{"sha": "6c022f732a934b61ab3fc7312bd3f2fc725d4223", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMwMjJmNzMyYTkzNGI2MWFiM2ZjNzMxMmJkM2YyZmM3MjVkNDIyMw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-02-14T15:54:09Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-02-14T15:54:09Z"}, "message": "re PR tree-optimization/79095 (spurious stringop-overflow warning)\n\n\tPR tree-optimization/79095\n\t* tree-vrp.c (extract_range_from_binary_expr_1): For EXACT_DIV_EXPR,\n\tif the numerator has the range ~[0,0] make the resultant range ~[0,0].\n\t(extract_range_from_binary_expr): For MINUS_EXPR with no derived range,\n\tif the operands are known to be not equal, then the resulting range\n\tis ~[0,0].\n\t(intersect_ranges): If the new range is ~[0,0] and the old range is\n\twide, then prefer ~[0,0].\n\t* tree-vrp.c (overflow_comparison_p_1): New function.\n\t(overflow_comparison_p): New function.\n\t* tree-vrp.c (register_edge_assert_for_2): Register additional asserts\n\tif NAME is used in an overflow test.\n\t(vrp_evaluate_conditional_warnv_with_ops): If the ops represent an\n\toverflow check that can be expressed as an equality test, then adjust\n\tops to be that equality test.\n\n\tPR tree-optimization/79095\n\t* g++.dg/pr79095-1.C: New test\n\t* g++.dg/pr79095-2.C: New test\n\t* g++.dg/pr79095-3.C: New test\n\t* g++.dg/pr79095-4.C: New test\n\t* g++.dg/pr79095-5.C: New test\n\t* gcc.c-torture/execute/arith-1.c: Update with more cases.\n\t* gcc.dg/tree-ssa/pr79095-1.c: New test.\n\nFrom-SVN: r245434", "tree": {"sha": "fc8cb29f5b36c3e8ce30d82c136db0ddb8829764", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc8cb29f5b36c3e8ce30d82c136db0ddb8829764"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c022f732a934b61ab3fc7312bd3f2fc725d4223", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c022f732a934b61ab3fc7312bd3f2fc725d4223", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c022f732a934b61ab3fc7312bd3f2fc725d4223", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c022f732a934b61ab3fc7312bd3f2fc725d4223/comments", "author": null, "committer": null, "parents": [{"sha": "c145a51018565e5e2fa61701998336a60911f849", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c145a51018565e5e2fa61701998336a60911f849", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c145a51018565e5e2fa61701998336a60911f849"}], "stats": {"total": 856, "additions": 855, "deletions": 1}, "files": [{"sha": "ba94c5380f80be9ef5ea5d7a4a7c26e30d5fb773", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c022f732a934b61ab3fc7312bd3f2fc725d4223", "patch": "@@ -1,3 +1,21 @@\n+2017-02-14 Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/79095\n+\t* tree-vrp.c (extract_range_from_binary_expr_1): For EXACT_DIV_EXPR,\n+\tif the numerator has the range ~[0,0] make the resultant range ~[0,0].\n+\t(extract_range_from_binary_expr): For MINUS_EXPR with no derived range,\n+\tif the operands are known to be not equal, then the resulting range\n+\tis ~[0,0].\n+\t(intersect_ranges): If the new range is ~[0,0] and the old range is\n+\twide, then prefer ~[0,0].\n+\t* tree-vrp.c (overflow_comparison_p_1): New function.\n+\t(overflow_comparison_p): New function.\n+\t* tree-vrp.c (register_edge_assert_for_2): Register additional asserts\n+\tif NAME is used in an overflow test.\n+\t(vrp_evaluate_conditional_warnv_with_ops): If the ops represent an\n+\toverflow check that can be expressed as an equality test, then adjust\n+\tops to be that equality test.\n+\n 2017-02-14  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* config/s390/s390-builtin-types.def: Remove flags argument."}, {"sha": "fb5b69d42984634f69140b2ab12cb49645871d8c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6c022f732a934b61ab3fc7312bd3f2fc725d4223", "patch": "@@ -1,3 +1,14 @@\n+2017-02-14  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/79095\n+\t* g++.dg/pr79095-1.C: New test\n+\t* g++.dg/pr79095-2.C: New test\n+\t* g++.dg/pr79095-3.C: New test\n+\t* g++.dg/pr79095-4.C: New test\n+\t* g++.dg/pr79095-5.C: New test\n+\t* gcc.c-torture/execute/arith-1.c: Update with more cases.\n+\t* gcc.dg/tree-ssa/pr79095-1.c: New test.\n+\n 2017-02-14  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* gcc.target/aarch64/vect_fp16_1.c: New."}, {"sha": "4b8043cbdb5dd72be80929f8c2bc1d7b1ac4bec4", "filename": "gcc/testsuite/g++.dg/pr79095-1.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr79095-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr79095-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr79095-1.C?ref=6c022f732a934b61ab3fc7312bd3f2fc725d4223", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall -O3\" } */\n+\n+typedef long unsigned int size_t;\n+\n+inline void\n+fill (int *p, size_t n, int)\n+{\n+  while (n--)\n+    *p++ = 0;\n+}\n+\n+struct B\n+{\n+  int* p0, *p1, *p2;\n+\n+  size_t size () const {\n+    return size_t (p1 - p0);\n+  }\n+\n+  void resize (size_t n) {\n+    if (n > size())\n+      append (n - size());\n+  }\n+\n+  void append (size_t n)\n+  {\n+    if (size_t (p2 - p1) >= n) \t {\n+      fill (p1, n, 0);\n+    }\n+  }\n+};\n+\n+void foo (B &b)\n+{\n+  if (b.size () != 0)\n+    b.resize (b.size () - 1);\n+}\n+\n+"}, {"sha": "9dabc7ee277f135ecd0056f2ff33bec25604555f", "filename": "gcc/testsuite/g++.dg/pr79095-2.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr79095-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr79095-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr79095-2.C?ref=6c022f732a934b61ab3fc7312bd3f2fc725d4223", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall -O3\" } */\n+\n+typedef long unsigned int size_t;\n+\n+inline void\n+fill (int *p, size_t n, int)\n+{\n+  while (n--)\n+    *p++ = 0;\n+}\n+\n+struct B\n+{\n+  int* p0, *p1, *p2;\n+\n+  size_t size () const {\n+    return size_t (p1 - p0);\n+  }\n+\n+  void resize (size_t n) {\n+    if (n > size())\n+      append (n - size());\n+  }\n+\n+  void append (size_t n)\n+  {\n+    if (size_t (p2 - p1) >= n) \t {\n+      fill (p1, n, 0);\n+    }\n+  }\n+};\n+\n+void foo (B &b)\n+{\n+    b.resize (b.size () - 1);\n+}\n+\n+/* If b.size() == 0, then the argument to b.resize is -1U (it overflowed).\n+   This will result calling \"fill\" which turns into a memset with a bogus\n+   length argument.  We want to make sure we warn, which multiple\n+   things.  First the ldist pass converted the loop into a memset,\n+   cprop and simplifications made the length a constant and the static\n+   analysis pass determines it's a bogus size to pass to memset.  */\n+/* { dg-warning \"exceeds maximum object size\" \"\" { target *-*-* } 0 } */ \n+"}, {"sha": "28c8a3768e61dbb83acb9789d08dcc908fcd4d2c", "filename": "gcc/testsuite/g++.dg/pr79095-3.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr79095-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr79095-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr79095-3.C?ref=6c022f732a934b61ab3fc7312bd3f2fc725d4223", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall -O3\" } */\n+\n+#include <vector>\n+\n+void foo(std::vector<unsigned int> &v);\n+\n+void vtest()\n+{\n+  std::vector<unsigned int> v;\n+  foo (v);\n+  if (v.size() > 0)\n+  {\n+    v.resize (v.size()-1);\n+  }\n+}\n+"}, {"sha": "df550257465274c5c048e9a21e70fb82e14a25e5", "filename": "gcc/testsuite/g++.dg/pr79095-4.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr79095-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr79095-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr79095-4.C?ref=6c022f732a934b61ab3fc7312bd3f2fc725d4223", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall -O3 -fdump-tree-vrp2\" } */\n+\n+#include <vector>\n+\n+void foo(std::vector<unsigned int> &v);\n+\n+void vtest()\n+{\n+  std::vector<unsigned int> v;\n+  foo (v);\n+  {\n+    v.resize (v.size()-1);\n+  }\n+}\n+\n+/* As written this testcase should trigger a warning.  We overflow to -1U\n+   if v.size() == 0 in foo().  This results in bogus calls to memset.\n+\n+   The number of clearing loops in the IL can vary depending on the C++\n+   mode used for the test.  But by the end of VRP2, there should be a single\n+   clearing loop left and it should be using memcpy.  */\n+/* { dg-final { scan-tree-dump-times  \"__builtin_memset \\\\(_\\[0-9\\]+, 0, \\[0-9\\]+\\\\)\" 1 \"vrp2\" } } */\n+\n+/* And that call should trigger a warning.  */\n+/* { dg-warning \"exceeds maximum object size\" \"\" { target *-*-* } 0 } */ "}, {"sha": "266f4e9b15e820f9237ab51d775c3ccb46338dab", "filename": "gcc/testsuite/g++.dg/pr79095-5.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr79095-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr79095-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr79095-5.C?ref=6c022f732a934b61ab3fc7312bd3f2fc725d4223", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall -O3\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+struct S {\n+  int *p0, *p1, *p2;\n+\n+  size_t size () const { return p1 - p0; }\n+\n+  void f (size_t n) {\n+    if (n > size ())       // can't happen because\n+      foo (n - size ());   //   n is in [1, MIN(size() - 1, 3)]\n+    else if (n < size ())\n+      bar (p0 + n);\n+  }\n+\n+  void foo (size_t n)\n+  {\n+    size_t left = (size_t)(p2 - p1);\n+    if (left >= n)\n+      __builtin_memset (p2, 0, n * sizeof *p2); // { dg-bogus \"maximum object size\" }\n+\n+  }\n+\n+  void bar (int*);\n+};\n+\n+void f (S &s)\n+{\n+  size_t n = s.size ();\n+  if (n > 1 && n < 5)\n+    s.f (n - 1);\n+}"}, {"sha": "6168d77af670d113519f4a4fd7a1a35463aebf94", "filename": "gcc/testsuite/gcc.c-torture/execute/arith-1.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Farith-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Farith-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Farith-1.c?ref=6c022f732a934b61ab3fc7312bd3f2fc725d4223", "patch": "@@ -7,9 +7,41 @@ sat_add (unsigned i)\n   return ret;\n }\n \n+unsigned\n+sat_add2 (unsigned i)\n+{\n+  unsigned ret = i + 1;\n+  if (ret > i)\n+    return ret;\n+  return i;\n+}\n+\n+unsigned\n+sat_add3 (unsigned i)\n+{\n+  unsigned ret = i - 1;\n+  if (ret > i)\n+    ret = i;\n+  return ret;\n+}\n+\n+unsigned\n+sat_add4 (unsigned i)\n+{\n+  unsigned ret = i - 1;\n+  if (ret < i)\n+    return ret;\n+  return i;\n+}\n main ()\n {\n   if (sat_add (~0U) != ~0U)\n     abort ();\n+  if (sat_add2 (~0U) != ~0U)\n+    abort ();\n+  if (sat_add3 (0U) != 0U)\n+    abort ();\n+  if (sat_add4 (0U) != 0U)\n+    abort ();\n   exit (0);\n }"}, {"sha": "f635fcafe4f792885979fc1a157d24e62ed64be0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr79095.c", "status": "added", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79095.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79095.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79095.c?ref=6c022f732a934b61ab3fc7312bd3f2fc725d4223", "patch": "@@ -0,0 +1,436 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-ipa-icf -fdump-tree-vrp1\" } */\n+\n+extern void arf (unsigned x, unsigned y);\n+extern void baz (unsigned x, unsigned y);\n+\n+unsigned\n+f1 (unsigned a, unsigned b)\n+{\n+  b = a + 1;\n+  if (b < a)\n+    {\n+      arf (a, b);\n+      return 42;\n+    }\n+  baz (a, b);\n+  return b;\n+}\n+\n+\n+unsigned\n+f1r (unsigned a, unsigned b)\n+{\n+  b = a + 1;\n+  if (a < b)\n+    {\n+      baz (a, b);\n+      return 42;\n+    }\n+  arf (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f1n (unsigned a, unsigned b)\n+{\n+  b = a + 1;\n+  if (!(b < a))\n+    {\n+      baz (a, b);\n+      return 42;\n+    }\n+  arf (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f1nr (unsigned a, unsigned b)\n+{\n+  b = a + 1;\n+  if (!(a < b))\n+    {\n+      arf (a, b);\n+      return 42;\n+    }\n+  baz (a, b);\n+  return b;\n+}\n+\n+\n+unsigned\n+f1o (unsigned a, unsigned b)\n+{\n+  b = a + 1;\n+  if (a < b)\n+    {\n+      baz (a, b);\n+      return 42;\n+    }\n+  arf (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f1ro (unsigned a, unsigned b)\n+{\n+  b = a + 1;\n+  if (b < a)\n+    {\n+      arf (a, b);\n+      return 42;\n+    }\n+  baz (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f1no (unsigned a, unsigned b)\n+{\n+  b = a + 1;\n+  if (!(a < b))\n+    {\n+      arf (a, b);\n+      return 42;\n+    }\n+  baz (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f1nro (unsigned a, unsigned b)\n+{\n+  b = a + 1;\n+  if (!(b < a))\n+    {\n+      baz (a, b);\n+      return 42;\n+    }\n+  arf (a, b);\n+  return b;\n+}\n+\n+\n+unsigned\n+f2 (unsigned a, unsigned b)\n+{\n+  b = a + 1;\n+  if (b <= a)\n+    {\n+      arf (a, b);\n+      return 42;\n+    }\n+  baz (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f2r (unsigned a, unsigned b)\n+{\n+  b = a + 1;\n+  if (a <= b)\n+    {\n+      baz (a, b);\n+      return 42;\n+    }\n+  arf (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f2n (unsigned a, unsigned b)\n+{\n+  b = a + 1;\n+  if (!(b <= a))\n+    {\n+      baz (a, b);\n+      return 42;\n+    }\n+  arf (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f2nr (unsigned a, unsigned b)\n+{\n+  b = a + 1;\n+  if (!(a <= b))\n+    {\n+      arf (a, b);\n+      return 42;\n+    }\n+  baz (a, b);\n+  return b;\n+}\n+\n+\n+unsigned\n+f2o (unsigned a, unsigned b)\n+{\n+  b = a + 1;\n+  if (a <= b)\n+    {\n+      baz (a, b);\n+      return 42;\n+    }\n+  arf (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f2ro (unsigned a, unsigned b)\n+{\n+  b = a + 1;\n+  if (b <= a)\n+    {\n+      arf (a, b);\n+      return 42;\n+    }\n+  baz (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f2no (unsigned a, unsigned b)\n+{\n+  b = a + 1;\n+  if (!(a <= b))\n+    {\n+      arf (a, b);\n+      return 42;\n+    }\n+  baz (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f2nro (unsigned a, unsigned b)\n+{\n+  b = a + 1;\n+  if (!(b <= a))\n+    {\n+      baz (a, b);\n+      return 42;\n+    }\n+  arf (a, b);\n+  return b;\n+}\n+\n+\n+unsigned\n+f3 (unsigned a, unsigned b)\n+{\n+  b = a - 1;\n+  if (b < a)\n+    {\n+      baz (a, b);\n+      return 42;\n+    }\n+  arf (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f3r (unsigned a, unsigned b)\n+{\n+  b = a - 1;\n+  if (a < b)\n+    {\n+      arf (a, b);\n+      return 42;\n+    }\n+  baz (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f3n (unsigned a, unsigned b)\n+{\n+  b = a - 1;\n+  if (!(b < a))\n+    {\n+      arf (a, b);\n+      return 42;\n+    }\n+  baz (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f3nr (unsigned a, unsigned b)\n+{\n+  b = a - 1;\n+  if (!(a < b))\n+    {\n+      baz (a, b);\n+      return 42;\n+    }\n+  arf (a, b);\n+  return b;\n+}\n+\n+\n+unsigned\n+f3o (unsigned a, unsigned b)\n+{\n+  b = a - 1;\n+  if (a < b)\n+    {\n+      arf (a, b);\n+      return 42;\n+    }\n+  baz (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f3ro (unsigned a, unsigned b)\n+{\n+  b = a - 1;\n+  if (b < a)\n+    {\n+      baz (a, b);\n+      return 42;\n+    }\n+  arf (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f3no (unsigned a, unsigned b)\n+{\n+  b = a - 1;\n+  if (!(a < b))\n+    {\n+      baz (a, b);\n+      return 42;\n+    }\n+  arf (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f3nro (unsigned a, unsigned b)\n+{\n+  b = a - 1;\n+  if (!(b < a))\n+    {\n+      arf (a, b);\n+      return 42;\n+    }\n+  baz (a, b);\n+  return b;\n+}\n+\n+\n+unsigned\n+f4 (unsigned a, unsigned b)\n+{\n+  b = a - 1;\n+  if (b <= a)\n+    {\n+      baz (a, b);\n+      return 42;\n+    }\n+  arf (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f4r (unsigned a, unsigned b)\n+{\n+  b = a - 1;\n+  if (a <= b)\n+    {\n+      arf (a, b);\n+      return 42;\n+    }\n+  baz (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f4n (unsigned a, unsigned b)\n+{\n+  b = a - 1;\n+  if (!(b <= a))\n+    {\n+      arf (a, b);\n+      return 42;\n+    }\n+  baz (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f4nr (unsigned a, unsigned b)\n+{\n+  b = a - 1;\n+  if (!(a <= b))\n+    {\n+      baz (a, b);\n+      return 42;\n+    }\n+  arf (a, b);\n+  return b;\n+}\n+\n+\n+unsigned\n+f4o (unsigned a, unsigned b)\n+{\n+  b = a - 1;\n+  if (a <= b)\n+    {\n+      arf (a, b);\n+      return 42;\n+    }\n+  baz (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f4ro (unsigned a, unsigned b)\n+{\n+  b = a - 1;\n+  if (b <= a)\n+    {\n+      baz (a, b);\n+      return 42;\n+    }\n+  arf (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f4no (unsigned a, unsigned b)\n+{\n+  b = a - 1;\n+  if (!(a <= b))\n+    {\n+      baz (a, b);\n+      return 42;\n+    }\n+  arf (a, b);\n+  return b;\n+}\n+\n+unsigned\n+f4nro (unsigned a, unsigned b)\n+{\n+  b = a - 1;\n+  if (!(b <= a))\n+    {\n+      arf (a, b);\n+      return 42;\n+    }\n+  baz (a, b);\n+  return b;\n+}\n+\n+/* All calls to baz should still reference a & b as arguments. */\n+/* { dg-final { scan-tree-dump-times \"baz \\\\(a_\\[0-9\\]+\\\\(D\\\\), b_\\[0-9\\]+\\\\)\" 32 \"vrp1\"} } */\n+\n+\n+/* All calls to arf should have constant arguments.  */\n+/* { dg-final { scan-tree-dump-times \"arf \\\\(\\[0-9\\]+, \\[0-9\\]+\\\\)\" 32 \"vrp1\"} } */"}, {"sha": "95bf1cf86969f78bec11659fdb92b6b7e4fec368", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 195, "deletions": 1, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c022f732a934b61ab3fc7312bd3f2fc725d4223/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=6c022f732a934b61ab3fc7312bd3f2fc725d4223", "patch": "@@ -2259,6 +2259,19 @@ extract_range_from_binary_expr_1 (value_range *vr,\n   else if (vr1.type == VR_UNDEFINED)\n     set_value_range_to_varying (&vr1);\n \n+  /* We get imprecise results from ranges_from_anti_range when\n+     code is EXACT_DIV_EXPR.  We could mask out bits in the resulting\n+     range, but then we also need to hack up vrp_meet.  It's just\n+     easier to special case when vr0 is ~[0,0] for EXACT_DIV_EXPR.  */\n+  if (code == EXACT_DIV_EXPR\n+      && vr0.type == VR_ANTI_RANGE\n+      && vr0.min == vr0.max\n+      && integer_zerop (vr0.min))\n+    {\n+      set_value_range_to_nonnull (vr, expr_type);\n+      return;\n+    }\n+\n   /* Now canonicalize anti-ranges to ranges when they are not symbolic\n      and express ~[] op X as ([]' op X) U ([]'' op X).  */\n   if (vr0.type == VR_ANTI_RANGE\n@@ -3298,6 +3311,21 @@ extract_range_from_binary_expr (value_range *vr,\n \n       extract_range_from_binary_expr_1 (vr, code, expr_type, &n_vr0, &vr1);\n     }\n+\n+  /* If we didn't derive a range for MINUS_EXPR, and\n+     op1's range is ~[op0,op0] or vice-versa, then we\n+     can derive a non-null range.  This happens often for\n+     pointer subtraction.  */\n+  if (vr->type == VR_VARYING\n+      && code == MINUS_EXPR\n+      && TREE_CODE (op0) == SSA_NAME\n+      && ((vr0.type == VR_ANTI_RANGE\n+\t   && vr0.min == op1\n+\t   && vr0.min == vr0.max)\n+\t  || (vr1.type == VR_ANTI_RANGE\n+\t      && vr1.min == op0\n+\t      && vr1.min == vr1.max)))\n+      set_value_range_to_nonnull (vr, TREE_TYPE (op0));\n }\n \n /* Extract range information from a unary operation CODE based on\n@@ -5158,6 +5186,118 @@ masked_increment (const wide_int &val_in, const wide_int &mask,\n   return val ^ sgnbit;\n }\n \n+/* Helper for overflow_comparison_p\n+\n+   OP0 CODE OP1 is a comparison.  Examine the comparison and potentially\n+   OP1's defining statement to see if it ultimately has the form\n+   OP0 CODE (OP0 PLUS INTEGER_CST)\n+\n+   If so, return TRUE indicating this is an overflow test and store into\n+   *NEW_CST an updated constant that can be used in a narrowed range test.\n+\n+   REVERSED indicates if the comparison was originally:\n+\n+   OP1 CODE' OP0.\n+\n+   This affects how we build the updated constant.  */\n+\n+static bool\n+overflow_comparison_p_1 (enum tree_code code, tree op0, tree op1,\n+\t\t         bool follow_assert_exprs, bool reversed, tree *new_cst)\n+{\n+  /* See if this is a relational operation between two SSA_NAMES with\n+     unsigned, overflow wrapping values.  If so, check it more deeply.  */\n+  if ((code == LT_EXPR || code == LE_EXPR\n+       || code == GE_EXPR || code == GT_EXPR)\n+      && TREE_CODE (op0) == SSA_NAME\n+      && TREE_CODE (op1) == SSA_NAME\n+      && INTEGRAL_TYPE_P (TREE_TYPE (op0))\n+      && TYPE_UNSIGNED (TREE_TYPE (op0))\n+      && TYPE_OVERFLOW_WRAPS (TREE_TYPE (op0)))\n+    {\n+      gimple *op1_def = SSA_NAME_DEF_STMT (op1);\n+\n+      /* If requested, follow any ASSERT_EXPRs backwards for OP1.  */\n+      if (follow_assert_exprs)\n+\t{\n+\t  while (gimple_assign_single_p (op1_def)\n+\t\t && TREE_CODE (gimple_assign_rhs1 (op1_def)) == ASSERT_EXPR)\n+\t    {\n+\t      op1 = TREE_OPERAND (gimple_assign_rhs1 (op1_def), 0);\n+\t      if (TREE_CODE (op1) != SSA_NAME)\n+\t\tbreak;\n+\t      op1_def = SSA_NAME_DEF_STMT (op1);\n+\t    }\n+\t}\n+\n+      /* Now look at the defining statement of OP1 to see if it adds\n+\t or subtracts a nonzero constant from another operand.  */\n+      if (op1_def\n+\t  && is_gimple_assign (op1_def)\n+\t  && gimple_assign_rhs_code (op1_def) == PLUS_EXPR\n+\t  && TREE_CODE (gimple_assign_rhs2 (op1_def)) == INTEGER_CST\n+\t  && !integer_zerop (gimple_assign_rhs2 (op1_def)))\n+\t{\n+\t  tree target = gimple_assign_rhs1 (op1_def);\n+\n+\t  /* If requested, follow ASSERT_EXPRs backwards for op0 looking\n+\t     for one where TARGET appears on the RHS.  */\n+\t  if (follow_assert_exprs)\n+\t    {\n+\t      /* Now see if that \"other operand\" is op0, following the chain\n+\t\t of ASSERT_EXPRs if necessary.  */\n+\t      gimple *op0_def = SSA_NAME_DEF_STMT (op0);\n+\t      while (op0 != target\n+\t\t     && gimple_assign_single_p (op0_def)\n+\t\t     && TREE_CODE (gimple_assign_rhs1 (op0_def)) == ASSERT_EXPR)\n+\t\t{\n+\t\t  op0 = TREE_OPERAND (gimple_assign_rhs1 (op0_def), 0);\n+\t\t  if (TREE_CODE (op0) != SSA_NAME)\n+\t\t    break;\n+\t\t  op0_def = SSA_NAME_DEF_STMT (op0);\n+\t\t}\n+\t    }\n+\n+\t  /* If we did not find our target SSA_NAME, then this is not\n+\t     an overflow test.  */\n+\t  if (op0 != target)\n+\t    return false;\n+\n+\t  tree type = TREE_TYPE (op0);\n+\t  wide_int max = wi::max_value (TYPE_PRECISION (type), UNSIGNED);\n+\t  tree inc = gimple_assign_rhs2 (op1_def);\n+\t  if (reversed)\n+\t    *new_cst = wide_int_to_tree (type, max + inc);\n+\t  else\n+\t    *new_cst = wide_int_to_tree (type, max - inc);\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* OP0 CODE OP1 is a comparison.  Examine the comparison and potentially\n+   OP1's defining statement to see if it ultimately has the form\n+   OP0 CODE (OP0 PLUS INTEGER_CST)\n+\n+   If so, return TRUE indicating this is an overflow test and store into\n+   *NEW_CST an updated constant that can be used in a narrowed range test.\n+\n+   These statements are left as-is in the IL to facilitate discovery of\n+   {ADD,SUB}_OVERFLOW sequences later in the optimizer pipeline.  But\n+   the alternate range representation is often useful within VRP.  */\n+\n+static bool\n+overflow_comparison_p (tree_code code, tree name, tree val,\n+\t\t       bool use_equiv_p, tree *new_cst)\n+{\n+  if (overflow_comparison_p_1 (code, name, val, use_equiv_p, false, new_cst))\n+    return true;\n+  return overflow_comparison_p_1 (swap_tree_comparison (code), val, name,\n+\t\t\t\t  use_equiv_p, true, new_cst);\n+}\n+\n+\n /* Try to register an edge assertion for SSA name NAME on edge E for\n    the condition COND contributing to the conditional jump pointed to by BSI.\n    Invert the condition COND if INVERT is true.  */\n@@ -5179,7 +5319,17 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n   /* Only register an ASSERT_EXPR if NAME was found in the sub-graph\n      reachable from E.  */\n   if (live_on_edge (e, name))\n-    register_new_assert_for (name, name, comp_code, val, NULL, e, bsi);\n+    {\n+      tree x;\n+      if (overflow_comparison_p (comp_code, name, val, false, &x))\n+\t{\n+\t  enum tree_code new_code\n+\t    = ((comp_code == GT_EXPR || comp_code == GE_EXPR)\n+\t       ? GT_EXPR : LE_EXPR);\n+\t  register_new_assert_for (name, name, new_code, x, NULL, e, bsi);\n+\t}\n+      register_new_assert_for (name, name, comp_code, val, NULL, e, bsi);\n+    }\n \n   /* In the case of NAME <= CST and NAME being defined as\n      NAME = (unsigned) NAME2 + CST2 we can assert NAME2 >= -CST2\n@@ -7538,6 +7688,39 @@ vrp_evaluate_conditional_warnv_with_ops (enum tree_code code, tree op0,\n       && !POINTER_TYPE_P (TREE_TYPE (op0)))\n     return NULL_TREE;\n \n+  /* If OP0 CODE OP1 is an overflow comparison, if it can be expressed\n+     as a simple equality test, then prefer that over its current form\n+     for evaluation.\n+\n+     An overflow test which collapses to an equality test can always be\n+     expressed as a comparison of one argument against zero.  Overflow\n+     occurs when the chosen argument is zero and does not occur if the\n+     chosen argument is not zero.  */\n+  tree x;\n+  if (overflow_comparison_p (code, op0, op1, use_equiv_p, &x))\n+    {\n+      wide_int max = wi::max_value (TYPE_PRECISION (TREE_TYPE (op0)), UNSIGNED);\n+      /* B = A - 1; if (A < B) -> B = A - 1; if (A == 0)\n+         B = A - 1; if (A > B) -> B = A - 1; if (A != 0)\n+         B = A + 1; if (B < A) -> B = A + 1; if (B == 0)\n+         B = A + 1; if (B > A) -> B = A + 1; if (B != 0) */\n+      if (integer_zerop (x))\n+\t{\n+\t  op1 = x;\n+\t  code = (code == LT_EXPR || code == LE_EXPR) ? EQ_EXPR : NE_EXPR;\n+\t}\n+      /* B = A + 1; if (A > B) -> B = A + 1; if (B == 0)\n+         B = A + 1; if (A < B) -> B = A + 1; if (B != 0)\n+         B = A - 1; if (B > A) -> B = A - 1; if (A == 0)\n+         B = A - 1; if (B < A) -> B = A - 1; if (A != 0) */\n+      else if (wi::eq_p (x, max - 1))\n+\t{\n+\t  op0 = op1;\n+\t  op1 = wide_int_to_tree (TREE_TYPE (op0), 0);\n+\t  code = (code == GT_EXPR || code == GE_EXPR) ? EQ_EXPR : NE_EXPR;\n+\t}\n+    }\n+\n   if ((ret = vrp_evaluate_conditional_warnv_with_ops_using_ranges\n \t       (code, op0, op1, strict_overflow_p)))\n     return ret;\n@@ -8620,6 +8803,17 @@ intersect_ranges (enum value_range_type *vr0type,\n \t  else if (vrp_val_is_min (vr1min)\n \t\t   && vrp_val_is_max (vr1max))\n \t    ;\n+\t  /* Choose the anti-range if it is ~[0,0], that range is special\n+\t     enough to special case when vr1's range is relatively wide.  */\n+\t  else if (*vr0min == *vr0max\n+\t\t   && integer_zerop (*vr0min)\n+\t\t   && (TYPE_PRECISION (TREE_TYPE (*vr0min))\n+\t\t       == TYPE_PRECISION (ptr_type_node))\n+\t\t   && TREE_CODE (vr1max) == INTEGER_CST\n+\t\t   && TREE_CODE (vr1min) == INTEGER_CST\n+\t\t   && (wi::clz (wi::sub (vr1max, vr1min))\n+\t\t       < TYPE_PRECISION (TREE_TYPE (*vr0min)) / 2))\n+\t    ;\n \t  /* Else choose the range.  */\n \t  else\n \t    {"}]}