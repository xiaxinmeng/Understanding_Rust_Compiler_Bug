{"sha": "81d87bcc58c3f7e0b91f7ce5e6b08e635a8fb032", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFkODdiY2M1OGMzZjdlMGI5MWY3Y2U1ZTZiMDhlNjM1YThmYjAzMg==", "commit": {"author": {"name": "Stan Shebs", "email": "shebs@apple.com", "date": "2001-05-28T01:01:10Z"}, "committer": {"name": "Stan Shebs", "email": "shebs@gcc.gnu.org", "date": "2001-05-28T01:01:10Z"}, "message": "objc-act.c: Add/fix various comments.\n\n\t* objc/objc-act.c: Add/fix various comments.\n\t(init_selector): Remove, no longer used.\n\t(build_msg_pool_reference): Ditto.\n\t(objc_debug): Ditto.\n\nFrom-SVN: r42666", "tree": {"sha": "a1eb2ed3856af0ceafce7cf387fd60d025bfed9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1eb2ed3856af0ceafce7cf387fd60d025bfed9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81d87bcc58c3f7e0b91f7ce5e6b08e635a8fb032", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81d87bcc58c3f7e0b91f7ce5e6b08e635a8fb032", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81d87bcc58c3f7e0b91f7ce5e6b08e635a8fb032", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81d87bcc58c3f7e0b91f7ce5e6b08e635a8fb032/comments", "author": null, "committer": null, "parents": [{"sha": "84b7783609980a52d9b4471bc3c558ea862dcb62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84b7783609980a52d9b4471bc3c558ea862dcb62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84b7783609980a52d9b4471bc3c558ea862dcb62"}], "stats": {"total": 135, "additions": 15, "deletions": 120}, "files": [{"sha": "7de42117ec070194e171a5ebf24a82a306bdf3f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81d87bcc58c3f7e0b91f7ce5e6b08e635a8fb032/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81d87bcc58c3f7e0b91f7ce5e6b08e635a8fb032/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81d87bcc58c3f7e0b91f7ce5e6b08e635a8fb032", "patch": "@@ -1,3 +1,10 @@\n+2001-05-27  Stan Shebs  <shebs@apple.com>\n+\n+\t* objc/objc-act.c: Add/fix various comments.\n+\t(init_selector): Remove, no longer used.\n+\t(build_msg_pool_reference): Ditto.\n+\t(objc_debug): Ditto.\n+\n 2001-05-27  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* c-decl.c (init_decl_processing):"}, {"sha": "1ef1199c53183f8e82e1b8e7626447ab9ffa5351", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 8, "deletions": 120, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81d87bcc58c3f7e0b91f7ce5e6b08e635a8fb032/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81d87bcc58c3f7e0b91f7ce5e6b08e635a8fb032/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=81d87bcc58c3f7e0b91f7ce5e6b08e635a8fb032", "patch": "@@ -87,8 +87,7 @@ Boston, MA 02111-1307, USA.  */\n /* Define the special tree codes that we use.  */\n \n /* Table indexed by tree code giving a string containing a character\n-   classifying the tree code.  Possibilities are\n-   t, d, s, c, r, <, 1 and 2.  See objc-tree.def for details.  */\n+   classifying the tree code.  */\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n \n@@ -136,9 +135,14 @@ char *util_firstobj;\n /* for encode_method_def */\n #include \"rtl.h\"\n \n+/* The version identifies which language generation and runtime\n+   the module (file) was compiled for, and is recorded in the\n+   module descriptor.  */\n+\n #define OBJC_VERSION\t(flag_next_runtime ? 5 : 8)\n #define PROTOCOL_VERSION 2\n \n+/* (Decide if these can ever be validly changed.) */\n #define OBJC_ENCODE_INLINE_DEFS \t0\n #define OBJC_ENCODE_DONT_INLINE_DEFS\t1\n \n@@ -191,9 +195,6 @@ static tree generate_protocol_list\t\tPARAMS ((tree));\n static void generate_forward_declaration_to_string_table PARAMS ((void));\n static void build_protocol_reference\t\tPARAMS ((tree));\n \n-#if 0\n-static tree init_selector\t\t\tPARAMS ((int));\n-#endif\n static tree build_keyword_selector\t\tPARAMS ((tree));\n static tree synth_id_with_class_suffix\t\tPARAMS ((const char *, tree));\n \n@@ -297,9 +298,6 @@ static tree init_objc_symtab\t\t\tPARAMS ((tree));\n static void forward_declare_categories\t\tPARAMS ((void));\n static void generate_objc_symtab_decl\t\tPARAMS ((void));\n static tree build_selector\t\t\tPARAMS ((tree));\n-#if 0\n-static tree build_msg_pool_reference\t\tPARAMS ((int));\n-#endif\n static tree build_typed_selector_reference     \tPARAMS ((tree, tree));\n static tree build_selector_reference\t\tPARAMS ((tree));\n static tree build_class_reference_decl\t\tPARAMS ((void));\n@@ -674,7 +672,7 @@ generate_struct_by_value_array ()\n   int aggregate_in_mem[32];\n   int found = 0;\n \n-  /* Presumbaly no platform passes 32 byte structures in a register. */\n+  /* Presumably no platform passes 32 byte structures in a register. */\n   for (i = 1; i < 32; i++)\n     {\n       char buffer[5];\n@@ -2147,39 +2145,6 @@ build_selector (ident)\n     return build_c_cast (selector_type, expr); /* cast! */\n }\n \n-/* Synthesize the following expr: (char *)&_OBJC_STRINGS[<offset>]\n-   The cast stops the compiler from issuing the following message:\n-   grok.m: warning: initialization of non-const * pointer from const *\n-   grok.m: warning: initialization between incompatible pointer types.  */\n-\n-#if 0\n-static tree\n-build_msg_pool_reference (offset)\n-     int offset;\n-{\n-  tree expr = build_int_2 (offset, 0);\n-  tree cast;\n-\n-  expr = build_array_ref (UOBJC_STRINGS_decl, expr);\n-  expr = build_unary_op (ADDR_EXPR, expr, 0);\n-\n-  cast = build_tree_list (build_tree_list (NULL_TREE,\n-\t\t\t\t\t   ridpointers[(int) RID_CHAR]),\n-\t\t\t  build1 (INDIRECT_REF, NULL_TREE, NULL_TREE));\n-  TREE_TYPE (expr) = groktypename (cast);\n-  return expr;\n-}\n-\n-static tree\n-init_selector (offset)\n-     int offset;\n-{\n-  tree expr = build_msg_pool_reference (offset);\n-  TREE_TYPE (expr) = selector_type;\n-  return expr;\n-}\n-#endif\n-\n static void\n build_selector_translation_table ()\n {\n@@ -2425,13 +2390,7 @@ get_class_reference (ident)\n     }\n }\n \n-/* SEL_REFDEF_CHAIN is a list whose \"value\" fields will be instances\n-   of identifier_node that represent the selector. It returns the\n-   offset of the selector from the beginning of the _OBJC_STRINGS\n-   pool. This offset is typically used by init_selector during code\n-   generation.\n-\n-   For each string section we have a chain which maps identifier nodes\n+/* For each string section we have a chain which maps identifier nodes\n    to decls for the strings.  */\n \n static tree\n@@ -8517,77 +8476,6 @@ handle_impent (impent)\n     }\n }\n \f\n-#ifdef DEBUG\n-\n-static void\n-objc_debug (fp)\n-     FILE *fp;\n-{\n-  char *buf = (char *)xmalloc (256);\n-\n-  {\t\t\t\t/* dump function prototypes */\n-    tree loop = UOBJC_MODULES_decl;\n-\n-    fprintf (fp, \"\\n\\nfunction prototypes:\\n\");\n-    while (loop)\n-      {\n-\tif (TREE_CODE (loop) == FUNCTION_DECL && DECL_INITIAL (loop))\n-\t  {\n-\t    /* We have a function definition: generate prototype.  */\n-\t    fprintf (fp, \"%s;\\n\", gen_declaration (loop, errbuf));\n-\t  }\n-\tloop = TREE_CHAIN (loop);\n-      }\n-  }\n-  {\n-    /* Dump global chains.  */\n-    tree loop;\n-    int i, index = 0, offset = 0;\n-    hash hashlist;\n-\n-    for (i = 0; i < SIZEHASHTABLE; i++)\n-      {\n-\tif (hashlist = nst_method_hash_list[i])\n-\t  {\n-\t    fprintf (fp, \"\\n\\nnst_method_hash_list[%d]:\\n\", i);\n-\t    do\n-\t      {\n-\t\tfprintf (fp, \"-%s;\\n\", gen_method_decl (hashlist->key, buf));\n-\t\thashlist = hashlist->next;\n-\t      }\n-\t    while (hashlist);\n-\t  }\n-      }\n-\n-    for (i = 0; i < SIZEHASHTABLE; i++)\n-      {\n-\tif (hashlist = cls_method_hash_list[i])\n-\t  {\n-\t    fprintf (fp, \"\\n\\ncls_method_hash_list[%d]:\\n\", i);\n-\t    do\n-\t      {\n-\t\tfprintf (fp, \"-%s;\\n\", gen_method_decl (hashlist->key, buf));\n-\t\thashlist = hashlist->next;\n-\t      }\n-\t    while (hashlist);\n-\t  }\n-      }\n-\n-    fprintf (fp, \"\\nsel_refdef_chain:\\n\");\n-    for (loop = sel_refdef_chain; loop; loop = TREE_CHAIN (loop))\n-      {\n-\tfprintf (fp, \"(index: %4d offset: %4d) %s\\n\", index, offset,\n-\t\t IDENTIFIER_POINTER (TREE_VALUE (loop)));\n-\tindex++;\n-\t/* add one for the '\\0' character */\n-\toffset += IDENTIFIER_LENGTH (TREE_VALUE (loop)) + 1;\n-      }\n-\n-    fprintf (fp, \"\\n (max_selector_index: %4d.\\n\", max_selector_index);\n-  }\n-}\n-#endif\n-\n void\n print_lang_statistics ()\n {"}]}