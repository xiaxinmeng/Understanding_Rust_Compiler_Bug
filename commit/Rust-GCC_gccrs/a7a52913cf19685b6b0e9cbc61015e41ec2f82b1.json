{"sha": "a7a52913cf19685b6b0e9cbc61015e41ec2f82b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdhNTI5MTNjZjE5Njg1YjZiMGU5Y2JjNjEwMTVlNDFlYzJmODJiMQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2005-01-31T13:37:37Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2005-01-31T13:37:37Z"}, "message": "linux-unwind.h (struct gcc_vregs): New.\n\n\t* config/rs6000/linux-unwind.h (struct gcc_vregs): New.\n\t(struct gcc_regs): Rename from gcc_pt_regs.  Add more regs.\n\t(struct gcc_sigcontext): Delete.  Merge contents to..\n\t(struct gcc_ucontext): ..here.\n\t(get_sigcontext): Delete.\n\t(get_regs): New function, like get_sigcontext but return regs ptr.\n\t64-bit version finds regs from r1 to support vdso.\n\t(ppc_linux_aux_vector): New function.\n\t(ppc_fallback_frame_state): Modify for get_regs.  Restore fprs\n\tand vector regs.\n\nFrom-SVN: r94481", "tree": {"sha": "2711321640270fb38a9c4b9736f14000fd02abb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2711321640270fb38a9c4b9736f14000fd02abb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7a52913cf19685b6b0e9cbc61015e41ec2f82b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7a52913cf19685b6b0e9cbc61015e41ec2f82b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7a52913cf19685b6b0e9cbc61015e41ec2f82b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7a52913cf19685b6b0e9cbc61015e41ec2f82b1/comments", "author": null, "committer": null, "parents": [{"sha": "261ba0c8dbb450cc88a56e6869f962964d6e9e91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/261ba0c8dbb450cc88a56e6869f962964d6e9e91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/261ba0c8dbb450cc88a56e6869f962964d6e9e91"}], "stats": {"total": 231, "additions": 184, "deletions": 47}, "files": [{"sha": "2a39cfd1727a9eae72f88943014b08ed3d22dd73", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a52913cf19685b6b0e9cbc61015e41ec2f82b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a52913cf19685b6b0e9cbc61015e41ec2f82b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7a52913cf19685b6b0e9cbc61015e41ec2f82b1", "patch": "@@ -1,3 +1,16 @@\n+2005-01-31  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* config/rs6000/linux-unwind.h (struct gcc_vregs): New.\n+\t(struct gcc_regs): Rename from gcc_pt_regs.  Add more regs.\n+\t(struct gcc_sigcontext): Delete.  Merge contents to..\n+\t(struct gcc_ucontext): ..here.\n+\t(get_sigcontext): Delete.\n+\t(get_regs): New function, like get_sigcontext but return regs ptr.\n+\t64-bit version finds regs from r1 to support vdso.\n+\t(ppc_linux_aux_vector): New function.\n+\t(ppc_fallback_frame_state): Modify for get_regs.  Restore fprs\n+\tand vector regs.\n+\n 2005-01-31  Ira Rosen  <irar@il.ibm.com>\n \n \t* tree-vectorizer.c (vect_analyze_offset_expr): Use ssizetype instead"}, {"sha": "3e12cc691aecbcc9b934b30419aa771bb684dc7f", "filename": "gcc/config/rs6000/linux-unwind.h", "status": "modified", "additions": 171, "deletions": 47, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a52913cf19685b6b0e9cbc61015e41ec2f82b1/gcc%2Fconfig%2Frs6000%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a52913cf19685b6b0e9cbc61015e41ec2f82b1/gcc%2Fconfig%2Frs6000%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux-unwind.h?ref=a7a52913cf19685b6b0e9cbc61015e41ec2f82b1", "patch": "@@ -1,5 +1,5 @@\n /* DWARF2 EH unwinding support for PowerPC and PowerPC64 Linux.\n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -24,7 +24,22 @@\n    these structs elsewhere;  Many fields are missing, particularly\n    from the end of the structures.  */\n \n-struct gcc_pt_regs\n+struct gcc_vregs\n+{\n+  __attribute__ ((vector_size (16))) int vr[32];\n+#ifdef __powerpc64__\n+  unsigned int pad1[3];\n+  unsigned int vscr;\n+  unsigned int vsave;\n+  unsigned int pad2[3];\n+#else\n+  unsigned int vsave;\n+  unsigned int pad[2];\n+  unsigned int vscr;\n+#endif\n+};\n+\n+struct gcc_regs\n {\n   unsigned long gpr[32];\n   unsigned long nip;\n@@ -34,22 +49,32 @@ struct gcc_pt_regs\n   unsigned long link;\n   unsigned long xer;\n   unsigned long ccr;\n-};\n-\n-struct gcc_sigcontext\n-{\n-  unsigned long\tpad[7];\n-  struct gcc_pt_regs *regs;\n+  unsigned long softe;\n+  unsigned long trap;\n+  unsigned long dar;\n+  unsigned long dsisr;\n+  unsigned long result;\n+  unsigned long pad1[4];\n+  double fpr[32];\n+  unsigned int pad2;\n+  unsigned int fpscr;\n+#ifdef __powerpc64__\n+  struct gcc_vregs *vp;\n+#else\n+  unsigned int pad3[2];\n+#endif\n+  struct gcc_vregs vregs;\n };\n \n struct gcc_ucontext\n {\n #ifdef __powerpc64__\n-  unsigned long pad[21];\n+  unsigned long pad[28];\n #else\n-  unsigned long pad[5];\n+  unsigned long pad[12];\n #endif\n-  struct gcc_sigcontext uc_mcontext;\n+  struct gcc_regs *regs;\n+  struct gcc_regs rsave;\n };\n \n #ifdef __powerpc64__\n@@ -77,34 +102,55 @@ frob_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n }\n \n /* If PC is at a sigreturn trampoline, return a pointer to the\n-   sigcontext.  Otherwise return NULL.  */\n+   regs.  Otherwise return NULL.  */\n \n-static struct gcc_sigcontext *\n-get_sigcontext (struct _Unwind_Context *context)\n+static struct gcc_regs *\n+get_regs (struct _Unwind_Context *context)\n {\n   const unsigned char *pc = context->ra;\n \n   /* addi r1, r1, 128; li r0, 0x0077; sc  (sigreturn) */\n   /* addi r1, r1, 128; li r0, 0x00AC; sc  (rt_sigreturn) */\n-  if (*(unsigned int *) (pc+0) != 0x38210000 + SIGNAL_FRAMESIZE\n-      || *(unsigned int *) (pc+8) != 0x44000002)\n+  if (*(unsigned int *) (pc + 0) != 0x38210000 + SIGNAL_FRAMESIZE\n+      || *(unsigned int *) (pc + 8) != 0x44000002)\n     return NULL;\n-  if (*(unsigned int *) (pc+4) == 0x38000077)\n+  if (*(unsigned int *) (pc + 4) == 0x38000077)\n     {\n       struct sigframe {\n \tchar gap[SIGNAL_FRAMESIZE];\n-\tstruct gcc_sigcontext sigctx;\n-      } *rt_ = context->cfa;\n-      return &rt_->sigctx;\n+\tunsigned long pad[7];\n+\tstruct gcc_regs *regs;\n+      } *frame = (struct sigframe *) context->cfa;\n+      return frame->regs;\n     }\n-  else if (*(unsigned int *) (pc+4) == 0x380000AC)\n+  else if (*(unsigned int *) (pc + 4) == 0x380000AC)\n     {\n-      struct rt_sigframe {\n+      /* This works for 2.4 kernels, but not for 2.6 kernels with vdso\n+\t because pc isn't pointing into the stack.  Can be removed when\n+\t no one is running 2.4.19 or 2.4.20, the first two ppc64\n+\t kernels released.  */\n+      struct rt_sigframe_24 {\n \tint tramp[6];\n \tvoid *pinfo;\n \tstruct gcc_ucontext *puc;\n-      } *rt_ = (struct rt_sigframe *) pc;\n-      return &rt_->puc->uc_mcontext;\n+      } *frame24 = (struct rt_sigframe_24 *) pc;\n+\n+      /* Test for magic value in *puc of vdso.  */\n+      if ((long) frame24->puc != -21 * 8)\n+\treturn frame24->puc->regs;\n+      else\n+\t{\n+\t  /* This works for 2.4.21 and later kernels.  */\n+\t  struct rt_sigframe {\n+\t    char gap[SIGNAL_FRAMESIZE];\n+\t    struct gcc_ucontext uc;\n+\t    unsigned long pad[2];\n+\t    int tramp[6];\n+\t    void *pinfo;\n+\t    struct gcc_ucontext *puc;\n+\t  } *frame = (struct rt_sigframe *) context->cfa;\n+\t  return frame->uc.regs;\n+\t}\n     }\n   return NULL;\n }\n@@ -113,40 +159,73 @@ get_sigcontext (struct _Unwind_Context *context)\n \n enum { SIGNAL_FRAMESIZE = 64 };\n \n-static struct gcc_sigcontext *\n-get_sigcontext (struct _Unwind_Context *context)\n+static struct gcc_regs *\n+get_regs (struct _Unwind_Context *context)\n {\n   const unsigned char *pc = context->ra;\n \n   /* li r0, 0x7777; sc  (sigreturn old)  */\n   /* li r0, 0x0077; sc  (sigreturn new)  */\n   /* li r0, 0x6666; sc  (rt_sigreturn old)  */\n   /* li r0, 0x00AC; sc  (rt_sigreturn new)  */\n-  if (*(unsigned int *) (pc+4) != 0x44000002)\n+  if (*(unsigned int *) (pc + 4) != 0x44000002)\n     return NULL;\n-  if (*(unsigned int *) (pc+0) == 0x38007777\n-      || *(unsigned int *) (pc+0) == 0x38000077)\n+  if (*(unsigned int *) (pc + 0) == 0x38007777\n+      || *(unsigned int *) (pc + 0) == 0x38000077)\n     {\n       struct sigframe {\n \tchar gap[SIGNAL_FRAMESIZE];\n-\tstruct gcc_sigcontext sigctx;\n-      } *rt_ = context->cfa;\n-      return &rt_->sigctx;\n+\tunsigned long pad[7];\n+\tstruct gcc_regs *regs;\n+      } *frame = (struct sigframe *) context->cfa;\n+      return frame->regs;\n     }\n-  else if (*(unsigned int *) (pc+0) == 0x38006666\n-\t   || *(unsigned int *) (pc+0) == 0x380000AC)\n+  else if (*(unsigned int *) (pc + 0) == 0x38006666\n+\t   || *(unsigned int *) (pc + 0) == 0x380000AC)\n     {\n       struct rt_sigframe {\n \tchar gap[SIGNAL_FRAMESIZE + 16];\n \tchar siginfo[128];\n \tstruct gcc_ucontext uc;\n-      } *rt_ = context->cfa;\n-      return &rt_->uc.uc_mcontext;\n+      } *frame = (struct rt_sigframe *) context->cfa;\n+      return frame->uc.regs;\n     }\n   return NULL;\n }\n #endif\n \n+/* Find an entry in the process auxilliary vector.  The canonical way to\n+   test for VMX is to look at AT_HWCAP.  */\n+\n+static long\n+ppc_linux_aux_vector (long which)\n+{\n+  /* __libc_stack_end holds the original stack passed to a process.  */\n+  extern long *__libc_stack_end;\n+  long argc;\n+  char **argv;\n+  char **envp;\n+  struct auxv\n+  {\n+    long a_type;\n+    long a_val;\n+  } *auxp;\n+\n+  /* The Linux kernel puts argc first on the stack.  */\n+  argc = __libc_stack_end[0];\n+  /* Followed by argv, NULL terminated.  */\n+  argv = (char **) __libc_stack_end + 1;\n+  /* Followed by environment string pointers, NULL terminated. */\n+  envp = argv + argc + 1;\n+  while (*envp++)\n+    continue;\n+  /* Followed by the aux vector, zero terminated.  */\n+  for (auxp = (struct auxv *) envp; auxp->a_type != 0; ++auxp)\n+    if (auxp->a_type == which)\n+      return auxp->a_val;\n+  return 0;\n+}\n+\n /* Do code reading to identify a signal frame, and set the frame\n    state data appropriately.  See unwind-dw2.c for the structs.  */\n \n@@ -156,14 +235,15 @@ static _Unwind_Reason_Code\n ppc_fallback_frame_state (struct _Unwind_Context *context,\n \t\t\t  _Unwind_FrameState *fs)\n {\n-  struct gcc_sigcontext *sc = get_sigcontext (context);\n+  static long hwcap = 0;\n+  struct gcc_regs *regs = get_regs (context);\n   long new_cfa;\n   int i;\n \n-  if (sc == NULL)\n+  if (regs == NULL)\n     return _URC_END_OF_STACK;\n \n-  new_cfa = sc->regs->gpr[STACK_POINTER_REGNUM];\n+  new_cfa = regs->gpr[STACK_POINTER_REGNUM];\n   fs->cfa_how = CFA_REG_OFFSET;\n   fs->cfa_reg = STACK_POINTER_REGNUM;\n   fs->cfa_offset = new_cfa - (long) context->cfa;\n@@ -172,21 +252,65 @@ ppc_fallback_frame_state (struct _Unwind_Context *context,\n     if (i != STACK_POINTER_REGNUM)\n       {\n \tfs->regs.reg[i].how = REG_SAVED_OFFSET;\n-\tfs->regs.reg[i].loc.offset\n-\t  = (long)&(sc->regs->gpr[i]) - new_cfa;\n+\tfs->regs.reg[i].loc.offset = (long) &regs->gpr[i] - new_cfa;\n       }\n \n   fs->regs.reg[CR2_REGNO].how = REG_SAVED_OFFSET;\n-  fs->regs.reg[CR2_REGNO].loc.offset\n-    = (long)&(sc->regs->ccr) - new_cfa;\n+  fs->regs.reg[CR2_REGNO].loc.offset = (long) &regs->ccr - new_cfa;\n \n   fs->regs.reg[LINK_REGISTER_REGNUM].how = REG_SAVED_OFFSET;\n-  fs->regs.reg[LINK_REGISTER_REGNUM].loc.offset\n-    = (long)&(sc->regs->link) - new_cfa;\n+  fs->regs.reg[LINK_REGISTER_REGNUM].loc.offset = (long) &regs->link - new_cfa;\n \n   fs->regs.reg[ARG_POINTER_REGNUM].how = REG_SAVED_OFFSET;\n-  fs->regs.reg[ARG_POINTER_REGNUM].loc.offset\n-    = (long)&(sc->regs->nip) - new_cfa;\n+  fs->regs.reg[ARG_POINTER_REGNUM].loc.offset = (long) &regs->nip - new_cfa;\n   fs->retaddr_column = ARG_POINTER_REGNUM;\n+\n+  if (hwcap == 0)\n+    {\n+      hwcap = ppc_linux_aux_vector (16);\n+      /* These will already be set if we found AT_HWCAP.  A non-zero\n+\t value stops us looking again if for some reason we couldn't\n+\t find AT_HWCAP.  */\n+#ifdef __powerpc64__\n+      hwcap |= 0xc0000000;\n+#else\n+      hwcap |= 0x80000000;\n+#endif\n+    }\n+\n+  /* If we have a FPU...  */\n+  if (hwcap & 0x08000000)\n+    for (i = 0; i < 32; i++)\n+      {\n+\tfs->regs.reg[i + 32].how = REG_SAVED_OFFSET;\n+\tfs->regs.reg[i + 32].loc.offset = (long) &regs->fpr[i] - new_cfa;\n+      }\n+\n+  /* If we have a VMX unit...  */\n+  if (hwcap & 0x10000000)\n+    {\n+      struct gcc_vregs *vregs;\n+#ifdef __powerpc64__\n+      vregs = regs->vp;\n+#else\n+      vregs = &regs->vregs;\n+#endif\n+      if (regs->msr & (1 << 25))\n+\t{\n+\t  for (i = 0; i < 32; i++)\n+\t    {\n+\t      fs->regs.reg[i + FIRST_ALTIVEC_REGNO].how = REG_SAVED_OFFSET;\n+\t      fs->regs.reg[i + FIRST_ALTIVEC_REGNO].loc.offset\n+\t\t= (long) &vregs[i] - new_cfa;\n+\t    }\n+\n+\t  fs->regs.reg[VSCR_REGNO].how = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[VSCR_REGNO].loc.offset = (long) &vregs->vscr - new_cfa;\n+\t}\n+\n+      fs->regs.reg[VRSAVE_REGNO].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[VRSAVE_REGNO].loc.offset = (long) &vregs->vsave - new_cfa;\n+    }\n+\n   return _URC_NO_REASON;\n }"}]}