{"sha": "eaa2834f9f7aeb81115213fcfb0d2e055afc779e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFhMjgzNGY5ZjdhZWI4MTExNTIxM2ZjZmIwZDJlMDU1YWZjNzc5ZQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-12-05T07:43:45Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-12-05T07:43:45Z"}, "message": "Class.h (_Jv_SetVTableEntries): Updated declaration.\n\n\t* java/lang/Class.h (_Jv_SetVTableEntries): Updated declaration.\n\t* resolve.cc: Don't include AbstractMethodError.h.\n\t(_Jv_abstractMethodError): Removed.\n\t* defineclass.cc (handleMethodsBegin): Initialize method index to\n\t-1.\n\t* java/lang/natClass.cc (_Jv_LayoutVTableMethods): Don't set\n\tmethod index for \"new\" final method.\n\t(_Jv_SetVTableEntries): Compare index against -1 instead of using\n\tisVirtualMethod.  Added `flags' argument.\n\t(_Jv_MakeVTable): Throw exception for abstract method in concrete\n\tclass.\n\nFrom-SVN: r59847", "tree": {"sha": "c34b3facbe8521cce08d485b456e9ded07c686e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c34b3facbe8521cce08d485b456e9ded07c686e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaa2834f9f7aeb81115213fcfb0d2e055afc779e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaa2834f9f7aeb81115213fcfb0d2e055afc779e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaa2834f9f7aeb81115213fcfb0d2e055afc779e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaa2834f9f7aeb81115213fcfb0d2e055afc779e/comments", "author": null, "committer": null, "parents": [{"sha": "83f0a003b8206e33923ea484ec74e3ecee1f0c03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83f0a003b8206e33923ea484ec74e3ecee1f0c03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83f0a003b8206e33923ea484ec74e3ecee1f0c03"}], "stats": {"total": 108, "additions": 73, "deletions": 35}, "files": [{"sha": "4f4a7e14aa34d23226242b1289fd483e493a91a2", "filename": "libjava/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa2834f9f7aeb81115213fcfb0d2e055afc779e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa2834f9f7aeb81115213fcfb0d2e055afc779e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=eaa2834f9f7aeb81115213fcfb0d2e055afc779e", "patch": "@@ -1,3 +1,17 @@\n+2002-12-05  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/lang/Class.h (_Jv_SetVTableEntries): Updated declaration.\n+\t* resolve.cc: Don't include AbstractMethodError.h.\n+\t(_Jv_abstractMethodError): Removed.\n+\t* defineclass.cc (handleMethodsBegin): Initialize method index to\n+\t-1.\n+\t* java/lang/natClass.cc (_Jv_LayoutVTableMethods): Don't set\n+\tmethod index for \"new\" final method.\n+\t(_Jv_SetVTableEntries): Compare index against -1 instead of using\n+\tisVirtualMethod.  Added `flags' argument.\n+\t(_Jv_MakeVTable): Throw exception for abstract method in concrete\n+\tclass.\n+\n 2002-12-04  Tom Tromey  <tromey@redhat.com>\n \n \t* java/net/SocketPermission.java (hashCode): Rewrote."}, {"sha": "dc350028cdde84dcf3b0337ef75dbdd600c7a049", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa2834f9f7aeb81115213fcfb0d2e055afc779e/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa2834f9f7aeb81115213fcfb0d2e055afc779e/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=eaa2834f9f7aeb81115213fcfb0d2e055afc779e", "patch": "@@ -1184,15 +1184,17 @@ void _Jv_ClassReader::handleFieldsEnd ()\n void\n _Jv_ClassReader::handleMethodsBegin (int count)\n {\n-  def->methods = (_Jv_Method*)\n-    _Jv_AllocBytes (sizeof (_Jv_Method)*count);\n+  def->methods = (_Jv_Method *) _Jv_AllocBytes (sizeof (_Jv_Method) * count);\n \n   def->interpreted_methods\n     = (_Jv_MethodBase **) _Jv_AllocBytes (sizeof (_Jv_MethodBase *)\n \t\t\t\t\t  * count);\n \n   for (int i = 0; i < count; i++)\n-    def->interpreted_methods[i] = 0;\n+    {\n+      def->interpreted_methods[i] = 0;\n+      def->methods[i].index = (_Jv_ushort) -1;\n+    }\n \n   def->method_count = count;\n }\n@@ -1376,12 +1378,14 @@ throw_internal_error (char *msg)\n   throw new java::lang::InternalError (JvNewStringLatin1 (msg));\n }\n \n-static void throw_incompatible_class_change_error (jstring msg)\n+static void\n+throw_incompatible_class_change_error (jstring msg)\n {\n   throw new java::lang::IncompatibleClassChangeError (msg);\n }\n \n-static void throw_class_circularity_error (jstring msg)\n+static void\n+throw_class_circularity_error (jstring msg)\n {\n   throw new java::lang::ClassCircularityError (msg);\n }"}, {"sha": "4ccf3886431d0e84af8222442f4e73f89ccb3341", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa2834f9f7aeb81115213fcfb0d2e055afc779e/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa2834f9f7aeb81115213fcfb0d2e055afc779e/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=eaa2834f9f7aeb81115213fcfb0d2e055afc779e", "patch": "@@ -325,7 +325,7 @@ class java::lang::Class : public java::lang::Object\n   friend jshort _Jv_FindIIndex (jclass *, jshort *, jshort);\n   friend void _Jv_LinkOffsetTable (jclass);\n   friend void _Jv_LayoutVTableMethods (jclass klass);\n-  friend void _Jv_SetVTableEntries (jclass, _Jv_VTable *);\n+  friend void _Jv_SetVTableEntries (jclass, _Jv_VTable *, jboolean *);\n   friend void _Jv_MakeVTable (jclass);\n \n   // Return array class corresponding to element type KLASS, creating it if"}, {"sha": "bafac789b0d0edebc500389958f6076bbf31eb2c", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 49, "deletions": 22, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa2834f9f7aeb81115213fcfb0d2e055afc779e/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa2834f9f7aeb81115213fcfb0d2e055afc779e/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=eaa2834f9f7aeb81115213fcfb0d2e055afc779e", "patch": "@@ -97,7 +97,7 @@ java::lang::Class::forName (jstring className)\n   java::lang::Class *klass = NULL;\n   try\n     {\n-      for (int i=1; !klass; i++)\n+      for (int i = 1; !klass; i++)\n \t{\n \t  klass = t->classAt (i);\n \t}\n@@ -1556,7 +1556,7 @@ _Jv_LinkOffsetTable(jclass klass)\n }\n \n // Returns true if METH should get an entry in a VTable.\n-static bool\n+static jboolean\n isVirtualMethod (_Jv_Method *meth)\n {\n   using namespace java::lang::reflect;\n@@ -1574,56 +1574,67 @@ _Jv_LayoutVTableMethods (jclass klass)\n   if (klass->vtable != NULL || klass->isInterface() \n       || klass->vtable_method_count != -1)\n     return;\n-    \n+\n   jclass superclass = klass->superclass;\n \n   if (superclass != NULL && superclass->vtable_method_count == -1)\n     {\n       JvSynchronize sync (superclass);\n       _Jv_LayoutVTableMethods (superclass);\n     }\n-    \n+\n   int index = (superclass == NULL ? 0 : superclass->vtable_method_count);\n \n   for (int i = 0; i < klass->method_count; ++i)\n     {\n       _Jv_Method *meth = &klass->methods[i];\n       _Jv_Method *super_meth = NULL;\n-    \n-      if (!isVirtualMethod(meth))\n-        continue;\n-\t      \n+\n+      if (! isVirtualMethod (meth))\n+\tcontinue;\n+\n       if (superclass != NULL)\n         super_meth = _Jv_LookupDeclaredMethod (superclass, meth->name, \n \t\t\t\t\t       meth->signature);\n-      \n+\n       if (super_meth)\n         meth->index = super_meth->index;\n-      else\n+      else if (! (meth->accflags & java::lang::reflect::Modifier::FINAL))\n         meth->index = index++;\n     }\n-  \n+\n   klass->vtable_method_count = index;\n }\n \n-// Set entries in VTABLE for virtual methods declared in KLASS. If KLASS has\n-// an immediate abstract parent, recursivly do its methods first.\n+// Set entries in VTABLE for virtual methods declared in KLASS. If\n+// KLASS has an immediate abstract parent, recursively do its methods\n+// first.  FLAGS is used to determine which slots we've actually set.\n void\n-_Jv_SetVTableEntries (jclass klass, _Jv_VTable *vtable)\n+_Jv_SetVTableEntries (jclass klass, _Jv_VTable *vtable, jboolean *flags)\n {\n   using namespace java::lang::reflect;\n \n   jclass superclass = klass->getSuperclass();\n \n   if (superclass != NULL && (superclass->getModifiers() & Modifier::ABSTRACT))\n-    _Jv_SetVTableEntries (superclass, vtable);\n-    \n+    _Jv_SetVTableEntries (superclass, vtable, flags);\n+\n   for (int i = klass->method_count - 1; i >= 0; i--)\n     {\n       _Jv_Method *meth = &klass->methods[i];\n-      if (!isVirtualMethod(meth))\n+      if (meth->index == (_Jv_ushort) -1)\n \tcontinue;\n-      vtable->set_method(meth->index, meth->ncode);\n+      if ((meth->accflags & Modifier::ABSTRACT))\n+\t{\n+\t  // FIXME: we should set abstract slots to a function that\n+\t  // throws AbstractMethodError.  How can we do that on IA-64?\n+\t  flags[meth->index] = false;\n+\t}\n+      else\n+\t{\n+\t  vtable->set_method(meth->index, meth->ncode);\n+\t  flags[meth->index] = true;\n+\t}\n     }\n }\n \n@@ -1639,15 +1650,19 @@ _Jv_MakeVTable (jclass klass)\n   if (klass->vtable != NULL || klass->isInterface() \n       || (klass->accflags & Modifier::ABSTRACT))\n     return;\n-  \n+\n   //  out before we can create a vtable. \n   if (klass->vtable_method_count == -1)\n     _Jv_LayoutVTableMethods (klass);\n \n   // Allocate the new vtable.\n   _Jv_VTable *vtable = _Jv_VTable::new_vtable (klass->vtable_method_count);\n   klass->vtable = vtable;\n-  \n+\n+  jboolean flags[klass->vtable_method_count];\n+  for (int i = 0; i < klass->vtable_method_count; ++i)\n+    flags[i] = false;\n+\n   // Copy the vtable of the closest non-abstract superclass.\n   jclass superclass = klass->superclass;\n   if (superclass != NULL)\n@@ -1662,7 +1677,10 @@ _Jv_MakeVTable (jclass klass)\n \t}\n \n       for (int i = 0; i < superclass->vtable_method_count; ++i)\n-\tvtable->set_method (i, superclass->vtable->get_method (i));\n+\t{\n+\t  vtable->set_method (i, superclass->vtable->get_method (i));\n+\t  flags[i] = true;\n+\t}\n     }\n \n   // Set the class pointer and GC descriptor.\n@@ -1671,5 +1689,14 @@ _Jv_MakeVTable (jclass klass)\n \n   // For each virtual declared in klass and any immediate abstract \n   // superclasses, set new vtable entry or override an old one.\n-  _Jv_SetVTableEntries (klass, vtable);\n+  _Jv_SetVTableEntries (klass, vtable, flags);\n+\n+  // It is an error to have an abstract method in a concrete class.\n+  if (! (klass->accflags & Modifier::ABSTRACT))\n+    {\n+      for (int i = 0; i < klass->vtable_method_count; ++i)\n+\tif (! flags[i])\n+\t  // FIXME: messsage.\n+\t  throw new java::lang::AbstractMethodError ();\n+    }\n }"}, {"sha": "e195c333cc897bd3dd950d39c37c3c06000f20b0", "filename": "libjava/resolve.cc", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa2834f9f7aeb81115213fcfb0d2e055afc779e/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa2834f9f7aeb81115213fcfb0d2e055afc779e/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=eaa2834f9f7aeb81115213fcfb0d2e055afc779e", "patch": "@@ -363,13 +363,6 @@ _Jv_SearchMethodInClass (jclass cls, jclass klass,\n   return 0;\n }\n \n-/* this is installed in place of abstract methods */\n-static void\n-_Jv_abstractMethodError ()\n-{\n-  throw new java::lang::AbstractMethodError;\n-}\n-\n void \n _Jv_PrepareClass(jclass klass)\n {"}]}