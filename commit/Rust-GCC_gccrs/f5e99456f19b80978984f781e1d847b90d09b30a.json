{"sha": "f5e99456f19b80978984f781e1d847b90d09b30a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVlOTk0NTZmMTliODA5Nzg5ODRmNzgxZTFkODQ3YjkwZDA5YjMwYQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-11-15T10:01:10Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-11-15T10:01:10Z"}, "message": "c-common.c: Include c-lex.h.\n\n\t* c-common.c: Include c-lex.h.\n\t(c_common_lang_init): Change prototype.  Call init_c_lex and\n\tinit_pragma from here.\n\t* c-common.h (c_common_lang_init): Change prototype.\n\t* c-decl.c (init_decl_processing): Rename.  Call c_parse_init.\n\t* c-lang.c (c_init): Change prototype.  Update.\n\t(c_init_options): Update.\n\t* c-lex.c (cpp_filename): Remove.\n\t(init_c_lex): Update.  Read the main file, and get the original\n\tfile name.\n\t(yyparse): Finish the command line options.\n\t* c-parse.in (c_parse_init): Call init_reswords here.\n\t(init_parse): Remove.\n\t* c-tree.h (c_init_decl_processing): New.\n\t* cpphash.c (_cpp_init_hashtable): After initializing the hash\n\ttable, populate it.\n\t* cppinit.c (read_original_filename, cpp_finish_options): New.\n\t(cpp_create_reader): New prototype. Defer hash table initialization.\n\t(cpp_start_read): Rename cpp_read_main_file.  Initialize the\n\thash table.  Get the original filename.\n\t* cpplib.h (cpp_create_reader): Update.\n\t(cpp_start_read): Remove.\n\t(cpp_read_main_file, cpp_finish_options): New.\n\t* cppmain.c (main, do_preprocessing): Update.\n\t* langhooks.h (struct langhooks): Update init prototype.\n\t* toplev.c (general_init, parse_options_and_default_flags,\n\tprocess_options, lang_indpendent_init, lang_dependent_init,\n\tinit_asm_output): New; perform the bulk of initialization.\n\t(compile_file): Move most of initialization to above functions.\n\t(debug_hooks): Initialize statically.\n\t(set_Wunused): Relocate.\n\t(toplev_main): Move most of initialization to other init functions.\n\tHave a clear logic flow.\n\t* tree.h (init_parse, init_decl_processing): Remove.\nada:\n\t* misc.c (gnat_init): Change prototype.  Include the\n\tfunctionality of the old init_parse and init_decl_processing.\n\t(gnat_init_decl_processing): New prototype.\n\t(init_parse): Remove.\n\t* utils.c (init_decl_processing): Rename gnat_init_decl_processing.\ncp:\t* cp-tree.h (init_reswords, cxx_init_decl_processing): New.\n\t(cxx_init): Update prototype.\n\t* decl.c (init_decl_processing): Rename.  Move null node init\n\tto its creation time.\n\t* lex.c (cxx_init_options): Update.\n\t(cxx_init): Combine with old init_parse; also call\n\tcxx_init_decl_processing.\nf:\t* com.c (ffecom_init_decl_processing): Renamed from\n\tinit_decl_processing.\n\t(init_parse): Move contents to ffe_init.\n\t(ffe_init): Update prototype.\njava:\t* decl.c (init_decl_processing): Rename java_init_decl_processing.\n\t* java-tree.h: New prototype.\n\t* lang.c (java_init): Update prototype.  Combine with old init_parse.\nobjc:\t* objc-act.c (objc_init): Update prototype, combine with old\n\tinit_parse.\n\t(objc_init_options): Update.\n\nFrom-SVN: r47046", "tree": {"sha": "cac90266aeb52525edc15fddc73e9428ce8a8556", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cac90266aeb52525edc15fddc73e9428ce8a8556"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5e99456f19b80978984f781e1d847b90d09b30a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5e99456f19b80978984f781e1d847b90d09b30a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5e99456f19b80978984f781e1d847b90d09b30a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5e99456f19b80978984f781e1d847b90d09b30a/comments", "author": null, "committer": null, "parents": [{"sha": "87bc7fa6aab909eb842be0800e0284b0daa3de70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87bc7fa6aab909eb842be0800e0284b0daa3de70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87bc7fa6aab909eb842be0800e0284b0daa3de70"}], "stats": {"total": 1517, "additions": 866, "deletions": 651}, "files": [{"sha": "e8a3715e1545ef5e5a11fe8a56e56f4d0126e3d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -1,3 +1,45 @@\n+2001-11-15  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* c-common.c: Include c-lex.h.\n+\t(c_common_lang_init): Change prototype.  Call init_c_lex and\n+\tinit_pragma from here.\n+\t* c-common.h (c_common_lang_init): Change prototype.\n+\t* c-decl.c (init_decl_processing): Rename.  Call c_parse_init.\n+\t* c-lang.c (c_init): Change prototype.  Update.\n+\t(c_init_options): Update.\n+\t* c-lex.c (cpp_filename): Remove.\n+\t(init_c_lex): Update.  Read the main file, and get the original\n+\tfile name.\n+\t(yyparse): Finish the command line options.\n+\t* c-parse.in (c_parse_init): Call init_reswords here.\n+\t(init_parse): Remove.\n+\t* c-tree.h (c_init_decl_processing): New.\n+\t* cpphash.c (_cpp_init_hashtable): After initializing the hash\n+\ttable, populate it.\n+\t* cppinit.c (read_original_filename, cpp_finish_options): New.\n+\t(cpp_create_reader): New prototype. Defer hash table initialization.\n+\t(cpp_start_read): Rename cpp_read_main_file.  Initialize the\n+\thash table.  Get the original filename.\n+\t* cpplib.h (cpp_create_reader): Update.\n+\t(cpp_start_read): Remove.\n+\t(cpp_read_main_file, cpp_finish_options): New.\n+\t* cppmain.c (main, do_preprocessing): Update.\n+\t* langhooks.h (struct langhooks): Update init prototype.\n+\t* toplev.c (general_init, parse_options_and_default_flags,\n+\tprocess_options, lang_indpendent_init, lang_dependent_init,\n+\tinit_asm_output): New; perform the bulk of initialization.\n+\t(compile_file): Move most of initialization to above functions.\n+\t(debug_hooks): Initialize statically.\n+\t(set_Wunused): Relocate.\n+\t(toplev_main): Move most of initialization to other init functions.\n+\tHave a clear logic flow.\n+\t* tree.h (init_parse, init_decl_processing): Remove.\n+objc:\n+\t* objc-act.c (objc_init): Update prototype, combine with old\n+\tinit_parse.\n+\t(objc_init_options): Update.\n+\n+\n 2001-11-15  Andreas Jaeger  <aj@suse.de>\n \n \t* cfgrtl.c (purge_all_dead_edges): Use int as argument for"}, {"sha": "b2aecad6bf2f17752c71e9e4efa9be61edb80712", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -1,3 +1,11 @@\n+2001-11-15  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* misc.c (gnat_init): Change prototype.  Include the\n+\tfunctionality of the old init_parse and init_decl_processing.\n+\t(gnat_init_decl_processing): New prototype.\n+\t(init_parse): Remove.\n+\t* utils.c (init_decl_processing): Rename gnat_init_decl_processing.\n+\n 2001-11-09  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* misc.c (gnat_print_decl, gnat_print_type): Renamed."}, {"sha": "0ea1339be619d25a7f4c53c3fb59f8d03ff9a2b9", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                           C Implementation File                          *\n  *                                                                          *\n- *                             $Revision: 1.10 $\n+ *                             $Revision: 1.11 $\n  *                                                                          *\n  *          Copyright (C) 1992-2001 Free Software Foundation, Inc.          *\n  *                                                                          *\n@@ -109,12 +109,13 @@ const char *gnat_tree_code_name[] = {\n };\n #undef DEFTREECODE\n \n-static void gnat_init\t\t\tPARAMS ((void));\n+static const char *gnat_init\t\tPARAMS ((const char *));\n static void gnat_init_options\t\tPARAMS ((void));\n static int gnat_decode_option\t\tPARAMS ((int, char **));\n static HOST_WIDE_INT gnat_get_alias_set\tPARAMS ((tree));\n static void gnat_print_decl\t\tPARAMS ((FILE *, tree, int));\n static void gnat_print_type\t\tPARAMS ((FILE *, tree, int));\n+extern void gnat_init_decl_processing\tPARAMS ((void));\n \n /* Structure giving our language-specific hooks.  */\n \n@@ -342,11 +343,38 @@ internal_error_function (msgid, ap)\n \n /* Perform all the initialization steps that are language-specific.  */\n \n-void\n-gnat_init ()\n+static const char *\n+gnat_init (filename)\n+     const char *filename;\n {\n+/* Performs whatever initialization steps needed by the language-dependent\n+   lexical analyzer.\n+\n+   Define the additional tree codes here.  This isn't the best place to put\n+   it, but it's where g++ does it.  */\n+\n+  lang_expand_expr = gnat_expand_expr;\n+  lang_expand_constant = gnat_expand_constant;\n+\n+  memcpy ((char *) (tree_code_type + (int) LAST_AND_UNUSED_TREE_CODE),\n+\t  (char *) gnat_tree_code_type,\n+\t  ((LAST_GNAT_TREE_CODE - (int) LAST_AND_UNUSED_TREE_CODE)\n+\t   * sizeof (char *)));\n+\n+  memcpy ((char *) (tree_code_length + (int) LAST_AND_UNUSED_TREE_CODE),\n+\t  (char *) gnat_tree_code_length,\n+\t  ((LAST_GNAT_TREE_CODE - (int) LAST_AND_UNUSED_TREE_CODE)\n+\t   * sizeof (int)));\n+\n+  memcpy ((char *) (tree_code_name + (int) LAST_AND_UNUSED_TREE_CODE),\n+\t  (char *) gnat_tree_code_name,\n+\t  ((LAST_GNAT_TREE_CODE - (int) LAST_AND_UNUSED_TREE_CODE)\n+\t   * sizeof (char *)));\n+\n+  gnat_init_decl_processing ();\n+\n   /* Add the input filename as the last argument.  */\n-  gnat_argv [gnat_argc] = (char *) input_filename;\n+  gnat_argv [gnat_argc] = (char *) filename;\n   gnat_argc++;\n   gnat_argv [gnat_argc] = 0;\n \n@@ -365,6 +393,8 @@ gnat_init ()\n #if defined(MIPS_DEBUGGING_INFO) && defined(DWARF2_DEBUGGING_INFO)\n   dwarf2out_set_demangle_name_func (convert_ada_name_to_qualified_name);\n #endif\n+\n+  return filename;\n }\n \n /* If DECL has a cleanup, build and return that cleanup here.\n@@ -849,37 +879,6 @@ insert_code_for (gnat_node)\n     }\n }\n \n-/* Performs whatever initialization steps needed by the language-dependent\n-   lexical analyzer.\n-\n-   Define the additional tree codes here.  This isn't the best place to put\n-   it, but it's where g++ does it.  */\n-\n-const char *\n-init_parse (filename)\n-     const char *filename;\n-{\n-  lang_expand_expr = gnat_expand_expr;\n-  lang_expand_constant = gnat_expand_constant;\n-\n-  memcpy ((char *) (tree_code_type + (int) LAST_AND_UNUSED_TREE_CODE),\n-\t  (char *) gnat_tree_code_type,\n-\t  ((LAST_GNAT_TREE_CODE - (int) LAST_AND_UNUSED_TREE_CODE)\n-\t   * sizeof (char *)));\n-\n-  memcpy ((char *) (tree_code_length + (int) LAST_AND_UNUSED_TREE_CODE),\n-\t  (char *) gnat_tree_code_length,\n-\t  ((LAST_GNAT_TREE_CODE - (int) LAST_AND_UNUSED_TREE_CODE)\n-\t   * sizeof (int)));\n-\n-  memcpy ((char *) (tree_code_name + (int) LAST_AND_UNUSED_TREE_CODE),\n-\t  (char *) gnat_tree_code_name,\n-\t  ((LAST_GNAT_TREE_CODE - (int) LAST_AND_UNUSED_TREE_CODE)\n-\t   * sizeof (char *)));\n-\n-  return filename;\n-}\n-\n void\n finish_parse ()\n {"}, {"sha": "1b4f80557ad990a5de114e3b824c6fbb393e8e8a", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *                            $Revision: 1.2 $\n+ *                            $Revision: 1.3 $\n  *                                                                          *\n  *          Copyright (C) 1992-2001, Free Software Foundation, Inc.         *\n  *                                                                          *\n@@ -478,7 +478,7 @@ pushdecl (decl)\n    front end has been run.  */\n \n void\n-init_decl_processing ()\n+gnat_init_decl_processing ()\n {\n   lineno = 0;\n "}, {"sha": "26a7f9edb6a176f15dd459c226125dc38b04e9fd", "filename": "gcc/c-common.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -32,6 +32,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"c-common.h\"\n #include \"tm_p.h\"\n #include \"obstack.h\"\n+#include \"c-lex.h\"\n #include \"cpplib.h\"\n #include \"target.h\"\n cpp_reader *parse_in;\t\t/* Declared in c-lex.h.  */\n@@ -3809,9 +3810,14 @@ static bool c_attrs_initialized = false;\n static void c_init_attributes PARAMS ((void));\n \n /* Do the parts of lang_init common to C and C++.  */\n-void\n-c_common_lang_init ()\n+const char *\n+c_common_lang_init (filename)\n+     const char *filename;\n {\n+  filename = init_c_lex (filename);\n+\n+  init_pragma ();\n+\n   /* If still \"unspecified\", make it match -fbounded-pointers.  */\n   if (flag_bounds_check < 0)\n     flag_bounds_check = flag_bounded_pointers;\n@@ -3831,6 +3837,8 @@ c_common_lang_init ()\n \n   if (!c_attrs_initialized)\n     c_init_attributes ();\n+\n+  return filename;\n }\n \n static void"}, {"sha": "76c59aa978646f621ef94df3e99bcbdb3e6a6ddc", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -540,7 +540,7 @@ extern void c_common_nodes_and_builtins\t\tPARAMS ((void));\n \n extern tree build_va_arg\t\t\tPARAMS ((tree, tree));\n \n-extern void c_common_lang_init\t\t\tPARAMS ((void));\n+extern const char *c_common_lang_init\t\tPARAMS ((const char *));\n extern HOST_WIDE_INT c_common_get_alias_set\tPARAMS ((tree));\n extern bool c_promoting_integer_type_p\t\tPARAMS ((tree));\n extern int self_promoting_args_p\t\tPARAMS ((tree));"}, {"sha": "f240aac43632c0a6b158a85134123228fa440247", "filename": "gcc/c-decl.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -2977,11 +2977,14 @@ mark_binding_level (arg)\n    Make definitions for built-in primitive functions.  */\n \n void\n-init_decl_processing ()\n+c_init_decl_processing ()\n {\n   tree endlink;\n   tree ptr_ftype_void, ptr_ftype_ptr;\n \n+  /* Adds some ggc roots, and reserved words for c-parse.in.  */\n+  c_parse_init ();\n+\n   current_function_decl = NULL;\n   named_labels = NULL;\n   current_binding_level = NULL_BINDING_LEVEL;"}, {"sha": "72d2536123c287a54dc9c686d9827eb4b30583a6", "filename": "gcc/c-lang.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -44,7 +44,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n static int c_tree_printer PARAMS ((output_buffer *));\n static int c_missing_noreturn_ok_p PARAMS ((tree));\n-static void c_init PARAMS ((void));\n+static const char *c_init PARAMS ((const char *));\n static void c_init_options PARAMS ((void));\n static void c_post_options PARAMS ((void));\n static int c_disregard_inline_limits PARAMS ((tree));\n@@ -108,16 +108,21 @@ c_post_options ()\n static void\n c_init_options ()\n {\n-  parse_in = cpp_create_reader (ident_hash, CLK_GNUC89);\n+  parse_in = cpp_create_reader (CLK_GNUC89);\n \n   /* Mark as \"unspecified\".  */\n   flag_bounds_check = -1;\n }\n \n-static void\n-c_init ()\n+static const char *\n+c_init (filename)\n+     const char *filename;\n {\n-  c_common_lang_init ();\n+  c_init_decl_processing ();\n+\n+  filename = c_common_lang_init (filename);\n+\n+  add_c_tree_codes ();\n \n   /* If still unspecified, make it match -std=c99\n      (allowing for -pedantic-errors).  */\n@@ -138,10 +143,10 @@ c_init ()\n   lang_expand_decl_stmt = &c_expand_decl_stmt;\n   lang_missing_noreturn_ok_p = &c_missing_noreturn_ok_p;\n \n-  c_parse_init ();\n-\n   VARRAY_TREE_INIT (deferred_fns, 32, \"deferred_fns\");\n   ggc_add_tree_varray_root (&deferred_fns, 1);\n+\n+  return filename;\n }\n \n /* Used by c-lex.c, but only for objc.  */"}, {"sha": "ea824ec239e288ab0ac23af894c87c4f9b5f91d5", "filename": "gcc/c-lex.c", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -54,9 +54,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define GET_ENVIRONMENT(ENV_VALUE,ENV_NAME) ((ENV_VALUE) = getenv (ENV_NAME))\n #endif\n \n-/* The input filename as understood by CPP, where \"\" represents stdin.  */\n-static const char *cpp_filename;\n-\n /* The current line map.  */\n static const struct line_map *map;\n \n@@ -109,7 +106,7 @@ init_c_lex (filename)\n   struct cpp_callbacks *cb;\n   struct c_fileinfo *toplevel;\n \n-  /* Set up filename timing.  Must happen before cpp_start_read.  */\n+  /* Set up filename timing.  Must happen before cpp_read_main_file.  */\n   file_info_tree = splay_tree_new ((splay_tree_compare_fn)strcmp,\n \t\t\t\t   0,\n \t\t\t\t   (splay_tree_delete_value_fn)free);\n@@ -142,16 +139,13 @@ init_c_lex (filename)\n       cb->undef = cb_undef;\n     }\n \n-\n-  if (filename == 0 || !strcmp (filename, \"-\"))\n-    filename = \"stdin\", cpp_filename = \"\";\n-  else\n-    cpp_filename = filename;\n-\n   /* Start it at 0.  */\n   lineno = 0;\n \n-  return filename;\n+  if (filename == NULL)\n+    filename = \"\";\n+\n+  return cpp_read_main_file (parse_in, filename, ident_hash);\n }\n \n /* A thin wrapper around the real parser that initializes the \n@@ -160,8 +154,7 @@ init_c_lex (filename)\n int\n yyparse()\n {\n-  if (! cpp_start_read (parse_in, cpp_filename))\n-    return 1;\t\t\t/* cpplib has emitted an error.  */\n+  cpp_finish_options (parse_in);\n \n   return yyparse_1();\n }"}, {"sha": "14a02535f36f30c8524c8ed4e66598ff750b6591", "filename": "gcc/c-parse.in", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -304,6 +304,8 @@ static void init_reswords PARAMS ((void));\n void\n c_parse_init ()\n {\n+  init_reswords ();\n+\n   ggc_add_tree_root (&declspec_stack, 1);\n   ggc_add_tree_root (&current_declspecs, 1);\n   ggc_add_tree_root (&prefix_attributes, 1);\n@@ -3528,17 +3530,6 @@ init_reswords ()\n     }\n }\n \n-const char *\n-init_parse (filename)\n-     const char *filename;\n-{\n-  add_c_tree_codes ();\n-  init_reswords ();\n-  init_pragma ();\n-\n-  return init_c_lex (filename);\n-}\n-\n void\n finish_parse ()\n {"}, {"sha": "865e734b505275b249e38ed685bf8a0f325d5908", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -164,6 +164,7 @@ extern int yyparse_1\t\t\t\tPARAMS ((void));\n extern void gen_aux_info_record                 PARAMS ((tree, int, int, int));\n \n /* in c-decl.c */\n+extern void c_init_decl_processing\t\tPARAMS ((void));\n extern void c_print_identifier\t\t\tPARAMS ((FILE *, tree, int));\n extern tree build_array_declarator              PARAMS ((tree, tree, int, int));\n extern tree build_enumerator                    PARAMS ((tree, tree));"}, {"sha": "7c856b4f1cad6c3788fbefcc8ba935166c92e8ed", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -1,3 +1,13 @@\n+2001-11-15  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cp-tree.h (init_reswords, cxx_init_decl_processing): New.\n+\t(cxx_init): Update prototype.\n+\t* decl.c (init_decl_processing): Rename.  Move null node init\n+\tto its creation time.\n+\t* lex.c (cxx_init_options): Update.\n+\t(cxx_init): Combine with old init_parse; also call\n+\tcxx_init_decl_processing.\n+\n 2001-11-14  Richard Sandiford  <rsandifo@redhat.com>\n \n         * decl.c (check_initializer): Try to complete the type of an"}, {"sha": "af8f396dee482c6bce4dc9e95f85564243344f34", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -3458,6 +3458,9 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n    : TYPE_NAME (NODE))\n \n /* in lex.c  */\n+\n+extern void init_reswords PARAMS ((void));\n+\n /* Indexed by TREE_CODE, these tables give C-looking names to\n    operators represented by TREE_CODES.  For example,\n    opname_tab[(int) MINUS_EXPR] == \"-\".  */\n@@ -3569,6 +3572,7 @@ extern void adjust_clone_args\t\t\tPARAMS ((tree));\n \n /* decl.c */\n /* resume_binding_level */\n+extern void cxx_init_decl_processing\t\tPARAMS ((void));\n extern int toplevel_bindings_p\t\t\tPARAMS ((void));\n extern int namespace_bindings_p\t\t\tPARAMS ((void));\n extern void keep_next_level\t\t\tPARAMS ((int));\n@@ -3882,7 +3886,7 @@ extern void yyerror\t\t\t\tPARAMS ((const char *));\n extern void clear_inline_text_obstack\t\tPARAMS ((void));\n extern void yyhook\t\t\t\tPARAMS ((int));\n extern int cp_type_qual_from_rid                PARAMS ((tree));\n-extern void cxx_init PARAMS ((void));\n+extern const char *cxx_init\t\t\tPARAMS ((const char *));\n extern void cxx_finish PARAMS ((void));\n extern void cxx_init_options PARAMS ((void));\n extern void cxx_post_options PARAMS ((void));"}, {"sha": "5098b576055f77368375340f74ab752eedb1ec06", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -6390,7 +6390,7 @@ initialize_predefined_identifiers ()\n    Make definitions for built-in primitive functions.  */\n \n void\n-init_decl_processing ()\n+cxx_init_decl_processing ()\n {\n   tree void_ftype;\n   tree void_ftype_ptr;\n@@ -6523,8 +6523,6 @@ init_decl_processing ()\n   /* Indirecting an UNKNOWN_TYPE node yields an UNKNOWN_TYPE node.  */\n   TREE_TYPE (unknown_type_node) = unknown_type_node;\n \n-  TREE_TYPE (null_node) = type_for_size (POINTER_SIZE, 0);\n-\n   /* Looking up TYPE_POINTER_TO and TYPE_REFERENCE_TO yield the same\n      result.  */\n   TYPE_POINTER_TO (unknown_type_node) = unknown_type_node;"}, {"sha": "21e359402f8975d8ed46032b8112d749bdc5a117", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -53,7 +53,6 @@ extern void yyprint PARAMS ((FILE *, int, YYSTYPE));\n \n static int interface_strcmp PARAMS ((const char *));\n static int *init_cpp_parse PARAMS ((void));\n-static void init_reswords PARAMS ((void));\n static void init_cp_pragma PARAMS ((void));\n \n static tree parse_strconst_pragma PARAMS ((const char *, int));\n@@ -248,7 +247,7 @@ cxx_post_options ()\n void\n cxx_init_options ()\n {\n-  parse_in = cpp_create_reader (ident_hash, CLK_GNUCXX);\n+  parse_in = cpp_create_reader (CLK_GNUCXX);\n \n   /* Default exceptions on.  */\n   flag_exceptions = 1;\n@@ -262,15 +261,6 @@ cxx_init_options ()\n   diagnostic_prefixing_rule (global_dc) = DIAGNOSTICS_SHOW_PREFIX_ONCE;\n }\n \n-void\n-cxx_init ()\n-{\n-  c_common_lang_init ();\n-\n-  if (flag_gnu_xref) GNU_xref_begin (input_filename);\n-  init_repo (input_filename);\n-}\n-\n void\n cxx_finish ()\n {\n@@ -636,7 +626,7 @@ const short rid_to_yy[RID_MAX] =\n   /* RID_AT_IMPLEMENTATION */\t0\n };\n \n-static void\n+void\n init_reswords ()\n {\n   unsigned int i;\n@@ -676,17 +666,18 @@ init_cp_pragma ()\n \t\t       handle_pragma_java_exceptions);\n }\n \n+/* Initialize the C++ front end.  This function is very sensitive to\n+   the exact order that things are done here.  It would be nice if the\n+   initialization done by this routine were moved to its subroutines,\n+   and the ordering dependencies clarified and reduced.  */\n const char *\n-init_parse (filename)\n+cxx_init (filename)\n      const char *filename;\n {\n   decl_printable_name = lang_printable_name;\n-\n   input_filename = \"<internal>\";\n \n   init_reswords ();\n-  init_pragma ();\n-  init_cp_pragma ();\n   init_spew ();\n   init_tree ();\n   init_cplus_expand ();\n@@ -726,17 +717,28 @@ init_parse (filename)\n   TREE_TYPE (enum_type_node) = enum_type_node;\n   ridpointers[(int) RID_ENUM] = enum_type_node;\n \n+  cxx_init_decl_processing ();\n+\n   /* Create the built-in __null node.  Note that we can't yet call for\n      type_for_size here because integer_type_node and so forth are not\n      set up.  Therefore, we don't set the type of these nodes until\n-     init_decl_processing.  */\n+     cxx_init_decl_processing.  */\n   null_node = build_int_2 (0, 0);\n+  TREE_TYPE (null_node) = type_for_size (POINTER_SIZE, 0);\n   ridpointers[RID_NULL] = null_node;\n \n   token_count = init_cpp_parse ();\n   interface_unknown = 1;\n \n-  return init_c_lex (filename);\n+  filename = c_common_lang_init (filename);\n+\n+  init_cp_pragma ();\n+\n+  if (flag_gnu_xref)\n+    GNU_xref_begin (filename);\n+  init_repo (filename);\n+\n+  return filename;\n }\n \n void"}, {"sha": "68ad412d8d3e825779245e9067aff98ffc7bffcb", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -173,7 +173,7 @@ static tree defarg_parm;    /* current default parameter */\n static tree defarg_depfns;  /* list of unprocessed fns met during current fn. */\n static tree defarg_fnsdone; /* list of fns with circular defargs */\n \n-/* Initialize obstacks. Called once, from init_parse.  */\n+/* Initialize obstacks. Called once, from cxx_init.  */\n \n void\n init_spew ()"}, {"sha": "1bb127508e12ade493a46589eee777251da43d6e", "filename": "gcc/cpphash.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -53,6 +53,8 @@ _cpp_init_hashtable (pfile, table)\n      cpp_reader *pfile;\n      hash_table *table;\n {\n+  struct spec_nodes *s;\n+\n   if (table == NULL)\n     {\n       pfile->our_hashtable = 1;\n@@ -63,6 +65,20 @@ _cpp_init_hashtable (pfile, table)\n \n   table->pfile = pfile;\n   pfile->hash_table = table;\n+\n+  /* Now we can initialize things that use the hash table.  */\n+  _cpp_init_directives (pfile);\n+  _cpp_init_internal_pragmas (pfile);\n+\n+  s = &pfile->spec_nodes;\n+  s->n_L                = cpp_lookup (pfile, DSC(\"L\"));\n+  s->n_defined\t\t= cpp_lookup (pfile, DSC(\"defined\"));\n+  s->n_true\t\t= cpp_lookup (pfile, DSC(\"true\"));\n+  s->n_false\t\t= cpp_lookup (pfile, DSC(\"false\"));\n+  s->n__STRICT_ANSI__   = cpp_lookup (pfile, DSC(\"__STRICT_ANSI__\"));\n+  s->n__CHAR_UNSIGNED__ = cpp_lookup (pfile, DSC(\"__CHAR_UNSIGNED__\"));\n+  s->n__VA_ARGS__       = cpp_lookup (pfile, DSC(\"__VA_ARGS__\"));\n+  s->n__VA_ARGS__->flags |= NODE_DIAGNOSTIC;\n }\n \n /* Tear down the identifier hash table.  */"}, {"sha": "ba9f1222487ed40f784de62a113a775e2c2c628f", "filename": "gcc/cppinit.c", "status": "modified", "additions": 63, "deletions": 31, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -63,7 +63,7 @@ struct pending_option\n };\n \n /* The `pending' structure accumulates all the options that are not\n-   actually processed until we hit cpp_start_read.  It consists of\n+   actually processed until we hit cpp_read_main_file.  It consists of\n    several lists, one for each type of option.  We keep both head and\n    tail pointers for quick insertion.  */\n struct cpp_pending\n@@ -111,6 +111,7 @@ static void free_chain\t\t\tPARAMS ((struct pending_option *));\n static void set_lang\t\t\tPARAMS ((cpp_reader *, enum c_lang));\n static void init_dependency_output\tPARAMS ((cpp_reader *));\n static void init_standard_includes\tPARAMS ((cpp_reader *));\n+static void read_original_filename\tPARAMS ((cpp_reader *));\n static void new_pending_directive\tPARAMS ((struct cpp_pending *,\n \t\t\t\t\t\t const char *,\n \t\t\t\t\t\t cl_directive_handler));\n@@ -476,11 +477,9 @@ init_library ()\n \n /* Initialize a cpp_reader structure.  */\n cpp_reader *\n-cpp_create_reader (table, lang)\n-     hash_table *table;\n+cpp_create_reader (lang)\n      enum c_lang lang;\n {\n-  struct spec_nodes *s;\n   cpp_reader *pfile;\n \n   /* Initialise this instance of the library if it hasn't been already.  */\n@@ -534,23 +533,7 @@ cpp_create_reader (table, lang)\n   /* Initialise the buffer obstack.  */\n   gcc_obstack_init (&pfile->buffer_ob);\n \n-  /* Initialise the hashtable.  */\n-  _cpp_init_hashtable (pfile, table);\n-\n-  _cpp_init_directives (pfile);\n   _cpp_init_includes (pfile);\n-  _cpp_init_internal_pragmas (pfile);\n-\n-  /* Initialize the special nodes.  */\n-  s = &pfile->spec_nodes;\n-  s->n_L                = cpp_lookup (pfile, DSC(\"L\"));\n-  s->n_defined\t\t= cpp_lookup (pfile, DSC(\"defined\"));\n-  s->n_true\t\t= cpp_lookup (pfile, DSC(\"true\"));\n-  s->n_false\t\t= cpp_lookup (pfile, DSC(\"false\"));\n-  s->n__STRICT_ANSI__   = cpp_lookup (pfile, DSC(\"__STRICT_ANSI__\"));\n-  s->n__CHAR_UNSIGNED__ = cpp_lookup (pfile, DSC(\"__CHAR_UNSIGNED__\"));\n-  s->n__VA_ARGS__       = cpp_lookup (pfile, DSC(\"__VA_ARGS__\"));\n-  s->n__VA_ARGS__->flags |= NODE_DIAGNOSTIC;\n \n   return pfile;\n }\n@@ -704,7 +687,7 @@ static const struct builtin builtin_array[] =\n #define builtin_array_end \\\n  builtin_array + sizeof(builtin_array)/sizeof(struct builtin)\n \n-/* Subroutine of cpp_start_read; reads the builtins table above and\n+/* Subroutine of cpp_read_main_file; reads the builtins table above and\n    enters the macros into the hash table.  */\n static void\n init_builtins (pfile)\n@@ -916,14 +899,21 @@ free_chain (head)\n     }\n }\n \n-/* This is called after options have been processed.  Setup for\n-   processing input from the file named FNAME, or stdin if it is the\n-   empty string.  Return 1 on success, 0 on failure.  */\n-int\n-cpp_start_read (pfile, fname)\n+/* This is called after options have been parsed, and partially\n+   processed.  Setup for processing input from the file named FNAME,\n+   or stdin if it is the empty string.  Return the original filename\n+   on success (e.g. foo.i->foo.c), or NULL on failure.  */\n+const char *\n+cpp_read_main_file (pfile, fname, table)\n      cpp_reader *pfile;\n      const char *fname;\n+     hash_table *table;\n {\n+  /* The front ends don't set up the hash table until they have\n+     finished processing the command line options, so initializing the\n+     hashtable is deferred until now.  */\n+  _cpp_init_hashtable (pfile, table);\n+\n   /* Set up the include search path now.  */\n   if (! CPP_OPTION (pfile, no_standard_includes))\n     init_standard_includes (pfile);\n@@ -948,16 +938,60 @@ cpp_start_read (pfile, fname)\n     /* Set the default target (if there is none already).  */\n     deps_add_default_target (pfile->deps, fname);\n \n-  /* Open the main input file.  This must be done early, so we have a\n-     buffer to stand on.  */\n+  /* Open the main input file.  */\n   if (!_cpp_read_file (pfile, fname))\n-    return 0;\n+    return NULL;\n \n   /* Set this after cpp_post_options so the client can change the\n      option if it wishes, and after stacking the main file so we don't\n      trace the main file.  */\n   pfile->line_maps.trace_includes = CPP_OPTION (pfile, print_include_names);\n \n+  /* For foo.i, read the original filename foo.c now, for the benefit\n+     of the front ends.  */\n+  if (CPP_OPTION (pfile, preprocessed))\n+    read_original_filename (pfile);\n+\n+  return pfile->map->to_file;\n+}\n+\n+/* For preprocessed files, if the first tokens are of the form # NUM.\n+   handle the directive so we know the original file name.  This will\n+   generate file_change callbacks, which the front ends must handle\n+   appropriately given their state of initialization.  */\n+static void\n+read_original_filename (pfile)\n+     cpp_reader *pfile;\n+{\n+  const cpp_token *token, *token1;\n+\n+  /* Lex ahead; if the first tokens are of the form # NUM, then\n+     process the directive, otherwise back up.  */\n+  token = _cpp_lex_direct (pfile);\n+  if (token->type == CPP_HASH)\n+    {\n+      token1 = _cpp_lex_direct (pfile);\n+      _cpp_backup_tokens (pfile, 1);\n+\n+      /* If it's a #line directive, handle it.  */\n+      if (token1->type == CPP_NUMBER)\n+\t{\n+\t  _cpp_handle_directive (pfile, token->flags & PREV_WHITE);\n+\t  return;\n+\t}\n+    }\n+\n+  /* Backup as if nothing happened.  */\n+  _cpp_backup_tokens (pfile, 1);\n+}\n+\n+/* Handle pending command line options: -D, -U, -A, -imacros and\n+   -include.  This should be called after debugging has been properly\n+   set up in the front ends.  */\n+void\n+cpp_finish_options (pfile)\n+     cpp_reader *pfile;\n+{\n   /* Install builtins and process command line macros etc. in the order\n      they appeared, but only if not already preprocessed.  */\n   if (! CPP_OPTION (pfile, preprocessed))\n@@ -986,8 +1020,6 @@ cpp_start_read (pfile, fname)\n \n   free_chain (CPP_OPTION (pfile, pending)->directive_head);\n   _cpp_push_next_buffer (pfile);\n-\n-  return 1;\n }\n \n /* Called to push the next buffer on the stack given by -include.  If"}, {"sha": "e9002fb9f954f1dedab2d9af48f220ce8f632bb5", "filename": "gcc/cpplib.h", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -451,16 +451,8 @@ struct cpp_hashnode\n   } value;\n };\n \n-/* Call this first to get a handle to pass to other functions.  If you\n-   want cpplib to manage its own hashtable, pass in a NULL pointer.\n-   Or you can pass in an initialised hash table that cpplib will use;\n-   this technique is used by the C front ends.  */\n-extern cpp_reader *cpp_create_reader PARAMS ((struct ht *,\n-\t\t\t\t\t      enum c_lang));\n-\n-/* Call this to release the handle.  Any use of the handle after this\n-   function returns is invalid.  Returns cpp_errors (pfile).  */\n-extern int cpp_destroy PARAMS ((cpp_reader *));\n+/* Call this first to get a handle to pass to other functions.  */\n+extern cpp_reader *cpp_create_reader PARAMS ((enum c_lang));\n \n /* Call these to get pointers to the options and callback structures\n    for a given reader.  These pointers are good until you call\n@@ -476,13 +468,39 @@ extern void cpp_set_callbacks PARAMS ((cpp_reader *, cpp_callbacks *));\n    return value is the number of arguments used.  If\n    cpp_handle_options returns without using all arguments, it couldn't\n    understand the next switch.  When there are no switches left, you\n-   must call cpp_post_options before calling cpp_start_read.  Only\n+   must call cpp_post_options before calling cpp_read_main_file.  Only\n    after cpp_post_options are the contents of the cpp_options\n-   structure reliable.  */\n+   structure reliable.  Options processing is not completed until you\n+   call cpp_finish_options.  */\n extern int cpp_handle_options PARAMS ((cpp_reader *, int, char **));\n extern int cpp_handle_option PARAMS ((cpp_reader *, int, char **));\n extern void cpp_post_options PARAMS ((cpp_reader *));\n \n+/* This function reads the file, but does not start preprocessing.  It\n+   returns the name of the original file; this is the same as the\n+   input file, except for preprocessed input.  This will generate at\n+   least one file change callback, and possibly a line change callback\n+   too.  If there was an error opening the file, it returns NULL.\n+\n+   If you want cpplib to manage its own hashtable, pass in a NULL\n+   pointer.  Otherise you should pass in an initialised hash table\n+   that cpplib will share; this technique is used by the C front\n+   ends.  */\n+extern const char *cpp_read_main_file PARAMS ((cpp_reader *, const char *,\n+\t\t\t\t\t       struct ht *));\n+\n+/* Deferred handling of command line options that can generate debug\n+   callbacks, such as -D and -imacros.  Call this after\n+   cpp_read_main_file.  The front ends need this separation so they\n+   can initialize debug output with the original file name, returned\n+   from cpp_read_main_file, before they get debug callbacks.  */\n+extern void cpp_finish_options PARAMS ((cpp_reader *));\n+\n+/* Call this to release the handle at the end of preprocessing.  Any\n+   use of the handle after this function returns is invalid.  Returns\n+   cpp_errors (pfile).  */\n+extern int cpp_destroy PARAMS ((cpp_reader *));\n+\n /* Error count.  */\n extern unsigned int cpp_errors PARAMS ((cpp_reader *));\n \n@@ -495,7 +513,6 @@ extern void cpp_register_pragma PARAMS ((cpp_reader *,\n \t\t\t\t\t const char *, const char *,\n \t\t\t\t\t void (*) PARAMS ((cpp_reader *))));\n \n-extern int cpp_start_read PARAMS ((cpp_reader *, const char *));\n extern void cpp_finish PARAMS ((cpp_reader *));\n extern int cpp_avoid_paste PARAMS ((cpp_reader *, const cpp_token *,\n \t\t\t\t    const cpp_token *));"}, {"sha": "923c71684f447d9093df49e28576d2e094ab1883", "filename": "gcc/cppmain.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -77,7 +77,7 @@ main (argc, argv)\n   general_init (argv[0]);\n \n   /* Contruct a reader with default language GNU C89.  */\n-  pfile = cpp_create_reader (NULL, CLK_GNUC89);\n+  pfile = cpp_create_reader (CLK_GNUC89);\n   options = cpp_get_options (pfile);\n   \n   do_preprocessing (argc, argv);\n@@ -117,10 +117,12 @@ do_preprocessing (argc, argv)\n     return;\n \n   if (argi < argc)\n-    cpp_fatal (pfile, \"Invalid option %s\", argv[argi]);\n-  else\n-    cpp_post_options (pfile);\n+    {\n+      cpp_fatal (pfile, \"Invalid option %s\", argv[argi]);\n+      return;\n+    }\n \n+  cpp_post_options (pfile);\n   if (CPP_FATAL_ERRORS (pfile))\n     return;\n \n@@ -156,8 +158,10 @@ do_preprocessing (argc, argv)\n \n   setup_callbacks ();\n \n-  if (cpp_start_read (pfile, options->in_fname))\n+  if (cpp_read_main_file (pfile, options->in_fname, NULL))\n     {\n+      cpp_finish_options (pfile);\n+\n       /* A successful cpp_start_read guarantees that we can call\n \t cpp_scan_nooutput or cpp_get_token next.  */\n       if (options->no_output)"}, {"sha": "586b6e3f86cdf04d2f865572f324b2b1e248d4c4", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -1,3 +1,10 @@\n+Thu Nov 15 10:06:38 2001  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* com.c (ffecom_init_decl_processing): Renamed from\n+\tinit_decl_processing.\n+\t(init_parse): Move contents to ffe_init.\n+\t(ffe_init): Update prototype.\n+\n 2001-11-14  Toon Moene  <toon@moene.indiv.nluug.nl>\n \n \t* g77.texi: Update to use `@command', `@option."}, {"sha": "fb7bd4fd805c66976b4784af3fb10f6f98879974", "filename": "gcc/f/com.c", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -260,6 +260,7 @@ struct _ffecom_concat_list_\n \n /* Static functions (internal). */\n \n+static void ffecom_init_decl_processing PARAMS ((void));\n static tree ffecom_arglist_expr_ (const char *argstring, ffebld args);\n static tree ffecom_widest_expr_type_ (ffebld list);\n static bool ffecom_overlap_ (tree dest_decl, tree dest_offset,\n@@ -14120,8 +14121,8 @@ mark_binding_level (void *arg)\n     }\n }\n \n-void\n-init_decl_processing ()\n+static void\n+ffecom_init_decl_processing ()\n {\n   static tree *const tree_roots[] = {\n     &current_function_decl,\n@@ -14188,31 +14189,6 @@ init_decl_processing ()\n   ffe_init_0 ();\n }\n \n-const char *\n-init_parse (filename)\n-     const char *filename;\n-{\n-  /* Open input file.  */\n-  if (filename == 0 || !strcmp (filename, \"-\"))\n-    {\n-      finput = stdin;\n-      filename = \"stdin\";\n-    }\n-  else\n-    finput = fopen (filename, \"r\");\n-  if (finput == 0)\n-    fatal_io_error (\"can't open %s\", filename);\n-\n-#ifdef IO_BUFFER_SIZE\n-  setvbuf (finput, (char *) xmalloc (IO_BUFFER_SIZE), _IOFBF, IO_BUFFER_SIZE);\n-#endif\n-\n-  decl_printable_name = lang_printable_name;\n-  print_error_function = lang_print_error_function;\n-\n-  return filename;\n-}\n-\n void\n finish_parse ()\n {\n@@ -14253,7 +14229,7 @@ insert_block (block)\n }\n \n /* Each front end provides its own.  */\n-static void ffe_init PARAMS ((void));\n+static const char *ffe_init PARAMS ((const char *));\n static void ffe_finish PARAMS ((void));\n static void ffe_init_options PARAMS ((void));\n static void ffe_print_identifier PARAMS ((FILE *, tree, int));\n@@ -14281,6 +14257,45 @@ static void ffe_print_identifier PARAMS ((FILE *, tree, int));\n \n const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n+static const char *\n+ffe_init (filename)\n+     const char *filename;\n+{\n+  /* Open input file.  */\n+  if (filename == 0 || !strcmp (filename, \"-\"))\n+    {\n+      finput = stdin;\n+      filename = \"stdin\";\n+    }\n+  else\n+    finput = fopen (filename, \"r\");\n+  if (finput == 0)\n+    fatal_io_error (\"can't open %s\", filename);\n+\n+#ifdef IO_BUFFER_SIZE\n+  setvbuf (finput, (char *) xmalloc (IO_BUFFER_SIZE), _IOFBF, IO_BUFFER_SIZE);\n+#endif\n+\n+  ffecom_init_decl_processing ();\n+  decl_printable_name = lang_printable_name;\n+  print_error_function = lang_print_error_function;\n+\n+  /* If the file is output from cpp, it should contain a first line\n+     `# 1 \"real-filename\"', and the current design of gcc (toplev.c\n+     in particular and the way it sets up information relied on by\n+     INCLUDE) requires that we read this now, and store the\n+     \"real-filename\" info in master_input_filename.  Ask the lexer\n+     to try doing this.  */\n+  ffelex_hash_kludge (finput);\n+\n+  /* FIXME: The ffelex_hash_kludge code needs to be cleaned up to\n+     return the new file name.  */\n+  if (main_input_filename)\n+    filename = main_input_filename;\n+\n+  return filename;\n+}\n+\n static void\n ffe_finish ()\n {\n@@ -14302,18 +14317,6 @@ ffe_init_options ()\n   flag_complex_divide_method = 1;\n }\n \n-static void\n-ffe_init ()\n-{\n-  /* If the file is output from cpp, it should contain a first line\n-     `# 1 \"real-filename\"', and the current design of gcc (toplev.c\n-     in particular and the way it sets up information relied on by\n-     INCLUDE) requires that we read this now, and store the\n-     \"real-filename\" info in master_input_filename.  Ask the lexer\n-     to try doing this.  */\n-  ffelex_hash_kludge (finput);\n-}\n-\n int\n mark_addressable (exp)\n      tree exp;"}, {"sha": "08264515f7fa5bbde7bd01898c86d729a9750970", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -1,3 +1,9 @@\n+2001-11-15  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* decl.c (init_decl_processing): Rename java_init_decl_processing.\n+\t* java-tree.h: New prototype.\n+\t* lang.c (java_init): Update prototype.  Combine with old init_parse.\n+\n 2001-11-13  Tom Tromey  <tromey@redhat.com>\n \n \t* gjavah.c (method_signature): New global."}, {"sha": "2577122b7d2dc67ef4d7aec0dc872f270e73cffb", "filename": "gcc/java/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -398,7 +398,7 @@ create_primitive_vtable (name)\n }\n \n void\n-init_decl_processing ()\n+java_init_decl_processing ()\n {\n   register tree endlink;\n   tree field = NULL_TREE;"}, {"sha": "e2e8cf30c8b6da07aa84c672a9d600d328377557", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -1031,6 +1031,7 @@ extern tree ident_subst PARAMS ((const char*, int,\n \t\t\t\tconst char*, int, int, const char*));\n extern tree identifier_subst PARAMS ((const tree,\n \t\t\t\t     const char *, int, int, const char *));\n+extern void java_init_decl_processing PARAMS ((void));\n extern tree build_java_signature PARAMS ((tree));\n extern tree build_java_argument_signature PARAMS ((tree));\n extern void set_java_signature PARAMS ((tree, tree));"}, {"sha": "977ed175ec4010387c6c3e048e7bcf49d9d1c25e", "filename": "gcc/java/lang.c", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -48,7 +48,7 @@ struct string_option\n   int on_value;\n };\n \n-static void java_init PARAMS ((void));\n+static const char *java_init PARAMS ((const char *));\n static void java_init_options PARAMS ((void));\n static int java_decode_option PARAMS ((int, char **));\n static void put_decl_string PARAMS ((const char *, int));\n@@ -186,7 +186,7 @@ lang_W_options[] =\n JCF *current_jcf;\n \n /* Variable controlling how dependency tracking is enabled in\n-   init_parse.  */\n+   java_init.  */\n static int dependency_tracking = 0;\n \n /* Flag values for DEPENDENCY_TRACKING.  */\n@@ -411,10 +411,15 @@ java_decode_option (argc, argv)\n /* Global open file.  */\n FILE *finput;\n \n-const char *\n-init_parse (filename)\n+static const char *\n+java_init (filename)\n      const char *filename;\n {\n+#if 0\n+  extern int flag_minimal_debug;\n+  flag_minimal_debug = 0;\n+#endif\n+\n   /* Open input file.  */\n \n   if (filename == 0 || !strcmp (filename, \"-\"))\n@@ -476,6 +481,30 @@ init_parse (filename)\n \t}\n     }\n \n+  jcf_path_init ();\n+  jcf_path_seal (version_flag);\n+\n+  decl_printable_name = lang_printable_name;\n+  print_error_function = lang_print_error;\n+  lang_expand_expr = java_lang_expand_expr;\n+\n+  /* Append to Gcc tree node definition arrays */\n+\n+  memcpy (tree_code_type + (int) LAST_AND_UNUSED_TREE_CODE,\n+\t  java_tree_code_type,\n+\t  (int)LAST_JAVA_TREE_CODE - (int)LAST_AND_UNUSED_TREE_CODE);\n+  memcpy (tree_code_length + (int) LAST_AND_UNUSED_TREE_CODE,\n+\t  java_tree_code_length,\n+\t  (LAST_JAVA_TREE_CODE - \n+\t   (int)LAST_AND_UNUSED_TREE_CODE) * sizeof (int));\n+  memcpy (tree_code_name + (int) LAST_AND_UNUSED_TREE_CODE,\n+\t  java_tree_code_name,\n+\t  (LAST_JAVA_TREE_CODE - \n+\t   (int)LAST_AND_UNUSED_TREE_CODE) * sizeof (char *));\n+  java_init_decl_processing ();\n+\n+  using_eh_for_cleanups ();\n+\n   return filename;\n }\n \n@@ -677,38 +706,6 @@ lang_print_error (context, file)\n \n }\n \n-static void\n-java_init ()\n-{\n-#if 0\n-  extern int flag_minimal_debug;\n-  flag_minimal_debug = 0;\n-#endif\n-\n-  jcf_path_init ();\n-  jcf_path_seal (version_flag);\n-\n-  decl_printable_name = lang_printable_name;\n-  print_error_function = lang_print_error;\n-  lang_expand_expr = java_lang_expand_expr;\n-\n-  /* Append to Gcc tree node definition arrays */\n-\n-  memcpy (tree_code_type + (int) LAST_AND_UNUSED_TREE_CODE,\n-\t  java_tree_code_type,\n-\t  (int)LAST_JAVA_TREE_CODE - (int)LAST_AND_UNUSED_TREE_CODE);\n-  memcpy (tree_code_length + (int) LAST_AND_UNUSED_TREE_CODE,\n-\t  java_tree_code_length,\n-\t  (LAST_JAVA_TREE_CODE - \n-\t   (int)LAST_AND_UNUSED_TREE_CODE) * sizeof (int));\n-  memcpy (tree_code_name + (int) LAST_AND_UNUSED_TREE_CODE,\n-\t  java_tree_code_name,\n-\t  (LAST_JAVA_TREE_CODE - \n-\t   (int)LAST_AND_UNUSED_TREE_CODE) * sizeof (char *));\n-\n-  using_eh_for_cleanups ();\n-}\n-\n /* This doesn't do anything on purpose. It's used to satisfy the\n    print_error_function hook we don't print error messages with bogus\n    function prototypes.  */"}, {"sha": "9823dc8797a89b60a6862fca65c757284b8c7529", "filename": "gcc/langhooks.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -59,8 +59,10 @@ struct lang_hooks\n      identifier nodes long enough for the language-specific slots.  */\n   size_t identifier_size;\n \n-  /* Called first, to initialize the front end.  */\n-  void (*init) PARAMS ((void));\n+  /* Called after options parsing, to initialize the front end.  The\n+     main input filename is passed, which may be NULL; the front end\n+     should return the original filename (e.g. foo.i -> foo.c).  */\n+  const char * (*init) PARAMS ((const char *));\n \n   /* Called last, as a finalizer.  */\n   void (*finish) PARAMS ((void));\n@@ -81,7 +83,7 @@ struct lang_hooks\n      done for this option.  */\n   int (*decode_option) PARAMS ((int, char **));\n \n-  /* Called when all command line options have been processed.  */\n+  /* Called when all command line options have been parsed.  */\n   void (*post_options) PARAMS ((void));\n \n   /* Called to obtain the alias set to be used for an expression or type."}, {"sha": "3dd0a33a50e8610b7f3331e1a2c0d0cae4f72908", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -157,7 +157,7 @@ char *util_firstobj;\n \n static void init_objc\t\t\t\tPARAMS ((void));\n static void finish_objc\t\t\t\tPARAMS ((void));\n-static void objc_init\t\t\t\tPARAMS ((void));\n+static const char *objc_init\t\t\tPARAMS ((const char *));\n static void objc_init_options\t\t\tPARAMS ((void));\n static int objc_decode_option\t\t\tPARAMS ((int, char **));\n static void objc_post_options\t\t\tPARAMS ((void));\n@@ -545,20 +545,25 @@ generate_struct_by_value_array ()\n static void\n objc_init_options ()\n {\n-  parse_in = cpp_create_reader (ident_hash, CLK_OBJC);\n+  parse_in = cpp_create_reader (CLK_OBJC);\n   c_language = clk_objective_c;\n }\n \n-static void\n-objc_init ()\n+static const char *\n+objc_init (filename)\n+     const char *filename;\n {\n+  c_init_decl_processing ();\n+\n+  filename = c_common_lang_init (filename);\n+\n+  add_c_tree_codes ();\n+\n   /* Force the line number back to 0; check_newline will have\n      raised it to 1, which will make the builtin functions appear\n      not to be built in.  */\n   lineno = 0;\n \n-  c_common_lang_init ();\n-\n   /* If gen_declaration desired, open the output file.  */\n   if (flag_gen_declaration)\n     {\n@@ -595,10 +600,11 @@ objc_init ()\n     generate_struct_by_value_array ();\n \n   objc_act_parse_init ();\n-  c_parse_init ();\n \n   VARRAY_TREE_INIT (deferred_fns, 32, \"deferred_fns\");\n   ggc_add_tree_varray_root (&deferred_fns, 1);\n+\n+  return filename;\n }\n \n /* Register a function tree, so that its optimization and conversion"}, {"sha": "3db578f6ffbcfabfe4419b319aa8d274b6c5a248", "filename": "gcc/toplev.c", "status": "modified", "additions": 479, "deletions": 415, "changes": 894, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -161,13 +161,20 @@ extern char **environ;\n extern int size_directive_output;\n extern tree last_assemble_variable_decl;\n \n+static void general_init PARAMS ((char *));\n+static void parse_options_and_default_flags PARAMS ((int, char **));\n+static void process_options PARAMS ((void));\n+static void lang_independent_init PARAMS ((void));\n+static void lang_dependent_init PARAMS ((const char *));\n+static void init_asm_output PARAMS ((const char *));\n+\n static void set_target_switch PARAMS ((const char *));\n static const char *decl_name PARAMS ((tree, int));\n \n static void float_signal PARAMS ((int)) ATTRIBUTE_NORETURN;\n static void crash_signal PARAMS ((int)) ATTRIBUTE_NORETURN;\n static void set_float_handler PARAMS ((jmp_buf));\n-static void compile_file PARAMS ((const char *));\n+static void compile_file PARAMS ((void));\n static void display_help PARAMS ((void));\n static void display_target_options PARAMS ((void));\n \n@@ -232,7 +239,7 @@ extern int target_flags;\n \n /* Debug hooks - dependent upon command line options.  */\n \n-struct gcc_debug_hooks *debug_hooks;\n+struct gcc_debug_hooks *debug_hooks = &do_nothing_debug_hooks;\n \n /* Describes a dump file.  */\n \n@@ -1438,23 +1445,6 @@ int warn_unused_parameter;\n int warn_unused_variable;\n int warn_unused_value;\n \n-void\n-set_Wunused (setting)\n-     int setting;\n-{\n-  warn_unused_function = setting;\n-  warn_unused_label = setting;\n-  /* Unused function parameter warnings are reported when either ``-W\n-     -Wunused'' or ``-Wunused-parameter'' is specified.  Differentiate\n-     -Wunused by setting WARN_UNUSED_PARAMETER to -1.  */\n-  if (!setting)\n-    warn_unused_parameter = 0;\n-  else if (!warn_unused_parameter)\n-    warn_unused_parameter = -1;\n-  warn_unused_variable = setting;\n-  warn_unused_value = setting;\n-}\n-\n /* Nonzero to warn about code which is never reached.  */\n \n int warn_notreached;\n@@ -1556,6 +1546,23 @@ lang_independent_options W_options[] =\n    N_(\"Warn about functions which might be candidates for attribute noreturn\") }\n };\n \n+void\n+set_Wunused (setting)\n+     int setting;\n+{\n+  warn_unused_function = setting;\n+  warn_unused_label = setting;\n+  /* Unused function parameter warnings are reported when either ``-W\n+     -Wunused'' or ``-Wunused-parameter'' is specified.  Differentiate\n+     -Wunused by setting WARN_UNUSED_PARAMETER to -1.  */\n+  if (!setting)\n+    warn_unused_parameter = 0;\n+  else if (!warn_unused_parameter)\n+    warn_unused_parameter = -1;\n+  warn_unused_variable = setting;\n+  warn_unused_value = setting;\n+}\n+\n /* The following routines are useful in setting all the flags that\n    -ffast-math and -fno-fast-math imply.  */\n \n@@ -2132,203 +2139,14 @@ pop_srcloc ()\n   lineno = input_file_stack->line;\n }\n \n-/* Compile an entire translation unit, whose primary source file is\n-   named NAME.  Write a file of assembly output and various debugging\n-   dumps.  */\n+/* Compile an entire translation unit.  Write a file of assembly\n+   output and various debugging dumps.  */\n \n static void\n-compile_file (name)\n-     const char *name;\n+compile_file ()\n {\n   tree globals;\n \n-  int name_specified = name != 0;\n-\n-  if (dump_base_name == 0)\n-    dump_base_name = name ? name : \"gccdump\";\n-\n-  if (! quiet_flag)\n-    time_report = 1;\n-\n-  /* Start timing total execution time.  */\n-\n-  init_timevar ();\n-  timevar_start (TV_TOTAL);\n-\n-  /* Open assembly code output file.  Do this even if -fsyntax-only is on,\n-     because then the driver will have provided the name of a temporary\n-     file or bit bucket for us.  */\n-\n-  if (! name_specified && asm_file_name == 0)\n-    asm_out_file = stdout;\n-  else\n-    {\n-      if (asm_file_name == 0)\n-        {\n-          int len = strlen (dump_base_name);\n-          char *dumpname = (char *) xmalloc (len + 6);\n-          memcpy (dumpname, dump_base_name, len + 1);\n-          strip_off_ending (dumpname, len);\n-          strcat (dumpname, \".s\");\n-          asm_file_name = dumpname;\n-        }\n-      if (!strcmp (asm_file_name, \"-\"))\n-        asm_out_file = stdout;\n-      else\n-        asm_out_file = fopen (asm_file_name, \"w\");\n-      if (asm_out_file == 0)\n-\tfatal_io_error (\"can't open %s for writing\", asm_file_name);\n-    }\n-\n-  /* Initialize data in various passes.  */\n-\n-  init_obstacks ();\n-  name = init_parse (name);\n-  init_emit_once (debug_info_level == DINFO_LEVEL_NORMAL\n-\t\t  || debug_info_level == DINFO_LEVEL_VERBOSE\n-\t\t  || flag_test_coverage\n-\t\t  || warn_notreached);\n-  init_regs ();\n-  init_alias_once ();\n-  init_decl_processing ();\n-  init_eh ();\n-  init_optabs ();\n-  init_stmt ();\n-  init_loop ();\n-  init_reload ();\n-  init_function_once ();\n-  init_stor_layout_once ();\n-  init_varasm_once ();\n-  init_EXPR_INSN_LIST_cache ();\n-\n-  /* The following initialization functions need to generate rtl, so\n-     provide a dummy function context for them.  */\n-  init_dummy_function_start ();\n-  init_expmed ();\n-  init_expr_once ();\n-  if (flag_caller_saves)\n-    init_caller_save ();\n-  expand_dummy_function_end ();\n-\n-  /* If auxiliary info generation is desired, open the output file.\n-     This goes in the same directory as the source file--unlike\n-     all the other output files.  */\n-  if (flag_gen_aux_info)\n-    {\n-      aux_info_file = fopen (aux_info_file_name, \"w\");\n-      if (aux_info_file == 0)\n-\tfatal_io_error (\"can't open %s\", aux_info_file_name);\n-    }\n-\n-#ifdef IO_BUFFER_SIZE\n-  setvbuf (asm_out_file, (char *) xmalloc (IO_BUFFER_SIZE),\n-           _IOFBF, IO_BUFFER_SIZE);\n-#endif\n-\n-  if (name != 0)\n-    name = ggc_strdup (name);\n-\n-  input_filename = name;\n-\n-  /* Put an entry on the input file stack for the main input file.  */\n-  push_srcloc (input_filename, 0);\n-\n-  /* Perform language-specific initialization.\n-     This may set main_input_filename.  */\n-  (*lang_hooks.init) ();\n-\n-  /* If the input doesn't start with a #line, use the input name\n-     as the official input file name.  */\n-  if (main_input_filename == 0)\n-    main_input_filename = name;\n-\n-  if (flag_syntax_only)\n-    {\n-      write_symbols = NO_DEBUG;\n-      profile_flag = 0;\n-      profile_block_flag = 0;\n-    }\n-  else\n-    {\n-#ifdef ASM_FILE_START\n-      ASM_FILE_START (asm_out_file);\n-#endif\n-\n-#ifdef ASM_COMMENT_START\n-      if (flag_verbose_asm)\n-\t{\n-\t  /* Print the list of options in effect.  */\n-\t  print_version (asm_out_file, ASM_COMMENT_START);\n-\t  print_switch_values (asm_out_file, 0, MAX_LINE,\n-\t\t\t       ASM_COMMENT_START, \" \", \"\\n\");\n-\t  /* Add a blank line here so it appears in assembler output but not\n-\t     screen output.  */\n-\t  fprintf (asm_out_file, \"\\n\");\n-\t}\n-#endif\n-    } /* ! flag_syntax_only  */\n-\n-  /* Set up the debug hooks based on write_symbols.  Default to doing\n-     nothing.  */\n-  debug_hooks = &do_nothing_debug_hooks;  \n-#if defined(DBX_DEBUGGING_INFO)\n-  if (write_symbols == DBX_DEBUG)\n-    debug_hooks = &dbx_debug_hooks;\n-#endif\n-#if defined(XCOFF_DEBUGGING_INFO)\n-  if (write_symbols == XCOFF_DEBUG)\n-    debug_hooks = &xcoff_debug_hooks;\n-#endif\n-#ifdef SDB_DEBUGGING_INFO\n-  if (write_symbols == SDB_DEBUG)\n-    debug_hooks = &sdb_debug_hooks;\n-#endif\n-#ifdef DWARF_DEBUGGING_INFO\n-  if (write_symbols == DWARF_DEBUG)\n-    debug_hooks = &dwarf_debug_hooks;\n-#endif\n-#ifdef DWARF2_DEBUGGING_INFO\n-  if (write_symbols == DWARF2_DEBUG)\n-    debug_hooks = &dwarf2_debug_hooks;\n-#endif\n-\n-  if (! targetm.have_named_sections)\n-    {\n-      if (flag_function_sections)\n-\t{\n-\t  warning (\"-ffunction-sections not supported for this target.\");\n-\t  flag_function_sections = 0;\n-\t}\n-      if (flag_data_sections)\n-\t{\n-\t  warning (\"-fdata-sections not supported for this target.\");\n-\t  flag_data_sections = 0;\n-\t}\n-    }\n-\n-  if (flag_function_sections\n-      && (profile_flag || profile_block_flag))\n-    {\n-      warning (\"-ffunction-sections disabled; it makes profiling impossible.\");\n-      flag_function_sections = 0;\n-    }\n-\n-#ifndef OBJECT_FORMAT_ELF\n-  if (flag_function_sections && write_symbols != NO_DEBUG)\n-    warning (\"-ffunction-sections may affect debugging on some targets.\");\n-#endif\n-\n-  /* If dbx symbol table desired, initialize writing it\n-     and output the predefined types.  */\n-  timevar_push (TV_SYMOUT);\n-#ifdef DWARF2_UNWIND_INFO\n-  if (dwarf2out_do_frame ())\n-    dwarf2out_frame_init ();\n-#endif\n-\n-  (*debug_hooks->init) (main_input_filename);\n-  timevar_pop (TV_SYMOUT);\n-\n   /* Initialize yet another pass.  */\n \n   init_final (main_input_filename);\n@@ -2491,13 +2309,6 @@ compile_file (name)\n \n   /* Free up memory for the benefit of leak detectors.  */\n   free_reg_info ();\n-\n-  /* Stop timing total execution time.  */\n-  timevar_stop (TV_TOTAL);\n-\n-  /* Print the times.  */\n-\n-  timevar_print (stderr);\n }\n \f\n /* This is called from various places for FUNCTION_DECL, VAR_DECL,\n@@ -4591,31 +4402,245 @@ independent_decode_option (argc, argv)\n   return 1;\n }\n \f\n-/* Entry point of cc1, cc1plus, jc1, f771, etc.\n-   Decode command args, then call compile_file.\n-   Exit code is FATAL_EXIT_CODE if can't open files or if there were\n-   any errors, or SUCCESS_EXIT_CODE if compilation succeeded.\n-\n-   It is not safe to call this function more than once.  */\n+/* Decode -m switches.  */\n+/* Decode the switch -mNAME.  */\n \n-int\n-toplev_main (argc, argv)\n-     int argc;\n-     char **argv;\n+static void\n+set_target_switch (name)\n+     const char *name;\n {\n-  int i;\n-  char *p;\n+  size_t j;\n+  int valid_target_option = 0;\n \n-  /* save in case md file wants to emit args as a comment.  */\n-  save_argc = argc;\n-  save_argv = argv;\n+  for (j = 0; j < ARRAY_SIZE (target_switches); j++)\n+    if (!strcmp (target_switches[j].name, name))\n+      {\n+\tif (target_switches[j].value < 0)\n+\t  target_flags &= ~-target_switches[j].value;\n+\telse\n+\t  target_flags |= target_switches[j].value;\n+\tvalid_target_option = 1;\n+      }\n \n-  p = argv[0] + strlen (argv[0]);\n-  while (p != argv[0] && !IS_DIR_SEPARATOR (p[-1]))\n-    --p;\n-  progname = p;\n+#ifdef TARGET_OPTIONS\n+  if (!valid_target_option)\n+    for (j = 0; j < ARRAY_SIZE (target_options); j++)\n+      {\n+\tint len = strlen (target_options[j].prefix);\n+\tif (!strncmp (target_options[j].prefix, name, len))\n+\t  {\n+\t    *target_options[j].variable = name + len;\n+\t    valid_target_option = 1;\n+\t  }\n+      }\n+#endif\n \n-  xmalloc_set_program_name (progname);\n+  if (!valid_target_option)\n+    error (\"Invalid option `%s'\", name);\n+}\n+\f\n+/* Print version information to FILE.\n+   Each line begins with INDENT (for the case where FILE is the\n+   assembler output file).  */\n+\n+static void\n+print_version (file, indent)\n+     FILE *file;\n+     const char *indent;\n+{\n+#ifndef __VERSION__\n+#define __VERSION__ \"[?]\"\n+#endif\n+  fnotice (file,\n+#ifdef __GNUC__\n+\t   \"%s%s%s version %s (%s)\\n%s\\tcompiled by GNU C version %s.\\n\"\n+#else\n+\t   \"%s%s%s version %s (%s) compiled by CC.\\n\"\n+#endif\n+\t   , indent, *indent != 0 ? \" \" : \"\",\n+\t   lang_hooks.name, version_string, TARGET_NAME,\n+\t   indent, __VERSION__);\n+}\n+\n+/* Print an option value and return the adjusted position in the line.\n+   ??? We don't handle error returns from fprintf (disk full); presumably\n+   other code will catch a disk full though.  */\n+\n+static int\n+print_single_switch (file, pos, max, indent, sep, term, type, name)\n+     FILE *file;\n+     int pos, max;\n+     const char *indent, *sep, *term, *type, *name;\n+{\n+  /* The ultrix fprintf returns 0 on success, so compute the result we want\n+     here since we need it for the following test.  */\n+  int len = strlen (sep) + strlen (type) + strlen (name);\n+\n+  if (pos != 0\n+      && pos + len > max)\n+    {\n+      fprintf (file, \"%s\", term);\n+      pos = 0;\n+    }\n+  if (pos == 0)\n+    {\n+      fprintf (file, \"%s\", indent);\n+      pos = strlen (indent);\n+    }\n+  fprintf (file, \"%s%s%s\", sep, type, name);\n+  pos += len;\n+  return pos;\n+}\n+\n+/* Print active target switches to FILE.\n+   POS is the current cursor position and MAX is the size of a \"line\".\n+   Each line begins with INDENT and ends with TERM.\n+   Each switch is separated from the next by SEP.  */\n+\n+static void\n+print_switch_values (file, pos, max, indent, sep, term)\n+     FILE *file;\n+     int pos, max;\n+     const char *indent, *sep, *term;\n+{\n+  size_t j;\n+  char **p;\n+\n+  /* Print the options as passed.  */\n+\n+  pos = print_single_switch (file, pos, max, indent, *indent ? \" \" : \"\", term,\n+\t\t\t     _(\"options passed: \"), \"\");\n+\n+  for (p = &save_argv[1]; *p != NULL; p++)\n+    if (**p == '-')\n+      {\n+\t/* Ignore these.  */\n+\tif (strcmp (*p, \"-o\") == 0)\n+\t  {\n+\t    if (p[1] != NULL)\n+\t      p++;\n+\t    continue;\n+\t  }\n+\tif (strcmp (*p, \"-quiet\") == 0)\n+\t  continue;\n+\tif (strcmp (*p, \"-version\") == 0)\n+\t  continue;\n+\tif ((*p)[1] == 'd')\n+\t  continue;\n+\n+\tpos = print_single_switch (file, pos, max, indent, sep, term, *p, \"\");\n+      }\n+  if (pos > 0)\n+    fprintf (file, \"%s\", term);\n+\n+  /* Print the -f and -m options that have been enabled.\n+     We don't handle language specific options but printing argv\n+     should suffice.  */\n+\n+  pos = print_single_switch (file, 0, max, indent, *indent ? \" \" : \"\", term,\n+\t\t\t     _(\"options enabled: \"), \"\");\n+\n+  for (j = 0; j < ARRAY_SIZE (f_options); j++)\n+    if (*f_options[j].variable == f_options[j].on_value)\n+      pos = print_single_switch (file, pos, max, indent, sep, term,\n+\t\t\t\t \"-f\", f_options[j].string);\n+\n+  /* Print target specific options.  */\n+\n+  for (j = 0; j < ARRAY_SIZE (target_switches); j++)\n+    if (target_switches[j].name[0] != '\\0'\n+\t&& target_switches[j].value > 0\n+\t&& ((target_switches[j].value & target_flags)\n+\t    == target_switches[j].value))\n+      {\n+\tpos = print_single_switch (file, pos, max, indent, sep, term,\n+\t\t\t\t   \"-m\", target_switches[j].name);\n+      }\n+\n+#ifdef TARGET_OPTIONS\n+  for (j = 0; j < ARRAY_SIZE (target_options); j++)\n+    if (*target_options[j].variable != NULL)\n+      {\n+\tchar prefix[256];\n+\tsprintf (prefix, \"-m%s\", target_options[j].prefix);\n+\tpos = print_single_switch (file, pos, max, indent, sep, term,\n+\t\t\t\t   prefix, *target_options[j].variable);\n+      }\n+#endif\n+\n+  fprintf (file, \"%s\", term);\n+}\n+\f\n+/* Open assembly code output file.  Do this even if -fsyntax-only is\n+   on, because then the driver will have provided the name of a\n+   temporary file or bit bucket for us.  NAME is the file specified on\n+   the command line, possibly NULL.  */\n+static void\n+init_asm_output (name)\n+     const char *name;\n+{\n+  if (name == NULL && asm_file_name == 0)\n+    asm_out_file = stdout;\n+  else\n+    {\n+      if (asm_file_name == 0)\n+        {\n+          int len = strlen (dump_base_name);\n+          char *dumpname = (char *) xmalloc (len + 6);\n+          memcpy (dumpname, dump_base_name, len + 1);\n+          strip_off_ending (dumpname, len);\n+          strcat (dumpname, \".s\");\n+          asm_file_name = dumpname;\n+        }\n+      if (!strcmp (asm_file_name, \"-\"))\n+        asm_out_file = stdout;\n+      else\n+        asm_out_file = fopen (asm_file_name, \"w\");\n+      if (asm_out_file == 0)\n+\tfatal_io_error (\"can't open %s for writing\", asm_file_name);\n+    }\n+\n+#ifdef IO_BUFFER_SIZE\n+  setvbuf (asm_out_file, (char *) xmalloc (IO_BUFFER_SIZE),\n+           _IOFBF, IO_BUFFER_SIZE);\n+#endif\n+\n+  if (!flag_syntax_only)\n+    {\n+#ifdef ASM_FILE_START\n+      ASM_FILE_START (asm_out_file);\n+#endif\n+\n+#ifdef ASM_COMMENT_START\n+      if (flag_verbose_asm)\n+\t{\n+\t  /* Print the list of options in effect.  */\n+\t  print_version (asm_out_file, ASM_COMMENT_START);\n+\t  print_switch_values (asm_out_file, 0, MAX_LINE,\n+\t\t\t       ASM_COMMENT_START, \" \", \"\\n\");\n+\t  /* Add a blank line here so it appears in assembler output but not\n+\t     screen output.  */\n+\t  fprintf (asm_out_file, \"\\n\");\n+\t}\n+#endif\n+    }\n+}\n+\f\n+/* Initialization of the front end environment, before command line\n+   options are parsed.  Signal handlers, internationalization etc.\n+   ARGV0 is main's argv[0].  */\n+static void\n+general_init (argv0)\n+     char *argv0;\n+{\n+  char *p;\n+\n+  p = argv0 + strlen (argv0);\n+  while (p != argv0 && !IS_DIR_SEPARATOR (p[-1]))\n+    --p;\n+  progname = p;\n+\n+  xmalloc_set_program_name (progname);\n \n   gcc_init_libintl ();\n \n@@ -4640,29 +4665,28 @@ toplev_main (argc, argv)\n   signal (SIGIOT, crash_signal);\n #endif\n \n-  decl_printable_name = decl_name;\n-  lang_expand_expr = (lang_expand_expr_t) do_abort;\n-\n-  /* Initialize whether `char' is signed.  */\n-  flag_signed_char = DEFAULT_SIGNED_CHAR;\n-#ifdef DEFAULT_SHORT_ENUMS\n-  /* Initialize how much space enums occupy, by default.  */\n-  flag_short_enums = DEFAULT_SHORT_ENUMS;\n-#endif\n-\n-  tree_code_length[(int) IDENTIFIER_NODE]\n-    = ((lang_hooks.identifier_size - sizeof (struct tree_common))\n-       / sizeof (tree));\n+  /* Initialize the diagnostics reporting machinery, so option parsing\n+     can give warnings and errors.  */\n+  diagnostic_initialize (global_dc);\n+}\n+\f\n+/* Parse command line options and set default flag values, called\n+   after language-independent option-independent intialization.  Do\n+   minimal options processing.  Outputting diagnostics is OK, but GC\n+   and identifier hashtables etc. are not initialized yet.  */\n+static void\n+parse_options_and_default_flags (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  int i;\n \n-  /* Initialize the garbage-collector.  */\n-  init_ggc ();\n-  init_stringpool ();\n-  ggc_add_rtx_root (&stack_limit_rtx, 1);\n-  ggc_add_tree_root (&current_function_decl, 1);\n-  ggc_add_tree_root (&current_function_func_begin_label, 1);\n+  /* Save in case md file wants to emit args as a comment.  */\n+  save_argc = argc;\n+  save_argv = argv;\n \n-  /* Initialize the diagnostics reporting machinery.  */\n-  diagnostic_initialize (global_dc);\n+  /* Initialize register usage now so switches may override.  */\n+  init_reg_sets ();\n \n   /* Register the language-independent parameters.  */\n   add_params (lang_independent_params, LAST_PARAM);\n@@ -4758,6 +4782,13 @@ toplev_main (argc, argv)\n       align_functions = 1;\n     }\n \n+  /* Initialize whether `char' is signed.  */\n+  flag_signed_char = DEFAULT_SIGNED_CHAR;\n+#ifdef DEFAULT_SHORT_ENUMS\n+  /* Initialize how much space enums occupy, by default.  */\n+  flag_short_enums = DEFAULT_SHORT_ENUMS;\n+#endif\n+\n   /* Initialize target_flags before OPTIMIZATION_OPTIONS so the latter can\n      modify it.  */\n   target_flags = 0;\n@@ -4774,9 +4805,6 @@ toplev_main (argc, argv)\n   OPTIMIZATION_OPTIONS (optimize, optimize_size);\n #endif\n \n-  /* Initialize register usage now so switches may override.  */\n-  init_reg_sets ();\n-\n   /* Perform normal command line switch decoding.  */\n   for (i = 1; i < argc;)\n     {\n@@ -4844,10 +4872,12 @@ toplev_main (argc, argv)\n \n   /* All command line options have been processed.  */\n   (*lang_hooks.post_options) ();\n-\n-  if (exit_after_options)\n-    exit (0);\n-\n+}\n+\f\n+/* Process the options that have been parsed.  */\n+static void\n+process_options ()\n+{\n   /* Checker uses the frame pointer.  */\n   if (flag_check_memory_usage)\n     flag_omit_frame_pointer = 0;\n@@ -4963,180 +4993,214 @@ toplev_main (argc, argv)\n \tprint_switch_values (stderr, 0, MAX_LINE, \"\", \" \", \"\\n\");\n     }\n \n-  compile_file (filename);\n-\n-  if (errorcount)\n-    return (FATAL_EXIT_CODE);\n-  if (sorrycount)\n-    return (FATAL_EXIT_CODE);\n-  return (SUCCESS_EXIT_CODE);\n-}\n-\f\n-/* Decode -m switches.  */\n-/* Decode the switch -mNAME.  */\n+  if (! quiet_flag)\n+    time_report = 1;\n \n-static void\n-set_target_switch (name)\n-     const char *name;\n-{\n-  size_t j;\n-  int valid_target_option = 0;\n+  if (flag_syntax_only)\n+    {\n+      write_symbols = NO_DEBUG;\n+      profile_flag = 0;\n+      profile_block_flag = 0;\n+    }\n \n-  for (j = 0; j < ARRAY_SIZE (target_switches); j++)\n-    if (!strcmp (target_switches[j].name, name))\n-      {\n-\tif (target_switches[j].value < 0)\n-\t  target_flags &= ~-target_switches[j].value;\n-\telse\n-\t  target_flags |= target_switches[j].value;\n-\tvalid_target_option = 1;\n-      }\n-\n-#ifdef TARGET_OPTIONS\n-  if (!valid_target_option)\n-    for (j = 0; j < ARRAY_SIZE (target_options); j++)\n-      {\n-\tint len = strlen (target_options[j].prefix);\n-\tif (!strncmp (target_options[j].prefix, name, len))\n-\t  {\n-\t    *target_options[j].variable = name + len;\n-\t    valid_target_option = 1;\n-\t  }\n-      }\n+  /* Now we know write_symbols, set up the debug hooks based on it.\n+     By default we do nothing for debug output.  */\n+#if defined(DBX_DEBUGGING_INFO)\n+  if (write_symbols == DBX_DEBUG)\n+    debug_hooks = &dbx_debug_hooks;\n #endif\n-\n-  if (!valid_target_option)\n-    error (\"Invalid option `%s'\", name);\n-}\n-\f\n-/* Print version information to FILE.\n-   Each line begins with INDENT (for the case where FILE is the\n-   assembler output file).  */\n-\n-static void\n-print_version (file, indent)\n-     FILE *file;\n-     const char *indent;\n-{\n-#ifndef __VERSION__\n-#define __VERSION__ \"[?]\"\n+#if defined(XCOFF_DEBUGGING_INFO)\n+  if (write_symbols == XCOFF_DEBUG)\n+    debug_hooks = &xcoff_debug_hooks;\n #endif\n-  fnotice (file,\n-#ifdef __GNUC__\n-\t   \"%s%s%s version %s (%s)\\n%s\\tcompiled by GNU C version %s.\\n\"\n-#else\n-\t   \"%s%s%s version %s (%s) compiled by CC.\\n\"\n+#ifdef SDB_DEBUGGING_INFO\n+  if (write_symbols == SDB_DEBUG)\n+    debug_hooks = &sdb_debug_hooks;\n+#endif\n+#ifdef DWARF_DEBUGGING_INFO\n+  if (write_symbols == DWARF_DEBUG)\n+    debug_hooks = &dwarf_debug_hooks;\n+#endif\n+#ifdef DWARF2_DEBUGGING_INFO\n+  if (write_symbols == DWARF2_DEBUG)\n+    debug_hooks = &dwarf2_debug_hooks;\n #endif\n-\t   , indent, *indent != 0 ? \" \" : \"\",\n-\t   lang_hooks.name, version_string, TARGET_NAME,\n-\t   indent, __VERSION__);\n-}\n-\n-/* Print an option value and return the adjusted position in the line.\n-   ??? We don't handle error returns from fprintf (disk full); presumably\n-   other code will catch a disk full though.  */\n \n-static int\n-print_single_switch (file, pos, max, indent, sep, term, type, name)\n-     FILE *file;\n-     int pos, max;\n-     const char *indent, *sep, *term, *type, *name;\n-{\n-  /* The ultrix fprintf returns 0 on success, so compute the result we want\n-     here since we need it for the following test.  */\n-  int len = strlen (sep) + strlen (type) + strlen (name);\n+  /* If auxiliary info generation is desired, open the output file.\n+     This goes in the same directory as the source file--unlike\n+     all the other output files.  */\n+  if (flag_gen_aux_info)\n+    {\n+      aux_info_file = fopen (aux_info_file_name, \"w\");\n+      if (aux_info_file == 0)\n+\tfatal_io_error (\"can't open %s\", aux_info_file_name);\n+    }\n \n-  if (pos != 0\n-      && pos + len > max)\n+  if (! targetm.have_named_sections)\n     {\n-      fprintf (file, \"%s\", term);\n-      pos = 0;\n+      if (flag_function_sections)\n+\t{\n+\t  warning (\"-ffunction-sections not supported for this target.\");\n+\t  flag_function_sections = 0;\n+\t}\n+      if (flag_data_sections)\n+\t{\n+\t  warning (\"-fdata-sections not supported for this target.\");\n+\t  flag_data_sections = 0;\n+\t}\n     }\n-  if (pos == 0)\n+\n+  if (flag_function_sections\n+      && (profile_flag || profile_block_flag))\n     {\n-      fprintf (file, \"%s\", indent);\n-      pos = strlen (indent);\n+      warning (\"-ffunction-sections disabled; it makes profiling impossible.\");\n+      flag_function_sections = 0;\n     }\n-  fprintf (file, \"%s%s%s\", sep, type, name);\n-  pos += len;\n-  return pos;\n+\n+#ifndef OBJECT_FORMAT_ELF\n+  if (flag_function_sections && write_symbols != NO_DEBUG)\n+    warning (\"-ffunction-sections may affect debugging on some targets.\");\n+#endif\n }\n+\f\n+/* Language-independent initialization, before language-dependent\n+   initialization.  */\n+static void\n+lang_independent_init ()\n+{\n+  decl_printable_name = decl_name;\n+  lang_expand_expr = (lang_expand_expr_t) do_abort;\n \n-/* Print active target switches to FILE.\n-   POS is the current cursor position and MAX is the size of a \"line\".\n-   Each line begins with INDENT and ends with TERM.\n-   Each switch is separated from the next by SEP.  */\n+  /* Set the language-dependent identifer size.  */\n+  tree_code_length[(int) IDENTIFIER_NODE]\n+    = ((lang_hooks.identifier_size - sizeof (struct tree_common))\n+       / sizeof (tree));\n+\n+  /* Initialize the garbage-collector, and string pools.  FIXME: We\n+     should do this later, in independent_init () when we know we\n+     actually want to compile something, but cpplib currently wants to\n+     use the hash table immediately in cpp_create_reader.  */\n+  init_ggc ();\n+  ggc_add_rtx_root (&stack_limit_rtx, 1);\n+  ggc_add_tree_root (&current_function_decl, 1);\n+  ggc_add_tree_root (&current_function_func_begin_label, 1);\n \n+  init_stringpool ();\n+  init_obstacks ();\n+\n+  init_emit_once (debug_info_level == DINFO_LEVEL_NORMAL\n+\t\t  || debug_info_level == DINFO_LEVEL_VERBOSE\n+\t\t  || flag_test_coverage\n+\t\t  || warn_notreached);\n+  init_regs ();\n+  init_alias_once ();\n+  init_stmt ();\n+  init_loop ();\n+  init_reload ();\n+  init_function_once ();\n+  init_stor_layout_once ();\n+  init_varasm_once ();\n+  init_EXPR_INSN_LIST_cache ();\n+\n+  /* The following initialization functions need to generate rtl, so\n+     provide a dummy function context for them.  */\n+  init_dummy_function_start ();\n+  init_expmed ();\n+  init_expr_once ();\n+  if (flag_caller_saves)\n+    init_caller_save ();\n+  expand_dummy_function_end ();\n+}\n+\f\n+/* Language-dependent initialization.  */\n static void\n-print_switch_values (file, pos, max, indent, sep, term)\n-     FILE *file;\n-     int pos, max;\n-     const char *indent, *sep, *term;\n+lang_dependent_init (name)\n+     const char *name;\n {\n-  size_t j;\n-  char **p;\n+  if (dump_base_name == 0)\n+    dump_base_name = name ? name : \"gccdump\";\n \n-  /* Print the options as passed.  */\n+  /* Front-end initialization.  This hook can assume that GC,\n+     identifier hashes etc. are set up, but debug initialization is\n+     not done yet.  This routine must return the original filename\n+     (e.g. foo.i -> foo.c) so can correctly initialize debug output.  */\n+  name = (*lang_hooks.init) (name);\n \n-  pos = print_single_switch (file, pos, max, indent, *indent ? \" \" : \"\", term,\n-\t\t\t     _(\"options passed: \"), \"\");\n+  if (name)\n+    name = ggc_strdup (name);\n \n-  for (p = &save_argv[1]; *p != NULL; p++)\n-    if (**p == '-')\n-      {\n-\t/* Ignore these.  */\n-\tif (strcmp (*p, \"-o\") == 0)\n-\t  {\n-\t    if (p[1] != NULL)\n-\t      p++;\n-\t    continue;\n-\t  }\n-\tif (strcmp (*p, \"-quiet\") == 0)\n-\t  continue;\n-\tif (strcmp (*p, \"-version\") == 0)\n-\t  continue;\n-\tif ((*p)[1] == 'd')\n-\t  continue;\n+  main_input_filename = input_filename = name;\n+  init_asm_output (name);\n \n-\tpos = print_single_switch (file, pos, max, indent, sep, term, *p, \"\");\n-      }\n-  if (pos > 0)\n-    fprintf (file, \"%s\", term);\n+  /* These create various _DECL nodes, so need to be called after the\n+     front end is initialized.  */\n+  init_eh ();\n+  init_optabs ();\n \n-  /* Print the -f and -m options that have been enabled.\n-     We don't handle language specific options but printing argv\n-     should suffice.  */\n+  /* Put an entry on the input file stack for the main input file.  */\n+  push_srcloc (input_filename, 0);\n \n-  pos = print_single_switch (file, 0, max, indent, *indent ? \" \" : \"\", term,\n-\t\t\t     _(\"options enabled: \"), \"\");\n+  /* If dbx symbol table desired, initialize writing it and output the\n+     predefined types.  */\n+  timevar_push (TV_SYMOUT);\n \n-  for (j = 0; j < ARRAY_SIZE (f_options); j++)\n-    if (*f_options[j].variable == f_options[j].on_value)\n-      pos = print_single_switch (file, pos, max, indent, sep, term,\n-\t\t\t\t \"-f\", f_options[j].string);\n+#ifdef DWARF2_UNWIND_INFO\n+  if (dwarf2out_do_frame ())\n+    dwarf2out_frame_init ();\n+#endif\n \n-  /* Print target specific options.  */\n+  /* Now we have the correct original filename, we can initialize\n+     debug output.  */\n+  (*debug_hooks->init) (name);\n \n-  for (j = 0; j < ARRAY_SIZE (target_switches); j++)\n-    if (target_switches[j].name[0] != '\\0'\n-\t&& target_switches[j].value > 0\n-\t&& ((target_switches[j].value & target_flags)\n-\t    == target_switches[j].value))\n-      {\n-\tpos = print_single_switch (file, pos, max, indent, sep, term,\n-\t\t\t\t   \"-m\", target_switches[j].name);\n-      }\n+  timevar_pop (TV_SYMOUT);\n+}\n+\f\n+/* Entry point of cc1, cc1plus, jc1, f771, etc.\n+   Decode command args, then call compile_file.\n+   Exit code is FATAL_EXIT_CODE if can't open files or if there were\n+   any errors, or SUCCESS_EXIT_CODE if compilation succeeded.\n \n-#ifdef TARGET_OPTIONS\n-  for (j = 0; j < ARRAY_SIZE (target_options); j++)\n-    if (*target_options[j].variable != NULL)\n-      {\n-\tchar prefix[256];\n-\tsprintf (prefix, \"-m%s\", target_options[j].prefix);\n-\tpos = print_single_switch (file, pos, max, indent, sep, term,\n-\t\t\t\t   prefix, *target_options[j].variable);\n-      }\n-#endif\n+   It is not safe to call this function more than once.  */\n \n-  fprintf (file, \"%s\", term);\n+int\n+toplev_main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  /* Initialization of GCC's environment, and diagnostics.  */\n+  general_init (argv [0]);\n+\n+  /* Parse the options and do minimal processing; basically just\n+     enough to default flags appropriately.  */\n+  parse_options_and_default_flags (argc, argv);\n+\n+  /* Exit early if we can (e.g. -help).  */\n+  if (exit_after_options)\n+    return (SUCCESS_EXIT_CODE);\n+\n+  /* Start timing total execution time.  */\n+  init_timevar ();\n+  timevar_start (TV_TOTAL);\n+\n+  /* The bulk of command line switch processing.  */\n+  process_options ();\n+\n+  /* Language-independent initialization.  Also sets up GC, identifier\n+     hashes etc.  */\n+  lang_independent_init ();\n+\n+  /* Language-dependent initialization.  */\n+  lang_dependent_init (filename);\n+\n+  compile_file ();\n+\n+  /* Stop timing and print the times.  */\n+  timevar_stop (TV_TOTAL);\n+  timevar_print (stderr);\n+\n+  if (errorcount || sorrycount)\n+    return (FATAL_EXIT_CODE);\n+\n+  return (SUCCESS_EXIT_CODE);\n }"}, {"sha": "4fa32801aa15fb565191f88e372082612f73d788", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e99456f19b80978984f781e1d847b90d09b30a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=f5e99456f19b80978984f781e1d847b90d09b30a", "patch": "@@ -2647,7 +2647,6 @@ extern const char *(*decl_printable_name)\tPARAMS ((tree, int));\n \n extern void (*incomplete_decl_finalize_hook)\tPARAMS ((tree));\n \n-extern const char *init_parse\t\t\tPARAMS ((const char *));\n extern void finish_parse\t\t\tPARAMS ((void));\n \n /* Declare a predefined function.  Return the declaration.  This function is\n@@ -2775,9 +2774,6 @@ extern tree fold_builtin\t\tPARAMS ((tree));\n \f\n /* The language front-end must define these functions.  */\n \n-/* Function of no arguments for initializing the symbol table.  */\n-extern void init_decl_processing\t\tPARAMS ((void));\n-\n /* Function to replace the DECL_LANG_SPECIFIC field of a DECL with a copy.  */\n extern void copy_lang_decl\t\t\tPARAMS ((tree));\n "}]}