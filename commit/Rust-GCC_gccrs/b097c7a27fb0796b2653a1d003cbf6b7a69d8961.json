{"sha": "b097c7a27fb0796b2653a1d003cbf6b7a69d8961", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA5N2M3YTI3ZmIwNzk2YjI2NTNhMWQwMDNjYmY2YjdhNjlkODk2MQ==", "commit": {"author": {"name": "Szabolcs Nagy", "email": "szabolcs.nagy@arm.com", "date": "2020-06-04T08:33:35Z"}, "committer": {"name": "Szabolcs Nagy", "email": "szabolcs.nagy@arm.com", "date": "2020-07-13T12:49:20Z"}, "message": "libgcc: fix the handling of return address mangling [PR94891]\n\nMangling, currently only used on AArch64 for return address signing,\nis an internal representation that should not be exposed via\n\n  __builtin_return_address return value,\n  __builtin_eh_return handler argument,\n  _Unwind_DebugHook handler argument.\n\nNote that a mangled address might not even fit into a void *, e.g.\nwith AArch64 ilp32 ABI the return address is stored as 64bit, so\nthe mangled return address cannot be accessed via _Unwind_GetPtr.\n\nThis patch changes the unwinder hooks as follows:\n\nMD_POST_EXTRACT_ROOT_ADDR is removed: root address comes from\n__builtin_return_address which is not mangled.\n\nMD_POST_EXTRACT_FRAME_ADDR is renamed to MD_DEMANGLE_RETURN_ADDR,\nit now operates on _Unwind_Word instead of void *, so the hook\nshould work when return address signing is enabled on AArch64 ilp32.\n(But for that __builtin_aarch64_autia1716 should be fixed to operate\non 64bit input instead of a void *.)\n\nMD_POST_FROB_EH_HANDLER_ADDR is removed: it is the responsibility of\n__builtin_eh_return to do the mangling if necessary.\n\n2020-07-13  Szabolcs Nagy  <szabolcs.nagy@arm.com>\n\nlibgcc/ChangeLog:\n\n\tPR target/94891\n\t* config/aarch64/aarch64-unwind.h (MD_POST_EXTRACT_ROOT_ADDR): Remove.\n\t(MD_POST_FROB_EH_HANDLER_ADDR): Remove.\n\t(MD_POST_EXTRACT_FRAME_ADDR): Rename to ...\n\t(MD_DEMANGLE_RETURN_ADDR): This.\n\t(aarch64_post_extract_frame_addr): Rename to ...\n\t(aarch64_demangle_return_addr): This.\n\t(aarch64_post_frob_eh_handler_addr): Remove.\n\t* unwind-dw2.c (uw_update_context): Demangle return address.\n\t(uw_frob_return_addr): Remove.", "tree": {"sha": "5562101be365c2497804621e3d1121e860420733", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5562101be365c2497804621e3d1121e860420733"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b097c7a27fb0796b2653a1d003cbf6b7a69d8961", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b097c7a27fb0796b2653a1d003cbf6b7a69d8961", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b097c7a27fb0796b2653a1d003cbf6b7a69d8961", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b097c7a27fb0796b2653a1d003cbf6b7a69d8961/comments", "author": {"login": "nsz-arm", "id": 30925343, "node_id": "MDQ6VXNlcjMwOTI1MzQz", "avatar_url": "https://avatars.githubusercontent.com/u/30925343?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nsz-arm", "html_url": "https://github.com/nsz-arm", "followers_url": "https://api.github.com/users/nsz-arm/followers", "following_url": "https://api.github.com/users/nsz-arm/following{/other_user}", "gists_url": "https://api.github.com/users/nsz-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/nsz-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nsz-arm/subscriptions", "organizations_url": "https://api.github.com/users/nsz-arm/orgs", "repos_url": "https://api.github.com/users/nsz-arm/repos", "events_url": "https://api.github.com/users/nsz-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/nsz-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nsz-arm", "id": 30925343, "node_id": "MDQ6VXNlcjMwOTI1MzQz", "avatar_url": "https://avatars.githubusercontent.com/u/30925343?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nsz-arm", "html_url": "https://github.com/nsz-arm", "followers_url": "https://api.github.com/users/nsz-arm/followers", "following_url": "https://api.github.com/users/nsz-arm/following{/other_user}", "gists_url": "https://api.github.com/users/nsz-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/nsz-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nsz-arm/subscriptions", "organizations_url": "https://api.github.com/users/nsz-arm/orgs", "repos_url": "https://api.github.com/users/nsz-arm/repos", "events_url": "https://api.github.com/users/nsz-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/nsz-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bc95be3bb8c8138e2e87c1c11c84bfede989d61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bc95be3bb8c8138e2e87c1c11c84bfede989d61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bc95be3bb8c8138e2e87c1c11c84bfede989d61"}], "stats": {"total": 74, "additions": 16, "deletions": 58}, "files": [{"sha": "3c5f85b43c815f6a9187fe3b477b74278af402da", "filename": "libgcc/config/aarch64/aarch64-unwind.h", "status": "modified", "additions": 8, "deletions": 32, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b097c7a27fb0796b2653a1d003cbf6b7a69d8961/libgcc%2Fconfig%2Faarch64%2Faarch64-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b097c7a27fb0796b2653a1d003cbf6b7a69d8961/libgcc%2Fconfig%2Faarch64%2Faarch64-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Faarch64%2Faarch64-unwind.h?ref=b097c7a27fb0796b2653a1d003cbf6b7a69d8961", "patch": "@@ -27,11 +27,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #define DWARF_REGNUM_AARCH64_RA_STATE 34\n \n-#define MD_POST_EXTRACT_ROOT_ADDR(addr)  __builtin_aarch64_xpaclri (addr)\n-#define MD_POST_EXTRACT_FRAME_ADDR(context, fs, addr) \\\n-  aarch64_post_extract_frame_addr (context, fs, addr)\n-#define MD_POST_FROB_EH_HANDLER_ADDR(current, target, addr) \\\n-  aarch64_post_frob_eh_handler_addr (current, target, addr)\n+#define MD_DEMANGLE_RETURN_ADDR(context, fs, addr) \\\n+  aarch64_demangle_return_addr (context, fs, addr)\n #define MD_FROB_UPDATE_CONTEXT(context, fs) \\\n   aarch64_frob_update_context (context, fs)\n \n@@ -52,14 +49,15 @@ aarch64_cie_signed_with_b_key (struct _Unwind_Context *context)\n   return 0;\n }\n \n-/* Do AArch64 private extraction on ADDR based on context info CONTEXT and\n-   unwind frame info FS.  If ADDR is signed, we do address authentication on it\n-   using CFA of current frame.  */\n+/* Do AArch64 private extraction on ADDR_WORD based on context info CONTEXT and\n+   unwind frame info FS.  If ADDR_WORD is signed, we do address authentication\n+   on it using CFA of current frame.  */\n \n static inline void *\n-aarch64_post_extract_frame_addr (struct _Unwind_Context *context,\n-\t\t\t\t _Unwind_FrameState *fs, void *addr)\n+aarch64_demangle_return_addr (struct _Unwind_Context *context,\n+\t\t\t      _Unwind_FrameState *fs, _Unwind_Word addr_word)\n {\n+  void *addr = (void *)addr_word;\n   if (context->flags & RA_SIGNED_BIT)\n     {\n       _Unwind_Word salt = (_Unwind_Word) context->cfa;\n@@ -71,28 +69,6 @@ aarch64_post_extract_frame_addr (struct _Unwind_Context *context,\n     return addr;\n }\n \n-/* Do AArch64 private frob on exception handler's address HANDLER_ADDR before\n-   installing it into current context CURRENT.  TARGET is currently not used.\n-   We need to sign exception handler's address if CURRENT itself is signed.  */\n-\n-static inline void *\n-aarch64_post_frob_eh_handler_addr (struct _Unwind_Context *current,\n-\t\t\t\t   struct _Unwind_Context *target\n-\t\t\t\t   ATTRIBUTE_UNUSED,\n-\t\t\t\t   void *handler_addr)\n-{\n-  if (current->flags & RA_SIGNED_BIT)\n-    {\n-      if (aarch64_cie_signed_with_b_key (current))\n-\treturn __builtin_aarch64_pacib1716 (handler_addr,\n-\t\t\t\t\t    (_Unwind_Word) current->cfa);\n-      return __builtin_aarch64_pacia1716 (handler_addr,\n-\t\t\t\t\t(_Unwind_Word) current->cfa);\n-    }\n-  else\n-    return handler_addr;\n-}\n-\n /* Do AArch64 private initialization on CONTEXT based on frame info FS.  Mark\n    CONTEXT as return address signed if bit 0 of DWARF_REGNUM_AARCH64_RA_STATE is\n    set.  */"}, {"sha": "fe896565d2ec5c43ac683f2c6ed6d5e49fd8242e", "filename": "libgcc/unwind-dw2.c", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b097c7a27fb0796b2653a1d003cbf6b7a69d8961/libgcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b097c7a27fb0796b2653a1d003cbf6b7a69d8961/libgcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-dw2.c?ref=b097c7a27fb0796b2653a1d003cbf6b7a69d8961", "patch": "@@ -1538,11 +1538,14 @@ uw_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n     {\n       /* Compute the return address now, since the return address column\n \t can change from frame to frame.  */\n-      context->ra = __builtin_extract_return_addr\n-\t(_Unwind_GetPtr (context, fs->retaddr_column));\n-#ifdef MD_POST_EXTRACT_FRAME_ADDR\n-      context->ra = MD_POST_EXTRACT_FRAME_ADDR (context, fs, context->ra);\n+      void *ret_addr;\n+#ifdef MD_DEMANGLE_RETURN_ADDR\n+      _Unwind_Word ra = _Unwind_GetGR (context, fs->retaddr_column);\n+      ret_addr = MD_DEMANGLE_RETURN_ADDR (context, fs, ra);\n+#else\n+      ret_addr = _Unwind_GetPtr (context, fs->retaddr_column);\n #endif\n+      context->ra = __builtin_extract_return_addr (ret_addr);\n     }\n }\n \n@@ -1577,9 +1580,6 @@ uw_init_context_1 (struct _Unwind_Context *context,\n \t\t   void *outer_cfa, void *outer_ra)\n {\n   void *ra = __builtin_extract_return_addr (__builtin_return_address (0));\n-#ifdef MD_POST_EXTRACT_ROOT_ADDR\n-  ra = MD_POST_EXTRACT_ROOT_ADDR (ra);\n-#endif\n   _Unwind_FrameState fs;\n   _Unwind_SpTmp sp_slot;\n   _Unwind_Reason_Code code;\n@@ -1616,9 +1616,6 @@ uw_init_context_1 (struct _Unwind_Context *context,\n      initialization context, then we can't see it in the given\n      call frame data.  So have the initialization context tell us.  */\n   context->ra = __builtin_extract_return_addr (outer_ra);\n-#ifdef MD_POST_EXTRACT_ROOT_ADDR\n-  context->ra = MD_POST_EXTRACT_ROOT_ADDR (context->ra);\n-#endif\n }\n \n static void _Unwind_DebugHook (void *, void *)\n@@ -1641,21 +1638,6 @@ _Unwind_DebugHook (void *cfa __attribute__ ((__unused__)),\n #endif\n }\n \n-/* Frob exception handler's address kept in TARGET before installing into\n-   CURRENT context.  */\n-\n-static inline void *\n-uw_frob_return_addr (struct _Unwind_Context *current\n-\t\t     __attribute__ ((__unused__)),\n-\t\t     struct _Unwind_Context *target)\n-{\n-  void *ret_addr = __builtin_frob_return_addr (target->ra);\n-#ifdef MD_POST_FROB_EH_HANDLER_ADDR\n-  ret_addr = MD_POST_FROB_EH_HANDLER_ADDR (current, target, ret_addr);\n-#endif\n-  return ret_addr;\n-}\n-\n /* Install TARGET into CURRENT so that we can return to it.  This is a\n    macro because __builtin_eh_return must be invoked in the context of\n    our caller.  FRAMES is a number of frames to be unwind.\n@@ -1667,7 +1649,7 @@ uw_frob_return_addr (struct _Unwind_Context *current\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       long offset = uw_install_context_1 ((CURRENT), (TARGET));\t\t\\\n-      void *handler = uw_frob_return_addr ((CURRENT), (TARGET));\t\\\n+      void *handler = __builtin_frob_return_addr ((TARGET)->ra);\t\\\n       _Unwind_DebugHook ((TARGET)->cfa, handler);\t\t\t\\\n       _Unwind_Frames_Extra (FRAMES);\t\t\t\t\t\\\n       __builtin_eh_return (offset, handler);\t\t\t\t\\"}]}