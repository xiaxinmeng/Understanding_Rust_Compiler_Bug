{"sha": "96043e7e1c32c6d82aab98b95ec36b7628bd6a0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTYwNDNlN2UxYzMyYzZkODJhYWI5OGI5NWVjMzZiNzYyOGJkNmEwZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-04-12T03:11:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-04-12T03:11:37Z"}, "message": "alpha.c (aligned_memory_operand): Handle out of range stack slots.\n\n        * alpha.c (aligned_memory_operand): Handle out of range stack slots.\n        Take a new SCRATCH argument for the occasion.  Update all callers.\n        (get_unaligned_address): Abort on out of range stack slots.\n        * alpha.md (adddi3 splitter): Check s_p_rtx not REGNO.\n        (reload_inqi): Check for aligned mems before unaligned.\n        (reload_inhi): Likewise.\n\nFrom-SVN: r26362", "tree": {"sha": "5acae0f8f6ae504e24da7b922ab3f7bc19f2b5cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5acae0f8f6ae504e24da7b922ab3f7bc19f2b5cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96043e7e1c32c6d82aab98b95ec36b7628bd6a0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96043e7e1c32c6d82aab98b95ec36b7628bd6a0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96043e7e1c32c6d82aab98b95ec36b7628bd6a0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96043e7e1c32c6d82aab98b95ec36b7628bd6a0e/comments", "author": null, "committer": null, "parents": [{"sha": "55a98783c87b42efddbc8a1dcda79fa62888e982", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55a98783c87b42efddbc8a1dcda79fa62888e982", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55a98783c87b42efddbc8a1dcda79fa62888e982"}], "stats": {"total": 190, "additions": 142, "deletions": 48}, "files": [{"sha": "9178df129962ef24516ea8cb67b9fa754a4e2633", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96043e7e1c32c6d82aab98b95ec36b7628bd6a0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96043e7e1c32c6d82aab98b95ec36b7628bd6a0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96043e7e1c32c6d82aab98b95ec36b7628bd6a0e", "patch": "@@ -1,3 +1,12 @@\n+Mon Apr 12 03:07:44 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.c (aligned_memory_operand): Handle out of range stack slots.\n+\tTake a new SCRATCH argument for the occasion.  Update all callers.\n+\t(get_unaligned_address): Abort on out of range stack slots.\n+\t* alpha.md (adddi3 splitter): Check s_p_rtx not REGNO.\n+\t(reload_inqi): Check for aligned mems before unaligned.\n+\t(reload_inhi): Likewise.\n+\n Mon Apr 12 03:11:30 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* flow.c (flow_delete_insn): If we delete a CODE_LABEL, also remove"}, {"sha": "1b7ecd365ebe730ca2a0ed2548c99540e094a08e", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 75, "deletions": 22, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96043e7e1c32c6d82aab98b95ec36b7628bd6a0e/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96043e7e1c32c6d82aab98b95ec36b7628bd6a0e/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=96043e7e1c32c6d82aab98b95ec36b7628bd6a0e", "patch": "@@ -728,11 +728,7 @@ divmod_operator (op, mode)\n    a constant.  It must be a valid address.  This means that we can do\n    this as an aligned reference plus some offset.\n \n-   Take into account what reload will do.\n-\n-   We could say that out-of-range stack slots are alignable, but that would\n-   complicate get_aligned_mem and it isn't worth the trouble since few\n-   functions have large stack space.  */\n+   Take into account what reload will do.  */\n \n int\n aligned_memory_operand (op, mode)\n@@ -747,11 +743,18 @@ aligned_memory_operand (op, mode)\n       mode = GET_MODE (op);\n     }\n \n-  if (reload_in_progress && GET_CODE (op) == REG\n-      && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n-    op = reg_equiv_mem[REGNO (op)];\n+  if (reload_in_progress)\n+    {\n+      /* This is a stack slot.  The stack pointer is always aligned.\n+\t We may have to jump through hoops to get a valid address,\n+\t but we can do it.  */\n+      if (GET_CODE (op) == REG\n+          && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+\treturn 1;\n+    }\n \n-  if (GET_CODE (op) != MEM || GET_MODE (op) != mode\n+  if (GET_CODE (op) != MEM\n+      || GET_MODE (op) != mode\n       || ! memory_address_p (mode, XEXP (op, 0)))\n     return 0;\n \n@@ -899,11 +902,12 @@ direct_return ()\n \n /* REF is an alignable memory location.  Place an aligned SImode\n    reference into *PALIGNED_MEM and the number of bits to shift into\n-   *PBITNUM.  */\n+   *PBITNUM.  SCRATCH is a free register for use in reloading out\n+   of range stack slots.  */\n \n void\n-get_aligned_mem (ref, paligned_mem, pbitnum)\n-     rtx ref;\n+get_aligned_mem (ref, scratch, paligned_mem, pbitnum)\n+     rtx ref, scratch;\n      rtx *paligned_mem, *pbitnum;\n {\n   rtx base;\n@@ -919,13 +923,48 @@ get_aligned_mem (ref, paligned_mem, pbitnum)\n       ref = SUBREG_REG (ref);\n     }\n \n-  if (GET_CODE (ref) == REG)\n-    ref = reg_equiv_mem[REGNO (ref)];\n-\n   if (reload_in_progress)\n-    base = find_replacement (&XEXP (ref, 0));\n+    {\n+      if (GET_CODE (ref) == REG)\n+\t{\n+\t  /* The \"simple\" case is where the stack slot is in range.  */\n+\t  if (reg_equiv_mem[REGNO (ref)])\n+\t    {\n+\t      ref = reg_equiv_mem[REGNO (ref)];\n+\t      base = find_replacement (&XEXP (ref, 0));\n+\t    }\n+\t  else\n+\t    {\n+\t      /* The stack slot isn't in range.  Fix it up as needed.  */\n+\t      HOST_WIDE_INT hi, lo;\n+\n+\t      base = reg_equiv_address[REGNO (ref)];\n+\t      if (GET_CODE (base) != PLUS)\n+\t\tabort ();\n+\t      offset += INTVAL (XEXP (base, 1));\n+\t      base = XEXP (base, 0);\n+\n+\t      lo = ((offset & 0xFFFF) ^ 0x8000) - 0x8000;\n+\t      hi = (((offset - lo) & 0xFFFFFFFF) ^ 0x80000000) - 0x80000000;\n+\t      if (hi + lo != offset)\n+\t\tabort ();\n+\t      if (scratch == NULL)\n+\t\tabort ();\n+\n+\t      emit_insn (gen_adddi3 (scratch, base, GEN_INT (hi)));\n+\t      base = scratch;\n+\t      offset = lo;\n+\t    }\n+\t}\n+      else\n+\tbase = find_replacement (&XEXP (ref, 0));\n+    }\n   else\n-    base = XEXP (ref, 0);\n+    {\n+      if (GET_CODE (ref) != MEM)\n+\tabort ();\n+      base = XEXP (ref, 0);\n+    }\n \n   if (GET_CODE (base) == PLUS)\n     offset += INTVAL (XEXP (base, 1)), base = XEXP (base, 0);\n@@ -962,13 +1001,27 @@ get_unaligned_address (ref, extra_offset)\n       ref = SUBREG_REG (ref);\n     }\n \n-  if (GET_CODE (ref) == REG)\n-    ref = reg_equiv_mem[REGNO (ref)];\n-\n   if (reload_in_progress)\n-    base = find_replacement (&XEXP (ref, 0));\n+    {\n+      if (GET_CODE (ref) == REG)\n+\t{\n+\t  if (reg_equiv_mem[REGNO (ref)])\n+            ref = reg_equiv_mem[REGNO (ref)];\n+\t  else\n+\t    {\n+\t      /* The stack slot is out of range.  We should have handled\n+\t\t this as an aligned access -- I wonder why we didn't? */\n+\t      abort ();\n+\t    }\n+\t}\n+      base = find_replacement (&XEXP (ref, 0));\n+    }\n   else\n-    base = XEXP (ref, 0);\n+    {\n+      if (GET_CODE (ref) != MEM)\n+\tabort ();\n+      base = XEXP (ref, 0);\n+    }\n \n   if (GET_CODE (base) == PLUS)\n     offset += INTVAL (XEXP (base, 1)), base = XEXP (base, 0);"}, {"sha": "7a2ce2fd032eea788bdfcb4f9ac55479b2598f1e", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 58, "deletions": 26, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96043e7e1c32c6d82aab98b95ec36b7628bd6a0e/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96043e7e1c32c6d82aab98b95ec36b7628bd6a0e/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=96043e7e1c32c6d82aab98b95ec36b7628bd6a0e", "patch": "@@ -547,7 +547,7 @@\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t (match_operand:DI 2 \"const_int_operand\" \"\")))]\n   \"! add_operand (operands[2], DImode)\n-   && REGNO (operands[0]) != STACK_POINTER_REGNUM\"\n+   && operands[0] != stack_pointer_rtx\"\n   [(set (match_dup 0) (plus:DI (match_dup 1) (match_dup 3)))\n    (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 4)))]\n   \"\n@@ -4521,7 +4521,7 @@\n \t\t\t ? gen_rtx_REG (SImode, REGNO (operands[0]))\n \t\t\t : gen_reg_rtx (SImode));\n \n-\t  get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n+\t  get_aligned_mem (operands[1], scratch, &aligned_mem, &bitnum);\n \n \t  emit_insn (gen_aligned_loadqi (operands[0], aligned_mem, bitnum,\n \t\t\t\t\t scratch));\n@@ -4561,7 +4561,7 @@\n \t  rtx temp1 = gen_reg_rtx (SImode);\n \t  rtx temp2 = gen_reg_rtx (SImode);\n \n-\t  get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n+\t  get_aligned_mem (operands[0], NULL_RTX, &aligned_mem, &bitnum);\n \n \t  emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n \t\t\t\t\ttemp1, temp2));\n@@ -4632,7 +4632,7 @@\n \t\t\t ? gen_rtx_REG (SImode, REGNO (operands[0]))\n \t\t\t : gen_reg_rtx (SImode));\n \n-\t  get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n+\t  get_aligned_mem (operands[1], scratch, &aligned_mem, &bitnum);\n \n \t  emit_insn (gen_aligned_loadhi (operands[0], aligned_mem, bitnum,\n \t\t\t\t\t scratch));\n@@ -4672,7 +4672,7 @@\n \t  rtx temp1 = gen_reg_rtx (SImode);\n \t  rtx temp2 = gen_reg_rtx (SImode);\n \n-\t  get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n+\t  get_aligned_mem (operands[0], NULL_RTX, &aligned_mem, &bitnum);\n \n \t  emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n \t\t\t\t\ttemp1, temp2));\n@@ -4706,42 +4706,74 @@\n   \"! TARGET_BWX\"\n   \"\n {\n-  rtx addr = get_unaligned_address (operands[1], 0);\n+  rtx scratch, seq;\n \n-  /* It is possible that one of the registers we got for operands[2]\n-     might coincide with that of operands[0] (which is why we made\n-     it TImode).  Pick the other one to use as our scratch.  */\n-  rtx scratch = gen_rtx_REG (DImode,\n-\t\t\t     REGNO (operands[0]) == REGNO (operands[2]) \n-\t\t\t     ? REGNO (operands[2]) + 1 : REGNO (operands[2]));\n+  if (aligned_memory_operand (operands[1], QImode))\n+    {\n+      rtx aligned_mem, bitnum;\n \n-  rtx seq = gen_unaligned_loadqi (operands[0], addr, scratch,\n-\t\t\t\t  gen_rtx_REG (DImode, REGNO (operands[0])));\n+      get_aligned_mem (operands[1],\n+\t\t       gen_rtx_REG (DImode, REGNO (operands[2]) + 1),\n+\t\t       &aligned_mem, &bitnum);\n+      seq = gen_aligned_loadqi (operands[0], aligned_mem, bitnum,\n+\t\t\t\tgen_rtx_REG (SImode, REGNO (operands[2])));\n+    }\n+  else\n+    {\n+      rtx addr;\n+\n+      /* It is possible that one of the registers we got for operands[2]\n+         might coincide with that of operands[0] (which is why we made\n+         it TImode).  Pick the other one to use as our scratch.  */\n+      if (REGNO (operands[0]) == REGNO (operands[2]))\n+\tscratch = gen_rtx_REG (DImode, REGNO (operands[2]) + 1);\n+      else\n+\tscratch = gen_rtx_REG (DImode, REGNO (operands[2]));\n \n+      addr = get_unaligned_address (operands[1], 0);\n+      seq = gen_unaligned_loadqi (operands[0], addr, scratch,\n+\t\t\t\t  gen_rtx_REG (DImode, REGNO (operands[0])));\n+    }\n   alpha_set_memflags (seq, operands[1]);\n   emit_insn (seq);\n   DONE;\n }\")\n \n (define_expand \"reload_inhi\"\n   [(parallel [(match_operand:HI 0 \"register_operand\" \"=r\")\n-\t      (match_operand:HI 1 \"unaligned_memory_operand\" \"m\")\n+\t      (match_operand:HI 1 \"any_memory_operand\" \"m\")\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n   \"! TARGET_BWX\"\n   \"\n {\n-  rtx addr = get_unaligned_address (operands[1], 0);\n+  rtx scratch, seq;\n \n-  /* It is possible that one of the registers we got for operands[2]\n-     might coincide with that of operands[0] (which is why we made\n-     it TImode).  Pick the other one to use as our scratch.  */\n-  rtx scratch = gen_rtx_REG (DImode,\n-\t\t\t     REGNO (operands[0]) == REGNO (operands[2]) \n-\t\t\t     ? REGNO (operands[2]) + 1 : REGNO (operands[2]));\n+  if (aligned_memory_operand (operands[1], HImode))\n+    {\n+      rtx aligned_mem, bitnum;\n \n-  rtx seq = gen_unaligned_loadhi (operands[0], addr, scratch,\n-\t\t\t\t  gen_rtx_REG (DImode, REGNO (operands[0])));\n+      get_aligned_mem (operands[1],\n+\t\t       gen_rtx_REG (DImode, REGNO (operands[2]) + 1),\n+\t\t       &aligned_mem, &bitnum);\n+      seq = gen_aligned_loadhi (operands[0], aligned_mem, bitnum,\n+\t\t\t\tgen_rtx_REG (SImode, REGNO (operands[2])));\n+    }\n+  else\n+    {\n+      rtx addr;\n+\n+      /* It is possible that one of the registers we got for operands[2]\n+         might coincide with that of operands[0] (which is why we made\n+         it TImode).  Pick the other one to use as our scratch.  */\n+      if (REGNO (operands[0]) == REGNO (operands[2]))\n+\tscratch = gen_rtx_REG (DImode, REGNO (operands[2]) + 1);\n+      else\n+\tscratch = gen_rtx_REG (DImode, REGNO (operands[2]));\n \n+      addr = get_unaligned_address (operands[1], 0);\n+      seq = gen_unaligned_loadhi (operands[0], addr, scratch,\n+\t\t\t\t  gen_rtx_REG (DImode, REGNO (operands[0])));\n+    }\n   alpha_set_memflags (seq, operands[1]);\n   emit_insn (seq);\n   DONE;\n@@ -4758,7 +4790,7 @@\n     {\n       rtx aligned_mem, bitnum;\n \n-      get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n+      get_aligned_mem (operands[0], NULL_RTX, &aligned_mem, &bitnum);\n \n       emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n \t\t\t\t    gen_rtx_REG (SImode, REGNO (operands[2])),\n@@ -4796,7 +4828,7 @@\n     {\n       rtx aligned_mem, bitnum;\n \n-      get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n+      get_aligned_mem (operands[0], NULL_RTX, &aligned_mem, &bitnum);\n \n       emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n \t\t\t\t    gen_rtx_REG (SImode, REGNO (operands[2])),"}]}