{"sha": "692fb023ef14a4690ee766c0596306353175aeec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkyZmIwMjNlZjE0YTQ2OTBlZTc2NmMwNTk2MzA2MzUzMTc1YWVlYw==", "commit": {"author": {"name": "Guilhem Lavaux", "email": "guilhem@kaffe.org", "date": "2003-12-23T22:06:01Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-12-23T22:06:01Z"}, "message": "2003-12-23  Guilhem Lavaux <guilhem@kaffe.org>\n\n\t* java/io/ObjectInputStream.java\n\t(getField): Handle transient and non persistent fields.\n\t(readClassDescriptor): Better error handling, use the right\n\tclass loader.\n\t(readFields): Fields marked as not present in the stream\n\tor not to be set are not read and set.\n\t* java/io/ObjectInputStream.java\n\t(readFields): Changed implementation of GetField.\n\t(readClassDescriptor): Documented.\n\t* java/io/ObjectOutputStream.java\n\t(writeClassDescriptor): Added condition when to write class super\n\tclass information.\n\nFrom-SVN: r74985", "tree": {"sha": "cf9911a00c5d1b39db4f88ffc6c7f626cad43bf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf9911a00c5d1b39db4f88ffc6c7f626cad43bf9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/692fb023ef14a4690ee766c0596306353175aeec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/692fb023ef14a4690ee766c0596306353175aeec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/692fb023ef14a4690ee766c0596306353175aeec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/692fb023ef14a4690ee766c0596306353175aeec/comments", "author": null, "committer": null, "parents": [{"sha": "f2073745a81b0687b24f40c1549769be5917987f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2073745a81b0687b24f40c1549769be5917987f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2073745a81b0687b24f40c1549769be5917987f"}], "stats": {"total": 404, "additions": 359, "deletions": 45}, "files": [{"sha": "4c81138ee3c77e00278088e415fa8f96e6b1318f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692fb023ef14a4690ee766c0596306353175aeec/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692fb023ef14a4690ee766c0596306353175aeec/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=692fb023ef14a4690ee766c0596306353175aeec", "patch": "@@ -1,3 +1,18 @@\n+2003-12-23  Guilhem Lavaux <guilhem@kaffe.org>\n+\n+\t* java/io/ObjectInputStream.java\n+\t(getField): Handle transient and non persistent fields.\n+\t(readClassDescriptor): Better error handling, use the right\n+\tclass loader.\n+\t(readFields): Fields marked as not present in the stream\n+\tor not to be set are not read and set.\n+\t* java/io/ObjectInputStream.java\n+\t(readFields): Changed implementation of GetField.\n+\t(readClassDescriptor): Documented.\n+\t* java/io/ObjectOutputStream.java\n+\t(writeClassDescriptor): Added condition when to write class super\n+\tclass information.\n+\n 2003-12-22  Fernando Nasser  <fnasser@redhat.com>\n \n \t* gnu/java/awt/peer/gtk/GtkChoicePeer.java (postItemEvent): Rename to..."}, {"sha": "de1393933356c507f56c4e06aef9324791df7e9a", "filename": "libjava/java/io/ObjectInputStream.java", "status": "modified", "additions": 308, "deletions": 38, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692fb023ef14a4690ee766c0596306353175aeec/libjava%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692fb023ef14a4690ee766c0596306353175aeec/libjava%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputStream.java?ref=692fb023ef14a4690ee766c0596306353175aeec", "patch": "@@ -101,6 +101,7 @@ else if (dump == true && (val == null || val.equals(\"\")))\n     this.nextOID = baseWireHandle;\n     this.objectLookupTable = new Hashtable ();\n     this.validators = new Vector ();\n+    this.classLookupTable = new Hashtable();\n     setBlockDataMode (true);\n     readStreamHeader ();\n   }\n@@ -417,6 +418,22 @@ public final Object readObject () throws ClassNotFoundException, IOException\n     return ret_val;\n   }\n \n+  /**\n+   * This method reads a class descriptor from the real input stream\n+   * and use these data to create a new instance of ObjectStreamClass.\n+   * Fields are sorted and ordered for the real read which occurs for\n+   * each instance of the described class. Be aware that if you call that\n+   * method you must ensure that the stream is synchronized, in the other\n+   * case it may be completely desynchronized.\n+   *\n+   * @return A new instance of ObjectStreamClass containing the freshly\n+   * created descriptor.\n+   * @throws ClassNotFoundException if the required class to build the\n+   * descriptor has not been found in the system.\n+   * @throws IOException An input/output error occured.\n+   * @throws InvalidClassException If there was a compatibility problem\n+   * between the class present in the system and the serialized class.\n+   */\n   protected ObjectStreamClass readClassDescriptor ()\n     throws ClassNotFoundException, IOException\n   {\n@@ -443,19 +460,41 @@ protected ObjectStreamClass readClassDescriptor ()\n \tdumpElementln (field_name);\n \tString class_name;\n \t\t  \n+\t// If the type code is an array or an object we must\n+\t// decode a String here. In the other case we convert\n+\t// the type code and pass it to ObjectStreamField.\n+\t// Type codes are decoded by gnu.java.lang.reflect.TypeSignature.\n \tif (type_code == 'L' || type_code == '[')\n \t  class_name = (String)readObject ();\n \telse\n \t  class_name = String.valueOf (type_code);\n \t\t  \n-\t// There're many cases you can't get java.lang.Class from\n-\t// typename if your context class loader can't load it,\n-\t// then use typename to construct the field\n \tfields[i] =\n-\t  new ObjectStreamField (field_name, class_name);\n+\t  new ObjectStreamField(field_name, class_name, currentLoader());\n       }\n \t      \n+    /* Now that fields have been read we may resolve the class\n+     * (and read annotation if needed). */\n     Class clazz = resolveClass(osc);\n+    \n+    for (int i = 0; i < field_count; i++)\n+      {\n+\tField f;\n+\t\n+\ttry\n+\t  {\n+\t    f = clazz.getDeclaredField(fields[i].getName());\n+\t    if (f != null && !f.getType().equals(fields[i].getType()))\n+\t      throw new InvalidClassException\n+\t\t(\"invalid field type for \" + fields[i].getName() + \" in class \"\n+\t\t + name + \" (requested was \\\"\" + fields[i].getType()\n+\t\t + \" and found \\\"\" + f.getType() + \"\\\")\"); \n+\t  }\n+\tcatch (NoSuchFieldException _)\n+\t  {\n+\t  }\n+      }\n+\n     boolean oldmode = setBlockDataMode (true);\n     osc.setClass (clazz, lookupClass(clazz.getSuperclass()));\n     classLookupTable.put(clazz, osc);\n@@ -487,10 +526,13 @@ public void defaultReadObject ()\n     throws ClassNotFoundException, IOException, NotActiveException\n   {\n     if (this.currentObject == null || this.currentObjectStreamClass == null)\n-      throw new NotActiveException (\"defaultReadObject called by non-active class and/or object\");\n+      throw new NotActiveException(\"defaultReadObject called by non-active\"\n+\t\t\t\t   + \" class and/or object\");\n \n     if (fieldsAlreadyRead)\n-      throw new NotActiveException (\"defaultReadObject called but fields already read from stream (by defaultReadObject or readFields)\");\n+      throw new NotActiveException(\"defaultReadObject called but fields \"\n+\t\t\t\t   + \"already read from stream (by \"\n+\t\t\t\t   + \"defaultReadObject or readFields)\");\n \n     boolean oldmode = setBlockDataMode(false);\n     readFields (this.currentObject, this.currentObjectStreamClass);\n@@ -523,10 +565,12 @@ public void registerValidation (ObjectInputValidation validator,\n     throws InvalidObjectException, NotActiveException\n   {\n     if (this.currentObject == null || this.currentObjectStreamClass == null)\n-      throw new NotActiveException (\"registerValidation called by non-active class and/or object\");\n+      throw new NotActiveException (\"registerValidation called by non-active \"\n+\t\t\t\t    +\"class and/or object\");\n \n     if (validator == null)\n-      throw new InvalidObjectException (\"attempt to add a null ObjectInputValidation object\");\n+      throw new InvalidObjectException (\"attempt to add a null \"\n+\t\t\t\t\t+\"ObjectInputValidation object\");\n \n     this.validators.addElement (new ValidatorAndPriority (validator,\n \t\t\t\t\t\t\t  priority));\n@@ -555,6 +599,14 @@ protected Class resolveClass (ObjectStreamClass osc)\n     return Class.forName(osc.getName(), true, currentLoader());\n   }\n \n+  /**\n+   * This method invokes the method currentClassLoader for the\n+   * current security manager (or build an empty one if it is not\n+   * present).\n+   *\n+   * @return The most recent non-system ClassLoader on the execution stack.\n+   * @see java.lang.SecurityManager#currentClassLoader()\n+   */\n   private ClassLoader currentLoader()\n   {\n     SecurityManager sm = System.getSecurityManager ();\n@@ -590,8 +642,8 @@ private ObjectStreamClass lookupClass (Class clazz)\n    * Reconstruct class hierarchy the same way\n    * {@link java.io.ObjectStreamClass.getObjectStreamClasses(java.lang.Class)} does\n    * but using lookupClass instead of ObjectStreamClass.lookup. This\n-   * dup is necessary localize the lookup table. Hopefully some future rewritings will\n-   * be able to prevent this.\n+   * dup is necessary localize the lookup table. Hopefully some future\n+   * rewritings will be able to prevent this.\n    *\n    * @param clazz This is the class for which we want the hierarchy.\n    *\n@@ -774,52 +826,142 @@ public void close () throws IOException\n \n   public boolean readBoolean () throws IOException\n   {\n-    return this.dataInputStream.readBoolean ();\n+    boolean switchmode = true;\n+    boolean oldmode = this.readDataFromBlock;\n+    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 1)\n+      switchmode = false;\n+    if (switchmode)\n+      oldmode = setBlockDataMode (true);\n+    boolean value = this.dataInputStream.readBoolean ();\n+    if (switchmode)\n+      setBlockDataMode (oldmode);\n+    return value;\n   }\n \n   public byte readByte () throws IOException\n   {\n-    return this.dataInputStream.readByte ();\n+    boolean switchmode = true;\n+    boolean oldmode = this.readDataFromBlock;\n+    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 1)\n+      switchmode = false;\n+    if (switchmode)\n+      oldmode = setBlockDataMode (true);\n+    byte value = this.dataInputStream.readByte ();\n+    if (switchmode)\n+      setBlockDataMode (oldmode);\n+    return value;\n   }\n \n   public int readUnsignedByte () throws IOException\n   {\n-    return this.dataInputStream.readUnsignedByte ();\n+    boolean switchmode = true;\n+    boolean oldmode = this.readDataFromBlock;\n+    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 1)\n+      switchmode = false;\n+    if (switchmode)\n+      oldmode = setBlockDataMode (true);\n+    int value = this.dataInputStream.readUnsignedByte ();\n+    if (switchmode)\n+      setBlockDataMode (oldmode);\n+    return value;\n   }\n \n   public short readShort () throws IOException\n   {\n-    return this.dataInputStream.readShort ();\n+    boolean switchmode = true;\n+    boolean oldmode = this.readDataFromBlock;\n+    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 2)\n+      switchmode = false;\n+    if (switchmode)\n+      oldmode = setBlockDataMode (true);\n+    short value = this.dataInputStream.readShort ();\n+    if (switchmode)\n+      setBlockDataMode (oldmode);\n+    return value;\n   }\n \n   public int readUnsignedShort () throws IOException\n   {\n-    return this.dataInputStream.readUnsignedShort ();\n+    boolean switchmode = true;\n+    boolean oldmode = this.readDataFromBlock;\n+    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 2)\n+      switchmode = false;\n+    if (switchmode)\n+      oldmode = setBlockDataMode (true);\n+    int value = this.dataInputStream.readUnsignedShort ();\n+    if (switchmode)\n+      setBlockDataMode (oldmode);\n+    return value;\n   }\n \n   public char readChar () throws IOException\n   {\n-    return this.dataInputStream.readChar ();\n+    boolean switchmode = true;\n+    boolean oldmode = this.readDataFromBlock;\n+    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 2)\n+      switchmode = false;\n+    if (switchmode)\n+      oldmode = setBlockDataMode (true);\n+    char value = this.dataInputStream.readChar ();\n+    if (switchmode)\n+      setBlockDataMode (oldmode);\n+    return value;\n   }\n \n   public int readInt () throws IOException\n   {\n-    return this.dataInputStream.readInt ();\n+    boolean switchmode = true;\n+    boolean oldmode = this.readDataFromBlock;\n+    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 4)\n+      switchmode = false;\n+    if (switchmode)\n+      oldmode = setBlockDataMode (true);\n+    int value = this.dataInputStream.readInt ();\n+    if (switchmode)\n+      setBlockDataMode (oldmode);\n+    return value;\n   }\n \n   public long readLong () throws IOException\n   {\n-    return this.dataInputStream.readLong ();\n+    boolean switchmode = true;\n+    boolean oldmode = this.readDataFromBlock;\n+    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 8)\n+      switchmode = false;\n+    if (switchmode)\n+      oldmode = setBlockDataMode (true);\n+    long value = this.dataInputStream.readLong ();\n+    if (switchmode)\n+      setBlockDataMode (oldmode);\n+    return value;\n   }\n \n   public float readFloat () throws IOException\n   {\n-    return this.dataInputStream.readFloat ();\n+    boolean switchmode = true;\n+    boolean oldmode = this.readDataFromBlock;\n+    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 4)\n+      switchmode = false;\n+    if (switchmode)\n+      oldmode = setBlockDataMode (true);\n+    float value = this.dataInputStream.readFloat ();\n+    if (switchmode)\n+      setBlockDataMode (oldmode);\n+    return value;\n   }\n \n   public double readDouble () throws IOException\n   {\n-    return this.dataInputStream.readDouble ();\n+    boolean switchmode = true;\n+    boolean oldmode = this.readDataFromBlock;\n+    if (!oldmode || this.blockDataBytes - this.blockDataPosition >= 8)\n+      switchmode = false;\n+    if (switchmode)\n+      oldmode = setBlockDataMode (true);\n+    double value = this.dataInputStream.readDouble ();\n+    if (switchmode)\n+      setBlockDataMode (oldmode);\n+    return value;\n   }\n \n   public void readFully (byte data[]) throws IOException\n@@ -893,14 +1035,31 @@ public abstract Object get (String name, Object defvalue)\n       throws IOException, IllegalArgumentException;\n   }\n \n+  /**\n+   * This method should be called by a method called 'readObject' in the\n+   * deserializing class (if present). It cannot (and should not)be called\n+   * outside of it. Its goal is to read all fields in the real input stream\n+   * and keep them accessible through the {@link #GetField} class. Calling\n+   * this method will not alterate the deserializing object.\n+   *\n+   * @return A valid freshly created 'GetField' instance to get access to\n+   * the deserialized stream.\n+   * @throws IOException An input/output exception occured. \n+   * @throws ClassNotFoundException \n+   * @throws NotActiveException\n+   */\n   public GetField readFields ()\n     throws IOException, ClassNotFoundException, NotActiveException\n   {\n     if (this.currentObject == null || this.currentObjectStreamClass == null)\n       throw new NotActiveException (\"readFields called by non-active class and/or object\");\n \n+    if (prereadFields != null)\n+      return prereadFields;\n+\n     if (fieldsAlreadyRead)\n-      throw new NotActiveException (\"readFields called but fields already read from stream (by defaultReadObject or readFields)\");\n+      throw new NotActiveException (\"readFields called but fields already read from\"\n+\t\t\t\t    + \" stream (by defaultReadObject or readFields)\");\n \n     final ObjectStreamClass clazz = this.currentObjectStreamClass;\n     final byte[] prim_field_data = new byte[clazz.primFieldSize];\n@@ -915,7 +1074,7 @@ public GetField readFields ()\n       objs[i] = readObject ();\n     setBlockDataMode (oldmode);\n \n-    return new GetField ()\n+    prereadFields = new GetField()\n       {\n \tpublic ObjectStreamClass getObjectStreamClass ()\n \t{\n@@ -925,7 +1084,31 @@ public ObjectStreamClass getObjectStreamClass ()\n \tpublic boolean defaulted (String name)\n \t  throws IOException, IllegalArgumentException\n \t{\n-\t  return clazz.getField (name) == null;\n+\t  ObjectStreamField f = clazz.getField(name);\n+\t  \n+\t  /* First if we have a serialized field use the descriptor */\n+\t  if (f != null)\n+\t    {\n+\t      /* It is in serialPersistentFields but setClass tells us\n+\t       * it should not be set. This value is defaulted.\n+\t       */\n+\t      if (f.isPersistent() && !f.isToSet())\n+\t\treturn true;\n+\t      \n+\t      return false;\n+\t    }\n+\n+\t  /* This is not a serialized field. There should be\n+\t   * a default value only if the field really exists.\n+\t   */\n+\t  try\n+\t    {\n+\t      return (clazz.forClass().getDeclaredField (name) != null);\n+\t    }\n+\t  catch (NoSuchFieldException e)\n+\t    {\n+\t      throw new IllegalArgumentException (e.getMessage());\n+\t    }\n \t}\n \n \tpublic boolean get (String name, boolean defvalue)\n@@ -1067,24 +1250,76 @@ private ObjectStreamField getField (String name, Class type)\n \t  throws IllegalArgumentException\n \t{\n \t  ObjectStreamField field = clazz.getField (name);\n+\t  boolean illegal = false;\n \n-\t  if (field == null)\n-\t    return null;\n-\n-\t  Class field_type = field.getType ();\n-\n-\t  if (type == field_type ||\n-\t      (type == null && ! field_type.isPrimitive ()))\n-\t    return field;\n-\n-\t  throw new IllegalArgumentException (\"Field requested is of type \"\n-\t\t\t\t\t      + field_type.getName ()\n-\t\t\t\t\t      + \", but requested type was \"\n-\t\t\t\t\t      + (type == null ?\n-\t\t\t\t\t\t \"Object\" : type.getName ()));\n+\t  try\n+\t    {\n+\t      try\n+\t\t{\n+\t\t  Class field_type = field.getType();\n+\t\t  \n+\t\t  if (type == field_type ||\n+\t\t      (type == null && !field_type.isPrimitive()))\n+\t\t    {\n+\t\t      /* See defaulted */\n+\t\t      return field;\n+\t\t    }\n+\t \n+\t\t  illegal = true;\n+\t\t  throw new IllegalArgumentException\n+\t\t    (\"Field requested is of type \"\n+\t\t     + field_type.getName()\n+\t\t     + \", but requested type was \"\n+\t\t     + (type == null ?  \"Object\" : type.getName()));\n+\t\t}\n+\t      catch (NullPointerException _)\n+\t\t{\n+\t\t  /* Here we catch NullPointerException, because it may\n+\t\t     only come from the call 'field.getType()'. If field\n+\t\t     is null, we have to return null and classpath ethic\n+\t\t     say we must try to avoid 'if (xxx == null)'.\n+\t\t  */\n+\t\t}\n+\t      catch (IllegalArgumentException e)\n+\t\t{\n+\t\t  throw e;\n+\t\t}\n+\t      \n+\t      return null;\n+\t    }\n+\t  finally\n+\t    {\n+\t      /* If this is an unassigned field we should return\n+\t       * the default value.\n+\t       */\n+\t      if (!illegal && field != null && !field.isToSet() && field.isPersistent())\n+\t\treturn null;\n+\n+\t      /* We do not want to modify transient fields. They should\n+\t       * be left to 0.\n+\t       */\n+\t      try\n+\t\t{\n+\t\t  Field f = clazz.forClass().getDeclaredField (name);\n+\t\t  if (Modifier.isTransient(f.getModifiers()))\n+\t\t    throw new IllegalArgumentException\n+\t\t      (\"no such field (non transient) \" + name);\n+\t\t  if (field == null && f.getType() != type)\n+\t\t    throw new IllegalArgumentException\n+\t\t      (\"Invalid requested type for field \" + name);\n+\t\t}\n+\t      catch (NoSuchFieldException e)\n+\t\t{\n+\t\t  if (field == null)\n+\t\t    throw new IllegalArgumentException(e.getMessage());\n+\t\t}\n+\t       \n+\t    }\n \t}\n       };\n \n+    fieldsAlreadyRead = true;\n+    return prereadFields;\n   }\n \n   /**\n@@ -1334,6 +1569,15 @@ else if (comp_val > 0)\n \t      }\n \t  }\n \n+\tif (stream_field.getOffset() < 0)\n+\t  {\n+\t    default_initialize = true;\n+\t    set_value = false;\n+\t  }\n+\t\n+\tif (!stream_field.isToSet()) \n+\t  set_value = false;\n+\n \ttry\n \t  {\n \t    if (type == Boolean.TYPE)\n@@ -1485,10 +1729,24 @@ private static ClassLoader currentClassLoader (SecurityManager sm)\n     return ClassLoader.getSystemClassLoader ();\n   }\n \n-  private static Field getField (Class klass, String name)\n+  /**\n+   * This method tries to access a precise field called in the\n+   * specified class. Before accessing the field, it tries to\n+   * gain control on this field. If the field is either declared as \n+   * not persistent or transient then it returns null\n+   * immediately.\n+   *\n+   * @param klass Class to get the field from.\n+   * @param name Name of the field to access.\n+   * @return Field instance representing the requested field.\n+   * @throws NoSuchFieldException if the field does not exist.\n+   */\n+  private Field getField(Class klass, String name)\n     throws java.lang.NoSuchFieldException\n   {\n     final Field f = klass.getDeclaredField(name);\n+    ObjectStreamField sf = lookupClass(klass).getField(name);\n+    \n     AccessController.doPrivileged(new PrivilegedAction()\n       {\n \tpublic Object run()\n@@ -1497,6 +1755,14 @@ public Object run()\n \t  return null;\n \t}\n       });\n+\n+    /* We do not want to modify transient fields. They should\n+     * be left to 0.\n+     * N.B.: Not valid if the field is in serialPersistentFields. \n+     */\n+    if (Modifier.isTransient(f.getModifiers()) && !sf.isPersistent())\n+      return null;\n+   \n     return f;\n   }\n \n@@ -1546,6 +1812,9 @@ private void callReadMethod (Object obj, ObjectStreamClass osc) throws IOExcepti\n \tthrow new IOException (\"Failure invoking readObject() on \" +\n \t\t\t       klass + \": \" + x.getClass().getName());\n       }\n+\n+    // Invalidate fields which has been read through readFields.\n+    prereadFields = null;\n   }\n     \n   private native Object allocateObject (Class clazz)\n@@ -1829,6 +2098,7 @@ private void setObjectField (Object obj, Class klass, String field_name,\n   private boolean fieldsAlreadyRead;\n   private Vector validators;\n   private Hashtable classLookupTable;\n+  private GetField prereadFields;\n \n   private static boolean dump;\n "}, {"sha": "0244e2d2c915c0e48458717a5b7728e7fd6e40bf", "filename": "libjava/java/io/ObjectOutputStream.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692fb023ef14a4690ee766c0596306353175aeec/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692fb023ef14a4690ee766c0596306353175aeec/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectOutputStream.java?ref=692fb023ef14a4690ee766c0596306353175aeec", "patch": "@@ -407,7 +407,8 @@ protected void writeClassDescriptor (ObjectStreamClass osc) throws IOException\n     setBlockDataMode (oldmode);\n     realOutput.writeByte (TC_ENDBLOCKDATA);\n \n-    if (osc.isSerializable ())\n+    if (osc.isSerializable()\n+\t|| osc.isExternalizable())\n       writeObject (osc.getSuper ());\n     else\n       writeObject (null);"}, {"sha": "9d9d99d33d1e12bf44c64f2243e0ddd3133c4b0e", "filename": "libjava/java/io/ObjectStreamClass.java", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692fb023ef14a4690ee766c0596306353175aeec/libjava%2Fjava%2Fio%2FObjectStreamClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692fb023ef14a4690ee766c0596306353175aeec/libjava%2Fjava%2Fio%2FObjectStreamClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectStreamClass.java?ref=692fb023ef14a4690ee766c0596306353175aeec", "patch": "@@ -516,9 +516,12 @@ private void setFields (Class cl)\n \t  && Modifier.isPrivate (modifiers))\n       {\n \tfields = getSerialPersistentFields (cl);\n-\tArrays.sort (fields);\n-\tcalculateOffsets ();\n-\treturn;\n+\tif (fields != null)\n+\t  {\n+\t    Arrays.sort(fields);\n+\t    calculateOffsets();\n+\t    return;\n+\t  }\n       }\n     }\n     catch (NoSuchFieldException ignore)\n@@ -700,16 +703,41 @@ private long getClassUID (Class cl)\n     }\n   }\n \n-  // Returns the value of CLAZZ's private static final field named\n-  // `serialPersistentFields'.\n+  /**\n+   * Returns the value of CLAZZ's private static final field named\n+   * `serialPersistentFields'. It performs some sanity checks before\n+   * returning the real array. Besides, the returned array is a clean\n+   * copy of the original. So it can be modified.\n+   *\n+   * @param clazz Class to retrieve 'serialPersistentFields' from.\n+   * @return The content of 'serialPersistentFields'.\n+   */\n   private ObjectStreamField[] getSerialPersistentFields (Class clazz)\n     throws NoSuchFieldException, IllegalAccessException\n   {\n+    ObjectStreamField[] fieldsArray = null;\n+    ObjectStreamField[] o;\n+\n     // Use getDeclaredField rather than getField for the same reason\n     // as above in getDefinedSUID.\n     Field f = clazz.getDeclaredField(\"serialPersistentFields\");\n     f.setAccessible(true);\n-    return (ObjectStreamField[]) f.get(null);\n+\n+    int modifiers = f.getModifiers();\n+    if (!(Modifier.isStatic(modifiers)\n+\t&& Modifier.isFinal(modifiers)\n+\t&& Modifier.isPrivate(modifiers)))\n+      return null;\n+    \n+    o = (ObjectStreamField[]) f.get(null);\n+    \n+    if (o == null)\n+      return null;\n+\n+    fieldsArray = new ObjectStreamField[o.length];\n+    System.arraycopy(o, 0, fieldsArray, 0, o.length);\n+    \n+    return fieldsArray;\n   }\n \n   public static final ObjectStreamField[] NO_FIELDS = {};"}]}