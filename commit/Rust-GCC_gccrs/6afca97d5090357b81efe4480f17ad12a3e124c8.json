{"sha": "6afca97d5090357b81efe4480f17ad12a3e124c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFmY2E5N2Q1MDkwMzU3YjgxZWZlNDQ4MGYxN2FkMTJhM2UxMjRjOA==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-02-22T02:47:54Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-02-22T02:47:54Z"}, "message": "sparc.h (enum processor_type): Declare.\n\n\t* sparc/sparc.h (enum processor_type): Declare.\n\t(sparc_cpu_attr): Define.\n\t(TARGET_OPTIONS): Add -mtune=.\n\t(sparc_select): Declare.\n\t(sparc_cpu_string): Delete.\n\t(FIRST_PSEUDO_REGISTER): Set to 100.\n\t({FIXED,CALL_USED}_REGISTERS): Merge !v9/v9 cases.\n\t(CONDITIONAL_REGISTER_USAGE): Mark %g5 as fixed if !v9.\n\tMark %g1 as fixed if v9.  Fix v9-only regs if !v9.\n\tMark fp{16..47} as call-saved if v9.\n\t(enum reg_class): Merge !v9/v9 cases.\n\t(REG_CLASS_NAMES,REG_CLASS_CONTENTS,REGNO_REG_CLASS): Likewise.\n\t(REG_ALLOC_ORDER,REG_LEAF_ALLOC_ORDER,LEAF_REGISTERS): Likewise.\n\t(FP_REG_CLASS_P,SPARC_REGISTER_NAMES): Likewise.\n\t(REG_CLASS_FROM_LETTER): Test TARGET_V9 at runtime.\n\nFrom-SVN: r11337", "tree": {"sha": "6a5a75fe9e69912561b5a41dfe3f7106971c9d6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a5a75fe9e69912561b5a41dfe3f7106971c9d6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6afca97d5090357b81efe4480f17ad12a3e124c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6afca97d5090357b81efe4480f17ad12a3e124c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6afca97d5090357b81efe4480f17ad12a3e124c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6afca97d5090357b81efe4480f17ad12a3e124c8/comments", "author": null, "committer": null, "parents": [{"sha": "1cfb500fa410af550a3a09fc97c58f90df3b8522", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cfb500fa410af550a3a09fc97c58f90df3b8522", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cfb500fa410af550a3a09fc97c58f90df3b8522"}], "stats": {"total": 242, "additions": 87, "deletions": 155}, "files": [{"sha": "0b54f2464363e7861a09d729dbdf1ab24769e8f5", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 87, "deletions": 155, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6afca97d5090357b81efe4480f17ad12a3e124c8/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6afca97d5090357b81efe4480f17ad12a3e124c8/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=6afca97d5090357b81efe4480f17ad12a3e124c8", "patch": "@@ -42,10 +42,7 @@ Boston, MA 02111-1307, USA.  */\n    SPARC_{V9,ARCH64} to a minimum.  No attempt is made to support both v8\n    and v9 in the v9 compiler.\n \n-   If a combination v8/v9 compiler is too slow, it should always be possible\n-   to #define TARGET_{V9,ARCH64} as 0 (and potentially other v9-only\n-   options), and #define SPARC_{V9,ARCH64} as 0.\n-   I measured the difference once and it was around 10%.  /dje 960120\n+   ??? All uses of SPARC_V9 have been removed.  Try not to add new ones.\n */\n \n #ifndef SPARC_V9\n@@ -440,7 +437,29 @@ extern int target_flags;\n #define ARCH64_SWITCHES\n #endif\n \n-extern enum attr_cpu sparc_cpu;\n+/* Processor type.\n+   These must match the values for the cpu attribute in sparc.md.  */\n+enum processor_type {\n+  PROCESSOR_V7,\n+  PROCESSOR_CYPRESS,\n+  PROCESSOR_V8,\n+  PROCESSOR_SUPERSPARC,\n+  PROCESSOR_SPARCLITE,\n+  PROCESSOR_F930,\n+  PROCESSOR_F934,\n+  PROCESSOR_SPARCLET,\n+  PROCESSOR_90C701,\n+  PROCESSOR_V8PLUS,\n+  PROCESSOR_V9,\n+  PROCESSOR_ULTRASPARC\n+};\n+\n+/* This is set from -m{cpu,tune}=xxx.  */\n+extern enum processor_type sparc_cpu;\n+\n+/* Recast the cpu class to be the cpu attribute.\n+   Every file includes us, but not every file includes insn-attr.h.  */\n+#define sparc_cpu_attr ((enum attr_cpu) sparc_cpu)\n \n /* This macro is similar to `TARGET_SWITCHES' but defines names of\n    command options that have values.  Its definition is an\n@@ -459,17 +478,26 @@ extern enum attr_cpu sparc_cpu;\n \textern char *m88k_short_data;\n \t#define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }  */\n \n-/* ??? This isn't as fancy as rs6000.h.  Maybe in time.  */\n-extern char *sparc_cpu_string;\n-\n #define TARGET_OPTIONS \\\n-{ \\\n-  { \"cpu=\", &sparc_cpu_string }, \\\n+{\t\t\t\t\t\\\n+  {\"cpu=\",  &sparc_select[1].string},\t\\\n+  {\"tune=\", &sparc_select[2].string},\t\\\n   SUBTARGET_OPTIONS \\\n }\n \n /* This is meant to be redefined in target specific files.  */\n #define SUBTARGET_OPTIONS\n+\n+/* sparc_select[0] is reserved for the default cpu.  */\n+struct sparc_cpu_select\n+{\n+  char *string;\n+  char *name;\n+  int set_tune_p;\n+  int set_arch_p;\n+};\n+\n+extern struct sparc_cpu_select sparc_select[];\n \f\n /* target machine storage layout */\n \n@@ -647,11 +675,11 @@ extern char *sparc_cpu_string;\n    32+32+32+4 == 100.\n    Register 0 is used as the integer condition code register.  */\n \n-#if SPARC_V9\n #define FIRST_PSEUDO_REGISTER 100\n-#else\n-#define FIRST_PSEUDO_REGISTER 64\n-#endif\n+\n+/* Additional V9 fp regs.  */\n+#define SPARC_FIRST_V9_FP_REG 64\n+#define SPARC_LAST_V9_FP_REG  99\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n@@ -670,11 +698,14 @@ extern char *sparc_cpu_string;\n    ??? Register 1 is used as a temporary by the 64 bit sethi pattern, so must\n    currently be a fixed register until this pattern is rewritten.\n    Register 1 is also used when restoring call-preserved registers in large\n-   stack frames.  */\n+   stack frames.\n+\n+   Registers fixed in arch32 and not arch64 (or vice-versa) are marked in\n+   CONDITIONAL_REGISTER_USAGE in order to properly handle -ffixed-.\n+*/\n \n-#if SPARC_V9\n #define FIXED_REGISTERS  \\\n- {0, 1, 0, 0, 0, 0, 1, 1,\t\\\n+ {0, 0, 0, 0, 0, 0, 1, 1,\t\\\n   0, 0, 0, 0, 0, 0, 1, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 1, 1,\t\\\n@@ -690,18 +721,6 @@ extern char *sparc_cpu_string;\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n \t\t\t\t\\\n   0, 0, 0, 0}\n-#else\n-#define FIXED_REGISTERS  \\\n- {0, 0, 0, 0, 0, 1, 1, 1,\t\\\n-  0, 0, 0, 0, 0, 0, 1, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 1, 1,\t\\\n-\t\t\t\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0}\n-#endif\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -710,26 +729,6 @@ extern char *sparc_cpu_string;\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.  */\n \n-#if SPARC_V9 && SPARC_ARCH64\n-#define CALL_USED_REGISTERS  \\\n- {1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 1, 1,\t\\\n-\t\t\t\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-\t\t\t\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-\t\t\t\t\\\n-  1, 1, 1, 1}\n-#else\n-#if SPARC_V9 && ! SPARC_ARCH64\n #define CALL_USED_REGISTERS  \\\n  {1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n@@ -747,30 +746,33 @@ extern char *sparc_cpu_string;\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n \t\t\t\t\\\n   1, 1, 1, 1}\n-#else\n-#define CALL_USED_REGISTERS  \\\n- {1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 1, 1,\t\\\n-\t\t\t\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1}\n-#endif\n-#endif\n \n /* If !TARGET_FPU, then make the fp registers fixed so that they won't\n    be allocated.  On v9, also make the fp cc regs fixed.  */\n \n #define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n-    if (SPARC_V9 && ! SPARC_ARCH64)\t\t\t\t\\\n+    if (! SPARC_ARCH64)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \tfixed_regs[5] = 1;\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n+    if (SPARC_ARCH64)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tint regno;\t\t\t\t\t\t\\\n+\tfixed_regs[1] = 1;\t\t\t\t\t\\\n+\t/* ??? We need to scan argv for -fcall-used-.  */\t\\\n+\tfor (regno = 48; regno < 80; regno++)\t\t\t\\\n+\t  call_used_regs[regno] = 0;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    if (! TARGET_V9)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tint regno;\t\t\t\t\t\t\\\n+\tfor (regno = SPARC_FIRST_V9_FP_REG;\t\t\t\\\n+\t     regno <= SPARC_LAST_V9_FP_REG;\t\t\t\\\n+\t     regno++)\t\t\t\t\t\t\\\n+\t  fixed_regs[regno] = 1;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n     if (! TARGET_FPU)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \tint regno;\t\t\t\t\t\t\\\n@@ -982,60 +984,38 @@ extern int sparc_mode_class[];\n    trying to compile _fixunsdfsi because fix_truncdfsi2 won't match its\n    constraints.  */\n \n-#if SPARC_V9\n enum reg_class { NO_REGS, FPCC_REGS, GENERAL_REGS, FP_REGS, EXTRA_FP_REGS,\n \t\t GENERAL_OR_FP_REGS, GENERAL_OR_EXTRA_FP_REGS,\n \t\t ALL_REGS, LIM_REG_CLASSES };\n-#else\n-enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n-#endif\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n /* Give names of register classes as strings for dump file.   */\n \n-#if SPARC_V9\n #define REG_CLASS_NAMES \\\n   { \"NO_REGS\", \"FPCC_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"EXTRA_FP_REGS\", \\\n     \"GENERAL_OR_FP_REGS\", \"GENERAL_OR_EXTRA_FP_REGS\", \"ALL_REGS\" }\n-#else\n-#define REG_CLASS_NAMES \\\n-  { \"NO_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"ALL_REGS\" }\n-#endif\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n-#if SPARC_V9\n #define REG_CLASS_CONTENTS \\\n   {{0, 0, 0, 0}, {0, 0, 0, 0xf}, {-2, 0, 0, 0}, \\\n    {0, -1, 0, 0}, {0, -1, -1, 0}, {-2, -1, 0, 0}, {-2, -1, -1, 0}, \\\n    {-2, -1, -1, 0xf}}\n-#else\n-#if 0 && defined (__GNUC__)\n-#define REG_CLASS_CONTENTS {0LL, 0xfffffffeLL, 0xffffffff00000000LL, 0xfffffffffffffffeLL}\n-#else\n-#define REG_CLASS_CONTENTS {{0, 0}, {-2, 0}, {0, -1}, {-2, -1}}\n-#endif\n-#endif\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n \n-#if SPARC_V9\n #define REGNO_REG_CLASS(REGNO) \\\n   ((REGNO) == 0 ? NO_REGS\t\t\\\n    : (REGNO) < 32 ? GENERAL_REGS\t\\\n    : (REGNO) < 64 ? FP_REGS\t\t\\\n    : (REGNO) < 96 ? EXTRA_FP_REGS\t\\\n    : FPCC_REGS)\n-#else\n-#define REGNO_REG_CLASS(REGNO) \\\n-  ((REGNO) >= 32 ? FP_REGS : (REGNO) == 0 ? NO_REGS : GENERAL_REGS)\n-#endif\n \n /* This is the order in which to allocate registers normally.  \n    \n@@ -1044,11 +1024,11 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n    will get allocated to the float return register, thus saving a move\n    instruction at the end of the function.\n \n-   On v9, the float registers are ordered a little \"funny\" because some\n-   of them (%f16-%f47) are call-preserved.  */\n-#if SPARC_V9\n+   The float registers are ordered a little \"funny\" because in the 64 bit\n+   architecture, some of them (%f16-%f47) are call-preserved.  */\n+\n #define REG_ALLOC_ORDER \\\n-{ 8, 9, 10, 11, 12, 13,\t\t\t\\\n+{ 8, 9, 10, 11, 12, 13, 2, 3,\t\t\\\n   15, 16, 17, 18, 19, 20, 21, 22,\t\\\n   23, 24, 25, 26, 27, 28, 29, 31,\t\\\n   34, 35, 36, 37, 38, 39,\t\t/* %f2-%f7 */   \\\n@@ -1061,28 +1041,16 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n   72, 73, 74, 75, 76, 77, 78, 79,\t/* %f40-%f47 */ \\\n   32, 33,\t\t\t\t/* %f0,%f1 */   \\\n   96, 97, 98, 99,\t\t\t/* %fcc0-3 */   \\\n-  1, 5, 2, 3, 4, 6, 7, 0, 14, 30}\n-#else\n-#define REG_ALLOC_ORDER \\\n-{ 8, 9, 10, 11, 12, 13, 2, 3, \t\t\\\n-  15, 16, 17, 18, 19, 20, 21, 22, \t\\\n-  23, 24, 25, 26, 27, 28, 29, 31,\t\\\n-  34, 35, 36, 37, 38, 39,\t\t\\\n-  40, 41, 42, 43, 44, 45, 46, 47,\t\\\n-  48, 49, 50, 51, 52, 53, 54, 55,\t\\\n-  56, 57, 58, 59, 60, 61, 62, 63,\t\\\n-  32, 33,\t\t\t\t\\\n   1, 4, 5, 6, 7, 0, 14, 30}\n-#endif\n \n /* This is the order in which to allocate registers for\n    leaf functions.  If all registers can fit in the \"i\" registers,\n    then we have the possibility of having a leaf function.\n-   v9: The floating point registers are ordered a little \"funny\" because some\n-   of them (%f16-%f47) are call-preserved.   */\n-#if SPARC_V9\n+   The floating point registers are ordered a little \"funny\" because in the\n+   64 bit architecture some of them (%f16-%f47) are call-preserved.   */\n+\n #define REG_LEAF_ALLOC_ORDER \\\n-{ 24, 25, 26, 27, 28, 29,\t\t\\\n+{ 2, 3, 24, 25, 26, 27, 28, 29,\t\t\\\n   15, 8, 9, 10, 11, 12, 13,\t\t\\\n   16, 17, 18, 19, 20, 21, 22, 23,\t\\\n   34, 35, 36, 37, 38, 39,\t\t\\\n@@ -1095,19 +1063,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n   72, 73, 74, 75, 76, 77, 78, 79,\t\\\n   32, 33,\t\t\t\t\\\n   96, 97, 98, 99,\t\t\t\\\n-  1, 5, 2, 3, 4, 6, 7, 0, 14, 30, 31}\n-#else\n-#define REG_LEAF_ALLOC_ORDER \\\n-{ 2, 3, 24, 25, 26, 27, 28, 29,\t\t\\\n-  15, 8, 9, 10, 11, 12, 13,\t\t\\\n-  16, 17, 18, 19, 20, 21, 22, 23,\t\\\n-  34, 35, 36, 37, 38, 39,\t\t\\\n-  40, 41, 42, 43, 44, 45, 46, 47,\t\\\n-  48, 49, 50, 51, 52, 53, 54, 55,\t\\\n-  56, 57, 58, 59, 60, 61, 62, 63,\t\\\n-  32, 33,\t\t\t\t\\\n   1, 4, 5, 6, 7, 0, 14, 30, 31}\n-#endif\n \n #define ORDER_REGS_FOR_LOCAL_ALLOC order_regs_for_local_alloc ()\n \n@@ -1116,7 +1072,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n    register is used and is not permitted in a leaf function.  We make %g7\n    a global reg if -mflat and voila.  Since %g7 is a system register and is\n    fixed it won't be used by gcc anyway.  */\n-#if SPARC_V9\n+\n #define LEAF_REGISTERS \\\n { 1, 1, 1, 1, 1, 1, 1, 0,\t\\\n   0, 0, 0, 0, 0, 0, 1, 0,\t\\\n@@ -1131,17 +1087,6 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1}\n-#else\n-#define LEAF_REGISTERS \\\n-{ 1, 1, 1, 1, 1, 1, 1, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 1, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  1, 1, 1, 1, 1, 1, 0, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1}\n-#endif\n \n extern char leaf_reg_remap[];\n #define LEAF_REG_REMAP(REGNO) (leaf_reg_remap[REGNO])\n@@ -1151,26 +1096,21 @@ extern char leaf_reg_remap[];\n #define BASE_REG_CLASS GENERAL_REGS\n \n /* Local macro to handle the two v9 classes of FP regs.  */\n-#if SPARC_V9\n #define FP_REG_CLASS_P(CLASS) ((CLASS) == FP_REGS || (CLASS) == EXTRA_FP_REGS)\n-#else\n-#define FP_REG_CLASS_P(CLASS) ((CLASS) == FP_REGS)\n-#endif\n \n-/* Get reg_class from a letter such as appears in the machine description.  */\n+/* Get reg_class from a letter such as appears in the machine description.\n+   In the not-v9 case, coerce v9's 'e' class to 'f', so we can use 'e' in the\n+   .md file for v8 and v9.  */\n \n-#if SPARC_V9\n #define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'f' ? FP_REGS\t\t\\\n-   : (C) == 'e' ? EXTRA_FP_REGS\t\\\n-   : (C) == 'c' ? FPCC_REGS\t\\\n-   : NO_REGS)\n-#else\n-/* Coerce v9's 'e' class to 'f', so we can use 'e' in the .md file for\n-   v8 and v9.  */\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'f' ? FP_REGS : (C) == 'e' ? FP_REGS : NO_REGS)\n-#endif\n+(TARGET_V9\t\t\t\\\n+ ? ((C) == 'f' ? FP_REGS\t\\\n+    : (C) == 'e' ? EXTRA_FP_REGS \\\n+    : (C) == 'c' ? FPCC_REGS\t\\\n+    : NO_REGS)\t\t\t\\\n+ : ((C) == 'f' ? FP_REGS\t\\\n+    : (C) == 'e' ? FP_REGS\t\\\n+    : NO_REGS))\n \n /* The letters I, J, K, L and M in a register constraint string\n    can be used to stand for particular ranges of immediate operands.\n@@ -2704,7 +2644,7 @@ extern struct rtx_def *legitimize_pic_address ();\n \n /* Adjust the cost of dependencies.  */\n #define ADJUST_COST(INSN,LINK,DEP,COST) \\\n-  if (sparc_cpu == CPU_SUPERSPARC) \\\n+  if (sparc_cpu == PROCESSOR_SUPERSPARC) \\\n     (COST) = supersparc_adjust_cost (INSN, LINK, DEP, COST)\n \n /* Conditional branches with empty delay slots have a length of two.  */\n@@ -2759,19 +2699,11 @@ extern struct rtx_def *legitimize_pic_address ();\n  \"%f8\", \"%f9\", \"%f10\", \"%f11\", \"%f12\", \"%f13\", \"%f14\", \"%f15\",\t\t\\\n  \"%f16\", \"%f17\", \"%f18\", \"%f19\", \"%f20\", \"%f21\", \"%f22\", \"%f23\",\t\\\n  \"%f24\", \"%f25\", \"%f26\", \"%f27\", \"%f28\", \"%f29\", \"%f30\", \"%f31\",\t\\\n- SPARC64_REGISTER_NAMES\t\t\t\t\t\t\t\\\n-}\n-\n-#if SPARC_V9\n-#define SPARC64_REGISTER_NAMES \\\n  \"%f32\", \"%f33\", \"%f34\", \"%f35\", \"%f36\", \"%f37\", \"%f38\", \"%f39\",\t\\\n  \"%f40\", \"%f41\", \"%f42\", \"%f43\", \"%f44\", \"%f45\", \"%f46\", \"%f47\",\t\\\n  \"%f48\", \"%f49\", \"%f50\", \"%f51\", \"%f52\", \"%f53\", \"%f54\", \"%f55\",\t\\\n  \"%f56\", \"%f57\", \"%f58\", \"%f59\", \"%f60\", \"%f61\", \"%f62\", \"%f63\",\t\\\n- \"%fcc0\", \"%fcc1\", \"%fcc2\", \"%fcc3\"\n-#else\n-#define SPARC64_REGISTER_NAMES\n-#endif\n+ \"%fcc0\", \"%fcc1\", \"%fcc2\", \"%fcc3\"}\n \n /* Define additional names for use in asm clobbers and asm declarations.\n "}]}