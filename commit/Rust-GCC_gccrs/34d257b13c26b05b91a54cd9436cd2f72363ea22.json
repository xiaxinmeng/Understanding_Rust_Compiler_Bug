{"sha": "34d257b13c26b05b91a54cd9436cd2f72363ea22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRkMjU3YjEzYzI2YjA1YjkxYTU0Y2Q5NDM2Y2QyZjcyMzYzZWEyMg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "1999-09-21T15:00:41Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "1999-09-21T15:00:41Z"}, "message": "dyncast1.C: New test.\n\n\t* g++.old-deja/g++.other/dyncast1.C: New test.\n\t* g++.old-deja/g++.other/dyncast2.C: New test.\n\t* g++.old-deja/g++.other/dyncast3.C: New test.\n\t* g++.old-deja/g++.other/dyncast4.C: New test.\n\t* g++.old-deja/g++.other/dyncast5.C: New test.\n\t* g++.old-deja/g++.eh/catch3.C: New test.\n\t* g++.old-deja/g++.eh/catch3p.C: New test.\n\t* g++.old-deja/g++.eh/catch4.C: New test.\n\t* g++.old-deja/g++.eh/catch4p.C: New test.\n\t* g++.old-deja/g++.eh/catch5.C: New test.\n\t* g++.old-deja/g++.eh/catch5p.C: New test.\n\t* g++.old-deja/g++.eh/catch6.C: New test.\n\t* g++.old-deja/g++.eh/catch6p.C: New test.\n\t* g++.old-deja/g++.eh/catch7.C: New test.\n\t* g++.old-deja/g++.eh/catch7p.C: New test.\n\t* g++.old-deja/g++.eh/catch8.C: New test.\n\t* g++.old-deja/g++.eh/catch8p.C: New test.\n\t* g++.old-deja/g++.eh/catch9.C: New test.\n\t* g++.old-deja/g++.eh/catch9p.C: New test.\n\nFrom-SVN: r29546", "tree": {"sha": "f66dff7a77014e0c8b43de0b18cc9314d3c23939", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f66dff7a77014e0c8b43de0b18cc9314d3c23939"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34d257b13c26b05b91a54cd9436cd2f72363ea22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34d257b13c26b05b91a54cd9436cd2f72363ea22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34d257b13c26b05b91a54cd9436cd2f72363ea22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34d257b13c26b05b91a54cd9436cd2f72363ea22/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8288909fc3faededa65c24aa04b7f91a7eb11c86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8288909fc3faededa65c24aa04b7f91a7eb11c86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8288909fc3faededa65c24aa04b7f91a7eb11c86"}], "stats": {"total": 2243, "additions": 2243, "deletions": 0}, "files": [{"sha": "65639f39ea8e7a96530944f537c093384bdb681c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -1,3 +1,25 @@\n+Tue Sep 21 15:38:10 BST 1999  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* g++.old-deja/g++.other/dyncast1.C: New test.\n+\t* g++.old-deja/g++.other/dyncast2.C: New test.\n+\t* g++.old-deja/g++.other/dyncast3.C: New test.\n+\t* g++.old-deja/g++.other/dyncast4.C: New test.\n+\t* g++.old-deja/g++.other/dyncast5.C: New test.\n+\t* g++.old-deja/g++.eh/catch3.C: New test.\n+\t* g++.old-deja/g++.eh/catch3p.C: New test.\n+\t* g++.old-deja/g++.eh/catch4.C: New test.\n+\t* g++.old-deja/g++.eh/catch4p.C: New test.\n+\t* g++.old-deja/g++.eh/catch5.C: New test.\n+\t* g++.old-deja/g++.eh/catch5p.C: New test.\n+\t* g++.old-deja/g++.eh/catch6.C: New test.\n+\t* g++.old-deja/g++.eh/catch6p.C: New test.\n+\t* g++.old-deja/g++.eh/catch7.C: New test.\n+\t* g++.old-deja/g++.eh/catch7p.C: New test.\n+\t* g++.old-deja/g++.eh/catch8.C: New test.\n+\t* g++.old-deja/g++.eh/catch8p.C: New test.\n+\t* g++.old-deja/g++.eh/catch9.C: New test.\n+\t* g++.old-deja/g++.eh/catch9p.C: New test.\n+\n Mon Sep 13 14:14:21 BST 1999  Nathan Sidwell  <nathan@acm.org>\n \n \t* g++.old-deja/g++.other/sizeof3.C: Remove XFAILS."}, {"sha": "0451d77ca7f37923ff2d3481fb946d143bfb538f", "filename": "gcc/testsuite/g++.old-deja/g++.eh/catch3.C", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch3.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,114 @@\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 29 Aug 1999 <nathan@acm.org>\n+\n+// We cannot catch an ambiguous base class. Check with a non-virtual public\n+// DAG.\n+// -- public, << private, == virtual\n+\n+// D--B--A\n+// +--C--A\n+\n+struct A { int m; };\n+struct B : A { int m; };\n+struct C : A { int m; };\n+struct D : B, C { int m; };\n+\n+void fna(A *obj) { throw obj; }\n+void fnb(B *obj) { throw obj; }\n+void fnc(C *obj) { throw obj; }\n+void fnd(D *obj) { throw obj; }\n+\n+extern \"C\" void abort();\n+\n+void check(D *d)\n+{\n+  int caught;\n+  \n+  // try with whole object\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(D *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(B *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  // try with an A object\n+  caught = 0;\n+  try { fna((B *)d); }\n+  catch(B *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (B *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((C *)d); }\n+  catch(C *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (C *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  // try with B object\n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(A *p) { caught = 1; if (p != (B *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(B *p) { caught = 1; if (p != (B *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(C *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  // try with C object\n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(A *p) { caught = 1; if (p != (C *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(B *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  return;\n+}\n+\n+int main ()\n+{\n+  D d;\n+  check (&d); // try with an object\n+  check ((D *)0); // try with no object\n+  \n+  return 0;\n+}"}, {"sha": "33873aa3cbe99443926cf957d93e2be9e191139d", "filename": "gcc/testsuite/g++.old-deja/g++.eh/catch3p.C", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch3p.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch3p.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch3p.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,114 @@\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 29 Aug 1999 <nathan@acm.org>\n+\n+// We cannot catch an ambiguous base class. Check with a non-virtual\n+// polymorphic public DAG.\n+// -- public, << private, == virtual\n+\n+// D--B--A\n+// +--C--A\n+\n+struct A { int m; virtual ~A(){}};\n+struct B : A { int m; };\n+struct C : A { int m; };\n+struct D : B, C { int m; };\n+\n+void fna(A *obj) { throw obj; }\n+void fnb(B *obj) { throw obj; }\n+void fnc(C *obj) { throw obj; }\n+void fnd(D *obj) { throw obj; }\n+\n+extern \"C\" void abort();\n+\n+void check(D *d)\n+{\n+  int caught;\n+  \n+  // try with whole object\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(D *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(B *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  // try with an A object\n+  caught = 0;\n+  try { fna((B *)d); }\n+  catch(B *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (B *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((C *)d); }\n+  catch(C *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (C *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  // try with B object\n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(A *p) { caught = 1; if (p != (B *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(B *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(C *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  // try with C object\n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(A *p) { caught = 1; if (p != (C *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(B *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  return;\n+}\n+\n+int main ()\n+{\n+  D d;\n+  check (&d); // try with an object\n+  check ((D *)0); // try with no object\n+  \n+  return 0;\n+}"}, {"sha": "94c602c7e0a8ebb361a01cc2134fbb430cc74f42", "filename": "gcc/testsuite/g++.old-deja/g++.eh/catch4.C", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch4.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,111 @@\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 29 Aug 1999 <nathan@acm.org>\n+\n+// We cannot catch an ambiguous base class. Check with a virtual public\n+// DAG.\n+// -- public, << private, == virtual\n+\n+// D--B==A\n+// +--C==A\n+\n+struct A { int m; };\n+struct B : virtual A { int m; };\n+struct C : virtual A { int m; };\n+struct D : B, C { int m; };\n+\n+void fna(A *obj) { throw obj; }\n+void fnb(B *obj) { throw obj; }\n+void fnc(C *obj) { throw obj; }\n+void fnd(D *obj) { throw obj; }\n+\n+extern \"C\" void abort();\n+\n+void check(D *d)\n+{\n+  int caught;\n+  \n+  // try with whole object\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(B *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  // try with an A object\n+  caught = 0;\n+  try { fna((B *)d); }\n+  catch(B *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((C *)d); }\n+  catch(C *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  // try with B object\n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(A *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(B *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(C *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  // try with C object\n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(A *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(B *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  return;\n+}\n+\n+int main ()\n+{\n+  D d;\n+  check (&d); // try with an object\n+  check ((D *)0); // try with no object\n+  \n+  return 0;\n+}"}, {"sha": "19c2273ec564ca88b1ce8c73264f134cc187905c", "filename": "gcc/testsuite/g++.old-deja/g++.eh/catch4p.C", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch4p.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch4p.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch4p.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,111 @@\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 29 Aug 1999 <nathan@acm.org>\n+\n+// We cannot catch an ambiguous base class. Check with a virtual \n+// polymorphic public DAG.\n+// -- public, << private, == virtual\n+\n+// D--B==A\n+// +--C==A\n+\n+struct A { int m; virtual ~A(){}};\n+struct B : virtual A { int m; };\n+struct C : virtual A { int m; };\n+struct D : B, C { int m; };\n+\n+void fna(A *obj) { throw obj; }\n+void fnb(B *obj) { throw obj; }\n+void fnc(C *obj) { throw obj; }\n+void fnd(D *obj) { throw obj; }\n+\n+extern \"C\" void abort();\n+\n+void check(D *d)\n+{\n+  int caught;\n+  \n+  // try with whole object\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(B *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  // try with an A object\n+  caught = 0;\n+  try { fna((B *)d); }\n+  catch(B *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((C *)d); }\n+  catch(C *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  // try with B object\n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(A *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(B *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(C *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  // try with C object\n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(A *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(B *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  return;\n+}\n+\n+int main ()\n+{\n+  D d;\n+  check (&d); // try with an object\n+  check ((D *)0); // try with no object\n+  \n+  return 0;\n+}"}, {"sha": "9dff637ade18e1310e5a59c154d5d70c28c1ccb7", "filename": "gcc/testsuite/g++.old-deja/g++.eh/catch5.C", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch5.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,151 @@\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 29 Aug 1999 <nathan@acm.org>\n+\n+// We cannot catch an ambiguous base class.\n+// -- public, << private, == virtual\n+\n+// D--B==A\n+// +--C==A\n+// +--AA-A\n+\n+struct A { int m; };\n+struct B : virtual A { int m; };\n+struct C : virtual A { int m; };\n+struct AA : A { int m; };\n+struct D : B, C, AA { int m; };\n+\n+void fna(A *obj) { throw obj; }\n+void fnb(B *obj) { throw obj; }\n+void fnc(C *obj) { throw obj; }\n+void fnd(D *obj) { throw obj; }\n+void fnaa(AA *obj) { throw obj; }\n+\n+extern \"C\" void abort();\n+\n+void check(D *d)\n+{\n+  int caught;\n+  \n+  // try with whole object\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(D *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(B *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(AA *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  // try with an A object\n+  caught = 0;\n+  try { fna((B *)d); }\n+  catch(B *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (B *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((C *)d); }\n+  catch(C *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (C *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((AA *)d); }\n+  catch(AA *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (AA *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  // try with B object\n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(A *p) { caught = 1; if (p != (B *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(B *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(C *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  // try with C object\n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(A *p) { caught = 1; if (p != (C *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(B *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  // try with AA object\n+  caught = 0;\n+  try { fnaa((AA *)d); }\n+  catch(A *p) { caught = 1; if (p != (AA *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnaa((AA *)d); }\n+  catch(AA *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnaa((AA *)d); }\n+  catch(C *p) { abort(); }\n+  catch(B *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  return;\n+}\n+\n+int main ()\n+{\n+  D d;\n+  check (&d); // try with an object\n+  check ((D *)0); // try with no object\n+  \n+  return 0;\n+}"}, {"sha": "c6a5d0a0b1ff9087acf5f6ebccf782398159ddd8", "filename": "gcc/testsuite/g++.old-deja/g++.eh/catch5p.C", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch5p.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch5p.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch5p.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,151 @@\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 29 Aug 1999 <nathan@acm.org>\n+\n+// We cannot catch an ambiguous base class.\n+// -- public, << private, == virtual\n+\n+// D--B==A\n+// +--C==A\n+// +--AA-A\n+\n+struct A { int m; virtual ~A(){}};\n+struct B : virtual A { int m; };\n+struct C : virtual A { int m; };\n+struct AA : A { int m; };\n+struct D : B, C, AA { int m; };\n+\n+void fna(A *obj) { throw obj; }\n+void fnb(B *obj) { throw obj; }\n+void fnc(C *obj) { throw obj; }\n+void fnd(D *obj) { throw obj; }\n+void fnaa(AA *obj) { throw obj; }\n+\n+extern \"C\" void abort();\n+\n+void check(D *d)\n+{\n+  int caught;\n+  \n+  // try with whole object\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(D *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(B *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(AA *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  // try with an A object\n+  caught = 0;\n+  try { fna((B *)d); }\n+  catch(B *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (B *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((C *)d); }\n+  catch(C *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (C *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((AA *)d); }\n+  catch(AA *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (AA *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  // try with B object\n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(A *p) { caught = 1; if (p != (B *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(B *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(C *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  // try with C object\n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(A *p) { caught = 1; if (p != (C *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(B *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  // try with AA object\n+  caught = 0;\n+  try { fnaa((AA *)d); }\n+  catch(A *p) { caught = 1; if (p != (AA *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnaa((AA *)d); }\n+  catch(AA *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnaa((AA *)d); }\n+  catch(C *p) { abort(); }\n+  catch(B *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  return;\n+}\n+\n+int main ()\n+{\n+  D d;\n+  check (&d); // try with an object\n+  check ((D *)0); // try with no object\n+  \n+  return 0;\n+}"}, {"sha": "1ac48124c9846fb69880a04879b1ff82d476e84f", "filename": "gcc/testsuite/g++.old-deja/g++.eh/catch6.C", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch6.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,182 @@\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 29 Aug 1999 <nathan@acm.org>\n+\n+// We cannot catch an ambiguous base class.\n+// -- public, << private, == virtual\n+\n+// E==D--B==A\n+//    +--C==A\n+//    +--AA-A\n+\n+struct A { int m; };\n+struct B : virtual A { int m; };\n+struct C : virtual A { int m; };\n+struct AA : A { int m; };\n+struct D : B, C, AA { int m; };\n+struct E : virtual D { int m; };\n+\n+void fna(A *obj) { throw obj; }\n+void fnb(B *obj) { throw obj; }\n+void fnc(C *obj) { throw obj; }\n+void fnd(D *obj) { throw obj; }\n+void fnaa(AA *obj) { throw obj; }\n+void fne(E *obj) { throw obj; }\n+\n+extern \"C\" void abort();\n+\n+void check(E *e)\n+{\n+  int caught;\n+  \n+  // try with whole object\n+  caught = 0;\n+  try { fne(e); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(D *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fne(e); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(B *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fne(e); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(C *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fne(e); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(AA *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  // try with D oject\n+  caught = 0;\n+  try { fnd((D *)e); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(D *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd((D *)e); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(B *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd((D *)e); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(C *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd((D *)e); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(AA *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  // try with an A object\n+  caught = 0;\n+  try { fna((B *)e); }\n+  catch(B *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (B *)e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((C *)e); }\n+  catch(C *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (C *)e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((AA *)e); }\n+  catch(AA *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (AA *)e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  // try with B object\n+  caught = 0;\n+  try { fnb((B *)e); }\n+  catch(A *p) { caught = 1; if (p != (B *)e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)e); }\n+  catch(B *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)e); }\n+  catch(C *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  // try with C object\n+  caught = 0;\n+  try { fnc((C *)e); }\n+  catch(A *p) { caught = 1; if (p != (C *)e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)e); }\n+  catch(C *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)e); }\n+  catch(B *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  // try with AA object\n+  caught = 0;\n+  try { fnaa((AA *)e); }\n+  catch(A *p) { caught = 1; if (p != (AA *)e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnaa((AA *)e); }\n+  catch(AA *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnaa((AA *)e); }\n+  catch(C *p) { abort(); }\n+  catch(B *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  return;\n+}\n+\n+int main ()\n+{\n+  E e;\n+  check (&e); // try with an object\n+  check ((E *)0); // try with no object\n+  \n+  return 0;\n+}"}, {"sha": "3aac1a789cc715100f2ed88228b292777cebd0c5", "filename": "gcc/testsuite/g++.old-deja/g++.eh/catch6p.C", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch6p.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch6p.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch6p.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,182 @@\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 29 Aug 1999 <nathan@acm.org>\n+\n+// We cannot catch an ambiguous base class.\n+// -- public, << private, == virtual\n+\n+// E==D--B==A\n+//    +--C==A\n+//    +--AA-A\n+\n+struct A { int m; virtual ~A(){}};\n+struct B : virtual A { int m; };\n+struct C : virtual A { int m; };\n+struct AA : A { int m; };\n+struct D : B, C, AA { int m; };\n+struct E : virtual D { int m; };\n+\n+void fna(A *obj) { throw obj; }\n+void fnb(B *obj) { throw obj; }\n+void fnc(C *obj) { throw obj; }\n+void fnd(D *obj) { throw obj; }\n+void fnaa(AA *obj) { throw obj; }\n+void fne(E *obj) { throw obj; }\n+\n+extern \"C\" void abort();\n+\n+void check(E *e)\n+{\n+  int caught;\n+  \n+  // try with whole object\n+  caught = 0;\n+  try { fne(e); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(D *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fne(e); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(B *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fne(e); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(C *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fne(e); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(AA *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  // try with D oject\n+  caught = 0;\n+  try { fnd((D *)e); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(D *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd((D *)e); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(B *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd((D *)e); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(C *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd((D *)e); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(AA *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  // try with an A object\n+  caught = 0;\n+  try { fna((B *)e); }\n+  catch(B *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (B *)e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((C *)e); }\n+  catch(C *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (C *)e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((AA *)e); }\n+  catch(AA *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (AA *)e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  // try with B object\n+  caught = 0;\n+  try { fnb((B *)e); }\n+  catch(A *p) { caught = 1; if (p != (B *)e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)e); }\n+  catch(B *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)e); }\n+  catch(C *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  // try with C object\n+  caught = 0;\n+  try { fnc((C *)e); }\n+  catch(A *p) { caught = 1; if (p != (C *)e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)e); }\n+  catch(C *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)e); }\n+  catch(B *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  // try with AA object\n+  caught = 0;\n+  try { fnaa((AA *)e); }\n+  catch(A *p) { caught = 1; if (p != (AA *)e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnaa((AA *)e); }\n+  catch(AA *p) { caught = 1; if (p != e) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnaa((AA *)e); }\n+  catch(C *p) { abort(); }\n+  catch(B *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  return;\n+}\n+\n+int main ()\n+{\n+  E e;\n+  check (&e); // try with an object\n+  check ((E *)0); // try with no object\n+  \n+  return 0;\n+}"}, {"sha": "bf90e0e590b9e1dc8fd241e411841fc9f3ff0f37", "filename": "gcc/testsuite/g++.old-deja/g++.eh/catch7.C", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch7.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,181 @@\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 29 Aug 1999 <nathan@acm.org>\n+\n+// We cannot catch an ambiguous base class.\n+// -- public, << private, == virtual\n+\n+// different levels\n+// F--D--B--A\n+//    +--C--A\n+// +--E--A\n+\n+struct A { int m; };\n+struct B : A { int m; };\n+struct C : A { int m; };\n+struct D : B, C { int m; };\n+struct E : A { int m; };\n+struct F : D, E { int m; };\n+\n+void fna(A *obj) { throw obj; }\n+void fnb(B *obj) { throw obj; }\n+void fnc(C *obj) { throw obj; }\n+void fnd(D *obj) { throw obj; }\n+void fne(E *obj) { throw obj; }\n+void fnf(F *obj) { throw obj; }\n+\n+extern \"C\" void abort();\n+\n+void check(F *f)\n+{\n+  int caught;\n+  \n+  // try with whole object\n+  caught = 0;\n+  try { fnf(f); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(F *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnf(f); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(E *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnf(f); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(D *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnf(f); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(B *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnf(f); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(C *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  // try with D object\n+  caught = 0;\n+  try { fnd(f); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(D *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(f); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(B *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(f); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(C *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  // try with E object\n+  caught = 0;\n+  try { fne(f); }\n+  catch(A *p) { caught = 1; if (p != (E *)f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fne(f); }\n+  catch(E *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fne(f); }\n+  catch(F *p) { abort(); }\n+  catch(...) { caught = 1; }\n+  if (!caught) abort();\n+\n+  // try with an A object\n+  caught = 0;\n+  try { fna((B *)f); }\n+  catch(B *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (B *)f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((C *)f); }\n+  catch(C *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (C *)f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((E *)f); }\n+  catch(E *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (E *)f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  // try with B object\n+  caught = 0;\n+  try { fnb((B *)f); }\n+  catch(A *p) { caught = 1; if (p != (B *)f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)f); }\n+  catch(B *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)f); }\n+  catch(C *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  // try with C object\n+  caught = 0;\n+  try { fnc((C *)f); }\n+  catch(A *p) { caught = 1; if (p != (C *)f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)f); }\n+  catch(C *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)f); }\n+  catch(B *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  return;\n+}\n+\n+int main ()\n+{\n+  F f;\n+  check (&f); // try with an object\n+  check ((F *)0); // try with no object\n+  \n+  return 0;\n+}"}, {"sha": "be017c1a10be25490c7e41dc6276afa5f42e4812", "filename": "gcc/testsuite/g++.old-deja/g++.eh/catch7p.C", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch7p.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch7p.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch7p.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,181 @@\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 29 Aug 1999 <nathan@acm.org>\n+\n+// We cannot catch an ambiguous base class.\n+// -- public, << private, == virtual\n+\n+// different levels\n+// F--D--B--A\n+//    +--C--A\n+// +--E--A\n+\n+struct A { int m; virtual ~A(){}};\n+struct B : A { int m; };\n+struct C : A { int m; };\n+struct D : B, C { int m; };\n+struct E : A { int m; };\n+struct F : D, E { int m; };\n+\n+void fna(A *obj) { throw obj; }\n+void fnb(B *obj) { throw obj; }\n+void fnc(C *obj) { throw obj; }\n+void fnd(D *obj) { throw obj; }\n+void fne(E *obj) { throw obj; }\n+void fnf(F *obj) { throw obj; }\n+\n+extern \"C\" void abort();\n+\n+void check(F *f)\n+{\n+  int caught;\n+  \n+  // try with whole object\n+  caught = 0;\n+  try { fnf(f); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(F *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnf(f); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(E *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnf(f); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(D *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnf(f); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(B *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnf(f); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(C *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  // try with D object\n+  caught = 0;\n+  try { fnd(f); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(D *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(f); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(B *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(f); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(C *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  // try with E object\n+  caught = 0;\n+  try { fne(f); }\n+  catch(A *p) { caught = 1; if (p != (E *)f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fne(f); }\n+  catch(E *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fne(f); }\n+  catch(F *p) { abort(); }\n+  catch(...) { caught = 1; }\n+  if (!caught) abort();\n+\n+  // try with an A object\n+  caught = 0;\n+  try { fna((B *)f); }\n+  catch(B *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (B *)f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((C *)f); }\n+  catch(C *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (C *)f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((E *)f); }\n+  catch(E *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (E *)f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  // try with B object\n+  caught = 0;\n+  try { fnb((B *)f); }\n+  catch(A *p) { caught = 1; if (p != (B *)f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)f); }\n+  catch(B *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)f); }\n+  catch(C *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  // try with C object\n+  caught = 0;\n+  try { fnc((C *)f); }\n+  catch(A *p) { caught = 1; if (p != (C *)f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)f); }\n+  catch(C *p) { caught = 1; if (p != f) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)f); }\n+  catch(B *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  return;\n+}\n+\n+int main ()\n+{\n+  F f;\n+  check (&f); // try with an object\n+  check ((F *)0); // try with no object\n+  \n+  return 0;\n+}"}, {"sha": "685a4ec7d7fadaed849b9b9cd15873604c4bc85a", "filename": "gcc/testsuite/g++.old-deja/g++.eh/catch8.C", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch8.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,107 @@\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 6 Jun 1999 <nathan@acm.org>\n+\n+// We cannot catch an ambiguous base class.\n+// -- public, << private, == virtual\n+\n+// D--B--A\n+// +--C<<A\n+\n+struct A { int m; };\n+struct B : A { int m; };\n+struct C : private A { int m; };\n+struct D : B, C { int m; };\n+\n+void fna(A *obj) { throw obj; }\n+void fnb(B *obj) { throw obj; }\n+void fnc(C *obj) { throw obj; }\n+void fnd(D *obj) { throw obj; }\n+\n+extern \"C\" void abort();\n+\n+void check(D *d)\n+{\n+  int caught;\n+  \n+  // try with whole object\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(D *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(B *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  // try with an A object\n+  caught = 0;\n+  try { fna((B *)d); }\n+  catch(B *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (B *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((A *)(C *)d); }\n+  catch(C *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (A *)(C *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  // try with B object\n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(A *p) { caught = 1; if (p != (B *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(B *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(C *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(A *p) { abort();}\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(B *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+\n+  return;\n+}  \n+\n+int main ()\n+{\n+  D d;\n+  check (&d); // try with an object\n+  check ((D *)0); // try with no object\n+  \n+  return 0;\n+}"}, {"sha": "972761d17e5be16492788f7f2994f06366e06644", "filename": "gcc/testsuite/g++.old-deja/g++.eh/catch8p.C", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch8p.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch8p.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch8p.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,108 @@\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 6 Jun 1999 <nathan@acm.org>\n+\n+// We cannot catch an ambiguous base class.\n+// -- public, << private, == virtual\n+\n+// D--B--A\n+// +--C<<A\n+\n+struct A { int m; virtual ~A(){}};\n+struct B : A { int m; };\n+struct C : private A { int m; };\n+struct D : B, C { int m; };\n+\n+void fna(A *obj) { throw obj; }\n+void fnb(B *obj) { throw obj; }\n+void fnc(C *obj) { throw obj; }\n+void fnd(D *obj) { throw obj; }\n+\n+extern \"C\" void abort();\n+\n+void check(D *d)\n+{\n+  int caught;\n+  \n+  // try with whole object\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(D *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(B *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  // try with an A object\n+  caught = 0;\n+  try { fna((B *)d); }\n+  catch(B *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (B *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((A *)(C *)d); }\n+  catch(C *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (A *)(C *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  // try with B object\n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(A *p) { caught = 1; if (p != (B *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(B *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(C *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  // try with C object\n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(A *p) { abort();}\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(B *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+\n+  return;\n+}  \n+\n+int main ()\n+{\n+  D d;\n+  check (&d); // try with an object\n+  check ((D *)0); // try with no object\n+  \n+  return 0;\n+}"}, {"sha": "13d8960e7160a93e27c9ce2980e458a094628f4e", "filename": "gcc/testsuite/g++.old-deja/g++.eh/catch9.C", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch9.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,114 @@\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 29 Aug 1999 <nathan@acm.org>\n+\n+// We cannot catch an ambiguous base class.\n+// -- public, << private, == virtual\n+\n+// D==B--A\n+// +==C--A\n+\n+struct A { int m; };\n+struct B : A { int m; };\n+struct C : A { int m; };\n+struct D : virtual B, virtual C { int m; };\n+\n+\n+void fna(A *obj) { throw obj; }\n+void fnb(B *obj) { throw obj; }\n+void fnc(C *obj) { throw obj; }\n+void fnd(D *obj) { throw obj; }\n+\n+extern \"C\" void abort();\n+\n+void check(D *d)\n+{\n+  int caught;\n+  \n+  // try with whole object\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(D *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(B *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  // try with an A object\n+  caught = 0;\n+  try { fna((B *)d); }\n+  catch(B *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (B *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((C *)d); }\n+  catch(C *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (C *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  // try with B object\n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(A *p) { caught = 1; if (p != (B *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(B *p) { caught = 1; if (p != (B *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(C *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  // try with C object\n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(A *p) { caught = 1; if (p != (C *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(C *p) { caught = 1; if (p != (C *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(B *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+\n+  return;\n+}  \n+\n+int main ()\n+{\n+  D d;\n+  check (&d); // try with an object\n+  check ((D *)0); // try with no object\n+  \n+  return 0;\n+}"}, {"sha": "ff7bf302d8477b8bb4d95a84bb4ccd8878cb4cf8", "filename": "gcc/testsuite/g++.old-deja/g++.eh/catch9p.C", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch9p.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch9p.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fcatch9p.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,114 @@\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 29 Aug 1999 <nathan@acm.org>\n+\n+// We cannot catch an ambiguous base class.\n+// -- public, << private, == virtual\n+\n+// D==B--A\n+// +==C--A\n+\n+struct A { int m; virtual ~A(){}};\n+struct B : A { int m; };\n+struct C : A { int m; };\n+struct D : virtual B, virtual C { int m; };\n+\n+\n+void fna(A *obj) { throw obj; }\n+void fnb(B *obj) { throw obj; }\n+void fnc(C *obj) { throw obj; }\n+void fnd(D *obj) { throw obj; }\n+\n+extern \"C\" void abort();\n+\n+void check(D *d)\n+{\n+  int caught;\n+  \n+  // try with whole object\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(D *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(B *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  caught = 0;\n+  try { fnd(d); }\n+  catch(A *p) { abort(); } // A is ambiguous\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+\n+  // try with an A object\n+  caught = 0;\n+  try { fna((B *)d); }\n+  catch(B *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (B *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fna((C *)d); }\n+  catch(C *p) { abort(); } // throw type is static type\n+  catch(A *p) { caught = 1; if (p != (C *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  // try with B object\n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(A *p) { caught = 1; if (p != (B *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(B *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnb((B *)d); }\n+  catch(C *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+  \n+  // try with C object\n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(A *p) { caught = 1; if (p != (C *)d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(C *p) { caught = 1; if (p != d) abort();}\n+  catch(...) { abort(); }\n+  if (!caught) abort();\n+  \n+  caught = 0;\n+  try { fnc((C *)d); }\n+  catch(B *p) { abort(); }\n+  catch(D *p) { abort(); }\n+  catch(...) { caught =1; }\n+  if (!caught) abort();\n+\n+  return;\n+}  \n+\n+int main ()\n+{\n+  D d;\n+  check (&d); // try with an object\n+  check ((D *)0); // try with no object\n+  \n+  return 0;\n+}"}, {"sha": "0a3a09b9a12f9699ff8f3e68fa7f535373e9f1d0", "filename": "gcc/testsuite/g++.old-deja/g++.other/dyncast1.C", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdyncast1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdyncast1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdyncast1.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,122 @@\n+// Author: Alfred Miniarik <a8601248@unet.univie.ac.at>\n+// test of dynamic_cast\n+// runtime detecting of nonpublic\n+// inheritance within a cast\n+// and therefor failing with result 0.\n+\n+extern \"C\" void abort();\n+extern \"C\" void printf(const char*, ...);\n+\n+static int errors = 0;\n+void error(int i)\n+{\n+  printf(\"Error %i\\n\",i);\n+  errors++;\n+}\n+\n+// 1. downcast\n+\n+// 1.1. single inheritance case\n+\n+struct A {virtual ~A(){}};\n+struct AA : A {};\n+struct B : A {};\n+struct BB : B {};\n+class C : B {};\n+struct D : C {};\n+\n+struct CC : B {};\n+class DD : CC {};\n+\n+class CCC : protected B {};\n+class DDD : protected CCC {};\n+\n+void \n+test01 ()\n+{\n+  D d;\n+  if(dynamic_cast<D*> ((A*)&d)) error(1);\n+  if(dynamic_cast<D*> ((B*)&d)) error(2);\n+  if(&d != dynamic_cast<D*> ((C*)&d)) error(3); //counter example\n+  if(dynamic_cast<C*> ((B*)&d)) error(4);\n+\t\n+  DD dd;\n+  if(dynamic_cast<DD*> ((A*)&dd)) error(5);\n+  if(dynamic_cast<DD*> ((B*)&dd)) error(6);\n+\n+  DDD ddd;\n+  if(dynamic_cast<DDD*> ((A*)&ddd)) error(7);\n+  if(dynamic_cast<DDD*> ((B*)&ddd)) error(8);\n+  if(dynamic_cast<CCC*> ((B*)&ddd)) error(9);\n+}\t\t\n+\n+// 1.2. multiple inheritance case\n+// 1.2.1. all bases are public\n+ \n+struct E : D, CC {};\n+struct EE : CC, D {}; //Will search in reverse order.\n+\n+void \n+test02 ()\n+{\n+  E e;\n+  if(dynamic_cast<E*> ((A*)(D*)&e)) error(10);\n+  if(dynamic_cast<E*> ((B*)(D*)&e)) error(11);\n+  if(&e != dynamic_cast<E*> ((C*)(D*)&e)) error(12); //counter example\n+  if(&e != dynamic_cast<E*> ((B*)(CC*)&e)) error(13); //counter example\n+  if((CC*)&e != dynamic_cast<CC*> ((B*)(CC*)&e)) error(14); //counter example\n+  \n+  EE ee;\n+  if(dynamic_cast<EE*> ((A*)(D*)&ee)) error(15);\n+  if(dynamic_cast<EE*> ((B*)(D*)&ee)) error(16);\n+  if(&ee != dynamic_cast<EE*> ((C*)(D*)&ee)) error(17); //counter example\n+  if(&ee != dynamic_cast<EE*> ((B*)(CC*)&ee)) error(18); //counter example\n+  if((CC*)&ee != dynamic_cast<CC*> ((B*)(CC*)&ee)) error(19); //counter example\n+}\t\t\n+\n+// 1.2.2 one or more branches are nonpublic\n+\n+struct X : private BB, E {};\n+struct Y : AA, private B {};\n+\n+class XX : BB, E {};\n+\n+void \n+test03 ()\n+{\n+  X x;\n+  if(&x != dynamic_cast<X*>((B*)(CC*)(E*)&x)) error(20); //counter example\n+  XX xx;\n+  if(dynamic_cast<XX*>((B*)(CC*)(E*)&xx)) error(21);\t\n+  Y y;\n+  if(dynamic_cast<Y*>((B*)&y)) error (22);\n+  if(dynamic_cast<Y*>((A*)(B*)&y)) error (23);\n+}\n+\n+// 2. crosscast\n+\n+struct J {virtual ~J(){};};\n+struct K : CC, private J {}; \n+class KK : J, CC{};\n+\t\t\n+void \n+test04 ()\n+{\n+  E e;\n+  if(dynamic_cast<CC*> ((B*)(D*)&e)) error(24);\n+  if((CC*)&e != dynamic_cast<CC*> ((C*)(D*)&e)) error(25); //counter example\n+  K k;\n+  if(dynamic_cast<J*> ((B*)&k)) error(26);\n+  KK kk;\n+  if(dynamic_cast<J*> ((CC*)&kk)) error(27);\n+}\n+\n+int \n+main ()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  return errors ? 1 : 0;\n+}"}, {"sha": "da537500b4d1c756f34a5889e592f60128e4e250", "filename": "gcc/testsuite/g++.old-deja/g++.other/dyncast2.C", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdyncast2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdyncast2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdyncast2.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,84 @@\n+// Author: Alfred Miniarik <a8601248@unet.univie.ac.at>\n+// test of dynamic_cast\n+// runtime detecting of valid \n+// downcasts within nonpublic \n+// baseclasses.\n+\n+extern \"C\" void abort();\n+extern \"C\" void printf(const char*, ...);\n+\n+static int errors = 0;\n+\n+void error(int i)\n+{\n+  printf(\"Error %i\\n\",i);\n+  errors++;\n+}\n+\n+// 1. downcast\n+// 1.1 single inheritance case\n+\n+struct A {virtual ~A(){};int i;};\n+struct B : A {int i;};\n+struct C : B {int i;};\n+struct CC : C {};\n+class D : C {int i;};\n+\n+struct E : D {int i;};\n+class F : E {int i;};\n+\n+void \n+test01 ()\n+{\n+  D d;\n+  if((C*)&d != dynamic_cast<C*> ((A*)&d)) error(1);\n+  if((C*)&d != dynamic_cast<C*> ((B*)&d)) error(2);\n+  if((B*)&d != dynamic_cast<B*> ((A*)&d)) error(3);\n+\n+  E e;\n+  if((C*)&e != dynamic_cast<C*> ((A*)&e)) error(4);\n+\n+  F f;\n+  if((C*)&f != dynamic_cast<C*> ((B*)&f)) error(5);\n+  if((B*)&f != dynamic_cast<B*> ((A*)&f)) error(6);\n+  if((E*)&f != dynamic_cast<E*> ((D*)&f)) error(7);\n+  if(dynamic_cast<E*> ((C*)&f)) error(8); //counter example\n+}\t\t\n+\n+// 1.2 multiple inheritance case\n+\n+struct G : CC, F{};\n+\t\t\n+void \n+test02 ()\n+{\n+  G g;\n+  if((B*)(F*)&g != dynamic_cast<B*> ((A*)(F*)&g)) error(9);\n+  if(dynamic_cast<D*> ((A*)(F*)&g)) error(10);\n+  if(dynamic_cast<G*> ((B*)(F*)&g)) error(11);\n+}\n+\n+// 2. crosscast (always fail)\n+\n+struct I : C{};\n+struct J : F{};\n+struct K : I, J{};\n+class L : K{};\n+\t\t\n+void \n+test03 ()\n+{\n+  L l;\n+  if(dynamic_cast<J*> ((I*)&l)) error(12);\n+  if(dynamic_cast<J*> ((E*)&l)) error(13);\n+  if(dynamic_cast<I*> ((J*)&l)) error(14);\n+}\n+\n+int \n+main ()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return errors ? 1 : 0;\n+}"}, {"sha": "76f8ca7ed1a3c244ef54fed34c4bd024a85bda9f", "filename": "gcc/testsuite/g++.old-deja/g++.other/dyncast3.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdyncast3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdyncast3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdyncast3.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,32 @@\n+// Author: Alfred Miniarik <a8601248@unet.univie.ac.at>\n+// test of dynamic_cast\n+// runtime detecting of nonpublic\n+// inheritance within a cast\n+// and therefor failing with result 0.\n+\n+extern \"C\" void abort();\n+extern \"C\" void printf(const char*, ...);\n+\n+static int errors = 0;\n+\n+void error(int i)\n+{\n+  printf(\"Error %i\\n\",i);\n+  errors++;\n+}\n+\n+struct A {virtual ~A(){}};\n+struct B : private virtual A {};\n+struct C : virtual A {};\n+struct D : B, C {};\n+\n+int \n+main()\n+{\n+  D d;\n+  A* ap= &d;\n+  if(&d != dynamic_cast<D*>(ap)) error(1);\n+  if((B*)&d != dynamic_cast<B*>(ap)) error(2);\n+  if((C*)&d != dynamic_cast<C*>(ap)) error(3);\n+  return errors ? 1 : 0;\n+}"}, {"sha": "65093d568ffe0e00c58e3dc4f753b4d76cf725bc", "filename": "gcc/testsuite/g++.old-deja/g++.other/dyncast4.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdyncast4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdyncast4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdyncast4.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,27 @@\n+// Author: Alfred Miniarik <a8601248@unet.univie.ac.at>\n+\n+// Even in a derived class, a private base cannot be dynamically downcasted\n+// from.\n+\n+extern \"C\" void abort();\n+\n+struct A {\n+  virtual ~A () {}\n+};\n+\n+struct B : private A {\n+  B* a2b (A* objp)\n+  {\n+    return dynamic_cast<B*> (objp);\n+  }\n+};\n+\n+int\n+main ()\n+{\n+  B b;\n+  A* aptr = (A*) &b;\n+  if (dynamic_cast <B*> (aptr)) abort ();\n+  if (b.a2b (aptr)) abort();\n+  return 0;\n+}"}, {"sha": "65a28523ec1fcf99346810fcc5e80387fc5f85ff", "filename": "gcc/testsuite/g++.old-deja/g++.other/dyncast5.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdyncast5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d257b13c26b05b91a54cd9436cd2f72363ea22/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdyncast5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdyncast5.C?ref=34d257b13c26b05b91a54cd9436cd2f72363ea22", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 6 Jun 1999 <nathan@acm.org>\n+\n+// dynamic cast can only cast to public unambiguous bases\n+\n+struct A {virtual ~A(){} int m; };\n+struct B {virtual ~B(){} int m; };\n+\n+struct C1 : A {int m;};\n+struct C2 : A {int m;};\n+\n+// A is ambiguous, but private in one branch\n+struct D1 : B, C1, private C2 {int m;};\n+// A is ambiguous, and public in both branches\n+struct D2 : B, C1, C2 {int m;};\n+\n+void fn(B *bd1, B *bd2)\n+{\n+  A *ad1;\n+  A *ad2;\n+  \n+  ad1 = dynamic_cast<A *>(bd1);\n+  if(ad1) abort();\n+  ad2 = dynamic_cast<A *>(bd2);\n+  if(ad2) abort();\n+}\n+\n+int main()\n+{\n+  D1 d1;\n+  D2 d2;\n+  \n+  fn((B *)&d1, (B *)&d2);\n+  return 0;\n+}"}]}