{"sha": "44c85722dc6499c65264d1d45ffe01701053b067", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRjODU3MjJkYzY0OTljNjUyNjRkMWQ0NWZmZTAxNzAxMDUzYjA2Nw==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-02-27T18:08:40Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-02-29T17:40:39Z"}, "message": "libstdc++ Hastable: Move std::is_permutation to limit includes\n\nMove std::is_permutation algorithm with associated helpers to stl_algobase.h\nto remove stl_algo.h include from hashtable_policy.h and so reduce preprocess\nsize of unordered_map and unordered_set headers.\n\n\t* include/bits/stl_algo.h\n\t(__find_if, __count_if, __is_permutation, std::is_permutation): Move...\n\t* include/bits/stl_algobase.h: ...here.\n\t* include/bits/hashtable_policy.h: Remove <bits/stl_algo.h> include.", "tree": {"sha": "a2cfdfbb6fd32419e811e848829cd19601f08ccf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2cfdfbb6fd32419e811e848829cd19601f08ccf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44c85722dc6499c65264d1d45ffe01701053b067", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44c85722dc6499c65264d1d45ffe01701053b067", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44c85722dc6499c65264d1d45ffe01701053b067", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44c85722dc6499c65264d1d45ffe01701053b067/comments", "author": null, "committer": null, "parents": [{"sha": "68a1a11fad06fed89c9cc53c247fea3cc8bb7cc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68a1a11fad06fed89c9cc53c247fea3cc8bb7cc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68a1a11fad06fed89c9cc53c247fea3cc8bb7cc8"}], "stats": {"total": 313, "additions": 161, "deletions": 152}, "files": [{"sha": "34615413280bc37aa71dd4e9e976276ce5b5a766", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c85722dc6499c65264d1d45ffe01701053b067/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c85722dc6499c65264d1d45ffe01701053b067/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=44c85722dc6499c65264d1d45ffe01701053b067", "patch": "@@ -1,3 +1,10 @@\n+2020-02-29  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/stl_algo.h\n+\t(__find_if, __count_if, __is_permutation, std::is_permutation): Move...\n+\t* include/bits/stl_algobase.h: ...here.\n+\t* include/bits/hashtable_policy.h: Remove <bits/stl_algo.h> include.\n+\n 2020-02-29  John David Anglin  <danglin@gcc.gnu.org>\n \n \t* testsuite/30_threads/stop_token/stop_callback.cc: Add libatomic"}, {"sha": "ef120134914df26ef594613b236bee57e185f5df", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c85722dc6499c65264d1d45ffe01701053b067/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c85722dc6499c65264d1d45ffe01701053b067/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=44c85722dc6499c65264d1d45ffe01701053b067", "patch": "@@ -33,8 +33,7 @@\n \n #include <tuple>\t\t// for std::tuple, std::forward_as_tuple\n #include <limits>\t\t// for std::numeric_limits\n-#include <bits/stl_algobase.h>\t// for std::min.\n-#include <bits/stl_algo.h>\t// for std::is_permutation.\n+#include <bits/stl_algobase.h>\t// for std::min, std::is_permutation.\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {"}, {"sha": "932ece555293ddf96f9fb638ac46b83a7c508b49", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 0, "deletions": 150, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c85722dc6499c65264d1d45ffe01701053b067/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c85722dc6499c65264d1d45ffe01701053b067/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=44c85722dc6499c65264d1d45ffe01701053b067", "patch": "@@ -96,76 +96,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tstd::iter_swap(__result, __b);\n     }\n \n-  /// This is an overload used by find algos for the Input Iterator case.\n-  template<typename _InputIterator, typename _Predicate>\n-    _GLIBCXX20_CONSTEXPR\n-    inline _InputIterator\n-    __find_if(_InputIterator __first, _InputIterator __last,\n-\t      _Predicate __pred, input_iterator_tag)\n-    {\n-      while (__first != __last && !__pred(__first))\n-\t++__first;\n-      return __first;\n-    }\n-\n-  /// This is an overload used by find algos for the RAI case.\n-  template<typename _RandomAccessIterator, typename _Predicate>\n-    _GLIBCXX20_CONSTEXPR\n-    _RandomAccessIterator\n-    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,\n-\t      _Predicate __pred, random_access_iterator_tag)\n-    {\n-      typename iterator_traits<_RandomAccessIterator>::difference_type\n-\t__trip_count = (__last - __first) >> 2;\n-\n-      for (; __trip_count > 0; --__trip_count)\n-\t{\n-\t  if (__pred(__first))\n-\t    return __first;\n-\t  ++__first;\n-\n-\t  if (__pred(__first))\n-\t    return __first;\n-\t  ++__first;\n-\n-\t  if (__pred(__first))\n-\t    return __first;\n-\t  ++__first;\n-\n-\t  if (__pred(__first))\n-\t    return __first;\n-\t  ++__first;\n-\t}\n-\n-      switch (__last - __first)\n-\t{\n-\tcase 3:\n-\t  if (__pred(__first))\n-\t    return __first;\n-\t  ++__first;\n-\tcase 2:\n-\t  if (__pred(__first))\n-\t    return __first;\n-\t  ++__first;\n-\tcase 1:\n-\t  if (__pred(__first))\n-\t    return __first;\n-\t  ++__first;\n-\tcase 0:\n-\tdefault:\n-\t  return __last;\n-\t}\n-    }\n-\n-  template<typename _Iterator, typename _Predicate>\n-    _GLIBCXX20_CONSTEXPR\n-    inline _Iterator\n-    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)\n-    {\n-      return __find_if(__first, __last, __pred,\n-\t\t       std::__iterator_category(__first));\n-    }\n-\n   /// Provided for stable_partition to use.\n   template<typename _InputIterator, typename _Predicate>\n     _GLIBCXX20_CONSTEXPR\n@@ -3279,18 +3209,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t      __new_value);\n     }\n \n-  template<typename _InputIterator, typename _Predicate>\n-    _GLIBCXX20_CONSTEXPR\n-    typename iterator_traits<_InputIterator>::difference_type\n-    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n-    {\n-      typename iterator_traits<_InputIterator>::difference_type __n = 0;\n-      for (; __first != __last; ++__first)\n-\tif (__pred(__first))\n-\t  ++__n;\n-      return __n;\n-    }\n-\n #if __cplusplus >= 201103L\n   /**\n    *  @brief  Determines whether the elements of a sequence are sorted.\n@@ -3588,74 +3506,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return std::make_pair(*__p.first, *__p.second);\n     }\n \n-  template<typename _ForwardIterator1, typename _ForwardIterator2,\n-\t   typename _BinaryPredicate>\n-    _GLIBCXX20_CONSTEXPR\n-    bool\n-    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n-\t\t     _ForwardIterator2 __first2, _BinaryPredicate __pred)\n-    {\n-      // Efficiently compare identical prefixes:  O(N) if sequences\n-      // have the same elements in the same order.\n-      for (; __first1 != __last1; ++__first1, (void)++__first2)\n-\tif (!__pred(__first1, __first2))\n-\t  break;\n-\n-      if (__first1 == __last1)\n-\treturn true;\n-\n-      // Establish __last2 assuming equal ranges by iterating over the\n-      // rest of the list.\n-      _ForwardIterator2 __last2 = __first2;\n-      std::advance(__last2, std::distance(__first1, __last1));\n-      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)\n-\t{\n-\t  if (__scan != std::__find_if(__first1, __scan,\n-\t\t\t  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))\n-\t    continue; // We've seen this one before.\n-\t  \n-\t  auto __matches\n-\t    = std::__count_if(__first2, __last2,\n-\t\t\t__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));\n-\t  if (0 == __matches ||\n-\t      std::__count_if(__scan, __last1,\n-\t\t\t__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))\n-\t      != __matches)\n-\t    return false;\n-\t}\n-      return true;\n-    }\n-\n-  /**\n-   *  @brief  Checks whether a permutation of the second sequence is equal\n-   *          to the first sequence.\n-   *  @ingroup non_mutating_algorithms\n-   *  @param  __first1  Start of first range.\n-   *  @param  __last1   End of first range.\n-   *  @param  __first2  Start of second range.\n-   *  @return true if there exists a permutation of the elements in the range\n-   *          [__first2, __first2 + (__last1 - __first1)), beginning with \n-   *          ForwardIterator2 begin, such that equal(__first1, __last1, begin)\n-   *          returns true; otherwise, returns false.\n-  */\n-  template<typename _ForwardIterator1, typename _ForwardIterator2>\n-    _GLIBCXX20_CONSTEXPR\n-    inline bool\n-    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n-\t\t   _ForwardIterator2 __first2)\n-    {\n-      // concept requirements\n-      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)\n-      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)\n-      __glibcxx_function_requires(_EqualOpConcept<\n-\t\ttypename iterator_traits<_ForwardIterator1>::value_type,\n-\t\ttypename iterator_traits<_ForwardIterator2>::value_type>)\n-      __glibcxx_requires_valid_range(__first1, __last1);\n-\n-      return std::__is_permutation(__first1, __last1, __first2,\n-\t\t\t\t   __gnu_cxx::__ops::__iter_equal_to_iter());\n-    }\n-\n   /**\n    *  @brief  Checks whether a permutation of the second sequence is equal\n    *          to the first sequence."}, {"sha": "5ec2f25424db71871d6388641ca21fd5cc9dcd94", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44c85722dc6499c65264d1d45ffe01701053b067/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44c85722dc6499c65264d1d45ffe01701053b067/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=44c85722dc6499c65264d1d45ffe01701053b067", "patch": "@@ -1899,6 +1899,159 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n #endif\n \n _GLIBCXX_END_NAMESPACE_ALGO\n+\n+  /// This is an overload used by find algos for the Input Iterator case.\n+  template<typename _InputIterator, typename _Predicate>\n+    _GLIBCXX20_CONSTEXPR\n+    inline _InputIterator\n+    __find_if(_InputIterator __first, _InputIterator __last,\n+\t      _Predicate __pred, input_iterator_tag)\n+    {\n+      while (__first != __last && !__pred(__first))\n+\t++__first;\n+      return __first;\n+    }\n+\n+  /// This is an overload used by find algos for the RAI case.\n+  template<typename _RandomAccessIterator, typename _Predicate>\n+    _GLIBCXX20_CONSTEXPR\n+    _RandomAccessIterator\n+    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,\n+\t      _Predicate __pred, random_access_iterator_tag)\n+    {\n+      typename iterator_traits<_RandomAccessIterator>::difference_type\n+\t__trip_count = (__last - __first) >> 2;\n+\n+      for (; __trip_count > 0; --__trip_count)\n+\t{\n+\t  if (__pred(__first))\n+\t    return __first;\n+\t  ++__first;\n+\n+\t  if (__pred(__first))\n+\t    return __first;\n+\t  ++__first;\n+\n+\t  if (__pred(__first))\n+\t    return __first;\n+\t  ++__first;\n+\n+\t  if (__pred(__first))\n+\t    return __first;\n+\t  ++__first;\n+\t}\n+\n+      switch (__last - __first)\n+\t{\n+\tcase 3:\n+\t  if (__pred(__first))\n+\t    return __first;\n+\t  ++__first;\n+\tcase 2:\n+\t  if (__pred(__first))\n+\t    return __first;\n+\t  ++__first;\n+\tcase 1:\n+\t  if (__pred(__first))\n+\t    return __first;\n+\t  ++__first;\n+\tcase 0:\n+\tdefault:\n+\t  return __last;\n+\t}\n+    }\n+\n+  template<typename _Iterator, typename _Predicate>\n+    _GLIBCXX20_CONSTEXPR\n+    inline _Iterator\n+    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)\n+    {\n+      return __find_if(__first, __last, __pred,\n+\t\t       std::__iterator_category(__first));\n+    }\n+\n+  template<typename _InputIterator, typename _Predicate>\n+    _GLIBCXX20_CONSTEXPR\n+    typename iterator_traits<_InputIterator>::difference_type\n+    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n+    {\n+      typename iterator_traits<_InputIterator>::difference_type __n = 0;\n+      for (; __first != __last; ++__first)\n+\tif (__pred(__first))\n+\t  ++__n;\n+      return __n;\n+    }\n+\n+#if __cplusplus >= 201103L\n+  template<typename _ForwardIterator1, typename _ForwardIterator2,\n+\t   typename _BinaryPredicate>\n+    _GLIBCXX20_CONSTEXPR\n+    bool\n+    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+\t\t     _ForwardIterator2 __first2, _BinaryPredicate __pred)\n+    {\n+      // Efficiently compare identical prefixes:  O(N) if sequences\n+      // have the same elements in the same order.\n+      for (; __first1 != __last1; ++__first1, (void)++__first2)\n+\tif (!__pred(__first1, __first2))\n+\t  break;\n+\n+      if (__first1 == __last1)\n+\treturn true;\n+\n+      // Establish __last2 assuming equal ranges by iterating over the\n+      // rest of the list.\n+      _ForwardIterator2 __last2 = __first2;\n+      std::advance(__last2, std::distance(__first1, __last1));\n+      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)\n+\t{\n+\t  if (__scan != std::__find_if(__first1, __scan,\n+\t\t\t  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))\n+\t    continue; // We've seen this one before.\n+\n+\t  auto __matches\n+\t    = std::__count_if(__first2, __last2,\n+\t\t\t__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));\n+\t  if (0 == __matches ||\n+\t      std::__count_if(__scan, __last1,\n+\t\t\t__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))\n+\t      != __matches)\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+\n+  /**\n+   *  @brief  Checks whether a permutation of the second sequence is equal\n+   *          to the first sequence.\n+   *  @ingroup non_mutating_algorithms\n+   *  @param  __first1  Start of first range.\n+   *  @param  __last1   End of first range.\n+   *  @param  __first2  Start of second range.\n+   *  @return true if there exists a permutation of the elements in the range\n+   *          [__first2, __first2 + (__last1 - __first1)), beginning with\n+   *          ForwardIterator2 begin, such that equal(__first1, __last1, begin)\n+   *          returns true; otherwise, returns false.\n+  */\n+  template<typename _ForwardIterator1, typename _ForwardIterator2>\n+    _GLIBCXX20_CONSTEXPR\n+    inline bool\n+    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+\t\t   _ForwardIterator2 __first2)\n+    {\n+      // concept requirements\n+      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)\n+      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)\n+      __glibcxx_function_requires(_EqualOpConcept<\n+\t\ttypename iterator_traits<_ForwardIterator1>::value_type,\n+\t\ttypename iterator_traits<_ForwardIterator2>::value_type>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n+\n+      return std::__is_permutation(__first1, __last1, __first2,\n+\t\t\t\t   __gnu_cxx::__ops::__iter_equal_to_iter());\n+    }\n+#endif // C++11\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n "}]}