{"sha": "6699b754e1e0464109d8f7dc163ba245ec59c881", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY5OWI3NTRlMWUwNDY0MTA5ZDhmN2RjMTYzYmEyNDVlYzU5Yzg4MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-10-14T07:17:54Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-10-14T07:17:54Z"}, "message": "cse.c (is_dead_reg): Change into inline function that is not called through for_each_rtx.\n\n\t* cse.c (is_dead_reg): Change into inline function that is not\n\tcalled through for_each_rtx.\n\t(set_live_p): Adjust caller.\n\t(insn_live_p): Don't reset DEBUG_INSNs here.\n\t(struct dead_debug_insn_data): New data. \n\t(count_stores, is_dead_debug_insn, replace_dead_reg): New functions.\n\t(delete_trivially_dead_insns): If there is just one setter for the\n\tdead reg that is referenced by some DEBUG_INSNs, create a DEBUG_EXPR\n\tand add DEBUG_INSN for it right before the removed setter and\n\tuse the DEBUG_EXPR instead of the dead pseudo.\n\nFrom-SVN: r165452", "tree": {"sha": "4c0b4bb96185a3d569106623c3fc4e30cfc0e171", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c0b4bb96185a3d569106623c3fc4e30cfc0e171"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6699b754e1e0464109d8f7dc163ba245ec59c881", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6699b754e1e0464109d8f7dc163ba245ec59c881", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6699b754e1e0464109d8f7dc163ba245ec59c881", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6699b754e1e0464109d8f7dc163ba245ec59c881/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d2e60b7bc2c690b1572072dcac73fbdcc8b15677", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2e60b7bc2c690b1572072dcac73fbdcc8b15677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2e60b7bc2c690b1572072dcac73fbdcc8b15677"}], "stats": {"total": 205, "additions": 180, "deletions": 25}, "files": [{"sha": "769074fe020b604be7530f099d8eda2f0afbdc65", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6699b754e1e0464109d8f7dc163ba245ec59c881/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6699b754e1e0464109d8f7dc163ba245ec59c881/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6699b754e1e0464109d8f7dc163ba245ec59c881", "patch": "@@ -1,4 +1,18 @@\n+2010-10-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cse.c (is_dead_reg): Change into inline function that is not\n+\tcalled through for_each_rtx.\n+\t(set_live_p): Adjust caller.\n+\t(insn_live_p): Don't reset DEBUG_INSNs here.\n+\t(struct dead_debug_insn_data): New data. \n+\t(count_stores, is_dead_debug_insn, replace_dead_reg): New functions.\n+\t(delete_trivially_dead_insns): If there is just one setter for the\n+\tdead reg that is referenced by some DEBUG_INSNs, create a DEBUG_EXPR\n+\tand add DEBUG_INSN for it right before the removed setter and\n+\tuse the DEBUG_EXPR instead of the dead pseudo.\n+\n 2010-10-14  Zdenek Dvorak  <rakdver@kam.uniff.cz>\n+\n \t* et-forest.c (et_nca): Return NULL immediately when\n \tthe dominance forest has disjoint components.\n "}, {"sha": "3ab6b37a8ea99f51cad920714aa7f161ceff7884", "filename": "gcc/cse.c", "status": "modified", "additions": 166, "deletions": 25, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6699b754e1e0464109d8f7dc163ba245ec59c881/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6699b754e1e0464109d8f7dc163ba245ec59c881/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=6699b754e1e0464109d8f7dc163ba245ec59c881", "patch": "@@ -1,6 +1,6 @@\n /* Common subexpression elimination for GNU compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -6698,14 +6698,11 @@ count_reg_usage (rtx x, int *counts, rtx dest, int incr)\n     }\n }\n \f\n-/* Return true if a register is dead.  Can be used in for_each_rtx.  */\n+/* Return true if X is a dead register.  */\n \n-static int\n-is_dead_reg (rtx *loc, void *data)\n+static inline int\n+is_dead_reg (rtx x, int *counts)\n {\n-  rtx x = *loc;\n-  int *counts = (int *)data;\n-\n   return (REG_P (x)\n \t  && REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t  && counts[REGNO (x)] == 0);\n@@ -6731,7 +6728,7 @@ set_live_p (rtx set, rtx insn ATTRIBUTE_UNUSED, /* Only used with HAVE_cc0.  */\n \t       || !reg_referenced_p (cc0_rtx, PATTERN (tem))))\n     return false;\n #endif\n-  else if (!is_dead_reg (&SET_DEST (set), counts)\n+  else if (!is_dead_reg (SET_DEST (set), counts)\n \t   || side_effects_p (SET_SRC (set)))\n     return true;\n   return false;\n@@ -6775,21 +6772,68 @@ insn_live_p (rtx insn, int *counts)\n \telse if (INSN_VAR_LOCATION_DECL (insn) == INSN_VAR_LOCATION_DECL (next))\n \t  return false;\n \n-      /* If this debug insn references a dead register, drop the\n-\t location expression for now.  ??? We could try to find the\n-\t def and see if propagation is possible.  */\n-      if (for_each_rtx (&INSN_VAR_LOCATION_LOC (insn), is_dead_reg, counts))\n-\t{\n-\t  INSN_VAR_LOCATION_LOC (insn) = gen_rtx_UNKNOWN_VAR_LOC ();\n-\t  df_insn_rescan (insn);\n-\t}\n-\n       return true;\n     }\n   else\n     return true;\n }\n \n+/* Count the number of stores into pseudo.  Callback for note_stores.  */\n+\n+static void\n+count_stores (rtx x, const_rtx set ATTRIBUTE_UNUSED, void *data)\n+{\n+  int *counts = (int *) data;\n+  if (REG_P (x) && REGNO (x) >= FIRST_PSEUDO_REGISTER)\n+    counts[REGNO (x)]++;\n+}\n+\n+struct dead_debug_insn_data\n+{\n+  int *counts;\n+  rtx *replacements;\n+  bool seen_repl;\n+};\n+\n+/* Return if a DEBUG_INSN needs to be reset because some dead\n+   pseudo doesn't have a replacement.  Callback for for_each_rtx.  */\n+\n+static int\n+is_dead_debug_insn (rtx *loc, void *data)\n+{\n+  rtx x = *loc;\n+  struct dead_debug_insn_data *ddid = (struct dead_debug_insn_data *) data;\n+\n+  if (is_dead_reg (x, ddid->counts))\n+    {\n+      if (ddid->replacements && ddid->replacements[REGNO (x)] != NULL_RTX)\n+\tddid->seen_repl = true;\n+      else\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+/* Replace a dead pseudo in a DEBUG_INSN with replacement DEBUG_EXPR.\n+   Callback for simplify_replace_fn_rtx.  */\n+\n+static rtx\n+replace_dead_reg (rtx x, const_rtx old_rtx ATTRIBUTE_UNUSED, void *data)\n+{\n+  rtx *replacements = (rtx *) data;\n+\n+  if (REG_P (x)\n+      && REGNO (x) >= FIRST_PSEUDO_REGISTER\n+      && replacements[REGNO (x)] != NULL_RTX)\n+    {\n+      if (GET_MODE (x) == GET_MODE (replacements[REGNO (x)]))\n+\treturn replacements[REGNO (x)];\n+      return lowpart_subreg (GET_MODE (x), replacements[REGNO (x)],\n+\t\t\t     GET_MODE (replacements[REGNO (x)]));\n+    }\n+  return NULL_RTX;\n+}\n+\n /* Scan all the insns and delete any that are dead; i.e., they store a register\n    that is never used or they copy a register to itself.\n \n@@ -6803,22 +6847,51 @@ delete_trivially_dead_insns (rtx insns, int nreg)\n {\n   int *counts;\n   rtx insn, prev;\n+  rtx *replacements = NULL;\n   int ndead = 0;\n \n   timevar_push (TV_DELETE_TRIVIALLY_DEAD);\n   /* First count the number of times each register is used.  */\n-  counts = XCNEWVEC (int, nreg);\n-  for (insn = insns; insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn))\n-      count_reg_usage (insn, counts, NULL_RTX, 1);\n-\n+  if (MAY_HAVE_DEBUG_INSNS)\n+    {\n+      counts = XCNEWVEC (int, nreg * 3);\n+      for (insn = insns; insn; insn = NEXT_INSN (insn))\n+\tif (DEBUG_INSN_P (insn))\n+\t  count_reg_usage (INSN_VAR_LOCATION_LOC (insn), counts + nreg,\n+\t\t\t   NULL_RTX, 1);\n+\telse if (INSN_P (insn))\n+\t  {\n+\t    count_reg_usage (insn, counts, NULL_RTX, 1);\n+\t    note_stores (PATTERN (insn), count_stores, counts + nreg * 2);\n+\t  }\n+      /* If there can be debug insns, COUNTS are 3 consecutive arrays.\n+\t First one counts how many times each pseudo is used outside\n+\t of debug insns, second counts how many times each pseudo is\n+\t used in debug insns and third counts how many times a pseudo\n+\t is stored.  */\n+    }\n+  else\n+    {\n+      counts = XCNEWVEC (int, nreg);\n+      for (insn = insns; insn; insn = NEXT_INSN (insn))\n+\tif (INSN_P (insn))\n+\t  count_reg_usage (insn, counts, NULL_RTX, 1);\n+      /* If no debug insns can be present, COUNTS is just an array\n+\t which counts how many times each pseudo is used.  */\n+    }\n   /* Go from the last insn to the first and delete insns that only set unused\n      registers or copy a register to itself.  As we delete an insn, remove\n      usage counts for registers it uses.\n \n      The first jump optimization pass may leave a real insn as the last\n      insn in the function.   We must not skip that insn or we may end\n-     up deleting code that is not really dead.  */\n+     up deleting code that is not really dead.\n+\n+     If some otherwise unused register is only used in DEBUG_INSNs,\n+     try to create a DEBUG_EXPR temporary and emit a DEBUG_INSN before\n+     the setter.  Then go through DEBUG_INSNs and if a DEBUG_EXPR\n+     has been created for the unused register, replace it with\n+     the DEBUG_EXPR, otherwise reset the DEBUG_INSN.  */\n   for (insn = get_last_insn (); insn; insn = prev)\n     {\n       int live_insn = 0;\n@@ -6834,12 +6907,80 @@ delete_trivially_dead_insns (rtx insns, int nreg)\n \n       if (! live_insn && dbg_cnt (delete_trivial_dead))\n \t{\n-\t  count_reg_usage (insn, counts, NULL_RTX, -1);\n+\t  if (DEBUG_INSN_P (insn))\n+\t    count_reg_usage (INSN_VAR_LOCATION_LOC (insn), counts + nreg,\n+\t\t\t     NULL_RTX, -1);\n+\t  else\n+\t    {\n+\t      rtx set;\n+\t      if (MAY_HAVE_DEBUG_INSNS\n+\t\t  && (set = single_set (insn)) != NULL_RTX\n+\t\t  && is_dead_reg (SET_DEST (set), counts)\n+\t\t  /* Used at least once in some DEBUG_INSN.  */\n+\t\t  && counts[REGNO (SET_DEST (set)) + nreg] > 0\n+\t\t  /* And set exactly once.  */\n+\t\t  && counts[REGNO (SET_DEST (set)) + nreg * 2] == 1\n+\t\t  && !side_effects_p (SET_SRC (set))\n+\t\t  && asm_noperands (PATTERN (insn)) < 0)\n+\t\t{\n+\t\t  rtx dval, bind;\n+\n+\t\t  /* Create DEBUG_EXPR (and DEBUG_EXPR_DECL).  */\n+\t\t  dval = make_debug_expr_from_rtl (SET_DEST (set));\n+\n+\t\t  /* Emit a debug bind insn before the insn in which\n+\t\t     reg dies.  */\n+\t\t  bind = gen_rtx_VAR_LOCATION (GET_MODE (SET_DEST (set)),\n+\t\t\t\t\t       DEBUG_EXPR_TREE_DECL (dval),\n+\t\t\t\t\t       SET_SRC (set),\n+\t\t\t\t\t       VAR_INIT_STATUS_INITIALIZED);\n+\t\t  count_reg_usage (bind, counts + nreg, NULL_RTX, 1);\n+\n+\t\t  bind = emit_debug_insn_before (bind, insn);\n+\t\t  df_insn_rescan (bind);\n+\n+\t\t  if (replacements == NULL)\n+\t\t    replacements = XCNEWVEC (rtx, nreg);\n+\t\t  replacements[REGNO (SET_DEST (set))] = dval;\n+\t\t}\n+\n+\t      count_reg_usage (insn, counts, NULL_RTX, -1);\n+\t      ndead++;\n+\t    }\n \t  delete_insn_and_edges (insn);\n-\t  ndead++;\n \t}\n     }\n \n+  if (MAY_HAVE_DEBUG_INSNS)\n+    {\n+      struct dead_debug_insn_data ddid;\n+      ddid.counts = counts;\n+      ddid.replacements = replacements;\n+      for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n+\tif (DEBUG_INSN_P (insn))\n+\t  {\n+\t    /* If this debug insn references a dead register that wasn't replaced\n+\t       with an DEBUG_EXPR, reset the DEBUG_INSN.  */\n+\t    ddid.seen_repl = false;\n+\t    if (for_each_rtx (&INSN_VAR_LOCATION_LOC (insn),\n+\t\t\t      is_dead_debug_insn, &ddid))\n+\t      {\n+\t\tINSN_VAR_LOCATION_LOC (insn) = gen_rtx_UNKNOWN_VAR_LOC ();\n+\t\tdf_insn_rescan (insn);\n+\t      }\n+\t    else if (ddid.seen_repl)\n+\t      {\n+\t\tINSN_VAR_LOCATION_LOC (insn)\n+\t\t  = simplify_replace_fn_rtx (INSN_VAR_LOCATION_LOC (insn),\n+\t\t\t\t\t     NULL_RTX, replace_dead_reg,\n+\t\t\t\t\t     replacements);\n+\t\tdf_insn_rescan (insn);\n+\t      }\n+\t  }\n+      if (replacements)\n+\tfree (replacements);\n+    }\n+\n   if (dump_file && ndead)\n     fprintf (dump_file, \"Deleted %i trivially dead insns\\n\",\n \t     ndead);"}]}