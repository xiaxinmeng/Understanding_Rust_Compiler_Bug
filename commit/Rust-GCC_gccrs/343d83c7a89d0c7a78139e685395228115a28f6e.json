{"sha": "343d83c7a89d0c7a78139e685395228115a28f6e", "node_id": "C_kwDOANBUbNoAKDM0M2Q4M2M3YTg5ZDBjN2E3ODEzOWU2ODUzOTUyMjgxMTVhMjhmNmU", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-06-10T20:10:02Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-06-10T20:10:02Z"}, "message": "c++: improve TYPENAME_TYPE hashing [PR65328]\n\nFor the testcase in this PR, compilation takes very long ultimately due\nto our poor hashing of TYPENAME_TYPE causing a huge number of collisions\nin the spec_hasher and typename_hasher tables.\n\nIn spec_hasher, we don't hash the components of TYPENAME_TYPE, which\nmeans most TYPENAME_TYPE arguments end up contributing the same hash.\nThis is the safe thing to do uniformly since structural_comptypes may\ntry resolving a TYPENAME_TYPE via the current instantiation.  But this\nbehavior of structural_comptypes is suppressed from spec_hasher::equal\nvia the comparing_specializations flag, which means spec_hasher::hash\ncan assume it's disabled too.  To that end, this patch makes\nspec_hasher::hash set the flag, and teaches iterative_hash_template_arg\nto hash the relevant components of TYPENAME_TYPE when the flag is set.\n\nAnd in typename_hasher, the hash function considers TYPE_IDENTIFIER\ninstead of the more informative TYPENAME_TYPE_FULLNAME, which this patch\nfixes accordingly.\n\nAfter this patch, compile time for the testcase in the PR falls to\naround 30 seconds on my machine (down from dozens of minutes).\n\n\tPR c++/65328\n\ngcc/cp/ChangeLog:\n\n\t* decl.cc (typename_hasher::hash): Add extra overloads.\n\tUse iterative_hash_object instead of htab_hash_pointer.\n\tHash TYPENAME_TYPE_FULLNAME instead of TYPE_IDENTIFIER.\n\t(build_typename_type): Use typename_hasher::hash.\n\t* pt.cc (spec_hasher::hash): Add two-parameter overload.\n\tSet comparing_specializations around the call to\n\thash_tmpl_and_args.\n\t(iterative_hash_template_arg) <case TYPENAME_TYPE>:\n\tWhen comparing_specializations, hash the TYPE_CONTEXT\n\tand TYPENAME_TYPE_FULLNAME.\n\t(tsubst_function_decl): Use spec_hasher::hash instead of\n\thash_tmpl_and_args.\n\t(tsubst_template_decl): Likewise.\n\t(tsubst_decl): Likewise.", "tree": {"sha": "02edb30bfdeb86b266f5d303c363282fa5b894ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02edb30bfdeb86b266f5d303c363282fa5b894ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/343d83c7a89d0c7a78139e685395228115a28f6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/343d83c7a89d0c7a78139e685395228115a28f6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/343d83c7a89d0c7a78139e685395228115a28f6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/343d83c7a89d0c7a78139e685395228115a28f6e/comments", "author": null, "committer": null, "parents": [{"sha": "f9b5a8e58dfd0642bea932d449ad46da9e57396f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9b5a8e58dfd0642bea932d449ad46da9e57396f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9b5a8e58dfd0642bea932d449ad46da9e57396f"}], "stats": {"total": 56, "additions": 45, "deletions": 11}, "files": [{"sha": "29fc36534c2f512119fea969a4a960c9e9e17d9f", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/343d83c7a89d0c7a78139e685395228115a28f6e/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/343d83c7a89d0c7a78139e685395228115a28f6e/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=343d83c7a89d0c7a78139e685395228115a28f6e", "patch": "@@ -4007,14 +4007,24 @@ struct typename_hasher : ggc_ptr_hash<tree_node>\n   /* Hash a TYPENAME_TYPE.  */\n \n   static hashval_t\n-  hash (tree t)\n+  hash (tree context, tree fullname)\n   {\n-    hashval_t hash;\n+    hashval_t hash = 0;\n+    hash = iterative_hash_object (context, hash);\n+    hash = iterative_hash_object (fullname, hash);\n+    return hash;\n+  }\n \n-    hash = (htab_hash_pointer (TYPE_CONTEXT (t))\n-\t    ^ htab_hash_pointer (TYPE_IDENTIFIER (t)));\n+  static hashval_t\n+  hash (const typename_info *ti)\n+  {\n+    return typename_hasher::hash (ti->scope, ti->template_id);\n+  }\n \n-    return hash;\n+  static hashval_t\n+  hash (tree t)\n+  {\n+    return typename_hasher::hash (TYPE_CONTEXT (t), TYPENAME_TYPE_FULLNAME (t));\n   }\n \n   /* Compare two TYPENAME_TYPEs.  */\n@@ -4053,8 +4063,7 @@ build_typename_type (tree context, tree name, tree fullname,\n   ti.class_p = (tag_type == class_type\n \t\t|| tag_type == record_type\n \t\t|| tag_type == union_type);\n-  hashval_t hash =  (htab_hash_pointer (ti.scope)\n-\t\t     ^ htab_hash_pointer (ti.name));\n+  hashval_t hash = typename_hasher::hash (&ti);\n \n   /* See if we already have this type.  */\n   tree *e = typename_htab->find_slot_with_hash (&ti, hash, INSERT);"}, {"sha": "28edc6ae9886cb41e0825e7911c9ff504be2bcbf", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/343d83c7a89d0c7a78139e685395228115a28f6e/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/343d83c7a89d0c7a78139e685395228115a28f6e/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=343d83c7a89d0c7a78139e685395228115a28f6e", "patch": "@@ -106,6 +106,7 @@ static bool excessive_deduction_depth;\n \n struct spec_hasher : ggc_ptr_hash<spec_entry>\n {\n+  static hashval_t hash (tree, tree);\n   static hashval_t hash (spec_entry *);\n   static bool equal (spec_entry *, spec_entry *);\n };\n@@ -1768,13 +1769,22 @@ hash_tmpl_and_args (tree tmpl, tree args)\n   return iterative_hash_template_arg (args, val);\n }\n \n+hashval_t\n+spec_hasher::hash (tree tmpl, tree args)\n+{\n+  ++comparing_specializations;\n+  hashval_t val = hash_tmpl_and_args (tmpl, args);\n+  --comparing_specializations;\n+  return val;\n+}\n+\n /* Returns a hash for a spec_entry node based on the TMPL and ARGS members,\n    ignoring SPEC.  */\n \n hashval_t\n spec_hasher::hash (spec_entry *e)\n {\n-  return hash_tmpl_and_args (e->tmpl, e->args);\n+  return spec_hasher::hash (e->tmpl, e->args);\n }\n \n /* Recursively calculate a hash value for a template argument ARG, for use\n@@ -1960,6 +1970,21 @@ iterative_hash_template_arg (tree arg, hashval_t val)\n \t  val = iterative_hash_template_arg (DECLTYPE_TYPE_EXPR (arg), val);\n \t  break;\n \n+\tcase TYPENAME_TYPE:\n+\t  if (comparing_specializations)\n+\t    {\n+\t      /* Hash the components that are relevant to TYPENAME_TYPE\n+\t\t equivalence as determined by structural_comptypes.  We\n+\t\t can only coherently do this when comparing_specializations\n+\t\t is set, because otherwise structural_comptypes tries\n+\t\t resolving TYPENAME_TYPE via the current instantiation.  */\n+\t      tree context = TYPE_MAIN_VARIANT (TYPE_CONTEXT (arg));\n+\t      tree fullname = TYPENAME_TYPE_FULLNAME (arg);\n+\t      val = iterative_hash_template_arg (context, val);\n+\t      val = iterative_hash_template_arg (fullname, val);\n+\t    }\n+\t  break;\n+\n \tdefault:\n \t  if (tree canonical = TYPE_CANONICAL (arg))\n \t    val = iterative_hash_object (TYPE_HASH (canonical), val);\n@@ -14116,7 +14141,7 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,\n       /* Check to see if we already have this specialization.  */\n       if (!lambda_fntype)\n \t{\n-\t  hash = hash_tmpl_and_args (gen_tmpl, argvec);\n+\t  hash = spec_hasher::hash (gen_tmpl, argvec);\n \t  if (tree spec = retrieve_specialization (gen_tmpl, argvec, hash))\n \t    /* The spec for these args might be a partial instantiation of the\n \t       template, but here what we want is the FUNCTION_DECL.  */\n@@ -14419,7 +14444,7 @@ tsubst_template_decl (tree t, tree args, tsubst_flags_t complain,\n       if (full_args == tmpl_args)\n \treturn t;\n \n-      hash = hash_tmpl_and_args (t, full_args);\n+      hash = spec_hasher::hash (t, full_args);\n       spec = retrieve_specialization (t, full_args, hash);\n       if (spec != NULL_TREE)\n \t{\n@@ -14963,7 +14988,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t\t    if (argvec == error_mark_node)\n \t\t      RETURN (error_mark_node);\n \t\t  }\n-\t\thash = hash_tmpl_and_args (gen_tmpl, argvec);\n+\t\thash = spec_hasher::hash (gen_tmpl, argvec);\n \t\tspec = retrieve_specialization (gen_tmpl, argvec, hash);\n \t      }\n \t  }"}]}