{"sha": "b3801819f495f925bc7c26f03e4e98f448423839", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM4MDE4MTlmNDk1ZjkyNWJjN2MyNmYwM2U0ZTk4ZjQ0ODQyMzgzOQ==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-12-15T11:16:14Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-12-15T11:16:14Z"}, "message": "gnat_and_program_execution.rst: Update section \"Dynamic Stack Usage Analysis\" to include more details about...\n\ngcc/ada/\n\n2017-12-15  Patrick Bernardi  <bernardi@adacore.com>\n\n\t* doc/gnat_ugn/gnat_and_program_execution.rst: Update section \"Dynamic\n\tStack Usage Analysis\" to include more details about GNAT_STACK_LIMIT.\n\n2017-12-15  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_util.adb (Add_Own_DIC): Ensure that the expression of the pragma\n\tis available (Is_Verifiable_DIC_Pragma): Moved from Sem_Util.\n\t* sem_util.adb (Has_Full_Default_Initialization):\n\tHas_Fully_Default_Initializing_DIC_Pragma is now used to determine\n\twhether a type has full default initialization due to pragma\n\tDefault_Initial_Condition.\n\t(Has_Fully_Default_Initializing_DIC_Pragma): New routine.\n\t(Is_Verifiable_DIC_Pragma): Moved to Exp_Util.\n\t* sem_util.ads (Has_Fully_Default_Initializing_DIC_Pragma): New\n\troutine.\n\t(Is_Verifiable_DIC_Pragma): Moved to Exp_Util.\n\t* sem_warn.adb (Is_OK_Fully_Initialized):\n\tHas_Fully_Default_Initializing_DIC_Pragma is now used to determine\n\twhether a type has full default initialization due to pragma\n\tDefault_Initial_Condition.\n\n2017-12-15  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Match_Constituent): Do not quietly accept constants as\n\tsuitable constituents.\n\t* exp_util.adb: Minor reformatting.\n\n2017-12-15  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_aggr.adb (In_Place_Assign_OK): Extend the predicate to recognize\n\tan array aggregate in an allocator, when the designated type is\n\tunconstrained and the upper bound of the aggregate belongs to the base\n\ttype of the index.\n\n2017-12-15  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch6.adb (Expand_N_Extended_Return_Statement,\n\tExpand_Simple_Function_Return): Assert that the b-i-p-ness of the\n\tcaller and callee match.  Otherwise, we would need some substantial\n\tchanges to allow b-i-p calls non-b-i-p, and vice versa.\n\ngcc/testsuite/\n\n2017-12-15  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* gnat.dg/dflt_init_cond.adb, gnat.dg/dflt_init_cond_pkg.ads: New\n\ttestcase.\n\nFrom-SVN: r255685", "tree": {"sha": "05bbd4a2275dcfa45bede507f65507549a26bbb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05bbd4a2275dcfa45bede507f65507549a26bbb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3801819f495f925bc7c26f03e4e98f448423839", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3801819f495f925bc7c26f03e4e98f448423839", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3801819f495f925bc7c26f03e4e98f448423839", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3801819f495f925bc7c26f03e4e98f448423839/comments", "author": null, "committer": null, "parents": [{"sha": "fe663f3750d37cc7edacd07caf5872d18f04889f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe663f3750d37cc7edacd07caf5872d18f04889f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe663f3750d37cc7edacd07caf5872d18f04889f"}], "stats": {"total": 279, "additions": 211, "deletions": 68}, "files": [{"sha": "c86b361a264183eacac40678c9f0994bc950b3a3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b3801819f495f925bc7c26f03e4e98f448423839", "patch": "@@ -1,3 +1,46 @@\n+2017-12-15  Patrick Bernardi  <bernardi@adacore.com>\n+\n+\t* doc/gnat_ugn/gnat_and_program_execution.rst: Update section \"Dynamic\n+\tStack Usage Analysis\" to include more details about GNAT_STACK_LIMIT.\n+\n+2017-12-15  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_util.adb (Add_Own_DIC): Ensure that the expression of the pragma\n+\tis available (Is_Verifiable_DIC_Pragma): Moved from Sem_Util.\n+\t* sem_util.adb (Has_Full_Default_Initialization):\n+\tHas_Fully_Default_Initializing_DIC_Pragma is now used to determine\n+\twhether a type has full default initialization due to pragma\n+\tDefault_Initial_Condition.\n+\t(Has_Fully_Default_Initializing_DIC_Pragma): New routine.\n+\t(Is_Verifiable_DIC_Pragma): Moved to Exp_Util.\n+\t* sem_util.ads (Has_Fully_Default_Initializing_DIC_Pragma): New\n+\troutine.\n+\t(Is_Verifiable_DIC_Pragma): Moved to Exp_Util.\n+\t* sem_warn.adb (Is_OK_Fully_Initialized):\n+\tHas_Fully_Default_Initializing_DIC_Pragma is now used to determine\n+\twhether a type has full default initialization due to pragma\n+\tDefault_Initial_Condition.\n+\n+2017-12-15  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Match_Constituent): Do not quietly accept constants as\n+\tsuitable constituents.\n+\t* exp_util.adb: Minor reformatting.\n+\n+2017-12-15  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_aggr.adb (In_Place_Assign_OK): Extend the predicate to recognize\n+\tan array aggregate in an allocator, when the designated type is\n+\tunconstrained and the upper bound of the aggregate belongs to the base\n+\ttype of the index.\n+\n+2017-12-15  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_N_Extended_Return_Statement,\n+\tExpand_Simple_Function_Return): Assert that the b-i-p-ness of the\n+\tcaller and callee match.  Otherwise, we would need some substantial\n+\tchanges to allow b-i-p calls non-b-i-p, and vice versa.\n+\n 2017-12-15  Ed Schonberg  <schonberg@adacore.com>\n \n \t* exp_unst.adb (Unnest_Subprograms): Nothing to do if the main unit is"}, {"sha": "6ce22f4a01ed1ee0e27e1ae76ef9befb46ca07cc", "filename": "gcc/ada/doc/gnat_ugn/gnat_and_program_execution.rst", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_and_program_execution.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_and_program_execution.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_and_program_execution.rst?ref=b3801819f495f925bc7c26f03e4e98f448423839", "patch": "@@ -3817,11 +3817,20 @@ where:\n   is not entirely analyzed, and it's not possible to know exactly how\n   much has actually been used.\n \n-The environment task stack, e.g., the stack that contains the main unit, is\n-only processed when the environment variable GNAT_STACK_LIMIT is set.\n+By default the environment task stack, the stack that contains the main unit,\n+is not processed. To enable processing of the environment task stack, the\n+environment variable GNAT_STACK_LIMIT needs to be set to the maximum size of\n+the environment task stack. This amount is given in kilobytes. For example:\n+\n+  ::\n+\n+     $ set GNAT_STACK_LIMIT 1600\n+\n+would specify to the analyzer that the environment task stack has a limit\n+of 1.6 megabytes. Any stack usage beyond this will be ignored by the analysis.\n \n The package ``GNAT.Task_Stack_Usage`` provides facilities to get\n-stack usage reports at run-time. See its body for the details.\n+stack-usage reports at run time. See its body for the details.\n \n \n "}, {"sha": "e2313f29e62bbd238e966a54140d0e036c4d02a8", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=b3801819f495f925bc7c26f03e4e98f448423839", "patch": "@@ -5537,13 +5537,29 @@ package body Exp_Aggr is\n                Get_Index_Bounds (Obj_In, Obj_Lo, Obj_Hi);\n \n                if not Compile_Time_Known_Value (Aggr_Lo)\n-                 or else not Compile_Time_Known_Value (Aggr_Hi)\n                  or else not Compile_Time_Known_Value (Obj_Lo)\n                  or else not Compile_Time_Known_Value (Obj_Hi)\n                  or else Expr_Value (Aggr_Lo) /= Expr_Value (Obj_Lo)\n-                 or else Expr_Value (Aggr_Hi) /= Expr_Value (Obj_Hi)\n                then\n                   return False;\n+\n+               --  For an assignment statement we require static matching\n+               --  of bounds. Ditto for an allocator whose qualified\n+               --  expression is a constrained type. If the expression in\n+               --  the allocator is an unconstrained array, we accept an\n+               --  upper bound that is not static, to allow for non-static\n+               --  expressions of the base type. Clearly there are further\n+               --  possibilities (with diminishing returns) for safely\n+               --  building arrays in place here.\n+\n+               elsif Nkind (Parent (N)) = N_Assignment_Statement\n+                 or else Is_Constrained (Etype (Parent (N)))\n+               then\n+                  if not Compile_Time_Known_Value (Aggr_Hi)\n+                   or else Expr_Value (Aggr_Hi) /= Expr_Value (Obj_Hi)\n+                  then\n+                     return False;\n+                  end if;\n                end if;\n \n                Next_Index (Aggr_In);"}, {"sha": "f207b5b13ddde61edab0f10edef8856d757616f5", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=b3801819f495f925bc7c26f03e4e98f448423839", "patch": "@@ -4751,6 +4751,17 @@ package body Exp_Ch6 is\n \n       if Nkind (Ret_Obj_Decl) = N_Object_Declaration then\n          Exp := Expression (Ret_Obj_Decl);\n+\n+         --  Assert that if F says \"return R : T := G(...) do...\"\n+         --  then F and G are both b-i-p, or neither b-i-p.\n+\n+         if Nkind (Exp) = N_Function_Call then\n+            pragma Assert (Ekind (Current_Scope) = E_Function);\n+            pragma Assert\n+              (Is_Build_In_Place_Function (Current_Scope) =\n+               Is_Build_In_Place_Function_Call (Exp));\n+            null;\n+         end if;\n       else\n          Exp := Empty;\n       end if;\n@@ -6446,6 +6457,17 @@ package body Exp_Ch6 is\n          end if;\n       end if;\n \n+      --  Assert that if F says \"return G(...);\"\n+      --  then F and G are both b-i-p, or neither b-i-p.\n+\n+      if Nkind (Exp) = N_Function_Call then\n+         pragma Assert (Ekind (Scope_Id) = E_Function);\n+         pragma Assert\n+           (Is_Build_In_Place_Function (Scope_Id) =\n+            Is_Build_In_Place_Function_Call (Exp));\n+         null;\n+      end if;\n+\n       --  For the case of a simple return that does not come from an\n       --  extended return, in the case of build-in-place, we rewrite\n       --  \"return <expression>;\" to be:\n@@ -7095,8 +7117,6 @@ package body Exp_Ch6 is\n                         return Empty;\n                      end Associated_Expr;\n \n-                  --  Start of processing for Expand_Simple_Function_Return\n-\n                   begin\n                      if not Positionals_Exhausted then\n                         Disc_Exp := First (Expressions (Discrim_Source));"}, {"sha": "a4797c7e6db7ab7527741150e7dda2f48d1fbbfd", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=b3801819f495f925bc7c26f03e4e98f448423839", "patch": "@@ -165,6 +165,10 @@ package body Exp_Util is\n    --  Force evaluation of bounds of a slice, which may be given by a range\n    --  or by a subtype indication with or without a constraint.\n \n+   function Is_Verifiable_DIC_Pragma (Prag : Node_Id) return Boolean;\n+   --  Determine whether pragma Default_Initial_Condition denoted by Prag has\n+   --  an assertion expression that should be verified at run time.\n+\n    function Make_CW_Equivalent_Type\n      (T : Entity_Id;\n       E : Node_Id) return Entity_Id;\n@@ -1500,6 +1504,7 @@ package body Exp_Util is\n       --  Start of processing for Add_Own_DIC\n \n       begin\n+         pragma Assert (Present (DIC_Expr));\n          Expr := New_Copy_Tree (DIC_Expr);\n \n          --  Perform the following substitution:\n@@ -1733,8 +1738,6 @@ package body Exp_Util is\n          --  Produce an empty completing body in the following cases:\n          --    * Assertions are disabled\n          --    * The DIC Assertion_Policy is Ignore\n-         --    * Pragma DIC appears without an argument\n-         --    * Pragma DIC appears with argument \"null\"\n \n          if No (Stmts) then\n             Stmts := New_List (Make_Null_Statement (Loc));\n@@ -8715,6 +8718,21 @@ package body Exp_Util is\n           and then Is_Itype (Full_Typ);\n    end Is_Untagged_Private_Derivation;\n \n+   ------------------------------\n+   -- Is_Verifiable_DIC_Pragma --\n+   ------------------------------\n+\n+   function Is_Verifiable_DIC_Pragma (Prag : Node_Id) return Boolean is\n+      Args : constant List_Id := Pragma_Argument_Associations (Prag);\n+\n+   begin\n+      --  To qualify as verifiable, a DIC pragma must have a non-null argument\n+\n+      return\n+        Present (Args)\n+          and then Nkind (Get_Pragma_Arg (First (Args))) /= N_Null;\n+   end Is_Verifiable_DIC_Pragma;\n+\n    ---------------------------\n    -- Is_Volatile_Reference --\n    ---------------------------"}, {"sha": "16113e1cfd9e13377343e8b79f6ebad3a4936e90", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=b3801819f495f925bc7c26f03e4e98f448423839", "patch": "@@ -27327,25 +27327,14 @@ package body Sem_Prag is\n                      end loop;\n                   end if;\n \n-                  --  Constants are part of the hidden state of a package, but\n-                  --  the compiler cannot determine whether they have variable\n-                  --  input (SPARK RM 7.1.1(2)) and cannot classify them as a\n-                  --  hidden state. Accept the constant quietly even if it is\n-                  --  a visible state or lacks a Part_Of indicator.\n+                  --  At this point it is known that the constituent is not\n+                  --  part of the package hidden state and cannot be used in\n+                  --  a refinement (SPARK RM 7.2.2(9)).\n \n-                  if Ekind (Constit_Id) = E_Constant then\n-                     Collect_Constituent;\n-\n-                  --  If we get here, then the constituent is not a hidden\n-                  --  state of the related package and may not be used in a\n-                  --  refinement (SPARK RM 7.2.2(9)).\n-\n-                  else\n-                     Error_Msg_Name_1 := Chars (Spec_Id);\n-                     SPARK_Msg_NE\n-                       (\"cannot use & in refinement, constituent is not a \"\n-                        & \"hidden state of package %\", Constit, Constit_Id);\n-                  end if;\n+                  Error_Msg_Name_1 := Chars (Spec_Id);\n+                  SPARK_Msg_NE\n+                    (\"cannot use & in refinement, constituent is not a hidden \"\n+                     & \"state of package %\", Constit, Constit_Id);\n                end if;\n             end Match_Constituent;\n "}, {"sha": "688ad7bfe328a037456ea87ca46f74736d9026ac", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b3801819f495f925bc7c26f03e4e98f448423839", "patch": "@@ -10384,19 +10384,16 @@ package body Sem_Util is\n \n    function Has_Full_Default_Initialization (Typ : Entity_Id) return Boolean is\n       Comp : Entity_Id;\n-      Prag : Node_Id;\n \n    begin\n-      --  A type subject to pragma Default_Initial_Condition is fully default\n-      --  initialized when the pragma appears with a non-null argument. Since\n-      --  any type may act as the full view of a private type, this check must\n-      --  be performed prior to the specialized tests below.\n+      --  A type subject to pragma Default_Initial_Condition may be fully\n+      --  default initialized depending on inheritance and the argument of\n+      --  the pragma. Since any type may act as the full view of a private\n+      --  type, this check must be performed prior to the specialized tests\n+      --  below.\n \n-      if Has_DIC (Typ) then\n-         Prag := Get_Pragma (Typ, Pragma_Default_Initial_Condition);\n-         pragma Assert (Present (Prag));\n-\n-         return Is_Verifiable_DIC_Pragma (Prag);\n+      if Has_Fully_Default_Initializing_DIC_Pragma (Typ) then\n+         return True;\n       end if;\n \n       --  A scalar type is fully default initialized if it is subject to aspect\n@@ -10463,6 +10460,47 @@ package body Sem_Util is\n       end if;\n    end Has_Full_Default_Initialization;\n \n+   -----------------------------------------------\n+   -- Has_Fully_Default_Initializing_DIC_Pragma --\n+   -----------------------------------------------\n+\n+   function Has_Fully_Default_Initializing_DIC_Pragma\n+     (Typ : Entity_Id) return Boolean\n+   is\n+      Args : List_Id;\n+      Prag : Node_Id;\n+\n+   begin\n+      --  A type that inherits pragma Default_Initial_Condition from a parent\n+      --  type is automatically fully default initialized.\n+\n+      if Has_Inherited_DIC (Typ) then\n+         return True;\n+\n+      --  Otherwise the type is fully default initialized only when the pragma\n+      --  appears without an argument, or the argument is non-null.\n+\n+      elsif Has_Own_DIC (Typ) then\n+         Prag := Get_Pragma (Typ, Pragma_Default_Initial_Condition);\n+         pragma Assert (Present (Prag));\n+         Args := Pragma_Argument_Associations (Prag);\n+\n+         --  The pragma appears without an argument in which case it defaults\n+         --  to True.\n+\n+         if No (Args) then\n+            return True;\n+\n+         --  The pragma appears with a non-null expression\n+\n+         elsif Nkind (Get_Pragma_Arg (First (Args))) /= N_Null then\n+            return True;\n+         end if;\n+      end if;\n+\n+      return False;\n+   end Has_Fully_Default_Initializing_DIC_Pragma;\n+\n    --------------------\n    -- Has_Infinities --\n    --------------------\n@@ -17018,21 +17056,6 @@ package body Sem_Util is\n       end if;\n    end Is_Variable;\n \n-   ------------------------------\n-   -- Is_Verifiable_DIC_Pragma --\n-   ------------------------------\n-\n-   function Is_Verifiable_DIC_Pragma (Prag : Node_Id) return Boolean is\n-      Args : constant List_Id := Pragma_Argument_Associations (Prag);\n-\n-   begin\n-      --  To qualify as verifiable, a DIC pragma must have a non-null argument\n-\n-      return\n-        Present (Args)\n-          and then Nkind (Get_Pragma_Arg (First (Args))) /= N_Null;\n-   end Is_Verifiable_DIC_Pragma;\n-\n    ---------------------------\n    -- Is_Visibly_Controlled --\n    ---------------------------"}, {"sha": "f368eaa257de6ddad87eab293bc87b6e222eab8d", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=b3801819f495f925bc7c26f03e4e98f448423839", "patch": "@@ -1238,8 +1238,14 @@ package Sem_Util is\n    --      either include a default expression or have a type which defines\n    --      full default initialization. In the case of type extensions, the\n    --      parent type defines full default initialization.\n-   --   * A task type\n-   --   * A private type whose Default_Initial_Condition is non-null\n+   --    * A task type\n+   --    * A private type with pragma Default_Initial_Condition that provides\n+   --      full default initialization.\n+\n+   function Has_Fully_Default_Initializing_DIC_Pragma\n+     (Typ : Entity_Id) return Boolean;\n+   --  Determine whether type Typ has a suitable Default_Initial_Condition\n+   --  pragma which provides the full default initialization of the type.\n \n    function Has_Infinities (E : Entity_Id) return Boolean;\n    --  Determines if the range of the floating-point type E includes\n@@ -1980,10 +1986,6 @@ package Sem_Util is\n    --  default is True since this routine is commonly invoked as part of the\n    --  semantic analysis and it must not be disturbed by the rewriten nodes.\n \n-   function Is_Verifiable_DIC_Pragma (Prag : Node_Id) return Boolean;\n-   --  Determine whether pragma Default_Initial_Condition denoted by Prag has\n-   --  an assertion expression which should be verified at runtime.\n-\n    function Is_Visibly_Controlled (T : Entity_Id) return Boolean;\n    --  Check whether T is derived from a visibly controlled type. This is true\n    --  if the root type is declared in Ada.Finalization. If T is derived"}, {"sha": "ce557242d28c14b73c2969853b9b1e681abf8f5e", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=b3801819f495f925bc7c26f03e4e98f448423839", "patch": "@@ -1742,21 +1742,16 @@ package body Sem_Warn is\n       -----------------------------\n \n       function Is_OK_Fully_Initialized return Boolean is\n-         Prag : Node_Id;\n-\n       begin\n          if Is_Access_Type (Typ) and then Is_Dereferenced (N) then\n             return False;\n \n-         --  A type subject to pragma Default_Initial_Condition is fully\n-         --  default initialized when the pragma appears with a non-null\n-         --  argument (SPARK RM 3.1 and SPARK RM 7.3.3).\n-\n-         elsif Has_DIC (Typ) then\n-            Prag := Get_Pragma (Typ, Pragma_Default_Initial_Condition);\n-            pragma Assert (Present (Prag));\n+         --  A type subject to pragma Default_Initial_Condition may be fully\n+         --  default initialized depending on inheritance and the argument of\n+         --  the pragma (SPARK RM 3.1 and SPARK RM 7.3.3).\n \n-            return Is_Verifiable_DIC_Pragma (Prag);\n+         elsif Has_Fully_Default_Initializing_DIC_Pragma (Typ) then\n+            return True;\n \n          else\n             return Is_Fully_Initialized_Type (Typ);"}, {"sha": "e8d45ac18ce0ed13d0016ba96feacff9e9012b80", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b3801819f495f925bc7c26f03e4e98f448423839", "patch": "@@ -1,3 +1,8 @@\n+2017-12-15  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* gnat.dg/dflt_init_cond.adb, gnat.dg/dflt_init_cond_pkg.ads: New\n+\ttestcase.\n+\n 2017-12-15  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* gnat.dg/expr_func_main.adb, gnat.dg/expr_func_pkg.ads,"}, {"sha": "1c4cd64529f07254f5d2be5a9ace03febaedbd00", "filename": "gcc/testsuite/gnat.dg/dflt_init_cond.adb", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Ftestsuite%2Fgnat.dg%2Fdflt_init_cond.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Ftestsuite%2Fgnat.dg%2Fdflt_init_cond.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdflt_init_cond.adb?ref=b3801819f495f925bc7c26f03e4e98f448423839", "patch": "@@ -0,0 +1,12 @@\n+--  { dg-do compile }\n+\n+with Dflt_Init_Cond_Pkg; use Dflt_Init_Cond_Pkg;\n+\n+procedure Dflt_Init_Cond is\n+   E : Explicit;\n+   I : Implicit;\n+\n+begin\n+   Read (E);\n+   Read (I);\n+end Dflt_Init_Cond;"}, {"sha": "e1955cde69d1f0af568a2dad3766db40961f6c57", "filename": "gcc/testsuite/gnat.dg/dflt_init_cond_pkg.ads", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Ftestsuite%2Fgnat.dg%2Fdflt_init_cond_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3801819f495f925bc7c26f03e4e98f448423839/gcc%2Ftestsuite%2Fgnat.dg%2Fdflt_init_cond_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdflt_init_cond_pkg.ads?ref=b3801819f495f925bc7c26f03e4e98f448423839", "patch": "@@ -0,0 +1,11 @@\n+package Dflt_Init_Cond_Pkg is\n+   type Explicit is limited private with Default_Initial_Condition => True;\n+   type Implicit is limited private with Default_Initial_Condition;\n+\n+   procedure Read (Obj : Explicit);\n+   procedure Read (Obj : Implicit);\n+\n+private\n+   type Implicit is access all Integer;\n+   type Explicit is access all Integer;\n+end Dflt_Init_Cond_Pkg;"}]}