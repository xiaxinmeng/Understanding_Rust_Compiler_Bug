{"sha": "a811708d7a5ab0f7b8e381622b899395bf640f0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgxMTcwOGQ3YTVhYjBmN2I4ZTM4MTYyMmI4OTkzOTViZjY0MGYwYg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@purist.soma.redhat.com", "date": "2000-08-29T01:27:47Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-08-29T01:27:47Z"}, "message": "codecvt.html: Add more bits, format.\n\n\n2000-08-28  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n\n\t* docs/22_locale/codecvt.html: Add more bits, format.\n\nFrom-SVN: r36026", "tree": {"sha": "4e6304593fff9f015050010d2bea812b640d7502", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e6304593fff9f015050010d2bea812b640d7502"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a811708d7a5ab0f7b8e381622b899395bf640f0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a811708d7a5ab0f7b8e381622b899395bf640f0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a811708d7a5ab0f7b8e381622b899395bf640f0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a811708d7a5ab0f7b8e381622b899395bf640f0b/comments", "author": null, "committer": null, "parents": [{"sha": "337aa8ed5471787a090a714b85b849e506c3ab1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/337aa8ed5471787a090a714b85b849e506c3ab1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/337aa8ed5471787a090a714b85b849e506c3ab1a"}], "stats": {"total": 628, "additions": 516, "deletions": 112}, "files": [{"sha": "3e7a44b2b29ed871643e22862384302fb4a62fb6", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a811708d7a5ab0f7b8e381622b899395bf640f0b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a811708d7a5ab0f7b8e381622b899395bf640f0b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a811708d7a5ab0f7b8e381622b899395bf640f0b", "patch": "@@ -1,3 +1,7 @@\n+2000-08-28  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n+\n+\t* docs/22_locale/codecvt.html: Add more bits, format. \n+\n 2000-08-28  Phil Edwards  <pme@sources.redhat.com>\n \n \t* docs/configopts.html:  Mention new options."}, {"sha": "de14677786d01717b554057b825e8798f688dfc9", "filename": "libstdc++-v3/docs/22_locale/codecvt.html", "status": "modified", "additions": 512, "deletions": 112, "changes": 624, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a811708d7a5ab0f7b8e381622b899395bf640f0b/libstdc%2B%2B-v3%2Fdocs%2F22_locale%2Fcodecvt.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a811708d7a5ab0f7b8e381622b899395bf640f0b/libstdc%2B%2B-v3%2Fdocs%2F22_locale%2Fcodecvt.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F22_locale%2Fcodecvt.html?ref=a811708d7a5ab0f7b8e381622b899395bf640f0b", "patch": "@@ -1,112 +1,512 @@\n-<!-- ================================================================================  -->\n-<!-- This HTML file was created by AbiWord.                                            -->\n-<!-- AbiWord is a free, Open Source word processor.                                    -->\n-<!-- You may obtain more information about AbiWord at www.abisource.com                -->\n-<!-- ================================================================================  -->\n-\n-<!--         Build_Version     = 0.7.10 -->\n-<!--         Build_Options     = LicensedTrademarks:On Debug:Off Gnome:Off -->\n-<!--         Build_Target      = /var/tmp/builds/0961080942/tmp/abi-0.7.10/src/Linux_2.2.14-5.0_i386_OBJ/obj -->\n-<!--         Build_CompileTime = 10:12:56 -->\n-<!--         Build_CompileDate = Jun 15 2000 -->\n-\n-<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml/DTD/xhtml1-strict.dtd\">\n-<html>\n-<head>\n-<title>AbiWord Document</title>\n-<style type=\"text/css\">\n-<!-- \n- P.norm { margin-top: 0pt; margin-bottom: 0pt } \n- -->\n-</style>\n-</head>\n-<body>\n-<div>\n-<p class=\"norm\"><span style=\"font-weight: bold font-size: 16.000000pt;\">N</span><span style=\"font-weight: bold font-size: 16.000000pt;\">otes on the</span><span style=\"font-weight: bold font-size: 16.000000pt;\"> codecvt implementation.</span></p>\n-<p class=\"norm\"><span style=\"font-weight: bold; font-style: italic font-size: 12.000000pt;\">prepared by Benjamin Kosnik (bkoz@</span><span style=\"font-weight: bold; font-style: italic font-size: 12.000000pt;\">redhat.com) on August 25, 2000</span></p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\"><span style=\"font-weight: bold\">1. </span><span style=\"font-weight: bold\">Abst</span><span style=\"font-weight: bold\">ract</span></p>\n-<p class=\"norm\">Around page 425 of the C++ Standard, this charming heading comes into view:</p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\">22.2.1.5 - Template class codecvt [lib.locale.codecvt]</p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\">The standard class codecvt attempts to address conversions between different character encoding schemes. In particular, the standard attempts to detail conversions between the implementation-defined wide characters (hereafter referred to as wchar_t) and the standard type char that is so beloved in classic \"C\" (which can now be referred to as narrow characters.) </p>\n-<p class=\"norm\">This document attempts to describe how the GNU libstdc++-v3 implementation deals with the conversion between wide and narrow characters, and also presents a framework for dealing with the huge number of other encodings that iconv can convert, including Unicode and UTF8. Design issues and requirements are addressed, and examples of correct usage for both the required specializations for wide and narrow characters and the implementation-provided extended functionality are given.</p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\"><span style=\"font-weight: bold\">2. </span><span style=\"font-weight: bold color: 000000; font-family: Times New Roman; font-size: 12.000000pt;\">Intro, ,</span><span style=\"font-weight: bold color: 000000; font-family: Times New Roman; font-size: 12.000000pt;\">standard says</span></p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\"><span style=\"font-weight: bold\">2. </span><span style=\"font-weight: bold\">Som</span><span style=\"font-weight: bold\">e thoughts on what </span><span style=\"font-weight: bold\">would be useful</span></p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\">Probably the most frequently asked question about code conversion is: \"So dudes, what's the deal with Unicode strings?\" The dude part is optional, but apparently the usefulness of Unicode strings is pretty widely appreciated. Sadly, this specific encoding (And other useful encodings like UTF8, UCS4, ISO 8859-10, etc etc etc) are not mentioned in the C++ standard. </p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\">In particular, the simple implementation detail of wchar_t's size seems to repeatedly confound people. Many systems use a two byte, unsigned integral type to represent wide characters, and use an internal encoding of Unicode or UCS2. (See AIX, Microsoft NT, Java, others.) Other systems, use a four byte, unsigned integral type to represent wide characters, and use an internal encoding of UCS4. (GNU/Linux systems using glibc, in particular.) The C programming language (and thus C++) does not specify a specific size for the type wchar_t. </p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\">Thus, portable C++ code cannot assume a byte size (or endianness) either.</p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\">Getting back to the frequently asked question: What about Unicode strings?</p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\">The text around the codecvt definition gives some clues:</p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\"><span style=\"font-style: italic\"\">-1- The class codecvt&lt;internT,externT,stateT&gt; is for use when converting from one</span></p>\n-<p class=\"norm\"><span style=\"font-style: italic\"\">codeset to another, such as from wide characters to multibyte characters, between wide</span></p>\n-<p class=\"norm\"><span style=\"font-style: italic\"\">character encodings such as Unicode and EUC. </span></p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\">Hmm. So, in some unspecified way, Unicode encodings and translations between other character sets should be handled by this class.</p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\"><span style=\"font-style: italic\"\">-2- The stateT argument selects the pair of codesets being mapped between. </span></p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\">Ah ha! Another clue...</p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\"><span style=\"font-style: italic\"\">-3- The instantiations required in the Table ?? (lib.locale.category), namely</span></p>\n-<p class=\"norm\"><span style=\"font-style: italic\"\">codecvt&lt;wchar_t,char,mbstate_t&gt; and codecvt&lt;char,char,mbstate_t&gt;, convert the</span></p>\n-<p class=\"norm\"><span style=\"font-style: italic\"\">implementation-defined native character set. codecvt&lt;char,char,mbstate_t&gt; implements</span></p>\n-<p class=\"norm\"><span style=\"font-style: italic\"\">a degenerate conversion; it does not convert at all. codecvt&lt;wchar_t,char,mbstate_t&gt;</span></p>\n-<p class=\"norm\"><span style=\"font-style: italic\"\">converts between the native character sets for tiny and wide characters. Instantiations on</span></p>\n-<p class=\"norm\"><span style=\"font-style: italic\"\">mbstate_t perform conversion between encodings known to the library implementor.</span></p>\n-<p class=\"norm\"><span style=\"font-style: italic\"\">Other encodings can be converted by specializing on a user-defined stateT type. The</span></p>\n-<p class=\"norm\"><span style=\"font-style: italic\"\">stateT object can contain any state that is useful to communicate to or from the</span></p>\n-<p class=\"norm\"><span style=\"font-style: italic\"\">specialized do_convert member. </span></p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\">At this point, the initial design of the library becomes clear:</p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\"><span style=\"font-weight: bold\">3. </span><span style=\"font-weight: bold\">How to accomplish </span><span style=\"font-weight: bold\">this: partial specialization with and iconv</span><span style=\"font-weight: bold\"> wrapper class, __enc_traits.</span></p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\"><span style=\"font-weight: bold\">4. Design</span></p>\n-<p class=\"norm\"> \ta. goals.</p>\n-<p class=\"norm\">\tb. drawbacks</p>\n-<p class=\"norm\">\tc. things that are sketchy</p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\"><span style=\"font-weight: bold\">5. Examples</span></p>\n-<p class=\"norm\">\ta. conversions involving string literals</p>\n-<p class=\"norm\">\tb. conversions invollving std::string</p>\n-<p class=\"norm\">\tc. conversions involving std::filebuf and std::ostream</p>\n-<p class=\"norm\"> </p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\"><span style=\"font-weight: bold\">6. Acknowledg</span><span style=\"font-weight: bold\">me</span><span style=\"font-weight: bold\">nts</span></p>\n-<p class=\"norm\">Ulrich Drepper for the iconv suggestions and patient question answering, Jason Merrill for the template partial specialization hints and wchar_t fixes, etc etc etc.</p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\"><span style=\"font-weight: bold\">7</span><span style=\"font-weight: bold\">. Bibliography</span><span style=\"font-weight: bold\"> / Referenced Documents</span></p>\n-<p class=\"norm\">ISO/IEC 14882:1998 Programming languages - C++</p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\">ISO/IEC 9899:1999 Programming languages - C</p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\">glibc-2.2 docs</p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\">System Interface Definitions, Issue 6 (IEEE Std. 1003.1-200x)</p>\n-<p class=\"norm\">The Open Group/The Institute of Electrical and Electronics Engineers, Inc.</p>\n-<p class=\"norm\">http://www.opennc.org/austin/docreg.html</p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\">Appendix D, The C++ Programming Language, Special Edition, Bjarne Stroustrup, Addison Wesley, Inc. 2000</p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\">Standard C++ IOStreams and Locales, Advanced Programmer's Guide and Reference, Angelika Langer and Klaus Kreft, Addison Wesley Longman, Inc. 2000</p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\">Numerous, late-night email correspondence with Ulrich Drepper (drepper@redhat.com).</p>\n-<p class=\"norm\"></p>\n-<p class=\"norm\"></p>\n-</div>\n-</body>\n-</html>\n+<HTML>\n+<HEAD>\n+  <H1>\n+  Notes on the codecvt implementation.\n+  </H1>\n+</HEAD>\n+<I>\n+prepared by Benjamin Kosnik (bkoz@redhat.com) on August 28, 2000\n+</I>\n+\n+<P>\n+<H2>\n+1. Abstract\n+</H2>\n+<P>\n+The standard class codecvt attempts to address conversions between\n+different character encoding schemes. In particular, the standard\n+attempts to detail conversions between the implementation-defined wide\n+characters (hereafter referred to as wchar_t) and the standard type\n+char that is so beloved in classic \"C\" (which can now be referred to\n+as narrow characters.)  This document attempts to describe how the GNU\n+libstdc++-v3 implementation deals with the conversion between wide and\n+narrow characters, and also presents a framework for dealing with the\n+huge number of other encodings that iconv can convert, including\n+Unicode and UTF8. Design issues and requirements are addressed, and\n+examples of correct usage for both the required specializations for\n+wide and narrow characters and the implementation-provided extended\n+functionality are given.\n+</P>\n+\n+<P>\n+<H2>\n+2. What the standard says\n+</H2>\n+Around page 425 of the C++ Standard, this charming heading comes into view:\n+\n+<BLOCKQUOTE>\n+22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+</BLOCKQUOTE>\n+\n+The text around the codecvt definition gives some clues:\n+\n+<BLOCKQUOTE>\n+<I>\n+-1- The class codecvt<internT,externT,stateT> is for use when\n+converting from one codeset to another, such as from wide characters\n+to multibyte characters, between wide character encodings such as\n+Unicode and EUC. \n+</I>\n+</BLOCKQUOTE>\n+\n+<P> \n+Hmm. So, in some unspecified way, Unicode encodings and\n+translations between other character sets should be handled by this\n+class.  \n+</P>\n+\n+<BLOCKQUOTE>\n+<I>\n+-2- The stateT argument selects the pair of codesets being mapped between. \n+</I>\n+</BLOCKQUOTE>\n+\n+<P>\n+Ah ha! Another clue...\n+</P>\n+\n+<BLOCKQUOTE>\n+<I>\n+-3- The instantiations required in the Table ??\n+(lib.locale.category), namely codecvt<wchar_t,char,mbstate_t> and\n+codecvt<char,char,mbstate_t>, convert the implementation-defined\n+native character set. codecvt<char,char,mbstate_t> implements a\n+degenerate conversion; it does not convert at\n+all. codecvt<wchar_t,char,mbstate_t> converts between the native\n+character sets for tiny and wide characters. Instantiations on\n+mbstate_t perform conversion between encodings known to the library\n+implementor.  Other encodings can be converted by specializing on a\n+user-defined stateT type. The stateT object can contain any state that\n+is useful to communicate to or from the specialized do_convert member.\n+</I>\n+</BLOCKQUOTE>\n+\n+<P>\n+At this point, a couple points become clear:\n+\n+<P>\n+One: The standard clearly implies that attempts to add non-required\n+(yet useful and widely used) conversions need to do so through the\n+third template parameter, stateT.</P>\n+\n+<P>\n+Two: The required conversions, by specifying mbstate_t as the third\n+template parameter, imply an implementation strategy that is mostly\n+(or wholly) based on the underlying C library, and the functions\n+mcsrtombs and wcsrtombs in particular.</P>\n+\n+<P>\n+<H2>\n+2. Some thoughts on what would be useful\n+</H2>\n+Probably the most frequently asked question about code conversion is:\n+\"So dudes, what's the deal with Unicode strings?\" The dude part is\n+optional, but apparently the usefulness of Unicode strings is pretty\n+widely appreciated. Sadly, this specific encoding (And other useful\n+encodings like UTF8, UCS4, ISO 8859-10, etc etc etc) are not mentioned\n+in the C++ standard.\n+\n+<P>\n+In particular, the simple implementation detail of wchar_t's size\n+seems to repeatedly confound people. Many systems use a two byte,\n+unsigned integral type to represent wide characters, and use an\n+internal encoding of Unicode or UCS2. (See AIX, Microsoft NT, Java,\n+others.) Other systems, use a four byte, unsigned integral type to\n+represent wide characters, and use an internal encoding of\n+UCS4. (GNU/Linux systems using glibc, in particular.) The C\n+programming language (and thus C++) does not specify a specific size\n+for the type wchar_t.\n+\n+<P>\n+Thus, portable C++ code cannot assume a byte size (or endianness) either.\n+\n+<P>\n+Getting back to the frequently asked question: What about Unicode strings?\n+\n+<P>\n+What magic spell will do this conversion?\n+\n+<P>\n+A couple of comments:\n+</P>\n+\n+<P>\n+The thought that all one needs to convert between two arbitrary\n+codesets is two types and some kind of state argument is\n+unfortunate. In particular, encodings may be stateless. The naming of\n+the third parameter as stateT is unfortunate, as what is really needed\n+is some kind of generalized type that accounts for the issues that\n+abstract encodings will need. The minimum information that is required\n+includes:\n+</P>\n+\n+<UL>\n+<LI>\n+</P>\n+ Identifiers for each of the codesets involved in the conversion. For\n+example, using the iconv family of functions from the Single Unix\n+Specification (what used to be called X/Open) hosted on the GNU/Linux\n+operating system allows bi-directional mapping between far more than\n+the following tantalizing possibilities: \n+</P>\n+\n+(An edited list taken from <TT>`iconv --list`</TT> on a Red Hat 6.2/Intel system:\n+\n+<BLOCKQUOTE>\n+<PRE>\n+8859_1, 8859_9, 10646-1:1993, 10646-1:1993/UCS4, ARABIC, ARABIC7,\n+ASCII, EUC-CN, EUC-JP, EUC-KR, EUC-TW, GREEK-CCITT, GREEK, GREEK7-OLD,\n+GREEK7, GREEK8, HEBREW, ISO-8859-1, ISO-8859-2, ISO-8859-3,\n+ISO-8859-4, ISO-8859-5, ISO-8859-6, ISO-8859-7, ISO-8859-8,\n+ISO-8859-9, ISO-8859-10, ISO-8859-11, ISO-8859-13, ISO-8859-14,\n+ISO-8859-15, ISO-10646, ISO-10646/UCS2, ISO-10646/UCS4,\n+ISO-10646/UTF-8, ISO-10646/UTF8, SHIFT-JIS, SHIFT_JIS, UCS-2, UCS-4,\n+UCS2, UCS4, UNICODE, UNICODEBIG, UNICODELITTLE, US-ASCII, US, UTF-8,\n+UTF-16, UTF8, UTF16).\n+</PRE>\n+</BLOCKQUOTE>\n+\n+<P>\n+For iconv-based implementations, string literals for each of the\n+encodings (ie. \"UCS-2\" and \"UTF-8\") are necessary, although for other,\n+non-iconv implementations a table of enumerated values or some other\n+mechanism may be required.\n+\n+<LI>\n+ Maximum length of the identifying string literal.\n+\n+<LI>\n+ Some encodings are require explicit endian-ness. As such, some kind\n+  of endian marker or other byte-order marker will be necessary. See\n+  \"Footnotes for C/C++ developers\" in Haible for more information on\n+  UCS-2/Unicode endian issues. (Summary: big endian seems most likely,\n+  however implementations, most notably Microsoft, vary.)\n+\n+<LI>\n+ Types representing the conversion state, for conversions involving\n+  the machinery in the \"C\" library, or the conversion descriptor, for\n+  conversions using iconv (such as the type iconv_t.)  Note that the\n+  conversion descriptor encodes more information than a simple encoding\n+  state type.\n+\n+<LI>\n+ Conversion descriptors for both directions of encoding. (ie, both\n+  UCS-2 to UTF-8 and UTF-8 to UCS-2.)\n+\n+<LI>\n+ Something to indicate if the conversion requested if valid.\n+\n+<LI>\n+ Something to represent if the conversion descriptors are valid.\n+\n+<LI>\n+ Some way to enforce strict type checking on the internal and\n+  external types. As part of this, the size of the internal and\n+  external types will need to be known.\n+</UL>\n+\n+<P>\n+<H2>\n+3. Problems with \"C\" code conversions : thread safety, global locales,\n+   termination.\n+</H2>\n+\n+In addition, multi-threaded and multi-locale environments also impact\n+the design and requirements for code conversions. In particular, they\n+affect the required specialization codecvt<wchar_t, char, mbstate_t>\n+when implemented using standard \"C\" functions.\n+\n+<P>\n+Three problems arise, one big, one of medium importance, and one small. \n+\n+<P>\n+First, the small: mcsrtombs and wcsrtombs may not be multithread-safe\n+on all systems required by the GNU tools. For GNU/Linux and glibc,\n+this is not an issue.\n+\n+<P>\n+Of medium concern, in the grand scope of things, is that the functions\n+used to implement this specialization work on null-terminated\n+strings. Buffers, especially file buffers, may not be null-terminated,\n+thus giving conversions that end prematurely or are otherwise\n+incorrect. Yikes!\n+\n+<P>\n+The last, and fundamental problem, is the assumption of a global\n+locale for all the \"C\" functions referenced above. For something like\n+C++ iostreams (where codecvt is explicitly used) the notion of\n+multiple locales is fundamental. In practice, most users may not run\n+into this limitation. However, as a quality of implementation issue,\n+the GNU C++ library would like to offer a solution that allows\n+multiple locales and or simultaneous usage with computationally\n+correct results. In short, libstdc++-v3 is trying to offer, as an\n+option, a high-quality implementation, damn the additional complexity!\n+\n+<P>\n+For the required specialization codecvt<wchar_t, char, mbstate_t> ,\n+conversions are made between the internal character set (always UCS4\n+on GNU/Linux) and whatever the currently selected locale for the\n+LC_CTYPE category implements.\n+\n+<P>\n+<H2>\n+4. Design\n+</H2>\n+The two required specializations are implemented as follows:\n+\n+<P>\n+<TT>\n+codecvt&#60char, char, mbstate_t&#62\n+</TT>\n+<P>\n+This is a degenerate (ie, does nothing) specialization. Implementing\n+this was a piece of cake.\n+\n+<P>\n+<TT>\n+codecvt&#60char, wchar_t, mbstate_t&#62\n+</TT>\n+<P>\n+This specialization, by specifying all the template parameters, pretty\n+much ties the hands of implementors. As such, the implementation is\n+straightforward, involving mcsrtombs for the conversions between char\n+to wchar_t and wcsrtombs for conversions between wchar_t and char.\n+\n+<P>\n+Neither of these two required specializations deals with Unicode\n+characters. As such, libstdc++-v3 implements a partial specialization\n+of the codecvt class with and iconv wrapper class, __enc_traits as the\n+third template parameter.\n+\n+<P>\n+This implementation should be standards conformant. First of all, the\n+standard explicitly points out that instantiations on the third\n+template parameter, stateT, are the proper way to implement\n+non-required conversions. Second of all, the standard says (in Chapter\n+17) that partial specializations of required classes are a-ok. Third\n+of all, the requirements for the stateT type elsewhere in the standard\n+(see 21.1.2 traits typedefs) only indicate that this type be copy\n+constructible.\n+\n+<P>\n+As such, the type __enc_traits is defined as a non-templatized, POD\n+type to be used as the third type of a codecvt instantiation. This\n+type is just a wrapper class for iconv, and provides an easy interface\n+to iconv functionality.\n+\n+<P>\n+There are two constructors for __enc_traits:\n+\n+<P>\n+<TT> \n+__enc_traits() : __in_desc(0), __out_desc(0)\n+</TT>\n+<P>\n+This default constructor sets the internal encoding to some default\n+(currently UCS4) and the external encoding to whatever is returned by\n+nl_langinfo(CODESET).\n+\n+<P>\n+<TT> \n+__enc_traits(const char* __int, const char* __ext)\n+</TT>\n+<P>\n+This constructor takes as parameters string literals that indicate the\n+desired internal and external encoding. There are no defaults for\n+either argument.\n+\n+<P>\n+One of the issues with iconv is that the string literals identifying\n+conversions are not standardized. Because of this, the thought of\n+mandating and or enforcing some set of pre-determined valid\n+identifiers seems iffy: thus, a more practical (and non-migraine\n+inducing) strategy was implemented: end-users can specify any string\n+(subject to a pre-determined length qualifier, currently 32 bytes) for\n+encodings. It is up to the user to make sure that these strings are\n+valid on the target system.\n+  \n+<P>\n+<TT> \n+void\n+_M_init()\n+</TT>\n+<P>\n+Strangely enough, this member function attempts to open conversion\n+descriptors for a given __enc_traits object. If the conversion\n+descriptors are not valid, the conversion descriptors returned will\n+not be valid and the resulting calls to the codecvt conversion\n+functions will return error.\n+\n+<P>\n+<TT> \n+bool\n+_M_good()\n+</TT>\n+<P>\n+Provides a way to see if the given __enc_traits object has been\n+properly initialized. If the string literals describing the desired\n+internal and external encoding are not valid, initialization will\n+fail, and this will return false. If the internal and external\n+encodings are valid, but iconv_open could not allocate conversion\n+descriptors, this will also return false. Otherwise, the object is\n+ready to convert and will return true.\n+\n+<P>\n+<TT> \n+__enc_traits(const __enc_traits&)\n+</TT>\n+<P>\n+As iconv allocates memory and sets up conversion descriptors, the copy\n+constructor can only copy the member data pertaining to the internal\n+and external code conversions, and not the conversion descriptors\n+themselves.\n+\n+<P>\n+Definitions for all the required codecvt member functions are provided\n+for this specialization, and usage of codecvt<internal character type,\n+external character type, __enc_traits> is consistent with other\n+codecvt usage.\n+\n+<P>\n+<H2>\n+5.  Examples\n+</H2>\n+a. conversions involving string literals\n+\n+<pre>\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef unsigned short\t\t\tunicode_t;\n+  typedef unicode_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef __enc_traits\t\t\t\tenc_type;\n+  typedef codecvt<int_type, ext_type, enc_type>\tunicode_codecvt;\n+\n+  const ext_type* \te_lit = \"black pearl jasmine tea\";\n+  int \t\t\tsize = strlen(e_lit);\n+  int_type \t\ti_lit_base[24] = \n+  { 25088, 27648, 24832, 25344, 27392, 8192, 28672, 25856, 24832, 29184, \n+    27648, 8192, 27136, 24832, 29440, 27904, 26880, 28160, 25856, 8192, 29696,\n+    25856, 24832, 2560\n+  };\n+  const int_type* \ti_lit = i_lit_base;\n+  const ext_type*       efrom_next;\n+  const int_type*       ifrom_next;\n+  ext_type* \t\te_arr = new ext_type[size + 1];\n+  ext_type*\t\teto_next;\n+  int_type* \t\ti_arr = new int_type[size + 1];\n+  int_type*\t\tito_next;\n+\n+  // construct a locale object with the specialized facet.\n+  locale \t\tloc(locale::classic(), new unicode_codecvt);\n+  // sanity check the constructed locale has the specialized facet.\n+  VERIFY( has_facet<unicode_codecvt>(loc) );\n+  const unicode_codecvt&\tcvt = use_facet<unicode_codecvt>(loc); \n+  // convert between const char* and unicode strings\n+  unicode_codecvt::state_type state01(\"UNICODE\", \"ISO_8859-1\");\n+  initialize_state(state01);\n+  result r1 = cvt.in(state01, e_lit, e_lit + size, efrom_next, \n+\t\t     i_arr, i_arr + size, ito_next);\n+  VERIFY( r1 == codecvt_base::ok );\n+  VERIFY( !int_traits::compare(i_arr, i_lit, size) ); \n+  VERIFY( efrom_next == e_lit + size );\n+  VERIFY( ito_next == i_arr + size );\n+</pre>\n+\tb. conversions involving std::string\n+\tc. conversions involving std::filebuf and std::ostream\n+\n+More information can be found in the following testcases:\n+codecvt_char_char.cc     \n+codecvt_unicode_wchar_t.cc\n+codecvt_unicode_char.cc  \n+codecvt_wchar_t_char.cc\n+\n+<P>\n+<H2>\n+6.  Unresolved Issues\n+</H2>\n+<UL>\n+<LI>\n+\ta. things that are sketchy, or remain unimplemented\n+\t\tdo_encoding, max_length and length member functions\n+\t\tare only weakly implemented. I have no idea how to do\n+\t\tthis correctly, and in a generic manner.  Nathan?\n+\n+<LI>\n+\tb. conversions involving std::string\n+\n+\t<UL>\n+\t\t<LI>\n+\t\thow should operators != and == work for string of\n+\t\tdifferent/same encoding?\n+\n+\t\t<LI>\n+\t\twhat is equal? A byte by byte comparison or an\n+\t\tencoding then byte comparison?\n+\t\t\n+\t\t<LI>\n+\t\tconversions between narrow, wide, and unicode strings\n+\t</UL>\n+<LI>\n+\tc. conversions involving std::filebuf and std::ostream\n+\t<UL>\n+\t\t<LI>\n+\t\thow to initialize the state object in a\n+\t\tstandards-conformant manner?\n+\n+\t\t<LI>\n+\t\thow to synchronize the \"C\" and \"C++\" conversion information?\n+\n+\t\t<LI>\n+\t\twchar_t/char internal buffers and conversions between\n+\t\tinternal/external buffers?\n+\t</UL>\n+</UL>\n+\n+<P>\n+<H2>\n+7. Acknowledgments\n+</H2>\n+Ulrich Drepper for the iconv suggestions and patient answering of\n+late-night questions, Jason Merrill for the template partial\n+specialization hints, language clarification, and wchar_t fixes.\n+\n+<P>\n+<H2>\n+8. Bibliography / Referenced Documents\n+</H2>\n+\n+Drepper, Ulrich, GNU libc (glibc) 2.2 manual. In particular, Chapters \"6. Character Set Handling\" and \"7 Locales and Internationalization\"\n+\n+<P>\n+Drepper, Ulrich, Numerous, late-night email correspondence\n+\n+<P>\n+Feather, Clive, \"A brief description of Normative Addendum 1,\" in particular the parts on Extended Character Sets\n+http://www.lysator.liu.se/c/na1.html\n+\n+<P>\n+Haible, Bruno, \"The Unicode HOWTO\" v0.18, 4 August 2000\n+ftp://ftp.ilog.fr/pub/Users/haible/utf8/Unicode-HOWTO.html\n+\n+<P>\n+ISO/IEC 14882:1998 Programming languages - C++\n+\n+<P>\n+ISO/IEC 9899:1999 Programming languages - C\n+\n+<P>\n+Khun, Markus, \"UTF-8 and Unicode FAQ for Unix/Linux\"\n+http://www.cl.cam.ac.uk/~mgk25/unicode.html\n+\n+<P>\n+Langer, Angelika and Klaus Kreft, Standard C++ IOStreams and Locales, Advanced Programmer's Guide and Reference, Addison Wesley Longman, Inc. 2000\n+\n+<P>\n+Stroustrup, Bjarne, Appendix D, The C++ Programming Language, Special Edition, Addison Wesley, Inc. 2000\n+\n+<P>\n+System Interface Definitions, Issue 6 (IEEE Std. 1003.1-200x)\n+The Open Group/The Institute of Electrical and Electronics Engineers, Inc.\n+http://www.opennc.org/austin/docreg.html\n+\n+"}]}