{"sha": "900dd8405fbd327023aa24f856b4535033ebbef0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTAwZGQ4NDA1ZmJkMzI3MDIzYWEyNGY4NTZiNDUzNTAzM2ViYmVmMA==", "commit": {"author": {"name": "Nicolas Roche", "email": "roche@adacore.com", "date": "2019-07-08T08:14:06Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-08T08:14:06Z"}, "message": "[Ada] Remove dependency on Win32 GDI (Graphical Interface)\n\nCommandLineToArgvW drags a dependency on SHELL32.DLL and thus GDI32.DLL.\nBy loading GDI32.DLL some default GDI objects are allocated. On some\nWindows versions this cause the use of a lock on the graphical interface\nduring process termination. This can impact parallelism significantly as\ntermination of processes is serialized.\n\n2019-07-08  Nicolas Roche  <roche@adacore.com>\n\ngcc/ada/\n\n\t* rtinit.c (__gnat_runtime_initialize): Remove dependency on\n\tCommandLineToArgvW.\n\nFrom-SVN: r273214", "tree": {"sha": "f4981b82a4a4ba7dceef2ec53de7de5bc6f6dae5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4981b82a4a4ba7dceef2ec53de7de5bc6f6dae5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/900dd8405fbd327023aa24f856b4535033ebbef0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/900dd8405fbd327023aa24f856b4535033ebbef0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/900dd8405fbd327023aa24f856b4535033ebbef0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/900dd8405fbd327023aa24f856b4535033ebbef0/comments", "author": {"login": "Nikokrock", "id": 7796165, "node_id": "MDQ6VXNlcjc3OTYxNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/7796165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nikokrock", "html_url": "https://github.com/Nikokrock", "followers_url": "https://api.github.com/users/Nikokrock/followers", "following_url": "https://api.github.com/users/Nikokrock/following{/other_user}", "gists_url": "https://api.github.com/users/Nikokrock/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nikokrock/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nikokrock/subscriptions", "organizations_url": "https://api.github.com/users/Nikokrock/orgs", "repos_url": "https://api.github.com/users/Nikokrock/repos", "events_url": "https://api.github.com/users/Nikokrock/events{/privacy}", "received_events_url": "https://api.github.com/users/Nikokrock/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eaec429d5be27b5dce89260248c928edc2593d17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaec429d5be27b5dce89260248c928edc2593d17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaec429d5be27b5dce89260248c928edc2593d17"}], "stats": {"total": 205, "additions": 197, "deletions": 8}, "files": [{"sha": "57869d32bdad7683e0c0ba57f92b49994295db76", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/900dd8405fbd327023aa24f856b4535033ebbef0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/900dd8405fbd327023aa24f856b4535033ebbef0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=900dd8405fbd327023aa24f856b4535033ebbef0", "patch": "@@ -1,3 +1,8 @@\n+2019-07-08  Nicolas Roche  <roche@adacore.com>\n+\n+\t* rtinit.c (__gnat_runtime_initialize): Remove dependency on\n+\tCommandLineToArgvW.\n+\n 2019-07-08  Doug Rupp  <rupp@adacore.com>\n \n \t* Makefile.rtl: Handle vxworks7r2 in x86_64 and x86 vxworks7."}, {"sha": "1df98f81cf288d4d6c0e4e208708d7791efe775e", "filename": "gcc/ada/rtinit.c", "status": "modified", "additions": 192, "deletions": 8, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/900dd8405fbd327023aa24f856b4535033ebbef0/gcc%2Fada%2Frtinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/900dd8405fbd327023aa24f856b4535033ebbef0/gcc%2Fada%2Frtinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtinit.c?ref=900dd8405fbd327023aa24f856b4535033ebbef0", "patch": "@@ -62,7 +62,7 @@ extern \"C\" {\n /* __gnat_runtime_initialize (NT-mingw32 Version) */\n /**************************************************/\n \n-extern void __gnat_install_handler(void);\n+extern void __gnat_install_handler (void);\n \n int __gnat_wide_text_translation_required = 0;\n /* wide text translation, 0=none, 1=activated */\n@@ -89,6 +89,189 @@ extern HANDLE ProcListEvt;\n int __gnat_do_argv_expansion = 1;\n #pragma weak __gnat_do_argv_expansion\n \n+/* Assuming we are pointing to the beginning of a quoted part of an\n+argument, skip until the end of the quoted part.  */\n+static void skip_quoted_string (const WCHAR **current_in,\n+\t\t\t\tWCHAR **current_out)\n+{\n+  /* Number of backslashes buffered.  */\n+  int qbs_count = 0;\n+\n+  /* Pointer to current input character.  */\n+  const WCHAR *ci = *current_in;\n+\n+  /* Pointer to next output character.  */\n+  WCHAR *co = *current_out;\n+\n+  /* Skip initial quote.  */\n+  ci++;\n+\n+  while (*ci)\n+    {\n+      if (*ci == '\\\\')\n+\t{\n+\t  /* Buffer incoming backslashes.  */\n+\t  qbs_count++;\n+\t}\n+      else if (*ci == '\"')\n+\t{\n+\t  /* Append qbs_count / 2 backslahes.  */\n+\t  for (int i=0; i<qbs_count / 2; i++)\n+\t    {\n+\t      *co = '\\\\';\n+\t      co++;\n+\t    }\n+\t  if ((qbs_count & 1) == 0)\n+\t    {\n+\t      /* 2n backslashes means that the quotation mark is the end of\n+\t         the quoted portion.  */\n+\t      qbs_count = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Otherwise this is a double quote literal.  */\n+\t      qbs_count = 0;\n+\t      *co = '\"'; co++;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* If the character is not a double quote we should append\n+\t     qbs_count backslashes.  */\n+\t  for (int i=0; i<qbs_count; i++)\n+\t    {\n+\t      *co = '\\\\';\n+\t      co++;\n+\t    }\n+\t  *co = *ci; co++;\n+\t  qbs_count = 0;\n+\t}\n+      ci++;\n+    }\n+  *current_in = ci;\n+  *current_out = co;\n+}\n+\n+/* Assuming that this is the beginning of an argument. Skip characters\n+   until we reach the character right after the last argument character.  */\n+static void skip_argument (const WCHAR **current_in,\n+\t\t\t   WCHAR **current_out)\n+{\n+  /* Number of backslashes buffered.  */\n+  int bs_count = 0;\n+\n+  /* Pointer to current input character.  */\n+  const WCHAR *ci = *current_in;\n+\n+  /* Pointer to next output character.  */\n+  WCHAR *co = *current_out;\n+\n+  while (*ci && ! (*ci == ' ' || *ci == '\\t'))\n+    {\n+      if (*ci == '\\\\')\n+\t{\n+\t  /* Buffer incoming backslashes.  */\n+\t  bs_count++;\n+\t}\n+      else if (*ci == '\"')\n+\t{\n+\t  /* Append qbs_count / 2 backslahes.  */\n+\t  for (int i=0; i< bs_count / 2; i++)\n+\t    {\n+\t      *co = '\\\\'; co++;\n+\t    }\n+\t  if ((bs_count & 1) == 0)\n+\t    {\n+\t      /* 2n backslashes followed by a quotation mark means that\n+\t\t this is a start of a quoted string.  */\n+\t      skip_quoted_string (&ci, &co);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Otherwise this is quotation mark literal.  */\n+\t      *co = '\"';\n+\t      co++;\n+\t    }\n+\t  bs_count = 0;\n+\t}\n+      else\n+\t{\n+\t  /* This is a regular character. */\n+\t  /* Backslashes are interpreted literally.  */\n+\t  for (int i=0; i<bs_count; i++)\n+\t    {\n+\t      *co = '\\\\';\n+\t      co++;\n+\t    }\n+\t  bs_count = 0;\n+\t  *co = *ci; co++;\n+\t}\n+      ci++;\n+    }\n+\n+  for (int i=0; i<bs_count; i++)\n+    {\n+      *co = '\\\\';\n+      co++;\n+    }\n+\n+  /* End the argument with a null character. */\n+  *co = '\\0';\n+  co++;\n+\n+  *current_in = ci;\n+  *current_out = co;\n+}\n+\n+\n+void __gnat_get_argw (const WCHAR *command_line, WCHAR ***argv, int *argc)\n+{\n+  WCHAR *inline_argv;\n+  WCHAR *co;\n+  int arg_count = 1;\n+  const WCHAR *ci;\n+\n+  inline_argv =\n+    (WCHAR *) xmalloc ((wcslen (command_line) + 1) * sizeof (WCHAR));\n+  co = inline_argv;\n+\n+  /* Start iteration on command line characters. */\n+  ci = command_line;\n+\n+  /* Skip command name. Note that if the command line starts with whitechars\n+     then the command name will be the empty string. */\n+  skip_argument (&ci, &co);\n+\n+  /* Count remaining arguments. */\n+  while (*ci)\n+    {\n+      /* skip whitechar */\n+      while (*ci && (*ci == ' ' || *ci == '\\t')) { ci++; }\n+      if (*ci)\n+\t{\n+\t  skip_argument (&ci, &co);\n+\t  arg_count++;\n+\t}\n+      else\n+\tbreak;\n+    }\n+\n+  /* Allocate table with pointer to each arguments */\n+  argv[0] = (WCHAR **) xmalloc (arg_count * sizeof (WCHAR *));\n+\n+  for (int idx = 0; idx < arg_count; idx++)\n+    {\n+      argv[0][idx] = inline_argv;\n+      while (*inline_argv)\n+\t{\n+\t  inline_argv++;\n+\t}\n+      inline_argv++;\n+     }\n+  *argc = arg_count;\n+}\n+\n static void\n append_arg (int *index, LPWSTR dir, LPWSTR value,\n \t    char ***argv, int *last, int quoted)\n@@ -102,14 +285,14 @@ append_arg (int *index, LPWSTR dir, LPWSTR value,\n     {\n       /* no dir prefix */\n       dirlen = 0;\n-      fullvalue = (LPWSTR) xmalloc ((vallen + 1) * sizeof(TCHAR));\n+      fullvalue = (LPWSTR) xmalloc ((vallen + 1) * sizeof (TCHAR));\n     }\n   else\n     {\n       /* Add dir first */\n       dirlen = _tcslen (dir);\n \n-      fullvalue = (LPWSTR) xmalloc ((dirlen + vallen + 1) * sizeof(TCHAR));\n+      fullvalue = (LPWSTR) xmalloc ((dirlen + vallen + 1) * sizeof (TCHAR));\n       _tcscpy (fullvalue, dir);\n     }\n \n@@ -118,7 +301,7 @@ append_arg (int *index, LPWSTR dir, LPWSTR value,\n   if (quoted)\n     {\n       _tcsncpy (fullvalue + dirlen, value + 1, vallen - 1);\n-      fullvalue [dirlen + vallen - sizeof(TCHAR)] = _T('\\0');\n+      fullvalue [dirlen + vallen - sizeof (TCHAR)] = _T ('\\0');\n     }\n   else\n     _tcscpy (fullvalue + dirlen, value);\n@@ -130,7 +313,7 @@ append_arg (int *index, LPWSTR dir, LPWSTR value,\n     }\n \n   size = WS2SC (NULL, fullvalue, 0);\n-  (*argv)[*index] = (char *) xmalloc (size + sizeof(TCHAR));\n+  (*argv)[*index] = (char *) xmalloc (size + sizeof (TCHAR));\n   WS2SC ((*argv)[*index], fullvalue, size);\n \n   free (fullvalue);\n@@ -140,7 +323,7 @@ append_arg (int *index, LPWSTR dir, LPWSTR value,\n #endif\n \n void\n-__gnat_runtime_initialize(int install_handler)\n+__gnat_runtime_initialize (int install_handler)\n {\n   /*  increment the reference counter */\n \n@@ -223,7 +406,7 @@ __gnat_runtime_initialize(int install_handler)\n      TCHAR result [MAX_PATH];\n      int quoted;\n \n-     wargv = CommandLineToArgvW (GetCommandLineW(), &wargc);\n+     __gnat_get_argw (GetCommandLineW (), &wargv, &wargc);\n \n      if (wargv != NULL)\n        {\n@@ -297,7 +480,8 @@ __gnat_runtime_initialize(int install_handler)\n \t       }\n \t   }\n \n-\t LocalFree (wargv);\n+\t free (wargv[0]);\n+\t free (wargv);\n \t gnat_argc = argc_expanded;\n \t gnat_argv = (char **) xrealloc\n \t   (gnat_argv, argc_expanded * sizeof (char *));"}]}