{"sha": "d28899393c6ba9503dda9dd66bfe864acac90dad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI4ODk5MzkzYzZiYTk1MDNkZGE5ZGQ2NmJmZTg2NGFjYWM5MGRhZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-01-08T01:45:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-01-08T01:45:37Z"}, "message": "(order_regs_for_local_alloc): Add casts to bcopy call.\n\n(print_operand, case 'f'): New case.\n(sparc_initialize_trampoline): Use gen_flush instead of knowing what pattern\nlooks like.\nUse MEM instead of address in flush insn, so virtual reg instantiation can\nupdate.\nEnsure address in flush insn is valid.\n\nFrom-SVN: r8727", "tree": {"sha": "cb011eadba668a4687c6b6cc8f5b43cd7fb25658", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb011eadba668a4687c6b6cc8f5b43cd7fb25658"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d28899393c6ba9503dda9dd66bfe864acac90dad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d28899393c6ba9503dda9dd66bfe864acac90dad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d28899393c6ba9503dda9dd66bfe864acac90dad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d28899393c6ba9503dda9dd66bfe864acac90dad/comments", "author": null, "committer": null, "parents": [{"sha": "175a444d3f1456071b956446cf50237157e71f29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/175a444d3f1456071b956446cf50237157e71f29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/175a444d3f1456071b956446cf50237157e71f29"}], "stats": {"total": 30, "additions": 16, "deletions": 14}, "files": [{"sha": "842276e0b2c1579d8de524d5431925c633b2a316", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d28899393c6ba9503dda9dd66bfe864acac90dad/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d28899393c6ba9503dda9dd66bfe864acac90dad/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=d28899393c6ba9503dda9dd66bfe864acac90dad", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Sun SPARC.\n-   Copyright (C) 1987, 88, 89, 92, 93, 1994 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92, 93, 94, 1995 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n    64 bit SPARC V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,\n    at Cygnus Support.\n@@ -3517,8 +3517,8 @@ order_regs_for_local_alloc ()\n   if (regs_ever_live[15] != last_order_nonleaf)\n     {\n       last_order_nonleaf = !last_order_nonleaf;\n-      bcopy (reg_alloc_orders[last_order_nonleaf], reg_alloc_order,\n-\t     FIRST_PSEUDO_REGISTER * sizeof (int));\n+      bcopy ((char *) reg_alloc_orders[last_order_nonleaf],\n+\t     (char *) reg_alloc_order, FIRST_PSEUDO_REGISTER * sizeof (int));\n     }\n }\n \f\n@@ -3779,6 +3779,13 @@ print_operand (file, x, code)\n \treturn;\n       }\n \n+    case 'f':\n+      /* Operand must be a MEM; write its address.  */\n+      if (GET_CODE (x) != MEM)\n+\toutput_operand_lossage (\"Invalid %%f operand\");\n+      output_address (XEXP (x, 0));\n+      return;\n+\n     case 0:\n       /* Do nothing special.  */\n       break;\n@@ -4044,8 +4051,7 @@ sparc_type_code (type)\n    (to store insns).  This is a bit excessive.  Perhaps a different\n    mechanism would be better here.\n \n-   Emit 3 FLUSH instructions (UNSPEC_VOLATILE 3) to synchonize the data\n-   and instruction caches.\n+   Emit 3 FLUSH instructions to synchonize the data and instruction caches.\n \n    ??? v9: We assume the top 32 bits of function addresses are 0.  */\n \n@@ -4080,15 +4086,11 @@ sparc_initialize_trampoline (tramp, fnaddr, cxt)\n   emit_move_insn (tem, g2_ori);\n   emit_insn (gen_iorsi3 (low_cxt, low_cxt, tem));\n   emit_move_insn (gen_rtx (MEM, SImode, plus_constant (tramp, 16)), low_cxt);\n-  emit_insn (gen_rtx (UNSPEC_VOLATILE, VOIDmode,\n-\t\t      gen_rtvec (1, plus_constant (tramp, 0)),\n-\t\t      3));\n-  emit_insn (gen_rtx (UNSPEC_VOLATILE, VOIDmode,\n-\t\t      gen_rtvec (1, plus_constant (tramp, 8)),\n-\t\t      3));\n-  emit_insn (gen_rtx (UNSPEC_VOLATILE, VOIDmode,\n-\t\t      gen_rtvec (1, plus_constant (tramp, 16)),\n-\t\t      3));\n+  emit_insn (gen_flush (validize_mem (gen_rtx (MEM, SImode, tramp))));\n+  emit_insn (gen_flush (validize_mem (gen_rtx (MEM, SImode,\n+\t\t\t\t\t       plus_constant (tramp, 8)))));\n+  emit_insn (gen_flush (validize_mem (gen_rtx (MEM, SImode,\n+\t\t\t\t\t       plus_constant (tramp, 16)))));\n }\n \n void"}]}