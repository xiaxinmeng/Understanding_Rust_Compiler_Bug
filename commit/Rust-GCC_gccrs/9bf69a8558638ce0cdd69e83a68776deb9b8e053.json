{"sha": "9bf69a8558638ce0cdd69e83a68776deb9b8e053", "node_id": "C_kwDOANBUbNoAKDliZjY5YTg1NTg2MzhjZTBjZGQ2OWU4M2E2ODc3NmRlYjliOGUwNTM", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-10-16T04:04:25Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-11-24T01:25:47Z"}, "message": "timevar: Add auto_cond_timevar class\n\nThe auto_timevar sentinel class for starting and stopping timevars was added\nin 2014, but doesn't work for the many uses of timevar_cond_start/stop in\nthe C++ front end.  So let's add one that does.\n\nThis allows us to remove a lot of wrapper functions that were just used to\ncall timevar_cond_stop on all exits from the function.\n\ngcc/ChangeLog:\n\n\t* timevar.h (class auto_cond_timevar): New.\n\ngcc/cp/ChangeLog:\n\n\t* call.c\n\t* decl.c\n\t* name-lookup.c:\n\tUse auto_cond_timevar instead of timevar_cond_start/stop.\n\tRemove wrapper functions.", "tree": {"sha": "da3c262a201ef128d64aaf930512fc4767eb2ea8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da3c262a201ef128d64aaf930512fc4767eb2ea8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bf69a8558638ce0cdd69e83a68776deb9b8e053", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bf69a8558638ce0cdd69e83a68776deb9b8e053", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bf69a8558638ce0cdd69e83a68776deb9b8e053", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bf69a8558638ce0cdd69e83a68776deb9b8e053/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7df89377a7ae3906255e38a79be8e5d962c3a0df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7df89377a7ae3906255e38a79be8e5d962c3a0df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7df89377a7ae3906255e38a79be8e5d962c3a0df"}], "stats": {"total": 441, "additions": 149, "deletions": 292}, "files": [{"sha": "27f4d9e77870c6d1100016e27c88a673a9293df0", "filename": "gcc/cp/call.c", "status": "modified", "additions": 28, "deletions": 78, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf69a8558638ce0cdd69e83a68776deb9b8e053/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf69a8558638ce0cdd69e83a68776deb9b8e053/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=9bf69a8558638ce0cdd69e83a68776deb9b8e053", "patch": "@@ -4432,7 +4432,7 @@ build_user_type_conversion (tree totype, tree expr, int flags,\n   struct z_candidate *cand;\n   tree ret;\n \n-  bool subtime = timevar_cond_start (TV_OVERLOAD);\n+  auto_cond_timevar tv (TV_OVERLOAD);\n   cand = build_user_type_conversion_1 (totype, expr, flags, complain);\n \n   if (cand)\n@@ -4448,7 +4448,6 @@ build_user_type_conversion (tree totype, tree expr, int flags,\n   else\n     ret = NULL_TREE;\n \n-  timevar_cond_stop (TV_OVERLOAD, subtime);\n   return ret;\n }\n \n@@ -4688,7 +4687,7 @@ perform_overload_resolution (tree fn,\n   tree explicit_targs;\n   int template_only;\n \n-  bool subtime = timevar_cond_start (TV_OVERLOAD);\n+  auto_cond_timevar tv (TV_OVERLOAD);\n \n   explicit_targs = NULL_TREE;\n   template_only = 0;\n@@ -4720,7 +4719,6 @@ perform_overload_resolution (tree fn,\n   else\n     cand = NULL;\n \n-  timevar_cond_stop (TV_OVERLOAD, subtime);\n   return cand;\n }\n \n@@ -4985,15 +4983,17 @@ build_operator_new_call (tree fnname, vec<tree, va_gc> **args,\n \n /* Build a new call to operator().  This may change ARGS.  */\n \n-static tree\n-build_op_call_1 (tree obj, vec<tree, va_gc> **args, tsubst_flags_t complain)\n+tree\n+build_op_call (tree obj, vec<tree, va_gc> **args, tsubst_flags_t complain)\n {\n   struct z_candidate *candidates = 0, *cand;\n   tree fns, convs, first_mem_arg = NULL_TREE;\n   bool any_viable_p;\n   tree result = NULL_TREE;\n   void *p;\n \n+  auto_cond_timevar tv (TV_OVERLOAD);\n+\n   obj = mark_lvalue_use (obj);\n \n   if (error_operand_p (obj))\n@@ -5123,18 +5123,6 @@ build_op_call_1 (tree obj, vec<tree, va_gc> **args, tsubst_flags_t complain)\n   return result;\n }\n \n-/* Wrapper for above.  */\n-\n-tree\n-build_op_call (tree obj, vec<tree, va_gc> **args, tsubst_flags_t complain)\n-{\n-  tree ret;\n-  bool subtime = timevar_cond_start (TV_OVERLOAD);\n-  ret = build_op_call_1 (obj, args, complain);\n-  timevar_cond_stop (TV_OVERLOAD, subtime);\n-  return ret;\n-}\n-\n /* Called by op_error to prepare format strings suitable for the error\n    function.  It concatenates a prefix (controlled by MATCH), ERRMSG,\n    and a suffix (controlled by NTYPES).  */\n@@ -5326,10 +5314,10 @@ conditional_conversion (tree e1, tree e2, tsubst_flags_t complain)\n /* Implement [expr.cond].  ARG1, ARG2, and ARG3 are the three\n    arguments to the conditional expression.  */\n \n-static tree\n-build_conditional_expr_1 (const op_location_t &loc,\n-\t\t\t  tree arg1, tree arg2, tree arg3,\n-                          tsubst_flags_t complain)\n+tree\n+build_conditional_expr (const op_location_t &loc,\n+\t\t\ttree arg1, tree arg2, tree arg3,\n+\t\t\ttsubst_flags_t complain)\n {\n   tree arg2_type;\n   tree arg3_type;\n@@ -5341,6 +5329,8 @@ build_conditional_expr_1 (const op_location_t &loc,\n   void *p;\n   tree orig_arg2, orig_arg3;\n \n+  auto_cond_timevar tv (TV_OVERLOAD);\n+\n   /* As a G++ extension, the second argument to the conditional can be\n      omitted.  (So that `a ? : c' is roughly equivalent to `a ? a :\n      c'.)  If the second operand is omitted, make sure it is\n@@ -5406,8 +5396,8 @@ build_conditional_expr_1 (const op_location_t &loc,\n \t  && !VECTOR_TYPE_P (arg3_type))\n \t{\n \t  /* Rely on the error messages of the scalar version.  */\n-\t  tree scal = build_conditional_expr_1 (loc, integer_one_node,\n-\t\t\t\t\t\torig_arg2, orig_arg3, complain);\n+\t  tree scal = build_conditional_expr (loc, integer_one_node,\n+\t\t\t\t\t      orig_arg2, orig_arg3, complain);\n \t  if (scal == error_mark_node)\n \t    return error_mark_node;\n \t  tree stype = TREE_TYPE (scal);\n@@ -5964,20 +5954,6 @@ build_conditional_expr_1 (const op_location_t &loc,\n   return result;\n }\n \n-/* Wrapper for above.  */\n-\n-tree\n-build_conditional_expr (const op_location_t &loc,\n-\t\t\ttree arg1, tree arg2, tree arg3,\n-                        tsubst_flags_t complain)\n-{\n-  tree ret;\n-  bool subtime = timevar_cond_start (TV_OVERLOAD);\n-  ret = build_conditional_expr_1 (loc, arg1, arg2, arg3, complain);\n-  timevar_cond_stop (TV_OVERLOAD, subtime);\n-  return ret;\n-}\n-\n /* OPERAND is an operand to an expression.  Perform necessary steps\n    required before using it.  If OPERAND is NULL_TREE, NULL_TREE is\n    returned.  */\n@@ -6479,10 +6455,10 @@ add_operator_candidates (z_candidate **candidates,\n   return NULL_TREE;\n }\n \n-static tree\n-build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n-\t\ttree arg1, tree arg2, tree arg3, tree *overload,\n-\t\ttsubst_flags_t complain)\n+tree\n+build_new_op (const op_location_t &loc, enum tree_code code, int flags,\n+\t      tree arg1, tree arg2, tree arg3, tree *overload,\n+\t      tsubst_flags_t complain)\n {\n   struct z_candidate *candidates = 0, *cand;\n   vec<tree, va_gc> *arglist;\n@@ -6496,6 +6472,8 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n   bool strict_p;\n   bool any_viable_p;\n \n+  auto_cond_timevar tv (TV_OVERLOAD);\n+\n   if (error_operand_p (arg1)\n       || error_operand_p (arg2)\n       || error_operand_p (arg3))\n@@ -6631,8 +6609,8 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n \t    code = PREINCREMENT_EXPR;\n \t  else\n \t    code = PREDECREMENT_EXPR;\n-\t  result = build_new_op_1 (loc, code, flags, arg1, NULL_TREE,\n-\t\t\t\t   NULL_TREE, overload, complain);\n+\t  result = build_new_op (loc, code, flags, arg1, NULL_TREE,\n+\t\t\t\t NULL_TREE, overload, complain);\n \t  break;\n \n \t  /* The caller will deal with these.  */\n@@ -6954,21 +6932,6 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n   return NULL_TREE;\n }\n \n-/* Wrapper for above.  */\n-\n-tree\n-build_new_op (const op_location_t &loc, enum tree_code code, int flags,\n-\t      tree arg1, tree arg2, tree arg3,\n-\t      tree *overload, tsubst_flags_t complain)\n-{\n-  tree ret;\n-  bool subtime = timevar_cond_start (TV_OVERLOAD);\n-  ret = build_new_op_1 (loc, code, flags, arg1, arg2, arg3,\n-\t\t\toverload, complain);\n-  timevar_cond_stop (TV_OVERLOAD, subtime);\n-  return ret;\n-}\n-\n /* CALL was returned by some call-building function; extract the actual\n    CALL_EXPR from any bits that have been tacked on, e.g. by\n    convert_from_reference.  */\n@@ -10694,10 +10657,10 @@ complain_about_no_candidates_for_method_call (tree instance,\n    be set, upon return, to the function called.  ARGS may be NULL.\n    This may change ARGS.  */\n \n-static tree\n-build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n-\t\t         tree conversion_path, int flags,\n-\t\t         tree *fn_p, tsubst_flags_t complain)\n+tree\n+build_new_method_call (tree instance, tree fns, vec<tree, va_gc> **args,\n+\t\t       tree conversion_path, int flags,\n+\t\t       tree *fn_p, tsubst_flags_t complain)\n {\n   struct z_candidate *candidates = 0, *cand;\n   tree explicit_targs = NULL_TREE;\n@@ -10717,6 +10680,8 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n   vec<tree, va_gc> *orig_args = NULL;\n   void *p;\n \n+  auto_cond_timevar tv (TV_OVERLOAD);\n+\n   gcc_assert (instance != NULL_TREE);\n \n   /* We don't know what function we're going to call, yet.  */\n@@ -11096,21 +11061,6 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n   return call;\n }\n \n-/* Wrapper for above.  */\n-\n-tree\n-build_new_method_call (tree instance, tree fns, vec<tree, va_gc> **args,\n-\t\t       tree conversion_path, int flags,\n-\t\t       tree *fn_p, tsubst_flags_t complain)\n-{\n-  tree ret;\n-  bool subtime = timevar_cond_start (TV_OVERLOAD);\n-  ret = build_new_method_call_1 (instance, fns, args, conversion_path, flags,\n-                                 fn_p, complain);\n-  timevar_cond_stop (TV_OVERLOAD, subtime);\n-  return ret;\n-}\n-\n /* Returns true iff standard conversion sequence ICS1 is a proper\n    subsequence of ICS2.  */\n "}, {"sha": "375079f0f68cd64216dfaf3b66952a2c5f44aef2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 13, "deletions": 38, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf69a8558638ce0cdd69e83a68776deb9b8e053/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf69a8558638ce0cdd69e83a68776deb9b8e053/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9bf69a8558638ce0cdd69e83a68776deb9b8e053", "patch": "@@ -598,7 +598,7 @@ poplevel (int keep, int reverse, int functionbody)\n   tree decl;\n   scope_kind kind;\n \n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n  restart:\n \n   block = NULL_TREE;\n@@ -830,7 +830,6 @@ poplevel (int keep, int reverse, int functionbody)\n   if (kind == sk_cleanup)\n     goto restart;\n \n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return block;\n }\n \n@@ -909,7 +908,7 @@ static GTY((deletable)) vec<tree, va_gc> *local_entities;\n void\n determine_local_discriminator (tree decl)\n {\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n   retrofit_lang_decl (decl);\n   tree ctx = DECL_CONTEXT (decl);\n   tree name = (TREE_CODE (decl) == TYPE_DECL\n@@ -944,8 +943,6 @@ determine_local_discriminator (tree decl)\n       local_entities->quick_push (decl);\n       local_entities->quick_push (name);\n     }\n-\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n \n \f\n@@ -3284,6 +3281,8 @@ named_label_hash::equal (const value_type entry, compare_type name)\n static named_label_entry *\n lookup_label_1 (tree id, bool making_local_p)\n {\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n+\n   /* You can't use labels at global scope.  */\n   if (current_function_decl == NULL_TREE)\n     {\n@@ -3346,18 +3345,14 @@ lookup_label_1 (tree id, bool making_local_p)\n tree\n lookup_label (tree id)\n {\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n   named_label_entry *ent = lookup_label_1 (id, false);\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return ent ? ent->label_decl : NULL_TREE;\n }\n \n tree\n declare_local_label (tree id)\n {\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n   named_label_entry *ent = lookup_label_1 (id, true);\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return ent ? ent->label_decl : NULL_TREE;\n }\n \n@@ -3688,9 +3683,11 @@ check_omp_return (void)\n /* Define a label, specifying the location in the source file.\n    Return the LABEL_DECL node for the label.  */\n \n-static tree\n-define_label_1 (location_t location, tree name)\n+tree\n+define_label (location_t location, tree name)\n {\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n+\n   /* After labels, make any new cleanups in the function go into their\n      own new (temporary) binding contour.  */\n   for (cp_binding_level *p = current_binding_level;\n@@ -3724,18 +3721,6 @@ define_label_1 (location_t location, tree name)\n   return decl;\n }\n \n-/* Wrapper for define_label_1.  */\n-\n-tree\n-define_label (location_t location, tree name)\n-{\n-  bool running = timevar_cond_start (TV_NAME_LOOKUP);\n-  tree ret = define_label_1 (location, name);\n-  timevar_cond_stop (TV_NAME_LOOKUP, running);\n-  return ret;\n-}\n-\n-\n struct cp_switch\n {\n   cp_binding_level *level;\n@@ -15499,13 +15484,15 @@ lookup_and_check_tag (enum tag_types tag_code, tree name,\n    TEMPLATE_HEADER_P is true when this declaration is preceded by\n    a set of template parameters.  */\n \n-static tree\n-xref_tag_1 (enum tag_types tag_code, tree name,\n-            TAG_how how, bool template_header_p)\n+tree\n+xref_tag (enum tag_types tag_code, tree name,\n+\t  TAG_how how, bool template_header_p)\n {\n   enum tree_code code;\n   tree context = NULL_TREE;\n \n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n+\n   gcc_assert (identifier_p (name));\n \n   switch (tag_code)\n@@ -15654,18 +15641,6 @@ xref_tag_1 (enum tag_types tag_code, tree name,\n   return t;\n }\n \n-/* Wrapper for xref_tag_1.  */\n-\n-tree\n-xref_tag (enum tag_types tag_code, tree name,\n-\t  TAG_how how, bool template_header_p)\n-{\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  tree ret = xref_tag_1 (tag_code, name, how, template_header_p);\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-  return ret;\n-}\n-\n /* Create the binfo hierarchy for REF with (possibly NULL) base list\n    BASE_LIST.  For each element on BASE_LIST the TREE_PURPOSE is an\n    access_* node, and the TREE_VALUE is the type of the base-class."}, {"sha": "080692899a81d73ae879b366a90e1b1acef5db8e", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 66, "deletions": 174, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf69a8558638ce0cdd69e83a68776deb9b8e053/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf69a8558638ce0cdd69e83a68776deb9b8e053/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=9bf69a8558638ce0cdd69e83a68776deb9b8e053", "patch": "@@ -39,7 +39,6 @@ along with GCC; see the file COPYING3.  If not see\n \n static cxx_binding *cxx_binding_make (tree value, tree type);\n static cp_binding_level *innermost_nonclass_level (void);\n-static tree do_pushdecl (tree decl, bool hiding);\n static void set_identifier_type_value_with_scope (tree id, tree decl,\n \t\t\t\t\t\t  cp_binding_level *b);\n static name_hint maybe_suggest_missing_std_header (location_t location,\n@@ -1725,11 +1724,9 @@ static void diagnose_name_conflict (tree, tree);\n tree\n lookup_arg_dependent (tree name, tree fns, vec<tree, va_gc> *args)\n {\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n   name_lookup lookup (name);\n-  fns = lookup.search_adl (fns, args);\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-  return fns;\n+  return lookup.search_adl (fns, args);\n }\n \n /* FNS is an overload set of conversion functions.  Return the\n@@ -2595,8 +2592,10 @@ anticipated_builtin_p (tree ovl)\n    was successful.  */\n \n static bool\n-supplement_binding_1 (cxx_binding *binding, tree decl)\n+supplement_binding (cxx_binding *binding, tree decl)\n {\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n+\n   tree bval = binding->value;\n   bool ok = true;\n   tree target_bval = strip_using_decl (bval);\n@@ -2736,18 +2735,6 @@ diagnose_name_conflict (tree decl, tree bval)\n   inform (location_of (bval), \"previous declaration %q#D\", bval);\n }\n \n-/* Wrapper for supplement_binding_1.  */\n-\n-static bool\n-supplement_binding (cxx_binding *binding, tree decl)\n-{\n-  bool ret;\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  ret = supplement_binding_1 (binding, decl);\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-  return ret;\n-}\n-\n /* Replace BINDING's current value on its scope's name list with\n    NEWVAL.  */\n \n@@ -3472,7 +3459,7 @@ push_local_extern_decl_alias (tree decl)\n \t  /* Expected default linkage is from the namespace.  */\n \t  TREE_PUBLIC (alias) = TREE_PUBLIC (ns);\n \t  push_nested_namespace (ns);\n-\t  alias = do_pushdecl (alias, /* hiding= */true);\n+\t  alias = pushdecl (alias, /* hiding= */true);\n \t  pop_nested_namespace (ns);\n \t  if (VAR_P (decl)\n \t      && CP_DECL_THREAD_LOCAL_P (decl)\n@@ -3620,16 +3607,20 @@ check_module_override (tree decl, tree mvec, bool hiding,\n \n /* Record DECL as belonging to the current lexical scope.  Check for\n    errors (such as an incompatible declaration for the same name\n-   already seen in the same scope).  IS_FRIEND is true if DECL is\n-   declared as a friend.\n+   already seen in the same scope).\n+\n+   The new binding is hidden if HIDING is true (an anticipated builtin\n+   or hidden friend).\n \n    Returns either DECL or an old decl for the same name.  If an old\n    decl is returned, it may have been smashed to agree with what DECL\n    says.  */\n \n-static tree\n-do_pushdecl (tree decl, bool hiding)\n+tree\n+pushdecl (tree decl, bool hiding)\n {\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n+\n   if (decl == error_mark_node)\n     return error_mark_node;\n \n@@ -3845,19 +3836,6 @@ do_pushdecl (tree decl, bool hiding)\n   return decl;\n }\n \n-/* Record a decl-node X as belonging to the current lexical scope.\n-   The new binding is hidden if HIDING is true (an anticipated builtin\n-   or hidden friend).   */\n-\n-tree\n-pushdecl (tree x, bool hiding)\n-{\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  tree ret = do_pushdecl (x, hiding);\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-  return ret;\n-}\n-\n /* A mergeable entity is being loaded into namespace NS slot NAME.\n    Create and return the appropriate vector slot for that.  Either a\n    GMF slot or a module-specific one.  */\n@@ -4786,7 +4764,7 @@ do_pushdecl_with_scope (tree x, cp_binding_level *level, bool hiding = false)\n \tcurrent_function_decl = NULL_TREE;\n       b = current_binding_level;\n       current_binding_level = level;\n-      x = do_pushdecl (x, hiding);\n+      x = pushdecl (x, hiding);\n       current_binding_level = b;\n       current_function_decl = function_decl;\n     }\n@@ -4799,17 +4777,14 @@ tree\n pushdecl_outermost_localscope (tree x)\n {\n   cp_binding_level *b = NULL;\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n \n   /* Find the scope just inside the function parms.  */\n   for (cp_binding_level *n = current_binding_level;\n        n->kind != sk_function_parms; n = b->level_chain)\n     b = n;\n \n-  tree ret = b ? do_pushdecl_with_scope (x, b) : error_mark_node;\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-\n-  return ret;\n+  return b ? do_pushdecl_with_scope (x, b) : error_mark_node;\n }\n \n /* Process a local-scope or namespace-scope using declaration.  LOOKUP\n@@ -5198,7 +5173,7 @@ poplevel_class (void)\n   size_t i;\n   tree shadowed;\n \n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n   gcc_assert (level != 0);\n \n   /* If we're leaving a toplevel class, cache its binding level.  */\n@@ -5225,7 +5200,6 @@ poplevel_class (void)\n      `pushlevel_class' routine.  */\n   gcc_assert (current_binding_level == level);\n   leave_scope ();\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n \n /* Set INHERITED_VALUE_BINDING_P on BINDING to true or false, as\n@@ -5268,14 +5242,13 @@ bool\n pushdecl_class_level (tree x)\n {\n   bool is_valid = true;\n-  bool subtime;\n \n   /* Do nothing if we're adding to an outer lambda closure type,\n      outer_binding will add it later if it's needed.  */\n   if (current_class_type != class_binding_level->this_entity)\n     return true;\n \n-  subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n   /* Get the name of X.  */\n   tree name = OVL_NAME (x);\n \n@@ -5315,7 +5288,6 @@ pushdecl_class_level (tree x)\n \t    }\n       input_location = save_location;\n     }\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return is_valid;\n }\n \n@@ -5361,13 +5333,15 @@ get_class_binding (tree name, cp_binding_level *scope)\n /* Make the declaration(s) of X appear in CLASS scope under the name\n    NAME.  Returns true if the binding is valid.  */\n \n-static bool\n-push_class_level_binding_1 (tree name, tree x)\n+bool\n+push_class_level_binding (tree name, tree x)\n {\n   cxx_binding *binding;\n   tree decl = x;\n   bool ok;\n \n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n+\n   /* The class_binding_level will be NULL if x is a template\n      parameter name in a member template.  */\n   if (!class_binding_level)\n@@ -5539,18 +5513,6 @@ push_class_level_binding_1 (tree name, tree x)\n   return ok;\n }\n \n-/* Wrapper for push_class_level_binding_1.  */\n-\n-bool\n-push_class_level_binding (tree name, tree x)\n-{\n-  bool ret;\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  ret = push_class_level_binding_1 (name, x);\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-  return ret;\n-}\n-\n /* Process and lookup a using decl SCOPE::lookup.name, filling in\n    lookup.values & lookup.type.  Return a USING_DECL, or NULL_TREE on\n    failure.  */\n@@ -5794,7 +5756,7 @@ do_class_using_decl (tree scope, tree name)\n tree\n get_namespace_binding (tree ns, tree name)\n {\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n   if (!ns)\n     ns = global_namespace;\n   gcc_checking_assert (!DECL_NAMESPACE_ALIAS (ns));\n@@ -5810,7 +5772,6 @@ get_namespace_binding (tree ns, tree name)\n \tret = MAYBE_STAT_DECL (ret);\n     }\n \n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return ret;\n }\n \n@@ -5821,7 +5782,7 @@ get_namespace_binding (tree ns, tree name)\n void\n set_global_binding (tree decl)\n {\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n \n   tree *slot = find_namespace_slot (global_namespace, DECL_NAME (decl), true);\n \n@@ -5831,8 +5792,6 @@ set_global_binding (tree decl)\n \n   /* Force the binding, so compiler internals continue to work.  */\n   *slot = decl;\n-\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n \n /* Set the context of a declaration to scope. Complain if we are not\n@@ -6125,11 +6084,9 @@ do_namespace_alias (tree alias, tree name_space)\n tree\n pushdecl_namespace_level (tree decl, bool hiding)\n {\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  tree res = do_pushdecl_with_scope (decl, NAMESPACE_LEVEL (current_namespace),\n-\t\t\t\t     hiding);\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-  return res;\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n+  return do_pushdecl_with_scope (decl, NAMESPACE_LEVEL (current_namespace),\n+\t\t\t\t hiding);\n }\n \n /* Wrapper around push_local_binding to push the bindings for\n@@ -7692,11 +7649,13 @@ innermost_non_namespace_value (tree name)\n    WANT can also have LOOK_want::HIDDEN_FRIEND or\n    LOOK_want::HIDDEN_LAMBDa added to it.  */\n \n-static tree\n-lookup_name_1 (tree name, LOOK_where where, LOOK_want want)\n+tree\n+lookup_name (tree name, LOOK_where where, LOOK_want want)\n {\n   tree val = NULL_TREE;\n \n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n+\n   gcc_checking_assert (unsigned (where) != 0);\n   /* If we're looking for hidden lambda things, we shouldn't be\n      looking in namespace scope.  */\n@@ -7797,17 +7756,6 @@ lookup_name_1 (tree name, LOOK_where where, LOOK_want want)\n   return val;\n }\n \n-/* Wrapper for lookup_name_1.  */\n-\n-tree\n-lookup_name (tree name, LOOK_where where, LOOK_want want)\n-{\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  tree ret = lookup_name_1 (name, where, want);\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-  return ret;\n-}\n-\n tree\n lookup_name (tree name)\n {\n@@ -7827,9 +7775,11 @@ lookup_name (tree name)\n    A TYPE_DECL best matching the NAME is returned.  Catching error\n    and issuing diagnostics are caller's responsibility.  */\n \n-static tree\n-lookup_elaborated_type_1 (tree name, TAG_how how)\n+tree\n+lookup_elaborated_type (tree name, TAG_how how)\n {\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n+\n   cp_binding_level *b = current_binding_level;\n \n   if (b->kind != sk_namespace)\n@@ -8013,17 +7963,6 @@ lookup_elaborated_type_1 (tree name, TAG_how how)\n   return NULL_TREE;\n }\n \n-/* Wrapper for lookup_type_scope_1.  */\n-\n-tree\n-lookup_elaborated_type (tree name, TAG_how how)\n-{\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  tree ret = lookup_elaborated_type_1 (name, how);\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-  return ret;\n-}\n-\n /* The type TYPE is being declared.  If it is a class template, or a\n    specialization of a class template, do any processing required and\n    perform error-checking.  If IS_FRIEND is nonzero, this TYPE is\n@@ -8101,13 +8040,15 @@ maybe_process_template_type_declaration (tree type, int is_friend,\n \n    Returns TYPE upon success and ERROR_MARK_NODE otherwise.  */\n \n-static tree\n-do_pushtag (tree name, tree type, TAG_how how)\n+tree\n+pushtag (tree name, tree type, TAG_how how)\n {\n   tree decl;\n \n   gcc_assert (identifier_p (name));\n \n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n+\n   cp_binding_level *b = current_binding_level;\n   while (true)\n     {\n@@ -8251,18 +8192,6 @@ do_pushtag (tree name, tree type, TAG_how how)\n \n   return type;\n }\n-\n-/* Wrapper for do_pushtag.  */\n-\n-tree\n-pushtag (tree name, tree type, TAG_how how)\n-{\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  tree ret = do_pushtag (name, type, how);\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-  return ret;\n-}\n-\n \f\n /* Subroutines for reverting temporarily to top-level for instantiation\n    of templates and such.  We actually need to clear out the class- and\n@@ -8311,7 +8240,7 @@ store_bindings (tree names, vec<cxx_saved_binding, va_gc> **old_bindings)\n   tree t, id;\n   size_t i;\n \n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n   for (t = names; t; t = TREE_CHAIN (t))\n     {\n       if (TREE_CODE (t) == TREE_LIST)\n@@ -8333,7 +8262,6 @@ store_bindings (tree names, vec<cxx_saved_binding, va_gc> **old_bindings)\n \t}\n       bindings_need_stored.truncate (0);\n     }\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n \n /* Like store_bindings, but NAMES is a vector of cp_class_binding\n@@ -8364,15 +8292,17 @@ store_class_bindings (vec<cp_class_binding, va_gc> *names,\n \n static GTY((deletable)) struct saved_scope *free_saved_scope;\n \n-static void\n-do_push_to_top_level (void)\n+void\n+push_to_top_level (void)\n {\n   struct saved_scope *s;\n   cp_binding_level *b;\n   cxx_saved_binding *sb;\n   size_t i;\n   bool need_pop;\n \n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n+\n   /* Reuse or create a new structure for this saved scope.  */\n   if (free_saved_scope != NULL)\n     {\n@@ -8450,13 +8380,15 @@ do_push_to_top_level (void)\n   suppress_location_wrappers = 0;\n }\n \n-static void\n-do_pop_from_top_level (void)\n+void\n+pop_from_top_level (void)\n {\n   struct saved_scope *s = scope_chain;\n   cxx_saved_binding *saved;\n   size_t i;\n \n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n+\n   /* Clear out class-level bindings cache.  */\n   if (previous_class_level)\n     invalidate_class_lookup_cache ();\n@@ -8491,14 +8423,15 @@ do_pop_from_top_level (void)\n /* Push into the scope of the namespace NS, even if it is deeply\n    nested within another namespace.  */\n \n-static void\n-do_push_nested_namespace (tree ns)\n+void\n+push_nested_namespace (tree ns)\n {\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n   if (ns == global_namespace)\n-    do_push_to_top_level ();\n+    push_to_top_level ();\n   else\n     {\n-      do_push_nested_namespace (CP_DECL_CONTEXT (ns));\n+      push_nested_namespace (CP_DECL_CONTEXT (ns));\n       resume_scope (NAMESPACE_LEVEL (ns));\n       current_namespace = ns;\n     }\n@@ -8507,17 +8440,18 @@ do_push_nested_namespace (tree ns)\n /* Pop back from the scope of the namespace NS, which was previously\n    entered with push_nested_namespace.  */\n \n-static void\n-do_pop_nested_namespace (tree ns)\n+void\n+pop_nested_namespace (tree ns)\n {\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n   while (ns != global_namespace)\n     {\n       ns = CP_DECL_CONTEXT (ns);\n       current_namespace = ns;\n       leave_scope ();\n     }\n \n-  do_pop_from_top_level ();\n+  pop_from_top_level ();\n }\n \n /* Add TARGET to USINGS, if it does not already exist there.  We used\n@@ -8597,13 +8531,12 @@ finish_using_directive (tree target, tree attribs)\n tree\n pushdecl_top_level (tree x)\n {\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  do_push_to_top_level ();\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n+  push_to_top_level ();\n   gcc_checking_assert (!DECL_CONTEXT (x));\n   DECL_CONTEXT (x) = FROB_CONTEXT (global_namespace);\n   x = pushdecl_namespace_level (x);\n-  do_pop_from_top_level ();\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  pop_from_top_level ();\n   return x;\n }\n \n@@ -8613,14 +8546,13 @@ pushdecl_top_level (tree x)\n tree\n pushdecl_top_level_and_finish (tree x, tree init)\n {\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  do_push_to_top_level ();\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n+  push_to_top_level ();\n   gcc_checking_assert (!DECL_CONTEXT (x));\n   DECL_CONTEXT (x) = FROB_CONTEXT (global_namespace);\n   x = pushdecl_namespace_level (x);\n   cp_finish_decl (x, init, false, NULL_TREE, 0);\n-  do_pop_from_top_level ();\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  pop_from_top_level ();\n   return x;\n }\n \n@@ -8730,7 +8662,7 @@ make_namespace_finish (tree ns, tree *slot, bool from_import = false)\n int\n push_namespace (tree name, bool make_inline)\n {\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n   int count = 0;\n \n   /* We should not get here if the global_namespace is not yet constructed\n@@ -8877,7 +8809,6 @@ push_namespace (tree name, bool make_inline)\n       count++;\n     }\n \n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return count;\n }\n \n@@ -8886,14 +8817,12 @@ push_namespace (tree name, bool make_inline)\n void\n pop_namespace (void)\n {\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  auto_cond_timevar tv (TV_NAME_LOOKUP);\n \n   gcc_assert (current_namespace != global_namespace);\n   current_namespace = CP_DECL_CONTEXT (current_namespace);\n   /* The binding level is not popped, as it might be re-opened later.  */\n   leave_scope ();\n-\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n \n /* An IMPORT is an import that is defining namespace NAME inside CTX.  Find or\n@@ -8960,43 +8889,6 @@ add_imported_namespace (tree ctx, tree name, location_t loc, unsigned import,\n   return decl;\n }\n \n-/* External entry points for do_{push_to/pop_from}_top_level.  */\n-\n-void\n-push_to_top_level (void)\n-{\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  do_push_to_top_level ();\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-}\n-\n-void\n-pop_from_top_level (void)\n-{\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  do_pop_from_top_level ();\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-}\n-\n-/* External entry points for do_{push,pop}_nested_namespace.  */\n-\n-void\n-push_nested_namespace (tree ns)\n-{\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  do_push_nested_namespace (ns);\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-}\n-\n-void\n-pop_nested_namespace (tree ns)\n-{\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  gcc_assert (current_namespace == ns);\n-  do_pop_nested_namespace (ns);\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-}\n-\n /* Pop off extraneous binding levels left over due to syntax errors.\n    We don't pop past namespaces, as they might be valid.  */\n "}, {"sha": "ccaa42e590442d204aac96393204a170af0df4b5", "filename": "gcc/timevar.h", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf69a8558638ce0cdd69e83a68776deb9b8e053/gcc%2Ftimevar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf69a8558638ce0cdd69e83a68776deb9b8e053/gcc%2Ftimevar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.h?ref=9bf69a8558638ce0cdd69e83a68776deb9b8e053", "patch": "@@ -247,13 +247,53 @@ class auto_timevar\n       m_timer->pop (m_tv);\n   }\n \n+  // Disallow copies.\n+  auto_timevar (const auto_timevar &) = delete;\n+\n  private:\n+  timer *m_timer;\n+  timevar_id_t m_tv;\n+};\n+\n+// As above, but use cond_start/stop.\n+class auto_cond_timevar\n+{\n+ public:\n+  auto_cond_timevar (timer *t, timevar_id_t tv)\n+    : m_timer (t),\n+      m_tv (tv)\n+  {\n+    start ();\n+  }\n+\n+  explicit auto_cond_timevar (timevar_id_t tv)\n+    : m_timer (g_timer)\n+    , m_tv (tv)\n+  {\n+    start ();\n+  }\n+\n+  ~auto_cond_timevar ()\n+  {\n+    if (m_timer && !already_running)\n+      m_timer->cond_stop (m_tv);\n+  }\n+\n+  // Disallow copies.\n+  auto_cond_timevar (const auto_cond_timevar &) = delete;\n \n-  // Private to disallow copies.\n-  auto_timevar (const auto_timevar &);\n+ private:\n+  void start()\n+  {\n+    if (m_timer)\n+      already_running = m_timer->cond_start (m_tv);\n+    else\n+      already_running = false;\n+  }\n \n   timer *m_timer;\n   timevar_id_t m_tv;\n+  bool already_running;\n };\n \n extern void print_time (const char *, long);"}]}