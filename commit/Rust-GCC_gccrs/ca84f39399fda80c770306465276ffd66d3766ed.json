{"sha": "ca84f39399fda80c770306465276ffd66d3766ed", "node_id": "C_kwDOANBUbNoAKGNhODRmMzkzOTlmZGE4MGM3NzAzMDY0NjUyNzZmZmQ2NmQzNzY2ZWQ", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-10-31T22:14:29Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-10-31T22:14:29Z"}, "message": "Improve handling of return slot in ipa-pure-const and modref.\n\nwhile preparing testcase for return slot tracking I noticed that both\nipa-pure-const and modref treat return slot writes as non-local which prevents\ndetecting functions as pure or not modifying global state.  Fixed by making\npoints_to_local_or_readonly_memory_p to special case return slot.  This is bit\nof a side case, but presently at all uses of\npoints_to_local_or_readonly_memory_p we want to handle return slot this way.\n\nI also noticed that we handle gimple copy unnecesarily pesimistically.  This\ndoes not make difference right now since we do no not track non-scalars, but\nI fixed it anyway.\n\nBootstrapped/regtested x86_64-linux, comitted.\n\ngcc/ChangeLog:\n\n\t* ipa-fnsummary.c: Include tree-dfa.h.\n\t(points_to_local_or_readonly_memory_p): Return true on return\n\tslot writes.\n\t* ipa-modref.c (analyze_ssa_name_flags): Fix handling of copy\n\tstatement.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/ipa/modref-1.C: New test.", "tree": {"sha": "6bb38a6cd317c43716c251388b7aa9b10c5302b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bb38a6cd317c43716c251388b7aa9b10c5302b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca84f39399fda80c770306465276ffd66d3766ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca84f39399fda80c770306465276ffd66d3766ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca84f39399fda80c770306465276ffd66d3766ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca84f39399fda80c770306465276ffd66d3766ed/comments", "author": null, "committer": null, "parents": [{"sha": "d41092ec52f46d2f4b08fff8d1519e50354331b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d41092ec52f46d2f4b08fff8d1519e50354331b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d41092ec52f46d2f4b08fff8d1519e50354331b0"}], "stats": {"total": 53, "additions": 51, "deletions": 2}, "files": [{"sha": "ac6eec30af88998f1c67ee727a2a6cf0d4d8ed27", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca84f39399fda80c770306465276ffd66d3766ed/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca84f39399fda80c770306465276ffd66d3766ed/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=ca84f39399fda80c770306465276ffd66d3766ed", "patch": "@@ -86,6 +86,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-into-ssa.h\"\n #include \"symtab-clones.h\"\n #include \"gimple-range.h\"\n+#include \"tree-dfa.h\"\n \n /* Summaries.  */\n fast_function_summary <ipa_fn_summary *, va_gc> *ipa_fn_summaries;\n@@ -2569,7 +2570,20 @@ points_to_local_or_readonly_memory_p (tree t)\n   if (integer_zerop (t))\n     return flag_delete_null_pointer_checks;\n   if (TREE_CODE (t) == SSA_NAME)\n-    return !ptr_deref_may_alias_global_p (t);\n+    {\n+      /* For IPA passes we can consinder accesses to return slot local\n+\t even if it is not local in the sense that memory is dead by\n+\t the end of founction.\n+\t The outer function will see a store in the call assignment\n+\t and thus this will do right thing for all uses of this\n+\t function in the current IPA passes (modref, pure/const discovery\n+\t and inlining heuristics).  */\n+      if (DECL_RESULT (current_function_decl)\n+\t  && DECL_BY_REFERENCE (DECL_RESULT (current_function_decl))\n+\t  && t == ssa_default_def (cfun, DECL_RESULT (current_function_decl)))\n+\treturn true;\n+      return !ptr_deref_may_alias_global_p (t);\n+    }\n   if (TREE_CODE (t) == ADDR_EXPR)\n     return refs_local_or_readonly_memory_p (TREE_OPERAND (t, 0));\n   return false;"}, {"sha": "d866d9ed6b3b768f0506619d40b5923fba951d8a", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca84f39399fda80c770306465276ffd66d3766ed/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca84f39399fda80c770306465276ffd66d3766ed/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=ca84f39399fda80c770306465276ffd66d3766ed", "patch": "@@ -1841,7 +1841,7 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t\t We do not track memory locations, so assume that value\n \t\t is used arbitrarily.  */\n \t      if (memory_access_to (gimple_assign_rhs1 (assign), name))\n-\t\tlattice[index].merge (0);\n+\t\tlattice[index].merge (deref_flags (0, false));\n \t      /* Handle *name = *exp.  */\n \t      else if (memory_access_to (gimple_assign_lhs (assign), name))\n \t\tlattice[index].merge_direct_store ();"}, {"sha": "1de9e1d06a57bd278b6ff748bc64ddd4d380e0ff", "filename": "gcc/testsuite/g++.dg/ipa/modref-1.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca84f39399fda80c770306465276ffd66d3766ed/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fmodref-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca84f39399fda80c770306465276ffd66d3766ed/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fmodref-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fmodref-1.C?ref=ca84f39399fda80c770306465276ffd66d3766ed", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do link } */\n+/* { dg-options \"-O2 -fdump-tree-local-pure-const1 -fdump-tree-modref1 -std=gnu++2a\"  } */\n+namespace {\n+struct B {\n+\tint b;\n+\tstruct B *bptr;\n+\tB() {b=1; }\n+\tB(B &src)\n+\t{\n+\t\tb=src.b;\n+\t\tbptr=0;\n+\t}\n+\t__attribute__ ((noinline))\n+\tstatic struct B genB()\n+\t{\n+\t\tstruct B b;\n+\t\tb.b=2;\n+\t\tb.bptr = 0;\n+\t\treturn b;\n+\t}\n+};\n+}\n+void linker_error ();\n+int main()\n+{\n+\tstruct B b1 = B::genB();\n+\tb1.b = 1;\n+\tstruct B b2 = B::genB();\n+\tif (b1.b != 1 || b2.bptr == &b2)\n+\t\tlinker_error ();\n+\treturn 0;\n+}\n+/* { dg-final { scan-ipa-dump \"Function found to be const: {anonymous}::B::genB\" \"local-pure-const1\"  } } */\n+/* { dg-final { scan-ipa-dump \"Retslot flags: direct noescape nodirectescape not_returned noread\" \"modref1\" } } */\n+  "}]}