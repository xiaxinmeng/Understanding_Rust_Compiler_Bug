{"sha": "4ce9a2d8c36d75dd21c8ba6ea6a25f7353e7f83d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNlOWEyZDhjMzZkNzVkZDIxYzhiYTZlYTZhMjVmNzM1M2U3ZjgzZA==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2007-12-13T10:24:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:24:53Z"}, "message": "exp_ch3.adb (Predefined_Primitive_Bodies): Generate the body of predefined primitive _Disp_Requeue.\n\n2007-12-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch3.adb (Predefined_Primitive_Bodies): Generate the body of\n\tpredefined primitive _Disp_Requeue.\n\t(Make_Predefined_Primitive_Specs): Create the spec for predefined\n\tprimitive _Disp_Requeue.\n\t(Make_Predefined_Primitive_Specs/Predefined_Primitive_Bodies): Set the\n\ttype of formal Renamed_Eq to Entity_Id (instead of Node_Id).\n\t(Make_Predefined_Primitive_Specs): Spec of \"=\" needed if the parent is\n\tan interface type. In case of limited interfaces we now declare all the\n\tpredefined primitives associated with synchronized interfaces as\n\tabstract.\n\t(Predef_Spec_Or_Body): For interface types generate abstract subprogram\n\tdeclarations.\n\t(Predefined_Primitive_Bodies): Add body of \"=\" if the parent of the\n\ttagged type is an interface type and there is no user-defined equality\n\tfunction.\n\tAdd also bodies of predefined primitives associated with synchronized\n\tinterfaces.\n\t(Freeze_Record_Type): Do not build bodies of predefined primitives of\n\tinterface types because they are now defined abstract.\n\tAdd missing documentation.\n\t(Expand_Record_Controller): Update occurrence of Related_Interface\n\tto Related_Type.\n\t(Build_Offset_To_Top_Functions): Do nothing in case of VM.\n\t(Expand_N_Object_Declaration): Take into account VM_Target when handling\n\tclass wide interface object declaration.\n\t(Expand_Previous_Access_Type): Do not create a duplicate master entity\n\tif the access type already has one.\n\t(Expand_N_Object_Declaration): Defend against attempt to validity check\n\tgeneric types. Noticed for -gnatVcf specified with previous errors.\n\nFrom-SVN: r130830", "tree": {"sha": "c152425e12839c35a0bfa682f630146e2310d4c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c152425e12839c35a0bfa682f630146e2310d4c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ce9a2d8c36d75dd21c8ba6ea6a25f7353e7f83d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ce9a2d8c36d75dd21c8ba6ea6a25f7353e7f83d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ce9a2d8c36d75dd21c8ba6ea6a25f7353e7f83d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ce9a2d8c36d75dd21c8ba6ea6a25f7353e7f83d/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e9a7121ec24926e485f7472cef776ef98c979547", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9a7121ec24926e485f7472cef776ef98c979547", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9a7121ec24926e485f7472cef776ef98c979547"}], "stats": {"total": 239, "additions": 171, "deletions": 68}, "files": [{"sha": "eae2c2fd5034d0bbfaf4961118cd5ab6bbee0ec4", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 171, "deletions": 68, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce9a2d8c36d75dd21c8ba6ea6a25f7353e7f83d/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce9a2d8c36d75dd21c8ba6ea6a25f7353e7f83d/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=4ce9a2d8c36d75dd21c8ba6ea6a25f7353e7f83d", "patch": "@@ -237,8 +237,11 @@ package body Exp_Ch3 is\n    procedure Make_Predefined_Primitive_Specs\n      (Tag_Typ     : Entity_Id;\n       Predef_List : out List_Id;\n-      Renamed_Eq  : out Node_Id);\n+      Renamed_Eq  : out Entity_Id);\n    --  Create a list with the specs of the predefined primitive operations.\n+   --  For tagged types that are interfaces all these primitives are defined\n+   --  abstract.\n+   --\n    --  The following entries are present for all tagged types, and provide\n    --  the results of the corresponding attribute applied to the object.\n    --  Dispatching is required in general, since the result of the attribute\n@@ -328,7 +331,7 @@ package body Exp_Ch3 is\n \n    function Predefined_Primitive_Bodies\n      (Tag_Typ    : Entity_Id;\n-      Renamed_Eq : Node_Id) return List_Id;\n+      Renamed_Eq : Entity_Id) return List_Id;\n    --  Create the bodies of the predefined primitives that are described in\n    --  Predefined_Primitive_Specs. When not empty, Renamed_Eq must denote\n    --  the defining unit name of the type's predefined equality as returned\n@@ -797,9 +800,8 @@ package body Exp_Ch3 is\n             --  If we fall off the top, we are at the outer level, and the\n             --  environment task is our effective master, so nothing to mark.\n \n-            if Nkind (Par) = N_Task_Body\n-              or else Nkind (Par) = N_Block_Statement\n-              or else Nkind (Par) = N_Subprogram_Body\n+            if Nkind_In\n+                (Par, N_Task_Body, N_Block_Statement, N_Subprogram_Body)\n             then\n                Set_Is_Task_Master (Par, True);\n                exit;\n@@ -2120,10 +2122,13 @@ package body Exp_Ch3 is\n       begin\n          --  Offset_To_Top_Functions are built only for derivations of types\n          --  with discriminants that cover interface types.\n+         --  Nothing is needed either in case of virtual machines, since\n+         --  interfaces are handled directly by the VM.\n \n          if not Is_Tagged_Type (Rec_Type)\n            or else Etype (Rec_Type) = Rec_Type\n            or else not Has_Discriminants (Etype (Rec_Type))\n+           or else VM_Target /= No_VM\n          then\n             return;\n          end if;\n@@ -4343,7 +4348,9 @@ package body Exp_Ch3 is\n             end if;\n \n             --  Ada 2005 (AI-251): Rewrite the expression that initializes a\n-            --  class-wide object to ensure that we copy the full object.\n+            --  class-wide object to ensure that we copy the full object,\n+            --  unless we're targetting a VM where interfaces are handled by\n+            --  VM itself.\n \n             --  Replace\n             --      CW : I'Class := Obj;\n@@ -4354,6 +4361,7 @@ package body Exp_Ch3 is\n             if Is_Interface (Typ)\n               and then Is_Class_Wide_Type (Etype (Expr))\n               and then Comes_From_Source (Def_Id)\n+              and then VM_Target = No_VM\n             then\n                declare\n                   Decl_1 : Node_Id;\n@@ -4523,10 +4531,15 @@ package body Exp_Ch3 is\n                end if;\n             end if;\n \n-            --  If validity checking on copies, validate initial expression\n+            --  If validity checking on copies, validate initial expression.\n+            --  But skip this if declaration is for a generic type, since it\n+            --  makes no sense to validate generic types. Not clear if this\n+            --  can happen for legal programs, but it definitely can arise\n+            --  from previous instantiation errors.\n \n             if Validity_Checks_On\n-               and then Validity_Check_Copies\n+              and then Validity_Check_Copies\n+              and then not Is_Generic_Type (Etype (Def_Id))\n             then\n                Ensure_Valid (Expr);\n                Set_Is_Known_Valid (Def_Id);\n@@ -4588,10 +4601,7 @@ package body Exp_Ch3 is\n          Validity_Check_Range (Range_Expression (Constraint (N)));\n       end if;\n \n-      if Nkind (Parent (N)) = N_Constrained_Array_Definition\n-           or else\n-         Nkind (Parent (N)) = N_Slice\n-      then\n+      if Nkind_In (Parent (N), N_Constrained_Array_Definition, N_Slice) then\n          Apply_Range_Check (Ran, Typ);\n       end if;\n    end Expand_N_Subtype_Indication;\n@@ -4628,11 +4638,13 @@ package body Exp_Ch3 is\n \n    begin\n       --  Find all access types declared in the current scope, whose\n-      --  designated type is Def_Id.\n+      --  designated type is Def_Id. If it does not have a Master_Id,\n+      --  create one now.\n \n       while Present (T) loop\n          if Is_Access_Type (T)\n            and then Designated_Type (T) = Def_Id\n+           and then No (Master_Id (T))\n          then\n             Build_Master_Entity (Def_Id);\n             Build_Master_Renaming (Parent (Def_Id), T);\n@@ -4727,7 +4739,7 @@ package body Exp_Ch3 is\n                --  between the secondary tag and its adjacent component.\n \n                    or else Present\n-                             (Related_Interface\n+                             (Related_Type\n                                (Defining_Identifier (First_Comp))))\n             loop\n                Next (First_Comp);\n@@ -5258,7 +5270,11 @@ package body Exp_Ch3 is\n       --  access components whose designated type is potentially controlled.\n \n       Renamed_Eq : Node_Id := Empty;\n-      --  Could use some comments ???\n+      --  Defining unit name for the predefined equality function in the case\n+      --  where the type has a primitive operation that is a renaming of\n+      --  predefined equality (but only if there is also an overriding\n+      --  user-defined equality function). Used to pass this entity from\n+      --  Make_Predefined_Primitive_Specs to Predefined_Primitive_Bodies.\n \n       Wrapper_Decl_List   : List_Id := No_List;\n       Wrapper_Body_List   : List_Id := No_List;\n@@ -5587,11 +5603,16 @@ package body Exp_Ch3 is\n          Build_Record_Init_Proc (Type_Decl, Def_Id);\n       end if;\n \n-      --  For tagged type, build bodies of primitive operations. Note that we\n-      --  do this after building the record initialization experiment, since\n-      --  the primitive operations may need the initialization routine\n+      --  For tagged type that are not interfaces, build bodies of primitive\n+      --  operations. Note that we do this after building the record\n+      --  initialization procedure, since the primitive operations may need\n+      --  the initialization routine. There is no need to add predefined\n+      --  primitives of interfaces because all their predefined primitives\n+      --  are abstract.\n \n-      if Is_Tagged_Type (Def_Id) then\n+      if Is_Tagged_Type (Def_Id)\n+        and then not Is_Interface (Def_Id)\n+      then\n \n          --  Do not add the body of the predefined primitives if we are\n          --  compiling under restriction No_Dispatching_Calls\n@@ -6118,9 +6139,7 @@ package body Exp_Ch3 is\n          --  Similarly, if it is an aggregate it must be qualified, because an\n          --  unchecked conversion does not provide a context for it.\n \n-         if Nkind (Val) = N_Null\n-           or else Nkind (Val) = N_Aggregate\n-         then\n+         if Nkind_In (Val, N_Null, N_Aggregate) then\n             Val :=\n               Make_Qualified_Expression (Loc,\n                 Subtype_Mark =>\n@@ -6821,12 +6840,14 @@ package body Exp_Ch3 is\n             while Present (Idx) loop\n                if Nkind (Idx) = N_Range then\n                   if (Nkind (Low_Bound (Idx)) = N_Identifier\n-                      and then Present (Entity (Low_Bound (Idx)))\n-                      and then Ekind (Entity (Low_Bound (Idx))) /= E_Constant)\n+                       and then Present (Entity (Low_Bound (Idx)))\n+                       and then\n+                         Ekind (Entity (Low_Bound (Idx))) /= E_Constant)\n                     or else\n                      (Nkind (High_Bound (Idx)) = N_Identifier\n-                      and then Present (Entity (High_Bound (Idx)))\n-                      and then Ekind (Entity (High_Bound (Idx))) /= E_Constant)\n+                       and then Present (Entity (High_Bound (Idx)))\n+                       and then\n+                         Ekind (Entity (High_Bound (Idx))) /= E_Constant)\n                   then\n                      return True;\n                   end if;\n@@ -7267,7 +7288,7 @@ package body Exp_Ch3 is\n    procedure Make_Predefined_Primitive_Specs\n      (Tag_Typ     : Entity_Id;\n       Predef_List : out List_Id;\n-      Renamed_Eq  : out Node_Id)\n+      Renamed_Eq  : out Entity_Id)\n    is\n       Loc       : constant Source_Ptr := Sloc (Tag_Typ);\n       Res       : constant List_Id    := New_List;\n@@ -7342,13 +7363,12 @@ package body Exp_Ch3 is\n          end loop;\n       end;\n \n-      --  Spec of \"=\" if expanded if the type is not limited and if a\n+      --  Spec of \"=\" is expanded if the type is not limited and if a\n       --  user defined \"=\" was not already declared for the non-full\n       --  view of a private extension\n \n       if not Is_Limited_Type (Tag_Typ) then\n          Eq_Needed := True;\n-\n          Prim := First_Elmt (Primitive_Operations (Tag_Typ));\n          while Present (Prim) loop\n \n@@ -7364,22 +7384,25 @@ package body Exp_Ch3 is\n             if Is_Predefined_Eq_Renaming (Node (Prim)) then\n                Eq_Name := New_External_Name (Chars (Node (Prim)), 'E');\n \n+            --  User-defined equality\n+\n             elsif Chars (Node (Prim)) = Name_Op_Eq\n               and then (No (Alias (Node (Prim)))\n                          or else Nkind (Unit_Declaration_Node (Node (Prim))) =\n                                             N_Subprogram_Renaming_Declaration)\n               and then Etype (First_Formal (Node (Prim))) =\n                          Etype (Next_Formal (First_Formal (Node (Prim))))\n               and then Base_Type (Etype (Node (Prim))) = Standard_Boolean\n-\n             then\n                Eq_Needed := False;\n                exit;\n \n-            --  If the parent equality is abstract, the inherited equality is\n-            --  abstract as well, and no body can be created for for it.\n+            --  If the parent is not an interface type and has an abstract\n+            --  equality function, the inherited equality is abstract as well,\n+            --  and no body can be created for it.\n \n             elsif Chars (Node (Prim)) = Name_Op_Eq\n+              and then not Is_Interface (Etype (Tag_Typ))\n               and then Present (Alias (Node (Prim)))\n               and then Is_Abstract_Subprogram (Alias (Node (Prim)))\n             then\n@@ -7469,47 +7492,96 @@ package body Exp_Ch3 is\n       --  operations for limited interfaces and synchronized types that\n       --  implement a limited interface.\n \n-      --    disp_asynchronous_select\n-      --    disp_conditional_select\n-      --    disp_get_prim_op_kind\n-      --    disp_get_task_id\n-      --    disp_timed_select\n+      --    Disp_Asynchronous_Select\n+      --    Disp_Conditional_Select\n+      --    Disp_Get_Prim_Op_Kind\n+      --    Disp_Get_Task_Id\n+      --    Disp_Requeue\n+      --    Disp_Timed_Select\n \n       --  These operations cannot be implemented on VM targets, so we simply\n       --  disable their generation in this case. We also disable generation\n       --  of these bodies if No_Dispatching_Calls is active.\n \n       if Ada_Version >= Ada_05\n         and then VM_Target = No_VM\n-        and then\n-          ((Is_Interface (Tag_Typ) and then Is_Limited_Record (Tag_Typ))\n-              or else (Is_Concurrent_Record_Type (Tag_Typ)\n-                         and then Has_Abstract_Interfaces (Tag_Typ)))\n       then\n-         Append_To (Res,\n-           Make_Subprogram_Declaration (Loc,\n-             Specification =>\n-               Make_Disp_Asynchronous_Select_Spec (Tag_Typ)));\n+         --  These primitives are defined abstract in interface types\n \n-         Append_To (Res,\n-           Make_Subprogram_Declaration (Loc,\n-             Specification =>\n-               Make_Disp_Conditional_Select_Spec (Tag_Typ)));\n+         if Is_Interface (Tag_Typ)\n+           and then Is_Limited_Record (Tag_Typ)\n+         then\n+            Append_To (Res,\n+              Make_Abstract_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Asynchronous_Select_Spec (Tag_Typ)));\n \n-         Append_To (Res,\n-           Make_Subprogram_Declaration (Loc,\n-             Specification =>\n-               Make_Disp_Get_Prim_Op_Kind_Spec (Tag_Typ)));\n+            Append_To (Res,\n+              Make_Abstract_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Conditional_Select_Spec (Tag_Typ)));\n \n-         Append_To (Res,\n-           Make_Subprogram_Declaration (Loc,\n-             Specification =>\n-               Make_Disp_Get_Task_Id_Spec (Tag_Typ)));\n+            Append_To (Res,\n+              Make_Abstract_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Get_Prim_Op_Kind_Spec (Tag_Typ)));\n \n-         Append_To (Res,\n-           Make_Subprogram_Declaration (Loc,\n-             Specification =>\n-               Make_Disp_Timed_Select_Spec (Tag_Typ)));\n+            Append_To (Res,\n+              Make_Abstract_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Get_Task_Id_Spec (Tag_Typ)));\n+\n+            Append_To (Res,\n+              Make_Abstract_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Requeue_Spec (Tag_Typ)));\n+\n+            Append_To (Res,\n+              Make_Abstract_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Timed_Select_Spec (Tag_Typ)));\n+\n+         --  If the ancestor is an interface type we declare non-abstract\n+         --  primitives to override the abstract primitives of the interface\n+         --  type.\n+\n+         elsif (not Is_Interface (Tag_Typ)\n+                  and then Is_Interface (Etype (Tag_Typ))\n+                  and then Is_Limited_Record (Etype (Tag_Typ)))\n+             or else\n+               (Is_Concurrent_Record_Type (Tag_Typ)\n+                  and then Has_Abstract_Interfaces (Tag_Typ))\n+         then\n+            Append_To (Res,\n+              Make_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Asynchronous_Select_Spec (Tag_Typ)));\n+\n+            Append_To (Res,\n+              Make_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Conditional_Select_Spec (Tag_Typ)));\n+\n+            Append_To (Res,\n+              Make_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Get_Prim_Op_Kind_Spec (Tag_Typ)));\n+\n+            Append_To (Res,\n+              Make_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Get_Task_Id_Spec (Tag_Typ)));\n+\n+            Append_To (Res,\n+              Make_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Requeue_Spec (Tag_Typ)));\n+\n+            Append_To (Res,\n+              Make_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Make_Disp_Timed_Select_Spec (Tag_Typ)));\n+         end if;\n       end if;\n \n       --  Specs for finalization actions that may be required in case a future\n@@ -7696,12 +7768,15 @@ package body Exp_Ch3 is\n                New_Reference_To (Ret_Type, Loc));\n       end if;\n \n+      if Is_Interface (Tag_Typ) then\n+         return Make_Abstract_Subprogram_Declaration (Loc, Spec);\n+\n       --  If body case, return empty subprogram body. Note that this is ill-\n       --  formed, because there is not even a null statement, and certainly not\n       --  a return in the function case. The caller is expected to do surgery\n       --  on the body to add the appropriate stuff.\n \n-      if For_Body then\n+      elsif For_Body then\n          return Make_Subprogram_Body (Loc, Spec, Empty_List, Empty);\n \n       --  For the case of an Input attribute predefined for an abstract type,\n@@ -7754,7 +7829,7 @@ package body Exp_Ch3 is\n \n    function Predefined_Primitive_Bodies\n      (Tag_Typ    : Entity_Id;\n-      Renamed_Eq : Node_Id) return List_Id\n+      Renamed_Eq : Entity_Id) return List_Id\n    is\n       Loc       : constant Source_Ptr := Sloc (Tag_Typ);\n       Res       : constant List_Id    := New_List;\n@@ -7767,12 +7842,35 @@ package body Exp_Ch3 is\n       pragma Warnings (Off, Ent);\n \n    begin\n+      pragma Assert (not Is_Interface (Tag_Typ));\n+\n       --  See if we have a predefined \"=\" operator\n \n       if Present (Renamed_Eq) then\n          Eq_Needed := True;\n          Eq_Name   := Chars (Renamed_Eq);\n \n+      --  If the parent is an interface type then it has defined all the\n+      --  predefined primitives abstract and we need to check if the type\n+      --  has some user defined \"=\" function to avoid generating it.\n+\n+      elsif Is_Interface (Etype (Tag_Typ)) then\n+         Eq_Needed := True;\n+         Eq_Name := Name_Op_Eq;\n+\n+         Prim := First_Elmt (Primitive_Operations (Tag_Typ));\n+         while Present (Prim) loop\n+            if Chars (Node (Prim)) = Name_Op_Eq\n+              and then not Is_Internal (Node (Prim))\n+            then\n+               Eq_Needed := False;\n+               Eq_Name := No_Name;\n+               exit;\n+            end if;\n+\n+            Next_Elmt (Prim);\n+         end loop;\n+\n       else\n          Eq_Needed := False;\n          Eq_Name   := No_Name;\n@@ -7784,6 +7882,7 @@ package body Exp_Ch3 is\n             then\n                Eq_Needed := True;\n                Eq_Name := Name_Op_Eq;\n+               exit;\n             end if;\n \n             Next_Elmt (Prim);\n@@ -7893,20 +7992,24 @@ package body Exp_Ch3 is\n       if Ada_Version >= Ada_05\n         and then VM_Target = No_VM\n         and then not Restriction_Active (No_Dispatching_Calls)\n+        and then not Is_Interface (Tag_Typ)\n         and then\n-          ((Is_Interface (Tag_Typ) and then Is_Limited_Record (Tag_Typ))\n-              or else (Is_Concurrent_Record_Type (Tag_Typ)\n-                        and then Has_Abstract_Interfaces (Tag_Typ)))\n+          ((Is_Interface (Etype (Tag_Typ))\n+              and then Is_Limited_Record (Etype (Tag_Typ)))\n+           or else (Is_Concurrent_Record_Type (Tag_Typ)\n+                     and then Has_Abstract_Interfaces (Tag_Typ)))\n       then\n          Append_To (Res, Make_Disp_Asynchronous_Select_Body (Tag_Typ));\n          Append_To (Res, Make_Disp_Conditional_Select_Body  (Tag_Typ));\n          Append_To (Res, Make_Disp_Get_Prim_Op_Kind_Body    (Tag_Typ));\n          Append_To (Res, Make_Disp_Get_Task_Id_Body         (Tag_Typ));\n+         Append_To (Res, Make_Disp_Requeue_Body             (Tag_Typ));\n          Append_To (Res, Make_Disp_Timed_Select_Body        (Tag_Typ));\n       end if;\n \n-      if not Is_Limited_Type (Tag_Typ) then\n-\n+      if not Is_Limited_Type (Tag_Typ)\n+        and then not Is_Interface (Tag_Typ)\n+      then\n          --  Body for equality\n \n          if Eq_Needed then"}]}