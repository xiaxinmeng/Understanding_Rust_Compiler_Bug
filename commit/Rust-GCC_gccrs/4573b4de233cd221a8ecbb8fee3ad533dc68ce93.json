{"sha": "4573b4de233cd221a8ecbb8fee3ad533dc68ce93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU3M2I0ZGUyMzNjZDIyMWE4ZWNiYjhmZWUzYWQ1MzNkYzY4Y2U5Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-03-28T11:09:20Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-03-28T11:09:20Z"}, "message": "alpha.c (alpha_sa_mask): Add EH_RETURN_DATA_REGNOs.\n\n        * config/alpha/alpha.c (alpha_sa_mask): Add EH_RETURN_DATA_REGNOs.\n        (alpha_mark_machine_status): No eh_epilogue_sp_ofs ...\n        (alpha_expand_epilogue): ... use EH_RETURN_STACKADJ_RTX instead.\n        * config/alpha/alpha.h (machine_function): Remove eh_epilogue_sp_ofs.\n        (EH_RETURN_DATA_REGNO): New.\n        (EH_RETURN_STACKADJ_RTX, EH_RETURN_HANDLER_RTX): New.\n        * config/alpha/alpha.md (eh_epilogue): Remove.\n        (exception_receiver): Use $26 for ldgp input.\n        * config/alpha/linux.h (MD_FALLBACK_FRAME_STATE_FOR): New.\n\nFrom-SVN: r40925", "tree": {"sha": "566a8ac346a56763949b3cca3f06c4c74aa23fba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/566a8ac346a56763949b3cca3f06c4c74aa23fba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4573b4de233cd221a8ecbb8fee3ad533dc68ce93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4573b4de233cd221a8ecbb8fee3ad533dc68ce93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4573b4de233cd221a8ecbb8fee3ad533dc68ce93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4573b4de233cd221a8ecbb8fee3ad533dc68ce93/comments", "author": null, "committer": null, "parents": [{"sha": "52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52a11cbfcf0cfb32628b6953588b6af4037ac0b6"}], "stats": {"total": 121, "additions": 93, "deletions": 28}, "files": [{"sha": "66122d4f86acef3473d19017d8858e2e9a9ca3b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4573b4de233cd221a8ecbb8fee3ad533dc68ce93/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4573b4de233cd221a8ecbb8fee3ad533dc68ce93/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4573b4de233cd221a8ecbb8fee3ad533dc68ce93", "patch": "@@ -1,3 +1,15 @@\n+2001-03-28  Richard Henderson  <rth@redhat.com>\n+\n+        * config/alpha/alpha.c (alpha_sa_mask): Add EH_RETURN_DATA_REGNOs.\n+        (alpha_mark_machine_status): No eh_epilogue_sp_ofs ...\n+        (alpha_expand_epilogue): ... use EH_RETURN_STACKADJ_RTX instead.\n+        * config/alpha/alpha.h (machine_function): Remove eh_epilogue_sp_ofs.\n+        (EH_RETURN_DATA_REGNO): New.\n+        (EH_RETURN_STACKADJ_RTX, EH_RETURN_HANDLER_RTX): New.\n+        * config/alpha/alpha.md (eh_epilogue): Remove.\n+        (exception_receiver): Use $26 for ldgp input.\n+\t* config/alpha/linux.h (MD_FALLBACK_FRAME_STATE_FOR): New.\n+\n 2001-03-28  Richard Henderson  <rth@redhat.com>\n \n \t* except.c: Rewrite entirely for IA-64 ABI exception handling."}, {"sha": "18a61d6c7f6e252cd0db6acaa5b153e70bf964a9", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4573b4de233cd221a8ecbb8fee3ad533dc68ce93/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4573b4de233cd221a8ecbb8fee3ad533dc68ce93/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=4573b4de233cd221a8ecbb8fee3ad533dc68ce93", "patch": "@@ -3664,7 +3664,6 @@ alpha_mark_machine_status (p)\n \n   if (machine)\n     {\n-      ggc_mark_rtx (machine->eh_epilogue_sp_ofs);\n       ggc_mark_rtx (machine->ra_rtx);\n     }\n }\n@@ -4416,6 +4415,18 @@ alpha_sa_mask (imaskP, fmaskP)\n \t      fmask |= (1L << (i - 32));\n \t  }\n \n+      /* We need to restore these for the handler.  */\n+      if (current_function_calls_eh_return)\n+\t{\n+\t  for (i = 0; ; ++i)\n+\t    {\n+\t      unsigned regno = EH_RETURN_DATA_REGNO (i);\n+\t      if (regno == INVALID_REGNUM)\n+\t\tbreak;\n+\t      imask |= 1L << regno;\n+\t    }\n+\t}\n+\n       if (imask || fmask || alpha_ra_ever_killed ())\n \timask |= (1L << REG_RA);\n     }\n@@ -5112,7 +5123,11 @@ alpha_expand_epilogue ()\n   fp_offset = 0;\n   sa_reg = stack_pointer_rtx;\n \n-  eh_ofs = cfun->machine->eh_epilogue_sp_ofs;\n+  if (current_function_calls_eh_return)\n+    eh_ofs = EH_RETURN_STACKADJ_RTX;\n+  else\n+    eh_ofs = NULL_RTX;\n+\n   if (sa_size)\n     {\n       /* If we have a frame pointer, restore SP from it.  */\n@@ -5140,12 +5155,11 @@ alpha_expand_epilogue ()\n \t  \n       /* Restore registers in order, excepting a true frame pointer. */\n \n+      mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));\n       if (! eh_ofs)\n-\t{\n-\t  mem = gen_rtx_MEM (DImode, plus_constant(sa_reg, reg_offset));\n-\t  MEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n-          FRP (emit_move_insn (gen_rtx_REG (DImode, REG_RA), mem));\n-\t}\n+        MEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n+      FRP (emit_move_insn (gen_rtx_REG (DImode, REG_RA), mem));\n+\n       reg_offset += 8;\n       imask &= ~(1L << REG_RA);\n "}, {"sha": "7d4c194b64b2e8c2ed378d78b03b7338c41e8e80", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4573b4de233cd221a8ecbb8fee3ad533dc68ce93/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4573b4de233cd221a8ecbb8fee3ad533dc68ce93/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=4573b4de233cd221a8ecbb8fee3ad533dc68ce93", "patch": "@@ -1213,9 +1213,6 @@ extern struct alpha_compare alpha_compare;\n \n struct machine_function\n {\n-  /* An offset to apply to the stack pointer when unwinding from EH.  */\n-  struct rtx_def *eh_epilogue_sp_ofs;\n-\n   /* If non-null, this rtx holds the return address for the function.  */\n   struct rtx_def *ra_rtx;\n };\n@@ -1342,6 +1339,13 @@ do {\t\t\t\t\t\t\\\n /* Before the prologue, RA lives in $26. */\n #define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (Pmode, 26)\n #define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (26)\n+\n+/* Describe how we implement __builtin_eh_return.  */\n+#define EH_RETURN_DATA_REGNO(N)\t((N) < 4 ? (N) + 16 : INVALID_REGNUM)\n+#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, 28)\n+#define EH_RETURN_HANDLER_RTX \\\n+  gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx, \\\n+\t\t\t\t     current_function_outgoing_args_size))\n \f\n /* Addressing modes, and classification of registers for them.  */\n "}, {"sha": "3460d42691e8e864dd485fe4f2db851565ffa676", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4573b4de233cd221a8ecbb8fee3ad533dc68ce93/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4573b4de233cd221a8ecbb8fee3ad533dc68ce93/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=4573b4de233cd221a8ecbb8fee3ad533dc68ce93", "patch": "@@ -5900,22 +5900,6 @@\n   DONE;\n }\")\n \n-(define_expand \"eh_epilogue\"\n-  [(use (match_operand:DI 0 \"register_operand\" \"r\"))\n-   (use (match_operand:DI 1 \"register_operand\" \"r\"))\n-   (use (match_operand:DI 2 \"register_operand\" \"r\"))]\n-  \"! TARGET_OPEN_VMS\"\n-  \"\n-{\n-  cfun->machine->eh_epilogue_sp_ofs = operands[1];\n-  if (GET_CODE (operands[2]) != REG || REGNO (operands[2]) != 26)\n-    {\n-      rtx ra = gen_rtx_REG (Pmode, 26);\n-      emit_move_insn (ra, operands[2]);\n-      operands[2] = ra;\n-    }\n-}\")\n-\n ;; In creating a large stack frame, NT _must_ use ldah+lda to load\n ;; the frame size into a register.  We use this pattern to ensure\n ;; we get lda instead of addq.\n@@ -5978,8 +5962,8 @@\n (define_insn \"exception_receiver\"\n   [(unspec_volatile [(const_int 0)] 7)]\n   \"! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT\"\n-  \"br $29,$LSJ%=\\\\n$LSJ%=:\\;ldgp $29,0($29)\"\n-  [(set_attr \"length\" \"12\")\n+  \"ldgp $29,0($26)\"\n+  [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"multi\")])\n \n (define_expand \"nonlocal_goto_receiver\""}, {"sha": "1be967e680e9e35eb9fe681e76ad9dcfd7869f02", "filename": "gcc/config/alpha/linux.h", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4573b4de233cd221a8ecbb8fee3ad533dc68ce93/gcc%2Fconfig%2Falpha%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4573b4de233cd221a8ecbb8fee3ad533dc68ce93/gcc%2Fconfig%2Falpha%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Flinux.h?ref=4573b4de233cd221a8ecbb8fee3ad533dc68ce93", "patch": "@@ -44,3 +44,54 @@ SUB_CPP_PREDEFINES\n \n /* Define this so that all GNU/Linux targets handle the same pragmas.  */\n #define HANDLE_PRAGMA_PACK_PUSH_POP\n+\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.  */\n+\n+#ifdef IN_LIBGCC2\n+#include <signal.h>\n+#include <sys/ucontext.h>\n+#endif\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    unsigned int *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n+    struct sigcontext *sc_;\t\t\t\t\t\t\\\n+    long new_cfa_, i_;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    if (pc_[0] != 0x47fe0410\t\t/* mov $30,$16 */\t\t\\\n+        || pc_[2] != 0x00000083\t\t/* callsys */)\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    if (pc_[1] == 0x201f0067)\t\t/* lda $0,NR_sigreturn */\t\\\n+      sc_ = (CONTEXT)->cfa;\t\t\t\t\t\t\\\n+    else if (pc_[1] == 0x201f015f)\t/* lda $0,NR_rt_sigreturn */\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tstruct rt_sigframe {\t\t\t\t\t\t\\\n+\t  struct siginfo info;\t\t\t\t\t\t\\\n+\t  struct ucontext uc;\t\t\t\t\t\t\\\n+\t} *rt_ = (CONTEXT)->cfa;\t\t\t\t\t\\\n+\tsc_ = &rt_->uc.uc_mcontext;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    new_cfa_ = sc_->sc_regs[30];\t\t\t\t\t\\\n+    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n+    (FS)->cfa_reg = 30;\t\t\t\t\t\t\t\\\n+    (FS)->cfa_offset = new_cfa_ - (long) (CONTEXT)->cfa;\t\t\\\n+    for (i_ = 0; i_ < 30; ++i_)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t(FS)->regs.reg[i_].how = REG_SAVED_OFFSET;\t\t\t\\\n+\t(FS)->regs.reg[i_].loc.offset\t\t\t\t\t\\\n+\t  = (long)&sc_->sc_regs[i_] - new_cfa_;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    for (i_ = 0; i_ < 31; ++i_)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t(FS)->regs.reg[i_+32].how = REG_SAVED_OFFSET;\t\t\t\\\n+\t(FS)->regs.reg[i_+32].loc.offset\t\t\t\t\\\n+\t  = (long)&sc_->sc_fpregs[i_] - new_cfa_;\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    (FS)->regs.reg[31].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[31].loc.offset = (long)&sc_->sc_pc - new_cfa_;\t\\\n+    (FS)->retaddr_column = 31;\t\t\t\t\t\t\\\n+    goto SUCCESS;\t\t\t\t\t\t\t\\\n+  } while (0)"}]}