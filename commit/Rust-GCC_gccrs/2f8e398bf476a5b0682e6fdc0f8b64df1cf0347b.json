{"sha": "2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY4ZTM5OGJmNDc2YTViMDY4MmU2ZmRjMGY4YjY0ZGYxY2YwMzQ3Yg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-06-16T07:25:53Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-06-16T07:25:53Z"}, "message": "coverage.c: Remove argument to rest_of_compilation.\n\ngcc/ChangeLog:\n2004-06-16  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* coverage.c: Remove argument to rest_of_compilation.\n\t* expr.c (execute_expand, set_save_expr_context, pass_expand): New.\n\t* passes.c (rest_of_compilation): Remove argument.\n\t(pass_rest_of_compilation): New.\n\t(rest_of_handle_final, rest_of_handle_delay_slots,\n\trest_of_handle_stack_regs, rest_of_handle_variable_tracking\n\trest_of_handle_machine_reorg, rest_of_handle_regrename\n\trest_of_handle_sched, rest_of_handle_sched2, rest_of_handle_gcse2\n\trest_of_handle_regmove, rest_of_handle_tracer\n\trest_of_handle_if_conversion, rest_of_handle_if_after_combine\n\trest_of_handle_web, rest_of_handle_branch_prob\n\trest_of_handle_value_profile_transformations, rest_of_handle_cfg\n\trest_of_handle_addressof, rest_of_handle_jump_bypass\n\trest_of_handle_life, rest_of_handle_cse, rest_of_handle_cse2):\n\tCheck that the two arguments are actually superfluous.\n\t* toplev.h (rest_of_compilation): Adjust prototype.\n\t* tree-optimize.c (register_dump_files): Add properties argument.\n\tTrack validity of passes.  Only initialize dump files for\n\ttree-based passes.  Store the full set of provided passes in\n\tthe pass.\n\t(init_tree_optimization_passes): Register pass_expand and\n\tpass_rest_of_compilation.\n\t(execute_one_pass): Do not track the presence of required properties\n\there.  Set in_gimple_form.  Do not update current_properties.\n\t(current_properties): Remove.\n\t(set_save_expr_context): Remove.\n\t(tree_rest_of_compilation): Do not set in_gimple_form.  Do not\n\texpand to RTL here, and do not call rest_of_compilation.  Push\n\tGGC context even before gimplification.\n\t* tree-pass.h (PROP_rtl, PROP_trees): New flags.\n\t(pass_expand, pass_rest_of_compilation): Declare.\n\ngcc/java/ChangeLog:\n2004-06-16  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* java/class.c (emit_register_classes): Remove argument to\n\trest_of_compilation.\n\t* java/resource.c (write_resource_constructor): Likewise.\n\nFrom-SVN: r83225", "tree": {"sha": "9a0555f8f1b2223026f9437cfe0dae25fa815cd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a0555f8f1b2223026f9437cfe0dae25fa815cd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b/comments", "author": null, "committer": null, "parents": [{"sha": "fd660b1bee7af09cd69d1125cf35e6aa5826234c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd660b1bee7af09cd69d1125cf35e6aa5826234c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd660b1bee7af09cd69d1125cf35e6aa5826234c"}], "stats": {"total": 332, "additions": 234, "deletions": 98}, "files": [{"sha": "3eab7a5dd4652d7743edac8b82ec8d8d1b9d9b98", "filename": "gcc/coverage.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b", "patch": "@@ -955,7 +955,7 @@ create_coverage (void)\n   DECL_INITIAL (ctor) = make_node (BLOCK);\n   TREE_USED (DECL_INITIAL (ctor)) = 1;\n \n-  rest_of_compilation (ctor);\n+  rest_of_compilation ();\n \n   if (! quiet_flag)\n     fflush (asm_out_file);"}, {"sha": "a3f89a1d2edc9335067383d74e5c6635bf278b4f", "filename": "gcc/expr.c", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b", "patch": "@@ -48,7 +48,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"intl.h\"\n #include \"tm_p.h\"\n #include \"tree-iterator.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-flow.h\"\n #include \"target.h\"\n+#include \"timevar.h\"\n \n /* Decide whether a function's arguments should be processed\n    from first to last or from last to first.\n@@ -165,6 +168,7 @@ static void emit_single_push_insn (enum machine_mode, rtx, tree);\n #endif\n static void do_tablejump (rtx, enum machine_mode, rtx, rtx, rtx);\n static rtx const_vector_from_tree (tree);\n+static void execute_expand (void);\n \n /* Record for each mode whether we can move a register directly to or\n    from an object of that mode in memory.  If we can't, we won't try\n@@ -10204,5 +10208,92 @@ const_vector_from_tree (tree exp)\n \n   return gen_rtx_raw_CONST_VECTOR (mode, v);\n }\n+\f\n+/* Called to move the SAVE_EXPRs for parameter declarations in a\n+   nested function into the nested function.  DATA is really the\n+   nested FUNCTION_DECL.  */\n+\n+static tree\n+set_save_expr_context (tree *tp,\n+                       int *walk_subtrees,\n+                       void *data)\n+{\n+  if (TREE_CODE (*tp) == SAVE_EXPR && !SAVE_EXPR_CONTEXT (*tp))\n+    SAVE_EXPR_CONTEXT (*tp) = (tree) data;\n+  /* Do not walk back into the SAVE_EXPR_CONTEXT; that will cause\n+     circularity.  */\n+  else if (DECL_P (*tp))\n+    *walk_subtrees = 0;\n+\n+  return NULL;\n+}\n+\n+\n+static void\n+execute_expand (void)\n+{\n+  /* If the function has a variably modified type, there may be\n+     SAVE_EXPRs in the parameter types.  Their context must be set to\n+     refer to this function; they cannot be expanded in the containing\n+     function.  */\n+  if (decl_function_context (current_function_decl) == current_function_decl\n+      && variably_modified_type_p (TREE_TYPE (current_function_decl)))\n+    walk_tree (&TREE_TYPE (current_function_decl), set_save_expr_context,\n+\t       current_function_decl, NULL);\n+\n+  /* Expand the variables recorded during gimple lowering.  This must\n+     occur before the call to expand_function_start to ensure that\n+     all used variables are expanded before we expand anything on the\n+     PENDING_SIZES list.  */\n+  expand_used_vars ();\n+\n+  /* Set up parameters and prepare for return, for the function.  */\n+  expand_function_start (current_function_decl, 0);\n+\n+  /* If this function is `main', emit a call to `__main'\n+     to run global initializers, etc.  */\n+  if (DECL_NAME (current_function_decl)\n+      && MAIN_NAME_P (DECL_NAME (current_function_decl))\n+      && DECL_FILE_SCOPE_P (current_function_decl))\n+    expand_main_function ();\n+\n+  /* Generate the RTL for this function.  */\n+  expand_expr_stmt_value (DECL_SAVED_TREE (current_function_decl), 0, 0);\n+\n+  /* We hard-wired immediate_size_expand to zero above.\n+     expand_function_end will decrement this variable.  So, we set the\n+     variable to one here, so that after the decrement it will remain\n+     zero.  */\n+  immediate_size_expand = 1;\n+\n+  /* Make sure the locus is set to the end of the function, so that\n+     epilogue line numbers and warnings are set properly.  */\n+  if (cfun->function_end_locus.file)\n+    input_location = cfun->function_end_locus;\n+\n+  /* The following insns belong to the top scope.  */\n+  record_block_change (DECL_INITIAL (current_function_decl));\n+\n+  /* Generate rtl for function exit.  */\n+  expand_function_end ();\n+}\n+\n+struct tree_opt_pass pass_expand =\n+{\n+  \"expand\",\t\t                /* name */\n+  NULL,                                 /* gate */\n+  execute_expand,\t                /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_EXPAND,\t\t                /* tv_id */\n+  /* ??? If TER is enabled, we actually receive GENERIC.  */\n+  PROP_gimple_leh,                      /* properties_required */\n+  PROP_rtl,                             /* properties_provided */\n+  PROP_cfg | PROP_gimple_leh,           /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0                                     /* todo_flags_finish */\n+};\n+\n \n #include \"gt-expr.h\""}, {"sha": "cfb3366eeceae112e0da5bc1b6d2d85c433a49ec", "filename": "gcc/java/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b", "patch": "@@ -2316,7 +2316,7 @@ emit_register_classes (void)\n       input_location = DECL_SOURCE_LOCATION (init_decl);\n       expand_function_end ();\n       poplevel (1, 0, 1);\n-      rest_of_compilation (init_decl);\n+      rest_of_compilation ();\n       current_function_decl = NULL_TREE;\n \n       if (targetm.have_ctors_dtors)"}, {"sha": "0f8440db4689763153e2c108cc81a0fc859eb71a", "filename": "gcc/java/resource.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b/gcc%2Fjava%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b/gcc%2Fjava%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fresource.c?ref=2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b", "patch": "@@ -153,7 +153,7 @@ write_resource_constructor (void)\n   poplevel (1, 0, 1);\n \n   /* rest_of_compilation forces generation even if -finline-functions.  */\n-  rest_of_compilation (init_decl);\n+  rest_of_compilation ();\n \n   current_function_decl = NULL_TREE;\n   if (targetm.have_ctors_dtors)"}, {"sha": "344cfb6856068c9e19b0e1c446b74d255d828e57", "filename": "gcc/passes.c", "status": "modified", "additions": 108, "deletions": 6, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b", "patch": "@@ -80,6 +80,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"coverage.h\"\n #include \"value-prof.h\"\n #include \"alloc-pool.h\"\n+#include \"tree-pass.h\"\n \n #if defined (DWARF2_UNWIND_INFO) || defined (DWARF2_DEBUGGING_INFO)\n #include \"dwarf2out.h\"\n@@ -430,6 +431,9 @@ rest_of_type_compilation (tree type, int toplev)\n static void\n rest_of_handle_final (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   timevar_push (TV_FINAL);\n   {\n     rtx x;\n@@ -483,6 +487,9 @@ rest_of_handle_final (tree decl, rtx insns)\n static void\n rest_of_handle_delay_slots (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   timevar_push (TV_DBR_SCHED);\n   open_dump_file (DFI_dbr, decl);\n \n@@ -501,6 +508,9 @@ rest_of_handle_delay_slots (tree decl, rtx insns)\n static void\n rest_of_handle_stack_regs (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n #if defined (HAVE_ATTR_length)\n   /* If flow2 creates new instructions which need splitting\n      and scheduling after reload is not done, they might not be\n@@ -543,6 +553,9 @@ rest_of_handle_stack_regs (tree decl, rtx insns)\n static void\n rest_of_handle_variable_tracking (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   timevar_push (TV_VAR_TRACKING);\n   open_dump_file (DFI_vartrack, decl);\n \n@@ -556,6 +569,9 @@ rest_of_handle_variable_tracking (tree decl, rtx insns)\n static void\n rest_of_handle_machine_reorg (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   timevar_push (TV_MACH_DEP);\n   open_dump_file (DFI_mach, decl);\n \n@@ -575,6 +591,9 @@ rest_of_handle_new_regalloc (tree decl, rtx insns)\n {\n   int failure;\n \n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   delete_trivially_dead_insns (insns, max_reg_num ());\n   reg_alloc ();\n \n@@ -622,6 +641,9 @@ rest_of_handle_old_regalloc (tree decl, rtx insns)\n   int failure;\n   int rebuild_notes;\n \n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   /* Allocate the reg_renumber array.  */\n   allocate_reg_info (max_regno, FALSE, TRUE);\n \n@@ -695,6 +717,9 @@ rest_of_handle_old_regalloc (tree decl, rtx insns)\n static void\n rest_of_handle_regrename (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   timevar_push (TV_RENAME_REGISTERS);\n   open_dump_file (DFI_rnreg, decl);\n \n@@ -714,6 +739,9 @@ rest_of_handle_reorder_blocks (tree decl, rtx insns)\n   bool changed;\n   open_dump_file (DFI_bbro, decl);\n \n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n      splitting possibly introduced more crossjumping opportunities.  */\n   changed = cleanup_cfg (CLEANUP_EXPENSIVE\n@@ -744,6 +772,9 @@ rest_of_handle_reorder_blocks (tree decl, rtx insns)\n static void\n rest_of_handle_sched (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   timevar_push (TV_SMS);\n   if (optimize > 0 && flag_modulo_sched)\n     {\n@@ -791,6 +822,9 @@ rest_of_handle_sched (tree decl, rtx insns)\n static void\n rest_of_handle_sched2 (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   timevar_push (TV_SCHED2);\n   open_dump_file (DFI_sched2, decl);\n \n@@ -820,6 +854,9 @@ rest_of_handle_sched2 (tree decl, rtx insns)\n static void\n rest_of_handle_gcse2 (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   open_dump_file (DFI_gcse2, decl);\n \n   gcse_after_reload_main (insns, dump_file);\n@@ -839,6 +876,9 @@ rest_of_handle_gcse2 (tree decl, rtx insns)\n static void\n rest_of_handle_regmove (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   timevar_push (TV_REGMOVE);\n   open_dump_file (DFI_regmove, decl);\n \n@@ -855,6 +895,9 @@ rest_of_handle_regmove (tree decl, rtx insns)\n static void\n rest_of_handle_tracer (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   open_dump_file (DFI_tracer, decl);\n   if (dump_file)\n     dump_flow_info (dump_file);\n@@ -868,6 +911,9 @@ rest_of_handle_tracer (tree decl, rtx insns)\n static void\n rest_of_handle_if_conversion (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   open_dump_file (DFI_ce1, decl);\n   if (flag_if_conversion)\n     {\n@@ -891,6 +937,9 @@ rest_of_handle_if_conversion (tree decl, rtx insns)\n static void\n rest_of_handle_if_after_combine (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   timevar_push (TV_IFCVT);\n   open_dump_file (DFI_ce2, decl);\n \n@@ -905,6 +954,9 @@ rest_of_handle_if_after_combine (tree decl, rtx insns)\n static void\n rest_of_handle_web (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   open_dump_file (DFI_web, decl);\n   timevar_push (TV_WEB);\n   web_main ();\n@@ -921,6 +973,8 @@ static void\n rest_of_handle_branch_prob (tree decl, rtx insns)\n {\n   struct loops loops;\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n \n   timevar_push (TV_BRANCH_PROB);\n   open_dump_file (DFI_bp, decl);\n@@ -949,6 +1003,9 @@ rest_of_handle_branch_prob (tree decl, rtx insns)\n static void\n rest_of_handle_value_profile_transformations (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   open_dump_file (DFI_vpt, decl);\n   timevar_push (TV_VPT);\n \n@@ -964,6 +1021,9 @@ rest_of_handle_value_profile_transformations (tree decl, rtx insns)\n static void\n rest_of_handle_cfg (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   open_dump_file (DFI_cfg, decl);\n   if (dump_file)\n     dump_flow_info (dump_file);\n@@ -993,6 +1053,9 @@ rest_of_handle_cfg (tree decl, rtx insns)\n static void\n rest_of_handle_addressof (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   open_dump_file (DFI_addressof, decl);\n \n   purge_addressof (insns);\n@@ -1007,6 +1070,9 @@ rest_of_handle_addressof (tree decl, rtx insns)\n static void\n rest_of_handle_jump_bypass (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   timevar_push (TV_BYPASS);\n   open_dump_file (DFI_bypass, decl);\n \n@@ -1036,6 +1102,9 @@ rest_of_handle_combine (tree decl, rtx insns)\n {\n   int rebuild_jump_labels_after_combine = 0;\n \n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   timevar_push (TV_COMBINE);\n   open_dump_file (DFI_combine, decl);\n \n@@ -1064,6 +1133,9 @@ rest_of_handle_combine (tree decl, rtx insns)\n static void\n rest_of_handle_life (tree decl, rtx insns)\n {\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   open_dump_file (DFI_life, decl);\n   regclass_init ();\n \n@@ -1110,6 +1182,8 @@ static void\n rest_of_handle_cse (tree decl, rtx insns)\n {\n   int tem;\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n \n   open_dump_file (DFI_cse, decl);\n   if (dump_file)\n@@ -1142,6 +1216,8 @@ static void\n rest_of_handle_cse2 (tree decl, rtx insns)\n {\n   int tem;\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n \n   timevar_push (TV_CSE2);\n   open_dump_file (DFI_cse2, decl);\n@@ -1178,6 +1254,8 @@ rest_of_handle_gcse (tree decl, rtx insns)\n {\n   int save_csb, save_cfj;\n   int tem2 = 0, tem;\n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n \n   timevar_push (TV_GCSE);\n   open_dump_file (DFI_gcse, decl);\n@@ -1241,6 +1319,9 @@ rest_of_handle_loop_optimize (tree decl, rtx insns)\n {\n   int do_unroll, do_prefetch;\n \n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   timevar_push (TV_LOOP);\n   delete_dead_jumptables ();\n   cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n@@ -1294,6 +1375,9 @@ rest_of_handle_loop2 (tree decl, rtx insns)\n   struct loops *loops;\n   basic_block bb;\n \n+  if (decl != current_function_decl || insns != get_insns ())\n+    abort ();\n+\n   if (!flag_unswitch_loops\n       && !flag_peel_loops\n       && !flag_unroll_loops\n@@ -1353,11 +1437,15 @@ rest_of_handle_loop2 (tree decl, rtx insns)\n    After we return, the tree storage is freed.  */\n \n void\n-rest_of_compilation (tree decl)\n+rest_of_compilation (void)\n {\n+  tree decl = current_function_decl;\n   rtx insns;\n \n-  timevar_push (TV_REST_OF_COMPILATION);\n+\n+  /* There's no need to defer outputting this function any more; we\n+     know we want to output it.  */\n+  DECL_DEFER_OUTPUT (current_function_decl) = 0;\n \n   /* There's no need to defer outputting this function any more; we\n      know we want to output it.  */\n@@ -1935,10 +2023,6 @@ rest_of_compilation (tree decl)\n \n   /* We're done with this function.  Free up memory if we can.  */\n   free_after_parsing (cfun);\n-\n-  ggc_collect ();\n-\n-  timevar_pop (TV_REST_OF_COMPILATION);\n }\n \n void\n@@ -2019,3 +2103,21 @@ enable_rtl_dump_file (int letter)\n \n   return matched;\n }\n+\n+struct tree_opt_pass pass_rest_of_compilation =\n+{\n+  \"rest of compilation\",                /* name */\n+  NULL,\t\t                        /* gate */\n+  rest_of_compilation,                  /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_REST_OF_COMPILATION,               /* tv_id */\n+  PROP_rtl,\t\t                /* properties_required */\n+  0,                                    /* properties_provided */\n+  PROP_rtl,                             /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_ggc_collect\t\t\t/* todo_flags_finish */\n+};\n+\n+"}, {"sha": "ad82644bd9296583ad164c3c84c97c2328d7bb4b", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 26, "deletions": 89, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b", "patch": "@@ -210,17 +210,31 @@ register_one_dump_file (struct tree_opt_pass *pass)\n   pass->static_pass_number = dump_register (dot_name, flag_name);\n }\n \n-static void \n-register_dump_files (struct tree_opt_pass *pass)\n+static int \n+register_dump_files (struct tree_opt_pass *pass, int properties)\n {\n   do\n     {\n-      register_one_dump_file (pass);\n+      /* Verify that all required properties are present.  */\n+      if (pass->properties_required & ~properties)\n+        abort ();\n+\n+      if (pass->properties_destroyed & pass->properties_provided)\n+        abort ();\n+\n+      pass->properties_required = properties;\n+      pass->properties_provided = properties =\n+        (properties | pass->properties_provided) & ~pass->properties_destroyed;\n+\n+      if (properties & PROP_trees)\n+        register_one_dump_file (pass);\n       if (pass->sub)\n-\tregister_dump_files (pass->sub);\n+\tproperties = register_dump_files (pass->sub, properties);\n       pass = pass->next;\n     }\n   while (pass);\n+\n+  return properties;\n }\n \n /* Duplicate a pass that's to be run more than once.  */\n@@ -272,6 +286,8 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_all_optimizations);\n   NEXT_PASS (pass_mudflap_2);\n   NEXT_PASS (pass_rebuild_bind);\n+  NEXT_PASS (pass_expand);\n+  NEXT_PASS (pass_rest_of_compilation);\n   *p = NULL;\n \n   p = &pass_all_optimizations.sub;\n@@ -326,12 +342,11 @@ init_tree_optimization_passes (void)\n #undef DUP_PASS\n \n   /* Register the passes with the tree dump code.  */\n-  register_dump_files (all_passes);\n+  register_dump_files (all_passes, 0);\n }\n \n static void execute_pass_list (struct tree_opt_pass *);\n \n-static unsigned int current_properties;\n static unsigned int last_verified;\n \n static void\n@@ -370,9 +385,9 @@ execute_one_pass (struct tree_opt_pass *pass)\n   if (pass->gate && !pass->gate ())\n     return false;\n \n-  /* Verify that all required properties are present.  */\n-  if (pass->properties_required & ~current_properties)\n-    abort ();\n+  /* Note that the folders should only create gimple expressions.\n+     This is a hack until the new folder is ready.  */\n+  in_gimple_form = (pass->properties_provided & PROP_trees) != 0;\n \n   /* Run pre-pass verification.  */\n   todo = pass->todo_flags_start & ~last_verified;\n@@ -411,10 +426,6 @@ execute_one_pass (struct tree_opt_pass *pass)\n   if (todo)\n     execute_todo (todo);\n \n-  /* Update properties.  */\n-  current_properties &= ~pass->properties_destroyed;\n-  current_properties |= pass->properties_provided;\n-\n   /* Close down timevar and dump file.  */\n   if (pass->tv_id)\n     timevar_pop (pass->tv_id);\n@@ -440,25 +451,6 @@ execute_pass_list (struct tree_opt_pass *pass)\n }\n \n \f\n-/* Called to move the SAVE_EXPRs for parameter declarations in a\n-   nested function into the nested function.  DATA is really the\n-   nested FUNCTION_DECL.  */\n-\n-static tree\n-set_save_expr_context (tree *tp,\n-\t\t       int *walk_subtrees,\n-\t\t       void *data)\n-{\n-  if (TREE_CODE (*tp) == SAVE_EXPR && !SAVE_EXPR_CONTEXT (*tp))\n-    SAVE_EXPR_CONTEXT (*tp) = (tree) data;\n-  /* Do not walk back into the SAVE_EXPR_CONTEXT; that will cause\n-     circularity.  */\n-  else if (DECL_P (*tp))\n-    *walk_subtrees = 0;\n-\n-  return NULL;\n-}\n-\n /* For functions-as-trees languages, this performs all optimization and\n    compilation for FNDECL.  */\n \n@@ -522,68 +514,13 @@ tree_rest_of_compilation (tree fndecl, bool nested_p)\n \t}\n     }\n \n-  /* Note that the folders should only create gimple expressions.\n-     This is a hack until the new folder is ready.  */\n-  in_gimple_form = true;\n-\n-  /* Perform all tree transforms and optimizations.  */\n-  execute_pass_list (all_passes);\n-\n-  /* Note that the folders can create non-gimple expressions again.  */\n-  in_gimple_form = false;\n-\n-  /* If the function has a variably modified type, there may be\n-     SAVE_EXPRs in the parameter types.  Their context must be set to\n-     refer to this function; they cannot be expanded in the containing\n-     function.  */\n-  if (decl_function_context (fndecl) == current_function_decl\n-      && variably_modified_type_p (TREE_TYPE (fndecl)))\n-    walk_tree (&TREE_TYPE (fndecl), set_save_expr_context, fndecl,\n-\t       NULL);\n-\n-  /* Expand the variables recorded during gimple lowering.  This must\n-     occur before the call to expand_function_start to ensure that\n-     all used variables are expanded before we expand anything on the\n-     PENDING_SIZES list.  */\n-  expand_used_vars ();\n-\n-  /* Set up parameters and prepare for return, for the function.  */\n-  expand_function_start (fndecl, 0);\n-\n-  /* If this function is `main', emit a call to `__main'\n-     to run global initializers, etc.  */\n-  if (DECL_NAME (fndecl)\n-      && MAIN_NAME_P (DECL_NAME (fndecl))\n-      && DECL_FILE_SCOPE_P (fndecl))\n-    expand_main_function ();\n-\n-  /* Generate the RTL for this function.  */\n-  expand_expr_stmt_value (DECL_SAVED_TREE (fndecl), 0, 0);\n-\n-  /* We hard-wired immediate_size_expand to zero above.\n-     expand_function_end will decrement this variable.  So, we set the\n-     variable to one here, so that after the decrement it will remain\n-     zero.  */\n-  immediate_size_expand = 1;\n-\n-  /* Make sure the locus is set to the end of the function, so that \n-     epilogue line numbers and warnings are set properly.  */\n-  if (cfun->function_end_locus.file)\n-    input_location = cfun->function_end_locus;\n-\n-  /* The following insns belong to the top scope.  */\n-  record_block_change (DECL_INITIAL (current_function_decl));\n-  \n-  /* Generate rtl for function exit.  */\n-  expand_function_end ();\n-\n   /* If this is a nested function, protect the local variables in the stack\n      above us from being collected while we're compiling this function.  */\n   if (nested_p)\n     ggc_push_context ();\n \n-  /* Run the optimizers and output the assembler code for this function.  */\n-  rest_of_compilation (fndecl);\n+  /* Perform all tree transforms and optimizations.  */\n+  execute_pass_list (all_passes);\n \n   /* Restore original body if still needed.  */\n   if (cfun->saved_tree)"}, {"sha": "3a8c31ea7af9ce43d53a7e8241f809665e847d07", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=2f8e398bf476a5b0682e6fdc0f8b64df1cf0347b", "patch": "@@ -75,6 +75,10 @@ struct tree_opt_pass\n #define PROP_pta\t\t(1 << 5)\n #define PROP_ssa\t\t(1 << 6)\n #define PROP_no_crit_edges      (1 << 7)\n+#define PROP_rtl\t\t(1 << 8)\n+\n+#define PROP_trees \\\n+  (PROP_gimple_any | PROP_gimple_lcf | PROP_gimple_leh)\n \n /* To-do flags.  */\n #define TODO_dump_func\t\t(1 << 0)\t/* pass doesn't dump itself */\n@@ -125,6 +129,8 @@ extern struct tree_opt_pass pass_dse;\n extern struct tree_opt_pass pass_nrv;\n extern struct tree_opt_pass pass_remove_useless_vars;\n extern struct tree_opt_pass pass_rename_ssa_copies;\n+extern struct tree_opt_pass pass_expand;\n+extern struct tree_opt_pass pass_rest_of_compilation;\n \n \n #endif /* GCC_TREE_PASS_H */"}]}