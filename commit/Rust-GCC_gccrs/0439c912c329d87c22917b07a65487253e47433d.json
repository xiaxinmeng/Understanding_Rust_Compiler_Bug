{"sha": "0439c912c329d87c22917b07a65487253e47433d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQzOWM5MTJjMzI5ZDg3YzIyOTE3YjA3YTY1NDg3MjUzZTQ3NDMzZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-18T09:25:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-18T09:25:40Z"}, "message": "[multiple changes]\n\n2014-07-18  Vincent Celier  <celier@adacore.com>\n\n\t* debug.adb: Update comment.\n\n2014-07-18  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_util.adb (Needs_Finalization): There is no reason why a\n\tC type should not benefit from finalization actions.\n\n2014-07-18  Thomas Quinot  <quinot@adacore.com>\n\n\t* s-oscons-tmplt.c (NAME_MAX): Fix definition for Solaris\n\t(FILENAME_MAX): Remove unneeded definition.\n\nFrom-SVN: r212785", "tree": {"sha": "916c8efd989256a5db10ceeeddb4e7d7780ad769", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/916c8efd989256a5db10ceeeddb4e7d7780ad769"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0439c912c329d87c22917b07a65487253e47433d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0439c912c329d87c22917b07a65487253e47433d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0439c912c329d87c22917b07a65487253e47433d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0439c912c329d87c22917b07a65487253e47433d/comments", "author": null, "committer": null, "parents": [{"sha": "5b89faafa8b5174dfe9e4e94695e57e9009440c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b89faafa8b5174dfe9e4e94695e57e9009440c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b89faafa8b5174dfe9e4e94695e57e9009440c3"}], "stats": {"total": 414, "additions": 278, "deletions": 136}, "files": [{"sha": "8641503d493383ac5e85a99f4a504e0ea20292fc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0439c912c329d87c22917b07a65487253e47433d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0439c912c329d87c22917b07a65487253e47433d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0439c912c329d87c22917b07a65487253e47433d", "patch": "@@ -1,3 +1,17 @@\n+2014-07-18  Vincent Celier  <celier@adacore.com>\n+\n+\t* debug.adb: Update comment.\n+\n+2014-07-18  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_util.adb (Needs_Finalization): There is no reason why a\n+\tC type should not benefit from finalization actions.\n+\n+2014-07-18  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* s-oscons-tmplt.c (NAME_MAX): Fix definition for Solaris\n+\t(FILENAME_MAX): Remove unneeded definition.\n+\n 2014-07-18  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_attr.adb, debug.adb: Update comments."}, {"sha": "97277d61de4141a9dcfe9d1940084c97d4b0886c", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 246, "deletions": 125, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0439c912c329d87c22917b07a65487253e47433d/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0439c912c329d87c22917b07a65487253e47433d/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=0439c912c329d87c22917b07a65487253e47433d", "patch": "@@ -135,7 +135,6 @@ package body Debug is\n    --  d.O  Dump internal SCO tables\n    --  d.P  Previous (non-optimized) handling of length comparisons\n    --  d.Q  Previous (incomplete) style check for binary operators\n-   --       ??? need to add doc for above switch\n    --  d.R  Restrictions in ali files in positional form\n    --  d.S  Force Optimize_Alignment (Space)\n    --  d.T  Force Optimize_Alignment (Time)\n@@ -821,82 +820,143 @@ package body Debug is\n    --------------------\n \n    procedure Set_Debug_Flag (C : Character; Val : Boolean := True) is\n-      subtype Dig  is Character range '1' .. '9';\n+      subtype Dig is Character range '1' .. '9';\n       subtype LLet is Character range 'a' .. 'z';\n       subtype ULet is Character range 'A' .. 'Z';\n \n    begin\n       if C in Dig then\n          case Dig (C) is\n-            when '1' => Debug_Flag_1 := Val;\n-            when '2' => Debug_Flag_2 := Val;\n-            when '3' => Debug_Flag_3 := Val;\n-            when '4' => Debug_Flag_4 := Val;\n-            when '5' => Debug_Flag_5 := Val;\n-            when '6' => Debug_Flag_6 := Val;\n-            when '7' => Debug_Flag_7 := Val;\n-            when '8' => Debug_Flag_8 := Val;\n-            when '9' => Debug_Flag_9 := Val;\n+            when '1' =>\n+               Debug_Flag_1 := Val;\n+            when '2' =>\n+               Debug_Flag_2 := Val;\n+            when '3' =>\n+               Debug_Flag_3 := Val;\n+            when '4' =>\n+               Debug_Flag_4 := Val;\n+            when '5' =>\n+               Debug_Flag_5 := Val;\n+            when '6' =>\n+               Debug_Flag_6 := Val;\n+            when '7' =>\n+               Debug_Flag_7 := Val;\n+            when '8' =>\n+               Debug_Flag_8 := Val;\n+            when '9' =>\n+               Debug_Flag_9 := Val;\n          end case;\n \n       elsif C in ULet then\n          case ULet (C) is\n-            when 'A' => Debug_Flag_AA := Val;\n-            when 'B' => Debug_Flag_BB := Val;\n-            when 'C' => Debug_Flag_CC := Val;\n-            when 'D' => Debug_Flag_DD := Val;\n-            when 'E' => Debug_Flag_EE := Val;\n-            when 'F' => Debug_Flag_FF := Val;\n-            when 'G' => Debug_Flag_GG := Val;\n-            when 'H' => Debug_Flag_HH := Val;\n-            when 'I' => Debug_Flag_II := Val;\n-            when 'J' => Debug_Flag_JJ := Val;\n-            when 'K' => Debug_Flag_KK := Val;\n-            when 'L' => Debug_Flag_LL := Val;\n-            when 'M' => Debug_Flag_MM := Val;\n-            when 'N' => Debug_Flag_NN := Val;\n-            when 'O' => Debug_Flag_OO := Val;\n-            when 'P' => Debug_Flag_PP := Val;\n-            when 'Q' => Debug_Flag_QQ := Val;\n-            when 'R' => Debug_Flag_RR := Val;\n-            when 'S' => Debug_Flag_SS := Val;\n-            when 'T' => Debug_Flag_TT := Val;\n-            when 'U' => Debug_Flag_UU := Val;\n-            when 'V' => Debug_Flag_VV := Val;\n-            when 'W' => Debug_Flag_WW := Val;\n-            when 'X' => Debug_Flag_XX := Val;\n-            when 'Y' => Debug_Flag_YY := Val;\n-            when 'Z' => Debug_Flag_ZZ := Val;\n+            when 'A' =>\n+               Debug_Flag_AA := Val;\n+            when 'B' =>\n+               Debug_Flag_BB := Val;\n+            when 'C' =>\n+               Debug_Flag_CC := Val;\n+            when 'D' =>\n+               Debug_Flag_DD := Val;\n+            when 'E' =>\n+               Debug_Flag_EE := Val;\n+            when 'F' =>\n+               Debug_Flag_FF := Val;\n+            when 'G' =>\n+               Debug_Flag_GG := Val;\n+            when 'H' =>\n+               Debug_Flag_HH := Val;\n+            when 'I' =>\n+               Debug_Flag_II := Val;\n+            when 'J' =>\n+               Debug_Flag_JJ := Val;\n+            when 'K' =>\n+               Debug_Flag_KK := Val;\n+            when 'L' =>\n+               Debug_Flag_LL := Val;\n+            when 'M' =>\n+               Debug_Flag_MM := Val;\n+            when 'N' =>\n+               Debug_Flag_NN := Val;\n+            when 'O' =>\n+               Debug_Flag_OO := Val;\n+            when 'P' =>\n+               Debug_Flag_PP := Val;\n+            when 'Q' =>\n+               Debug_Flag_QQ := Val;\n+            when 'R' =>\n+               Debug_Flag_RR := Val;\n+            when 'S' =>\n+               Debug_Flag_SS := Val;\n+            when 'T' =>\n+               Debug_Flag_TT := Val;\n+            when 'U' =>\n+               Debug_Flag_UU := Val;\n+            when 'V' =>\n+               Debug_Flag_VV := Val;\n+            when 'W' =>\n+               Debug_Flag_WW := Val;\n+            when 'X' =>\n+               Debug_Flag_XX := Val;\n+            when 'Y' =>\n+               Debug_Flag_YY := Val;\n+            when 'Z' =>\n+               Debug_Flag_ZZ := Val;\n          end case;\n \n       else\n          case LLet (C) is\n-            when 'a' => Debug_Flag_A := Val;\n-            when 'b' => Debug_Flag_B := Val;\n-            when 'c' => Debug_Flag_C := Val;\n-            when 'd' => Debug_Flag_D := Val;\n-            when 'e' => Debug_Flag_E := Val;\n-            when 'f' => Debug_Flag_F := Val;\n-            when 'g' => Debug_Flag_G := Val;\n-            when 'h' => Debug_Flag_H := Val;\n-            when 'i' => Debug_Flag_I := Val;\n-            when 'j' => Debug_Flag_J := Val;\n-            when 'k' => Debug_Flag_K := Val;\n-            when 'l' => Debug_Flag_L := Val;\n-            when 'm' => Debug_Flag_M := Val;\n-            when 'n' => Debug_Flag_N := Val;\n-            when 'o' => Debug_Flag_O := Val;\n-            when 'p' => Debug_Flag_P := Val;\n-            when 'q' => Debug_Flag_Q := Val;\n-            when 'r' => Debug_Flag_R := Val;\n-            when 's' => Debug_Flag_S := Val;\n-            when 't' => Debug_Flag_T := Val;\n-            when 'u' => Debug_Flag_U := Val;\n-            when 'v' => Debug_Flag_V := Val;\n-            when 'w' => Debug_Flag_W := Val;\n-            when 'x' => Debug_Flag_X := Val;\n-            when 'y' => Debug_Flag_Y := Val;\n-            when 'z' => Debug_Flag_Z := Val;\n+            when 'a' =>\n+               Debug_Flag_A := Val;\n+            when 'b' =>\n+               Debug_Flag_B := Val;\n+            when 'c' =>\n+               Debug_Flag_C := Val;\n+            when 'd' =>\n+               Debug_Flag_D := Val;\n+            when 'e' =>\n+               Debug_Flag_E := Val;\n+            when 'f' =>\n+               Debug_Flag_F := Val;\n+            when 'g' =>\n+               Debug_Flag_G := Val;\n+            when 'h' =>\n+               Debug_Flag_H := Val;\n+            when 'i' =>\n+               Debug_Flag_I := Val;\n+            when 'j' =>\n+               Debug_Flag_J := Val;\n+            when 'k' =>\n+               Debug_Flag_K := Val;\n+            when 'l' =>\n+               Debug_Flag_L := Val;\n+            when 'm' =>\n+               Debug_Flag_M := Val;\n+            when 'n' =>\n+               Debug_Flag_N := Val;\n+            when 'o' =>\n+               Debug_Flag_O := Val;\n+            when 'p' =>\n+               Debug_Flag_P := Val;\n+            when 'q' =>\n+               Debug_Flag_Q := Val;\n+            when 'r' =>\n+               Debug_Flag_R := Val;\n+            when 's' =>\n+               Debug_Flag_S := Val;\n+            when 't' =>\n+               Debug_Flag_T := Val;\n+            when 'u' =>\n+               Debug_Flag_U := Val;\n+            when 'v' =>\n+               Debug_Flag_V := Val;\n+            when 'w' =>\n+               Debug_Flag_W := Val;\n+            when 'x' =>\n+               Debug_Flag_X := Val;\n+            when 'y' =>\n+               Debug_Flag_Y := Val;\n+            when 'z' =>\n+               Debug_Flag_Z := Val;\n          end case;\n       end if;\n    end Set_Debug_Flag;\n@@ -906,82 +966,143 @@ package body Debug is\n    ---------------------------\n \n    procedure Set_Dotted_Debug_Flag (C : Character; Val : Boolean := True) is\n-      subtype Dig  is Character range '1' .. '9';\n+      subtype Dig is Character range '1' .. '9';\n       subtype LLet is Character range 'a' .. 'z';\n       subtype ULet is Character range 'A' .. 'Z';\n \n    begin\n       if C in Dig then\n          case Dig (C) is\n-            when '1' => Debug_Flag_Dot_1 := Val;\n-            when '2' => Debug_Flag_Dot_2 := Val;\n-            when '3' => Debug_Flag_Dot_3 := Val;\n-            when '4' => Debug_Flag_Dot_4 := Val;\n-            when '5' => Debug_Flag_Dot_5 := Val;\n-            when '6' => Debug_Flag_Dot_6 := Val;\n-            when '7' => Debug_Flag_Dot_7 := Val;\n-            when '8' => Debug_Flag_Dot_8 := Val;\n-            when '9' => Debug_Flag_Dot_9 := Val;\n+            when '1' =>\n+               Debug_Flag_Dot_1 := Val;\n+            when '2' =>\n+               Debug_Flag_Dot_2 := Val;\n+            when '3' =>\n+               Debug_Flag_Dot_3 := Val;\n+            when '4' =>\n+               Debug_Flag_Dot_4 := Val;\n+            when '5' =>\n+               Debug_Flag_Dot_5 := Val;\n+            when '6' =>\n+               Debug_Flag_Dot_6 := Val;\n+            when '7' =>\n+               Debug_Flag_Dot_7 := Val;\n+            when '8' =>\n+               Debug_Flag_Dot_8 := Val;\n+            when '9' =>\n+               Debug_Flag_Dot_9 := Val;\n          end case;\n \n       elsif C in ULet then\n          case ULet (C) is\n-            when 'A' => Debug_Flag_Dot_AA := Val;\n-            when 'B' => Debug_Flag_Dot_BB := Val;\n-            when 'C' => Debug_Flag_Dot_CC := Val;\n-            when 'D' => Debug_Flag_Dot_DD := Val;\n-            when 'E' => Debug_Flag_Dot_EE := Val;\n-            when 'F' => Debug_Flag_Dot_FF := Val;\n-            when 'G' => Debug_Flag_Dot_GG := Val;\n-            when 'H' => Debug_Flag_Dot_HH := Val;\n-            when 'I' => Debug_Flag_Dot_II := Val;\n-            when 'J' => Debug_Flag_Dot_JJ := Val;\n-            when 'K' => Debug_Flag_Dot_KK := Val;\n-            when 'L' => Debug_Flag_Dot_LL := Val;\n-            when 'M' => Debug_Flag_Dot_MM := Val;\n-            when 'N' => Debug_Flag_Dot_NN := Val;\n-            when 'O' => Debug_Flag_Dot_OO := Val;\n-            when 'P' => Debug_Flag_Dot_PP := Val;\n-            when 'Q' => Debug_Flag_Dot_QQ := Val;\n-            when 'R' => Debug_Flag_Dot_RR := Val;\n-            when 'S' => Debug_Flag_Dot_SS := Val;\n-            when 'T' => Debug_Flag_Dot_TT := Val;\n-            when 'U' => Debug_Flag_Dot_UU := Val;\n-            when 'V' => Debug_Flag_Dot_VV := Val;\n-            when 'W' => Debug_Flag_Dot_WW := Val;\n-            when 'X' => Debug_Flag_Dot_XX := Val;\n-            when 'Y' => Debug_Flag_Dot_YY := Val;\n-            when 'Z' => Debug_Flag_Dot_ZZ := Val;\n+            when 'A' =>\n+               Debug_Flag_Dot_AA := Val;\n+            when 'B' =>\n+               Debug_Flag_Dot_BB := Val;\n+            when 'C' =>\n+               Debug_Flag_Dot_CC := Val;\n+            when 'D' =>\n+               Debug_Flag_Dot_DD := Val;\n+            when 'E' =>\n+               Debug_Flag_Dot_EE := Val;\n+            when 'F' =>\n+               Debug_Flag_Dot_FF := Val;\n+            when 'G' =>\n+               Debug_Flag_Dot_GG := Val;\n+            when 'H' =>\n+               Debug_Flag_Dot_HH := Val;\n+            when 'I' =>\n+               Debug_Flag_Dot_II := Val;\n+            when 'J' =>\n+               Debug_Flag_Dot_JJ := Val;\n+            when 'K' =>\n+               Debug_Flag_Dot_KK := Val;\n+            when 'L' =>\n+               Debug_Flag_Dot_LL := Val;\n+            when 'M' =>\n+               Debug_Flag_Dot_MM := Val;\n+            when 'N' =>\n+               Debug_Flag_Dot_NN := Val;\n+            when 'O' =>\n+               Debug_Flag_Dot_OO := Val;\n+            when 'P' =>\n+               Debug_Flag_Dot_PP := Val;\n+            when 'Q' =>\n+               Debug_Flag_Dot_QQ := Val;\n+            when 'R' =>\n+               Debug_Flag_Dot_RR := Val;\n+            when 'S' =>\n+               Debug_Flag_Dot_SS := Val;\n+            when 'T' =>\n+               Debug_Flag_Dot_TT := Val;\n+            when 'U' =>\n+               Debug_Flag_Dot_UU := Val;\n+            when 'V' =>\n+               Debug_Flag_Dot_VV := Val;\n+            when 'W' =>\n+               Debug_Flag_Dot_WW := Val;\n+            when 'X' =>\n+               Debug_Flag_Dot_XX := Val;\n+            when 'Y' =>\n+               Debug_Flag_Dot_YY := Val;\n+            when 'Z' =>\n+               Debug_Flag_Dot_ZZ := Val;\n          end case;\n \n       else\n          case LLet (C) is\n-            when 'a' => Debug_Flag_Dot_A := Val;\n-            when 'b' => Debug_Flag_Dot_B := Val;\n-            when 'c' => Debug_Flag_Dot_C := Val;\n-            when 'd' => Debug_Flag_Dot_D := Val;\n-            when 'e' => Debug_Flag_Dot_E := Val;\n-            when 'f' => Debug_Flag_Dot_F := Val;\n-            when 'g' => Debug_Flag_Dot_G := Val;\n-            when 'h' => Debug_Flag_Dot_H := Val;\n-            when 'i' => Debug_Flag_Dot_I := Val;\n-            when 'j' => Debug_Flag_Dot_J := Val;\n-            when 'k' => Debug_Flag_Dot_K := Val;\n-            when 'l' => Debug_Flag_Dot_L := Val;\n-            when 'm' => Debug_Flag_Dot_M := Val;\n-            when 'n' => Debug_Flag_Dot_N := Val;\n-            when 'o' => Debug_Flag_Dot_O := Val;\n-            when 'p' => Debug_Flag_Dot_P := Val;\n-            when 'q' => Debug_Flag_Dot_Q := Val;\n-            when 'r' => Debug_Flag_Dot_R := Val;\n-            when 's' => Debug_Flag_Dot_S := Val;\n-            when 't' => Debug_Flag_Dot_T := Val;\n-            when 'u' => Debug_Flag_Dot_U := Val;\n-            when 'v' => Debug_Flag_Dot_V := Val;\n-            when 'w' => Debug_Flag_Dot_W := Val;\n-            when 'x' => Debug_Flag_Dot_X := Val;\n-            when 'y' => Debug_Flag_Dot_Y := Val;\n-            when 'z' => Debug_Flag_Dot_Z := Val;\n+            when 'a' =>\n+               Debug_Flag_Dot_A := Val;\n+            when 'b' =>\n+               Debug_Flag_Dot_B := Val;\n+            when 'c' =>\n+               Debug_Flag_Dot_C := Val;\n+            when 'd' =>\n+               Debug_Flag_Dot_D := Val;\n+            when 'e' =>\n+               Debug_Flag_Dot_E := Val;\n+            when 'f' =>\n+               Debug_Flag_Dot_F := Val;\n+            when 'g' =>\n+               Debug_Flag_Dot_G := Val;\n+            when 'h' =>\n+               Debug_Flag_Dot_H := Val;\n+            when 'i' =>\n+               Debug_Flag_Dot_I := Val;\n+            when 'j' =>\n+               Debug_Flag_Dot_J := Val;\n+            when 'k' =>\n+               Debug_Flag_Dot_K := Val;\n+            when 'l' =>\n+               Debug_Flag_Dot_L := Val;\n+            when 'm' =>\n+               Debug_Flag_Dot_M := Val;\n+            when 'n' =>\n+               Debug_Flag_Dot_N := Val;\n+            when 'o' =>\n+               Debug_Flag_Dot_O := Val;\n+            when 'p' =>\n+               Debug_Flag_Dot_P := Val;\n+            when 'q' =>\n+               Debug_Flag_Dot_Q := Val;\n+            when 'r' =>\n+               Debug_Flag_Dot_R := Val;\n+            when 's' =>\n+               Debug_Flag_Dot_S := Val;\n+            when 't' =>\n+               Debug_Flag_Dot_T := Val;\n+            when 'u' =>\n+               Debug_Flag_Dot_U := Val;\n+            when 'v' =>\n+               Debug_Flag_Dot_V := Val;\n+            when 'w' =>\n+               Debug_Flag_Dot_W := Val;\n+            when 'x' =>\n+               Debug_Flag_Dot_X := Val;\n+            when 'y' =>\n+               Debug_Flag_Dot_Y := Val;\n+            when 'z' =>\n+               Debug_Flag_Dot_Z := Val;\n          end case;\n       end if;\n    end Set_Dotted_Debug_Flag;"}, {"sha": "ea337266105ddde0fd1e582ea5e2e65e3daa1b01", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0439c912c329d87c22917b07a65487253e47433d/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0439c912c329d87c22917b07a65487253e47433d/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=0439c912c329d87c22917b07a65487253e47433d", "patch": "@@ -6340,11 +6340,10 @@ package body Exp_Util is\n       if Restriction_Active (No_Finalization) then\n          return False;\n \n-      --  C, C++, CIL and Java types are not considered controlled. It is\n-      --  assumed that the non-Ada side will handle their clean up.\n+      --  C++, CIL and Java types are not considered controlled. It is assumed\n+      --  that the non-Ada side will handle their clean up.\n \n-      elsif Convention (T) = Convention_C\n-        or else Convention (T) = Convention_CIL\n+      elsif Convention (T) = Convention_CIL\n         or else Convention (T) = Convention_CPP\n         or else Convention (T) = Convention_Java\n       then"}, {"sha": "0d79d6fdbb968ee5b6410cbd0d2aff991edf3542", "filename": "gcc/ada/s-oscons-tmplt.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0439c912c329d87c22917b07a65487253e47433d/gcc%2Fada%2Fs-oscons-tmplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0439c912c329d87c22917b07a65487253e47433d/gcc%2Fada%2Fs-oscons-tmplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-oscons-tmplt.c?ref=0439c912c329d87c22917b07a65487253e47433d", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2000-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -314,16 +314,24 @@ CND(SIZEOF_unsigned_int, \"Size of unsigned int\")\n #endif\n CND(IOV_MAX, \"Maximum writev iovcnt\")\n \n+/* NAME_MAX is used to compute the allocation size for a struct dirent\n+ * passed to readdir() / readdir_r(). However on some systems it is not\n+ * defined, as it is technically a filesystem dependent property that\n+ * we should retrieve through pathconf().\n+ */\n #ifndef NAME_MAX\n-# define NAME_MAX 255\n+# ifdef MAXNAMELEN\n+   /* Solaris has no NAME_MAX but defines MAXNAMELEN */\n+#  define NAME_MAX MAXNAMELEN\n+# else\n+   /* PATH_MAX (maximum length of a full path name) is a safe last\n+    * chance fall back.\n+    */\n+#  define NAME_MAX PATH_MAX\n+# endif\n #endif\n CND(NAME_MAX, \"Maximum file name length\")\n \n-#ifndef PATH_MAX\n-# define PATH_MAX 1024\n-#endif\n-CND(FILENAME_MAX, \"Maximum file path length\")\n-\n /*\n \n    ---------------------"}]}