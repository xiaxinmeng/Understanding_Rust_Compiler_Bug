{"sha": "39379e67c7d1f9f52e9531c815a79b24b649afe6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkzNzllNjdjN2QxZjlmNTJlOTUzMWM4MTVhNzliMjRiNjQ5YWZlNg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-06-02T22:05:38Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-06-02T22:05:38Z"}, "message": "Widen some short fields to int; Use allocate_reg_info to allocate the reg_renumber array\n\nFrom-SVN: r14142", "tree": {"sha": "d28649d18416201742bfa6e0d658ac3243511920", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d28649d18416201742bfa6e0d658ac3243511920"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39379e67c7d1f9f52e9531c815a79b24b649afe6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39379e67c7d1f9f52e9531c815a79b24b649afe6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39379e67c7d1f9f52e9531c815a79b24b649afe6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39379e67c7d1f9f52e9531c815a79b24b649afe6/comments", "author": null, "committer": null, "parents": [{"sha": "2808652ac8344bb1c2c6d4a48578fd3fd7ec1d01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2808652ac8344bb1c2c6d4a48578fd3fd7ec1d01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2808652ac8344bb1c2c6d4a48578fd3fd7ec1d01"}], "stats": {"total": 115, "additions": 78, "deletions": 37}, "files": [{"sha": "355a35e90d6481bf6812d92324bccd5091ce4efa", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39379e67c7d1f9f52e9531c815a79b24b649afe6/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39379e67c7d1f9f52e9531c815a79b24b649afe6/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=39379e67c7d1f9f52e9531c815a79b24b649afe6", "patch": "@@ -1286,7 +1286,7 @@ allocate_for_life_analysis ()\n      information, explicitly reset it here.  The allocation should have\n      already happened on the previous reg_scan pass.  Make sure in case\n      some more registers were allocated.  */\n-  allocate_reg_info (max_regno, FALSE);\n+  allocate_reg_info (max_regno, FALSE, FALSE);\n \n   for (i = 0; i < max_regno; i++)\n     REG_N_SETS (i) = 0;"}, {"sha": "3603e534d57428951e3b96b87cac361325a6de23", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39379e67c7d1f9f52e9531c815a79b24b649afe6/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39379e67c7d1f9f52e9531c815a79b24b649afe6/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=39379e67c7d1f9f52e9531c815a79b24b649afe6", "patch": "@@ -453,9 +453,8 @@ local_alloc ()\n   reg_offset = (char *) alloca (max_regno * sizeof (char));\n   reg_next_in_qty = (int *) alloca (max_regno * sizeof (int));\n \n-  reg_renumber = (short *) oballoc (max_regno * sizeof (short));\n-  for (i = 0; i < max_regno; i++)\n-    reg_renumber[i] = -1;\n+  /* Allocate the reg_renumber array */\n+  allocate_reg_info (max_regno, FALSE, TRUE);\n \n   /* Determine which pseudo-registers can be allocated by local-alloc.\n      In general, these are the registers used only in a single block and"}, {"sha": "92eab1f9821163130d731a3006ce260a38e947c7", "filename": "gcc/loop.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39379e67c7d1f9f52e9531c815a79b24b649afe6/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39379e67c7d1f9f52e9531c815a79b24b649afe6/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=39379e67c7d1f9f52e9531c815a79b24b649afe6", "patch": "@@ -139,13 +139,13 @@ static rtx loop_continue;\n    Therefore, at all times, == 0 indicates an invariant register;\n    < 0 a conditionally invariant one.  */\n \n-static short *n_times_set;\n+static int *n_times_set;\n \n /* Original value of n_times_set; same except that this value\n    is not set negative for a reg whose sets have been made candidates\n    and not set to 0 for a reg that is moved.  */\n \n-static short *n_times_used;\n+static int *n_times_used;\n \n /* Index by register number, 1 indicates that the register\n    cannot be moved or strength reduced.  */\n@@ -497,8 +497,8 @@ scan_loop (loop_start, end, nregs)\n   /* Nonzero if we are scanning instructions in a sub-loop.  */\n   int loop_depth = 0;\n \n-  n_times_set = (short *) alloca (nregs * sizeof (short));\n-  n_times_used = (short *) alloca (nregs * sizeof (short));\n+  n_times_set = (int *) alloca (nregs * sizeof (int));\n+  n_times_used = (int *) alloca (nregs * sizeof (int));\n   may_not_optimize = (char *) alloca (nregs);\n \n   /* Determine whether this loop starts with a jump down to a test at\n@@ -581,7 +581,7 @@ scan_loop (loop_start, end, nregs)\n      the setting of register I.  If this loop has calls, set\n      reg_single_usage[I].  */\n \n-  bzero ((char *) n_times_set, nregs * sizeof (short));\n+  bzero ((char *) n_times_set, nregs * sizeof (int));\n   bzero (may_not_optimize, nregs);\n \n   if (loop_has_call)\n@@ -595,7 +595,7 @@ scan_loop (loop_start, end, nregs)\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     may_not_optimize[i] = 1, n_times_set[i] = 1;\n-  bcopy ((char *) n_times_set, (char *) n_times_used, nregs * sizeof (short));\n+  bcopy ((char *) n_times_set, (char *) n_times_used, nregs * sizeof (int));\n \n   if (loop_dump_stream)\n     {"}, {"sha": "358b7bb12967e76a1cf7c247a8f892fbe22c8af0", "filename": "gcc/regclass.c", "status": "modified", "additions": 59, "deletions": 12, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39379e67c7d1f9f52e9531c815a79b24b649afe6/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39379e67c7d1f9f52e9531c815a79b24b649afe6/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=39379e67c7d1f9f52e9531c815a79b24b649afe6", "patch": "@@ -1,5 +1,5 @@\n /* Compute register class preferences for pseudo-registers.\n-   Copyright (C) 1987, 88, 91, 92, 93, 94, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 91, 92, 93, 94, 96, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1651,37 +1651,84 @@ auto_inc_dec_reg_p (reg, mode)\n \f\n /* Allocate enough space to hold NUM_REGS registers for the tables used for\n    reg_scan and flow_analysis that are indexed by the register number.  If\n-   NEW_P is set, initialize all of the registers, otherwise only initialize the\n-   new registers allocated.  The same table is kept from function to function,\n-   only reallocating it when we need more room.  */\n+   NEW_P is non zero, initialize all of the registers, otherwise only\n+   initialize the new registers allocated.  The same table is kept from\n+   function to function, only reallocating it when we need more room.  If\n+   RENUMBER_P is non zero, allocate the reg_renumber array also.  */\n \n void\n-allocate_reg_info (num_regs, new_p)\n+allocate_reg_info (num_regs, new_p, renumber_p)\n      int num_regs;\n      int new_p;\n+     int renumber_p;\n {\n   static int regno_allocated = 0;\n   static int regno_max = 0;\n+  static short *renumber = (short *)0;\n   int i;\n-  int size;\n+  int size_info;\n+  int size_renumber;\n   int min = (new_p) ? 0 : regno_max+1;\n \n+  /* If this message come up, and you want to fix it, then all of the tables\n+     like reg_renumber, etc. that use short will have to be found and lengthed\n+     to int or HOST_WIDE_INT.  */\n+\n+  /* Free up all storage allocated */\n+  if (num_regs < 0)\n+    {\n+      if (reg_n_info)\n+\t{\n+\t  free ((char *)reg_n_info);\n+\t  free ((char *)renumber);\n+\t  reg_n_info = (reg_info *)0;\n+\t  renumber = (short *)0;\n+\t}\n+      regno_allocated = 0;\n+      regno_max = 0;\n+      return;\n+    }\n+\n   if (num_regs > regno_allocated)\n     {\n       regno_allocated = num_regs + (num_regs / 20);\t/* add some slop space */\n-      size = regno_allocated * sizeof (reg_info);\n-      reg_n_info = ((reg_n_info)\n-\t\t    ? (reg_info *) xrealloc ((char *)reg_n_info, size)\n-\t\t    : (reg_info *) xmalloc (size));\n+      size_info = regno_allocated * sizeof (reg_info);\n+      size_renumber = regno_allocated * sizeof (short);\n+\n+      if (!reg_n_info)\n+\t{\n+\t  reg_n_info = (reg_info *) xmalloc (size_info);\n+\t  renumber = (short *) xmalloc (size_renumber);\n+\t}\n+\n+      else if (new_p)\t\t/* if we're zapping everything, no need to realloc */\n+\t{\n+\t  free ((char *)reg_n_info);\n+\t  free ((char *)renumber);\n+\t  reg_n_info = (reg_info *) xmalloc (size_info);\n+\t  renumber = (short *) xmalloc (size_renumber);\n+\t}\n+\n+      else\n+\t{\n+\t  reg_n_info = (reg_info *) xrealloc ((char *)reg_n_info, size_info);\n+\t  renumber = (short *) xrealloc ((char *)renumber, size_renumber);\n+\t}\n     }\n \n   if (min < num_regs)\n     {\n       bzero ((char *) &reg_n_info[min], (num_regs - min) * sizeof (reg_info));\n       for (i = min; i < num_regs; i++)\n-\tREG_BASIC_BLOCK (i) = REG_BLOCK_UNKNOWN;\n+\t{\n+\t  REG_BASIC_BLOCK (i) = REG_BLOCK_UNKNOWN;\n+\t  renumber[i] = -1;\n+\t}\n     }\n \n+  if (renumber_p)\n+    reg_renumber = renumber;\n+\n   regno_max = num_regs;\n }\n \n@@ -1709,7 +1756,7 @@ reg_scan (f, nregs, repeat)\n {\n   register rtx insn;\n \n-  allocate_reg_info (nregs, TRUE);\n+  allocate_reg_info (nregs, TRUE, FALSE);\n   max_parallel = 3;\n \n   for (insn = f; insn; insn = NEXT_INSN (insn))"}, {"sha": "5089553d0f482b37de99be6f5235d946be6f3c33", "filename": "gcc/regs.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39379e67c7d1f9f52e9531c815a79b24b649afe6/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39379e67c7d1f9f52e9531c815a79b24b649afe6/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=39379e67c7d1f9f52e9531c815a79b24b649afe6", "patch": "@@ -1,5 +1,5 @@\n /* Define per-register tables for data flow info and register allocation.\n-   Copyright (C) 1987, 1993, 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1993, 1994, 1995, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -124,7 +124,7 @@ extern reg_info *reg_n_info;\n \n    This can't be folded into reg_n_info without changing all of the\n    machine dependent directories, since the reload functions\n-   access it.  */\n+   in the machine dependent files access it.  */\n \n extern short *reg_renumber;\n \n@@ -214,4 +214,4 @@ extern int *scratch_block;\n extern int scratch_list_length;\n \n /* Allocate reg_n_info tables */\n-extern void allocate_reg_info PROTO((int, int));\n+extern void allocate_reg_info PROTO((int, int, int));"}, {"sha": "262796851b076542049da41af0da32d4c9e8db18", "filename": "gcc/sched.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39379e67c7d1f9f52e9531c815a79b24b649afe6/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39379e67c7d1f9f52e9531c815a79b24b649afe6/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=39379e67c7d1f9f52e9531c815a79b24b649afe6", "patch": "@@ -135,7 +135,6 @@ Boston, MA 02111-1307, USA.  */\n \n    Values of these arrays are copied at the end of this pass into the\n    arrays set up by flow analysis.  */\n-static short *sched_reg_n_deaths;\n static int *sched_reg_n_calls_crossed;\n static int *sched_reg_live_length;\n \n@@ -290,8 +289,10 @@ static int *insn_tick;\n \n struct sometimes\n {\n-  short offset; short bit;\n-  short live_length; short calls_crossed;\n+  int offset;\n+  int bit;\n+  int live_length;\n+  int calls_crossed;\n };\n \n /* Forward declarations.  */\n@@ -4872,20 +4873,16 @@ schedule_insns (dump_file)\n \n   if (reload_completed == 0)\n     {\n-      sched_reg_n_deaths = (short *) alloca (max_regno * sizeof (short));\n       sched_reg_n_calls_crossed = (int *) alloca (max_regno * sizeof (int));\n       sched_reg_live_length = (int *) alloca (max_regno * sizeof (int));\n       bb_dead_regs = (regset) alloca (regset_bytes);\n       bb_live_regs = (regset) alloca (regset_bytes);\n       bzero ((char *) sched_reg_n_calls_crossed, max_regno * sizeof (int));\n       bzero ((char *) sched_reg_live_length, max_regno * sizeof (int));\n-      for (i = 0; i < max_regno; i++)\n-\tsched_reg_n_deaths[i] = REG_N_DEATHS (i);\n       init_alias_analysis ();\n     }\n   else\n     {\n-      sched_reg_n_deaths = 0;\n       sched_reg_n_calls_crossed = 0;\n       sched_reg_live_length = 0;\n       bb_dead_regs = 0;"}, {"sha": "396799e5da83e639bc93ea8e7a64303877f0bfc8", "filename": "gcc/stupid.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39379e67c7d1f9f52e9531c815a79b24b649afe6/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39379e67c7d1f9f52e9531c815a79b24b649afe6/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=39379e67c7d1f9f52e9531c815a79b24b649afe6", "patch": "@@ -1,5 +1,5 @@\n /* Dummy data flow analysis for GNU compiler in nonoptimizing mode.\n-   Copyright (C) 1987, 1991, 1994, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1991, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -179,13 +179,11 @@ stupid_life_analysis (f, nregs, file)\n   regs_crosses_setjmp = (char *) alloca (nregs * sizeof (char));\n   bzero ((char *) regs_crosses_setjmp, nregs * sizeof (char));\n \n-  reg_renumber = (short *) oballoc (nregs * sizeof (short));\n+  /* Allocate the reg_renumber array */\n+  allocate_reg_info (max_regno, FALSE, TRUE);\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     reg_renumber[i] = i;\n \n-  for (i = FIRST_VIRTUAL_REGISTER; i < max_regno; i++)\n-    reg_renumber[i] = -1;\n-\n   after_insn_hard_regs\n     = (HARD_REG_SET *) alloca (max_suid * sizeof (HARD_REG_SET));\n "}]}