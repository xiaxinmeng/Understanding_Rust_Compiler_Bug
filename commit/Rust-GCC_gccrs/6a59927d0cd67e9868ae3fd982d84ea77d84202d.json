{"sha": "6a59927d0cd67e9868ae3fd982d84ea77d84202d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE1OTkyN2QwY2Q2N2U5ODY4YWUzZmQ5ODJkODRlYTc3ZDg0MjAyZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-01-20T20:36:18Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-01-20T20:36:18Z"}, "message": "cselib.c: Include alloc-pool.h\n\n\n\t* cselib.c: Include alloc-pool.h\n\t(empty_vals, empty_elt_lists, empty_elt_loc_lists): Kill.\n\t(elt_loc_list_pool, elt_list_pool, cselib_val_pool): Declare.\n\t(new_elt_list, new_elt_loc_list, unchain_one_elt_list,\n\tunchain_one_elt_loc_list_pool, unchain_one_value,\n\tnew_cselib_val): Simplify using allocpool.\n\t(cselib_init): Initialize allocpools.\n\t(cselib_finish): Finish allocpools.\n\t* Makefile.in (cselib.o): Depend on alloc-pool.h\n\nFrom-SVN: r76226", "tree": {"sha": "93365aa2d35a0194c9f8f14c0287163ab1463d7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93365aa2d35a0194c9f8f14c0287163ab1463d7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a59927d0cd67e9868ae3fd982d84ea77d84202d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a59927d0cd67e9868ae3fd982d84ea77d84202d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a59927d0cd67e9868ae3fd982d84ea77d84202d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a59927d0cd67e9868ae3fd982d84ea77d84202d/comments", "author": null, "committer": null, "parents": [{"sha": "3c53850d643480c7fa846a72db993c9d2a84ab16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c53850d643480c7fa846a72db993c9d2a84ab16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c53850d643480c7fa846a72db993c9d2a84ab16"}], "stats": {"total": 73, "additions": 39, "deletions": 34}, "files": [{"sha": "6a21f2ed007e4bad63c3a34bf8a9a214e97050aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a59927d0cd67e9868ae3fd982d84ea77d84202d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a59927d0cd67e9868ae3fd982d84ea77d84202d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a59927d0cd67e9868ae3fd982d84ea77d84202d", "patch": "@@ -1,3 +1,15 @@\n+2004-01-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cselib.c: Include alloc-pool.h\n+\t(empty_vals, empty_elt_lists, empty_elt_loc_lists): Kill.\n+\t(elt_loc_list_pool, elt_list_pool, cselib_val_pool): Declare.\n+\t(new_elt_list, new_elt_loc_list, unchain_one_elt_list,\n+\tunchain_one_elt_loc_list_pool, unchain_one_value,\n+\tnew_cselib_val): Simplify using allocpool.\n+\t(cselib_init): Initialize allocpools.\n+\t(cselib_finish): Finish allocpools.\n+\t* Makefile.in (cselib.o): Depend on alloc-pool.h\n+\n 2004-01-20  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.c (mips_load_call_address): Make the call insn"}, {"sha": "e162cb980e7607904ea3d54ce8d7122c67a7838b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a59927d0cd67e9868ae3fd982d84ea77d84202d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a59927d0cd67e9868ae3fd982d84ea77d84202d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6a59927d0cd67e9868ae3fd982d84ea77d84202d", "patch": "@@ -1635,7 +1635,8 @@ coverage.o : coverage.c gcov-io.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    gt-coverage.h $(HASHTAB_H)\n cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n-   output.h function.h cselib.h $(GGC_H) $(TM_P_H) gt-cselib.h $(PARAMS_H)\n+   output.h function.h cselib.h $(GGC_H) $(TM_P_H) gt-cselib.h $(PARAMS_H) \\\n+   alloc-pool.h\n cse.o : cse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n    output.h function.h $(BASIC_BLOCK_H) $(GGC_H) $(TM_P_H) $(TIMEVAR_H) \\"}, {"sha": "50cc0ff34c985fad233b861ea10eaac1ce2b641e", "filename": "gcc/cselib.c", "status": "modified", "additions": 25, "deletions": 33, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a59927d0cd67e9868ae3fd982d84ea77d84202d/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a59927d0cd67e9868ae3fd982d84ea77d84202d/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=6a59927d0cd67e9868ae3fd982d84ea77d84202d", "patch": "@@ -40,6 +40,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"hashtab.h\"\n #include \"cselib.h\"\n #include \"params.h\"\n+#include \"alloc-pool.h\"\n \n static int entry_and_rtx_equal_p (const void *, const void *);\n static hashval_t get_value_hash (const void *);\n@@ -117,11 +118,6 @@ static GTY((deletable (\"\"))) varray_type used_regs_old;\n    memory for a non-const call instruction.  */\n static GTY(()) rtx callmem;\n \n-/* Caches for unused structures.  */\n-static GTY((deletable (\"\"))) cselib_val *empty_vals;\n-static GTY((deletable (\"\"))) struct elt_list *empty_elt_lists;\n-static GTY((deletable (\"\"))) struct elt_loc_list *empty_elt_loc_lists;\n-\n /* Set by discard_useless_locs if it deleted the last location of any\n    value.  */\n static int values_became_useless;\n@@ -134,20 +130,17 @@ static cselib_val dummy_val;\n    May or may not contain the useless values - the list is compacted\n    each time memory is invalidated.  */\n static cselib_val *first_containing_mem = &dummy_val;\n+static alloc_pool elt_loc_list_pool, elt_list_pool, cselib_val_pool;\n \f\n \n /* Allocate a struct elt_list and fill in its two elements with the\n    arguments.  */\n \n-static struct elt_list *\n+static inline struct elt_list *\n new_elt_list (struct elt_list *next, cselib_val *elt)\n {\n-  struct elt_list *el = empty_elt_lists;\n-\n-  if (el)\n-    empty_elt_lists = el->next;\n-  else\n-    el = ggc_alloc (sizeof (struct elt_list));\n+  struct elt_list *el;\n+  el = pool_alloc (elt_list_pool);\n   el->next = next;\n   el->elt = elt;\n   return el;\n@@ -156,15 +149,11 @@ new_elt_list (struct elt_list *next, cselib_val *elt)\n /* Allocate a struct elt_loc_list and fill in its two elements with the\n    arguments.  */\n \n-static struct elt_loc_list *\n+static inline struct elt_loc_list *\n new_elt_loc_list (struct elt_loc_list *next, rtx loc)\n {\n-  struct elt_loc_list *el = empty_elt_loc_lists;\n-\n-  if (el)\n-    empty_elt_loc_lists = el->next;\n-  else\n-    el = ggc_alloc (sizeof (struct elt_loc_list));\n+  struct elt_loc_list *el;\n+  el = pool_alloc (elt_loc_list_pool);\n   el->next = next;\n   el->loc = loc;\n   el->canon_loc = NULL;\n@@ -176,14 +165,13 @@ new_elt_loc_list (struct elt_loc_list *next, rtx loc)\n /* The elt_list at *PL is no longer needed.  Unchain it and free its\n    storage.  */\n \n-static void\n+static inline void\n unchain_one_elt_list (struct elt_list **pl)\n {\n   struct elt_list *l = *pl;\n \n   *pl = l->next;\n-  l->next = empty_elt_lists;\n-  empty_elt_lists = l;\n+  pool_free (elt_list_pool, l);\n }\n \n /* Likewise for elt_loc_lists.  */\n@@ -194,8 +182,7 @@ unchain_one_elt_loc_list (struct elt_loc_list **pl)\n   struct elt_loc_list *l = *pl;\n \n   *pl = l->next;\n-  l->next = empty_elt_loc_lists;\n-  empty_elt_loc_lists = l;\n+  pool_free (elt_loc_list_pool, l);\n }\n \n /* Likewise for cselib_vals.  This also frees the addr_list associated with\n@@ -207,8 +194,7 @@ unchain_one_value (cselib_val *v)\n   while (v->addr_list)\n     unchain_one_elt_list (&v->addr_list);\n \n-  v->u.next_free = empty_vals;\n-  empty_vals = v;\n+  pool_free (cselib_val_pool, v);\n }\n \n /* Remove all entries from the hash table.  Also used during\n@@ -697,18 +683,15 @@ hash_rtx (rtx x, enum machine_mode mode, int create)\n /* Create a new value structure for VALUE and initialize it.  The mode of the\n    value is MODE.  */\n \n-static cselib_val *\n+static inline cselib_val *\n new_cselib_val (unsigned int value, enum machine_mode mode)\n {\n-  cselib_val *e = empty_vals;\n-\n-  if (e)\n-    empty_vals = e->u.next_free;\n-  else\n-    e = ggc_alloc (sizeof (cselib_val));\n+  cselib_val *e = pool_alloc (cselib_val_pool);\n \n+#ifdef ENABLE_CHECKING\n   if (value == 0)\n     abort ();\n+#endif\n \n   e->value = value;\n   e->u.val_rtx = gen_rtx_VALUE (mode);\n@@ -1403,6 +1386,12 @@ cselib_update_varray_sizes (void)\n void\n cselib_init (void)\n {\n+  elt_list_pool = create_alloc_pool (\"elt_list\", \n+\t\t\t\t     sizeof (struct elt_list), 10);\n+  elt_loc_list_pool = create_alloc_pool (\"elt_loc_list\", \n+\t\t\t\t         sizeof (struct elt_loc_list), 10);\n+  cselib_val_pool = create_alloc_pool (\"cselib_val_list\", \n+\t\t\t\t       sizeof (cselib_val), 10);\n   /* This is only created once.  */\n   if (! callmem)\n     callmem = gen_rtx_MEM (BLKmode, const0_rtx);\n@@ -1428,6 +1417,9 @@ cselib_init (void)\n void\n cselib_finish (void)\n {\n+  free_alloc_pool (elt_list_pool);\n+  free_alloc_pool (elt_loc_list_pool);\n+  free_alloc_pool (cselib_val_pool);\n   clear_table ();\n   reg_values_old = reg_values;\n   reg_values = 0;"}]}