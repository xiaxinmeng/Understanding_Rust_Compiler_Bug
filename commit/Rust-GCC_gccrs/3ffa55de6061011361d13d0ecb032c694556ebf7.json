{"sha": "3ffa55de6061011361d13d0ecb032c694556ebf7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZmYTU1ZGU2MDYxMDExMzYxZDEzZDBlY2IwMzJjNjk0NTU2ZWJmNw==", "commit": {"author": {"name": "Jeremy Sawicki", "email": "jeremy-gcc@sawicki.us", "date": "2018-08-14T11:23:50Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-08-14T11:23:50Z"}, "message": "Rope iterators: don't retain pointers when copied\n\nRope iterators sometimes contain pointers to an internal buffer\ninside the iterator itself.  When such an iterator is copied, the\ncopy incorrectly retains pointers to the original.\n\nThis patch takes the simple approach of not copying the cached\ninformation when the internal buffer is being used, instead\nrequiring it to be recomputed when the copied iterator is\ndereferenced.  An alternative would be to adjust the pointers so\nthey refer to the buffer in the copy.\n\n2018-08-14  Jeremy Sawicki  <jeremy-gcc@sawicki.us>\n\n\t* include/ext/rope (_Rope_iterator_base(const _Rope_iterator_base&))\n\t(_Rope_const_iterator::operator=(const _Rope_const_iterator&))\n\t(_Rope_iterator::operator=(const _Rope_iterator&)): Ensure\n\tcopied/assigned rope iterators don't retain pointers to the iterator\n\tthey were copied/assigned from.\n\t* testsuite/ext/rope/7.cc: New.\n\nFrom-SVN: r263534", "tree": {"sha": "0f678d4fe0e0a22224cb8f95e68293d013ac9d73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f678d4fe0e0a22224cb8f95e68293d013ac9d73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ffa55de6061011361d13d0ecb032c694556ebf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ffa55de6061011361d13d0ecb032c694556ebf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ffa55de6061011361d13d0ecb032c694556ebf7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ffa55de6061011361d13d0ecb032c694556ebf7/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d3083dde2a4fb03fab20d66fda1a5881801c757", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d3083dde2a4fb03fab20d66fda1a5881801c757", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d3083dde2a4fb03fab20d66fda1a5881801c757"}], "stats": {"total": 110, "additions": 107, "deletions": 3}, "files": [{"sha": "65890ea4b6b4e8f3811b0ea4086ce7d8a245e251", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ffa55de6061011361d13d0ecb032c694556ebf7/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ffa55de6061011361d13d0ecb032c694556ebf7/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=3ffa55de6061011361d13d0ecb032c694556ebf7", "patch": "@@ -1,3 +1,12 @@\n+2018-08-14  Jeremy Sawicki  <jeremy-gcc@sawicki.us>\n+\n+\t* include/ext/rope (_Rope_iterator_base(const _Rope_iterator_base&))\n+\t(_Rope_const_iterator::operator=(const _Rope_const_iterator&))\n+\t(_Rope_iterator::operator=(const _Rope_iterator&)): Ensure\n+\tcopied/assigned rope iterators don't retain pointers to the iterator\n+\tthey were copied/assigned from.\n+\t* testsuite/ext/rope/7.cc: New.\n+\n 2018-08-13  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/45093"}, {"sha": "a172989a2f9f8bcfe08f7ac1f6662a8cc013dbcc", "filename": "libstdc++-v3/include/ext/rope", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ffa55de6061011361d13d0ecb032c694556ebf7/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ffa55de6061011361d13d0ecb032c694556ebf7/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope?ref=3ffa55de6061011361d13d0ecb032c694556ebf7", "patch": "@@ -1119,7 +1119,7 @@ protected:\n     \n       _Rope_iterator_base(const _Rope_iterator_base& __x)\n       {\n-        if (0 != __x._M_buf_ptr)\n+        if (0 != __x._M_buf_ptr && __x._M_buf_start != __x._M_tmp_buf)\n \t  *this = __x;\n \telse\n \t  {\n@@ -1166,7 +1166,7 @@ protected:\n       _Rope_const_iterator&\n       operator=(const _Rope_const_iterator& __x)\n       {\n-        if (0 != __x._M_buf_ptr)\n+        if (0 != __x._M_buf_ptr && __x._M_buf_start != __x._M_tmp_buf)\n \t  *(static_cast<_Rope_iterator_base<_CharT, _Alloc>*>(this)) = __x;\n \telse\n \t  {\n@@ -1345,7 +1345,7 @@ protected:\n         _RopeRep* __old = this->_M_root;\n \t\n         _RopeRep::_S_ref(__x._M_root);\n-        if (0 != __x._M_buf_ptr)\n+        if (0 != __x._M_buf_ptr && __x._M_buf_start != __x._M_tmp_buf)\n \t  {\n             _M_root_rope = __x._M_root_rope;\n             *(static_cast<_Rope_iterator_base<_CharT, _Alloc>*>(this)) = __x;"}, {"sha": "a9274943b6b5e37b76b230a978cc2763f6daa416", "filename": "libstdc++-v3/testsuite/ext/rope/7.cc", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ffa55de6061011361d13d0ecb032c694556ebf7/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Frope%2F7.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ffa55de6061011361d13d0ecb032c694556ebf7/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Frope%2F7.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Frope%2F7.cc?ref=3ffa55de6061011361d13d0ecb032c694556ebf7", "patch": "@@ -0,0 +1,95 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// rope (SGI extension)\n+\n+// { dg-do run }\n+\n+#include <ext/rope>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using __gnu_cxx::crope;\n+\n+  char str_a[] =\n+    \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+    \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+    \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+    \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+    \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n+  char str_b[] =\n+    \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\"\n+    \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\"\n+    \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\"\n+    \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\"\n+    \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\";\n+\n+  // Create ropes with leaf nodes longer than __lazy_threshold = 128\n+  // so substring nodes will be created by the next step\n+  crope leaf_rope_a(str_a);\n+  crope leaf_rope_b(str_b);\n+\n+  // Create ropes with substring nodes referencing the leaf nodes\n+  // of the prior ropes\n+  crope substring_rope_a(leaf_rope_a.begin() + 1,\n+                         leaf_rope_a.begin() + 199);\n+  crope substring_rope_b(leaf_rope_b.begin() + 1,\n+                         leaf_rope_b.begin() + 199);\n+\n+  // Create iterators to substring_rope_a\n+  crope::const_iterator cit_orig = substring_rope_a.begin();\n+  crope::iterator mit_orig = substring_rope_a.mutable_begin();\n+\n+  // Dereference the iterators so they cache a portion of the substring\n+  // node in their internal buffers\n+  *cit_orig;\n+  *mit_orig;\n+\n+  // Copy the original iterators, via both copy constructors and\n+  // assignment operators.  Prior to the bug fix, these iterators\n+  // retained pointers to the internal buffers of the original\n+  // iterators.\n+  crope::const_iterator cit_copy(cit_orig);\n+  crope::iterator mit_copy(mit_orig);\n+  crope::const_iterator cit_assign; cit_assign = cit_orig;\n+  crope::iterator mit_assign; mit_assign = mit_orig;\n+\n+  // Modify the original iterators to refer to substring_rope_b\n+  cit_orig = substring_rope_b.begin();\n+  mit_orig = substring_rope_b.mutable_begin();\n+\n+  // Dereference the original iterators so they fill their internal\n+  // buffers with part of substring_rope_b\n+  *cit_orig;\n+  *mit_orig;\n+\n+  // Verify that the copied iterators return data from\n+  // substring_rope_a, not substring_rope_b\n+  VERIFY(*cit_copy == 'a');\n+  VERIFY(*mit_copy == 'a');\n+  VERIFY(*cit_assign == 'a');\n+  VERIFY(*mit_assign == 'a');\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}]}