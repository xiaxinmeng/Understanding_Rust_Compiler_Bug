{"sha": "0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE4MWYwNzRjZjZjNTBjNWViMDI2ZGZjOTVlYzBkNDJlOTVmM2RhMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-05-05T17:41:49Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-05-05T17:41:49Z"}, "message": "rtl.h (plus_constant, [...]): Merge into a single plus_constant function.\n\ngcc/\n\t* rtl.h (plus_constant, plus_constant_mode): Merge into a single\n\tplus_constant function.\n\t* explow.c (plus_constant, plus_constant_mode): Likewise.  Assert\n\tthat the mode is sensible.\n\t(use_anchored_address, round_push, allocate_dynamic_stack_space)\n\t(probe_stack_range, anti_adjust_stack_and_probe): Update calls to\n\tplus_constant.\n\n\t* alias.c (canon_rtx): Likewise.\n\t(init_alias_analysis): Likewise.\n\t* builtins.c (expand_builtin_return_addr)\n\t(expand_builtin_setjmp_setup, expand_builtin_longjmp)\n\t(expand_builtin_nonlocal_goto, expand_builtin_update_setjmp_buf)\n\t(expand_builtin_apply_args_1, expand_builtin_apply, expand_movstr)\n\t(expand_builtin_stpcpy): Likewise.\n\t* calls.c (save_fixed_argument_area, restore_fixed_argument_area)\n\t(compute_argument_addresses, internal_arg_pointer_based_exp)\n\t(expand_call, emit_library_call_value_1): Likewise.\n\t* cfgexpand.c (expand_one_stack_var_at, expand_debug_expr): Likewise.\n\t* combine-stack-adj.c (try_apply_stack_adjustment): Likewise.\n\t* combine.c (combine_simplify_rtx, force_to_mode): Likewise.\n\t* cse.c (insert_const_anchor, find_reg_offset_for_const)\n\t(use_related_value, fold_rtx): Likewise.\n\t* cselib.c (cselib_subst_to_values): Likewise.\n\t* dse.c (record_store, check_mem_read_rtx): Likewise.\n\t* dwarf2out.c (rtl_for_decl_location, gen_variable_die): Likewise.\n\t* emit-rtl.c (adjust_address_1): Likewise.\n\t* except.c (sjlj_emit_function_enter)\n\t(expand_builtin_extract_return_addr)\n\t(expand_builtin_frob_return_addr): Likewise.\n\t* expmed.c (expand_divmod): Likewise.\n\t* expr.c (move_by_pieces, store_by_pieces, store_by_pieces_1)\n\t(emit_move_resolve_push, push_block, emit_push_insn, store_expr)\n\t(expand_expr_addr_expr_1, expand_expr_real_1): Likewise.\n\t* function.c (assign_stack_local_1)\n\t(instantiate_virtual_regs_in_rtx): Likewise.\n\t* optabs.c (prepare_cmp_insn): Likewise.\n\t* recog.c (offsettable_address_addr_space_p): Likewise.\n\t* reload.c (find_reloads_address, form_sum)\n\t(find_reloads_subreg_address): Likewise.\n\t* reload1.c (init_reload, eliminate_regs_1)\n\t(eliminate_regs_in_insn): Likewise.\n\t* simplify-rtx.c (simplify_unary_operation_1)\n\t(simplify_binary_operation_1, simplify_plus_minus): Likewise.\n\t* var-tracking.c (compute_cfa_pointer, prepare_call_arguments)\n\t(vt_add_function_parameter): Likewise.\n\n\t* config/alpha/alpha.h (EH_RETURN_HANDLER_RTX): Likewise.\n\t* config/alpha/vms.h (EH_RETURN_HANDLER_RTX): Likewise.\n\t* config/alpha/alpha.c (alpha_legitimize_address_1)\n\t(get_unaligned_address, alpha_expand_unaligned_load)\n\t(alpha_expand_unaligned_store, alpha_expand_unaligned_load_words)\n\t(alpha_expand_unaligned_store_words, alpha_expand_block_clear)\n\t(alpha_expand_builtin_establish_vms_condition_handler)\n\t(alpha_setup_incoming_varargs, emit_frame_store_1)\n\t(alpha_expand_prologue, alpha_expand_epilogue)\n\t(alpha_use_linkage): Likewise.\n\t* config/alpha/alpha.md: Likewise.\n\n\t* config/arm/arm.c (arm_trampoline_init, legitimize_pic_address)\n\t(arm_load_pic_register, arm_pic_static_addr, arm_legitimize_address)\n\t(thumb_legitimize_address, arm_gen_load_multiple_1)\n\t(arm_gen_store_multiple_1, arm_gen_multiple_op, gen_ldm_seq)\n\t(gen_stm_seq, gen_const_stm_seq, arm_block_move_unaligned_straight)\n\t(arm_block_move_unaligned_loop, arm_gen_movmemqi, arm_reload_in_hi)\n\t(arm_reload_out_hi, arm_reorg, vfp_emit_fstmd, emit_multi_reg_push)\n\t(emit_sfm, thumb_set_frame_pointer, arm_expand_prologue)\n\t(thumb1_emit_multi_reg_push, thumb1_expand_prologue)\n\t(thumb_expand_movmemqi, arm_set_return_address)\n\t(thumb_set_return_address): Likewise.\n\t* config/arm/arm.md: Likewise.\n\n\t* config/avr/avr.c (avr_incoming_return_addr_rtx)\n\t(avr_prologue_setup_frame, expand_epilogue)\n\t(avr_const_address_lo16): Likewise.\n\n\t* config/bfin/bfin.h (EH_RETURN_HANDLER_RTX): Likewise.\n\t* config/bfin/bfin.c (setup_incoming_varargs, bfin_load_pic_reg)\n\t(bfin_expand_prologue, bfin_trampoline_init, bfin_expand_call)\n\t(bfin_output_mi_thunk): Likewise.\n\n\t* config/c6x/c6x.c (c6x_initialize_trampoline)\n\t(c6x_output_mi_thunk): Likewise.\n\n\t* config/cr16/cr16.h (EH_RETURN_HANDLER_RTX): Likewise.\n\t* config/cr16/cr16.c (cr16_create_dwarf_for_multi_push): Likewise.\n\n\t* config/cris/cris.c (cris_return_addr_rtx, cris_split_movdx)\n\t(cris_expand_prologue, cris_expand_epilogue, cris_gen_movem_load)\n\t(cris_emit_movem_store, cris_trampoline_init): Likewise.\n\t* config/cris/cris.md: Likewise.\n\n\t* config/darwin.c (machopic_indirect_data_reference)\n\t(machopic_legitimize_pic_address): Likewise.\n\n\t* config/epiphany/epiphany.c (epiphany_emit_save_restore)\n\t(epiphany_expand_prologue, epiphany_expand_epilogue)\n\t(epiphany_trampoline_init): Likewise.\n\t* config/epiphany/epiphany.md: Likewise.\n\n\t* config/fr30/fr30.c (fr30_move_double): Likewise.\n\n\t* config/frv/frv.c (frv_dwarf_store, frv_expand_prologue)\n\t(frv_expand_block_move, frv_expand_block_clear, frv_return_addr_rtx)\n\t(frv_index_memory, unspec_got_name, frv_find_base_term)\n\t(frv_output_dwarf_dtprel): Likewise.\n\n\t* config/h8300/h8300.c (h8300_push_pop, h8300_return_addr_rtx)\n\t(h8300_swap_into_er6, h8300_swap_out_of_er6): Likewise.\n\n\t* config/i386/i386.h (RETURN_ADDR_RTX): Likewise.\n\t* config/i386/i386.c (setup_incoming_varargs_64)\n\t(setup_incoming_varargs_ms_64, choose_baseaddr)\n\t(ix86_emit_save_reg_using_mov, ix86_adjust_stack_and_probe)\n\t(ix86_emit_probe_stack_range, ix86_expand_prologue)\n\t(ix86_emit_restore_reg_using_pop, ix86_emit_leave)\n\t(ix86_expand_epilogue, legitimize_pic_address, ix86_legitimize_address)\n\t(ix86_split_long_move, ix86_expand_movmem, ix86_expand_setmem)\n\t(ix86_static_chain, ix86_trampoline_init, x86_this_parameter)\n\t(x86_output_mi_thunk): Likewise.\n\t* config/i386/i386.md: Likewise.\n\n\t* config/ia64/ia64.c (ia64_expand_load_address)\n\t(ia64_expand_tls_address, ia64_expand_move, ia64_split_tmode)\n\t(do_spill, ia64_trampoline_init): Likewise.\n\n\t* config/iq2000/iq2000.c (iq2000_va_start)\n\t(iq2000_emit_frame_related_store, iq2000_expand_prologue)\n\t(iq2000_expand_eh_return, iq2000_setup_incoming_varargs)\n\t(iq2000_print_operand, iq2000_legitimize_address): Likewise.\n\n\t* config/lm32/lm32.c (lm32_setup_incoming_varargs): Likewise.\n\n\t* config/m32c/m32c.c (m32c_return_addr_rtx)\n\t(m32c_expand_insv): Likewise.\n\n\t* config/m32r/m32r.c (m32r_setup_incoming_varargs)\n\t(m32r_legitimize_pic_address, m32r_print_operand)\n\t(m32r_print_operand_address): Likewise.\n\n\t* config/m68k/linux.h (FINALIZE_TRAMPOLINE): Likewise.\n\t* config/m68k/m68k.h (RETURN_ADDR_RTX): Likewise.\n\t(EH_RETURN_HANDLER_RTX): Likewise.\n\t* config/m68k/m68k.c (m68k_emit_movem, m68k_expand_prologue)\n\t(m68k_expand_epilogue, legitimize_pic_address)\n\t(m68k_output_mi_thunk): Likewise.\n\t* config/m68k/m68k.md: Likewise.\n\n\t* config/mcore/mcore.c (mcore_expand_prolog): Likewise.\n\t(mcore_expand_epilog): Likewise.\n\t* config/mcore/mcore.md: Likewise.\n\n\t* config/mep/mep.c (mep_allocate_initial_value)\n\t(mep_expand_prologue, mep_expand_epilogue): Likewise.\n\n\t* config/microblaze/microblaze.c (double_memory_operand)\n\t(microblaze_block_move_loop): Likewise.\n\n\t* config/mips/mips.c (mips_strip_unspec_address, mips_add_offset)\n\t(mips_setup_incoming_varargs, mips_va_start, mips_block_move_loop)\n\t(mips_print_operand, mips16e_save_restore_reg, mips_save_restore_reg)\n\t(mips_expand_prologue, mips_epilogue_set_cfa)\n\t(mips_expand_epilogue): Likewise.\n\t* config/mips/mips.md: Likewise.\n\n\t* config/mmix/mmix.c (mmix_dynamic_chain_address, mmix_return_addr_rtx)\n\t(mmix_expand_prologue, mmix_expand_epilogue): Likewise.\n\n\t* config/mn10300/mn10300.c (mn10300_gen_multiple_store)\n\t(mn10300_builtin_saveregs, mn10300_trampoline_init): Likewise.\n\n\t* config/moxie/moxie.h (INCOMING_RETURN_ADDR_RTX): Likewise.\n\t(EH_RETURN_HANDLER_RTX): Likewise.\n\t* config/moxie/moxie.c (moxie_static_chain): Likewise.\n\n\t* config/pa/pa.c (legitimize_pic_address, hppa_legitimize_address)\n\t(store_reg, set_reg_plus_d, pa_expand_prologue, load_reg)\n\t(pa_return_addr_rtx, hppa_builtin_saveregs)\n\t(pa_trampoline_init): Likewise.\n\t* config/pa/pa.md: Likewise.\n\n\t* config/pdp11/pdp11.c (pdp11_expand_epilogue): Likewise.\n\n\t* config/picochip/picochip.c (picochip_static_chain): Likewise.\n\n\t* config/rs6000/rs6000.h (RS6000_SAVE_TOC): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_legitimize_address)\n\t(setup_incoming_varargs, print_operand, rs6000_return_addr)\n\t(rs6000_emit_eh_reg_restore, rs6000_emit_probe_stack_range)\n\t(rs6000_emit_epilogue)\n\t(rs6000_machopic_legitimize_pic_address): Likewise.\n\n\t* config/rx/rx.c (gen_rx_rtsd_vector, gen_rx_popm_vector): Likewise.\n\n\t* config/s390/s390.h (INITIAL_FRAME_ADDRESS_RTX): Likewise.\n\t(DYNAMIC_CHAIN_ADDRESS): Likewise.\n\t* config/s390/s390.c (s390_decompose_address, legitimize_pic_address)\n\t(s390_delegitimize_address, print_operand, annotate_constant_pool_refs)\n\t(replace_constant_pool_ref, s390_return_addr_rtx, s390_back_chain_rtx)\n\t(save_fpr, restore_fpr, save_gprs, restore_gprs, s390_emit_prologue)\n\t(s390_emit_epilogue, s390_function_profiler): Likewise.\n\t* config/s390/s390.md: Likewise.\n\n\t* config/score/score.c (score_add_offset, score_prologue): Likewise.\n\n\t* config/sh/sh.c (expand_block_move, push_regs, sh_builtin_saveregs)\n\t(sh_output_mi_thunk): Likewise.\n\t* config/sh/sh.md: Likewise.\n\n\t* config/sparc/sparc.h (DYNAMIC_CHAIN_ADDRESS, FRAME_ADDR_RTX)\n\t(RETURN_ADDR_RTX, INCOMING_RETURN_ADDR_RTX): Likewise.\n\t* config/sparc/sparc.c (sparc_legitimize_pic_address)\n\t(sparc_emit_probe_stack_range, emit_save_or_restore_regs)\n\t(emit_window_save, sparc_flat_expand_prologue, sparc_struct_value_rtx)\n\t(emit_and_preserve): Likewise.\n\t* config/sparc/sparc.md: Likewise.\n\n\t* config/spu/spu.h (DYNAMIC_CHAIN_ADDRESS): Likewise.\n\t* config/spu/spu.c (spu_expand_insv, spu_machine_dependent_reorg)\n\t(spu_setup_incoming_varargs, ea_load_store_inline)\n\t(spu_expand_load): Likewise.\n\n\t* config/stormy16/stormy16.c (xstormy16_expand_prologue)\n\t(combine_bnp): Likewise.\n\n\t* config/tilegx/tilegx.h (DYNAMIC_CHAIN_ADDRESS): Likewise.\n\t* config/tilegx/tilegx.c (tilegx_setup_incoming_varargs)\n\t(tilegx_expand_unaligned_load, tilegx_trampoline_init): Likewise.\n\n\t* config/tilepro/tilepro.h (DYNAMIC_CHAIN_ADDRESS): Likewise.\n\t* config/tilepro/tilepro.c (tilepro_setup_incoming_varargs)\n\t(tilepro_expand_unaligned_load, tilepro_trampoline_init): Likewise.\n\n\t* config/v850/v850.c (expand_prologue, expand_epilogue): Likewise.\n\t* config/v850/v850.md: Likewise.\n\n\t* config/vax/elf.h (EH_RETURN_STACKADJ_RTX): Likewise.\n\t(EH_RETURN_HANDLER_RTX): Likewise.\n\t* config/vax/vax.h (DYNAMIC_CHAIN_ADDRESS, RETURN_ADDR_RTX): Likewise.\n\t* config/vax/vax.c (vax_add_reg_cfa_offset, vax_expand_prologue)\n\t(print_operand_address, vax_trampoline_init): Likewise.\n\n\t* config/xtensa/xtensa.c (xtensa_expand_prologue, xtensa_return_addr)\n\t(xtensa_function_value_regno_p): Likewise.\n\nFrom-SVN: r187199", "tree": {"sha": "a9e29626a294417f7835ab23c14674d3ce69ce5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9e29626a294417f7835ab23c14674d3ce69ce5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8b5e75a5c666b19d286688578985bd24189146d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b5e75a5c666b19d286688578985bd24189146d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b5e75a5c666b19d286688578985bd24189146d6"}], "stats": {"total": 1772, "additions": 1109, "deletions": 663}, "files": [{"sha": "364d2d7871e59da1a756c8a5839f2ede5b57e5d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1,3 +1,250 @@\n+2012-05-05  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* rtl.h (plus_constant, plus_constant_mode): Merge into a single\n+\tplus_constant function.\n+\t* explow.c (plus_constant, plus_constant_mode): Likewise.  Assert\n+\tthat the mode is sensible.\n+\t(use_anchored_address, round_push, allocate_dynamic_stack_space)\n+\t(probe_stack_range, anti_adjust_stack_and_probe): Update calls to\n+\tplus_constant.\n+\n+\t* alias.c (canon_rtx): Likewise.\n+\t(init_alias_analysis): Likewise.\n+\t* builtins.c (expand_builtin_return_addr)\n+\t(expand_builtin_setjmp_setup, expand_builtin_longjmp)\n+\t(expand_builtin_nonlocal_goto, expand_builtin_update_setjmp_buf)\n+\t(expand_builtin_apply_args_1, expand_builtin_apply, expand_movstr)\n+\t(expand_builtin_stpcpy): Likewise.\n+\t* calls.c (save_fixed_argument_area, restore_fixed_argument_area)\n+\t(compute_argument_addresses, internal_arg_pointer_based_exp)\n+\t(expand_call, emit_library_call_value_1): Likewise.\n+\t* cfgexpand.c (expand_one_stack_var_at, expand_debug_expr): Likewise.\n+\t* combine-stack-adj.c (try_apply_stack_adjustment): Likewise.\n+\t* combine.c (combine_simplify_rtx, force_to_mode): Likewise.\n+\t* cse.c (insert_const_anchor, find_reg_offset_for_const)\n+\t(use_related_value, fold_rtx): Likewise.\n+\t* cselib.c (cselib_subst_to_values): Likewise.\n+\t* dse.c (record_store, check_mem_read_rtx): Likewise.\n+\t* dwarf2out.c (rtl_for_decl_location, gen_variable_die): Likewise.\n+\t* emit-rtl.c (adjust_address_1): Likewise.\n+\t* except.c (sjlj_emit_function_enter)\n+\t(expand_builtin_extract_return_addr)\n+\t(expand_builtin_frob_return_addr): Likewise.\n+\t* expmed.c (expand_divmod): Likewise.\n+\t* expr.c (move_by_pieces, store_by_pieces, store_by_pieces_1)\n+\t(emit_move_resolve_push, push_block, emit_push_insn, store_expr)\n+\t(expand_expr_addr_expr_1, expand_expr_real_1): Likewise.\n+\t* function.c (assign_stack_local_1)\n+\t(instantiate_virtual_regs_in_rtx): Likewise.\n+\t* optabs.c (prepare_cmp_insn): Likewise.\n+\t* recog.c (offsettable_address_addr_space_p): Likewise.\n+\t* reload.c (find_reloads_address, form_sum)\n+\t(find_reloads_subreg_address): Likewise.\n+\t* reload1.c (init_reload, eliminate_regs_1)\n+\t(eliminate_regs_in_insn): Likewise.\n+\t* simplify-rtx.c (simplify_unary_operation_1)\n+\t(simplify_binary_operation_1, simplify_plus_minus): Likewise.\n+\t* var-tracking.c (compute_cfa_pointer, prepare_call_arguments)\n+\t(vt_add_function_parameter): Likewise.\n+\n+\t* config/alpha/alpha.h (EH_RETURN_HANDLER_RTX): Likewise.\n+\t* config/alpha/vms.h (EH_RETURN_HANDLER_RTX): Likewise.\n+\t* config/alpha/alpha.c (alpha_legitimize_address_1)\n+\t(get_unaligned_address, alpha_expand_unaligned_load)\n+\t(alpha_expand_unaligned_store, alpha_expand_unaligned_load_words)\n+\t(alpha_expand_unaligned_store_words, alpha_expand_block_clear)\n+\t(alpha_expand_builtin_establish_vms_condition_handler)\n+\t(alpha_setup_incoming_varargs, emit_frame_store_1)\n+\t(alpha_expand_prologue, alpha_expand_epilogue)\n+\t(alpha_use_linkage): Likewise.\n+\t* config/alpha/alpha.md: Likewise.\n+\n+\t* config/arm/arm.c (arm_trampoline_init, legitimize_pic_address)\n+\t(arm_load_pic_register, arm_pic_static_addr, arm_legitimize_address)\n+\t(thumb_legitimize_address, arm_gen_load_multiple_1)\n+\t(arm_gen_store_multiple_1, arm_gen_multiple_op, gen_ldm_seq)\n+\t(gen_stm_seq, gen_const_stm_seq, arm_block_move_unaligned_straight)\n+\t(arm_block_move_unaligned_loop, arm_gen_movmemqi, arm_reload_in_hi)\n+\t(arm_reload_out_hi, arm_reorg, vfp_emit_fstmd, emit_multi_reg_push)\n+\t(emit_sfm, thumb_set_frame_pointer, arm_expand_prologue)\n+\t(thumb1_emit_multi_reg_push, thumb1_expand_prologue)\n+\t(thumb_expand_movmemqi, arm_set_return_address)\n+\t(thumb_set_return_address): Likewise.\n+\t* config/arm/arm.md: Likewise.\n+\n+\t* config/avr/avr.c (avr_incoming_return_addr_rtx)\n+\t(avr_prologue_setup_frame, expand_epilogue)\n+\t(avr_const_address_lo16): Likewise.\n+\n+\t* config/bfin/bfin.h (EH_RETURN_HANDLER_RTX): Likewise.\n+\t* config/bfin/bfin.c (setup_incoming_varargs, bfin_load_pic_reg)\n+\t(bfin_expand_prologue, bfin_trampoline_init, bfin_expand_call)\n+\t(bfin_output_mi_thunk): Likewise.\n+\n+\t* config/c6x/c6x.c (c6x_initialize_trampoline)\n+\t(c6x_output_mi_thunk): Likewise.\n+\n+\t* config/cr16/cr16.h (EH_RETURN_HANDLER_RTX): Likewise.\n+\t* config/cr16/cr16.c (cr16_create_dwarf_for_multi_push): Likewise.\n+\n+\t* config/cris/cris.c (cris_return_addr_rtx, cris_split_movdx)\n+\t(cris_expand_prologue, cris_expand_epilogue, cris_gen_movem_load)\n+\t(cris_emit_movem_store, cris_trampoline_init): Likewise.\n+\t* config/cris/cris.md: Likewise.\n+\n+\t* config/darwin.c (machopic_indirect_data_reference)\n+\t(machopic_legitimize_pic_address): Likewise.\n+\n+\t* config/epiphany/epiphany.c (epiphany_emit_save_restore)\n+\t(epiphany_expand_prologue, epiphany_expand_epilogue)\n+\t(epiphany_trampoline_init): Likewise.\n+\t* config/epiphany/epiphany.md: Likewise.\n+\n+\t* config/fr30/fr30.c (fr30_move_double): Likewise.\n+\n+\t* config/frv/frv.c (frv_dwarf_store, frv_expand_prologue)\n+\t(frv_expand_block_move, frv_expand_block_clear, frv_return_addr_rtx)\n+\t(frv_index_memory, unspec_got_name, frv_find_base_term)\n+\t(frv_output_dwarf_dtprel): Likewise.\n+\n+\t* config/h8300/h8300.c (h8300_push_pop, h8300_return_addr_rtx)\n+\t(h8300_swap_into_er6, h8300_swap_out_of_er6): Likewise.\n+\n+\t* config/i386/i386.h (RETURN_ADDR_RTX): Likewise.\n+\t* config/i386/i386.c (setup_incoming_varargs_64)\n+\t(setup_incoming_varargs_ms_64, choose_baseaddr)\n+\t(ix86_emit_save_reg_using_mov, ix86_adjust_stack_and_probe)\n+\t(ix86_emit_probe_stack_range, ix86_expand_prologue)\n+\t(ix86_emit_restore_reg_using_pop, ix86_emit_leave)\n+\t(ix86_expand_epilogue, legitimize_pic_address, ix86_legitimize_address)\n+\t(ix86_split_long_move, ix86_expand_movmem, ix86_expand_setmem)\n+\t(ix86_static_chain, ix86_trampoline_init, x86_this_parameter)\n+\t(x86_output_mi_thunk): Likewise.\n+\t* config/i386/i386.md: Likewise.\n+\n+\t* config/ia64/ia64.c (ia64_expand_load_address)\n+\t(ia64_expand_tls_address, ia64_expand_move, ia64_split_tmode)\n+\t(do_spill, ia64_trampoline_init): Likewise.\n+\n+\t* config/iq2000/iq2000.c (iq2000_va_start)\n+\t(iq2000_emit_frame_related_store, iq2000_expand_prologue)\n+\t(iq2000_expand_eh_return, iq2000_setup_incoming_varargs)\n+\t(iq2000_print_operand, iq2000_legitimize_address): Likewise.\n+\n+\t* config/lm32/lm32.c (lm32_setup_incoming_varargs): Likewise.\n+\n+\t* config/m32c/m32c.c (m32c_return_addr_rtx)\n+\t(m32c_expand_insv): Likewise.\n+\n+\t* config/m32r/m32r.c (m32r_setup_incoming_varargs)\n+\t(m32r_legitimize_pic_address, m32r_print_operand)\n+\t(m32r_print_operand_address): Likewise.\n+\n+\t* config/m68k/linux.h (FINALIZE_TRAMPOLINE): Likewise.\n+\t* config/m68k/m68k.h (RETURN_ADDR_RTX): Likewise.\n+\t(EH_RETURN_HANDLER_RTX): Likewise.\n+\t* config/m68k/m68k.c (m68k_emit_movem, m68k_expand_prologue)\n+\t(m68k_expand_epilogue, legitimize_pic_address)\n+\t(m68k_output_mi_thunk): Likewise.\n+\t* config/m68k/m68k.md: Likewise.\n+\n+\t* config/mcore/mcore.c (mcore_expand_prolog): Likewise.\n+\t(mcore_expand_epilog): Likewise.\n+\t* config/mcore/mcore.md: Likewise.\n+\n+\t* config/mep/mep.c (mep_allocate_initial_value)\n+\t(mep_expand_prologue, mep_expand_epilogue): Likewise.\n+\n+\t* config/microblaze/microblaze.c (double_memory_operand)\n+\t(microblaze_block_move_loop): Likewise.\n+\n+\t* config/mips/mips.c (mips_strip_unspec_address, mips_add_offset)\n+\t(mips_setup_incoming_varargs, mips_va_start, mips_block_move_loop)\n+\t(mips_print_operand, mips16e_save_restore_reg, mips_save_restore_reg)\n+\t(mips_expand_prologue, mips_epilogue_set_cfa)\n+\t(mips_expand_epilogue): Likewise.\n+\t* config/mips/mips.md: Likewise.\n+\n+\t* config/mmix/mmix.c (mmix_dynamic_chain_address, mmix_return_addr_rtx)\n+\t(mmix_expand_prologue, mmix_expand_epilogue): Likewise.\n+\n+\t* config/mn10300/mn10300.c (mn10300_gen_multiple_store)\n+\t(mn10300_builtin_saveregs, mn10300_trampoline_init): Likewise.\n+\n+\t* config/moxie/moxie.h (INCOMING_RETURN_ADDR_RTX): Likewise.\n+\t(EH_RETURN_HANDLER_RTX): Likewise.\n+\t* config/moxie/moxie.c (moxie_static_chain): Likewise.\n+\n+\t* config/pa/pa.c (legitimize_pic_address, hppa_legitimize_address)\n+\t(store_reg, set_reg_plus_d, pa_expand_prologue, load_reg)\n+\t(pa_return_addr_rtx, hppa_builtin_saveregs)\n+\t(pa_trampoline_init): Likewise.\n+\t* config/pa/pa.md: Likewise.\n+\n+\t* config/pdp11/pdp11.c (pdp11_expand_epilogue): Likewise.\n+\n+\t* config/picochip/picochip.c (picochip_static_chain): Likewise.\n+\n+\t* config/rs6000/rs6000.h (RS6000_SAVE_TOC): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_legitimize_address)\n+\t(setup_incoming_varargs, print_operand, rs6000_return_addr)\n+\t(rs6000_emit_eh_reg_restore, rs6000_emit_probe_stack_range)\n+\t(rs6000_emit_epilogue)\n+\t(rs6000_machopic_legitimize_pic_address): Likewise.\n+\n+\t* config/rx/rx.c (gen_rx_rtsd_vector, gen_rx_popm_vector): Likewise.\n+\n+\t* config/s390/s390.h (INITIAL_FRAME_ADDRESS_RTX): Likewise.\n+\t(DYNAMIC_CHAIN_ADDRESS): Likewise.\n+\t* config/s390/s390.c (s390_decompose_address, legitimize_pic_address)\n+\t(s390_delegitimize_address, print_operand, annotate_constant_pool_refs)\n+\t(replace_constant_pool_ref, s390_return_addr_rtx, s390_back_chain_rtx)\n+\t(save_fpr, restore_fpr, save_gprs, restore_gprs, s390_emit_prologue)\n+\t(s390_emit_epilogue, s390_function_profiler): Likewise.\n+\t* config/s390/s390.md: Likewise.\n+\n+\t* config/score/score.c (score_add_offset, score_prologue): Likewise.\n+\n+\t* config/sh/sh.c (expand_block_move, push_regs, sh_builtin_saveregs)\n+\t(sh_output_mi_thunk): Likewise.\n+\t* config/sh/sh.md: Likewise.\n+\n+\t* config/sparc/sparc.h (DYNAMIC_CHAIN_ADDRESS, FRAME_ADDR_RTX)\n+\t(RETURN_ADDR_RTX, INCOMING_RETURN_ADDR_RTX): Likewise.\n+\t* config/sparc/sparc.c (sparc_legitimize_pic_address)\n+\t(sparc_emit_probe_stack_range, emit_save_or_restore_regs)\n+\t(emit_window_save, sparc_flat_expand_prologue, sparc_struct_value_rtx)\n+\t(emit_and_preserve): Likewise.\n+\t* config/sparc/sparc.md: Likewise.\n+\n+\t* config/spu/spu.h (DYNAMIC_CHAIN_ADDRESS): Likewise.\n+\t* config/spu/spu.c (spu_expand_insv, spu_machine_dependent_reorg)\n+\t(spu_setup_incoming_varargs, ea_load_store_inline)\n+\t(spu_expand_load): Likewise.\n+\n+\t* config/stormy16/stormy16.c (xstormy16_expand_prologue)\n+\t(combine_bnp): Likewise.\n+\n+\t* config/tilegx/tilegx.h (DYNAMIC_CHAIN_ADDRESS): Likewise.\n+\t* config/tilegx/tilegx.c (tilegx_setup_incoming_varargs)\n+\t(tilegx_expand_unaligned_load, tilegx_trampoline_init): Likewise.\n+\n+\t* config/tilepro/tilepro.h (DYNAMIC_CHAIN_ADDRESS): Likewise.\n+\t* config/tilepro/tilepro.c (tilepro_setup_incoming_varargs)\n+\t(tilepro_expand_unaligned_load, tilepro_trampoline_init): Likewise.\n+\n+\t* config/v850/v850.c (expand_prologue, expand_epilogue): Likewise.\n+\t* config/v850/v850.md: Likewise.\n+\n+\t* config/vax/elf.h (EH_RETURN_STACKADJ_RTX): Likewise.\n+\t(EH_RETURN_HANDLER_RTX): Likewise.\n+\t* config/vax/vax.h (DYNAMIC_CHAIN_ADDRESS, RETURN_ADDR_RTX): Likewise.\n+\t* config/vax/vax.c (vax_add_reg_cfa_offset, vax_expand_prologue)\n+\t(print_operand_address, vax_trampoline_init): Likewise.\n+\n+\t* config/xtensa/xtensa.c (xtensa_expand_prologue, xtensa_return_addr)\n+\t(xtensa_function_value_regno_p): Likewise.\n+\n 2012-05-04  Andrew Pinski  <apinski@cavium.com>\n \n \t* expr.c (get_def_for_expr_class): New function."}, {"sha": "00af340c3722a50367fbeb6e385c38bc7e5bf36b", "filename": "gcc/alias.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1433,9 +1433,9 @@ canon_rtx (rtx x)\n       if (x0 != XEXP (x, 0) || x1 != XEXP (x, 1))\n \t{\n \t  if (CONST_INT_P (x0))\n-\t    return plus_constant (x1, INTVAL (x0));\n+\t    return plus_constant (GET_MODE (x), x1, INTVAL (x0));\n \t  else if (CONST_INT_P (x1))\n-\t    return plus_constant (x0, INTVAL (x1));\n+\t    return plus_constant (GET_MODE (x), x0, INTVAL (x1));\n \t  return gen_rtx_PLUS (GET_MODE (x), x0, x1);\n \t}\n     }\n@@ -2928,7 +2928,8 @@ init_alias_analysis (void)\n \t\t\t   && (t = get_reg_known_value (REGNO (XEXP (src, 0))))\n \t\t\t   && CONST_INT_P (XEXP (src, 1)))\n \t\t    {\n-\t\t      t = plus_constant (t, INTVAL (XEXP (src, 1)));\n+\t\t      t = plus_constant (GET_MODE (src), t,\n+\t\t\t\t\t INTVAL (XEXP (src, 1)));\n \t\t      set_reg_known_value (regno, t);\n \t\t      set_reg_known_equiv_p (regno, 0);\n \t\t    }"}, {"sha": "8b20e439cc0457e2d1eaaec0b8a9e95b91e3c964", "filename": "gcc/builtins.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -844,7 +844,7 @@ expand_builtin_return_addr (enum built_in_function fndecl_code, int count)\n   tem = RETURN_ADDR_RTX (count, tem);\n #else\n   tem = memory_address (Pmode,\n-\t\t\tplus_constant (tem, GET_MODE_SIZE (Pmode)));\n+\t\t\tplus_constant (Pmode, tem, GET_MODE_SIZE (Pmode)));\n   tem = gen_frame_mem (Pmode, tem);\n #endif\n   return tem;\n@@ -879,14 +879,15 @@ expand_builtin_setjmp_setup (rtx buf_addr, rtx receiver_label)\n   set_mem_alias_set (mem, setjmp_alias_set);\n   emit_move_insn (mem, targetm.builtin_setjmp_frame_value ());\n \n-  mem = gen_rtx_MEM (Pmode, plus_constant (buf_addr, GET_MODE_SIZE (Pmode))),\n+  mem = gen_rtx_MEM (Pmode, plus_constant (Pmode, buf_addr,\n+\t\t\t\t\t   GET_MODE_SIZE (Pmode))),\n   set_mem_alias_set (mem, setjmp_alias_set);\n \n   emit_move_insn (validize_mem (mem),\n \t\t  force_reg (Pmode, gen_rtx_LABEL_REF (Pmode, receiver_label)));\n \n   stack_save = gen_rtx_MEM (sa_mode,\n-\t\t\t    plus_constant (buf_addr,\n+\t\t\t    plus_constant (Pmode, buf_addr,\n \t\t\t\t\t   2 * GET_MODE_SIZE (Pmode)));\n   set_mem_alias_set (stack_save, setjmp_alias_set);\n   emit_stack_save (SAVE_NONLOCAL, &stack_save);\n@@ -1007,10 +1008,10 @@ expand_builtin_longjmp (rtx buf_addr, rtx value)\n #endif\n     {\n       fp = gen_rtx_MEM (Pmode, buf_addr);\n-      lab = gen_rtx_MEM (Pmode, plus_constant (buf_addr,\n+      lab = gen_rtx_MEM (Pmode, plus_constant (Pmode, buf_addr,\n \t\t\t\t\t       GET_MODE_SIZE (Pmode)));\n \n-      stack = gen_rtx_MEM (sa_mode, plus_constant (buf_addr,\n+      stack = gen_rtx_MEM (sa_mode, plus_constant (Pmode, buf_addr,\n \t\t\t\t\t\t   2 * GET_MODE_SIZE (Pmode)));\n       set_mem_alias_set (fp, setjmp_alias_set);\n       set_mem_alias_set (lab, setjmp_alias_set);\n@@ -1084,7 +1085,8 @@ expand_builtin_nonlocal_goto (tree exp)\n   r_save_area = copy_to_reg (r_save_area);\n   r_fp = gen_rtx_MEM (Pmode, r_save_area);\n   r_sp = gen_rtx_MEM (STACK_SAVEAREA_MODE (SAVE_NONLOCAL),\n-\t\t      plus_constant (r_save_area, GET_MODE_SIZE (Pmode)));\n+\t\t      plus_constant (Pmode, r_save_area,\n+\t\t\t\t     GET_MODE_SIZE (Pmode)));\n \n   crtl->has_nonlocal_goto = 1;\n \n@@ -1154,7 +1156,8 @@ expand_builtin_update_setjmp_buf (rtx buf_addr)\n     = gen_rtx_MEM (sa_mode,\n \t\t   memory_address\n \t\t   (sa_mode,\n-\t\t    plus_constant (buf_addr, 2 * GET_MODE_SIZE (Pmode))));\n+\t\t    plus_constant (Pmode, buf_addr,\n+\t\t\t\t   2 * GET_MODE_SIZE (Pmode))));\n \n   emit_stack_save (SAVE_NONLOCAL, &stack_save);\n }\n@@ -1539,7 +1542,7 @@ expand_builtin_apply_args_1 (void)\n      as we might have pretended they were passed.  Make sure it's a valid\n      operand, as emit_move_insn isn't expected to handle a PLUS.  */\n   tem\n-    = force_operand (plus_constant (tem, crtl->args.pretend_args_size),\n+    = force_operand (plus_constant (Pmode, tem, crtl->args.pretend_args_size),\n \t\t     NULL_RTX);\n #endif\n   emit_move_insn (adjust_address (registers, Pmode, 0), tem);\n@@ -1660,7 +1663,7 @@ expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n   dest = virtual_outgoing_args_rtx;\n #ifndef STACK_GROWS_DOWNWARD\n   if (CONST_INT_P (argsize))\n-    dest = plus_constant (dest, -INTVAL (argsize));\n+    dest = plus_constant (Pmode, dest, -INTVAL (argsize));\n   else\n     dest = gen_rtx_PLUS (Pmode, dest, negate_rtx (Pmode, argsize));\n #endif\n@@ -3352,7 +3355,8 @@ expand_movstr (tree dest, tree src, rtx target, int endp)\n \t adjust it.  */\n       if (endp == 1)\n \t{\n-\t  rtx tem = plus_constant (gen_lowpart (GET_MODE (target), target), 1);\n+\t  rtx tem = plus_constant (GET_MODE (target),\n+\t\t\t\t   gen_lowpart (GET_MODE (target), target), 1);\n \t  emit_move_insn (target, force_operand (tem, NULL_RTX));\n \t}\n     }\n@@ -3451,7 +3455,7 @@ expand_builtin_stpcpy (tree exp, rtx target, enum machine_mode mode)\n \t\t  if (GET_MODE (target) != GET_MODE (ret))\n \t\t    ret = gen_lowpart (GET_MODE (target), ret);\n \n-\t\t  ret = plus_constant (ret, INTVAL (len_rtx));\n+\t\t  ret = plus_constant (GET_MODE (ret), ret, INTVAL (len_rtx));\n \t\t  ret = emit_move_insn (target, force_operand (ret, NULL_RTX));\n \t\t  gcc_assert (ret);\n "}, {"sha": "a01c4233357041a07418994b3a05b162063465c3", "filename": "gcc/calls.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -868,6 +868,7 @@ save_fixed_argument_area (int reg_parm_stack_space, rtx argblock, int *low_to_sa\n \tint num_to_save;\n \tenum machine_mode save_mode;\n \tint delta;\n+\trtx addr;\n \trtx stack_area;\n \trtx save_area;\n \n@@ -891,10 +892,8 @@ save_fixed_argument_area (int reg_parm_stack_space, rtx argblock, int *low_to_sa\n #else\n \tdelta = low;\n #endif\n-\tstack_area = gen_rtx_MEM (save_mode,\n-\t\t\t\t  memory_address (save_mode,\n-\t\t\t\t\t\t  plus_constant (argblock,\n-\t\t\t\t\t\t\t\t delta)));\n+\taddr = plus_constant (Pmode, argblock, delta);\n+\tstack_area = gen_rtx_MEM (save_mode, memory_address (save_mode, addr));\n \n \tset_mem_align (stack_area, PARM_BOUNDARY);\n \tif (save_mode == BLKmode)\n@@ -920,16 +919,15 @@ restore_fixed_argument_area (rtx save_area, rtx argblock, int high_to_save, int\n {\n   enum machine_mode save_mode = GET_MODE (save_area);\n   int delta;\n-  rtx stack_area;\n+  rtx addr, stack_area;\n \n #ifdef ARGS_GROW_DOWNWARD\n   delta = -high_to_save;\n #else\n   delta = low_to_save;\n #endif\n-  stack_area = gen_rtx_MEM (save_mode,\n-\t\t\t    memory_address (save_mode,\n-\t\t\t\t\t    plus_constant (argblock, delta)));\n+  addr = plus_constant (Pmode, argblock, delta);\n+  stack_area = gen_rtx_MEM (save_mode, memory_address (save_mode, addr));\n   set_mem_align (stack_area, PARM_BOUNDARY);\n \n   if (save_mode != BLKmode)\n@@ -1560,11 +1558,11 @@ compute_argument_addresses (struct arg_data *args, rtx argblock, int num_actuals\n \t    continue;\n \n \t  if (CONST_INT_P (offset))\n-\t    addr = plus_constant (arg_reg, INTVAL (offset));\n+\t    addr = plus_constant (Pmode, arg_reg, INTVAL (offset));\n \t  else\n \t    addr = gen_rtx_PLUS (Pmode, arg_reg, offset);\n \n-\t  addr = plus_constant (addr, arg_offset);\n+\t  addr = plus_constant (Pmode, addr, arg_offset);\n \n \t  if (args[i].partial != 0)\n \t    {\n@@ -1594,11 +1592,11 @@ compute_argument_addresses (struct arg_data *args, rtx argblock, int num_actuals\n \t  set_mem_align (args[i].stack, align);\n \n \t  if (CONST_INT_P (slot_offset))\n-\t    addr = plus_constant (arg_reg, INTVAL (slot_offset));\n+\t    addr = plus_constant (Pmode, arg_reg, INTVAL (slot_offset));\n \t  else\n \t    addr = gen_rtx_PLUS (Pmode, arg_reg, slot_offset);\n \n-\t  addr = plus_constant (addr, arg_offset);\n+\t  addr = plus_constant (Pmode, addr, arg_offset);\n \n \t  if (args[i].partial != 0)\n \t    {\n@@ -1759,7 +1757,7 @@ internal_arg_pointer_based_exp (rtx rtl, bool toplevel)\n       rtx val = internal_arg_pointer_based_exp (XEXP (rtl, 0), toplevel);\n       if (val == NULL_RTX || val == pc_rtx)\n \treturn val;\n-      return plus_constant (val, INTVAL (XEXP (rtl, 1)));\n+      return plus_constant (Pmode, val, INTVAL (XEXP (rtl, 1)));\n     }\n \n   /* When called at the topmost level, scan pseudo assignments in between the\n@@ -2716,9 +2714,9 @@ expand_call (tree exp, rtx target, int ignore)\n \t  argblock = crtl->args.internal_arg_pointer;\n \t  argblock\n #ifdef STACK_GROWS_DOWNWARD\n-\t    = plus_constant (argblock, crtl->args.pretend_args_size);\n+\t    = plus_constant (Pmode, argblock, crtl->args.pretend_args_size);\n #else\n-\t    = plus_constant (argblock, -crtl->args.pretend_args_size);\n+\t    = plus_constant (Pmode, argblock, -crtl->args.pretend_args_size);\n #endif\n \t  stored_args_map = sbitmap_alloc (args_size.constant);\n \t  sbitmap_zero (stored_args_map);\n@@ -2853,7 +2851,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t    {\n \t\t      argblock = push_block (GEN_INT (needed), 0, 0);\n #ifdef ARGS_GROW_DOWNWARD\n-\t\t      argblock = plus_constant (argblock, needed);\n+\t\t      argblock = plus_constant (Pmode, argblock, needed);\n #endif\n \t\t    }\n \n@@ -3890,7 +3888,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t use virtuals anyway, they won't match the rtl patterns.  */\n \n       if (virtuals_instantiated)\n-\targblock = plus_constant (stack_pointer_rtx, STACK_POINTER_OFFSET);\n+\targblock = plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t  STACK_POINTER_OFFSET);\n       else\n \targblock = virtual_outgoing_args_rtx;\n     }\n@@ -3976,7 +3975,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t\t  enum machine_mode save_mode\n \t\t    = mode_for_size (size, MODE_INT, 1);\n \t\t  rtx adr\n-\t\t    = plus_constant (argblock,\n+\t\t    = plus_constant (Pmode, argblock,\n \t\t\t\t     argvec[argnum].locate.offset.constant);\n \t\t  rtx stack_area\n \t\t    = gen_rtx_MEM (save_mode, memory_address (save_mode, adr));\n@@ -4018,7 +4017,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t  /* Indicate argument access so that alias.c knows that these\n \t     values are live.  */\n \t  if (argblock)\n-\t    use = plus_constant (argblock,\n+\t    use = plus_constant (Pmode, argblock,\n \t\t\t\t argvec[argnum].locate.offset.constant);\n \t  else\n \t    /* When arguments are pushed, trying to tell alias.c where\n@@ -4244,7 +4243,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \tif (argvec[count].save_area)\n \t  {\n \t    enum machine_mode save_mode = GET_MODE (argvec[count].save_area);\n-\t    rtx adr = plus_constant (argblock,\n+\t    rtx adr = plus_constant (Pmode, argblock,\n \t\t\t\t     argvec[count].locate.offset.constant);\n \t    rtx stack_area = gen_rtx_MEM (save_mode,\n \t\t\t\t\t  memory_address (save_mode, adr));"}, {"sha": "126b132eb055e31cc8af0d5625b5a597ede66bab", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -873,7 +873,7 @@ expand_one_stack_var_at (tree decl, rtx base, unsigned base_align,\n   /* If this fails, we've overflowed the stack frame.  Error nicely?  */\n   gcc_assert (offset == trunc_int_for_mode (offset, Pmode));\n \n-  x = plus_constant (base, offset);\n+  x = plus_constant (Pmode, base, offset);\n   x = gen_rtx_MEM (DECL_MODE (SSAVAR (decl)), x);\n \n   if (TREE_CODE (decl) != SSA_NAME)\n@@ -2836,6 +2836,7 @@ expand_debug_expr (tree exp)\n \t}\n       /* FALLTHROUGH */\n     case INDIRECT_REF:\n+      inner_mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n       op0 = expand_debug_expr (TREE_OPERAND (exp, 0));\n       if (!op0)\n \treturn NULL;\n@@ -2853,7 +2854,7 @@ expand_debug_expr (tree exp)\n \t  if (!op1 || !CONST_INT_P (op1))\n \t    return NULL;\n \n-\t  op0 = plus_constant (op0, INTVAL (op1));\n+\t  op0 = plus_constant (inner_mode, op0, INTVAL (op1));\n \t}\n \n       if (POINTER_TYPE_P (TREE_TYPE (exp)))\n@@ -3347,8 +3348,10 @@ expand_debug_expr (tree exp)\n \t\t  && (bitoffset % BITS_PER_UNIT) == 0\n \t\t  && bitsize > 0\n \t\t  && bitsize == maxsize)\n-\t\treturn plus_constant (gen_rtx_DEBUG_IMPLICIT_PTR (mode, decl),\n-\t\t\t\t      bitoffset / BITS_PER_UNIT);\n+\t\t{\n+\t\t  rtx base = gen_rtx_DEBUG_IMPLICIT_PTR (mode, decl);\n+\t\t  return plus_constant (mode, base, bitoffset / BITS_PER_UNIT);\n+\t\t}\n \t    }\n \n \t  return NULL;"}, {"sha": "27aca85de38c598406a7d2d61fdb738ba37839bc", "filename": "gcc/combine-stack-adj.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -214,7 +214,8 @@ try_apply_stack_adjustment (rtx insn, struct csa_reflist *reflist,\n \n   for (ml = reflist; ml ; ml = ml->next)\n     {\n-      rtx new_addr = plus_constant (stack_pointer_rtx, ml->sp_offset - delta);\n+      rtx new_addr = plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t    ml->sp_offset - delta);\n       rtx new_val;\n \n       if (MEM_P (*ml->ref))"}, {"sha": "d2c65141fedc1247c275cefee6909d4d2d0683f7", "filename": "gcc/combine.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -5874,7 +5874,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest,\n \t\t       == GET_MODE_PRECISION (mode)))\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      return plus_constant (gen_lowpart (mode, op0), 1);\n+\t      return plus_constant (mode, gen_lowpart (mode, op0), 1);\n \t    }\n \n \t  /* If STORE_FLAG_VALUE is -1, we have cases similar to\n@@ -5923,7 +5923,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest,\n \t\t   && nonzero_bits (op0, mode) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      return plus_constant (gen_lowpart (mode, op0), -1);\n+\t      return plus_constant (mode, gen_lowpart (mode, op0), -1);\n \t    }\n \n \t  /* If STORE_FLAG_VALUE says to just test the sign bit and X has just\n@@ -8306,7 +8306,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t    && exact_log2 (- smask) >= 0\n \t    && (nonzero_bits (XEXP (x, 0), mode) & ~smask) == 0\n \t    && (INTVAL (XEXP (x, 1)) & ~smask) != 0)\n-\t  return force_to_mode (plus_constant (XEXP (x, 0),\n+\t  return force_to_mode (plus_constant (GET_MODE (x), XEXP (x, 0),\n \t\t\t\t\t       (INTVAL (XEXP (x, 1)) & smask)),\n \t\t\t\tmode, smask, next_select);\n       }"}, {"sha": "174abc2f5599186ef8dce030bee21e6c8f072a80", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -988,7 +988,7 @@ alpha_legitimize_address_1 (rtx x, rtx scratch, enum machine_mode mode)\n \t\t\t       (!can_create_pseudo_p () ? scratch : NULL_RTX),\n \t\t\t       1, OPTAB_LIB_WIDEN);\n \n-    return plus_constant (x, low);\n+    return plus_constant (Pmode, x, low);\n   }\n }\n \n@@ -1388,7 +1388,7 @@ get_unaligned_address (rtx ref)\n   if (GET_CODE (base) == PLUS)\n     offset += INTVAL (XEXP (base, 1)), base = XEXP (base, 0);\n \n-  return plus_constant (base, offset);\n+  return plus_constant (Pmode, base, offset);\n }\n \n /* Compute a value X, such that X & 7 == (ADDR + OFS) & 7.\n@@ -3233,21 +3233,22 @@ alpha_expand_unaligned_load (rtx tgt, rtx mem, HOST_WIDE_INT size,\n \n   tmp = change_address (mem, DImode,\n \t\t\tgen_rtx_AND (DImode,\n-\t\t\t\t     plus_constant (mema, ofs),\n+\t\t\t\t     plus_constant (DImode, mema, ofs),\n \t\t\t\t     GEN_INT (-8)));\n   set_mem_alias_set (tmp, 0);\n   emit_move_insn (meml, tmp);\n \n   tmp = change_address (mem, DImode,\n \t\t\tgen_rtx_AND (DImode,\n-\t\t\t\t     plus_constant (mema, ofs + size - 1),\n+\t\t\t\t     plus_constant (DImode, mema,\n+\t\t\t\t\t\t    ofs + size - 1),\n \t\t\t\t     GEN_INT (-8)));\n   set_mem_alias_set (tmp, 0);\n   emit_move_insn (memh, tmp);\n \n   if (sign && size == 2)\n     {\n-      emit_move_insn (addr, plus_constant (mema, ofs+2));\n+      emit_move_insn (addr, plus_constant (Pmode, mema, ofs+2));\n \n       emit_insn (gen_extql (extl, meml, addr));\n       emit_insn (gen_extqh (exth, memh, addr));\n@@ -3261,7 +3262,7 @@ alpha_expand_unaligned_load (rtx tgt, rtx mem, HOST_WIDE_INT size,\n     }\n   else\n     {\n-      emit_move_insn (addr, plus_constant (mema, ofs));\n+      emit_move_insn (addr, plus_constant (Pmode, mema, ofs));\n       emit_insn (gen_extxl (extl, meml, GEN_INT (size*8), addr));\n       switch ((int) size)\n \t{\n@@ -3333,20 +3334,21 @@ alpha_expand_unaligned_store (rtx dst, rtx src,\n \n   meml = change_address (dst, DImode,\n \t\t\t gen_rtx_AND (DImode,\n-\t\t\t\t      plus_constant (dsta, ofs),\n+\t\t\t\t      plus_constant (DImode, dsta, ofs),\n \t\t\t\t      GEN_INT (-8)));\n   set_mem_alias_set (meml, 0);\n \n   memh = change_address (dst, DImode,\n \t\t\t gen_rtx_AND (DImode,\n-\t\t\t\t      plus_constant (dsta, ofs + size - 1),\n+\t\t\t\t      plus_constant (DImode, dsta,\n+\t\t\t\t\t\t     ofs + size - 1),\n \t\t\t\t      GEN_INT (-8)));\n   set_mem_alias_set (memh, 0);\n \n   emit_move_insn (dsth, memh);\n   emit_move_insn (dstl, meml);\n \n-  addr = copy_addr_to_reg (plus_constant (dsta, ofs));\n+  addr = copy_addr_to_reg (plus_constant (Pmode, dsta, ofs));\n \n   if (src != CONST0_RTX (GET_MODE (src)))\n     {\n@@ -3436,15 +3438,16 @@ alpha_expand_unaligned_load_words (rtx *out_regs, rtx smem,\n     {\n       tmp = change_address (smem, DImode,\n \t\t\t    gen_rtx_AND (DImode,\n-\t\t\t\t\t plus_constant (smema, 8*i),\n+\t\t\t\t\t plus_constant (DImode, smema, 8*i),\n \t\t\t\t\t im8));\n       set_mem_alias_set (tmp, 0);\n       emit_move_insn (data_regs[i], tmp);\n     }\n \n   tmp = change_address (smem, DImode,\n \t\t\tgen_rtx_AND (DImode,\n-\t\t\t\t     plus_constant (smema, 8*words - 1),\n+\t\t\t\t     plus_constant (DImode, smema,\n+\t\t\t\t\t\t    8*words - 1),\n \t\t\t\t     im8));\n   set_mem_alias_set (tmp, 0);\n   emit_move_insn (data_regs[words], tmp);\n@@ -3504,8 +3507,9 @@ alpha_expand_unaligned_store_words (rtx *data_regs, rtx dmem,\n \n   st_addr_2 = change_address (dmem, DImode,\n \t\t\t      gen_rtx_AND (DImode,\n-\t\t\t\t\t   plus_constant (dmema, words*8 - 1),\n-\t\t\t\t       im8));\n+\t\t\t\t\t   plus_constant (DImode, dmema,\n+\t\t\t\t\t\t\t  words*8 - 1),\n+\t\t\t\t\t   im8));\n   set_mem_alias_set (st_addr_2, 0);\n \n   st_addr_1 = change_address (dmem, DImode,\n@@ -3551,7 +3555,8 @@ alpha_expand_unaligned_store_words (rtx *data_regs, rtx dmem,\n     {\n       rtx tmp = change_address (dmem, DImode,\n \t\t\t\tgen_rtx_AND (DImode,\n-\t\t\t\t\t     plus_constant (dmema, i*8),\n+\t\t\t\t\t     plus_constant (DImode,\n+\t\t\t\t\t\t\t    dmema, i*8),\n \t\t\t\t\t     im8));\n       set_mem_alias_set (tmp, 0);\n       emit_move_insn (tmp, data_regs ? ins_tmps[i-1] : const0_rtx);\n@@ -3961,7 +3966,8 @@ alpha_expand_block_clear (rtx operands[])\n \t  rtx mem\n \t    = change_address (orig_dst, DImode,\n \t\t\t      gen_rtx_AND (DImode,\n-\t\t\t\t\t   plus_constant (orig_dsta, ofs + i*8),\n+\t\t\t\t\t   plus_constant (DImode, orig_dsta,\n+\t\t\t\t\t\t\t  ofs + i*8),\n \t\t\t\t\t   GEN_INT (-8)));\n \t  set_mem_alias_set (mem, 0);\n \t  emit_move_insn (mem, const0_rtx);\n@@ -4718,8 +4724,8 @@ alpha_init_machine_status (void)\n void\n alpha_expand_builtin_establish_vms_condition_handler (rtx target, rtx handler)\n {\n-  rtx handler_slot_address\n-    = plus_constant (hard_frame_pointer_rtx, VMS_COND_HANDLER_FP_OFFSET);\n+  rtx handler_slot_address = plus_constant (Pmode, hard_frame_pointer_rtx,\n+\t\t\t\t\t    VMS_COND_HANDLER_FP_OFFSET);\n \n   rtx handler_slot\n     = gen_rtx_MEM (DImode, handler_slot_address);\n@@ -6055,7 +6061,7 @@ alpha_setup_incoming_varargs (cumulative_args_t pcum, enum machine_mode mode,\n       if (cfun->va_list_fpr_size & 1)\n \t{\n \t  tmp = gen_rtx_MEM (BLKmode,\n-\t\t\t     plus_constant (virtual_incoming_args_rtx,\n+\t\t\t     plus_constant (Pmode, virtual_incoming_args_rtx,\n \t\t\t\t\t    (cum + 6) * UNITS_PER_WORD));\n \t  MEM_NOTRAP_P (tmp) = 1;\n \t  set_mem_alias_set (tmp, set);\n@@ -6065,7 +6071,7 @@ alpha_setup_incoming_varargs (cumulative_args_t pcum, enum machine_mode mode,\n       if (cfun->va_list_fpr_size & 2)\n \t{\n \t  tmp = gen_rtx_MEM (BLKmode,\n-\t\t\t     plus_constant (virtual_incoming_args_rtx,\n+\t\t\t     plus_constant (Pmode, virtual_incoming_args_rtx,\n \t\t\t\t\t    cum * UNITS_PER_WORD));\n \t  MEM_NOTRAP_P (tmp) = 1;\n \t  set_mem_alias_set (tmp, set);\n@@ -7514,7 +7520,7 @@ emit_frame_store_1 (rtx value, rtx base_reg, HOST_WIDE_INT frame_bias,\n {\n   rtx addr, mem, insn;\n \n-  addr = plus_constant (base_reg, base_ofs);\n+  addr = plus_constant (Pmode, base_reg, base_ofs);\n   mem = gen_frame_mem (DImode, addr);\n \n   insn = emit_move_insn (mem, value);\n@@ -7524,7 +7530,8 @@ emit_frame_store_1 (rtx value, rtx base_reg, HOST_WIDE_INT frame_bias,\n     {\n       if (frame_bias)\n \t{\n-\t  addr = plus_constant (stack_pointer_rtx, frame_bias + base_ofs);\n+\t  addr = plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t        frame_bias + base_ofs);\n \t  mem = gen_rtx_MEM (DImode, addr);\n \t}\n \n@@ -7679,7 +7686,8 @@ alpha_expand_prologue (void)\n \n       if ((leftover > 4096 && sa_size == 0) || flag_stack_check)\n \t{\n-\t  rtx last = gen_rtx_MEM (DImode, plus_constant (ptr, -leftover));\n+\t  rtx last = gen_rtx_MEM (DImode,\n+\t\t\t\t  plus_constant (Pmode, ptr, -leftover));\n \t  MEM_VOLATILE_P (last) = 1;\n \t  emit_move_insn (last, const0_rtx);\n \t}\n@@ -7710,7 +7718,7 @@ alpha_expand_prologue (void)\n       RTX_FRAME_RELATED_P (seq) = 1;\n       add_reg_note (seq, REG_FRAME_RELATED_EXPR,\n \t\t    gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t\t plus_constant (stack_pointer_rtx,\n+\t\t\t\t plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t-frame_size)));\n     }\n \n@@ -7791,7 +7799,7 @@ alpha_expand_prologue (void)\n \t  rtx seq\n \t    = emit_move_insn (stack_pointer_rtx,\n \t\t\t      plus_constant\n-\t\t\t      (hard_frame_pointer_rtx,\n+\t\t\t      (Pmode, hard_frame_pointer_rtx,\n \t\t\t       - (ALPHA_ROUND\n \t\t\t\t  (crtl->outgoing_args_size))));\n \n@@ -8087,14 +8095,14 @@ alpha_expand_epilogue (void)\n \t    bias = reg_offset, reg_offset = 0;\n \n \t  sa_reg = gen_rtx_REG (DImode, 22);\n-\t  sa_reg_exp = plus_constant (stack_pointer_rtx, bias);\n+\t  sa_reg_exp = plus_constant (Pmode, stack_pointer_rtx, bias);\n \n \t  emit_move_insn (sa_reg, sa_reg_exp);\n \t}\n \n       /* Restore registers in order, excepting a true frame pointer.  */\n \n-      mem = gen_frame_mem (DImode, plus_constant (sa_reg, reg_offset));\n+      mem = gen_frame_mem (DImode, plus_constant (Pmode, sa_reg, reg_offset));\n       reg = gen_rtx_REG (DImode, REG_RA);\n       emit_move_insn (reg, mem);\n       cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n@@ -8110,7 +8118,8 @@ alpha_expand_epilogue (void)\n \t    else\n \t      {\n \t\tmem = gen_frame_mem (DImode,\n-\t\t\t\t     plus_constant (sa_reg, reg_offset));\n+\t\t\t\t     plus_constant (Pmode, sa_reg,\n+\t\t\t\t\t\t    reg_offset));\n \t\treg = gen_rtx_REG (DImode, i);\n \t\temit_move_insn (reg, mem);\n \t\tcfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n@@ -8122,7 +8131,8 @@ alpha_expand_epilogue (void)\n       for (i = 0; i < 31; ++i)\n \tif (fmask & (1UL << i))\n \t  {\n-\t    mem = gen_frame_mem (DFmode, plus_constant (sa_reg, reg_offset));\n+\t    mem = gen_frame_mem (DFmode, plus_constant (Pmode, sa_reg,\n+\t\t\t\t\t\t        reg_offset));\n \t    reg = gen_rtx_REG (DFmode, i+32);\n \t    emit_move_insn (reg, mem);\n \t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n@@ -8150,7 +8160,7 @@ alpha_expand_epilogue (void)\n \t{\n \t  int low = ((frame_size & 0xffff) ^ 0x8000) - 0x8000;\n \n-\t  sp_adj2 = plus_constant (sp_adj1, frame_size - low);\n+\t  sp_adj2 = plus_constant (Pmode, sp_adj1, frame_size - low);\n \t  if (sa_reg_exp && rtx_equal_p (sa_reg_exp, sp_adj2))\n \t    sp_adj1 = sa_reg;\n \t  else\n@@ -8180,7 +8190,8 @@ alpha_expand_epilogue (void)\n       if (fp_is_frame_pointer)\n \t{\n \t  emit_insn (gen_blockage ());\n-\t  mem = gen_frame_mem (DImode, plus_constant (sa_reg, fp_offset));\n+\t  mem = gen_frame_mem (DImode, plus_constant (Pmode, sa_reg,\n+\t\t\t\t\t\t      fp_offset));\n \t  emit_move_insn (hard_frame_pointer_rtx, mem);\n \t  cfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n \t\t\t\t\t hard_frame_pointer_rtx, cfa_restores);\n@@ -9509,7 +9520,7 @@ alpha_use_linkage (rtx func, bool lflag, bool rflag)\n   al->rkind = rflag ? KIND_CODEADDR : KIND_LINKAGE;\n \n   if (lflag)\n-    return gen_rtx_MEM (Pmode, plus_constant (al->linkage, 8));\n+    return gen_rtx_MEM (Pmode, plus_constant (Pmode, al->linkage, 8));\n   else\n     return al->linkage;\n }"}, {"sha": "8520ea82f45ec351d8969805337d88ebd4b7f3e7", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -767,7 +767,7 @@ extern int alpha_memory_latency;\n #define EH_RETURN_DATA_REGNO(N)\t((N) < 4 ? (N) + 16 : INVALID_REGNUM)\n #define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, 28)\n #define EH_RETURN_HANDLER_RTX \\\n-  gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx, \\\n+  gen_rtx_MEM (Pmode, plus_constant (Pmode, stack_pointer_rtx, \\\n \t\t\t\t     crtl->outgoing_args_size))\n \f\n /* Addressing modes, and classification of registers for them.  */"}, {"sha": "e89ed271942080b81dc4c59c1abf1e8eef487d16", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1666,7 +1666,7 @@\n ;;\t\t   (match_dup 4)))]\n ;;  \"\n ;;{\n-;;  operands[6] = plus_constant (operands[3],\n+;;  operands[6] = plus_constant (DImode, operands[3],\n ;;\t\t\t       INTVAL (operands[2]) / BITS_PER_UNIT);\n ;;  operands[7] = GEN_INT (- INTVAL (operands[2]) / BITS_PER_UNIT);\n ;;}\")\n@@ -3971,7 +3971,8 @@\n   else\n     {\n       emit_move_insn (gen_rtx_REG (Pmode, 26),\n-\t\t      gen_rtx_MEM (Pmode, plus_constant (operands[0], 8)));\n+\t\t      gen_rtx_MEM (Pmode, plus_constant (Pmode,\n+\t\t\t\t\t\t\t operands[0], 8)));\n       operands[2] = operands[0];\n     }\n \n@@ -4046,7 +4047,8 @@\n   else\n     {\n       emit_move_insn (gen_rtx_REG (Pmode, 26),\n-\t\t      gen_rtx_MEM (Pmode, plus_constant (operands[1], 8)));\n+\t\t      gen_rtx_MEM (Pmode, plus_constant (Pmode,\n+\t\t\t\t\t\t\t operands[1], 8)));\n       operands[3] = operands[1];\n     }\n })\n@@ -5572,7 +5574,7 @@\n   [(set (match_dup 1) (match_operand:DI 0 \"const_int_operand\" \"\"))]\n   \"\"\n {\n-  operands[1] = gen_rtx_MEM (DImode, plus_constant (stack_pointer_rtx,\n+  operands[1] = gen_rtx_MEM (DImode, plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t    INTVAL (operands[0])));\n   MEM_VOLATILE_P (operands[1]) = 1;\n \n@@ -5794,8 +5796,8 @@\n {\n   /* The elements of the buffer are, in order:  */\n   rtx fp = gen_rtx_MEM (Pmode, operands[0]);\n-  rtx lab = gen_rtx_MEM (Pmode, plus_constant (operands[0], 8));\n-  rtx stack = gen_rtx_MEM (Pmode, plus_constant (operands[0], 16));\n+  rtx lab = gen_rtx_MEM (Pmode, plus_constant (Pmode, operands[0], 8));\n+  rtx stack = gen_rtx_MEM (Pmode, plus_constant (Pmode, operands[0], 16));\n   rtx pv = gen_rtx_REG (Pmode, 27);\n \n   /* This bit is the same as expand_builtin_longjmp.  */"}, {"sha": "6f90122fef328de3fa39a87a11fc90ce3747da90", "filename": "gcc/config/alpha/vms.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Falpha%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Falpha%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms.h?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -206,7 +206,7 @@ typedef struct {int num_args; enum avms_arg_type atypes[6];} avms_arg_info;\n \n #undef EH_RETURN_HANDLER_RTX\n #define EH_RETURN_HANDLER_RTX \\\n-  gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx, 8))\n+  gen_rtx_MEM (Pmode, plus_constant (Pmode, stack_pointer_rtx, 8))\n \n #define LINK_EH_SPEC \"vms-dwarf2eh.o%s \"\n #define LINK_GCC_C_SEQUENCE_SPEC \"%G\""}, {"sha": "17b4b5d43de2048e21f30490d53b714d1080d1e8", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 85, "deletions": 72, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -2226,7 +2226,7 @@ arm_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n   a_tramp = XEXP (m_tramp, 0);\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__clear_cache\"),\n \t\t     LCT_NORMAL, VOIDmode, 2, a_tramp, Pmode,\n-\t\t     plus_constant (a_tramp, TRAMPOLINE_SIZE), Pmode);\n+\t\t     plus_constant (Pmode, a_tramp, TRAMPOLINE_SIZE), Pmode);\n }\n \n /* Thumb trampolines should be entered in thumb mode, so set\n@@ -5458,7 +5458,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t    }\n \n \t  if (GET_CODE (offset) == CONST_INT)\n-\t    return plus_constant (base, INTVAL (offset));\n+\t    return plus_constant (Pmode, base, INTVAL (offset));\n \t}\n \n       if (GET_MODE_SIZE (mode) > 4\n@@ -5575,7 +5575,7 @@ arm_load_pic_register (unsigned long saved_regs ATTRIBUTE_UNUSED)\n \n       /* On the ARM the PC register contains 'dot + 8' at the time of the\n \t addition, on the Thumb it is 'dot + 4'.  */\n-      pic_rtx = plus_constant (l1, TARGET_ARM ? 8 : 4);\n+      pic_rtx = plus_constant (Pmode, l1, TARGET_ARM ? 8 : 4);\n       pic_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, pic_rtx),\n \t\t\t\tUNSPEC_GOTSYM_OFF);\n       pic_rtx = gen_rtx_CONST (Pmode, pic_rtx);\n@@ -5623,7 +5623,7 @@ arm_pic_static_addr (rtx orig, rtx reg)\n \n   /* On the ARM the PC register contains 'dot + 8' at the time of the\n      addition, on the Thumb it is 'dot + 4'.  */\n-  offset_rtx = plus_constant (l1, TARGET_ARM ? 8 : 4);\n+  offset_rtx = plus_constant (Pmode, l1, TARGET_ARM ? 8 : 4);\n   offset_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, orig, offset_rtx),\n                                UNSPEC_SYMBOL_OFFSET);\n   offset_rtx = gen_rtx_CONST (Pmode, offset_rtx);\n@@ -6513,9 +6513,9 @@ arm_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n \t    }\n \n \t  base_reg = gen_reg_rtx (SImode);\n-\t  val = force_operand (plus_constant (xop0, n), NULL_RTX);\n+\t  val = force_operand (plus_constant (Pmode, xop0, n), NULL_RTX);\n \t  emit_move_insn (base_reg, val);\n-\t  x = plus_constant (base_reg, low_n);\n+\t  x = plus_constant (Pmode, base_reg, low_n);\n \t}\n       else if (xop0 != XEXP (x, 0) || xop1 != XEXP (x, 1))\n \tx = gen_rtx_PLUS (SImode, xop0, xop1);\n@@ -6563,7 +6563,7 @@ arm_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n \t  index -= mask;\n \t}\n       base_reg = force_reg (SImode, GEN_INT (base));\n-      x = plus_constant (base_reg, index);\n+      x = plus_constant (Pmode, base_reg, index);\n     }\n \n   if (flag_pic)\n@@ -6612,9 +6612,9 @@ thumb_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n \t  else\n \t    delta = offset & (~31 * GET_MODE_SIZE (mode));\n \n-\t  xop0 = force_operand (plus_constant (xop0, offset - delta),\n+\t  xop0 = force_operand (plus_constant (Pmode, xop0, offset - delta),\n \t\t\t\tNULL_RTX);\n-\t  x = plus_constant (xop0, delta);\n+\t  x = plus_constant (Pmode, xop0, delta);\n \t}\n       else if (offset < 0 && offset > -256)\n \t/* Small negative offsets are best done with a subtract before the\n@@ -10781,7 +10781,7 @@ arm_gen_load_multiple_1 (int count, int *regs, rtx *mems, rtx basereg,\n \temit_move_insn (gen_rtx_REG (SImode, regs[i]), mems[i]);\n \n       if (wback_offset != 0)\n-\temit_move_insn (basereg, plus_constant (basereg, wback_offset));\n+\temit_move_insn (basereg, plus_constant (Pmode, basereg, wback_offset));\n \n       seq = get_insns ();\n       end_sequence ();\n@@ -10795,7 +10795,7 @@ arm_gen_load_multiple_1 (int count, int *regs, rtx *mems, rtx basereg,\n     {\n       XVECEXP (result, 0, 0)\n \t= gen_rtx_SET (VOIDmode, basereg,\n-\t\t       plus_constant (basereg, wback_offset));\n+\t\t       plus_constant (Pmode, basereg, wback_offset));\n       i = 1;\n       count++;\n     }\n@@ -10833,7 +10833,7 @@ arm_gen_store_multiple_1 (int count, int *regs, rtx *mems, rtx basereg,\n \temit_move_insn (mems[i], gen_rtx_REG (SImode, regs[i]));\n \n       if (wback_offset != 0)\n-\temit_move_insn (basereg, plus_constant (basereg, wback_offset));\n+\temit_move_insn (basereg, plus_constant (Pmode, basereg, wback_offset));\n \n       seq = get_insns ();\n       end_sequence ();\n@@ -10847,7 +10847,7 @@ arm_gen_store_multiple_1 (int count, int *regs, rtx *mems, rtx basereg,\n     {\n       XVECEXP (result, 0, 0)\n \t= gen_rtx_SET (VOIDmode, basereg,\n-\t\t       plus_constant (basereg, wback_offset));\n+\t\t       plus_constant (Pmode, basereg, wback_offset));\n       i = 1;\n       count++;\n     }\n@@ -10889,7 +10889,7 @@ arm_gen_multiple_op (bool is_load, int *regs, int count, rtx basereg,\n \n   for (i = 0; i < count; i++)\n     {\n-      rtx addr = plus_constant (basereg, i * 4);\n+      rtx addr = plus_constant (Pmode, basereg, i * 4);\n       mems[i] = adjust_automodify_address_nv (basemem, SImode, addr, offset);\n       offset += 4;\n     }\n@@ -10978,7 +10978,7 @@ gen_ldm_seq (rtx *operands, int nops, bool sort_regs)\n \n   for (i = 0; i < nops; i++)\n     {\n-      addr = plus_constant (base_reg_rtx, offset + i * 4);\n+      addr = plus_constant (Pmode, base_reg_rtx, offset + i * 4);\n       mems[i] = adjust_automodify_address_nv (operands[nops + mem_order[i]],\n \t\t\t\t\t      SImode, addr, 0);\n     }\n@@ -11028,11 +11028,11 @@ gen_stm_seq (rtx *operands, int nops)\n       offset = 0;\n     }\n \n-  addr = plus_constant (base_reg_rtx, offset);\n+  addr = plus_constant (Pmode, base_reg_rtx, offset);\n \n   for (i = 0; i < nops; i++)\n     {\n-      addr = plus_constant (base_reg_rtx, offset + i * 4);\n+      addr = plus_constant (Pmode, base_reg_rtx, offset + i * 4);\n       mems[i] = adjust_automodify_address_nv (operands[nops + mem_order[i]],\n \t\t\t\t\t      SImode, addr, 0);\n     }\n@@ -11144,11 +11144,11 @@ gen_const_stm_seq (rtx *operands, int nops)\n       offset = 0;\n     }\n \n-  addr = plus_constant (base_reg_rtx, offset);\n+  addr = plus_constant (Pmode, base_reg_rtx, offset);\n \n   for (i = 0; i < nops; i++)\n     {\n-      addr = plus_constant (base_reg_rtx, offset + i * 4);\n+      addr = plus_constant (Pmode, base_reg_rtx, offset + i * 4);\n       mems[i] = adjust_automodify_address_nv (operands[nops + mem_order[i]],\n \t\t\t\t\t      SImode, addr, 0);\n     }\n@@ -11220,8 +11220,8 @@ arm_block_move_unaligned_straight (rtx dstbase, rtx srcbase,\n \t{\n \t  for (j = 0; j < interleave_factor; j++)\n \t    {\n-\t      addr = plus_constant (src, srcoffset + j * UNITS_PER_WORD\n-\t\t\t\t\t - src_autoinc);\n+\t      addr = plus_constant (Pmode, src, (srcoffset + j * UNITS_PER_WORD\n+\t\t\t\t\t\t - src_autoinc));\n \t      mem = adjust_automodify_address (srcbase, SImode, addr,\n \t\t\t\t\t       srcoffset + j * UNITS_PER_WORD);\n \t      emit_insn (gen_unaligned_loadsi (regs[j], mem));\n@@ -11240,8 +11240,8 @@ arm_block_move_unaligned_straight (rtx dstbase, rtx srcbase,\n \t{\n \t  for (j = 0; j < interleave_factor; j++)\n \t    {\n-\t      addr = plus_constant (dst, dstoffset + j * UNITS_PER_WORD\n-\t\t\t\t\t - dst_autoinc);\n+\t      addr = plus_constant (Pmode, dst, (dstoffset + j * UNITS_PER_WORD\n+\t\t\t\t\t\t - dst_autoinc));\n \t      mem = adjust_automodify_address (dstbase, SImode, addr,\n \t\t\t\t\t       dstoffset + j * UNITS_PER_WORD);\n \t      emit_insn (gen_unaligned_storesi (mem, regs[j]));\n@@ -11269,7 +11269,7 @@ arm_block_move_unaligned_straight (rtx dstbase, rtx srcbase,\n     {\n       for (j = 0; j < words; j++)\n \t{\n-\t  addr = plus_constant (src,\n+\t  addr = plus_constant (Pmode, src,\n \t\t\t\tsrcoffset + j * UNITS_PER_WORD - src_autoinc);\n \t  mem = adjust_automodify_address (srcbase, SImode, addr,\n \t\t\t\t\t   srcoffset + j * UNITS_PER_WORD);\n@@ -11288,7 +11288,7 @@ arm_block_move_unaligned_straight (rtx dstbase, rtx srcbase,\n     {\n       for (j = 0; j < words; j++)\n \t{\n-\t  addr = plus_constant (dst,\n+\t  addr = plus_constant (Pmode, dst,\n \t\t\t\tdstoffset + j * UNITS_PER_WORD - dst_autoinc);\n \t  mem = adjust_automodify_address (dstbase, SImode, addr,\n \t\t\t\t\t   dstoffset + j * UNITS_PER_WORD);\n@@ -11307,15 +11307,15 @@ arm_block_move_unaligned_straight (rtx dstbase, rtx srcbase,\n     {\n       halfword_tmp = gen_reg_rtx (SImode);\n \n-      addr = plus_constant (src, srcoffset - src_autoinc);\n+      addr = plus_constant (Pmode, src, srcoffset - src_autoinc);\n       mem = adjust_automodify_address (srcbase, HImode, addr, srcoffset);\n       emit_insn (gen_unaligned_loadhiu (halfword_tmp, mem));\n \n       /* Either write out immediately, or delay until we've loaded the last\n \t byte, depending on interleave factor.  */\n       if (interleave_factor == 1)\n \t{\n-\t  addr = plus_constant (dst, dstoffset - dst_autoinc);\n+\t  addr = plus_constant (Pmode, dst, dstoffset - dst_autoinc);\n \t  mem = adjust_automodify_address (dstbase, HImode, addr, dstoffset);\n \t  emit_insn (gen_unaligned_storehi (mem,\n \t\t       gen_lowpart (HImode, halfword_tmp)));\n@@ -11335,13 +11335,13 @@ arm_block_move_unaligned_straight (rtx dstbase, rtx srcbase,\n     {\n       byte_tmp = gen_reg_rtx (SImode);\n \n-      addr = plus_constant (src, srcoffset - src_autoinc);\n+      addr = plus_constant (Pmode, src, srcoffset - src_autoinc);\n       mem = adjust_automodify_address (srcbase, QImode, addr, srcoffset);\n       emit_move_insn (gen_lowpart (QImode, byte_tmp), mem);\n \n       if (interleave_factor == 1)\n \t{\n-\t  addr = plus_constant (dst, dstoffset - dst_autoinc);\n+\t  addr = plus_constant (Pmode, dst, dstoffset - dst_autoinc);\n \t  mem = adjust_automodify_address (dstbase, QImode, addr, dstoffset);\n \t  emit_move_insn (mem, gen_lowpart (QImode, byte_tmp));\n \t  byte_tmp = NULL;\n@@ -11356,7 +11356,7 @@ arm_block_move_unaligned_straight (rtx dstbase, rtx srcbase,\n   \n   if (halfword_tmp)\n     {\n-      addr = plus_constant (dst, dstoffset - dst_autoinc);\n+      addr = plus_constant (Pmode, dst, dstoffset - dst_autoinc);\n       mem = adjust_automodify_address (dstbase, HImode, addr, dstoffset);\n       emit_insn (gen_unaligned_storehi (mem,\n \t\t   gen_lowpart (HImode, halfword_tmp)));\n@@ -11367,7 +11367,7 @@ arm_block_move_unaligned_straight (rtx dstbase, rtx srcbase,\n \n   if (byte_tmp)\n     {\n-      addr = plus_constant (dst, dstoffset - dst_autoinc);\n+      addr = plus_constant (Pmode, dst, dstoffset - dst_autoinc);\n       mem = adjust_automodify_address (dstbase, QImode, addr, dstoffset);\n       emit_move_insn (mem, gen_lowpart (QImode, byte_tmp));\n       dstoffset++;\n@@ -11433,8 +11433,8 @@ arm_block_move_unaligned_loop (rtx dest, rtx src, HOST_WIDE_INT length,\n \t\t\t\t     interleave_factor);\n \n   /* Move on to the next block.  */\n-  emit_move_insn (src_reg, plus_constant (src_reg, bytes_per_iter));\n-  emit_move_insn (dest_reg, plus_constant (dest_reg, bytes_per_iter));\n+  emit_move_insn (src_reg, plus_constant (Pmode, src_reg, bytes_per_iter));\n+  emit_move_insn (dest_reg, plus_constant (Pmode, dest_reg, bytes_per_iter));\n   \n   /* Emit the loop condition.  */\n   test = gen_rtx_NE (VOIDmode, src_reg, final_src);\n@@ -11595,7 +11595,8 @@ arm_gen_movmemqi (rtx *operands)\n       while (last_bytes)\n \t{\n \t  mem = adjust_automodify_address (dstbase, QImode,\n-\t\t\t\t\t   plus_constant (dst, last_bytes - 1),\n+\t\t\t\t\t   plus_constant (Pmode, dst,\n+\t\t\t\t\t\t\t  last_bytes - 1),\n \t\t\t\t\t   dstoffset + last_bytes - 1);\n \t  emit_move_insn (mem, gen_lowpart (QImode, part_bytes_reg));\n \n@@ -12120,11 +12121,11 @@ arm_reload_in_hi (rtx *operands)\n \n   emit_insn (gen_zero_extendqisi2 (scratch,\n \t\t\t\t   gen_rtx_MEM (QImode,\n-\t\t\t\t\t\tplus_constant (base,\n+\t\t\t\t\t\tplus_constant (Pmode, base,\n \t\t\t\t\t\t\t       offset))));\n   emit_insn (gen_zero_extendqisi2 (gen_rtx_SUBREG (SImode, operands[0], 0),\n \t\t\t\t   gen_rtx_MEM (QImode,\n-\t\t\t\t\t\tplus_constant (base,\n+\t\t\t\t\t\tplus_constant (Pmode, base,\n \t\t\t\t\t\t\t       offset + 1))));\n   if (!BYTES_BIG_ENDIAN)\n     emit_set_insn (gen_rtx_SUBREG (SImode, operands[0], 0),\n@@ -12284,23 +12285,27 @@ arm_reload_out_hi (rtx *operands)\n   if (BYTES_BIG_ENDIAN)\n     {\n       emit_insn (gen_movqi (gen_rtx_MEM (QImode,\n-\t\t\t\t\t plus_constant (base, offset + 1)),\n+\t\t\t\t\t plus_constant (Pmode, base,\n+\t\t\t\t\t\t\toffset + 1)),\n \t\t\t    gen_lowpart (QImode, outval)));\n       emit_insn (gen_lshrsi3 (scratch,\n \t\t\t      gen_rtx_SUBREG (SImode, outval, 0),\n \t\t\t      GEN_INT (8)));\n-      emit_insn (gen_movqi (gen_rtx_MEM (QImode, plus_constant (base, offset)),\n+      emit_insn (gen_movqi (gen_rtx_MEM (QImode, plus_constant (Pmode, base,\n+\t\t\t\t\t\t\t\toffset)),\n \t\t\t    gen_lowpart (QImode, scratch)));\n     }\n   else\n     {\n-      emit_insn (gen_movqi (gen_rtx_MEM (QImode, plus_constant (base, offset)),\n+      emit_insn (gen_movqi (gen_rtx_MEM (QImode, plus_constant (Pmode, base,\n+\t\t\t\t\t\t\t\toffset)),\n \t\t\t    gen_lowpart (QImode, outval)));\n       emit_insn (gen_lshrsi3 (scratch,\n \t\t\t      gen_rtx_SUBREG (SImode, outval, 0),\n \t\t\t      GEN_INT (8)));\n       emit_insn (gen_movqi (gen_rtx_MEM (QImode,\n-\t\t\t\t\t plus_constant (base, offset + 1)),\n+\t\t\t\t\t plus_constant (Pmode, base,\n+\t\t\t\t\t\t\toffset + 1)),\n \t\t\t    gen_lowpart (QImode, scratch)));\n     }\n }\n@@ -13814,7 +13819,8 @@ arm_reorg (void)\n \tif (GET_CODE (this_fix->insn) != BARRIER)\n \t  {\n \t    rtx addr\n-\t      = plus_constant (gen_rtx_LABEL_REF (VOIDmode,\n+\t      = plus_constant (Pmode,\n+\t\t\t       gen_rtx_LABEL_REF (VOIDmode,\n \t\t\t\t\t\t  minipool_vector_label),\n \t\t\t       this_fix->minipool->offset);\n \t    *this_fix->loc = gen_rtx_MEM (this_fix->mode, addr);\n@@ -14025,15 +14031,15 @@ vfp_emit_fstmd (int base_reg, int count)\n \t\t    gen_rtx_PRE_MODIFY (Pmode,\n \t\t\t\t\tstack_pointer_rtx,\n \t\t\t\t\tplus_constant\n-\t\t\t\t\t(stack_pointer_rtx,\n+\t\t\t\t\t(Pmode, stack_pointer_rtx,\n \t\t\t\t\t - (count * 8)))\n \t\t    ),\n \t\t   gen_rtx_UNSPEC (BLKmode,\n \t\t\t\t   gen_rtvec (1, reg),\n \t\t\t\t   UNSPEC_PUSH_MULT));\n \n   tmp = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t     plus_constant (stack_pointer_rtx, -(count * 8)));\n+\t\t     plus_constant (Pmode, stack_pointer_rtx, -(count * 8)));\n   RTX_FRAME_RELATED_P (tmp) = 1;\n   XVECEXP (dwarf, 0, 0) = tmp;\n \n@@ -14051,7 +14057,8 @@ vfp_emit_fstmd (int base_reg, int count)\n \n       tmp = gen_rtx_SET (VOIDmode,\n \t\t\t gen_frame_mem (DFmode,\n-\t\t\t\t\tplus_constant (stack_pointer_rtx,\n+\t\t\t\t\tplus_constant (Pmode,\n+\t\t\t\t\t\t       stack_pointer_rtx,\n \t\t\t\t\t\t       i * 8)),\n \t\t\t reg);\n       RTX_FRAME_RELATED_P (tmp) = 1;\n@@ -16538,7 +16545,7 @@ emit_multi_reg_push (unsigned long mask)\n \t\t\t    gen_rtx_PRE_MODIFY (Pmode,\n \t\t\t\t\t\tstack_pointer_rtx,\n \t\t\t\t\t\tplus_constant\n-\t\t\t\t\t\t(stack_pointer_rtx,\n+\t\t\t\t\t\t(Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t -4 * num_regs))\n \t\t\t    ),\n \t\t\t   gen_rtx_UNSPEC (BLKmode,\n@@ -16573,7 +16580,7 @@ emit_multi_reg_push (unsigned long mask)\n \t\t= gen_rtx_SET (VOIDmode,\n \t\t\t       gen_frame_mem\n \t\t\t       (SImode,\n-\t\t\t\tplus_constant (stack_pointer_rtx,\n+\t\t\t\tplus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t       4 * j)),\n \t\t\t       reg);\n \t      RTX_FRAME_RELATED_P (tmp) = 1;\n@@ -16588,7 +16595,7 @@ emit_multi_reg_push (unsigned long mask)\n \n   tmp = gen_rtx_SET (VOIDmode,\n \t\t     stack_pointer_rtx,\n-\t\t     plus_constant (stack_pointer_rtx, -4 * num_regs));\n+\t\t     plus_constant (Pmode, stack_pointer_rtx, -4 * num_regs));\n   RTX_FRAME_RELATED_P (tmp) = 1;\n   XVECEXP (dwarf, 0, 0) = tmp;\n \n@@ -16631,7 +16638,7 @@ emit_sfm (int base_reg, int count)\n \t\t    gen_rtx_PRE_MODIFY (Pmode,\n \t\t\t\t\tstack_pointer_rtx,\n \t\t\t\t\tplus_constant\n-\t\t\t\t\t(stack_pointer_rtx,\n+\t\t\t\t\t(Pmode, stack_pointer_rtx,\n \t\t\t\t\t -12 * count))\n \t\t    ),\n \t\t   gen_rtx_UNSPEC (BLKmode,\n@@ -16649,7 +16656,8 @@ emit_sfm (int base_reg, int count)\n \n       tmp = gen_rtx_SET (VOIDmode,\n \t\t\t gen_frame_mem (XFmode,\n-\t\t\t\t\tplus_constant (stack_pointer_rtx,\n+\t\t\t\t\tplus_constant (Pmode,\n+\t\t\t\t\t\t       stack_pointer_rtx,\n \t\t\t\t\t\t       i * 12)),\n \t\t\t reg);\n       RTX_FRAME_RELATED_P (tmp) = 1;\n@@ -16658,7 +16666,7 @@ emit_sfm (int base_reg, int count)\n \n   tmp = gen_rtx_SET (VOIDmode,\n \t\t     stack_pointer_rtx,\n-\t\t     plus_constant (stack_pointer_rtx, -12 * count));\n+\t\t     plus_constant (Pmode, stack_pointer_rtx, -12 * count));\n \n   RTX_FRAME_RELATED_P (tmp) = 1;\n   XVECEXP (dwarf, 0, 0) = tmp;\n@@ -17130,7 +17138,7 @@ thumb_set_frame_pointer (arm_stack_offsets *offsets)\n \t\t\t\t\tstack_pointer_rtx));\n \t}\n       dwarf = gen_rtx_SET (VOIDmode, hard_frame_pointer_rtx,\n-\t\t\t   plus_constant (stack_pointer_rtx, amount));\n+\t\t\t   plus_constant (Pmode, stack_pointer_rtx, amount));\n       RTX_FRAME_RELATED_P (dwarf) = 1;\n       add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n     }\n@@ -17261,7 +17269,7 @@ arm_expand_prologue (void)\n \n \t      /* Just tell the dwarf backend that we adjusted SP.  */\n \t      dwarf = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t  -fp_offset));\n \t      RTX_FRAME_RELATED_P (insn) = 1;\n \t      add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n@@ -17289,7 +17297,8 @@ arm_expand_prologue (void)\n \t}\n \n       insn = emit_set_insn (ip_rtx,\n-\t\t\t    plus_constant (stack_pointer_rtx, fp_offset));\n+\t\t\t    plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t   fp_offset));\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n@@ -17318,7 +17327,7 @@ arm_expand_prologue (void)\n     {\n       rtx lr = gen_rtx_REG (SImode, LR_REGNUM);\n \n-      emit_set_insn (lr, plus_constant (lr, -4));\n+      emit_set_insn (lr, plus_constant (SImode, lr, -4));\n     }\n \n   if (live_regs_mask)\n@@ -17368,7 +17377,7 @@ arm_expand_prologue (void)\n \t\tinsn = gen_rtx_REG (SImode, 3);\n \t      else /* if (crtl->args.pretend_args_size == 0) */\n \t\t{\n-\t\t  insn = plus_constant (hard_frame_pointer_rtx, 4);\n+\t\t  insn = plus_constant (Pmode, hard_frame_pointer_rtx, 4);\n \t\t  insn = gen_frame_mem (SImode, insn);\n \t\t}\n \t      emit_set_insn (ip_rtx, insn);\n@@ -21595,7 +21604,7 @@ thumb1_emit_multi_reg_push (unsigned long mask, unsigned long real_regs)\n       par[i] = tmp;\n     }\n \n-  tmp = plus_constant (stack_pointer_rtx, -4 * i);\n+  tmp = plus_constant (Pmode, stack_pointer_rtx, -4 * i);\n   tmp = gen_rtx_PRE_MODIFY (Pmode, stack_pointer_rtx, tmp);\n   tmp = gen_frame_mem (BLKmode, tmp);\n   tmp = gen_rtx_SET (VOIDmode, tmp, par[0]);\n@@ -21605,7 +21614,7 @@ thumb1_emit_multi_reg_push (unsigned long mask, unsigned long real_regs)\n   insn = emit_insn (tmp);\n \n   /* Always build the stack adjustment note for unwind info.  */\n-  tmp = plus_constant (stack_pointer_rtx, -4 * i);\n+  tmp = plus_constant (Pmode, stack_pointer_rtx, -4 * i);\n   tmp = gen_rtx_SET (VOIDmode, stack_pointer_rtx, tmp);\n   par[0] = tmp;\n \n@@ -21615,7 +21624,7 @@ thumb1_emit_multi_reg_push (unsigned long mask, unsigned long real_regs)\n       regno = ctz_hwi (real_regs);\n       reg = gen_rtx_REG (SImode, regno);\n \n-      tmp = plus_constant (stack_pointer_rtx, j * 4);\n+      tmp = plus_constant (Pmode, stack_pointer_rtx, j * 4);\n       tmp = gen_frame_mem (SImode, tmp);\n       tmp = gen_rtx_SET (VOIDmode, tmp, reg);\n       RTX_FRAME_RELATED_P (tmp) = 1;\n@@ -22559,7 +22568,7 @@ thumb1_expand_prologue (void)\n       x = GEN_INT (offset + 16 + crtl->args.pretend_args_size);\n       emit_insn (gen_addsi3 (work_reg, stack_pointer_rtx, x));\n \n-      x = plus_constant (stack_pointer_rtx, offset + 4);\n+      x = plus_constant (Pmode, stack_pointer_rtx, offset + 4);\n       x = gen_frame_mem (SImode, x);\n       emit_move_insn (x, work_reg);\n \n@@ -22573,36 +22582,36 @@ thumb1_expand_prologue (void)\n \t  x = gen_rtx_REG (SImode, PC_REGNUM);\n \t  emit_move_insn (work_reg, x);\n \n-\t  x = plus_constant (stack_pointer_rtx, offset + 12);\n+\t  x = plus_constant (Pmode, stack_pointer_rtx, offset + 12);\n \t  x = gen_frame_mem (SImode, x);\n \t  emit_move_insn (x, work_reg);\n \n \t  emit_move_insn (work_reg, arm_hfp_rtx);\n \n-\t  x = plus_constant (stack_pointer_rtx, offset);\n+\t  x = plus_constant (Pmode, stack_pointer_rtx, offset);\n \t  x = gen_frame_mem (SImode, x);\n \t  emit_move_insn (x, work_reg);\n \t}\n       else\n \t{\n \t  emit_move_insn (work_reg, arm_hfp_rtx);\n \n-\t  x = plus_constant (stack_pointer_rtx, offset);\n+\t  x = plus_constant (Pmode, stack_pointer_rtx, offset);\n \t  x = gen_frame_mem (SImode, x);\n \t  emit_move_insn (x, work_reg);\n \n \t  x = gen_rtx_REG (SImode, PC_REGNUM);\n \t  emit_move_insn (work_reg, x);\n \n-\t  x = plus_constant (stack_pointer_rtx, offset + 12);\n+\t  x = plus_constant (Pmode, stack_pointer_rtx, offset + 12);\n \t  x = gen_frame_mem (SImode, x);\n \t  emit_move_insn (x, work_reg);\n \t}\n \n       x = gen_rtx_REG (SImode, LR_REGNUM);\n       emit_move_insn (work_reg, x);\n \n-      x = plus_constant (stack_pointer_rtx, offset + 8);\n+      x = plus_constant (Pmode, stack_pointer_rtx, offset + 8);\n       x = gen_frame_mem (SImode, x);\n       emit_move_insn (x, work_reg);\n \n@@ -22736,7 +22745,7 @@ thumb1_expand_prologue (void)\n \t\t\t\t\tstack_pointer_rtx, reg));\n \n \t  dwarf = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t       plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t      -amount));\n \t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n@@ -23087,8 +23096,10 @@ thumb_expand_movmemqi (rtx *operands)\n     {\n       rtx reg = gen_reg_rtx (HImode);\n       emit_insn (gen_movhi (reg, gen_rtx_MEM (HImode,\n-\t\t\t\t\t      plus_constant (in, offset))));\n-      emit_insn (gen_movhi (gen_rtx_MEM (HImode, plus_constant (out, offset)),\n+\t\t\t\t\t      plus_constant (Pmode, in,\n+\t\t\t\t\t\t\t     offset))));\n+      emit_insn (gen_movhi (gen_rtx_MEM (HImode, plus_constant (Pmode, out,\n+\t\t\t\t\t\t\t\toffset)),\n \t\t\t    reg));\n       len -= 2;\n       offset += 2;\n@@ -23098,8 +23109,10 @@ thumb_expand_movmemqi (rtx *operands)\n     {\n       rtx reg = gen_reg_rtx (QImode);\n       emit_insn (gen_movqi (reg, gen_rtx_MEM (QImode,\n-\t\t\t\t\t      plus_constant (in, offset))));\n-      emit_insn (gen_movqi (gen_rtx_MEM (QImode, plus_constant (out, offset)),\n+\t\t\t\t\t      plus_constant (Pmode, in,\n+\t\t\t\t\t\t\t     offset))));\n+      emit_insn (gen_movqi (gen_rtx_MEM (QImode, plus_constant (Pmode, out,\n+\t\t\t\t\t\t\t\toffset)),\n \t\t\t    reg));\n     }\n }\n@@ -23884,7 +23897,7 @@ arm_set_return_address (rtx source, rtx scratch)\n   else\n     {\n       if (frame_pointer_needed)\n-\taddr = plus_constant(hard_frame_pointer_rtx, -4);\n+\taddr = plus_constant (Pmode, hard_frame_pointer_rtx, -4);\n       else\n \t{\n \t  /* LR will be the first saved register.  */\n@@ -23901,7 +23914,7 @@ arm_set_return_address (rtx source, rtx scratch)\n \t  else\n \t    addr = stack_pointer_rtx;\n \n-\t  addr = plus_constant (addr, delta);\n+\t  addr = plus_constant (Pmode, addr, delta);\n \t}\n       emit_move_insn (gen_frame_mem (Pmode, addr), source);\n     }\n@@ -23953,7 +23966,7 @@ thumb_set_return_address (rtx source, rtx scratch)\n \t  addr = scratch;\n \t}\n       else\n-\taddr = plus_constant (addr, delta);\n+\taddr = plus_constant (Pmode, addr, delta);\n \n       emit_move_insn (gen_frame_mem (Pmode, addr), source);\n     }"}, {"sha": "b1ad3bf34eb7e4f4701499082e13f8ce24b08abb", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -4929,7 +4929,8 @@\n     rtx addr = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n \n     mem1 = change_address (operands[1], QImode, addr);\n-    mem2 = change_address (operands[1], QImode, plus_constant (addr, 1));\n+    mem2 = change_address (operands[1], QImode,\n+\t\t\t   plus_constant (Pmode, addr, 1));\n     operands[0] = gen_lowpart (SImode, operands[0]);\n     operands[1] = mem1;\n     operands[2] = gen_reg_rtx (SImode);\n@@ -5445,7 +5446,7 @@\n       return thumb_load_double_from_address (operands);\n     case 6:\n       operands[2] = gen_rtx_MEM (SImode,\n-\t\t\t     plus_constant (XEXP (operands[0], 0), 4));\n+\t\t\t     plus_constant (Pmode, XEXP (operands[0], 0), 4));\n       output_asm_insn (\\\"str\\\\t%1, %0\\;str\\\\t%H1, %2\\\", operands);\n       return \\\"\\\";\n     case 7:\n@@ -6223,7 +6224,8 @@\n     rtx addr = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n \n     mem1 = change_address (operands[1], QImode, addr);\n-    mem2 = change_address (operands[1], QImode, plus_constant (addr, 1));\n+    mem2 = change_address (operands[1], QImode,\n+\t\t\t   plus_constant (Pmode, addr, 1));\n     operands[0] = gen_lowpart (SImode, operands[0]);\n     operands[1] = mem1;\n     operands[2] = gen_reg_rtx (SImode);\n@@ -6746,7 +6748,8 @@\n       return thumb_load_double_from_address (operands);\n     case 4:\n       operands[2] = gen_rtx_MEM (SImode,\n-\t\t\t\t plus_constant (XEXP (operands[0], 0), 4));\n+\t\t\t\t plus_constant (Pmode,\n+\t\t\t\t\t\tXEXP (operands[0], 0), 4));\n       output_asm_insn (\\\"str\\\\t%1, %0\\;str\\\\t%H1, %2\\\", operands);\n       return \\\"\\\";\n     case 5:\n@@ -8756,7 +8759,7 @@\n \trtx reg = XEXP (XVECEXP (par, 0, i), 0);\n \n \tif (size != 0)\n-\t  emit_move_insn (addr, plus_constant (addr, size));\n+\t  emit_move_insn (addr, plus_constant (Pmode, addr, size));\n \n \tmem = change_address (mem, GET_MODE (reg), NULL);\n \tif (REGNO (reg) == R0_REGNUM)\n@@ -8803,7 +8806,7 @@\n \trtx reg = SET_DEST (XVECEXP (operands[1], 0, i));\n \n \tif (size != 0)\n-\t  emit_move_insn (addr, plus_constant (addr, size));\n+\t  emit_move_insn (addr, plus_constant (Pmode, addr, size));\n \n \tmem = change_address (mem, GET_MODE (reg), NULL);\n \tif (REGNO (reg) == R0_REGNUM)"}, {"sha": "d52ab156c1804b10112afc5f3993ecd059411bb1", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -770,7 +770,7 @@ avr_incoming_return_addr_rtx (void)\n {\n   /* The return address is at the top of the stack.  Note that the push\n      was via post-decrement, which means the actual address is off by one.  */\n-  return gen_frame_mem (HImode, plus_constant (stack_pointer_rtx, 1));\n+  return gen_frame_mem (HImode, plus_constant (Pmode, stack_pointer_rtx, 1));\n }\n \n /*  Helper for expand_prologue.  Emit a push of a byte register.  */\n@@ -866,8 +866,8 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)\n                     gen_rtx_SET (VOIDmode, (frame_pointer_needed\n                                             ? frame_pointer_rtx\n                                             : stack_pointer_rtx),\n-                                 plus_constant (stack_pointer_rtx,\n-                                                -(size + live_seq))));\n+                                 plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t-(size + live_seq))));\n \n       /* Note that live_seq always contains r28+r29, but the other\n          registers to be saved are all below 18.  */\n@@ -880,7 +880,8 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)\n         {\n           rtx m, r;\n \n-          m = gen_rtx_MEM (QImode, plus_constant (stack_pointer_rtx, offset));\n+          m = gen_rtx_MEM (QImode, plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t  offset));\n           r = gen_rtx_REG (QImode, reg);\n           add_reg_note (insn, REG_CFA_OFFSET, gen_rtx_SET (VOIDmode, m, r));\n         }\n@@ -995,13 +996,14 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)\n                             gen_rtx_SET (VOIDmode, fp, stack_pointer_rtx));\n             }\n \n-          insn = emit_move_insn (my_fp, plus_constant (my_fp, -size));\n+          insn = emit_move_insn (my_fp, plus_constant (Pmode, my_fp, -size));\n           if (frame_pointer_needed)\n             {\n               RTX_FRAME_RELATED_P (insn) = 1;\n               add_reg_note (insn, REG_CFA_ADJUST_CFA,\n                             gen_rtx_SET (VOIDmode, fp,\n-                                         plus_constant (fp, -size_cfa)));\n+                                         plus_constant (Pmode, fp,\n+\t\t\t\t\t\t\t-size_cfa)));\n             }\n           \n           /* Copy to stack pointer.  Note that since we've already\n@@ -1028,8 +1030,9 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)\n               RTX_FRAME_RELATED_P (insn) = 1;\n               add_reg_note (insn, REG_CFA_ADJUST_CFA,\n                             gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-                                         plus_constant (stack_pointer_rtx,\n-                                                        -size_cfa)));\n+                                         plus_constant (Pmode,\n+\t\t\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\t\t\t-size_cfa)));\n             }\n           \n           fp_plus_insns = get_insns ();\n@@ -1047,12 +1050,14 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)\n               start_sequence ();\n \n               insn = emit_move_insn (stack_pointer_rtx,\n-                                     plus_constant (stack_pointer_rtx, -size));\n+                                     plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t    -size));\n               RTX_FRAME_RELATED_P (insn) = 1;\n               add_reg_note (insn, REG_CFA_ADJUST_CFA,\n                             gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-                                         plus_constant (stack_pointer_rtx,\n-                                                        -size_cfa)));\n+                                         plus_constant (Pmode,\n+\t\t\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\t\t\t-size_cfa)));\n               if (frame_pointer_needed)\n                 {\n                   insn = emit_move_insn (fp, stack_pointer_rtx);\n@@ -1273,7 +1278,7 @@ expand_epilogue (bool sibcall_p)\n       if (size)\n         {\n           emit_move_insn (frame_pointer_rtx,\n-                          plus_constant (frame_pointer_rtx, size));\n+                          plus_constant (Pmode, frame_pointer_rtx, size));\n         }\n         \n       emit_insn (gen_epilogue_restores (gen_int_mode (live_seq, HImode)));\n@@ -1319,7 +1324,7 @@ expand_epilogue (bool sibcall_p)\n       if (!frame_pointer_needed)\n         emit_move_insn (fp, stack_pointer_rtx);\n \n-      emit_move_insn (my_fp, plus_constant (my_fp, size));\n+      emit_move_insn (my_fp, plus_constant (Pmode, my_fp, size));\n \n       /* Copy to stack pointer.  */\n \n@@ -1344,7 +1349,7 @@ expand_epilogue (bool sibcall_p)\n           start_sequence ();\n \n           emit_move_insn (stack_pointer_rtx,\n-                          plus_constant (stack_pointer_rtx, size));\n+                          plus_constant (Pmode, stack_pointer_rtx, size));\n \n           sp_plus_insns = get_insns ();\n           end_sequence ();\n@@ -6594,7 +6599,7 @@ avr_const_address_lo16 (rtx x)\n           const char *name = XSTR (XEXP (XEXP (x, 0), 0), 0);\n           \n           lo16 = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n-          lo16 = gen_rtx_CONST (Pmode, plus_constant (lo16, offset));\n+          lo16 = gen_rtx_CONST (Pmode, plus_constant (Pmode, lo16, offset));\n           \n           return lo16;\n         }"}, {"sha": "1342c568fd03e101a5783a3dc784bb5cc28258f2", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -580,7 +580,8 @@ setup_incoming_varargs (cumulative_args_t cum,\n   for (i = get_cumulative_args (cum)->words + 1; i < max_arg_registers; i++)\n     {\n       mem = gen_rtx_MEM (Pmode,\n-\t\t\t plus_constant (arg_pointer_rtx, (i * UNITS_PER_WORD)));\n+\t\t\t plus_constant (Pmode, arg_pointer_rtx,\n+\t\t\t\t\t(i * UNITS_PER_WORD)));\n       emit_move_insn (mem, gen_rtx_REG (Pmode, i));\n     }\n \n@@ -1050,7 +1051,8 @@ bfin_load_pic_reg (rtx dest)\n     return pic_offset_table_rtx;\n       \n   if (global_options_set.x_bfin_library_id)\n-    addr = plus_constant (pic_offset_table_rtx, -4 - bfin_library_id * 4);\n+    addr = plus_constant (Pmode, pic_offset_table_rtx,\n+\t\t\t   -4 - bfin_library_id * 4);\n   else\n     addr = gen_rtx_PLUS (Pmode, pic_offset_table_rtx,\n \t\t\t gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n@@ -1111,7 +1113,7 @@ bfin_expand_prologue (void)\n \t    }\n \t  else\n \t    {\n-\t      rtx limit = plus_constant (lim, offset);\n+\t      rtx limit = plus_constant (Pmode, lim, offset);\n \t      emit_move_insn (p2reg, limit);\n \t      lim = p2reg;\n \t    }\n@@ -1883,7 +1885,7 @@ bfin_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n \n   if (TARGET_FDPIC)\n     {\n-      rtx a = force_reg (Pmode, plus_constant (XEXP (m_tramp, 0), 8));\n+      rtx a = force_reg (Pmode, plus_constant (Pmode, XEXP (m_tramp, 0), 8));\n       mem = adjust_address (m_tramp, Pmode, 0);\n       emit_move_insn (mem, a);\n       i = 8;\n@@ -2077,7 +2079,7 @@ bfin_expand_call (rtx retval, rtx fnaddr, rtx callarg1, rtx cookie, int sibcall)\n \n \t  picreg = gen_reg_rtx (SImode);\n \t  emit_insn (gen_load_funcdescsi (picreg,\n-\t\t\t\t\t  plus_constant (addr, 4)));\n+\t\t\t\t\t  plus_constant (Pmode, addr, 4)));\n \t}\n \n       nelts++;\n@@ -4942,7 +4944,8 @@ bfin_output_mi_thunk (FILE *file ATTRIBUTE_UNUSED,\n       output_asm_insn (\"%2 = r0; %2 = [%2];\", xops);\n \n       /* Adjust the this parameter.  */\n-      xops[0] = gen_rtx_MEM (Pmode, plus_constant (p2tmp, vcall_offset));\n+      xops[0] = gen_rtx_MEM (Pmode, plus_constant (Pmode, p2tmp,\n+\t\t\t\t\t\t   vcall_offset));\n       if (!memory_operand (xops[0], Pmode))\n \t{\n \t  rtx tmp2 = gen_rtx_REG (Pmode, REG_P1);"}, {"sha": "03759bffdeaadfdd6bfa07b28236a8c5593eadb3", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -784,7 +784,8 @@ typedef struct {\n #define EH_RETURN_DATA_REGNO(N)\t((N) < 2 ? (N) : INVALID_REGNUM)\n #define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, REG_P2)\n #define EH_RETURN_HANDLER_RTX \\\n-    gen_frame_mem (Pmode, plus_constant (frame_pointer_rtx, UNITS_PER_WORD))\n+  gen_frame_mem (Pmode, plus_constant (Pmode, frame_pointer_rtx, \\\n+\t\t\t\t       UNITS_PER_WORD))\n \n /* Addressing Modes */\n "}, {"sha": "8a368892bb21c85ddf380ba3ca161468c1c73d66", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -735,7 +735,8 @@ c6x_initialize_trampoline (rtx tramp, tree fndecl, rtx cxt)\n   tramp = XEXP (tramp, 0);\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__gnu_clear_cache\"),\n \t\t     LCT_NORMAL, VOIDmode, 2, tramp, Pmode,\n-\t\t     plus_constant (tramp, TRAMPOLINE_SIZE), Pmode);\n+\t\t     plus_constant (Pmode, tramp, TRAMPOLINE_SIZE),\n+\t\t     Pmode);\n #endif\n }\n \f\n@@ -822,7 +823,8 @@ c6x_output_mi_thunk (FILE *file ATTRIBUTE_UNUSED,\n       output_asm_insn (\"ldw .d1t1 %3, %2\", xops);\n \n       /* Adjust the this parameter.  */\n-      xops[0] = gen_rtx_MEM (Pmode, plus_constant (a0tmp, vcall_offset));\n+      xops[0] = gen_rtx_MEM (Pmode, plus_constant (Pmode, a0tmp,\n+\t\t\t\t\t\t   vcall_offset));\n       if (!memory_operand (xops[0], Pmode))\n \t{\n \t  rtx tmp2 = gen_rtx_REG (Pmode, REG_A1);"}, {"sha": "852c808f571b9f6b10fc35eefc31169f483624e2", "filename": "gcc/config/cr16/cr16.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fcr16%2Fcr16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fcr16%2Fcr16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1851,7 +1851,7 @@ cr16_create_dwarf_for_multi_push (rtx insn)\n \t      tmp = gen_rtx_SET (VOIDmode,\n \t\t\t\t gen_frame_mem (mode,\n \t\t\t\t\t\tplus_constant\n-\t\t\t\t\t\t(stack_pointer_rtx,\n+\t\t\t\t\t\t(Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t total_push_bytes - offset)),\n \t\t\t\t reg);\n \t      RTX_FRAME_RELATED_P (tmp) = 1;"}, {"sha": "54794e1fd272e3b975ebfc3fe41f287185ec933e", "filename": "gcc/config/cr16/cr16.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fcr16%2Fcr16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fcr16%2Fcr16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.h?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -238,7 +238,7 @@ while (0)\n #define EH_RETURN_STACKADJ_RTX \t\tgen_rtx_REG (Pmode, 4)\n \n #define EH_RETURN_HANDLER_RTX \\\n-  gen_rtx_MEM (Pmode, plus_constant (arg_pointer_rtx, -4))\n+  gen_rtx_MEM (Pmode, plus_constant (Pmode, arg_pointer_rtx, -4))\n \n #define INCOMING_RETURN_ADDR_RTX\tgen_rtx_RA\n "}, {"sha": "40efd233ebfd3aa832d4629a89043ed872e3ecea", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1181,7 +1181,7 @@ cris_return_addr_rtx (int count, rtx frameaddr ATTRIBUTE_UNUSED)\n      present).  Apparently we can't eliminate from the frame-pointer in\n      that direction, so use the incoming args (maybe pretended) pointer.  */\n   return count == 0\n-    ? gen_rtx_MEM (Pmode, plus_constant (virtual_incoming_args_rtx, -4))\n+    ? gen_rtx_MEM (Pmode, plus_constant (Pmode, virtual_incoming_args_rtx, -4))\n     : NULL_RTX;\n }\n \n@@ -2815,14 +2815,14 @@ cris_split_movdx (rtx *operands)\n \t\t\t  operand_subword (dest, reverse, TRUE, mode),\n \t\t\t  change_address\n \t\t\t  (src, SImode,\n-\t\t\t   plus_constant (addr,\n+\t\t\t   plus_constant (Pmode, addr,\n \t\t\t\t\t  reverse * UNITS_PER_WORD))));\n \t      emit_insn (gen_rtx_SET\n \t\t\t (VOIDmode,\n \t\t\t  operand_subword (dest, ! reverse, TRUE, mode),\n \t\t\t  change_address\n \t\t\t  (src, SImode,\n-\t\t\t   plus_constant (addr,\n+\t\t\t   plus_constant (Pmode, addr,\n \t\t\t\t\t  (! reverse) *\n \t\t\t\t\t  UNITS_PER_WORD))));\n \t    }\n@@ -2882,7 +2882,7 @@ cris_split_movdx (rtx *operands)\n \t  emit_insn (gen_rtx_SET\n \t\t     (VOIDmode,\n \t\t      change_address (dest, SImode,\n-\t\t\t\t      plus_constant (addr,\n+\t\t\t\t      plus_constant (Pmode, addr,\n \t\t\t\t\t\t     UNITS_PER_WORD)),\n \t\t      operand_subword (src, 1, TRUE, mode)));\n \t}\n@@ -2954,7 +2954,8 @@ cris_expand_prologue (void)\n \t{\n \t  insn = emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\t\t stack_pointer_rtx,\n-\t\t\t\t\t plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t plus_constant (Pmode,\n+\t\t\t\t\t\t\tstack_pointer_rtx,\n \t\t\t\t\t\t\t-4)));\n \t  /* FIXME: When dwarf2 frame output and unless asynchronous\n \t     exceptions, make dwarf2 bundle together all stack\n@@ -2982,7 +2983,7 @@ cris_expand_prologue (void)\n     {\n       insn = emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\t     stack_pointer_rtx,\n-\t\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t     plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t    -4 - pretend)));\n       pretend = 0;\n       RTX_FRAME_RELATED_P (insn) = 1;\n@@ -2999,7 +3000,7 @@ cris_expand_prologue (void)\n     {\n       insn = emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\t     stack_pointer_rtx,\n-\t\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t     plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t    -4 - pretend)));\n       pretend = 0;\n       RTX_FRAME_RELATED_P (insn) = 1;\n@@ -3052,7 +3053,7 @@ cris_expand_prologue (void)\n \t\t    {\n \t\t      mem\n \t\t\t= gen_rtx_MEM (SImode,\n-\t\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t       plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t      -(n_saved * 4 + size)));\n \t\t      set_mem_alias_set (mem, get_frame_alias_set ());\n \t\t      insn\n@@ -3065,7 +3066,7 @@ cris_expand_prologue (void)\n \t\t      insn\n \t\t\t= gen_rtx_SET (VOIDmode,\n \t\t\t\t       stack_pointer_rtx,\n-\t\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t       plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t      -(n_saved * 4 + size)));\n \t\t      insn = emit_insn (insn);\n \t\t      RTX_FRAME_RELATED_P (insn) = 1;\n@@ -3083,7 +3084,8 @@ cris_expand_prologue (void)\n \n \t      insn = emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\t\t     stack_pointer_rtx,\n-\t\t\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t     plus_constant (Pmode,\n+\t\t\t\t\t\t\t    stack_pointer_rtx,\n \t\t\t\t\t\t\t    -4 - size)));\n \t      RTX_FRAME_RELATED_P (insn) = 1;\n \n@@ -3113,7 +3115,7 @@ cris_expand_prologue (void)\n \t{\n \t  mem\n \t    = gen_rtx_MEM (SImode,\n-\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t  -(n_saved * 4 + size)));\n \t  set_mem_alias_set (mem, get_frame_alias_set ());\n \t  insn = cris_emit_movem_store (mem, GEN_INT (n_saved),\n@@ -3124,7 +3126,7 @@ cris_expand_prologue (void)\n \t  insn\n \t    = gen_rtx_SET (VOIDmode,\n \t\t\t   stack_pointer_rtx,\n-\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t  -(n_saved * 4 + size)));\n \t  insn = emit_insn (insn);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n@@ -3140,7 +3142,8 @@ cris_expand_prologue (void)\n \t{\n \t  insn = emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\t\t stack_pointer_rtx,\n-\t\t\t\t\t plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t plus_constant (Pmode,\n+\t\t\t\t\t\t\tstack_pointer_rtx,\n \t\t\t\t\t\t\t-cfoa_size)));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t  framesize += cfoa_size;\n@@ -3150,7 +3153,8 @@ cris_expand_prologue (void)\n     {\n       insn = emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\t     stack_pointer_rtx,\n-\t\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t     plus_constant (Pmode,\n+\t\t\t\t\t\t    stack_pointer_rtx,\n \t\t\t\t\t\t    -(cfoa_size + size))));\n       RTX_FRAME_RELATED_P (insn) = 1;\n       framesize += size + cfoa_size;\n@@ -3248,7 +3252,7 @@ cris_expand_epilogue (void)\n \t       the saved registers.  We have to adjust for that.  */\n \t    emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\t    stack_pointer_rtx,\n-\t\t\t\t    plus_constant (stack_pointer_rtx,\n+\t\t\t\t    plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t   argspace_offset)));\n \t    /* Make sure we only do this once.  */\n \t    argspace_offset = 0;\n@@ -3274,7 +3278,7 @@ cris_expand_epilogue (void)\n \t{\n \t  emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t  plus_constant (stack_pointer_rtx,\n+\t\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t argspace_offset)));\n \t  argspace_offset = 0;\n \t}\n@@ -3333,7 +3337,7 @@ cris_expand_epilogue (void)\n \n       emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t      stack_pointer_rtx,\n-\t\t\t      plus_constant (stack_pointer_rtx, size)));\n+\t\t\t      plus_constant (Pmode, stack_pointer_rtx, size)));\n     }\n \n   /* If this function has no pushed register parameters\n@@ -3395,7 +3399,8 @@ cris_expand_epilogue (void)\n \n       emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t      stack_pointer_rtx,\n-\t\t\t      plus_constant (stack_pointer_rtx, pretend)));\n+\t\t\t      plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t     pretend)));\n     }\n \n   /* Perform the \"physical\" unwinding that the EH machinery calculated.  */\n@@ -3443,7 +3448,8 @@ cris_gen_movem_load (rtx src, rtx nregs_rtx, int nprefix)\n   if (GET_CODE (XEXP (src, 0)) == POST_INC)\n     {\n       RTVEC_ELT (vec, nprefix + 1)\n-\t= gen_rtx_SET (VOIDmode, srcreg, plus_constant (srcreg, nregs * 4));\n+\t= gen_rtx_SET (VOIDmode, srcreg,\n+\t\t       plus_constant (Pmode, srcreg, nregs * 4));\n       eltno++;\n     }\n \n@@ -3514,7 +3520,8 @@ cris_emit_movem_store (rtx dest, rtx nregs_rtx, int increment,\n \n       RTVEC_ELT (vec, 0) = mov;\n       RTVEC_ELT (vec, 1) = gen_rtx_SET (VOIDmode, destreg,\n-\t\t\t\t\tplus_constant (destreg, increment));\n+\t\t\t\t\tplus_constant (Pmode, destreg,\n+\t\t\t\t\t\t       increment));\n       if (frame_related)\n \t{\n \t  RTX_FRAME_RELATED_P (mov) = 1;\n@@ -3527,7 +3534,7 @@ cris_emit_movem_store (rtx dest, rtx nregs_rtx, int increment,\n       RTVEC_ELT (vec, 0)\n \t= gen_rtx_SET (VOIDmode,\n \t\t       replace_equiv_address (dest,\n-\t\t\t\t\t      plus_constant (destreg,\n+\t\t\t\t\t      plus_constant (Pmode, destreg,\n \t\t\t\t\t\t\t     increment)),\n \t\t       gen_rtx_REG (SImode, regno));\n       regno += regno_inc;\n@@ -3542,7 +3549,7 @@ cris_emit_movem_store (rtx dest, rtx nregs_rtx, int increment,\n \t{\n \t  RTVEC_ELT (vec, 1)\n \t    = gen_rtx_SET (VOIDmode, destreg,\n-\t\t\t   plus_constant (destreg,\n+\t\t\t   plus_constant (Pmode, destreg,\n \t\t\t\t\t  increment != 0\n \t\t\t\t\t  ? increment : nregs * 4));\n \t  eltno++;\n@@ -4143,7 +4150,7 @@ cris_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n   if (TARGET_V32)\n     {\n       mem = adjust_address (m_tramp, SImode, 6);\n-      emit_move_insn (mem, plus_constant (tramp, 38));\n+      emit_move_insn (mem, plus_constant (Pmode, tramp, 38));\n       mem = adjust_address (m_tramp, SImode, 22);\n       emit_move_insn (mem, chain_value);\n       mem = adjust_address (m_tramp, SImode, 28);"}, {"sha": "b4ead76f38b339b4f8c74dcafbe6dbfb8e5ddd0e", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -976,7 +976,7 @@\n \t\t    tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym),\n \t\t\t\t\t  CRIS_UNSPEC_PCREL);\n \t\t    if (offs != 0)\n-\t\t      tem = plus_constant (tem, offs);\n+\t\t      tem = plus_constant (Pmode, tem, offs);\n \t\t    rm = rn;\n \t\t    emit_move_insn (rm, gen_rtx_CONST (Pmode, tem));\n \t\t  }\n@@ -988,7 +988,7 @@\n \t\t    tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym),\n \t\t\t\t\t  CRIS_UNSPEC_GOTREL);\n \t\t    if (offs != 0)\n-\t\t      tem = plus_constant (tem, offs);\n+\t\t      tem = plus_constant (Pmode, tem, offs);\n \t\t    rm = gen_reg_rtx (Pmode);\n \t\t    emit_move_insn (rm, gen_rtx_CONST (Pmode, tem));\n \t\t    if (expand_binop (Pmode, add_optab, rm, pic_offset_table_rtx,\n@@ -3868,7 +3868,7 @@\n      (use (label_ref (match_operand 3 \"\" \"\")))])]\n   \"\"\n {\n-  operands[2] = plus_constant (operands[2], 1);\n+  operands[2] = plus_constant (SImode, operands[2], 1);\n   operands[5] = gen_reg_rtx (SImode);\n   operands[6] = gen_reg_rtx (SImode);\n   operands[7] = gen_reg_rtx (SImode);\n@@ -3903,7 +3903,7 @@\n   rtx xlabel = gen_rtx_LABEL_REF (VOIDmode, operands[3]);\n   for (i = 5; i <= 10; i++)\n     operands[i] = gen_reg_rtx (SImode);\n-  operands[2] = plus_constant (operands[2], 1);\n+  operands[2] = plus_constant (SImode, operands[2], 1);\n \n   /* Don't forget to decorate labels too, for PIC.  */\n   operands[11] = flag_pic"}, {"sha": "10cbdc39a3f836d05ffa341535680f605879cfac", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -687,7 +687,7 @@ machopic_indirect_data_reference (rtx orig, rtx reg)\n       orig = machopic_indirect_data_reference (XEXP (orig, 1),\n \t\t\t\t\t       (base == reg ? 0 : reg));\n       if (MACHOPIC_INDIRECT && (GET_CODE (orig) == CONST_INT))\n-\tresult = plus_constant (base, INTVAL (orig));\n+\tresult = plus_constant (Pmode, base, INTVAL (orig));\n       else\n \tresult = gen_rtx_PLUS (Pmode, base, orig);\n \n@@ -972,7 +972,7 @@ machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t\t\t\t\t      Pmode, (base == reg ? 0 : reg));\n       if (GET_CODE (orig) == CONST_INT)\n \t{\n-\t  pic_ref = plus_constant (base, INTVAL (orig));\n+\t  pic_ref = plus_constant (Pmode, base, INTVAL (orig));\n \t  is_complex = 1;\n \t}\n       else"}, {"sha": "f1a8db76353ede77a4c0f7a49ead2f6565a8d4b7", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1555,7 +1555,8 @@ epiphany_emit_save_restore (int min, int limit, rtx addr, int epilogue_p)\n \t  if (current_frame_info.first_slot_size > UNITS_PER_WORD)\n \t    {\n \t      mode = DImode;\n-\t      addr = plus_constant (addr, - (HOST_WIDE_INT) UNITS_PER_WORD);\n+\t      addr = plus_constant (Pmode, addr,\n+\t\t\t\t    - (HOST_WIDE_INT) UNITS_PER_WORD);\n \t    }\n \t  if (i-- < min || !epilogue_p)\n \t    goto next_slot;\n@@ -1588,7 +1589,8 @@ epiphany_emit_save_restore (int min, int limit, rtx addr, int epilogue_p)\n \t    {\n \t      mode = DImode;\n \t      i++;\n-\t      addr = plus_constant (addr, - (HOST_WIDE_INT) UNITS_PER_WORD);\n+\t      addr = plus_constant (Pmode, addr,\n+\t\t\t\t    - (HOST_WIDE_INT) UNITS_PER_WORD);\n \t    }\n \t  /* If it fits in the following stack slot pair, that's fine, too.  */\n \t  else if (GET_CODE (addr) == PLUS && (stack_offset & 7) == 4\n@@ -1603,7 +1605,8 @@ epiphany_emit_save_restore (int min, int limit, rtx addr, int epilogue_p)\n \t      skipped_mem = gen_mem (mode, addr);\n \t      mode = DImode;\n \t      i++;\n-\t      addr = plus_constant (addr, - (HOST_WIDE_INT) 2 * UNITS_PER_WORD);\n+\t      addr = plus_constant (Pmode, addr,\n+\t\t\t\t    - (HOST_WIDE_INT) 2 * UNITS_PER_WORD);\n \t    }\n \t}\n       reg = gen_rtx_REG (mode, n);\n@@ -1621,7 +1624,7 @@ epiphany_emit_save_restore (int min, int limit, rtx addr, int epilogue_p)\n \t  continue;\n \t}\n     next_slot:\n-      addr = plus_constant (addr, - (HOST_WIDE_INT) UNITS_PER_WORD);\n+      addr = plus_constant (Pmode, addr, -(HOST_WIDE_INT) UNITS_PER_WORD);\n       stack_offset -= GET_MODE_SIZE (mode);\n     }\n }\n@@ -1646,7 +1649,7 @@ epiphany_expand_prologue (void)\n \n   if (interrupt_p)\n     {\n-      addr = plus_constant (stack_pointer_rtx,\n+      addr = plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t    - (HOST_WIDE_INT) 2 * UNITS_PER_WORD);\n       if (!lookup_attribute (\"forwarder_section\",\n \t\t\t    DECL_ATTRIBUTES (current_function_decl))\n@@ -1663,13 +1666,13 @@ epiphany_expand_prologue (void)\n       frame_insn (gen_stack_adjust_add (off, mem));\n       if (!epiphany_uninterruptible_p (current_function_decl))\n \temit_insn (gen_gie ());\n-      addr = plus_constant (stack_pointer_rtx,\n+      addr = plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t    current_frame_info.first_slot_offset\n \t\t\t    - (HOST_WIDE_INT) 3 * UNITS_PER_WORD);\n     }\n   else\n     {\n-      addr = plus_constant (stack_pointer_rtx,\n+      addr = plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t    epiphany_stack_offset\n \t\t\t    - (HOST_WIDE_INT) UNITS_PER_WORD);\n       epiphany_emit_save_restore (0, current_frame_info.small_threshold,\n@@ -1689,7 +1692,8 @@ epiphany_expand_prologue (void)\n \t\t       (gen_frame_mem (mode, stack_pointer_rtx),\n \t\t\tgen_rtx_REG (mode, current_frame_info.first_slot),\n \t\t\toff, mem));\n-\t  addr = plus_constant (addr, current_frame_info.first_slot_offset);\n+\t  addr = plus_constant (Pmode, addr,\n+\t\t\t\tcurrent_frame_info.first_slot_offset);\n \t}\n     }\n   epiphany_emit_save_restore (current_frame_info.small_threshold,\n@@ -1718,7 +1722,7 @@ epiphany_expand_prologue (void)\n   else if (current_frame_info.last_slot_offset)\n     {\n       mem = gen_frame_mem (BLKmode,\n-\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t  current_frame_info.last_slot_offset));\n       off = GEN_INT (-current_frame_info.last_slot_offset);\n       if (!SIMM11 (INTVAL (off)))\n@@ -1797,7 +1801,7 @@ epiphany_expand_epilogue (int sibcall_p)\n   restore_offset = (interrupt_p\n \t\t    ? - 3 * UNITS_PER_WORD\n \t\t    : epiphany_stack_offset - (HOST_WIDE_INT) UNITS_PER_WORD);\n-  addr = plus_constant (stack_pointer_rtx,\n+  addr = plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t(current_frame_info.first_slot_offset\n \t\t\t + restore_offset));\n   epiphany_emit_save_restore (current_frame_info.small_threshold,\n@@ -1832,12 +1836,12 @@ epiphany_expand_epilogue (int sibcall_p)\n \t\t      gen_rtx_REG (SImode, GPR_0));\n       emit_move_insn (gen_rtx_REG (word_mode, IRET_REGNUM),\n \t\t      gen_rtx_REG (SImode, GPR_0+1));\n-      addr = plus_constant (stack_pointer_rtx,\n+      addr = plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t    - (HOST_WIDE_INT) 2 * UNITS_PER_WORD);\n       emit_move_insn (gen_rtx_REG (DImode, GPR_0),\n \t\t      gen_frame_mem (DImode, addr));\n     }\n-  addr = plus_constant (stack_pointer_rtx,\n+  addr = plus_constant (Pmode, stack_pointer_rtx,\n \t\t\tepiphany_stack_offset - (HOST_WIDE_INT) UNITS_PER_WORD);\n   epiphany_emit_save_restore (0, current_frame_info.small_threshold, addr, 1);\n   if (!sibcall_p)\n@@ -2181,19 +2185,19 @@ epiphany_trampoline_init (rtx tramp_mem, tree fndecl, rtx cxt)\n   rtx fnaddr = XEXP (DECL_RTL (fndecl), 0);\n   rtx tramp = force_reg (Pmode, XEXP (tramp_mem, 0));\n \n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 0)),\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (Pmode, tramp, 0)),\n \t\t  gen_rtx_IOR (SImode, GEN_INT (0x4002000b),\n \t\t\t       EPIPHANY_LOW_RTX (fnaddr)));\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 4)),\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (Pmode, tramp, 4)),\n \t\t  gen_rtx_IOR (SImode, GEN_INT (0x5002000b),\n \t\t\t       EPIPHANY_HIGH_RTX (fnaddr)));\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 8)),\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (Pmode, tramp, 8)),\n \t\t  gen_rtx_IOR (SImode, GEN_INT (0x2002800b),\n \t\t\t       EPIPHANY_LOW_RTX (cxt)));\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 12)),\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (Pmode, tramp, 12)),\n \t\t  gen_rtx_IOR (SImode, GEN_INT (0x3002800b),\n \t\t\t       EPIPHANY_HIGH_RTX (cxt)));\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 16)),\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (Pmode, tramp, 16)),\n \t\t  GEN_INT (0x0802014f));\n }\n \f"}, {"sha": "22863e8150e1c44e77eab3de0b870a6d1fb92ace", "filename": "gcc/config/epiphany/epiphany.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fepiphany%2Fepiphany.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fepiphany%2Fepiphany.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.md?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -265,7 +265,7 @@\n   rtx addr\n     = (frame_pointer_needed ? hard_frame_pointer_rtx : stack_pointer_rtx);\n \n-  addr = plus_constant (addr, MACHINE_FUNCTION (cfun)->lr_slot_offset);\n+  addr = plus_constant (Pmode, addr, MACHINE_FUNCTION (cfun)->lr_slot_offset);\n   operands[1] = gen_frame_mem (SImode, addr);\n })\n \n@@ -373,12 +373,12 @@\n   if (post_modify_operand (operands[0], <MODE>mode))\n     operands[2]\n       = change_address (operands[2], VOIDmode,\n-\t\t\tplus_constant (XEXP (XEXP (operands[0], 0), 0),\n+\t\t\tplus_constant (Pmode, XEXP (XEXP (operands[0], 0), 0),\n \t\t\t\t       UNITS_PER_WORD));\n   if (post_modify_operand (operands[1], <MODE>mode))\n     operands[3]\n       = change_address (operands[3], VOIDmode,\n-\t\t\tplus_constant (XEXP (XEXP (operands[1], 0), 0),\n+\t\t\tplus_constant (Pmode, XEXP (XEXP (operands[1], 0), 0),\n \t\t\t\t       UNITS_PER_WORD));\n }\n   [(set_attr \"type\" \"move,move,load,store\")"}, {"sha": "edb8dc4669b9a726b126698eafd6a522fffbcec6", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -936,7 +936,8 @@ fr30_move_double (rtx * operands)\n \t  emit_insn (gen_rtx_SET (VOIDmode, dest0,\n \t\t\t\t  adjust_address (src, SImode, 0)));\n \t  emit_insn (gen_rtx_SET (SImode, dest1,\n-\t\t\t\t  plus_constant (dest1, UNITS_PER_WORD)));\n+\t\t\t\t  plus_constant (SImode, dest1,\n+\t\t\t\t\t\t UNITS_PER_WORD)));\n \n \t  new_mem = gen_rtx_MEM (SImode, dest1);\n \t  MEM_COPY_ATTRIBUTES (new_mem, src);"}, {"sha": "ace9e437118fc9c7be8d7ca989007d13d0116b67", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1586,7 +1586,7 @@ frv_dwarf_store (rtx reg, int offset)\n {\n   rtx set = gen_rtx_SET (VOIDmode,\n \t\t\t gen_rtx_MEM (GET_MODE (reg),\n-\t\t\t\t      plus_constant (stack_pointer_rtx,\n+\t\t\t\t      plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t     offset)),\n \t\t\t reg);\n   RTX_FRAME_RELATED_P (set) = 1;\n@@ -1821,9 +1821,9 @@ frv_expand_prologue (void)\n       /* ASM_SRC and DWARF_SRC both point to the frame header.  ASM_SRC is\n \t based on ACCESSOR.BASE but DWARF_SRC is always based on the stack\n \t pointer.  */\n-      rtx asm_src = plus_constant (accessor.base,\n+      rtx asm_src = plus_constant (Pmode, accessor.base,\n \t\t\t\t   fp_offset - accessor.base_offset);\n-      rtx dwarf_src = plus_constant (sp, fp_offset);\n+      rtx dwarf_src = plus_constant (Pmode, sp, fp_offset);\n \n       /* Store the old frame pointer at (sp + FP_OFFSET).  */\n       frv_frame_access (&accessor, fp, fp_offset);\n@@ -2272,8 +2272,8 @@ frv_expand_block_move (rtx operands[])\n \t}\n       else\n \t{\n-\t  src_addr = plus_constant (src_reg, offset);\n-\t  dest_addr = plus_constant (dest_reg, offset);\n+\t  src_addr = plus_constant (Pmode, src_reg, offset);\n+\t  dest_addr = plus_constant (Pmode, dest_reg, offset);\n \t}\n \n       /* Generate the appropriate load and store, saving the stores\n@@ -2357,7 +2357,7 @@ frv_expand_block_clear (rtx operands[])\n       /* Calculate the correct offset for src/dest.  */\n       dest_addr = ((offset == 0)\n \t\t   ? dest_reg\n-\t\t   : plus_constant (dest_reg, offset));\n+\t\t   : plus_constant (Pmode, dest_reg, offset));\n \n       /* Generate the appropriate store of gr0.  */\n       if (bytes >= 4 && align >= 4)\n@@ -2471,7 +2471,7 @@ frv_return_addr_rtx (int count, rtx frame)\n   if (count != 0)\n     return const0_rtx;\n   cfun->machine->frame_needed = 1;\n-  return gen_rtx_MEM (Pmode, plus_constant (frame, 8));\n+  return gen_rtx_MEM (Pmode, plus_constant (Pmode, frame, 8));\n }\n \n /* Given a memory reference MEMREF, interpret the referenced memory as\n@@ -2489,7 +2489,8 @@ frv_index_memory (rtx memref, enum machine_mode mode, int index)\n   if (GET_CODE (base) == PRE_MODIFY)\n     base = XEXP (base, 0);\n   return change_address (memref, mode,\n-\t\t\t plus_constant (base, index * GET_MODE_SIZE (mode)));\n+\t\t\t plus_constant (Pmode, base,\n+\t\t\t\t\tindex * GET_MODE_SIZE (mode)));\n }\n \n \f\n@@ -3741,7 +3742,8 @@ static void\n frv_output_const_unspec (FILE *stream, const struct frv_unspec *unspec)\n {\n   fprintf (stream, \"#%s(\", unspec_got_name (unspec->reloc));\n-  output_addr_const (stream, plus_constant (unspec->symbol, unspec->offset));\n+  output_addr_const (stream, plus_constant (Pmode, unspec->symbol,\n+\t\t\t\t\t    unspec->offset));\n   fputs (\")\", stream);\n }\n \n@@ -3756,7 +3758,7 @@ frv_find_base_term (rtx x)\n \n   if (frv_const_unspec_p (x, &unspec)\n       && frv_small_data_reloc_p (unspec.symbol, unspec.reloc))\n-    return plus_constant (unspec.symbol, unspec.offset);\n+    return plus_constant (Pmode, unspec.symbol, unspec.offset);\n \n   return x;\n }\n@@ -9647,7 +9649,7 @@ frv_output_dwarf_dtprel (FILE *file, int size, rtx x)\n   fputs (\"\\t.picptr\\ttlsmoff(\", file);\n   /* We want the unbiased TLS offset, so add the bias to the\n      expression, such that the implicit biasing cancels out.  */\n-  output_addr_const (file, plus_constant (x, TLS_BIAS));\n+  output_addr_const (file, plus_constant (Pmode, x, TLS_BIAS));\n   fputs (\")\", file);\n }\n "}, {"sha": "f165fdf66f6290c1604095e9e40c67f22ae2fbfa", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -678,12 +678,13 @@ h8300_push_pop (int regno, int nregs, bool pop_p, bool return_p)\n \t  /* Register REGNO + NREGS - 1 is popped first.  Before the\n \t     stack adjustment, its slot is at address @sp.  */\n \t  lhs = gen_rtx_REG (SImode, regno + j);\n-\t  rhs = gen_rtx_MEM (SImode, plus_constant (sp, (nregs - j - 1) * 4));\n+\t  rhs = gen_rtx_MEM (SImode, plus_constant (Pmode, sp,\n+\t\t\t\t\t\t    (nregs - j - 1) * 4));\n \t}\n       else\n \t{\n \t  /* Register REGNO is pushed first and will be stored at @(-4,sp).  */\n-\t  lhs = gen_rtx_MEM (SImode, plus_constant (sp, (j + 1) * -4));\n+\t  lhs = gen_rtx_MEM (SImode, plus_constant (Pmode, sp, (j + 1) * -4));\n \t  rhs = gen_rtx_REG (SImode, regno + j);\n \t}\n       RTVEC_ELT (vec, i + j) = gen_rtx_SET (VOIDmode, lhs, rhs);\n@@ -2002,7 +2003,8 @@ h8300_return_addr_rtx (int count, rtx frame)\n   else\n     ret = gen_rtx_MEM (Pmode,\n \t\t       memory_address (Pmode,\n-\t\t\t\t       plus_constant (frame, UNITS_PER_WORD)));\n+\t\t\t\t       plus_constant (Pmode, frame,\n+\t\t\t\t\t\t      UNITS_PER_WORD)));\n   set_mem_alias_set (ret, get_frame_alias_set ());\n   return ret;\n }\n@@ -2719,17 +2721,17 @@ h8300_swap_into_er6 (rtx addr)\n   rtx insn = push (HARD_FRAME_POINTER_REGNUM);\n   if (frame_pointer_needed)\n     add_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\t  plus_constant (gen_rtx_MEM (Pmode, stack_pointer_rtx),\n+\t\t  plus_constant (Pmode, gen_rtx_MEM (Pmode, stack_pointer_rtx),\n \t\t\t\t 2 * UNITS_PER_WORD));\n   else\n     add_reg_note (insn, REG_CFA_ADJUST_CFA,\n \t\t  gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t       plus_constant (stack_pointer_rtx, 4)));\n+\t\t\t       plus_constant (Pmode, stack_pointer_rtx, 4)));\n \n   emit_move_insn (hard_frame_pointer_rtx, addr);\n   if (REGNO (addr) == SP_REG)\n     emit_move_insn (hard_frame_pointer_rtx,\n-\t\t    plus_constant (hard_frame_pointer_rtx,\n+\t\t    plus_constant (Pmode, hard_frame_pointer_rtx,\n \t\t\t\t   GET_MODE_SIZE (word_mode)));\n }\n \n@@ -2748,11 +2750,12 @@ h8300_swap_out_of_er6 (rtx addr)\n   RTX_FRAME_RELATED_P (insn) = 1;\n   if (frame_pointer_needed)\n     add_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\t  plus_constant (hard_frame_pointer_rtx, 2 * UNITS_PER_WORD));\n+\t\t  plus_constant (Pmode, hard_frame_pointer_rtx,\n+\t\t\t\t 2 * UNITS_PER_WORD));\n   else\n     add_reg_note (insn, REG_CFA_ADJUST_CFA,\n \t\t  gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t       plus_constant (stack_pointer_rtx, -4)));\n+\t\t\t       plus_constant (Pmode, stack_pointer_rtx, -4)));\n }\n \f\n /* Return the length of mov instruction.  */"}, {"sha": "953b668944324a3abed3b70aea4534dddc96447d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 54, "deletions": 40, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -7699,7 +7699,7 @@ setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)\n   for (i = cum->regno; i < max; i++)\n     {\n       mem = gen_rtx_MEM (word_mode,\n-\t\t\t plus_constant (save_area, i * UNITS_PER_WORD));\n+\t\t\t plus_constant (Pmode, save_area, i * UNITS_PER_WORD));\n       MEM_NOTRAP_P (mem) = 1;\n       set_mem_alias_set (mem, set);\n       emit_move_insn (mem,\n@@ -7735,7 +7735,8 @@ setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)\n \n       for (i = cum->sse_regno; i < max; ++i)\n \t{\n-\t  mem = plus_constant (save_area, i * 16 + ix86_varargs_gpr_size);\n+\t  mem = plus_constant (Pmode, save_area,\n+\t\t\t       i * 16 + ix86_varargs_gpr_size);\n \t  mem = gen_rtx_MEM (smode, mem);\n \t  MEM_NOTRAP_P (mem) = 1;\n \t  set_mem_alias_set (mem, set);\n@@ -7764,7 +7765,7 @@ setup_incoming_varargs_ms_64 (CUMULATIVE_ARGS *cum)\n       rtx reg, mem;\n \n       mem = gen_rtx_MEM (Pmode,\n-\t\t\t plus_constant (virtual_incoming_args_rtx,\n+\t\t\t plus_constant (Pmode, virtual_incoming_args_rtx,\n \t\t\t\t\ti * UNITS_PER_WORD));\n       MEM_NOTRAP_P (mem) = 1;\n       set_mem_alias_set (mem, set);\n@@ -9233,7 +9234,7 @@ choose_baseaddr (HOST_WIDE_INT cfa_offset)\n     }\n   gcc_assert (base_reg != NULL);\n \n-  return plus_constant (base_reg, base_offset);\n+  return plus_constant (Pmode, base_reg, base_offset);\n }\n \n /* Emit code to save registers in the prologue.  */\n@@ -9288,7 +9289,7 @@ ix86_emit_save_reg_using_mov (enum machine_mode mode, unsigned int regno,\n \t     the re-aligned stack frame, which provides us with a copy\n \t     of the CFA that will last past the prologue.  Install it.  */\n \t  gcc_checking_assert (cfun->machine->fs.fp_valid);\n-\t  addr = plus_constant (hard_frame_pointer_rtx,\n+\t  addr = plus_constant (Pmode, hard_frame_pointer_rtx,\n \t\t\t\tcfun->machine->fs.fp_offset - cfa_offset);\n \t  mem = gen_rtx_MEM (mode, addr);\n \t  add_reg_note (insn, REG_CFA_DEF_CFA, mem);\n@@ -9298,7 +9299,7 @@ ix86_emit_save_reg_using_mov (enum machine_mode mode, unsigned int regno,\n \t  /* The frame pointer is a stable reference within the\n \t     aligned frame.  Use it.  */\n \t  gcc_checking_assert (cfun->machine->fs.fp_valid);\n-\t  addr = plus_constant (hard_frame_pointer_rtx,\n+\t  addr = plus_constant (Pmode, hard_frame_pointer_rtx,\n \t\t\t\tcfun->machine->fs.fp_offset - cfa_offset);\n \t  mem = gen_rtx_MEM (mode, addr);\n \t  add_reg_note (insn, REG_CFA_EXPRESSION,\n@@ -9311,7 +9312,8 @@ ix86_emit_save_reg_using_mov (enum machine_mode mode, unsigned int regno,\n      use by the unwind info.  */\n   else if (base != m->fs.cfa_reg)\n     {\n-      addr = plus_constant (m->fs.cfa_reg, m->fs.cfa_offset - cfa_offset);\n+      addr = plus_constant (Pmode, m->fs.cfa_reg,\n+\t\t\t    m->fs.cfa_offset - cfa_offset);\n       mem = gen_rtx_MEM (mode, addr);\n       add_reg_note (insn, REG_CFA_OFFSET, gen_rtx_SET (VOIDmode, mem, reg));\n     }\n@@ -9757,7 +9759,8 @@ ix86_adjust_stack_and_probe (const HOST_WIDE_INT size)\n \t    adjust = PROBE_INTERVAL;\n \n \t  emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t\t  plus_constant (stack_pointer_rtx, -adjust)));\n+\t\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t -adjust)));\n \t  emit_stack_probe (stack_pointer_rtx);\n \t}\n \n@@ -9767,12 +9770,13 @@ ix86_adjust_stack_and_probe (const HOST_WIDE_INT size)\n         adjust = size + PROBE_INTERVAL - i;\n \n       emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t      plus_constant (stack_pointer_rtx, -adjust)));\n+\t\t\t      plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t     -adjust)));\n       emit_stack_probe (stack_pointer_rtx);\n \n       /* Adjust back to account for the additional first interval.  */\n       last = emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t     plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t    PROBE_INTERVAL + dope)));\n     }\n \n@@ -9798,7 +9802,7 @@ ix86_adjust_stack_and_probe (const HOST_WIDE_INT size)\n \n       /* SP = SP_0 + PROBE_INTERVAL.  */\n       emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t      plus_constant (stack_pointer_rtx,\n+\t\t\t      plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t     - (PROBE_INTERVAL + dope))));\n \n       /* LAST_ADDR = SP_0 + PROBE_INTERVAL + ROUNDED_SIZE.  */\n@@ -9828,14 +9832,14 @@ ix86_adjust_stack_and_probe (const HOST_WIDE_INT size)\n       if (size != rounded_size)\n \t{\n \t  emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t          plus_constant (stack_pointer_rtx,\n+\t\t\t          plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t rounded_size - size)));\n \t  emit_stack_probe (stack_pointer_rtx);\n \t}\n \n       /* Adjust back to account for the additional first interval.  */\n       last = emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t     plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t    PROBE_INTERVAL + dope)));\n \n       release_scratch_register_on_entry (&sr);\n@@ -9851,10 +9855,10 @@ ix86_adjust_stack_and_probe (const HOST_WIDE_INT size)\n       rtx expr = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (2));\n       XVECEXP (expr, 0, 0)\n \t= gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t       plus_constant (stack_pointer_rtx, -size));\n+\t\t       plus_constant (Pmode, stack_pointer_rtx, -size));\n       XVECEXP (expr, 0, 1)\n \t= gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t       plus_constant (stack_pointer_rtx,\n+\t\t       plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t      PROBE_INTERVAL + dope + size));\n       add_reg_note (last, REG_FRAME_RELATED_EXPR, expr);\n       RTX_FRAME_RELATED_P (last) = 1;\n@@ -9923,9 +9927,11 @@ ix86_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n \t it exceeds SIZE.  If only one probe is needed, this will not\n \t generate any code.  Then probe at FIRST + SIZE.  */\n       for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)\n-\temit_stack_probe (plus_constant (stack_pointer_rtx, -(first + i)));\n+\temit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t -(first + i)));\n \n-      emit_stack_probe (plus_constant (stack_pointer_rtx, -(first + size)));\n+      emit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t       -(first + size)));\n     }\n \n   /* Otherwise, do the same as above, but in a loop.  Note that we must be\n@@ -9973,7 +9979,8 @@ ix86_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n \t that SIZE is equal to ROUNDED_SIZE.  */\n \n       if (size != rounded_size)\n-\temit_stack_probe (plus_constant (gen_rtx_PLUS (Pmode,\n+\temit_stack_probe (plus_constant (Pmode,\n+\t\t\t\t\t gen_rtx_PLUS (Pmode,\n \t\t\t\t\t\t       stack_pointer_rtx,\n \t\t\t\t\t\t       sr.reg),\n \t\t\t\t\t rounded_size - size));\n@@ -10226,7 +10233,7 @@ ix86_expand_prologue (void)\n       /* We don't want to interpret this push insn as a register save,\n \t only as a stack adjustment.  The real copy of the register as\n \t a save will be done later, if needed.  */\n-      t = plus_constant (stack_pointer_rtx, -UNITS_PER_WORD);\n+      t = plus_constant (Pmode, stack_pointer_rtx, -UNITS_PER_WORD);\n       t = gen_rtx_SET (VOIDmode, stack_pointer_rtx, t);\n       add_reg_note (insn, REG_CFA_ADJUST_CFA, t);\n       RTX_FRAME_RELATED_P (insn) = 1;\n@@ -10247,7 +10254,7 @@ ix86_expand_prologue (void)\n \t}\n \n       /* Grab the argument pointer.  */\n-      t = plus_constant (stack_pointer_rtx, m->fs.sp_offset);\n+      t = plus_constant (Pmode, stack_pointer_rtx, m->fs.sp_offset);\n       insn = emit_insn (gen_rtx_SET (VOIDmode, crtl->drap_reg, t));\n       RTX_FRAME_RELATED_P (insn) = 1;\n       m->fs.cfa_reg = crtl->drap_reg;\n@@ -10263,7 +10270,7 @@ ix86_expand_prologue (void)\n \t address can be reached via (argp - 1) slot.  This is needed\n \t to implement macro RETURN_ADDR_RTX and intrinsic function\n \t expand_builtin_return_addr etc.  */\n-      t = plus_constant (crtl->drap_reg, -UNITS_PER_WORD);\n+      t = plus_constant (Pmode, crtl->drap_reg, -UNITS_PER_WORD);\n       t = gen_frame_mem (word_mode, t);\n       insn = emit_insn (gen_push (t));\n       RTX_FRAME_RELATED_P (insn) = 1;\n@@ -10453,7 +10460,7 @@ ix86_expand_prologue (void)\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n \t\t\tgen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t     plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t    -allocate)));\n \t}\n       m->fs.sp_offset += allocate;\n@@ -10608,7 +10615,7 @@ ix86_emit_restore_reg_using_pop (rtx reg)\n \n   if (m->fs.cfa_reg == stack_pointer_rtx)\n     {\n-      rtx x = plus_constant (stack_pointer_rtx, UNITS_PER_WORD);\n+      rtx x = plus_constant (Pmode, stack_pointer_rtx, UNITS_PER_WORD);\n       x = gen_rtx_SET (VOIDmode, stack_pointer_rtx, x);\n       add_reg_note (insn, REG_CFA_ADJUST_CFA, x);\n       RTX_FRAME_RELATED_P (insn) = 1;\n@@ -10670,7 +10677,8 @@ ix86_emit_leave (void)\n       m->fs.cfa_offset = m->fs.sp_offset;\n \n       add_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\t    plus_constant (stack_pointer_rtx, m->fs.sp_offset));\n+\t\t    plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t   m->fs.sp_offset));\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n   ix86_add_cfa_restore_note (insn, hard_frame_pointer_rtx,\n@@ -10883,7 +10891,7 @@ ix86_expand_epilogue (int style)\n \t  if (frame_pointer_needed)\n \t    {\n \t      t = gen_rtx_PLUS (Pmode, hard_frame_pointer_rtx, sa);\n-\t      t = plus_constant (t, m->fs.fp_offset - UNITS_PER_WORD);\n+\t      t = plus_constant (Pmode, t, m->fs.fp_offset - UNITS_PER_WORD);\n \t      emit_insn (gen_rtx_SET (VOIDmode, sa, t));\n \n \t      t = gen_frame_mem (Pmode, hard_frame_pointer_rtx);\n@@ -10898,7 +10906,7 @@ ix86_expand_epilogue (int style)\n \t\t bother resetting the CFA to the SP for the duration of\n \t\t the return insn.  */\n \t      add_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\t\t    plus_constant (sa, UNITS_PER_WORD));\n+\t\t\t    plus_constant (Pmode, sa, UNITS_PER_WORD));\n \t      ix86_add_queued_cfa_restore_notes (insn);\n \t      add_reg_note (insn, REG_CFA_RESTORE, hard_frame_pointer_rtx);\n \t      RTX_FRAME_RELATED_P (insn) = 1;\n@@ -10913,7 +10921,7 @@ ix86_expand_epilogue (int style)\n \t  else\n \t    {\n \t      t = gen_rtx_PLUS (Pmode, stack_pointer_rtx, sa);\n-\t      t = plus_constant (t, m->fs.sp_offset - UNITS_PER_WORD);\n+\t      t = plus_constant (Pmode, t, m->fs.sp_offset - UNITS_PER_WORD);\n \t      insn = emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx, t));\n \t      ix86_add_queued_cfa_restore_notes (insn);\n \n@@ -10922,7 +10930,7 @@ ix86_expand_epilogue (int style)\n \t\t{\n \t\t  m->fs.cfa_offset = UNITS_PER_WORD;\n \t\t  add_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\t\t\tplus_constant (stack_pointer_rtx,\n+\t\t\t\tplus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t       UNITS_PER_WORD));\n \t\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t\t}\n@@ -12587,7 +12595,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t\t\t\t\t\t base == reg ? NULL_RTX : reg);\n \n \t      if (CONST_INT_P (new_rtx))\n-\t\tnew_rtx = plus_constant (base, INTVAL (new_rtx));\n+\t\tnew_rtx = plus_constant (Pmode, base, INTVAL (new_rtx));\n \t      else\n \t\t{\n \t\t  if (GET_CODE (new_rtx) == PLUS && CONSTANT_P (XEXP (new_rtx, 1)))\n@@ -13107,7 +13115,8 @@ ix86_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t      x = gen_rtx_PLUS (Pmode,\n \t\t\t\tgen_rtx_PLUS (Pmode, XEXP (XEXP (x, 0), 0),\n \t\t\t\t\t      XEXP (XEXP (XEXP (x, 0), 1), 0)),\n-\t\t\t\tplus_constant (other, INTVAL (constant)));\n+\t\t\t\tplus_constant (Pmode, other,\n+\t\t\t\t\t       INTVAL (constant)));\n \t    }\n \t}\n \n@@ -20685,7 +20694,7 @@ ix86_split_long_move (rtx operands[])\n       /* Compensate for the stack decrement by 4.  */\n       if (!TARGET_64BIT && nparts == 3\n \t  && mode == XFmode && TARGET_128BIT_LONG_DOUBLE)\n-\tsrc_base = plus_constant (src_base, 4);\n+\tsrc_base = plus_constant (Pmode, src_base, 4);\n \n       /* src_base refers to the stack pointer and is\n \t automatically decreased by emitted push.  */\n@@ -20749,7 +20758,7 @@ ix86_split_long_move (rtx operands[])\n \t  part[1][0] = replace_equiv_address (part[1][0], base);\n \t  for (i = 1; i < nparts; i++)\n \t    {\n-\t      tmp = plus_constant (base, UNITS_PER_WORD * i);\n+\t      tmp = plus_constant (Pmode, base, UNITS_PER_WORD * i);\n \t      part[1][i] = replace_equiv_address (part[1][i], tmp);\n \t    }\n \t}\n@@ -22365,7 +22374,8 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n \t     sufficiently aligned, maintain aliasing info accurately.  */\n \t  dst = expand_constant_movmem_prologue (dst, &src, destreg, srcreg,\n \t\t\t\t\t\t desired_align, align_bytes);\n-\t  count_exp = plus_constant (count_exp, -align_bytes);\n+\t  count_exp = plus_constant (counter_mode (count_exp),\n+\t\t\t\t     count_exp, -align_bytes);\n \t  count -= align_bytes;\n \t}\n       if (need_zero_guard\n@@ -22757,7 +22767,8 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n \t     sufficiently aligned, maintain aliasing info accurately.  */\n \t  dst = expand_constant_setmem_prologue (dst, destreg, promoted_val,\n \t\t\t\t\t\t desired_align, align_bytes);\n-\t  count_exp = plus_constant (count_exp, -align_bytes);\n+\t  count_exp = plus_constant (counter_mode (count_exp),\n+\t\t\t\t     count_exp, -align_bytes);\n \t  count -= align_bytes;\n \t}\n       if (need_zero_guard\n@@ -24464,7 +24475,8 @@ ix86_static_chain (const_tree fndecl, bool incoming_p)\n \t      if (fndecl == current_function_decl)\n \t\tix86_static_chain_on_stack = true;\n \t      return gen_frame_mem (SImode,\n-\t\t\t\t    plus_constant (arg_pointer_rtx, -8));\n+\t\t\t\t    plus_constant (Pmode,\n+\t\t\t\t\t\t   arg_pointer_rtx, -8));\n \t    }\n \t  regno = SI_REG;\n \t}\n@@ -24586,7 +24598,7 @@ ix86_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n \t (call-saved) register static chain; this push is 1 byte.  */\n       offset += 5;\n       disp = expand_binop (SImode, sub_optab, fnaddr,\n-\t\t\t   plus_constant (XEXP (m_tramp, 0),\n+\t\t\t   plus_constant (Pmode, XEXP (m_tramp, 0),\n \t\t\t\t\t  offset - (MEM_P (chain) ? 1 : 0)),\n \t\t\t   NULL_RTX, 1, OPTAB_DIRECT);\n       emit_move_insn (mem, disp);\n@@ -32567,7 +32579,7 @@ x86_this_parameter (tree function)\n \t  regno = CX_REG;\n \t  if (aggr)\n \t    return gen_rtx_MEM (SImode,\n-\t\t\t\tplus_constant (stack_pointer_rtx, 4));\n+\t\t\t\tplus_constant (Pmode, stack_pointer_rtx, 4));\n \t}\n       else\n         {\n@@ -32577,13 +32589,15 @@ x86_this_parameter (tree function)\n \t      regno = DX_REG;\n \t      if (nregs == 1)\n \t\treturn gen_rtx_MEM (SImode,\n-\t\t\t\t    plus_constant (stack_pointer_rtx, 4));\n+\t\t\t\t    plus_constant (Pmode,\n+\t\t\t\t\t\t   stack_pointer_rtx, 4));\n \t    }\n \t}\n       return gen_rtx_REG (SImode, regno);\n     }\n \n-  return gen_rtx_MEM (SImode, plus_constant (stack_pointer_rtx, aggr ? 8 : 4));\n+  return gen_rtx_MEM (SImode, plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t     aggr ? 8 : 4));\n }\n \n /* Determine whether x86_output_mi_thunk can succeed.  */\n@@ -32685,7 +32699,7 @@ x86_output_mi_thunk (FILE *file,\n       emit_move_insn (tmp, this_mem);\n \n       /* Adjust the this parameter.  */\n-      vcall_addr = plus_constant (tmp, vcall_offset);\n+      vcall_addr = plus_constant (Pmode, tmp, vcall_offset);\n       if (TARGET_64BIT\n \t  && !ix86_legitimate_address_p (ptr_mode, vcall_addr, true))\n \t{"}, {"sha": "ddb36459e931f79345cf67cbcdb5953a11684e06", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1912,8 +1912,9 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n /* After the prologue, RA is at -4(AP) in the current frame.  */\n #define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t   \\\n   ((COUNT) == 0\t\t\t\t\t\t\t\t   \\\n-   ? gen_rtx_MEM (Pmode, plus_constant (arg_pointer_rtx, -UNITS_PER_WORD)) \\\n-   : gen_rtx_MEM (Pmode, plus_constant (FRAME, UNITS_PER_WORD)))\n+   ? gen_rtx_MEM (Pmode, plus_constant (Pmode, arg_pointer_rtx,\t   \\\n+\t\t\t\t\t-UNITS_PER_WORD))\t\t   \\\n+   : gen_rtx_MEM (Pmode, plus_constant (Pmode, FRAME, UNITS_PER_WORD)))\n \n /* PC is dbx register 8; let's use that column for RA.  */\n #define DWARF_FRAME_RETURN_COLUMN \t(TARGET_64BIT ? 16 : 8)"}, {"sha": "f0725c7ed9c9dcae7c8d985fe9c0f5b40de6942d", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -6349,7 +6349,7 @@\n \n   operands[2] = GEN_INT (1 << INTVAL (operands[2]));\n \n-  pat = plus_constant (gen_rtx_MULT (mode, operands[1], operands[2]),\n+  pat = plus_constant (mode, gen_rtx_MULT (mode, operands[1], operands[2]),\n \t\t       INTVAL (operands[3]));\n \n   emit_insn (gen_rtx_SET (VOIDmode, operands[0], pat));\n@@ -11964,7 +11964,7 @@\n      be returning into someone else's stack frame, one word below the\n      stack address we wish to restore.  */\n   tmp = gen_rtx_PLUS (Pmode, arg_pointer_rtx, sa);\n-  tmp = plus_constant (tmp, -UNITS_PER_WORD);\n+  tmp = plus_constant (Pmode, tmp, -UNITS_PER_WORD);\n   tmp = gen_rtx_MEM (Pmode, tmp);\n   emit_move_insn (tmp, ra);\n "}, {"sha": "89a65ff82a21cea591a675038b64be7ca173577f", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1104,7 +1104,7 @@ ia64_expand_load_address (rtx dest, rtx src)\n \t  if (lo != 0)\n \t    {\n \t      addend = lo;\n-\t      src = plus_constant (XEXP (XEXP (src, 0), 0), hi);\n+\t      src = plus_constant (Pmode, XEXP (XEXP (src, 0), 0), hi);\n \t    }\n \t}\n \n@@ -1213,7 +1213,7 @@ ia64_expand_tls_address (enum tls_model tls_kind, rtx op0, rtx op1,\n       addend_lo = ((addend & 0x3fff) ^ 0x2000) - 0x2000;\n       addend_hi = addend - addend_lo;\n \n-      op1 = plus_constant (op1, addend_hi);\n+      op1 = plus_constant (Pmode, op1, addend_hi);\n       addend = addend_lo;\n \n       tmp = gen_reg_rtx (Pmode);\n@@ -1290,7 +1290,7 @@ ia64_expand_move (rtx op0, rtx op1)\n \n \t  if (addend_lo != 0)\n \t    {\n-\t      op1 = plus_constant (sym, addend_hi);\n+\t      op1 = plus_constant (mode, sym, addend_hi);\n \t      addend = addend_lo;\n \t    }\n \t  else\n@@ -1441,7 +1441,8 @@ ia64_split_tmode (rtx out[2], rtx in, bool reversed, bool dead)\n \t      (in, DImode, gen_rtx_POST_INC (Pmode, base), 0);\n \t    out[1] = adjust_automodify_address\n \t      (in, DImode,\n-\t       gen_rtx_POST_MODIFY (Pmode, base, plus_constant (base, -24)),\n+\t       gen_rtx_POST_MODIFY (Pmode, base,\n+\t\t\t\t    plus_constant (Pmode, base, -24)),\n \t       8);\n \t    break;\n \n@@ -3190,7 +3191,8 @@ do_spill (rtx (*move_fn) (rtx, rtx, rtx), rtx reg, HOST_WIDE_INT cfa_off,\n       add_reg_note (insn, REG_CFA_OFFSET,\n \t\t    gen_rtx_SET (VOIDmode,\n \t\t\t\t gen_rtx_MEM (GET_MODE (reg),\n-\t\t\t\t\t      plus_constant (base, off)),\n+\t\t\t\t\t      plus_constant (Pmode,\n+\t\t\t\t\t\t\t     base, off)),\n \t\t\t\t frame_reg));\n     }\n }\n@@ -4253,7 +4255,7 @@ ia64_trampoline_init (rtx m_tramp, tree fndecl, rtx static_chain)\n   emit_insn (gen_adddi3 (addr_reg, addr_reg, eight));\n   m_tramp = adjust_automodify_address (m_tramp, VOIDmode, NULL, 8);\n \n-  emit_move_insn (m_tramp, force_reg (Pmode, plus_constant (addr, 16)));\n+  emit_move_insn (m_tramp, force_reg (Pmode, plus_constant (Pmode, addr, 16)));\n   emit_insn (gen_adddi3 (addr_reg, addr_reg, eight));\n   m_tramp = adjust_automodify_address (m_tramp, VOIDmode, NULL, 8);\n "}, {"sha": "e75eb2f806ab8a7ac30b3332280592005499192a", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1412,7 +1412,7 @@ iq2000_va_start (tree valist, rtx nextarg)\n \n   /* Everything is in the GPR save area, or in the overflow\n      area which is contiguous with it.  */\n-  nextarg = plus_constant (nextarg, - gpr_save_area_size);\n+  nextarg = plus_constant (Pmode, nextarg, - gpr_save_area_size);\n   std_expand_builtin_va_start (valist, nextarg);\n }\n \f\n@@ -1783,7 +1783,7 @@ iq2000_annotate_frame_insn (rtx insn, rtx dwarf_pattern)\n static void\n iq2000_emit_frame_related_store (rtx mem, rtx reg, HOST_WIDE_INT offset)\n {\n-  rtx dwarf_address = plus_constant (stack_pointer_rtx, offset);\n+  rtx dwarf_address = plus_constant (Pmode, stack_pointer_rtx, offset);\n   rtx dwarf_mem = gen_rtx_MEM (GET_MODE (reg), dwarf_address);\n \n   iq2000_annotate_frame_insn (emit_move_insn (mem, reg),\n@@ -2031,7 +2031,8 @@ iq2000_expand_prologue (void)\n \t\t\t\t    adjustment_rtx));\n \n       dwarf_pattern = gen_rtx_SET (Pmode, stack_pointer_rtx,\n-\t\t\t\t   plus_constant (stack_pointer_rtx, -tsize));\n+\t\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t  -tsize));\n \n       iq2000_annotate_frame_insn (insn, dwarf_pattern);\n \n@@ -2120,7 +2121,7 @@ iq2000_expand_eh_return (rtx address)\n   HOST_WIDE_INT gp_offset = cfun->machine->gp_sp_offset;\n   rtx scratch;\n \n-  scratch = plus_constant (stack_pointer_rtx, gp_offset);\n+  scratch = plus_constant (Pmode, stack_pointer_rtx, gp_offset);\n   emit_move_insn (gen_rtx_MEM (GET_MODE (address), scratch), address);\n }\n \f\n@@ -2873,9 +2874,9 @@ iq2000_setup_incoming_varargs (cumulative_args_t cum_v,\n \t  if (cum->arg_words < MAX_ARGS_IN_REGISTERS - iq2000_off) \n \t    {\n \t      rtx ptr, mem; \n-\t      ptr = plus_constant (virtual_incoming_args_rtx, \n-\t\t\t\t   - (iq2000_save_gp_regs \n-\t\t\t\t      * UNITS_PER_WORD)); \n+\t      ptr = plus_constant (Pmode, virtual_incoming_args_rtx,\n+\t\t\t\t   - (iq2000_save_gp_regs\n+\t\t\t\t      * UNITS_PER_WORD));\n \t      mem = gen_rtx_MEM (BLKmode, ptr); \n \t      move_block_from_reg \n \t\t(cum->arg_words + GP_ARG_FIRST + iq2000_off, \n@@ -3165,7 +3166,7 @@ iq2000_print_operand (FILE *file, rtx op, int letter)\n   else if (code == MEM)\n     {\n       if (letter == 'D')\n-\toutput_address (plus_constant (XEXP (op, 0), 4));\n+\toutput_address (plus_constant (Pmode, XEXP (op, 0), 4));\n       else\n \toutput_address (XEXP (op, 0));\n     }\n@@ -3273,7 +3274,7 @@ iq2000_legitimize_address (rtx xinsn, rtx old_x ATTRIBUTE_UNUSED,\n                                   ptr_reg,\n                                   gen_rtx_PLUS (Pmode, xplus0, int_reg)));\n \n-          return plus_constant (ptr_reg, INTVAL (xplus1) & 0x7fff);\n+          return plus_constant (Pmode, ptr_reg, INTVAL (xplus1) & 0x7fff);\n         }\n     }\n "}, {"sha": "2e1cf445428b3c94b22d1f7ba783d983c87bba6e", "filename": "gcc/config/lm32/lm32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Flm32%2Flm32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Flm32%2Flm32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -715,7 +715,7 @@ lm32_setup_incoming_varargs (cumulative_args_t cum_v, enum machine_mode mode,\n       rtx regblock;\n \n       regblock = gen_rtx_MEM (BLKmode,\n-\t\t\t      plus_constant (arg_pointer_rtx,\n+\t\t\t      plus_constant (Pmode, arg_pointer_rtx,\n \t\t\t\t\t     FIRST_PARM_OFFSET (0)));\n       move_block_from_reg (first_reg_offset, regblock, size);\n "}, {"sha": "79b03fa06508409b02ab5eec05ab37fc695abe62", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1178,7 +1178,8 @@ m32c_return_addr_rtx (int count)\n     }\n \n   ra_mem =\n-    gen_rtx_MEM (mode, plus_constant (gen_rtx_REG (Pmode, FP_REGNO), offset));\n+    gen_rtx_MEM (mode, plus_constant (Pmode, gen_rtx_REG (Pmode, FP_REGNO),\n+\t\t\t\t      offset));\n   return copy_to_mode_reg (mode, ra_mem);\n }\n \n@@ -4178,7 +4179,8 @@ m32c_expand_insv (rtx *operands)\n       && GET_CODE (op0) == MEM)\n     {\n       /* We are little endian.  */\n-      rtx new_mem = gen_rtx_MEM (QImode, plus_constant (XEXP (op0, 0), 1));\n+      rtx new_mem = gen_rtx_MEM (QImode, plus_constant (Pmode,\n+\t\t\t\t\t\t\tXEXP (op0, 0), 1));\n       MEM_COPY_ATTRIBUTES (new_mem, op0);\n       mask >>= 8;\n     }"}, {"sha": "b27a3a5bb89e36605c1f019f3c7c26c0fa62c7dc", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1293,7 +1293,7 @@ m32r_setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n       rtx regblock;\n \n       regblock = gen_frame_mem (BLKmode,\n-\t\t\t\tplus_constant (arg_pointer_rtx,\n+\t\t\t\tplus_constant (Pmode, arg_pointer_rtx,\n \t\t\t\t\t       FIRST_PARM_OFFSET (0)));\n       set_mem_alias_set (regblock, get_varargs_alias_set ());\n       move_block_from_reg (first_reg_offset, regblock, size);\n@@ -1984,7 +1984,7 @@ m32r_legitimize_pic_address (rtx orig, rtx reg)\n       if (CONST_INT_P (offset))\n         {\n           if (INT16_P (INTVAL (offset)))\n-            return plus_constant (base, INTVAL (offset));\n+            return plus_constant (Pmode, base, INTVAL (offset));\n           else\n \t    {\n \t      gcc_assert (! reload_in_progress && ! reload_completed);\n@@ -2087,9 +2087,9 @@ m32r_print_operand (FILE * file, rtx x, int code)\n \t     currently necessary, but keep it around.  */\n \t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n \t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n-\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 4));\n+\t    output_address (plus_constant (Pmode, XEXP (XEXP (x, 0), 0), 4));\n \t  else\n-\t    output_address (plus_constant (XEXP (x, 0), 4));\n+\t    output_address (plus_constant (Pmode, XEXP (x, 0), 4));\n \t  fputc (')', file);\n \t}\n       else\n@@ -2327,7 +2327,8 @@ m32r_print_operand_address (FILE * file, rtx addr)\n \t    fputs (\"sda(\", file);\n \t  else\n \t    fputs (\"low(\", file);\n-\t  output_addr_const (file, plus_constant (XEXP (base, 1), offset));\n+\t  output_addr_const (file, plus_constant (Pmode, XEXP (base, 1),\n+\t\t\t\t\t\t  offset));\n \t  fputs (\"),\", file);\n \t  fputs (reg_names[REGNO (XEXP (base, 0))], file);\n \t}"}, {"sha": "8f5b5057bf909c9eb9d67e2a061958a21b8c8827", "filename": "gcc/config/m68k/linux.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fm68k%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fm68k%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flinux.h?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -190,7 +190,8 @@ along with GCC; see the file COPYING3.  If not see\n #define FINALIZE_TRAMPOLINE(TRAMP)\t\t\t\t\t\\\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__clear_cache\"),\t\\\n \t\t     LCT_NORMAL, VOIDmode, 2, TRAMP, Pmode,\t\t\\\n-\t\t     plus_constant (TRAMP, TRAMPOLINE_SIZE), Pmode);\n+\t\t     plus_constant (Pmode, TRAMP, TRAMPOLINE_SIZE), \\\n+\t\t     Pmode);\n \n /* Clear the instruction cache from `beg' to `end'.  This makes an\n    inline system call to SYS_cacheflush.  The arguments are as"}, {"sha": "8b21419bd31fb3dc693e8ddcb4530c51eadc4ed7", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -916,16 +916,17 @@ m68k_emit_movem (rtx base, HOST_WIDE_INT offset,\n \n   if (adjust_stack_p)\n     {\n-      src = plus_constant (base, (count\n-\t\t\t\t  * GET_MODE_SIZE (mode)\n-\t\t\t\t  * (HOST_WIDE_INT) (store_p ? -1 : 1)));\n+      src = plus_constant (Pmode, base,\n+\t\t\t   (count\n+\t\t\t    * GET_MODE_SIZE (mode)\n+\t\t\t    * (HOST_WIDE_INT) (store_p ? -1 : 1)));\n       XVECEXP (body, 0, i++) = gen_rtx_SET (VOIDmode, base, src);\n     }\n \n   for (; mask != 0; mask >>= 1, regno++)\n     if (mask & 1)\n       {\n-\taddr = plus_constant (base, offset);\n+\taddr = plus_constant (Pmode, base, offset);\n \toperands[!store_p] = gen_frame_mem (mode, addr);\n \toperands[store_p] = gen_rtx_REG (mode, regno);\n \tXVECEXP (body, 0, i++)\n@@ -971,7 +972,7 @@ m68k_expand_prologue (void)\n   if (crtl->limit_stack\n       && GET_CODE (stack_limit_rtx) == SYMBOL_REF)\n     {\n-      limit = plus_constant (stack_limit_rtx, current_frame.size + 4);\n+      limit = plus_constant (Pmode, stack_limit_rtx, current_frame.size + 4);\n       if (!m68k_legitimate_constant_p (Pmode, limit))\n \t{\n \t  emit_move_insn (gen_rtx_REG (Pmode, D0_REG), limit);\n@@ -1205,12 +1206,12 @@ m68k_expand_epilogue (bool sibcall_p)\n \t\t/* Generate the address -OFFSET(%fp,%a1.l).  */\n \t\taddr = gen_rtx_REG (Pmode, A1_REG);\n \t\taddr = gen_rtx_PLUS (Pmode, addr, frame_pointer_rtx);\n-\t\taddr = plus_constant (addr, -offset);\n+\t\taddr = plus_constant (Pmode, addr, -offset);\n \t      }\n \t    else if (restore_from_sp)\n \t      addr = gen_rtx_POST_INC (Pmode, stack_pointer_rtx);\n \t    else\n-\t      addr = plus_constant (frame_pointer_rtx, -offset);\n+\t      addr = plus_constant (Pmode, frame_pointer_rtx, -offset);\n \t    emit_move_insn (gen_rtx_REG (SImode, D0_REG + i),\n \t\t\t    gen_frame_mem (SImode, addr));\n \t    offset -= GET_MODE_SIZE (SImode);\n@@ -2450,7 +2451,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\t     base == reg ? 0 : reg);\n \n       if (GET_CODE (orig) == CONST_INT)\n-\tpic_ref = plus_constant (base, INTVAL (orig));\n+\tpic_ref = plus_constant (Pmode, base, INTVAL (orig));\n       else\n \tpic_ref = gen_rtx_PLUS (Pmode, base, orig);\n     }\n@@ -5035,7 +5036,8 @@ m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n   reload_completed = 1;\n \n   /* The \"this\" pointer is stored at 4(%sp).  */\n-  this_slot = gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx, 4));\n+  this_slot = gen_rtx_MEM (Pmode, plus_constant (Pmode,\n+\t\t\t\t\t\t stack_pointer_rtx, 4));\n \n   /* Add DELTA to THIS.  */\n   if (delta != 0)\n@@ -5060,7 +5062,7 @@ m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n       emit_move_insn (tmp, gen_rtx_MEM (Pmode, tmp));\n \n       /* Set ADDR to a legitimate address for *THIS + VCALL_OFFSET.  */\n-      addr = plus_constant (tmp, vcall_offset);\n+      addr = plus_constant (Pmode, tmp, vcall_offset);\n       if (!m68k_legitimate_address_p (Pmode, addr, true))\n \t{\n \t  emit_insn (gen_rtx_SET (VOIDmode, tmp, addr));"}, {"sha": "0a390d074d471536f04d0f6b5767432bee85001d", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -782,8 +782,9 @@ do { if (cc_prev_status.flags & CC_IN_68881)\t\t\t\\\n /* After the prologue, RA is at 4(AP) in the current frame.  */\n #define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t   \\\n   ((COUNT) == 0\t\t\t\t\t\t\t\t   \\\n-   ? gen_rtx_MEM (Pmode, plus_constant (arg_pointer_rtx, UNITS_PER_WORD)) \\\n-   : gen_rtx_MEM (Pmode, plus_constant (FRAME, UNITS_PER_WORD)))\n+   ? gen_rtx_MEM (Pmode, plus_constant (Pmode, arg_pointer_rtx,\t   \\\n+\t\t\t\t\tUNITS_PER_WORD))\t\t   \\\n+   : gen_rtx_MEM (Pmode, plus_constant (Pmode, FRAME, UNITS_PER_WORD)))\n \n /* We must not use the DBX register numbers for the DWARF 2 CFA column\n    numbers because that maps to numbers beyond FIRST_PSEUDO_REGISTER.\n@@ -814,7 +815,7 @@ do { if (cc_prev_status.flags & CC_IN_68881)\t\t\t\\\n #define EH_RETURN_HANDLER_RTX\t\t\t\t\t    \\\n   gen_rtx_MEM (Pmode,\t\t\t\t\t\t    \\\n \t       gen_rtx_PLUS (Pmode, arg_pointer_rtx,\t\t    \\\n-\t\t\t     plus_constant (EH_RETURN_STACKADJ_RTX, \\\n+\t\t\t     plus_constant (Pmode, EH_RETURN_STACKADJ_RTX, \\\n \t\t\t\t\t    UNITS_PER_WORD)))\n \n /* Select a format to encode pointers in exception handling data.  CODE"}, {"sha": "cc59d45a3bcffb3d8a6fe0d714f18f2352b6a1df", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -2409,7 +2409,8 @@\n       if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n \t{\n \t  operands[1] = gen_rtx_MEM (SImode,\n-\t\t\t\t     plus_constant (XEXP(operands[0], 0), -8));\n+\t\t\t\t     plus_constant (Pmode,\n+\t\t\t\t\t\t    XEXP(operands[0], 0), -8));\n \t  return \"move%.l %0,%3\\;add%.l %R2,%0\\;addx%.l %2,%3\\;move%.l %3,%1\";\n \t}\n       else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n@@ -2907,7 +2908,8 @@\n       if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n \t{\n \t  operands[1]\n-\t    = gen_rtx_MEM (SImode, plus_constant (XEXP (operands[0], 0), -8));\n+\t    = gen_rtx_MEM (SImode, plus_constant (Pmode,\n+\t\t\t\t\t\t  XEXP (operands[0], 0), -8));\n \t  return \"move%.l %0,%3\\;sub%.l %R2,%0\\;subx%.l %2,%3\\;move%.l %3,%1\";\n \t}\n       else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n@@ -7264,7 +7266,8 @@\n \t\t      (match_operand:SI 1 \"const_int_operand\")))])]\n   \"TARGET_68020 || INTVAL (operands[1]) >= -0x8004\"\n {\n-  operands[2] = gen_frame_mem (SImode, plus_constant (stack_pointer_rtx, -4));\n+  operands[2] = gen_frame_mem (SImode,\n+\t\t\t       plus_constant (Pmode, stack_pointer_rtx, -4));\n })\n \n (define_insn \"*link\""}, {"sha": "9b8cf020ef30ce71a18c5bc90414cf5674cc8eac", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -2003,7 +2003,8 @@ mcore_expand_prolog (void)\n         {\n           emit_insn (gen_movsi\n                      (gen_rtx_MEM (SImode,\n-                               plus_constant (stack_pointer_rtx, offset)),\n+\t\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t  offset)),\n                       gen_rtx_REG (SImode, rn)));\n         }\n     }\n@@ -2038,7 +2039,8 @@ mcore_expand_prolog (void)\n \t    {\n \t      emit_insn (gen_movsi\n \t\t         (gen_rtx_MEM (SImode,\n-\t\t\t           plus_constant (stack_pointer_rtx, offs)),\n+\t\t\t\t       plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t      offs)),\n \t\t          gen_rtx_REG (SImode, i)));\n \t      offs += 4;\n \t    }\n@@ -2133,7 +2135,8 @@ mcore_expand_epilog (void)\n \t  emit_insn (gen_movsi\n \t\t     (gen_rtx_REG (SImode, i),\n \t\t      gen_rtx_MEM (SImode,\n-\t\t\t       plus_constant (stack_pointer_rtx, offs))));\n+\t\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t  offs))));\n \t  offs += 4;\n \t}\n     }"}, {"sha": "805de2b232652de441c72b93dd3037d5abcb2b66", "filename": "gcc/config/mcore/mcore.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmcore%2Fmcore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmcore%2Fmcore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.md?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1408,8 +1408,8 @@\n     XVECEXP (operands[3], 0, i)\n       = gen_rtx_SET (VOIDmode,\n \t\t gen_rtx_REG (SImode, regno + i),\n-\t\t gen_rtx_MEM (SImode, plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t      i * 4)));\n+\t\t gen_rtx_MEM (SImode, plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t     i * 4)));\n }\")\n \n (define_insn \"\"\n@@ -1446,8 +1446,8 @@\n   for (i = 0; i < count; i++)\n     XVECEXP (operands[3], 0, i)\n       = gen_rtx_SET (VOIDmode,\n-\t\t gen_rtx_MEM (SImode, plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t      i * 4)),\n+\t\t gen_rtx_MEM (SImode, plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t     i * 4)),\n \t\t gen_rtx_REG (SImode, regno + i));\n }\")\n "}, {"sha": "edfff549e2ab8c12fb9d1936bd1dea39cadf9a8c", "filename": "gcc/config/mep/mep.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -2366,7 +2366,7 @@ mep_allocate_initial_value (rtx reg)\n     }\n \n   rss = cfun->machine->reg_save_slot[REGNO(reg)];\n-  return gen_rtx_MEM (SImode, plus_constant (arg_pointer_rtx, -rss));\n+  return gen_rtx_MEM (SImode, plus_constant (Pmode, arg_pointer_rtx, -rss));\n }\n \n rtx\n@@ -2844,7 +2844,8 @@ mep_expand_prologue (void)\n \t   ALLOCATE_INITIAL_VALUE.  The moves emitted here can then be safely\n \t   deleted as dead.  */\n \tmem = gen_rtx_MEM (rmode,\n-\t\t\t   plus_constant (stack_pointer_rtx, sp_offset - rss));\n+\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t  sp_offset - rss));\n \tmaybe_dead_p = rtx_equal_p (mem, has_hard_reg_initial_val (rmode, i));\n \n \tif (GR_REGNO_P (i) || LOADABLE_CR_REGNO_P (i))\n@@ -2855,7 +2856,8 @@ mep_expand_prologue (void)\n \t    int be = TARGET_BIG_ENDIAN ? 4 : 0;\n \n \t    mem = gen_rtx_MEM (SImode,\n-\t\t\t       plus_constant (stack_pointer_rtx, sp_offset - rss + be));\n+\t\t\t       plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t      sp_offset - rss + be));\n \n \t    maybe_dead_move (gen_rtx_REG (SImode, REGSAVE_CONTROL_TEMP),\n \t\t\t     gen_rtx_REG (SImode, i),\n@@ -2876,7 +2878,8 @@ mep_expand_prologue (void)\n \t\t\t\t       copy_rtx (mem),\n \t\t\t\t       gen_rtx_REG (rmode, i)));\n \t    mem = gen_rtx_MEM (SImode,\n-\t\t\t       plus_constant (stack_pointer_rtx, sp_offset - rss + (4-be)));\n+\t\t\t       plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t      sp_offset - rss + (4-be)));\n \t    insn = maybe_dead_move (mem,\n \t\t\t\t    gen_rtx_REG (SImode, REGSAVE_CONTROL_TEMP+1),\n \t\t\t\t    maybe_dead_p);\n@@ -3083,8 +3086,8 @@ mep_expand_epilogue (void)\n \tif (GR_REGNO_P (i) || LOADABLE_CR_REGNO_P (i))\n \t  emit_move_insn (gen_rtx_REG (rmode, i),\n \t\t\t  gen_rtx_MEM (rmode,\n-\t\t\t\t       plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t      sp_offset-rss)));\n+\t\t\t\t       plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t      sp_offset - rss)));\n \telse\n \t  {\n \t    if (i == LP_REGNO && !mep_sibcall_epilogue && !interrupt_handler)\n@@ -3096,7 +3099,8 @@ mep_expand_epilogue (void)\n \t      {\n \t\temit_move_insn (gen_rtx_REG (rmode, REGSAVE_CONTROL_TEMP),\n \t\t\t\tgen_rtx_MEM (rmode,\n-\t\t\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t     plus_constant (Pmode,\n+\t\t\t\t\t\t\t    stack_pointer_rtx,\n \t\t\t\t\t\t\t    sp_offset-rss)));\n \t\temit_move_insn (gen_rtx_REG (rmode, i),\n \t\t\t\tgen_rtx_REG (rmode, REGSAVE_CONTROL_TEMP));\n@@ -3109,7 +3113,7 @@ mep_expand_epilogue (void)\n \t register when we return by jumping indirectly via the temp.  */\n       emit_move_insn (gen_rtx_REG (SImode, REGSAVE_CONTROL_TEMP),\n \t\t      gen_rtx_MEM (SImode,\n-\t\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t  lp_slot)));\n       lp_temp = REGSAVE_CONTROL_TEMP;\n     }"}, {"sha": "b170606bc7507c4c8a919e73b8c001dc02be2546", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -341,7 +341,8 @@ double_memory_operand (rtx op, enum machine_mode mode)\n     return 1;\n \n   return memory_address_p ((GET_MODE_CLASS (mode) == MODE_INT\n-\t\t\t    ? SImode : SFmode), plus_constant (addr, 4));\n+\t\t\t    ? SImode : SFmode),\n+\t\t\t   plus_constant (Pmode, addr, 4));\n }\n \n /* Implement REG_OK_FOR_BASE_P -and- REG_OK_FOR_INDEX_P.  */\n@@ -808,8 +809,8 @@ microblaze_block_move_loop (rtx dest, rtx src, HOST_WIDE_INT length)\n   microblaze_block_move_straight (dest, src, MAX_MOVE_BYTES);\n \n   /* Move on to the next block.  */\n-  emit_move_insn (src_reg, plus_constant (src_reg, MAX_MOVE_BYTES));\n-  emit_move_insn (dest_reg, plus_constant (dest_reg, MAX_MOVE_BYTES));\n+  emit_move_insn (src_reg, plus_constant (Pmode, src_reg, MAX_MOVE_BYTES));\n+  emit_move_insn (dest_reg, plus_constant (Pmode, dest_reg, MAX_MOVE_BYTES));\n \n   /* Emit the test & branch.  */\n   emit_insn (gen_cbranchsi4 (gen_rtx_NE (SImode, src_reg, final_src),"}, {"sha": "1e09f28d9a272a0a18c4b4f01e8ecad51909064f", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -2569,7 +2569,7 @@ mips_strip_unspec_address (rtx op)\n \n   split_const (op, &base, &offset);\n   if (UNSPEC_ADDRESS_P (base))\n-    op = plus_constant (UNSPEC_ADDRESS (base), INTVAL (offset));\n+    op = plus_constant (Pmode, UNSPEC_ADDRESS (base), INTVAL (offset));\n   return op;\n }\n \n@@ -2808,7 +2808,7 @@ mips_add_offset (rtx temp, rtx reg, HOST_WIDE_INT offset)\n       high = mips_force_temporary (temp, high);\n       reg = mips_force_temporary (temp, gen_rtx_PLUS (Pmode, high, reg));\n     }\n-  return plus_constant (reg, offset);\n+  return plus_constant (Pmode, reg, offset);\n }\n \f\n /* The __tls_get_attr symbol.  */\n@@ -5392,7 +5392,7 @@ mips_setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n \t{\n \t  rtx ptr, mem;\n \n-\t  ptr = plus_constant (virtual_incoming_args_rtx,\n+\t  ptr = plus_constant (Pmode, virtual_incoming_args_rtx,\n \t\t\t       REG_PARM_STACK_SPACE (cfun->decl)\n \t\t\t       - gp_saved * UNITS_PER_WORD);\n \t  mem = gen_frame_mem (BLKmode, ptr);\n@@ -5421,7 +5421,7 @@ mips_setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n \t    {\n \t      rtx ptr, mem;\n \n-\t      ptr = plus_constant (virtual_incoming_args_rtx, off);\n+\t      ptr = plus_constant (Pmode, virtual_incoming_args_rtx, off);\n \t      mem = gen_frame_mem (mode, ptr);\n \t      set_mem_alias_set (mem, get_varargs_alias_set ());\n \t      mips_emit_move (mem, gen_rtx_REG (mode, FP_ARG_FIRST + i));\n@@ -5584,7 +5584,7 @@ mips_va_start (tree valist, rtx nextarg)\n     }\n   else\n     {\n-      nextarg = plus_constant (nextarg, -cfun->machine->varargs_size);\n+      nextarg = plus_constant (Pmode, nextarg, -cfun->machine->varargs_size);\n       std_expand_builtin_va_start (valist, nextarg);\n     }\n }\n@@ -6951,8 +6951,8 @@ mips_block_move_loop (rtx dest, rtx src, HOST_WIDE_INT length,\n   mips_block_move_straight (dest, src, bytes_per_iter);\n \n   /* Move on to the next block.  */\n-  mips_emit_move (src_reg, plus_constant (src_reg, bytes_per_iter));\n-  mips_emit_move (dest_reg, plus_constant (dest_reg, bytes_per_iter));\n+  mips_emit_move (src_reg, plus_constant (Pmode, src_reg, bytes_per_iter));\n+  mips_emit_move (dest_reg, plus_constant (Pmode, dest_reg, bytes_per_iter));\n \n   /* Emit the loop condition.  */\n   test = gen_rtx_NE (VOIDmode, src_reg, final_src);\n@@ -7892,7 +7892,7 @@ mips_print_operand (FILE *file, rtx op, int letter)\n \n \tcase MEM:\n \t  if (letter == 'D')\n-\t    output_address (plus_constant (XEXP (op, 0), 4));\n+\t    output_address (plus_constant (Pmode, XEXP (op, 0), 4));\n \t  else if (letter && letter != 'z')\n \t    output_operand_lossage (\"invalid use of '%%%c'\", letter);\n \t  else\n@@ -8751,7 +8751,8 @@ mips16e_save_restore_reg (bool restore_p, bool reg_parm_p,\n {\n   rtx reg, mem;\n \n-  mem = gen_frame_mem (SImode, plus_constant (stack_pointer_rtx, offset));\n+  mem = gen_frame_mem (SImode, plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t      offset));\n   reg = gen_rtx_REG (SImode, regno);\n   if (restore_p)\n     {\n@@ -8810,7 +8811,7 @@ mips16e_build_save_restore (bool restore_p, unsigned int *mask_ptr,\n \n   /* Add the stack pointer adjustment.  */\n   set = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t     plus_constant (stack_pointer_rtx,\n+\t\t     plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t    restore_p ? size : -size));\n   RTX_FRAME_RELATED_P (set) = 1;\n   XVECEXP (pattern, 0, n++) = set;\n@@ -9951,7 +9952,8 @@ mips_save_restore_reg (enum machine_mode mode, int regno,\n {\n   rtx mem;\n \n-  mem = gen_frame_mem (mode, plus_constant (stack_pointer_rtx, offset));\n+  mem = gen_frame_mem (mode, plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t    offset));\n   fn (gen_rtx_REG (mode, regno), mem);\n }\n \n@@ -10441,7 +10443,7 @@ mips_expand_prologue (void)\n \t\t{\n \t\t  /* Push EPC into its stack slot.  */\n \t\t  mem = gen_frame_mem (word_mode,\n-\t\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t       plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t      offset));\n \t\t  mips_emit_move (mem, gen_rtx_REG (word_mode, K1_REG_NUM));\n \t\t  offset -= UNITS_PER_WORD;\n@@ -10460,7 +10462,8 @@ mips_expand_prologue (void)\n \n \t      /* Push Status into its stack slot.  */\n \t      mem = gen_frame_mem (word_mode,\n-\t\t\t\t   plus_constant (stack_pointer_rtx, offset));\n+\t\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t  offset));\n \t      mips_emit_move (mem, gen_rtx_REG (word_mode, K1_REG_NUM));\n \t      offset -= UNITS_PER_WORD;\n \n@@ -10532,7 +10535,7 @@ mips_expand_prologue (void)\n \t  /* Describe the combined effect of the previous instructions.  */\n \t  mips_set_frame_expr\n \t    (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t  plus_constant (stack_pointer_rtx, -size)));\n+\t\t\t  plus_constant (Pmode, stack_pointer_rtx, -size)));\n \t}\n       mips_frame_barrier ();\n     }\n@@ -10563,7 +10566,7 @@ mips_expand_prologue (void)\n \t\t\t\t    MIPS_PROLOGUE_TEMP (Pmode)));\n \t  mips_set_frame_expr\n \t    (gen_rtx_SET (VOIDmode, hard_frame_pointer_rtx,\n-\t\t\t  plus_constant (stack_pointer_rtx, offset)));\n+\t\t\t  plus_constant (Pmode, stack_pointer_rtx, offset)));\n \t}\n     }\n \n@@ -10576,7 +10579,7 @@ mips_expand_prologue (void)\n       HOST_WIDE_INT offset;\n \n       mips_get_cprestore_base_and_offset (&base, &offset, false);\n-      mem = gen_frame_mem (Pmode, plus_constant (base, offset));\n+      mem = gen_frame_mem (Pmode, plus_constant (Pmode, base, offset));\n       gp = TARGET_MIPS16 ? MIPS16_PIC_TEMP : pic_offset_table_rtx;\n       temp = (SMALL_OPERAND (offset)\n \t      ? gen_rtx_SCRATCH (Pmode)\n@@ -10585,7 +10588,7 @@ mips_expand_prologue (void)\n \t\t\t     (mem, GEN_INT (offset), gp, temp)));\n \n       mips_get_cprestore_base_and_offset (&base, &offset, true);\n-      mem = gen_frame_mem (Pmode, plus_constant (base, offset));\n+      mem = gen_frame_mem (Pmode, plus_constant (Pmode, base, offset));\n       emit_insn (PMODE_INSN (gen_use_cprestore, (mem)));\n     }\n \n@@ -10641,7 +10644,7 @@ mips_epilogue_set_cfa (rtx reg, HOST_WIDE_INT offset)\n     {\n       RTX_FRAME_RELATED_P (insn) = 1;\n       REG_NOTES (insn) = alloc_reg_note (REG_CFA_DEF_CFA,\n-\t\t\t\t\t plus_constant (reg, offset),\n+\t\t\t\t\t plus_constant (Pmode, reg, offset),\n \t\t\t\t\t REG_NOTES (insn));\n       mips_epilogue.cfa_reg = reg;\n       mips_epilogue.cfa_offset = offset;\n@@ -10830,7 +10833,8 @@ mips_expand_epilogue (bool sibcall_p)\n \t    {\n \t      /* Restore the original EPC.  */\n \t      mem = gen_frame_mem (word_mode,\n-\t\t\t\t   plus_constant (stack_pointer_rtx, offset));\n+\t\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t  offset));\n \t      mips_emit_move (gen_rtx_REG (word_mode, K0_REG_NUM), mem);\n \t      offset -= UNITS_PER_WORD;\n \n@@ -10841,7 +10845,8 @@ mips_expand_epilogue (bool sibcall_p)\n \n \t  /* Restore the original Status.  */\n \t  mem = gen_frame_mem (word_mode,\n-\t\t\t       plus_constant (stack_pointer_rtx, offset));\n+\t\t\t       plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t      offset));\n \t  mips_emit_move (gen_rtx_REG (word_mode, K0_REG_NUM), mem);\n \t  offset -= UNITS_PER_WORD;\n "}, {"sha": "912dccb5ee0c54c3918f79c1562e4f9f33f35b9b", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -5756,7 +5756,7 @@\n {\n   rtx addr;\n \n-  addr = plus_constant (operands[0], GET_MODE_SIZE (Pmode) * 3);\n+  addr = plus_constant (Pmode, operands[0], GET_MODE_SIZE (Pmode) * 3);\n   mips_emit_move (gen_rtx_MEM (Pmode, addr), pic_offset_table_rtx);\n   DONE;\n })\n@@ -5772,9 +5772,9 @@\n   /* The elements of the buffer are, in order:  */\n   int W = GET_MODE_SIZE (Pmode);\n   rtx fp = gen_rtx_MEM (Pmode, operands[0]);\n-  rtx lab = gen_rtx_MEM (Pmode, plus_constant (operands[0], 1*W));\n-  rtx stack = gen_rtx_MEM (Pmode, plus_constant (operands[0], 2*W));\n-  rtx gpv = gen_rtx_MEM (Pmode, plus_constant (operands[0], 3*W));\n+  rtx lab = gen_rtx_MEM (Pmode, plus_constant (Pmode, operands[0], 1*W));\n+  rtx stack = gen_rtx_MEM (Pmode, plus_constant (Pmode, operands[0], 2*W));\n+  rtx gpv = gen_rtx_MEM (Pmode, plus_constant (Pmode, operands[0], 3*W));\n   rtx pv = gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM);\n   /* Use gen_raw_REG to avoid being given pic_offset_table_rtx.\n      The target is bound to be using $28 as the global pointer"}, {"sha": "8f801e6c7cae5413f0e8f17f13ac8b4a55370b16", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -550,7 +550,7 @@ mmix_dynamic_chain_address (rtx frame)\n      frame-pointer.  Unfortunately, the caller assumes that a\n      frame-pointer is present for *all* previous frames.  There should be\n      a way to say that that cannot be done, like for RETURN_ADDR_RTX.  */\n-  return plus_constant (frame, -8);\n+  return plus_constant (Pmode, frame, -8);\n }\n \n /* STARTING_FRAME_OFFSET.  */\n@@ -581,7 +581,9 @@ mmix_return_addr_rtx (int count, rtx frame ATTRIBUTE_UNUSED)\n \t  See mmix_initial_elimination_offset for the reason we can't use\n \t  get_hard_reg_initial_val for both.  Always using a stack slot\n \t  and not a register would be suboptimal.  */\n-       ? validize_mem (gen_rtx_MEM (Pmode, plus_constant (frame_pointer_rtx, -16)))\n+       ? validize_mem (gen_rtx_MEM (Pmode,\n+\t\t\t\t    plus_constant (Pmode,\n+\t\t\t\t\t\t   frame_pointer_rtx, -16)))\n        : get_hard_reg_initial_val (Pmode, MMIX_INCOMING_RETURN_ADDRESS_REGNUM))\n     : NULL_RTX;\n }\n@@ -2063,7 +2065,7 @@ mmix_expand_prologue (void)\n \t  /* These registers aren't actually saved (as in \"will be\n \t     restored\"), so don't tell DWARF2 they're saved.  */\n \t  emit_move_insn (gen_rtx_MEM (DImode,\n-\t\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t       plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t      offset)),\n \t\t\t  gen_rtx_REG (DImode, regno));\n \t  offset -= 8;\n@@ -2090,7 +2092,8 @@ mmix_expand_prologue (void)\n \t}\n \n       insn = emit_move_insn (gen_rtx_MEM (DImode,\n-\t\t\t\t\t  plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t  plus_constant (Pmode,\n+\t\t\t\t\t\t\t stack_pointer_rtx,\n \t\t\t\t\t\t\t offset)),\n \t\t\t     hard_frame_pointer_rtx);\n       RTX_FRAME_RELATED_P (insn) = 1;\n@@ -2132,14 +2135,16 @@ mmix_expand_prologue (void)\n       emit_move_insn (tmpreg, retreg);\n \n       insn = emit_move_insn (gen_rtx_MEM (DImode,\n-\t\t\t\t\t  plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t  plus_constant (Pmode,\n+\t\t\t\t\t\t\t stack_pointer_rtx,\n \t\t\t\t\t\t\t offset)),\n \t\t\t     tmpreg);\n       RTX_FRAME_RELATED_P (insn) = 1;\n       add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n \t\t    gen_rtx_SET (VOIDmode,\n \t\t\t\t gen_rtx_MEM (DImode,\n-\t\t\t\t\t      plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t      plus_constant (Pmode,\n+\t\t\t\t\t\t\t     stack_pointer_rtx,\n \t\t\t\t\t\t\t     offset)),\n \t\t\t\t retreg));\n \n@@ -2179,7 +2184,8 @@ mmix_expand_prologue (void)\n \t\t      gen_rtx_REG (DImode,\n \t\t\t\t   MMIX_rO_REGNUM));\n       emit_move_insn (gen_rtx_MEM (DImode,\n-\t\t\t\t   plus_constant (stack_pointer_rtx, offset)),\n+\t\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t  offset)),\n \t\t      gen_rtx_REG (DImode, 255));\n       offset -= 8;\n     }\n@@ -2215,7 +2221,8 @@ mmix_expand_prologue (void)\n \t  }\n \n \tinsn = emit_move_insn (gen_rtx_MEM (DImode,\n-\t\t\t\t\t    plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t    plus_constant (Pmode,\n+\t\t\t\t\t\t\t   stack_pointer_rtx,\n \t\t\t\t\t\t\t   offset)),\n \t\t\t       gen_rtx_REG (DImode, regno));\n \tRTX_FRAME_RELATED_P (insn) = 1;\n@@ -2291,7 +2298,7 @@ mmix_expand_epilogue (void)\n \n \temit_move_insn (gen_rtx_REG (DImode, regno),\n \t\t\tgen_rtx_MEM (DImode,\n-\t\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t     plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t    offset)));\n \toffset += 8;\n       }\n@@ -2323,7 +2330,7 @@ mmix_expand_epilogue (void)\n \n       emit_move_insn (hard_frame_pointer_rtx,\n \t\t      gen_rtx_MEM (DImode,\n-\t\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t  offset)));\n       offset += 8;\n     }"}, {"sha": "1554f94644c16277c61033a43984f8b487d7916b", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -711,7 +711,7 @@ mn10300_gen_multiple_store (unsigned int mask)\n \tcontinue;\n \n       ++count;\n-      x = plus_constant (stack_pointer_rtx, count * -4);\n+      x = plus_constant (Pmode, stack_pointer_rtx, count * -4);\n       x = gen_frame_mem (SImode, x);\n       x = gen_rtx_SET (VOIDmode, x, gen_rtx_REG (SImode, regno));\n       elts[count] = F(x);\n@@ -725,7 +725,7 @@ mn10300_gen_multiple_store (unsigned int mask)\n   gcc_assert (mask == 0);\n \n   /* Create the instruction that updates the stack pointer.  */\n-  x = plus_constant (stack_pointer_rtx, count * -4);\n+  x = plus_constant (Pmode, stack_pointer_rtx, count * -4);\n   x = gen_rtx_SET (VOIDmode, stack_pointer_rtx, x);\n   elts[0] = F(x);\n \n@@ -1464,7 +1464,7 @@ mn10300_builtin_saveregs (void)\n   alias_set_type set = get_varargs_alias_set ();\n \n   if (argadj)\n-    offset = plus_constant (crtl->args.arg_offset_rtx, argadj);\n+    offset = plus_constant (Pmode, crtl->args.arg_offset_rtx, argadj);\n   else\n     offset = crtl->args.arg_offset_rtx;\n \n@@ -1473,7 +1473,8 @@ mn10300_builtin_saveregs (void)\n   emit_move_insn (mem, gen_rtx_REG (SImode, 0));\n \n   mem = gen_rtx_MEM (SImode,\n-\t\t     plus_constant (crtl->args.internal_arg_pointer, 4));\n+\t\t     plus_constant (Pmode,\n+\t\t\t\t    crtl->args.internal_arg_pointer, 4));\n   set_mem_alias_set (mem, set);\n   emit_move_insn (mem, gen_rtx_REG (SImode, 1));\n \n@@ -2516,7 +2517,7 @@ mn10300_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n      clobber the flags but do not affect the contents of D0 or D1.  */\n \n   disp = expand_binop (SImode, sub_optab, fnaddr,\n-\t\t       plus_constant (XEXP (m_tramp, 0), 11),\n+\t\t       plus_constant (Pmode, XEXP (m_tramp, 0), 11),\n \t\t       NULL_RTX, 1, OPTAB_DIRECT);\n \n   mem = adjust_address (m_tramp, SImode, 0);"}, {"sha": "8d40412d095bf3da5f4da5a6f0aac7c5767bf454", "filename": "gcc/config/moxie/moxie.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -504,9 +504,9 @@ moxie_static_chain (const_tree fndecl, bool incoming_p)\n     return NULL;\n \n   if (incoming_p)\n-    addr = plus_constant (arg_pointer_rtx, 2 * UNITS_PER_WORD);\n+    addr = plus_constant (Pmode, arg_pointer_rtx, 2 * UNITS_PER_WORD);\n   else\n-    addr = plus_constant (stack_pointer_rtx, -UNITS_PER_WORD);\n+    addr = plus_constant (Pmode, stack_pointer_rtx, -UNITS_PER_WORD);\n \n   mem = gen_rtx_MEM (Pmode, addr);\n   MEM_NOTRAP_P (mem) = 1;"}, {"sha": "c80d26c5ae98126373fd432a6448fde43789ad67", "filename": "gcc/config/moxie/moxie.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmoxie%2Fmoxie.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fmoxie%2Fmoxie.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.h?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -278,15 +278,15 @@ enum reg_class\n    the prologue.  */\n #define INCOMING_RETURN_ADDR_RTX\t\t\t\t\t\\\n   gen_frame_mem (Pmode,\t\t\t\t\t\t\t\\\n-\t\t plus_constant (stack_pointer_rtx, UNITS_PER_WORD))\n+\t\t plus_constant (Pmode, stack_pointer_rtx, UNITS_PER_WORD))\n \n /* Describe how we implement __builtin_eh_return.  */\n #define EH_RETURN_DATA_REGNO(N)\t((N) < 4 ? (N+2) : INVALID_REGNUM)\n \n /* Store the return handler into the call frame.  */\n #define EH_RETURN_HANDLER_RTX\t\t\t\t\t\t\\\n   gen_frame_mem (Pmode,\t\t\t\t\t\t\t\\\n-\t\t plus_constant (frame_pointer_rtx, UNITS_PER_WORD))\n+\t\t plus_constant (Pmode, frame_pointer_rtx, UNITS_PER_WORD))\n \n /* Storage Layout */\n "}, {"sha": "56c889db88cc31de46f5ab66a61826070bd2131a", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -863,7 +863,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n       if (GET_CODE (orig) == CONST_INT)\n \t{\n \t  if (INT_14_BITS (orig))\n-\t    return plus_constant (base, INTVAL (orig));\n+\t    return plus_constant (Pmode, base, INTVAL (orig));\n \t  orig = force_reg (Pmode, orig);\n \t}\n       pic_ref = gen_rtx_PLUS (Pmode, base, orig);\n@@ -1073,7 +1073,7 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       if (! VAL_14_BITS_P (newoffset)\n \t  && GET_CODE (XEXP (x, 0)) == SYMBOL_REF)\n \t{\n-\t  rtx const_part = plus_constant (XEXP (x, 0), newoffset);\n+\t  rtx const_part = plus_constant (Pmode, XEXP (x, 0), newoffset);\n \t  rtx tmp_reg\n \t    = force_reg (Pmode,\n \t\t\t gen_rtx_HIGH (Pmode, const_part));\n@@ -1094,7 +1094,7 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t\t\t\t\t     force_reg (Pmode, XEXP (x, 0)),\n \t\t\t\t\t     int_part));\n \t}\n-      return plus_constant (ptr_reg, offset - newoffset);\n+      return plus_constant (Pmode, ptr_reg, offset - newoffset);\n     }\n \n   /* Handle (plus (mult (a) (shadd_constant)) (b)).  */\n@@ -3484,7 +3484,7 @@ store_reg (int reg, HOST_WIDE_INT disp, int base)\n   basereg = gen_rtx_REG (Pmode, base);\n   if (VAL_14_BITS_P (disp))\n     {\n-      dest = gen_rtx_MEM (word_mode, plus_constant (basereg, disp));\n+      dest = gen_rtx_MEM (word_mode, plus_constant (Pmode, basereg, disp));\n       insn = emit_move_insn (dest, src);\n     }\n   else if (TARGET_64BIT && !VAL_32_BITS_P (disp))\n@@ -3568,7 +3568,8 @@ set_reg_plus_d (int reg, int base, HOST_WIDE_INT disp, int note)\n   if (VAL_14_BITS_P (disp))\n     {\n       insn = emit_move_insn (gen_rtx_REG (Pmode, reg),\n-\t\t\t     plus_constant (gen_rtx_REG (Pmode, base), disp));\n+\t\t\t     plus_constant (Pmode,\n+\t\t\t\t\t    gen_rtx_REG (Pmode, base), disp));\n     }\n   else if (TARGET_64BIT && !VAL_32_BITS_P (disp))\n     {\n@@ -4007,16 +4008,19 @@ pa_expand_prologue (void)\n \t\t  if (TARGET_64BIT)\n \t\t    {\n \t\t      rtx mem = gen_rtx_MEM (DFmode,\n-\t\t\t\t\t     plus_constant (base, offset));\n+\t\t\t\t\t     plus_constant (Pmode, base,\n+\t\t\t\t\t\t\t    offset));\n \t\t      add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n \t\t\t\t    gen_rtx_SET (VOIDmode, mem, reg));\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      rtx meml = gen_rtx_MEM (SFmode,\n-\t\t\t\t\t      plus_constant (base, offset));\n+\t\t\t\t\t      plus_constant (Pmode, base,\n+\t\t\t\t\t\t\t     offset));\n \t\t      rtx memr = gen_rtx_MEM (SFmode,\n-\t\t\t\t\t      plus_constant (base, offset + 4));\n+\t\t\t\t\t      plus_constant (Pmode, base,\n+\t\t\t\t\t\t\t     offset + 4));\n \t\t      rtx regl = gen_rtx_REG (SFmode, i);\n \t\t      rtx regr = gen_rtx_REG (SFmode, i + 1);\n \t\t      rtx setl = gen_rtx_SET (VOIDmode, meml, regl);\n@@ -4048,7 +4052,7 @@ load_reg (int reg, HOST_WIDE_INT disp, int base)\n   rtx src;\n \n   if (VAL_14_BITS_P (disp))\n-    src = gen_rtx_MEM (word_mode, plus_constant (basereg, disp));\n+    src = gen_rtx_MEM (word_mode, plus_constant (Pmode, basereg, disp));\n   else if (TARGET_64BIT && !VAL_32_BITS_P (disp))\n     {\n       rtx delta = GEN_INT (disp);\n@@ -4562,7 +4566,7 @@ pa_return_addr_rtx (int count, rtx frameaddr)\n \n   for (i = 0; i < len; i++)\n     {\n-      rtx op0 = gen_rtx_MEM (SImode, plus_constant (ins, i * 4)); \n+      rtx op0 = gen_rtx_MEM (SImode, plus_constant (Pmode, ins, i * 4));\n       rtx op1 = GEN_INT (insns[i]);\n       emit_cmp_and_jump_insns (op0, op1, NE, NULL, SImode, 0, label);\n     }\n@@ -4575,7 +4579,7 @@ pa_return_addr_rtx (int count, rtx frameaddr)\n   emit_move_insn (saved_rp,\n \t\t  gen_rtx_MEM (Pmode,\n \t\t\t       memory_address (Pmode,\n-\t\t\t\t\t       plus_constant (frameaddr,\n+\t\t\t\t\t       plus_constant (Pmode, frameaddr,\n \t\t\t\t\t\t\t      -24))));\n \n   emit_label (label);\n@@ -6080,7 +6084,7 @@ hppa_builtin_saveregs (void)\n \t\t? UNITS_PER_WORD : 0);\n \n   if (argadj)\n-    offset = plus_constant (crtl->args.arg_offset_rtx, argadj);\n+    offset = plus_constant (Pmode, crtl->args.arg_offset_rtx, argadj);\n   else\n     offset = crtl->args.arg_offset_rtx;\n \n@@ -6090,23 +6094,24 @@ hppa_builtin_saveregs (void)\n \n       /* Adjust for varargs/stdarg differences.  */\n       if (argadj)\n-\toffset = plus_constant (crtl->args.arg_offset_rtx, -argadj);\n+\toffset = plus_constant (Pmode, crtl->args.arg_offset_rtx, -argadj);\n       else\n \toffset = crtl->args.arg_offset_rtx;\n \n       /* We need to save %r26 .. %r19 inclusive starting at offset -64\n \t from the incoming arg pointer and growing to larger addresses.  */\n       for (i = 26, off = -64; i >= 19; i--, off += 8)\n \temit_move_insn (gen_rtx_MEM (word_mode,\n-\t\t\t\t     plus_constant (arg_pointer_rtx, off)),\n+\t\t\t\t     plus_constant (Pmode,\n+\t\t\t\t\t\t    arg_pointer_rtx, off)),\n \t\t\tgen_rtx_REG (word_mode, i));\n \n       /* The incoming args pointer points just beyond the flushback area;\n \t normally this is not a serious concern.  However, when we are doing\n \t varargs/stdargs we want to make the arg pointer point to the start\n \t of the incoming argument area.  */\n       emit_move_insn (virtual_incoming_args_rtx,\n-\t\t      plus_constant (arg_pointer_rtx, -64));\n+\t\t      plus_constant (Pmode, arg_pointer_rtx, -64));\n \n       /* Now return a pointer to the first anonymous argument.  */\n       return copy_to_reg (expand_binop (Pmode, add_optab,\n@@ -6116,7 +6121,7 @@ hppa_builtin_saveregs (void)\n \n   /* Store general registers on the stack.  */\n   dest = gen_rtx_MEM (BLKmode,\n-\t\t      plus_constant (crtl->args.internal_arg_pointer,\n+\t\t      plus_constant (Pmode, crtl->args.internal_arg_pointer,\n \t\t\t\t     -16));\n   set_mem_alias_set (dest, get_varargs_alias_set ());\n   set_mem_align (dest, BITS_PER_WORD);\n@@ -10126,7 +10131,8 @@ pa_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n \t cache lines to minimize the number of lines flushed.  */\n       emit_insn (gen_andsi3 (start_addr, r_tramp,\n \t\t\t     GEN_INT (-MIN_CACHELINE_SIZE)));\n-      tmp = force_reg (Pmode, plus_constant (r_tramp, TRAMPOLINE_CODE_SIZE-1));\n+      tmp = force_reg (Pmode, plus_constant (Pmode, r_tramp,\n+\t\t\t\t\t     TRAMPOLINE_CODE_SIZE-1));\n       emit_insn (gen_andsi3 (end_addr, tmp,\n \t\t\t     GEN_INT (-MIN_CACHELINE_SIZE)));\n       emit_move_insn (line_length, GEN_INT (MIN_CACHELINE_SIZE));\n@@ -10144,18 +10150,20 @@ pa_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n \n       /* Create a fat pointer for the trampoline.  */\n       tmp = adjust_address (m_tramp, Pmode, 16);\n-      emit_move_insn (tmp, force_reg (Pmode, plus_constant (r_tramp, 32)));\n+      emit_move_insn (tmp, force_reg (Pmode, plus_constant (Pmode,\n+\t\t\t\t\t\t\t    r_tramp, 32)));\n       tmp = adjust_address (m_tramp, Pmode, 24);\n       emit_move_insn (tmp, gen_rtx_REG (Pmode, 27));\n \n       /* fdc and fic only use registers for the address to flush,\n \t they do not accept integer displacements.  We align the\n \t start and end addresses to the beginning of their respective\n \t cache lines to minimize the number of lines flushed.  */\n-      tmp = force_reg (Pmode, plus_constant (r_tramp, 32));\n+      tmp = force_reg (Pmode, plus_constant (Pmode, r_tramp, 32));\n       emit_insn (gen_anddi3 (start_addr, tmp,\n \t\t\t     GEN_INT (-MIN_CACHELINE_SIZE)));\n-      tmp = force_reg (Pmode, plus_constant (tmp, TRAMPOLINE_CODE_SIZE - 1));\n+      tmp = force_reg (Pmode, plus_constant (Pmode, tmp,\n+\t\t\t\t\t     TRAMPOLINE_CODE_SIZE - 1));\n       emit_insn (gen_anddi3 (end_addr, tmp,\n \t\t\t     GEN_INT (-MIN_CACHELINE_SIZE)));\n       emit_move_insn (line_length, GEN_INT (MIN_CACHELINE_SIZE));\n@@ -10174,7 +10182,7 @@ static rtx\n pa_trampoline_adjust_address (rtx addr)\n {\n   if (!TARGET_64BIT)\n-    addr = memory_address (Pmode, plus_constant (addr, 46));\n+    addr = memory_address (Pmode, plus_constant (Pmode, addr, 46));\n   return addr;\n }\n "}, {"sha": "d0110e798688e6279a17da99f7be53bc55b057c2", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -6870,7 +6870,7 @@\n      of the virtual stack variables and the hard frame pointer.  */\n   if (GET_CODE (fp) != REG)\n     fp = force_reg (Pmode, fp);\n-  emit_move_insn (hard_frame_pointer_rtx, plus_constant (fp, -8));\n+  emit_move_insn (hard_frame_pointer_rtx, plus_constant (Pmode, fp, -8));\n \n   emit_stack_restore (SAVE_NONLOCAL, stack);\n \n@@ -8300,9 +8300,9 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n {\n   /* The elements of the buffer are, in order:  */\n   rtx fp = gen_rtx_MEM (Pmode, operands[0]);\n-  rtx lab = gen_rtx_MEM (Pmode, plus_constant (operands[0],\n+  rtx lab = gen_rtx_MEM (Pmode, plus_constant (Pmode, operands[0],\n \t\t\t POINTER_SIZE / BITS_PER_UNIT));\n-  rtx stack = gen_rtx_MEM (Pmode, plus_constant (operands[0],\n+  rtx stack = gen_rtx_MEM (Pmode, plus_constant (Pmode, operands[0],\n \t\t\t   (POINTER_SIZE * 2) / BITS_PER_UNIT));\n   rtx pv = gen_rtx_REG (Pmode, 1);\n \n@@ -8314,7 +8314,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n      to adjust for the offset between these two values.  */\n   if (GET_CODE (fp) != REG)\n     fp = force_reg (Pmode, fp);\n-  emit_move_insn (hard_frame_pointer_rtx, plus_constant (fp, -8));\n+  emit_move_insn (hard_frame_pointer_rtx, plus_constant (Pmode, fp, -8));\n \n   /* This bit is the same as expand_builtin_longjmp.  */\n   emit_stack_restore (SAVE_NONLOCAL, stack);"}, {"sha": "85ea46abfa771ebeabf7e7ba5941570222c0692e", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -389,7 +389,7 @@ pdp11_expand_epilogue (void)\n       for (regno = AC5_REGNUM; regno >= AC0_REGNUM; regno--)\n \tif (pdp11_saved_regno (regno))\n \t  {\n-\t    x = plus_constant (hard_frame_pointer_rtx, ofs);\n+\t    x = plus_constant (Pmode, hard_frame_pointer_rtx, ofs);\n \t    x = gen_frame_mem (DFmode, x);\n \t    reg = gen_rtx_REG (DFmode, regno);\n \n@@ -407,7 +407,7 @@ pdp11_expand_epilogue (void)\n \tif (pdp11_saved_regno (regno)\n \t    && (regno != HARD_FRAME_POINTER_REGNUM || !frame_pointer_needed))\n \t  {\n-\t    x = plus_constant (hard_frame_pointer_rtx, ofs);\n+\t    x = plus_constant (Pmode, hard_frame_pointer_rtx, ofs);\n \t    x = gen_frame_mem (Pmode, x);\n \t    emit_move_insn (gen_rtx_REG (Pmode, regno), x);\n \t    ofs += 2;"}, {"sha": "57cbd157f4174bbcf07abc9482833a182f97053e", "filename": "gcc/config/picochip/picochip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -4696,6 +4696,6 @@ picochip_static_chain (const_tree ARG_UNUSED (fndecl), bool incoming_p)\n   if (incoming_p)\n     addr = arg_pointer_rtx;\n   else\n-    addr = plus_constant (stack_pointer_rtx, -2 * UNITS_PER_WORD);\n+    addr = plus_constant (Pmode, stack_pointer_rtx, -2 * UNITS_PER_WORD);\n   return gen_frame_mem (Pmode, addr);\n }"}, {"sha": "9b6d898dfb49efe60b892a7b6cbe100f5f81a549", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -5594,7 +5594,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       high_int = INTVAL (XEXP (x, 1)) - low_int;\n       sum = force_operand (gen_rtx_PLUS (Pmode, XEXP (x, 0),\n \t\t\t\t\t GEN_INT (high_int)), 0);\n-      return plus_constant (sum, low_int);\n+      return plus_constant (Pmode, sum, low_int);\n     }\n   else if (GET_CODE (x) == PLUS\n \t   && GET_CODE (XEXP (x, 0)) == REG\n@@ -8951,7 +8951,7 @@ setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n \t    }\n \n \t  cfun->machine->varargs_save_offset = offset;\n-\t  save_area = plus_constant (virtual_stack_vars_rtx, offset);\n+\t  save_area = plus_constant (Pmode, virtual_stack_vars_rtx, offset);\n \t}\n     }\n   else\n@@ -8983,7 +8983,7 @@ setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n \t}\n \n       mem = gen_rtx_MEM (BLKmode,\n-\t\t\t plus_constant (save_area,\n+\t\t\t plus_constant (Pmode, save_area,\n \t\t\t\t\tfirst_reg_offset * reg_size));\n       MEM_NOTRAP_P (mem) = 1;\n       set_mem_alias_set (mem, set);\n@@ -9021,7 +9021,7 @@ setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n \t{\n \t  mem = gen_rtx_MEM ((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n \t\t\t      ? DFmode : SFmode, \n-                             plus_constant (save_area, off));\n+                             plus_constant (Pmode, save_area, off));\n   \t  MEM_NOTRAP_P (mem) = 1;\n   \t  set_mem_alias_set (mem, set);\n \t  set_mem_align (mem, GET_MODE_ALIGNMENT (\n@@ -14832,10 +14832,10 @@ print_operand (FILE *file, rtx x, int code)\n \t     we have already done it, we can just use an offset of word.  */\n \t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n \t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n-\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0),\n+\t    output_address (plus_constant (Pmode, XEXP (XEXP (x, 0), 0),\n \t\t\t\t\t   UNITS_PER_WORD));\n \t  else if (GET_CODE (XEXP (x, 0)) == PRE_MODIFY)\n-\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0),\n+\t    output_address (plus_constant (Pmode, XEXP (XEXP (x, 0), 0),\n \t\t\t\t\t   UNITS_PER_WORD));\n \t  else\n \t    output_address (XEXP (adjust_address_nv (x, SImode,\n@@ -15159,9 +15159,9 @@ print_operand (FILE *file, rtx x, int code)\n \t{\n \t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n \t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n-\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 8));\n+\t    output_address (plus_constant (Pmode, XEXP (XEXP (x, 0), 0), 8));\n \t  else if (GET_CODE (XEXP (x, 0)) == PRE_MODIFY)\n-\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 8));\n+\t    output_address (plus_constant (Pmode, XEXP (XEXP (x, 0), 0), 8));\n \t  else\n \t    output_address (XEXP (adjust_address_nv (x, SImode, 8), 0));\n \t  if (small_data_operand (x, GET_MODE (x)))\n@@ -15209,9 +15209,9 @@ print_operand (FILE *file, rtx x, int code)\n \t{\n \t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n \t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n-\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 12));\n+\t    output_address (plus_constant (Pmode, XEXP (XEXP (x, 0), 0), 12));\n \t  else if (GET_CODE (XEXP (x, 0)) == PRE_MODIFY)\n-\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 12));\n+\t    output_address (plus_constant (Pmode, XEXP (XEXP (x, 0), 0), 12));\n \t  else\n \t    output_address (XEXP (adjust_address_nv (x, SImode, 12), 0));\n \t  if (small_data_operand (x, GET_MODE (x)))\n@@ -18161,7 +18161,8 @@ rs6000_return_addr (int count, rtx frame)\n \t  (Pmode,\n \t   memory_address\n \t   (Pmode,\n-\t    plus_constant (copy_to_reg\n+\t    plus_constant (Pmode,\n+\t\t\t   copy_to_reg\n \t\t\t   (gen_rtx_MEM (Pmode,\n \t\t\t\t\t memory_address (Pmode, frame))),\n \t\t\t   RETURN_ADDRESS_OFFSET)));\n@@ -18431,7 +18432,8 @@ rs6000_emit_eh_reg_restore (rtx source, rtx scratch)\n       else if (info->push_p)\n \tsp_offset = info->total_size;\n \n-      tmp = plus_constant (frame_rtx, info->lr_save_offset + sp_offset);\n+      tmp = plus_constant (Pmode, frame_rtx,\n+\t\t\t   info->lr_save_offset + sp_offset);\n       tmp = gen_frame_mem (Pmode, tmp);\n       emit_move_insn (tmp, operands[0]);\n     }\n@@ -18679,9 +18681,11 @@ rs6000_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n \t it exceeds SIZE.  If only one probe is needed, this will not\n \t generate any code.  Then probe at FIRST + SIZE.  */\n       for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)\n-\temit_stack_probe (plus_constant (stack_pointer_rtx, -(first + i)));\n+\temit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t -(first + i)));\n \n-      emit_stack_probe (plus_constant (stack_pointer_rtx, -(first + size)));\n+      emit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t       -(first + size)));\n     }\n \n   /* Otherwise, do the same as above, but in a loop.  Note that we must be\n@@ -18707,7 +18711,8 @@ rs6000_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n \n       /* TEST_ADDR = SP + FIRST.  */\n       emit_insn (gen_rtx_SET (VOIDmode, r12,\n-\t\t\t      plus_constant (stack_pointer_rtx, -first)));\n+\t\t\t      plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t     -first)));\n \n       /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */\n       if (rounded_size > 32768)\n@@ -18718,7 +18723,7 @@ rs6000_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n \t}\n       else\n \temit_insn (gen_rtx_SET (VOIDmode, r0,\n-\t\t\t        plus_constant (r12, -rounded_size)));\n+\t\t\t        plus_constant (Pmode, r12, -rounded_size)));\n \n \n       /* Step 3: the loop\n@@ -18742,7 +18747,7 @@ rs6000_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n \t that SIZE is equal to ROUNDED_SIZE.  */\n \n       if (size != rounded_size)\n-\temit_stack_probe (plus_constant (r12, rounded_size - size));\n+\temit_stack_probe (plus_constant (Pmode, r12, rounded_size - size));\n     }\n }\n \n@@ -21111,7 +21116,7 @@ rs6000_emit_epilogue (int sibcall)\n \t{\n \t  insn = get_last_insn ();\n \t  add_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\t\tplus_constant (frame_reg_rtx, frame_off));\n+\t\t\tplus_constant (Pmode, frame_reg_rtx, frame_off));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n \n@@ -25176,7 +25181,7 @@ rs6000_machopic_legitimize_pic_address (rtx orig, enum machine_mode mode,\n       if (GET_CODE (offset) == CONST_INT)\n \t{\n \t  if (SMALL_INT (offset))\n-\t    return plus_constant (base, INTVAL (offset));\n+\t    return plus_constant (Pmode, base, INTVAL (offset));\n \t  else if (! reload_in_progress && ! reload_completed)\n \t    offset = force_reg (Pmode, offset);\n \t  else"}, {"sha": "c69a209fc8a48c19bdc7962cd06e779fdbc799e6", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1394,7 +1394,7 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n \n /* MEM representing address to save the TOC register */\n #define RS6000_SAVE_TOC gen_rtx_MEM (Pmode, \\\n-\t\t\t\t     plus_constant (stack_pointer_rtx, \\\n+\t\t\t\t     plus_constant (Pmode, stack_pointer_rtx, \\\n \t\t\t\t\t\t    (TARGET_32BIT ? 20 : 40)))\n \n /* Align an address */"}, {"sha": "016c34827ce5ca74ef2d7457e7a1eff25a2c2965", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1779,15 +1779,15 @@ gen_rx_rtsd_vector (unsigned int adjust, unsigned int low, unsigned int high)\n \n   XVECEXP (vector, 0, 0) =\n     gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t plus_constant (stack_pointer_rtx, adjust));\n+\t\t plus_constant (Pmode, stack_pointer_rtx, adjust));\n \n   for (i = 0; i < count - 2; i++)\n     XVECEXP (vector, 0, i + 1) =\n       gen_rtx_SET (VOIDmode,\n \t\t   gen_rtx_REG (SImode, low + i),\n \t\t   gen_rtx_MEM (SImode,\n \t\t\t\ti == 0 ? stack_pointer_rtx\n-\t\t\t\t: plus_constant (stack_pointer_rtx,\n+\t\t\t\t: plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t i * UNITS_PER_WORD)));\n \n   XVECEXP (vector, 0, count - 1) = ret_rtx;\n@@ -1808,7 +1808,7 @@ gen_rx_popm_vector (unsigned int low, unsigned int high)\n \n   XVECEXP (vector, 0, 0) =\n     gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t plus_constant (stack_pointer_rtx,\n+\t\t plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t(count - 1) * UNITS_PER_WORD));\n \n   for (i = 0; i < count - 1; i++)\n@@ -1817,7 +1817,7 @@ gen_rx_popm_vector (unsigned int low, unsigned int high)\n \t\t   gen_rtx_REG (SImode, low + i),\n \t\t   gen_rtx_MEM (SImode,\n \t\t\t\ti == 0 ? stack_pointer_rtx\n-\t\t\t\t: plus_constant (stack_pointer_rtx,\n+\t\t\t\t: plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t i * UNITS_PER_WORD)));\n \n   return vector;"}, {"sha": "b338cd96136bb61c1f04c90c9e8d67d8f7762104", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1994,7 +1994,7 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n \t      if (offset >= GET_MODE_SIZE (get_pool_mode (sym)))\n \t\treturn false;\n \n-              orig_disp = plus_constant (orig_disp, offset);\n+              orig_disp = plus_constant (Pmode, orig_disp, offset);\n \t    }\n         }\n \n@@ -3564,7 +3564,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t      new_rtx  = legitimize_pic_address (XEXP (addr, 1),\n \t\t\t\t\t     base == reg ? NULL_RTX : reg);\n \t      if (GET_CODE (new_rtx) == CONST_INT)\n-\t\tnew_rtx = plus_constant (base, INTVAL (new_rtx));\n+\t\tnew_rtx = plus_constant (Pmode, base, INTVAL (new_rtx));\n \t      else\n \t\t{\n \t\t  if (GET_CODE (new_rtx) == PLUS && CONSTANT_P (XEXP (new_rtx, 1)))\n@@ -3807,7 +3807,8 @@ legitimize_tls_address (rtx addr, rtx reg)\n \tnew_rtx = gen_rtx_CONST (Pmode, new_rtx);\n \n       new_rtx = legitimize_tls_address (new_rtx, reg);\n-      new_rtx = plus_constant (new_rtx, INTVAL (XEXP (XEXP (addr, 0), 1)));\n+      new_rtx = plus_constant (Pmode, new_rtx,\n+\t\t\t       INTVAL (XEXP (XEXP (addr, 0), 1)));\n       new_rtx = force_operand (new_rtx, 0);\n     }\n \n@@ -4941,7 +4942,7 @@ s390_delegitimize_address (rtx orig_x)\n       if (GET_CODE (y) == UNSPEC\n \t  && (XINT (y, 1) == UNSPEC_GOTOFF\n \t      || XINT (y, 1) == UNSPEC_PLTOFF))\n-\treturn plus_constant (XVECEXP (y, 0, 0), offset);\n+\treturn plus_constant (Pmode, XVECEXP (y, 0, 0), offset);\n     }\n \n   if (GET_CODE (x) != MEM)\n@@ -5328,7 +5329,8 @@ print_operand (FILE *file, rtx x, int code)\n       if (GET_CODE (x) == REG)\n \tx = gen_rtx_REG (GET_MODE (x), REGNO (x) + 1);\n       else if (GET_CODE (x) == MEM)\n-\tx = change_address (x, VOIDmode, plus_constant (XEXP (x, 0), 4));\n+\tx = change_address (x, VOIDmode,\n+\t\t\t    plus_constant (Pmode, XEXP (x, 0), 4));\n       else\n \toutput_operand_lossage (\"register or memory expression expected \"\n \t\t\t\t\"for 'N' output modifier\");\n@@ -5338,7 +5340,8 @@ print_operand (FILE *file, rtx x, int code)\n       if (GET_CODE (x) == REG)\n \tx = gen_rtx_REG (GET_MODE (x), REGNO (x) + 1);\n       else if (GET_CODE (x) == MEM)\n-\tx = change_address (x, VOIDmode, plus_constant (XEXP (x, 0), 8));\n+\tx = change_address (x, VOIDmode,\n+\t\t\t    plus_constant (Pmode, XEXP (x, 0), 8));\n       else\n \toutput_operand_lossage (\"register or memory expression expected \"\n \t\t\t\t\"for 'M' output modifier\");\n@@ -5644,7 +5647,7 @@ annotate_constant_pool_refs (rtx *x)\n \t  rtx addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, sym, base),\n \t\t\t\t     UNSPEC_LTREF);\n \n-\t  *x = replace_equiv_address (*x, plus_constant (addr, off));\n+\t  *x = replace_equiv_address (*x, plus_constant (Pmode, addr, off));\n \t  return;\n \t}\n     }\n@@ -5677,7 +5680,7 @@ annotate_constant_pool_refs (rtx *x)\n \t  rtx addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, sym, base),\n \t\t\t\t     UNSPEC_LTREF);\n \n-\t  SET_SRC (*x) = plus_constant (addr, off);\n+\t  SET_SRC (*x) = plus_constant (Pmode, addr, off);\n \t  return;\n \t}\n     }\n@@ -5874,7 +5877,7 @@ replace_constant_pool_ref (rtx *x, rtx ref, rtx offset)\n       && XVECEXP (XEXP (*x, 0), 0, 0) == ref)\n     {\n       rtx addr = gen_rtx_PLUS (Pmode, XVECEXP (XEXP (*x, 0), 0, 1), offset);\n-      *x = plus_constant (addr, INTVAL (XEXP (*x, 1)));\n+      *x = plus_constant (Pmode, addr, INTVAL (XEXP (*x, 1)));\n       return;\n     }\n \n@@ -7033,7 +7036,7 @@ s390_return_addr_rtx (int count, rtx frame ATTRIBUTE_UNUSED)\n   else\n     offset = RETURN_REGNUM * UNITS_PER_LONG;\n \n-  addr = plus_constant (frame, offset);\n+  addr = plus_constant (Pmode, frame, offset);\n   addr = memory_address (Pmode, addr);\n   return gen_rtx_MEM (Pmode, addr);\n }\n@@ -7049,7 +7052,7 @@ s390_back_chain_rtx (void)\n   gcc_assert (TARGET_BACKCHAIN);\n \n   if (TARGET_PACKED_STACK)\n-    chain = plus_constant (stack_pointer_rtx,\n+    chain = plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t   STACK_POINTER_OFFSET - UNITS_PER_LONG);\n   else\n     chain = stack_pointer_rtx;\n@@ -7711,7 +7714,7 @@ static rtx\n save_fpr (rtx base, int offset, int regnum)\n {\n   rtx addr;\n-  addr = gen_rtx_MEM (DFmode, plus_constant (base, offset));\n+  addr = gen_rtx_MEM (DFmode, plus_constant (Pmode, base, offset));\n \n   if (regnum >= 16 && regnum <= (16 + FP_ARG_NUM_REG))\n     set_mem_alias_set (addr, get_varargs_alias_set ());\n@@ -7728,7 +7731,7 @@ static rtx\n restore_fpr (rtx base, int offset, int regnum)\n {\n   rtx addr;\n-  addr = gen_rtx_MEM (DFmode, plus_constant (base, offset));\n+  addr = gen_rtx_MEM (DFmode, plus_constant (Pmode, base, offset));\n   set_mem_alias_set (addr, get_frame_alias_set ());\n \n   return emit_move_insn (gen_rtx_REG (DFmode, regnum), addr);\n@@ -7759,7 +7762,7 @@ save_gprs (rtx base, int offset, int first, int last)\n   rtx addr, insn, note;\n   int i;\n \n-  addr = plus_constant (base, offset);\n+  addr = plus_constant (Pmode, base, offset);\n   addr = gen_rtx_MEM (Pmode, addr);\n \n   set_mem_alias_set (addr, get_frame_alias_set ());\n@@ -7826,7 +7829,8 @@ save_gprs (rtx base, int offset, int first, int last)\n       if (start > last)\n \treturn insn;\n \n-      addr = plus_constant (base, offset + (start - first) * UNITS_PER_LONG);\n+      addr = plus_constant (Pmode, base,\n+\t\t\t    offset + (start - first) * UNITS_PER_LONG);\n       note = gen_store_multiple (gen_rtx_MEM (Pmode, addr),\n \t\t\t\t gen_rtx_REG (Pmode, start),\n \t\t\t\t GEN_INT (last - start + 1));\n@@ -7855,7 +7859,7 @@ restore_gprs (rtx base, int offset, int first, int last)\n {\n   rtx addr, insn;\n \n-  addr = plus_constant (base, offset);\n+  addr = plus_constant (Pmode, base, offset);\n   addr = gen_rtx_MEM (Pmode, addr);\n   set_mem_alias_set (addr, get_frame_alias_set ());\n \n@@ -8158,7 +8162,7 @@ s390_emit_prologue (void)\n \t{\n \t  if (cfun_frame_layout.backchain_offset)\n \t    addr = gen_rtx_MEM (Pmode,\n-\t\t\t\tplus_constant (stack_pointer_rtx,\n+\t\t\t\tplus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t  cfun_frame_layout.backchain_offset));\n \t  else\n \t    addr = gen_rtx_MEM (Pmode, stack_pointer_rtx);\n@@ -8193,7 +8197,7 @@ s390_emit_prologue (void)\n       for (i = 24; i <= next_fpr; i++)\n \tif (cfun_fpr_bit_p (i - 16))\n \t  {\n-\t    rtx addr = plus_constant (stack_pointer_rtx,\n+\t    rtx addr = plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t      cfun_frame_layout.frame_size\n \t\t\t\t      + cfun_frame_layout.f8_offset\n \t\t\t\t      + offset);\n@@ -8375,7 +8379,7 @@ s390_emit_epilogue (bool sibcall)\n \t{\n \t  if (global_not_special_regno_p (i))\n \t    {\n-\t      addr = plus_constant (frame_pointer,\n+\t      addr = plus_constant (Pmode, frame_pointer,\n \t\t\t\t    offset + cfun_frame_layout.gprs_offset\n \t\t\t\t    + (i - cfun_frame_layout.first_save_gpr_slot)\n \t\t\t\t    * UNITS_PER_LONG);\n@@ -8403,7 +8407,7 @@ s390_emit_epilogue (bool sibcall)\n \t\treturn_regnum = 4;\n \t      return_reg = gen_rtx_REG (Pmode, return_regnum);\n \n-\t      addr = plus_constant (frame_pointer,\n+\t      addr = plus_constant (Pmode, frame_pointer,\n \t\t\t\t    offset + cfun_frame_layout.gprs_offset\n \t\t\t\t    + (RETURN_REGNUM\n \t\t\t\t       - cfun_frame_layout.first_save_gpr_slot)\n@@ -8424,7 +8428,8 @@ s390_emit_epilogue (bool sibcall)\n       insn = emit_insn (insn);\n       REG_NOTES (insn) = cfa_restores;\n       add_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\t    plus_constant (stack_pointer_rtx, STACK_POINTER_OFFSET));\n+\t\t    plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t   STACK_POINTER_OFFSET));\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n@@ -9285,7 +9290,7 @@ s390_function_profiler (FILE *file, int labelno)\n \n   op[0] = gen_rtx_REG (Pmode, RETURN_REGNUM);\n   op[1] = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n-  op[1] = gen_rtx_MEM (Pmode, plus_constant (op[1], UNITS_PER_LONG));\n+  op[1] = gen_rtx_MEM (Pmode, plus_constant (Pmode, op[1], UNITS_PER_LONG));\n \n   op[2] = gen_rtx_REG (Pmode, 1);\n   op[3] = gen_rtx_SYMBOL_REF (Pmode, label);"}, {"sha": "99c09e8860e2aa02d65a11aa01fd900c66ceeb66", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -539,15 +539,16 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n /* Defining this macro makes __builtin_frame_address(0) and\n    __builtin_return_address(0) work with -fomit-frame-pointer.  */\n #define INITIAL_FRAME_ADDRESS_RTX                                             \\\n-  (plus_constant (arg_pointer_rtx, -STACK_POINTER_OFFSET))\n+  (plus_constant (Pmode, arg_pointer_rtx, -STACK_POINTER_OFFSET))\n \n /* The return address of the current frame is retrieved\n    from the initial value of register RETURN_REGNUM.\n    For frames farther back, we use the stack slot where\n    the corresponding RETURN_REGNUM register was saved.  */\n #define DYNAMIC_CHAIN_ADDRESS(FRAME)                                          \\\n   (TARGET_PACKED_STACK ?                                                      \\\n-   plus_constant ((FRAME), STACK_POINTER_OFFSET - UNITS_PER_LONG) : (FRAME))\n+   plus_constant (Pmode, (FRAME),\t\t\t\t\t      \\\n+\t\t  STACK_POINTER_OFFSET - UNITS_PER_LONG) : (FRAME))\n \n /* For -mpacked-stack this adds 160 - 8 (96 - 4) to the output of\n    builtin_frame_address.  Otherwise arg pointer -"}, {"sha": "a467d4a10ec6028a13468be0ff12f913208a858d", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -2353,7 +2353,8 @@\n     XVECEXP (operands[3], 0, i)\n       = gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, regno + i),\n \t\t     change_address (operands[1], mode,\n-\t\t       plus_constant (from, off + i * GET_MODE_SIZE (mode))));\n+\t\t       plus_constant (Pmode, from,\n+\t\t\t\t      off + i * GET_MODE_SIZE (mode))));\n })\n \n (define_insn \"*load_multiple_di\"\n@@ -2443,7 +2444,8 @@\n     XVECEXP (operands[3], 0, i)\n       = gen_rtx_SET (VOIDmode,\n \t\t     change_address (operands[0], mode,\n-\t\t       plus_constant (to, off + i * GET_MODE_SIZE (mode))),\n+\t\t       plus_constant (Pmode, to,\n+\t\t\t\t      off + i * GET_MODE_SIZE (mode))),\n \t\t     gen_rtx_REG (mode, regno + i));\n })\n "}, {"sha": "0af0fd50b82e40a3d7275112e2ed17fdb073fd72", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -444,7 +444,7 @@ score_add_offset (rtx reg, HOST_WIDE_INT offset)\n       offset &= 0x3fff;\n     }\n \n-  return plus_constant (reg, offset);\n+  return plus_constant (GET_MODE (reg), reg, offset);\n }\n \n /* Implement TARGET_ASM_OUTPUT_MI_THUNK.  Generate rtl rather than asm text\n@@ -1546,8 +1546,8 @@ score_prologue (void)\n       REG_NOTES (insn) =\n         alloc_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n                          gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-                                      plus_constant (stack_pointer_rtx,\n-                                                     -size)),\n+                                      plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t     -size)),\n                                       REG_NOTES (insn));\n     }\n "}, {"sha": "d86347499a6d53c27d9dc357646ac384e693dffb", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1499,7 +1499,7 @@ expand_block_move (rtx *operands)\n \n \t  set_mem_size (from, 4);\n \t  emit_insn (gen_movua (temp, from));\n-\t  emit_move_insn (src_addr, plus_constant (src_addr, 4));\n+\t  emit_move_insn (src_addr, plus_constant (Pmode, src_addr, 4));\n \t  emit_move_insn (to, temp);\n \t  copied += 4;\n \t}\n@@ -6584,12 +6584,13 @@ push_regs (HARD_REG_SET *mask, int interrupt_handler)\n \t  x = frame_insn (x);\n \t  for (i = FIRST_BANKED_REG; i <= LAST_BANKED_REG; i++)\n \t    {\n-\t      mem = gen_rtx_MEM (SImode, plus_constant (sp_reg, i * 4));\n+\t      mem = gen_rtx_MEM (SImode, plus_constant (Pmode, sp_reg, i * 4));\n \t      reg = gen_rtx_REG (SImode, i);\n \t      add_reg_note (x, REG_CFA_OFFSET, gen_rtx_SET (SImode, mem, reg));\n \t    }\n \n-\t  set = gen_rtx_SET (SImode, sp_reg, plus_constant (sp_reg, - 32));\n+\t  set = gen_rtx_SET (SImode, sp_reg,\n+\t\t\t     plus_constant (Pmode, sp_reg, - 32));\n \t  add_reg_note (x, REG_CFA_ADJUST_CFA, set);\n \t  emit_insn (gen_blockage ());\n \t}\n@@ -7817,7 +7818,8 @@ sh_builtin_saveregs (void)\n       rtx addr, mask;\n \n       regbuf = assign_stack_local (BLKmode, bufsize + UNITS_PER_WORD, 0);\n-      addr = copy_to_mode_reg (Pmode, plus_constant (XEXP (regbuf, 0), 4));\n+      addr = copy_to_mode_reg (Pmode, plus_constant (Pmode,\n+\t\t\t\t\t\t     XEXP (regbuf, 0), 4));\n       mask = copy_to_mode_reg (Pmode, GEN_INT (-8));\n       emit_insn (gen_andsi3 (addr, addr, mask));\n       regbuf = change_address (regbuf, BLKmode, addr);\n@@ -7849,8 +7851,8 @@ sh_builtin_saveregs (void)\n      We emit the moves in reverse order so that we can use predecrement.  */\n \n   fpregs = copy_to_mode_reg (Pmode,\n-\t\t\t     plus_constant (XEXP (regbuf, 0),\n-                                            n_floatregs * UNITS_PER_WORD));\n+\t\t\t     plus_constant (Pmode, XEXP (regbuf, 0),\n+\t\t\t\t\t    n_floatregs * UNITS_PER_WORD));\n   if (TARGET_SH4 || TARGET_SH2A_DOUBLE)\n     {\n       rtx mem;\n@@ -11777,7 +11779,7 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \terror (\"need a call-clobbered target register\");\n     }\n \n-  this_value = plus_constant (this_rtx, delta);\n+  this_value = plus_constant (Pmode, this_rtx, delta);\n   if (vcall_offset\n       && (simple_add || scratch0 != scratch1)\n       && strict_memory_address_p (ptr_mode, this_value))\n@@ -11803,7 +11805,7 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n       if (!did_load)\n \temit_load_ptr (scratch0, this_rtx);\n \n-      offset_addr = plus_constant (scratch0, vcall_offset);\n+      offset_addr = plus_constant (Pmode, scratch0, vcall_offset);\n       if (strict_memory_address_p (ptr_mode, offset_addr))\n \t; /* Do nothing.  */\n       else if (! TARGET_SH5 && scratch0 != scratch1)"}, {"sha": "914d5bf8b924112533631d6ef287a9331db4e16b", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -6187,7 +6187,7 @@ label:\n   if (TARGET_SH5 && true_regnum (operands[1]) < 16)\n     {\n       emit_move_insn (stack_pointer_rtx,\n-\t\t      plus_constant (stack_pointer_rtx, -8));\n+\t\t      plus_constant (Pmode, stack_pointer_rtx, -8));\n       tos = gen_tmp_stack_mem (DFmode, stack_pointer_rtx);\n     }\n   else\n@@ -6203,7 +6203,8 @@ label:\n \t\t\t     gen_rtx_POST_INC (Pmode, stack_pointer_rtx));\n   insn = emit_insn (gen_movdf_i4 (operands[0], tos, operands[2]));\n   if (TARGET_SH5 && true_regnum (operands[0]) < 16)\n-    emit_move_insn (stack_pointer_rtx, plus_constant (stack_pointer_rtx, 8));\n+    emit_move_insn (stack_pointer_rtx,\n+\t\t    plus_constant (Pmode, stack_pointer_rtx, 8));\n   else\n     add_reg_note (insn, REG_INC, stack_pointer_rtx);\n   DONE;\n@@ -6413,7 +6414,7 @@ label:\n     case PLUS:\n       emit_insn (gen_movsf_ie (reg0, operands[1], operands[2]));\n       operands[1] = copy_rtx (operands[1]);\n-      XEXP (operands[1], 0) = plus_constant (addr, 4);\n+      XEXP (operands[1], 0) = plus_constant (Pmode, addr, 4);\n       emit_insn (gen_movsf_ie (reg1, operands[1], operands[2]));\n       break;\n       \n@@ -6480,7 +6481,7 @@ label:\n       emit_insn (gen_movsf_ie (operands[0], reg0, operands[2]));\n \n       operands[0] = copy_rtx (operands[0]);\n-      XEXP (operands[0], 0) = plus_constant (addr, 4);\n+      XEXP (operands[0], 0) = plus_constant (Pmode, addr, 4);\n \n       emit_insn (gen_movsf_ie (operands[0], reg1, operands[2]));\t \n       break;\n@@ -11244,7 +11245,8 @@ label:\n       emit_insn (gen_movsi (shift_reg, operands[3]));\n       qi_val = gen_rtx_SUBREG (QImode, shift_reg, 3);\n     }\n-  addr_target = copy_addr_to_reg (plus_constant (orig_address, size - 1));\n+  addr_target = copy_addr_to_reg (plus_constant (Pmode,\n+\t\t\t\t\t\t orig_address, size - 1));\n \n   operands[0] = replace_equiv_address (operands[0], addr_target);\n   emit_insn (gen_movqi (operands[0], qi_val));"}, {"sha": "4cb381e60e9776d99f748eaa75e1ef3f1e4fd560", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -3866,7 +3866,7 @@ sparc_legitimize_pic_address (rtx orig, rtx reg)\n       if (GET_CODE (offset) == CONST_INT)\n \t{\n \t  if (SMALL_INT (offset))\n-\t    return plus_constant (base, INTVAL (offset));\n+\t    return plus_constant (Pmode, base, INTVAL (offset));\n \t  else if (can_create_pseudo_p ())\n \t    offset = force_reg (Pmode, offset);\n \t  else\n@@ -4605,7 +4605,7 @@ sparc_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n       emit_move_insn (g1, GEN_INT (first));\n       emit_insn (gen_rtx_SET (VOIDmode, g1,\n \t\t\t      gen_rtx_MINUS (Pmode, stack_pointer_rtx, g1)));\n-      emit_stack_probe (plus_constant (g1, -size));\n+      emit_stack_probe (plus_constant (Pmode, g1, -size));\n     }\n \n   /* The run-time loop is made up of 10 insns in the generic case while the\n@@ -4625,11 +4625,12 @@ sparc_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n       for (i = 2 * PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)\n \t{\n \t  emit_insn (gen_rtx_SET (VOIDmode, g1,\n-\t\t\t\t  plus_constant (g1, -PROBE_INTERVAL)));\n+\t\t\t\t  plus_constant (Pmode, g1, -PROBE_INTERVAL)));\n \t  emit_stack_probe (g1);\n \t}\n \n-      emit_stack_probe (plus_constant (g1, (i - PROBE_INTERVAL) - size));\n+      emit_stack_probe (plus_constant (Pmode, g1,\n+\t\t\t\t       (i - PROBE_INTERVAL) - size));\n     }\n \n   /* Otherwise, do the same as above, but in a loop.  Note that we must be\n@@ -4682,7 +4683,7 @@ sparc_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n \t that SIZE is equal to ROUNDED_SIZE.  */\n \n       if (size != rounded_size)\n-\temit_stack_probe (plus_constant (g4, rounded_size - size));\n+\temit_stack_probe (plus_constant (Pmode, g4, rounded_size - size));\n     }\n \n   /* Make sure nothing is scheduled before we are done.  */\n@@ -4759,7 +4760,8 @@ emit_save_or_restore_regs (unsigned int low, unsigned int high, rtx base,\n \t{\n \t  if (save_p (i, leaf_function))\n \t    {\n-\t      mem = gen_frame_mem (DImode, plus_constant (base, offset));\n+\t      mem = gen_frame_mem (DImode, plus_constant (Pmode,\n+\t\t\t\t\t\t\t  base, offset));\n \t      if (action_true == SORR_SAVE)\n \t\t{\n \t\t  insn = emit_move_insn (mem, gen_rtx_REG (DImode, i));\n@@ -4784,7 +4786,7 @@ emit_save_or_restore_regs (unsigned int low, unsigned int high, rtx base,\n \n       if (fp_offset >= 0)\n \t{\n-\t  mem = gen_frame_mem (DImode, plus_constant (base, fp_offset));\n+\t  mem = gen_frame_mem (DImode, plus_constant (Pmode, base, fp_offset));\n \t  emit_move_insn (hard_frame_pointer_rtx, mem);\n \t}\n     }\n@@ -4820,20 +4822,22 @@ emit_save_or_restore_regs (unsigned int low, unsigned int high, rtx base,\n \t      continue;\n \t    }\n \n-\t  mem = gen_frame_mem (mode, plus_constant (base, offset));\n+\t  mem = gen_frame_mem (mode, plus_constant (Pmode, base, offset));\n \t  if (action_true == SORR_SAVE)\n \t    {\n \t      insn = emit_move_insn (mem, gen_rtx_REG (mode, regno));\n \t      RTX_FRAME_RELATED_P (insn) = 1;\n \t      if (mode == DImode)\n \t\t{\n \t\t  rtx set1, set2;\n-\t\t  mem = gen_frame_mem (SImode, plus_constant (base, offset));\n+\t\t  mem = gen_frame_mem (SImode, plus_constant (Pmode, base,\n+\t\t\t\t\t\t\t      offset));\n \t\t  set1 = gen_rtx_SET (VOIDmode, mem,\n \t\t\t\t      gen_rtx_REG (SImode, regno));\n \t\t  RTX_FRAME_RELATED_P (set1) = 1;\n \t\t  mem\n-\t\t    = gen_frame_mem (SImode, plus_constant (base, offset + 4));\n+\t\t    = gen_frame_mem (SImode, plus_constant (Pmode, base,\n+\t\t\t\t\t\t\t    offset + 4));\n \t\t  set2 = gen_rtx_SET (VOIDmode, mem,\n \t\t\t\t      gen_rtx_REG (SImode, regno + 1));\n \t\t  RTX_FRAME_RELATED_P (set2) = 1;\n@@ -4923,7 +4927,7 @@ emit_window_save (rtx increment)\n \n   /* The CFA is %fp, the hard frame pointer.  */\n   add_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\tplus_constant (hard_frame_pointer_rtx,\n+\t\tplus_constant (Pmode, hard_frame_pointer_rtx,\n \t\t\t       INCOMING_FRAME_SP_OFFSET));\n \n   return insn;\n@@ -5145,7 +5149,7 @@ sparc_flat_expand_prologue (void)\n \n \t  add_reg_note (insn, REG_CFA_ADJUST_CFA,\n \t\t\tgen_rtx_SET (VOIDmode, hard_frame_pointer_rtx,\n-\t\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t     plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t    size)));\n \t}\n \n@@ -6736,10 +6740,10 @@ sparc_struct_value_rtx (tree fndecl, int incoming)\n       rtx mem;\n \n       if (incoming)\n-\tmem = gen_frame_mem (Pmode, plus_constant (frame_pointer_rtx,\n+\tmem = gen_frame_mem (Pmode, plus_constant (Pmode, frame_pointer_rtx,\n \t\t\t\t\t\t   STRUCT_VALUE_OFFSET));\n       else\n-\tmem = gen_frame_mem (Pmode, plus_constant (stack_pointer_rtx,\n+\tmem = gen_frame_mem (Pmode, plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t\t   STRUCT_VALUE_OFFSET));\n \n       /* Only follow the SPARC ABI for fixed-size structure returns.\n@@ -6770,7 +6774,8 @@ sparc_struct_value_rtx (tree fndecl, int incoming)\n \t     it's an unimp instruction (the most significant 10 bits\n \t     will be zero).  */\n \t  emit_move_insn (scratch, gen_rtx_MEM (SImode,\n-\t\t\t\t\t\tplus_constant (ret_reg, 8)));\n+\t\t\t\t\t\tplus_constant (Pmode,\n+\t\t\t\t\t\t\t       ret_reg, 8)));\n \t  /* Assume the size is valid and pre-adjust */\n \t  emit_insn (gen_add3_insn (ret_reg, ret_reg, GEN_INT (4)));\n \t  emit_cmp_and_jump_insns (scratch, size_rtx, EQ, const0_rtx, SImode,\n@@ -10420,7 +10425,7 @@ emit_and_preserve (rtx seq, rtx reg, rtx reg2)\n   HOST_WIDE_INT size = SPARC_STACK_ALIGN (offset + 2*UNITS_PER_WORD);\n \n   rtx slot\n-    = gen_rtx_MEM (word_mode, plus_constant (stack_pointer_rtx,\n+    = gen_rtx_MEM (word_mode, plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t     SPARC_STACK_BIAS + offset));\n \n   emit_insn (gen_stack_pointer_dec (GEN_INT (size)));"}, {"sha": "a2bf09f1c810cca59d7254c5d6c8a5ae64b84db8", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1273,11 +1273,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n    return an rtx for the address of the word in the frame\n    that holds the dynamic chain--the previous frame's address.  */\n #define DYNAMIC_CHAIN_ADDRESS(frame)\t\\\n-  plus_constant (frame, 14 * UNITS_PER_WORD + SPARC_STACK_BIAS)\n+  plus_constant (Pmode, frame, 14 * UNITS_PER_WORD + SPARC_STACK_BIAS)\n \n /* Given an rtx for the frame pointer,\n    return an rtx for the address of the frame.  */\n-#define FRAME_ADDR_RTX(frame) plus_constant (frame, SPARC_STACK_BIAS)\n+#define FRAME_ADDR_RTX(frame) plus_constant (Pmode, frame, SPARC_STACK_BIAS)\n \n /* The return address isn't on the stack, it is in a register, so we can't\n    access it from the current frame pointer.  We can access it from the\n@@ -1299,7 +1299,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   ((count == -1)\t\t\t\t\\\n    ? gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM)\t\t\t\\\n    : gen_rtx_MEM (Pmode,\t\t\t\\\n-\t\t  memory_address (Pmode, plus_constant (frame, \\\n+\t\t  memory_address (Pmode, plus_constant (Pmode, frame, \\\n \t\t\t\t\t\t\t15 * UNITS_PER_WORD \\\n \t\t\t\t\t\t\t+ SPARC_STACK_BIAS))))\n \n@@ -1309,7 +1309,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n    is something you can return to.  */\n #define INCOMING_RETURN_ADDR_REGNUM 15\n #define INCOMING_RETURN_ADDR_RTX \\\n-  plus_constant (gen_rtx_REG (word_mode, INCOMING_RETURN_ADDR_REGNUM), 8)\n+  plus_constant (word_mode, \\\n+\t\t gen_rtx_REG (word_mode, INCOMING_RETURN_ADDR_REGNUM), 8)\n #define DWARF_FRAME_RETURN_COLUMN \\\n   DWARF_FRAME_REGNUM (INCOMING_RETURN_ADDR_REGNUM)\n "}, {"sha": "aafff5598d1ef80460956d63010fcef483031dff", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -6436,7 +6436,7 @@\n \t instruction (the most significant 10 bits will be zero).  If so,\n \t update the return address to skip the unimp instruction.  */\n       emit_move_insn (value,\n-\t\t      gen_rtx_MEM (SImode, plus_constant (rtnreg, 8)));\n+\t\t      gen_rtx_MEM (SImode, plus_constant (SImode, rtnreg, 8)));\n       emit_insn (gen_lshrsi3 (value, value, GEN_INT (22)));\n       emit_insn (gen_update_return (rtnreg, value));\n     }"}, {"sha": "dc5ca45dd5756228a33ae3f66ca6e340781f418a", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -858,7 +858,7 @@ spu_expand_insv (rtx ops[])\n \t  rtx mask1 = gen_reg_rtx (TImode);\n \t  rtx dst1 = gen_reg_rtx (TImode);\n \t  rtx mem1;\n-\t  addr1 = plus_constant (addr, 16);\n+\t  addr1 = plus_constant (Pmode, addr, 16);\n \t  addr1 = gen_rtx_AND (Pmode, addr1, GEN_INT (-16));\n \t  emit_insn (gen_subsi3 (shl, GEN_INT (16), low));\n \t  emit_insn (gen_shlqby_ti (mask1, mask, shl));\n@@ -2949,7 +2949,7 @@ spu_machine_dependent_reorg (void)\n \t  if (NONJUMP_INSN_P (branch))\n \t    offset += get_attr_length (branch);\n \tif (offset > 0)\n-\t  XVECEXP (unspec, 0, 0) = plus_constant (label_ref, offset);\n+\t  XVECEXP (unspec, 0, 0) = plus_constant (Pmode, label_ref, offset);\n       }\n \n   spu_var_tracking ();\n@@ -4379,7 +4379,7 @@ spu_setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n       for (regno = ncum; regno < MAX_REGISTER_ARGS; regno++)\n \t{\n \t  tmp = gen_frame_mem (V4SImode,\n-\t\t\t       plus_constant (virtual_incoming_args_rtx,\n+\t\t\t       plus_constant (Pmode, virtual_incoming_args_rtx,\n \t\t\t\t\t      offset));\n \t  emit_move_insn (tmp,\n \t\t\t  gen_rtx_REG (V4SImode, FIRST_ARG_REGNUM + regno));\n@@ -4556,7 +4556,7 @@ ea_load_store_inline (rtx mem, bool is_store, rtx ea_addr, rtx data_addr)\n       tag_equal_hi = gen_reg_rtx (V4SImode);\n     }\n \n-  emit_move_insn (index_mask, plus_constant (tag_size_sym, -128));\n+  emit_move_insn (index_mask, plus_constant (Pmode, tag_size_sym, -128));\n   emit_move_insn (tag_arr, tag_arr_sym);\n   v = 0x0001020300010203LL;\n   emit_move_insn (splat_mask, immed_double_const (v, v, TImode));\n@@ -4583,14 +4583,16 @@ ea_load_store_inline (rtx mem, bool is_store, rtx ea_addr, rtx data_addr)\n   emit_move_insn (cache_tag, gen_rtx_MEM (V4SImode, tag_addr));\n   if (spu_ea_model != 32)\n     emit_move_insn (cache_tag_hi, gen_rtx_MEM (V4SImode,\n-\t\t\t\t\t       plus_constant (tag_addr, 16)));\n+\t\t\t\t\t       plus_constant (Pmode,\n+\t\t\t\t\t\t\t      tag_addr, 16)));\n \n   /* tag = ea_addr & -128  */\n   emit_insn (gen_andv4si3 (tag, splat, spu_const (V4SImode, -128)));\n \n   /* Read all four cache data pointers.  */\n   emit_move_insn (cache_ptrs, gen_rtx_MEM (TImode,\n-\t\t\t\t\t   plus_constant (tag_addr, 32)));\n+\t\t\t\t\t   plus_constant (Pmode,\n+\t\t\t\t\t\t\t  tag_addr, 32)));\n \n   /* Compare tags.  */\n   emit_insn (gen_ceq_v4si (tag_equal, tag, cache_tag));\n@@ -4941,7 +4943,7 @@ spu_expand_load (rtx dst0, rtx dst1, rtx src, int extra_rotby)\n \n   if (dst1)\n     {\n-      addr1 = plus_constant (copy_rtx (addr), 16);\n+      addr1 = plus_constant (SImode, copy_rtx (addr), 16);\n       addr1 = gen_rtx_AND (SImode, addr1, GEN_INT (-16));\n       emit_insn (gen__movti (dst1, change_address (src, TImode, addr1)));\n     }"}, {"sha": "ce0bc8edb5f913e8f732f7320b4a068980fbf224", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -250,7 +250,7 @@ targetm.resolve_overloaded_builtin = spu_resolve_overloaded_builtin;\t\\\n \n #define FIRST_PARM_OFFSET(FNDECL) (0)\n \n-#define DYNAMIC_CHAIN_ADDRESS(FP) plus_constant ((FP), -16)\n+#define DYNAMIC_CHAIN_ADDRESS(FP) plus_constant (Pmode, (FP), -16)\n \n #define RETURN_ADDR_RTX(COUNT,FP) (spu_return_addr (COUNT, FP))\n "}, {"sha": "a2e6481d07b8aef46b025a643077e27acb2ec8f8", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1053,7 +1053,8 @@ xstormy16_expand_prologue (void)\n \t\t\t\t\t     gen_rtx_MEM (Pmode, stack_pointer_rtx),\n \t\t\t\t\t     reg);\n \tXVECEXP (dwarf, 0, 1) = gen_rtx_SET (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t     plus_constant (Pmode,\n+\t\t\t\t\t\t\t    stack_pointer_rtx,\n \t\t\t\t\t\t\t    GET_MODE_SIZE (Pmode)));\n \tadd_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n \tRTX_FRAME_RELATED_P (XVECEXP (dwarf, 0, 0)) = 1;\n@@ -1076,7 +1077,8 @@ xstormy16_expand_prologue (void)\n \t\t\t\t\t     gen_rtx_MEM (Pmode, stack_pointer_rtx),\n \t\t\t\t\t     reg);\n \tXVECEXP (dwarf, 0, 1) = gen_rtx_SET (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t     plus_constant (Pmode, \\\n+\t\t\t\t\t\t\t    stack_pointer_rtx,\n \t\t\t\t\t\t\t    GET_MODE_SIZE (Pmode)));\n \tadd_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n \tRTX_FRAME_RELATED_P (XVECEXP (dwarf, 0, 0)) = 1;\n@@ -2564,7 +2566,7 @@ combine_bnp (rtx insn)\n \n       if (! (mask & 0xff))\n \t{\n-\t  addr = plus_constant (addr, 1);\n+\t  addr = plus_constant (Pmode, addr, 1);\n \t  mask >>= 8;\n \t}\n       mem = gen_rtx_MEM (QImode, addr);"}, {"sha": "a23e193ee3aa4f05d7065f822607cb5ad1344478", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -352,7 +352,8 @@ tilegx_setup_incoming_varargs (cumulative_args_t cum,\n \t{\n \t  alias_set_type set = get_varargs_alias_set ();\n \t  rtx tmp =\n-\t    gen_rtx_MEM (BLKmode, plus_constant (virtual_incoming_args_rtx,\n+\t    gen_rtx_MEM (BLKmode, plus_constant (Pmode,\n+\t\t\t\t\t\t virtual_incoming_args_rtx,\n \t\t\t\t\t\t -STACK_POINTER_OFFSET -\n \t\t\t\t\t\t UNITS_PER_WORD *\n \t\t\t\t\t\t (TILEGX_NUM_ARG_REGS -\n@@ -1755,7 +1756,7 @@ tilegx_expand_unaligned_load (rtx dest_reg, rtx mem, HOST_WIDE_INT bitsize,\n      implicitly alias surrounding code.  Ideally we'd have some alias\n      set that covered all types except those with alignment 8 or\n      higher.  */\n-  addr_lo = force_reg (Pmode, plus_constant (mema, byte_offset));\n+  addr_lo = force_reg (Pmode, plus_constant (Pmode, mema, byte_offset));\n   mem_lo = change_address (mem, mode,\n \t\t\t   gen_rtx_AND (GET_MODE (mema), addr_lo,\n \t\t\t\t\tGEN_INT (-8)));\n@@ -1764,7 +1765,7 @@ tilegx_expand_unaligned_load (rtx dest_reg, rtx mem, HOST_WIDE_INT bitsize,\n   /* Load the high word at an address that will not fault if the low\n      address is aligned and at the very end of a page.  */\n   last_byte_offset = (bit_offset + bitsize - 1) / BITS_PER_UNIT;\n-  addr_hi = force_reg (Pmode, plus_constant (mema, last_byte_offset));\n+  addr_hi = force_reg (Pmode, plus_constant (Pmode, mema, last_byte_offset));\n   mem_hi = change_address (mem, mode,\n \t\t\t   gen_rtx_AND (GET_MODE (mema), addr_hi,\n \t\t\t\t\tGEN_INT (-8)));\n@@ -4890,7 +4891,7 @@ tilegx_trampoline_init (rtx m_tramp, tree fndecl, rtx static_chain)\n \n   /* Get pointers to the beginning and end of the code block.  */\n   begin_addr = force_reg (Pmode, XEXP (m_tramp, 0));\n-  end_addr = force_reg (Pmode, plus_constant (XEXP (m_tramp, 0),\n+  end_addr = force_reg (Pmode, plus_constant (Pmode, XEXP (m_tramp, 0),\n \t\t\t\t\t      TRAMPOLINE_SIZE));\n \n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__clear_cache\"),"}, {"sha": "ac69061d85c5c135a7d9fa87ccd37f712f4e1026", "filename": "gcc/config/tilegx/tilegx.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Ftilegx%2Ftilegx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Ftilegx%2Ftilegx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.h?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -243,7 +243,8 @@ enum reg_class\n #define FRAME_GROWS_DOWNWARD 1\n #define STARTING_FRAME_OFFSET 0\n \n-#define DYNAMIC_CHAIN_ADDRESS(FRAME) plus_constant ((FRAME), UNITS_PER_WORD)\n+#define DYNAMIC_CHAIN_ADDRESS(FRAME) \\\n+  plus_constant (Pmode, (FRAME), UNITS_PER_WORD)\n \n #define FIRST_PARM_OFFSET(FNDECL) 0\n "}, {"sha": "2b18b4f6622ac12784acaaa867c3c90ecea87b8a", "filename": "gcc/config/tilepro/tilepro.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -356,7 +356,8 @@ tilepro_setup_incoming_varargs (cumulative_args_t cum,\n \t{\n \t  alias_set_type set = get_varargs_alias_set ();\n \t  rtx tmp =\n-\t    gen_rtx_MEM (BLKmode, plus_constant (virtual_incoming_args_rtx,\n+\t    gen_rtx_MEM (BLKmode, plus_constant (Pmode, \\\n+\t\t\t\t\t\t virtual_incoming_args_rtx,\n \t\t\t\t\t\t -STACK_POINTER_OFFSET -\n \t\t\t\t\t\t UNITS_PER_WORD *\n \t\t\t\t\t\t (TILEPRO_NUM_ARG_REGS -\n@@ -1640,15 +1641,15 @@ tilepro_expand_unaligned_load (rtx dest_reg, rtx mem, HOST_WIDE_INT bitsize,\n      implicitly alias surrounding code.  Ideally we'd have some alias\n      set that covered all types except those with alignment 8 or\n      higher.  */\n-  addr_lo = force_reg (Pmode, plus_constant (mema, byte_offset));\n+  addr_lo = force_reg (Pmode, plus_constant (Pmode, mema, byte_offset));\n   mem_lo = change_address (mem, mode,\n \t\t\t   gen_rtx_AND (Pmode, addr_lo, GEN_INT (-4)));\n   set_mem_alias_set (mem_lo, 0);\n \n   /* Load the high word at an address that will not fault if the low\n      address is aligned and at the very end of a page.  */\n   last_byte_offset = (bit_offset + bitsize - 1) / BITS_PER_UNIT;\n-  addr_hi = force_reg (Pmode, plus_constant (mema, last_byte_offset));\n+  addr_hi = force_reg (Pmode, plus_constant (Pmode, mema, last_byte_offset));\n   mem_hi = change_address (mem, mode,\n \t\t\t   gen_rtx_AND (Pmode, addr_hi, GEN_INT (-4)));\n   set_mem_alias_set (mem_hi, 0);\n@@ -4455,7 +4456,7 @@ tilepro_trampoline_init (rtx m_tramp, tree fndecl, rtx static_chain)\n \n   /* Get pointers to the beginning and end of the code block.  */\n   begin_addr = force_reg (Pmode, XEXP (m_tramp, 0));\n-  end_addr = force_reg (Pmode, plus_constant (XEXP (m_tramp, 0),\n+  end_addr = force_reg (Pmode, plus_constant (Pmode, XEXP (m_tramp, 0),\n \t\t\t\t\t      TRAMPOLINE_SIZE));\n \n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__clear_cache\"),"}, {"sha": "593bf68d60a80e798291adf6536827f089a1b9db", "filename": "gcc/config/tilepro/tilepro.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Ftilepro%2Ftilepro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Ftilepro%2Ftilepro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.h?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -226,7 +226,8 @@ enum reg_class\n #define FRAME_GROWS_DOWNWARD 1\n #define STARTING_FRAME_OFFSET 0\n \n-#define DYNAMIC_CHAIN_ADDRESS(FRAME) plus_constant ((FRAME), UNITS_PER_WORD)\n+#define DYNAMIC_CHAIN_ADDRESS(FRAME) \\\n+  plus_constant (Pmode, (FRAME), UNITS_PER_WORD)\n \n #define FIRST_PARM_OFFSET(FNDECL) 0\n "}, {"sha": "e2a72b0b3d5c705fef3a85f495a15250e6e86c1f", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1719,7 +1719,8 @@ expand_prologue (void)\n \t  if (num_save > 0 && REGNO (save_regs[num_save-1]) == LINK_POINTER_REGNUM)\n \t    {\n \t      emit_move_insn (gen_rtx_MEM (SImode,\n-\t\t\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t   plus_constant (Pmode,\n+\t\t\t\t\t\t\t  stack_pointer_rtx,\n \t\t\t\t\t\t\t  offset)),\n \t\t\t      save_regs[--num_save]);\n \t      offset -= 4;\n@@ -1728,7 +1729,8 @@ expand_prologue (void)\n \t  for (i = 0; i < num_save; i++)\n \t    {\n \t      emit_move_insn (gen_rtx_MEM (SImode,\n-\t\t\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t   plus_constant (Pmode,\n+\t\t\t\t\t\t\t  stack_pointer_rtx,\n \t\t\t\t\t\t\t  offset)),\n \t\t\t      save_regs[i]);\n \t      offset -= 4;\n@@ -1916,7 +1918,8 @@ expand_epilogue (void)\n \t    {\n \t      emit_move_insn (restore_regs[--num_restore],\n \t\t\t      gen_rtx_MEM (SImode,\n-\t\t\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t   plus_constant (Pmode,\n+\t\t\t\t\t\t\t  stack_pointer_rtx,\n \t\t\t\t\t\t\t  offset)));\n \t      offset -= 4;\n \t    }\n@@ -1925,7 +1928,8 @@ expand_epilogue (void)\n \t    {\n \t      emit_move_insn (restore_regs[i],\n \t\t\t      gen_rtx_MEM (SImode,\n-\t\t\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t   plus_constant (Pmode,\n+\t\t\t\t\t\t\t  stack_pointer_rtx,\n \t\t\t\t\t\t\t  offset)));\n \n \t      emit_use (restore_regs[i]);"}, {"sha": "4ac565383cdceae489f748e957cd324ced7ac2a0", "filename": "gcc/config/v850/v850.md", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fv850%2Fv850.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fv850%2Fv850.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.md?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -648,7 +648,8 @@\n \n   rtx xoperands[2];\n   xoperands[0] = gen_rtx_MEM (QImode,\n-\t\t\t      plus_constant (XEXP (operands[0], 0), log2 / 8));\n+\t\t\t      plus_constant (Pmode, XEXP (operands[0], 0),\n+\t\t\t\t\t     log2 / 8));\n   xoperands[1] = GEN_INT (log2 % 8);\n   output_asm_insn (\"clr1 %1,%0\", xoperands);\n   return \"\";\n@@ -668,7 +669,8 @@\n \n   rtx xoperands[2];\n   xoperands[0] = gen_rtx_MEM (QImode,\n-\t\t\t      plus_constant (XEXP (operands[0], 0), log2 / 8));\n+\t\t\t      plus_constant (Pmode, XEXP (operands[0], 0),\n+\t\t\t\t\t     log2 / 8));\n   xoperands[1] = GEN_INT (log2 % 8);\n   output_asm_insn (\"clr1 %1,%0\", xoperands);\n   return \"\";\n@@ -719,7 +721,7 @@\n     {\n       rtx xoperands[2];\n       xoperands[0] = gen_rtx_MEM (QImode,\n-\t\t\t\t  plus_constant (XEXP (operands[0], 0),\n+\t\t\t\t  plus_constant (Pmode, XEXP (operands[0], 0),\n \t\t\t\t\t\t log2 / 8));\n       xoperands[1] = GEN_INT (log2 % 8);\n       output_asm_insn (\"set1 %1,%0\", xoperands);\n@@ -745,7 +747,7 @@\n     {\n       rtx xoperands[2];\n       xoperands[0] = gen_rtx_MEM (QImode,\n-\t\t\t\t  plus_constant (XEXP (operands[0], 0),\n+\t\t\t\t  plus_constant (Pmode, XEXP (operands[0], 0),\n \t\t\t\t\t\t log2 / 8));\n       xoperands[1] = GEN_INT (log2 % 8);\n       output_asm_insn (\"set1 %1,%0\", xoperands);\n@@ -798,7 +800,7 @@\n     {\n       rtx xoperands[2];\n       xoperands[0] = gen_rtx_MEM (QImode,\n-\t\t\t\t  plus_constant (XEXP (operands[0], 0),\n+\t\t\t\t  plus_constant (Pmode, XEXP (operands[0], 0),\n \t\t\t\t\t\t log2 / 8));\n       xoperands[1] = GEN_INT (log2 % 8);\n       output_asm_insn (\"not1 %1,%0\", xoperands);\n@@ -824,7 +826,7 @@\n     {\n       rtx xoperands[2];\n       xoperands[0] = gen_rtx_MEM (QImode,\n-\t\t\t\t  plus_constant (XEXP (operands[0], 0),\n+\t\t\t\t  plus_constant (Pmode, XEXP (operands[0], 0),\n \t\t\t\t\t\t log2 / 8));\n       xoperands[1] = GEN_INT (log2 % 8);\n       output_asm_insn (\"not1 %1,%0\", xoperands);"}, {"sha": "7796f348d5953a1b57d06074ee03e325c116ec75", "filename": "gcc/config/vax/elf.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fvax%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fvax%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Felf.h?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -55,13 +55,15 @@ along with GCC; see the file COPYING3.  If not see\n /* Place the top of the stack for the DWARF2 EH stackadj value.  */\n #define EH_RETURN_STACKADJ_RTX\t\t\t\t\t\t\\\n   gen_rtx_MEM (SImode,\t\t\t\t\t\t\t\\\n-\t       plus_constant (gen_rtx_REG (Pmode, FRAME_POINTER_REGNUM),\\\n+\t       plus_constant (Pmode,\t\t\t\t\t\\\n+\t\t\t      gen_rtx_REG (Pmode, FRAME_POINTER_REGNUM),\\\n \t\t\t      -4))\n \n /* Simple store the return handler into the call frame.  */\n #define EH_RETURN_HANDLER_RTX\t\t\t\t\t\t\\\n   gen_rtx_MEM (Pmode,\t\t\t\t\t\t\t\\\n-\t       plus_constant (gen_rtx_REG (Pmode, FRAME_POINTER_REGNUM),\\\n+\t       plus_constant (Pmode,\t\t\t\t\t\\\n+\t\t\t      gen_rtx_REG (Pmode, FRAME_POINTER_REGNUM),\\\n \t\t\t      16))\n \n "}, {"sha": "aa929ca1e50e575a6745055d60293b3691d2890d", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -138,7 +138,7 @@ vax_add_reg_cfa_offset (rtx insn, int offset, rtx src)\n {\n   rtx x;\n \n-  x = plus_constant (frame_pointer_rtx, offset);\n+  x = plus_constant (Pmode, frame_pointer_rtx, offset);\n   x = gen_rtx_MEM (SImode, x);\n   x = gen_rtx_SET (VOIDmode, x, src);\n   add_reg_note (insn, REG_CFA_OFFSET, x);\n@@ -201,7 +201,7 @@ vax_expand_prologue (void)\n      it will be processed first.  This is required to allow the other\n      notes be interpreted properly.  */\n   add_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\tplus_constant (frame_pointer_rtx, offset));\n+\t\tplus_constant (Pmode, frame_pointer_rtx, offset));\n \n   /* Allocate the local stack frame.  */\n   size = get_frame_size ();\n@@ -373,11 +373,13 @@ print_operand_address (FILE * file, rtx addr)\n \t      if (offset)\n \t\t{\n \t\t  if (CONST_INT_P (offset))\n-\t\t    offset = plus_constant (XEXP (addr, 0), INTVAL (offset));\n+\t\t    offset = plus_constant (Pmode, XEXP (addr, 0),\n+\t\t\t\t\t    INTVAL (offset));\n \t\t  else\n \t\t    {\n \t\t      gcc_assert (CONST_INT_P (XEXP (addr, 0)));\n-\t\t      offset = plus_constant (offset, INTVAL (XEXP (addr, 0)));\n+\t\t      offset = plus_constant (Pmode, offset,\n+\t\t\t\t\t      INTVAL (XEXP (addr, 0)));\n \t\t    }\n \t\t}\n \t      offset = XEXP (addr, 0);\n@@ -402,11 +404,13 @@ print_operand_address (FILE * file, rtx addr)\n \t      if (offset)\n \t\t{\n \t\t  if (CONST_INT_P (offset))\n-\t\t    offset = plus_constant (XEXP (addr, 1), INTVAL (offset));\n+\t\t    offset = plus_constant (Pmode, XEXP (addr, 1),\n+\t\t\t\t\t    INTVAL (offset));\n \t\t  else\n \t\t    {\n \t\t      gcc_assert (CONST_INT_P (XEXP (addr, 1)));\n-\t\t      offset = plus_constant (offset, INTVAL (XEXP (addr, 1)));\n+\t\t      offset = plus_constant (Pmode, offset,\n+\t\t\t\t\t      INTVAL (XEXP (addr, 1)));\n \t\t    }\n \t\t}\n \t      offset = XEXP (addr, 1);\n@@ -2108,7 +2112,7 @@ vax_trampoline_init (rtx m_tramp, tree fndecl, rtx cxt)\n   mem = adjust_address (m_tramp, SImode, 4);\n   emit_move_insn (mem, cxt);\n   mem = adjust_address (m_tramp, SImode, 11);\n-  emit_move_insn (mem, plus_constant (fnaddr, 2));\n+  emit_move_insn (mem, plus_constant (Pmode, fnaddr, 2));\n   emit_insn (gen_sync_istream ());\n }\n "}, {"sha": "a9de79c62fb1b4375b90dec16a72f4bb2168c947", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -259,7 +259,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* Given an rtx for the address of a frame,\n    return an rtx for the address of the word in the frame\n    that holds the dynamic chain--the previous frame's address.  */\n-#define DYNAMIC_CHAIN_ADDRESS(FRAME) plus_constant ((FRAME), 12)\n+#define DYNAMIC_CHAIN_ADDRESS(FRAME) plus_constant (Pmode, (FRAME), 12)\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.\n@@ -370,7 +370,8 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n #define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t\\\n   ((COUNT == 0)\t\t\t\t\t\t\t\t\\\n-   ? gen_rtx_MEM (Pmode, plus_constant (FRAME, RETURN_ADDRESS_OFFSET))\t\\\n+   ? gen_rtx_MEM (Pmode, plus_constant (Pmode, FRAME,\t\t\t\\\n+\t\t\t\t\tRETURN_ADDRESS_OFFSET))\t\t\\\n    : (rtx) 0)\n \n \f"}, {"sha": "fa38008bb0b36106c11925a770ce4770eb13220c", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -2682,7 +2682,8 @@ xtensa_expand_prologue (void)\n   note_rtx = gen_rtx_SET (VOIDmode, (frame_pointer_needed\n \t\t\t\t     ? hard_frame_pointer_rtx\n \t\t\t\t     : stack_pointer_rtx),\n-\t\t\t  plus_constant (stack_pointer_rtx, -total_size));\n+\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t -total_size));\n   RTX_FRAME_RELATED_P (insn) = 1;\n   add_reg_note (insn, REG_FRAME_RELATED_EXPR, note_rtx);\n }\n@@ -2707,7 +2708,7 @@ xtensa_return_addr (int count, rtx frame)\n     retaddr = gen_rtx_REG (Pmode, A0_REG);\n   else\n     {\n-      rtx addr = plus_constant (frame, -4 * UNITS_PER_WORD);\n+      rtx addr = plus_constant (Pmode, frame, -4 * UNITS_PER_WORD);\n       addr = memory_address (Pmode, addr);\n       retaddr = gen_reg_rtx (Pmode);\n       emit_move_insn (retaddr, gen_rtx_MEM (Pmode, addr));\n@@ -3608,7 +3609,8 @@ static rtx\n xtensa_static_chain (const_tree ARG_UNUSED (fndecl), bool incoming_p)\n {\n   rtx base = incoming_p ? arg_pointer_rtx : stack_pointer_rtx;\n-  return gen_frame_mem (Pmode, plus_constant (base, -5 * UNITS_PER_WORD));\n+  return gen_frame_mem (Pmode, plus_constant (Pmode, base,\n+\t\t\t\t\t      -5 * UNITS_PER_WORD));\n }\n \n "}, {"sha": "a8df74b0be024d93b3dcaea20af0b286f27a4329", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1258,7 +1258,7 @@ insert_const_anchor (HOST_WIDE_INT anchor, rtx reg, HOST_WIDE_INT offs,\n   if (!elt)\n     elt = insert (anchor_exp, NULL, hash, mode);\n \n-  exp = plus_constant (reg, offs);\n+  exp = plus_constant (mode, reg, offs);\n   /* REG has just been inserted and the hash codes recomputed.  */\n   mention_regs (exp);\n   hash = HASH (exp, mode);\n@@ -1333,7 +1333,7 @@ find_reg_offset_for_const (struct table_elt *anchor_elt, HOST_WIDE_INT offs,\n \t  if (!REG_P (elt->exp) && !exp_equiv_p (elt->exp, elt->exp, 1, false))\n \t    continue;\n \n-\t  x = plus_constant (elt->exp, offs);\n+\t  x = plus_constant (GET_MODE (elt->exp), elt->exp, offs);\n \t  if (REG_P (x)\n \t      || (GET_CODE (x) == PLUS\n \t\t  && IN_RANGE (INTVAL (XEXP (x, 1)),\n@@ -2218,7 +2218,7 @@ use_related_value (rtx x, struct table_elt *elt)\n \n   offset = (get_integer_term (x) - get_integer_term (p->exp));\n   /* Note: OFFSET may be 0 if P->xexp and X are related by commutativity.  */\n-  return plus_constant (q->exp, offset);\n+  return plus_constant (q->mode, q->exp, offset);\n }\n \f\n \n@@ -3567,7 +3567,7 @@ fold_rtx (rtx x, rtx insn)\n \t    {\n \t      rtx y = lookup_as_function (XEXP (x, 0), PLUS);\n \t      if (y && CONST_INT_P (XEXP (y, 1)))\n-\t\treturn fold_rtx (plus_constant (copy_rtx (y),\n+\t\treturn fold_rtx (plus_constant (mode, copy_rtx (y),\n \t\t\t\t\t\t-INTVAL (const_arg1)),\n \t\t\t\t NULL_RTX);\n \t    }"}, {"sha": "51212770c04c630822a83e272422f005fe7e6116", "filename": "gcc/cselib.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1866,7 +1866,8 @@ cselib_subst_to_values (rtx x, enum machine_mode memmode)\n       i = GET_MODE_SIZE (memmode);\n       if (code == PRE_DEC)\n \ti = -i;\n-      return cselib_subst_to_values (plus_constant (XEXP (x, 0), i),\n+      return cselib_subst_to_values (plus_constant (GET_MODE (x),\n+\t\t\t\t\t\t    XEXP (x, 0), i),\n \t\t\t\t     memmode);\n \n     case PRE_MODIFY:"}, {"sha": "0523757b5fb0cb76498e8dc15ce22599f5cdbd95", "filename": "gcc/dse.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1392,6 +1392,7 @@ record_store (rtx body, bb_info_t bb_info)\n   cselib_val *base = NULL;\n   insn_info_t ptr, last, redundant_reason;\n   bool store_is_unused;\n+  enum machine_mode address_mode;\n \n   if (GET_CODE (body) != SET && GET_CODE (body) != CLOBBER)\n     return 0;\n@@ -1454,6 +1455,8 @@ record_store (rtx body, bb_info_t bb_info)\n       return 0;\n     }\n \n+  address_mode = targetm.addr_space.address_mode (MEM_ADDR_SPACE (mem));\n+\n   if (GET_MODE (mem) == BLKmode)\n     width = MEM_SIZE (mem);\n   else\n@@ -1561,7 +1564,7 @@ record_store (rtx body, bb_info_t bb_info)\n \t  mem_addr = group->canon_base_addr;\n \t}\n       if (offset)\n-\tmem_addr = plus_constant (mem_addr, offset);\n+\tmem_addr = plus_constant (address_mode, mem_addr, offset);\n     }\n \n   while (ptr)\n@@ -2178,7 +2181,11 @@ check_mem_read_rtx (rtx *loc, void *data)\n \t  mem_addr = group->canon_base_addr;\n \t}\n       if (offset)\n-\tmem_addr = plus_constant (mem_addr, offset);\n+\t{\n+\t  enum machine_mode address_mode\n+\t    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (mem));\n+\t  mem_addr = plus_constant (address_mode, mem_addr, offset);\n+\t}\n     }\n \n   /* We ignore the clobbers in store_info.  The is mildly aggressive,"}, {"sha": "8da10f27b07d6e7b95fbe59fcffc8fbfe593ad69", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -14286,11 +14286,12 @@ rtl_for_decl_location (tree decl)\n \t       && (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (decl)))\n \t\t   < UNITS_PER_WORD))\n \t{\n+\t  enum machine_mode addr_mode = get_address_mode (rtl);\n \t  int offset = (UNITS_PER_WORD\n \t\t\t- GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (decl))));\n \n \t  rtl = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (decl)),\n-\t\t\t     plus_constant (XEXP (rtl, 0), offset));\n+\t\t\t     plus_constant (addr_mode, XEXP (rtl, 0), offset));\n \t}\n     }\n   else if (TREE_CODE (decl) == VAR_DECL\n@@ -14299,6 +14300,7 @@ rtl_for_decl_location (tree decl)\n \t   && GET_MODE (rtl) != TYPE_MODE (TREE_TYPE (decl))\n \t   && BYTES_BIG_ENDIAN)\n     {\n+      enum machine_mode addr_mode = get_address_mode (rtl);\n       int rsize = GET_MODE_SIZE (GET_MODE (rtl));\n       int dsize = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (decl)));\n \n@@ -14310,7 +14312,8 @@ rtl_for_decl_location (tree decl)\n \t else gdb will not be able to display it.  */\n       if (rsize > dsize)\n \trtl = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (decl)),\n-\t\t\t   plus_constant (XEXP (rtl, 0), rsize-dsize));\n+\t\t\t   plus_constant (addr_mode, XEXP (rtl, 0),\n+\t\t\t\t\t  rsize - dsize));\n     }\n \n   /* A variable with no DECL_RTL but a DECL_INITIAL is a compile-time constant,\n@@ -17267,10 +17270,13 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n \t\t\t  && loc->expr->dw_loc_next == NULL\n \t\t\t  && GET_CODE (loc->expr->dw_loc_oprnd1.v.val_addr)\n \t\t\t     == SYMBOL_REF)\n-\t\t\tloc->expr->dw_loc_oprnd1.v.val_addr\n-\t\t\t  = plus_constant (loc->expr->dw_loc_oprnd1.v.val_addr, off);\n-\t\t\telse\n-\t\t\t  loc_list_plus_const (loc, off);\n+\t\t\t{\n+\t\t\t  rtx x = loc->expr->dw_loc_oprnd1.v.val_addr;\n+\t\t\t  loc->expr->dw_loc_oprnd1.v.val_addr\n+\t\t\t    = plus_constant (GET_MODE (x), x , off);\n+\t\t\t}\n+\t\t      else\n+\t\t\tloc_list_plus_const (loc, off);\n \t\t    }\n \t\t  add_AT_location_description (var_die, DW_AT_location, loc);\n \t\t  remove_AT (var_die, DW_AT_declaration);\n@@ -17330,8 +17336,11 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n \t\t  && loc->expr->dw_loc_opc == DW_OP_addr\n \t\t  && loc->expr->dw_loc_next == NULL\n \t\t  && GET_CODE (loc->expr->dw_loc_oprnd1.v.val_addr) == SYMBOL_REF)\n-\t\tloc->expr->dw_loc_oprnd1.v.val_addr\n-\t\t  = plus_constant (loc->expr->dw_loc_oprnd1.v.val_addr, off);\n+\t\t{\n+\t\t  rtx x = loc->expr->dw_loc_oprnd1.v.val_addr;\n+\t\t  loc->expr->dw_loc_oprnd1.v.val_addr\n+\t\t    = plus_constant (GET_MODE (x), x, off);\n+\t\t}\n \t      else\n \t\tloc_list_plus_const (loc, off);\n \t    }"}, {"sha": "25c8deda982e94ac4216f1edb43b0e8ba5ade930", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -2110,9 +2110,10 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n \t  && (unsigned HOST_WIDE_INT) offset\n \t      < GET_MODE_ALIGNMENT (GET_MODE (memref)) / BITS_PER_UNIT)\n \taddr = gen_rtx_LO_SUM (address_mode, XEXP (addr, 0),\n-\t\t\t       plus_constant (XEXP (addr, 1), offset));\n+\t\t\t       plus_constant (address_mode,\n+\t\t\t\t\t      XEXP (addr, 1), offset));\n       else\n-\taddr = plus_constant (addr, offset);\n+\taddr = plus_constant (address_mode, addr, offset);\n     }\n \n   new_rtx = change_address_1 (memref, mode, addr, validate);"}, {"sha": "158ca20745a89be38f52565c449ce01222fc6822", "filename": "gcc/except.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1155,7 +1155,7 @@ sjlj_emit_function_enter (rtx dispatch_label)\n       rtx x, last;\n       x = emit_library_call_value (setjmp_libfunc, NULL_RTX, LCT_RETURNS_TWICE,\n \t\t\t\t   TYPE_MODE (integer_type_node), 1,\n-\t\t\t\t   plus_constant (XEXP (fc, 0),\n+\t\t\t\t   plus_constant (Pmode, XEXP (fc, 0),\n \t\t\t\t\t\t  sjlj_fc_jbuf_ofs), Pmode);\n \n       emit_cmp_and_jump_insns (x, const0_rtx, NE, 0,\n@@ -1168,7 +1168,7 @@ sjlj_emit_function_enter (rtx dispatch_label)\n \t  add_reg_note (last, REG_BR_PROB, GEN_INT (REG_BR_PROB_BASE / 100));\n \t}\n #else\n-      expand_builtin_setjmp_setup (plus_constant (XEXP (fc, 0),\n+      expand_builtin_setjmp_setup (plus_constant (Pmode, XEXP (fc, 0),\n \t\t\t\t\t\t  sjlj_fc_jbuf_ofs),\n \t\t\t\t   dispatch_label);\n #endif\n@@ -2094,7 +2094,7 @@ expand_builtin_extract_return_addr (tree addr_tree)\n \n   /* Then adjust to find the real return address.  */\n #if defined (RETURN_ADDR_OFFSET)\n-  addr = plus_constant (addr, RETURN_ADDR_OFFSET);\n+  addr = plus_constant (Pmode, addr, RETURN_ADDR_OFFSET);\n #endif\n \n   return addr;\n@@ -2113,7 +2113,7 @@ expand_builtin_frob_return_addr (tree addr_tree)\n \n #ifdef RETURN_ADDR_OFFSET\n   addr = force_reg (Pmode, addr);\n-  addr = plus_constant (addr, -RETURN_ADDR_OFFSET);\n+  addr = plus_constant (Pmode, addr, -RETURN_ADDR_OFFSET);\n #endif\n \n   return addr;"}, {"sha": "cc4391c5e8db28cb72e79a91ddaea8c233115761", "filename": "gcc/explow.c", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -75,22 +75,18 @@ trunc_int_for_mode (HOST_WIDE_INT c, enum machine_mode mode)\n }\n \n /* Return an rtx for the sum of X and the integer C, given that X has\n-   mode MODE.  This routine should be used instead of plus_constant\n-   when they want to ensure that addition happens in a particular\n-   mode, which is necessary when X can be a VOIDmode CONST_INT or\n-   CONST_DOUBLE and the width of the constant is different from the\n-   width of the expression.  */\n-/* TODO: All callers of plus_constant should migrate to this routine,\n-   and once they do, we can assert that mode is not VOIDmode.  */\n+   mode MODE.  */\n \n rtx\n-plus_constant_mode (enum machine_mode mode, rtx x, HOST_WIDE_INT c)\n+plus_constant (enum machine_mode mode, rtx x, HOST_WIDE_INT c)\n {\n   RTX_CODE code;\n   rtx y;\n   rtx tem;\n   int all_constant = 0;\n \n+  gcc_assert (GET_MODE (x) == VOIDmode || GET_MODE (x) == mode);\n+\n   if (c == 0)\n     return x;\n \n@@ -143,7 +139,7 @@ plus_constant_mode (enum machine_mode mode, rtx x, HOST_WIDE_INT c)\n       if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n \t  && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))\n \t{\n-\t  tem = plus_constant_mode (mode, get_pool_constant (XEXP (x, 0)), c);\n+\t  tem = plus_constant (mode, get_pool_constant (XEXP (x, 0)), c);\n \t  tem = force_const_mem (GET_MODE (x), tem);\n \t  if (memory_address_p (GET_MODE (tem), XEXP (tem, 0)))\n \t    return tem;\n@@ -173,7 +169,8 @@ plus_constant_mode (enum machine_mode mode, rtx x, HOST_WIDE_INT c)\n \n       if (CONSTANT_P (XEXP (x, 1)))\n \t{\n-\t  x = gen_rtx_PLUS (mode, XEXP (x, 0), plus_constant_mode (mode, XEXP (x, 1), c));\n+\t  x = gen_rtx_PLUS (mode, XEXP (x, 0),\n+\t\t\t    plus_constant (mode, XEXP (x, 1), c));\n \t  c = 0;\n \t}\n       else if (find_constant_term_loc (&y))\n@@ -183,7 +180,7 @@ plus_constant_mode (enum machine_mode mode, rtx x, HOST_WIDE_INT c)\n \t  rtx copy = copy_rtx (x);\n \t  rtx *const_loc = find_constant_term_loc (&copy);\n \n-\t  *const_loc = plus_constant_mode (mode, *const_loc, c);\n+\t  *const_loc = plus_constant (mode, *const_loc, c);\n \t  x = copy;\n \t  c = 0;\n \t}\n@@ -203,14 +200,6 @@ plus_constant_mode (enum machine_mode mode, rtx x, HOST_WIDE_INT c)\n   else\n     return x;\n }\n-\n-/* Return an rtx for the sum of X and the integer C.  */\n-\n-rtx\n-plus_constant (rtx x, HOST_WIDE_INT c)\n-{\n-  return plus_constant_mode (GET_MODE (x), x, c);\n-}\n \f\n /* If X is a sum, return a new sum like X but lacking any constant terms.\n    Add all the removed constant terms into *CONSTPTR.\n@@ -567,6 +556,7 @@ use_anchored_address (rtx x)\n {\n   rtx base;\n   HOST_WIDE_INT offset;\n+  enum machine_mode mode;\n \n   if (!flag_section_anchors)\n     return x;\n@@ -607,10 +597,11 @@ use_anchored_address (rtx x)\n   /* If we're going to run a CSE pass, force the anchor into a register.\n      We will then be able to reuse registers for several accesses, if the\n      target costs say that that's worthwhile.  */\n+  mode = GET_MODE (base);\n   if (!cse_not_expected)\n-    base = force_reg (GET_MODE (base), base);\n+    base = force_reg (mode, base);\n \n-  return replace_equiv_address (x, plus_constant (base, offset));\n+  return replace_equiv_address (x, plus_constant (mode, base, offset));\n }\n \f\n /* Copy the value or contents of X to a new temp reg and return that reg.  */\n@@ -995,7 +986,8 @@ round_push (rtx size)\n \t substituted by the right value in vregs pass and optimized\n \t during combine.  */\n       align_rtx = virtual_preferred_stack_boundary_rtx;\n-      alignm1_rtx = force_operand (plus_constant (align_rtx, -1), NULL_RTX);\n+      alignm1_rtx = force_operand (plus_constant (Pmode, align_rtx, -1),\n+\t\t\t\t   NULL_RTX);\n     }\n \n   /* CEIL_DIV_EXPR needs to worry about the addition overflowing,\n@@ -1285,7 +1277,7 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n     {\n       unsigned extra = (required_align - extra_align) / BITS_PER_UNIT;\n \n-      size = plus_constant (size, extra);\n+      size = plus_constant (Pmode, size, extra);\n       size = force_operand (size, NULL_RTX);\n \n       if (flag_stack_usage_info)\n@@ -1576,7 +1568,8 @@ probe_stack_range (HOST_WIDE_INT first, rtx size)\n       rtx addr = memory_address (Pmode,\n \t\t\t\t gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n \t\t\t\t\t         stack_pointer_rtx,\n-\t\t\t\t\t         plus_constant (size, first)));\n+\t\t\t\t\t         plus_constant (Pmode,\n+\t\t\t\t\t\t\t\tsize, first)));\n       emit_library_call (stack_check_libfunc, LCT_NORMAL, VOIDmode, 1, addr,\n \t\t\t Pmode);\n       return;\n@@ -1590,7 +1583,8 @@ probe_stack_range (HOST_WIDE_INT first, rtx size)\n       rtx addr = memory_address (Pmode,\n \t\t\t\t gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n \t\t\t\t\t         stack_pointer_rtx,\n-\t\t\t\t\t         plus_constant (size, first)));\n+\t\t\t\t\t         plus_constant (Pmode,\n+\t\t\t\t\t\t\t\tsize, first)));\n \n       create_input_operand (&ops[0], addr, Pmode);\n       if (maybe_expand_insn (CODE_FOR_check_stack, 1, ops))\n@@ -1611,13 +1605,13 @@ probe_stack_range (HOST_WIDE_INT first, rtx size)\n       for (i = PROBE_INTERVAL; i < isize; i += PROBE_INTERVAL)\n \t{\n \t  addr = memory_address (Pmode,\n-\t\t\t\t plus_constant (stack_pointer_rtx,\n+\t\t\t\t plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t \t\tSTACK_GROW_OFF (first + i)));\n \t  emit_stack_probe (addr);\n \t}\n \n       addr = memory_address (Pmode,\n-\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t     plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t    STACK_GROW_OFF (first + isize)));\n       emit_stack_probe (addr);\n     }\n@@ -1701,7 +1695,7 @@ probe_stack_range (HOST_WIDE_INT first, rtx size)\n \t      /* Use [base + disp} addressing mode if supported.  */\n \t      HOST_WIDE_INT offset = INTVAL (temp);\n \t      addr = memory_address (Pmode,\n-\t\t\t\t     plus_constant (last_addr,\n+\t\t\t\t     plus_constant (Pmode, last_addr,\n \t\t\t\t\t\t    STACK_GROW_OFF (offset)));\n \t    }\n \t  else\n@@ -1759,9 +1753,9 @@ anti_adjust_stack_and_probe (rtx size, bool adjust_back)\n \t}\n \n       if (first_probe)\n-\tanti_adjust_stack (plus_constant (size, PROBE_INTERVAL + dope));\n+\tanti_adjust_stack (plus_constant (Pmode, size, PROBE_INTERVAL + dope));\n       else\n-\tanti_adjust_stack (plus_constant (size, PROBE_INTERVAL - i));\n+\tanti_adjust_stack (plus_constant (Pmode, size, PROBE_INTERVAL - i));\n       emit_stack_probe (stack_pointer_rtx);\n     }\n \n@@ -1839,7 +1833,7 @@ anti_adjust_stack_and_probe (rtx size, bool adjust_back)\n \n   /* Adjust back and account for the additional first interval.  */\n   if (adjust_back)\n-    adjust_stack (plus_constant (size, PROBE_INTERVAL + dope));\n+    adjust_stack (plus_constant (Pmode, size, PROBE_INTERVAL + dope));\n   else\n     adjust_stack (GEN_INT (PROBE_INTERVAL + dope));\n }"}, {"sha": "45b150efc3e56639effb721299981b9dcc4c4b26", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -4786,7 +4786,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\tremainder = expand_binop (compute_mode, sub_optab, op0, tem,\n \t\t\t\t\t  remainder, 1, OPTAB_LIB_WIDEN);\n \t      }\n-\t    tem = plus_constant (op1, -1);\n+\t    tem = plus_constant (compute_mode, op1, -1);\n \t    tem = expand_shift (RSHIFT_EXPR, compute_mode, tem, 1, NULL_RTX, 1);\n \t    do_cmp_and_jump (remainder, tem, LEU, compute_mode, label);\n \t    expand_inc (quotient, const1_rtx);"}, {"sha": "fa512a2823828f06efb7459fa1ba8f19a5785ce4", "filename": "gcc/expr.c", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -927,7 +927,8 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n       if (USE_LOAD_PRE_DECREMENT (mode) && data.reverse && ! data.autinc_from)\n \t{\n \t  data.from_addr = copy_to_mode_reg (from_addr_mode,\n-\t\t\t\t\t     plus_constant (from_addr, len));\n+\t\t\t\t\t     plus_constant (from_addr_mode,\n+\t\t\t\t\t\t\t    from_addr, len));\n \t  data.autinc_from = 1;\n \t  data.explicit_inc_from = -1;\n \t}\n@@ -942,7 +943,8 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n       if (USE_STORE_PRE_DECREMENT (mode) && data.reverse && ! data.autinc_to)\n \t{\n \t  data.to_addr = copy_to_mode_reg (to_addr_mode,\n-\t\t\t\t\t   plus_constant (to_addr, len));\n+\t\t\t\t\t   plus_constant (to_addr_mode,\n+\t\t\t\t\t\t\t  to_addr, len));\n \t  data.autinc_to = 1;\n \t  data.explicit_inc_to = -1;\n \t}\n@@ -991,7 +993,8 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n \t\temit_insn (gen_add2_insn (data.to_addr, constm1_rtx));\n \t      else\n \t\tdata.to_addr = copy_to_mode_reg (to_addr_mode,\n-\t\t\t\t\t\t plus_constant (data.to_addr,\n+\t\t\t\t\t\t plus_constant (to_addr_mode,\n+\t\t\t\t\t\t\t\tdata.to_addr,\n \t\t\t\t\t\t\t\t-1));\n \t    }\n \t  to1 = adjust_automodify_address (data.to, QImode, data.to_addr,\n@@ -2492,7 +2495,8 @@ store_by_pieces (rtx to, unsigned HOST_WIDE_INT len,\n \t\temit_insn (gen_add2_insn (data.to_addr, constm1_rtx));\n \t      else\n \t\tdata.to_addr = copy_to_mode_reg (to_addr_mode,\n-\t\t\t\t\t\t plus_constant (data.to_addr,\n+\t\t\t\t\t\t plus_constant (to_addr_mode,\n+\t\t\t\t\t\t\t\tdata.to_addr,\n \t\t\t\t\t\t\t\t-1));\n \t    }\n \t  to1 = adjust_automodify_address (data.to, QImode, data.to_addr,\n@@ -2580,7 +2584,9 @@ store_by_pieces_1 (struct store_by_pieces_d *data ATTRIBUTE_UNUSED,\n       if (USE_STORE_PRE_DECREMENT (mode) && data->reverse && ! data->autinc_to)\n \t{\n \t  data->to_addr = copy_to_mode_reg (to_addr_mode,\n-\t\t\t\t\t    plus_constant (to_addr, data->len));\n+\t\t\t\t\t    plus_constant (to_addr_mode,\n+\t\t\t\t\t\t\t   to_addr,\n+\t\t\t\t\t\t\t   data->len));\n \t  data->autinc_to = 1;\n \t  data->explicit_inc_to = -1;\n \t}\n@@ -3115,7 +3121,7 @@ emit_move_resolve_push (enum machine_mode mode, rtx x)\n     case POST_INC:\n     case POST_DEC:\n     case POST_MODIFY:\n-      temp = plus_constant (stack_pointer_rtx, -adjust);\n+      temp = plus_constant (Pmode, stack_pointer_rtx, -adjust);\n       break;\n     default:\n       gcc_unreachable ();\n@@ -3595,7 +3601,7 @@ push_block (rtx size, int extra, int below)\n \n   size = convert_modes (Pmode, ptr_mode, size, 1);\n   if (CONSTANT_P (size))\n-    anti_adjust_stack (plus_constant (size, extra));\n+    anti_adjust_stack (plus_constant (Pmode, size, extra));\n   else if (REG_P (size) && extra == 0)\n     anti_adjust_stack (size);\n   else\n@@ -3615,16 +3621,17 @@ push_block (rtx size, int extra, int below)\n     {\n       temp = virtual_outgoing_args_rtx;\n       if (extra != 0 && below)\n-\ttemp = plus_constant (temp, extra);\n+\ttemp = plus_constant (Pmode, temp, extra);\n     }\n   else\n     {\n       if (CONST_INT_P (size))\n-\ttemp = plus_constant (virtual_outgoing_args_rtx,\n+\ttemp = plus_constant (Pmode, virtual_outgoing_args_rtx,\n \t\t\t      -INTVAL (size) - (below ? 0 : extra));\n       else if (extra != 0 && !below)\n \ttemp = gen_rtx_PLUS (Pmode, virtual_outgoing_args_rtx,\n-\t\t\t     negate_rtx (Pmode, plus_constant (size, extra)));\n+\t\t\t     negate_rtx (Pmode, plus_constant (Pmode, size,\n+\t\t\t\t\t\t\t       extra)));\n       else\n \ttemp = gen_rtx_PLUS (Pmode, virtual_outgoing_args_rtx,\n \t\t\t     negate_rtx (Pmode, size));\n@@ -4097,11 +4104,12 @@ emit_push_insn (rtx x, enum machine_mode mode, tree type, rtx size,\n \t    }\n \t  else if (CONST_INT_P (args_so_far))\n \t    temp = memory_address (BLKmode,\n-\t\t\t\t   plus_constant (args_addr,\n+\t\t\t\t   plus_constant (Pmode, args_addr,\n \t\t\t\t\t\t  skip + INTVAL (args_so_far)));\n \t  else\n \t    temp = memory_address (BLKmode,\n-\t\t\t\t   plus_constant (gen_rtx_PLUS (Pmode,\n+\t\t\t\t   plus_constant (Pmode,\n+\t\t\t\t\t\t  gen_rtx_PLUS (Pmode,\n \t\t\t\t\t\t\t\targs_addr,\n \t\t\t\t\t\t\t\targs_so_far),\n \t\t\t\t\t\t  skip));\n@@ -4214,7 +4222,7 @@ emit_push_insn (rtx x, enum machine_mode mode, tree type, rtx size,\n \t  if (CONST_INT_P (args_so_far))\n \t    addr\n \t      = memory_address (mode,\n-\t\t\t\tplus_constant (args_addr,\n+\t\t\t\tplus_constant (Pmode, args_addr,\n \t\t\t\t\t       INTVAL (args_so_far)));\n \t  else\n \t    addr = memory_address (mode, gen_rtx_PLUS (Pmode, args_addr,\n@@ -5264,7 +5272,8 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t\t Do all calculations in pointer_mode.  */\n \t      if (CONST_INT_P (copy_size_rtx))\n \t\t{\n-\t\t  size = plus_constant (size, -INTVAL (copy_size_rtx));\n+\t\t  size = plus_constant (address_mode, size,\n+\t\t\t\t\t-INTVAL (copy_size_rtx));\n \t\t  target = adjust_address (target, BLKmode,\n \t\t\t\t\t   INTVAL (copy_size_rtx));\n \t\t}\n@@ -7628,7 +7637,7 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n \t of such an object.  */\n       gcc_assert ((bitpos % BITS_PER_UNIT) == 0);\n \n-      result = plus_constant (result, bitpos / BITS_PER_UNIT);\n+      result = plus_constant (tmode, result, bitpos / BITS_PER_UNIT);\n       if (modifier < EXPAND_SUM)\n \tresult = force_operand (result, target);\n     }\n@@ -8223,7 +8232,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t\t= immed_double_const (TREE_INT_CST_LOW (treeop0),\n \t\t\t\t      (HOST_WIDE_INT) 0,\n \t\t\t\t      TYPE_MODE (TREE_TYPE (treeop1)));\n-\t      op1 = plus_constant (op1, INTVAL (constant_part));\n+\t      op1 = plus_constant (mode, op1, INTVAL (constant_part));\n \t      if (modifier != EXPAND_SUM && modifier != EXPAND_INITIALIZER)\n \t\top1 = force_operand (op1, target);\n \t      return REDUCE_BIT_FIELD (op1);\n@@ -8256,7 +8265,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t\t= immed_double_const (TREE_INT_CST_LOW (treeop1),\n \t\t\t\t      (HOST_WIDE_INT) 0,\n \t\t\t\t      TYPE_MODE (TREE_TYPE (treeop0)));\n-\t      op0 = plus_constant (op0, INTVAL (constant_part));\n+\t      op0 = plus_constant (mode, op0, INTVAL (constant_part));\n \t      if (modifier != EXPAND_SUM && modifier != EXPAND_INITIALIZER)\n \t\top0 = force_operand (op0, target);\n \t      return REDUCE_BIT_FIELD (op0);\n@@ -8318,7 +8327,8 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t  /* If the last operand is a CONST_INT, use plus_constant of\n \t     the negated constant.  Else make the MINUS.  */\n \t  if (CONST_INT_P (op1))\n-\t    return REDUCE_BIT_FIELD (plus_constant (op0, - INTVAL (op1)));\n+\t    return REDUCE_BIT_FIELD (plus_constant (mode, op0,\n+\t\t\t\t\t\t    -INTVAL (op1)));\n \t  else\n \t    return REDUCE_BIT_FIELD (gen_rtx_MINUS (mode, op0, op1));\n \t}"}, {"sha": "b5e9011ce23ddda9903b576563f9a66ff28244e9", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -496,12 +496,12 @@ assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size,\n   /* If we have already instantiated virtual registers, return the actual\n      address relative to the frame pointer.  */\n   if (virtuals_instantiated)\n-    addr = plus_constant (frame_pointer_rtx,\n+    addr = plus_constant (Pmode, frame_pointer_rtx,\n \t\t\t  trunc_int_for_mode\n \t\t\t  (slot_offset + bigend_correction\n \t\t\t   + STARTING_FRAME_OFFSET, Pmode));\n   else\n-    addr = plus_constant (virtual_stack_vars_rtx,\n+    addr = plus_constant (Pmode, virtual_stack_vars_rtx,\n \t\t\t  trunc_int_for_mode\n \t\t\t  (slot_offset + bigend_correction,\n \t\t\t   Pmode));\n@@ -1449,7 +1449,7 @@ instantiate_virtual_regs_in_rtx (rtx *loc, void *data)\n       new_rtx = instantiate_new_reg (x, &offset);\n       if (new_rtx)\n \t{\n-\t  *loc = plus_constant (new_rtx, offset);\n+\t  *loc = plus_constant (GET_MODE (x), new_rtx, offset);\n \t  if (changed)\n \t    *changed = true;\n \t}\n@@ -1459,7 +1459,7 @@ instantiate_virtual_regs_in_rtx (rtx *loc, void *data)\n       new_rtx = instantiate_new_reg (XEXP (x, 0), &offset);\n       if (new_rtx)\n \t{\n-\t  new_rtx = plus_constant (new_rtx, offset);\n+\t  new_rtx = plus_constant (GET_MODE (x), new_rtx, offset);\n \t  *loc = simplify_gen_binary (PLUS, GET_MODE (x), new_rtx, XEXP (x, 1));\n \t  if (changed)\n \t    *changed = true;"}, {"sha": "f8c5de7e722e6a781707ed2de4c05e29bb0be6bc", "filename": "gcc/optabs.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -4152,6 +4152,7 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n   if (!SCALAR_FLOAT_MODE_P (mode))\n     {\n       rtx result;\n+      enum machine_mode ret_mode;\n \n       /* Handle a libcall just for the mode we are using.  */\n       libfunc = optab_libfunc (cmp_optab, mode);\n@@ -4166,9 +4167,9 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n \t    libfunc = ulibfunc;\n \t}\n \n+      ret_mode = targetm.libgcc_cmp_return_mode ();\n       result = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n-\t\t\t\t\ttargetm.libgcc_cmp_return_mode (),\n-\t\t\t\t\t2, x, mode, y, mode);\n+\t\t\t\t\tret_mode, 2, x, mode, y, mode);\n \n       /* There are two kinds of comparison routines. Biased routines\n \t return 0/1/2, and unbiased routines return -1/0/1. Other parts\n@@ -4186,7 +4187,7 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n       if (!TARGET_LIB_INT_CMP_BIASED && !ALL_FIXED_POINT_MODE_P (mode))\n \t{\n \t  if (unsignedp)\n-\t    x = plus_constant (result, 1);\n+\t    x = plus_constant (ret_mode, result, 1);\n \t  else\n \t    y = const0_rtx;\n \t}"}, {"sha": "c5725d2abdff41501cc0cec2fadb738f4483fb68", "filename": "gcc/recog.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1969,7 +1969,7 @@ offsettable_address_addr_space_p (int strictp, enum machine_mode mode, rtx y,\n       int good;\n \n       y1 = *y2;\n-      *y2 = plus_constant (*y2, mode_sz - 1);\n+      *y2 = plus_constant (GET_MODE (y), *y2, mode_sz - 1);\n       /* Use QImode because an odd displacement may be automatically invalid\n \t for any wider mode.  But it should be valid for a single byte.  */\n       good = (*addressp) (QImode, y, as);\n@@ -1991,9 +1991,10 @@ offsettable_address_addr_space_p (int strictp, enum machine_mode mode, rtx y,\n       && mode != BLKmode\n       && mode_sz <= GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT)\n     z = gen_rtx_LO_SUM (GET_MODE (y), XEXP (y, 0),\n-\t\t\tplus_constant (XEXP (y, 1), mode_sz - 1));\n+\t\t\tplus_constant (GET_MODE (y), XEXP (y, 1),\n+\t\t\t\t       mode_sz - 1));\n   else\n-    z = plus_constant (y, mode_sz - 1);\n+    z = plus_constant (GET_MODE (y), y, mode_sz - 1);\n \n   /* Use QImode because an odd displacement may be automatically invalid\n      for any wider mode.  But it should be valid for a single byte.  */"}, {"sha": "bcc7750af78ad676015795756722fd6180a6db2e", "filename": "gcc/reload.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -5196,7 +5196,8 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t  rtx offset_reg;\n \t  enum reg_class cls;\n \n-\t  offset_reg = plus_constant (operand, INTVAL (XEXP (ad, 1)));\n+\t  offset_reg = plus_constant (GET_MODE (ad), operand,\n+\t\t\t\t      INTVAL (XEXP (ad, 1)));\n \n \t  /* Form the adjusted address.  */\n \t  if (GET_CODE (XEXP (ad, 0)) == PLUS)\n@@ -5363,9 +5364,9 @@ form_sum (enum machine_mode mode, rtx x, rtx y)\n   gcc_assert (GET_MODE (y) == mode || GET_MODE (y) == VOIDmode);\n \n   if (CONST_INT_P (x))\n-    return plus_constant (y, INTVAL (x));\n+    return plus_constant (mode, y, INTVAL (x));\n   else if (CONST_INT_P (y))\n-    return plus_constant (x, INTVAL (y));\n+    return plus_constant (mode, x, INTVAL (y));\n   else if (CONSTANT_P (x))\n     tem = x, x = y, y = tem;\n \n@@ -6161,7 +6162,8 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n \t      else\n \t\toffset = SUBREG_BYTE (x);\n \n-\t      XEXP (tem, 0) = plus_constant (XEXP (tem, 0), offset);\n+\t      XEXP (tem, 0) = plus_constant (GET_MODE (XEXP (tem, 0)),\n+\t\t\t\t\t     XEXP (tem, 0), offset);\n \t      PUT_MODE (tem, GET_MODE (x));\n \t      if (MEM_OFFSET_KNOWN_P (tem))\n \t\tset_mem_offset (tem, MEM_OFFSET (tem) + offset);"}, {"sha": "c887614ce5b886898c72139baaec766df437ca8d", "filename": "gcc/reload1.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -462,7 +462,7 @@ init_reload (void)\n \t\t\t  gen_rtx_REG (Pmode, i));\n \n       /* This way, we make sure that reg+reg is an offsettable address.  */\n-      tem = plus_constant (tem, 4);\n+      tem = plus_constant (Pmode, tem, 4);\n \n       if (memory_address_p (QImode, tem))\n \t{\n@@ -2590,7 +2590,7 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS];\n \t       ep++)\n \t    if (ep->from_rtx == x && ep->can_eliminate)\n-\t      return plus_constant (ep->to_rtx, ep->previous_offset);\n+\t      return plus_constant (Pmode, ep->to_rtx, ep->previous_offset);\n \n \t}\n       else if (reg_renumber && reg_renumber[regno] < 0\n@@ -2646,7 +2646,7 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t\t  return ep->to_rtx;\n \t\telse\n \t\t  return gen_rtx_PLUS (Pmode, ep->to_rtx,\n-\t\t\t\t       plus_constant (XEXP (x, 1),\n+\t\t\t\t       plus_constant (Pmode, XEXP (x, 1),\n \t\t\t\t\t\t      ep->previous_offset));\n \t      }\n \n@@ -2723,7 +2723,8 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t\tep->ref_outside_mem = 1;\n \n \t      return\n-\t\tplus_constant (gen_rtx_MULT (Pmode, ep->to_rtx, XEXP (x, 1)),\n+\t\tplus_constant (Pmode,\n+\t\t\t       gen_rtx_MULT (Pmode, ep->to_rtx, XEXP (x, 1)),\n \t\t\t       ep->previous_offset * INTVAL (XEXP (x, 1)));\n \t    }\n \n@@ -3297,8 +3298,8 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \n \t\tif (base == ep->to_rtx)\n \t\t  {\n-\t\t    rtx src\n-\t\t      = plus_constant (ep->to_rtx, offset - ep->offset);\n+\t\t    rtx src = plus_constant (Pmode, ep->to_rtx,\n+\t\t\t\t\t     offset - ep->offset);\n \n \t\t    new_body = old_body;\n \t\t    if (! replace)\n@@ -3412,7 +3413,8 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t       had a PLUS before.  */\n \t    if (offset == 0 || plus_src)\n \t      {\n-\t\trtx new_src = plus_constant (to_rtx, offset);\n+\t\trtx new_src = plus_constant (GET_MODE (to_rtx),\n+\t\t\t\t\t     to_rtx, offset);\n \n \t\tnew_body = old_body;\n \t\tif (! replace)"}, {"sha": "8883b8a795b097e4702e7fb8e33b26b533a9cf9a", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -1643,8 +1643,7 @@ extern int ceil_log2 (unsigned HOST_WIDE_INT);\n \n /* In explow.c */\n extern HOST_WIDE_INT trunc_int_for_mode\t(HOST_WIDE_INT, enum machine_mode);\n-extern rtx plus_constant (rtx, HOST_WIDE_INT);\n-extern rtx plus_constant_mode (enum machine_mode, rtx, HOST_WIDE_INT);\n+extern rtx plus_constant (enum machine_mode, rtx, HOST_WIDE_INT);\n \n /* In rtl.c */\n extern rtx rtx_alloc_stat (RTX_CODE MEM_STAT_DECL);"}, {"sha": "6b0d56ed3ea480c2c8417b87adccb588426ddce3", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -613,7 +613,7 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \n       /* Similarly, (not (neg X)) is (plus X -1).  */\n       if (GET_CODE (op) == NEG)\n-\treturn plus_constant (XEXP (op, 0), -1);\n+\treturn plus_constant (mode, XEXP (op, 0), -1);\n \n       /* (not (xor X C)) for C constant is (xor X D) with D = ~C.  */\n       if (GET_CODE (op) == XOR\n@@ -713,7 +713,7 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \n       /* Similarly, (neg (not X)) is (plus X 1).  */\n       if (GET_CODE (op) == NOT)\n-\treturn plus_constant (XEXP (op, 0), 1);\n+\treturn plus_constant (mode, XEXP (op, 0), 1);\n \n       /* (neg (minus X Y)) can become (minus Y X).  This transformation\n \t isn't safe for modes with signed zeros, since if X and Y are\n@@ -782,7 +782,7 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n       if (GET_CODE (op) == XOR\n \t  && XEXP (op, 1) == const1_rtx\n \t  && nonzero_bits (XEXP (op, 0), mode) == 1)\n-\treturn plus_constant (XEXP (op, 0), -1);\n+\treturn plus_constant (mode, XEXP (op, 0), -1);\n \n       /* (neg (lt x 0)) is (ashiftrt X C) if STORE_FLAG_VALUE is 1.  */\n       /* (neg (lt x 0)) is (lshiftrt X C) if STORE_FLAG_VALUE is -1.  */\n@@ -1954,12 +1954,12 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t   || GET_CODE (op0) == SYMBOL_REF\n \t   || GET_CODE (op0) == LABEL_REF)\n \t  && CONST_INT_P (op1))\n-\treturn plus_constant (op0, INTVAL (op1));\n+\treturn plus_constant (mode, op0, INTVAL (op1));\n       else if ((GET_CODE (op1) == CONST\n \t\t|| GET_CODE (op1) == SYMBOL_REF\n \t\t|| GET_CODE (op1) == LABEL_REF)\n \t       && CONST_INT_P (op0))\n-\treturn plus_constant (op1, INTVAL (op0));\n+\treturn plus_constant (mode, op1, INTVAL (op0));\n \n       /* See if this is something like X * C - X or vice versa or\n \t if the multiplication is written as a shift.  If so, we can\n@@ -2557,7 +2557,8 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n           if (mask >> count == INTVAL (trueop1)\n               && (mask & nonzero_bits (XEXP (op0, 0), mode)) == 0)\n \t    return simplify_gen_binary (ASHIFTRT, mode,\n-\t\t\t\t\tplus_constant (XEXP (op0, 0), mask),\n+\t\t\t\t\tplus_constant (mode, XEXP (op0, 0),\n+\t\t\t\t\t\t       mask),\n \t\t\t\t\tXEXP (op0, 1));\n         }\n \n@@ -4118,7 +4119,8 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n       rtx value = ops[n_ops - 1].op;\n       if (ops[n_ops - 1].neg ^ ops[n_ops - 2].neg)\n \tvalue = neg_const_int (mode, value);\n-      ops[n_ops - 2].op = plus_constant (ops[n_ops - 2].op, INTVAL (value));\n+      ops[n_ops - 2].op = plus_constant (mode, ops[n_ops - 2].op,\n+\t\t\t\t\t INTVAL (value));\n       n_ops--;\n     }\n "}, {"sha": "da09e6bbf1753d75afce586b7122f0f46af3e867", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=0a81f074cf6c50c5eb026dfc95ec0d42e95f3da0", "patch": "@@ -811,7 +811,7 @@ static HOST_WIDE_INT cfa_base_offset;\n static inline rtx\n compute_cfa_pointer (HOST_WIDE_INT adjustment)\n {\n-  return plus_constant (cfa_base_rtx, adjustment + cfa_base_offset);\n+  return plus_constant (Pmode, cfa_base_rtx, adjustment + cfa_base_offset);\n }\n \n /* Adjustment for hard_frame_pointer_rtx to cfa base reg,\n@@ -5982,7 +5982,8 @@ prepare_call_arguments (basic_block bb, rtx insn)\n       HOST_WIDE_INT token\n \t= tree_low_cst (OBJ_TYPE_REF_TOKEN (obj_type_ref), 0);\n       if (token)\n-\tclobbered = plus_constant (clobbered, token * GET_MODE_SIZE (mode));\n+\tclobbered = plus_constant (mode, clobbered,\n+\t\t\t\t   token * GET_MODE_SIZE (mode));\n       clobbered = gen_rtx_MEM (mode, clobbered);\n       x = gen_rtx_CONCAT (mode, gen_rtx_CLOBBER (VOIDmode, pc_rtx), clobbered);\n       call_arguments\n@@ -9021,7 +9022,8 @@ vt_add_function_parameter (tree parm)\n \toff += INTVAL (XEXP (XEXP (incoming, 0), 1));\n       incoming\n \t= replace_equiv_address_nv (incoming,\n-\t\t\t\t    plus_constant (arg_pointer_rtx, off));\n+\t\t\t\t    plus_constant (Pmode,\n+\t\t\t\t\t\t   arg_pointer_rtx, off));\n     }\n \n #ifdef HAVE_window_save"}]}