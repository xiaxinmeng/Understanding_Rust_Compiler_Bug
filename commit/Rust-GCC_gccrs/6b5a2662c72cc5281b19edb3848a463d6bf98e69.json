{"sha": "6b5a2662c72cc5281b19edb3848a463d6bf98e69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI1YTI2NjJjNzJjYzUyODFiMTllZGIzODQ4YTQ2M2Q2YmY5OGU2OQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2003-10-21T18:01:37Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-10-21T18:01:37Z"}, "message": "mt_allocator.h: Change include to gthr.h.\n\n\n2003-10-21  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/ext/mt_allocator.h: Change include to gthr.h.\n\t* include/ext/rope: Same. Add _Refcount_base definitions.\n\t* include/ext/pool_allocator.h: Adjust namespaces.\n\t* include/bits/stl_threads.h (_Refcount_base): Move.\n\tPut remaining into namespace __gnu_cxx.\n\nFrom-SVN: r72763", "tree": {"sha": "02ee1c7444f261933ab9843f607822fa9240a95e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02ee1c7444f261933ab9843f607822fa9240a95e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b5a2662c72cc5281b19edb3848a463d6bf98e69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b5a2662c72cc5281b19edb3848a463d6bf98e69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b5a2662c72cc5281b19edb3848a463d6bf98e69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b5a2662c72cc5281b19edb3848a463d6bf98e69/comments", "author": null, "committer": null, "parents": [{"sha": "c3220510b4c97c080fbb640cb124efd2ecb36b59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3220510b4c97c080fbb640cb124efd2ecb36b59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3220510b4c97c080fbb640cb124efd2ecb36b59"}], "stats": {"total": 177, "additions": 80, "deletions": 97}, "files": [{"sha": "3ac3f04ce385e50585cc6375d280f95a39e44183", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5a2662c72cc5281b19edb3848a463d6bf98e69/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5a2662c72cc5281b19edb3848a463d6bf98e69/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=6b5a2662c72cc5281b19edb3848a463d6bf98e69", "patch": "@@ -1,3 +1,11 @@\n+2003-10-21  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/ext/mt_allocator.h: Change include to gthr.h.\n+\t* include/ext/rope: Same. Add _Refcount_base definitions.\n+\t* include/ext/pool_allocator.h: Adjust namespaces.\n+\t* include/bits/stl_threads.h (_Refcount_base): Move.\n+\tPut remaining into namespace __gnu_cxx.\n+\t\n 2003-10-21  Benjamin Kosnik  <bkoz@redhat.com>\n  \n \tPR libstdc++/9858"}, {"sha": "ffa21a49998313e45bb6a6b1d8c07df966e5c0ee", "filename": "libstdc++-v3/include/bits/stl_threads.h", "status": "modified", "additions": 19, "deletions": 88, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5a2662c72cc5281b19edb3848a463d6bf98e69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5a2662c72cc5281b19edb3848a463d6bf98e69/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h?ref=6b5a2662c72cc5281b19edb3848a463d6bf98e69", "patch": "@@ -50,56 +50,19 @@\n \n #include <cstddef>\n \n-// The only supported threading model is GCC's own gthr.h abstraction layer.\n+// The only supported threading model is GCC's own gthr.h abstraction\n+// layer.\n #include \"bits/gthr.h\"\n \n-namespace std\n+namespace __gnu_cxx\n {\n-  // Class _Refcount_Base provides a type, _RC_t, a data member,\n-  // _M_ref_count, and member functions _M_incr and _M_decr, which perform\n-  // atomic preincrement/predecrement.  The constructor initializes \n-  // _M_ref_count.\n-  struct _Refcount_Base\n-  {\n-    // The type _RC_t\n-    typedef size_t _RC_t;\n-    \n-    // The data member _M_ref_count\n-    volatile _RC_t _M_ref_count;\n-    \n-    // Constructor\n-    __gthread_mutex_t _M_ref_count_lock;\n-\n-    _Refcount_Base(_RC_t __n) : _M_ref_count(__n)\n-    {\n-#ifdef __GTHREAD_MUTEX_INIT\n-      __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;\n-      _M_ref_count_lock = __tmp;\n-#elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n-      __GTHREAD_MUTEX_INIT_FUNCTION (&_M_ref_count_lock);\n-#else\n-#error __GTHREAD_MUTEX_INIT or __GTHREAD_MUTEX_INIT_FUNCTION should be defined by gthr.h abstraction layer, report problem to libstdc++@gcc.gnu.org.\n+#if !defined(__GTHREAD_MUTEX_INIT) && defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n+  extern __gthread_mutex_t _GLIBCXX_mutex;\n+  extern __gthread_mutex_t *_GLIBCXX_mutex_address;\n+  extern __gthread_once_t _GLIBCXX_once;\n+  extern void _GLIBCXX_mutex_init(void);\n+  extern void _GLIBCXX_mutex_address_init(void);\n #endif\n-    }\n-\n-    void \n-    _M_incr() \n-    {\n-      __gthread_mutex_lock(&_M_ref_count_lock);\n-      ++_M_ref_count;\n-      __gthread_mutex_unlock(&_M_ref_count_lock);\n-    }\n-\n-    _RC_t \n-    _M_decr() \n-    {\n-      __gthread_mutex_lock(&_M_ref_count_lock);\n-      volatile _RC_t __tmp = --_M_ref_count;\n-      __gthread_mutex_unlock(&_M_ref_count_lock);\n-      return __tmp;\n-    }\n-  };\n-} //namespace std\n \n   // Locking class.  Note that this class *does not have a\n   // constructor*.  It must be initialized either statically, with\n@@ -113,20 +76,6 @@ namespace std\n   // 8.5.1 of the C++ standard) can be initialized that way.  That\n   // means we must have no constructors, no base classes, no virtual\n   // functions, and no private or protected members.\n-\n-#if !defined(__GTHREAD_MUTEX_INIT) && defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n-namespace __gnu_cxx\n-{\n-  extern __gthread_mutex_t _GLIBCXX_mutex;\n-  extern __gthread_mutex_t *_GLIBCXX_mutex_address;\n-  extern __gthread_once_t _GLIBCXX_once;\n-  extern void _GLIBCXX_mutex_init (void);\n-  extern void _GLIBCXX_mutex_address_init (void);\n-}\n-#endif\n-\n-namespace std\n-{\n   struct _STL_mutex_lock\n   {\n     // The class must be statically initialized with __STL_MUTEX_INITIALIZER.\n@@ -143,24 +92,24 @@ namespace std\n       // There should be no code in this path given the usage rules above.\n #elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n       if (_M_init_flag) return;\n-      if (__gthread_once (&__gnu_cxx::_GLIBCXX_once,\n-\t\t\t  __gnu_cxx::_GLIBCXX_mutex_init) != 0\n-\t  && __gthread_active_p ())\n+      if (__gthread_once(&__gnu_cxx::_GLIBCXX_once,\n+\t\t\t __gnu_cxx::_GLIBCXX_mutex_init) != 0\n+\t  && __gthread_active_p())\n \tabort ();\n-      __gthread_mutex_lock (&__gnu_cxx::_GLIBCXX_mutex);\n+      __gthread_mutex_lock(&__gnu_cxx::_GLIBCXX_mutex);\n       if (!_M_init_flag) \n \t{\n \t  // Even though we have a global lock, we use __gthread_once to be\n \t  // absolutely certain the _M_lock mutex is only initialized once on\n \t  // multiprocessor systems.\n \t  __gnu_cxx::_GLIBCXX_mutex_address = &_M_lock;\n-\t  if (__gthread_once (&_M_once,\n-\t\t\t      __gnu_cxx::_GLIBCXX_mutex_address_init) != 0\n-\t    && __gthread_active_p ())\n-\t    abort ();\n+\t  if (__gthread_once(&_M_once,\n+\t\t\t     __gnu_cxx::_GLIBCXX_mutex_address_init) != 0\n+\t    && __gthread_active_p())\n+\t    abort();\n \t  _M_init_flag = 1;\n \t}\n-      __gthread_mutex_unlock (&__gnu_cxx::_GLIBCXX_mutex);\n+      __gthread_mutex_unlock(&__gnu_cxx::_GLIBCXX_mutex);\n #endif\n     }\n \n@@ -193,24 +142,6 @@ namespace std\n #define __STL_MUTEX_INITIALIZER = { 0, __GTHREAD_ONCE_INIT }\n #endif\n #endif\n-\n-  // A locking class that uses _STL_mutex_lock.  The constructor takes a\n-  // reference to an _STL_mutex_lock, and acquires a lock.  The\n-  // destructor releases the lock.  It's not clear that this is exactly\n-  // the right functionality.  It will probably change in the future.\n-  struct _STL_auto_lock\n-  {\n-    _STL_mutex_lock& _M_lock;\n-    \n-    _STL_auto_lock(_STL_mutex_lock& __lock) : _M_lock(__lock)\n-    { _M_lock._M_acquire_lock(); }\n-\n-    ~_STL_auto_lock() { _M_lock._M_release_lock(); }\n-\n-  private:\n-    void operator=(const _STL_auto_lock&);\n-    _STL_auto_lock(const _STL_auto_lock&);\n-  } __attribute__ ((__unused__));\n-} // namespace std\n+} // namespace __gnu_cxx\n \n #endif "}, {"sha": "b1a88ec79bedb133371134d60e36f48ada74bed0", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5a2662c72cc5281b19edb3848a463d6bf98e69/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5a2662c72cc5281b19edb3848a463d6bf98e69/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=6b5a2662c72cc5281b19edb3848a463d6bf98e69", "patch": "@@ -37,7 +37,7 @@\n \n #include <cstdlib>\n #include <bits/functexcept.h> \n-#include <bits/stl_threads.h>\n+#include <bits/gthr.h>\n #include <bits/atomicity.h>\n #include <bits/allocator_traits.h>\n "}, {"sha": "cec7920483fb8722f91b2c3e03d12e0394e0d2c3", "filename": "libstdc++-v3/include/ext/pool_allocator.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5a2662c72cc5281b19edb3848a463d6bf98e69/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5a2662c72cc5281b19edb3848a463d6bf98e69/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h?ref=6b5a2662c72cc5281b19edb3848a463d6bf98e69", "patch": "@@ -56,7 +56,6 @@\n \n namespace __gnu_cxx\n {\n-  using std::_STL_mutex_lock;\n   using std::__throw_bad_alloc;\n \n   /**\n@@ -80,11 +79,12 @@ namespace __gnu_cxx\n    *  transfers its ownership to the second one.  This may have undesirable\n    *  effects on reference locality.\n    *\n-   *  The second parameter is unused and serves only to allow the creation of\n-   *  multiple default_alloc instances.  Note that containers built on different\n-   *  allocator instances have different types, limiting the utility of this\n-   *  approach.  If you do not wish to share the free lists with the main\n-   *  default_alloc instance, instantiate this with a non-zero __inst.\n+   *  The second parameter is unused and serves only to allow the\n+   *  creation of multiple default_alloc instances.  Note that\n+   *  containers built on different allocator instances have different\n+   *  types, limiting the utility of this approach.  If you do not\n+   *  wish to share the free lists with the main default_alloc\n+   *  instance, instantiate this with a non-zero __inst.\n    *\n    *  @endif\n    *  (See @link Allocators allocators info @endlink for more.)"}, {"sha": "c12eaa87393bb07bc8d8222fad83f0cb4a3d98c7", "filename": "libstdc++-v3/include/ext/rope", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5a2662c72cc5281b19edb3848a463d6bf98e69/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5a2662c72cc5281b19edb3848a463d6bf98e69/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope?ref=6b5a2662c72cc5281b19edb3848a463d6bf98e69", "patch": "@@ -61,7 +61,7 @@\n # ifdef __GC\n #   define __GC_CONST const\n # else\n-#   include <bits/stl_threads.h>\n+#   include <bits/gthr.h>\n #   define __GC_CONST   // constant except for deallocation\n # endif\n \n@@ -76,7 +76,6 @@ using std::iterator;\n using std::reverse_iterator;\n using std::_Alloc_traits;\n using std::_Destroy;\n-using std::_Refcount_Base;\n \n // The _S_eos function is used for those functions that\n // convert to/from C-like strings to detect the end of the string.\n@@ -346,6 +345,51 @@ identity_element(_Rope_Concat_fn<_CharT, _Alloc>)\n }\n \n \n+  // Class _Refcount_Base provides a type, _RC_t, a data member,\n+  // _M_ref_count, and member functions _M_incr and _M_decr, which perform\n+  // atomic preincrement/predecrement.  The constructor initializes \n+  // _M_ref_count.\n+  struct _Refcount_Base\n+  {\n+    // The type _RC_t\n+    typedef size_t _RC_t;\n+    \n+    // The data member _M_ref_count\n+    volatile _RC_t _M_ref_count;\n+    \n+    // Constructor\n+    __gthread_mutex_t _M_ref_count_lock;\n+\n+    _Refcount_Base(_RC_t __n) : _M_ref_count(__n)\n+    {\n+#ifdef __GTHREAD_MUTEX_INIT\n+      __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;\n+      _M_ref_count_lock = __tmp;\n+#elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n+      __GTHREAD_MUTEX_INIT_FUNCTION (&_M_ref_count_lock);\n+#else\n+#error __GTHREAD_MUTEX_INIT or __GTHREAD_MUTEX_INIT_FUNCTION should be defined by gthr.h abstraction layer, report problem to libstdc++@gcc.gnu.org.\n+#endif\n+    }\n+\n+    void \n+    _M_incr() \n+    {\n+      __gthread_mutex_lock(&_M_ref_count_lock);\n+      ++_M_ref_count;\n+      __gthread_mutex_unlock(&_M_ref_count_lock);\n+    }\n+\n+    _RC_t \n+    _M_decr() \n+    {\n+      __gthread_mutex_lock(&_M_ref_count_lock);\n+      volatile _RC_t __tmp = --_M_ref_count;\n+      __gthread_mutex_unlock(&_M_ref_count_lock);\n+      return __tmp;\n+    }\n+  };\n+\n //\n // What follows should really be local to rope.  Unfortunately,\n // that doesn't work, since it makes it impossible to define generic"}]}