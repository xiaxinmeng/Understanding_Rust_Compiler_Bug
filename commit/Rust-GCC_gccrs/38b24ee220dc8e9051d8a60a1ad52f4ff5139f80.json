{"sha": "38b24ee220dc8e9051d8a60a1ad52f4ff5139f80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhiMjRlZTIyMGRjOGU5MDUxZDhhNjBhMWFkNTJmNGZmNTEzOWY4MA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-03-08T20:37:23Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-03-08T20:37:23Z"}, "message": "cpplib.h (parse_underflow_t, [...]): Delete.\n\n\t* cpplib.h (parse_underflow_t, CPP_NULL_BUFFER): Delete.\n\t(struct cpp_buffer): Remove fname and underflow fields.\n\t(struct cpp_reader): Remove get_token field.\n\t(struct include_hash): Rename to struct ihash.  Add typedef to\n\tIHASH.\n\t(struct if_stack): Remove fname field.\n\t(IF_STACK_FRAME): Rename to IF_STACK.\n\n\t* cpperror.c (print_containing_files): Trust that there are no\n\tmacro buffers below the top file buffer.\n\t* cppfiles.c: Replace all references to 'struct include_hash'\n\twith 'IHASH'.  Rename initialize_input_buffer to\n\tinit_input_buffer.  Don't set or reference cpp_buffer->fname,\n\tuse buffer->ihash->name instead.\n\t* cpphash.c (special_symbol): Use cpp_file_buffer.  Use NULL\n\tnot CPP_NULL_BUFFER.\n\t* cppinit.c: Use NULL not CPP_NULL_BUFFER, IF_STACK not\n\tIF_STACK_FRAME, IHASH not struct include_hash.\n\t* cpplib.c: Rename eval_if_expression to eval_if_expr.  Remove\n\tnull_underflow.  Use IF_STACK not IF_STACK_FRAME, IHASH not\n\tstruct include_hash, NULL not CPP_NULL_BUFFER.  Remove all\n\treferences to cpp_buffer->fname (delete entirely, or use\n\t->ihash->name instead) and IF_STACK->fname.\n\t(cpp_push_buffer): Don't set new->underflow.\n\t(do_include): Use cpp_file_buffer.\n\n\t* cpphash.c (collect_formal_parameters): Remove duplicate\n\tincrement of argslen.  Pedwarn in C99 mode if __VA_ARGS__ is\n\tused as a macro argument name.  Don't append \"...\" to namebuf\n\tfor varargs macros.  After we're done scanning, go through\n\tnamebuf and make it NUL separated, not comma separated.\n\t(_cpp_compare_defs): Remove register tag from variables.\n\tExpect defn->argnames to be NUL separated.\n\t(_cpp_dump_definition): Expect defn->argnames to be NUL\n\tseparated and in forward order.\n\t* cpphash.h: Update documentation of argnames field.\n\nFrom-SVN: r32430", "tree": {"sha": "1653b79c8f978db12857348c7022fa5ac999b2f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1653b79c8f978db12857348c7022fa5ac999b2f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80/comments", "author": null, "committer": null, "parents": [{"sha": "dd05e4fae90b9f885f20217bd5b18ed13030314c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd05e4fae90b9f885f20217bd5b18ed13030314c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd05e4fae90b9f885f20217bd5b18ed13030314c"}], "stats": {"total": 400, "additions": 190, "deletions": 210}, "files": [{"sha": "be50eae86910d59611d3324692ff40a0565c2c10", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38b24ee220dc8e9051d8a60a1ad52f4ff5139f80", "patch": "@@ -1,3 +1,42 @@\n+2000-03-08  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpplib.h (parse_underflow_t, CPP_NULL_BUFFER): Delete.\n+\t(struct cpp_buffer): Remove fname and underflow fields.\n+\t(struct cpp_reader): Remove get_token field.\n+\t(struct include_hash): Rename to struct ihash.  Add typedef to\n+\tIHASH.\n+\t(struct if_stack): Remove fname field.\n+\t(IF_STACK_FRAME): Rename to IF_STACK.\n+\n+\t* cpperror.c (print_containing_files): Trust that there are no\n+\tmacro buffers below the top file buffer.\n+\t* cppfiles.c: Replace all references to 'struct include_hash'\n+\twith 'IHASH'.  Rename initialize_input_buffer to\n+\tinit_input_buffer.  Don't set or reference cpp_buffer->fname,\n+\tuse buffer->ihash->name instead.\n+\t* cpphash.c (special_symbol): Use cpp_file_buffer.  Use NULL\n+\tnot CPP_NULL_BUFFER.\n+\t* cppinit.c: Use NULL not CPP_NULL_BUFFER, IF_STACK not\n+\tIF_STACK_FRAME, IHASH not struct include_hash.\n+\t* cpplib.c: Rename eval_if_expression to eval_if_expr.  Remove\n+\tnull_underflow.  Use IF_STACK not IF_STACK_FRAME, IHASH not\n+\tstruct include_hash, NULL not CPP_NULL_BUFFER.  Remove all\n+\treferences to cpp_buffer->fname (delete entirely, or use\n+\t->ihash->name instead) and IF_STACK->fname.\n+\t(cpp_push_buffer): Don't set new->underflow.\n+\t(do_include): Use cpp_file_buffer.\n+\n+\t* cpphash.c (collect_formal_parameters): Remove duplicate\n+\tincrement of argslen.  Pedwarn in C99 mode if __VA_ARGS__ is\n+\tused as a macro argument name.  Don't append \"...\" to namebuf\n+\tfor varargs macros.  After we're done scanning, go through\n+\tnamebuf and make it NUL separated, not comma separated.\n+\t(_cpp_compare_defs): Remove register tag from variables.\n+\tExpect defn->argnames to be NUL separated.\n+\t(_cpp_dump_definition): Expect defn->argnames to be NUL\n+\tseparated and in forward order.\n+\t* cpphash.h: Update documentation of argnames field.\n+\n 2000-03-08  Richard Henderson  <rth@cygnus.com>\n \n \t* builtins.c (expand_builtin_strlen): Be prepared for strlensi"}, {"sha": "969907b537c3ffa6f7ac58164bb040cdc6216962", "filename": "gcc/cpperror.c", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=38b24ee220dc8e9051d8a60a1ad52f4ff5139f80", "patch": "@@ -50,34 +50,31 @@ print_containing_files (pfile, ip)\n     return;\n \n   /* Find the other, outer source files.  */\n-  for (ip = CPP_PREV_BUFFER (ip);\n-       ip != CPP_NULL_BUFFER (pfile);\n-       ip = CPP_PREV_BUFFER (ip))\n-    if (ip->fname != NULL)\n-      {\n-\tlong line;\n-\tcpp_buf_line_and_col (ip, &line, NULL);\n-\tif (first)\n-\t  {\n-\t    first = 0;\n-\t    fprintf (stderr,  _(\"In file included from %s:%ld\"),\n-\t\t     ip->nominal_fname, line);\n-\t  }\n-\telse\n-\t  /* Translators note: this message is used in conjunction\n-\t     with \"In file included from %s:%ld\" and some other\n-\t     tricks.  We want something like this:\n-\n-\t     In file included from sys/select.h:123,\n-\t                      from sys/types.h:234,\n-\t\t\t      from userfile.c:31:\n-\t     bits/select.h:45: <error message here>\n-\n-\t     The trailing comma is at the beginning of this message,\n-\t     and the trailing colon is not translated.  */\n-\t  fprintf (stderr, _(\",\\n                 from %s:%ld\"),\n+  for (ip = CPP_PREV_BUFFER (ip); ip != NULL; ip = CPP_PREV_BUFFER (ip))\n+    {\n+      long line;\n+      cpp_buf_line_and_col (ip, &line, NULL);\n+      if (first)\n+\t{\n+\t  first = 0;\n+\t  fprintf (stderr,  _(\"In file included from %s:%ld\"),\n \t\t   ip->nominal_fname, line);\n-      }\n+\t}\n+      else\n+\t/* Translators note: this message is used in conjunction\n+\t   with \"In file included from %s:%ld\" and some other\n+\t   tricks.  We want something like this:\n+\n+\t   In file included from sys/select.h:123,\n+\t                    from sys/types.h:234,\n+\t                    from userfile.c:31:\n+\t   bits/select.h:45: <error message here>\n+\n+\t   The trailing comma is at the beginning of this message,\n+\t   and the trailing colon is not translated.  */\n+\tfprintf (stderr, _(\",\\n                 from %s:%ld\"),\n+\t\t ip->nominal_fname, line);\n+    }\n   if (first == 0)\n     fputs (\":\\n\", stderr);\n "}, {"sha": "f4d2423b285f8f01c04d89dc5146eacbfc4fdbfd", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 34, "deletions": 39, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=38b24ee220dc8e9051d8a60a1ad52f4ff5139f80", "patch": "@@ -29,26 +29,21 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpplib.h\"\n #include \"intl.h\"\n \n-static struct include_hash *include_hash PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t  const char *, int));\n-static struct include_hash *redundant_include_p\n-\t\t\t\t\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t struct include_hash *,\n-\t\t\t\t\t\t struct file_name_list *));\n+static IHASH *include_hash\tPARAMS ((cpp_reader *, const char *, int));\n+static IHASH *redundant_include_p PARAMS ((cpp_reader *, IHASH *,\n+\t\t\t\t\t   struct file_name_list *));\n static struct file_name_map *read_name_map\n-\t\t\t\t\tPARAMS ((cpp_reader *, const char *));\n-static char *read_filename_string\tPARAMS ((int, FILE *));\n-static char *remap_filename \t\tPARAMS ((cpp_reader *, char *,\n-\t\t\t\t\t\t struct file_name_list *));\n-static long read_and_prescan\t\tPARAMS ((cpp_reader *, cpp_buffer *,\n-\t\t\t\t\t\t int, size_t));\n+\t\t\t\tPARAMS ((cpp_reader *, const char *));\n+static char *read_filename_string PARAMS ((int, FILE *));\n+static char *remap_filename \tPARAMS ((cpp_reader *, char *,\n+\t\t\t\t\t struct file_name_list *));\n+static long read_and_prescan\tPARAMS ((cpp_reader *, cpp_buffer *,\n+\t\t\t\t\t int, size_t));\n static struct file_name_list *actual_directory\n-\t\t\t\t\tPARAMS ((cpp_reader *, const char *));\n-static void initialize_input_buffer\tPARAMS ((cpp_reader *, int,\n-\t\t\t\t\t\t struct stat *));\n-static int file_cleanup\t\t\tPARAMS ((cpp_buffer *, cpp_reader *));\n-static U_CHAR *find_position\t\tPARAMS ((U_CHAR *, U_CHAR *,\n-\t\t\t\t\t\t unsigned long *));\n+\t\t\t\tPARAMS ((cpp_reader *, const char *));\n+static void init_input_buffer\tPARAMS ((cpp_reader *, int, struct stat *));\n+static int file_cleanup\t\tPARAMS ((cpp_buffer *, cpp_reader *));\n+static U_CHAR *find_position\tPARAMS ((U_CHAR *, U_CHAR *, unsigned long *));\n \n #if 0\n static void hack_vms_include_specification PARAMS ((char *));\n@@ -205,14 +200,14 @@ _cpp_merge_include_chains (opts)\n  #include name (there are at least three ways this can happen).  The\n  hash function could probably be improved a bit. */\n \n-static struct include_hash *\n+static IHASH *\n include_hash (pfile, fname, add)\n      cpp_reader *pfile;\n      const char *fname;\n      int add;\n {\n   unsigned int hash = 0;\n-  struct include_hash *l, *m;\n+  IHASH *l, *m;\n   const char *f = fname;\n \n   while (*f)\n@@ -227,7 +222,7 @@ include_hash (pfile, fname, add)\n   if (!add)\n     return 0;\n   \n-  l = (struct include_hash *) xmalloc (sizeof (struct include_hash));\n+  l = (IHASH *) xmalloc (sizeof (IHASH));\n   l->next = NULL;\n   l->next_this_file = NULL;\n   l->foundhere = NULL;\n@@ -263,14 +258,14 @@ include_hash (pfile, fname, add)\n    so the test below (i->foundhere == l) may be false even when\n    the directories are in fact the same.  */\n \n-static struct include_hash *\n+static IHASH *\n redundant_include_p (pfile, ihash, ilist)\n      cpp_reader *pfile;\n-     struct include_hash *ihash;\n+     IHASH *ihash;\n      struct file_name_list *ilist;\n {\n   struct file_name_list *l;\n-  struct include_hash *i;\n+  IHASH *i;\n \n   if (! ihash->foundhere)\n     return 0;\n@@ -285,7 +280,7 @@ redundant_include_p (pfile, ihash, ilist)\n \t return (i->control_macro\n \t\t && (i->control_macro[0] == '\\0'\n \t\t     || cpp_defined (pfile, i->control_macro, -1)))\n-\t     ? (struct include_hash *)-1 : i;\n+\t     ? (IHASH *)-1 : i;\n \n   return 0;\n }\n@@ -297,7 +292,7 @@ cpp_included (pfile, fname)\n      cpp_reader *pfile;\n      const char *fname;\n {\n-  struct include_hash *ptr;\n+  IHASH *ptr;\n \n   ptr = include_hash (pfile, fname, 0);\n   return (ptr != NULL);\n@@ -330,11 +325,11 @@ _cpp_find_include_file (pfile, fname, search_start, ihash, before)\n      cpp_reader *pfile;\n      const char *fname;\n      struct file_name_list *search_start;\n-     struct include_hash **ihash;\n+     IHASH **ihash;\n      int *before;\n {\n   struct file_name_list *l;\n-  struct include_hash *ih, *jh;\n+  IHASH *ih, *jh;\n   int f, len;\n   char *name;\n   \n@@ -347,7 +342,7 @@ _cpp_find_include_file (pfile, fname, search_start, ihash, before)\n       *before = 1;\n       *ihash = jh;\n \n-      if (jh == (struct include_hash *)-1)\n+      if (jh == (IHASH *)-1)\n \treturn -2;\n       else\n \treturn open (jh->name, O_RDONLY, 0666);\n@@ -358,7 +353,7 @@ _cpp_find_include_file (pfile, fname, search_start, ihash, before)\n        Allocate another include_hash block and add it to the next_this_file\n        chain. */\n     {\n-      jh = (struct include_hash *)xmalloc (sizeof (struct include_hash));\n+      jh = (IHASH *) xmalloc (sizeof (IHASH));\n       while (ih->next_this_file) ih = ih->next_this_file;\n \n       ih->next_this_file = jh;\n@@ -422,7 +417,7 @@ _cpp_find_include_file (pfile, fname, search_start, ihash, before)\n \tfree (ih);\n       }\n     free (name);\n-    *ihash = (struct include_hash *)-1;\n+    *ihash = (IHASH *)-1;\n     return -1;\n }\n \n@@ -627,7 +622,7 @@ cpp_read_file (pfile, fname)\n      cpp_reader *pfile;\n      const char *fname;\n {\n-  struct include_hash *ih_fake;\n+  IHASH *ih_fake;\n   int f;\n \n   if (fname == NULL || *fname == 0)\n@@ -655,7 +650,7 @@ cpp_read_file (pfile, fname)\n   /* Gin up an include_hash structure for this file and feed it\n      to finclude.  */\n \n-  ih_fake = (struct include_hash *) xmalloc (sizeof (struct include_hash));\n+  ih_fake = (IHASH *) xmalloc (sizeof (IHASH));\n   ih_fake->next = 0;\n   ih_fake->next_this_file = 0;\n   ih_fake->foundhere = ABSOLUTE_PATH;  /* well sort of ... */\n@@ -687,7 +682,7 @@ int\n _cpp_read_include_file (pfile, fd, ihash)\n      cpp_reader *pfile;\n      int fd;\n-     struct include_hash *ihash;\n+     IHASH *ihash;\n {\n   struct stat st;\n   size_t st_size;\n@@ -749,12 +744,12 @@ _cpp_read_include_file (pfile, fd, ihash)\n     }\n \n   if (pfile->input_buffer == NULL)\n-    initialize_input_buffer (pfile, fd, &st);\n+    init_input_buffer (pfile, fd, &st);\n \n   /* Read the file, converting end-of-line characters and trigraphs\n      (if enabled). */\n   fp->ihash = ihash;\n-  fp->nominal_fname = fp->fname = ihash->name;\n+  fp->nominal_fname = ihash->name;\n   length = read_and_prescan (pfile, fp, fd, st_size);\n   if (length < 0)\n     goto fail;\n@@ -774,7 +769,7 @@ _cpp_read_include_file (pfile, fd, ihash)\n   /* The ->actual_dir field is only used when ignore_srcdir is not in effect;\n      see do_include */\n   if (!CPP_OPTIONS (pfile)->ignore_srcdir)\n-    fp->actual_dir = actual_directory (pfile, fp->fname);\n+    fp->actual_dir = actual_directory (pfile, ihash->name);\n \n   pfile->input_stack_listing_current = 0;\n   return 1;\n@@ -1176,7 +1171,7 @@ read_and_prescan (pfile, fp, desc, len)\n   return -1;\n \n  error:\n-  cpp_error_from_errno (pfile, fp->fname);\n+  cpp_error_from_errno (pfile, fp->ihash->name);\n   free (buf);\n   return -1;\n }\n@@ -1187,7 +1182,7 @@ read_and_prescan (pfile, fp, desc, len)\n    the duration of the cpp run.  */\n \n static void\n-initialize_input_buffer (pfile, fd, st)\n+init_input_buffer (pfile, fd, st)\n      cpp_reader *pfile;\n      int fd;\n      struct stat *st;"}, {"sha": "fc4051b8d4c914e91109ba5c483bbc5ad8f303c1", "filename": "gcc/cpphash.c", "status": "modified", "additions": 40, "deletions": 44, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=38b24ee220dc8e9051d8a60a1ad52f4ff5139f80", "patch": "@@ -548,7 +548,7 @@ collect_formal_parameters (pfile)\n {\n   struct arglist *result = 0;\n   struct arg *argv = 0;\n-  U_CHAR *namebuf = xstrdup (\"\");\n+  U_CHAR *namebuf = (U_CHAR *) xstrdup (\"\");\n \n   U_CHAR *name, *tok;\n   size_t argslen = 1;\n@@ -587,6 +587,10 @@ collect_formal_parameters (pfile)\n \t      cpp_error (pfile, \"duplicate macro argument name `%s'\", tok);\n \t      continue;\n \t    }\n+\t  if (CPP_PEDANTIC (pfile) && CPP_OPTIONS (pfile)->c99\n+\t      && strncmp (tok, \"__VA_ARGS__\", sizeof \"__VA_ARGS__\" - 1))\n+\t    cpp_pedwarn (pfile,\n+\t\"C99 does not permit use of `__VA_ARGS__' as a macro argument name\");\n \t  namebuf = xrealloc (namebuf, argslen + len + 1);\n \t  name = &namebuf[argslen - 1];\n \t  argslen += len + 1;\n@@ -637,18 +641,13 @@ collect_formal_parameters (pfile)\n       name = &namebuf[argslen - 1];\n       argslen += len;\n       memcpy (name, \"__VA_ARGS__\", len);\n-\n-      argslen += len + 1;\n       argv[argc].len = len;\n     }\n   else\n     if (CPP_PEDANTIC (pfile))\n       cpp_pedwarn (pfile, \"ISO C does not permit named varargs macros\");\n \n   argv[argc].rest_arg = 1;\n-  namebuf = xrealloc (namebuf, argslen + 3);\n-  memcpy (&namebuf[argslen - 1], \"...\", 4);\n-  argslen += 3;\n   \n   token = get_directive_token (pfile);\n   if (token != CPP_RPAREN)\n@@ -664,6 +663,7 @@ collect_formal_parameters (pfile)\n     {\n       argv[i].name = namebuf + len;\n       len += argv[i].len + 1;\n+      namebuf[len - 1] = '\\0';\n     }\n \n   CPP_SET_WRITTEN (pfile, old_written);\n@@ -834,16 +834,10 @@ special_symbol (hp, pfile)\n     case T_FILE:\n     case T_BASE_FILE:\n       {\n-\tip = CPP_BUFFER (pfile);\n+\tip = cpp_file_buffer (pfile);\n \tif (hp->type == T_BASE_FILE)\n \t  {\n-\t    while (CPP_PREV_BUFFER (ip) != CPP_NULL_BUFFER (pfile))\n-\t      ip = CPP_PREV_BUFFER (ip);\n-\t  }\n-\telse\n-\t  {\n-\t    ip = CPP_BUFFER (pfile);\n-\t    while (!ip->nominal_fname && ip != CPP_NULL_BUFFER (pfile))\n+\t    while (CPP_PREV_BUFFER (ip) != NULL)\n \t      ip = CPP_PREV_BUFFER (ip);\n \t  }\n \n@@ -858,11 +852,10 @@ special_symbol (hp, pfile)\n \n     case T_INCLUDE_LEVEL:\n       {\n-\tint true_indepth = 0;\n-\tip = CPP_BUFFER (pfile);\n-\tfor (; ip != CPP_NULL_BUFFER (pfile); ip = CPP_PREV_BUFFER (ip))\n-\t  if (ip->fname != NULL)\n-\t    true_indepth++;\n+\tint true_indepth = 1;\n+\tip = cpp_file_buffer (pfile);\n+\twhile ((ip = CPP_PREV_BUFFER (ip)) != NULL)\n+\t  true_indepth++;\n \n \tCPP_RESERVE (pfile, 10);\n \tsprintf (CPP_PWRITTEN (pfile), \"%d\", true_indepth);\n@@ -895,9 +888,7 @@ special_symbol (hp, pfile)\n     case T_STDC:\n       CPP_RESERVE (pfile, 2);\n #ifdef STDC_0_IN_SYSTEM_HEADERS\n-      ip = CPP_BUFFER (pfile);\n-      while (!ip->nominal_fname && ip != CPP_NULL_BUFFER (pfile))\n-\tip = CPP_PREV_BUFFER (ip);\n+      ip = cpp_file_buffer (pfile);\n       if (ip->system_header_p\n \t  && !cpp_defined (pfile, (const U_CHAR *) \"__STRICT_ANSI__\", 15))\n \tCPP_PUTC_Q (pfile, '0');\n@@ -1488,17 +1479,29 @@ _cpp_compare_defs (pfile, d1, d2)\n      cpp_reader *pfile;\n      DEFINITION *d1, *d2;\n {\n-  register struct reflist *a1, *a2;\n-  register U_CHAR *p1 = d1->expansion;\n-  register U_CHAR *p2 = d2->expansion;\n+  struct reflist *a1, *a2;\n+  U_CHAR *p1 = d1->expansion;\n+  U_CHAR *p2 = d2->expansion;\n   int first = 1;\n \n   if (d1->nargs != d2->nargs)\n     return 1;\n   if (CPP_PEDANTIC (pfile)\n-      && d1->argnames && d2->argnames\n-      && strcmp ((char *) d1->argnames, (char *) d2->argnames))\n-    return 1;\n+      && d1->argnames && d2->argnames)\n+    {\n+      U_CHAR *arg1 = d1->argnames;\n+      U_CHAR *arg2 = d2->argnames;\n+      size_t len;\n+      int i = d1->nargs;\n+      while (i--)\n+\t{\n+\t  len = strlen (arg1);\n+\t  if (strcmp (arg1, arg2))\n+\t    return 1;\n+\t  arg1 += len;\n+\t  arg2 += len;\n+\t}\n+    }\n   for (a1 = d1->pattern, a2 = d2->pattern; a1 && a2;\n        a1 = a1->next, a2 = a2->next)\n     {\n@@ -1602,42 +1605,35 @@ _cpp_dump_definition (pfile, sym, len, defn)\n   else\n     {\n       struct reflist *r;\n-      unsigned char *argnames = (unsigned char *) xstrdup (defn->argnames);\n       unsigned char **argv = (unsigned char **) alloca (defn->nargs *\n \t\t\t\t\t\t\tsizeof(char *));\n       int *argl = (int *) alloca (defn->nargs * sizeof(int));\n       unsigned char *x;\n       int i;\n \n       /* First extract the argument list. */\n-      x = argnames;\n-      i = defn->nargs;\n-      while (i--)\n+      x = defn->argnames;\n+      for (i = 0; i < defn->nargs; i++)\n \t{\n \t  argv[i] = x;\n-\t  while (*x != ',' && *x != '\\0') x++;\n-\t  argl[i] = x - argv[i];\n-\t  if (*x == ',')\n-\t    {\n-\t      *x = '\\0';\n-\t      x += 2;  /* skip the space after the comma */\n-\t    }\n+\t  argl[i] = strlen (x);\n+\t  x += argl[i] + 1;\n \t}\n       \n       /* Now print out the argument list. */\n       CPP_PUTC_Q (pfile, '(');\n       for (i = 0; i < defn->nargs; i++)\n \t{\n \t  CPP_RESERVE (pfile, argl[i] + 2);\n-\t  CPP_PUTS_Q (pfile, argv[i], argl[i]);\n+\t  if (!(i == defn->nargs-1 && defn->rest_args\n+\t\t&& !strcmp (argv[i], \"__VA_ARGS__\")))\n+\t    CPP_PUTS_Q (pfile, argv[i], argl[i]);\n \t  if (i < defn->nargs-1)\n \t    CPP_PUTS_Q (pfile, \", \", 2);\n \t}\n-\n       if (defn->rest_args)\n-\tCPP_PUTS (pfile, \"...) \", 5);\n-      else\n-\tCPP_PUTS (pfile, \") \", 2);\n+\tCPP_PUTS (pfile, \"...\", 3);\n+      CPP_PUTS (pfile, \") \", 2);\n \n       /* Now the definition. */\n       x = defn->expansion;"}, {"sha": "814dccd98621b4b34f9aa05af4202b2f7ba10aa2", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=38b24ee220dc8e9051d8a60a1ad52f4ff5139f80", "patch": "@@ -64,7 +64,7 @@ struct definition\n   char rest_args;\t\t/* Nonzero if last arg. absorbs the rest */\n   struct reflist *pattern;\n \n-  /* Names of macro args, concatenated in order with commas between\n+  /* Names of macro args, concatenated in order with \\0 between\n      them.  The only use of this is that we warn on redefinition if\n      this differs between the old and new definitions.  */\n   U_CHAR *argnames;"}, {"sha": "74ddd5b4dbcdc01c0938efc58958082a16d82d1b", "filename": "gcc/cppinit.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=38b24ee220dc8e9051d8a60a1ad52f4ff5139f80", "patch": "@@ -398,7 +398,7 @@ cpp_cleanup (pfile)\n      cpp_reader *pfile;\n {\n   int i;\n-  while (CPP_BUFFER (pfile) != CPP_NULL_BUFFER (pfile))\n+  while (CPP_BUFFER (pfile) != NULL)\n     cpp_pop_buffer (pfile);\n \n   if (pfile->token_buffer)\n@@ -420,22 +420,20 @@ cpp_cleanup (pfile)\n \n   while (pfile->if_stack)\n     {\n-      IF_STACK_FRAME *temp = pfile->if_stack;\n+      IF_STACK *temp = pfile->if_stack;\n       pfile->if_stack = temp->next;\n       free (temp);\n     }\n \n   for (i = ALL_INCLUDE_HASHSIZE; --i >= 0; )\n     {\n-      struct include_hash *imp = pfile->all_include_files[i];\n-      while (imp)\n+      IHASH *imp, *next;\n+      for (imp = pfile->all_include_files[i]; imp; imp = next)\n \t{\n-\t  struct include_hash *next = imp->next;\n-\n+\t  next = imp->next;\n \t  free ((PTR) imp->name);\n \t  free ((PTR) imp->nshort);\n \t  free (imp);\n-\t  imp = next;\n \t}\n       pfile->all_include_files[i] = 0;\n     }\n@@ -846,7 +844,7 @@ cpp_finish (pfile)\n {\n   struct cpp_options *opts = CPP_OPTIONS (pfile);\n \n-  if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)) != CPP_NULL_BUFFER (pfile))\n+  if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)) != NULL)\n     cpp_ice (pfile, \"buffers still stacked in cpp_finish\");\n   cpp_pop_buffer (pfile);\n "}, {"sha": "4f00f401ef8667d7bca8b99062a255ca7c102642", "filename": "gcc/cpplib.c", "status": "modified", "additions": 31, "deletions": 66, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=38b24ee220dc8e9051d8a60a1ad52f4ff5139f80", "patch": "@@ -78,7 +78,7 @@ static int do_warning PARAMS ((cpp_reader *, const struct directive *));\n /* Forward declarations.  */\n \n static void validate_else\t\tPARAMS ((cpp_reader *, const char *));\n-static HOST_WIDEST_INT eval_if_expression PARAMS ((cpp_reader *));\n+static HOST_WIDEST_INT eval_if_expr\tPARAMS ((cpp_reader *));\n static void conditional_skip\t\tPARAMS ((cpp_reader *, int,\n \t\t\t\t\t\tenum node_type, U_CHAR *));\n static void skip_if_group\t\tPARAMS ((cpp_reader *));\n@@ -87,7 +87,6 @@ static void parse_string\t\tPARAMS ((cpp_reader *, int));\n static int parse_assertion\t\tPARAMS ((cpp_reader *));\n static const char *if_directive_name\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t struct if_stack *));\n-static enum cpp_token null_underflow\tPARAMS ((cpp_reader *));\n static int null_cleanup\t\t\tPARAMS ((cpp_buffer *, cpp_reader *));\n static int skip_comment\t\t\tPARAMS ((cpp_reader *, int));\n static int copy_comment\t\t\tPARAMS ((cpp_reader *, int));\n@@ -100,8 +99,8 @@ static void pass_thru_directive\t\tPARAMS ((const U_CHAR *, size_t,\n \t\t\t\t\t\t const struct directive *));\n static int read_line_number\t\tPARAMS ((cpp_reader *, int *));\n static U_CHAR *detect_if_not_defined\tPARAMS ((cpp_reader *));\n-static int consider_directive_while_skipping PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t      IF_STACK_FRAME *));\n+static int consider_directive_while_skipping\n+\t\t\t\t\tPARAMS ((cpp_reader *, IF_STACK *));\n static void skip_block_comment\t\tPARAMS ((cpp_reader *));\n static void skip_line_comment\t\tPARAMS ((cpp_reader *));\n static void parse_set_mark\t\tPARAMS ((cpp_reader *));\n@@ -264,13 +263,6 @@ cpp_defined (pfile, id, len)\n   return (hp != NULL);\n }\n \n-static enum cpp_token\n-null_underflow (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  return CPP_EOF;\n-}\n-\n static int\n null_cleanup (pbuf, pfile)\n      cpp_buffer *pbuf ATTRIBUTE_UNUSED;\n@@ -758,7 +750,6 @@ cpp_push_buffer (pfile, buffer, length)\n \n   new->if_stack = pfile->if_stack;\n   new->cleanup = null_cleanup;\n-  new->underflow = null_underflow;\n   new->buf = new->cur = buffer;\n   new->alimit = new->rlimit = buffer + length;\n   new->prev = buf;\n@@ -805,8 +796,7 @@ cpp_scan_buffer (pfile)\n \t    break;\n \t  if (token == CPP_POP && CPP_BUFFER (pfile) == buffer)\n \t    {\n-\t      if (CPP_PREV_BUFFER (CPP_BUFFER (pfile))\n-\t\t  != CPP_NULL_BUFFER (pfile))\n+\t      if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)) != NULL)\n \t\tcpp_pop_buffer (pfile);\n \t      break;\n \t    }\n@@ -822,8 +812,7 @@ cpp_scan_buffer (pfile)\n \t    break;\n \t  if (token == CPP_POP && CPP_BUFFER (pfile) == buffer)\n \t    {\n-\t      if (CPP_PREV_BUFFER (CPP_BUFFER (pfile))\n-\t\t  != CPP_NULL_BUFFER (pfile))\n+\t      if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)) != NULL)\n \t\tcpp_pop_buffer (pfile);\n \t      break;\n \t    }\n@@ -903,10 +892,10 @@ cpp_buffer *\n cpp_file_buffer (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *ip = CPP_BUFFER (pfile);\n+  cpp_buffer *ip;\n \n-  for ( ; ip != CPP_NULL_BUFFER (pfile); ip = CPP_PREV_BUFFER (ip))\n-    if (ip->fname != NULL)\n+  for (ip = CPP_BUFFER (pfile); ip; ip = CPP_PREV_BUFFER (ip))\n+    if (ip->ihash != NULL)\n       return ip;\n   return NULL;\n }\n@@ -1058,7 +1047,7 @@ do_include (pfile, keyword)\n   enum cpp_token token;\n \n   /* Chain of dirs to search */\n-  struct include_hash *ihash;\n+  IHASH *ihash;\n   struct file_name_list *search_start;\n   \n   long old_written = CPP_WRITTEN (pfile);\n@@ -1151,23 +1140,13 @@ do_include (pfile, keyword)\n \n   search_start = 0;\n \n-  for (fp = CPP_BUFFER (pfile);\n-       fp != CPP_NULL_BUFFER (pfile);\n-       fp = CPP_PREV_BUFFER (fp))\n-    if (fp->fname != NULL)\n-      break;\n+  fp = cpp_file_buffer (pfile);\n \n-  if (fp == CPP_NULL_BUFFER (pfile))\n-    {\n-      cpp_ice (pfile, \"fp == NULL_BUFFER in do_include\");\n-      return 0;\n-    }\n-  \n   /* For #include_next, skip in the search path past the dir in which the\n      containing file was found.  Treat files specified using an absolute path\n      as if there are no more directories to search.  Treat the primary source\n      file like any other included source, but generate a warning.  */\n-  if (skip_dirs && CPP_PREV_BUFFER(fp) != CPP_NULL_BUFFER (pfile))\n+  if (skip_dirs && CPP_PREV_BUFFER (fp))\n     {\n       if (fp->ihash->foundhere != ABSOLUTE_PATH)\n \tsearch_start = fp->ihash->foundhere->next;\n@@ -1257,7 +1236,7 @@ do_include (pfile, keyword)\n   if (CPP_OPTIONS(pfile)->print_include_names)\n     {\n       fp = CPP_BUFFER (pfile);\n-      while ((fp = CPP_PREV_BUFFER (fp)) != CPP_NULL_BUFFER (pfile))\n+      while ((fp = CPP_PREV_BUFFER (fp)) != NULL)\n \tputc ('.', stderr);\n       fprintf (stderr, \" %s\\n\", ihash->name);\n     }\n@@ -1390,8 +1369,8 @@ do_line (pfile, keyword)\n       if (strcmp (fname, ip->nominal_fname))\n \t{\n \t  const char *newname, *oldname;\n-\t  if (!strcmp (fname, ip->fname))\n-\t    newname = ip->fname;\n+\t  if (!strcmp (fname, ip->ihash->name))\n+\t    newname = ip->ihash->name;\n \t  else if (ip->last_nominal_fname\n \t\t   && !strcmp (fname, ip->last_nominal_fname))\n \t    newname = ip->last_nominal_fname;\n@@ -1404,10 +1383,10 @@ do_line (pfile, keyword)\n \t  if (ip->last_nominal_fname\n \t      && ip->last_nominal_fname != oldname\n \t      && ip->last_nominal_fname != newname\n-\t      && ip->last_nominal_fname != ip->fname)\n+\t      && ip->last_nominal_fname != ip->ihash->name)\n \t    free ((void *) ip->last_nominal_fname);\n \n-\t  if (newname == ip->fname)\n+\t  if (newname == ip->ihash->name)\n \t    ip->last_nominal_fname = NULL;\n \t  else\n \t    ip->last_nominal_fname = oldname;\n@@ -1676,18 +1655,12 @@ do_pragma_once (pfile)\n {\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n \n-  if (ip->fname == NULL)\n-    {\n-      cpp_ice (pfile, \"ip->fname == NULL in do_pragma_once\");\n-      return 1;\n-    }\n-  \n   /* Allow #pragma once in system headers, since that's not the user's\n      fault.  */\n   if (!ip->system_header_p)\n     cpp_warning (pfile, \"`#pragma once' is obsolete\");\n       \n-  if (CPP_PREV_BUFFER (ip) == CPP_NULL_BUFFER (pfile))\n+  if (CPP_PREV_BUFFER (ip) == NULL)\n     cpp_warning (pfile, \"`#pragma once' outside include file\");\n   else\n     ip->ihash->control_macro = \"\";  /* never repeat */\n@@ -1887,7 +1860,7 @@ do_if (pfile, keyword)\n      const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   U_CHAR *control_macro = detect_if_not_defined (pfile);\n-  HOST_WIDEST_INT value = eval_if_expression (pfile);\n+  HOST_WIDEST_INT value = eval_if_expr (pfile);\n   conditional_skip (pfile, value == 0, T_IF, control_macro);\n   return 0;\n }\n@@ -1922,7 +1895,7 @@ do_elif (pfile, keyword)\n     skip_if_group (pfile);\n   else\n     {\n-      HOST_WIDEST_INT value = eval_if_expression (pfile);\n+      HOST_WIDEST_INT value = eval_if_expr (pfile);\n       if (value == 0)\n \tskip_if_group (pfile);\n       else\n@@ -1940,7 +1913,7 @@ do_elif (pfile, keyword)\n  */\n \n static HOST_WIDEST_INT\n-eval_if_expression (pfile)\n+eval_if_expr (pfile)\n      cpp_reader *pfile;\n {\n   HOST_WIDEST_INT value;\n@@ -1968,7 +1941,6 @@ do_xifdef (pfile, keyword)\n      const struct directive *keyword;\n {\n   int skip;\n-  cpp_buffer *ip = CPP_BUFFER (pfile);\n   U_CHAR *ident;\n   int ident_length;\n   enum cpp_token token;\n@@ -1977,7 +1949,7 @@ do_xifdef (pfile, keyword)\n   int old_written = CPP_WRITTEN (pfile);\n \n   /* Detect a #ifndef at start of file (not counting comments).  */\n-  if (ip->fname != 0 && keyword->type == T_IFNDEF)\n+  if (keyword->type == T_IFNDEF)\n     start_of_file = pfile->only_seen_white == 2;\n \n   pfile->no_macro_expand++;\n@@ -2038,10 +2010,9 @@ conditional_skip (pfile, skip, type, control_macro)\n      enum node_type type;\n      U_CHAR *control_macro;\n {\n-  IF_STACK_FRAME *temp;\n+  IF_STACK *temp;\n \n-  temp = (IF_STACK_FRAME *) xcalloc (1, sizeof (IF_STACK_FRAME));\n-  temp->fname = CPP_BUFFER (pfile)->nominal_fname;\n+  temp = (IF_STACK *) xcalloc (1, sizeof (IF_STACK));\n   temp->lineno = CPP_BUFFER (pfile)->lineno;\n   temp->next = pfile->if_stack;\n   temp->control_macro = control_macro;\n@@ -2066,11 +2037,11 @@ conditional_skip (pfile, skip, type, control_macro)\n static int\n consider_directive_while_skipping (pfile, stack)\n     cpp_reader *pfile;\n-    IF_STACK_FRAME *stack; \n+    IF_STACK *stack; \n {\n   long ident_len, ident;\n   const struct directive *kt;\n-  IF_STACK_FRAME *temp;\n+  IF_STACK *temp;\n     \n   cpp_skip_hspace (pfile);\n \n@@ -2088,10 +2059,9 @@ consider_directive_while_skipping (pfile, stack)\n \tcase T_IF:\n \tcase T_IFDEF:\n \tcase T_IFNDEF:\n-\t    temp = (IF_STACK_FRAME *) xmalloc (sizeof (IF_STACK_FRAME));\n+\t    temp = (IF_STACK *) xmalloc (sizeof (IF_STACK));\n \t    temp->next = pfile->if_stack;\n \t    pfile->if_stack = temp;\n-\t    temp->fname = CPP_BUFFER(pfile)->nominal_fname;\n \t    temp->type = kt->type;\n \t    return 0;\n \n@@ -2138,7 +2108,7 @@ skip_if_group (pfile)\n     cpp_reader *pfile;\n {\n   int c;\n-  IF_STACK_FRAME *save_if_stack = pfile->if_stack; /* don't pop past here */\n+  IF_STACK *save_if_stack = pfile->if_stack; /* don't pop past here */\n   U_CHAR *beg_of_line;\n   long old_written;\n \n@@ -2241,7 +2211,7 @@ do_endif (pfile, keyword)\n     cpp_error (pfile, \"`#endif' not within a conditional\");\n   else\n     {\n-      IF_STACK_FRAME *temp = pfile->if_stack;\n+      IF_STACK *temp = pfile->if_stack;\n       pfile->if_stack = temp->next;\n       if (temp->control_macro != 0)\n \t{\n@@ -2266,11 +2236,7 @@ do_endif (pfile, keyword)\n \t\t that contains all of the file (aside from whitespace).\n \t\t Arrange not to include the file again\n \t\t if the macro that was tested is defined. */\n-\t      struct cpp_buffer *ip;\n-\t      for (ip = CPP_BUFFER (pfile); ; ip = CPP_PREV_BUFFER (ip))\n-\t\tif (ip->fname != NULL)\n-\t\t  break;\n-\t      ip->ihash->control_macro = temp->control_macro;\n+\t      CPP_BUFFER (pfile)->ihash->control_macro = temp->control_macro;\n \t    }\n         }\n       free (temp);\n@@ -2337,7 +2303,7 @@ cpp_get_token (pfile)\n \treturn CPP_EOF;\n       else if (CPP_BUFFER (pfile)->seen_eof)\n \t{\n-\t  if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)) == CPP_NULL_BUFFER (pfile))\n+\t  if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)) == NULL)\n \t    return CPP_EOF;\n \n \t  cpp_pop_buffer (pfile);\n@@ -2362,8 +2328,7 @@ cpp_get_token (pfile)\n \t    }\n \t  pfile->if_stack = ifs;\n \n-\t  if (CPP_BUFFER (pfile)->nominal_fname\n-\t      && next_buf != CPP_NULL_BUFFER (pfile))\n+\t  if (CPP_BUFFER (pfile)->nominal_fname && next_buf != NULL)\n \t    {\n \t      /* We're about to return from an #include file.\n \t\t Emit #line information now (as part of the CPP_POP) result."}, {"sha": "a0544808d7d74a4c8c47477f768a9c683e675081", "filename": "gcc/cpplib.h", "status": "modified", "additions": 15, "deletions": 25, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b24ee220dc8e9051d8a60a1ad52f4ff5139f80/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=38b24ee220dc8e9051d8a60a1ad52f4ff5139f80", "patch": "@@ -61,7 +61,6 @@ enum cpp_token\n   CPP_POP\t\t/* We're about to pop the buffer stack.  */\n };\n \n-typedef enum cpp_token (*parse_underflow_t) PARAMS((cpp_reader *));\n typedef int (*parse_cleanup_t) PARAMS((cpp_buffer *, cpp_reader *));\n \n extern int cpp_handle_options PARAMS ((cpp_reader *, int, char **));\n@@ -82,8 +81,6 @@ struct cpp_buffer\n \n   struct cpp_buffer *prev;\n \n-  /* Real filename.  (Alias to ->ihash->fname, obsolete). */\n-  const char *fname;\n   /* Filename specified with #line command.  */\n   const char *nominal_fname;\n   /* Last filename specified with #line command.  */\n@@ -93,12 +90,11 @@ struct cpp_buffer\n \n   /* Pointer into the include hash table.  Used for include_next and\n      to record control macros. */\n-  struct include_hash *ihash;\n+  struct ihash *ihash;\n \n   long lineno; /* Line number at CPP_LINE_BASE. */\n   long colno; /* Column number at CPP_LINE_BASE. */\n   long mark;  /* Saved position for lengthy backtrack. */\n-  parse_underflow_t underflow;\n   parse_cleanup_t cleanup;\n   void *data;\n \n@@ -146,7 +142,6 @@ struct file_name_map_list;\n \n struct cpp_reader\n {\n-  parse_underflow_t get_token;\n   cpp_buffer *buffer;\n   cpp_options *opts;\n \n@@ -175,7 +170,7 @@ struct cpp_reader\n \n   /* Hash table of other included files.  See cppfiles.c */\n #define ALL_INCLUDE_HASHSIZE 71\n-  struct include_hash *all_include_files[ALL_INCLUDE_HASHSIZE];\n+  struct ihash *all_include_files[ALL_INCLUDE_HASHSIZE];\n \n   /* Chain of `actual directory' file_name_list entries,\n      for \"\" inclusion. */\n@@ -284,8 +279,6 @@ struct cpp_reader\n #define CPP_OPTIONS(PFILE) ((PFILE)->opts)\n #define CPP_BUFFER(PFILE) ((PFILE)->buffer)\n #define CPP_PREV_BUFFER(BUFFER) ((BUFFER)->prev)\n-/* The bottom of the buffer stack. */\n-#define CPP_NULL_BUFFER(PFILE) NULL\n \n /* The `pending' structure accumulates all the options that are not\n    actually processed until we hit cpp_start_read.  It consists of\n@@ -528,12 +521,12 @@ struct file_name_list\n /* This structure is used for the table of all includes.  It is\n    indexed by the `short name' (the name as it appeared in the\n    #include statement) which is stored in *nshort.  */\n-struct include_hash\n+struct ihash\n {\n-  struct include_hash *next;\n+  struct ihash *next;\n   /* Next file with the same short name but a\n      different (partial) pathname). */\n-  struct include_hash *next_this_file;\n+  struct ihash *next_this_file;\n \n   /* Location of the file in the include search path.\n      Used for include_next */\n@@ -545,6 +538,7 @@ struct include_hash\n   char *buf, *limit;\t\t/* for file content cache,\n \t\t\t\t   not yet implemented */\n };\n+typedef struct ihash IHASH;\n \n /* Name under which this program was invoked.  */\n \n@@ -623,17 +617,15 @@ extern unsigned char _cpp_IStable[256];\n /* Stack of conditionals currently in progress\n    (including both successful and failing conditionals).  */\n \n-struct if_stack {\n-  struct if_stack *next;\t/* for chaining to the next stack frame */\n-  const char *fname;\t\t/* copied from input when frame is made */\n-  int lineno;\t\t\t/* similarly */\n-  int if_succeeded;\t\t/* true if a leg of this if-group\n-\t\t\t\t    has been passed through rescan */\n-  U_CHAR *control_macro;\t/* For #ifndef at start of file,\n-\t\t\t\t   this is the macro name tested.  */\n+struct if_stack\n+{\n+  struct if_stack *next;\n+  int lineno;\t\t\t/* line number where condition started */\n+  int if_succeeded;\t\t/* truth of last condition in this group */\n+  const U_CHAR *control_macro;\t/* macro name for #ifndef around entire file */\n   enum node_type type;\t\t/* type of last directive seen in this group */\n };\n-typedef struct if_stack IF_STACK_FRAME;\n+typedef struct if_stack IF_STACK;\n \n extern void cpp_buf_line_and_col PARAMS((cpp_buffer *, long *, long *));\n extern cpp_buffer *cpp_file_buffer PARAMS((cpp_reader *));\n@@ -700,10 +692,8 @@ extern void _cpp_simplify_pathname\tPARAMS ((char *));\n extern void _cpp_merge_include_chains\tPARAMS ((struct cpp_options *));\n extern int _cpp_find_include_file\tPARAMS ((cpp_reader *, const char *,\n \t\t\t\t\t\tstruct file_name_list *,\n-\t\t\t\t\t\tstruct include_hash **,\n-\t\t\t\t\t\tint *));\n-extern int _cpp_read_include_file\tPARAMS ((cpp_reader *, int,\n-\t\t\t\t\t        struct include_hash *));\n+\t\t\t\t\t\tIHASH **, int *));\n+extern int _cpp_read_include_file\tPARAMS ((cpp_reader *, int, IHASH *));\n \n /* In cppexp.c */\n extern HOST_WIDEST_INT _cpp_parse_expr\tPARAMS ((cpp_reader *));"}]}