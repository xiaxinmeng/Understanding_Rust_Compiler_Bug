{"sha": "cfaab3a92418d34e14bb0fa447c052fce9f6057b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZhYWIzYTkyNDE4ZDM0ZTE0YmIwZmE0NDdjMDUyZmNlOWY2MDU3Yg==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2006-12-11T20:15:53Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2006-12-11T20:15:53Z"}, "message": "tree-ssa-operands.h (create_ssa_artificial_load_stmt): Rename from create_ssa_artficial_load_stmt.\n\n\n\t* tree-ssa-operands.h (create_ssa_artificial_load_stmt):\n\tRename from create_ssa_artficial_load_stmt.  Update all users.\n\t* tree-into-ssa.c (register_new_def): Make static.\n\t* tree.c (is_global_var): Handle SSA_NAMEs.\n\t* tree.h (SSA_NAME_IS_DEFAULT_DEF): Define.  Update all users\n\tthat used to call gimple_default_def.\n\t* tree-ssa-operands.c (push_stmt_changes): New.\n\t(pop_stmt_changes): New.  Update every pass that modifies\n\tstatements to bracket modifications with\n\tpush_stmt_changes/pop_stmt_changes.\n\t(discard_stmt_changes): New.\n\t* tree-ssa-dom.c (stmts_to_rescan): Change to stack of\n\t'tree *' instead of 'tree'.  Update all users.\n\t* tree-flow-inline.h (zero_imm_uses_p): New.\n\t(symbol_mem_tag): New.  Update every function that used\n\tto access the annotation directly.\n\t(set_symbol_mem_tag): Likewise.\n\t* tree-dfa.c (dump_variable): Always show the escape mask.\n\t(mark_symbols_for_renaming): Rename from\n\tmark_new_vars_to_rename.  Update all users.\n\tOnly mark to rename naked symbols in real and virtual\n\toperands.\n\nFrom-SVN: r119746", "tree": {"sha": "79969bcc52ffc34edcced0521bbe67cd20e564f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79969bcc52ffc34edcced0521bbe67cd20e564f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfaab3a92418d34e14bb0fa447c052fce9f6057b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfaab3a92418d34e14bb0fa447c052fce9f6057b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfaab3a92418d34e14bb0fa447c052fce9f6057b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfaab3a92418d34e14bb0fa447c052fce9f6057b/comments", "author": null, "committer": null, "parents": [{"sha": "7f46c638e6be449fcd80c08babdfaee63b70278e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f46c638e6be449fcd80c08babdfaee63b70278e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f46c638e6be449fcd80c08babdfaee63b70278e"}], "stats": {"total": 668, "additions": 498, "deletions": 170}, "files": [{"sha": "f01ef1077879acb337442bccf348d1cf3ee57811", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -1,3 +1,28 @@\n+2006-12-11  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-ssa-operands.h (create_ssa_artificial_load_stmt):\n+\tRename from create_ssa_artficial_load_stmt.  Update all users.\n+\t* tree-into-ssa.c (register_new_def): Make static.\n+\t* tree.c (is_global_var): Handle SSA_NAMEs.\n+\t* tree.h (SSA_NAME_IS_DEFAULT_DEF): Define.  Update all users\n+\tthat used to call gimple_default_def.\n+\t* tree-ssa-operands.c (push_stmt_changes): New.\n+\t(pop_stmt_changes): New.  Update every pass that modifies\n+\tstatements to bracket modifications with\n+\tpush_stmt_changes/pop_stmt_changes.\n+\t(discard_stmt_changes): New.\n+\t* tree-ssa-dom.c (stmts_to_rescan): Change to stack of\n+\t'tree *' instead of 'tree'.  Update all users.\n+\t* tree-flow-inline.h (zero_imm_uses_p): New.\n+\t(symbol_mem_tag): New.  Update every function that used\n+\tto access the annotation directly.\n+\t(set_symbol_mem_tag): Likewise.\n+\t* tree-dfa.c (dump_variable): Always show the escape mask.\n+\t(mark_symbols_for_renaming): Rename from\n+\tmark_new_vars_to_rename.  Update all users.\n+\tOnly mark to rename naked symbols in real and virtual\n+\toperands.\n+\n 2006-12-11  Andreas Schwab  <schwab@suse.de>\n \n \t* varasm.c (elf_record_gcc_switches): Cast second argument of"}, {"sha": "8bacb08d511777a47c40b78fc1848565308f2b33", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -885,6 +885,7 @@ execute_one_pass (struct tree_opt_pass *pass)\n       free ((char *) dump_file_name);\n       dump_file_name = NULL;\n     }\n+\n   if (dump_file)\n     {\n       dump_end (pass->static_pass_number, dump_file);"}, {"sha": "48893d4f214bb3ef7126583b43d604ccf9637480", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -1248,6 +1248,9 @@ replace_uses_by (tree name, tree val)\n \n   FOR_EACH_IMM_USE_STMT (stmt, imm_iter, name)\n     {\n+      if (TREE_CODE (stmt) != PHI_NODE)\n+\tpush_stmt_changes (&stmt);\n+\n       FOR_EACH_IMM_USE_ON_STMT (use, imm_iter)\n         {\n \t  replace_exp (use, val);\n@@ -1265,21 +1268,25 @@ replace_uses_by (tree name, tree val)\n \t\t}\n \t    }\n \t}\n+\n       if (TREE_CODE (stmt) != PHI_NODE)\n \t{\n \t  tree rhs;\n \n \t  fold_stmt_inplace (stmt);\n+\n+\t  /* FIXME.  This should go in pop_stmt_changes.  */\n \t  rhs = get_rhs (stmt);\n \t  if (TREE_CODE (rhs) == ADDR_EXPR)\n \t    recompute_tree_invariant_for_addr_expr (rhs);\n \n \t  maybe_clean_or_replace_eh_stmt (stmt, stmt);\n-\t  mark_new_vars_to_rename (stmt);\n+\n+\t  pop_stmt_changes (&stmt);\n \t}\n     }\n \n-  gcc_assert (num_imm_uses (name) == 0);\n+  gcc_assert (zero_imm_uses_p (name));\n \n   /* Also update the trees stored in loop structures.  */\n   if (current_loops)\n@@ -3996,7 +4003,7 @@ tree_make_forwarder_block (edge fallthru)\n   if (single_pred_p (bb))\n     return;\n \n-  /* If we redirected a branch we must create new phi nodes at the\n+  /* If we redirected a branch we must create new PHI nodes at the\n      start of BB.  */\n   for (phi = phi_nodes (dummy); phi; phi = PHI_CHAIN (phi))\n     {\n@@ -5684,7 +5691,7 @@ gimplify_val (block_stmt_iterator *bsi, tree type, tree exp)\n \n   bsi_insert_before (bsi, new_stmt, BSI_SAME_STMT);\n   if (gimple_in_ssa_p (cfun))\n-    mark_new_vars_to_rename (new_stmt);\n+    mark_symbols_for_renaming (new_stmt);\n \n   return t;\n }"}, {"sha": "4d60da027bb9fd03654a3cdbc64db5b018de6245", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -149,7 +149,7 @@ ptr_decl_may_alias_p (tree ptr, tree decl,\n   if (pi)\n     tag = pi->name_mem_tag;\n   if (!tag)\n-    tag = get_var_ann (SSA_NAME_VAR (ptr))->symbol_mem_tag;\n+    tag = symbol_mem_tag (SSA_NAME_VAR (ptr));\n   if (!tag)\n     tag = DR_MEMTAG (ptr_dr);\n   if (!tag)\n@@ -180,13 +180,13 @@ ptr_ptr_may_alias_p (tree ptr_a, tree ptr_b,\n     }\n   else\n     {\n-      tag_a = get_var_ann (SSA_NAME_VAR (ptr_a))->symbol_mem_tag;\n+      tag_a = symbol_mem_tag (SSA_NAME_VAR (ptr_a));\n       if (!tag_a)\n \ttag_a = DR_MEMTAG (dra);\n       if (!tag_a)\n \treturn false;\n       \n-      tag_b = get_var_ann (SSA_NAME_VAR (ptr_b))->symbol_mem_tag;\n+      tag_b = symbol_mem_tag (SSA_NAME_VAR (ptr_b));\n       if (!tag_b)\n \ttag_b = DR_MEMTAG (drb);\n       if (!tag_b)\n@@ -1729,10 +1729,9 @@ object_analysis (tree memref, tree stmt, bool is_read,\n       switch (TREE_CODE (base_address))\n \t{\n \tcase SSA_NAME:\n-\t  *memtag = get_var_ann (SSA_NAME_VAR (base_address))->symbol_mem_tag;\n+\t  *memtag = symbol_mem_tag (SSA_NAME_VAR (base_address));\n \t  if (!(*memtag) && TREE_CODE (TREE_OPERAND (memref, 0)) == SSA_NAME)\n-\t    *memtag = get_var_ann (\n-\t\t      SSA_NAME_VAR (TREE_OPERAND (memref, 0)))->symbol_mem_tag;\n+\t    *memtag = symbol_mem_tag (SSA_NAME_VAR (TREE_OPERAND (memref, 0)));\n \t  break;\n \tcase ADDR_EXPR:\n \t  *memtag = TREE_OPERAND (base_address, 0);"}, {"sha": "9c7afceccab60c5b9e283123291ad5ded573deee", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 40, "deletions": 84, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -334,33 +334,30 @@ dump_variable (FILE *file, tree var)\n \n   if (is_call_clobbered (var))\n     {\n+      var_ann_t va = var_ann (var);\n+      unsigned int escape_mask = va->escape_mask;\n+\n       fprintf (file, \", call clobbered\");\n-      if (dump_flags & TDF_DETAILS)\n-\t{\n-\t  var_ann_t va = var_ann (var);\n-\t  unsigned int escape_mask = va->escape_mask;\n-\t  \n-\t  fprintf (file, \" (\");\n-\t  if (escape_mask & ESCAPE_STORED_IN_GLOBAL)\n-\t    fprintf (file, \", stored in global\");\n-\t  if (escape_mask & ESCAPE_TO_ASM)\n-\t    fprintf (file, \", goes through ASM\");\n-\t  if (escape_mask & ESCAPE_TO_CALL)\n-\t    fprintf (file, \", passed to call\");\n-\t  if (escape_mask & ESCAPE_BAD_CAST)\n-\t    fprintf (file, \", bad cast\");\n-\t  if (escape_mask & ESCAPE_TO_RETURN)\n-\t    fprintf (file, \", returned from func\");\n-\t  if (escape_mask & ESCAPE_TO_PURE_CONST)\n-\t    fprintf (file, \", passed to pure/const\");\n-\t  if (escape_mask & ESCAPE_IS_GLOBAL)\n-\t    fprintf (file, \", is global var\");\n-\t  if (escape_mask & ESCAPE_IS_PARM)\n-\t    fprintf (file, \", is incoming pointer\");\n-\t  if (escape_mask & ESCAPE_UNKNOWN)\n-\t    fprintf (file, \", unknown escape\");\n-\t  fprintf (file, \" )\");\n-\t}\n+      fprintf (file, \" (\");\n+      if (escape_mask & ESCAPE_STORED_IN_GLOBAL)\n+\tfprintf (file, \", stored in global\");\n+      if (escape_mask & ESCAPE_TO_ASM)\n+\tfprintf (file, \", goes through ASM\");\n+      if (escape_mask & ESCAPE_TO_CALL)\n+\tfprintf (file, \", passed to call\");\n+      if (escape_mask & ESCAPE_BAD_CAST)\n+\tfprintf (file, \", bad cast\");\n+      if (escape_mask & ESCAPE_TO_RETURN)\n+\tfprintf (file, \", returned from func\");\n+      if (escape_mask & ESCAPE_TO_PURE_CONST)\n+\tfprintf (file, \", passed to pure/const\");\n+      if (escape_mask & ESCAPE_IS_GLOBAL)\n+\tfprintf (file, \", is global var\");\n+      if (escape_mask & ESCAPE_IS_PARM)\n+\tfprintf (file, \", is incoming pointer\");\n+      if (escape_mask & ESCAPE_UNKNOWN)\n+\tfprintf (file, \", unknown escape\");\n+      fprintf (file, \" )\");\n     }\n \n   if (gimple_default_def (cfun, var))\n@@ -688,8 +685,12 @@ set_default_def (tree var, tree def)\n    else\n     {\n       h = (struct int_tree_map *) *loc;\n+      SSA_NAME_IS_DEFAULT_DEF (h->to) = false;\n       h->to = def;\n     }\n+\n+   /* Mark DEF as the default definition for VAR.  */\n+   SSA_NAME_IS_DEFAULT_DEF (def) = true;\n }\n \n /* Add VAR to the list of referenced variables if it isn't already there.  */\n@@ -751,72 +752,27 @@ get_virtual_var (tree var)\n   return var;\n }\n \n-/* Mark all the non-SSA variables found in STMT's operands to be\n-   processed by update_ssa.  */\n+/* Mark all the naked symbols in STMT for SSA renaming.\n+   \n+   NOTE: This function should only be used for brand new statements.\n+   If the caller is modifying an existing statement, it should use the\n+   combination push_stmt_changes/pop_stmt_changes.  */\n \n void\n-mark_new_vars_to_rename (tree stmt)\n+mark_symbols_for_renaming (tree stmt)\n {\n+  tree op;\n   ssa_op_iter iter;\n-  tree val;\n-  bitmap vars_in_vops_to_rename;\n-  bool found_exposed_symbol = false;\n-  int v_may_defs_before, v_may_defs_after;\n-  int v_must_defs_before, v_must_defs_after;\n-\n-  if (TREE_CODE (stmt) == PHI_NODE)\n-    return;\n-\n-  get_stmt_ann (stmt);\n-  vars_in_vops_to_rename = BITMAP_ALLOC (NULL);\n-\n-  /* Before re-scanning the statement for operands, mark the existing\n-     virtual operands to be renamed again.  We do this because when new\n-     symbols are exposed, the virtual operands that were here before due to\n-     aliasing will probably be removed by the call to get_stmt_operand.\n-     Therefore, we need to flag them to be renamed beforehand.\n-\n-     We flag them in a separate bitmap because we don't really want to\n-     rename them if there are not any newly exposed symbols in the\n-     statement operands.  */\n-  v_may_defs_before = NUM_SSA_OPERANDS (stmt, SSA_OP_VMAYDEF);\n-  v_must_defs_before = NUM_SSA_OPERANDS (stmt, SSA_OP_VMUSTDEF);\n \n-  FOR_EACH_SSA_TREE_OPERAND (val, stmt, iter, \n-\t\t\t     SSA_OP_VMAYDEF | SSA_OP_VUSE | SSA_OP_VMUSTDEF)\n-    {\n-      if (!DECL_P (val))\n-\tval = SSA_NAME_VAR (val);\n-      bitmap_set_bit (vars_in_vops_to_rename, DECL_UID (val));\n-    }\n-\n-  /* Now force an operand re-scan on the statement and mark any newly\n-     exposed variables.  */\n   update_stmt (stmt);\n \n-  v_may_defs_after = NUM_SSA_OPERANDS (stmt, SSA_OP_VMAYDEF);\n-  v_must_defs_after = NUM_SSA_OPERANDS (stmt, SSA_OP_VMUSTDEF);\n-\n-  FOR_EACH_SSA_TREE_OPERAND (val, stmt, iter, SSA_OP_ALL_OPERANDS)\n-    if (DECL_P (val))\n-      {\n-\tfound_exposed_symbol = true;\n-\tmark_sym_for_renaming (val);\n-      }\n-\n-  /* If we found any newly exposed symbols, or if there are fewer VDEF\n-     operands in the statement, add the variables we had set in\n-     VARS_IN_VOPS_TO_RENAME to VARS_TO_RENAME.  We need to check for\n-     vanishing VDEFs because in those cases, the names that were formerly\n-     generated by this statement are not going to be available anymore.  */\n-  if (found_exposed_symbol\n-      || v_may_defs_before > v_may_defs_after\n-      || v_must_defs_before > v_must_defs_after)\n-    mark_set_for_renaming (vars_in_vops_to_rename);\n-\n-  BITMAP_FREE (vars_in_vops_to_rename);\n+  /* Mark all the operands for renaming.  */\n+  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_ALL_OPERANDS)\n+    if (DECL_P (op))\n+      mark_sym_for_renaming (op);\n }\n \n+\n /* Find all variables within the gimplified statement that were not previously\n    visible to the function and add them to the referenced variables list.  */\n \n@@ -845,7 +801,7 @@ find_new_referenced_vars (tree *stmt_p)\n }\n \n \n-/* If REF is a handled component reference for a structure, return the\n+/* If EXP is a handled component reference for a structure, return the\n    base variable.  The access range is delimited by bit positions *POFFSET and\n    *POFFSET + *PMAX_SIZE.  The access size is *PSIZE bits.  If either\n    *PSIZE or *PMAX_SIZE is -1, they could not be determined.  If *PSIZE"}, {"sha": "49be48e1009df45b2130919f7d0bd15403a706f3", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -587,7 +587,14 @@ num_imm_uses (tree var)\n   return num;\n }\n \n-\n+/* Return true if VAR has no immediate uses.  */\n+static inline bool\n+zero_imm_uses_p (tree var)\n+{\n+  ssa_use_operand_t *ptr = &(SSA_NAME_IMM_USE_NODE (var));\n+  return (ptr == ptr->next);\n+}\n+ \n /* Return the tree pointer to by USE.  */ \n static inline tree\n get_use_from_ptr (use_operand_p use)\n@@ -1712,6 +1719,35 @@ overlap_subvar (unsigned HOST_WIDE_INT offset, unsigned HOST_WIDE_INT size,\n \n }\n \n+/* Return the memory tag associated with symbol SYM.  */\n+\n+static inline tree\n+symbol_mem_tag (tree sym)\n+{\n+  tree tag = get_var_ann (sym)->symbol_mem_tag;\n+\n+#if defined ENABLE_CHECKING\n+  if (tag)\n+    gcc_assert (TREE_CODE (tag) == SYMBOL_MEMORY_TAG);\n+#endif\n+\n+  return tag;\n+}\n+\n+\n+/* Set the memory tag associated with symbol SYM.  */\n+\n+static inline void\n+set_symbol_mem_tag (tree sym, tree tag)\n+{\n+#if defined ENABLE_CHECKING\n+  if (tag)\n+    gcc_assert (TREE_CODE (tag) == SYMBOL_MEMORY_TAG);\n+#endif\n+\n+  get_var_ann (sym)->symbol_mem_tag = tag;\n+}\n+\n /* Get the value handle of EXPR.  This is the only correct way to get\n    the value handle for a \"thing\".  If EXPR does not have a value\n    handle associated, it returns NULL_TREE.  "}, {"sha": "2a5476422823aa88fa2c724e0e975c7e441032da", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -675,7 +675,7 @@ extern void dump_subvars_for (FILE *, tree);\n extern void debug_subvars_for (tree);\n extern tree get_virtual_var (tree);\n extern void add_referenced_var (tree);\n-extern void mark_new_vars_to_rename (tree);\n+extern void mark_symbols_for_renaming (tree);\n extern void find_new_referenced_vars (tree *);\n \n extern tree make_rename_temp (tree, const char *);\n@@ -733,7 +733,6 @@ extern bool tree_ssa_useless_type_conversion (tree);\n extern bool tree_ssa_useless_type_conversion_1 (tree, tree);\n extern void verify_ssa (bool);\n extern void delete_tree_ssa (void);\n-extern void register_new_def (tree, VEC(tree,heap) **);\n extern void walk_use_def_chains (tree, walk_use_def_chains_fn, void *, bool);\n extern bool stmt_references_memory_p (tree);\n \n@@ -746,7 +745,7 @@ bool need_ssa_update_p (void);\n bool name_mappings_registered_p (void);\n bool name_registered_for_update_p (tree);\n bitmap ssa_names_to_replace (void);\n-void release_ssa_name_after_update_ssa (tree name);\n+void release_ssa_name_after_update_ssa (tree);\n void compute_global_livein (bitmap, bitmap);\n tree duplicate_ssa_name (tree, tree);\n void mark_sym_for_renaming (tree);\n@@ -906,21 +905,22 @@ extern enum move_pos movement_possibility (tree);\n \n /* The reasons a variable may escape a function.  */\n enum escape_type \n-  {\n-    NO_ESCAPE = 0, /* Doesn't escape.  */\n-    ESCAPE_STORED_IN_GLOBAL = 1 << 1,\n-    ESCAPE_TO_ASM = 1 << 2,  /* Passed by address to an assembly\n-\t\t\t\tstatement.  */\n-    ESCAPE_TO_CALL = 1 << 3,  /* Escapes to a function call.  */\n-    ESCAPE_BAD_CAST = 1 << 4, /* Cast from pointer to integer */\n-    ESCAPE_TO_RETURN = 1 << 5, /* Returned from function.  */\n-    ESCAPE_TO_PURE_CONST = 1 << 6, /* Escapes to a pure or constant\n-\t\t\t\t      function call.  */\n-    ESCAPE_IS_GLOBAL = 1 << 7,  /* Is a global variable.  */\n-    ESCAPE_IS_PARM = 1 << 8, /* Is an incoming function parameter.  */\n-    ESCAPE_UNKNOWN = 1 << 9 /* We believe it escapes for some reason\n-\t\t\t       not enumerated above.  */\n-  };\n+{\n+  NO_ESCAPE = 0,\t\t\t/* Doesn't escape.  */\n+  ESCAPE_STORED_IN_GLOBAL = 1 << 1,\n+  ESCAPE_TO_ASM = 1 << 2,\t\t/* Passed by address to an assembly\n+\t\t\t\t\t   statement.  */\n+  ESCAPE_TO_CALL = 1 << 3,\t\t/* Escapes to a function call.  */\n+  ESCAPE_BAD_CAST = 1 << 4,\t\t/* Cast from pointer to integer */\n+  ESCAPE_TO_RETURN = 1 << 5,\t\t/* Returned from function.  */\n+  ESCAPE_TO_PURE_CONST = 1 << 6,\t/* Escapes to a pure or constant\n+\t\t\t\t\t   function call.  */\n+  ESCAPE_IS_GLOBAL = 1 << 7,\t\t/* Is a global variable.  */\n+  ESCAPE_IS_PARM = 1 << 8,\t\t/* Is an incoming function argument.  */\n+  ESCAPE_UNKNOWN = 1 << 9\t\t/* We believe it escapes for\n+\t\t\t\t\t   some reason not enumerated\n+\t\t\t\t\t   above.  */\n+};\n \n /* In tree-flow-inline.h  */\n static inline bool is_call_clobbered (tree);"}, {"sha": "fa71f5a5ac7675d79bdd97e65c5f18d4c4232819", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -1225,7 +1225,7 @@ insert_phi_nodes (bitmap *dfs)\n    variable (SSA_NAME_VAR (DEF)) and push VAR's current reaching definition\n    into the stack pointed to by BLOCK_DEFS_P.  */\n \n-void\n+static void\n register_new_def (tree def, VEC(tree,heap) **block_defs_p)\n {\n   tree var = SSA_NAME_VAR (def);"}, {"sha": "c65a31a1c0bdcead650c4fdc500cbbe5ebbca2ff", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -125,7 +125,7 @@ create_temp (tree t)\n   /* add_referenced_var will create the annotation and set up some\n      of the flags in the annotation.  However, some flags we need to\n      inherit from our original variable.  */\n-  var_ann (tmp)->symbol_mem_tag = var_ann (t)->symbol_mem_tag;\n+  set_symbol_mem_tag (tmp, symbol_mem_tag (t));\n   if (is_call_clobbered (t))\n     mark_call_clobbered (tmp, var_ann (t)->escape_mask);\n "}, {"sha": "9ce6f6bd2e8c05ec9f12e15ec5f7b8d82dd0c049", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -1844,12 +1844,11 @@ pointer_used_p (tree ptr)\n   imm_use_iterator imm_iter;\n   tree stmt, rhs;\n   struct ptr_info_def *pi = get_ptr_info (ptr);\n-  var_ann_t v_ann = var_ann (SSA_NAME_VAR (ptr));\n \n   /* Check whether the pointer has a memory tag; if it does, it is\n      (or at least used to be) dereferenced.  */\n   if ((pi != NULL && pi->name_mem_tag != NULL)\n-      || v_ann->symbol_mem_tag)\n+      || symbol_mem_tag (SSA_NAME_VAR (ptr)))\n     return true;\n \n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, ptr)"}, {"sha": "843e056f7c90d9512131529d16bdde294af15eda", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -1436,9 +1436,13 @@ struct tree_opt_pass pass_ccp =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_cleanup_cfg | TODO_dump_func | TODO_update_ssa\n-    | TODO_ggc_collect | TODO_verify_ssa\n-    | TODO_verify_stmts | TODO_update_smt_usage, /* todo_flags_finish */\n+  TODO_cleanup_cfg\n+    | TODO_dump_func\n+    | TODO_update_ssa\n+    | TODO_ggc_collect\n+    | TODO_verify_ssa\n+    | TODO_verify_stmts\n+    | TODO_update_smt_usage,\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n \n@@ -1474,10 +1478,13 @@ struct tree_opt_pass pass_store_ccp =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_update_ssa\n-    | TODO_ggc_collect | TODO_verify_ssa\n+  TODO_dump_func\n+    | TODO_update_ssa\n+    | TODO_ggc_collect\n+    | TODO_verify_ssa\n     | TODO_cleanup_cfg\n-    | TODO_verify_stmts | TODO_update_smt_usage, /* todo_flags_finish */\n+    | TODO_verify_stmts\n+    | TODO_update_smt_usage,\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n \n@@ -2512,7 +2519,7 @@ convert_to_gimple_builtin (block_stmt_iterator *si_p, tree expr, bool ignore)\n       tree new_stmt = tsi_stmt (ti);\n       find_new_referenced_vars (tsi_stmt_ptr (ti));\n       bsi_insert_before (si_p, new_stmt, BSI_NEW_STMT);\n-      mark_new_vars_to_rename (bsi_stmt (*si_p));\n+      mark_symbols_for_renaming (new_stmt);\n       bsi_next (si_p);\n     }\n \n@@ -2574,6 +2581,8 @@ execute_fold_all_builtins (void)\n \t      print_generic_stmt (dump_file, *stmtp, dump_flags);\n \t    }\n \n+\t  push_stmt_changes (stmtp);\n+\n \t  if (!set_rhs (stmtp, result))\n \t    {\n \t      result = convert_to_gimple_builtin (&i, result,\n@@ -2582,11 +2591,12 @@ execute_fold_all_builtins (void)\n \t      if (result)\n \t\t{\n \t\t  bool ok = set_rhs (stmtp, result);\n-\t\t  \n \t\t  gcc_assert (ok);\n \t\t}\n \t    }\n-\t  mark_new_vars_to_rename (*stmtp);\n+\n+\t  pop_stmt_changes (stmtp);\n+\n \t  if (maybe_clean_or_replace_eh_stmt (old_stmt, *stmtp)\n \t      && tree_purge_dead_eh_edges (bb))\n \t    cfg_changed = true;"}, {"sha": "a2d8f1fecb316b7c78cb16ae56a2565a00c4f76f", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -101,7 +101,11 @@ static VEC(tree,heap) *avail_exprs_stack;\n    expressions are removed from AVAIL_EXPRS.  Else we may change the\n    hash code for an expression and be unable to find/remove it from\n    AVAIL_EXPRS.  */\n-static VEC(tree,heap) *stmts_to_rescan;\n+typedef tree *tree_p;\n+DEF_VEC_P(tree_p);\n+DEF_VEC_ALLOC_P(tree_p,heap);\n+\n+static VEC(tree_p,heap) *stmts_to_rescan;\n \n /* Structure for entries in the expression hash table.\n \n@@ -247,7 +251,7 @@ tree_ssa_dominator_optimize (void)\n   avail_exprs = htab_create (1024, real_avail_expr_hash, avail_expr_eq, free);\n   avail_exprs_stack = VEC_alloc (tree, heap, 20);\n   const_and_copies_stack = VEC_alloc (tree, heap, 20);\n-  stmts_to_rescan = VEC_alloc (tree, heap, 20);\n+  stmts_to_rescan = VEC_alloc (tree_p, heap, 20);\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n \n   /* Setup callbacks for the generic dominator tree walker.  */\n@@ -359,7 +363,7 @@ tree_ssa_dominator_optimize (void)\n   \n   VEC_free (tree, heap, avail_exprs_stack);\n   VEC_free (tree, heap, const_and_copies_stack);\n-  VEC_free (tree, heap, stmts_to_rescan);\n+  VEC_free (tree_p, heap, stmts_to_rescan);\n   return 0;\n }\n \n@@ -701,16 +705,17 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \n   /* If we queued any statements to rescan in this block, then\n      go ahead and rescan them now.  */\n-  while (VEC_length (tree, stmts_to_rescan) > 0)\n+  while (VEC_length (tree_p, stmts_to_rescan) > 0)\n     {\n-      tree stmt = VEC_last (tree, stmts_to_rescan);\n+      tree *stmt_p = VEC_last (tree_p, stmts_to_rescan);\n+      tree stmt = *stmt_p;\n       basic_block stmt_bb = bb_for_stmt (stmt);\n \n       if (stmt_bb != bb)\n \tbreak;\n \n-      VEC_pop (tree, stmts_to_rescan);\n-      mark_new_vars_to_rename (stmt);\n+      VEC_pop (tree_p, stmts_to_rescan);\n+      pop_stmt_changes (stmt_p);\n     }\n }\n \n@@ -1557,9 +1562,7 @@ eliminate_redundant_computations (tree stmt)\n    Detect and record those equivalences.  */\n \n static void\n-record_equivalences_from_stmt (tree stmt,\n-\t\t\t       int may_optimize_p,\n-\t\t\t       stmt_ann_t ann)\n+record_equivalences_from_stmt (tree stmt, int may_optimize_p, stmt_ann_t ann)\n {\n   tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n   enum tree_code lhs_code = TREE_CODE (lhs);\n@@ -1588,6 +1591,7 @@ record_equivalences_from_stmt (tree stmt,\n      vops and recording the result in the available expression table,\n      we may be able to expose more redundant loads.  */\n   if (!ann->has_volatile_ops\n+      && stmt_references_memory_p (stmt)\n       && (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == SSA_NAME\n \t  || is_gimple_min_invariant (GIMPLE_STMT_OPERAND (stmt, 1)))\n       && !is_gimple_reg (lhs))\n@@ -1621,7 +1625,7 @@ record_equivalences_from_stmt (tree stmt,\n \t  /* Build a new statement with the RHS and LHS exchanged.  */\n \t  new = build2_gimple (GIMPLE_MODIFY_STMT, rhs, lhs);\n \n-\t  create_ssa_artficial_load_stmt (new, stmt);\n+\t  create_ssa_artificial_load_stmt (new, stmt);\n \n \t  /* Finally enter the statement into the available expression\n \t     table.  */\n@@ -1741,7 +1745,7 @@ cprop_operand (tree stmt, use_operand_p op_p)\n    known value for that SSA_NAME (or NULL if no value is known).  \n \n    Propagate values from CONST_AND_COPIES into the uses, vuses and\n-   v_may_def_ops of STMT.  */\n+   vdef_ops of STMT.  */\n \n static bool\n cprop_into_stmt (tree stmt)\n@@ -1793,14 +1797,15 @@ optimize_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   ann = stmt_ann (stmt);\n   opt_stats.num_stmts++;\n   may_have_exposed_new_symbols = false;\n+  push_stmt_changes (bsi_stmt_ptr (si));\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Optimizing statement \");\n       print_generic_stmt (dump_file, stmt, TDF_SLIM);\n     }\n \n-  /* Const/copy propagate into USES, VUSES and the RHS of V_MAY_DEFs.  */\n+  /* Const/copy propagate into USES, VUSES and the RHS of VDEFs.  */\n   may_have_exposed_new_symbols = cprop_into_stmt (stmt);\n \n   /* If the statement has been modified with constant replacements,\n@@ -1856,9 +1861,7 @@ optimize_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \n   /* Record any additional equivalences created by this statement.  */\n   if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n-    record_equivalences_from_stmt (stmt,\n-\t\t\t\t   may_optimize_p,\n-\t\t\t\t   ann);\n+    record_equivalences_from_stmt (stmt, may_optimize_p, ann);\n \n   /* If STMT is a COND_EXPR and it was modified, then we may know\n      where it goes.  If that is the case, then mark the CFG as altered.\n@@ -1885,7 +1888,6 @@ optimize_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \n      Ultimately I suspect we're going to need to change the interface\n      into the SSA_NAME manager.  */\n-\n   if (ann->modified)\n     {\n       tree val = NULL;\n@@ -1909,7 +1911,20 @@ optimize_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n     }\n \n   if (may_have_exposed_new_symbols)\n-    VEC_safe_push (tree, heap, stmts_to_rescan, bsi_stmt (si));\n+    {\n+      /* Queue the statement to be re-scanned after all the\n+\t AVAIL_EXPRS have been processed.  The change buffer stack for\n+\t all the pushed statements will be processed when this queue\n+\t is emptied.  */\n+      VEC_safe_push (tree_p, heap, stmts_to_rescan, bsi_stmt_ptr (si));\n+    }\n+  else\n+    {\n+      /* Otherwise, just discard the recently pushed change buffer.  If\n+\t not, the STMTS_TO_RESCAN queue will get out of synch with the\n+\t change buffer stack.  */\n+      discard_stmt_changes (bsi_stmt_ptr (si));\n+    }\n }\n \n /* Search for an existing instance of STMT in the AVAIL_EXPRS table.  If\n@@ -2185,6 +2200,8 @@ propagate_rhs_into_lhs (tree stmt, tree lhs, tree rhs, bitmap interesting_names)\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \n+\t  push_stmt_changes (&use_stmt);\n+\n \t  /* Propagate the RHS into this use of the LHS.  */\n \t  FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n \t    propagate_value (use_p, rhs);\n@@ -2219,6 +2236,8 @@ propagate_rhs_into_lhs (tree stmt, tree lhs, tree rhs, bitmap interesting_names)\n \t\t  tree result = get_lhs_or_phi_result (use_stmt);\n \t\t  bitmap_set_bit (interesting_names, SSA_NAME_VERSION (result));\n \t\t}\n+\n+\t      discard_stmt_changes (&use_stmt);\n \t      continue;\n \t    }\n \n@@ -2231,7 +2250,7 @@ propagate_rhs_into_lhs (tree stmt, tree lhs, tree rhs, bitmap interesting_names)\n \t  /* Sometimes propagation can expose new operands to the\n \t     renamer.  Note this will call update_stmt at the \n \t     appropriate time.  */\n-\t  mark_new_vars_to_rename (use_stmt);\n+\t  pop_stmt_changes (&use_stmt);\n \n \t  /* Dump details.  */\n \t  if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "638224a803566e8d9d5a40c4c4150102e4d892f8", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -586,7 +586,7 @@ tidy_after_forward_propagate_addr (tree stmt)\n   if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == ADDR_EXPR)\n      recompute_tree_invariant_for_addr_expr (GIMPLE_STMT_OPERAND (stmt, 1));\n \n-  mark_new_vars_to_rename (stmt);\n+  mark_symbols_for_renaming (stmt);\n }\n \n /* STMT defines LHS which is contains the address of the 0th element\n@@ -856,9 +856,13 @@ forward_propagate_addr_expr (tree stmt, bool *some)\n \t  continue;\n \t}\n       \n+      push_stmt_changes (&use_stmt);\n+\n       result = forward_propagate_addr_expr_1 (stmt, use_stmt, some);\n       *some |= result;\n       all &= result;\n+\n+      pop_stmt_changes (&use_stmt);\n     }\n \n   return all;\n@@ -1051,8 +1055,9 @@ struct tree_opt_pass pass_forwprop = {\n   0,\t\t\t\t/* properties_provided */\n   0,\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func /* todo_flags_finish */\n+  TODO_dump_func\n   | TODO_ggc_collect\n-  | TODO_update_ssa | TODO_verify_ssa,\n-  0\t\t\t\t\t/* letter */\n+  | TODO_update_ssa\n+  | TODO_verify_ssa,\t\t/* todo_flags_finish */\n+  0\t\t\t\t/* letter */\n };"}, {"sha": "454374010aa25706f4273952e699c8048d8a14e4", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -5556,7 +5556,7 @@ get_ref_tag (tree ref, tree orig)\n \t}\n  \n       var = SSA_NAME_VAR (var);\n-      tag = var_ann (var)->symbol_mem_tag;\n+      tag = symbol_mem_tag (var);\n       gcc_assert (tag != NULL_TREE);\n       return tag;\n     }\n@@ -5565,7 +5565,7 @@ get_ref_tag (tree ref, tree orig)\n       if (!DECL_P (var))\n \treturn NULL_TREE;\n \n-      tag = var_ann (var)->symbol_mem_tag;\n+      tag = symbol_mem_tag (var);\n       if (tag)\n \treturn tag;\n \n@@ -5657,9 +5657,10 @@ rewrite_use_compare (struct ivopts_data *data,\n /* Rewrites USE using candidate CAND.  */\n \n static void\n-rewrite_use (struct ivopts_data *data,\n-\t     struct iv_use *use, struct iv_cand *cand)\n+rewrite_use (struct ivopts_data *data, struct iv_use *use, struct iv_cand *cand)\n {\n+  push_stmt_changes (&use->stmt);\n+\n   switch (use->type)\n     {\n       case USE_NONLINEAR_EXPR:\n@@ -5677,7 +5678,8 @@ rewrite_use (struct ivopts_data *data,\n       default:\n \tgcc_unreachable ();\n     }\n-  mark_new_vars_to_rename (use->stmt);\n+\n+  pop_stmt_changes (&use->stmt);\n }\n \n /* Rewrite the uses using the selected induction variables.  */"}, {"sha": "cac13ebf469c9755ed3cd42ade50712fa211f032", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 247, "deletions": 1, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -121,6 +121,49 @@ static void get_expr_operands (tree, tree *, int);\n /* Number of functions with initialized ssa_operands.  */\n static int n_initialized = 0;\n \n+/* Statement change buffer.  Data structure used to record state\n+   information for statements.  This is used to determine what needs\n+   to be done in order to update the SSA web after a statement is\n+   modified by a pass.  If STMT is a statement that has just been\n+   created, or needs to be folded via fold_stmt, or anything that\n+   changes its physical structure then the pass should:\n+\n+   1- Call push_stmt_changes (&stmt) to record the current state of\n+      STMT before any modifications are made.\n+\n+   2- Make all appropriate modifications to the statement.\n+\n+   3- Call pop_stmt_changes (&stmt) to find new symbols that\n+      need to be put in SSA form, SSA name mappings for names that\n+      have disappeared, recompute invariantness for address\n+      expressions, cleanup EH information, etc.\n+\n+   If it is possible to determine that the statement was not modified,\n+   instead of calling pop_stmt_changes it is quicker to call\n+   discard_stmt_changes to avoid the expensive and unnecessary operand\n+   re-scan and change comparison.  */\n+\n+struct scb_d\n+{\n+  /* Pointer to the statement being modified.  */\n+  tree *stmt_p;\n+\n+  /* If the statement references memory these are the sets of symbols\n+     loaded and stored by the statement.  */\n+  bitmap loads;\n+  bitmap stores;\n+};\n+\n+typedef struct scb_d *scb_t;\n+DEF_VEC_P(scb_t);\n+DEF_VEC_ALLOC_P(scb_t,heap);\n+\n+/* Stack of statement change buffers (SCB).  Every call to\n+   push_stmt_changes pushes a new buffer onto the stack.  Calls to\n+   pop_stmt_changes pop a buffer off of the stack and compute the set\n+   of changes for the popped statement.  */\n+static VEC(scb_t,heap) *scb_stack;\n+\n /* Allocates operand OP of given TYPE from the appropriate free list,\n    or of the new value if the list is empty.  */\n \n@@ -2277,7 +2320,7 @@ copy_virtual_operands (tree dest, tree src)\n    values stored.  */\n \n void\n-create_ssa_artficial_load_stmt (tree new_stmt, tree old_stmt)\n+create_ssa_artificial_load_stmt (tree new_stmt, tree old_stmt)\n {\n   stmt_ann_t ann;\n   tree op;\n@@ -2567,3 +2610,206 @@ debug_immediate_uses_for (tree var)\n {\n   dump_immediate_uses_for (stderr, var);\n }\n+\n+\n+/* Create a new change buffer for the statement pointed by STMT_P and\n+   push the buffer into SCB_STACK.  Each change buffer\n+   records state information needed to determine what changed in the\n+   statement.  Mainly, this keeps track of symbols that may need to be\n+   put into SSA form, SSA name replacements and other information\n+   needed to keep the SSA form up to date.  */\n+\n+void\n+push_stmt_changes (tree *stmt_p)\n+{\n+  tree stmt;\n+  scb_t buf;\n+  \n+  stmt = *stmt_p;\n+\n+  /* It makes no sense to keep track of PHI nodes.  */\n+  if (TREE_CODE (stmt) == PHI_NODE)\n+    return;\n+\n+  buf = xmalloc (sizeof *buf);\n+  memset (buf, 0, sizeof *buf);\n+\n+  buf->stmt_p = stmt_p;\n+\n+  if (stmt_references_memory_p (stmt))\n+    {\n+      tree op;\n+      ssa_op_iter i;\n+\n+      FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_VUSE)\n+\t{\n+\t  tree sym = TREE_CODE (op) == SSA_NAME ? SSA_NAME_VAR (op) : op;\n+\t  if (buf->loads == NULL)\n+\t    buf->loads = BITMAP_ALLOC (NULL);\n+\t  bitmap_set_bit (buf->loads, DECL_UID (sym));\n+\t}\n+\n+      FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_VIRTUAL_DEFS)\n+\t{\n+\t  tree sym = TREE_CODE (op) == SSA_NAME ? SSA_NAME_VAR (op) : op;\n+\t  if (buf->stores == NULL)\n+\t    buf->stores = BITMAP_ALLOC (NULL);\n+\t  bitmap_set_bit (buf->stores, DECL_UID (sym));\n+\t}\n+    }\n+\n+  VEC_safe_push (scb_t, heap, scb_stack, buf);\n+}\n+\n+\n+/* Given two sets S1 and S2, mark the symbols that differ in S1 and S2\n+   for renaming.  The set to mark for renaming is (S1 & ~S2) | (S2 & ~S1).  */\n+\n+static void\n+mark_difference_for_renaming (bitmap s1, bitmap s2)\n+{\n+  if (s1 == NULL && s2 == NULL)\n+    return;\n+\n+  if (s1 && s2 == NULL)\n+    mark_set_for_renaming (s1);\n+  else if (s1 == NULL && s2)\n+    mark_set_for_renaming (s2);\n+  else if (!bitmap_equal_p (s1, s2))\n+    {\n+      bitmap t1 = BITMAP_ALLOC (NULL);\n+      bitmap t2 = BITMAP_ALLOC (NULL);\n+\n+      bitmap_and_compl (t1, s1, s2);\n+      bitmap_and_compl (t2, s2, s1);\n+      bitmap_ior_into (t1, t2);\n+      mark_set_for_renaming (t1);\n+\n+      BITMAP_FREE (t1);\n+      BITMAP_FREE (t2);\n+    }\n+}\n+\n+\n+/* Pop the top SCB from SCB_STACK and act on the differences between\n+   what was recorded by push_stmt_changes and the current state of\n+   the statement.  */\n+\n+void\n+pop_stmt_changes (tree *stmt_p)\n+{\n+  tree op, stmt;\n+  ssa_op_iter iter;\n+  bitmap loads, stores;\n+  scb_t buf;\n+\n+  stmt = *stmt_p;\n+\n+  /* It makes no sense to keep track of PHI nodes.  */\n+  if (TREE_CODE (stmt) == PHI_NODE)\n+    return;\n+\n+  buf = VEC_pop (scb_t, scb_stack);\n+  gcc_assert (stmt_p == buf->stmt_p);\n+\n+  /* Force an operand re-scan on the statement and mark any newly\n+     exposed variables.  */\n+  update_stmt (stmt);\n+\n+  /* Determine whether any memory symbols need to be renamed.  If the\n+     sets of loads and stores are different after the statement is\n+     modified, then the affected symbols need to be renamed.\n+     \n+     Note that it may be possible for the statement to not reference\n+     memory anymore, but we still need to act on the differences in\n+     the sets of symbols.  */\n+  loads = stores = NULL;\n+  if (stmt_references_memory_p (stmt))\n+    {\n+      tree op;\n+      ssa_op_iter i;\n+\n+      FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_VUSE)\n+\t{\n+\t  tree sym = TREE_CODE (op) == SSA_NAME ? SSA_NAME_VAR (op) : op;\n+\t  if (loads == NULL)\n+\t    loads = BITMAP_ALLOC (NULL);\n+\t  bitmap_set_bit (loads, DECL_UID (sym));\n+\t}\n+\n+      FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_VIRTUAL_DEFS)\n+\t{\n+\t  tree sym = TREE_CODE (op) == SSA_NAME ? SSA_NAME_VAR (op) : op;\n+\t  if (stores == NULL)\n+\t    stores = BITMAP_ALLOC (NULL);\n+\t  bitmap_set_bit (stores, DECL_UID (sym));\n+\n+\t  /* If a V_MAY_DEF turned into a V_MUST_DEF, we will keep\n+\t     referencing the same symbol, but we still need to mark it\n+\t     for renaming since the operand scanner stripped its\n+\t     SSA_NAME.  */\n+\t  if (op == sym)\n+\t    mark_sym_for_renaming (sym);\n+\t}\n+    }\n+\n+  /* If LOADS is different from BUF->LOADS, the affected\n+     symbols need to be marked for renaming.  */\n+  mark_difference_for_renaming (loads, buf->loads);\n+\n+  /* Similarly for STORES and BUF->STORES.  */\n+  mark_difference_for_renaming (stores, buf->stores);\n+\n+  /* Mark all the naked GIMPLE register operands for renaming.  */\n+  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_DEF|SSA_OP_USE)\n+    if (DECL_P (op))\n+      mark_sym_for_renaming (op);\n+\n+  /* FIXME, need to add more finalizers here.  Cleanup EH info,\n+     recompute invariants for address expressions, add\n+     SSA replacement mappings, etc.  For instance, given\n+     testsuite/gcc.c-torture/compile/pr16808.c, we fold a statement of\n+     the form:\n+\n+\t  # SMT.4_20 = VDEF <SMT.4_16>\n+\t  D.1576_11 = 1.0e+0;\n+\n+     So, the VDEF will disappear, but instead of marking SMT.4 for\n+     renaming it would be far more efficient to establish a\n+     replacement mapping that would replace every reference of\n+     SMT.4_20 with SMT.4_16.  */\n+\n+  /* Free memory used by the buffer.  */\n+  BITMAP_FREE (buf->loads);\n+  BITMAP_FREE (buf->stores);\n+  BITMAP_FREE (loads);\n+  BITMAP_FREE (stores);\n+  buf->stmt_p = NULL;\n+  free (buf);\n+}\n+\n+\n+/* Discard the topmost change buffer from SCB_STACK.  This is useful\n+   when the caller realized that it did not actually modified the\n+   statement.  It avoids the expensive operand re-scan.  */\n+\n+void\n+discard_stmt_changes (tree *stmt_p)\n+{\n+  scb_t buf;\n+  tree stmt;\n+  \n+  /* It makes no sense to keep track of PHI nodes.  */\n+  stmt = *stmt_p;\n+  if (TREE_CODE (stmt) == PHI_NODE)\n+    return;\n+\n+  buf = VEC_pop (scb_t, scb_stack);\n+  gcc_assert (stmt_p == buf->stmt_p);\n+\n+  /* Free memory used by the buffer.  */\n+  BITMAP_FREE (buf->loads);\n+  BITMAP_FREE (buf->stores);\n+  buf->stmt_p = NULL;\n+  free (buf);\n+}"}, {"sha": "17c1f6bb8e30d112f88425e792c51247c243a0b6", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -171,7 +171,7 @@ extern void update_stmt_operands (tree);\n extern bool verify_imm_links (FILE *f, tree var);\n \n extern void copy_virtual_operands (tree, tree);\n-extern void create_ssa_artficial_load_stmt (tree, tree);\n+extern void create_ssa_artificial_load_stmt (tree, tree);\n \n extern void dump_immediate_uses (FILE *file);\n extern void dump_immediate_uses_for (FILE *file, tree var);\n@@ -181,6 +181,9 @@ extern void debug_immediate_uses_for (tree var);\n extern bool ssa_operands_active (void);\n \n extern void add_to_addressable_set (tree, bitmap *);\n+extern void push_stmt_changes (tree *);\n+extern void pop_stmt_changes (tree *);\n+extern void discard_stmt_changes (tree *);\n \n enum ssa_op_iter_type {\n   ssa_op_iter_none = 0,"}, {"sha": "24274619914c6841d4245a79fda9f1cc5205893c", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -2616,7 +2616,7 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \t  vn_add (forcedname, val);\n \t  bitmap_value_replace_in_set (NEW_SETS (block), forcedname);\n \t  bitmap_value_replace_in_set (AVAIL_OUT (block), forcedname);\n-\t  mark_new_vars_to_rename (stmt);\n+\t  mark_symbols_for_renaming (stmt);\n \t}\n       tsi = tsi_last (stmts);\n       tsi_link_after (&tsi, forced_stmts, TSI_CONTINUE_LINKING);\n@@ -2644,7 +2644,9 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n   tsi = tsi_last (stmts);\n   tsi_link_after (&tsi, newexpr, TSI_CONTINUE_LINKING);\n   VEC_safe_push (tree, heap, inserted_exprs, newexpr);\n-  mark_new_vars_to_rename (newexpr);\n+\n+  /* All the symbols in NEWEXPR should be put into SSA form.  */\n+  mark_symbols_for_renaming (newexpr);\n \n   /* Add a value handle to the temporary.\n      The value may already exist in either NEW_SETS, or AVAIL_OUT, because\n@@ -3543,7 +3545,7 @@ insert_fake_stores (void)\n \n \t      lhs = make_ssa_name (storetemp, new);\n \t      GIMPLE_STMT_OPERAND (new, 0) = lhs;\n-\t      create_ssa_artficial_load_stmt (new, stmt);\n+\t      create_ssa_artificial_load_stmt (new, stmt);\n \n \t      NECESSARY (new) = 0;\n \t      VEC_safe_push (tree, heap, inserted_exprs, new);"}, {"sha": "49277a037c2ccdbf5a0185a3fa9ddec688ccd0ee", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -1176,6 +1176,9 @@ substitute_and_fold (prop_value_t *prop_value, bool use_ranges_p)\n \t      && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == ASSERT_EXPR)\n \t    continue;\n \n+\t  /* Record the state of the statement before replacements.  */\n+\t  push_stmt_changes (bsi_stmt_ptr (i));\n+\n \t  /* Replace the statement with its folded version and mark it\n \t     folded.  */\n \t  did_replace = false;\n@@ -1211,10 +1214,6 @@ substitute_and_fold (prop_value_t *prop_value, bool use_ranges_p)\n \t      fold_stmt (bsi_stmt_ptr (i));\n \t      stmt = bsi_stmt (i);\n \n-\t      /* If we folded a builtin function, we'll likely\n-\t\t need to rename VDEFs.  */\n-\t      mark_new_vars_to_rename (stmt);\n-\n               /* If we cleaned up EH information from the statement,\n                  remove EH edges.  */\n \t      if (maybe_clean_or_replace_eh_stmt (old_stmt, stmt))\n@@ -1232,6 +1231,14 @@ substitute_and_fold (prop_value_t *prop_value, bool use_ranges_p)\n \t\t  print_generic_stmt (dump_file, stmt, TDF_SLIM);\n \t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n+\n+\t      /* Determine what needs to be done to update the SSA form.  */\n+\t      pop_stmt_changes (bsi_stmt_ptr (i));\n+\t    }\n+\t  else\n+\t    {\n+\t      /* The statement was not modified, discard the change buffer.  */\n+\t      discard_stmt_changes (bsi_stmt_ptr (i));\n \t    }\n \n \t  /* Some statements may be simplified using ranges.  For\n@@ -1242,7 +1249,6 @@ substitute_and_fold (prop_value_t *prop_value, bool use_ranges_p)\n \t     statement.  */\n \t  if (use_ranges_p)\n \t    simplify_stmt_using_ranges (stmt);\n-\n \t}\n     }\n "}, {"sha": "5e78261507259cc52b1426e5f721641cecfdbd1d", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -264,7 +264,7 @@ get_rank (tree e)\n       int i;\n \n       if (TREE_CODE (SSA_NAME_VAR (e)) == PARM_DECL\n-\t  && e == gimple_default_def (cfun, SSA_NAME_VAR (e)))\n+\t  && SSA_NAME_IS_DEFAULT_DEF (e))\n \treturn find_operand_rank (e)->rank;\n \n       stmt = SSA_NAME_DEF_STMT (e);"}, {"sha": "5404edded823a1027bed753a5001f4e230156542", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -152,6 +152,7 @@ make_ssa_name (tree var, tree stmt)\n   SSA_NAME_DEF_STMT (t) = stmt;\n   SSA_NAME_PTR_INFO (t) = NULL;\n   SSA_NAME_IN_FREE_LIST (t) = 0;\n+  SSA_NAME_IS_DEFAULT_DEF (t) = 0;\n   imm = &(SSA_NAME_IMM_USE_NODE (t));\n   imm->use = NULL;\n   imm->prev = imm;\n@@ -178,7 +179,7 @@ release_ssa_name (tree var)\n \n   /* Never release the default definition for a symbol.  It's a\n      special SSA name that should always exist once it's created.  */\n-  if (var == gimple_default_def (cfun, SSA_NAME_VAR (var)))\n+  if (SSA_NAME_IS_DEFAULT_DEF (var))\n     return;\n \n   /* If VAR has been registered for SSA updating, don't remove it."}, {"sha": "d1caf5c92ebf553a893187a6a8402e26502ddbb6", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -3162,7 +3162,7 @@ vect_permute_load_chain (VEC(tree,heap) *dr_chain,\n \t  data_ref = make_ssa_name (perm_dest, perm_stmt);\n \t  GIMPLE_STMT_OPERAND (perm_stmt, 0) = data_ref;\n \t  vect_finish_stmt_generation (stmt, perm_stmt, bsi);\n-\t  mark_new_vars_to_rename (perm_stmt);\n+\t  mark_symbols_for_renaming (perm_stmt);\n \n \t  VEC_replace (tree, *result_chain, j/2, data_ref);\t      \n \t      \n@@ -3176,7 +3176,7 @@ vect_permute_load_chain (VEC(tree,heap) *dr_chain,\n \t  data_ref = make_ssa_name (perm_dest, perm_stmt);\n \t  GIMPLE_STMT_OPERAND (perm_stmt, 0) = data_ref;\n \t  vect_finish_stmt_generation (stmt, perm_stmt, bsi);\n-\t  mark_new_vars_to_rename (perm_stmt);\n+\t  mark_symbols_for_renaming (perm_stmt);\n \n \t  VEC_replace (tree, *result_chain, j/2+length/2, data_ref);\n \t}\n@@ -3540,7 +3540,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t  GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n \t  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n \t  copy_virtual_operands (new_stmt, stmt);\n-\t  mark_new_vars_to_rename (new_stmt);\n+\t  mark_symbols_for_renaming (new_stmt);\n \n \t  /* 3. Handle explicit realignment if necessary/supported.  */\n \t  if (alignment_support_cheme == dr_unaligned_software_pipeline)"}, {"sha": "483607ec5544f8a46d3e86ad419e7e338b9372eb", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -273,7 +273,7 @@ get_value_range (tree var)\n   /* If VAR is a default definition, the variable can take any value\n      in VAR's type.  */\n   sym = SSA_NAME_VAR (var);\n-  if (var == gimple_default_def (cfun, sym))\n+  if (SSA_NAME_IS_DEFAULT_DEF (var))\n     {\n       /* Try to use the \"nonnull\" attribute to create ~[0, 0]\n \t anti-ranges for pointers.  Note that this is only valid with"}, {"sha": "614de7aab7848bfcaf06936a4ead6a6f8b43ec7f", "filename": "gcc/tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -7306,6 +7306,9 @@ is_global_var (tree t)\n bool\n needs_to_live_in_memory (tree t)\n {\n+  if (TREE_CODE (t) == SSA_NAME)\n+    t = SSA_NAME_VAR (t);\n+\n   return (TREE_ADDRESSABLE (t)\n \t  || is_global_var (t)\n \t  || (TREE_CODE (t) == RESULT_DECL"}, {"sha": "a6515517f9bc4227927c655849546d6637763c95", "filename": "gcc/tree.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfaab3a92418d34e14bb0fa447c052fce9f6057b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=cfaab3a92418d34e14bb0fa447c052fce9f6057b", "patch": "@@ -1762,6 +1762,14 @@ struct tree_exp GTY(())\n #define SSA_NAME_IN_FREE_LIST(NODE) \\\n     SSA_NAME_CHECK (NODE)->base.nothrow_flag\n \n+/* Nonzero if this SSA_NAME is the default definition for the\n+   underlying symbol.  A default SSA name is created for symbol S if\n+   the very first reference to S in the function is a read operation.\n+   Default definitions are always created by an empty statement and\n+   belong to no basic block.  */\n+#define SSA_NAME_IS_DEFAULT_DEF(NODE)\t\\\n+    SSA_NAME_CHECK (NODE)->base.volatile_flag\n+\n /* Attributes for SSA_NAMEs for pointer-type variables.  */\n #define SSA_NAME_PTR_INFO(N) \\\n     SSA_NAME_CHECK (N)->ssa_name.ptr_info"}]}