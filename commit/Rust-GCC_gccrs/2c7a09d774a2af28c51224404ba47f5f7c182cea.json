{"sha": "2c7a09d774a2af28c51224404ba47f5f7c182cea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM3YTA5ZDc3NGEyYWYyOGM1MTIyNDQwNGJhNDdmNWY3YzE4MmNlYQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2011-04-30T19:40:06Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2011-04-30T19:40:06Z"}, "message": "[multiple changes]\n\n2011-04-30  Daniel Krugler  <daniel.kruegler@googlemail.com>\n\n\t* include/std/type_traits (__is_default_constructible_atom,\n\t__is_default_constructible_safe<, true>,\n\t__is_direct_constructible_new_safe,\n\t__is_base_to_derived_ref<,, true>, __is_lvalue_to_rvalue_ref<,, true>,\n\t__is_direct_constructible_ref_cast, __is_direct_constructible,\n\t__is_nary_constructible): Simplify; add comments throughout.\n\n2011-04-30  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc:\n\tAdjust dg-error line numbers.\n\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc:\n\tLikewise.\n\t* testsuite/20_util/declval/requirements/1_neg.cc: Likewise.\n\nFrom-SVN: r173222", "tree": {"sha": "216363d5372c9b247b77a0955e69523ffad3fc97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/216363d5372c9b247b77a0955e69523ffad3fc97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c7a09d774a2af28c51224404ba47f5f7c182cea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c7a09d774a2af28c51224404ba47f5f7c182cea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c7a09d774a2af28c51224404ba47f5f7c182cea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c7a09d774a2af28c51224404ba47f5f7c182cea/comments", "author": null, "committer": null, "parents": [{"sha": "2ad7ae18f41c0fc42e0d68978bb0fdb4f6f7c3a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ad7ae18f41c0fc42e0d68978bb0fdb4f6f7c3a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ad7ae18f41c0fc42e0d68978bb0fdb4f6f7c3a5"}], "stats": {"total": 111, "additions": 70, "deletions": 41}, "files": [{"sha": "8e509aa7500d920e6a66545ef742ca2bca0077e4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7a09d774a2af28c51224404ba47f5f7c182cea/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7a09d774a2af28c51224404ba47f5f7c182cea/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2c7a09d774a2af28c51224404ba47f5f7c182cea", "patch": "@@ -1,3 +1,20 @@\n+2011-04-30  Daniel Krugler  <daniel.kruegler@googlemail.com>\n+\n+\t* include/std/type_traits (__is_default_constructible_atom,\n+\t__is_default_constructible_safe<, true>,\n+\t__is_direct_constructible_new_safe,\n+\t__is_base_to_derived_ref<,, true>, __is_lvalue_to_rvalue_ref<,, true>,\n+\t__is_direct_constructible_ref_cast, __is_direct_constructible,\n+\t__is_nary_constructible): Simplify; add comments throughout.\n+\n+2011-04-30  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc:\n+\tAdjust dg-error line numbers.\n+\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc:\n+\tLikewise.\n+\t* testsuite/20_util/declval/requirements/1_neg.cc: Likewise.\n+\n 2011-04-30  Doug Kwan  <dougkwan@google.com>\n \n \t* include/Makefile.am (install-freestanding-headers): Also install"}, {"sha": "0560522cbfd1cc11e2babeb279389b8e1570542d", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 48, "deletions": 36, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7a09d774a2af28c51224404ba47f5f7c182cea/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7a09d774a2af28c51224404ba47f5f7c182cea/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=2c7a09d774a2af28c51224404ba47f5f7c182cea", "patch": "@@ -550,7 +550,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct __is_array_unknown_bounds\n     : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>::type\n     { };\n-\n+    \n+  // In N3290 is_destructible does not say anything about function \n+  // types and abstract types, see LWG 2049. This implementation\n+  // describes function types as trivially nothrow destructible and\n+  // abstract types as destructible, iff the  explicit destructor\n+  // call expression is wellformed.\n   struct __do_is_destructible_impl_1\n   {\n     template<typename _Up>\n@@ -571,6 +576,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef decltype(__test<_Tp>(0)) type;\n     };\n \n+  // Special implementation for abstract types\n   struct __do_is_destructible_impl_2\n   {\n     template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>\n@@ -632,23 +638,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp>\n     struct __is_default_constructible_atom\n-    : public __and_<is_destructible<_Tp>,\n-                    __is_default_constructible_impl<_Tp>>::type::type\n+    : public __and_<__not_<is_void<_Tp>>,\n+                    __is_default_constructible_impl<_Tp>>::type\n     { };\n \n   template<typename _Tp, bool = is_array<_Tp>::value>\n     struct __is_default_constructible_safe;\n \n-  // The following technique is a workaround for a gcc defect, which does\n-  // not sfinae away attempts to default-construct arrays of unknown bounds.\n-  // Complete arrays can be default-constructed, if the element type is\n-  // default-constructible, but arrays with unknown bounds are not:\n-\n+  // The following technique is a workaround for a current core language\n+  // restriction, which does not allow for array types to occur in \n+  // functional casts of the form T().  Complete arrays can be default-\n+  // constructed, if the element type is default-constructible, but \n+  // arrays with unknown bounds are not.\n   template<typename _Tp>\n     struct __is_default_constructible_safe<_Tp, true>\n     : public __and_<__is_array_known_bounds<_Tp>,\n \t\t    __is_default_constructible_atom<typename\n-                      remove_all_extents<_Tp>::type>>::type::type\n+                      remove_all_extents<_Tp>::type>>::type\n     { };\n \n   template<typename _Tp>\n@@ -663,6 +669,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t      _Tp>::value)>\n     { };\n \n+\n+  // Implementation of is_constructible.\n+\n+  // The hardest part of this trait is the binary direct-initialization\n+  // case, because we hit into a functional cast of the form T(arg).\n+  // This implementation uses different strategies depending on the\n+  // target type to reduce the test overhead as much as possible:\n+  //\n+  // a) For a reference target type, we use a static_cast expression \n+  //    modulo its extra cases.\n+  //\n+  // b) For a non-reference target type we use a ::new expression.\n   struct __do_is_static_castable_impl\n   {\n     template<typename _From, typename _To, typename\n@@ -682,8 +700,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _From, typename _To>\n     struct __is_static_castable_safe\n-    : public __and_<__or_<is_void<_To>, is_destructible<_To>>,\n-                    __is_static_castable_impl<_From, _To>>::type::type\n+    : public __is_static_castable_impl<_From, _To>::type\n     { };\n \n   // __is_static_castable\n@@ -693,6 +710,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t      _From, _To>::value)>\n     { };\n \n+  // Implementation for non-reference types. To meet the proper\n+  // variable definition semantics, we also need to test for\n+  // is_destructible in this case.\n   struct __do_is_direct_constructible_impl\n   {\n     template<typename _Tp, typename _Arg, typename\n@@ -713,7 +733,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp, typename _Arg>\n     struct __is_direct_constructible_new_safe\n     : public __and_<is_destructible<_Tp>,\n-                    __is_direct_constructible_impl<_Tp, _Arg>>::type::type\n+                    __is_direct_constructible_impl<_Tp, _Arg>>::type\n     { };\n \n   template<typename, typename>\n@@ -736,10 +756,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         >::type>::type __src_t;\n       typedef typename remove_cv<typename remove_reference<_To\n         >::type>::type __dst_t;\n-      typedef typename __and_<\n-        __not_<is_same<__src_t, __dst_t>>,\n-        is_base_of<__src_t, __dst_t>\n-      >::type type;\n+      typedef __and_<__not_<is_same<__src_t, __dst_t>>,\n+\t\t     is_base_of<__src_t, __dst_t>> type;\n       static constexpr bool value = type::value;\n     };\n \n@@ -760,10 +778,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         _From>::type>::type __src_t;\n       typedef typename remove_cv<typename remove_reference<\n         _To>::type>::type __dst_t;\n-      typedef typename __or_<\n-        is_same<__src_t, __dst_t>,\n-        is_base_of<__dst_t, __src_t>\n-      >::type type;\n+      typedef __or_<is_same<__src_t, __dst_t>,\n+\t\t    is_base_of<__dst_t, __src_t>> type;\n       static constexpr bool value = type::value;\n     };\n \n@@ -772,25 +788,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public false_type\n     { };\n \n-  // Here we handle direct-initialization to a reference type\n-  // as equivalent to a static_cast modulo overshooting conversions.\n-  // These are restricted to the following conversion:\n-  //    a) A base class to a derived class reference\n-  //    b) An lvalue-reference to an rvalue-reference\n-\n+  // Here we handle direct-initialization to a reference type as \n+  // equivalent to a static_cast modulo overshooting conversions.\n+  // These are restricted to the following conversions:\n+  //    a) A glvalue of a base class to a derived class reference\n+  //    b) An lvalue to an rvalue-reference of reference-compatible \n+  //       types\n   template<typename _Tp, typename _Arg>\n     struct __is_direct_constructible_ref_cast\n     : public __and_<__is_static_castable<_Arg, _Tp>,\n                     __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,\n                                  __is_lvalue_to_rvalue_ref<_Arg, _Tp>\n-                   >>>::type::type\n+                   >>>::type\n     { };\n \n-  // Direct-initialization is tricky, because of functional\n-  // casts: For a conversion to reference we fall back to a\n-  // static_cast modulo extra cases, otherwise we use a\n-  // new expression:\n-\n   template<typename _Tp, typename _Arg>\n     struct __is_direct_constructible_new\n     : public conditional<is_reference<_Tp>::value,\n@@ -802,9 +813,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp, typename _Arg>\n     struct __is_direct_constructible\n     : public integral_constant<bool, (__is_direct_constructible_new<\n-\t\t\t\t      _Tp, _Arg>::type::value)>\n+\t\t\t\t      _Tp, _Arg>::value)>\n     { };\n \n+  // Since default-construction and binary direct-initialization have\n+  // been handled separately, the implementation of the remaining\n+  // n-ary construction cases is rather straightforward.\n   struct __do_is_nary_constructible_impl\n   {\n     template<typename _Tp, typename... _Args, typename\n@@ -824,9 +838,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp, typename... _Args>\n     struct __is_nary_constructible\n-    : public __and_<is_destructible<_Tp>,\n-\t\t    __is_nary_constructible_impl<_Tp, _Args...>\n-                   >::type::type\n+    : public __is_nary_constructible_impl<_Tp, _Args...>::type\n     {\n       static_assert(sizeof...(_Args) > 1,\n                     \"Only useful for > 1 arguments\");"}, {"sha": "4fa005ecdd6689afa60c00ff42f809b259bf689a", "filename": "libstdc++-v3/testsuite/20_util/declval/requirements/1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7a09d774a2af28c51224404ba47f5f7c182cea/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7a09d774a2af28c51224404ba47f5f7c182cea/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc?ref=2c7a09d774a2af28c51224404ba47f5f7c182cea", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1603 }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1615 }\n \n #include <utility>\n "}, {"sha": "01a2068e6e7ee01e629a432ef755b18f36174869", "filename": "libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7a09d774a2af28c51224404ba47f5f7c182cea/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7a09d774a2af28c51224404ba47f5f7c182cea/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc?ref=2c7a09d774a2af28c51224404ba47f5f7c182cea", "patch": "@@ -48,5 +48,5 @@ void test01()\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 40 }\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1389 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 1353 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1401 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 1365 }"}, {"sha": "7dd19d63127a4db0e7106b96cf8575bc013c94bd", "filename": "libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7a09d774a2af28c51224404ba47f5f7c182cea/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7a09d774a2af28c51224404ba47f5f7c182cea/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc?ref=2c7a09d774a2af28c51224404ba47f5f7c182cea", "patch": "@@ -48,5 +48,5 @@ void test01()\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 40 }\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1313 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 1277 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1325 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 1289 }"}]}