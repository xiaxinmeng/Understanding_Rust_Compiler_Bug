{"sha": "b53fed56360bb38807b13ec7b3c83d34c6b0b81a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUzZmVkNTYzNjBiYjM4ODA3YjEzZWM3YjNjODNkMzRjNmIwYjgxYQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2006-10-24T17:44:36Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2006-10-24T17:44:36Z"}, "message": "re PR middle-end/29335 (transcendental functions with constant arguments should be resolved at compile-time)\n\n\tPR middle-end/29335\n\t* builtins.c (fold_builtin_sin, fold_builtin_atan): Remove.\n\t(do_mpfr_arg1): Add `min', `max' and `inclusive' arguments.\n\tUpdate all callers.\n\t(BUILT_IN_SIN, BUILT_IN_ATAN): Handle in main switch.\n\t(BUILT_IN_ASIN, BUILT_IN_ACOS, BUILT_IN_ATAN, BUILT_IN_ASINH,\n\tBUILT_IN_ACOSH, BUILT_IN_ATANH, BUILT_IN_SINH, BUILT_IN_COSH,\n\tBUILT_IN_TANH): Calculate compile-time arguments using MPFR.\n\ntestsuite:\n\t* gcc.dg/torture/builtin-math-3.c: New test.\n\nFrom-SVN: r118009", "tree": {"sha": "ff3d7f4f7fc07e5db5341f56a39d6422fb73e875", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff3d7f4f7fc07e5db5341f56a39d6422fb73e875"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b53fed56360bb38807b13ec7b3c83d34c6b0b81a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b53fed56360bb38807b13ec7b3c83d34c6b0b81a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b53fed56360bb38807b13ec7b3c83d34c6b0b81a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b53fed56360bb38807b13ec7b3c83d34c6b0b81a/comments", "author": null, "committer": null, "parents": [{"sha": "b9703d9852e08e9b3b52b9d6eba428bbf15d6532", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9703d9852e08e9b3b52b9d6eba428bbf15d6532", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9703d9852e08e9b3b52b9d6eba428bbf15d6532"}], "stats": {"total": 229, "additions": 165, "deletions": 64}, "files": [{"sha": "d47b94b74cce3a99e499319545813c208948f379", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b53fed56360bb38807b13ec7b3c83d34c6b0b81a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b53fed56360bb38807b13ec7b3c83d34c6b0b81a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b53fed56360bb38807b13ec7b3c83d34c6b0b81a", "patch": "@@ -1,3 +1,14 @@\n+2006-10-24  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\tPR middle-end/29335\n+\t* builtins.c (fold_builtin_sin, fold_builtin_atan): Remove.\n+\t(do_mpfr_arg1): Add `min', `max' and `inclusive' arguments.\n+\tUpdate all callers.\n+\t(BUILT_IN_SIN, BUILT_IN_ATAN): Handle in main switch.\n+\t(BUILT_IN_ASIN, BUILT_IN_ACOS, BUILT_IN_ATAN, BUILT_IN_ASINH,\n+\tBUILT_IN_ACOSH, BUILT_IN_ATANH, BUILT_IN_SINH, BUILT_IN_COSH,\n+\tBUILT_IN_TANH): Calculate compile-time arguments using MPFR.\n+\n 2006-10-24  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/28796\n@@ -21,6 +32,7 @@\n \n 2006-10-24  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n+\tPR middle-end/29335\n \t* builtins.c (fold_builtin_exponent): Evaluate constant arguments\n \tat compile-time using MPFR.  Change parameter VALUE to FUNC,\n \tupdate all callers."}, {"sha": "ebb9a857629279099316bdb3289b818baa8aee77", "filename": "gcc/builtins.c", "status": "modified", "additions": 78, "deletions": 64, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b53fed56360bb38807b13ec7b3c83d34c6b0b81a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b53fed56360bb38807b13ec7b3c83d34c6b0b81a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=b53fed56360bb38807b13ec7b3c83d34c6b0b81a", "patch": "@@ -150,10 +150,8 @@ static tree fold_builtin_sqrt (tree, tree);\n static tree fold_builtin_cbrt (tree, tree);\n static tree fold_builtin_pow (tree, tree, tree);\n static tree fold_builtin_powi (tree, tree, tree);\n-static tree fold_builtin_sin (tree, tree);\n static tree fold_builtin_cos (tree, tree, tree);\n static tree fold_builtin_tan (tree, tree);\n-static tree fold_builtin_atan (tree, tree);\n static tree fold_builtin_trunc (tree, tree);\n static tree fold_builtin_floor (tree, tree);\n static tree fold_builtin_ceil (tree, tree);\n@@ -205,7 +203,8 @@ static unsigned HOST_WIDE_INT target_s;\n static char target_percent_c[3];\n static char target_percent_s[3];\n static char target_percent_s_newline[4];\n-static tree do_mpfr_arg1 (tree, tree, int (*)(mpfr_ptr, mpfr_srcptr, mp_rnd_t));\n+static tree do_mpfr_arg1 (tree, tree, int (*)(mpfr_ptr, mpfr_srcptr, mp_rnd_t),\n+\t\t\t  const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *, bool);\n \n /* Return true if NODE should be considered for inline expansion regardless\n    of the optimization level.  This means whenever a function is invoked with\n@@ -7204,23 +7203,6 @@ fold_builtin_cbrt (tree arglist, tree type)\n   return NULL_TREE;\n }\n \n-/* Fold function call to builtin sin, sinf, or sinl.  Return\n-   NULL_TREE if no simplification can be made.  */\n-static tree\n-fold_builtin_sin (tree arglist, tree type)\n-{\n-  tree arg = TREE_VALUE (arglist), res;\n-\n-  if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n-    return NULL_TREE;\n-\n-  /* Calculate the result when the argument is a constant.  */\n-  if ((res = do_mpfr_arg1 (arg, type, mpfr_sin)))\n-    return res;\n-  \n-  return NULL_TREE;\n-}\n-\n /* Fold function call to builtin cos, cosf, or cosl.  Return\n    NULL_TREE if no simplification can be made.  */\n static tree\n@@ -7232,7 +7214,7 @@ fold_builtin_cos (tree arglist, tree type, tree fndecl)\n     return NULL_TREE;\n \n   /* Calculate the result when the argument is a constant.  */\n-  if ((res = do_mpfr_arg1 (arg, type, mpfr_cos)))\n+  if ((res = do_mpfr_arg1 (arg, type, mpfr_cos, NULL, NULL, 0)))\n     return res;\n   \n   /* Optimize cos(-x) into cos (x).  */\n@@ -7258,7 +7240,7 @@ fold_builtin_tan (tree arglist, tree type)\n     return NULL_TREE;\n \n   /* Calculate the result when the argument is a constant.  */\n-  if ((res = do_mpfr_arg1 (arg, type, mpfr_tan)))\n+  if ((res = do_mpfr_arg1 (arg, type, mpfr_tan, NULL, NULL, 0)))\n     return res;\n   \n   /* Optimize tan(atan(x)) = x.  */\n@@ -7272,35 +7254,6 @@ fold_builtin_tan (tree arglist, tree type)\n   return NULL_TREE;\n }\n \n-/* Fold function call to builtin atan, atanf, or atanl.  Return\n-   NULL_TREE if no simplification can be made.  */\n-\n-static tree\n-fold_builtin_atan (tree arglist, tree type)\n-{\n-\n-  tree arg = TREE_VALUE (arglist);\n-\n-  if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n-    return NULL_TREE;\n-\n-  /* Optimize atan(0.0) = 0.0.  */\n-  if (real_zerop (arg))\n-    return arg;\n-\n-  /* Optimize atan(1.0) = pi/4.  */\n-  if (real_onep (arg))\n-    {\n-      REAL_VALUE_TYPE cst;\n-\n-      real_convert (&cst, TYPE_MODE (type), &dconstpi);\n-      SET_REAL_EXP (&cst, REAL_EXP (&cst) - 2);\n-      return build_real (type, cst);\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n /* Fold function call to builtin trunc, truncf or truncl.  Return\n    NULL_TREE if no simplification can be made.  */\n \n@@ -7924,7 +7877,7 @@ fold_builtin_exponent (tree fndecl, tree arglist,\n       tree arg = TREE_VALUE (arglist), res;\n       \n       /* Calculate the result when the argument is a constant.  */\n-      if ((res = do_mpfr_arg1 (arg, type, func)))\n+      if ((res = do_mpfr_arg1 (arg, type, func, NULL, NULL, 0)))\n \treturn res;\n \n       /* Optimize expN(logN(x)) = x.  */\n@@ -9026,12 +8979,72 @@ fold_builtin_1 (tree fndecl, tree arglist, bool ignore)\n     CASE_FLT_FN (BUILT_IN_CBRT):\n       return fold_builtin_cbrt (arglist, type);\n \n+    CASE_FLT_FN (BUILT_IN_ASIN):\n+      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+\treturn do_mpfr_arg1 (TREE_VALUE (arglist), type, mpfr_asin,\n+\t\t\t     &dconstm1, &dconst1, true);\n+    break;\n+\n+    CASE_FLT_FN (BUILT_IN_ACOS):\n+      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+\treturn do_mpfr_arg1 (TREE_VALUE (arglist), type, mpfr_acos,\n+\t\t\t     &dconstm1, &dconst1, true);\n+    break;\n+\n+    CASE_FLT_FN (BUILT_IN_ATAN):\n+      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+\treturn do_mpfr_arg1 (TREE_VALUE (arglist), type, mpfr_atan,\n+\t\t\t     NULL, NULL, 0);\n+    break;\n+\n+    CASE_FLT_FN (BUILT_IN_ASINH):\n+      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+\treturn do_mpfr_arg1 (TREE_VALUE (arglist), type, mpfr_asinh,\n+\t\t\t     NULL, NULL, 0);\n+    break;\n+\n+    CASE_FLT_FN (BUILT_IN_ACOSH):\n+      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+\treturn do_mpfr_arg1 (TREE_VALUE (arglist), type, mpfr_acosh,\n+\t\t\t     &dconst1, NULL, true);\n+    break;\n+\n+    CASE_FLT_FN (BUILT_IN_ATANH):\n+      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+\treturn do_mpfr_arg1 (TREE_VALUE (arglist), type, mpfr_atanh,\n+\t\t\t     &dconstm1, &dconst1, false);\n+    break;\n+\n     CASE_FLT_FN (BUILT_IN_SIN):\n-      return fold_builtin_sin (arglist, type);\n+      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+\treturn do_mpfr_arg1 (TREE_VALUE (arglist), type, mpfr_sin,\n+\t\t\t     NULL, NULL, 0);\n+    break;\n \n     CASE_FLT_FN (BUILT_IN_COS):\n       return fold_builtin_cos (arglist, type, fndecl);\n \n+    CASE_FLT_FN (BUILT_IN_TAN):\n+      return fold_builtin_tan (arglist, type);\n+\n+    CASE_FLT_FN (BUILT_IN_SINH):\n+      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+\treturn do_mpfr_arg1 (TREE_VALUE (arglist), type, mpfr_sinh,\n+\t\t\t     NULL, NULL, 0);\n+    break;\n+\n+    CASE_FLT_FN (BUILT_IN_COSH):\n+      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+\treturn do_mpfr_arg1 (TREE_VALUE (arglist), type, mpfr_cosh,\n+\t\t\t     NULL, NULL, 0);\n+    break;\n+\n+    CASE_FLT_FN (BUILT_IN_TANH):\n+      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+\treturn do_mpfr_arg1 (TREE_VALUE (arglist), type, mpfr_tanh,\n+\t\t\t     NULL, NULL, 0);\n+    break;\n+\n     CASE_FLT_FN (BUILT_IN_EXP):\n       return fold_builtin_exponent (fndecl, arglist, mpfr_exp);\n \n@@ -9051,12 +9064,6 @@ fold_builtin_1 (tree fndecl, tree arglist, bool ignore)\n     CASE_FLT_FN (BUILT_IN_LOG10):\n       return fold_builtin_logarithm (fndecl, arglist, &dconst10);\n \n-    CASE_FLT_FN (BUILT_IN_TAN):\n-      return fold_builtin_tan (arglist, type);\n-\n-    CASE_FLT_FN (BUILT_IN_ATAN):\n-      return fold_builtin_atan (arglist, type);\n-\n     CASE_FLT_FN (BUILT_IN_POW):\n       return fold_builtin_pow (fndecl, arglist, type);\n \n@@ -11269,12 +11276,17 @@ init_target_chars (void)\n \n /* If argument ARG is a REAL_CST, call the one-argument mpfr function\n    FUNC on it and return the resulting value as a tree with type TYPE.\n-   The mpfr precision is set to the precision of TYPE.  We assume that\n-   function FUNC returns zero if the result could be calculated\n-   exactly within the requested precision.  */\n+   If MIN and/or MAX are not NULL, then the supplied ARG must be\n+   within those bounds.  If INCLUSIVE is true, then MIN/MAX are\n+   acceptable values, otherwise they are not.  The mpfr precision is\n+   set to the precision of TYPE.  We assume that function FUNC returns\n+   zero if the result could be calculated exactly within the requested\n+   precision.  */\n \n static tree\n-do_mpfr_arg1 (tree arg, tree type, int (*func)(mpfr_ptr, mpfr_srcptr, mp_rnd_t))\n+do_mpfr_arg1 (tree arg, tree type, int (*func)(mpfr_ptr, mpfr_srcptr, mp_rnd_t),\n+\t      const REAL_VALUE_TYPE *min, const REAL_VALUE_TYPE *max,\n+\t      bool inclusive)\n {\n   tree result = NULL_TREE;\n   \n@@ -11284,7 +11296,9 @@ do_mpfr_arg1 (tree arg, tree type, int (*func)(mpfr_ptr, mpfr_srcptr, mp_rnd_t))\n     {\n       REAL_VALUE_TYPE r = TREE_REAL_CST (arg);\n \n-      if (!real_isnan (&r) && !real_isinf (&r))\n+      if (!real_isnan (&r) && !real_isinf (&r)\n+\t  && (!min || real_compare (inclusive ? GE_EXPR: GT_EXPR , &r, min))\n+\t  && (!max || real_compare (inclusive ? LE_EXPR: LT_EXPR , &r, max)))\n         {\n \t  const enum machine_mode mode = TYPE_MODE (type);\n \t  const int prec = REAL_MODE_FORMAT (mode)->p;"}, {"sha": "97e3f75c6ac3234512f2a022330f412b715870b7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b53fed56360bb38807b13ec7b3c83d34c6b0b81a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b53fed56360bb38807b13ec7b3c83d34c6b0b81a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b53fed56360bb38807b13ec7b3c83d34c6b0b81a", "patch": "@@ -1,3 +1,7 @@\n+2006-10-24  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/torture/builtin-math-3.c: New test.\n+\n 2006-10-24  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \tPR fortran/29393"}, {"sha": "60f030b6e04abb955d681934ae5c6b55c3ea225a", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-3.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b53fed56360bb38807b13ec7b3c83d34c6b0b81a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b53fed56360bb38807b13ec7b3c83d34c6b0b81a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-3.c?ref=b53fed56360bb38807b13ec7b3c83d34c6b0b81a", "patch": "@@ -0,0 +1,71 @@\n+/* Copyright (C) 2006  Free Software Foundation.\n+\n+   Verify that built-in math function constant folding of constant\n+   arguments is correctly performed by the compiler.\n+\n+   Origin: Kaveh R. Ghazi, October 23, 2006.  */\n+\n+/* { dg-do link } */\n+\n+/* All references to link_error should go away at compile-time.  */\n+extern void link_error(int);\n+\n+/* Test that FUNC(ARG) == (RES).  */\n+#define TESTIT(FUNC,ARG,RES) do { \\\n+  if (__builtin_##FUNC##f(ARG) != RES) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC(ARG) != RES) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC##l(ARG) != RES) \\\n+    link_error(__LINE__); \\\n+  } while (0);\n+\n+/* Test that (LOW) < FUNC(ARG) < (HI).  */\n+#define TESTIT2(FUNC,ARG,LOW,HI) do { \\\n+  if (__builtin_##FUNC##f(ARG) <= (LOW) || __builtin_##FUNC##f(ARG) >= (HI)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC(ARG) <= (LOW) || __builtin_##FUNC(ARG) >= (HI)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC##l(ARG) <= (LOW) || __builtin_##FUNC##l(ARG) >= (HI)) \\\n+    link_error(__LINE__); \\\n+  } while (0);\n+\n+int main (void)\n+{\n+  TESTIT2 (asin, -1, -3.15/2, -3.14/2); /* asin(-1) == -pi/2 */\n+  TESTIT (asin, 0, 0); /* asin(0) == 0 */\n+  TESTIT2 (asin, 1, 3.14/2, 3.15/2); /* asin(1) == pi/2 */\n+\n+  TESTIT2 (acos, -1, 3.14, 3.15); /* acos(-1) == pi */\n+  TESTIT2 (acos, 0, 3.14/2, 3.15/2); /* acos(0) == pi/2 */\n+  TESTIT (acos, 1, 0); /* acos(1) == 0 */\n+\n+  TESTIT2 (atan, -1, -3.15/4, -3.14/4); /* atan(-1) == -pi/4 */\n+  TESTIT (atan, 0, 0); /* atan(0) == 0 */\n+  TESTIT2 (atan, 1, 3.14/4, 3.15/4); /* atan(1) == pi/4 */\n+\n+  TESTIT2 (asinh, -1, -0.89, -0.88); /* asinh(-1) == -0.881... */\n+  TESTIT (asinh, 0, 0); /* asinh(0) == 0 */\n+  TESTIT2 (asinh, 1, 0.88, 0.89); /* asinh(1) == 0.881... */\n+\n+  TESTIT (acosh, 1, 0); /* acosh(1) == 0. */\n+  TESTIT2 (acosh, 2, 1.31, 1.32); /* acosh(2) == 1.316... */\n+\n+  TESTIT2 (atanh, -0.5, -0.55, -0.54); /* atanh(-0.5) == -0.549... */\n+  TESTIT (atanh, 0, 0); /* atanh(0) == 0 */\n+  TESTIT2 (atanh, 0.5, 0.54, 0.55); /* atanh(0.5) == 0.549... */\n+\n+  TESTIT2 (sinh, -1, -1.18, -1.17); /* sinh(-1) == -1.175... */\n+  TESTIT (sinh, 0, 0); /* sinh(0) == 0 */\n+  TESTIT2 (sinh, 1, 1.17, 1.18); /* sinh(1) == 1.175... */\n+\n+  TESTIT2 (cosh, -1, 1.54, 1.55); /* cosh(-1) == 1.543... */\n+  TESTIT (cosh, 0, 1); /* cosh(0) == 1 */\n+  TESTIT2 (cosh, 1, 1.54, 1.55); /* cosh(1) == 1.543... */\n+\n+  TESTIT2 (tanh, -1, -0.77, -0.76); /* tanh(-1) == -0.761... */\n+  TESTIT (tanh, 0, 0); /* tanh(0) == 0 */\n+  TESTIT2 (tanh, 1, 0.76, 0.77); /* tanh(1) == 0.761... */\n+\n+  return 0;\n+}"}]}