{"sha": "c885d7a17a4fa12b015adde15326b13303c348bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg4NWQ3YTE3YTRmYTEyYjAxNWFkZGUxNTMyNmIxMzMwM2MzNDhiZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-09-13T10:18:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-09-13T10:18:42Z"}, "message": "[multiple changes]\n\n2004-09-09  Vincent Celier  <celier@gnat.com>\n\n\t* a-direct.ads: Add pragma Ada_05\n\t(Directory_Entry_Type): Give default value to component Kind to avoid\n\tnot initialized warnings.\n\n\t* a-direct.adb (Current_Directory): Remove directory separator at the\n\tend.\n\t(Delete_Directory, Delete_Tree): Raise Name_Error if Directory is not\n\tan existing directory.\n\t(Fetch_Next_Entry): Give default value to variable Kind to avoid warning\n\t(Size (String)): Function C_Size returns Long_Integer, not File_Size.\n\tConvert the result to File_Size.\n\n\t* prj.ads: (Project_Error): New exception\n\n\t* prj-attr.adb: Except in procedure Initialize, Fail comes from\n\tPrj.Com, not from Osint.\n\t(Attrs, Package_Attributes): Tables moved to private part of spec\n\t(Add_Attribute, Add_Unknown_Package): Moved to new child package\n\tPrj.Attr.PM.\n\t(Register_New_Package (Name, Attributes), Register_New_Attribute): Raise\n\tPrj.Project_Error after call to Fail.\n\t(Register_New_Package (Name, Id)): Set Id to Empty_Package after calling\n\tFail. Check that package name is not already in use.\n\n\t* prj-attr.ads: Comment updates to indicate that all subprograms may be\n\tused by tools, not only by the project manager, and to indicate that\n\texception Prj.Prj_Error may be raised in case of problem.\n\t(Add_Unknown_Package, Add_Attribute): Moved to new child package\n\tPrj.Attr.PM.\n\t(Attrs, Package_Attributes): Table instantiations moved from the body to\n\tthe private part to be accessible from Prj.Attr.PM body.\n\n\t* prj-dect.adb (Parse_Package_Declaration): Call Add_Unknown_Package\n\tfrom new package Prj.Attr.PM.\n\t(Parse_Attribute_Declaration): Call Add_Attribute from new package\n\tPrj.Attr.PM.\n\n\t* Makefile.in: Add prj-attr-pm.o to gnatmake object list\n\n\t* gnatbind.adb (Gnatbind): Correct warning message (Elaboration_Check\n\tinstead of Elaboration_Checks).\n\n\t* a-calend.adb: Minor reformatting\n\n2004-09-09  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* gigi.h (maybe_pad_type): New declaration.\n\t(create_subprog_type): New arg RETURNS_BY_TARGET_PTR.\n\n\t* ada-tree.h: (TYPE_RETURNS_BY_TARGET_PTR_P): New macro.\n\n\t* cuintp.c: Convert to use buildN.\n\n\t* decl.c (maybe_pad_type): No longer static.\n\t(gnat_to_gnu_entity, case E_Function): Handle case of returning by\n\ttarget pointer.\n\tConvert to use buildN.\n\n\t* trans.c (call_to_gnu): Add arg GNU_TARGET; support\n\tTYPE_RETURNS_BY_TARGET_PTR_P.  All callers changed.\n\t(gnat_to_gnu, case N_Assignment_Statement): Call call_to_gnu if call on\n\tRHS.\n\t(gnat_to_gnu, case N_Return): Handle TYPE_RETURN_BY_TARGET_PTR_P.\n\t(gnat_gimplify_expr, case ADDR_EXPR): New case.\n\tConvert to use buildN.\n\n\t* utils2.c (gnat_build_constructor): Also set TREE_INVARIANT and\n\tTREE_READONLY for const.\n\tConvert to use buildN.\n\n\t* utils.c (create_subprog_type): New operand RETURNS_BY_TARGET_PTR.\n\t(create_var_decl): Refine when TREE_STATIC is set.\n\tConvert to use buildN.\n\n2004-09-09  Gary Dismukes  <dismukes@gnat.com>\n\n\t* gnat_ugn.texi: Delete text relating to checking of ali and object\n\tconsistency.\n\n\t* a-except.adb (Rcheck_*): Add pragmas No_Return for each of these\n\troutines.\n\n2004-09-09  Jose Ruiz  <ruiz@act-europe.fr>\n\n\t* gnat_ugn.texi: Add Detect_Blocking to the list of configuration\n\tpragmas recognized by GNAT.\n\n\t* gnat_rm.texi: Document pragma Detect_Blocking.\n\n\t* s-solita.adb (Timed_Delay_T): When pragma Detect_Blocking is active,\n\traise Program_Error if called from a protected operation.\n\n\t* s-taprob.adb (Lock): When pragma Detect_Blocking is active increase\n\tthe protected action nesting level.\n\t(Lock_Read_Only): When pragma Detect_Blocking is active increase the\n\tprotected action nesting level.\n\t(Unlock): When pragma Detect_Blocking is active decrease the protected\n\taction nesting level.\n\n\t* s-taskin.adb (Initialize_ATCB): Initialize to 0 the\n\tProtected_Action_Nesting.\n\n\t* s-taskin.ads: Adding the field Protected_Action_Nesting to the\n\tCommon_ATCB record. It contains the dynamic level of protected action\n\tnesting for each task. It is needed for checking whether potentially\n\tblocking operations are called from protected operations.\n\t(Detect_Blocking): Adding a Boolean constant reflecting whether pragma\n\tDetect_Blocking is active or not in the partition.\n\n\t* s-tasren.adb (Call_Simple): When pragma Detect_Blocking is active,\n\traise Program_Error if called from a protected operation.\n\t(Task_Entry_Call): When pragma Detect_Blocking is active, raise\n\tProgram_Error if called from a protected operation.\n\t(Timed_Task_Entry_Call): When pragma Detect_Blocking is active, raise\n\tProgram_Error if called from a protected operation.\n\n\t* s-tassta.adb (Abort_Tasks): When pragma Detect_Blocking is active,\n\traise Program_Error if called from a protected operation.\n\n\t* s-tpoben.adb (Lock_Entries): When pragma Detect_Blocking is active,\n\traise Program_Error if called from a protected operation, and increase\n\tthe protected action nesting level.\n\t(Lock_Read_Only_Entries): When pragma Detect_Blocking is active, raise\n\tProgram_Error if called from a protected operation, and increase the\n\tprotected action nesting level.\n\t(Unlock_Entries): When pragma Detect_Blocking is active decrease the\n\tprotected action nesting level.\n\n\t* s-tposen.adb (Lock_Entry): When pragma Detect_Blocking is active,\n\traise Program_Error if called from a protected operation, and increase\n\tthe protected action nesting level.\n\t(Lock_Read_Only_Entry): When pragma Detect_Blocking is active, raise\n\tProgram_Error if called from a protected operation, and increase the\n\tprotected action nesting level.\n\t(Protected_Single_Entry_Call): When pragma Detect_Blocking is active,\n\traise Program_Error if called from a protected operation.\n\t(Timed_Protected_Single_Entry_Call): When pragma Detect_Blocking is\n\tactive, raise Program_Error if called from a protected operation.\n\t(Unlock_Entry): When pragma Detect_Blocking is active decrease the\n\tprotected action nesting level.\n\n\t* sem_util.adb (Check_Potentially_Blocking_Operation): Remove the\n\tinsertion of the statement raising Program_Error. The run time\n\tcontains the required machinery for handling that.\n\n\t* sem_util.ads: Change comment associated to procedure\n\tCheck_Potentially_Blocking_Operation.\n\tThis procedure does not insert a call for raising the exception because\n\tthat is currently done by the run time.\n\n\t* raise.h (__gnat_set_globals): Pass the detect_blocking parameter.\n\n\t* init.c: Add the global variable __gl_detect_blocking that indicates\n\twhether pragma Detect_Blocking is active (1) or not (0). Needed for\n\tmaking the pragma available at run time.\n\t(__gnat_set_globals): Pass and update the detect_blocking parameter.\n\n\t* lib-writ.adb (Write_ALI): Set the DB flag in the ali file if\n\tpragma Detect_Blocking is active.\n\n\t* lib-writ.ads: Document the Detect_Blocking flag (DB) in ali files.\n\n\t* ali.adb (Scan_ALI): Set the Detect_Blocking value to true if the flag\n\tDB is found in the ali file. Any unit compiled with pragma\n\tDetect_Blocking active forces its effect in the whole partition.\n\n\t* a-retide.adb (Delay_Until): Raise Program_Error if pragma\n\tDetect_Blocking is active and delay is called from a protected\n\toperation.\n\n\t* bindgen.adb (Gen_Adainit_Ada): When generating the call to\n\t__gnat_set_globals, pass 1 as Detect_Blocking parameter if pragma\n\tDetect_Blocking is active (0 otherwise).\n\t(Gen_Adainit_C): When generating the call to __gnat_set_globals, pass 1\n\tas Detect_Blocking parameter if pragma Detect_Blocking is active (0\n\totherwise).\n\n2004-09-09  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* gnat_rm.texi: Rename GNAT.Perfect_Hash.Generators to\n\tGNAT.Perfect_Hash_Generators, and remove the empty GNAT.Perfect_Hash\n\tpackage.\n\n\t* s-parint.ads, s-parint.adb (Get_RAS_Info): New subprogram.\n\t(Register_Receiving_Stub): Add Subp_Info formal parameter.\n\tUpdate API in placeholder implemetation of s-parint to reflect changes\n\tin distribution runtime library.\n\n\t* sem_ch3.adb (Expand_Derived_Record): Rename to\n\tExpand_Record_Extension.\n\n\t* sem_disp.adb (Check_Controlling_Formals): Improve error message for\n\tprimitive operations of potentially distributed object types that have\n\tnon-controlling anonymous access formals.\n\n\t* sem_dist.ads, sem_dist.adb (Build_RAS_Primitive_Specification): New\n\tsubprogram.\n\tNew implementation of expansion for remote access-to-subprogram types,\n\tbased on the RACW infrastructure.\n\tThis version of sem_dist is compatible with PolyORB/DSA as well as\n\tGLADE.\n\n\t* sem_prag.adb (Analyze_Pragma, case Pragma_Asynchronous): For a pragma\n\tAsynchrronous that applies to a remote access-to-subprogram type, mark\n\tthe underlying RACW type as asynchronous.\n\n\t* link.c: FreeBSD uses GNU ld: set __gnat_objlist_file_supported and\n\t __gnat_using_gnu_linker to 1.\n\n\t* Makefile.rtl, impunit.adb, g-perhas.ads, g-pehage.ads,\n\tg-pehage.adb: Rename GNAT.Perfect_Hash.Generators to\n\tGNAT.Perfect_Hash_Generators, and remove the empty\n\tGNAT.Perfect_Hash package.\n\n\t* atree.adb: Minor reformatting\n\n\t* exp_ch3.adb (Expand_Derived_Record): Rename to\n\tExpand_Record_Extension.\n\t(Build_Record_Init_Proc.Build_Assignment): The default expression in\n\ta component declaration must remain attached at that point in the\n\ttree so New_Copy_Tree copies it if the enclosing record type is derived.\n\tIt is therefore necessary to take a copy of the expression when building\n\tthe corresponding assignment statement in the init proc.\n\tAs a side effect, in the case of a derived record type, we now see the\n\toriginal expression, without any rewriting that could have occurred\n\tduring expansion of the ancestor type's init proc, and we do not need\n\tto go back to Original_Node.\n\n\t* exp_ch3.ads (Expand_Derived_Record): Rename to\n\tExpand_Record_Extension.\n\n\t* exp_dist.ads, exp_dist.adb (Underlying_RACW_Type): New subprogram.\n\tReturns the RACW type used to implement a remote access-to-subprogram\n\ttype.\n\t(Add_RAS_Proxy_And_Analyze, Build_Remote_Subprogram_Proxy_Type):\n\tNew subprograms. Used to create a proxy tagged object for a remote\n\tsubprogram. The proxy object is used as the designated object\n\tfor RAS values on the same partition (unless All_Calls_Remote applies).\n\t(Build_Get_Unique_RP_Call): New subprogram. Build a call to\n\tSystem.Partition_Interface.Get_Unique_Remote_Pointer.\n\t(Add_RAS_Access_TSS, Add_RAS_Dereference_TSS):\n\tRenamed from Add_RAS_*_Attribute.\n\t(Add_Receiving_Stubs_To_Declarations): Generate a table of local\n\tsubprograms.\n\tNew implementation of expansion for remote access-to-subprogram types,\n\tbased on the RACW infrastructure.\n\n\t* exp_dist.ads (Copy_Specification): Update comment to note that this\n\tfunction can copy the specification from either a subprogram\n\tspecification or an access-to-subprogram type definition.\n\n2004-09-09  Ed Schonberg  <schonberg@gnat.com>\n\n\t* sem_type.adb (Disambiguate): Handle properly an accidental ambiguity\n\tin an instance, between an explicit subprogram an one inherited from a\n\ttype derived from an actual.\n\n\t* exp_ch6.adb (Expand_N_Subprogram_Body): If polling is enabled, do not\n\tadd a polling call if the subprogram is to be inlined by the back-end,\n\tto avoid repeated calls with multiple inlinings.\n\n\t* checks.adb (Apply_Alignment_Check): If the expression in the address\n\tclause is a call whose name is not a static entity (e.g. a dispatching\n\tcall), treat as dynamic.\n\n2004-09-09  Robert Dewar  <dewar@gnat.com>\n\n\t* g-trasym.ads: Minor reformatting\n\n\t* exp_ch3.adb (Component_Needs_Simple_Initialization): Don't except\n\tpacked arrays, since unused bits are expected to be zero for a\n\tcomparison.\n\n2004-09-09  Eric Botcazou  <ebotcazou@act-europe.fr>\n\n\t* exp_pakd.ads: Fix an inacurracy and a couple of typos in the head\n\tcomment.\n\n2004-09-09  Pascal Obry  <obry@gnat.com>\n\n\t* mdll.ads, mdll.adb (Build_Dynamic_Library): New parameter Map_File to\n\tenable map file generation. Add the right option to generate the map\n\tfile if Map_File is set to True.\n\n\t* gnatdll.adb (Gen_Map_File): New variable.\n\t(Syntax): Add info about new -m (Map_File) option.\n\t(Parse_Command_Line): Add support for -m option.\n\t(gnatdll): Pass Gen_Map_File to Build_Dynamic_Library calls.\n\tMinor reformatting.\n\n2004-09-09  Laurent Pautet  <pautet@act-europe.fr>\n\n\t* gnatls.adb: Add a very verbose mode -V. Such mode is required by the\n\tnew gnatdist implementation.\n\tDefine a subpackage isolating the output routines specific to this\n\tverbose mode.\n\n2004-09-09  Joel Brobecker  <brobecker@gnat.com>\n\n\t* Makefile.rtl: (GNATRTL_NONTASKING_OBJS): Add g-dynhta.\n\n\t* gnat_ugn.texi (Main Subprograms): Fix typo. Deduced, not deducted.\n\n2004-09-09  Cyrille Comar  <comar@act-europe.fr>\n\n\t* opt.adb (Set_Opt_Config_Switches): Use Ada_Version_Runtime to compile\n\tinternal unit.\n\n\t* opt.ads: Add Ada_Version_Runtime constant used to decide which\n\tversion of the language is used to compile the run time.\n\n2004-09-09  Arnaud Charlet  <charlet@act-europe.fr>\n\n\t* sem_util.adb (Requires_Transient_Scope): Re-enable handling\n\tof variable length temporaries for function return now that the\n\tback-end and gigi support it.\n\nFrom-SVN: r87435", "tree": {"sha": "b660d80503dd74c8b52af273fa1a7b3c2af763e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b660d80503dd74c8b52af273fa1a7b3c2af763e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c885d7a17a4fa12b015adde15326b13303c348bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c885d7a17a4fa12b015adde15326b13303c348bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c885d7a17a4fa12b015adde15326b13303c348bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c885d7a17a4fa12b015adde15326b13303c348bd/comments", "author": null, "committer": null, "parents": [{"sha": "c892972fa7c999bf2cb6379d19265be42a974692", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c892972fa7c999bf2cb6379d19265be42a974692", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c892972fa7c999bf2cb6379d19265be42a974692"}], "stats": {"total": 5358, "additions": 3658, "deletions": 1700}, "files": [{"sha": "c824ae6d9ffdc17d99781e89d0a416747d6ac6d4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -1,3 +1,322 @@\n+2004-09-09  Vincent Celier  <celier@gnat.com>\n+\n+\t* a-direct.ads: Add pragma Ada_05\n+\t(Directory_Entry_Type): Give default value to component Kind to avoid\n+\tnot initialized warnings.\n+\n+\t* a-direct.adb (Current_Directory): Remove directory separator at the\n+\tend.\n+\t(Delete_Directory, Delete_Tree): Raise Name_Error if Directory is not\n+\tan existing directory.\n+\t(Fetch_Next_Entry): Give default value to variable Kind to avoid warning\n+\t(Size (String)): Function C_Size returns Long_Integer, not File_Size.\n+\tConvert the result to File_Size.\n+\n+\t* prj.ads: (Project_Error): New exception\n+\n+\t* prj-attr.adb: Except in procedure Initialize, Fail comes from\n+\tPrj.Com, not from Osint.\n+\t(Attrs, Package_Attributes): Tables moved to private part of spec\n+\t(Add_Attribute, Add_Unknown_Package): Moved to new child package\n+\tPrj.Attr.PM.\n+\t(Register_New_Package (Name, Attributes), Register_New_Attribute): Raise\n+\tPrj.Project_Error after call to Fail.\n+\t(Register_New_Package (Name, Id)): Set Id to Empty_Package after calling\n+\tFail. Check that package name is not already in use.\n+\n+\t* prj-attr.ads: Comment updates to indicate that all subprograms may be\n+\tused by tools, not only by the project manager, and to indicate that\n+\texception Prj.Prj_Error may be raised in case of problem.\n+\t(Add_Unknown_Package, Add_Attribute): Moved to new child package\n+\tPrj.Attr.PM.\n+\t(Attrs, Package_Attributes): Table instantiations moved from the body to\n+\tthe private part to be accessible from Prj.Attr.PM body.\n+\n+\t* prj-dect.adb (Parse_Package_Declaration): Call Add_Unknown_Package\n+\tfrom new package Prj.Attr.PM.\n+\t(Parse_Attribute_Declaration): Call Add_Attribute from new package\n+\tPrj.Attr.PM.\n+\n+\t* Makefile.in: Add prj-attr-pm.o to gnatmake object list\n+\n+\t* gnatbind.adb (Gnatbind): Correct warning message (Elaboration_Check\n+\tinstead of Elaboration_Checks).\n+\n+\t* a-calend.adb: Minor reformatting\n+\n+2004-09-09  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* gigi.h (maybe_pad_type): New declaration.\n+\t(create_subprog_type): New arg RETURNS_BY_TARGET_PTR.\n+\n+\t* ada-tree.h: (TYPE_RETURNS_BY_TARGET_PTR_P): New macro.\n+\n+\t* cuintp.c: Convert to use buildN.\n+\n+\t* decl.c (maybe_pad_type): No longer static.\n+\t(gnat_to_gnu_entity, case E_Function): Handle case of returning by\n+\ttarget pointer.\n+\tConvert to use buildN.\n+\n+\t* trans.c (call_to_gnu): Add arg GNU_TARGET; support\n+\tTYPE_RETURNS_BY_TARGET_PTR_P.  All callers changed.\n+\t(gnat_to_gnu, case N_Assignment_Statement): Call call_to_gnu if call on\n+\tRHS.\n+\t(gnat_to_gnu, case N_Return): Handle TYPE_RETURN_BY_TARGET_PTR_P.\n+\t(gnat_gimplify_expr, case ADDR_EXPR): New case.\n+\tConvert to use buildN.\n+\n+\t* utils2.c (gnat_build_constructor): Also set TREE_INVARIANT and\n+\tTREE_READONLY for const.\n+\tConvert to use buildN.\n+\n+\t* utils.c (create_subprog_type): New operand RETURNS_BY_TARGET_PTR.\n+\t(create_var_decl): Refine when TREE_STATIC is set.\n+\tConvert to use buildN.\n+\n+2004-09-09  Gary Dismukes  <dismukes@gnat.com>\n+\n+\t* gnat_ugn.texi: Delete text relating to checking of ali and object\n+\tconsistency.\n+\n+\t* a-except.adb (Rcheck_*): Add pragmas No_Return for each of these\n+\troutines.\n+\n+2004-09-09  Jose Ruiz  <ruiz@act-europe.fr>\n+\n+\t* gnat_ugn.texi: Add Detect_Blocking to the list of configuration\n+\tpragmas recognized by GNAT.\n+\n+\t* gnat_rm.texi: Document pragma Detect_Blocking.\n+\n+\t* s-solita.adb (Timed_Delay_T): When pragma Detect_Blocking is active,\n+\traise Program_Error if called from a protected operation.\n+\n+\t* s-taprob.adb (Lock): When pragma Detect_Blocking is active increase\n+\tthe protected action nesting level.\n+\t(Lock_Read_Only): When pragma Detect_Blocking is active increase the\n+\tprotected action nesting level.\n+\t(Unlock): When pragma Detect_Blocking is active decrease the protected\n+\taction nesting level.\n+\n+\t* s-taskin.adb (Initialize_ATCB): Initialize to 0 the\n+\tProtected_Action_Nesting.\n+\n+\t* s-taskin.ads: Adding the field Protected_Action_Nesting to the\n+\tCommon_ATCB record. It contains the dynamic level of protected action\n+\tnesting for each task. It is needed for checking whether potentially\n+\tblocking operations are called from protected operations.\n+\t(Detect_Blocking): Adding a Boolean constant reflecting whether pragma\n+\tDetect_Blocking is active or not in the partition.\n+\n+\t* s-tasren.adb (Call_Simple): When pragma Detect_Blocking is active,\n+\traise Program_Error if called from a protected operation.\n+\t(Task_Entry_Call): When pragma Detect_Blocking is active, raise\n+\tProgram_Error if called from a protected operation.\n+\t(Timed_Task_Entry_Call): When pragma Detect_Blocking is active, raise\n+\tProgram_Error if called from a protected operation.\n+\n+\t* s-tassta.adb (Abort_Tasks): When pragma Detect_Blocking is active,\n+\traise Program_Error if called from a protected operation.\n+\n+\t* s-tpoben.adb (Lock_Entries): When pragma Detect_Blocking is active,\n+\traise Program_Error if called from a protected operation, and increase\n+\tthe protected action nesting level.\n+\t(Lock_Read_Only_Entries): When pragma Detect_Blocking is active, raise\n+\tProgram_Error if called from a protected operation, and increase the\n+\tprotected action nesting level.\n+\t(Unlock_Entries): When pragma Detect_Blocking is active decrease the\n+\tprotected action nesting level.\n+\n+\t* s-tposen.adb (Lock_Entry): When pragma Detect_Blocking is active,\n+\traise Program_Error if called from a protected operation, and increase\n+\tthe protected action nesting level.\n+\t(Lock_Read_Only_Entry): When pragma Detect_Blocking is active, raise\n+\tProgram_Error if called from a protected operation, and increase the\n+\tprotected action nesting level.\n+\t(Protected_Single_Entry_Call): When pragma Detect_Blocking is active,\n+\traise Program_Error if called from a protected operation.\n+\t(Timed_Protected_Single_Entry_Call): When pragma Detect_Blocking is\n+\tactive, raise Program_Error if called from a protected operation.\n+\t(Unlock_Entry): When pragma Detect_Blocking is active decrease the\n+\tprotected action nesting level.\n+\n+\t* sem_util.adb (Check_Potentially_Blocking_Operation): Remove the\n+\tinsertion of the statement raising Program_Error. The run time\n+\tcontains the required machinery for handling that.\n+\n+\t* sem_util.ads: Change comment associated to procedure\n+\tCheck_Potentially_Blocking_Operation.\n+\tThis procedure does not insert a call for raising the exception because\n+\tthat is currently done by the run time.\n+\n+\t* raise.h (__gnat_set_globals): Pass the detect_blocking parameter.\n+\n+\t* init.c: Add the global variable __gl_detect_blocking that indicates\n+\twhether pragma Detect_Blocking is active (1) or not (0). Needed for\n+\tmaking the pragma available at run time.\n+\t(__gnat_set_globals): Pass and update the detect_blocking parameter.\n+\n+\t* lib-writ.adb (Write_ALI): Set the DB flag in the ali file if\n+\tpragma Detect_Blocking is active.\n+\n+\t* lib-writ.ads: Document the Detect_Blocking flag (DB) in ali files.\n+\n+\t* ali.adb (Scan_ALI): Set the Detect_Blocking value to true if the flag\n+\tDB is found in the ali file. Any unit compiled with pragma\n+\tDetect_Blocking active forces its effect in the whole partition.\n+\n+\t* a-retide.adb (Delay_Until): Raise Program_Error if pragma\n+\tDetect_Blocking is active and delay is called from a protected\n+\toperation.\n+\n+\t* bindgen.adb (Gen_Adainit_Ada): When generating the call to\n+\t__gnat_set_globals, pass 1 as Detect_Blocking parameter if pragma\n+\tDetect_Blocking is active (0 otherwise).\n+\t(Gen_Adainit_C): When generating the call to __gnat_set_globals, pass 1\n+\tas Detect_Blocking parameter if pragma Detect_Blocking is active (0\n+\totherwise).\n+\n+2004-09-09  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* gnat_rm.texi: Rename GNAT.Perfect_Hash.Generators to\n+\tGNAT.Perfect_Hash_Generators, and remove the empty GNAT.Perfect_Hash\n+\tpackage.\n+\n+\t* s-parint.ads, s-parint.adb (Get_RAS_Info): New subprogram.\n+\t(Register_Receiving_Stub): Add Subp_Info formal parameter.\n+\tUpdate API in placeholder implemetation of s-parint to reflect changes\n+\tin distribution runtime library.\n+\n+\t* sem_ch3.adb (Expand_Derived_Record): Rename to\n+\tExpand_Record_Extension.\n+\n+\t* sem_disp.adb (Check_Controlling_Formals): Improve error message for\n+\tprimitive operations of potentially distributed object types that have\n+\tnon-controlling anonymous access formals.\n+\n+\t* sem_dist.ads, sem_dist.adb (Build_RAS_Primitive_Specification): New\n+\tsubprogram.\n+\tNew implementation of expansion for remote access-to-subprogram types,\n+\tbased on the RACW infrastructure.\n+\tThis version of sem_dist is compatible with PolyORB/DSA as well as\n+\tGLADE.\n+\n+\t* sem_prag.adb (Analyze_Pragma, case Pragma_Asynchronous): For a pragma\n+\tAsynchrronous that applies to a remote access-to-subprogram type, mark\n+\tthe underlying RACW type as asynchronous.\n+\n+\t* link.c: FreeBSD uses GNU ld: set __gnat_objlist_file_supported and\n+\t __gnat_using_gnu_linker to 1.\n+\n+\t* Makefile.rtl, impunit.adb, g-perhas.ads, g-pehage.ads,\n+\tg-pehage.adb: Rename GNAT.Perfect_Hash.Generators to\n+\tGNAT.Perfect_Hash_Generators, and remove the empty\n+\tGNAT.Perfect_Hash package.\n+\n+\t* atree.adb: Minor reformatting\n+\n+\t* exp_ch3.adb (Expand_Derived_Record): Rename to\n+\tExpand_Record_Extension.\n+\t(Build_Record_Init_Proc.Build_Assignment): The default expression in\n+\ta component declaration must remain attached at that point in the\n+\ttree so New_Copy_Tree copies it if the enclosing record type is derived.\n+\tIt is therefore necessary to take a copy of the expression when building\n+\tthe corresponding assignment statement in the init proc.\n+\tAs a side effect, in the case of a derived record type, we now see the\n+\toriginal expression, without any rewriting that could have occurred\n+\tduring expansion of the ancestor type's init proc, and we do not need\n+\tto go back to Original_Node.\n+\n+\t* exp_ch3.ads (Expand_Derived_Record): Rename to\n+\tExpand_Record_Extension.\n+\n+\t* exp_dist.ads, exp_dist.adb (Underlying_RACW_Type): New subprogram.\n+\tReturns the RACW type used to implement a remote access-to-subprogram\n+\ttype.\n+\t(Add_RAS_Proxy_And_Analyze, Build_Remote_Subprogram_Proxy_Type):\n+\tNew subprograms. Used to create a proxy tagged object for a remote\n+\tsubprogram. The proxy object is used as the designated object\n+\tfor RAS values on the same partition (unless All_Calls_Remote applies).\n+\t(Build_Get_Unique_RP_Call): New subprogram. Build a call to\n+\tSystem.Partition_Interface.Get_Unique_Remote_Pointer.\n+\t(Add_RAS_Access_TSS, Add_RAS_Dereference_TSS):\n+\tRenamed from Add_RAS_*_Attribute.\n+\t(Add_Receiving_Stubs_To_Declarations): Generate a table of local\n+\tsubprograms.\n+\tNew implementation of expansion for remote access-to-subprogram types,\n+\tbased on the RACW infrastructure.\n+\n+\t* exp_dist.ads (Copy_Specification): Update comment to note that this\n+\tfunction can copy the specification from either a subprogram\n+\tspecification or an access-to-subprogram type definition.\n+\n+2004-09-09  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_type.adb (Disambiguate): Handle properly an accidental ambiguity\n+\tin an instance, between an explicit subprogram an one inherited from a\n+\ttype derived from an actual.\n+\n+\t* exp_ch6.adb (Expand_N_Subprogram_Body): If polling is enabled, do not\n+\tadd a polling call if the subprogram is to be inlined by the back-end,\n+\tto avoid repeated calls with multiple inlinings.\n+\n+\t* checks.adb (Apply_Alignment_Check): If the expression in the address\n+\tclause is a call whose name is not a static entity (e.g. a dispatching\n+\tcall), treat as dynamic.\n+\n+2004-09-09  Robert Dewar  <dewar@gnat.com>\n+\n+\t* g-trasym.ads: Minor reformatting\n+\n+\t* exp_ch3.adb (Component_Needs_Simple_Initialization): Don't except\n+\tpacked arrays, since unused bits are expected to be zero for a\n+\tcomparison.\n+\n+2004-09-09  Eric Botcazou  <ebotcazou@act-europe.fr>\n+\n+\t* exp_pakd.ads: Fix an inacurracy and a couple of typos in the head\n+\tcomment.\n+\n+2004-09-09  Pascal Obry  <obry@gnat.com>\n+\n+\t* mdll.ads, mdll.adb (Build_Dynamic_Library): New parameter Map_File to\n+\tenable map file generation. Add the right option to generate the map\n+\tfile if Map_File is set to True.\n+\n+\t* gnatdll.adb (Gen_Map_File): New variable.\n+\t(Syntax): Add info about new -m (Map_File) option.\n+\t(Parse_Command_Line): Add support for -m option.\n+\t(gnatdll): Pass Gen_Map_File to Build_Dynamic_Library calls.\n+\tMinor reformatting.\n+\n+2004-09-09  Laurent Pautet  <pautet@act-europe.fr>\n+\n+\t* gnatls.adb: Add a very verbose mode -V. Such mode is required by the\n+\tnew gnatdist implementation.\n+\tDefine a subpackage isolating the output routines specific to this\n+\tverbose mode.\n+\n+2004-09-09  Joel Brobecker  <brobecker@gnat.com>\n+\n+\t* Makefile.rtl: (GNATRTL_NONTASKING_OBJS): Add g-dynhta.\n+\n+\t* gnat_ugn.texi (Main Subprograms): Fix typo. Deduced, not deducted.\n+\n+2004-09-09  Cyrille Comar  <comar@act-europe.fr>\n+\n+\t* opt.adb (Set_Opt_Config_Switches): Use Ada_Version_Runtime to compile\n+\tinternal unit.\n+\n+\t* opt.ads: Add Ada_Version_Runtime constant used to decide which\n+\tversion of the language is used to compile the run time.\n+\n+2004-09-09  Arnaud Charlet  <charlet@act-europe.fr>\n+\n+\t* sem_util.adb (Requires_Transient_Scope): Re-enable handling\n+\tof variable length temporaries for function return now that the\n+\tback-end and gigi support it.\n+\n 2004-09-01  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* misc.c (gnat_print_type): Use TYPE_RM_SIZE_NUM."}, {"sha": "1dba67473a36d396982026cd29928f4444977ecd", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -308,7 +308,7 @@ GNATMAKE_OBJS = a-except.o ctrl_c.o ali.o ali-util.o s-casuti.o \\\n  gnatmake.o gnatvsn.o hostparm.o interfac.o i-c.o i-cstrin.o krunch.o lib.o \\\n  make.o makeusg.o makeutl.o mlib.o mlib-fil.o mlib-prj.o mlib-tgt.o mlib-utl.o \\\n  namet.o nlists.o opt.o osint.o osint-m.o output.o \\\n- prj.o prj-attr.o prj-com.o prj-dect.o prj-env.o prj-err.o prj-ext.o prj-nmsc.o \\\n+ prj.o prj-attr.o prj-attr-pm.o prj-com.o prj-dect.o prj-env.o prj-err.o prj-ext.o prj-nmsc.o \\\n  prj-pars.o prj-part.o prj-proc.o prj-strt.o prj-tree.o prj-util.o \\\n  rident.o s-exctab.o s-secsta.o s-stalib.o s-stoele.o \\\n  scans.o scng.o sdefault.o sfn_scan.o s-purexc.o s-htable.o \\"}, {"sha": "4c01553fe50a7050f30901fd73478434994eb4cf", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -219,6 +219,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-diopit$(objext) \\\n   g-dirope$(objext) \\\n   g-dyntab$(objext) \\\n+  g-dynhta$(objext) \\\n   g-except$(objext) \\\n   g-excact$(objext) \\\n   g-exctra$(objext) \\\n@@ -235,7 +236,6 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-memdum$(objext) \\\n   g-moreex$(objext) \\\n   g-os_lib$(objext) \\\n-  g-perhas$(objext) \\\n   g-pehage$(objext) \\\n   g-regexp$(objext) \\\n   g-regpat$(objext) \\"}, {"sha": "e5788a473e2ed6acc7cdfb3e986a7d8735774cb5", "filename": "gcc/ada/a-calend.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fa-calend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fa-calend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -417,7 +417,7 @@ package body Ada.Calendar is\n       end if;\n \n       --  Check for Day value too large (one might expect mktime to do this\n-      --  check, as well as the basi checks we did with 'Valid, but it seems\n+      --  check, as well as the basic checks we did with 'Valid, but it seems\n       --  that at least on some systems, this built-in check is too weak).\n \n       if Day > Days_In_Month (Month)"}, {"sha": "db0a9317c752cce50c7529ac31e54f91da0e53a2", "filename": "gcc/ada/a-direct.adb", "status": "modified", "additions": 51, "deletions": 30, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fa-direct.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fa-direct.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direct.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -38,22 +38,25 @@ with Ada.Unchecked_Deallocation;\n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n with GNAT.OS_Lib;               use GNAT.OS_Lib;\n with GNAT.Regexp;               use GNAT.Regexp;\n+--  ??? Ada units cannot depend on GNAT units\n \n with System;\n \n package body Ada.Directories is\n \n    type Search_Data is record\n-      Is_Valid : Boolean := False;\n-      Name     : Ada.Strings.Unbounded.Unbounded_String;\n-      Pattern  : Regexp;\n-      Filter   : Filter_Type;\n-      Dir      : Dir_Type;\n+      Is_Valid      : Boolean := False;\n+      Name          : Ada.Strings.Unbounded.Unbounded_String;\n+      Pattern       : Regexp;\n+      Filter        : Filter_Type;\n+      Dir           : Dir_Type;\n       Entry_Fetched : Boolean := False;\n       Dir_Entry     : Directory_Entry_Type;\n    end record;\n+   --  Comment required ???\n \n    Empty_String : constant String := (1 .. 0 => ASCII.NUL);\n+   --  Comment required ???\n \n    procedure Free is new Ada.Unchecked_Deallocation (Search_Data, Search_Ptr);\n \n@@ -97,9 +100,8 @@ package body Ada.Directories is\n       Name                 : String;\n       Extension            : String := \"\") return String\n    is\n-      Result : String (1 ..\n-                         Containing_Directory'Length +\n-                         Name'Length + Extension'Length + 2);\n+      Result : String (1 .. Containing_Directory'Length +\n+                              Name'Length + Extension'Length + 2);\n       Last   : Natural;\n \n    begin\n@@ -205,9 +207,9 @@ package body Ada.Directories is\n    begin\n       --  First, the invalid cases\n \n-      if (not Is_Valid_Path_Name (Source_Name)) or else\n-        (not Is_Valid_Path_Name (Target_Name)) or else\n-        (not Is_Regular_File (Source_Name))\n+      if not Is_Valid_Path_Name (Source_Name)\n+        or else not Is_Valid_Path_Name (Target_Name)\n+        or else not Is_Regular_File (Source_Name)\n       then\n          raise Name_Error;\n \n@@ -328,10 +330,17 @@ package body Ada.Directories is\n    -----------------------\n \n    function Current_Directory return String is\n-   begin\n+\n       --  The implementation uses GNAT.Directory_Operations.Get_Current_Dir\n \n-      return Get_Current_Dir;\n+      Cur : constant String := Get_Current_Dir;\n+\n+   begin\n+      if Cur'Length > 1 and then Cur (Cur'Last) = Dir_Separator then\n+         return Cur (1 .. Cur'Last - 1);\n+      else\n+         return Cur;\n+      end if;\n    end Current_Directory;\n \n    ----------------------\n@@ -340,11 +349,14 @@ package body Ada.Directories is\n \n    procedure Delete_Directory (Directory : String) is\n    begin\n-      --  First, the invalid case\n+      --  First, the invalid cases\n \n       if not Is_Valid_Path_Name (Directory) then\n          raise Name_Error;\n \n+      elsif not Is_Directory (Directory) then\n+         raise Name_Error;\n+\n       else\n          --  The implementation uses GNAT.Directory_Operations.Remove_Dir\n \n@@ -391,11 +403,14 @@ package body Ada.Directories is\n \n    procedure Delete_Tree (Directory : String) is\n    begin\n-      --  First, the invalid case\n+      --  First, the invalid cases\n \n       if not Is_Valid_Path_Name (Directory) then\n          raise Name_Error;\n \n+      elsif not Is_Directory (Directory) then\n+         raise Name_Error;\n+\n       else\n          --  The implementation uses GNAT.Directory_Operations.Remove_Dir\n \n@@ -439,13 +454,12 @@ package body Ada.Directories is\n          raise Name_Error;\n \n       else\n-         --  Look fir the first dot that is not followed by a directory\n-         --  separator.\n+         --  Look for first dot that is not followed by a directory separator\n \n          for Pos in reverse Name'Range loop\n \n-            --  If a directory separator is found before a dot, there is no\n-            --  extension.\n+            --  If a directory separator is found before a dot, there\n+            --  is no extension.\n \n             if Name (Pos) = Dir_Separator then\n                return Empty_String;\n@@ -459,6 +473,8 @@ package body Ada.Directories is\n                begin\n                   Result := Name (Pos + 1 .. Name'Last);\n                   return Result;\n+                  --  This should be done with a subtype conversion, avoiding\n+                  --  the unnecessary junk copy ???\n                end;\n             end if;\n          end loop;\n@@ -476,7 +492,9 @@ package body Ada.Directories is\n    procedure Fetch_Next_Entry (Search : Search_Type) is\n       Name : String (1 .. 255);\n       Last : Natural;\n-      Kind : File_Kind;\n+\n+      Kind : File_Kind := Ordinary_File;\n+      --  Initialized to avoid a compilation warning\n \n    begin\n       --  Search.Value.Is_Valid is always True when Fetch_Next_Entry is called\n@@ -499,7 +517,7 @@ package body Ada.Directories is\n                              Compose\n                                (To_String\n                                   (Search.Value.Name), Name (1 .. Last));\n-               Found : Boolean := False;\n+               Found     : Boolean := False;\n \n             begin\n                if File_Exists (Full_Name) then\n@@ -553,7 +571,6 @@ package body Ada.Directories is\n    begin\n       C_Name (1 .. Name'Length) := Name;\n       C_Name (C_Name'Last) := ASCII.NUL;\n-\n       return C_File_Exists (C_Name (1)'Address) = 1;\n    end File_Exists;\n \n@@ -587,15 +604,17 @@ package body Ada.Directories is\n          raise Name_Error;\n \n       else\n-         --  Build the return value with lower bound 1.\n-         --  Use GNAT.OS_Lib.Normalize_Pathname.\n+         --  Build the return value with lower bound 1\n+\n+         --  Use GNAT.OS_Lib.Normalize_Pathname\n \n          declare\n             Value : constant String := Normalize_Pathname (Name);\n             Result : String (1 .. Value'Length);\n          begin\n             Result := Value;\n             return Result;\n+            --  Should use subtype conversion, not junk copy ???\n          end;\n       end if;\n    end Full_Name;\n@@ -775,7 +794,7 @@ package body Ada.Directories is\n          raise Use_Error;\n \n       else\n-         --  The implemewntation uses GNAT.OS_Lib.Rename_File\n+         --  The implementation uses GNAT.OS_Lib.Rename_File\n \n          Rename_File (Old_Name, New_Name, Success);\n \n@@ -812,16 +831,18 @@ package body Ada.Directories is\n          raise Name_Error;\n \n       else\n-         --  Build the value to return with lower bound 1.\n-         --  The implementation uses GNAT.Directory_Operations.Base_Name.\n+         --  Build the value to return with lower bound 1\n+\n+         --  The implementation uses GNAT.Directory_Operations.Base_Name\n \n          declare\n-            Value : constant String :=\n+            Value  : constant String :=\n                        GNAT.Directory_Operations.Base_Name (Name);\n             Result : String (1 .. Value'Length);\n          begin\n             Result := Value;\n             return Result;\n+            --  Should use subtype conversion instead of junk copy ???\n          end;\n       end if;\n    end Simple_Name;\n@@ -849,7 +870,7 @@ package body Ada.Directories is\n    function Size (Name : String) return File_Size is\n       C_Name : String (1 .. Name'Length + 1);\n \n-      function C_Size (Name : System.Address) return File_Size;\n+      function C_Size (Name : System.Address) return Long_Integer;\n       pragma Import (C, C_Size, \"__gnat_named_file_length\");\n \n    begin\n@@ -861,7 +882,7 @@ package body Ada.Directories is\n       else\n          C_Name (1 .. Name'Length) := Name;\n          C_Name (C_Name'Last) := ASCII.NUL;\n-         return C_Size (C_Name'Address);\n+         return File_Size (C_Size (C_Name'Address));\n       end if;\n    end Size;\n "}, {"sha": "4cd2340a79c8eda323f96e803db6d318ac9fc1e1", "filename": "gcc/ada/a-direct.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fa-direct.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fa-direct.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direct.ads?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -77,6 +77,9 @@ with Ada.Strings.Unbounded;\n \n package Ada.Directories is\n \n+   pragma Ada_05;\n+   --  To be removed later ???\n+\n    -----------------------------------\n    -- Directory and File Operations --\n    -----------------------------------\n@@ -386,7 +389,7 @@ private\n       Is_Valid : Boolean := False;\n       Simple   : Ada.Strings.Unbounded.Unbounded_String;\n       Full     : Ada.Strings.Unbounded.Unbounded_String;\n-      Kind     : File_Kind;\n+      Kind     : File_Kind := Ordinary_File;\n    end record;\n \n    --  The type Search_Data is defined in the body, so that the spec does not"}, {"sha": "22331f318dd8ff4f6174f2de55e5675bef10296f", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -516,6 +516,37 @@ package body Ada.Exceptions is\n    pragma Export (C, Rcheck_28, \"__gnat_rcheck_28\");\n    pragma Export (C, Rcheck_29, \"__gnat_rcheck_29\");\n \n+   pragma No_Return (Rcheck_00);\n+   pragma No_Return (Rcheck_01);\n+   pragma No_Return (Rcheck_02);\n+   pragma No_Return (Rcheck_03);\n+   pragma No_Return (Rcheck_04);\n+   pragma No_Return (Rcheck_05);\n+   pragma No_Return (Rcheck_06);\n+   pragma No_Return (Rcheck_07);\n+   pragma No_Return (Rcheck_08);\n+   pragma No_Return (Rcheck_09);\n+   pragma No_Return (Rcheck_10);\n+   pragma No_Return (Rcheck_11);\n+   pragma No_Return (Rcheck_12);\n+   pragma No_Return (Rcheck_13);\n+   pragma No_Return (Rcheck_14);\n+   pragma No_Return (Rcheck_15);\n+   pragma No_Return (Rcheck_16);\n+   pragma No_Return (Rcheck_17);\n+   pragma No_Return (Rcheck_18);\n+   pragma No_Return (Rcheck_19);\n+   pragma No_Return (Rcheck_20);\n+   pragma No_Return (Rcheck_21);\n+   pragma No_Return (Rcheck_22);\n+   pragma No_Return (Rcheck_23);\n+   pragma No_Return (Rcheck_24);\n+   pragma No_Return (Rcheck_25);\n+   pragma No_Return (Rcheck_26);\n+   pragma No_Return (Rcheck_27);\n+   pragma No_Return (Rcheck_28);\n+   pragma No_Return (Rcheck_29);\n+\n    ---------------------------------------------\n    -- Reason Strings for Run-Time Check Calls --\n    ---------------------------------------------"}, {"sha": "325a6b3717a7648c9e6acb17842cb0844ee61c12", "filename": "gcc/ada/a-retide.adb", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fa-retide.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fa-retide.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-retide.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2001, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,22 +31,46 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Ada.Exceptions;\n+--  Used for Raise_Exception\n+\n+with System.Tasking;\n+--  Used for Task_Id\n+\n with System.Task_Primitives.Operations;\n --  Used for Timed_Delay\n+--           Self\n \n package body Ada.Real_Time.Delays is\n \n    package STPO renames System.Task_Primitives.Operations;\n \n+   ----------------\n+   -- Local Data --\n+   ----------------\n+\n    Absolute_RT : constant := 2;\n \n    -----------------\n    -- Delay_Until --\n    -----------------\n \n    procedure Delay_Until (T : Time) is\n+      Self_Id : constant System.Tasking.Task_Id := STPO.Self;\n+\n    begin\n-      STPO.Timed_Delay (STPO.Self, To_Duration (T), Absolute_RT);\n+      --  If pragma Detect_Blocking is active, Program_Error must be\n+      --  raised if this potentially blocking operation is called from a\n+      --  protected action.\n+\n+      if System.Tasking.Detect_Blocking\n+        and then Self_Id.Common.Protected_Action_Nesting > 0\n+      then\n+         Ada.Exceptions.Raise_Exception\n+           (Program_Error'Identity, \"potentially blocking operation\");\n+      else\n+         STPO.Timed_Delay (Self_Id, To_Duration (T), Absolute_RT);\n+      end if;\n    end Delay_Until;\n \n    -----------------"}, {"sha": "21f1cafb2ca312c588b5e134ef5aa87e14b5a77f", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -131,6 +131,11 @@ struct lang_type GTY(()) {tree t; };\n #define TYPE_RETURNS_BY_REF_P(NODE) \\\n   TYPE_LANG_FLAG_4 (FUNCTION_TYPE_CHECK (NODE))\n \n+/* For FUNCTION_TYPEs, nonzero if function returns by being passed a pointer\n+   to a place to store its result.  */\n+#define TYPE_RETURNS_BY_TARGET_PTR_P(NODE) \\\n+  TYPE_LANG_FLAG_5 (FUNCTION_TYPE_CHECK (NODE))\n+\n /* For VOID_TYPE, ENUMERAL_TYPE, UNION_TYPE, and RECORD_TYPE, nonzero if this\n    is a dummy type, made to correspond to a private or incomplete type.  */\n #define TYPE_DUMMY_P(NODE) TYPE_LANG_FLAG_4 (NODE)"}, {"sha": "c1e51b4d472ba85756e2b5a96ba44f9a14cec418", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -815,6 +815,12 @@ package body ALI is\n                Checkc ('E');\n                ALIs.Table (Id).Compile_Errors := True;\n \n+            --  Processing for DB\n+\n+            elsif C = 'D' then\n+               Checkc ('B');\n+               Detect_Blocking := True;\n+\n             --  Processing for FD/FG/FI\n \n             elsif C = 'F' then"}, {"sha": "daf0641cfe644da261a6c7308f3ae02581d5689c", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -1429,7 +1429,6 @@ package body Atree is\n             Set_Field5\n               (New_Node, Copy_Field_With_Replacement (Field5 (New_Node)));\n \n-\n             --  Adjust Sloc of new node if necessary\n \n             if New_Sloc /= No_Location then"}, {"sha": "dca5bbe67f4994d56d6702c3cd497c423e02bf3c", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -100,7 +100,8 @@ package body Bindgen is\n    --      Num_Interrupt_States     : Integer;\n    --      Unreserve_All_Interrupts : Integer;\n    --      Exception_Tracebacks     : Integer;\n-   --      Zero_Cost_Exceptions     : Integer);\n+   --      Zero_Cost_Exceptions     : Integer;\n+   --      Detect_Blocking          : Integer);\n \n    --  Main_Priority is the priority value set by pragma Priority in the\n    --  main program. If no such pragma is present, the value is -1.\n@@ -162,6 +163,11 @@ package body Bindgen is\n    --  this partition, and to zero if longjmp/setjmp exceptions are used.\n    --  the use of zero\n \n+   --  Detect_Blocking indicates whether pragma Detect_Blocking is\n+   --  active or not. A value of zero indicates that the pragma is not\n+   --  present, while a value of 1 signals its presence in the\n+   --  partition.\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -524,12 +530,14 @@ package body Bindgen is\n          WBI (\"         Locking_Policy           : Character;\");\n          WBI (\"         Queuing_Policy           : Character;\");\n          WBI (\"         Task_Dispatching_Policy  : Character;\");\n+\n          WBI (\"         Restrictions             : System.Address;\");\n          WBI (\"         Interrupt_States         : System.Address;\");\n          WBI (\"         Num_Interrupt_States     : Integer;\");\n          WBI (\"         Unreserve_All_Interrupts : Integer;\");\n          WBI (\"         Exception_Tracebacks     : Integer;\");\n-         WBI (\"         Zero_Cost_Exceptions     : Integer);\");\n+         WBI (\"         Zero_Cost_Exceptions     : Integer;\");\n+         WBI (\"         Detect_Blocking          : Integer);\");\n          WBI (\"      pragma Import (C, Set_Globals, \"\"__gnat_set_globals\"\");\");\n \n          --  Import entry point for elaboration time signal handler\n@@ -630,6 +638,17 @@ package body Bindgen is\n             Set_String (\"0\");\n          end if;\n \n+         Set_String (\",\");\n+         Write_Statement_Buffer;\n+\n+         Set_String (\"         Detect_Blocking          => \");\n+\n+         if Detect_Blocking then\n+            Set_Int (1);\n+         else\n+            Set_Int (0);\n+         end if;\n+\n          Set_String (\");\");\n          Write_Statement_Buffer;\n \n@@ -863,10 +882,23 @@ package body Bindgen is\n \n          Set_String (\"      \");\n          Set_Int    (Boolean'Pos (Zero_Cost_Exceptions_Specified));\n-         Set_String (\");\");\n+         Set_String (\",\");\n          Tab_To (24);\n          Set_String (\"/* Zero_Cost_Exceptions       */\");\n          Write_Statement_Buffer;\n+\n+         Set_String (\"      \");\n+\n+         if Detect_Blocking then\n+            Set_Int (1);\n+         else\n+            Set_Int (0);\n+         end if;\n+\n+         Set_String (\");\");\n+         Tab_To (24);\n+         Set_String (\"/* Detect_Blocking            */\");\n+         Write_Statement_Buffer;\n          WBI (\"\");\n \n          --  Install elaboration time signal handler\n@@ -2427,7 +2459,7 @@ package body Bindgen is\n       WBI (\"extern void __gnat_set_globals\");\n       WBI (\"  (int, int, char, char, char, char,\");\n       WBI (\"   const char *, const char *,\");\n-      WBI (\"   int, int, int, int);\");\n+      WBI (\"   int, int, int, int, int);\");\n       WBI (\"extern void \" & Ada_Final_Name.all & \" (void);\");\n       WBI (\"extern void \" & Ada_Init_Name.all & \" (void);\");\n       WBI (\"extern void system__standard_library__adafinal (void);\");"}, {"sha": "6f7410113771e94c828e2fd1285dcc361147be10", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -492,6 +492,7 @@ package body Checks is\n          Expr := Expression (Expr);\n \n       elsif Nkind (Expr) = N_Function_Call\n+        and then Is_Entity_Name (Name (Expr))\n         and then Is_RTE (Entity (Name (Expr)), RE_To_Address)\n       then\n          Expr := First (Parameter_Associations (Expr));"}, {"sha": "ecd21ca65d34f6722257feaee8be194e2ba292d8", "filename": "gcc/ada/cuintp.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fcuintp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fcuintp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcuintp.c?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -95,18 +95,18 @@ UI_To_gnu (Uint Input, tree type)\n       gnu_ret = build_cst_from_int (comp_type, First);\n       if (First < 0)\n \tfor (Idx++, Length--; Length; Idx++, Length--)\n-\t  gnu_ret = fold (build (MINUS_EXPR, comp_type,\n-\t\t\t\t fold (build (MULT_EXPR, comp_type,\n-\t\t\t\t\t      gnu_ret, gnu_base)),\n-\t\t\t\t build_cst_from_int (comp_type,\n-\t\t\t\t\t\t     Udigits_Ptr[Idx])));\n+\t  gnu_ret = fold (build2 (MINUS_EXPR, comp_type,\n+\t\t\t\t  fold (build2 (MULT_EXPR, comp_type,\n+\t\t\t\t\t\tgnu_ret, gnu_base)),\n+\t\t\t\t  build_cst_from_int (comp_type,\n+\t\t\t\t\t\t      Udigits_Ptr[Idx])));\n       else\n \tfor (Idx++, Length--; Length; Idx++, Length--)\n-\t  gnu_ret = fold (build (PLUS_EXPR, comp_type,\n-\t\t\t\t fold (build (MULT_EXPR, comp_type,\n-\t\t\t\t\t      gnu_ret, gnu_base)),\n-\t\t\t\t build_cst_from_int (comp_type,\n-\t\t\t\t\t\t     Udigits_Ptr[Idx])));\n+\t  gnu_ret = fold (build2 (PLUS_EXPR, comp_type,\n+\t\t\t\t  fold (build2 (MULT_EXPR, comp_type,\n+\t\t\t\t\t\tgnu_ret, gnu_base)),\n+\t\t\t\t  build_cst_from_int (comp_type,\n+\t\t\t\t\t\t      Udigits_Ptr[Idx])));\n     }\n \n   gnu_ret = convert (type, gnu_ret);"}, {"sha": "604c47151d1ddcf8104997a1c031b216bccb8d9b", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 63, "deletions": 47, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -89,8 +89,6 @@ static bool is_variable_size (tree);\n static tree elaborate_expression_1 (Node_Id, Entity_Id, tree, tree,\n \t\t\t\t    bool, bool);\n static tree make_packable_type (tree);\n-static tree maybe_pad_type (tree, tree, unsigned int, Entity_Id, const char *,\n-                            bool, bool, bool);\n static tree gnat_to_gnu_field (Entity_Id, tree, int, bool);\n static void components_to_record (tree, Node_Id, tree, int, bool, tree *,\n                                   bool, bool);\n@@ -877,13 +875,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      gnu_expr = gnu_address;\n \t    else\n \t      gnu_expr\n-\t\t= build (COMPOUND_EXPR, gnu_type,\n-\t\t\t build_binary_op\n-\t\t\t (MODIFY_EXPR, NULL_TREE,\n-\t\t\t  build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t\t\t  gnu_address),\n-\t\t\t  gnu_expr),\n-\t\t\t gnu_address);\n+\t\t= build2 (COMPOUND_EXPR, gnu_type,\n+\t\t\t  build_binary_op\n+\t\t\t  (MODIFY_EXPR, NULL_TREE,\n+\t\t\t   build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t\t\t   gnu_address),\n+\t\t\t   gnu_expr),\n+\t\t\t  gnu_address);\n \t  }\n \n \t/* If it has an address clause and we are not defining it, mark it\n@@ -1234,8 +1232,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  {\n \t    TYPE_MODULAR_P (gnu_type) = 1;\n \t    SET_TYPE_MODULUS (gnu_type, gnu_modulus);\n-\t    gnu_high = fold (build (MINUS_EXPR, gnu_type, gnu_modulus,\n-\t\t\t\t    convert (gnu_type, integer_one_node)));\n+\t    gnu_high = fold (build2 (MINUS_EXPR, gnu_type, gnu_modulus,\n+\t\t\t\t     convert (gnu_type, integer_one_node)));\n \t  }\n \n \t/* If we have to set TYPE_PRECISION different from its natural value,\n@@ -1511,9 +1509,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* Build a reference to the template from a PLACEHOLDER_EXPR that\n \t   is the fat pointer.  This will be used to access the individual\n \t   fields once we build them.  */\n-\ttem = build (COMPONENT_REF, gnu_ptr_template,\n-\t\t     build (PLACEHOLDER_EXPR, gnu_fat_type),\n-\t\t     TREE_CHAIN (TYPE_FIELDS (gnu_fat_type)), NULL_TREE);\n+\ttem = build3 (COMPONENT_REF, gnu_ptr_template,\n+\t\t      build0 (PLACEHOLDER_EXPR, gnu_fat_type),\n+\t\t      TREE_CHAIN (TYPE_FIELDS (gnu_fat_type)), NULL_TREE);\n \tgnu_template_reference\n \t  = build_unary_op (INDIRECT_REF, gnu_template_type, tem);\n \tTREE_READONLY (gnu_template_reference) = 1;\n@@ -1559,10 +1557,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t    /* We can't use build_component_ref here since the template\n \t       type isn't complete yet.  */\n-\t    gnu_min = build (COMPONENT_REF, gnu_ind_subtype,\n-\t\t\t     gnu_template_reference, gnu_min_field, NULL_TREE);\n-\t    gnu_max = build (COMPONENT_REF, gnu_ind_subtype,\n-\t\t\t     gnu_template_reference, gnu_max_field, NULL_TREE);\n+\t    gnu_min = build3 (COMPONENT_REF, gnu_ind_subtype,\n+\t\t\t      gnu_template_reference, gnu_min_field,\n+\t\t\t      NULL_TREE);\n+\t    gnu_max = build3 (COMPONENT_REF, gnu_ind_subtype,\n+\t\t\t      gnu_template_reference, gnu_max_field,\n+\t\t\t      NULL_TREE);\n \t    TREE_READONLY (gnu_min) = TREE_READONLY (gnu_max) = 1;\n \n \t    /* Make a range type with the new ranges, but using\n@@ -1802,9 +1802,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  && TREE_CODE (gnu_max) == INTEGER_CST\n \t\t  && TREE_OVERFLOW (gnu_min) && TREE_OVERFLOW (gnu_max)\n \t\t  && (!TREE_OVERFLOW\n-\t\t      (fold (build (MINUS_EXPR, gnu_index_subtype,\n-\t\t\t\t    TYPE_MAX_VALUE (gnu_index_subtype),\n-\t\t\t\t    TYPE_MIN_VALUE (gnu_index_subtype))))))\n+\t\t      (fold (build2 (MINUS_EXPR, gnu_index_subtype,\n+\t\t\t\t     TYPE_MAX_VALUE (gnu_index_subtype),\n+\t\t\t\t     TYPE_MIN_VALUE (gnu_index_subtype))))))\n \t\tTREE_OVERFLOW (gnu_min) = TREE_OVERFLOW (gnu_max)\n \t\t  = TREE_CONSTANT_OVERFLOW (gnu_min)\n \t\t  = TREE_CONSTANT_OVERFLOW (gnu_max) = 0;\n@@ -2360,11 +2360,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       COMPONENT_REF which will be filled in below, once\n \t       the parent type can be safely built.  */\n \n-\t    gnu_get_parent = build (COMPONENT_REF, void_type_node,\n-\t\t\t\t    build (PLACEHOLDER_EXPR, gnu_type),\n-\t\t\t\t    build_decl (FIELD_DECL, NULL_TREE,\n-\t\t\t\t\t\tNULL_TREE),\n-\t\t\t\t    NULL_TREE);\n+\t    gnu_get_parent = build3 (COMPONENT_REF, void_type_node,\n+\t\t\t\t     build0 (PLACEHOLDER_EXPR, gnu_type),\n+\t\t\t\t     build_decl (FIELD_DECL, NULL_TREE,\n+\t\t\t\t\t\t NULL_TREE),\n+\t\t\t\t     NULL_TREE);\n \n \t    if (Has_Discriminants (gnat_entity))\n \t      for (gnat_field = First_Stored_Discriminant (gnat_entity);\n@@ -2373,13 +2373,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tif (Present (Corresponding_Discriminant (gnat_field)))\n \t\t  save_gnu_tree\n \t\t    (gnat_field,\n-\t\t     build (COMPONENT_REF,\n-\t\t\t    get_unpadded_type (Etype (gnat_field)),\n-\t\t\t    gnu_get_parent,\n-\t\t\t    gnat_to_gnu_entity (Corresponding_Discriminant\n-\t\t\t\t\t\t(gnat_field),\n+\t\t     build3 (COMPONENT_REF,\n+\t\t\t     get_unpadded_type (Etype (gnat_field)),\n+\t\t\t     gnu_get_parent,\n+\t\t\t     gnat_to_gnu_entity (Corresponding_Discriminant\n+\t\t\t\t\t\t (gnat_field),\n \t\t\t\t\t\tNULL_TREE, 0),\n-\t\t\t    NULL_TREE),\n+\t\t\t     NULL_TREE),\n \t\t     true);\n \n \t    gnu_parent = gnat_to_gnu_type (Parent_Subtype (gnat_entity));\n@@ -2418,10 +2418,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t corresponding GNAT defining identifier.  Then add to the\n \t\t list of fields.  */\n \t      save_gnu_tree (gnat_field,\n-\t\t\t     build (COMPONENT_REF, TREE_TYPE (gnu_field),\n-\t\t\t\t    build (PLACEHOLDER_EXPR,\n-\t\t\t\t\t   DECL_CONTEXT (gnu_field)),\n-\t\t\t\t    gnu_field, NULL_TREE),\n+\t\t\t     build3 (COMPONENT_REF, TREE_TYPE (gnu_field),\n+\t\t\t\t     build0 (PLACEHOLDER_EXPR,\n+\t\t\t\t\t     DECL_CONTEXT (gnu_field)),\n+\t\t\t\t     gnu_field, NULL_TREE),\n \t\t\t     true);\n \n \t      TREE_CHAIN (gnu_field) = gnu_field_list;\n@@ -3243,6 +3243,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tbool volatile_flag = No_Return (gnat_entity);\n \tbool returns_by_ref = false;\n \tbool returns_unconstrained = false;\n+\tbool returns_by_target_ptr = false;\n \ttree gnu_ext_name = create_concat_name (gnat_entity, 0);\n \tbool has_copy_in_out = false;\n \tint parmnum;\n@@ -3323,9 +3324,19 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t     || Has_Foreign_Convention (gnat_entity)))\n \t  gnu_return_type = TREE_TYPE (TYPE_FIELDS (gnu_return_type));\n \n-\t/* Look at all our parameters and get the type of\n-\t   each.  While doing this, build a copy-out structure if\n-\t   we need one.  */\n+\t/* If the return type is unconstrained, that means it must have a\n+\t   maximum size.  We convert the function into a procedure and its\n+\t   caller will pass a pointer to an object of that maximum size as the\n+\t   first parameter when we call the function.  */\n+\tif (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_return_type)))\n+\t  {\n+\t    returns_by_target_ptr = true;\n+\t    gnu_param_list\n+\t      = create_param_decl (get_identifier (\"TARGET\"),\n+\t\t\t\t   build_reference_type (gnu_return_type),\n+\t\t\t\t   true);\n+\t    gnu_return_type = void_type_node;\n+\t  }\n \n \t/* If the return type has a size that overflows, we cannot have\n \t   a function that returns that type.  This usage doesn't make\n@@ -3339,9 +3350,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    TYPE_SIZE (gnu_return_type) = bitsize_zero_node;\n \t    TYPE_SIZE_UNIT (gnu_return_type) = size_zero_node;\n \t    TYPE_MAIN_VARIANT (gnu_return_type) = gnu_return_type;\n-\t    TYPE_NEXT_VARIANT (gnu_return_type) = 0;\n+\t    TYPE_NEXT_VARIANT (gnu_return_type) = NULL_TREE;\n \t  }\n \n+\t/* Look at all our parameters and get the type of\n+\t   each.  While doing this, build a copy-out structure if\n+\t   we need one.  */\n+\n \tfor (gnat_param = First_Formal (gnat_entity), parmnum = 0;\n \t     Present (gnat_param);\n \t     gnat_param = Next_Formal_With_Extras (gnat_param), parmnum++)\n@@ -3599,7 +3614,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  = create_subprog_type (gnu_return_type, gnu_param_list,\n \t\t\t\t gnu_return_list, returns_unconstrained,\n \t\t\t\t returns_by_ref,\n-\t\t\t\t Function_Returns_With_DSP (gnat_entity));\n+\t\t\t\t Function_Returns_With_DSP (gnat_entity),\n+\t\t\t\t returns_by_target_ptr);\n \n \t/* A subprogram (something that doesn't return anything) shouldn't\n \t   be considered Pure since there would be no reason for such a\n@@ -4524,9 +4540,9 @@ elaborate_expression_1 (Node_Id gnat_expr, Entity_Id gnat_entity,\n      here.  We have to hope it will be at the highest level of the\n      expression in these cases.  */\n   if (TREE_CODE (gnu_expr) == FIELD_DECL)\n-    gnu_expr = build (COMPONENT_REF, TREE_TYPE (gnu_expr),\n-\t\t      build (PLACEHOLDER_EXPR, DECL_CONTEXT (gnu_expr)),\n-\t\t      gnu_expr, NULL_TREE);\n+    gnu_expr = build3 (COMPONENT_REF, TREE_TYPE (gnu_expr),\n+\t\t       build0 (PLACEHOLDER_EXPR, DECL_CONTEXT (gnu_expr)),\n+\t\t       gnu_expr, NULL_TREE);\n \n   /* If GNU_EXPR is neither a placeholder nor a constant, nor a variable\n      that is a constant, make a variable that is initialized to contain the\n@@ -4576,7 +4592,7 @@ tree\n make_aligning_type (tree type, int align, tree size)\n {\n   tree record_type = make_node (RECORD_TYPE);\n-  tree place = build (PLACEHOLDER_EXPR, record_type);\n+  tree place = build0 (PLACEHOLDER_EXPR, record_type);\n   tree size_addr_place = convert (sizetype,\n \t\t\t\t  build_unary_op (ADDR_EXPR, NULL_TREE,\n \t\t\t\t\t\t  place));\n@@ -4701,7 +4717,7 @@ make_packable_type (tree type)\n    set to its TYPE_SIZE; otherwise, it's set to the RM_Size of the original\n    type.  */\n \n-static tree\n+tree\n maybe_pad_type (tree type, tree size, unsigned int align,\n                 Entity_Id gnat_entity, const char *name_trailer,\n                 bool is_user_type, bool definition, bool same_rm_size)\n@@ -5587,7 +5603,7 @@ annotate_value (tree gnu_size)\n \n \t  temp = build1 (NEGATE_EXPR, bitsizetype, negative_size);\n \t  if (adjust)\n-\t    temp = build (MINUS_EXPR, bitsizetype, temp, bitsize_one_node);\n+\t    temp = build2 (MINUS_EXPR, bitsizetype, temp, bitsize_one_node);\n \n \t  return annotate_value (temp);\n \t}"}, {"sha": "631900a7c93ec943bb9d506cb77a9c844e448a0b", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 26, "deletions": 46, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -1400,17 +1400,10 @@ package body Exp_Ch3 is\n         (T : Entity_Id) return Boolean;\n       --  Determines if a component needs simple initialization, given its\n       --  type T. This is the same as Needs_Simple_Initialization except\n-      --  for the following differences. The types Tag and Vtable_Ptr,\n-      --  which are access types which would normally require simple\n-      --  initialization to null, do not require initialization as\n-      --  components, since they are explicitly initialized by other\n-      --  means. The other relaxation is for packed bit arrays that are\n-      --  associated with a modular type, which in some cases require\n-      --  zero initialization to properly support comparisons, except\n-      --  that comparison of such components always involves an explicit\n-      --  selection of only the component's specific bits (whether or not\n-      --  there are adjacent components or gaps), so zero initialization\n-      --  is never needed for components.\n+      --  for the following difference: the types Tag and Vtable_Ptr, which\n+      --  are access types which would normally require simple initialization\n+      --  to null, do not require initialization as components, since they\n+      --  are explicitly initialized by other means.\n \n       procedure Constrain_Array\n         (SI         : Node_Id;\n@@ -1457,16 +1450,14 @@ package body Exp_Ch3 is\n              Selector_Name => New_Occurrence_Of (Id, Loc));\n          Set_Assignment_OK (Lhs);\n \n-         --  Case of an access attribute applied to the current\n-         --  instance. Replace the reference to the type by a\n-         --  reference to the actual object. (Note that this\n-         --  handles the case of the top level of the expression\n-         --  being given by such an attribute, but doesn't cover\n-         --  uses nested within an initial value expression.\n-         --  Nested uses are unlikely to occur in practice,\n-         --  but theoretically possible. It's not clear how\n-         --  to handle them without fully traversing the\n-         --  expression. ???)\n+         --  Case of an access attribute applied to the current instance.\n+         --  Replace the reference to the type by a reference to the actual\n+         --  object. (Note that this handles the case of the top level of\n+         --  the expression being given by such an attribute, but does not\n+         --  cover uses nested within an initial value expression. Nested\n+         --  uses are unlikely to occur in practice, but are theoretically\n+         --  possible. It is not clear how to handle them without fully\n+         --  traversing the expression. ???\n \n          if Kind = N_Attribute_Reference\n            and then (Attribute_Name (N) = Name_Unchecked_Access\n@@ -1482,23 +1473,8 @@ package body Exp_Ch3 is\n                 Attribute_Name => Name_Unrestricted_Access);\n          end if;\n \n-         --  For a derived type the default value is copied from the component\n-         --  declaration of the parent. In the analysis of the init_proc for\n-         --  the parent the default value may have been expanded into a local\n-         --  variable, which is of course not usable here. We must copy the\n-         --  original expression and reanalyze.\n-\n-         if Nkind (Exp) = N_Identifier\n-           and then not Comes_From_Source (Exp)\n-           and then Analyzed (Exp)\n-           and then not In_Open_Scopes (Scope (Entity (Exp)))\n-           and then Nkind (Original_Node (Exp)) = N_Aggregate\n-         then\n-            Exp := New_Copy_Tree (Original_Node (Exp));\n-         end if;\n-\n          --  Ada 2005 (AI-231): Generate conversion to the null-excluding\n-         --  type to force the corresponding run-time check\n+         --  type to force the corresponding run-time check.\n \n          if Ada_Version >= Ada_05\n            and then Can_Never_Be_Null (Etype (Id))  -- Lhs\n@@ -1509,6 +1485,12 @@ package body Exp_Ch3 is\n             Analyze_And_Resolve (Exp, Etype (Id));\n          end if;\n \n+         --  Take a copy of Exp to ensure that later copies of this\n+         --  component_declaration in derived types see the original tree,\n+         --  not a node rewritten during expansion of the init_proc.\n+\n+         Exp := New_Copy_Tree (Exp);\n+\n          Res := New_List (\n            Make_Assignment_Statement (Loc,\n              Name       => Lhs,\n@@ -2243,8 +2225,7 @@ package body Exp_Ch3 is\n          return\n            Needs_Simple_Initialization (T)\n              and then not Is_RTE (T, RE_Tag)\n-             and then not Is_RTE (T, RE_Vtable_Ptr)\n-             and then not Is_Bit_Packed_Array (T);\n+             and then not Is_RTE (T, RE_Vtable_Ptr);\n       end Component_Needs_Simple_Initialization;\n \n       ---------------------\n@@ -3049,9 +3030,9 @@ package body Exp_Ch3 is\n       end if;\n    end Check_Stream_Attributes;\n \n-   ---------------------------\n-   -- Expand_Derived_Record --\n-   ---------------------------\n+   -----------------------------\n+   -- Expand_Record_Extension --\n+   -----------------------------\n \n    --  Add a field _parent at the beginning of the record extension. This is\n    --  used to implement inheritance. Here are some examples of expansion:\n@@ -3075,7 +3056,7 @@ package body Exp_Ch3 is\n    --       D : Int;\n    --    end;\n \n-   procedure Expand_Derived_Record (T : Entity_Id; Def : Node_Id) is\n+   procedure Expand_Record_Extension (T : Entity_Id; Def : Node_Id) is\n       Indic        : constant Node_Id    := Subtype_Indication (Def);\n       Loc          : constant Source_Ptr := Sloc (Def);\n       Rec_Ext_Part : Node_Id             := Record_Extension_Part (Def);\n@@ -3087,7 +3068,7 @@ package body Exp_Ch3 is\n       List_Constr  : constant List_Id    := New_List;\n \n    begin\n-      --  Expand_Tagged_Extension is called directly from the semantics, so\n+      --  Expand_Record_Extension is called directly from the semantics, so\n       --  we must check to see whether expansion is active before proceeding\n \n       if not Expander_Active then\n@@ -3170,7 +3151,7 @@ package body Exp_Ch3 is\n       end if;\n \n       Analyze (Comp_Decl);\n-   end Expand_Derived_Record;\n+   end Expand_Record_Extension;\n \n    ------------------------------------\n    -- Expand_N_Full_Type_Declaration --\n@@ -5605,7 +5586,6 @@ package body Exp_Ch3 is\n \n       elsif Is_Access_Type (T)\n         or else (Init_Or_Norm_Scalars and then (Is_Scalar_Type (T)))\n-\n         or else (Is_Bit_Packed_Array (T)\n                    and then Is_Modular_Integer_Type (Packed_Array_Type (T)))\n       then"}, {"sha": "27cd7d8c1a38af72084f660d3fc1c9e0d08b8b05", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -43,7 +43,7 @@ package Exp_Ch3 is\n    --  the master for that access type, now that it is known to denote an\n    --  object with tasks.\n \n-   procedure Expand_Derived_Record (T : Entity_Id; Def : Node_Id);\n+   procedure Expand_Record_Extension (T : Entity_Id; Def : Node_Id);\n    --  Add a field _parent in the extension part of the record.\n \n    procedure Build_Discr_Checking_Funcs (N : Node_Id);"}, {"sha": "df976adec6f68542655d6367d500cec3b7fe8d93", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -3043,7 +3043,8 @@ package body Exp_Ch6 is\n    -- Expand_N_Subprogram_Body --\n    ------------------------------\n \n-   --  Add poll call if ATC polling is enabled\n+   --  Add poll call if ATC polling is enabled, unless the body will be\n+   --  inlined by the back-end.\n \n    --  Add return statement if last statement in body is not a return\n    --  statement (this makes things easier on Gigi which does not want\n@@ -3272,14 +3273,6 @@ package body Exp_Ch6 is\n          L := Statements (Handled_Statement_Sequence (N));\n       end if;\n \n-      --  Need poll on entry to subprogram if polling enabled. We only\n-      --  do this for non-empty subprograms, since it does not seem\n-      --  necessary to poll for a dummy null subprogram.\n-\n-      if Is_Non_Empty_List (L) then\n-         Generate_Poll_Call (First (L));\n-      end if;\n-\n       --  Find entity for subprogram\n \n       Body_Id := Defining_Entity (N);\n@@ -3290,6 +3283,23 @@ package body Exp_Ch6 is\n          Spec_Id := Body_Id;\n       end if;\n \n+      --  Need poll on entry to subprogram if polling enabled. We only\n+      --  do this for non-empty subprograms, since it does not seem\n+      --  necessary to poll for a dummy null subprogram. Do not add polling\n+      --  point if calls to this subprogram will be inlined by the back-end,\n+      --  to avoid repeated polling points in nested inlinings.\n+\n+      if Is_Non_Empty_List (L) then\n+         if Is_Inlined (Spec_Id)\n+           and then Front_End_Inlining\n+           and then Optimization_Level > 1\n+         then\n+            null;\n+         else\n+            Generate_Poll_Call (First (L));\n+         end if;\n+      end if;\n+\n       --  If this is a Pure function which has any parameters whose root\n       --  type is System.Address, reset the Pure indication, since it will\n       --  likely cause incorrect code to be generated as the parameter is"}, {"sha": "7015079326942725535813f20972b0d3152900b2", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 1014, "deletions": 493, "changes": 1507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -76,27 +76,63 @@ package body Exp_Dist is\n    --       to fake half a derivation to ensure that the subprograms do have\n    --       the same dispatching table.\n \n+   First_RCI_Subprogram_Id : constant := 2;\n+   --  RCI subprograms are numbered starting at 2. The RCI receiver for\n+   --  an RCI package can thus identify calls received through remote\n+   --  access-to-subprogram dereferences by the fact that they have a\n+   --  (primitive) subprogram id of 0, and 1 is used for the internal\n+   --  RAS information lookup operation.\n+\n    -----------------------\n    -- Local subprograms --\n    -----------------------\n \n+   procedure Add_RAS_Proxy_And_Analyze\n+     (Decls              :     List_Id;\n+      Vis_Decl           :     Node_Id;\n+      All_Calls_Remote_E :     Entity_Id;\n+      Proxy_Object_Addr  : out Entity_Id);\n+   --  Add the proxy type necessary to call the subprogram declared\n+   --  by Vis_Decl through a remote access to subprogram type.\n+   --  All_Calls_Remote_E must be Standard_True if a pragma All_Calls_Remote\n+   --  applies, Standard_False otherwise. The new proxy type is appended\n+   --  to Decls. Proxy_Object_Addr is a constant of type System.Address that\n+   --  designates an instance of the proxy object.\n+\n+   function Build_Remote_Subprogram_Proxy_Type\n+     (Loc            : Source_Ptr;\n+      ACR_Expression : Node_Id) return Node_Id;\n+   --  Build and return a tagged record type definition for an RCI\n+   --  subprogram proxy type.\n+   --  ACR_Expression is use as the initialization value for\n+   --  the All_Calls_Remote component.\n+\n    function Get_Subprogram_Id (E : Entity_Id) return Int;\n    --  Given a subprogram defined in a RCI package, get its subprogram id\n    --  which will be used for remote calls.\n \n+   function Build_Get_Unique_RP_Call\n+     (Loc       : Source_Ptr;\n+      Pointer   : Entity_Id;\n+      Stub_Type : Entity_Id) return List_Id;\n+   --  Build a call to Get_Unique_Remote_Pointer (Pointer),\n+   --  followed by a tag fixup (Get_Unique_Remote_Pointer may have\n+   --  changed Pointer'Tag to RACW_Stub_Type'Tag, while the desired\n+   --  tag is that of Stub_Type).\n+\n    procedure Build_General_Calling_Stubs\n-     (Decls                     : in List_Id;\n-      Statements                : in List_Id;\n-      Target_Partition          : in Entity_Id;\n-      RPC_Receiver              : in Node_Id;\n-      Subprogram_Id             : in Node_Id;\n-      Asynchronous              : in Node_Id := Empty;\n-      Is_Known_Asynchronous     : in Boolean := False;\n-      Is_Known_Non_Asynchronous : in Boolean := False;\n-      Is_Function               : in Boolean;\n-      Spec                      : in Node_Id;\n-      Object_Type               : in Entity_Id := Empty;\n-      Nod                       : in Node_Id);\n+     (Decls                     : List_Id;\n+      Statements                : List_Id;\n+      Target_Partition          : Entity_Id;\n+      RPC_Receiver              : Node_Id;\n+      Subprogram_Id             : Node_Id;\n+      Asynchronous              : Node_Id := Empty;\n+      Is_Known_Asynchronous     : Boolean := False;\n+      Is_Known_Non_Asynchronous : Boolean := False;\n+      Is_Function               : Boolean;\n+      Spec                      : Node_Id;\n+      Object_Type               : Entity_Id := Empty;\n+      Nod                       : Node_Id);\n    --  Build calling stubs for general purpose. The parameters are:\n    --    Decls             : a place to put declarations\n    --    Statements        : a place to put statements\n@@ -124,8 +160,7 @@ package body Exp_Dist is\n       Dynamically_Asynchronous : Boolean   := False;\n       Stub_Type                : Entity_Id := Empty;\n       Locator                  : Entity_Id := Empty;\n-      New_Name                 : Name_Id   := No_Name)\n-      return                     Node_Id;\n+      New_Name                 : Name_Id   := No_Name) return Node_Id;\n    --  Build the calling stub for a given subprogram with the subprogram ID\n    --  being Subp_Id. If Stub_Type is given, then the \"addr\" field of\n    --  parameters of this type will be marshalled instead of the object\n@@ -142,8 +177,7 @@ package body Exp_Dist is\n       Dynamically_Asynchronous : Boolean   := False;\n       Stub_Type                : Entity_Id := Empty;\n       RACW_Type                : Entity_Id := Empty;\n-      Parent_Primitive         : Entity_Id := Empty)\n-      return                     Node_Id;\n+      Parent_Primitive         : Entity_Id := Empty) return Node_Id;\n    --  Build the receiving stub for a given subprogram. The subprogram\n    --  declaration is also built by this procedure, and the value returned\n    --  is a N_Subprogram_Body. If a parameter of type access to Stub_Type is\n@@ -155,31 +189,32 @@ package body Exp_Dist is\n    function Build_RPC_Receiver_Specification\n      (RPC_Receiver     : Entity_Id;\n       Stream_Parameter : Entity_Id;\n-      Result_Parameter : Entity_Id)\n-      return Node_Id;\n+      Result_Parameter : Entity_Id) return Node_Id;\n    --  Make a subprogram specification for an RPC receiver,\n    --  with the given defining unit name and formal parameters.\n \n    function Build_Ordered_Parameters_List (Spec : Node_Id) return List_Id;\n    --  Return an ordered parameter list: unconstrained parameters are put\n    --  at the beginning of the list and constrained ones are put after. If\n-   --  there are no parameters, an empty list is returned.\n+   --  there are no parameters, an empty list is returned. Special case:\n+   --  the controlling formal of the equivalent RACW operation for a RAS\n+   --  type is always left in first position.\n \n    procedure Add_Calling_Stubs_To_Declarations\n-     (Pkg_Spec : in Node_Id;\n-      Decls    : in List_Id);\n+     (Pkg_Spec : Node_Id;\n+      Decls    : List_Id);\n    --  Add calling stubs to the declarative part\n \n    procedure Add_Receiving_Stubs_To_Declarations\n-     (Pkg_Spec : in Node_Id;\n-      Decls    : in List_Id);\n+     (Pkg_Spec : Node_Id;\n+      Decls    : List_Id);\n    --  Add receiving stubs to the declarative part\n \n-   procedure Add_RAS_Dereference_Attribute (N : in Node_Id);\n-   --  Add a subprogram body for RAS dereference\n+   procedure Add_RAS_Dereference_TSS (N : Node_Id);\n+   --  Add a subprogram body for RAS Dereference TSS\n \n-   procedure Add_RAS_Access_Attribute (N : in Node_Id);\n-   --  Add a subprogram body for RAS Access attribute\n+   procedure Add_RAS_Access_TSS (N : Node_Id);\n+   --  Add a subprogram body for RAS Access TSS\n \n    function Could_Be_Asynchronous (Spec : Node_Id) return Boolean;\n    --  Return True if nothing prevents the program whose specification is\n@@ -194,8 +229,7 @@ package body Exp_Dist is\n      (Loc    : Source_Ptr;\n       Stream : Node_Id;\n       Object : Entity_Id;\n-      Etyp   : Entity_Id := Empty)\n-      return   Node_Id;\n+      Etyp   : Entity_Id := Empty) return Node_Id;\n    --  Pack Object (of type Etyp) into Stream. If Etyp is not given,\n    --  then Etype (Object) will be used if present. If the type is\n    --  constrained, then 'Write will be used to output the object,\n@@ -205,30 +239,16 @@ package body Exp_Dist is\n      (Loc    : Source_Ptr;\n       Stream : Entity_Id;\n       Object : Node_Id;\n-      Etyp   : Entity_Id)\n-      return   Node_Id;\n+      Etyp   : Entity_Id) return Node_Id;\n    --  Similar to above, with an arbitrary node instead of an entity\n \n    function Pack_Node_Into_Stream_Access\n      (Loc    : Source_Ptr;\n       Stream : Node_Id;\n       Object : Node_Id;\n-      Etyp   : Entity_Id)\n-      return   Node_Id;\n+      Etyp   : Entity_Id) return Node_Id;\n    --  Similar to above, with Stream instead of Stream'Access\n \n-   function Copy_Specification\n-     (Loc         : Source_Ptr;\n-      Spec        : Node_Id;\n-      Object_Type : Entity_Id := Empty;\n-      Stub_Type   : Entity_Id := Empty;\n-      New_Name    : Name_Id   := No_Name)\n-      return        Node_Id;\n-   --  Build a specification from another one. If Object_Type is not Empty\n-   --  and any access to Object_Type is found, then it is replaced by an\n-   --  access to Stub_Type. If New_Name is given, then it will be used as\n-   --  the name for the newly created spec.\n-\n    function Scope_Of_Spec (Spec : Node_Id) return Entity_Id;\n    --  Return the scope represented by a given spec\n \n@@ -237,8 +257,7 @@ package body Exp_Dist is\n    --  its constrained status.\n \n    function Is_RACW_Controlling_Formal\n-     (Parameter : Node_Id; Stub_Type : Entity_Id)\n-      return Boolean;\n+     (Parameter : Node_Id; Stub_Type : Entity_Id) return Boolean;\n    --  Return True if the current parameter is a controlling formal argument\n    --  of type Stub_Type or access to Stub_Type.\n \n@@ -301,9 +320,9 @@ package body Exp_Dist is\n    --  Mapping between a RCI subprogram and the corresponding calling stubs\n \n    procedure Add_Stub_Type\n-     (Designated_Type     : in Entity_Id;\n-      RACW_Type           : in Entity_Id;\n-      Decls               : in List_Id;\n+     (Designated_Type     : Entity_Id;\n+      RACW_Type           : Entity_Id;\n+      Decls               : List_Id;\n       Stub_Type           : out Entity_Id;\n       Stub_Type_Access    : out Entity_Id;\n       Object_RPC_Receiver : out Entity_Id;\n@@ -314,37 +333,36 @@ package body Exp_Dist is\n    --  anyhow and Existing is set to True.\n \n    procedure Add_RACW_Read_Attribute\n-     (RACW_Type           : in Entity_Id;\n-      Stub_Type           : in Entity_Id;\n-      Stub_Type_Access    : in Entity_Id;\n-      Declarations        : in List_Id);\n+     (RACW_Type           : Entity_Id;\n+      Stub_Type           : Entity_Id;\n+      Stub_Type_Access    : Entity_Id;\n+      Declarations        : List_Id);\n    --  Add Read attribute in Decls for the RACW type. The Read attribute\n    --  is added right after the RACW_Type declaration while the body is\n    --  inserted after Declarations.\n \n    procedure Add_RACW_Write_Attribute\n-     (RACW_Type           : in Entity_Id;\n-      Stub_Type           : in Entity_Id;\n-      Stub_Type_Access    : in Entity_Id;\n-      Object_RPC_Receiver : in Entity_Id;\n-      Declarations        : in List_Id);\n+     (RACW_Type           : Entity_Id;\n+      Stub_Type           : Entity_Id;\n+      Stub_Type_Access    : Entity_Id;\n+      Object_RPC_Receiver : Entity_Id;\n+      Declarations        : List_Id);\n    --  Same thing for the Write attribute\n \n    procedure Add_RACW_Read_Write_Attributes\n-     (RACW_Type           : in Entity_Id;\n-      Stub_Type           : in Entity_Id;\n-      Stub_Type_Access    : in Entity_Id;\n-      Object_RPC_Receiver : in Entity_Id;\n-      Declarations        : in List_Id);\n+     (RACW_Type           : Entity_Id;\n+      Stub_Type           : Entity_Id;\n+      Stub_Type_Access    : Entity_Id;\n+      Object_RPC_Receiver : Entity_Id;\n+      Declarations        : List_Id);\n    --  Add Read and Write attributes declarations and bodies for a given\n    --  RACW type. The declarations are added just after the declaration\n    --  of the RACW type itself, while the bodies are inserted at the end\n    --  of Decls.\n \n    function RCI_Package_Locator\n      (Loc          : Source_Ptr;\n-      Package_Spec : Node_Id)\n-      return         Node_Id;\n+      Package_Spec : Node_Id) return Node_Id;\n    --  Instantiate the generic package RCI_Info in order to locate the\n    --  RCI package whose spec is given as argument.\n \n@@ -361,8 +379,7 @@ package body Exp_Dist is\n    function Input_With_Tag_Check\n      (Loc      : Source_Ptr;\n       Var_Type : Entity_Id;\n-      Stream   : Entity_Id)\n-     return Node_Id;\n+      Stream   : Entity_Id) return Node_Id;\n    --  Return a function with the following form:\n    --    function R return Var_Type is\n    --    begin\n@@ -392,16 +409,16 @@ package body Exp_Dist is\n    ---------------------------------------\n \n    procedure Add_Calling_Stubs_To_Declarations\n-     (Pkg_Spec : in Node_Id;\n-      Decls    : in List_Id)\n+     (Pkg_Spec : Node_Id;\n+      Decls    : List_Id)\n    is\n-      Current_Subprogram_Number : Int := 0;\n-      Current_Declaration       : Node_Id;\n+      Current_Subprogram_Number : Int := First_RCI_Subprogram_Id;\n+      --  Subprogram id 0 is reserved for calls received from\n+      --  remote access-to-subprogram dereferences.\n \n+      Current_Declaration       : Node_Id;\n       Loc                       : constant Source_Ptr := Sloc (Pkg_Spec);\n-\n       RCI_Instantiation         : Node_Id;\n-\n       Subp_Stubs                : Node_Id;\n \n    begin\n@@ -424,9 +441,7 @@ package body Exp_Dist is\n       --  do the correct dispatching.\n \n       Current_Declaration := First (Visible_Declarations (Pkg_Spec));\n-\n       while Current_Declaration /= Empty loop\n-\n          if Nkind (Current_Declaration) = N_Subprogram_Declaration\n            and then Comes_From_Source (Current_Declaration)\n          then\n@@ -453,14 +468,13 @@ package body Exp_Dist is\n \n          Next (Current_Declaration);\n       end loop;\n-\n    end Add_Calling_Stubs_To_Declarations;\n \n    -----------------------\n    -- Add_RACW_Features --\n    -----------------------\n \n-   procedure Add_RACW_Features (RACW_Type : in Entity_Id)\n+   procedure Add_RACW_Features (RACW_Type : Entity_Id)\n    is\n       Desig : constant Entity_Id :=\n                 Etype (Designated_Type (RACW_Type));\n@@ -554,7 +568,7 @@ package body Exp_Dist is\n       Loc : constant Source_Ptr := Sloc (Insertion_Node);\n \n       Stub_Elements : constant Stub_Structure :=\n-        Stubs_Table.Get (Designated_Type);\n+                        Stubs_Table.Get (Designated_Type);\n \n       pragma Assert (Stub_Elements /= Empty_Stub_Structure);\n \n@@ -593,9 +607,7 @@ package body Exp_Dist is\n \n          Current_Primitive_Elmt :=\n            First_Elmt (Primitive_Operations (Designated_Type));\n-\n          while Current_Primitive_Elmt /= No_Elmt loop\n-\n             Current_Primitive := Node (Current_Primitive_Elmt);\n \n             --  Copy the primitive of all the parents, except predefined\n@@ -748,10 +760,10 @@ package body Exp_Dist is\n    -----------------------------\n \n    procedure Add_RACW_Read_Attribute\n-     (RACW_Type           : in Entity_Id;\n-      Stub_Type           : in Entity_Id;\n-      Stub_Type_Access    : in Entity_Id;\n-      Declarations        : in List_Id)\n+     (RACW_Type           : Entity_Id;\n+      Stub_Type           : Entity_Id;\n+      Stub_Type_Access    : Entity_Id;\n+      Declarations        : List_Id)\n    is\n       Loc : constant Source_Ptr := Sloc (RACW_Type);\n \n@@ -777,6 +789,9 @@ package body Exp_Dist is\n       Source_Address    : constant Entity_Id :=\n                             Make_Defining_Identifier\n                               (Loc, New_Internal_Name ('P'));\n+      Local_Stub        : constant Entity_Id  :=\n+                            Make_Defining_Identifier\n+                              (Loc, New_Internal_Name ('L'));\n       Stubbed_Result    : constant Entity_Id  :=\n                             Make_Defining_Identifier\n                               (Loc, New_Internal_Name ('S'));\n@@ -835,10 +850,21 @@ package body Exp_Dist is\n           Object_Definition   =>\n             New_Occurrence_Of (RTE (RE_Unsigned_64), Loc)),\n \n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Local_Stub,\n+          Aliased_Present     => True,\n+          Object_Definition   => New_Occurrence_Of (Stub_Type, Loc)),\n+\n         Make_Object_Declaration (Loc,\n           Defining_Identifier => Stubbed_Result,\n           Object_Definition   =>\n-            New_Occurrence_Of (Stub_Type_Access, Loc)));\n+            New_Occurrence_Of (Stub_Type_Access, Loc),\n+          Expression          =>\n+            Make_Attribute_Reference (Loc,\n+              Prefix =>\n+                New_Occurrence_Of (Local_Stub, Loc),\n+              Attribute_Name =>\n+                Name_Unchecked_Access)));\n \n       --  Read the source Partition_ID and RPC_Receiver from incoming stream\n \n@@ -869,6 +895,10 @@ package body Exp_Dist is\n             Stream_Parameter,\n             New_Occurrence_Of (Source_Address, Loc))));\n \n+      --  Build_Get_Unique_RP_Call needs the type of Stubbed_Result\n+\n+      Set_Etype (Stubbed_Result, Stub_Type_Access);\n+\n       --  If the Address is Null_Address, then return a null object\n \n       Append_To (Statements,\n@@ -900,12 +930,6 @@ package body Exp_Dist is\n \n       Remote_Statements := New_List (\n \n-        Make_Assignment_Statement (Loc,\n-          Name       => New_Occurrence_Of (Stubbed_Result, Loc),\n-          Expression =>\n-            Make_Allocator (Loc,\n-              New_Occurrence_Of (Stub_Type, Loc))),\n-\n         Make_Assignment_Statement (Loc,\n           Name       => Make_Selected_Component (Loc,\n             Prefix        => New_Occurrence_Of (Stubbed_Result, Loc),\n@@ -935,13 +959,18 @@ package body Exp_Dist is\n           Expression =>\n             New_Occurrence_Of (Asynchronous_Flag, Loc)));\n \n-      Append_To (Remote_Statements,\n-        Make_Procedure_Call_Statement (Loc,\n-          Name                   =>\n-            New_Occurrence_Of (RTE (RE_Get_Unique_Remote_Pointer), Loc),\n-          Parameter_Associations => New_List (\n-            Unchecked_Convert_To (RTE (RE_RACW_Stub_Type_Access),\n-              New_Occurrence_Of (Stubbed_Result, Loc)))));\n+      Append_List_To (Remote_Statements,\n+        Build_Get_Unique_RP_Call (Loc, Stubbed_Result, Stub_Type));\n+      --  ??? Issue with asynchronous calls here: the Asynchronous\n+      --  flag is set on the stub type if, and only if, the RACW type\n+      --  has a pragma Asynchronous. This is incorrect for RACWs that\n+      --  implement RAS types, because in that case the /designated\n+      --  subprogram/ (not the type) might be asynchronous, and\n+      --  that causes the stub to need to be asynchronous too.\n+      --  A solution is to transport a RAS as a struct containing\n+      --  a RACW and an asynchronous flag, and to properly alter\n+      --  the Asynchronous component in the stub type in the RAS's\n+      --  Input TSS.\n \n       Append_To (Remote_Statements,\n         Make_Assignment_Statement (Loc,\n@@ -991,11 +1020,11 @@ package body Exp_Dist is\n    ------------------------------------\n \n    procedure Add_RACW_Read_Write_Attributes\n-     (RACW_Type           : in Entity_Id;\n-      Stub_Type           : in Entity_Id;\n-      Stub_Type_Access    : in Entity_Id;\n-      Object_RPC_Receiver : in Entity_Id;\n-      Declarations        : in List_Id)\n+     (RACW_Type           : Entity_Id;\n+      Stub_Type           : Entity_Id;\n+      Stub_Type_Access    : Entity_Id;\n+      Object_RPC_Receiver : Entity_Id;\n+      Declarations        : List_Id)\n    is\n    begin\n       Add_RACW_Write_Attribute\n@@ -1017,18 +1046,22 @@ package body Exp_Dist is\n    ------------------------------\n \n    procedure Add_RACW_Write_Attribute\n-     (RACW_Type           : in Entity_Id;\n-      Stub_Type           : in Entity_Id;\n-      Stub_Type_Access    : in Entity_Id;\n-      Object_RPC_Receiver : in Entity_Id;\n-      Declarations        : in List_Id)\n+     (RACW_Type           : Entity_Id;\n+      Stub_Type           : Entity_Id;\n+      Stub_Type_Access    : Entity_Id;\n+      Object_RPC_Receiver : Entity_Id;\n+      Declarations        : List_Id)\n    is\n       Loc : constant Source_Ptr := Sloc (RACW_Type);\n \n+      Is_RAS : constant Boolean := not Comes_From_Source (RACW_Type);\n+\n       Body_Node : Node_Id;\n       Proc_Decl : Node_Id;\n       Attr_Decl : Node_Id;\n \n+      RPC_Receiver : Node_Id;\n+\n       Statements        : List_Id;\n       Local_Statements  : List_Id;\n       Remote_Statements : List_Id;\n@@ -1056,6 +1089,26 @@ package body Exp_Dist is\n       --  Build the code fragment corresponding to the marshalling of a\n       --  local object.\n \n+      if Is_RAS then\n+\n+         --  For a RAS, the RPC receiver is that of the RCI unit,\n+         --  not that of the corresponding distributed object type.\n+         --  We retrieve its address from the local proxy object.\n+\n+         RPC_Receiver := Make_Selected_Component (Loc,\n+           Prefix         =>\n+             Unchecked_Convert_To (RTE (RE_RAS_Proxy_Type_Access), Object),\n+           Selector_Name =>\n+             Make_Identifier (Loc, Name_Receiver));\n+\n+      else\n+         RPC_Receiver := Make_Attribute_Reference (Loc,\n+           Prefix         =>\n+             New_Occurrence_Of (Object_RPC_Receiver, Loc),\n+           Attribute_Name =>\n+             Name_Address);\n+      end if;\n+\n       Local_Statements := New_List (\n \n         Pack_Entity_Into_Stream_Access (Loc,\n@@ -1064,21 +1117,18 @@ package body Exp_Dist is\n \n         Pack_Node_Into_Stream_Access (Loc,\n           Stream => Stream_Parameter,\n-          Object => OK_Convert_To (RTE (RE_Unsigned_64),\n-            Make_Attribute_Reference (Loc,\n-              Prefix         => New_Occurrence_Of (Object_RPC_Receiver, Loc),\n-              Attribute_Name => Name_Address)),\n+          Object => OK_Convert_To (RTE (RE_Unsigned_64), RPC_Receiver),\n           Etyp   => RTE (RE_Unsigned_64)),\n \n-        Pack_Node_Into_Stream_Access (Loc,\n-          Stream => Stream_Parameter,\n-          Object => OK_Convert_To (RTE (RE_Unsigned_64),\n-            Make_Attribute_Reference (Loc,\n-              Prefix         =>\n-                Make_Explicit_Dereference (Loc,\n-                  Prefix => Object),\n-              Attribute_Name => Name_Address)),\n-          Etyp   => RTE (RE_Unsigned_64)));\n+       Pack_Node_Into_Stream_Access (Loc,\n+         Stream => Stream_Parameter,\n+         Object => OK_Convert_To (RTE (RE_Unsigned_64),\n+           Make_Attribute_Reference (Loc,\n+             Prefix         =>\n+               Make_Explicit_Dereference (Loc,\n+                 Prefix => Object),\n+             Attribute_Name => Name_Address)),\n+         Etyp   => RTE (RE_Unsigned_64)));\n \n       --  Build the code fragment corresponding to the marshalling of\n       --  a remote object.\n@@ -1180,34 +1230,79 @@ package body Exp_Dist is\n       Append_To (Declarations, Body_Node);\n    end Add_RACW_Write_Attribute;\n \n-   ------------------------------\n-   -- Add_RAS_Access_Attribute --\n-   ------------------------------\n+   ------------------------\n+   -- Add_RAS_Access_TSS --\n+   ------------------------\n+\n+   procedure Add_RAS_Access_TSS (N : Node_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n \n-   procedure Add_RAS_Access_Attribute (N : in Node_Id) is\n       Ras_Type : constant Entity_Id := Defining_Identifier (N);\n       Fat_Type : constant Entity_Id := Equivalent_Type (Ras_Type);\n       --  Ras_Type is the access to subprogram type while Fat_Type points to\n       --  the record type corresponding to a remote access to subprogram type.\n \n-      Proc_Decls        : constant List_Id := New_List;\n-      Proc_Statements   : constant List_Id := New_List;\n+      RACW_Type : constant Entity_Id :=\n+        Underlying_RACW_Type (Ras_Type);\n+      Desig     : constant Entity_Id :=\n+        Etype (Designated_Type (RACW_Type));\n \n-      Proc_Spec    : Node_Id;\n-      Proc         : Node_Id;\n-      Local_Addr   : Entity_Id;\n-      Package_Name : Entity_Id;\n-      Subp_Id      : Entity_Id;\n-      Asynch_P     : Entity_Id;\n-      Origin       : Entity_Id;\n-      Return_Value : Entity_Id;\n+      Stub_Elements : constant Stub_Structure :=\n+        Stubs_Table.Get (Desig);\n+      pragma Assert (Stub_Elements /= Empty_Stub_Structure);\n \n-      All_Calls_Remote : Entity_Id;\n+      Proc : constant Entity_Id :=\n+               Make_Defining_Identifier (Loc,\n+                 Chars => Make_TSS_Name (Ras_Type, TSS_RAS_Access));\n+      Proc_Spec : Node_Id;\n+\n+      --  Formal parameters\n+\n+      Package_Name : constant Entity_Id :=\n+                       Make_Defining_Identifier (Loc,\n+                         Chars => Name_P);\n+      --  Target package\n+\n+      Subp_Id : constant Entity_Id :=\n+                  Make_Defining_Identifier (Loc,\n+                    Chars => Name_S);\n+      --  Target subprogram\n+\n+      Asynch_P : constant Entity_Id :=\n+                   Make_Defining_Identifier (Loc,\n+                     Chars => Name_Asynchronous);\n+      --  Is the procedure to which the 'Access applies asynchronous?\n+\n+      All_Calls_Remote : constant Entity_Id :=\n+                           Make_Defining_Identifier (Loc,\n+                             Chars => Name_All_Calls_Remote);\n       --  True if an All_Calls_Remote pragma applies to the RCI unit\n-      --  that contains the subprogram (currently unused, all RAS\n-      --  dereferences are handled through the PCS).\n+      --  that contains the subprogram.\n \n-      Loc : constant Source_Ptr := Sloc (N);\n+      --  Common local variables\n+\n+      Proc_Decls        : List_Id;\n+      Proc_Statements   : List_Id;\n+\n+      Origin : constant Entity_Id :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_Internal_Name ('P'));\n+\n+      --  Additional local variables for the local case\n+\n+      Proxy_Addr : constant Entity_Id :=\n+                     Make_Defining_Identifier (Loc,\n+                       Chars => New_Internal_Name ('P'));\n+\n+      --  Additional local variables for the remote case\n+\n+      Local_Stub : constant Entity_Id :=\n+                     Make_Defining_Identifier (Loc,\n+                       Chars => New_Internal_Name ('L'));\n+\n+      Stub_Ptr : constant Entity_Id :=\n+                   Make_Defining_Identifier (Loc,\n+                     Chars => New_Internal_Name ('S'));\n \n       function Set_Field\n         (Field_Name : Name_Id;\n@@ -1228,26 +1323,17 @@ package body Exp_Dist is\n            Make_Assignment_Statement (Loc,\n              Name       =>\n                Make_Selected_Component (Loc,\n-                 Prefix        => New_Occurrence_Of (Return_Value, Loc),\n+                 Prefix        => New_Occurrence_Of (Stub_Ptr, Loc),\n                  Selector_Name => Make_Identifier (Loc, Field_Name)),\n              Expression => Value);\n       end Set_Field;\n \n-   --  Start of processing for Add_RAS_Access_Attribute\n+   --  Start of processing for Add_RAS_Access_TSS\n \n    begin\n-      Local_Addr   := Make_Defining_Identifier (Loc, New_Internal_Name ('L'));\n-      Package_Name := Make_Defining_Identifier (Loc, New_Internal_Name ('P'));\n-      Subp_Id      := Make_Defining_Identifier (Loc, New_Internal_Name ('N'));\n-      Asynch_P     := Make_Defining_Identifier (Loc, New_Internal_Name ('B'));\n-      Origin       := Make_Defining_Identifier (Loc, New_Internal_Name ('P'));\n-      Return_Value := Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n-      All_Calls_Remote :=\n-        Make_Defining_Identifier (Loc, New_Internal_Name ('A'));\n-\n-      --  Create the object which will be returned of type Fat_Type\n+      Proc_Decls := New_List (\n \n-      Append_List_To (Proc_Decls, New_List (\n+      --  Common declarations\n \n         Make_Object_Declaration (Loc,\n           Defining_Identifier => Origin,\n@@ -1261,41 +1347,75 @@ package body Exp_Dist is\n               Parameter_Associations => New_List (\n                 New_Occurrence_Of (Package_Name, Loc)))),\n \n+      --  Declaration use only in the local case: proxy address\n+\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Proxy_Addr,\n+          Object_Definition   =>\n+            New_Occurrence_Of (RTE (RE_Unsigned_64), Loc)),\n+\n+      --  Declarations used only in the remote case: stub object and\n+      --  stub pointer.\n+\n         Make_Object_Declaration (Loc,\n-          Defining_Identifier => Return_Value,\n+          Defining_Identifier => Local_Stub,\n+          Aliased_Present     => True,\n           Object_Definition   =>\n-            New_Occurrence_Of (Fat_Type, Loc))));\n+            New_Occurrence_Of (Stub_Elements.Stub_Type, Loc)),\n+\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier =>\n+            Stub_Ptr,\n+          Object_Definition   =>\n+            New_Occurrence_Of (Stub_Elements.Stub_Type_Access, Loc),\n+          Expression          =>\n+            Make_Attribute_Reference (Loc,\n+              Prefix => New_Occurrence_Of (Local_Stub, Loc),\n+              Attribute_Name => Name_Unchecked_Access)));\n \n-      --  Initialize the fields of the record type with the appropriate data\n+      Set_Etype (Stub_Ptr, Stub_Elements.Stub_Type_Access);\n+      --  Build_Get_Unique_RP_Call needs this information.\n+\n+      --  Note: Here we assume that the Fat_Type is a record\n+      --  containing just a pointer to a proxy or stub object.\n+\n+      Proc_Statements := New_List (\n+\n+      --  Get_RAS_Info (Pkg, Subp, PA);\n+      --  if Origin = Local_Partition_Id and then not All_Calls_Remote then\n+      --     return Fat_Type!(PA);\n+      --  end if;\n+\n+         Make_Procedure_Call_Statement (Loc,\n+           Name =>\n+             New_Occurrence_Of (RTE (RE_Get_RAS_Info), Loc),\n+           Parameter_Associations => New_List (\n+             New_Occurrence_Of (Package_Name, Loc),\n+             New_Occurrence_Of (Subp_Id, Loc),\n+             New_Occurrence_Of (Proxy_Addr, Loc))),\n \n-      Append_List_To (Proc_Statements, New_List (\n         Make_Implicit_If_Statement (N,\n           Condition =>\n             Make_And_Then (Loc,\n-              Left_Opnd =>\n-                Make_Op_Not (Loc,\n-                  New_Occurrence_Of (All_Calls_Remote, Loc)),\n-              Right_Opnd =>\n+              Left_Opnd  =>\n                 Make_Op_Eq (Loc,\n                   Left_Opnd =>\n                     New_Occurrence_Of (Origin, Loc),\n                   Right_Opnd =>\n                     Make_Function_Call (Loc,\n                       New_Occurrence_Of (\n-                        RTE (RE_Get_Local_Partition_Id), Loc)))),\n-\n+                        RTE (RE_Get_Local_Partition_Id), Loc))),\n+              Right_Opnd =>\n+                Make_Op_Not (Loc,\n+                  New_Occurrence_Of (All_Calls_Remote, Loc))),\n           Then_Statements => New_List (\n-            Set_Field (Name_Ras,\n-              OK_Convert_To (RTE (RE_Unsigned_64),\n-                             New_Occurrence_Of (Local_Addr, Loc)))),\n-\n-          Else_Statements => New_List (\n-            Set_Field (Name_Ras,\n-              Make_Integer_Literal (Loc, Uint_0)))),\n+            Make_Return_Statement (Loc,\n+              Unchecked_Convert_To (Fat_Type,\n+                OK_Convert_To (RTE (RE_Address),\n+                  New_Occurrence_Of (Proxy_Addr, Loc)))))),\n \n         Set_Field (Name_Origin,\n-          Unchecked_Convert_To (Standard_Integer,\n-            New_Occurrence_Of (Origin, Loc))),\n+            New_Occurrence_Of (Origin, Loc)),\n \n         Set_Field (Name_Receiver,\n           Make_Function_Call (Loc,\n@@ -1304,32 +1424,35 @@ package body Exp_Dist is\n             Parameter_Associations => New_List (\n               New_Occurrence_Of (Package_Name, Loc)))),\n \n-        Set_Field (Name_Subp_Id,\n-          New_Occurrence_Of (Subp_Id, Loc)),\n+        Set_Field (Name_Addr, New_Occurrence_Of (Proxy_Addr, Loc)),\n+\n+        Set_Field (Name_Asynchronous,\n+          Make_Or_Else (Loc,\n+            New_Occurrence_Of (Asynch_P, Loc),\n+            New_Occurrence_Of (Boolean_Literals (\n+              Is_Asynchronous (Ras_Type)), Loc))));\n+      --  E.4.1(9) A remote call is asynchronous if it is a call to\n+      --  a procedure, or a call through a value of an access-to-procedure\n+      --  type, to which a pragma Asynchronous applies.\n+      --  Parameter Asynch_P is true when the procedure is asynchronous;\n+      --  Expression Asynch_T is true when the type is asynchronous.\n \n-        Set_Field (Name_Async,\n-          New_Occurrence_Of (Asynch_P, Loc))));\n+      Append_List_To (Proc_Statements,\n+        Build_Get_Unique_RP_Call\n+          (Loc, Stub_Ptr, Stub_Elements.Stub_Type));\n \n       --  Return the newly created value\n \n       Append_To (Proc_Statements,\n         Make_Return_Statement (Loc,\n           Expression =>\n-            New_Occurrence_Of (Return_Value, Loc)));\n-\n-      Proc :=\n-        Make_Defining_Identifier (Loc,\n-          Chars => Make_TSS_Name (Ras_Type, TSS_RAS_Access));\n+            Unchecked_Convert_To (Fat_Type,\n+              New_Occurrence_Of (Stub_Ptr, Loc))));\n \n       Proc_Spec :=\n         Make_Function_Specification (Loc,\n           Defining_Unit_Name       => Proc,\n           Parameter_Specifications => New_List (\n-            Make_Parameter_Specification (Loc,\n-              Defining_Identifier => Local_Addr,\n-              Parameter_Type      =>\n-                New_Occurrence_Of (RTE (RE_Address), Loc)),\n-\n             Make_Parameter_Specification (Loc,\n               Defining_Identifier => Package_Name,\n               Parameter_Type      =>\n@@ -1338,7 +1461,7 @@ package body Exp_Dist is\n             Make_Parameter_Specification (Loc,\n               Defining_Identifier => Subp_Id,\n               Parameter_Type      =>\n-                New_Occurrence_Of (Standard_Natural, Loc)),\n+                New_Occurrence_Of (RTE (RE_Subprogram_Id), Loc)),\n \n             Make_Parameter_Specification (Loc,\n               Defining_Identifier => Asynch_P,\n@@ -1368,139 +1491,127 @@ package body Exp_Dist is\n               Statements => Proc_Statements)));\n \n       Set_TSS (Fat_Type, Proc);\n+   end Add_RAS_Access_TSS;\n \n-   end Add_RAS_Access_Attribute;\n-\n-   -----------------------------------\n-   -- Add_RAS_Dereference_Attribute --\n-   -----------------------------------\n+   -----------------------------\n+   -- Add_RAS_Dereference_TSS --\n+   -----------------------------\n \n-   procedure Add_RAS_Dereference_Attribute (N : in Node_Id) is\n+   procedure Add_RAS_Dereference_TSS (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n \n       Type_Def : constant Node_Id   := Type_Definition (N);\n \n-      Ras_Type : constant Entity_Id := Defining_Identifier (N);\n-\n-      Fat_Type : constant Entity_Id := Equivalent_Type (Ras_Type);\n+      RAS_Type  : constant Entity_Id := Defining_Identifier (N);\n+      Fat_Type  : constant Entity_Id := Equivalent_Type (RAS_Type);\n+      RACW_Type : constant Entity_Id := Underlying_RACW_Type (RAS_Type);\n+      Desig     : constant Entity_Id := Etype (Designated_Type (RACW_Type));\n \n-      Proc_Decls      : constant List_Id := New_List;\n-      Proc_Statements : constant List_Id := New_List;\n+      Stub_Elements : constant Stub_Structure := Stubs_Table.Get (Desig);\n+      pragma Assert (Stub_Elements /= Empty_Stub_Structure);\n \n-      Inner_Decls      : constant List_Id := New_List;\n-      Inner_Statements : constant List_Id := New_List;\n+      RACW_Primitive_Name : Node_Id;\n \n-      Direct_Statements : constant List_Id := New_List;\n+      Proc : constant Entity_Id :=\n+               Make_Defining_Identifier (Loc,\n+                 Chars => Make_TSS_Name (RAS_Type, TSS_RAS_Dereference));\n \n-      Proc        : Node_Id;\n       Proc_Spec   : Node_Id;\n-      Param_Specs : constant List_Id := New_List;\n+      Param_Specs : List_Id;\n       Param_Assoc : constant List_Id := New_List;\n+      Stmts       : constant List_Id := New_List;\n \n-      Pointer : Node_Id;\n-\n-      Converted_Ras    : Node_Id;\n-      Target_Partition : Node_Id;\n-      RPC_Receiver     : Node_Id;\n-      Subprogram_Id    : Node_Id;\n-      Asynchronous     : Node_Id;\n+      RAS_Parameter : constant Entity_Id :=\n+                        Make_Defining_Identifier (Loc,\n+                          Chars => New_Internal_Name ('P'));\n \n       Is_Function : constant Boolean :=\n                       Nkind (Type_Def) = N_Access_Function_Definition;\n \n+      Is_Degenerate : Boolean;\n+      --  Set to True if the subprogram_specification for this RAS has\n+      --  an anonymous access parameter (see Process_Remote_AST_Declaration).\n+\n       Spec : constant Node_Id := Type_Def;\n \n       Current_Parameter : Node_Id;\n \n    begin\n-      --  The way to do it is test if the Ras field is non-null and then if\n-      --  the Origin field is equal to the current partition ID (which is in\n-      --  fact Current_Package'Partition_ID). If this is the case, then it\n-      --  is safe to dereference the Ras field directly rather than\n-      --  performing a remote call.\n+      Param_Specs := New_List (\n+        Make_Parameter_Specification (Loc,\n+          Defining_Identifier => RAS_Parameter,\n+          In_Present          => True,\n+          Parameter_Type      =>\n+            New_Occurrence_Of (Fat_Type, Loc)));\n \n-      Pointer :=\n-        Make_Defining_Identifier (Loc, New_Internal_Name ('P'));\n+      Is_Degenerate := False;\n+      Current_Parameter := First (Parameter_Specifications (Type_Def));\n+      Parameters : while Current_Parameter /= Empty loop\n+         if Nkind (Parameter_Type (Current_Parameter))\n+           = N_Access_Definition\n+         then\n+            Is_Degenerate := True;\n+         end if;\n+         Append_To (Param_Specs,\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc,\n+                 Chars => Chars (Defining_Identifier (Current_Parameter))),\n+             In_Present        => In_Present (Current_Parameter),\n+             Out_Present       => Out_Present (Current_Parameter),\n+             Parameter_Type    =>\n+               New_Copy_Tree (Parameter_Type (Current_Parameter)),\n+             Expression        =>\n+               New_Copy_Tree (Expression (Current_Parameter))));\n+\n+         Append_To (Param_Assoc,\n+           Make_Identifier (Loc,\n+             Chars => Chars (Defining_Identifier (Current_Parameter))));\n \n-      Target_Partition :=\n-        Make_Defining_Identifier (Loc, New_Internal_Name ('P'));\n+         Next (Current_Parameter);\n+      end loop Parameters;\n \n-      Append_To (Proc_Decls,\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Target_Partition,\n-          Constant_Present    => True,\n-          Object_Definition   =>\n-            New_Occurrence_Of (RTE (RE_Partition_ID), Loc),\n-          Expression          =>\n-            Unchecked_Convert_To (RTE (RE_Partition_ID),\n-              Make_Selected_Component (Loc,\n-                Prefix        =>\n-                  New_Occurrence_Of (Pointer, Loc),\n-                Selector_Name =>\n-                  Make_Identifier (Loc, Name_Origin)))));\n-\n-      RPC_Receiver :=\n-        Make_Selected_Component (Loc,\n-          Prefix        =>\n-            New_Occurrence_Of (Pointer, Loc),\n-          Selector_Name =>\n-            Make_Identifier (Loc, Name_Receiver));\n-\n-      Subprogram_Id :=\n-        Unchecked_Convert_To (RTE (RE_Subprogram_Id),\n-          Make_Selected_Component (Loc,\n-            Prefix        =>\n-              New_Occurrence_Of (Pointer, Loc),\n-            Selector_Name =>\n-              Make_Identifier (Loc, Name_Subp_Id)));\n-\n-      --  A function is never asynchronous. A procedure may or may not be\n-      --  asynchronous depending on whether a pragma Asynchronous applies\n-      --  on it. Since a RAST may point onto various subprograms, this is\n-      --  only known at runtime so both versions (synchronous and asynchronous)\n-      --  must be built every times it is not a function.\n+      if Is_Degenerate then\n+         Prepend_To (Param_Assoc, New_Occurrence_Of (RAS_Parameter, Loc));\n \n-      if Is_Function then\n-         Asynchronous := Empty;\n+         --  Generate a dummy body recursing on the Dereference TSS, since\n+         --  actually it will never be executed.\n+\n+         Append_To (Stmts,\n+           Make_Raise_Program_Error (Loc, Reason => PE_Explicit_Raise));\n+         RACW_Primitive_Name := New_Occurrence_Of (Proc, Loc);\n \n       else\n-         Asynchronous :=\n+         Prepend_To (Param_Assoc,\n+           Unchecked_Convert_To (RACW_Type,\n+             New_Occurrence_Of (RAS_Parameter, Loc)));\n+\n+         RACW_Primitive_Name :=\n            Make_Selected_Component (Loc,\n-             Prefix        =>\n-               New_Occurrence_Of (Pointer, Loc),\n+             Prefix =>\n+               New_Occurrence_Of (Scope (RACW_Type), Loc),\n              Selector_Name =>\n-               Make_Identifier (Loc, Name_Async));\n-\n+               Make_Identifier (Loc, Name_Call));\n       end if;\n \n-      if Present (Parameter_Specifications (Type_Def)) then\n-         Current_Parameter := First (Parameter_Specifications (Type_Def));\n-\n-         while Current_Parameter /= Empty loop\n-            Append_To (Param_Specs,\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier =>\n-                  Make_Defining_Identifier (Loc,\n-                    Chars =>\n-                      Chars (Defining_Identifier (Current_Parameter))),\n-                    In_Present        => In_Present (Current_Parameter),\n-                    Out_Present       => Out_Present (Current_Parameter),\n-                    Parameter_Type    =>\n-                      New_Copy_Tree (Parameter_Type (Current_Parameter)),\n-                    Expression        =>\n-                      New_Copy_Tree (Expression (Current_Parameter))));\n-\n-            Append_To (Param_Assoc,\n-              Make_Identifier (Loc,\n-                Chars => Chars (Defining_Identifier (Current_Parameter))));\n+      if Is_Function then\n+         Append_To (Stmts,\n+            Make_Return_Statement (Loc,\n+              Expression =>\n+                Make_Function_Call (Loc,\n+              Name                   =>\n+                RACW_Primitive_Name,\n+              Parameter_Associations => Param_Assoc)));\n \n-            Next (Current_Parameter);\n-         end loop;\n+      else\n+         Append_To (Stmts,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   =>\n+               RACW_Primitive_Name,\n+             Parameter_Associations => Param_Assoc));\n       end if;\n \n-      Proc :=\n-        Make_Defining_Identifier (Loc,\n-          Chars => Make_TSS_Name (Ras_Type, TSS_RAS_Dereference));\n+      --  Build the complete subprogram.\n \n       if Is_Function then\n          Proc_Spec :=\n@@ -1512,7 +1623,6 @@ package body Exp_Dist is\n                  Entity (Subtype_Mark (Spec)), Loc));\n \n          Set_Ekind (Proc, E_Function);\n-\n          Set_Etype (Proc,\n            New_Occurrence_Of (Entity (Subtype_Mark (Spec)), Loc));\n \n@@ -1526,96 +1636,213 @@ package body Exp_Dist is\n          Set_Etype (Proc, Standard_Void_Type);\n       end if;\n \n-      --  Build the calling stubs for the dereference of the RAS\n+      Discard_Node (\n+        Make_Subprogram_Body (Loc,\n+          Specification              => Proc_Spec,\n+          Declarations               => New_List,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => Stmts)));\n+\n+      Set_TSS (Fat_Type, Proc);\n+   end Add_RAS_Dereference_TSS;\n \n-      Build_General_Calling_Stubs\n-        (Decls                     => Inner_Decls,\n-         Statements                => Inner_Statements,\n-         Target_Partition          => Target_Partition,\n-         RPC_Receiver              => RPC_Receiver,\n-         Subprogram_Id             => Subprogram_Id,\n-         Asynchronous              => Asynchronous,\n-         Is_Known_Non_Asynchronous => Is_Function,\n-         Is_Function               => Is_Function,\n-         Spec                      => Proc_Spec,\n-         Nod                       => N);\n-\n-      Converted_Ras :=\n-        Unchecked_Convert_To (Ras_Type,\n-          OK_Convert_To (RTE (RE_Address),\n-            Make_Selected_Component (Loc,\n-              Prefix        => New_Occurrence_Of (Pointer, Loc),\n-              Selector_Name => Make_Identifier (Loc, Name_Ras))));\n+   -------------------------------\n+   -- Add_RAS_Proxy_And_Analyze --\n+   -------------------------------\n \n-      if Is_Function then\n-         Append_To (Direct_Statements,\n-           Make_Return_Statement (Loc,\n-             Expression =>\n-               Make_Function_Call (Loc,\n-                 Name                   =>\n-                   Make_Explicit_Dereference (Loc,\n-                     Prefix => Converted_Ras),\n-                 Parameter_Associations => Param_Assoc)));\n+   procedure Add_RAS_Proxy_And_Analyze\n+     (Decls              :     List_Id;\n+      Vis_Decl           :     Node_Id;\n+      All_Calls_Remote_E :     Entity_Id;\n+      Proxy_Object_Addr  : out Entity_Id)\n+   is\n+      Loc : constant Source_Ptr := Sloc (Vis_Decl);\n \n-      else\n-         Append_To (Direct_Statements,\n+      Subp_Name : constant Entity_Id :=\n+                     Defining_Unit_Name (Specification (Vis_Decl));\n+\n+      Pkg_Name   : constant Entity_Id :=\n+                     Make_Defining_Identifier (Loc,\n+                       Chars =>\n+                         New_External_Name (Chars (Subp_Name), 'P', -1));\n+\n+      Proxy_Type : constant Entity_Id :=\n+                     Make_Defining_Identifier (Loc,\n+                       Chars =>\n+                         New_External_Name (\n+                           Related_Id => Chars (Subp_Name),\n+                           Suffix     => 'P'));\n+\n+      Proxy_Type_Full_View : constant Entity_Id :=\n+                               Make_Defining_Identifier (Loc,\n+                                 Chars (Proxy_Type));\n+\n+      Subp_Decl_Spec : constant Node_Id :=\n+                         Build_RAS_Primitive_Specification\n+                           (Subp_Spec          => Specification (Vis_Decl),\n+                            Remote_Object_Type => Proxy_Type);\n+\n+      Subp_Body_Spec : constant Node_Id :=\n+                         Build_RAS_Primitive_Specification\n+                           (Subp_Spec          => Specification (Vis_Decl),\n+                            Remote_Object_Type => Proxy_Type);\n+\n+      Vis_Decls    : constant List_Id := New_List;\n+      Pvt_Decls    : constant List_Id := New_List;\n+      Actuals      : constant List_Id := New_List;\n+      Formal       : Node_Id;\n+      Perform_Call : Node_Id;\n+\n+   begin\n+      --  type subpP is tagged limited private;\n+\n+      Append_To (Vis_Decls,\n+        Make_Private_Type_Declaration (Loc,\n+          Defining_Identifier => Proxy_Type,\n+          Tagged_Present      => True,\n+          Limited_Present     => True));\n+\n+      --  [subprogram] Call\n+      --    (Self : access subpP;\n+      --     ...other-formals...)\n+      --     [return T];\n+\n+      Append_To (Vis_Decls,\n+        Make_Subprogram_Declaration (Loc,\n+          Specification => Subp_Decl_Spec));\n+\n+      --  A : constant System.Address;\n+\n+      Proxy_Object_Addr := Make_Defining_Identifier (Loc, Name_uA);\n+\n+      Append_To (Vis_Decls,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier =>\n+            Proxy_Object_Addr,\n+          Constant_Present     =>\n+            True,\n+          Object_Definition   =>\n+            New_Occurrence_Of (RTE (RE_Address), Loc)));\n+\n+      --  private\n+\n+      --  type subpP is tagged limited record\n+      --     All_Calls_Remote : Boolean := [All_Calls_Remote?];\n+      --     ...\n+      --  end record;\n+\n+      Append_To (Pvt_Decls,\n+        Make_Full_Type_Declaration (Loc,\n+          Defining_Identifier =>\n+            Proxy_Type_Full_View,\n+          Type_Definition     =>\n+            Build_Remote_Subprogram_Proxy_Type (Loc,\n+              New_Occurrence_Of (All_Calls_Remote_E, Loc))));\n+\n+      --  Trick semantic analysis into swapping the public and\n+      --  full view when freezing the public view.\n+\n+      Set_Comes_From_Source (Proxy_Type_Full_View, True);\n+\n+\n+      --  procedure Call\n+      --    (Self : access O;\n+      --     ...other-formals...) is\n+      --  begin\n+      --    P (...other-formals...);\n+      --  end Call;\n+\n+      --  function Call\n+      --    (Self : access O;\n+      --     ...other-formals...)\n+      --     return T is\n+      --  begin\n+      --    return F (...other-formals...);\n+      --  end Call;\n+\n+      if Nkind (Subp_Decl_Spec) = N_Procedure_Specification then\n+         Perform_Call :=\n            Make_Procedure_Call_Statement (Loc,\n-             Name                   =>\n-               Make_Explicit_Dereference (Loc,\n-                 Prefix => Converted_Ras),\n-             Parameter_Associations => Param_Assoc));\n+             Name =>\n+               New_Occurrence_Of (Subp_Name, Loc),\n+             Parameter_Associations =>\n+               Actuals);\n+      else\n+         Perform_Call :=\n+           Make_Return_Statement (Loc,\n+             Expression =>\n+           Make_Function_Call (Loc,\n+             Name =>\n+               New_Occurrence_Of (Subp_Name, Loc),\n+             Parameter_Associations =>\n+               Actuals));\n       end if;\n \n-      Prepend_To (Param_Specs,\n-        Make_Parameter_Specification (Loc,\n-          Defining_Identifier => Pointer,\n-          In_Present          => True,\n-          Parameter_Type      =>\n-            New_Occurrence_Of (Fat_Type, Loc)));\n+      Formal := First (Parameter_Specifications (Subp_Decl_Spec));\n+      pragma Assert (Present (Formal));\n+      Next (Formal);\n \n-      Append_To (Proc_Statements,\n-        Make_Implicit_If_Statement (N,\n-          Condition =>\n-            Make_And_Then (Loc,\n-              Left_Opnd  =>\n-                Make_Op_Ne (Loc,\n-                  Left_Opnd  =>\n-                    Make_Selected_Component (Loc,\n-                      Prefix        => New_Occurrence_Of (Pointer, Loc),\n-                      Selector_Name => Make_Identifier (Loc, Name_Ras)),\n-                  Right_Opnd =>\n-                    Make_Integer_Literal (Loc, Uint_0)),\n+      while Present (Formal) loop\n+         Append_To (Actuals, New_Occurrence_Of (\n+           Defining_Identifier (Formal), Loc));\n+         Next (Formal);\n+      end loop;\n \n-              Right_Opnd =>\n-                Make_Op_Eq (Loc,\n-                  Left_Opnd  =>\n-                    New_Occurrence_Of (Target_Partition, Loc),\n-                  Right_Opnd =>\n-                    Make_Function_Call (Loc,\n-                      New_Occurrence_Of (\n-                        RTE (RE_Get_Local_Partition_Id), Loc)))),\n+      --  O : aliased subpP;\n \n-          Then_Statements =>\n-            Direct_Statements,\n+      Append_To (Pvt_Decls,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier =>\n+            Make_Defining_Identifier (Loc,\n+              Name_uO),\n+          Aliased_Present =>\n+            True,\n+          Object_Definition =>\n+            New_Occurrence_Of (Proxy_Type, Loc)));\n \n-          Else_Statements => New_List (\n-            Make_Block_Statement (Loc,\n-              Declarations               => Inner_Decls,\n-              Handled_Statement_Sequence =>\n-                Make_Handled_Sequence_Of_Statements (Loc,\n-                  Statements => Inner_Statements)))));\n+      --  A : constant System.Address := O'Address;\n \n-      Discard_Node (\n-        Make_Subprogram_Body (Loc,\n-          Specification              => Proc_Spec,\n-          Declarations               => Proc_Decls,\n-          Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => Proc_Statements)));\n+      Append_To (Pvt_Decls,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier =>\n+            Make_Defining_Identifier (Loc,\n+              Chars (Proxy_Object_Addr)),\n+          Constant_Present =>\n+            True,\n+          Object_Definition =>\n+            New_Occurrence_Of (RTE (RE_Address), Loc),\n+          Expression =>\n+            Make_Attribute_Reference (Loc,\n+              Prefix => New_Occurrence_Of (\n+                Defining_Identifier (Last (Pvt_Decls)), Loc),\n+              Attribute_Name =>\n+                Name_Address)));\n \n-      Set_TSS (Fat_Type, Defining_Unit_Name (Proc_Spec));\n+      Append_To (Decls,\n+        Make_Package_Declaration (Loc,\n+          Specification => Make_Package_Specification (Loc,\n+            Defining_Unit_Name   => Pkg_Name,\n+            Visible_Declarations => Vis_Decls,\n+            Private_Declarations => Pvt_Decls,\n+            End_Label            => Empty)));\n+      Analyze (Last (Decls));\n \n-   end Add_RAS_Dereference_Attribute;\n+      Append_To (Decls,\n+        Make_Package_Body (Loc,\n+          Defining_Unit_Name =>\n+            Make_Defining_Identifier (Loc,\n+              Chars (Pkg_Name)),\n+          Declarations => New_List (\n+            Make_Subprogram_Body (Loc,\n+              Specification  =>\n+                Subp_Body_Spec,\n+              Declarations   => New_List,\n+              Handled_Statement_Sequence =>\n+                Make_Handled_Sequence_Of_Statements (Loc,\n+                  Statements => New_List (Perform_Call))))));\n+      Analyze (Last (Decls));\n+   end Add_RAS_Proxy_And_Analyze;\n \n    -----------------------\n    -- Add_RAST_Features --\n@@ -1633,17 +1860,17 @@ package body Exp_Dist is\n          return;\n       end if;\n \n-      Add_RAS_Dereference_Attribute (Vis_Decl);\n-      Add_RAS_Access_Attribute (Vis_Decl);\n+      Add_RAS_Dereference_TSS (Vis_Decl);\n+      Add_RAS_Access_TSS (Vis_Decl);\n    end Add_RAST_Features;\n \n    -----------------------------------------\n    -- Add_Receiving_Stubs_To_Declarations --\n    -----------------------------------------\n \n    procedure Add_Receiving_Stubs_To_Declarations\n-     (Pkg_Spec : in Node_Id;\n-      Decls    : in List_Id)\n+     (Pkg_Spec : Node_Id;\n+      Decls    : List_Id)\n    is\n       Loc : constant Source_Ptr := Sloc (Pkg_Spec);\n \n@@ -1658,20 +1885,78 @@ package body Exp_Dist is\n       Pkg_RPC_Receiver_Body       : Node_Id;\n       --  A Pkg_RPC_Receiver is built to decode the request\n \n-      Subp_Id                     : Node_Id;\n+      Lookup_RAS_Info : constant Entity_Id :=\n+        Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n+      --  A remote subprogram is created to allow peers to look up\n+      --  RAS information using subprogram ids.\n+\n+      Subp_Id : Node_Id;\n       --  Subprogram_Id as read from the incoming stream\n \n       Current_Declaration       : Node_Id;\n-      Current_Subprogram_Number : Int := 0;\n+      Current_Subprogram_Number : Int := First_RCI_Subprogram_Id;\n       Current_Stubs             : Node_Id;\n \n-      Actuals : List_Id;\n+      Subp_Info_Array : constant Entity_Id :=\n+        Make_Defining_Identifier (Loc, New_Internal_Name ('I'));\n+\n+      Subp_Info_List : constant List_Id := New_List;\n \n       Dummy_Register_Name : Name_Id;\n       Dummy_Register_Spec : Node_Id;\n       Dummy_Register_Decl : Node_Id;\n       Dummy_Register_Body : Node_Id;\n \n+      All_Calls_Remote_E  : Entity_Id;\n+      Proxy_Object_Addr   : Entity_Id;\n+\n+      procedure Append_Stubs_To\n+        (RPC_Receiver_Cases : List_Id;\n+         Declaration        : Node_Id;\n+         Stubs              : Node_Id;\n+         Subprogram_Number  : Int);\n+      --  Add one case to the specified RPC receiver case list\n+      --  associating Subprogram_Number with the subprogram declared\n+      --  by Declaration, for which we have receiving stubs in Stubs.\n+\n+      procedure Append_Stubs_To\n+        (RPC_Receiver_Cases : List_Id;\n+         Declaration        : Node_Id;\n+         Stubs              : Node_Id;\n+         Subprogram_Number  : Int)\n+      is\n+         Actuals : constant List_Id :=\n+                     New_List (New_Occurrence_Of (Stream_Parameter, Loc));\n+      begin\n+         if Nkind (Specification (Declaration)) = N_Function_Specification\n+           or else not\n+             Is_Asynchronous (Defining_Entity (Specification (Declaration)))\n+         then\n+            --  An asynchronous procedure does not want an output parameter\n+            --  since no result and no exception will ever be returned.\n+\n+            Append_To (Actuals,\n+              New_Occurrence_Of (Result_Parameter, Loc));\n+         end if;\n+\n+         Append_To (RPC_Receiver_Cases,\n+           Make_Case_Statement_Alternative (Loc,\n+             Discrete_Choices =>\n+                New_List (\n+                  Make_Integer_Literal (Loc, Subprogram_Number)),\n+\n+             Statements       =>\n+               New_List (\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name                   =>\n+                     New_Occurrence_Of (\n+                       Defining_Entity (Stubs), Loc),\n+                   Parameter_Associations =>\n+                     Actuals))));\n+      end Append_Stubs_To;\n+\n+   --  Start of processing for Add_Receiving_Stubs_To_Declarations\n+\n    begin\n       --  Building receiving stubs consist in several operations:\n \n@@ -1724,21 +2009,87 @@ package body Exp_Dist is\n             New_Occurrence_Of (Stream_Parameter, Loc),\n             New_Occurrence_Of (Subp_Id, Loc))));\n \n+      --  A null subp_id denotes a call through a RAS, in which case the\n+      --  next Uint_64 element in the stream is the address of the local\n+      --  proxy object, from which we can retrieve the actual subprogram id.\n+\n+      Append_To (Pkg_RPC_Receiver_Statements,\n+        Make_Implicit_If_Statement (Pkg_Spec,\n+          Condition =>\n+            Make_Op_Eq (Loc,\n+              New_Occurrence_Of (Subp_Id, Loc),\n+              Make_Integer_Literal (Loc, 0)),\n+          Then_Statements => New_List (\n+            Make_Assignment_Statement (Loc,\n+              Name =>\n+                New_Occurrence_Of (Subp_Id, Loc),\n+              Expression =>\n+                Make_Selected_Component (Loc,\n+                  Prefix =>\n+                    Unchecked_Convert_To (RTE (RE_RAS_Proxy_Type_Access),\n+                      OK_Convert_To (RTE (RE_Address),\n+                        Make_Attribute_Reference (Loc,\n+                          Prefix =>\n+                            New_Occurrence_Of (RTE (RE_Unsigned_64), Loc),\n+                          Attribute_Name =>\n+                            Name_Input,\n+                          Expressions => New_List (\n+                            New_Occurrence_Of (Stream_Parameter, Loc))))),\n+                  Selector_Name =>\n+                    Make_Identifier (Loc, Name_Subp_Id))))));\n+\n+      All_Calls_Remote_E := Boolean_Literals (\n+        Has_All_Calls_Remote (Defining_Entity (Pkg_Spec)));\n+\n+      --  Build a subprogram for RAS information lookups\n+\n+      Current_Declaration :=\n+        Make_Subprogram_Declaration (Loc,\n+          Specification =>\n+            Make_Function_Specification (Loc,\n+              Defining_Unit_Name =>\n+                Lookup_RAS_Info,\n+              Parameter_Specifications => New_List (\n+                Make_Parameter_Specification (Loc,\n+                  Defining_Identifier =>\n+                    Make_Defining_Identifier (Loc, Name_Subp_Id),\n+                  In_Present =>\n+                    True,\n+                  Parameter_Type =>\n+                    New_Occurrence_Of (RTE (RE_Subprogram_Id), Loc))),\n+              Subtype_Mark =>\n+                New_Occurrence_Of (RTE (RE_Unsigned_64), Loc)));\n+      Append_To (Decls, Current_Declaration);\n+      Analyze (Current_Declaration);\n+\n+      Current_Stubs := Build_Subprogram_Receiving_Stubs\n+        (Vis_Decl     => Current_Declaration,\n+         Asynchronous => False);\n+      Append_To (Decls, Current_Stubs);\n+      Analyze (Current_Stubs);\n+\n+      Append_Stubs_To (Pkg_RPC_Receiver_Cases,\n+        Declaration =>\n+          Current_Declaration,\n+        Stubs       =>\n+          Current_Stubs,\n+        Subprogram_Number => 1);\n+\n       --  For each subprogram, the receiving stub will be built and a\n       --  case statement will be made on the Subprogram_Id to dispatch\n       --  to the right subprogram.\n \n       Current_Declaration := First (Visible_Declarations (Pkg_Spec));\n-\n       while Current_Declaration /= Empty loop\n-\n          if Nkind (Current_Declaration) = N_Subprogram_Declaration\n            and then Comes_From_Source (Current_Declaration)\n          then\n             pragma Assert (Current_Subprogram_Number =\n               Get_Subprogram_Id (Defining_Unit_Name (Specification (\n                 Current_Declaration))));\n \n+            --  Build receiving stub\n+\n             Current_Stubs :=\n               Build_Subprogram_Receiving_Stubs\n                 (Vis_Decl     => Current_Declaration,\n@@ -1750,40 +2101,44 @@ package body Exp_Dist is\n                           (Current_Declaration))));\n \n             Append_To (Decls, Current_Stubs);\n-\n             Analyze (Current_Stubs);\n \n-            Actuals := New_List (New_Occurrence_Of (Stream_Parameter, Loc));\n-\n-            if Nkind (Specification (Current_Declaration))\n-                = N_Function_Specification\n-              or else\n-                not Is_Asynchronous (\n-                  Defining_Entity (Specification (Current_Declaration)))\n-            then\n-               --  An asynchronous procedure does not want an output parameter\n-               --  since no result and no exception will ever be returned.\n-\n-               Append_To (Actuals,\n-                 New_Occurrence_Of (Result_Parameter, Loc));\n-\n-            end if;\n-\n-            Append_To (Pkg_RPC_Receiver_Cases,\n-              Make_Case_Statement_Alternative (Loc,\n-                Discrete_Choices =>\n-                  New_List (\n-                    Make_Integer_Literal (Loc, Current_Subprogram_Number)),\n-\n-                Statements       =>\n-                  New_List (\n-                    Make_Procedure_Call_Statement (Loc,\n-                      Name                   =>\n-                        New_Occurrence_Of (\n-                          Defining_Entity (Current_Stubs), Loc),\n-                      Parameter_Associations =>\n-                        Actuals))));\n-\n+            --  Build RAS proxy\n+\n+            Add_RAS_Proxy_And_Analyze (Decls,\n+              Vis_Decl           =>\n+                Current_Declaration,\n+              All_Calls_Remote_E =>\n+                All_Calls_Remote_E,\n+              Proxy_Object_Addr  =>\n+                Proxy_Object_Addr);\n+\n+            --  Add subprogram descriptor (RCI_Subp_Info) to the\n+            --  subprograms table for this receiver. The aggregate\n+            --  below must be kept consistent with the declaration\n+            --  of type RCI_Subp_Info in System.Partition_Interface.\n+\n+            Append_To (Subp_Info_List,\n+              Make_Component_Association (Loc,\n+                Choices => New_List (\n+                  Make_Integer_Literal (Loc,\n+                    Current_Subprogram_Number)),\n+                Expression =>\n+                  Make_Aggregate (Loc,\n+                    Component_Associations => New_List (\n+                      Make_Component_Association (Loc,\n+                        Choices => New_List (\n+                          Make_Identifier (Loc, Name_Addr)),\n+                        Expression =>\n+                          New_Occurrence_Of (Proxy_Object_Addr, Loc))))));\n+\n+            Append_Stubs_To (Pkg_RPC_Receiver_Cases,\n+              Declaration =>\n+                Current_Declaration,\n+              Stubs =>\n+                Current_Stubs,\n+              Subprogram_Number =>\n+                Current_Subprogram_Number);\n             Current_Subprogram_Number := Current_Subprogram_Number + 1;\n          end if;\n \n@@ -1811,6 +2166,53 @@ package body Exp_Dist is\n             New_Occurrence_Of (Subp_Id, Loc),\n           Alternatives => Pkg_RPC_Receiver_Cases));\n \n+      Append_To (Decls,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Subp_Info_Array,\n+          Constant_Present    => True,\n+          Aliased_Present     => True,\n+          Object_Definition   =>\n+            Make_Subtype_Indication (Loc,\n+              Subtype_Mark =>\n+                New_Occurrence_Of (RTE (RE_RCI_Subp_Info_Array), Loc),\n+              Constraint =>\n+                Make_Index_Or_Discriminant_Constraint (Loc,\n+                  New_List (\n+                    Make_Range (Loc,\n+                      Low_Bound  => Make_Integer_Literal (Loc,\n+                        First_RCI_Subprogram_Id),\n+                      High_Bound =>\n+                        Make_Integer_Literal (Loc,\n+                          First_RCI_Subprogram_Id\n+                          + List_Length (Subp_Info_List) - 1))))),\n+          Expression          =>\n+            Make_Aggregate (Loc,\n+              Component_Associations => Subp_Info_List)));\n+      Analyze (Last (Decls));\n+\n+      Append_To (Decls,\n+        Make_Subprogram_Body (Loc,\n+          Specification =>\n+            Copy_Specification (Loc, Parent (Lookup_RAS_Info)),\n+          Declarations =>\n+            No_List,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => New_List (\n+                Make_Return_Statement (Loc,\n+                  Expression => OK_Convert_To (RTE (RE_Unsigned_64),\n+                    Make_Selected_Component (Loc,\n+                      Prefix =>\n+                        Make_Indexed_Component (Loc,\n+                          Prefix =>\n+                            New_Occurrence_Of (Subp_Info_Array, Loc),\n+                          Expressions => New_List (\n+                            Convert_To (Standard_Integer,\n+                              Make_Identifier (Loc, Name_Subp_Id)))),\n+                      Selector_Name =>\n+                        Make_Identifier (Loc, Name_Addr))))))));\n+      Analyze (Last (Decls));\n+\n       Pkg_RPC_Receiver_Body :=\n         Make_Subprogram_Body (Loc,\n           Specification              => Pkg_RPC_Receiver_Spec,\n@@ -1867,7 +2269,17 @@ package body Exp_Dist is\n                       Prefix         =>\n                         New_Occurrence_Of (Defining_Entity (Pkg_Spec), Loc),\n                       Attribute_Name =>\n-                        Name_Version))))));\n+                        Name_Version),\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix =>\n+                        New_Occurrence_Of (Subp_Info_Array, Loc),\n+                      Attribute_Name =>\n+                        Name_Address),\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix =>\n+                        New_Occurrence_Of (Subp_Info_Array, Loc),\n+                      Attribute_Name =>\n+                        Name_Length))))));\n \n       Append_To (Decls, Dummy_Register_Body);\n       Analyze (Dummy_Register_Body);\n@@ -1878,9 +2290,9 @@ package body Exp_Dist is\n    -------------------\n \n    procedure Add_Stub_Type\n-     (Designated_Type     : in Entity_Id;\n-      RACW_Type           : in Entity_Id;\n-      Decls               : in List_Id;\n+     (Designated_Type     : Entity_Id;\n+      RACW_Type           : Entity_Id;\n+      Decls               : List_Id;\n       Stub_Type           : out Entity_Id;\n       Stub_Type_Access    : out Entity_Id;\n       Object_RPC_Receiver : out Entity_Id;\n@@ -1992,6 +2404,7 @@ package body Exp_Dist is\n           Defining_Identifier => Stub_Type_Access,\n           Type_Definition     =>\n             Make_Access_To_Object_Definition (Loc,\n+              All_Present        => True,\n               Subtype_Indication => New_Occurrence_Of (Stub_Type, Loc)));\n \n       Append_To (Decls, Stub_Type_Access_Declaration);\n@@ -2152,19 +2565,16 @@ package body Exp_Dist is\n             Subprogram_Id)));\n \n       Current_Parameter := First (Ordered_Parameters_List);\n-\n       while Current_Parameter /= Empty loop\n-\n          declare\n             Typ             : constant Node_Id :=\n-              Parameter_Type (Current_Parameter);\n+                                Parameter_Type (Current_Parameter);\n             Etyp            : Entity_Id;\n             Constrained     : Boolean;\n             Value           : Node_Id;\n             Extra_Parameter : Entity_Id;\n \n          begin\n-\n             if Is_RACW_Controlling_Formal (Current_Parameter, Object_Type) then\n \n                --  In the case of a controlling formal argument, we marshall\n@@ -2370,19 +2780,18 @@ package body Exp_Dist is\n             --  have changed since they are remote, so we do not read them\n             --  from the stream.\n \n-            Current_Parameter :=\n-              First (Ordered_Parameters_List);\n-\n+            Current_Parameter := First (Ordered_Parameters_List);\n             while Current_Parameter /= Empty loop\n-\n                declare\n                   Typ   : constant Node_Id :=\n-                    Parameter_Type (Current_Parameter);\n+                            Parameter_Type (Current_Parameter);\n                   Etyp  : Entity_Id;\n                   Value : Node_Id;\n+\n                begin\n-                  Value := New_Occurrence_Of\n-                    (Defining_Identifier (Current_Parameter), Loc);\n+                  Value :=\n+                    New_Occurrence_Of\n+                      (Defining_Identifier (Current_Parameter), Loc);\n \n                   if Nkind (Typ) = N_Access_Definition then\n                      Value := Make_Explicit_Dereference (Loc, Value);\n@@ -2392,7 +2801,7 @@ package body Exp_Dist is\n                   end if;\n \n                   if (Out_Present (Current_Parameter)\n-                      or else Nkind (Typ) = N_Access_Definition)\n+                       or else Nkind (Typ) = N_Access_Definition)\n                     and then Etyp /= Object_Type\n                   then\n                      Append_To (Non_Asynchronous_Statements,\n@@ -2434,6 +2843,7 @@ package body Exp_Dist is\n                  Prefix         => New_Occurrence_Of (Stream_Parameter, Loc),\n                  Attribute_Name => Name_Access),\n                New_Occurrence_Of (Standard_True, Loc))));\n+\n          Prepend_To (Non_Asynchronous_Statements,\n            Make_Attribute_Reference (Loc,\n              Prefix         => New_Occurrence_Of (Standard_Boolean, Loc),\n@@ -2443,6 +2853,7 @@ package body Exp_Dist is\n                  Prefix         => New_Occurrence_Of (Stream_Parameter, Loc),\n                  Attribute_Name => Name_Access),\n                New_Occurrence_Of (Standard_False, Loc))));\n+\n          Append_To (Statements,\n            Make_Implicit_If_Statement (Nod,\n              Condition       => Asynchronous,\n@@ -2451,6 +2862,86 @@ package body Exp_Dist is\n       end if;\n    end Build_General_Calling_Stubs;\n \n+   ------------------------------\n+   -- Build_Get_Unique_RP_Call --\n+   ------------------------------\n+\n+   function Build_Get_Unique_RP_Call\n+     (Loc       : Source_Ptr;\n+      Pointer   : Entity_Id;\n+      Stub_Type : Entity_Id) return List_Id\n+   is\n+   begin\n+      return New_List (\n+        Make_Procedure_Call_Statement (Loc,\n+          Name                   =>\n+            New_Occurrence_Of (RTE (RE_Get_Unique_Remote_Pointer), Loc),\n+          Parameter_Associations => New_List (\n+            Unchecked_Convert_To (RTE (RE_RACW_Stub_Type_Access),\n+              New_Occurrence_Of (Pointer, Loc)))),\n+\n+        Make_Assignment_Statement (Loc,\n+          Name =>\n+            Make_Selected_Component (Loc,\n+              Prefix =>\n+                New_Occurrence_Of (Pointer, Loc),\n+              Selector_Name =>\n+                New_Occurrence_Of (Tag_Component\n+                  (Designated_Type (Etype (Pointer))), Loc)),\n+          Expression =>\n+            Make_Attribute_Reference (Loc,\n+              Prefix =>\n+                New_Occurrence_Of (Stub_Type, Loc),\n+              Attribute_Name =>\n+                Name_Tag)));\n+\n+      --  Note: The assignment to Pointer._Tag is safe here because\n+      --  we carefully ensured that Stub_Type has exactly the same layout\n+      --  as System.Partition_Interface.RACW_Stub_Type.\n+\n+   end Build_Get_Unique_RP_Call;\n+\n+   ----------------------------------------\n+   -- Build_Remote_Subprogram_Proxy_Type --\n+   ----------------------------------------\n+\n+   function Build_Remote_Subprogram_Proxy_Type\n+     (Loc            : Source_Ptr;\n+      ACR_Expression : Node_Id) return Node_Id\n+   is\n+   begin\n+      return\n+        Make_Record_Definition (Loc,\n+          Tagged_Present  => True,\n+          Limited_Present => True,\n+          Component_List  =>\n+            Make_Component_List (Loc,\n+\n+              Component_Items => New_List (\n+                Make_Component_Declaration (Loc,\n+                  Make_Defining_Identifier (Loc,\n+                    Name_All_Calls_Remote),\n+                  Make_Component_Definition (Loc,\n+                    Subtype_Indication =>\n+                      New_Occurrence_Of (Standard_Boolean, Loc)),\n+                  ACR_Expression),\n+\n+                Make_Component_Declaration (Loc,\n+                  Make_Defining_Identifier (Loc,\n+                    Name_Receiver),\n+                  Make_Component_Definition (Loc,\n+                    Subtype_Indication =>\n+                      New_Occurrence_Of (RTE (RE_Address), Loc)),\n+                  New_Occurrence_Of (RTE (RE_Null_Address), Loc)),\n+\n+                Make_Component_Declaration (Loc,\n+                  Make_Defining_Identifier (Loc,\n+                    Name_Subp_Id),\n+                  Make_Component_Definition (Loc,\n+                    Subtype_Indication =>\n+                      New_Occurrence_Of (RTE (RE_Subprogram_Id), Loc))))));\n+   end Build_Remote_Subprogram_Proxy_Type;\n+\n    -----------------------------------\n    -- Build_Ordered_Parameters_List --\n    -----------------------------------\n@@ -2460,24 +2951,34 @@ package body Exp_Dist is\n       Unconstrained_List : List_Id;\n       Current_Parameter  : Node_Id;\n \n+      First_Parameter : Node_Id;\n+      For_RAS         : Boolean := False;\n+\n    begin\n       if not Present (Parameter_Specifications (Spec)) then\n          return New_List;\n       end if;\n \n       Constrained_List   := New_List;\n       Unconstrained_List := New_List;\n+      First_Parameter    := First (Parameter_Specifications (Spec));\n+\n+      if Nkind (Parameter_Type (First_Parameter)) = N_Access_Definition\n+        and then Chars (Defining_Identifier (First_Parameter)) = Name_uS\n+      then\n+         For_RAS := True;\n+      end if;\n \n       --  Loop through the parameters and add them to the right list\n \n-      Current_Parameter := First (Parameter_Specifications (Spec));\n+      Current_Parameter := First_Parameter;\n       while Current_Parameter /= Empty loop\n-\n-         if Nkind (Parameter_Type (Current_Parameter)) = N_Access_Definition\n+         if (Nkind (Parameter_Type (Current_Parameter)) = N_Access_Definition\n              or else\n-           Is_Constrained (Etype (Parameter_Type (Current_Parameter)))\n+               Is_Constrained (Etype (Parameter_Type (Current_Parameter)))\n              or else\n-           Is_Elementary_Type (Etype (Parameter_Type (Current_Parameter)))\n+               Is_Elementary_Type (Etype (Parameter_Type (Current_Parameter))))\n+           and then not (For_RAS and then Current_Parameter = First_Parameter)\n          then\n             Append_To (Constrained_List, New_Copy (Current_Parameter));\n          else\n@@ -2492,7 +2993,6 @@ package body Exp_Dist is\n       Append_List_To (Unconstrained_List, Constrained_List);\n \n       return Unconstrained_List;\n-\n    end Build_Ordered_Parameters_List;\n \n    ----------------------------------\n@@ -2512,7 +3012,6 @@ package body Exp_Dist is\n       declare\n          Dist_OK : Entity_Id;\n          pragma Warnings (Off, Dist_OK);\n-\n       begin\n          Dist_OK := RTE (RE_Params_Stream_Type);\n       end;\n@@ -2549,8 +3048,7 @@ package body Exp_Dist is\n    function Build_RPC_Receiver_Specification\n      (RPC_Receiver     : Entity_Id;\n       Stream_Parameter : Entity_Id;\n-      Result_Parameter : Entity_Id)\n-      return             Node_Id\n+      Result_Parameter : Entity_Id) return Node_Id\n    is\n       Loc : constant Source_Ptr := Sloc (RPC_Receiver);\n \n@@ -2586,8 +3084,7 @@ package body Exp_Dist is\n       Dynamically_Asynchronous : Boolean   := False;\n       Stub_Type                : Entity_Id := Empty;\n       Locator                  : Entity_Id := Empty;\n-      New_Name                 : Name_Id   := No_Name)\n-      return                     Node_Id\n+      New_Name                 : Name_Id   := No_Name) return Node_Id\n    is\n       Loc : constant Source_Ptr := Sloc (Vis_Decl);\n \n@@ -2609,15 +3106,15 @@ package body Exp_Dist is\n \n       Spec_To_Use : Node_Id;\n \n-      procedure Insert_Partition_Check (Parameter : in Node_Id);\n+      procedure Insert_Partition_Check (Parameter : Node_Id);\n       --  Check that the parameter has been elaborated on the same partition\n       --  than the controlling parameter (E.4(19)).\n \n       ----------------------------\n       -- Insert_Partition_Check --\n       ----------------------------\n \n-      procedure Insert_Partition_Check (Parameter : in Node_Id) is\n+      procedure Insert_Partition_Check (Parameter : Node_Id) is\n          Parameter_Entity  : constant Entity_Id :=\n                                Defining_Identifier (Parameter);\n          Condition         : Node_Id;\n@@ -2633,7 +3130,7 @@ package body Exp_Dist is\n          --    then\n          --      raise Constraint_Error;\n          --    end if;\n-         --\n+\n          --  Condition contains the reversed condition. Also, Parameter is\n          --  dereferenced if it is an access type. We do not check that\n          --  Parameter is in Stub_Type since such a check has been inserted\n@@ -2827,8 +3324,7 @@ package body Exp_Dist is\n       Dynamically_Asynchronous : Boolean   := False;\n       Stub_Type                : Entity_Id := Empty;\n       RACW_Type                : Entity_Id := Empty;\n-      Parent_Primitive         : Entity_Id := Empty)\n-      return Node_Id\n+      Parent_Primitive         : Entity_Id := Empty) return Node_Id\n    is\n       Loc : constant Source_Ptr := Sloc (Vis_Decl);\n \n@@ -2935,6 +3431,7 @@ package body Exp_Dist is\n \n          declare\n             Etyp        : Entity_Id;\n+            RACW_Controlling : Boolean;\n             Constrained : Boolean;\n             Object      : Entity_Id;\n             Expr        : Node_Id := Empty;\n@@ -2943,9 +3440,11 @@ package body Exp_Dist is\n             Object := Make_Defining_Identifier (Loc, New_Internal_Name ('P'));\n             Set_Ekind (Object, E_Variable);\n \n-            if\n-              Is_RACW_Controlling_Formal (Current_Parameter, Stub_Type)\n-            then\n+            RACW_Controlling :=\n+              Is_RACW_Controlling_Formal (Current_Parameter, Stub_Type);\n+\n+            if RACW_Controlling then\n+\n                --  We have a controlling formal parameter. Read its address\n                --  rather than a real object. The address is in Unsigned_64\n                --  form.\n@@ -2959,16 +3458,17 @@ package body Exp_Dist is\n               Is_Constrained (Etyp) or else Is_Elementary_Type (Etyp);\n \n             if In_Present (Current_Parameter)\n-               or else not Out_Present (Current_Parameter)\n-               or else not Constrained\n+              or else not Out_Present (Current_Parameter)\n+              or else not Constrained\n+              or else RACW_Controlling\n             then\n                --  If an input parameter is contrained, then its reading is\n                --  deferred until the beginning of the subprogram body. If\n                --  it is unconstrained, then an expression is built for\n                --  the object declaration and the variable is set using\n                --  'Input instead of 'Read.\n \n-               if Constrained then\n+               if Constrained and then not RACW_Controlling then\n                   Append_To (Statements,\n                     Make_Attribute_Reference (Loc,\n                       Prefix         => New_Occurrence_Of (Etyp, Loc),\n@@ -3024,7 +3524,6 @@ package body Exp_Dist is\n             if\n               Is_RACW_Controlling_Formal (Current_Parameter, Stub_Type)\n             then\n-\n                if Nkind (Parameter_Type (Current_Parameter)) /=\n                  N_Access_Definition\n                then\n@@ -3038,6 +3537,7 @@ package body Exp_Dist is\n                           Unchecked_Convert_To (RACW_Type,\n                             OK_Convert_To (RTE (RE_Address),\n                               New_Occurrence_Of (Object, Loc))))));\n+\n                else\n                   Append_To (Parameter_List,\n                     Make_Parameter_Association (Loc,\n@@ -3049,6 +3549,7 @@ package body Exp_Dist is\n                           OK_Convert_To (RTE (RE_Address),\n                             New_Occurrence_Of (Object, Loc)))));\n                end if;\n+\n             else\n                Append_To (Parameter_List,\n                  Make_Parameter_Association (Loc,\n@@ -3178,7 +3679,6 @@ package body Exp_Dist is\n              Parameter_Associations => Parameter_List));\n \n          Append_List_To (Statements, After_Statements);\n-\n       end if;\n \n       if Asynchronous and then not Dynamically_Asynchronous then\n@@ -3266,7 +3766,6 @@ package body Exp_Dist is\n             Make_Handled_Sequence_Of_Statements (Loc,\n               Statements         => Statements,\n               Exception_Handlers => New_List (Excep_Handler)));\n-\n    end Build_Subprogram_Receiving_Stubs;\n \n    ------------------------\n@@ -3278,49 +3777,50 @@ package body Exp_Dist is\n       Spec        : Node_Id;\n       Object_Type : Entity_Id := Empty;\n       Stub_Type   : Entity_Id := Empty;\n-      New_Name    : Name_Id   := No_Name)\n-      return        Node_Id\n+      New_Name    : Name_Id   := No_Name) return Node_Id\n    is\n       Parameters : List_Id := No_List;\n \n-      Current_Parameter : Node_Id;\n-      Current_Type      : Node_Id;\n-      Current_Etype     : Entity_Id;\n+      Current_Parameter  : Node_Id;\n+      Current_Identifier : Entity_Id;\n+      Current_Type       : Node_Id;\n+      Current_Etype      : Entity_Id;\n \n       Name_For_New_Spec : Name_Id;\n \n       New_Identifier : Entity_Id;\n \n    begin\n       if New_Name = No_Name then\n+         pragma Assert (Nkind (Spec) = N_Function_Specification\n+                or else Nkind (Spec) = N_Procedure_Specification);\n+\n          Name_For_New_Spec := Chars (Defining_Unit_Name (Spec));\n       else\n          Name_For_New_Spec := New_Name;\n       end if;\n \n       if Present (Parameter_Specifications (Spec)) then\n-\n          Parameters        := New_List;\n          Current_Parameter := First (Parameter_Specifications (Spec));\n-\n          while Current_Parameter /= Empty loop\n-\n-            Current_Type := Parameter_Type (Current_Parameter);\n+            Current_Identifier := Defining_Identifier (Current_Parameter);\n+            Current_Type       := Parameter_Type (Current_Parameter);\n \n             if Nkind (Current_Type) = N_Access_Definition then\n                Current_Etype := Entity (Subtype_Mark (Current_Type));\n \n-               if Object_Type = Empty then\n+               if Present (Object_Type) then\n+                  pragma Assert (\n+                    Root_Type (Current_Etype) = Root_Type (Object_Type));\n                   Current_Type :=\n                     Make_Access_Definition (Loc,\n-                      Subtype_Mark =>\n-                        New_Occurrence_Of (Current_Etype, Loc));\n+                      Subtype_Mark => New_Occurrence_Of (Stub_Type, Loc));\n                else\n-                  pragma Assert\n-                    (Root_Type (Current_Etype) = Root_Type (Object_Type));\n                   Current_Type :=\n                     Make_Access_Definition (Loc,\n-                      Subtype_Mark => New_Occurrence_Of (Stub_Type, Loc));\n+                      Subtype_Mark =>\n+                        New_Occurrence_Of (Current_Etype, Loc));\n                end if;\n \n             else\n@@ -3336,7 +3836,7 @@ package body Exp_Dist is\n             end if;\n \n             New_Identifier := Make_Defining_Identifier (Loc,\n-              Chars (Defining_Identifier (Current_Parameter)));\n+              Chars (Current_Identifier));\n \n             Append_To (Parameters,\n               Make_Parameter_Specification (Loc,\n@@ -3351,25 +3851,29 @@ package body Exp_Dist is\n          end loop;\n       end if;\n \n-      if Nkind (Spec) = N_Function_Specification then\n-         return\n-           Make_Function_Specification (Loc,\n-             Defining_Unit_Name       =>\n-               Make_Defining_Identifier (Loc,\n-                 Chars => Name_For_New_Spec),\n-             Parameter_Specifications => Parameters,\n-             Subtype_Mark             =>\n-               New_Occurrence_Of (Entity (Subtype_Mark (Spec)), Loc));\n+      case Nkind (Spec) is\n \n-      else\n-         return\n-           Make_Procedure_Specification (Loc,\n-             Defining_Unit_Name       =>\n-               Make_Defining_Identifier (Loc,\n-                 Chars => Name_For_New_Spec),\n-             Parameter_Specifications => Parameters);\n-      end if;\n+         when N_Function_Specification | N_Access_Function_Definition =>\n+            return\n+              Make_Function_Specification (Loc,\n+                Defining_Unit_Name       =>\n+                  Make_Defining_Identifier (Loc,\n+                    Chars => Name_For_New_Spec),\n+                Parameter_Specifications => Parameters,\n+                Subtype_Mark             =>\n+                  New_Occurrence_Of (Entity (Subtype_Mark (Spec)), Loc));\n+\n+         when N_Procedure_Specification | N_Access_Procedure_Definition =>\n+            return\n+              Make_Procedure_Specification (Loc,\n+                Defining_Unit_Name       =>\n+                  Make_Defining_Identifier (Loc,\n+                    Chars => Name_For_New_Spec),\n+                Parameter_Specifications => Parameters);\n \n+         when others =>\n+            raise Program_Error;\n+      end case;\n    end Copy_Specification;\n \n    ---------------------------\n@@ -3398,7 +3902,7 @@ package body Exp_Dist is\n    -- Expand_All_Calls_Remote_Subprogram_Call --\n    ---------------------------------------------\n \n-   procedure Expand_All_Calls_Remote_Subprogram_Call (N : in Node_Id) is\n+   procedure Expand_All_Calls_Remote_Subprogram_Call (N : Node_Id) is\n       Called_Subprogram : constant Entity_Id  := Entity (Name (N));\n       RCI_Package       : constant Entity_Id  := Scope (Called_Subprogram);\n       Loc               : constant Source_Ptr := Sloc (N);\n@@ -3468,7 +3972,7 @@ package body Exp_Dist is\n    -- Expand_Calling_Stubs_Bodies --\n    ---------------------------------\n \n-   procedure Expand_Calling_Stubs_Bodies (Unit_Node : in Node_Id) is\n+   procedure Expand_Calling_Stubs_Bodies (Unit_Node : Node_Id) is\n       Spec  : constant Node_Id := Specification (Unit_Node);\n       Decls : constant List_Id := Visible_Declarations (Spec);\n \n@@ -3483,7 +3987,7 @@ package body Exp_Dist is\n    -- Expand_Receiving_Stubs_Bodies --\n    -----------------------------------\n \n-   procedure Expand_Receiving_Stubs_Bodies (Unit_Node : in Node_Id) is\n+   procedure Expand_Receiving_Stubs_Bodies (Unit_Node : Node_Id) is\n       Spec  : Node_Id;\n       Decls : List_Id;\n       Temp  : List_Id;\n@@ -3543,7 +4047,7 @@ package body Exp_Dist is\n \n    function Get_Subprogram_Id (E : Entity_Id) return Int is\n       Current_Declaration : Node_Id;\n-      Result              : Int := 0;\n+      Result              : Int := First_RCI_Subprogram_Id;\n \n    begin\n       pragma Assert\n@@ -3698,8 +4202,7 @@ package body Exp_Dist is\n      (Loc    : Source_Ptr;\n       Stream : Node_Id;\n       Object : Entity_Id;\n-      Etyp   : Entity_Id := Empty)\n-      return   Node_Id\n+      Etyp   : Entity_Id := Empty) return Node_Id\n    is\n       Typ : Entity_Id;\n \n@@ -3725,8 +4228,7 @@ package body Exp_Dist is\n      (Loc    : Source_Ptr;\n       Stream : Entity_Id;\n       Object : Node_Id;\n-      Etyp   : Entity_Id)\n-      return   Node_Id\n+      Etyp   : Entity_Id) return Node_Id\n    is\n       Write_Attribute : Name_Id := Name_Write;\n \n@@ -3754,8 +4256,7 @@ package body Exp_Dist is\n      (Loc    : Source_Ptr;\n       Stream : Node_Id;\n       Object : Node_Id;\n-      Etyp   : Entity_Id)\n-      return   Node_Id\n+      Etyp   : Entity_Id) return Node_Id\n    is\n       Write_Attribute : Name_Id := Name_Write;\n \n@@ -3777,10 +4278,9 @@ package body Exp_Dist is\n    -- RACW_Type_Is_Asynchronous --\n    -------------------------------\n \n-   procedure RACW_Type_Is_Asynchronous (RACW_Type : in Entity_Id) is\n+   procedure RACW_Type_Is_Asynchronous (RACW_Type : Entity_Id) is\n       N : constant Node_Id := Asynchronous_Flags_Table.Get (RACW_Type);\n       pragma Assert (N /= Empty);\n-\n    begin\n       Replace (N, New_Occurrence_Of (Standard_True, Sloc (N)));\n    end RACW_Type_Is_Asynchronous;\n@@ -3791,8 +4291,7 @@ package body Exp_Dist is\n \n    function RCI_Package_Locator\n      (Loc          : Source_Ptr;\n-      Package_Spec : Node_Id)\n-      return         Node_Id\n+      Package_Spec : Node_Id) return Node_Id\n    is\n       Inst : constant Node_Id :=\n                Make_Package_Instantiation (Loc,\n@@ -3819,7 +4318,7 @@ package body Exp_Dist is\n    -----------------------------------------------\n \n    procedure Remote_Types_Tagged_Full_View_Encountered\n-     (Full_View : in Entity_Id)\n+     (Full_View : Entity_Id)\n    is\n       Stub_Elements : constant Stub_Structure :=\n                         Stubs_Table.Get (Full_View);\n@@ -3848,4 +4347,26 @@ package body Exp_Dist is\n       return Unit_Name;\n    end Scope_Of_Spec;\n \n+   --------------------------\n+   -- Underlying_RACW_Type --\n+   --------------------------\n+\n+   function Underlying_RACW_Type (RAS_Typ : Entity_Id) return Entity_Id is\n+      Record_Type : Entity_Id;\n+\n+   begin\n+      if Ekind (RAS_Typ) = E_Record_Type then\n+         Record_Type := RAS_Typ;\n+      else\n+         pragma Assert (Present (Equivalent_Type (RAS_Typ)));\n+         Record_Type := Equivalent_Type (RAS_Typ);\n+      end if;\n+\n+      return\n+        Etype (Subtype_Indication (\n+          Component_Definition (\n+           First (Component_Items (Component_List (\n+            Type_Definition (Declaration_Node (Record_Type))))))));\n+   end Underlying_RACW_Type;\n+\n end Exp_Dist;"}, {"sha": "7d11ce34c0f8ea6a40859102026dfd5105fe7df7", "filename": "gcc/ada/exp_dist.ads", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fexp_dist.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fexp_dist.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.ads?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -83,4 +83,21 @@ package Exp_Dist is\n       E   : Entity_Id) return Node_Id;\n    --  Build a literal representing the remote subprogram identifier of E\n \n+   function Copy_Specification\n+     (Loc         : Source_Ptr;\n+      Spec        : Node_Id;\n+      Object_Type : Entity_Id := Empty;\n+      Stub_Type   : Entity_Id := Empty;\n+      New_Name    : Name_Id   := No_Name) return Node_Id;\n+   --  Build a subprogram specification from another one, or from\n+   --  an access-to-subprogram definition. If Object_Type is not Empty\n+   --  and any access to Object_Type is found, then it is replaced by an\n+   --  access to Stub_Type. If New_Name is given, then it will be used as\n+   --  the name for the newly created spec.\n+\n+   function Underlying_RACW_Type\n+     (RAS_Typ : Entity_Id) return Entity_Id;\n+   --  Given a remote access-to-subprogram type or its equivalent\n+   --  record type, return the RACW type generated to implement it.\n+\n end Exp_Dist;"}, {"sha": "ac52ecb962bbaf80321dfc8a17b5736a46f08dbd", "filename": "gcc/ada/exp_pakd.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fexp_pakd.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fexp_pakd.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.ads?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -119,9 +119,9 @@ package Exp_Pakd is\n    --  a packed array. There are two reasonable rules for deciding this:\n \n    --    Store the first bit at right end (low order) word. This means\n-   --    that the scaled subscript can be used directly as a right shift\n+   --    that the scaled subscript can be used directly as a left shift\n    --    count (if we put bit 0 at the left end, then we need an extra\n-   --    subtract to compute the shift count.\n+   --    subtract to compute the shift count).\n \n    --    Layout the bits so that if the packed boolean array is overlaid on\n    --    a record, using unchecked conversion, then bit 0 of the array is\n@@ -156,7 +156,7 @@ package Exp_Pakd is\n    --  that a worthwhile price to pay for the consistency.\n \n    --  One more important point arises in the case where we have a constrained\n-   --  subtype of an unconstrained array. Take the case of 20-bits. For the\n+   --  subtype of an unconstrained array. Take the case of 20 bits. For the\n    --  unconstrained representation, we would use an array of bytes:\n \n    --     Little-endian case"}, {"sha": "32eaf0d33a1d86f18341e5468c6cdd2d68819ff2", "filename": "gcc/ada/g-pehage.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fg-pehage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fg-pehage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-pehage.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n---        G N A T . P E R F E C T _ H A S H . G E N E R A T O R S           --\n+--        G N A T . P E R F E C T _ H A S H _ G E N E R A T O R S           --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---            Copyright (C) 2002-2003 Ada Core Technologies, Inc.           --\n+--            Copyright (C) 2002-2004 Ada Core Technologies, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,7 +38,7 @@ with GNAT.Heap_Sort_A; use GNAT.Heap_Sort_A;\n with GNAT.OS_Lib;      use GNAT.OS_Lib;\n with GNAT.Table;\n \n-package body GNAT.Perfect_Hash.Generators is\n+package body GNAT.Perfect_Hash_Generators is\n \n    --  We are using the algorithm of J. Czech as described in Zbigniew\n    --  J. Czech, George Havas, and Bohdan S. Majewski ``An Optimal\n@@ -2397,4 +2397,4 @@ package body GNAT.Perfect_Hash.Generators is\n       end case;\n    end Value;\n \n-end GNAT.Perfect_Hash.Generators;\n+end GNAT.Perfect_Hash_Generators;"}, {"sha": "c5c36666cf9443b6704ada7dfae60d282c142bcc", "filename": "gcc/ada/g-pehage.ads", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fg-pehage.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fg-pehage.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-pehage.ads?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n---        G N A T . P E R F E C T _ H A S H . G E N E R A T O R S           --\n+--          G N A T . P E R F E C T _ H A S H _ G E N E R A T O R S         --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                 Copyright (C) 2002 Ada Core Technologies, Inc.           --\n+--            Copyright (C) 2002-2004 Ada Core Technologies, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,16 +31,45 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package provides a single generator of static minimal perfect\n---  hash functions. No collisions occur and each item can be retrieved\n---  from the table in one probe (perfect property). The hash table\n---  size corresponds to the exact size of W and *no larger* (minimal\n---  property). The key set has to be know in advance (static\n---  property). The hash functions are also order preservering. If w2\n---  is inserted after w1 in the generator, then f (w1) < f (w2). These\n---  hashing functions are convenient for use with realtime applications.\n-\n-package GNAT.Perfect_Hash.Generators is\n+--  This package provides a generator of static minimal perfect hash\n+--  functions. To understand what a perfect hash function is, we\n+--  define several notions. These definitions are inspired from the\n+--  following paper:\n+\n+--    Zbigniew J. Czech, George Havas, and Bohdan S. Majewski ``An\n+--    Optimal Algorithm for Generating Minimal Perfect Hash Functions'',\n+--    Information Processing Letters, 43(1992) pp.257-264, Oct.1992\n+\n+--  Let W be a set of m words. A hash function h is a function that\n+--  maps the set of words W into some given interval of integers\n+--  [0, k-1], where k is an integer, usually k >= m. h (w) where w\n+--  is a word computes an address or an integer from I for the\n+--  storage or the retrieval of that item. The storage area used to\n+--  store items is known as a hash table. Words for which the same\n+--  address is computed are called synonyms. Due to the existence\n+--  of synonyms a situation called collision may arise in which two\n+--  items w1 and w2 have the same address. Several schemes for\n+--  resolving known. A perfect hash function is an injection from\n+--  the word set W to the integer interval I with k >= m. If k = m,\n+--  then h is a minimal perfect hash function. A hash function is\n+--  order preserving if it puts entries into the hash table in a\n+--  prespecified order.\n+\n+--  A minimal perfect hash function is defined by two properties:\n+\n+--    Since no collisions occur each item can be retrieved from the\n+--    table in *one* probe. This represents the \"perfect\" property.\n+\n+--    The hash table size corresponds to the exact size of W and\n+--    *no larger*. This represents the \"minimal\" property.\n+\n+--  The functions generated by this package require the key set to\n+--  be known in advance (they are \"static\" hash functions).\n+--  The hash functions are also order preservering. If w2 is inserted\n+--  after w1 in the generator, then f (w1) < f (w2). These hashing\n+--  functions are convenient for use with realtime applications.\n+\n+package GNAT.Perfect_Hash_Generators is\n \n    Default_K_To_V : constant Float  := 2.05;\n    --  Default ratio for the algorithm. When K is the number of keys,\n@@ -57,7 +86,8 @@ package GNAT.Perfect_Hash.Generators is\n    Default_Optimization : constant Optimization := CPU_Time;\n    --  Optimize either the memory space or the execution time.\n \n-   Verbose  : Boolean := False;\n+   Verbose : Boolean := False;\n+   --  Comment required ???\n \n    procedure Initialize\n      (Seed   : Natural;\n@@ -183,4 +213,4 @@ package GNAT.Perfect_Hash.Generators is\n    --  Return the value of the component (I, J) of the table\n    --  Name. When the table has only one dimension, J is ignored.\n \n-end GNAT.Perfect_Hash.Generators;\n+end GNAT.Perfect_Hash_Generators;"}, {"sha": "92a899cf600ff63737821ddc62df4fa22e302033", "filename": "gcc/ada/g-perhas.ads", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c892972fa7c999bf2cb6379d19265be42a974692/gcc%2Fada%2Fg-perhas.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c892972fa7c999bf2cb6379d19265be42a974692/gcc%2Fada%2Fg-perhas.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-perhas.ads?ref=c892972fa7c999bf2cb6379d19265be42a974692", "patch": "@@ -1,67 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                  G N A T . P E R F E C T _ H A S H                       --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---              Copyright (C) 2002-2003 Ada Core Technologies, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-package GNAT.Perfect_Hash is\n-pragma Pure (Perfect_Hash);\n-\n-   --  The packages in this hierarchy implement perfect hash\n-   --  functions. To understand what a perfect hash function is, we\n-   --  define several notions. These definitions are inspired from the\n-   --  following paper:\n-   --\n-   --    Zbigniew J. Czech, George Havas, and Bohdan S. Majewski ``An\n-   --    Optimal Algorithm for Generating Minimal Perfect Hash Functions'',\n-   --    Information Processing Letters, 43(1992) pp.257-264, Oct.1992\n-   --\n-   --  Let W be a set of m words. A hash function h is a function that\n-   --  maps the set of words W into some given interval of integers\n-   --  [0, k-1], where k is an integer, usually k >= m. h (w) where w\n-   --  is a word computes an address or an integer from I for the\n-   --  storage or the retrieval of that item. The storage area used to\n-   --  store items is known as a hash table. Words for which the same\n-   --  address is computed are called synonyms. Due to the existence\n-   --  of synonyms a situation called collision may arise in which two\n-   --  items w1 and w2 have the same address. Several schemes for\n-   --  resolving known. A perfect hash function is an injection from\n-   --  the word set W to the integer interval I with k >= m. If k = m,\n-   --  then h is a minimal perfect hash function. A hash function is\n-   --  order preserving if it puts entries into the hash table in a\n-   --  prespecified order.\n-   --\n-   --  A minimal perfect hash function is defined by two properties:\n-   --  * Since no collisions occur each item can be retrieved from the\n-   --    table in *one* probe. This represents the \"perfect\" property.\n-   --  * The hash table size corresponds to the exact size of W and\n-   --    *no larger*. This represents the \"minimal\" property.\n-\n-end GNAT.Perfect_Hash;"}, {"sha": "dc7b6dbe7c31a9fadcc673ed42a94378c0d89251", "filename": "gcc/ada/g-trasym.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fg-trasym.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fg-trasym.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-trasym.ads?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -52,8 +52,8 @@\n \n --  On all platforms except VMS, this package is not intended to be used\n --  within a shared library, symbolic tracebacks are only supported for the\n---  main executable and not for shared libraries.\n---  You should consider using gdb to obtain symbolic traceback in such cases.\n+--  main executable and not for shared libraries. You should consider using\n+--  gdb to obtain symbolic traceback in such cases.\n \n --  On VMS, there is no restriction on using this facility with shared\n --  libraries. However, the OS should be at least v7.3-1 and OS patch"}, {"sha": "233c22be5ed15c0278b20b9a25f5bec95cf94e15", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -114,6 +114,22 @@ extern tree maybe_variable (tree);\n    position so that it is aligned to ALIGN bits and is SIZE bytes long.  */\n extern tree make_aligning_type (tree, int, tree);\n \n+/* Ensure that TYPE has SIZE and ALIGN.  Make and return a new padded type\n+   if needed.  We have already verified that SIZE and TYPE are large enough.\n+\n+   GNAT_ENTITY and NAME_TRAILER are used to name the resulting record and\n+   to issue a warning.\n+\n+   IS_USER_TYPE is true if we must be sure we complete the original type.\n+\n+   DEFINITION is true if this type is being defined.\n+\n+   SAME_RM_SIZE is true if the RM_Size of the resulting type is to be\n+   set to its TYPE_SIZE; otherwise, it's set to the RM_Size of the original\n+   type.  */\n+extern tree maybe_pad_type (tree, tree, unsigned int, Entity_Id,\n+\t\t\t    const char *, bool, bool, bool);\n+\n /* Given a GNU tree and a GNAT list of choices, generate an expression to test\n    the value passed against the list of choices.  */\n extern tree choices_to_gnu (tree, Node_Id);\n@@ -446,8 +462,10 @@ extern void finish_record_type (tree, tree, bool, bool);\n    RETURNS_UNCONSTRAINED is true if the function returns an unconstrained\n    object.  RETURNS_BY_REF is true if the function returns by reference.\n    RETURNS_WITH_DSP is true if the function is to return with a\n-   depressed stack pointer.  */\n-extern tree create_subprog_type (tree, tree, tree, bool, bool, bool);\n+   depressed stack pointer.  RETURNS_BY_TARGET_PTR is true if the function\n+   is to be passed (as its first parameter) the address of the place to copy\n+   its result.  */\n+extern tree create_subprog_type (tree, tree, tree, bool, bool, bool, bool);\n \n /* Return a copy of TYPE, but safe to modify in any way.  */\n extern tree copy_type (tree);"}, {"sha": "08a668317b2067ba5e5ffa819d05d189c21dd9f3", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -117,6 +117,7 @@ Implementation Defined Pragmas\n * Pragma CPP_Virtual::\n * Pragma CPP_Vtable::\n * Pragma Debug::\n+* Pragma Detect_Blocking::\n * Pragma Elaboration_Checks::\n * Pragma Eliminate::\n * Pragma Export_Exception::\n@@ -308,7 +309,7 @@ The GNAT Library\n * GNAT.Memory_Dump (g-memdum.ads)::\n * GNAT.Most_Recent_Exception (g-moreex.ads)::\n * GNAT.OS_Lib (g-os_lib.ads)::\n-* GNAT.Perfect_Hash.Generators (g-pehage.ads)::\n+* GNAT.Perfect_Hash_Generators (g-pehage.ads)::\n * GNAT.Regexp (g-regexp.ads)::\n * GNAT.Registry (g-regist.ads)::\n * GNAT.Regpat (g-regpat.ads)::\n@@ -632,6 +633,7 @@ consideration, the use of these pragmas should be minimized.\n * Pragma CPP_Virtual::\n * Pragma CPP_Vtable::\n * Pragma Debug::\n+* Pragma Detect_Blocking::\n * Pragma Elaboration_Checks::\n * Pragma Eliminate::\n * Pragma Export_Exception::\n@@ -1330,6 +1332,21 @@ with a terminating semicolon.  Pragmas are permitted in sequences of\n declarations, so you can use pragma @code{Debug} to intersperse calls to\n debug procedures in the middle of declarations.\n \n+@node Pragma Detect_Blocking\n+@unnumberedsec Pragma Detect_Blocking\n+@findex Detect_Blocking\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Detect_Blocking;\n+@end smallexample\n+\n+@noindent\n+This is a configuration pragma that forces the detection of potentially\n+blocking operations within a protected operation, and to raise Program_Error\n+if that happens.\n+\n @node Pragma Elaboration_Checks\n @unnumberedsec Pragma Elaboration_Checks\n @cindex Elaboration control\n@@ -11495,7 +11512,7 @@ of GNAT, and will generate a warning message.\n * GNAT.Memory_Dump (g-memdum.ads)::\n * GNAT.Most_Recent_Exception (g-moreex.ads)::\n * GNAT.OS_Lib (g-os_lib.ads)::\n-* GNAT.Perfect_Hash.Generators (g-pehage.ads)::\n+* GNAT.Perfect_Hash_Generators (g-pehage.ads)::\n * GNAT.Regexp (g-regexp.ads)::\n * GNAT.Registry (g-regist.ads)::\n * GNAT.Regpat (g-regpat.ads)::\n@@ -12137,9 +12154,9 @@ including time/date management, file operations, subprocess management,\n including a portable spawn procedure, and access to environment variables\n and error return codes.\n \n-@node GNAT.Perfect_Hash.Generators (g-pehage.ads)\n-@section @code{GNAT.Perfect_Hash.Generators} (@file{g-pehage.ads})\n-@cindex @code{GNAT.Perfect_Hash.Generators} (@file{g-pehage.ads})\n+@node GNAT.Perfect_Hash_Generators (g-pehage.ads)\n+@section @code{GNAT.Perfect_Hash_Generators} (@file{g-pehage.ads})\n+@cindex @code{GNAT.Perfect_Hash_Generators} (@file{g-pehage.ads})\n @cindex Hash functions\n \n @noindent"}, {"sha": "c8da0d86467ee33823ef6dba3f39953fc8ddab9e", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 3, "deletions": 116, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -98,8 +98,6 @@\n @set FILE gnat_ugn_vms\n @end ifset\n \n-\n-\n @settitle @value{EDITION} User's Guide for Native Platforms / @value{PLATFORM}\n @dircategory GNU Ada tools\n @direntry\n@@ -149,7 +147,6 @@ A copy of the license is included in the section entitled\n \n @end titlepage\n \n-\n @ifnottex\n @node Top, About This Guide, (dir), (dir)\n @top @value{EDITION} User's Guide\n@@ -321,7 +318,6 @@ The GNAT Make Program gnatmake\n * How gnatmake Works::\n * Examples of gnatmake Usage::\n \n-\n Improving Performance\n * Performance Considerations::\n * Reducing the Size of Ada Executables with gnatelim::\n@@ -384,7 +380,6 @@ GNAT Project Manager\n * An Extended Example::\n * Project File Complete Syntax::\n \n-\n The Cross-Referencing Tools gnatxref and gnatfind\n \n * gnatxref Switches::\n@@ -394,13 +389,11 @@ The Cross-Referencing Tools gnatxref and gnatfind\n * Examples of gnatxref Usage::\n * Examples of gnatfind Usage::\n \n-\n The GNAT Pretty-Printer gnatpp\n \n * Switches for gnatpp::\n * Formatting Rules::\n \n-\n File Name Krunching Using gnatkr\n \n * About gnatkr::\n@@ -622,7 +615,6 @@ Microsoft Windows Topics\n * GNAT and COM/DCOM Objects::\n @end ifset\n \n-\n * Index::\n @end menu\n @end ifnottex\n@@ -649,8 +641,6 @@ For ease of exposition, ``GNAT Pro'' will be referred to simply as\n ``GNAT'' in the remainder of this document.\n @end ifset\n \n-\n-\n @menu\n * What This Guide Contains::\n * What You Should Know before Reading This Guide::\n@@ -729,7 +719,6 @@ way to navigate through sources.\n version of an Ada source file with control over casing, indentation,\n comment placement, and other elements of program presentation style.\n \n-\n @item\n @ref{File Name Krunching Using gnatkr}, describes the @code{gnatkr}\n file name krunching utility, used to handle shortened\n@@ -826,7 +815,6 @@ Microsoft Windows platform.\n @end ifset\n @end itemize\n \n-\n @c *************************************************\n @node What You Should Know before Reading This Guide\n @c *************************************************\n@@ -933,8 +921,6 @@ If you are using GNAT on a Windows platform, please note that\n the ``@code{\\}'' character should be used instead.\n @end ifset\n \n-\n-\n @c ****************************\n @node Getting Started with GNAT\n @chapter Getting Started with GNAT\n@@ -991,7 +977,6 @@ All three steps are most commonly handled by using the @code{gnatmake}\n utility program that, given the name of the main program, automatically\n performs the necessary compilation, binding and linking steps.\n \n-\n @node Running a Simple Ada Program\n @section Running a Simple Ada Program\n \n@@ -1114,7 +1099,6 @@ Hello WORLD!\n @noindent\n appear in response to this command.\n \n-\n @c ****************************************\n @node Running a Program with Multiple Units\n @section Running a Program with Multiple Units\n@@ -1322,7 +1306,6 @@ startup menu).\n * Simple Debugging with GPS::\n @end menu\n \n-\n @node Building a New Program with GPS\n @subsection Building a New Program with GPS\n @noindent\n@@ -1429,7 +1412,6 @@ Select @code{File}, then @code{Save As}, and enter the source file name\n The file will be saved in the same directory you specified as the\n location of the default project file.\n \n-\n @item @emph{Updating the project file}\n \n You need to add the new source file to the project.\n@@ -1463,8 +1445,6 @@ Close the GPS window (or select @code{File}, then @code{Exit}) to\n terminate this GPS session.\n @end enumerate\n \n-\n-\n @node Simple Debugging with GPS\n @subsection Simple Debugging with GPS\n @noindent\n@@ -1572,7 +1552,6 @@ Right click on @code{N}, select @code{Debug}, then select @code{Display N}.\n You will see information about @code{N} appear in the @code{Debugger Data}\n pane, showing the value as 5.\n \n-\n @item @emph{Assigning a new value to a variable}\n \n Right click on the @code{N} in the @code{Debugger Data} pane, and\n@@ -1608,7 +1587,6 @@ The console window will disappear.\n @end enumerate\n @end enumerate\n \n-\n @node Introduction to Glide and GVD\n @section Introduction to Glide and GVD\n @cindex Glide\n@@ -3483,7 +3461,6 @@ directory designated by the logical name @code{SYS$SCRATCH:}\n GNAT uses the current directory for temporary files.\n @end ifset\n \n-\n @c *************************\n @node Compiling Using gcc\n @chapter Compiling Using @code{gcc}\n@@ -4122,7 +4099,6 @@ is equivalent to specifying the following sequence of switches:\n @end smallexample\n @end ifclear\n \n-\n @c NEED TO CHECK THIS FOR VMS\n \n @noindent\n@@ -4166,7 +4142,6 @@ as validity checking options (see description of @option{-gnatV}).\n @end ifclear\n @end itemize\n \n-\n @node Output and Error Message Control\n @subsection Output and Error Message Control\n @findex stderr\n@@ -4330,7 +4305,6 @@ List possible interpretations for ambiguous calls\n Additional details on incorrect parameters\n @end itemize\n \n-\n @item -gnatq\n @cindex @option{-gnatq} (@code{gcc})\n @ifclear vms\n@@ -4374,7 +4348,6 @@ since ALI files are never generated if @option{-gnats} is set.\n \n @end table\n \n-\n @node Warning Message Control\n @subsection Warning Message Control\n @cindex Warning messages\n@@ -4467,7 +4440,6 @@ Mismatching bounds in an aggregate\n @item\n Attempt to return local value by reference\n \n-\n @item\n Premature instantiation of a generic body\n \n@@ -4528,7 +4500,6 @@ Useless exception handlers\n @item\n Accidental hiding of name by child unit\n \n-\n @item\n Access before elaboration detected at compile time\n \n@@ -4969,7 +4940,6 @@ When no switch @option{^-gnatw^/WARNINGS^} is used, this is equivalent to:\n \n @end table\n \n-\n @node Debugging and Assertion Control\n @subsection Debugging and Assertion Control\n \n@@ -5063,7 +5033,6 @@ indicate validity checks that are performed or not performed in addition\n to the default checks described above.\n @end ifset\n \n-\n @table @option\n @c !sort!\n @item -gnatVa\n@@ -5227,7 +5196,6 @@ See also the pragma @code{Validity_Checks} which allows modification of\n the validity checking mode at the program source level, and also allows for\n temporary disabling of validity checks.\n \n-\n @node Style Checking\n @subsection Style Checking\n @findex Style checking\n@@ -5781,7 +5749,6 @@ increase the amount of stack for the environment task, then this\n is an operating systems issue, and must be addressed with the\n appropriate operating systems commands.\n \n-\n @node Using gcc for Syntax Checking\n @subsection Using @code{gcc} for Syntax Checking\n @table @option\n@@ -5837,7 +5804,6 @@ together. This is primarily used by the @code{gnatchop} utility\n (@pxref{Renaming Files Using gnatchop}).\n @end table\n \n-\n @node Using gcc for Semantic Checking\n @subsection Using @code{gcc} for Semantic Checking\n @table @option\n@@ -6025,7 +5991,6 @@ to enable file name krunching.\n For the source file naming rules, @xref{File Naming Rules}.\n @end table\n \n-\n @node Subprogram Inlining Control\n @subsection Subprogram Inlining Control\n \n@@ -6415,7 +6380,6 @@ and communicates it to the compiler using this switch.\n \n @end table\n \n-\n @node Integrated Preprocessing\n @subsection Integrated Preprocessing\n \n@@ -6603,7 +6567,6 @@ are suitable for spawning with appropriate GNAT RTL routines.\n \n @end ifset\n \n-\n @node Search Paths and the Run-Time Library (RTL)\n @section Search Paths and the Run-Time Library (RTL)\n \n@@ -6717,7 +6680,6 @@ Besides simplifying access to the RTL, a major use of search paths is\n in compiling sources from multiple directories. This can make\n development environments much more flexible.\n \n-\n @node Order of Compilation Issues\n @section Order of Compilation Issues\n \n@@ -6827,7 +6789,6 @@ This information is output in the forms of comments in the generated program,\n to be read by the @code{gnatlink} utility used to link the Ada application.\n @end enumerate\n \n-\n @node Running gnatbind\n @section Running @code{gnatbind}\n \n@@ -6919,7 +6880,6 @@ The use of the @option{^-C^/BIND_FILE=C^} switch\n for both @code{gnatbind} and @code{gnatlink} will cause the program to\n be generated in C (and compiled using the gnu C compiler).\n \n-\n @node Switches for gnatbind\n @section Switches for @command{gnatbind}\n \n@@ -7173,7 +7133,6 @@ You may obtain this listing of switches by running @code{gnatbind} with\n no arguments.\n @end ifclear\n \n-\n @node Consistency-Checking Modes\n @subsection Consistency-Checking Modes\n \n@@ -7496,7 +7455,6 @@ a list of ALI files can be given, and the execution of the program\n consists of elaboration of these units in an appropriate order.\n @end table\n \n-\n @node Command-Line Access\n @section Command-Line Access\n \n@@ -7527,7 +7485,6 @@ required, your main program must set @code{gnat_argc} and\n @code{gnat_argv} from the @code{argc} and @code{argv} values passed to\n it.\n \n-\n @node Search Paths for gnatbind\n @section Search Paths for @code{gnatbind}\n \n@@ -7696,7 +7653,6 @@ the @code{adainit} and @code{adafinal} routines to be called before and\n after accessing the Ada units.\n @end table\n \n-\n @c ------------------------------------\n @node Linking Using gnatlink\n @chapter Linking Using @code{gnatlink}\n@@ -8582,13 +8538,6 @@ source paths only and @option{^-aO^/OBJECT_SEARCH^}\n if you want to specify library paths\n only.\n \n-@item\n-@code{gnatmake} examines both an ALI file and its corresponding object file\n-for consistency. If an ALI is more recent than its corresponding object,\n-or if the object file is missing, the corresponding source will be recompiled.\n-Note that @code{gnatmake} expects an ALI and the corresponding object file\n-to be in the same directory.\n-\n @item\n @code{gnatmake} will ignore any files whose ALI file is write-protected.\n This may conveniently be used to exclude standard libraries from\n@@ -8642,8 +8591,7 @@ approach and in particular to understand how it uses the results of\n previous compilations without incorrectly depending on them.\n \n First a definition: an object file is considered @dfn{up to date} if the\n-corresponding ALI file exists and its time stamp predates that of the\n-object file and if all the source files listed in the\n+corresponding ALI file exists and if all the source files listed in the\n dependency section of this ALI file have time stamps matching those in\n the ALI file. This means that neither the source file itself nor any\n files that it depends on have been modified, and hence there is no need\n@@ -8710,7 +8658,6 @@ listed by the binder. @code{gnatmake} will operate in quiet mode, not\n displaying commands it is executing.\n @end table\n \n-\n @c *************************\n @node Improving Performance\n @chapter Improving Performance\n@@ -8730,7 +8677,6 @@ the size of program executables.\n @end menu\n @end ifnottex\n \n-\n @c *****************************\n @node Performance Considerations\n @section Performance Considerations\n@@ -8935,7 +8881,6 @@ is generally discouraged with GNAT, since it often results in larger\n executables which run more slowly. See further discussion of this point\n in @pxref{Inlining of Subprograms}.\n \n-\n @node Debugging Optimized Code\n @subsection Debugging Optimized Code\n @cindex Debugging optimized code\n@@ -9064,7 +9009,6 @@ on the resulting executable,\n which removes both debugging information and global symbols.\n @end ifclear\n \n-\n @node Inlining of Subprograms\n @subsection Inlining of Subprograms\n \n@@ -9574,7 +9518,6 @@ the @file{gnat.adc} file. You should recompile your program\n from scratch after that, because you need a consistent @file{gnat.adc} file\n during the entire compilation.\n \n-\n @node Making Your Executables Smaller\n @subsection Making Your Executables Smaller\n \n@@ -9635,9 +9578,6 @@ $ gnatmake ^-f main_prog^/FORCE_COMPILE MAIN_PROG^\n \n @end enumerate\n \n-\n-\n-\n @c ********************************\n @node Renaming Files Using gnatchop\n @chapter Renaming Files Using @code{gnatchop}\n@@ -9682,7 +9622,6 @@ system, you can set up a procedure where you use @command{gnatchop} each\n time you compile, regarding the source files that it writes as temporary\n files that you throw away.\n \n-\n @node Operating gnatchop in Compilation Mode\n @section Operating gnatchop in Compilation Mode\n \n@@ -9997,6 +9936,7 @@ recognized by @code{GNAT}:\n    Ada_95\n    C_Pass_By_Copy\n    Component_Alignment\n+   Detect_Blocking\n    Discard_Names\n    Elaboration_Checks\n    Eliminate\n@@ -10333,7 +10273,6 @@ even in conjunction with one or several switches\n @option{^-D^/DIRS_FILE^}. Several Naming Patterns and one excluded pattern\n are used in this example.\n \n-\n @c *****************************************\n @c * G N A T  P r o j e c t  M a n a g e r *\n @c *****************************************\n@@ -10744,7 +10683,7 @@ invoking @command{gnatmake} (see @ref{gnatmake and Project Files}).\n \n @noindent\n By default, the executable file name corresponding to a main source is\n-deducted from the main source file name. Through the attributes\n+deduced from the main source file name. Through the attributes\n @code{Executable} and @code{Executable_Suffix} of package @code{Builder},\n it is possible to change this default.\n In project @code{Debug} above, the executable file name\n@@ -12542,7 +12481,6 @@ All @file{ALI} files will also be copied from the object directory to the\n library directory. To build executables, @command{gnatmake} will use the\n library rather than the individual object files.\n \n-\n @c **********************************************\n @c * Using Third-Party Libraries through Projects\n @c **********************************************\n@@ -13730,7 +13668,6 @@ simple_name ::=\n \n @end smallexample\n \n-\n @node The Cross-Referencing Tools gnatxref and gnatfind\n @chapter  The Cross-Referencing Tools @code{gnatxref} and @code{gnatfind}\n @findex gnatxref\n@@ -14426,7 +14363,6 @@ point to any character in the middle of the identifier.\n \n @end table\n \n-\n @c *********************************\n @node The GNAT Pretty-Printer gnatpp\n @chapter The GNAT Pretty-Printer @command{gnatpp}\n@@ -14478,7 +14414,6 @@ allowed.  The file name may contain path information; it does not have to\n follow the GNAT file naming rules\n @end itemize\n \n-\n @menu\n * Switches for gnatpp::\n * Formatting Rules::\n@@ -14540,7 +14475,6 @@ indicate the effect.\n * Other gnatpp Switches::\n @end menu\n \n-\n @node Alignment Control\n @subsection Alignment Control\n @cindex Alignment control in @command{gnatpp}\n@@ -14581,7 +14515,6 @@ Align @code{=>} in associations\n The @option{^-A^/ALIGN^} switches are mutually compatible; any combination\n is allowed.\n \n-\n @node Casing Control\n @subsection Casing Control\n @cindex Casing control in @command{gnatpp}\n@@ -14676,7 +14609,6 @@ The @option{^-D-^/SPECIFIC_CASING^} and\n @option{^-D@var{file}^/DICTIONARY=@var{file}^} switches are mutually\n compatible.\n \n-\n @node Construct Layout Control\n @subsection Construct Layout Control\n @cindex Layout control in @command{gnatpp}\n@@ -14771,7 +14703,6 @@ indentation is set to 1 (in which case the default value for continuation\n line indentation is also 1)\n @end table\n \n-\n @node Other Formatting Options\n @subsection Other Formatting Options\n \n@@ -14831,7 +14762,6 @@ The same as the corresponding gcc switch\n \n @end table\n \n-\n @node Output File Control\n @subsection Output File Control\n \n@@ -14913,7 +14843,6 @@ Warning mode;\n a required layout in the result source.\n @end table\n \n-\n @node Formatting Rules\n @section Formatting Rules\n \n@@ -14929,7 +14858,6 @@ They provide the detailed descriptions of the switches shown above.\n * Name Casing::\n @end menu\n \n-\n @node White Space and Empty Lines\n @subsection White Space and Empty Lines\n \n@@ -14963,7 +14891,6 @@ In order to preserve a visual separation between comment blocks, use an\n Likewise, if for some reason you wish to have a sequence of empty lines,\n use a sequence of empty comments instead.\n \n-\n @node Formatting Comments\n @subsection Formatting Comments\n \n@@ -15107,7 +15034,6 @@ comments may be reformatted in typical\n word processor style (that is, moving words between lines and putting as\n many words in a line as possible).\n \n-\n @node Construct Layout\n @subsection Construct Layout\n \n@@ -15185,7 +15111,6 @@ type q is record                        type q is\n end record;                                   b : integer;\n                                            end record;\n \n-\n Block : declare                         Block :\n    A : Integer := 3;                       declare\n begin                                         A : Integer := 3;\n@@ -15206,7 +15131,6 @@ A further difference between GNAT style layout and compact layout is that\n GNAT style layout inserts empty lines as separation for\n compound statements, return statements and bodies.\n \n-\n @node Name Casing\n @subsection Name Casing\n \n@@ -15399,8 +15323,6 @@ end Test;\n @end cartouche\n @end smallexample\n \n-\n-\n @c ***********************************\n @node File Name Krunching Using gnatkr\n @chapter File Name Krunching Using @code{gnatkr}\n@@ -16578,7 +16500,6 @@ library, by reordering the lines in the configuration files. In general, a\n library must be installed before the GNAT library if it redefines\n any part of it.\n \n-\n @node Using the library\n @subsection Using the library\n \n@@ -16646,7 +16567,6 @@ pragma Linker_Options (\"-lmy_lib\");\n @end smallexample\n @end itemize\n \n-\n @node Stand-alone Ada Libraries\n @section Stand-alone Ada Libraries\n @cindex Stand-alone library, building, using\n@@ -16926,7 +16846,6 @@ gnat library. This Makefile contains its own documentation and in\n particular the set of instructions needed to rebuild a new library and\n to use it.\n \n-\n @node Using the GNU make Utility\n @chapter Using the GNU @code{make} Utility\n @findex make\n@@ -17218,7 +17137,6 @@ all:\n @end smallexample\n @end ifclear\n \n-\n @node Finding Memory Problems\n @chapter Finding Memory Problems\n \n@@ -17238,7 +17156,6 @@ access values (including ``dangling references'').\n * The GNAT Debug Pool Facility::\n @end menu\n \n-\n @ifclear vms\n @node The gnatmem Tool\n @section The @command{gnatmem} Tool\n@@ -17581,7 +17498,6 @@ and #3 thanks to the more precise associated backtrace.\n \n @end ifclear\n \n-\n @node The GNAT Debug Pool Facility\n @section The GNAT Debug Pool Facility\n @findex Debug Pool\n@@ -17726,7 +17642,6 @@ Debug Pool info:\n   High Water Mark:  8\n @end smallexample\n \n-\n @node Creating Sample Bodies Using gnatstub\n @chapter Creating Sample Bodies Using @command{gnatstub}\n @findex gnatstub\n@@ -17903,7 +17818,6 @@ Verbose mode: generate version information.\n \n @end table\n \n-\n @node Other Utility Programs\n @chapter Other Utility Programs\n \n@@ -18098,7 +18012,6 @@ For more information, please refer to the online documentation\n available in the @code{Glide} @result{} @code{Help} menu.\n @end ifclear\n \n-\n @node Converting Ada Files to html with gnathtml\n @section Converting Ada Files to HTML with @code{gnathtml}\n \n@@ -18389,7 +18302,6 @@ The simplest command is simply @code{run}, which causes the program to run\n exactly as if the debugger were not present. The following section\n describes some of the additional commands that can be given to @code{GDB}.\n \n-\n @c *******************************\n @node Introduction to GDB Commands\n @section Introduction to GDB Commands\n@@ -19189,7 +19101,6 @@ You can then get further information by invoking the @code{addr2line}\n tool as described earlier (note that the hexadecimal addresses\n need to be specified in C format, with a leading ``0x'').\n \n-\n @node Symbolic Traceback\n @subsection Symbolic Traceback\n @cindex traceback, symbolic\n@@ -20893,7 +20804,6 @@ and GNAT systems.\n \n @end ifset\n \n-\n @c **************************************\n @node Platform-Specific Information for the Run-Time Libraries\n @appendix Platform-Specific Information for the Run-Time Libraries\n@@ -20957,11 +20867,9 @@ information about several specific platforms.\n * AIX-Specific Considerations::\n @end menu\n \n-\n @node Summary of Run-Time Configurations\n @section Summary of Run-Time Configurations\n \n-\n @multitable @columnfractions .30 .70\n @item @b{alpha-openvms}\n @item @code{@ @ }@i{rts-native (default)}\n@@ -21021,8 +20929,6 @@ information about several specific platforms.\n @*\n @end multitable\n \n-\n-\n @node Specifying a Run-Time Library\n @section Specifying a Run-Time Library\n \n@@ -21196,7 +21102,6 @@ you find that the improved efficiency of FSU threads is significant to you.\n Note also that to take full advantage of Florist and Glade, it is highly\n recommended that you use native threads.\n \n-\n @node Choosing the Scheduling Policy\n @section Choosing the Scheduling Policy\n \n@@ -21235,8 +21140,6 @@ you should use @code{pragma Time_Slice} with a\n value greater than @code{0.0}, or else use the corresponding @option{-T}\n binder option.\n \n-\n-\n @node Solaris-Specific Considerations\n @section Solaris-Specific Considerations\n @cindex Solaris Sparc threads libraries\n@@ -21251,7 +21154,6 @@ debugging 64-bit applications.\n * Building and Debugging 64-bit Applications::\n @end menu\n \n-\n @node Solaris Threads Issues\n @subsection Solaris Threads Issues\n \n@@ -21305,7 +21207,6 @@ Run the program on the specified processor.\n (where @code{_SC_NPROCESSORS_CONF} is a system variable).\n @end table\n \n-\n @node Building and Debugging 64-bit Applications\n @subsection Building and Debugging 64-bit Applications\n \n@@ -21329,8 +21230,6 @@ amounts to:\n      $ gdb64 hello\n @end smallexample\n \n-\n-\n @node IRIX-Specific Considerations\n @section IRIX-Specific Considerations\n @cindex IRIX thread library\n@@ -21351,7 +21250,6 @@ See the @cite{GNAT Reference Manual} for further information.\n The @emph{n32 ABI} compiler comes with a run-time library based on the\n kernel POSIX threads and thus does not have the limitations mentioned above.\n \n-\n @node Linux-Specific Considerations\n @section Linux-Specific Considerations\n @cindex Linux threads libraries\n@@ -21395,7 +21293,6 @@ This Appendix displays the source code for @command{gnatbind}'s output\n file generated for a simple ``Hello World'' program.\n Comments have been added for clarification purposes.\n \n-\n @smallexample @c adanocomment\n @iftex\n @leftskip=0cm\n@@ -22111,7 +22008,6 @@ and trace the elaboration routine for this package to find out where\n the problem might be (more usually of course you would be debugging\n elaboration code in your own application).\n \n-\n @node Elaboration Order Handling in GNAT\n @appendix Elaboration Order Handling in GNAT\n @cindex Order of elaboration\n@@ -23967,7 +23863,6 @@ difference, by looking at the two elaboration orders that are chosen,\n and figuring out which is correct, and then adding the necessary\n @code{Elaborate_All} pragmas to ensure the desired order.\n \n-\n @node Inline Assembler\n @appendix Inline Assembler\n \n@@ -25578,8 +25473,6 @@ end Intel_CPU;\n @c END OF INLINE ASSEMBLER CHAPTER\n @c ===============================\n \n-\n-\n @c ***********************************\n @c * Compatibility and Porting Guide *\n @c ***********************************\n@@ -25784,7 +25677,6 @@ include @code{pragma Interface} and the floating point type attributes\n (@code{Emax}, @code{Mantissa}, etc.), among other items.\n @end table\n \n-\n @node Implementation-dependent characteristics\n @section Implementation-dependent characteristics\n @noindent\n@@ -25805,7 +25697,6 @@ transition from certain Ada 83 compilers.\n * Target-specific aspects::\n @end menu\n \n-\n @node Implementation-defined pragmas\n @subsection Implementation-defined pragmas\n \n@@ -25903,7 +25794,6 @@ incompatible with typical Ada 83 compiler practices regarding implicit\n packing, the meaning of the Size attribute, and the size of access values.\n GNAT's approach to these issues is described in @ref{Representation Clauses}.\n \n-\n @node Compatibility with Other Ada 95 Systems\n @section Compatibility with Other Ada 95 Systems\n \n@@ -26104,8 +25994,6 @@ attributes are recognized, although only a subset of them can sensibly\n be implemented.  The description of pragmas in this reference manual\n indicates whether or not they are applicable to non-VMS systems.\n \n-\n-\n @ifset unw\n @node Microsoft Windows Topics\n @appendix Microsoft Windows Topics\n@@ -27878,7 +27766,6 @@ This section is temporarily left blank.\n \n @end ifset\n \n-\n @c **********************************\n @c * GNU Free Documentation License *\n @c **********************************"}, {"sha": "48c23f07eb87dda03c4d8122214e138695e9ff94", "filename": "gcc/ada/gnatbind.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -605,7 +605,7 @@ begin\n          Error_Msg\n            (\"?may result in missing run-time elaboration checks\");\n          Error_Msg\n-           (\"?use -gnatE, pragma Suppress (Elaboration_Checks) instead\");\n+           (\"?use -gnatE, pragma Suppress (Elaboration_Check) instead\");\n       end if;\n \n       --  Quit if some file needs compiling"}, {"sha": "10249b313ddfac2acb1e5ba8776f37b5c77643a4", "filename": "gcc/ada/gnatdll.adb", "status": "modified", "additions": 92, "deletions": 90, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fgnatdll.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fgnatdll.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatdll.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n---                               G N A T D L L                              --\n+--                              G N A T D L L                               --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1997-2002, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,25 +27,20 @@\n --  GNATDLL is a Windows specific tool for building a DLL.\n --  Both relocatable and non-relocatable DLL's are supported\n \n-with Ada.Text_IO;\n-with Ada.Strings.Unbounded;\n-with Ada.Exceptions;\n-with Ada.Command_Line;\n-with GNAT.OS_Lib;\n-with GNAT.Command_Line;\n+with Ada.Text_IO;           use Ada.Text_IO;\n+with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n+with Ada.Exceptions;        use Ada.Exceptions;\n+with Ada.Command_Line;      use Ada.Command_Line;\n+with GNAT.OS_Lib;           use GNAT.OS_Lib;\n+with GNAT.Command_Line;     use GNAT.Command_Line;\n with Gnatvsn;\n \n-with MDLL.Fil;\n-with MDLL.Utl;\n+with MDLL.Fil;              use MDLL.Fil;\n+with MDLL.Utl;              use MDLL.Utl;\n \n procedure Gnatdll is\n \n-   use GNAT;\n-   use Ada;\n-   use MDLL;\n-   use Ada.Strings.Unbounded;\n-\n-   use type OS_Lib.Argument_List;\n+   use type GNAT.OS_Lib.Argument_List;\n \n    procedure Syntax;\n    --  Print out usage\n@@ -59,7 +54,7 @@ procedure Gnatdll is\n    procedure Check_Context;\n    --  Check the context before runing any commands to build the library\n \n-   Syntax_Error  : exception;\n+   Syntax_Error : exception;\n    --  Raised when a syntax error is detected, in this case a usage info will\n    --  be displayed.\n \n@@ -76,31 +71,33 @@ procedure Gnatdll is\n    Default_DLL_Address : constant String := \"0x11000000\";\n    --  Default address for non relocatable DLL (Win32)\n \n-   Lib_Filename        : Unbounded_String := Null_Unbounded_String;\n+   Lib_Filename : Unbounded_String := Null_Unbounded_String;\n    --  The DLL filename that will be created (.dll)\n \n-   Def_Filename        : Unbounded_String := Null_Unbounded_String;\n+   Def_Filename : Unbounded_String := Null_Unbounded_String;\n    --  The definition filename (.def)\n \n-   List_Filename       : Unbounded_String := Null_Unbounded_String;\n+   List_Filename : Unbounded_String := Null_Unbounded_String;\n    --  The name of the file containing the objects file to put into the DLL\n \n-   DLL_Address         : Unbounded_String :=\n-                           To_Unbounded_String (Default_DLL_Address);\n+   DLL_Address : Unbounded_String := To_Unbounded_String (Default_DLL_Address);\n    --  The DLL's base address\n \n-   Objects_Files : Argument_List_Access := Null_Argument_List_Access;\n+   Gen_Map_File : Boolean := False;\n+   --  Set to True if a map file is to be generated\n+\n+   Objects_Files : Argument_List_Access := MDLL.Null_Argument_List_Access;\n    --  List of objects to put inside the library\n \n-   Ali_Files : Argument_List_Access := Null_Argument_List_Access;\n+   Ali_Files : Argument_List_Access := MDLL.Null_Argument_List_Access;\n    --  For each Ada file specified, we keep arecord of the corresponding\n    --  ALI file. This list of SLI files is used to build the binder program.\n \n-   Options : Argument_List_Access := Null_Argument_List_Access;\n-   --  A list of options set in the command line.\n+   Options : Argument_List_Access := MDLL.Null_Argument_List_Access;\n+   --  A list of options set in the command line\n \n-   Largs_Options : Argument_List_Access := Null_Argument_List_Access;\n-   Bargs_Options : Argument_List_Access := Null_Argument_List_Access;\n+   Largs_Options : Argument_List_Access := MDLL.Null_Argument_List_Access;\n+   Bargs_Options : Argument_List_Access := MDLL.Null_Argument_List_Access;\n    --  GNAT linker and binder args options\n \n    type Build_Mode_State is (Import_Lib, Dynamic_Lib, Dynamic_Lib_Only, Nil);\n@@ -109,8 +106,8 @@ procedure Gnatdll is\n    --  Dynamic_Lib_Only means that only the DLL will be created (no import\n    --  library).\n \n-   Build_Mode             : Build_Mode_State := Nil;\n-   --  Will be set when parsing the command line.\n+   Build_Mode : Build_Mode_State := Nil;\n+   --  Will be set when parsing the command line\n \n    Must_Build_Relocatable : Boolean := True;\n    --  True means build a relocatable DLL, will be set to False if a\n@@ -121,10 +118,7 @@ procedure Gnatdll is\n    ------------\n \n    procedure Syntax is\n-      use Text_IO;\n-\n-      procedure P (Str : in String) renames Text_IO.Put_Line;\n-\n+      procedure P (Str : String) renames Put_Line;\n    begin\n       P (\"Usage : gnatdll [options] [list-of-files]\");\n       New_Line;\n@@ -148,6 +142,7 @@ procedure Gnatdll is\n       P (\"   -a[addr]      Build non-relocatable DLL at address <addr>\");\n       P (\"                 if <addr> is not specified use \"\n          & Default_DLL_Address);\n+      P (\"   -m            Generate map file\");\n       P (\"   -n            No-import - do not create the import library\");\n       P (\"   -bargs opts   opts are passed to the binder\");\n       P (\"   -largs opts   opts are passed to the linker\");\n@@ -159,9 +154,9 @@ procedure Gnatdll is\n \n    procedure Check (Filename : in String) is\n    begin\n-      if not OS_Lib.Is_Regular_File (Filename) then\n-         Exceptions.Raise_Exception (Context_Error'Identity,\n-                                     \"Error: \" & Filename & \" not found.\");\n+      if not Is_Regular_File (Filename) then\n+         Raise_Exception\n+           (Context_Error'Identity, \"Error: \" & Filename & \" not found.\");\n       end if;\n    end Check;\n \n@@ -186,37 +181,37 @@ procedure Gnatdll is\n       --  No, a better choice would be to use tables ???\n       --  Limits on what???\n \n-      Ofiles : OS_Lib.Argument_List (1 .. Max_Files);\n+      Ofiles : Argument_List (1 .. Max_Files);\n       O      : Positive := Ofiles'First;\n       --  List of object files to put in the library. O is the next entry\n       --  to be used.\n \n-      Afiles : OS_Lib.Argument_List (1 .. Max_Files);\n+      Afiles : Argument_List (1 .. Max_Files);\n       A      : Positive := Afiles'First;\n-      --  List of ALI files. A is the next entry to be used.\n+      --  List of ALI files. A is the next entry to be used\n \n-      Gopts  : OS_Lib.Argument_List (1 .. Max_Options);\n+      Gopts  : Argument_List (1 .. Max_Options);\n       G      : Positive := Gopts'First;\n-      --  List of gcc options. G is the next entry to be used.\n+      --  List of gcc options. G is the next entry to be used\n \n-      Lopts  : OS_Lib.Argument_List (1 .. Max_Options);\n+      Lopts  : Argument_List (1 .. Max_Options);\n       L      : Positive := Lopts'First;\n       --  A list of -largs options (L is next entry to be used)\n \n-      Bopts  : OS_Lib.Argument_List (1 .. Max_Options);\n+      Bopts  : Argument_List (1 .. Max_Options);\n       B      : Positive := Bopts'First;\n       --  A list of -bargs options (B is next entry to be used)\n \n       Build_Import : Boolean := True;\n-      --  Set to Fals if option -n if specified (no-import).\n+      --  Set to Fals if option -n if specified (no-import)\n \n       --------------\n       -- Add_File --\n       --------------\n \n       procedure Add_File (Filename : in String) is\n       begin\n-         if Fil.Is_Ali (Filename) then\n+         if Is_Ali (Filename) then\n \n             Check (Filename);\n \n@@ -226,7 +221,7 @@ procedure Gnatdll is\n             Afiles (A) := new String'(Filename);\n             A := A + 1;\n \n-         elsif Fil.Is_Obj (Filename) then\n+         elsif Is_Obj (Filename) then\n \n             Check (Filename);\n \n@@ -238,7 +233,7 @@ procedure Gnatdll is\n          else\n             --  Unknown file type\n \n-            Exceptions.Raise_Exception\n+            Raise_Exception\n               (Syntax_Error'Identity,\n                \"don't know what to do with \" & Filename & \" !\");\n          end if;\n@@ -249,19 +244,19 @@ procedure Gnatdll is\n       -------------------------\n \n       procedure Add_Files_From_List (List_Filename : in String) is\n-         File   : Text_IO.File_Type;\n+         File   : File_Type;\n          Buffer : String (1 .. 500);\n          Last   : Natural;\n \n       begin\n-         Text_IO.Open (File, Text_IO.In_File, List_Filename);\n+         Open (File, In_File, List_Filename);\n \n-         while not Text_IO.End_Of_File (File) loop\n-            Text_IO.Get_Line (File, Buffer, Last);\n+         while not End_Of_File (File) loop\n+            Get_Line (File, Buffer, Last);\n             Add_File (Buffer (1 .. Last));\n          end loop;\n \n-         Text_IO.Close (File);\n+         Close (File);\n       end Add_Files_From_List;\n \n    --  Start of processing for Parse_Command_Line\n@@ -272,7 +267,7 @@ procedure Gnatdll is\n       --  scan gnatdll switches\n \n       loop\n-         case Getopt (\"g h v q k a? b: d: e: l: n I:\") is\n+         case Getopt (\"g h v q k a? b: d: e: l: n m I:\") is\n \n             when ASCII.Nul =>\n                exit;\n@@ -290,7 +285,7 @@ procedure Gnatdll is\n \n                MDLL.Verbose := True;\n                if MDLL.Quiet then\n-                  Exceptions.Raise_Exception\n+                  Raise_Exception\n                     (Syntax_Error'Identity,\n                      \"impossible to use -q and -v together.\");\n                end if;\n@@ -301,7 +296,7 @@ procedure Gnatdll is\n \n                MDLL.Quiet := True;\n                if MDLL.Verbose then\n-                  Exceptions.Raise_Exception\n+                  Raise_Exception\n                     (Syntax_Error'Identity,\n                      \"impossible to use -v and -q together.\");\n                end if;\n@@ -343,11 +338,15 @@ procedure Gnatdll is\n \n                if Def_Filename = Null_Unbounded_String then\n                   Def_Filename := To_Unbounded_String\n-                    (Fil.Ext_To (Parameter, \"def\"));\n+                    (Ext_To (Parameter, \"def\"));\n                end if;\n \n                Build_Mode := Dynamic_Lib;\n \n+            when 'm' =>\n+\n+               Gen_Map_File := True;\n+\n             when 'n' =>\n \n                Build_Import := False;\n@@ -361,7 +360,6 @@ procedure Gnatdll is\n \n             when others =>\n                raise Invalid_Switch;\n-\n          end case;\n       end loop;\n \n@@ -382,14 +380,12 @@ procedure Gnatdll is\n \n       loop\n          case Getopt (\"*\") is\n-\n             when ASCII.Nul =>\n                exit;\n \n             when others =>\n                Lopts (L) := new String'(Full_Switch);\n                L := L + 1;\n-\n          end case;\n       end loop;\n \n@@ -416,12 +412,10 @@ procedure Gnatdll is\n          Add_Files_From_List (To_String (List_Filename));\n       end if;\n \n-      --  Check if the set of parameters are compatible.\n+      --  Check if the set of parameters are compatible\n \n-      if Build_Mode = Nil and then not Help and then not Verbose then\n-         Exceptions.Raise_Exception\n-           (Syntax_Error'Identity,\n-            \"nothing to do.\");\n+      if Build_Mode = Nil and then not Help and then not MDLL.Verbose then\n+         Raise_Exception (Syntax_Error'Identity, \"nothing to do.\");\n       end if;\n \n       --  -n option but no file specified\n@@ -430,7 +424,7 @@ procedure Gnatdll is\n         and then A = Afiles'First\n         and then O = Ofiles'First\n       then\n-         Exceptions.Raise_Exception\n+         Raise_Exception\n            (Syntax_Error'Identity,\n             \"-n specified but there are no objects to build the library.\");\n       end if;\n@@ -445,41 +439,49 @@ procedure Gnatdll is\n          Build_Mode := Import_Lib;\n       end if;\n \n-      --  Check if only a dynamic library must be built.\n+      --  If map file is to be generated, add linker option here\n+\n+      if Gen_Map_File and then Build_Mode = Import_Lib then\n+         Raise_Exception\n+           (Syntax_Error'Identity,\n+            \"Can't generate a map file for an import library.\");\n+      end if;\n+\n+      --  Check if only a dynamic library must be built\n \n       if Build_Mode = Dynamic_Lib and then not Build_Import then\n          Build_Mode := Dynamic_Lib_Only;\n       end if;\n \n       if O /= Ofiles'First then\n-         Objects_Files := new OS_Lib.Argument_List'(Ofiles (1 .. O - 1));\n+         Objects_Files := new Argument_List'(Ofiles (1 .. O - 1));\n       end if;\n \n       if A /= Afiles'First then\n-         Ali_Files     := new OS_Lib.Argument_List'(Afiles (1 .. A - 1));\n+         Ali_Files     := new Argument_List'(Afiles (1 .. A - 1));\n       end if;\n \n       if G /= Gopts'First then\n-         Options       := new OS_Lib.Argument_List'(Gopts (1 .. G - 1));\n+         Options       := new Argument_List'(Gopts (1 .. G - 1));\n       end if;\n \n       if L /= Lopts'First then\n-         Largs_Options := new OS_Lib.Argument_List'(Lopts (1 .. L - 1));\n+         Largs_Options := new Argument_List'(Lopts (1 .. L - 1));\n       end if;\n \n       if B /= Bopts'First then\n-         Bargs_Options := new OS_Lib.Argument_List'(Bopts (1 .. B - 1));\n+         Bargs_Options := new Argument_List'(Bopts (1 .. B - 1));\n       end if;\n \n    exception\n \n       when Invalid_Switch    =>\n-         Exceptions.Raise_Exception\n+         Raise_Exception\n            (Syntax_Error'Identity,\n             Message => \"Invalid Switch \" & Full_Switch);\n \n       when Invalid_Parameter =>\n-         Exceptions.Raise_Exception\n+         Raise_Exception\n            (Syntax_Error'Identity,\n             Message => \"No parameter for \" & Full_Switch);\n \n@@ -512,9 +514,9 @@ begin\n    end if;\n \n    if MDLL.Verbose or else Help then\n-      Text_IO.New_Line;\n-      Text_IO.Put_Line (\"GNATDLL \" & Version & \" - Dynamic Libraries Builder\");\n-      Text_IO.New_Line;\n+      New_Line;\n+      Put_Line (\"GNATDLL \" & Version & \" - Dynamic Libraries Builder\");\n+      New_Line;\n    end if;\n \n    MDLL.Utl.Locate;\n@@ -544,7 +546,8 @@ begin\n                To_String (Def_Filename),\n                To_String (DLL_Address),\n                Build_Import => True,\n-               Relocatable  => Must_Build_Relocatable);\n+               Relocatable  => Must_Build_Relocatable,\n+               Map_File     => Gen_Map_File);\n \n          when Dynamic_Lib_Only =>\n             MDLL.Build_Dynamic_Library\n@@ -557,31 +560,30 @@ begin\n                To_String (Def_Filename),\n                To_String (DLL_Address),\n                Build_Import => False,\n-               Relocatable  => Must_Build_Relocatable);\n+               Relocatable  => Must_Build_Relocatable,\n+               Map_File     => Gen_Map_File);\n \n          when Nil =>\n             null;\n-\n       end case;\n-\n    end if;\n \n-   Ada.Command_Line.Set_Exit_Status (Ada.Command_Line.Success);\n+   Set_Exit_Status (Success);\n \n exception\n \n    when SE : Syntax_Error =>\n-      Text_IO.Put_Line (\"Syntax error : \" & Exceptions.Exception_Message (SE));\n-      Text_IO.New_Line;\n+      Put_Line (\"Syntax error : \" & Exception_Message (SE));\n+      New_Line;\n       Syntax;\n-      Ada.Command_Line.Set_Exit_Status (Ada.Command_Line.Failure);\n+      Set_Exit_Status (Failure);\n \n-   when E : Tools_Error | Context_Error =>\n-      Text_IO.Put_Line (Exceptions.Exception_Message (E));\n-      Ada.Command_Line.Set_Exit_Status (Ada.Command_Line.Failure);\n+   when E : MDLL.Tools_Error | Context_Error =>\n+      Put_Line (Exception_Message (E));\n+      Set_Exit_Status (Failure);\n \n    when others =>\n-      Text_IO.Put_Line (\"gnatdll: INTERNAL ERROR. Please report\");\n-      Ada.Command_Line.Set_Exit_Status (Ada.Command_Line.Failure);\n+      Put_Line (\"gnatdll: INTERNAL ERROR. Please report\");\n+      Set_Exit_Status (Failure);\n \n end Gnatdll;"}, {"sha": "cdc924cb418b38e849565df00181d891f9bdcd50", "filename": "gcc/ada/gnatls.adb", "status": "modified", "additions": 443, "deletions": 17, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fgnatls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fgnatls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatls.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -98,6 +98,8 @@ procedure Gnatls is\n    Dependable  : Boolean := False;  --  flag -d\n    Also_Predef : Boolean := False;\n \n+   Very_Verbose_Mode : Boolean := False; --  flag -V\n+\n    Unit_Start   : Integer;\n    Unit_End     : Integer;\n    Source_Start : Integer;\n@@ -162,6 +164,20 @@ procedure Gnatls is\n    function Image (Restriction : Restriction_Id) return String;\n    --  Returns the capitalized image of Restriction\n \n+   ---------------------------------------\n+   -- GLADE specific output subprograms --\n+   ---------------------------------------\n+\n+   package GLADE is\n+\n+      --  Any modification to this subunit requires a synchronization\n+      --  with the GLADE implementation.\n+\n+      procedure Output_ALI    (A : ALI_Id);\n+      procedure Output_No_ALI (Afile : File_Name_Type);\n+\n+   end GLADE;\n+\n    -----------------\n    -- Add_Lib_Dir --\n    -----------------\n@@ -354,6 +370,409 @@ procedure Gnatls is\n       end if;\n    end Find_Status;\n \n+   -----------\n+   -- GLADE --\n+   -----------\n+\n+   package body GLADE is\n+\n+      N_Flags   : Natural;\n+      N_Indents : Natural := 0;\n+\n+      type Token_Type is\n+        (T_No_ALI,\n+         T_ALI,\n+         T_Unit,\n+         T_With,\n+         T_Source,\n+         T_Afile,\n+         T_Ofile,\n+         T_Sfile,\n+         T_Name,\n+         T_Main,\n+         T_Kind,\n+         T_Flags,\n+         T_Preelaborated,\n+         T_Pure,\n+         T_Has_RACW,\n+         T_Remote_Types,\n+         T_Shared_Passive,\n+         T_RCI,\n+         T_Predefined,\n+         T_Internal,\n+         T_Is_Generic,\n+         T_Procedure,\n+         T_Function,\n+         T_Package,\n+         T_Subprogram,\n+         T_Spec,\n+         T_Body);\n+\n+      Image : constant array (Token_Type) of String_Access :=\n+        (T_No_ALI         => new String'(\"No_ALI\"),\n+         T_ALI            => new String'(\"ALI\"),\n+         T_Unit           => new String'(\"Unit\"),\n+         T_With           => new String'(\"With\"),\n+         T_Source         => new String'(\"Source\"),\n+         T_Afile          => new String'(\"Afile\"),\n+         T_Ofile          => new String'(\"Ofile\"),\n+         T_Sfile          => new String'(\"Sfile\"),\n+         T_Name           => new String'(\"Name\"),\n+         T_Main           => new String'(\"Main\"),\n+         T_Kind           => new String'(\"Kind\"),\n+         T_Flags          => new String'(\"Flags\"),\n+         T_Preelaborated  => new String'(\"Preelaborated\"),\n+         T_Pure           => new String'(\"Pure\"),\n+         T_Has_RACW       => new String'(\"Has_RACW\"),\n+         T_Remote_Types   => new String'(\"Remote_Types\"),\n+         T_Shared_Passive => new String'(\"Shared_Passive\"),\n+         T_RCI            => new String'(\"RCI\"),\n+         T_Predefined     => new String'(\"Predefined\"),\n+         T_Internal       => new String'(\"Internal\"),\n+         T_Is_Generic     => new String'(\"Is_Generic\"),\n+         T_Procedure      => new String'(\"procedure\"),\n+         T_Function       => new String'(\"function\"),\n+         T_Package        => new String'(\"package\"),\n+         T_Subprogram     => new String'(\"subprogram\"),\n+         T_Spec           => new String'(\"spec\"),\n+         T_Body           => new String'(\"body\"));\n+\n+      procedure Output_Name  (N : Name_Id);\n+      --  Remove any encoding info (%b and %s) and output N\n+\n+      procedure Output_Afile (A : File_Name_Type);\n+      procedure Output_Ofile (O : File_Name_Type);\n+      procedure Output_Sfile (S : File_Name_Type);\n+      --  Output various names. Check that the name is different from\n+      --  no name. Otherwise, skip the output.\n+\n+      procedure Output_Token (T : Token_Type);\n+      --  Output token using a specific format. That is several\n+      --  indentations and:\n+      --\n+      --  T_No_ALI  .. T_With : <token> & \" =>\" & NL\n+      --  T_Source  .. T_Kind : <token> & \" => \"\n+      --  T_Flags             : <token> & \" =>\"\n+      --  T_Preelab .. T_Body : \" \" & <token>\n+\n+      procedure Output_Sdep  (S : Sdep_Id);\n+      procedure Output_Unit  (U : Unit_Id);\n+      procedure Output_With  (W : With_Id);\n+      --  Output this entry as a global section (like ALIs)\n+\n+      ------------------\n+      -- Output_Afile --\n+      ------------------\n+\n+      procedure Output_Afile (A : File_Name_Type) is\n+      begin\n+         if A /= No_File then\n+            Output_Token (T_Afile);\n+            Write_Name (A);\n+            Write_Eol;\n+         end if;\n+      end Output_Afile;\n+\n+      ----------------\n+      -- Output_ALI --\n+      ----------------\n+\n+      procedure Output_ALI (A : ALI_Id) is\n+      begin\n+         Output_Token (T_ALI);\n+         N_Indents := N_Indents + 1;\n+\n+         Output_Afile (ALIs.Table (A).Afile);\n+         Output_Ofile (ALIs.Table (A).Ofile_Full_Name);\n+         Output_Sfile (ALIs.Table (A).Sfile);\n+\n+         --  Output Main\n+\n+         if ALIs.Table (A).Main_Program /= None then\n+            Output_Token (T_Main);\n+\n+            if ALIs.Table (A).Main_Program = Proc then\n+               Output_Token (T_Procedure);\n+            else\n+               Output_Token (T_Function);\n+            end if;\n+\n+            Write_Eol;\n+         end if;\n+\n+         --  Output Units\n+\n+         for U in ALIs.Table (A).First_Unit .. ALIs.Table (A).Last_Unit loop\n+            Output_Unit (U);\n+         end loop;\n+\n+         --  Output Sdeps\n+\n+         for S in ALIs.Table (A).First_Sdep .. ALIs.Table (A).Last_Sdep loop\n+            Output_Sdep (S);\n+         end loop;\n+\n+         N_Indents := N_Indents - 1;\n+      end Output_ALI;\n+\n+      -------------------\n+      -- Output_No_ALI --\n+      -------------------\n+\n+      procedure Output_No_ALI (Afile : File_Name_Type) is\n+      begin\n+         Output_Token (T_No_ALI);\n+         N_Indents := N_Indents + 1;\n+         Output_Afile (Afile);\n+         N_Indents := N_Indents - 1;\n+      end Output_No_ALI;\n+\n+      -----------------\n+      -- Output_Name --\n+      -----------------\n+\n+      procedure Output_Name (N : Name_Id) is\n+      begin\n+         --  Remove any encoding info (%s or %b)\n+\n+         Get_Name_String (N);\n+         if Name_Len > 2\n+           and then Name_Buffer (Name_Len - 1) = '%'\n+         then\n+            Name_Len := Name_Len - 2;\n+         end if;\n+\n+         Output_Token (T_Name);\n+         Write_Str (Name_Buffer (1 .. Name_Len));\n+         Write_Eol;\n+      end Output_Name;\n+\n+      ------------------\n+      -- Output_Ofile --\n+      ------------------\n+\n+      procedure Output_Ofile (O : File_Name_Type) is\n+      begin\n+         if O /= No_File then\n+            Output_Token (T_Ofile);\n+            Write_Name (O);\n+            Write_Eol;\n+         end if;\n+      end Output_Ofile;\n+\n+      -----------------\n+      -- Output_Sdep --\n+      -----------------\n+\n+      procedure Output_Sdep (S : Sdep_Id) is\n+      begin\n+         Output_Token (T_Source);\n+         Write_Name (Sdep.Table (S).Sfile);\n+         Write_Eol;\n+      end Output_Sdep;\n+\n+      ------------------\n+      -- Output_Sfile --\n+      ------------------\n+\n+      procedure Output_Sfile (S : File_Name_Type) is\n+         FS : File_Name_Type := S;\n+\n+      begin\n+         if FS /= No_File then\n+\n+            --  We want to output the full source name\n+\n+            FS := Full_Source_Name (FS);\n+\n+            --  There is no full source name. This occurs for instance when a\n+            --  withed unit has a spec file but no body file. This situation\n+            --  is not a problem for GLADE since the unit may be located on\n+            --  a partition we do not want to build. However, we need to\n+            --  locate the spec file and to find its full source name.\n+            --  Replace the body file name with the spec file name used to\n+            --  compile the current unit when possible.\n+\n+            if FS = No_File then\n+               Get_Name_String (S);\n+\n+               if Name_Len > 4\n+                 and then Name_Buffer (Name_Len - 3 .. Name_Len) = \".adb\"\n+               then\n+                  Name_Buffer (Name_Len) := 's';\n+                  FS := Full_Source_Name (Name_Find);\n+               end if;\n+            end if;\n+         end if;\n+\n+         if FS /= No_File then\n+            Output_Token (T_Sfile);\n+            Write_Name (FS);\n+            Write_Eol;\n+         end if;\n+      end Output_Sfile;\n+\n+      ------------------\n+      -- Output_Token --\n+      ------------------\n+\n+      procedure Output_Token (T : Token_Type) is\n+      begin\n+         if T in T_No_ALI .. T_Flags then\n+            for J in 1 .. N_Indents loop\n+               Write_Str (\"   \");\n+            end loop;\n+\n+            Write_Str (Image (T).all);\n+\n+            for J in Image (T)'Length .. 12 loop\n+               Write_Char (' ');\n+            end loop;\n+\n+            Write_Str (\"=>\");\n+\n+            if T in T_No_ALI .. T_With then\n+               Write_Eol;\n+            elsif T in T_Source .. T_Name then\n+               Write_Char (' ');\n+            end if;\n+\n+         elsif T in T_Preelaborated .. T_Body then\n+            if T in T_Preelaborated .. T_Is_Generic then\n+               if N_Flags = 0 then\n+                  Output_Token (T_Flags);\n+               end if;\n+\n+               N_Flags := N_Flags + 1;\n+            end if;\n+\n+            Write_Char (' ');\n+            Write_Str  (Image (T).all);\n+\n+         else\n+            Write_Str  (Image (T).all);\n+         end if;\n+      end Output_Token;\n+\n+      -----------------\n+      -- Output_Unit --\n+      -----------------\n+\n+      procedure Output_Unit (U : Unit_Id) is\n+      begin\n+         Output_Token (T_Unit);\n+         N_Indents := N_Indents + 1;\n+\n+         --  Output Name\n+\n+         Output_Name (Units.Table (U).Uname);\n+\n+         --  Output Kind\n+\n+         Output_Token (T_Kind);\n+\n+         if Units.Table (U).Unit_Kind = 'p' then\n+            Output_Token (T_Package);\n+         else\n+            Output_Token (T_Subprogram);\n+         end if;\n+\n+         if Name_Buffer (Name_Len) = 's' then\n+            Output_Token (T_Spec);\n+         else\n+            Output_Token (T_Body);\n+         end if;\n+\n+         Write_Eol;\n+\n+         --  Output source file name\n+\n+         Output_Sfile (Units.Table (U).Sfile);\n+\n+         --  Output Flags\n+\n+         N_Flags := 0;\n+\n+         if Units.Table (U).Preelab then\n+            Output_Token (T_Preelaborated);\n+         end if;\n+\n+         if Units.Table (U).Pure then\n+            Output_Token (T_Pure);\n+         end if;\n+\n+         if Units.Table (U).Has_RACW then\n+            Output_Token (T_Has_RACW);\n+         end if;\n+\n+         if Units.Table (U).Remote_Types then\n+            Output_Token (T_Remote_Types);\n+         end if;\n+\n+         if Units.Table (U).Shared_Passive then\n+            Output_Token (T_Shared_Passive);\n+         end if;\n+\n+         if Units.Table (U).RCI then\n+            Output_Token (T_RCI);\n+         end if;\n+\n+         if Units.Table (U).Predefined then\n+            Output_Token (T_Predefined);\n+         end if;\n+\n+         if Units.Table (U).Internal then\n+            Output_Token (T_Internal);\n+         end if;\n+\n+         if Units.Table (U).Is_Generic then\n+            Output_Token (T_Is_Generic);\n+         end if;\n+\n+         if N_Flags > 0 then\n+            Write_Eol;\n+         end if;\n+\n+         --  Output Withs\n+\n+         for W in Units.Table (U).First_With .. Units.Table (U).Last_With loop\n+            Output_With (W);\n+         end loop;\n+\n+         N_Indents := N_Indents - 1;\n+      end Output_Unit;\n+\n+      -----------------\n+      -- Output_With --\n+      -----------------\n+\n+      procedure Output_With (W : With_Id) is\n+      begin\n+         Output_Token (T_With);\n+         N_Indents := N_Indents + 1;\n+\n+         Output_Name (Withs.Table (W).Uname);\n+\n+         --  Output Kind\n+\n+         Output_Token (T_Kind);\n+\n+         if Name_Buffer (Name_Len) = 's' then\n+            Output_Token (T_Spec);\n+         else\n+            Output_Token (T_Body);\n+         end if;\n+\n+         Write_Eol;\n+\n+         Output_Afile (Withs.Table (W).Afile);\n+         Output_Sfile (Withs.Table (W).Sfile);\n+\n+         N_Indents := N_Indents - 1;\n+      end Output_With;\n+\n+   end GLADE;\n+\n    -----------\n    -- Image --\n    -----------\n@@ -629,6 +1048,7 @@ procedure Gnatls is\n             declare\n                Restrictions : constant Restrictions_Info :=\n                                 ALIs.Table (ALI).Restrictions;\n+\n             begin\n                --  If the source was compiled with pragmas Restrictions,\n                --  Display these restrictions.\n@@ -721,6 +1141,7 @@ procedure Gnatls is\n    procedure Scan_Ls_Arg (Argv : String) is\n       FD  : File_Descriptor;\n       Len : Integer;\n+\n    begin\n       pragma Assert (Argv'First = 1);\n \n@@ -729,7 +1150,6 @@ procedure Gnatls is\n       end if;\n \n       if Argv (1) = '-' then\n-\n          if Argv'Length = 1 then\n             Fail (\"switch character cannot be followed by a blank\");\n \n@@ -782,6 +1202,7 @@ procedure Gnatls is\n                when 'o' => Reset_Print; Print_Object := True;\n                when 'v' => Verbose_Mode              := True;\n                when 'd' => Dependable                := True;\n+               when 'V' => Very_Verbose_Mode         := True;\n \n                when others => null;\n             end case;\n@@ -911,9 +1332,6 @@ procedure Gnatls is\n    -----------\n \n    procedure Usage is\n-\n-   --  Start of processing for Usage\n-\n    begin\n       --  Usage line\n \n@@ -1020,7 +1438,7 @@ procedure Gnatls is\n \n    end Usage;\n \n-   --   Start of processing for Gnatls\n+--   Start of processing for Gnatls\n \n begin\n    --  Initialize standard packages\n@@ -1063,11 +1481,6 @@ begin\n    if Verbose_Mode then\n       Targparm.Get_Target_Parameters;\n \n-      --  WARNING: the output of gnatls -v is used during the compilation\n-      --  and installation of GLADE to recreate sdefault.adb and locate\n-      --  the libgnat.a to use. Any change in the output of gnatls -v must\n-      --  be synchronized with the GLADE Dist/config.sdefault shell script.\n-\n       Write_Eol;\n       Write_Str (\"GNATLS \");\n       Write_Str (Gnat_Version_String);\n@@ -1132,15 +1545,20 @@ begin\n \n    while More_Lib_Files loop\n       Main_File := Next_Main_Lib_File;\n-      Ali_File := Full_Lib_File_Name (Lib_File_Name (Main_File));\n+      Ali_File  := Full_Lib_File_Name (Lib_File_Name (Main_File));\n \n       if Ali_File = No_File then\n-         Write_Str (\"Can't find library info for \");\n-         Get_Name_String (Main_File);\n-         Write_Char ('\"');\n-         Write_Str (Name_Buffer (1 .. Name_Len));\n-         Write_Char ('\"');\n-         Write_Eol;\n+         if Very_Verbose_Mode then\n+            GLADE.Output_No_ALI (Lib_File_Name (Main_File));\n+\n+         else\n+            Write_Str (\"Can't find library info for \");\n+            Get_Name_String (Main_File);\n+            Write_Char ('\"'); -- \"\n+            Write_Str (Name_Buffer (1 .. Name_Len));\n+            Write_Char ('\"'); -- \"\n+            Write_Eol;\n+         end if;\n \n       else\n          Ali_File := Strip_Directory (Ali_File);\n@@ -1166,6 +1584,14 @@ begin\n       end if;\n    end loop;\n \n+   if Very_Verbose_Mode then\n+      for A in ALIs.First .. ALIs.Last loop\n+         GLADE.Output_ALI (A);\n+      end loop;\n+\n+      return;\n+   end if;\n+\n    Find_General_Layout;\n \n    for Id in ALIs.First .. ALIs.Last loop"}, {"sha": "189ee917691ea075e2dee3d5e4ec308b0991011d", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -224,8 +224,7 @@ package body Impunit is\n      \"g-memdum\",    -- GNAT.Memory_Dump\n      \"g-moreex\",    -- GNAT.Most_Recent_Exception\n      \"g-os_lib\",    -- GNAT.Os_Lib\n-     \"g-pehage\",    -- GNAT.Perfect_Hash.Generators\n-     \"g-perhas\",    -- GNAT.Perfect_Hash\n+     \"g-pehage\",    -- GNAT.Perfect_Hash_Generators\n      \"g-regexp\",    -- GNAT.Regexp\n      \"g-regist\",    -- GNAT.Registry\n      \"g-regpat\",    -- GNAT.Regpat"}, {"sha": "4a54affe47733b968f9be63d06f6984b995d289e", "filename": "gcc/ada/init.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -111,6 +111,7 @@ int   __gl_num_interrupt_states     = 0;\n int   __gl_unreserve_all_interrupts = 0;\n int   __gl_exception_tracebacks     = 0;\n int   __gl_zero_cost_exceptions     = 0;\n+int   __gl_detect_blocking          = 0;\n \n /* Indication of whether synchronous signal handler has already been\n    installed by a previous call to adainit */\n@@ -173,7 +174,8 @@ __gnat_set_globals (int main_priority,\n                     int num_interrupt_states,\n                     int unreserve_all_interrupts,\n                     int exception_tracebacks,\n-                    int zero_cost_exceptions)\n+                    int zero_cost_exceptions,\n+                    int detect_blocking)\n {\n   static int already_called = 0;\n \n@@ -236,6 +238,7 @@ __gnat_set_globals (int main_priority,\n   __gl_task_dispatching_policy  = task_dispatching_policy;\n   __gl_unreserve_all_interrupts = unreserve_all_interrupts;\n   __gl_exception_tracebacks     = exception_tracebacks;\n+  __gl_detect_blocking          = detect_blocking;\n \n   /* ??? __gl_zero_cost_exceptions is new in 3.15 and is referenced from\n      a-except.adb, which is also part of the compiler sources. Since the"}, {"sha": "36240549d043227a55f582428515c500015bee24", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -856,6 +856,10 @@ package body Lib.Writ is\n          Write_Info_Str (\" CE\");\n       end if;\n \n+      if Opt.Detect_Blocking then\n+         Write_Info_Str (\" DB\");\n+      end if;\n+\n       if Opt.Float_Format /= ' ' then\n          Write_Info_Str (\" F\");\n "}, {"sha": "2cc6b568cb01895416cc880d64d7799680ca5b4d", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -181,6 +181,9 @@ package Lib.Writ is\n    --              format will be correct and complete. Note that NO is\n    --              always present if CE is present.\n    --\n+   --         DB   Detect_Blocking pragma is in effect for all units in\n+   --              this file.\n+   --\n    --         FD   Configuration pragmas apply to all the units in this\n    --              file specifying a possibly non-standard floating point\n    --              format (VAX float with Long_Float using D_Float)"}, {"sha": "70b349f5482881a670fa2f54dda57e33db6bba7d", "filename": "gcc/ada/link.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Flink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Flink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flink.c?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -157,9 +157,9 @@ const char *__gnat_object_library_extension = \".a\";\n char *__gnat_object_file_option = \"\";\n char *__gnat_run_path_option = \"-Wl,-rpath,\";\n char __gnat_shared_libgnat_default = STATIC;\n-int __gnat_link_max = 2147483647;\n-unsigned char __gnat_objlist_file_supported = 0;\n-unsigned char __gnat_using_gnu_linker = 0;\n+int __gnat_link_max = 8192;\n+unsigned char __gnat_objlist_file_supported = 1;\n+unsigned char __gnat_using_gnu_linker = 1;\n char *__gnat_object_library_extension = \".a\";\n \n #elif defined (linux)"}, {"sha": "be8ace85db855cc0ce3a129e62d2bd7a1f1237dc", "filename": "gcc/ada/mdll.adb", "status": "modified", "additions": 41, "deletions": 18, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fmdll.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fmdll.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmdll.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -52,7 +52,8 @@ package body MDLL is\n       Def_Filename  : String;\n       Lib_Address   : String  := \"\";\n       Build_Import  : Boolean := False;\n-      Relocatable   : Boolean := False)\n+      Relocatable   : Boolean := False;\n+      Map_File      : Boolean := False)\n    is\n \n       use type OS_Lib.Argument_List;\n@@ -70,6 +71,7 @@ package body MDLL is\n       Lib_Opt  : aliased String := \"-mdll\";\n       Out_Opt  : aliased String := \"-o\";\n       Adr_Opt  : aliased String := \"-Wl,--image-base=\" & Lib_Address;\n+      Map_Opt  : aliased String := \"-Wl,-Map,\" & Lib_Filename & \".map\";\n \n       L_Afiles : Argument_List := Afiles;\n       --  Local afiles list. This list can be reordered to ensure that the\n@@ -97,12 +99,10 @@ package body MDLL is\n \n       procedure Build_Reloc_DLL is\n          --  Objects plus the export table (.exp) file\n-\n          Objects_Exp_File : constant OS_Lib.Argument_List\n            := Exp_File'Unchecked_Access & Ofiles;\n \n          Success : Boolean;\n-\n       begin\n          if not Quiet then\n             Text_IO.Put_Line (\"building relocatable DLL...\");\n@@ -147,10 +147,20 @@ package body MDLL is\n \n          --  5) Build the dynamic library\n \n-         Utl.Gcc (Output_File => Dll_File,\n-                  Files       => Objects_Exp_File,\n-                  Options     => Adr_Opt'Unchecked_Access & All_Options,\n-                  Build_Lib   => True);\n+         declare\n+            Params : OS_Lib.Argument_List :=\n+                       Adr_Opt'Unchecked_Access & All_Options;\n+         begin\n+            if Map_File then\n+               Params := Map_Opt'Unchecked_Access & Params;\n+            end if;\n+\n+            Utl.Gcc\n+              (Output_File => Dll_File,\n+               Files       => Objects_Exp_File,\n+               Options     => Params,\n+               Build_Lib   => True);\n+         end;\n \n          OS_Lib.Delete_File (Exp_File, Success);\n          OS_Lib.Delete_File (Bas_File, Success);\n@@ -234,7 +244,7 @@ package body MDLL is\n          Utl.Gnatbind (L_Afiles, Options & Bargs_Options);\n \n          declare\n-            Params : constant OS_Lib.Argument_List :=\n+            Params : OS_Lib.Argument_List :=\n                        Out_Opt'Unchecked_Access &\n                        Dll_File'Unchecked_Access &\n                        Lib_Opt'Unchecked_Access &\n@@ -243,6 +253,10 @@ package body MDLL is\n                        Ofiles &\n                        All_Options;\n          begin\n+            if Map_File then\n+               Params := Map_Opt'Unchecked_Access & Params;\n+            end if;\n+\n             Utl.Gnatlink (L_Afiles (L_Afiles'Last).all, Params);\n          end;\n \n@@ -285,10 +299,19 @@ package body MDLL is\n \n          --  Build the DLL\n \n-         Utl.Gcc (Output_File => Dll_File,\n-                  Files       => Exp_File'Unchecked_Access & Ofiles,\n-                  Options     => Adr_Opt'Unchecked_Access & All_Options,\n-                  Build_Lib   => True);\n+         declare\n+            Params : OS_Lib.Argument_List :=\n+                       Adr_Opt'Unchecked_Access & All_Options;\n+         begin\n+            if Map_File then\n+               Params :=  Map_Opt'Unchecked_Access & Params;\n+            end if;\n+\n+            Utl.Gcc (Output_File => Dll_File,\n+                     Files       => Exp_File'Unchecked_Access & Ofiles,\n+                     Options     => Params,\n+                     Build_Lib   => True);\n+         end;\n \n          OS_Lib.Delete_File (Exp_File, Success);\n \n@@ -330,7 +353,7 @@ package body MDLL is\n          Utl.Gnatbind (L_Afiles, Options & Bargs_Options);\n \n          declare\n-            Params : constant OS_Lib.Argument_List :=\n+            Params : OS_Lib.Argument_List :=\n                        Out_Opt'Unchecked_Access &\n                        Dll_File'Unchecked_Access &\n                        Lib_Opt'Unchecked_Access &\n@@ -339,6 +362,10 @@ package body MDLL is\n                        Ofiles &\n                        All_Options;\n          begin\n+            if Map_File then\n+               Params := Map_Opt'Unchecked_Access & Params;\n+            end if;\n+\n             Utl.Gnatlink (L_Afiles (L_Afiles'Last).all, Params);\n          end;\n \n@@ -370,7 +397,6 @@ package body MDLL is\n       end if;\n \n       case Relocatable is\n-\n          when True =>\n             if L_Afiles'Length = 0 then\n                Build_Reloc_DLL;\n@@ -384,7 +410,6 @@ package body MDLL is\n             else\n                Ada_Build_Non_Reloc_DLL;\n             end if;\n-\n       end case;\n    end Build_Dynamic_Library;\n \n@@ -408,13 +433,11 @@ package body MDLL is\n       --------------------------\n \n       procedure Build_Import_Library (Def_Base_Filename : String) is\n-\n          Def_File : String renames Def_Filename;\n          Dll_File : constant String := Def_Base_Filename & \".dll\";\n          Lib_File : constant String := \"lib\" & Base_Filename & \".a\";\n \n       begin\n-\n          if not Quiet then\n             Text_IO.Put_Line (\"Building import library...\");\n             Text_IO.Put_Line (\"make \" & Lib_File &"}, {"sha": "495e025aabb95f1f1f1bed50e6269aef705c280e", "filename": "gcc/ada/mdll.ads", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fmdll.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fmdll.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmdll.ads?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,6 +28,7 @@\n --  to build Windows DLL\n \n with GNAT.OS_Lib;\n+--  Should have USE here ???\n \n package MDLL is\n \n@@ -36,20 +37,21 @@ package MDLL is\n \n    Null_Argument_List : constant Argument_List := (1 .. 0 => new String'(\"\"));\n \n-   Null_Argument_List_Access : Argument_List_Access\n-     := new Argument_List (1 .. 0);\n+   Null_Argument_List_Access : Argument_List_Access :=\n+                                 new Argument_List (1 .. 0);\n \n-   Tools_Error    : exception;\n+   Tools_Error : exception;\n+   --  Commment required\n \n-   Verbose        : Boolean := False;\n-   Quiet          : Boolean := False;\n+   Verbose : Boolean := False;\n+   Quiet   : Boolean := False;\n+   --  Comment required ???\n \n+   Kill_Suffix : Boolean := False;\n    --  Kill_Suffix is used by dlltool to know whether or not the @nn suffix\n    --  should be removed from the exported names. When Kill_Suffix is set to\n    --  True then dlltool -k option is used.\n \n-   Kill_Suffix    : Boolean := False;\n-\n    procedure Build_Dynamic_Library\n      (Ofiles        : Argument_List;\n       Afiles        : Argument_List;\n@@ -60,14 +62,16 @@ package MDLL is\n       Def_Filename  : String;\n       Lib_Address   : String  := \"\";\n       Build_Import  : Boolean := False;\n-      Relocatable   : Boolean := False);\n+      Relocatable   : Boolean := False;\n+      Map_File      : Boolean := False);\n    --  Build a DLL and the import library to link against the DLL.\n    --  this function handles relocatable and non relocatable DLL.\n    --  If the Afiles argument list contains some Ada units then it will\n    --  generate the right adainit and adafinal and integrate it in the DLL.\n    --  If the Afiles argument list is empty (there is only some object files\n    --  provided) then it will not try to build a binder file. This is ok to\n-   --  build DLL containing no Ada code.\n+   --  build DLL containing no Ada code. If Map_File is set to True, a map\n+   --  file named Lib_Filename & \".map\" will be created.\n \n    procedure Build_Import_Library\n      (Lib_Filename : String;"}, {"sha": "528cbffaf9981631a9d0500a81f601c6cb45a17e", "filename": "gcc/ada/opt.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fopt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fopt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -98,7 +98,7 @@ package body Opt is\n    procedure Set_Opt_Config_Switches (Internal_Unit : Boolean) is\n    begin\n       if Internal_Unit then\n-         Ada_Version                := Ada_Version_Default;\n+         Ada_Version                := Ada_Version_Runtime;\n          Dynamic_Elaboration_Checks := False;\n          Extensions_Allowed         := True;\n          External_Name_Exp_Casing   := As_Is;"}, {"sha": "e710275b74a90a20616659cc3a7ee0bf4c6ae283", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -72,6 +72,10 @@ package Opt is\n    --  GNAT\n    --  Current Ada version for compiler\n \n+   Ada_Version_Runtime : Ada_Version_Type := Ada_05;\n+   --  GNAT\n+   --  Ada version used to compile the runtime\n+\n    Ada_Final_Suffix : constant String := \"final\";\n    Ada_Final_Name : String_Ptr := new String'(\"ada\" & Ada_Final_Suffix);\n    --  GNATBIND"}, {"sha": "324b7dcde30ce1200364876a0e98b2e938e4cf01", "filename": "gcc/ada/prj-attr.adb", "status": "modified", "additions": 31, "deletions": 93, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fprj-attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fprj-attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -24,8 +24,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Namet; use Namet;\n-with Osint; use Osint;\n+with Namet;   use Namet;\n+with Osint;\n+with Prj.Com; use Prj.Com;\n with Table;\n \n with System.Case_Util; use System.Case_Util;\n@@ -39,11 +40,13 @@ package body Prj.Attr is\n    --  Package names are preceded by 'P'\n \n    --  Attribute names are preceded by two letters:\n+\n    --  The first letter is one of\n    --    'S' for Single\n    --    's' for Single with optional index\n    --    'L' for List\n    --    'l' for List of strings with optional indexes\n+\n    --  The second letter is one of\n    --    'V' for single variable\n    --    'A' for associative array\n@@ -186,90 +189,9 @@ package body Prj.Attr is\n    Initialized : Boolean := False;\n    --  A flag to avoid multiple initialization\n \n-   ----------------\n-   -- Attributes --\n-   ----------------\n-\n-   type Attribute_Record is record\n-      Name           : Name_Id;\n-      Var_Kind       : Variable_Kind;\n-      Optional_Index : Boolean;\n-      Attr_Kind      : Attribute_Kind;\n-      Next           : Attr_Node_Id;\n-   end record;\n-   --  Data for an attribute\n-\n-   package Attrs is\n-      new Table.Table (Table_Component_Type => Attribute_Record,\n-                       Table_Index_Type     => Attr_Node_Id,\n-                       Table_Low_Bound      => First_Attribute,\n-                       Table_Initial        => Attributes_Initial,\n-                       Table_Increment      => Attributes_Increment,\n-                       Table_Name           => \"Prj.Attr.Attrs\");\n-   --  The table of the attributes\n-\n-   --------------\n-   -- Packages --\n-   --------------\n-\n-   type Package_Record is record\n-      Name            : Name_Id;\n-      Known           : Boolean := True;\n-      First_Attribute : Attr_Node_Id;\n-   end record;\n-   --  Data for a package\n-\n-   package Package_Attributes is\n-      new Table.Table (Table_Component_Type => Package_Record,\n-                       Table_Index_Type     => Pkg_Node_Id,\n-                       Table_Low_Bound      => First_Package,\n-                       Table_Initial        => Packages_Initial,\n-                       Table_Increment      => Packages_Increment,\n-                       Table_Name           => \"Prj.Attr.Packages\");\n-   --  The table of the packages\n-\n    function Name_Id_Of (Name : String) return Name_Id;\n    --  Returns the Name_Id for Name in lower case\n \n-   -------------------\n-   -- Add_Attribute --\n-   -------------------\n-\n-   procedure Add_Attribute\n-     (To_Package     : Package_Node_Id;\n-      Attribute_Name : Name_Id;\n-      Attribute_Node : out Attribute_Node_Id)\n-   is\n-   begin\n-      --  Only add the attribute if the package is already defined\n-\n-      if To_Package /= Empty_Package then\n-         Attrs.Increment_Last;\n-         Attrs.Table (Attrs.Last) :=\n-           (Name              => Attribute_Name,\n-            Var_Kind          => Undefined,\n-            Optional_Index    => False,\n-            Attr_Kind         => Unknown,\n-            Next              =>\n-              Package_Attributes.Table (To_Package.Value).First_Attribute);\n-         Package_Attributes.Table (To_Package.Value).First_Attribute :=\n-           Attrs.Last;\n-         Attribute_Node := (Value => Attrs.Last);\n-      end if;\n-   end Add_Attribute;\n-\n-   -------------------------\n-   -- Add_Unknown_Package --\n-   -------------------------\n-\n-   procedure Add_Unknown_Package (Name : Name_Id; Id : out Package_Node_Id) is\n-   begin\n-      Package_Attributes.Increment_Last;\n-      Id := (Value => Package_Attributes.Last);\n-      Package_Attributes.Table (Id.Value) :=\n-        (Name => Name, Known => False, First_Attribute => Empty_Attr);\n-   end Add_Unknown_Package;\n-\n    -----------------------\n    -- Attribute_Kind_Of --\n    -----------------------\n@@ -307,6 +229,7 @@ package body Prj.Attr is\n       Starting_At : Attribute_Node_Id) return Attribute_Node_Id\n    is\n       Id : Attr_Node_Id := Starting_At.Value;\n+\n    begin\n       while Id /= Empty_Attr\n         and then Attrs.Table (Id).Name /= Name\n@@ -386,7 +309,7 @@ package body Prj.Attr is\n \n                for Index in First_Package .. Package_Attributes.Last loop\n                   if Package_Name = Package_Attributes.Table (Index).Name then\n-                     Fail (\"duplicate name \"\"\",\n+                     Osint.Fail (\"duplicate name \"\"\",\n                            Initialization_Data (Start .. Finish - 1),\n                            \"\"\" in predefined packages.\");\n                   end if;\n@@ -438,14 +361,14 @@ package body Prj.Attr is\n                   Attr_Kind := Case_Insensitive_Associative_Array;\n \n                when 'b' =>\n-                  if File_Names_Case_Sensitive then\n+                  if Osint.File_Names_Case_Sensitive then\n                      Attr_Kind := Associative_Array;\n                   else\n                      Attr_Kind := Case_Insensitive_Associative_Array;\n                   end if;\n \n                when 'c' =>\n-                  if File_Names_Case_Sensitive then\n+                  if Osint.File_Names_Case_Sensitive then\n                      Attr_Kind := Optional_Index_Associative_Array;\n                   else\n                      Attr_Kind :=\n@@ -480,7 +403,7 @@ package body Prj.Attr is\n \n                for Index in First_Attribute .. Attrs.Last - 1 loop\n                   if Attribute_Name = Attrs.Table (Index).Name then\n-                     Fail (\"duplicate attribute \"\"\",\n+                     Osint.Fail (\"duplicate attribute \"\"\",\n                            Initialization_Data (Start .. Finish - 1),\n                            \"\"\" in \" & Attribute_Location);\n                   end if;\n@@ -581,11 +504,13 @@ package body Prj.Attr is\n    begin\n       if Name'Length = 0 then\n          Fail (\"cannot register an attribute with no name\");\n+         raise Project_Error;\n       end if;\n \n       if In_Package = Empty_Package then\n          Fail (\"attempt to add attribute \"\"\", Name,\n                \"\"\" to an undefined package\");\n+         raise Project_Error;\n       end if;\n \n       Attr_Name := Name_Id_Of (Name);\n@@ -603,7 +528,7 @@ package body Prj.Attr is\n                   Get_Name_String\n                     (Package_Attributes.Table (In_Package.Value).Name) &\n                   \"\"\"\");\n-            exit;\n+            raise Project_Error;\n          end if;\n \n          Curr_Attr := Attrs.Table (Curr_Attr).Next;\n@@ -613,7 +538,7 @@ package body Prj.Attr is\n \n       --  If Index_Is_File_Name, change the attribute kind if necessary\n \n-      if Index_Is_File_Name  and then not File_Names_Case_Sensitive then\n+      if Index_Is_File_Name and then not Osint.File_Names_Case_Sensitive then\n          case Attr_Kind is\n             when Associative_Array =>\n                Real_Attr_Kind := Case_Insensitive_Associative_Array;\n@@ -645,14 +570,26 @@ package body Prj.Attr is\n    --------------------------\n \n    procedure Register_New_Package (Name : String; Id : out Package_Node_Id) is\n-      Pkg_Name   : Name_Id;\n+      Pkg_Name : Name_Id;\n \n    begin\n       if Name'Length = 0 then\n          Fail (\"cannot register a package with no name\");\n+         Id := Empty_Package;\n+         return;\n       end if;\n \n       Pkg_Name := Name_Id_Of (Name);\n+\n+      for Index in Package_Attributes.First .. Package_Attributes.Last loop\n+         if Package_Attributes.Table (Index).Name = Pkg_Name then\n+            Fail (\"cannot register a package with a non unique name\"\"\",\n+                  Name, \"\"\"\");\n+            Id := Empty_Package;\n+            return;\n+         end if;\n+      end loop;\n+\n       Package_Attributes.Increment_Last;\n       Id := (Value => Package_Attributes.Last);\n       Package_Attributes.Table (Package_Attributes.Last) :=\n@@ -672,6 +609,7 @@ package body Prj.Attr is\n    begin\n       if Name'Length = 0 then\n          Fail (\"cannot register a package with no name\");\n+         raise Project_Error;\n       end if;\n \n       Pkg_Name := Name_Id_Of (Name);\n@@ -680,7 +618,7 @@ package body Prj.Attr is\n          if Package_Attributes.Table (Index).Name = Pkg_Name then\n             Fail (\"cannot register a package with a non unique name\"\"\",\n                   Name, \"\"\"\");\n-            exit;\n+            raise Project_Error;\n          end if;\n       end loop;\n \n@@ -692,7 +630,7 @@ package body Prj.Attr is\n             if Attrs.Table (Curr_Attr).Name = Attr_Name then\n                Fail (\"duplicate attribute name \"\"\", Attributes (Index).Name,\n                      \"\"\" in new package \"\"\" & Name & \"\"\"\");\n-               exit;\n+               raise Project_Error;\n             end if;\n \n             Curr_Attr := Attrs.Table (Curr_Attr).Next;\n@@ -701,7 +639,7 @@ package body Prj.Attr is\n          Attr_Kind := Attributes (Index).Attr_Kind;\n \n          if Attributes (Index).Index_Is_File_Name\n-           and then not File_Names_Case_Sensitive\n+           and then not Osint.File_Names_Case_Sensitive\n          then\n             case Attr_Kind is\n                when Associative_Array =>"}, {"sha": "4c0968934263c580b557aef3a09aaa39c14ccd69", "filename": "gcc/ada/prj-attr.ads", "status": "modified", "additions": 59, "deletions": 23, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fprj-attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fprj-attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.ads?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -86,18 +86,21 @@ package Prj.Attr is\n    --  explicitly with Register_New_Package (see below).\n \n    type Attribute_Data_Array is array (Positive range <>) of Attribute_Data;\n+   --  A list of attribute name/characteristics to be used as parameter of\n+   --  procedure Register_New_Package below.\n+\n+   --  In the subprograms below, when it is specified that the subprogram\n+   --  \"fails\", procedure Prj.Com.Fail is called. Unless it is specified\n+   --  otherwise, if Prj.Com.Fail returns, exception Prj.Prj_Error is raised.\n \n    procedure Register_New_Package\n      (Name       : String;\n       Attributes : Attribute_Data_Array);\n    --  Add a new package with its attributes.\n    --  This procedure can only be called after Initialize, but before any\n    --  other call to a service of the Project Managers.\n-   --  The name of the package must be unique. The names of the attributes\n-   --  must be different.\n-\n-   --  The following declarations are only for the Project Manager, that is\n-   --  the packages of the Prj or MLib hierarchies.\n+   --  Fail if the name of the package is empty or not unique, or if the names\n+   --  of the attributes are not different.\n \n    ----------------\n    -- Attributes --\n@@ -168,9 +171,11 @@ package Prj.Attr is\n    --  Default value of Package_Node_Id objects\n \n    procedure Register_New_Package (Name : String; Id : out Package_Node_Id);\n-   --  Add a new package. Fails if the package has a duplicate name.\n-   --  Initially, the new package has no attributes. Id may be used to add\n-   --  attributes using procedure Register_New_Attribute below.\n+   --  Add a new package. Fails if Name (the package name) is empty or is\n+   --  already the name of a package, and set Id to Empty_Package,\n+   --  if Prj.Com.Fail returns. Initially, the new package has no attributes.\n+   --  Id may be used to add attributes using procedure Register_New_Attribute\n+   --  below.\n \n    procedure Register_New_Attribute\n      (Name               : String;\n@@ -179,32 +184,21 @@ package Prj.Attr is\n       Var_Kind           : Defined_Variable_Kind;\n       Index_Is_File_Name : Boolean := False;\n       Opt_Index          : Boolean := False);\n-   --  Add a new attribute to registered package In_Package. Fails if the\n-   --  attribute has a duplicate name. See definition of type Attribute_Data\n-   --  above for the meaning of parameters Attr_Kind, Var_Kind,\n+   --  Add a new attribute to registered package In_Package. Fails if Name\n+   --  (the attribute name) is empty, if In_Package is Empty_Package or if\n+   --  the attribute name has a duplicate name. See definition of type\n+   --  Attribute_Data above for the meaning of parameters Attr_Kind, Var_Kind,\n    --  Index_Is_File_Name and Opt_Index.\n \n    function Package_Node_Id_Of (Name : Name_Id) return Package_Node_Id;\n    --  Returns the package node id of the package with name Name. Returns\n    --  Empty_Package if there is no package with this name.\n \n-   procedure Add_Unknown_Package (Name : Name_Id; Id : out Package_Node_Id);\n-   --  Add a new package. The Name cannot be the name of a predefined or\n-   --  already registered package.\n-\n    function First_Attribute_Of\n      (Pkg : Package_Node_Id) return Attribute_Node_Id;\n    --  Returns the first attribute in the list of attributes of package Pkg.\n    --  Returns Empty_Attribute if Pkg is Empty_Package.\n \n-   procedure Add_Attribute\n-     (To_Package     : Package_Node_Id;\n-      Attribute_Name : Name_Id;\n-      Attribute_Node : out Attribute_Node_Id);\n-   --  Add an attribute to the list for package To_Package. Attribute_Name\n-   --  cannot be the name of an existing attribute of the package.\n-   --  Does nothing if To_Package is Empty_Package.\n-\n private\n    ----------------\n    -- Attributes --\n@@ -266,4 +260,46 @@ private\n \n    Package_First : constant Package_Node_Id := First_Package_Node_Id;\n \n+   ----------------\n+   -- Attributes --\n+   ----------------\n+\n+   type Attribute_Record is record\n+      Name           : Name_Id;\n+      Var_Kind       : Variable_Kind;\n+      Optional_Index : Boolean;\n+      Attr_Kind      : Attribute_Kind;\n+      Next           : Attr_Node_Id;\n+   end record;\n+   --  Data for an attribute\n+\n+   package Attrs is\n+      new Table.Table (Table_Component_Type => Attribute_Record,\n+                       Table_Index_Type     => Attr_Node_Id,\n+                       Table_Low_Bound      => First_Attribute,\n+                       Table_Initial        => Attributes_Initial,\n+                       Table_Increment      => Attributes_Increment,\n+                       Table_Name           => \"Prj.Attr.Attrs\");\n+   --  The table of the attributes\n+\n+   --------------\n+   -- Packages --\n+   --------------\n+\n+   type Package_Record is record\n+      Name            : Name_Id;\n+      Known           : Boolean := True;\n+      First_Attribute : Attr_Node_Id;\n+   end record;\n+   --  Data for a package\n+\n+   package Package_Attributes is\n+      new Table.Table (Table_Component_Type => Package_Record,\n+                       Table_Index_Type     => Pkg_Node_Id,\n+                       Table_Low_Bound      => First_Package,\n+                       Table_Initial        => Packages_Initial,\n+                       Table_Increment      => Packages_Increment,\n+                       Table_Name           => \"Prj.Attr.Packages\");\n+   --  The table of the packages\n+\n end Prj.Attr;"}, {"sha": "e030236afe8517f9ff8e9fba9fab1e52f857a413", "filename": "gcc/ada/prj-dect.adb", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fprj-dect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fprj-dect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-dect.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -24,17 +24,18 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Err_Vars; use Err_Vars;\n-with Namet;    use Namet;\n-with Opt;      use Opt;\n-with Prj.Err;  use Prj.Err;\n-with Prj.Strt; use Prj.Strt;\n-with Prj.Tree; use Prj.Tree;\n-with Scans;    use Scans;\n+with Err_Vars;    use Err_Vars;\n+with Namet;       use Namet;\n+with Opt;         use Opt;\n+with Prj.Err;     use Prj.Err;\n+with Prj.Strt;    use Prj.Strt;\n+with Prj.Tree;    use Prj.Tree;\n+with Scans;       use Scans;\n with Snames;\n-with Types;    use Types;\n-with Prj.Attr; use Prj.Attr;\n-with Uintp;    use Uintp;\n+with Types;       use Types;\n+with Prj.Attr;    use Prj.Attr;\n+with Prj.Attr.PM; use Prj.Attr.PM;\n+with Uintp;       use Uintp;\n \n package body Prj.Dect is\n \n@@ -876,7 +877,6 @@ package body Prj.Dect is\n       --  Scan past \"package\"\n \n       Scan;\n-\n       Expect (Tok_Identifier, \"identifier\");\n \n       if Token = Tok_Identifier then"}, {"sha": "41ca8d9fbc1b49573482ee76a0fdf2181a733c18", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -699,6 +699,9 @@ package Prj is\n \n    end record;\n \n+   Project_Error : exception;\n+   --  Raised by some subprograms in Prj.Attr.\n+\n    function Empty_Project return Project_Data;\n    --  Return the representation of an empty project\n "}, {"sha": "4a6ffbe2dbff8602407f0fa01149b15c7cec96ef", "filename": "gcc/ada/raise.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fraise.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fraise.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.h?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -65,7 +65,7 @@ extern void set_gnat_exit_status\t(int);\n extern void __gnat_set_globals\t\t(int, int,\n \t\t\t\t\t\t char, char, char, char,\n \t\t\t\t\t\t char *, char *,\n-\t\t\t\t\t\t int, int, int, int);\n+\t\t\t\t\t\t int, int, int, int, int);\n extern void __gnat_initialize\t\t(void);\n extern void __gnat_init_float\t\t(void);\n extern void __gnat_install_handler\t(void);"}, {"sha": "89ba39fc1b31417cb7f23ecab93ec7662409a92e", "filename": "gcc/ada/s-parint.adb", "status": "modified", "additions": 63, "deletions": 32, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-parint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-parint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parint.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -45,8 +45,10 @@ package body System.Partition_Interface is\n    type Pkg_Node;\n    type Pkg_List is access Pkg_Node;\n    type Pkg_Node is record\n-      Name : String_Access;\n-      Next : Pkg_List;\n+      Name          : String_Access;\n+      Subp_Info     : System.Address;\n+      Subp_Info_Len : Integer;\n+      Next          : Pkg_List;\n    end record;\n \n    Pkg_Head : Pkg_List;\n@@ -63,9 +65,9 @@ package body System.Partition_Interface is\n    --  String prepended in top of shared passive packages\n \n    procedure Check\n-     (Name    : in Unit_Name;\n-      Version : in String;\n-      RCI     : in Boolean := True)\n+     (Name    : Unit_Name;\n+      Version : String;\n+      RCI     : Boolean := True)\n    is\n    begin\n       null;\n@@ -76,8 +78,7 @@ package body System.Partition_Interface is\n    -----------------------------\n \n    function Get_Active_Partition_ID\n-     (Name : Unit_Name)\n-      return System.RPC.Partition_ID\n+     (Name : Unit_Name) return System.RPC.Partition_ID\n    is\n       P : Pkg_List := Pkg_Head;\n       N : String   := Lower (Name);\n@@ -98,10 +99,7 @@ package body System.Partition_Interface is\n    -- Get_Active_Version --\n    ------------------------\n \n-   function Get_Active_Version\n-     (Name : Unit_Name)\n-      return String\n-   is\n+   function Get_Active_Version (Name : Unit_Name) return String is\n    begin\n       return \"\";\n    end Get_Active_Version;\n@@ -120,8 +118,7 @@ package body System.Partition_Interface is\n    ------------------------------\n \n    function Get_Passive_Partition_ID\n-     (Name : Unit_Name)\n-      return System.RPC.Partition_ID\n+     (Name : Unit_Name) return System.RPC.Partition_ID\n    is\n    begin\n       return Get_Local_Partition_ID;\n@@ -131,21 +128,50 @@ package body System.Partition_Interface is\n    -- Get_Passive_Version --\n    -------------------------\n \n-   function Get_Passive_Version\n-     (Name : Unit_Name)\n-      return String\n-   is\n+   function Get_Passive_Version (Name : Unit_Name) return String is\n    begin\n       return \"\";\n    end Get_Passive_Version;\n \n+   ------------------\n+   -- Get_RAS_Info --\n+   ------------------\n+\n+   procedure Get_RAS_Info\n+     (Name          :  Unit_Name;\n+      Subp_Id       :  Subprogram_Id;\n+      Proxy_Address : out Interfaces.Unsigned_64)\n+   is\n+      LName : constant String := Lower (Name);\n+      N : Pkg_List;\n+   begin\n+      N := Pkg_Head;\n+      while N /= null loop\n+         if N.Name.all = LName then\n+            declare\n+               subtype Subprogram_Array is RCI_Subp_Info_Array\n+                 (First_RCI_Subprogram_Id ..\n+                  First_RCI_Subprogram_Id + N.Subp_Info_Len - 1);\n+               Subprograms : Subprogram_Array;\n+               for Subprograms'Address use N.Subp_Info;\n+               pragma Import (Ada, Subprograms);\n+            begin\n+               Proxy_Address :=\n+                 Interfaces.Unsigned_64 (Subprograms (Integer (Subp_Id)).Addr);\n+               return;\n+            end;\n+         end if;\n+         N := N.Next;\n+      end loop;\n+      Proxy_Address := 0;\n+   end Get_RAS_Info;\n+\n    ------------------------------\n    -- Get_RCI_Package_Receiver --\n    ------------------------------\n \n    function Get_RCI_Package_Receiver\n-     (Name : Unit_Name)\n-      return Interfaces.Unsigned_64\n+     (Name : Unit_Name) return Interfaces.Unsigned_64\n    is\n    begin\n       return 0;\n@@ -186,7 +212,7 @@ package body System.Partition_Interface is\n    -------------------------------------\n \n    procedure Raise_Program_Error_Unknown_Tag\n-     (E : in Ada.Exceptions.Exception_Occurrence)\n+     (E : Ada.Exceptions.Exception_Occurrence)\n    is\n    begin\n       Ada.Exceptions.Raise_Exception\n@@ -235,39 +261,44 @@ package body System.Partition_Interface is\n    ------------------------------\n \n    procedure Register_Passive_Package\n-     (Name    : in Unit_Name;\n-      Version : in String := \"\")\n+     (Name    : Unit_Name;\n+      Version : String := \"\")\n    is\n    begin\n-      Register_Receiving_Stub (Passive_Prefix & Name, null, Version);\n+      Register_Receiving_Stub\n+        (Passive_Prefix & Name, null, Version, System.Null_Address, 0);\n    end Register_Passive_Package;\n \n    -----------------------------\n    -- Register_Receiving_Stub --\n    -----------------------------\n \n    procedure Register_Receiving_Stub\n-     (Name     : in Unit_Name;\n-      Receiver : in RPC.RPC_Receiver;\n-      Version  : in String := \"\")\n+     (Name          : Unit_Name;\n+      Receiver      : RPC.RPC_Receiver;\n+      Version       : String := \"\";\n+      Subp_Info     : System.Address;\n+      Subp_Info_Len : Integer)\n    is\n+      N : constant Pkg_List :=\n+            new Pkg_Node'(new String'(Lower (Name)),\n+                          Subp_Info, Subp_Info_Len,\n+                          Next => null);\n    begin\n       if Pkg_Tail = null then\n-         Pkg_Head := new Pkg_Node'(new String'(Lower (Name)), null);\n-         Pkg_Tail := Pkg_Head;\n-\n+         Pkg_Head := N;\n       else\n-         Pkg_Tail.Next := new Pkg_Node'(new String'(Lower (Name)), null);\n-         Pkg_Tail := Pkg_Tail.Next;\n+         Pkg_Tail.Next := N;\n       end if;\n+      Pkg_Tail := N;\n    end Register_Receiving_Stub;\n \n    ---------\n    -- Run --\n    ---------\n \n    procedure Run\n-     (Main : in Main_Subprogram_Type := null)\n+     (Main : Main_Subprogram_Type := null)\n    is\n    begin\n       if Main /= null then"}, {"sha": "a4ac13d0789ef58894b520ee3e5bd0d40e781fa7", "filename": "gcc/ada/s-parint.ads", "status": "modified", "additions": 50, "deletions": 21, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-parint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-parint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parint.ads?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -45,8 +45,20 @@ package System.Partition_Interface is\n    type DSA_Implementation_Name is (No_DSA, GLADE_DSA, PolyORB_DSA);\n    DSA_Implementation : constant DSA_Implementation_Name := No_DSA;\n \n+   --  RCI receiving stubs contain a table of descriptors for\n+   --  all user subprograms exported by the unit.\n+\n    type Subprogram_Id is new Natural;\n-   --  This type is used exclusively by stubs\n+   First_RCI_Subprogram_Id : constant := 2;\n+\n+   type RCI_Subp_Info is record\n+      Addr : System.Address;\n+      --  Local address of the proxy object\n+   end record;\n+\n+   type RCI_Subp_Info_Access is access all RCI_Subp_Info;\n+   type RCI_Subp_Info_Array is array (Integer range <>) of\n+     aliased RCI_Subp_Info;\n \n    subtype Unit_Name is String;\n    --  Name of Ada units\n@@ -59,63 +71,80 @@ package System.Partition_Interface is\n       Addr         : Interfaces.Unsigned_64;\n       Asynchronous : Boolean;\n    end record;\n+\n    type RACW_Stub_Type_Access is access RACW_Stub_Type;\n    --  This type is used by the expansion to implement distributed objects.\n    --  Do not change its definition or its layout without updating\n    --  exp_dist.adb.\n \n+   type RAS_Proxy_Type is tagged limited record\n+      All_Calls_Remote : Boolean;\n+      Receiver         : System.Address;\n+      Subp_Id          : Subprogram_Id;\n+   end record;\n+\n+   type RAS_Proxy_Type_Access is access RAS_Proxy_Type;\n+   pragma No_Strict_Aliasing (RAS_Proxy_Type_Access);\n+   --  This type is used by the expansion to implement distributed objects.\n+   --  Do not change its definition or its layout without updating\n+   --  Exp_Dist.Build_Remote_Supbrogram_Proxy_Type.\n+\n    procedure Check\n-     (Name    : in Unit_Name;\n-      Version : in String;\n-      RCI     : in Boolean := True);\n+     (Name    : Unit_Name;\n+      Version : String;\n+      RCI     : Boolean := True);\n    --  Use by the main subprogram to check that a remote receiver\n    --  unit has has the same version than the caller's one.\n \n-   function Get_Active_Partition_ID\n-     (Name : Unit_Name)\n-      return RPC.Partition_ID;\n+   function Get_Active_Partition_ID (Name : Unit_Name) return RPC.Partition_ID;\n    --  Similar in some respects to RCI_Info.Get_Active_Partition_ID\n \n-   function Get_Active_Version\n-      (Name : Unit_Name)\n-       return String;\n+   function Get_Active_Version (Name : Unit_Name) return String;\n    --  Similar in some respects to Get_Active_Partition_ID\n \n    function Get_Local_Partition_ID return RPC.Partition_ID;\n    --  Return the Partition_ID of the current partition\n \n    function Get_Passive_Partition_ID\n-     (Name : Unit_Name)\n-     return RPC.Partition_ID;\n+     (Name : Unit_Name) return RPC.Partition_ID;\n    --  Return the Partition_ID of the given shared passive partition\n \n    function Get_Passive_Version (Name : Unit_Name) return String;\n    --  Return the version corresponding to a shared passive unit\n \n    function Get_RCI_Package_Receiver\n-     (Name : Unit_Name)\n-      return Interfaces.Unsigned_64;\n+     (Name : Unit_Name) return Interfaces.Unsigned_64;\n    --  Similar in some respects to RCI_Info.Get_RCI_Package_Receiver\n \n    procedure Get_Unique_Remote_Pointer\n      (Handler : in out RACW_Stub_Type_Access);\n    --  Get a unique pointer on a remote object\n \n    procedure Raise_Program_Error_Unknown_Tag\n-     (E : in Ada.Exceptions.Exception_Occurrence);\n+     (E : Ada.Exceptions.Exception_Occurrence);\n    pragma No_Return (Raise_Program_Error_Unknown_Tag);\n    --  Raise Program_Error with the same message as E one\n \n    procedure Register_Receiving_Stub\n-     (Name     : in Unit_Name;\n-      Receiver : in RPC.RPC_Receiver;\n-      Version  : in String := \"\");\n+     (Name          : Unit_Name;\n+      Receiver      : RPC.RPC_Receiver;\n+      Version       : String := \"\";\n+      Subp_Info     : System.Address;\n+      Subp_Info_Len : Integer);\n    --  Register the fact that the Name receiving stub is now elaborated.\n    --  Register the access value to the package RPC_Receiver procedure.\n \n+   procedure Get_RAS_Info\n+     (Name          :  Unit_Name;\n+      Subp_Id       :  Subprogram_Id;\n+      Proxy_Address : out Interfaces.Unsigned_64);\n+   --  Look up the address of the proxy object for the given subprogram\n+   --  in the named unit, or Null_Address if not present on the local\n+   --  partition.\n+\n    procedure Register_Passive_Package\n-     (Name    : in Unit_Name;\n-      Version : in String := \"\");\n+     (Name    : Unit_Name;\n+      Version : String := \"\");\n    --  Register a passive package\n \n    generic\n@@ -126,7 +155,7 @@ package System.Partition_Interface is\n    end RCI_Info;\n    --  RCI package information caching\n \n-   procedure Run (Main : in Main_Subprogram_Type := null);\n+   procedure Run (Main : Main_Subprogram_Type := null);\n    --  Run the main subprogram\n \n end System.Partition_Interface;"}, {"sha": "6fd13da6cf834ab363ab4120758d023fef25d937", "filename": "gcc/ada/s-solita.adb", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-solita.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-solita.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-solita.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -44,6 +44,12 @@ with System.Task_Primitives.Operations;\n --  Used for Self\n --           Timed_Delay\n \n+with System.Tasking;\n+--  Used for Task_Id\n+\n+with Ada.Exceptions;\n+--  Used for Raise_Exception\n+\n package body System.Soft_Links.Tasking is\n \n    package STPO renames System.Task_Primitives.Operations;\n@@ -79,9 +85,9 @@ package body System.Soft_Links.Tasking is\n    procedure Timed_Delay_T (Time : Duration; Mode : Integer);\n    --  Task-safe version of SSL.Timed_Delay\n \n-   ----------------------\n-   -- Soft-Link Bodies --\n-   ----------------------\n+   --------------------------\n+   -- Soft-Link Get Bodies --\n+   --------------------------\n \n    function Get_Current_Excep return SSL.EOA is\n    begin\n@@ -103,6 +109,10 @@ package body System.Soft_Links.Tasking is\n       return STPO.Self.Common.Compiler_Data.Sec_Stack_Addr;\n    end Get_Sec_Stack_Addr;\n \n+   --------------------------\n+   -- Soft-Link Set Bodies --\n+   --------------------------\n+\n    procedure Set_Jmpbuf_Address (Addr : Address) is\n    begin\n       STPO.Self.Common.Compiler_Data.Jmpbuf_Address := Addr;\n@@ -118,9 +128,27 @@ package body System.Soft_Links.Tasking is\n       STPO.Self.Common.Compiler_Data.Sec_Stack_Addr := Addr;\n    end Set_Sec_Stack_Addr;\n \n+   -------------------\n+   -- Timed_Delay_T --\n+   -------------------\n+\n    procedure Timed_Delay_T (Time : Duration; Mode : Integer) is\n+      Self_Id : constant System.Tasking.Task_Id := STPO.Self;\n+\n    begin\n-      STPO.Timed_Delay (STPO.Self, Time, Mode);\n+      --  In case pragma Detect_Blocking is active then Program_Error\n+      --  must be raised if this potentially blocking operation\n+      --  is called from a protected operation.\n+\n+      if System.Tasking.Detect_Blocking\n+        and then Self_Id.Common.Protected_Action_Nesting > 0\n+      then\n+         Ada.Exceptions.Raise_Exception\n+           (Program_Error'Identity, \"potentially blocking operation\");\n+      else\n+         STPO.Timed_Delay (Self_Id, Time, Mode);\n+      end if;\n+\n    end Timed_Delay_T;\n \n    -----------------------------"}, {"sha": "9852c4e376c1db9b511df80c05b221b2d32bc086", "filename": "gcc/ada/s-taprob.adb", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-taprob.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-taprob.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprob.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -39,6 +39,7 @@ pragma Polling (Off);\n with System.Task_Primitives.Operations;\n --  used for Write_Lock\n --           Unlock\n+--           Self\n \n with System.Parameters;\n --  used for Runtime_Traces\n@@ -87,6 +88,7 @@ package body System.Tasking.Protected_Objects is\n \n    procedure Lock (Object : Protection_Access) is\n       Ceiling_Violation : Boolean;\n+\n    begin\n       --  The lock is made without defering abortion.\n \n@@ -107,6 +109,19 @@ package body System.Tasking.Protected_Objects is\n       if Ceiling_Violation then\n          raise Program_Error;\n       end if;\n+\n+      --  We are entering in a protected action, so that we increase the\n+      --  protected object nesting level (if pragma Detect_Blocking is\n+      --  active).\n+\n+      if Detect_Blocking then\n+         declare\n+            Self_Id : constant Task_Id := Self;\n+         begin\n+            Self_Id.Common.Protected_Action_Nesting :=\n+              Self_Id.Common.Protected_Action_Nesting + 1;\n+         end;\n+      end if;\n    end Lock;\n \n    --------------------\n@@ -115,6 +130,7 @@ package body System.Tasking.Protected_Objects is\n \n    procedure Lock_Read_Only (Object : Protection_Access) is\n       Ceiling_Violation : Boolean;\n+\n    begin\n       Read_Lock (Object.L'Access, Ceiling_Violation);\n \n@@ -125,6 +141,19 @@ package body System.Tasking.Protected_Objects is\n       if Ceiling_Violation then\n          raise Program_Error;\n       end if;\n+\n+      --  We are entering in a protected action, so that we increase the\n+      --  protected object nesting level (if pragma Detect_Blocking is\n+      --  active).\n+\n+      if Detect_Blocking then\n+         declare\n+            Self_Id : constant Task_Id := Self;\n+         begin\n+            Self_Id.Common.Protected_Action_Nesting :=\n+              Self_Id.Common.Protected_Action_Nesting + 1;\n+         end;\n+      end if;\n    end Lock_Read_Only;\n \n    ------------\n@@ -133,6 +162,25 @@ package body System.Tasking.Protected_Objects is\n \n    procedure Unlock (Object : Protection_Access) is\n    begin\n+      --  We are exiting from a protected action, so that we decrease the\n+      --  protected object nesting level (if pragma Detect_Blocking is\n+      --  active).\n+\n+      if Detect_Blocking then\n+         declare\n+            Self_Id : constant Task_Id := Self;\n+\n+         begin\n+            --  Cannot call this procedure without being within a protected\n+            --  action.\n+\n+            pragma Assert (Self_Id.Common.Protected_Action_Nesting > 0);\n+\n+            Self_Id.Common.Protected_Action_Nesting :=\n+              Self_Id.Common.Protected_Action_Nesting - 1;\n+         end;\n+      end if;\n+\n       Unlock (Object.L'Access);\n \n       if Parameters.Runtime_Traces then"}, {"sha": "f667a313bf32587bbc7163e8b28200f3f655a5bd", "filename": "gcc/ada/s-taskin.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-taskin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-taskin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -83,6 +83,7 @@ package body System.Tasking is\n       T.Common.Parent := Parent;\n       T.Common.Base_Priority := Base_Priority;\n       T.Common.Current_Priority := 0;\n+      T.Common.Protected_Action_Nesting := 0;\n       T.Common.Call := null;\n       T.Common.Task_Arg := Task_Arg;\n       T.Common.Task_Entry_Point := Task_Entry_Point;"}, {"sha": "1dd9e27d730bec5d505caa8af90c169814d7e4f4", "filename": "gcc/ada/s-taskin.ads", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-taskin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-taskin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.ads?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -335,13 +335,18 @@ package System.Tasking is\n    ------------------------------------\n \n    type Activation_Chain is limited private;\n+   --  Comment required ???\n \n    type Activation_Chain_Access is access all Activation_Chain;\n+   --  Comment required ???\n \n    type Task_Procedure_Access is access procedure (Arg : System.Address);\n \n    type Access_Boolean is access all Boolean;\n \n+   Detect_Blocking : constant Boolean;\n+   --  Boolean constant set True iff Detect_Blocking is active\n+\n    ----------------------------------------------\n    -- Ada_Task_Control_Block (ATCB) definition --\n    ----------------------------------------------\n@@ -421,6 +426,14 @@ package System.Tasking is\n       --  accepts an entry or when Created activates, at which points Self is\n       --  suspended.\n \n+      Protected_Action_Nesting : Natural;\n+      pragma Atomic (Protected_Action_Nesting);\n+      --  The dynamic level of protected action nesting for this task.\n+      --  This field is needed for checking whether potentially\n+      --  blocking operations are invoked from protected actions.\n+      --  pragma Atomic is used because it can be read/written from\n+      --  protected interrupt handlers.\n+\n       Task_Image : String (1 .. 32);\n       --  Hold a string that provides a readable id for task,\n       --  built from the variable of which it is a value or component.\n@@ -969,6 +982,14 @@ package System.Tasking is\n private\n    Null_Task : constant Task_Id := null;\n \n+   GL_Detect_Blocking : Integer;\n+   pragma Import (C, GL_Detect_Blocking, \"__gl_detect_blocking\");\n+   --  Global variable exported by the binder generated file. A value\n+   --  equal to 1 indicates that pragma Detect_Blocking is active,\n+   --  while 0 is used for the pragma not being present.\n+\n+   Detect_Blocking : constant Boolean := GL_Detect_Blocking = 1;\n+\n    type Activation_Chain is record\n       T_ID : Task_Id;\n    end record;"}, {"sha": "5763272ce247f05f6a196b30c0157d6edf74aae9", "filename": "gcc/ada/s-tasren.adb", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-tasren.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-tasren.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasren.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -102,6 +102,10 @@ package body System.Tasking.Rendezvous is\n      Accept_Alternative_Open,\n      No_Alternative_Open);\n \n+   ----------------\n+   -- Local Data --\n+   ----------------\n+\n    Default_Treatment : constant array (Select_Modes) of Select_Treatment :=\n      (Simple_Mode         => No_Alternative_Open,\n       Else_Mode           => Else_Selected,\n@@ -391,7 +395,19 @@ package body System.Tasking.Rendezvous is\n       Uninterpreted_Data : System.Address)\n    is\n       Rendezvous_Successful : Boolean;\n+\n    begin\n+      --  If pragma Detect_Blocking is active then Program_Error must be\n+      --  raised if this potentially blocking operation is called from a\n+      --  protected action.\n+\n+      if System.Tasking.Detect_Blocking\n+        and then STPO.Self.Common.Protected_Action_Nesting > 0\n+      then\n+         Ada.Exceptions.Raise_Exception\n+           (Program_Error'Identity, \"potentially blocking operation\");\n+      end if;\n+\n       Call_Synchronous\n         (Acceptor, E, Uninterpreted_Data, Simple_Call, Rendezvous_Successful);\n    end Call_Simple;\n@@ -1309,6 +1325,17 @@ package body System.Tasking.Rendezvous is\n       Entry_Call : Entry_Call_Link;\n \n    begin\n+      --  If pragma Detect_Blocking is active then Program_Error must be\n+      --  raised if this potentially blocking operation is called from a\n+      --  protected action.\n+\n+      if System.Tasking.Detect_Blocking\n+        and then Self_Id.Common.Protected_Action_Nesting > 0\n+      then\n+         Ada.Exceptions.Raise_Exception\n+           (Program_Error'Identity, \"potentially blocking operation\");\n+      end if;\n+\n       if Parameters.Runtime_Traces then\n          Send_Trace_Info (W_Call, Acceptor, Entry_Index (E));\n       end if;\n@@ -1668,6 +1695,17 @@ package body System.Tasking.Rendezvous is\n       Yielded    : Boolean;\n \n    begin\n+      --  If pragma Detect_Blocking is active then Program_Error must be\n+      --  raised if this potentially blocking operation is called from a\n+      --  protected action.\n+\n+      if System.Tasking.Detect_Blocking\n+        and then Self_Id.Common.Protected_Action_Nesting > 0\n+      then\n+         Ada.Exceptions.Raise_Exception\n+           (Program_Error'Identity, \"potentially blocking operation\");\n+      end if;\n+\n       Initialization.Defer_Abort (Self_Id);\n       Self_Id.ATC_Nesting_Level := Self_Id.ATC_Nesting_Level + 1;\n "}, {"sha": "535add5afbd2b7d2c9b89d61e330a4e8105ef9b9", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -226,6 +226,17 @@ package body System.Tasking.Stages is\n \n    procedure Abort_Tasks (Tasks : Task_List) is\n    begin\n+      --  If pragma Detect_Blocking is active then Program_Error must be\n+      --  raised if this potentially blocking operation is called from a\n+      --  protected action.\n+\n+      if System.Tasking.Detect_Blocking\n+        and then STPO.Self.Common.Protected_Action_Nesting > 0\n+      then\n+         Ada.Exceptions.Raise_Exception\n+           (Program_Error'Identity, \"potentially blocking operation\");\n+      end if;\n+\n       Utilities.Abort_Tasks (Tasks);\n    end Abort_Tasks;\n \n@@ -266,6 +277,17 @@ package body System.Tasking.Stages is\n       All_Elaborated : Boolean := True;\n \n    begin\n+      --  If pragma Detect_Blocking is active must be checked whether\n+      --  this potentially blocking operation is called from a\n+      --  protected action.\n+\n+      if System.Tasking.Detect_Blocking\n+        and then Self_ID.Common.Protected_Action_Nesting > 0\n+      then\n+         Ada.Exceptions.Raise_Exception\n+           (Program_Error'Identity, \"potentially blocking operation\");\n+      end if;\n+\n       pragma Debug\n         (Debug.Trace (Self_ID, \"Activate_Tasks\", 'C'));\n \n@@ -513,6 +535,17 @@ package body System.Tasking.Stages is\n       Len           : Natural;\n \n    begin\n+      --  If pragma Detect_Blocking is active must be checked whether\n+      --  this potentially blocking operation is called from a\n+      --  protected action.\n+\n+      if System.Tasking.Detect_Blocking\n+        and then Self_ID.Common.Protected_Action_Nesting > 0\n+      then\n+         Ada.Exceptions.Raise_Exception\n+           (Program_Error'Identity, \"potentially blocking operation\");\n+      end if;\n+\n       pragma Debug\n         (Debug.Trace (Self_ID, \"Create_Task\", 'C'));\n "}, {"sha": "c1d7d3ccae4b72fcafd7317e449571e40cff326b", "filename": "gcc/ada/s-tpoben.adb", "status": "modified", "additions": 72, "deletions": 8, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-tpoben.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-tpoben.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpoben.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -44,6 +44,7 @@\n \n with Ada.Exceptions;\n --  used for Exception_Occurrence_Access\n+--           Raise_Exception\n \n with System.Task_Primitives.Operations;\n --  used for Initialize_Lock\n@@ -72,6 +73,10 @@ package body System.Tasking.Protected_Objects.Entries is\n    use Task_Primitives.Operations;\n    use Ada.Exceptions;\n \n+   ----------------\n+   -- Local Data --\n+   ----------------\n+\n    Locking_Policy : Character;\n    pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n \n@@ -216,13 +221,36 @@ package body System.Tasking.Protected_Objects.Entries is\n    ------------------\n \n    procedure Lock_Entries\n-     (Object : Protection_Entries_Access; Ceiling_Violation : out Boolean) is\n+     (Object : Protection_Entries_Access; Ceiling_Violation : out Boolean)\n+   is\n    begin\n       if Object.Finalized then\n          Raise_Exception\n            (Program_Error'Identity, \"Protected Object is finalized\");\n       end if;\n \n+      --  If pragma Detect_Blocking is active then Program_Error must\n+      --  be raised if this potentially blocking operation is called from\n+      --  a protected action, and the protected object nesting level\n+      --  must be increased.\n+\n+      if Detect_Blocking then\n+         declare\n+            Self_Id : constant Task_Id := STPO.Self;\n+         begin\n+            if Self_Id.Common.Protected_Action_Nesting > 0  then\n+               Ada.Exceptions.Raise_Exception\n+                 (Program_Error'Identity, \"potentially blocking operation\");\n+            else\n+               --  We are entering in a protected action, so that we\n+               --  increase the protected object nesting level.\n+\n+               Self_Id.Common.Protected_Action_Nesting :=\n+                 Self_Id.Common.Protected_Action_Nesting + 1;\n+            end if;\n+         end;\n+      end if;\n+\n       --  The lock is made without defering abortion.\n \n       --  Therefore the abortion has to be deferred before calling this\n@@ -239,14 +267,9 @@ package body System.Tasking.Protected_Objects.Entries is\n \n    procedure Lock_Entries (Object : Protection_Entries_Access) is\n       Ceiling_Violation : Boolean;\n-   begin\n-      if Object.Finalized then\n-         Raise_Exception\n-           (Program_Error'Identity, \"Protected Object is finalized\");\n-      end if;\n \n-      pragma Assert (STPO.Self.Deferral_Level > 0);\n-      Write_Lock (Object.L'Access, Ceiling_Violation);\n+   begin\n+      Lock_Entries (Object, Ceiling_Violation);\n \n       if Ceiling_Violation then\n          Raise_Exception (Program_Error'Identity, \"Ceiling Violation\");\n@@ -259,12 +282,35 @@ package body System.Tasking.Protected_Objects.Entries is\n \n    procedure Lock_Read_Only_Entries (Object : Protection_Entries_Access) is\n       Ceiling_Violation : Boolean;\n+\n    begin\n       if Object.Finalized then\n          Raise_Exception\n            (Program_Error'Identity, \"Protected Object is finalized\");\n       end if;\n \n+      --  If pragma Detect_Blocking is active then Program_Error must be\n+      --  raised if this potentially blocking operation is called from a\n+      --  protected action, and the protected object nesting level must\n+      --  be increased.\n+\n+      if Detect_Blocking then\n+         declare\n+            Self_Id : constant Task_Id := STPO.Self;\n+         begin\n+            if Self_Id.Common.Protected_Action_Nesting > 0  then\n+               Ada.Exceptions.Raise_Exception\n+                 (Program_Error'Identity, \"potentially blocking operation\");\n+            else\n+               --  We are entering in a protected action, so that we\n+               --  increase the protected object nesting level.\n+\n+               Self_Id.Common.Protected_Action_Nesting :=\n+                 Self_Id.Common.Protected_Action_Nesting + 1;\n+            end if;\n+         end;\n+      end if;\n+\n       Read_Lock (Object.L'Access, Ceiling_Violation);\n \n       if Ceiling_Violation then\n@@ -278,6 +324,24 @@ package body System.Tasking.Protected_Objects.Entries is\n \n    procedure Unlock_Entries (Object : Protection_Entries_Access) is\n    begin\n+      --  We are exiting from a protected action, so that we decrease the\n+      --  protected object nesting level (if pragma Detect_Blocking is\n+      --  active).\n+\n+      if Detect_Blocking then\n+         declare\n+            Self_Id : constant Task_Id := Self;\n+         begin\n+            --  Cannot call this procedure without being within a protected\n+            --  action.\n+\n+            pragma Assert (Self_Id.Common.Protected_Action_Nesting > 0);\n+\n+            Self_Id.Common.Protected_Action_Nesting :=\n+              Self_Id.Common.Protected_Action_Nesting - 1;\n+         end;\n+      end if;\n+\n       Unlock (Object.L'Access);\n    end Unlock_Entries;\n "}, {"sha": "a992ed1df0f018eb265121673ffaf3d096c310df", "filename": "gcc/ada/s-tposen.adb", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-tposen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fs-tposen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tposen.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -67,7 +67,8 @@ with System.Task_Primitives.Operations;\n --           Unlock\n \n with Ada.Exceptions;\n---  used for Exception_Id;\n+--  used for Exception_Id\n+--           Raise_Exception\n \n with System.Parameters;\n --  used for Single_Lock\n@@ -347,7 +348,30 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n \n    procedure Lock_Entry (Object : Protection_Entry_Access) is\n       Ceiling_Violation : Boolean;\n+\n    begin\n+      --  If pragma Detect_Blocking is active then Program_Error must\n+      --  be raised if this potentially blocking operation is called from\n+      --  a protected action, and the protected object nesting level\n+      --  must be increased.\n+\n+      if Detect_Blocking then\n+         declare\n+            Self_Id : constant Task_Id := STPO.Self;\n+         begin\n+            if Self_Id.Common.Protected_Action_Nesting > 0  then\n+               Ada.Exceptions.Raise_Exception\n+                 (Program_Error'Identity, \"potentially blocking operation\");\n+            else\n+               --  We are entering in a protected action, so that we\n+               --  increase the protected object nesting level.\n+\n+               Self_Id.Common.Protected_Action_Nesting :=\n+                 Self_Id.Common.Protected_Action_Nesting + 1;\n+            end if;\n+         end;\n+      end if;\n+\n       STPO.Write_Lock (Object.L'Access, Ceiling_Violation);\n \n       if Ceiling_Violation then\n@@ -364,7 +388,30 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n \n    procedure Lock_Read_Only_Entry (Object : Protection_Entry_Access) is\n       Ceiling_Violation : Boolean;\n+\n    begin\n+      --  If pragma Detect_Blocking is active then Program_Error must be\n+      --  raised if this potentially blocking operation is called from a\n+      --  protected action, and the protected object nesting level must\n+      --  be increased.\n+\n+      if Detect_Blocking then\n+         declare\n+            Self_Id : constant Task_Id := STPO.Self;\n+         begin\n+            if Self_Id.Common.Protected_Action_Nesting > 0  then\n+               Ada.Exceptions.Raise_Exception\n+                 (Program_Error'Identity, \"potentially blocking operation\");\n+            else\n+               --  We are entering in a protected action, so that we\n+               --  increase the protected object nesting level.\n+\n+               Self_Id.Common.Protected_Action_Nesting :=\n+                 Self_Id.Common.Protected_Action_Nesting + 1;\n+            end if;\n+         end;\n+      end if;\n+\n       STPO.Read_Lock (Object.L'Access, Ceiling_Violation);\n \n       if Ceiling_Violation then\n@@ -465,6 +512,17 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n       Ceiling_Violation : Boolean;\n \n    begin\n+      --  If pragma Detect_Blocking is active then Program_Error must be\n+      --  raised if this potentially blocking operation is called from a\n+      --  protected action.\n+\n+      if Detect_Blocking\n+        and then Self_Id.Common.Protected_Action_Nesting > 0\n+      then\n+         Ada.Exceptions.Raise_Exception\n+           (Program_Error'Identity, \"potentially blocking operation\");\n+      end if;\n+\n       STPO.Write_Lock (Object.L'Access, Ceiling_Violation);\n \n       if Ceiling_Violation then\n@@ -579,6 +637,17 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n       Ceiling_Violation : Boolean;\n \n    begin\n+      --  If pragma Detect_Blocking is active then Program_Error must be\n+      --  raised if this potentially blocking operation is called from a\n+      --  protected action.\n+\n+      if Detect_Blocking\n+        and then Self_Id.Common.Protected_Action_Nesting > 0\n+      then\n+         Ada.Exceptions.Raise_Exception\n+           (Program_Error'Identity, \"potentially blocking operation\");\n+      end if;\n+\n       STPO.Write_Lock (Object.L'Access, Ceiling_Violation);\n \n       if Ceiling_Violation then\n@@ -631,6 +700,23 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n \n    procedure Unlock_Entry (Object : Protection_Entry_Access) is\n    begin\n+      --  We are exiting from a protected action, so that we decrease the\n+      --  protected object nesting level (if pragma Detect_Blocking is active).\n+\n+      if Detect_Blocking then\n+         declare\n+            Self_Id : constant Task_Id := Self;\n+\n+         begin\n+            --  Cannot call Unlock_Entry without being within protected action\n+\n+            pragma Assert (Self_Id.Common.Protected_Action_Nesting > 0);\n+\n+            Self_Id.Common.Protected_Action_Nesting :=\n+              Self_Id.Common.Protected_Action_Nesting - 1;\n+         end;\n+      end if;\n+\n       STPO.Unlock (Object.L'Access);\n    end Unlock_Entry;\n "}, {"sha": "7f78060490b1b936c8cc8f73d3457b5a5a223c88", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -5594,12 +5594,13 @@ package body Sem_Ch3 is\n       elsif Private_Extension and then Is_Generic_Type (Derived_Type) then\n          Record_Type_Definition (Empty, Derived_Type);\n \n-      --  STEP 5c: Process the record extension for non private tagged types.\n+      --  STEP 5c: Process the record extension for non private tagged types\n \n       elsif not Private_Extension then\n-         --  Add the _parent field in the derived type.\n \n-         Expand_Derived_Record (Derived_Type, Type_Def);\n+         --  Add the _parent field in the derived type\n+\n+         Expand_Record_Extension (Derived_Type, Type_Def);\n \n          --  Analyze the record extension\n "}, {"sha": "7ea68f856993138f80a3c4ce8a2111d96be4f95f", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -150,7 +150,8 @@ package body Sem_Disp is\n            and then Ekind (Etype (Formal)) = E_Anonymous_Access_Type\n          then\n             Error_Msg_N\n-              (\"Access parameter of a remote subprogram must be controlling\",\n+              (\"access parameter of remote object primitive\"\n+               & \" must be controlling\",\n                 Formal);\n          end if;\n "}, {"sha": "8314e6ca32f40a15e8c656a2757b6de4db74c5f5", "filename": "gcc/ada/sem_dist.adb", "status": "modified", "additions": 210, "deletions": 84, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fsem_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fsem_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dist.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -105,6 +105,55 @@ package body Sem_Dist is\n       end if;\n    end Add_Stub_Constructs;\n \n+   ---------------------------------------\n+   -- Build_RAS_Primitive_Specification --\n+   ---------------------------------------\n+\n+   function Build_RAS_Primitive_Specification\n+     (Subp_Spec          : Node_Id;\n+      Remote_Object_Type : Node_Id) return Node_Id\n+   is\n+      Loc : constant Source_Ptr := Sloc (Subp_Spec);\n+\n+      Primitive_Spec : constant Node_Id :=\n+                         Copy_Specification (Loc,\n+                           Spec     => Subp_Spec,\n+                           New_Name => Name_Call);\n+\n+      Subtype_Mark_For_Self : Node_Id;\n+\n+   begin\n+      if No (Parameter_Specifications (Primitive_Spec)) then\n+         Set_Parameter_Specifications (Primitive_Spec, New_List);\n+      end if;\n+\n+      if Nkind (Remote_Object_Type) in N_Entity then\n+         Subtype_Mark_For_Self :=\n+           New_Occurrence_Of (Remote_Object_Type, Loc);\n+      else\n+         Subtype_Mark_For_Self := Remote_Object_Type;\n+      end if;\n+\n+      Prepend_To (\n+        Parameter_Specifications (Primitive_Spec),\n+        Make_Parameter_Specification (Loc,\n+          Defining_Identifier =>\n+            Make_Defining_Identifier (Loc, Name_uS),\n+          Parameter_Type      =>\n+            Make_Access_Definition (Loc,\n+              Subtype_Mark =>\n+                Subtype_Mark_For_Self)));\n+\n+      --  Trick later semantic analysis into considering this\n+      --  operation as a primitive (dispatching) operation of\n+      --  tagged type Obj_Type.\n+\n+      Set_Comes_From_Source (\n+        Defining_Unit_Name (Primitive_Spec), True);\n+\n+      return Primitive_Spec;\n+   end Build_RAS_Primitive_Specification;\n+\n    -------------------------\n    -- Full_Qualified_Name --\n    -------------------------\n@@ -295,7 +344,6 @@ package body Sem_Dist is\n       Async_E               : Entity_Id;\n       All_Calls_Remote_E    : Entity_Id;\n       Attribute_Subp        : Entity_Id;\n-      Local_Addr            : Node_Id;\n \n    begin\n       --  Check if we have to expand the access attribute\n@@ -329,17 +377,11 @@ package body Sem_Dist is\n       All_Calls_Remote_E :=\n         Boolean_Literals (Has_All_Calls_Remote (RS_Pkg_E));\n \n-      Local_Addr :=\n-        Make_Attribute_Reference (Loc,\n-          Prefix         => New_Occurrence_Of (Remote_Subp, Loc),\n-          Attribute_Name => Name_Address);\n-\n       Tick_Access_Conv_Call :=\n         Make_Function_Call (Loc,\n           Name => New_Occurrence_Of (Attribute_Subp, Loc),\n           Parameter_Associations =>\n             New_List (\n-              Local_Addr,\n               Make_String_Literal (Loc, Full_Qualified_Name (RS_Pkg_E)),\n               Build_Subprogram_Id (Loc, Remote_Subp),\n               New_Occurrence_Of (Async_E, Loc),\n@@ -354,78 +396,165 @@ package body Sem_Dist is\n    ------------------------------------\n \n    procedure Process_Remote_AST_Declaration (N : Node_Id) is\n-      Loc           : constant Source_Ptr := Sloc (N);\n-      User_Type     : constant Node_Id := Defining_Identifier (N);\n-      Fat_Type      : constant Entity_Id :=\n+      Loc            : constant Source_Ptr := Sloc (N);\n+      User_Type      : constant Node_Id := Defining_Identifier (N);\n+      Scop           : constant Entity_Id := Scope (User_Type);\n+      Is_RCI         : constant Boolean :=\n+        Is_Remote_Call_Interface (Scop);\n+      Is_RT          : constant Boolean :=\n+        Is_Remote_Types (Scop);\n+      Type_Def       : constant Node_Id := Type_Definition (N);\n+\n+      Parameter      : Node_Id;\n+      Is_Degenerate  : Boolean;\n+      --  True iff this RAS has an access formal parameter (see\n+      --  Exp_Dist.Add_RAS_Dereference_TSS for details).\n+\n+      Subpkg         : constant Entity_Id :=\n+                         Make_Defining_Identifier\n+                           (Loc, New_Internal_Name ('S'));\n+      Subpkg_Decl    : Node_Id;\n+      Vis_Decls      : constant List_Id := New_List;\n+      Priv_Decls     : constant List_Id := New_List;\n+\n+      Obj_Type       : constant Entity_Id :=\n+                         Make_Defining_Identifier\n+                           (Loc, New_External_Name (\n+                                   Chars (User_Type), 'R'));\n+\n+\n+      Full_Obj_Type  : constant Entity_Id :=\n+                         Make_Defining_Identifier\n+                           (Loc, Chars (Obj_Type));\n+\n+      RACW_Type      : constant Entity_Id :=\n+                         Make_Defining_Identifier\n+                           (Loc, New_External_Name (\n+                                   Chars (User_Type), 'P'));\n+\n+      Fat_Type       : constant Entity_Id :=\n                         Make_Defining_Identifier\n                           (Loc, Chars (User_Type));\n-      New_Type_Decl : Node_Id;\n+      Fat_Type_Decl  : Node_Id;\n \n    begin\n-      --  We add a record type declaration for the equivalent fat pointer type\n \n-      New_Type_Decl :=\n+      --  The tagged private type, primitive operation and RACW\n+      --  type associated with a RAS need to all be declared in\n+      --  a subpackage of the one that contains the RAS declaration,\n+      --  because the primitive of the object type, and the associated\n+      --  primitive of the stub type, need to be dispatching operations\n+      --  of these types, and the profile of the RAS might contain\n+      --  tagged types declared in the same scope.\n+\n+      Append_To (Vis_Decls,\n+        Make_Private_Type_Declaration (Loc,\n+          Defining_Identifier => Obj_Type,\n+          Abstract_Present => True,\n+          Tagged_Present   => True,\n+          Limited_Present  => True));\n+\n+      Append_To (Priv_Decls,\n         Make_Full_Type_Declaration (Loc,\n-          Defining_Identifier => Fat_Type,\n-          Type_Definition =>\n+          Defining_Identifier =>\n+            Full_Obj_Type,\n+          Type_Definition     =>\n             Make_Record_Definition (Loc,\n-              Component_List =>\n-                Make_Component_List (Loc,\n-                  Component_Items => New_List (\n-\n-                    Make_Component_Declaration (Loc,\n-                      Defining_Identifier =>\n-                        Make_Defining_Identifier (Loc,\n-                          Chars => Name_Ras),\n-                      Component_Definition =>\n-                        Make_Component_Definition (Loc,\n-                          Aliased_Present    => False,\n-                          Subtype_Indication =>\n-                            New_Occurrence_Of (RTE (RE_Unsigned_64), Loc))),\n-\n-                    Make_Component_Declaration (Loc,\n-                      Defining_Identifier =>\n-                        Make_Defining_Identifier (Loc,\n-                          Chars => Name_Origin),\n-                      Component_Definition =>\n-                        Make_Component_Definition (Loc,\n-                          Aliased_Present    => False,\n-                          Subtype_Indication =>\n-                            New_Reference_To (Standard_Integer, Loc))),\n-\n-                    Make_Component_Declaration (Loc,\n-                      Defining_Identifier =>\n-                        Make_Defining_Identifier (Loc,\n-                          Chars => Name_Receiver),\n-                      Component_Definition =>\n-                        Make_Component_Definition (Loc,\n-                          Aliased_Present    => False,\n-                          Subtype_Indication =>\n-                            New_Reference_To (RTE (RE_Unsigned_64), Loc))),\n-\n-                    Make_Component_Declaration (Loc,\n-                      Defining_Identifier =>\n-                        Make_Defining_Identifier (Loc,\n-                          Chars => Name_Subp_Id),\n-                      Component_Definition =>\n-                        Make_Component_Definition (Loc,\n-                          Aliased_Present    => False,\n-                          Subtype_Indication =>\n-                            New_Reference_To (Standard_Natural, Loc))),\n-\n-                    Make_Component_Declaration (Loc,\n-                      Defining_Identifier =>\n-                        Make_Defining_Identifier (Loc,\n-                          Chars => Name_Async),\n-                      Component_Definition =>\n-                        Make_Component_Definition (Loc,\n-                          Aliased_Present    => False,\n-                          Subtype_Indication =>\n-                            New_Reference_To (Standard_Boolean, Loc)))))));\n-\n-      Insert_After (N, New_Type_Decl);\n+              Abstract_Present => True,\n+              Tagged_Present   => True,\n+              Limited_Present  => True,\n+              Null_Present     => True,\n+              Component_List   => Empty)));\n+\n+      Is_Degenerate := False;\n+      Parameter := First (Parameter_Specifications (Type_Def));\n+      Parameters : while Present (Parameter) loop\n+         if Nkind (Parameter_Type (Parameter)) = N_Access_Definition then\n+            Error_Msg_N (\"formal parameter& has anonymous access type?\",\n+              Defining_Identifier (Parameter));\n+            Is_Degenerate := True;\n+            exit Parameters;\n+         end if;\n+         Next (Parameter);\n+      end loop Parameters;\n+\n+      if Is_Degenerate then\n+         Error_Msg_NE (\n+           \"remote access-to-subprogram type& can only be null?\",\n+           Defining_Identifier (Parameter), User_Type);\n+         --  The only legal value for a RAS with a formal parameter of an\n+         --  anonymous access type is null, because it cannot be\n+         --  subtype-Conformant with any legal remote subprogram declaration.\n+         --  In this case, we cannot generate a corresponding primitive\n+         --  operation.\n+\n+      else\n+         Append_To (Vis_Decls,\n+           Make_Abstract_Subprogram_Declaration (Loc,\n+             Specification => Build_RAS_Primitive_Specification (\n+               Subp_Spec          => Type_Def,\n+               Remote_Object_Type => Obj_Type)));\n+      end if;\n+\n+      Append_To (Vis_Decls,\n+        Make_Full_Type_Declaration (Loc,\n+          Defining_Identifier => RACW_Type,\n+          Type_Definition     =>\n+            Make_Access_To_Object_Definition (Loc,\n+              All_Present => True,\n+              Subtype_Indication =>\n+                Make_Attribute_Reference (Loc,\n+                  Prefix =>\n+                    New_Occurrence_Of (Obj_Type, Loc),\n+                  Attribute_Name =>\n+                    Name_Class))));\n+      Set_Is_Remote_Call_Interface (RACW_Type, Is_RCI);\n+      Set_Is_Remote_Types (RACW_Type, Is_RT);\n+      --  ??? Object RPC receiver generation should be bypassed for this\n+      --  RACW type, since actually calls will be received by the package\n+      --  RPC receiver for the designated RCI subprogram.\n+\n+      Subpkg_Decl :=\n+        Make_Package_Declaration (Loc,\n+          Make_Package_Specification (Loc,\n+            Defining_Unit_Name =>\n+              Subpkg,\n+            Visible_Declarations =>\n+              Vis_Decls,\n+            Private_Declarations =>\n+              Priv_Decls,\n+            End_Label =>\n+              New_Occurrence_Of (Subpkg, Loc)));\n+      Set_Is_Remote_Call_Interface (Subpkg, Is_RCI);\n+      Set_Is_Remote_Types (Subpkg, Is_RT);\n+      Insert_After_And_Analyze (N, Subpkg_Decl);\n+\n+      --  Many parts of the analyzer and expander expect\n+      --  that the fat pointer type used to implement remote\n+      --  access to subprogram types be a record.\n+      --  Note: The structure of this type must be kept consistent\n+      --  with the code generated by Remote_AST_Null_Value for the\n+      --  corresponding 'null' expression.\n+\n+      Fat_Type_Decl := Make_Full_Type_Declaration (Loc,\n+        Defining_Identifier => Fat_Type,\n+        Type_Definition     =>\n+          Make_Record_Definition (Loc,\n+            Component_List =>\n+              Make_Component_List (Loc,\n+                Component_Items => New_List (\n+                  Make_Component_Declaration (Loc,\n+                    Defining_Identifier =>\n+                      Make_Defining_Identifier (Loc, Name_Ras),\n+                    Component_Definition =>\n+                      Make_Component_Definition (Loc,\n+                        Aliased_Present     =>\n+                          False,\n+                        Subtype_Indication  =>\n+                          New_Occurrence_Of (RACW_Type, Loc)))))));\n       Set_Equivalent_Type (User_Type, Fat_Type);\n       Set_Corresponding_Remote_Type (Fat_Type, User_Type);\n+      Insert_After_And_Analyze (Subpkg_Decl, Fat_Type_Decl);\n \n       --  The reason we suppress the initialization procedure is that we know\n       --  that no initialization is required (even if Initialize_Scalars mode\n@@ -506,8 +635,7 @@ package body Sem_Dist is\n    -- Remote_AST_E_Dereference --\n    ------------------------------\n \n-   function Remote_AST_E_Dereference (P : Node_Id) return Boolean\n-   is\n+   function Remote_AST_E_Dereference (P : Node_Id) return Boolean is\n       ET : constant Entity_Id  := Etype (P);\n \n    begin\n@@ -534,12 +662,11 @@ package body Sem_Dist is\n    -- Remote_AST_I_Dereference --\n    ------------------------------\n \n-   function Remote_AST_I_Dereference (P : Node_Id) return Boolean\n-   is\n+   function Remote_AST_I_Dereference (P : Node_Id) return Boolean is\n       ET     : constant Entity_Id  := Etype (P);\n       Deref  : Node_Id;\n-   begin\n \n+   begin\n       if Comes_From_Source (P)\n         and then (Is_Remote_Call_Interface (ET)\n                    or else Is_Remote_Types (ET))\n@@ -563,9 +690,8 @@ package body Sem_Dist is\n    ---------------------------\n \n    function Remote_AST_Null_Value\n-     (N    : Node_Id;\n-      Typ  : Entity_Id)\n-      return Boolean\n+     (N   : Node_Id;\n+      Typ : Entity_Id) return Boolean\n    is\n       Loc         : constant Source_Ptr := Sloc (N);\n       Target_Type : Entity_Id;\n@@ -603,12 +729,12 @@ package body Sem_Dist is\n \n       Rewrite (N,\n         Make_Aggregate (Loc,\n-          Expressions => New_List (\n-            Make_Integer_Literal (Loc, 0),                  -- Ras\n-            Make_Integer_Literal (Loc, 0),                  -- Origin\n-            Make_Integer_Literal (Loc, 0),                  -- Receiver\n-            Make_Integer_Literal (Loc, 0),                  -- Subp_Id\n-            New_Occurrence_Of (Standard_False, Loc))));     -- Asyn\n+          Component_Associations => New_List (\n+            Make_Component_Association (Loc,\n+              Choices => New_List (\n+                Make_Identifier (Loc, Name_Ras)),\n+              Expression =>\n+                Make_Null (Loc)))));\n       Analyze_And_Resolve (N, Target_Type);\n       return True;\n    end Remote_AST_Null_Value;"}, {"sha": "4acf872baf47f8b4219b2d023634991c79a8e126", "filename": "gcc/ada/sem_dist.ads", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fsem_dist.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fsem_dist.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dist.ads?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -36,6 +36,13 @@ package Sem_Dist is\n    --  caller stubs, expansion takes place directly in the specification and\n    --  no additional compilation unit is created.\n \n+   function Build_RAS_Primitive_Specification\n+     (Subp_Spec          : Node_Id;\n+      Remote_Object_Type : Node_Id) return Node_Id;\n+   --  Build a subprogram specification for the primitive operation of the\n+   --  Remote_Object_Type used to implement a remote access-to-subprogram\n+   --  type whose parameter profile is given by specification Subp_Spec.\n+\n    function Is_All_Remote_Call (N : Node_Id) return Boolean;\n    --  Check whether a function or procedure call should be expanded into\n    --  a remote call, because the entity is declared in a package decl that\n@@ -75,9 +82,8 @@ package Sem_Dist is\n    --  the previous function.\n \n    function Remote_AST_Null_Value\n-     (N    : Node_Id;\n-      Typ  : Entity_Id)\n-      return Boolean;\n+     (N   : Node_Id;\n+      Typ : Entity_Id) return Boolean;\n    --  If N is a null value and Typ a remote access to subprogram type,\n    --  this function will check if null needs to be replaced with an\n    --  aggregate and will return True in this case. Otherwise, it will"}, {"sha": "6fd97d8a269462e659fb5e1abaa1bf0351fc558f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -2929,7 +2929,6 @@ package body Sem_Prag is\n             --  denoted entities in the same declarative part.\n \n             Hom_Id := Def_Id;\n-\n             while Present (Hom_Id) loop\n                Def_Id := Get_Base_Subprogram (Hom_Id);\n \n@@ -4498,6 +4497,9 @@ package body Sem_Prag is\n             elsif Ekind (Nm) = E_Record_Type\n               and then Present (Corresponding_Remote_Type (Nm))\n             then\n+               --  A record type that is the Equivalent_Type for\n+               --  a remote access-to-subprogram type.\n+\n                N := Declaration_Node (Corresponding_Remote_Type (Nm));\n \n                if Nkind (N) = N_Full_Type_Declaration\n@@ -4507,6 +4509,13 @@ package body Sem_Prag is\n                   L := Parameter_Specifications (Type_Definition (N));\n                   Process_Async_Pragma;\n \n+                  if Is_Asynchronous (Nm)\n+                    and then Expander_Active\n+                  then\n+                     RACW_Type_Is_Asynchronous (\n+                       Underlying_RACW_Type (Nm));\n+                  end if;\n+\n                else\n                   Error_Pragma_Arg\n                     (\"pragma% cannot reference access-to-function type\","}, {"sha": "8d0cf7577e034ace8cad2f4f69e2b42d37bdcbee", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 73, "deletions": 52, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -141,7 +141,7 @@ package body Sem_Type is\n    --  visibility of these user-defined operations must be special-cased\n    --  to determine whether they hide or are hidden by predefined operators.\n    --  The form P.\"+\" (x, y) requires additional handling.\n-   --\n+\n    --  Concatenation is treated more conventionally: for every one-dimensional\n    --  array type we introduce a explicit concatenation operator. This is\n    --  necessary to handle the case of (element & element => array) which\n@@ -154,7 +154,7 @@ package body Sem_Type is\n \n    procedure All_Overloads;\n    pragma Warnings (Off, All_Overloads);\n-   --  Debugging procedure: list full contents of Overloads table.\n+   --  Debugging procedure: list full contents of Overloads table\n \n    procedure New_Interps (N : Node_Id);\n    --  Initialize collection of interpretations for the given node, which is\n@@ -197,7 +197,6 @@ package body Sem_Type is\n \n       begin\n          Get_First_Interp (N, Index, It);\n-\n          while Present (It.Nam) loop\n \n             --  A user-defined subprogram hides another declared at an outer\n@@ -234,8 +233,8 @@ package body Sem_Type is\n                   exit;\n \n                elsif not In_Open_Scopes (Scope (Name))\n-                 or else Scope_Depth (Scope (Name))\n-                   <= Scope_Depth (Scope (It.Nam))\n+                 or else Scope_Depth (Scope (Name)) <=\n+                         Scope_Depth (Scope (It.Nam))\n                then\n                   --  If ambiguity within instance, and entity is not an\n                   --  implicit operation, save for later disambiguation.\n@@ -297,9 +296,7 @@ package body Sem_Type is\n \n          elsif Nkind (N) = N_Function_Call then\n             Arg := First_Actual (N);\n-\n             while Present (Arg) loop\n-\n                if No (Universal_Interpretation (Arg)) then\n                   return False;\n                end if;\n@@ -338,7 +335,7 @@ package body Sem_Type is\n            or else Is_Potentially_Use_Visible (Vis_Type)\n            or else In_Use (Vis_Type)\n            or else (In_Use (Scope (Vis_Type))\n-                     and then not Is_Hidden (Vis_Type))\n+                      and then not Is_Hidden (Vis_Type))\n            or else Nkind (N) = N_Expanded_Name\n            or else (Nkind (N) in N_Op and then E = Entity (N))\n            or else In_Instance\n@@ -354,8 +351,8 @@ package body Sem_Type is\n          elsif Nkind (N) = N_Function_Call\n            and then Nkind (Name (N)) = N_Expanded_Name\n            and then (Entity (Prefix (Name (N))) = Scope (Base_Type (T))\n-                      or else Entity (Prefix (Name (N))) = Scope (Vis_Type)\n-                      or else Scope (Vis_Type) = System_Aux_Id)\n+                       or else Entity (Prefix (Name (N))) = Scope (Vis_Type)\n+                       or else Scope (Vis_Type) = System_Aux_Id)\n          then\n             null;\n \n@@ -390,7 +387,7 @@ package body Sem_Type is\n             Set_Etype (N, T);\n \n          else\n-            --  Record both the operator or subprogram name, and its type.\n+            --  Record both the operator or subprogram name, and its type\n \n             if Nkind (N) in N_Op or else Is_Entity_Name (N) then\n                Set_Entity (N, E);\n@@ -504,12 +501,12 @@ package body Sem_Type is\n \n                for J in First_Interp .. All_Interp.Last - 1 loop\n \n-                  --  Current homograph is not hidden. Add to overloads.\n+                  --  Current homograph is not hidden. Add to overloads\n \n                   if not Is_Immediately_Visible (All_Interp.Table (J).Nam) then\n                      exit;\n \n-                  --  Homograph is hidden, unless it is a predefined operator.\n+                  --  Homograph is hidden, unless it is a predefined operator\n \n                   elsif Type_Conformant (H, All_Interp.Table (J).Nam) then\n \n@@ -547,7 +544,7 @@ package body Sem_Type is\n                H := Homonym (H);\n          end loop;\n \n-         --  Scan list of homographs for use-visible entities only.\n+         --  Scan list of homographs for use-visible entities only\n \n          H := Current_Entity (Ent);\n \n@@ -576,7 +573,7 @@ package body Sem_Type is\n \n       if All_Interp.Last = First_Interp + 1 then\n \n-         --  The original interpretation is in fact not overloaded.\n+         --  The original interpretation is in fact not overloaded\n \n          Set_Is_Overloaded (N, False);\n       end if;\n@@ -666,7 +663,7 @@ package body Sem_Type is\n       then\n          return True;\n \n-      --  The context may be class wide.\n+      --  The context may be class wide\n \n       elsif Is_Class_Wide_Type (T1)\n         and then Is_Ancestor (Root_Type (T1), T2)\n@@ -903,6 +900,10 @@ package body Sem_Type is\n       Predef_Subp : Entity_Id;\n       User_Subp   : Entity_Id;\n \n+      function Inherited_From_Actual (S : Entity_Id) return Boolean;\n+      --  Determine whether one of the candidates is an operation inherited\n+      --  by a type that is derived from an actual in an instantiation.\n+\n       function Is_Actual_Subprogram (S : Entity_Id) return Boolean;\n       --  Determine whether a subprogram is an actual in an enclosing\n       --  instance. An overloading between such a subprogram and one\n@@ -914,6 +915,7 @@ package body Sem_Type is\n       --  ambiguities when two formal types have the same actual.\n \n       function Standard_Operator return Boolean;\n+      --  Comment required ???\n \n       function Remove_Conversions return Interp;\n       --  Last chance for pathological cases involving comparisons on\n@@ -932,6 +934,29 @@ package body Sem_Type is\n       --  pathology in the other direction with calls whose multiple overloaded\n       --  actuals make them truly unresolvable.\n \n+      ---------------------------\n+      -- Inherited_From_Actual --\n+      ---------------------------\n+\n+      function Inherited_From_Actual (S : Entity_Id) return Boolean is\n+         Par : constant Node_Id := Parent (S);\n+      begin\n+         if Nkind (Par) /= N_Full_Type_Declaration\n+           or else Nkind (Type_Definition (Par)) /= N_Derived_Type_Definition\n+         then\n+            return False;\n+         else\n+            return Is_Entity_Name (Subtype_Indication (Type_Definition (Par)))\n+              and then\n+               Is_Generic_Actual_Type (\n+                 Entity (Subtype_Indication (Type_Definition (Par))));\n+         end if;\n+      end Inherited_From_Actual;\n+\n+      --------------------------\n+      -- Is_Actual_Subprogram --\n+      --------------------------\n+\n       function Is_Actual_Subprogram (S : Entity_Id) return Boolean is\n       begin\n          return In_Open_Scopes (Scope (S))\n@@ -947,7 +972,6 @@ package body Sem_Type is\n       function Matches (Actual, Formal : Node_Id) return Boolean is\n          T1 : constant Entity_Id := Etype (Actual);\n          T2 : constant Entity_Id := Etype (Formal);\n-\n       begin\n          return T1 = T2\n            or else\n@@ -969,9 +993,9 @@ package body Sem_Type is\n          Act2 : Node_Id;\n \n       begin\n-         It1   := No_Interp;\n-         Get_First_Interp (N, I, It);\n+         It1 := No_Interp;\n \n+         Get_First_Interp (N, I, It);\n          while Present (It.Typ) loop\n \n             if not Is_Overloadable (It.Nam) then\n@@ -1055,12 +1079,11 @@ package body Sem_Type is\n                Get_Next_Interp (I, It);\n          end loop;\n \n-         if Serious_Errors_Detected > 0 then\n-\n-            --  After some error, a formal may have Any_Type and yield\n-            --  a spurious match. To avoid cascaded errors if possible,\n-            --  check for such a formal in either candidate.\n+         --  After some error, a formal may have Any_Type and yield\n+         --  a spurious match. To avoid cascaded errors if possible,\n+         --  check for such a formal in either candidate.\n \n+         if Serious_Errors_Detected > 0 then\n             declare\n                Formal : Entity_Id;\n \n@@ -1115,17 +1138,15 @@ package body Sem_Type is\n    --  Start of processing for Disambiguate\n \n    begin\n-      --  Recover the two legal interpretations.\n+      --  Recover the two legal interpretations\n \n       Get_First_Interp (N, I, It);\n-\n       while I /= I1 loop\n          Get_Next_Interp (I, It);\n       end loop;\n \n       It1  := It;\n       Nam1 := It.Nam;\n-\n       while I /= I2 loop\n          Get_Next_Interp (I, It);\n       end loop;\n@@ -1154,12 +1175,12 @@ package body Sem_Type is\n \n             declare\n                Candidate : Interp := No_Interp;\n+\n             begin\n                Get_First_Interp (N, I, It);\n-\n                while Present (It.Typ) loop\n                   if (Covers (Typ, It.Typ)\n-                       or else Typ = Any_Type)\n+                        or else Typ = Any_Type)\n                     and then\n                      (It.Typ = Universal_Integer\n                        or else It.Typ = Universal_Real)\n@@ -1183,8 +1204,7 @@ package body Sem_Type is\n             end;\n \n          elsif Chars (Nam1) /= Name_Op_Not\n-           and then (Typ = Standard_Boolean\n-             or else Typ = Any_Boolean)\n+           and then (Typ = Standard_Boolean or else Typ = Any_Boolean)\n          then\n             --  Equality or comparison operation. Choose predefined operator\n             --  if arguments are universal. The node may be an operator, a\n@@ -1215,7 +1235,6 @@ package body Sem_Type is\n                           Universal_Interpretation (Arg1)\n                then\n                   Get_First_Interp (N, I, It);\n-\n                   while Scope (It.Nam) /= Standard_Standard loop\n                      Get_Next_Interp (I, It);\n                   end loop;\n@@ -1273,6 +1292,11 @@ package body Sem_Type is\n          --  node is overloaded, it did not resolve to the global entity in\n          --  the generic, and we choose the formal subprogram.\n \n+         --  Finally, the ambiguity can be between an explicit subprogram and\n+         --  one inherited (with different defaults) from an actual. In this\n+         --  case the resolution was to the explicit declaration in the\n+         --  generic, and remains so in the instance.\n+\n          elsif In_Instance then\n             if Nkind (N) = N_Function_Call\n               or else Nkind (N) = N_Procedure_Call_Statement\n@@ -1289,6 +1313,16 @@ package body Sem_Type is\n \n                   elsif Is_Act2 and then not Is_Act1 then\n                      return It2;\n+\n+                  elsif Inherited_From_Actual (Nam1)\n+                    and then Comes_From_Source (Nam2)\n+                  then\n+                     return It2;\n+\n+                  elsif Inherited_From_Actual (Nam2)\n+                    and then Comes_From_Source (Nam1)\n+                  then\n+                     return It1;\n                   end if;\n \n                   Actual := First_Actual (N);\n@@ -1306,7 +1340,6 @@ package body Sem_Type is\n                end;\n \n             elsif Nkind (N) in N_Binary_Op then\n-\n                if Matches (Left_Opnd (N), First_Formal (Nam1))\n                  and then\n                    Matches (Right_Opnd (N), Next_Formal (First_Formal (Nam1)))\n@@ -1317,7 +1350,6 @@ package body Sem_Type is\n                end if;\n \n             elsif Nkind (N) in  N_Unary_Op then\n-\n                if Etype (Right_Opnd (N)) = Etype (First_Formal (Nam1)) then\n                   return It1;\n                else\n@@ -1374,7 +1406,7 @@ package body Sem_Type is\n          then\n             if Is_Fixed_Point_Type (Typ)\n               and then (Chars (Nam1) = Name_Op_Multiply\n-                         or else Chars (Nam1) = Name_Op_Divide)\n+                          or else Chars (Nam1) = Name_Op_Divide)\n               and then Ada_Version = Ada_83\n             then\n                if It2.Nam = Predef_Subp then\n@@ -1393,7 +1425,6 @@ package body Sem_Type is\n             return It2;\n          end if;\n       end if;\n-\n    end Disambiguate;\n \n    ---------------------\n@@ -1449,7 +1480,6 @@ package body Sem_Type is\n    begin\n       if Is_Overloaded (R) then\n          Get_First_Interp (R, I, It);\n-\n          while Present (It.Typ) loop\n             if Covers (T, It.Typ) or else Covers (It.Typ, T) then\n \n@@ -1474,8 +1504,7 @@ package body Sem_Type is\n \n          Set_Etype (R, TR);\n \n-      --  In the non-overloaded case, the Etype of R is already set\n-      --  correctly.\n+      --  In the non-overloaded case, the Etype of R is already set correctly\n \n       else\n          null;\n@@ -1542,7 +1571,6 @@ package body Sem_Type is\n       end if;\n \n       Map_Ptr := Headers (Hash (O_N));\n-\n       while Present (Interp_Map.Table (Map_Ptr).Node) loop\n          if Interp_Map.Table (Map_Ptr).Node = O_N then\n             Int_Ind := Interp_Map.Table (Map_Ptr).Index;\n@@ -1598,16 +1626,14 @@ package body Sem_Type is\n \n       else\n          Get_First_Interp (N, I, It);\n-\n          while Present (It.Typ) loop\n             if (Covers (Typ, It.Typ)\n-                and then\n-                  (Scope (It.Nam) /= Standard_Standard\n-                     or else not Is_Invisible_Operator (N, Base_Type (Typ))))\n-\n+                  and then\n+                    (Scope (It.Nam) /= Standard_Standard\n+                       or else not Is_Invisible_Operator (N, Base_Type (Typ))))\n               or else (not Is_Tagged_Type (Typ)\n-                        and then Ekind (Typ) /= E_Anonymous_Access_Type\n-                        and then Covers (It.Typ, Typ))\n+                         and then Ekind (Typ) /= E_Anonymous_Access_Type\n+                         and then Covers (It.Typ, Typ))\n             then\n                return True;\n             end if;\n@@ -1685,7 +1711,6 @@ package body Sem_Type is\n \n          else\n             Get_First_Interp (R, Index, It);\n-\n             loop\n                T2 := Specific_Type (T, It.Typ);\n \n@@ -1714,7 +1739,6 @@ package body Sem_Type is\n       else\n          Typ := Any_Type;\n          Get_First_Interp (L, Index, It);\n-\n          while Present (It.Typ) loop\n             Typ := Check_Right_Argument (It.Typ);\n             exit when Typ /= Any_Type;\n@@ -1726,7 +1750,6 @@ package body Sem_Type is\n       --  If Typ is Any_Type, it means no compatible pair of types was found\n \n       if Typ = Any_Type then\n-\n          if Nkind (Parent (L)) in N_Op then\n             Error_Msg_N (\"incompatible types for operator\", Parent (L));\n \n@@ -1947,7 +1970,6 @@ package body Sem_Type is\n       New_F := First_Formal (New_S);\n       Old_F := First_Formal (Op);\n       Num := 0;\n-\n       while Present (New_F) and then Present (Old_F) loop\n          Num := Num + 1;\n          Next_Formal (New_F);\n@@ -2095,7 +2117,6 @@ package body Sem_Type is\n       --  Find end of Interp list and copy downward to erase the discarded one\n \n       II := I + 1;\n-\n       while Present (All_Interp.Table (II).Typ) loop\n          II := II + 1;\n       end loop;"}, {"sha": "762be69a9a4f853753ccb5781270ad8a46b32a0f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -41,7 +41,6 @@ with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Output;   use Output;\n with Opt;      use Opt;\n-with Restrict; use Restrict;\n with Rtsfind;  use Rtsfind;\n with Scans;    use Scans;\n with Scn;      use Scn;\n@@ -869,33 +868,23 @@ package body Sem_Util is\n \n    procedure Check_Potentially_Blocking_Operation (N : Node_Id) is\n       S   : Entity_Id;\n-      Loc : constant Source_Ptr := Sloc (N);\n \n    begin\n-      --  N is one of the potentially blocking operations listed in\n-      --  9.5.1 (8). When using the Ravenscar profile, raise Program_Error\n-      --  before N if the context is a protected action. Otherwise, only issue\n-      --  a warning, since some users are relying on blocking operations\n-      --  inside protected objects.\n-      --  Indirect blocking through a subprogram call\n-      --  cannot be diagnosed statically without interprocedural analysis,\n-      --  so we do not attempt to do it here.\n+      --  N is one of the potentially blocking operations listed in 9.5.1(8).\n+      --  When pragma Detect_Blocking is active, the run time will raise\n+      --  Program_Error. Here we only issue a warning, since we generally\n+      --  support the use of potentially blocking operations in the absence\n+      --  of the pragma.\n \n-      S := Scope (Current_Scope);\n+      --  Indirect blocking through a subprogram call cannot be diagnosed\n+      --  statically without interprocedural analysis, so we do not attempt\n+      --  to do it here.\n \n+      S := Scope (Current_Scope);\n       while Present (S) and then S /= Standard_Standard loop\n          if Is_Protected_Type (S) then\n-            if Restricted_Profile then\n-               Insert_Before_And_Analyze (N,\n-                  Make_Raise_Program_Error (Loc,\n-                    Reason => PE_Potentially_Blocking_Operation));\n-               Error_Msg_N (\"potentially blocking operation, \" &\n-                 \" Program Error will be raised at run time?\", N);\n-\n-            else\n-               Error_Msg_N\n-                 (\"potentially blocking operation in protected operation?\", N);\n-            end if;\n+            Error_Msg_N\n+              (\"potentially blocking operation in protected operation?\", N);\n \n             return;\n          end if;\n@@ -5781,10 +5770,9 @@ package body Sem_Util is\n          --  scope because the back end otherwise tries to allocate a\n          --  variable length temporary for the particular variant.\n \n-         --  ??? With tree-ssa, the back-end does not (yet) support these\n-         --  types either, so disable this optimization for now.\n-\n-         if Has_Discriminants (Typ) then\n+         if Opt.GCC_Version = 2\n+           and then Has_Discriminants (Typ)\n+         then\n             return True;\n \n          --  For GCC 3, or for a non-discriminated record in GCC 2, we are"}, {"sha": "4cc22f8b9172459152b9e9882d8fbd580c692c45", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -110,8 +110,7 @@ package Sem_Util is\n \n    procedure Check_Potentially_Blocking_Operation (N : Node_Id);\n    --  N is one of the statement forms that is a potentially blocking\n-   --  operation. If it appears within a protected action, emit warning\n-   --  and raise Program_Error.\n+   --  operation. If it appears within a protected action, emit warning.\n \n    procedure Check_VMS (Construct : Node_Id);\n    --  Check that this the target is OpenVMS, and if so, return with"}, {"sha": "eb25be383f90a5440f5f5a8e3fd484c49c7cce29", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 285, "deletions": 181, "changes": 466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -779,8 +779,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \n       if (attribute == Attr_Max_Size_In_Storage_Elements)\n \tgnu_result = convert (sizetype,\n-\t\t\t      fold (build (CEIL_DIV_EXPR, bitsizetype,\n-\t\t\t\t\t   gnu_result, bitsize_unit_node)));\n+\t\t\t      fold (build2 (CEIL_DIV_EXPR, bitsizetype,\n+\t\t\t\t\t    gnu_result, bitsize_unit_node)));\n       break;\n \n     case Attr_Alignment:\n@@ -1101,8 +1101,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n      example in AARM 11.6(5.e). */\n   if (prefix_unused && TREE_SIDE_EFFECTS (gnu_prefix)\n       && !Is_Entity_Name (Prefix (gnat_node)))\n-    gnu_result = fold (build (COMPOUND_EXPR, TREE_TYPE (gnu_result),\n-\t\t\t      gnu_prefix, gnu_result));\n+    gnu_result = fold (build2 (COMPOUND_EXPR, TREE_TYPE (gnu_result),\n+\t\t\t       gnu_prefix, gnu_result));\n \n   *gnu_result_type_p = gnu_result_type;\n   return gnu_result;\n@@ -1197,9 +1197,9 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n \t      abort ();\n \t    }\n \n-\t  add_stmt_with_node (build (CASE_LABEL_EXPR, void_type_node,\n-\t\t\t\t     gnu_low, gnu_high,\n-\t\t\t\t     create_artificial_label ()),\n+\t  add_stmt_with_node (build3 (CASE_LABEL_EXPR, void_type_node,\n+\t\t\t\t      gnu_low, gnu_high,\n+\t\t\t\t      create_artificial_label ()),\n \t\t\t      gnat_choice);\n \t}\n \n@@ -1214,8 +1214,8 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n   /* Now emit a definition of the label all the cases branched to. */\n   add_stmt (build1 (LABEL_EXPR, void_type_node,\n \t\t    TREE_VALUE (gnu_switch_label_stack)));\n-  gnu_result = build (SWITCH_EXPR, TREE_TYPE (gnu_expr), gnu_expr,\n-\t\t      end_stmt_group (), NULL_TREE);\n+  gnu_result = build3 (SWITCH_EXPR, TREE_TYPE (gnu_expr), gnu_expr,\n+\t\t       end_stmt_group (), NULL_TREE);\n   pop_stack (&gnu_switch_label_stack);\n \n   return gnu_result;\n@@ -1279,10 +1279,10 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \t  || tree_int_cst_equal (gnu_last, gnu_limit))\n \t{\n \t  gnu_cond_expr\n-\t    = build (COND_EXPR, void_type_node,\n-\t\t     build_binary_op (LE_EXPR, integer_type_node,\n-\t\t\t\t      gnu_low, gnu_high),\n-\t\t     NULL_TREE, alloc_stmt_list ());\n+\t    = build3 (COND_EXPR, void_type_node,\n+\t\t      build_binary_op (LE_EXPR, integer_type_node,\n+\t\t\t\t       gnu_low, gnu_high),\n+\t\t      NULL_TREE, alloc_stmt_list ());\n \t  annotate_with_node (gnu_cond_expr, gnat_loop_spec);\n \t}\n \n@@ -1485,8 +1485,8 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n       add_stmt_with_node\n \t(build1 (RETURN_EXPR, void_type_node,\n-\t\t build (MODIFY_EXPR, TREE_TYPE (gnu_retval),\n-\t\t\tDECL_RESULT (current_function_decl), gnu_retval)),\n+\t\t build2 (MODIFY_EXPR, TREE_TYPE (gnu_retval),\n+\t\t\t DECL_RESULT (current_function_decl), gnu_retval)),\n \t gnat_node);\n       gnat_poplevel ();\n       gnu_result = end_stmt_group ();\n@@ -1520,10 +1520,12 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \f\n /* Subroutine of gnat_to_gnu to translate gnat_node, either an N_Function_Call\n    or an N_Procedure_Call_Statement, to a GCC tree, which is returned.\n-   GNU_RESULT_TYPE_P is a pointer to where we should place the result type.  */\n+   GNU_RESULT_TYPE_P is a pointer to where we should place the result type.\n+   If GNU_TARGET is non-null, this must be a function call and the result\n+   of the call is to be placed into that object.  */\n \n static tree\n-call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n+call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n {\n   tree gnu_result;\n   /* The GCC node corresponding to the GNAT subprogram name.  This can either\n@@ -1566,7 +1568,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t   gnat_actual = Next_Actual (gnat_actual))\n \tadd_stmt (gnat_to_gnu (gnat_actual));\n \n-      if (Nkind (gnat_node) == N_Function_Call)\n+      if (Nkind (gnat_node) == N_Function_Call && !gnu_target)\n \t{\n \t  *gnu_result_type_p = TREE_TYPE (gnu_subprog_type);\n \t  return build1 (NULL_EXPR, *gnu_result_type_p,\n@@ -1576,6 +1578,37 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \treturn build_call_raise (PE_Stubbed_Subprogram_Called);\n     }\n \n+  /* If we are calling by supplying a pointer to a target, set up that\n+     pointer as the first argument.  Use GNU_TARGET if one was passed;\n+     otherwise, make a target by building a variable of the maximum size\n+     of the type.  */\n+  if (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type))\n+    {\n+      tree gnu_real_ret_type\n+\t= TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (gnu_subprog_type)));\n+\n+      if (!gnu_target)\n+\t{\n+\t  tree gnu_obj_type\n+\t    = maybe_pad_type (gnu_real_ret_type,\n+\t\t\t      max_size (TYPE_SIZE (gnu_real_ret_type), true),\n+\t\t\t      0, Etype (Name (gnat_node)), \"PAD\", false,\n+\t\t\t      false, false);\n+\n+\t  gnu_target = create_tmp_var_raw (gnu_obj_type, \"LR\");\n+\t  gnat_pushdecl (gnu_target, gnat_node);\n+\t}\n+\n+      gnu_actual_list\n+\t= tree_cons (NULL_TREE,\n+\t\t     build_unary_op (ADDR_EXPR, NULL_TREE,\n+\t\t\t\t     unchecked_convert (gnu_real_ret_type,\n+\t\t\t\t\t\t\tgnu_target,\n+\t\t\t\t\t\t\tfalse)),\n+\t\t     NULL_TREE);\n+\t\t\t\t\t\t   \n+    }\n+\n   /* The only way we can be making a call via an access type is if Name is an\n      explicit dereference.  In that case, get the list of formal args from the\n      type the access type is pointing to.  Otherwise, get the formals from\n@@ -1660,8 +1693,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t\t}\n \n \t      /* Set up to move the copy back to the original.  */\n-\t      gnu_temp = build (MODIFY_EXPR, TREE_TYPE (gnu_copy),\n-\t\t\t\tgnu_copy, gnu_actual);\n+\t      gnu_temp = build2 (MODIFY_EXPR, TREE_TYPE (gnu_copy),\n+\t\t\t\t gnu_copy, gnu_actual);\n \t      annotate_with_node (gnu_temp, gnat_actual);\n \t      append_to_statement_list (gnu_temp, &gnu_after_list);\n \t    }\n@@ -1826,12 +1859,24 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       gnu_actual_list = tree_cons (NULL_TREE, gnu_actual, gnu_actual_list);\n     }\n \n-  gnu_subprog_call = build (CALL_EXPR, TREE_TYPE (gnu_subprog_type),\n-\t\t\t    gnu_subprog_addr, nreverse (gnu_actual_list),\n-\t\t\t    NULL_TREE);\n+  gnu_subprog_call = build3 (CALL_EXPR, TREE_TYPE (gnu_subprog_type),\n+\t\t\t     gnu_subprog_addr, nreverse (gnu_actual_list),\n+\t\t\t     NULL_TREE);\n \n-  /* If it is a function call, the result is the call expression.  */\n-  if (Nkind (gnat_node) == N_Function_Call)\n+  /* If we return by passing a target, we emit the call and return the target\n+     as our result.  */\n+  if (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type))\n+    {\n+      add_stmt_with_node (gnu_subprog_call, gnat_node);\n+      *gnu_result_type_p\n+\t= TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (gnu_subprog_type)));\n+      return unchecked_convert (*gnu_result_type_p, gnu_target, false);\n+    }\n+\n+  /* If it is a function call, the result is the call expression unless\n+     a target is specified, in which case we copy the result into the target\n+     and return the assignment statement.  */\n+  else if (Nkind (gnat_node) == N_Function_Call)\n     {\n       gnu_result = gnu_subprog_call;\n \n@@ -1841,7 +1886,12 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t  || TYPE_RETURNS_BY_REF_P (gnu_subprog_type))\n \tgnu_result = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_result);\n \n-      *gnu_result_type_p = get_unpadded_type (Etype (gnat_node));\n+      if (gnu_target)\n+\tgnu_result = build_binary_op (MODIFY_EXPR, NULL_TREE,\n+\t\t\t\t      gnu_target, gnu_result);\n+      else\n+\t*gnu_result_type_p = get_unpadded_type (Etype (gnat_node));\n+\n       return gnu_result;\n     }\n \n@@ -2111,12 +2161,12 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n       gnu_handler = end_stmt_group ();\n \n       /* This block is now \"if (setjmp) ... <handlers> else <block>\".  */\n-      gnu_result = build (COND_EXPR, void_type_node,\n-\t\t\t  (build_call_1_expr\n-\t\t\t   (setjmp_decl,\n-\t\t\t    build_unary_op (ADDR_EXPR, NULL_TREE,\n-\t\t\t\t\t    gnu_jmpbuf_decl))),\n-\t\t\t  gnu_handler, gnu_inner_block);\n+      gnu_result = build3 (COND_EXPR, void_type_node,\n+\t\t\t   (build_call_1_expr\n+\t\t\t    (setjmp_decl,\n+\t\t\t     build_unary_op (ADDR_EXPR, NULL_TREE,\n+\t\t\t\t\t     gnu_jmpbuf_decl))),\n+\t\t\t   gnu_handler, gnu_inner_block);\n     }\n   else if (gcc_zcx)\n     {\n@@ -2131,8 +2181,8 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n       gnu_handlers = end_stmt_group ();\n \n       /* Now make the TRY_CATCH_EXPR for the block.  */\n-      gnu_result = build (TRY_CATCH_EXPR, void_type_node,\n-\t\t\t  gnu_inner_block, gnu_handlers);\n+      gnu_result = build2 (TRY_CATCH_EXPR, void_type_node,\n+\t\t\t   gnu_inner_block, gnu_handlers);\n     }\n   else\n     gnu_result = gnu_inner_block;\n@@ -2225,7 +2275,7 @@ Exception_Handler_to_gnu_sjlj (Node_Id gnat_node)\n \t\t\t\t    gnu_choice, this_choice);\n     }\n \n-  return build (COND_EXPR, void_type_node, gnu_choice, gnu_body, NULL_TREE);\n+  return build3 (COND_EXPR, void_type_node, gnu_choice, gnu_body, NULL_TREE);\n }\n \f\n /* Subroutine of gnat_to_gnu to translate gnat_node, an N_Exception_Handler,\n@@ -2312,7 +2362,7 @@ Exception_Handler_to_gnu_zcx (Node_Id gnat_node)\n \n      We use a local variable to retrieve the incoming value at handler entry\n      time, and reuse it to feed the end_handler hook's argument at exit.  */\n-  gnu_current_exc_ptr = build (EXC_PTR_EXPR, ptr_type_node);\n+  gnu_current_exc_ptr = build0 (EXC_PTR_EXPR, ptr_type_node);\n   gnu_incoming_exc_ptr = create_var_decl (get_identifier (\"EXPTR\"), NULL_TREE,\n \t\t\t\t\t  ptr_type_node, gnu_current_exc_ptr,\n \t\t\t\t\t  false, false, false, false, NULL,\n@@ -2325,8 +2375,8 @@ Exception_Handler_to_gnu_zcx (Node_Id gnat_node)\n   add_stmt_list (Statements (gnat_node));\n   gnat_poplevel ();\n \n-  return build (CATCH_EXPR, void_type_node, gnu_etypes_list,\n-\t\tend_stmt_group ());\n+  return build2 (CATCH_EXPR, void_type_node, gnu_etypes_list,\n+\t\t end_stmt_group ());\n }\n \f\n /* Subroutine of gnat_to_gnu to generate code for an N_Compilation unit.  */\n@@ -2857,13 +2907,13 @@ gnat_to_gnu (Node_Id gnat_node)\n                expression if the slice range is not null (max >= min) or\n                returns the min if the slice range is null */\n             gnu_expr\n-              = fold (build (COND_EXPR, gnu_expr_type,\n-\t\t\t     build_binary_op (GE_EXPR, gnu_expr_type,\n-\t\t\t\t\t      convert (gnu_expr_type,\n-\t\t\t\t\t\t       gnu_max_expr),\n-\t\t\t\t\t      convert (gnu_expr_type,\n-\t\t\t\t\t\t       gnu_min_expr)),\n-\t\t\t     gnu_expr, gnu_min_expr));\n+              = fold (build3 (COND_EXPR, gnu_expr_type,\n+\t\t\t      build_binary_op (GE_EXPR, gnu_expr_type,\n+\t\t\t\t\t       convert (gnu_expr_type,\n+\t\t\t\t\t\t\tgnu_max_expr),\n+\t\t\t\t\t       convert (gnu_expr_type,\n+\t\t\t\t\t\t\tgnu_min_expr)),\n+\t\t\t      gnu_expr, gnu_min_expr));\n           }\n         else\n           gnu_expr = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_result_type));\n@@ -3354,36 +3404,42 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Assignment_Statement:\n       /* Get the LHS and RHS of the statement and convert any reference to an\n-\t unconstrained array into a reference to the underlying array.  */\n+\t unconstrained array into a reference to the underlying array.\n+\t If we are not to do range checking and the RHS is an N_Function_Call,\n+\t pass the LHS to the call function.  */\n       gnu_lhs = maybe_unconstrained_array (gnat_to_gnu (Name (gnat_node)));\n-      gnu_rhs\n-\t= maybe_unconstrained_array (gnat_to_gnu (Expression (gnat_node)));\n-\n-      /* If range check is needed, emit code to generate it */\n-      if (Do_Range_Check (Expression (gnat_node)))\n-\tgnu_rhs = emit_range_check (gnu_rhs, Etype (Name (gnat_node)));\n \n-      /* If either side's type has a size that overflows, convert this\n-\t into raise of Storage_Error: execution shouldn't have gotten\n-\t here anyway.  */\n-      if ((TREE_CODE (TYPE_SIZE (TREE_TYPE (gnu_lhs))) == INTEGER_CST\n+      /* If the type has a size that overflows, convert this into raise of\n+\t Storage_Error: execution shouldn't have gotten here anyway.  */\n+      if (TREE_CODE (TYPE_SIZE (TREE_TYPE (gnu_lhs))) == INTEGER_CST\n \t   && TREE_OVERFLOW (TYPE_SIZE (TREE_TYPE (gnu_lhs))))\n-\t  || (TREE_CODE (TYPE_SIZE (TREE_TYPE (gnu_rhs))) == INTEGER_CST\n-\t      && TREE_OVERFLOW (TYPE_SIZE (TREE_TYPE (gnu_rhs)))))\n \tgnu_result = build_call_raise (SE_Object_Too_Large);\n+      else if (Nkind (Expression (gnat_node)) == N_Function_Call\n+\t       && !Do_Range_Check (Expression (gnat_node)))\n+\tgnu_result = call_to_gnu (Expression (gnat_node),\n+\t\t\t\t  &gnu_result_type, gnu_lhs);\n       else\n-\tgnu_result\n-\t  = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_lhs, gnu_rhs);\n+\t{\n+\t  gnu_rhs\n+\t    = maybe_unconstrained_array (gnat_to_gnu (Expression (gnat_node)));\n+\n+\t  /* If range check is needed, emit code to generate it */\n+\t  if (Do_Range_Check (Expression (gnat_node)))\n+\t    gnu_rhs = emit_range_check (gnu_rhs, Etype (Name (gnat_node)));\n+\n+\t  gnu_result\n+\t    = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_lhs, gnu_rhs);\n+\t}\n       break;\n \n     case N_If_Statement:\n       {\n \ttree *gnu_else_ptr;\t/* Point to put next \"else if\" or \"else\". */\n \n \t/* Make the outer COND_EXPR.  Avoid non-determinism.  */\n-\tgnu_result = build (COND_EXPR, void_type_node,\n-\t\t\t    gnat_to_gnu (Condition (gnat_node)),\n-\t\t\t    NULL_TREE, NULL_TREE);\n+\tgnu_result = build3 (COND_EXPR, void_type_node,\n+\t\t\t     gnat_to_gnu (Condition (gnat_node)),\n+\t\t\t     NULL_TREE, NULL_TREE);\n \tCOND_EXPR_THEN (gnu_result)\n \t  = build_stmt_group (Then_Statements (gnat_node), false);\n \tTREE_SIDE_EFFECTS (gnu_result) = 1;\n@@ -3396,9 +3452,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  for (gnat_temp = First (Elsif_Parts (gnat_node));\n \t       Present (gnat_temp); gnat_temp = Next (gnat_temp))\n \t    {\n-\t      gnu_expr = build (COND_EXPR, void_type_node,\n-\t\t\t\tgnat_to_gnu (Condition (gnat_temp)),\n-\t\t\t\tNULL_TREE, NULL_TREE);\n+\t      gnu_expr = build3 (COND_EXPR, void_type_node,\n+\t\t\t\t gnat_to_gnu (Condition (gnat_temp)),\n+\t\t\t\t NULL_TREE, NULL_TREE);\n \t      COND_EXPR_THEN (gnu_expr)\n \t\t= build_stmt_group (Then_Statements (gnat_temp), false);\n \t      TREE_SIDE_EFFECTS (gnu_expr) = 1;\n@@ -3433,20 +3489,26 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Exit_Statement:\n       gnu_result\n-\t= build (EXIT_STMT, void_type_node,\n-\t\t (Present (Condition (gnat_node))\n-\t\t  ? gnat_to_gnu (Condition (gnat_node)) : NULL_TREE),\n-\t\t (Present (Name (gnat_node))\n-\t\t  ? get_gnu_tree (Entity (Name (gnat_node)))\n-\t\t  : TREE_VALUE (gnu_loop_label_stack)));\n+\t= build2 (EXIT_STMT, void_type_node,\n+\t\t  (Present (Condition (gnat_node))\n+\t\t   ? gnat_to_gnu (Condition (gnat_node)) : NULL_TREE),\n+\t\t  (Present (Name (gnat_node))\n+\t\t   ? get_gnu_tree (Entity (Name (gnat_node)))\n+\t\t   : TREE_VALUE (gnu_loop_label_stack)));\n       break;\n \n     case N_Return_Statement:\n       {\n \t/* The gnu function type of the subprogram currently processed.  */\n \ttree gnu_subprog_type = TREE_TYPE (current_function_decl);\n \t/* The return value from the subprogram.  */\n-\ttree gnu_ret_val = 0;\n+\ttree gnu_ret_val = NULL_TREE;\n+\t/* The place to put the return value.  */\n+\ttree gnu_lhs\n+\t  = (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type)\n+\t     ? build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t       DECL_ARGUMENTS (current_function_decl))\n+\t     : DECL_RESULT (current_function_decl));\n \n \t/* If we are dealing with a \"return;\" from an Ada procedure with\n \t   parameters passed by copy in copy out, we need to return a record\n@@ -3484,53 +3546,71 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \telse if (Present (Expression (gnat_node)))\n \t  {\n-\t    gnu_ret_val = gnat_to_gnu (Expression (gnat_node));\n-\n-\t    /* Do not remove the padding from GNU_RET_VAL if the inner\n-\t       type is self-referential since we want to allocate the fixed\n-\t       size in that case.  */\n-\t    if (TREE_CODE (gnu_ret_val) == COMPONENT_REF\n-\t\t&& (TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_ret_val, 0)))\n-\t\t    == RECORD_TYPE)\n-\t\t&& (TYPE_IS_PADDING_P\n-\t\t    (TREE_TYPE (TREE_OPERAND (gnu_ret_val, 0))))\n-\t\t&& (CONTAINS_PLACEHOLDER_P\n-\t\t    (TYPE_SIZE (TREE_TYPE (gnu_ret_val)))))\n-\t      gnu_ret_val = TREE_OPERAND (gnu_ret_val, 0);\n-\n-\t    if (TYPE_RETURNS_BY_REF_P (gnu_subprog_type)\n-\t\t|| By_Ref (gnat_node))\n-\t      gnu_ret_val = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_ret_val);\n-\n-\t    else if (TYPE_RETURNS_UNCONSTRAINED_P (gnu_subprog_type))\n+\t    /* If the current function returns by target pointer and we\n+\t       are doing a call, pass that target to the call.  */\n+\t    if (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type)\n+\t\t&& Nkind (Expression (gnat_node)) == N_Function_Call)\n+\t      gnu_result = call_to_gnu (Expression (gnat_node),\n+\t\t\t\t\t&gnu_result_type, gnu_lhs);\n+\n+\t    else\n \t      {\n-\t\tgnu_ret_val = maybe_unconstrained_array (gnu_ret_val);\n-\n-\t\t/* We have two cases: either the function returns with\n-\t\t   depressed stack or not.  If not, we allocate on the\n-\t\t   secondary stack.  If so, we allocate in the stack frame.\n-\t\t   if no copy is needed, the front end will set By_Ref,\n-\t\t   which we handle in the case above.  */\n-\t\tif (TYPE_RETURNS_STACK_DEPRESSED (gnu_subprog_type))\n-\t\t  gnu_ret_val\n-\t\t    = build_allocator (TREE_TYPE (gnu_ret_val), gnu_ret_val,\n-\t\t\t\t       TREE_TYPE (gnu_subprog_type), 0, -1,\n-\t\t\t\t       gnat_node);\n-\t\telse\n+\t\tgnu_ret_val = gnat_to_gnu (Expression (gnat_node));\n+\n+\t\t/* Do not remove the padding from GNU_RET_VAL if the inner\n+\t\t   type is self-referential since we want to allocate the fixed\n+\t\t   size in that case.  */\n+\t\tif (TREE_CODE (gnu_ret_val) == COMPONENT_REF\n+\t\t    && (TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_ret_val, 0)))\n+\t\t\t== RECORD_TYPE)\n+\t\t    && (TYPE_IS_PADDING_P\n+\t\t\t(TREE_TYPE (TREE_OPERAND (gnu_ret_val, 0))))\n+\t\t    && (CONTAINS_PLACEHOLDER_P\n+\t\t\t(TYPE_SIZE (TREE_TYPE (gnu_ret_val)))))\n+\t\t  gnu_ret_val = TREE_OPERAND (gnu_ret_val, 0);\n+\n+\t\tif (TYPE_RETURNS_BY_REF_P (gnu_subprog_type)\n+\t\t    || By_Ref (gnat_node))\n \t\t  gnu_ret_val\n-\t\t    = build_allocator (TREE_TYPE (gnu_ret_val), gnu_ret_val,\n-\t\t\t\t       TREE_TYPE (gnu_subprog_type),\n-\t\t\t\t       Procedure_To_Call (gnat_node),\n-\t\t\t\t       Storage_Pool (gnat_node), gnat_node);\n+\t\t    = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_ret_val);\n+\n+\t\telse if (TYPE_RETURNS_UNCONSTRAINED_P (gnu_subprog_type))\n+\t\t  {\n+\t\t    gnu_ret_val = maybe_unconstrained_array (gnu_ret_val);\n+\n+\t\t    /* We have two cases: either the function returns with\n+\t\t       depressed stack or not.  If not, we allocate on the\n+\t\t       secondary stack.  If so, we allocate in the stack frame.\n+\t\t       if no copy is needed, the front end will set By_Ref,\n+\t\t       which we handle in the case above.  */\n+\t\t    if (TYPE_RETURNS_STACK_DEPRESSED (gnu_subprog_type))\n+\t\t      gnu_ret_val\n+\t\t\t= build_allocator (TREE_TYPE (gnu_ret_val),\n+\t\t\t\t\t   gnu_ret_val,\n+\t\t\t\t\t   TREE_TYPE (gnu_subprog_type),\n+\t\t\t\t\t   0, -1, gnat_node);\n+\t\t    else\n+\t\t      gnu_ret_val\n+\t\t\t= build_allocator (TREE_TYPE (gnu_ret_val),\n+\t\t\t\t\t   gnu_ret_val,\n+\t\t\t\t\t   TREE_TYPE (gnu_subprog_type),\n+\t\t\t\t\t   Procedure_To_Call (gnat_node),\n+\t\t\t\t\t   Storage_Pool (gnat_node),\n+\t\t\t\t\t   gnat_node);\n+\t\t  }\n+\t      }\n+\n+\t    gnu_result = build2 (MODIFY_EXPR, TREE_TYPE (gnu_ret_val),\n+\t\t\t\t gnu_lhs, gnu_ret_val);\n+\t    if (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type))\n+\t      {\n+\t\tadd_stmt_with_node (gnu_result, gnat_node);\n+\t\tgnu_ret_val = NULL_TREE;\n \t      }\n \t  }\n \n \tgnu_result =  build1 (RETURN_EXPR, void_type_node,\n-\t\t\t      (gnu_ret_val\n-\t\t\t       ? build (MODIFY_EXPR, TREE_TYPE (gnu_ret_val),\n-\t\t\t\t\tDECL_RESULT (current_function_decl),\n-\t\t\t\t\tgnu_ret_val)\n-\t\t\t       : NULL_TREE));\n+\t\t\t      gnu_ret_val ? gnu_result : gnu_ret_val);\n       }\n       break;\n \n@@ -3584,7 +3664,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Function_Call:\n     case N_Procedure_Call_Statement:\n-      gnu_result = call_to_gnu (gnat_node, &gnu_result_type);\n+      gnu_result = call_to_gnu (gnat_node, &gnu_result_type, NULL_TREE);\n       break;\n \n     /*************************/\n@@ -3788,9 +3868,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t  gnu_input_list = nreverse (gnu_input_list);\n \t  gnu_output_list = nreverse (gnu_output_list);\n-\t  gnu_result = build (ASM_EXPR,  void_type_node,\n-\t\t\t      gnu_template, gnu_output_list,\n-\t\t\t      gnu_input_list, gnu_clobber_list);\n+\t  gnu_result = build4 (ASM_EXPR,  void_type_node,\n+\t\t\t       gnu_template, gnu_output_list,\n+\t\t\t       gnu_input_list, gnu_clobber_list);\n \t  ASM_VOLATILE_P (gnu_result) = Is_Asm_Volatile (gnat_node);\n \t}\n       else\n@@ -3889,9 +3969,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  annotate_with_node (gnu_result, gnat_node);\n \n \t  if (Present (Condition (gnat_node)))\n-\t    gnu_result = build (COND_EXPR, void_type_node,\n-\t\t\t\tgnat_to_gnu (Condition (gnat_node)),\n-\t\t\t\tgnu_result, alloc_stmt_list ());\n+\t    gnu_result = build3 (COND_EXPR, void_type_node,\n+\t\t\t\t gnat_to_gnu (Condition (gnat_node)),\n+\t\t\t\t gnu_result, alloc_stmt_list ());\n \t}\n       else\n \tgnu_result = build1 (NULL_EXPR, gnu_result_type, gnu_result);\n@@ -4079,7 +4159,7 @@ gnat_to_gnu (Node_Id gnat_node)\n static void\n record_code_position (Node_Id gnat_node)\n {\n-  tree stmt_stmt = build (STMT_STMT, void_type_node, NULL_TREE);\n+  tree stmt_stmt = build1 (STMT_STMT, void_type_node, NULL_TREE);\n \n   add_stmt_with_node (stmt_stmt, gnat_node);\n   save_gnu_tree (gnat_node, stmt_stmt, true);\n@@ -4157,7 +4237,7 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n      this decl since we already have evaluated the expressions in the\n      sizes and positions as globals and doing it again would be wrong.\n      But we do have to mark everything as used.  */\n-  gnu_stmt = build (DECL_EXPR, void_type_node, gnu_decl);\n+  gnu_stmt = build1 (DECL_EXPR, void_type_node, gnu_decl);\n   if (!global_bindings_p ())\n     add_stmt_with_node (gnu_stmt, gnat_entity);\n   else\n@@ -4276,12 +4356,12 @@ end_stmt_group ()\n     gnu_retval = alloc_stmt_list ();\n \n   if (group->cleanups)\n-    gnu_retval = build (TRY_FINALLY_EXPR, void_type_node, gnu_retval,\n-\t\t\tgroup->cleanups);\n+    gnu_retval = build2 (TRY_FINALLY_EXPR, void_type_node, gnu_retval,\n+\t\t\t group->cleanups);\n \n   if (current_stmt_group->block)\n-    gnu_retval = build (BIND_EXPR, void_type_node, BLOCK_VARS (group->block),\n-\t\t\tgnu_retval, group->block);\n+    gnu_retval = build3 (BIND_EXPR, void_type_node, BLOCK_VARS (group->block),\n+\t\t\t gnu_retval, group->block);\n \n   /* Remove this group from the stack and add it to the free list.  */\n   current_stmt_group = group->previous;\n@@ -4418,10 +4498,33 @@ gnat_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n       *expr_p = TREE_OPERAND (*expr_p, 0);\n       return GS_OK;\n \n+    case ADDR_EXPR:\n+      /* If we're taking the address of a constant CONSTRUCTOR, force it to\n+\t be put into static memory.  We know it's going to be readonly given\n+\t the semantics we have and it's required to be static memory in\n+\t the case when the reference is in an elaboration procedure.  */\n+      if (TREE_CODE (TREE_OPERAND (expr, 0)) == CONSTRUCTOR\n+\t  && TREE_CONSTANT (TREE_OPERAND (expr, 0)))\n+\t{\n+\t  tree new_var\n+\t    = create_tmp_var (TREE_TYPE (TREE_OPERAND (expr, 0)), \"C\");\n+\n+\t  TREE_READONLY (new_var) = 1;\n+\t  TREE_STATIC (new_var) = 1;\n+\t  TREE_ADDRESSABLE (new_var) = 1;\n+\n+\t  gimplify_and_add (build2 (MODIFY_EXPR, TREE_TYPE (new_var),\n+\t\t\t\t    new_var, TREE_OPERAND (expr, 0)),\n+\t\t\t    pre_p);\n+\n+\t  TREE_OPERAND (expr, 0) = new_var;\n+\t  return GS_ALL_DONE;\n+\t}\n+      return GS_UNHANDLED;\n+\t \n     case COMPONENT_REF:\n-      /* We have a kludge here.  If the FIELD_DECL is from a fat pointer\n-\t and is from an early dummy type, replace it with the proper\n-\t FIELD_DECL.  */\n+      /* We have a kludge here.  If the FIELD_DECL is from a fat pointer and is\n+\t from an early dummy type, replace it with the proper FIELD_DECL.  */\n       if (TYPE_FAT_POINTER_P (TREE_TYPE (TREE_OPERAND (*expr_p, 0)))\n \t  && DECL_ORIGINAL_FIELD (TREE_OPERAND (*expr_p, 1)))\n \t{\n@@ -4472,23 +4575,23 @@ gnat_gimplify_stmt (tree *stmt_p)\n \t\t\t\t  stmt_p);\n \n \tif (LOOP_STMT_TOP_COND (stmt))\n-\t  append_to_statement_list (build (COND_EXPR, void_type_node,\n-\t\t\t\t\t   LOOP_STMT_TOP_COND (stmt),\n-\t\t\t\t\t   alloc_stmt_list (),\n-\t\t\t\t\t   build1 (GOTO_EXPR,\n-\t\t\t\t\t\t   void_type_node,\n-\t\t\t\t\t\t   gnu_end_label)),\n+\t  append_to_statement_list (build3 (COND_EXPR, void_type_node,\n+\t\t\t\t\t    LOOP_STMT_TOP_COND (stmt),\n+\t\t\t\t\t    alloc_stmt_list (),\n+\t\t\t\t\t    build1 (GOTO_EXPR,\n+\t\t\t\t\t\t    void_type_node,\n+\t\t\t\t\t\t    gnu_end_label)),\n \t\t\t\t    stmt_p);\n \n \tappend_to_statement_list (LOOP_STMT_BODY (stmt), stmt_p);\n \n \tif (LOOP_STMT_BOT_COND (stmt))\n-\t  append_to_statement_list (build (COND_EXPR, void_type_node,\n-\t\t\t\t\t   LOOP_STMT_BOT_COND (stmt),\n-\t\t\t\t\t   alloc_stmt_list (),\n-\t\t\t\t\t   build1 (GOTO_EXPR,\n-\t\t\t\t\t\t   void_type_node,\n-\t\t\t\t\t\t   gnu_end_label)),\n+\t  append_to_statement_list (build3 (COND_EXPR, void_type_node,\n+\t\t\t\t\t    LOOP_STMT_BOT_COND (stmt),\n+\t\t\t\t\t    alloc_stmt_list (),\n+\t\t\t\t\t    build1 (GOTO_EXPR,\n+\t\t\t\t\t\t    void_type_node,\n+\t\t\t\t\t\t    gnu_end_label)),\n \t\t\t\t    stmt_p);\n \n \tif (LOOP_STMT_UPDATE (stmt))\n@@ -4508,8 +4611,8 @@ gnat_gimplify_stmt (tree *stmt_p)\n \t see if it needs to be conditional.  */\n       *stmt_p = build1 (GOTO_EXPR, void_type_node, EXIT_STMT_LABEL (stmt));\n       if (EXIT_STMT_COND (stmt))\n-\t*stmt_p = build (COND_EXPR, void_type_node,\n-\t\t\t EXIT_STMT_COND (stmt), *stmt_p, alloc_stmt_list ());\n+\t*stmt_p = build3 (COND_EXPR, void_type_node,\n+\t\t\t  EXIT_STMT_COND (stmt), *stmt_p, alloc_stmt_list ());\n       return GS_OK;\n \n     default:\n@@ -4974,17 +5077,17 @@ emit_check (tree gnu_cond, tree gnu_expr, int reason)\n      in front of the comparison in case it ends up being a SAVE_EXPR.  Put the\n      whole thing inside its own SAVE_EXPR so the inner SAVE_EXPR doesn't leak\n      out.  */\n-  gnu_result = fold (build (COND_EXPR, TREE_TYPE (gnu_expr), gnu_cond,\n-\t\t\t    build (COMPOUND_EXPR, TREE_TYPE (gnu_expr),\n-\t\t\t\t   gnu_call, gnu_expr),\n-\t\t\t    gnu_expr));\n+  gnu_result = fold (build3 (COND_EXPR, TREE_TYPE (gnu_expr), gnu_cond,\n+\t\t\t     build2 (COMPOUND_EXPR, TREE_TYPE (gnu_expr),\n+\t\t\t\t     gnu_call, gnu_expr),\n+\t\t\t     gnu_expr));\n \n   /* If GNU_EXPR has side effects, make the outer COMPOUND_EXPR and\n      protect it.  Otherwise, show GNU_RESULT has no side effects: we\n      don't need to evaluate it just for the check.  */\n   if (TREE_SIDE_EFFECTS (gnu_expr))\n     gnu_result\n-      = build (COMPOUND_EXPR, TREE_TYPE (gnu_expr), gnu_expr, gnu_result);\n+      = build2 (COMPOUND_EXPR, TREE_TYPE (gnu_expr), gnu_expr, gnu_result);\n   else\n     TREE_SIDE_EFFECTS (gnu_result) = 0;\n \n@@ -5107,13 +5210,13 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n       tree gnu_minus_point_5 = build_real (gnu_in_basetype, dconstmp5);\n       tree gnu_zero = convert (gnu_in_basetype, integer_zero_node);\n       tree gnu_saved_result = save_expr (gnu_result);\n-      tree gnu_comp = build (GE_EXPR, integer_type_node,\n-\t\t\t     gnu_saved_result, gnu_zero);\n-      tree gnu_adjust = build (COND_EXPR, gnu_in_basetype, gnu_comp,\n-\t\t\t       gnu_point_5, gnu_minus_point_5);\n+      tree gnu_comp = build2 (GE_EXPR, integer_type_node,\n+\t\t\t      gnu_saved_result, gnu_zero);\n+      tree gnu_adjust = build3 (COND_EXPR, gnu_in_basetype, gnu_comp,\n+\t\t\t\tgnu_point_5, gnu_minus_point_5);\n \n       gnu_result\n-\t= build (PLUS_EXPR, gnu_in_basetype, gnu_saved_result, gnu_adjust);\n+\t= build2 (PLUS_EXPR, gnu_in_basetype, gnu_saved_result, gnu_adjust);\n     }\n \n   if (TREE_CODE (gnu_ada_base_type) == INTEGER_TYPE\n@@ -5531,36 +5634,36 @@ gnat_stabilize_reference (tree ref, bool force)\n       break;\n \n     case COMPONENT_REF:\n-      result = build (COMPONENT_REF, type,\n-\t\t      gnat_stabilize_reference (TREE_OPERAND (ref, 0),\n-\t\t\t\t\t\tforce),\n-\t\t      TREE_OPERAND (ref, 1), NULL_TREE);\n+      result = build3 (COMPONENT_REF, type,\n+\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 0),\n+\t\t\t\t\t\t force),\n+\t\t       TREE_OPERAND (ref, 1), NULL_TREE);\n       break;\n \n     case BIT_FIELD_REF:\n-      result = build (BIT_FIELD_REF, type,\n-\t\t      gnat_stabilize_reference (TREE_OPERAND (ref, 0), force),\n-\t\t      gnat_stabilize_reference_1 (TREE_OPERAND (ref, 1),\n-\t\t\t\t\t\t     force),\n-\t\t      gnat_stabilize_reference_1 (TREE_OPERAND (ref, 2),\n-\t\t\t\t\t\t  force));\n+      result = build3 (BIT_FIELD_REF, type,\n+\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 0), force),\n+\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 1),\n+\t\t\t\t\t\t   force),\n+\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 2),\n+\t\t\t\t\t\t   force));\n       break;\n \n     case ARRAY_REF:\n     case ARRAY_RANGE_REF:\n-      result = build (code, type,\n-\t\t      gnat_stabilize_reference (TREE_OPERAND (ref, 0), force),\n-\t\t      gnat_stabilize_reference_1 (TREE_OPERAND (ref, 1),\n-\t\t\t\t\t\t  force),\n-\t\t      NULL_TREE, NULL_TREE);\n+      result = build4 (code, type,\n+\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 0), force),\n+\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 1),\n+\t\t\t\t\t\t   force),\n+\t\t       NULL_TREE, NULL_TREE);\n       break;\n \n     case COMPOUND_EXPR:\n-      result = build (COMPOUND_EXPR, type,\n-\t\t      gnat_stabilize_reference_1 (TREE_OPERAND (ref, 0),\n-\t\t\t\t\t\t  force),\n-\t\t      gnat_stabilize_reference (TREE_OPERAND (ref, 1),\n-\t\t\t\t\t\tforce));\n+      result = build2 (COMPOUND_EXPR, type,\n+\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 0),\n+\t\t\t\t\t\t   force),\n+\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 1),\n+\t\t\t\t\t\t force));\n       break;\n \n       /* If arg isn't a kind of lvalue we recognize, make no change.\n@@ -5621,10 +5724,10 @@ gnat_stabilize_reference_1 (tree e, bool force)\n \t us to more easily find the match for the PLACEHOLDER_EXPR.  */\n       if (code == COMPONENT_REF\n \t  && TYPE_FAT_POINTER_P (TREE_TYPE (TREE_OPERAND (e, 0))))\n-\tresult = build (COMPONENT_REF, type,\n-\t\t\tgnat_stabilize_reference_1 (TREE_OPERAND (e, 0),\n-\t\t\t\t\t\t    force),\n-\t\t\tTREE_OPERAND (e, 1), TREE_OPERAND (e, 2));\n+\tresult = build3 (COMPONENT_REF, type,\n+\t\t\t gnat_stabilize_reference_1 (TREE_OPERAND (e, 0),\n+\t\t\t\t\t\t     force),\n+\t\t\t TREE_OPERAND (e, 1), TREE_OPERAND (e, 2));\n       else if (TREE_SIDE_EFFECTS (e) || force)\n \treturn save_expr (e);\n       else\n@@ -5638,9 +5741,10 @@ gnat_stabilize_reference_1 (tree e, bool force)\n \n     case '2':\n       /* Recursively stabilize each operand.  */\n-      result = build (code, type,\n-\t\t      gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), force),\n-\t\t      gnat_stabilize_reference_1 (TREE_OPERAND (e, 1), force));\n+      result = build2 (code, type,\n+\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), force),\n+\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (e, 1),\n+\t\t\t\t\t\t   force));\n       break;\n \n     case '1':"}, {"sha": "2b5bad74092f26a02df511742e141fb9a3d0c012", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 50, "deletions": 42, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -832,12 +832,13 @@ finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n \n \tcase QUAL_UNION_TYPE:\n \t  ada_size\n-\t    = fold (build (COND_EXPR, bitsizetype, DECL_QUALIFIER (field),\n-\t\t\t   this_ada_size, ada_size));\n-\t  size = fold (build (COND_EXPR, bitsizetype, DECL_QUALIFIER (field),\n-\t\t\t      this_size, size));\n-\t  size_unit = fold (build (COND_EXPR, sizetype, DECL_QUALIFIER (field),\n-\t\t\t\t   this_size_unit, size_unit));\n+\t    = fold (build3 (COND_EXPR, bitsizetype, DECL_QUALIFIER (field),\n+\t\t\t    this_ada_size, ada_size));\n+\t  size = fold (build3 (COND_EXPR, bitsizetype, DECL_QUALIFIER (field),\n+\t\t\t       this_size, size));\n+\t  size_unit = fold (build3 (COND_EXPR, sizetype,\n+\t\t\t\t    DECL_QUALIFIER (field),\n+\t\t\t\t    this_size_unit, size_unit));\n \t  break;\n \n \tcase RECORD_TYPE:\n@@ -1073,15 +1074,15 @@ merge_sizes (tree last_size, tree first_bit, tree size, bool special,\n     }\n \n   else\n-    new = fold (build (COND_EXPR, type, TREE_OPERAND (size, 0),\n-\t\t       integer_zerop (TREE_OPERAND (size, 1))\n-\t\t       ? last_size : merge_sizes (last_size, first_bit,\n-\t\t\t\t\t\t  TREE_OPERAND (size, 1),\n-\t\t\t\t\t\t  1, has_rep),\n-\t\t       integer_zerop (TREE_OPERAND (size, 2))\n-\t\t      ? last_size : merge_sizes (last_size, first_bit,\n-\t\t\t\t\t\t TREE_OPERAND (size, 2),\n-\t\t\t\t\t\t 1, has_rep)));\n+    new = fold (build3 (COND_EXPR, type, TREE_OPERAND (size, 0),\n+\t\t\tinteger_zerop (TREE_OPERAND (size, 1))\n+\t\t\t? last_size : merge_sizes (last_size, first_bit,\n+\t\t\t\t\t\t   TREE_OPERAND (size, 1),\n+\t\t\t\t\t\t   1, has_rep),\n+\t\t\tinteger_zerop (TREE_OPERAND (size, 2))\n+\t\t\t? last_size : merge_sizes (last_size, first_bit,\n+\t\t\t\t\t\t   TREE_OPERAND (size, 2),\n+\t\t\t\t\t\t   1, has_rep)));\n \n   /* We don't need any NON_VALUE_EXPRs and they can confuse us (especially\n      when fed through substitute_in_expr) into thinking that a constant\n@@ -1157,12 +1158,14 @@ split_plus (tree in, tree *pvar)\n    RETURNS_UNCONSTRAINED is nonzero if the function returns an unconstrained\n    object.  RETURNS_BY_REF is nonzero if the function returns by reference.\n    RETURNS_WITH_DSP is nonzero if the function is to return with a\n-   depressed stack pointer.  */\n+   depressed stack pointer.  RETURNS_BY_TARGET_PTR is true if the function\n+   is to be passed (as its first parameter) the address of the place to copy\n+   its result.  */\n \n tree\n create_subprog_type (tree return_type, tree param_decl_list, tree cico_list,\n                      bool returns_unconstrained, bool returns_by_ref,\n-                     bool returns_with_dsp)\n+                     bool returns_with_dsp, bool returns_by_target_ptr)\n {\n   /* A chain of TREE_LIST nodes whose TREE_VALUEs are the data type nodes of\n      the subprogram formal parameters. This list is generated by traversing the\n@@ -1193,13 +1196,15 @@ create_subprog_type (tree return_type, tree param_decl_list, tree cico_list,\n      RETURNS_UNCONSTRAINED and RETURNS_BY_REF.  */\n   if (TYPE_CI_CO_LIST (type) || cico_list\n       || TYPE_RETURNS_UNCONSTRAINED_P (type) != returns_unconstrained\n-      || TYPE_RETURNS_BY_REF_P (type) != returns_by_ref)\n+      || TYPE_RETURNS_BY_REF_P (type) != returns_by_ref\n+      || TYPE_RETURNS_BY_TARGET_PTR_P (type) != returns_by_target_ptr)\n     type = copy_type (type);\n \n   TYPE_CI_CO_LIST (type) = cico_list;\n   TYPE_RETURNS_UNCONSTRAINED_P (type) = returns_unconstrained;\n   TYPE_RETURNS_STACK_DEPRESSED (type) = returns_with_dsp;\n   TYPE_RETURNS_BY_REF_P (type) = returns_by_ref;\n+  TYPE_RETURNS_BY_TARGET_PTR_P (type) = returns_by_target_ptr;\n   return type;\n }\n \f\n@@ -1342,10 +1347,12 @@ create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n   TREE_THIS_VOLATILE (var_decl) = TREE_SIDE_EFFECTS (var_decl)\n     = TYPE_VOLATILE (type);\n \n-  /* At the global binding level we need to allocate static storage for the\n-     variable if and only if its not external. If we are not at the top level\n+  /* If it's public and not external, always allocate storage for it.\n+     At the global binding level we need to allocate static storage for the\n+     variable if and only if it's not external. If we are not at the top level\n      we allocate automatic storage unless requested not to.  */\n-  TREE_STATIC (var_decl) = global_bindings_p () ? !extern_flag : static_flag;\n+  TREE_STATIC (var_decl)\n+    = public_flag || (global_bindings_p () ? !extern_flag : static_flag);\n \n   if (asm_name)\n     SET_DECL_ASSEMBLER_NAME (var_decl, asm_name);\n@@ -2066,19 +2073,19 @@ max_size (tree exp, bool max_p)\n \t\t     && !TREE_CONSTANT (rhs))\n \t      return lhs;\n \t    else\n-\t      return fold (build (code, type, lhs, rhs));\n+\t      return fold (build2 (code, type, lhs, rhs));\n \t  }\n \n \tcase 3:\n \t  if (code == SAVE_EXPR)\n \t    return exp;\n \t  else if (code == COND_EXPR)\n-\t    return fold (build (max_p ? MAX_EXPR : MIN_EXPR, type,\n-\t\t\t\tmax_size (TREE_OPERAND (exp, 1), max_p),\n-\t\t\t\tmax_size (TREE_OPERAND (exp, 2), max_p)));\n+\t    return fold (build2 (max_p ? MAX_EXPR : MIN_EXPR, type,\n+\t\t\t\t max_size (TREE_OPERAND (exp, 1), max_p),\n+\t\t\t\t max_size (TREE_OPERAND (exp, 2), max_p)));\n \t  else if (code == CALL_EXPR && TREE_OPERAND (exp, 1))\n-\t    return build (CALL_EXPR, type, TREE_OPERAND (exp, 0),\n-\t\t\t  max_size (TREE_OPERAND (exp, 1), max_p), NULL);\n+\t    return build3 (CALL_EXPR, type, TREE_OPERAND (exp, 0),\n+\t\t\t   max_size (TREE_OPERAND (exp, 1), max_p), NULL);\n \t}\n     }\n \n@@ -2307,7 +2314,7 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n \t\tbuild_pointer_type_for_mode (type, SImode, false), record_type,\n \t\tbuild1 (ADDR_EXPR,\n \t\t\tbuild_pointer_type_for_mode (type, SImode, false),\n-\t\t\tbuild (PLACEHOLDER_EXPR, type))));\n+\t\t\tbuild0 (PLACEHOLDER_EXPR, type))));\n \n   switch (mech)\n     {\n@@ -2368,12 +2375,12 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n \t\t\t\t\t\t   size_in_bytes (type)));\n \n       /* Now build a pointer to the 0,0,0... element.  */\n-      tem = build (PLACEHOLDER_EXPR, type);\n+      tem = build0 (PLACEHOLDER_EXPR, type);\n       for (i = 0, inner_type = type; i < ndim;\n \t   i++, inner_type = TREE_TYPE (inner_type))\n-\ttem = build (ARRAY_REF, TREE_TYPE (inner_type), tem,\n-\t\t     convert (TYPE_DOMAIN (inner_type), size_zero_node),\n-\t\t     NULL_TREE, NULL_TREE);\n+\ttem = build4 (ARRAY_REF, TREE_TYPE (inner_type), tem,\n+\t\t      convert (TYPE_DOMAIN (inner_type), size_zero_node),\n+\t\t      NULL_TREE, NULL_TREE);\n \n       field_list\n \t= chainon (field_list,\n@@ -2596,9 +2603,9 @@ update_pointer_to (tree old_type, tree new_type)\n \t is now a very \"heavy\" routine to do this, so it should be replaced\n \t at some point.  */\n       ptr_temp_type = TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (ptr)));\n-      new_ref = build (COMPONENT_REF, ptr_temp_type,\n-\t\t       build (PLACEHOLDER_EXPR, ptr),\n-\t\t       TREE_CHAIN (TYPE_FIELDS (ptr)), NULL_TREE);\n+      new_ref = build3 (COMPONENT_REF, ptr_temp_type,\n+\t\t\tbuild0 (PLACEHOLDER_EXPR, ptr),\n+\t\t\tTREE_CHAIN (TYPE_FIELDS (ptr)), NULL_TREE);\n \n       update_pointer_to\n \t(TREE_TYPE (TREE_TYPE (TYPE_FIELDS (ptr))),\n@@ -2801,10 +2808,11 @@ convert (tree type, tree expr)\n \n   /* If the input is a biased type, adjust first.  */\n   if (ecode == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (etype))\n-    return convert (type, fold (build (PLUS_EXPR, TREE_TYPE (etype),\n-\t\t\t\t       fold (build1 (NOP_EXPR,\n-\t\t\t\t\t\t     TREE_TYPE (etype), expr)),\n-\t\t\t\t       TYPE_MIN_VALUE (etype))));\n+    return convert (type, fold (build2 (PLUS_EXPR, TREE_TYPE (etype),\n+\t\t\t\t\tfold (build1 (NOP_EXPR,\n+\t\t\t\t\t\t      TREE_TYPE (etype),\n+\t\t\t\t\t\t      expr)),\n+\t\t\t\t\tTYPE_MIN_VALUE (etype))));\n \n   /* If the input is a left-justified modular type, we need to extract\n      the actual object before converting it to any other type with the\n@@ -2936,9 +2944,9 @@ convert (tree type, tree expr)\n \treturn unchecked_convert (type, expr, false);\n       else if (TYPE_BIASED_REPRESENTATION_P (type))\n \treturn fold (build1 (CONVERT_EXPR, type,\n-\t\t\t     fold (build (MINUS_EXPR, TREE_TYPE (type),\n-\t\t\t\t\t  convert (TREE_TYPE (type), expr),\n-\t\t\t\t\t  TYPE_MIN_VALUE (type)))));\n+\t\t\t     fold (build2 (MINUS_EXPR, TREE_TYPE (type),\n+\t\t\t\t\t   convert (TREE_TYPE (type), expr),\n+\t\t\t\t\t   TYPE_MIN_VALUE (type)))));\n \n       /* ... fall through ... */\n "}, {"sha": "6341863f0614ec028a9075086f2d477ba92e6cdc", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 108, "deletions": 107, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c885d7a17a4fa12b015adde15326b13303c348bd/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=c885d7a17a4fa12b015adde15326b13303c348bd", "patch": "@@ -96,9 +96,9 @@ gnat_truthvalue_conversion (tree expr)\n     case COND_EXPR:\n       /* Distribute the conversion into the arms of a COND_EXPR.  */\n       return fold\n-\t(build (COND_EXPR, type, TREE_OPERAND (expr, 0),\n-\t\tgnat_truthvalue_conversion (TREE_OPERAND (expr, 1)),\n-\t\tgnat_truthvalue_conversion (TREE_OPERAND (expr, 2))));\n+\t(build3 (COND_EXPR, type, TREE_OPERAND (expr, 0),\n+\t\t gnat_truthvalue_conversion (TREE_OPERAND (expr, 1)),\n+\t\t gnat_truthvalue_conversion (TREE_OPERAND (expr, 2))));\n \n     default:\n       return build_binary_op (NE_EXPR, type, expr,\n@@ -355,8 +355,8 @@ compare_arrays (tree result_type, tree a1, tree a2)\n       tree lb2 = TYPE_MIN_VALUE (TYPE_DOMAIN (t2));\n       tree ub2 = TYPE_MAX_VALUE (TYPE_DOMAIN (t2));\n       tree bt = get_base_type (TREE_TYPE (lb1));\n-      tree length1 = fold (build (MINUS_EXPR, bt, ub1, lb1));\n-      tree length2 = fold (build (MINUS_EXPR, bt, ub2, lb2));\n+      tree length1 = fold (build2 (MINUS_EXPR, bt, ub1, lb1));\n+      tree length2 = fold (build2 (MINUS_EXPR, bt, ub2, lb2));\n       tree nbt;\n       tree tem;\n       tree comparison, this_a1_is_null, this_a2_is_null;\n@@ -365,8 +365,8 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t unless the length of the second array is the constant zero.\n \t Note that we have set the `length' values to the length - 1.  */\n       if (TREE_CODE (length1) == INTEGER_CST\n-\t  && !integer_zerop (fold (build (PLUS_EXPR, bt, length2,\n-\t\t\t\t\t  convert (bt, integer_one_node)))))\n+\t  && !integer_zerop (fold (build2 (PLUS_EXPR, bt, length2,\n+\t\t\t\t\t   convert (bt, integer_one_node)))))\n \t{\n \t  tem = a1, a1 = a2, a2 = tem;\n \t  tem = t1, t1 = t2, t2 = tem;\n@@ -379,8 +379,8 @@ compare_arrays (tree result_type, tree a1, tree a2)\n       /* If the length of this dimension in the second array is the constant\n \t zero, we can just go inside the original bounds for the first\n \t array and see if last < first.  */\n-      if (integer_zerop (fold (build (PLUS_EXPR, bt, length2,\n-\t\t\t\t      convert (bt, integer_one_node)))))\n+      if (integer_zerop (fold (build2 (PLUS_EXPR, bt, length2,\n+\t\t\t\t       convert (bt, integer_one_node)))))\n \t{\n \t  tree ub = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n \t  tree lb = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n@@ -459,7 +459,7 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \ta1 = convert (type, a1), a2 = convert (type, a2);\n \n       result = build_binary_op (TRUTH_ANDIF_EXPR, result_type, result,\n-\t\t\t\tfold (build (EQ_EXPR, result_type, a1, a2)));\n+\t\t\t\tfold (build2 (EQ_EXPR, result_type, a1, a2)));\n \n     }\n \n@@ -474,10 +474,10 @@ compare_arrays (tree result_type, tree a1, tree a2)\n      evaluated would be wrong.  */\n \n   if (contains_save_expr_p (a1))\n-    result = build (COMPOUND_EXPR, result_type, a1, result);\n+    result = build2 (COMPOUND_EXPR, result_type, a1, result);\n \n   if (contains_save_expr_p (a2))\n-    result = build (COMPOUND_EXPR, result_type, a2, result);\n+    result = build2 (COMPOUND_EXPR, result_type, a2, result);\n \n   return result;\n }\n@@ -500,7 +500,7 @@ nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n   /* If this is an addition of a constant, convert it to a subtraction\n      of a constant since we can do that faster.  */\n   if (op_code == PLUS_EXPR && TREE_CODE (rhs) == INTEGER_CST)\n-    rhs = fold (build (MINUS_EXPR, type, modulus, rhs)), op_code = MINUS_EXPR;\n+    rhs = fold (build2 (MINUS_EXPR, type, modulus, rhs)), op_code = MINUS_EXPR;\n \n   /* For the logical operations, we only need PRECISION bits.  For\n      addition and subraction, we need one more and for multiplication we\n@@ -532,7 +532,7 @@ nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n     }\n \n   /* Do the operation, then we'll fix it up.  */\n-  result = fold (build (op_code, op_type, lhs, rhs));\n+  result = fold (build2 (op_code, op_type, lhs, rhs));\n \n   /* For multiplication, we have no choice but to do a full modulus\n      operation.  However, we want to do this in the narrowest\n@@ -544,32 +544,32 @@ nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n       SET_TYPE_MODULUS (div_type, modulus);\n       TYPE_MODULAR_P (div_type) = 1;\n       result = convert (op_type,\n-\t\t\tfold (build (TRUNC_MOD_EXPR, div_type,\n-\t\t\t\t     convert (div_type, result), modulus)));\n+\t\t\tfold (build2 (TRUNC_MOD_EXPR, div_type,\n+\t\t\t\t      convert (div_type, result), modulus)));\n     }\n \n   /* For subtraction, add the modulus back if we are negative.  */\n   else if (op_code == MINUS_EXPR)\n     {\n       result = save_expr (result);\n-      result = fold (build (COND_EXPR, op_type,\n-\t\t\t    build (LT_EXPR, integer_type_node, result,\n-\t\t\t\t   convert (op_type, integer_zero_node)),\n-\t\t\t    fold (build (PLUS_EXPR, op_type,\n-\t\t\t\t\t result, modulus)),\n-\t\t\t    result));\n+      result = fold (build3 (COND_EXPR, op_type,\n+\t\t\t     build2 (LT_EXPR, integer_type_node, result,\n+\t\t\t\t     convert (op_type, integer_zero_node)),\n+\t\t\t     fold (build2 (PLUS_EXPR, op_type,\n+\t\t\t\t\t   result, modulus)),\n+\t\t\t     result));\n     }\n \n   /* For the other operations, subtract the modulus if we are >= it.  */\n   else\n     {\n       result = save_expr (result);\n-      result = fold (build (COND_EXPR, op_type,\n-\t\t\t    build (GE_EXPR, integer_type_node,\n-\t\t\t\t   result, modulus),\n-\t\t\t    fold (build (MINUS_EXPR, op_type,\n-\t\t\t\t\t result, modulus)),\n-\t\t\t    result));\n+      result = fold (build3 (COND_EXPR, op_type,\n+\t\t\t     build2 (GE_EXPR, integer_type_node,\n+\t\t\t\t     result, modulus),\n+\t\t\t     fold (build2 (MINUS_EXPR, op_type,\n+\t\t\t\t\t   result, modulus)),\n+\t\t\t     result));\n     }\n \n   return convert (type, result);\n@@ -791,16 +791,16 @@ build_binary_op (enum tree_code op_code, tree result_type,\n     case NE_EXPR:\n       /* If either operand is a NULL_EXPR, just return a new one.  */\n       if (TREE_CODE (left_operand) == NULL_EXPR)\n-\treturn build (op_code, result_type,\n-\t\t      build1 (NULL_EXPR, integer_type_node,\n-\t\t\t      TREE_OPERAND (left_operand, 0)),\n-\t\t      integer_zero_node);\n+\treturn build2 (op_code, result_type,\n+\t\t       build1 (NULL_EXPR, integer_type_node,\n+\t\t\t       TREE_OPERAND (left_operand, 0)),\n+\t\t       integer_zero_node);\n \n       else if (TREE_CODE (right_operand) == NULL_EXPR)\n-\treturn build (op_code, result_type,\n-\t\t      build1 (NULL_EXPR, integer_type_node,\n-\t\t\t      TREE_OPERAND (right_operand, 0)),\n-\t\t      integer_zero_node);\n+\treturn build2 (op_code, result_type,\n+\t\t       build1 (NULL_EXPR, integer_type_node,\n+\t\t\t       TREE_OPERAND (right_operand, 0)),\n+\t\t       integer_zero_node);\n \n       /* If either object is a left-justified modular types, get the\n \t fields from within.  */\n@@ -998,11 +998,11 @@ build_binary_op (enum tree_code op_code, tree result_type,\n   else if (TREE_CODE (right_operand) == NULL_EXPR)\n     return build1 (NULL_EXPR, operation_type, TREE_OPERAND (right_operand, 0));\n   else if (op_code == ARRAY_REF || op_code == ARRAY_RANGE_REF)\n-    result = fold (build (op_code, operation_type, left_operand, right_operand,\n-\t\t\t  NULL_TREE, NULL_TREE));\n+    result = fold (build4 (op_code, operation_type, left_operand,\n+\t\t\t   right_operand, NULL_TREE, NULL_TREE));\n   else\n     result\n-      = fold (build (op_code, operation_type, left_operand, right_operand));\n+      = fold (build2 (op_code, operation_type, left_operand, right_operand));\n \n   TREE_SIDE_EFFECTS (result) |= has_side_effects;\n   TREE_CONSTANT (result)\n@@ -1016,8 +1016,8 @@ build_binary_op (enum tree_code op_code, tree result_type,\n   /* If we are working with modular types, perform the MOD operation\n      if something above hasn't eliminated the need for it.  */\n   if (modulus)\n-    result = fold (build (FLOOR_MOD_EXPR, operation_type, result,\n-\t\t\t  convert (operation_type, modulus)));\n+    result = fold (build2 (FLOOR_MOD_EXPR, operation_type, result,\n+\t\t\t   convert (operation_type, modulus)));\n \n   if (result_type && result_type != operation_type)\n     result = convert (result_type, result);\n@@ -1260,33 +1260,35 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t       the straightforward code; the TRUNC_MOD_EXPR below\n \t       is an AND operation.  */\n \t    if (op_code == NEGATE_EXPR && mod_pow2)\n-\t      result = fold (build (TRUNC_MOD_EXPR, operation_type,\n-\t\t\t\t    fold (build1 (NEGATE_EXPR, operation_type,\n-\t\t\t\t\t\t  operand)),\n-\t\t\t\t    modulus));\n+\t      result = fold (build2 (TRUNC_MOD_EXPR, operation_type,\n+\t\t\t\t     fold (build1 (NEGATE_EXPR, operation_type,\n+\t\t\t\t\t\t   operand)),\n+\t\t\t\t     modulus));\n \n \t    /* For nonbinary negate case, return zero for zero operand,\n \t       else return the modulus minus the operand.  If the modulus\n \t       is a power of two minus one, we can do the subtraction\n \t       as an XOR since it is equivalent and faster on most machines. */\n \t    else if (op_code == NEGATE_EXPR && !mod_pow2)\n \t      {\n-\t\tif (integer_pow2p (fold (build (PLUS_EXPR, operation_type,\n-\t\t\t\t\t\tmodulus,\n-\t\t\t\t\t\tconvert (operation_type,\n-\t\t\t\t\t\t\t integer_one_node)))))\n-\t\t  result = fold (build (BIT_XOR_EXPR, operation_type,\n-\t\t\t\t\toperand, modulus));\n+\t\tif (integer_pow2p (fold (build2 (PLUS_EXPR, operation_type,\n+\t\t\t\t\t\t modulus,\n+\t\t\t\t\t\t convert (operation_type,\n+\t\t\t\t\t\t\t  integer_one_node)))))\n+\t\t  result = fold (build2 (BIT_XOR_EXPR, operation_type,\n+\t\t\t\t\t operand, modulus));\n \t\telse\n-\t\t  result = fold (build (MINUS_EXPR, operation_type,\n+\t\t  result = fold (build2 (MINUS_EXPR, operation_type,\n \t\t\t\t\tmodulus, operand));\n \n-\t\tresult = fold (build (COND_EXPR, operation_type,\n-\t\t\t\t      fold (build (NE_EXPR, integer_type_node,\n-\t\t\t\t\t\t   operand,\n-\t\t\t\t\t\t   convert (operation_type,\n-\t\t\t\t\t\t\t    integer_zero_node))),\n-\t\t\t\t      result, operand));\n+\t\tresult = fold (build3 (COND_EXPR, operation_type,\n+\t\t\t\t       fold (build2 (NE_EXPR,\n+\t\t\t\t\t\t     integer_type_node,\n+\t\t\t\t\t\t     operand,\n+\t\t\t\t\t\t     convert\n+\t\t\t\t\t\t     (operation_type,\n+\t\t\t\t\t\t      integer_zero_node))),\n+\t\t\t\t       result, operand));\n \t      }\n \t    else\n \t      {\n@@ -1295,16 +1297,16 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t\t   XOR against the constant and subtract the operand from\n \t\t   that constant for nonbinary modulus.  */\n \n-\t\ttree cnst = fold (build (MINUS_EXPR, operation_type, modulus,\n-\t\t\t\t\t convert (operation_type,\n-\t\t\t\t\t\t  integer_one_node)));\n+\t\ttree cnst = fold (build2 (MINUS_EXPR, operation_type, modulus,\n+\t\t\t\t\t  convert (operation_type,\n+\t\t\t\t\t\t   integer_one_node)));\n \n \t\tif (mod_pow2)\n-\t\t  result = fold (build (BIT_XOR_EXPR, operation_type,\n-\t\t\t\t\toperand, cnst));\n+\t\t  result = fold (build2 (BIT_XOR_EXPR, operation_type,\n+\t\t\t\t\t operand, cnst));\n \t\telse\n-\t\t  result = fold (build (MINUS_EXPR, operation_type,\n-\t\t\t\t\tcnst, operand));\n+\t\t  result = fold (build2 (MINUS_EXPR, operation_type,\n+\t\t\t\t\t cnst, operand));\n \t      }\n \n \t    break;\n@@ -1360,19 +1362,19 @@ build_cond_expr (tree result_type, tree condition_operand,\n       false_operand = build_unary_op (ADDR_EXPR, result_type, false_operand);\n     }\n \n-  result = fold (build (COND_EXPR, result_type, condition_operand,\n-\t\t\ttrue_operand, false_operand));\n+  result = fold (build3 (COND_EXPR, result_type, condition_operand,\n+\t\t\t true_operand, false_operand));\n \n   /* If either operand is a SAVE_EXPR (possibly surrounded by\n      arithmetic, make sure it gets done.  */\n   true_operand  = skip_simple_arithmetic (true_operand);\n   false_operand = skip_simple_arithmetic (false_operand);\n \n   if (TREE_CODE (true_operand) == SAVE_EXPR)\n-    result = build (COMPOUND_EXPR, result_type, true_operand, result);\n+    result = build2 (COMPOUND_EXPR, result_type, true_operand, result);\n \n   if (TREE_CODE (false_operand) == SAVE_EXPR)\n-    result = build (COMPOUND_EXPR, result_type, false_operand, result);\n+    result = build2 (COMPOUND_EXPR, result_type, false_operand, result);\n \n   /* ??? Seems the code above is wrong, as it may move ahead of the COND\n      SAVE_EXPRs with side effects and not shared by both arms.  */\n@@ -1390,10 +1392,10 @@ build_cond_expr (tree result_type, tree condition_operand,\n tree\n build_call_1_expr (tree fundecl, tree arg)\n {\n-  tree call = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fundecl)),\n-\t\t     build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n-\t\t     chainon (NULL_TREE, build_tree_list (NULL_TREE, arg)),\n-\t\t     NULL_TREE);\n+  tree call = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fundecl)),\n+\t\t      build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n+\t\t      chainon (NULL_TREE, build_tree_list (NULL_TREE, arg)),\n+\t\t      NULL_TREE);\n \n   TREE_SIDE_EFFECTS (call) = 1;\n \n@@ -1406,11 +1408,11 @@ build_call_1_expr (tree fundecl, tree arg)\n tree\n build_call_2_expr (tree fundecl, tree arg1, tree arg2)\n {\n-  tree call = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fundecl)),\n-\t\t     build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n-\t\t     chainon (chainon (NULL_TREE,\n-\t\t\t\t       build_tree_list (NULL_TREE, arg1)),\n-\t\t\t      build_tree_list (NULL_TREE, arg2)),\n+  tree call = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fundecl)),\n+\t\t      build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n+\t\t      chainon (chainon (NULL_TREE,\n+\t\t\t\t\tbuild_tree_list (NULL_TREE, arg1)),\n+\t\t\t       build_tree_list (NULL_TREE, arg2)),\n \t\t     NULL_TREE);\n \n   TREE_SIDE_EFFECTS (call) = 1;\n@@ -1423,9 +1425,9 @@ build_call_2_expr (tree fundecl, tree arg1, tree arg2)\n tree\n build_call_0_expr (tree fundecl)\n {\n-  tree call = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fundecl)),\n-\t\t     build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n-\t\t     NULL_TREE, NULL_TREE);\n+  tree call = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fundecl)),\n+\t\t      build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n+\t\t      NULL_TREE, NULL_TREE);\n \n   TREE_SIDE_EFFECTS (call) = 1;\n \n@@ -1510,11 +1512,10 @@ gnat_build_constructor (tree type, tree list)\n     }\n \n   result = build_constructor (type, list);\n-  TREE_CONSTANT (result) = allconstant;\n-  TREE_STATIC (result) = allconstant;\n+  TREE_CONSTANT (result) = TREE_INVARIANT (result)\n+    = TREE_STATIC (result) = allconstant;\n   TREE_SIDE_EFFECTS (result) = side_effects;\n-  TREE_READONLY (result) = TYPE_READONLY (type);\n-\n+  TREE_READONLY (result) = TYPE_READONLY (type) || allconstant;\n   return result;\n }\n \f\n@@ -1596,8 +1597,8 @@ build_simple_component_ref (tree record_variable, tree component,\n \n   /* It would be nice to call \"fold\" here, but that can lose a type\n      we need to tag a PLACEHOLDER_EXPR with, so we can't do it.  */\n-  ref = build (COMPONENT_REF, TREE_TYPE (field), record_variable, field,\n-\t       NULL_TREE);\n+  ref = build3 (COMPONENT_REF, TREE_TYPE (field), record_variable, field,\n+\t\tNULL_TREE);\n \n   if (TREE_READONLY (record_variable) || TREE_READONLY (field))\n     TREE_READONLY (ref) = 1;\n@@ -1688,8 +1689,8 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n \t\t       build_tree_list (NULL_TREE,\n \t\t\t\t\tconvert (gnu_size_type, gnu_align)));\n \n-\t  gnu_call = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (gnu_proc)),\n-\t\t\t    gnu_proc_addr, gnu_args, NULL_TREE);\n+\t  gnu_call = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (gnu_proc)),\n+\t\t\t     gnu_proc_addr, gnu_args, NULL_TREE);\n \t  TREE_SIDE_EFFECTS (gnu_call) = 1;\n \t  return gnu_call;\n \t}\n@@ -1717,8 +1718,8 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n \t\t       build_tree_list (NULL_TREE,\n \t\t\t\t\tconvert (gnu_size_type, gnu_size)));\n \n-\t  gnu_call = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (gnu_proc)),\n-\t\t\t    gnu_proc_addr, gnu_args, NULL_TREE);\n+\t  gnu_call = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (gnu_proc)),\n+\t\t\t     gnu_proc_addr, gnu_args, NULL_TREE);\n \t  TREE_SIDE_EFFECTS (gnu_call) = 1;\n \t  return gnu_call;\n \t}\n@@ -1750,7 +1751,7 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n       else\n \tabort ();\n #if 0\n-\treturn build (ALLOCATE_EXPR, ptr_void_type_node, gnu_size, gnu_align);\n+\treturn build2 (ALLOCATE_EXPR, ptr_void_type_node, gnu_size, gnu_align);\n #endif\n     }\n   else\n@@ -1830,16 +1831,16 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \n \t  return convert\n \t    (result_type,\n-\t     build (COMPOUND_EXPR, storage_ptr_type,\n-\t\t    build_binary_op\n-\t\t    (MODIFY_EXPR, storage_type,\n-\t\t     build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t\t     convert (storage_ptr_type, storage)),\n-\t\t     gnat_build_constructor (storage_type, template_cons)),\n-\t\t    convert (storage_ptr_type, storage)));\n+\t     build2 (COMPOUND_EXPR, storage_ptr_type,\n+\t\t     build_binary_op\n+\t\t     (MODIFY_EXPR, storage_type,\n+\t\t      build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t\t      convert (storage_ptr_type, storage)),\n+\t\t      gnat_build_constructor (storage_type, template_cons)),\n+\t\t     convert (storage_ptr_type, storage)));\n \t}\n       else\n-\treturn build\n+\treturn build2\n \t  (COMPOUND_EXPR, result_type,\n \t   build_binary_op\n \t   (MODIFY_EXPR, template_type,\n@@ -1910,13 +1911,13 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n     {\n       result = save_expr (result);\n       result\n-\t= build (COMPOUND_EXPR, TREE_TYPE (result),\n-\t\t build_binary_op\n-\t\t (MODIFY_EXPR, NULL_TREE,\n-\t\t  build_unary_op (INDIRECT_REF, TREE_TYPE (TREE_TYPE (result)),\n-\t\t\t\t  result),\n-\t\t  init),\n-\t\t result);\n+\t= build2 (COMPOUND_EXPR, TREE_TYPE (result),\n+\t\t  build_binary_op\n+\t\t  (MODIFY_EXPR, NULL_TREE,\n+\t\t   build_unary_op (INDIRECT_REF,\n+\t\t\t\t   TREE_TYPE (TREE_TYPE (result)), result),\n+\t\t   init),\n+\t\t  result);\n     }\n \n   return convert (result_type, result);"}]}