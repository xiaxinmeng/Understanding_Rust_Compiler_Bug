{"sha": "805c33df1366e3f86fde31be556ca843ef1bac5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA1YzMzZGYxMzY2ZTNmODZmZGUzMWJlNTU2Y2E4NDNlZjFiYWM1YQ==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2004-09-29T01:42:09Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2004-09-29T01:42:09Z"}, "message": "extend.texi (Extended Asm): Add blurb about using Explicit Reg Vars to enforce register allocation with...\n\n\t* doc/extend.texi (Extended Asm): Add blurb about using Explicit\n\tReg Vars to enforce register allocation with general constraints.\n\t(Explicit Reg Vars): Clarify relation to asm statements.\n\t(Local Reg Vars): Similar.\n\nFrom-SVN: r88265", "tree": {"sha": "2393845f1419867b4d1a88d3294ec423b933bcc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2393845f1419867b4d1a88d3294ec423b933bcc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/805c33df1366e3f86fde31be556ca843ef1bac5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/805c33df1366e3f86fde31be556ca843ef1bac5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/805c33df1366e3f86fde31be556ca843ef1bac5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/805c33df1366e3f86fde31be556ca843ef1bac5a/comments", "author": null, "committer": null, "parents": [{"sha": "dcda848050bcb1460b394a99fdb6f4e4e4fd7cdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcda848050bcb1460b394a99fdb6f4e4e4fd7cdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcda848050bcb1460b394a99fdb6f4e4e4fd7cdd"}], "stats": {"total": 32, "additions": 29, "deletions": 3}, "files": [{"sha": "fed8724504535f4aa2e0e5854ae931af660d0480", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805c33df1366e3f86fde31be556ca843ef1bac5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805c33df1366e3f86fde31be556ca843ef1bac5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=805c33df1366e3f86fde31be556ca843ef1bac5a", "patch": "@@ -1,3 +1,10 @@\n+2004-09-29  Hans-Peter Nilsson  <hp@bitrange.com>\n+\n+\t* doc/extend.texi (Extended Asm): Add blurb about using Explicit\n+\tReg Vars to enforce register allocation with general constraints.\n+\t(Explicit Reg Vars): Clarify relation to asm statements.\n+\t(Local Reg Vars): Similar.\n+\n 2004-09-28  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* sched-rgn.c (haifa_edge, edge_table, NEXT_IN, NEXT_OUT, FROM_BLOCK,"}, {"sha": "713695083d244041768e80197bb899ec99c9a893", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805c33df1366e3f86fde31be556ca843ef1bac5a/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805c33df1366e3f86fde31be556ca843ef1bac5a/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=805c33df1366e3f86fde31be556ca843ef1bac5a", "patch": "@@ -3562,6 +3562,20 @@ asm (\"cmoveq %1,%2,%[result]\"\n      : \"r\" (test), \"r\"(new), \"[result]\"(old));\n @end smallexample\n \n+Sometimes you need to make an @code{asm} operand be a specific register,\n+but there's no matching constraint letter for that register @emph{by\n+itself}.  To force the operand into that register, use a local variable\n+for the operand and specify the register in the variable declaration.\n+@xref{Explicit Reg Vars}.  Then for the @code{asm} operand, use any\n+register constraint letter that matches the register:\n+\n+@smallexample\n+register int *p1 asm (\"r0\") = @dots{};\n+register int *p2 asm (\"r1\") = @dots{};\n+register int *result asm (\"r0\");\n+asm (\"sysint\" : \"=r\" (result) : \"0\" (p1), \"r\" (p2));\n+@end smallexample\n+\n Some instructions clobber specific hard registers.  To describe this,\n write a third colon after the input operands, followed by the names of\n the clobbered hard registers (given as strings).  Here is a realistic\n@@ -3955,7 +3969,9 @@ very often.\n \n @item\n Local register variables in specific registers do not reserve the\n-registers.  The compiler's data flow analysis is capable of determining\n+registers, except at the point where they are used as input or output\n+operands in an @code{asm} statement and the @code{asm} statement itself is\n+not deleted.  The compiler's data flow analysis is capable of determining\n where the specified registers contain live values, and where they are\n available for other uses.  Stores into local register variables may be deleted\n when they appear to be dead according to dataflow analysis.  References\n@@ -4104,8 +4120,11 @@ the variable's value is not live.\n \n This option does not guarantee that GCC will generate code that has\n this variable in the register you specify at all times.  You may not\n-code an explicit reference to this register in an @code{asm} statement\n-and assume it will always refer to this variable.\n+code an explicit reference to this register in the @emph{assembler\n+instruction template} part of an @code{asm} statement and assume it will\n+always refer to this variable.  However, using the variable as an\n+@code{asm} @emph{operand} guarantees that the specified register is used\n+for the operand.\n \n Stores into local register variables may be deleted when they appear to be dead\n according to dataflow analysis.  References to local register variables may"}]}