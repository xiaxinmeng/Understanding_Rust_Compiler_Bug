{"sha": "f20731b7ca20be9dd32d7cf95ddeb9ef6baa4d1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjIwNzMxYjdjYTIwYmU5ZGQzMmQ3Y2Y5NWRkZWI5ZWY2YmFhNGQxYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2005-09-27T18:47:27Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-09-27T18:47:27Z"}, "message": "passes.c (init_optimization_passes): Replace copy propagation passes immediately after DOM with phi-only copy...\n\n       * passes.c (init_optimization_passes): Replace copy propagation\n        passes immediately after DOM with phi-only copy propagation\n        pases.  Add phi-only copy propagation pass after first DOM pass.\n        * tree-pass.h (pass_phi_only_copy_prop): Declare.\n        * tree-ssa-copy.c (init_copy_prop): Accept new PHI_ONLY argument.\n        If true, then mark all non-control statements with DONT_SIMULATE_AGAIN.\n        (execute_copy_prop): Accept new PHI_ONLY argument.  Pass it along\n        to init_copy_prop.  Callers updated.\n        (do_phi_only_copy_prop): New function.\n        (pass_phi_only_copy_prop): New pass descriptor.\n\nFrom-SVN: r104705", "tree": {"sha": "6c0678c98499772e377cb3741449d3860e6fd8a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c0678c98499772e377cb3741449d3860e6fd8a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f20731b7ca20be9dd32d7cf95ddeb9ef6baa4d1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f20731b7ca20be9dd32d7cf95ddeb9ef6baa4d1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f20731b7ca20be9dd32d7cf95ddeb9ef6baa4d1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f20731b7ca20be9dd32d7cf95ddeb9ef6baa4d1c/comments", "author": null, "committer": null, "parents": [{"sha": "3542b7ccd2bfe7d5bf9df0f008eecf4d1858c18d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3542b7ccd2bfe7d5bf9df0f008eecf4d1858c18d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3542b7ccd2bfe7d5bf9df0f008eecf4d1858c18d"}], "stats": {"total": 93, "additions": 80, "deletions": 13}, "files": [{"sha": "fd231baa49680d14cfb0550837070e063409bb7a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20731b7ca20be9dd32d7cf95ddeb9ef6baa4d1c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20731b7ca20be9dd32d7cf95ddeb9ef6baa4d1c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f20731b7ca20be9dd32d7cf95ddeb9ef6baa4d1c", "patch": "@@ -1,3 +1,16 @@\n+2005-09-27  Jeff Law  <law@redhat.com>\n+\n+\t* passes.c (init_optimization_passes): Replace copy propagation\n+\tpasses immediately after DOM with phi-only copy propagation\n+\tpases.  Add phi-only copy propagation pass after first DOM pass.\n+\t* tree-pass.h (pass_phi_only_copy_prop): Declare.\n+\t* tree-ssa-copy.c (init_copy_prop): Accept new PHI_ONLY argument.\n+\tIf true, then mark all non-control statements with DONT_SIMULATE_AGAIN.\n+\t(execute_copy_prop): Accept new PHI_ONLY argument.  Pass it along\n+\tto init_copy_prop.  Callers updated.\n+\t(do_phi_only_copy_prop): New function.\n+\t(pass_phi_only_copy_prop): New pass descriptor.\n+\n 2005-09-27  Nick Clifton  <nickc@redhat.com>\n \n \t* libgcc2.c (__popcount_tab): Remove redundant prototype."}, {"sha": "b03eae39f4398033943c2baebb4cf7053c545432", "filename": "gcc/passes.c", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20731b7ca20be9dd32d7cf95ddeb9ef6baa4d1c/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20731b7ca20be9dd32d7cf95ddeb9ef6baa4d1c/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=f20731b7ca20be9dd32d7cf95ddeb9ef6baa4d1c", "patch": "@@ -494,6 +494,12 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_merge_phi);\n   NEXT_PASS (pass_dominator);\n \n+  /* The only copy propagation opportunities left after DOM\n+     should be due to degenerate PHI nodes.  So rather than\n+     run the full copy propagator, just discover and copy\n+     propagate away the degenerate PHI nodes.  */\n+  NEXT_PASS (pass_phi_only_copy_prop);\n+\n   NEXT_PASS (pass_phiopt);\n   NEXT_PASS (pass_may_alias);\n   NEXT_PASS (pass_tail_recursion);\n@@ -508,7 +514,13 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_may_alias);\n   NEXT_PASS (pass_rename_ssa_copies);\n   NEXT_PASS (pass_dominator);\n-  NEXT_PASS (pass_copy_prop);\n+\n+  /* The only copy propagation opportunities left after DOM\n+     should be due to degenerate PHI nodes.  So rather than\n+     run the full copy propagator, just discover and copy\n+     propagate away the degenerate PHI nodes.  */\n+  NEXT_PASS (pass_phi_only_copy_prop);\n+\n   NEXT_PASS (pass_dce);\n   NEXT_PASS (pass_dse);\n   NEXT_PASS (pass_may_alias);\n@@ -529,7 +541,13 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_sink_code);\n   NEXT_PASS (pass_tree_loop);\n   NEXT_PASS (pass_dominator);\n-  NEXT_PASS (pass_copy_prop);\n+\n+  /* The only copy propagation opportunities left after DOM\n+     should be due to degenerate PHI nodes.  So rather than\n+     run the full copy propagator, just discover and copy\n+     propagate away the degenerate PHI nodes.  */\n+  NEXT_PASS (pass_phi_only_copy_prop);\n+\n   NEXT_PASS (pass_cd_dce);\n \n   /* FIXME: If DCE is not run before checking for uninitialized uses,"}, {"sha": "6674884944a7f4a01d384dad7bd9c2e4fee04fd4", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20731b7ca20be9dd32d7cf95ddeb9ef6baa4d1c/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20731b7ca20be9dd32d7cf95ddeb9ef6baa4d1c/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=f20731b7ca20be9dd32d7cf95ddeb9ef6baa4d1c", "patch": "@@ -275,6 +275,7 @@ extern struct tree_opt_pass pass_sink_code;\n extern struct tree_opt_pass pass_fre;\n extern struct tree_opt_pass pass_linear_transform;\n extern struct tree_opt_pass pass_copy_prop;\n+extern struct tree_opt_pass pass_phi_only_copy_prop;\n extern struct tree_opt_pass pass_store_ccp;\n extern struct tree_opt_pass pass_store_copy_prop;\n extern struct tree_opt_pass pass_vrp;"}, {"sha": "575fe09d6e47ece6aadb1bee23f6bee5be2a213e", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20731b7ca20be9dd32d7cf95ddeb9ef6baa4d1c/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20731b7ca20be9dd32d7cf95ddeb9ef6baa4d1c/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=f20731b7ca20be9dd32d7cf95ddeb9ef6baa4d1c", "patch": "@@ -838,10 +838,12 @@ copy_prop_visit_phi_node (tree phi)\n }\n \n \n-/* Initialize structures used for copy propagation.  */\n+/* Initialize structures used for copy propagation.   PHIS_ONLY is true\n+   if we should only consider PHI nodes as generating copy propagation\n+   opportunities.  */\n \n static void\n-init_copy_prop (void)\n+init_copy_prop (bool phis_only)\n {\n   basic_block bb;\n \n@@ -866,7 +868,7 @@ init_copy_prop (void)\n \t     lists of the propagator.  */\n \t  if (stmt_ends_bb_p (stmt))\n \t    DONT_SIMULATE_AGAIN (stmt) = false;\n-\t  else if (stmt_may_generate_copy (stmt))\n+\t  else if (!phis_only && stmt_may_generate_copy (stmt))\n \t    DONT_SIMULATE_AGAIN (stmt) = false;\n \t  else\n \t    {\n@@ -917,10 +919,15 @@ fini_copy_prop (void)\n }\n \n \n-/* Main entry point to the copy propagator.  The algorithm propagates\n-   the value COPY-OF using ssa_propagate.  For every variable X_i,\n-   COPY-OF(X_i) indicates which variable is X_i created from.  The\n-   following example shows how the algorithm proceeds at a high level:\n+/* Main entry point to the copy propagator.\n+\n+   PHIS_ONLY is true if we should only consider PHI nodes as generating\n+   copy propagation opportunities. \n+\n+   The algorithm propagates the value COPY-OF using ssa_propagate.  For\n+   every variable X_i, COPY-OF(X_i) indicates which variable is X_i created\n+   from.  The following example shows how the algorithm proceeds at a\n+   high level:\n \n \t    1\ta_24 = x_1\n \t    2\ta_2 = PHI <a_24, x_1>\n@@ -1020,10 +1027,10 @@ fini_copy_prop (void)\n    x_53 and x_54 are both copies of x_898.  */\n \n static void\n-execute_copy_prop (bool store_copy_prop)\n+execute_copy_prop (bool store_copy_prop, bool phis_only)\n {\n   do_store_copy_prop = store_copy_prop;\n-  init_copy_prop ();\n+  init_copy_prop (phis_only);\n   ssa_propagate (copy_prop_visit_stmt, copy_prop_visit_phi_node);\n   fini_copy_prop ();\n }\n@@ -1038,7 +1045,7 @@ gate_copy_prop (void)\n static void\n do_copy_prop (void)\n {\n-  execute_copy_prop (false);\n+  execute_copy_prop (false, false);\n }\n \n struct tree_opt_pass pass_copy_prop =\n@@ -1063,6 +1070,34 @@ struct tree_opt_pass pass_copy_prop =\n };\n \n \n+static void\n+do_phi_only_copy_prop (void)\n+{\n+  execute_copy_prop (false, true);\n+}\n+\n+struct tree_opt_pass pass_phi_only_copy_prop =\n+{\n+  \"phionlycopyprop\",\t\t\t/* name */\n+  gate_copy_prop,\t\t\t/* gate */\n+  do_phi_only_copy_prop,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_COPY_PROP,\t\t\t/* tv_id */\n+  PROP_ssa | PROP_alias | PROP_cfg,\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_cleanup_cfg\n+    | TODO_dump_func\n+    | TODO_ggc_collect\n+    | TODO_verify_ssa\n+    | TODO_update_ssa,\t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n+\n+\n static bool\n gate_store_copy_prop (void)\n {\n@@ -1077,7 +1112,7 @@ static void\n store_copy_prop (void)\n {\n   /* If STORE-COPY-PROP is not enabled, we just run regular COPY-PROP.  */\n-  execute_copy_prop (flag_tree_store_copy_prop != 0);\n+  execute_copy_prop (flag_tree_store_copy_prop != 0, false);\n }\n \n struct tree_opt_pass pass_store_copy_prop ="}]}