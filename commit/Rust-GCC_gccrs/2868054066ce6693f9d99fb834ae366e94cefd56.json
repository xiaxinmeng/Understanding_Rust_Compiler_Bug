{"sha": "2868054066ce6693f9d99fb834ae366e94cefd56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg2ODA1NDA2NmNlNjY5M2Y5ZDk5ZmI4MzRhZTM2NmU5NGNlZmQ1Ng==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-05-11T15:54:19Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-05-11T15:54:19Z"}, "message": "loop.h (struct movables): Remove `num'.\n\n\t* loop.h (struct movables): Remove `num'.\n\t* loop.c (scan_loop): Don't set it.  Use count_insns_in_loop.\n\tAdjust call to strength_reduce.\n\t(num_unmoved_movables): New function.\n\t(move_movables): Don't set movables->num.\n\t(strength_reduce): Compute the number of instructions in the loop\n\there, rather than in the caller.\n\t(check_dbra_loop): Always clear reversible_mem_store if there\n\tare any memory sets.\n\t(loop_regs_scan): Don't count instructions here.\n\t(count_insn_in_loop): New function.\n\nFrom-SVN: r41966", "tree": {"sha": "7e8f2fa2de2821974241456f1c9e7c9a00401659", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e8f2fa2de2821974241456f1c9e7c9a00401659"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2868054066ce6693f9d99fb834ae366e94cefd56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2868054066ce6693f9d99fb834ae366e94cefd56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2868054066ce6693f9d99fb834ae366e94cefd56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2868054066ce6693f9d99fb834ae366e94cefd56/comments", "author": null, "committer": null, "parents": [{"sha": "897aa57fd0e7e7f32540b0fc66cb2534172b10a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/897aa57fd0e7e7f32540b0fc66cb2534172b10a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/897aa57fd0e7e7f32540b0fc66cb2534172b10a2"}], "stats": {"total": 98, "additions": 66, "deletions": 32}, "files": [{"sha": "9387b95bc73bf187175bfc0ba032053e71b37ad8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2868054066ce6693f9d99fb834ae366e94cefd56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2868054066ce6693f9d99fb834ae366e94cefd56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2868054066ce6693f9d99fb834ae366e94cefd56", "patch": "@@ -1,3 +1,17 @@\n+2001-05-11  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* loop.h (struct movables): Remove `num'.\n+\t* loop.c (scan_loop): Don't set it.  Use count_insns_in_loop.\n+\tAdjust call to strength_reduce.\n+\t(num_unmoved_movables): New function.\n+\t(move_movables): Don't set movables->num.\n+\t(strength_reduce): Compute the number of instructions in the loop\n+\there, rather than in the caller.\n+\t(check_dbra_loop): Always clear reversible_mem_store if there\n+\tare any memory sets.\n+\t(loop_regs_scan): Don't count instructions here.\n+\t(count_insn_in_loop): New function.\n+\n 2001-05-11  Mark Mitchell  <mark@codesourcery.com>\n \n \t* optabs.c (emit_libcall_block): Don't mark calls as CONST_CALL_P."}, {"sha": "4a41c2d32d1b9f0549f69e72962ac5ed477df6e7", "filename": "gcc/loop.c", "status": "modified", "additions": 52, "deletions": 30, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2868054066ce6693f9d99fb834ae366e94cefd56/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2868054066ce6693f9d99fb834ae366e94cefd56/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=2868054066ce6693f9d99fb834ae366e94cefd56", "patch": "@@ -165,6 +165,7 @@ static void ignore_some_movables PARAMS ((struct loop_movables *));\n static void force_movables PARAMS ((struct loop_movables *));\n static void combine_movables PARAMS ((struct loop_movables *,\n \t\t\t\t      struct loop_regs *));\n+static int num_unmoved_movables PARAMS ((const struct loop *));\n static int regs_match_p PARAMS ((rtx, rtx, struct loop_movables *));\n static int rtx_equal_for_loop_p PARAMS ((rtx, rtx, struct loop_movables *,\n \t\t\t\t\t struct loop_regs *));\n@@ -189,7 +190,7 @@ static void loop_givs_reduce PARAMS((struct loop *, struct iv_class *));\n static void loop_givs_rescan PARAMS((struct loop *, struct iv_class *,\n \t\t\t\t     rtx *));\n static void loop_ivs_free PARAMS((struct loop *));\n-static void strength_reduce PARAMS ((struct loop *, int, int));\n+static void strength_reduce PARAMS ((struct loop *, int));\n static void find_single_use_in_loop PARAMS ((struct loop_regs *, rtx, rtx));\n static int valid_initial_value_p PARAMS ((rtx, rtx, int, rtx));\n static void find_mem_givs PARAMS ((const struct loop *, rtx, rtx, int, int));\n@@ -232,7 +233,8 @@ static int last_use_this_basic_block PARAMS ((rtx, rtx));\n static void record_initial PARAMS ((rtx, rtx, void *));\n static void update_reg_last_use PARAMS ((rtx, rtx));\n static rtx next_insn_in_loop PARAMS ((const struct loop *, rtx));\n-static void loop_regs_scan PARAMS ((const struct loop*, int, int *));\n+static void loop_regs_scan PARAMS ((const struct loop *, int));\n+static int count_insns_in_loop PARAMS ((const struct loop *));\n static void load_mems PARAMS ((const struct loop *));\n static int insert_loop_mem PARAMS ((rtx *, void *));\n static int replace_loop_mem PARAMS ((rtx *, void *));\n@@ -550,7 +552,6 @@ scan_loop (loop, flags)\n \n   movables->head = 0;\n   movables->last = 0;\n-  movables->num = 0;\n \n   /* Determine whether this loop starts with a jump down to a test at\n      the end.  This will occur for a small number of loops with a test\n@@ -637,7 +638,8 @@ scan_loop (loop, flags)\n   /* Allocate extra space for REGs that might be created by load_mems.\n      We allocate a little extra slop as well, in the hopes that we\n      won't have to reallocate the regs array.  */\n-  loop_regs_scan (loop, loop_info->mems_idx + 16, &insn_count);\n+  loop_regs_scan (loop, loop_info->mems_idx + 16);\n+  insn_count = count_insns_in_loop (loop);\n \n   if (loop_dump_stream)\n     {\n@@ -1006,7 +1008,7 @@ scan_loop (loop, flags)\n \n   /* Recalculate regs->array if load_mems has created new registers.  */\n   if (max_reg_num () > regs->num)\n-    loop_regs_scan (loop, 0, &insn_count);\n+    loop_regs_scan (loop, 0);\n \n   for (update_start = loop_start;\n        PREV_INSN (update_start)\n@@ -1024,7 +1026,7 @@ scan_loop (loop, flags)\n \t/* Ensure our label doesn't go away.  */\n \tLABEL_NUSES (update_end)++;\n \n-      strength_reduce (loop, insn_count, flags);\n+      strength_reduce (loop, flags);\n \n       reg_scan_update (update_start, update_end, loop_max_reg);\n       loop_max_reg = max_reg_num ();\n@@ -1421,6 +1423,24 @@ combine_movables (movables, regs)\n   /* Clean up.  */\n   free (matched_regs);\n }\n+\n+/* Returns the number of movable instructions in LOOP that were not\n+   moved outside the loop.  */\n+\n+static int\n+num_unmoved_movables (loop)\n+     const struct loop *loop;\n+{\n+  int num = 0;\n+  struct movable *m;\n+\n+  for (m = LOOP_MOVABLES (loop)->head; m; m = m->next)\n+    if (!m->done)\n+      ++num;\n+\n+  return num;\n+}\n+\n \f\n /* Return 1 if regs X and Y will become the same if moved.  */\n \n@@ -1634,8 +1654,6 @@ move_movables (loop, movables, threshold, insn_count)\n   rtx *reg_map = (rtx *) xcalloc (nregs, sizeof (rtx));\n   char *already_moved = (char *) xcalloc (nregs, sizeof (char));\n \n-  movables->num = 0;\n-\n   for (m = movables->head; m; m = m->next)\n     {\n       /* Describe this movable insn.  */\n@@ -1664,9 +1682,6 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t     INSN_UID (m->forces->insn));\n \t}\n \n-      /* Count movables.  Value used in heuristics in strength_reduce.  */\n-      movables->num++;\n-\n       /* Ignore the insn if it's already done (it matched something else).\n \t Otherwise, see if it is now safe to move.  */\n \n@@ -4200,9 +4215,8 @@ loop_ivs_free (loop)\n    must check regnos to make sure they are in bounds.  */\n \n static void\n-strength_reduce (loop, insn_count, flags)\n+strength_reduce (loop, flags)\n      struct loop *loop;\n-     int insn_count;\n      int flags;\n {\n   struct loop_info *loop_info = LOOP_INFO (loop);\n@@ -4222,6 +4236,7 @@ strength_reduce (loop, insn_count, flags)\n   int reg_map_size;\n   int unrolled_insn_copies = 0;\n   rtx test_reg = gen_rtx_REG (word_mode, LAST_VIRTUAL_REGISTER + 1);\n+  int insn_count = count_insns_in_loop (loop);\n \n   addr_placeholder = gen_reg_rtx (Pmode);\n \n@@ -7325,12 +7340,11 @@ check_dbra_loop (loop, insn_count)\n \t    {\n \t      struct induction *v;\n \n-\t      reversible_mem_store\n-\t\t= (! loop_info->unknown_address_altered\n-\t\t   && ! loop_info->unknown_constant_address_altered\n-\t\t   && ! loop_invariant_p (loop,\n-\t\t\t\t\t  XEXP (XEXP (loop_info->store_mems, 0),\n-\t\t\t\t\t\t0)));\n+\t      /* If we could prove that each of the memory locations\n+\t\t written to was different, then we could reverse the\n+\t\t store -- but we don't presently have any way of\n+\t\t knowing that.  */\n+\t      reversible_mem_store = 0;\n \n \t      /* If the store depends on a register that is set after the\n \t\t store, it depends on the initial value, and is thus not\n@@ -7362,7 +7376,7 @@ check_dbra_loop (loop, insn_count)\n \t   && ! loop_info->has_volatile\n \t   && reversible_mem_store\n \t   && (bl->giv_count + bl->biv_count + loop_info->num_mem_sets\n-\t       + LOOP_MOVABLES (loop)->num + compare_and_branch == insn_count)\n+\t       + num_unmoved_movables (loop) + compare_and_branch == insn_count)\n \t   && (bl == ivs->list && bl->next == 0))\n \t  || no_use_except_counting)\n \t{\n@@ -8702,24 +8716,19 @@ insert_loop_mem (mem, data)\n    parameter may be zero, in which case this processing is not done.\n \n    Set REGS->ARRAY[I].MAY_NOT_OPTIMIZE nonzero if we should not\n-   optimize register I.\n-\n-   Store in *COUNT_PTR the number of actual instructions\n-   in the loop.  We use this to decide what is worth moving out.  */\n+   optimize register I.  */\n \n static void\n-loop_regs_scan (loop, extra_size, count_ptr)\n+loop_regs_scan (loop, extra_size)\n      const struct loop *loop;\n      int extra_size;\n-     int *count_ptr;\n {\n   struct loop_regs *regs = LOOP_REGS (loop);\n   int old_nregs;\n   /* last_set[n] is nonzero iff reg n has been set in the current\n    basic block.  In that case, it is the insn that last set reg n.  */\n   rtx *last_set;\n   rtx insn;\n-  int count = 0;\n   int i;\n \n   old_nregs = regs->num;\n@@ -8754,8 +8763,6 @@ loop_regs_scan (loop, extra_size, count_ptr)\n     {\n       if (INSN_P (insn))\n \t{\n-\t  ++count;\n-\n \t  /* Record registers that have exactly one use.  */\n \t  find_single_use_in_loop (regs, insn, PATTERN (insn));\n \n@@ -8798,9 +8805,24 @@ loop_regs_scan (loop, extra_size, count_ptr)\n     regs->array[i].n_times_set = regs->array[i].set_in_loop;\n \n   free (last_set);\n-  *count_ptr = count;\n }\n \n+/* Returns the number of real INSNs in the LOOP.  */\n+\n+static int\n+count_insns_in_loop (loop)\n+     const struct loop *loop;\n+{\n+  int count = 0;\n+  rtx insn;\n+\n+  for (insn = loop->top ? loop->top : loop->start; insn != loop->end;\n+       insn = NEXT_INSN (insn))\n+    if (INSN_P (insn))\n+      ++count;\n+\n+  return count;\n+}\n \n /* Move MEMs into registers for the duration of the loop.  */\n "}, {"sha": "1794730307d25d89d7fa9d449bfc8b0872eefcd2", "filename": "gcc/loop.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2868054066ce6693f9d99fb834ae366e94cefd56/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2868054066ce6693f9d99fb834ae366e94cefd56/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=2868054066ce6693f9d99fb834ae366e94cefd56", "patch": "@@ -289,8 +289,6 @@ struct loop_movables\n   struct movable *head;\n   /* Last movable in chain.  */\n   struct movable *last;\n-  /* Number of movables in the loop.  */\n-  int num;\n };\n \n "}]}