{"sha": "f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYzYWRhYTdhNGFlMThjN2IwZGM0MjBmOWUyOThmNWIwNzQ2ZGE2Zg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-08T10:05:18Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-08T10:05:18Z"}, "message": "[multiple changes]\n\n2017-09-08  Yannick Moy  <moy@adacore.com>\n\n\t* sem_prag.adb: Use System.Case_Util.To_Lower to simplify code.\n\n2017-09-08  Arnaud Charlet  <charlet@adacore.com>\n\n\t* opt.ads (Include_Subprogram_In_Messages): New variable.\n\t* errout.ads (Current_Subprogram_Ptr): New variable.\n\t* errout.adb (Error_Msg): Prepend current subprogram info\n\tin messages if Include_Subprogram_In_Messages is set.\n\t* sem_util.adb (elab code): Initialize Current_Subprogram_Ptr to\n\tCurrent_Subprogram.\n\t* gnat1drv.adb (Adjust_Global_Switches): Set\n\tInclude_Subprogram_In_Messages when -gnatdJ is set.\n\t* debug.adb: Document and reserve -gnatdJ.\n\n2017-09-08  Georges-Axel Jaloyan  <jaloyan@adacore.com>\n\n\t* g-dynhta.adb, g-dynhta.ads (Get_First_Key, Get_Next_Key): New\n\tfunctions to iterate over simple hastables.\n\t(Load_Factor_HTable): Remove obsolete and inefficient implementation.\n\n2017-09-08  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch6.adb (Unqual_BIP_Function_Call): Adding\n\tmissing checks on the presence of Entity() before checking the\n\tentity attributes.\n\n2017-09-08  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Expression_Function): Reorder some\n\tstatements, use local variable and remove unnecessary processing.\n\nFrom-SVN: r251880", "tree": {"sha": "358956872032be9a0511fbfcc6dd5eb0659c861c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/358956872032be9a0511fbfcc6dd5eb0659c861c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/comments", "author": null, "committer": null, "parents": [{"sha": "4ac62786d6fb3b28c157fe9e6292842aa201d904", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ac62786d6fb3b28c157fe9e6292842aa201d904", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ac62786d6fb3b28c157fe9e6292842aa201d904"}], "stats": {"total": 782, "additions": 216, "deletions": 566}, "files": [{"sha": "3e030fe752b1951d2285ec4f93986d98a5a1d555", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f", "patch": "@@ -1,3 +1,36 @@\n+2017-09-08  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_prag.adb: Use System.Case_Util.To_Lower to simplify code.\n+\n+2017-09-08  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* opt.ads (Include_Subprogram_In_Messages): New variable.\n+\t* errout.ads (Current_Subprogram_Ptr): New variable.\n+\t* errout.adb (Error_Msg): Prepend current subprogram info\n+\tin messages if Include_Subprogram_In_Messages is set.\n+\t* sem_util.adb (elab code): Initialize Current_Subprogram_Ptr to\n+\tCurrent_Subprogram.\n+\t* gnat1drv.adb (Adjust_Global_Switches): Set\n+\tInclude_Subprogram_In_Messages when -gnatdJ is set.\n+\t* debug.adb: Document and reserve -gnatdJ.\n+\n+2017-09-08  Georges-Axel Jaloyan  <jaloyan@adacore.com>\n+\n+\t* g-dynhta.adb, g-dynhta.ads (Get_First_Key, Get_Next_Key): New\n+\tfunctions to iterate over simple hastables.\n+\t(Load_Factor_HTable): Remove obsolete and inefficient implementation.\n+\n+2017-09-08  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch6.adb (Unqual_BIP_Function_Call): Adding\n+\tmissing checks on the presence of Entity() before checking the\n+\tentity attributes.\n+\n+2017-09-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Expression_Function): Reorder some\n+\tstatements, use local variable and remove unnecessary processing.\n+\n 2017-09-08  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_ch6.ads (Make_Build_In_Place_Iface_Call_In_Allocator): New"}, {"sha": "c45a1883ce2afb67a18fc4ebb133c1a800a8c1e5", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f", "patch": "@@ -73,7 +73,7 @@ package body Debug is\n    --  dG   Generate all warnings including those normally suppressed\n    --  dH   Hold (kill) call to gigi\n    --  dI   Inhibit internal name numbering in gnatG listing\n-   --  dJ\n+   --  dJ   Prepend subprogram name in messages\n    --  dK   Kill all error messages\n    --  dL   Output trace information on elaboration checking\n    --  dM   Assume all variables are modified (no current values)\n@@ -400,6 +400,11 @@ package body Debug is\n    --       is used in the fixed bugs run to minimize system and version\n    --       dependency in filed -gnatD or -gnatG output.\n \n+   --  dJ   Prepend the name of the enclosing subprogram in compiler messages\n+   --       (errors, warnings, style checks). This is useful in particular to\n+   --       integrate compiler warnings in static analysis tools such as\n+   --       CodePeer.\n+\n    --  dK   Kill all error messages. This debug flag suppresses the output\n    --       of all error messages. It is used in regression tests where the\n    --       error messages are target dependent and irrelevant."}, {"sha": "664d36e0842b85cfeb5a76e338fe803fdc8b5da7", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f", "patch": "@@ -310,6 +310,8 @@ package body Errout is\n       --  Original location of Flag_Location (i.e. location in original\n       --  template in instantiation case, otherwise unchanged).\n \n+      Entity : Bounded_String;\n+\n    begin\n       --  Return if all errors are to be ignored\n \n@@ -336,6 +338,18 @@ package body Errout is\n       Prescan_Message (Msg);\n       Orig_Loc := Original_Location (Flag_Location);\n \n+      if Include_Subprogram_In_Messages then\n+         declare\n+            Ent : constant Entity_Id := Current_Subprogram_Ptr.all;\n+         begin\n+            if Present (Ent) then\n+               Append_Unqualified_Decoded (Entity, Chars (Ent));\n+            else\n+               Append (Entity, \"unknown subprogram\");\n+            end if;\n+         end;\n+      end if;\n+\n       --  If the current location is in an instantiation, the issue arises of\n       --  whether to post the message on the template or the instantiation.\n \n@@ -405,7 +419,14 @@ package body Errout is\n       --  Error_Msg_Internal to place the message in the requested location.\n \n       if Instantiation (Sindex) = No_Location then\n-         Error_Msg_Internal (Msg, Flag_Location, Flag_Location, False);\n+         if Include_Subprogram_In_Messages then\n+            Append (Entity, \": \");\n+            Append (Entity, Msg);\n+            Error_Msg_Internal (+Entity, Flag_Location, Flag_Location, False);\n+         else\n+            Error_Msg_Internal (Msg, Flag_Location, Flag_Location, False);\n+         end if;\n+\n          return;\n       end if;\n \n@@ -555,8 +576,15 @@ package body Errout is\n \n          --  Here we output the original message on the outer instantiation\n \n-         Error_Msg_Internal\n-           (Msg, Actual_Error_Loc, Flag_Location, Msg_Cont_Status);\n+         if Include_Subprogram_In_Messages then\n+            Append (Entity, \": \");\n+            Append (Entity, Msg);\n+            Error_Msg_Internal\n+              (+Entity, Actual_Error_Loc, Flag_Location, Msg_Cont_Status);\n+         else\n+            Error_Msg_Internal\n+              (Msg, Actual_Error_Loc, Flag_Location, Msg_Cont_Status);\n+         end if;\n       end;\n    end Error_Msg;\n "}, {"sha": "ad33673cdff966508c628bbcc09379f16ce59490", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -68,6 +68,11 @@ package Errout is\n    --  error message tag. The -gnatw.d switch sets this flag True, -gnatw.D\n    --  sets this flag False.\n \n+   type Current_Subprogram_Type is access function return Entity_Id;\n+   Current_Subprogram_Ptr : Current_Subprogram_Type := null;\n+   --  Indirect call to Sem_Util.Current_Subprogram to break circular\n+   --  dependency with the static elaboration model.\n+\n    -----------------------------------\n    -- Suppression of Error Messages --\n    -----------------------------------"}, {"sha": "d04bbb1f075a253de94766d765c105936c182afa", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f", "patch": "@@ -9100,6 +9100,7 @@ package body Exp_Ch6 is\n          --  Recurse on object renamings\n \n          elsif Nkind (Expr) = N_Identifier\n+           and then Present (Entity (Expr))\n            and then Ekind_In (Entity (Expr), E_Constant, E_Variable)\n            and then Nkind (Parent (Entity (Expr))) =\n                       N_Object_Renaming_Declaration\n@@ -9112,6 +9113,7 @@ package body Exp_Ch6 is\n \n          elsif not On_Object_Declaration\n            and then Nkind (Expr) = N_Identifier\n+           and then Present (Entity (Expr))\n            and then Ekind_In (Entity (Expr), E_Constant, E_Variable)\n            and then Nkind (Parent (Entity (Expr))) = N_Object_Declaration\n            and then Present (Expression (Parent (Entity (Expr))))\n@@ -9125,6 +9127,7 @@ package body Exp_Ch6 is\n \n          elsif Nkind (Expr) = N_Function_Call\n            and then Nkind (Name (Expr)) in N_Has_Entity\n+           and then Present (Entity (Name (Expr)))\n            and then RTU_Loaded (Ada_Tags)\n            and then RTE_Available (RE_Displace)\n            and then Is_RTE (Entity (Name (Expr)), RE_Displace)"}, {"sha": "dbb9d3ee3ef67516fdc707df530b137364aab2fd", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f", "patch": "@@ -324,7 +324,7 @@ package body Exp_Prag is\n       --  Discriminants of the enclosing protected object may be referenced\n       --  in the expression of a precondition of a protected operation.\n       --  In the body of the operation these references must be replaced by\n-      --  the discriminal created for them, which area renamings of the\n+      --  the discriminal created for them, which are renamings of the\n       --  discriminants of the object that is the target of the operation.\n       --  This replacement is done by visibility when the references appear\n       --  in the subprogram body, but in the case of a condition which appears"}, {"sha": "05ef90183d3afbe05b7193115d7cb264c2cfa1dd", "filename": "gcc/ada/g-dynhta.adb", "status": "modified", "additions": 29, "deletions": 361, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fg-dynhta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fg-dynhta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dynhta.adb?ref=f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2002-2016, AdaCore                     --\n+--                     Copyright (C) 2002-2017, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -256,6 +256,20 @@ package body GNAT.Dynamic_HTables is\n          end if;\n       end Get_First;\n \n+      -------------------\n+      -- Get_First_Key --\n+      -------------------\n+\n+      function Get_First_Key (T : Instance) return access constant Key is\n+         Tmp : aliased constant Elmt_Ptr := Tab.Get_First (Tab.Instance (T));\n+      begin\n+         if Tmp = null then\n+            return null;\n+         else\n+            return Tmp.all.K'Access;\n+         end if;\n+      end Get_First_Key;\n+\n       -------------\n       -- Get_Key --\n       -------------\n@@ -279,6 +293,20 @@ package body GNAT.Dynamic_HTables is\n          end if;\n       end Get_Next;\n \n+      ------------------\n+      -- Get_Next_Key --\n+      ------------------\n+\n+      function Get_Next_Key (T : Instance) return access constant Key is\n+         Tmp : aliased constant Elmt_Ptr := Tab.Get_Next (Tab.Instance (T));\n+      begin\n+         if Tmp = null then\n+            return null;\n+         else\n+            return Tmp.all.K'Access;\n+         end if;\n+      end Get_Next_Key;\n+\n       ----------\n       -- Next --\n       ----------\n@@ -347,364 +375,4 @@ package body GNAT.Dynamic_HTables is\n \n    end Simple_HTable;\n \n-   ------------------------\n-   -- Load_Factor_HTable --\n-   ------------------------\n-\n-   package body Load_Factor_HTable is\n-\n-      Min_Size_Increase : constant := 5;\n-      --  The minimum increase expressed as number of buckets. This value is\n-      --  used to determine the new size of small tables and/or small growth\n-      --  percentages.\n-\n-      procedure Attach\n-        (Elmt  : not null Element_Ptr;\n-         Chain : not null Element_Ptr);\n-      --  Prepend an element to a bucket chain. Elmt is inserted after the\n-      --  dummy head of Chain.\n-\n-      function Create_Buckets (Size : Positive) return Buckets_Array_Ptr;\n-      --  Allocate and initialize a new set of buckets. The buckets are created\n-      --  in the range Range_Type'First .. Range_Type'First + Size - 1.\n-\n-      procedure Detach (Elmt : not null Element_Ptr);\n-      --  Remove an element from an arbitrary bucket chain\n-\n-      function Find\n-        (Key   : Key_Type;\n-         Chain : not null Element_Ptr) return Element_Ptr;\n-      --  Try to locate the element which contains a particular key within a\n-      --  bucket chain. If no such element exists, return No_Element.\n-\n-      procedure Free is\n-        new Ada.Unchecked_Deallocation (Buckets_Array, Buckets_Array_Ptr);\n-\n-      procedure Free is\n-        new Ada.Unchecked_Deallocation (Element, Element_Ptr);\n-\n-      function Is_Empty_Chain (Chain : not null Element_Ptr) return Boolean;\n-      --  Determine whether a bucket chain contains only one element, namely\n-      --  the dummy head.\n-\n-      ------------\n-      -- Attach --\n-      ------------\n-\n-      procedure Attach\n-        (Elmt  : not null Element_Ptr;\n-         Chain : not null Element_Ptr)\n-      is\n-      begin\n-         Chain.Next.Prev := Elmt;\n-         Elmt.Next  := Chain.Next;\n-         Chain.Next := Elmt;\n-         Elmt.Prev  := Chain;\n-      end Attach;\n-\n-      --------------------\n-      -- Create_Buckets --\n-      --------------------\n-\n-      function Create_Buckets (Size : Positive) return Buckets_Array_Ptr is\n-         Low_Bound : constant Range_Type := Range_Type'First;\n-         Buckets   : Buckets_Array_Ptr;\n-\n-      begin\n-         Buckets :=\n-           new Buckets_Array (Low_Bound .. Low_Bound + Range_Type (Size) - 1);\n-\n-         --  Ensure that the dummy head of each bucket chain points to itself\n-         --  in both directions.\n-\n-         for Index in Buckets'Range loop\n-            declare\n-               Bucket : Element renames Buckets (Index);\n-\n-            begin\n-               Bucket.Prev := Bucket'Unchecked_Access;\n-               Bucket.Next := Bucket'Unchecked_Access;\n-            end;\n-         end loop;\n-\n-         return Buckets;\n-      end Create_Buckets;\n-\n-      ------------------\n-      -- Current_Size --\n-      ------------------\n-\n-      function Current_Size (T : Table) return Positive is\n-      begin\n-         --  The table should have been properly initialized during object\n-         --  elaboration.\n-\n-         if T.Buckets = null then\n-            raise Program_Error;\n-\n-         --  The size of the table is determined by the number of buckets\n-\n-         else\n-            return T.Buckets'Length;\n-         end if;\n-      end Current_Size;\n-\n-      ------------\n-      -- Detach --\n-      ------------\n-\n-      procedure Detach (Elmt : not null Element_Ptr) is\n-      begin\n-         if Elmt.Prev /= null and Elmt.Next /= null then\n-            Elmt.Prev.Next := Elmt.Next;\n-            Elmt.Next.Prev := Elmt.Prev;\n-            Elmt.Prev := null;\n-            Elmt.Next := null;\n-         end if;\n-      end Detach;\n-\n-      --------------\n-      -- Finalize --\n-      --------------\n-\n-      procedure Finalize (T : in out Table) is\n-         Bucket : Element_Ptr;\n-         Elmt   : Element_Ptr;\n-\n-      begin\n-         --  Inspect the buckets and deallocate bucket chains\n-\n-         for Index in T.Buckets'Range loop\n-            Bucket := T.Buckets (Index)'Unchecked_Access;\n-\n-            --  The current bucket chain contains an element other than the\n-            --  dummy head.\n-\n-            while not Is_Empty_Chain (Bucket) loop\n-\n-               --  Skip the dummy head, remove and deallocate the element\n-\n-               Elmt := Bucket.Next;\n-               Detach (Elmt);\n-               Free   (Elmt);\n-            end loop;\n-         end loop;\n-\n-         --  Deallocate the buckets\n-\n-         Free (T.Buckets);\n-      end Finalize;\n-\n-      ----------\n-      -- Find --\n-      ----------\n-\n-      function Find\n-        (Key   : Key_Type;\n-         Chain : not null Element_Ptr) return Element_Ptr\n-      is\n-         Elmt : Element_Ptr;\n-\n-      begin\n-         --  Skip the dummy head, inspect the bucket chain for an element whose\n-         --  key matches the requested key. Since each bucket chain is circular\n-         --  the search must stop once the dummy head is encountered.\n-\n-         Elmt := Chain.Next;\n-         while Elmt /= Chain loop\n-            if Equal (Elmt.Key, Key) then\n-               return Elmt;\n-            end if;\n-\n-            Elmt := Elmt.Next;\n-         end loop;\n-\n-         return No_Element;\n-      end Find;\n-\n-      ---------\n-      -- Get --\n-      ---------\n-\n-      function Get (T : Table; Key : Key_Type) return Value_Type is\n-         Bucket : Element_Ptr;\n-         Elmt   : Element_Ptr;\n-\n-      begin\n-         --  Obtain the bucket chain where the (key, value) pair should reside\n-         --  by calculating the proper hash location.\n-\n-         Bucket := T.Buckets (Hash (Key, Current_Size (T)))'Unchecked_Access;\n-\n-         --  Try to find an element whose key matches the requested key\n-\n-         Elmt := Find (Key, Bucket);\n-\n-         --  The hash table does not contain a matching (key, value) pair\n-\n-         if Elmt = No_Element then\n-            return No_Value;\n-         else\n-            return Elmt.Val;\n-         end if;\n-      end Get;\n-\n-      ----------------\n-      -- Initialize --\n-      ----------------\n-\n-      procedure Initialize (T : in out Table) is\n-      begin\n-         pragma Assert (T.Buckets = null);\n-\n-         T.Buckets       := Create_Buckets (Initial_Size);\n-         T.Element_Count := 0;\n-      end Initialize;\n-\n-      --------------------\n-      -- Is_Empty_Chain --\n-      --------------------\n-\n-      function Is_Empty_Chain (Chain : not null Element_Ptr) return Boolean is\n-      begin\n-         return Chain.Next = Chain and Chain.Prev = Chain;\n-      end Is_Empty_Chain;\n-\n-      ------------\n-      -- Remove --\n-      ------------\n-\n-      procedure Remove (T : in out Table; Key : Key_Type) is\n-         Bucket : Element_Ptr;\n-         Elmt   : Element_Ptr;\n-\n-      begin\n-         --  Obtain the bucket chain where the (key, value) pair should reside\n-         --  by calculating the proper hash location.\n-\n-         Bucket := T.Buckets (Hash (Key, Current_Size (T)))'Unchecked_Access;\n-\n-         --  Try to find an element whose key matches the requested key\n-\n-         Elmt := Find (Key, Bucket);\n-\n-         --  Remove and deallocate the (key, value) pair\n-\n-         if Elmt /= No_Element then\n-            Detach (Elmt);\n-            Free   (Elmt);\n-         end if;\n-      end Remove;\n-\n-      ---------\n-      -- Set --\n-      ---------\n-\n-      procedure Set\n-        (T   : in out Table;\n-         Key : Key_Type;\n-         Val : Value_Type)\n-      is\n-         Curr_Size : constant Positive := Current_Size (T);\n-\n-         procedure Grow;\n-         --  Grow the table to a new size according to the desired percentage\n-         --  and relocate all existing elements to the new buckets.\n-\n-         ----------\n-         -- Grow --\n-         ----------\n-\n-         procedure Grow is\n-            Buckets     : Buckets_Array_Ptr;\n-            Elmt        : Element_Ptr;\n-            Hash_Loc    : Range_Type;\n-            Old_Bucket  : Element_Ptr;\n-            Old_Buckets : Buckets_Array_Ptr := T.Buckets;\n-            Size        : Positive;\n-\n-         begin\n-            --  Calculate the new size and allocate a new set of buckets. Note\n-            --  that a table with a small size or a small growth percentage may\n-            --  not always grow (for example, 10 buckets and 3% increase). In\n-            --  that case, enforce a minimum increase.\n-\n-            Size :=\n-              Positive'Max (Curr_Size * ((100 + Growth_Percentage) / 100),\n-                            Min_Size_Increase);\n-            Buckets := Create_Buckets (Size);\n-\n-            --  Inspect the old buckets and transfer all elements by rehashing\n-            --  all (key, value) pairs in the new buckets.\n-\n-            for Index in Old_Buckets'Range loop\n-               Old_Bucket := Old_Buckets (Index)'Unchecked_Access;\n-\n-               --  The current bucket chain contains an element other than the\n-               --  dummy head.\n-\n-               while not Is_Empty_Chain (Old_Bucket) loop\n-\n-                  --  Skip the dummy head and find the new hash location\n-\n-                  Elmt     := Old_Bucket.Next;\n-                  Hash_Loc := Hash (Elmt.Key, Size);\n-\n-                  --  Remove the element from the old buckets and insert it\n-                  --  into the new buckets. Note that there is no need to check\n-                  --  for duplicates because the hash table did not have any to\n-                  --  begin with.\n-\n-                  Detach (Elmt);\n-                  Attach\n-                    (Elmt  => Elmt,\n-                     Chain => Buckets (Hash_Loc)'Unchecked_Access);\n-               end loop;\n-            end loop;\n-\n-            --  Associate the new buckets with the table and reclaim the\n-            --  storage occupied by the old buckets.\n-\n-            T.Buckets := Buckets;\n-\n-            Free (Old_Buckets);\n-         end Grow;\n-\n-         --  Local variables\n-\n-         subtype LLF is Long_Long_Float;\n-\n-         Count    : Natural renames T.Element_Count;\n-         Bucket   : Element_Ptr;\n-         Hash_Loc : Range_Type;\n-\n-      --  Start of processing for Set\n-\n-      begin\n-         --  Find the bucket where the (key, value) pair should be inserted by\n-         --  computing the proper hash location.\n-\n-         Hash_Loc := Hash (Key, Curr_Size);\n-         Bucket   := T.Buckets (Hash_Loc)'Unchecked_Access;\n-\n-         --  Ensure that the key is not already present in the bucket in order\n-         --  to avoid duplicates.\n-\n-         if Find (Key, Bucket) = No_Element then\n-            Attach\n-              (Elmt  => new Element'(Key, Val, null, null),\n-               Chain => Bucket);\n-            Count := Count + 1;\n-\n-            --  Multiple insertions may cause long bucket chains and decrease\n-            --  the performance of basic operations. If this is the case, grow\n-            --  the table and rehash all existing elements.\n-\n-            if (LLF (Count) / LLF (Curr_Size)) > LLF (Load_Factor) then\n-               Grow;\n-            end if;\n-         end if;\n-      end Set;\n-   end Load_Factor_HTable;\n-\n end GNAT.Dynamic_HTables;"}, {"sha": "e80dfdfd172d428cb578890227b7cee3b1b71aa6", "filename": "gcc/ada/g-dynhta.ads", "status": "modified", "additions": 18, "deletions": 120, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fg-dynhta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fg-dynhta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dynhta.ads?ref=f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 1995-2014, AdaCore                     --\n+--                     Copyright (C) 1995-2017, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -48,8 +48,6 @@\n --  GNAT.HTable to keep as much coherency as possible between these two\n --  related units.\n \n-private with Ada.Finalization;\n-\n package GNAT.Dynamic_HTables is\n \n    -------------------\n@@ -124,11 +122,11 @@ package GNAT.Dynamic_HTables is\n \n       function Get_First (T : Instance) return Elmt_Ptr;\n       --  Returns Null_Ptr if the Htable is empty, otherwise returns one\n-      --  non specified element. There is no guarantee that 2 calls to this\n+      --  unspecified element. There is no guarantee that 2 calls to this\n       --  function will return the same element.\n \n       function Get_Next (T : Instance) return Elmt_Ptr;\n-      --  Returns a non-specified element that has not been returned by the\n+      --  Returns an unspecified element that has not been returned by the\n       --  same function since the last call to Get_First or Null_Ptr if\n       --  there is no such element or Get_First has never been called. If\n       --  there is no call to 'Set' in between Get_Next calls, all the\n@@ -189,12 +187,18 @@ package GNAT.Dynamic_HTables is\n \n       function Get_First (T : Instance) return Element;\n       --  Returns No_Element if the Htable is empty, otherwise returns one\n-      --  non specified element. There is no guarantee that two calls to this\n+      --  unspecified element. There is no guarantee that two calls to this\n       --  function will return the same element, if the Htable has been\n       --  modified between the two calls.\n \n+      function Get_First_Key (T : Instance) return access constant Key;\n+      --  Returns Null if the Htable is empty, otherwise returns one\n+      --  unspecified key. There is no guarantee that two calls to this\n+      --  function will return the same key, if the Htable has been modified\n+      --  between the two calls.\n+\n       function Get_Next (T : Instance) return Element;\n-      --  Returns a non-specified element that has not been returned by the\n+      --  Returns an unspecified element that has not been returned by the\n       --  same function since the last call to Get_First or No_Element if\n       --  there is no such element. If there is no call to 'Set' in between\n       --  Get_Next calls, all the elements of the Htable will be traversed.\n@@ -203,12 +207,18 @@ package GNAT.Dynamic_HTables is\n       --  between a call to Get_First and subsequent consecutive calls to\n       --  Get_Next, until one of these calls returns No_Element.\n \n+      function Get_Next_Key (T : Instance) return access constant Key;\n+      --  Same as Get_Next except that this returns an unspecified access\n+      --  to constant key that has not been returned by either Get_First_Key\n+      --  or this very same function (or null if there is none). The same\n+      --  restrictions apply as Get_Next.\n+\n    private\n \n       type Element_Wrapper;\n       type Elmt_Ptr is access all Element_Wrapper;\n       type Element_Wrapper is record\n-         K    : Key;\n+         K    : aliased Key;\n          E    : Element;\n          Next : Elmt_Ptr;\n       end record;\n@@ -234,116 +244,4 @@ package GNAT.Dynamic_HTables is\n \n    end Simple_HTable;\n \n-   ------------------------\n-   -- Load_Factor_HTable --\n-   ------------------------\n-\n-   --  A simple hash table abstraction capable of growing once a threshold has\n-   --  been exceeded. Collisions are resolved by chaining elements onto lists\n-   --  hanging from individual buckets. This implementation does not make any\n-   --  effort to minimize the number of necessary rehashes once the table has\n-   --  been expanded, hence the term \"simple\".\n-\n-   --  WARNING: This hash table implementation utilizes dynamic allocation.\n-   --  Storage reclamation is performed by the hash table.\n-\n-   --  WARNING: This hash table implementation is not thread-safe. To achieve\n-   --  proper concurrency and synchronization, wrap an instance of a table in\n-   --  a protected object.\n-\n-   generic\n-      type Range_Type is range <>;\n-      --  The underlying range of the hash table. Note that this type must be\n-      --  large enough to accommodate multiple expansions of the table.\n-\n-      type Key_Type is private;\n-      type Value_Type is private;\n-      --  The types of the (key, value) pair stored in the hash table\n-\n-      No_Value : Value_Type;\n-      --  A predefined value denoting a non-existent value\n-\n-      Initial_Size : Positive;\n-      --  The starting size of the hash table. The hash table must contain at\n-      --  least one bucket.\n-\n-      Growth_Percentage : Positive;\n-      --  The amount of increase expressed as a percentage. The hash table must\n-      --  grow by at least 1%. To illustrate, a value of 100 will increase the\n-      --  table by 100%, effectively doubling its size.\n-\n-      Load_Factor : Float;\n-      --  The ratio of the elements stored within the hash table divided by the\n-      --  current size of the table. This value acts as the growth threshold.\n-      --  If exceeded, the hash table is expanded by Growth_Percentage.\n-\n-      with function Equal\n-        (Left  : Key_Type;\n-         Right : Key_Type) return Boolean;\n-\n-      with function Hash\n-        (Key  : Key_Type;\n-         Size : Positive) return Range_Type;\n-      --  Parameter Size denotes the current size of the hash table\n-\n-   package Load_Factor_HTable is\n-      type Table is tagged limited private;\n-\n-      function Current_Size (T : Table) return Positive;\n-      --  Obtain the current size of the table\n-\n-      function Get (T : Table; Key : Key_Type) return Value_Type;\n-      --  Obtain the value associated with a key. This routine returns No_Value\n-      --  if the key is not present in the hash table.\n-\n-      procedure Remove (T : in out Table; Key : Key_Type);\n-      --  Remove the value associated with the given key. This routine has no\n-      --  effect if the key is not present in the hash table.\n-\n-      procedure Set\n-        (T   : in out Table;\n-         Key : Key_Type;\n-         Val : Value_Type);\n-      --  Associate a value with a given key. This routine has no effect if the\n-      --  the (key, value) pair is already present in the hash table. Note that\n-      --  this action may cause the table to grow.\n-\n-   private\n-      --  The following types model a bucket chain. Note that the key is also\n-      --  stored for rehashing purposes.\n-\n-      type Element;\n-      type Element_Ptr is access all Element;\n-      type Element is record\n-         Key  : Key_Type;\n-         Val  : Value_Type;\n-         Prev : Element_Ptr := null;\n-         Next : Element_Ptr := null;\n-      end record;\n-\n-      No_Element : constant Element_Ptr := null;\n-\n-      --  The following types model the buckets of the hash table. Each bucket\n-      --  has a dummy head to facilitate insertion and deletion of elements.\n-\n-      type Buckets_Array is array (Range_Type range <>) of aliased Element;\n-      type Buckets_Array_Ptr is access all Buckets_Array;\n-\n-      type Table is new Ada.Finalization.Limited_Controlled with record\n-         Buckets : Buckets_Array_Ptr := null;\n-\n-         Element_Count : Natural := 0;\n-         --  The number of (key, value) pairs stored in the hash table\n-      end record;\n-\n-      procedure Finalize (T : in out Table);\n-      --  Destroy the contents of a hash table by reclaiming all storage used\n-      --  by buckets and their respective chains.\n-\n-      procedure Initialize (T : in out Table);\n-      --  Create a hash table with buckets within the range Range_Type'First ..\n-      --  Range_Type'First + Initial_Size - 1.\n-\n-   end Load_Factor_HTable;\n-\n end GNAT.Dynamic_HTables;"}, {"sha": "e60d912a90329ed8020e6538f8ae6495e5584008", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f", "patch": "@@ -178,6 +178,13 @@ procedure Gnat1drv is\n          Error_To_Warning := True;\n       end if;\n \n+      --  -gnatdJ sets Include_Subprogram_In_Messages, adding the related\n+      --  subprogram as part of the error and warning messages.\n+\n+      if Debug_Flag_JJ then\n+         Include_Subprogram_In_Messages := True;\n+      end if;\n+\n       --  Disable CodePeer_Mode in Check_Syntax, since we need front-end\n       --  expansion.\n "}, {"sha": "1c7c0a0e2081d26e064c1a781ef5c2225a713a69", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f", "patch": "@@ -848,6 +848,10 @@ package Opt is\n    --  cause implicit packing instead of generating an error message. Set by\n    --  use of pragma Implicit_Packing.\n \n+   Include_Subprogram_In_Messages : Boolean := False;\n+   --  GNAT\n+   --  Set True to include the enclosing subprogram in compiler messages.\n+\n    Ineffective_Inline_Warnings : Boolean := False;\n    --  GNAT\n    --  Set True to activate warnings if front-end inlining (-gnatN) is not able"}, {"sha": "37459f80382da99d1b335f71a0c0cfaf78109c4c", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f", "patch": "@@ -672,6 +672,15 @@ package body Sem_Ch6 is\n          end if;\n \n          Def_Id := Defining_Entity (N);\n+         Set_Is_Inlined (Def_Id);\n+\n+         --  Establish the linkages between the spec and the body. These are\n+         --  used when the expression function acts as the prefix of attribute\n+         --  'Access in order to freeze the original expression which has been\n+         --  moved to the generated body.\n+\n+         Set_Corresponding_Body (N, Defining_Entity (New_Body));\n+         Set_Corresponding_Spec (New_Body, Def_Id);\n \n          --  Within a generic pre-analyze the original expression for name\n          --  capture. The body is also generated but plays no role in\n@@ -685,16 +694,6 @@ package body Sem_Ch6 is\n             End_Scope;\n          end if;\n \n-         Set_Is_Inlined (Defining_Entity (N));\n-\n-         --  Establish the linkages between the spec and the body. These are\n-         --  used when the expression function acts as the prefix of attribute\n-         --  'Access in order to freeze the original expression which has been\n-         --  moved to the generated body.\n-\n-         Set_Corresponding_Body (N, Defining_Entity (New_Body));\n-         Set_Corresponding_Spec (New_Body, Defining_Entity (N));\n-\n          --  To prevent premature freeze action, insert the new body at the end\n          --  of the current declarations, or at the end of the package spec.\n          --  However, resolve usage names now, to prevent spurious visibility\n@@ -716,7 +715,7 @@ package body Sem_Ch6 is\n             --  the enclosing instance is analyzed.\n \n             if GNATprove_Mode\n-              and then Is_Generic_Actual_Subprogram (Defining_Entity (N))\n+              and then Is_Generic_Actual_Subprogram (Def_Id)\n             then\n                Insert_After (N, New_Body);\n \n@@ -735,16 +734,13 @@ package body Sem_Ch6 is\n                --  instance, where this has been done during generic analysis,\n                --  and will be redone when analyzing the body.\n \n-               Set_Parent (Expr, Ret);\n-               Push_Scope (Def_Id);\n-               Install_Formals (Def_Id);\n-\n                if not In_Instance then\n+                  Push_Scope (Def_Id);\n+                  Install_Formals (Def_Id);\n                   Preanalyze_Spec_Expression (Expr, Typ);\n                   Check_Limited_Return (Original_Node (N), Expr, Typ);\n+                  End_Scope;\n                end if;\n-\n-               End_Scope;\n             end if;\n          end;\n       end if;"}, {"sha": "1f4eb1b8fdb8e3d3d256009a8ed3f5021c9b6755", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 63, "deletions": 62, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f", "patch": "@@ -29,64 +29,65 @@\n --  to complete the syntax checks. Certain pragmas are handled partially or\n --  completely by the parser (see Par.Prag for further details).\n \n-with Aspects;   use Aspects;\n-with Atree;     use Atree;\n-with Casing;    use Casing;\n-with Checks;    use Checks;\n-with Contracts; use Contracts;\n-with Csets;     use Csets;\n-with Debug;     use Debug;\n-with Einfo;     use Einfo;\n-with Elists;    use Elists;\n-with Errout;    use Errout;\n-with Exp_Dist;  use Exp_Dist;\n-with Exp_Util;  use Exp_Util;\n-with Freeze;    use Freeze;\n-with Ghost;     use Ghost;\n-with Gnatvsn;   use Gnatvsn;\n-with Lib;       use Lib;\n-with Lib.Writ;  use Lib.Writ;\n-with Lib.Xref;  use Lib.Xref;\n-with Namet.Sp;  use Namet.Sp;\n-with Nlists;    use Nlists;\n-with Nmake;     use Nmake;\n-with Output;    use Output;\n-with Par_SCO;   use Par_SCO;\n-with Restrict;  use Restrict;\n-with Rident;    use Rident;\n-with Rtsfind;   use Rtsfind;\n-with Sem;       use Sem;\n-with Sem_Aux;   use Sem_Aux;\n-with Sem_Ch3;   use Sem_Ch3;\n-with Sem_Ch6;   use Sem_Ch6;\n-with Sem_Ch8;   use Sem_Ch8;\n-with Sem_Ch12;  use Sem_Ch12;\n-with Sem_Ch13;  use Sem_Ch13;\n-with Sem_Disp;  use Sem_Disp;\n-with Sem_Dist;  use Sem_Dist;\n-with Sem_Elim;  use Sem_Elim;\n-with Sem_Eval;  use Sem_Eval;\n-with Sem_Intr;  use Sem_Intr;\n-with Sem_Mech;  use Sem_Mech;\n-with Sem_Res;   use Sem_Res;\n-with Sem_Type;  use Sem_Type;\n-with Sem_Util;  use Sem_Util;\n-with Sem_Warn;  use Sem_Warn;\n-with Stand;     use Stand;\n-with Sinfo;     use Sinfo;\n-with Sinfo.CN;  use Sinfo.CN;\n-with Sinput;    use Sinput;\n-with Stringt;   use Stringt;\n-with Stylesw;   use Stylesw;\n+with Aspects;          use Aspects;\n+with Atree;            use Atree;\n+with Casing;           use Casing;\n+with Checks;           use Checks;\n+with Contracts;        use Contracts;\n+with Csets;            use Csets;\n+with Debug;            use Debug;\n+with Einfo;            use Einfo;\n+with Elists;           use Elists;\n+with Errout;           use Errout;\n+with Exp_Dist;         use Exp_Dist;\n+with Exp_Util;         use Exp_Util;\n+with Freeze;           use Freeze;\n+with Ghost;            use Ghost;\n+with Gnatvsn;          use Gnatvsn;\n+with Lib;              use Lib;\n+with Lib.Writ;         use Lib.Writ;\n+with Lib.Xref;         use Lib.Xref;\n+with Namet.Sp;         use Namet.Sp;\n+with Nlists;           use Nlists;\n+with Nmake;            use Nmake;\n+with Output;           use Output;\n+with Par_SCO;          use Par_SCO;\n+with Restrict;         use Restrict;\n+with Rident;           use Rident;\n+with Rtsfind;          use Rtsfind;\n+with Sem;              use Sem;\n+with Sem_Aux;          use Sem_Aux;\n+with Sem_Ch3;          use Sem_Ch3;\n+with Sem_Ch6;          use Sem_Ch6;\n+with Sem_Ch8;          use Sem_Ch8;\n+with Sem_Ch12;         use Sem_Ch12;\n+with Sem_Ch13;         use Sem_Ch13;\n+with Sem_Disp;         use Sem_Disp;\n+with Sem_Dist;         use Sem_Dist;\n+with Sem_Elim;         use Sem_Elim;\n+with Sem_Eval;         use Sem_Eval;\n+with Sem_Intr;         use Sem_Intr;\n+with Sem_Mech;         use Sem_Mech;\n+with Sem_Res;          use Sem_Res;\n+with Sem_Type;         use Sem_Type;\n+with Sem_Util;         use Sem_Util;\n+with Sem_Warn;         use Sem_Warn;\n+with Stand;            use Stand;\n+with Sinfo;            use Sinfo;\n+with Sinfo.CN;         use Sinfo.CN;\n+with Sinput;           use Sinput;\n+with Stringt;          use Stringt;\n+with Stylesw;          use Stylesw;\n+with System.Case_Util;\n with Table;\n-with Targparm;  use Targparm;\n-with Tbuild;    use Tbuild;\n+with Targparm;         use Targparm;\n+with Tbuild;           use Tbuild;\n with Ttypes;\n-with Uintp;     use Uintp;\n-with Uname;     use Uname;\n-with Urealp;    use Urealp;\n-with Validsw;   use Validsw;\n-with Warnsw;    use Warnsw;\n+with Uintp;            use Uintp;\n+with Uname;            use Uname;\n+with Urealp;           use Urealp;\n+with Validsw;          use Validsw;\n+with Warnsw;           use Warnsw;\n \n package body Sem_Prag is\n \n@@ -17923,24 +17924,24 @@ package body Sem_Prag is\n                                                   Name_Increases)\n                then\n                   declare\n-                     Name : constant String :=\n+                     Name : String :=\n                               Get_Name_String (Chars (Variant));\n                   begin\n                      --  It is a common mistake to write \"Increasing\" for\n                      --  \"Increases\" or \"Decreasing\" for \"Decreases\". Recognize\n-                     --  specially names starting with \"Incr\" or \"Decr\" to\n+                     --  specially names starting with \"incr\" or \"decr\" to\n                      --  suggest the corresponding name.\n \n+                     System.Case_Util.To_Lower (Name);\n+\n                      if Name'Length >= 4\n-                       and then (Name (1 .. 4) = \"Incr\"\n-                                   or else Name (1 .. 4) = \"incr\")\n+                       and then Name (1 .. 4) = \"incr\"\n                      then\n                         Error_Pragma_Arg_Ident\n                           (\"expect name `Increases`\", Variant);\n \n                      elsif Name'Length >= 4\n-                       and then (Name (1 .. 4) = \"Decr\"\n-                                   or else Name (1 .. 4) = \"decr\")\n+                       and then Name (1 .. 4) = \"decr\"\n                      then\n                         Error_Pragma_Arg_Ident\n                           (\"expect name `Decreases`\", Variant);"}, {"sha": "a399be05f17f4567e6c9da66d73c13c4370b1f7a", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f63adaa7a4ae18c7b0dc420f9e298f5b0746da6f", "patch": "@@ -23173,4 +23173,6 @@ package body Sem_Util is\n       end if;\n    end Yields_Universal_Type;\n \n+begin\n+   Errout.Current_Subprogram_Ptr := Current_Subprogram'Access;\n end Sem_Util;"}]}