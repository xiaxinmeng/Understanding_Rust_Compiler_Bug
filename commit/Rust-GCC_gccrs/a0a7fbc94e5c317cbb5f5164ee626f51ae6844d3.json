{"sha": "a0a7fbc94e5c317cbb5f5164ee626f51ae6844d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBhN2ZiYzk0ZTVjMzE3Y2JiNWY1MTY0ZWU2MjZmNTFhZTY4NDRkMw==", "commit": {"author": {"name": "Andreas Schwab", "email": "schwab@suse.de", "date": "2005-11-27T21:26:36Z"}, "committer": {"name": "Andreas Schwab", "email": "schwab@gcc.gnu.org", "date": "2005-11-27T21:26:36Z"}, "message": "m68k.c: Reindent and fix whitespace, remove redundant parens.\n\n\t* config/m68k/m68k.c: Reindent and fix whitespace, remove\n\tredundant parens.\n\nFrom-SVN: r107574", "tree": {"sha": "3ce8a2cb676b8c1333767a7853a7fded31aae947", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ce8a2cb676b8c1333767a7853a7fded31aae947"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0a7fbc94e5c317cbb5f5164ee626f51ae6844d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a7fbc94e5c317cbb5f5164ee626f51ae6844d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0a7fbc94e5c317cbb5f5164ee626f51ae6844d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a7fbc94e5c317cbb5f5164ee626f51ae6844d3/comments", "author": {"login": "andreas-schwab", "id": 2175493, "node_id": "MDQ6VXNlcjIxNzU0OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/2175493?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andreas-schwab", "html_url": "https://github.com/andreas-schwab", "followers_url": "https://api.github.com/users/andreas-schwab/followers", "following_url": "https://api.github.com/users/andreas-schwab/following{/other_user}", "gists_url": "https://api.github.com/users/andreas-schwab/gists{/gist_id}", "starred_url": "https://api.github.com/users/andreas-schwab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andreas-schwab/subscriptions", "organizations_url": "https://api.github.com/users/andreas-schwab/orgs", "repos_url": "https://api.github.com/users/andreas-schwab/repos", "events_url": "https://api.github.com/users/andreas-schwab/events{/privacy}", "received_events_url": "https://api.github.com/users/andreas-schwab/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "64acfd9910111c7d754802a3b9c92ee82e441113", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64acfd9910111c7d754802a3b9c92ee82e441113", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64acfd9910111c7d754802a3b9c92ee82e441113"}], "stats": {"total": 1011, "additions": 503, "deletions": 508}, "files": [{"sha": "446ae10f91af764de3e771c6b0b6c6c67af50653", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a7fbc94e5c317cbb5f5164ee626f51ae6844d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a7fbc94e5c317cbb5f5164ee626f51ae6844d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a0a7fbc94e5c317cbb5f5164ee626f51ae6844d3", "patch": "@@ -1,3 +1,8 @@\n+2005-11-27  Andreas Schwab  <schwab@suse.de>\n+\n+\t* config/m68k/m68k.c: Reindent and fix whitespace, remove\n+\tredundant parens.\n+\n 2005-11-27  Steven Bosscher  <stevenb@suse.de>\n \n \t* cfgcleanup.c (try_crossjump_to_edge): Always split SRC2 if it"}, {"sha": "48f924a65b986c36d07ac22fe1c63edac2607ea6", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 498, "deletions": 508, "changes": 1006, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a7fbc94e5c317cbb5f5164ee626f51ae6844d3/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a7fbc94e5c317cbb5f5164ee626f51ae6844d3/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=a0a7fbc94e5c317cbb5f5164ee626f51ae6844d3", "patch": "@@ -445,9 +445,9 @@ m68k_initial_elimination_offset (int from, int to)\n   gcc_assert (to == STACK_POINTER_REGNUM);\n   switch (from)\n     {\n-      case ARG_POINTER_REGNUM:\n-\treturn current_frame.offset + current_frame.size\n-\t  + (frame_pointer_needed ? -UNITS_PER_WORD * 2 : -UNITS_PER_WORD);\n+    case ARG_POINTER_REGNUM:\n+      return (current_frame.offset + current_frame.size\n+\t      + (frame_pointer_needed ? -UNITS_PER_WORD * 2 : -UNITS_PER_WORD));\n     case FRAME_POINTER_REGNUM:\n       return current_frame.offset + current_frame.size;\n     default:\n@@ -496,13 +496,13 @@ m68k_save_reg (unsigned int regno, bool interrupt_handler)\n   /* Interrupt handlers must also save call_used_regs\n      if they are live or when calling nested functions.  */\n   if (interrupt_handler)\n-  {\n-     if (regs_ever_live[regno])\n-       return true;\n+    {\n+      if (regs_ever_live[regno])\n+\treturn true;\n \n-     if (!current_function_is_leaf && call_used_regs[regno])\n-       return true;\n-  }\n+      if (!current_function_is_leaf && call_used_regs[regno])\n+\treturn true;\n+    }\n \n   /* Never need to save registers that aren't touched.  */\n   if (!regs_ever_live[regno])\n@@ -517,7 +517,8 @@ m68k_save_reg (unsigned int regno, bool interrupt_handler)\n    SIZE is an int: how many units of temporary storage to allocate.  */\n \n static void\n-m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n+m68k_output_function_prologue (FILE *stream,\n+\t\t\t       HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT fsize_with_regs;\n   HOST_WIDE_INT cfa_offset = INCOMING_FRAME_SP_OFFSET;\n@@ -540,23 +541,24 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n     {\n       if (current_frame.size == 0 && TARGET_68040)\n \t/* on the 68040, pea + move is faster than link.w 0 */\n-\tfprintf (stream, MOTOROLA ?\n-\t\t\t   \"\\tpea (%s)\\n\\tmove.l %s,%s\\n\" :\n-\t\t\t   \"\\tpea %s@\\n\\tmovel %s,%s\\n\",\n-\t\t M68K_REGNAME(FRAME_POINTER_REGNUM),\n-\t\t M68K_REGNAME(STACK_POINTER_REGNUM),\n-\t\t M68K_REGNAME(FRAME_POINTER_REGNUM));\n+\tfprintf (stream, (MOTOROLA\n+\t\t\t  ? \"\\tpea (%s)\\n\\tmove.l %s,%s\\n\"\n+\t\t\t  : \"\\tpea %s@\\n\\tmovel %s,%s\\n\"),\n+\t\t M68K_REGNAME (FRAME_POINTER_REGNUM),\n+\t\t M68K_REGNAME (STACK_POINTER_REGNUM),\n+\t\t M68K_REGNAME (FRAME_POINTER_REGNUM));\n       else if (fsize_with_regs < 0x8000)\n \tasm_fprintf (stream, \"\\tlink\" ASM_DOTW \" %s,%I%wd\\n\",\n-\t\t     M68K_REGNAME(FRAME_POINTER_REGNUM), -fsize_with_regs);\n+\t\t     M68K_REGNAME (FRAME_POINTER_REGNUM), -fsize_with_regs);\n       else if (TARGET_68020)\n \tasm_fprintf (stream, \"\\tlink\" ASM_DOTL \" %s,%I%wd\\n\",\n-\t\t     M68K_REGNAME(FRAME_POINTER_REGNUM), -fsize_with_regs);\n+\t\t     M68K_REGNAME (FRAME_POINTER_REGNUM), -fsize_with_regs);\n       else\n \t/* Adding negative number is faster on the 68040.  */\n-\tasm_fprintf (stream, \"\\tlink\" ASM_DOTW \" %s,%I0\\n\"\n-\t\t\t     \"\\tadd\" ASM_DOT \"l %I%wd,%Rsp\\n\",\n-\t\t     M68K_REGNAME(FRAME_POINTER_REGNUM), -fsize_with_regs);\n+\tasm_fprintf (stream,\n+\t\t     \"\\tlink\" ASM_DOTW \" %s,%I0\\n\"\n+\t\t     \"\\tadd\" ASM_DOT \"l %I%wd,%Rsp\\n\",\n+\t\t     M68K_REGNAME (FRAME_POINTER_REGNUM), -fsize_with_regs);\n \n       if (dwarf2out_do_frame ())\n \t{\n@@ -593,13 +595,14 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \t    asm_fprintf (stream, \"\\tadd\" ASM_DOT \"w %I%wd,%Rsp\\n\",\n \t\t\t -fsize_with_regs);\n \t  else\n-\t    asm_fprintf (stream, MOTOROLA ?\n-\t\t\t\t   \"\\tlea (%wd,%Rsp),%Rsp\\n\" :\n-\t\t\t\t   \"\\tlea %Rsp@(%wd),%Rsp\\n\",\n+\t    asm_fprintf (stream, (MOTOROLA\n+\t\t\t\t  ? \"\\tlea (%wd,%Rsp),%Rsp\\n\"\n+\t\t\t\t  : \"\\tlea %Rsp@(%wd),%Rsp\\n\"),\n \t\t\t -fsize_with_regs);\n \t}\n       else /* fsize_with_regs >= 0x8000 */\n-\tasm_fprintf (stream, \"\\tadd\" ASM_DOT \"l %I%wd,%Rsp\\n\", -fsize_with_regs);\n+\tasm_fprintf (stream, \"\\tadd\" ASM_DOT \"l %I%wd,%Rsp\\n\",\n+\t\t     -fsize_with_regs);\n \n       if (dwarf2out_do_frame ())\n \t{\n@@ -610,9 +613,9 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \n   if (current_frame.fpu_mask)\n     {\n-      asm_fprintf (stream, MOTOROLA ?\n-\t\t\t     \"\\tfmovm %I0x%x,-(%Rsp)\\n\" :\n-\t\t\t     \"\\tfmovem %I0x%x,%Rsp@-\\n\",\n+      asm_fprintf (stream, (MOTOROLA\n+\t\t\t    ? \"\\tfmovm %I0x%x,-(%Rsp)\\n\"\n+\t\t\t    : \"\\tfmovem %I0x%x,%Rsp@-\\n\"),\n \t\t   current_frame.fpu_mask);\n \n       if (dwarf2out_do_frame ())\n@@ -635,7 +638,7 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n     {\n       if (REG_P (stack_limit_rtx))\n \tasm_fprintf (stream, \"\\tcmp\" ASM_DOT \"l %s,%Rsp\\n\\ttrapcs\\n\",\n-\t\t     M68K_REGNAME(REGNO (stack_limit_rtx)));\n+\t\t     M68K_REGNAME (REGNO (stack_limit_rtx)));\n       else if (GET_CODE (stack_limit_rtx) != SYMBOL_REF)\n \twarning (0, \"stack limit expression is not supported\");\n     }\n@@ -652,10 +655,10 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n       for (i = 0; i < 16; i++)\n         if (current_frame.reg_rev_mask & (1 << i))\n \t  {\n-\t    asm_fprintf (stream, MOTOROLA ?\n-\t\t\t\t   \"\\t%Omove.l %s,-(%Rsp)\\n\" :\n-\t\t\t\t   \"\\tmovel %s,%Rsp@-\\n\",\n-\t\t\t M68K_REGNAME(15 - i));\n+\t    asm_fprintf (stream, (MOTOROLA\n+\t\t\t\t  ? \"\\t%Omove.l %s,-(%Rsp)\\n\"\n+\t\t\t\t  : \"\\tmovel %s,%Rsp@-\\n\"),\n+\t\t\t M68K_REGNAME (15 - i));\n \t    if (dwarf2out_do_frame ())\n \t      {\n \t\tchar *l = (char *) dwarf2out_cfi_label ();\n@@ -676,14 +679,14 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \t   The required register save space was combined earlier with\n \t   the fsize_with_regs amount.  */\n \n-\tasm_fprintf (stream, MOTOROLA ?\n-\t\t\t       \"\\tmovm.l %I0x%x,(%Rsp)\\n\" :\n-\t\t\t       \"\\tmoveml %I0x%x,%Rsp@\\n\",\n+\tasm_fprintf (stream, (MOTOROLA\n+\t\t\t      ? \"\\tmovm.l %I0x%x,(%Rsp)\\n\"\n+\t\t\t      : \"\\tmoveml %I0x%x,%Rsp@\\n\"),\n \t\t     current_frame.reg_mask);\n       else\n-\tasm_fprintf (stream, MOTOROLA ?\n-\t\t\t       \"\\tmovm.l %I0x%x,-(%Rsp)\\n\" :\n-\t\t\t       \"\\tmoveml %I0x%x,%Rsp@-\\n\",\n+\tasm_fprintf (stream, (MOTOROLA\n+\t\t\t      ? \"\\tmovm.l %I0x%x,-(%Rsp)\\n\"\n+\t\t\t      : \"\\tmoveml %I0x%x,%Rsp@-\\n\"),\n \t\t     current_frame.reg_rev_mask);\n       if (dwarf2out_do_frame ())\n \t{\n@@ -698,29 +701,30 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \t      dwarf2out_reg_save (l, regno, -cfa_offset + n_regs++ * 4);\n \t}\n     }\n-  if (!TARGET_SEP_DATA && flag_pic &&\n-      (current_function_uses_pic_offset_table ||\n-        (!current_function_is_leaf && TARGET_ID_SHARED_LIBRARY)))\n+  if (!TARGET_SEP_DATA && flag_pic\n+      && (current_function_uses_pic_offset_table\n+\t  || (!current_function_is_leaf && TARGET_ID_SHARED_LIBRARY)))\n     {\n       if (TARGET_ID_SHARED_LIBRARY)\n \t{\n \t  asm_fprintf (stream, \"\\tmovel %s@(%s), %s\\n\",\n-\t\t       M68K_REGNAME(PIC_OFFSET_TABLE_REGNUM),\n+\t\t       M68K_REGNAME (PIC_OFFSET_TABLE_REGNUM),\n \t\t       m68k_library_id_string,\n-\t\t       M68K_REGNAME(PIC_OFFSET_TABLE_REGNUM));\n+\t\t       M68K_REGNAME (PIC_OFFSET_TABLE_REGNUM));\n \t}\n       else\n \t{\n \t  if (MOTOROLA)\n-\t    asm_fprintf (stream, \"\\t%Olea (%Rpc, %U_GLOBAL_OFFSET_TABLE_@GOTPC), %s\\n\",\n-\t\t\t M68K_REGNAME(PIC_OFFSET_TABLE_REGNUM));\n+\t    asm_fprintf (stream,\n+\t\t\t \"\\t%Olea (%Rpc, %U_GLOBAL_OFFSET_TABLE_@GOTPC), %s\\n\",\n+\t\t\t M68K_REGNAME (PIC_OFFSET_TABLE_REGNUM));\n \t  else\n \t    {\n \t      asm_fprintf (stream, \"\\tmovel %I%U_GLOBAL_OFFSET_TABLE_, %s\\n\",\n-\t\t\t   M68K_REGNAME(PIC_OFFSET_TABLE_REGNUM));\n+\t\t\t   M68K_REGNAME (PIC_OFFSET_TABLE_REGNUM));\n \t      asm_fprintf (stream, \"\\tlea %Rpc@(0,%s:l),%s\\n\",\n-\t\t\t   M68K_REGNAME(PIC_OFFSET_TABLE_REGNUM),\n-\t\t\t   M68K_REGNAME(PIC_OFFSET_TABLE_REGNUM));\n+\t\t\t   M68K_REGNAME (PIC_OFFSET_TABLE_REGNUM),\n+\t\t\t   M68K_REGNAME (PIC_OFFSET_TABLE_REGNUM));\n \t    }\n \t}\n     }\n@@ -736,7 +740,7 @@ use_return_insn (void)\n \n   /* We can output the epilogue as RTL only if no registers need to be\n      restored.  */\n-  m68k_compute_frame_layout();\n+  m68k_compute_frame_layout ();\n   return current_frame.reg_no ? false : true;\n }\n \n@@ -749,14 +753,15 @@ use_return_insn (void)\n    omit stack adjustments before returning.  */\n \n static void\n-m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n+m68k_output_function_epilogue (FILE *stream,\n+\t\t\t       HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT fsize, fsize_with_regs;\n   bool big = false;\n   bool restore_from_sp = false;\n   rtx insn = get_last_insn ();\n \n-  m68k_compute_frame_layout();\n+  m68k_compute_frame_layout ();\n \n   /* If the last insn was a BARRIER, we don't have to write any code.  */\n   if (GET_CODE (insn) == NOTE)\n@@ -775,11 +780,12 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \n   fsize = current_frame.size;\n \n-  /* FIXME : leaf_function_p below is too strong.\n+  /* FIXME: leaf_function_p below is too strong.\n      What we really need to know there is if there could be pending\n      stack adjustment needed at that point.  */\n-  restore_from_sp = ! frame_pointer_needed\n-\t     || (! current_function_calls_alloca && leaf_function_p ());\n+  restore_from_sp\n+    = (! frame_pointer_needed\n+       || (! current_function_calls_alloca && leaf_function_p ()));\n \n   /* fsize_with_regs is the size we need to adjust the sp when\n      popping the frame.  */\n@@ -823,64 +829,65 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \t\tif (MOTOROLA)\n \t\t  asm_fprintf (stream, \"\\t%Omove.l -%wd(%s,%Ra1.l),%s\\n\",\n \t\t\t       offset,\n-\t\t\t       M68K_REGNAME(FRAME_POINTER_REGNUM),\n-\t\t\t       M68K_REGNAME(i));\n+\t\t\t       M68K_REGNAME (FRAME_POINTER_REGNUM),\n+\t\t\t       M68K_REGNAME (i));\n \t\telse\n \t\t  asm_fprintf (stream, \"\\tmovel %s@(-%wd,%Ra1:l),%s\\n\",\n-\t\t\t       M68K_REGNAME(FRAME_POINTER_REGNUM),\n+\t\t\t       M68K_REGNAME (FRAME_POINTER_REGNUM),\n \t\t\t       offset,\n-\t\t\t       M68K_REGNAME(i));\n+\t\t\t       M68K_REGNAME (i));\n \t      }\n             else if (restore_from_sp)\n-\t      asm_fprintf (stream, MOTOROLA ?\n-\t\t\t\t     \"\\t%Omove.l (%Rsp)+,%s\\n\" :\n-\t\t\t\t     \"\\tmovel %Rsp@+,%s\\n\",\n-\t\t\t   M68K_REGNAME(i));\n+\t      asm_fprintf (stream, (MOTOROLA\n+\t\t\t\t    ? \"\\t%Omove.l (%Rsp)+,%s\\n\"\n+\t\t\t\t    : \"\\tmovel %Rsp@+,%s\\n\"),\n+\t\t\t   M68K_REGNAME (i));\n             else\n \t      {\n \t        if (MOTOROLA)\n \t\t  asm_fprintf (stream, \"\\t%Omove.l -%wd(%s),%s\\n\",\n \t\t\t       offset,\n-\t\t\t       M68K_REGNAME(FRAME_POINTER_REGNUM),\n-\t\t\t       M68K_REGNAME(i));\n+\t\t\t       M68K_REGNAME (FRAME_POINTER_REGNUM),\n+\t\t\t       M68K_REGNAME (i));\n \t\telse\n \t\t  asm_fprintf (stream, \"\\tmovel %s@(-%wd),%s\\n\",\n-\t\t\t       M68K_REGNAME(FRAME_POINTER_REGNUM),\n+\t\t\t       M68K_REGNAME (FRAME_POINTER_REGNUM),\n \t\t\t       offset,\n-\t\t\t       M68K_REGNAME(i));\n+\t\t\t       M68K_REGNAME (i));\n \t      }\n             offset -= 4;\n           }\n     }\n   else if (current_frame.reg_mask)\n     {\n-      /* The ColdFire requires special handling due to its limited moveml insn.  */\n+      /* The ColdFire requires special handling due to its limited moveml\n+\t insn.  */\n       if (TARGET_COLDFIRE)\n         {\n           if (big)\n             {\n               asm_fprintf (stream, \"\\tadd\" ASM_DOT \"l %s,%Ra1\\n\",\n-\t\t\t   M68K_REGNAME(FRAME_POINTER_REGNUM));\n-              asm_fprintf (stream, MOTOROLA ?\n-\t\t\t\t     \"\\tmovm.l (%Ra1),%I0x%x\\n\" :\n-\t\t\t\t     \"\\tmoveml %Ra1@,%I0x%x\\n\",\n+\t\t\t   M68K_REGNAME (FRAME_POINTER_REGNUM));\n+              asm_fprintf (stream, (MOTOROLA\n+\t\t\t\t    ? \"\\tmovm.l (%Ra1),%I0x%x\\n\"\n+\t\t\t\t    : \"\\tmoveml %Ra1@,%I0x%x\\n\"),\n \t\t\t   current_frame.reg_mask);\n \t     }\n \t   else if (restore_from_sp)\n-\t     asm_fprintf (stream, MOTOROLA ?\n-\t\t\t\t    \"\\tmovm.l (%Rsp),%I0x%x\\n\" :\n-\t\t\t\t    \"\\tmoveml %Rsp@,%I0x%x\\n\",\n+\t     asm_fprintf (stream, (MOTOROLA\n+\t\t\t\t   ? \"\\tmovm.l (%Rsp),%I0x%x\\n\"\n+\t\t\t\t   : \"\\tmoveml %Rsp@,%I0x%x\\n\"),\n \t\t\t  current_frame.reg_mask);\n           else\n             {\n \t      if (MOTOROLA)\n \t\tasm_fprintf (stream, \"\\tmovm.l -%wd(%s),%I0x%x\\n\",\n \t\t\t     current_frame.offset + fsize,\n-\t\t\t     M68K_REGNAME(FRAME_POINTER_REGNUM),\n+\t\t\t     M68K_REGNAME (FRAME_POINTER_REGNUM),\n \t\t\t     current_frame.reg_mask);\n \t      else\n \t\tasm_fprintf (stream, \"\\tmoveml %s@(-%wd),%I0x%x\\n\",\n-\t\t\t     M68K_REGNAME(FRAME_POINTER_REGNUM),\n+\t\t\t     M68K_REGNAME (FRAME_POINTER_REGNUM),\n \t\t\t     current_frame.offset + fsize,\n \t\t\t     current_frame.reg_mask);\n \t    }\n@@ -892,31 +899,31 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \t      if (MOTOROLA)\n \t\tasm_fprintf (stream, \"\\tmovm.l -%wd(%s,%Ra1.l),%I0x%x\\n\",\n \t\t\t     current_frame.offset + fsize,\n-\t\t\t     M68K_REGNAME(FRAME_POINTER_REGNUM),\n+\t\t\t     M68K_REGNAME (FRAME_POINTER_REGNUM),\n \t\t\t     current_frame.reg_mask);\n \t      else\n \t\tasm_fprintf (stream, \"\\tmoveml %s@(-%wd,%Ra1:l),%I0x%x\\n\",\n-\t\t\t     M68K_REGNAME(FRAME_POINTER_REGNUM),\n+\t\t\t     M68K_REGNAME (FRAME_POINTER_REGNUM),\n \t\t\t     current_frame.offset + fsize,\n \t\t\t     current_frame.reg_mask);\n \t    }\n \t  else if (restore_from_sp)\n \t    {\n-\t      asm_fprintf (stream, MOTOROLA ?\n-\t\t\t\t     \"\\tmovm.l (%Rsp)+,%I0x%x\\n\" :\n-\t\t\t\t     \"\\tmoveml %Rsp@+,%I0x%x\\n\",\n+\t      asm_fprintf (stream, (MOTOROLA\n+\t\t\t\t    ? \"\\tmovm.l (%Rsp)+,%I0x%x\\n\"\n+\t\t\t\t    : \"\\tmoveml %Rsp@+,%I0x%x\\n\"),\n \t\t\t   current_frame.reg_mask);\n \t    }\n \t  else\n \t    {\n \t      if (MOTOROLA)\n \t\tasm_fprintf (stream, \"\\tmovm.l -%wd(%s),%I0x%x\\n\",\n \t\t\t     current_frame.offset + fsize,\n-\t\t\t     M68K_REGNAME(FRAME_POINTER_REGNUM),\n+\t\t\t     M68K_REGNAME (FRAME_POINTER_REGNUM),\n \t\t\t     current_frame.reg_mask);\n \t      else\n \t\tasm_fprintf (stream, \"\\tmoveml %s@(-%wd),%I0x%x\\n\",\n-\t\t\t     M68K_REGNAME(FRAME_POINTER_REGNUM),\n+\t\t\t     M68K_REGNAME (FRAME_POINTER_REGNUM),\n \t\t\t     current_frame.offset + fsize,\n \t\t\t     current_frame.reg_mask);\n \t    }\n@@ -929,11 +936,11 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \t  if (MOTOROLA)\n \t    asm_fprintf (stream, \"\\tfmovm -%wd(%s,%Ra1.l),%I0x%x\\n\",\n \t\t         current_frame.foffset + fsize,\n-\t\t         M68K_REGNAME(FRAME_POINTER_REGNUM),\n+\t\t         M68K_REGNAME (FRAME_POINTER_REGNUM),\n \t\t         current_frame.fpu_rev_mask);\n \t  else\n \t    asm_fprintf (stream, \"\\tfmovem %s@(-%wd,%Ra1:l),%I0x%x\\n\",\n-\t\t\t M68K_REGNAME(FRAME_POINTER_REGNUM),\n+\t\t\t M68K_REGNAME (FRAME_POINTER_REGNUM),\n \t\t\t current_frame.foffset + fsize,\n \t\t\t current_frame.fpu_rev_mask);\n \t}\n@@ -951,17 +958,17 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \t  if (MOTOROLA)\n \t    asm_fprintf (stream, \"\\tfmovm -%wd(%s),%I0x%x\\n\",\n \t\t\t current_frame.foffset + fsize,\n-\t\t\t M68K_REGNAME(FRAME_POINTER_REGNUM),\n+\t\t\t M68K_REGNAME (FRAME_POINTER_REGNUM),\n \t\t\t current_frame.fpu_rev_mask);\n \t  else\n \t    asm_fprintf (stream, \"\\tfmovem %s@(-%wd),%I0x%x\\n\",\n-\t\t\t M68K_REGNAME(FRAME_POINTER_REGNUM),\n+\t\t\t M68K_REGNAME (FRAME_POINTER_REGNUM),\n \t\t\t current_frame.foffset + fsize,\n \t\t\t current_frame.fpu_rev_mask);\n \t}\n     }\n   if (frame_pointer_needed)\n-    fprintf (stream, \"\\tunlk %s\\n\", M68K_REGNAME(FRAME_POINTER_REGNUM));\n+    fprintf (stream, \"\\tunlk %s\\n\", M68K_REGNAME (FRAME_POINTER_REGNUM));\n   else if (fsize_with_regs)\n     {\n       if (fsize_with_regs <= 8)\n@@ -977,8 +984,9 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \t{\n \t  /* On the CPU32 it is faster to use two addqw instructions to\n \t     add a small integer (8 < N <= 16) to a register.  */\n-\t  asm_fprintf (stream, \"\\taddq\" ASM_DOT \"w %I8,%Rsp\\n\"\n-\t  \t\t       \"\\taddq\" ASM_DOT \"w %I%wd,%Rsp\\n\",\n+\t  asm_fprintf (stream,\n+\t\t       \"\\taddq\" ASM_DOT \"w %I8,%Rsp\\n\"\n+\t\t       \"\\taddq\" ASM_DOT \"w %I%wd,%Rsp\\n\",\n \t\t       fsize_with_regs - 8);\n \t}\n       else if (fsize_with_regs < 0x8000)\n@@ -987,16 +995,16 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \t    asm_fprintf (stream, \"\\tadd\" ASM_DOT \"w %I%wd,%Rsp\\n\",\n \t\t\t fsize_with_regs);\n \t  else\n-\t    asm_fprintf (stream, MOTOROLA ?\n-\t\t\t\t   \"\\tlea (%wd,%Rsp),%Rsp\\n\" :\n-\t\t\t\t   \"\\tlea %Rsp@(%wd),%Rsp\\n\",\n+\t    asm_fprintf (stream, (MOTOROLA\n+\t\t\t\t  ? \"\\tlea (%wd,%Rsp),%Rsp\\n\"\n+\t\t\t\t  : \"\\tlea %Rsp@(%wd),%Rsp\\n\"),\n \t\t\t fsize_with_regs);\n \t}\n       else\n \tasm_fprintf (stream, \"\\tadd\" ASM_DOT \"l %I%wd,%Rsp\\n\", fsize_with_regs);\n     }\n   if (current_function_calls_eh_return)\n-    asm_fprintf (stream, \"\\tadd\" ASM_DOT\"l %Ra0,%Rsp\\n\");\n+    asm_fprintf (stream, \"\\tadd\" ASM_DOT \"l %Ra0,%Rsp\\n\");\n   if (m68k_interrupt_function_p (current_function_decl))\n     fprintf (stream, \"\\trte\\n\");\n   else if (current_function_pops_args)\n@@ -1041,22 +1049,21 @@ flags_in_68881 (void)\n \n /* Output a BSR instruction suitable for PIC code.  */\n void\n-m68k_output_pic_call(rtx dest)\n+m68k_output_pic_call (rtx dest)\n {\n   const char *out;\n \n   if (!(GET_CODE (dest) == MEM && GET_CODE (XEXP (dest, 0)) == SYMBOL_REF))\n     out = \"jsr %0\";\n       /* We output a BSR instruction if we're using -fpic or we're building for\n-       * a target that supports long branches.  If we're building -fPIC on the\n-       * 68000, 68010 or ColdFire we generate one of two sequences:\n-       * a shorter one that uses a GOT entry or a longer one that doesn't.\n-       * We'll use the -Os command-line flag to decide which to generate.\n-       * Both sequences take the same time to execute on the ColdFire.\n-       */\n+\t a target that supports long branches.  If we're building -fPIC on the\n+\t 68000, 68010 or ColdFire we generate one of two sequences:\n+\t a shorter one that uses a GOT entry or a longer one that doesn't.\n+\t We'll use the -Os command-line flag to decide which to generate.\n+\t Both sequences take the same time to execute on the ColdFire.  */\n   else if (TARGET_PCREL)\n     out = \"bsr.l %o0\";\n-  else if ((flag_pic == 1) || TARGET_68020)\n+  else if (flag_pic == 1 || TARGET_68020)\n #if defined(USE_GAS)\n     out = \"bsr.l %0@PLTPC\";\n #else\n@@ -1067,7 +1074,7 @@ m68k_output_pic_call(rtx dest)\n   else\n     out = \"lea %0-.-8,%%a1\\n\\tjsr 0(%%pc,%%a1)\";\n \n-  output_asm_insn(out, &dest);\n+  output_asm_insn (out, &dest);\n }\n \n /* Output a dbCC; jCC sequence.  Note we do not handle the \n@@ -1082,72 +1089,72 @@ output_dbcc_and_branch (rtx *operands)\n   switch (GET_CODE (operands[3]))\n     {\n       case EQ:\n-\toutput_asm_insn (MOTOROLA ?\n-\t\t\t   \"dbeq %0,%l1\\n\\tjbeq %l2\" :\n-\t\t\t   \"dbeq %0,%l1\\n\\tjeq %l2\",\n+\toutput_asm_insn (MOTOROLA\n+\t\t\t ? \"dbeq %0,%l1\\n\\tjbeq %l2\"\n+\t\t\t : \"dbeq %0,%l1\\n\\tjeq %l2\",\n \t\t\t operands);\n \tbreak;\n \n       case NE:\n-\toutput_asm_insn (MOTOROLA ?\n-\t\t\t   \"dbne %0,%l1\\n\\tjbne %l2\" :\n-\t\t\t   \"dbne %0,%l1\\n\\tjne %l2\",\n+\toutput_asm_insn (MOTOROLA\n+\t\t\t ? \"dbne %0,%l1\\n\\tjbne %l2\"\n+\t\t\t : \"dbne %0,%l1\\n\\tjne %l2\",\n \t\t\t operands);\n \tbreak;\n \n       case GT:\n-\toutput_asm_insn (MOTOROLA ?\n-\t\t\t   \"dbgt %0,%l1\\n\\tjbgt %l2\" :\n-\t\t\t   \"dbgt %0,%l1\\n\\tjgt %l2\",\n+\toutput_asm_insn (MOTOROLA\n+\t\t\t ? \"dbgt %0,%l1\\n\\tjbgt %l2\"\n+\t\t\t : \"dbgt %0,%l1\\n\\tjgt %l2\",\n \t\t\t operands);\n \tbreak;\n \n       case GTU:\n-\toutput_asm_insn (MOTOROLA ?\n-\t\t\t   \"dbhi %0,%l1\\n\\tjbhi %l2\" :\n-\t\t\t   \"dbhi %0,%l1\\n\\tjhi %l2\",\n+\toutput_asm_insn (MOTOROLA\n+\t\t\t ? \"dbhi %0,%l1\\n\\tjbhi %l2\"\n+\t\t\t : \"dbhi %0,%l1\\n\\tjhi %l2\",\n \t\t\t operands);\n \tbreak;\n \n       case LT:\n-\toutput_asm_insn (MOTOROLA ?\n-\t\t\t   \"dblt %0,%l1\\n\\tjblt %l2\" :\n-\t\t\t   \"dblt %0,%l1\\n\\tjlt %l2\",\n+\toutput_asm_insn (MOTOROLA\n+\t\t\t ? \"dblt %0,%l1\\n\\tjblt %l2\"\n+\t\t\t : \"dblt %0,%l1\\n\\tjlt %l2\",\n \t\t\t operands);\n \tbreak;\n \n       case LTU:\n-\toutput_asm_insn (MOTOROLA ?\n-\t\t\t   \"dbcs %0,%l1\\n\\tjbcs %l2\" :\n-\t\t\t   \"dbcs %0,%l1\\n\\tjcs %l2\",\n+\toutput_asm_insn (MOTOROLA\n+\t\t\t ? \"dbcs %0,%l1\\n\\tjbcs %l2\"\n+\t\t\t : \"dbcs %0,%l1\\n\\tjcs %l2\",\n \t\t\t operands);\n \tbreak;\n \n       case GE:\n-\toutput_asm_insn (MOTOROLA ?\n-\t\t\t   \"dbge %0,%l1\\n\\tjbge %l2\" :\n-\t\t\t   \"dbge %0,%l1\\n\\tjge %l2\",\n+\toutput_asm_insn (MOTOROLA\n+\t\t\t ? \"dbge %0,%l1\\n\\tjbge %l2\"\n+\t\t\t : \"dbge %0,%l1\\n\\tjge %l2\",\n \t\t\t operands);\n \tbreak;\n \n       case GEU:\n-\toutput_asm_insn (MOTOROLA ?\n-\t\t\t   \"dbcc %0,%l1\\n\\tjbcc %l2\" :\n-\t\t\t   \"dbcc %0,%l1\\n\\tjcc %l2\",\n+\toutput_asm_insn (MOTOROLA\n+\t\t\t ? \"dbcc %0,%l1\\n\\tjbcc %l2\"\n+\t\t\t : \"dbcc %0,%l1\\n\\tjcc %l2\",\n \t\t\t operands);\n \tbreak;\n \n       case LE:\n-\toutput_asm_insn (MOTOROLA ?\n-\t\t\t   \"dble %0,%l1\\n\\tjble %l2\" :\n-\t\t\t   \"dble %0,%l1\\n\\tjle %l2\",\n+\toutput_asm_insn (MOTOROLA\n+\t\t\t ? \"dble %0,%l1\\n\\tjble %l2\"\n+\t\t\t : \"dble %0,%l1\\n\\tjle %l2\",\n \t\t\t operands);\n \tbreak;\n \n       case LEU:\n-\toutput_asm_insn (MOTOROLA ?\n-\t\t\t   \"dbls %0,%l1\\n\\tjbls %l2\" : \n-\t\t\t   \"dbls %0,%l1\\n\\tjls %l2\",\n+\toutput_asm_insn (MOTOROLA\n+\t\t\t ? \"dbls %0,%l1\\n\\tjbls %l2\"\n+\t\t\t : \"dbls %0,%l1\\n\\tjls %l2\",\n \t\t\t operands);\n \tbreak;\n \n@@ -1160,9 +1167,9 @@ output_dbcc_and_branch (rtx *operands)\n   switch (GET_MODE (operands[0]))\n     {\n       case SImode:\n-        output_asm_insn (MOTOROLA ?\n-\t\t\t   \"clr%.w %0\\n\\tsubq%.l #1,%0\\n\\tjbpl %l1\" :\n-\t\t\t   \"clr%.w %0\\n\\tsubq%.l #1,%0\\n\\tjpl %l1\",\n+        output_asm_insn (MOTOROLA\n+\t\t\t ? \"clr%.w %0\\n\\tsubq%.l #1,%0\\n\\tjbpl %l1\"\n+\t\t\t : \"clr%.w %0\\n\\tsubq%.l #1,%0\\n\\tjpl %l1\",\n \t\t\t operands);\n         break;\n \n@@ -1210,19 +1217,17 @@ output_scc_di (rtx op, rtx operand1, rtx operand2, rtx dest)\n   loperands[4] = gen_label_rtx ();\n   if (operand2 != const0_rtx)\n     {\n-      output_asm_insn (MOTOROLA ?\n-\t  \"cmp%.l %2,%0\\n\\tjbne %l4\\n\\tcmp%.l %3,%1\" :\n-          \"cmp%.l %2,%0\\n\\tjne %l4\\n\\tcmp%.l %3,%1\",\n-\tloperands);\n+      output_asm_insn (MOTOROLA\n+\t\t       ? \"cmp%.l %2,%0\\n\\tjbne %l4\\n\\tcmp%.l %3,%1\"\n+\t\t       : \"cmp%.l %2,%0\\n\\tjne %l4\\n\\tcmp%.l %3,%1\",\n+\t\t       loperands);\n     }\n   else\n     {\n       if (TARGET_68020 || TARGET_COLDFIRE || ! ADDRESS_REG_P (loperands[0]))\n \toutput_asm_insn (\"tst%.l %0\", loperands);\n       else\n-\t{\n-\t  output_asm_insn (\"cmp%.w #0,%0\", loperands);\n-\t}\n+\toutput_asm_insn (\"cmp%.w #0,%0\", loperands);\n \n       output_asm_insn (MOTOROLA ? \"jbne %l4\" : \"jne %l4\", loperands);\n \n@@ -1238,89 +1243,81 @@ output_scc_di (rtx op, rtx operand1, rtx operand2, rtx dest)\n     {\n       case EQ:\n         (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t    CODE_LABEL_NUMBER (loperands[4]));\n+\t\t\t\t\t   CODE_LABEL_NUMBER (loperands[4]));\n         output_asm_insn (\"seq %5\", loperands);\n         break;\n \n       case NE:\n         (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t    CODE_LABEL_NUMBER (loperands[4]));\n+\t\t\t\t\t   CODE_LABEL_NUMBER (loperands[4]));\n         output_asm_insn (\"sne %5\", loperands);\n         break;\n \n       case GT:\n         loperands[6] = gen_label_rtx ();\n-        output_asm_insn (MOTOROLA ?\n-\t\t\t   \"shi %5\\n\\tjbra %l6\" :\n-\t\t\t   \"shi %5\\n\\tjra %l6\",\n+        output_asm_insn (MOTOROLA ? \"shi %5\\n\\tjbra %l6\" : \"shi %5\\n\\tjra %l6\",\n \t\t\t loperands);\n         (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t    CODE_LABEL_NUMBER (loperands[4]));\n+\t\t\t\t\t   CODE_LABEL_NUMBER (loperands[4]));\n         output_asm_insn (\"sgt %5\", loperands);\n         (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t    CODE_LABEL_NUMBER (loperands[6]));\n+\t\t\t\t\t   CODE_LABEL_NUMBER (loperands[6]));\n         break;\n \n       case GTU:\n         (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t    CODE_LABEL_NUMBER (loperands[4]));\n+\t\t\t\t\t   CODE_LABEL_NUMBER (loperands[4]));\n         output_asm_insn (\"shi %5\", loperands);\n         break;\n \n       case LT:\n         loperands[6] = gen_label_rtx ();\n-        output_asm_insn (MOTOROLA ?\n-\t\t\t   \"scs %5\\n\\tjbra %l6\" :\n-\t\t\t   \"scs %5\\n\\tjra %l6\",\n+        output_asm_insn (MOTOROLA ? \"scs %5\\n\\tjbra %l6\" : \"scs %5\\n\\tjra %l6\",\n \t\t\t loperands);\n         (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t    CODE_LABEL_NUMBER (loperands[4]));\n+\t\t\t\t\t   CODE_LABEL_NUMBER (loperands[4]));\n         output_asm_insn (\"slt %5\", loperands);\n         (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t    CODE_LABEL_NUMBER (loperands[6]));\n+\t\t\t\t\t   CODE_LABEL_NUMBER (loperands[6]));\n         break;\n \n       case LTU:\n         (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t    CODE_LABEL_NUMBER (loperands[4]));\n+\t\t\t\t\t   CODE_LABEL_NUMBER (loperands[4]));\n         output_asm_insn (\"scs %5\", loperands);\n         break;\n \n       case GE:\n         loperands[6] = gen_label_rtx ();\n-        output_asm_insn (MOTOROLA ?\n-\t\t\t   \"scc %5\\n\\tjbra %l6\" :\n-\t\t\t   \"scc %5\\n\\tjra %l6\",\n-\t\t\t   loperands);\n+        output_asm_insn (MOTOROLA ? \"scc %5\\n\\tjbra %l6\" : \"scc %5\\n\\tjra %l6\",\n+\t\t\t loperands);\n         (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t    CODE_LABEL_NUMBER (loperands[4]));\n+\t\t\t\t\t   CODE_LABEL_NUMBER (loperands[4]));\n         output_asm_insn (\"sge %5\", loperands);\n         (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t    CODE_LABEL_NUMBER (loperands[6]));\n+\t\t\t\t\t   CODE_LABEL_NUMBER (loperands[6]));\n         break;\n \n       case GEU:\n         (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t    CODE_LABEL_NUMBER (loperands[4]));\n+\t\t\t\t\t   CODE_LABEL_NUMBER (loperands[4]));\n         output_asm_insn (\"scc %5\", loperands);\n         break;\n \n       case LE:\n         loperands[6] = gen_label_rtx ();\n-        output_asm_insn (MOTOROLA ?\n-\t\t\t   \"sls %5\\n\\tjbra %l6\" :\n-\t\t\t   \"sls %5\\n\\tjra %l6\",\n+        output_asm_insn (MOTOROLA ? \"sls %5\\n\\tjbra %l6\" : \"sls %5\\n\\tjra %l6\",\n \t\t\t loperands);\n         (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t    CODE_LABEL_NUMBER (loperands[4]));\n+\t\t\t\t\t   CODE_LABEL_NUMBER (loperands[4]));\n         output_asm_insn (\"sle %5\", loperands);\n         (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t    CODE_LABEL_NUMBER (loperands[6]));\n+\t\t\t\t\t   CODE_LABEL_NUMBER (loperands[6]));\n         break;\n \n       case LEU:\n         (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t    CODE_LABEL_NUMBER (loperands[4]));\n+\t\t\t\t\t   CODE_LABEL_NUMBER (loperands[4]));\n         output_asm_insn (\"sls %5\", loperands);\n         break;\n \n@@ -1459,7 +1456,7 @@ typedef enum { MOVL, SWAP, NEGW, NOTW, NOTB, MOVQ, MVS, MVZ } CONST_METHOD;\n \n static CONST_METHOD const_method (rtx);\n \n-#define USE_MOVQ(i)\t((unsigned)((i) + 128) <= 255)\n+#define USE_MOVQ(i)\t((unsigned) ((i) + 128) <= 255)\n \n static CONST_METHOD\n const_method (rtx constant)\n@@ -1510,21 +1507,21 @@ const_int_cost (rtx constant)\n {\n   switch (const_method (constant))\n     {\n-      case MOVQ :\n-      /* Constants between -128 and 127 are cheap due to moveq */\n-\treturn 0;\n-      case MVZ:\n-      case MVS:\n-      case NOTB :\n-      case NOTW :\n-      case NEGW :\n-      case SWAP :\n-      /* Constants easily generated by moveq + not.b/not.w/neg.w/swap  */\n-        return 1;\n-      case MOVL :\n-\treturn 2;\n-      default :\n-        gcc_unreachable ();\n+    case MOVQ:\n+      /* Constants between -128 and 127 are cheap due to moveq.  */\n+      return 0;\n+    case MVZ:\n+    case MVS:\n+    case NOTB:\n+    case NOTW:\n+    case NEGW:\n+    case SWAP:\n+      /* Constants easily generated by moveq + not.b/not.w/neg.w/swap.  */\n+      return 1;\n+    case MOVL:\n+      return 2;\n+    default:\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1562,10 +1559,13 @@ m68k_rtx_costs (rtx x, int code, int outer_code, int *total)\n        in synth_mult on the 68020, relative to an average of the time\n        for add and the time for shift, taking away a little more because\n        sometimes move insns are needed.  */\n-    /* div?.w is relatively cheaper on 68000 counted in COSTS_N_INSNS terms.  */\n-#define MULL_COST (TARGET_68060 ? 2 : TARGET_68040 ? 5 : (TARGET_COLDFIRE && !TARGET_5200) ? 3 : TARGET_COLDFIRE ? 10 : 13)\n-#define MULW_COST (TARGET_68060 ? 2 : TARGET_68040 ? 3 : TARGET_68020 ? 8 : \\\n-\t\t\t(TARGET_COLDFIRE && !TARGET_5200) ? 2 : 5)\n+    /* div?.w is relatively cheaper on 68000 counted in COSTS_N_INSNS\n+       terms.  */\n+#define MULL_COST (TARGET_68060 ? 2 : TARGET_68040 ? 5\t\t\\\n+\t\t   : (TARGET_COLDFIRE && !TARGET_5200) ? 3\t\\\n+\t\t   : TARGET_COLDFIRE ? 10 : 13)\n+#define MULW_COST (TARGET_68060 ? 2 : TARGET_68040 ? 3 : TARGET_68020 ? 8 \\\n+\t\t   : (TARGET_COLDFIRE && !TARGET_5200) ? 2 : 5)\n #define DIVW_COST (TARGET_68020 ? 27 : TARGET_CF_HWDIV ? 11 : 12)\n \n     case PLUS:\n@@ -1604,7 +1604,7 @@ m68k_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t        *total = COSTS_N_INSNS (4) + (INTVAL (XEXP (x, 1)) - 16) / 2;\n \t    }\n \t  else\n-\t    *total = COSTS_N_INSNS (10); /* worst case */\n+\t    *total = COSTS_N_INSNS (10); /* Worst case.  */\n \t  return true;\n         }\n       /* A shift by a big integer takes an extra instruction.  */\n@@ -1663,29 +1663,29 @@ output_move_const_into_data_reg (rtx *operands)\n       return \"mvsw %1,%0\";\n     case MVS:\n       return \"mvzw %1,%0\";\n-    case MOVQ :\n+    case MOVQ:\n       return \"moveq %1,%0\";\n-    case NOTB :\n+    case NOTB:\n       CC_STATUS_INIT;\n       operands[1] = GEN_INT (i ^ 0xff);\n       return \"moveq %1,%0\\n\\tnot%.b %0\";\n-    case NOTW :\n+    case NOTW:\n       CC_STATUS_INIT;\n       operands[1] = GEN_INT (i ^ 0xffff);\n       return \"moveq %1,%0\\n\\tnot%.w %0\";\n-    case NEGW :\n+    case NEGW:\n       CC_STATUS_INIT;\n       return \"moveq #-128,%0\\n\\tneg%.w %0\";\n-    case SWAP :\n+    case SWAP:\n       {\n \tunsigned u = i;\n \n \toperands[1] = GEN_INT ((u << 16) | (u >> 16));\n \treturn \"moveq %1,%0\\n\\tswap %0\";\n       }\n-    case MOVL :\n+    case MOVL:\n \treturn \"move%.l %1,%0\";\n-    default :\n+    default:\n \tgcc_unreachable ();\n     }\n }\n@@ -1700,7 +1700,7 @@ valid_mov3q_const (rtx constant)\n   if (TARGET_CFV4 && GET_CODE (constant) == CONST_INT)\n     {\n       i = INTVAL (constant);\n-      if ((i == -1) || (i >= 1 && i <= 7))\n+      if (i == -1 || (i >= 1 && i <= 7))\n \treturn 1;\n     }\n   return 0;\n@@ -1721,7 +1721,7 @@ output_move_simode_const (rtx *operands)\n     return \"clr%.l %0\";\n   else if ((GET_MODE (operands[0]) == SImode)\n            && valid_mov3q_const (operands[1]))\n-      return \"mov3q%.l %1,%0\";\n+    return \"mov3q%.l %1,%0\";\n   else if (operands[1] == const0_rtx\n \t   && ADDRESS_REG_P (operands[0]))\n     return \"sub%.l %0,%0\";\n@@ -1736,8 +1736,8 @@ output_move_simode_const (rtx *operands)\n       return \"move%.w %1,%0\";\n     }\n   else if (GET_CODE (operands[0]) == MEM\n-      && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC\n-      && REGNO (XEXP (XEXP (operands[0], 0), 0)) == STACK_POINTER_REGNUM\n+\t   && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC\n+\t   && REGNO (XEXP (XEXP (operands[0], 0), 0)) == STACK_POINTER_REGNUM\n \t   && INTVAL (operands[1]) < 0x8000\n \t   && INTVAL (operands[1]) >= -0x8000)\n     {\n@@ -1784,9 +1784,7 @@ output_move_himode (rtx *operands)\n       else if (DATA_REG_P (operands[0])\n \t       && INTVAL (operands[1]) < 128\n \t       && INTVAL (operands[1]) >= -128)\n-\t{\n-\t  return \"moveq %1,%0\";\n-\t}\n+\treturn \"moveq %1,%0\";\n       else if (INTVAL (operands[1]) < 0x8000\n \t       && INTVAL (operands[1]) >= -0x8000)\n \treturn \"move%.w %1,%0\";\n@@ -1810,7 +1808,7 @@ output_move_himode (rtx *operands)\n \t\t     CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n       else\n \t(*targetm.asm_out.internal_label) (asm_out_file, \"LI\",\n-\t\t     CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n+\t\t\t\t\t   CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n     }\n   return \"move%.w %1,%0\";\n }\n@@ -1821,7 +1819,7 @@ output_move_qimode (rtx *operands)\n   /* 68k family always modifies the stack pointer by at least 2, even for\n      byte pushes.  The 5200 (ColdFire) does not do this.  */\n   \n-  /* This case is generated by pushqi1 pattern now */\n+  /* This case is generated by pushqi1 pattern now.  */\n   gcc_assert (!(GET_CODE (operands[0]) == MEM\n \t\t&& GET_CODE (XEXP (operands[0], 0)) == PRE_DEC\n \t\t&& XEXP (XEXP (operands[0], 0), 0) == stack_pointer_rtx\n@@ -1848,9 +1846,7 @@ output_move_qimode (rtx *operands)\n       && DATA_REG_P (operands[0])\n       && INTVAL (operands[1]) < 128\n       && INTVAL (operands[1]) >= -128)\n-    {\n-      return \"moveq %1,%0\";\n-    }\n+    return \"moveq %1,%0\";\n   if (operands[1] == const0_rtx && ADDRESS_REG_P (operands[0]))\n     return \"sub%.l %0,%0\";\n   if (GET_CODE (operands[1]) != CONST_INT && CONSTANT_P (operands[1]))\n@@ -2348,9 +2344,7 @@ notice_update_cc (rtx exp, rtx insn)\n   if (GET_CODE (exp) == SET)\n     {\n       if (GET_CODE (SET_SRC (exp)) == CALL)\n-\t{\n-\t  CC_STATUS_INIT; \n-\t}\n+\tCC_STATUS_INIT; \n       else if (ADDRESS_REG_P (SET_DEST (exp)))\n \t{\n \t  if (cc_status.value1 && modified_in_p (cc_status.value1, insn))\n@@ -2364,23 +2358,17 @@ notice_update_cc (rtx exp, rtx insn)\n \t\t   || GET_CODE (SET_SRC (exp)) == FIX\n \t\t   || GET_CODE (SET_SRC (exp)) == FLOAT_TRUNCATE\n \t\t   || GET_CODE (SET_SRC (exp)) == FLOAT_EXTEND))\n-\t{\n-\t  CC_STATUS_INIT; \n-\t}\n+\tCC_STATUS_INIT; \n       /* A pair of move insns doesn't produce a useful overall cc.  */\n       else if (!FP_REG_P (SET_DEST (exp))\n \t       && !FP_REG_P (SET_SRC (exp))\n \t       && GET_MODE_SIZE (GET_MODE (SET_SRC (exp))) > 4\n \t       && (GET_CODE (SET_SRC (exp)) == REG\n \t\t   || GET_CODE (SET_SRC (exp)) == MEM\n \t\t   || GET_CODE (SET_SRC (exp)) == CONST_DOUBLE))\n-\t{\n-\t  CC_STATUS_INIT; \n-\t}\n+\tCC_STATUS_INIT; \n       else if (GET_CODE (SET_SRC (exp)) == CALL)\n-\t{\n-\t  CC_STATUS_INIT; \n-\t}\n+\tCC_STATUS_INIT; \n       else if (XEXP (exp, 0) != pc_rtx)\n \t{\n \t  cc_status.flags = 0;\n@@ -2489,7 +2477,7 @@ static const char *const strings_68881[7] = {\n   \"10000.0\",\n   \"1e8\",\n   \"1e16\"\n-  };\n+};\n \n static const int codes_68881[7] = {\n   0x0f,\n@@ -2499,7 +2487,7 @@ static const int codes_68881[7] = {\n   0x35,\n   0x36,\n   0x37\n-  };\n+};\n \n REAL_VALUE_TYPE values_68881[7];\n \n@@ -2747,11 +2735,11 @@ print_operand (FILE *file, rtx op, int letter)\n    -fPIC code the offset is output in long mode (e.g. movel a5@(_foo:l), a0) */\n \n #if MOTOROLA\n-#  define ASM_OUTPUT_CASE_FETCH(file, labelno, regname)\\\n-\tasm_fprintf (file, \"%LL%d-%LLI%d.b(%Rpc,%s.\", labelno, labelno, regname)\n+#  define ASM_OUTPUT_CASE_FETCH(file, labelno, regname) \\\n+  asm_fprintf (file, \"%LL%d-%LLI%d.b(%Rpc,%s.\", labelno, labelno, regname)\n #else /* !MOTOROLA */\n-# define ASM_OUTPUT_CASE_FETCH(file, labelno, regname)\\\n-\tasm_fprintf (file, \"%Rpc@(%LL%d-%LLI%d-2:b,%s:\", labelno, labelno, regname)\n+# define ASM_OUTPUT_CASE_FETCH(file, labelno, regname) \\\n+  asm_fprintf (file, \"%Rpc@(%LL%d-%LLI%d-2:b,%s:\", labelno, labelno, regname)\n #endif /* !MOTOROLA */\n \n void\n@@ -2762,251 +2750,249 @@ print_operand_address (FILE *file, rtx addr)\n \n   switch (GET_CODE (addr))\n     {\n-      case REG:\n-\tfprintf (file, MOTOROLA ? \"(%s)\" : \"%s@\", M68K_REGNAME(REGNO (addr)));\n-\tbreak;\n-      case PRE_DEC:\n-\tfprintf (file, MOTOROLA ? \"-(%s)\" : \"%s@-\",\n-\t         M68K_REGNAME(REGNO (XEXP (addr, 0))));\n-\tbreak;\n-      case POST_INC:\n-\tfprintf (file, MOTOROLA ? \"(%s)+\" : \"%s@+\",\n-\t\t M68K_REGNAME(REGNO (XEXP (addr, 0))));\n-\tbreak;\n-      case PLUS:\n-\treg1 = reg2 = ireg = breg = offset = 0;\n-\tif (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\n-\t  {\n-\t    offset = XEXP (addr, 0);\n-\t    addr = XEXP (addr, 1);\n-\t  }\n-\telse if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\n-\t  {\n-\t    offset = XEXP (addr, 1);\n-\t    addr = XEXP (addr, 0);\n-\t  }\n-\tif (GET_CODE (addr) != PLUS)\n-\t  {\n-\t    ;\n-\t  }\n-\telse if (GET_CODE (XEXP (addr, 0)) == SIGN_EXTEND)\n-\t  {\n-\t    reg1 = XEXP (addr, 0);\n-\t    addr = XEXP (addr, 1);\n-\t  }\n-\telse if (GET_CODE (XEXP (addr, 1)) == SIGN_EXTEND)\n-\t  {\n-\t    reg1 = XEXP (addr, 1);\n-\t    addr = XEXP (addr, 0);\n-\t  }\n-\telse if (GET_CODE (XEXP (addr, 0)) == MULT)\n-\t  {\n-\t    reg1 = XEXP (addr, 0);\n-\t    addr = XEXP (addr, 1);\n-\t  }\n-\telse if (GET_CODE (XEXP (addr, 1)) == MULT)\n-\t  {\n-\t    reg1 = XEXP (addr, 1);\n-\t    addr = XEXP (addr, 0);\n-\t  }\n-\telse if (GET_CODE (XEXP (addr, 0)) == REG)\n-\t  {\n-\t    reg1 = XEXP (addr, 0);\n-\t    addr = XEXP (addr, 1);\n-\t  }\n-\telse if (GET_CODE (XEXP (addr, 1)) == REG)\n-\t  {\n-\t    reg1 = XEXP (addr, 1);\n-\t    addr = XEXP (addr, 0);\n-\t  }\n-\tif (GET_CODE (addr) == REG || GET_CODE (addr) == MULT\n-\t    || GET_CODE (addr) == SIGN_EXTEND)\n-\t  {\n-\t    if (reg1 == 0)\n-\t      {\n-\t\treg1 = addr;\n-\t      }\n-\t    else\n-\t      {\n-\t\treg2 = addr;\n-\t      }\n-\t    addr = 0;\n-\t  }\n+    case REG:\n+      fprintf (file, MOTOROLA ? \"(%s)\" : \"%s@\", M68K_REGNAME (REGNO (addr)));\n+      break;\n+    case PRE_DEC:\n+      fprintf (file, MOTOROLA ? \"-(%s)\" : \"%s@-\",\n+\t       M68K_REGNAME (REGNO (XEXP (addr, 0))));\n+      break;\n+    case POST_INC:\n+      fprintf (file, MOTOROLA ? \"(%s)+\" : \"%s@+\",\n+\t       M68K_REGNAME (REGNO (XEXP (addr, 0))));\n+      break;\n+    case PLUS:\n+      reg1 = reg2 = ireg = breg = offset = 0;\n+      if (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\n+\t{\n+\t  offset = XEXP (addr, 0);\n+\t  addr = XEXP (addr, 1);\n+\t}\n+      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\n+\t{\n+\t  offset = XEXP (addr, 1);\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      if (GET_CODE (addr) != PLUS)\n+\t{\n+\t  ;\n+\t}\n+      else if (GET_CODE (XEXP (addr, 0)) == SIGN_EXTEND)\n+\t{\n+\t  reg1 = XEXP (addr, 0);\n+\t  addr = XEXP (addr, 1);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 1)) == SIGN_EXTEND)\n+\t{\n+\t  reg1 = XEXP (addr, 1);\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 0)) == MULT)\n+\t{\n+\t  reg1 = XEXP (addr, 0);\n+\t  addr = XEXP (addr, 1);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 1)) == MULT)\n+\t{\n+\t  reg1 = XEXP (addr, 1);\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 0)) == REG)\n+\t{\n+\t  reg1 = XEXP (addr, 0);\n+\t  addr = XEXP (addr, 1);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\n+\t{\n+\t  reg1 = XEXP (addr, 1);\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT\n+\t  || GET_CODE (addr) == SIGN_EXTEND)\n+\t{\n+\t  if (reg1 == 0)\n+\t    reg1 = addr;\n+\t  else\n+\t    reg2 = addr;\n+\t  addr = 0;\n+\t}\n #if 0\t/* for OLD_INDEXING */\n-\telse if (GET_CODE (addr) == PLUS)\n-\t  {\n-\t    if (GET_CODE (XEXP (addr, 0)) == REG)\n-\t      {\n-\t\treg2 = XEXP (addr, 0);\n-\t\taddr = XEXP (addr, 1);\n-\t      }\n-\t    else if (GET_CODE (XEXP (addr, 1)) == REG)\n-\t      {\n-\t\treg2 = XEXP (addr, 1);\n-\t\taddr = XEXP (addr, 0);\n-\t      }\n-\t  }\n+      else if (GET_CODE (addr) == PLUS)\n+\t{\n+\t  if (GET_CODE (XEXP (addr, 0)) == REG)\n+\t    {\n+\t      reg2 = XEXP (addr, 0);\n+\t      addr = XEXP (addr, 1);\n+\t    }\n+\t  else if (GET_CODE (XEXP (addr, 1)) == REG)\n+\t    {\n+\t      reg2 = XEXP (addr, 1);\n+\t      addr = XEXP (addr, 0);\n+\t    }\n+\t}\n #endif\n-\tif (offset != 0)\n-\t  {\n-\t    gcc_assert (!addr);\n-\t    addr = offset;\n-\t  }\n-\tif ((reg1 && (GET_CODE (reg1) == SIGN_EXTEND\n-\t\t      || GET_CODE (reg1) == MULT))\n-\t    || (reg2 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg2))))\n-\t  {\n-\t    breg = reg2;\n-\t    ireg = reg1;\n-\t  }\n-\telse if (reg1 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg1)))\n-\t  {\n-\t    breg = reg1;\n-\t    ireg = reg2;\n-\t  }\n-\tif (ireg != 0 && breg == 0 && GET_CODE (addr) == LABEL_REF\n-\t    && ! (flag_pic && ireg == pic_offset_table_rtx))\n-\t  {\n-\t    int scale = 1;\n-\t    if (GET_CODE (ireg) == MULT)\n-\t      {\n-\t\tscale = INTVAL (XEXP (ireg, 1));\n-\t\tireg = XEXP (ireg, 0);\n-\t      }\n-\t    if (GET_CODE (ireg) == SIGN_EXTEND)\n-\t      {\n-\t\tASM_OUTPUT_CASE_FETCH (file,\n-\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t     M68K_REGNAME(REGNO (XEXP (ireg, 0))));\n-\t\tfprintf (file, \"w\");\n-\t      }\n-\t    else\n-\t      {\n-\t\tASM_OUTPUT_CASE_FETCH (file,\n-\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t     M68K_REGNAME(REGNO (ireg)));\n-\t\tfprintf (file, \"l\");\n-\t      }\n-\t    if (scale != 1)\n-\t      fprintf (file, MOTOROLA ? \"*%d\" : \":%d\", scale);\n-\t    putc (')', file);\n-\t    break;\n-\t  }\n-\tif (breg != 0 && ireg == 0 && GET_CODE (addr) == LABEL_REF\n-\t    && ! (flag_pic && breg == pic_offset_table_rtx))\n-\t  {\n-\t    ASM_OUTPUT_CASE_FETCH (file,\n-\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t M68K_REGNAME(REGNO (breg)));\n-\t    fprintf (file, \"l)\");\n-\t    break;\n-\t  }\n-\tif (ireg != 0 || breg != 0)\n-\t  {\n-\t    int scale = 1;\n+      if (offset != 0)\n+\t{\n+\t  gcc_assert (!addr);\n+\t  addr = offset;\n+\t}\n+      if ((reg1 && (GET_CODE (reg1) == SIGN_EXTEND\n+\t\t    || GET_CODE (reg1) == MULT))\n+\t  || (reg2 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg2))))\n+\t{\n+\t  breg = reg2;\n+\t  ireg = reg1;\n+\t}\n+      else if (reg1 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg1)))\n+\t{\n+\t  breg = reg1;\n+\t  ireg = reg2;\n+\t}\n+      if (ireg != 0 && breg == 0 && GET_CODE (addr) == LABEL_REF\n+\t  && ! (flag_pic && ireg == pic_offset_table_rtx))\n+\t{\n+\t  int scale = 1;\n+\t  if (GET_CODE (ireg) == MULT)\n+\t    {\n+\t      scale = INTVAL (XEXP (ireg, 1));\n+\t      ireg = XEXP (ireg, 0);\n+\t    }\n+\t  if (GET_CODE (ireg) == SIGN_EXTEND)\n+\t    {\n+\t      ASM_OUTPUT_CASE_FETCH (file,\n+\t\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t\t     M68K_REGNAME (REGNO (XEXP (ireg, 0))));\n+\t      fprintf (file, \"w\");\n+\t    }\n+\t  else\n+\t    {\n+\t      ASM_OUTPUT_CASE_FETCH (file,\n+\t\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t\t     M68K_REGNAME (REGNO (ireg)));\n+\t      fprintf (file, \"l\");\n+\t    }\n+\t  if (scale != 1)\n+\t    fprintf (file, MOTOROLA ? \"*%d\" : \":%d\", scale);\n+\t  putc (')', file);\n+\t  break;\n+\t}\n+      if (breg != 0 && ireg == 0 && GET_CODE (addr) == LABEL_REF\n+\t  && ! (flag_pic && breg == pic_offset_table_rtx))\n+\t{\n+\t  ASM_OUTPUT_CASE_FETCH (file,\n+\t\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t\t M68K_REGNAME (REGNO (breg)));\n+\t  fprintf (file, \"l)\");\n+\t  break;\n+\t}\n+      if (ireg != 0 || breg != 0)\n+\t{\n+\t  int scale = 1;\n \t    \n-\t    gcc_assert (breg);\n-\t    gcc_assert (flag_pic || !addr || GET_CODE (addr) != LABEL_REF);\n+\t  gcc_assert (breg);\n+\t  gcc_assert (flag_pic || !addr || GET_CODE (addr) != LABEL_REF);\n \t    \n-\t    if (MOTOROLA)\n-\t      {\n-\t\tif (addr != 0)\n-\t\t  {\n-\t\t    output_addr_const (file, addr);\n-\t            if (flag_pic && (breg == pic_offset_table_rtx))\n+\t  if (MOTOROLA)\n+\t    {\n+\t      if (addr != 0)\n+\t\t{\n+\t\t  output_addr_const (file, addr);\n+\t\t  if (flag_pic && (breg == pic_offset_table_rtx))\n+\t\t    {\n+\t\t      fprintf (file, \"@GOT\");\n+\t\t      if (flag_pic == 1)\n+\t\t\tfprintf (file, \".w\");\n+\t\t    }\n+\t\t}\n+\t      fprintf (file, \"(%s\", M68K_REGNAME (REGNO (breg)));\n+\t      if (ireg != 0)\n+\t\tputc (',', file);\n+\t    }\n+\t  else /* !MOTOROLA */\n+\t    {\n+\t      fprintf (file, \"%s@(\", M68K_REGNAME (REGNO (breg)));\n+\t      if (addr != 0)\n+\t\t{\n+\t\t  output_addr_const (file, addr);\n+\t\t  if (breg == pic_offset_table_rtx)\n+\t\t    switch (flag_pic)\n \t\t      {\n-\t\t\tfprintf (file, \"@GOT\");\n-\t\t\tif (flag_pic == 1)\n-\t\t\t  fprintf (file, \".w\");\n+\t\t      case 1:\n+\t\t\tfprintf (file, \":w\");\n+\t\t\tbreak;\n+\t\t      case 2:\n+\t\t\tfprintf (file, \":l\");\n+\t\t\tbreak;\n+\t\t      default:\n+\t\t\tbreak;\n \t\t      }\n-\t\t  }\n-\t\tfprintf (file, \"(%s\", M68K_REGNAME(REGNO (breg)));\n-\t\tif (ireg != 0)\n-\t\t  putc (',', file);\n-\t      }\n-\t    else /* !MOTOROLA */\n-\t      {\n-\t\tfprintf (file, \"%s@(\", M68K_REGNAME(REGNO (breg)));\n-\t\tif (addr != 0)\n-\t\t  {\n-\t\t    output_addr_const (file, addr);\n-\t\t    if (breg == pic_offset_table_rtx)\n-\t\t      switch (flag_pic)\n-\t\t        {\n-\t\t        case 1:\n-\t\t          fprintf (file, \":w\"); break;\n-\t\t        case 2:\n-\t\t          fprintf (file, \":l\"); break;\n-\t\t        default:\n-\t\t          break;\n-\t\t        }\n-\t\t    if (ireg != 0)\n-\t\t      putc (',', file);\n-\t\t  }\n-\t      } /* !MOTOROLA */\n-\t    if (ireg != 0 && GET_CODE (ireg) == MULT)\n-\t      {\n-\t\tscale = INTVAL (XEXP (ireg, 1));\n-\t\tireg = XEXP (ireg, 0);\n-\t      }\n-\t    if (ireg != 0 && GET_CODE (ireg) == SIGN_EXTEND)\n-\t      fprintf (file, MOTOROLA ? \"%s.w\" : \"%s:w\",\n-\t\t       M68K_REGNAME(REGNO (XEXP (ireg, 0))));\n-\t    else if (ireg != 0)\n-\t      fprintf (file, MOTOROLA ? \"%s.l\" : \"%s:l\",\n-\t\t       M68K_REGNAME(REGNO (ireg)));\n-\t    if (scale != 1)\n-\t      fprintf (file, MOTOROLA ? \"*%d\" : \":%d\", scale);\n-\t    putc (')', file);\n-\t    break;\n-\t  }\n-\telse if (reg1 != 0 && GET_CODE (addr) == LABEL_REF\n-\t\t && ! (flag_pic && reg1 == pic_offset_table_rtx))\n-\t  {\n-\t    ASM_OUTPUT_CASE_FETCH (file,\n-\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t M68K_REGNAME(REGNO (reg1)));\n-\t    fprintf (file, \"l)\");\n-\t    break;\n-\t  }\n-\t/* FALL-THROUGH (is this really what we want?)  */\n-      default:\n-        if (GET_CODE (addr) == CONST_INT\n-\t    && INTVAL (addr) < 0x8000\n-\t    && INTVAL (addr) >= -0x8000)\n-\t  {\n-\t    fprintf (file, MOTOROLA ? \"%d.w\" : \"%d:w\", (int) INTVAL (addr));\n-\t  }\n-\telse if (GET_CODE (addr) == CONST_INT)\n-\t  {\n-\t    fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (addr));\n-\t  }\n-\telse if (TARGET_PCREL)\n-\t  {\n-\t    fputc ('(', file);\n-\t    output_addr_const (file, addr);\n-\t    if (flag_pic == 1)\n-\t      asm_fprintf (file, \":w,%Rpc)\");\n-\t    else\n-\t      asm_fprintf (file, \":l,%Rpc)\");\n-\t  }\n-\telse\n-\t  {\n-\t    /* Special case for SYMBOL_REF if the symbol name ends in\n-\t       `.<letter>', this can be mistaken as a size suffix.  Put\n-\t       the name in parentheses.  */\n-\t    if (GET_CODE (addr) == SYMBOL_REF\n-\t\t&& strlen (XSTR (addr, 0)) > 2\n-\t\t&& XSTR (addr, 0)[strlen (XSTR (addr, 0)) - 2] == '.')\n-\t      {\n-\t\tputc ('(', file);\n-\t\toutput_addr_const (file, addr);\n-\t\tputc (')', file);\n-\t      }\n-\t    else\n+\t\t  if (ireg != 0)\n+\t\t    putc (',', file);\n+\t\t}\n+\t    } /* !MOTOROLA */\n+\t  if (ireg != 0 && GET_CODE (ireg) == MULT)\n+\t    {\n+\t      scale = INTVAL (XEXP (ireg, 1));\n+\t      ireg = XEXP (ireg, 0);\n+\t    }\n+\t  if (ireg != 0 && GET_CODE (ireg) == SIGN_EXTEND)\n+\t    fprintf (file, MOTOROLA ? \"%s.w\" : \"%s:w\",\n+\t\t     M68K_REGNAME (REGNO (XEXP (ireg, 0))));\n+\t  else if (ireg != 0)\n+\t    fprintf (file, MOTOROLA ? \"%s.l\" : \"%s:l\",\n+\t\t     M68K_REGNAME (REGNO (ireg)));\n+\t  if (scale != 1)\n+\t    fprintf (file, MOTOROLA ? \"*%d\" : \":%d\", scale);\n+\t  putc (')', file);\n+\t  break;\n+\t}\n+      else if (reg1 != 0 && GET_CODE (addr) == LABEL_REF\n+\t       && ! (flag_pic && reg1 == pic_offset_table_rtx))\n+\t{\n+\t  ASM_OUTPUT_CASE_FETCH (file,\n+\t\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n+\t\t\t\t M68K_REGNAME (REGNO (reg1)));\n+\t  fprintf (file, \"l)\");\n+\t  break;\n+\t}\n+      /* FALL-THROUGH (is this really what we want?)  */\n+    default:\n+      if (GET_CODE (addr) == CONST_INT\n+\t  && INTVAL (addr) < 0x8000\n+\t  && INTVAL (addr) >= -0x8000)\n+\t{\n+\t  fprintf (file, MOTOROLA ? \"%d.w\" : \"%d:w\", (int) INTVAL (addr));\n+\t}\n+      else if (GET_CODE (addr) == CONST_INT)\n+\t{\n+\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (addr));\n+\t}\n+      else if (TARGET_PCREL)\n+\t{\n+\t  fputc ('(', file);\n+\t  output_addr_const (file, addr);\n+\t  if (flag_pic == 1)\n+\t    asm_fprintf (file, \":w,%Rpc)\");\n+\t  else\n+\t    asm_fprintf (file, \":l,%Rpc)\");\n+\t}\n+      else\n+\t{\n+\t  /* Special case for SYMBOL_REF if the symbol name ends in\n+\t     `.<letter>', this can be mistaken as a size suffix.  Put\n+\t     the name in parentheses.  */\n+\t  if (GET_CODE (addr) == SYMBOL_REF\n+\t      && strlen (XSTR (addr, 0)) > 2\n+\t      && XSTR (addr, 0)[strlen (XSTR (addr, 0)) - 2] == '.')\n+\t    {\n+\t      putc ('(', file);\n \t      output_addr_const (file, addr);\n-\t  }\n-\tbreak;\n+\t      putc (')', file);\n+\t    }\n+\t  else\n+\t    output_addr_const (file, addr);\n+\t}\n+      break;\n     }\n }\n \f\n@@ -3148,9 +3134,7 @@ output_andsi3 (rtx *operands)\n           || offsettable_memref_p (operands[0])))\n     {\n       if (DATA_REG_P (operands[0]))\n-        {\n-          operands[1] = GEN_INT (logval);\n-        }\n+\toperands[1] = GEN_INT (logval);\n       else\n         {\n \t  operands[0] = adjust_address (operands[0], SImode, 3 - (logval / 8));\n@@ -3264,36 +3248,38 @@ m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n   const char *fmt;\n \n   if (delta > 0 && delta <= 8)\n-    asm_fprintf (file, MOTOROLA ?\n-\t\t\t \"\\taddq.l %I%d,4(%Rsp)\\n\" :\n-\t\t\t \"\\taddql %I%d,%Rsp@(4)\\n\",\n+    asm_fprintf (file, (MOTOROLA\n+\t\t\t? \"\\taddq.l %I%d,4(%Rsp)\\n\"\n+\t\t\t: \"\\taddql %I%d,%Rsp@(4)\\n\"),\n \t\t (int) delta);\n   else if (delta < 0 && delta >= -8)\n-    asm_fprintf (file, MOTOROLA ?\n-\t\t\t \"\\tsubq.l %I%d,4(%Rsp)\\n\" :\n-\t\t\t \"\\tsubql %I%d,%Rsp@(4)\\n\",\n+    asm_fprintf (file, (MOTOROLA\n+\t\t\t? \"\\tsubq.l %I%d,4(%Rsp)\\n\"\n+\t\t\t: \"\\tsubql %I%d,%Rsp@(4)\\n\"),\n \t\t (int) -delta);\n   else if (TARGET_COLDFIRE)\n     {\n       /* ColdFire can't add/sub a constant to memory unless it is in\n \t the range of addq/subq.  So load the value into %d0 and\n \t then add it to 4(%sp). */\n       if (delta >= -128 && delta <= 127)\n-\tasm_fprintf (file, MOTOROLA ?\n-\t\t     \"\\tmoveq.l %I%wd,%Rd0\\n\" :\n-\t\t     \"\\tmoveql %I%wd,%Rd0\\n\", delta);\n+\tasm_fprintf (file, (MOTOROLA\n+\t\t\t    ? \"\\tmoveq.l %I%wd,%Rd0\\n\"\n+\t\t\t    : \"\\tmoveql %I%wd,%Rd0\\n\"),\n+\t\t     delta);\n       else\n-\tasm_fprintf (file, MOTOROLA ?\n-\t\t     \"\\tmove.l %I%wd,%Rd0\\n\" :\n-\t\t     \"\\tmovel %I%wd,%Rd0\\n\", delta);\n-      asm_fprintf (file, MOTOROLA ?\n-\t\t   \"\\tadd.l %Rd0,4(%Rsp)\\n\" :\n-\t\t   \"\\taddl %Rd0,%Rsp@(4)\\n\");\n+\tasm_fprintf (file, (MOTOROLA\n+\t\t\t    ? \"\\tmove.l %I%wd,%Rd0\\n\"\n+\t\t\t    : \"\\tmovel %I%wd,%Rd0\\n\"),\n+\t\t     delta);\n+      asm_fprintf (file, (MOTOROLA\n+\t\t\t  ? \"\\tadd.l %Rd0,4(%Rsp)\\n\"\n+\t\t\t  : \"\\taddl %Rd0,%Rsp@(4)\\n\"));\n     }\n   else\n-    asm_fprintf (file, MOTOROLA ?\n-\t\t\t \"\\tadd.l %I%wd,4(%Rsp)\\n\" :\n-\t\t\t \"\\taddl %I%wd,%Rsp@(4)\\n\",\n+    asm_fprintf (file, (MOTOROLA\n+\t\t\t? \"\\tadd.l %I%wd,4(%Rsp)\\n\"\n+\t\t\t: \"\\taddl %I%wd,%Rsp@(4)\\n\"),\n \t\t delta);\n \n   xops[0] = DECL_RTL (function);\n@@ -3303,20 +3289,24 @@ m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n     {\n       if (TARGET_PCREL)\n \tfmt = \"bra.l %o0\";\n-      else if ((flag_pic == 1) || TARGET_68020)\n+      else if (flag_pic == 1 || TARGET_68020)\n \t{\n \t  if (MOTOROLA)\n-#if defined(USE_GAS)\n-\t    fmt = \"bra.l %0@PLTPC\";\n+\t    {\n+#if defined (USE_GAS)\n+\t      fmt = \"bra.l %0@PLTPC\";\n #else\n-\t    fmt = \"bra %0@PLTPC\";\n+\t      fmt = \"bra %0@PLTPC\";\n #endif\n+\t    }\n \t  else /* !MOTOROLA */\n+\t    {\n #ifdef USE_GAS\n-\t    fmt = \"bra.l %0\";\n+\t      fmt = \"bra.l %0\";\n #else\n-\t    fmt = \"jra %0,a1\";\n+\t      fmt = \"jra %0,a1\";\n #endif\n+\t    }\n \t}\n       else if (optimize_size || TARGET_ID_SHARED_LIBRARY)\n         fmt = \"move.l %0@GOT(%%a5), %%a1\\n\\tjmp (%%a1)\";\n@@ -3369,27 +3359,27 @@ m68k_regno_mode_ok (int regno, enum machine_mode mode)\n {\n   if (regno < 8)\n     {\n-\t/* Data Registers, can hold aggregate if fits in.  */\n-\tif (regno + GET_MODE_SIZE (mode) / 4 <= 8)\n-\t  return true;\n+      /* Data Registers, can hold aggregate if fits in.  */\n+      if (regno + GET_MODE_SIZE (mode) / 4 <= 8)\n+\treturn true;\n     }\n   else if (regno < 16)\n     {\n-\t/* Address Registers, can't hold bytes, can hold aggregate if\n-\t   fits in.  */\n-\tif (GET_MODE_SIZE (mode) == 1)\n-\t  return false;\n-\tif (regno + GET_MODE_SIZE (mode) / 4 <= 16)\n-\t  return true;\n+      /* Address Registers, can't hold bytes, can hold aggregate if\n+\t fits in.  */\n+      if (GET_MODE_SIZE (mode) == 1)\n+\treturn false;\n+      if (regno + GET_MODE_SIZE (mode) / 4 <= 16)\n+\treturn true;\n     }\n   else if (regno < 24)\n     {\n       /* FPU registers, hold float or complex float of long double or\n-\t   smaller.  */\n-\tif ((GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t     || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n-\t    && GET_MODE_UNIT_SIZE (mode) <= 12)\n-\t  return true;\n+\t smaller.  */\n+      if ((GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t   || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n+\t  && GET_MODE_UNIT_SIZE (mode) <= 12)\n+\treturn true;\n     }\n   return false;\n }"}]}