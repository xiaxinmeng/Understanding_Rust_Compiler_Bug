{"sha": "099dde21d2cc95cc752b0529fb762210e7be9a4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk5ZGRlMjFkMmNjOTVjYzc1MmIwNTI5ZmI3NjIyMTBlN2JlOWE0Yw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-11-15T17:29:00Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-11-15T17:29:00Z"}, "message": "Workaround for Itanium A/B step errata\n\nFrom-SVN: r37482", "tree": {"sha": "f845a243873f7f7dd77f10fec8754fc6c46f5863", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f845a243873f7f7dd77f10fec8754fc6c46f5863"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/099dde21d2cc95cc752b0529fb762210e7be9a4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/099dde21d2cc95cc752b0529fb762210e7be9a4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/099dde21d2cc95cc752b0529fb762210e7be9a4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/099dde21d2cc95cc752b0529fb762210e7be9a4c/comments", "author": null, "committer": null, "parents": [{"sha": "4e7b85edbe7364864ee331fc9e4edbf663b24304", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e7b85edbe7364864ee331fc9e4edbf663b24304", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e7b85edbe7364864ee331fc9e4edbf663b24304"}], "stats": {"total": 167, "additions": 159, "deletions": 8}, "files": [{"sha": "c9d8ff6a4309a34615e50471166b27798ca33e22", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099dde21d2cc95cc752b0529fb762210e7be9a4c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099dde21d2cc95cc752b0529fb762210e7be9a4c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=099dde21d2cc95cc752b0529fb762210e7be9a4c", "patch": "@@ -1,3 +1,20 @@\n+2000-11-15  Bernd Schmidt  <bernds@redhat.co.uk>\n+\n+\t* ia64.c (struct group): New structure.\n+\t(last_group): New static array.\n+\t(group_idx): New static variable.\n+\t(emit_group_barrier_after, errata_find_address_regs, errata_emit_nops):\n+\tNew static functions.\n+\t(emit_insn_group_barriers): Initialize and keep track of group_idx\n+\tand last_group.\n+\tCall errata_emit_nops if TARGET_B_STEP or TARGET_A_STEP.\n+\tReplace all calls to emit_insn_after that emit a group barrier to use\n+\temit_group_barrier_after.\n+\t* ia64.h (MASK_B_STEP): New.\n+\t(other MASK_XXX macros): Renumbered.\n+\t(TARGET_B_STEP): New.\n+\t(TARGET_SWITCHES): Add -mb-step.\n+\n 2000-11-15  Fred Fish  <fnf@be.com>\n \n \t* fixinc/mkfixinc.sh (fixincludes): Add *-*-beos* to list of"}, {"sha": "87cc12d346fe1c8a01bf2c7c62f3e735d24356e0", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 132, "deletions": 4, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099dde21d2cc95cc752b0529fb762210e7be9a4c/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099dde21d2cc95cc752b0529fb762210e7be9a4c/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=099dde21d2cc95cc752b0529fb762210e7be9a4c", "patch": "@@ -4279,6 +4279,128 @@ rtx_needs_barrier (x, flags, pred)\n   return need_barrier;\n }\n \n+/* This structure is used to track some details about the previous insns\n+   groups so we can determine if it may be necessary to insert NOPs to\n+   workaround hardware errata.  */\n+static struct group\n+{\n+  HARD_REG_SET p_reg_set;\n+  HARD_REG_SET gr_reg_conditionally_set;\n+} last_group[3];\n+\n+/* Index into the last_group array.  */\n+static int group_idx;\n+\n+static void emit_group_barrier_after PARAMS ((rtx));\n+static int errata_find_address_regs PARAMS ((rtx *, void *));\n+static void errata_emit_nops PARAMS ((rtx));\n+\n+/* Create a new group barrier, emit it after AFTER, and advance group_idx.  */\n+static void\n+emit_group_barrier_after (after)\n+     rtx after;\n+{\n+  emit_insn_after (gen_insn_group_barrier (), after);\n+  group_idx = (group_idx + 1) % 3;\n+  memset (last_group + group_idx, 0, sizeof last_group[group_idx]);\n+}\n+\n+/* Called through for_each_rtx; determines if a hard register that was\n+   conditionally set in the previous group is used as an address register.\n+   It ensures that for_each_rtx returns 1 in that case.  */\n+static int\n+errata_find_address_regs (xp, data)\n+     rtx *xp;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  rtx x = *xp;\n+  if (GET_CODE (x) != MEM)\n+    return 0;\n+  x = XEXP (x, 0);\n+  if (GET_CODE (x) == POST_MODIFY)\n+    x = XEXP (x, 0);\n+  if (GET_CODE (x) == REG)\n+    {\n+      struct group *prev_group = last_group + (group_idx + 2) % 3;\n+      if (TEST_HARD_REG_BIT (prev_group->gr_reg_conditionally_set,\n+\t\t\t     REGNO (x)))\n+\treturn 1;\n+      return -1;\n+    }\n+  return 0;\n+}\n+\n+/* Called for each insn; this function keeps track of the state in\n+   last_group and emits additional NOPs if necessary to work around\n+   an Itanium A/B step erratum.  */\n+static void\n+errata_emit_nops (insn)\n+     rtx insn;\n+{\n+  struct group *this_group = last_group + group_idx;\n+  struct group *prev_group = last_group + (group_idx + 2) % 3;\n+  rtx pat = PATTERN (insn);\n+  rtx cond = GET_CODE (pat) == COND_EXEC ? COND_EXEC_TEST (pat) : 0;\n+  rtx real_pat = cond ? COND_EXEC_CODE (pat) : pat;\n+  enum attr_type type;\n+  rtx set = real_pat;\n+\n+  if (GET_CODE (real_pat) == USE\n+      || GET_CODE (real_pat) == CLOBBER\n+      || GET_CODE (real_pat) == ASM_INPUT\n+      || GET_CODE (real_pat) == ADDR_VEC\n+      || GET_CODE (real_pat) == ADDR_DIFF_VEC\n+      || asm_noperands (insn) >= 0)\n+    return;\n+\n+  /* single_set doesn't work for COND_EXEC insns, so we have to duplicate\n+     parts of it.  */\n+\n+  if (GET_CODE (set) == PARALLEL)\n+    {\n+      int i;\n+      set = XVECEXP (real_pat, 0, 0);\n+      for (i = 1; i < XVECLEN (real_pat, 0); i++)\n+\tif (GET_CODE (XVECEXP (real_pat, 0, i)) != USE\n+\t    && GET_CODE (XVECEXP (real_pat, 0, i)) != CLOBBER)\n+\t  {\n+\t    set = 0;\n+\t    break;\n+\t  }\n+    }\n+\n+  if (set && GET_CODE (set) != SET)\n+    set = 0;\n+\n+  type  = get_attr_type (insn);\n+\n+  if (type == TYPE_F\n+      && set && REG_P (SET_DEST (set)) && PR_REGNO_P (REGNO (SET_DEST (set))))\n+    SET_HARD_REG_BIT (this_group->p_reg_set, REGNO (SET_DEST (set)));\n+\n+  if ((type == TYPE_M || type == TYPE_A) && cond && set\n+      && REG_P (SET_DEST (set))\n+      && GET_CODE (SET_SRC (set)) != PLUS\n+      && GET_CODE (SET_SRC (set)) != MINUS\n+      && (GET_CODE (SET_SRC (set)) != MEM\n+\t  || GET_CODE (XEXP (SET_SRC (set), 0)) != POST_MODIFY)\n+      && GENERAL_REGNO_P (REGNO (SET_DEST (set))))\n+    {\n+      if (GET_RTX_CLASS (GET_CODE (cond)) != '<'\n+\t  || ! REG_P (XEXP (cond, 0)))\n+\tabort ();\n+\n+      if (TEST_HARD_REG_BIT (prev_group->p_reg_set, REGNO (XEXP (cond, 0))))\n+\tSET_HARD_REG_BIT (this_group->gr_reg_conditionally_set, REGNO (SET_DEST (set)));\n+    }\n+  if (for_each_rtx (&real_pat, errata_find_address_regs, NULL))\n+    {\n+      emit_insn_before (gen_insn_group_barrier (), insn);\n+      emit_insn_before (gen_nop (), insn);\n+      emit_insn_before (gen_insn_group_barrier (), insn);\n+    }\n+}\n+\n /* INSNS is an chain of instructions.  Scan the chain, and insert stop bits\n    as necessary to eliminate dependendencies.  */\n \n@@ -4290,12 +4412,18 @@ emit_insn_group_barriers (insns)\n \n   memset (rws_sum, 0, sizeof (rws_sum));\n \n+  group_idx = 0;\n+  memset (last_group, 0, sizeof last_group);\n+\n   prev_insn = 0;\n   for (insn = insns; insn; insn = NEXT_INSN (insn))\n     {\n       int need_barrier = 0;\n       struct reg_flags flags;\n \n+      if ((TARGET_B_STEP || TARGET_A_STEP) && INSN_P (insn))\n+\terrata_emit_nops (insn);\n+\n       memset (&flags, 0, sizeof (flags));\n       switch (GET_CODE (insn))\n \t{\n@@ -4310,7 +4438,7 @@ emit_insn_group_barriers (insns)\n \t      need_barrier = rws_access_regno (AR_LC_REGNUM, flags, 0);\n \t      if (need_barrier)\n \t\t{\n-\t\t  emit_insn_after (gen_insn_group_barrier (), insn);\n+\t\t  emit_group_barrier_after (insn);\n \t\t  memset (rws_sum, 0, sizeof(rws_sum));\n \t\t  prev_insn = NULL_RTX;\n \t\t}\n@@ -4328,7 +4456,7 @@ emit_insn_group_barriers (insns)\n \t      /* PREV_INSN null can happen if the very first insn is a\n \t\t volatile asm.  */\n \t      if (prev_insn)\n-\t\temit_insn_after (gen_insn_group_barrier (), prev_insn);\n+\t\temit_group_barrier_after (prev_insn);\n \t      memcpy (rws_sum, rws_insn, sizeof (rws_sum));\n \t    }\n \n@@ -4354,7 +4482,7 @@ emit_insn_group_barriers (insns)\n \t    }\n \t  if (need_barrier)\n \t    {\n-\t      emit_insn_after (gen_insn_group_barrier (), insn);\n+\t      emit_group_barrier_after (insn);\n \t      memset (rws_sum, 0, sizeof (rws_sum));\n \t      prev_insn = NULL_RTX;\n \t    }\n@@ -4412,7 +4540,7 @@ emit_insn_group_barriers (insns)\n \t\t  /* PREV_INSN null can happen if the very first insn is a\n \t\t     volatile asm.  */\n \t\t  if (prev_insn)\n-\t\t    emit_insn_after (gen_insn_group_barrier (), prev_insn);\n+\t\t    emit_group_barrier_after (prev_insn);\n \t\t  memcpy (rws_sum, rws_insn, sizeof (rws_sum));\n \t\t}\n \t      prev_insn = insn;"}, {"sha": "1f9250f9370fbb060241e6776776363e88e5a123", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099dde21d2cc95cc752b0529fb762210e7be9a4c/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099dde21d2cc95cc752b0529fb762210e7be9a4c/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=099dde21d2cc95cc752b0529fb762210e7be9a4c", "patch": "@@ -55,13 +55,15 @@ extern int target_flags;\n \n #define MASK_A_STEP\t0x00000020\t/* Emit code for Itanium A step.  */\n \n-#define MASK_REG_NAMES\t0x00000040\t/* Use in/loc/out register names.  */\n+#define MASK_B_STEP\t0x00000040\t/* Emit code for Itanium B step.  */\n \n-#define MASK_NO_SDATA   0x00000080\t/* Disable sdata/scommon/sbss.  */\n+#define MASK_REG_NAMES\t0x00000080\t/* Use in/loc/out register names.  */\n \n-#define MASK_CONST_GP\t0x00000100\t/* treat gp as program-wide constant */\n+#define MASK_NO_SDATA   0x00000100\t/* Disable sdata/scommon/sbss.  */\n \n-#define MASK_AUTO_PIC\t0x00000200\t/* generate automatically PIC */\n+#define MASK_CONST_GP\t0x00000200\t/* treat gp as program-wide constant */\n+\n+#define MASK_AUTO_PIC\t0x00000400\t/* generate automatically PIC */\n \n #define MASK_INLINE_DIV_LAT 0x00000400\t/* inline div, min latency.  */\n \n@@ -81,6 +83,8 @@ extern int target_flags;\n \n #define TARGET_A_STEP\t\t(target_flags & MASK_A_STEP)\n \n+#define TARGET_B_STEP\t\t(target_flags & MASK_B_STEP)\n+\n #define TARGET_REG_NAMES\t(target_flags & MASK_REG_NAMES)\n \n #define TARGET_NO_SDATA\t\t(target_flags & MASK_NO_SDATA)\n@@ -124,6 +128,8 @@ extern int target_flags;\n       N_(\"Don't emit stop bits before and after volatile extended asms\") }, \\\n   { \"a-step\",\t\tMASK_A_STEP,\t\t\t\t\t\\\n       N_(\"Emit code for Itanium (TM) processor A step\")},\t\t\\\n+  { \"b-step\",\t\tMASK_B_STEP,\t\t\t\t\t\\\n+      N_(\"Emit code for Itanium (TM) processor B step\")},\t\t\\\n   { \"register-names\",\tMASK_REG_NAMES,\t\t\t\t\t\\\n       N_(\"Use in/loc/out register names\")},\t\t\t\t\\\n   { \"no-sdata\",\t\tMASK_NO_SDATA,\t\t\t\t\t\\"}]}