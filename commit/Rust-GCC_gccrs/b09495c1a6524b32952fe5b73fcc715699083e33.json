{"sha": "b09495c1a6524b32952fe5b73fcc715699083e33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA5NDk1YzFhNjUyNGIzMjk1MmZlNWI3M2ZjYzcxNTY5OTA4M2UzMw==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2010-02-10T02:07:22Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2010-02-10T02:07:22Z"}, "message": "re PR middle-end/42973 (IRA apparently systematically making reload too busy on 2 address instructions with 3 operands)\n\n2010-02-09  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR middle-end/42973\n\t* ira-conflicts.c (get_dup): Remove.\n\t(process_reg_shuffles): Add new parameter.  Use it as an\n\tadditional guard for copy generation.\n\t(add_insn_allocno_copies): Rewrite.\n\nFrom-SVN: r156641", "tree": {"sha": "9c68c7e1ecf780642c308612352d0f2baaf5c43e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c68c7e1ecf780642c308612352d0f2baaf5c43e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b09495c1a6524b32952fe5b73fcc715699083e33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b09495c1a6524b32952fe5b73fcc715699083e33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b09495c1a6524b32952fe5b73fcc715699083e33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b09495c1a6524b32952fe5b73fcc715699083e33/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7dfbafe4744f6a014c244301974302dc59418452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dfbafe4744f6a014c244301974302dc59418452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dfbafe4744f6a014c244301974302dc59418452"}], "stats": {"total": 120, "additions": 64, "deletions": 56}, "files": [{"sha": "9b8f4d5a969e8c805cde2705437b4cb6aa84fc10", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b09495c1a6524b32952fe5b73fcc715699083e33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b09495c1a6524b32952fe5b73fcc715699083e33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b09495c1a6524b32952fe5b73fcc715699083e33", "patch": "@@ -1,3 +1,11 @@\n+2010-02-09  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR middle-end/42973\n+\t* ira-conflicts.c (get_dup): Remove.\n+\t(process_reg_shuffles): Add new parameter.  Use it as an\n+\tadditional guard for copy generation.\n+\t(add_insn_allocno_copies): Rewrite.\n+\n 2010-02-09  Alexander Monakov  <amonakov@ispras.ru>\n \n \t* common.opt (fsched2-use-traces): Preserved for backward"}, {"sha": "faa36ae19561790b537f095f39599c490a1e3157", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b09495c1a6524b32952fe5b73fcc715699083e33/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b09495c1a6524b32952fe5b73fcc715699083e33/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=b09495c1a6524b32952fe5b73fcc715699083e33", "patch": "@@ -302,21 +302,6 @@ get_dup_num (int op_num, bool use_commut_op_p)\n   return dup;\n }\n \n-/* Return the operand which should be, in any case, the same as\n-   operand with number OP_NUM.  If USE_COMMUT_OP_P is TRUE, the\n-   function makes temporarily commutative operand exchange before\n-   this.  */\n-static rtx\n-get_dup (int op_num, bool use_commut_op_p)\n-{\n-  int n = get_dup_num (op_num, use_commut_op_p);\n-\n-  if (n < 0)\n-    return NULL_RTX;\n-  else\n-    return recog_data.operand[n];\n-}\n-\n /* Check that X is REG or SUBREG of REG.  */\n #define REG_SUBREG_P(x)\t\t\t\t\t\t\t\\\n    (REG_P (x) || (GET_CODE (x) == SUBREG && REG_P (SUBREG_REG (x))))\n@@ -432,12 +417,12 @@ process_regs_for_copy (rtx reg1, rtx reg2, bool constraint_p,\n   return true;\n }\n \n-/* Process all of the output registers of the current insn and\n-   the input register REG (its operand number OP_NUM) which dies in the\n-   insn as if there were a move insn between them with frequency\n-   FREQ.  */\n+/* Process all of the output registers of the current insn which are\n+   not bound (BOUND_P) and the input register REG (its operand number\n+   OP_NUM) which dies in the insn as if there were a move insn between\n+   them with frequency FREQ.  */\n static void\n-process_reg_shuffles (rtx reg, int op_num, int freq)\n+process_reg_shuffles (rtx reg, int op_num, int freq, bool *bound_p)\n {\n   int i;\n   rtx another_reg;\n@@ -448,7 +433,8 @@ process_reg_shuffles (rtx reg, int op_num, int freq)\n       another_reg = recog_data.operand[i];\n \n       if (!REG_SUBREG_P (another_reg) || op_num == i\n-\t  || recog_data.operand_type[i] != OP_OUT)\n+\t  || recog_data.operand_type[i] != OP_OUT\n+\t  || bound_p[i])\n \tcontinue;\n \n       process_regs_for_copy (reg, another_reg, false, NULL_RTX, freq);\n@@ -461,11 +447,11 @@ process_reg_shuffles (rtx reg, int op_num, int freq)\n static void\n add_insn_allocno_copies (rtx insn)\n {\n-  rtx set, operand, dup;\n+  rtx set, operand, dup, link;\n   const char *str;\n-  bool commut_p, bound_p;\n-  int i, j, freq;\n-\n+  bool commut_p, bound_p[MAX_RECOG_OPERANDS];\n+  int i, j, n, freq;\n+  \n   freq = REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn));\n   if (freq == 0)\n     freq = 1;\n@@ -476,38 +462,52 @@ add_insn_allocno_copies (rtx insn)\n \t\t\tREG_P (SET_SRC (set))\n \t\t\t? SET_SRC (set)\n \t\t\t: SUBREG_REG (SET_SRC (set))) != NULL_RTX)\n-    process_regs_for_copy (SET_DEST (set), SET_SRC (set), false, insn, freq);\n-  else\n     {\n-      extract_insn (insn);\n-      for (i = 0; i < recog_data.n_operands; i++)\n-\t{\n-\t  operand = recog_data.operand[i];\n-\t  if (REG_SUBREG_P (operand)\n-\t      && find_reg_note (insn, REG_DEAD,\n-\t\t\t\tREG_P (operand)\n-\t\t\t\t? operand : SUBREG_REG (operand)) != NULL_RTX)\n-\t    {\n-\t      str = recog_data.constraints[i];\n-\t      while (*str == ' ' || *str == '\\t')\n-\t\tstr++;\n-\t      bound_p = false;\n-\t      for (j = 0, commut_p = false; j < 2; j++, commut_p = true)\n-\t\tif ((dup = get_dup (i, commut_p)) != NULL_RTX\n-\t\t    && REG_SUBREG_P (dup)\n-\t\t    && process_regs_for_copy (operand, dup, true,\n-\t\t\t\t\t      NULL_RTX, freq))\n-\t\t  bound_p = true;\n-\t      if (bound_p)\n-\t\tcontinue;\n-\t      /* If an operand dies, prefer its hard register for the\n-\t\t output operands by decreasing the hard register cost\n-\t\t or creating the corresponding allocno copies.  The\n-\t\t cost will not correspond to a real move insn cost, so\n-\t\t make the frequency smaller.  */\n-\t      process_reg_shuffles (operand, i, freq < 8 ? 1 : freq / 8);\n-\t    }\n-\t}\n+      process_regs_for_copy (SET_DEST (set), SET_SRC (set), false, insn, freq);\n+      return;\n+    }\n+  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+    if (REG_NOTE_KIND (link) == REG_DEAD)\n+      break;\n+  if (! link)\n+    return;\n+  extract_insn (insn);\n+  for (i = 0; i < recog_data.n_operands; i++)\n+    bound_p[i] = false;\n+  for (i = 0; i < recog_data.n_operands; i++)\n+    {\n+      operand = recog_data.operand[i];\n+      if (! REG_SUBREG_P (operand))\n+\tcontinue;\n+      str = recog_data.constraints[i];\n+      while (*str == ' ' || *str == '\\t')\n+\tstr++;\n+      for (j = 0, commut_p = false; j < 2; j++, commut_p = true)\n+\tif ((n = get_dup_num (i, commut_p)) >= 0)\n+\t  {\n+\t    bound_p[n] = true;\n+\t    dup = recog_data.operand[n];\n+\t    if (REG_SUBREG_P (dup)\n+\t\t&& find_reg_note (insn, REG_DEAD,\n+\t\t\t\t  REG_P (operand)\n+\t\t\t\t  ? operand\n+\t\t\t\t  : SUBREG_REG (operand)) != NULL_RTX)\n+\t      process_regs_for_copy (operand, dup, true, NULL_RTX, freq);\n+\t  }\n+    }\n+  for (i = 0; i < recog_data.n_operands; i++)\n+    {\n+      operand = recog_data.operand[i];\n+      if (REG_SUBREG_P (operand)\n+\t  && find_reg_note (insn, REG_DEAD,\n+\t\t\t    REG_P (operand)\n+\t\t\t    ? operand : SUBREG_REG (operand)) != NULL_RTX)\n+\t/* If an operand dies, prefer its hard register for the output\n+\t   operands by decreasing the hard register cost or creating\n+\t   the corresponding allocno copies.  The cost will not\n+\t   correspond to a real move insn cost, so make the frequency\n+\t   smaller.  */\n+\tprocess_reg_shuffles (operand, i, freq < 8 ? 1 : freq / 8, bound_p);\n     }\n }\n "}]}