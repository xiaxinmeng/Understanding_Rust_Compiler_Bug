{"sha": "49d1a2f91325fa8cc011149e27e5093a988b3a49", "node_id": "C_kwDOANBUbNoAKDQ5ZDFhMmY5MTMyNWZhOGNjMDExMTQ5ZTI3ZTUwOTNhOTg4YjNhNDk", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-05-23T08:54:32Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-05-23T08:54:32Z"}, "message": "OpenMP: Handle descriptors in target's firstprivate [PR104949]\n\nFor allocatable/pointer arrays, a firstprivate to a device\nnot only needs to privatize the descriptor but also the actual\ndata. This is implemented as:\n  firstprivate(x) firstprivate(x.data) attach(x [bias: &x.data-&x)\nwhere the address of x in device memory is saved in hostaddrs[i]\nby libgomp and the middle end actually passes hostaddrs[i]' to\nattach.\n\nAs side effect, has_device_addr(array_desc) had to be changed:\nbefore, it was converted to firstprivate in the front end; now\nit is handled in omp-low.cc as has_device_addr requires a shallow\nfirstprivate (not touching the data pointer) while the normal\nfirstprivate requires (now) a deep firstprivate.\n\ngcc/fortran/ChangeLog:\n\n\tPR fortran/104949\n\t* f95-lang.cc (LANG_HOOKS_OMP_ARRAY_SIZE): Redefine.\n\t* trans-openmp.cc (gfc_omp_array_size): New.\n\t(gfc_trans_omp_variable_list): Never turn has_device_addr\n\tto firstprivate.\n\t* trans.h (gfc_omp_array_size): New.\n\ngcc/ChangeLog:\n\n\tPR fortran/104949\n\t* langhooks-def.h (lhd_omp_array_size): New.\n\t(LANG_HOOKS_OMP_ARRAY_SIZE): Define.\n\t(LANG_HOOKS_DECLS): Add it.\n\t* langhooks.cc (lhd_omp_array_size): New.\n\t* langhooks.h (struct lang_hooks_for_decls): Add hook.\n\t* omp-low.cc (scan_sharing_clauses, lower_omp_target):\n\tHandle GOMP_MAP_FIRSTPRIVATE for array descriptors.\n\nlibgomp/ChangeLog:\n\n\tPR fortran/104949\n\t* target.c (gomp_map_vars_internal, copy_firstprivate_data):\n\tSupport attach for GOMP_MAP_FIRSTPRIVATE.\n\t* testsuite/libgomp.fortran/target-firstprivate-1.f90: New test.\n\t* testsuite/libgomp.fortran/target-firstprivate-2.f90: New test.\n\t* testsuite/libgomp.fortran/target-firstprivate-3.f90: New test.", "tree": {"sha": "ce38d6f9032b9def8f22449dafc015b05fe4db6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce38d6f9032b9def8f22449dafc015b05fe4db6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49d1a2f91325fa8cc011149e27e5093a988b3a49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49d1a2f91325fa8cc011149e27e5093a988b3a49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49d1a2f91325fa8cc011149e27e5093a988b3a49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49d1a2f91325fa8cc011149e27e5093a988b3a49/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7707d7fddf7d6858399c8a47b139dc4708c5d7d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7707d7fddf7d6858399c8a47b139dc4708c5d7d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7707d7fddf7d6858399c8a47b139dc4708c5d7d9"}], "stats": {"total": 366, "additions": 355, "deletions": 11}, "files": [{"sha": "e83fef378bba027cd096aeb6cb58b2a548a19b21", "filename": "gcc/fortran/f95-lang.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d1a2f91325fa8cc011149e27e5093a988b3a49/gcc%2Ffortran%2Ff95-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d1a2f91325fa8cc011149e27e5093a988b3a49/gcc%2Ffortran%2Ff95-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.cc?ref=49d1a2f91325fa8cc011149e27e5093a988b3a49", "patch": "@@ -114,6 +114,7 @@ static const struct attribute_spec gfc_attribute_table[] =\n #undef LANG_HOOKS_TYPE_FOR_SIZE\n #undef LANG_HOOKS_INIT_TS\n #undef LANG_HOOKS_OMP_ARRAY_DATA\n+#undef LANG_HOOKS_OMP_ARRAY_SIZE\n #undef LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR\n #undef LANG_HOOKS_OMP_CHECK_OPTIONAL_ARGUMENT\n #undef LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE\n@@ -152,6 +153,7 @@ static const struct attribute_spec gfc_attribute_table[] =\n #define LANG_HOOKS_TYPE_FOR_SIZE\tgfc_type_for_size\n #define LANG_HOOKS_INIT_TS\t\tgfc_init_ts\n #define LANG_HOOKS_OMP_ARRAY_DATA\t\tgfc_omp_array_data\n+#define LANG_HOOKS_OMP_ARRAY_SIZE\t\tgfc_omp_array_size\n #define LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR\tgfc_omp_is_allocatable_or_ptr\n #define LANG_HOOKS_OMP_CHECK_OPTIONAL_ARGUMENT\tgfc_omp_check_optional_argument\n #define LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE\tgfc_omp_privatize_by_reference"}, {"sha": "bfd24f964eaf78003420f090f54f668894b2f988", "filename": "gcc/fortran/trans-openmp.cc", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d1a2f91325fa8cc011149e27e5093a988b3a49/gcc%2Ffortran%2Ftrans-openmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d1a2f91325fa8cc011149e27e5093a988b3a49/gcc%2Ffortran%2Ftrans-openmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.cc?ref=49d1a2f91325fa8cc011149e27e5093a988b3a49", "patch": "@@ -169,6 +169,48 @@ gfc_omp_array_data (tree decl, bool type_only)\n   return decl;\n }\n \n+/* Return the byte-size of the passed array descriptor. */\n+\n+tree\n+gfc_omp_array_size (tree decl, gimple_seq *pre_p)\n+{\n+  stmtblock_t block;\n+  if (POINTER_TYPE_P (TREE_TYPE (decl)))\n+    decl = build_fold_indirect_ref (decl);\n+  tree type = TREE_TYPE (decl);\n+  gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n+  bool allocatable = (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE\n+\t\t      || GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_POINTER\n+\t\t      || GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_POINTER_CONT);\n+  gfc_init_block (&block);\n+  tree size = gfc_full_array_size (&block, decl,\n+\t\t\t\t   GFC_TYPE_ARRAY_RANK (TREE_TYPE (decl)));\n+  size = fold_convert (size_type_node, size);\n+  tree elemsz = gfc_get_element_type (TREE_TYPE (decl));\n+  if (TREE_CODE (elemsz) == ARRAY_TYPE && TYPE_STRING_FLAG (elemsz))\n+    elemsz = gfc_conv_descriptor_elem_len (decl);\n+  else\n+    elemsz = TYPE_SIZE_UNIT (elemsz);\n+  size = fold_build2 (MULT_EXPR, size_type_node, size, elemsz);\n+  if (!allocatable)\n+    gimplify_and_add (gfc_finish_block (&block), pre_p);\n+  else\n+    {\n+      tree var = create_tmp_var (size_type_node);\n+      gfc_add_expr_to_block (&block, build2 (MODIFY_EXPR, sizetype, var, size));\n+      tree tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t  gfc_conv_descriptor_data_get (decl),\n+\t\t\t\t  null_pointer_node);\n+      tmp = build3_loc (input_location, COND_EXPR, void_type_node, tmp,\n+\t\t\tgfc_finish_block (&block),\n+\t\t\tbuild2 (MODIFY_EXPR, sizetype, var, size_zero_node));\n+      gimplify_and_add (tmp, pre_p);\n+      size = var;\n+    }\n+  return size;\n+}\n+\n+\n /* True if OpenMP should privatize what this DECL points to rather\n    than the DECL itself.  */\n \n@@ -1922,16 +1964,7 @@ gfc_trans_omp_variable_list (enum omp_clause_code code,\n \tif (t != error_mark_node)\n \t  {\n \t    tree node;\n-\t    /* For HAS_DEVICE_ADDR of an array descriptor, firstprivatize the\n-\t       descriptor such that the bounds are available; its data component\n-\t       is unmodified; it is handled as device address inside target. */\n-\t    if (code == OMP_CLAUSE_HAS_DEVICE_ADDR\n-\t\t&& (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (t))\n-\t\t    || (POINTER_TYPE_P (TREE_TYPE (t))\n-\t\t\t&& GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (t))))))\n-\t      node = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n-\t    else\n-\t      node = build_omp_clause (input_location, code);\n+\t    node = build_omp_clause (input_location, code);\n \t    OMP_CLAUSE_DECL (node) = t;\n \t    list = gfc_trans_add_clause (node, list);\n "}, {"sha": "03d5288aad20a4fb3c75d2c4f993521442382b19", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d1a2f91325fa8cc011149e27e5093a988b3a49/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d1a2f91325fa8cc011149e27e5093a988b3a49/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=49d1a2f91325fa8cc011149e27e5093a988b3a49", "patch": "@@ -808,6 +808,7 @@ bool gfc_get_array_descr_info (const_tree, struct array_descr_info *);\n bool gfc_omp_is_allocatable_or_ptr (const_tree);\n tree gfc_omp_check_optional_argument (tree, bool);\n tree gfc_omp_array_data (tree, bool);\n+tree gfc_omp_array_size (tree, gimple_seq *);\n bool gfc_omp_privatize_by_reference (const_tree);\n enum omp_clause_default_kind gfc_omp_predetermined_sharing (tree);\n enum omp_clause_defaultmap_kind gfc_omp_predetermined_mapping (tree);"}, {"sha": "95d8dec8cc3b37caaef54dac8e2722f2c20d185b", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d1a2f91325fa8cc011149e27e5093a988b3a49/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d1a2f91325fa8cc011149e27e5093a988b3a49/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=49d1a2f91325fa8cc011149e27e5093a988b3a49", "patch": "@@ -84,6 +84,7 @@ extern enum omp_clause_default_kind lhd_omp_predetermined_sharing (tree);\n extern enum omp_clause_defaultmap_kind lhd_omp_predetermined_mapping (tree);\n extern tree lhd_omp_assignment (tree, tree, tree);\n extern void lhd_omp_finish_clause (tree, gimple_seq *, bool);\n+extern tree lhd_omp_array_size (tree, gimple_seq *);\n struct gimplify_omp_ctx;\n extern void lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *,\n \t\t\t\t\t       tree);\n@@ -257,6 +258,7 @@ extern tree lhd_unit_size_without_reusable_padding (tree);\n #define LANG_HOOKS_POST_COMPILATION_PARSING_CLEANUPS NULL\n #define LANG_HOOKS_DECL_OK_FOR_SIBCALL\tlhd_decl_ok_for_sibcall\n #define LANG_HOOKS_OMP_ARRAY_DATA\thook_tree_tree_bool_null\n+#define LANG_HOOKS_OMP_ARRAY_SIZE\tlhd_omp_array_size\n #define LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR hook_bool_const_tree_false\n #define LANG_HOOKS_OMP_CHECK_OPTIONAL_ARGUMENT hook_tree_tree_bool_null\n #define LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE hook_bool_const_tree_false\n@@ -290,6 +292,7 @@ extern tree lhd_unit_size_without_reusable_padding (tree);\n   LANG_HOOKS_POST_COMPILATION_PARSING_CLEANUPS, \\\n   LANG_HOOKS_DECL_OK_FOR_SIBCALL, \\\n   LANG_HOOKS_OMP_ARRAY_DATA, \\\n+  LANG_HOOKS_OMP_ARRAY_SIZE, \\\n   LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR, \\\n   LANG_HOOKS_OMP_CHECK_OPTIONAL_ARGUMENT, \\\n   LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE, \\"}, {"sha": "97e5139652121ef4c82c93d392b2dcb12ee6fdb7", "filename": "gcc/langhooks.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d1a2f91325fa8cc011149e27e5093a988b3a49/gcc%2Flanghooks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d1a2f91325fa8cc011149e27e5093a988b3a49/gcc%2Flanghooks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.cc?ref=49d1a2f91325fa8cc011149e27e5093a988b3a49", "patch": "@@ -634,6 +634,14 @@ lhd_omp_finish_clause (tree, gimple_seq *, bool)\n {\n }\n \n+/* Return array size; cf. omp_array_data.  */\n+\n+tree\n+lhd_omp_array_size (tree, gimple_seq *)\n+{\n+  return NULL_TREE;\n+}\n+\n /* Return true if DECL is a scalar variable (for the purpose of\n    implicit firstprivatization & mapping). Only if alloc_ptr_ok\n    are allocatables and pointers accepted. */"}, {"sha": "75025550aa4465fcea5f9ad568c90f700ec37cad", "filename": "gcc/langhooks.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d1a2f91325fa8cc011149e27e5093a988b3a49/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d1a2f91325fa8cc011149e27e5093a988b3a49/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=49d1a2f91325fa8cc011149e27e5093a988b3a49", "patch": "@@ -246,6 +246,11 @@ struct lang_hooks_for_decls\n      is true, only the TREE_TYPE is returned without generating a new tree.  */\n   tree (*omp_array_data) (tree, bool);\n \n+  /* Return a tree for the actual data of an array descriptor - or NULL_TREE\n+     if original tree is not an array descriptor.  If the second argument\n+     is true, only the TREE_TYPE is returned without generating a new tree.  */\n+  tree (*omp_array_size) (tree, gimple_seq *pre_p);\n+\n   /* True if OpenMP should regard this DECL as being a scalar which has Fortran's\n      allocatable or pointer attribute.  */\n   bool (*omp_is_allocatable_or_ptr) (const_tree);"}, {"sha": "16f596587e8fd78cdf17e41edaa1a1de05957cd4", "filename": "gcc/omp-low.cc", "status": "modified", "additions": 101, "deletions": 1, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d1a2f91325fa8cc011149e27e5093a988b3a49/gcc%2Fomp-low.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d1a2f91325fa8cc011149e27e5093a988b3a49/gcc%2Fomp-low.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.cc?ref=49d1a2f91325fa8cc011149e27e5093a988b3a49", "patch": "@@ -1372,7 +1372,9 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_HAS_DEVICE_ADDR)\n \t      && is_gimple_omp_offloaded (ctx->stmt))\n \t    {\n-\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE)\n+\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n+\t\t  || (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_HAS_DEVICE_ADDR\n+\t\t      && lang_hooks.decls.omp_array_data (decl, true)))\n \t\t{\n \t\t  by_ref = !omp_privatize_by_reference (decl);\n \t\t  install_var_field (decl, by_ref, 3, ctx);\n@@ -1424,6 +1426,15 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t\tinstall_var_field (decl, by_ref, 3, ctx);\n \t    }\n \t  install_var_local (decl, ctx);\n+\t  /* For descr arrays on target: firstprivatize data + attach ptr.  */\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n+\t      && is_gimple_omp_offloaded (ctx->stmt)\n+\t      && !is_gimple_omp_oacc (ctx->stmt)\n+\t      && lang_hooks.decls.omp_array_data (decl, true))\n+\t    {\n+\t      install_var_field (decl, false, 16 | 3, ctx);\n+\t      install_var_field (decl, true, 8 | 3, ctx);\n+\t    }\n \t  break;\n \n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n@@ -12871,6 +12882,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \tbreak;\n \n       case OMP_CLAUSE_FIRSTPRIVATE:\n+      omp_firstprivate_recv:\n \tgcc_checking_assert (offloaded);\n \tif (is_gimple_omp_oacc (ctx->stmt))\n \t  {\n@@ -12902,6 +12914,10 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    SET_DECL_VALUE_EXPR (new_var, x);\n \t    DECL_HAS_VALUE_EXPR_P (new_var) = 1;\n \t  }\n+\t  /* Fortran array descriptors: firstprivate of data + attach.  */\n+\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_HAS_DEVICE_ADDR\n+\t      && lang_hooks.decls.omp_array_data (var, true))\n+\t    map_cnt += 2;\n \tbreak;\n \n       case OMP_CLAUSE_PRIVATE:\n@@ -12941,6 +12957,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    while (TREE_CODE (var) == INDIRECT_REF\n \t\t   || TREE_CODE (var) == ARRAY_REF)\n \t      var = TREE_OPERAND (var, 0);\n+\t    if (lang_hooks.decls.omp_array_data (var, true))\n+\t      goto omp_firstprivate_recv;\n \t  }\n \tmap_cnt++;\n \tif (is_variable_sized (var))\n@@ -13354,6 +13372,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    break;\n \n \t  case OMP_CLAUSE_FIRSTPRIVATE:\n+\t  omp_has_device_addr_descr:\n \t    if (is_gimple_omp_oacc (ctx->stmt))\n \t      goto oacc_firstprivate_map;\n \t    ovar = OMP_CLAUSE_DECL (c);\n@@ -13419,6 +13438,82 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t\t <= tree_to_uhwi (TYPE_MAX_VALUE (tkind_type)));\n \t    CONSTRUCTOR_APPEND_ELT (vkind, purpose,\n \t\t\t\t    build_int_cstu (tkind_type, tkind));\n+\t    /* Fortran array descriptors: firstprivate of data + attach.  */\n+\t    if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_HAS_DEVICE_ADDR\n+\t\t&& lang_hooks.decls.omp_array_data (ovar, true))\n+\t      {\n+\t\ttree not_null_lb, null_lb, after_lb;\n+\t\ttree var1, var2, size1, size2;\n+\t\ttree present = omp_check_optional_argument (ovar, true);\n+\t\tif (present)\n+\t\t  {\n+\t\t    location_t clause_loc = OMP_CLAUSE_LOCATION (c);\n+\t\t    not_null_lb = create_artificial_label (clause_loc);\n+\t\t    null_lb = create_artificial_label (clause_loc);\n+\t\t    after_lb = create_artificial_label (clause_loc);\n+\t\t    gimple_seq seq = NULL;\n+\t\t    present = force_gimple_operand (present, &seq, true,\n+\t\t\t\t\t\t    NULL_TREE);\n+\t\t    gimple_seq_add_seq (&ilist, seq);\n+\t\t    gimple_seq_add_stmt (&ilist,\n+\t\t      gimple_build_cond_from_tree (present,\n+\t\t\t\t\t\t   not_null_lb, null_lb));\n+\t\t    gimple_seq_add_stmt (&ilist,\n+\t\t\t\t\t gimple_build_label (not_null_lb));\n+\t\t  }\n+\t\tvar1 = lang_hooks.decls.omp_array_data (var, false);\n+\t\tsize1 = lang_hooks.decls.omp_array_size (var, &ilist);\n+\t\tvar2 = build_fold_addr_expr (x);\n+\t\tif (!POINTER_TYPE_P (TREE_TYPE (var)))\n+\t\t  var = build_fold_addr_expr (var);\n+\t\tsize2 = fold_build2 (POINTER_DIFF_EXPR, ssizetype,\n+\t\t\t\t   build_fold_addr_expr (var1), var);\n+\t\tsize2 = fold_convert (sizetype, size2);\n+\t\tif (present)\n+\t\t  {\n+\t\t    tree tmp = create_tmp_var (TREE_TYPE (var1));\n+\t\t    gimplify_assign (tmp, var1, &ilist);\n+\t\t    var1 = tmp;\n+\t\t    tmp = create_tmp_var (TREE_TYPE (var2));\n+\t\t    gimplify_assign (tmp, var2, &ilist);\n+\t\t    var2 = tmp;\n+\t\t    tmp = create_tmp_var (TREE_TYPE (size1));\n+\t\t    gimplify_assign (tmp, size1, &ilist);\n+\t\t    size1 = tmp;\n+\t\t    tmp = create_tmp_var (TREE_TYPE (size2));\n+\t\t    gimplify_assign (tmp, size2, &ilist);\n+\t\t    size2 = tmp;\n+\t\t    gimple_seq_add_stmt (&ilist, gimple_build_goto (after_lb));\n+\t\t    gimple_seq_add_stmt (&ilist, gimple_build_label (null_lb));\n+\t\t    gimplify_assign (var1, null_pointer_node, &ilist);\n+\t\t    gimplify_assign (var2, null_pointer_node, &ilist);\n+\t\t    gimplify_assign (size1, size_zero_node, &ilist);\n+\t\t    gimplify_assign (size2, size_zero_node, &ilist);\n+\t\t    gimple_seq_add_stmt (&ilist, gimple_build_label (after_lb));\n+\t\t  }\n+\t\tx = build_sender_ref ((splay_tree_key) &DECL_NAME (ovar), ctx);\n+\t\tgimplify_assign (x, var1, &ilist);\n+\t\ttkind = GOMP_MAP_FIRSTPRIVATE;\n+\t\ttalign = DECL_ALIGN_UNIT (ovar);\n+\t\ttalign = ceil_log2 (talign);\n+\t\ttkind |= talign << talign_shift;\n+\t\tgcc_checking_assert (tkind\n+\t\t\t\t     <= tree_to_uhwi (\n+\t\t\t\t\t  TYPE_MAX_VALUE (tkind_type)));\n+\t\tpurpose = size_int (map_idx++);\n+\t\tCONSTRUCTOR_APPEND_ELT (vsize, purpose, size1);\n+\t\tif (TREE_CODE (size1) != INTEGER_CST)\n+\t\t  TREE_STATIC (TREE_VEC_ELT (t, 1)) = 0;\n+\t\tCONSTRUCTOR_APPEND_ELT (vkind, purpose,\n+\t\t\t\t\tbuild_int_cstu (tkind_type, tkind));\n+\t\tx = build_sender_ref ((splay_tree_key) &DECL_UID (ovar), ctx);\n+\t\tgimplify_assign (x, var2, &ilist);\n+\t\ttkind = GOMP_MAP_ATTACH;\n+\t\tpurpose = size_int (map_idx++);\n+\t\tCONSTRUCTOR_APPEND_ELT (vsize, purpose, size2);\n+\t\tCONSTRUCTOR_APPEND_ELT (vkind, purpose,\n+\t\t\t\t\tbuild_int_cstu (tkind_type, tkind));\n+\t      }\n \t    break;\n \n \t  case OMP_CLAUSE_USE_DEVICE_PTR:\n@@ -13428,6 +13523,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    ovar = OMP_CLAUSE_DECL (c);\n \t    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_HAS_DEVICE_ADDR)\n \t      {\n+\t\tif (lang_hooks.decls.omp_array_data (ovar, true))\n+\t\t  goto omp_has_device_addr_descr;\n \t\twhile (TREE_CODE (ovar) == INDIRECT_REF\n \t\t       || TREE_CODE (ovar) == ARRAY_REF)\n \t\t  ovar = TREE_OPERAND (ovar, 0);\n@@ -13594,6 +13691,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  default:\n \t    break;\n \t  case OMP_CLAUSE_FIRSTPRIVATE:\n+\t  omp_firstprivatize_data_region:\n \t    if (is_gimple_omp_oacc (ctx->stmt))\n \t      break;\n \t    var = OMP_CLAUSE_DECL (c);\n@@ -13688,6 +13786,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    do_optional_check = false;\n \t    var = OMP_CLAUSE_DECL (c);\n \t    is_array_data = lang_hooks.decls.omp_array_data (var, true) != NULL;\n+\t    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_HAS_DEVICE_ADDR && is_array_data)\n+\t      goto omp_firstprivatize_data_region;\n \n \t    if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IS_DEVICE_PTR\n \t\t&& OMP_CLAUSE_CODE (c) != OMP_CLAUSE_HAS_DEVICE_ADDR)"}, {"sha": "4740f8a45d3fe86a5a2f2e23c1660736de23dff6", "filename": "libgomp/target.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d1a2f91325fa8cc011149e27e5093a988b3a49/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d1a2f91325fa8cc011149e27e5093a988b3a49/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=49d1a2f91325fa8cc011149e27e5093a988b3a49", "patch": "@@ -1352,7 +1352,24 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\tgomp_copy_host2dev (devicep, aq,\n \t\t\t\t    (void *) (tgt->tgt_start + tgt_size),\n \t\t\t\t    (void *) hostaddrs[i], len, false, cbufp);\n+\t\t/* Save device address in hostaddr to permit latter availablity\n+\t\t   when doing a deep-firstprivate with pointer attach.  */\n+\t\thostaddrs[i] = (void *) (tgt->tgt_start + tgt_size);\n \t\ttgt_size += len;\n+\n+\t\t/* If followed by GOMP_MAP_ATTACH, pointer assign this\n+\t\t   firstprivate to hostaddrs[i+1], which is assumed to contain a\n+\t\t   device address.  */\n+\t\tif (i + 1 < mapnum\n+\t\t    && (GOMP_MAP_ATTACH\n+\t\t\t== (typemask & get_kind (short_mapkind, kinds, i+1))))\n+\t\t  {\n+\t\t    uintptr_t target = (uintptr_t) hostaddrs[i];\n+\t\t    void *devptr = *(void**) hostaddrs[i+1] + sizes[i+1];\n+\t\t    gomp_copy_host2dev (devicep, aq, devptr, &target,\n+\t\t\t\t\tsizeof (void *), false, cbufp);\n+\t\t    ++i;\n+\t\t  }\n \t\tcontinue;\n \t      case GOMP_MAP_FIRSTPRIVATE_INT:\n \t      case GOMP_MAP_ZERO_LEN_ARRAY_SECTION:\n@@ -2519,6 +2536,11 @@ copy_firstprivate_data (char *tgt, size_t mapnum, void **hostaddrs,\n \tmemcpy (tgt + tgt_size, hostaddrs[i], sizes[i]);\n \thostaddrs[i] = tgt + tgt_size;\n \ttgt_size = tgt_size + sizes[i];\n+\tif (i + 1 < mapnum && (kinds[i+1] & 0xff) == GOMP_MAP_ATTACH)\n+\t  {\n+\t    *(*(uintptr_t**) hostaddrs[i+1] + sizes[i+1]) = (uintptr_t) hostaddrs[i];\n+\t    ++i;\n+\t  }\n       }\n }\n "}, {"sha": "7b77992a21dda9e918c51c85514cbb28528bd66a", "filename": "libgomp/testsuite/libgomp.fortran/target-firstprivate-1.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d1a2f91325fa8cc011149e27e5093a988b3a49/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-firstprivate-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d1a2f91325fa8cc011149e27e5093a988b3a49/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-firstprivate-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-firstprivate-1.f90?ref=49d1a2f91325fa8cc011149e27e5093a988b3a49", "patch": "@@ -0,0 +1,33 @@\n+! PR fortran/104949\n+\n+implicit none (type,external)\n+integer, allocatable :: A(:)\n+A = [1,2,3,4,5,6]\n+\n+!$omp parallel firstprivate(A)\n+!$omp master\n+  if (any (A /= [1,2,3,4,5])) error stop\n+  A(:) = [99,88,77,66,55]\n+!$omp end master\n+!$omp end parallel\n+\n+!$omp target firstprivate(A)\n+  if (any (A /= [1,2,3,4,5])) error stop\n+  A(:) = [99,88,77,66,55]\n+!$omp end target\n+if (any (A /= [1,2,3,4,5])) error stop\n+\n+!$omp parallel default(firstprivate)\n+!$omp master\n+  if (any (A /= [1,2,3,4,5])) error stop\n+  A(:) = [99,88,77,66,55]\n+!$omp end master\n+!$omp end parallel\n+if (any (A /= [1,2,3,4,5])) error stop\n+\n+!$omp target defaultmap(firstprivate)\n+  if (any (A /= [1,2,3,4,5])) error stop\n+  A(:) = [99,88,77,66,55]\n+!$omp end target\n+if (any (A /= [1,2,3,4,5])) error stop\n+end"}, {"sha": "d00b4070c11abc811de13c81236bbd6e52236bb5", "filename": "libgomp/testsuite/libgomp.fortran/target-firstprivate-2.f90", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d1a2f91325fa8cc011149e27e5093a988b3a49/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-firstprivate-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d1a2f91325fa8cc011149e27e5093a988b3a49/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-firstprivate-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-firstprivate-2.f90?ref=49d1a2f91325fa8cc011149e27e5093a988b3a49", "patch": "@@ -0,0 +1,113 @@\n+! PR fortran/104949\n+\n+module m\n+use omp_lib\n+implicit none (type, external)\n+\n+contains\n+subroutine one\n+  integer, allocatable :: x(:)\n+  integer :: i\n+\n+  do i = 1, omp_get_num_devices() + 1\n+    !$omp target firstprivate(x)\n+      if (allocated(x)) error stop\n+    !$omp end target\n+    if (allocated(x)) error stop\n+  end do\n+\n+  do i = 1, omp_get_num_devices() + 1\n+    !$omp target firstprivate(x, i)\n+      if (allocated(x)) error stop\n+      x = [10,20,30,40] + i\n+      if (any (x /= [10,20,30,40] + i)) error stop\n+      ! This leaks memory!\n+      ! deallocate(x)\n+    !$omp end target\n+    if (allocated(x)) error stop\n+  end do\n+\n+  x = [1,2,3,4]\n+\n+  do i = 1, omp_get_num_devices() + 1\n+    !$omp target firstprivate(x, i)\n+      if (i <= 0) error stop\n+      if (.not.allocated(x)) error stop\n+      if (size(x) /= 4) error stop\n+      if (lbound(x,1) /= 1) error stop\n+      if (any (x /= [1,2,3,4])) error stop\n+      ! no reallocation, just malloced + assignment\n+      x = [10,20,30,40] + i\n+      if (any (x /= [10,20,30,40] + i)) error stop\n+      ! This leaks memory!\n+      ! deallocate(x)\n+    !$omp end target\n+    if (.not.allocated(x)) error stop\n+    if (size(x) /= 4) error stop\n+    if (lbound(x,1) /= 1) error stop\n+    if (any (x /= [1,2,3,4])) error stop\n+  end do\n+  deallocate(x)\n+end\n+\n+subroutine two\n+  character(len=:), allocatable :: x(:)\n+  character(len=5)  :: str\n+  integer :: i\n+\n+  str = \"abcde\" ! work around for PR fortran/91544\n+  do i = 1, omp_get_num_devices() + 1\n+    !$omp target firstprivate(x)\n+      if (allocated(x)) error stop\n+    !$omp end target\n+    if (allocated(x)) error stop\n+  end do\n+\n+  do i = 1, omp_get_num_devices() + 1\n+    !$omp target firstprivate(x, i)\n+      if (allocated(x)) error stop\n+      ! no reallocation, just malloced + assignment\n+      x = [character(len=2+i) :: str,\"fhji\",\"klmno\"]\n+      if (len(x) /= 2+i) error stop\n+      if (any (x /= [character(len=2+i) :: str,\"fhji\",\"klmno\"])) error stop\n+      ! This leaks memory!\n+      ! deallocate(x)\n+    !$omp end target\n+    if (allocated(x)) error stop\n+  end do\n+\n+  x = [character(len=4) :: \"ABCDE\",\"FHJI\",\"KLMNO\"]\n+\n+  do i = 1, omp_get_num_devices() + 1\n+    !$omp target firstprivate(x, i)\n+      if (i <= 0) error stop\n+      if (.not.allocated(x)) error stop\n+      if (size(x) /= 3) error stop\n+      if (lbound(x,1) /= 1) error stop\n+      if (len(x) /= 4) error stop\n+      if (any (x /= [character(len=4) :: \"ABCDE\",\"FHJI\",\"KLMNO\"])) error stop\n+      !! Reallocation runs into the issue PR fortran/105538\n+      !!\n+      !!x = [character(len=2+i) :: str,\"fhji\",\"klmno\"]\n+      !!if (len(x) /= 2+i) error stop\n+      !!if (any (x /= [character(len=2+i) :: str,\"fhji\",\"klmno\"])) error stop\n+      !! This leaks memory!\n+      !! deallocate(x)\n+      ! Just assign:\n+      x = [character(len=4) :: \"abcde\",\"fhji\",\"klmno\"]\n+      if (any (x /= [character(len=4) :: \"abcde\",\"fhji\",\"klmno\"])) error stop\n+    !$omp end target\n+    if (.not.allocated(x)) error stop\n+    if (lbound(x,1) /= 1) error stop\n+    if (size(x) /= 3) error stop\n+    if (len(x) /= 4) error stop\n+    if (any (x /= [character(len=4) :: \"ABCDE\",\"FHJI\",\"KLMNO\"])) error stop\n+  end do\n+  deallocate(x)\n+end\n+end module m\n+\n+use m\n+call one\n+call two\n+end"}, {"sha": "7406cdc4e413b718748c7b9cd17e26772aa41237", "filename": "libgomp/testsuite/libgomp.fortran/target-firstprivate-3.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d1a2f91325fa8cc011149e27e5093a988b3a49/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-firstprivate-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d1a2f91325fa8cc011149e27e5093a988b3a49/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-firstprivate-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-firstprivate-3.f90?ref=49d1a2f91325fa8cc011149e27e5093a988b3a49", "patch": "@@ -0,0 +1,24 @@\n+implicit none\n+  integer, allocatable :: x(:)\n+  x = [1,2,3,4]\n+  call foo(x)\n+  if (any (x /= [1,2,3,4])) error stop\n+  call foo()\n+contains\n+subroutine foo(c)\n+  integer, allocatable, optional :: c(:)\n+  logical :: is_present\n+  is_present = present (c)\n+  !$omp target firstprivate(c)\n+    if (is_present) then\n+      if (.not. allocated(c)) error stop\n+      if (any (c /= [1,2,3,4])) error stop\n+      c = [99,88,77,66]\n+      if (any (c /= [99,88,77,66])) error stop\n+    end if\n+  !$omp end target\n+  if (is_present) then\n+    if (any (c /= [1,2,3,4])) error stop\n+  end if\n+end\n+end"}]}