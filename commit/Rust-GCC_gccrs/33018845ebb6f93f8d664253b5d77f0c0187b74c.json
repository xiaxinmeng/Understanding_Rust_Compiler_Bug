{"sha": "33018845ebb6f93f8d664253b5d77f0c0187b74c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzMwMTg4NDVlYmI2ZjkzZjhkNjY0MjUzYjVkNzdmMGMwMTg3Yjc0Yw==", "commit": {"author": {"name": "Ulrich Weigand", "email": "ulrich.weigand@linaro.org", "date": "2012-05-04T12:46:04Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2012-05-04T12:46:04Z"}, "message": "re PR tree-optimization/52633 (Compiler ICE in vect_is_simple_use_1 (ARM))\n\n\tgcc/\n\tPR tree-optimization/52633\n\t* tree-vect-patterns.c (vect_vect_recog_func_ptrs): Swap order of\n\tvect_recog_widen_shift_pattern and vect_recog_over_widening_pattern.\n\t(vect_recog_over_widening_pattern): Remove handling of code that was\n\talready detected as over-widening pattern.  Remove special handling\n\tof \"unsigned\" cases.  Instead, support general case of conversion\n\tof the shift result to another type.\n\n\tgcc/testsuite/\n\tPR tree-optimization/52633\n\t* gcc.dg/vect/vect-over-widen-1.c: Two patterns should now be\n\trecognized as widening shifts instead of over-widening.\n\t* gcc.dg/vect/vect-over-widen-1-big-array.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-4.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-4-big-array.c: Likewise.\n\t* gcc.target/arm/pr52633.c: New test.\n\nFrom-SVN: r187158", "tree": {"sha": "56c691e07c1a6e95679faaa805e2259418d41bbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56c691e07c1a6e95679faaa805e2259418d41bbd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33018845ebb6f93f8d664253b5d77f0c0187b74c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33018845ebb6f93f8d664253b5d77f0c0187b74c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33018845ebb6f93f8d664253b5d77f0c0187b74c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33018845ebb6f93f8d664253b5d77f0c0187b74c/comments", "author": null, "committer": null, "parents": [{"sha": "9a7a4398d3b33eb4ea3be8094e7a381921f6a4f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a7a4398d3b33eb4ea3be8094e7a381921f6a4f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a7a4398d3b33eb4ea3be8094e7a381921f6a4f6"}], "stats": {"total": 167, "additions": 74, "deletions": 93}, "files": [{"sha": "a60912a16f7c83620a302249839262c45386d7aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33018845ebb6f93f8d664253b5d77f0c0187b74c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33018845ebb6f93f8d664253b5d77f0c0187b74c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=33018845ebb6f93f8d664253b5d77f0c0187b74c", "patch": "@@ -1,3 +1,13 @@\n+2012-05-04  Ulrich Weigand  <ulrich.weigand@linaro.org>\n+\n+\tPR tree-optimization/52633\n+\t* tree-vect-patterns.c (vect_vect_recog_func_ptrs): Swap order of\n+\tvect_recog_widen_shift_pattern and vect_recog_over_widening_pattern.\n+\t(vect_recog_over_widening_pattern): Remove handling of code that was\n+\talready detected as over-widening pattern.  Remove special handling\n+\tof \"unsigned\" cases.  Instead, support general case of conversion\n+\tof the shift result to another type.\n+\n 2012-05-04  Ulrich Weigand  <ulrich.weigand@linaro.org>\n \n \t* tree-vect-patterns.c (vect_single_imm_use): New function."}, {"sha": "e456366e0e14f6facaaa36437b29c4b1b73574bc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33018845ebb6f93f8d664253b5d77f0c0187b74c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33018845ebb6f93f8d664253b5d77f0c0187b74c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=33018845ebb6f93f8d664253b5d77f0c0187b74c", "patch": "@@ -1,3 +1,13 @@\n+2012-05-04  Ulrich Weigand  <ulrich.weigand@linaro.org>\n+\n+\tPR tree-optimization/52633\n+\t* gcc.dg/vect/vect-over-widen-1.c: Two patterns should now be\n+\trecognized as widening shifts instead of over-widening.\n+\t* gcc.dg/vect/vect-over-widen-1-big-array.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-4.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-4-big-array.c: Likewise.\n+\t* gcc.target/arm/pr52633.c: New test.\n+\n 2012-05-04  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/53168"}, {"sha": "5df349a155e47a96d71067517277bcc18389dc9b", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-1-big-array.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33018845ebb6f93f8d664253b5d77f0c0187b74c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-1-big-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33018845ebb6f93f8d664253b5d77f0c0187b74c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-1-big-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-1-big-array.c?ref=33018845ebb6f93f8d664253b5d77f0c0187b74c", "patch": "@@ -58,7 +58,9 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 4 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_shift_pattern: detected\" 2 \"vect\" { target vect_widen_shift } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 2 \"vect\" { target vect_widen_shift } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 4 \"vect\" { target { ! vect_widen_shift } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "e358209ab107ce1695ae2c78aa7dac42a1722d8d", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-1.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33018845ebb6f93f8d664253b5d77f0c0187b74c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33018845ebb6f93f8d664253b5d77f0c0187b74c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-1.c?ref=33018845ebb6f93f8d664253b5d77f0c0187b74c", "patch": "@@ -58,7 +58,9 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 4 \"vect\" { target {! vect_sizes_32B_16B} } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_shift_pattern: detected\" 2 \"vect\" { target vect_widen_shift } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 2 \"vect\" { target vect_widen_shift } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 4 \"vect\" { target { { ! vect_sizes_32B_16B } && { ! vect_widen_shift } } } } } */\n /* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 8 \"vect\" { target vect_sizes_32B_16B } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "900250f0471a1494732b25e8f83f8019115f5936", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-4-big-array.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33018845ebb6f93f8d664253b5d77f0c0187b74c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-4-big-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33018845ebb6f93f8d664253b5d77f0c0187b74c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-4-big-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-4-big-array.c?ref=33018845ebb6f93f8d664253b5d77f0c0187b74c", "patch": "@@ -62,7 +62,9 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 4 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_shift_pattern: detected\" 2 \"vect\" { target vect_widen_shift } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 2 \"vect\" { target vect_widen_shift } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 4 \"vect\" { target { ! vect_widen_shift } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "70f12fef7d3801c2ed042606d210eadf8daa4ab5", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-4.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33018845ebb6f93f8d664253b5d77f0c0187b74c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33018845ebb6f93f8d664253b5d77f0c0187b74c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-4.c?ref=33018845ebb6f93f8d664253b5d77f0c0187b74c", "patch": "@@ -62,7 +62,9 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 4 \"vect\" { target {! vect_sizes_32B_16B } } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_shift_pattern: detected\" 2 \"vect\" { target vect_widen_shift } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 2 \"vect\" { target vect_widen_shift } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 4 \"vect\" { target { { ! vect_sizes_32B_16B } && { ! vect_widen_shift } } } } } */\n /* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 8 \"vect\" { target vect_sizes_32B_16B } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "b904d59d95caade6a294190acbdc5d2ba1a7b329", "filename": "gcc/testsuite/gcc.target/arm/pr52633.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33018845ebb6f93f8d664253b5d77f0c0187b74c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr52633.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33018845ebb6f93f8d664253b5d77f0c0187b74c/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr52633.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr52633.c?ref=33018845ebb6f93f8d664253b5d77f0c0187b74c", "patch": "@@ -0,0 +1,13 @@\n+/* PR tree-optimization/52633 */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-march=armv7-a -mfloat-abi=softfp -mfpu=neon -O -ftree-vectorize\" } */\n+\n+void\n+test (unsigned short *x, signed char *y)\n+{\n+  int i;\n+  for (i = 0; i < 32; i++)\n+    x[i] = (short) (y[i] << 5);\n+}\n+"}, {"sha": "b4fadf8b69e0621c9126833eea4df0e90f5a383a", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 29, "deletions": 89, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33018845ebb6f93f8d664253b5d77f0c0187b74c/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33018845ebb6f93f8d664253b5d77f0c0187b74c/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=33018845ebb6f93f8d664253b5d77f0c0187b74c", "patch": "@@ -63,8 +63,8 @@ static vect_recog_func_ptr vect_vect_recog_func_ptrs[NUM_PATTERNS] = {\n \tvect_recog_widen_sum_pattern,\n \tvect_recog_dot_prod_pattern,\n \tvect_recog_pow_pattern,\n-\tvect_recog_over_widening_pattern,\n \tvect_recog_widen_shift_pattern,\n+\tvect_recog_over_widening_pattern,\n \tvect_recog_vector_vector_shift_pattern,\n \tvect_recog_sdivmod_pow2_pattern,\n \tvect_recog_mixed_size_cond_pattern,\n@@ -1309,16 +1309,20 @@ vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n \n   where type 'TYPE' is at least double the size of type 'type'.\n \n-  Also detect unsigned cases:\n+  Also detect cases where the shift result is immediately converted\n+  to another type 'result_type' that is no larger in size than 'TYPE'.\n+  In those cases we perform a widen-shift that directly results in\n+  'result_type', to avoid a possible over-widening situation:\n \n-  unsigned type a_t;\n-  unsigned TYPE u_res_T;\n+  type a_t;\n   TYPE a_T, res_T;\n+  result_type res_result;\n \n   S1 a_t = ;\n   S2 a_T = (TYPE) a_t;\n   S3 res_T = a_T << CONST;\n-  S4 u_res_T = (unsigned TYPE) res_T;\n+  S4 res_result = (result_type) res_T;\n+      '--> res_result' = a_t w<< CONST;\n \n   And a case when 'TYPE' is 4 times bigger than 'type'.  In that case we\n   create an additional pattern stmt for S2 to create a variable of an\n@@ -1359,60 +1363,21 @@ vect_recog_widen_shift_pattern (VEC (gimple, heap) **stmts,\n   gimple def_stmt0;\n   tree oprnd0, oprnd1;\n   tree type, half_type0;\n-  gimple pattern_stmt, orig_stmt = NULL;\n+  gimple pattern_stmt;\n   tree vectype, vectype_out = NULL_TREE;\n   tree dummy;\n   tree var;\n   enum tree_code dummy_code;\n   int dummy_int;\n   VEC (tree, heap) * dummy_vec;\n-  gimple use_stmt = NULL;\n-  bool over_widen = false;\n+  gimple use_stmt;\n   bool promotion;\n \n   if (!is_gimple_assign (last_stmt) || !vinfo_for_stmt (last_stmt))\n     return NULL;\n \n-  orig_stmt = last_stmt;\n   if (STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (last_stmt)))\n-    {\n-      /* This statement was also detected as over-widening operation (it can't\n-         be any other pattern, because only over-widening detects shifts).\n-         LAST_STMT is the final type demotion statement, but its related\n-         statement is shift.  We analyze the related statement to catch cases:\n-\n-         orig code:\n-          type a_t;\n-          itype res;\n-          TYPE a_T, res_T;\n-\n-          S1 a_T = (TYPE) a_t;\n-          S2 res_T = a_T << CONST;\n-          S3 res = (itype)res_T;\n-\n-          (size of type * 2 <= size of itype\n-           and size of itype * 2 <= size of TYPE)\n-\n-         code after over-widening pattern detection:\n-\n-          S1 a_T = (TYPE) a_t;\n-               --> a_it = (itype) a_t;\n-          S2 res_T = a_T << CONST;\n-          S3 res = (itype)res_T;  <--- LAST_STMT\n-               --> res = a_it << CONST;\n-\n-         after widen_shift:\n-\n-          S1 a_T = (TYPE) a_t;\n-               --> a_it = (itype) a_t; - redundant\n-          S2 res_T = a_T << CONST;\n-          S3 res = (itype)res_T;\n-               --> res = a_t w<< CONST;\n-\n-      i.e., we replace the three statements with res = a_t w<< CONST.  */\n-      last_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (last_stmt));\n-      over_widen = true;\n-    }\n+    return NULL;\n \n   if (gimple_assign_rhs_code (last_stmt) != LSHIFT_EXPR)\n     return NULL;\n@@ -1436,49 +1401,29 @@ vect_recog_widen_shift_pattern (VEC (gimple, heap) **stmts,\n   oprnd0 = gimple_assign_rhs1 (def_stmt0);\n   type = gimple_expr_type (last_stmt);\n \n+  /* Check for subsequent conversion to another type.  */\n+  use_stmt = vect_single_imm_use (last_stmt);\n+  if (use_stmt && is_gimple_assign (use_stmt)\n+      && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt))\n+      && !STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (use_stmt)))\n+    {\n+      tree use_lhs = gimple_assign_lhs (use_stmt);\n+      tree use_type = TREE_TYPE (use_lhs);\n+\n+      if (INTEGRAL_TYPE_P (use_type)\n+\t  && TYPE_PRECISION (use_type) <= TYPE_PRECISION (type))\n+\t{\n+\t  last_stmt = use_stmt;\n+\t  type = use_type;\n+\t}\n+    }\n+\n   /* Check if this a widening operation.  */\n   if (!vect_handle_widen_op_by_const (last_stmt, LSHIFT_EXPR, oprnd1,\n        \t\t\t\t      &oprnd0, stmts,\n \t                              type, &half_type0, def_stmt0))\n     return NULL;\n \n-  /* Handle unsigned case.  Look for\n-     S4  u_res_T = (unsigned TYPE) res_T;\n-     Use unsigned TYPE as the type for WIDEN_LSHIFT_EXPR.  */\n-  if (TYPE_UNSIGNED (type) != TYPE_UNSIGNED (half_type0))\n-    {\n-      if (over_widen)\n-        {\n-          /* In case of over-widening pattern, S4 should be ORIG_STMT itself.\n-             We check here that TYPE is the correct type for the operation,\n-             i.e., it's the type of the original result.  */\n-          tree orig_type = gimple_expr_type (orig_stmt);\n-          if ((TYPE_UNSIGNED (type) != TYPE_UNSIGNED (orig_type))\n-              || (TYPE_PRECISION (type) != TYPE_PRECISION (orig_type)))\n-            return NULL;\n-        }\n-      else\n-        {\n-\t  tree use_type;\n-\t  tree use_lhs;\n-\n-\t  use_stmt = vect_single_imm_use (last_stmt);\n-\t  if (!use_stmt || !is_gimple_assign (use_stmt)\n-\t      || !CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt)))\n-\t    return NULL;\n-\n-          use_lhs = gimple_assign_lhs (use_stmt);\n-          use_type = TREE_TYPE (use_lhs);\n-\n-          if (!INTEGRAL_TYPE_P (use_type)\n-              || (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (use_type))\n-              || (TYPE_PRECISION (type) != TYPE_PRECISION (use_type)))\n-            return NULL;\n-\n-          type = use_type;\n-        }\n-    }\n-\n   /* Pattern detected.  */\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"vect_recog_widen_shift_pattern: detected: \");\n@@ -1507,11 +1452,6 @@ vect_recog_widen_shift_pattern (VEC (gimple, heap) **stmts,\n   if (vect_print_dump_info (REPORT_DETAILS))\n     print_gimple_stmt (vect_dump, pattern_stmt, 0, TDF_SLIM);\n \n-  if (use_stmt)\n-    last_stmt = use_stmt;\n-  else\n-    last_stmt = orig_stmt;\n-\n   VEC_safe_push (gimple, heap, *stmts, last_stmt);\n   return pattern_stmt;\n }"}]}