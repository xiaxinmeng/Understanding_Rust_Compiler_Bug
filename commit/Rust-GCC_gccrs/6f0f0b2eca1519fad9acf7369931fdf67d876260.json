{"sha": "6f0f0b2eca1519fad9acf7369931fdf67d876260", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYwZjBiMmVjYTE1MTlmYWQ5YWNmNzM2OTkzMWZkZjY3ZDg3NjI2MA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-04-05T22:23:27Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-04-05T22:23:27Z"}, "message": "PR fortran/25829 28655\n\n2008-04-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\t    Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n\n\tPR fortran/25829 28655\n\t* dump-parse-tree.c (gfc_show_code_node): Show new I/O parameters.\n\t* gfortran.h (gfc_statement): Add ST_WAIT enumerator.\n\t(gfc_open): Add pointers for decimal, encoding, round, sign,\n\tasynchronous. (gfc_inquire): Add pointers for asynchronous, decimal,\n\tencoding, pending, round, sign, size, id.\n\t(gfc_wait): New typedef struct. (gfc_dt): Add pointers for id, pos,\n\tasynchronous, blank, decimal, delim, pad, round, sign.\n\t(gfc_exec_op): Add EXEC_WAIT enumerator. (gfc_code): Add pointer for\n\twait. (gfc_free_wait), (gfc_resolve_wait): New function prototypes.\n\t* trans-stmt.h (gfc_trans_wait): New function prototype.\n\t* trans.c (gfc_trans_code): Add case for EXEC_WAIT.\n\t* io.c (io_tag): Add new tags for DECIMAL, ENCODING, ROUND, SIGN,\n\tASYCHRONOUS, ID. (match_open_element): Add matchers for new tags.\n\t(gfc_free_open): Free new pointers. (gfc_resolve_open): Resolve new\n\ttags. (gfc_resolve_open): Remove comment around check for allowed\n\tvalues and ASYNCHRONOUS, update it.  Likewise for DECIMAL, ENCODING,\n\tROUND, and SIGN. (match_dt_element): Add matching for new tags.\n\t(gfc_free_wait): New function. (gfc_resolve_wait): New function.\n\t(match_wait_element): New function. (gfc_match_wait): New function.\n\t* resolve.c (gfc_resolve_blocks): Add case for EXEC_WAIT.\n\t(resolve_code): Add case for EXEC_WAIT. \n\t* st.c (gfc_free_statement): Add case for EXEC_WAIT.\n\t* trans-io.c (ioparam_type): Add IOPARM_ptype_wait. (gfc_st_parameter):\n\tAdd \"wait\" entry. (iocall): Add IOCALL_WAIT enumerator.\n\t(gfc_build_io_library_fndecls): Add function declaration for st_wait.\n\t(gfc_trans_open): Add mask bits for new I/O tags.\n\t(gfc_trans_inquire): Add mask bits for new I/O tags.\n\t(gfc_trans_wait): New translation function.\n\t(build_dt): Add mask bits for new I/O tags.\n\t* match.c (gfc_match_if) Add matcher for \"wait\".\n\t* match.h (gfc_match_wait): Prototype for new function.\n\t* ioparm.def: Add new I/O parameter definitions.\n\t* parse.c (decode_statement): Add match for \"wait\" statement.\n\t(next_statement): Add case for ST_WAIT. (gfc_ascii_statement): Same.\n\nCo-Authored-By: Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n\nFrom-SVN: r133944", "tree": {"sha": "c3b9d6b3dd92b1e32dc74b6b5924e2197dc1bd4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3b9d6b3dd92b1e32dc74b6b5924e2197dc1bd4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f0f0b2eca1519fad9acf7369931fdf67d876260", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f0f0b2eca1519fad9acf7369931fdf67d876260", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f0f0b2eca1519fad9acf7369931fdf67d876260", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f0f0b2eca1519fad9acf7369931fdf67d876260/comments", "author": null, "committer": null, "parents": [{"sha": "10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef"}], "stats": {"total": 970, "additions": 877, "deletions": 93}, "files": [{"sha": "b534d8ea9f5b57997efa3d4b6b600666de6b55c0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6f0f0b2eca1519fad9acf7369931fdf67d876260", "patch": "@@ -1,3 +1,42 @@\n+2008-04-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\t    Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/25829 28655\n+\t* dump-parse-tree.c (gfc_show_code_node): Show new I/O parameters.\n+\t* gfortran.h (gfc_statement): Add ST_WAIT enumerator.\n+\t(gfc_open): Add pointers for decimal, encoding, round, sign,\n+\tasynchronous. (gfc_inquire): Add pointers for asynchronous, decimal,\n+\tencoding, pending, round, sign, size, id.\n+\t(gfc_wait): New typedef struct. (gfc_dt): Add pointers for id, pos,\n+\tasynchronous, blank, decimal, delim, pad, round, sign.\n+\t(gfc_exec_op): Add EXEC_WAIT enumerator. (gfc_code): Add pointer for\n+\twait. (gfc_free_wait), (gfc_resolve_wait): New function prototypes.\n+\t* trans-stmt.h (gfc_trans_wait): New function prototype.\n+\t* trans.c (gfc_trans_code): Add case for EXEC_WAIT.\n+\t* io.c (io_tag): Add new tags for DECIMAL, ENCODING, ROUND, SIGN,\n+\tASYCHRONOUS, ID. (match_open_element): Add matchers for new tags.\n+\t(gfc_free_open): Free new pointers. (gfc_resolve_open): Resolve new\n+\ttags. (gfc_resolve_open): Remove comment around check for allowed\n+\tvalues and ASYNCHRONOUS, update it.  Likewise for DECIMAL, ENCODING,\n+\tROUND, and SIGN. (match_dt_element): Add matching for new tags.\n+\t(gfc_free_wait): New function. (gfc_resolve_wait): New function.\n+\t(match_wait_element): New function. (gfc_match_wait): New function.\n+\t* resolve.c (gfc_resolve_blocks): Add case for EXEC_WAIT.\n+\t(resolve_code): Add case for EXEC_WAIT. \n+\t* st.c (gfc_free_statement): Add case for EXEC_WAIT.\n+\t* trans-io.c (ioparam_type): Add IOPARM_ptype_wait. (gfc_st_parameter):\n+\tAdd \"wait\" entry. (iocall): Add IOCALL_WAIT enumerator.\n+\t(gfc_build_io_library_fndecls): Add function declaration for st_wait.\n+\t(gfc_trans_open): Add mask bits for new I/O tags.\n+\t(gfc_trans_inquire): Add mask bits for new I/O tags.\n+\t(gfc_trans_wait): New translation function.\n+\t(build_dt): Add mask bits for new I/O tags.\n+\t* match.c (gfc_match_if) Add matcher for \"wait\".\n+\t* match.h (gfc_match_wait): Prototype for new function.\n+\t* ioparm.def: Add new I/O parameter definitions.\n+\t* parse.c (decode_statement): Add match for \"wait\" statement.\n+\t(next_statement): Add case for ST_WAIT. (gfc_ascii_statement): Same.\n+\n 2008-04-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/35786"}, {"sha": "dc3ab32fedf086fd78532fbf3072eb47736c9ebc", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=6f0f0b2eca1519fad9acf7369931fdf67d876260", "patch": "@@ -1405,11 +1405,36 @@ gfc_show_code_node (int level, gfc_code *c)\n \t  gfc_status (\" PAD=\");\n \t  gfc_show_expr (open->pad);\n \t}\n+      if (open->decimal)\n+\t{\n+\t  gfc_status (\" DECIMAL=\");\n+\t  gfc_show_expr (open->decimal);\n+\t}\n+      if (open->encoding)\n+\t{\n+\t  gfc_status (\" ENCODING=\");\n+\t  gfc_show_expr (open->encoding);\n+\t}\n+      if (open->round)\n+\t{\n+\t  gfc_status (\" ROUND=\");\n+\t  gfc_show_expr (open->round);\n+\t}\n+      if (open->sign)\n+\t{\n+\t  gfc_status (\" SIGN=\");\n+\t  gfc_show_expr (open->sign);\n+\t}\n       if (open->convert)\n \t{\n \t  gfc_status (\" CONVERT=\");\n \t  gfc_show_expr (open->convert);\n \t}\n+      if (open->asynchronous)\n+\t{\n+\t  gfc_status (\" ASYNCHRONOUS=\");\n+\t  gfc_show_expr (open->asynchronous);\n+\t}\n       if (open->err != NULL)\n \tgfc_status (\" ERR=%d\", open->err->value);\n \n@@ -1616,6 +1641,46 @@ gfc_show_code_node (int level, gfc_code *c)\n \t  gfc_status (\" CONVERT=\");\n \t  gfc_show_expr (i->convert);\n \t}\n+      if (i->asynchronous)\n+\t{\n+\t  gfc_status (\" ASYNCHRONOUS=\");\n+\t  gfc_show_expr (i->asynchronous);\n+\t}\n+      if (i->decimal)\n+\t{\n+\t  gfc_status (\" DECIMAL=\");\n+\t  gfc_show_expr (i->decimal);\n+\t}\n+      if (i->encoding)\n+\t{\n+\t  gfc_status (\" ENCODING=\");\n+\t  gfc_show_expr (i->encoding);\n+\t}\n+      if (i->pending)\n+\t{\n+\t  gfc_status (\" PENDING=\");\n+\t  gfc_show_expr (i->pending);\n+\t}\n+      if (i->round)\n+\t{\n+\t  gfc_status (\" ROUND=\");\n+\t  gfc_show_expr (i->round);\n+\t}\n+      if (i->sign)\n+\t{\n+\t  gfc_status (\" SIGN=\");\n+\t  gfc_show_expr (i->sign);\n+\t}\n+      if (i->size)\n+\t{\n+\t  gfc_status (\" SIZE=\");\n+\t  gfc_show_expr (i->size);\n+\t}\n+      if (i->id)\n+\t{\n+\t  gfc_status (\" ID=\");\n+\t  gfc_show_expr (i->id);\n+\t}\n \n       if (i->err != NULL)\n \tgfc_status (\" ERR=%d\", i->err->value);\n@@ -1678,6 +1743,51 @@ gfc_show_code_node (int level, gfc_code *c)\n \t  gfc_status (\" ADVANCE=\");\n \t  gfc_show_expr (dt->advance);\n \t}\n+      if (dt->id)\n+\t{\n+\t  gfc_status (\" ID=\");\n+\t  gfc_show_expr (dt->id);\n+\t}\n+      if (dt->pos)\n+\t{\n+\t  gfc_status (\" POS=\");\n+\t  gfc_show_expr (dt->pos);\n+\t}\n+      if (dt->asynchronous)\n+\t{\n+\t  gfc_status (\" ASYNCHRONOUS=\");\n+\t  gfc_show_expr (dt->asynchronous);\n+\t}\n+      if (dt->blank)\n+\t{\n+\t  gfc_status (\" BLANK=\");\n+\t  gfc_show_expr (dt->blank);\n+\t}\n+      if (dt->decimal)\n+\t{\n+\t  gfc_status (\" DECIMAL=\");\n+\t  gfc_show_expr (dt->decimal);\n+\t}\n+      if (dt->delim)\n+\t{\n+\t  gfc_status (\" DELIM=\");\n+\t  gfc_show_expr (dt->delim);\n+\t}\n+      if (dt->pad)\n+\t{\n+\t  gfc_status (\" PAD=\");\n+\t  gfc_show_expr (dt->pad);\n+\t}\n+      if (dt->round)\n+\t{\n+\t  gfc_status (\" ROUND=\");\n+\t  gfc_show_expr (dt->round);\n+\t}\n+      if (dt->sign)\n+\t{\n+\t  gfc_status (\" SIGN=\");\n+\t  gfc_show_expr (dt->sign);\n+\t}\n \n     show_dt_code:\n       gfc_status_char ('\\n');"}, {"sha": "009dbc88aea57aba73616353a986ab468fbc2d2f", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=6f0f0b2eca1519fad9acf7369931fdf67d876260", "patch": "@@ -211,8 +211,8 @@ typedef enum\n   ST_IF_BLOCK, ST_IMPLICIT, ST_IMPLICIT_NONE, ST_IMPORT, ST_INQUIRE, ST_INTERFACE,\n   ST_PARAMETER, ST_MODULE, ST_MODULE_PROC, ST_NAMELIST, ST_NULLIFY, ST_OPEN,\n   ST_PAUSE, ST_PRIVATE, ST_PROGRAM, ST_PUBLIC, ST_READ, ST_RETURN, ST_REWIND,\n-  ST_STOP, ST_SUBROUTINE, ST_TYPE, ST_USE, ST_WHERE_BLOCK, ST_WHERE, ST_WRITE,\n-  ST_ASSIGNMENT, ST_POINTER_ASSIGNMENT, ST_SELECT_CASE, ST_SEQUENCE,\n+  ST_STOP, ST_SUBROUTINE, ST_TYPE, ST_USE, ST_WHERE_BLOCK, ST_WHERE, ST_WAIT, \n+  ST_WRITE, ST_ASSIGNMENT, ST_POINTER_ASSIGNMENT, ST_SELECT_CASE, ST_SEQUENCE,\n   ST_SIMPLE_IF, ST_STATEMENT_FUNCTION, ST_DERIVED_DECL, ST_LABEL_ASSIGNMENT,\n   ST_ENUM, ST_ENUMERATOR, ST_END_ENUM,\n   ST_OMP_ATOMIC, ST_OMP_BARRIER, ST_OMP_CRITICAL, ST_OMP_END_CRITICAL,\n@@ -1635,7 +1635,8 @@ gfc_alloc;\n typedef struct\n {\n   gfc_expr *unit, *file, *status, *access, *form, *recl,\n-    *blank, *position, *action, *delim, *pad, *iostat, *iomsg, *convert;\n+    *blank, *position, *action, *delim, *pad, *iostat, *iomsg, *convert,\n+    *decimal, *encoding, *round, *sign, *asynchronous, *id;\n   gfc_st_label *err;\n }\n gfc_open;\n@@ -1662,7 +1663,8 @@ typedef struct\n   gfc_expr *unit, *file, *iostat, *exist, *opened, *number, *named,\n     *name, *access, *sequential, *direct, *form, *formatted,\n     *unformatted, *recl, *nextrec, *blank, *position, *action, *read,\n-    *write, *readwrite, *delim, *pad, *iolength, *iomsg, *convert, *strm_pos;\n+    *write, *readwrite, *delim, *pad, *iolength, *iomsg, *convert, *strm_pos,\n+    *asynchronous, *decimal, *encoding, *pending, *round, *sign, *size, *id;\n \n   gfc_st_label *err;\n \n@@ -1672,7 +1674,17 @@ gfc_inquire;\n \n typedef struct\n {\n-  gfc_expr *io_unit, *format_expr, *rec, *advance, *iostat, *size, *iomsg;\n+  gfc_expr *unit, *iostat, *iomsg, *id;\n+  gfc_st_label *err, *end, *eor;\n+}\n+gfc_wait;\n+\n+\n+typedef struct\n+{\n+  gfc_expr *io_unit, *format_expr, *rec, *advance, *iostat, *size, *iomsg,\n+\t   *id, *pos, *asynchronous, *blank, *decimal, *delim, *pad, *round,\n+\t   *sign;\n \n   gfc_symbol *namelist;\n   /* A format_label of `format_asterisk' indicates the \"*\" format */\n@@ -1701,7 +1713,7 @@ typedef enum\n   EXEC_IF, EXEC_ARITHMETIC_IF, EXEC_DO, EXEC_DO_WHILE, EXEC_SELECT,\n   EXEC_FORALL, EXEC_WHERE, EXEC_CYCLE, EXEC_EXIT,\n   EXEC_ALLOCATE, EXEC_DEALLOCATE,\n-  EXEC_OPEN, EXEC_CLOSE,\n+  EXEC_OPEN, EXEC_CLOSE, EXEC_WAIT,\n   EXEC_READ, EXEC_WRITE, EXEC_IOLENGTH, EXEC_TRANSFER, EXEC_DT_END,\n   EXEC_BACKSPACE, EXEC_ENDFILE, EXEC_INQUIRE, EXEC_REWIND, EXEC_FLUSH,\n   EXEC_OMP_CRITICAL, EXEC_OMP_DO, EXEC_OMP_FLUSH, EXEC_OMP_MASTER,\n@@ -1738,6 +1750,7 @@ typedef struct gfc_code\n     gfc_close *close;\n     gfc_filepos *filepos;\n     gfc_inquire *inquire;\n+    gfc_wait *wait;\n     gfc_dt *dt;\n     gfc_forall_iterator *forall_iterator;\n     struct gfc_code *whichloop;\n@@ -2323,6 +2336,8 @@ void gfc_free_inquire (gfc_inquire *);\n try gfc_resolve_inquire (gfc_inquire *);\n void gfc_free_dt (gfc_dt *);\n try gfc_resolve_dt (gfc_dt *);\n+void gfc_free_wait (gfc_wait *);\n+try gfc_resolve_wait (gfc_wait *);\n \n /* module.c */\n void gfc_module_init_2 (void);"}, {"sha": "917acc3443e9a572038daeb127c3b3e12e00f1b0", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 498, "deletions": 76, "changes": 574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=6f0f0b2eca1519fad9acf7369931fdf67d876260", "patch": "@@ -48,6 +48,10 @@ static const io_tag\n \ttag_e_action\t= {\"ACTION\", \" action = %e\", BT_CHARACTER},\n \ttag_e_delim\t= {\"DELIM\", \" delim = %e\", BT_CHARACTER},\n \ttag_e_pad\t= {\"PAD\", \" pad = %e\", BT_CHARACTER},\n+\ttag_e_decimal\t= {\"DECIMAL\", \" decimal = %e\", BT_CHARACTER},\n+\ttag_e_encoding\t= {\"ENCODING\", \" encoding = %e\", BT_CHARACTER},\n+\ttag_e_round\t= {\"ROUND\", \" round = %e\", BT_CHARACTER},\n+\ttag_e_sign\t= {\"SIGN\", \" sign = %e\", BT_CHARACTER},\n \ttag_unit\t= {\"UNIT\", \" unit = %e\", BT_INTEGER},\n \ttag_advance\t= {\"ADVANCE\", \" advance = %e\", BT_CHARACTER},\n \ttag_rec\t\t= {\"REC\", \" rec = %e\", BT_INTEGER},\n@@ -82,7 +86,9 @@ static const io_tag\n \ttag_strm_out    = {\"POS\", \" pos = %v\", BT_INTEGER},\n \ttag_err\t\t= {\"ERR\", \" err = %l\", BT_UNKNOWN},\n \ttag_end\t\t= {\"END\", \" end = %l\", BT_UNKNOWN},\n-\ttag_eor\t\t= {\"EOR\", \" eor = %l\", BT_UNKNOWN};\n+\ttag_eor\t\t= {\"EOR\", \" eor = %l\", BT_UNKNOWN},\n+\ttag_async\t= {\"ASYNCHRONOUS\", \" asynchronous = %e\", BT_CHARACTER},\n+\ttag_id\t\t= {\"ID\", \" id = %v\", BT_INTEGER};\n \n static gfc_dt *current_dt;\n \n@@ -97,7 +103,8 @@ typedef enum\n   FMT_NONE, FMT_UNKNOWN, FMT_SIGNED_INT, FMT_ZERO, FMT_POSINT, FMT_PERIOD,\n   FMT_COMMA, FMT_COLON, FMT_SLASH, FMT_DOLLAR, FMT_POS, FMT_LPAREN,\n   FMT_RPAREN, FMT_X, FMT_SIGN, FMT_BLANK, FMT_CHAR, FMT_P, FMT_IBOZ, FMT_F,\n-  FMT_E, FMT_EXT, FMT_G, FMT_L, FMT_A, FMT_D, FMT_H, FMT_END, FMT_ERROR\n+  FMT_E, FMT_EXT, FMT_G, FMT_L, FMT_A, FMT_D, FMT_H, FMT_END, FMT_ERROR, FMT_DC,\n+  FMT_DP\n }\n format_token;\n \n@@ -420,7 +427,26 @@ format_lex (void)\n       break;\n \n     case 'D':\n-      token = FMT_D;\n+      c = next_char_not_space (&error);\n+      if (c == 'P')\n+\t{\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: DP format \"\n+\t      \"specifier not allowed at %C\") == FAILURE)\n+\t  return FMT_ERROR;\n+\t  token = FMT_DP;\n+\t}\n+      else if (c == 'C')\n+\t{\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: DC format \"\n+\t      \"specifier not allowed at %C\") == FAILURE)\n+\t  return FMT_ERROR;\n+\t  token = FMT_DC;\n+\t}\n+      else\n+\t{\n+\t  token = FMT_D;\n+\t  unget_char ();\n+\t}\n       break;\n \n     case '\\0':\n@@ -537,6 +563,8 @@ check_format (bool is_input)\n \n     case FMT_SIGN:\n     case FMT_BLANK:\n+    case FMT_DP:\n+    case FMT_DC:\n       goto between_desc;\n \n     case FMT_CHAR:\n@@ -590,6 +618,8 @@ check_format (bool is_input)\n     {\n     case FMT_SIGN:\n     case FMT_BLANK:\n+    case FMT_DP:\n+    case FMT_DC:\n     case FMT_X:\n       break;\n \n@@ -1224,6 +1254,9 @@ match_open_element (gfc_open *open)\n {\n   match m;\n \n+  m = match_etag (&tag_async, &open->asynchronous);\n+  if (m != MATCH_NO)\n+    return m;\n   m = match_etag (&tag_unit, &open->unit);\n   if (m != MATCH_NO)\n     return m;\n@@ -1261,6 +1294,18 @@ match_open_element (gfc_open *open)\n   if (m != MATCH_NO)\n     return m;\n   m = match_etag (&tag_e_pad, &open->pad);\n+  if (m != MATCH_NO)\n+    return m;\n+  m = match_etag (&tag_e_decimal, &open->decimal);\n+  if (m != MATCH_NO)\n+    return m;\n+  m = match_etag (&tag_e_encoding, &open->encoding);\n+  if (m != MATCH_NO)\n+    return m;\n+  m = match_etag (&tag_e_round, &open->round);\n+  if (m != MATCH_NO)\n+    return m;\n+  m = match_etag (&tag_e_sign, &open->sign);\n   if (m != MATCH_NO)\n     return m;\n   m = match_ltag (&tag_err, &open->err);\n@@ -1295,7 +1340,12 @@ gfc_free_open (gfc_open *open)\n   gfc_free_expr (open->action);\n   gfc_free_expr (open->delim);\n   gfc_free_expr (open->pad);\n+  gfc_free_expr (open->decimal);\n+  gfc_free_expr (open->encoding);\n+  gfc_free_expr (open->round);\n+  gfc_free_expr (open->sign);\n   gfc_free_expr (open->convert);\n+  gfc_free_expr (open->asynchronous);\n   gfc_free (open);\n }\n \n@@ -1319,6 +1369,10 @@ gfc_resolve_open (gfc_open *open)\n   RESOLVE_TAG (&tag_e_action, open->action);\n   RESOLVE_TAG (&tag_e_delim, open->delim);\n   RESOLVE_TAG (&tag_e_pad, open->pad);\n+  RESOLVE_TAG (&tag_e_decimal, open->decimal);\n+  RESOLVE_TAG (&tag_e_encoding, open->encoding);\n+  RESOLVE_TAG (&tag_e_round, open->round);\n+  RESOLVE_TAG (&tag_e_sign, open->sign);\n   RESOLVE_TAG (&tag_convert, open->convert);\n \n   if (gfc_reference_st_label (open->err, ST_LABEL_TARGET) == FAILURE)\n@@ -1501,63 +1555,97 @@ gfc_match_open (void)\n     }\n \n   /* Checks on the ASYNCHRONOUS specifier.  */\n-  /* TODO: code is ready, just needs uncommenting when async I/O support\n-     is added ;-)\n-  if (open->asynchronous && open->asynchronous->expr_type == EXPR_CONSTANT)\n+  if (open->asynchronous)\n     {\n-      static const char * asynchronous[] = { \"YES\", \"NO\", NULL };\n-\n-      if (!compare_to_allowed_values\n-\t\t(\"action\", asynchronous, NULL, NULL,\n-\t\t open->asynchronous->value.character.string, \"OPEN\", warn))\n+      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ASYNCHRONOUS= at %C \"\n+\t  \"not allowed in Fortran 95\") == FAILURE)\n \tgoto cleanup;\n-    }*/\n-  \n+\n+      if (open->asynchronous->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  static const char * asynchronous[] = { \"YES\", \"NO\", NULL };\n+\n+\t  if (!compare_to_allowed_values (\"ASYNCHRONOUS\", asynchronous,\n+\t\t\tNULL, NULL, open->asynchronous->value.character.string,\n+\t\t\t\"OPEN\", warn))\n+\t    goto cleanup;\n+\t}\n+    }\n+\n   /* Checks on the BLANK specifier.  */\n-  if (open->blank && open->blank->expr_type == EXPR_CONSTANT)\n+  if (open->blank)\n     {\n-      static const char *blank[] = { \"ZERO\", \"NULL\", NULL };\n-\n-      if (!compare_to_allowed_values (\"BLANK\", blank, NULL, NULL,\n-\t\t\t\t      open->blank->value.character.string,\n-\t\t\t\t      \"OPEN\", warn))\n+      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: BLANK= at %C \"\n+\t  \"not allowed in Fortran 95\") == FAILURE)\n \tgoto cleanup;\n+\n+      if (open->blank->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  static const char *blank[] = { \"ZERO\", \"NULL\", NULL };\n+\n+\t  if (!compare_to_allowed_values (\"BLANK\", blank, NULL, NULL,\n+\t\t\t\t\t  open->blank->value.character.string,\n+\t\t\t\t\t  \"OPEN\", warn))\n+\t    goto cleanup;\n+\t}\n     }\n \n   /* Checks on the DECIMAL specifier.  */\n-  /* TODO: uncomment this code when DECIMAL support is added \n-  if (open->decimal && open->decimal->expr_type == EXPR_CONSTANT)\n+  if (open->decimal)\n     {\n-      static const char * decimal[] = { \"COMMA\", \"POINT\", NULL };\n-\n-      if (!compare_to_allowed_values (\"DECIMAL\", decimal, NULL, NULL,\n-\t\t\t\t      open->decimal->value.character.string,\n-\t\t\t\t      \"OPEN\", warn))\n+      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: DECIMAL= at %C \"\n+\t  \"not allowed in Fortran 95\") == FAILURE)\n \tgoto cleanup;\n-    } */\n+\n+      if (open->decimal->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  static const char * decimal[] = { \"COMMA\", \"POINT\", NULL };\n+\n+\t  if (!compare_to_allowed_values (\"DECIMAL\", decimal, NULL, NULL,\n+\t\t\t\t\t  open->decimal->value.character.string,\n+\t\t\t\t\t  \"OPEN\", warn))\n+\t    goto cleanup;\n+\t}\n+    }\n \n   /* Checks on the DELIM specifier.  */\n-  if (open->delim && open->delim->expr_type == EXPR_CONSTANT)\n+  if (open->delim)\n     {\n-      static const char *delim[] = { \"APOSTROPHE\", \"QUOTE\", \"NONE\", NULL };\n-\n-      if (!compare_to_allowed_values (\"DELIM\", delim, NULL, NULL,\n-\t\t\t\t      open->delim->value.character.string,\n-\t\t\t\t      \"OPEN\", warn))\n+      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: DELIM= at %C \"\n+\t  \"not allowed in Fortran 95\") == FAILURE)\n \tgoto cleanup;\n+\n+      if (open->delim->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  static const char *delim[] = { \"APOSTROPHE\", \"QUOTE\", \"NONE\", NULL };\n+\n+\t  if (!compare_to_allowed_values (\"DELIM\", delim, NULL, NULL,\n+\t\t\t\t\t  open->delim->value.character.string,\n+\t\t\t\t\t  \"OPEN\", warn))\n+\t  goto cleanup;\n+\t}\n     }\n \n   /* Checks on the ENCODING specifier.  */\n-  /* TODO: uncomment this code when ENCODING support is added \n-  if (open->encoding && open->encoding->expr_type == EXPR_CONSTANT)\n+  if (open->encoding)\n     {\n-      static const char * encoding[] = { \"UTF-8\", \"DEFAULT\", NULL };\n+      /* When implemented, change the following to use gfc_notify_std F2003.\n+      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ENCODING= at %C \"\n+\t  \"not allowed in Fortran 95\") == FAILURE)\n+\tgoto cleanup; */\n+      gfc_error (\"F2003 Feature: ENCODING=specifier at %C not implemented\");\n+      goto cleanup;\n+    \n+      if (open->encoding->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  static const char * encoding[] = { \"UTF-8\", \"DEFAULT\", NULL };\n \n-      if (!compare_to_allowed_values (\"ENCODING\", encoding, NULL, NULL,\n-\t\t\t\t      open->encoding->value.character.string,\n-\t\t\t\t      \"OPEN\", warn))\n-\tgoto cleanup;\n-    } */\n+\t  if (!compare_to_allowed_values (\"ENCODING\", encoding, NULL, NULL,\n+\t\t\t\t\t  open->encoding->value.character.string,\n+\t\t\t\t\t  \"OPEN\", warn))\n+\t  goto cleanup;\n+\t}\n+    }\n \n   /* Checks on the FORM specifier.  */\n   if (open->form && open->form->expr_type == EXPR_CONSTANT)\n@@ -1593,30 +1681,43 @@ gfc_match_open (void)\n     }\n \n   /* Checks on the ROUND specifier.  */\n-  /* TODO: uncomment this code when ROUND support is added \n-  if (open->round && open->round->expr_type == EXPR_CONSTANT)\n+  if (open->round)\n     {\n-      static const char * round[] = { \"UP\", \"DOWN\", \"ZERO\", \"NEAREST\",\n-\t\t\t\t      \"COMPATIBLE\", \"PROCESSOR_DEFINED\", NULL };\n+      /* When implemented, change the following to use gfc_notify_std F2003.  */\n+      gfc_error (\"F2003 Feature: ROUND=specifier at %C not implemented\");\n+      goto cleanup;\n \n-      if (!compare_to_allowed_values (\"ROUND\", round, NULL, NULL,\n-\t\t\t\t      open->round->value.character.string,\n-\t\t\t\t      \"OPEN\", warn))\n-\tgoto cleanup;\n-    } */\n+      if (open->round->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  static const char * round[] = { \"UP\", \"DOWN\", \"ZERO\", \"NEAREST\",\n+\t\t\t\t\t  \"COMPATIBLE\", \"PROCESSOR_DEFINED\",\n+\t\t\t\t\t   NULL };\n+\n+\t  if (!compare_to_allowed_values (\"ROUND\", round, NULL, NULL,\n+\t\t\t\t\t  open->round->value.character.string,\n+\t\t\t\t\t  \"OPEN\", warn))\n+\t  goto cleanup;\n+\t}\n+    }\n \n   /* Checks on the SIGN specifier.  */\n-  /* TODO: uncomment this code when SIGN support is added \n-  if (open->sign && open->sign->expr_type == EXPR_CONSTANT)\n+  if (open->sign) \n     {\n-      static const char * sign[] = { \"PLUS\", \"SUPPRESS\", \"PROCESSOR_DEFINED\",\n-\t\t\t\t     NULL };\n-\n-      if (!compare_to_allowed_values (\"SIGN\", sign, NULL, NULL,\n-\t\t\t\t      open->sign->value.character.string,\n-\t\t\t\t      \"OPEN\", warn))\n+      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: SIGN= at %C \"\n+\t  \"not allowed in Fortran 95\") == FAILURE)\n \tgoto cleanup;\n-    } */\n+\n+      if (open->sign->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  static const char * sign[] = { \"PLUS\", \"SUPPRESS\", \"PROCESSOR_DEFINED\",\n+\t\t\t\t\t  NULL };\n+\n+\t  if (!compare_to_allowed_values (\"SIGN\", sign, NULL, NULL,\n+\t\t\t\t\t  open->sign->value.character.string,\n+\t\t\t\t\t  \"OPEN\", warn))\n+\t  goto cleanup;\n+\t}\n+    }\n \n #define warn_or_error(...) \\\n { \\\n@@ -1648,8 +1749,8 @@ gfc_match_open (void)\n \t\t\t\t      \"OPEN\", warn))\n \tgoto cleanup;\n \n-      /* F2003, 9.4.5: If the STATUS= specifier has the value NEW or REPLACE,\n-\t the FILE= specifier shall appear.  */\n+      /* F2003, 9.4.5: If the STATUS=specifier has the value NEW or REPLACE,\n+\t the FILE=specifier shall appear.  */\n       if (open->file == NULL\n \t  && (strncasecmp (open->status->value.character.string, \"replace\", 7)\n \t      == 0\n@@ -1661,8 +1762,8 @@ gfc_match_open (void)\n \t\t\t open->status->value.character.string);\n \t}\n \n-      /* F2003, 9.4.5: If the STATUS= specifier has the value SCRATCH,\n-\t the FILE= specifier shall not appear.  */\n+      /* F2003, 9.4.5: If the STATUS=specifier has the value SCRATCH,\n+\t the FILE=specifier shall not appear.  */\n       if (strncasecmp (open->status->value.character.string, \"scratch\", 7)\n \t  == 0 && open->file)\n \t{\n@@ -1674,11 +1775,8 @@ gfc_match_open (void)\n \n   /* Things that are not allowed for unformatted I/O.  */\n   if (open->form && open->form->expr_type == EXPR_CONSTANT\n-      && (open->delim\n-\t  /* TODO uncomment this code when F2003 support is finished */\n-\t  /* || open->decimal || open->encoding || open->round\n-\t     || open->sign */\n-\t  || open->pad || open->blank)\n+      && (open->delim || open->decimal || open->encoding || open->round\n+\t  || open->sign || open->pad || open->blank)\n       && strncasecmp (open->form->value.character.string,\n \t\t      \"unformatted\", 11) == 0)\n     {\n@@ -2203,6 +2301,30 @@ match_dt_element (io_kind k, gfc_dt *dt)\n       return MATCH_YES;\n     }\n \n+  m = match_etag (&tag_async, &dt->asynchronous);\n+  if (m != MATCH_NO)\n+    return m;\n+  m = match_etag (&tag_e_blank, &dt->blank);\n+  if (m != MATCH_NO)\n+    return m;\n+  m = match_etag (&tag_e_delim, &dt->delim);\n+  if (m != MATCH_NO)\n+    return m;\n+  m = match_etag (&tag_e_pad, &dt->pad);\n+  if (m != MATCH_NO)\n+    return m;\n+  m = match_etag (&tag_e_sign, &dt->sign);\n+  if (m != MATCH_NO)\n+    return m;\n+  m = match_etag (&tag_e_round, &dt->round);\n+  if (m != MATCH_NO)\n+    return m;\n+  m = match_out_tag (&tag_id, &dt->id);\n+  if (m != MATCH_NO)\n+    return m;\n+  m = match_etag (&tag_e_decimal, &dt->decimal);\n+  if (m != MATCH_NO)\n+    return m;\n   m = match_etag (&tag_rec, &dt->rec);\n   if (m != MATCH_NO)\n     return m;\n@@ -2265,6 +2387,12 @@ gfc_free_dt (gfc_dt *dt)\n   gfc_free_expr (dt->iomsg);\n   gfc_free_expr (dt->iostat);\n   gfc_free_expr (dt->size);\n+  gfc_free_expr (dt->pad);\n+  gfc_free_expr (dt->delim);\n+  gfc_free_expr (dt->sign);\n+  gfc_free_expr (dt->round);\n+  gfc_free_expr (dt->blank);\n+  gfc_free_expr (dt->decimal);\n   gfc_free (dt);\n }\n \n@@ -2283,6 +2411,12 @@ gfc_resolve_dt (gfc_dt *dt)\n   RESOLVE_TAG (&tag_iomsg, dt->iomsg);\n   RESOLVE_TAG (&tag_iostat, dt->iostat);\n   RESOLVE_TAG (&tag_size, dt->size);\n+  RESOLVE_TAG (&tag_e_pad, dt->pad);\n+  RESOLVE_TAG (&tag_e_delim, dt->delim);\n+  RESOLVE_TAG (&tag_e_sign, dt->sign);\n+  RESOLVE_TAG (&tag_e_round, dt->round);\n+  RESOLVE_TAG (&tag_e_blank, dt->blank);\n+  RESOLVE_TAG (&tag_e_decimal, dt->decimal);\n \n   e = dt->io_unit;\n   if (gfc_resolve_expr (e) == SUCCESS\n@@ -2648,6 +2782,11 @@ if (condition) \\\n   match m;\n   gfc_expr *expr;\n   gfc_symbol *sym = NULL;\n+  bool warn, unformatted;\n+\n+  warn = (dt->err || dt->iostat) ? true : false;\n+  unformatted = dt->format_expr == NULL && dt->format_label == NULL\n+\t\t&& dt->namelist == NULL;\n \n   m = MATCH_YES;\n \n@@ -2669,11 +2808,14 @@ if (condition) \\\n \t\t     \"REC tag at %L is incompatible with internal file\",\n \t\t     &dt->rec->where);\n \n-      io_constraint (dt->format_expr == NULL && dt->format_label == NULL\n-\t\t     && dt->namelist == NULL,\n+      io_constraint (unformatted,\n \t\t     \"Unformatted I/O not allowed with internal unit at %L\",\n \t\t     &dt->io_unit->where);\n \n+      io_constraint (dt->asynchronous != NULL,\n+\t\t     \"ASYNCHRONOUS tag at %L not allowed with internal file\",\n+\t\t     &dt->asynchronous->where);\n+\n       if (dt->namelist != NULL)\n \t{\n \t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Internal file \"\n@@ -2696,7 +2838,6 @@ if (condition) \\\n \t\t     io_kind_name (k));\n     }\n \n-\n   if (k != M_READ)\n     {\n       io_constraint (dt->end, \"END tag not allowed with output at %L\",\n@@ -2705,8 +2846,13 @@ if (condition) \\\n       io_constraint (dt->eor, \"EOR tag not allowed with output at %L\",\n \t\t     &dt->eor_where);\n \n-      io_constraint (k != M_READ && dt->size,\n-\t\t     \"SIZE=specifier not allowed with output at %L\",\n+      io_constraint (dt->blank, \"BLANK=specifier not allowed with output at %L\",\n+\t\t     &dt->blank->where);\n+\n+      io_constraint (dt->pad, \"PAD=specifier not allowed with output at %L\",\n+\t\t     &dt->pad->where);\n+\n+      io_constraint (dt->size, \"SIZE=specifier not allowed with output at %L\",\n \t\t     &dt->size->where);\n     }\n   else\n@@ -2720,8 +2866,167 @@ if (condition) \\\n \t\t     &dt->eor_where);\n     }\n \n+  if (dt->asynchronous && dt->asynchronous->expr_type == EXPR_CONSTANT)\n+    {\n+      static const char * asynchronous[] = { \"YES\", \"NO\", NULL };\n+\n+      if (!compare_to_allowed_values\n+\t\t(\"ASYNCHRONOUS\", asynchronous, NULL, NULL,\n+\t\t dt->asynchronous->value.character.string,\n+\t\t io_kind_name (k), warn))\n+\treturn MATCH_ERROR;\n+    }\n+\n+  if (dt->id)\n+    {\n+      io_constraint (dt->asynchronous\n+\t\t     && strcmp (dt->asynchronous->value.character.string,\n+\t\t\t\t \"yes\"),\n+\t\t     \"ID=specifier at %L must be with ASYNCHRONOUS='yes' \"\n+\t\t     \"specifier\", &dt->id->where);\n+    }\n+\n+  if (dt->decimal)\n+    {\n+      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: DECIMAL= at %C \"\n+\t  \"not allowed in Fortran 95\") == FAILURE)\n+\treturn MATCH_ERROR;\n+\n+      if (dt->decimal->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  static const char * decimal[] = { \"COMMA\", \"POINT\", NULL };\n+\n+\t  if (!compare_to_allowed_values (\"DECIMAL\", decimal, NULL, NULL,\n+\t\t\t\t\t  dt->decimal->value.character.string,\n+\t\t\t\t\t  io_kind_name (k), warn))\n+\t    return MATCH_ERROR;\n+\n+\t  io_constraint (unformatted,\n+\t\t\t \"the DECIMAL=specifier at %L must be with an \"\n+\t\t\t \"explicit format expression\", &dt->decimal->where);\n+\t}\n+    }\n+  \n+  if (dt->blank)\n+    {\n+      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: BLANK= at %C \"\n+\t  \"not allowed in Fortran 95\") == FAILURE)\n+\treturn MATCH_ERROR;\n+\n+      if (dt->blank->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  static const char * blank[] = { \"NULL\", \"ZERO\", NULL };\n+\n+\t  if (!compare_to_allowed_values (\"BLANK\", blank, NULL, NULL,\n+\t\t\t\t\t  dt->blank->value.character.string,\n+\t\t\t\t\t  io_kind_name (k), warn))\n+\t    return MATCH_ERROR;\n+\n+\t  io_constraint (unformatted,\n+\t\t\t \"the BLANK=specifier at %L must be with an \"\n+\t\t\t \"explicit format expression\", &dt->blank->where);\n+\t}\n+    }\n+\n+  if (dt->pad)\n+    {\n+      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: PAD= at %C \"\n+\t  \"not allowed in Fortran 95\") == FAILURE)\n+\treturn MATCH_ERROR;\n+\n+      if (dt->pad->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  static const char * pad[] = { \"YES\", \"NO\", NULL };\n+\n+\t  if (!compare_to_allowed_values (\"PAD\", pad, NULL, NULL,\n+\t\t\t\t\t  dt->pad->value.character.string,\n+\t\t\t\t\t  io_kind_name (k), warn))\n+\t    return MATCH_ERROR;\n+\n+\t  io_constraint (unformatted,\n+\t\t\t \"the PAD=specifier at %L must be with an \"\n+\t\t\t \"explicit format expression\", &dt->pad->where);\n+\t}\n+    }\n+\n+  if (dt->round)\n+    {\n+      /* When implemented, change the following to use gfc_notify_std F2003.\n+      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ROUND= at %C \"\n+\t  \"not allowed in Fortran 95\") == FAILURE)\n+\treturn MATCH_ERROR;  */\n+      gfc_error (\"F2003 Feature: ROUND=specifier at %C not implemented\");\n+      return MATCH_ERROR;\n+\n+      if (dt->round->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  static const char * round[] = { \"UP\", \"DOWN\", \"ZERO\", \"NEAREST\",\n+\t\t\t\t\t  \"COMPATIBLE\", \"PROCESSOR_DEFINED\",\n+\t\t\t\t\t  NULL };\n+\n+\t  if (!compare_to_allowed_values (\"ROUND\", round, NULL, NULL,\n+\t\t\t\t\t  dt->round->value.character.string,\n+\t\t\t\t\t  io_kind_name (k), warn))\n+\t    return MATCH_ERROR;\n+\t}\n+    }\n+  \n+  if (dt->sign)\n+    {\n+      /* When implemented, change the following to use gfc_notify_std F2003.\n+      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: SIGN= at %C \"\n+\t  \"not allowed in Fortran 95\") == FAILURE)\n+\treturn MATCH_ERROR;  */\n+      if (dt->sign->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  static const char * sign[] = { \"PLUS\", \"SUPPRESS\", \"PROCESSOR_DEFINED\",\n+\t\t\t\t\t NULL };\n+\n+\t  if (!compare_to_allowed_values (\"SIGN\", sign, NULL, NULL,\n+\t\t\t\t      dt->sign->value.character.string,\n+\t\t\t\t      io_kind_name (k), warn))\n+\t    return MATCH_ERROR;\n+\n+\t  io_constraint (unformatted,\n+\t\t\t \"SIGN=specifier at %L must be with an \"\n+\t\t\t \"explicit format expression\", &dt->sign->where);\n \n+\t  io_constraint (k == M_READ,\n+\t\t\t \"SIGN=specifier at %L not allowed in a \"\n+\t\t\t \"READ statement\", &dt->sign->where);\n+\t}\n+    }\n+\n+  if (dt->delim)\n+    {\n+      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: DELIM= at %C \"\n+\t  \"not allowed in Fortran 95\") == FAILURE)\n+\treturn MATCH_ERROR;\n \n+      if (dt->delim->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  static const char *delim[] = { \"APOSTROPHE\", \"QUOTE\", \"NONE\", NULL };\n+\n+\t  if (!compare_to_allowed_values (\"DELIM\", delim, NULL, NULL,\n+\t\t\t\t\t  dt->delim->value.character.string,\n+\t\t\t\t\t  io_kind_name (k), warn))\n+\t    return MATCH_ERROR;\n+\n+\t  io_constraint (k == M_READ,\n+\t\t\t \"DELIM=specifier at %L not allowed in a \"\n+\t\t\t \"READ statement\", &dt->delim->where);\n+      \n+\t  io_constraint (dt->format_label != &format_asterisk\n+\t\t\t && dt->namelist == NULL,\n+\t\t\t \"DELIM=specifier at %L must have FMT=*\",\n+\t\t\t &dt->delim->where);\n+\n+\t  io_constraint (unformatted && dt->namelist == NULL,\n+\t\t\t \"DELIM=specifier at %L must be with FMT=* or \"\n+\t\t\t \"NML=specifier \", &dt->delim->where);\n+\t}\n+    }\n+  \n   if (dt->namelist)\n     {\n       io_constraint (io_code && dt->namelist,\n@@ -2752,7 +3057,6 @@ if (condition) \\\n \t\t     \"An END tag is not allowed with a \"\n \t\t     \"REC=specifier at %L.\", &dt->end_where);\n \n-\n       io_constraint (dt->format_label == &format_asterisk,\n \t\t     \"FMT=* is not allowed with a REC=specifier \"\n \t\t     \"at %L.\", spec_end);\n@@ -2767,8 +3071,7 @@ if (condition) \\\n \t\t     \"List directed format(*) is not allowed with a \"\n \t\t     \"ADVANCE=specifier at %L.\", &expr->where);\n \n-      io_constraint (dt->format_expr == NULL && dt->format_label == NULL\n-\t\t     && dt->namelist == NULL,\n+      io_constraint (unformatted,\n \t\t     \"the ADVANCE=specifier at %L must appear with an \"\n \t\t     \"explicit format expression\", &expr->where);\n \n@@ -3025,12 +3328,14 @@ gfc_match_read (void)\n   return match_io (M_READ);\n }\n \n+\n match\n gfc_match_write (void)\n {\n   return match_io (M_WRITE);\n }\n \n+\n match\n gfc_match_print (void)\n {\n@@ -3289,3 +3594,120 @@ gfc_resolve_inquire (gfc_inquire *inquire)\n \n   return SUCCESS;\n }\n+\n+\n+void\n+gfc_free_wait (gfc_wait *wait)\n+{\n+  if (wait == NULL)\n+    return;\n+\n+  gfc_free_expr (wait->unit);\n+  gfc_free_expr (wait->iostat);\n+  gfc_free_expr (wait->iomsg);\n+  gfc_free_expr (wait->id);\n+}\n+\n+\n+try\n+gfc_resolve_wait (gfc_wait *wait)\n+{\n+  RESOLVE_TAG (&tag_unit, wait->unit);\n+  RESOLVE_TAG (&tag_iomsg, wait->iomsg);\n+  RESOLVE_TAG (&tag_iostat, wait->iostat);\n+  RESOLVE_TAG (&tag_id, wait->id);\n+\n+  if (gfc_reference_st_label (wait->err, ST_LABEL_TARGET) == FAILURE)\n+    return FAILURE;\n+  \n+  if (gfc_reference_st_label (wait->end, ST_LABEL_TARGET) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+/* Match an element of a WAIT statement.  */\n+\n+#define RETM   if (m != MATCH_NO) return m;\n+\n+static match\n+match_wait_element (gfc_wait *wait)\n+{\n+  match m;\n+\n+  m = match_etag (&tag_unit, &wait->unit);\n+  RETM m = match_ltag (&tag_err, &wait->err);\n+  RETM m = match_ltag (&tag_end, &wait->eor);\n+  RETM m = match_ltag (&tag_eor, &wait->end);\n+  RETM m = match_out_tag (&tag_iomsg, &wait->iomsg);\n+  RETM m = match_out_tag (&tag_iostat, &wait->iostat);\n+  RETM m = match_etag (&tag_id, &wait->id);\n+  RETM return MATCH_NO;\n+}\n+\n+#undef RETM\n+\n+\n+match\n+gfc_match_wait (void)\n+{\n+  gfc_wait *wait;\n+  match m;\n+  locus loc;\n+\n+  m = gfc_match_char ('(');\n+  if (m == MATCH_NO)\n+    return m;\n+\n+  wait = gfc_getmem (sizeof (gfc_wait));\n+\n+  loc = gfc_current_locus;\n+\n+  m = match_wait_element (wait);\n+  if (m == MATCH_ERROR)\n+    goto cleanup;\n+  if (m == MATCH_NO)\n+    {\n+      m = gfc_match_expr (&wait->unit);\n+      if (m == MATCH_ERROR)\n+\tgoto cleanup;\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+    }\n+\n+  for (;;)\n+    {\n+      if (gfc_match_char (')') == MATCH_YES)\n+\tbreak;\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tgoto syntax;\n+\n+      m = match_wait_element (wait);\n+      if (m == MATCH_ERROR)\n+\tgoto cleanup;\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+    }\n+\n+  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: WAIT at %C \"\n+\t  \"not allowed in Fortran 95\") == FAILURE)\n+    goto cleanup;\n+\n+  if (gfc_pure (NULL))\n+    {\n+      gfc_error (\"WAIT statement not allowed in PURE procedure at %C\");\n+      goto cleanup;\n+    }\n+\n+  new_st.op = EXEC_WAIT;\n+  new_st.ext.wait = wait;\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_syntax_error (ST_WAIT);\n+\n+cleanup:\n+  gfc_free_wait (wait);\n+  return MATCH_ERROR;\n+}"}, {"sha": "b16fcb53c313b36f0f133932eb8e5ce42087bde4", "filename": "gcc/fortran/ioparm.def", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Fioparm.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Fioparm.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fioparm.def?ref=6f0f0b2eca1519fad9acf7369931fdf67d876260", "patch": "@@ -8,10 +8,10 @@\n #define IOPARM_common_end\t\t(1 << 3)\n #define IOPARM_common_eor\t\t(1 << 4)\n #endif\n-IOPARM (common,  flags,\t\t0,       int4)\n-IOPARM (common,  unit,\t\t0,       int4)\n-IOPARM (common,  filename,\t0,       pchar)\n-IOPARM (common,  line,\t\t0,       int4)\n+IOPARM (common,  flags,\t\t0,\t int4)\n+IOPARM (common,  unit,\t\t0,\t int4)\n+IOPARM (common,  filename,\t0,\t pchar)\n+IOPARM (common,  line,\t\t0,\t int4)\n IOPARM (common,  iomsg,\t\t1 << 6,  char2)\n IOPARM (common,  iostat,\t1 << 5,  pint4)\n IOPARM (open,    common,\t0,\t common)\n@@ -25,7 +25,12 @@ IOPARM (open,    position,\t1 << 13, char1)\n IOPARM (open,    action,\t1 << 14, char2)\n IOPARM (open,    delim,\t\t1 << 15, char1)\n IOPARM (open,    pad,\t\t1 << 16, char2)\n-IOPARM (open,    convert,       1 << 17, char1)\n+IOPARM (open,    convert,\t1 << 17, char1)\n+IOPARM (open,    decimal,\t1 << 18, char2)\n+IOPARM (open,    encoding,\t1 << 19, char1)\n+IOPARM (open,    round,\t\t1 << 20, char2)\n+IOPARM (open,    sign,\t\t1 << 21, char1)\n+IOPARM (open,    asynchronous,\t1 << 22, char2)\n IOPARM (close,   common,\t0,\t common)\n IOPARM (close,   status,\t1 << 7,  char1)\n IOPARM (filepos, common,\t0,\t common)\n@@ -53,7 +58,18 @@ IOPARM (inquire, unformatted,\t1 << 26, char1)\n IOPARM (inquire, read,\t\t1 << 27, char2)\n IOPARM (inquire, write,\t\t1 << 28, char1)\n IOPARM (inquire, readwrite,\t1 << 29, char2)\n-IOPARM (inquire, convert,       1 << 30, char1)\n+IOPARM (inquire, convert,\t1 << 30, char1)\n+IOPARM (inquire, flags2,\t1 << 31, int4)\n+IOPARM (inquire, asynchronous,\t1 << 0,  char1)\n+IOPARM (inquire, decimal,\t1 << 1,  char2)\n+IOPARM (inquire, encoding,\t1 << 2,  char1)\n+IOPARM (inquire, round,\t\t1 << 3,  char2)\n+IOPARM (inquire, sign,\t\t1 << 4,  char1)\n+IOPARM (inquire, pending,\t1 << 5,  pint4)\n+IOPARM (inquire, size,\t\t1 << 6,  pint4)\n+IOPARM (inquire, id,\t\t1 << 7,  pint4)\n+IOPARM (wait,    common,\t0,\t common)\n+IOPARM (wait,    id,\t\t1 << 7,  pint4)\n #ifndef IOPARM_dt_list_format\n #define IOPARM_dt_list_format\t\t(1 << 7)\n #define IOPARM_dt_namelist_read_mode\t(1 << 8)\n@@ -67,4 +83,13 @@ IOPARM (dt,      format,\t1 << 12, char1)\n IOPARM (dt,      advance,\t1 << 13, char2)\n IOPARM (dt,      internal_unit,\t1 << 14, char1)\n IOPARM (dt,      namelist_name,\t1 << 15, char2)\n-IOPARM (dt,      u,\t\t0,       pad)\n+IOPARM (dt,      id,\t\t1 << 16, pint4)\n+IOPARM (dt,      pos,\t\t1 << 17, intio)\n+IOPARM (dt,      asynchronous, \t1 << 18, char1)\n+IOPARM (dt,      blank,\t\t1 << 19, char2)\n+IOPARM (dt,      decimal,\t1 << 20, char1)\n+IOPARM (dt,      delim,\t\t1 << 21, char2)\n+IOPARM (dt,      pad,\t\t1 << 22, char1)\n+IOPARM (dt,      round,\t\t1 << 23, char2)\n+IOPARM (dt,      sign,\t\t1 << 24, char1)\n+IOPARM (dt,      u,\t\t0,\t pad)"}, {"sha": "8512d03a0fba39239b612059828cc7926f003b2e", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=6f0f0b2eca1519fad9acf7369931fdf67d876260", "patch": "@@ -1533,6 +1533,7 @@ gfc_match_if (gfc_statement *if_type)\n   match (\"return\", gfc_match_return, ST_RETURN)\n   match (\"rewind\", gfc_match_rewind, ST_REWIND)\n   match (\"stop\", gfc_match_stop, ST_STOP)\n+  match (\"wait\", gfc_match_wait, ST_WAIT)\n   match (\"where\", match_simple_where, ST_WHERE)\n   match (\"write\", gfc_match_write, ST_WRITE)\n "}, {"sha": "4a3776e2cd8baa65d63cdf5f9c27ff68666a0420", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=6f0f0b2eca1519fad9acf7369931fdf67d876260", "patch": "@@ -212,6 +212,7 @@ match gfc_match_rewind (void);\n match gfc_match_flush (void);\n match gfc_match_inquire (void);\n match gfc_match_read (void);\n+match gfc_match_wait (void);\n match gfc_match_write (void);\n match gfc_match_print (void);\n "}, {"sha": "d7d81a1e30fc7b69ee7ef17e317edfd9b844ab6d", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=6f0f0b2eca1519fad9acf7369931fdf67d876260", "patch": "@@ -440,6 +440,7 @@ decode_statement (void)\n       break;\n \n     case 'w':\n+      match (\"wait\", gfc_match_wait, ST_WAIT);\n       match (\"write\", gfc_match_write, ST_WRITE);\n       break;\n     }\n@@ -861,9 +862,9 @@ next_statement (void)\n   case ST_CLOSE: case ST_CONTINUE: case ST_DEALLOCATE: case ST_END_FILE: \\\n   case ST_GOTO: case ST_INQUIRE: case ST_NULLIFY: case ST_OPEN: \\\n   case ST_READ: case ST_RETURN: case ST_REWIND: case ST_SIMPLE_IF: \\\n-  case ST_PAUSE: case ST_STOP: case ST_WRITE: case ST_ASSIGNMENT: \\\n+  case ST_PAUSE: case ST_STOP: case ST_WAIT: case ST_WRITE: \\\n   case ST_POINTER_ASSIGNMENT: case ST_EXIT: case ST_CYCLE: \\\n-  case ST_ARITHMETIC_IF: case ST_WHERE: case ST_FORALL: \\\n+  case ST_ASSIGNMENT: case ST_ARITHMETIC_IF: case ST_WHERE: case ST_FORALL: \\\n   case ST_LABEL_ASSIGNMENT: case ST_FLUSH: case ST_OMP_FLUSH: \\\n   case ST_OMP_BARRIER\n \n@@ -1268,6 +1269,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_WHERE:\n       p = \"WHERE\";\n       break;\n+    case ST_WAIT:\n+      p = \"WAIT\";\n+      break;\n     case ST_WRITE:\n       p = \"WRITE\";\n       break;"}, {"sha": "65d1a162cac15b0d137c4ab9273c2ac927f70f46", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=6f0f0b2eca1519fad9acf7369931fdf67d876260", "patch": "@@ -5964,6 +5964,7 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \tcase EXEC_READ:\n \tcase EXEC_WRITE:\n \tcase EXEC_IOLENGTH:\n+\tcase EXEC_WAIT:\n \t  break;\n \n \tcase EXEC_OMP_ATOMIC:\n@@ -6373,6 +6374,15 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  resolve_branch (code->ext.inquire->err, code);\n \t  break;\n \n+\tcase EXEC_WAIT:\n+\t  if (gfc_resolve_wait (code->ext.wait) == FAILURE)\n+\t    break;\n+\n+\t  resolve_branch (code->ext.wait->err, code);\n+\t  resolve_branch (code->ext.wait->end, code);\n+\t  resolve_branch (code->ext.wait->eor, code);\n+\t  break;\n+\n \tcase EXEC_READ:\n \tcase EXEC_WRITE:\n \t  if (gfc_resolve_dt (code->ext.dt) == FAILURE)"}, {"sha": "0f0e4813d288801ed3a9da8153ac567f4a8e9fb8", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=6f0f0b2eca1519fad9acf7369931fdf67d876260", "patch": "@@ -146,6 +146,10 @@ gfc_free_statement (gfc_code *p)\n       gfc_free_inquire (p->ext.inquire);\n       break;\n \n+    case EXEC_WAIT:\n+      gfc_free_wait (p->ext.wait);\n+      break;\n+\n     case EXEC_READ:\n     case EXEC_WRITE:\n       gfc_free_dt (p->ext.dt);"}, {"sha": "6bc41e1ce6729f1d3574572b9d9874d8fe6f88f5", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 150, "deletions": 2, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=6f0f0b2eca1519fad9acf7369931fdf67d876260", "patch": "@@ -45,6 +45,7 @@ enum ioparam_type\n   IOPARM_ptype_filepos,\n   IOPARM_ptype_inquire,\n   IOPARM_ptype_dt,\n+  IOPARM_ptype_wait,\n   IOPARM_ptype_num\n };\n \n@@ -96,7 +97,8 @@ static GTY(()) gfc_st_parameter st_parameter[] =\n   { \"close\", NULL },\n   { \"filepos\", NULL },\n   { \"inquire\", NULL },\n-  { \"dt\", NULL }\n+  { \"dt\", NULL },\n+  { \"wait\", NULL }\n };\n \n static GTY(()) gfc_st_parameter_field st_parameter_field[] =\n@@ -133,6 +135,7 @@ enum iocall\n   IOCALL_FLUSH,\n   IOCALL_SET_NML_VAL,\n   IOCALL_SET_NML_VAL_DIM,\n+  IOCALL_WAIT,\n   IOCALL_NUM\n };\n \n@@ -372,6 +375,11 @@ gfc_build_io_library_fndecls (void)\n     gfc_build_library_function_decl(get_identifier (PREFIX(\"st_iolength\")),\n \t\t\t\t    void_type_node, 1, dt_parm_type);\n \n+  parm_type = build_pointer_type (st_parameter[IOPARM_ptype_wait].type);\n+  iocall[IOCALL_WAIT] =\n+    gfc_build_library_function_decl (get_identifier (PREFIX(\"st_wait\")),\n+\t\t\t\t     gfc_int4_type_node, 1, parm_type);\n+\n   parm_type = build_pointer_type (st_parameter[IOPARM_ptype_filepos].type);\n   iocall[IOCALL_REWIND] =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"st_rewind\")),\n@@ -921,6 +929,24 @@ gfc_trans_open (gfc_code * code)\n   if (p->pad)\n     mask |= set_string (&block, &post_block, var, IOPARM_open_pad, p->pad);\n \n+  if (p->decimal)\n+    mask |= set_string (&block, &post_block, var, IOPARM_open_decimal,\n+\t\t\tp->decimal);\n+\n+  if (p->encoding)\n+    mask |= set_string (&block, &post_block, var, IOPARM_open_encoding,\n+\t\t\tp->encoding);\n+\n+  if (p->round)\n+    mask |= set_string (&block, &post_block, var, IOPARM_open_round, p->round);\n+\n+  if (p->sign)\n+    mask |= set_string (&block, &post_block, var, IOPARM_open_sign, p->sign);\n+\n+  if (p->asynchronous)\n+    mask |= set_string (&block, &post_block, var, IOPARM_open_asynchronous,\n+\t\t\tp->asynchronous);\n+\n   if (p->convert)\n     mask |= set_string (&block, &post_block, var, IOPARM_open_convert,\n \t\t\tp->convert);\n@@ -1117,7 +1143,7 @@ gfc_trans_inquire (gfc_code * code)\n   stmtblock_t block, post_block;\n   gfc_inquire *p;\n   tree tmp, var;\n-  unsigned int mask = 0;\n+  unsigned int mask = 0, mask2 = 0;\n \n   gfc_start_block (&block);\n   gfc_init_block (&post_block);\n@@ -1248,6 +1274,43 @@ gfc_trans_inquire (gfc_code * code)\n     mask |= set_parameter_ref (&block, &post_block, var,\n \t\t\t       IOPARM_inquire_strm_pos_out, p->strm_pos);\n \n+  /* The second series of flags.  */\n+  if (p->asynchronous)\n+    mask2 |= set_string (&block, &post_block, var, IOPARM_inquire_asynchronous,\n+\t\t\t p->asynchronous);\n+\n+  if (p->decimal)\n+    mask2 |= set_string (&block, &post_block, var, IOPARM_inquire_decimal,\n+\t\t\t p->decimal);\n+\n+  if (p->encoding)\n+    mask2 |= set_string (&block, &post_block, var, IOPARM_inquire_encoding,\n+\t\t\t p->encoding);\n+\n+  if (p->round)\n+    mask2 |= set_string (&block, &post_block, var, IOPARM_inquire_round,\n+\t\t\t p->round);\n+\n+  if (p->sign)\n+    mask2 |= set_string (&block, &post_block, var, IOPARM_inquire_sign,\n+\t\t\t p->sign);\n+\n+  if (p->pending)\n+    mask2 |= set_parameter_ref (&block, &post_block, var,\n+\t\t\t\tIOPARM_inquire_pending, p->pending);\n+\n+  if (p->size)\n+    mask2 |= set_parameter_ref (&block, &post_block, var, IOPARM_inquire_size,\n+\t\t\t\tp->size);\n+\n+  if (p->id)\n+    mask2 |= set_parameter_value (&block, var, IOPARM_inquire_id, p->id);\n+\n+  set_parameter_const (&block, var, IOPARM_inquire_flags2, mask2);\n+\n+  if (mask2)\n+    mask |= IOPARM_inquire_flags2;\n+\n   set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n   if (p->unit)\n@@ -1266,6 +1329,56 @@ gfc_trans_inquire (gfc_code * code)\n   return gfc_finish_block (&block);\n }\n \n+\n+tree\n+gfc_trans_wait (gfc_code * code)\n+{\n+  stmtblock_t block, post_block;\n+  gfc_wait *p;\n+  tree tmp, var;\n+  unsigned int mask = 0;\n+\n+  gfc_start_block (&block);\n+  gfc_init_block (&post_block);\n+\n+  var = gfc_create_var (st_parameter[IOPARM_ptype_wait].type,\n+\t\t\t\"wait_parm\");\n+\n+  set_error_locus (&block, var, &code->loc);\n+  p = code->ext.wait;\n+\n+  /* Set parameters here.  */\n+  if (p->iomsg)\n+    mask |= set_string (&block, &post_block, var, IOPARM_common_iomsg,\n+\t\t\tp->iomsg);\n+\n+  if (p->iostat)\n+    mask |= set_parameter_ref (&block, &post_block, var, IOPARM_common_iostat,\n+\t\t\t       p->iostat);\n+\n+  if (p->err)\n+    mask |= IOPARM_common_err;\n+\n+  if (p->id)\n+    mask |= set_parameter_value (&block, var, IOPARM_wait_id, p->id);\n+\n+  set_parameter_const (&block, var, IOPARM_common_flags, mask);\n+\n+  if (p->unit)\n+    set_parameter_value (&block, var, IOPARM_common_unit, p->unit);\n+\n+  tmp = build_fold_addr_expr (var);\n+  tmp = build_call_expr (iocall[IOCALL_WAIT], 1, tmp);\n+  gfc_add_expr_to_block (&block, tmp);\n+\n+  gfc_add_block_to_block (&block, &post_block);\n+\n+  io_result (&block, var, p->err, NULL, NULL);\n+\n+  return gfc_finish_block (&block);\n+\n+}\n+\n static gfc_expr *\n gfc_new_nml_name_expr (const char * name)\n {\n@@ -1583,6 +1696,41 @@ build_dt (tree function, gfc_code * code)\n       if (dt->end)\n \tmask |= IOPARM_common_end;\n \n+      if (dt->id)\n+\tmask |= set_parameter_ref (&block, &post_end_block, var,\n+\t\t\t\t   IOPARM_dt_id, dt->id);\n+\n+      if (dt->pos)\n+\tmask |= set_parameter_value (&block, var, IOPARM_dt_pos, dt->pos);\n+\n+      if (dt->asynchronous)\n+\tmask |= set_string (&block, &post_block, var, IOPARM_dt_asynchronous,\n+\t\t\t    dt->asynchronous);\n+\n+      if (dt->blank)\n+\tmask |= set_string (&block, &post_block, var, IOPARM_dt_blank,\n+\t\t\t    dt->blank);\n+\n+      if (dt->decimal)\n+\tmask |= set_string (&block, &post_block, var, IOPARM_dt_decimal,\n+\t\t\t    dt->decimal);\n+\n+      if (dt->delim)\n+\tmask |= set_string (&block, &post_block, var, IOPARM_dt_delim,\n+\t\t\t    dt->delim);\n+\n+      if (dt->pad)\n+\tmask |= set_string (&block, &post_block, var, IOPARM_dt_pad,\n+\t\t\t    dt->pad);\n+\n+      if (dt->round)\n+\tmask |= set_string (&block, &post_block, var, IOPARM_dt_round,\n+\t\t\t    dt->round);\n+\n+      if (dt->sign)\n+\tmask |= set_string (&block, &post_block, var, IOPARM_dt_sign,\n+\t\t\t    dt->sign);\n+\n       if (dt->rec)\n \tmask |= set_parameter_value (&block, var, IOPARM_dt_rec, dt->rec);\n "}, {"sha": "5d92a9c756f90a3996e8f09a05d157dc8bcdf289", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=6f0f0b2eca1519fad9acf7369931fdf67d876260", "patch": "@@ -69,3 +69,4 @@ tree gfc_trans_flush (gfc_code *);\n \n tree gfc_trans_transfer (gfc_code *);\n tree gfc_trans_dt_end (gfc_code *);\n+tree gfc_trans_wait (gfc_code *);"}, {"sha": "a9951e48c57d4d12399430d9352c5bd32475feeb", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f0f0b2eca1519fad9acf7369931fdf67d876260/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=6f0f0b2eca1519fad9acf7369931fdf67d876260", "patch": "@@ -1108,6 +1108,10 @@ gfc_trans_code (gfc_code * code)\n \t  res = gfc_trans_inquire (code);\n \t  break;\n \n+\tcase EXEC_WAIT:\n+\t  res = gfc_trans_wait (code);\n+\t  break;\n+\n \tcase EXEC_REWIND:\n \t  res = gfc_trans_rewind (code);\n \t  break;"}]}