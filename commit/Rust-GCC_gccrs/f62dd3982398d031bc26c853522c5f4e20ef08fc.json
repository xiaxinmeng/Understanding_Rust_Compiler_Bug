{"sha": "f62dd3982398d031bc26c853522c5f4e20ef08fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYyZGQzOTgyMzk4ZDAzMWJjMjZjODUzNTIyYzVmNGUyMGVmMDhmYw==", "commit": {"author": {"name": "Jozef Lawrynowicz", "email": "jozef.l@mittosystems.com", "date": "2020-11-13T15:35:42Z"}, "committer": {"name": "Jozef Lawrynowicz", "email": "jozef.l@mittosystems.com", "date": "2020-11-13T15:36:30Z"}, "message": "MSP430: Implement TARGET_RTX_COSTS\n\nCosts of MSP430 instructions are mostly just a function of the type and\nnumber of operands; knowledge of the specific instruction often\nisn't required to calculate the cost.\nIn these cases, TARGET_RTX_COSTS just needs to examine the operands to\ncalculate the cost of the expression.\n\nFor more complicated operations where library helper functions are\nrequired, if the cost cannot be accurately calculated, it is estimated\nand disparaged relative to the cost of a single instruction.\n\ngcc/ChangeLog:\n\n\t* config/msp430/msp430.c (use_helper_for_const_shift): Add forward\n\tdeclaration.\n\tRemove unused argument.\n\t(struct msp430_multlib_costs): New struct.\n\t(msp430_is_mem_indirect): New function.\n\t(msp430_costs): Likewise.\n\t(msp430_shift_costs): Likewise.\n\t(msp430_muldiv_costs): Likewise.\n\t(msp430_get_inner_dest_code): Likewise.\n\t(msp430_single_op_cost): Likewise.\n\t(msp430_rtx_costs): Rewrite from scratch.\n\t(msp430_expand_shift): Adjust use_helper_for_const_shift call.", "tree": {"sha": "66dd239c6da387cdb22bfc13a4c14042d9938722", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66dd239c6da387cdb22bfc13a4c14042d9938722"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f62dd3982398d031bc26c853522c5f4e20ef08fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f62dd3982398d031bc26c853522c5f4e20ef08fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f62dd3982398d031bc26c853522c5f4e20ef08fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f62dd3982398d031bc26c853522c5f4e20ef08fc/comments", "author": {"login": "jozefl-mitto", "id": 36524004, "node_id": "MDQ6VXNlcjM2NTI0MDA0", "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jozefl-mitto", "html_url": "https://github.com/jozefl-mitto", "followers_url": "https://api.github.com/users/jozefl-mitto/followers", "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}", "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}", "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions", "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs", "repos_url": "https://api.github.com/users/jozefl-mitto/repos", "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}", "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jozefl-mitto", "id": 36524004, "node_id": "MDQ6VXNlcjM2NTI0MDA0", "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jozefl-mitto", "html_url": "https://github.com/jozefl-mitto", "followers_url": "https://api.github.com/users/jozefl-mitto/followers", "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}", "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}", "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions", "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs", "repos_url": "https://api.github.com/users/jozefl-mitto/repos", "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}", "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "953587a2b0fb171b94685f2808e906adb66d4f0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/953587a2b0fb171b94685f2808e906adb66d4f0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/953587a2b0fb171b94685f2808e906adb66d4f0b"}], "stats": {"total": 502, "additions": 485, "deletions": 17}, "files": [{"sha": "9f7635118b1d948c22dbf84e589ab9f47d855604", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 485, "deletions": 17, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62dd3982398d031bc26c853522c5f4e20ef08fc/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62dd3982398d031bc26c853522c5f4e20ef08fc/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=f62dd3982398d031bc26c853522c5f4e20ef08fc", "patch": "@@ -49,13 +49,17 @@\n #include \"msp430-devices.h\"\n #include \"incpath.h\"\n #include \"prefix.h\"\n+#include \"insn-config.h\"\n+#include \"insn-attr.h\"\n+#include \"recog.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n \f\n \n static void msp430_compute_frame_info (void);\n static bool use_32bit_hwmult (void);\n+static bool use_helper_for_const_shift (machine_mode mode, HOST_WIDE_INT amt);\n \n \f\n \n@@ -1118,6 +1122,28 @@ static const struct double_op_cost size_cost_double_op =\n   2, 2, 3\n };\n \n+struct msp430_multlib_costs\n+{\n+  const int mulhi;\n+  const int mulsi;\n+  const int muldi;\n+};\n+\n+/* There is no precise size cost when using libcalls, instead it is disparaged\n+   relative to other instructions.\n+   The cycle costs are from the CALL to the RET, inclusive.\n+   FIXME muldi cost is not accurate.  */\n+static const struct msp430_multlib_costs cycle_cost_multlib_32bit =\n+{\n+  27, 33, 66\n+};\n+\n+/* 32bit multiply takes a few more instructions on 16bit hwmult.  */\n+static const struct msp430_multlib_costs cycle_cost_multlib_16bit =\n+{\n+  27, 42, 66\n+};\n+\n /* TARGET_REGISTER_MOVE_COST\n    There is only one class of general-purpose, non-fixed registers, and the\n    relative cost of moving data between them is always the same.\n@@ -1160,29 +1186,469 @@ msp430_memory_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n    because there are no conditional move insns - when a condition is involved,\n    the only option is to use a cbranch.  */\n \n-#undef  TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS msp430_rtx_costs\n+/* For X, which must be a MEM RTX, return TRUE if it is an indirect memory\n+   reference, @Rn or @Rn+.  */\n+static bool\n+msp430_is_mem_indirect (rtx x)\n+{\n+  gcc_assert (GET_CODE (x) == MEM);\n+  rtx op0 = XEXP (x, 0);\n+  return (GET_CODE (op0) == REG || GET_CODE (op0) == POST_INC);\n+}\n+\n+/* Costs of MSP430 instructions are generally based on the addressing mode\n+   combination of the source and destination operands.\n+   Given source operand SRC (which may be NULL to indicate a single-operand\n+   instruction) and destination operand DST return the cost of this\n+   expression.  */\n+static int\n+msp430_costs (rtx src, rtx dst, bool speed, rtx outer_rtx)\n+{\n+  enum rtx_code src_code = GET_CODE (src);\n+  enum rtx_code dst_code = GET_CODE (dst);\n+  enum rtx_code outer_code = GET_CODE (outer_rtx);\n+  machine_mode outer_mode = GET_MODE (outer_rtx);\n+  const struct double_op_cost *cost_p;\n+  cost_p = (speed ? &cycle_cost_double_op : &size_cost_double_op);\n+\n+  if (outer_code == TRUNCATE\n+      && (outer_mode == QImode\n+\t  || outer_mode == HImode\n+\t  || outer_mode == PSImode))\n+    /* Truncation to these modes is normally free as a side effect of the\n+       instructions themselves.  */\n+    return 0;\n+\n+  if (dst_code == SYMBOL_REF\n+      || dst_code == LABEL_REF\n+      || dst_code == CONST_INT)\n+    /* Catch RTX like (minus (const_int 0) (reg)) but don't add any cost.  */\n+    return 0;\n+\n+  switch (src_code)\n+    {\n+    case REG:\n+      return (dst_code == REG ? cost_p->r2r\n+\t      : (dst_code == PC ? cost_p->r2pc : cost_p->r2m));\n+\n+    case CONST_INT:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case CONST:\n+      return (dst_code == REG ? cost_p->imm2r\n+\t      : (dst_code == PC ? cost_p->imm2pc : cost_p->imm2m));\n+\n+\n+    case MEM:\n+      if (msp430_is_mem_indirect (src))\n+\treturn (dst_code == REG ? cost_p->ind2r : (dst_code == PC\n+\t\t\t\t\t\t   ? cost_p->ind2pc\n+\t\t\t\t\t\t   : cost_p->ind2m));\n+      else\n+\treturn (dst_code == REG ? cost_p->mem2r\t: (dst_code == PC\n+\t\t\t\t\t\t   ? cost_p->mem2pc\n+\t\t\t\t\t\t   : cost_p->mem2m));\n+    default:\n+      return cost_p->mem2m;\n+    }\n+}\n+\n+/* Given source operand SRC and destination operand DST from the shift or\n+   rotate RTX OUTER_RTX, return the cost of performing that shift, assuming\n+   optimization for speed when SPEED is true.  */\n+static int\n+msp430_shift_costs (rtx src, rtx dst, bool speed, rtx outer_rtx)\n+{\n+  int amt;\n+  enum rtx_code src_code = GET_CODE (src);\n+  enum rtx_code dst_code = GET_CODE (dst);\n+  const struct single_op_cost *cost_p;\n+\n+  cost_p = (speed ? &cycle_cost_single_op : &size_cost_single_op);\n+\n+  if (src_code != CONST_INT)\n+    /* The size or speed cost when the shift amount is unknown cannot be\n+       accurately calculated, so just disparage it slightly.  */\n+    return 2 * msp430_costs (src, dst, speed, outer_rtx);\n \n-static bool msp430_rtx_costs (rtx\t   x ATTRIBUTE_UNUSED,\n-\t\t\t      machine_mode mode,\n-\t\t\t      int\t   outer_code ATTRIBUTE_UNUSED,\n-\t\t\t      int\t   opno ATTRIBUTE_UNUSED,\n-\t\t\t      int *\t   total,\n-\t\t\t      bool\t   speed ATTRIBUTE_UNUSED)\n+  if (use_helper_for_const_shift (GET_MODE (outer_rtx), amt = INTVAL (src)))\n+    {\n+      /* GCC sometimes tries to perform shifts in some very inventive ways,\n+\t resulting in much larger code size usage than necessary, if\n+\t they are disparaged too much here.  So in general, if\n+\t use_helper_for_const_shift thinks a helper should be used, obey\n+\t that and don't disparage the shift any more than a regular\n+\t instruction, even though the shift may actually cost more.\n+\t This ensures that the RTL generated at the initial expand pass has the\n+\t expected shift instructions, which can be mapped to the helper\n+\t functions.  */\n+      return msp430_costs (src, dst, speed, outer_rtx);\n+    }\n+\n+  if (!msp430x)\n+    {\n+      /* Each shift by one place will be emitted individually.  */\n+      switch (dst_code)\n+\t{\n+\tcase REG:\n+\tcase CONST_INT:\n+\t  return amt * cost_p->reg;\n+\tcase MEM:\n+\t  if (msp430_is_mem_indirect (dst))\n+\t    return amt * cost_p->ind;\n+\t  else\n+\t    return amt * cost_p->mem;\n+\tdefault:\n+\t  return amt * cost_p->mem;\n+\t}\n+    }\n+\n+  /* RRAM, RRCM, RRUM, RLAM are used for shift counts <= 4, otherwise, the 'X'\n+     versions are used.\n+     Instructions which shift a MEM operand will never actually be output.  It\n+     will always be copied into a register to allow for efficient shifting.  So\n+     the cost just takes into account the cost of an additional copy in that\n+     case.  */\n+  return (amt <= 4 ? (speed ? amt : 1) : (speed ? amt + 1 : 2)\n+\t  + (dst_code == REG ? 0\n+\t     : msp430_costs (dst, gen_rtx_REG (HImode, 10), speed, outer_rtx)));\n+}\n+\n+/* Given source operand SRC and destination operand DST from the MULT/DIV/MOD\n+   RTX OUTER_RTX, return the cost of performing that operation, assuming\n+   optimization for speed when SPEED is true.  */\n+static int\n+msp430_muldiv_costs (rtx src, rtx dst, bool speed, rtx outer_rtx,\n+\t\t     machine_mode outer_mode)\n {\n-  int code = GET_CODE (x);\n+  enum rtx_code outer_code = GET_CODE (outer_rtx);\n+  const struct msp430_multlib_costs *cost_p;\n+  bool hwmult_16bit = (msp430_has_hwmult () && !(msp430_use_f5_series_hwmult ()\n+\t\t\t\t\t\t || use_32bit_hwmult ()));\n+  cost_p = (hwmult_16bit\n+\t    ? &cycle_cost_multlib_32bit\n+\t    : &cycle_cost_multlib_16bit);\n+\n+  int factor = 1;\n+  /* Only used in some calculations.  */\n+  int mode_factor = 1;\n+  if (outer_mode == SImode)\n+    mode_factor = 2;\n+  else if (outer_mode == PSImode)\n+    /* PSImode multiplication is performed using SImode operands, so has extra\n+       cost to factor in the conversions necessary before/after the\n+       operation.  */\n+    mode_factor = 3;\n+  else if (outer_mode == DImode)\n+    mode_factor = 4;\n+\n+  if (!speed)\n+    {\n+      /* The codesize cost of using a helper function to perform the\n+\t multiplication or division cannot be accurately calculated, since the\n+\t cost depends on how many times the operation is performed in the\n+\t entire program.  */\n+      if (outer_code != MULT)\n+\t/* Division is always expensive.  */\n+\tfactor = 7;\n+      else if (((hwmult_16bit && outer_mode != DImode)\n+\t\t   || use_32bit_hwmult () || msp430_use_f5_series_hwmult ()))\n+\t/* When the hardware multiplier is available, only disparage\n+\t   slightly.  */\n+\tfactor = 2;\n+      else\n+\tfactor = 5;\n+      return factor * mode_factor * msp430_costs (src, dst, speed, outer_rtx);\n+    }\n+\n+  /* When there is hardware multiply support, there is a relatively low, fixed\n+     cycle cost to performing any multiplication, but when there is no hardware\n+     multiply support it is very costly.  That precise cycle cost has not been\n+     calculated here.\n+     Division is extra slow since it always uses a software library.\n+     The 16-bit hardware multiply library cannot be used to produce 64-bit\n+     results.  */\n+  if (outer_code != MULT || !msp430_has_hwmult ()\n+      || (outer_mode == DImode && hwmult_16bit))\n+    {\n+      factor = (outer_code == MULT ? 50 : 70);\n+      return factor * mode_factor * msp430_costs (src, dst, speed, outer_rtx);\n+    }\n+\n+  switch (outer_mode)\n+    {\n+    case E_QImode:\n+    case E_HImode:\n+      /* Include the cost of copying the operands into and out of the hardware\n+\t multiply routine.  */\n+      return cost_p->mulhi + (3 * msp430_costs (src, dst, speed, outer_rtx));\n+\n+    case E_PSImode:\n+      /* Extra factor for the conversions necessary to do PSI->SI before the\n+\t operation.  */\n+      factor = 2;\n+      /* fallthru.  */\n+    case E_SImode:\n+      return factor * (cost_p->mulsi\n+\t\t       + (6 * msp430_costs (src, dst, speed, outer_rtx)));\n+\n+    case E_DImode:\n+    default:\n+      return cost_p->muldi + (12 * msp430_costs (src, dst, speed, outer_rtx));\n+    }\n+}\n \n+/* Recurse within X to find the actual destination operand of the expression.\n+   For example:\n+   (plus (ashift (minus (ashift (reg)\n+   (const_int) ......\n+   should return the reg RTX.  */\n+static rtx\n+msp430_get_inner_dest_code (rtx x)\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  rtx op0 = XEXP (x, 0);\n   switch (code)\n     {\n-    case SIGN_EXTEND:\n-      if (mode == SImode && outer_code == SET)\n+    case REG:\n+    case SYMBOL_REF:\n+    case CONST_INT:\n+    case CONST:\n+    case LABEL_REF:\n+      return x;\n+\n+    case MEM:\n+      /* Return the MEM expr not the inner REG for these cases.  */\n+      switch (GET_CODE (op0))\n \t{\n-\t  *total = COSTS_N_INSNS (4);\n-\t  return true;\n+\tcase REG:\n+\tcase SYMBOL_REF:\n+\tcase LABEL_REF:\n+\tcase CONST:\n+\tcase POST_INC:\n+\t  return x;\n+\n+\tcase PLUS:\n+\t  /* return MEM (PLUS (REG) (CONST)) */\n+\t  if (GET_CODE (XEXP (op0, 0)) == REG)\n+\t    {\n+\t      if (GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t\t  || GET_CODE (XEXP (op0, 1)) == CONST\n+\t\t  || GET_CODE (XEXP (op0, 1)) == LABEL_REF\n+\t\t  || GET_CODE (XEXP (op0, 1)) == SYMBOL_REF)\n+\t\treturn x;\n+\t      else\n+\t\treturn msp430_get_inner_dest_code (op0);\n+\t    }\n+\t  return msp430_get_inner_dest_code (op0);\n+\n+\tdefault:\n+\t  if (GET_RTX_FORMAT (code)[0] != 'e')\n+\t    return x;\n+\t  return msp430_get_inner_dest_code (op0);\n \t}\n       break;\n+\n+    default:\n+      if (op0 == NULL_RTX)\n+\tgcc_unreachable ();\n+      else\n+\t{\n+\t  if (GET_RTX_FORMAT (code)[0] != 'e'\n+\t      && code != ENTRY_VALUE)\n+\t    return x;\n+\t  return msp430_get_inner_dest_code (op0);\n+\t}\n+    }\n+}\n+\n+/* Calculate the cost of an MSP430 single-operand instruction, for operand DST\n+   within the RTX OUTER_RTX, optimizing for speed if SPEED is true.  */\n+static int\n+msp430_single_op_cost (rtx dst, bool speed, rtx outer_rtx)\n+{\n+  enum rtx_code dst_code = GET_CODE (dst);\n+  const struct single_op_cost *cost_p;\n+  const struct double_op_cost *double_op_cost_p;\n+\n+  cost_p = (speed ? &cycle_cost_single_op : &size_cost_single_op);\n+  double_op_cost_p = (speed ? &cycle_cost_double_op : &size_cost_double_op);\n+\n+  switch (dst_code)\n+    {\n+    case REG:\n+      return cost_p->reg;\n+    case MEM:\n+      if (msp430_is_mem_indirect (dst))\n+\treturn cost_p->ind;\n+      else\n+\treturn cost_p->mem;\n+\n+    case CONST_INT:\n+    case CONST_FIXED:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case CONST:\n+      /* A constant value would need to be copied into a register first.  */\n+      return double_op_cost_p->imm2r + cost_p->reg;\n+\n+    default:\n+      return cost_p->mem;\n+    }\n+}\n+\n+#undef  TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS msp430_rtx_costs\n+\n+/* This target hook describes the relative costs of RTL expressions.\n+   The function recurses to just before the lowest level of the expression,\n+   when both of the operands of the expression can be examined at the same time.\n+   This is because the cost of the expression depends on the specific\n+   addressing mode combination of the operands.\n+   The hook returns true when all subexpressions of X have been processed, and\n+   false when rtx_cost should recurse.  */\n+static bool\n+msp430_rtx_costs (rtx x,\n+\t\t  machine_mode mode,\n+\t\t  int\t   outer_code ATTRIBUTE_UNUSED,\n+\t\t  int\t   opno ATTRIBUTE_UNUSED,\n+\t\t  int *\t   total,\n+\t\t  bool\t   speed)\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  rtx dst, src;\n+  rtx dst_inner, src_inner;\n+\n+  *total = 0;\n+  dst = XEXP (x, 0);\n+  if (GET_RTX_LENGTH (code) == 1)\n+    /* Some RTX that are single-op in GCC are double-op when translated to\n+       MSP430 instructions e.g NOT, NEG, ZERO_EXTEND.  */\n+    src = dst;\n+  else\n+    src = XEXP (x, 1);\n+\n+\n+  switch (code)\n+    {\n+    case SET:\n+      /* Ignoring SET improves codesize.  */\n+      if (!speed)\n+\treturn true;\n+      /* fallthru.  */\n+    case PLUS:\n+      if (outer_code == MEM)\n+\t/* Do not add any cost for the plus itself, but recurse in case there\n+\t   are more complicated RTX inside.  */\n+\treturn false;\n+      /* fallthru.  */\n+    case MINUS:\n+    case AND:\n+    case IOR:\n+    case XOR:\n+    case NOT:\n+    case ZERO_EXTEND:\n+    case TRUNCATE:\n+    case NEG:\n+    case ZERO_EXTRACT:\n+    case SIGN_EXTRACT:\n+    case IF_THEN_ELSE:\n+      dst_inner = msp430_get_inner_dest_code (dst);\n+      src_inner = msp430_get_inner_dest_code (src);\n+      *total = COSTS_N_INSNS (msp430_costs (src_inner, dst_inner, speed, x));\n+      if (mode == SImode)\n+\t*total *= 2;\n+      if (mode == DImode)\n+\t*total *= 4;\n+      return false;\n+\n+    case ROTATE:\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      dst_inner = msp430_get_inner_dest_code (dst);\n+      src_inner = msp430_get_inner_dest_code (src);\n+      *total = COSTS_N_INSNS (msp430_shift_costs (src_inner, dst_inner,\n+\t\t\t\t\t\t  speed, x));\n+      if (mode == SImode)\n+\t*total *= 2;\n+      if (mode == DImode)\n+\t*total *= 4;\n+      return false;\n+\n+    case MULT:\n+    case DIV:\n+    case MOD:\n+    case UDIV:\n+    case UMOD:\n+      dst_inner = msp430_get_inner_dest_code (dst);\n+      src_inner = msp430_get_inner_dest_code (src);\n+      *total = COSTS_N_INSNS (msp430_muldiv_costs (src_inner, dst_inner, speed,\n+\t\t\t\t\t\t   x, mode));\n+      return false;\n+\n+    case CALL:\n+    case SIGN_EXTEND:\n+      dst_inner = msp430_get_inner_dest_code (dst);\n+      *total = COSTS_N_INSNS (msp430_single_op_cost (dst_inner, speed, x));\n+      if (mode == SImode)\n+\t*total *= 2;\n+      if (mode == DImode)\n+\t*total *= 4;\n+      return false;\n+\n+    case CONST_INT:\n+    case CONST_FIXED:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case CONST:\n+    case LABEL_REF:\n+    case REG:\n+    case PC:\n+    case POST_INC:\n+      if (mode == SImode)\n+\t*total = COSTS_N_INSNS (2);\n+      else if (mode == DImode)\n+\t*total = COSTS_N_INSNS (4);\n+      return true;\n+\n+    case MEM:\n+      /* PSImode operands are expensive when in memory.  */\n+      if (mode == PSImode)\n+\t*total = COSTS_N_INSNS (1);\n+      else if (mode == SImode)\n+\t*total = COSTS_N_INSNS (2);\n+      else if (mode == DImode)\n+\t*total = COSTS_N_INSNS (4);\n+      /* Recurse into the MEM.  */\n+      return false;\n+\n+    case EQ:\n+    case NE:\n+    case GT:\n+    case GTU:\n+    case GE:\n+    case GEU:\n+    case LT:\n+    case LTU:\n+    case LE:\n+    case LEU:\n+      /* Conditions are mostly equivalent, changing their relative\n+\t costs has no effect.  */\n+      return false;\n+\n+    case ASM_OPERANDS:\n+    case ASM_INPUT:\n+    case CLOBBER:\n+    case COMPARE:\n+    case CONCAT:\n+    case ENTRY_VALUE:\n+      /* Other unhandled expressions.  */\n+      return false;\n+\n+    default:\n+      return false;\n     }\n-  return false;\n }\n \f\n /* Function Entry and Exit */\n@@ -2947,8 +3413,7 @@ msp430_expand_helper (rtx *operands, const char *helper_name,\n /* Return TRUE if the helper function should be used and FALSE if the shifts\n    insns should be emitted inline.  */\n static bool\n-use_helper_for_const_shift (enum rtx_code code, machine_mode mode,\n-\t\t\t    HOST_WIDE_INT amt)\n+use_helper_for_const_shift (machine_mode mode, HOST_WIDE_INT amt)\n {\n   const int default_inline_shift = 4;\n   /* We initialize the option to 65 so we know if the user set it or not.  */\n@@ -2959,6 +3424,9 @@ use_helper_for_const_shift (enum rtx_code code, machine_mode mode,\n      the heuristic accordingly.  */\n   int max_inline_32 = max_inline / 2;\n \n+  if (mode == E_DImode)\n+    return true;\n+\n   /* Don't use helpers for these modes on 430X, when optimizing for speed, or\n      when emitting a small number of insns.  */\n   if ((mode == E_QImode || mode == E_HImode || mode == E_PSImode)\n@@ -2996,7 +3464,7 @@ msp430_expand_shift (enum rtx_code code, machine_mode mode, rtx *operands)\n      constant.  */\n   if (!CONST_INT_P (operands[2])\n       || mode == E_DImode\n-      || use_helper_for_const_shift (code, mode, INTVAL (operands[2])))\n+      || use_helper_for_const_shift (mode, INTVAL (operands[2])))\n     {\n       const char *helper_name = NULL;\n       /* The const variants of mspabi shifts have significantly larger code"}]}