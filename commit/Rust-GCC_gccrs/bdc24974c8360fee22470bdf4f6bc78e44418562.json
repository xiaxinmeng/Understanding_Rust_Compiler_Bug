{"sha": "bdc24974c8360fee22470bdf4f6bc78e44418562", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRjMjQ5NzRjODM2MGZlZTIyNDcwYmRmNGY2YmM3OGU0NDQxODU2Mg==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-11-12T01:56:17Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-11-12T01:56:17Z"}, "message": "global.c (global_conflicts): Update comments.\n\n        * global.c (global_conflicts): Update comments.\n        (record_conflicts): No need to record conflicts between pseudos here.\n\nFrom-SVN: r30492", "tree": {"sha": "73a33be2feee2041af76fe35e753200b87fe8870", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73a33be2feee2041af76fe35e753200b87fe8870"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdc24974c8360fee22470bdf4f6bc78e44418562", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdc24974c8360fee22470bdf4f6bc78e44418562", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdc24974c8360fee22470bdf4f6bc78e44418562", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdc24974c8360fee22470bdf4f6bc78e44418562/comments", "author": null, "committer": null, "parents": [{"sha": "e55b279b6d572d32b0359dfe203a490a2cb9cf7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e55b279b6d572d32b0359dfe203a490a2cb9cf7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e55b279b6d572d32b0359dfe203a490a2cb9cf7f"}], "stats": {"total": 38, "additions": 32, "deletions": 6}, "files": [{"sha": "9dcb970f537391f1d01a78936965f4f4b424433c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdc24974c8360fee22470bdf4f6bc78e44418562/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdc24974c8360fee22470bdf4f6bc78e44418562/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bdc24974c8360fee22470bdf4f6bc78e44418562", "patch": "@@ -1,3 +1,8 @@\n+Thu Nov 11 18:54:24 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* global.c (global_conflicts): Update comments.\n+\t(record_conflicts): No need to record conflicts between pseudos here.\n+\n Thu Nov 11 12:42:11 MST 1999\tDiego Novillo <dnovillo@cygnus.com>\n \n \t* gcc/cp/init.c (init_init_processing): Header information for"}, {"sha": "7e0074cbd63df7dafab03a0a524d835e16f08b85", "filename": "gcc/global.c", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdc24974c8360fee22470bdf4f6bc78e44418562/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdc24974c8360fee22470bdf4f6bc78e44418562/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=bdc24974c8360fee22470bdf4f6bc78e44418562", "patch": "@@ -673,7 +673,8 @@ global_conflicts ()\n \n       /* Initialize table of registers currently live\n \t to the state at the beginning of this basic block.\n-\t This also marks the conflicts among them.\n+\t This also marks the conflicts among hard registers\n+\t and any allocnos that are live.\n \n \t For pseudo-regs, there is only one bit for each one\n \t no matter how many hard regs it occupies.\n@@ -702,9 +703,30 @@ global_conflicts ()\n \t\t\t\t\t (a, PSEUDO_REGNO_MODE (i));\n \t\t\t\t   });\n \n-\t/* Record that each allocno now live conflicts with each other\n-\t   allocno now live, and with each hard reg now live.  */\n+\t/* Record that each allocno now live conflicts with each hard reg\n+\t   now live.\n \n+\t   It is not necessary to mark any conflicts between pseudos as\n+\t   this point, even for pseudos which are live at the start of\n+\t   the basic block.\n+\n+\t     Given two pseudos X and Y and any point in the CFG P.\n+\n+\t     On any path to point P where X and Y are live one of the\n+\t     following conditions must be true:\n+\n+\t\t1. X is live at some instruction on the path that\n+\t\t   evaluates Y.\n+\n+\t\t2. Y is live at some instruction on the path that\n+\t\t   evaluates X.\n+\n+\t\t3. Either X or Y is not evaluted on the path to P\n+\t\t   (ie it is used uninitialized) and thus the\n+\t\t   conflict can be ignored.\n+\n+\t    In cases #1 and #2 the conflict will be recorded when we\n+\t    scan the instruction that makes either X or Y become live.  */\n \trecord_conflicts (block_start_allocnos, ax);\n \n #ifdef STACK_REGS\n@@ -1350,7 +1372,8 @@ record_one_conflict (regno)\n }\n \n /* Record all allocnos currently live as conflicting\n-   with each other and with all hard regs currently live.\n+   with all hard regs currently live.\n+\n    ALLOCNO_VEC is a vector of LEN allocnos, all allocnos that\n    are currently live.  Their bits are also flagged in allocnos_live.  */\n \n@@ -1368,8 +1391,6 @@ record_conflicts (allocno_vec, len)\n       allocno = allocno_vec[len];\n       ialloc_prod = allocno * allocno_row_words;\n       IOR_HARD_REG_SET (hard_reg_conflicts[allocno], hard_regs_live);\n-      for (j = allocno_row_words - 1; j >= 0; j--)\n-\tconflicts[ialloc_prod + j] |= allocnos_live[j];\n     }\n }\n "}]}