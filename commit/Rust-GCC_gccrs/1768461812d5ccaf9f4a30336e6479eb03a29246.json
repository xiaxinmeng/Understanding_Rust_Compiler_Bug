{"sha": "1768461812d5ccaf9f4a30336e6479eb03a29246", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc2ODQ2MTgxMmQ1Y2NhZjlmNGEzMDMzNmU2NDc5ZWIwM2EyOTI0Ng==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-02-14T12:22:11Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-02-14T12:22:11Z"}, "message": "invoke.texi (-fprefetch-loop-arrays, [...]): Document.\n\n\t* doc/invoke.texi (-fprefetch-loop-arrays, -fprefetch-loop-arrays-rtl):\n\tDocument.\n\t* tree-ssa-loop-niter.c (number_of_iterations_ne,\n\tnumber_of_iterations_lt, number_of_iterations_cond): Remember the shape\n\tof the ending condition.\n\t* tree-ssa-loop-manip.c: Include params.h.\n\t(build_if_stmt, can_unroll_loop_p, determine_exit_conditions,\n\ttree_unroll_loop): New functions.\n\t* tree-pass.h (pass_loop_prefetch): Declare.\n\t* loop.c (rest_of_handle_loop_optimize): Test for\n\t-fprefetch-loop-arrays-rtl.\n\t* tree-scalar-evolution.h (affine_iv): Moved to tree-flow.h.\n\t* timevar.def (TV_TREE_PREFETCH): New timevar.\n\t* tree-ssa-loop.c (tree_ssa_loop_prefetch, gate_tree_ssa_loop_prefetch,\n\tpass_loop_prefetch): New.\n\t* tree-cfgcleanup.c: Include tree-scalar-evolution.h.\n\t(cleanup_tree_cfg_loop): Call scev_reset.\n\t* common.opt (fprefetch-loop-arrays-rtl): Add.\n\t* tree-ssa-loop-prefetch.c: New file.\n\t* tree-outof-ssa.c (struct value_expr_d): Add expr_vars field.\n\t(new_temp_expr_table): Initialize expr_vars.\n\t(free_temp_expr_table): Cleanup expr_vars.\n\t(check_replaceable, find_replaceable_in_bb): Prevent accumulating\n\texpressions from being merged into one.\n\t* tree-flow.h (affine_iv): Moved from tree-scalar-evolution.h.\n\t(struct tree_niter_desc): Add control, bound and cmp fields.\n\t(tree_ssa_prefetch_arrays, can_unroll_loop_p, tree_unroll_loop):\n\tDeclare.\n\t* Makefile.in (tree-ssa-loop-prefetch.o): Add.\n\t(tree-cfgcleanup.o): Add SCEV_H dependency.\n\t(tree-ssa-loop-manip.o): Add PARAMS_H dependency.\n\t* passes.c (init_optimization_passes): Add pass_loop_prefetch.\n\nFrom-SVN: r110964", "tree": {"sha": "b637075905e0031ec892d61490a5aafc1637566c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b637075905e0031ec892d61490a5aafc1637566c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1768461812d5ccaf9f4a30336e6479eb03a29246", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1768461812d5ccaf9f4a30336e6479eb03a29246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1768461812d5ccaf9f4a30336e6479eb03a29246", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1768461812d5ccaf9f4a30336e6479eb03a29246/comments", "author": null, "committer": null, "parents": [{"sha": "0a4288d92e5c080b448db4041091aea932b44980", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a4288d92e5c080b448db4041091aea932b44980", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a4288d92e5c080b448db4041091aea932b44980"}], "stats": {"total": 553, "additions": 512, "deletions": 41}, "files": [{"sha": "9aec203aa99a8dd05bef130be1f3c6bc23f668d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1768461812d5ccaf9f4a30336e6479eb03a29246", "patch": "@@ -1,3 +1,38 @@\n+2006-02-14  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* doc/invoke.texi (-fprefetch-loop-arrays, -fprefetch-loop-arrays-rtl):\n+\tDocument.\n+\t* tree-ssa-loop-niter.c (number_of_iterations_ne,\n+\tnumber_of_iterations_lt, number_of_iterations_cond): Remember the shape\n+\tof the ending condition.\n+\t* tree-ssa-loop-manip.c: Include params.h.\n+\t(build_if_stmt, can_unroll_loop_p, determine_exit_conditions,\n+\ttree_unroll_loop): New functions.\n+\t* tree-pass.h (pass_loop_prefetch): Declare.\n+\t* loop.c (rest_of_handle_loop_optimize): Test for\n+\t-fprefetch-loop-arrays-rtl.\n+\t* tree-scalar-evolution.h (affine_iv): Moved to tree-flow.h.\n+\t* timevar.def (TV_TREE_PREFETCH): New timevar.\n+\t* tree-ssa-loop.c (tree_ssa_loop_prefetch, gate_tree_ssa_loop_prefetch,\n+\tpass_loop_prefetch): New.\n+\t* tree-cfgcleanup.c: Include tree-scalar-evolution.h.\n+\t(cleanup_tree_cfg_loop): Call scev_reset.\n+\t* common.opt (fprefetch-loop-arrays-rtl): Add.\n+\t* tree-ssa-loop-prefetch.c: New file.\n+\t* tree-outof-ssa.c (struct value_expr_d): Add expr_vars field.\n+\t(new_temp_expr_table): Initialize expr_vars.\n+\t(free_temp_expr_table): Cleanup expr_vars.\n+\t(check_replaceable, find_replaceable_in_bb): Prevent accumulating\n+\texpressions from being merged into one.\n+\t* tree-flow.h (affine_iv): Moved from tree-scalar-evolution.h.\n+\t(struct tree_niter_desc): Add control, bound and cmp fields.\n+\t(tree_ssa_prefetch_arrays, can_unroll_loop_p, tree_unroll_loop):\n+\tDeclare.\n+\t* Makefile.in (tree-ssa-loop-prefetch.o): Add.\n+\t(tree-cfgcleanup.o): Add SCEV_H dependency.\n+\t(tree-ssa-loop-manip.o): Add PARAMS_H dependency.\n+\t* passes.c (init_optimization_passes): Add pass_loop_prefetch.\n+\n 2006-02-14  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/26258"}, {"sha": "d6d79005cdd50b6f2d622871e6c3f7f8c0212b40", "filename": "gcc/Makefile.in", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1768461812d5ccaf9f4a30336e6479eb03a29246", "patch": "@@ -963,7 +963,7 @@ OBJS-common = \\\n  tree-vect-generic.o tree-ssa-loop.o tree-ssa-loop-niter.o\t\t   \\\n  tree-ssa-loop-manip.o tree-ssa-threadupdate.o tree-ssa-threadedge.o\t   \\\n  tree-vectorizer.o tree-vect-analyze.o tree-vect-transform.o\t\t   \\\n- tree-vect-patterns.o                                                      \\\n+ tree-vect-patterns.o tree-ssa-loop-prefetch.o\t\t\t\t   \\\n  tree-ssa-loop-ivcanon.o tree-ssa-propagate.o tree-ssa-address.o\t   \\\n  tree-ssa-math-opts.o\t\t\t\t\t\t\t   \\\n  tree-ssa-loop-ivopts.o tree-if-conv.o tree-ssa-loop-unswitch.o\t\t   \\\n@@ -1975,6 +1975,12 @@ tree-ssa-loop-ch.o : tree-ssa-loop-ch.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(TREE_INLINE_H) \\\n    output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    tree-pass.h $(FLAGS_H) $(BASIC_BLOCK_H) hard-reg-set.h\n+tree-ssa-loop-prefetch.o: tree-ssa-loop-prefetch.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(EXPR_H) \\\n+   output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   tree-pass.h $(GGC_H) $(RECOG_H) insn-config.h $(HASHTAB_H) $(SCEV_H) \\\n+   $(CFGLOOP_H) $(PARAMS_H) langhooks.h $(BASIC_BLOCK_H) hard-reg-set.h \\\n+   tree-chrec.h toplev.h langhooks.h\n tree-ssa-loop-ivopts.o : tree-ssa-loop-ivopts.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(EXPR_H) \\\n    output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n@@ -1984,7 +1990,8 @@ tree-ssa-loop-ivopts.o : tree-ssa-loop-ivopts.c $(TREE_FLOW_H) $(CONFIG_H) \\\n tree-ssa-loop-manip.o : tree-ssa-loop-manip.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) \\\n    output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n-   tree-pass.h $(CFGLAYOUT_H) $(SCEV_H) $(BASIC_BLOCK_H) hard-reg-set.h\n+   tree-pass.h $(CFGLAYOUT_H) $(SCEV_H) $(BASIC_BLOCK_H) hard-reg-set.h \\\n+   $(PARAMS_H)\n tree-ssa-loop-im.o : tree-ssa-loop-im.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) domwalk.h \\\n    $(PARAMS_H) output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\"}, {"sha": "c7fee2c9c090d3f5deb59cbc79b6408059283dca", "filename": "gcc/common.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=1768461812d5ccaf9f4a30336e6479eb03a29246", "patch": "@@ -659,7 +659,11 @@ Common Report Var(flag_pie,1) VarExists\n Generate position-independent code for executables if possible (small mode)\n \n fprefetch-loop-arrays\n-Common Report Var(flag_prefetch_loop_arrays)\n+Common Report Var(flag_prefetch_loop_arrays,1)\n+Generate prefetch instructions, if available, for arrays in loops\n+\n+fprefetch-loop-arrays-rtl\n+Common Report Var(flag_prefetch_loop_arrays,2)\n Generate prefetch instructions, if available, for arrays in loops\n \n fprofile"}, {"sha": "5c7ff5ebeae90832de082467c8e136a2fc751764", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1768461812d5ccaf9f4a30336e6479eb03a29246", "patch": "@@ -321,7 +321,7 @@ Objective-C and Objective-C++ Dialects}.\n -funsafe-math-optimizations  -funsafe-loop-optimizations  -ffinite-math-only @gol\n -fno-toplevel-reorder -fno-trapping-math  -fno-zero-initialized-in-bss @gol\n -fomit-frame-pointer  -foptimize-register-move @gol\n--foptimize-sibling-calls  -fprefetch-loop-arrays @gol\n+-foptimize-sibling-calls  -fprefetch-loop-arrays -fprefetch-loop-arrays-rtl @gol\n -fprofile-generate -fprofile-use @gol\n -fregmove  -frename-registers @gol\n -freorder-blocks  -freorder-blocks-and-partition -freorder-functions @gol\n@@ -5171,7 +5171,9 @@ With this option, the compiler will create multiple copies of some\n local variables when unrolling a loop which can result in superior code.\n \n @item -fprefetch-loop-arrays\n+@itemx -fprefetch-loop-arrays-rtl\n @opindex fprefetch-loop-arrays\n+@opindex fprefetch-loop-arrays-rtl\n If supported by the target machine, generate instructions to prefetch\n memory to improve the performance of loops that access large arrays.\n \n@@ -5709,7 +5711,9 @@ Move branches with loop invariant conditions out of the loop, with duplicates\n of the loop on both branches (modified according to result of the condition).\n \n @item -fprefetch-loop-arrays\n+@itemx -fprefetch-loop-arrays-rtl\n @opindex fprefetch-loop-arrays\n+@opindex fprefetch-loop-arrays-rtl\n If supported by the target machine, generate instructions to prefetch\n memory to improve the performance of loops that access large arrays.\n "}, {"sha": "1beb4dc16a6ae8ff37791a540426bcb03a1548b4", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=1768461812d5ccaf9f4a30336e6479eb03a29246", "patch": "@@ -11780,7 +11780,7 @@ rest_of_handle_loop_optimize (void)\n   free_bb_for_insn ();\n   profile_status = PROFILE_ABSENT;\n   \n-  do_prefetch = flag_prefetch_loop_arrays ? LOOP_PREFETCH : 0;\n+  do_prefetch = flag_prefetch_loop_arrays == 2 ? LOOP_PREFETCH : 0;\n   \n   if (flag_rerun_loop_opt)\n     {"}, {"sha": "2e7f0b53b32edea3f6994ce70d624debfa439f0c", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=1768461812d5ccaf9f4a30336e6479eb03a29246", "patch": "@@ -601,6 +601,7 @@ init_optimization_passes (void)\n      vectorizer creates alias relations that are not supported by\n      pass_may_alias.  */\n   NEXT_PASS (pass_complete_unroll);\n+  NEXT_PASS (pass_loop_prefetch);\n   NEXT_PASS (pass_iv_optimize);\n   NEXT_PASS (pass_tree_loop_done);\n   *p = NULL;"}, {"sha": "d6065e7ca01b8e3f3f3af13b4bdf586b84ea18a5", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=1768461812d5ccaf9f4a30336e6479eb03a29246", "patch": "@@ -107,6 +107,7 @@ DEFTIMEVAR (TV_TREE_LOOP_UNSWITCH    , \"tree loop unswitching\")\n DEFTIMEVAR (TV_COMPLETE_UNROLL       , \"complete unrolling\")\n DEFTIMEVAR (TV_TREE_VECTORIZATION    , \"tree vectorization\")\n DEFTIMEVAR (TV_TREE_LINEAR_TRANSFORM , \"tree loop linear\")\n+DEFTIMEVAR (TV_TREE_PREFETCH\t     , \"tree prefetching\")\n DEFTIMEVAR (TV_TREE_LOOP_IVOPTS\t     , \"tree iv optimization\")\n DEFTIMEVAR (TV_TREE_LOOP_INIT\t     , \"tree loop init\")\n DEFTIMEVAR (TV_TREE_LOOP_FINI\t     , \"tree loop fini\")"}, {"sha": "76667a6edc17d6301898de34c772a0602093eb26", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=1768461812d5ccaf9f4a30336e6479eb03a29246", "patch": "@@ -45,6 +45,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"cfglayout.h\"\n #include \"hashtab.h\"\n #include \"tree-ssa-propagate.h\"\n+#include \"tree-scalar-evolution.h\"\n \n /* Remove any fallthru edge from EV.  Return true if an edge was removed.  */\n \n@@ -559,23 +560,26 @@ cleanup_tree_cfg (void)\n void\n cleanup_tree_cfg_loop (void)\n {\n-  bitmap changed_bbs = BITMAP_ALLOC (NULL);\n+  bool changed = cleanup_tree_cfg ();\n \n-  cleanup_tree_cfg ();\n-\n-  fix_loop_structure (current_loops, changed_bbs);\n-  calculate_dominance_info (CDI_DOMINATORS);\n+  if (changed)\n+    {\n+      bitmap changed_bbs = BITMAP_ALLOC (NULL);\n+      fix_loop_structure (current_loops, changed_bbs);\n+      calculate_dominance_info (CDI_DOMINATORS);\n \n-  /* This usually does nothing.  But sometimes parts of cfg that originally\n-     were inside a loop get out of it due to edge removal (since they\n-     become unreachable by back edges from latch).  */\n-  rewrite_into_loop_closed_ssa (changed_bbs, TODO_update_ssa);\n+      /* This usually does nothing.  But sometimes parts of cfg that originally\n+\t were inside a loop get out of it due to edge removal (since they\n+\t become unreachable by back edges from latch).  */\n+      rewrite_into_loop_closed_ssa (changed_bbs, TODO_update_ssa);\n \n-  BITMAP_FREE (changed_bbs);\n+      BITMAP_FREE (changed_bbs);\n \n #ifdef ENABLE_CHECKING\n-  verify_loop_structure (current_loops);\n+      verify_loop_structure (current_loops);\n #endif\n+      scev_reset ();\n+    }\n }\n \n /* Merge the PHI nodes at BB into those at BB's sole successor.  */"}, {"sha": "7774c3b42b7dc88664be7b284280fdc9b8449e84", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=1768461812d5ccaf9f4a30336e6479eb03a29246", "patch": "@@ -667,6 +667,17 @@ extern void replace_exp (use_operand_p, tree);\n extern bool may_propagate_copy (tree, tree);\n extern bool may_propagate_copy_into_asm (tree);\n \n+/* Affine iv.  */\n+\n+typedef struct\n+{\n+  /* Iv = BASE + STEP * i.  */\n+  tree base, step;\n+\n+  /* True if this iv does not overflow.  */\n+  bool no_overflow;\n+} affine_iv;\n+\n /* Description of number of iterations of a loop.  All the expressions inside\n    the structure can be evaluated at the end of the loop's preheader\n    (and due to ssa form, also anywhere inside the body of the loop).  */\n@@ -697,6 +708,15 @@ struct tree_niter_desc\n \t\t\t   MAX_SIGNED_INT.  However if the (n <= 0) assumption\n \t\t\t   is eliminated (by looking at the guard on entry of\n \t\t\t   the loop), then the information would be lost.  */\n+\n+  /* The simplified shape of the exit condition.  The loop exits if\n+     CONTROL CMP BOUND is false, where CMP is one of NE_EXPR,\n+     LT_EXPR, or GT_EXPR, and step of CONTROL is positive if CMP is\n+     LE_EXPR and negative if CMP is GE_EXPR.  This information is used\n+     by loop unrolling.  */\n+  affine_iv control;\n+  tree bound;\n+  enum tree_code cmp;\n };\n \n /* In tree-vectorizer.c */\n@@ -711,6 +731,7 @@ void tree_ssa_lim (struct loops *);\n void tree_ssa_unswitch_loops (struct loops *);\n void canonicalize_induction_variables (struct loops *);\n void tree_unroll_loops_completely (struct loops *, bool);\n+void tree_ssa_prefetch_arrays (struct loops *);\n void remove_empty_loops (struct loops *);\n void tree_ssa_iv_optimize (struct loops *);\n \n@@ -748,6 +769,10 @@ struct loop *tree_ssa_loop_version (struct loops *, struct loop *, tree,\n tree expand_simple_operations (tree);\n void substitute_in_loop_info (struct loop *, tree, tree);\n edge single_dom_exit (struct loop *);\n+bool can_unroll_loop_p (struct loop *loop, unsigned factor,\n+\t\t\tstruct tree_niter_desc *niter);\n+void tree_unroll_loop (struct loops *, struct loop *, unsigned,\n+\t\t       edge, struct tree_niter_desc *);\n \n /* In tree-ssa-threadedge.c */\n extern bool potentially_threadable_block (basic_block);"}, {"sha": "40d6c9305112c939689ebc0277cf449e374b4084", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=1768461812d5ccaf9f4a30336e6479eb03a29246", "patch": "@@ -1299,7 +1299,8 @@ typedef struct value_expr_d\n typedef struct temp_expr_table_d \n {\n   var_map map;\n-  void **version_info;\t\t\n+  void **version_info;\n+  bitmap *expr_vars;\n   value_expr_p *partition_dep_list;\n   bitmap replaceable;\n   bool saw_replaceable;\n@@ -1344,6 +1345,7 @@ new_temp_expr_table (var_map map)\n   t->map = map;\n \n   t->version_info = XCNEWVEC (void *, num_ssa_names + 1);\n+  t->expr_vars = XCNEWVEC (bitmap, num_ssa_names + 1);\n   t->partition_dep_list = XCNEWVEC (value_expr_p,\n                                     num_var_partitions (map) + 1);\n \n@@ -1367,6 +1369,7 @@ free_temp_expr_table (temp_expr_table_p t)\n {\n   value_expr_p p;\n   tree *ret = NULL;\n+  unsigned i;\n \n #ifdef ENABLE_CHECKING\n   unsigned x;\n@@ -1383,6 +1386,11 @@ free_temp_expr_table (temp_expr_table_p t)\n   BITMAP_FREE (t->partition_in_use);\n   BITMAP_FREE (t->replaceable);\n \n+  for (i = 0; i <= num_ssa_names; i++)\n+    if (t->expr_vars[i])\n+      BITMAP_FREE (t->expr_vars[i]);\n+  free (t->expr_vars);\n+\n   free (t->partition_dep_list);\n   if (t->saw_replaceable)\n     ret = (tree *)t->version_info;\n@@ -1545,11 +1553,12 @@ add_dependance (temp_expr_table_p tab, int version, tree var)\n static bool\n check_replaceable (temp_expr_table_p tab, tree stmt)\n {\n-  tree var, def;\n+  tree var, def, basevar;\n   int version;\n   var_map map = tab->map;\n   ssa_op_iter iter;\n   tree call_expr;\n+  bitmap def_vars = BITMAP_ALLOC (NULL), use_vars;\n \n   if (TREE_CODE (stmt) != MODIFY_EXPR)\n     return false;\n@@ -1580,12 +1589,19 @@ check_replaceable (temp_expr_table_p tab, tree stmt)\n     }\n \n   version = SSA_NAME_VERSION (def);\n+  basevar = SSA_NAME_VAR (def);\n+  bitmap_set_bit (def_vars, DECL_UID (basevar));\n \n   /* Add this expression to the dependency list for each use partition.  */\n   FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_USE)\n     {\n       add_dependance (tab, version, var);\n+\n+      use_vars = tab->expr_vars[SSA_NAME_VERSION (var)];\n+      if (use_vars)\n+\tbitmap_ior_into (def_vars, use_vars);\n     }\n+  tab->expr_vars[version] = def_vars;\n \n   /* If there are VUSES, add a dependence on virtual defs.  */\n   if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VUSE))\n@@ -1704,7 +1720,7 @@ static void\n find_replaceable_in_bb (temp_expr_table_p tab, basic_block bb)\n {\n   block_stmt_iterator bsi;\n-  tree stmt, def;\n+  tree stmt, def, use;\n   stmt_ann_t ann;\n   int partition;\n   var_map map = tab->map;\n@@ -1717,30 +1733,34 @@ find_replaceable_in_bb (temp_expr_table_p tab, basic_block bb)\n       ann = stmt_ann (stmt);\n \n       /* Determine if this stmt finishes an existing expression.  */\n-      FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_USE)\n+      FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n \t{\n-\t  if (tab->version_info[SSA_NAME_VERSION (def)])\n+\t  unsigned ver = SSA_NAME_VERSION (use);\n+\n+\t  if (tab->version_info[ver])\n \t    {\n \t      bool same_root_var = false;\n-\t      tree def2;\n \t      ssa_op_iter iter2;\n+\t      bitmap vars = tab->expr_vars[ver];\n \n \t      /* See if the root variables are the same.  If they are, we\n \t\t do not want to do the replacement to avoid problems with\n \t\t code size, see PR tree-optimization/17549.  */\n-\t      FOR_EACH_SSA_TREE_OPERAND (def2, stmt, iter2, SSA_OP_DEF)\n-\t\tif (SSA_NAME_VAR (def) == SSA_NAME_VAR (def2))\n-\t\t  {\n-\t\t    same_root_var = true;\n-\t\t    break;\n-\t\t  }\n+\t      FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter2, SSA_OP_DEF)\n+\t\t{\n+\t\t  if (bitmap_bit_p (vars, DECL_UID (SSA_NAME_VAR (def))))\n+\t\t    {\n+\t\t      same_root_var = true;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n \n \t      /* Mark expression as replaceable unless stmt is volatile\n \t\t or DEF sets the same root variable as STMT.  */\n \t      if (!ann->has_volatile_ops && !same_root_var)\n-\t\tmark_replaceable (tab, def);\n+\t\tmark_replaceable (tab, use);\n \t      else\n-\t\tfinish_expr (tab, SSA_NAME_VERSION (def), false);\n+\t\tfinish_expr (tab, ver, false);\n \t    }\n \t}\n       "}, {"sha": "baa60da96e38dfab358ff838d8e57f06612d99de", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=1768461812d5ccaf9f4a30336e6479eb03a29246", "patch": "@@ -247,6 +247,7 @@ extern struct tree_opt_pass pass_record_bounds;\n extern struct tree_opt_pass pass_if_conversion;\n extern struct tree_opt_pass pass_vectorize;\n extern struct tree_opt_pass pass_complete_unroll;\n+extern struct tree_opt_pass pass_loop_prefetch;\n extern struct tree_opt_pass pass_iv_optimize;\n extern struct tree_opt_pass pass_tree_loop_done;\n extern struct tree_opt_pass pass_ch;"}, {"sha": "f7749545f9aa589cf2e5bb6f800ad7bb05ebb8a6", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=1768461812d5ccaf9f4a30336e6479eb03a29246", "patch": "@@ -34,17 +34,6 @@ extern void gather_stats_on_scev_database (void);\n extern void scev_analysis (void);\n void scev_const_prop (void);\n \n-/* Affine iv.  */\n-\n-typedef struct\n-{\n-  /* Iv = BASE + STEP * i.  */\n-  tree base, step;\n-\n-  /* True if this iv does not overflow.  */\n-  bool no_overflow;\n-} affine_iv;\n-\n extern bool simple_iv (struct loop *, tree, tree, affine_iv *, bool);\n \n #endif  /* GCC_TREE_SCALAR_EVOLUTION_H  */"}, {"sha": "21d1ea14b143e14d46d2712eb28bddc85529a53d", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=1768461812d5ccaf9f4a30336e6479eb03a29246", "patch": "@@ -36,6 +36,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree-pass.h\"\n #include \"cfglayout.h\"\n #include \"tree-scalar-evolution.h\"\n+#include \"params.h\"\n \n /* Creates an induction variable with value BASE + STEP * iteration in LOOP.\n    It is expected that neither BASE nor STEP are shared with other expressions\n@@ -618,3 +619,328 @@ tree_duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \n   return true;\n }\n+\n+/* Build if (COND) goto THEN_LABEL; else goto ELSE_LABEL;  */\n+\n+static tree\n+build_if_stmt (tree cond, tree then_label, tree else_label)\n+{\n+  return build3 (COND_EXPR, void_type_node,\n+\t\t cond,\n+\t\t build1 (GOTO_EXPR, void_type_node, then_label),\n+\t\t build1 (GOTO_EXPR, void_type_node, else_label));\n+}\n+\n+/* Returns true if we can unroll LOOP FACTOR times.  Number\n+   of iterations of the loop is returned in NITER.  */\n+\n+bool\n+can_unroll_loop_p (struct loop *loop, unsigned factor,\n+\t\t   struct tree_niter_desc *niter)\n+{\n+  edge exit;\n+\n+  /* Check whether unrolling is possible.  We only want to unroll loops\n+     for that we are able to determine number of iterations.  We also\n+     want to split the extra iterations of the loop from its end,\n+     therefore we require that the loop has precisely one\n+     exit.  */\n+\n+  exit = single_dom_exit (loop);\n+  if (!exit)\n+    return false;\n+\n+  if (!number_of_iterations_exit (loop, exit, niter, false)\n+      || niter->cmp == ERROR_MARK)\n+    return false;\n+\n+  /* And of course, we must be able to duplicate the loop.  */\n+  if (!can_duplicate_loop_p (loop))\n+    return false;\n+\n+  /* The final loop should be small enough.  */\n+  if (tree_num_loop_insns (loop) * factor\n+      > (unsigned) PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Determines the conditions that control execution of LOOP unrolled FACTOR\n+   times.  DESC is number of iterations of LOOP.  ENTER_COND is set to\n+   condition that must be true if the main loop can be entered.\n+   EXIT_BASE, EXIT_STEP, EXIT_CMP and EXIT_BOUND are set to values describing\n+   how the exit from the unrolled loop should be controlled.  */\n+\n+static void\n+determine_exit_conditions (struct loop *loop, struct tree_niter_desc *desc,\n+\t\t\t   unsigned factor, tree *enter_cond,\n+\t\t\t   tree *exit_base, tree *exit_step,\n+\t\t\t   enum tree_code *exit_cmp, tree *exit_bound)\n+{\n+  tree stmts;\n+  tree base = desc->control.base;\n+  tree step = desc->control.step;\n+  tree bound = desc->bound;\n+  tree type = TREE_TYPE (base);\n+  tree bigstep, delta;\n+  tree min = lower_bound_in_type (type, type);\n+  tree max = upper_bound_in_type (type, type);\n+  enum tree_code cmp = desc->cmp;\n+  tree cond = boolean_true_node, assum;\n+\n+  *enter_cond = boolean_false_node;\n+  *exit_base = NULL_TREE;\n+  *exit_step = NULL_TREE;\n+  *exit_cmp = ERROR_MARK;\n+  *exit_bound = NULL_TREE;\n+  gcc_assert (cmp != ERROR_MARK);\n+\n+  /* We only need to be correct when we answer question\n+     \"Do at least FACTOR more iterations remain?\" in the unrolled loop.\n+     Thus, transforming BASE + STEP * i <> BOUND to\n+     BASE + STEP * i < BOUND is ok.  */\n+  if (cmp == NE_EXPR)\n+    {\n+      if (tree_int_cst_sign_bit (step))\n+\tcmp = GT_EXPR;\n+      else\n+\tcmp = LT_EXPR;\n+    }\n+  else if (cmp == LT_EXPR)\n+    {\n+      gcc_assert (!tree_int_cst_sign_bit (step));\n+    }\n+  else if (cmp == GT_EXPR)\n+    {\n+      gcc_assert (tree_int_cst_sign_bit (step));\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  /* The main body of the loop may be entered iff:\n+\n+     1) desc->may_be_zero is false.\n+     2) it is possible to check that there are at least FACTOR iterations\n+\tof the loop, i.e., BOUND - step * FACTOR does not overflow.\n+     3) # of iterations is at least FACTOR  */\n+\n+  if (!zero_p (desc->may_be_zero))\n+    cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\tinvert_truthvalue (desc->may_be_zero),\n+\t\t\tcond);\n+\n+  bigstep = fold_build2 (MULT_EXPR, type, step,\n+\t\t\t build_int_cst_type (type, factor));\n+  delta = fold_build2 (MINUS_EXPR, type, bigstep, step);\n+  if (cmp == LT_EXPR)\n+    assum = fold_build2 (GE_EXPR, boolean_type_node,\n+\t\t\t bound,\n+\t\t\t fold_build2 (PLUS_EXPR, type, min, delta));\n+  else\n+    assum = fold_build2 (LE_EXPR, boolean_type_node,\n+\t\t\t bound,\n+\t\t\t fold_build2 (PLUS_EXPR, type, max, delta));\n+  cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, assum, cond);\n+\n+  bound = fold_build2 (MINUS_EXPR, type, bound, delta);\n+  assum = fold_build2 (cmp, boolean_type_node, base, bound);\n+  cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, assum, cond);\n+\n+  cond = force_gimple_operand (unshare_expr (cond), &stmts, false, NULL_TREE);\n+  if (stmts)\n+    bsi_insert_on_edge_immediate_loop (loop_preheader_edge (loop), stmts);\n+  /* cond now may be a gimple comparison, which would be OK, but also any\n+     other gimple rhs (say a && b).  In this case we need to force it to\n+     operand.  */\n+  if (!is_gimple_condexpr (cond))\n+    {\n+      cond = force_gimple_operand (cond, &stmts, true, NULL_TREE);\n+      if (stmts)\n+\tbsi_insert_on_edge_immediate_loop (loop_preheader_edge (loop), stmts);\n+    }\n+  *enter_cond = cond;\n+\n+  base = force_gimple_operand (unshare_expr (base), &stmts, true, NULL_TREE);\n+  if (stmts)\n+    bsi_insert_on_edge_immediate_loop (loop_preheader_edge (loop), stmts);\n+  bound = force_gimple_operand (unshare_expr (bound), &stmts, true, NULL_TREE);\n+  if (stmts)\n+    bsi_insert_on_edge_immediate_loop (loop_preheader_edge (loop), stmts);\n+\n+  *exit_base = base;\n+  *exit_step = bigstep;\n+  *exit_cmp = cmp;\n+  *exit_bound = bound;\n+}\n+\n+/* Unroll LOOP FACTOR times.  LOOPS is the loops tree.  DESC describes\n+   number of iterations of LOOP.  EXIT is the exit of the loop to that\n+   DESC corresponds.\n+   \n+   If N is number of iterations of the loop and MAY_BE_ZERO is the condition\n+   under that loop exits in the first iteration even if N != 0,\n+   \n+   while (1)\n+     {\n+       x = phi (init, next);\n+\n+       pre;\n+       if (st)\n+         break;\n+       post;\n+     }\n+\n+   becomes (with possibly the exit conditions formulated a bit differently,\n+   avoiding the need to create a new iv):\n+   \n+   if (MAY_BE_ZERO || N < FACTOR)\n+     goto rest;\n+\n+   do\n+     {\n+       x = phi (init, next);\n+\n+       pre;\n+       post;\n+       pre;\n+       post;\n+       ...\n+       pre;\n+       post;\n+       N -= FACTOR;\n+       \n+     } while (N >= FACTOR);\n+\n+   rest:\n+     init' = phi (init, x);\n+\n+   while (1)\n+     {\n+       x = phi (init', next);\n+\n+       pre;\n+       if (st)\n+         break;\n+       post;\n+     } */\n+\n+void\n+tree_unroll_loop (struct loops *loops, struct loop *loop, unsigned factor,\n+\t\t  edge exit, struct tree_niter_desc *desc)\n+{\n+  tree dont_exit, exit_if, ctr_before, ctr_after;\n+  tree enter_main_cond, exit_base, exit_step, exit_bound;\n+  enum tree_code exit_cmp;\n+  tree phi_old_loop, phi_new_loop, phi_rest, init, next, new_init, var;\n+  struct loop *new_loop;\n+  basic_block rest, exit_bb;\n+  edge old_entry, new_entry, old_latch, precond_edge, new_exit;\n+  edge nonexit, new_nonexit;\n+  block_stmt_iterator bsi;\n+  use_operand_p op;\n+  bool ok;\n+  unsigned est_niter;\n+  sbitmap wont_exit;\n+\n+  est_niter = expected_loop_iterations (loop);\n+  determine_exit_conditions (loop, desc, factor,\n+\t\t\t     &enter_main_cond, &exit_base, &exit_step,\n+\t\t\t     &exit_cmp, &exit_bound);\n+\n+  new_loop = loop_version (loops, loop, enter_main_cond, NULL, true);\n+  gcc_assert (new_loop != NULL);\n+  update_ssa (TODO_update_ssa);\n+\n+  /* Unroll the loop and remove the old exits.  */\n+  dont_exit = ((exit->flags & EDGE_TRUE_VALUE)\n+\t       ? boolean_false_node\n+\t       : boolean_true_node);\n+  if (exit == EDGE_SUCC (exit->src, 0))\n+    nonexit = EDGE_SUCC (exit->src, 1);\n+  else\n+    nonexit = EDGE_SUCC (exit->src, 0);\n+  nonexit->probability = REG_BR_PROB_BASE;\n+  exit->probability = 0;\n+  nonexit->count += exit->count;\n+  exit->count = 0;\n+  exit_if = last_stmt (exit->src);\n+  COND_EXPR_COND (exit_if) = dont_exit;\n+  update_stmt (exit_if);\n+      \n+  wont_exit = sbitmap_alloc (factor);\n+  sbitmap_ones (wont_exit);\n+  ok = tree_duplicate_loop_to_header_edge\n+\t  (loop, loop_latch_edge (loop), loops, factor - 1,\n+\t   wont_exit, NULL, NULL, NULL, DLTHE_FLAG_UPDATE_FREQ);\n+  free (wont_exit);\n+  gcc_assert (ok);\n+  update_ssa (TODO_update_ssa);\n+\n+  /* Prepare the cfg and update the phi nodes.  */\n+  rest = loop_preheader_edge (new_loop)->src;\n+  precond_edge = single_pred_edge (rest);\n+  loop_split_edge_with (loop_latch_edge (loop), NULL);\n+  exit_bb = single_pred (loop->latch);\n+\n+  new_exit = make_edge (exit_bb, rest, EDGE_FALSE_VALUE);\n+  new_exit->count = loop_preheader_edge (loop)->count;\n+  est_niter = est_niter / factor + 1;\n+  new_exit->probability = REG_BR_PROB_BASE / est_niter;\n+\n+  new_nonexit = single_pred_edge (loop->latch);\n+  new_nonexit->flags = EDGE_TRUE_VALUE;\n+  new_nonexit->probability = REG_BR_PROB_BASE - new_exit->probability;\n+\n+  old_entry = loop_preheader_edge (loop);\n+  new_entry = loop_preheader_edge (new_loop);\n+  old_latch = loop_latch_edge (loop);\n+  for (phi_old_loop = phi_nodes (loop->header),\n+       phi_new_loop = phi_nodes (new_loop->header);\n+       phi_old_loop;\n+       phi_old_loop = PHI_CHAIN (phi_old_loop),\n+       phi_new_loop = PHI_CHAIN (phi_new_loop))\n+    {\n+      init = PHI_ARG_DEF_FROM_EDGE (phi_old_loop, old_entry);\n+      op = PHI_ARG_DEF_PTR_FROM_EDGE (phi_new_loop, new_entry);\n+      gcc_assert (operand_equal_for_phi_arg_p (init, USE_FROM_PTR (op)));\n+      next = PHI_ARG_DEF_FROM_EDGE (phi_old_loop, old_latch);\n+\n+      /* Prefer using original variable as a base for the new ssa name.\n+\t This is necessary for virtual ops, and useful in order to avoid\n+\t losing debug info for real ops.  */\n+      if (TREE_CODE (next) == SSA_NAME)\n+\tvar = SSA_NAME_VAR (next);\n+      else if (TREE_CODE (init) == SSA_NAME)\n+\tvar = SSA_NAME_VAR (init);\n+      else\n+\t{\n+\t  var = create_tmp_var (TREE_TYPE (init), \"unrinittmp\");\n+\t  add_referenced_tmp_var (var);\n+\t}\n+\n+      new_init = make_ssa_name (var, NULL_TREE);\n+      phi_rest = create_phi_node (new_init, rest);\n+      SSA_NAME_DEF_STMT (new_init) = phi_rest;\n+\n+      add_phi_arg (phi_rest, init, precond_edge);\n+      add_phi_arg (phi_rest, next, new_exit);\n+      SET_USE (op, new_init);\n+    }\n+\n+  /* Finally create the new counter for number of iterations and add the new\n+     exit instruction.  */\n+  bsi = bsi_last (exit_bb);\n+  create_iv (exit_base, exit_step, NULL_TREE, loop,\n+\t     &bsi, true, &ctr_before, &ctr_after);\n+  exit_if = build_if_stmt (build2 (exit_cmp, boolean_type_node, ctr_after,\n+\t\t\t\t   exit_bound),\n+\t\t\t   tree_block_label (loop->latch),\n+\t\t\t   tree_block_label (rest));\n+  bsi_insert_after (&bsi, exit_if, BSI_NEW_STMT);\n+\n+  verify_flow_info ();\n+  verify_dominators (CDI_DOMINATORS);\n+  verify_loop_structure (loops);\n+  verify_loop_closed_ssa ();\n+}"}, {"sha": "f913df3141b989cffc4fc2e322870506979803be", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=1768461812d5ccaf9f4a30336e6479eb03a29246", "patch": "@@ -140,6 +140,10 @@ number_of_iterations_ne (tree type, affine_iv *iv, tree final,\n   tree niter_type = unsigned_type_for (type);\n   tree s, c, d, bits, assumption, tmp, bound;\n \n+  niter->control = *iv;\n+  niter->bound = final;\n+  niter->cmp = NE_EXPR;\n+\n   /* Rearrange the terms so that we get inequality s * i <> c, with s\n      positive.  Also cast everything to the unsigned type.  */\n   if (tree_int_cst_sign_bit (iv->step))\n@@ -410,6 +414,19 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n   tree niter_type = unsigned_type_for (type);\n   tree delta, step, s;\n \n+  if (nonzero_p (iv0->step))\n+    {\n+      niter->control = *iv0;\n+      niter->cmp = LT_EXPR;\n+      niter->bound = iv1->base;\n+    }\n+  else\n+    {\n+      niter->control = *iv1;\n+      niter->cmp = GT_EXPR;\n+      niter->bound = iv0->base;\n+    }\n+\n   delta = fold_build2 (MINUS_EXPR, niter_type,\n \t\t       fold_convert (niter_type, iv1->base),\n \t\t       fold_convert (niter_type, iv0->base));\n@@ -543,6 +560,9 @@ number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n   niter->niter = NULL_TREE;\n   niter->additional_info = boolean_true_node;\n \n+  niter->bound = NULL_TREE;\n+  niter->cmp = ERROR_MARK;\n+\n   /* Make < comparison from > ones, and for NE_EXPR comparisons, ensure that\n      the control variable is on lhs.  */\n   if (code == GE_EXPR || code == GT_EXPR"}, {"sha": "60cdefcbe242bdcaab2b5fd1abfb0979a835bd17", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1768461812d5ccaf9f4a30336e6479eb03a29246/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=1768461812d5ccaf9f4a30336e6479eb03a29246", "patch": "@@ -401,6 +401,40 @@ struct tree_opt_pass pass_complete_unroll =\n   0\t\t\t\t\t/* letter */\n };\n \n+/* Prefetching.  */\n+\n+static void\n+tree_ssa_loop_prefetch (void)\n+{\n+  if (!current_loops)\n+    return;\n+\n+  tree_ssa_prefetch_arrays (current_loops);\n+}\n+\n+static bool\n+gate_tree_ssa_loop_prefetch (void)\n+{\n+  return flag_prefetch_loop_arrays == 1;\n+}\n+\n+struct tree_opt_pass pass_loop_prefetch =\n+{\n+  \"prefetch\",\t\t\t\t/* name */\n+  gate_tree_ssa_loop_prefetch,\t\t/* gate */\n+  tree_ssa_loop_prefetch,\t       \t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_PREFETCH,\t  \t\t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_verify_loops,\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n+\n /* Induction variable optimizations.  */\n \n static void"}]}