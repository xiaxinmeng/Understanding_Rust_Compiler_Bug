{"sha": "c3f35647ff0ca30479971bb449058b733384d728", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNmMzU2NDdmZjBjYTMwNDc5OTcxYmI0NDkwNThiNzMzMzg0ZDcyOA==", "commit": {"author": {"name": "Sofiane Naci", "email": "sofiane.naci@arm.com", "date": "2013-07-31T14:32:39Z"}, "committer": {"name": "Sofiane Naci", "email": "sofiane@gcc.gnu.org", "date": "2013-07-31T14:32:39Z"}, "message": "config.gcc (arm*-*-*): Add aarch-common.o to extra_objs.\n\n\t* config.gcc (arm*-*-*): Add aarch-common.o to extra_objs.  Add\n\taarch-common-protos.h to extra_headers.\n\t(arm*-*-*): Add arm/aarch-common-protos.h to tm_p_file.\n\t* config/arm/arm.c (arm_early_load_addr_dep): Move from here to ...\n\t(arm_early_store_addr_dep): Likewise.\n\t(arm_no_early_alu_shift_dep: Likewise.\n\t(arm_no_early_alu_shift_value_dep: Likewise.\n\t(arm_no_early_mul_dep: Likewise.\n\t(arm_no_early_store_addr_dep: Likewise.\n\t(arm_mac_accumulator_is_mul_result: Likewise.\n\t(arm_mac_accumulator_is_result: Likewise.\n\t* config/arm/aarch-common.c: ... here.  New file.\n\t* config/arm/arm-protos.h (arm_early_load_addr_dep): Move from here to ...\n\t(arm_early_store_addr_dep): Likewise.\n\t(arm_no_early_alu_shift_dep: Likewise.\n\t(arm_no_early_alu_shift_value_dep: Likewise.\n\t(arm_no_early_mul_dep: Likewise.\n\t(arm_no_early_store_addr_dep: Likewise.\n\t(arm_mac_accumulator_is_mul_result: Likewise.\n\t(arm_mac_accumulator_is_result: Likewise.\n\t* config/arm/aarch-common-protos.h: ... here.  New file.\n\t* config/arm/t-arm (aarch-common.o): Define.\n\nFrom-SVN: r201376", "tree": {"sha": "8f78ee617f809fa9d16862c363e929c594cbe1c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f78ee617f809fa9d16862c363e929c594cbe1c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3f35647ff0ca30479971bb449058b733384d728", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3f35647ff0ca30479971bb449058b733384d728", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3f35647ff0ca30479971bb449058b733384d728", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3f35647ff0ca30479971bb449058b733384d728/comments", "author": null, "committer": null, "parents": [{"sha": "701bd1bd9cb1d26a57a812fc3d67563d59c3a2fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/701bd1bd9cb1d26a57a812fc3d67563d59c3a2fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/701bd1bd9cb1d26a57a812fc3d67563d59c3a2fb"}], "stats": {"total": 613, "additions": 358, "deletions": 255}, "files": [{"sha": "e343f2c64a39c6656ff714c18127171ec92a349c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f35647ff0ca30479971bb449058b733384d728/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f35647ff0ca30479971bb449058b733384d728/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c3f35647ff0ca30479971bb449058b733384d728", "patch": "@@ -1,3 +1,36 @@\n+2013-07-31  Sofiane Naci  <sofiane.naci@arm.com>\n+\n+\t* config.gcc (arm*-*-*): Add aarch-common.o to extra_objs.  Add\n+\taarch-common-protos.h to extra_headers.\n+\t(arm*-*-*): Add arm/aarch-common-protos.h to tm_p_file.\n+\t* config/arm/arm.c (arm_early_load_addr_dep): Move from here to ...\n+\t(arm_early_store_addr_dep): Likewise.\n+\t(arm_no_early_alu_shift_dep: Likewise.\n+\t(arm_no_early_alu_shift_value_dep: Likewise.\n+\t(arm_no_early_mul_dep: Likewise.\n+\t(arm_no_early_store_addr_dep: Likewise.\n+\t(arm_mac_accumulator_is_mul_result: Likewise.\n+\t(arm_mac_accumulator_is_result: Likewise.\n+\t* config/arm/aarch-common.c: ... here.  New file.\n+\t* config/arm/arm-protos.h (arm_early_load_addr_dep): Move from here to ...\n+\t(arm_early_store_addr_dep): Likewise.\n+\t(arm_no_early_alu_shift_dep: Likewise.\n+\t(arm_no_early_alu_shift_value_dep: Likewise.\n+\t(arm_no_early_mul_dep: Likewise.\n+\t(arm_no_early_store_addr_dep: Likewise.\n+\t(arm_mac_accumulator_is_mul_result: Likewise.\n+\t(arm_mac_accumulator_is_result: Likewise.\n+\t* config/arm/aarch-common-protos.h: ... here.  New file.\n+\t* config/arm/t-arm (aarch-common.o): Define.\n+\n+2013-07-31  Sofiane Naci  <sofiane.naci@arm.com>\n+\n+\t* config/arm/arm.md: Include new file \"types.md\".\n+\t(define_attr \"type\"): Move from here to ...\n+\t(define_attr \"mul32\"): Likewise.\n+\t(define_attr \"mul64\"): Likewise.\n+\t* config/arm/types.md: ... here.  New file.\n+\n 2013-07-31  Sebastian Huber  <sebastian.huber@embedded-brains.de>\n \n \t* config.gcc (*-*-rtems*): Use __cxa_atexit by default."}, {"sha": "fda3c6e0fb8b746f2548272a7cbb62840dabb697", "filename": "gcc/config.gcc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f35647ff0ca30479971bb449058b733384d728/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f35647ff0ca30479971bb449058b733384d728/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=c3f35647ff0ca30479971bb449058b733384d728", "patch": "@@ -327,6 +327,7 @@ am33_2.0-*-linux*)\n arm*-*-*)\n \tcpu_type=arm\n \textra_headers=\"mmintrin.h arm_neon.h\"\n+\textra_objs=\"aarch-common.o\"\n \ttarget_type_format_char='%'\n \tc_target_objs=\"arm-c.o\"\n \tcxx_target_objs=\"arm-c.o\"\n@@ -559,7 +560,11 @@ x86_64-*-*)\n \tfi\n \ttm_file=\"vxworks-dummy.h ${tm_file}\"\n \t;;\n-arm*-*-* | mips*-*-* | sh*-*-* | sparc*-*-*)\n+arm*-*-*)\n+\ttm_p_file=\"${tm_p_file} arm/aarch-common-protos.h\"\n+\ttm_file=\"vxworks-dummy.h ${tm_file}\"\n+\t;;\n+mips*-*-* | sh*-*-* | sparc*-*-*)\n \ttm_file=\"vxworks-dummy.h ${tm_file}\"\n \t;;\n esac"}, {"sha": "97768fce0caa3caba7491849ff00834e57f7ea57", "filename": "gcc/config/arm/aarch-common-protos.h", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f35647ff0ca30479971bb449058b733384d728/gcc%2Fconfig%2Farm%2Faarch-common-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f35647ff0ca30479971bb449058b733384d728/gcc%2Fconfig%2Farm%2Faarch-common-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common-protos.h?ref=c3f35647ff0ca30479971bb449058b733384d728", "patch": "@@ -0,0 +1,36 @@\n+/* Function prototypes for instruction scheduling dependeoncy routines,\n+   defined in aarch-common.c\n+\n+   Copyright (C) 1991-2013 Free Software Foundation, Inc.\n+   Contributed by ARM Ltd.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\n+#ifndef GCC_AARCH_COMMON_PROTOS_H\n+#define GCC_AARCH_COMMON_PROTOS_H\n+\n+extern int arm_early_load_addr_dep (rtx, rtx);\n+extern int arm_early_store_addr_dep (rtx, rtx);\n+extern int arm_mac_accumulator_is_mul_result (rtx, rtx);\n+extern int arm_mac_accumulator_is_result (rtx, rtx);\n+extern int arm_no_early_alu_shift_dep (rtx, rtx);\n+extern int arm_no_early_alu_shift_value_dep (rtx, rtx);\n+extern int arm_no_early_mul_dep (rtx, rtx);\n+extern int arm_no_early_store_addr_dep (rtx, rtx);\n+\n+#endif /* GCC_AARCH_COMMON_PROTOS_H */"}, {"sha": "69366af9bd5923678eb49dfe689495ad1dde3b8c", "filename": "gcc/config/arm/aarch-common.c", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f35647ff0ca30479971bb449058b733384d728/gcc%2Fconfig%2Farm%2Faarch-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f35647ff0ca30479971bb449058b733384d728/gcc%2Fconfig%2Farm%2Faarch-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common.c?ref=c3f35647ff0ca30479971bb449058b733384d728", "patch": "@@ -0,0 +1,278 @@\n+/* Dependency checks for instruction scheduling, shared between ARM and\n+   AARCH64.\n+\n+   Copyright (C) 1991-2013 Free Software Foundation, Inc.\n+   Contributed by ARM Ltd.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\n+/* Return nonzero if the CONSUMER instruction (a load) does need\n+   PRODUCER's value to calculate the address.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tm_p.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"c-family/c-common.h\"\n+#include \"rtl.h\"\n+\n+int\n+arm_early_load_addr_dep (rtx producer, rtx consumer)\n+{\n+  rtx value = PATTERN (producer);\n+  rtx addr = PATTERN (consumer);\n+\n+  if (GET_CODE (value) == COND_EXEC)\n+    value = COND_EXEC_CODE (value);\n+  if (GET_CODE (value) == PARALLEL)\n+    value = XVECEXP (value, 0, 0);\n+  value = XEXP (value, 0);\n+  if (GET_CODE (addr) == COND_EXEC)\n+    addr = COND_EXEC_CODE (addr);\n+  if (GET_CODE (addr) == PARALLEL)\n+    {\n+      if (GET_CODE (XVECEXP (addr, 0, 0)) == RETURN)\n+        addr = XVECEXP (addr, 0, 1);\n+      else\n+        addr = XVECEXP (addr, 0, 0);\n+    }\n+  addr = XEXP (addr, 1);\n+\n+  return reg_overlap_mentioned_p (value, addr);\n+}\n+\n+/* Return nonzero if the CONSUMER instruction (an ALU op) does not\n+   have an early register shift value or amount dependency on the\n+   result of PRODUCER.  */\n+\n+int\n+arm_no_early_alu_shift_dep (rtx producer, rtx consumer)\n+{\n+  rtx value = PATTERN (producer);\n+  rtx op = PATTERN (consumer);\n+  rtx early_op;\n+\n+  if (GET_CODE (value) == COND_EXEC)\n+    value = COND_EXEC_CODE (value);\n+  if (GET_CODE (value) == PARALLEL)\n+    value = XVECEXP (value, 0, 0);\n+  value = XEXP (value, 0);\n+  if (GET_CODE (op) == COND_EXEC)\n+    op = COND_EXEC_CODE (op);\n+  if (GET_CODE (op) == PARALLEL)\n+    op = XVECEXP (op, 0, 0);\n+  op = XEXP (op, 1);\n+\n+  early_op = XEXP (op, 0);\n+  /* This is either an actual independent shift, or a shift applied to\n+     the first operand of another operation.  We want the whole shift\n+     operation.  */\n+  if (REG_P (early_op))\n+    early_op = op;\n+\n+  return !reg_overlap_mentioned_p (value, early_op);\n+}\n+\n+/* Return nonzero if the CONSUMER instruction (an ALU op) does not\n+   have an early register shift value dependency on the result of\n+   PRODUCER.  */\n+\n+int\n+arm_no_early_alu_shift_value_dep (rtx producer, rtx consumer)\n+{\n+  rtx value = PATTERN (producer);\n+  rtx op = PATTERN (consumer);\n+  rtx early_op;\n+\n+  if (GET_CODE (value) == COND_EXEC)\n+    value = COND_EXEC_CODE (value);\n+  if (GET_CODE (value) == PARALLEL)\n+    value = XVECEXP (value, 0, 0);\n+  value = XEXP (value, 0);\n+  if (GET_CODE (op) == COND_EXEC)\n+    op = COND_EXEC_CODE (op);\n+  if (GET_CODE (op) == PARALLEL)\n+    op = XVECEXP (op, 0, 0);\n+  op = XEXP (op, 1);\n+\n+  early_op = XEXP (op, 0);\n+\n+  /* This is either an actual independent shift, or a shift applied to\n+     the first operand of another operation.  We want the value being\n+     shifted, in either case.  */\n+  if (!REG_P (early_op))\n+    early_op = XEXP (early_op, 0);\n+\n+  return !reg_overlap_mentioned_p (value, early_op);\n+}\n+\n+/* Return nonzero if the CONSUMER (a mul or mac op) does not\n+   have an early register mult dependency on the result of\n+   PRODUCER.  */\n+\n+int\n+arm_no_early_mul_dep (rtx producer, rtx consumer)\n+{\n+  rtx value = PATTERN (producer);\n+  rtx op = PATTERN (consumer);\n+\n+  if (GET_CODE (value) == COND_EXEC)\n+    value = COND_EXEC_CODE (value);\n+  if (GET_CODE (value) == PARALLEL)\n+    value = XVECEXP (value, 0, 0);\n+  value = XEXP (value, 0);\n+  if (GET_CODE (op) == COND_EXEC)\n+    op = COND_EXEC_CODE (op);\n+  if (GET_CODE (op) == PARALLEL)\n+    op = XVECEXP (op, 0, 0);\n+  op = XEXP (op, 1);\n+\n+  if (GET_CODE (op) == PLUS || GET_CODE (op) == MINUS)\n+    {\n+      if (GET_CODE (XEXP (op, 0)) == MULT)\n+\treturn !reg_overlap_mentioned_p (value, XEXP (op, 0));\n+      else\n+\treturn !reg_overlap_mentioned_p (value, XEXP (op, 1));\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return nonzero if the CONSUMER instruction (a store) does not need\n+   PRODUCER's value to calculate the address.  */\n+\n+int\n+arm_no_early_store_addr_dep (rtx producer, rtx consumer)\n+{\n+  rtx value = PATTERN (producer);\n+  rtx addr = PATTERN (consumer);\n+\n+  if (GET_CODE (value) == COND_EXEC)\n+    value = COND_EXEC_CODE (value);\n+  if (GET_CODE (value) == PARALLEL)\n+    value = XVECEXP (value, 0, 0);\n+  value = XEXP (value, 0);\n+  if (GET_CODE (addr) == COND_EXEC)\n+    addr = COND_EXEC_CODE (addr);\n+  if (GET_CODE (addr) == PARALLEL)\n+    addr = XVECEXP (addr, 0, 0);\n+  addr = XEXP (addr, 0);\n+\n+  return !reg_overlap_mentioned_p (value, addr);\n+}\n+\n+/* Return nonzero if the CONSUMER instruction (a store) does need\n+   PRODUCER's value to calculate the address.  */\n+\n+int\n+arm_early_store_addr_dep (rtx producer, rtx consumer)\n+{\n+  return !arm_no_early_store_addr_dep (producer, consumer);\n+}\n+\n+/* Return non-zero iff the consumer (a multiply-accumulate or a\n+   multiple-subtract instruction) has an accumulator dependency on the\n+   result of the producer and no other dependency on that result.  It\n+   does not check if the producer is multiply-accumulate instruction.  */\n+int\n+arm_mac_accumulator_is_result (rtx producer, rtx consumer)\n+{\n+  rtx result;\n+  rtx op0, op1, acc;\n+\n+  producer = PATTERN (producer);\n+  consumer = PATTERN (consumer);\n+\n+  if (GET_CODE (producer) == COND_EXEC)\n+    producer = COND_EXEC_CODE (producer);\n+  if (GET_CODE (consumer) == COND_EXEC)\n+    consumer = COND_EXEC_CODE (consumer);\n+\n+  if (GET_CODE (producer) != SET)\n+    return 0;\n+\n+  result = XEXP (producer, 0);\n+\n+  if (GET_CODE (consumer) != SET)\n+    return 0;\n+\n+  /* Check that the consumer is of the form\n+     (set (...) (plus (mult ...) (...)))\n+     or\n+     (set (...) (minus (...) (mult ...))).  */\n+  if (GET_CODE (XEXP (consumer, 1)) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (XEXP (consumer, 1), 0)) != MULT)\n+        return 0;\n+\n+      op0 = XEXP (XEXP (XEXP (consumer, 1), 0), 0);\n+      op1 = XEXP (XEXP (XEXP (consumer, 1), 0), 1);\n+      acc = XEXP (XEXP (consumer, 1), 1);\n+    }\n+  else if (GET_CODE (XEXP (consumer, 1)) == MINUS)\n+    {\n+      if (GET_CODE (XEXP (XEXP (consumer, 1), 1)) != MULT)\n+        return 0;\n+\n+      op0 = XEXP (XEXP (XEXP (consumer, 1), 1), 0);\n+      op1 = XEXP (XEXP (XEXP (consumer, 1), 1), 1);\n+      acc = XEXP (XEXP (consumer, 1), 0);\n+    }\n+  else\n+    return 0;\n+\n+  return (reg_overlap_mentioned_p (result, acc)\n+          && !reg_overlap_mentioned_p (result, op0)\n+          && !reg_overlap_mentioned_p (result, op1));\n+}\n+\n+/* Return non-zero if the consumer (a multiply-accumulate instruction)\n+   has an accumulator dependency on the result of the producer (a\n+   multiplication instruction) and no other dependency on that result.  */\n+int\n+arm_mac_accumulator_is_mul_result (rtx producer, rtx consumer)\n+{\n+  rtx mul = PATTERN (producer);\n+  rtx mac = PATTERN (consumer);\n+  rtx mul_result;\n+  rtx mac_op0, mac_op1, mac_acc;\n+\n+  if (GET_CODE (mul) == COND_EXEC)\n+    mul = COND_EXEC_CODE (mul);\n+  if (GET_CODE (mac) == COND_EXEC)\n+    mac = COND_EXEC_CODE (mac);\n+\n+  /* Check that mul is of the form (set (...) (mult ...))\n+     and mla is of the form (set (...) (plus (mult ...) (...))).  */\n+  if ((GET_CODE (mul) != SET || GET_CODE (XEXP (mul, 1)) != MULT)\n+      || (GET_CODE (mac) != SET || GET_CODE (XEXP (mac, 1)) != PLUS\n+          || GET_CODE (XEXP (XEXP (mac, 1), 0)) != MULT))\n+    return 0;\n+\n+  mul_result = XEXP (mul, 0);\n+  mac_op0 = XEXP (XEXP (XEXP (mac, 1), 0), 0);\n+  mac_op1 = XEXP (XEXP (XEXP (mac, 1), 0), 1);\n+  mac_acc = XEXP (XEXP (mac, 1), 1);\n+\n+  return (reg_overlap_mentioned_p (mul_result, mac_acc)\n+          && !reg_overlap_mentioned_p (mul_result, mac_op0)\n+          && !reg_overlap_mentioned_p (mul_result, mac_op1));\n+}"}, {"sha": "f694dfdaae2e8d224cb1a103c76670b23ace58af", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f35647ff0ca30479971bb449058b733384d728/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f35647ff0ca30479971bb449058b733384d728/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=c3f35647ff0ca30479971bb449058b733384d728", "patch": "@@ -97,14 +97,6 @@ extern bool arm_tls_referenced_p (rtx);\n extern int arm_coproc_mem_operand (rtx, bool);\n extern int neon_vector_mem_operand (rtx, int, bool);\n extern int neon_struct_mem_operand (rtx);\n-extern int arm_no_early_store_addr_dep (rtx, rtx);\n-extern int arm_early_store_addr_dep (rtx, rtx);\n-extern int arm_early_load_addr_dep (rtx, rtx);\n-extern int arm_no_early_alu_shift_dep (rtx, rtx);\n-extern int arm_no_early_alu_shift_value_dep (rtx, rtx);\n-extern int arm_no_early_mul_dep (rtx, rtx);\n-extern int arm_mac_accumulator_is_result (rtx, rtx);\n-extern int arm_mac_accumulator_is_mul_result (rtx, rtx);\n \n extern int tls_mentioned_p (rtx);\n extern int symbol_mentioned_p (rtx);"}, {"sha": "0ee4d91f4c5a397ad1f7a03b764a05ccafe30abd", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 0, "deletions": 246, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f35647ff0ca30479971bb449058b733384d728/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f35647ff0ca30479971bb449058b733384d728/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c3f35647ff0ca30479971bb449058b733384d728", "patch": "@@ -25394,163 +25394,6 @@ arm_setup_incoming_varargs (cumulative_args_t pcum_v,\n     *pretend_size = (NUM_ARG_REGS - nregs) * UNITS_PER_WORD;\n }\n \n-/* Return nonzero if the CONSUMER instruction (a store) does not need\n-   PRODUCER's value to calculate the address.  */\n-\n-int\n-arm_no_early_store_addr_dep (rtx producer, rtx consumer)\n-{\n-  rtx value = PATTERN (producer);\n-  rtx addr = PATTERN (consumer);\n-\n-  if (GET_CODE (value) == COND_EXEC)\n-    value = COND_EXEC_CODE (value);\n-  if (GET_CODE (value) == PARALLEL)\n-    value = XVECEXP (value, 0, 0);\n-  value = XEXP (value, 0);\n-  if (GET_CODE (addr) == COND_EXEC)\n-    addr = COND_EXEC_CODE (addr);\n-  if (GET_CODE (addr) == PARALLEL)\n-    addr = XVECEXP (addr, 0, 0);\n-  addr = XEXP (addr, 0);\n-\n-  return !reg_overlap_mentioned_p (value, addr);\n-}\n-\n-/* Return nonzero if the CONSUMER instruction (a store) does need\n-   PRODUCER's value to calculate the address.  */\n-\n-int\n-arm_early_store_addr_dep (rtx producer, rtx consumer)\n-{\n-  return !arm_no_early_store_addr_dep (producer, consumer);\n-}\n-\n-/* Return nonzero if the CONSUMER instruction (a load) does need\n-   PRODUCER's value to calculate the address.  */\n-\n-int\n-arm_early_load_addr_dep (rtx producer, rtx consumer)\n-{\n-  rtx value = PATTERN (producer);\n-  rtx addr = PATTERN (consumer);\n-\n-  if (GET_CODE (value) == COND_EXEC)\n-    value = COND_EXEC_CODE (value);\n-  if (GET_CODE (value) == PARALLEL)\n-    value = XVECEXP (value, 0, 0);\n-  value = XEXP (value, 0);\n-  if (GET_CODE (addr) == COND_EXEC)\n-    addr = COND_EXEC_CODE (addr);\n-  if (GET_CODE (addr) == PARALLEL)\n-    {\n-      if (GET_CODE (XVECEXP (addr, 0, 0)) == RETURN)\n-        addr = XVECEXP (addr, 0, 1);\n-      else\n-        addr = XVECEXP (addr, 0, 0);\n-    }\n-  addr = XEXP (addr, 1);\n-\n-  return reg_overlap_mentioned_p (value, addr);\n-}\n-\n-/* Return nonzero if the CONSUMER instruction (an ALU op) does not\n-   have an early register shift value or amount dependency on the\n-   result of PRODUCER.  */\n-\n-int\n-arm_no_early_alu_shift_dep (rtx producer, rtx consumer)\n-{\n-  rtx value = PATTERN (producer);\n-  rtx op = PATTERN (consumer);\n-  rtx early_op;\n-\n-  if (GET_CODE (value) == COND_EXEC)\n-    value = COND_EXEC_CODE (value);\n-  if (GET_CODE (value) == PARALLEL)\n-    value = XVECEXP (value, 0, 0);\n-  value = XEXP (value, 0);\n-  if (GET_CODE (op) == COND_EXEC)\n-    op = COND_EXEC_CODE (op);\n-  if (GET_CODE (op) == PARALLEL)\n-    op = XVECEXP (op, 0, 0);\n-  op = XEXP (op, 1);\n-\n-  early_op = XEXP (op, 0);\n-  /* This is either an actual independent shift, or a shift applied to\n-     the first operand of another operation.  We want the whole shift\n-     operation.  */\n-  if (REG_P (early_op))\n-    early_op = op;\n-\n-  return !reg_overlap_mentioned_p (value, early_op);\n-}\n-\n-/* Return nonzero if the CONSUMER instruction (an ALU op) does not\n-   have an early register shift value dependency on the result of\n-   PRODUCER.  */\n-\n-int\n-arm_no_early_alu_shift_value_dep (rtx producer, rtx consumer)\n-{\n-  rtx value = PATTERN (producer);\n-  rtx op = PATTERN (consumer);\n-  rtx early_op;\n-\n-  if (GET_CODE (value) == COND_EXEC)\n-    value = COND_EXEC_CODE (value);\n-  if (GET_CODE (value) == PARALLEL)\n-    value = XVECEXP (value, 0, 0);\n-  value = XEXP (value, 0);\n-  if (GET_CODE (op) == COND_EXEC)\n-    op = COND_EXEC_CODE (op);\n-  if (GET_CODE (op) == PARALLEL)\n-    op = XVECEXP (op, 0, 0);\n-  op = XEXP (op, 1);\n-\n-  early_op = XEXP (op, 0);\n-\n-  /* This is either an actual independent shift, or a shift applied to\n-     the first operand of another operation.  We want the value being\n-     shifted, in either case.  */\n-  if (!REG_P (early_op))\n-    early_op = XEXP (early_op, 0);\n-\n-  return !reg_overlap_mentioned_p (value, early_op);\n-}\n-\n-/* Return nonzero if the CONSUMER (a mul or mac op) does not\n-   have an early register mult dependency on the result of\n-   PRODUCER.  */\n-\n-int\n-arm_no_early_mul_dep (rtx producer, rtx consumer)\n-{\n-  rtx value = PATTERN (producer);\n-  rtx op = PATTERN (consumer);\n-\n-  if (GET_CODE (value) == COND_EXEC)\n-    value = COND_EXEC_CODE (value);\n-  if (GET_CODE (value) == PARALLEL)\n-    value = XVECEXP (value, 0, 0);\n-  value = XEXP (value, 0);\n-  if (GET_CODE (op) == COND_EXEC)\n-    op = COND_EXEC_CODE (op);\n-  if (GET_CODE (op) == PARALLEL)\n-    op = XVECEXP (op, 0, 0);\n-  op = XEXP (op, 1);\n-\n-  if (GET_CODE (op) == PLUS || GET_CODE (op) == MINUS)\n-    {\n-      if (GET_CODE (XEXP (op, 0)) == MULT)\n-\treturn !reg_overlap_mentioned_p (value, XEXP (op, 0));\n-      else\n-\treturn !reg_overlap_mentioned_p (value, XEXP (op, 1));\n-    }\n-\n-  return 0;\n-}\n-\n /* We can't rely on the caller doing the proper promotion when\n    using APCS or ATPCS.  */\n \n@@ -25600,95 +25443,6 @@ arm_cxx_guard_type (void)\n   return TARGET_AAPCS_BASED ? integer_type_node : long_long_integer_type_node;\n }\n \n-/* Return non-zero iff the consumer (a multiply-accumulate or a\n-   multiple-subtract instruction) has an accumulator dependency on the\n-   result of the producer and no other dependency on that result.  It\n-   does not check if the producer is multiply-accumulate instruction.  */\n-int\n-arm_mac_accumulator_is_result (rtx producer, rtx consumer)\n-{\n-  rtx result;\n-  rtx op0, op1, acc;\n-\n-  producer = PATTERN (producer);\n-  consumer = PATTERN (consumer);\n-\n-  if (GET_CODE (producer) == COND_EXEC)\n-    producer = COND_EXEC_CODE (producer);\n-  if (GET_CODE (consumer) == COND_EXEC)\n-    consumer = COND_EXEC_CODE (consumer);\n-\n-  if (GET_CODE (producer) != SET)\n-    return 0;\n-\n-  result = XEXP (producer, 0);\n-\n-  if (GET_CODE (consumer) != SET)\n-    return 0;\n-\n-  /* Check that the consumer is of the form\n-     (set (...) (plus (mult ...) (...)))\n-     or\n-     (set (...) (minus (...) (mult ...))).  */\n-  if (GET_CODE (XEXP (consumer, 1)) == PLUS)\n-    {\n-      if (GET_CODE (XEXP (XEXP (consumer, 1), 0)) != MULT)\n-        return 0;\n-\n-      op0 = XEXP (XEXP (XEXP (consumer, 1), 0), 0);\n-      op1 = XEXP (XEXP (XEXP (consumer, 1), 0), 1);\n-      acc = XEXP (XEXP (consumer, 1), 1);\n-    }\n-  else if (GET_CODE (XEXP (consumer, 1)) == MINUS)\n-    {\n-      if (GET_CODE (XEXP (XEXP (consumer, 1), 1)) != MULT)\n-        return 0;\n-\n-      op0 = XEXP (XEXP (XEXP (consumer, 1), 1), 0);\n-      op1 = XEXP (XEXP (XEXP (consumer, 1), 1), 1);\n-      acc = XEXP (XEXP (consumer, 1), 0);\n-    }\n-  else\n-    return 0;\n-\n-  return (reg_overlap_mentioned_p (result, acc)\n-          && !reg_overlap_mentioned_p (result, op0)\n-          && !reg_overlap_mentioned_p (result, op1));\n-}\n-\n-/* Return non-zero if the consumer (a multiply-accumulate instruction)\n-   has an accumulator dependency on the result of the producer (a\n-   multiplication instruction) and no other dependency on that result.  */\n-int\n-arm_mac_accumulator_is_mul_result (rtx producer, rtx consumer)\n-{\n-  rtx mul = PATTERN (producer);\n-  rtx mac = PATTERN (consumer);\n-  rtx mul_result;\n-  rtx mac_op0, mac_op1, mac_acc;\n-\n-  if (GET_CODE (mul) == COND_EXEC)\n-    mul = COND_EXEC_CODE (mul);\n-  if (GET_CODE (mac) == COND_EXEC)\n-    mac = COND_EXEC_CODE (mac);\n-\n-  /* Check that mul is of the form (set (...) (mult ...))\n-     and mla is of the form (set (...) (plus (mult ...) (...))).  */\n-  if ((GET_CODE (mul) != SET || GET_CODE (XEXP (mul, 1)) != MULT)\n-      || (GET_CODE (mac) != SET || GET_CODE (XEXP (mac, 1)) != PLUS\n-          || GET_CODE (XEXP (XEXP (mac, 1), 0)) != MULT))\n-    return 0;\n-\n-  mul_result = XEXP (mul, 0);\n-  mac_op0 = XEXP (XEXP (XEXP (mac, 1), 0), 0);\n-  mac_op1 = XEXP (XEXP (XEXP (mac, 1), 0), 1);\n-  mac_acc = XEXP (XEXP (mac, 1), 1);\n-\n-  return (reg_overlap_mentioned_p (mul_result, mac_acc)\n-          && !reg_overlap_mentioned_p (mul_result, mac_op0)\n-          && !reg_overlap_mentioned_p (mul_result, mac_op1));\n-}\n-\n \n /* The EABI says test the least significant bit of a guard variable.  */\n "}, {"sha": "20e79ef26809e049f33cd7a57b9105d51fc6d303", "filename": "gcc/config/arm/t-arm", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f35647ff0ca30479971bb449058b733384d728/gcc%2Fconfig%2Farm%2Ft-arm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f35647ff0ca30479971bb449058b733384d728/gcc%2Fconfig%2Farm%2Ft-arm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm?ref=c3f35647ff0ca30479971bb449058b733384d728", "patch": "@@ -78,6 +78,11 @@ $(srcdir)/config/arm/arm-tables.opt: $(srcdir)/config/arm/genopt.sh \\\n \t$(SHELL) $(srcdir)/config/arm/genopt.sh $(srcdir)/config/arm > \\\n \t\t$(srcdir)/config/arm/arm-tables.opt\n \n+aarch-common.o: $(srcdir)/config/arm/aarch-common.c $(CONFIG_H) $(SYSTEM_H) \\\n+    coretypes.h $(TM_H) $(TM_P_H) $(RTL_H) $(TREE_H) output.h $(C_COMMON_H)\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/config/arm/aarch-common.c\n+\n arm.o: $(srcdir)/config/arm/arm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   $(RTL_H) $(TREE_H) $(HASH_TABLE_H) $(OBSTACK_H) $(REGS_H) hard-reg-set.h \\\n   insn-config.h conditions.h output.h dumpfile.h \\"}]}