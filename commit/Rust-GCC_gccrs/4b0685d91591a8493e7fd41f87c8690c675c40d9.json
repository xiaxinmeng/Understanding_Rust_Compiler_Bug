{"sha": "4b0685d91591a8493e7fd41f87c8690c675c40d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIwNjg1ZDkxNTkxYTg0OTNlN2ZkNDFmODdjODY5MGM2NzVjNDBkOQ==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2016-10-21T17:04:21Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2016-10-21T17:04:21Z"}, "message": "If the number of integer callee-saves is odd, any FP callee-saves use 8-byte aligned LDP/STP.\n\nIf the number of integer callee-saves is odd, any FP callee-saves use 8-byte\naligned LDP/STP.  Since 16-byte alignment may be faster on some CPUs, align\nthe FP callee-saves to 16 bytes and use the alignment gap for the last FP\ncallee-save when possible.\n\n    gcc/\n        * config/aarch64/aarch64.c (aarch64_layout_frame):\n        Align FP callee-saves.\n\nFrom-SVN: r241419", "tree": {"sha": "5db6300c2af15dbe11dae0ce8ae9d65e363b666c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5db6300c2af15dbe11dae0ce8ae9d65e363b666c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b0685d91591a8493e7fd41f87c8690c675c40d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b0685d91591a8493e7fd41f87c8690c675c40d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b0685d91591a8493e7fd41f87c8690c675c40d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b0685d91591a8493e7fd41f87c8690c675c40d9/comments", "author": null, "committer": null, "parents": [{"sha": "d17f7088fbe9b7d159021d0442d174925df7b20d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d17f7088fbe9b7d159021d0442d174925df7b20d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d17f7088fbe9b7d159021d0442d174925df7b20d"}], "stats": {"total": 24, "additions": 22, "deletions": 2}, "files": [{"sha": "0625c00044c31ffc23b253b644fbe424e87f5cb2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0685d91591a8493e7fd41f87c8690c675c40d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0685d91591a8493e7fd41f87c8690c675c40d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b0685d91591a8493e7fd41f87c8690c675c40d9", "patch": "@@ -1,3 +1,8 @@\n+2016-10-21  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_layout_frame):\n+\tAlign FP callee-saves.\n+\n 2016-10-21  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/adxintrin.h (_subborrow_u32, _addcarry_u32,"}, {"sha": "584e1f5a477804d3d059ed490608db1c7bdc4d2a", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0685d91591a8493e7fd41f87c8690c675c40d9/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0685d91591a8493e7fd41f87c8690c675c40d9/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=4b0685d91591a8493e7fd41f87c8690c675c40d9", "patch": "@@ -2734,7 +2734,7 @@ static void\n aarch64_layout_frame (void)\n {\n   HOST_WIDE_INT offset = 0;\n-  int regno;\n+  int regno, last_fp_reg = INVALID_REGNUM;\n \n   if (reload_completed && cfun->machine->frame.laid_out)\n     return;\n@@ -2768,7 +2768,10 @@ aarch64_layout_frame (void)\n   for (regno = V0_REGNUM; regno <= V31_REGNUM; regno++)\n     if (df_regs_ever_live_p (regno)\n \t&& !call_used_regs[regno])\n-      cfun->machine->frame.reg_offset[regno] = SLOT_REQUIRED;\n+      {\n+\tcfun->machine->frame.reg_offset[regno] = SLOT_REQUIRED;\n+\tlast_fp_reg = regno;\n+      }\n \n   if (frame_pointer_needed)\n     {\n@@ -2792,9 +2795,21 @@ aarch64_layout_frame (void)\n \toffset += UNITS_PER_WORD;\n       }\n \n+  HOST_WIDE_INT max_int_offset = offset;\n+  offset = ROUND_UP (offset, STACK_BOUNDARY / BITS_PER_UNIT);\n+  bool has_align_gap = offset != max_int_offset;\n+\n   for (regno = V0_REGNUM; regno <= V31_REGNUM; regno++)\n     if (cfun->machine->frame.reg_offset[regno] == SLOT_REQUIRED)\n       {\n+\t/* If there is an alignment gap between integer and fp callee-saves,\n+\t   allocate the last fp register to it if possible.  */\n+\tif (regno == last_fp_reg && has_align_gap && (offset & 8) == 0)\n+\t  {\n+\t    cfun->machine->frame.reg_offset[regno] = max_int_offset;\n+\t    break;\n+\t  }\n+\n \tcfun->machine->frame.reg_offset[regno] = offset;\n \tif (cfun->machine->frame.wb_candidate1 == INVALID_REGNUM)\n \t  cfun->machine->frame.wb_candidate1 = regno;"}]}