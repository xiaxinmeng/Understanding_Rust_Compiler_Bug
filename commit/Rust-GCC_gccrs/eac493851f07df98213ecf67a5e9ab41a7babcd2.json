{"sha": "eac493851f07df98213ecf67a5e9ab41a7babcd2", "node_id": "C_kwDOANBUbNoAKGVhYzQ5Mzg1MWYwN2RmOTgyMTNlY2Y2N2E1ZTlhYjQxYTdiYWJjZDI", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2023-04-08T08:04:13Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2023-04-08T08:04:13Z"}, "message": "Fortran: Fix some of the bugs in associate [PR87477]\n\n2023-04-08  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran\n\tPR fortran/87477\n\t* iresolve.cc (gfc_resolve_adjustl, gfc_resolve_adjustr): if\n\tstring length is deferred use the string typespec for result.\n\t* resolve.cc (resolve_assoc_var): Handle parentheses around the\n\ttarget expression.\n\t(resolve_block_construct): Remove unnecessary static decls.\n\t* trans-array.cc (gfc_conv_expr_descriptor): Guard string len\n\texpression in condition. Improve handling of string length and\n\tspan, especially for substrings of the descriptor.\n\t(duplicate_allocatable): Make element type more explicit with\n\t'eltype'.\n\t* trans-decl.cc (gfc_get_symbol_decl): Emit a fatal error with\n\tappropriate message instead of ICE if symbol type is unknown.\n\t(gfc_generate_function_code): Set current locus to proc_sym\n\tdeclared_at.\n\t* trans-expr.cc (gfc_get_expr_charlen): Retain last charlen in\n\t'previous' and use if end expression in substring reference is\n\tnull.\n\t(gfc_conv_string_length): Use gfc_conv_expr_descriptor if\n\t'expr_flat' is an array. Add post block to catch deallocation\n\tof temporaries.\n\t(gfc_conv_procedure_call): Assign the parmse string length to\n\tthe expression string length, if it is deferred.\n\t(gfc_trans_alloc_subarray_assign): If this is a deferred string\n\tlength component, store the string length in the hidden comp.\n\tUpdate the typespec length accordingly. Generate a new type\n\tspec for the call to gfc_duplicate-allocatable in this case.\n\t* trans-io.cc (gfc_trans_transfer): Scalarize transfer of\n\tdeferred character array components.\n\ngcc/testsuite/\n\tPR fortran/87477\n\t* gfortran.dg/associate_47.f90 : Enable substring test.\n\t* gfortran.dg/associate_51.f90 : Update an error message.\n\t* gfortran.dg/goacc/array-with-dt-2.f90 : Add span to\n\tuninitialzed dg-warnings.\n\n\tPR fortran/85686\n\tPR fortran/88247\n\tPR fortran/91941\n\tPR fortran/92779\n\tPR fortran/93339\n\tPR fortran/93813\n\tPR fortran/100948\n\tPR fortran/102106\n\t* gfortran.dg/associate_60.f90 : New test\n\n\tPR fortran/98408\n\t* gfortran.dg/pr98408.f90 : New test\n\n\tPR fortran/105205\n\t* gfortran.dg/pr105205.f90 : New test\n\n\tPR fortran/106918\n\t* gfortran.dg/pr106918.f90 : New test", "tree": {"sha": "7146895eed8a0c1417490f20a8e6f17be08b8884", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7146895eed8a0c1417490f20a8e6f17be08b8884"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eac493851f07df98213ecf67a5e9ab41a7babcd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eac493851f07df98213ecf67a5e9ab41a7babcd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eac493851f07df98213ecf67a5e9ab41a7babcd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eac493851f07df98213ecf67a5e9ab41a7babcd2/comments", "author": null, "committer": null, "parents": [{"sha": "46fe32cb4d887d44a62f9c4ff2a72532d4eb5a19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46fe32cb4d887d44a62f9c4ff2a72532d4eb5a19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46fe32cb4d887d44a62f9c4ff2a72532d4eb5a19"}], "stats": {"total": 351, "additions": 310, "deletions": 41}, "files": [{"sha": "8acad60a02be8786e1bbe387ef6f0c2c7a8c21cb", "filename": "gcc/fortran/iresolve.cc", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ffortran%2Firesolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ffortran%2Firesolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.cc?ref=eac493851f07df98213ecf67a5e9ab41a7babcd2", "patch": "@@ -230,7 +230,9 @@ gfc_resolve_adjustl (gfc_expr *f, gfc_expr *string)\n {\n   f->ts.type = BT_CHARACTER;\n   f->ts.kind = string->ts.kind;\n-  if (string->ts.u.cl)\n+  if (string->ts.deferred)\n+    f->ts = string->ts;\n+  else if (string->ts.u.cl)\n     f->ts.u.cl = gfc_new_charlen (gfc_current_ns, string->ts.u.cl);\n \n   f->value.function.name = gfc_get_string (\"__adjustl_s%d\", f->ts.kind);\n@@ -242,7 +244,9 @@ gfc_resolve_adjustr (gfc_expr *f, gfc_expr *string)\n {\n   f->ts.type = BT_CHARACTER;\n   f->ts.kind = string->ts.kind;\n-  if (string->ts.u.cl)\n+  if (string->ts.deferred)\n+    f->ts = string->ts;\n+  else if (string->ts.u.cl)\n     f->ts.u.cl = gfc_new_charlen (gfc_current_ns, string->ts.u.cl);\n \n   f->value.function.name = gfc_get_string (\"__adjustr_s%d\", f->ts.kind);\n@@ -3361,7 +3365,7 @@ gfc_resolve_mvbits (gfc_code *c)\n }\n \n \n-/* Set up the call to RANDOM_INIT.  */ \n+/* Set up the call to RANDOM_INIT.  */\n \n void\n gfc_resolve_random_init (gfc_code *c)"}, {"sha": "6e42397c2ea1f9993664b887750f7188ddb74850", "filename": "gcc/fortran/resolve.cc", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ffortran%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ffortran%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.cc?ref=eac493851f07df98213ecf67a5e9ab41a7babcd2", "patch": "@@ -9084,6 +9084,7 @@ static void\n resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n {\n   gfc_expr* target;\n+  bool parentheses = false;\n \n   gcc_assert (sym->assoc);\n   gcc_assert (sym->attr.flavor == FL_VARIABLE);\n@@ -9096,6 +9097,16 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n     return;\n   gcc_assert (!sym->assoc->dangling);\n \n+  if (target->expr_type == EXPR_OP\n+      && target->value.op.op == INTRINSIC_PARENTHESES\n+      && target->value.op.op1->expr_type == EXPR_VARIABLE)\n+    {\n+      sym->assoc->target = gfc_copy_expr (target->value.op.op1);\n+      gfc_free_expr (target);\n+      target = sym->assoc->target;\n+      parentheses = true;\n+    }\n+\n   if (resolve_target && !gfc_resolve_expr (target))\n     return;\n \n@@ -9177,6 +9188,7 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n \n   /* See if this is a valid association-to-variable.  */\n   sym->assoc->variable = (target->expr_type == EXPR_VARIABLE\n+\t\t\t  && !parentheses\n \t\t\t  && !gfc_has_vector_subscript (target));\n \n   /* Finally resolve if this is an array or not.  */\n@@ -9191,7 +9203,6 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n       return;\n     }\n \n-\n   /* We cannot deal with class selectors that need temporaries.  */\n   if (target->ts.type == BT_CLASS\n \t&& gfc_ref_needs_temporary_p (target->ref))\n@@ -10885,11 +10896,6 @@ gfc_resolve_forall (gfc_code *code, gfc_namespace *ns, int forall_save)\n \n \n /* Resolve a BLOCK construct statement.  */\n-static gfc_expr*\n-get_temp_from_expr (gfc_expr *, gfc_namespace *);\n-static gfc_code *\n-build_assignment (gfc_exec_op, gfc_expr *, gfc_expr *,\n-\t\t  gfc_component *, gfc_component *, locus);\n \n static void\n resolve_block_construct (gfc_code* code)"}, {"sha": "e17258080335d48c9ab9c5e21fbf6081f8a73c0b", "filename": "gcc/fortran/trans-array.cc", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ffortran%2Ftrans-array.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ffortran%2Ftrans-array.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.cc?ref=eac493851f07df98213ecf67a5e9ab41a7babcd2", "patch": "@@ -7568,6 +7568,7 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n   int full;\n   bool subref_array_target = false;\n   bool deferred_array_component = false;\n+  bool substr = false;\n   gfc_expr *arg, *ss_expr;\n \n   if (se->want_coarray)\n@@ -7618,6 +7619,9 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t  && TREE_CODE (desc) == COMPONENT_REF)\n \tdeferred_array_component = true;\n \n+      substr = info->ref && info->ref->next\n+\t       && info->ref->next->type == REF_SUBSTRING;\n+\n       subref_array_target = (is_subref_array (expr)\n \t\t\t     && (se->direct_byref\n \t\t\t\t || expr->ts.type == BT_CHARACTER));\n@@ -7659,7 +7663,10 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t\t\t\t      subref_array_target, expr);\n \n \t      /* ....and set the span field.  */\n-\t      tmp = gfc_conv_descriptor_span_get (desc);\n+\t      if (ss_info->expr->ts.type == BT_CHARACTER)\n+\t\ttmp = gfc_conv_descriptor_span_get (desc);\n+\t      else\n+\t\ttmp = gfc_get_array_span (desc, expr);\n \t      gfc_conv_descriptor_span_set (&se->pre, se->expr, tmp);\n \t    }\n \t  else if (se->want_pointer)\n@@ -7730,6 +7737,7 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \n \t  need_tmp = 1;\n \t  if (expr->ts.type == BT_CHARACTER\n+\t\t&& expr->ts.u.cl->length\n \t\t&& expr->ts.u.cl->length->expr_type != EXPR_CONSTANT)\n \t    get_array_charlen (expr, se);\n \n@@ -7915,7 +7923,7 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n       /* Set the string_length for a character array.  */\n       if (expr->ts.type == BT_CHARACTER)\n \t{\n-\t  if (deferred_array_component)\n+\t  if (deferred_array_component && !substr)\n \t    se->string_length = ss_info->string_length;\n \t  else\n \t    se->string_length =  gfc_get_expr_charlen (expr);\n@@ -7992,7 +8000,11 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t}\n \n       /* Set the span field.  */\n-      tmp = gfc_get_array_span (desc, expr);\n+      tmp = NULL_TREE;\n+      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))\n+\ttmp = gfc_conv_descriptor_span_get (desc);\n+      else\n+\ttmp = gfc_get_array_span (desc, expr);\n       if (tmp)\n \tgfc_conv_descriptor_span_set (&loop.pre, parm, tmp);\n \n@@ -8766,6 +8778,7 @@ duplicate_allocatable (tree dest, tree src, tree type, int rank,\n \t\t       tree add_when_allocated)\n {\n   tree tmp;\n+  tree eltype;\n   tree size;\n   tree nelems;\n   tree null_cond;\n@@ -8782,10 +8795,11 @@ duplicate_allocatable (tree dest, tree src, tree type, int rank,\n       null_data = gfc_finish_block (&block);\n \n       gfc_init_block (&block);\n+      eltype = TREE_TYPE (type);\n       if (str_sz != NULL_TREE)\n \tsize = str_sz;\n       else\n-\tsize = TYPE_SIZE_UNIT (TREE_TYPE (type));\n+\tsize = TYPE_SIZE_UNIT (eltype);\n \n       if (!no_malloc)\n \t{\n@@ -8812,11 +8826,19 @@ duplicate_allocatable (tree dest, tree src, tree type, int rank,\n       else\n \tnelems = gfc_index_one_node;\n \n+      /* If type is not the array type, then it is the element type.  */\n+      if (GFC_ARRAY_TYPE_P (type) || GFC_DESCRIPTOR_TYPE_P (type))\n+\teltype = gfc_get_element_type (type);\n+      else\n+\teltype = type;\n+\n       if (str_sz != NULL_TREE)\n \ttmp = fold_convert (gfc_array_index_type, str_sz);\n       else\n \ttmp = fold_convert (gfc_array_index_type,\n-\t\t\t    TYPE_SIZE_UNIT (gfc_get_element_type (type)));\n+\t\t\t    TYPE_SIZE_UNIT (eltype));\n+\n+      tmp = gfc_evaluate_now (tmp, &block);\n       size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n \t\t\t      nelems, tmp);\n       if (!no_malloc)\n@@ -9865,6 +9887,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl, tree dest,\n \t      /* This component cannot have allocatable components,\n \t\t therefore add_when_allocated of duplicate_allocatable ()\n \t\t is always NULL.  */\n+\t      rank = c->as ? c->as->rank : 0;\n \t      tmp = duplicate_allocatable (dcmp, comp, ctype, rank,\n \t\t\t\t\t   false, false, size, NULL_TREE);\n \t      gfc_add_expr_to_block (&fnblock, tmp);"}, {"sha": "299764b08b25d9ac31b73d07ebeb7667f70685cf", "filename": "gcc/fortran/trans-decl.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ffortran%2Ftrans-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ffortran%2Ftrans-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.cc?ref=eac493851f07df98213ecf67a5e9ab41a7babcd2", "patch": "@@ -1791,6 +1791,9 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n       return decl;\n     }\n \n+  if (sym->ts.type == BT_UNKNOWN)\n+    gfc_fatal_error (\"%s at %C has no default type\", sym->name);\n+\n   if (sym->attr.intrinsic)\n     gfc_internal_error (\"intrinsic variable which isn't a procedure\");\n \n@@ -7538,6 +7541,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n     }\n \n   trans_function_start (sym);\n+  gfc_current_locus = sym->declared_at;\n \n   gfc_init_block (&init);\n   gfc_init_block (&cleanup);"}, {"sha": "f052d6b94407a2eb723f65a6fa5d780c58772cf7", "filename": "gcc/fortran/trans-expr.cc", "status": "modified", "additions": 60, "deletions": 20, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ffortran%2Ftrans-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ffortran%2Ftrans-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.cc?ref=eac493851f07df98213ecf67a5e9ab41a7babcd2", "patch": "@@ -2124,6 +2124,7 @@ gfc_get_expr_charlen (gfc_expr *e)\n {\n   gfc_ref *r;\n   tree length;\n+  tree previous = NULL_TREE;\n   gfc_se se;\n \n   gcc_assert (e->expr_type == EXPR_VARIABLE\n@@ -2149,6 +2150,7 @@ gfc_get_expr_charlen (gfc_expr *e)\n   /* Look through the reference chain for component references.  */\n   for (r = e->ref; r; r = r->next)\n     {\n+      previous = length;\n       switch (r->type)\n \t{\n \tcase REF_COMPONENT:\n@@ -2164,7 +2166,10 @@ gfc_get_expr_charlen (gfc_expr *e)\n \t  gfc_init_se (&se, NULL);\n \t  gfc_conv_expr_type (&se, r->u.ss.start, gfc_charlen_type_node);\n \t  length = se.expr;\n-\t  gfc_conv_expr_type (&se, r->u.ss.end, gfc_charlen_type_node);\n+\t  if (r->u.ss.end)\n+\t    gfc_conv_expr_type (&se, r->u.ss.end, gfc_charlen_type_node);\n+\t  else\n+\t    se.expr = previous;\n \t  length = fold_build2_loc (input_location, MINUS_EXPR,\n \t\t\t\t    gfc_charlen_type_node,\n \t\t\t\t    se.expr, length);\n@@ -2554,23 +2559,25 @@ gfc_conv_string_length (gfc_charlen * cl, gfc_expr * expr, stmtblock_t * pblock)\n       expr_flat = gfc_copy_expr (expr);\n       flatten_array_ctors_without_strlen (expr_flat);\n       gfc_resolve_expr (expr_flat);\n-\n-      gfc_conv_expr (&se, expr_flat);\n-      gfc_add_block_to_block (pblock, &se.pre);\n-      cl->backend_decl = convert (gfc_charlen_type_node, se.string_length);\n-\n+      if (expr_flat->rank)\n+\tgfc_conv_expr_descriptor (&se, expr_flat);\n+      else\n+\tgfc_conv_expr (&se, expr_flat);\n+      if (expr_flat->expr_type != EXPR_VARIABLE)\n+\tgfc_add_block_to_block (pblock, &se.pre);\n+      se.expr = convert (gfc_charlen_type_node, se.string_length);\n+      gfc_add_block_to_block (pblock, &se.post);\n       gfc_free_expr (expr_flat);\n-      return;\n     }\n-\n-  /* Convert cl->length.  */\n-\n-  gcc_assert (cl->length);\n-\n-  gfc_conv_expr_type (&se, cl->length, gfc_charlen_type_node);\n-  se.expr = fold_build2_loc (input_location, MAX_EXPR, gfc_charlen_type_node,\n-\t\t\t     se.expr, build_zero_cst (TREE_TYPE (se.expr)));\n-  gfc_add_block_to_block (pblock, &se.pre);\n+  else\n+    {\n+      /* Convert cl->length.  */\n+      gfc_conv_expr_type (&se, cl->length, gfc_charlen_type_node);\n+      se.expr = fold_build2_loc (input_location, MAX_EXPR,\n+\t\t\t\t gfc_charlen_type_node, se.expr,\n+\t\t\t\t build_zero_cst (TREE_TYPE (se.expr)));\n+      gfc_add_block_to_block (pblock, &se.pre);\n+    }\n \n   if (cl->backend_decl && VAR_P (cl->backend_decl))\n     gfc_add_modify (pblock, cl->backend_decl, se.expr);\n@@ -7310,17 +7317,31 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       if (parmse.string_length && fsym && fsym->ts.deferred)\n \t{\n \t  if (INDIRECT_REF_P (parmse.string_length))\n-\t    /* In chains of functions/procedure calls the string_length already\n-\t       is a pointer to the variable holding the length.  Therefore\n-\t       remove the deref on call.  */\n-\t    parmse.string_length = TREE_OPERAND (parmse.string_length, 0);\n+\t    {\n+\t      /* In chains of functions/procedure calls the string_length already\n+\t\t is a pointer to the variable holding the length.  Therefore\n+\t\t remove the deref on call.  */\n+\t      tmp = parmse.string_length;\n+\t      parmse.string_length = TREE_OPERAND (parmse.string_length, 0);\n+\t    }\n \t  else\n \t    {\n \t      tmp = parmse.string_length;\n \t      if (!VAR_P (tmp) && TREE_CODE (tmp) != COMPONENT_REF)\n \t\ttmp = gfc_evaluate_now (parmse.string_length, &se->pre);\n \t      parmse.string_length = gfc_build_addr_expr (NULL_TREE, tmp);\n \t    }\n+\n+\t  if (e && e->expr_type == EXPR_VARIABLE\n+\t      && fsym->attr.allocatable\n+\t      && e->ts.u.cl->backend_decl\n+\t      && VAR_P (e->ts.u.cl->backend_decl))\n+\t    {\n+\t      if (INDIRECT_REF_P (tmp))\n+\t\ttmp = TREE_OPERAND (tmp, 0);\n+\t      gfc_add_modify (&se->post, e->ts.u.cl->backend_decl,\n+\t\t\t      fold_convert (gfc_charlen_type_node, tmp));\n+\t    }\n \t}\n \n       /* Character strings are passed as two parameters, a length and a\n@@ -8584,6 +8605,20 @@ gfc_trans_alloc_subarray_assign (tree dest, gfc_component * cm,\n   gfc_conv_expr_descriptor (&se, expr);\n   gfc_add_block_to_block (&block, &se.pre);\n   gfc_add_modify (&block, dest, se.expr);\n+  if (cm->ts.type == BT_CHARACTER\n+      && gfc_deferred_strlen (cm, &tmp))\n+    {\n+      tmp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t     TREE_TYPE (tmp),\n+\t\t\t     TREE_OPERAND (dest, 0),\n+\t\t\t     tmp, NULL_TREE);\n+      gfc_add_modify (&block, tmp,\n+\t\t\t      fold_convert (TREE_TYPE (tmp),\n+\t\t\t      se.string_length));\n+      cm->ts.u.cl->backend_decl = gfc_create_var (gfc_charlen_type_node,\n+\t\t\t\t\t\t  \"slen\");\n+      gfc_add_modify (&block, cm->ts.u.cl->backend_decl, se.string_length);\n+    }\n \n   /* Deal with arrays of derived types with allocatable components.  */\n   if (gfc_bt_struct (cm->ts.type)\n@@ -8607,11 +8642,16 @@ gfc_trans_alloc_subarray_assign (tree dest, gfc_component * cm,\n \t\t\t\t\t   tmp, expr->rank, NULL_TREE);\n \t}\n     }\n+  else if (cm->ts.type == BT_CHARACTER && cm->ts.deferred)\n+    tmp = gfc_duplicate_allocatable (dest, se.expr,\n+\t\t\t\t     gfc_typenode_for_spec (&cm->ts),\n+\t\t\t\t     cm->as->rank, NULL_TREE);\n   else\n     tmp = gfc_duplicate_allocatable (dest, se.expr,\n \t\t\t\t     TREE_TYPE(cm->backend_decl),\n \t\t\t\t     cm->as->rank, NULL_TREE);\n \n+\n   gfc_add_expr_to_block (&block, tmp);\n   gfc_add_block_to_block (&block, &se.post);\n "}, {"sha": "9b54d2f0d31a79490c760e74f02c1fb493bc2616", "filename": "gcc/fortran/trans-io.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ffortran%2Ftrans-io.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ffortran%2Ftrans-io.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.cc?ref=eac493851f07df98213ecf67a5e9ab41a7babcd2", "patch": "@@ -2622,10 +2622,10 @@ gfc_trans_transfer (gfc_code * code)\n \n       if (expr->ts.type != BT_CLASS\n \t && expr->expr_type == EXPR_VARIABLE\n-\t && gfc_expr_attr (expr).pointer)\n+\t && ((expr->symtree->n.sym->ts.type == BT_DERIVED && expr->ts.deferred)\n+\t     || gfc_expr_attr (expr).pointer))\n \tgoto scalarize;\n \n-\n       if (!(gfc_bt_struct (expr->ts.type)\n \t      || expr->ts.type == BT_CLASS)\n \t    && ref && ref->next == NULL"}, {"sha": "d8a50c6091c154c7294475169e540373c023d5ab", "filename": "gcc/testsuite/gfortran.dg/associate_47.f90", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_47.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_47.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_47.f90?ref=eac493851f07df98213ecf67a5e9ab41a7babcd2", "patch": "@@ -39,10 +39,9 @@ program p\n    end associate\n    if (x%d(1) .ne. 'zqrtyd') stop 5\n \n-! Substrings of arrays still do not work correctly.\n    call foo ('lmnopqrst','ghijklmno')\n    associate (y => x%d(:)(2:4))\n-!      if (any (y .ne. ['mno','hij'])) stop 6\n+      if (any (y .ne. ['mno','hij'])) stop 6\n    end associate\n \n    call foo ('abcdef','ghijkl')"}, {"sha": "2e5218c78cf16c53fd17b1da4246c3dc94e6e9ba", "filename": "gcc/testsuite/gfortran.dg/associate_51.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_51.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_51.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_51.f90?ref=eac493851f07df98213ecf67a5e9ab41a7babcd2", "patch": "@@ -51,7 +51,7 @@ recursive subroutine s\n end\n \n recursive subroutine s2\n-   associate (y => (s2)) ! { dg-error \"Associating selector-expression at .1. yields a procedure\" }\n+   associate (y => (s2)) ! { dg-error \"is a procedure name\" }\n    end associate\n end\n "}, {"sha": "d804d62f400c300b6ced248c023a6fbb4d30fac7", "filename": "gcc/testsuite/gfortran.dg/associate_60.f90", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_60.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_60.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_60.f90?ref=eac493851f07df98213ecf67a5e9ab41a7babcd2", "patch": "@@ -0,0 +1,138 @@\n+! { dg-do run }\n+!\n+! Tests fixes for various pr87477 dependencies\n+!\n+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de> except for pr102106:\n+! which was contributed by Brad Richardson  <everythingfunctional@protonmail.com>\n+!\n+program associate_60\n+  implicit none\n+  character(20) :: buffer\n+\n+  call pr102106\n+  call pr100948\n+  call pr85686\n+  call pr88247\n+  call pr91941\n+  call pr92779\n+  call pr93339\n+  call pr93813\n+\n+contains\n+\n+  subroutine pr102106\n+    type :: sub_class_t\n+        integer :: i\n+    end type\n+    type :: with_polymorphic_component_t\n+        class(sub_class_t), allocatable :: sub_obj_\n+    end type\n+    associate(obj => with_polymorphic_component_t(sub_class_t(42)))\n+        if (obj%sub_obj_%i .ne. 42) stop 1\n+    end associate\n+  end\n+\n+  subroutine pr100948\n+    type t\n+      character(:), allocatable :: c(:)\n+    end type\n+    type(t), allocatable :: x\n+!\n+! Valid test in comment 1\n+!\n+    x = t(['ab','cd'])\n+    associate (y => x%c(:))\n+      if (any (y .ne. x%c)) stop 2\n+      if (any (y .ne. ['ab','cd'])) stop 3\n+    end associate\n+    deallocate (x)\n+!\n+! Allocation with source was found to only copy over one of the array elements\n+!\n+    allocate (x, source = t(['ef','gh']))\n+    associate (y => x%c(:))\n+      if (any (y .ne. x%c)) stop 4\n+      if (any (y .ne. ['ef','gh'])) stop 5\n+    end associate\n+    deallocate (x)\n+  end\n+\n+  subroutine pr85686\n+    call s85686([\" g'day \",\" bye!! \"])\n+    if (trim (buffer) .ne. \" a g'day a bye!!\") stop 6\n+  end\n+\n+  subroutine s85686(x)\n+    character(*) :: x(:)\n+    associate (y => 'a'//x)\n+      write (buffer, *) y ! Used to segfault at the write statement.\n+    end associate\n+  end\n+\n+  subroutine pr88247\n+      type t\n+         character(:), dimension(:), allocatable :: d\n+      end type t\n+      type(t), allocatable :: x\n+      character(5) :: buffer(3)\n+      allocate (x, source = t (['ab','cd'])) ! Didn't work\n+      write(buffer(1), *) x%d(2:1:-1)        ! Was found to be broken\n+      write(buffer(2), *) [x%d(2:1:-1)]      ! Was OK\n+      associate (y => [x%d(2:1:-1)])\n+        write(buffer(3), *) y                ! Bug in comment 7\n+      end associate\n+      if (any (buffer .ne. \" cdab\")) stop 7\n+  end\n+\n+  subroutine pr91941\n+    character(:), allocatable :: x(:), z(:)\n+    x = [' abc', ' xyz']\n+    z = adjustl(x)\n+    associate (y => adjustl(x))              ! Wrong character length was passed\n+      if (any(y .ne. ['abc ', 'xyz '])) stop 8\n+    end associate\n+  end\n+\n+  subroutine pr92779\n+    character(3) :: a = 'abc'\n+    associate (y => spread(trim(a),1,2) // 'd')\n+      if (any (y .ne. ['abcd','abcd'])) stop 9\n+    end associate\n+  end\n+\n+  subroutine pr93339\n+    type t\n+      character(:), allocatable :: a(:)\n+    end type\n+    type(t) :: x\n+    x = t([\"abc \"])                    ! Didn't assign anything\n+!   allocate (x%a(1), source = 'abc') ! Worked OK\n+    associate (y => x%a)\n+       if (any (y .ne. 'abc ')) stop 10\n+          associate (z => x%a)\n+            if (any (y .ne. z)) stop 11\n+          end associate\n+    end associate\n+  end\n+\n+  subroutine pr93813\n+    type t\n+    end type\n+    type, extends(t) :: t2\n+    end type\n+    class(t), allocatable :: x\n+    integer :: i = 0\n+    allocate (t :: x)\n+    associate (y => (x))  ! The parentheses triggered an ICE in select type\n+      select type (y)\n+      type is (t2)\n+          stop 12\n+      type is (t)\n+          i = 42\n+      class default\n+          stop 13\n+      end select\n+    end associate\n+    if (i .ne. 42) stop 14\n+  end\n+end"}, {"sha": "560e5351323be251764a899ef0de4ddc7b063383", "filename": "gcc/testsuite/gfortran.dg/goacc/array-with-dt-2.f90", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Farray-with-dt-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Farray-with-dt-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Farray-with-dt-2.f90?ref=eac493851f07df98213ecf67a5e9ab41a7babcd2", "patch": "@@ -8,8 +8,9 @@\n ! { dg-note {'b' declared here} {} { target *-*-* } .-1 }\n \n !$acc update host(b(::2))\n-! { dg-warning {'b\\.dim\\[0\\]\\.ubound' is used uninitialized} {} { target *-*-* } .-1 }\n-! { dg-warning {'b\\.dim\\[0\\]\\.lbound' is used uninitialized} {} { target *-*-* } .-2 }\n+! { dg-warning {'b\\.span' is used uninitialized} {} { target *-*-* } .-1 }\n+! { dg-warning {'b\\.dim\\[0\\]\\.ubound' is used uninitialized} {} { target *-*-* } .-2 }\n+! { dg-warning {'b\\.dim\\[0\\]\\.lbound' is used uninitialized} {} { target *-*-* } .-3 }\n !$acc update host(b(1)%A(::3,::4))\n end\n "}, {"sha": "0b6ada6e50fecbf0e3e44047852b53da94845d39", "filename": "gcc/testsuite/gfortran.dg/pr105205.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr105205.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr105205.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr105205.f90?ref=eac493851f07df98213ecf67a5e9ab41a7babcd2", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do run }\n+!\n+! Contributed by Rich Townsend  <townsend@astro.wisc.edu>\n+!\n+program alloc_char_type\n+   implicit none\n+   integer, parameter :: start = 1, finish = 4\n+   character(3) :: check(4)\n+   type mytype\n+      character(:), allocatable :: c(:)\n+   end type mytype\n+   type(mytype) :: a\n+   type(mytype) :: b\n+   integer :: i\n+   a%c = ['foo','bar','biz','buz']\n+   check = ['foo','bar','biz','buz']\n+   b = a\n+   do i = 1, size(b%c)\n+      if (b%c(i) .ne. check(i)) stop 1\n+   end do\n+   if (any (a%c .ne. check)) stop 2\n+   if (any (a%c(start:finish) .ne. check)) stop 3\n+   deallocate (a%c)\n+   deallocate (b%c)\n+end"}, {"sha": "25f72b360796f6f16023856c417bdaa7671c4274", "filename": "gcc/testsuite/gfortran.dg/pr106918.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr106918.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr106918.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr106918.f90?ref=eac493851f07df98213ecf67a5e9ab41a7babcd2", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do run }\n+!\n+! Contributed by Lionel Guez  <guez@lmd.ens.fr>\n+!\n+  character(len = :), allocatable:: attr_name(:)\n+  character(6) :: buffer\n+  type coord_def\n+     character(len = :), allocatable:: attr_name(:)\n+  end type coord_def\n+  type(coord_def) coordinates\n+  attr_name = [\"units\"]\n+  write (buffer, *) attr_name\n+  if (buffer .ne. \" units\") stop 1\n+  coordinates = coord_def(attr_name)\n+  write (buffer, *) coordinates%attr_name\n+  if (buffer .ne. \" units\") stop 2\n+  deallocate (attr_name)\n+  deallocate (coordinates%attr_name)\n+end"}, {"sha": "4ec1a08fe02c2d240b48a9dfbd3c30a179415960", "filename": "gcc/testsuite/gfortran.dg/pr98408.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr98408.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac493851f07df98213ecf67a5e9ab41a7babcd2/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr98408.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr98408.f90?ref=eac493851f07df98213ecf67a5e9ab41a7babcd2", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do run }\n+!\n+! Contributed by Thomas Koenig  <tkoenig@gcc.gnu.org>\n+!\n+program main\n+  character (len=:), allocatable :: a(:)\n+  allocate (character(len=10) :: a(5))\n+  if (sizeof(a) .ne. 50) stop 1\n+  deallocate (a)\n+end program main"}]}