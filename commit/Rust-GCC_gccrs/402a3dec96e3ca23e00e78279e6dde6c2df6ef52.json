{"sha": "402a3dec96e3ca23e00e78279e6dde6c2df6ef52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAyYTNkZWM5NmUzY2EyM2UwMGU3ODI3OWU2ZGRlNmMyZGY2ZWY1Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-07-05T16:14:51Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-07-05T16:14:51Z"}, "message": "tree-sra.c (struct sra_walk_fns): Init function now returns bool.\n\n\t* tree-sra.c (struct sra_walk_fns): Init function now returns bool.\n\t(sra_walk_modify_expr): Allow init function to fail.\n\t(scan_init): Now returns bool.\n\t(generate_element_init): If can't understand INIT, return false.\n\t(scalarize_init): Return false if generate_element_init does.\n\nFrom-SVN: r84120", "tree": {"sha": "c17b91148516e5bc330b639dd6508efde3389f23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c17b91148516e5bc330b639dd6508efde3389f23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/402a3dec96e3ca23e00e78279e6dde6c2df6ef52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/402a3dec96e3ca23e00e78279e6dde6c2df6ef52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/402a3dec96e3ca23e00e78279e6dde6c2df6ef52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/402a3dec96e3ca23e00e78279e6dde6c2df6ef52/comments", "author": null, "committer": null, "parents": [{"sha": "030bbecdbb3935ea4728da13d46dc0f0a9ebda4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/030bbecdbb3935ea4728da13d46dc0f0a9ebda4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/030bbecdbb3935ea4728da13d46dc0f0a9ebda4f"}], "stats": {"total": 66, "additions": 43, "deletions": 23}, "files": [{"sha": "791b1837c4a7694e30a1f4dcf3d4f56790759d89", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/402a3dec96e3ca23e00e78279e6dde6c2df6ef52/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/402a3dec96e3ca23e00e78279e6dde6c2df6ef52/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=402a3dec96e3ca23e00e78279e6dde6c2df6ef52", "patch": "@@ -5,6 +5,12 @@\n \n 2004-07-05  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* tree-sra.c (struct sra_walk_fns): Init function now returns bool.\n+\t(sra_walk_modify_expr): Allow init function to fail.\n+\t(scan_init): Now returns bool.\n+\t(generate_element_init): If can't understand INIT, return false.\n+\t(scalarize_init): Return false if generate_element_init does.\n+\t\n \t* tree-pretty-print.c (dump_generic_node, case ARRAY_TYPE): Properly\n \tprint bounds.\n "}, {"sha": "592054013242be227041a18ecf555f1366397d11", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/402a3dec96e3ca23e00e78279e6dde6c2df6ef52/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/402a3dec96e3ca23e00e78279e6dde6c2df6ef52/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=402a3dec96e3ca23e00e78279e6dde6c2df6ef52", "patch": "@@ -569,8 +569,9 @@ struct sra_walk_fns\n \t\tblock_stmt_iterator *bsi);\n \n   /* Invoked when ELT is initialized from a constant.  VALUE may be NULL,\n-     in which case it should be treated as an empty CONSTRUCTOR.  */\n-  void (*init) (struct sra_elt *elt, tree value, block_stmt_iterator *bsi);\n+     in which case it should be treated as an empty CONSTRUCTOR.  Return\n+     false if we found a case we couldn't handle.  */\n+  bool (*init) (struct sra_elt *elt, tree value, block_stmt_iterator *bsi);\n \n   /* Invoked when we have a copy between one scalarizable reference ELT\n      and one non-scalarizable reference OTHER.  IS_OUTPUT is true if ELT\n@@ -769,21 +770,21 @@ sra_walk_modify_expr (tree expr, block_stmt_iterator *bsi,\n     {\n       /* If this is an assignment from a constant, or constructor, then\n \t we have access to all of the elements individually.  Invoke INIT.  */\n-      if (TREE_CODE (rhs) == COMPLEX_EXPR\n-\t  || TREE_CODE (rhs) == COMPLEX_CST\n-\t  || TREE_CODE (rhs) == CONSTRUCTOR)\n-\tfns->init (lhs_elt, rhs, bsi);\n+      if ((TREE_CODE (rhs) == COMPLEX_EXPR\n+\t   || TREE_CODE (rhs) == COMPLEX_CST\n+\t   || TREE_CODE (rhs) == CONSTRUCTOR)\n+\t  && fns->init (lhs_elt, rhs, bsi))\n+\t;\n \n       /* If this is an assignment from read-only memory, treat this as if\n \t we'd been passed the constructor directly.  Invoke INIT.  */\n       else if (TREE_CODE (rhs) == VAR_DECL\n \t       && TREE_STATIC (rhs)\n \t       && TREE_READONLY (rhs)\n-\t       && targetm.binds_local_p (rhs))\n-\t{\n-\t  if (DECL_INITIAL (rhs) != error_mark_node)\n-\t    fns->init (lhs_elt, DECL_INITIAL (rhs), bsi);\n-\t}\n+\t       && targetm.binds_local_p (rhs)\n+\t       && DECL_INITIAL (rhs)\n+\t       && fns->init (lhs_elt, DECL_INITIAL (rhs), bsi))\n+\t;\n \n       /* If this is a copy from a non-scalarizable lvalue, invoke LDST.\n \t The lvalue requirement prevents us from trying to directly scalarize\n@@ -933,11 +934,12 @@ scan_copy (struct sra_elt *lhs_elt, struct sra_elt *rhs_elt,\n   rhs_elt->n_copies += 1;\n }\n \n-static void\n+static bool\n scan_init (struct sra_elt *lhs_elt, tree rhs ATTRIBUTE_UNUSED,\n \t   block_stmt_iterator *bsi ATTRIBUTE_UNUSED)\n {\n   lhs_elt->n_copies += 1;\n+  return true;\n }\n \n static void\n@@ -1511,15 +1513,19 @@ generate_element_zero (struct sra_elt *elt, tree *list_p)\n /* Generate a set of assignment statements in *LIST_P to set all instantiated\n    elements under ELT with the contents of the initializer INIT.  In addition,\n    mark all assigned elements VISITED; this allows easy coordination with\n-   generate_element_zero.  */\n+   generate_element_zero.  Return false if we found a case we couldn't\n+   handle.  */\n \n-static void\n+static bool\n generate_element_init (struct sra_elt *elt, tree init, tree *list_p)\n {\n+  bool result = true;\n   enum tree_code init_code;\n   struct sra_elt *sub;\n   tree t;\n \n+  /* We can be passed DECL_INITIAL of a static variable.  It might have a\n+     conversion, which we strip off here.  */\n   STRIP_USELESS_TYPE_CONVERSION (init);\n   init_code = TREE_CODE (init);\n \n@@ -1531,7 +1537,7 @@ generate_element_init (struct sra_elt *elt, tree init, tree *list_p)\n \t  append_to_statement_list (t, list_p);\n \t  elt->visited = true;\n \t}\n-      return;\n+      return result;\n     }\n \n   switch (init_code)\n@@ -1546,7 +1552,7 @@ generate_element_init (struct sra_elt *elt, tree init, tree *list_p)\n \t  else\n \t    t = (init_code == COMPLEX_EXPR\n \t\t ? TREE_OPERAND (init, 1) : TREE_IMAGPART (init));\n-\t  generate_element_init (sub, t, list_p);\n+\t  result &= generate_element_init (sub, t, list_p);\n \t}\n       break;\n \n@@ -1556,13 +1562,15 @@ generate_element_init (struct sra_elt *elt, tree init, tree *list_p)\n \t  sub = lookup_element (elt, TREE_PURPOSE (t), NULL, NO_INSERT);\n \t  if (sub == NULL)\n \t    continue;\n-\t  generate_element_init (sub, TREE_VALUE (t), list_p);\n+\t  result &= generate_element_init (sub, TREE_VALUE (t), list_p);\n \t}\n       break;\n \n     default:\n-      abort ();\n+      result = false;\n     }\n+\n+  return result;\n }\n \n /* Insert STMT on all the outgoing edges out of BB.  Note that if BB\n@@ -1752,22 +1760,26 @@ scalarize_copy (struct sra_elt *lhs_elt, struct sra_elt *rhs_elt,\n /* Scalarize an INIT.  To recap, this is an assignment to a scalarizable\n    reference from some form of constructor: CONSTRUCTOR, COMPLEX_CST or\n    COMPLEX_EXPR.  If RHS is NULL, it should be treated as an empty\n-   CONSTRUCTOR.  */\n+   CONSTRUCTOR.  Return false if we didn't handle this case.  */\n \n-static void\n+static bool\n scalarize_init (struct sra_elt *lhs_elt, tree rhs, block_stmt_iterator *bsi)\n {\n+  bool result = true;\n   tree list = NULL;\n \n   /* Generate initialization statements for all members extant in the RHS.  */\n   if (rhs)\n-    generate_element_init (lhs_elt, rhs, &list);\n+    result = generate_element_init (lhs_elt, rhs, &list);\n \n   /* CONSTRUCTOR is defined such that any member not mentioned is assigned\n      a zero value.  Initialize the rest of the instantiated elements.  */\n   generate_element_zero (lhs_elt, &list);\n-  if (list == NULL)\n-    return;\n+\n+  /* If we didn't generate anything or couldn't handle this case return.\n+     Say which it was.  */\n+  if (!result || list == NULL)\n+    return result;\n \n   if (lhs_elt->use_block_copy)\n     {\n@@ -1784,6 +1796,8 @@ scalarize_init (struct sra_elt *lhs_elt, tree rhs, block_stmt_iterator *bsi)\n       mark_all_v_defs (bsi_stmt (*bsi));\n       sra_replace (bsi, list);\n     }\n+\n+  return true;\n }\n \n /* A subroutine of scalarize_ldst called via walk_tree.  Set TREE_NO_TRAP"}]}