{"sha": "a130a4418f3f1ebe732eb7c7d47d3b5a719e32f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTEzMGE0NDE4ZjNmMWViZTczMmViN2M3ZDQ3ZDNiNWE3MTllMzJmNg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-03-14T05:30:20Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-03-14T05:30:20Z"}, "message": "Initial revision\n\nFrom-SVN: r480", "tree": {"sha": "cbe422a4f0bfad0b215e4dc7a829d9b250be2d1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbe422a4f0bfad0b215e4dc7a829d9b250be2d1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a130a4418f3f1ebe732eb7c7d47d3b5a719e32f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a130a4418f3f1ebe732eb7c7d47d3b5a719e32f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a130a4418f3f1ebe732eb7c7d47d3b5a719e32f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a130a4418f3f1ebe732eb7c7d47d3b5a719e32f6/comments", "author": null, "committer": null, "parents": [{"sha": "cce8749ec52efb47ba2b1c6b266d53fc239a2f0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cce8749ec52efb47ba2b1c6b266d53fc239a2f0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cce8749ec52efb47ba2b1c6b266d53fc239a2f0f"}], "stats": {"total": 2442, "additions": 2442, "deletions": 0}, "files": [{"sha": "8aad34cf4eef1f5b75996160974f19f36514db0a", "filename": "gcc/final.c", "status": "added", "additions": 2442, "deletions": 0, "changes": 2442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a130a4418f3f1ebe732eb7c7d47d3b5a719e32f6/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a130a4418f3f1ebe732eb7c7d47d3b5a719e32f6/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=a130a4418f3f1ebe732eb7c7d47d3b5a719e32f6", "patch": "@@ -0,0 +1,2442 @@\n+/* Convert RTL to assembler code and output it, for GNU compiler.\n+   Copyright (C) 1987, 1988, 1989, 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* This is the final pass of the compiler.\n+   It looks at the rtl code for a function and outputs assembler code.\n+\n+   Call `final_start_function' to output the assembler code for function entry,\n+   `final' to output assembler code for some RTL code,\n+   `final_end_function' to output assembler code for function exit.\n+   If a function is compiled in several pieces, each piece is\n+   output separately with `final'.\n+\n+   Some optimizations are also done at this level.\n+   Move instructions that were made unnecessary by good register allocation\n+   are detected and omitted from the output.  (Though most of these\n+   are removed by the last jump pass.)\n+\n+   Instructions to set the condition codes are omitted when it can be\n+   seen that the condition codes already had the desired values.\n+\n+   In some cases it is sufficient if the inherited condition codes\n+   have related values, but this may require the following insn\n+   (the one that tests the condition codes) to be modified.\n+\n+   The code for the function prologue and epilogue are generated\n+   directly as assembler code by the macros FUNCTION_PROLOGUE and\n+   FUNCTION_EPILOGUE.  Those instructions never exist as rtl.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"gvarargs.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"insn-config.h\"\n+#include \"insn-attr.h\"\n+#include \"insn-codes.h\"\n+#include \"recog.h\"\n+#include \"conditions.h\"\n+#include \"flags.h\"\n+#include \"real.h\"\n+#include \"output.h\"\n+#include \"hard-reg-set.h\"\n+\n+#ifndef ASM_STABD_OP\n+#define ASM_STABD_OP \".stabd\"\n+#endif\n+\n+/* Get N_SLINE and N_SOL from stab.h if we can expect the file to exist.  */\n+#if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n+#ifdef USG\n+#include \"gstab.h\"  /* If doing DBX on sysV, use our own stab.h.  */\n+#else\n+#include <stab.h>  /* On BSD, use the system's stab.h.  */\n+#endif /* not USG */\n+#endif /* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */\n+\n+#ifdef XCOFF_DEBUGGING_INFO\n+#include \"xcoff.h\"\n+#endif\n+\n+/* .stabd code for line number.  */\n+#ifndef N_SLINE\n+#define\tN_SLINE\t0x44\n+#endif\n+\n+/* .stabs code for included file name.  */\n+#ifndef N_SOL\n+#define\tN_SOL 0x84\n+#endif\n+\n+#ifndef INT_TYPE_SIZE\n+#define INT_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+/* If we aren't using cc0, CC_STATUS_INIT shouldn't exist.  So define a\n+   null default for it to save conditionalization later.  */\n+#ifndef CC_STATUS_INIT\n+#define CC_STATUS_INIT\n+#endif\n+\n+/* How to start an assembler comment.  */\n+#ifndef ASM_COMMENT_START\n+#define ASM_COMMENT_START \";#\"\n+#endif\n+\n+rtx peephole ();\n+void output_asm_insn ();\n+rtx alter_subreg ();\n+static int alter_cond ();\n+void output_asm_label ();\n+static void output_operand ();\n+void output_address ();\n+void output_addr_const ();\n+static void output_source_line ();\n+rtx final_scan_insn ();\n+void profile_function ();\n+\n+#ifdef HAVE_ATTR_length\n+static int asm_insn_count ();\n+#endif\n+\n+/* Nonzero means this function is a leaf function, with no function calls. \n+   This variable exists to be examined in FUNCTION_PROLOGUE\n+   and FUNCTION_EPILOGUE.  Always zero, unless set by some action.  */\n+int leaf_function;\n+\n+int leaf_function_p ();\n+\n+#ifdef LEAF_REGISTERS\n+int only_leaf_regs_used ();\n+static void leaf_renumber_regs ();\n+void leaf_renumber_regs_insn ();\n+#endif\n+\n+/* Last insn processed by final_scan_insn.  */\n+static rtx debug_insn = 0;\n+\n+/* Line number of last NOTE.  */\n+static int last_linenum;\n+\n+/* Number of basic blocks seen so far;\n+   used if profile_block_flag is set.  */\n+static int count_basic_blocks;\n+\n+/* Nonzero while outputting an `asm' with operands.\n+   This means that inconsistencies are the user's fault, so don't abort.\n+   The precise value is the insn being output, to pass to error_for_asm.  */\n+static rtx this_is_asm_operands;\n+\n+/* Number of operands of this insn, for an `asm' with operands.  */\n+static int insn_noperands;\n+\n+/* Compare optimization flag.  */\n+\n+static rtx last_ignored_compare = 0;\n+\n+/* Flag indicating this insn is the start of a new basic block.  */\n+\n+static int new_block = 1;\n+\n+/* All the symbol-blocks (levels of scoping) in the compilation\n+   are assigned sequence numbers in order of appearance of the\n+   beginnings of the symbol-blocks.  Both final and dbxout do this,\n+   and assume that they will both give the same number to each block.\n+   Final uses these sequence numbers to generate assembler label names\n+   LBBnnn and LBEnnn for the beginning and end of the symbol-block.\n+   Dbxout uses the sequence nunbers to generate references to the same labels\n+   from the dbx debugging information.\n+\n+   Sdb records this level at the beginning of each function,\n+   in order to find the current level when recursing down declarations.\n+   It outputs the block beginning and endings\n+   at the point in the asm file where the blocks would begin and end.  */\n+\n+int next_block_index;\n+\n+/* Assign a unique number to each insn that is output.\n+   This can be used to generate unique local labels.  */\n+\n+static int insn_counter = 0;\n+\n+#ifdef HAVE_cc0\n+/* This variable contains machine-dependent flags (defined in tm.h)\n+   set and examined by output routines\n+   that describe how to interpret the condition codes properly.  */\n+\n+CC_STATUS cc_status;\n+\n+/* During output of an insn, this contains a copy of cc_status\n+   from before the insn.  */\n+\n+CC_STATUS cc_prev_status;\n+#endif\n+\n+/* Indexed by hardware reg number, is 1 if that register is ever\n+   used in the current function.\n+\n+   In life_analysis, or in stupid_life_analysis, this is set\n+   up to record the hard regs used explicitly.  Reload adds\n+   in the hard regs used for holding pseudo regs.  Final uses\n+   it to generate the code in the function prologue and epilogue\n+   to save and restore registers as needed.  */\n+\n+char regs_ever_live[FIRST_PSEUDO_REGISTER];\n+\n+/* Nonzero means current function must be given a frame pointer.\n+   Set in stmt.c if anything is allocated on the stack there.\n+   Set in reload1.c if anything is allocated on the stack there.  */\n+\n+int frame_pointer_needed;\n+\n+/* Assign unique numbers to labels generated for profiling.  */\n+\n+int profile_label_no;\n+\n+/* Length so far allocated in PENDING_BLOCKS.  */\n+\n+static int max_block_depth;\n+\n+/* Stack of sequence numbers of symbol-blocks of which we have seen the\n+   beginning but not yet the end.  Sequence numbers are assigned at\n+   the beginning; this stack allows us to find the sequence number\n+   of a block that is ending.  */\n+\n+static int *pending_blocks;\n+\n+/* Number of elements currently in use in PENDING_BLOCKS.  */\n+\n+static int block_depth;\n+\n+/* Nonzero if have enabled APP processing of our assembler output.  */\n+\n+static int app_on;\n+\n+/* If we are outputting an insn sequence, this contains the sequence rtx.\n+   Zero otherwise.  */\n+\n+rtx final_sequence;\n+\n+/* Indexed by line number, nonzero if there is a note for that line.  */\n+\n+static char *line_note_exists;\n+\f\n+/* Initialize data in final at the beginning of a compilation.  */\n+\n+void\n+init_final (filename)\n+     char *filename;\n+{\n+  next_block_index = 2;\n+  app_on = 0;\n+  max_block_depth = 20;\n+  pending_blocks = (int *) xmalloc (20 * sizeof *pending_blocks);\n+  final_sequence = 0;\n+}\n+\n+/* Called at end of source file,\n+   to output the block-profiling table for this entire compilation.  */\n+\n+void\n+end_final (filename)\n+     char *filename;\n+{\n+  int i;\n+\n+  if (profile_block_flag)\n+    {\n+      char name[12];\n+\n+      data_section ();\n+\n+      /* Output the main header, of 6 words:\n+\t 0:  1 if this file's initialized, else 0.\n+\t 1:  address of file name.\n+\t 2:  address of table of counts.\n+\t 4:  number of counts in the table.\n+\t 5:  always 0, for compatibility with Sun.\n+\t 6:  extra word added by GNU: address of address table\n+\t      which contains addresses of basic blocks,\n+\t      in parallel with the table of counts.  */\n+      ASM_OUTPUT_ALIGN (asm_out_file,\n+\t\t\texact_log2 (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n+\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 0);\n+      assemble_integer (const0_rtx, UNITS_PER_WORD, 1);\n+      ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 1);\n+      assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), UNITS_PER_WORD, 1);\n+      ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 2);\n+      assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), UNITS_PER_WORD, 1);\n+      assemble_integer (gen_rtx (CONST_INT, VOIDmode, count_basic_blocks),\n+\t\t\tUNITS_PER_WORD, 1);\n+      assemble_integer (const0_rtx, UNITS_PER_WORD, 1);\n+      ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 3);\n+      assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), UNITS_PER_WORD, 1);\n+\n+      /* Output the file name.  */\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 1);\n+      {\n+\tint len = strlen (filename);\n+\tchar *data_file = (char *) alloca (len + 3);\n+\tstrcpy (data_file, filename);\n+\tstrip_off_ending (data_file, len);\n+\tstrcat (data_file, \".d\");\n+\tassemble_string (data_file, strlen (data_file) + 1);\n+      }\n+\n+      /* Realign data section.  */\n+      ASM_OUTPUT_ALIGN (asm_out_file,\n+\t\t\texact_log2 (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n+\n+      /* Make space for the table of counts.  */\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 2);\n+      assemble_zeros (INT_TYPE_SIZE / BITS_PER_UNIT * count_basic_blocks);\n+\n+      /* Output the table of addresses.  */\n+      readonly_data_section ();\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 3);\n+      for (i = 0; i < count_basic_blocks; i++)\n+\t{\n+\t  char name[12];\n+\t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPB\", i);\n+\t  assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name),\n+\t\t\t    UNITS_PER_WORD, 1);\n+\t}\n+\n+      /* End with the address of the table of addresses,\n+\t so we can find it easily, as the last word in the file's text.  */\n+      ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 3);\n+      assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), UNITS_PER_WORD, 1);\n+    }\n+}\n+\n+/* Enable APP processing of subsequent output.\n+   Used before the output from an `asm' statement.  */\n+\n+void\n+app_enable ()\n+{\n+  if (! app_on)\n+    {\n+      fprintf (asm_out_file, ASM_APP_ON);\n+      app_on = 1;\n+    }\n+}\n+\n+/* Enable APP processing of subsequent output.\n+   Called from varasm.c before most kinds of output.  */\n+\n+void\n+app_disable ()\n+{\n+  if (app_on)\n+    {\n+      fprintf (asm_out_file, ASM_APP_OFF);\n+      app_on = 0;\n+    }\n+}\n+\f\n+/* Return the number of slots filled in the current \n+   delayed branch sequence (we don't count the insn needing the\n+   delay slot).   Zero if not in a delayed branch sequence.  */\n+\n+#ifdef DELAY_SLOTS\n+int\n+dbr_sequence_length ()\n+{\n+  if (final_sequence != 0)\n+    return XVECLEN (final_sequence, 0) - 1;\n+  else\n+    return 0;\n+}\n+#endif\n+\f\n+/* The next two pages contain routines used to compute the length of an insn\n+   and to shorten branches.  */\n+\n+/* Arrays for insn lengths, and addresses.  The latter is referenced by\n+   `insn_current_length'.  */\n+\n+static short *insn_lengths;\n+int *insn_addresses;\n+\n+/* Address of insn being processed.  Used by `insn_current_length'.  */\n+int insn_current_address;\n+\n+/* Indicate the branch shortening hasn't yet been done.  */\n+\n+void\n+init_insn_lengths ()\n+{\n+  insn_lengths = 0;\n+}\n+\n+/* Obtain the current length of an insn.  If branch shortening has been done,\n+   get its actual length.  Otherwise, get its maximum length.  */\n+\n+int\n+get_attr_length (insn)\n+     rtx insn;\n+{\n+#ifdef HAVE_ATTR_length\n+  rtx body;\n+  int i;\n+  int length = 0;\n+\n+  if (insn_lengths)\n+    return insn_lengths[INSN_UID (insn)];\n+  else\n+    switch (GET_CODE (insn))\n+      {\n+      case NOTE:\n+      case BARRIER:\n+      case CODE_LABEL:\n+\treturn 0;\n+\n+      case CALL_INSN:\n+\tlength = insn_default_length (insn);\n+\tbreak;\n+\n+      case JUMP_INSN:\n+\tbody = PATTERN (insn);\n+        if (GET_CODE (body) == ADDR_VEC || GET_CODE (body) == ADDR_DIFF_VEC)\n+\t  {\n+\t    /* This only takes room if jump tables go into the text section.  */\n+#if !defined(READONLY_DATA_SECTION) || defined(JUMP_TABLES_IN_TEXT_SECTION)\n+\t    length = (XVECLEN (body, GET_CODE (body) == ADDR_DIFF_VEC)\n+\t\t      * GET_MODE_SIZE (GET_MODE (body)));\n+\n+\t    /* Be pessimistic and assume worst-case alignment.  */\n+\t    length += (GET_MODE_SIZE (GET_MODE (body)) - 1);\n+#else\n+\t    return 0;\n+#endif\n+\t  }\n+\telse\n+\t  length = insn_default_length (insn);\n+\tbreak;\n+\n+      case INSN:\n+\tbody = PATTERN (insn);\n+\tif (GET_CODE (body) == USE || GET_CODE (body) == CLOBBER)\n+\t  return 0;\n+\n+\telse if (GET_CODE (body) == ASM_INPUT || asm_noperands (body) >= 0)\n+\t  length = asm_insn_count (insn) * insn_default_length (insn);\n+\telse if (GET_CODE (body) == SEQUENCE)\n+\t  for (i = 0; i < XVECLEN (body, 0); i++)\n+\t    length += get_attr_length (XVECEXP (body, 0, i));\n+\telse\n+\t  length = insn_default_length (insn);\n+      }\n+\n+#ifdef ADJUST_INSN_LENGTH\n+  ADJUST_INSN_LENGTH (insn, length);\n+#endif\n+  return length;\n+#else /* not HAVE_ATTR_length */\n+  return 0;\n+#endif /* not HAVE_ATTR_length */\n+}\n+\f\n+/* Make a pass over all insns and compute their actual lengths by shortening\n+   any branches of variable length if possible.  */\n+\n+/* Give a default value for the lowest address in a function.  */\n+\n+#ifndef FIRST_INSN_ADDRESS\n+#define FIRST_INSN_ADDRESS 0\n+#endif\n+\n+void\n+shorten_branches (first)\n+     rtx first;\n+{\n+#ifdef HAVE_ATTR_length\n+  rtx insn;\n+  int something_changed = 1;\n+  int max_uid = 0;\n+  char *varying_length;\n+  rtx body;\n+  int uid;\n+\n+  /* Compute maximum UID and allocate arrays.  */\n+  for (insn = first; insn; insn = NEXT_INSN (insn))\n+    if (INSN_UID (insn) > max_uid)\n+      max_uid = INSN_UID (insn);\n+\n+  max_uid++;\n+  insn_lengths = (short *) oballoc (max_uid * sizeof (short));\n+  insn_addresses = (int *) oballoc (max_uid * sizeof (int));\n+  varying_length = (char *) oballoc (max_uid * sizeof (char));\n+\n+  /* Compute initial lengths, addresses, and varying flags for each insn.  */\n+  for (insn_current_address = FIRST_INSN_ADDRESS, insn = first;\n+       insn != 0;\n+       insn_current_address += insn_lengths[uid], insn = NEXT_INSN (insn))\n+    {\n+      uid = INSN_UID (insn);\n+      insn_addresses[uid] = insn_current_address;\n+      insn_lengths[uid] = 0;\n+      varying_length[uid] = 0;\n+      \n+      if (GET_CODE (insn) == NOTE || GET_CODE (insn) == BARRIER\n+\t  || GET_CODE (insn) == CODE_LABEL)\n+\tcontinue;\n+\n+      body = PATTERN (insn);\n+      if (GET_CODE (body) == ADDR_VEC || GET_CODE (body) == ADDR_DIFF_VEC)\n+\t{\n+\t  /* This only takes room if read-only data goes into the text\n+\t     section.  */\n+#if !defined(READONLY_DATA_SECTION) || defined(JUMP_TABLES_IN_TEXT_SECTION)\n+\t  int unitsize = GET_MODE_SIZE (GET_MODE (body));\n+\n+\t  insn_lengths[uid] = (XVECLEN (body, GET_CODE (body) == ADDR_DIFF_VEC)\n+\t\t\t       * GET_MODE_SIZE (GET_MODE (body)));\n+\n+\t  /* Account for possible alignment.  */\n+\t  insn_lengths[uid]\n+\t    += unitsize - (insn_current_address & (unitsize - 1));\n+#else\n+\t  ;\n+#endif\n+\t}\n+      else if (asm_noperands (body) >= 0)\n+\tinsn_lengths[uid] = asm_insn_count (body) * insn_default_length (insn);\n+      else if (GET_CODE (body) == SEQUENCE)\n+\t{\n+\t  int i;\n+\n+\t  /* Inside a delay slot sequence, we do not do any branch shortening\n+\t     (on the only machine known to have both variable-length branches\n+\t     and delay slots, the ROMP, branch-with-execute is the same size\n+\t     as the maximum branch anyway).  So we only have to handle normal\n+\t     insns (actually, reorg never puts ASM insns in a delay slot, but\n+\t     we don't take advantage of that knowledge here).  */\n+\t  for (i = 0; i < XVECLEN (body, 0); i++)\n+\t    {\n+\t      rtx inner_insn = XVECEXP (body, 0, i);\n+\t      int inner_uid = INSN_UID (inner_insn);\n+\t      int inner_length;\n+\n+\t      if (asm_noperands (PATTERN (XVECEXP (body, 0, i))) >= 0)\n+\t\tinner_length = (asm_insn_count (PATTERN (inner_insn))\n+\t\t\t\t* insn_default_length (inner_insn));\n+\t      else\n+\t\tinner_length = insn_default_length (inner_insn);\n+\t      \n+\t      insn_lengths[inner_uid] = inner_length;\n+\t      varying_length[inner_uid] = 0;\n+\t      insn_lengths[uid] += inner_length;\n+\t    }\n+\t}\n+      else if (GET_CODE (body) != USE && GET_CODE (body) != CLOBBER)\n+\t{\n+\t  insn_lengths[uid] = insn_default_length (insn);\n+\t  varying_length[uid] = insn_variable_length_p (insn);\n+\t}\n+\n+      /* If needed, do any adjustment.  */\n+#ifdef ADJUST_INSN_LENGTH\n+      ADJUST_INSN_LENGTH (insn, insn_lengths[uid]);\n+#endif\n+    }\n+\n+  /* Now loop over all the insns finding varying length insns.  For each,\n+     get the current insn length.  If it has changed, reflect the change.\n+     When nothing changes for a full pass, we are done.  */\n+\n+  while (something_changed)\n+    {\n+      something_changed = 0;\n+      for (insn_current_address = FIRST_INSN_ADDRESS, insn = first;\n+\t   insn != 0;\n+\t   insn_current_address += insn_lengths[uid], insn = NEXT_INSN (insn))\n+\t{\n+\t  int new_length;\n+\n+\t  uid = INSN_UID (insn);\n+\t  insn_addresses[uid] = insn_current_address;\n+\t  if (! varying_length[uid])\n+\t    continue;\n+\n+\t  new_length = insn_current_length (insn);\n+\t  if (new_length != insn_lengths[uid])\n+\t    {\n+\t      insn_lengths[uid] = new_length;\n+\t      something_changed = 1;\n+\t    }\n+\t}\n+    }\n+#endif /* HAVE_ATTR_length */\n+}\n+\n+#ifdef HAVE_ATTR_length\n+/* Given the body of an INSN known to be generated by an ASM statement, return\n+   the number of machine instructions likely to be generated for this insn.\n+   This is used to compute its length.  */\n+\n+static int\n+asm_insn_count (body)\n+     rtx body;\n+{\n+  char *template;\n+  int count = 1;\n+\n+  for (template = decode_asm_operands (body, 0, 0, 0, 0);\n+       *template; template++)\n+    if (*template == ';' || *template == '\\n')\n+      count++;\n+\n+  return count;\n+}\n+#endif\n+\f\n+/* Output assembler code for the start of a function,\n+   and initialize some of the variables in this file\n+   for the new function.  The label for the function and associated\n+   assembler pseudo-ops have already been output in `assemble_start_function'.\n+\n+   FIRST is the first insn of the rtl for the function being compiled.\n+   FILE is the file to write assembler code to.\n+   OPTIMIZE is nonzero if we should eliminate redundant\n+     test and compare insns.  */\n+\n+void\n+final_start_function (first, file, optimize)\n+     rtx first;\n+     FILE *file;\n+     int optimize;\n+{\n+  block_depth = 0;\n+\n+  this_is_asm_operands = 0;\n+\n+#ifdef NON_SAVING_SETJMP\n+  /* A function that calls setjmp should save and restore all the\n+     call-saved registers on a system where longjmp clobbers them.  */\n+  if (NON_SAVING_SETJMP && current_function_calls_setjmp)\n+    {\n+      int i;\n+\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (!call_used_regs[i] && !call_fixed_regs[i])\n+\t  regs_ever_live[i] = 1;\n+    }\n+#endif\n+  \n+  /* Initial line number is supposed to be output\n+     before the function's prologue and label\n+     so that the function's address will not appear to be\n+     in the last statement of the preceding function.  */\n+  if (NOTE_LINE_NUMBER (first) != NOTE_INSN_DELETED)\n+    {\n+      if (write_symbols == SDB_DEBUG)\n+\t/* For sdb, let's not, but say we did.\n+\t   We need to set last_linenum for sdbout_function_begin,\n+\t   but we can't have an actual line number before the .bf symbol.\n+\t   (sdb_begin_function_line is not set,\n+\t   and other compilers don't do it.)  */\n+\tlast_linenum = NOTE_LINE_NUMBER (first);\n+#ifdef XCOFF_DEBUGGING_INFO\n+      else if (write_symbols == XCOFF_DEBUG)\n+\t{\n+\t  last_linenum = NOTE_LINE_NUMBER (first);\n+\t  xcoffout_output_first_source_line (file, last_linenum);\n+\t}\n+#endif\t  \n+      else\n+\toutput_source_line (file, first);\n+    }\n+\n+#ifdef LEAF_REG_REMAP\n+  if (leaf_function)\n+    leaf_renumber_regs (first);\n+#endif\n+\n+  /* The Sun386i and perhaps other machines don't work right\n+     if the profiling code comes after the prologue.  */\n+#ifdef PROFILE_BEFORE_PROLOGUE\n+  if (profile_flag)\n+    profile_function (file);\n+#endif /* PROFILE_BEFORE_PROLOGUE */\n+\n+#ifdef FUNCTION_PROLOGUE\n+  /* First output the function prologue: code to set up the stack frame.  */\n+  FUNCTION_PROLOGUE (file, get_frame_size ());\n+#endif\n+\n+#if defined (SDB_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n+  if (write_symbols == SDB_DEBUG || write_symbols == XCOFF_DEBUG)\n+    next_block_index = 1;\n+#endif\n+\n+#ifdef FUNCTION_BLOCK_PROFILER\n+  if (profile_block_flag)\n+    {\n+      FUNCTION_BLOCK_PROFILER (file, profile_label_no);\n+    }\n+#endif /* FUNCTION_BLOCK_PROFILER */\n+\n+#ifndef PROFILE_BEFORE_PROLOGUE\n+  if (profile_flag)\n+    profile_function (file);\n+#endif /* not PROFILE_BEFORE_PROLOGUE */\n+\n+  profile_label_no++;\n+}\n+\n+void\n+profile_function (file)\n+     FILE *file;\n+{\n+  int align = MIN (BIGGEST_ALIGNMENT, INT_TYPE_SIZE);\n+  int sval = current_function_returns_struct;\n+  int cxt = current_function_needs_context;\n+\n+  data_section ();\n+  ASM_OUTPUT_ALIGN (file, floor_log2 (align / BITS_PER_UNIT));\n+  ASM_OUTPUT_INTERNAL_LABEL (file, \"LP\", profile_label_no);\n+  assemble_integer (const0_rtx, UNITS_PER_WORD, 1);\n+\n+  text_section ();\n+\n+#ifdef STRUCT_VALUE_INCOMING_REGNUM\n+  if (sval)\n+    ASM_OUTPUT_REG_PUSH (file, STRUCT_VALUE_INCOMING_REGNUM);\n+#else\n+#ifdef STRUCT_VALUE_REGNUM\n+  if (sval)\n+    ASM_OUTPUT_REG_PUSH (file, STRUCT_VALUE_REGNUM);\n+#endif\n+#endif\n+\n+#if 0\n+#ifdef STATIC_CHAIN_INCOMING_REGNUM\n+  if (cxt)\n+    ASM_OUTPUT_REG_PUSH (file, STATIC_CHAIN_INCOMING_REGNUM);\n+#else\n+#ifdef STATIC_CHAIN_REGNUM\n+  if (cxt)\n+    ASM_OUTPUT_REG_PUSH (file, STATIC_CHAIN_REGNUM);\n+#endif\n+#endif\n+#endif\t\t\t\t/* 0 */\n+\n+  FUNCTION_PROFILER (file, profile_label_no);\n+\n+#if 0\n+#ifdef STATIC_CHAIN_INCOMING_REGNUM\n+  if (cxt)\n+    ASM_OUTPUT_REG_POP (file, STATIC_CHAIN_INCOMING_REGNUM);\n+#else\n+#ifdef STATIC_CHAIN_REGNUM\n+  if (cxt)\n+    ASM_OUTPUT_REG_POP (file, STATIC_CHAIN_REGNUM);\n+#endif\n+#endif\n+#endif\t\t\t\t/* 0 */\n+\n+#ifdef STRUCT_VALUE_INCOMING_REGNUM\n+  if (sval)\n+    ASM_OUTPUT_REG_POP (file, STRUCT_VALUE_INCOMING_REGNUM);\n+#else\n+#ifdef STRUCT_VALUE_REGNUM\n+  if (sval)\n+    ASM_OUTPUT_REG_POP (file, STRUCT_VALUE_REGNUM);\n+#endif\n+#endif\n+}\n+\n+/* Output assembler code for the end of a function.\n+   For clarity, args are same as those of `final_start_function'\n+   even though not all of them are needed.  */\n+\n+void\n+final_end_function (first, file, optimize)\n+     rtx first;\n+     FILE *file;\n+     int optimize;\n+{\n+  if (app_on)\n+    {\n+      fprintf (file, ASM_APP_OFF);\n+      app_on = 0;\n+    }\n+\n+#ifdef SDB_DEBUGGING_INFO\n+  if (write_symbols == SDB_DEBUG)\n+    sdbout_end_function (last_linenum);\n+#endif\n+\n+#ifdef XCOFF_DEBUGGING_INFO\n+  if (write_symbols == XCOFF_DEBUG)\n+    xcoffout_end_function (file, last_linenum);\n+#endif\n+\n+#ifdef FUNCTION_EPILOGUE\n+  /* Finally, output the function epilogue:\n+     code to restore the stack frame and return to the caller.  */\n+  FUNCTION_EPILOGUE (file, get_frame_size ());\n+#endif\n+\n+#ifdef SDB_DEBUGGING_INFO\n+  if (write_symbols == SDB_DEBUG)\n+    sdbout_end_epilogue ();\n+#endif\n+\n+#ifdef DWARF_DEBUGGING_INFO\n+  if (write_symbols == DWARF_DEBUG)\n+    dwarfout_end_epilogue ();\n+#endif\n+\n+#ifdef XCOFF_DEBUGGING_INFO\n+  if (write_symbols == XCOFF_DEBUG)\n+    xcoffout_end_epilogue (file);\n+#endif\n+\n+  /* If FUNCTION_EPILOGUE is not defined, then the function body\n+     itself contains return instructions wherever needed.  */\n+}\n+\f\n+/* Output assembler code for some insns: all or part of a function.\n+   For description of args, see `final_start_function', above.\n+\n+   PRESCAN is 1 if we are not really outputting,\n+     just scanning as if we were outputting.\n+   Prescanning deletes and rearranges insns just like ordinary output.\n+   PRESCAN is -2 if we are outputting after having prescanned.\n+   In this case, don't try to delete or rearrange insns\n+   because that has already been done.\n+   Prescanning is done only on certain machines.  */\n+\n+void\n+final (first, file, optimize, prescan)\n+     rtx first;\n+     FILE *file;\n+     int optimize;\n+     int prescan;\n+{\n+  register rtx insn;\n+  int max_line = 0;\n+\n+  last_ignored_compare = 0;\n+  new_block = 1;\n+\n+  /* Make a map indicating which line numbers appear in this function.  */\n+  for (insn = first; insn; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > max_line)\n+      max_line = NOTE_LINE_NUMBER (insn);\n+\n+  line_note_exists = (char *) oballoc (max_line + 1);\n+  bzero (line_note_exists, max_line + 1);\n+\n+  for (insn = first; insn; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n+      line_note_exists[NOTE_LINE_NUMBER (insn)] = 1;\n+\n+  init_recog ();\n+\n+  CC_STATUS_INIT;\n+\n+  /* Output the insns.  */\n+  for (insn = NEXT_INSN (first); insn;)\n+    insn = final_scan_insn (insn, file, optimize, prescan, 0);\n+\n+  /* Do basic-block profiling here\n+     if the last insn was a conditional branch.  */\n+  if (profile_block_flag && new_block)\n+    {\n+      new_block = 0;\n+      /* Enable the table of basic-block use counts\n+\t to point at the code it applies to.  */\n+      ASM_OUTPUT_INTERNAL_LABEL (file, \"LPB\", count_basic_blocks);\n+      /* Before first insn of this basic block, increment the\n+\t count of times it was entered.  */\n+#ifdef BLOCK_PROFILER\n+      BLOCK_PROFILER (file, count_basic_blocks);\n+      CC_STATUS_INIT;\n+#endif\n+      count_basic_blocks++;\n+    }\n+}\n+\f\n+/* The final scan for one insn, INSN.\n+   Args are same as in `final', except that INSN\n+   is the insn being scanned.\n+   Value returned is the next insn to be scanned.\n+\n+   NOPEEPHOLES is the flag to disallow peephole processing (currently\n+   used for within delayed branch sequence output).  */\n+\n+rtx\n+final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n+     rtx insn;\n+     FILE *file;\n+     int optimize;\n+     int prescan;\n+     int nopeepholes;\n+{\n+  register int i;\n+  insn_counter++;\n+\n+  /* Ignore deleted insns.  These can occur when we split insns (due to a\n+     template of \"#\") while not optimizing.  */\n+  if (INSN_DELETED_P (insn))\n+    return NEXT_INSN (insn);\n+\n+  switch (GET_CODE (insn))\n+    {\n+    case NOTE:\n+      if (prescan > 0)\n+\tbreak;\n+\n+      /* Align the beginning of a loop, for higher speed\n+\t on certain machines.  */\n+\n+      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG && optimize > 0)\n+\t{\n+#ifdef ASM_OUTPUT_LOOP_ALIGN\n+\t  rtx next = next_nonnote_insn (insn);\n+\t  if (next && GET_CODE (next) == CODE_LABEL)\n+\t    {\n+\t      ASM_OUTPUT_LOOP_ALIGN (asm_out_file);\n+\t    }\n+#endif\n+\t  break;\n+\t}\n+      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n+\tbreak;\n+\n+      if (write_symbols == NO_DEBUG)\n+\tbreak;\n+      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n+\t{\n+#ifdef SDB_DEBUGGING_INFO\n+\t  if (write_symbols == SDB_DEBUG)\n+\t    sdbout_begin_function (last_linenum);\n+#endif\n+#ifdef XCOFF_DEBUGGING_INFO\n+\t  if (write_symbols == XCOFF_DEBUG)\n+\t    xcoffout_begin_function (file, last_linenum);\n+#endif\n+\t  break;\n+\t}\n+      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED)\n+\tbreak;\t\t\t/* An insn that was \"deleted\" */\n+      if (app_on)\n+\t{\n+\t  fprintf (file, ASM_APP_OFF);\n+\t  app_on = 0;\n+\t}\n+      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG\n+\t  && (debug_info_level == DINFO_LEVEL_NORMAL\n+\t      || debug_info_level == DINFO_LEVEL_VERBOSE))\n+\t{\n+\t  /* Beginning of a symbol-block.  Assign it a sequence number\n+\t     and push the number onto the stack PENDING_BLOCKS.  */\n+\n+\t  if (block_depth == max_block_depth)\n+\t    {\n+\t      /* PENDING_BLOCKS is full; make it longer.  */\n+\t      max_block_depth *= 2;\n+\t      pending_blocks\n+\t\t= (int *) xrealloc (pending_blocks,\n+\t\t\t\t    max_block_depth * sizeof (int));\n+\t    }\n+\t  pending_blocks[block_depth++] = next_block_index;\n+\n+\t  /* Output debugging info about the symbol-block beginning.  */\n+\n+#ifdef SDB_DEBUGGING_INFO\n+\t  if (write_symbols == SDB_DEBUG)\n+\t    sdbout_begin_block (file, last_linenum, next_block_index);\n+#endif\n+#ifdef XCOFF_DEBUGGING_INFO\n+\t  if (write_symbols == XCOFF_DEBUG)\n+\t    xcoffout_begin_block (file, last_linenum, next_block_index);\n+#endif\n+#ifdef DBX_DEBUGGING_INFO\n+\t  if (write_symbols == DBX_DEBUG)\n+\t    ASM_OUTPUT_INTERNAL_LABEL (file, \"LBB\", next_block_index);\n+#endif\n+#ifdef DWARF_DEBUGGING_INFO\n+\t  if (write_symbols == DWARF_DEBUG && block_depth > 1)\n+\t    dwarfout_begin_block (next_block_index);\n+#endif\n+\n+\t  next_block_index++;\n+\t}\n+      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END\n+\t       && (debug_info_level == DINFO_LEVEL_NORMAL\n+\t\t   || debug_info_level == DINFO_LEVEL_VERBOSE))\n+\t{\n+\t  /* End of a symbol-block.  Pop its sequence number off\n+\t     PENDING_BLOCKS and output debugging info based on that.  */\n+\n+\t  --block_depth;\n+\n+#ifdef XCOFF_DEBUGGING_INFO\n+\t  if (write_symbols == XCOFF_DEBUG && block_depth >= 0)\n+\t    xcoffout_end_block (file, last_linenum, pending_blocks[block_depth]);\n+#endif\n+#ifdef DBX_DEBUGGING_INFO\n+\t  if (write_symbols == DBX_DEBUG && block_depth >= 0)\n+\t    ASM_OUTPUT_INTERNAL_LABEL (file, \"LBE\",\n+\t\t\t\t       pending_blocks[block_depth]);\n+#endif\n+#ifdef SDB_DEBUGGING_INFO\n+\t  if (write_symbols == SDB_DEBUG && block_depth >= 0)\n+\t    sdbout_end_block (file, last_linenum);\n+#endif\n+#ifdef DWARF_DEBUGGING_INFO\n+\t  if (write_symbols == DWARF_DEBUG && block_depth >= 1)\n+\t    dwarfout_end_block (pending_blocks[block_depth]);\n+#endif\n+\t}\n+      else if (NOTE_LINE_NUMBER (insn) > 0)\n+\t/* This note is a line-number.  */\n+\t{\n+\t  register rtx note;\n+\n+#if 0 /* This is what we used to do.  */\n+\t  output_source_line (file, insn);\n+#endif\n+\t  int note_after = 0;\n+\n+\t  /* If there is anything real after this note,\n+\t     output it.  If another line note follows, omit this one.  */\n+\t  for (note = NEXT_INSN (insn); note; note = NEXT_INSN (note))\n+\t    {\n+\t      if (GET_CODE (note) != NOTE && GET_CODE (note) != CODE_LABEL)\n+\t\tbreak;\n+\t      else if (GET_CODE (note) == NOTE && NOTE_LINE_NUMBER (note) > 0)\n+\t\t{\n+\t\t  /* Another note follows; we can delete this note provided\n+\t\t     no intervening line numbers have notes elsewhere.  */\n+\t\t  int num;\n+\t\t  for (num = NOTE_LINE_NUMBER (insn) + 1;\n+\t\t       num < NOTE_LINE_NUMBER (note);\n+\t\t       num++)\n+\t\t    if (line_note_exists[num])\n+\t\t      break;\n+\n+\t\t  if (num == NOTE_LINE_NUMBER (note))\n+\t\t    note_after = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  /* Output this line note\n+\t     if it is the first or the last line note in a row.  */\n+\t  if (!note_after)\n+\t    output_source_line (file, insn);\n+\t}\n+      break;\n+\n+    case BARRIER:\n+#ifdef ASM_OUTPUT_ALIGN_CODE\n+      ASM_OUTPUT_ALIGN_CODE (file);\n+#endif\n+      break;\n+\n+    case CODE_LABEL:\n+      CC_STATUS_INIT;\n+      if (prescan > 0)\n+\tbreak;\n+      new_block = 1;\n+#ifdef SDB_DEBUGGING_INFO\n+      if (write_symbols == SDB_DEBUG && LABEL_NAME (insn))\n+\tsdbout_label (insn);\n+#endif\n+#ifdef DWARF_DEBUGGING_INFO\n+      if (write_symbols == DWARF_DEBUG && LABEL_NAME (insn))\n+\tdwarfout_label (insn);\n+#endif\n+      if (app_on)\n+\t{\n+\t  fprintf (file, ASM_APP_OFF);\n+\t  app_on = 0;\n+\t}\n+      if (NEXT_INSN (insn) != 0\n+\t  && GET_CODE (NEXT_INSN (insn)) == JUMP_INSN)\n+\t{\n+\t  rtx nextbody = PATTERN (NEXT_INSN (insn));\n+\n+\t  /* If this label is followed by a jump-table,\n+\t     make sure we put the label in the read-only section.  Also\n+\t     possibly write the label and jump table together.  */\n+\n+\t  if (GET_CODE (nextbody) == ADDR_VEC\n+\t      || GET_CODE (nextbody) == ADDR_DIFF_VEC)\n+\t    {\n+#ifndef JUMP_TABLES_IN_TEXT_SECTION\n+\t      readonly_data_section ();\n+#else\n+\t      text_section ();\n+#endif\n+#ifdef ASM_OUTPUT_CASE_LABEL\n+\t      ASM_OUTPUT_CASE_LABEL (file, \"L\", CODE_LABEL_NUMBER (insn),\n+\t\t\t\t     NEXT_INSN (insn));\n+#else\n+\t      ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (insn));\n+#endif\n+\t      break;\n+\t    }\n+\t}\n+\n+      ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (insn));\n+      break;\n+\n+    default:\n+      {\n+\tregister rtx body = PATTERN (insn);\n+\tint insn_code_number;\n+\tchar *template;\n+\trtx note;\n+\n+\t/* An INSN, JUMP_INSN or CALL_INSN.\n+\t   First check for special kinds that recog doesn't recognize.  */\n+\n+\tif (GET_CODE (body) == USE /* These are just declarations */\n+\t    || GET_CODE (body) == CLOBBER)\n+\t  break;\n+\n+#ifdef HAVE_cc0\n+\t/* If there is a REG_CC_SETTER note on this insn, it means that\n+\t   the setting of the condition code was done in the delay slot\n+\t   of the insn that branched here.  So recover the cc status\n+\t   from the insn that set it.  */\n+\n+\tnote = find_reg_note (insn, REG_CC_SETTER, 0);\n+\tif (note)\n+\t  {\n+\t    NOTICE_UPDATE_CC (PATTERN (XEXP (note, 0)), XEXP (note, 0));\n+\t    cc_prev_status = cc_status;\n+\t  }\n+#endif\n+\n+\t/* Detect insns that are really jump-tables\n+\t   and output them as such.  */\n+\n+\tif (GET_CODE (body) == ADDR_VEC || GET_CODE (body) == ADDR_DIFF_VEC)\n+\t  {\n+\t    register int vlen, idx;\n+\n+\t    if (prescan > 0)\n+\t      break;\n+\n+\t    if (app_on)\n+\t      {\n+\t\tfprintf (file, ASM_APP_OFF);\n+\t\tapp_on = 0;\n+\t      }\n+\n+\t    vlen = XVECLEN (body, GET_CODE (body) == ADDR_DIFF_VEC);\n+\t    for (idx = 0; idx < vlen; idx++)\n+\t      {\n+\t\tif (GET_CODE (body) == ADDR_VEC)\n+\t\t  ASM_OUTPUT_ADDR_VEC_ELT\n+\t\t    (file, CODE_LABEL_NUMBER (XEXP (XVECEXP (body, 0, idx), 0)));\n+\t\telse\n+\t\t  ASM_OUTPUT_ADDR_DIFF_ELT\n+\t\t    (file,\n+\t\t     CODE_LABEL_NUMBER (XEXP (XVECEXP (body, 1, idx), 0)),\n+\t\t     CODE_LABEL_NUMBER (XEXP (XEXP (body, 0), 0)));\n+\t      }\n+#ifdef ASM_OUTPUT_CASE_END\n+\t    ASM_OUTPUT_CASE_END (file,\n+\t\t\t\t CODE_LABEL_NUMBER (PREV_INSN (insn)),\n+\t\t\t\t insn);\n+#endif\n+\n+\t    text_section ();\n+\n+\t    break;\n+\t  }\n+\n+\t/* Do basic-block profiling when we reach a new block.\n+\t   Done here to avoid jump tables.  */\n+\tif (profile_block_flag && new_block)\n+\t  {\n+\t    new_block = 0;\n+\t    /* Enable the table of basic-block use counts\n+\t       to point at the code it applies to.  */\n+\t    ASM_OUTPUT_INTERNAL_LABEL (file, \"LPB\", count_basic_blocks);\n+\t    /* Before first insn of this basic block, increment the\n+\t       count of times it was entered.  */\n+#ifdef BLOCK_PROFILER\n+\t    BLOCK_PROFILER (file, count_basic_blocks);\n+\t    CC_STATUS_INIT;\n+#endif\n+\t    count_basic_blocks++;\n+\t  }\n+\n+\tif (GET_CODE (body) == ASM_INPUT)\n+\t  {\n+\t    /* There's no telling what that did to the condition codes.  */\n+\t    CC_STATUS_INIT;\n+\t    if (prescan > 0)\n+\t      break;\n+\t    if (! app_on)\n+\t      {\n+\t\tfprintf (file, ASM_APP_ON);\n+\t\tapp_on = 1;\n+\t      }\n+\t    fprintf (asm_out_file, \"\\t%s\\n\", XSTR (body, 0));\n+\t    break;\n+\t  }\n+\n+\t/* Detect `asm' construct with operands.  */\n+\tif (asm_noperands (body) >= 0)\n+\t  {\n+\t    int noperands = asm_noperands (body);\n+\t    rtx *ops;\n+\t    char *string;\n+\n+\t    /* There's no telling what that did to the condition codes.  */\n+\t    CC_STATUS_INIT;\n+\t    if (prescan > 0)\n+\t      break;\n+\n+\t    /* alloca won't do here, since only return from `final'\n+\t       would free it.  */\n+\t    if (noperands > 0)\n+\t      ops = (rtx *) xmalloc (noperands * sizeof (rtx));\n+\n+\t    if (! app_on)\n+\t      {\n+\t\tfprintf (file, ASM_APP_ON);\n+\t\tapp_on = 1;\n+\t      }\n+\n+\t    /* Get out the operand values.  */\n+\t    string = decode_asm_operands (body, ops, 0, 0, 0);\n+\t    /* Inhibit aborts on what would otherwise be compiler bugs.  */\n+\t    insn_noperands = noperands;\n+\t    this_is_asm_operands = insn;\n+\t    /* Output the insn using them.  */\n+\t    output_asm_insn (string, ops);\n+\t    this_is_asm_operands = 0;\n+\t    if (noperands > 0)\n+\t      free (ops);\n+\t    break;\n+\t  }\n+\n+\tif (prescan <= 0 && app_on)\n+\t  {\n+\t    fprintf (file, ASM_APP_OFF);\n+\t    app_on = 0;\n+\t  }\n+\n+\tif (GET_CODE (body) == SEQUENCE)\n+\t  {\n+\t    /* A delayed-branch sequence */\n+\t    register int i;\n+\t    rtx next;\n+\n+\t    if (prescan > 0)\n+\t      break;\n+\t    final_sequence = body;\n+\n+\t    /* The first insn in this SEQUENCE might be a JUMP_INSN that will\n+\t       force the restoration of a comparison that was previously\n+\t       thought unnecessary.  If that happens, cancel this sequence\n+\t       and cause that insn to be restored.  */\n+\n+\t    next = final_scan_insn (XVECEXP (body, 0, 0), file, 0, prescan, 1);\n+\t    if (next != XVECEXP (body, 0, 1))\n+\t      {\n+\t\tfinal_sequence = 0;\n+\t\treturn next;\n+\t      }\n+\n+\t    for (i = 1; i < XVECLEN (body, 0); i++)\n+\t      final_scan_insn (XVECEXP (body, 0, i), file, 0, prescan, 1);\n+#ifdef DBR_OUTPUT_SEQEND\n+\t    DBR_OUTPUT_SEQEND (file);\n+#endif\n+\t    final_sequence = 0;\n+\n+\t    /* If the insn requiring the delay slot was a CALL_INSN, the\n+\t       insns in the delay slot are actually executed before the\n+\t       called function.  Hence we don't preserve any CC-setting\n+\t       actions in these insns and the CC must be marked as being\n+\t       clobbered by the function.  */\n+\t    if (GET_CODE (XVECEXP (body, 0, 0)) == CALL_INSN)\n+\t      CC_STATUS_INIT;\n+\t    break;\n+\t  }\n+\n+\t/* We have a real machine instruction as rtl.  */\n+\n+\tbody = PATTERN (insn);\n+\n+#ifdef HAVE_cc0\n+\t/* Check for redundant test and compare instructions\n+\t   (when the condition codes are already set up as desired).\n+\t   This is done only when optimizing; if not optimizing,\n+\t   it should be possible for the user to alter a variable\n+\t   with the debugger in between statements\n+\t   and the next statement should reexamine the variable\n+\t   to compute the condition codes.  */\n+\n+\tif (optimize\n+\t    && GET_CODE (body) == SET\n+\t    && GET_CODE (SET_DEST (body)) == CC0\n+\t    && insn != last_ignored_compare)\n+\t  {\n+\t    if (GET_CODE (SET_SRC (body)) == SUBREG)\n+\t      SET_SRC (body) = alter_subreg (SET_SRC (body));\n+\t    else if (GET_CODE (SET_SRC (body)) == COMPARE)\n+\t      {\n+\t\tif (GET_CODE (XEXP (SET_SRC (body), 0)) == SUBREG)\n+\t\t  XEXP (SET_SRC (body), 0)\n+\t\t    = alter_subreg (XEXP (SET_SRC (body), 0));\n+\t\tif (GET_CODE (XEXP (SET_SRC (body), 1)) == SUBREG)\n+\t\t  XEXP (SET_SRC (body), 1)\n+\t\t    = alter_subreg (XEXP (SET_SRC (body), 1));\n+\t      }\n+\t    if ((cc_status.value1 != 0\n+\t\t && rtx_equal_p (SET_SRC (body), cc_status.value1))\n+\t\t|| (cc_status.value2 != 0\n+\t\t    && rtx_equal_p (SET_SRC (body), cc_status.value2)))\n+\t      {\n+\t\t/* Don't delete insn if it has an addressing side-effect.  */\n+\t\tif (! FIND_REG_INC_NOTE (insn, 0)\n+\t\t    /* or if anything in it is volatile.  */\n+\t\t    && ! volatile_refs_p (PATTERN (insn)))\n+\t\t  {\n+\t\t    /* We don't really delete the insn; just ignore it.  */\n+\t\t    last_ignored_compare = insn;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t  }\n+#endif\n+\n+\t/* Following a conditional branch, we have a new basic block.  */\n+\tif ((GET_CODE (insn) == JUMP_INSN && GET_CODE (body) == SET\n+\t     && GET_CODE (SET_SRC (body)) != LABEL_REF)\n+\t    || (GET_CODE (insn) == JUMP_INSN && GET_CODE (body) == PARALLEL\n+\t\t&& GET_CODE (XVECEXP (body, 0, 0)) == SET\n+\t\t&& GET_CODE (SET_SRC (XVECEXP (body, 0, 0))) != LABEL_REF))\n+\t  new_block = 1;\n+\n+#ifndef STACK_REGS\n+\t/* Don't bother outputting obvious no-ops, even without -O.\n+\t   This optimization is fast and doesn't interfere with debugging.\n+\t   Don't do this if the insn is in a delay slot, since this\n+\t   will cause an improper number of delay insns to be written.  */\n+\tif (final_sequence == 0\n+\t    && prescan >= 0\n+\t    && GET_CODE (insn) == INSN && GET_CODE (body) == SET\n+\t    && GET_CODE (SET_SRC (body)) == REG\n+\t    && GET_CODE (SET_DEST (body)) == REG\n+\t    && REGNO (SET_SRC (body)) == REGNO (SET_DEST (body)))\n+\t  break;\n+#endif\n+\n+#ifdef HAVE_cc0\n+\t/* If this is a conditional branch, maybe modify it\n+\t   if the cc's are in a nonstandard state\n+\t   so that it accomplishes the same thing that it would\n+\t   do straightforwardly if the cc's were set up normally.  */\n+\n+\tif (cc_status.flags != 0\n+\t    && GET_CODE (insn) == JUMP_INSN\n+\t    && GET_CODE (body) == SET\n+\t    && SET_DEST (body) == pc_rtx\n+\t    && GET_CODE (SET_SRC (body)) == IF_THEN_ELSE\n+\t    /* This is done during prescan; it is not done again\n+\t       in final scan when prescan has been done.  */\n+\t    && prescan >= 0)\n+\t  {\n+\t    /* This function may alter the contents of its argument\n+\t       and clear some of the cc_status.flags bits.\n+\t       It may also return 1 meaning condition now always true\n+\t       or -1 meaning condition now always false\n+\t       or 2 meaning condition nontrivial but altered.  */\n+\t    register int result = alter_cond (XEXP (SET_SRC (body), 0));\n+\t    /* If condition now has fixed value, replace the IF_THEN_ELSE\n+\t       with its then-operand or its else-operand.  */\n+\t    if (result == 1)\n+\t      SET_SRC (body) = XEXP (SET_SRC (body), 1);\n+\t    if (result == -1)\n+\t      SET_SRC (body) = XEXP (SET_SRC (body), 2);\n+\n+\t    /* The jump is now either unconditional or a no-op.\n+\t       If it has become a no-op, don't try to output it.\n+\t       (It would not be recognized.)  */\n+\t    if (SET_SRC (body) == pc_rtx)\n+\t      {\n+\t\tPUT_CODE (insn, NOTE);\n+\t\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t\tNOTE_SOURCE_FILE (insn) = 0;\n+\t\tbreak;\n+\t      }\n+\t    else if (GET_CODE (SET_SRC (body)) == RETURN)\n+\t      /* Replace (set (pc) (return)) with (return).  */\n+\t      PATTERN (insn) = body = SET_SRC (body);\n+\n+\t    /* Rerecognize the instruction if it has changed.  */\n+\t    if (result != 0)\n+\t      INSN_CODE (insn) = -1;\n+\t  }\n+\n+\t/* Make same adjustments to instructions that examine the\n+\t   condition codes without jumping (if this machine has them).  */\n+\n+\tif (cc_status.flags != 0\n+\t    && GET_CODE (body) == SET)\n+\t  {\n+\t    switch (GET_CODE (SET_SRC (body)))\n+\t      {\n+\t      case GTU:\n+\t      case GT:\n+\t      case LTU:\n+\t      case LT:\n+\t      case GEU:\n+\t      case GE:\n+\t      case LEU:\n+\t      case LE:\n+\t      case EQ:\n+\t      case NE:\n+\t\t{\n+\t\t  register int result;\n+\t\t  if (XEXP (SET_SRC (body), 0) != cc0_rtx)\n+\t\t    break;\n+\t\t  result = alter_cond (SET_SRC (body));\n+\t\t  if (result == 1)\n+\t\t    validate_change (insn, &SET_SRC (body), const_true_rtx, 0);\n+\t\t  else if (result == -1)\n+\t\t    validate_change (insn, &SET_SRC (body), const0_rtx, 0);\n+\t\t  else if (result == 2)\n+\t\t    INSN_CODE (insn) = -1;\n+\t\t}\n+\t      }\n+\t  }\n+#endif\n+\n+\t/* Do machine-specific peephole optimizations if desired.  */\n+\n+\tif (optimize && !flag_no_peephole && !nopeepholes)\n+\t  {\n+\t    rtx next = peephole (insn);\n+\t    /* When peepholing, if there were notes within the peephole,\n+\t       emit them before the peephole.  */\n+\t    if (next != 0 && next != NEXT_INSN (insn))\n+\t      {\n+\t\trtx prev = PREV_INSN (insn);\n+\t\trtx note;\n+\n+\t\tfor (note = NEXT_INSN (insn); note != next;\n+\t\t     note = NEXT_INSN (note))\n+\t\t  final_scan_insn (note, file, optimize, prescan, nopeepholes);\n+\n+\t\t/* In case this is prescan, put the notes\n+\t\t   in proper position for later rescan.  */\n+\t\tnote = NEXT_INSN (insn);\n+\t\tPREV_INSN (note) = prev;\n+\t\tNEXT_INSN (prev) = note;\n+\t\tNEXT_INSN (PREV_INSN (next)) = insn;\n+\t\tPREV_INSN (insn) = PREV_INSN (next);\n+\t\tNEXT_INSN (insn) = next;\n+\t\tPREV_INSN (next) = insn;\n+\t      }\n+\n+\t    /* PEEPHOLE might have changed this.  */\n+\t    body = PATTERN (insn);\n+\t  }\n+\n+\t/* Try to recognize the instruction.\n+\t   If successful, verify that the operands satisfy the\n+\t   constraints for the instruction.  Crash if they don't,\n+\t   since `reload' should have changed them so that they do.  */\n+\n+\tinsn_code_number = recog_memoized (insn);\n+\tinsn_extract (insn);\n+\tfor (i = 0; i < insn_n_operands[insn_code_number]; i++)\n+\t  {\n+\t    if (GET_CODE (recog_operand[i]) == SUBREG)\n+\t      recog_operand[i] = alter_subreg (recog_operand[i]);\n+\t  }\n+\n+#ifdef REGISTER_CONSTRAINTS\n+\tif (! constrain_operands (insn_code_number, 1))\n+\t  fatal_insn_not_found (insn);\n+#endif\n+\n+\t/* Some target machines need to prescan each insn before\n+\t   it is output.  */\n+\n+#ifdef FINAL_PRESCAN_INSN\n+\tFINAL_PRESCAN_INSN (insn, recog_operand,\n+\t\t\t    insn_n_operands[insn_code_number]);\n+#endif\n+\n+#ifdef HAVE_cc0\n+\tcc_prev_status = cc_status;\n+\n+\t/* Update `cc_status' for this instruction.\n+\t   The instruction's output routine may change it further.\n+\t   If the output routine for a jump insn needs to depend\n+\t   on the cc status, it should look at cc_prev_status.  */\n+\n+\tNOTICE_UPDATE_CC (body, insn);\n+#endif\n+\n+\tdebug_insn = insn;\n+\n+\t/* If the proper template needs to be chosen by some C code,\n+\t   run that code and get the real template.  */\n+\n+\ttemplate = insn_template[insn_code_number];\n+\tif (template == 0)\n+\t  {\n+\t    template = (*insn_outfun[insn_code_number]) (recog_operand, insn);\n+\n+\t    /* If the C code returns 0, it means that it is a jump insn\n+\t       which follows a deleted test insn, and that test insn\n+\t       needs to be reinserted.  */\n+\t    if (template == 0)\n+\t      {\n+\t\tif (prev_nonnote_insn (insn) != last_ignored_compare)\n+\t\t  abort ();\n+\t\tnew_block = 0;\n+\t\treturn prev_nonnote_insn (insn);\n+\t      }\n+\t  }\n+\n+\t/* If the template is the string \"#\", it means that this insn must\n+\t   be split.  */\n+\tif (template[0] == '#' && template[1] == '\\0')\n+\t  {\n+\t    rtx new = try_split (body, insn, 0);\n+\n+\t    /* If we didn't split the insn, go away.  */\n+\t    if (new == insn && PATTERN (new) == body)\n+\t      abort ();\n+\t      \n+\t    new_block = 0;\n+\t    return new;\n+\t  }\n+\t\n+\tif (prescan > 0)\n+\t  break;\n+\n+\t/* Output assembler code from the template.  */\n+\n+\toutput_asm_insn (template, recog_operand);\n+\n+#if 0\n+\t/* It's not at all clear why we did this and doing so interferes\n+\t   with tests we'd like to do to use REG_WAS_0 notes, so let's try\n+\t   with this out.  */\n+\n+\t/* Mark this insn as having been output.  */\n+\tINSN_DELETED_P (insn) = 1;\n+#endif\n+\n+\tdebug_insn = 0;\n+      }\n+    }\n+  return NEXT_INSN (insn);\n+}\n+\f\n+/* Output debugging info to the assembler file FILE\n+   based on the NOTE-insn INSN, assumed to be a line number.  */\n+\n+static void\n+output_source_line (file, insn)\n+     FILE *file;\n+     rtx insn;\n+{\n+  char ltext_label_name[100];\n+  register char *filename = NOTE_SOURCE_FILE (insn);\n+\n+  last_linenum = NOTE_LINE_NUMBER (insn);\n+\n+  if (write_symbols != NO_DEBUG)\n+    {\n+#ifdef SDB_DEBUGGING_INFO\n+      if (write_symbols == SDB_DEBUG\n+#if 0 /* People like having line numbers even in wrong file!  */\n+\t  /* COFF can't handle multiple source files--lose, lose.  */\n+\t  && !strcmp (filename, main_input_filename)\n+#endif\n+\t  /* COFF relative line numbers must be positive.  */\n+\t  && last_linenum > sdb_begin_function_line)\n+\t{\n+#ifdef ASM_OUTPUT_SOURCE_LINE\n+\t  ASM_OUTPUT_SOURCE_LINE (file, last_linenum);\n+#else\n+\t  fprintf (file, \"\\t.ln\\t%d\\n\",\n+\t\t   ((sdb_begin_function_line > -1)\n+\t\t    ? last_linenum - sdb_begin_function_line : 1));\n+#endif\n+\t}\n+#endif\n+\n+#if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n+      if (write_symbols == DBX_DEBUG || write_symbols == XCOFF_DEBUG)\n+\t{\n+\t  dbxout_source_file (file, filename);\n+\n+#ifdef ASM_OUTPUT_SOURCE_LINE\n+\t  ASM_OUTPUT_SOURCE_LINE (file, NOTE_LINE_NUMBER (insn));\n+#else\n+\t  fprintf (file, \"\\t%s %d,0,%d\\n\", ASM_STABD_OP, \n+\t\t   N_SLINE, NOTE_LINE_NUMBER (insn));\n+#endif\n+\t}\n+#endif /* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */\n+\n+#ifdef DWARF_DEBUGGING_INFO\n+      if (write_symbols == DWARF_DEBUG)\n+\tdwarfout_line (filename, NOTE_LINE_NUMBER (insn));\n+#endif\n+    }\n+}\n+\f\n+/* If X is a SUBREG, replace it with a REG or a MEM,\n+   based on the thing it is a subreg of.  */\n+\n+rtx\n+alter_subreg (x)\n+     register rtx x;\n+{\n+  register rtx y = SUBREG_REG (x);\n+  if (GET_CODE (y) == SUBREG)\n+    y = alter_subreg (y);\n+\n+  if (GET_CODE (y) == REG)\n+    {\n+      /* If the containing reg really gets a hard reg, so do we.  */\n+      PUT_CODE (x, REG);\n+      REGNO (x) = REGNO (y) + SUBREG_WORD (x);\n+    }\n+  else if (GET_CODE (y) == MEM)\n+    {\n+      register int offset = SUBREG_WORD (x) * UNITS_PER_WORD;\n+#if BYTES_BIG_ENDIAN\n+      offset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x)))\n+\t\t - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (y))));\n+#endif\n+      PUT_CODE (x, MEM);\n+      MEM_VOLATILE_P (x) = MEM_VOLATILE_P (y);\n+      XEXP (x, 0) = plus_constant (XEXP (y, 0), offset);\n+    }\n+\n+  return x;\n+}\n+\n+/* Do alter_subreg on all the SUBREGs contained in X.  */\n+\n+static rtx\n+walk_alter_subreg (x)\n+     rtx x;\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case PLUS:\n+    case MULT:\n+      XEXP (x, 0) = walk_alter_subreg (XEXP (x, 0));\n+      XEXP (x, 1) = walk_alter_subreg (XEXP (x, 1));\n+      break;\n+\n+    case MEM:\n+      XEXP (x, 0) = walk_alter_subreg (XEXP (x, 0));\n+      break;\n+\n+    case SUBREG:\n+      return alter_subreg (x);\n+    }\n+\n+  return x;\n+}\n+\f\n+#ifdef HAVE_cc0\n+\n+/* Given BODY, the body of a jump instruction, alter the jump condition\n+   as required by the bits that are set in cc_status.flags.\n+   Not all of the bits there can be handled at this level in all cases.\n+\n+   The value is normally 0.\n+   1 means that the condition has become always true.\n+   -1 means that the condition has become always false.\n+   2 means that COND has been altered.  */\n+\n+static int\n+alter_cond (cond)\n+     register rtx cond;\n+{\n+  int value = 0;\n+\n+  if (cc_status.flags & CC_REVERSED)\n+    {\n+      value = 2;\n+      PUT_CODE (cond, swap_condition (GET_CODE (cond)));\n+    }\n+\n+  if (cc_status.flags & CC_INVERTED)\n+    {\n+      value = 2;\n+      PUT_CODE (cond, reverse_condition (GET_CODE (cond)));\n+    }\n+\n+  if (cc_status.flags & CC_NOT_POSITIVE)\n+    switch (GET_CODE (cond))\n+      {\n+      case LE:\n+      case LEU:\n+      case GEU:\n+\t/* Jump becomes unconditional.  */\n+\treturn 1;\n+\n+      case GT:\n+      case GTU:\n+      case LTU:\n+\t/* Jump becomes no-op.  */\n+\treturn -1;\n+\n+      case GE:\n+\tPUT_CODE (cond, EQ);\n+\tvalue = 2;\n+\tbreak;\n+\n+      case LT:\n+\tPUT_CODE (cond, NE);\n+\tvalue = 2;\n+\tbreak;\n+      }\n+\n+  if (cc_status.flags & CC_NOT_NEGATIVE)\n+    switch (GET_CODE (cond))\n+      {\n+      case GE:\n+      case GEU:\n+\t/* Jump becomes unconditional.  */\n+\treturn 1;\n+\n+      case LT:\n+      case LTU:\n+\t/* Jump becomes no-op.  */\n+\treturn -1;\n+\n+      case LE:\n+      case LEU:\n+\tPUT_CODE (cond, EQ);\n+\tvalue = 2;\n+\tbreak;\n+\n+      case GT:\n+      case GTU:\n+\tPUT_CODE (cond, NE);\n+\tvalue = 2;\n+\tbreak;\n+      }\n+\n+  if (cc_status.flags & CC_NO_OVERFLOW)\n+    switch (GET_CODE (cond))\n+      {\n+      case GEU:\n+\t/* Jump becomes unconditional.  */\n+\treturn 1;\n+\n+      case LEU:\n+\tPUT_CODE (cond, EQ);\n+\tvalue = 2;\n+\tbreak;\n+\n+      case GTU:\n+\tPUT_CODE (cond, NE);\n+\tvalue = 2;\n+\tbreak;\n+\n+      case LTU:\n+\t/* Jump becomes no-op.  */\n+\treturn -1;\n+      }\n+\n+  if (cc_status.flags & (CC_Z_IN_NOT_N | CC_Z_IN_N))\n+    switch (GET_CODE (cond))\n+      {\n+      case LE:\n+      case LEU:\n+      case GE:\n+      case GEU:\n+      case LT:\n+      case LTU:\n+      case GT:\n+      case GTU:\n+\tabort ();\n+\n+      case NE:\n+\tPUT_CODE (cond, cc_status.flags & CC_Z_IN_N ? GE : LT);\n+\tvalue = 2;\n+\tbreak;\n+\n+      case EQ:\n+\tPUT_CODE (cond, cc_status.flags & CC_Z_IN_N ? LT : GE);\n+\tvalue = 2;\n+\tbreak;\n+      }\n+  \n+  return value;\n+}\n+#endif\n+\f\n+/* Report inconsistency between the assembler template and the operands.\n+   In an `asm', it's the user's fault; otherwise, the compiler's fault.  */\n+\n+void\n+output_operand_lossage (str)\n+     char *str;\n+{\n+  if (this_is_asm_operands)\n+    error_for_asm (this_is_asm_operands, \"invalid `asm': %s\", str);\n+  else\n+    abort ();\n+}\n+\f\n+/* Output of assembler code from a template, and its subroutines.  */\n+\n+/* Output text from TEMPLATE to the assembler output file,\n+   obeying %-directions to substitute operands taken from\n+   the vector OPERANDS.\n+\n+   %N (for N a digit) means print operand N in usual manner.\n+   %lN means require operand N to be a CODE_LABEL or LABEL_REF\n+      and print the label name with no punctuation.\n+   %cN means require operand N to be a constant\n+      and print the constant expression with no punctuation.\n+   %aN means expect operand N to be a memory address\n+      (not a memory reference!) and print a reference\n+      to that address.\n+   %nN means expect operand N to be a constant\n+      and print a constant expression for minus the value\n+      of the operand, with no other punctuation.  */\n+\n+void\n+output_asm_insn (template, operands)\n+     char *template;\n+     rtx *operands;\n+{\n+  register char *p;\n+  register int c;\n+\n+  /* An insn may return a null string template\n+     in a case where no assembler code is needed.  */\n+  if (*template == 0)\n+    return;\n+\n+  p = template;\n+  putc ('\\t', asm_out_file);\n+\n+#ifdef ASM_OUTPUT_OPCODE\n+  ASM_OUTPUT_OPCODE (asm_out_file, p);\n+#endif\n+\n+  while (c = *p++)\n+    {\n+#ifdef ASM_OUTPUT_OPCODE\n+      if (c == '\\n')\n+\t{\n+\t  putc (c, asm_out_file);\n+\t  while ((c = *p) == '\\t')\n+\t    {\n+\t      putc (c, asm_out_file);\n+\t      p++;\n+\t    }\n+\t  ASM_OUTPUT_OPCODE (asm_out_file, p);\n+\t}\n+      else\n+#endif\n+      if (c != '%')\n+\tputc (c, asm_out_file);\n+      else\n+\t{\n+\t  /* %% outputs a single %.  */\n+\t  if (*p == '%')\n+\t    {\n+\t      p++;\n+\t      putc (c, asm_out_file);\n+\t    }\n+\t  /* %= outputs a number which is unique to each insn in the entire\n+\t     compilation.  This is useful for making local labels that are\n+\t     referred to more than once in a given insn.  */\n+\t  else if (*p == '=')\n+\t    fprintf (asm_out_file, \"%d\", insn_counter);\n+\t  /* % followed by a letter and some digits\n+\t     outputs an operand in a special way depending on the letter.\n+\t     Letters `acln' are implemented directly.\n+\t     Other letters are passed to `output_operand' so that\n+\t     the PRINT_OPERAND macro can define them.  */\n+\t  else if ((*p >= 'a' && *p <= 'z')\n+\t\t   || (*p >= 'A' && *p <= 'Z'))\n+\t    {\n+\t      int letter = *p++;\n+\t      c = atoi (p);\n+\n+\t      if (! (*p >= '0' && *p <= '9'))\n+\t\toutput_operand_lossage (\"operand number missing after %-letter\");\n+\t      else if (this_is_asm_operands && c >= (unsigned) insn_noperands)\n+\t\toutput_operand_lossage (\"operand number out of range\");\n+\t      else if (letter == 'l')\n+\t\toutput_asm_label (operands[c]);\n+\t      else if (letter == 'a')\n+\t\toutput_address (operands[c]);\n+\t      else if (letter == 'c')\n+\t\t{\n+\t\t  if (CONSTANT_ADDRESS_P (operands[c]))\n+\t\t    output_addr_const (asm_out_file, operands[c]);\n+\t\t  else\n+\t\t    output_operand (operands[c], 'c');\n+\t\t}\n+\t      else if (letter == 'n')\n+\t\t{\n+\t\t  if (GET_CODE (operands[c]) == CONST_INT)\n+\t\t    fprintf (asm_out_file, \"%d\", - INTVAL (operands[c]));\n+\t\t  else\n+\t\t    {\n+\t\t      putc ('-', asm_out_file);\n+\t\t      output_addr_const (asm_out_file, operands[c]);\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\toutput_operand (operands[c], letter);\n+\n+\t      while ((c = *p) >= '0' && c <= '9') p++;\n+\t    }\n+\t  /* % followed by a digit outputs an operand the default way.  */\n+\t  else if (*p >= '0' && *p <= '9')\n+\t    {\n+\t      c = atoi (p);\n+\t      if (this_is_asm_operands && c >= (unsigned) insn_noperands)\n+\t\toutput_operand_lossage (\"operand number out of range\");\n+\t      else\n+\t\toutput_operand (operands[c], 0);\n+\t      while ((c = *p) >= '0' && c <= '9') p++;\n+\t    }\n+\t  /* % followed by punctuation: output something for that\n+\t     punctuation character alone, with no operand.\n+\t     The PRINT_OPERAND macro decides what is actually done.  */\n+#ifdef PRINT_OPERAND_PUNCT_VALID_P\n+\t  else if (PRINT_OPERAND_PUNCT_VALID_P (*p))\n+\t    output_operand (0, *p++);\n+#endif\n+\t  else\n+\t    output_operand_lossage (\"invalid %%-code\");\n+\t}\n+    }\n+\n+  if (flag_print_asm_name)\n+    {\n+      /* Annotate the assembly with a comment describing the pattern and\n+\t alternative used.  */\n+      if (debug_insn)\n+\t{\n+\t  register int num = INSN_CODE (debug_insn);\n+\t  fprintf (asm_out_file, \" %s %d %s\", \n+\t\t   ASM_COMMENT_START, INSN_UID (debug_insn), insn_name[num]);\n+\t  if (insn_n_alternatives[num] > 1)\n+\t    fprintf (asm_out_file, \"/%d\", which_alternative + 1);\n+\n+\t  /* Clear this so only the first assembler insn\n+\t     of any rtl insn will get the special comment for -dp.  */\n+\t  debug_insn = 0;\n+\t}\n+    }\n+\n+  putc ('\\n', asm_out_file);\n+}\n+\f\n+/* Output a LABEL_REF, or a bare CODE_LABEL, as an assembler symbol.  */\n+\n+void\n+output_asm_label (x)\n+     rtx x;\n+{\n+  char buf[256];\n+\n+  if (GET_CODE (x) == LABEL_REF)\n+    ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", CODE_LABEL_NUMBER (XEXP (x, 0)));\n+  else if (GET_CODE (x) == CODE_LABEL)\n+    ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", CODE_LABEL_NUMBER (x));\n+  else\n+    output_operand_lossage (\"`%l' operand isn't a label\");\n+\n+  assemble_name (asm_out_file, buf);\n+}\n+\n+/* Print operand X using machine-dependent assembler syntax.\n+   The macro PRINT_OPERAND is defined just to control this function.\n+   CODE is a non-digit that preceded the operand-number in the % spec,\n+   such as 'z' if the spec was `%z3'.  CODE is 0 if there was no char\n+   between the % and the digits.\n+   When CODE is a non-letter, X is 0.\n+\n+   The meanings of the letters are machine-dependent and controlled\n+   by PRINT_OPERAND.  */\n+\n+static void\n+output_operand (x, code)\n+     rtx x;\n+     int code;\n+{\n+  if (x && GET_CODE (x) == SUBREG)\n+    x = alter_subreg (x);\n+  PRINT_OPERAND (asm_out_file, x, code);\n+}\n+\n+/* Print a memory reference operand for address X\n+   using machine-dependent assembler syntax.\n+   The macro PRINT_OPERAND_ADDRESS exists just to control this function.  */\n+\n+void\n+output_address (x)\n+     rtx x;\n+{\n+  walk_alter_subreg (x);\n+  PRINT_OPERAND_ADDRESS (asm_out_file, x);\n+}\n+\f\n+/* Print an integer constant expression in assembler syntax.\n+   Addition and subtraction are the only arithmetic\n+   that may appear in these expressions.  */\n+\n+void\n+output_addr_const (file, x)\n+     FILE *file;\n+     rtx x;\n+{\n+  char buf[256];\n+\n+ restart:\n+  switch (GET_CODE (x))\n+    {\n+    case PC:\n+      if (flag_pic)\n+\tputc ('.', file);\n+      else\n+\tabort ();\n+      break;\n+\n+    case SYMBOL_REF:\n+      assemble_name (file, XSTR (x, 0));\n+      break;\n+\n+    case LABEL_REF:\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", CODE_LABEL_NUMBER (XEXP (x, 0)));\n+      assemble_name (asm_out_file, buf);\n+      break;\n+\n+    case CODE_LABEL:\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", CODE_LABEL_NUMBER (x));\n+      assemble_name (asm_out_file, buf);\n+      break;\n+\n+    case CONST_INT:\n+      fprintf (file, \"%d\", INTVAL (x));\n+      break;\n+\n+    case CONST:\n+      /* This used to output parentheses around the expression,\n+\t but that does not work on the 386 (either ATT or BSD assembler).  */\n+      output_addr_const (file, XEXP (x, 0));\n+      break;\n+\n+    case CONST_DOUBLE:\n+      if (GET_MODE (x) == VOIDmode)\n+\t{\n+\t  /* We can use %d if the number is <32 bits and positive.  */\n+\t  if (CONST_DOUBLE_HIGH (x) || CONST_DOUBLE_LOW (x) < 0)\n+\t    fprintf (file, \"0x%x%08x\",\n+\t\t     CONST_DOUBLE_HIGH (x), CONST_DOUBLE_LOW (x));\n+\t  else\n+\t    fprintf (file, \"%d\", CONST_DOUBLE_LOW (x));\n+\t}\n+      else\n+\t/* We can't handle floating point constants;\n+\t   PRINT_OPERAND must handle them.  */\n+\toutput_operand_lossage (\"floating constant misused\");\n+      break;\n+\n+    case PLUS:\n+      /* Some assemblers need integer constants to appear last (eg masm).  */\n+      if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n+\t{\n+\t  output_addr_const (file, XEXP (x, 1));\n+\t  if (INTVAL (XEXP (x, 0)) >= 0)\n+\t    fprintf (file, \"+\");\n+\t  output_addr_const (file, XEXP (x, 0));\n+\t}\n+      else\n+\t{\n+\t  output_addr_const (file, XEXP (x, 0));\n+\t  if (INTVAL (XEXP (x, 1)) >= 0)\n+\t    fprintf (file, \"+\");\n+\t  output_addr_const (file, XEXP (x, 1));\n+\t}\n+      break;\n+\n+    case MINUS:\n+      output_addr_const (file, XEXP (x, 0));\n+      fprintf (file, \"-\");\n+      output_addr_const (file, XEXP (x, 1));\n+      break;\n+\n+    default:\n+      output_operand_lossage (\"invalid expression as operand\");\n+    }\n+}\n+\f\n+/* A poor man's fprintf, with the added features of %I, %R, %L, and %U.\n+   %R prints the value of REGISTER_PREFIX.\n+   %L prints the value of LOCAL_LABEL_PREFIX.\n+   %U prints the value of USER_LABEL_PREFIX.\n+   %I prints the value of IMMEDIATE_PREFIX.\n+   %O runs ASM_OUTPUT_OPCODE to transform what follows in the string.\n+   Also supported are %d, %x, %s, %e, %f, %g and %%.  */\n+\n+void\n+asm_fprintf (va_alist)\n+     va_dcl\n+{\n+  va_list argptr;\n+  FILE *file;\n+  char buf[10];\n+  char *p, *q, c;\n+\n+  va_start (argptr);\n+\n+  file = va_arg (argptr, FILE *);\n+  p = va_arg (argptr, char *);\n+  buf[0] = '%';\n+\n+  while (c = *p++)\n+    switch (c)\n+      {\n+      case '%':\n+\tc = *p++;\n+\tq = &buf[1];\n+\twhile ((c >= '0' && c <= '9') || c == '.')\n+\t  {\n+\t    *q++ = c;\n+\t    c = *p++;\n+\t  }\n+\tswitch (c)\n+\t  {\n+\t  case '%':\n+\t    fprintf (file, \"%%\");\n+\t    break;\n+\n+\t  case 'd':  case 'i':  case 'u':\n+\t  case 'x':  case 'p':  case 'X':\n+\t  case 'o':\n+\t    *q++ = c;\n+\t    *q = 0;\n+\t    fprintf (file, buf, va_arg (argptr, int));\n+\t    break;\n+\n+\t  case 'e':\n+\t  case 'f':\n+\t  case 'g':\n+\t    *q++ = c;\n+\t    *q = 0;\n+\t    fprintf (file, buf, va_arg (argptr, double));\n+\t    break;\n+\n+\t  case 's':\n+\t    *q++ = c;\n+\t    *q = 0;\n+\t    fprintf (file, buf, va_arg (argptr, char *));\n+\t    break;\n+\n+\t  case 'O':\n+#ifdef ASM_OUTPUT_OPCODE\n+\t    ASM_OUTPUT_OPCODE (asm_out_file, p);\n+#endif\n+\t    break;\n+\n+\t  case 'R':\n+#ifdef REGISTER_PREFIX\n+\t    fprintf (file, \"%s\", REGISTER_PREFIX);\n+#endif\n+\t    break;\n+\n+\t  case 'I':\n+#ifdef IMMEDIATE_PREFIX\n+\t    fprintf (file, \"%s\", IMMEDIATE_PREFIX);\n+#endif\n+\t    break;\n+\n+\t  case 'L':\n+#ifdef LOCAL_LABEL_PREFIX\n+\t    fprintf (file, \"%s\", LOCAL_LABEL_PREFIX);\n+#endif\n+\t    break;\n+\n+\t  case 'U':\n+#ifdef USER_LABEL_PREFIX\n+\t    fprintf (file, \"%s\", USER_LABEL_PREFIX);\n+#endif\n+\t    break;\n+\n+\t  default:\n+\t    abort ();\n+\t  }\n+\tbreak;\n+\n+      default:\n+\tfputc (c, file);\n+      }\n+}\n+\f\n+/* Split up a CONST_DOUBLE or integer constant rtx\n+   into two rtx's for single words,\n+   storing in *FIRST the word that comes first in memory in the target\n+   and in *SECOND the other.  */\n+\n+void\n+split_double (value, first, second)\n+     rtx value;\n+     rtx *first, *second;\n+{\n+  if (GET_CODE (value) == CONST_INT)\n+    {\n+      /* The rule for using CONST_INT for a wider mode\n+\t is that we regard the value as signed.\n+\t So sign-extend it.  */\n+      rtx high = (INTVAL (value) < 0 ? constm1_rtx : const0_rtx);\n+#if WORDS_BIG_ENDIAN\n+      *first = high;\n+      *second = value;\n+#else\n+      *first = value;\n+      *second = high;\n+#endif\n+    }\n+  else if (GET_CODE (value) != CONST_DOUBLE)\n+    {\n+#if WORDS_BIG_ENDIAN\n+      *first = const0_rtx;\n+      *second = value;\n+#else\n+      *first = value;\n+      *second = const0_rtx;\n+#endif\n+    }\n+  else if (GET_MODE (value) == VOIDmode\n+\t   /* This is the old way we did CONST_DOUBLE integers.  */\n+\t   || GET_MODE_CLASS (GET_MODE (value)) == MODE_INT)\n+    {\n+      /* In an integer, the words are defined as most and least significant.\n+\t So order them by the target's convention.  */\n+#if WORDS_BIG_ENDIAN\n+      *first = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_HIGH (value));\n+      *second = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_LOW (value));\n+#else\n+      *first = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_LOW (value));\n+      *second = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_HIGH (value));\n+#endif\n+    }\n+  else\n+    {\n+      if ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n+\t   || HOST_BITS_PER_INT != BITS_PER_WORD)\n+\t  && ! flag_pretend_float)\n+      abort ();\n+\n+#if defined (HOST_WORDS_BIG_ENDIAN) == WORDS_BIG_ENDIAN\n+      /* Host and target agree => no need to swap.  */\n+      *first = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_LOW (value));\n+      *second = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_HIGH (value));\n+#else\n+      *second = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_LOW (value));\n+      *first = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_HIGH (value));\n+#endif\n+    }\n+}\n+\f\n+/* Return nonzero if this function has no function calls.  */\n+\n+int\n+leaf_function_p ()\n+{\n+  rtx insn;\n+\n+  if (profile_flag || profile_block_flag)\n+    return 0;\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == CALL_INSN)\n+\treturn 0;\n+      if (GET_CODE (insn) == INSN\n+\t  && GET_CODE (PATTERN (insn)) == SEQUENCE\n+\t  && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == CALL_INSN)\n+\treturn 0;\n+    }\n+  for (insn = current_function_epilogue_delay_list; insn; insn = XEXP (insn, 1))\n+    {\n+      if (GET_CODE (XEXP (insn, 0)) == CALL_INSN)\n+\treturn 0;\n+      if (GET_CODE (XEXP (insn, 0)) == INSN\n+\t  && GET_CODE (PATTERN (XEXP (insn, 0))) == SEQUENCE\n+\t  && GET_CODE (XVECEXP (PATTERN (XEXP (insn, 0)), 0, 0)) == CALL_INSN)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* On some machines, a function with no call insns\n+   can run faster if it doesn't create its own register window.\n+   When output, the leaf function should use only the \"output\"\n+   registers.  Ordinarily, the function would be compiled to use\n+   the \"input\" registers to find its arguments; it is a candidate\n+   for leaf treatment if it uses only the \"input\" registers.\n+   Leaf function treatment means renumbering so the function\n+   uses the \"output\" registers instead.  */\n+\n+#ifdef LEAF_REGISTERS\n+\n+static char permitted_reg_in_leaf_functions[] = LEAF_REGISTERS;\n+\n+/* Return 1 if this function uses only the registers that can be\n+   safely renumbered.  */\n+\n+int\n+only_leaf_regs_used ()\n+{\n+  int i;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (regs_ever_live[i] > permitted_reg_in_leaf_functions[i])\n+\treturn 0;\n+    }\n+  return 1;\n+}\n+\n+/* Scan all instructions and renumber all registers into those\n+   available in leaf functions.  */\n+\n+static void\n+leaf_renumber_regs (first)\n+     rtx first;\n+{\n+  rtx insn;\n+\n+  /* Renumber only the actual patterns.\n+     The reg-notes can contain frame pointer refs,\n+     and renumbering them could crash, and should not be needed.  */\n+  for (insn = first; insn; insn = NEXT_INSN (insn))\n+    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+      leaf_renumber_regs_insn (PATTERN (insn));\n+  for (insn = current_function_epilogue_delay_list; insn; insn = XEXP (insn, 1))\n+    if (GET_RTX_CLASS (GET_CODE (XEXP (insn, 0))) == 'i')\n+      leaf_renumber_regs_insn (PATTERN (XEXP (insn, 0)));\n+}\n+\n+/* Scan IN_RTX and its subexpressions, and renumber all regs into those\n+   available in leaf functions.  */\n+\n+void\n+leaf_renumber_regs_insn (in_rtx)\n+     register rtx in_rtx;\n+{\n+  register int i, j;\n+  register char *format_ptr;\n+\n+  if (in_rtx == 0)\n+    return;\n+\n+  /* Renumber all input-registers into output-registers.\n+     renumbered_regs would be 1 for an output-register;\n+     they  */\n+\n+  if (GET_CODE (in_rtx) == REG)\n+    {\n+      int newreg;\n+\n+      /* Don't renumber the same reg twice.  */\n+      if (in_rtx->used)\n+\treturn;\n+\n+      newreg = REGNO (in_rtx);\n+      /* Don't try to renumber pseudo regs.  It is possible for a pseudo reg\n+\t to reach here as part of a REG_NOTE.  */\n+      if (newreg >= FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  in_rtx->used = 1;\n+\t  return;\n+\t}\n+      newreg = LEAF_REG_REMAP (newreg);\n+      if (newreg < 0)\n+\tabort ();\n+      regs_ever_live[REGNO (in_rtx)] = 0;\n+      regs_ever_live[newreg] = 1;\n+      REGNO (in_rtx) = newreg;\n+      in_rtx->used = 1;\n+    }\n+\n+  if (GET_RTX_CLASS (GET_CODE (in_rtx)) == 'i')\n+    {\n+      /* Inside a SEQUENCE, we find insns.\n+\t Renumber just the patterns of these insns,\n+\t just as we do for the top-level insns.  */\n+      leaf_renumber_regs_insn (PATTERN (in_rtx));\n+      return;\n+    }\n+\n+  format_ptr = GET_RTX_FORMAT (GET_CODE (in_rtx));\n+\n+  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (in_rtx)); i++)\n+    switch (*format_ptr++)\n+      {\n+      case 'e':\n+\tleaf_renumber_regs_insn (XEXP (in_rtx, i));\n+\tbreak;\n+\n+      case 'E':\n+\tif (NULL != XVEC (in_rtx, i))\n+\t  {\n+\t    for (j = 0; j < XVECLEN (in_rtx, i); j++)\n+\t      leaf_renumber_regs_insn (XVECEXP (in_rtx, i, j));\n+\t  }\n+\tbreak;\n+\n+      case 'S':\n+      case 's':\n+      case '0':\n+      case 'i':\n+      case 'n':\n+      case 'u':\n+\tbreak;\n+\n+      default:\n+\tabort ();\n+      }\n+}\n+#endif"}]}