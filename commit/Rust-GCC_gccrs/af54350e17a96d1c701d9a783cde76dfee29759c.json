{"sha": "af54350e17a96d1c701d9a783cde76dfee29759c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY1NDM1MGUxN2E5NmQxYzcwMWQ5YTc4M2NkZTc2ZGZlZTI5NzU5Yw==", "commit": {"author": {"name": "David S. Miller", "email": "davem@redhat.com", "date": "2002-05-04T04:21:46Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2002-05-04T04:21:46Z"}, "message": "sparc.h (REG_ALLOC_ORDER, [...]): Tweak, and add more detailed comments.\n\n2002-05-03  David S. Miller  <davem@redhat.com>\n\n\t* config/sparc/sparc.h (REG_ALLOC_ORDER, REG_LEAF_ALLOC_ORDER):\n\tTweak, and add more detailed comments.\n\nFrom-SVN: r53144", "tree": {"sha": "0b7fd4db4a1fe1d45c8be56fb5d552951a23b8b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b7fd4db4a1fe1d45c8be56fb5d552951a23b8b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af54350e17a96d1c701d9a783cde76dfee29759c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af54350e17a96d1c701d9a783cde76dfee29759c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af54350e17a96d1c701d9a783cde76dfee29759c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af54350e17a96d1c701d9a783cde76dfee29759c/comments", "author": null, "committer": null, "parents": [{"sha": "1c177c18164f86bda1fbbd01e23d740319860844", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c177c18164f86bda1fbbd01e23d740319860844", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c177c18164f86bda1fbbd01e23d740319860844"}], "stats": {"total": 92, "additions": 65, "deletions": 27}, "files": [{"sha": "7d887654802e91cae5629b4970397a05fb8642c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af54350e17a96d1c701d9a783cde76dfee29759c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af54350e17a96d1c701d9a783cde76dfee29759c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af54350e17a96d1c701d9a783cde76dfee29759c", "patch": "@@ -1,3 +1,8 @@\n+2002-05-03  David S. Miller  <davem@redhat.com>\n+\n+\t* config/sparc/sparc.h (REG_ALLOC_ORDER, REG_LEAF_ALLOC_ORDER):\n+\tTweak, and add more detailed comments.\n+\n 2002-05-03  Zack Weinberg  <zack@codesourcery.com>\n \n \t* Re-apply patch accidentally reverted with"}, {"sha": "f807be89e54ce4b2691400d4a826508c612e95f0", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 60, "deletions": 27, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af54350e17a96d1c701d9a783cde76dfee29759c/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af54350e17a96d1c701d9a783cde76dfee29759c/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=af54350e17a96d1c701d9a783cde76dfee29759c", "patch": "@@ -1273,47 +1273,80 @@ extern enum reg_class sparc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n \n /* This is the order in which to allocate registers normally.  \n    \n-   We put %f0/%f1 last among the float registers, so as to make it more\n+   We put %f0-%f7 last among the float registers, so as to make it more\n    likely that a pseudo-register which dies in the float return register\n-   will get allocated to the float return register, thus saving a move\n-   instruction at the end of the function.  */\n+   area will get allocated to the float return register, thus saving a move\n+   instruction at the end of the function.\n+\n+   Similarly for integer return value registers.\n+\n+   We know in this case that we will not end up with a leaf function.\n+\n+   The register allocater is given the global and out registers first\n+   because these registers are call clobbered and thus less useful to\n+   global register allocation.\n+\n+   Next we list the local and in registers.  They are not call clobbered\n+   and thus very useful for global register allocation.  We list the input\n+   registers before the locals so that it is more likely the incoming\n+   arguments received in those registers can just stay there and not be\n+   reloaded.  */\n \n #define REG_ALLOC_ORDER \\\n-{ 8, 9, 10, 11, 12, 13, 2, 3,\t\t\\\n-  15, 16, 17, 18, 19, 20, 21, 22,\t\\\n-  23, 24, 25, 26, 27, 28, 29, 31,\t\\\n-  34, 35, 36, 37, 38, 39,\t\t/* %f2-%f7 */   \\\n+{ 1, 2, 3, 4, 5, 6, 7,\t\t\t/* %g1-%g7 */\t\\\n+  13, 12, 11, 10, 9, 8, \t\t/* %o5-%o0 */\t\\\n+  15,\t\t\t\t\t/* %o7 */\t\\\n+  16, 17, 18, 19, 20, 21, 22, 23,\t/* %l0-%l7 */ \t\\\n+  29, 28, 27, 26, 25, 24, 31,\t\t/* %i5-%i0,%i7 */\\\n   40, 41, 42, 43, 44, 45, 46, 47,\t/* %f8-%f15 */  \\\n   48, 49, 50, 51, 52, 53, 54, 55,\t/* %f16-%f23 */ \\\n   56, 57, 58, 59, 60, 61, 62, 63,\t/* %f24-%f31 */ \\\n   64, 65, 66, 67, 68, 69, 70, 71,\t/* %f32-%f39 */ \\\n   72, 73, 74, 75, 76, 77, 78, 79,\t/* %f40-%f47 */ \\\n   80, 81, 82, 83, 84, 85, 86, 87,\t/* %f48-%f55 */ \\\n   88, 89, 90, 91, 92, 93, 94, 95,\t/* %f56-%f63 */ \\\n-  32, 33,\t\t\t\t/* %f0,%f1 */   \\\n-  96, 97, 98, 99, 100,\t\t\t/* %fcc0-3, %icc */ \\\n-  1, 4, 5, 6, 7, 0, 14, 30, 101}\n+  39, 38, 37, 36, 35, 34, 33, 32,\t/* %f7-%f0 */   \\\n+  96, 97, 98, 99,\t\t\t/* %fcc0-3 */   \\\n+  100, 0, 14, 30, 101}\t\t\t/* %icc, %g0, %o6, %i6, %sfp */\n \n /* This is the order in which to allocate registers for\n-   leaf functions.  If all registers can fit in the \"gi\" registers,\n-   then we have the possibility of having a leaf function.  */\n+   leaf functions.  If all registers can fit in the global and\n+   output registers, then we have the possibility of having a leaf\n+   function.\n+\n+   The macro actually mentioned the input registers first,\n+   because they get renumbered into the output registers once\n+   we know really do have a leaf function.\n+\n+   To be more precise, this register allocation order is used\n+   when %o7 is found to not be clobbered right before register\n+   allocation.  Normally, the reason %o7 would be clobbered is\n+   due to a call which could not be transformed into a sibling\n+   call.\n+\n+   As a consequence, it is possible to use the leaf register\n+   allocation order and not end up with a leaf function.  We will\n+   not get suboptimal register allocation in that case because by\n+   definition of being potentially leaf, there were no function\n+   calls.  Therefore, allocation order within the local register\n+   window is not critical like it is when we do have function calls.  */\n \n #define REG_LEAF_ALLOC_ORDER \\\n-{ 2, 3, 24, 25, 26, 27, 28, 29,\t\t\\\n-  4, 5, 6, 7, 1,\t\t\t\\\n-  15, 8, 9, 10, 11, 12, 13,\t\t\\\n-  16, 17, 18, 19, 20, 21, 22, 23,\t\\\n-  34, 35, 36, 37, 38, 39,\t\t\\\n-  40, 41, 42, 43, 44, 45, 46, 47,\t\\\n-  48, 49, 50, 51, 52, 53, 54, 55,\t\\\n-  56, 57, 58, 59, 60, 61, 62, 63,\t\\\n-  64, 65, 66, 67, 68, 69, 70, 71,\t\\\n-  72, 73, 74, 75, 76, 77, 78, 79,\t\\\n-  80, 81, 82, 83, 84, 85, 86, 87,\t\\\n-  88, 89, 90, 91, 92, 93, 94, 95,\t\\\n-  32, 33,\t\t\t\t\\\n-  96, 97, 98, 99, 100,\t\t\t\\\n-  0, 14, 30, 31, 101}\n+{ 1, 2, 3, 4, 5, 6, 7, \t\t\t/* %g1-%g7 */\t\\\n+  29, 28, 27, 26, 25, 24,\t\t/* %i5-%i0 */\t\\\n+  15,\t\t\t\t\t/* %o7 */\t\\\n+  13, 12, 11, 10, 9, 8,\t\t\t/* %o5-%o0 */\t\\\n+  16, 17, 18, 19, 20, 21, 22, 23,\t/* %l0-%l7 */\t\\\n+  40, 41, 42, 43, 44, 45, 46, 47,\t/* %f8-%f15 */\t\\\n+  48, 49, 50, 51, 52, 53, 54, 55,\t/* %f16-%f23 */\t\\\n+  56, 57, 58, 59, 60, 61, 62, 63,\t/* %f24-%f31 */\t\\\n+  64, 65, 66, 67, 68, 69, 70, 71,\t/* %f32-%f39 */\t\\\n+  72, 73, 74, 75, 76, 77, 78, 79,\t/* %f40-%f47 */\t\\\n+  80, 81, 82, 83, 84, 85, 86, 87,\t/* %f48-%f55 */\t\\\n+  88, 89, 90, 91, 92, 93, 94, 95,\t/* %f56-%f63 */\t\\\n+  39, 38, 37, 36, 35, 34, 33, 32,\t/* %f7-%f0 */\t\\\n+  96, 97, 98, 99,\t\t\t/* %fcc0-3 */\t\\\n+  100, 0, 14, 30, 31, 101}\t\t/* %icc, %g0, %o6, %i6, %i7, %sfp */\n   \n #define ORDER_REGS_FOR_LOCAL_ALLOC order_regs_for_local_alloc ()\n "}]}