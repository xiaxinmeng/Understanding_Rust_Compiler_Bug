{"sha": "2e1295ade52283a56984222331d603c85ae6d19a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUxMjk1YWRlNTIyODNhNTY5ODQyMjIzMzFkNjAzYzg1YWU2ZDE5YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T10:43:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T10:43:41Z"}, "message": "[multiple changes]\n\n2014-08-04  Robert Dewar  <dewar@adacore.com>\n\n\t* inline.adb, einfo.ads, s-tassta.adb, s-tarest.adb: Minor comment\n\tfixes.\n\n2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.adb (Process_Import_Or_Interface): Handle properly\n\tan aspect Import that specifies a False value.\n\n2014-08-04  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Add section on aspect Invariant'Class.\n\n2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_case.adb (Check_Choice_Set): New flag Predicate_Error,\n\tfor better control of cascaded error messages when some choice\n\tin a case statement over a predicated type violates the given\n\tstatic predicate.\n\n2014-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch3.adb (Build_Derived_Type): Modify the\n\tinheritance of the rep chain to ensure that a non-tagged type's\n\titems are not clobbered during the inheritance.\n\nFrom-SVN: r213566", "tree": {"sha": "aa22f3838d1fd9486d2749047b71f1e08bd68d56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa22f3838d1fd9486d2749047b71f1e08bd68d56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e1295ade52283a56984222331d603c85ae6d19a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e1295ade52283a56984222331d603c85ae6d19a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e1295ade52283a56984222331d603c85ae6d19a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e1295ade52283a56984222331d603c85ae6d19a/comments", "author": null, "committer": null, "parents": [{"sha": "82701811fcb7027114db712f6b06b742fc5557d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82701811fcb7027114db712f6b06b742fc5557d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82701811fcb7027114db712f6b06b742fc5557d1"}], "stats": {"total": 174, "additions": 133, "deletions": 41}, "files": [{"sha": "d02d068c0e3d0b3c14de701cb24d3fe87e5bc63a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1295ade52283a56984222331d603c85ae6d19a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1295ade52283a56984222331d603c85ae6d19a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2e1295ade52283a56984222331d603c85ae6d19a", "patch": "@@ -1,3 +1,30 @@\n+2014-08-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* inline.adb, einfo.ads, s-tassta.adb, s-tarest.adb: Minor comment\n+\tfixes.\n+\n+2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb (Process_Import_Or_Interface): Handle properly\n+\tan aspect Import that specifies a False value.\n+\n+2014-08-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Add section on aspect Invariant'Class.\n+\n+2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_case.adb (Check_Choice_Set): New flag Predicate_Error,\n+\tfor better control of cascaded error messages when some choice\n+\tin a case statement over a predicated type violates the given\n+\tstatic predicate.\n+\n+2014-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch3.adb (Build_Derived_Type): Modify the\n+\tinheritance of the rep chain to ensure that a non-tagged type's\n+\titems are not clobbered during the inheritance.\n+\n 2014-08-04  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch3.adb, einfo.ads: Minor reformatting."}, {"sha": "fb737e1ef63e5fd06e3bc88fd05c754d1634d945", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1295ade52283a56984222331d603c85ae6d19a/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1295ade52283a56984222331d603c85ae6d19a/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=2e1295ade52283a56984222331d603c85ae6d19a", "patch": "@@ -5716,7 +5716,7 @@ package Einfo is\n    --    Requires_Overriding                 (Flag213)  (non-generic case only)\n    --    Return_Present                      (Flag54)\n    --    Returns_By_Ref                      (Flag90)\n-   --    Returns_Limited_View                (Flag134)\n+   --    Returns_Limited_View                (Flag134)  (non-generic case only)\n    --    Sec_Stack_Needed_For_Return         (Flag167)\n    --    SPARK_Pragma_Inherited              (Flag265)\n    --    Uses_Sec_Stack                      (Flag95)"}, {"sha": "cd215f521bf37fe99624d26c4ed90cd92c76a2e9", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1295ade52283a56984222331d603c85ae6d19a/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1295ade52283a56984222331d603c85ae6d19a/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=2e1295ade52283a56984222331d603c85ae6d19a", "patch": "@@ -308,6 +308,7 @@ Implementation Defined Aspects\n * Aspect Initializes::\n * Aspect Inline_Always::\n * Aspect Invariant::\n+* Aspect Invariant'Class::\n * Aspect Iterable::\n * Aspect Linker_Section::\n * Aspect No_Elaboration_Code_All::\n@@ -8061,6 +8062,7 @@ clause.\n * Aspect Initializes::\n * Aspect Inline_Always::\n * Aspect Invariant::\n+* Aspect Invariant'Class::\n * Aspect Iterable::\n * Aspect Linker_Section::\n * Aspect Lock_Free::\n@@ -8285,6 +8287,14 @@ This aspect is equivalent to pragma @code{Invariant}. It is a\n synonym for the language defined aspect @code{Type_Invariant} except\n that it is separately controllable using pragma @code{Assertion_Policy}.\n \n+@node Aspect Invariant'Class\n+@unnumberedsec Aspect Invariant'Class\n+@findex Invariant'Class\n+@noindent\n+This aspect is equivalent to pragma @code{Type_Invariant_Class}. It is a\n+synonym for the language defined aspect @code{Type_Invariant'Class} except\n+that it is separately controllable using pragma @code{Assertion_Policy}.\n+\n @node Aspect Iterable\n @unnumberedsec Aspect Iterable\n @findex Iterable"}, {"sha": "c2e0f18a0ea3bf947fb7986d3876b5371e89ae8e", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1295ade52283a56984222331d603c85ae6d19a/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1295ade52283a56984222331d603c85ae6d19a/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=2e1295ade52283a56984222331d603c85ae6d19a", "patch": "@@ -1384,6 +1384,7 @@ package body Inline is\n \n       function Is_Unit_Subprogram (Id : Entity_Id) return Boolean;\n       --  Returns True if subprogram Id defines a compilation unit\n+      --  Shouldn't this be in Sem_Aux???\n \n       function In_Package_Visible_Spec (Id : Node_Id) return Boolean;\n       --  Returns True if subprogram Id is defined in the visible part of a"}, {"sha": "5d44196216ca9f8e64f2a31b182369d5395680ae", "filename": "gcc/ada/s-tarest.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1295ade52283a56984222331d603c85ae6d19a/gcc%2Fada%2Fs-tarest.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1295ade52283a56984222331d603c85ae6d19a/gcc%2Fada%2Fs-tarest.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tarest.adb?ref=2e1295ade52283a56984222331d603c85ae6d19a", "patch": "@@ -211,6 +211,8 @@ package body System.Tasking.Restricted.Stages is\n         (1 .. Self_ID.Common.Compiler_Data.Pri_Stack_Info.Size *\n                 SSE.Storage_Offset (Parameters.Sec_Stack_Percentage) / 100);\n       for Secondary_Stack'Alignment use Standard'Maximum_Alignment;\n+      --  This is the secondary stack data. Note that it is critical that this\n+      --  have maximum alignment, since any kind of data can be allocated here.\n \n       pragma Warnings (Off);\n       Secondary_Stack_Address : System.Address := Secondary_Stack'Address;"}, {"sha": "da76c6559e5063d66840f8935b46d0bbedbc4e60", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1295ade52283a56984222331d603c85ae6d19a/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1295ade52283a56984222331d603c85ae6d19a/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=2e1295ade52283a56984222331d603c85ae6d19a", "patch": "@@ -1053,7 +1053,9 @@ package body System.Tasking.Stages is\n \n       Secondary_Stack : aliased SSE.Storage_Array (1 .. Secondary_Stack_Size);\n       for Secondary_Stack'Alignment use Standard'Maximum_Alignment;\n-      --  Actual area allocated for secondary stack\n+      --  Actual area allocated for secondary stack. Note that it is critical\n+      --  that this have maximum alignment, since any kind of data can be\n+      --  allocated here.\n \n       Secondary_Stack_Address : System.Address := Secondary_Stack'Address;\n       --  Address of secondary stack. In the fixed secondary stack case, this"}, {"sha": "b14f047c2946d6cf3149a3bc1f2c34e506e471fe", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1295ade52283a56984222331d603c85ae6d19a/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1295ade52283a56984222331d603c85ae6d19a/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=2e1295ade52283a56984222331d603c85ae6d19a", "patch": "@@ -113,7 +113,12 @@ package body Sem_Case is\n       Subtyp         : Entity_Id;\n       Others_Present : Boolean;\n       Case_Node      : Node_Id)\n+\n    is\n+      Predicate_Error : Boolean;\n+      --  Flag to prevent cascaded errors when a static predicate is known to\n+      --  be violated by one choice.\n+\n       procedure Check_Against_Predicate\n         (Pred    : in out Node_Id;\n          Choice  : Choice_Bounds;\n@@ -626,6 +631,12 @@ package body Sem_Case is\n \n          elsif Value1 > Value2 then\n             return;\n+\n+         --  If predicate is already known to be violated, do no check for\n+         --  coverage error, to prevent cascaded messages.\n+\n+         elsif Predicate_Error then\n+            return;\n          end if;\n \n          --  Case of only one value that is missing\n@@ -748,6 +759,8 @@ package body Sem_Case is\n       --  expression is static, independently of whether the aspect mentions\n       --  Static explicitly.\n \n+      Predicate_Error := False;\n+\n       if Has_Predicate then\n          Pred    := First (Static_Discrete_Predicate (Bounds_Type));\n          Prev_Lo := Uint_Minus_1;\n@@ -763,13 +776,21 @@ package body Sem_Case is\n                Error   => Error);\n \n             --  The analysis detected an illegal intersection between a choice\n-            --  and a static predicate set.\n+            --  and a static predicate set. Do not examine other choices unless\n+            --  all errors are requested.\n \n             if Error then\n-               return;\n+               Predicate_Error := True;\n+               if not All_Errors_Mode then\n+                  return;\n+               end if;\n             end if;\n          end loop;\n \n+         if Predicate_Error then\n+            return;\n+         end if;\n+\n          --  The choices may legally cover some of the static predicate sets,\n          --  but not all. Emit an error for each non-covered set.\n "}, {"sha": "73a63e7f3a8ab12a5d4c474d513043ceef5f7992", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1295ade52283a56984222331d603c85ae6d19a/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1295ade52283a56984222331d603c85ae6d19a/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=2e1295ade52283a56984222331d603c85ae6d19a", "patch": "@@ -8586,56 +8586,55 @@ package body Sem_Ch3 is\n       --  The derived type inherits the representation clauses of the parent.\n       --  However, for a private type that is completed by a derivation, there\n       --  may be operation attributes that have been specified already (stream\n-      --  attributes and External_Tag) and those must be provided. Finally,\n-      --  if the partial view is a private extension, the representation items\n-      --  of the parent have been inherited already, and should not be chained\n+      --  attributes and External_Tag) and those must be provided. Finally, if\n+      --  the partial view is a private extension, the representation items of\n+      --  the parent have been inherited already, and should not be chained\n       --  twice to the derived type.\n \n-      if Is_Tagged_Type (Parent_Type)\n-        and then Present (First_Rep_Item (Derived_Type))\n-      then\n-         --  The existing items are either operational items or items inherited\n-         --  from a private extension declaration.\n+      --  Historic note: The guard below used to check whether the parent type\n+      --  is tagged. This is no longer needed because an untagged derived type\n+      --  may carry rep items of its own as a result of certain SPARK pragmas.\n+      --  With the old guard in place, the rep items of the derived type were\n+      --  clobbered.\n \n+      if Present (First_Rep_Item (Derived_Type)) then\n          declare\n-            Rep : Node_Id;\n-            --  Used to iterate over representation items of the derived type\n-\n-            Last_Rep : Node_Id;\n-            --  Last representation item of the (non-empty) representation\n-            --  item list of the derived type.\n-\n-            Found : Boolean := False;\n+            Par_Item  : constant Node_Id := First_Rep_Item (Parent_Type);\n+            Inherited : Boolean := False;\n+            Item      : Node_Id;\n+            Last_Item : Node_Id;\n \n          begin\n-            Rep      := First_Rep_Item (Derived_Type);\n-            Last_Rep := Rep;\n-            while Present (Rep) loop\n-               if Rep = First_Rep_Item (Parent_Type) then\n-                  Found := True;\n+            --  Inspect the rep item chain of the derived type and perform the\n+            --  following two functions:\n+            --    1) Determine whether the derived type already inherited the\n+            --       rep items of the parent type.\n+            --    2) Find the last rep item of the derived type\n+\n+            Item := First_Rep_Item (Derived_Type);\n+            Last_Item := Item;\n+            while Present (Item) loop\n+               if Item = Par_Item then\n+                  Inherited := True;\n                   exit;\n-\n-               else\n-                  Rep := Next_Rep_Item (Rep);\n-\n-                  if Present (Rep) then\n-                     Last_Rep := Rep;\n-                  end if;\n                end if;\n+\n+               Last_Item := Item;\n+               Item := Next_Rep_Item (Item);\n             end loop;\n \n-            --  Here if we either encountered the parent type's first rep\n-            --  item on the derived type's rep item list (in which case\n-            --  Found is True, and we have nothing else to do), or if we\n-            --  reached the last rep item of the derived type, which is\n-            --  Last_Rep, in which case we further chain the parent type's\n-            --  rep items to those of the derived type.\n+            --  Nothing to do if the derived type already inherited the rep\n+            --  items from the parent type, otherwise append the parent rep\n+            --  item chain to that of the derived type.\n \n-            if not Found then\n-               Set_Next_Rep_Item (Last_Rep, First_Rep_Item (Parent_Type));\n+            if not Inherited then\n+               Set_Next_Rep_Item (Last_Item, Par_Item);\n             end if;\n          end;\n \n+      --  Otherwise the derived type lacks rep items and directly inherits the\n+      --  rep items of the parent type.\n+\n       else\n          Set_First_Rep_Item (Derived_Type, First_Rep_Item (Parent_Type));\n       end if;"}, {"sha": "0b2accfc126c86df06137af3a9b7d64a87b2450f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1295ade52283a56984222331d603c85ae6d19a/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1295ade52283a56984222331d603c85ae6d19a/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=2e1295ade52283a56984222331d603c85ae6d19a", "patch": "@@ -7993,7 +7993,37 @@ package body Sem_Prag is\n                      end if;\n                   end;\n \n-                  Set_Has_Completion (Def_Id);\n+                  --  If the pragma comes from an aspect specification, there\n+                  --  must be an Import aspect specified as well. In the rare\n+                  --  case where Import is set to False, the suprogram needs to\n+                  --  have a local completion.\n+\n+                  declare\n+                     Imp_Aspect : constant Node_Id :=\n+                                    Find_Aspect (Def_Id, Aspect_Import);\n+                     Expr       : Node_Id;\n+\n+                  begin\n+                     if Present (Imp_Aspect)\n+                       and then Present (Expression (Imp_Aspect))\n+                     then\n+                        Expr := Expression (Imp_Aspect);\n+                        Analyze_And_Resolve (Expr, Standard_Boolean);\n+\n+                        if Is_Entity_Name (Expr)\n+                          and then Entity (Expr) = Standard_True\n+                        then\n+                           Set_Has_Completion (Def_Id);\n+                        end if;\n+\n+                     --  If there is no expression, the default is True, as for\n+                     --  all boolean aspects. Same for the older pragma.\n+\n+                     else\n+                        Set_Has_Completion (Def_Id);\n+                     end if;\n+                  end;\n+\n                   Process_Interface_Name (Def_Id, Arg3, Arg4);\n                end if;\n "}]}