{"sha": "6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAyN2VhNGNkN2IxZTk1NWNmN2NkNjFlOTE3OGE4OWQ4OWUzZGJlMg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2018-03-13T20:42:49Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2018-03-13T20:42:49Z"}, "message": "re PR target/83712 (\"Unable to find a register to spill\" when compiling for thumb1)\n\n2018-03-13  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/83712\n\t* lra-assigns.c (find_all_spills_for): Ignore uninteresting\n\tpseudos.\n\t(assign_by_spills): Return a flag of reload assignment failure.\n\tDo not process the reload assignment failures.  Do not spill other\n\treload pseudos if they has the same reg class.  Update n if\n\tnecessary.\n\t(lra_assign): Add a return arg.  Set up from the result of\n\tassign_by_spills call.\n\t(find_reload_regno_insns, lra_split_hard_reg_for): New functions.\n\t* lra-constraints.c (split_reg): Add a new arg.  Use it instead of\n\tusage_insns if it is not NULL.\n\t(spill_hard_reg_in_range): New function.\n\t(split_if_necessary, inherit_in_ebb): Pass a new arg to split_reg.\n\t* lra-int.h (spill_hard_reg_in_range, lra_split_hard_reg_for): New\n\tfunction prototypes.\n\t(lra_assign): Change prototype.\n\t* lra.c (lra): Add code to deal with fails by splitting hard reg\n\tlive ranges.\n\nFrom-SVN: r258504", "tree": {"sha": "238e7d9dada206bba93256cb01455ec15fea1ea6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/238e7d9dada206bba93256cb01455ec15fea1ea6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "949aab190a4ff95d4ba71f55e8b77a2aae61457f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/949aab190a4ff95d4ba71f55e8b77a2aae61457f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/949aab190a4ff95d4ba71f55e8b77a2aae61457f"}], "stats": {"total": 407, "additions": 292, "deletions": 115}, "files": [{"sha": "5eaafcfb9bbed3c6fa263edd9d1549d64213b4fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2", "patch": "@@ -1,3 +1,25 @@\n+2018-03-13  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/83712\n+\t* lra-assigns.c (find_all_spills_for): Ignore uninteresting\n+\tpseudos.\n+\t(assign_by_spills): Return a flag of reload assignment failure.\n+\tDo not process the reload assignment failures.  Do not spill other\n+\treload pseudos if they has the same reg class.  Update n if\n+\tnecessary.\n+\t(lra_assign): Add a return arg.  Set up from the result of\n+\tassign_by_spills call.\n+\t(find_reload_regno_insns, lra_split_hard_reg_for): New functions.\n+\t* lra-constraints.c (split_reg): Add a new arg.  Use it instead of\n+\tusage_insns if it is not NULL.\n+\t(spill_hard_reg_in_range): New function.\n+\t(split_if_necessary, inherit_in_ebb): Pass a new arg to split_reg.\n+\t* lra-int.h (spill_hard_reg_in_range, lra_split_hard_reg_for): New\n+\tfunction prototypes.\n+\t(lra_assign): Change prototype.\n+\t* lra.c (lra): Add code to deal with fails by splitting hard reg\n+\tlive ranges.\n+\n 2018-03-01  Palmer Dabbelt  <palmer@sifive.com>\n \n \t* config/riscv/riscv.opt (mrelax): New option."}, {"sha": "6d16037ab0246f4fe220264e44d1c662bbfd152a", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 166, "deletions": 66, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2", "patch": "@@ -1339,24 +1339,33 @@ find_all_spills_for (int regno)\n \t       r2 = r2->start_next)\n \t    {\n \t      if (live_pseudos_reg_renumber[r2->regno] >= 0\n-\t\t  && rclass_intersect_p[regno_allocno_class_array[r2->regno]])\n+\t\t  && ! sparseset_bit_p (live_range_hard_reg_pseudos, r2->regno)\n+\t\t  && rclass_intersect_p[regno_allocno_class_array[r2->regno]]\n+\t\t  && ((int) r2->regno < lra_constraint_new_regno_start\n+\t\t      || bitmap_bit_p (&lra_inheritance_pseudos, r2->regno)\n+\t\t      || bitmap_bit_p (&lra_split_regs, r2->regno)\n+\t\t      || bitmap_bit_p (&lra_optional_reload_pseudos, r2->regno)\n+\t\t      /* There is no sense to consider another reload\n+\t\t\t pseudo if it has the same class.  */\n+\t\t      || regno_allocno_class_array[r2->regno] != rclass))\n \t\tsparseset_set_bit (live_range_hard_reg_pseudos, r2->regno);\n \t    }\n \t}\n     }\n }\n \n-/* Assign hard registers to reload pseudos and other pseudos.  */\n-static void\n+/* Assign hard registers to reload pseudos and other pseudos.  Return\n+   true if we was not able to assign hard registers to all reload\n+   pseudos.  */\n+static bool\n assign_by_spills (void)\n {\n-  int i, n, nfails, iter, regno, hard_regno, cost;\n+  int i, n, nfails, iter, regno, regno2, hard_regno, cost;\n   rtx restore_rtx;\n-  rtx_insn *insn;\n   bitmap_head changed_insns, do_not_assign_nonreload_pseudos;\n   unsigned int u, conflict_regno;\n   bitmap_iterator bi;\n-  bool reload_p;\n+  bool reload_p, fails_p = false;\n   int max_regno = max_reg_num ();\n \n   for (n = 0, i = lra_constraint_new_regno_start; i < max_regno; i++)\n@@ -1399,8 +1408,13 @@ assign_by_spills (void)\n \t    hard_regno = spill_for (regno, &all_spilled_pseudos, iter == 1);\n \t  if (hard_regno < 0)\n \t    {\n-\t      if (reload_p)\n+\t      if (reload_p) {\n+\t\t/* Put unassigned reload pseudo first in the\n+\t\t   array.  */\n+\t\tregno2 = sorted_pseudos[nfails];\n \t\tsorted_pseudos[nfails++] = regno;\n+\t\tsorted_pseudos[i] = regno2;\n+\t      }\n \t    }\n \t  else\n \t    {\n@@ -1415,61 +1429,9 @@ assign_by_spills (void)\n \t\tbitmap_set_bit (&changed_pseudo_bitmap, regno);\n \t    }\n \t}\n-      if (nfails == 0)\n-\tbreak;\n-      if (iter > 0)\n+      if (nfails == 0 || iter > 0)\n \t{\n-\t  /* We did not assign hard regs to reload pseudos after two iterations.\n-\t     Either it's an asm and something is wrong with the constraints, or\n-\t     we have run out of spill registers; error out in either case.  */\n-\t  bool asm_p = false;\n-\t  bitmap_head failed_reload_insns;\n-\n-\t  bitmap_initialize (&failed_reload_insns, &reg_obstack);\n-\t  for (i = 0; i < nfails; i++)\n-\t    {\n-\t      regno = sorted_pseudos[i];\n-\t      bitmap_ior_into (&failed_reload_insns,\n-\t\t\t       &lra_reg_info[regno].insn_bitmap);\n-\t      /* Assign an arbitrary hard register of regno class to\n-\t\t avoid further trouble with this insn.  */\n-\t      bitmap_clear_bit (&all_spilled_pseudos, regno);\n-\t      assign_hard_regno\n-\t\t(ira_class_hard_regs[regno_allocno_class_array[regno]][0],\n-\t\t regno);\n-\t    }\n-\t  EXECUTE_IF_SET_IN_BITMAP (&failed_reload_insns, 0, u, bi)\n-\t    {\n-\t      insn = lra_insn_recog_data[u]->insn;\n-\t      if (asm_noperands (PATTERN (insn)) >= 0)\n-\t\t{\n-\t\t  asm_p = true;\n-\t\t  error_for_asm (insn,\n-\t\t\t\t \"%<asm%> operand has impossible constraints\");\n-\t\t  /* Avoid further trouble with this insn.\n-\t\t     For asm goto, instead of fixing up all the edges\n-\t\t     just clear the template and clear input operands\n-\t\t     (asm goto doesn't have any output operands).  */\n-\t\t  if (JUMP_P (insn))\n-\t\t    {\n-\t\t      rtx asm_op = extract_asm_operands (PATTERN (insn));\n-\t\t      ASM_OPERANDS_TEMPLATE (asm_op) = ggc_strdup (\"\");\n-\t\t      ASM_OPERANDS_INPUT_VEC (asm_op) = rtvec_alloc (0);\n-\t\t      ASM_OPERANDS_INPUT_CONSTRAINT_VEC (asm_op) = rtvec_alloc (0);\n-\t\t      lra_update_insn_regno_info (insn);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);\n-\t\t      lra_set_insn_deleted (insn);\n-\t\t    }\n-\t\t}\n-\t      else if (!asm_p)\n-\t\t{\n-\t\t  error (\"unable to find a register to spill\");\n-\t\t  fatal_insn (\"this is the insn:\", insn);\n-\t\t}\n-\t    }\n+\t  fails_p = nfails != 0;\n \t  break;\n \t}\n       /* This is a very rare event.  We can not assign a hard register\n@@ -1518,7 +1480,8 @@ assign_by_spills (void)\n \t  update_lives (conflict_regno, true);\n \t  lra_setup_reg_renumber (conflict_regno, -1, false);\n \t}\n-      n = nfails;\n+      if (n < nfails)\n+\tn = nfails;\n     }\n   improve_inheritance (&changed_pseudo_bitmap);\n   bitmap_clear (&non_reload_pseudos);\n@@ -1604,9 +1567,9 @@ assign_by_spills (void)\n   bitmap_clear (&best_spill_pseudos_bitmap);\n   bitmap_clear (&spill_pseudos_bitmap);\n   bitmap_clear (&insn_conflict_pseudos);\n+  return fails_p;\n }\n \n-\n /* Entry function to assign hard registers to new reload pseudos\n    starting with LRA_CONSTRAINT_NEW_REGNO_START (by possible spilling\n    of old pseudos) and possibly to the old pseudos.  The function adds\n@@ -1615,9 +1578,10 @@ assign_by_spills (void)\n    changed allocation.\n \n    Return true if we did not spill any non-reload and non-inheritance\n-   pseudos.  */\n+   pseudos.  Set up FAILS_P if we failed to assign hard registers to\n+   all reload pseudos.  */\n bool\n-lra_assign (void)\n+lra_assign (bool &fails_p)\n {\n   int i;\n   unsigned int u;\n@@ -1661,7 +1625,7 @@ lra_assign (void)\n   /* Setup insns to process on the next constraint pass.  */\n   bitmap_initialize (&changed_pseudo_bitmap, &reg_obstack);\n   init_live_reload_and_inheritance_pseudos ();\n-  assign_by_spills ();\n+  fails_p = assign_by_spills ();\n   finish_live_reload_and_inheritance_pseudos ();\n   bitmap_ior_into (&changed_pseudo_bitmap, &all_spilled_pseudos);\n   no_spills_p = true;\n@@ -1707,3 +1671,139 @@ lra_assign (void)\n   return no_spills_p;\n }\n \n+/* Find start and finish insns for reload pseudo REGNO.  Return true\n+   if we managed to find the expected insns.  Return false,\n+   otherwise.  */\n+static bool\n+find_reload_regno_insns (int regno, rtx_insn * &start, rtx_insn * &finish)\n+{\n+  unsigned int uid;\n+  bitmap_iterator bi;\n+  int n = 0;\n+  rtx_insn *prev_insn, *next_insn;\n+  rtx_insn *start_insn = NULL, *first_insn = NULL, *second_insn = NULL;\n+  \n+  EXECUTE_IF_SET_IN_BITMAP (&lra_reg_info[regno].insn_bitmap, 0, uid, bi)\n+    {\n+      if (start_insn == NULL)\n+\tstart_insn = lra_insn_recog_data[uid]->insn;\n+      n++;\n+    }\n+  /* For reload pseudo we should have at most 3 insns referring for it:\n+     input/output reload insns and the original insn.  */\n+  if (n > 3)\n+    return false;\n+  if (n > 1)\n+    {\n+      for (prev_insn = PREV_INSN (start_insn),\n+\t     next_insn = NEXT_INSN (start_insn);\n+\t   n != 1 && (prev_insn != NULL || next_insn != NULL); )\n+\t{\n+\t  if (prev_insn != NULL && first_insn == NULL)\n+\t    {\n+\t      if (! bitmap_bit_p (&lra_reg_info[regno].insn_bitmap,\n+\t\t\t\t  INSN_UID (prev_insn)))\n+\t\tprev_insn = PREV_INSN (prev_insn);\n+\t      else\n+\t\t{\n+\t\t  first_insn = prev_insn;\n+\t\t  n--;\n+\t\t}\n+\t    }\n+\t  if (next_insn != NULL && second_insn == NULL)\n+\t    {\n+\t      if (! bitmap_bit_p (&lra_reg_info[regno].insn_bitmap,\n+\t\t\t\tINSN_UID (next_insn)))\n+\t\tnext_insn = NEXT_INSN (next_insn);\n+\t      else\n+\t\t{\n+\t\t  second_insn = next_insn;\n+\t\t  n--;\n+\t\t}\n+\t    }\n+\t}\n+      if (n > 1)\n+\treturn false;\n+    }\n+  start = first_insn != NULL ? first_insn : start_insn;\n+  finish = second_insn != NULL ? second_insn : start_insn;\n+  return true;\n+}\n+\n+/* Process reload pseudos which did not get a hard reg, split a hard\n+   reg live range in live range of a reload pseudo, and then return\n+   TRUE.  If we did not split a hard reg live range, report an error,\n+   and return FALSE.  */\n+bool\n+lra_split_hard_reg_for (void)\n+{\n+  int i, regno, n;\n+  rtx_insn *insn, *first, *last;\n+  unsigned int u;\n+  bitmap_iterator bi;\n+  int max_regno = max_reg_num ();\n+  /* We did not assign hard regs to reload pseudos after two\n+     iterations.  Either it's an asm and something is wrong with the\n+     constraints, or we have run out of spill registers; error out in\n+     either case.  */\n+  bool asm_p = false;\n+  bitmap_head failed_reload_insns;\n+  \n+  if (lra_dump_file != NULL)\n+    fprintf (lra_dump_file,\n+\t     \"\\n****** Splitting a hard reg after assignment #%d: ******\\n\\n\",\n+\t     lra_assignment_iter);\n+  for (n = 0, i = lra_constraint_new_regno_start; i < max_regno; i++)\n+    if (reg_renumber[i] < 0 && lra_reg_info[i].nrefs != 0\n+\t&& regno_allocno_class_array[i] != NO_REGS\n+\t&& ! bitmap_bit_p (&non_reload_pseudos, i))\n+      {\n+\tsorted_pseudos[n++] = i;\n+\tif (! find_reload_regno_insns (i, first, last))\n+\t  continue;\n+\tif (spill_hard_reg_in_range (i, regno_allocno_class_array[i],\n+\t\t\t\t     first, last))\n+\t  return true;\n+      }\n+  bitmap_initialize (&failed_reload_insns, &reg_obstack);\n+  for (i = 0; i < n; i++)\n+    {\n+      regno = sorted_pseudos[i];\n+      bitmap_ior_into (&failed_reload_insns,\n+\t\t       &lra_reg_info[regno].insn_bitmap);\n+      lra_setup_reg_renumber (regno, ira_class_hard_regs[regno_allocno_class_array[regno]][0], false);\n+    }\n+  EXECUTE_IF_SET_IN_BITMAP (&failed_reload_insns, 0, u, bi)\n+    {\n+      insn = lra_insn_recog_data[u]->insn;\n+      if (asm_noperands (PATTERN (insn)) >= 0)\n+\t{\n+\t  asm_p = true;\n+\t  error_for_asm (insn,\n+\t\t\t \"%<asm%> operand has impossible constraints\");\n+\t  /* Avoid further trouble with this insn.\n+\t     For asm goto, instead of fixing up all the edges\n+\t     just clear the template and clear input operands\n+\t     (asm goto doesn't have any output operands).  */\n+\t  if (JUMP_P (insn))\n+\t    {\n+\t      rtx asm_op = extract_asm_operands (PATTERN (insn));\n+\t      ASM_OPERANDS_TEMPLATE (asm_op) = ggc_strdup (\"\");\n+\t      ASM_OPERANDS_INPUT_VEC (asm_op) = rtvec_alloc (0);\n+\t      ASM_OPERANDS_INPUT_CONSTRAINT_VEC (asm_op) = rtvec_alloc (0);\n+\t      lra_update_insn_regno_info (insn);\n+\t    }\n+\t  else\n+\t    {\n+\t      PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);\n+\t      lra_set_insn_deleted (insn);\n+\t    }\n+\t}\n+      else if (!asm_p)\n+\t{\n+\t  error (\"unable to find a register to spill\");\n+\t  fatal_insn (\"this is the insn:\", insn);\n+\t}\n+    }\n+  return false;\n+}"}, {"sha": "118b65f6a23c99cbbfb6721595f645fc555150dc", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 59, "deletions": 21, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2", "patch": "@@ -5458,7 +5458,8 @@ lra_copy_reg_equiv (unsigned int new_regno, unsigned int original_regno)\n /* Do split transformations for insn INSN, which defines or uses\n    ORIGINAL_REGNO.  NEXT_USAGE_INSNS specifies which instruction in\n    the EBB next uses ORIGINAL_REGNO; it has the same form as the\n-   \"insns\" field of usage_insns.\n+   \"insns\" field of usage_insns.  If TO is not NULL, we don't use\n+   usage_insns, we put restore insns after TO insn.\n \n    The transformations look like:\n \n@@ -5480,7 +5481,7 @@ lra_copy_reg_equiv (unsigned int new_regno, unsigned int original_regno)\n    transformation.  */\n static bool\n split_reg (bool before_p, int original_regno, rtx_insn *insn,\n-\t   rtx next_usage_insns)\n+\t   rtx next_usage_insns, rtx_insn *to)\n {\n   enum reg_class rclass;\n   rtx original_reg;\n@@ -5613,29 +5614,37 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n   if (!HARD_REGISTER_NUM_P (original_regno)\n       && mode == PSEUDO_REGNO_MODE (original_regno))\n     lra_copy_reg_equiv (new_regno, original_regno);\n-  after_p = usage_insns[original_regno].after_p;\n   lra_reg_info[new_regno].restore_rtx = regno_reg_rtx[original_regno];\n   bitmap_set_bit (&check_only_regs, new_regno);\n   bitmap_set_bit (&check_only_regs, original_regno);\n   bitmap_set_bit (&lra_split_regs, new_regno);\n-  for (;;)\n+  if (to != NULL)\n     {\n-      if (GET_CODE (next_usage_insns) != INSN_LIST)\n-\t{\n-\t  usage_insn = next_usage_insns;\n-\t  break;\n-\t}\n-      usage_insn = XEXP (next_usage_insns, 0);\n-      lra_assert (DEBUG_INSN_P (usage_insn));\n-      next_usage_insns = XEXP (next_usage_insns, 1);\n-      lra_substitute_pseudo (&usage_insn, original_regno, new_reg, false,\n-\t\t\t     true);\n-      lra_update_insn_regno_info (as_a <rtx_insn *> (usage_insn));\n-      if (lra_dump_file != NULL)\n+      usage_insn = to;\n+      after_p = TRUE;\n+    }\n+  else\n+    {\n+      after_p = usage_insns[original_regno].after_p;\n+      for (;;)\n \t{\n-\t  fprintf (lra_dump_file, \"    Split reuse change %d->%d:\\n\",\n-\t\t   original_regno, new_regno);\n-\t  dump_insn_slim (lra_dump_file, as_a <rtx_insn *> (usage_insn));\n+\t  if (GET_CODE (next_usage_insns) != INSN_LIST)\n+\t    {\n+\t      usage_insn = next_usage_insns;\n+\t      break;\n+\t    }\n+\t  usage_insn = XEXP (next_usage_insns, 0);\n+\t  lra_assert (DEBUG_INSN_P (usage_insn));\n+\t  next_usage_insns = XEXP (next_usage_insns, 1);\n+\t  lra_substitute_pseudo (&usage_insn, original_regno, new_reg, false,\n+\t\t\t\t true);\n+\t  lra_update_insn_regno_info (as_a <rtx_insn *> (usage_insn));\n+\t  if (lra_dump_file != NULL)\n+\t    {\n+\t      fprintf (lra_dump_file, \"    Split reuse change %d->%d:\\n\",\n+\t\t       original_regno, new_regno);\n+\t      dump_insn_slim (lra_dump_file, as_a <rtx_insn *> (usage_insn));\n+\t    }\n \t}\n     }\n   lra_assert (NOTE_P (usage_insn) || NONDEBUG_INSN_P (usage_insn));\n@@ -5662,6 +5671,35 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n   return true;\n }\n \n+/* Split a hard reg for reload pseudo REGNO having RCLASS and living\n+   in the range [FROM, TO].  Return true if did a split.  Otherwise,\n+   return false.  */\n+bool\n+spill_hard_reg_in_range (int regno, enum reg_class rclass, rtx_insn *from, rtx_insn *to)\n+{\n+  int i, hard_regno;\n+  int rclass_size;\n+  rtx_insn *insn;\n+  \n+  lra_assert (from != NULL && to != NULL);\n+  rclass_size = ira_class_hard_regs_num[rclass];\n+  for (i = 0; i < rclass_size; i++)\n+    {\n+      hard_regno = ira_class_hard_regs[rclass][i];\n+      if (! TEST_HARD_REG_BIT (lra_reg_info[regno].conflict_hard_regs, hard_regno))\n+\tcontinue;\n+      for (insn = from; insn != NEXT_INSN (to); insn = NEXT_INSN (insn))\n+\tif (bitmap_bit_p (&lra_reg_info[hard_regno].insn_bitmap,\n+\t\t\t  INSN_UID (insn)))\n+\t  break;\n+      if (insn != NEXT_INSN (to))\n+\tcontinue;\n+      if (split_reg (TRUE, hard_regno, from, NULL, to))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Recognize that we need a split transformation for insn INSN, which\n    defines or uses REGNO in its insn biggest MODE (we use it only if\n    REGNO is a hard register).  POTENTIAL_RELOAD_HARD_REGS contains\n@@ -5689,7 +5727,7 @@ split_if_necessary (int regno, machine_mode mode,\n \t    || (GET_CODE (next_usage_insns) == INSN_LIST\n \t\t&& (INSN_UID (XEXP (next_usage_insns, 0)) < max_uid)))\n \t&& need_for_split_p (potential_reload_hard_regs, regno + i)\n-\t&& split_reg (before_p, regno + i, insn, next_usage_insns))\n+\t&& split_reg (before_p, regno + i, insn, next_usage_insns, NULL))\n     res = true;\n   return res;\n }\n@@ -6467,7 +6505,7 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t\t\t  head_p = false;\n \t\t\t}\n \t\t      if (split_reg (false, j, bb_note (curr_bb),\n-\t\t\t\t     next_usage_insns))\n+\t\t\t\t     next_usage_insns, NULL))\n \t\t\tchange_p = true;\n \t\t    }\n \t\t  usage_insns[j].check = 0;"}, {"sha": "86e103b748000e80890f8e070bd89213582fe705", "filename": "gcc/lra-int.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2", "patch": "@@ -356,6 +356,7 @@ extern bool lra_constrain_insn (rtx_insn *);\n extern bool lra_constraints (bool);\n extern void lra_constraints_init (void);\n extern void lra_constraints_finish (void);\n+extern bool spill_hard_reg_in_range (int, enum reg_class, rtx_insn *, rtx_insn *);\n extern void lra_inheritance (void);\n extern bool lra_undo_inheritance (void);\n \n@@ -389,8 +390,8 @@ extern void lra_setup_reload_pseudo_preferenced_hard_reg (int, int, int);\n extern int lra_assignment_iter;\n extern int lra_assignment_iter_after_spill;\n extern void lra_setup_reg_renumber (int, int, bool);\n-extern bool lra_assign (void);\n-\n+extern bool lra_assign (bool &);\n+extern bool lra_split_hard_reg_for (void);\n \n /* lra-coalesce.c: */\n "}, {"sha": "b410b90f126e50594b43de7e0f36804983785947", "filename": "gcc/lra.c", "status": "modified", "additions": 42, "deletions": 26, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=6027ea4cd7b1e955cf7cd61e9178a89d89e3dbe2", "patch": "@@ -2461,38 +2461,54 @@ lra (FILE *f)\n \t    }\n \t  if (live_p)\n \t    lra_clear_live_ranges ();\n-\t  /* We need live ranges for lra_assign -- so build them.  But\n-\t     don't remove dead insns or change global live info as we\n-\t     can undo inheritance transformations after inheritance\n-\t     pseudo assigning.  */\n-\t  lra_create_live_ranges (true, false);\n-\t  live_p = true;\n-\t  /* If we don't spill non-reload and non-inheritance pseudos,\n-\t     there is no sense to run memory-memory move coalescing.\n-\t     If inheritance pseudos were spilled, the memory-memory\n-\t     moves involving them will be removed by pass undoing\n-\t     inheritance.  */\n-\t  if (lra_simple_p)\n-\t    lra_assign ();\n-\t  else\n+\t  bool fails_p;\n+\t  do\n \t    {\n-\t      bool spill_p = !lra_assign ();\n-\n-\t      if (lra_undo_inheritance ())\n-\t\tlive_p = false;\n-\t      if (spill_p)\n+\t      /* We need live ranges for lra_assign -- so build them.\n+\t\t But don't remove dead insns or change global live\n+\t\t info as we can undo inheritance transformations after\n+\t\t inheritance pseudo assigning.  */\n+\t      lra_create_live_ranges (true, false);\n+\t      live_p = true;\n+\t      /* If we don't spill non-reload and non-inheritance\n+\t\t pseudos, there is no sense to run memory-memory move\n+\t\t coalescing.  If inheritance pseudos were spilled, the\n+\t\t memory-memory moves involving them will be removed by\n+\t\t pass undoing inheritance.  */\n+\t      if (lra_simple_p)\n+\t\tlra_assign (fails_p);\n+\t      else\n \t\t{\n-\t\t  if (! live_p)\n+\t\t  bool spill_p = !lra_assign (fails_p);\n+\t\t  \n+\t\t  if (lra_undo_inheritance ())\n+\t\t    live_p = false;\n+\t\t  if (spill_p && ! fails_p)\n \t\t    {\n-\t\t      lra_create_live_ranges (true, true);\n-\t\t      live_p = true;\n+\t\t      if (! live_p)\n+\t\t\t{\n+\t\t\t  lra_create_live_ranges (true, true);\n+\t\t\t  live_p = true;\n+\t\t\t}\n+\t\t      if (lra_coalesce ())\n+\t\t\tlive_p = false;\n \t\t    }\n-\t\t  if (lra_coalesce ())\n-\t\t    live_p = false;\n+\t\t  if (! live_p)\n+\t\t    lra_clear_live_ranges ();\n+\t\t}\n+\t      if (fails_p)\n+\t\t{\n+\t\t  /* It is a very rare case.  It is the last hope to\n+\t\t     split a hard regno live range for a reload\n+\t\t     pseudo.  */\n+\t\t  if (live_p)\n+\t\t    lra_clear_live_ranges ();\n+\t\t  live_p = false;\n+\t\t  if (! lra_split_hard_reg_for ())\n+\t\t    break;\n \t\t}\n-\t      if (! live_p)\n-\t\tlra_clear_live_ranges ();\n \t    }\n+\t  while (fails_p);\n \t}\n       /* Don't clear optional reloads bitmap until all constraints are\n \t satisfied as we need to differ them from regular reloads.  */"}]}