{"sha": "0a1eb35020de1c6379c8cab591f6474e94a03c5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGExZWIzNTAyMGRlMWM2Mzc5YzhjYWI1OTFmNjQ3NGU5NGEwM2M1Yg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2014-05-22T21:09:59Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2014-05-22T21:09:59Z"}, "message": "re PR rtl-optimization/60969 (ICE in output_129 in MMXMOV of mode MODE_SF for march=pentium4)\n\n2014-05-22  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/60969\n\t* ira-costs.c (record_reg_classes): Process NO_REGS for matching\n\tconstraints.  Set up mem cost for NO_REGS case.\n\nFrom-SVN: r210824", "tree": {"sha": "21d38cd500a74d55207af2c6667759cfd084e1f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21d38cd500a74d55207af2c6667759cfd084e1f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a1eb35020de1c6379c8cab591f6474e94a03c5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a1eb35020de1c6379c8cab591f6474e94a03c5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a1eb35020de1c6379c8cab591f6474e94a03c5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a1eb35020de1c6379c8cab591f6474e94a03c5b/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "040d18b6ca1de5fa9d7877c4a4c8c9dc0092db0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/040d18b6ca1de5fa9d7877c4a4c8c9dc0092db0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/040d18b6ca1de5fa9d7877c4a4c8c9dc0092db0b"}], "stats": {"total": 96, "additions": 72, "deletions": 24}, "files": [{"sha": "e941c3f81c9e2f844e08bfe4a48afb7c0adb3d32", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a1eb35020de1c6379c8cab591f6474e94a03c5b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a1eb35020de1c6379c8cab591f6474e94a03c5b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a1eb35020de1c6379c8cab591f6474e94a03c5b", "patch": "@@ -1,3 +1,9 @@\n+2014-05-22  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/60969\n+\t* ira-costs.c (record_reg_classes): Process NO_REGS for matching\n+\tconstraints.  Set up mem cost for NO_REGS case.\n+\n 2014-05-22  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* builtin-types.def: Simplify examples for DEF_FUNCTION_TYPE_*."}, {"sha": "2b1574fed3330be0607fcbdb37733dd5f467b133", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 66, "deletions": 24, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a1eb35020de1c6379c8cab591f6474e94a03c5b/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a1eb35020de1c6379c8cab591f6474e94a03c5b/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=0a1eb35020de1c6379c8cab591f6474e94a03c5b", "patch": "@@ -407,6 +407,8 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n   int alt;\n   int i, j, k;\n   int insn_allows_mem[MAX_RECOG_OPERANDS];\n+  move_table *move_in_cost, *move_out_cost;\n+  short (*mem_cost)[2];\n \n   for (i = 0; i < n_ops; i++)\n     insn_allows_mem[i] = 0;\n@@ -517,41 +519,78 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t  bool in_p = recog_data.operand_type[i] != OP_OUT;\n \t\t  bool out_p = recog_data.operand_type[i] != OP_IN;\n \t\t  enum reg_class op_class = classes[i];\n-\t\t  move_table *move_in_cost, *move_out_cost;\n \n \t\t  ira_init_register_move_cost_if_necessary (mode);\n \t\t  if (! in_p)\n \t\t    {\n \t\t      ira_assert (out_p);\n-\t\t      move_out_cost = ira_may_move_out_cost[mode];\n-\t\t      for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n+\t\t      if (op_class == NO_REGS)\n \t\t\t{\n-\t\t\t  rclass = cost_classes[k];\n-\t\t\t  pp_costs[k]\n-\t\t\t    = move_out_cost[op_class][rclass] * frequency;\n+\t\t\t  mem_cost = ira_memory_move_cost[mode];\n+\t\t\t  for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n+\t\t\t    {\n+\t\t\t      rclass = cost_classes[k];\n+\t\t\t      pp_costs[k] = mem_cost[rclass][0] * frequency;\n+\t\t\t    }\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  move_out_cost = ira_may_move_out_cost[mode];\n+\t\t\t  for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n+\t\t\t    {\n+\t\t\t      rclass = cost_classes[k];\n+\t\t\t      pp_costs[k]\n+\t\t\t\t= move_out_cost[op_class][rclass] * frequency;\n+\t\t\t    }\n \t\t\t}\n \t\t    }\n \t\t  else if (! out_p)\n \t\t    {\n \t\t      ira_assert (in_p);\n-\t\t      move_in_cost = ira_may_move_in_cost[mode];\n-\t\t      for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n+\t\t      if (op_class == NO_REGS)\n \t\t\t{\n-\t\t\t  rclass = cost_classes[k];\n-\t\t\t  pp_costs[k]\n-\t\t\t    = move_in_cost[rclass][op_class] * frequency;\n+\t\t\t  mem_cost = ira_memory_move_cost[mode];\n+\t\t\t  for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n+\t\t\t    {\n+\t\t\t      rclass = cost_classes[k];\n+\t\t\t      pp_costs[k] = mem_cost[rclass][1] * frequency;\n+\t\t\t    }\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  move_in_cost = ira_may_move_in_cost[mode];\n+\t\t\t  for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n+\t\t\t    {\n+\t\t\t      rclass = cost_classes[k];\n+\t\t\t      pp_costs[k]\n+\t\t\t\t= move_in_cost[rclass][op_class] * frequency;\n+\t\t\t    }\n \t\t\t}\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      move_in_cost = ira_may_move_in_cost[mode];\n-\t\t      move_out_cost = ira_may_move_out_cost[mode];\n-\t\t      for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n+\t\t      if (op_class == NO_REGS)\n \t\t\t{\n-\t\t\t  rclass = cost_classes[k];\n-\t\t\t  pp_costs[k] = ((move_in_cost[rclass][op_class]\n-\t\t\t\t\t  + move_out_cost[op_class][rclass])\n-\t\t\t\t\t * frequency);\n+\t\t\t  mem_cost = ira_memory_move_cost[mode];\n+\t\t\t  for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n+\t\t\t    {\n+\t\t\t      rclass = cost_classes[k];\n+\t\t\t      pp_costs[k] = ((mem_cost[rclass][0]\n+\t\t\t\t\t      + mem_cost[rclass][1])\n+\t\t\t\t\t     * frequency);\n+\t\t\t    }\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  move_in_cost = ira_may_move_in_cost[mode];\n+\t\t\t  move_out_cost = ira_may_move_out_cost[mode];\n+\t\t\t  for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n+\t\t\t    {\n+\t\t\t      rclass = cost_classes[k];\n+\t\t\t      pp_costs[k] = ((move_in_cost[rclass][op_class]\n+\t\t\t\t\t      + move_out_cost[op_class][rclass])\n+\t\t\t\t\t     * frequency);\n+\t\t\t    }\n \t\t\t}\n \t\t    }\n \n@@ -783,8 +822,6 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t  bool in_p = recog_data.operand_type[i] != OP_OUT;\n \t\t  bool out_p = recog_data.operand_type[i] != OP_IN;\n \t\t  enum reg_class op_class = classes[i];\n-\t\t  move_table *move_in_cost, *move_out_cost;\n-\t\t  short (*mem_cost)[2];\n \n \t\t  ira_init_register_move_cost_if_necessary (mode);\n \t\t  if (! in_p)\n@@ -860,10 +897,15 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t\t}\n \t\t    }\n \n-\t\t  /* If the alternative actually allows memory, make\n-\t\t     things a bit cheaper since we won't need an extra\n-\t\t     insn to load it.  */\n-\t\t  if (op_class != NO_REGS)\n+\t\t  if (op_class == NO_REGS)\n+\t\t    /* Although we don't need insn to reload from\n+\t\t       memory, still accessing memory is usually more\n+\t\t       expensive than a register.  */\n+\t\t    pp->mem_cost = frequency;\n+\t\t  else\n+\t\t    /* If the alternative actually allows memory, make\n+\t\t       things a bit cheaper since we won't need an\n+\t\t       extra insn to load it.  */\n \t\t    pp->mem_cost\n \t\t      = ((out_p ? ira_memory_move_cost[mode][op_class][0] : 0)\n \t\t\t + (in_p ? ira_memory_move_cost[mode][op_class][1] : 0)"}]}