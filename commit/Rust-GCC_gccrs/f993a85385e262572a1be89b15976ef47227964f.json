{"sha": "f993a85385e262572a1be89b15976ef47227964f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk5M2E4NTM4NWUyNjI1NzJhMWJlODliMTU5NzZlZjQ3MjI3OTY0Zg==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2015-11-20T10:25:26Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2015-11-20T10:25:26Z"}, "message": "Do final value replacement in try_create_reduction_list\n\n2015-11-20  Tom de Vries  <tom@codesourcery.com>\n\n\tPR tree-optimization/68373\n\t* tree-scalar-evolution.c (final_value_replacement_loop): Factor out of ...\n\t(scev_const_prop): ... here.\n\t* tree-scalar-evolution.h (final_value_replacement_loop): Declare.\n\t* tree-parloops.c (try_create_reduction_list): Call\n\tfinal_value_replacement_loop.\n\n\t* gcc.dg/autopar/pr68373.c: New test.\n\nFrom-SVN: r230650", "tree": {"sha": "026be2a2c3f7a62a6ab3e92dc2d14e6ac4010117", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/026be2a2c3f7a62a6ab3e92dc2d14e6ac4010117"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f993a85385e262572a1be89b15976ef47227964f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f993a85385e262572a1be89b15976ef47227964f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f993a85385e262572a1be89b15976ef47227964f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f993a85385e262572a1be89b15976ef47227964f/comments", "author": null, "committer": null, "parents": [{"sha": "5b5e7b181fa56b3c2c8aef6cd421bd40852d97e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b5e7b181fa56b3c2c8aef6cd421bd40852d97e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b5e7b181fa56b3c2c8aef6cd421bd40852d97e9"}], "stats": {"total": 280, "additions": 159, "deletions": 121}, "files": [{"sha": "51578300c688eed4b9c23bba2a8885df56def1a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f993a85385e262572a1be89b15976ef47227964f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f993a85385e262572a1be89b15976ef47227964f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f993a85385e262572a1be89b15976ef47227964f", "patch": "@@ -1,3 +1,12 @@\n+2015-11-20  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR tree-optimization/68373\n+\t* tree-scalar-evolution.c (final_value_replacement_loop): Factor out of ...\n+\t(scev_const_prop): ... here.\n+\t* tree-scalar-evolution.h (final_value_replacement_loop): Declare.\n+\t* tree-parloops.c (try_create_reduction_list): Call\n+\tfinal_value_replacement_loop.\n+\n 2015-11-20  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/52272"}, {"sha": "d5042dded04121c5ab8588983e8889dccd3811b1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f993a85385e262572a1be89b15976ef47227964f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f993a85385e262572a1be89b15976ef47227964f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f993a85385e262572a1be89b15976ef47227964f", "patch": "@@ -1,3 +1,8 @@\n+2015-11-20  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR tree-optimization/68373\n+\t* gcc.dg/autopar/pr68373.c: New test.\n+\n 2015-11-20  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/67354"}, {"sha": "8e0f8a5160e514a89fe0d4c021dfae7bfc05444a", "filename": "gcc/testsuite/gcc.dg/autopar/pr68373.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f993a85385e262572a1be89b15976ef47227964f/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fpr68373.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f993a85385e262572a1be89b15976ef47227964f/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fpr68373.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fpr68373.c?ref=f993a85385e262572a1be89b15976ef47227964f", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=2 -fdump-tree-parloops-details\" } */\n+\n+unsigned int\n+foo (int *a, unsigned int n)\n+{\n+  unsigned int i;\n+  for (i = 0; i < n; ++i)\n+    a[i] = 1;\n+\n+  return i;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops\" } } */"}, {"sha": "8d7912dc5821fa45aea0ebc86d3776237e382d42", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f993a85385e262572a1be89b15976ef47227964f/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f993a85385e262572a1be89b15976ef47227964f/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=f993a85385e262572a1be89b15976ef47227964f", "patch": "@@ -2539,6 +2539,9 @@ try_create_reduction_list (loop_p loop,\n \n   gcc_assert (exit);\n \n+  /* Try to get rid of exit phis.  */\n+  final_value_replacement_loop (loop);\n+\n   gather_scalar_reductions (loop, reduction_list);\n \n "}, {"sha": "9b33693e61785bcdc5d097b011b18b151320b3ea", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 127, "deletions": 121, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f993a85385e262572a1be89b15976ef47227964f/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f993a85385e262572a1be89b15976ef47227964f/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=f993a85385e262572a1be89b15976ef47227964f", "patch": "@@ -3417,6 +3417,131 @@ expression_expensive_p (tree expr)\n     }\n }\n \n+/* Do final value replacement for LOOP.  */\n+\n+void\n+final_value_replacement_loop (struct loop *loop)\n+{\n+  /* If we do not know exact number of iterations of the loop, we cannot\n+     replace the final value.  */\n+  edge exit = single_exit (loop);\n+  if (!exit)\n+    return;\n+\n+  tree niter = number_of_latch_executions (loop);\n+  if (niter == chrec_dont_know)\n+    return;\n+\n+  /* Ensure that it is possible to insert new statements somewhere.  */\n+  if (!single_pred_p (exit->dest))\n+    split_loop_exit_edge (exit);\n+\n+  /* Set stmt insertion pointer.  All stmts are inserted before this point.  */\n+  gimple_stmt_iterator gsi = gsi_after_labels (exit->dest);\n+\n+  struct loop *ex_loop\n+    = superloop_at_depth (loop,\n+\t\t\t  loop_depth (exit->dest->loop_father) + 1);\n+\n+  gphi_iterator psi;\n+  for (psi = gsi_start_phis (exit->dest); !gsi_end_p (psi); )\n+    {\n+      gphi *phi = psi.phi ();\n+      tree rslt = PHI_RESULT (phi);\n+      tree def = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n+      if (virtual_operand_p (def))\n+\t{\n+\t  gsi_next (&psi);\n+\t  continue;\n+\t}\n+\n+      if (!POINTER_TYPE_P (TREE_TYPE (def))\n+\t  && !INTEGRAL_TYPE_P (TREE_TYPE (def)))\n+\t{\n+\t  gsi_next (&psi);\n+\t  continue;\n+\t}\n+\n+      bool folded_casts;\n+      def = analyze_scalar_evolution_in_loop (ex_loop, loop, def,\n+\t\t\t\t\t      &folded_casts);\n+      def = compute_overall_effect_of_inner_loop (ex_loop, def);\n+      if (!tree_does_not_contain_chrecs (def)\n+\t  || chrec_contains_symbols_defined_in_loop (def, ex_loop->num)\n+\t  /* Moving the computation from the loop may prolong life range\n+\t     of some ssa names, which may cause problems if they appear\n+\t     on abnormal edges.  */\n+\t  || contains_abnormal_ssa_name_p (def)\n+\t  /* Do not emit expensive expressions.  The rationale is that\n+\t     when someone writes a code like\n+\n+\t     while (n > 45) n -= 45;\n+\n+\t     he probably knows that n is not large, and does not want it\n+\t     to be turned into n %= 45.  */\n+\t  || expression_expensive_p (def))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"not replacing:\\n  \");\n+\t      print_gimple_stmt (dump_file, phi, 0, 0);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t  gsi_next (&psi);\n+\t  continue;\n+\t}\n+\n+      /* Eliminate the PHI node and replace it by a computation outside\n+\t the loop.  */\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\nfinal value replacement:\\n  \");\n+\t  print_gimple_stmt (dump_file, phi, 0, 0);\n+\t  fprintf (dump_file, \"  with\\n  \");\n+\t}\n+      def = unshare_expr (def);\n+      remove_phi_node (&psi, false);\n+\n+      /* If def's type has undefined overflow and there were folded\n+\t casts, rewrite all stmts added for def into arithmetics\n+\t with defined overflow behavior.  */\n+      if (folded_casts && ANY_INTEGRAL_TYPE_P (TREE_TYPE (def))\n+\t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (def)))\n+\t{\n+\t  gimple_seq stmts;\n+\t  gimple_stmt_iterator gsi2;\n+\t  def = force_gimple_operand (def, &stmts, true, NULL_TREE);\n+\t  gsi2 = gsi_start (stmts);\n+\t  while (!gsi_end_p (gsi2))\n+\t    {\n+\t      gimple *stmt = gsi_stmt (gsi2);\n+\t      gimple_stmt_iterator gsi3 = gsi2;\n+\t      gsi_next (&gsi2);\n+\t      gsi_remove (&gsi3, false);\n+\t      if (is_gimple_assign (stmt)\n+\t\t  && arith_code_with_undefined_signed_overflow\n+\t\t  (gimple_assign_rhs_code (stmt)))\n+\t\tgsi_insert_seq_before (&gsi,\n+\t\t\t\t       rewrite_to_defined_overflow (stmt),\n+\t\t\t\t       GSI_SAME_STMT);\n+\t      else\n+\t\tgsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\t    }\n+\t}\n+      else\n+\tdef = force_gimple_operand_gsi (&gsi, def, false, NULL_TREE,\n+\t\t\t\t\ttrue, GSI_SAME_STMT);\n+\n+      gassign *ass = gimple_build_assign (rslt, def);\n+      gsi_insert_before (&gsi, ass, GSI_SAME_STMT);\n+      if (dump_file)\n+\t{\n+\t  print_gimple_stmt (dump_file, ass, 0, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+    }\n+}\n+\n /* Replace ssa names for that scev can prove they are constant by the\n    appropriate constants.  Also perform final value replacement in loops,\n    in case the replacement expressions are cheap.\n@@ -3430,8 +3555,7 @@ scev_const_prop (void)\n   basic_block bb;\n   tree name, type, ev;\n   gphi *phi;\n-  gassign *ass;\n-  struct loop *loop, *ex_loop;\n+  struct loop *loop;\n   bitmap ssa_names_to_remove = NULL;\n   unsigned i;\n   gphi_iterator psi;\n@@ -3507,126 +3631,8 @@ scev_const_prop (void)\n \n   /* Now the regular final value replacement.  */\n   FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n-    {\n-      edge exit;\n-      tree def, rslt, niter;\n-      gimple_stmt_iterator gsi;\n-\n-      /* If we do not know exact number of iterations of the loop, we cannot\n-\t replace the final value.  */\n-      exit = single_exit (loop);\n-      if (!exit)\n-\tcontinue;\n-\n-      niter = number_of_latch_executions (loop);\n-      if (niter == chrec_dont_know)\n-\tcontinue;\n-\n-      /* Ensure that it is possible to insert new statements somewhere.  */\n-      if (!single_pred_p (exit->dest))\n-\tsplit_loop_exit_edge (exit);\n-      gsi = gsi_after_labels (exit->dest);\n+    final_value_replacement_loop (loop);\n \n-      ex_loop = superloop_at_depth (loop,\n-\t\t\t\t    loop_depth (exit->dest->loop_father) + 1);\n-\n-      for (psi = gsi_start_phis (exit->dest); !gsi_end_p (psi); )\n-\t{\n-\t  phi = psi.phi ();\n-\t  rslt = PHI_RESULT (phi);\n-\t  def = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n-\t  if (virtual_operand_p (def))\n-\t    {\n-\t      gsi_next (&psi);\n-\t      continue;\n-\t    }\n-\n-\t  if (!POINTER_TYPE_P (TREE_TYPE (def))\n-\t      && !INTEGRAL_TYPE_P (TREE_TYPE (def)))\n-\t    {\n-\t      gsi_next (&psi);\n-\t      continue;\n-\t    }\n-\n-\t  bool folded_casts;\n-\t  def = analyze_scalar_evolution_in_loop (ex_loop, loop, def,\n-\t\t\t\t\t\t  &folded_casts);\n-\t  def = compute_overall_effect_of_inner_loop (ex_loop, def);\n-\t  if (!tree_does_not_contain_chrecs (def)\n-\t      || chrec_contains_symbols_defined_in_loop (def, ex_loop->num)\n-\t      /* Moving the computation from the loop may prolong life range\n-\t\t of some ssa names, which may cause problems if they appear\n-\t\t on abnormal edges.  */\n-\t      || contains_abnormal_ssa_name_p (def)\n-\t      /* Do not emit expensive expressions.  The rationale is that\n-\t\t when someone writes a code like\n-\n-\t\t while (n > 45) n -= 45;\n-\n-\t\t he probably knows that n is not large, and does not want it\n-\t\t to be turned into n %= 45.  */\n-\t      || expression_expensive_p (def))\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t          fprintf (dump_file, \"not replacing:\\n  \");\n-\t          print_gimple_stmt (dump_file, phi, 0, 0);\n-\t          fprintf (dump_file, \"\\n\");\n-\t\t}\n-\t      gsi_next (&psi);\n-\t      continue;\n-\t    }\n-\n-\t  /* Eliminate the PHI node and replace it by a computation outside\n-\t     the loop.  */\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"\\nfinal value replacement:\\n  \");\n-\t      print_gimple_stmt (dump_file, phi, 0, 0);\n-\t      fprintf (dump_file, \"  with\\n  \");\n-\t    }\n-\t  def = unshare_expr (def);\n-\t  remove_phi_node (&psi, false);\n-\n-\t  /* If def's type has undefined overflow and there were folded\n-\t     casts, rewrite all stmts added for def into arithmetics\n-\t     with defined overflow behavior.  */\n-\t  if (folded_casts && ANY_INTEGRAL_TYPE_P (TREE_TYPE (def))\n-\t      && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (def)))\n-\t    {\n-\t      gimple_seq stmts;\n-\t      gimple_stmt_iterator gsi2;\n-\t      def = force_gimple_operand (def, &stmts, true, NULL_TREE);\n-\t      gsi2 = gsi_start (stmts);\n-\t      while (!gsi_end_p (gsi2))\n-\t\t{\n-\t\t  gimple *stmt = gsi_stmt (gsi2);\n-\t\t  gimple_stmt_iterator gsi3 = gsi2;\n-\t\t  gsi_next (&gsi2);\n-\t\t  gsi_remove (&gsi3, false);\n-\t\t  if (is_gimple_assign (stmt)\n-\t\t      && arith_code_with_undefined_signed_overflow\n-\t\t\t\t\t(gimple_assign_rhs_code (stmt)))\n-\t\t    gsi_insert_seq_before (&gsi,\n-\t\t\t\t\t   rewrite_to_defined_overflow (stmt),\n-\t\t\t\t\t   GSI_SAME_STMT);\n-\t\t  else\n-\t\t    gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n-\t\t}\n-\t    }\n-\t  else\n-\t    def = force_gimple_operand_gsi (&gsi, def, false, NULL_TREE,\n-\t\t\t\t\t    true, GSI_SAME_STMT);\n-\n-\t  ass = gimple_build_assign (rslt, def);\n-\t  gsi_insert_before (&gsi, ass, GSI_SAME_STMT);\n-\t  if (dump_file)\n-\t    {\n-\t      print_gimple_stmt (dump_file, ass, 0, 0);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\t}\n-    }\n   return 0;\n }\n "}, {"sha": "29c7cd43189d3cceb508d537f078d646d522b986", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f993a85385e262572a1be89b15976ef47227964f/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f993a85385e262572a1be89b15976ef47227964f/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=f993a85385e262572a1be89b15976ef47227964f", "patch": "@@ -33,6 +33,7 @@ extern tree analyze_scalar_evolution (struct loop *, tree);\n extern tree instantiate_scev (basic_block, struct loop *, tree);\n extern tree resolve_mixers (struct loop *, tree, bool *);\n extern void gather_stats_on_scev_database (void);\n+extern void final_value_replacement_loop (struct loop *);\n extern unsigned int scev_const_prop (void);\n extern bool expression_expensive_p (tree);\n extern bool simple_iv (struct loop *, struct loop *, tree, struct affine_iv *,"}]}