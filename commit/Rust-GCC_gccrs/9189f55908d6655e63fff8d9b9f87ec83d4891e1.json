{"sha": "9189f55908d6655e63fff8d9b9f87ec83d4891e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE4OWY1NTkwOGQ2NjU1ZTYzZmZmOGQ5YjlmODdlYzgzZDQ4OTFlMQ==", "commit": {"author": {"name": "Tim Shen", "email": "timshen@google.com", "date": "2016-12-06T11:20:13Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2016-12-06T11:20:13Z"}, "message": "variant (std::get, operator==): Implement constexpr comparison and get<>.\n\n\t* include/std/variant (std::get, operator==): Implement constexpr\n\tcomparison and get<>.\n\t* testsuite/20_util/variant/compile.cc: Tests.\n\nFrom-SVN: r243293", "tree": {"sha": "bf3ff26cc7a4108bc3b3fed889dd652fe693a3ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf3ff26cc7a4108bc3b3fed889dd652fe693a3ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9189f55908d6655e63fff8d9b9f87ec83d4891e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9189f55908d6655e63fff8d9b9f87ec83d4891e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9189f55908d6655e63fff8d9b9f87ec83d4891e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9189f55908d6655e63fff8d9b9f87ec83d4891e1/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "44f46885959d501929eeca3d3618db6db6d50c77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44f46885959d501929eeca3d3618db6db6d50c77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44f46885959d501929eeca3d3618db6db6d50c77"}], "stats": {"total": 514, "additions": 335, "deletions": 179}, "files": [{"sha": "8a3ab43d665b5f2ca12a131fe8b70620515c2f02", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9189f55908d6655e63fff8d9b9f87ec83d4891e1/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9189f55908d6655e63fff8d9b9f87ec83d4891e1/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9189f55908d6655e63fff8d9b9f87ec83d4891e1", "patch": "@@ -1,3 +1,9 @@\n+2016-12-07  Tim Shen  <timshen@google.com>\n+\n+\t* include/std/variant (std::get, operator==): Implement constexpr\n+\tcomparison and get<>.\n+\t* testsuite/20_util/variant/compile.cc: Tests.\n+\n 2016-12-07  Tim Shen  <timshen@google.com>\n \n \t* include/std/variant (__erased_use_alloc_ctor,"}, {"sha": "a961a058a5693ad81bb2b54ddca0bcd7b56f58f4", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 240, "deletions": 161, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9189f55908d6655e63fff8d9b9f87ec83d4891e1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9189f55908d6655e63fff8d9b9f87ec83d4891e1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=9189f55908d6655e63fff8d9b9f87ec83d4891e1", "patch": "@@ -41,6 +41,7 @@\n #include <bits/functexcept.h>\n #include <bits/move.h>\n #include <bits/functional_hash.h>\n+#include <ext/aligned_buffer.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -153,33 +154,60 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Alternative>\n     using __storage = _Alternative;\n \n-  template<typename _Type, bool __is_literal = std::is_literal_type_v<_Type>>\n+  // _Uninitialized<T> is guaranteed to be a literal type, even if T is not.\n+  // We have to do this, because [basic.types]p10.5.3 (n4606) is not implemented\n+  // yet. When it's implemented, _Uninitialized<T> can be changed to the alias\n+  // to T, therefore equivalent to being removed entirely.\n+  //\n+  // Another reason we may not want to remove _Uninitialzied<T> may be that, we\n+  // want _Uninitialized<T> to be trivially destructible, no matter whether T\n+  // is; but we will see.\n+  template<typename _Type, bool = std::is_literal_type_v<_Type>>\n     struct _Uninitialized;\n \n   template<typename _Type>\n     struct _Uninitialized<_Type, true>\n     {\n-      constexpr _Uninitialized() = default;\n-\n       template<typename... _Args>\n       constexpr _Uninitialized(in_place_index_t<0>, _Args&&... __args)\n       : _M_storage(std::forward<_Args>(__args)...)\n       { }\n \n+      constexpr const _Type& _M_get() const &\n+      { return _M_storage; }\n+\n+      constexpr _Type& _M_get() &\n+      { return _M_storage; }\n+\n+      constexpr const _Type&& _M_get() const &&\n+      { return std::move(_M_storage); }\n+\n+      constexpr _Type&& _M_get() &&\n+      { return std::move(_M_storage); }\n+\n       _Type _M_storage;\n     };\n \n   template<typename _Type>\n     struct _Uninitialized<_Type, false>\n     {\n-      constexpr _Uninitialized() = default;\n-\n       template<typename... _Args>\n       constexpr _Uninitialized(in_place_index_t<0>, _Args&&... __args)\n       { ::new (&_M_storage) _Type(std::forward<_Args>(__args)...); }\n \n-      typename std::aligned_storage<sizeof(_Type), alignof(_Type)>::type\n-\t  _M_storage;\n+      const _Type& _M_get() const &\n+      { return *_M_storage._M_ptr(); }\n+\n+      _Type& _M_get() &\n+      { return *_M_storage._M_ptr(); }\n+\n+      const _Type&& _M_get() const &&\n+      { return std::move(*_M_storage._M_ptr()); }\n+\n+      _Type&& _M_get() &&\n+      { return std::move(*_M_storage._M_ptr()); }\n+\n+      __gnu_cxx::__aligned_membuf<_Type> _M_storage;\n     };\n \n   // Given a qualified storage type, return the desired reference.\n@@ -194,20 +222,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t*static_cast<_Storage*>(__ptr));\n     }\n \n+  template<typename _Union>\n+    constexpr decltype(auto) __get(in_place_index_t<0>, _Union&& __u)\n+    { return std::forward<_Union>(__u)._M_first._M_get(); }\n+\n+  template<size_t _Np, typename _Union>\n+    constexpr decltype(auto) __get(in_place_index_t<_Np>, _Union&& __u)\n+    { return __get(in_place_index<_Np-1>, std::forward<_Union>(__u)._M_rest); }\n+\n+  // Returns the typed storage for __v.\n+  template<size_t _Np, typename _Variant>\n+    constexpr decltype(auto) __get(_Variant&& __v)\n+    {\n+      return __get(std::in_place_index<_Np>, std::forward<_Variant>(__v)._M_u);\n+    }\n+\n   // Various functions as \"vtable\" entries, where those vtables are used by\n   // polymorphic operations.\n   template<typename _Lhs, typename _Rhs>\n     constexpr void\n     __erased_ctor(void* __lhs, void* __rhs)\n     { ::new (__lhs) decay_t<_Lhs>(__get_alternative<_Rhs>(__rhs)); }\n \n-  // TODO: Find a potential chance to reuse this accross the project.\n-  template<typename _Tp>\n+  template<typename _Variant, size_t _Np>\n     constexpr void\n-    __erased_dtor(void* __ptr)\n+    __erased_dtor(_Variant&& __v)\n     {\n-      using _Storage = decay_t<_Tp>;\n-      static_cast<_Storage*>(__ptr)->~_Storage();\n+      auto&& __element = __get<_Np>(std::forward<_Variant>(__v));\n+      using _Type = std::remove_reference_t<decltype(__element)>;\n+      __element.~_Type();\n     }\n \n   template<typename _Lhs, typename _Rhs>\n@@ -223,90 +266,108 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       swap(__get_alternative<_Lhs>(__lhs), __get_alternative<_Rhs>(__rhs));\n     }\n \n-  template<typename _Lhs, typename _Rhs>\n+  template<typename _Variant, size_t _Np>\n     constexpr bool\n-    __erased_equal_to(void* __lhs, void* __rhs)\n-    { return __get_alternative<_Lhs>(__lhs) == __get_alternative<_Rhs>(__rhs); }\n+    __erased_equal_to(_Variant&& __lhs, _Variant&& __rhs)\n+    {\n+      return __get<_Np>(std::forward<_Variant>(__lhs))\n+\t  == __get<_Np>(std::forward<_Variant>(__rhs));\n+    }\n \n-  template<typename _Lhs, typename _Rhs>\n+  template<typename _Variant, size_t _Np>\n     constexpr bool\n-    __erased_less_than(void* __lhs, void* __rhs)\n-    { return __get_alternative<_Lhs>(__lhs) < __get_alternative<_Rhs>(__rhs); }\n+    __erased_less_than(const _Variant& __lhs, const _Variant& __rhs)\n+    {\n+      return __get<_Np>(std::forward<_Variant>(__lhs))\n+\t  < __get<_Np>(std::forward<_Variant>(__rhs));\n+    }\n \n   template<typename _Tp>\n     constexpr size_t\n     __erased_hash(void* __t)\n     { return std::hash<decay_t<_Tp>>{}(__get_alternative<_Tp>(__t)); }\n \n+  // Defines members and ctors.\n   template<typename... _Types>\n-    struct _Variant_base;\n+    union _Variadic_union { };\n \n-  template<typename... _Types>\n-    struct _Variant_storage\n-    { constexpr _Variant_storage() = default; };\n-\n-  // Use recursive unions to implement a trivially destructible variant.\n   template<typename _First, typename... _Rest>\n-    struct _Variant_storage<_First, _Rest...>\n+    union _Variadic_union<_First, _Rest...>\n     {\n-      constexpr _Variant_storage() = default;\n+      constexpr _Variadic_union() : _M_rest() { }\n+\n+      template<typename... _Args>\n+\tconstexpr _Variadic_union(in_place_index_t<0>, _Args&&... __args)\n+\t: _M_first(in_place_index<0>, std::forward<_Args>(__args)...)\n+\t{ }\n+\n+      template<size_t _Np, typename... _Args>\n+\tconstexpr _Variadic_union(in_place_index_t<_Np>, _Args&&... __args)\n+\t: _M_rest(in_place_index<_Np-1>, std::forward<_Args>(__args)...)\n+\t{ }\n+\n+      _Uninitialized<_First> _M_first;\n+      _Variadic_union<_Rest...> _M_rest;\n+    };\n+\n+  // Defines index and the dtor, possibly trivial.\n+  template<bool __trivially_destructible, typename... _Types>\n+    struct _Variant_storage;\n+\n+  template<typename... _Types>\n+    struct _Variant_storage<false, _Types...>\n+    {\n+      template<size_t... __indices>\n+\tstatic constexpr void (*_S_vtable[])(const _Variant_storage&) =\n+\t    { &__erased_dtor<const _Variant_storage&, __indices>... };\n+\n+      constexpr _Variant_storage() : _M_index(variant_npos) { }\n \n       template<size_t _Np, typename... _Args>\n \tconstexpr _Variant_storage(in_place_index_t<_Np>, _Args&&... __args)\n-\t: _M_union(in_place_index<_Np>, std::forward<_Args>(__args)...)\n+\t: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),\n+\t_M_index(_Np)\n \t{ }\n \n-      ~_Variant_storage() = default;\n+      template<size_t... __indices>\n+\tconstexpr void _M_destroy_impl(std::index_sequence<__indices...>)\n+\t{\n+\t  if (_M_index != variant_npos)\n+\t    _S_vtable<__indices...>[_M_index](*this);\n+\t}\n \n-      constexpr void*\n-      _M_storage() const\n-      {\n-\treturn const_cast<void*>(\n-\t  static_cast<const void*>(std::addressof(_M_union._M_first._M_storage)));\n-      }\n+      ~_Variant_storage()\n+      { _M_destroy_impl(std::index_sequence_for<_Types...>{}); }\n \n-      union _Union\n-      {\n-\tconstexpr _Union() {};\n-\n-\ttemplate<typename... _Args>\n-\t  constexpr _Union(in_place_index_t<0>, _Args&&... __args)\n-\t  : _M_first(in_place_index<0>, std::forward<_Args>(__args)...)\n-\t  { }\n-\n-\ttemplate<size_t _Np, typename... _Args,\n-\t\t typename = enable_if_t<0 < _Np && _Np < sizeof...(_Rest) + 1>>\n-\t  constexpr _Union(in_place_index_t<_Np>, _Args&&... __args)\n-\t  : _M_rest(in_place_index<_Np - 1>, std::forward<_Args>(__args)...)\n-\t  { }\n-\n-\t_Uninitialized<__storage<_First>> _M_first;\n-\t_Variant_storage<_Rest...> _M_rest;\n-      } _M_union;\n+      _Variadic_union<_Types...> _M_u;\n+      size_t _M_index;\n     };\n \n-  template<typename _Derived, bool __is_trivially_destructible>\n-    struct _Dtor_mixin\n+  template<typename... _Types>\n+    struct _Variant_storage<true, _Types...>\n     {\n-      ~_Dtor_mixin()\n-      { static_cast<_Derived*>(this)->_M_destroy(); }\n-    };\n+      constexpr _Variant_storage() : _M_index(variant_npos) { }\n \n-  template<typename _Derived>\n-    struct _Dtor_mixin<_Derived, true>\n-    {\n-      ~_Dtor_mixin() = default;\n+      template<size_t _Np, typename... _Args>\n+\tconstexpr _Variant_storage(in_place_index_t<_Np>, _Args&&... __args)\n+\t: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),\n+\t_M_index(_Np)\n+\t{ }\n+\n+      _Variadic_union<_Types...> _M_u;\n+      size_t _M_index;\n     };\n \n   // Helps SFINAE on special member functions. Otherwise it can live in variant\n   // class.\n   template<typename... _Types>\n     struct _Variant_base :\n-      _Variant_storage<_Types...>,\n-      _Dtor_mixin<_Variant_base<_Types...>,\n-\t\t  __and_<std::is_trivially_destructible<_Types>...>::value>\n+      _Variant_storage<(std::is_trivially_destructible_v<_Types> && ...),\n+\t\t\t_Types...>\n     {\n-      using _Storage = _Variant_storage<_Types...>;\n+      using _Storage =\n+\t  _Variant_storage<(std::is_trivially_destructible_v<_Types> && ...),\n+\t\t\t    _Types...>;\n \n       constexpr\n       _Variant_base()\n@@ -315,39 +376,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       : _Variant_base(in_place_index<0>) { }\n \n       _Variant_base(const _Variant_base& __rhs)\n-      : _Storage(), _M_index(__rhs._M_index)\n       {\n \tif (__rhs._M_valid())\n \t  {\n \t    static constexpr void (*_S_vtable[])(void*, void*) =\n \t      { &__erased_ctor<__storage<_Types>&,\n \t\t\t       const __storage<_Types>&>... };\n \t    _S_vtable[__rhs._M_index](_M_storage(), __rhs._M_storage());\n+\t    this->_M_index = __rhs._M_index;\n \t  }\n       }\n \n       _Variant_base(_Variant_base&& __rhs)\n       noexcept(__and_<is_nothrow_move_constructible<_Types>...>::value)\n-      : _Storage(), _M_index(__rhs._M_index)\n       {\n \tif (__rhs._M_valid())\n \t  {\n \t    static constexpr void (*_S_vtable[])(void*, void*) =\n \t      { &__erased_ctor<__storage<_Types>&, __storage<_Types>&&>... };\n \t    _S_vtable[__rhs._M_index](_M_storage(), __rhs._M_storage());\n+\t    this->_M_index = __rhs._M_index;\n \t  }\n       }\n \n       template<size_t _Np, typename... _Args>\n \tconstexpr explicit\n \t_Variant_base(in_place_index_t<_Np> __i, _Args&&... __args)\n-\t: _Storage(__i, std::forward<_Args>(__args)...), _M_index(_Np)\n+\t: _Storage(__i, std::forward<_Args>(__args)...)\n \t{ }\n \n       _Variant_base&\n       operator=(const _Variant_base& __rhs)\n       {\n-\tif (_M_index == __rhs._M_index)\n+\tif (this->_M_index == __rhs._M_index)\n \t  {\n \t    if (__rhs._M_valid())\n \t      {\n@@ -367,11 +428,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      }\n \t    __catch (...)\n \t      {\n-\t\t_M_index = variant_npos;\n+\t\tthis->_M_index = variant_npos;\n \t\t__throw_exception_again;\n \t      }\n \t  }\n-\t__glibcxx_assert(_M_index == __rhs._M_index);\n+\t__glibcxx_assert(this->_M_index == __rhs._M_index);\n \treturn *this;\n       }\n \n@@ -380,7 +441,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       noexcept(__and_<is_nothrow_move_constructible<_Types>...,\n \t\t      is_nothrow_move_assignable<_Types>...>::value)\n       {\n-\tif (_M_index == __rhs._M_index)\n+\tif (this->_M_index == __rhs._M_index)\n \t  {\n \t    if (__rhs._M_valid())\n \t      {\n@@ -399,32 +460,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      }\n \t    __catch (...)\n \t      {\n-\t\t_M_index = variant_npos;\n+\t\tthis->_M_index = variant_npos;\n \t\t__throw_exception_again;\n \t      }\n \t  }\n \treturn *this;\n       }\n \n-      void _M_destroy()\n+      void*\n+      _M_storage() const\n       {\n-\tif (_M_valid())\n-\t  {\n-\t    static constexpr void (*_S_vtable[])(void*) =\n-\t      { &__erased_dtor<__storage<_Types>&>... };\n-\t    _S_vtable[this->_M_index](_M_storage());\n-\t  }\n+\treturn const_cast<void*>(static_cast<const void*>(\n+\t    std::addressof(_Storage::_M_u)));\n       }\n \n-      constexpr void*\n-      _M_storage() const\n-      { return _Storage::_M_storage(); }\n-\n       constexpr bool\n       _M_valid() const noexcept\n-      { return _M_index != variant_npos; }\n-\n-      size_t _M_index;\n+      { return this->_M_index != variant_npos; }\n     };\n \n   // For how many times does _Tp appear in _Tuple?\n@@ -489,15 +541,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void* __get_storage(_Variant&& __v)\n     { return __v._M_storage(); }\n \n-  // Returns the reference to the desired alternative.\n-  // It is as unsafe as a reinterpret_cast.\n-  template<typename _Tp, typename _Variant>\n-    decltype(auto) __access(_Variant&& __v)\n-    {\n-      return __get_alternative<__reserved_type_map<_Variant&&, __storage<_Tp>>>(\n-\t__get_storage(std::forward<_Variant>(__v)));\n-    }\n-\n   // A helper used to create variadic number of _To types.\n   template<typename _From, typename _To>\n     using _To_type = _To;\n@@ -597,9 +640,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_S_apply_all_alts(_Array_type& __vtable, index_sequence<__indices...>)\n \t{ (_S_apply_single_alt<__indices>(__vtable._M_arr[__indices]), ...); }\n \n-      template<size_t __index>\n+      template<size_t __index, typename _Tp>\n \tstatic constexpr void\n-\t_S_apply_single_alt(auto& __element)\n+\t_S_apply_single_alt(_Tp& __element)\n \t{\n \t  using _Alternative = variant_alternative_t<__index, decay_t<_First>>;\n \t  using _Qualified_storage = __reserved_type_map<\n@@ -655,23 +698,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<size_t _Np, typename... _Types>\n-    variant_alternative_t<_Np, variant<_Types...>>&\n+    constexpr variant_alternative_t<_Np, variant<_Types...>>&\n     get(variant<_Types...>&);\n \n   template<size_t _Np, typename... _Types>\n-    variant_alternative_t<_Np, variant<_Types...>>&&\n+    constexpr variant_alternative_t<_Np, variant<_Types...>>&&\n     get(variant<_Types...>&&);\n \n   template<size_t _Np, typename... _Types>\n-    variant_alternative_t<_Np, variant<_Types...>> const&\n+    constexpr variant_alternative_t<_Np, variant<_Types...>> const&\n     get(const variant<_Types...>&);\n \n   template<size_t _Np, typename... _Types>\n-    variant_alternative_t<_Np, variant<_Types...>> const&&\n+    constexpr variant_alternative_t<_Np, variant<_Types...>> const&&\n     get(const variant<_Types...>&&);\n \n   template<typename _Tp, typename... _Types>\n-    inline _Tp& get(variant<_Types...>& __v)\n+    constexpr inline _Tp& get(variant<_Types...>& __v)\n     {\n       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n \t\t    \"T should occur for exactly once in alternatives\");\n@@ -680,7 +723,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Tp, typename... _Types>\n-    inline _Tp&& get(variant<_Types...>&& __v)\n+    constexpr inline _Tp&& get(variant<_Types...>&& __v)\n     {\n       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n \t\t    \"T should occur for exactly once in alternatives\");\n@@ -690,7 +733,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Tp, typename... _Types>\n-    inline const _Tp& get(const variant<_Types...>& __v)\n+    constexpr inline const _Tp& get(const variant<_Types...>& __v)\n     {\n       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n \t\t    \"T should occur for exactly once in alternatives\");\n@@ -699,7 +742,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Tp, typename... _Types>\n-    inline const _Tp&& get(const variant<_Types...>&& __v)\n+    constexpr inline const _Tp&& get(const variant<_Types...>&& __v)\n     {\n       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n \t\t    \"T should occur for exactly once in alternatives\");\n@@ -709,33 +752,36 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<size_t _Np, typename... _Types>\n-    inline add_pointer_t<variant_alternative_t<_Np, variant<_Types...>>>\n+    constexpr inline\n+    add_pointer_t<variant_alternative_t<_Np, variant<_Types...>>>\n     get_if(variant<_Types...>* __ptr) noexcept\n     {\n       using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;\n       static_assert(_Np < sizeof...(_Types),\n \t\t    \"The index should be in [0, number of alternatives)\");\n       static_assert(!is_void_v<_Alternative_type>, \"_Tp should not be void\");\n       if (__ptr && __ptr->index() == _Np)\n-\treturn &__detail::__variant::__access<_Alternative_type>(*__ptr);\n+\treturn &__detail::__variant::__get<_Np>(*__ptr);\n       return nullptr;\n     }\n \n   template<size_t _Np, typename... _Types>\n-    inline add_pointer_t<const variant_alternative_t<_Np, variant<_Types...>>>\n+    constexpr inline\n+    add_pointer_t<const variant_alternative_t<_Np, variant<_Types...>>>\n     get_if(const variant<_Types...>* __ptr) noexcept\n     {\n       using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;\n       static_assert(_Np < sizeof...(_Types),\n \t\t    \"The index should be in [0, number of alternatives)\");\n       static_assert(!is_void_v<_Alternative_type>, \"_Tp should not be void\");\n       if (__ptr && __ptr->index() == _Np)\n-\treturn &__detail::__variant::__access<_Alternative_type>(*__ptr);\n+\treturn &__detail::__variant::__get<_Np>(*__ptr);\n       return nullptr;\n     }\n \n   template<typename _Tp, typename... _Types>\n-    inline add_pointer_t<_Tp> get_if(variant<_Types...>* __ptr) noexcept\n+    constexpr inline add_pointer_t<_Tp>\n+    get_if(variant<_Types...>* __ptr) noexcept\n     {\n       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n \t\t    \"T should occur for exactly once in alternatives\");\n@@ -744,7 +790,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Tp, typename... _Types>\n-    inline add_pointer_t<const _Tp> get_if(const variant<_Types...>* __ptr)\n+    constexpr inline add_pointer_t<const _Tp>\n+    get_if(const variant<_Types...>* __ptr)\n     noexcept\n     {\n       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,\n@@ -754,64 +801,36 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename... _Types>\n-    bool operator==(const variant<_Types...>& __lhs,\n-\t\t    const variant<_Types...>& __rhs)\n+    constexpr bool operator==(const variant<_Types...>& __lhs,\n+\t\t\t      const variant<_Types...>& __rhs)\n     {\n-      if (__lhs.index() != __rhs.index())\n-\treturn false;\n-\n-      if (__lhs.valueless_by_exception())\n-\treturn true;\n-\n-      using __detail::__variant::__storage;\n-      static constexpr bool (*_S_vtable[])(void*, void*) =\n-\t{ &__detail::__variant::__erased_equal_to<\n-\t  const __storage<_Types>&, const __storage<_Types>&>... };\n-      return _S_vtable[__lhs.index()](\n-\t  __detail::__variant::__get_storage(__lhs),\n-\t  __detail::__variant::__get_storage(__rhs));\n+      return __lhs._M_equal_to(__rhs, std::index_sequence_for<_Types...>{});\n     }\n \n   template<typename... _Types>\n-    inline bool\n+    constexpr inline bool\n     operator!=(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)\n     { return !(__lhs == __rhs); }\n \n   template<typename... _Types>\n-    inline bool\n+    constexpr inline bool\n     operator<(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)\n     {\n-      if (__lhs.index() < __rhs.index())\n-\treturn true;\n-\n-      if (__lhs.index() > __rhs.index())\n-\treturn false;\n-\n-      if (__lhs.valueless_by_exception())\n-\treturn false;\n-\n-      using __detail::__variant::__storage;\n-      static constexpr bool (*_S_vtable[])(void*, void*) =\n-\t{ &__detail::__variant::__erased_less_than<\n-\t    const __storage<_Types>&,\n-\t    const __storage<_Types>&>... };\n-      return _S_vtable[__lhs.index()](\n-\t  __detail::__variant::__get_storage(__lhs),\n-\t  __detail::__variant::__get_storage(__rhs));\n+      return __lhs._M_less_than(__rhs, std::index_sequence_for<_Types...>{});\n     }\n \n   template<typename... _Types>\n-    inline bool\n+    constexpr inline bool\n     operator>(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)\n     { return __rhs < __lhs; }\n \n   template<typename... _Types>\n-    inline bool\n+    constexpr inline bool\n     operator<=(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)\n     { return !(__lhs > __rhs); }\n \n   template<typename... _Types>\n-    inline bool\n+    constexpr inline bool\n     operator>=(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)\n     { return !(__lhs < __rhs); }\n \n@@ -1102,60 +1121,120 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  }\n       }\n \n+    private:\n+      template<size_t... __indices>\n+\tstatic constexpr bool\n+\t(*_S_equal_to_vtable[])(const variant&, const variant&) =\n+\t  { &__detail::__variant::__erased_equal_to<\n+\t    const variant&, __indices>... };\n+\n+      template<size_t... __indices>\n+\tstatic constexpr bool\n+\t(*_S_less_than_vtable[])(const variant&, const variant&) =\n+\t  { &__detail::__variant::__erased_less_than<\n+\t      const variant&, __indices>... };\n+\n+      template<size_t... __indices>\n+\tconstexpr bool\n+\t_M_equal_to(const variant& __rhs,\n+\t\t    std::index_sequence<__indices...>) const\n+\t{\n+\t  if (this->index() != __rhs.index())\n+\t    return false;\n+\n+\t  if (this->valueless_by_exception())\n+\t    return true;\n+\n+\t  return _S_equal_to_vtable<__indices...>[this->index()](*this, __rhs);\n+\t}\n+\n+      template<size_t... __indices>\n+\tconstexpr inline bool\n+\t_M_less_than(const variant& __rhs,\n+\t\t     std::index_sequence<__indices...>) const\n+\t{\n+\t  auto __lhs_index = this->index();\n+\t  auto __rhs_index = __rhs.index();\n+\n+\t  if (__lhs_index < __rhs_index)\n+\t    return true;\n+\n+\t  if (__lhs_index > __rhs_index)\n+\t    return false;\n+\n+\t  if (this->valueless_by_exception())\n+\t    return false;\n+\n+\t  return _S_less_than_vtable<__indices...>[__lhs_index](*this, __rhs);\n+\t}\n+\n+      template<size_t _Np, typename _Vp>\n+\tfriend constexpr decltype(auto) __detail::__variant::\n+#if _GLIBCXX_INLINE_VERSION\n+        __7:: // Required due to PR c++/59256\n+#endif\n+\t__get(_Vp&& __v);\n+\n       template<typename _Vp>\n \tfriend void* __detail::__variant::\n #if _GLIBCXX_INLINE_VERSION\n         __7:: // Required due to PR c++/59256\n #endif\n         __get_storage(_Vp&& __v);\n+\n+      template<typename... _Tp>\n+\tfriend constexpr bool\n+\toperator==(const variant<_Tp...>& __lhs,\n+\t\t   const variant<_Tp...>& __rhs);\n+\n+      template<typename... _Tp>\n+\tfriend constexpr bool\n+\toperator<(const variant<_Tp...>& __lhs,\n+\t\t  const variant<_Tp...>& __rhs);\n     };\n \n   template<size_t _Np, typename... _Types>\n-    variant_alternative_t<_Np, variant<_Types...>>&\n+    constexpr variant_alternative_t<_Np, variant<_Types...>>&\n     get(variant<_Types...>& __v)\n     {\n       static_assert(_Np < sizeof...(_Types),\n \t\t    \"The index should be in [0, number of alternatives)\");\n       if (__v.index() != _Np)\n \t__throw_bad_variant_access(\"Unexpected index\");\n-      return __detail::__variant::__access<\n-\tvariant_alternative_t<_Np, variant<_Types...>>>(__v);\n+      return __detail::__variant::__get<_Np>(__v);\n     }\n \n   template<size_t _Np, typename... _Types>\n-    variant_alternative_t<_Np, variant<_Types...>>&&\n+    constexpr variant_alternative_t<_Np, variant<_Types...>>&&\n     get(variant<_Types...>&& __v)\n     {\n       static_assert(_Np < sizeof...(_Types),\n \t\t    \"The index should be in [0, number of alternatives)\");\n       if (__v.index() != _Np)\n \t__throw_bad_variant_access(\"Unexpected index\");\n-      return __detail::__variant::__access<\n-\tvariant_alternative_t<_Np, variant<_Types...>>>(std::move(__v));\n+      return __detail::__variant::__get<_Np>(std::move(__v));\n     }\n \n   template<size_t _Np, typename... _Types>\n-    const variant_alternative_t<_Np, variant<_Types...>>&\n+    constexpr const variant_alternative_t<_Np, variant<_Types...>>&\n     get(const variant<_Types...>& __v)\n     {\n       static_assert(_Np < sizeof...(_Types),\n \t\t    \"The index should be in [0, number of alternatives)\");\n       if (__v.index() != _Np)\n \t__throw_bad_variant_access(\"Unexpected index\");\n-      return __detail::__variant::__access<\n-\tvariant_alternative_t<_Np, variant<_Types...>>>(__v);\n+      return __detail::__variant::__get<_Np>(__v);\n     }\n \n   template<size_t _Np, typename... _Types>\n-    const variant_alternative_t<_Np, variant<_Types...>>&&\n+    constexpr const variant_alternative_t<_Np, variant<_Types...>>&&\n     get(const variant<_Types...>&& __v)\n     {\n       static_assert(_Np < sizeof...(_Types),\n \t\t    \"The index should be in [0, number of alternatives)\");\n       if (__v.index() != _Np)\n \t__throw_bad_variant_access(\"Unexpected index\");\n-      return __detail::__variant::__access<\n-\tvariant_alternative_t<_Np, variant<_Types...>>>(std::move(__v));\n+      return __detail::__variant::__get<_Np>(std::move(__v));\n     }\n \n   template<typename _Visitor, typename... _Variants>"}, {"sha": "ab8ada2e9191816d78027e359785e6252b507da4", "filename": "libstdc++-v3/testsuite/20_util/variant/compile.cc", "status": "modified", "additions": 89, "deletions": 18, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9189f55908d6655e63fff8d9b9f87ec83d4891e1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9189f55908d6655e63fff8d9b9f87ec83d4891e1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc?ref=9189f55908d6655e63fff8d9b9f87ec83d4891e1", "patch": "@@ -51,6 +51,14 @@ struct DefaultNoexcept\n   DefaultNoexcept& operator=(DefaultNoexcept&&) noexcept = default;\n };\n \n+struct nonliteral\n+{\n+  nonliteral() { }\n+\n+  bool operator<(const nonliteral&) const;\n+  bool operator==(const nonliteral&) const;\n+};\n+\n void default_ctor()\n {\n   static_assert(is_default_constructible_v<variant<int, string>>, \"\");\n@@ -175,22 +183,40 @@ void test_get()\n void test_relational()\n {\n   {\n-    const variant<int, string> a, b;\n-    (void)(a < b);\n-    (void)(a > b);\n-    (void)(a <= b);\n-    (void)(a == b);\n-    (void)(a != b);\n-    (void)(a >= b);\n+    constexpr variant<int, nonliteral> a(42), b(43);\n+    static_assert((a < b), \"\");\n+    static_assert(!(a > b), \"\");\n+    static_assert((a <= b), \"\");\n+    static_assert(!(a == b), \"\");\n+    static_assert((a != b), \"\");\n+    static_assert(!(a >= b), \"\");\n   }\n   {\n-    const monostate a, b;\n-    (void)(a < b);\n-    (void)(a > b);\n-    (void)(a <= b);\n-    (void)(a == b);\n-    (void)(a != b);\n-    (void)(a >= b);\n+    constexpr variant<int, nonliteral> a(42), b(42);\n+    static_assert(!(a < b), \"\");\n+    static_assert(!(a > b), \"\");\n+    static_assert((a <= b), \"\");\n+    static_assert((a == b), \"\");\n+    static_assert(!(a != b), \"\");\n+    static_assert((a >= b), \"\");\n+  }\n+  {\n+    constexpr variant<int, nonliteral> a(43), b(42);\n+    static_assert(!(a < b), \"\");\n+    static_assert((a > b), \"\");\n+    static_assert(!(a <= b), \"\");\n+    static_assert(!(a == b), \"\");\n+    static_assert((a != b), \"\");\n+    static_assert((a >= b), \"\");\n+  }\n+  {\n+    constexpr monostate a, b;\n+    static_assert(!(a < b), \"\");\n+    static_assert(!(a > b), \"\");\n+    static_assert((a <= b), \"\");\n+    static_assert((a == b), \"\");\n+    static_assert(!(a != b), \"\");\n+    static_assert((a >= b), \"\");\n   }\n }\n \n@@ -262,14 +288,59 @@ void test_constexpr()\n \tconstexpr literal() = default;\n     };\n \n-    struct nonliteral {\n-\tnonliteral() { }\n-    };\n-\n     constexpr variant<literal, nonliteral> v{};\n     constexpr variant<literal, nonliteral> v1{in_place_type<literal>};\n     constexpr variant<literal, nonliteral> v2{in_place_index<0>};\n   }\n+\n+  {\n+    constexpr variant<int> a(42);\n+    static_assert(get<0>(a) == 42, \"\");\n+  }\n+  {\n+    constexpr variant<int, nonliteral> a(42);\n+    static_assert(get<0>(a) == 42, \"\");\n+  }\n+  {\n+    constexpr variant<nonliteral, int> a(42);\n+    static_assert(get<1>(a) == 42, \"\");\n+  }\n+  {\n+    constexpr variant<int> a(42);\n+    static_assert(get<int>(a) == 42, \"\");\n+  }\n+  {\n+    constexpr variant<int, nonliteral> a(42);\n+    static_assert(get<int>(a) == 42, \"\");\n+  }\n+  {\n+    constexpr variant<nonliteral, int> a(42);\n+    static_assert(get<int>(a) == 42, \"\");\n+  }\n+  {\n+    constexpr variant<int> a(42);\n+    static_assert(get<0>(std::move(a)) == 42, \"\");\n+  }\n+  {\n+    constexpr variant<int, nonliteral> a(42);\n+    static_assert(get<0>(std::move(a)) == 42, \"\");\n+  }\n+  {\n+    constexpr variant<nonliteral, int> a(42);\n+    static_assert(get<1>(std::move(a)) == 42, \"\");\n+  }\n+  {\n+    constexpr variant<int> a(42);\n+    static_assert(get<int>(std::move(a)) == 42, \"\");\n+  }\n+  {\n+    constexpr variant<int, nonliteral> a(42);\n+    static_assert(get<int>(std::move(a)) == 42, \"\");\n+  }\n+  {\n+    constexpr variant<nonliteral, int> a(42);\n+    static_assert(get<int>(std::move(a)) == 42, \"\");\n+  }\n }\n \n void test_pr77641()"}]}