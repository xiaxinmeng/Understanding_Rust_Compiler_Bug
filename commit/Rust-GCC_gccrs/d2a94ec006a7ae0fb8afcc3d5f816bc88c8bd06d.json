{"sha": "d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJhOTRlYzAwNmE3YWUwZmI4YWZjYzNkNWY4MTZiYzg4YzhiZDA2ZA==", "commit": {"author": {"name": "Timothy Moore", "email": "moore@gnu.org", "date": "1992-10-14T14:50:17Z"}, "committer": {"name": "Timothy Moore", "email": "moore@gnu.org", "date": "1992-10-14T14:50:17Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r2460", "tree": {"sha": "bdd6c0d148307229409a4445e234f40d777b4250", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdd6c0d148307229409a4445e234f40d777b4250"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d/comments", "author": null, "committer": null, "parents": [{"sha": "12c83d0b3529153a3725d4f28db68b50ab967fdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12c83d0b3529153a3725d4f28db68b50ab967fdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12c83d0b3529153a3725d4f28db68b50ab967fdd"}], "stats": {"total": 610, "additions": 450, "deletions": 160}, "files": [{"sha": "52ab59b1669b9674c843796245926441be7ff418", "filename": "gcc/config/pa/pa-hpux.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d/gcc%2Fconfig%2Fpa%2Fpa-hpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d/gcc%2Fconfig%2Fpa%2Fpa-hpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-hpux.h?ref=d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d", "patch": "@@ -25,3 +25,11 @@\n \n #undef CPP_PREDEFINES\n #define CPP_PREDEFINES \"-Dhppa -Dhp9000s800 -D__hp9000s800 -Dhp9k8 -DPWB -Dhpux -Dunix -D_HPUX_SOURCE\"\n+\n+/* Link against shared libraries */\n+#ifdef hpux8\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT 8 \n+#undef LINK_SPEC\n+#define LINK_SPEC \"-u main %{g*:-a archive} %{p:-a archive} %{pg:-a archive}\"\n+#endif"}, {"sha": "ddc7f9e9eb53ca5ad5c9bb3cea0a52dc09f40a09", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 107, "deletions": 80, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d", "patch": "@@ -33,6 +33,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"tree.h\"\n #include \"c-tree.h\"\n #include \"expr.h\"\n+#include \"obstack.h\"\n \n /* Save the operands last given to a compare for use when we\n    generate a scc or bcc insn.  */\n@@ -204,6 +205,22 @@ fp_reg_operand (op, mode)\n {\n   return reg_renumber && FP_REG_P (op);\n }\n+\n+int\n+check_fp_mov (operands)\n+     rtx *operands;\n+{\n+  enum machine_mode mode = GET_MODE (operands[0]);\n+\n+  if (fp_reg_operand (operands[0], mode))\n+    return (register_operand (operands[1], mode)\n+\t    || short_memory_operand (operands[1], mode));\n+  else if (fp_reg_operand (operands[1], mode))\n+    return (register_operand (operands[0], mode)\n+\t    || short_memory_operand (operands[0], mode));\n+  else\n+    return 1;\n+}\n \f\n extern int current_function_uses_pic_offset_table;\n extern rtx force_reg (), validize_mem ();\n@@ -481,63 +498,6 @@ initialize_pic ()\n void\n finalize_pic ()\n {\n-  /* The table we use to reference PIC data.  */\n-  rtx global_offset_table;\n-  /* Labels to get the PC in the prologue of this function.  */\n-  rtx l1, l2;\n-  rtx seq;\n-  int orig_flag_pic = flag_pic;\n-\n-  if (current_function_uses_pic_offset_table == 0)\n-    return;\n-\n-  if (! flag_pic)\n-    abort ();\n-\n-  flag_pic = 0;\n-  l1 = gen_label_rtx ();\n-  l2 = gen_label_rtx ();\n-\n-  start_sequence ();\n-\n-  emit_label (l1);\n-  /* Note that we pun calls and jumps here!  */\n-  emit_jump_insn (gen_rtx (PARALLEL, VOIDmode,\n-                         gen_rtvec (2,\n-                                    gen_rtx (SET, VOIDmode, pc_rtx, gen_rtx (LABEL_REF, VOIDmode, l2)),\n-                                    gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, 15), gen_rtx (LABEL_REF, VOIDmode, l2)))));\n-  emit_label (l2);\n-\n-  /* Initialize every time through, since we can't easily\n-     know this to be permanent.  */\n-  global_offset_table = gen_rtx (SYMBOL_REF, Pmode, \"*__GLOBAL_OFFSET_TABLE_\");\n-  pic_pc_rtx = gen_rtx (CONST, Pmode,\n-\t\t\tgen_rtx (MINUS, Pmode,\n-\t\t\t\t global_offset_table,\n-\t\t\t\t gen_rtx (CONST, Pmode,\n-\t\t\t\t\t  gen_rtx (MINUS, Pmode,\n-\t\t\t\t\t\t   gen_rtx (LABEL_REF, VOIDmode, l1),\n-\t\t\t\t\t\t   pc_rtx))));\n-\n-  emit_insn (gen_rtx (SET, VOIDmode, pic_offset_table_rtx,\n-\t\t      gen_rtx (HIGH, Pmode, pic_pc_rtx)));\n-  emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t      pic_offset_table_rtx,\n-\t\t      gen_rtx (LO_SUM, Pmode,\n-\t\t\t       pic_offset_table_rtx, pic_pc_rtx)));\n-  emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t      pic_offset_table_rtx,\n-\t\t      gen_rtx (PLUS, SImode,\n-\t\t\t       pic_offset_table_rtx, gen_rtx (REG, SImode, 15))));\n-  /* emit_insn (gen_rtx (ASM_INPUT, VOIDmode, \"!#PROLOGUE# 1\")); */\n-  LABEL_PRESERVE_P (l1) = 1;\n-  LABEL_PRESERVE_P (l2) = 1;\n-  flag_pic = orig_flag_pic;\n-\n-  seq = gen_sequence ();\n-  end_sequence ();\n-  emit_insn_after (seq, get_insns ());\n-\n   /* Need to emit this whether or not we obey regdecls,\n      since setjmp/longjmp can cause life info to screw up.  */\n   emit_insn (gen_rtx (USE, VOIDmode, pic_offset_table_rtx));\n@@ -570,15 +530,36 @@ hppa_address_cost (X)\n    normally.  */\n \n int\n-emit_move_sequence (operands, mode)\n+emit_move_sequence (operands, mode, scratch_reg)\n      rtx *operands;\n      enum machine_mode mode;\n+     rtx scratch_reg;\n {\n   register rtx operand0 = operands[0];\n   register rtx operand1 = operands[1];\n \n-  /* Handle most common case first: storing into a register.  */\n-  if (register_operand (operand0, mode))\n+  if (fp_reg_operand (operand0, mode)\n+      && GET_CODE (operand1) == MEM\n+      && !short_memory_operand  (operand1, mode)\n+      && scratch_reg)\n+    {\n+      emit_move_insn (scratch_reg, XEXP (operand1 , 0));\n+      emit_insn (gen_rtx (SET, VOIDmode, operand0, gen_rtx (MEM, mode,\n+\t\t\t\t\t\t\t    scratch_reg)));\n+      return 1;\n+    }\n+  else if (fp_reg_operand (operand1, mode)\n+\t   && GET_CODE (operand0) == MEM\n+\t   && !short_memory_operand  (operand0, mode)\n+\t   && scratch_reg)\n+    {\n+      emit_move_insn (scratch_reg, XEXP (operand0 , 0));\n+      emit_insn (gen_rtx (SET, VOIDmode, gen_rtx (MEM, mode,  scratch_reg),\n+\t\t\t  operand1));\n+      return 1;\n+    }\n+  /* Handle most common case: storing into a register.  */\n+  else if (register_operand (operand0, mode))\n     {\n       if (register_operand (operand1, mode)\n \t  || (GET_CODE (operand1) == CONST_INT && SMALL_INT (operand1))\n@@ -608,21 +589,6 @@ emit_move_sequence (operands, mode)\n     }\n \n   /* Simplify the source if we need to.  */\n-#if 0\n-  if (GET_CODE (operand1) == HIGH\n-      && symbolic_operand (XEXP (operand1, 0), mode)\n-      && !read_only_operand (XEXP (operand1, 0)))\n-    {\n-      rtx temp = reload_in_progress ? operand0 : gen_reg_rtx (mode);\n-      \n-      emit_insn (gen_rtx (SET, VOIDmode, temp, operand1));\n-      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t  operand0,\n-\t\t\t  gen_rtx (PLUS, mode,\n-\t\t\t\t   temp, gen_rtx (REG, mode, 27))));\n-      return 1;\n-    }\n-#endif\n   if (GET_CODE (operand1) != HIGH && immediate_operand (operand1, mode))\n     {\n       if (symbolic_operand (operand1, mode))\n@@ -636,12 +602,28 @@ emit_move_sequence (operands, mode)\n \t  /* use dp, register 27. */\n \t  else if (read_only_operand (operand1))\n \t    {\n-\t      emit_insn (gen_rtx (SET, VOIDmode,\n+\t      rtx set = gen_rtx (SET, VOIDmode,\n \t\t\t\t  operand0,\n-\t\t\t\t  gen_rtx (HIGH, mode, operand1)));\n+\t\t\t\t  gen_rtx (LO_SUM, mode, operand0, operand1));\n+\t\t\t\t \n \t      emit_insn (gen_rtx (SET, VOIDmode,\n \t\t\t\t  operand0,\n-\t\t\t\t  gen_rtx (LO_SUM, mode, operand0, operand1)));\n+\t\t\t\t  gen_rtx (HIGH, mode, operand1)));\n+\t      if (TARGET_SHARED_LIBS\n+\t\t  && function_label_operand (operand1, mode))\n+\t\t{\n+\t\t  rtx temp = reload_in_progress ? scratch_reg\n+\t\t    : gen_reg_rtx (mode);\n+\t\t  if (!temp)\n+\t\t    abort ();\n+\t\t  emit_insn (gen_rtx (PARALLEL, VOIDmode,\n+\t\t\t\t      gen_rtvec (2,\n+\t\t\t\t\t\t set,\n+\t\t\t\t\t\t gen_rtx (CLOBBER, VOIDmode,\n+\t\t\t\t\t\t\t  temp))));\n+\t\t}\n+\t      else\n+\t\temit_insn (set);\n \t      return 1;\n \t    }\n \t  else\n@@ -1223,7 +1205,7 @@ char *\n output_and (operands)\n      rtx *operands;\n {\n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) != 0)\n     {\n       unsigned mask = INTVAL (operands[2]);\n       int ls0, ls1, ms0, p, len;\n@@ -1494,6 +1476,7 @@ output_function_prologue (file, size, leaf_function)\n {\n   extern char call_used_regs[];\n   extern int frame_pointer_needed;\n+  extern int current_function_returns_struct;\n   int i, offset;\n \n   actual_fsize = compute_frame_size (size, leaf_function) + 32;\n@@ -1537,6 +1520,12 @@ output_function_prologue (file, size, leaf_function)\n \tfprintf (file, \"\\taddil L'%d,30\\n\\tldo R'%d(1),30\\n\",\n \t\t actual_fsize, actual_fsize);\n     }\n+  /* The hppa calling conventions say that that %r19, the pic offset \n+     register, is saved at sp - 32 (in this function's frame) */\n+  if (flag_pic)\n+    {\n+      fprintf (file, \"\\tstw %%r19,-32(%%r30)\\n\");\n+    }\n   /* Instead of taking one argument, the counter label, as most normal\n      mcounts do, _mcount appears to behave differently on the HPPA. It\n      takes the return address of the caller, the address of this\n@@ -1561,6 +1550,8 @@ output_function_prologue (file, size, leaf_function)\n \t\t\t\t     : STACK_POINTER_REGNUM;\n       offsetadj = frame_pointer_needed ? 0 : actual_fsize;\n \n+      if (current_function_returns_struct)\n+\tprint_stw (file, STRUCT_VALUE_REGNUM, - 12 - offsetadj, basereg);\n       for (i = 26, arg_offset = -36 - offsetadj; i >= 23; i--, arg_offset -= 4)\n \tif (regs_ever_live[i])\n \t  {\n@@ -1578,6 +1569,8 @@ output_function_prologue (file, size, leaf_function)\n       for (i = 26, arg_offset = -36 - offsetadj; i >= 23; i--, arg_offset -= 4)\n \tif (regs_ever_live[i])\n \t  print_ldw (file, i, arg_offset, basereg);\n+      if (current_function_returns_struct)\n+\tprint_ldw (file, STRUCT_VALUE_REGNUM, - 12 - offsetadj, basereg);\n     }\n \n   /* Normal register save. */\n@@ -2385,7 +2378,13 @@ secondary_reload_class (class, mode, in)\n {\n   int regno = true_regnum (in);\n \n-  if (class == SHIFT_REGS && (regno <= 0 || regno >= 32))\n+  if ((TARGET_SHARED_LIBS && function_label_operand (in, mode))\n+      || ((regno >= FIRST_PSEUDO_REGISTER || regno == -1)\n+\t  && ((mode == QImode || mode == HImode || mode == SImode\n+\t       || mode == DImode) \n+\t      && (class == FP_REGS || class == SNAKE_FP_REGS\n+\t\t  || class == HI_SNAKE_FP_REGS)))\n+      || (class == SHIFT_REGS && (regno <= 0 || regno >= 32)))\n     return GENERAL_REGS;\n \n   return NO_REGS;\n@@ -2448,3 +2447,31 @@ hppa_builtin_saveregs (arglist)\n \t\t\t\t    current_function_internal_arg_pointer,\n \t\t\t\t    offset, 0, 0, OPTAB_LIB_WIDEN));\n }\n+\n+extern struct obstack *saveable_obstack;\n+\n+/* In HPUX 8.0's shared library scheme, special relocations are needed\n+   for function labels if they might be passed to a function \n+   in a shared library (because shared libraries don't live in code\n+   space), and special magic is needed to construct their address. */\n+\n+void\n+hppa_encode_label (sym)\n+     rtx sym;\n+{\n+  char *str = XSTR (sym, 0);\n+  int len = strlen (str);\n+  char *newstr = obstack_alloc (saveable_obstack, len + 2) ;\n+\n+  strcpy (newstr + 1, str);\n+  newstr[0] = '@';\n+  XSTR (sym,0) = newstr;\n+}\n+  \n+int\n+function_label_operand  (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return GET_CODE (op) == SYMBOL_REF && (XSTR (op, 0))[0] == '@';\n+}"}, {"sha": "8ab532334d05ef9ae62a75dd5e3811707e3c9273", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 49, "deletions": 13, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d", "patch": "@@ -106,6 +106,11 @@ extern int target_flags;\n \n #define TARGET_KERNEL (target_flags & 4)\n \n+/* Generate code that will link against HPUX 8.0 shared libraries.\n+   Older linkers and assemblers might not support this. */\n+\n+#define TARGET_SHARED_LIBS (target_flags & 8)\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n@@ -119,6 +124,8 @@ extern int target_flags;\n    {\"pa-risc-1-1\", 1},\t\\\n    {\"no-bss\", 2},\t\\\n    {\"kernel\", 4},\t\\\n+   {\"shared-libs\", 8},\t\\\n+   {\"no-shared-libs\", -8},\\\n    { \"\", TARGET_DEFAULT}}\n \n #define TARGET_DEFAULT 0\n@@ -233,7 +240,8 @@ extern int target_flags;\n    Reg 3\t= Unused\n    Reg 4\t= Frame Pointer (Gnu)\n    Reg 5-18\t= Preserved Registers\n-   Reg 19-22\t= Temporary Registers\n+   Reg 19\t= Linkage Table Register in HPUX 8.0 shared library scheme.\n+   Reg 20-22\t= Temporary Registers\n    Reg 23-26\t= Temporary/Parameter Registers\n    Reg 27\t= Global Data Pointer (hp)\n    Reg 28\t= Temporary/???/Return Value register\n@@ -376,12 +384,20 @@ extern int target_flags;\n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    On the HP-PA, the cpu registers can hold any mode.  We\n    force this to be an even register is it cannot hold the full mode.  */\n+#if 0\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   ((REGNO) == 0 ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\\\n    : (REGNO) < 32 ? ((GET_MODE_SIZE (MODE) <= 4) ? 1 : ((REGNO) & 1) == 0)\\\n    : (REGNO) < 48 ? (GET_MODE_SIZE (MODE) >= 4)\t\t\t\t\\\n    : (GET_MODE_SIZE (MODE) > 4 ? ((REGNO) & 1) == 0\t\t\t\\\n       : GET_MODE_SIZE (MODE) == 4))\n+#endif\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+  ((REGNO) == 0 ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\\\n+   : (REGNO) < 32 ? ((GET_MODE_SIZE (MODE) <= 4) ? 1 : ((REGNO) & 1) == 0)\\\n+   : (REGNO) < 48 ? (GET_MODE_SIZE (MODE) >= 4)\t\t\t\t\\\n+   : (GET_MODE_SIZE (MODE) > 4 ? ((REGNO) & 1) == 0\t\t\t\\\n+      : 1))\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n@@ -431,7 +447,7 @@ extern int leaf_function;\n /* Register which holds offset table for position-independent\n    data references.  */\n \n-#define PIC_OFFSET_TABLE_REGNUM 18\n+#define PIC_OFFSET_TABLE_REGNUM 19\n \n #define INITIALIZE_PIC initialize_pic ()\n #define FINALIZE_PIC finalize_pic ()\n@@ -462,11 +478,14 @@ extern int leaf_function;\n \n   /* The HP-PA has four kinds of registers: general regs, 1.0 fp regs,\n      1.1 fp regs, and the high 1.1 fp regs, to which the operands of\n-     fmpyadd and fmpysub are restricted. */\n+     fmpyadd and fmpysub are restricted.\n+\n+     FP_OR_SNAKE_FP_REGS is for reload_{in,out}di only and isn't used\n+     anywhere else.*/\n \n enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n   HI_SNAKE_FP_REGS, SNAKE_FP_REGS, GENERAL_OR_SNAKE_FP_REGS,\n-  SHIFT_REGS, ALL_REGS, LIM_REG_CLASSES}; \n+  FP_OR_SNAKE_FP_REGS, SHIFT_REGS, ALL_REGS, LIM_REG_CLASSES}; \n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n@@ -475,7 +494,7 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n #define REG_CLASS_NAMES \\\n   { \"NO_REGS\", \"R1_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"GENERAL_OR_FP_REGS\",\\\n     \"HI_SNAKE_FP_REGS\", \"SNAKE_FP_REGS\", \"GENERAL_OR_SNAKE_FP_REGS\",\\\n-    \"SHIFT_REGS\", \"ALL_REGS\"}\n+    \"FP_OR_SNAKE_FP_REGS\",\"SHIFT_REGS\", \"ALL_REGS\"}\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n@@ -491,6 +510,7 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n   {0, 0, 0xffff0000, 0xffff},\t/* HI_SNAKE_FP_REGS */\t\\\n   {0, 0xffff0000, ~0, 0xffff},\t/* SNAKE_FP_REGS */\t\\\n   {-2, 0xffff0000, ~0, 0xffff},\t/* GENERAL_OR_SNAKE_FP_REGS */\\\n+  {0, ~0, ~0, 0xffff},\t\t/* FP_OR_SNAKE_FP_REGS */\\\n   {0, 0, 0, 0x10000},\t\t/* SHIFT_REGS */\t\\\n   {-2, ~0, ~0, 0x1ffff}}\t/* ALL_REGS */\n \n@@ -519,7 +539,8 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n    ((C) == 'x' ? (TARGET_SNAKE ? SNAKE_FP_REGS : NO_REGS) :\t\\\n     ((C) == 'y' ? (TARGET_SNAKE ? HI_SNAKE_FP_REGS : NO_REGS) :\t\\\n      ((C) == 'q' ? SHIFT_REGS :\t\t\t\t\t\\\n-      ((C) == 'a' ? R1_REGS : NO_REGS)))))\n+      ((C) == 'a' ? R1_REGS :\t\t\t\t\t\\\n+       ((C) == 'z' ? FP_OR_SNAKE_FP_REGS : NO_REGS))))))\n \n /* The letters I, J, K, L and M in a register constraint string\n    can be used to stand for particular ranges of immediate operands.\n@@ -794,6 +815,13 @@ extern enum cmp_type hppa_branch_type;\n   do { fprintf (FILE, \",ARGW%d=FU\", (ARG0));\t\t\\\n        fprintf (FILE, \",ARGW%d=FR\", (ARG1));} while (0)\n #endif\n+\n+#ifdef BUGGY_GAS\n+#define EXPORT_PARMS(FILE) fputs (\",PRIV_LEV=3\", FILE)\n+#else\n+#define EXPORT_PARMS(FILE) fputs (\",ENTRY,PRIV_LEV=3\", FILE)\n+#endif\n+\n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) \\\n     do { tree fntype = DECL_RESULT (DECL);\t \t\t\t\\\n \t tree tree_type = TREE_TYPE (DECL);\t\t\t\t\\\n@@ -802,7 +830,7 @@ extern enum cmp_type hppa_branch_type;\n \t if (TREE_PUBLIC (DECL))\t\t\t\t\t\\\n \t   { extern int current_function_varargs;\t\t\t\\\n \t     fputs (\"\\t.EXPORT \", FILE); assemble_name (FILE, NAME);\t\\\n-\t     fputs (\",PRIV_LEV=3\", FILE);\t\t\t\t\\\n+\t     EXPORT_PARMS (FILE);\t\t\t\t\t\\\n \t     for (parm = DECL_ARGUMENTS (DECL), i = 0; parm && i < 4;\t\\\n \t\t  parm = TREE_CHAIN (parm))\t\t\t\t\\\n \t       {\t\t\t\t\t\t\t\\\n@@ -984,8 +1012,8 @@ extern union tree_node *current_function_decl;\n #define REGNO_OK_FOR_BASE_P(REGNO)  \\\n   ((REGNO) && ((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32))\n #define REGNO_OK_FOR_FP_P(REGNO) \\\n-  (((REGNO) >= 32 || reg_renumber[REGNO] >= 32)\\\n-   && ((REGNO) <= 111 || reg_renumber[REGNO] <= 111))\n+  (((REGNO) >= 32 && (REGNO) <= 111)\\\n+   || (reg_renumber[REGNO] >= 32 && reg_renumber[REGNO] <= 111))\n \n /* Now macros that check whether X is a register and also,\n    strictly, whether it is in a specified class.\n@@ -1200,7 +1228,7 @@ extern union tree_node *current_function_decl;\n   if (memory_address_p (MODE, X))\t\t\t\t\\\n     goto WIN;\t\t\t\t\t\t\t\\\n   if (flag_pic) (X) = legitimize_pic_address (X, MODE, gen_reg_rtx (Pmode));\\\n-  else if ((GET_CODE (X) == SYMBOL_REF && read_only_operand (X))\\\n+  else if ((GET_CODE (X) == SYMBOL_REF & read_only_operand (X))\t\\\n \t    || GET_CODE (X) == LABEL_REF)\t\t\t\\\n     (X) = gen_rtx (LO_SUM, Pmode,\t\t\t\t\\\n \t\t   copy_to_mode_reg (Pmode, gen_rtx (HIGH, Pmode, X)), X); \\\n@@ -1246,7 +1274,10 @@ extern union tree_node *current_function_decl;\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\t\\\n-      SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\thppa_encode_label (XEXP (DECL_RTL (DECL), 0));\t\t\t\\\n+\tSYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n     else\t\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \trtx rtl = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'\t\t\\\n@@ -1376,7 +1407,7 @@ while (0)\n   case MOD:\t\t\t\t\t\t\\\n   case UMOD:\t\t\t\t\t\t\\\n     return COSTS_N_INSNS (60);\t\t\t\t\\\n-  case PLUS: /* this includes shNadd insns */\t\t\\\n+   case PLUS: /* this includes shNadd insns */\t\t\\\n     return COSTS_N_INSNS (1) + 2;\n \n /* Conditional branches with empty delay slots have a length of two.  */\n@@ -1518,7 +1549,7 @@ bss_section ()\t\t\t\t\t\t\t\t\\\n    `assemble_name' uses this.  */\n \n #define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n-  fprintf (FILE, \"%s\", NAME)\n+  fprintf ((FILE), \"%s\", (NAME) + ((NAME)[0] == '@' ? 1 : 0))\n \n /* This is how to output an internal numbered label where\n    PREFIX is the class of label and NUM is the number within the class.  */\n@@ -1578,6 +1609,7 @@ bss_section ()\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \\\n   output_ascii ((FILE), (P), (SIZE))\n \n+#if 0\n #define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n   fprintf (FILE, \"\\tstws,mb %s,4(0,30)\\n\", reg_names[REGNO])\n \n@@ -1586,7 +1618,10 @@ bss_section ()\t\t\t\t\t\t\t\t\\\n \n #define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n   fprintf (FILE, \"\\tldws,ma -4(0,30),%s\\n\", reg_names[REGNO])\n+#endif\n \n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO) \n /* This is how to output an element of a case-vector that is absolute.\n    Note that this method makes filling these branch delay slots\n    virtually impossible.  */\n@@ -1732,3 +1767,4 @@ extern void output_global_address ();\n extern struct rtx_def *legitimize_pic_address ();\n extern struct rtx_def *gen_cmp_fp ();\n extern struct rtx_def *gen_scond_fp ();\n+extern void hppa_encode_label ();"}, {"sha": "7cdbcf142ccf26ff729dd8cfe48b74ce0cb1a6f4", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 271, "deletions": 58, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d", "patch": "@@ -209,7 +209,7 @@\n \n (define_expand \"seq\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(eq:CC (match_dup 1)\n+\t(eq:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n   \"\n@@ -228,7 +228,7 @@\n \n (define_expand \"sne\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ne:CC (match_dup 1)\n+\t(ne:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n   \"\n@@ -245,7 +245,7 @@\n \n (define_expand \"slt\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(lt:CC (match_dup 1)\n+\t(lt:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n   \"\n@@ -262,7 +262,7 @@\n \n (define_expand \"sgt\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(gt:CC (match_dup 1)\n+\t(gt:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n   \"\n@@ -279,7 +279,7 @@\n \n (define_expand \"sle\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(le:CC (match_dup 1)\n+\t(le:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n   \"\n@@ -296,7 +296,7 @@\n \n (define_expand \"sge\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ge:CC (match_dup 1)\n+\t(ge:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n   \"\n@@ -313,7 +313,7 @@\n \n (define_expand \"sltu\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ltu:CC (match_dup 1)\n+\t(ltu:SI (match_dup 1)\n \t        (match_dup 2)))]\n   \"\"\n   \"\n@@ -326,7 +326,7 @@\n \n (define_expand \"sgtu\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(gtu:CC (match_dup 1)\n+\t(gtu:SI (match_dup 1)\n \t        (match_dup 2)))]\n   \"\"\n   \"\n@@ -339,7 +339,7 @@\n \n (define_expand \"sleu\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(leu:CC (match_dup 1)\n+\t(leu:SI (match_dup 1)\n \t        (match_dup 2)))]\n   \"\"\n   \"\n@@ -352,7 +352,7 @@\n \n (define_expand \"sgeu\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(geu:CC (match_dup 1)\n+\t(geu:SI (match_dup 1)\n \t        (match_dup 2)))]\n   \"\"\n   \"\n@@ -368,7 +368,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(match_operator:CC 3 \"comparison_operator\"\n+\t(match_operator:SI 3 \"comparison_operator\"\n \t\t\t   [(match_operand:SI 1 \"register_operand\" \"r,r\")\n \t\t\t    (match_operand:SI 2  \"arith11_operand\" \"r,I\")]))]\n   \"\"\n@@ -660,10 +660,43 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, SImode))\n+  if (emit_move_sequence (operands, SImode, 0))\n     DONE;\n }\")\n \n+;; Reloading an SImode or DImode value requires a scratch register if\n+;; going in to or out of float point registers.\n+\n+(define_expand \"reload_insi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=z\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&r\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, SImode, operands[2]))\n+    DONE;\n+\n+  /* We don't want the clobber emitted, so handle this ourselves.  */\n+  emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n+(define_expand \"reload_outsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(match_operand:SI 1  \"register_operand\"\"z\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&r\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, SImode, operands[2]))\n+    DONE;\n+\n+  /* We don't want the clobber emitted, so handle this ourselves.  */\n+  emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n ;; Moves to and from the shift register.\n \n (define_insn \"\"\n@@ -680,10 +713,39 @@\n   \"mfctl 11,%0\"\n   [(set_attr \"type\" \"move\")])\n \n+;;; Experimental\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"fp_reg_operand\" \"=fx\")\n+\t(match_operand:SI 1 \"short_memory_operand\" \"T\"))]\n+  \"\"\n+  \"fldws%F1 %1,%0\"\n+  [(set_attr \"type\" \"fpload\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"short_memory_operand\" \"=T\")\n+\t(match_operand:SI 1 \"fp_reg_operand\" \"fx\"))]\n+  \"\"\n+  \"fstws%F0 %1,%0\"\n+  [(set_attr \"type\" \"fpstore\")\n+   (set_attr \"length\" \"1\")])\n+\n+;;; pic symbol refrences\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"symbolic_operand\" \"\"))))]\n+  \"flag_pic && operands[1] == pic_offset_table_rtx\"\n+  \"ldw T'%2(%1),%0\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"1\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"reg_or_nonsymb_mem_operand\"\n-\t\t\t  \"=r,r,Q,!r,!*f*x,!*f*x\")\n-\t(match_operand:SI 1 \"move_operand\" \"rM,Q,rM,!*f*x*y,!r,!*f*x\"))]\n+\t\t\t  \"=r,r,Q,!r,!fx,!fx\")\n+\t(match_operand:SI 1 \"move_operand\" \"rM,Q,rM,!fxy,!r,!fx\"))]\n   \"\"\n   \"@\n    copy %r1,%0\n@@ -712,7 +774,7 @@\n   xoperands[2] = label_rtx;\n   output_asm_insn (\\\"bl .+8,%0\\;addil L'%1-%2,%0\\\", xoperands);\n   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (label_rtx));\n-  output_asm_insn (\\\"ldo R'%1(1),%0\\\", xoperands);\n+  output_asm_insn (\\\"ldo R'%1-%2(1),%0\\\", xoperands);\n   return \\\"\\\";\n   }\n \"\n@@ -779,6 +841,14 @@\n    (set (match_dup 0) (plus:SI (match_dup 3) (match_dup 1)))]\n   \"\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(high:SI (match_operand:SI 1 \"function_label_operand\" \"\")))]\n+  \"TARGET_SHARED_LIBS\"\n+  \"ldil LP'%G1,%0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(high:SI (match_operand 1 \"\" \"\")))]\n@@ -795,6 +865,16 @@\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"function_label_operand\" \"\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"=r\"))]\n+  \"TARGET_SHARED_LIBS\"\n+  \"ldo RP'%G2(%1),%0\\;extru,= %0,31,1,%3\\;ldw -4(%%r27),%3\\;add %0,%3,%0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -805,44 +885,29 @@\n   ;; is not an \"arith_operand\".\n   [(set_attr \"length\" \"1\")])\n \n-;;; Experimental\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"fp_reg_operand\" \"=*f*x\")\n-\t(match_operand:SI 1 \"short_memory_operand\" \"T\"))]\n-  \"\"\n-  \"fldws%F1 %1,%0\"\n-  [(set_attr \"type\" \"fpload\")\n-   (set_attr \"length\" \"1\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"short_memory_operand\" \"=T\")\n-\t(match_operand:SI 1 \"fp_reg_operand\" \"*f*x\"))]\n-  \"\"\n-  \"fstws%F0 %1,%0\"\n-  [(set_attr \"type\" \"fpstore\")\n-   (set_attr \"length\" \"1\")])\n-\n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"general_operand\" \"\")\n \t(match_operand:HI 1 \"general_operand\" \"\"))]\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, HImode))\n+  if (emit_move_sequence (operands, HImode, 0))\n     DONE;\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,Q\")\n-\t(match_operand:HI 1 \"move_operand\" \"rM,Q,rM\"))]\n+  [(set (match_operand:HI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,Q,!r,!*fx,!*fx\")\n+\t(match_operand:HI 1 \"move_operand\" \"rM,Q,rM,*fx,r,!*fx\"))]\n   \"\"\n   \"@\n    copy %r1,%0\n    ldh%M1 %1,%0\n-   sth%M0 %r1,%0\"\n-  [(set_attr \"type\" \"move,load,store\")\n-   (set_attr \"length\" \"1,1,1\")])\n+   sth%M0 %r1,%0\n+   fstws %1,-16(30)\\;ldw -16(30),%0\n+   stw %1,-16(30)\\;fldws -16(30),%0\n+   fcpy,sgl %1,%0\"\n+  [(set_attr \"type\" \"move,load,store,move,move,fpalu\")\n+   (set_attr \"length\" \"1,1,1,2,2,1\")])\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n@@ -887,20 +952,23 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, QImode))\n+  if (emit_move_sequence (operands, QImode, 0))\n     DONE;\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,Q\")\n-\t(match_operand:QI 1 \"move_operand\" \"rM,Q,rM\"))]\n+  [(set (match_operand:QI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,Q,!r,!*fx,!*fx\")\n+\t(match_operand:QI 1 \"move_operand\" \"rM,Q,rM,*fx,r,*fx\"))]\n   \"\"\n   \"@\n    copy %r1,%0\n    ldb%M1 %1,%0\n-   stb%M0 %r1,%0\"\n-  [(set_attr \"type\" \"move,load,store\")\n-   (set_attr \"length\" \"1,1,1\")])\n+   stb%M0 %r1,%0\n+   fstws %1,-16(30)\\;ldw -16(30),%0\n+   stw %1,-16(30)\\;fldws -16(30),%0\n+   fcpy,sgl %1,%0\"\n+  [(set_attr \"type\" \"move,load,store,move,move,fpalu\")\n+   (set_attr \"length\" \"1,1,1,2,2,1\")])\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n@@ -918,6 +986,83 @@\n   \"ldo R'%G2(%1),%0\"\n   [(set_attr \"length\" \"1\")])\n \n+;; Sneaky ways of using index modes\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mem:SI (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t  (const_int 4))\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"ldwx,s %1(0,%2),%0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mem:SI (match_operand:SI 1 \"register_operand\" \"+r\")))\n+   (set (match_dup 1)\n+\t(plus:SI (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t  (const_int 4))\n+\t\t (match_dup 1)))]\n+  \"\"\n+  \"ldwx,sm %2(0,%1),%0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mem:SI (match_operand:SI 1 \"register_operand\" \"+r\")))\n+   (set (match_dup 1)\n+\t(plus:SI (match_dup 1)\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"ldwx,m %2(0,%1),%0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mem:HI (plus:SI (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t  (const_int 2))\n+\t\t\t (match_operand:SI 1 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"ldhx,s %2(0,%1),%0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mem:HI (match_operand:SI 1 \"register_operand\" \"+r\")))\n+   (set (match_dup 1)\n+\t(plus:SI (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t  (const_int 2))\n+\t\t (match_dup 1)))]\n+  \"\"\n+  \"ldhx,sm %2(0,%1),%0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mem:HI (match_operand:SI 1 \"register_operand\" \"+r\")))\n+   (set (match_dup 1)\n+\t(plus:SI (match_dup 1)\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"ldhx,m %2(0,%1),%0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(mem:QI (match_operand:SI 1 \"register_operand\" \"+r\")))\n+   (set (match_dup 1)\n+\t(plus:SI (match_dup 1)\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"ldbx,m %2(0,%1),%0\")\n+\n ;; The definition of this insn does not really explain what it does,\n ;; but it should suffice\n ;; that anything generated as this insn will be recognized as one\n@@ -997,16 +1142,17 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, DFmode))\n+  if (emit_move_sequence (operands, DFmode, 0))\n     DONE;\n }\")\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"reg_or_nonsymb_mem_operand\"\n-\t\t\t  \"=fx,r,Q,Q,fx,&r,?fx,?r\")\n+\t\t\t  \"=fx,*r,Q,?Q,fx,*&r,?fx,?r\")\n \t(match_operand:DF 1 \"reg_or_nonsymb_mem_operand\"\n-\t\t\t  \"fx,r,fx,r,Q,Q,r,fx\"))]\n-  \"\"\n+\t\t\t  \"fx,*r,fx,*r,Q,Q,*r,fx\"))]\n+  \"register_operand (operands[0], DFmode)\n+   || register_operand (operands[1], DFmode)\"\n   \"*\n {\n   if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n@@ -1022,10 +1168,40 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, DImode))\n+  if (emit_move_sequence (operands, DImode, 0))\n     DONE;\n }\")\n \n+(define_expand \"reload_indi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=z\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&r\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, DImode, operands[2]))\n+    DONE;\n+\n+  /* We don't want the clobber emitted, so handle this ourselves.  */\n+  emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n+(define_expand \"reload_outdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(match_operand:DI 1 \"register_operand\" \"z\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&r\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, DImode, operands[2]))\n+    DONE;\n+\n+  /* We don't want the clobber emitted, so handle this ourselves.  */\n+  emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(high:DI (match_operand 1 \"\" \"\")))]\n@@ -1064,20 +1240,38 @@\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"2\")])\n \n+;;; Experimental\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"fp_reg_operand\" \"=fx\")\n+\t(match_operand:DI 1 \"short_memory_operand\" \"T\"))]\n+  \"\"\n+  \"fldds%F1 %1,%0\"\n+  [(set_attr \"type\" \"fpload\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"short_memory_operand\" \"=T\")\n+\t(match_operand:DI 1 \"fp_reg_operand\" \"fx\"))]\n+  \"\"\n+  \"fstds%F0 %1,%0\"\n+  [(set_attr \"type\" \"fpstore\")\n+   (set_attr \"length\" \"1\")])\n+\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\"\n-\t\t\t  \"=r,Q,&r,&r,*f*x,*f*x,*f*x,r,Q\")\n+\t\t\t  \"=r,Q,&r,&r,fx,fx,r\")\n \t(match_operand:DI 1 \"general_operand\"\n-\t\t\t  \"r,r,Q,i,r,*f*x,Q,*f*x,*f*x\"))]\n+\t\t\t  \"r,r,Q,i,r,fx,fx\"))]\n   \"\"\n   \"*\n {\n   if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n     return output_fp_move_double (operands);\n   return output_move_double (operands);\n }\"\n-  [(set_attr \"type\" \"move,store,load,misc,multi,fpalu,fpload,multi,fpstore\")\n-   (set_attr \"length\" \"2,3,3,3,3,2,3,3,3\")])\n+  [(set_attr \"type\" \"move,store,load,misc,multi,fpalu,multi\")\n+   (set_attr \"length\" \"2,3,3,3,3,2,3\")])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n@@ -1104,7 +1298,7 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, SFmode))\n+  if (emit_move_sequence (operands, SFmode, 0))\n     DONE;\n }\")\n \n@@ -1386,16 +1580,35 @@\n ;; The mulsi3 insns set up registers for the millicode call.\n \n (define_expand \"mulsi3\"\n-  [(set (reg:SI 26) (match_operand:SI 1 \"srcsi_operand\" \"\"))\n-   (set (reg:SI 25) (match_operand:SI 2 \"srcsi_operand\" \"\"))\n+  [(set (reg:SI 26) (match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (reg:SI 25) (match_operand:SI 2 \"arith32_operand\" \"\"))\n    (parallel [(set (reg:SI 29) (mult:SI (reg:SI 26) (reg:SI 25)))\n \t      (clobber (match_scratch:SI 3 \"\"))\n \t      (clobber (reg:SI 26))\n \t      (clobber (reg:SI 25))\n \t      (clobber (reg:SI 31))])\n    (set (match_operand:SI 0 \"general_operand\" \"\") (reg:SI 29))]\n   \"\"\n-  \"\")\n+  \"\n+{\n+  if (TARGET_SNAKE && !(CONSTANT_P (operands[1]) || CONSTANT_P (operands[2])))\n+    {\n+      rtx scratch = gen_reg_rtx (DImode);\n+      emit_insn (gen_umulsidi3 (scratch, operands[1], operands[2]));\n+      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t  operands[0],\n+\t\t\t  gen_rtx (SUBREG, SImode, scratch, 1)));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"umulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n+\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"x\"))\n+\t\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"x\"))))]\n+  \"TARGET_SNAKE\"\n+  \"xmpyu %1,%2,%0\"\n+  [(set_attr \"type\" \"fpmul\")])\n \n (define_insn \"\"\n   [(set (reg:SI 29) (mult:SI (reg:SI 26) (reg:SI 25)))"}, {"sha": "f6bdea899935af3daea3cb9e7f8eb0375d4de7a2", "filename": "gcc/config/pa/xm-pa.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d/gcc%2Fconfig%2Fpa%2Fxm-pa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d/gcc%2Fconfig%2Fpa%2Fxm-pa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fxm-pa.h?ref=d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d", "patch": "@@ -23,6 +23,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include <magic.h>\n #if defined(SHL_MAGIC)\n #define hpux8 1\n+#define HAVE_VPRINTF\n #endif\n \n #define USG"}, {"sha": "c01850ac898563bf54d7fc7df6647bd6666e3184", "filename": "gcc/ginclude/va-pa.h", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d/gcc%2Fginclude%2Fva-pa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d/gcc%2Fginclude%2Fva-pa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-pa.h?ref=d2a94ec006a7ae0fb8afcc3d5f816bc88c8bd06d", "patch": "@@ -1,4 +1,3 @@\n-#if __GNUC__ > 1\n \n /* Define __gnuc_va_list. */\n \n@@ -11,12 +10,23 @@ typedef double *__gnuc_va_list;\n /* If this is for internal libc use, don't define anything but\n    __gnuc_va_list.  */\n #if defined (_STDARG_H) || defined (_VARARGS_H)\n+#if __GNUC__ > 1\n+#define __va_ellipsis ...\n+#define __gnuc_va_start(AP) ((AP) = (va_list)__builtin_saveregs())\n+#else\n+#define va_alist __va_a__, __va_b__, __va_c__, __va_d__\n+#define __va_ellipsis \n+#define __gnuc_va_start(AP)\\\n+  (AP) = (double *) &__va_a__, &__va_b__, &__va_c__, &__va_d__, \\\n+  (AP) = (double *)((char *)(AP) + 4)\n+#endif /* __GNUC__ > 1 */\n+\n #ifdef _STDARG_H\n-#define va_start(AP,LASTARG) ((AP) = (va_list)__builtin_saveregs())\n+#define va_start(AP,LASTARG) __gnuc_va_start (AP)\n #else\n /* The ... causes current_function_varargs to be set in cc1.  */\n-#define va_dcl long va_alist; ...\n-#define va_start(AP) ((AP) = (va_list)__builtin_saveregs())\n+#define va_dcl long va_alist; __va_ellipsis\n+#define va_start(AP) __gnuc_va_start (AP)\n #endif\n \n #define va_arg(AP,TYPE)\t\t\t\t\t\t\\\n@@ -31,8 +41,3 @@ typedef double *__gnuc_va_list;\n #define va_end(AP)\n \n #endif /* defined (_STDARG_H) || defined (_VARARGS_H) */\n-\n-#else /* not __GNUC__ > 1 */\n-#include \"/usr/local/lib/gcc-include/va-hp9k8.h\"\n-#define _VA_LIST_\n-#endif"}]}