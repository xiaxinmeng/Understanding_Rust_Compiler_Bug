{"sha": "d3ccfbb91e622532f44d298c3764d7ec9e2ef5a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNjY2ZiYjkxZTYyMjUzMmY0NGQyOThjMzc2NGQ3ZWM5ZTJlZjVhMQ==", "commit": {"author": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2015-12-19T01:50:00Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2015-12-19T01:50:00Z"}, "message": "re PR target/68729 (../Xbae/Methods.c:1772:1: ICE: in extract_insn, at recog.c:2343)\n\n\tPR target/68729\n\t* config/pa/pa.c (pa_emit_move_sequence): Reorganize handling of\n\tfloating-point reloads. Only reload operands that are not valid\n\tfloating-point memory operands.\n\nFrom-SVN: r231845", "tree": {"sha": "2a272a8ca5c296f15d99a4fd7bbb5ad03763623d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a272a8ca5c296f15d99a4fd7bbb5ad03763623d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3ccfbb91e622532f44d298c3764d7ec9e2ef5a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3ccfbb91e622532f44d298c3764d7ec9e2ef5a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3ccfbb91e622532f44d298c3764d7ec9e2ef5a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3ccfbb91e622532f44d298c3764d7ec9e2ef5a1/comments", "author": null, "committer": null, "parents": [{"sha": "c73f3223610c9f19331cbccaeff0bda0da33ae78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c73f3223610c9f19331cbccaeff0bda0da33ae78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c73f3223610c9f19331cbccaeff0bda0da33ae78"}], "stats": {"total": 113, "additions": 68, "deletions": 45}, "files": [{"sha": "cccfd0478090744354c1d22d64452cbe54b0138f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ccfbb91e622532f44d298c3764d7ec9e2ef5a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ccfbb91e622532f44d298c3764d7ec9e2ef5a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d3ccfbb91e622532f44d298c3764d7ec9e2ef5a1", "patch": "@@ -1,3 +1,10 @@\n+2015-13-18  John David Anglin  <danglin@gcc.gnu.org>\n+\n+\tPR target/68729\n+\t* config/pa/pa.c (pa_emit_move_sequence): Reorganize handling of\n+\tfloating-point reloads. Only reload operands that are not valid\n+\tfloating-point memory operands.\n+\n 2015-12-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/68860"}, {"sha": "1d2227228d2355cd124a28a7ef479255d5823b7c", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 61, "deletions": 45, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ccfbb91e622532f44d298c3764d7ec9e2ef5a1/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ccfbb91e622532f44d298c3764d7ec9e2ef5a1/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=d3ccfbb91e622532f44d298c3764d7ec9e2ef5a1", "patch": "@@ -1688,64 +1688,79 @@ pa_emit_move_sequence (rtx *operands, machine_mode mode, rtx scratch_reg)\n \t  || (GET_CODE (operand1) == SUBREG\n \t      && MEM_P (XEXP (operand1, 0)))))\n     {\n-      if (GET_CODE (operand1) == SUBREG)\n-\toperand1 = XEXP (operand1, 0);\n+      rtx op1 = operand1;\n \n-      /* SCRATCH_REG will hold an address and maybe the actual data.  We want\n-\t it in WORD_MODE regardless of what mode it was originally given\n-\t to us.  */\n-      scratch_reg = force_mode (word_mode, scratch_reg);\n+      if (GET_CODE (op1) == SUBREG)\n+\top1 = XEXP (op1, 0);\n \n-      /* D might not fit in 14 bits either; for such cases load D into\n-\t scratch reg.  */\n-      if (reg_plus_base_memory_operand (operand1, GET_MODE (operand1))\n-\t  && !INT_14_BITS (XEXP (XEXP (operand1, 0), 1)))\n+      if (reg_plus_base_memory_operand (op1, GET_MODE (op1))\n+\t  && !(TARGET_PA_20\n+\t       && !TARGET_ELF32\n+\t       && INT_14_BITS (XEXP (XEXP (op1, 0), 1)))\n+\t  && !INT_5_BITS (XEXP (XEXP (op1, 0), 1)))\n \t{\n-\t  emit_move_insn (scratch_reg, XEXP (XEXP (operand1, 0), 1));\n-\t  emit_move_insn (scratch_reg,\n-\t\t\t  gen_rtx_fmt_ee (GET_CODE (XEXP (operand1, 0)),\n-\t\t\t\t\t  Pmode,\n-\t\t\t\t\t  XEXP (XEXP (operand1, 0), 0),\n-\t\t\t\t\t  scratch_reg));\n+\t  /* SCRATCH_REG will hold an address and maybe the actual data.\n+\t     We want it in WORD_MODE regardless of what mode it was\n+\t     originally given to us.  */\n+\t  scratch_reg = force_mode (word_mode, scratch_reg);\n+\n+\t  /* D might not fit in 14 bits either; for such cases load D into\n+\t     scratch reg.  */\n+\t  if (!INT_14_BITS (XEXP (XEXP (op1, 0), 1)))\n+\t    {\n+\t      emit_move_insn (scratch_reg, XEXP (XEXP (op1, 0), 1));\n+\t      emit_move_insn (scratch_reg,\n+\t\t\t      gen_rtx_fmt_ee (GET_CODE (XEXP (op1, 0)),\n+\t\t\t\t\t      Pmode,\n+\t\t\t\t\t      XEXP (XEXP (op1, 0), 0),\n+\t\t\t\t\t      scratch_reg));\n+\t    }\n+\t  else\n+\t    emit_move_insn (scratch_reg, XEXP (op1, 0));\n+\t  emit_insn (gen_rtx_SET (operand0,\n+\t\t\t\t  replace_equiv_address (op1, scratch_reg)));\n+\t  return 1;\n \t}\n-      else\n-\temit_move_insn (scratch_reg, XEXP (operand1, 0));\n-      emit_insn (gen_rtx_SET (operand0,\n-\t\t\t      replace_equiv_address (operand1, scratch_reg)));\n-      return 1;\n     }\n   else if (scratch_reg\n \t   && FP_REG_P (operand1)\n \t   && (MEM_P (operand0)\n \t       || (GET_CODE (operand0) == SUBREG\n \t\t   && MEM_P (XEXP (operand0, 0)))))\n     {\n-      if (GET_CODE (operand0) == SUBREG)\n-\toperand0 = XEXP (operand0, 0);\n+      rtx op0 = operand0;\n \n-      /* SCRATCH_REG will hold an address and maybe the actual data.  We want\n-\t it in WORD_MODE regardless of what mode it was originally given\n-\t to us.  */\n-      scratch_reg = force_mode (word_mode, scratch_reg);\n+      if (GET_CODE (op0) == SUBREG)\n+\top0 = XEXP (op0, 0);\n \n-      /* D might not fit in 14 bits either; for such cases load D into\n-\t scratch reg.  */\n-      if (reg_plus_base_memory_operand (operand0, GET_MODE (operand0))\n-\t  && !INT_14_BITS (XEXP (XEXP (operand0, 0), 1)))\n+      if (reg_plus_base_memory_operand (op0, GET_MODE (op0))\n+\t  && !(TARGET_PA_20\n+\t       && !TARGET_ELF32\n+\t       && INT_14_BITS (XEXP (XEXP (op0, 0), 1)))\n+\t  && !INT_5_BITS (XEXP (XEXP (op0, 0), 1)))\n \t{\n-\t  emit_move_insn (scratch_reg, XEXP (XEXP (operand0, 0), 1));\n-\t  emit_move_insn (scratch_reg, gen_rtx_fmt_ee (GET_CODE (XEXP (operand0,\n-\t\t\t\t\t\t\t\t        0)),\n-\t\t\t\t\t\t       Pmode,\n-\t\t\t\t\t\t       XEXP (XEXP (operand0, 0),\n-\t\t\t\t\t\t\t\t   0),\n-\t\t\t\t\t\t       scratch_reg));\n+\t  /* SCRATCH_REG will hold an address and maybe the actual data.\n+\t     We want it in WORD_MODE regardless of what mode it was\n+\t     originally given to us.  */\n+\t  scratch_reg = force_mode (word_mode, scratch_reg);\n+\n+\t  /* D might not fit in 14 bits either; for such cases load D into\n+\t     scratch reg.  */\n+\t  if (!INT_14_BITS (XEXP (XEXP (op0, 0), 1)))\n+\t    {\n+\t      emit_move_insn (scratch_reg, XEXP (XEXP (op0, 0), 1));\n+\t      emit_move_insn (scratch_reg,\n+\t\t\t      gen_rtx_fmt_ee (GET_CODE (XEXP (op0, 0)),\n+\t\t\t\t\t      Pmode,\n+\t\t\t\t\t      XEXP (XEXP (op0, 0), 0),\n+\t\t\t\t\t      scratch_reg));\n+\t    }\n+\t  else\n+\t    emit_move_insn (scratch_reg, XEXP (op0, 0));\n+\t  emit_insn (gen_rtx_SET (replace_equiv_address (op0, scratch_reg),\n+\t\t\t\t  operand1));\n+\t  return 1;\n \t}\n-      else\n-\temit_move_insn (scratch_reg, XEXP (operand0, 0));\n-      emit_insn (gen_rtx_SET (replace_equiv_address (operand0, scratch_reg),\n-\t\t\t      operand1));\n-      return 1;\n     }\n   /* Handle secondary reloads for loads of FP registers from constant\n      expressions by forcing the constant into memory.  For the most part,\n@@ -1754,7 +1769,7 @@ pa_emit_move_sequence (rtx *operands, machine_mode mode, rtx scratch_reg)\n      Use scratch_reg to hold the address of the memory location.  */\n   else if (scratch_reg\n \t   && CONSTANT_P (operand1)\n-\t   && fp_reg_operand (operand0, mode))\n+\t   && FP_REG_P (operand0))\n     {\n       rtx const_mem, xoperands[2];\n \n@@ -1830,8 +1845,9 @@ pa_emit_move_sequence (rtx *operands, machine_mode mode, rtx scratch_reg)\n       emit_move_insn (operand0, scratch_reg);\n       return 1;\n     }\n+\n   /* Handle the most common case: storing into a register.  */\n-  else if (register_operand (operand0, mode))\n+  if (register_operand (operand0, mode))\n     {\n       /* Legitimize TLS symbol references.  This happens for references\n \t that aren't a legitimate constant.  */"}]}