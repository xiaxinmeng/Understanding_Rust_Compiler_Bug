{"sha": "f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY3ZjRkZmZmZTA4YjFjZWE1ZGU0MDdlMzVlMDNkZDM4YjY0ZmNkMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:10:44Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:10:44Z"}, "message": "[19/77] Add a smallest_int_mode_for_size helper function\n\nThis patch adds a wrapper around smallest_mode_for_size\nfor cases in which the mode class is MODE_INT.  Unlike\n(int_)mode_for_size, smallest_mode_for_size always returns\na mode of the specified class, asserting if no such mode exists.\nsmallest_int_mode_for_size therefore returns a scalar_int_mode\nrather than an opt_scalar_int_mode.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* machmode.h (smallest_mode_for_size): Fix formatting.\n\t(smallest_int_mode_for_size): New function.\n\t* cfgexpand.c (expand_debug_expr): Use smallest_int_mode_for_size\n\tinstead of smallest_mode_for_size.\n\t* combine.c (make_extraction): Likewise.\n\t* config/arc/arc.c (arc_expand_movmem): Likewise.\n\t* config/arm/arm.c (arm_expand_divmod_libfunc): Likewise.\n\t* config/i386/i386.c (ix86_get_mask_mode): Likewise.\n\t* config/s390/s390.c (s390_expand_insv): Likewise.\n\t* config/sparc/sparc.c (assign_int_registers): Likewise.\n\t* config/spu/spu.c (spu_function_value): Likewise.\n\t(spu_function_arg): Likewise.\n\t* coverage.c (get_gcov_type): Likewise.\n\t(get_gcov_unsigned_t): Likewise.\n\t* dse.c (find_shift_sequence): Likewise.\n\t* expmed.c (store_bit_field_1): Likewise.\n\t* expr.c (convert_move): Likewise.\n\t(store_field): Likewise.\n\t* internal-fn.c (expand_arith_overflow): Likewise.\n\t* optabs-query.c (get_best_extraction_insn): Likewise.\n\t* optabs.c (expand_twoval_binop_libfunc): Likewise.\n\t* stor-layout.c (layout_type): Likewise.\n\t(initialize_sizetypes): Likewise.\n\t* targhooks.c (default_get_mask_mode): Likewise.\n\t* tree-ssa-loop-manip.c (canonicalize_loop_ivs): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251471", "tree": {"sha": "a08f3d32bc93a70f1da4b61931edf7ce88da32b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a08f3d32bc93a70f1da4b61931edf7ce88da32b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/comments", "author": null, "committer": null, "parents": [{"sha": "304b9962830476dce3fe7632713e5f5ce002c050", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/304b9962830476dce3fe7632713e5f5ce002c050", "html_url": "https://github.com/Rust-GCC/gccrs/commit/304b9962830476dce3fe7632713e5f5ce002c050"}], "stats": {"total": 150, "additions": 95, "deletions": 55}, "files": [{"sha": "15ec88d4eba96cea1d3812761ad90b6eca01a555", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -1,3 +1,33 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* machmode.h (smallest_mode_for_size): Fix formatting.\n+\t(smallest_int_mode_for_size): New function.\n+\t* cfgexpand.c (expand_debug_expr): Use smallest_int_mode_for_size\n+\tinstead of smallest_mode_for_size.\n+\t* combine.c (make_extraction): Likewise.\n+\t* config/arc/arc.c (arc_expand_movmem): Likewise.\n+\t* config/arm/arm.c (arm_expand_divmod_libfunc): Likewise.\n+\t* config/i386/i386.c (ix86_get_mask_mode): Likewise.\n+\t* config/s390/s390.c (s390_expand_insv): Likewise.\n+\t* config/sparc/sparc.c (assign_int_registers): Likewise.\n+\t* config/spu/spu.c (spu_function_value): Likewise.\n+\t(spu_function_arg): Likewise.\n+\t* coverage.c (get_gcov_type): Likewise.\n+\t(get_gcov_unsigned_t): Likewise.\n+\t* dse.c (find_shift_sequence): Likewise.\n+\t* expmed.c (store_bit_field_1): Likewise.\n+\t* expr.c (convert_move): Likewise.\n+\t(store_field): Likewise.\n+\t* internal-fn.c (expand_arith_overflow): Likewise.\n+\t* optabs-query.c (get_best_extraction_insn): Likewise.\n+\t* optabs.c (expand_twoval_binop_libfunc): Likewise.\n+\t* stor-layout.c (layout_type): Likewise.\n+\t(initialize_sizetypes): Likewise.\n+\t* targhooks.c (default_get_mask_mode): Likewise.\n+\t* tree-ssa-loop-manip.c (canonicalize_loop_ivs): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n             Alan Hayward  <alan.hayward@arm.com>\n             David Sherwood  <david.sherwood@arm.com>"}, {"sha": "7a90b0e8799ed165bc7764ee7f1456cb28418198", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -4497,7 +4497,7 @@ expand_debug_expr (tree exp)\n \t  {\n \t    if (mode1 == VOIDmode)\n \t      /* Bitfield.  */\n-\t      mode1 = smallest_mode_for_size (bitsize, MODE_INT);\n+\t      mode1 = smallest_int_mode_for_size (bitsize);\n \t    if (bitpos >= BITS_PER_UNIT)\n \t      {\n \t\top0 = adjust_address_nv (op0, mode1, bitpos / BITS_PER_UNIT);"}, {"sha": "44e378a160c752bf50cab14f191bc6274f82136d", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -7598,7 +7598,7 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n     {\n       /* Be careful not to go beyond the extracted object and maintain the\n \t natural alignment of the memory.  */\n-      wanted_inner_mode = smallest_mode_for_size (len, MODE_INT);\n+      wanted_inner_mode = smallest_int_mode_for_size (len);\n       while (pos % GET_MODE_BITSIZE (wanted_inner_mode) + len\n \t     > GET_MODE_BITSIZE (wanted_inner_mode))\n \twanted_inner_mode = GET_MODE_WIDER_MODE (wanted_inner_mode).require ();"}, {"sha": "1f5c6dfe9b99e769ff5f788123892b9f3a57ade5", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -7972,7 +7972,7 @@ arc_expand_movmem (rtx *operands)\n \n       while (piece > size)\n \tpiece >>= 1;\n-      mode = smallest_mode_for_size (piece * BITS_PER_UNIT, MODE_INT);\n+      mode = smallest_int_mode_for_size (piece * BITS_PER_UNIT);\n       /* If we don't re-use temporaries, the scheduler gets carried away,\n \t and the register pressure gets unnecessarily high.  */\n       if (0 && tmpx[i] && GET_MODE (tmpx[i]) == mode)"}, {"sha": "e66cfa651b5304476ec9f016eab890ac9bd19755", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -31097,8 +31097,8 @@ arm_expand_divmod_libfunc (rtx libfunc, machine_mode mode,\n   if (mode == SImode)\n     gcc_assert (!TARGET_IDIV);\n \n-  machine_mode libval_mode = smallest_mode_for_size (2 * GET_MODE_BITSIZE (mode),\n-\t\t\t\t\t\t     MODE_INT);\n+  scalar_int_mode libval_mode\n+    = smallest_int_mode_for_size (2 * GET_MODE_BITSIZE (mode));\n \n   rtx libval = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n \t\t\t\t\tlibval_mode, 2,"}, {"sha": "be83381692efb28873a3a9651ab7b083baf2db29", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -51580,11 +51580,11 @@ ix86_get_mask_mode (unsigned nunits, unsigned vector_size)\n       || (TARGET_AVX512VL && (vector_size == 32 || vector_size == 16)))\n     {\n       if (elem_size == 4 || elem_size == 8 || TARGET_AVX512BW)\n-\treturn smallest_mode_for_size (nunits, MODE_INT);\n+\treturn smallest_int_mode_for_size (nunits);\n     }\n \n-  machine_mode elem_mode\n-    = smallest_mode_for_size (elem_size * BITS_PER_UNIT, MODE_INT);\n+  scalar_int_mode elem_mode\n+    = smallest_int_mode_for_size (elem_size * BITS_PER_UNIT);\n \n   gcc_assert (elem_size * nunits == vector_size);\n "}, {"sha": "e4d14fbc01d8d72055ab146ef659103d95962b44", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -6185,7 +6185,7 @@ s390_expand_insv (rtx dest, rtx op1, rtx op2, rtx src)\n       return true;\n     }\n \n-  smode = smallest_mode_for_size (bitsize, MODE_INT);\n+  smode = smallest_int_mode_for_size (bitsize);\n   smode_bsize = GET_MODE_BITSIZE (smode);\n   mode_bsize = GET_MODE_BITSIZE (mode);\n "}, {"sha": "a3e7e46a514826b709b6ab8a0f40554618cf8f4d", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -6771,8 +6771,8 @@ assign_int_registers (HOST_WIDE_INT bitpos, assign_data_t *data)\n      the latter case we may pick up unwanted bits.  It's not a problem\n      at the moment but may wish to revisit.  */\n   if (intoffset % BITS_PER_WORD != 0)\n-    mode = smallest_mode_for_size (BITS_PER_WORD - intoffset % BITS_PER_WORD,\n-\t\t\t  \t   MODE_INT);\n+    mode = smallest_int_mode_for_size (BITS_PER_WORD\n+\t\t\t\t       - intoffset % BITS_PER_WORD);\n   else\n     mode = word_mode;\n "}, {"sha": "b917609bb601a306b1431e6500672058afc97244", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -3810,8 +3810,7 @@ spu_function_value (const_tree type, const_tree func ATTRIBUTE_UNUSED)\n \t{\n \t  if (byte_size < 4)\n \t    byte_size = 4;\n-\t  smode =\n-\t    smallest_mode_for_size (byte_size * BITS_PER_UNIT, MODE_INT);\n+\t  smode = smallest_int_mode_for_size (byte_size * BITS_PER_UNIT);\n \t  RTVEC_ELT (v, n) =\n \t    gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t       gen_rtx_REG (smode, FIRST_RETURN_REGNUM + n),\n@@ -3849,7 +3848,7 @@ spu_function_arg (cumulative_args_t cum_v,\n       rtx gr_reg;\n       if (byte_size < 4)\n \tbyte_size = 4;\n-      smode = smallest_mode_for_size (byte_size * BITS_PER_UNIT, MODE_INT);\n+      smode = smallest_int_mode_for_size (byte_size * BITS_PER_UNIT);\n       gr_reg = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t  gen_rtx_REG (smode, FIRST_ARG_REGNUM + *cum),\n \t\t\t\t  const0_rtx);"}, {"sha": "8a56a677f157427d9b03ec18e129b2df20df9990", "filename": "gcc/coverage.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -143,8 +143,8 @@ static void coverage_obj_finish (vec<constructor_elt, va_gc> *);\n tree\n get_gcov_type (void)\n {\n-  machine_mode mode\n-    = smallest_mode_for_size (LONG_LONG_TYPE_SIZE > 32 ? 64 : 32, MODE_INT);\n+  scalar_int_mode mode\n+    = smallest_int_mode_for_size (LONG_LONG_TYPE_SIZE > 32 ? 64 : 32);\n   return lang_hooks.types.type_for_mode (mode, false);\n }\n \n@@ -153,7 +153,7 @@ get_gcov_type (void)\n static tree\n get_gcov_unsigned_t (void)\n {\n-  machine_mode mode = smallest_mode_for_size (32, MODE_INT);\n+  scalar_int_mode mode = smallest_int_mode_for_size (32);\n   return lang_hooks.types.type_for_mode (mode, true);\n }\n \f"}, {"sha": "e6643321887270a28b33db80f68ac7bb47a20aa1", "filename": "gcc/dse.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -1573,7 +1573,7 @@ find_shift_sequence (int access_size,\n \t\t     int shift, bool speed, bool require_cst)\n {\n   machine_mode store_mode = GET_MODE (store_info->mem);\n-  machine_mode new_mode;\n+  scalar_int_mode new_mode;\n   rtx read_reg = NULL;\n \n   /* Some machines like the x86 have shift insns for each size of\n@@ -1583,14 +1583,15 @@ find_shift_sequence (int access_size,\n      justify the value we want to read but is available in one insn on\n      the machine.  */\n \n-  FOR_EACH_MODE_FROM (new_mode,\n-\t\t      smallest_mode_for_size (access_size * BITS_PER_UNIT,\n-\t\t\t\t\t      MODE_INT))\n+  opt_scalar_int_mode new_mode_iter;\n+  FOR_EACH_MODE_FROM (new_mode_iter,\n+\t\t      smallest_int_mode_for_size (access_size * BITS_PER_UNIT))\n     {\n       rtx target, new_reg, new_lhs;\n       rtx_insn *shift_seq, *insn;\n       int cost;\n \n+      new_mode = new_mode_iter.require ();\n       if (GET_MODE_BITSIZE (new_mode) > BITS_PER_WORD)\n \tbreak;\n "}, {"sha": "f7ac82145de3b5e3f4d8cd385b57bed88e5507f4", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -900,7 +900,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t is not allowed.  */\n       fieldmode = GET_MODE (value);\n       if (fieldmode == VOIDmode)\n-\tfieldmode = smallest_mode_for_size (nwords * BITS_PER_WORD, MODE_INT);\n+\tfieldmode = smallest_int_mode_for_size (nwords * BITS_PER_WORD);\n \n       last = get_last_insn ();\n       for (i = 0; i < nwords; i++)"}, {"sha": "776c71904951b0b403487b387adc19111726dfb7", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -346,8 +346,8 @@ convert_move (rtx to, rtx from, int unsignedp)\n      xImode for all MODE_PARTIAL_INT modes they use, but no others.  */\n   if (GET_MODE_CLASS (to_mode) == MODE_PARTIAL_INT)\n     {\n-      machine_mode full_mode\n-\t= smallest_mode_for_size (GET_MODE_BITSIZE (to_mode), MODE_INT);\n+      scalar_int_mode full_mode\n+\t= smallest_int_mode_for_size (GET_MODE_BITSIZE (to_mode));\n \n       gcc_assert (convert_optab_handler (trunc_optab, to_mode, full_mode)\n \t\t  != CODE_FOR_nothing);\n@@ -361,8 +361,8 @@ convert_move (rtx to, rtx from, int unsignedp)\n   if (GET_MODE_CLASS (from_mode) == MODE_PARTIAL_INT)\n     {\n       rtx new_from;\n-      machine_mode full_mode\n-\t= smallest_mode_for_size (GET_MODE_BITSIZE (from_mode), MODE_INT);\n+      scalar_int_mode full_mode\n+\t= smallest_int_mode_for_size (GET_MODE_BITSIZE (from_mode));\n       convert_optab ctab = unsignedp ? zext_optab : sext_optab;\n       enum insn_code icode;\n \n@@ -6848,8 +6848,8 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n       if (GET_CODE (temp) == PARALLEL)\n \t{\n \t  HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));\n-\t  machine_mode temp_mode\n-\t    = smallest_mode_for_size (size * BITS_PER_UNIT, MODE_INT);\n+\t  scalar_int_mode temp_mode\n+\t    = smallest_int_mode_for_size (size * BITS_PER_UNIT);\n \t  rtx temp_target = gen_reg_rtx (temp_mode);\n \t  emit_group_store (temp_target, temp, TREE_TYPE (exp), size);\n \t  temp = temp_target;\n@@ -6920,7 +6920,7 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t word size, we need to load the value (see again store_bit_field).  */\n       if (GET_MODE (temp) == BLKmode && bitsize <= BITS_PER_WORD)\n \t{\n-\t  machine_mode temp_mode = smallest_mode_for_size (bitsize, MODE_INT);\n+\t  scalar_int_mode temp_mode = smallest_int_mode_for_size (bitsize);\n \t  temp = extract_bit_field (temp, bitsize, 0, 1, NULL_RTX, temp_mode,\n \t\t\t\t    temp_mode, false, NULL);\n \t}"}, {"sha": "2c243fdf44ae02dd10ee0c816bb7e44aeba63449", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -2173,7 +2173,7 @@ expand_arith_overflow (enum tree_code code, gimple *stmt)\n       if (orig_precres == precres && precop <= BITS_PER_WORD)\n \t{\n \t  int p = MAX (min_precision, precop);\n-\t  machine_mode m = smallest_mode_for_size (p, MODE_INT);\n+\t  scalar_int_mode m = smallest_int_mode_for_size (p);\n \t  tree optype = build_nonstandard_integer_type (GET_MODE_PRECISION (m),\n \t\t\t\t\t\t\tuns0_p && uns1_p\n \t\t\t\t\t\t\t&& unsr_p);\n@@ -2215,7 +2215,7 @@ expand_arith_overflow (enum tree_code code, gimple *stmt)\n       if (orig_precres == precres)\n \t{\n \t  int p = MAX (prec0, prec1);\n-\t  machine_mode m = smallest_mode_for_size (p, MODE_INT);\n+\t  scalar_int_mode m = smallest_int_mode_for_size (p);\n \t  tree optype = build_nonstandard_integer_type (GET_MODE_PRECISION (m),\n \t\t\t\t\t\t\tuns0_p && uns1_p\n \t\t\t\t\t\t\t&& unsr_p);"}, {"sha": "6fd10b42a8f39192a9d18a5d1155654b8b619d98", "filename": "gcc/machmode.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -588,9 +588,16 @@ float_mode_for_size (unsigned int size)\n \n /* Similar to mode_for_size, but find the smallest mode for a given width.  */\n \n-extern machine_mode smallest_mode_for_size (unsigned int,\n-\t\t\t\t\t\t enum mode_class);\n+extern machine_mode smallest_mode_for_size (unsigned int, enum mode_class);\n \n+/* Find the narrowest integer mode that contains at least SIZE bits.\n+   Such a mode must exist.  */\n+\n+inline scalar_int_mode\n+smallest_int_mode_for_size (unsigned int size)\n+{\n+  return as_a <scalar_int_mode> (smallest_mode_for_size (size, MODE_INT));\n+}\n \n /* Return an integer mode of exactly the same size as the input mode.  */\n "}, {"sha": "48b1250bda24fda4443aa2f1b343636c6092fc32", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -193,13 +193,15 @@ get_best_extraction_insn (extraction_insn *insn,\n \t\t\t  unsigned HOST_WIDE_INT struct_bits,\n \t\t\t  machine_mode field_mode)\n {\n-  machine_mode mode = smallest_mode_for_size (struct_bits, MODE_INT);\n-  FOR_EACH_MODE_FROM (mode, mode)\n+  opt_scalar_int_mode mode_iter;\n+  FOR_EACH_MODE_FROM (mode_iter, smallest_int_mode_for_size (struct_bits))\n     {\n+      scalar_int_mode mode = mode_iter.require ();\n       if (get_extraction_insn (insn, pattern, type, mode))\n \t{\n-\t  FOR_EACH_MODE_FROM (mode, mode)\n+\t  FOR_EACH_MODE_FROM (mode_iter, mode)\n \t    {\n+\t      mode = mode_iter.require ();\n \t      if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (field_mode)\n \t\t  || TRULY_NOOP_TRUNCATION_MODES_P (insn->field_mode,\n \t\t\t\t\t\t    field_mode))"}, {"sha": "ee3b4e9cfaa52ba921d3210bcb0aaebdf169f5eb", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -2084,8 +2084,7 @@ expand_twoval_binop_libfunc (optab binoptab, rtx op0, rtx op1,\n \n   /* The value returned by the library function will have twice as\n      many bits as the nominal MODE.  */\n-  libval_mode = smallest_mode_for_size (2 * GET_MODE_BITSIZE (mode),\n-\t\t\t\t\tMODE_INT);\n+  libval_mode = smallest_int_mode_for_size (2 * GET_MODE_BITSIZE (mode));\n   start_sequence ();\n   libval = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n \t\t\t\t    libval_mode, 2,"}, {"sha": "76d0075507f1abf9cd8b728ff8f33fa4f377e315", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -2194,12 +2194,15 @@ layout_type (tree type)\n     case BOOLEAN_TYPE:\n     case INTEGER_TYPE:\n     case ENUMERAL_TYPE:\n-      SET_TYPE_MODE (type,\n-\t\t     smallest_mode_for_size (TYPE_PRECISION (type), MODE_INT));\n-      TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n-      /* Don't set TYPE_PRECISION here, as it may be set by a bitfield.  */\n-      TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n-      break;\n+      {\n+\tscalar_int_mode mode\n+\t  = smallest_int_mode_for_size (TYPE_PRECISION (type));\n+\tSET_TYPE_MODE (type, mode);\n+\tTYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (mode));\n+\t/* Don't set TYPE_PRECISION here, as it may be set by a bitfield.  */\n+\tTYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (mode));\n+\tbreak;\n+      }\n \n     case REAL_TYPE:\n       {\n@@ -2608,8 +2611,7 @@ initialize_sizetypes (void)\n \n   bprecision\n     = MIN (precision + LOG2_BITS_PER_UNIT + 1, MAX_FIXED_MODE_SIZE);\n-  bprecision\n-    = GET_MODE_PRECISION (smallest_mode_for_size (bprecision, MODE_INT));\n+  bprecision = GET_MODE_PRECISION (smallest_int_mode_for_size (bprecision));\n   if (bprecision > HOST_BITS_PER_DOUBLE_INT)\n     bprecision = HOST_BITS_PER_DOUBLE_INT;\n \n@@ -2624,17 +2626,18 @@ initialize_sizetypes (void)\n   TYPE_UNSIGNED (bitsizetype) = 1;\n \n   /* Now layout both types manually.  */\n-  SET_TYPE_MODE (sizetype, smallest_mode_for_size (precision, MODE_INT));\n+  scalar_int_mode mode = smallest_int_mode_for_size (precision);\n+  SET_TYPE_MODE (sizetype, mode);\n   SET_TYPE_ALIGN (sizetype, GET_MODE_ALIGNMENT (TYPE_MODE (sizetype)));\n   TYPE_SIZE (sizetype) = bitsize_int (precision);\n-  TYPE_SIZE_UNIT (sizetype) = size_int (GET_MODE_SIZE (TYPE_MODE (sizetype)));\n+  TYPE_SIZE_UNIT (sizetype) = size_int (GET_MODE_SIZE (mode));\n   set_min_and_max_values_for_integral_type (sizetype, precision, UNSIGNED);\n \n-  SET_TYPE_MODE (bitsizetype, smallest_mode_for_size (bprecision, MODE_INT));\n+  mode = smallest_int_mode_for_size (bprecision);\n+  SET_TYPE_MODE (bitsizetype, mode);\n   SET_TYPE_ALIGN (bitsizetype, GET_MODE_ALIGNMENT (TYPE_MODE (bitsizetype)));\n   TYPE_SIZE (bitsizetype) = bitsize_int (bprecision);\n-  TYPE_SIZE_UNIT (bitsizetype)\n-    = size_int (GET_MODE_SIZE (TYPE_MODE (bitsizetype)));\n+  TYPE_SIZE_UNIT (bitsizetype) = size_int (GET_MODE_SIZE (mode));\n   set_min_and_max_values_for_integral_type (bitsizetype, bprecision, UNSIGNED);\n \n   /* Create the signed variants of *sizetype.  */"}, {"sha": "72e199f44ff73a81adb87ff850c9e34acab0ba12", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -1180,8 +1180,8 @@ machine_mode\n default_get_mask_mode (unsigned nunits, unsigned vector_size)\n {\n   unsigned elem_size = vector_size / nunits;\n-  machine_mode elem_mode\n-    = smallest_mode_for_size (elem_size * BITS_PER_UNIT, MODE_INT);\n+  scalar_int_mode elem_mode\n+    = smallest_int_mode_for_size (elem_size * BITS_PER_UNIT);\n   machine_mode vector_mode;\n \n   gcc_assert (elem_size * nunits == vector_size);"}, {"sha": "d6ba305e8fd2d2af54f9c7a9e34488163c71439c", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "patch": "@@ -1506,7 +1506,6 @@ canonicalize_loop_ivs (struct loop *loop, tree *nit, bool bump_in_latch)\n   gcond *stmt;\n   edge exit = single_dom_exit (loop);\n   gimple_seq stmts;\n-  machine_mode mode;\n   bool unsigned_p = false;\n \n   for (psi = gsi_start_phis (loop->header);\n@@ -1533,7 +1532,7 @@ canonicalize_loop_ivs (struct loop *loop, tree *nit, bool bump_in_latch)\n       precision = TYPE_PRECISION (type);\n     }\n \n-  mode = smallest_mode_for_size (precision, MODE_INT);\n+  scalar_int_mode mode = smallest_int_mode_for_size (precision);\n   precision = GET_MODE_PRECISION (mode);\n   type = build_nonstandard_integer_type (precision, unsigned_p);\n "}]}