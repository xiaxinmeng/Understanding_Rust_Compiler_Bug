{"sha": "9340d1c97b8a7aa47aff677f9b6db4799670f47b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM0MGQxYzk3YjhhN2FhNDdhZmY2NzdmOWI2ZGI0Nzk5NjcwZjQ3Yg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-10-02T16:47:00Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-10-02T16:55:45Z"}, "message": "c++: cleanup ctor_omit_inherited_parms [PR97268]\n\nctor_omit_inherited_parms was being somewhat abused.  What I'd missed\nis that it checks for a base-dtor name, before proceeding with the\ncheck.  But we ended up passing it that during cloning before we'd\ncompleted the cloning.  It was also using DECL_ORIGIN to get to the\nin-charge ctor, but we sometimes zap DECL_ABSTRACT_ORIGIN, and it ends\nup processing the incoming function -- which happens to work.  so,\nthis breaks out a predicate that expects to get the incharge ctor, and\nwill tell you whether its base ctor will need to omit the parms.  We\ncall that directly during cloning.\n\nThen the original fn is essentially just a wrapper, but uses\nDECL_CLONED_FUNCTION to get to the in-charge ctor.  That uncovered\nabuse in add_method, which was happily passing TEMPLATE_DECLs to it.\nLet's not do that.  add_method itself contained a loop mostly\ncontaining an 'if (nomatch) continue' idiom, except for a final 'if\n(match) {...}'  check, which itself contained instances of the former\nidiom.  I refactored that to use the former idiom throughout.  In\ndoing that I found a place where we'd issue an error, but then not\nactually reject the new member.\n\n\tgcc/cp/\n\t* cp-tree.h (base_ctor_omit_inherited_parms): Declare.\n\t* class.c (add_method): Refactor main loop, only pass fns to\n\tctor_omit_inherited_parms.\n\t(build_cdtor_clones): Rename bool parms.\n\t(clone_cdtor): Call base_ctor_omit_inherited_parms.\n\t* method.c (base_ctor_omit_inherited_parms): New, broken out of\n\t...\n\t(ctor_omit_inherited_parms): ... here, call it with\n\tDECL_CLONED_FUNCTION.\n\tgcc/testsuite/\n\t* g++.dg/inherit/pr97268.C: New.", "tree": {"sha": "39e725b83b1effa518e1c43f6ef0e0757b957bff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39e725b83b1effa518e1c43f6ef0e0757b957bff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9340d1c97b8a7aa47aff677f9b6db4799670f47b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9340d1c97b8a7aa47aff677f9b6db4799670f47b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9340d1c97b8a7aa47aff677f9b6db4799670f47b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9340d1c97b8a7aa47aff677f9b6db4799670f47b/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "315848246657607d5acd9bca29d64d98a4c5f042", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315848246657607d5acd9bca29d64d98a4c5f042", "html_url": "https://github.com/Rust-GCC/gccrs/commit/315848246657607d5acd9bca29d64d98a4c5f042"}], "stats": {"total": 356, "additions": 222, "deletions": 134}, "files": [{"sha": "01780fe82917c287b227333863eb1e29e268582f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 133, "deletions": 126, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9340d1c97b8a7aa47aff677f9b6db4799670f47b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9340d1c97b8a7aa47aff677f9b6db4799670f47b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9340d1c97b8a7aa47aff677f9b6db4799670f47b", "patch": "@@ -1006,10 +1006,6 @@ add_method (tree type, tree method, bool via_using)\n   for (ovl_iterator iter (current_fns); iter; ++iter)\n     {\n       tree fn = *iter;\n-      tree fn_type;\n-      tree method_type;\n-      tree parms1;\n-      tree parms2;\n \n       if (TREE_CODE (fn) != TREE_CODE (method))\n \tcontinue;\n@@ -1037,10 +1033,8 @@ add_method (tree type, tree method, bool via_using)\n \t functions in the derived class override and/or hide member\n \t functions with the same name and parameter types in a base\n \t class (rather than conflicting).  */\n-      fn_type = TREE_TYPE (fn);\n-      method_type = TREE_TYPE (method);\n-      parms1 = TYPE_ARG_TYPES (fn_type);\n-      parms2 = TYPE_ARG_TYPES (method_type);\n+      tree fn_type = TREE_TYPE (fn);\n+      tree method_type = TREE_TYPE (method);\n \n       /* Compare the quals on the 'this' parm.  Don't compare\n \t the whole types, as used functions are treated as\n@@ -1055,137 +1049,149 @@ add_method (tree type, tree method, bool via_using)\n \t      || type_memfn_rqual (fn_type) != type_memfn_rqual (method_type)))\n \t  continue;\n \n-      /* For templates, the return type and template parameters\n-\t must be identical.  */\n-      if (TREE_CODE (fn) == TEMPLATE_DECL\n-\t  && (!same_type_p (TREE_TYPE (fn_type),\n-\t\t\t    TREE_TYPE (method_type))\n-\t      || !comp_template_parms (DECL_TEMPLATE_PARMS (fn),\n-\t\t\t\t       DECL_TEMPLATE_PARMS (method))))\n+      tree real_fn = fn;\n+      tree real_method = method;\n+\n+      /* Templates and conversion ops must match return types.  */\n+      if ((DECL_CONV_FN_P (fn) || TREE_CODE (fn) == TEMPLATE_DECL)\n+\t  && !same_type_p (TREE_TYPE (fn_type), TREE_TYPE (method_type)))\n \tcontinue;\n+      \n+      /* For templates, the template parameters must be identical.  */\n+      if (TREE_CODE (fn) == TEMPLATE_DECL)\n+\t{\n+\t  if (!comp_template_parms (DECL_TEMPLATE_PARMS (fn),\n+\t\t\t\t    DECL_TEMPLATE_PARMS (method)))\n+\t    continue;\n \n-      if (! DECL_STATIC_FUNCTION_P (fn))\n+\t  real_fn = DECL_TEMPLATE_RESULT (fn);\n+\t  real_method = DECL_TEMPLATE_RESULT (method);\n+\t}\n+\n+      tree parms1 = TYPE_ARG_TYPES (fn_type);\n+      tree parms2 = TYPE_ARG_TYPES (method_type);\n+      if (! DECL_STATIC_FUNCTION_P (real_fn))\n \tparms1 = TREE_CHAIN (parms1);\n-      if (! DECL_STATIC_FUNCTION_P (method))\n+      if (! DECL_STATIC_FUNCTION_P (real_method))\n \tparms2 = TREE_CHAIN (parms2);\n \n-      /* Bring back parameters omitted from an inherited ctor.  */\n-      if (ctor_omit_inherited_parms (fn))\n-\tparms1 = FUNCTION_FIRST_USER_PARMTYPE (DECL_ORIGIN (fn));\n-      if (ctor_omit_inherited_parms (method))\n-\tparms2 = FUNCTION_FIRST_USER_PARMTYPE (DECL_ORIGIN (method));\n+      /* Bring back parameters omitted from an inherited ctor.  The\n+\t method and the function can have different omittedness.  */\n+      if (ctor_omit_inherited_parms (real_fn))\n+\tparms1 = FUNCTION_FIRST_USER_PARMTYPE (DECL_CLONED_FUNCTION (real_fn));\n+      if (ctor_omit_inherited_parms (real_method))\n+\tparms2 = (FUNCTION_FIRST_USER_PARMTYPE\n+\t\t  (DECL_CLONED_FUNCTION (real_method)));\n \n-      if (compparms (parms1, parms2)\n-\t  && (!DECL_CONV_FN_P (fn)\n-\t      || same_type_p (TREE_TYPE (fn_type),\n-\t\t\t      TREE_TYPE (method_type))))\n-\t{\n-          if (!equivalently_constrained (fn, method))\n-\t    {\n-\t      if (processing_template_decl)\n-\t\t/* We can't check satisfaction in dependent context, wait until\n-\t\t   the class is instantiated.  */\n-\t\tcontinue;\n-\n-\t      special_function_kind sfk = special_memfn_p (method);\n+      if (!compparms (parms1, parms2))\n+\tcontinue;\n \n-\t      if (sfk == sfk_none\n-\t\t  || DECL_INHERITED_CTOR (fn)\n-\t\t  || TREE_CODE (fn) == TEMPLATE_DECL)\n-\t\t/* Member function templates and non-special member functions\n-\t\t   coexist if they are not equivalently constrained.  A member\n-\t\t   function is not hidden by an inherited constructor.  */\n-\t\tcontinue;\n+      if (!equivalently_constrained (fn, method))\n+\t{\n+\t  if (processing_template_decl)\n+\t    /* We can't check satisfaction in dependent context, wait until\n+\t       the class is instantiated.  */\n+\t    continue;\n \n-\t      /* P0848: For special member functions, deleted, unsatisfied, or\n-\t\t less constrained overloads are ineligible.  We implement this\n-\t\t by removing them from CLASSTYPE_MEMBER_VEC.  Destructors don't\n-\t\t use the notion of eligibility, and the selected destructor can\n-\t\t be deleted, but removing unsatisfied or less constrained\n-\t\t overloads has the same effect as overload resolution.  */\n-\t      bool dtor = (sfk == sfk_destructor);\n-\t      if (losem == -1)\n-\t\tlosem = ((!dtor && DECL_DELETED_FN (method))\n-\t\t\t || !constraints_satisfied_p (method));\n-\t      bool losef = ((!dtor && DECL_DELETED_FN (fn))\n-\t\t\t    || !constraints_satisfied_p (fn));\n-\t      int win;\n-\t      if (losem || losef)\n-\t\twin = losem - losef;\n-\t      else\n-\t\twin = more_constrained (fn, method);\n-\t      if (win > 0)\n-\t\t/* Leave FN in the method vec, discard METHOD.  */\n-\t\treturn false;\n-\t      else if (win < 0)\n-\t\t{\n-\t\t  /* Remove FN, add METHOD.  */\n-\t\t  current_fns = iter.remove_node (current_fns);\n-\t\t  continue;\n-\t\t}\n-\t      else\n-\t\t/* Let them coexist for now.  */\n-\t\tcontinue;\n-\t    }\n+\t  special_function_kind sfk = special_memfn_p (method);\n \n-\t  /* If these are versions of the same function, process and\n-\t     move on.  */\n-\t  if (TREE_CODE (fn) == FUNCTION_DECL\n-\t      && maybe_version_functions (method, fn, true))\n+\t  if (sfk == sfk_none\n+\t      || DECL_INHERITED_CTOR (fn)\n+\t      || TREE_CODE (fn) == TEMPLATE_DECL)\n+\t    /* Member function templates and non-special member functions\n+\t       coexist if they are not equivalently constrained.  A member\n+\t       function is not hidden by an inherited constructor.  */\n \t    continue;\n \n-\t  if (DECL_INHERITED_CTOR (method))\n-\t    {\n-\t      if (DECL_INHERITED_CTOR (fn))\n-\t\t{\n-\t\t  tree basem = DECL_INHERITED_CTOR_BASE (method);\n-\t\t  tree basef = DECL_INHERITED_CTOR_BASE (fn);\n-\t\t  if (flag_new_inheriting_ctors)\n-\t\t    {\n-\t\t      if (basem == basef)\n-\t\t\t{\n-\t\t\t  /* Inheriting the same constructor along different\n-\t\t\t     paths, combine them.  */\n-\t\t\t  SET_DECL_INHERITED_CTOR\n-\t\t\t    (fn, ovl_make (DECL_INHERITED_CTOR (method),\n-\t\t\t\t\t   DECL_INHERITED_CTOR (fn)));\n-\t\t\t  /* And discard the new one.  */\n-\t\t\t  return false;\n-\t\t\t}\n-\t\t      else\n-\t\t\t/* Inherited ctors can coexist until overload\n-\t\t\t   resolution.  */\n-\t\t\tcontinue;\n-\t\t    }\n-\t\t  error_at (DECL_SOURCE_LOCATION (method),\n-\t\t\t    \"%q#D conflicts with version inherited from %qT\",\n-\t\t\t    method, basef);\n-\t\t  inform (DECL_SOURCE_LOCATION (fn),\n-\t\t\t  \"version inherited from %qT declared here\",\n-\t\t\t  basef);\n-\t\t}\n-\t      /* Otherwise defer to the other function.  */\n-\t      return false;\n-\t    }\n-\n-\t  if (via_using)\n-\t    /* Defer to the local function.  */\n+\t  /* P0848: For special member functions, deleted, unsatisfied, or\n+\t     less constrained overloads are ineligible.  We implement this\n+\t     by removing them from CLASSTYPE_MEMBER_VEC.  Destructors don't\n+\t     use the notion of eligibility, and the selected destructor can\n+\t     be deleted, but removing unsatisfied or less constrained\n+\t     overloads has the same effect as overload resolution.  */\n+\t  bool dtor = (sfk == sfk_destructor);\n+\t  if (losem == -1)\n+\t    losem = ((!dtor && DECL_DELETED_FN (method))\n+\t\t     || !constraints_satisfied_p (method));\n+\t  bool losef = ((!dtor && DECL_DELETED_FN (fn))\n+\t\t\t|| !constraints_satisfied_p (fn));\n+\t  int win;\n+\t  if (losem || losef)\n+\t    win = losem - losef;\n+\t  else\n+\t    win = more_constrained (fn, method);\n+\t  if (win > 0)\n+\t    /* Leave FN in the method vec, discard METHOD.  */\n \t    return false;\n-\t  else if (flag_new_inheriting_ctors\n-\t\t   && DECL_INHERITED_CTOR (fn))\n+\t  else if (win < 0)\n \t    {\n-\t      /* Remove the inherited constructor.  */\n+\t      /* Remove FN, add METHOD.  */\n \t      current_fns = iter.remove_node (current_fns);\n \t      continue;\n \t    }\n \t  else\n+\t    /* Let them coexist for now.  */\n+\t    continue;\n+\t}\n+\n+      /* If these are versions of the same function, process and\n+\t move on.  */\n+      if (TREE_CODE (fn) == FUNCTION_DECL\n+\t  && maybe_version_functions (method, fn, true))\n+\tcontinue;\n+\n+      if (DECL_INHERITED_CTOR (method))\n+\t{\n+\t  if (!DECL_INHERITED_CTOR (fn))\n+\t    /* Defer to the other function.  */\n+\t    return false;\n+\t    \n+\t  tree basem = DECL_INHERITED_CTOR_BASE (method);\n+\t  tree basef = DECL_INHERITED_CTOR_BASE (fn);\n+\t  if (flag_new_inheriting_ctors)\n \t    {\n-\t      error_at (DECL_SOURCE_LOCATION (method),\n-\t\t\t\"%q#D cannot be overloaded with %q#D\", method, fn);\n-\t      inform (DECL_SOURCE_LOCATION (fn),\n-\t\t      \"previous declaration %q#D\", fn);\n-\t      return false;\n+\t      if (basem == basef)\n+\t\t{\n+\t\t  /* Inheriting the same constructor along different\n+\t\t     paths, combine them.  */\n+\t\t  SET_DECL_INHERITED_CTOR\n+\t\t    (fn, ovl_make (DECL_INHERITED_CTOR (method),\n+\t\t\t\t   DECL_INHERITED_CTOR (fn)));\n+\t\t  /* And discard the new one.  */\n+\t\t  return false;\n+\t\t}\n+\t      else\n+\t\t/* Inherited ctors can coexist until overload\n+\t\t   resolution.  */\n+\t\tcontinue;\n \t    }\n+\n+\t  error_at (DECL_SOURCE_LOCATION (method),\n+\t\t    \"%q#D conflicts with version inherited from %qT\",\n+\t\t    method, basef);\n+\t  inform (DECL_SOURCE_LOCATION (fn),\n+\t\t  \"version inherited from %qT declared here\",\n+\t\t  basef);\n+\t  return false;\n+\t}\n+\n+      if (via_using)\n+\t/* Defer to the local function.  */\n+\treturn false;\n+      else if (flag_new_inheriting_ctors\n+\t       && DECL_INHERITED_CTOR (fn))\n+\t{\n+\t  /* Remove the inherited constructor.  */\n+\t  current_fns = iter.remove_node (current_fns);\n+\t  continue;\n+\t}\n+      else\n+\t{\n+\t  error_at (DECL_SOURCE_LOCATION (method),\n+\t\t    \"%q#D cannot be overloaded with %q#D\", method, fn);\n+\t  inform (DECL_SOURCE_LOCATION (fn),\n+\t\t  \"previous declaration %q#D\", fn);\n+\t  return false;\n \t}\n     }\n \n@@ -4892,7 +4898,7 @@ build_clone (tree fn, tree name, bool need_vtt_parm_p,\n    will be inserted onto DECL_CHAIN of FN.  */\n \n static unsigned\n-build_cdtor_clones (tree fn, bool needs_vtt_parm_p, bool omit_inherited_parms_p)\n+build_cdtor_clones (tree fn, bool needs_vtt_p, bool base_omits_inherited_p)\n {\n   unsigned count = 0;\n \n@@ -4901,8 +4907,8 @@ build_cdtor_clones (tree fn, bool needs_vtt_parm_p, bool omit_inherited_parms_p)\n       /* For each constructor, we need two variants: an in-charge version\n \t and a not-in-charge version.  */\n       build_clone (fn, complete_ctor_identifier, false, false);\n-      build_clone (fn, base_ctor_identifier, needs_vtt_parm_p,\n-\t\t   omit_inherited_parms_p);\n+      build_clone (fn, base_ctor_identifier, needs_vtt_p,\n+\t\t   base_omits_inherited_p);\n       count += 2;\n     }\n   else\n@@ -4924,7 +4930,7 @@ build_cdtor_clones (tree fn, bool needs_vtt_parm_p, bool omit_inherited_parms_p)\n \t  count++;\n \t}\n       build_clone (fn, complete_dtor_identifier, false, false);\n-      build_clone (fn, base_dtor_identifier, needs_vtt_parm_p, false);\n+      build_clone (fn, base_dtor_identifier, needs_vtt_p, false);\n       count += 2;\n     }\n \n@@ -4948,9 +4954,10 @@ clone_cdtor (tree fn, bool update_methods)\n \n   /* Base ctor omits inherited parms it needs a vttparm and inherited\n      from a virtual nase ctor.  */\n-  bool omit_inherited = ctor_omit_inherited_parms (fn);\n+  bool base_omits_inherited = (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (fn)\n+\t\t\t       && base_ctor_omit_inherited_parms (fn));\n \n-  unsigned count = build_cdtor_clones (fn, vtt, omit_inherited);\n+  unsigned count = build_cdtor_clones (fn, vtt, base_omits_inherited);\n \n   /* Note that this is an abstract function that is never emitted.  */\n   DECL_ABSTRACT_P (fn) = true;"}, {"sha": "43e0c18ec03cfcf5d30b4792197d8b7c86b915b3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9340d1c97b8a7aa47aff677f9b6db4799670f47b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9340d1c97b8a7aa47aff677f9b6db4799670f47b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9340d1c97b8a7aa47aff677f9b6db4799670f47b", "patch": "@@ -6764,6 +6764,7 @@ extern tree get_default_ctor\t\t\t(tree);\n extern tree get_dtor\t\t\t\t(tree, tsubst_flags_t);\n extern tree strip_inheriting_ctors\t\t(tree);\n extern tree inherited_ctor_binfo\t\t(tree);\n+extern bool base_ctor_omit_inherited_parms\t(tree);\n extern bool ctor_omit_inherited_parms\t\t(tree);\n extern tree locate_ctor\t\t\t\t(tree);\n extern tree implicitly_declare_fn               (special_function_kind, tree,"}, {"sha": "6e4c5f7e83b8fb6ff4ae691bb1b53d3b59fb7879", "filename": "gcc/cp/method.c", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9340d1c97b8a7aa47aff677f9b6db4799670f47b/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9340d1c97b8a7aa47aff677f9b6db4799670f47b/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=9340d1c97b8a7aa47aff677f9b6db4799670f47b", "patch": "@@ -551,31 +551,51 @@ inherited_ctor_binfo (tree fndecl)\n   return inherited_ctor_binfo (binfo, fndecl);\n }\n \n-/* True if we should omit all user-declared parameters from constructor FN,\n-   because it is a base clone of a ctor inherited from a virtual base.  */\n+\n+/* True if we should omit all user-declared parameters from a base\n+   construtor built from complete constructor FN.\n+   That's when the ctor is inherited from a virtual base.  */\n \n bool\n-ctor_omit_inherited_parms (tree fn)\n+base_ctor_omit_inherited_parms (tree comp_ctor)\n {\n+  gcc_checking_assert (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (comp_ctor));\n+\n   if (!flag_new_inheriting_ctors)\n     /* We only optimize away the parameters in the new model.  */\n     return false;\n-  if (!DECL_BASE_CONSTRUCTOR_P (fn)\n-      || !CLASSTYPE_VBASECLASSES (DECL_CONTEXT (fn)))\n+\n+  if (!CLASSTYPE_VBASECLASSES (DECL_CONTEXT (comp_ctor)))\n     return false;\n \n-  if (FUNCTION_FIRST_USER_PARMTYPE (DECL_ORIGIN (fn)) == void_list_node)\n+  if (FUNCTION_FIRST_USER_PARMTYPE (comp_ctor) == void_list_node)\n     /* No user-declared parameters to omit.  */\n     return false;\n \n-  tree binfo = inherited_ctor_binfo (fn);\n-  for (; binfo; binfo = BINFO_INHERITANCE_CHAIN (binfo))\n+  for (tree binfo = inherited_ctor_binfo (comp_ctor);\n+       binfo;\n+       binfo = BINFO_INHERITANCE_CHAIN (binfo))\n     if (BINFO_VIRTUAL_P (binfo))\n       return true;\n \n   return false;\n }\n \n+\n+/* True if we should omit all user-declared parameters from constructor FN,\n+   because it is a base clone of a ctor inherited from a virtual base.  */\n+\n+bool\n+ctor_omit_inherited_parms (tree fn)\n+{\n+  gcc_checking_assert (TREE_CODE (fn) == FUNCTION_DECL);\n+\n+  if (!DECL_BASE_CONSTRUCTOR_P (fn))\n+    return false;\n+\n+  return base_ctor_omit_inherited_parms (DECL_CLONED_FUNCTION (fn));\n+}\n+\n /* True iff constructor(s) INH inherited into BINFO initializes INIT_BINFO.\n    This can be true for multiple virtual bases as well as one direct\n    non-virtual base.  */"}, {"sha": "79a809cd230e851dd87c0228ba81212ad9955304", "filename": "gcc/testsuite/g++.dg/inherit/pr97268.C", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9340d1c97b8a7aa47aff677f9b6db4799670f47b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fpr97268.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9340d1c97b8a7aa47aff677f9b6db4799670f47b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fpr97268.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fpr97268.C?ref=9340d1c97b8a7aa47aff677f9b6db4799670f47b", "patch": "@@ -0,0 +1,60 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options -Wall }\n+// PR 97268, ICE due to broken inherited-from-virtual base-ctor\n+class Handle {\n+public:\n+    explicit Handle(char const *const &) { }\n+    ~Handle() {}\n+    Handle(const Handle &) = delete;\n+    Handle &operator=(const Handle &) = delete;\n+\n+protected:\n+    int lasterr = 0;\n+\n+};\n+\n+struct ObjectBase {\n+    ~ObjectBase() {}\n+\n+protected:\n+    explicit ObjectBase(const char *lc_, int ln_, Handle &h, unsigned) \n+            :  handle(h) { }\n+\n+protected:\n+\n+    Handle &handle;\n+};\n+\n+template <bool CACHED>\n+struct Object : virtual public ObjectBase {\n+    explicit Object(const char *lc_, int ln_, Handle &env);\n+\n+protected:\n+    using ObjectBase::ObjectBase;\n+\n+};\n+\n+class BetterObjectBase : virtual public ObjectBase {\n+protected:\n+    BetterObjectBase(const char *lc_, int ln_, Handle &env)\n+            : ObjectBase(\"\", 0, env, 0) {}\n+\n+};\n+\n+template <bool CACHED>\n+class BetterObject : public Object<CACHED>, public BetterObjectBase {\n+public:\n+    BetterObject(Handle &env)\n+      : ObjectBase(\"\", 0, env, 0)\n+      , Object<CACHED>(\"\", 0, env, 0)\n+      , BetterObjectBase(\"\", 0, env) {} // { dg-error \"use of deleted function\" }\n+\n+};\n+\n+int main() {\n+    Handle h(\"handle\");\n+\n+    BetterObject<true> B(h);\n+\n+    return 0;\n+}"}]}