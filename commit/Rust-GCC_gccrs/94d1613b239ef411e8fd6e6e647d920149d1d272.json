{"sha": "94d1613b239ef411e8fd6e6e647d920149d1d272", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRkMTYxM2IyMzllZjQxMWU4ZmQ2ZTZlNjQ3ZDkyMDE0OWQxZDI3Mg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@apple.com", "date": "2004-03-04T00:18:54Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2004-03-04T00:18:54Z"}, "message": "Add framework support for darwin.\n\n\t* c-incpath.c: Include target.h and machmode.h.\n\t(add_path): Use a consistent style for cpp_dir.  Initialize\n\tp->construct to 0.\n\t(add_cpp_dir_path): New.\n\t(register_include_chains): Add use of extra_includes callback.\n\t(hook_void_int): Add.\n\t(target_c_incpath): Add.\n\t* c-incpath.h (add_cpp_dir_path): New.\n\t(target_c_incpath_s): Add.\n\t(target_c_incpath): Add.\n\t(C_INCPATH_INIT): Add.\n\t* c-opts.c (c_common_missing_argument,\n\tc_common_handle_option): Add -F argument processing.\n\t* c.opt: Add -F argument processing.\n\t* gcc.c (trad_capable_cpp): Add -F argument processing.\n\t* cppfiles.c (find_file_in_dir): Update to use construct\n\tcallback.\n\t(search_path_exhausted, cpp_get_path, cpp_get_buffer,\n\tcpp_get_prev): New.\n\t(_cpp_find_file): Use search_path_exhausted.\n\t(make_cpp_dir): Initialize construct to 0.\n\t* cpplib.h (missing_header_cb\n\tcpp_get_path, cpp_get_buffer, cpp_get_file, cpp_get_prev): New.\n\t(cpp_callbacks): Add missing_header\n\t(cpp_dir): Add construct.\n\t* target-def.h: (TARGET_OPTF): New.\n\t* hooks.c (hook_void_int, hook_void_charptr): Add.\n\t* hooks.h (hook_void_int, hook_void_charptr): Add.\n\t* Makefile.in (c-incpath.o) : Add $(TARGET_H) and\n\t$(MACHMODE_H) dependencies.\n\t* doc/invoke.texi (Darwin Options): Document -F.\n\t* doc/tm.texi (TARGET_EXTRA_INCLUDES): Add.\n\t(TARGET_OPTF): Add.\n\t* fix-header.c (target_c_incpath): Add.\n\n\t* config/darwin-c.c: Add c-incpath.h include.\n\t(using_frameworks, find_subframework_file,\n\tfind_subframework_header, add_system_framework_path,\n\tframeworks_in_use, num_frameworks, max_frameworks,\n\tadd_framework, find_framework, struct framework_header,\n\tframework_header_dirs, framework_construct_pathname,\n\tfind_subframework_file, add_system_framework_path,\n\tadd_framework_path, framework_defaults,\n\tdarwin_register_frameworks, find_subframework_header): Add.\n\t* config/darwin.h (TARGET_EXTRA_INCLUDES, TARGET_OPTF): New.\n\t(TARGET_OPTION_TRANSLATE_TABLE): Add -framework support.\n\t(CPP_SPEC): Add __APPLE_CC__ support.\n\t* t-darwin (darwin-c.o): Add c-incpath.h dependency.\n\nFrom-SVN: r78875", "tree": {"sha": "52808307852a6d2e40b91f9dd8a1f85f701d9c10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52808307852a6d2e40b91f9dd8a1f85f701d9c10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94d1613b239ef411e8fd6e6e647d920149d1d272", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94d1613b239ef411e8fd6e6e647d920149d1d272", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94d1613b239ef411e8fd6e6e647d920149d1d272", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94d1613b239ef411e8fd6e6e647d920149d1d272/comments", "author": null, "committer": null, "parents": [{"sha": "c158d74ab414718dba2a566728c4b58ed6f781f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c158d74ab414718dba2a566728c4b58ed6f781f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c158d74ab414718dba2a566728c4b58ed6f781f7"}], "stats": {"total": 631, "additions": 609, "deletions": 22}, "files": [{"sha": "fd13ce718a2c15a4bd5822c00bdbf4634a72af99", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -1,3 +1,56 @@\n+2004-03-03  Mike Stump  <mrs@apple.com>\n+\n+\tAdd framework support for darwin.\n+\n+\t* c-incpath.c: Include target.h and machmode.h.\n+\t(add_path): Use a consistent style for cpp_dir.  Initialize\n+\tp->construct to 0.\n+\t(add_cpp_dir_path): New.\n+\t(register_include_chains): Add use of extra_includes callback.\n+\t(hook_void_int): Add.\n+\t(target_c_incpath): Add.\n+\t* c-incpath.h (add_cpp_dir_path): New.\n+\t(target_c_incpath_s): Add.\n+\t(target_c_incpath): Add.\n+\t(C_INCPATH_INIT): Add.\n+\t* c-opts.c (c_common_missing_argument,\n+\tc_common_handle_option): Add -F argument processing.\n+\t* c.opt: Add -F argument processing.\n+\t* gcc.c (trad_capable_cpp): Add -F argument processing.\n+\t* cppfiles.c (find_file_in_dir): Update to use construct\n+\tcallback.\n+\t(search_path_exhausted, cpp_get_path, cpp_get_buffer,\n+\tcpp_get_prev): New.\n+\t(_cpp_find_file): Use search_path_exhausted.\n+\t(make_cpp_dir): Initialize construct to 0.\n+\t* cpplib.h (missing_header_cb\n+\tcpp_get_path, cpp_get_buffer, cpp_get_file, cpp_get_prev): New.\n+\t(cpp_callbacks): Add missing_header\n+\t(cpp_dir): Add construct.\n+\t* target-def.h: (TARGET_OPTF): New.\n+\t* hooks.c (hook_void_int, hook_void_charptr): Add.\n+\t* hooks.h (hook_void_int, hook_void_charptr): Add.\n+\t* Makefile.in (c-incpath.o) : Add $(TARGET_H) and\n+\t$(MACHMODE_H) dependencies.\n+\t* doc/invoke.texi (Darwin Options): Document -F.\n+\t* doc/tm.texi (TARGET_EXTRA_INCLUDES): Add.\n+\t(TARGET_OPTF): Add.\n+\t* fix-header.c (target_c_incpath): Add.\n+\n+\t* config/darwin-c.c: Add c-incpath.h include.\n+\t(using_frameworks, find_subframework_file,\n+\tfind_subframework_header, add_system_framework_path,\n+\tframeworks_in_use, num_frameworks, max_frameworks,\n+\tadd_framework, find_framework, struct framework_header,\n+\tframework_header_dirs, framework_construct_pathname,\n+\tfind_subframework_file, add_system_framework_path,\n+\tadd_framework_path, framework_defaults,\n+\tdarwin_register_frameworks, find_subframework_header): Add.\n+\t* config/darwin.h (TARGET_EXTRA_INCLUDES, TARGET_OPTF): New.\n+\t(TARGET_OPTION_TRANSLATE_TABLE): Add -framework support.\n+\t(CPP_SPEC): Add __APPLE_CC__ support.\n+\t* t-darwin (darwin-c.o): Add c-incpath.h dependency.\n+\n 2004-03-04  Jan Hubicka  <jh@suse.cz>\n \n \t* cselib.c (cselib_finish): Fix miss-application of my previous"}, {"sha": "994f0e8ceed77c3abbf6c7a8c9a3b62d854fdb3f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -1297,7 +1297,8 @@ c-parse.y: c-parse.in\n \t$(SHELL) $(srcdir)/../move-if-change tmp-c-parse.y $@\n \n c-incpath.o: c-incpath.c c-incpath.h $(CONFIG_H) $(SYSTEM_H) $(CPPLIB_H) \\\n-\t\tintl.h prefix.h coretypes.h $(TM_H) cppdefault.h\n+\t\tintl.h prefix.h coretypes.h $(TM_H) cppdefault.h $(TARGET_H) \\\n+\t\t$(MACHMODE_H)\n \n c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(RTL_H) $(C_TREE_H) $(GGC_H) $(TARGET_H) flags.h function.h output.h \\\n@@ -1360,9 +1361,10 @@ c-common.o : c-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n c-pretty-print.o : c-pretty-print.c $(C_PRETTY_PRINT_H) \\\n \t$(C_COMMON_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) real.h\n \n-c-opts.o : c-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-        c-pragma.h flags.h toplev.h langhooks.h tree-inline.h $(DIAGNOSTIC_H) \\\n-\tintl.h debug.h $(C_COMMON_H) opts.h options.h $(PARAMS_H)\n+c-opts.o : c-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\t\t\\\n+        $(TREE_H) c-pragma.h flags.h toplev.h langhooks.h\t\t\\\n+        tree-inline.h $(DIAGNOSTIC_H) intl.h debug.h $(C_COMMON_H)\t\\\n+        opts.h options.h $(PARAMS_H)\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t\t$< $(OUTPUT_OPTION) @TARGET_SYSTEM_ROOT_DEFINE@\n "}, {"sha": "7f6cbdf63f048503b8a321950871f865a7a8b98c", "filename": "gcc/c-incpath.c", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fc-incpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fc-incpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-incpath.c?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -21,6 +21,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"machmode.h\"\n+#include \"target.h\"\n #include \"tm.h\"\n #include \"cpplib.h\"\n #include \"prefix.h\"\n@@ -298,20 +300,33 @@ split_quote_chain (void)\n   quote_ignores_source_dir = true;\n }\n \n+/* Add P to the chain specified by CHAIN.  */\n+\n+void\n+add_cpp_dir_path (cpp_dir *p, int chain)\n+{\n+  if (tails[chain])\n+    tails[chain]->next = p;\n+  else\n+    heads[chain] = p;\n+  tails[chain] = p;\n+}\n+\n /* Add PATH to the include chain CHAIN. PATH must be malloc-ed and\n    NUL-terminated.  */\n void\n add_path (char *path, int chain, int cxx_aware)\n {\n-  struct cpp_dir *p;\n+  cpp_dir *p;\n \n-  p = xmalloc (sizeof (struct cpp_dir));\n+  p = xmalloc (sizeof (cpp_dir));\n   p->next = NULL;\n   p->name = path;\n   if (chain == SYSTEM || chain == AFTER)\n     p->sysp = 1 + !cxx_aware;\n   else\n     p->sysp = 0;\n+  p->construct = 0;\n \n   if (tails[chain])\n     tails[chain]->next = p;\n@@ -347,8 +362,16 @@ register_include_chains (cpp_reader *pfile, const char *sysroot,\n   if (stdinc)\n     add_standard_paths (sysroot, iprefix, cxx_stdinc);\n \n+  target_c_incpath.extra_includes (stdinc);\n+\n   merge_include_chains (pfile, verbose);\n \n   cpp_set_include_chains (pfile, heads[QUOTE], heads[BRACKET],\n \t\t\t  quote_ignores_source_dir);\n }\n+\n+#ifndef TARGET_EXTRA_INCLUDES\n+static void hook_void_int(int u ATTRIBUTE_UNUSED) { }\n+\n+struct target_c_incpath_s target_c_incpath = { hook_void_int };\n+#endif"}, {"sha": "80b413051758175bd6a3ec13de06b51267ebf9ae", "filename": "gcc/c-incpath.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fc-incpath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fc-incpath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-incpath.h?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -19,5 +19,15 @@ extern void split_quote_chain (void);\n extern void add_path (char *, int, int);\n extern void register_include_chains (cpp_reader *, const char *,\n \t\t\t\t     const char *, int, int, int);\n+extern void add_cpp_dir_path (struct cpp_dir *, int);\n+\n+struct target_c_incpath_s {\n+  /* Do extra includes processing.  STDINC is false iff -nostdinc was given.  */\n+  void (*extra_includes) (int);\n+};\n+\n+extern struct target_c_incpath_s target_c_incpath;\n+\n+#define C_INCPATH_INIT { TARGET_EXTRA_INCLUDES }\n \n enum { QUOTE = 0, BRACKET, SYSTEM, AFTER };"}, {"sha": "6d9696a042c82c046d6121df3ba21c49ae02fa4a", "filename": "gcc/c-opts.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -153,6 +153,7 @@ c_common_missing_argument (const char *opt, size_t code)\n       error (\"macro name missing after \\\"%s\\\"\", opt);\n       break;\n \n+    case OPT_F:\n     case OPT_I:\n     case OPT_idirafter:\n     case OPT_isysroot:\n@@ -285,6 +286,10 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n       cpp_opts->print_include_names = 1;\n       break;\n \n+    case OPT_F:\n+      TARGET_OPTF (xstrdup (arg));\n+      break;\n+\n     case OPT_I:\n       if (strcmp (arg, \"-\"))\n \tadd_path (xstrdup (arg), BRACKET, 0);"}, {"sha": "151c2de6e529b57a05b0723fef3bafa8bb9feaab", "filename": "gcc/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc.opt?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -93,6 +93,10 @@ C ObjC C++ ObjC++ Joined Separate\n E\n C ObjC C++ ObjC++ Undocumented\n \n+F\n+C ObjC C++ ObjC++ Joined Separate\n+-F <dir>\tAdd <dir> to the end of the main framework include path  \n+\n H\n C ObjC C++ ObjC++\n Print the name of header files as they are used"}, {"sha": "a4c6d8bd1daa60b01ae4726d51c3311754e8a8e6", "filename": "gcc/config/darwin-c.c", "status": "modified", "additions": 317, "deletions": 0, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fconfig%2Fdarwin-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fconfig%2Fdarwin-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-c.c?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -27,18 +27,24 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"c-pragma.h\"\n #include \"c-tree.h\"\n+#include \"c-incpath.h\"\n #include \"toplev.h\"\n #include \"tm_p.h\"\n \n /* Pragmas.  */\n \n #define BAD(msgid) do { warning (msgid); return; } while (0)\n \n+static bool using_frameworks = false;\n+\n /* Maintain a small stack of alignments.  This is similar to pragma\n    pack's stack, but simpler.  */\n \n static void push_field_alignment (int);\n static void pop_field_alignment (void);\n+static const char *find_subframework_file (const char *, const char *);\n+static void add_system_framework_path (char *);\n+static const char *find_subframework_header (cpp_reader *pfile, const char *header);\n \n typedef struct align_stack\n {\n@@ -147,3 +153,314 @@ darwin_pragma_unused (cpp_reader *pfile ATTRIBUTE_UNUSED)\n   if (c_lex (&x) != CPP_EOF)\n     warning (\"junk at end of '#pragma unused'\");\n }\n+\n+static struct {\n+  size_t len;\n+  const char *name;\n+  cpp_dir* dir;\n+} *frameworks_in_use;\n+static int num_frameworks = 0;\n+static int max_frameworks = 0;\n+\n+\n+/* Remember which frameworks have been seen, so that we can ensure\n+   that all uses of that framework come from the same framework.  DIR\n+   is the place where the named framework NAME, which is of length\n+   LEN, was found.  */\n+\n+static void\n+add_framework (const char *name, size_t len, cpp_dir *dir)\n+{\n+  int i;\n+  for (i = 0; i < num_frameworks; ++i)\n+    {\n+      if (len == frameworks_in_use[i].len\n+\t  && strncmp (name, frameworks_in_use[i].name, len) == 0)\n+\t{\n+\t  return;\n+\t}\n+    }\n+  if (i >= max_frameworks)\n+    {\n+      max_frameworks = i*2;\n+      frameworks_in_use = xrealloc (frameworks_in_use,\n+\t\t\t\t    max_frameworks*sizeof(*frameworks_in_use));\n+    }\n+  frameworks_in_use[num_frameworks].name = name;\n+  frameworks_in_use[num_frameworks].len = len;\n+  frameworks_in_use[num_frameworks].dir = dir;\n+  ++num_frameworks;\n+}\n+\n+/* Recall if we have seen the named framework NAME, before, and where\n+   we saw it.  NAME is LEN bytes long.  The return value is the place\n+   where it was seen before.  */\n+\n+static struct cpp_dir*\n+find_framework (const char *name, size_t len)\n+{\n+  int i;\n+  for (i = 0; i < num_frameworks; ++i)\n+    {\n+      if (len == frameworks_in_use[i].len\n+\t  && strncmp (name, frameworks_in_use[i].name, len) == 0)\n+\t{\n+\t  return frameworks_in_use[i].dir;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* There are two directories in a framework that contain header files,\n+   Headers and PrivateHeaders.  We search Headers first as it is more\n+   common to upgrade a header from PrivateHeaders to Headers and when\n+   that is done, the old one might hang around and be out of data,\n+   causing grief.  */\n+\n+struct framework_header {const char * dirName; int dirNameLen; };\n+static struct framework_header framework_header_dirs[] = {\n+  { \"Headers\", 7 },\n+  { \"PrivateHeaders\", 14 },\n+  { NULL, 0 }\n+};\n+\n+/* Returns a pointer to a malloced string that contains the real pathname\n+   to the file, given the base name and the name.  */\n+\n+static char *\n+framework_construct_pathname (const char *fname, cpp_dir *dir)\n+{\n+  char *buf;\n+  size_t fname_len, frname_len;\n+  cpp_dir *fast_dir;\n+  char *frname;\n+  struct stat st;\n+  int i;\n+\n+  /* Framework names must have a / in them.  */\n+  buf = strchr (fname, '/');\n+  if (buf)\n+    fname_len = buf - fname;\n+  else\n+    return 0;\n+\n+  fast_dir = find_framework (fname, fname_len);\n+\n+  /* Framework includes must all come from one framework.  */\n+  if (fast_dir && dir != fast_dir)\n+    return 0;\n+\n+  frname = xmalloc (strlen (fname) + dir->len + 2\n+\t\t    + strlen(\".framework/\") + strlen(\"PrivateHeaders\"));\n+  strncpy (&frname[0], dir->name, dir->len);\n+  frname_len = dir->len;\n+  if (frname_len && frname[frname_len-1] != '/')\n+    frname[frname_len++] = '/';\n+  strncpy (&frname[frname_len], fname, fname_len);\n+  frname_len += fname_len;\n+  strncpy (&frname[frname_len], \".framework/\", strlen (\".framework/\"));\n+  frname_len += strlen (\".framework/\");\n+\n+  /* Append framework_header_dirs and header file name */\n+  for (i = 0; framework_header_dirs[i].dirName; i++)\n+    {\n+      strncpy (&frname[frname_len], \n+\t       framework_header_dirs[i].dirName,\n+\t       framework_header_dirs[i].dirNameLen);\n+      strcpy (&frname[frname_len + framework_header_dirs[i].dirNameLen],\n+\t      &fname[fname_len]);\n+\n+      if (stat (frname, &st) == 0)\n+\t{\n+\t  add_framework (fname, fname_len, dir);\n+\t  return frname;\n+\t}\n+    }\n+\n+  free (frname);\n+  return 0;\n+}\n+\n+/* Search for FNAME in sub-frameworks.  pname is the context that we\n+   wish to search in.  Return the path the file was found at,\n+   otherwise return 0.  */\n+\n+static const char*\n+find_subframework_file (const char *fname, const char *pname)\n+{\n+  char *sfrname;\n+  const char *dot_framework = \".framework/\";\n+  char *bufptr; \n+  int sfrname_len, i, fname_len; \n+  struct cpp_dir *fast_dir;\n+  static struct cpp_dir subframe_dir;\n+  struct stat st;\n+\n+  bufptr = strchr (fname, '/');\n+\n+  /* Subframework files must have / in the name.  */\n+  if (bufptr == 0)\n+    return 0;\n+    \n+  fname_len = bufptr - fname;\n+  fast_dir = find_framework (fname, fname_len);\n+\n+  /* Sub framework header filename includes parent framework name and\n+     header name in the \"CarbonCore/OSUtils.h\" form. If it does not\n+     include slash it is not a sub framework include.  */\n+  bufptr = strstr (pname, dot_framework);\n+\n+  /* If the parent header is not of any framework, then this header\n+     can not be part of any subframework.  */\n+  if (!bufptr)\n+    return 0;\n+\n+  /* Now translate. For example,                  +- bufptr\n+     fname = CarbonCore/OSUtils.h                 | \n+     pname = /System/Library/Frameworks/Foundation.framework/Headers/Foundation.h\n+     into\n+     sfrname = /System/Library/Frameworks/Foundation.framework/Frameworks/CarbonCore.framework/Headers/OSUtils.h */\n+\n+  sfrname = (char *) xmalloc (strlen (pname) + strlen (fname) + 2 +\n+\t\t\t      strlen (\"Frameworks/\") + strlen (\".framework/\")\n+\t\t\t      + strlen (\"PrivateHeaders\"));\n+ \n+  bufptr += strlen (dot_framework);\n+\n+  sfrname_len = bufptr - pname; \n+\n+  strncpy (&sfrname[0], pname, sfrname_len);\n+\n+  strncpy (&sfrname[sfrname_len], \"Frameworks/\", strlen (\"Frameworks/\"));\n+  sfrname_len += strlen(\"Frameworks/\");\n+\n+  strncpy (&sfrname[sfrname_len], fname, fname_len);\n+  sfrname_len += fname_len;\n+\n+  strncpy (&sfrname[sfrname_len], \".framework/\", strlen (\".framework/\"));\n+  sfrname_len += strlen (\".framework/\");\n+\n+  /* Append framework_header_dirs and header file name */\n+  for (i = 0; framework_header_dirs[i].dirName; i++)\n+    {\n+      strncpy (&sfrname[sfrname_len], \n+\t       framework_header_dirs[i].dirName,\n+\t       framework_header_dirs[i].dirNameLen);\n+      strcpy (&sfrname[sfrname_len + framework_header_dirs[i].dirNameLen],\n+\t      &fname[fname_len]);\n+    \n+      if (stat (sfrname, &st) == 0)\n+\t{\n+\t  if (fast_dir != &subframe_dir)\n+\t    {\n+\t      if (fast_dir)\n+\t\twarning (\"subframework include %s conflicts with framework include\",\n+\t\t\t fname);\n+\t      else\n+\t\tadd_framework (fname, fname_len, &subframe_dir);\n+\t    }\n+\n+\t  return sfrname;\n+\t}\n+    }\n+  free (sfrname);\n+\n+  return 0;\n+}\n+\n+/* Add PATH to the system includes. PATH must be malloc-ed and\n+   NUL-terminated.  System framework paths are C++ aware.  */\n+\n+static void\n+add_system_framework_path (char *path)\n+{\n+  int cxx_aware = 1;\n+  cpp_dir *p;\n+\n+  p = xmalloc (sizeof (cpp_dir));\n+  p->next = NULL;\n+  p->name = path;\n+  p->sysp = 1 + !cxx_aware;\n+  p->construct = framework_construct_pathname;\n+  using_frameworks = 1;\n+\n+  add_cpp_dir_path (p, SYSTEM);\n+}\n+\n+/* Add PATH to the bracket includes. PATH must be malloc-ed and\n+   NUL-terminated.  */\n+\n+void\n+add_framework_path (char *path)\n+{\n+  cpp_dir *p;\n+\n+  p = xmalloc (sizeof (cpp_dir));\n+  p->next = NULL;\n+  p->name = path;\n+  p->sysp = 0;\n+  p->construct = framework_construct_pathname;\n+  using_frameworks = 1;\n+\n+  add_cpp_dir_path (p, BRACKET);\n+}\n+\n+static const char *framework_defaults [] = \n+  {\n+    \"/System/Library/Frameworks\",\n+    \"/Library/Frameworks\",\n+    \"/Local/Library/Frameworks\",\n+  };\n+\n+\n+/* Register all the system framework paths if STDINC is true and setup\n+   the missing_header callback for subframework searching if any\n+   frameworks had been registered.  */\n+\n+void\n+darwin_register_frameworks (int stdinc)\n+{\n+  if (stdinc)\n+    {\n+      size_t i;\n+\n+      /* Setup default search path for frameworks.  */\n+      for (i=0; i<sizeof (framework_defaults)/sizeof(const char *); ++i)\n+\t{\n+\t  /* System Framework headers are cxx aware.  */\n+\t  add_system_framework_path (xstrdup (framework_defaults[i]));\n+\t}\n+    }\n+\n+  if (using_frameworks)\n+    cpp_get_callbacks (parse_in)->missing_header = find_subframework_header;\n+}\n+\n+/* Search for HEADER in context dependent way.  The return value is\n+   the malloced name of a header to try and open, if any, or NULL\n+   otherwise.  This is called after normal header lookup processing\n+   fails to find a header.  We search each file in the include stack,\n+   using FUNC, starting from the most deeply nested include and\n+   finishing with the main input file.  We stop searching when FUNC\n+   returns non-zero.  */\n+\n+static const char*\n+find_subframework_header (cpp_reader *pfile, const char *header)\n+{\n+  const char *fname = header;\n+  struct cpp_buffer *b;\n+  const char *n;\n+\n+  for (b = cpp_get_buffer (pfile);\n+       b && cpp_get_file (b) && cpp_get_path (cpp_get_file (b));\n+       b = cpp_get_prev (b))\n+    {\n+      n = find_subframework_file (fname, cpp_get_path (cpp_get_file (b)));\n+      if (n)\n+\treturn n;\n+    }\n+\n+  return 0;\n+}\n+\n+struct target_c_incpath_s target_c_incpath = C_INCPATH_INIT;"}, {"sha": "b5dae39e967f67e5af13b7e28e6f948f8e305f3f", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -119,6 +119,7 @@ Boston, MA 02111-1307, USA.  */\n   { \"-exported_symbols_list\", \"-Zexported_symbols_list\" },  \\\n   { \"-seg_addr_table_filename\", \"-Zseg_addr_table_filename\" }, \\\n   { \"-filelist\", \"-Xlinker -filelist -Xlinker\" },  \\\n+  { \"-framework\", \"-Xlinker -framework -Xlinker\" },  \\\n   { \"-flat_namespace\", \"-Zflat_namespace\" },  \\\n   { \"-force_cpusubtype_ALL\", \"-Zforce_cpusubtype_ALL\" },  \\\n   { \"-force_flat_namespace\", \"-Zforce_flat_namespace\" },  \\\n@@ -175,10 +176,13 @@ Boston, MA 02111-1307, USA.  */\n    !strcmp (STR, \"dylinker_install_name\") ? 1 : \\\n    0)\n \n-/* Machine dependent cpp options.  */\n+/* Machine dependent cpp options.  __APPLE_CC__ is defined as the\n+   Apple include files expect it to be defined and won't work if it\n+   isn't.  */\n \n #undef\tCPP_SPEC\n-#define CPP_SPEC \"%{static:%{!dynamic:-D__STATIC__}}%{!static:-D__DYNAMIC__}\"\n+#define CPP_SPEC \"%{static:%{!dynamic:-D__STATIC__}}%{!static:-D__DYNAMIC__}\\\n+    -D__APPLE_CC__=1\"\n \n /* This is mostly a clone of the standard LINK_COMMAND_SPEC, plus\n    precomp, libtool, and fat build additions.  Also we\n@@ -834,6 +838,12 @@ enum machopic_addr_class {\n #undef ASM_APP_OFF\n #define ASM_APP_OFF \"\"\n \n+void darwin_register_frameworks (int);\n+#define TARGET_EXTRA_INCLUDES darwin_register_frameworks\n+\n+void add_framework_path (char *);\n+#define TARGET_OPTF add_framework_path\n+\n #define TARGET_HAS_F_SETLKW\n \n #endif /* CONFIG_DARWIN_H */"}, {"sha": "f5af52eb2e4b6615ec9226a5e5ab783dc0dd9188", "filename": "gcc/config/t-darwin", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fconfig%2Ft-darwin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fconfig%2Ft-darwin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ft-darwin?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -5,7 +5,8 @@ darwin.o: $(srcdir)/config/darwin.c $(CONFIG_H) $(SYSTEM_H) coretypes.h     \\\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/darwin.c\n \n darwin-c.o: $(srcdir)/config/darwin-c.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-  $(TM_H) $(CPPLIB_H) tree.h c-pragma.h $(C_TREE_H) toplev.h $(TM_P_H)\n+  $(TM_H) $(CPPLIB_H) tree.h c-pragma.h $(C_TREE_H) toplev.h $(TM_P_H) \\\n+  c-incpath.h\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/darwin-c.c\n \n gt-darwin.h : s-gtype ; @true"}, {"sha": "d31f61b7aee861d4156f3667ca98bf5770f579b4", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 86, "deletions": 11, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -319,23 +319,58 @@ find_file_in_dir (cpp_reader *pfile, _cpp_file *file, bool *invalid_pch)\n   if (CPP_OPTION (pfile, remap) && (path = remap_filename (pfile, file)))\n     ;\n   else\n-    path = append_file_to_dir (file->name, file->dir);\n+    if (file->dir->construct)\n+      path = file->dir->construct (file->name, file->dir);\n+    else\n+      path = append_file_to_dir (file->name, file->dir);\n \n-  file->path = path;\n-  if (pch_open_file (pfile, file, invalid_pch))\n-    return true;\n+  if (path)\n+    {\n+      file->path = path;\n+      if (pch_open_file (pfile, file, invalid_pch))\n+\treturn true;\n \n-  if (open_file (file))\n-    return true;\n+      if (open_file (file))\n+\treturn true;\n+\n+      if (file->err_no != ENOENT)\n+\t{\n+\t  open_file_failed (pfile, file);\n+\t  return true;\n+\t}\n+\n+      free (path);\n+      file->path = file->name;\n+    }\n+  else\n+    {\n+      file->err_no = ENOENT; \n+      file->path = NULL;\n+    }\n+\n+  return false;\n+}\n \n-  if (file->err_no != ENOENT)\n+/* Return tue iff the missing_header callback found the given HEADER.  */\n+static bool\n+search_path_exhausted (cpp_reader *pfile, const char *header, _cpp_file *file)\n+{\n+  missing_header_cb func = pfile->cb.missing_header;\n+\n+  /* When the regular search path doesn't work, try context dependent\n+     headers search paths.  */\n+  if (func\n+      && file->dir == NULL)\n     {\n-      open_file_failed (pfile, file);\n-      return true;\n+      if ((file->path = func (pfile, header)) != NULL)\n+\t{\n+\t  if (open_file (file))\n+\t    return true;\n+\t  free ((void *)file->path);\n+\t}\n+      file->path = file->name;\n     }\n \n-  free (path);\n-  file->path = file->name;\n   return false;\n }\n \n@@ -391,6 +426,9 @@ _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir, bool f\n       file->dir = file->dir->next;\n       if (file->dir == NULL)\n \t{\n+\t  if (search_path_exhausted (pfile, fname, file))\n+\t    return file;\n+\n \t  open_file_failed (pfile, file);\n \t  if (invalid_pch)\n \t    {\n@@ -839,6 +877,7 @@ make_cpp_dir (cpp_reader *pfile, const char *dir_name, int sysp)\n   dir->name = (char *) dir_name;\n   dir->len = strlen (dir_name);\n   dir->sysp = sysp;\n+  dir->construct = 0;\n \n   /* Store this new result in the hash table.  */\n   entry = new_file_hash_entry (pfile);\n@@ -1265,6 +1304,42 @@ validate_pch (cpp_reader *pfile, _cpp_file *file, const char *pchname)\n   file->path = saved_path;\n   return valid;\n }\n+\n+/* Get the path associated with the _cpp_file F.  The path includes\n+   the base name from the include directive and the directory it was\n+   found in via the search path.  */\n+\n+const char *\n+cpp_get_path (struct _cpp_file *f)\n+{\n+  return f->path;\n+}\n+\n+/* Get the cpp_buffer currently associated with the cpp_reader\n+   PFILE.  */\n+\n+cpp_buffer *\n+cpp_get_buffer (cpp_reader *pfile)\n+{\n+  return pfile->buffer;\n+}\n+\n+/* Get the _cpp_file associated with the cpp_buffer B.  */\n+\n+_cpp_file *\n+cpp_get_file (cpp_buffer *b)\n+{\n+  return b->file;\n+}\n+\n+/* Get the previous cpp_buffer given a cpp_buffer B.  The previous\n+   buffer is the buffer that included the given buffer.  */\n+\n+cpp_buffer *\n+cpp_get_prev (cpp_buffer *b)\n+{\n+  return b->prev;\n+}\n \f\n /* This datastructure holds the list of header files that were seen\n    while the PCH was being built.  The 'entries' field is kept sorted"}, {"sha": "c53375d413885298becfc410bdf1bc564c7c604b", "filename": "gcc/cpplib.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -42,6 +42,7 @@ typedef struct cpp_callbacks cpp_callbacks;\n typedef struct cpp_dir cpp_dir;\n \n struct answer;\n+struct _cpp_file;\n \n /* The first three groups, apart from '=', can appear in preprocessor\n    expressions (+= and -= are used to indicate unary + and - resp.).\n@@ -378,6 +379,14 @@ struct cpp_options\n   unsigned char stdc_0_in_system_headers;\n };\n \n+/* Callback for header lookup for HEADER, which is the name of a\n+   source file.  It is used as a method of last resort to find headers\n+   that are not otherwise found during the normal include processing.\n+   The return value is the malloced name of a header to try and open,\n+   if any, or NULL otherwise.  This callback is called only if the\n+   header is otherwise unfound.  */\n+typedef const char *(*missing_header_cb)(cpp_reader *, const char *header);\n+\n /* Call backs to cpplib client.  */\n struct cpp_callbacks\n {\n@@ -399,6 +408,7 @@ struct cpp_callbacks\n   void (*def_pragma) (cpp_reader *, unsigned int);\n   int (*valid_pch) (cpp_reader *, const char *, int);\n   void (*read_pch) (cpp_reader *, const char *, int, const char *);\n+  missing_header_cb missing_header;\n };\n \n /* Chain of directories to look for include files in.  */\n@@ -419,6 +429,12 @@ struct cpp_dir\n      platforms.  A NULL-terminated array of (from, to) pairs.  */\n   const char **name_map;\n \n+  /* Routine to construct pathname, given the search path name and the\n+     HEADER we are trying to find, return a constructed pathname to\n+     try and open.  If this is NULL, the constructed pathname is as\n+     constructed by append_file_to_dir.  */\n+  char *(*construct) (const char *header, cpp_dir *dir);\n+\n   /* The C front end uses these to recognize duplicated\n      directories in the search path.  */\n   ino_t ino;\n@@ -727,6 +743,10 @@ extern bool cpp_included (cpp_reader *, const char *);\n extern void cpp_make_system_header (cpp_reader *, int, int);\n extern bool cpp_push_include (cpp_reader *, const char *);\n extern void cpp_change_file (cpp_reader *, enum lc_reason, const char *);\n+extern const char *cpp_get_path (struct _cpp_file *);\n+extern cpp_buffer *cpp_get_buffer (cpp_reader *);\n+extern struct _cpp_file *cpp_get_file (cpp_buffer *);\n+extern cpp_buffer *cpp_get_prev (cpp_buffer *);\n \n /* In cpppch.c */\n struct save_macro_data;"}, {"sha": "da42b61315a2069880667ffe712864ec13d23e0d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -461,7 +461,7 @@ in the following sections.\n -single_module  -static  -sub_library  -sub_umbrella @gol\n -twolevel_namespace  -umbrella  -undefined @gol\n -unexported_symbols_list  -weak_reference_mismatches @gol\n--whatsloaded}\n+-whatsloaded -F}\n \n @emph{MIPS Options}\n @gccoptlist{-EL  -EB  -march=@var{arch}  -mtune=@var{arch} @gol\n@@ -7562,6 +7562,34 @@ These options are defined for all architectures running the Darwin operating\n system.  They are useful for compatibility with other Mac OS compilers.\n \n @table @gcctabopt\n+@item -F@var{dir}\n+@opindex F\n+Add the framework directory @var{dir} to the head of the list of\n+directories to be searched for header files.  These directories are\n+interleaved with those specified by @option{-I} options and are\n+scanned in a left-to-right order.\n+\n+A framework directory is a directory with frameworks in it.  A\n+framework is a directory with a @samp{\"Headers\"} and/or\n+@samp{\"PrivateHeaders\"} directory contained directly in it that ends\n+in @samp{\".framework\"}.  The name of a framework is the name of this\n+directory excluding the @samp{\".framework\"}.  Headers associated with\n+the framework are found in one of those two directories, with\n+@samp{\"Headers\"} being searched first.  A subframework is a framework\n+directory that is in a framework's @samp{\"Frameworks\"} directory.\n+Includes of subframework headers can only appear in a header of a\n+framework that contains the subframework, or in a sibling subframework\n+header.  Two subframeworks are siblings if they occur in the same\n+framework.  A subframework should not have the same name as a\n+framework, a warning will be issued if this is violated.  Currently a\n+subframework cannot have subframeworks, in the future, the mechanism\n+may be extended to support this.  The standard frameworks can be found\n+in @samp{\"/System/Library/Frameworks\"}, @samp{\"/Library/Frameworks\"}\n+and @samp{\"/Local/Library/Frameworks\"}.  An example include looks like\n+@code{#include <Framework/header.h>}, where @samp{Framework} denotes\n+the name of the framework and header.h is found in the\n+@samp{\"PrivateHeaders\"} or @samp{\"Headers\"} directory.\n+\n @item -all_load\n @opindex all_load\n Loads all members of static archive libraries."}, {"sha": "3ca5acae3ff0d77fdd0b92856a9c2dce6a3fe0c9", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -9109,3 +9109,16 @@ more than this number of multiplications is implemented by calling the\n system library's @code{pow}, @code{powf} or @code{powl} routines.\n The default value places no upper bound on the multiplication count.\n @end defmac\n+\n+@deftypefn Macro void TARGET_EXTRA_INCLUDES (int @var{stdinc})\n+This target hook should register any extra include files for the\n+target.  The parameter @var{stdinc} indicates if normal include files\n+are present.\n+@end deftypefn\n+\n+@deftypefn Macro void TARGET_OPTF (char *@var{path})\n+This target hook should register special include paths for the target.\n+The parameter @var{path} is the include to register.  On Darwin\n+systems, this is used for Framework includes, which have semantics\n+that are different from @option{-I}.\n+@end deftypefn"}, {"sha": "7b7aee3c3371ac198024726bd06d3cd5978d0076", "filename": "gcc/fix-header.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -84,6 +84,12 @@ static void v_fatal (const char *, va_list)\n      ATTRIBUTE_PRINTF (1,0) ATTRIBUTE_NORETURN;\n static void fatal (const char *, ...) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n \n+#ifdef TARGET_EXTRA_INCLUDES\n+static void hook_void_int(int u ATTRIBUTE_UNUSED) { }\n+\n+struct target_c_incpath_s target_c_incpath = { hook_void_int };\n+#endif\n+\n struct line_maps line_table;\n \n sstring buf;"}, {"sha": "9538c620a73b9b6f585c179571eac72e44b199c0", "filename": "gcc/gcc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -743,7 +743,7 @@ static const char *trad_capable_cpp =\n    file that happens to exist is up-to-date.  */\n static const char *cpp_unique_options =\n \"%{C|CC:%{!E:%eGCC does not support -C or -CC without -E}}\\\n- %{!Q:-quiet} %{nostdinc*} %{C} %{CC} %{v} %{I*} %{P} %I\\\n+ %{!Q:-quiet} %{nostdinc*} %{C} %{CC} %{v} %{I*&F*} %{P} %I\\\n  %{MD:-MD %{!o:%b.d}%{o*:%.d%*}}\\\n  %{MMD:-MMD %{!o:%b.d}%{o*:%.d%*}}\\\n  %{M} %{MM} %{MF*} %{MG} %{MP} %{MQ*} %{MT*}\\"}, {"sha": "cb6efd4bb6a0655223eef76a7e5390fdb8c464c1", "filename": "gcc/hooks.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -124,11 +124,21 @@ hook_uint_uint_constcharptrptr_0 (unsigned int a ATTRIBUTE_UNUSED,\n   return 0;\n }\n \n+void\n+hook_void_int (int b ATTRIBUTE_UNUSED)\n+{\n+}\n+\n void\n hook_void_tree (tree a ATTRIBUTE_UNUSED)\n {\n }\n \n+void\n+hook_void_charptr (char *a ATTRIBUTE_UNUSED)\n+{\n+}\n+\n void\n hook_void_tree_treeptr (tree a ATTRIBUTE_UNUSED, tree *b ATTRIBUTE_UNUSED)\n {"}, {"sha": "a72f6c8801352ed77c45962cb93138b987581b02", "filename": "gcc/hooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -36,6 +36,8 @@ extern bool hook_bool_rtx_int_int_intp_false (rtx, int, int, int *);\n extern bool hook_bool_constcharptr_size_t_false (const char *, size_t);\n \n extern void hook_void_void (void);\n+extern void hook_void_int (int);\n+extern void hook_void_charptr (char *);\n extern void hook_void_FILEptr_constcharptr (FILE *, const char *);\n extern void hook_void_tree (tree);\n extern void hook_void_tree_treeptr (tree, tree *);"}, {"sha": "861e9ed07cb4ff9b1c627803921d58db262922cc", "filename": "gcc/target-def.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -361,6 +361,10 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    TARGET_PRETEND_OUTGOING_VARARGS_NAMED,\t\t\t\\\n    }\n \n+#ifndef TARGET_OPTF\n+#define TARGET_OPTF hook_void_charptr\n+#endif\n+\n /* The whole shebang.  */\n #define TARGET_INITIALIZER\t\t\t\\\n {\t\t\t\t\t\t\\"}, {"sha": "7e68683299440255dbbad31d1f9d1cf8e3713982", "filename": "gcc/testsuite/gcc.dg/framework-1.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Ftestsuite%2Fgcc.dg%2Fframework-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d1613b239ef411e8fd6e6e647d920149d1d272/gcc%2Ftestsuite%2Fgcc.dg%2Fframework-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fframework-1.c?ref=94d1613b239ef411e8fd6e6e647d920149d1d272", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do compile { target *-*-darwin* } } */\n+/* { dg-options \"-F.\" } */\n+\n+#include <Carbon/Carbon.h>"}]}