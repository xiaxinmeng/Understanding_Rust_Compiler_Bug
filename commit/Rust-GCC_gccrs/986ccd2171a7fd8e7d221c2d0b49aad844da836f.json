{"sha": "986ccd2171a7fd8e7d221c2d0b49aad844da836f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg2Y2NkMjE3MWE3ZmQ4ZTdkMjIxYzJkMGI0OWFhZDg0NGRhODM2Zg==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2015-12-17T14:09:36Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2015-12-17T14:09:36Z"}, "message": "DWARF: handle variable-length records and variant parts\n\nEnhance the DWARF back-end to emit proper descriptions for\nvariable-length records as well as variant parts in records.\n\nIn order to achieve this, generate DWARF expressions (\"location\ndescriptions\" in dwarf2out's parlance) for size and data member location\nattributes.  Also match QUAL_UNION_TYPE data types as variant parts,\nassuming the formers appear only to implement the latters (which is the\ncase at the moment: only the Ada front-end emits them).\n\nNote that very few debuggers can handle these descriptions (GDB does not\nyet), so in order to ease the the transition enable these only when\n-fgnat-encodings=minimal.\n\ngcc/ada/ChangeLog:\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Disable ___XVS GNAT\n\tencodings when -fgnat-encodings=minimal.\n\t(components_to_record): Disable ___XVE, ___XVN, ___XVU and\n\t___XVZ GNAT encodings when -fgnat-encodings=minimal.\n\t* gcc-interface/utils.c (maybe_pad_type): Disable __XVS GNAT\n\tencodings when -fgnat-encodings=minimal.\n\ngcc/ChangeLog:\n\n\t* debug.h (struct gcc_debug_hooks): Add a new size_function\n\thook.\n\t* debug.c (do_nothing_debug_hooks): Set the size_function field\n\tto no-op.\n\t* dbxout.c (dbx_debug_hooks, xcoff_debug_hooks): Likewise.\n\t* sdbout.c (sdb_debug_hooks): Likewise.\n\t* vmsdbgout.c (vmsdbg_debug_hooks): Likewise.\n\t* stor-layout.c (finalize_size_functions): Let the debug info\n\tback-end know about the implementation of size functions.\n\t* dwarf2out.h (dw_discr_list_ref): New typedef.\n\t(enum dw_val_class): Add value classes for discriminant values\n\tand discriminant lists.\n\t(struct dw_discr_value): New structure.\n\t(struct dw_val_node): Add discriminant values and discriminant\n\tlists to the union.\n\t(struct dw_loc_descr_node): Add frame_offset_rel and\n\tdw_loc_frame_offset (only for checking) fields to handle DWARF\n\tprocedures generation.\n\t(struct dw_discr_list_node): New structure.\n\t* dwarf2out.c (dwarf2out_size_function): New.\n\t(dwarf2_debug_hooks): Set the size_function field to\n\tdwarf2out_size_function.\n\t(dwarf2_lineno_debug_hooks): Set the size_function field to\n\tno-op.\n\t(new_loc_descr): Initialize the\n\tdw_loc_frame_offset field.\n\t(dwarf_proc_stack_usage_map): New.\n\t(dw_val_equal_p): Handle discriminants.\n\t(size_of_discr_value): New.\n\t(size_of_discr_list): New.\n\t(size_of_die): Handle discriminants.\n\t(add_loc_descr_to_each): New.\n\t(add_loc_list): New.\n\t(print_discr_value): New.\n\t(print_dw_val): Handle discriminants.\n\t(value_format): Handle discriminants.\n\t(output_discr_value): New.\n\t(output_die): Handle discriminants.\n\t(output_loc_operands): Handle DW_OP_call2 and DW_OP_call4.\n\t(uint_loc_descriptor): New.\n\t(uint_comparison_loc_list): New.\n\t(loc_list_from_uint_comparison): New.\n\t(add_discr_value): New.\n\t(add_discr_list): New.\n\t(AT_discr_list): New.\n\t(loc_descr_to_next_no_op): New.\n\t(free_loc_descr): New.\n\t(loc_descr_without_nops): New.\n\t(struct loc_descr_context): Add a dpi field.\n\t(struct dwarf_procedure_info): New helper structure.\n\t(new_dwarf_proc_die): New.\n\t(is_handled_procedure_type): New.\n\t(resolve_args_picking_1): New.\n\t(resolve_args_picking): New.\n\t(function_to_dwarf_procedure): New.\n\t(copy_dwarf_procedure): New.\n\t(copy_dwarf_procs_ref_in_attrs): New.\n\t(copy_dwarf_procs_ref_in_dies): New.\n\t(break_out_comdat_types): Copy DWARF procedures along with the\n\ttypes that reference them.\n\t(loc_list_from_tree): Rename into loc_list_from_tree_1.  Handle\n\tCALL_EXPR in the cases suitable for DWARF procedures.  Handle\n\tfor PARM_DECL when generating a location description for a DWARF\n\tprocedure.  Handle big unsigned INTEGER_CST nodes.  Handle\n\tNON_LVALUE_EXPR, EXACT_DIV_EXPR and all unsigned comparison\n\toperators.  Add a wrapper for loc_list_from_tree that strips\n\tDW_OP_nop operations from the result.\n\t(type_byte_size): New.\n\t(struct vlr_context): New helper structure.\n\t(field_byte_offset): Change signature to return either a\n\tconstant offset or a location description for dynamic ones.\n\tHandle dynamic byte offsets with constant bit offsets and handle\n\tfields in variant parts.\n\t(add_data_member_location): Change signature to handle dynamic\n\tmember offsets and fields in variant parts.  Update call to\n\tfield_byte_offset.  Handle location lists.  Emit a variable data\n\tmember location only when -fgnat-encodings=minimal.\n\t(add_bound_info): Emit self-referential bounds only when\n\t-fgnat-encodings=minimal.\n\t(add_byte_size_attribute): Use type_byte_size in order to handle\n\tdynamic type sizes.  Emit variable byte size only when\n\t-fgnat-encodings=minimal and when the target DWARF version\n\tallows them.\n\t(add_bit_offset_attribute): Change signature to handle\n\tvariable-length records.  Update call to field_byte_offset.\n\t(gen_descr_array_type_die): Update call to gen_field_die.\n\tUpdate loc_descr_context literal.\n\t(gen_type_die_for_member): Likewise.\n\t(gen_subprogram_die): Update calls to get_decl_die.\n\t(gen_field_die): Change signature to handle variable-length\n\trecords.  Update calls to add_bit_offset_attribute and\n\tadd_data_member_location_attribute.\n\t(gen_inheritance_die): Update call to\n\tadd_data_member_location_attribute.\n\t(gen_decl_die): Change signature to handle variable-length\n\trecords.  Update call to gen_field_die.\n\t(gen_inheritance_die): Change signature to handle\n\tvariable-length records.  Update call to\n\tadd_data_member_location_attribute.\n\t(is_variant_part): New.\n\t(analyze_discr_in_predicate): New.\n\t(get_discr_value): New.\n\t(analyze_variants_discr): New.\n\t(gen_variant_part): New.\n\t(gen_member_die): Update calls to gen_decl_die.  Call instead\n\tgen_variant_part for variant parts.\n\t(gen_type_die_with_usage): Update calls to gen_decl_die.\n\t(process_scope_var): Likewise.\n\t(force_decl_die): Likewise.\n\t(declare_in_namespace): Likewise.\n\t(dwarf2out_decl): Likewise.\n\t(prune_unused_types_walk_loc_descr): New.\n\t(prune_unused_types_walk_attribs): Mark DIEs referenced by\n\tlocation descriptions and loc. descr. lists.\n\t(prune_unused_types_walk): Don't mark DWARF procedures by\n\tdefault.  Mark variant parts since nothing is supposed to\n\treference them.\n\t(dwarf2out_init): Allocate dwarf_proc_stack_usage_map.\n\t(dwarf2out_c_finalize): Deallocate and reset\n\tdwarf_proc_stack_usage_map.\n\ngcc/testsuite/ChangeLog:\n\n\t* gnat.dg/specs/debug1.ads: Update the expected number of\n\tDW_AT_artificial attribute in compiler output.\n\nFrom-SVN: r231762", "tree": {"sha": "6573f30c629ae8d30ba6fe9220f370a4f44bd927", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6573f30c629ae8d30ba6fe9220f370a4f44bd927"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/986ccd2171a7fd8e7d221c2d0b49aad844da836f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/986ccd2171a7fd8e7d221c2d0b49aad844da836f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/986ccd2171a7fd8e7d221c2d0b49aad844da836f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/986ccd2171a7fd8e7d221c2d0b49aad844da836f/comments", "author": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6592d14b43d21382d7876484d3ba90ba650fbc6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6592d14b43d21382d7876484d3ba90ba650fbc6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6592d14b43d21382d7876484d3ba90ba650fbc6e"}], "stats": {"total": 2309, "additions": 2125, "deletions": 184}, "files": [{"sha": "04270508d1c78d3b0501fc0a3707c5033afa6810", "filename": "gcc/ChangeLog", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=986ccd2171a7fd8e7d221c2d0b49aad844da836f", "patch": "@@ -1,3 +1,126 @@\n+2015-12-17  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* debug.h (struct gcc_debug_hooks): Add a new size_function\n+\thook.\n+\t* debug.c (do_nothing_debug_hooks): Set the size_function field\n+\tto no-op.\n+\t* dbxout.c (dbx_debug_hooks, xcoff_debug_hooks): Likewise.\n+\t* sdbout.c (sdb_debug_hooks): Likewise.\n+\t* vmsdbgout.c (vmsdbg_debug_hooks): Likewise.\n+\t* stor-layout.c (finalize_size_functions): Let the debug info\n+\tback-end know about the implementation of size functions.\n+\t* dwarf2out.h (dw_discr_list_ref): New typedef.\n+\t(enum dw_val_class): Add value classes for discriminant values\n+\tand discriminant lists.\n+\t(struct dw_discr_value): New structure.\n+\t(struct dw_val_node): Add discriminant values and discriminant\n+\tlists to the union.\n+\t(struct dw_loc_descr_node): Add frame_offset_rel and\n+\tdw_loc_frame_offset (only for checking) fields to handle DWARF\n+\tprocedures generation.\n+\t(struct dw_discr_list_node): New structure.\n+\t* dwarf2out.c (dwarf2out_size_function): New.\n+\t(dwarf2_debug_hooks): Set the size_function field to\n+\tdwarf2out_size_function.\n+\t(dwarf2_lineno_debug_hooks): Set the size_function field to\n+\tno-op.\n+\t(new_loc_descr): Initialize the\n+\tdw_loc_frame_offset field.\n+\t(dwarf_proc_stack_usage_map): New.\n+\t(dw_val_equal_p): Handle discriminants.\n+\t(size_of_discr_value): New.\n+\t(size_of_discr_list): New.\n+\t(size_of_die): Handle discriminants.\n+\t(add_loc_descr_to_each): New.\n+\t(add_loc_list): New.\n+\t(print_discr_value): New.\n+\t(print_dw_val): Handle discriminants.\n+\t(value_format): Handle discriminants.\n+\t(output_discr_value): New.\n+\t(output_die): Handle discriminants.\n+\t(output_loc_operands): Handle DW_OP_call2 and DW_OP_call4.\n+\t(uint_loc_descriptor): New.\n+\t(uint_comparison_loc_list): New.\n+\t(loc_list_from_uint_comparison): New.\n+\t(add_discr_value): New.\n+\t(add_discr_list): New.\n+\t(AT_discr_list): New.\n+\t(loc_descr_to_next_no_op): New.\n+\t(free_loc_descr): New.\n+\t(loc_descr_without_nops): New.\n+\t(struct loc_descr_context): Add a dpi field.\n+\t(struct dwarf_procedure_info): New helper structure.\n+\t(new_dwarf_proc_die): New.\n+\t(is_handled_procedure_type): New.\n+\t(resolve_args_picking_1): New.\n+\t(resolve_args_picking): New.\n+\t(function_to_dwarf_procedure): New.\n+\t(copy_dwarf_procedure): New.\n+\t(copy_dwarf_procs_ref_in_attrs): New.\n+\t(copy_dwarf_procs_ref_in_dies): New.\n+\t(break_out_comdat_types): Copy DWARF procedures along with the\n+\ttypes that reference them.\n+\t(loc_list_from_tree): Rename into loc_list_from_tree_1.  Handle\n+\tCALL_EXPR in the cases suitable for DWARF procedures.  Handle\n+\tfor PARM_DECL when generating a location description for a DWARF\n+\tprocedure.  Handle big unsigned INTEGER_CST nodes.  Handle\n+\tNON_LVALUE_EXPR, EXACT_DIV_EXPR and all unsigned comparison\n+\toperators.  Add a wrapper for loc_list_from_tree that strips\n+\tDW_OP_nop operations from the result.\n+\t(type_byte_size): New.\n+\t(struct vlr_context): New helper structure.\n+\t(field_byte_offset): Change signature to return either a\n+\tconstant offset or a location description for dynamic ones.\n+\tHandle dynamic byte offsets with constant bit offsets and handle\n+\tfields in variant parts.\n+\t(add_data_member_location): Change signature to handle dynamic\n+\tmember offsets and fields in variant parts.  Update call to\n+\tfield_byte_offset.  Handle location lists.  Emit a variable data\n+\tmember location only when -fgnat-encodings=minimal.\n+\t(add_bound_info): Emit self-referential bounds only when\n+\t-fgnat-encodings=minimal.\n+\t(add_byte_size_attribute): Use type_byte_size in order to handle\n+\tdynamic type sizes.  Emit variable byte size only when\n+\t-fgnat-encodings=minimal and when the target DWARF version\n+\tallows them.\n+\t(add_bit_offset_attribute): Change signature to handle\n+\tvariable-length records.  Update call to field_byte_offset.\n+\t(gen_descr_array_type_die): Update call to gen_field_die.\n+\tUpdate loc_descr_context literal.\n+\t(gen_type_die_for_member): Likewise.\n+\t(gen_subprogram_die): Update calls to get_decl_die.\n+\t(gen_field_die): Change signature to handle variable-length\n+\trecords.  Update calls to add_bit_offset_attribute and\n+\tadd_data_member_location_attribute.\n+\t(gen_inheritance_die): Update call to\n+\tadd_data_member_location_attribute.\n+\t(gen_decl_die): Change signature to handle variable-length\n+\trecords.  Update call to gen_field_die.\n+\t(gen_inheritance_die): Change signature to handle\n+\tvariable-length records.  Update call to\n+\tadd_data_member_location_attribute.\n+\t(is_variant_part): New.\n+\t(analyze_discr_in_predicate): New.\n+\t(get_discr_value): New.\n+\t(analyze_variants_discr): New.\n+\t(gen_variant_part): New.\n+\t(gen_member_die): Update calls to gen_decl_die.  Call instead\n+\tgen_variant_part for variant parts.\n+\t(gen_type_die_with_usage): Update calls to gen_decl_die.\n+\t(process_scope_var): Likewise.\n+\t(force_decl_die): Likewise.\n+\t(declare_in_namespace): Likewise.\n+\t(dwarf2out_decl): Likewise.\n+\t(prune_unused_types_walk_loc_descr): New.\n+\t(prune_unused_types_walk_attribs): Mark DIEs referenced by\n+\tlocation descriptions and loc. descr. lists.\n+\t(prune_unused_types_walk): Don't mark DWARF procedures by\n+\tdefault.  Mark variant parts since nothing is supposed to\n+\treference them.\n+\t(dwarf2out_init): Allocate dwarf_proc_stack_usage_map.\n+\t(dwarf2out_c_finalize): Deallocate and reset\n+\tdwarf_proc_stack_usage_map.\n+\n 2015-12-17  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* common.opt (gnat_encodings): New variable"}, {"sha": "21ed1dc9ad7e8a6964605f574326a39fecc4a8c2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=986ccd2171a7fd8e7d221c2d0b49aad844da836f", "patch": "@@ -1,3 +1,12 @@\n+2015-12-17  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Disable ___XVS GNAT\n+\tencodings when -fgnat-encodings=minimal.\n+\t(components_to_record): Disable ___XVE, ___XVN, ___XVU and\n+\t___XVZ GNAT encodings when -fgnat-encodings=minimal.\n+\t* gcc-interface/utils.c (maybe_pad_type): Disable __XVS GNAT\n+\tencodings when -fgnat-encodings=minimal.\n+\n 2015-12-17  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* gcc-interface/misc.c (gnat_encodings): Undefine macro and"}, {"sha": "4db119347482646551a7fabb2fe4fa0a6884930d", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=986ccd2171a7fd8e7d221c2d0b49aad844da836f", "patch": "@@ -3556,10 +3556,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      /* Fill in locations of fields.  */\n \t      annotate_rep (gnat_entity, gnu_type);\n \n-\t      /* If debugging information is being written for the type, write\n-\t\t a record that shows what we are a subtype of and also make a\n-\t\t variable that indicates our size, if still variable.  */\n-\t      if (debug_info_p)\n+\t      /* If debugging information is being written for the type and if\n+\t\t we are asked to output such encodings, write a record that\n+\t\t shows what we are a subtype of and also make a variable that\n+\t\t indicates our size, if still variable.  */\n+\t      if (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n \t\t{\n \t\t  tree gnu_subtype_marker = make_node (RECORD_TYPE);\n \t\t  tree gnu_unpad_base_name\n@@ -7029,6 +7030,8 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t\t      bool debug_info, bool maybe_unused, bool reorder,\n \t\t      tree first_free_pos, tree *p_gnu_rep_list)\n {\n+  const bool needs_xv_encodings\n+    = debug_info && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL;\n   bool all_rep_and_size = all_rep && TYPE_SIZE (gnu_record_type);\n   bool variants_have_rep = all_rep;\n   bool layout_with_rep = false;\n@@ -7211,7 +7214,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t\t\t\t    NULL_TREE, packed, definition,\n \t\t\t\t    !all_rep_and_size, all_rep,\n \t\t\t\t    unchecked_union,\n-\t\t\t\t    true, debug_info, true, reorder,\n+\t\t\t\t    true, needs_xv_encodings, true, reorder,\n \t\t\t\t    this_first_free_pos,\n \t\t\t\t    all_rep || this_first_free_pos\n \t\t\t\t    ? NULL : &gnu_rep_list);\n@@ -7301,7 +7304,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t      if (debug_info)\n \t\trest_of_record_type_compilation (gnu_variant_type);\n \t      create_type_decl (TYPE_NAME (gnu_variant_type), gnu_variant_type,\n-\t\t\t\ttrue, debug_info, gnat_component_list);\n+\t\t\t\ttrue, needs_xv_encodings, gnat_component_list);\n \n \t      gnu_field\n \t\t= create_field_decl (gnu_variant->name, gnu_variant_type,\n@@ -7334,7 +7337,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t    }\n \n \t  finish_record_type (gnu_union_type, nreverse (gnu_variant_list),\n-\t\t\t      all_rep_and_size ? 1 : 0, debug_info);\n+\t\t\t      all_rep_and_size ? 1 : 0, needs_xv_encodings);\n \n \t  /* If GNU_UNION_TYPE is our record type, it means we must have an\n \t     Unchecked_Union with no fields.  Verify that and, if so, just\n@@ -7348,7 +7351,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t    }\n \n \t  create_type_decl (TYPE_NAME (gnu_union_type), gnu_union_type, true,\n-\t\t\t    debug_info, gnat_component_list);\n+\t\t\t    needs_xv_encodings, gnat_component_list);\n \n \t  /* Deal with packedness like in gnat_to_gnu_field.  */\n \t  if (union_field_needs_strict_alignment)"}, {"sha": "830a0b8003e824f6928b5992a33548caa055077a", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=986ccd2171a7fd8e7d221c2d0b49aad844da836f", "patch": "@@ -1348,8 +1348,10 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \n   /* Unless debugging information isn't being written for the input type,\n      write a record that shows what we are a subtype of and also make a\n-     variable that indicates our size, if still variable.  */\n-  if (TREE_CODE (orig_size) != INTEGER_CST\n+     variable that indicates our size, if still variable.  Don't do this if\n+     asked to output as few encodings as possible.  */\n+  if (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL\n+      && TREE_CODE (orig_size) != INTEGER_CST\n       && TYPE_NAME (record)\n       && TYPE_NAME (type)\n       && !(TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n@@ -1890,7 +1892,7 @@ rest_of_record_type_compilation (tree record_type)\n \n   /* If this record type is of variable size, make a parallel record type that\n      will tell the debugger how the former is laid out (see exp_dbug.ads).  */\n-  if (var_size)\n+  if (var_size && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n     {\n       tree new_record_type\n \t= make_node (TREE_CODE (record_type) == QUAL_UNION_TYPE"}, {"sha": "a442a1cbb10bcac76bb981cb5eda9f3ada87e401", "filename": "gcc/dbxout.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=986ccd2171a7fd8e7d221c2d0b49aad844da836f", "patch": "@@ -375,6 +375,7 @@ const struct gcc_debug_hooks dbx_debug_hooks =\n   debug_nothing_rtx_code_label,\t         /* label */\n   dbxout_handle_pch,\t\t         /* handle_pch */\n   debug_nothing_rtx_insn,\t         /* var_location */\n+  debug_nothing_tree,\t\t\t /* size_function */\n   debug_nothing_void,                    /* switch_text_section */\n   debug_nothing_tree_tree,\t\t /* set_name */\n   0,                                     /* start_end_main_source_file */\n@@ -414,6 +415,7 @@ const struct gcc_debug_hooks xcoff_debug_hooks =\n   debug_nothing_rtx_code_label,\t         /* label */\n   dbxout_handle_pch,\t\t         /* handle_pch */\n   debug_nothing_rtx_insn,\t         /* var_location */\n+  debug_nothing_tree,\t\t\t /* size_function */\n   debug_nothing_void,                    /* switch_text_section */\n   debug_nothing_tree_tree,\t         /* set_name */\n   0,                                     /* start_end_main_source_file */"}, {"sha": "048810414c5462b9ec4bbb2d6fef46ddf9f53dbd", "filename": "gcc/debug.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fdebug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fdebug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.c?ref=986ccd2171a7fd8e7d221c2d0b49aad844da836f", "patch": "@@ -53,6 +53,7 @@ const struct gcc_debug_hooks do_nothing_debug_hooks =\n   debug_nothing_rtx_code_label,\t         /* label */\n   debug_nothing_int,\t\t         /* handle_pch */\n   debug_nothing_rtx_insn,\t         /* var_location */\n+  debug_nothing_tree,\t\t\t /* size_function */\n   debug_nothing_void,                    /* switch_text_section */\n   debug_nothing_tree_tree,\t\t /* set_name */\n   0,                                     /* start_end_main_source_file */"}, {"sha": "14c08c8e67d8f74f11bf002342a8884605dfe4f7", "filename": "gcc/debug.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.h?ref=986ccd2171a7fd8e7d221c2d0b49aad844da836f", "patch": "@@ -166,6 +166,11 @@ struct gcc_debug_hooks\n   /* Called from final_scan_insn for any NOTE_INSN_VAR_LOCATION note.  */\n   void (* var_location) (rtx_insn *);\n \n+  /* Called from finalize_size_functions for size functions so that their body\n+     can be encoded in the debug info to describe the layout of variable-length\n+     structures.  */\n+  void (* size_function) (tree decl);\n+\n   /* Called from final_scan_insn if there is a switch between hot and cold\n      text sections.  */\n   void (* switch_text_section) (void);"}, {"sha": "f731e92d1c2aedf3dc061fd4f1b0e39438fd11e6", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1907, "deletions": 171, "changes": 2078, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=986ccd2171a7fd8e7d221c2d0b49aad844da836f", "patch": "@@ -1299,6 +1299,7 @@ typedef struct GTY(()) dw_loc_list_struct {\n } dw_loc_list_node;\n \n static dw_loc_descr_ref int_loc_descriptor (HOST_WIDE_INT);\n+static dw_loc_descr_ref uint_loc_descriptor (unsigned HOST_WIDE_INT);\n \n /* Convert a DWARF stack opcode into its string name.  */\n \n@@ -1324,6 +1325,9 @@ new_loc_descr (enum dwarf_location_atom op, unsigned HOST_WIDE_INT oprnd1,\n   dw_loc_descr_ref descr = ggc_cleared_alloc<dw_loc_descr_node> ();\n \n   descr->dw_loc_opc = op;\n+#if ENABLE_CHECKING\n+  descr->dw_loc_frame_offset = -1;\n+#endif\n   descr->dw_loc_oprnd1.val_class = dw_val_class_unsigned_const;\n   descr->dw_loc_oprnd1.val_entry = NULL;\n   descr->dw_loc_oprnd1.v.val_unsigned = oprnd1;\n@@ -1426,6 +1430,13 @@ dw_val_equal_p (dw_val_node *a, dw_val_node *b)\n     case dw_val_class_vms_delta:\n       return (!strcmp (a->v.val_vms_delta.lbl1, b->v.val_vms_delta.lbl1)\n               && !strcmp (a->v.val_vms_delta.lbl1, b->v.val_vms_delta.lbl1));\n+\n+    case dw_val_class_discr_value:\n+      return (a->v.val_discr_value.pos == b->v.val_discr_value.pos\n+\t      && a->v.val_discr_value.v.uval == b->v.val_discr_value.v.uval);\n+    case dw_val_class_discr_list:\n+      /* It makes no sense comparing two discriminant value lists.  */\n+      return false;\n     }\n   gcc_unreachable ();\n }\n@@ -1740,6 +1751,39 @@ size_of_locs (dw_loc_descr_ref loc)\n   return size;\n }\n \n+/* Return the size of the value in a DW_AT_discr_value attribute.  */\n+\n+static int\n+size_of_discr_value (dw_discr_value *discr_value)\n+{\n+  if (discr_value->pos)\n+    return size_of_uleb128 (discr_value->v.uval);\n+  else\n+    return size_of_sleb128 (discr_value->v.sval);\n+}\n+\n+/* Return the size of the value in a DW_discr_list attribute.  */\n+\n+static int\n+size_of_discr_list (dw_discr_list_ref discr_list)\n+{\n+  int size = 0;\n+\n+  for (dw_discr_list_ref list = discr_list;\n+       list != NULL;\n+       list = list->dw_discr_next)\n+    {\n+      /* One byte for the discriminant value descriptor, and then one or two\n+\t LEB128 numbers, depending on whether it's a single case label or a\n+\t range label.  */\n+      size += 1;\n+      size += size_of_discr_value (&list->dw_discr_lower_bound);\n+      if (list->dw_discr_range != 0)\n+\tsize += size_of_discr_value (&list->dw_discr_upper_bound);\n+    }\n+  return size;\n+}\n+\n static HOST_WIDE_INT extract_int (const unsigned char *, unsigned);\n static void get_ref_die_offset_label (char *, dw_die_ref);\n static unsigned long int get_ref_die_offset (dw_die_ref);\n@@ -2002,6 +2046,22 @@ output_loc_operands (dw_loc_descr_ref loc, int for_eh_or_skip)\n                                    \"(index into .debug_addr)\");\n       break;\n \n+    case DW_OP_call2:\n+    case DW_OP_call4:\n+      {\n+\tunsigned long die_offset\n+\t  = get_ref_die_offset (val1->v.val_die_ref.die);\n+\t/* Make sure the offset has been computed and that we can encode it as\n+\t   an operand.  */\n+\tgcc_assert (die_offset > 0\n+\t\t    && die_offset <= (loc->dw_loc_opc == DW_OP_call2)\n+\t\t\t\t     ? 0xffff\n+\t\t\t\t     : 0xffffffff);\n+\tdw2_asm_output_data ((loc->dw_loc_opc == DW_OP_call2) ? 2 : 4,\n+\t\t\t     die_offset, NULL);\n+      }\n+      break;\n+\n     case DW_OP_GNU_implicit_pointer:\n       {\n \tchar label[MAX_ARTIFICIAL_LABEL_BYTES\n@@ -2441,6 +2501,7 @@ static void dwarf2out_imported_module_or_decl_1 (tree, tree, tree,\n \t\t\t\t\t\t dw_die_ref);\n static void dwarf2out_abstract_function (tree);\n static void dwarf2out_var_location (rtx_insn *);\n+static void dwarf2out_size_function (tree);\n static void dwarf2out_begin_function (tree);\n static void dwarf2out_end_function (unsigned int);\n static void dwarf2out_register_main_translation_unit (tree unit);\n@@ -2487,6 +2548,7 @@ const struct gcc_debug_hooks dwarf2_debug_hooks =\n   debug_nothing_rtx_code_label,\t/* label */\n   debug_nothing_int,\t\t/* handle_pch */\n   dwarf2out_var_location,\n+  dwarf2out_size_function,\t/* size_function */\n   dwarf2out_switch_text_section,\n   dwarf2out_set_name,\n   1,                            /* start_end_main_source_file */\n@@ -2524,6 +2586,7 @@ const struct gcc_debug_hooks dwarf2_lineno_debug_hooks =\n   debug_nothing_rtx_code_label,\t         /* label */\n   debug_nothing_int,\t\t         /* handle_pch */\n   debug_nothing_rtx_insn,\t         /* var_location */\n+  debug_nothing_tree,\t\t\t /* size_function */\n   debug_nothing_void,                    /* switch_text_section */\n   debug_nothing_tree_tree,\t\t /* set_name */\n   0,                                     /* start_end_main_source_file */\n@@ -2962,6 +3025,12 @@ static GTY(()) unsigned abbrev_die_table_allocated;\n /* Number of elements in abbrev_die_table currently in use.  */\n static GTY(()) unsigned abbrev_die_table_in_use;\n \n+/* A hash map to remember the stack usage for DWARF procedures.  The value\n+   stored is the stack size difference between before the DWARF procedure\n+   invokation and after it returned.  In other words, for a DWARF procedure\n+   that consumes N stack slots and that pushes M ones, this stores M - N.  */\n+static hash_map<dw_die_ref, int> *dwarf_proc_stack_usage_map;\n+\n /* Size (in elements) of increments by which we may expand the\n    abbrev_die_table.  */\n #define ABBREV_DIE_TABLE_INCREMENT 256\n@@ -3241,6 +3310,8 @@ static dw_loc_descr_ref concat_loc_descriptor (rtx, rtx,\n static dw_loc_descr_ref loc_descriptor (rtx, machine_mode mode,\n \t\t\t\t\tenum var_init_status);\n struct loc_descr_context;\n+static void add_loc_descr_to_each (dw_loc_list_ref list, dw_loc_descr_ref ref);\n+static void add_loc_list (dw_loc_list_ref *ret, dw_loc_list_ref list);\n static dw_loc_list_ref loc_list_from_tree (tree, int,\n \t\t\t\t\t   const struct loc_descr_context *);\n static dw_loc_descr_ref loc_descriptor_from_tree (tree, int,\n@@ -3250,10 +3321,13 @@ static tree field_type (const_tree);\n static unsigned int simple_type_align_in_bits (const_tree);\n static unsigned int simple_decl_align_in_bits (const_tree);\n static unsigned HOST_WIDE_INT simple_type_size_in_bits (const_tree);\n-static HOST_WIDE_INT field_byte_offset (const_tree);\n+struct vlr_context;\n+static dw_loc_descr_ref field_byte_offset (const_tree, struct vlr_context *,\n+\t\t\t\t\t   HOST_WIDE_INT *);\n static void add_AT_location_description\t(dw_die_ref, enum dwarf_attribute,\n \t\t\t\t\t dw_loc_list_ref);\n-static void add_data_member_location_attribute (dw_die_ref, tree);\n+static void add_data_member_location_attribute (dw_die_ref, tree,\n+\t\t\t\t\t\tstruct vlr_context *);\n static bool add_const_value_attribute (dw_die_ref, rtx);\n static void insert_int (HOST_WIDE_INT, unsigned, unsigned char *);\n static void insert_wide_int (const wide_int &, unsigned char *, int);\n@@ -3271,13 +3345,17 @@ static void add_bound_info (dw_die_ref, enum dwarf_attribute, tree,\n \t\t\t    const struct loc_descr_context *);\n static void add_subscript_info (dw_die_ref, tree, bool);\n static void add_byte_size_attribute (dw_die_ref, tree);\n-static void add_bit_offset_attribute (dw_die_ref, tree);\n+static inline void add_bit_offset_attribute (dw_die_ref, tree,\n+\t\t\t\t\t     struct vlr_context *);\n static void add_bit_size_attribute (dw_die_ref, tree);\n static void add_prototyped_attribute (dw_die_ref, tree);\n static dw_die_ref add_abstract_origin_attribute (dw_die_ref, tree);\n static void add_pure_or_virtual_attribute (dw_die_ref, tree);\n static void add_src_coords_attributes (dw_die_ref, tree);\n static void add_name_and_src_coords_attributes (dw_die_ref, tree);\n+static void add_discr_value (dw_die_ref, dw_discr_value *);\n+static void add_discr_list (dw_die_ref, dw_discr_list_ref);\n+static inline dw_discr_list_ref AT_discr_list (dw_attr_node *);\n static void push_decl_scope (tree);\n static void pop_decl_scope (void);\n static dw_die_ref scope_die_for (tree, dw_die_ref);\n@@ -3307,10 +3385,10 @@ static void gen_const_die (tree, dw_die_ref);\n static void gen_label_die (tree, dw_die_ref);\n static void gen_lexical_block_die (tree, dw_die_ref);\n static void gen_inlined_subroutine_die (tree, dw_die_ref);\n-static void gen_field_die (tree, dw_die_ref);\n+static void gen_field_die (tree, struct vlr_context *, dw_die_ref);\n static void gen_ptr_to_mbr_type_die (tree, dw_die_ref);\n static dw_die_ref gen_compile_unit_die (const char *);\n-static void gen_inheritance_die (tree, tree, dw_die_ref);\n+static void gen_inheritance_die (tree, tree, tree, dw_die_ref);\n static void gen_member_die (tree, dw_die_ref);\n static void gen_struct_or_union_type_die (tree, dw_die_ref,\n \t\t\t\t\t\tenum debug_info_usage);\n@@ -3323,7 +3401,7 @@ static bool is_naming_typedef_decl (const_tree);\n static inline dw_die_ref get_context_die (tree);\n static void gen_namespace_die (tree, dw_die_ref);\n static dw_die_ref gen_namelist_decl (tree, dw_die_ref, tree);\n-static dw_die_ref gen_decl_die (tree, tree, dw_die_ref);\n+static dw_die_ref gen_decl_die (tree, tree, struct vlr_context *, dw_die_ref);\n static dw_die_ref force_decl_die (tree);\n static dw_die_ref force_type_die (tree);\n static dw_die_ref setup_namespace_context (tree, dw_die_ref);\n@@ -5456,6 +5534,15 @@ print_signature (FILE *outfile, char *sig)\n     fprintf (outfile, \"%02x\", sig[i] & 0xff);\n }\n \n+static inline void\n+print_discr_value (FILE *outfile, dw_discr_value *discr_value)\n+{\n+  if (discr_value->pos)\n+    fprintf (outfile, HOST_WIDE_INT_PRINT_UNSIGNED, discr_value->v.sval);\n+  else\n+    fprintf (outfile, HOST_WIDE_INT_PRINT_DEC, discr_value->v.uval);\n+}\n+\n static void print_loc_descr (dw_loc_descr_ref, FILE *);\n \n /* Print the value associated to the VAL DWARF value node to OUTFILE.  If\n@@ -5574,6 +5661,26 @@ print_dw_val (dw_val_node *val, bool recurse, FILE *outfile)\n \t  fprintf (outfile, \"%02x\", val->v.val_data8[i]);\n \tbreak;\n       }\n+    case dw_val_class_discr_value:\n+      print_discr_value (outfile, &val->v.val_discr_value);\n+      break;\n+    case dw_val_class_discr_list:\n+      for (dw_discr_list_ref node = val->v.val_discr_list;\n+\t   node != NULL;\n+\t   node = node->dw_discr_next)\n+\t{\n+\t  if (node->dw_discr_range)\n+\t    {\n+\t      fprintf (outfile, \" .. \");\n+\t      print_discr_value (outfile, &node->dw_discr_lower_bound);\n+\t      print_discr_value (outfile, &node->dw_discr_upper_bound);\n+\t    }\n+\t  else\n+\t    print_discr_value (outfile, &node->dw_discr_lower_bound);\n+\n+\t  if (node->dw_discr_next != NULL)\n+\t    fprintf (outfile, \" | \");\n+\t}\n     default:\n       break;\n     }\n@@ -7596,6 +7703,104 @@ remove_child_or_replace_with_skeleton (dw_die_ref unit, dw_die_ref child,\n   return skeleton;\n }\n \n+static void\n+copy_dwarf_procs_ref_in_attrs (dw_die_ref die,\n+\t\t\t       comdat_type_node *type_node,\n+\t\t\t       hash_map<dw_die_ref, dw_die_ref> &copied_dwarf_procs);\n+\n+/* Helper for copy_dwarf_procs_ref_in_dies.  Make a copy of the DIE DWARF\n+   procedure, put it under TYPE_NODE and return the copy.  Continue looking for\n+   DWARF procedure references in the DW_AT_location attribute.  */\n+\n+static dw_die_ref\n+copy_dwarf_procedure (dw_die_ref die,\n+\t\t      comdat_type_node *type_node,\n+\t\t      hash_map<dw_die_ref, dw_die_ref> &copied_dwarf_procs)\n+{\n+  /* We do this for COMDAT section, which is DWARFv4 specific, so\n+     DWARF procedure are always DW_TAG_dwarf_procedure DIEs (unlike\n+     DW_TAG_variable in DWARFv3).  */\n+  gcc_assert (die->die_tag == DW_TAG_dwarf_procedure);\n+\n+  /* DWARF procedures are not supposed to have children...  */\n+  gcc_assert (die->die_child == NULL);\n+\n+  /* ... and they are supposed to have only one attribute: DW_AT_location.  */\n+  gcc_assert (vec_safe_length (die->die_attr) == 1\n+\t      && ((*die->die_attr)[0].dw_attr == DW_AT_location));\n+\n+  /* Do not copy more than once DWARF procedures.  */\n+  bool existed;\n+  dw_die_ref &die_copy = copied_dwarf_procs.get_or_insert (die, &existed);\n+  if (existed)\n+    return die_copy;\n+\n+  die_copy = clone_die (die);\n+  add_child_die (type_node->root_die, die_copy);\n+  copy_dwarf_procs_ref_in_attrs (die_copy, type_node, copied_dwarf_procs);\n+  return die_copy;\n+}\n+\n+/* Helper for copy_dwarf_procs_ref_in_dies.  Look for references to DWARF\n+   procedures in DIE's attributes.  */\n+\n+static void\n+copy_dwarf_procs_ref_in_attrs (dw_die_ref die,\n+\t\t\t       comdat_type_node *type_node,\n+\t\t\t       hash_map<dw_die_ref, dw_die_ref> &copied_dwarf_procs)\n+{\n+  dw_attr_node *a;\n+  unsigned i;\n+\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, i, a)\n+    {\n+      dw_loc_descr_ref loc;\n+\n+      if (a->dw_attr_val.val_class != dw_val_class_loc)\n+\tcontinue;\n+\n+      for (loc = a->dw_attr_val.v.val_loc; loc != NULL; loc = loc->dw_loc_next)\n+\t{\n+\t  switch (loc->dw_loc_opc)\n+\t    {\n+\t    case DW_OP_call2:\n+\t    case DW_OP_call4:\n+\t    case DW_OP_call_ref:\n+\t      gcc_assert (loc->dw_loc_oprnd1.val_class\n+\t\t\t  == dw_val_class_die_ref);\n+\t      loc->dw_loc_oprnd1.v.val_die_ref.die\n+\t        = copy_dwarf_procedure (loc->dw_loc_oprnd1.v.val_die_ref.die,\n+\t\t\t\t\ttype_node,\n+\t\t\t\t\tcopied_dwarf_procs);\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Copy DWARF procedures that are referenced by the DIE tree to TREE_NODE and\n+   rewrite references to point to the copies.\n+\n+   References are looked for in DIE's attributes and recursively in all its\n+   children attributes that are location descriptions. COPIED_DWARF_PROCS is a\n+   mapping from old DWARF procedures to their copy. It is used not to copy\n+   twice the same DWARF procedure under TYPE_NODE.  */\n+\n+static void\n+copy_dwarf_procs_ref_in_dies (dw_die_ref die,\n+\t\t\t      comdat_type_node *type_node,\n+\t\t\t      hash_map<dw_die_ref, dw_die_ref> &copied_dwarf_procs)\n+{\n+  dw_die_ref c;\n+\n+  copy_dwarf_procs_ref_in_attrs (die, type_node, copied_dwarf_procs);\n+  FOR_EACH_CHILD (die, c, copy_dwarf_procs_ref_in_dies (c,\n+\t\t\t\t\t\t\ttype_node,\n+\t\t\t\t\t\t\tcopied_dwarf_procs));\n+}\n+\n /* Traverse the DIE and set up additional .debug_types sections for each\n    type worthy of being placed in a COMDAT section.  */\n \n@@ -7646,6 +7851,13 @@ break_out_comdat_types (dw_die_ref die)\n         /* Add the DIE to the new compunit.  */\n \tadd_child_die (unit, c);\n \n+\t/* Types can reference DWARF procedures for type size or data location\n+\t   expressions.  Calls in DWARF expressions cannot target procedures\n+\t   that are not in the same section.  So we must copy DWARF procedures\n+\t   along with this type and then rewrite references to them.  */\n+\thash_map<dw_die_ref, dw_die_ref> copied_dwarf_procs;\n+\tcopy_dwarf_procs_ref_in_dies (c, type_node, copied_dwarf_procs);\n+\n         if (replacement != NULL)\n           c = replacement;\n       }\n@@ -8248,6 +8460,18 @@ size_of_die (dw_die_ref die)\n \tcase dw_val_class_high_pc:\n \t  size += DWARF2_ADDR_SIZE;\n \t  break;\n+\tcase dw_val_class_discr_value:\n+\t  size += size_of_discr_value (&a->dw_attr_val.v.val_discr_value);\n+\t  break;\n+\tcase dw_val_class_discr_list:\n+\t    {\n+\t      unsigned block_size = size_of_discr_list (AT_discr_list (a));\n+\n+\t      /* This is a block, so we have the block length and then its\n+\t\t data.  */\n+\t      size += constant_size (block_size) + block_size;\n+\t    }\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -8631,6 +8855,23 @@ value_format (dw_attr_node *a)\n \t  gcc_unreachable ();\n \t}\n \n+    case dw_val_class_discr_value:\n+      return (a->dw_attr_val.v.val_discr_value.pos\n+\t      ? DW_FORM_udata\n+\t      : DW_FORM_sdata);\n+    case dw_val_class_discr_list:\n+      switch (constant_size (size_of_discr_list (AT_discr_list (a))))\n+\t{\n+\tcase 1:\n+\t  return DW_FORM_block1;\n+\tcase 2:\n+\t  return DW_FORM_block2;\n+\tcase 4:\n+\t  return DW_FORM_block4;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -8900,6 +9141,17 @@ output_signature (const char *sig, const char *name)\n     dw2_asm_output_data (1, sig[i], i == 0 ? \"%s\" : NULL, name);\n }\n \n+/* Output a discriminant value.  */\n+\n+static inline void\n+output_discr_value (dw_discr_value *discr_value, const char *name)\n+{\n+  if (discr_value->pos)\n+    dw2_asm_output_data_uleb128 (discr_value->v.uval, \"%s\", name);\n+  else\n+    dw2_asm_output_data_sleb128 (discr_value->v.sval, \"%s\", name);\n+}\n+\n /* Output the DIE and its attributes.  Called recursively to generate\n    the definitions of each child DIE.  */\n \n@@ -9178,6 +9430,37 @@ output_die (dw_die_ref die)\n \t\t\t\tget_AT_low_pc (die), \"DW_AT_high_pc\");\n \t  break;\n \n+\tcase dw_val_class_discr_value:\n+\t  output_discr_value (&a->dw_attr_val.v.val_discr_value, name);\n+\t  break;\n+\n+\tcase dw_val_class_discr_list:\n+\t  {\n+\t    dw_discr_list_ref list = AT_discr_list (a);\n+\t    const int size = size_of_discr_list (list);\n+\n+\t    /* This is a block, so output its length first.  */\n+\t    dw2_asm_output_data (constant_size (size), size,\n+\t\t\t\t \"%s: block size\", name);\n+\n+\t    for (; list != NULL; list = list->dw_discr_next)\n+\t      {\n+\t\t/* One byte for the discriminant value descriptor, and then as\n+\t\t   many LEB128 numbers as required.  */\n+\t\tif (list->dw_discr_range)\n+\t\t  dw2_asm_output_data (1, DW_DSC_range,\n+\t\t\t\t       \"%s: DW_DSC_range\", name);\n+\t\telse\n+\t\t  dw2_asm_output_data (1, DW_DSC_label,\n+\t\t\t\t       \"%s: DW_DSC_label\", name);\n+\n+\t\toutput_discr_value (&list->dw_discr_lower_bound, name);\n+\t\tif (list->dw_discr_range)\n+\t\t  output_discr_value (&list->dw_discr_upper_bound, name);\n+\t      }\n+\t    break;\n+\t  }\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -11482,6 +11765,151 @@ int_loc_descriptor (HOST_WIDE_INT i)\n   return new_loc_descr (op, i, 0);\n }\n \n+/* Likewise, for unsigned constants.  */\n+\n+static dw_loc_descr_ref\n+uint_loc_descriptor (unsigned HOST_WIDE_INT i)\n+{\n+  const unsigned HOST_WIDE_INT max_int = INTTYPE_MAXIMUM (HOST_WIDE_INT);\n+  const unsigned HOST_WIDE_INT max_uint\n+    = INTTYPE_MAXIMUM (unsigned HOST_WIDE_INT);\n+\n+  /* If possible, use the clever signed constants handling.  */\n+  if (i <= max_int)\n+    return int_loc_descriptor ((HOST_WIDE_INT) i);\n+\n+  /* Here, we are left with positive numbers that cannot be represented as\n+     HOST_WIDE_INT, i.e.:\n+         max (HOST_WIDE_INT) < i <= max (unsigned HOST_WIDE_INT)\n+\n+     Using DW_OP_const4/8/./u operation to encode them consumes a lot of bytes\n+     whereas may be better to output a negative integer: thanks to integer\n+     wrapping, we know that:\n+         x = x - 2 ** DWARF2_ADDR_SIZE\n+\t   = x - 2 * (max (HOST_WIDE_INT) + 1)\n+     So numbers close to max (unsigned HOST_WIDE_INT) could be represented as\n+     small negative integers.  Let's try that in cases it will clearly improve\n+     the encoding: there is no gain turning DW_OP_const4u into\n+     DW_OP_const4s.  */\n+  if (DWARF2_ADDR_SIZE * 8 == HOST_BITS_PER_WIDE_INT\n+      && ((DWARF2_ADDR_SIZE == 4 && i > max_uint - 0x8000)\n+\t  || (DWARF2_ADDR_SIZE == 8 && i > max_uint - 0x80000000)))\n+    {\n+      const unsigned HOST_WIDE_INT first_shift = i - max_int - 1;\n+\n+      /* Now, -1 <  first_shift <= max (HOST_WIDE_INT)\n+\t i.e.  0 <= first_shift <= max (HOST_WIDE_INT).  */\n+      const HOST_WIDE_INT second_shift\n+        = (HOST_WIDE_INT) first_shift - (HOST_WIDE_INT) max_int - 1;\n+\n+      /* So we finally have:\n+\t      -max (HOST_WIDE_INT) - 1 <= second_shift <= -1.\n+\t i.e.  min (HOST_WIDE_INT)     <= second_shift <  0.  */\n+      return int_loc_descriptor (second_shift);\n+    }\n+\n+  /* Last chance: fallback to a simple constant operation.  */\n+  return new_loc_descr\n+     ((HOST_BITS_PER_WIDE_INT == 32 || i <= 0xffffffff)\n+      ? DW_OP_const4u\n+      : DW_OP_const8u,\n+      i, 0);\n+}\n+\n+/* Generate and return a location description that computes the unsigned\n+   comparison of the two stack top entries (a OP b where b is the top-most\n+   entry and a is the second one).  The KIND of comparison can be LT_EXPR,\n+   LE_EXPR, GT_EXPR or GE_EXPR.  */\n+\n+static dw_loc_descr_ref\n+uint_comparison_loc_list (enum tree_code kind)\n+{\n+  enum dwarf_location_atom op, flip_op;\n+  dw_loc_descr_ref ret, bra_node, jmp_node, tmp;\n+\n+  switch (kind)\n+    {\n+    case LT_EXPR:\n+      op = DW_OP_lt;\n+      break;\n+    case LE_EXPR:\n+      op = DW_OP_le;\n+      break;\n+    case GT_EXPR:\n+      op = DW_OP_gt;\n+      break;\n+    case GE_EXPR:\n+      op = DW_OP_ge;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  bra_node = new_loc_descr (DW_OP_bra, 0, 0);\n+  jmp_node = new_loc_descr (DW_OP_skip, 0, 0);\n+\n+  /* Until DWARFv4, operations all work on signed integers.  It is nevertheless\n+     possible to perform unsigned comparisons: we just have to distinguish\n+     three cases:\n+\n+       1. when a and b have the same sign (as signed integers); then we should\n+\t  return: a OP(signed) b;\n+\n+       2. when a is a negative signed integer while b is a positive one, then a\n+\t  is a greater unsigned integer than b; likewise when a and b's roles\n+\t  are flipped.\n+\n+     So first, compare the sign of the two operands.  */\n+  ret = new_loc_descr (DW_OP_over, 0, 0);\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_over, 0, 0));\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_xor, 0, 0));\n+  /* If they have different signs (i.e. they have different sign bits), then\n+     the stack top value has now the sign bit set and thus it's smaller than\n+     zero.  */\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_lit0, 0, 0));\n+  add_loc_descr (&ret, new_loc_descr (DW_OP_lt, 0, 0));\n+  add_loc_descr (&ret, bra_node);\n+\n+  /* We are in case 1.  At this point, we know both operands have the same\n+     sign, to it's safe to use the built-in signed comparison.  */\n+  add_loc_descr (&ret, new_loc_descr (op, 0, 0));\n+  add_loc_descr (&ret, jmp_node);\n+\n+  /* We are in case 2.  Here, we know both operands do not have the same sign,\n+     so we have to flip the signed comparison.  */\n+  flip_op = (kind == LT_EXPR || kind == LE_EXPR) ? DW_OP_gt : DW_OP_lt;\n+  tmp = new_loc_descr (flip_op, 0, 0);\n+  bra_node->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+  bra_node->dw_loc_oprnd1.v.val_loc = tmp;\n+  add_loc_descr (&ret, tmp);\n+\n+  /* This dummy operation is necessary to make the two branches join.  */\n+  tmp = new_loc_descr (DW_OP_nop, 0, 0);\n+  jmp_node->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+  jmp_node->dw_loc_oprnd1.v.val_loc = tmp;\n+  add_loc_descr (&ret, tmp);\n+\n+  return ret;\n+}\n+\n+/* Likewise, but takes the location description lists (might be destructive on\n+   them).  Return NULL if either is NULL or if concatenation fails.  */\n+\n+static dw_loc_list_ref\n+loc_list_from_uint_comparison (dw_loc_list_ref left, dw_loc_list_ref right,\n+\t\t\t       enum tree_code kind)\n+{\n+  if (left == NULL || right == NULL)\n+    return NULL;\n+\n+  add_loc_list (&left, right);\n+  if (left == NULL)\n+    return NULL;\n+\n+  add_loc_descr_to_each (left, uint_comparison_loc_list (kind));\n+  return left;\n+}\n+\n /* Return size_of_locs (int_shift_loc_descriptor (i, shift))\n    without actually allocating it.  */\n \n@@ -14526,6 +14954,68 @@ loc_list_for_address_of_addr_expr_of_indirect_ref (tree loc, bool toplev,\n   return list_ret;\n }\n \n+/* Set LOC to the next operation that is not a DW_OP_nop operation. In the case\n+   all operations from LOC are nops, move to the last one.  Insert in NOPS all\n+   operations that are skipped.  */\n+\n+static void\n+loc_descr_to_next_no_nop (dw_loc_descr_ref &loc,\n+\t\t\t  hash_set<dw_loc_descr_ref> &nops)\n+{\n+  while (loc->dw_loc_next != NULL && loc->dw_loc_opc == DW_OP_nop)\n+    {\n+      nops.add (loc);\n+      loc = loc->dw_loc_next;\n+    }\n+}\n+\n+/* Helper for loc_descr_without_nops: free the location description operation\n+   P.  */\n+\n+bool\n+free_loc_descr (const dw_loc_descr_ref &loc, void *data ATTRIBUTE_UNUSED)\n+{\n+  ggc_free (loc);\n+  return true;\n+}\n+\n+/* Remove all DW_OP_nop operations from LOC except, if it exists, the one that\n+   finishes LOC.  */\n+\n+static void\n+loc_descr_without_nops (dw_loc_descr_ref &loc)\n+{\n+  if (loc->dw_loc_opc == DW_OP_nop && loc->dw_loc_next == NULL)\n+    return;\n+\n+  /* Set of all DW_OP_nop operations we remove.  */\n+  hash_set<dw_loc_descr_ref> nops;\n+\n+  /* First, strip all prefix NOP operations in order to keep the head of the\n+     operations list.  */\n+  loc_descr_to_next_no_nop (loc, nops);\n+\n+  for (dw_loc_descr_ref cur = loc; cur != NULL;)\n+    {\n+      /* For control flow operations: strip \"prefix\" nops in destination\n+\t labels.  */\n+      if (cur->dw_loc_oprnd1.val_class == dw_val_class_loc)\n+\tloc_descr_to_next_no_nop (cur->dw_loc_oprnd1.v.val_loc, nops);\n+      if (cur->dw_loc_oprnd2.val_class == dw_val_class_loc)\n+\tloc_descr_to_next_no_nop (cur->dw_loc_oprnd2.v.val_loc, nops);\n+\n+      /* Do the same for the operations that follow, then move to the next\n+\t iteration.  */\n+      if (cur->dw_loc_next != NULL)\n+\tloc_descr_to_next_no_nop (cur->dw_loc_next, nops);\n+      cur = cur->dw_loc_next;\n+    }\n+\n+  nops.traverse<void *, free_loc_descr> (NULL);\n+}\n+\n+\n+struct dwarf_procedure_info;\n \n /* Helper structure for location descriptions generation.  */\n struct loc_descr_context\n@@ -14537,82 +15027,594 @@ struct loc_descr_context\n   /* The ..._DECL node that should be translated as a\n      DW_OP_push_object_address operation.  */\n   tree base_decl;\n+  /* Information about the DWARF procedure we are currently generating. NULL if\n+     we are not generating a DWARF procedure.  */\n+  struct dwarf_procedure_info *dpi;\n };\n \n-/* Generate Dwarf location list representing LOC.\n-   If WANT_ADDRESS is false, expression computing LOC will be computed\n-   If WANT_ADDRESS is 1, expression computing address of LOC will be returned\n-   if WANT_ADDRESS is 2, expression computing address useable in location\n-     will be returned (i.e. DW_OP_reg can be used\n-     to refer to register values).\n+/* DWARF procedures generation\n \n-   CONTEXT provides information to customize the location descriptions\n-   generation.  Its context_type field specifies what type is implicitly\n-   referenced by DW_OP_push_object_address.  If it is NULL_TREE, this operation\n-   will not be generated.\n+   DWARF expressions (aka. location descriptions) are used to encode variable\n+   things such as sizes or offsets.  Such computations can have redundant parts\n+   that can be factorized in order to reduce the size of the output debug\n+   information.  This is the whole point of DWARF procedures.\n \n-   If CONTEXT is NULL, the behavior is the same as if both context_type and\n-   base_decl fields were NULL_TREE.  */\n+   Thanks to stor-layout.c, size and offset expressions in GENERIC trees are\n+   already factorized into functions (\"size functions\") in order to handle very\n+   big and complex types.  Such functions are quite simple: they have integral\n+   arguments, they return an integral result and their body contains only a\n+   return statement with arithmetic expressions.  This is the only kind of\n+   function we are interested in translating into DWARF procedures, here.\n \n-static dw_loc_list_ref\n-loc_list_from_tree (tree loc, int want_address,\n-\t\t    const struct loc_descr_context *context)\n-{\n-  dw_loc_descr_ref ret = NULL, ret1 = NULL;\n-  dw_loc_list_ref list_ret = NULL, list_ret1 = NULL;\n-  int have_address = 0;\n-  enum dwarf_location_atom op;\n+   DWARF expressions and DWARF procedure are executed using a stack, so we have\n+   to define some calling convention for them to interact.  Let's say that:\n \n-  /* ??? Most of the time we do not take proper care for sign/zero\n-     extending the values properly.  Hopefully this won't be a real\n-     problem...  */\n+   - Before calling a DWARF procedure, DWARF expressions must push on the stack\n+     all arguments in reverse order (right-to-left) so that when the DWARF\n+     procedure execution starts, the first argument is the top of the stack.\n \n-  if (context != NULL\n-      && context->base_decl == loc\n-      && want_address == 0)\n-    {\n-      if (dwarf_version >= 3 || !dwarf_strict)\n-\treturn new_loc_list (new_loc_descr (DW_OP_push_object_address, 0, 0),\n-\t\t\t     NULL, NULL, NULL);\n-      else\n-\treturn NULL;\n-    }\n+   - Then, when returning, the DWARF procedure must have consumed all arguments\n+     on the stack, must have pushed the result and touched nothing else.\n \n-  switch (TREE_CODE (loc))\n-    {\n-    case ERROR_MARK:\n-      expansion_failed (loc, NULL_RTX, \"ERROR_MARK\");\n-      return 0;\n+   - Each integral argument and the result are integral types can be hold in a\n+     single stack slot.\n \n-    case PLACEHOLDER_EXPR:\n-      /* This case involves extracting fields from an object to determine the\n-\t position of other fields. It is supposed to appear only as the first\n-         operand of COMPONENT_REF nodes and to reference precisely the type\n-         that the context allows.  */\n-      if (context != NULL\n-          && TREE_TYPE (loc) == context->context_type\n-\t  && want_address >= 1)\n-\t{\n-\t  if (dwarf_version >= 3 || !dwarf_strict)\n-\t    {\n-\t      ret = new_loc_descr (DW_OP_push_object_address, 0, 0);\n-\t      have_address = 1;\n-\t      break;\n-\t    }\n-\t  else\n-\t    return NULL;\n-\t}\n-      else\n-\texpansion_failed (loc, NULL_RTX,\n-\t\t\t  \"PLACEHOLDER_EXPR for an unexpected type\");\n-      break;\n+   - We call \"frame offset\" the number of stack slots that are \"under DWARF\n+     procedure control\": it includes the arguments slots, the temporaries and\n+     the result slot. Thus, it is equal to the number of arguments when the\n+     procedure execution starts and must be equal to one (the result) when it\n+     returns.  */\n \n-    case CALL_EXPR:\n-      expansion_failed (loc, NULL_RTX, \"CALL_EXPR\");\n-      /* There are no opcodes for these operations.  */\n-      return 0;\n+/* Helper structure used when generating operations for a DWARF procedure.  */\n+struct dwarf_procedure_info\n+{\n+  /* The FUNCTION_DECL node corresponding to the DWARF procedure that is\n+     currently translated.  */\n+  tree fndecl;\n+  /* The number of arguments FNDECL takes.  */\n+  unsigned args_count;\n+};\n \n-    case PREINCREMENT_EXPR:\n+/* Return a pointer to a newly created DIE node for a DWARF procedure.  Add\n+   LOCATION as its DW_AT_location attribute.  If FNDECL is not NULL_TREE,\n+   equate it to this DIE.  */\n+\n+static dw_die_ref\n+new_dwarf_proc_die (dw_loc_descr_ref location, tree fndecl,\n+\t\t    dw_die_ref parent_die)\n+{\n+  const bool dwarf_proc_supported = dwarf_version >= 4;\n+  dw_die_ref dwarf_proc_die;\n+\n+  if ((dwarf_version < 3 && dwarf_strict)\n+      || location == NULL)\n+    return NULL;\n+\n+  dwarf_proc_die  = new_die (dwarf_proc_supported\n+\t\t\t     ? DW_TAG_dwarf_procedure\n+\t\t\t     : DW_TAG_variable,\n+\t\t\t     parent_die,\n+\t\t\t     fndecl);\n+  if (fndecl)\n+    equate_decl_number_to_die (fndecl, dwarf_proc_die);\n+  if (!dwarf_proc_supported)\n+    add_AT_flag (dwarf_proc_die, DW_AT_artificial, 1);\n+  add_AT_loc (dwarf_proc_die, DW_AT_location, location);\n+  return dwarf_proc_die;\n+}\n+\n+/* Return whether TYPE is a supported type as a DWARF procedure argument\n+   type or return type (we handle only scalar types and pointer types that\n+   aren't wider than the DWARF expression evaluation stack.  */\n+\n+static bool\n+is_handled_procedure_type (tree type)\n+{\n+  return ((INTEGRAL_TYPE_P (type)\n+\t   || TREE_CODE (type) == OFFSET_TYPE\n+\t   || TREE_CODE (type) == POINTER_TYPE)\n+\t  && int_size_in_bytes (type) <= DWARF2_ADDR_SIZE);\n+}\n+\n+/* Helper for resolve_args_picking.  Stop when coming across VISITED nodes.  */\n+\n+static bool\n+resolve_args_picking_1 (dw_loc_descr_ref loc, unsigned initial_frame_offset,\n+\t\t\tstruct dwarf_procedure_info *dpi,\n+\t\t\thash_set<dw_loc_descr_ref> &visited)\n+{\n+  /* The \"frame_offset\" identifier is already used to name a macro... */\n+  unsigned frame_offset_ = initial_frame_offset;\n+  dw_loc_descr_ref l;\n+\n+  for (l = loc; l != NULL;)\n+    {\n+      /* If we already met this node, there is nothing to compute anymore.  */\n+      if (visited.add (l))\n+\t{\n+#if ENABLE_CHECKING\n+\t  /* Make sure that the stack size is consistent wherever the execution\n+\t     flow comes from.  */\n+\t  gcc_assert ((unsigned) l->dw_loc_frame_offset == frame_offset_);\n+#endif\n+\t  break;\n+\t}\n+#if ENABLE_CHECKING\n+      l->dw_loc_frame_offset = frame_offset_;\n+#endif\n+\n+      /* If needed, relocate the picking offset with respect to the frame\n+\t offset. */\n+      if (l->dw_loc_opc == DW_OP_pick && l->frame_offset_rel)\n+\t{\n+\t  /* frame_offset_ is the size of the current stack frame, including\n+\t     incoming arguments. Besides, the arguments are pushed\n+\t     right-to-left.  Thus, in order to access the Nth argument from\n+\t     this operation node, the picking has to skip temporaries *plus*\n+\t     one stack slot per argument (0 for the first one, 1 for the second\n+\t     one, etc.).\n+\n+\t     The targetted argument number (N) is already set as the operand,\n+\t     and the number of temporaries can be computed with:\n+\t       frame_offsets_ - dpi->args_count */\n+\t  l->dw_loc_oprnd1.v.val_unsigned += frame_offset_ - dpi->args_count;\n+\n+\t  /* DW_OP_pick handles only offsets from 0 to 255 (inclusive)...  */\n+\t  if (l->dw_loc_oprnd1.v.val_unsigned > 255)\n+\t    return false;\n+\t}\n+\n+      /* Update frame_offset according to the effect the current operation has\n+\t on the stack.  */\n+      switch (l->dw_loc_opc)\n+\t{\n+\tcase DW_OP_deref:\n+\tcase DW_OP_swap:\n+\tcase DW_OP_rot:\n+\tcase DW_OP_abs:\n+\tcase DW_OP_not:\n+\tcase DW_OP_plus_uconst:\n+\tcase DW_OP_skip:\n+\tcase DW_OP_reg0:\n+\tcase DW_OP_reg1:\n+\tcase DW_OP_reg2:\n+\tcase DW_OP_reg3:\n+\tcase DW_OP_reg4:\n+\tcase DW_OP_reg5:\n+\tcase DW_OP_reg6:\n+\tcase DW_OP_reg7:\n+\tcase DW_OP_reg8:\n+\tcase DW_OP_reg9:\n+\tcase DW_OP_reg10:\n+\tcase DW_OP_reg11:\n+\tcase DW_OP_reg12:\n+\tcase DW_OP_reg13:\n+\tcase DW_OP_reg14:\n+\tcase DW_OP_reg15:\n+\tcase DW_OP_reg16:\n+\tcase DW_OP_reg17:\n+\tcase DW_OP_reg18:\n+\tcase DW_OP_reg19:\n+\tcase DW_OP_reg20:\n+\tcase DW_OP_reg21:\n+\tcase DW_OP_reg22:\n+\tcase DW_OP_reg23:\n+\tcase DW_OP_reg24:\n+\tcase DW_OP_reg25:\n+\tcase DW_OP_reg26:\n+\tcase DW_OP_reg27:\n+\tcase DW_OP_reg28:\n+\tcase DW_OP_reg29:\n+\tcase DW_OP_reg30:\n+\tcase DW_OP_reg31:\n+\tcase DW_OP_bregx:\n+\tcase DW_OP_piece:\n+\tcase DW_OP_deref_size:\n+\tcase DW_OP_nop:\n+\tcase DW_OP_form_tls_address:\n+\tcase DW_OP_bit_piece:\n+\tcase DW_OP_implicit_value:\n+\tcase DW_OP_stack_value:\n+\t  break;\n+\n+\tcase DW_OP_addr:\n+\tcase DW_OP_const1u:\n+\tcase DW_OP_const1s:\n+\tcase DW_OP_const2u:\n+\tcase DW_OP_const2s:\n+\tcase DW_OP_const4u:\n+\tcase DW_OP_const4s:\n+\tcase DW_OP_const8u:\n+\tcase DW_OP_const8s:\n+\tcase DW_OP_constu:\n+\tcase DW_OP_consts:\n+\tcase DW_OP_dup:\n+\tcase DW_OP_over:\n+\tcase DW_OP_pick:\n+\tcase DW_OP_lit0:\n+\tcase DW_OP_lit1:\n+\tcase DW_OP_lit2:\n+\tcase DW_OP_lit3:\n+\tcase DW_OP_lit4:\n+\tcase DW_OP_lit5:\n+\tcase DW_OP_lit6:\n+\tcase DW_OP_lit7:\n+\tcase DW_OP_lit8:\n+\tcase DW_OP_lit9:\n+\tcase DW_OP_lit10:\n+\tcase DW_OP_lit11:\n+\tcase DW_OP_lit12:\n+\tcase DW_OP_lit13:\n+\tcase DW_OP_lit14:\n+\tcase DW_OP_lit15:\n+\tcase DW_OP_lit16:\n+\tcase DW_OP_lit17:\n+\tcase DW_OP_lit18:\n+\tcase DW_OP_lit19:\n+\tcase DW_OP_lit20:\n+\tcase DW_OP_lit21:\n+\tcase DW_OP_lit22:\n+\tcase DW_OP_lit23:\n+\tcase DW_OP_lit24:\n+\tcase DW_OP_lit25:\n+\tcase DW_OP_lit26:\n+\tcase DW_OP_lit27:\n+\tcase DW_OP_lit28:\n+\tcase DW_OP_lit29:\n+\tcase DW_OP_lit30:\n+\tcase DW_OP_lit31:\n+\tcase DW_OP_breg0:\n+\tcase DW_OP_breg1:\n+\tcase DW_OP_breg2:\n+\tcase DW_OP_breg3:\n+\tcase DW_OP_breg4:\n+\tcase DW_OP_breg5:\n+\tcase DW_OP_breg6:\n+\tcase DW_OP_breg7:\n+\tcase DW_OP_breg8:\n+\tcase DW_OP_breg9:\n+\tcase DW_OP_breg10:\n+\tcase DW_OP_breg11:\n+\tcase DW_OP_breg12:\n+\tcase DW_OP_breg13:\n+\tcase DW_OP_breg14:\n+\tcase DW_OP_breg15:\n+\tcase DW_OP_breg16:\n+\tcase DW_OP_breg17:\n+\tcase DW_OP_breg18:\n+\tcase DW_OP_breg19:\n+\tcase DW_OP_breg20:\n+\tcase DW_OP_breg21:\n+\tcase DW_OP_breg22:\n+\tcase DW_OP_breg23:\n+\tcase DW_OP_breg24:\n+\tcase DW_OP_breg25:\n+\tcase DW_OP_breg26:\n+\tcase DW_OP_breg27:\n+\tcase DW_OP_breg28:\n+\tcase DW_OP_breg29:\n+\tcase DW_OP_breg30:\n+\tcase DW_OP_breg31:\n+\tcase DW_OP_fbreg:\n+\tcase DW_OP_push_object_address:\n+\tcase DW_OP_call_frame_cfa:\n+\t  ++frame_offset_;\n+\t  break;\n+\n+\tcase DW_OP_drop:\n+\tcase DW_OP_xderef:\n+\tcase DW_OP_and:\n+\tcase DW_OP_div:\n+\tcase DW_OP_minus:\n+\tcase DW_OP_mod:\n+\tcase DW_OP_mul:\n+\tcase DW_OP_neg:\n+\tcase DW_OP_or:\n+\tcase DW_OP_plus:\n+\tcase DW_OP_shl:\n+\tcase DW_OP_shr:\n+\tcase DW_OP_shra:\n+\tcase DW_OP_xor:\n+\tcase DW_OP_bra:\n+\tcase DW_OP_eq:\n+\tcase DW_OP_ge:\n+\tcase DW_OP_gt:\n+\tcase DW_OP_le:\n+\tcase DW_OP_lt:\n+\tcase DW_OP_ne:\n+\tcase DW_OP_regx:\n+\tcase DW_OP_xderef_size:\n+\t  --frame_offset_;\n+\t  break;\n+\n+\tcase DW_OP_call2:\n+\tcase DW_OP_call4:\n+\tcase DW_OP_call_ref:\n+\t  {\n+\t    dw_die_ref dwarf_proc = l->dw_loc_oprnd1.v.val_die_ref.die;\n+\t    int *stack_usage = dwarf_proc_stack_usage_map->get (dwarf_proc);\n+\n+\t    if (stack_usage == NULL)\n+\t      return false;\n+\t    frame_offset += *stack_usage;\n+\t    break;\n+\t  }\n+\n+\tcase DW_OP_GNU_push_tls_address:\n+\tcase DW_OP_GNU_uninit:\n+\tcase DW_OP_GNU_encoded_addr:\n+\tcase DW_OP_GNU_implicit_pointer:\n+\tcase DW_OP_GNU_entry_value:\n+\tcase DW_OP_GNU_const_type:\n+\tcase DW_OP_GNU_regval_type:\n+\tcase DW_OP_GNU_deref_type:\n+\tcase DW_OP_GNU_convert:\n+\tcase DW_OP_GNU_reinterpret:\n+\tcase DW_OP_GNU_parameter_ref:\n+\t  /* loc_list_from_tree will probably not output these operations for\n+\t     size functions, so assume they will not appear here.  */\n+\t  /* Fall through...  */\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      /* Now, follow the control flow (except subroutine calls).  */\n+      switch (l->dw_loc_opc)\n+\t{\n+\tcase DW_OP_bra:\n+\t  if (!resolve_args_picking_1 (l->dw_loc_next, frame_offset_, dpi,\n+\t\t\t\t       visited))\n+\t    return false;\n+\t  /* Fall through... */\n+\n+\tcase DW_OP_skip:\n+\t  l = l->dw_loc_oprnd1.v.val_loc;\n+\t  break;\n+\n+\tcase DW_OP_stack_value:\n+\t  return true;\n+\n+\tdefault:\n+\t  l = l->dw_loc_next;\n+\t  break;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* Make a DFS over operations reachable through LOC (i.e. follow branch\n+   operations) in order to resolve the operand of DW_OP_pick operations that\n+   target DWARF procedure arguments (DPI).  Stop at already visited nodes.\n+   INITIAL_FRAME_OFFSET is the frame offset *before* LOC is executed.  Return\n+   if all relocations were successful.  */\n+\n+static bool\n+resolve_args_picking (dw_loc_descr_ref loc, unsigned initial_frame_offset,\n+\t\t      struct dwarf_procedure_info *dpi)\n+{\n+  hash_set<dw_loc_descr_ref> visited;\n+\n+  return resolve_args_picking_1 (loc, initial_frame_offset, dpi, visited);\n+}\n+\n+/* Try to generate a DWARF procedure that computes the same result as FNDECL.\n+   Return NULL if it is not possible.  */\n+\n+static dw_die_ref\n+function_to_dwarf_procedure (tree fndecl)\n+{\n+  struct loc_descr_context ctx;\n+  struct dwarf_procedure_info dpi;\n+  dw_die_ref dwarf_proc_die;\n+  tree tree_body = DECL_SAVED_TREE (fndecl);\n+  dw_loc_descr_ref loc_body, epilogue;\n+\n+  tree cursor;\n+  unsigned i;\n+\n+  /* Do not generate multiple DWARF procedures for the same function\n+     declaration.  */\n+  dwarf_proc_die = lookup_decl_die (fndecl);\n+  if (dwarf_proc_die != NULL)\n+    return dwarf_proc_die;\n+\n+  /* DWARF procedures are available starting with the DWARFv3 standard, but\n+     it's the DWARFv4 standard that introduces the DW_TAG_dwarf_procedure\n+     DIE.  */\n+  if (dwarf_version < 3 && dwarf_strict)\n+    return NULL;\n+\n+  /* We handle only functions for which we still have a body, that return a\n+     supported type and that takes arguments with supported types.  Note that\n+     there is no point translating functions that return nothing.  */\n+  if (tree_body == NULL_TREE\n+      || DECL_RESULT (fndecl) == NULL_TREE\n+      || !is_handled_procedure_type (TREE_TYPE (DECL_RESULT (fndecl))))\n+    return NULL;\n+\n+  for (cursor = DECL_ARGUMENTS (fndecl);\n+       cursor != NULL_TREE;\n+       cursor = TREE_CHAIN (cursor))\n+    if (!is_handled_procedure_type (TREE_TYPE (cursor)))\n+      return NULL;\n+\n+  /* Match only \"expr\" in: RETURN_EXPR (MODIFY_EXPR (RESULT_DECL, expr)).  */\n+  if (TREE_CODE (tree_body) != RETURN_EXPR)\n+    return NULL;\n+  tree_body = TREE_OPERAND (tree_body, 0);\n+  if (TREE_CODE (tree_body) != MODIFY_EXPR\n+      || TREE_OPERAND (tree_body, 0) != DECL_RESULT (fndecl))\n+    return NULL;\n+  tree_body = TREE_OPERAND (tree_body, 1);\n+\n+  /* Try to translate the body expression itself.  Note that this will probably\n+     cause an infinite recursion if its call graph has a cycle.  This is very\n+     unlikely for size functions, however, so don't bother with such things at\n+     the moment.  */\n+  ctx.context_type = NULL_TREE;\n+  ctx.base_decl = NULL_TREE;\n+  ctx.dpi = &dpi;\n+  dpi.fndecl = fndecl;\n+  dpi.args_count = list_length (DECL_ARGUMENTS (fndecl));\n+  loc_body = loc_descriptor_from_tree (tree_body, 0, &ctx);\n+  if (!loc_body)\n+    return NULL;\n+\n+  /* After evaluating all operands in \"loc_body\", we should still have on the\n+     stack all arguments plus the desired function result (top of the stack).\n+     Generate code in order to keep only the result in our stack frame.  */\n+  epilogue = NULL;\n+  for (i = 0; i < dpi.args_count; ++i)\n+    {\n+      dw_loc_descr_ref op_couple = new_loc_descr (DW_OP_swap, 0, 0);\n+      op_couple->dw_loc_next = new_loc_descr (DW_OP_drop, 0, 0);\n+      op_couple->dw_loc_next->dw_loc_next = epilogue;\n+      epilogue = op_couple;\n+    }\n+  add_loc_descr (&loc_body, epilogue);\n+  if (!resolve_args_picking (loc_body, dpi.args_count, &dpi))\n+    return NULL;\n+\n+  /* Trailing nops from loc_descriptor_from_tree (if any) cannot be removed\n+     because they are considered useful.  Now there is an epilogue, they are\n+     not anymore, so give it another try.   */\n+  loc_descr_without_nops (loc_body);\n+\n+  /* fndecl may be used both as a regular DW_TAG_subprogram DIE and as\n+     a DW_TAG_dwarf_procedure, so we may have a conflict, here.  It's unlikely,\n+     though, given that size functions do not come from source, so they should\n+     not have a dedicated DW_TAG_subprogram DIE.  */\n+  dwarf_proc_die\n+    = new_dwarf_proc_die (loc_body, fndecl,\n+\t\t\t  get_context_die (DECL_CONTEXT (fndecl)));\n+\n+  /* The called DWARF procedure consumes one stack slot per argument and\n+     returns one stack slot.  */\n+  dwarf_proc_stack_usage_map->put (dwarf_proc_die, 1 - dpi.args_count);\n+\n+  return dwarf_proc_die;\n+}\n+\n+\n+/* Generate Dwarf location list representing LOC.\n+   If WANT_ADDRESS is false, expression computing LOC will be computed\n+   If WANT_ADDRESS is 1, expression computing address of LOC will be returned\n+   if WANT_ADDRESS is 2, expression computing address useable in location\n+     will be returned (i.e. DW_OP_reg can be used\n+     to refer to register values).\n+\n+   CONTEXT provides information to customize the location descriptions\n+   generation.  Its context_type field specifies what type is implicitly\n+   referenced by DW_OP_push_object_address.  If it is NULL_TREE, this operation\n+   will not be generated.\n+\n+   Its DPI field determines whether we are generating a DWARF expression for a\n+   DWARF procedure, so PARM_DECL references are processed specifically.\n+\n+   If CONTEXT is NULL, the behavior is the same as if context_type, base_decl\n+   and dpi fields were null.  */\n+\n+static dw_loc_list_ref\n+loc_list_from_tree_1 (tree loc, int want_address,\n+\t\t      const struct loc_descr_context *context)\n+{\n+  dw_loc_descr_ref ret = NULL, ret1 = NULL;\n+  dw_loc_list_ref list_ret = NULL, list_ret1 = NULL;\n+  int have_address = 0;\n+  enum dwarf_location_atom op;\n+\n+  /* ??? Most of the time we do not take proper care for sign/zero\n+     extending the values properly.  Hopefully this won't be a real\n+     problem...  */\n+\n+  if (context != NULL\n+      && context->base_decl == loc\n+      && want_address == 0)\n+    {\n+      if (dwarf_version >= 3 || !dwarf_strict)\n+\treturn new_loc_list (new_loc_descr (DW_OP_push_object_address, 0, 0),\n+\t\t\t     NULL, NULL, NULL);\n+      else\n+\treturn NULL;\n+    }\n+\n+  switch (TREE_CODE (loc))\n+    {\n+    case ERROR_MARK:\n+      expansion_failed (loc, NULL_RTX, \"ERROR_MARK\");\n+      return 0;\n+\n+    case PLACEHOLDER_EXPR:\n+      /* This case involves extracting fields from an object to determine the\n+\t position of other fields. It is supposed to appear only as the first\n+         operand of COMPONENT_REF nodes and to reference precisely the type\n+         that the context allows.  */\n+      if (context != NULL\n+          && TREE_TYPE (loc) == context->context_type\n+\t  && want_address >= 1)\n+\t{\n+\t  if (dwarf_version >= 3 || !dwarf_strict)\n+\t    {\n+\t      ret = new_loc_descr (DW_OP_push_object_address, 0, 0);\n+\t      have_address = 1;\n+\t      break;\n+\t    }\n+\t  else\n+\t    return NULL;\n+\t}\n+      else\n+\texpansion_failed (loc, NULL_RTX,\n+\t\t\t  \"PLACEHOLDER_EXPR for an unexpected type\");\n+      break;\n+\n+    case CALL_EXPR:\n+\t{\n+\t  const int nargs = call_expr_nargs (loc);\n+\t  tree callee = get_callee_fndecl (loc);\n+\t  int i;\n+\t  dw_die_ref dwarf_proc;\n+\n+\t  if (callee == NULL_TREE)\n+\t    goto call_expansion_failed;\n+\n+\t  /* We handle only functions that return an integer.  */\n+\t  if (!is_handled_procedure_type (TREE_TYPE (TREE_TYPE (callee))))\n+\t    goto call_expansion_failed;\n+\n+\t  dwarf_proc = function_to_dwarf_procedure (callee);\n+\t  if (dwarf_proc == NULL)\n+\t    goto call_expansion_failed;\n+\n+\t  /* Evaluate arguments right-to-left so that the first argument will\n+\t     be the top-most one on the stack.  */\n+\t  for (i = nargs - 1; i >= 0; --i)\n+\t    {\n+\t      dw_loc_descr_ref loc_descr\n+\t        = loc_descriptor_from_tree (CALL_EXPR_ARG (loc, i), 0,\n+\t\t\t\t\t    context);\n+\n+\t      if (loc_descr == NULL)\n+\t\tgoto call_expansion_failed;\n+\n+\t      add_loc_descr (&ret, loc_descr);\n+\t    }\n+\n+\t  ret1 = new_loc_descr (DW_OP_call4, 0, 0);\n+\t  ret1->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t  ret1->dw_loc_oprnd1.v.val_die_ref.die = dwarf_proc;\n+\t  ret1->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t  add_loc_descr (&ret, ret1);\n+\t  break;\n+\n+\tcall_expansion_failed:\n+\t  expansion_failed (loc, NULL_RTX, \"CALL_EXPR\");\n+\t  /* There are no opcodes for these operations.  */\n+\t  return 0;\n+\t}\n+\n+    case PREINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n@@ -14635,7 +15637,7 @@ loc_list_from_tree (tree loc, int want_address,\n \t}\n         /* Otherwise, process the argument and look for the address.  */\n       if (!list_ret && !ret)\n-        list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 1, context);\n+        list_ret = loc_list_from_tree_1 (TREE_OPERAND (loc, 0), 1, context);\n       else\n \t{\n \t  if (want_address)\n@@ -14702,10 +15704,34 @@ loc_list_from_tree (tree loc, int want_address,\n       /* FALLTHRU */\n \n     case PARM_DECL:\n+      if (context != NULL && context->dpi != NULL\n+\t  && DECL_CONTEXT (loc) == context->dpi->fndecl)\n+\t{\n+\t  /* We are generating code for a DWARF procedure and we want to access\n+\t     one of its arguments: find the appropriate argument offset and let\n+\t     the resolve_args_picking pass compute the offset that complies\n+\t     with the stack frame size.  */\n+\t  unsigned i = 0;\n+\t  tree cursor;\n+\n+\t  for (cursor = DECL_ARGUMENTS (context->dpi->fndecl);\n+\t       cursor != NULL_TREE && cursor != loc;\n+\t       cursor = TREE_CHAIN (cursor), ++i)\n+\t    ;\n+\t  /* If we are translating a DWARF procedure, all referenced parameters\n+\t     must belong to the current function.  */\n+\t  gcc_assert (cursor != NULL_TREE);\n+\n+\t  ret = new_loc_descr (DW_OP_pick, i, 0);\n+\t  ret->frame_offset_rel = 1;\n+\t  break;\n+\t}\n+      /* FALLTHRU */\n+\n     case RESULT_DECL:\n       if (DECL_HAS_VALUE_EXPR_P (loc))\n-\treturn loc_list_from_tree (DECL_VALUE_EXPR (loc),\n-\t\t\t\t   want_address, context);\n+\treturn loc_list_from_tree_1 (DECL_VALUE_EXPR (loc),\n+\t\t\t\t     want_address, context);\n       /* FALLTHRU */\n \n     case FUNCTION_DECL:\n@@ -14779,7 +15805,7 @@ loc_list_from_tree (tree loc, int want_address,\n \t}\n       /* Fallthru.  */\n     case INDIRECT_REF:\n-      list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0, context);\n+      list_ret = loc_list_from_tree_1 (TREE_OPERAND (loc, 0), 0, context);\n       have_address = 1;\n       break;\n \n@@ -14789,13 +15815,16 @@ loc_list_from_tree (tree loc, int want_address,\n       return NULL;\n \n     case COMPOUND_EXPR:\n-      return loc_list_from_tree (TREE_OPERAND (loc, 1), want_address, context);\n+      return loc_list_from_tree_1 (TREE_OPERAND (loc, 1), want_address,\n+\t\t\t\t   context);\n \n     CASE_CONVERT:\n     case VIEW_CONVERT_EXPR:\n     case SAVE_EXPR:\n     case MODIFY_EXPR:\n-      return loc_list_from_tree (TREE_OPERAND (loc, 0), want_address, context);\n+    case NON_LVALUE_EXPR:\n+      return loc_list_from_tree_1 (TREE_OPERAND (loc, 0), want_address,\n+\t\t\t\t   context);\n \n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n@@ -14814,10 +15843,10 @@ loc_list_from_tree (tree loc, int want_address,\n \n \tgcc_assert (obj != loc);\n \n-\tlist_ret = loc_list_from_tree (obj,\n-\t\t\t\t       want_address == 2\n-\t\t\t\t       && !bitpos && !offset ? 2 : 1,\n-\t\t\t\t       context);\n+\tlist_ret = loc_list_from_tree_1 (obj,\n+\t\t\t\t\t want_address == 2\n+\t\t\t\t\t && !bitpos && !offset ? 2 : 1,\n+\t\t\t\t\t context);\n \t/* TODO: We can extract value of the small expression via shifting even\n \t   for nonzero bitpos.  */\n \tif (list_ret == 0)\n@@ -14832,7 +15861,7 @@ loc_list_from_tree (tree loc, int want_address,\n \tif (offset != NULL_TREE)\n \t  {\n \t    /* Variable offset.  */\n-\t    list_ret1 = loc_list_from_tree (offset, 0, context);\n+\t    list_ret1 = loc_list_from_tree_1 (offset, 0, context);\n \t    if (list_ret1 == 0)\n \t      return 0;\n \t    add_loc_list (&list_ret, list_ret1);\n@@ -14863,6 +15892,8 @@ loc_list_from_tree (tree loc, int want_address,\n \thave_address = 1;\n       else if (tree_fits_shwi_p (loc))\n \tret = int_loc_descriptor (tree_to_shwi (loc));\n+      else if (tree_fits_uhwi_p (loc))\n+\tret = uint_loc_descriptor (tree_to_uhwi (loc));\n       else\n \t{\n \t  expansion_failed (loc, NULL_RTX,\n@@ -14904,6 +15935,7 @@ loc_list_from_tree (tree loc, int want_address,\n     case CEIL_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case TRUNC_DIV_EXPR:\n+    case EXACT_DIV_EXPR:\n       if (TYPE_UNSIGNED (TREE_TYPE (loc)))\n \treturn 0;\n       op = DW_OP_div;\n@@ -14922,8 +15954,8 @@ loc_list_from_tree (tree loc, int want_address,\n \t  op = DW_OP_mod;\n \t  goto do_binop;\n \t}\n-      list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0, context);\n-      list_ret1 = loc_list_from_tree (TREE_OPERAND (loc, 1), 0, context);\n+      list_ret = loc_list_from_tree_1 (TREE_OPERAND (loc, 0), 0, context);\n+      list_ret1 = loc_list_from_tree_1 (TREE_OPERAND (loc, 1), 0, context);\n       if (list_ret == 0 || list_ret1 == 0)\n \treturn 0;\n \n@@ -14954,44 +15986,82 @@ loc_list_from_tree (tree loc, int want_address,\n     do_plus:\n       if (tree_fits_shwi_p (TREE_OPERAND (loc, 1)))\n \t{\n-\t  list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0, context);\n+\t  /* Big unsigned numbers can fit in HOST_WIDE_INT but it may be\n+\t     smarter to encode their opposite.  The DW_OP_plus_uconst operation\n+\t     takes 1 + X bytes, X being the size of the ULEB128 addend.  On the\n+\t     other hand, a \"<push literal>; DW_OP_minus\" pattern takes 1 + Y\n+\t     bytes, Y being the size of the operation that pushes the opposite\n+\t     of the addend.  So let's choose the smallest representation.  */\n+\t  const tree tree_addend = TREE_OPERAND (loc, 1);\n+\t  offset_int wi_addend;\n+\t  HOST_WIDE_INT shwi_addend;\n+\t  dw_loc_descr_ref loc_naddend;\n+\n+\t  list_ret = loc_list_from_tree_1 (TREE_OPERAND (loc, 0), 0, context);\n \t  if (list_ret == 0)\n \t    return 0;\n \n-\t  loc_list_plus_const (list_ret, tree_to_shwi (TREE_OPERAND (loc, 1)));\n+\t  /* Try to get the literal to push.  It is the opposite of the addend,\n+\t     so as we rely on wrapping during DWARF evaluation, first decode\n+\t     the literal as a \"DWARF-sized\" signed number.  */\n+\t  wi_addend = wi::to_offset (tree_addend);\n+\t  wi_addend = wi::sext (wi_addend, DWARF2_ADDR_SIZE * 8);\n+\t  shwi_addend = wi_addend.to_shwi ();\n+\t  loc_naddend = (shwi_addend != INTTYPE_MINIMUM (HOST_WIDE_INT))\n+\t\t\t? int_loc_descriptor (-shwi_addend)\n+\t\t\t: NULL;\n+\n+\t  if (loc_naddend != NULL\n+\t      && ((unsigned) size_of_uleb128 (shwi_addend)\n+\t          > size_of_loc_descr (loc_naddend)))\n+\t    {\n+\t      add_loc_descr_to_each (list_ret, loc_naddend);\n+\t      add_loc_descr_to_each (list_ret,\n+\t\t\t\t     new_loc_descr (DW_OP_minus, 0, 0));\n+\t    }\n+\t  else\n+\t    {\n+\t      for (dw_loc_descr_ref loc_cur = loc_naddend; loc_cur != NULL; )\n+\t\t{\n+\t\t  loc_naddend = loc_cur;\n+\t\t  loc_cur = loc_cur->dw_loc_next;\n+\t\t  ggc_free (loc_naddend);\n+\t\t}\n+\t      loc_list_plus_const (list_ret, wi_addend.to_shwi ());\n+\t    }\n \t  break;\n \t}\n \n       op = DW_OP_plus;\n       goto do_binop;\n \n     case LE_EXPR:\n-      if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n-\treturn 0;\n-\n       op = DW_OP_le;\n-      goto do_binop;\n+      goto do_comp_binop;\n \n     case GE_EXPR:\n-      if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n-\treturn 0;\n-\n       op = DW_OP_ge;\n-      goto do_binop;\n+      goto do_comp_binop;\n \n     case LT_EXPR:\n-      if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n-\treturn 0;\n-\n       op = DW_OP_lt;\n-      goto do_binop;\n+      goto do_comp_binop;\n \n     case GT_EXPR:\n-      if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n-\treturn 0;\n-\n       op = DW_OP_gt;\n-      goto do_binop;\n+      goto do_comp_binop;\n+\n+    do_comp_binop:\n+      if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n+\t{\n+\t  list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0, context);\n+\t  list_ret1 = loc_list_from_tree (TREE_OPERAND (loc, 1), 0, context);\n+\t  list_ret = loc_list_from_uint_comparison (list_ret, list_ret1,\n+\t\t\t\t\t\t    TREE_CODE (loc));\n+\t  break;\n+\t}\n+      else\n+\tgoto do_binop;\n \n     case EQ_EXPR:\n       op = DW_OP_eq;\n@@ -15002,8 +16072,8 @@ loc_list_from_tree (tree loc, int want_address,\n       goto do_binop;\n \n     do_binop:\n-      list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0, context);\n-      list_ret1 = loc_list_from_tree (TREE_OPERAND (loc, 1), 0, context);\n+      list_ret = loc_list_from_tree_1 (TREE_OPERAND (loc, 0), 0, context);\n+      list_ret1 = loc_list_from_tree_1 (TREE_OPERAND (loc, 1), 0, context);\n       if (list_ret == 0 || list_ret1 == 0)\n \treturn 0;\n \n@@ -15027,7 +16097,7 @@ loc_list_from_tree (tree loc, int want_address,\n       goto do_unop;\n \n     do_unop:\n-      list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0, context);\n+      list_ret = loc_list_from_tree_1 (TREE_OPERAND (loc, 0), 0, context);\n       if (list_ret == 0)\n \treturn 0;\n \n@@ -15053,10 +16123,10 @@ loc_list_from_tree (tree loc, int want_address,\n \tdw_loc_descr_ref lhs\n \t  = loc_descriptor_from_tree (TREE_OPERAND (loc, 1), 0, context);\n \tdw_loc_list_ref rhs\n-\t  = loc_list_from_tree (TREE_OPERAND (loc, 2), 0, context);\n+\t  = loc_list_from_tree_1 (TREE_OPERAND (loc, 2), 0, context);\n \tdw_loc_descr_ref bra_node, jump_node, tmp;\n \n-\tlist_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0, context);\n+\tlist_ret = loc_list_from_tree_1 (TREE_OPERAND (loc, 0), 0, context);\n \tif (list_ret == 0 || lhs == 0 || rhs == 0)\n \t  return 0;\n \n@@ -15159,6 +16229,22 @@ loc_list_from_tree (tree loc, int want_address,\n   return list_ret;\n }\n \n+/* Likewise, but strip useless DW_OP_nop operations in the resulting\n+   expressions.  */\n+\n+static dw_loc_list_ref\n+loc_list_from_tree (tree loc, int want_address,\n+\t\t    const struct loc_descr_context *context)\n+{\n+  dw_loc_list_ref result = loc_list_from_tree_1 (loc, want_address, context);\n+\n+  for (dw_loc_list_ref loc_cur = result;\n+       loc_cur != NULL; loc_cur =\n+       loc_cur->dw_loc_next)\n+    loc_descr_without_nops (loc_cur->expr);\n+  return result;\n+}\n+\n /* Same as above but return only single location expression.  */\n static dw_loc_descr_ref\n loc_descriptor_from_tree (tree loc, int want_address,\n@@ -15229,34 +16315,91 @@ round_up_to_align (const offset_int &t, unsigned int align)\n   return wi::udiv_trunc (t + align - 1, align) * align;\n }\n \n-/* Given a pointer to a FIELD_DECL, compute and return the byte offset of the\n-   lowest addressed byte of the \"containing object\" for the given FIELD_DECL,\n-   or return 0 if we are unable to determine what that offset is, either\n-   because the argument turns out to be a pointer to an ERROR_MARK node, or\n-   because the offset is actually variable.  (We can't handle the latter case\n-   just yet).  */\n+/* Compute the size of TYPE in bytes.  If possible, return NULL and store the\n+   size as an integer constant in CST_SIZE.  Otherwise, if possible, return a\n+   DWARF expression that computes the size.  Return NULL and set CST_SIZE to -1\n+   if we fail to return the size in one of these two forms.  */\n \n-static HOST_WIDE_INT\n-field_byte_offset (const_tree decl)\n+static dw_loc_descr_ref\n+type_byte_size (const_tree type, HOST_WIDE_INT *cst_size)\n+{\n+  tree tree_size;\n+  struct loc_descr_context ctx;\n+\n+  /* Return a constant integer in priority, if possible.  */\n+  *cst_size = int_size_in_bytes (type);\n+  if (*cst_size != -1)\n+    return NULL;\n+\n+  ctx.context_type = const_cast<tree> (type);\n+  ctx.base_decl = NULL_TREE;\n+  ctx.dpi = NULL;\n+\n+  type = TYPE_MAIN_VARIANT (type);\n+  tree_size = TYPE_SIZE_UNIT (type);\n+  return ((tree_size != NULL_TREE)\n+\t  ? loc_descriptor_from_tree (tree_size, 0, &ctx)\n+\t  : NULL);\n+}\n+\n+/* Helper structure for RECORD_TYPE processing.  */\n+struct vlr_context\n+{\n+  /* Root RECORD_TYPE.  It is needed to generate data member location\n+     descriptions in variable-length records (VLR), but also to cope with\n+     variants, which are composed of nested structures multiplexed with\n+     QUAL_UNION_TYPE nodes.  Each time such a structure is passed to a\n+     function processing a FIELD_DECL, it is required to be non null.  */\n+  tree struct_type;\n+  /* When generating a variant part in a RECORD_TYPE (i.e. a nested\n+     QUAL_UNION_TYPE), this holds an expression that computes the offset for\n+     this variant part as part of the root record (in storage units).  For\n+     regular records, it must be NULL_TREE.  */\n+  tree variant_part_offset;\n+};\n+\n+/* Given a pointer to a FIELD_DECL, compute the byte offset of the lowest\n+   addressed byte of the \"containing object\" for the given FIELD_DECL. If\n+   possible, return a native constant through CST_OFFSET (in which case NULL is\n+   returned); otherwise return a DWARF expression that computes the offset.\n+\n+   Set *CST_OFFSET to 0 and return NULL if we are unable to determine what\n+   that offset is, either because the argument turns out to be a pointer to an\n+   ERROR_MARK node, or because the offset expression is too complex for us.\n+\n+   CTX is required: see the comment for VLR_CONTEXT.  */\n+\n+static dw_loc_descr_ref\n+field_byte_offset (const_tree decl, struct vlr_context *ctx,\n+\t\t   HOST_WIDE_INT *cst_offset)\n {\n   offset_int object_offset_in_bits;\n   offset_int object_offset_in_bytes;\n   offset_int bitpos_int;\n+  bool is_byte_offset_cst, is_bit_offset_cst;\n+  tree tree_result;\n+  dw_loc_list_ref loc_result;\n \n-  if (TREE_CODE (decl) == ERROR_MARK)\n-    return 0;\n+  *cst_offset = 0;\n \n-  gcc_assert (TREE_CODE (decl) == FIELD_DECL);\n+  if (TREE_CODE (decl) == ERROR_MARK)\n+    return NULL;\n+  else\n+    gcc_assert (TREE_CODE (decl) == FIELD_DECL);\n \n-  /* We cannot yet cope with fields whose positions are variable, so\n-     for now, when we see such things, we simply return 0.  Someday, we may\n-     be able to handle such cases, but it will be damn difficult.  */\n-  if (TREE_CODE (bit_position (decl)) != INTEGER_CST)\n-    return 0;\n+  is_bit_offset_cst = TREE_CODE (DECL_FIELD_BIT_OFFSET (decl)) != INTEGER_CST;\n+  is_byte_offset_cst = TREE_CODE (DECL_FIELD_OFFSET (decl)) != INTEGER_CST;\n \n-  bitpos_int = wi::to_offset (bit_position (decl));\n+  /* We cannot handle variable bit offsets at the moment, so abort if it's the\n+     case.  */\n+  if (is_bit_offset_cst)\n+    return NULL;\n \n-  if (PCC_BITFIELD_TYPE_MATTERS)\n+#ifdef PCC_BITFIELD_TYPE_MATTERS\n+  /* We used to handle only constant offsets in all cases.  Now, we handle\n+     properly dynamic byte offsets only when PCC bitfield type doesn't\n+     matter.  */\n+  if (PCC_BITFIELD_TYPE_MATTERS && is_byte_offset_cst && is_bit_offset_cst)\n     {\n       tree type;\n       tree field_size_tree;\n@@ -15266,6 +16409,7 @@ field_byte_offset (const_tree decl)\n       unsigned int decl_align_in_bits;\n       offset_int type_size_in_bits;\n \n+      bitpos_int = wi::to_offset (bit_position (decl));\n       type = field_type (decl);\n       type_size_in_bits = offset_int_type_size_in_bits (type);\n       type_align_in_bits = simple_type_align_in_bits (type);\n@@ -15352,12 +16496,33 @@ field_byte_offset (const_tree decl)\n \t    = round_up_to_align (object_offset_in_bits, decl_align_in_bits);\n \t}\n     }\n-  else\n-    object_offset_in_bits = bitpos_int;\n+#endif /* PCC_BITFIELD_TYPE_MATTERS */\n+\n+  tree_result = byte_position (decl);\n+  if (ctx->variant_part_offset != NULL_TREE)\n+    tree_result = fold (build2 (PLUS_EXPR, TREE_TYPE (tree_result),\n+\t\t\t\tctx->variant_part_offset, tree_result));\n \n-  object_offset_in_bytes\n-    = wi::lrshift (object_offset_in_bits, LOG2_BITS_PER_UNIT);\n-  return object_offset_in_bytes.to_shwi ();\n+  /* If the byte offset is a constant, it's simplier to handle a native\n+     constant rather than a DWARF expression.  */\n+  if (TREE_CODE (tree_result) == INTEGER_CST)\n+    {\n+      *cst_offset = wi::to_offset (tree_result).to_shwi ();\n+      return NULL;\n+    }\n+  struct loc_descr_context loc_ctx = {\n+    ctx->struct_type, /* context_type */\n+    NULL_TREE,\t      /* base_decl */\n+    NULL\t      /* dpi */\n+  };\n+  loc_result = loc_list_from_tree (tree_result, 0, &loc_ctx);\n+\n+  /* We want a DWARF expression: abort if we only have a location list with\n+     multiple elements.  */\n+  if (!loc_result || !single_element_loc_list_p (loc_result))\n+    return NULL;\n+  else\n+    return loc_result->expr;\n }\n \f\n /* The following routines define various Dwarf attributes and any data\n@@ -15421,10 +16586,14 @@ add_accessibility_attribute (dw_die_ref die, tree decl)\n    DW_AT_byte_size attribute for this bit-field.  (See the\n    `byte_size_attribute' function below.)  It is also used when calculating the\n    value of the DW_AT_bit_offset attribute.  (See the `bit_offset_attribute'\n-   function below.)  */\n+   function below.)\n+\n+   CTX is required: see the comment for VLR_CONTEXT.  */\n \n static void\n-add_data_member_location_attribute (dw_die_ref die, tree decl)\n+add_data_member_location_attribute (dw_die_ref die,\n+\t\t\t\t    tree decl,\n+\t\t\t\t    struct vlr_context *ctx)\n {\n   HOST_WIDE_INT offset;\n   dw_loc_descr_ref loc_descr = 0;\n@@ -15474,7 +16643,23 @@ add_data_member_location_attribute (dw_die_ref die, tree decl)\n \toffset = tree_to_shwi (BINFO_OFFSET (decl));\n     }\n   else\n-    offset = field_byte_offset (decl);\n+    {\n+      loc_descr = field_byte_offset (decl, ctx, &offset);\n+\n+      /* Data member location evalutation start with the base address on the\n+\t stack.  Compute the field offset and add it to this base address.  */\n+      if (loc_descr != NULL)\n+\tadd_loc_descr (&loc_descr, new_loc_descr (DW_OP_plus, 0, 0));\n+    }\n+\n+  /* If loc_descr is available then we know the field offset is dynamic.\n+     However, GDB does not handle dynamic field offsets very well at the\n+     moment.  */\n+  if (loc_descr != NULL && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+    {\n+      loc_descr = NULL;\n+      offset = 0;\n+    }\n \n   if (! loc_descr)\n     {\n@@ -16924,6 +18109,14 @@ add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr,\n \t/* FALLTHRU */\n \n       default:\n+\t/* Because of the complex interaction there can be with other GNAT\n+\t   encodings, GDB isn't ready yet to handle proper DWARF description\n+\t   for self-referencial subrange bounds: let GNAT encodings do the\n+\t   magic in such a case.  */\n+\tif (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL\n+\t    && contains_placeholder_p (bound))\n+\t  return;\n+\n \tadd_scalar_info (subrange_die, bound_attr, bound,\n \t\t\t dw_scalar_form_constant\n \t\t\t | dw_scalar_form_exprloc\n@@ -17040,6 +18233,7 @@ add_byte_size_attribute (dw_die_ref die, tree tree_node)\n {\n   dw_die_ref decl_die;\n   HOST_WIDE_INT size;\n+  dw_loc_descr_ref size_expr = NULL;\n \n   switch (TREE_CODE (tree_node))\n     {\n@@ -17056,7 +18250,7 @@ add_byte_size_attribute (dw_die_ref die, tree tree_node)\n \t  add_AT_die_ref (die, DW_AT_byte_size, decl_die);\n \t  return;\n \t}\n-      size = int_size_in_bytes (tree_node);\n+      size_expr = type_byte_size (tree_node, &size);\n       break;\n     case FIELD_DECL:\n       /* For a data member of a struct or union, the DW_AT_byte_size is\n@@ -17069,10 +18263,17 @@ add_byte_size_attribute (dw_die_ref die, tree tree_node)\n       gcc_unreachable ();\n     }\n \n+  /* Support for dynamically-sized objects was introduced by DWARFv3.\n+     At the moment, GDB does not handle variable byte sizes very well,\n+     though.  */\n+  if ((dwarf_version >= 3 || !dwarf_strict)\n+      && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL\n+      && size_expr != NULL)\n+    add_AT_loc (die, DW_AT_byte_size, size_expr);\n+\n   /* Note that `size' might be -1 when we get to this point.  If it is, that\n-     indicates that the byte size of the entity in question is variable.  We\n-     have no good way of expressing this fact in Dwarf at the present time,\n-     when location description was not used by the caller code instead.  */\n+     indicates that the byte size of the entity in question is variable and\n+     that we could not generate a DWARF expression that computes it.  */\n   if (size >= 0)\n     add_AT_unsigned (die, DW_AT_byte_size, size);\n }\n@@ -17089,22 +18290,26 @@ add_byte_size_attribute (dw_die_ref die, tree tree_node)\n    exact location of the \"containing object\" for a bit-field is rather\n    complicated.  It's handled by the `field_byte_offset' function (above).\n \n+   CTX is required: see the comment for VLR_CONTEXT.\n+\n    Note that it is the size (in bytes) of the hypothetical \"containing object\"\n    which will be given in the DW_AT_byte_size attribute for this bit-field.\n    (See `byte_size_attribute' above).  */\n \n static inline void\n-add_bit_offset_attribute (dw_die_ref die, tree decl)\n+add_bit_offset_attribute (dw_die_ref die, tree decl, struct vlr_context *ctx)\n {\n-  HOST_WIDE_INT object_offset_in_bytes = field_byte_offset (decl);\n-  tree type = DECL_BIT_FIELD_TYPE (decl);\n+  HOST_WIDE_INT object_offset_in_bytes;\n+  tree original_type = DECL_BIT_FIELD_TYPE (decl);\n   HOST_WIDE_INT bitpos_int;\n   HOST_WIDE_INT highest_order_object_bit_offset;\n   HOST_WIDE_INT highest_order_field_bit_offset;\n   HOST_WIDE_INT bit_offset;\n \n+  field_byte_offset (decl, ctx, &object_offset_in_bytes);\n+\n   /* Must be a field and a bit field.  */\n-  gcc_assert (type && TREE_CODE (decl) == FIELD_DECL);\n+  gcc_assert (original_type && TREE_CODE (decl) == FIELD_DECL);\n \n   /* We can't yet handle bit-fields whose offsets are variable, so if we\n      encounter such things, just return without generating any attribute\n@@ -17126,7 +18331,8 @@ add_bit_offset_attribute (dw_die_ref die, tree decl)\n   if (! BYTES_BIG_ENDIAN)\n     {\n       highest_order_field_bit_offset += tree_to_shwi (DECL_SIZE (decl));\n-      highest_order_object_bit_offset += simple_type_size_in_bits (type);\n+      highest_order_object_bit_offset +=\n+        simple_type_size_in_bits (original_type);\n     }\n \n   bit_offset\n@@ -17336,6 +18542,44 @@ add_name_and_src_coords_attributes (dw_die_ref die, tree decl)\n #endif /* VMS_DEBUGGING_INFO */\n }\n \n+/* Add VALUE as a DW_AT_discr_value attribute to DIE.  */\n+\n+static void\n+add_discr_value (dw_die_ref die, dw_discr_value *value)\n+{\n+  dw_attr_node attr;\n+\n+  attr.dw_attr = DW_AT_discr_value;\n+  attr.dw_attr_val.val_class = dw_val_class_discr_value;\n+  attr.dw_attr_val.val_entry = NULL;\n+  attr.dw_attr_val.v.val_discr_value.pos = value->pos;\n+  if (value->pos)\n+    attr.dw_attr_val.v.val_discr_value.v.uval = value->v.uval;\n+  else\n+    attr.dw_attr_val.v.val_discr_value.v.sval = value->v.sval;\n+  add_dwarf_attr (die, &attr);\n+}\n+\n+/* Add DISCR_LIST as a DW_AT_discr_list to DIE.  */\n+\n+static void\n+add_discr_list (dw_die_ref die, dw_discr_list_ref discr_list)\n+{\n+  dw_attr_node attr;\n+\n+  attr.dw_attr = DW_AT_discr_list;\n+  attr.dw_attr_val.val_class = dw_val_class_discr_list;\n+  attr.dw_attr_val.val_entry = NULL;\n+  attr.dw_attr_val.v.val_discr_list = discr_list;\n+  add_dwarf_attr (die, &attr);\n+}\n+\n+static inline dw_discr_list_ref\n+AT_discr_list (dw_attr_node *attr)\n+{\n+  return attr->dw_attr_val.v.val_discr_list;\n+}\n+\n #ifdef VMS_DEBUGGING_INFO\n /* Output the debug main pointer die for VMS */\n \n@@ -17795,7 +19039,7 @@ gen_descr_array_type_die (tree type, struct array_descr_info *info,\n {\n   const dw_die_ref scope_die = scope_die_for (type, context_die);\n   const dw_die_ref array_die = new_die (DW_TAG_array_type, scope_die, type);\n-  const struct loc_descr_context context = { type, info->base_decl };\n+  const struct loc_descr_context context = { type, info->base_decl, NULL };\n   int dim;\n \n   add_name_attribute (array_die, type_tag (type));\n@@ -18314,8 +19558,12 @@ gen_type_die_for_member (tree type, tree member, dw_die_ref context_die)\n \t      || TREE_CODE (TREE_TYPE (member)) == UNION_TYPE\n \t      || TREE_CODE (TREE_TYPE (member)) == RECORD_TYPE)\n \t    {\n+\t      struct vlr_context vlr_ctx = {\n+\t\tDECL_CONTEXT (member), /* struct_type */\n+\t\tNULL_TREE /* variant_part_offset */\n+\t      };\n \t      gen_type_die (member_declared_type (member), type_die);\n-\t      gen_field_die (member, type_die);\n+\t      gen_field_die (member, &vlr_ctx, type_die);\n \t    }\n \t}\n       else\n@@ -19189,7 +20437,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t\t\t\t   &parm);\n \t  else if (parm && !POINTER_BOUNDS_P (parm))\n \t    {\n-\t      dw_die_ref parm_die = gen_decl_die (parm, NULL, subr_die);\n+\t      dw_die_ref parm_die = gen_decl_die (parm, NULL, NULL, subr_die);\n \n \t      if (parm == DECL_ARGUMENTS (decl)\n \t\t  && TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE\n@@ -19251,7 +20499,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \n       /* Emit a DW_TAG_variable DIE for a named return value.  */\n       if (DECL_NAME (DECL_RESULT (decl)))\n-\tgen_decl_die (DECL_RESULT (decl), NULL, subr_die);\n+\tgen_decl_die (DECL_RESULT (decl), NULL, NULL, subr_die);\n \n       /* The first time through decls_for_scope we will generate the\n \t DIEs for the locals.  The second time, we fill in the\n@@ -20008,10 +21256,11 @@ gen_inlined_subroutine_die (tree stmt, dw_die_ref context_die)\n     }\n }\n \n-/* Generate a DIE for a field in a record, or structure.  */\n+/* Generate a DIE for a field in a record, or structure.  CTX is required: see\n+   the comment for VLR_CONTEXT.  */\n \n static void\n-gen_field_die (tree decl, dw_die_ref context_die)\n+gen_field_die (tree decl, struct vlr_context *ctx, dw_die_ref context_die)\n {\n   dw_die_ref decl_die;\n \n@@ -20027,11 +21276,16 @@ gen_field_die (tree decl, dw_die_ref context_die)\n     {\n       add_byte_size_attribute (decl_die, decl);\n       add_bit_size_attribute (decl_die, decl);\n-      add_bit_offset_attribute (decl_die, decl);\n+      add_bit_offset_attribute (decl_die, decl, ctx);\n     }\n \n+  /* If we have a variant part offset, then we are supposed to process a member\n+     of a QUAL_UNION_TYPE, which is how we represent variant parts in\n+     trees.  */\n+  gcc_assert (ctx->variant_part_offset == NULL_TREE\n+\t      || TREE_CODE (DECL_FIELD_CONTEXT (decl)) != QUAL_UNION_TYPE);\n   if (TREE_CODE (DECL_FIELD_CONTEXT (decl)) != UNION_TYPE)\n-    add_data_member_location_attribute (decl_die, decl);\n+    add_data_member_location_attribute (decl_die, decl, ctx);\n \n   if (DECL_ARTIFICIAL (decl))\n     add_AT_flag (decl_die, DW_AT_artificial, 1);\n@@ -20356,12 +21610,14 @@ gen_compile_unit_die (const char *filename)\n /* Generate the DIE for a base class.  */\n \n static void\n-gen_inheritance_die (tree binfo, tree access, dw_die_ref context_die)\n+gen_inheritance_die (tree binfo, tree access, tree type,\n+\t\t     dw_die_ref context_die)\n {\n   dw_die_ref die = new_die (DW_TAG_inheritance, context_die, binfo);\n+  struct vlr_context ctx = { type, NULL };\n \n   add_type_attribute (die, BINFO_TYPE (binfo), TYPE_UNQUALIFIED, context_die);\n-  add_data_member_location_attribute (die, binfo);\n+  add_data_member_location_attribute (die, binfo, &ctx);\n \n   if (BINFO_VIRTUAL_P (binfo))\n     add_AT_unsigned (die, DW_AT_virtuality, DW_VIRTUALITY_virtual);\n@@ -20382,6 +21638,407 @@ gen_inheritance_die (tree binfo, tree access, dw_die_ref context_die)\n     add_AT_unsigned (die, DW_AT_accessibility, DW_ACCESS_private);\n }\n \n+/* Return whether DECL is a FIELD_DECL that represents the variant part of a\n+   structure.  */\n+static bool\n+is_variant_part (tree decl)\n+{\n+  return (TREE_CODE (decl) == FIELD_DECL\n+\t  && TREE_CODE (TREE_TYPE (decl)) == QUAL_UNION_TYPE);\n+}\n+\n+/* Check that OPERAND is a reference to a field in STRUCT_TYPE.  If it is,\n+   return the FIELD_DECL.  Return NULL_TREE otherwise.  */\n+\n+static tree\n+analyze_discr_in_predicate (tree operand, tree struct_type)\n+{\n+  bool continue_stripping = true;\n+  while (continue_stripping)\n+    switch (TREE_CODE (operand))\n+      {\n+      CASE_CONVERT:\n+\toperand = TREE_OPERAND (operand, 0);\n+\tbreak;\n+      default:\n+\tcontinue_stripping = false;\n+\tbreak;\n+      }\n+\n+  /* Match field access to members of struct_type only.  */\n+  if (TREE_CODE (operand) == COMPONENT_REF\n+      && TREE_CODE (TREE_OPERAND (operand, 0)) == PLACEHOLDER_EXPR\n+      && TREE_TYPE (TREE_OPERAND (operand, 0)) == struct_type\n+      && TREE_CODE (TREE_OPERAND (operand, 1)) == FIELD_DECL)\n+    return TREE_OPERAND (operand, 1);\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* Check that SRC is a constant integer that can be represented as a native\n+   integer constant (either signed or unsigned).  If so, store it into DEST and\n+   return true.  Return false otherwise. */\n+\n+static bool\n+get_discr_value (tree src, dw_discr_value *dest)\n+{\n+  bool is_unsigned = TYPE_UNSIGNED (TREE_TYPE (src));\n+\n+  if (TREE_CODE (src) != INTEGER_CST\n+      || !(is_unsigned ? tree_fits_uhwi_p (src) : tree_fits_shwi_p (src)))\n+    return false;\n+\n+  dest->pos = is_unsigned;\n+  if (is_unsigned)\n+    dest->v.uval = tree_to_uhwi (src);\n+  else\n+    dest->v.sval = tree_to_shwi (src);\n+\n+  return true;\n+}\n+\n+/* Try to extract synthetic properties out of VARIANT_PART_DECL, which is a\n+   FIELD_DECL in STRUCT_TYPE that represents a variant part.  If unsuccessful,\n+   store NULL_TREE in DISCR_DECL.  Otherwise:\n+\n+     - store the discriminant field in STRUCT_TYPE that controls the variant\n+       part to *DISCR_DECL\n+\n+     - put in *DISCR_LISTS_P an array where for each variant, the item\n+       represents the corresponding matching list of discriminant values.\n+\n+     - put in *DISCR_LISTS_LENGTH the number of variants, which is the size of\n+       the above array.\n+\n+   Note that when the array is allocated (i.e. when the analysis is\n+   successful), it is up to the caller to free the array.  */\n+\n+static void\n+analyze_variants_discr (tree variant_part_decl,\n+\t\t\ttree struct_type,\n+\t\t\ttree *discr_decl,\n+\t\t\tdw_discr_list_ref **discr_lists_p,\n+\t\t\tunsigned *discr_lists_length)\n+{\n+  tree variant_part_type = TREE_TYPE (variant_part_decl);\n+  tree variant;\n+  dw_discr_list_ref *discr_lists;\n+  unsigned i;\n+\n+  /* Compute how many variants there are in this variant part.  */\n+  *discr_lists_length = 0;\n+  for (variant = TYPE_FIELDS (variant_part_type);\n+       variant != NULL_TREE;\n+       variant = DECL_CHAIN (variant))\n+    ++*discr_lists_length;\n+\n+  *discr_decl = NULL_TREE;\n+  *discr_lists_p\n+    = (dw_discr_list_ref *) xcalloc (*discr_lists_length,\n+\t\t\t\t     sizeof (**discr_lists_p));\n+  discr_lists = *discr_lists_p;\n+\n+  /* And then analyze all variants to extract discriminant information for all\n+     of them.  This analysis is conservative: as soon as we detect something we\n+     do not support, abort everything and pretend we found nothing.  */\n+  for (variant = TYPE_FIELDS (variant_part_type), i = 0;\n+       variant != NULL_TREE;\n+       variant = DECL_CHAIN (variant), ++i)\n+    {\n+      tree match_expr = DECL_QUALIFIER (variant);\n+\n+      /* Now, try to analyze the predicate and deduce a discriminant for\n+\t it.  */\n+      if (match_expr == boolean_true_node)\n+\t/* Typically happens for the default variant: it matches all cases that\n+\t   previous variants rejected.  Don't output any matching value for\n+\t   this one.  */\n+\tcontinue;\n+\n+      /* The following loop tries to iterate over each discriminant\n+\t possibility: single values or ranges.  */\n+      while (match_expr != NULL_TREE)\n+\t{\n+\t  tree next_round_match_expr;\n+\t  tree candidate_discr = NULL_TREE;\n+\t  dw_discr_list_ref new_node = NULL;\n+\n+\t  /* Possibilities are matched one after the other by nested\n+\t     TRUTH_ORIF_EXPR expressions.  Process the current possibility and\n+\t     continue with the rest at next iteration.  */\n+\t  if (TREE_CODE (match_expr) == TRUTH_ORIF_EXPR)\n+\t    {\n+\t      next_round_match_expr = TREE_OPERAND (match_expr, 0);\n+\t      match_expr = TREE_OPERAND (match_expr, 1);\n+\t    }\n+\t  else\n+\t    next_round_match_expr = NULL_TREE;\n+\n+\t  if (match_expr == boolean_false_node)\n+\t    /* This sub-expression matches nothing: just wait for the next\n+\t       one.  */\n+\t    ;\n+\n+\t  else if (TREE_CODE (match_expr) == EQ_EXPR)\n+\t    {\n+\t      /* We are matching:  <discr_field> == <integer_cst>\n+\t\t This sub-expression matches a single value.  */\n+\t      tree integer_cst = TREE_OPERAND (match_expr, 1);\n+\n+\t      candidate_discr\n+\t       = analyze_discr_in_predicate (TREE_OPERAND (match_expr, 0),\n+\t\t\t\t\t     struct_type);\n+\n+\t      new_node = ggc_cleared_alloc<dw_discr_list_node> ();\n+\t      if (!get_discr_value (integer_cst,\n+\t\t\t\t    &new_node->dw_discr_lower_bound))\n+\t\tgoto abort;\n+\t      new_node->dw_discr_range = false;\n+\t    }\n+\n+\t  else if (TREE_CODE (match_expr) == TRUTH_ANDIF_EXPR)\n+\t    {\n+\t      /* We are matching:\n+\t\t   <discr_field> > <integer_cst>\n+\t\t   && <discr_field> < <integer_cst>.\n+\t\t This sub-expression matches the range of values between the\n+\t\t two matched integer constants.  Note that comparisons can be\n+\t\t inclusive or exclusive.  */\n+\t      tree candidate_discr_1, candidate_discr_2;\n+\t      tree lower_cst, upper_cst;\n+\t      bool lower_cst_included, upper_cst_included;\n+\t      tree lower_op = TREE_OPERAND (match_expr, 0);\n+\t      tree upper_op = TREE_OPERAND (match_expr, 1);\n+\n+\t      /* When the comparison is exclusive, the integer constant is not\n+\t\t the discriminant range bound we are looking for: we will have\n+\t\t to increment or decrement it.  */\n+\t      if (TREE_CODE (lower_op) == GE_EXPR)\n+\t\tlower_cst_included = true;\n+\t      else if (TREE_CODE (lower_op) == GT_EXPR)\n+\t\tlower_cst_included = false;\n+\t      else\n+\t\tgoto abort;\n+\n+\t      if (TREE_CODE (upper_op) == LE_EXPR)\n+\t\tupper_cst_included = true;\n+\t      else if (TREE_CODE (upper_op) == LT_EXPR)\n+\t\tupper_cst_included = false;\n+\t      else\n+\t\tgoto abort;\n+\n+\t      /* Extract the discriminant from the first operand and check it\n+\t\t is consistant with the same analysis in the second\n+\t\t operand.  */\n+\t      candidate_discr_1\n+\t        = analyze_discr_in_predicate (TREE_OPERAND (lower_op, 0),\n+\t\t\t\t\t      struct_type);\n+\t      candidate_discr_2\n+\t        = analyze_discr_in_predicate (TREE_OPERAND (upper_op, 0),\n+\t\t\t\t\t      struct_type);\n+\t      if (candidate_discr_1 == candidate_discr_2)\n+\t\tcandidate_discr = candidate_discr_1;\n+\t      else\n+\t\tgoto abort;\n+\n+\t      /* Extract bounds from both.  */\n+\t      new_node = ggc_cleared_alloc<dw_discr_list_node> ();\n+\t      lower_cst = TREE_OPERAND (lower_op, 1);\n+\t      upper_cst = TREE_OPERAND (upper_op, 1);\n+\n+\t      if (!lower_cst_included)\n+\t\tlower_cst\n+\t\t  = fold (build2 (PLUS_EXPR, TREE_TYPE (lower_cst),\n+\t\t\t\t  lower_cst,\n+\t\t\t\t  build_int_cst (TREE_TYPE (lower_cst), 1)));\n+\t      if (!upper_cst_included)\n+\t\tupper_cst\n+\t\t  = fold (build2 (MINUS_EXPR, TREE_TYPE (upper_cst),\n+\t\t\t\t  upper_cst,\n+\t\t\t\t  build_int_cst (TREE_TYPE (upper_cst), 1)));\n+\n+\t      if (!get_discr_value (lower_cst,\n+\t\t\t\t    &new_node->dw_discr_lower_bound)\n+\t\t  || !get_discr_value (upper_cst,\n+\t\t\t\t       &new_node->dw_discr_upper_bound))\n+\t\tgoto abort;\n+\n+\t      new_node->dw_discr_range = true;\n+\t    }\n+\n+\t  else\n+\t    /* Unsupported sub-expression: we cannot determine the set of\n+\t       matching discriminant values.  Abort everything.  */\n+\t    goto abort;\n+\n+\t  /* If the discriminant info is not consistant with what we saw so\n+\t     far, consider the analysis failed and abort everything.  */\n+\t  if (candidate_discr == NULL_TREE\n+\t      || (*discr_decl != NULL_TREE && candidate_discr != *discr_decl))\n+\t    goto abort;\n+\t  else\n+\t    *discr_decl = candidate_discr;\n+\n+\t  if (new_node != NULL)\n+\t    {\n+\t      new_node->dw_discr_next = discr_lists[i];\n+\t      discr_lists[i] = new_node;\n+\t    }\n+\t  match_expr = next_round_match_expr;\n+\t}\n+    }\n+\n+  /* If we reach this point, we could match everything we were interested\n+     in.  */\n+  return;\n+\n+abort:\n+  /* Clean all data structure and return no result.  */\n+  free (*discr_lists_p);\n+  *discr_lists_p = NULL;\n+  *discr_decl = NULL_TREE;\n+}\n+\n+/* Generate a DIE to represent VARIANT_PART_DECL, a variant part that is part\n+   of STRUCT_TYPE, a record type.  This new DIE is emitted as the next child\n+   under CONTEXT_DIE.\n+\n+   Variant parts are supposed to be implemented as a FIELD_DECL whose type is a\n+   QUAL_UNION_TYPE: this is the VARIANT_PART_DECL parameter.  The members for\n+   this type, which are record types, represent the available variants and each\n+   has a DECL_QUALIFIER attribute.  The discriminant and the discriminant\n+   values are inferred from these attributes.\n+\n+   In trees, the offsets for the fields inside these sub-records are relative\n+   to the variant part itself, whereas the corresponding DIEs should have\n+   offset attributes that are relative to the embedding record base address.\n+   This is why the caller must provide a VARIANT_PART_OFFSET expression: it\n+   must be an expression that computes the offset of the variant part to\n+   describe in DWARF.  */\n+\n+static void\n+gen_variant_part (tree variant_part_decl, struct vlr_context *vlr_ctx,\n+\t\t  dw_die_ref context_die)\n+{\n+  const tree variant_part_type = TREE_TYPE (variant_part_decl);\n+  tree variant_part_offset = vlr_ctx->variant_part_offset;\n+  struct loc_descr_context ctx = {\n+    vlr_ctx->struct_type, /* context_type */\n+    NULL_TREE,\t\t  /* base_decl */\n+    NULL\t\t  /* dpi */\n+  };\n+\n+  /* The FIELD_DECL node in STRUCT_TYPE that acts as the discriminant, or\n+     NULL_TREE if there is no such field.  */\n+  tree discr_decl = NULL_TREE;\n+  dw_discr_list_ref *discr_lists;\n+  unsigned discr_lists_length = 0;\n+  unsigned i;\n+\n+  dw_die_ref dwarf_proc_die = NULL;\n+  dw_die_ref variant_part_die\n+    = new_die (DW_TAG_variant_part, context_die, variant_part_type);\n+\n+  equate_decl_number_to_die (variant_part_decl, variant_part_die);\n+\n+  analyze_variants_discr (variant_part_decl, vlr_ctx->struct_type,\n+\t\t\t  &discr_decl, &discr_lists, &discr_lists_length);\n+\n+  if (discr_decl != NULL_TREE)\n+    {\n+      dw_die_ref discr_die = lookup_decl_die (discr_decl);\n+\n+      if (discr_die)\n+\tadd_AT_die_ref (variant_part_die, DW_AT_discr, discr_die);\n+      else\n+\t/* We have no DIE for the discriminant, so just discard all\n+\t   discrimimant information in the output.  */\n+\tdiscr_decl = NULL_TREE;\n+    }\n+\n+  /* If the offset for this variant part is more complex than a constant,\n+     create a DWARF procedure for it so that we will not have to generate DWARF\n+     expressions for it for each member.  */\n+  if (TREE_CODE (variant_part_offset) != INTEGER_CST\n+      && (dwarf_version >= 3 || !dwarf_strict))\n+    {\n+      const tree dwarf_proc_fndecl\n+        = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL, NULL_TREE,\n+\t\t      build_function_type (TREE_TYPE (variant_part_offset),\n+\t\t\t\t\t   NULL_TREE));\n+      const tree dwarf_proc_call = build_call_expr (dwarf_proc_fndecl, 0);\n+      const dw_loc_descr_ref dwarf_proc_body\n+        = loc_descriptor_from_tree (variant_part_offset, 0, &ctx);\n+\n+      dwarf_proc_die = new_dwarf_proc_die (dwarf_proc_body,\n+\t\t\t\t\t   dwarf_proc_fndecl, context_die);\n+      if (dwarf_proc_die != NULL)\n+\tvariant_part_offset = dwarf_proc_call;\n+    }\n+\n+  /* Output DIEs for all variants.  */\n+  i = 0;\n+  for (tree variant = TYPE_FIELDS (variant_part_type);\n+       variant != NULL_TREE;\n+       variant = DECL_CHAIN (variant), ++i)\n+    {\n+      tree variant_type = TREE_TYPE (variant);\n+      dw_die_ref variant_die;\n+\n+      /* All variants (i.e. members of a variant part) are supposed to be\n+\t encoded as structures.  Sub-variant parts are QUAL_UNION_TYPE fields\n+\t under these records.  */\n+      gcc_assert (TREE_CODE (variant_type) == RECORD_TYPE);\n+\n+      variant_die = new_die (DW_TAG_variant, variant_part_die, variant_type);\n+      equate_decl_number_to_die (variant, variant_die);\n+\n+      /* Output discriminant values this variant matches, if any.  */\n+      if (discr_decl == NULL || discr_lists[i] == NULL)\n+\t/* In the case we have discriminant information at all, this is\n+\t   probably the default variant: as the standard says, don't\n+\t   output any discriminant value/list attribute.  */\n+\t;\n+      else if (discr_lists[i]->dw_discr_next == NULL\n+\t       && !discr_lists[i]->dw_discr_range)\n+\t/* If there is only one accepted value, don't bother outputting a\n+\t   list.  */\n+\tadd_discr_value (variant_die, &discr_lists[i]->dw_discr_lower_bound);\n+      else\n+\tadd_discr_list (variant_die, discr_lists[i]);\n+\n+      for (tree member = TYPE_FIELDS (variant_type);\n+\t   member != NULL_TREE;\n+\t   member = DECL_CHAIN (member))\n+\t{\n+\t  struct vlr_context vlr_sub_ctx = {\n+\t    vlr_ctx->struct_type, /* struct_type */\n+\t    NULL\t\t  /* variant_part_offset */\n+\t  };\n+\t  if (is_variant_part (member))\n+\t    {\n+\t      /* All offsets for fields inside variant parts are relative to\n+\t\t the top-level embedding RECORD_TYPE's base address.  On the\n+\t\t other hand, offsets in GCC's types are relative to the\n+\t\t nested-most variant part.  So we have to sum offsets each time\n+\t\t we recurse.  */\n+\n+\t      vlr_sub_ctx.variant_part_offset\n+\t        = fold (build2 (PLUS_EXPR, TREE_TYPE (variant_part_offset),\n+\t\t\t\tvariant_part_offset, byte_position (member)));\n+\t      gen_variant_part (member, &vlr_sub_ctx, variant_die);\n+\t    }\n+\t  else\n+\t    {\n+\t      vlr_sub_ctx.variant_part_offset = variant_part_offset;\n+\t      gen_decl_die (member, NULL, &vlr_sub_ctx, variant_die);\n+\t    }\n+\t}\n+    }\n+\n+  free (discr_lists);\n+}\n+\n /* Generate a DIE for a class member.  */\n \n static void\n@@ -20413,12 +22070,15 @@ gen_member_die (tree type, dw_die_ref context_die)\n       for (i = 0; BINFO_BASE_ITERATE (binfo, i, base); i++)\n \tgen_inheritance_die (base,\n \t\t\t     (accesses ? (*accesses)[i] : access_public_node),\n+\t\t\t     type,\n \t\t\t     context_die);\n     }\n \n   /* Now output info about the data members and type members.  */\n   for (member = TYPE_FIELDS (type); member; member = DECL_CHAIN (member))\n     {\n+      struct vlr_context vlr_ctx = { type, NULL_TREE };\n+\n       /* If we thought we were generating minimal debug info for TYPE\n \t and then changed our minds, some of the member declarations\n \t may have already been defined.  Don't define them again, but\n@@ -20427,8 +22087,21 @@ gen_member_die (tree type, dw_die_ref context_die)\n       child = lookup_decl_die (member);\n       if (child)\n \tsplice_child_die (context_die, child);\n+\n+      /* Do not generate standard DWARF for variant parts if we are generating\n+\t the corresponding GNAT encodings: DIEs generated for both would\n+\t conflict in our mappings.  */\n+      else if (is_variant_part (member)\n+\t       && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t{\n+\t  vlr_ctx.variant_part_offset = byte_position (member);\n+\t  gen_variant_part (member, &vlr_ctx, context_die);\n+\t}\n       else\n-\tgen_decl_die (member, NULL, context_die);\n+\t{\n+\t  vlr_ctx.variant_part_offset = NULL_TREE;\n+\t  gen_decl_die (member, NULL, &vlr_ctx, context_die);\n+\t}\n     }\n \n   /* We do not keep type methods in type variants.  */\n@@ -20449,7 +22122,7 @@ gen_member_die (tree type, dw_die_ref context_die)\n \tif (child)\n \t  splice_child_die (context_die, child);\n \telse\n-\t  gen_decl_die (member, NULL, context_die);\n+\t  gen_decl_die (member, NULL, NULL, context_die);\n       }\n }\n \n@@ -20783,7 +22456,7 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n \n       TREE_ASM_WRITTEN (type) = 1;\n \n-      gen_decl_die (TYPE_NAME (type), NULL, context_die);\n+      gen_decl_die (TYPE_NAME (type), NULL, NULL, context_die);\n       return;\n     }\n \n@@ -20796,8 +22469,8 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n       if (DECL_CONTEXT (TYPE_NAME (type))\n \t  && TREE_CODE (DECL_CONTEXT (TYPE_NAME (type))) == NAMESPACE_DECL)\n \tcontext_die = get_context_die (DECL_CONTEXT (TYPE_NAME (type)));\n-      \n-      gen_decl_die (TYPE_NAME (type), NULL, context_die);\n+\n+      gen_decl_die (TYPE_NAME (type), NULL, NULL, context_die);\n       return;\n     }\n \n@@ -21072,7 +22745,7 @@ process_scope_var (tree stmt, tree decl, tree origin, dw_die_ref context_die)\n \t\t\t\t\t     stmt, context_die);\n     }\n   else\n-    gen_decl_die (decl, origin, context_die);\n+    gen_decl_die (decl, origin, NULL, context_die);\n }\n \n /* Generate all of the decls declared within a given scope and (recursively)\n@@ -21238,7 +22911,7 @@ force_decl_die (tree decl)\n \t   gen_decl_die() call.  */\n \t  saved_external_flag = DECL_EXTERNAL (decl);\n \t  DECL_EXTERNAL (decl) = 1;\n-\t  gen_decl_die (decl, NULL, context_die);\n+\t  gen_decl_die (decl, NULL, NULL, context_die);\n \t  DECL_EXTERNAL (decl) = saved_external_flag;\n \t  break;\n \n@@ -21351,7 +23024,7 @@ declare_in_namespace (tree thing, dw_die_ref context_die)\n       if (is_fortran ())\n \treturn ns_context;\n       if (DECL_P (thing))\n-\tgen_decl_die (thing, NULL, ns_context);\n+\tgen_decl_die (thing, NULL, NULL, ns_context);\n       else\n \tgen_type_die (thing, ns_context);\n     }\n@@ -21411,10 +23084,14 @@ gen_namespace_die (tree decl, dw_die_ref context_die)\n \n /* Generate Dwarf debug information for a decl described by DECL.\n    The return value is currently only meaningful for PARM_DECLs,\n-   for all other decls it returns NULL.  */\n+   for all other decls it returns NULL.\n+\n+   If DECL is a FIELD_DECL, CTX is required: see the comment for VLR_CONTEXT.\n+   It can be NULL otherwise.  */\n \n static dw_die_ref\n-gen_decl_die (tree decl, tree origin, dw_die_ref context_die)\n+gen_decl_die (tree decl, tree origin, struct vlr_context *ctx,\n+\t      dw_die_ref context_die)\n {\n   tree decl_or_origin = decl ? decl : origin;\n   tree class_origin = NULL, ultimate_origin;\n@@ -21585,14 +23262,15 @@ gen_decl_die (tree decl, tree origin, dw_die_ref context_die)\n       break;\n \n     case FIELD_DECL:\n+      gcc_assert (ctx != NULL && ctx->struct_type != NULL);\n       /* Ignore the nameless fields that are used to skip bits but handle C++\n \t anonymous unions and structs.  */\n       if (DECL_NAME (decl) != NULL_TREE\n \t  || TREE_CODE (TREE_TYPE (decl)) == UNION_TYPE\n \t  || TREE_CODE (TREE_TYPE (decl)) == RECORD_TYPE)\n \t{\n \t  gen_type_die (member_declared_type (decl), context_die);\n-\t  gen_field_die (decl, context_die);\n+\t  gen_field_die (decl, ctx, context_die);\n \t}\n       break;\n \n@@ -21996,7 +23674,7 @@ dwarf2out_decl (tree decl)\n       return;\n     }\n \n-  gen_decl_die (decl, NULL, context_die);\n+  gen_decl_die (decl, NULL, NULL, context_die);\n \n   if (flag_checking)\n     {\n@@ -22530,6 +24208,16 @@ dwarf2out_var_location (rtx_insn *loc_note)\n   last_in_cold_section_p = in_cold_section_p;\n }\n \n+/* Called from finalize_size_functions for size functions so that their body\n+   can be encoded in the debug info to describe the layout of variable-length\n+   structures.  */\n+\n+static void\n+dwarf2out_size_function (tree decl)\n+{\n+  function_to_dwarf_procedure (decl);\n+}\n+\n /* Note in one location list that text section has changed.  */\n \n int\n@@ -23356,6 +25044,9 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n   /* Zero-th entry is allocated, but unused.  */\n   abbrev_die_table_in_use = 1;\n \n+  /* Allocate the dwarf_proc_stack_usage_map.  */\n+  dwarf_proc_stack_usage_map = new hash_map<dw_die_ref, int>;\n+\n   /* Allocate the pubtypes and pubnames vectors.  */\n   vec_alloc (pubname_table, 32);\n   vec_alloc (pubtype_table, 32);\n@@ -23665,6 +25356,25 @@ prune_unmark_dies (dw_die_ref die)\n   FOR_EACH_CHILD (die, c, prune_unmark_dies (c));\n }\n \n+/* Given LOC that is referenced by a DIE we're marking as used, find all\n+   referenced DWARF procedures it references and mark them as used.  */\n+\n+static void\n+prune_unused_types_walk_loc_descr (dw_loc_descr_ref loc)\n+{\n+  for (; loc != NULL; loc = loc->dw_loc_next)\n+    switch (loc->dw_loc_opc)\n+      {\n+      case DW_OP_call2:\n+      case DW_OP_call4:\n+      case DW_OP_call_ref:\n+\tprune_unused_types_mark (loc->dw_loc_oprnd1.v.val_die_ref.die, 1);\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n+}\n+\n /* Given DIE that we're marking as used, find any other dies\n    it references as attributes and mark them as used.  */\n \n@@ -23676,19 +25386,38 @@ prune_unused_types_walk_attribs (dw_die_ref die)\n \n   FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     {\n-      if (a->dw_attr_val.val_class == dw_val_class_die_ref)\n+      switch (AT_class (a))\n \t{\n+\t/* Make sure DWARF procedures referenced by location descriptions will\n+\t   get emitted.  */\n+\tcase dw_val_class_loc:\n+\t  prune_unused_types_walk_loc_descr (AT_loc (a));\n+\t  break;\n+\tcase dw_val_class_loc_list:\n+\t  for (dw_loc_list_ref list = AT_loc_list (a);\n+\t       list != NULL;\n+\t       list = list->dw_loc_next)\n+\t    prune_unused_types_walk_loc_descr (list->expr);\n+\t  break;\n+\n+\tcase dw_val_class_die_ref:\n \t  /* A reference to another DIE.\n \t     Make sure that it will get emitted.\n \t     If it was broken out into a comdat group, don't follow it.  */\n           if (! AT_ref (a)->comdat_type_p\n               || a->dw_attr == DW_AT_specification)\n \t    prune_unused_types_mark (a->dw_attr_val.v.val_die_ref.die, 1);\n+\t  break;\n+\n+\tcase dw_val_class_str:\n+\t  /* Set the string's refcount to 0 so that prune_unused_types_mark\n+\t     accounts properly for it.  */\n+\t  a->dw_attr_val.v.val_str->refcount = 0;\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n \t}\n-      /* Set the string's refcount to 0 so that prune_unused_types_mark\n-\t accounts properly for it.  */\n-      if (AT_class (a) == dw_val_class_str)\n-\ta->dw_attr_val.v.val_str->refcount = 0;\n     }\n }\n \n@@ -23839,18 +25568,23 @@ prune_unused_types_walk (dw_die_ref die)\n     case DW_TAG_array_type:\n     case DW_TAG_interface_type:\n     case DW_TAG_friend:\n-    case DW_TAG_variant_part:\n     case DW_TAG_enumeration_type:\n     case DW_TAG_subroutine_type:\n     case DW_TAG_string_type:\n     case DW_TAG_set_type:\n     case DW_TAG_subrange_type:\n     case DW_TAG_ptr_to_member_type:\n     case DW_TAG_file_type:\n+      /* Type nodes are useful only when other DIEs reference them --- don't\n+\t mark them.  */\n+      /* FALLTHROUGH */\n+\n+    case DW_TAG_dwarf_procedure:\n+      /* Likewise for DWARF procedures.  */\n+\n       if (die->die_perennial_p)\n \tbreak;\n \n-      /* It's a type node --- don't mark it.  */\n       return;\n \n     default:\n@@ -25737,6 +27471,8 @@ dwarf2out_c_finalize (void)\n   abbrev_die_table = NULL;\n   abbrev_die_table_allocated = 0;\n   abbrev_die_table_in_use = 0;\n+  delete dwarf_proc_stack_usage_map;\n+  dwarf_proc_stack_usage_map = NULL;\n   line_info_label_num = 0;\n   cur_line_info_table = NULL;\n   text_section_line_info = NULL;"}, {"sha": "4303e60b55f49c0812ab7eebb63fb292390c7cbc", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=986ccd2171a7fd8e7d221c2d0b49aad844da836f", "patch": "@@ -29,6 +29,7 @@ typedef struct dw_val_node *dw_val_ref;\n typedef struct dw_cfi_node *dw_cfi_ref;\n typedef struct dw_loc_descr_node *dw_loc_descr_ref;\n typedef struct dw_loc_list_struct *dw_loc_list_ref;\n+typedef struct dw_discr_list_node *dw_discr_list_ref;\n typedef wide_int *wide_int_ptr;\n \n \n@@ -150,7 +151,9 @@ enum dw_val_class\n   dw_val_class_data8,\n   dw_val_class_decl_ref,\n   dw_val_class_vms_delta,\n-  dw_val_class_high_pc\n+  dw_val_class_high_pc,\n+  dw_val_class_discr_value,\n+  dw_val_class_discr_list\n };\n \n /* Describe a floating point constant value, or a vector constant value.  */\n@@ -161,6 +164,25 @@ struct GTY(()) dw_vec_const {\n   unsigned elt_size;\n };\n \n+/* Describe a single value that a discriminant can match.\n+\n+   Discriminants (in the \"record variant part\" meaning) are scalars.\n+   dw_discr_list_ref and dw_discr_value are a mean to describe a set of\n+   discriminant values that are matched by a particular variant.\n+\n+   Discriminants can be signed or unsigned scalars, and can be discriminants\n+   values.  Both have to be consistent, though.  */\n+\n+struct GTY(()) dw_discr_value {\n+  int pos; /* Whether the discriminant value is positive (unsigned).  */\n+  union\n+    {\n+      HOST_WIDE_INT GTY ((tag (\"0\"))) sval;\n+      unsigned HOST_WIDE_INT GTY ((tag (\"1\"))) uval;\n+    }\n+  GTY ((desc (\"%1.pos\"))) v;\n+};\n+\n struct addr_table_entry;\n \n /* The dw_val_node describes an attribute's value, as it is\n@@ -197,6 +219,8 @@ struct GTY(()) dw_val_node {\n \t  char * lbl1;\n \t  char * lbl2;\n \t} GTY ((tag (\"dw_val_class_vms_delta\"))) val_vms_delta;\n+      dw_discr_value GTY ((tag (\"dw_val_class_discr_value\"))) val_discr_value;\n+      dw_discr_list_ref GTY ((tag (\"dw_val_class_discr_list\"))) val_discr_list;\n     }\n   GTY ((desc (\"%1.val_class\"))) v;\n };\n@@ -210,11 +234,35 @@ struct GTY((chain_next (\"%h.dw_loc_next\"))) dw_loc_descr_node {\n   /* Used to distinguish DW_OP_addr with a direct symbol relocation\n      from DW_OP_addr with a dtp-relative symbol relocation.  */\n   unsigned int dtprel : 1;\n+  /* For DW_OP_pick operations: true iff. it targets a DWARF prodecure\n+     argument.  In this case, it needs to be relocated according to the current\n+     frame offset.  */\n+  unsigned int frame_offset_rel : 1;\n   int dw_loc_addr;\n+#if ENABLE_CHECKING\n+  /* When translating a function into a DWARF procedure, contains the frame\n+     offset *before* evaluating this operation.  It is -1 when not yet\n+     initialized.  */\n+  int dw_loc_frame_offset;\n+#endif\n   dw_val_node dw_loc_oprnd1;\n   dw_val_node dw_loc_oprnd2;\n };\n \n+/* A variant (inside a record variant part) is selected when the corresponding\n+   discriminant matches its set of values (see the comment for dw_discr_value).\n+   The following datastructure holds such matching information.  */\n+\n+struct GTY(()) dw_discr_list_node {\n+  dw_discr_list_ref dw_discr_next;\n+\n+  dw_discr_value dw_discr_lower_bound;\n+  dw_discr_value dw_discr_upper_bound;\n+  /* This node represents only the value in dw_discr_lower_bound when it's\n+     zero.  It represents the range between the two fields (bounds included)\n+     otherwise.  */\n+  int dw_discr_range;\n+};\n \n /* Interface from dwarf2out.c to dwarf2cfi.c.  */\n extern struct dw_loc_descr_node *build_cfa_loc"}, {"sha": "06fd818fbefe90572af9053b98db1f1066ea9c2b", "filename": "gcc/sdbout.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=986ccd2171a7fd8e7d221c2d0b49aad844da836f", "patch": "@@ -304,6 +304,7 @@ const struct gcc_debug_hooks sdb_debug_hooks =\n   sdbout_label,\t\t\t         /* label */\n   debug_nothing_int,\t\t         /* handle_pch */\n   debug_nothing_rtx_insn,\t         /* var_location */\n+  debug_nothing_tree,\t\t\t /* size_function */\n   debug_nothing_void,                    /* switch_text_section */\n   debug_nothing_tree_tree,\t\t /* set_name */\n   0,                                     /* start_end_main_source_file */"}, {"sha": "6b0fbc6874c7e33863f54a9a7aa4c92027328b4f", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=986ccd2171a7fd8e7d221c2d0b49aad844da836f", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-inline.h\"\n #include \"tree-dump.h\"\n #include \"gimplify.h\"\n+#include \"debug.h\"\n \n /* Data type for the expressions representing sizes of data types.\n    It is the first integer type laid out.  */\n@@ -292,6 +293,10 @@ finalize_size_functions (void)\n       allocate_struct_function (fndecl, false);\n       set_cfun (NULL);\n       dump_function (TDI_original, fndecl);\n+\n+      /* As these functions are used to describe the layout of variable-length\n+         structures, debug info generation needs their implementation.  */\n+      debug_hooks->size_function (fndecl);\n       gimplify_function_tree (fndecl);\n       cgraph_node::finalize_function (fndecl, false);\n     }"}, {"sha": "4dba47141f3b42405fffe37757b1ed1cd845a57c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=986ccd2171a7fd8e7d221c2d0b49aad844da836f", "patch": "@@ -1,3 +1,8 @@\n+2015-12-17  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* gnat.dg/specs/debug1.ads: Update the expected number of\n+\tDW_AT_artificial attribute in compiler output.\n+\n 2015-12-17  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/68835"}, {"sha": "92e9184e473b65da124bee16a896a3ee218b1a05", "filename": "gcc/testsuite/gnat.dg/specs/debug1.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fdebug1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fdebug1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fdebug1.ads?ref=986ccd2171a7fd8e7d221c2d0b49aad844da836f", "patch": "@@ -11,4 +11,4 @@ package Debug1 is\n \n end Debug1;\n \n--- { dg-final { scan-assembler-times \"DW_AT_artificial\" 15 } }\n+-- { dg-final { scan-assembler-times \"DW_AT_artificial\" 17 } }"}, {"sha": "87cc8b26126b9c4b024377c8dcf575081c496d95", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/986ccd2171a7fd8e7d221c2d0b49aad844da836f/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=986ccd2171a7fd8e7d221c2d0b49aad844da836f", "patch": "@@ -201,6 +201,7 @@ const struct gcc_debug_hooks vmsdbg_debug_hooks\n    debug_nothing_rtx_code_label,  /* label */\n    debug_nothing_int,\t\t  /* handle_pch */\n    debug_nothing_rtx_insn,\t  /* var_location */\n+   debug_nothing_tree,\t\t  /* size_function */\n    debug_nothing_void,            /* switch_text_section */\n    debug_nothing_tree_tree,\t  /* set_name */\n    0,                             /* start_end_main_source_file */"}]}