{"sha": "8575023cdc36ca4647811302e329a64e2df81634", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU3NTAyM2NkYzM2Y2E0NjQ3ODExMzAyZTMyOWE2NGUyZGY4MTYzNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T08:11:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T08:11:06Z"}, "message": "[multiple changes]\n\n2014-08-04  Thomas Quinot  <quinot@adacore.com>\n\n\t* s-fatgen.ads, s-fatgen.adb (S, P): New visible type declarations\n\t(Unaligned_Valid): Remove now unused subprogram.\n\t* exp_attr.adb (Expand_N_Attribute_Reference, case\n\tAttribute_Valid): If the prefix is in reverse SSO or potentially\n\tunaligned, copy it using a byte copy operation to a temporary\n\tvariable.\n\t* einfo.adb: Minor comment fix.\n\n2014-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* freeze.adb (Freeze_Entity): Do not freeze formal subprograms.\n\nFrom-SVN: r213540", "tree": {"sha": "d5e9d4f4cf07bc195919c93c8bf9847eb413ac21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5e9d4f4cf07bc195919c93c8bf9847eb413ac21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8575023cdc36ca4647811302e329a64e2df81634", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8575023cdc36ca4647811302e329a64e2df81634", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8575023cdc36ca4647811302e329a64e2df81634", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8575023cdc36ca4647811302e329a64e2df81634/comments", "author": null, "committer": null, "parents": [{"sha": "8616baee3a59d28336a2012b539fad1f720cc4dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8616baee3a59d28336a2012b539fad1f720cc4dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8616baee3a59d28336a2012b539fad1f720cc4dc"}], "stats": {"total": 194, "additions": 120, "deletions": 74}, "files": [{"sha": "b7c71fd4796b9246371490fcc12e5dff0d24c980", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8575023cdc36ca4647811302e329a64e2df81634/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8575023cdc36ca4647811302e329a64e2df81634/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8575023cdc36ca4647811302e329a64e2df81634", "patch": "@@ -1,3 +1,17 @@\n+2014-08-04  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* s-fatgen.ads, s-fatgen.adb (S, P): New visible type declarations\n+\t(Unaligned_Valid): Remove now unused subprogram.\n+\t* exp_attr.adb (Expand_N_Attribute_Reference, case\n+\tAttribute_Valid): If the prefix is in reverse SSO or potentially\n+\tunaligned, copy it using a byte copy operation to a temporary\n+\tvariable.\n+\t* einfo.adb: Minor comment fix.\n+\n+2014-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* freeze.adb (Freeze_Entity): Do not freeze formal subprograms.\n+\n 2014-08-04  Robert Dewar  <dewar@adacore.com>\n \n \t* s-imgrea.adb (Image_Floating_Point): Don't add space before +Inf."}, {"sha": "631ddc76c588e938ae2e08546b32b88b2d4b9938", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8575023cdc36ca4647811302e329a64e2df81634/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8575023cdc36ca4647811302e329a64e2df81634/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=8575023cdc36ca4647811302e329a64e2df81634", "patch": "@@ -563,7 +563,7 @@ package body Einfo is\n \n    --    (Has_Protected)                 Flag271\n    --    (SSO_Set_Low_By_Default)        Flag272\n-   --    (SSO_Set_Low_By_Default)        Flag273\n+   --    (SSO_Set_High_By_Default)       Flag273\n \n    --    Is_Generic_Actual_Subprogram    Flag274\n    --    No_Predicate_On_Actual          Flag275"}, {"sha": "f67220b61e2d2698db376294ff5d410f50c970c8", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 87, "deletions": 27, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8575023cdc36ca4647811302e329a64e2df81634/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8575023cdc36ca4647811302e329a64e2df81634/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=8575023cdc36ca4647811302e329a64e2df81634", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n@@ -6406,6 +6407,23 @@ package body Exp_Attr is\n                Pkg : RE_Id;\n                Ftp : Entity_Id;\n \n+               function Get_Fat_Entity (Nam : Name_Id) return Entity_Id;\n+               --  Return entity for Pkg.Nam\n+\n+               --------------------\n+               -- Get_Fat_Entity --\n+               --------------------\n+\n+               function Get_Fat_Entity (Nam : Name_Id) return Entity_Id is\n+                  Exp_Name : constant Node_Id :=\n+                    Make_Selected_Component (Loc,\n+                      Prefix        => New_Occurrence_Of (RTE (Pkg), Loc),\n+                      Selector_Name => Make_Identifier (Loc, Nam));\n+               begin\n+                  Find_Selected_Component (Exp_Name);\n+                  return Entity (Exp_Name);\n+               end Get_Fat_Entity;\n+\n             begin\n                case Float_Rep (Btyp) is\n \n@@ -6419,34 +6437,76 @@ package body Exp_Attr is\n                   when IEEE_Binary =>\n                      Find_Fat_Info (Ptyp, Ftp, Pkg);\n \n-                     --  If the floating-point object might be unaligned, we\n-                     --  need to call the special routine Unaligned_Valid,\n-                     --  which makes the needed copy, being careful not to\n-                     --  load the value into any floating-point register.\n-                     --  The argument in this case is obj'Address (see\n-                     --  Unaligned_Valid routine in Fat_Gen).\n-\n-                     if Is_Possibly_Unaligned_Object (Pref) then\n-                        Expand_Fpt_Attribute\n-                          (N, Pkg, Name_Unaligned_Valid,\n-                           New_List (\n-                             Make_Attribute_Reference (Loc,\n-                               Prefix => Relocate_Node (Pref),\n-                               Attribute_Name => Name_Address)));\n-\n-                     --  In the normal case where we are sure the object is\n-                     --  aligned, we generate a call to Valid, and the argument\n-                     --  in this case is obj'Unrestricted_Access (after\n-                     --  converting obj to the right floating-point type).\n+                     --  If the prefix is a reverse SSO component, or is\n+                     --  possibly unaligned, first create a temporary copy\n+                     --  that is in native SSO, and properly aligned. Make it\n+                     --  Volatile to prevent folding in the back-end. Note\n+                     --  that we use an intermediate constrained string type\n+                     --  to initialize the temporary, as the value at hand\n+                     --  might be invalid, and in that case it cannot be copied\n+                     --  using a floating point register.\n+\n+                     if In_Reverse_Storage_Order_Object (Pref)\n+                          or else\n+                        Is_Possibly_Unaligned_Object (Pref)\n+                     then\n+                        declare\n+                           Temp : constant Entity_Id :=\n+                                    Make_Temporary (Loc, 'F');\n \n-                     else\n-                        Expand_Fpt_Attribute\n-                          (N, Pkg, Name_Valid,\n-                           New_List (\n-                             Make_Attribute_Reference (Loc,\n-                               Prefix => Unchecked_Convert_To (Ftp, Pref),\n-                               Attribute_Name => Name_Unrestricted_Access)));\n+                           Fat_S : constant Entity_Id :=\n+                                     Get_Fat_Entity (Name_S);\n+                           --  Constrained string subtype of appropriate size\n+\n+                           Fat_P : constant Entity_Id :=\n+                                     Get_Fat_Entity (Name_P);\n+                           --  Access to Fat_S\n+\n+                           Decl : constant Node_Id :=\n+                             Make_Object_Declaration (Loc,\n+                               Defining_Identifier => Temp,\n+                               Aliased_Present     => True,\n+                               Object_Definition   =>\n+                                 New_Occurrence_Of (Ptyp, Loc));\n+\n+                        begin\n+                           Set_Aspect_Specifications (Decl, New_List (\n+                             Make_Aspect_Specification (Loc,\n+                               Identifier =>\n+                                 Make_Identifier (Loc, Name_Volatile))));\n+\n+                           Insert_Actions (N,\n+                             New_List (\n+                               Decl,\n+\n+                               Make_Assignment_Statement (Loc,\n+                                 Name =>\n+                                   Make_Explicit_Dereference (Loc,\n+                                     Prefix =>\n+                                       Unchecked_Convert_To (Fat_P,\n+                                         Make_Attribute_Reference (Loc,\n+                                           Prefix =>\n+                                             New_Occurrence_Of (Temp, Loc),\n+                                           Attribute_Name =>\n+                                             Name_Unrestricted_Access))),\n+                                 Expression =>\n+                                   Unchecked_Convert_To (Fat_S,\n+                                     Relocate_Node (Pref)))),\n+                             Suppress => All_Checks);\n+\n+                           Rewrite (Pref, New_Occurrence_Of (Temp, Loc));\n+                        end;\n                      end if;\n+\n+                     --  We now have an object of the proper endianness and\n+                     --  alignment, and can call the Valid runtime routine.\n+\n+                     Expand_Fpt_Attribute\n+                       (N, Pkg, Name_Valid,\n+                        New_List (\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix => Unchecked_Convert_To (Ftp, Pref),\n+                            Attribute_Name => Name_Unrestricted_Access)));\n                end case;\n \n                --  One more task, we still need a range check. Required\n@@ -6462,7 +6522,7 @@ package body Exp_Attr is\n                       Left_Opnd  => Relocate_Node (N),\n                       Right_Opnd =>\n                         Make_In (Loc,\n-                          Left_Opnd => Convert_To (Btyp, Pref),\n+                          Left_Opnd  => Convert_To (Btyp, Pref),\n                           Right_Opnd => New_Occurrence_Of (Ptyp, Loc))));\n                end if;\n             end;"}, {"sha": "971bc39d2e0a961d25b4ddf19a55989c365fa31c", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8575023cdc36ca4647811302e329a64e2df81634/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8575023cdc36ca4647811302e329a64e2df81634/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=8575023cdc36ca4647811302e329a64e2df81634", "patch": "@@ -3818,8 +3818,12 @@ package body Freeze is\n       then\n          return No_List;\n \n-      --  Generic types need no freeze node and have no delayed semantic\n-      --  checks.\n+      --  Formal subprograms are never frozen\n+\n+      elsif Is_Formal_Subprogram (E) then\n+         return No_List;\n+\n+      --  Generic types are never frozen as they lack delayed semantic checks\n \n       elsif Is_Generic_Type (E) then\n          return No_List;"}, {"sha": "62534f67c38ca225f4f33c1148c4ea6b173a1185", "filename": "gcc/ada/s-fatgen.adb", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8575023cdc36ca4647811302e329a64e2df81634/gcc%2Fada%2Fs-fatgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8575023cdc36ca4647811302e329a64e2df81634/gcc%2Fada%2Fs-fatgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fatgen.adb?ref=8575023cdc36ca4647811302e329a64e2df81634", "patch": "@@ -918,30 +918,4 @@ package body System.Fat_Gen is\n          ((E = IEEE_Emin - 1) and then abs To_Float (SR) = 1.0);\n    end Valid;\n \n-   ---------------------\n-   -- Unaligned_Valid --\n-   ---------------------\n-\n-   function Unaligned_Valid (A : System.Address) return Boolean is\n-      subtype FS is String (1 .. T'Size / Character'Size);\n-      type FSP is access FS;\n-\n-      function To_FSP is new Ada.Unchecked_Conversion (Address, FSP);\n-\n-      Local_T : aliased T;\n-\n-   begin\n-      --  Note that we have to be sure that we do not load the value into a\n-      --  floating-point register, since a signalling NaN may cause a trap.\n-      --  The following assignment is what does the actual alignment, since\n-      --  we know that the target Local_T is aligned.\n-\n-      To_FSP (Local_T'Address).all := To_FSP (A).all;\n-\n-      --  Now that we have an aligned value, we can use the normal aligned\n-      --  version of Valid to obtain the required result.\n-\n-      return Valid (Local_T'Access);\n-   end Unaligned_Valid;\n-\n end System.Fat_Gen;"}, {"sha": "d8d761eaaedbab9bb83d95cbed217bbb166d8c41", "filename": "gcc/ada/s-fatgen.ads", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8575023cdc36ca4647811302e329a64e2df81634/gcc%2Fada%2Fs-fatgen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8575023cdc36ca4647811302e329a64e2df81634/gcc%2Fada%2Fs-fatgen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fatgen.ads?ref=8575023cdc36ca4647811302e329a64e2df81634", "patch": "@@ -94,24 +94,18 @@ package System.Fat_Gen is\n    --  be an abnormal value that cannot be passed in a floating-point\n    --  register, and the whole point of 'Valid is to prevent exceptions.\n    --  Note that the object of type T must have the natural alignment\n-   --  for type T. See Unaligned_Valid for further discussion.\n-\n-   function Unaligned_Valid (A : System.Address) return Boolean;\n-   --  This version of Valid is used if the floating-point value to\n-   --  be checked is not known to be aligned (for example it appears\n-   --  in a packed record). In this case, we cannot call Valid since\n-   --  Valid assumes proper full alignment. Instead Unaligned_Valid\n-   --  performs the same processing for a possibly unaligned float,\n-   --  by first doing a copy and then calling Valid. One might think\n-   --  that the front end could simply do a copy to an aligned temp,\n-   --  but remember that we may have an abnormal value that cannot\n-   --  be copied into a floating-point register, so things are a bit\n-   --  trickier than one might expect.\n-   --\n-   --  Note: Unaligned_Valid is never called for a target which does\n-   --  not require strict alignment (e.g. the ia32/x86), since on a\n-   --  target not requiring strict alignment, it is fine to pass a\n-   --  non-aligned value to the standard Valid routine.\n+   --  for type T.\n+\n+   type S is new String (1 .. T'Size / Character'Size);\n+   type P is access all S with Storage_Size => 0;\n+   --  Buffer and access types used to initialize temporaries for validity\n+   --  checks, if the value to be checked has reverse scalar storage order, or\n+   --  is not known to be properly aligned (for example it appears in a packed\n+   --  record). In this case, we cannot call Valid since Valid assumes proper\n+   --  full alignment. Instead, we copy the value to a temporary location using\n+   --  type S (we cannot simply do a copy of a T value, because the value might\n+   --  be invalid, in which case it might not be possible to copy it through a\n+   --  floating point register).\n \n private\n    pragma Inline (Machine);"}]}