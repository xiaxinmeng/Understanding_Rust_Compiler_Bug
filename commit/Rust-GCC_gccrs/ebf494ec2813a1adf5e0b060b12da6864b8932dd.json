{"sha": "ebf494ec2813a1adf5e0b060b12da6864b8932dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJmNDk0ZWMyODEzYTFhZGY1ZTBiMDYwYjEyZGE2ODY0Yjg5MzJkZA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2011-09-06T07:56:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-06T07:56:50Z"}, "message": "sem_util.adb, [...]: Minor reformatting and code reorganization.\n\n2011-09-06  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_util.adb, exp_ch6.adb: Minor reformatting and code reorganization.\n\nFrom-SVN: r178568", "tree": {"sha": "383b38c9178023ab3101640fcafeedeb63fb8bfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/383b38c9178023ab3101640fcafeedeb63fb8bfe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebf494ec2813a1adf5e0b060b12da6864b8932dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebf494ec2813a1adf5e0b060b12da6864b8932dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebf494ec2813a1adf5e0b060b12da6864b8932dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebf494ec2813a1adf5e0b060b12da6864b8932dd/comments", "author": null, "committer": null, "parents": [{"sha": "63585f754c2048b49f8e1607323f8f693e6649bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63585f754c2048b49f8e1607323f8f693e6649bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63585f754c2048b49f8e1607323f8f693e6649bf"}], "stats": {"total": 139, "additions": 83, "deletions": 56}, "files": [{"sha": "8d875b6de8d9819c783f15565e389ea7ad2ad878", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf494ec2813a1adf5e0b060b12da6864b8932dd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf494ec2813a1adf5e0b060b12da6864b8932dd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ebf494ec2813a1adf5e0b060b12da6864b8932dd", "patch": "@@ -1,3 +1,7 @@\n+2011-09-06  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_util.adb, exp_ch6.adb: Minor reformatting and code reorganization.\n+\n 2011-09-06  Steve Baird  <baird@adacore.com>\n \n \t* einfo.ads (Extra_Accessibility_Of_Result): New function; in the"}, {"sha": "7c9ce179aceb9b4846762994cd71375353b5cdd2", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 56, "deletions": 39, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf494ec2813a1adf5e0b060b12da6864b8932dd/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf494ec2813a1adf5e0b060b12da6864b8932dd/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=ebf494ec2813a1adf5e0b060b12da6864b8932dd", "patch": "@@ -2780,12 +2780,16 @@ package body Exp_Ch6 is\n \n             case Nkind (Ancestor) is\n                when N_Allocator =>\n-                  --  Messy.\n-                  --\n+\n+                  --  Messy code, could use a cleanup???\n+\n                   --  At this point, we'd like to assign\n+\n                   --    Level := Dynamic_Accessibility_Level (Ancestor);\n+\n                   --  but Etype of Ancestor may not have been set yet,\n                   --  so that doesn't work.\n+\n                   --  Handle this later in Expand_Allocator_Expression.\n \n                   Defer := True;\n@@ -2794,6 +2798,7 @@ package body Exp_Ch6 is\n                   declare\n                      Def_Id : constant Entity_Id :=\n                                 Defining_Identifier (Ancestor);\n+\n                   begin\n                      if Is_Return_Object (Def_Id) then\n                         if Present (Extra_Accessibility_Of_Result\n@@ -2806,17 +2811,19 @@ package body Exp_Ch6 is\n                            Level :=\n                              New_Occurrence_Of\n                               (Extra_Accessibility_Of_Result\n-                                 (Return_Applies_To (Scope (Def_Id))), Loc);\n+                                (Return_Applies_To (Scope (Def_Id))), Loc);\n                         end if;\n                      else\n-                        Level := Make_Integer_Literal (Loc,\n-                                   Object_Access_Level (Def_Id));\n+                        Level :=\n+                          Make_Integer_Literal (Loc,\n+                            Intval => Object_Access_Level (Def_Id));\n                      end if;\n                   end;\n \n                when N_Simple_Return_Statement =>\n                   if Present (Extra_Accessibility_Of_Result\n-                    (Return_Applies_To (Return_Statement_Entity (Ancestor))))\n+                               (Return_Applies_To\n+                                 (Return_Statement_Entity (Ancestor))))\n                   then\n                      --  Pass along value that was passed in if the routine\n                      --  we are returning from also has an\n@@ -2835,9 +2842,10 @@ package body Exp_Ch6 is\n \n             if not Defer then\n                if not Present (Level) then\n+\n                   --  The \"innermost master that evaluates the function call\".\n-                  --\n-                  --  ??? -  Shuld we use Integer'Last here instead\n+\n+                  --  ??? -  Shpuld we use Integer'Last here instead\n                   --  in order to deal with (some of) the problems\n                   --  associated with calls to subps whose enclosing\n                   --  scope is unknown (e.g., Anon_Access_To_Subp_Param.all)?\n@@ -6268,6 +6276,7 @@ package body Exp_Ch6 is\n             Next_Discriminant (Discr);\n          end loop;\n       end if;\n+\n       return False;\n    end Has_Unconstrained_Access_Discriminants;\n \n@@ -6715,16 +6724,19 @@ package body Exp_Ch6 is\n                    Make_Op_Ne (Loc,\n                      Left_Opnd  => Duplicate_Subexpr (Exp),\n                      Right_Opnd => Make_Null (Loc)),\n+\n                  Right_Opnd => Make_Op_Ne (Loc,\n                    Left_Opnd  =>\n                      Make_Selected_Component (Loc,\n                        Prefix        => Duplicate_Subexpr (Exp),\n                        Selector_Name => Make_Identifier (Loc, Name_uTag)),\n+\n                    Right_Opnd =>\n                      Make_Attribute_Reference (Loc,\n                        Prefix         =>\n                          New_Occurrence_Of (Designated_Type (R_Type), Loc),\n                        Attribute_Name => Name_Tag))),\n+\n              Reason    => CE_Tag_Check_Failed),\n              Suppress  => All_Checks);\n       end if;\n@@ -6737,11 +6749,11 @@ package body Exp_Ch6 is\n         and then Has_Unconstrained_Access_Discriminants (R_Type)\n       then\n          declare\n-            Discrim_Source : Node_Id := Exp;\n+            Discrim_Source : Node_Id;\n \n             procedure Check_Against_Result_Level (Level : Node_Id);\n-            --  Check the given accessibility level against the\n-            --  level determined by the point of call\" (AI05-0234).\n+            --  Check the given accessibility level against the level\n+            --  determined by the point of call. (AI05-0234).\n \n             --------------------------------\n             -- Check_Against_Result_Level --\n@@ -6759,15 +6771,16 @@ package body Exp_Ch6 is\n                            (Extra_Accessibility_Of_Result (Scope_Id), Loc)),\n                        Reason => PE_Accessibility_Check_Failed));\n             end Check_Against_Result_Level;\n+\n          begin\n+            Discrim_Source := Exp;\n             while Nkind (Discrim_Source) = N_Qualified_Expression loop\n                Discrim_Source := Expression (Discrim_Source);\n             end loop;\n \n             if Nkind (Discrim_Source) = N_Identifier\n               and then Is_Return_Object (Entity (Discrim_Source))\n             then\n-\n                Discrim_Source := Entity (Discrim_Source);\n \n                if Is_Constrained (Etype (Discrim_Source)) then\n@@ -6780,22 +6793,18 @@ package body Exp_Ch6 is\n               and then Nkind_In (Original_Node (Discrim_Source),\n                                  N_Aggregate, N_Extension_Aggregate)\n             then\n-\n                Discrim_Source := Original_Node (Discrim_Source);\n \n             elsif Nkind (Discrim_Source) = N_Explicit_Dereference and then\n               Nkind (Original_Node (Discrim_Source)) = N_Function_Call\n             then\n-\n                Discrim_Source := Original_Node (Discrim_Source);\n-\n             end if;\n \n             while Nkind_In (Discrim_Source, N_Qualified_Expression,\n                                             N_Type_Conversion,\n                                             N_Unchecked_Type_Conversion)\n             loop\n-\n                Discrim_Source := Expression (Discrim_Source);\n             end loop;\n \n@@ -8268,9 +8277,9 @@ package body Exp_Ch6 is\n       Func_Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n \n       function Has_Unconstrained_Access_Discriminant_Component\n-        (Comp_Typ :  Entity_Id) return Boolean;\n-      --  Returns True if any component of the type has\n-      --  an unconstrained access discriminant.\n+        (Comp_Typ : Entity_Id) return Boolean;\n+      --  Returns True if any component of the type has an unconstrained access\n+      --  discriminant.\n \n       -----------------------------------------------------\n       -- Has_Unconstrained_Access_Discriminant_Component --\n@@ -8282,6 +8291,7 @@ package body Exp_Ch6 is\n       begin\n          if not Is_Limited_Type (Comp_Typ) then\n             return False;\n+\n             --  Only limited types can have access discriminants with\n             --  defaults.\n \n@@ -8294,8 +8304,10 @@ package body Exp_Ch6 is\n \n          elsif Is_Record_Type (Comp_Typ) then\n             declare\n-               Comp : Entity_Id := First_Component (Comp_Typ);\n+               Comp : Entity_Id;\n+\n             begin\n+               Comp := First_Component (Comp_Typ);\n                while Present (Comp) loop\n                   if Has_Unconstrained_Access_Discriminant_Component\n                        (Underlying_Type (Etype (Comp)))\n@@ -8314,32 +8326,36 @@ package body Exp_Ch6 is\n    --  Start of processing for Needs_Result_Accessibility_Level\n \n    begin\n-      if not Present (Func_Typ) --  ??? completion unavailable\n+      --  False if completion unavailable (how does this happen???)\n+\n+      if not Present (Func_Typ) then\n+         return False;\n \n-        or else Func_Typ = Standard_Void_Type --  not a function\n+      --  False if not a function, also handle enum-lit renames case\n \n-        or else Is_Scalar_Type (Func_Typ) --  handle enum-lit renames\n+      elsif Func_Typ = Standard_Void_Type\n+        or else Is_Scalar_Type (Func_Typ)\n       then\n          return False;\n-      end if;\n \n-      if Present (Alias (Func_Id)) then\n-         --  Handle a corner case, a cross-dialect subp renaming. For example,\n-         --  an Ada2012 renaming of an Ada05 subprogram. This can occur when\n-         --  a non-Ada2012 unit references predefined runtime units.\n-         --\n+      --  Handle a corner case, a cross-dialect subp renaming. For example,\n+      --  an Ada2012 renaming of an Ada05 subprogram. This can occur when a\n+      --  non-Ada2012 unit references predefined runtime units.\n+\n+      elsif Present (Alias (Func_Id)) then\n+\n          --  Unimplemented: a cross-dialect subp renaming which does not set\n          --  the Alias attribute (e.g., a rename of a dereference of an access\n          --  to subprogram value).\n \n          return Present (Extra_Accessibility_Of_Result (Alias (Func_Id)));\n-      end if;\n \n-      if Ada_Version < Ada_2012 then\n+      --  Remaining cases require Ada 2012 mode\n+\n+      elsif Ada_Version < Ada_2012 then\n          return False;\n-      end if;\n \n-      if Ekind (Func_Typ) = E_Anonymous_Access_Type\n+      elsif Ekind (Func_Typ) = E_Anonymous_Access_Type\n         or else Is_Tagged_Type (Func_Typ)\n       then\n          --  In the case of, say, a null tagged record result type, the need\n@@ -8357,17 +8373,18 @@ package body Exp_Ch6 is\n          --  wrappers, but that is not the approach that was chosen.\n \n          return True;\n-      end if;\n \n-      if Has_Unconstrained_Access_Discriminants (Func_Typ) then\n+      elsif Has_Unconstrained_Access_Discriminants (Func_Typ) then\n          return True;\n-      end if;\n \n-      if Has_Unconstrained_Access_Discriminant_Component (Func_Typ) then\n+      elsif Has_Unconstrained_Access_Discriminant_Component (Func_Typ) then\n          return True;\n-      end if;\n \n-      return False;\n+      --  False for all other cases\n+\n+      else\n+         return False;\n+      end if;\n    end Needs_Result_Accessibility_Level;\n \n end Exp_Ch6;"}, {"sha": "f92eb0649965994503a8255ee901b5040aa38c30", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf494ec2813a1adf5e0b060b12da6864b8932dd/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf494ec2813a1adf5e0b060b12da6864b8932dd/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=ebf494ec2813a1adf5e0b060b12da6864b8932dd", "patch": "@@ -2880,20 +2880,22 @@ package body Sem_Util is\n       Loc : constant Source_Ptr := Sloc (Expr);\n \n       function Make_Level_Literal (Level : Uint) return Node_Id;\n-      --  Construct an integer literal representing an accessibility level.\n+      --  Construct an integer literal representing an accessibility level\n+      --  with its type set to Natural.\n \n-      ---------------------------------\n-      -- function Make_Level_Literal --\n-      ---------------------------------\n+      ------------------------\n+      -- Make_Level_Literal --\n+      ------------------------\n \n       function Make_Level_Literal (Level : Uint) return Node_Id is\n-         Result : constant Node_Id :=\n-                    Make_Integer_Literal (Loc, Level);\n+         Result : constant Node_Id := Make_Integer_Literal (Loc, Level);\n       begin\n          Set_Etype (Result, Standard_Natural);\n          return Result;\n       end Make_Level_Literal;\n \n+   --  Start of processing for Dynamic_Accessibility_Level\n+\n    begin\n       if Is_Entity_Name (Expr) then\n          E := Entity (Expr);\n@@ -2909,16 +2911,17 @@ package body Sem_Util is\n          end if;\n       end if;\n \n-      --  unimplemented: Ptr.all'Access, where Ptr has Extra_Accessibility ???\n+      --  Unimplemented: Ptr.all'Access, where Ptr has Extra_Accessibility ???\n \n       case Nkind (Expr) is\n-         --  for access discriminant, the level of the enclosing object\n+\n+         --  For access discriminant, the level of the enclosing object\n \n          when N_Selected_Component =>\n             if Ekind (Entity (Selector_Name (Expr))) = E_Discriminant\n               and then Ekind (Etype (Entity (Selector_Name (Expr)))) =\n-              E_Anonymous_Access_Type then\n-\n+                                            E_Anonymous_Access_Type\n+            then\n                return Make_Level_Literal (Object_Access_Level (Expr));\n             end if;\n \n@@ -2933,8 +2936,8 @@ package body Sem_Util is\n \n                --  Treat the unchecked attributes as library-level\n \n-               when Attribute_Unchecked_Access |\n-                 Attribute_Unrestricted_Access =>\n+               when Attribute_Unchecked_Access    |\n+                    Attribute_Unrestricted_Access =>\n                   return Make_Level_Literal (Scope_Depth (Standard_Standard));\n \n                --  No other access-valued attributes\n@@ -2944,17 +2947,20 @@ package body Sem_Util is\n             end case;\n \n          when N_Allocator =>\n-            --  Unimplemented: depends on context. As an actual\n-            --  parameter where formal type is anonymous, use\n+\n+            --  Unimplemented: depends on context. As an actual parameter where\n+            --  formal type is anonymous, use\n             --    Scope_Depth (Current_Scope) + 1.\n             --  For other cases, see 3.10.2(14/3) and following. ???\n+\n             null;\n \n          when N_Type_Conversion =>\n             if not Is_Local_Anonymous_Access (Etype (Expr)) then\n-               --  Handle type conversions introduced for a\n-               --  rename of an Ada2012 stand-alone object of an\n-               --  anonymous access type.\n+\n+               --  Handle type conversions introduced for a rename of an\n+               --  Ada2012 stand-alone object of an anonymous access type.\n+\n                return Dynamic_Accessibility_Level (Expression (Expr));\n             end if;\n "}]}