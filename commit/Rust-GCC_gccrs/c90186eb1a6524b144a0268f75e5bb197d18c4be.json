{"sha": "c90186eb1a6524b144a0268f75e5bb197d18c4be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkwMTg2ZWIxYTY1MjRiMTQ0YTAyNjhmNzVlNWJiMTk3ZDE4YzRiZQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-12-30T18:43:00Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-12-30T18:43:00Z"}, "message": "tree.h (VALUE_HANDLE_VUSES): New.\n\n2005-12-29  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree.h (VALUE_HANDLE_VUSES): New.\n\t(struct tree_value_handle): Add vuses.\n\n\t* tree-vn.c (struct val_expr_pair_d): Remove stmt, add vuses.\n\t(vn_compute): Remove stmt argument.\n\tDon't use vuses in hash value computation.\n\t(val_expr_pair_eq): Compare vuse lists.\n\t(copy_vuses_from_stmt): New function.\n\t(shared_vuses_from_stmt): Ditto.\n\t(vn_add): Rewrite in terms of vn_add_with_vuses.\n\t(vn_add_with_vuses): New function.\n\t(vn_lookup): Rewrite in terms of vn_lookup_with_vuses.\n\t(vn_lookup_with_vuses): New function.\n\t(vuses_compare): New function.\n\t(print_creation_to_file): Ditto.\n\t(vn_lookup_or_add): Rewrite to handle vuses.\n\t(sort_vuses): New function.\n\t(vn_lookup_or_add_with_vuses): Ditto.\n\t(vn_init): Initialize shared_lookup_vuses.\n\t(vn_delete): Free shared_lookup_vuses.\n\n\t* tree-ssa-pre.c: Update todo list.\n\t(bb_value_sets_t): Add rvuse_in, rvuse_out, rvuse_gen, and\n\trvuse_kill.\n\t(RVUSE_IN): New macro.\n\t(RVUSE_GEN): Ditto.\n\t(RVUSE_KILL): Ditto.\n\t(RVUSE_OUT): Ditto.\n\t(modify_expr_node_pool): New function.\n\t(pretemp): New.\n\t(storetemp): Ditto.\n\t(mergephitemp): Ditto.\n\t(prephitemp): Ditto.\n\t(struct expr_pred_trans_d): Add vuses member.\n\t(expr_pred_trans_eq): Compare vuses.\n\t(phi_trans_lookup): Add vuses argument.\n\t(phi_trans_add): Ditto.\n\t(translate_vuses_through_block): New function.\n\t(phi_translate): Use vuses to ask about those expressions that can\n\thave vuses.\n\tProperly translate virtual uses through phis, and use\n\tvn_lookup_or_add_with vuses.  Handle tcc_reference.\n\t(phi_translate_set): Don't add pointless translations to the\n\tcache.\n\t(get_representative): New function.\n\t(vuses_dies_in_block_x): Ditto.\n\t(valid_in_set): Add block argument.  Check virtual use validity.\n\t(clean): Add block argument. Update call to valid_in_set\n\t(compute_antic_aux): Update call to clean.\n\t(dump_bitmap_of_names): New function.\n\t(compute_vuse_representatives): Ditto.\n\t(compute_rvuse): Ditto.\n\t(can_value_number_call): Modified to accept calls with vuses.\n\t(can_value_number_operation): New function.\n\t(can_PRE_operation): Ditto.\n\t(need_creation): New vector of stores that may need creation.\n\t(find_or_generate_expression): use can_PRE_operation.\n\t(create_expression_by_pieces): Handle INDIRECT_REF.\n\tOnly create one temp until we have to change types.\n\tMark new vars for renaming.\n\t(insert_into_preds_of_block): Ignore loopiness of loads.\n\tUse can_PRE_operation.\n\tOnly create one temp until we have to chnge types.\n\t(insert_aux): Use can_PRE_operation.\n\tDon't pass name to insert_into_preds_of_block.\n\t(insert_extra_phis): Only use one temp until we have to change\n\ttypes.\n\t(poolify_tree): New function.\n\t(modify_expr_template): New var.\n\t(poolify_modify_expr): New function.\n\t(insert_fake_stores): Ditto.\n\t(realify_fake_stores): Ditto.\n\t(compute_avail): Use can_value_number_operation.\n\t(mark_operand_necessary): Return NULL for non-SSA names.\n\t(remove_dead_inserted_code): Update comment.\n\t(init_pre): Initialize pretemp, need_creation, storetemp,\n\tmergephitemp, prephitemp.\n\tCreate modify_expr_node_pool.\n\t(fini_pre): Free modify_expr_node_pool and need_creation array.\n\t(execute_pre): Call insert_fake_stores, compute_rvuse, and\n\trealify_fake_stores. \n\t* tree-flow.h (vn_compute): Fix prototype.\n\t(vn_add): Ditto.\n\t(vn_lookup): Ditto.\n\t(sort_vuses): New.\n\t(vn_lookup_or_add_with_vuses): Ditto.\n\t(vn_add_with_vuses): Ditto.\n\t(vn_lookup_with_vuses): Ditto.\n\t* passes.c (pass_may_alias): Add.\n\nFrom-SVN: r109180", "tree": {"sha": "bcfde4543d9a85e504674357c7c11327c437e994", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcfde4543d9a85e504674357c7c11327c437e994"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c90186eb1a6524b144a0268f75e5bb197d18c4be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c90186eb1a6524b144a0268f75e5bb197d18c4be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c90186eb1a6524b144a0268f75e5bb197d18c4be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c90186eb1a6524b144a0268f75e5bb197d18c4be/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a176426f3573d5eceb4f60caf01a291ab778e475", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a176426f3573d5eceb4f60caf01a291ab778e475", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a176426f3573d5eceb4f60caf01a291ab778e475"}], "stats": {"total": 1594, "additions": 1442, "deletions": 152}, "files": [{"sha": "43dc427c264f668a3e5d1198c4955f47d9a8f38a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c90186eb1a6524b144a0268f75e5bb197d18c4be", "patch": "@@ -1,3 +1,95 @@\n+2005-12-29  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree.h (VALUE_HANDLE_VUSES): New.\n+\t(struct tree_value_handle): Add vuses.\n+\n+\t* tree-vn.c (struct val_expr_pair_d): Remove stmt, add vuses.\n+\t(vn_compute): Remove stmt argument.\n+\tDon't use vuses in hash value computation.\n+\t(val_expr_pair_eq): Compare vuse lists.\n+\t(copy_vuses_from_stmt): New function.\n+\t(shared_vuses_from_stmt): Ditto.\n+\t(vn_add): Rewrite in terms of vn_add_with_vuses.\n+\t(vn_add_with_vuses): New function.\n+\t(vn_lookup): Rewrite in terms of vn_lookup_with_vuses.\n+\t(vn_lookup_with_vuses): New function.\n+\t(vuses_compare): New function.\n+\t(print_creation_to_file): Ditto.\n+\t(vn_lookup_or_add): Rewrite to handle vuses.\n+\t(sort_vuses): New function.\n+\t(vn_lookup_or_add_with_vuses): Ditto.\n+\t(vn_init): Initialize shared_lookup_vuses.\n+\t(vn_delete): Free shared_lookup_vuses.\n+\n+\t* tree-ssa-pre.c: Update todo list.\n+\t(bb_value_sets_t): Add rvuse_in, rvuse_out, rvuse_gen, and\n+\trvuse_kill.\n+\t(RVUSE_IN): New macro.\n+\t(RVUSE_GEN): Ditto.\n+\t(RVUSE_KILL): Ditto.\n+\t(RVUSE_OUT): Ditto.\n+\t(modify_expr_node_pool): New function.\n+\t(pretemp): New.\n+\t(storetemp): Ditto.\n+\t(mergephitemp): Ditto.\n+\t(prephitemp): Ditto.\n+\t(struct expr_pred_trans_d): Add vuses member.\n+\t(expr_pred_trans_eq): Compare vuses.\n+\t(phi_trans_lookup): Add vuses argument.\n+\t(phi_trans_add): Ditto.\n+\t(translate_vuses_through_block): New function.\n+\t(phi_translate): Use vuses to ask about those expressions that can\n+\thave vuses.\n+\tProperly translate virtual uses through phis, and use\n+\tvn_lookup_or_add_with vuses.  Handle tcc_reference.\n+\t(phi_translate_set): Don't add pointless translations to the\n+\tcache.\n+\t(get_representative): New function.\n+\t(vuses_dies_in_block_x): Ditto.\n+\t(valid_in_set): Add block argument.  Check virtual use validity.\n+\t(clean): Add block argument. Update call to valid_in_set\n+\t(compute_antic_aux): Update call to clean.\n+\t(dump_bitmap_of_names): New function.\n+\t(compute_vuse_representatives): Ditto.\n+\t(compute_rvuse): Ditto.\n+\t(can_value_number_call): Modified to accept calls with vuses.\n+\t(can_value_number_operation): New function.\n+\t(can_PRE_operation): Ditto.\n+\t(need_creation): New vector of stores that may need creation.\n+\t(find_or_generate_expression): use can_PRE_operation.\n+\t(create_expression_by_pieces): Handle INDIRECT_REF.\n+\tOnly create one temp until we have to change types.\n+\tMark new vars for renaming.\n+\t(insert_into_preds_of_block): Ignore loopiness of loads.\n+\tUse can_PRE_operation.\n+\tOnly create one temp until we have to chnge types.\n+\t(insert_aux): Use can_PRE_operation.\n+\tDon't pass name to insert_into_preds_of_block.\n+\t(insert_extra_phis): Only use one temp until we have to change\n+\ttypes.\n+\t(poolify_tree): New function.\n+\t(modify_expr_template): New var.\n+\t(poolify_modify_expr): New function.\n+\t(insert_fake_stores): Ditto.\n+\t(realify_fake_stores): Ditto.\n+\t(compute_avail): Use can_value_number_operation.\n+\t(mark_operand_necessary): Return NULL for non-SSA names.\n+\t(remove_dead_inserted_code): Update comment.\n+\t(init_pre): Initialize pretemp, need_creation, storetemp,\n+\tmergephitemp, prephitemp.\n+\tCreate modify_expr_node_pool.\n+\t(fini_pre): Free modify_expr_node_pool and need_creation array.\n+\t(execute_pre): Call insert_fake_stores, compute_rvuse, and\n+\trealify_fake_stores. \n+\t* tree-flow.h (vn_compute): Fix prototype.\n+\t(vn_add): Ditto.\n+\t(vn_lookup): Ditto.\n+\t(sort_vuses): New.\n+\t(vn_lookup_or_add_with_vuses): Ditto.\n+\t(vn_add_with_vuses): Ditto.\n+\t(vn_lookup_with_vuses): Ditto.\n+\t* passes.c (pass_may_alias): Add.\n+\n 2005-12-30  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* c-pretty-print.h (struct c_pretty_print_info): Add new member"}, {"sha": "dcff796067658615dd382a1eb9a3f1744b5709db", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=c90186eb1a6524b144a0268f75e5bb197d18c4be", "patch": "@@ -554,6 +554,7 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_cse_reciprocals);\n   NEXT_PASS (pass_split_crit_edges);\n   NEXT_PASS (pass_pre);\n+  NEXT_PASS (pass_may_alias);\n   NEXT_PASS (pass_sink_code);\n   NEXT_PASS (pass_tree_loop);\n   NEXT_PASS (pass_reassoc);"}, {"sha": "e6597514743d72575a1ce83114800476a83b08cf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre1.c?ref=c90186eb1a6524b144a0268f75e5bb197d18c4be", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+int main(int *a, int argc)\n+{\n+  int c;\n+  int d, e;\n+  \n+  /* Should be able to eliminate the second load of *a along the main path. */\n+  d = *a;\n+  if (argc)\n+    {\n+      a = &c;\n+    }\n+  e = *a;\n+  return d + e;\n+}\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "8d6557a9e88dde597c610695b53f063b051b0cf3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre2.c?ref=c90186eb1a6524b144a0268f75e5bb197d18c4be", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+int main(int *a, int argc)\n+{\n+  int b;\n+  int i;\n+  int d, e;\n+\n+  /* Should be able to hoist this out of the loop.  */\n+  for (i = 0; i < argc; i++)\n+    {\n+      e = *a;\n+    }\n+  return d + e;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "8767e16a98e2a543d74c055d6c3477189c338bc9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre3.c?ref=c90186eb1a6524b144a0268f75e5bb197d18c4be", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+int main(int **a,int argc)\n+{\n+  int b;\n+  int d, e;\n+\n+  if (argc)\n+    {\n+      d = *(*a);\n+    }\n+  else\n+    {\n+\n+    }\n+  /* Should be able to eliminate one of the *(*a)'s along the if path \n+     by pushing it into the else path. We will also eliminate\n+     one of the *a's.  */\n+  e = *(*a);\n+  return d + e;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 2\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "3b886151be1e430debbc01336d24f5935c3d3e32", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre4.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre4.c?ref=c90186eb1a6524b144a0268f75e5bb197d18c4be", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+int main(int *a, int argc)\n+{\n+  int b;\n+  int c;\n+  int i;\n+  int d, e;\n+\n+  /* With smarter load PRE, we'd be able to recompute the value at the \n+     kill point.  arguably not worth it.  */\n+  for (i = 0; i < argc; i++)\n+    {\n+      e = *a;\n+      *a = 9;\n+    }\n+  return d + e;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "37314ebe8fd2b4a75f2f31dba06e838e04eb4e21", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre5.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre5.c?ref=c90186eb1a6524b144a0268f75e5bb197d18c4be", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+int p;\n+int r;\n+int a(void)\n+{\n+  return p;\n+}\n+int main(int argc)\n+{\n+  int q;\n+  q = a();\n+\n+  /* We should be able to move the call to a into the if path.\n+     in a perfect world, we'd actually decide that it can't touch\n+     r, and not recompute it at all!.  */\n+  if (argc)\n+    r = 9;\n+  return q + a();\n+}\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "5283f20d4d40f6f41e728381e85c03293a8edfdf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre6.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre6.c?ref=c90186eb1a6524b144a0268f75e5bb197d18c4be", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+\n+union tree_node;\n+typedef union tree_node *tree;\n+\n+struct tree_common\n+{\n+  tree chain;\n+};\n+\n+struct tree_list\n+{\n+  struct tree_common common;\n+  tree value;\n+};\n+\n+union tree_node\n+\n+{\n+  struct tree_common common;\n+  struct tree_list list;\n+};\n+\n+extern void abort (void) __attribute__((noreturn));\n+\n+void __attribute__((noinline))\n+foo (void)\n+{\n+  abort ();\n+}\n+\n+void __attribute__((noinline))\n+remove_useless_vars (tree *unexpanded_var_list, int dump_file)\n+{\n+  tree var, *cell;\n+  int c = 0;\n+  for (cell = unexpanded_var_list; *cell; )\n+    {\n+      var = (*cell)->list.value;\n+      if (var)\n+        {\n+          if (dump_file)\n+            foo ();\n+\n+          *cell = ((*cell)->common.chain);\n+          continue;\n+        }\n+\n+      cell = &((*cell)->common.chain);\n+    }\n+}\n+extern void *malloc (int) __attribute__ ((malloc));\n+\n+int\n+main (void)\n+{\n+  int i;\n+  tree unexpanded_var_list, last = (tree) 0;\n+\n+  for (i = 0; i < 2; i++)\n+    {\n+      unexpanded_var_list = malloc (sizeof (struct tree_list));\n+      unexpanded_var_list->list.value = (tree) (long unsigned) (i & 1);\n+      unexpanded_var_list->common.chain = last;\n+      last = unexpanded_var_list;\n+    }\n+\n+  remove_useless_vars (&unexpanded_var_list, 0);\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\" } } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */\n+"}, {"sha": "7cd6838c6ab396b73b15529e1d88b4c7941cfd50", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre7.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre7.c?ref=c90186eb1a6524b144a0268f75e5bb197d18c4be", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+/* We can't eliminate the *p load here in any sane way, as eshup8 may \n+   change it.  */\n+void\n+enormlz (x)\n+     unsigned short x[];\n+{\n+  register unsigned short *p;\n+  p = &x[2];\n+  while ((*p & 0xff00) == 0)\n+    {\n+      eshup8 (x);\n+    }\n+}\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 0\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "86cb1e46bba7f7a4556662b7ce8f8538e72d372e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre8.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre8.c?ref=c90186eb1a6524b144a0268f75e5bb197d18c4be", "patch": "@@ -0,0 +1,97 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+typedef union tree_node *tree;\n+struct tree_common\n+{\n+  tree chain;\n+}\n+VEC_constructor_elt_base;\n+struct tree_ssa_name\n+{\n+  tree var;\n+};\n+union tree_node\n+{\n+  struct tree_common common;\n+  struct tree_ssa_name ssa_name;\n+};\n+struct edge_def\n+{\n+  struct basic_block_def *dest;\n+};\n+typedef struct edge_def *edge;\n+typedef struct VEC_edge_base\n+{\n+}\n+VEC_edge_base;\n+edge\n+VEC_edge_base_index (const VEC_edge_base * vec_, unsigned ix_)\n+{\n+}\n+typedef struct VEC_edge_gc\n+{\n+  VEC_edge_base base;\n+}\n+VEC_edge_gc;\n+struct basic_block_def\n+{\n+  VEC_edge_gc *succs;\n+};\n+typedef struct basic_block_def *basic_block;\n+typedef struct\n+{\n+  unsigned index;\n+  VEC_edge_gc **container;\n+}\n+edge_iterator;\n+__inline__ VEC_edge_gc *\n+ei_container (edge_iterator i)\n+{\n+  return *i.container;\n+}\n+__inline__ edge_iterator\n+ei_start_1 (VEC_edge_gc ** ev)\n+{\n+  edge_iterator i;\n+  i.container = ev;\n+  return i;\n+}\n+ei_next (edge_iterator * i)\n+{\n+}\n+static __inline__ edge\n+ei_edge (edge_iterator i)\n+{\n+  return  (edge) (VEC_edge_base_index ((((ei_container (i))) ? &((ei_container (i)))->base : 0), (i.index)));\n+}\n+static __inline__ unsigned char\n+ei_cond (edge_iterator ei, edge * p)\n+{\n+  *p = ei_edge (ei);\n+}\n+typedef tree *def_operand_p;\n+extern tree *get_phi_result_ptr (tree);\n+static __inline__ tree\n+get_def_from_ptr (def_operand_p def)\n+{\n+}\n+tree\n+phi_nodes (basic_block bb)\n+{\n+}\n+\n+/* We can eliminate a load of the SRA'd variable edge_iterator.container */\n+rewrite_add_phi_arguments (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  for ((ei) = ei_start_1 (&((bb->succs))); ei_cond ((ei), &(e));\n+       ei_next (&(ei)))\n+    {\n+      tree phi;\n+      for (phi = phi_nodes (e->dest); phi; phi = (((phi))->common.chain))\n+\t  get_reaching_def ((get_def_from_ptr (get_phi_result_ptr (phi)))->ssa_name.var);\n+    }\n+}\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "6065a3b39109dfdd6c59677bda0dd16c36e14595", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=c90186eb1a6524b144a0268f75e5bb197d18c4be", "patch": "@@ -776,10 +776,14 @@ void print_value_expressions (FILE *, tree);\n /* In tree-vn.c  */\n bool expressions_equal_p (tree, tree);\n tree get_value_handle (tree);\n-hashval_t vn_compute (tree, hashval_t, tree);\n+hashval_t vn_compute (tree, hashval_t);\n+void sort_vuses (VEC (tree, gc) *);\n tree vn_lookup_or_add (tree, tree);\n-void vn_add (tree, tree, tree);\n+tree vn_lookup_or_add_with_vuses (tree, VEC (tree, gc) *);\n+void vn_add (tree, tree);\n+void vn_add_with_vuses (tree, tree, VEC (tree, gc) *);\n tree vn_lookup (tree, tree);\n+tree vn_lookup_with_vuses (tree, VEC (tree, gc) *);\n void vn_init (void);\n void vn_delete (void);\n "}, {"sha": "f0bf0205297cb781329105b3cf8e7efe950112ef", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 859, "deletions": 112, "changes": 971, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=c90186eb1a6524b144a0268f75e5bb197d18c4be", "patch": "@@ -49,13 +49,9 @@ Boston, MA 02110-1301, USA.  */\n    1. Avail sets can be shared by making an avail_find_leader that\n       walks up the dominator tree and looks in those avail sets.\n       This might affect code optimality, it's unclear right now.\n-   2. Load motion can be performed by value numbering the loads the\n-      same as we do other expressions.  This requires iterative\n-      hashing the vuses into the values.  Right now we simply assign\n-      a new value every time we see a statement with a vuse.\n-   3. Strength reduction can be performed by anticipating expressions\n+   2. Strength reduction can be performed by anticipating expressions\n       we can repair later on.\n-   4. We can do back-substitution or smarter value numbering to catch\n+   3. We can do back-substitution or smarter value numbering to catch\n       commutative expressions split up over multiple statements.\n */   \n \n@@ -247,21 +243,32 @@ typedef struct bb_value_sets\n      a given basic block.  */\n   bitmap_set_t avail_out;\n \n-  /* The ANTIC_IN set, which represents which values are anticiptable\n+  /* The ANTIC_IN set, which represents which values are anticipatable\n      in a given basic block.  */\n   value_set_t antic_in;\n \n   /* The NEW_SETS set, which is used during insertion to augment the\n      AVAIL_OUT set of blocks with the new insertions performed during\n      the current iteration.  */\n   bitmap_set_t new_sets;\n+\n+  /* The RVUSE sets, which are used during ANTIC computation to ensure\n+     that we don't mark loads ANTIC once they have died.  */\n+  bitmap rvuse_in;\n+  bitmap rvuse_out;\n+  bitmap rvuse_gen;\n+  bitmap rvuse_kill;\n } *bb_value_sets_t;\n \n #define EXP_GEN(BB)\t((bb_value_sets_t) ((BB)->aux))->exp_gen\n #define PHI_GEN(BB)\t((bb_value_sets_t) ((BB)->aux))->phi_gen\n #define TMP_GEN(BB)\t((bb_value_sets_t) ((BB)->aux))->tmp_gen\n #define AVAIL_OUT(BB)\t((bb_value_sets_t) ((BB)->aux))->avail_out\n #define ANTIC_IN(BB)\t((bb_value_sets_t) ((BB)->aux))->antic_in\n+#define RVUSE_IN(BB)    ((bb_value_sets_t) ((BB)->aux))->rvuse_in\n+#define RVUSE_GEN(BB)   ((bb_value_sets_t) ((BB)->aux))->rvuse_gen\n+#define RVUSE_KILL(BB)   ((bb_value_sets_t) ((BB)->aux))->rvuse_kill\n+#define RVUSE_OUT(BB)    ((bb_value_sets_t) ((BB)->aux))->rvuse_out\n #define NEW_SETS(BB)\t((bb_value_sets_t) ((BB)->aux))->new_sets\n \n /* This structure is used to keep track of statistics on what\n@@ -309,8 +316,18 @@ static alloc_pool reference_node_pool;\n static alloc_pool comparison_node_pool;\n static alloc_pool expression_node_pool;\n static alloc_pool list_node_pool;\n+static alloc_pool modify_expr_node_pool;\n static bitmap_obstack grand_bitmap_obstack;\n \n+/* To avoid adding 300 temporary variables when we only need one, we\n+   only create one temporary variable, on demand, and build ssa names\n+   off that.  We do have to change the variable if the types don't\n+   match the current variable's type.  */\n+static tree pretemp;\n+static tree storetemp;\n+static tree mergephitemp;\n+static tree prephitemp;\n+\n /* Set of blocks with statements that have had its EH information\n    cleaned up.  */\n static bitmap need_eh_cleanup;\n@@ -331,9 +348,13 @@ typedef struct expr_pred_trans_d\n   /* The predecessor block along which we translated the expression.  */\n   basic_block pred;\n \n+  /* vuses associated with the expression.  */\n+  VEC (tree, gc) *vuses;\n+\n   /* The value that resulted from the translation.  */\n   tree v;\n \n+\n   /* The hashcode for the expression, pred pair. This is cached for\n      speed reasons.  */\n   hashval_t hashcode;\n@@ -358,33 +379,50 @@ expr_pred_trans_eq (const void *p1, const void *p2)\n   const expr_pred_trans_t ve2 = (expr_pred_trans_t) p2;\n   basic_block b1 = ve1->pred;\n   basic_block b2 = ve2->pred;\n-\n+  int i;\n+  tree vuse1;\n   \n   /* If they are not translations for the same basic block, they can't\n      be equal.  */\n   if (b1 != b2)\n     return false;\n \n+\n   /* If they are for the same basic block, determine if the\n      expressions are equal.  */  \n-  if (expressions_equal_p (ve1->e, ve2->e))\n+  if (!expressions_equal_p (ve1->e, ve2->e))\n+    return false;\n+\n+  /* Make sure the vuses are equivalent.  */\n+  if (ve1->vuses == ve2->vuses)\n     return true;\n   \n-  return false;\n+  if (VEC_length (tree, ve1->vuses) != VEC_length (tree, ve2->vuses))\n+    return false;\n+\n+  for (i = 0; VEC_iterate (tree, ve1->vuses, i, vuse1); i++)\n+    {\n+      if (VEC_index (tree, ve2->vuses, i) != vuse1)\n+\treturn false;\n+    }\n+\n+  return true;\n }\n \n /* Search in the phi translation table for the translation of\n-   expression E in basic block PRED. Return the translated value, if\n-   found, NULL otherwise.  */ \n+   expression E in basic block PRED with vuses VUSES.\n+   Return the translated value, if found, NULL otherwise.  */\n \n static inline tree\n-phi_trans_lookup (tree e, basic_block pred)\n+phi_trans_lookup (tree e, basic_block pred, VEC (tree, gc) *vuses)\n {\n   void **slot;\n   struct expr_pred_trans_d ept;\n+\n   ept.e = e;\n   ept.pred = pred;\n-  ept.hashcode = vn_compute (e, (unsigned long) pred, NULL);\n+  ept.vuses = vuses;\n+  ept.hashcode = vn_compute (e, (unsigned long) pred);\n   slot = htab_find_slot_with_hash (phi_translate_table, &ept, ept.hashcode,\n \t\t\t\t   NO_INSERT);\n   if (!slot)\n@@ -394,18 +432,19 @@ phi_trans_lookup (tree e, basic_block pred)\n }\n \n \n-/* Add the tuple mapping from {expression E, basic block PRED} to\n+/* Add the tuple mapping from {expression E, basic block PRED, vuses VUSES} to\n    value V, to the phi translation table.  */\n \n static inline void\n-phi_trans_add (tree e, tree v, basic_block pred)\n+phi_trans_add (tree e, tree v, basic_block pred, VEC (tree, gc) *vuses)\n {\n   void **slot;\n   expr_pred_trans_t new_pair = XNEW (struct expr_pred_trans_d);\n   new_pair->e = e;\n   new_pair->pred = pred;\n+  new_pair->vuses = vuses;\n   new_pair->v = v;\n-  new_pair->hashcode = vn_compute (e, (unsigned long) pred, NULL);\n+  new_pair->hashcode = vn_compute (e, (unsigned long) pred);\n   slot = htab_find_slot_with_hash (phi_translate_table, new_pair,\n \t\t\t\t   new_pair->hashcode, INSERT);\n   if (*slot)\n@@ -936,7 +975,42 @@ pool_copy_list (tree list)\n   return head;\n }\n \n+/* Translate the vuses in the VUSES vector backwards through phi\n+   nodes, so that they have the value they would have in BLOCK. */\n+\n+static VEC(tree, gc) *\n+translate_vuses_through_block (VEC (tree, gc) *vuses, basic_block block)\n+{\n+  tree oldvuse;\n+  VEC(tree, gc) *result = NULL;\n+  int i;\n \n+  for (i = 0; VEC_iterate (tree, vuses, i, oldvuse); i++)\n+    {\n+      tree phi = SSA_NAME_DEF_STMT (oldvuse);\n+      if (TREE_CODE (phi) == PHI_NODE)\n+\t{\n+\t  edge e = find_edge (block, bb_for_stmt (phi));\n+\t  if (e)\n+\t    {\n+\t      tree def = PHI_ARG_DEF (phi, e->dest_idx);\n+\t      if (def != oldvuse)\n+\t\t{\n+\t\t  if (!result)\n+\t\t    result = VEC_copy (tree, gc, vuses);\n+\t\t  VEC_replace (tree, result, i, def);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  if (result)\n+    {\n+      sort_vuses (result);\n+      return result;\n+    }\n+  return vuses;\n+\n+}\n /* Translate EXPR using phis in PHIBLOCK, so that it has the values of\n    the phis in PRED.  Return NULL if we can't find a leader for each\n    part of the translated expression.  */\n@@ -947,15 +1021,26 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n {\n   tree phitrans = NULL;\n   tree oldexpr = expr;\n-  \n   if (expr == NULL)\n     return NULL;\n \n   if (is_gimple_min_invariant (expr))\n     return expr;\n \n   /* Phi translations of a given expression don't change.  */\n-  phitrans = phi_trans_lookup (expr, pred);\n+  if (EXPR_P (expr))\n+    {\n+      tree vh;\n+\n+      vh = get_value_handle (expr);\n+      if (vh && TREE_CODE (vh) == VALUE_HANDLE)\n+\tphitrans = phi_trans_lookup (expr, pred, VALUE_HANDLE_VUSES (vh));\n+      else\n+\tphitrans = phi_trans_lookup (expr, pred, NULL);\n+    }\n+  else\n+    phitrans = phi_trans_lookup (expr, pred, NULL);\n+\n   if (phitrans)\n     return phitrans;\n   \n@@ -976,7 +1061,10 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t    tree oldwalker;\n \t    tree newwalker;\n \t    tree newexpr;\n+\t    tree vh = get_value_handle (expr);\n \t    bool listchanged = false;\n+\t    VEC (tree, gc) *vuses = VALUE_HANDLE_VUSES (vh);\n+\t    VEC (tree, gc) *tvuses;\n \n \t    /* Call expressions are kind of weird because they have an\n \t       argument list.  We don't want to value number the list\n@@ -1028,25 +1116,87 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t    if (listchanged)\n \t      vn_lookup_or_add (newarglist, NULL);\n \t    \n-\t    if (listchanged || (newop0 != oldop0) || (oldop2 != newop2))\n+\t    tvuses = translate_vuses_through_block (vuses, pred);\n+\n+\t    if (listchanged || (newop0 != oldop0) || (oldop2 != newop2)\n+\t\t|| vuses != tvuses)\n \t      {\n \t\tnewexpr = (tree) pool_alloc (expression_node_pool);\n \t\tmemcpy (newexpr, expr, tree_size (expr));\n \t\tTREE_OPERAND (newexpr, 0) = newop0 == oldop0 ? oldop0 : get_value_handle (newop0);\n \t\tTREE_OPERAND (newexpr, 1) = listchanged ? newarglist : oldarglist;\n \t\tTREE_OPERAND (newexpr, 2) = newop2 == oldop2 ? oldop2 : get_value_handle (newop2);\n \t\tcreate_tree_ann (newexpr);\t \n-\t\tvn_lookup_or_add (newexpr, NULL);\n+\t\tvn_lookup_or_add_with_vuses (newexpr, tvuses);\n \t\texpr = newexpr;\n-\t\tphi_trans_add (oldexpr, newexpr, pred);\n+\t\tphi_trans_add (oldexpr, newexpr, pred, tvuses);\n \t      }\n \t  }\n       }\n       return expr;\n \n+    case tcc_declaration:\n+      {\n+\tVEC (tree, gc) * oldvuses = NULL;\n+\tVEC (tree, gc) * newvuses = NULL;\n+\n+\toldvuses = VALUE_HANDLE_VUSES (get_value_handle (expr));\n+\tif (oldvuses)\n+\t  newvuses = translate_vuses_through_block (oldvuses, pred);\n+\n+\tif (oldvuses != newvuses)\n+\t  vn_lookup_or_add_with_vuses (expr, newvuses);\n+\n+\tphi_trans_add (oldexpr, expr, pred, newvuses);\n+      }\n+      return expr;\n+\n     case tcc_reference:\n-      /* XXX: Until we have PRE of loads working, none will be ANTIC.  */\n-      return NULL;\n+      {\n+\ttree oldop1 = TREE_OPERAND (expr, 0);\n+\ttree newop1;\n+\ttree newexpr;\n+\tVEC (tree, gc) * oldvuses = NULL;\n+\tVEC (tree, gc) * newvuses = NULL;\n+\n+\tif (TREE_CODE (expr) != INDIRECT_REF)\n+\t  return NULL;\n+\n+\tnewop1 = phi_translate (find_leader (set, oldop1),\n+\t\t\t\tset, pred, phiblock);\n+\tif (newop1 == NULL)\n+\t  return NULL;\n+\n+\toldvuses = VALUE_HANDLE_VUSES (get_value_handle (expr));\n+\tif (oldvuses)\n+\t  newvuses = translate_vuses_through_block (oldvuses, pred);\n+\n+\tif (newop1 != oldop1 || newvuses != oldvuses)\n+\t  {\n+\t    tree t;\n+\n+\t    newexpr = pool_alloc (reference_node_pool);\n+\t    memcpy (newexpr, expr, tree_size (expr));\n+\t    TREE_OPERAND (newexpr, 0) = get_value_handle (newop1);\n+\n+\t    t = fully_constant_expression (newexpr);\n+\n+\t    if (t != newexpr)\n+\t      {\n+\t\tpool_free (reference_node_pool, newexpr);\n+\t\tnewexpr = t;\n+\t      }\n+\t    else\n+\t      {\n+\t\tcreate_tree_ann (newexpr);\n+\t\tvn_lookup_or_add_with_vuses (newexpr, newvuses);\n+\t      }\n+\t    expr = newexpr;\n+\t    phi_trans_add (oldexpr, newexpr, pred, newvuses);\n+\t  }\n+      }\n+      return expr;\n+      break;\n \n     case tcc_binary:\n     case tcc_comparison:\n@@ -1084,7 +1234,7 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t\tvn_lookup_or_add (newexpr, NULL);\n \t      }\n \t    expr = newexpr;\n-\t    phi_trans_add (oldexpr, newexpr, pred);\t    \n+\t    phi_trans_add (oldexpr, newexpr, pred, NULL);\n \t  }\n       }\n       return expr;\n@@ -1117,7 +1267,7 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t\tvn_lookup_or_add (newexpr, NULL);\n \t      }\n \t    expr = newexpr;\n-\t    phi_trans_add (oldexpr, newexpr, pred);\n+\t    phi_trans_add (oldexpr, newexpr, pred, NULL);\n \t  }\n       }\n       return expr;\n@@ -1162,9 +1312,23 @@ phi_translate_set (value_set_t dest, value_set_t set, basic_block pred,\n        node = node->next)\n     {\n       tree translated;\n-      translated = phi_translate (node->expr, set, pred, phiblock);\n-      phi_trans_add (node->expr, translated, pred);\n       \n+      translated = phi_translate (node->expr, set, pred, phiblock);\n+\n+      /* Don't add constants or empty translations to the cache, since\n+\t we won't look them up that way, or use the result, anyway.  */\n+      if (translated && !is_gimple_min_invariant (translated))\n+\t{\n+\t  tree vh = get_value_handle (translated);\n+\t  VEC (tree, gc) *vuses;\n+\t  \n+\t  /* The value handle itself may also be an invariant, in\n+\t     which case, it has no vuses.  */\n+\t  vuses = !is_gimple_min_invariant (vh)\n+\t    ? VALUE_HANDLE_VUSES (vh) : NULL;\n+\t  phi_trans_add (node->expr, translated, pred, vuses);\n+\t}\n+\n       if (translated != NULL)\n \tvalue_insert_into_set (dest, translated);\n     } \n@@ -1245,6 +1409,42 @@ find_leader (value_set_t set, tree val)\n   return NULL;\n }\n \n+/* Given the vuse representative map, MAP, and an SSA version number,\n+   ID, return the bitmap of names ID represents, or NULL, if none\n+   exists.  */\n+\n+static bitmap\n+get_representative (bitmap *map, int id)\n+{\n+  if (map[id] != NULL)\n+    return map[id];\n+  return NULL;\n+}\n+\n+/* A vuse is anticipable at the top of block x, from the bottom of the\n+   block, if it reaches the top of the block, and is not killed in the\n+   block.  In effect, we are trying to see if the vuse is transparent\n+   backwards in the block.  */\n+\n+static bool\n+vuses_dies_in_block_x (VEC (tree, gc) *vuses, basic_block block)\n+{\n+  int i;\n+  tree vuse;\n+\n+  for (i = 0; VEC_iterate (tree, vuses, i, vuse); i++)\n+    {\n+      /* Any places where this is too conservative, are  places\n+\t where we created a new version and shouldn't have.  */\n+\n+      if (!bitmap_bit_p (RVUSE_IN (block), SSA_NAME_VERSION (vuse))\n+\t  || bitmap_bit_p (RVUSE_KILL (block), SSA_NAME_VERSION\n+\t\t\t   (vuse)))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Determine if the expression EXPR is valid in SET.  This means that\n    we have a leader for each part of the expression (if it consists of\n    values), or the expression is an SSA_NAME.  \n@@ -1255,9 +1455,10 @@ find_leader (value_set_t set, tree val)\n    (IE VALUE1 + VALUE2, *VALUE1, VALUE1 < VALUE2)  */\n \n static bool\n-valid_in_set (value_set_t set, tree expr)\n+valid_in_set (value_set_t set, tree expr, basic_block block)\n {\n-  switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n+ tree vh = get_value_handle (expr);\n+ switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n     {\n     case tcc_binary:\n     case tcc_comparison:\n@@ -1292,22 +1493,35 @@ valid_in_set (value_set_t set, tree expr)\n \t\tif (!set_contains_value (set, TREE_VALUE (arglist)))\n \t\t  return false;\n \t      }\n-\t    return true;\n+\t    return !vuses_dies_in_block_x (VALUE_HANDLE_VUSES (vh), block);\n \t  }\n \treturn false;\n       }\n       \n     case tcc_reference:\n-      /* XXX: Until PRE of loads works, no reference nodes are ANTIC.  */\n+      {\n+\tif (TREE_CODE (expr) == INDIRECT_REF)\n+\t  {\n+\t    tree op0 = TREE_OPERAND (expr, 0);\n+\t    if (is_gimple_min_invariant (op0)\n+\t\t|| TREE_CODE (op0) == VALUE_HANDLE)\n+\t      {\n+\t\tbool retval = set_contains_value (set, op0);\n+\t\tif (retval)\n+\t\t  return !vuses_dies_in_block_x (VALUE_HANDLE_VUSES (vh),\n+\t\t\t\t\t\t block);\n+\t\treturn false;\n+\t      }\n+\t  }\n+      }\n       return false;\n \n     case tcc_exceptional:\n       gcc_assert (TREE_CODE (expr) == SSA_NAME);\n       return true;\n \n     case tcc_declaration:\n-      /* VAR_DECL and PARM_DECL are never anticipatable.  */\n-      return false;\n+      return !vuses_dies_in_block_x (VALUE_HANDLE_VUSES (vh), block);\n \n     default:\n       /* No other cases should be encountered.  */\n@@ -1320,15 +1534,15 @@ valid_in_set (value_set_t set, tree expr)\n    in SET.  */\n \n static void\n-clean (value_set_t set)\n+clean (value_set_t set, basic_block block)\n {\n   value_set_node_t node;\n   value_set_node_t next;\n   node = set->head;\n   while (node)\n     {\n       next = node->next;\n-      if (!valid_in_set (set, node->expr))\t\n+      if (!valid_in_set (set, node->expr, block))\t\n \tset_remove (set, node->expr);\n       node = next;\n     }\n@@ -1402,6 +1616,7 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n \t    {\n \t      tree val;\n \t      value_set_node_t next = node->next;\n+\n \t      val = get_value_handle (node->expr);\n \t      if (!set_contains_value (ANTIC_IN (bprime), val))\n \t\tset_remove (ANTIC_OUT, node->expr);\n@@ -1424,7 +1639,7 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n   for (node = S->head; node; node = node->next)\n     value_insert_into_set (ANTIC_IN (block), node->expr);\n \n-  clean (ANTIC_IN (block));\n+  clean (ANTIC_IN (block), block);\n   if (!set_equal (old, ANTIC_IN (block)))\n     changed = true;\n \n@@ -1492,7 +1707,304 @@ compute_antic (void)\n     fprintf (dump_file, \"compute_antic required %d iterations\\n\", num_iterations);\n }\n \n+/* Print the names represented by the bitmap NAMES, to the file OUT.  */\n+static void\n+dump_bitmap_of_names (FILE *out, bitmap names)\n+{\n+  bitmap_iterator bi;\n+  unsigned int i;\n+\n+  fprintf (out, \" { \");\n+  EXECUTE_IF_SET_IN_BITMAP (names, 0, i, bi)\n+    {\n+      print_generic_expr (out, ssa_name (i), 0);\n+      fprintf (out, \" \");\n+    }\n+  fprintf (out, \"}\\n\");\n+}\n+\n+  /* Compute a set of representative vuse versions for each phi.  This\n+     is so we can compute conservative kill sets in terms of all vuses\n+     that are killed, instead of continually walking chains.\n+\n+     We also have to be able kill all names associated with a phi when\n+     the phi dies in order to ensure we don't generate overlapping\n+     live ranges, which are not allowed in virtual SSA.  */\n+\n+static bitmap *vuse_names;\n+static void\n+compute_vuse_representatives (void)\n+{\n+  tree phi;\n+  basic_block bb;\n+  VEC (tree, heap) *phis = NULL;\n+  bool changed = true;\n+  size_t i;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      for (phi = phi_nodes (bb);\n+\t   phi;\n+\t   phi = PHI_CHAIN (phi))\n+\tif (!is_gimple_reg (PHI_RESULT (phi)))\n+\t  VEC_safe_push (tree, heap, phis, phi);\n+    }\n+\n+  while (changed)\n+    {\n+      changed = false;\n+\n+      for (i = 0; VEC_iterate (tree, phis, i, phi); i++)\n+\t{\n+\t  size_t ver = SSA_NAME_VERSION (PHI_RESULT (phi));\n+\t  use_operand_p usep;\n+\t  ssa_op_iter iter;\n+\n+\t  if (vuse_names[ver] == NULL)\n+\t    {\n+\t      vuse_names[ver] = BITMAP_ALLOC (&grand_bitmap_obstack);\n+\t      bitmap_set_bit (vuse_names[ver], ver);\n+\t    }\n+\t  FOR_EACH_PHI_ARG (usep, phi, iter, SSA_OP_ALL_USES)\n+\t    {\n+\t      tree use = USE_FROM_PTR (usep);\n+\t      bitmap usebitmap = get_representative (vuse_names,\n+\t\t\t\t\t\t     SSA_NAME_VERSION (use));\n+\t      if (usebitmap != NULL)\n+\t\t{\n+\t\t  changed |= bitmap_ior_into (vuse_names[ver],\n+\t\t\t\t\t      usebitmap);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  changed |= !bitmap_bit_p (vuse_names[ver],\n+\t\t\t\t\t    SSA_NAME_VERSION (use));\n+\t\t  if (changed)\n+\t\t    bitmap_set_bit (vuse_names[ver],\n+\t\t\t\t    SSA_NAME_VERSION (use));\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    for (i = 0; VEC_iterate (tree, phis, i, phi); i++)\n+      {\n+\tbitmap reps = get_representative (vuse_names,\n+\t\t\t\t\t  SSA_NAME_VERSION (PHI_RESULT (phi)));\n+\tif (reps)\n+\t  {\n+\t    print_generic_expr (dump_file, PHI_RESULT (phi), 0);\n+\t    fprintf (dump_file, \" represents \");\n+\t    dump_bitmap_of_names (dump_file, reps);\n+\t  }\n+      }\n+  VEC_free (tree, heap, phis);\n+}\n+\n+/* Compute reaching vuses.  This is a small bit of iterative dataflow\n+   to determine what virtual uses reach what blocks.  Because we can't\n+   generate overlapping virtual uses, and virtual uses *do* actually\n+   die, this ends up being faster in most cases than continually\n+   walking the virtual use/def chains to determine whether we are\n+   inside a block where a given virtual is still available to be\n+   used.  */\n+\n+static void\n+compute_rvuse (void)\n+{\n+\n+  size_t i;\n+  tree phi;\n+  basic_block bb;\n+  int *postorder;\n+  bool changed = true;\n+\n+  compute_vuse_representatives ();\n+\n+  FOR_ALL_BB (bb)\n+    {\n+      RVUSE_IN (bb) = BITMAP_ALLOC (&grand_bitmap_obstack);\n+      RVUSE_GEN (bb) = BITMAP_ALLOC (&grand_bitmap_obstack);\n+      RVUSE_KILL (bb) = BITMAP_ALLOC (&grand_bitmap_obstack);\n+      RVUSE_OUT (bb) = BITMAP_ALLOC (&grand_bitmap_obstack);\n+    }\n+\n+\n+  /* Mark live on entry */\n+  for (i = 0; i < num_ssa_names; i++)\n+    {\n+      tree name = ssa_name (i);\n+      if (name && !is_gimple_reg (name)\n+\t  && IS_EMPTY_STMT (SSA_NAME_DEF_STMT (name)))\n+\tbitmap_set_bit (RVUSE_OUT (ENTRY_BLOCK_PTR),\n+\t\t\tSSA_NAME_VERSION (name));\n+    }\n+\n+  /* Compute local sets for reaching vuses.\n+     GEN(block) = generated in block and not locally killed.\n+     KILL(block) = set of vuses killed in block.\n+  */\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator bsi;\n+      ssa_op_iter iter;\n+      def_operand_p defp;\n+      use_operand_p usep;\n+\n+\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t{\n+\t  tree stmt = bsi_stmt (bsi);\n+\t  FOR_EACH_SSA_USE_OPERAND (usep, stmt, iter, SSA_OP_VIRTUAL_KILLS\n+\t\t\t\t    | SSA_OP_VMAYUSE)\n+\t    {\n+\t      tree use = USE_FROM_PTR (usep);\n+\t      bitmap repbit = get_representative (vuse_names,\n+\t\t\t\t\t\t  SSA_NAME_VERSION (use));\n+\t      if (repbit != NULL)\n+\t\t{\n+\t\t  bitmap_and_compl_into (RVUSE_GEN (bb), repbit);\n+\t\t  bitmap_ior_into (RVUSE_KILL (bb), repbit);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  bitmap_set_bit (RVUSE_KILL (bb), SSA_NAME_VERSION (use));\n+\t\t  bitmap_clear_bit (RVUSE_GEN (bb), SSA_NAME_VERSION (use));\n+\t\t}\n+\t    }\n+\t  FOR_EACH_SSA_DEF_OPERAND (defp, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n+\t    {\n+\t      tree def = DEF_FROM_PTR (defp);\n+\t      bitmap_set_bit (RVUSE_GEN (bb), SSA_NAME_VERSION (def));\n+\t    }\n+\t}\n+    }\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  if (!is_gimple_reg (PHI_RESULT (phi)))\n+\t    {\n+\t      edge e;\n+\t      edge_iterator ei;\n+\n+\t      tree def = PHI_RESULT (phi);\n+\t      /* In reality, the PHI result is generated at the end of\n+\t\t each predecessor block.  This will make the value\n+\t\t LVUSE_IN for the bb containing the PHI, which is\n+\t\t correct.  */\n+\t      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t\tbitmap_set_bit (RVUSE_GEN (e->src), SSA_NAME_VERSION (def));\n+\t    }\n+\t}\n+    }\n+\n+  /* Solve reaching vuses.\n+\n+     RVUSE_IN[BB] = Union of RVUSE_OUT of predecessors.\n+     RVUSE_OUT[BB] = RVUSE_GEN[BB] U (RVUSE_IN[BB] - RVUSE_KILL[BB])\n+  */\n+  postorder = xmalloc (sizeof (int) * (n_basic_blocks - NUM_FIXED_BLOCKS));\n+  pre_and_rev_post_order_compute (NULL, postorder, false);\n+\n+  changed = true;\n+  while (changed)\n+    {\n+      int j;\n+      changed = false;\n+      for (j = 0; j < n_basic_blocks - NUM_FIXED_BLOCKS; j++)\n+\t{\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  bb = BASIC_BLOCK (postorder[j]);\n+\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    bitmap_ior_into (RVUSE_IN (bb), RVUSE_OUT (e->src));\n+\n+\t  changed |= bitmap_ior_and_compl (RVUSE_OUT (bb),\n+\t\t\t\t\t   RVUSE_GEN (bb),\n+\t\t\t\t\t   RVUSE_IN (bb),\n+\t\t\t\t\t   RVUSE_KILL (bb));\n+\t}\n+    }\n+  free (postorder);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      FOR_ALL_BB (bb)\n+\t{\n+\t  fprintf (dump_file, \"RVUSE_IN (%d) =\", bb->index);\n+\t  dump_bitmap_of_names (dump_file, RVUSE_IN (bb));\n+\n+\t  fprintf (dump_file, \"RVUSE_KILL (%d) =\", bb->index);\n+\t  dump_bitmap_of_names (dump_file, RVUSE_KILL (bb));\n+\n+\t  fprintf (dump_file, \"RVUSE_GEN (%d) =\", bb->index);\n+\t  dump_bitmap_of_names (dump_file, RVUSE_GEN (bb));\n+\n+\t  fprintf (dump_file, \"RVUSE_OUT (%d) =\", bb->index);\n+\t  dump_bitmap_of_names (dump_file, RVUSE_OUT (bb));\n+\t}\n+    }\n+}\n+\n+/* Return true if we can value number the call in STMT.  This is true\n+   if we have a pure or constant call.  */\n+\n+static bool\n+can_value_number_call (tree stmt)\n+{\n+  tree call = get_call_expr_in (stmt);\n+\n+  if (call_expr_flags (call)  & (ECF_PURE | ECF_CONST))\n+    return true;\n+  return false;\n+}\n+\n+/* Return true if OP is a tree which we can perform value numbering\n+   on.  */\n+\n+static bool\n+can_value_number_operation (tree op)\n+{\n+  return UNARY_CLASS_P (op)\n+    || BINARY_CLASS_P (op)\n+    || COMPARISON_CLASS_P (op)\n+    || REFERENCE_CLASS_P (op)\n+    || (TREE_CODE (op) == CALL_EXPR\n+\t&& can_value_number_call (op));\n+}\n+\n+\n+/* Return true if OP is a tree which we can perform PRE on\n+   on.  This may not match the operations we can value number, but in\n+   a perfect world would.  */\n+\n+static bool\n+can_PRE_operation (tree op)\n+{\n+  return UNARY_CLASS_P (op)\n+    || BINARY_CLASS_P (op)\n+    || COMPARISON_CLASS_P (op)\n+    || TREE_CODE (op) == INDIRECT_REF\n+    || TREE_CODE (op) == CALL_EXPR;\n+}\n+\n+\n+/* Inserted expressions are placed onto this worklist, which is used\n+   for performing quick dead code elimination of insertions we made\n+   that didn't turn out to be necessary.   */\n static VEC(tree,heap) *inserted_exprs;\n+\n+/* Pool allocated fake store expressions are placed onto this\n+   worklist, which, after performing dead code elimination, is walked\n+   to see which expressions need to be put into GC'able memory  */\n+static VEC(tree, heap) *need_creation;\n+\n+\n /* Find a leader for an expression, or generate one using\n    create_expression_by_pieces if it's ANTIC but\n    complex.  \n@@ -1512,11 +2024,8 @@ find_or_generate_expression (basic_block block, tree expr, tree stmts)\n   if (genop == NULL)\n     {\n       genop = VALUE_HANDLE_EXPR_SET (expr)->head->expr;\n-      gcc_assert (UNARY_CLASS_P (genop)\n-\t\t  || BINARY_CLASS_P (genop)\n-\t\t  || COMPARISON_CLASS_P (genop)\n-\t\t  || REFERENCE_CLASS_P (genop)\n-\t\t  || TREE_CODE (genop) == CALL_EXPR);\n+\n+      gcc_assert (can_PRE_operation (genop));\n       genop = create_expression_by_pieces (block, genop, stmts);\n     }\n   return genop;\n@@ -1568,9 +2077,9 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \t     genwalker && walker;\n \t     genwalker = TREE_CHAIN (genwalker), walker = TREE_CHAIN (walker))\n \t  {\n-\t    TREE_VALUE (genwalker) = find_or_generate_expression (block, \n-\t\t\t\t\t\t\t\t  TREE_VALUE (walker), \n-\t\t\t\t\t\t\t\t  stmts);\n+\t    TREE_VALUE (genwalker)\n+\t      = find_or_generate_expression (block, TREE_VALUE (walker),\n+\t\t\t\t\t     stmts);\n \t  }\n \n \tif (op2)\t  \n@@ -1582,6 +2091,16 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \t\n       }\n       break;\n+    case tcc_reference:\n+      gcc_assert (TREE_CODE (expr) == INDIRECT_REF);\n+      {\n+\ttree op1 = TREE_OPERAND (expr, 0);\n+\ttree genop1 = find_or_generate_expression (block, op1, stmts);\n+\n+\tfolded = fold_build1 (TREE_CODE (expr), TREE_TYPE (expr),\n+\t\t\t      genop1);\n+\tbreak;\n+      }\n       \n     case tcc_binary:\n     case tcc_comparison:\n@@ -1628,35 +2147,48 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \t  tree val = vn_lookup_or_add (forcedexpr, NULL);\n \t  \n \t  VEC_safe_push (tree, heap, inserted_exprs, stmt);\n-\t  vn_add (forcedname, val, NULL);\n+\t  vn_add (forcedname, val);\n \t  bitmap_value_replace_in_set (NEW_SETS (block), forcedname);\n \t  bitmap_value_replace_in_set (AVAIL_OUT (block), forcedname);\n+\t  update_stmt (stmt);\n+\t  mark_new_vars_to_rename (tsi_stmt (tsi));\n \t}\n       tsi = tsi_last (stmts);\n       tsi_link_after (&tsi, forced_stmts, TSI_CONTINUE_LINKING);\n     }\n \n   /* Build and insert the assignment of the end result to the temporary\n      that we will return.  */\n-  temp = create_tmp_var (TREE_TYPE (expr), \"pretmp\");\n+  if (!pretemp || TREE_TYPE (expr) != TREE_TYPE (pretemp))\n+    {\n+      pretemp = create_tmp_var (TREE_TYPE (expr), \"pretmp\");\n+      get_var_ann (pretemp);\n+    }\n+\n+  temp = pretemp;\n   add_referenced_tmp_var (temp);\n+\n   if (TREE_CODE (TREE_TYPE (expr)) == COMPLEX_TYPE)\n     DECL_COMPLEX_GIMPLE_REG_P (temp) = 1;\n+\n   newexpr = build2 (MODIFY_EXPR, TREE_TYPE (expr), temp, newexpr);\n   name = make_ssa_name (temp, newexpr);\n   TREE_OPERAND (newexpr, 0) = name;\n   NECESSARY (newexpr) = 0;\n+\n   tsi = tsi_last (stmts);\n   tsi_link_after (&tsi, newexpr, TSI_CONTINUE_LINKING);\n   VEC_safe_push (tree, heap, inserted_exprs, newexpr);\n+  update_stmt (newexpr);\n+  mark_new_vars_to_rename (newexpr);\n \n   /* Add a value handle to the temporary.\n      The value may already exist in either NEW_SETS, or AVAIL_OUT, because\n      we are creating the expression by pieces, and this particular piece of\n      the expression may have been represented.  There is no harm in replacing\n      here.  */\n   v = get_value_handle (expr);\n-  vn_add (name, v, NULL);\n+  vn_add (name, v);\n   bitmap_value_replace_in_set (NEW_SETS (block), name); \n   bitmap_value_replace_in_set (AVAIL_OUT (block), name);\n \n@@ -1671,14 +2203,14 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n   return name;\n }\n \n-/* Insert the to-be-made-available values of NODE for each predecessor, stored\n-   in AVAIL, into the predecessors of BLOCK, and merge the result with a phi\n-   node, given the same value handle as NODE.  The prefix of the phi node is\n-   given with TMPNAME.  Return true if we have inserted new stuff.  */\n+/* Insert the to-be-made-available values of NODE for each\n+   predecessor, stored in AVAIL, into the predecessors of BLOCK, and\n+   merge the result with a phi node, given the same value handle as\n+   NODE.  Return true if we have inserted new stuff.  */\n \n static bool\n insert_into_preds_of_block (basic_block block, value_set_node_t node,\n-\t\t\t    tree *avail, const char *tmpname)\n+\t\t\t    tree *avail)\n {\n   tree val = get_value_handle (node->expr);\n   edge pred;\n@@ -1694,11 +2226,15 @@ insert_into_preds_of_block (basic_block block, value_set_node_t node,\n     {\n       fprintf (dump_file, \"Found partial redundancy for expression \");\n       print_generic_expr (dump_file, node->expr, 0);\n+      fprintf (dump_file, \" (\");\n+      print_generic_expr (dump_file, val, 0);\n+      fprintf (dump_file, \")\");\n       fprintf (dump_file, \"\\n\");\n     }\n \n   /* Make sure we aren't creating an induction variable.  */\n-  if (block->loop_depth > 0 && EDGE_COUNT (block->preds) == 2)\n+  if (block->loop_depth > 0 && EDGE_COUNT (block->preds) == 2\n+      && TREE_CODE_CLASS (TREE_CODE (node->expr)) != tcc_reference )\n     {\n       bool firstinsideloop = false;\n       bool secondinsideloop = false;\n@@ -1723,11 +2259,32 @@ insert_into_preds_of_block (basic_block block, value_set_node_t node,\n       tree builtexpr;\n       bprime = pred->src;\n       eprime = avail[bprime->index];\n-      if (BINARY_CLASS_P (eprime)\n-\t  || COMPARISON_CLASS_P (eprime)\n-\t  || UNARY_CLASS_P (eprime)\n-\t  || TREE_CODE (eprime) == CALL_EXPR)\n+\n+      if (can_PRE_operation (eprime))\n \t{\n+#ifdef ENABLE_CHECKING\n+\t  tree vh;\n+\n+\t  /* eprime may be an invariant.  */\n+\t  vh = TREE_CODE (eprime) == VALUE_HANDLE \n+\t    ? eprime\n+\t    : get_value_handle (eprime);\n+\n+\t  /* ensure that the virtual uses we need reach our block.  */\n+\t  if (TREE_CODE (vh) == VALUE_HANDLE)\n+\t    {\n+\t      int i;\n+\t      tree vuse;\n+\t      for (i = 0;\n+\t\t   VEC_iterate (tree, VALUE_HANDLE_VUSES (vh), i, vuse);\n+\t\t   i++)\n+\t\t{\n+\t\t  size_t id = SSA_NAME_VERSION (vuse);\n+\t\t  gcc_assert (bitmap_bit_p (RVUSE_OUT (bprime), id)\n+\t\t\t      || IS_EMPTY_STMT (SSA_NAME_DEF_STMT (vuse)));\n+\t\t}\n+\t    }\n+#endif\n \t  builtexpr = create_expression_by_pieces (bprime,\n \t\t\t\t\t\t   eprime,\n \t\t\t\t\t\t   stmts);\n@@ -1746,17 +2303,25 @@ insert_into_preds_of_block (basic_block block, value_set_node_t node,\n     return false;\n \n   /* Now build a phi for the new variable.  */\n-  temp = create_tmp_var (type, tmpname);\n+  if (!prephitemp || TREE_TYPE (prephitemp) != type)\n+    {\n+      prephitemp = create_tmp_var (type, \"prephitmp\");\n+      get_var_ann (prephitemp);\n+    }\n+\n+  temp = prephitemp;\n   add_referenced_tmp_var (temp);\n+\n   if (TREE_CODE (type) == COMPLEX_TYPE)\n     DECL_COMPLEX_GIMPLE_REG_P (temp) = 1;\n   temp = create_phi_node (temp, block);\n+\n   NECESSARY (temp) = 0; \n   VEC_safe_push (tree, heap, inserted_exprs, temp);\n   FOR_EACH_EDGE (pred, ei, block->preds)\n     add_phi_arg (temp, avail[pred->src->index], pred);\n   \n-  vn_add (PHI_RESULT (temp), val, NULL);\n+  vn_add (PHI_RESULT (temp), val);\n   \n   /* The value should *not* exist in PHI_GEN, or else we wouldn't be doing\n      this insertion, since we test for the existence of this value in PHI_GEN\n@@ -1840,10 +2405,7 @@ insert_aux (basic_block block)\n \t\t   node;\n \t\t   node = node->next)\n \t\t{\n-\t\t  if (BINARY_CLASS_P (node->expr)\n-\t\t      || COMPARISON_CLASS_P (node->expr)\n-\t\t      || UNARY_CLASS_P (node->expr)\n-\t\t      || TREE_CODE (node->expr) == CALL_EXPR)\n+\t\t  if (can_PRE_operation (node->expr))\n \t\t    {\n \t\t      tree *avail;\n \t\t      tree val;\n@@ -1927,8 +2489,7 @@ insert_aux (basic_block block)\n \t\t\t partially redundant.  */\n \t\t      if (!cant_insert && !all_same && by_some)\n \t\t\t{\n- \t\t\t  if (insert_into_preds_of_block (block, node, avail, \n- \t\t\t\t\t\t\t  \"prephitmp\"))\n+\t\t\t  if (insert_into_preds_of_block (block, node, avail))\n  \t\t\t    new_stuff = true;\n \t\t\t}\n \t\t      /* If all edges produce the same value and that value is\n@@ -1940,11 +2501,12 @@ insert_aux (basic_block block)\n \t\t\t{\n \t\t\t  value_set_t exprset = VALUE_HANDLE_EXPR_SET (val);\n \t\t\t  value_set_node_t node;\n+\n \t\t\t  for (node = exprset->head; node; node = node->next)\n  \t\t\t    {\n \t\t\t      if (TREE_CODE (node->expr) == SSA_NAME)\n \t\t\t\t{\t\t\t\t  \n-\t\t\t\t  vn_add (node->expr, eprime, NULL);\n+\t\t\t\t  vn_add (node->expr, eprime);\n \t\t\t\t  pre_stats.constified++;\n \t\t\t\t}\n  \t\t\t    }\n@@ -2007,7 +2569,7 @@ is_undefined_value (tree expr)\n    S1 and its value handle to S2.\n \n    VUSES represent the virtual use operands associated with EXPR (if\n-   any). They are used when computing the hash value for EXPR.  */\n+   any).  */\n \n static inline void\n add_to_sets (tree var, tree expr, tree stmt, bitmap_set_t s1,\n@@ -2020,7 +2582,7 @@ add_to_sets (tree var, tree expr, tree stmt, bitmap_set_t s1,\n      statements that make aliased stores).  In those cases, we are\n      only interested in making VAR available as its own value.  */\n   if (var != expr)\n-    vn_add (var, val, NULL_TREE);\n+    vn_add (var, val);\n \n   if (s1)\n     bitmap_insert_into_set (s1, var);\n@@ -2033,8 +2595,7 @@ add_to_sets (tree var, tree expr, tree stmt, bitmap_set_t s1,\n    replaced with the value handles of each of the operands of EXPR.\n \n    VUSES represent the virtual use operands associated with EXPR (if\n-   any). They are used when computing the hash value for EXPR.\n-   Insert EXPR's operands into the EXP_GEN set for BLOCK. */\n+   any). Insert EXPR's operands into the EXP_GEN set for BLOCK. */\n \n static inline tree\n create_value_expr_from (tree expr, basic_block block, tree stmt)\n@@ -2049,7 +2610,8 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n \t      || TREE_CODE_CLASS (code) == tcc_comparison\n \t      || TREE_CODE_CLASS (code) == tcc_reference\n \t      || TREE_CODE_CLASS (code) == tcc_expression\n-\t      || TREE_CODE_CLASS (code) == tcc_exceptional);\n+\t      || TREE_CODE_CLASS (code) == tcc_exceptional\n+\t      || TREE_CODE_CLASS (code) == tcc_declaration);\n \n   if (TREE_CODE_CLASS (code) == tcc_unary)\n     pool = unary_node_pool;\n@@ -2167,21 +2729,6 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n }\n \n \n-/* Return true if we can value number a call.  This is true if we have\n-   a pure or constant call.  */\n-static bool\n-can_value_number_call (tree stmt)\n-{\n-  tree call = get_call_expr_in (stmt);\n-\n-  /* This is a temporary restriction until we translate vuses through\n-     phi nodes.  This is only needed for PRE, of course.  */\n-  if (!in_fre && !ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n-    return false;  \n-  if (call_expr_flags (call)  & (ECF_PURE | ECF_CONST))\n-    return true;\n-  return false;\n-}\n \n /* Insert extra phis to merge values that are fully available from\n    preds of BLOCK, but have no dominating representative coming from\n@@ -2221,7 +2768,16 @@ insert_extra_phis (basic_block block, basic_block dom)\n \t    {\n \t      tree name = ssa_name (i);\n \t      tree val = get_value_handle (name);\n-\t      tree temp = create_tmp_var (TREE_TYPE (name), \"mergephitmp\");\n+\t      tree temp;\n+\n+\t      if (!mergephitemp\n+\t\t  || TREE_TYPE (name) != TREE_TYPE (mergephitemp))\n+\t\t{\n+\t\t  mergephitemp = create_tmp_var (TREE_TYPE (name),\n+\t\t\t\t\t\t \"mergephitmp\");\n+\t\t  get_var_ann (mergephitemp);\n+\t\t}\n+\t      temp = mergephitemp;\n \t\t  \n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n@@ -2249,7 +2805,7 @@ insert_extra_phis (basic_block block, basic_block dom)\n \t\t    }\n \t\t}\n \n-\t      vn_add (PHI_RESULT (temp), val, NULL);\n+\t      vn_add (PHI_RESULT (temp), val);\n \t      \n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"\\n\");\n@@ -2329,6 +2885,174 @@ try_look_through_load (tree lhs, tree mem_ref, tree stmt, basic_block block)\n   return false;\n }\n \n+/* Return a copy of NODE that is stored in the temporary alloc_pool's.\n+   This is made recursively true, so that the operands are stored in\n+   the pool as well.  */\n+\n+static tree\n+poolify_tree (tree node)\n+{\n+  switch  (TREE_CODE (node))\n+    {\n+    case INDIRECT_REF:\n+      {\n+\ttree temp = pool_alloc (reference_node_pool);\n+\tmemcpy (temp, node, tree_size (node));\n+\tTREE_OPERAND (temp, 0) = poolify_tree (TREE_OPERAND (temp, 0));\n+\treturn temp;\n+      }\n+      break;\n+    case MODIFY_EXPR:\n+      {\n+\ttree temp = pool_alloc (modify_expr_node_pool);\n+\tmemcpy (temp, node, tree_size (node));\n+\tTREE_OPERAND (temp, 0) = poolify_tree (TREE_OPERAND (temp, 0));\n+\tTREE_OPERAND (temp, 1) = poolify_tree (TREE_OPERAND (temp, 1));\n+\treturn temp;\n+      }\n+      break;\n+    case SSA_NAME:\n+    case INTEGER_CST:\n+    case STRING_CST:\n+    case REAL_CST:\n+    case PARM_DECL:\n+    case VAR_DECL:\n+    case RESULT_DECL:\n+      return node;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+static tree modify_expr_template;\n+\n+/* Allocate a MODIFY_EXPR with TYPE, and operands OP1, OP2 in the\n+   alloc pools and return it.  */\n+static tree\n+poolify_modify_expr (tree type, tree op1, tree op2)\n+{\n+  if (modify_expr_template == NULL)\n+    modify_expr_template = build2 (MODIFY_EXPR, type, op1, op2);\n+\n+  TREE_OPERAND (modify_expr_template, 0) = op1;\n+  TREE_OPERAND (modify_expr_template, 1) = op2;\n+  TREE_TYPE (modify_expr_template) = type;\n+\n+  return poolify_tree (modify_expr_template);\n+}\n+\n+\n+/* For each real store operation of the form\n+   *a = <value> that we see, create a corresponding fake store of the\n+   form storetmp_<version> = *a.\n+\n+   This enables AVAIL computation to mark the results of stores as\n+   available.  Without this, you'd need to do some computation to\n+   mark the result of stores as ANTIC and AVAIL at all the right\n+   points.\n+   To save memory, we keep the store\n+   statements pool allocated until we decide whether they are\n+   necessary or not.  */\n+\n+static void\n+insert_fake_stores (void)\n+{\n+  basic_block block;\n+\n+  FOR_ALL_BB (block)\n+    {\n+      block_stmt_iterator bsi;\n+      for (bsi = bsi_start (block); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t{\n+\t  tree stmt = bsi_stmt (bsi);\n+\n+\t  /* We can't generate SSA names for stores that are complex\n+\t     or aggregate.  We also want to ignore things whose\n+\t     virtual uses occur in abnormal phis.  */\n+\n+\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (stmt, 0)) == INDIRECT_REF\n+\t      && !AGGREGATE_TYPE_P (TREE_TYPE (TREE_OPERAND (stmt, 0)))\n+\t      && TREE_CODE (TREE_TYPE (TREE_OPERAND (stmt, 0))) != COMPLEX_TYPE)\n+\t    {\n+\t      ssa_op_iter iter;\n+\t      def_operand_p defp;\n+\t      tree lhs = TREE_OPERAND (stmt, 0);\n+\t      tree rhs = TREE_OPERAND (stmt, 1);\n+\t      tree new;\n+\t      bool notokay = false;\n+\n+\t      FOR_EACH_SSA_DEF_OPERAND (defp, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n+\t\t{\n+\t\t  tree defvar = DEF_FROM_PTR (defp);\n+\t\t  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (defvar))\n+\t\t    {\n+\t\t      notokay = true;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\n+\t      if (notokay)\n+\t\tcontinue;\n+\n+\t      if (!storetemp || TREE_TYPE (rhs) != TREE_TYPE (storetemp))\n+\t\t{\n+\t\t  storetemp = create_tmp_var (TREE_TYPE (rhs), \"storetmp\");\n+\t\t  get_var_ann (storetemp);\n+\t\t}\n+\n+\t      new = poolify_modify_expr (TREE_TYPE (stmt), storetemp, lhs);\n+\n+\t      lhs = make_ssa_name (storetemp, new);\n+\t      TREE_OPERAND (new, 0) = lhs;\n+\t      create_ssa_artficial_load_stmt (new, stmt);\n+\n+\t      NECESSARY (new) = 0;\n+\t      VEC_safe_push (tree, heap, inserted_exprs, new);\n+\t      VEC_safe_push (tree, heap, need_creation, new);\n+\t      bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Turn the pool allocated fake stores that we created back into real\n+   GC allocated ones if they turned out to be necessary to PRE some\n+   expressions.  */\n+\n+static void\n+realify_fake_stores (void)\n+{\n+  unsigned int i;\n+  tree stmt;\n+\n+  for (i = 0; VEC_iterate (tree, need_creation, i, stmt); i++)\n+    {\n+      if (NECESSARY (stmt))\n+\t{\n+\t  block_stmt_iterator bsi;\n+\t  tree newstmt;\n+\n+\t  /* Mark the temp variable as referenced */\n+\t  add_referenced_tmp_var (SSA_NAME_VAR (TREE_OPERAND (stmt, 0)));\n+\n+\t  /* Put the new statement in GC memory, fix up the annotation\n+\t     and SSA_NAME_DEF_STMT on it, and then put it in place of\n+\t     the old statement in the IR stream.  */\n+\t  newstmt = unshare_expr (stmt);\n+\t  SSA_NAME_DEF_STMT (TREE_OPERAND (newstmt, 0)) = newstmt;\n+\n+\t  newstmt->common.ann = stmt->common.ann;\n+\n+\t  bsi = bsi_for_stmt (stmt);\n+\t  bsi_replace (&bsi, newstmt, true);\n+\t}\n+      else\n+\trelease_defs (stmt);\n+    }\n+}\n+\n+\n /* Compute the AVAIL set for all basic blocks.\n \n    This function performs value numbering of the statements in each basic\n@@ -2410,10 +3134,10 @@ compute_avail (void)\n \t  stmt = bsi_stmt (bsi);\n \t  ann = stmt_ann (stmt);\n \n-\t  /* We are only interested in assignments of the form\n-\t     X_i = EXPR, where EXPR represents an \"interesting\"\n-\t     computation, it has no volatile operands and X_i\n-\t     doesn't flow through an abnormal edge.  */\n+\t  /* For regular value numbering, we are only interested in\n+\t     assignments of the form X_i = EXPR, where EXPR represents\n+\t     an \"interesting\" computation, it has no volatile operands\n+\t     and X_i doesn't flow through an abnormal edge.  */\n \t  if (TREE_CODE (stmt) == MODIFY_EXPR\n \t      && !ann->has_volatile_ops\n \t      && TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME\n@@ -2429,17 +3153,11 @@ compute_avail (void)\n \t\tcontinue;\n \n \t      STRIP_USELESS_TYPE_CONVERSION (rhs);\n-\t      if (UNARY_CLASS_P (rhs)\n-\t\t  || BINARY_CLASS_P (rhs)\n-\t\t  || COMPARISON_CLASS_P (rhs)\n-\t\t  || REFERENCE_CLASS_P (rhs)\n-\t\t  || (TREE_CODE (rhs) == CALL_EXPR\n-\t\t      && can_value_number_call (stmt)))\n+\t      if (can_value_number_operation (rhs))\n \t\t{\n-\t\t  /* For binary, unary, and reference expressions,\n-\t\t     create a duplicate expression with the operands\n-\t\t     replaced with the value handles of the original\n-\t\t     RHS.  */\n+\t\t  /* For value numberable operation, create a\n+\t\t     duplicate expression with the operands replaced\n+\t\t     with the value handles of the original RHS.  */\n \t\t  tree newt = create_value_expr_from (rhs, block, stmt);\n \t\t  if (newt)\n \t\t    {\n@@ -2582,6 +3300,9 @@ mark_operand_necessary (tree op)\n \n   gcc_assert (op);\n \n+  if (TREE_CODE (op) != SSA_NAME)\n+    return NULL;\n+\n   stmt = SSA_NAME_DEF_STMT (op);\n   gcc_assert (stmt);\n \n@@ -2614,14 +3335,12 @@ remove_dead_inserted_code (void)\n   while (VEC_length (tree, worklist) > 0)\n     {\n       t = VEC_pop (tree, worklist);\n+\n+      /* PHI nodes are somewhat special in that each PHI alternative has\n+\t data and control dependencies.  All the statements feeding the\n+\t PHI node's arguments are always necessary. */\n       if (TREE_CODE (t) == PHI_NODE)\n \t{\n-\t  /* PHI nodes are somewhat special in that each PHI alternative has\n-\t     data and control dependencies.  All the statements feeding the\n-\t     PHI node's arguments are always necessary.  In aggressive mode,\n-\t     we also consider the control dependent edges leading to the\n-\t     predecessor block associated with each PHI alternative as\n-\t     necessary.  */\n \t  int k;\n \n \t  VEC_reserve (tree, heap, worklist, PHI_NUM_ARGS (t));\n@@ -2657,16 +3376,19 @@ remove_dead_inserted_code (void)\n \t    }\n \t}\n     }\n+\n   for (i = 0; VEC_iterate (tree, inserted_exprs, i, t); i++)\n     {\n       if (!NECESSARY (t))\n \t{\n \t  block_stmt_iterator bsi;\n+\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      fprintf (dump_file, \"Removing unnecessary insertion:\");\n \t      print_generic_stmt (dump_file, t, 0);\n \t    }\n+\n \t  if (TREE_CODE (t) == PHI_NODE)\n \t    {\n \t      remove_phi_node (t, NULL);\n@@ -2675,11 +3397,13 @@ remove_dead_inserted_code (void)\n \t    {\n \t      bsi = bsi_for_stmt (t);\n \t      bsi_remove (&bsi);\n+\t      release_defs (t);\n \t    }\n \t}\n     }\n   VEC_free (tree, heap, worklist);\n }\n+\n /* Initialize data structures used by PRE.  */\n \n static void\n@@ -2690,9 +3414,16 @@ init_pre (bool do_fre)\n   in_fre = do_fre;\n \n   inserted_exprs = NULL;\n+  need_creation = NULL;\n+  pretemp = NULL_TREE;\n+  storetemp = NULL_TREE;\n+  mergephitemp = NULL_TREE;\n+  prephitemp = NULL_TREE;\n+\n   vn_init ();\n   if (!do_fre)\n     current_loops = loop_optimizer_init (dump_file);\n+\n   connect_infinite_loops_to_exit ();\n   memset (&pre_stats, 0, sizeof (pre_stats));\n \n@@ -2733,6 +3464,11 @@ init_pre (bool do_fre)\n \t\t\t\t      tree_code_size (TREE_LIST), 30);  \n   comparison_node_pool = create_alloc_pool (\"Comparison tree nodes\",\n       \t\t\t\t\t    tree_code_size (EQ_EXPR), 30);\n+  modify_expr_node_pool = create_alloc_pool (\"MODIFY_EXPR nodes\",\n+\t\t\t\t\t     tree_code_size (MODIFY_EXPR),\n+\t\t\t\t\t     30);\n+  modify_expr_template = NULL;\n+\n   FOR_ALL_BB (bb)\n     {\n       EXP_GEN (bb) = set_new (true);\n@@ -2754,6 +3490,7 @@ fini_pre (bool do_fre)\n   unsigned int i;\n \n   VEC_free (tree, heap, inserted_exprs);\n+  VEC_free (tree, heap, need_creation);\n   bitmap_obstack_release (&grand_bitmap_obstack);\n   free_alloc_pool (value_set_pool);\n   free_alloc_pool (bitmap_set_pool);\n@@ -2764,6 +3501,7 @@ fini_pre (bool do_fre)\n   free_alloc_pool (list_node_pool);\n   free_alloc_pool (expression_node_pool);\n   free_alloc_pool (comparison_node_pool);\n+  free_alloc_pool (modify_expr_node_pool);\n   htab_delete (phi_translate_table);\n   remove_fake_exit_edges ();\n \n@@ -2804,7 +3542,6 @@ fini_pre (bool do_fre)\n     }\n }\n \n-\n /* Main entry point to the SSA-PRE pass.  DO_FRE is true if the caller\n    only wants to do full redundancy elimination.  */\n \n@@ -2813,6 +3550,9 @@ execute_pre (bool do_fre)\n {\n   init_pre (do_fre);\n \n+  if (!do_fre)\n+    insert_fake_stores ();\n+\n   /* Collect and value number expressions computed in each basic block.  */\n   compute_avail ();\n \n@@ -2837,8 +3577,11 @@ execute_pre (bool do_fre)\n      computing ANTIC, either, even though it's plenty fast.  */\n   if (!do_fre && n_basic_blocks < 4000)\n     {\n+      vuse_names = xcalloc (num_ssa_names, sizeof (bitmap));\n+      compute_rvuse ();\n       compute_antic ();\n       insert ();\n+      free (vuse_names);\n     }\n \n   /* Remove all the redundant expressions.  */\n@@ -2854,13 +3597,17 @@ execute_pre (bool do_fre)\n     }\n   \n   bsi_commit_edge_inserts ();\n+\n   if (!do_fre)\n-    remove_dead_inserted_code ();\n+    {\n+      remove_dead_inserted_code ();\n+      realify_fake_stores ();\n+    }\n+\n   fini_pre (do_fre);\n \n }\n \n-\n /* Gate and execute functions for PRE.  */\n \n static void"}, {"sha": "0bc5c0309df441e56cb9176a1d623ebb86ed0d91", "filename": "gcc/tree-vn.c", "status": "modified", "additions": 187, "deletions": 38, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftree-vn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftree-vn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vn.c?ref=c90186eb1a6524b144a0268f75e5bb197d18c4be", "patch": "@@ -48,8 +48,8 @@ typedef struct val_expr_pair_d\n   /* Associated expression.  */\n   tree e;\n \n-  /* for comparing Virtual uses in E.  */\n-  tree stmt;\n+  /* For comparing virtual uses in E.  */\n+  VEC (tree, gc) *vuses;\n \n   /* E's hash value.  */\n   hashval_t hashcode;\n@@ -77,34 +77,21 @@ make_value_handle (tree type)\n    any).\n    \n    VAL can be used to iterate by passing previous value numbers (it is\n-   used by iterative_hash_expr).\n-\n-   STMT is the stmt associated with EXPR for comparing virtual operands.  */\n+   used by iterative_hash_expr).  */\n \n hashval_t\n-vn_compute (tree expr, hashval_t val, tree stmt)\n+vn_compute (tree expr, hashval_t val)\n {\n-  ssa_op_iter iter;\n-  tree vuse;\n-\n   /* EXPR must not be a statement.  We are only interested in value\n      numbering expressions on the RHS of assignments.  */\n   gcc_assert (expr);\n   gcc_assert (!expr->common.ann\n \t      || expr->common.ann->common.type != STMT_ANN);\n \n   val = iterative_hash_expr (expr, val);\n-\n-  /* If the expression has virtual uses, incorporate them into the\n-     hash value computed for EXPR.  */\n-  if (stmt)\n-    FOR_EACH_SSA_TREE_OPERAND (vuse, stmt, iter, SSA_OP_VUSE)\n-      val = iterative_hash_expr (vuse,  val);\n-\n   return val;\n }\n \n-\n /* Compare two expressions E1 and E2 and return true if they are\n    equal.  */\n \n@@ -163,15 +150,26 @@ val_expr_pair_hash (const void *p)\n static int\n val_expr_pair_expr_eq (const void *p1, const void *p2)\n {\n-  bool ret;\n+  int i;\n+  tree vuse1;\n   const val_expr_pair_t ve1 = (val_expr_pair_t) p1;\n   const val_expr_pair_t ve2 = (val_expr_pair_t) p2;\n \n   if (! expressions_equal_p (ve1->e, ve2->e))\n     return false;\n \n-  ret = compare_ssa_operands_equal (ve1->stmt, ve2->stmt, SSA_OP_VUSE);\n-  return ret;\n+  if (ve1->vuses == ve2->vuses)\n+    return true;\n+\n+  if (VEC_length (tree, ve1->vuses) != VEC_length (tree, ve2->vuses))\n+    return false;\n+\n+  for (i = 0; VEC_iterate (tree, ve1->vuses, i, vuse1); i++)\n+    {\n+      if (VEC_index (tree, ve2->vuses, i) != vuse1)\n+\treturn false;\n+    }\n+  return true;\n }\n \n \n@@ -190,30 +188,86 @@ set_value_handle (tree e, tree v)\n     gcc_assert (is_gimple_min_invariant (e));\n }\n \n+/* Copy the virtual uses from STMT into a newly allocated VEC(tree),\n+   and return the VEC(tree).  */\n+\n+static VEC (tree, gc) *\n+copy_vuses_from_stmt (tree stmt)\n+{\n+  ssa_op_iter iter;\n+  tree vuse;\n+  VEC (tree, gc) *vuses = NULL;\n+\n+  if (!stmt)\n+    return NULL;\n+\n+  FOR_EACH_SSA_TREE_OPERAND (vuse, stmt, iter, SSA_OP_VUSE)\n+    VEC_safe_push (tree, gc, vuses, vuse);\n+\n+  return vuses;\n+}\n+\n+/* Place for shared_vuses_from_stmt to shove vuses.  */\n+static VEC (tree, gc) *shared_lookup_vuses;\n+\n+/* Copy the virtual uses from STMT into SHARED_LOOKUP_VUSES.\n+   This function will overwrite the current SHARED_LOOKUP_VUSES\n+   variable.  */\n+\n+static VEC (tree, gc) *\n+shared_vuses_from_stmt (tree stmt)\n+{\n+  ssa_op_iter iter;\n+  tree vuse;\n+\n+  if (!stmt)\n+    return NULL;\n+\n+  VEC_truncate (tree, shared_lookup_vuses, 0);\n+\n+  FOR_EACH_SSA_TREE_OPERAND (vuse, stmt, iter, SSA_OP_VUSE)\n+    VEC_safe_push (tree, gc, shared_lookup_vuses, vuse);\n+\n+  if (VEC_length (tree, shared_lookup_vuses) > 1)\n+    sort_vuses (shared_lookup_vuses);\n+\n+  return shared_lookup_vuses;\n+}\n+\n+/* Insert EXPR into VALUE_TABLE with value VAL, and add expression\n+   EXPR to the value set for value VAL.  */\n+\n+void\n+vn_add (tree expr, tree val)\n+{\n+  vn_add_with_vuses (expr, val, NULL);\n+}\n \n /* Insert EXPR into VALUE_TABLE with value VAL, and add expression\n-   EXPR to the value set for value VAL.  STMT represents the stmt\n-   associated with EXPR.  It is used when computing a hash value for EXPR.  */\n+   EXPR to the value set for value VAL.  VUSES represents the virtual\n+   use operands associated with EXPR.  It is used when computing a\n+   hash value for EXPR.  */\n \n void\n-vn_add (tree expr, tree val, tree stmt)\n+vn_add_with_vuses (tree expr, tree val, VEC (tree, gc) *vuses)\n {\n   void **slot;\n   val_expr_pair_t new_pair;\n   \n   new_pair = XNEW (struct val_expr_pair_d);\n   new_pair->e = expr;\n   new_pair->v = val;\n-  new_pair->stmt = stmt;\n-  new_pair->hashcode = vn_compute (expr, 0, stmt);\n+  new_pair->vuses = vuses;\n+  new_pair->hashcode = vn_compute (expr, 0);\n   slot = htab_find_slot_with_hash (value_table, new_pair, new_pair->hashcode,\n \t\t\t\t   INSERT);\n   if (*slot)\n     free (*slot);\n   *slot = (void *) new_pair;\n \n   set_value_handle (expr, val);\n-  add_to_value (val, expr);\n+  if (TREE_CODE (val) == VALUE_HANDLE)\n+    add_to_value (val, expr);\n }\n \n \n@@ -224,6 +278,17 @@ vn_add (tree expr, tree val, tree stmt)\n \n tree\n vn_lookup (tree expr, tree stmt)\n+{\n+  return vn_lookup_with_vuses (expr, shared_vuses_from_stmt (stmt));\n+}\n+\n+/* Search in VALUE_TABLE for an existing instance of expression EXPR,\n+   and return its value, or NULL if none has been set.  VUSES is the\n+   list of virtual use operands associated with EXPR.  It is used when\n+   computing the hash value for EXPR.  */\n+\n+tree\n+vn_lookup_with_vuses (tree expr, VEC (tree, gc) *vuses)\n {\n   void **slot;\n   struct val_expr_pair_d vep = {NULL, NULL, NULL, 0};\n@@ -233,8 +298,8 @@ vn_lookup (tree expr, tree stmt)\n     return expr;\n \n   vep.e = expr;\n-  vep.stmt = stmt;\n-  vep.hashcode = vn_compute (expr, 0, stmt); \n+  vep.vuses = vuses;\n+  vep.hashcode = vn_compute (expr, 0);\n   slot = htab_find_slot_with_hash (value_table, &vep, vep.hashcode, NO_INSERT);\n   if (!slot)\n     return NULL_TREE;\n@@ -243,36 +308,118 @@ vn_lookup (tree expr, tree stmt)\n }\n \n \n+/* A comparison function for use in qsort to compare vuses.  Simply\n+   subtracts version numbers.  */\n+\n+static int\n+vuses_compare (const void *pa, const void *pb)\n+{\n+  const tree vusea = *((const tree *)pa);\n+  const tree vuseb = *((const tree *)pb);\n+  int sn = SSA_NAME_VERSION (vusea) - SSA_NAME_VERSION (vuseb);\n+\n+  return sn;\n+}\n+\n+/* Print out the \"Created value <x> for <Y>\" statement to the\n+   dump_file.\n+   This is factored because both versions of lookup use it, and it\n+   obscures the real work going on in those functions.  */\n+\n+static void\n+print_creation_to_file (tree v, tree expr, VEC (tree, gc) *vuses)\n+{\n+  fprintf (dump_file, \"Created value \");\n+  print_generic_expr (dump_file, v, dump_flags);\n+  fprintf (dump_file, \" for \");\n+  print_generic_expr (dump_file, expr, dump_flags);\n+  \n+  if (vuses && VEC_length (tree, vuses) != 0)\n+    {\n+      size_t i;\n+      tree vuse;\n+      \n+      fprintf (dump_file, \" vuses: (\");\n+      for (i = 0; VEC_iterate (tree, vuses, i, vuse); i++)\n+\t{\n+\t  print_generic_expr (dump_file, vuse, dump_flags);\n+\t  if (VEC_length (tree, vuses) - 1 != i)\n+\t    fprintf (dump_file, \",\");\n+\t}\n+      fprintf (dump_file, \")\");\n+    }\t\t   \n+  fprintf (dump_file, \"\\n\");\n+}\n+\n /* Like vn_lookup, but creates a new value for expression EXPR, if\n    EXPR doesn't already have a value.  Return the existing/created\n-   value for EXPR.  STMT represents the stmt associated with EXPR.  It is used\n-   when computing the hash value for EXPR.  */\n+   value for EXPR.  STMT represents the stmt associated with EXPR.  It\n+   is used when computing the VUSES for EXPR.  */\n \n tree\n vn_lookup_or_add (tree expr, tree stmt)\n {\n   tree v = vn_lookup (expr, stmt);\n   if (v == NULL_TREE)\n     {\n+      VEC(tree,gc) *vuses;\n+\n       v = make_value_handle (TREE_TYPE (expr));\n+      vuses = copy_vuses_from_stmt (stmt);\n+      sort_vuses (vuses);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{     \n-\t  fprintf (dump_file, \"Created value \");\n-\t  print_generic_expr (dump_file, v, dump_flags);\n-\t  fprintf (dump_file, \" for \");\n-\t  print_generic_expr (dump_file, expr, dump_flags);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n+\tprint_creation_to_file (v, expr, vuses);\n \n-      vn_add (expr, v, stmt);\n+      VALUE_HANDLE_VUSES (v) = vuses;\n+      vn_add_with_vuses (expr, v, vuses);\n     }\n \n   set_value_handle (expr, v);\n \n   return v;\n }\n \n+/* Sort the VUSE array so that we can do equality comparisons\n+   quicker on two vuse vecs.  */\n+\n+void \n+sort_vuses (VEC (tree,gc) *vuses)\n+{\n+  if (VEC_length (tree, vuses) > 1)\n+    qsort (VEC_address (tree, vuses),\n+\t   VEC_length (tree, vuses),\n+\t   sizeof (tree),\n+\t   vuses_compare);\n+}\n+\n+/* Like vn_lookup, but creates a new value for expression EXPR, if\n+   EXPR doesn't already have a value.  Return the existing/created\n+   value for EXPR.  STMT represents the stmt associated with EXPR.  It is used\n+   when computing the hash value for EXPR.  */\n+\n+tree\n+vn_lookup_or_add_with_vuses (tree expr, VEC (tree, gc) *vuses)\n+{\n+  tree v = vn_lookup_with_vuses (expr, vuses);\n+  if (v == NULL_TREE)\n+    {\n+      v = make_value_handle (TREE_TYPE (expr));\n+      sort_vuses (vuses);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tprint_creation_to_file (v, expr, vuses);\n+\n+      VALUE_HANDLE_VUSES (v) = vuses;\n+      vn_add_with_vuses (expr, v, vuses);\n+    }\n+\n+  set_value_handle (expr, v);\n+\n+  return v;\n+}\n+\n+\n \n /* Get the value handle of EXPR.  This is the only correct way to get\n    the value handle for a \"thing\".  If EXPR does not have a value\n@@ -306,6 +453,7 @@ vn_init (void)\n {\n   value_table = htab_create (511, val_expr_pair_hash,\n \t\t\t     val_expr_pair_expr_eq, free);\n+  shared_lookup_vuses = NULL;\n }\n \n \n@@ -315,5 +463,6 @@ void\n vn_delete (void)\n {\n   htab_delete (value_table);\n+  VEC_free (tree, gc, shared_lookup_vuses);\n   value_table = NULL;\n }"}, {"sha": "78c3bc33738abf1cd0e250d41fb63b1e6e809eb6", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90186eb1a6524b144a0268f75e5bb197d18c4be/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c90186eb1a6524b144a0268f75e5bb197d18c4be", "patch": "@@ -2814,6 +2814,9 @@ struct tree_statement_list\n #define VALUE_HANDLE_EXPR_SET(NODE)\t\\\n   (VALUE_HANDLE_CHECK (NODE)->value_handle.expr_set)\n \n+#define VALUE_HANDLE_VUSES(NODE)        \\\n+  (VALUE_HANDLE_CHECK (NODE)->value_handle.vuses)\n+\n /* Defined and used in tree-ssa-pre.c.  */\n struct value_set;\n \n@@ -2828,6 +2831,9 @@ struct tree_value_handle GTY(())\n      conveniently dense form starting at 0, so that we can make\n      bitmaps of value handles.  */\n   unsigned int id;\n+\n+  /* Set of virtual uses represented by this handle.  */\n+  VEC (tree, gc) *vuses;\n };\n \f\n /* Define the overall contents of a tree node."}]}