{"sha": "d30fe1c5cdc98c83c1d29d6b20f88a13328faddd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMwZmUxYzVjZGM5OGM4M2MxZDI5ZDZiMjBmODhhMTMzMjhmYWRkZA==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2011-04-16T17:43:03Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2011-04-16T17:43:03Z"}, "message": "Replace sprintf with snprintf\n\nFrom-SVN: r172590", "tree": {"sha": "a18b46c3ac70b0e29558cbe228eaa2af23e758b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a18b46c3ac70b0e29558cbe228eaa2af23e758b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/comments", "author": null, "committer": null, "parents": [{"sha": "9c575e20c33a032619b063d243f6e7320fcda878", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c575e20c33a032619b063d243f6e7320fcda878", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c575e20c33a032619b063d243f6e7320fcda878"}], "stats": {"total": 252, "additions": 134, "deletions": 118}, "files": [{"sha": "012ebe8a69f61fb2a91b76b461d72716435e79fc", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=d30fe1c5cdc98c83c1d29d6b20f88a13328faddd", "patch": "@@ -1,3 +1,33 @@\n+2011-04-16  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\t* intrinsics/date_and_time.c (date_and_time): Remove sprintf CPP\n+\tbranch.\n+\t* io/format.c (format_error): Use snprintf instead of sprintf.\n+\t* io/list_read.c: Move snprintf fallback macro to libgfortran.h.\n+\t(convert_integer): Use snprintf instead of sprintf.\n+\t(parse_repeat): Likewise.\n+\t(read_logical): Likewise.\n+\t(read_integer): Likewise.\n+\t(read_character): Likewise.\n+\t(parse_real): Likewise.\n+\t(read_complex): Likewise.\n+\t(read_real): Likewise.\n+\t(check_type): Likewise.\n+\t(nml_parse_qualifier): Add string length argument, use snprintf\n+\tinstead of sprintf.\n+\t(nml_get_obj_data): Use snprintf instead of sprintf.\n+\t* io/open.c (new_unit): Remove sprintf CPP branch, use snprintf\n+\tinstead of sprintf.\n+\t* io/transfer.c (require_type): Use snprintf instead of sprintf.\n+\t* io/unix.c (tempfile): Likewise.\n+\t* io/write.c (nml_write_obj): Likewise.\n+\t* io/write_float.def (output_float): Remove sprintf CPP branch,\n+\tuse snprintf instead of sprintf.\n+\t* libgfortran.h: Add fallback snprintf macro from io/list_read.c.\n+\t* runtime/backtrace.c (show_backtrace): Remove sprintf CPP branch.\n+\t* runtime/main.c (store_exe_path): Use snprintf instead of\n+\tsprintf.\n+\n 2011-04-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/48589\n@@ -20,7 +50,6 @@\n \t* intrinsics/system_clock.c: Use weakrefs only when needed and\n \tsupported.\n \n->>>>>>> .r172501\n 2011-04-12  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* configure.ac: Use AC_TYPE_* to make sure we have (u)intptr_t,"}, {"sha": "fa51d5f5ba287734ae5aa6c4e8f9abacbf91b6c8", "filename": "libgfortran/intrinsics/date_and_time.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fintrinsics%2Fdate_and_time.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fintrinsics%2Fdate_and_time.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fdate_and_time.c?ref=d30fe1c5cdc98c83c1d29d6b20f88a13328faddd", "patch": "@@ -168,7 +168,6 @@ date_and_time (char *__date, char *__time, char *__zone,\n       values[5] = local_time.tm_min;\n       values[6] = local_time.tm_sec;\n \n-#if HAVE_SNPRINTF\n       if (__date)\n \tsnprintf (date, DATE_LEN + 1, \"%04d%02d%02d\",\n \t\t  values[0], values[1], values[2]);\n@@ -179,18 +178,6 @@ date_and_time (char *__date, char *__time, char *__zone,\n       if (__zone)\n \tsnprintf (zone, ZONE_LEN + 1, \"%+03d%02d\",\n \t\t  values[3] / 60, abs (values[3] % 60));\n-#else\n-      if (__date)\n-\tsprintf (date, \"%04d%02d%02d\", values[0], values[1], values[2]);\n-\n-      if (__time)\n-\tsprintf (timec, \"%02d%02d%02d.%03d\",\n-\t\t values[4], values[5], values[6], values[7]);\n-\n-      if (__zone)\n-\tsprintf (zone, \"%+03d%02d\",\n-\t\t values[3] / 60, abs (values[3] % 60));\n-#endif\n     }\n   else\n     {"}, {"sha": "5760e0cb38b946b6362384b2216514262c819c61", "filename": "libgfortran/io/format.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fio%2Fformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fio%2Fformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fformat.c?ref=d30fe1c5cdc98c83c1d29d6b20f88a13328faddd", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    F2003 I/O support contributed by Jerry DeLisle\n@@ -1127,16 +1127,17 @@ void\n format_error (st_parameter_dt *dtp, const fnode *f, const char *message)\n {\n   int width, i, j, offset;\n-  char *p, buffer[300];\n+#define BUFLEN 300\n+  char *p, buffer[BUFLEN];\n   format_data *fmt = dtp->u.p.fmt;\n \n   if (f != NULL)\n     fmt->format_string = f->source;\n \n   if (message == unexpected_element)\n-    sprintf (buffer, message, fmt->error_element);\n+    snprintf (buffer, BUFLEN, message, fmt->error_element);\n   else\n-    sprintf (buffer, \"%s\\n\", message);\n+    snprintf (buffer, BUFLEN, \"%s\\n\", message);\n \n   j = fmt->format_string - dtp->format;\n "}, {"sha": "38a92e1ba401f2634af31c56eb581bc9178ee52d", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 61, "deletions": 46, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=d30fe1c5cdc98c83c1d29d6b20f88a13328faddd", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010\n+/* Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    Namelist input contributed by Paul Thomas\n@@ -63,10 +63,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #define MAX_REPEAT 200000000\n \n-#ifndef HAVE_SNPRINTF\n-# undef snprintf\n-# define snprintf(str, size, ...) sprintf (str, __VA_ARGS__)\n-#endif\n+\n+#define MSGLEN 100\n \n /* Save a character to a string buffer, enlarging it as necessary.  */\n \n@@ -471,7 +469,7 @@ nml_bad_return (st_parameter_dt *dtp, char c)\n static int\n convert_integer (st_parameter_dt *dtp, int length, int negative)\n {\n-  char c, *buffer, message[100];\n+  char c, *buffer, message[MSGLEN];\n   int m;\n   GFC_INTEGER_LARGEST v, max, max10;\n \n@@ -511,7 +509,7 @@ convert_integer (st_parameter_dt *dtp, int length, int negative)\n \n       if (dtp->u.p.repeat_count == 0)\n \t{\n-\t  sprintf (message, \"Zero repeat count in item %d of list input\",\n+\t  snprintf (message, MSGLEN, \"Zero repeat count in item %d of list input\",\n \t\t   dtp->u.p.item_count);\n \n \t  generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n@@ -524,10 +522,10 @@ convert_integer (st_parameter_dt *dtp, int length, int negative)\n \n  overflow:\n   if (length == -1)\n-    sprintf (message, \"Repeat count overflow in item %d of list input\",\n+    snprintf (message, MSGLEN, \"Repeat count overflow in item %d of list input\",\n \t     dtp->u.p.item_count);\n   else\n-    sprintf (message, \"Integer overflow while reading item %d\",\n+    snprintf (message, MSGLEN, \"Integer overflow while reading item %d\",\n \t     dtp->u.p.item_count);\n \n   free_saved (dtp);\n@@ -544,7 +542,7 @@ convert_integer (st_parameter_dt *dtp, int length, int negative)\n static int\n parse_repeat (st_parameter_dt *dtp)\n {\n-  char message[100];\n+  char message[MSGLEN];\n   int c, repeat;\n \n   if ((c = next_char (dtp)) == EOF)\n@@ -575,7 +573,7 @@ parse_repeat (st_parameter_dt *dtp)\n \n \t  if (repeat > MAX_REPEAT)\n \t    {\n-\t      sprintf (message,\n+\t      snprintf (message, MSGLEN,\n \t\t       \"Repeat count overflow in item %d of list input\",\n \t\t       dtp->u.p.item_count);\n \n@@ -588,7 +586,7 @@ parse_repeat (st_parameter_dt *dtp)\n \tcase '*':\n \t  if (repeat == 0)\n \t    {\n-\t      sprintf (message,\n+\t      snprintf (message, MSGLEN,\n \t\t       \"Zero repeat count in item %d of list input\",\n \t\t       dtp->u.p.item_count);\n \n@@ -617,7 +615,7 @@ parse_repeat (st_parameter_dt *dtp)\n     }\n   else\n     eat_line (dtp);\n-  sprintf (message, \"Bad repeat count in item %d of list input\",\n+  snprintf (message, MSGLEN, \"Bad repeat count in item %d of list input\",\n \t   dtp->u.p.item_count);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n   return 1;\n@@ -647,7 +645,7 @@ l_push_char (st_parameter_dt *dtp, char c)\n static void\n read_logical (st_parameter_dt *dtp, int length)\n {\n-  char message[100];\n+  char message[MSGLEN];\n   int c, i, v;\n \n   if (parse_repeat (dtp))\n@@ -770,7 +768,7 @@ read_logical (st_parameter_dt *dtp, int length)\n     }\n   else if (c != '\\n')\n     eat_line (dtp);\n-  sprintf (message, \"Bad logical value while reading item %d\",\n+  snprintf (message, MSGLEN, \"Bad logical value while reading item %d\",\n \t      dtp->u.p.item_count);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n   return;\n@@ -793,7 +791,7 @@ read_logical (st_parameter_dt *dtp, int length)\n static void\n read_integer (st_parameter_dt *dtp, int length)\n {\n-  char message[100];\n+  char message[MSGLEN];\n   int c, negative;\n \n   negative = 0;\n@@ -908,7 +906,7 @@ read_integer (st_parameter_dt *dtp, int length)\n     }\n   else if (c != '\\n')\n     eat_line (dtp);\n-  sprintf (message, \"Bad integer for item %d in list input\",\n+  snprintf (message, MSGLEN, \"Bad integer for item %d in list input\",\n \t      dtp->u.p.item_count);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n \n@@ -935,7 +933,7 @@ read_integer (st_parameter_dt *dtp, int length)\n static void\n read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n {\n-  char quote, message[100];\n+  char quote, message[MSGLEN];\n   int c;\n \n   quote = ' ';\t\t\t/* Space means no quote character.  */\n@@ -1086,7 +1084,7 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n \t  hit_eof (dtp);\n \t  return;\n \t}\n-      sprintf (message, \"Invalid string input in item %d\",\n+      snprintf (message, MSGLEN, \"Invalid string input in item %d\",\n \t\t  dtp->u.p.item_count);\n       generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n     }\n@@ -1099,7 +1097,7 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n static int\n parse_real (st_parameter_dt *dtp, void *buffer, int length)\n {\n-  char message[100];\n+  char message[MSGLEN];\n   int c, m, seen_dp;\n \n   if ((c = next_char (dtp)) == EOF)\n@@ -1284,7 +1282,7 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n     }\n   else if (c != '\\n')\n     eat_line (dtp);\n-  sprintf (message, \"Bad floating point number for item %d\",\n+  snprintf (message, MSGLEN, \"Bad floating point number for item %d\",\n \t      dtp->u.p.item_count);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n \n@@ -1298,7 +1296,7 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n static void\n read_complex (st_parameter_dt *dtp, void * dest, int kind, size_t size)\n {\n-  char message[100];\n+  char message[MSGLEN];\n   int c;\n \n   if (parse_repeat (dtp))\n@@ -1388,7 +1386,7 @@ read_complex (st_parameter_dt *dtp, void * dest, int kind, size_t size)\n     }\n   else if (c != '\\n')   \n     eat_line (dtp);\n-  sprintf (message, \"Bad complex value in item %d of list input\",\n+  snprintf (message, MSGLEN, \"Bad complex value in item %d of list input\",\n \t      dtp->u.p.item_count);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n }\n@@ -1399,7 +1397,7 @@ read_complex (st_parameter_dt *dtp, void * dest, int kind, size_t size)\n static void\n read_real (st_parameter_dt *dtp, void * dest, int length)\n {\n-  char message[100];\n+  char message[MSGLEN];\n   int c;\n   int seen_dp;\n   int is_inf;\n@@ -1760,7 +1758,7 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n   else if (c != '\\n')\n     eat_line (dtp);\n \n-  sprintf (message, \"Bad real number in item %d of list input\",\n+  snprintf (message, MSGLEN, \"Bad real number in item %d of list input\",\n \t      dtp->u.p.item_count);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n }\n@@ -1772,11 +1770,11 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n static int\n check_type (st_parameter_dt *dtp, bt type, int len)\n {\n-  char message[100];\n+  char message[MSGLEN];\n \n   if (dtp->u.p.saved_type != BT_UNKNOWN && dtp->u.p.saved_type != type)\n     {\n-      sprintf (message, \"Read type %s where %s was expected for item %d\",\n+      snprintf (message, MSGLEN, \"Read type %s where %s was expected for item %d\",\n \t\t  type_name (dtp->u.p.saved_type), type_name (type),\n \t\t  dtp->u.p.item_count);\n \n@@ -1789,7 +1787,7 @@ check_type (st_parameter_dt *dtp, bt type, int len)\n \n   if (dtp->u.p.saved_length != len)\n     {\n-      sprintf (message,\n+      snprintf (message, MSGLEN,\n \t\t  \"Read kind %d %s where kind %d is required for item %d\",\n \t\t  dtp->u.p.saved_length, type_name (dtp->u.p.saved_type), len,\n \t\t  dtp->u.p.item_count);\n@@ -2040,6 +2038,7 @@ void namelist_read (st_parameter_dt *dtp)\n static try\n nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t\t     array_loop_spec *ls, int rank, char *parse_err_msg,\n+\t\t     size_t parse_err_msg_size,\n \t\t     int *parsed_rank)\n {\n   int dim;\n@@ -2109,9 +2108,11 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t\t      || (c==')' && dim < rank -1))\n \t\t    {\n \t\t      if (is_char)\n-\t\t        sprintf (parse_err_msg, \"Bad substring qualifier\");\n+\t\t        snprintf (parse_err_msg, parse_err_msg_size, \n+\t\t\t\t  \"Bad substring qualifier\");\n \t\t      else\n-\t\t\tsprintf (parse_err_msg, \"Bad number of index fields\");\n+\t\t\tsnprintf (parse_err_msg, parse_err_msg_size, \n+\t\t\t\t \"Bad number of index fields\");\n \t\t      goto err_ret;\n \t\t    }\n \t\t  break;\n@@ -2128,36 +2129,41 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \n \t\tdefault:\n \t\t  if (is_char)\n-\t\t    sprintf (parse_err_msg,\n+\t\t    snprintf (parse_err_msg, parse_err_msg_size,\n \t\t\t     \"Bad character in substring qualifier\");\n \t\t  else\n-\t\t    sprintf (parse_err_msg, \"Bad character in index\");\n+\t\t    snprintf (parse_err_msg, parse_err_msg_size, \n+\t\t\t      \"Bad character in index\");\n \t\t  goto err_ret;\n \t\t}\n \n \t      if ((c == ',' || c == ')') && indx == 0\n \t\t  && dtp->u.p.saved_string == 0)\n \t\t{\n \t\t  if (is_char)\n-\t\t    sprintf (parse_err_msg, \"Null substring qualifier\");\n+\t\t    snprintf (parse_err_msg, parse_err_msg_size, \n+\t\t\t      \"Null substring qualifier\");\n \t\t  else\n-\t\t    sprintf (parse_err_msg, \"Null index field\");\n+\t\t    snprintf (parse_err_msg, parse_err_msg_size, \n+\t\t\t      \"Null index field\");\n \t\t  goto err_ret;\n \t\t}\n \n \t      if ((c == ':' && indx == 1 && dtp->u.p.saved_string == 0)\n \t\t  || (indx == 2 && dtp->u.p.saved_string == 0))\n \t\t{\n \t\t  if (is_char)\n-\t\t    sprintf (parse_err_msg, \"Bad substring qualifier\");\n+\t\t    snprintf (parse_err_msg, parse_err_msg_size, \n+\t\t\t      \"Bad substring qualifier\");\n \t\t  else\n-\t\t    sprintf (parse_err_msg, \"Bad index triplet\");\n+\t\t    snprintf (parse_err_msg, parse_err_msg_size,\n+\t\t\t      \"Bad index triplet\");\n \t\t  goto err_ret;\n \t\t}\n \n \t      if (is_char && !is_array_section)\n \t\t{\n-\t\t  sprintf (parse_err_msg,\n+\t\t  snprintf (parse_err_msg, parse_err_msg_size,\n \t\t\t   \"Missing colon in substring qualifier\");\n \t\t  goto err_ret;\n \t\t}\n@@ -2175,9 +2181,11 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t      if (convert_integer (dtp, sizeof(index_type), neg))\n \t\t{\n \t\t  if (is_char)\n-\t\t    sprintf (parse_err_msg, \"Bad integer substring qualifier\");\n+\t\t    snprintf (parse_err_msg, parse_err_msg_size,\n+\t\t\t      \"Bad integer substring qualifier\");\n \t\t  else\n-\t\t    sprintf (parse_err_msg, \"Bad integer in index\");\n+\t\t    snprintf (parse_err_msg, parse_err_msg_size,\n+\t\t\t      \"Bad integer in index\");\n \t\t  goto err_ret;\n \t\t}\n \t      break;\n@@ -2235,16 +2243,19 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t   || (ls[dim].end < GFC_DIMENSION_LBOUND(ad[dim])))\n \t{\n \t  if (is_char)\n-\t    sprintf (parse_err_msg, \"Substring out of range\");\n+\t    snprintf (parse_err_msg, parse_err_msg_size, \n+\t\t      \"Substring out of range\");\n \t  else\n-\t    sprintf (parse_err_msg, \"Index %d out of range\", dim + 1);\n+\t    snprintf (parse_err_msg, parse_err_msg_size, \n+\t\t      \"Index %d out of range\", dim + 1);\n \t  goto err_ret;\n \t}\n \n       if (((ls[dim].end - ls[dim].start ) * ls[dim].step < 0)\n \t  || (ls[dim].step == 0))\n \t{\n-\t  sprintf (parse_err_msg, \"Bad range in index %d\", dim + 1);\n+\t  snprintf (parse_err_msg, parse_err_msg_size, \n+\t\t   \"Bad range in index %d\", dim + 1);\n \t  goto err_ret;\n \t}\n \n@@ -2732,7 +2743,8 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \treturn FAILURE;\n       if (c != '?')\n \t{\n-\t  sprintf (nml_err_msg, \"namelist read: misplaced = sign\");\n+\t  snprintf (nml_err_msg, nml_err_msg_size, \n+\t\t    \"namelist read: misplaced = sign\");\n \t  goto nml_err_ret;\n \t}\n       nml_query (dtp, '=');\n@@ -2747,7 +2759,8 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n       nml_match_name (dtp, \"end\", 3);\n       if (dtp->u.p.nml_read_error)\n \t{\n-\t  sprintf (nml_err_msg, \"namelist not terminated with / or &end\");\n+\t  snprintf (nml_err_msg, nml_err_msg_size, \n+\t\t    \"namelist not terminated with / or &end\");\n \t  goto nml_err_ret;\n \t}\n     case '/':\n@@ -2838,7 +2851,8 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n     {\n       parsed_rank = 0;\n       if (nml_parse_qualifier (dtp, nl->dim, nl->ls, nl->var_rank,\n-\t\t\t       nml_err_msg, &parsed_rank) == FAILURE)\n+\t\t\t       nml_err_msg, nml_err_msg_size, \n+\t\t\t       &parsed_rank) == FAILURE)\n \t{\n \t  char *nml_err_msg_end = strchr (nml_err_msg, '\\0');\n \t  snprintf (nml_err_msg_end,\n@@ -2893,7 +2907,8 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n       descriptor_dimension chd[1] = { {1, clow, nl->string_length} };\n       array_loop_spec ind[1] = { {1, clow, nl->string_length, 1} };\n \n-      if (nml_parse_qualifier (dtp, chd, ind, -1, nml_err_msg, &parsed_rank)\n+      if (nml_parse_qualifier (dtp, chd, ind, -1, nml_err_msg, \n+\t\t\t       nml_err_msg_size, &parsed_rank)\n \t  == FAILURE)\n \t{\n \t  char *nml_err_msg_end = strchr (nml_err_msg, '\\0');"}, {"sha": "bcf7941c20af9f0b3289ff0451474624c186c9e0", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=d30fe1c5cdc98c83c1d29d6b20f88a13328faddd", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010\n+/* Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    F2003 I/O support contributed by Jerry DeLisle\n@@ -467,12 +467,8 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n \tbreak;\n \n       opp->file = tmpname;\n-#ifdef HAVE_SNPRINTF\n       opp->file_len = snprintf(opp->file, sizeof (tmpname), \"fort.%d\", \n \t\t\t       (int) opp->common.unit);\n-#else\n-      opp->file_len = sprintf(opp->file, \"fort.%d\", (int) opp->common.unit);\n-#endif\n       break;\n \n     default:\n@@ -504,26 +500,29 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n   if (s == NULL)\n     {\n       char *path, *msg;\n+      size_t msglen;\n       path = (char *) gfc_alloca (opp->file_len + 1);\n-      msg = (char *) gfc_alloca (opp->file_len + 51);\n+      msglen = opp->file_len + 51;\n+      msg = (char *) gfc_alloca (msglen);\n       unpack_filename (path, opp->file, opp->file_len);\n \n       switch (errno)\n \t{\n \tcase ENOENT: \n-\t  sprintf (msg, \"File '%s' does not exist\", path);\n+\t  snprintf (msg, msglen, \"File '%s' does not exist\", path);\n \t  break;\n \n \tcase EEXIST:\n-\t  sprintf (msg, \"File '%s' already exists\", path);\n+\t  snprintf (msg, msglen, \"File '%s' already exists\", path);\n \t  break;\n \n \tcase EACCES:\n-\t  sprintf (msg, \"Permission denied trying to open file '%s'\", path);\n+\t  snprintf (msg, msglen, \n+\t\t    \"Permission denied trying to open file '%s'\", path);\n \t  break;\n \n \tcase EISDIR:\n-\t  sprintf (msg, \"'%s' is a directory\", path);\n+\t  snprintf (msg, msglen, \"'%s' is a directory\", path);\n \t  break;\n \n \tdefault:"}, {"sha": "12aca9779b6252bd2f51f95c20e41780f7138d10", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=d30fe1c5cdc98c83c1d29d6b20f88a13328faddd", "patch": "@@ -1047,13 +1047,15 @@ write_constant_string (st_parameter_dt *dtp, const fnode *f)\n static int\n require_type (st_parameter_dt *dtp, bt expected, bt actual, const fnode *f)\n {\n-  char buffer[100];\n+#define BUFLEN 100\n+  char buffer[BUFLEN];\n \n   if (actual == expected)\n     return 0;\n \n   /* Adjust item_count before emitting error message.  */\n-  sprintf (buffer, \"Expected %s for item %d in formatted transfer, got %s\",\n+  snprintf (buffer, BUFLEN, \n+\t    \"Expected %s for item %d in formatted transfer, got %s\",\n \t   type_name (expected), dtp->u.p.item_count - 1, type_name (actual));\n \n   format_error (dtp, f, buffer);"}, {"sha": "429507191564601328d80c01d105b7bb8b98302b", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=d30fe1c5cdc98c83c1d29d6b20f88a13328faddd", "patch": "@@ -1068,7 +1068,8 @@ tempfile (st_parameter_open *opp)\n   template = get_mem (tempdirlen + 23);\n \n #ifdef HAVE_MKSTEMP\n-  sprintf (template, \"%s%sgfortrantmpXXXXXX\", tempdir, slash);\n+  snprintf (template, tempdirlen + 23, \"%s%sgfortrantmpXXXXXX\", \n+\t    tempdir, slash);\n \n   fd = mkstemp (template);\n \n@@ -1078,7 +1079,8 @@ tempfile (st_parameter_open *opp)\n   slashlen = strlen (slash);\n   do\n     {\n-      sprintf (template, \"%s%sgfortrantmpaaaXXXXXX\", tempdir, slash);\n+      snprintf (template, tempdirlen + 23, \"%s%sgfortrantmpaaaXXXXXX\", \n+\t\ttempdir, slash);\n       if (count > 0)\n \t{\n \t  int c = count;"}, {"sha": "5338162bc6ce06c657763df6683d165dd5c45c38", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=d30fe1c5cdc98c83c1d29d6b20f88a13328faddd", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    Namelist output contributed by Paul Thomas\n@@ -1689,6 +1689,7 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n   char cup;\n   char * obj_name;\n   char * ext_name;\n+  size_t ext_name_len;\n   char rep_buff[NML_DIGITS];\n   namelist_info * cmp;\n   namelist_info * retval = obj->next;\n@@ -1797,7 +1798,7 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \t{\n \t  if (rep_ctr > 1)\n \t    {\n-\t      sprintf(rep_buff, \" %d*\", rep_ctr);\n+\t      snprintf(rep_buff, NML_DIGITS, \" %d*\", rep_ctr);\n \t      write_character (dtp, rep_buff, 1, strlen (rep_buff));\n \t      dtp->u.p.no_leading_blank = 1;\n \t    }\n@@ -1851,11 +1852,9 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \n \t      base_name_len = base_name ? strlen (base_name) : 0;\n \t      base_var_name_len = base ? strlen (base->var_name) : 0;\n-\t      ext_name = (char*)get_mem ( base_name_len\n-\t\t\t\t\t+ base_var_name_len\n-\t\t\t\t\t+ strlen (obj->var_name)\n-\t\t\t\t\t+ obj->var_rank * NML_DIGITS\n-\t\t\t\t\t+ 1);\n+\t      ext_name_len = base_name_len + base_var_name_len \n+\t\t+ strlen (obj->var_name) + obj->var_rank * NML_DIGITS + 1;\n+\t      ext_name = (char*)get_mem (ext_name_len);\n \n \t      memcpy (ext_name, base_name, base_name_len);\n \t      clen = strlen (obj->var_name + base_var_name_len);\n@@ -1872,7 +1871,8 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \t\t      ext_name[tot_len] = '(';\n \t\t      tot_len++;\n \t\t    }\n-\t\t  sprintf (ext_name + tot_len, \"%d\", (int) obj->ls[dim_i].idx);\n+\t\t  snprintf (ext_name + tot_len, ext_name_len - tot_len, \"%d\", \n+\t\t\t    (int) obj->ls[dim_i].idx);\n \t\t  tot_len += strlen (ext_name + tot_len);\n \t\t  ext_name[tot_len] = ((int) dim_i == obj->var_rank - 1) ? ')' : ',';\n \t\t  tot_len++;"}, {"sha": "1fa797ed0d4c477fe2e6da60087c57ec61fc7ec3", "filename": "libgfortran/io/write_float.def", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fio%2Fwrite_float.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fio%2Fwrite_float.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite_float.def?ref=d30fe1c5cdc98c83c1d29d6b20f88a13328faddd", "patch": "@@ -524,11 +524,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n \t      *(out4++) = expchar;\n \t      edigits--;\n \t    }\n-#if HAVE_SNPRINTF\n \t  snprintf (buffer, size, \"%+0*d\", edigits, e);\n-#else\n-\t  sprintf (buffer, \"%+0*d\", edigits, e);\n-#endif\n \t  memcpy4 (out4, buffer, edigits);\n \t}\n \n@@ -616,11 +612,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n \t  *(out++) = expchar;\n \t  edigits--;\n \t}\n-#if HAVE_SNPRINTF\n       snprintf (buffer, size, \"%+0*d\", edigits, e);\n-#else\n-      sprintf (buffer, \"%+0*d\", edigits, e);\n-#endif\n       memcpy (out, buffer, edigits);\n     }\n \n@@ -940,7 +932,7 @@ OUTPUT_FLOAT_FMT_G(16)\n \n /* Define a macro to build code for write_float.  */\n \n-  /* Note: Before output_float is called, sprintf is used to print to buffer the\n+  /* Note: Before output_float is called, snprintf is used to print to buffer the\n      number in the format +D.DDDDe+ddd. For an N digit exponent, this gives us\n      (MIN_FIELD_WIDTH-5)-N digits after the decimal point, plus another one\n      before the decimal point.\n@@ -961,8 +953,6 @@ OUTPUT_FLOAT_FMT_G(16)\n        equal to the precision. The exponent always contains at least two\n        digits; if the value is zero, the exponent is 00.  */\n \n-#ifdef HAVE_SNPRINTF\n-\n #define DTOA \\\n snprintf (buffer, size, \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\" \\\n \t  \"e\", ndigits - 1, tmp);\n@@ -971,17 +961,6 @@ snprintf (buffer, size, \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\" \\\n snprintf (buffer, size, \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\" \\\n \t  \"Le\", ndigits - 1, tmp);\n \n-#else\n-\n-#define DTOA \\\n-sprintf (buffer, \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\" \\\n-\t \"e\", ndigits - 1, tmp);\n-\n-#define DTOAL \\\n-sprintf (buffer, \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\" \\\n-\t \"Le\", ndigits - 1, tmp);\n-\n-#endif\n \n #if defined(GFC_REAL_16_IS_FLOAT128)\n #define DTOAQ \\"}, {"sha": "6cccacadabe9d9e84845c97bfd0beb39fa4ac7a5", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=d30fe1c5cdc98c83c1d29d6b20f88a13328faddd", "patch": "@@ -119,6 +119,10 @@ extern int __mingw_snprintf (char *, size_t, const char *, ...)\n      __attribute__ ((format (gnu_printf, 3, 4)));\n #undef snprintf\n #define snprintf __mingw_snprintf\n+/* Fallback to sprintf if target does not have snprintf.  */\n+#elif !defined(HAVE_SNPRINTF)\n+#undef snprintf\n+#define snprintf(str, size, ...) sprintf (str, __VA_ARGS__)\n #endif\n \n "}, {"sha": "5e4f15c78c99a8480f80619bc44f572576ccc69e", "filename": "libgfortran/runtime/backtrace.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fruntime%2Fbacktrace.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fruntime%2Fbacktrace.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fbacktrace.c?ref=d30fe1c5cdc98c83c1d29d6b20f88a13328faddd", "patch": "@@ -1,7 +1,7 @@\n-/* Copyright (C) 2006, 2007, 2009 Free Software Foundation, Inc.\n+/* Copyright (C) 2006, 2007, 2009, 2011 Free Software Foundation, Inc.\n    Contributed by Fran\u00e7ois-Xavier Coudert\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n@@ -290,11 +290,7 @@ show_backtrace (void)\n \n \tst_printf (\"\\nBacktrace for this error:\\n\");\n \targ[0] = (char *) \"pstack\";\n-#ifdef HAVE_SNPRINTF\n \tsnprintf (buf, sizeof(buf), \"%d\", (int) getppid ());\n-#else\n-\tsprintf (buf, \"%d\", (int) getppid ());\n-#endif\n \targ[1] = buf;\n \targ[2] = NULL;\n \texecvp (arg[0], arg);"}, {"sha": "f5d4721283e16c837d97114fff56b83fe5c37716", "filename": "libgfortran/runtime/main.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fruntime%2Fmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d30fe1c5cdc98c83c1d29d6b20f88a13328faddd/libgfortran%2Fruntime%2Fmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fmain.c?ref=d30fe1c5cdc98c83c1d29d6b20f88a13328faddd", "patch": "@@ -1,7 +1,8 @@\n-/* Copyright (C) 2002-2003, 2005, 2007, 2009 Free Software Foundation, Inc.\n+/* Copyright (C) 2002-2003, 2005, 2007, 2009, 2011 \n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught and Paul Brook <paul@nowt.org>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n@@ -107,8 +108,9 @@ store_exe_path (const char * argv0)\n #endif\n \n   /* exe_path will be cwd + \"/\" + argv[0] + \"\\0\" */\n-  path = malloc (strlen (cwd) + 1 + strlen (argv0) + 1);\n-  sprintf (path, \"%s%c%s\", cwd, DIR_SEPARATOR, argv0);\n+  size_t pathlen = strlen (cwd) + 1 + strlen (argv0) + 1;\n+  path = malloc (pathlen);\n+  snprintf (path, pathlen, \"%s%c%s\", cwd, DIR_SEPARATOR, argv0);\n   exe_path = path;\n   please_free_exe_path_when_done = 1;\n }"}]}