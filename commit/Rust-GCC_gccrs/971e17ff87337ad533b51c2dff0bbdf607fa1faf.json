{"sha": "971e17ff87337ad533b51c2dff0bbdf607fa1faf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTcxZTE3ZmY4NzMzN2FkNTMzYjUxYzJkZmYwYmJkZjYwN2ZhMWZhZg==", "commit": {"author": {"name": "Andrew Sutton", "email": "andrew.n.sutton@gmail.com", "date": "2015-08-07T05:44:49Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-08-07T05:44:49Z"}, "message": "Add C++ Concepts TS support.\n\ngcc/c-family/\n\t* c-common.c (c_common_reswords): Add __is_same_as, concept, requires.\n\t* c-common.h (enum rid): Add RID_IS_SAME_AS, RID_CONCEPT, RID_REQUIRES.\n\t(D_CXX_CONCEPTS, D_CXX_CONCEPTS_FLAGS): New.\n\t* c-cppbuiltin.c (c_cpp_builtins): Define __cpp_concepts.\n\t* c-opts.c (set_std_cxx1z): Set flag_concepts.\n\t* c.opt (fconcepts): New.\ngcc/cp/\n\t* constraint.cc, logic.cc: New files.\n\t* Make-lang.in (CXX_AND_OBJCXX_OBJS): Add constraint.o and logic.o.\n\t(c++.tags): Also process .cc files.\n\t* call.c (enum rejection_reason_code): Add rr_constraint_failure.\n\t(print_z_candidate): Handle it.\n\t(constraint_failure): New.\n\t(add_function_candidate): Check constraints.\n\t(build_new_function_call): Handle evaluating concepts.\n\t(joust): Check more_constrained.\n\t* class.c (add_method): Check equivalently_constrained.\n\t(build_clone): Copy constraints.\n\t(currently_open_class): Return tree.\n\t(resolve_address_of_overloaded_function): Check constraints.\n\t* constexpr.c (cxx_eval_constant_expression): Handle REQUIRES_EXPR.\n\t(potential_constant_expression_1): Likewise.\n\t* cp-objcp-common.c (cp_tree_size): Handle CONSTRAINT_INFO.\n\t(cp_common_init_ts): Handle WILDCARD_DECL and REQUIRES_EXPR.\n\t* cp-tree.def: Add CONSTRAINT_INFO, WILDCARD_DECL, REQUIRES_EXPR,\n\tSIMPLE_REQ, TYPE_REQ, COMPOUND_REQ, NESTED_REQ, PRED_CONSTR,\n\tEXPR_CONSTR, TYPE_CONSTR, ICONV_CONSTR, DEDUCT_CONSTR,\n\tEXCEPT_CONSTR, PARM_CONSTR, CONJ_CONSTR, DISJ_CONSTR.\n\t* cp-tree.h (struct tree_constraint_info, check_nonnull)\n\t(check_constraint_info, CI_TEMPLATE_REQS, CI_DECLARATOR_REQS)\n\t(CI_ASSOCIATED_CONSTRAINTS, CI_NORMALIZED_CONSTRAINTS)\n\t(CI_ASSUMPTIONS, TEMPLATE_PARMS_CONSTRAINTS)\n\t(TEMPLATE_PARM_CONSTRAINTS, COMPOUND_REQ_NOEXCEPT_P)\n\t(PLACEHOLDER_TYPE_CONSTRAINTS, PRED_CONSTR_EXPR, EXPR_CONSTR_EXPR)\n\t(TYPE_CONSTR_TYPE, ICONV_CONSTR_EXPR, ICONV_CONSTR_TYPE)\n\t(DEDUCT_CONSTR_EXPR, DEDUCT_CONSTR_PATTERN)\n\t(DEDUCT_CONSTR_PLACEHOLDER, EXCEPT_CONSTR_EXPR, PARM_CONSTR_PARMS)\n\t(PARM_CONSTR_OPERAND, CONSTRAINT_VAR_P, CONSTRAINED_PARM_CONCEPT)\n\t(CONSTRAINED_PARM_EXTRA_ARGS, CONSTRAINED_PARM_PROTOTYPE)\n\t(DECL_DECLARED_CONCEPT_P, WILDCARD_PACK_P, struct cp_unevaluated)\n\t(struct local_specialization_stack, enum auto_deduction_context)\n\t(variable_concept_p, concept_template_p)\n\t(struct deferring_access_check_sentinel): New.\n\t(enum cp_tree_node_structure_enum): Add TS_CP_CONSTRAINT_INFO.\n\t(union lang_tree_node): Add constraint_info field.\n\t(struct lang_decl_base): Add concept_p flag.\n\t(enum cp_decl_spec): Add ds_concept.\n\t(struct cp_declarator): Add requires_clause.\n\t* cxx-pretty-print.c (cxx_pretty_printer::primary_expression)\n\t(cxx_pretty_printer::expression): Handle REQUIRES_EXPR,\n\tTRAIT_EXPR, *_CONSTR.\n\t(pp_cxx_parameter_declaration_clause): Accept a chain of\n\tPARM_DECLs.\n\t(cxx_pretty_printer::declarator): Print requires-clause.\n\t(pp_cxx_template_declaration): Likewise.\n\t(pp_cxx_trait_expression): Handle CPTK_IS_SAME_AS.\n\t(pp_cxx_requires_clause, pp_cxx_requirement)\n\t(pp_cxx_requirement_list, pp_cxx_requirement_body)\n\t(pp_cxx_requires_expr, pp_cxx_simple_requirement)\n\t(pp_cxx_type_requirement, pp_cxx_compound_requirement)\n\t(pp_cxx_nested_requirement, pp_cxx_predicate_constraint)\n\t(pp_cxx_expression_constraint, pp_cxx_type_constraint)\n\t(pp_cxx_implicit_conversion_constraint)\n\t(pp_cxx_argument_deduction_constraint)\n\t(pp_cxx_exception_constraint, pp_cxx_parameterized_constraint)\n\t(pp_cxx_conjunction, pp_cxx_disjunction, pp_cxx_constraint): New.\n\t* cxx-pretty-print.h: Declare them.\n\t* decl.c (decls_match): Compare constraints.\n\t(duplicate_decls): Likewise.  Remove constraints before freeing.\n\t(cxx_init_decl_processing): Call init_constraint_processing.\n\t(cp_finish_decl): Diagnose concept without initializer.\n\t(grokfndecl, grokvardecl): Handle concepts and constraints.\n\t(grokdeclarator): Handle concept, requires-clause.\n\t(grokparms): No longer static.\n\t(xref_tag_1): Check constraints.\n\t(finish_function): Call check_function_concept.\n\t(cp_tree_node_structure): Handle CONSTRAINT_INFO.\n\t(check_concept_refinement, is_concept_var, check_concept_fn): New.\n\t* decl2.c (check_classfn): Compare constraints.\n\t(mark_used): Don't instantiate concepts.\n\t* error.c (dump_template_decl): Print constraints.\n\t(dump_function_decl): Likewise.\n\t(dump_expr): Handle REQUIRES_EXPR, *_REQ, *_CONSTR.\n\t* lex.c (init_reswords): Set D_CXX_CONCEPTS.\n\t* method.c (implicitly_declare_fn): Copy constraints from\n\tinherited ctor.\n\t* parser.h (struct cp_parser): Add in_result_type_constraint_p and\n\tprevent_constrained_type_specifiers fields.\n\t* parser.c (make_call_declarator): Add requires_clause parm.\n\t(cp_parser_new): Clear prevent_constrained_type_specifiers.\n\t(cp_parser_primary_expression): Handle RID_IS_SAME_AS, RID_REQUIRES.\n\t(cp_parser_postfix_expression): Set prevent_constrained_type_specifiers.\n\t(cp_parser_trait_expr): Handle RID_IS_SAME_AS.\n\t(cp_parser_declaration): Handle concept introduction.\n\t(cp_parser_member_declaration): Likewise.\n\t(cp_parser_template_parameter): Handle constrained parameter.\n\t(cp_parser_type_parameter): Handle constraints.\n\t(cp_parser_decl_specifier_seq): Handle RID_CONCEPT.\n\t(cp_parser_template_id): Handle partial concept id.\n\t(cp_parser_type_name): Add overload that takes typename_keyword_p.\n\tHandle constrained parameter.\n\t(cp_parser_nonclass_name): Handle concept names.\n\t(cp_parser_alias_declaration): Handle constraints.\n\t(cp_parser_late_return_type_opt): Also handle requires-clause.\n\t(cp_parser_type_id_1): Handle deduction constraint.\n\t(cp_parser_parameter_declaration): Handle constrained parameters.\n\t(cp_parser_class_specifier_1): Handle constraints.\n\t(cp_parser_template_declaration_after_parameters): Split out from\n\tcp_parser_template_declaration_after_export.\n\t(cp_parser_single_declaration): Handle constraints.\n\t(synthesize_implicit_template_parm): Handle constraints.\n\t(cp_parser_maybe_concept_name, cp_parser_maybe_partial_concept_id)\n\t(cp_parser_introduction_list, get_id_declarator)\n\t(get_unqualified_id, is_constrained_parameter)\n\t(cp_parser_check_constrained_type_parm)\n\t(cp_parser_constrained_type_template_parm)\n\t(cp_parser_constrained_template_template_parm)\n\t(constrained_non_type_template_parm, finish_constrained_parameter)\n\t(declares_constrained_type_template_parameter)\n\t(declares_constrained_template_template_parameter)\n\t(check_type_concept, cp_parser_maybe_constrained_type_specifier)\n\t(cp_parser_maybe_concept_name, cp_parser_maybe_partial_concept_id)\n\t(cp_parser_requires_clause, cp_parser_requires_clause_opt)\n\t(cp_parser_requires_expression)\n\t(cp_parser_requirement_parameter_list, cp_parser_requirement_body)\n\t(cp_parser_requirement_list, cp_parser_requirement)\n\t(cp_parser_simple_requirement, cp_parser_type_requirement)\n\t(cp_parser_compound_requirement, cp_parser_nested_requirement)\n\t(cp_parser_template_introduction)\n\t(cp_parser_explicit_template_declaration)\n\t(get_concept_from_constraint): New.\n\t* pt.c (local_specialization_stack): Implement.\n\t(maybe_new_partial_specialization): New.\n\t(maybe_process_partial_specialization): Use it.\n\t(retrieve_local_specialization, register_local_specialization)\n\t(template_parm_to_arg, build_template_decl, extract_fnparm_pack)\n\t(tsubst_expr): No longer static.\n\t(spec_hasher::equal): Compare constraints.\n\t(determine_specialization): Handle constraints.\n\t(check_explicit_specialization): Handle concepts.\n\t(process_template_parm): Handle constraints.\n\t(end_template_parm_list): Add overload taking no arguments.\n\t(process_partial_specialization): Handle concepts and constraints.\n\tRegister partial specializations of variable templates.\n\t(redeclare_class_template): Handle constraints.\n\t(convert_template_argument): Handle WILDCARD_DECL.  Check\n\tis_compatible_template_arg.\n\t(coerce_template_parameter_pack): Handle wildcard packs.\n\t(coerce_template_parms): DR 1430 also applies to concepts.  Add\n\toverloads taking fewer parameters.\n\t(lookup_template_class_1): Handle constraints.\n\t(lookup_template_variable): Concepts are always bool.\n\t(finish_template_variable): Handle concepts and constraints.\n\t(tsubst_friend_class): Handle constraints.\n\t(gen_elem_of_pack_expansion_instantiation): Handle constraints.\n\t(tsubst_pack_expansion): Handle local parameters.\n\t(tsubst_decl) [FUNCTION_DECL]: Handle constraints.\n\t(tsubst) [TEMPLATE_TYPE_PARM]: Handle deduction constraints.\n\t(tsubst_copy_and_build): Handle REQUIRES_EXPR.\n\t(more_specialized_fn, more_specialized_partial_spec): Check constraints.\n\t(more_specialized_inst): Split out from most_specialized_instantiation.\n\t(most_specialized_partial_spec): Check constraints.\n\t(instantiate_decl): Never instantiate a concept.\n\t(value_dependent_expression_p): Handle REQUIRES_EXPR, TYPE_REQ,\n\tvariable concepts.\n\t(type_dependent_expression_p): Handle WILDCARD_DECL, REQUIRES_EXPR.\n\t(instantiation_dependent_r): Handle REQUIRES_EXPR and concepts.\n\t(do_auto_deduction): Add overload taking tsubst flags and context enum.\n\tHandle constraints.\n\t(get_template_for_ordering, most_constrained_function)\n\t(is_compatible_template_arg, convert_wildcard_argument)\n\t(struct\tconstr_entry, struct constr_hasher, decl_constraints)\n\t(valid_constraints_p, get_constraints, set_constraints)\n\t(remove_constraints, init_constraint_processing): New.\n\t* ptree.c (cxx_print_xnode): Handle CONSTRAINT_INFO.\n\t* search.c (lookup_member): Do lookup in the open partial\n\tinstantiation.\n\t* semantics.c (finish_template_template_parm): Handle constraints.\n\t(fixup_template_type): New.\n\t(finish_template_type): Call it.\n\t(trait_expr_value, finish_trait_expr): Handle CPTK_IS_SAME_AS.\n\t* tree.c (cp_tree_equal): Handle local parameters, CONSTRAINT_INFO.\n\t(cp_walk_subtrees): Handle REQUIRES_EXPR.\n\t* typeck.c (cp_build_function_call_vec): Check constraints.\n\nCo-Authored-By: Braden Obrzut <admin@maniacsvault.net>\nCo-Authored-By: Jason Merrill <jason@redhat.com>\n\nFrom-SVN: r226713", "tree": {"sha": "23bad22378f96699b757d5523bf73d4139ad66da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23bad22378f96699b757d5523bf73d4139ad66da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/971e17ff87337ad533b51c2dff0bbdf607fa1faf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/971e17ff87337ad533b51c2dff0bbdf607fa1faf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/971e17ff87337ad533b51c2dff0bbdf607fa1faf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/971e17ff87337ad533b51c2dff0bbdf607fa1faf/comments", "author": {"login": "asutton", "id": 570796, "node_id": "MDQ6VXNlcjU3MDc5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/570796?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asutton", "html_url": "https://github.com/asutton", "followers_url": "https://api.github.com/users/asutton/followers", "following_url": "https://api.github.com/users/asutton/following{/other_user}", "gists_url": "https://api.github.com/users/asutton/gists{/gist_id}", "starred_url": "https://api.github.com/users/asutton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asutton/subscriptions", "organizations_url": "https://api.github.com/users/asutton/orgs", "repos_url": "https://api.github.com/users/asutton/repos", "events_url": "https://api.github.com/users/asutton/events{/privacy}", "received_events_url": "https://api.github.com/users/asutton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bf5372e7f0c5c0df7f239ce96ce35a2114400269", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf5372e7f0c5c0df7f239ce96ce35a2114400269", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf5372e7f0c5c0df7f239ce96ce35a2114400269"}], "stats": {"total": 10269, "additions": 10016, "deletions": 253}, "files": [{"sha": "d3a6a38ed7c6a41ee1ce5b01c25fb760ee63613d", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -1,3 +1,15 @@\n+2015-08-06  Andrew Sutton  <andrew.n.sutton@gmail.com>\n+\t    Braden Obrzut  <admin@maniacsvault.net>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tAdd C++ Concepts TS support.\n+\t* c-common.c (c_common_reswords): Add __is_same_as, concept, requires.\n+\t* c-common.h (enum rid): Add RID_IS_SAME_AS, RID_CONCEPT, RID_REQUIRES.\n+\t(D_CXX_CONCEPTS, D_CXX_CONCEPTS_FLAGS): New.\n+\t* c-cppbuiltin.c (c_cpp_builtins): Define __cpp_concepts.\n+\t* c-opts.c (set_std_cxx1z): Set flag_concepts.\n+\t* c.opt (fconcepts): New.\n+\n 2015-08-02  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \t* c-indentation.c (should_warn_for_misleading_indentation):"}, {"sha": "f6c5ddd049618affabd72129bda943e39c04b75b", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -491,6 +491,7 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__is_literal_type\", RID_IS_LITERAL_TYPE, D_CXXONLY },\n   { \"__is_pod\",\t\tRID_IS_POD,\tD_CXXONLY },\n   { \"__is_polymorphic\",\tRID_IS_POLYMORPHIC, D_CXXONLY },\n+  { \"__is_same_as\",     RID_IS_SAME_AS, D_CXXONLY },\n   { \"__is_standard_layout\", RID_IS_STD_LAYOUT, D_CXXONLY },\n   { \"__is_trivial\",     RID_IS_TRIVIAL, D_CXXONLY },\n   { \"__is_trivially_assignable\", RID_IS_TRIVIALLY_ASSIGNABLE, D_CXXONLY },\n@@ -589,6 +590,11 @@ const struct c_common_resword c_common_reswords[] =\n   { \"volatile\",\t\tRID_VOLATILE,\t0 },\n   { \"wchar_t\",\t\tRID_WCHAR,\tD_CXXONLY },\n   { \"while\",\t\tRID_WHILE,\t0 },\n+\n+  /* Concepts-related keywords */\n+  { \"concept\",\t\tRID_CONCEPT,\tD_CXX_CONCEPTS_FLAGS | D_CXXWARN },\n+  { \"requires\", \tRID_REQUIRES,\tD_CXX_CONCEPTS_FLAGS | D_CXXWARN },\n+\n   /* These Objective-C keywords are recognized only immediately after\n      an '@'.  */\n   { \"compatibility_alias\", RID_AT_ALIAS,\tD_OBJC },"}, {"sha": "d1f6cba20e359efb75769eac1994eb20dbe3d390", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -142,6 +142,7 @@ enum rid\n   RID_IS_EMPTY,                RID_IS_ENUM,\n   RID_IS_FINAL,                RID_IS_LITERAL_TYPE,\n   RID_IS_POD,                  RID_IS_POLYMORPHIC,\n+  RID_IS_SAME_AS,\n   RID_IS_STD_LAYOUT,           RID_IS_TRIVIAL,\n   RID_IS_TRIVIALLY_ASSIGNABLE, RID_IS_TRIVIALLY_CONSTRUCTIBLE,\n   RID_IS_TRIVIALLY_COPYABLE,\n@@ -150,6 +151,9 @@ enum rid\n   /* C++11 */\n   RID_CONSTEXPR, RID_DECLTYPE, RID_NOEXCEPT, RID_NULLPTR, RID_STATIC_ASSERT,\n \n+  /* C++ concepts */\n+  RID_CONCEPT, RID_REQUIRES,\n+\n   /* Cilk Plus keywords.  */\n   RID_CILK_SPAWN, RID_CILK_SYNC, RID_CILK_FOR,\n   \n@@ -386,6 +390,9 @@ extern machine_mode c_default_pointer_mode;\n #define D_OBJC\t\t0x080\t/* In Objective C and neither C nor C++.  */\n #define D_CXX_OBJC\t0x100\t/* In Objective C, and C++, but not C.  */\n #define D_CXXWARN\t0x200\t/* In C warn with -Wcxx-compat.  */\n+#define D_CXX_CONCEPTS  0x400   /* In C++, only with concepts. */\n+\n+#define D_CXX_CONCEPTS_FLAGS D_CXXONLY | D_CXX_CONCEPTS\n \n /* The reserved keyword table.  */\n extern const struct c_common_resword c_common_reswords[];"}, {"sha": "6e18a77f227cf24bf99fbd0cb16bb08ade47509d", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -865,6 +865,10 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  cpp_define (pfile, \"__cpp_variable_templates=201304\");\n \t  cpp_define (pfile, \"__cpp_digit_separators=201309\");\n \t}\n+      if (flag_concepts)\n+\t/* Use a value smaller than the 201507 specified in\n+\t   the TS, since we don't yet support extended auto.  */\n+\tcpp_define (pfile, \"__cpp_concepts=201500\");\n       if (flag_sized_deallocation)\n \tcpp_define (pfile, \"__cpp_sized_deallocation=201309\");\n     }"}, {"sha": "3239a853546caa081de76bb1a7c7279996fd39f9", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -1558,6 +1558,8 @@ set_std_cxx1z (int iso)\n   /* C++11 includes the C99 standard library.  */\n   flag_isoc94 = 1;\n   flag_isoc99 = 1;\n+  /* Enable concepts by default. */\n+  flag_concepts = 1;\n   flag_isoc11 = 1;\n   cxx_dialect = cxx1z;\n   lang_hooks.name = \"GNU C++14\"; /* Pretend C++14 till standarization.  */"}, {"sha": "e86ee12acac23e17762ba728e1785f02eebd2af1", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -1086,6 +1086,10 @@ fcilkplus\n C ObjC C++ ObjC++ LTO Report Var(flag_cilkplus) Init(0)\n Enable Cilk Plus\n \n+fconcepts\n+C++ ObjC++ Var(flag_concepts)\n+Enable support for C++ concepts\n+\n fcond-mismatch\n C ObjC C++ ObjC++\n Allow the arguments of the '?' operator to have different types"}, {"sha": "2ecb8d937644cc8cb2861f2a1571fe10e7c3b025", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -1,3 +1,186 @@\n+2015-08-06  Andrew Sutton  <andrew.n.sutton@gmail.com>\n+\t    Braden Obrzut  <admin@maniacsvault.net>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tAdd C++ Concepts TS support.\n+\t* constraint.cc, logic.cc: New files.\n+\t* Make-lang.in (CXX_AND_OBJCXX_OBJS): Add constraint.o and logic.o.\n+\t(c++.tags): Also process .cc files.\n+\t* call.c (enum rejection_reason_code): Add rr_constraint_failure.\n+\t(print_z_candidate): Handle it.\n+\t(constraint_failure): New.\n+\t(add_function_candidate): Check constraints.\n+\t(build_new_function_call): Handle evaluating concepts.\n+\t(joust): Check more_constrained.\n+\t* class.c (add_method): Check equivalently_constrained.\n+\t(build_clone): Copy constraints.\n+\t(currently_open_class): Return tree.\n+\t(resolve_address_of_overloaded_function): Check constraints.\n+\t* constexpr.c (cxx_eval_constant_expression): Handle REQUIRES_EXPR.\n+\t(potential_constant_expression_1): Likewise.\n+\t* cp-objcp-common.c (cp_tree_size): Handle CONSTRAINT_INFO.\n+\t(cp_common_init_ts): Handle WILDCARD_DECL and REQUIRES_EXPR.\n+\t* cp-tree.def: Add CONSTRAINT_INFO, WILDCARD_DECL, REQUIRES_EXPR,\n+\tSIMPLE_REQ, TYPE_REQ, COMPOUND_REQ, NESTED_REQ, PRED_CONSTR,\n+\tEXPR_CONSTR, TYPE_CONSTR, ICONV_CONSTR, DEDUCT_CONSTR,\n+\tEXCEPT_CONSTR, PARM_CONSTR, CONJ_CONSTR, DISJ_CONSTR.\n+\t* cp-tree.h (struct tree_constraint_info, check_nonnull)\n+\t(check_constraint_info, CI_TEMPLATE_REQS, CI_DECLARATOR_REQS)\n+\t(CI_ASSOCIATED_CONSTRAINTS, CI_NORMALIZED_CONSTRAINTS)\n+\t(CI_ASSUMPTIONS, TEMPLATE_PARMS_CONSTRAINTS)\n+\t(TEMPLATE_PARM_CONSTRAINTS, COMPOUND_REQ_NOEXCEPT_P)\n+\t(PLACEHOLDER_TYPE_CONSTRAINTS, PRED_CONSTR_EXPR, EXPR_CONSTR_EXPR)\n+\t(TYPE_CONSTR_TYPE, ICONV_CONSTR_EXPR, ICONV_CONSTR_TYPE)\n+\t(DEDUCT_CONSTR_EXPR, DEDUCT_CONSTR_PATTERN)\n+\t(DEDUCT_CONSTR_PLACEHOLDER, EXCEPT_CONSTR_EXPR, PARM_CONSTR_PARMS)\n+\t(PARM_CONSTR_OPERAND, CONSTRAINT_VAR_P, CONSTRAINED_PARM_CONCEPT)\n+\t(CONSTRAINED_PARM_EXTRA_ARGS, CONSTRAINED_PARM_PROTOTYPE)\n+\t(DECL_DECLARED_CONCEPT_P, WILDCARD_PACK_P, struct cp_unevaluated)\n+\t(struct local_specialization_stack, enum auto_deduction_context)\n+\t(variable_concept_p, concept_template_p)\n+\t(struct deferring_access_check_sentinel): New.\n+\t(enum cp_tree_node_structure_enum): Add TS_CP_CONSTRAINT_INFO.\n+\t(union lang_tree_node): Add constraint_info field.\n+\t(struct lang_decl_base): Add concept_p flag.\n+\t(enum cp_decl_spec): Add ds_concept.\n+\t(struct cp_declarator): Add requires_clause.\n+\t* cxx-pretty-print.c (cxx_pretty_printer::primary_expression)\n+\t(cxx_pretty_printer::expression): Handle REQUIRES_EXPR,\n+\tTRAIT_EXPR, *_CONSTR.\n+\t(pp_cxx_parameter_declaration_clause): Accept a chain of\n+\tPARM_DECLs.\n+\t(cxx_pretty_printer::declarator): Print requires-clause.\n+\t(pp_cxx_template_declaration): Likewise.\n+\t(pp_cxx_trait_expression): Handle CPTK_IS_SAME_AS.\n+\t(pp_cxx_requires_clause, pp_cxx_requirement)\n+\t(pp_cxx_requirement_list, pp_cxx_requirement_body)\n+\t(pp_cxx_requires_expr, pp_cxx_simple_requirement)\n+\t(pp_cxx_type_requirement, pp_cxx_compound_requirement)\n+\t(pp_cxx_nested_requirement, pp_cxx_predicate_constraint)\n+\t(pp_cxx_expression_constraint, pp_cxx_type_constraint)\n+\t(pp_cxx_implicit_conversion_constraint)\n+\t(pp_cxx_argument_deduction_constraint)\n+\t(pp_cxx_exception_constraint, pp_cxx_parameterized_constraint)\n+\t(pp_cxx_conjunction, pp_cxx_disjunction, pp_cxx_constraint): New.\n+\t* cxx-pretty-print.h: Declare them.\n+\t* decl.c (decls_match): Compare constraints.\n+\t(duplicate_decls): Likewise.  Remove constraints before freeing.\n+\t(cxx_init_decl_processing): Call init_constraint_processing.\n+\t(cp_finish_decl): Diagnose concept without initializer.\n+\t(grokfndecl, grokvardecl): Handle concepts and constraints.\n+\t(grokdeclarator): Handle concept, requires-clause.\n+\t(grokparms): No longer static.\n+\t(xref_tag_1): Check constraints.\n+\t(finish_function): Call check_function_concept.\n+\t(cp_tree_node_structure): Handle CONSTRAINT_INFO.\n+\t(check_concept_refinement, is_concept_var, check_concept_fn): New.\n+\t* decl2.c (check_classfn): Compare constraints.\n+\t(mark_used): Don't instantiate concepts.\n+\t* error.c (dump_template_decl): Print constraints.\n+\t(dump_function_decl): Likewise.\n+\t(dump_expr): Handle REQUIRES_EXPR, *_REQ, *_CONSTR.\n+\t* lex.c (init_reswords): Set D_CXX_CONCEPTS.\n+\t* method.c (implicitly_declare_fn): Copy constraints from\n+\tinherited ctor.\n+\t* parser.h (struct cp_parser): Add in_result_type_constraint_p and\n+\tprevent_constrained_type_specifiers fields.\n+\t* parser.c (make_call_declarator): Add requires_clause parm.\n+\t(cp_parser_new): Clear prevent_constrained_type_specifiers.\n+\t(cp_parser_primary_expression): Handle RID_IS_SAME_AS, RID_REQUIRES.\n+\t(cp_parser_postfix_expression): Set prevent_constrained_type_specifiers.\n+\t(cp_parser_trait_expr): Handle RID_IS_SAME_AS.\n+\t(cp_parser_declaration): Handle concept introduction.\n+\t(cp_parser_member_declaration): Likewise.\n+\t(cp_parser_template_parameter): Handle constrained parameter.\n+\t(cp_parser_type_parameter): Handle constraints.\n+\t(cp_parser_decl_specifier_seq): Handle RID_CONCEPT.\n+\t(cp_parser_template_id): Handle partial concept id.\n+\t(cp_parser_type_name): Add overload that takes typename_keyword_p.\n+\tHandle constrained parameter.\n+\t(cp_parser_nonclass_name): Handle concept names.\n+\t(cp_parser_alias_declaration): Handle constraints.\n+\t(cp_parser_late_return_type_opt): Also handle requires-clause.\n+\t(cp_parser_type_id_1): Handle deduction constraint.\n+\t(cp_parser_parameter_declaration): Handle constrained parameters.\n+\t(cp_parser_class_specifier_1): Handle constraints.\n+\t(cp_parser_template_declaration_after_parameters): Split out from\n+\tcp_parser_template_declaration_after_export.\n+\t(cp_parser_single_declaration): Handle constraints.\n+\t(synthesize_implicit_template_parm): Handle constraints.\n+\t(cp_parser_maybe_concept_name, cp_parser_maybe_partial_concept_id)\n+\t(cp_parser_introduction_list, get_id_declarator)\n+\t(get_unqualified_id, is_constrained_parameter)\n+\t(cp_parser_check_constrained_type_parm)\n+\t(cp_parser_constrained_type_template_parm)\n+\t(cp_parser_constrained_template_template_parm)\n+\t(constrained_non_type_template_parm, finish_constrained_parameter)\n+\t(declares_constrained_type_template_parameter)\n+\t(declares_constrained_template_template_parameter)\n+\t(check_type_concept, cp_parser_maybe_constrained_type_specifier)\n+\t(cp_parser_maybe_concept_name, cp_parser_maybe_partial_concept_id)\n+\t(cp_parser_requires_clause, cp_parser_requires_clause_opt)\n+\t(cp_parser_requires_expression)\n+\t(cp_parser_requirement_parameter_list, cp_parser_requirement_body)\n+\t(cp_parser_requirement_list, cp_parser_requirement)\n+\t(cp_parser_simple_requirement, cp_parser_type_requirement)\n+\t(cp_parser_compound_requirement, cp_parser_nested_requirement)\n+\t(cp_parser_template_introduction)\n+\t(cp_parser_explicit_template_declaration)\n+\t(get_concept_from_constraint): New.\n+\t* pt.c (local_specialization_stack): Implement.\n+\t(maybe_new_partial_specialization): New.\n+\t(maybe_process_partial_specialization): Use it.\n+\t(retrieve_local_specialization, register_local_specialization)\n+\t(template_parm_to_arg, build_template_decl, extract_fnparm_pack)\n+\t(tsubst_expr): No longer static.\n+\t(spec_hasher::equal): Compare constraints.\n+\t(determine_specialization): Handle constraints.\n+\t(check_explicit_specialization): Handle concepts.\n+\t(process_template_parm): Handle constraints.\n+\t(end_template_parm_list): Add overload taking no arguments.\n+\t(process_partial_specialization): Handle concepts and constraints.\n+\tRegister partial specializations of variable templates.\n+\t(redeclare_class_template): Handle constraints.\n+\t(convert_template_argument): Handle WILDCARD_DECL.  Check\n+\tis_compatible_template_arg.\n+\t(coerce_template_parameter_pack): Handle wildcard packs.\n+\t(coerce_template_parms): DR 1430 also applies to concepts.  Add\n+\toverloads taking fewer parameters.\n+\t(lookup_template_class_1): Handle constraints.\n+\t(lookup_template_variable): Concepts are always bool.\n+\t(finish_template_variable): Handle concepts and constraints.\n+\t(tsubst_friend_class): Handle constraints.\n+\t(gen_elem_of_pack_expansion_instantiation): Handle constraints.\n+\t(tsubst_pack_expansion): Handle local parameters.\n+\t(tsubst_decl) [FUNCTION_DECL]: Handle constraints.\n+\t(tsubst) [TEMPLATE_TYPE_PARM]: Handle deduction constraints.\n+\t(tsubst_copy_and_build): Handle REQUIRES_EXPR.\n+\t(more_specialized_fn, more_specialized_partial_spec): Check constraints.\n+\t(more_specialized_inst): Split out from most_specialized_instantiation.\n+\t(most_specialized_partial_spec): Check constraints.\n+\t(instantiate_decl): Never instantiate a concept.\n+\t(value_dependent_expression_p): Handle REQUIRES_EXPR, TYPE_REQ,\n+\tvariable concepts.\n+\t(type_dependent_expression_p): Handle WILDCARD_DECL, REQUIRES_EXPR.\n+\t(instantiation_dependent_r): Handle REQUIRES_EXPR and concepts.\n+\t(do_auto_deduction): Add overload taking tsubst flags and context enum.\n+\tHandle constraints.\n+\t(get_template_for_ordering, most_constrained_function)\n+\t(is_compatible_template_arg, convert_wildcard_argument)\n+\t(struct\tconstr_entry, struct constr_hasher, decl_constraints)\n+\t(valid_constraints_p, get_constraints, set_constraints)\n+\t(remove_constraints, init_constraint_processing): New.\n+\t* ptree.c (cxx_print_xnode): Handle CONSTRAINT_INFO.\n+\t* search.c (lookup_member): Do lookup in the open partial\n+\tinstantiation.\n+\t* semantics.c (finish_template_template_parm): Handle constraints.\n+\t(fixup_template_type): New.\n+\t(finish_template_type): Call it.\n+\t(trait_expr_value, finish_trait_expr): Handle CPTK_IS_SAME_AS.\n+\t* tree.c (cp_tree_equal): Handle local parameters, CONSTRAINT_INFO.\n+\t(cp_walk_subtrees): Handle REQUIRES_EXPR.\n+\t* typeck.c (cp_build_function_call_vec): Check constraints.\n+\n 2015-08-06  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/66533"}, {"sha": "a16f228146cfe1111683026175dd2ee75de1d80b", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -78,7 +78,8 @@ CXX_AND_OBJCXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \\\n  cp/mangle.o cp/cp-objcp-common.o cp/name-lookup.o cp/cxx-pretty-print.o \\\n  cp/cp-cilkplus.o \\\n  cp/cp-gimplify.o cp/cp-array-notation.o cp/lambda.o \\\n- cp/vtable-class-hierarchy.o cp/constexpr.o cp/cp-ubsan.o $(CXX_C_OBJS)\n+ cp/vtable-class-hierarchy.o cp/constexpr.o cp/cp-ubsan.o \\\n+ cp/constraint.o cp/logic.o $(CXX_C_OBJS)\n \n # Language-specific object files for C++.\n CXX_OBJS = cp/cp-lang.o c-family/stub-objc.o $(CXX_AND_OBJCXX_OBJS)\n@@ -131,7 +132,7 @@ c++.srcinfo:\n c++.srcextra:\n \n c++.tags: force\n-\tcd $(srcdir)/cp; etags -o TAGS.sub *.c *.h --language=none \\\n+\tcd $(srcdir)/cp; etags -o TAGS.sub *.c *.cc *.h --language=none \\\n \t  --regex='/DEFTREECODE [(]\\([A-Z_]+\\)/\\1/' cp-tree.def; \\\n \tetags --include TAGS.sub --include ../TAGS.sub\n "}, {"sha": "4823d37a9c40e187b43be14128d82c57c607c710", "filename": "gcc/cp/call.c", "status": "modified", "additions": 75, "deletions": 4, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -425,7 +425,8 @@ enum rejection_reason_code {\n   rr_arg_conversion,\n   rr_bad_arg_conversion,\n   rr_template_unification,\n-  rr_invalid_copy\n+  rr_invalid_copy,\n+  rr_constraint_failure\n };\n \n struct conversion_info {\n@@ -688,6 +689,27 @@ invalid_copy_with_fn_template_rejection (void)\n   return r;\n }\n \n+// Build a constraint failure record, saving information into the\n+// template_instantiation field of the rejection. If FN is not a template\n+// declaration, the TMPL member is the FN declaration and TARGS is empty.\n+\n+static struct rejection_reason *\n+constraint_failure (tree fn)\n+{\n+  struct rejection_reason *r = alloc_rejection (rr_constraint_failure);\n+  if (tree ti = DECL_TEMPLATE_INFO (fn))\n+    {\n+      r->u.template_instantiation.tmpl = TI_TEMPLATE (ti);\n+      r->u.template_instantiation.targs = TI_ARGS (ti);\n+    }\n+  else\n+    {\n+      r->u.template_instantiation.tmpl = fn;\n+      r->u.template_instantiation.targs = NULL_TREE;\n+    }\n+  return r;\n+}\n+\n /* Dynamically allocate a conversion.  */\n \n static conversion *\n@@ -1957,10 +1979,20 @@ add_function_candidate (struct z_candidate **candidates,\n       viable = 0;\n       reason = arity_rejection (first_arg, i + remaining, len);\n     }\n+\n+  /* Second, for a function to be viable, its constraints must be\n+     satisfied. */\n+  if (flag_concepts && viable\n+      && !constraints_satisfied_p (fn))\n+    {\n+      reason = constraint_failure (fn);\n+      viable = false;\n+    }\n+\n   /* When looking for a function from a subobject from an implicit\n      copy/move constructor/operator=, don't consider anything that takes (a\n      reference to) an unrelated type.  See c++/44909 and core 1092.  */\n-  else if (parmlist && (flags & LOOKUP_DEFAULTED))\n+  if (viable && parmlist && (flags & LOOKUP_DEFAULTED))\n     {\n       if (DECL_CONSTRUCTOR_P (fn))\n \ti = 1;\n@@ -1984,7 +2016,7 @@ add_function_candidate (struct z_candidate **candidates,\n   if (! viable)\n     goto out;\n \n-  /* Second, for F to be a viable function, there shall exist for each\n+  /* Third, for F to be a viable function, there shall exist for each\n      argument an implicit conversion sequence that converts that argument\n      to the corresponding parameter of F.  */\n \n@@ -3387,6 +3419,13 @@ print_z_candidate (location_t loc, const char *msgstr,\n \t\t  \"  a constructor taking a single argument of its own \"\n \t\t  \"class type is invalid\");\n \t  break;\n+\tcase rr_constraint_failure:\n+\t  {\n+\t    tree tmpl = r->u.template_instantiation.tmpl;\n+\t    tree args = r->u.template_instantiation.targs;\n+\t    diagnose_constraints (cloc, tmpl, args);\n+\t  }\n+\t  break;\n \tcase rr_none:\n \tdefault:\n \t  /* This candidate didn't have any issues or we failed to\n@@ -4044,9 +4083,13 @@ build_new_function_call (tree fn, vec<tree, va_gc> **args, bool koenig_p,\n     {\n       if (complain & tf_error)\n \t{\n+\t  // If there is a single (non-viable) function candidate,\n+\t  // let the error be diagnosed by cp_build_function_call_vec.\n \t  if (!any_viable_p && candidates && ! candidates->next\n \t      && (TREE_CODE (candidates->fn) == FUNCTION_DECL))\n \t    return cp_build_function_call_vec (candidates->fn, args, complain);\n+\n+\t  // Otherwise, emit notes for non-viable candidates.\n \t  if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n \t    fn = TREE_OPERAND (fn, 0);\n \t  print_error_for_call_failure (fn, *args, candidates);\n@@ -4061,7 +4104,26 @@ build_new_function_call (tree fn, vec<tree, va_gc> **args, bool koenig_p,\n          through flags so that later we can use it to decide whether to warn\n          about peculiar null pointer conversion.  */\n       if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n-        flags |= LOOKUP_EXPLICIT_TMPL_ARGS;\n+        {\n+          /* If overload resolution selects a specialization of a\n+             function concept for non-dependent template arguments,\n+             the expression is true if the constraints are satisfied\n+             and false otherwise.\n+\n+             NOTE: This is an extension of Concepts Lite TS that\n+             allows constraints to be used in expressions. */\n+          if (flag_concepts && !processing_template_decl)\n+            {\n+              tree tmpl = DECL_TI_TEMPLATE (cand->fn);\n+              tree targs = DECL_TI_ARGS (cand->fn);\n+              tree decl = DECL_TEMPLATE_RESULT (tmpl);\n+              if (DECL_DECLARED_CONCEPT_P (decl))\n+                return evaluate_function_concept (decl, targs);\n+            }\n+\n+          flags |= LOOKUP_EXPLICIT_TMPL_ARGS;\n+        }\n+\n       result = build_over_call (cand, flags, complain);\n     }\n \n@@ -9095,6 +9157,15 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n \treturn winner;\n     }\n \n+    // C++ Concepts\n+    // or, if not that, F1 is more constrained than F2.\n+    if (flag_concepts)\n+      {\n+        winner = more_constrained (cand1->fn, cand2->fn);\n+        if (winner)\n+          return winner;\n+      }\n+\n   /* Check whether we can discard a builtin candidate, either because we\n      have two identical ones or matching builtin and non-builtin candidates.\n "}, {"sha": "bf7b5c4bab6c37349204cd3a5a35e218f81cee8b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -1138,7 +1138,8 @@ add_method (tree type, tree method, tree using_decl)\n       if (compparms (parms1, parms2)\n \t  && (!DECL_CONV_FN_P (fn)\n \t      || same_type_p (TREE_TYPE (fn_type),\n-\t\t\t      TREE_TYPE (method_type))))\n+\t\t\t      TREE_TYPE (method_type)))\n+          && equivalently_constrained (fn, method))\n \t{\n \t  /* For function versions, their parms and types match\n \t     but they are not duplicates.  Record function versions\n@@ -4602,6 +4603,14 @@ build_clone (tree fn, tree name)\n       TREE_TYPE (clone) = TREE_TYPE (result);\n       return clone;\n     }\n+  else\n+    {\n+      // Clone constraints.\n+      if (flag_concepts)\n+        if (tree ci = get_constraints (fn))\n+          set_constraints (clone, copy_node (ci));\n+    }\n+\n \n   SET_DECL_ASSEMBLER_NAME (clone, NULL_TREE);\n   DECL_CLONED_FUNCTION (clone) = fn;\n@@ -7281,15 +7290,17 @@ pop_class_stack (void)\n }\n \n /* Returns 1 if the class type currently being defined is either T or\n-   a nested type of T.  */\n+   a nested type of T.  Returns the type from the current_class_stack,\n+   which might be equivalent to but not equal to T in case of\n+   constrained partial specializations.  */\n \n-bool\n+tree\n currently_open_class (tree t)\n {\n   int i;\n \n   if (!CLASS_TYPE_P (t))\n-    return false;\n+    return NULL_TREE;\n \n   t = TYPE_MAIN_VARIANT (t);\n \n@@ -7309,9 +7320,9 @@ currently_open_class (tree t)\n       if (!c)\n \tcontinue;\n       if (same_type_p (c, t))\n-\treturn true;\n+\treturn c;\n     }\n-  return false;\n+  return NULL_TREE;\n }\n \n /* If either current_class_type or one of its enclosing classes are derived\n@@ -7661,6 +7672,12 @@ resolve_address_of_overloaded_function (tree target_type,\n \t    /* Instantiation failed.  */\n \t    continue;\n \n+\t  /* Constraints must be satisfied. This is done before\n+\t     return type deduction since that instantiates the\n+\t     function. */\n+\t  if (flag_concepts && !constraints_satisfied_p (instantiation))\n+\t    continue;\n+\n \t  /* And now force instantiation to do return type deduction.  */\n \t  if (undeduced_auto_decl (instantiation))\n \t    {"}, {"sha": "218faeccf80221ceedb5408954a58eb07c5ae10d", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -3525,6 +3525,25 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t    non_constant_p, overflow_p, jump_target);\n       break;\n \n+    case REQUIRES_EXPR:\n+      /* It's possible to get a requires-expression in a constant\n+         expression. For example:\n+\n+             template<typename T> concept bool C() {\n+               return requires (T t) { t; };\n+             }\n+\n+             template<typename T> requires !C<T>() void f(T);\n+\n+         Normalization leaves f with the associated constraint\n+         '!requires (T t) { ... }' which is not transformed into\n+         a constraint.  */\n+      if (!processing_template_decl)\n+        return evaluate_constraint_expression (t, NULL_TREE);\n+      else\n+        *non_constant_p = true;\n+      return t;\n+\n     default:\n       if (STATEMENT_CODE_P (TREE_CODE (t)))\n \t{\n@@ -3897,6 +3916,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict,\n     case PLACEHOLDER_EXPR:\n     case BREAK_STMT:\n     case CONTINUE_STMT:\n+    case REQUIRES_EXPR:\n       return true;\n \n     case AGGR_INIT_EXPR:"}, {"sha": "cf57cc010a469babaf70962660459ee725882241", "filename": "gcc/cp/constraint.cc", "status": "added", "additions": 2617, "deletions": 0, "changes": 2617, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,2617 @@\n+/* Processing rules for constraints.\n+   Copyright (C) 2013-2015 Free Software Foundation, Inc.\n+   Contributed by Andrew Sutton (andrew.n.sutton@gmail.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"hash-set.h\"\n+#include \"machmode.h\"\n+#include \"vec.h\"\n+#include \"double-int.h\"\n+#include \"input.h\"\n+#include \"alias.h\"\n+#include \"symtab.h\"\n+#include \"wide-int.h\"\n+#include \"inchash.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n+#include \"intl.h\"\n+#include \"flags.h\"\n+#include \"cp-tree.h\"\n+#include \"c-family/c-common.h\"\n+#include \"c-family/c-objc.h\"\n+#include \"cp-objcp-common.h\"\n+#include \"tree-inline.h\"\n+#include \"decl.h\"\n+#include \"toplev.h\"\n+#include \"type-utils.h\"\n+\n+/*---------------------------------------------------------------------------\n+                       Operations on constraints\n+---------------------------------------------------------------------------*/\n+\n+/* Returns true if C is a constraint tree code. Note that ERROR_MARK\n+   is a valid constraint.  */\n+\n+static inline bool\n+constraint_p (tree_code c)\n+{\n+  return (PRED_CONSTR <= c && c <= DISJ_CONSTR) || c == ERROR_MARK;\n+}\n+\n+/* Returns true if T is a constraint. Note that error_mark_node\n+   is a valid constraint.  */\n+\n+bool\n+constraint_p (tree t)\n+{\n+  return constraint_p (TREE_CODE (t));\n+}\n+\n+/* Make a predicate constraint from the given expression. */\n+\n+tree\n+make_predicate_constraint (tree expr)\n+{\n+  return build_nt (PRED_CONSTR, expr);\n+}\n+\n+/* Returns the conjunction of two constraints A and B. Note that\n+   conjoining a non-null constraint with NULL_TREE is an identity\n+   operation. That is, for non-null A,\n+\n+      conjoin_constraints(a, NULL_TREE) == a\n+\n+   and\n+\n+      conjoin_constraints (NULL_TREE, a) == a\n+\n+   If both A and B are NULL_TREE, the result is also NULL_TREE. */\n+\n+tree\n+conjoin_constraints (tree a, tree b)\n+{\n+  gcc_assert (a ? constraint_p (a) : true);\n+  gcc_assert (b ? constraint_p (b) : true);\n+  if (a)\n+    return b ? build_nt (CONJ_CONSTR, a, b) : a;\n+  else if (b)\n+    return b;\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* Transform the vector of expressions in the T into a conjunction\n+   of requirements. T must be a TREE_VEC. */\n+\n+tree\n+conjoin_constraints (tree t)\n+{\n+  gcc_assert (TREE_CODE (t) == TREE_VEC);\n+  tree r = NULL_TREE;\n+  for (int i = 0; i < TREE_VEC_LENGTH (t); ++i)\n+    r = conjoin_constraints (r, TREE_VEC_ELT (t, i));\n+  return r;\n+}\n+\n+/* Returns true if T is a call expression to a function\n+   concept. */\n+\n+bool\n+function_concept_check_p (tree t)\n+{\n+  gcc_assert (TREE_CODE (t) == CALL_EXPR);\n+  tree fn = CALL_EXPR_FN (t);\n+  if (TREE_CODE (fn) == TEMPLATE_ID_EXPR\n+      && TREE_CODE (TREE_OPERAND (fn, 0)) == OVERLOAD)\n+    {\n+      tree f1 = get_first_fn (fn);\n+      if (TREE_CODE (f1) == TEMPLATE_DECL\n+\t  && DECL_DECLARED_CONCEPT_P (DECL_TEMPLATE_RESULT (f1)))\n+        return true;\n+    }\n+  return false;\n+}\n+\n+/*---------------------------------------------------------------------------\n+                    Resolution of qualified concept names\n+---------------------------------------------------------------------------*/\n+\n+/* This facility is used to resolve constraint checks from\n+   requirement expressions. A constraint check is a call to\n+   a function template declared with the keyword 'concept'.\n+\n+   The result of resolution is a pair (a TREE_LIST) whose value\n+   is the matched declaration, and whose purpose contains the\n+   coerced template arguments that can be substituted into the\n+   call.  */\n+\n+// Given an overload set OVL, try to find a unique definition that can be\n+// instantiated by the template arguments ARGS.\n+//\n+// This function is not called for arbitrary call expressions. In particular,\n+// the call expression must be written with explicit template arguments\n+// and no function arguments. For example:\n+//\n+//      f<T, U>()\n+//\n+// If a single match is found, this returns a TREE_LIST whose VALUE\n+// is the constraint function (not the template), and its PURPOSE is\n+// the complete set of arguments substituted into the parameter list.\n+static tree\n+resolve_constraint_check (tree ovl, tree args)\n+{\n+  tree cands = NULL_TREE;\n+  for (tree p = ovl; p != NULL_TREE; p = OVL_NEXT (p))\n+    {\n+      // Get the next template overload.\n+      tree tmpl = OVL_CURRENT (p);\n+      if (TREE_CODE (tmpl) != TEMPLATE_DECL)\n+        continue;\n+\n+      // Don't try to deduce checks for non-concepts. We often\n+      // end up trying to resolve constraints in functional casts\n+      // as part of a postfix-expression. We can save time and\n+      // headaches by not instantiating those declarations.\n+      //\n+      // NOTE: This masks a potential error, caused by instantiating\n+      // non-deduced contexts using placeholder arguments.\n+      tree fn = DECL_TEMPLATE_RESULT (tmpl);\n+      if (DECL_ARGUMENTS (fn))\n+        continue;\n+      if (!DECL_DECLARED_CONCEPT_P (fn))\n+        continue;\n+\n+      // Remember the candidate if we can deduce a substitution.\n+      ++processing_template_decl;\n+      tree parms = TREE_VALUE (DECL_TEMPLATE_PARMS (tmpl));\n+      if (tree subst = coerce_template_parms (parms, args, tmpl))\n+        if (subst != error_mark_node)\n+          cands = tree_cons (subst, fn, cands);\n+      --processing_template_decl;\n+    }\n+\n+  // If we didn't find a unique candidate, then this is\n+  // not a constraint check.\n+  if (!cands || TREE_CHAIN (cands))\n+    return NULL_TREE;\n+\n+  return cands;\n+}\n+\n+// Determine if the the call expression CALL is a constraint check, and\n+// return the concept declaration and arguments being checked. If CALL\n+// does not denote a constraint check, return NULL.\n+tree\n+resolve_constraint_check (tree call)\n+{\n+  gcc_assert (TREE_CODE (call) == CALL_EXPR);\n+\n+  // A constraint check must be only a template-id expression. If\n+  // it's a call to a base-link, its function(s) should be a\n+  // template-id expression. If this is not a template-id, then it\n+  // cannot be a concept-check.\n+  tree target = CALL_EXPR_FN (call);\n+  if (BASELINK_P (target))\n+    target = BASELINK_FUNCTIONS (target);\n+  if (TREE_CODE (target) != TEMPLATE_ID_EXPR)\n+    return NULL_TREE;\n+\n+  // Get the overload set and template arguments and try to\n+  // resolve the target.\n+  tree ovl = TREE_OPERAND (target, 0);\n+\n+  /* This is a function call of a variable concept... ill-formed. */\n+  if (TREE_CODE (ovl) == TEMPLATE_DECL)\n+    {\n+      error_at (location_of (call),\n+\t\t\"function call of variable concept %qE\", call);\n+      return error_mark_node;\n+    }\n+\n+  tree args = TREE_OPERAND (target, 1);\n+  return resolve_constraint_check (ovl, args);\n+}\n+\n+/* Returns a pair containing the checked variable concept\n+   and its associated prototype parameter.  The result\n+   is a TREE_LIST whose TREE_VALUE is the variable concept\n+   and whose TREE_PURPOSE is the prototype parameter.  */\n+\n+tree\n+resolve_variable_concept_check (tree id)\n+{\n+  tree tmpl = TREE_OPERAND (id, 0);\n+  tree args = TREE_OPERAND (id, 1);\n+\n+  if (!variable_concept_p (tmpl))\n+    return NULL_TREE;\n+\n+  /* Make sure that we have the right parameters before\n+     assuming that it works.  Note that failing to deduce\n+     will result in diagnostics.  */\n+  tree parms = INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (tmpl));\n+  tree result = coerce_template_parms (parms, args, tmpl);\n+  if (result != error_mark_node)\n+    {\n+      tree decl = DECL_TEMPLATE_RESULT (tmpl);\n+      return build_tree_list (result, decl);\n+    }\n+  else\n+    return NULL_TREE;\n+}\n+\n+\n+/* Given a call expression or template-id expression to\n+  a concept EXPR possibly including a wildcard, deduce\n+  the concept being checked and the prototype parameter.\n+  Returns true if the constraint and prototype can be\n+  deduced and false otherwise.  Note that the CHECK and\n+  PROTO arguments are set to NULL_TREE if this returns\n+  false.  */\n+\n+bool\n+deduce_constrained_parameter (tree expr, tree& check, tree& proto)\n+{\n+  tree info = NULL_TREE;\n+  if (TREE_CODE (expr) == TEMPLATE_ID_EXPR)\n+    info = resolve_variable_concept_check (expr);\n+  else if (TREE_CODE (expr) == CALL_EXPR)\n+    info = resolve_constraint_check (expr);\n+  else\n+    gcc_unreachable ();\n+\n+  if (info && info != error_mark_node)\n+    {\n+      check = TREE_VALUE (info);\n+      tree arg = TREE_VEC_ELT (TREE_PURPOSE (info), 0);\n+      if (ARGUMENT_PACK_P (arg))\n+\targ = TREE_VEC_ELT (ARGUMENT_PACK_ARGS (arg), 0);\n+      proto = TREE_TYPE (arg);\n+      return true;\n+    }\n+  check = proto = NULL_TREE;\n+  return false;\n+}\n+\n+// Given a call expression or template-id expression to a concept, EXPR,\n+// deduce the concept being checked and return the template arguments.\n+// Returns NULL_TREE if deduction fails.\n+static tree\n+deduce_concept_introduction (tree expr)\n+{\n+  tree info = NULL_TREE;\n+  if (TREE_CODE (expr) == TEMPLATE_ID_EXPR)\n+    info = resolve_variable_concept_check (expr);\n+  else if (TREE_CODE (expr) == CALL_EXPR)\n+    info = resolve_constraint_check (expr);\n+  else\n+    gcc_unreachable ();\n+\n+  if (info && info != error_mark_node)\n+    return TREE_PURPOSE (info);\n+  return NULL_TREE;\n+}\n+\n+namespace {\n+\n+/*---------------------------------------------------------------------------\n+                       Lifting of concept definitions\n+---------------------------------------------------------------------------*/\n+\n+/* Part of constraint normalization.  Whenever we find a reference to\n+   a variable concept or a call to a function concept, we lift or\n+   inline that concept's definition into the constraint.  This ensures\n+   that constraints are always checked in the immediate instantiation\n+   context. */\n+\n+tree lift_expression (tree);\n+\n+/* If the tree T has operands, then lift any concepts out of them.  */\n+tree\n+lift_operands (tree t)\n+{\n+  if (int n = tree_operand_length (t))\n+    {\n+      t = copy_node (t);\n+      for (int i = 0; i < n; ++i)\n+        TREE_OPERAND (t, i) = lift_expression (TREE_OPERAND (t, i));\n+    }\n+  return t;\n+}\n+\n+/* Recursively lift all operands of the function call. Also, check\n+   that the call target is not accidentally a variable concept\n+   since that's ill-formed.  */\n+tree\n+lift_function_call (tree t)\n+{\n+  gcc_assert (TREE_CODE (t) == CALL_EXPR);\n+  gcc_assert (!VAR_P (CALL_EXPR_FN (t)));\n+  return lift_operands (t);\n+}\n+\n+/* Inline a function (concept) definition by substituting\n+   ARGS into its body. */\n+tree\n+lift_function_definition (tree fn, tree args)\n+{\n+  /* Extract the body of the function minus the return expression.  */\n+  tree body = DECL_SAVED_TREE (fn);\n+  if (!body)\n+    return error_mark_node;\n+  if (TREE_CODE (body) == BIND_EXPR)\n+    body = BIND_EXPR_BODY (body);\n+  if (TREE_CODE (body) != RETURN_EXPR)\n+    return error_mark_node;\n+\n+  body = TREE_OPERAND (body, 0);\n+\n+  /* Substitute template arguments to produce our inline expression.  */\n+  tree result = tsubst_expr (body, args, tf_none, NULL_TREE, false);\n+  if (result == error_mark_node)\n+    return error_mark_node;\n+\n+  return lift_expression (result);\n+}\n+\n+/* Inline a reference to a function concept.  */\n+tree\n+lift_call_expression (tree t)\n+{\n+  /* Try to resolve this function call as a concept.  If not, then\n+     it can be returned as-is.  */\n+  tree check = resolve_constraint_check (t);\n+  if (!check)\n+    return lift_function_call (t);\n+  if (check == error_mark_node)\n+    return error_mark_node;\n+\n+  tree fn = TREE_VALUE (check);\n+  tree args = TREE_PURPOSE (check);\n+  return lift_function_definition (fn, args);\n+}\n+\n+tree\n+lift_variable_initializer (tree var, tree args)\n+{\n+  /* Extract the body from the variable initializer.  */\n+  tree init = DECL_INITIAL (var);\n+  if (!init)\n+    return error_mark_node;\n+\n+  /* Substitute the arguments to form our new inline expression.  */\n+  tree result = tsubst_expr (init, args, tf_none, NULL_TREE, false);\n+  if (result == error_mark_node)\n+    return error_mark_node;\n+\n+  return lift_expression (result);\n+}\n+\n+/* Determine if a template-id is a variable concept and inline.  */\n+\n+tree\n+lift_template_id (tree t)\n+{\n+  if (tree info = resolve_variable_concept_check (t))\n+    {\n+      tree decl = TREE_VALUE (info);\n+      tree args = TREE_PURPOSE (info);\n+      return lift_variable_initializer (decl, args);\n+    }\n+\n+  /* Check that we didn't refer to a function concept like\n+      a variable.\n+\n+     TODO: Add a note on how to fix this.  */\n+  tree tmpl = TREE_OPERAND (t, 0);\n+  if (TREE_CODE (tmpl) == OVERLOAD)\n+    {\n+      tree fn = OVL_FUNCTION (tmpl);\n+      if (TREE_CODE (fn) == TEMPLATE_DECL\n+          && DECL_DECLARED_CONCEPT_P (DECL_TEMPLATE_RESULT (fn)))\n+        {\n+          error_at (location_of (t),\n+\t\t    \"invalid reference to function concept %qD\", fn);\n+          return error_mark_node;\n+        }\n+    }\n+\n+  return t;\n+}\n+\n+/* Lift any constraints appearing in a nested requirement of\n+   a requires-expression. */\n+tree\n+lift_requires_expression (tree t)\n+{\n+  tree parms = TREE_OPERAND (t, 0);\n+  tree reqs = TREE_OPERAND (t, 1);\n+  tree result = NULL_TREE;\n+  for (; reqs != NULL_TREE; reqs = TREE_CHAIN (reqs))\n+    {\n+      tree req = TREE_VALUE (reqs);\n+      if (TREE_CODE (req) == NESTED_REQ)\n+        {\n+          tree expr = lift_expression (TREE_OPERAND (req, 0));\n+          req = finish_nested_requirement (expr);\n+        }\n+      result = tree_cons (NULL_TREE, req, result);\n+    }\n+  return finish_requires_expr (parms, result);\n+}\n+\n+/* Inline references to specializations of concepts.  */\n+tree\n+lift_expression (tree t)\n+{\n+  if (t == NULL_TREE)\n+    return NULL_TREE;\n+\n+  if (t == error_mark_node)\n+    return error_mark_node;\n+\n+  /* Concepts can be referred to by call or variable. All other\n+     nodes are preserved.  */\n+  switch (TREE_CODE (t))\n+    {\n+    case CALL_EXPR:\n+      return lift_call_expression (t);\n+\n+    case TEMPLATE_ID_EXPR:\n+      return lift_template_id (t);\n+\n+    case REQUIRES_EXPR:\n+      return lift_requires_expression (t);\n+\n+    case EXPR_PACK_EXPANSION:\n+      /* Use copy_node rather than make_pack_expansion so that\n+\t PACK_EXPANSION_PARAMETER_PACKS stays the same.  */\n+      t = copy_node (t);\n+      SET_PACK_EXPANSION_PATTERN\n+\t(t, lift_expression (PACK_EXPANSION_PATTERN (t)));\n+      return t;\n+\n+    case TREE_LIST:\n+      {\n+        t = copy_node (t);\n+        TREE_VALUE (t) = lift_expression (TREE_VALUE (t));\n+        TREE_CHAIN (t) = lift_expression (TREE_CHAIN (t));\n+        return t;\n+      }\n+\n+    default:\n+      return lift_operands (t);\n+    }\n+}\n+\n+/*---------------------------------------------------------------------------\n+                Transformation of expressions into constraints\n+---------------------------------------------------------------------------*/\n+\n+/* Part of constraint normalization. The following functions rewrite\n+   expressions as constraints.  */\n+\n+tree transform_expression (tree);\n+\n+/* Check that the logical-or or logical-and expression does\n+   not result in a call to a user-defined user-defined operator\n+   (temp.constr.op). Returns true if the logical operator is\n+   admissible and false otherwise. */\n+\n+bool\n+check_logical_expr (tree t)\n+{\n+  /* We can't do much for type dependent expressions. */\n+  if (type_dependent_expression_p (t))\n+    return true;\n+\n+  /* Resolve the logical operator. Note that template processing is\n+     disabled so we get the actual call or target expression back.\n+     not_processing_template_sentinel sentinel.\n+\n+     TODO: This check is actually subsumed by the requirement that\n+     constraint operands have type bool. I'm not sure we need it\n+     unless we allow conversions.  */\n+  tree arg1 = TREE_OPERAND (t, 0);\n+  tree arg2 = TREE_OPERAND (t, 1);\n+  tree ovl = NULL_TREE;\n+  tree expr = build_x_binary_op (EXPR_LOC_OR_LOC (arg2, input_location),\n+                                 TREE_CODE (t),\n+                                 arg1, TREE_CODE (arg1),\n+                                 arg2, TREE_CODE (arg2),\n+                                 &ovl,\n+                                 tf_none);\n+  if (TREE_CODE (expr) != TREE_CODE (t))\n+    {\n+      error (\"user-defined operator %qs in constraint %q+E\",\n+\t     operator_name_info[TREE_CODE (t)].name, t);\n+      return false;\n+    }\n+  return true;\n+}\n+\n+/* Transform a logical-or or logical-and expression into either\n+   a conjunction or disjunction. */\n+\n+tree\n+xform_logical (tree t, tree_code c)\n+{\n+  if (!check_logical_expr (t))\n+    return error_mark_node;\n+  tree t0 = transform_expression (TREE_OPERAND (t, 0));\n+  tree t1 = transform_expression (TREE_OPERAND (t, 1));\n+  return build_nt (c, t0, t1);\n+}\n+\n+/* A simple requirement T introduces an expression constraint\n+   for its expression. */\n+\n+inline tree\n+xform_simple_requirement (tree t)\n+{\n+  return build_nt (EXPR_CONSTR, TREE_OPERAND (t, 0));\n+}\n+\n+/* A type requirement T introduce a type constraint for its type.  */\n+\n+inline tree\n+xform_type_requirement (tree t)\n+{\n+  return build_nt (TYPE_CONSTR, TREE_OPERAND (t, 0));\n+}\n+\n+/* A compound requirement T introduces a conjunction of constraints\n+   depending on its form.  The conjunction always includes an\n+   expression constraint for the expression of the requirement.\n+   If a trailing return type was specified, the conjunction includes\n+   either an implicit conversion constraint or an argument deduction\n+   constraint.  If the noexcept specifier is present, the conjunction\n+   includes an exception constraint.  */\n+\n+tree\n+xform_compound_requirement (tree t)\n+{\n+  tree expr = TREE_OPERAND (t, 0);\n+  tree constr = build_nt (EXPR_CONSTR, TREE_OPERAND (t, 0));\n+\n+  /* If a type is given, append an implicit conversion or\n+     argument deduction constraint.  */\n+  if (tree type = TREE_OPERAND (t, 1))\n+    {\n+      tree type_constr;\n+      /* TODO: We should be extracting a list of auto nodes\n+         from type_uses_auto, not a single node */\n+      if (tree placeholder = type_uses_auto (type))\n+        type_constr = build_nt (DEDUCT_CONSTR, expr, type, placeholder);\n+      else\n+        type_constr = build_nt (ICONV_CONSTR, expr, type);\n+      constr = conjoin_constraints (constr, type_constr);\n+    }\n+\n+  /* If noexcept is present, append an exception constraint. */\n+  if (COMPOUND_REQ_NOEXCEPT_P (t))\n+    {\n+      tree except = build_nt (EXCEPT_CONSTR, expr);\n+      constr = conjoin_constraints (constr, except);\n+    }\n+\n+  return constr;\n+}\n+\n+/* A nested requirement T introduces a conjunction of constraints\n+   corresponding to its constraint-expression.\n+\n+   If the result of transforming T is error_mark_node, the resulting\n+   constraint is a predicate constraint whose operand is also\n+   error_mark_node. This preserves the constraint structure, but\n+   will guarantee that the constraint is never satisfied.  */\n+\n+inline tree\n+xform_nested_requirement (tree t)\n+{\n+  return transform_expression (TREE_OPERAND (t, 0));\n+}\n+\n+/* Transform a requirement T into one or more constraints.  */\n+\n+tree\n+xform_requirement (tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case SIMPLE_REQ:\n+      return xform_simple_requirement (t);\n+\n+    case TYPE_REQ:\n+      return xform_type_requirement (t);\n+\n+    case COMPOUND_REQ:\n+      return xform_compound_requirement (t);\n+\n+    case NESTED_REQ:\n+      return xform_nested_requirement (t);\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return error_mark_node;\n+}\n+\n+/* Transform a sequence of requirements into a conjunction of\n+   constraints. */\n+\n+tree\n+xform_requirements (tree t)\n+{\n+  tree result = NULL_TREE;\n+  for (; t; t = TREE_CHAIN (t))\n+    {\n+      tree constr = xform_requirement (TREE_VALUE (t));\n+      result = conjoin_constraints (result, constr);\n+    }\n+  return result;\n+}\n+\n+/* Transform a requires-expression into a parameterized constraint.  */\n+\n+tree\n+xform_requires_expr (tree t)\n+{\n+  tree operand = xform_requirements (TREE_OPERAND (t, 1));\n+  if (tree parms = TREE_OPERAND (t, 0))\n+    return build_nt (PARM_CONSTR, parms, operand);\n+  else\n+    return operand;\n+}\n+\n+/* Transform an expression into an atomic predicate constraint.\n+   After substitution, the expression of a predicate constraint\n+   shall have type bool (temp.constr.pred).  For non-type-dependent\n+   expressions, we can check that now.  */\n+\n+tree\n+xform_atomic (tree t)\n+{\n+  if (TREE_TYPE (t) && !type_dependent_expression_p (t))\n+  {\n+    tree type = cv_unqualified (TREE_TYPE (t));\n+    if (!same_type_p (type, boolean_type_node))\n+      {\n+        error (\"predicate constraint %q+E does not have type %<bool%>\", t);\n+        return error_mark_node;\n+      }\n+  }\n+  return build_nt (PRED_CONSTR, t);\n+}\n+\n+/* Push down the pack expansion EXP into the leaves of the constraint PAT.  */\n+\n+tree\n+push_down_pack_expansion (tree exp, tree pat)\n+{\n+  switch (TREE_CODE (pat))\n+    {\n+    case CONJ_CONSTR:\n+    case DISJ_CONSTR:\n+      {\n+\tpat = copy_node (pat);\n+\tTREE_OPERAND (pat, 0)\n+\t  = push_down_pack_expansion (exp, TREE_OPERAND (pat, 0));\n+\tTREE_OPERAND (pat, 1)\n+\t  = push_down_pack_expansion (exp, TREE_OPERAND (pat, 1));\n+\treturn pat;\n+      }\n+    default:\n+      {\n+\texp = copy_node (exp);\n+\tSET_PACK_EXPANSION_PATTERN (exp, pat);\n+\treturn exp;\n+      }\n+    }\n+}\n+\n+/* Transform a pack expansion into a constraint.  First we transform the\n+   pattern of the pack expansion, then we push the pack expansion down into the\n+   leaves of the constraint so that partial ordering will work.  */\n+\n+tree\n+xform_pack_expansion (tree t)\n+{\n+  tree pat = transform_expression (PACK_EXPANSION_PATTERN (t));\n+  return push_down_pack_expansion (t, pat);\n+}\n+\n+/* Transform an expression into a constraint.  */\n+\n+tree\n+xform_expr (tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case TRUTH_ANDIF_EXPR:\n+      return xform_logical (t, CONJ_CONSTR);\n+\n+    case TRUTH_ORIF_EXPR:\n+      return xform_logical (t, DISJ_CONSTR);\n+\n+    case REQUIRES_EXPR:\n+      return xform_requires_expr (t);\n+\n+    case BIND_EXPR:\n+      return transform_expression (BIND_EXPR_BODY (t));\n+\n+    case EXPR_PACK_EXPANSION:\n+      return xform_pack_expansion (t);\n+\n+    default:\n+      /* All other constraints are atomic. */\n+      return xform_atomic (t);\n+    }\n+}\n+\n+/* Transform a statement into an expression.  */\n+\n+tree\n+xform_stmt (tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case RETURN_EXPR:\n+      return transform_expression (TREE_OPERAND (t, 0));\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return error_mark_node;\n+}\n+\n+/* Reduction rules for the declaration T.  */\n+\n+tree\n+xform_decl (tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case VAR_DECL:\n+      return xform_atomic (t);\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return error_mark_node;\n+}\n+\n+/* Transform a lifted expression into a constraint. This either\n+   returns a constraint, or it returns error_mark_node when\n+   a constraint cannot be formed.  */\n+\n+tree\n+transform_expression (tree t)\n+{\n+  if (!t)\n+    return NULL_TREE;\n+\n+  if (t == error_mark_node)\n+    return error_mark_node;\n+\n+  switch (TREE_CODE_CLASS (TREE_CODE (t)))\n+    {\n+    case tcc_unary:\n+    case tcc_binary:\n+    case tcc_expression:\n+    case tcc_vl_exp:\n+      return xform_expr (t);\n+\n+    case tcc_statement:\n+      return xform_stmt (t);\n+\n+    case tcc_declaration:\n+      return xform_decl (t);\n+\n+    case tcc_exceptional:\n+    case tcc_constant:\n+    case tcc_reference:\n+    case tcc_comparison:\n+      /* These are all atomic predicate constraints. */\n+      return xform_atomic (t);\n+\n+    default:\n+      /* Unhandled node kind. */\n+      gcc_unreachable ();\n+    }\n+  return error_mark_node;\n+}\n+\n+/*---------------------------------------------------------------------------\n+                        Constraint normalization\n+---------------------------------------------------------------------------*/\n+\n+tree normalize_constraint (tree);\n+\n+/* The normal form of the disjunction T0 /\\ T1 is the conjunction\n+   of the normal form of T0 and the normal form of T1.  */\n+\n+inline tree\n+normalize_conjunction (tree t)\n+{\n+  tree t0 = normalize_constraint (TREE_OPERAND (t, 0));\n+  tree t1 = normalize_constraint (TREE_OPERAND (t, 1));\n+  return build_nt (CONJ_CONSTR, t0, t1);\n+}\n+\n+/* The normal form of the disjunction T0 \\/ T1 is the disjunction\n+   of the normal form of T0 and the normal form of T1.  */\n+\n+inline tree\n+normalize_disjunction (tree t)\n+{\n+  tree t0 = normalize_constraint (TREE_OPERAND (t, 0));\n+  tree t1 = normalize_constraint (TREE_OPERAND (t, 1));\n+  return build_nt (DISJ_CONSTR, t0, t1);\n+}\n+\n+/* A predicate constraint is normalized in two stages.  First all\n+   references specializations of concepts are replaced by their\n+   substituted definitions.  Then, the resulting expression is\n+   transformed into a constraint by transforming && expressions\n+   into conjunctions and || into disjunctions.  */\n+\n+tree\n+normalize_predicate_constraint (tree t)\n+{\n+  ++processing_template_decl;\n+  tree expr = PRED_CONSTR_EXPR (t);\n+  tree lifted = lift_expression (expr);\n+  tree constr = transform_expression (lifted);\n+  --processing_template_decl;\n+  return constr;\n+}\n+\n+/* The normal form of a parameterized constraint is the normal\n+   form of its operand.  */\n+\n+tree\n+normalize_parameterized_constraint (tree t)\n+{\n+  tree parms = PARM_CONSTR_PARMS (t);\n+  tree operand = normalize_constraint (PARM_CONSTR_OPERAND (t));\n+  return build_nt (PARM_CONSTR, parms, operand);\n+}\n+\n+/* Normalize the constraint T by reducing it so that it is\n+   comprised of only conjunctions and disjunctions of atomic\n+   constraints.  */\n+\n+tree\n+normalize_constraint (tree t)\n+{\n+  if (!t)\n+    return NULL_TREE;\n+\n+  if (t == error_mark_node)\n+    return t;\n+\n+  switch (TREE_CODE (t))\n+    {\n+      case CONJ_CONSTR:\n+        return normalize_conjunction (t);\n+\n+      case DISJ_CONSTR:\n+        return normalize_disjunction (t);\n+\n+      case PRED_CONSTR:\n+        return normalize_predicate_constraint (t);\n+\n+      case PARM_CONSTR:\n+        return normalize_parameterized_constraint (t);\n+\n+      case EXPR_CONSTR:\n+      case TYPE_CONSTR:\n+      case ICONV_CONSTR:\n+      case DEDUCT_CONSTR:\n+      case EXCEPT_CONSTR:\n+        /* These constraints are defined to be atomic. */\n+        return t;\n+\n+      default:\n+        /* CONSTR was not a constraint. */\n+        gcc_unreachable();\n+    }\n+  return error_mark_node;\n+}\n+\n+} /* namespace */\n+\n+\n+// -------------------------------------------------------------------------- //\n+// Constraint Semantic Processing\n+//\n+// The following functions are called by the parser and substitution rules\n+// to create and evaluate constraint-related nodes.\n+\n+// The constraints associated with the current template parameters.\n+tree\n+current_template_constraints (void)\n+{\n+  if (!current_template_parms)\n+    return NULL_TREE;\n+  tree tmpl_constr = TEMPLATE_PARM_CONSTRAINTS (current_template_parms);\n+  return build_constraints (tmpl_constr, NULL_TREE);\n+}\n+\n+// If the recently parsed TYPE declares or defines a template or template\n+// specialization, get its corresponding constraints from the current\n+// template parameters and bind them to TYPE's declaration.\n+tree\n+associate_classtype_constraints (tree type)\n+{\n+  if (!type || type == error_mark_node || TREE_CODE (type) != RECORD_TYPE)\n+    return type;\n+\n+  // An explicit class template specialization has no template\n+  // parameters.\n+  if (!current_template_parms)\n+    return type;\n+\n+  if (CLASSTYPE_IS_TEMPLATE (type) || CLASSTYPE_TEMPLATE_SPECIALIZATION (type))\n+    {\n+      tree decl = TYPE_STUB_DECL (type);\n+      tree ci = current_template_constraints ();\n+\n+      // An implicitly instantiated member template declaration already\n+      // has associated constraints. If it is defined outside of its\n+      // class, then we need match these constraints against those of\n+      // original declaration.\n+      if (tree orig_ci = get_constraints (decl))\n+        {\n+          if (!equivalent_constraints (ci, orig_ci))\n+            {\n+              // FIXME: Improve diagnostics.\n+              error (\"%qT does not match any declaration\", type);\n+              return error_mark_node;\n+            }\n+          return type;\n+        }\n+      set_constraints (decl, ci);\n+    }\n+  return type;\n+}\n+\n+namespace {\n+\n+// Create an empty constraint info block.\n+inline tree_constraint_info*\n+build_constraint_info ()\n+{\n+  return (tree_constraint_info *)make_node (CONSTRAINT_INFO);\n+}\n+\n+} // namespace\n+\n+/* Build a constraint-info object that contains the associated constraints\n+   of a declaration.  This also includes the declaration's template\n+   requirements (TREQS) and any trailing requirements for a function\n+   declarator (DREQS).  Note that both TREQS and DREQS must be constraints.\n+\n+   If the declaration has neither template nor declaration requirements\n+   this returns NULL_TREE, indicating an unconstrained declaration.  */\n+\n+tree\n+build_constraints (tree tmpl_reqs, tree decl_reqs)\n+{\n+  gcc_assert (tmpl_reqs ? constraint_p (tmpl_reqs) : true);\n+  gcc_assert (decl_reqs ? constraint_p (decl_reqs) : true);\n+\n+  if (!tmpl_reqs && !decl_reqs)\n+    return NULL_TREE;\n+\n+  tree_constraint_info* ci = build_constraint_info ();\n+  ci->template_reqs = tmpl_reqs;\n+  ci->declarator_reqs = decl_reqs;\n+  ci->associated_constr = conjoin_constraints (tmpl_reqs, decl_reqs);\n+\n+  ++processing_template_decl;\n+  ci->normalized_constr = normalize_constraint (ci->associated_constr);\n+  --processing_template_decl;\n+\n+  ci->assumptions = decompose_assumptions (ci->normalized_constr);\n+  return (tree)ci;\n+}\n+\n+namespace {\n+\n+/* Returns true if any of the arguments in the template\n+   argument list is a wildcard or wildcard pack. */\n+bool\n+contains_wildcard_p (tree args)\n+{\n+  for (int i = 0; i < TREE_VEC_LENGTH (args); ++i)\n+    {\n+      tree arg = TREE_VEC_ELT (args, i);\n+      if (TREE_CODE (arg) == WILDCARD_DECL)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Build a new call expression, but don't actually generate\n+   a new function call. We just want the tree, not the\n+   semantics. */\n+inline tree\n+build_call_check (tree id)\n+{\n+  ++processing_template_decl;\n+  vec<tree, va_gc> *fargs = make_tree_vector();\n+  tree call = finish_call_expr (id, &fargs, false, false, tf_none);\n+  release_tree_vector (fargs);\n+  --processing_template_decl;\n+  return call;\n+}\n+\n+/* Build an expression that will check a variable concept. If any\n+   argument contains a wildcard, don't try to finish the variable\n+   template because we can't substitute into a non-existent\n+   declaration.  */\n+tree\n+build_variable_check (tree id)\n+{\n+  gcc_assert (TREE_CODE (id) == TEMPLATE_ID_EXPR);\n+  if (contains_wildcard_p (TREE_OPERAND (id, 1)))\n+    return id;\n+\n+  ++processing_template_decl;\n+  tree var = finish_template_variable (id);\n+  --processing_template_decl;\n+  return var;\n+}\n+\n+/* Construct a sequence of template arguments by prepending\n+   ARG to REST. Either ARG or REST may be null. */\n+tree\n+build_concept_check_arguments (tree arg, tree rest)\n+{\n+  gcc_assert (rest ? TREE_CODE (rest) == TREE_VEC : true);\n+  tree args;\n+  if (arg)\n+    {\n+      int n = rest ? TREE_VEC_LENGTH (rest) : 0;\n+      args = make_tree_vec (n + 1);\n+      TREE_VEC_ELT (args, 0) = arg;\n+      if (rest)\n+        for (int i = 0; i < n; ++i)\n+          TREE_VEC_ELT (args, i + 1) = TREE_VEC_ELT (rest, i);\n+      int def = rest ? GET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (rest) : 0;\n+      SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (args, def + 1);\n+    }\n+  else\n+    {\n+      gcc_assert (rest != NULL_TREE);\n+      args = rest;\n+    }\n+  return args;\n+}\n+\n+} // namespace\n+\n+/* Construct an expression that checks the concept given by\n+   TARGET. The TARGET must be:\n+\n+   - an OVERLOAD referring to one or more function concepts\n+   - a BASELINK referring to an overload set of the above, or\n+   - a TEMPLTATE_DECL referring to a variable concept.\n+\n+   ARG and REST are the explicit template arguments for the\n+   eventual concept check. */\n+tree\n+build_concept_check (tree target, tree arg, tree rest)\n+{\n+  tree args = build_concept_check_arguments (arg, rest);\n+  if (variable_template_p (target))\n+    return build_variable_check (lookup_template_variable (target, args));\n+  else\n+    return build_call_check (lookup_template_function (target, args));\n+}\n+\n+\n+/* Returns a TYPE_DECL that contains sufficient information to\n+   build a template parameter of the same kind as PROTO and\n+   constrained by the concept declaration CNC.  Note that PROTO\n+   is the first template parameter of CNC.\n+\n+   If specified, ARGS provides additional arguments to the\n+   constraint check.  */\n+tree\n+build_constrained_parameter (tree cnc, tree proto, tree args)\n+{\n+  tree name = DECL_NAME (cnc);\n+  tree type = TREE_TYPE (proto);\n+  tree decl = build_decl (input_location, TYPE_DECL, name, type);\n+  CONSTRAINED_PARM_PROTOTYPE (decl) = proto;\n+  CONSTRAINED_PARM_CONCEPT (decl) = cnc;\n+  CONSTRAINED_PARM_EXTRA_ARGS (decl) = args;\n+  return decl;\n+}\n+\n+/* Create a constraint expression for the given DECL that\n+   evaluates the requirements specified by CONSTR, a TYPE_DECL\n+   that contains all the information necessary to build the\n+   requirements (see finish_concept_name for the layout of\n+   that TYPE_DECL).\n+\n+   Note that the constraints are neither reduced nor decomposed.\n+   That is done only after the requires clause has been parsed\n+   (or not). */\n+tree\n+finish_shorthand_constraint (tree decl, tree constr)\n+{\n+  /* No requirements means no constraints.  */\n+  if (!constr)\n+    return NULL_TREE;\n+\n+  tree proto = CONSTRAINED_PARM_PROTOTYPE (constr);\n+  tree con = CONSTRAINED_PARM_CONCEPT (constr);\n+  tree args = CONSTRAINED_PARM_EXTRA_ARGS (constr);\n+\n+  /* If the parameter declaration is variadic, but the concept\n+     is not then we need to apply the concept to every element\n+     in the pack.  */\n+  bool is_proto_pack = template_parameter_pack_p (proto);\n+  bool is_decl_pack = template_parameter_pack_p (decl);\n+  bool apply_to_all_p = is_decl_pack && !is_proto_pack;\n+\n+  /* Get the argument and overload used for the requirement\n+     and adjust it if we're going to expand later.  */\n+  tree arg = template_parm_to_arg (build_tree_list (NULL_TREE, decl));\n+  if (apply_to_all_p)\n+    arg = PACK_EXPANSION_PATTERN (TREE_VEC_ELT (ARGUMENT_PACK_ARGS (arg), 0));\n+\n+  /* Build the concept check. If it the constraint needs to be\n+     applied to all elements of the parameter pack, then make\n+     the constraint an expansion. */\n+  tree check;\n+  tree tmpl = DECL_TI_TEMPLATE (con);\n+  if (TREE_CODE (con) == VAR_DECL)\n+    {\n+      check = build_concept_check (tmpl, arg, args);\n+    }\n+  else\n+    {\n+      tree ovl = build_overload (tmpl, NULL_TREE);\n+      check = build_concept_check (ovl, arg, args);\n+    }\n+\n+  /* Make the check a pack expansion if needed.\n+\n+     FIXME: We should be making a fold expression. */\n+  if (apply_to_all_p)\n+    {\n+      check = make_pack_expansion (check);\n+      TREE_TYPE (check) = boolean_type_node;\n+    }\n+\n+  return make_predicate_constraint (check);\n+}\n+\n+/* Returns a conjunction of shorthand requirements for the template\n+   parameter list PARMS. Note that the requirements are stored in\n+   the TYPE of each tree node. */\n+tree\n+get_shorthand_constraints (tree parms)\n+{\n+  tree result = NULL_TREE;\n+  parms = INNERMOST_TEMPLATE_PARMS (parms);\n+  for (int i = 0; i < TREE_VEC_LENGTH (parms); ++i)\n+    {\n+      tree parm = TREE_VEC_ELT (parms, i);\n+      tree constr = TEMPLATE_PARM_CONSTRAINTS (parm);\n+      result = conjoin_constraints (result, constr);\n+    }\n+  return result;\n+}\n+\n+// Returns and chains a new parameter for PARAMETER_LIST which will conform\n+// to the prototype given by SRC_PARM.  The new parameter will have its\n+// identifier and location set according to IDENT and PARM_LOC respectively.\n+static tree\n+process_introduction_parm (tree parameter_list, tree src_parm)\n+{\n+  // If we have a pack, we should have a single pack argument which is the\n+  // placeholder we want to look at.\n+  bool is_parameter_pack = ARGUMENT_PACK_P (src_parm);\n+  if (is_parameter_pack)\n+    src_parm = TREE_VEC_ELT (ARGUMENT_PACK_ARGS (src_parm), 0);\n+\n+  // At this point we should have a wildcard, but we want to\n+  // grab the associated decl from it.  Also grab the stored\n+  // identifier and location that should be chained to it in\n+  // a PARM_DECL.\n+  gcc_assert (TREE_CODE (src_parm) == WILDCARD_DECL);\n+\n+  tree ident = DECL_NAME (src_parm);\n+  location_t parm_loc = DECL_SOURCE_LOCATION (src_parm);\n+\n+  // If we expect a pack and the deduced template is not a pack, or if the\n+  // template is using a pack and we didn't declare a pack, throw an error.\n+  if (is_parameter_pack != WILDCARD_PACK_P (src_parm))\n+    {\n+      error_at (parm_loc, \"cannot match pack for introduced parameter\");\n+      tree err_parm = build_tree_list (error_mark_node, error_mark_node);\n+      return chainon (parameter_list, err_parm);\n+    }\n+\n+  src_parm = TREE_TYPE (src_parm);\n+\n+  tree parm;\n+  bool is_non_type;\n+  if (TREE_CODE (src_parm) == TYPE_DECL)\n+    {\n+      is_non_type = false;\n+      parm = finish_template_type_parm (class_type_node, ident);\n+    }\n+  else if (TREE_CODE (src_parm) == TEMPLATE_DECL)\n+    {\n+      is_non_type = false;\n+      begin_template_parm_list ();\n+      current_template_parms = DECL_TEMPLATE_PARMS (src_parm);\n+      end_template_parm_list ();\n+      parm = finish_template_template_parm (class_type_node, ident);\n+    }\n+  else\n+    {\n+      is_non_type = true;\n+\n+      // Since we don't have a declarator, so we can copy the source\n+      // parameter and change the name and eventually the location.\n+      parm = copy_decl (src_parm);\n+      DECL_NAME (parm) = ident;\n+    }\n+\n+  // Wrap in a TREE_LIST for process_template_parm.  Introductions do not\n+  // retain the defaults from the source template.\n+  parm = build_tree_list (NULL_TREE, parm);\n+\n+  return process_template_parm (parameter_list, parm_loc, parm,\n+                                is_non_type, is_parameter_pack);\n+}\n+\n+/* Associates a constraint check to the current template based\n+   on the introduction parameters.  INTRO_LIST must be a TREE_VEC\n+   of WILDCARD_DECLs containing a chained PARM_DECL which\n+   contains the identifier as well as the source location.\n+   TMPL_DECL is the decl for the concept being used.  If we\n+   take a concept, C, this will form a check in the form of\n+   C<INTRO_LIST> filling in any extra arguments needed by the\n+   defaults deduced.\n+\n+   Returns NULL_TREE if no concept could be matched and\n+   error_mark_node if an error occurred when matching.  */\n+tree\n+finish_template_introduction (tree tmpl_decl, tree intro_list)\n+{\n+  /* Deduce the concept check.  */\n+  tree expr = build_concept_check (tmpl_decl, NULL_TREE, intro_list);\n+  if (expr == error_mark_node)\n+    return NULL_TREE;\n+\n+  tree parms = deduce_concept_introduction (expr);\n+  if (!parms)\n+    return NULL_TREE;\n+\n+  /* Build template parameter scope for introduction.  */\n+  tree parm_list = NULL_TREE;\n+  begin_template_parm_list ();\n+  int nargs = MIN (TREE_VEC_LENGTH (parms), TREE_VEC_LENGTH (intro_list));\n+  for (int n = 0; n < nargs; ++n)\n+    parm_list = process_introduction_parm (parm_list, TREE_VEC_ELT (parms, n));\n+  parm_list = end_template_parm_list (parm_list);\n+  for (int i = 0; i < TREE_VEC_LENGTH (parm_list); ++i)\n+    if (TREE_VALUE (TREE_VEC_ELT (parm_list, i)) == error_mark_node)\n+      {\n+        end_template_decl ();\n+        return error_mark_node;\n+      }\n+\n+  /* Build a concept check for our constraint.  */\n+  tree check_args = make_tree_vec (TREE_VEC_LENGTH (parms));\n+  int n = 0;\n+  for (; n < TREE_VEC_LENGTH (parm_list); ++n)\n+    {\n+      tree parm = TREE_VEC_ELT (parm_list, n);\n+      TREE_VEC_ELT (check_args, n) = template_parm_to_arg (parm);\n+    }\n+\n+  /* If the template expects more parameters we should be able\n+     to use the defaults from our deduced concept.  */\n+  for (; n < TREE_VEC_LENGTH (parms); ++n)\n+    TREE_VEC_ELT (check_args, n) = TREE_VEC_ELT (parms, n);\n+\n+  /* Associate the constraint. */\n+  tree check = build_concept_check (tmpl_decl, NULL_TREE, check_args);\n+  tree constr = make_predicate_constraint (check);\n+  TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = constr;\n+\n+  return parm_list;\n+}\n+\n+\n+/* Make a \"constrained auto\" type-specifier. This is an\n+   auto type with constraints that must be associated after\n+   deduction.  The constraint is formed from the given\n+   CONC and its optional sequence of arguments, which are\n+   non-null if written as partial-concept-id.  */\n+tree\n+make_constrained_auto (tree con, tree args)\n+{\n+  tree type = make_auto();\n+\n+  /* Build the constraint. */\n+  tree tmpl = DECL_TI_TEMPLATE (con);\n+  tree expr;\n+  if (VAR_P (con))\n+    expr = build_concept_check (tmpl, type, args);\n+  else\n+    expr = build_concept_check (build_overload (tmpl, NULL_TREE), type, args);\n+\n+  tree constr = make_predicate_constraint (expr);\n+  PLACEHOLDER_TYPE_CONSTRAINTS (type) = constr;\n+\n+  /* Attach the constraint to the type declaration. */\n+  tree decl = TYPE_NAME (type);\n+  return decl;\n+}\n+\n+\n+/*---------------------------------------------------------------------------\n+                        Constraint substitution\n+---------------------------------------------------------------------------*/\n+\n+/* The following functions implement substitution rules for constraints.\n+   Substitution without checking constraints happens only in the\n+   instantiation of class templates. For example:\n+\n+      template<C1 T> struct S {\n+        void f(T) requires C2<T>;\n+        void g(T) requires T::value;\n+      };\n+\n+      S<int> s; // error instantiating S<int>::g(T)\n+\n+   When we instantiate S, we substitute into its member declarations,\n+   including their constraints. However, those constraints are not\n+   checked. Substituting int into C2<T> yields C2<int>, and substituting\n+   into T::value yields a substitution failure, making the program\n+   ill-formed.\n+\n+   Note that we only ever substitute into the associated constraints\n+   of a declaration. That is, substitution is defined only for predicate\n+   constraints and conjunctions. */\n+\n+/* Substitute into the predicate constraints. Returns error_mark_node\n+   if the substitution into the expression fails. */\n+tree\n+tsubst_predicate_constraint (tree t, tree args,\n+                             tsubst_flags_t complain, tree in_decl)\n+{\n+  tree expr = PRED_CONSTR_EXPR (t);\n+  ++processing_template_decl;\n+  tree result = tsubst_expr (expr, args, complain, in_decl, false);\n+  --processing_template_decl;\n+  return build_nt (PRED_CONSTR, result);\n+}\n+\n+/* Substitute into the conjunction of constraints. Returns\n+   error_mark_node if substitution into either operand fails. */\n+tree\n+tsubst_conjunction (tree t, tree args,\n+                    tsubst_flags_t complain, tree in_decl)\n+{\n+  tree t0 = TREE_OPERAND (t, 0);\n+  tree r0 = tsubst_constraint (t0, args, complain, in_decl);\n+  tree t1 = TREE_OPERAND (t, 1);\n+  tree r1 = tsubst_constraint (t1, args, complain, in_decl);\n+  return build_nt (CONJ_CONSTR, r0, r1);\n+}\n+\n+/* Substitute ARGS into the constraint T. */\n+tree\n+tsubst_constraint (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n+{\n+  if (t == NULL_TREE)\n+    return t;\n+  if (TREE_CODE (t) == CONJ_CONSTR)\n+    return tsubst_conjunction (t, args, complain, in_decl);\n+  else if (TREE_CODE (t) == PRED_CONSTR)\n+    return tsubst_predicate_constraint (t, args, complain, in_decl);\n+  else\n+    gcc_unreachable ();\n+  return error_mark_node;\n+}\n+\n+namespace {\n+\n+/* A subroutine of tsubst_constraint_variables. Register local\n+   specializations for each of parameter in PARMS and its\n+   corresponding substituted constraint variable in VARS.\n+   Returns VARS. */\n+tree\n+declare_constraint_vars (tree parms, tree vars)\n+{\n+  tree s = vars;\n+  for (tree t = parms; t; t = DECL_CHAIN (t))\n+    {\n+      if (DECL_PACK_P (t))\n+        {\n+          tree pack = extract_fnparm_pack (t, &s);\n+          register_local_specialization (pack, t);\n+        }\n+      else\n+        {\n+          register_local_specialization (s, t);\n+          s = DECL_CHAIN (s);\n+        }\n+    }\n+  return vars;\n+}\n+\n+/* A subroutine of tsubst_parameterized_constraint. Substitute ARGS\n+   into the parameter list T, producing a sequence of constraint\n+   variables, declared in the current scope.\n+\n+   Note that the caller must establish a local specialization stack\n+   prior to calling this function since this substitution will\n+   declare the substituted parameters. */\n+tree\n+tsubst_constraint_variables (tree t, tree args,\n+                             tsubst_flags_t complain, tree in_decl)\n+{\n+  /* Clear cp_unevaluated_operand across tsubst so that we get a proper chain\n+     of PARM_DECLs.  */\n+  int saved_unevaluated_operand = cp_unevaluated_operand;\n+  cp_unevaluated_operand = 0;\n+  tree vars = tsubst (t, args, complain, in_decl);\n+  cp_unevaluated_operand = saved_unevaluated_operand;\n+  if (vars == error_mark_node)\n+    return error_mark_node;\n+  return declare_constraint_vars (t, vars);\n+}\n+\n+/* Substitute ARGS into the simple requirement T. Note that\n+   substitution may result in an ill-formed expression without\n+   causing the program to be ill-formed. In such cases, the\n+   requirement wraps an error_mark_node. */\n+inline tree\n+tsubst_simple_requirement (tree t, tree args,\n+                           tsubst_flags_t complain, tree in_decl)\n+{\n+  ++processing_template_decl;\n+  tree expr = tsubst_expr (TREE_OPERAND (t, 0), args, complain, in_decl, false);\n+  --processing_template_decl;\n+  return finish_simple_requirement (expr);\n+}\n+\n+/* Substitute ARGS into the type requirement T. Note that\n+   substitution may result in an ill-formed type without\n+   causing the program to be ill-formed. In such cases, the\n+   requirement wraps an error_mark_node. */\n+\n+inline tree\n+tsubst_type_requirement (tree t, tree args,\n+                         tsubst_flags_t complain, tree in_decl)\n+{\n+  ++processing_template_decl;\n+  tree type = tsubst (TREE_OPERAND (t, 0), args, complain, in_decl);\n+  --processing_template_decl;\n+  return finish_type_requirement (type);\n+}\n+\n+/* Substitute args into the compound requirement T. If substituting\n+   into either the expression or the type fails, the corresponding\n+   operands in the resulting node will be error_mark_node. This\n+   preserves a requirement for the purpose of partial ordering, but\n+   it will never be satisfied. */\n+\n+tree\n+tsubst_compound_requirement (tree t, tree args,\n+                             tsubst_flags_t complain, tree in_decl)\n+{\n+  ++processing_template_decl;\n+  tree expr = tsubst_expr (TREE_OPERAND (t, 0), args, complain, in_decl, false);\n+  tree type = tsubst (TREE_OPERAND (t, 1), args, complain, in_decl);\n+  --processing_template_decl;\n+  bool noexcept_p = COMPOUND_REQ_NOEXCEPT_P (t);\n+  return finish_compound_requirement (expr, type, noexcept_p);\n+}\n+\n+/* Substitute ARGS into the nested requirement T. */\n+\n+tree\n+tsubst_nested_requirement (tree t, tree args,\n+                           tsubst_flags_t complain, tree in_decl)\n+{\n+  ++processing_template_decl;\n+  tree expr = tsubst_expr (TREE_OPERAND (t, 0), args, complain, in_decl, false);\n+  --processing_template_decl;\n+  return finish_nested_requirement (expr);\n+}\n+\n+inline tree\n+tsubst_requirement (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case SIMPLE_REQ:\n+      return tsubst_simple_requirement (t, args, complain, in_decl);\n+    case TYPE_REQ:\n+      return tsubst_type_requirement (t, args, complain, in_decl);\n+    case COMPOUND_REQ:\n+      return tsubst_compound_requirement (t, args, complain, in_decl);\n+    case NESTED_REQ:\n+      return tsubst_nested_requirement (t, args, complain, in_decl);\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return error_mark_node;\n+}\n+\n+/* Substitute ARGS into the list of requirements T. Note that\n+   substitution failures here result in ill-formed programs. */\n+\n+tree\n+tsubst_requirement_body (tree t, tree args,\n+                         tsubst_flags_t complain, tree in_decl)\n+{\n+  tree r = NULL_TREE;\n+  while (t)\n+    {\n+      tree e = tsubst_requirement (TREE_VALUE (t), args, complain, in_decl);\n+      if (e == error_mark_node)\n+        return error_mark_node;\n+      r = tree_cons (NULL_TREE, e, r);\n+      t = TREE_CHAIN (t);\n+    }\n+  return r;\n+}\n+\n+} /* namespace */\n+\n+/* Substitute ARGS into the requires expression T. Note that this\n+   results in the re-declaration of local parameters when\n+   substituting through the parameter list. If either substitution\n+   fails, the program is ill-formed. */\n+\n+tree\n+tsubst_requires_expr (tree t, tree args,\n+                      tsubst_flags_t complain, tree in_decl)\n+{\n+  local_specialization_stack stack;\n+\n+  tree parms = TREE_OPERAND (t, 0);\n+  if (parms)\n+    {\n+      parms = tsubst_constraint_variables (parms, args, complain, in_decl);\n+      if (parms == error_mark_node)\n+        return error_mark_node;\n+    }\n+\n+  tree reqs = TREE_OPERAND (t, 1);\n+  reqs = tsubst_requirement_body (reqs, args, complain, in_decl);\n+  if (reqs == error_mark_node)\n+    return error_mark_node;\n+\n+  return finish_requires_expr (parms, reqs);\n+}\n+\n+/* Substitute ARGS into the constraint information CI, producing a new\n+   constraint record. */\n+tree\n+tsubst_constraint_info (tree t, tree args,\n+                        tsubst_flags_t complain, tree in_decl)\n+{\n+  if (!t || t == error_mark_node || !check_constraint_info (t))\n+    return NULL_TREE;\n+\n+  tree tmpl_constr = NULL_TREE;\n+  if (tree r = CI_TEMPLATE_REQS (t))\n+    tmpl_constr = tsubst_constraint (r, args, complain, in_decl);\n+\n+  tree decl_constr = NULL_TREE;\n+  if (tree r = CI_DECLARATOR_REQS (t))\n+    decl_constr = tsubst_constraint (r, args, complain, in_decl);\n+\n+  return build_constraints (tmpl_constr, decl_constr);\n+}\n+\n+\n+/*---------------------------------------------------------------------------\n+                        Constraint satisfaction\n+---------------------------------------------------------------------------*/\n+\n+/* The following functions determine if a constraint, when\n+   substituting template arguments, is satisfied. For convenience,\n+   satisfaction reduces a constraint to either true or false (and\n+   nothing else). */\n+\n+namespace {\n+\n+tree satisfy_constraint_1 (tree, tree, tsubst_flags_t, tree);\n+\n+/* Check the constraint pack expansion.  */\n+\n+tree\n+satisfy_pack_expansion (tree t, tree args,\n+                      tsubst_flags_t complain, tree in_decl)\n+{\n+  /* Get the vector of satisfaction results.\n+     gen_elem_of_pack_expansion_instantiation will check that each element of\n+     the expansion is satisfied.  */\n+  tree exprs = tsubst_pack_expansion (t, args, complain, in_decl);\n+  if (exprs == error_mark_node)\n+    return boolean_false_node;\n+  int n = TREE_VEC_LENGTH (exprs);\n+\n+  for (int i = 0; i < n; ++i)\n+    if (TREE_VEC_ELT (exprs, i) != boolean_true_node)\n+      return boolean_false_node;\n+  return boolean_true_node;\n+}\n+\n+/* A predicate constraint is satisfied if its expression evaluates\n+   to true. If substitution into that node fails, the constraint\n+   is not satisfied ([temp.constr.pred]).\n+\n+   Note that a predicate constraint is a constraint expression\n+   of type bool. If neither of those are true, the program is\n+   ill-formed; they are not SFINAE'able errors. */\n+\n+tree\n+satisfy_predicate_constraint (tree t, tree args,\n+                              tsubst_flags_t complain, tree in_decl)\n+{\n+  tree original = TREE_OPERAND (t, 0);\n+\n+  /* We should never have a naked pack expansion in a predicate constraint.  */\n+  gcc_assert (TREE_CODE (original) != EXPR_PACK_EXPANSION);\n+\n+  tree expr = tsubst_expr (original, args, complain, in_decl, false);\n+  if (expr == error_mark_node)\n+    return boolean_false_node;\n+\n+  /* A predicate constraint shall have type bool. In some\n+     cases, substitution gives us const-qualified bool, which\n+     is also acceptable.  */\n+  tree type = cv_unqualified (TREE_TYPE (expr));\n+  if (!same_type_p (type, boolean_type_node))\n+    {\n+      error_at (EXPR_LOC_OR_LOC (expr, input_location),\n+                \"constraint %qE does not have type %qT\",\n+                expr, boolean_type_node);\n+      return boolean_false_node;\n+    }\n+\n+  tree value = cxx_constant_value (expr);\n+  return value;\n+}\n+\n+/* Check an expression constraint. The constraint is satisfied if\n+   substitution succeeds ([temp.constr.expr]).\n+\n+   Note that the expression is unevaluated. */\n+\n+tree\n+satisfy_expression_constraint (tree t, tree args,\n+                               tsubst_flags_t complain, tree in_decl)\n+{\n+  cp_unevaluated guard;\n+  deferring_access_check_sentinel deferring;\n+\n+  tree expr = EXPR_CONSTR_EXPR (t);\n+  tree check = tsubst_expr (expr, args, complain, in_decl, false);\n+  if (check == error_mark_node)\n+    return boolean_false_node;\n+  if (!perform_deferred_access_checks (tf_none))\n+    return boolean_false_node;\n+\n+  return boolean_true_node;\n+}\n+\n+/* Check a type constraint. The constraint is satisfied if\n+   substitution succeeds. */\n+\n+inline tree\n+satisfy_type_constraint (tree t, tree args,\n+                         tsubst_flags_t complain, tree in_decl)\n+{\n+  deferring_access_check_sentinel deferring;\n+  tree type = TYPE_CONSTR_TYPE (t);\n+  gcc_assert (TYPE_P (type) || type == error_mark_node);\n+  tree check = tsubst (type, args, complain, in_decl);\n+  if (error_operand_p (check))\n+    return boolean_false_node;\n+  if (!perform_deferred_access_checks (complain))\n+    return boolean_false_node;\n+\n+  return boolean_true_node;\n+}\n+\n+/* Check an implicit conversion constraint.  */\n+\n+tree\n+satisfy_implicit_conversion_constraint (tree t, tree args,\n+                                        tsubst_flags_t complain, tree in_decl)\n+{\n+  /* Don't tsubst as if we're processing a template. If we try\n+     to we can end up generating template-like expressions\n+     (e.g., modop-exprs) that aren't properly typed.  */\n+  tree expr =\n+    tsubst_expr (ICONV_CONSTR_EXPR (t), args, complain, in_decl, false);\n+  if (expr == error_mark_node)\n+    return boolean_false_node;\n+\n+  /* Get the transformed target type.  */\n+  tree type = tsubst (ICONV_CONSTR_TYPE (t), args, complain, in_decl);\n+  if (type == error_mark_node)\n+    return boolean_false_node;\n+\n+  /* Attempt the conversion as a direct initialization\n+     of the form TYPE <unspecified> = EXPR.  */\n+  tree conv =\n+    perform_direct_initialization_if_possible (type, expr, false, complain);\n+  if (conv == error_mark_node)\n+    return boolean_false_node;\n+  else\n+    return boolean_true_node;\n+}\n+\n+/* Check an argument deduction constraint. */\n+\n+tree\n+satisfy_argument_deduction_constraint (tree t, tree args,\n+                                       tsubst_flags_t complain, tree in_decl)\n+{\n+  /* Substitute through the expression. */\n+  tree expr = DEDUCT_CONSTR_EXPR (t);\n+  tree init = tsubst_expr (expr, args, complain, in_decl, false);\n+  if (expr == error_mark_node)\n+    return boolean_false_node;\n+\n+  /* Perform auto or decltype(auto) deduction to get the result. */\n+  tree pattern = DEDUCT_CONSTR_PATTERN (t);\n+  tree placeholder = DEDUCT_CONSTR_PLACEHOLDER (t);\n+  tree constr = PLACEHOLDER_TYPE_CONSTRAINTS (placeholder);\n+  PLACEHOLDER_TYPE_CONSTRAINTS (placeholder)\n+    = tsubst_constraint (constr, args, complain|tf_partial, in_decl);\n+  tree type = do_auto_deduction (pattern, init, placeholder,\n+                                 complain, adc_requirement);\n+  PLACEHOLDER_TYPE_CONSTRAINTS (placeholder) = constr;\n+  if (type == error_mark_node)\n+    return boolean_false_node;\n+\n+  return boolean_true_node;\n+}\n+\n+/* Check an exception constraint. An exception constraint for an\n+   expression e is satisfied when noexcept(e) is true. */\n+\n+tree\n+satisfy_exception_constraint (tree t, tree args,\n+                              tsubst_flags_t complain, tree in_decl)\n+{\n+  tree expr = EXCEPT_CONSTR_EXPR (t);\n+  tree check = tsubst_expr (expr, args, complain, in_decl, false);\n+  if (check == error_mark_node)\n+    return boolean_false_node;\n+\n+  if (expr_noexcept_p (check, complain))\n+    return boolean_true_node;\n+  else\n+    return boolean_false_node;\n+}\n+\n+/* Check a parameterized constraint. */\n+\n+tree\n+satisfy_parameterized_constraint (tree t, tree args,\n+                                  tsubst_flags_t complain, tree in_decl)\n+{\n+  local_specialization_stack stack;\n+  tree parms = PARM_CONSTR_PARMS (t);\n+  tree vars = tsubst_constraint_variables (parms, args, complain, in_decl);\n+  if (vars == error_mark_node)\n+    return boolean_false_node;\n+  tree constr = PARM_CONSTR_OPERAND (t);\n+  return satisfy_constraint_1 (constr, args, complain, in_decl);\n+}\n+\n+/* Check that the conjunction of constraints is satisfied. Note\n+   that if left operand is not satisfied, the right operand\n+   is not checked.\n+\n+   FIXME: Check that this wouldn't result in a user-defined\n+   operator. Note that this error is partially diagnosed in\n+   satisfy_predicate_constraint. It would be nice to diagnose\n+   the overload, but I don't think it's strictly necessary.  */\n+\n+tree\n+satisfy_conjunction (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n+{\n+  tree t0 = satisfy_constraint_1 (TREE_OPERAND (t, 0), args, complain, in_decl);\n+  if (t0 == boolean_false_node)\n+    return t0;\n+  tree t1 = satisfy_constraint_1 (TREE_OPERAND (t, 1), args, complain, in_decl);\n+  if (t1 == boolean_false_node)\n+    return t1;\n+  return boolean_true_node;\n+}\n+\n+/* Check that the disjunction of constraints is satisfied. Note\n+   that if the left operand is satisfied, the right operand is not\n+   checked.  */\n+\n+tree\n+satisfy_disjunction (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n+{\n+  tree t0 = satisfy_constraint_1 (TREE_OPERAND (t, 0), args, complain, in_decl);\n+  if (t0 == boolean_true_node)\n+    return boolean_true_node;\n+  tree t1 = satisfy_constraint_1 (TREE_OPERAND (t, 1), args, complain, in_decl);\n+  if (t1 == boolean_true_node)\n+    return boolean_true_node;\n+  return boolean_false_node;\n+}\n+\n+/* Dispatch to an appropriate satisfaction routine depending on the\n+   tree code of T.  */\n+\n+tree\n+satisfy_constraint_1 (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n+{\n+  gcc_assert (!processing_template_decl);\n+\n+  if (!t)\n+    return boolean_false_node;\n+\n+  if (t == error_mark_node)\n+    return boolean_false_node;\n+\n+  switch (TREE_CODE (t))\n+  {\n+  case PRED_CONSTR:\n+    return satisfy_predicate_constraint (t, args, complain, in_decl);\n+\n+  case EXPR_CONSTR:\n+    return satisfy_expression_constraint (t, args, complain, in_decl);\n+\n+  case TYPE_CONSTR:\n+    return satisfy_type_constraint (t, args, complain, in_decl);\n+\n+  case ICONV_CONSTR:\n+    return satisfy_implicit_conversion_constraint (t, args, complain, in_decl);\n+\n+  case DEDUCT_CONSTR:\n+    return satisfy_argument_deduction_constraint (t, args, complain, in_decl);\n+\n+  case EXCEPT_CONSTR:\n+    return satisfy_exception_constraint (t, args, complain, in_decl);\n+\n+  case PARM_CONSTR:\n+    return satisfy_parameterized_constraint (t, args, complain, in_decl);\n+\n+  case CONJ_CONSTR:\n+    return satisfy_conjunction (t, args, complain, in_decl);\n+\n+  case DISJ_CONSTR:\n+    return satisfy_disjunction (t, args, complain, in_decl);\n+\n+  case EXPR_PACK_EXPANSION:\n+    return satisfy_pack_expansion (t, args, complain, in_decl);\n+\n+  default:\n+    gcc_unreachable ();\n+  }\n+  return boolean_false_node;\n+}\n+\n+/* Check that the constraint is satisfied, according to the rules\n+   for that constraint. Note that each satisfy_* function returns\n+   true or false, depending on whether it is satisfied or not.  */\n+\n+tree\n+satisfy_constraint (tree t, tree args)\n+{\n+  /* Turn off template processing. Constraint satisfaction only applies\n+     to non-dependent terms, so we want full checking here.  */\n+  processing_template_decl_sentinel sentinel (true);\n+  /* Avoid early exit in tsubst and tsubst_copy from null args; since earlier\n+     substitution was done with processing_template_decl forced on, there will\n+     be expressions that still need semantic processing, possibly buried in\n+     decltype or a template argument.  */\n+  if (args == NULL_TREE)\n+    args = make_tree_vec (1);\n+  return satisfy_constraint_1 (t, args, tf_none, NULL_TREE);\n+}\n+\n+/* Check the associated constraints in CI against the given\n+   ARGS, returning true when the constraints are satisfied\n+   and false otherwise.  */\n+\n+tree\n+satisfy_associated_constraints (tree ci, tree args)\n+{\n+  /* If there are no constraints then this is trivially satisfied. */\n+  if (!ci)\n+    return boolean_true_node;\n+\n+  /* If any arguments depend on template parameters, we can't\n+     check constraints. */\n+  if (args && uses_template_parms (args))\n+    return boolean_true_node;\n+\n+  /* Invalid requirements cannot be satisfied. */\n+  if (!valid_constraints_p (ci))\n+    return boolean_false_node;\n+\n+  return satisfy_constraint (CI_NORMALIZED_CONSTRAINTS (ci), args);\n+}\n+\n+} /* namespace */\n+\n+/* Evaluate the given constraint, returning boolean_true_node\n+   if the constraint is satisfied and boolean_false_node\n+   otherwise. */\n+\n+tree\n+evaluate_constraints (tree constr, tree args)\n+{\n+  gcc_assert (constraint_p (constr));\n+  return satisfy_constraint (normalize_constraint (constr), args);\n+}\n+\n+/* Evaluate the function concept FN by substituting its own args\n+   into its definition and evaluating that as the result. Returns\n+   boolean_true_node if the constraints are satisfied and\n+   boolean_false_node otherwise.  */\n+\n+tree\n+evaluate_function_concept (tree fn, tree args)\n+{\n+  ++processing_template_decl;\n+  /* We lift using DECL_TI_ARGS because we want to delay producing\n+     non-dependent expressions until we're doing satisfaction.  We can't just\n+     go without any substitution because we need to lower the level of 'auto's\n+     in type deduction constraints.  */\n+  tree constr = transform_expression (lift_function_definition\n+\t\t\t\t      (fn, DECL_TI_ARGS (fn)));\n+  --processing_template_decl;\n+  return satisfy_constraint (constr, args);\n+}\n+\n+/* Evaluate the variable concept VAR by substituting its own args into\n+   its initializer and checking the resulting constraint. Returns\n+   boolean_true_node if the constraints are satisfied and\n+   boolean_false_node otherwise.  */\n+\n+tree\n+evaluate_variable_concept (tree decl, tree args)\n+{\n+  ++processing_template_decl;\n+  tree constr = transform_expression (lift_variable_initializer\n+\t\t\t\t      (decl, DECL_TI_ARGS (decl)));\n+  --processing_template_decl;\n+  return satisfy_constraint (constr, args);\n+}\n+\n+/* Evaluate the given expression as if it were a predicate\n+   constraint. Returns boolean_true_node if the constraint\n+   is satisfied and boolean_false_node otherwise. */\n+\n+tree\n+evaluate_constraint_expression (tree expr, tree args)\n+{\n+  ++processing_template_decl;\n+  tree constr = transform_expression (lift_expression (expr));\n+  --processing_template_decl;\n+  return satisfy_constraint (constr, args);\n+}\n+\n+/* Returns true if the DECL's constraints are satisfied.\n+   This is used in cases where a declaration is formed but\n+   before it is used (e.g., overload resolution). */\n+\n+bool\n+constraints_satisfied_p (tree decl)\n+{\n+  /* Get the constraints to check for satisfaction. This depends\n+     on whether we're looking at a template specialization or not. */\n+  tree ci;\n+  tree args = NULL_TREE;\n+  if (tree ti = DECL_TEMPLATE_INFO (decl))\n+    {\n+      ci = get_constraints (TI_TEMPLATE (ti));\n+      args = INNERMOST_TEMPLATE_ARGS (TI_ARGS (ti));\n+    }\n+  else\n+    {\n+      ci = get_constraints (decl);\n+    }\n+\n+  tree eval = satisfy_associated_constraints (ci, args);\n+  return eval == boolean_true_node;\n+}\n+\n+/* Returns true if the constraints are satisfied by ARGS.\n+   Here, T can be either a constraint or a constrained\n+   declaration.  */\n+\n+bool\n+constraints_satisfied_p (tree t, tree args)\n+{\n+  tree eval;\n+  if (constraint_p (t))\n+    eval = evaluate_constraints (t, args);\n+  else\n+    eval = satisfy_associated_constraints (get_constraints (t), args);\n+  return eval == boolean_true_node;\n+}\n+\n+namespace\n+{\n+\n+/* Normalize EXPR and determine if the resulting constraint is\n+   satisfied by ARGS. Returns true if and only if the constraint\n+   is satisfied.  This is used extensively by diagnostics to\n+   determine causes for failure.  */\n+\n+inline bool\n+constraint_expression_satisfied_p (tree expr, tree args)\n+{\n+  return evaluate_constraint_expression (expr, args) == boolean_true_node;\n+}\n+\n+} /* namespace */\n+\n+\n+/*---------------------------------------------------------------------------\n+                Semantic analysis of requires-expressions\n+---------------------------------------------------------------------------*/\n+\n+/* Finish a requires expression for the given PARMS (possibly\n+   null) and the non-empty sequence of requirements. */\n+tree\n+finish_requires_expr (tree parms, tree reqs)\n+{\n+  /* Modify the declared parameters by removing their context\n+     so they don't refer to the enclosing scope and explicitly\n+     indicating that they are constraint variables. */\n+  for (tree parm = parms; parm; parm = DECL_CHAIN (parm))\n+    {\n+      DECL_CONTEXT (parm) = NULL_TREE;\n+      CONSTRAINT_VAR_P (parm) = true;\n+    }\n+\n+  /* Build the node. */\n+  tree r = build_min (REQUIRES_EXPR, boolean_type_node, parms, reqs);\n+  TREE_SIDE_EFFECTS (r) = false;\n+  TREE_CONSTANT (r) = true;\n+  return r;\n+}\n+\n+/* Construct a requirement for the validity of EXPR. */\n+tree\n+finish_simple_requirement (tree expr)\n+{\n+  return build_nt (SIMPLE_REQ, expr);\n+}\n+\n+/* Construct a requirement for the validity of TYPE. */\n+tree\n+finish_type_requirement (tree type)\n+{\n+  return build_nt (TYPE_REQ, type);\n+}\n+\n+/* Construct a requirement for the validity of EXPR, along with\n+   its properties. if TYPE is non-null, then it specifies either\n+   an implicit conversion or argument deduction constraint,\n+   depending on whether any placeholders occur in the type name.\n+   NOEXCEPT_P is true iff the noexcept keyword was specified. */\n+tree\n+finish_compound_requirement (tree expr, tree type, bool noexcept_p)\n+{\n+  tree req = build_nt (COMPOUND_REQ, expr, type);\n+  COMPOUND_REQ_NOEXCEPT_P (req) = noexcept_p;\n+  return req;\n+}\n+\n+/* Finish a nested requirement. */\n+tree\n+finish_nested_requirement (tree expr)\n+{\n+  return build_nt (NESTED_REQ, expr);\n+}\n+\n+// Check that FN satisfies the structural requirements of a\n+// function concept definition.\n+tree\n+check_function_concept (tree fn)\n+{\n+  // Check that the function is comprised of only a single\n+  // return statement.\n+  tree body = DECL_SAVED_TREE (fn);\n+  if (TREE_CODE (body) == BIND_EXPR)\n+    body = BIND_EXPR_BODY (body);\n+\n+  // Sometimes a function call results in the creation of clean up\n+  // points. Allow these to be preserved in the body of the\n+  // constraint, as we might actually need them for some constexpr\n+  // evaluations.\n+  if (TREE_CODE (body) == CLEANUP_POINT_EXPR)\n+    body = TREE_OPERAND (body, 0);\n+\n+  /* Check that the definition is written correctly. */\n+  if (TREE_CODE (body) != RETURN_EXPR)\n+    {\n+      location_t loc = DECL_SOURCE_LOCATION (fn);\n+      if (TREE_CODE (body) == STATEMENT_LIST && !STATEMENT_LIST_HEAD (body))\n+        error_at (loc, \"definition of concept %qD is empty\", fn);\n+      else\n+        error_at (loc, \"definition of concept %qD has multiple statements\", fn);\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+\n+// Check that a constrained friend declaration function declaration,\n+// FN, is admissible. This is the case only when the declaration depends\n+// on template parameters and does not declare a specialization.\n+void\n+check_constrained_friend (tree fn, tree reqs)\n+{\n+  if (fn == error_mark_node)\n+    return;\n+  gcc_assert (TREE_CODE (fn) == FUNCTION_DECL);\n+\n+  // If there are not constraints, this cannot be an error.\n+  if (!reqs)\n+    return;\n+\n+  // Constrained friend functions that don't depend on template\n+  // arguments are effectively meaningless.\n+  if (!uses_template_parms (TREE_TYPE (fn)))\n+    {\n+      error_at (location_of (fn),\n+\t\t\"constrained friend does not depend on template parameters\");\n+      return;\n+    }\n+}\n+\n+/*---------------------------------------------------------------------------\n+                        Equivalence of constraints\n+---------------------------------------------------------------------------*/\n+\n+/* Returns true when A and B are equivalent constraints.  */\n+bool\n+equivalent_constraints (tree a, tree b)\n+{\n+  gcc_assert (!a || TREE_CODE (a) == CONSTRAINT_INFO);\n+  gcc_assert (!b || TREE_CODE (b) == CONSTRAINT_INFO);\n+  return cp_tree_equal (a, b);\n+}\n+\n+/* Returns true if the template declarations A and B have equivalent\n+   constraints. This is the case when A's constraints subsume B's and\n+   when B's also constrain A's.  */\n+bool\n+equivalently_constrained (tree d1, tree d2)\n+{\n+  gcc_assert (TREE_CODE (d1) == TREE_CODE (d2));\n+  return equivalent_constraints (get_constraints (d1), get_constraints (d2));\n+}\n+\n+/*---------------------------------------------------------------------------\n+                     Partial ordering of constraints\n+---------------------------------------------------------------------------*/\n+\n+/* Returns true when the the constraints in A subsume those in B.  */\n+bool\n+subsumes_constraints (tree a, tree b)\n+{\n+  gcc_assert (!a || TREE_CODE (a) == CONSTRAINT_INFO);\n+  gcc_assert (!b || TREE_CODE (b) == CONSTRAINT_INFO);\n+  return subsumes (a, b);\n+}\n+\n+/* Determines which of the declarations, A or B, is more constrained.\n+   That is, which declaration's constraints subsume but are not subsumed\n+   by the other's?\n+\n+   Returns 1 if A is more constrained than B, -1 if B is more constrained\n+   than A, and 0 otherwise. */\n+int\n+more_constrained (tree d1, tree d2)\n+{\n+  tree c1 = get_constraints (d1);\n+  tree c2 = get_constraints (d2);\n+  int winner = 0;\n+  if (subsumes_constraints (c1, c2))\n+    ++winner;\n+  if (subsumes_constraints (c2, c1))\n+    --winner;\n+  return winner;\n+}\n+\n+/* Returns true if D1 is at least as constrained as D2. That is, the\n+   associated constraints of D1 subsume those of D2, or both declarations\n+   are unconstrained. */\n+bool\n+at_least_as_constrained (tree d1, tree d2)\n+{\n+  tree c1 = get_constraints (d1);\n+  tree c2 = get_constraints (d2);\n+  return subsumes_constraints (c1, c2);\n+}\n+\n+\n+/*---------------------------------------------------------------------------\n+                        Constraint diagnostics\n+---------------------------------------------------------------------------*/\n+\n+/* The diagnosis of constraints performs a combination of\n+   normalization and satisfaction testing. We recursively\n+   walk through the conjunction (or disjunctions) of associated\n+   constraints, testing each sub-expression in turn.\n+\n+   We currently restrict diagnostics to just the top-level\n+   conjunctions within the associated constraints. A fully\n+   recursive walk is possible, but it can generate a lot\n+   of errors. */\n+\n+\n+namespace {\n+\n+void diagnose_expression (location_t, tree, tree);\n+void diagnose_constraint (location_t, tree, tree);\n+\n+/* Diagnose a conjunction of constraints. */\n+void\n+diagnose_logical_operation (location_t loc, tree t, tree args)\n+{\n+  diagnose_expression (loc, TREE_OPERAND (t, 0), args);\n+  diagnose_expression (loc, TREE_OPERAND (t, 0), args);\n+}\n+\n+/* Determine if the trait expression T is satisfied by ARGS.\n+   Emit a precise diagnostic if it is not. */\n+void\n+diagnose_trait_expression (location_t loc, tree t, tree args)\n+{\n+  if (constraint_expression_satisfied_p (t, args))\n+    return;\n+\n+  /* Rebuild the trait expression so we can diagnose the\n+     specific failure. */\n+  ++processing_template_decl;\n+  tree expr = tsubst_expr (t, args, tf_none, NULL_TREE, false);\n+  --processing_template_decl;\n+\n+  tree t1 = TRAIT_EXPR_TYPE1 (expr);\n+  tree t2 = TRAIT_EXPR_TYPE2 (expr);\n+  switch (TRAIT_EXPR_KIND (t))\n+    {\n+    case CPTK_HAS_NOTHROW_ASSIGN:\n+      inform (loc, \"  %qT is not nothrow copy assignable\", t1);\n+      break;\n+    case CPTK_HAS_NOTHROW_CONSTRUCTOR:\n+      inform (loc, \"  %qT is not nothrow default constructible\", t1);\n+      break;\n+    case CPTK_HAS_NOTHROW_COPY:\n+      inform (loc, \"  %qT is not nothrow copy constructible\", t1);\n+      break;\n+    case CPTK_HAS_TRIVIAL_ASSIGN:\n+      inform (loc, \"  %qT is not trivially copy assignable\", t1);\n+      break;\n+    case CPTK_HAS_TRIVIAL_CONSTRUCTOR:\n+      inform (loc, \"  %qT is not trivially default constructible\", t1);\n+      break;\n+    case CPTK_HAS_TRIVIAL_COPY:\n+      inform (loc, \"  %qT is not trivially copy constructible\", t1);\n+      break;\n+    case CPTK_HAS_TRIVIAL_DESTRUCTOR:\n+      inform (loc, \"  %qT is not trivially destructible\", t1);\n+      break;\n+    case CPTK_HAS_VIRTUAL_DESTRUCTOR:\n+      inform (loc, \"  %qT does not have a virtual destructor\", t1);\n+      break;\n+    case CPTK_IS_ABSTRACT:\n+      inform (loc, \"  %qT is not an abstract class\", t1);\n+      break;\n+    case CPTK_IS_BASE_OF:\n+      inform (loc, \"  %qT is not a base of %qT\", t1, t2);\n+      break;\n+    case CPTK_IS_CLASS:\n+      inform (loc, \"  %qT is not a class\", t1);\n+      break;\n+    case CPTK_IS_EMPTY:\n+      inform (loc, \"  %qT is not an empty class\", t1);\n+      break;\n+    case CPTK_IS_ENUM:\n+      inform (loc, \"  %qT is not an enum\", t1);\n+      break;\n+    case CPTK_IS_FINAL:\n+      inform (loc, \"  %qT is not a final class\", t1);\n+      break;\n+    case CPTK_IS_LITERAL_TYPE:\n+      inform (loc, \"  %qT is not a literal type\", t1);\n+      break;\n+    case CPTK_IS_POD:\n+      inform (loc, \"  %qT is not a POD type\", t1);\n+      break;\n+    case CPTK_IS_POLYMORPHIC:\n+      inform (loc, \"  %qT is not a polymorphic type\", t1);\n+      break;\n+    case CPTK_IS_SAME_AS:\n+      inform (loc, \"  %qT is not the same as %qT\", t1, t2);\n+      break;\n+    case CPTK_IS_STD_LAYOUT:\n+      inform (loc, \"  %qT is not an standard layout type\", t1);\n+      break;\n+    case CPTK_IS_TRIVIAL:\n+      inform (loc, \"  %qT is not a trivial type\", t1);\n+      break;\n+    case CPTK_IS_UNION:\n+      inform (loc, \"  %qT is not a union\", t1);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Determine if the call expression T, when normalized as a constraint,\n+   is satisfied by ARGS.\n+\n+   TODO: If T is refers to a concept, We could recursively analyze\n+   its definition to identify the exact failure, but that could\n+   emit a *lot* of error messages (defeating the purpose of\n+   improved diagnostics). Consider adding a flag to control the\n+   depth of diagnostics. */\n+void\n+diagnose_call_expression (location_t loc, tree t, tree args)\n+{\n+  if (constraint_expression_satisfied_p (t, args))\n+    return;\n+\n+  /* Rebuild the expression for the purpose of diagnostics. */\n+  ++processing_template_decl;\n+  tree expr = tsubst_expr (t, args, tf_none, NULL_TREE, false);\n+  --processing_template_decl;\n+\n+  /* If the function call is known to be a concept check, then\n+     diagnose it differently (i.e., we may recurse). */\n+  if (resolve_constraint_check (t))\n+    inform (loc, \"  concept %qE was not satisfied\", expr);\n+  else\n+    inform (loc, \"  %qE evaluated to false\", expr);\n+}\n+\n+/* Determine if the template-id T, when normalized as a constraint\n+   is satisfied by ARGS. */\n+void\n+diagnose_template_id (location_t loc, tree t, tree args)\n+{\n+  /* Check for invalid template-ids. */\n+  if (!variable_template_p (TREE_OPERAND (t, 0)))\n+    {\n+      inform (loc, \"  invalid constraint %qE\", t);\n+      return;\n+    }\n+\n+  if (constraint_expression_satisfied_p (t, args))\n+    return;\n+\n+  /* Rebuild the expression for the purpose of diagnostics. */\n+  ++processing_template_decl;\n+  tree expr = tsubst_expr (t, args, tf_none, NULL_TREE, false);\n+  --processing_template_decl;\n+\n+  tree var = DECL_TEMPLATE_RESULT (TREE_OPERAND (t, 0));\n+  if (DECL_DECLARED_CONCEPT_P (var))\n+    inform (loc, \"  concept %qE was not satisfied\", expr);\n+  else\n+    inform (loc, \"  %qE evaluated to false\", expr);\n+}\n+\n+/* Determine if the requires-expression, when normalized as a\n+   constraint is satisfied by ARGS.\n+\n+   TODO: Build sets of expressions, types, and constraints\n+   based on the requirements in T and emit specific diagnostics\n+   for those. */\n+void\n+diagnose_requires_expression (location_t loc, tree t, tree args)\n+{\n+  if (constraint_expression_satisfied_p (t, args))\n+    return;\n+  inform (loc, \"requirements not satisfied\");\n+}\n+\n+void\n+diagnose_pack_expansion (location_t loc, tree t, tree args)\n+{\n+  if (constraint_expression_satisfied_p (t, args))\n+    return;\n+\n+  /* Make sure that we don't have naked packs that we don't expect. */\n+  if (!same_type_p (TREE_TYPE (t), boolean_type_node))\n+    {\n+      inform (loc, \"invalid pack expansion in constraint %qE\", t);\n+      return;\n+    }\n+\n+  inform (loc, \"  in the expansion of %qE\", t);\n+\n+  /* Get the vector of expanded arguments. Note that n must not\n+     be 0 since this constraint is not satisfied.  */\n+  ++processing_template_decl;\n+  tree exprs = tsubst_pack_expansion (t, args, tf_none, NULL_TREE);\n+  --processing_template_decl;\n+  if (exprs == error_mark_node)\n+    {\n+      /* TODO: This error message could be better. */\n+      inform (loc, \"    substitution failure occurred during expansion\");\n+      return;\n+    }\n+\n+  /* Check each expanded constraint separately. */\n+  int n = TREE_VEC_LENGTH (exprs);\n+  for (int i = 0; i < n; ++i)\n+    {\n+      tree expr = TREE_VEC_ELT (exprs, i);\n+      if (!constraint_expression_satisfied_p (expr, args))\n+        inform (loc, \"    %qE was not satisfied\", expr);\n+    }\n+}\n+\n+/* Diagnose an expression that would be characterized as\n+   a predicate constraint. */\n+void\n+diagnose_other_expression (location_t loc, tree t, tree args)\n+{\n+  if (constraint_expression_satisfied_p (t, args))\n+    return;\n+  inform (loc, \"  %qE evaluated to false\", t);\n+}\n+\n+void\n+diagnose_expression (location_t loc, tree t, tree args)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case TRUTH_ANDIF_EXPR:\n+      diagnose_logical_operation (loc, t, args);\n+      break;\n+\n+    case TRUTH_ORIF_EXPR:\n+      diagnose_logical_operation (loc, t, args);\n+      break;\n+\n+    case CALL_EXPR:\n+      diagnose_call_expression (loc, t, args);\n+      break;\n+\n+    case TEMPLATE_ID_EXPR:\n+      diagnose_template_id (loc, t, args);\n+      break;\n+\n+    case REQUIRES_EXPR:\n+      diagnose_requires_expression (loc, t, args);\n+      break;\n+\n+    case TRAIT_EXPR:\n+      diagnose_trait_expression (loc, t, args);\n+      break;\n+\n+    case EXPR_PACK_EXPANSION:\n+      diagnose_pack_expansion (loc, t, args);\n+      break;\n+\n+    default:\n+      diagnose_other_expression (loc, t, args);\n+      break;\n+    }\n+}\n+\n+inline void\n+diagnose_predicate_constraint (location_t loc, tree t, tree args)\n+{\n+  diagnose_expression (loc, PRED_CONSTR_EXPR (t), args);\n+}\n+\n+inline void\n+diagnose_conjunction (location_t loc, tree t, tree args)\n+{\n+  diagnose_constraint (loc, TREE_OPERAND (t, 0), args);\n+  diagnose_constraint (loc, TREE_OPERAND (t, 1), args);\n+}\n+\n+/* Diagnose the constraint T for the given ARGS. This is only\n+   ever invoked on the associated constraints, so we can\n+   only have conjunctions of predicate constraints. */\n+void\n+diagnose_constraint (location_t loc, tree t, tree args)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case CONJ_CONSTR:\n+      diagnose_conjunction (loc, t, args);\n+      break;\n+\n+    case PRED_CONSTR:\n+      diagnose_predicate_constraint (loc, t, args);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+}\n+\n+/* Diagnose the reason(s) why ARGS do not satisfy the constraints\n+   of declaration DECL. */\n+\n+void\n+diagnose_declaration_constraints (location_t loc, tree decl, tree args)\n+{\n+  inform (loc, \"  constraints not satisfied\");\n+\n+  /* Constraints are attached to the template.  */\n+  if (tree ti = DECL_TEMPLATE_INFO (decl))\n+    {\n+      decl = TI_TEMPLATE (ti);\n+      if (!args)\n+\targs = TI_ARGS (ti);\n+    }\n+\n+  /* Check that the constraints are actually valid.  */\n+  tree ci = get_constraints (decl);\n+  if (!valid_constraints_p (ci))\n+    {\n+      inform (loc, \"    invalid constraints\");\n+      return;\n+    }\n+\n+  /* Recursively diagnose the associated constraints.  */\n+  diagnose_constraint (loc, CI_ASSOCIATED_CONSTRAINTS (ci), args);\n+}\n+\n+} // namespace\n+\n+/* Emit diagnostics detailing the failure ARGS to satisfy the\n+   constraints of T. Here, T can be either a constraint\n+   or a declaration.  */\n+\n+void\n+diagnose_constraints (location_t loc, tree t, tree args)\n+{\n+  if (constraint_p (t))\n+    diagnose_constraint (loc, t, args);\n+  else\n+    diagnose_declaration_constraints (loc, t, args);\n+}"}, {"sha": "2cab89c1552df783d0291eaac30262a879c3c5b4", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -100,6 +100,8 @@ cp_tree_size (enum tree_code code)\n \n     case TEMPLATE_INFO:         return sizeof (struct tree_template_info);\n \n+    case CONSTRAINT_INFO:       return sizeof (struct tree_constraint_info);\n+\n     case USERDEF_LITERAL:\treturn sizeof (struct tree_userdef_literal);\n \n     case TEMPLATE_DECL:\t\treturn sizeof (struct tree_template_decl);\n@@ -240,6 +242,7 @@ cp_common_init_ts (void)\n {\n   MARK_TS_DECL_NON_COMMON (USING_DECL);\n   MARK_TS_DECL_COMMON (TEMPLATE_DECL);\n+  MARK_TS_DECL_COMMON (WILDCARD_DECL);\n \n   MARK_TS_COMMON (TEMPLATE_TEMPLATE_PARM);\n   MARK_TS_COMMON (TEMPLATE_TYPE_PARM);\n@@ -311,6 +314,7 @@ cp_common_init_ts (void)\n   MARK_TS_TYPED (LAMBDA_EXPR);\n   MARK_TS_TYPED (CTOR_INITIALIZER);\n   MARK_TS_TYPED (ARRAY_NOTATION_REF);\n+  MARK_TS_TYPED (REQUIRES_EXPR);\n }\n \n #include \"gt-cp-cp-objcp-common.h\""}, {"sha": "61acf2718855c2058705466159d86bc637fa089a", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -475,6 +475,94 @@ DEFTREECODE (BASES, \"bases\", tcc_type, 0)\n    instantiation time.  */\n DEFTREECODE (TEMPLATE_INFO, \"template_info\", tcc_exceptional, 0)\n \n+/* Extensions for Concepts. */\n+\n+/* Used to represent information associated with constrained declarations. */\n+DEFTREECODE (CONSTRAINT_INFO, \"constraint_info\", tcc_exceptional, 0)\n+\n+/* A wildcard declaration is a placeholder for a template parameter\n+   used to resolve constrained-type-names in concepts.  During\n+   resolution, the matching argument is saved as the TREE_TYPE\n+   of the wildcard.  */\n+DEFTREECODE (WILDCARD_DECL, \"wildcard_decl\", tcc_declaration, 0)\n+\n+/* A requires-expr is a binary expression. The first operand is\n+   its parameter list (possibly NULL). The second is a list of\n+   requirements, which are denoted by the _REQ* tree codes\n+   below. */\n+DEFTREECODE (REQUIRES_EXPR,   \"requires_expr\", tcc_expression, 2)\n+\n+/* A requirement for an expression. */\n+DEFTREECODE (SIMPLE_REQ, \"simple_req\", tcc_expression, 1)\n+\n+/* A requirement for a type. */\n+DEFTREECODE (TYPE_REQ, \"type_req\", tcc_expression, 1)\n+\n+/* A requirement for an expression and its properties. The\n+   first operand is the expression, and the 2nd is its type.\n+   The accessor COMPOUND_REQ_NOEXCEPT determines whether\n+   the noexcept keyword was present. */\n+DEFTREECODE (COMPOUND_REQ, \"compound_req\", tcc_expression, 2)\n+\n+/* A requires clause within a requires expression. */\n+DEFTREECODE (NESTED_REQ, \"nested_req\", tcc_expression, 1)\n+\n+/* Constraints are modeled as kinds of expressions.\n+   The operands of a constraint can be either types or expressions.\n+   Unlike expressions, constraints do not have a type. */\n+\n+/* A predicate constraint evaluates an expression E.\n+\n+   PRED_CONSTR_EXPR has the expression to be evaluated. */\n+DEFTREECODE (PRED_CONSTR, \"pred_constr\", tcc_expression, 1)\n+\n+/* An expression constraint determines the validity of a expression E.\n+\n+   EXPR_CONST_EXPR has the expression being validated. */\n+DEFTREECODE (EXPR_CONSTR, \"expr_constr\", tcc_expression, 1)\n+\n+/* A type constraint determines the validity of a type T. Note that\n+\n+   TYPE_CONST_TYPE has the type being validated */\n+DEFTREECODE (TYPE_CONSTR, \"type_constr\", tcc_expression, 1)\n+\n+/* An implicit conversion constraint determines if an expression\n+   E is implicitly convertible to a type T. Note that T may\n+   be dependent but does not contain any placeholders.\n+\n+   ICONV_CONSTR_EXPR has the expression E.\n+   ICONV_CONSTR_TYPE has the type T.\n+   */\n+DEFTREECODE (ICONV_CONSTR, \"iconv_constr\", tcc_expression, 2)\n+\n+/* An argument deduction constraint determines if the type of an\n+   expression E can be deduced from a type pattern T. Note that\n+   T must contain at least one place holder.\n+\n+   DEDUCT_CONSTR_EXPR has the expression E\n+   DEDUCT_CONSTR_PATTERN has the type patter T.\n+   DEDUCT_CONSTR_PLACEHOLDERS has the list of placeholder nodes in T. */\n+DEFTREECODE (DEDUCT_CONSTR, \"deduct_constr\", tcc_expression, 3)\n+\n+/* An exception constraint determines if, for an expression E,\n+   noexcept(E) is true.\n+\n+   EXCEPT_CONSTR_EXPR has the expression E. */\n+DEFTREECODE (EXCEPT_CONSTR, \"except_constr\", tcc_expression, 1)\n+\n+/* A parameterized constraint declares constraint variables, which\n+   are used in expression, type, and exception constraints.\n+\n+   PARM_CONSTR_PARMS has a TREE_LIST of parameter declarations.\n+   PARM_CONSTR_OPERAND has the nested constraint. */\n+DEFTREECODE (PARM_CONSTR, \"parm_constr\", tcc_expression, 2)\n+\n+/* The conjunction and disjunction of two constraints, respectively.\n+   Operands are accessed using TREE_OPERAND. */\n+DEFTREECODE (CONJ_CONSTR, \"conj_constr\", tcc_expression, 2)\n+DEFTREECODE (DISJ_CONSTR, \"disj_constr\", tcc_expression, 2)\n+\n+\n /*\n Local variables:\n mode:c"}, {"sha": "78fd4af0a2fbe6e7d817de80dbcf85fd272c08c3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 312, "deletions": 5, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -77,6 +77,8 @@ c-common.h, not after.\n       PACK_EXPANSION_LOCAL_P (in *_PACK_EXPANSION)\n       TINFO_HAS_ACCESS_ERRORS (in TEMPLATE_INFO)\n       SIZEOF_EXPR_TYPE_P (in SIZEOF_EXPR)\n+      COMPOUND_REQ_NOEXCEPT_P (in COMPOUND_REQ)\n+      WILDCARD_PACK_P (in WILDCARD_DECL)\n       BLOCK_OUTER_CURLY_BRACE_P (in BLOCK)\n    1: IDENTIFIER_VIRTUAL_P (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n@@ -154,6 +156,7 @@ c-common.h, not after.\n       LABEL_DECL_CONTINUE (in LABEL_DECL)\n    2: DECL_THIS_EXTERN (in VAR_DECL or FUNCTION_DECL).\n       DECL_IMPLICIT_TYPEDEF_P (in a TYPE_DECL)\n+      DECL_CONSTRAINT_VAR_P (in a PARM_DECL)\n       TEMPLATE_DECL_COMPLEX_ALIAS_P (in TEMPLATE_DECL)\n       DECL_INSTANTIATING_NSDMI_P (in a FIELD_DECL)\n    3: DECL_IN_AGGR_P.\n@@ -660,6 +663,7 @@ typedef enum cp_trait_kind\n   CPTK_IS_LITERAL_TYPE,\n   CPTK_IS_POD,\n   CPTK_IS_POLYMORPHIC,\n+  CPTK_IS_SAME_AS,\n   CPTK_IS_STD_LAYOUT,\n   CPTK_IS_TRIVIAL,\n   CPTK_IS_TRIVIALLY_ASSIGNABLE,\n@@ -812,6 +816,154 @@ struct GTY(()) tree_template_info {\n   vec<qualified_typedef_usage_t, va_gc> *typedefs_needing_access_checking;\n };\n \n+// Constraint information for a C++ declaration. Constraint information is\n+// comprised of:\n+//\n+// - a constraint expression introduced by the template header\n+// - a constraint expression introduced by a function declarator\n+// - the associated constraints, which are the conjunction of those,\n+//   and used for declaration matching\n+// - the cached normalized associated constraints which are used\n+//   to support satisfaction and subsumption.\n+// - assumptions which is the result of decomposing the normalized\n+//   constraints.\n+//\n+// The template and declarator requirements are kept to support pretty\n+// printing constrained declarations.\n+struct GTY(()) tree_constraint_info {\n+  struct tree_base base;\n+  tree template_reqs;\n+  tree declarator_reqs;\n+  tree associated_constr;\n+  tree normalized_constr;\n+  tree assumptions;\n+};\n+\n+// Require that pointer P is non-null before returning.\n+template<typename T>\n+inline T*\n+check_nonnull (T* p)\n+{\n+  gcc_assert (p);\n+  return p;\n+}\n+\n+// Returns true iff T is non-null and represents constraint info.\n+inline tree_constraint_info *\n+check_constraint_info (tree t)\n+{\n+  if (t && TREE_CODE (t) == CONSTRAINT_INFO)\n+    return (tree_constraint_info *)t;\n+  return NULL;\n+}\n+\n+// Access the expression describing the template constraints. This may be\n+// null if no constraints were introduced in the template parameter list,\n+// a requirements clause after the template parameter list, or constraints\n+// through a constrained-type-specifier.\n+#define CI_TEMPLATE_REQS(NODE) \\\n+  check_constraint_info (check_nonnull(NODE))->template_reqs\n+\n+// Access the expression describing the trailing constraints. This is non-null\n+// for any implicit instantiation of a constrained declaration. For a\n+// templated declaration it is non-null only when a trailing requires-clause\n+// was specified.\n+#define CI_DECLARATOR_REQS(NODE) \\\n+  check_constraint_info (check_nonnull(NODE))->declarator_reqs\n+\n+// The computed associated constraint expression for a declaration.\n+#define CI_ASSOCIATED_CONSTRAINTS(NODE) \\\n+  check_constraint_info (check_nonnull(NODE))->associated_constr\n+\n+// The normalized associated constraints.\n+#define CI_NORMALIZED_CONSTRAINTS(NODE) \\\n+  check_constraint_info (check_nonnull(NODE))->normalized_constr\n+\n+// Get the set of assumptions associated with the constraint info node.\n+#define CI_ASSUMPTIONS(NODE) \\\n+  check_constraint_info (check_nonnull(NODE))->assumptions\n+\n+// Access the logical constraints on the template parameters introduced\n+// at a given template parameter list level indicated by NODE.\n+#define TEMPLATE_PARMS_CONSTRAINTS(NODE) \\\n+  TREE_TYPE (TREE_LIST_CHECK (NODE))\n+\n+// Access the logical constraints on the template parameter declaration\n+// indicated by NODE.\n+#define TEMPLATE_PARM_CONSTRAINTS(NODE) \\\n+  TREE_TYPE (TREE_LIST_CHECK (NODE))\n+\n+/* Non-zero if the noexcept is present in a compound requirement. */\n+#define COMPOUND_REQ_NOEXCEPT_P(NODE) \\\n+  TREE_LANG_FLAG_0 (TREE_CHECK (NODE, COMPOUND_REQ))\n+\n+/* The constraints on an 'auto' placeholder type, used in an argument deduction\n+   constraint.  */\n+#define PLACEHOLDER_TYPE_CONSTRAINTS(NODE) \\\n+  DECL_SIZE_UNIT (TYPE_NAME (NODE))\n+\n+/* The expression evaluated by the predicate constraint. */\n+#define PRED_CONSTR_EXPR(NODE) \\\n+  TREE_OPERAND (TREE_CHECK (NODE, PRED_CONSTR), 0)\n+\n+/* The expression validated by the predicate constraint. */\n+#define EXPR_CONSTR_EXPR(NODE) \\\n+  TREE_OPERAND (TREE_CHECK (NODE, EXPR_CONSTR), 0)\n+\n+/* The type validated by the predicate constraint. */\n+#define TYPE_CONSTR_TYPE(NODE) \\\n+  TREE_OPERAND (TREE_CHECK (NODE, TYPE_CONSTR), 0)\n+\n+/* In an implicit conversion constraint, the source expression. */\n+#define ICONV_CONSTR_EXPR(NODE) \\\n+  TREE_OPERAND (TREE_CHECK (NODE, ICONV_CONSTR), 0)\n+\n+/* In an implicit conversion constraint, the target type. */\n+#define ICONV_CONSTR_TYPE(NODE) \\\n+  TREE_OPERAND (TREE_CHECK (NODE, ICONV_CONSTR), 1)\n+\n+/* In an argument deduction constraint, the source expression. */\n+#define DEDUCT_CONSTR_EXPR(NODE) \\\n+  TREE_OPERAND (TREE_CHECK (NODE, DEDUCT_CONSTR), 0)\n+\n+/* In an argument deduction constraint, the target type pattern. */\n+#define DEDUCT_CONSTR_PATTERN(NODE) \\\n+  TREE_OPERAND (TREE_CHECK (NODE, DEDUCT_CONSTR), 1)\n+\n+/* In an argument deduction constraint, the list of placeholder nodes. */\n+#define DEDUCT_CONSTR_PLACEHOLDER(NODE) \\\n+  TREE_OPERAND (TREE_CHECK (NODE, DEDUCT_CONSTR), 2)\n+\n+/* The expression of an exception constraint. */\n+#define EXCEPT_CONSTR_EXPR(NODE) \\\n+  TREE_OPERAND (TREE_CHECK (NODE, EXCEPT_CONSTR), 0)\n+\n+/* In a parameterized constraint, the local parameters. */\n+#define PARM_CONSTR_PARMS(NODE) \\\n+  TREE_OPERAND (TREE_CHECK (NODE, PARM_CONSTR), 0)\n+\n+/* In a parameterized constraint, the operand. */\n+#define PARM_CONSTR_OPERAND(NODE) \\\n+  TREE_OPERAND (TREE_CHECK (NODE, PARM_CONSTR), 1)\n+\n+/* Whether a PARM_DECL represents a local parameter in a\n+   requires-expression.  */\n+#define CONSTRAINT_VAR_P(NODE) \\\n+  DECL_LANG_FLAG_2 (TREE_CHECK (NODE, PARM_DECL))\n+\n+/* The concept constraining this constrained template-parameter.  */\n+#define CONSTRAINED_PARM_CONCEPT(NODE) \\\n+  DECL_SIZE_UNIT (TYPE_DECL_CHECK (NODE))\n+/* Any extra template arguments specified for a constrained\n+   template-parameter.  */\n+#define CONSTRAINED_PARM_EXTRA_ARGS(NODE) \\\n+  DECL_SIZE (TYPE_DECL_CHECK (NODE))\n+/* The first template parameter of CONSTRAINED_PARM_CONCEPT to be used as a\n+   prototype for the constrained parameter in finish_shorthand_constraint,\n+   attached for convenience.  */\n+#define CONSTRAINED_PARM_PROTOTYPE(NODE) \\\n+  DECL_INITIAL (TYPE_DECL_CHECK (NODE))\n+\n enum cp_tree_node_structure_enum {\n   TS_CP_GENERIC,\n   TS_CP_IDENTIFIER,\n@@ -829,6 +981,7 @@ enum cp_tree_node_structure_enum {\n   TS_CP_TRAIT_EXPR,\n   TS_CP_LAMBDA_EXPR,\n   TS_CP_TEMPLATE_INFO,\n+  TS_CP_CONSTRAINT_INFO,\n   TS_CP_USERDEF_LITERAL,\n   LAST_TS_CP_ENUM\n };\n@@ -856,6 +1009,8 @@ union GTY((desc (\"cp_tree_node_structure (&%h)\"),\n     lambda_expression;\n   struct tree_template_info GTY ((tag (\"TS_CP_TEMPLATE_INFO\")))\n     template_info;\n+  struct tree_constraint_info GTY ((tag (\"TS_CP_CONSTRAINT_INFO\")))\n+    constraint_info;\n   struct tree_userdef_literal GTY ((tag (\"TS_CP_USERDEF_LITERAL\")))\n     userdef_literal;\n };\n@@ -2021,7 +2176,8 @@ struct GTY(()) lang_decl_base {\n   unsigned template_conv_p : 1;\t\t   /* var or template */\n   unsigned odr_used : 1;\t\t   /* var or fn */\n   unsigned u2sel : 1;\n-  /* 1 spare bit */\n+  unsigned concept_p : 1;                  /* applies to vars and functions */\n+  /* 0 spare bits */\n };\n \n /* True for DECL codes which have template info and access.  */\n@@ -2569,6 +2725,12 @@ struct GTY(()) lang_decl {\n #define DECL_DECLARED_CONSTEXPR_P(DECL) \\\n   DECL_LANG_FLAG_8 (VAR_OR_FUNCTION_DECL_CHECK (STRIP_TEMPLATE (DECL)))\n \n+// True if NODE was declared as 'concept'.  The flag implies that the\n+// declaration is constexpr, that the declaration cannot be specialized or\n+// refined, and that the result type must be convertible to bool.\n+#define DECL_DECLARED_CONCEPT_P(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->u.base.concept_p)\n+\n /* Nonzero if this DECL is the __PRETTY_FUNCTION__ variable in a\n    template function.  */\n #define DECL_PRETTY_FUNCTION_P(NODE) \\\n@@ -3036,6 +3198,9 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n /* True iff this pack expansion is within a function context.  */\n #define PACK_EXPANSION_LOCAL_P(NODE) TREE_LANG_FLAG_0 (NODE)\n \n+/* True iff the wildcard can match a template parameter pack.  */\n+#define WILDCARD_PACK_P(NODE) TREE_LANG_FLAG_0 (NODE)\n+\n /* Determine if this is an argument pack.  */\n #define ARGUMENT_PACK_P(NODE)                          \\\n   (TREE_CODE (NODE) == TYPE_ARGUMENT_PACK              \\\n@@ -4504,6 +4669,15 @@ extern int comparing_specializations;\n \n extern int cp_unevaluated_operand;\n \n+/* RAII class used to inhibit the evaluation of operands during parsing\n+   and template instantiation. Evaluation warnings are also inhibited. */\n+\n+struct cp_unevaluated\n+{\n+  cp_unevaluated ();\n+  ~cp_unevaluated ();\n+};\n+\n /* in pt.c  */\n \n /* These values are used for the `STRICT' parameter to type_unification and\n@@ -4516,6 +4690,17 @@ typedef enum unification_kind_t {\n   DEDUCE_EXACT\n } unification_kind_t;\n \n+// An RAII class used to create a new pointer map for local\n+// specializations. When the stack goes out of scope, the\n+// previous pointer map is restored.\n+struct local_specialization_stack\n+{\n+  local_specialization_stack ();\n+  ~local_specialization_stack ();\n+\n+  hash_map<tree, tree> *saved;\n+};\n+\n /* in class.c */\n \n extern int current_class_depth;\n@@ -4810,6 +4995,17 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n #define TEMPLATE_TYPE_PARAMETER_PACK(NODE) \\\n   (TEMPLATE_PARM_PARAMETER_PACK (TEMPLATE_TYPE_PARM_INDEX (NODE)))\n \n+/* Contexts in which auto deduction occurs. These flags are\n+   used to control diagnostics in do_auto_deduction.  */\n+\n+enum auto_deduction_context\n+{\n+  adc_unspecified,   /* Not given */\n+  adc_variable_type, /* Variable initializer deduction */\n+  adc_return_type,   /* Return type deduction */\n+  adc_requirement    /* Argument dedution constraint */\n+};\n+\n /* True iff this TEMPLATE_TYPE_PARM represents decltype(auto).  */\n #define AUTO_IS_DECLTYPE(NODE) \\\n   (TYPE_LANG_FLAG_5 (TEMPLATE_TYPE_PARM_CHECK (NODE)))\n@@ -4963,6 +5159,7 @@ typedef enum cp_decl_spec {\n   ds_std_attribute,\n   ds_storage_class,\n   ds_long_long,\n+  ds_concept,\n   ds_last /* This enumerator must always be the last one.  */\n } cp_decl_spec;\n \n@@ -5092,6 +5289,8 @@ struct cp_declarator {\n       tree exception_specification;\n       /* The late-specified return type, if any.  */\n       tree late_return_type;\n+      /* The trailing requires-clause, if any. */\n+      tree requires_clause;\n     } function;\n     /* For arrays.  */\n     struct {\n@@ -5157,7 +5356,7 @@ class_of_this_parm (const_tree fntype)\n   return TREE_TYPE (type_of_this_parm (fntype));\n }\n \n-/* True if T designates a variable template declaration.  */\n+/* True iff T is a variable template declaration. */\n inline bool\n variable_template_p (tree t)\n {\n@@ -5170,6 +5369,30 @@ variable_template_p (tree t)\n   return false;\n }\n \n+/* True iff T is a variable concept definition. That is, T is\n+   a variable template declared with the concept specifier. */\n+inline bool\n+variable_concept_p (tree t)\n+{\n+  if (TREE_CODE (t) != TEMPLATE_DECL)\n+    return false;\n+  if (tree r = DECL_TEMPLATE_RESULT (t))\n+    return VAR_P (r) && DECL_DECLARED_CONCEPT_P (r);\n+  return false;\n+}\n+\n+/* True iff T is a concept definition. That is, T is a variable or function\n+   template declared with the concept specifier. */\n+inline bool\n+concept_template_p (tree t)\n+{\n+  if (TREE_CODE (t) != TEMPLATE_DECL)\n+    return false;\n+  if (tree r = DECL_TEMPLATE_RESULT (t))\n+    return VAR_OR_FUNCTION_DECL_P (r) && DECL_DECLARED_CONCEPT_P (r);\n+  return false;\n+}\n+\n /* A parameter list indicating for a function with no parameters,\n    e.g  \"int f(void)\".  */\n extern cp_parameter_declarator *no_parameters;\n@@ -5266,7 +5489,7 @@ extern tree get_vtable_decl\t\t\t(tree, int);\n extern void resort_type_method_vec\t\t(void *, void *,\n \t\t\t\t\t\t gt_pointer_operator, void *);\n extern bool add_method\t\t\t\t(tree, tree, tree);\n-extern bool currently_open_class\t\t(tree);\n+extern tree currently_open_class\t\t(tree);\n extern tree currently_open_derived_class\t(tree);\n extern tree outermost_open_class\t\t(void);\n extern tree current_nonlambda_class_type\t(void);\n@@ -5402,6 +5625,7 @@ extern tree build_ptrmemfunc_type\t\t(tree);\n extern tree build_ptrmem_type\t\t\t(tree, tree);\n /* the grokdeclarator prototype is in decl.h */\n extern tree build_this_parm\t\t\t(tree, cp_cv_quals);\n+extern tree grokparms\t\t\t\t(tree, tree *);\n extern int copy_fn_p\t\t\t\t(const_tree);\n extern bool move_fn_p                           (const_tree);\n extern bool move_signature_fn_p                 (const_tree);\n@@ -5679,7 +5903,10 @@ extern int num_template_headers_for_class\t(tree);\n extern void check_template_variable\t\t(tree);\n extern tree make_auto\t\t\t\t(void);\n extern tree make_decltype_auto\t\t\t(void);\n-extern tree do_auto_deduction\t\t\t(tree, tree, tree);\n+extern tree do_auto_deduction                   (tree, tree, tree);\n+extern tree do_auto_deduction                   (tree, tree, tree,\n+                                                 tsubst_flags_t,\n+                                                 auto_deduction_context);\n extern tree type_uses_auto\t\t\t(tree);\n extern tree type_uses_auto_or_concept\t\t(tree);\n extern void append_type_to_template_for_access_check (tree, tree, tree,\n@@ -5691,13 +5918,14 @@ extern bool is_auto_or_concept\t\t\t(const_tree);\n extern tree process_template_parm\t\t(tree, location_t, tree, \n \t\t\t\t\t\t bool, bool);\n extern tree end_template_parm_list\t\t(tree);\n+extern void end_template_parm_list\t\t(void);\n extern void end_template_decl\t\t\t(void);\n extern tree maybe_update_decl_type\t\t(tree, tree);\n extern bool check_default_tmpl_args             (tree, tree, bool, bool, int);\n extern tree push_template_decl\t\t\t(tree);\n extern tree push_template_decl_real\t\t(tree, bool);\n extern tree add_inherited_template_parms\t(tree, tree);\n-extern bool redeclare_class_template\t\t(tree, tree);\n+extern bool redeclare_class_template\t\t(tree, tree, tree);\n extern tree lookup_template_class\t\t(tree, tree, tree, tree,\n \t\t\t\t\t\t int, tsubst_flags_t);\n extern tree lookup_template_function\t\t(tree, tree);\n@@ -5742,6 +5970,9 @@ extern tree tsubst_default_argument\t\t(tree, tree, tree,\n extern tree tsubst (tree, tree, tsubst_flags_t, tree);\n extern tree tsubst_copy_and_build\t\t(tree, tree, tsubst_flags_t,\n \t\t\t\t\t\t tree, bool, bool);\n+extern tree tsubst_expr                         (tree, tree, tsubst_flags_t,\n+                                                 tree, bool);\n+extern tree tsubst_pack_expansion               (tree, tree, tsubst_flags_t, tree);\n extern tree most_general_template\t\t(tree);\n extern tree get_mostly_instantiated_function_type (tree);\n extern bool problematic_instantiation_changed\t(void);\n@@ -5792,6 +6023,12 @@ extern tree get_template_argument_pack_elems\t(const_tree);\n extern tree get_function_template_decl\t\t(const_tree);\n extern tree resolve_nondeduced_context\t\t(tree);\n extern hashval_t iterative_hash_template_arg (tree arg, hashval_t val);\n+extern tree coerce_template_parms               (tree, tree, tree);\n+extern tree coerce_template_parms               (tree, tree, tree, tsubst_flags_t);\n+extern void register_local_specialization       (tree, tree);\n+extern tree retrieve_local_specialization       (tree);\n+extern tree extract_fnparm_pack                 (tree, tree *);\n+extern tree template_parm_to_arg                (tree);\n \n /* in repo.c */\n extern void init_repo\t\t\t\t(void);\n@@ -5882,6 +6119,22 @@ extern bool perform_access_checks (vec<deferred_access_check, va_gc> *,\n extern bool perform_deferred_access_checks\t(tsubst_flags_t);\n extern bool perform_or_defer_access_check\t(tree, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n+\n+/* RAII sentinel to ensures that deferred access checks are popped before\n+  a function returns.  */\n+\n+struct deferring_access_check_sentinel\n+{\n+  deferring_access_check_sentinel ()\n+  {\n+    push_deferring_access_checks (dk_deferred);\n+  }\n+  ~deferring_access_check_sentinel ()\n+  {\n+    pop_deferring_access_checks ();\n+  }\n+};\n+\n extern int stmts_are_full_exprs_p\t\t(void);\n extern void init_cp_semantics\t\t\t(void);\n extern tree do_poplevel\t\t\t\t(tree);\n@@ -6392,6 +6645,60 @@ extern bool cxx_omp_privatize_by_reference\t(const_tree);\n extern void suggest_alternatives_for            (location_t, tree);\n extern tree strip_using_decl                    (tree);\n \n+/* in constraint.cc */\n+extern void init_constraint_processing          ();\n+extern bool constraint_p                        (tree);\n+extern tree make_predicate_constraint           (tree);\n+extern tree conjoin_constraints                 (tree, tree);\n+extern tree conjoin_constraints                 (tree);\n+extern bool valid_constraints_p                 (tree);\n+extern tree get_constraints                     (tree);\n+extern void set_constraints                     (tree, tree);\n+extern void remove_constraints                  (tree);\n+extern tree current_template_constraints\t(void);\n+extern tree associate_classtype_constraints     (tree);\n+extern tree build_constraints                   (tree, tree);\n+extern tree get_shorthand_constraints           (tree);\n+extern tree build_concept_check                 (tree, tree, tree = NULL_TREE);\n+extern tree build_constrained_parameter         (tree, tree, tree = NULL_TREE);\n+extern tree make_constrained_auto               (tree, tree);\n+extern bool deduce_constrained_parameter        (tree, tree&, tree&);\n+extern tree resolve_constraint_check            (tree);\n+extern tree check_function_concept              (tree);\n+extern tree finish_template_introduction        (tree, tree);\n+extern bool valid_requirements_p                (tree);\n+extern tree finish_concept_name                 (tree);\n+extern tree finish_shorthand_constraint         (tree, tree);\n+extern tree finish_requires_expr                (tree, tree);\n+extern tree finish_simple_requirement           (tree);\n+extern tree finish_type_requirement             (tree);\n+extern tree finish_compound_requirement         (tree, tree, bool);\n+extern tree finish_nested_requirement           (tree);\n+extern void check_constrained_friend            (tree, tree);\n+extern tree tsubst_requires_expr                (tree, tree, tsubst_flags_t, tree);\n+extern tree tsubst_constraint                   (tree, tree, tsubst_flags_t, tree);\n+extern tree tsubst_constraint_info              (tree, tree, tsubst_flags_t, tree);\n+extern bool function_concept_check_p            (tree);\n+\n+extern tree evaluate_constraints                (tree, tree);\n+extern tree evaluate_function_concept           (tree, tree);\n+extern tree evaluate_variable_concept           (tree, tree);\n+extern tree evaluate_constraint_expression      (tree, tree);\n+extern bool constraints_satisfied_p             (tree);\n+extern bool constraints_satisfied_p             (tree, tree);\n+\n+extern bool equivalent_constraints              (tree, tree);\n+extern bool equivalently_constrained            (tree, tree);\n+extern bool subsumes_constraints                (tree, tree);\n+extern int more_constrained                     (tree, tree);\n+\n+extern void diagnose_constraints                (location_t, tree, tree);\n+\n+/* in logic.cc */\n+extern tree decompose_assumptions               (tree);\n+extern tree decompose_conclusions               (tree);\n+extern bool subsumes                            (tree, tree);\n+\n /* in vtable-class-hierarchy.c */\n extern void vtv_compute_class_hierarchy_transitive_closure (void);\n extern void vtv_generate_init_routine           (void);"}, {"sha": "879eb71fc3ab51328feeaf8990f34e599b6906c1", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 333, "deletions": 6, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -451,6 +451,10 @@ cxx_pretty_printer::primary_expression (tree t)\n       pp_cxx_offsetof_expression (this, t);\n       break;\n \n+    case REQUIRES_EXPR:\n+      pp_cxx_requires_expr (this, t);\n+      break;\n+\n     default:\n       c_pretty_printer::primary_expression (t);\n       break;\n@@ -1064,6 +1068,7 @@ cxx_pretty_printer::expression (tree t)\n     case TEMPLATE_PARM_INDEX:\n     case TEMPLATE_TEMPLATE_PARM:\n     case STMT_EXPR:\n+    case REQUIRES_EXPR:\n       primary_expression (t);\n       break;\n \n@@ -1158,6 +1163,22 @@ cxx_pretty_printer::expression (tree t)\n       pp_cxx_ws_string (this, \"<lambda>\");\n       break;\n \n+    case TRAIT_EXPR:\n+      pp_cxx_trait_expression (this, t);\n+      break;\n+\n+    case PRED_CONSTR:\n+    case EXPR_CONSTR:\n+    case TYPE_CONSTR:\n+    case ICONV_CONSTR:\n+    case DEDUCT_CONSTR:\n+    case EXCEPT_CONSTR:\n+    case PARM_CONSTR:\n+    case CONJ_CONSTR:\n+    case DISJ_CONSTR:\n+      pp_cxx_constraint (this, t);\n+      break;\n+\n     case PAREN_EXPR:\n       pp_cxx_left_paren (this);\n       expression (TREE_OPERAND (t, 0));\n@@ -1423,10 +1444,26 @@ pp_cxx_parameter_declaration (cxx_pretty_printer *pp, tree t)\n static void\n pp_cxx_parameter_declaration_clause (cxx_pretty_printer *pp, tree t)\n {\n-  tree args = TYPE_P (t) ? NULL : FUNCTION_FIRST_USER_PARM (t);\n-  tree types =\n-    TYPE_P (t) ? TYPE_ARG_TYPES (t) : FUNCTION_FIRST_USER_PARMTYPE (t);\n-  const bool abstract = args == NULL || pp->flags & pp_c_flag_abstract;\n+  tree args;\n+  tree types;\n+  bool abstract;\n+\n+  // For a requires clause or the explicit printing of a parameter list\n+  // we expect T to be a chain of PARM_DECLs. Otherwise, the list of\n+  // args and types are taken from the function decl T.\n+  if (TREE_CODE (t) == PARM_DECL)\n+    {\n+      args = t;\n+      types = t;\n+      abstract = false;\n+    }\n+  else\n+    {\n+      bool type_p = TYPE_P (t);\n+      args = type_p ? NULL : FUNCTION_FIRST_USER_PARM (t);\n+      types = type_p ? TYPE_ARG_TYPES (t) : FUNCTION_FIRST_USER_PARMTYPE (t);\n+      abstract = args == NULL || pp->flags & pp_c_flag_abstract;\n+    }\n   bool first = true;\n \n   /* Skip artificial parameter for nonstatic member functions.  */\n@@ -1574,6 +1611,12 @@ void\n cxx_pretty_printer::declarator (tree t)\n {\n   direct_declarator (t);\n+\n+  // Print a requires clause.\n+  if (flag_concepts)\n+    if (tree ci = get_constraints (t))\n+      if (tree reqs = CI_DECLARATOR_REQS (ci))\n+        pp_cxx_requires_clause (this, reqs);\n }\n \n /* ctor-initializer:\n@@ -2154,7 +2197,13 @@ pp_cxx_canonical_template_parameter (cxx_pretty_printer *pp, tree parm)\n \n /*\n   template-declaration:\n-     export(opt) template < template-parameter-list > declaration   */\n+     export(opt) template < template-parameter-list > declaration\n+\n+  Concept extensions:\n+\n+  template-declaration:\n+     export(opt) template < template-parameter-list >\n+       requires-clause(opt) declaration */\n \n static void\n pp_cxx_template_declaration (cxx_pretty_printer *pp, tree t)\n@@ -2171,6 +2220,15 @@ pp_cxx_template_declaration (cxx_pretty_printer *pp, tree t)\n       pp_cxx_end_template_argument_list (pp);\n       pp_newline_and_indent (pp, 3);\n     }\n+\n+  if (flag_concepts)\n+    if (tree ci = get_constraints (t))\n+      if (tree reqs = CI_TEMPLATE_REQS (ci))\n+         {\n+            pp_cxx_requires_clause (pp, reqs);\n+            pp_newline_and_indent (pp, 6);\n+         }\n+\n   if (TREE_CODE (t) == FUNCTION_DECL && DECL_SAVED_TREE (t))\n     pp_cxx_function_definition (pp, t);\n   else\n@@ -2387,6 +2445,9 @@ pp_cxx_trait_expression (cxx_pretty_printer *pp, tree t)\n     case CPTK_IS_POLYMORPHIC:\n       pp_cxx_ws_string (pp, \"__is_polymorphic\");\n       break;\n+    case CPTK_IS_SAME_AS:\n+      pp_cxx_ws_string (pp, \"__is_same_as\");\n+      break;\n     case CPTK_IS_STD_LAYOUT:\n       pp_cxx_ws_string (pp, \"__is_std_layout\");\n       break;\n@@ -2416,14 +2477,280 @@ pp_cxx_trait_expression (cxx_pretty_printer *pp, tree t)\n   pp_cxx_left_paren (pp);\n   pp->type_id (TRAIT_EXPR_TYPE1 (t));\n \n-  if (kind == CPTK_IS_BASE_OF)\n+  if (kind == CPTK_IS_BASE_OF || kind == CPTK_IS_SAME_AS)\n     {\n       pp_cxx_separate_with (pp, ',');\n       pp->type_id (TRAIT_EXPR_TYPE2 (t));\n     }\n \n   pp_cxx_right_paren (pp);\n }\n+\n+// requires-clause:\n+//    'requires' logical-or-expression\n+void\n+pp_cxx_requires_clause (cxx_pretty_printer *pp, tree t)\n+{\n+  if (!t)\n+    return;\n+  pp->padding = pp_before;\n+  pp_cxx_ws_string (pp, \"requires\");\n+  pp_space (pp);\n+  pp->expression (t);\n+}\n+\n+/* requirement:\n+     simple-requirement\n+     compound-requirement\n+     type-requirement\n+     nested-requirement */\n+static void\n+pp_cxx_requirement (cxx_pretty_printer *pp, tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case SIMPLE_REQ:\n+      pp_cxx_simple_requirement (pp, t);\n+      break;\n+\n+    case TYPE_REQ:\n+      pp_cxx_type_requirement (pp, t);\n+      break;\n+\n+    case COMPOUND_REQ:\n+      pp_cxx_compound_requirement (pp, t);\n+      break;\n+\n+    case NESTED_REQ:\n+      pp_cxx_nested_requirement (pp, t);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+// requirement-list:\n+//    requirement\n+//    requirement-list ';' requirement[opt]\n+//\n+static void\n+pp_cxx_requirement_list (cxx_pretty_printer *pp, tree t)\n+{\n+  for (; t; t = TREE_CHAIN (t))\n+    pp_cxx_requirement (pp, TREE_VALUE (t));\n+}\n+\n+// requirement-body:\n+//    '{' requirement-list '}'\n+static void\n+pp_cxx_requirement_body (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_cxx_left_brace (pp);\n+  pp_cxx_requirement_list (pp, t);\n+  pp_cxx_right_brace (pp);\n+}\n+\n+// requires-expression:\n+//    'requires' requirement-parameter-list requirement-body\n+void\n+pp_cxx_requires_expr (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_string (pp, \"requires\");\n+  if (tree parms = TREE_OPERAND (t, 0))\n+    {\n+      pp_cxx_parameter_declaration_clause (pp, parms);\n+      pp_cxx_whitespace (pp);\n+    }\n+  pp_cxx_requirement_body (pp, TREE_OPERAND (t, 1));\n+}\n+\n+/* simple-requirement:\n+     expression ';' */\n+void\n+pp_cxx_simple_requirement (cxx_pretty_printer *pp, tree t)\n+{\n+  pp->expression (TREE_OPERAND (t, 0));\n+  pp_cxx_semicolon (pp);\n+}\n+\n+/* type-requirement:\n+     typename type-name ';' */\n+void\n+pp_cxx_type_requirement (cxx_pretty_printer *pp, tree t)\n+{\n+  pp->type_id (TREE_OPERAND (t, 0));\n+  pp_cxx_semicolon (pp);\n+}\n+\n+/* compound-requirement:\n+     '{' expression '}' 'noexcept' [opt] trailing-return-type [opt] */\n+void\n+pp_cxx_compound_requirement (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_cxx_left_brace (pp);\n+  pp->expression (TREE_OPERAND (t, 0));\n+  pp_cxx_right_brace (pp);\n+\n+  if (COMPOUND_REQ_NOEXCEPT_P (t))\n+    pp_cxx_ws_string (pp, \"noexcept\");\n+\n+  if (tree type = TREE_OPERAND (t, 1))\n+    {\n+      pp_cxx_ws_string (pp, \"->\");\n+      pp->type_id (type);\n+    }\n+}\n+\n+/* nested requirement:\n+     'requires' constraint-expression */\n+void\n+pp_cxx_nested_requirement (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_cxx_ws_string (pp, \"requires\");\n+  pp->expression (TREE_OPERAND (t, 0));\n+  pp_cxx_semicolon (pp);\n+}\n+\n+void\n+pp_cxx_predicate_constraint (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_string (pp, \"predicate\");\n+  pp_left_paren (pp);\n+  pp->expression (TREE_OPERAND (t, 0));\n+  pp_right_paren (pp);\n+}\n+\n+void\n+pp_cxx_expression_constraint (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_string (pp, \"valid_expr\");\n+  pp_left_paren (pp);\n+  pp->expression (TREE_OPERAND (t, 0));\n+  pp_right_paren (pp);\n+}\n+\n+void\n+pp_cxx_type_constraint (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_string (pp, \"valid_type\");\n+  pp_left_paren (pp);\n+  pp->type_id (TREE_OPERAND (t, 0));\n+  pp_right_paren (pp);\n+}\n+\n+void\n+pp_cxx_implicit_conversion_constraint (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_string (pp, \"convertible\");\n+  pp_left_paren (pp);\n+  pp->expression (ICONV_CONSTR_EXPR (t));\n+  pp_cxx_separate_with (pp, ',');\n+  pp->expression (ICONV_CONSTR_TYPE (t));\n+  pp_right_paren (pp);\n+}\n+\n+void\n+pp_cxx_argument_deduction_constraint (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_string (pp, \"deducible\");\n+  pp_left_paren (pp);\n+  pp->expression (DEDUCT_CONSTR_EXPR (t));\n+  pp_cxx_separate_with (pp, ',');\n+  pp->expression (DEDUCT_CONSTR_PATTERN (t));\n+  pp_right_paren (pp);\n+}\n+\n+void\n+pp_cxx_exception_constraint (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_cxx_ws_string (pp, \"noexcept\");\n+  pp_left_paren (pp);\n+  pp->expression (TREE_OPERAND (t, 0));\n+  pp_right_paren (pp);\n+}\n+\n+void\n+pp_cxx_parameterized_constraint (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_left_paren (pp);\n+  pp_string (pp, \"forall\");\n+  if (tree parms = PARM_CONSTR_PARMS (t))\n+    {\n+      if (parms)\n+\tpp_cxx_parameter_declaration_clause (pp, parms);\n+      pp_cxx_whitespace (pp);\n+    }\n+  pp_cxx_constraint (pp, PARM_CONSTR_OPERAND (t));\n+  pp_right_paren (pp);\n+}\n+\n+void\n+pp_cxx_conjunction (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_cxx_constraint (pp, TREE_OPERAND (t, 0));\n+  pp_string (pp, \" and \");\n+  pp_cxx_constraint (pp, TREE_OPERAND (t, 1));\n+}\n+\n+void\n+pp_cxx_disjunction (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_cxx_constraint (pp, TREE_OPERAND (t, 0));\n+  pp_string (pp, \" or \");\n+  pp_cxx_constraint (pp, TREE_OPERAND (t, 1));\n+}\n+\n+void\n+pp_cxx_constraint (cxx_pretty_printer *pp, tree t)\n+{\n+  if (t == error_mark_node)\n+    return pp->expression (t);\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case PRED_CONSTR:\n+      pp_cxx_predicate_constraint (pp, t);\n+      break;\n+\n+    case EXPR_CONSTR:\n+      pp_cxx_expression_constraint (pp, t);\n+      break;\n+\n+    case TYPE_CONSTR:\n+      pp_cxx_type_constraint (pp, t);\n+      break;\n+\n+    case ICONV_CONSTR:\n+      pp_cxx_implicit_conversion_constraint (pp, t);\n+      break;\n+\n+    case DEDUCT_CONSTR:\n+      pp_cxx_argument_deduction_constraint (pp, t);\n+      break;\n+\n+    case EXCEPT_CONSTR:\n+      pp_cxx_exception_constraint (pp, t);\n+      break;\n+\n+    case PARM_CONSTR:\n+      pp_cxx_parameterized_constraint (pp, t);\n+      break;\n+\n+    case CONJ_CONSTR:\n+      pp_cxx_conjunction (pp, t);\n+      break;\n+\n+    case DISJ_CONSTR:\n+      pp_cxx_disjunction (pp, t);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+\n \f\n typedef c_pretty_print_fn pp_fun;\n "}, {"sha": "e5161df0644a44ec092ee1808e5d649e7078dc69", "filename": "gcc/cp/cxx-pretty-print.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fcxx-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fcxx-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.h?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -91,6 +91,21 @@ void pp_cxx_trait_expression (cxx_pretty_printer *, tree);\n void pp_cxx_va_arg_expression (cxx_pretty_printer *, tree);\n void pp_cxx_offsetof_expression (cxx_pretty_printer *, tree);\n void pp_cxx_userdef_literal (cxx_pretty_printer *, tree);\n-\n+void pp_cxx_requires_clause (cxx_pretty_printer *, tree);\n+void pp_cxx_requires_expr (cxx_pretty_printer *, tree);\n+void pp_cxx_simple_requirement (cxx_pretty_printer *, tree);\n+void pp_cxx_type_requirement (cxx_pretty_printer *, tree);\n+void pp_cxx_compound_requirement (cxx_pretty_printer *, tree);\n+void pp_cxx_nested_requirement (cxx_pretty_printer *, tree);\n+void pp_cxx_predicate_constraint (cxx_pretty_printer *, tree);\n+void pp_cxx_expression_constraint (cxx_pretty_printer *, tree);\n+void pp_cxx_type_constraint (cxx_pretty_printer *, tree);\n+void pp_cxx_implicit_conversion_constraint (cxx_pretty_printer *, tree);\n+void pp_cxx_argument_deduction_constraint (cxx_pretty_printer *, tree);\n+void pp_cxx_exception_constraint (cxx_pretty_printer *, tree);\n+void pp_cxx_parameterized_constraint (cxx_pretty_printer *, tree);\n+void pp_cxx_conjunction (cxx_pretty_printer *, tree);\n+void pp_cxx_disjunction (cxx_pretty_printer *, tree);\n+void pp_cxx_constraint (cxx_pretty_printer *, tree);\n \n #endif /* GCC_CXX_PRETTY_PRINT_H */"}, {"sha": "e8ed472293bd7bd6972e865b649ba6ab58030a59", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 242, "deletions": 25, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -72,7 +72,6 @@ enum bad_spec_place {\n   BSP_FIELD   /* field */\n };\n \n-static tree grokparms (tree parmlist, tree *);\n static const char *redeclaration_error_message (tree, tree);\n \n static int decl_jump_unsafe (tree);\n@@ -1079,20 +1078,23 @@ decls_match (tree newdecl, tree olddecl)\n     }\n   else if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n     {\n-      if (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl))\n-\t  != TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)))\n+      tree oldres = DECL_TEMPLATE_RESULT (olddecl);\n+      tree newres = DECL_TEMPLATE_RESULT (newdecl);\n+\n+      if (TREE_CODE (newres) != TREE_CODE (oldres))\n \treturn 0;\n \n       if (!comp_template_parms (DECL_TEMPLATE_PARMS (newdecl),\n \t\t\t\tDECL_TEMPLATE_PARMS (olddecl)))\n \treturn 0;\n \n       if (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL)\n-\ttypes_match = same_type_p (TREE_TYPE (DECL_TEMPLATE_RESULT (olddecl)),\n-\t\t\t\t   TREE_TYPE (DECL_TEMPLATE_RESULT (newdecl)));\n+\ttypes_match = (same_type_p (TREE_TYPE (oldres), TREE_TYPE (newres))\n+\t\t       && equivalently_constrained (olddecl, newdecl));\n       else\n-\ttypes_match = decls_match (DECL_TEMPLATE_RESULT (olddecl),\n-\t\t\t\t   DECL_TEMPLATE_RESULT (newdecl));\n+\t// We don't need to check equivalently_constrained for variable and\n+\t// function templates because we check it on the results.\n+\ttypes_match = decls_match (oldres, newres);\n     }\n   else\n     {\n@@ -1120,6 +1122,11 @@ decls_match (tree newdecl, tree olddecl)\n \t\t\t\t COMPARE_REDECLARATION);\n     }\n \n+  // Normal functions can be constrained, as can variable partial\n+  // specializations.\n+  if (types_match && VAR_OR_FUNCTION_DECL_P (newdecl))\n+    types_match = equivalently_constrained (newdecl, olddecl);\n+\n   return types_match;\n }\n \n@@ -1243,6 +1250,36 @@ validate_constexpr_redeclaration (tree old_decl, tree new_decl)\n   return true;\n }\n \n+// If OLDDECL and NEWDECL are concept declarations with the same type\n+// (i.e., and template parameters), but different requirements,\n+// emit diagnostics and return true. Otherwise, return false.\n+static inline bool\n+check_concept_refinement (tree olddecl, tree newdecl)\n+{\n+  if (!DECL_DECLARED_CONCEPT_P (olddecl) || !DECL_DECLARED_CONCEPT_P (newdecl))\n+    return false;\n+\n+  tree d1 = DECL_TEMPLATE_RESULT (olddecl);\n+  tree d2 = DECL_TEMPLATE_RESULT (newdecl);\n+  if (TREE_CODE (d1) != TREE_CODE (d2))\n+    return false;\n+\n+  tree t1 = TREE_TYPE (d1);\n+  tree t2 = TREE_TYPE (d2);\n+  if (TREE_CODE (d1) == FUNCTION_DECL)\n+    {\n+      if (compparms (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2))\n+          && comp_template_parms (DECL_TEMPLATE_PARMS (olddecl),\n+                                  DECL_TEMPLATE_PARMS (newdecl))\n+          && !equivalently_constrained (olddecl, newdecl))\n+        {\n+          error (\"cannot specialize concept %q#D\", olddecl);\n+          return true;\n+        }\n+    }\n+  return false;\n+}\n+\n /* DECL is a redeclaration of a function or function template.  If\n    it does have default arguments issue a diagnostic.  Note: this\n    function is used to enforce the requirements in C++11 8.3.6 about\n@@ -1571,12 +1608,17 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t\t   /* Template functions can be disambiguated by\n \t\t      return type.  */\n \t\t   && same_type_p (TREE_TYPE (TREE_TYPE (newdecl)),\n-\t\t\t\t   TREE_TYPE (TREE_TYPE (olddecl))))\n+\t\t\t\t   TREE_TYPE (TREE_TYPE (olddecl)))\n+                   // Template functions can also be disambiguated by\n+                   // constraints.\n+                   && equivalently_constrained (olddecl, newdecl))\n \t    {\n \t      error (\"ambiguating new declaration %q+#D\", newdecl);\n \t      inform (DECL_SOURCE_LOCATION (olddecl),\n \t\t      \"old declaration %q#D\", olddecl);\n \t    }\n+          else if (check_concept_refinement (olddecl, newdecl))\n+\t    return error_mark_node;\n \t  return NULL_TREE;\n \t}\n       if (TREE_CODE (newdecl) == FUNCTION_DECL)\n@@ -1593,8 +1635,11 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t     are not ambiguous.  */\n \t  else if ((!DECL_FUNCTION_VERSIONED (newdecl)\n \t\t    && !DECL_FUNCTION_VERSIONED (olddecl))\n+                   // The functions have the same parameter types.\n \t\t   && compparms (TYPE_ARG_TYPES (TREE_TYPE (newdecl)),\n-\t\t\t      TYPE_ARG_TYPES (TREE_TYPE (olddecl))))\n+\t\t\t\t TYPE_ARG_TYPES (TREE_TYPE (olddecl)))\n+                   // And the same constraints.\n+                   && equivalently_constrained (newdecl, olddecl))\n \t    {\n \t      error (\"ambiguating new declaration of %q+#D\", newdecl);\n \t      inform (DECL_SOURCE_LOCATION (olddecl),\n@@ -2576,6 +2621,12 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n       if (snode)\n \tsnode->remove ();\n     }\n+\n+  /* Remove the associated constraints for newdecl, if any, before\n+     reclaiming memory. */\n+  if (flag_concepts)\n+    remove_constraints (newdecl);\n+\n   ggc_free (newdecl);\n \n   return olddecl;\n@@ -3981,6 +4032,10 @@ cxx_init_decl_processing (void)\n \n     /* Ensure attribs.c is initialized.  */\n     init_attributes ();\n+\n+    /* Ensure constraint.cc is initialized. */\n+    init_constraint_processing ();\n+\n     extvisattr = build_tree_list (get_identifier (\"externally_visible\"),\n \t\t\t\t  NULL_TREE);\n     newattrs = tree_cons (get_identifier (\"alloc_size\"),\n@@ -6368,6 +6423,16 @@ value_dependent_init_p (tree init)\n   return false;\n }\n \n+// Returns true if a DECL is VAR_DECL with the concept specifier.\n+static inline bool\n+is_concept_var (tree decl)\n+{\n+  return (VAR_P (decl)\n+\t  // Not all variables have DECL_LANG_SPECIFIC.\n+          && DECL_LANG_SPECIFIC (decl)\n+          && DECL_DECLARED_CONCEPT_P (decl));\n+}\n+\n /* Finish processing of a declaration;\n    install its line number and initial value.\n    If the length of an array type is not known before,\n@@ -6446,7 +6511,9 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t\t\t\t\t\t  tf_warning_or_error);\n       d_init = resolve_nondeduced_context (d_init);\n       type = TREE_TYPE (decl) = do_auto_deduction (type, d_init,\n-\t\t\t\t\t\t   auto_node);\n+\t\t\t\t\t\t   auto_node,\n+                                                   tf_warning_or_error,\n+                                                   adc_variable_type);\n       if (type == error_mark_node)\n \treturn;\n       cp_apply_type_quals_to_decl (cp_type_quals (type), decl);\n@@ -6544,6 +6611,8 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t    init = NULL_TREE;\n \t  release_tree_vector (cleanups);\n \t}\n+      else if (!init && is_concept_var (decl))\n+        error (\"variable concept has no initializer\");\n       else if (!DECL_PRETTY_FUNCTION_P (decl))\n \t{\n \t  /* Deduce array size even if the initializer is dependent.  */\n@@ -7606,6 +7675,23 @@ check_static_quals (tree decl, cp_cv_quals quals)\n \t   decl);\n }\n \n+// Check that FN takes no arguments and returns bool.\n+static void\n+check_concept_fn (tree fn)\n+{\n+  // A constraint is nullary.\n+  if (DECL_ARGUMENTS (fn))\n+    error (\"concept %q#D declared with function parameters\", fn);\n+\n+  // The declared return type of the concept shall be bool, and\n+  // it shall not be deduced from it definition.\n+  tree type = TREE_TYPE (TREE_TYPE (fn));\n+  if (is_auto (type))\n+    error (\"concept %q#D declared with a deduced return type\", fn);\n+  else if (type != boolean_type_node)\n+    error (\"concept %q#D with non-%<bool%> return type %qT\", fn, type);\n+}\n+\n /* Helper function.  Replace the temporary this parameter injected\n    during cp_finish_omp_declare_simd with the real this parameter.  */\n \n@@ -7646,6 +7732,7 @@ grokfndecl (tree ctype,\n \t    tree declarator,\n \t    tree parms,\n \t    tree orig_declarator,\n+\t    tree decl_reqs,\n \t    int virtualp,\n \t    enum overload_flags flags,\n \t    cp_cv_quals quals,\n@@ -7667,13 +7754,38 @@ grokfndecl (tree ctype,\n   int staticp = ctype && TREE_CODE (type) == FUNCTION_TYPE;\n   tree t;\n \n+  // Was the concept specifier present?\n+  bool concept_p = inlinep & 4;\n+\n+  // Concept declarations must have a corresponding definition.\n+  if (concept_p && !funcdef_flag)\n+    {\n+      error (\"concept %qD has no definition\", declarator);\n+      return NULL_TREE;\n+    }\n+\n   if (rqual)\n     type = build_ref_qualified_type (type, rqual);\n   if (raises)\n     type = build_exception_variant (type, raises);\n \n   decl = build_lang_decl (FUNCTION_DECL, declarator, type);\n \n+  /* Set the constraints on the declaration. */\n+  if (flag_concepts)\n+    {\n+      tree tmpl_reqs = NULL_TREE;\n+      if (processing_template_decl > template_class_depth (ctype))\n+        tmpl_reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);\n+\n+      /* Adjust the required expression into a constraint. */\n+      if (decl_reqs)\n+        decl_reqs = make_predicate_constraint (decl_reqs);\n+\n+      tree ci = build_constraints (tmpl_reqs, decl_reqs);\n+      set_constraints (decl, ci);\n+    }\n+\n   /* If we have an explicit location, use it, otherwise use whatever\n      build_lang_decl used (probably input_location).  */\n   if (location != UNKNOWN_LOCATION)\n@@ -7848,6 +7960,14 @@ grokfndecl (tree ctype,\n   if (inlinep & 2)\n     DECL_DECLARED_CONSTEXPR_P (decl) = true;\n \n+  // If the concept declaration specifier was found, check\n+  // that the declaration satisfies the necessary requirements.\n+  if (concept_p)\n+    {\n+      DECL_DECLARED_CONCEPT_P (decl) = true;\n+      check_concept_fn (decl);\n+    }\n+\n   DECL_EXTERNAL (decl) = 1;\n   if (TREE_CODE (type) == FUNCTION_TYPE)\n     {\n@@ -7967,7 +8087,8 @@ grokfndecl (tree ctype,\n   decl = check_explicit_specialization (orig_declarator, decl,\n \t\t\t\t\ttemplate_count,\n \t\t\t\t\t2 * funcdef_flag +\n-\t\t\t\t\t4 * (friendp != 0));\n+\t\t\t\t\t4 * (friendp != 0) +\n+                                        8 * concept_p);\n   if (decl == error_mark_node)\n     return NULL_TREE;\n \n@@ -8125,7 +8246,7 @@ grokvardecl (tree type,\n \t     tree orig_declarator,\n \t     const cp_decl_specifier_seq *declspecs,\n \t     int initialized,\n-\t     int constp,\n+\t     int flags,\n \t     int template_count,\n \t     tree scope)\n {\n@@ -8134,6 +8255,9 @@ grokvardecl (tree type,\n \n   gcc_assert (!name || identifier_p (name));\n \n+  bool constp = flags&1;\n+  bool conceptp = flags&2;\n+\n   /* Compute the scope in which to place the variable, but remember\n      whether or not that scope was explicitly specified by the user.   */\n   explicit_scope = scope;\n@@ -8231,10 +8355,33 @@ grokvardecl (tree type,\n   else\n     DECL_INTERFACE_KNOWN (decl) = 1;\n \n+  /* Check that the variable can be safely declared as a concept.\n+     Note that this also forbids explicit specializations.  */\n+  if (conceptp)\n+    {\n+      if (!processing_template_decl)\n+        {\n+          error (\"a non-template variable cannot be %<concept%>\");\n+          return NULL_TREE;\n+        }\n+      else\n+        DECL_DECLARED_CONCEPT_P (decl) = true;\n+      if (!same_type_ignoring_top_level_qualifiers_p (type, boolean_type_node))\n+\terror_at (declspecs->locations[ds_type_spec],\n+\t\t  \"concept must have type %<bool%>\");\n+    }\n+  else if (flag_concepts\n+\t   && processing_template_decl > template_class_depth (scope))\n+    {\n+      tree reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);\n+      tree ci = build_constraints (reqs, NULL_TREE);\n+      set_constraints (decl, ci);\n+    }\n+\n   // Handle explicit specializations and instantiations of variable templates.\n   if (orig_declarator)\n     decl = check_explicit_specialization (orig_declarator, decl,\n-\t\t\t\t\t  template_count, 0);\n+\t\t\t\t\t  template_count, conceptp * 8);\n \n   return decl != error_mark_node ? decl : NULL_TREE;\n }\n@@ -8969,6 +9116,7 @@ grokdeclarator (const cp_declarator *declarator,\n   bool array_parameter_p = false;\n   source_location saved_loc = input_location;\n   const char *errmsg;\n+  tree reqs = NULL_TREE;\n \n   signed_p = decl_spec_seq_has_spec_p (declspecs, ds_signed);\n   unsigned_p = decl_spec_seq_has_spec_p (declspecs, ds_unsigned);\n@@ -8978,6 +9126,12 @@ grokdeclarator (const cp_declarator *declarator,\n   explicit_intN = declspecs->explicit_intN_p;\n   thread_p = decl_spec_seq_has_spec_p (declspecs, ds_thread);\n \n+  // Was concept_p specified? Note that ds_concept\n+  // implies ds_constexpr!\n+  bool concept_p = decl_spec_seq_has_spec_p (declspecs, ds_concept);\n+  if (concept_p)\n+    constexpr_p = true;\n+\n   if (decl_context == FUNCDEF)\n     funcdef_flag = true, decl_context = NORMAL;\n   else if (decl_context == MEMFUNCDEF)\n@@ -9220,6 +9374,12 @@ grokdeclarator (const cp_declarator *declarator,\n   if (name == NULL)\n     name = decl_context == PARM ? \"parameter\" : \"type name\";\n \n+  if (concept_p && typedef_p)\n+    {\n+      error (\"%<concept%> cannot appear in a typedef declaration\");\n+      return error_mark_node;\n+    }\n+\n   if (constexpr_p && typedef_p)\n     {\n       error (\"%<constexpr%> cannot appear in a typedef declaration\");\n@@ -9548,9 +9708,12 @@ grokdeclarator (const cp_declarator *declarator,\n \t       || thread_p)\n \terror (\"storage class specifiers invalid in parameter declarations\");\n \n+      /* Function parameters cannot be concept. */\n+      if (concept_p)\n+          error (\"a parameter cannot be declared %<concept%>\");\n       /* Function parameters cannot be constexpr.  If we saw one, moan\n          and pretend it wasn't there.  */\n-      if (constexpr_p)\n+      else if (constexpr_p)\n         {\n           error (\"a parameter cannot be declared %<constexpr%>\");\n           constexpr_p = 0;\n@@ -9778,6 +9941,10 @@ grokdeclarator (const cp_declarator *declarator,\n \t    if (raises == error_mark_node)\n \t      raises = NULL_TREE;\n \n+\t    if (reqs)\n+\t      error_at (location_of (reqs), \"requires-clause on return type\");\n+\t    reqs = declarator->u.function.requires_clause;\n+\n \t    /* Say it's a definition only for the CALL_EXPR\n \t       closest to the identifier.  */\n \t    funcdecl_p = inner_declarator && inner_declarator->kind == cdk_id;\n@@ -10373,6 +10540,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t  type = error_mark_node;\n \t}\n \n+      if (reqs)\n+\terror_at (location_of (reqs), \"requires-clause on typedef\");\n+\n       if (decl_context == FIELD)\n \tdecl = build_lang_decl (TYPE_DECL, unqualified_id, type);\n       else\n@@ -10566,6 +10736,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t    error (\"invalid qualifiers on non-member function type\");\n \t}\n \n+      if (reqs)\n+\terror_at (location_of (reqs), \"requires-clause on type-id\");\n+\n       return type;\n     }\n   else if (unqualified_id == NULL_TREE && decl_context != PARM\n@@ -10587,6 +10760,13 @@ grokdeclarator (const cp_declarator *declarator,\n       return error_mark_node;\n     }\n \n+  if (reqs\n+      && TREE_CODE (type) != FUNCTION_TYPE\n+      && TREE_CODE (type) != METHOD_TYPE)\n+    error_at (location_of (reqs),\n+\t      \"requires-clause on declaration of non-function type %qT\",\n+\t      type);\n+\n   /* We don't check parameter types here because we can emit a better\n      error message later.  */\n   if (decl_context != PARM)\n@@ -10744,6 +10924,11 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t   uqname, ctype);\n \t\t    return error_mark_node;\n \t\t  }\n+                if (concept_p)\n+                  {\n+                    error (\"a destructor cannot be %<concept%>\");\n+                    return error_mark_node;\n+                  }\n                 if (constexpr_p)\n                   {\n                     error (\"a destructor cannot be %<constexpr%>\");\n@@ -10757,6 +10942,17 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t       id_declarator->u.id.unqualified_name);\n \t\treturn error_mark_node;\n \t      }\n+\t    if (sfk == sfk_constructor)\n+\t      if (concept_p)\n+\t\t{\n+\t\t  error (\"a constructor cannot be %<concept%>\");\n+\t\t  return error_mark_node;\n+\t\t}\n+\t    if (concept_p)\n+\t      {\n+\t\terror (\"a concept cannot be a member function\");\n+\t\tconcept_p = false;\n+\t      }\n \n \t    if (TREE_CODE (unqualified_id) == TEMPLATE_ID_EXPR)\n \t      {\n@@ -10785,9 +10981,10 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t       ? unqualified_id : dname,\n \t\t\t       parms,\n \t\t\t       unqualified_id,\n+\t\t\t       reqs,\n \t\t\t       virtualp, flags, memfn_quals, rqual, raises,\n \t\t\t       friendp ? -1 : 0, friendp, publicp,\n-                               inlinep | (2 * constexpr_p),\n+                               inlinep | (2 * constexpr_p) | (4 * concept_p),\n \t\t\t       initialized == SD_DELETED, sfk,\n \t\t\t       funcdef_flag, template_count, in_namespace,\n \t\t\t       attrlist, declarator->id_loc);\n@@ -10890,8 +11087,10 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t    if (declspecs->gnu_thread_keyword_p)\n \t\t      SET_DECL_GNU_TLS_P (decl);\n \t\t  }\n-\n-\t\tif (constexpr_p && !initialized)\n+\t\tif (concept_p)\n+\t\t    error (\"static data member %qE declared %<concept%>\",\n+\t\t\t   unqualified_id);\n+\t\telse if (constexpr_p && !initialized)\n \t\t  {\n \t\t    error (\"constexpr static data member %qD must have an \"\n \t\t\t   \"initializer\", decl);\n@@ -10900,7 +11099,10 @@ grokdeclarator (const cp_declarator *declarator,\n \t      }\n \t    else\n \t      {\n-                if (constexpr_p)\n+\t\tif (concept_p)\n+\t\t  error (\"non-static data member %qE declared %<concept%>\",\n+\t\t\t unqualified_id);\n+                else if (constexpr_p)\n \t\t  {\n \t\t    error (\"non-static data member %qE declared %<constexpr%>\",\n \t\t\t   unqualified_id);\n@@ -11010,10 +11212,12 @@ grokdeclarator (const cp_declarator *declarator,\n \t  TYPE_HAS_LATE_RETURN_TYPE (type) = 1;\n \n \tdecl = grokfndecl (ctype, type, original_name, parms, unqualified_id,\n-\t\t\t   virtualp, flags, memfn_quals, rqual, raises,\n+                           reqs, virtualp, flags, memfn_quals, rqual, raises,\n \t\t\t   1, friendp,\n-\t\t\t   publicp, inlinep | (2 * constexpr_p),\n-\t\t\t   initialized == SD_DELETED, sfk,\n+\t\t\t   publicp,\n+                           inlinep | (2 * constexpr_p) | (4 * concept_p),\n+\t\t\t   initialized == SD_DELETED,\n+                           sfk,\n                            funcdef_flag,\n \t\t\t   template_count, in_namespace, attrlist,\n \t\t\t   declarator->id_loc);\n@@ -11054,7 +11258,7 @@ grokdeclarator (const cp_declarator *declarator,\n \tdecl = grokvardecl (type, dname, unqualified_id,\n \t\t\t    declspecs,\n \t\t\t    initialized,\n-\t\t\t    (type_quals & TYPE_QUAL_CONST) != 0,\n+\t\t\t    ((type_quals & TYPE_QUAL_CONST) != 0) | (2 * concept_p),\n \t\t\t    template_count,\n \t\t\t    ctype ? ctype : in_namespace);\n \tif (decl == NULL_TREE)\n@@ -11304,7 +11508,7 @@ type_is_deprecated (tree type)\n \n    *PARMS is set to the chain of PARM_DECLs created.  */\n \n-static tree\n+tree\n grokparms (tree parmlist, tree *parms)\n {\n   tree result = NULL_TREE;\n@@ -12399,8 +12603,16 @@ xref_tag_1 (enum tag_types tag_code, tree name,\n     {\n       if (template_header_p && MAYBE_CLASS_TYPE_P (t))\n         {\n-\t  if (!redeclare_class_template (t, current_template_parms))\n-            return error_mark_node;\n+          /* Check that we aren't trying to overload a class with different\n+             constraints.  */\n+          tree constr = NULL_TREE;\n+          if (current_template_parms)\n+            {\n+              tree reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);\n+              constr = build_constraints (reqs, NULL_TREE);\n+            }\n+\t  if (!redeclare_class_template (t, current_template_parms, constr))\n+\t    return error_mark_node;\n         }\n       else if (!processing_template_decl\n \t       && CLASS_TYPE_P (t)\n@@ -14252,6 +14464,10 @@ finish_function (int flags)\n       fntype = TREE_TYPE (fndecl);\n     }\n \n+  // If this is a concept, check that the definition is reasonable.\n+  if (DECL_DECLARED_CONCEPT_P (fndecl))\n+    check_function_concept (fndecl);\n+\n   /* Save constexpr function body before it gets munged by\n      the NRV transformation.   */\n   maybe_save_function_definition (fndecl);\n@@ -14742,6 +14958,7 @@ cp_tree_node_structure (union lang_tree_node * t)\n     case TRAIT_EXPR:\t\treturn TS_CP_TRAIT_EXPR;\n     case LAMBDA_EXPR:\t\treturn TS_CP_LAMBDA_EXPR;\n     case TEMPLATE_INFO:\t\treturn TS_CP_TEMPLATE_INFO;\n+    case CONSTRAINT_INFO:       return TS_CP_CONSTRAINT_INFO;\n     case USERDEF_LITERAL:\treturn TS_CP_USERDEF_LITERAL;\n     default:\t\t\treturn TS_CP_GENERIC;\n     }"}, {"sha": "068d79cd10c16033d3170bb176f97f728a3c4f84", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -714,6 +714,10 @@ check_classfn (tree ctype, tree function, tree template_parms)\n \t      != type_memfn_rqual (TREE_TYPE (fndecl)))\n \t    continue;\n \n+\t  // Include constraints in the match.\n+\t  tree c1 = get_constraints (function);\n+\t  tree c2 = get_constraints (fndecl);\n+\n \t  /* While finding a match, same types and params are not enough\n \t     if the function is versioned.  Also check version (\"target\")\n \t     attributes.  */\n@@ -724,6 +728,7 @@ check_classfn (tree ctype, tree function, tree template_parms)\n \t      && (!is_template\n \t\t  || comp_template_parms (template_parms,\n \t\t\t\t\t  DECL_TEMPLATE_PARMS (fndecl)))\n+\t      && equivalent_constraints (c1, c2)\n \t      && (DECL_TEMPLATE_SPECIALIZATION (function)\n \t\t  == DECL_TEMPLATE_SPECIALIZATION (fndecl))\n \t      && (!DECL_TEMPLATE_SPECIALIZATION (function)\n@@ -5081,6 +5086,7 @@ mark_used (tree decl, tsubst_flags_t complain)\n \t  || (TREE_CODE (decl) == FUNCTION_DECL\n \t      && DECL_OMP_DECLARE_REDUCTION_P (decl))\n \t  || undeduced_auto_decl (decl))\n+      && !DECL_DECLARED_CONCEPT_P (decl)\n       && !uses_template_parms (DECL_TI_ARGS (decl)))\n     {\n       /* Instantiating a function will result in garbage collection.  We\n@@ -5179,6 +5185,7 @@ mark_used (tree decl, tsubst_flags_t complain)\n     }\n   else if (VAR_OR_FUNCTION_DECL_P (decl)\n \t   && DECL_TEMPLATE_INFO (decl)\n+           && !DECL_DECLARED_CONCEPT_P (decl)\n \t   && (!DECL_EXPLICIT_INSTANTIATION (decl)\n \t       || always_instantiate_p (decl)))\n     /* If this is a function or variable that is an instance of some"}, {"sha": "4f85751711a15c3136970d83c99ab8e01e9c2dfc", "filename": "gcc/cp/error.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -1333,6 +1333,15 @@ dump_template_decl (cxx_pretty_printer *pp, tree t, int flags)\n \t}\n     }\n \n+  if (flag_concepts)\n+    if (tree ci = get_constraints (t))\n+      if (check_constraint_info (ci))\n+        if (tree reqs = CI_TEMPLATE_REQS (ci))\n+\t  {\n+\t    pp_cxx_requires_clause (pp, reqs);\n+\t    pp_cxx_whitespace (pp);\n+\t  }\n+\n   if (DECL_CLASS_TEMPLATE_P (t))\n     dump_type (pp, TREE_TYPE (t),\n \t       ((flags & ~TFF_CLASS_KEY_OR_ENUM) | TFF_TEMPLATE_NAME\n@@ -1564,6 +1573,11 @@ dump_function_decl (cxx_pretty_printer *pp, tree t, int flags)\n       if (show_return)\n \tdump_type_suffix (pp, TREE_TYPE (fntype), flags);\n \n+      if (flag_concepts)\n+        if (tree ci = get_constraints (t))\n+          if (tree reqs = CI_DECLARATOR_REQS (ci))\n+            pp_cxx_requires_clause (pp, reqs);\n+\n       dump_substitution (pp, t, template_parms, template_args, flags);\n     }\n   else if (template_args)\n@@ -2689,6 +2703,38 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n       pp_cxx_right_paren (pp);\n       break;\n \n+    case REQUIRES_EXPR:\n+      pp_cxx_requires_expr (cxx_pp, t);\n+      break;\n+\n+    case SIMPLE_REQ:\n+      pp_cxx_simple_requirement (cxx_pp, t);\n+      break;\n+\n+    case TYPE_REQ:\n+      pp_cxx_type_requirement (cxx_pp, t);\n+      break;\n+\n+    case COMPOUND_REQ:\n+      pp_cxx_compound_requirement (cxx_pp, t);\n+      break;\n+\n+    case NESTED_REQ:\n+      pp_cxx_nested_requirement (cxx_pp, t);\n+      break;\n+\n+    case PRED_CONSTR:\n+    case EXPR_CONSTR:\n+    case TYPE_CONSTR:\n+    case ICONV_CONSTR:\n+    case DEDUCT_CONSTR:\n+    case EXCEPT_CONSTR:\n+    case PARM_CONSTR:\n+    case CONJ_CONSTR:\n+    case DISJ_CONSTR:\n+      pp_cxx_constraint (cxx_pp, t);\n+      break;\n+\n     case PLACEHOLDER_EXPR:\n       pp_string (pp, M_(\"*this\"));\n       break;"}, {"sha": "f81c17b4a51f577f220b1451bf0fae2004baa24b", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -174,6 +174,8 @@ init_reswords (void)\n \n   if (cxx_dialect < cxx11)\n     mask |= D_CXX11;\n+  if (!flag_concepts)\n+    mask |= D_CXX_CONCEPTS;\n   if (flag_no_asm)\n     mask |= D_ASM | D_EXT;\n   if (flag_no_gnu_keywords)"}, {"sha": "7e016409c30bf9c7f30e4cc9c73d0fef80cac97f", "filename": "gcc/cp/logic.cc", "status": "added", "additions": 497, "deletions": 0, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Flogic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Flogic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flogic.cc?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,497 @@\n+/* Derivation and subsumption rules for constraints.\n+   Copyright (C) 2013-2015 Free Software Foundation, Inc.\n+   Contributed by Andrew Sutton (andrew.n.sutton@gmail.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"hash-set.h\"\n+#include \"machmode.h\"\n+#include \"vec.h\"\n+#include \"double-int.h\"\n+#include \"input.h\"\n+#include \"alias.h\"\n+#include \"symtab.h\"\n+#include \"wide-int.h\"\n+#include \"inchash.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n+#include \"intl.h\"\n+#include \"flags.h\"\n+#include \"cp-tree.h\"\n+#include \"c-family/c-common.h\"\n+#include \"c-family/c-objc.h\"\n+#include \"cp-objcp-common.h\"\n+#include \"tree-inline.h\"\n+#include \"decl.h\"\n+#include \"toplev.h\"\n+#include \"type-utils.h\"\n+\n+#include <list>\n+\n+namespace {\n+\n+// Helper algorithms\n+\n+// Increment iter distance(first, last) times.\n+template<typename I1, typename I2, typename I3>\n+  I1 next_by_distance (I1 iter, I2 first, I3 last)\n+  {\n+    for ( ; first != last; ++first, ++iter)\n+      ;\n+    return iter;\n+  }\n+\n+/*---------------------------------------------------------------------------\n+                           Proof state\n+---------------------------------------------------------------------------*/\n+\n+/* A term list is a list of atomic constraints. It is used\n+   to maintain the lists of assumptions and conclusions in a\n+   proof goal.\n+\n+   Each term list maintains an iterator that refers to the current\n+   term. This can be used by various tactics to support iteration\n+   and stateful manipulation of the list. */\n+struct term_list : std::list<tree>\n+{\n+  term_list ();\n+  term_list (const term_list &x);\n+  term_list& operator= (const term_list &x);\n+\n+  tree       current_term ()       { return *current; }\n+  const_tree current_term () const { return *current; }\n+\n+\n+  void insert (tree t);\n+  tree erase ();\n+\n+  void start ();\n+  void next ();\n+  bool done() const;\n+\n+  iterator current;\n+};\n+\n+inline\n+term_list::term_list ()\n+  : std::list<tree> (), current (end ())\n+{ }\n+\n+inline\n+term_list::term_list (const term_list &x)\n+  : std::list<tree> (x)\n+  , current (next_by_distance (begin (), x.begin (), x.current))\n+{ }\n+\n+inline term_list&\n+term_list::operator= (const term_list &x)\n+{\n+  std::list<tree>::operator=(x);\n+  current = next_by_distance (begin (), x.begin (), x.current);\n+  return *this;\n+}\n+\n+/* Try saving the term T into the list of terms. If\n+   T is already in the list of terms, then no action is\n+   performed. Otherwise, insert T before the current\n+   position, making this term current.\n+\n+   Note that not inserting terms is an optimization\n+   that corresponds to the structural rule of\n+   contraction.\n+\n+   NOTE: With the contraction rule, this data structure\n+   would be more efficiently represented as an ordered set\n+   or hash set.  */\n+void\n+term_list::insert (tree t)\n+{\n+  /* Search the current term list. If there is already\n+     a matching term, do not add the new one.  */\n+  for (iterator i = begin(); i != end(); ++i)\n+    if (cp_tree_equal (*i, t))\n+      return;\n+\n+  current = std::list<tree>::insert (current, t);\n+}\n+\n+/* Remove the current term from the list, repositioning to\n+   the term following the removed term. Note that the new\n+   position could be past the end of the list.\n+\n+   The removed term is returned. */\n+inline tree\n+term_list::erase ()\n+{\n+  tree t = *current;\n+  current = std::list<tree>::erase (current);\n+  return t;\n+}\n+\n+/* Initialize the current term to the first in the list. */\n+inline void\n+term_list::start ()\n+{\n+  current = begin ();\n+}\n+\n+/* Advance to the next term in the list. */\n+inline void\n+term_list::next ()\n+{\n+  ++current;\n+}\n+\n+/* Returns true when the current position is past the end. */\n+inline bool\n+term_list::done () const\n+{\n+  return current == end ();\n+}\n+\n+\n+/* A goal (or subgoal) models a sequent of the form\n+   'A |- C' where A and C are lists of assumptions and\n+   conclusions written as propositions in the constraint\n+   language (i.e., lists of trees).\n+*/\n+struct proof_goal\n+{\n+  term_list assumptions;\n+  term_list conclusions;\n+};\n+\n+/* A proof state owns a list of goals and tracks the\n+   current sub-goal. The class also provides facilities\n+   for managing subgoals and constructing term lists. */\n+struct proof_state : std::list<proof_goal>\n+{\n+  proof_state ();\n+\n+  iterator branch (iterator i);\n+};\n+\n+/* An alias for proof state iterators. */\n+typedef proof_state::iterator goal_iterator;\n+\n+/* Initialize the state with a single empty goal,\n+   and set that goal as the current subgoal. */\n+inline\n+proof_state::proof_state ()\n+  : std::list<proof_goal> (1)\n+{ }\n+\n+\n+/* Branch the current goal by creating a new subgoal,\n+   returning a reference to // the new object. This does\n+   not update the current goal. */\n+inline proof_state::iterator\n+proof_state::branch (iterator i)\n+{\n+  gcc_assert (i != end());\n+  proof_goal& g = *i;\n+  return insert (++i, g);\n+}\n+\n+/*---------------------------------------------------------------------------\n+                           Logical rules\n+---------------------------------------------------------------------------*/\n+\n+/*These functions modify the current state and goal by decomposing\n+  logical expressions using the logical rules of sequent calculus for\n+  first order logic.\n+\n+  Note that in each decomposition rule, the term T has been erased\n+  from term list before the specific rule is applied. */\n+\n+/* The left logical rule for conjunction adds both operands\n+   to the current set of constraints. */\n+void\n+left_conjunction (proof_state &, goal_iterator i, tree t)\n+{\n+  gcc_assert (TREE_CODE (t) == CONJ_CONSTR);\n+\n+  /* Insert the operands into the current branch. Note that the\n+     final order of insertion is left-to-right. */\n+  term_list &l = i->assumptions;\n+  l.insert (TREE_OPERAND (t, 1));\n+  l.insert (TREE_OPERAND (t, 0));\n+}\n+\n+/* The left logical rule for disjunction creates a new goal,\n+   adding the first operand to the original set of\n+   constraints and the second operand to the new set\n+   of constraints. */\n+void\n+left_disjunction (proof_state &s, goal_iterator i, tree t)\n+{\n+  gcc_assert (TREE_CODE (t) == DISJ_CONSTR);\n+\n+  /* Branch the current subgoal. */\n+  goal_iterator j = s.branch (i);\n+  term_list &l1 = i->assumptions;\n+  term_list &l2 = j->assumptions;\n+\n+  /* Insert operands into the different branches. */\n+  l1.insert (TREE_OPERAND (t, 0));\n+  l2.insert (TREE_OPERAND (t, 1));\n+}\n+\n+/* The left logical rules for parameterized constraints\n+   adds its operand to the current goal. The list of\n+   parameters are effectively discarded. */\n+void\n+left_parameterized_constraint (proof_state &, goal_iterator i, tree t)\n+{\n+  gcc_assert (TREE_CODE (t) == PARM_CONSTR);\n+  term_list &l = i->assumptions;\n+  l.insert (PARM_CONSTR_OPERAND (t));\n+}\n+\n+/*---------------------------------------------------------------------------\n+                           Decomposition\n+---------------------------------------------------------------------------*/\n+\n+/* The following algorithms decompose expressions into sets of\n+   atomic propositions. In terms of the sequent calculus, these\n+   functions exercise the logical rules only.\n+\n+   This is equivalent, for the purpose of determining subsumption,\n+   to rewriting a constraint in disjunctive normal form. It also\n+   allows the resulting assumptions to be used as declarations\n+   for the purpose of separate checking. */\n+\n+/* Apply the left logical rules to the proof state. */\n+void\n+decompose_left_term (proof_state &s, goal_iterator i)\n+{\n+  term_list &l = i->assumptions;\n+  tree t = l.current_term ();\n+  switch (TREE_CODE (t))\n+    {\n+    case CONJ_CONSTR:\n+      left_conjunction (s, i, l.erase ());\n+      break;\n+    case DISJ_CONSTR:\n+      left_disjunction (s, i, l.erase ());\n+      break;\n+    case PARM_CONSTR:\n+      left_parameterized_constraint (s, i, l.erase ());\n+      break;\n+    default:\n+      l.next ();\n+      break;\n+    }\n+}\n+\n+/* Apply the left logical rules of the sequent calculus\n+   until the current goal is fully decomposed into atomic\n+   constraints. */\n+void\n+decompose_left_goal (proof_state &s, goal_iterator i)\n+{\n+  term_list& l = i->assumptions;\n+  l.start ();\n+  while (!l.done ())\n+    decompose_left_term (s, i);\n+}\n+\n+/* Apply the left logical rules of the sequent calculus\n+   until the antecedents are fully decomposed into atomic\n+   constraints. */\n+void\n+decompose_left (proof_state& s)\n+{\n+  goal_iterator iter = s.begin ();\n+  goal_iterator end = s.end ();\n+  for ( ; iter != end; ++iter)\n+    decompose_left_goal (s, iter);\n+}\n+\n+/* Returns a vector of terms from the term list L. */\n+tree\n+extract_terms (term_list& l)\n+{\n+  tree result = make_tree_vec (l.size());\n+  term_list::iterator iter = l.begin();\n+  term_list::iterator end = l.end();\n+  for (int n = 0; iter != end; ++iter, ++n)\n+    TREE_VEC_ELT (result, n) = *iter;\n+  return result;\n+}\n+\n+/* Extract the assumptions from the proof state S\n+   as a vector of vectors of atomic constraints. */\n+inline tree\n+extract_assumptions (proof_state& s)\n+{\n+  tree result = make_tree_vec (s.size ());\n+  goal_iterator iter = s.begin ();\n+  goal_iterator end = s.end ();\n+  for (int n = 0; iter != end; ++iter, ++n)\n+    TREE_VEC_ELT (result, n) = extract_terms (iter->assumptions);\n+  return result;\n+}\n+\n+} // namespace\n+\n+/* Decompose the required expression T into a constraint set: a\n+   vector of vectors containing only atomic propositions. If T is\n+   invalid, return an error. */\n+tree\n+decompose_assumptions (tree t)\n+{\n+  if (!t || t == error_mark_node)\n+    return t;\n+\n+  /* Create a proof state, and insert T as the sole assumption. */\n+  proof_state s;\n+  term_list &l = s.begin ()->assumptions;\n+  l.insert (t);\n+\n+  /* Decompose the expression into a constraint set, and then\n+     extract the terms for the AST. */\n+  decompose_left (s);\n+  return extract_assumptions (s);\n+}\n+\n+\n+/*---------------------------------------------------------------------------\n+                           Subsumption Rules\n+---------------------------------------------------------------------------*/\n+\n+namespace {\n+\n+bool subsumes_constraint (tree, tree);\n+bool subsumes_conjunction (tree, tree);\n+bool subsumes_disjunction (tree, tree);\n+bool subsumes_parameterized_constraint (tree, tree);\n+bool subsumes_atomic_constraint (tree, tree);\n+\n+/* Returns true if the assumption A matches the conclusion C. This\n+   is generally the case when A and C have the same syntax.\n+\n+   NOTE: There will be specialized matching rules to accommodate\n+   type equivalence, conversion, inheritance, etc. But this is not\n+   in the current concepts draft. */\n+inline bool\n+match_terms (tree a, tree c)\n+{\n+  return cp_tree_equal (a, c);\n+}\n+\n+/* Returns true if the list of assumptions AS subsumes the atomic\n+   proposition C. This is the case when we can find a proposition\n+  in AS that entails the conclusion C. */\n+bool\n+subsumes_atomic_constraint (tree as, tree c)\n+{\n+  for (int i = 0; i < TREE_VEC_LENGTH (as); ++i)\n+    if (match_terms (TREE_VEC_ELT (as, i), c))\n+      return true;\n+  return false;\n+}\n+\n+/* Returns true when both operands of C are subsumed by the\n+   assumptions AS. */\n+inline bool\n+subsumes_conjunction (tree as, tree c)\n+{\n+  tree l = TREE_OPERAND (c, 0);\n+  tree r = TREE_OPERAND (c, 1);\n+  return subsumes_constraint (as, l) && subsumes_constraint (as, r);\n+}\n+\n+/* Returns true when either operand of C is subsumed by the\n+   assumptions AS. */\n+inline bool\n+subsumes_disjunction (tree as, tree c)\n+{\n+  tree l = TREE_OPERAND (c, 0);\n+  tree r = TREE_OPERAND (c, 1);\n+  return subsumes_constraint (as, l) || subsumes_constraint (as, r);\n+}\n+\n+/* Returns true when the operand of C is subsumed by the\n+   assumptions in AS. The parameters are not considered in\n+   the subsumption rules. */\n+bool\n+subsumes_parameterized_constraint (tree as, tree c)\n+{\n+  tree t = PARM_CONSTR_OPERAND (c);\n+  return subsumes_constraint (as, t);\n+}\n+\n+\n+/* Returns true when the list of assumptions AS subsumes the\n+   concluded proposition C. This is a simple recursive descent\n+   on C, matching against propositions in the assumption list AS. */\n+bool\n+subsumes_constraint (tree as, tree c)\n+{\n+  switch (TREE_CODE (c))\n+    {\n+    case CONJ_CONSTR:\n+      return subsumes_conjunction (as, c);\n+    case DISJ_CONSTR:\n+      return subsumes_disjunction (as, c);\n+    case PARM_CONSTR:\n+      return subsumes_parameterized_constraint (as, c);\n+    default:\n+      return subsumes_atomic_constraint (as, c);\n+    }\n+}\n+\n+/* Returns true if the LEFT constraints subsume the RIGHT constraints.\n+   This is done by checking that the RIGHT requirements follow from\n+   each of the LEFT subgoals. */\n+bool\n+subsumes_constraints_nonnull (tree left, tree right)\n+{\n+  gcc_assert (check_constraint_info (left));\n+  gcc_assert (check_constraint_info (right));\n+\n+  /* Check that the required expression in RIGHT is subsumed by each\n+     subgoal in the assumptions of LEFT. */\n+  tree as = CI_ASSUMPTIONS (left);\n+  tree c = CI_NORMALIZED_CONSTRAINTS (right);\n+  for (int i = 0; i < TREE_VEC_LENGTH (as); ++i)\n+    if (!subsumes_constraint (TREE_VEC_ELT (as, i), c))\n+      return false;\n+  return true;\n+}\n+\n+} /* namespace */\n+\n+/* Returns true if the LEFT constraints subsume the RIGHT\n+   constraints. */\n+bool\n+subsumes (tree left, tree right)\n+{\n+  if (left == right)\n+    return true;\n+  if (!left)\n+    return false;\n+  if (!right)\n+    return true;\n+  return subsumes_constraints_nonnull (left, right);\n+}"}, {"sha": "fdc76043e936360c2e515e80147a7b295e695add", "filename": "gcc/cp/method.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -1924,6 +1924,14 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n   rest_of_decl_compilation (fn, toplevel_bindings_p (), at_eof);\n   gcc_assert (!TREE_USED (fn));\n \n+  /* Propagate constraints from the inherited constructor. */\n+  if (flag_concepts && inherited_ctor)\n+    if (tree orig_ci = get_constraints (inherited_ctor))\n+      {\n+        tree new_ci = copy_node (orig_ci);\n+        set_constraints (fn, new_ci);\n+      }\n+\n   /* Restore PROCESSING_TEMPLATE_DECL.  */\n   processing_template_decl = saved_processing_template_decl;\n "}, {"sha": "a0b249bbf5b71fae98a8366564d2c4de41ea61cc", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1151, "deletions": 109, "changes": 1260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -1343,7 +1343,7 @@ clear_decl_specs (cp_decl_specifier_seq *decl_specs)\n    VAR_DECLs or FUNCTION_DECLs) should do that directly.  */\n \n static cp_declarator *make_call_declarator\n-  (cp_declarator *, tree, cp_cv_quals, cp_virt_specifiers, cp_ref_qualifier, tree, tree);\n+  (cp_declarator *, tree, cp_cv_quals, cp_virt_specifiers, cp_ref_qualifier, tree, tree, tree);\n static cp_declarator *make_array_declarator\n   (cp_declarator *, tree);\n static cp_declarator *make_pointer_declarator\n@@ -1522,7 +1522,8 @@ make_call_declarator (cp_declarator *target,\n \t\t      cp_virt_specifiers virt_specifiers,\n \t\t      cp_ref_qualifier ref_qualifier,\n \t\t      tree exception_specification,\n-\t\t      tree late_return_type)\n+\t\t      tree late_return_type,\n+\t\t      tree requires_clause)\n {\n   cp_declarator *declarator;\n \n@@ -1534,6 +1535,7 @@ make_call_declarator (cp_declarator *target,\n   declarator->u.function.ref_qualifier = ref_qualifier;\n   declarator->u.function.exception_specification = exception_specification;\n   declarator->u.function.late_return_type = late_return_type;\n+  declarator->u.function.requires_clause = requires_clause;\n   if (target)\n     {\n       declarator->id_loc = target->id_loc;\n@@ -2081,6 +2083,8 @@ static tree cp_parser_type_specifier\n    int *, bool *);\n static tree cp_parser_simple_type_specifier\n   (cp_parser *, cp_decl_specifier_seq *, cp_parser_flags);\n+static tree cp_parser_type_name\n+  (cp_parser *, bool);\n static tree cp_parser_type_name\n   (cp_parser *);\n static tree cp_parser_nonclass_name \n@@ -2136,7 +2140,7 @@ static cp_virt_specifiers cp_parser_virt_specifier_seq_opt\n static cp_ref_qualifier cp_parser_ref_qualifier_opt\n   (cp_parser *);\n static tree cp_parser_late_return_type_opt\n-  (cp_parser *, cp_declarator *, cp_cv_quals);\n+  (cp_parser *, cp_declarator *, tree &, cp_cv_quals);\n static tree cp_parser_declarator_id\n   (cp_parser *, bool);\n static tree cp_parser_type_id\n@@ -2177,7 +2181,7 @@ static tree cp_parser_late_parsing_cilk_simd_fn_info\n   (cp_parser *, tree);\n \n static tree synthesize_implicit_template_parm\n-  (cp_parser *);\n+  (cp_parser *, tree);\n static tree finish_fully_implicit_template\n   (cp_parser *, tree);\n \n@@ -2314,6 +2318,31 @@ static bool cp_parser_extension_opt\n static void cp_parser_label_declaration\n   (cp_parser *);\n \n+/* Concept Extensions */\n+\n+static tree cp_parser_requires_clause\n+  (cp_parser *);\n+static tree cp_parser_requires_clause_opt\n+  (cp_parser *);\n+static tree cp_parser_requires_expression\n+  (cp_parser *);\n+static tree cp_parser_requirement_parameter_list\n+  (cp_parser *);\n+static tree cp_parser_requirement_body\n+  (cp_parser *);\n+static tree cp_parser_requirement_list\n+  (cp_parser *);\n+static tree cp_parser_requirement\n+  (cp_parser *);\n+static tree cp_parser_simple_requirement\n+  (cp_parser *);\n+static tree cp_parser_compound_requirement\n+  (cp_parser *);\n+static tree cp_parser_type_requirement\n+  (cp_parser *);\n+static tree cp_parser_nested_requirement\n+  (cp_parser *);\n+\n /* Transactional Memory Extensions */\n \n static tree cp_parser_transaction\n@@ -2396,7 +2425,7 @@ static tree cp_parser_function_definition_from_specifiers_and_declarator\n   (cp_parser *, cp_decl_specifier_seq *, tree, const cp_declarator *);\n static tree cp_parser_function_definition_after_declarator\n   (cp_parser *, bool);\n-static void cp_parser_template_declaration_after_export\n+static bool cp_parser_template_declaration_after_export\n   (cp_parser *, bool);\n static void cp_parser_perform_template_parameter_access_checks\n   (vec<deferred_access_check, va_gc> *);\n@@ -2532,6 +2561,30 @@ static bool cp_parser_array_designator_p\n static bool cp_parser_skip_to_closing_square_bracket\n   (cp_parser *);\n \n+/* Concept-related syntactic transformations */\n+\n+static tree cp_parser_maybe_concept_name       (cp_parser *, tree);\n+static tree cp_parser_maybe_partial_concept_id (cp_parser *, tree, tree);\n+\n+// -------------------------------------------------------------------------- //\n+// Unevaluated Operand Guard\n+//\n+// Implementation of an RAII helper for unevaluated operand parsing.\n+cp_unevaluated::cp_unevaluated ()\n+{\n+  ++cp_unevaluated_operand;\n+  ++c_inhibit_evaluation_warnings;\n+}\n+\n+cp_unevaluated::~cp_unevaluated ()\n+{\n+  --c_inhibit_evaluation_warnings;\n+  --cp_unevaluated_operand;\n+}\n+\n+// -------------------------------------------------------------------------- //\n+// Tentative Parsing\n+\n /* Returns nonzero if we are parsing tentatively.  */\n \n static inline bool\n@@ -3552,6 +3605,9 @@ cp_parser_new (void)\n   parser->implicit_template_parms = 0;\n   parser->implicit_template_scope = 0;\n \n+  /* Allow constrained-type-specifiers. */\n+  parser->prevent_constrained_type_specifiers = 0;\n+\n   return parser;\n }\n \n@@ -4591,6 +4647,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \tcase RID_IS_LITERAL_TYPE:\n \tcase RID_IS_POD:\n \tcase RID_IS_POLYMORPHIC:\n+\tcase RID_IS_SAME_AS:\n \tcase RID_IS_STD_LAYOUT:\n \tcase RID_IS_TRIVIAL:\n \tcase RID_IS_TRIVIALLY_ASSIGNABLE:\n@@ -4599,6 +4656,10 @@ cp_parser_primary_expression (cp_parser *parser,\n \tcase RID_IS_UNION:\n \t  return cp_parser_trait_expr (parser, token->keyword);\n \n+\t// C++ concepts\n+\tcase RID_REQUIRES:\n+\t  return cp_parser_requires_expression (parser);\n+\n \t/* Objective-C++ expressions.  */\n \tcase RID_AT_ENCODE:\n \tcase RID_AT_PROTOCOL:\n@@ -5956,9 +6017,11 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \ttree type;\n \t/* The syntax permitted here is the same permitted for an\n \t   elaborated-type-specifier.  */\n+        ++parser->prevent_constrained_type_specifiers;\n \ttype = cp_parser_elaborated_type_specifier (parser,\n \t\t\t\t\t\t    /*is_friend=*/false,\n \t\t\t\t\t\t    /*is_declaration=*/false);\n+        --parser->prevent_constrained_type_specifiers;\n \tpostfix_expression = cp_parser_functional_cast (parser, type);\n       }\n       break;\n@@ -6056,9 +6119,11 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t   that doesn't work we fall back to the primary-expression.  */\n \tcp_parser_parse_tentatively (parser);\n \t/* Look for the simple-type-specifier.  */\n+        ++parser->prevent_constrained_type_specifiers;\n \ttype = cp_parser_simple_type_specifier (parser,\n \t\t\t\t\t\t/*decl_specs=*/NULL,\n \t\t\t\t\t\tCP_PARSER_FLAGS_NONE);\n+        --parser->prevent_constrained_type_specifiers;\n \t/* Parse the cast itself.  */\n \tif (!cp_parser_error_occurred (parser))\n \t  postfix_expression\n@@ -8843,6 +8908,10 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n     case RID_IS_POLYMORPHIC:\n       kind = CPTK_IS_POLYMORPHIC;\n       break;\n+    case RID_IS_SAME_AS:\n+      kind = CPTK_IS_SAME_AS;\n+      binary = true;\n+      break;\n     case RID_IS_STD_LAYOUT:\n       kind = CPTK_IS_STD_LAYOUT;\n       break;\n@@ -9440,7 +9509,8 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n \t\t\t\t       VIRT_SPEC_UNSPECIFIED,\n                                        REF_QUAL_NONE,\n \t\t\t\t       exception_spec,\n-                                       /*late_return_type=*/NULL_TREE);\n+                                       /*late_return_type=*/NULL_TREE,\n+                                       /*requires_clause*/NULL_TREE);\n     declarator->id_loc = LAMBDA_EXPR_LOCATION (lambda_expr);\n \n     fco = grokmethod (&return_type_specs,\n@@ -11371,8 +11441,12 @@ cp_parser_declaration (cp_parser* parser)\n \t   && token1.keyword == RID_ATTRIBUTE\n \t   && cp_parser_objc_valid_prefix_attributes (parser, &attributes))\n     cp_parser_objc_declaration (parser, attributes);\n-  /* We must have either a block declaration or a function\n-     definition.  */\n+  /* At this point we may have a template declared by a concept\n+     introduction.  */\n+  else if (flag_concepts\n+\t   && cp_parser_template_declaration_after_export (parser,\n+\t\t\t\t\t\t\t   /*member_p=*/false))\n+    /* We did.  */;\n   else\n     /* Try to parse a block-declaration, or a function-definition.  */\n     cp_parser_block_declaration (parser, /*statement_p=*/false);\n@@ -11723,6 +11797,11 @@ cp_parser_simple_declaration (cp_parser* parser,\n    decl-specifier:\n      attributes\n \n+   Concepts Extension:\n+\n+   decl-specifier:\n+     concept\n+\n    Set *DECL_SPECS to a representation of the decl-specifier-seq.\n \n    The parser flags FLAGS is used to control type-specifier parsing.\n@@ -11850,6 +11929,11 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n           cp_lexer_consume_token (parser->lexer);\n           break;\n \n+        case RID_CONCEPT:\n+          ds = ds_concept;\n+          cp_lexer_consume_token (parser->lexer);\n+          break;\n+\n \t  /* function-specifier:\n \t       inline\n \t       virtual\n@@ -13256,7 +13340,15 @@ cp_parser_operator (cp_parser* parser)\n \n    template-parameter-list-seq:\n      template-parameter-list-seq [opt]\n-     template < template-parameter-list >  */\n+     template < template-parameter-list >\n+\n+   Concept Extensions:\n+\n+   template-parameter-list-seq:\n+     template < template-parameter-list > requires-clause [opt]\n+\n+   requires-clause:\n+     requires logical-or-expression  */\n \n static void\n cp_parser_template_declaration (cp_parser* parser, bool member_p)\n@@ -13330,6 +13422,244 @@ cp_parser_template_parameter_list (cp_parser* parser)\n   return end_template_parm_list (parameter_list);\n }\n \n+/* Parse a introduction-list.\n+\n+   introduction-list:\n+     introduced-parameter\n+     introduction-list , introduced-parameter\n+\n+   introduced-parameter:\n+     ...[opt] identifier\n+\n+   Returns a TREE_VEC of WILDCARD_DECLs.  If the parameter is a pack\n+   then the introduced parm will have WILDCARD_PACK_P set.  In addition, the\n+   WILDCARD_DECL will also have DECL_NAME set and token location in\n+   DECL_SOURCE_LOCATION.  */\n+\n+static tree\n+cp_parser_introduction_list (cp_parser *parser)\n+{\n+  vec<tree, va_gc> *introduction_vec = make_tree_vector ();\n+\n+  while (true)\n+    {\n+      bool is_pack = cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS);\n+      if (is_pack)\n+\tcp_lexer_consume_token (parser->lexer);\n+\n+      /* Build placeholder. */\n+      tree parm = build_nt (WILDCARD_DECL);\n+      DECL_SOURCE_LOCATION (parm)\n+\t= cp_lexer_peek_token (parser->lexer)->location;\n+      DECL_NAME (parm) = cp_parser_identifier (parser);\n+      WILDCARD_PACK_P (parm) = is_pack;\n+      vec_safe_push (introduction_vec, parm);\n+\n+      /* If the next token is not a `,', we're done.  */\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA))\n+\tbreak;\n+      /* Otherwise, consume the `,' token.  */\n+      cp_lexer_consume_token (parser->lexer);\n+    }\n+\n+  /* Convert the vec into a TREE_VEC.  */\n+  tree introduction_list = make_tree_vec (introduction_vec->length ());\n+  unsigned int n;\n+  tree parm;\n+  FOR_EACH_VEC_ELT (*introduction_vec, n, parm)\n+    TREE_VEC_ELT (introduction_list, n) = parm;\n+\n+  release_tree_vector (introduction_vec);\n+  return introduction_list;\n+}\n+\n+/* Given a declarator, get the declarator-id part, or NULL_TREE if this\n+   is an abstract declarator. */\n+\n+static inline cp_declarator*\n+get_id_declarator (cp_declarator *declarator)\n+{\n+  cp_declarator *d = declarator;\n+  while (d && d->kind != cdk_id)\n+    d = d->declarator;\n+  return d;\n+}\n+\n+/* Get the unqualified-id from the DECLARATOR or NULL_TREE if this\n+   is an abstract declarator. */\n+\n+static inline tree\n+get_unqualified_id (cp_declarator *declarator)\n+{\n+  declarator = get_id_declarator (declarator);\n+  if (declarator)\n+    return declarator->u.id.unqualified_name;\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* Returns true if DECL represents a constrained-parameter.  */\n+\n+static inline bool\n+is_constrained_parameter (tree decl)\n+{\n+  return (decl\n+          && TREE_CODE (decl) == TYPE_DECL\n+          && CONSTRAINED_PARM_CONCEPT (decl)\n+          && DECL_P (CONSTRAINED_PARM_CONCEPT (decl)));\n+}\n+\n+/* Returns true if PARM declares a constrained-parameter. */\n+\n+static inline bool\n+is_constrained_parameter (cp_parameter_declarator *parm)\n+{\n+  return is_constrained_parameter (parm->decl_specifiers.type);\n+}\n+\n+/* Check that the type parameter is only a declarator-id, and that its\n+   type is not cv-qualified. */\n+\n+bool\n+cp_parser_check_constrained_type_parm (cp_parser *parser,\n+\t\t\t\t       cp_parameter_declarator *parm)\n+{\n+  if (!parm->declarator)\n+    return true;\n+\n+  if (parm->declarator->kind != cdk_id)\n+    {\n+      cp_parser_error (parser, \"invalid constrained type parameter\");\n+      return false;\n+    }\n+\n+  /* Don't allow cv-qualified type parameters.  */\n+  if (decl_spec_seq_has_spec_p (&parm->decl_specifiers, ds_const)\n+      || decl_spec_seq_has_spec_p (&parm->decl_specifiers, ds_volatile))\n+    {\n+      cp_parser_error (parser, \"cv-qualified type parameter\");\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Finish parsing/processing a template type parameter and checking\n+   various restrictions. */\n+\n+static inline tree\n+cp_parser_constrained_type_template_parm (cp_parser *parser,\n+                                          tree id,\n+                                          cp_parameter_declarator* parmdecl)\n+{\n+  if (cp_parser_check_constrained_type_parm (parser, parmdecl))\n+    return finish_template_type_parm (class_type_node, id);\n+  else\n+    return error_mark_node;\n+}\n+\n+/* Finish parsing/processing a template template parameter by borrowing\n+   the template parameter list from the prototype parameter.  */\n+\n+static tree\n+cp_parser_constrained_template_template_parm (cp_parser *parser,\n+                                              tree proto,\n+                                              tree id,\n+                                              cp_parameter_declarator *parmdecl)\n+{\n+  if (!cp_parser_check_constrained_type_parm (parser, parmdecl))\n+    return error_mark_node;\n+\n+  /* FIXME: This should probably be copied, and we may need to adjust\n+     the template parameter depths.  */\n+  tree saved_parms = current_template_parms;\n+  begin_template_parm_list ();\n+  current_template_parms = DECL_TEMPLATE_PARMS (proto);\n+  end_template_parm_list ();\n+\n+  tree parm = finish_template_template_parm (class_type_node, id);\n+  current_template_parms = saved_parms;\n+\n+  return parm;\n+}\n+\n+/* Create a new non-type template parameter from the given PARM\n+   declarator.  */\n+\n+static tree\n+constrained_non_type_template_parm (bool *is_non_type,\n+                                    cp_parameter_declarator *parm)\n+{\n+  *is_non_type = true;\n+  cp_declarator *decl = parm->declarator;\n+  cp_decl_specifier_seq *specs = &parm->decl_specifiers;\n+  specs->type = TREE_TYPE (DECL_INITIAL (specs->type));\n+  return grokdeclarator (decl, specs, TPARM, 0, NULL);\n+}\n+\n+/* Build a constrained template parameter based on the PARMDECL\n+   declarator. The type of PARMDECL is the constrained type, which\n+   refers to the prototype template parameter that ultimately\n+   specifies the type of the declared parameter. */\n+\n+static tree\n+finish_constrained_parameter (cp_parser *parser,\n+                              cp_parameter_declarator *parmdecl,\n+                              bool *is_non_type,\n+                              bool *is_parameter_pack)\n+{\n+  tree decl = parmdecl->decl_specifiers.type;\n+  tree id = get_unqualified_id (parmdecl->declarator);\n+  tree def = parmdecl->default_argument;\n+  tree proto = DECL_INITIAL (decl);\n+\n+  /* A template parameter constrained by a variadic concept shall also\n+     be declared as a template parameter pack.  */\n+  bool is_variadic = template_parameter_pack_p (proto);\n+  if (is_variadic && !*is_parameter_pack)\n+    cp_parser_error (parser, \"variadic constraint introduced without %<...%>\");\n+\n+  /* Build the parameter. Return an error if the declarator was invalid. */\n+  tree parm;\n+  if (TREE_CODE (proto) == TYPE_DECL)\n+    parm = cp_parser_constrained_type_template_parm (parser, id, parmdecl);\n+  else if (TREE_CODE (proto) == TEMPLATE_DECL)\n+    parm = cp_parser_constrained_template_template_parm (parser, proto, id,\n+\t\t\t\t\t\t\t parmdecl);\n+  else\n+    parm = constrained_non_type_template_parm (is_non_type, parmdecl);\n+  if (parm == error_mark_node)\n+    return error_mark_node;\n+\n+  /* Finish the parameter decl and create a node attaching the\n+     default argument and constraint.  */\n+  parm = build_tree_list (def, parm);\n+  TEMPLATE_PARM_CONSTRAINTS (parm) = decl;\n+\n+  return parm;\n+}\n+\n+/* Returns true if the parsed type actually represents the declaration\n+   of a type template-parameter.  */\n+\n+static inline bool\n+declares_constrained_type_template_parameter (tree type)\n+{\n+  return (is_constrained_parameter (type)\n+\t  && TREE_CODE (TREE_TYPE (type)) == TEMPLATE_TYPE_PARM);\n+}\n+\n+\n+/* Returns true if the parsed type actually represents the declaration of\n+   a template template-parameter.  */\n+\n+static bool\n+declares_constrained_template_template_parameter (tree type)\n+{\n+  return (is_constrained_parameter (type)\n+\t  && TREE_CODE (TREE_TYPE (type)) == TEMPLATE_TEMPLATE_PARM);\n+}\n+\n /* Parse a default argument for a type template-parameter.\n    Note that diagnostics are handled in cp_parser_template_parameter.  */\n \n@@ -13454,15 +13784,14 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type,\n \treturn cp_parser_type_parameter (parser, is_parameter_pack);\n     }\n \n-  /* Otherwise, it is a non-type parameter.\n+  /* Otherwise, it is a non-type parameter or a constrained parameter.\n \n      [temp.param]\n \n      When parsing a default template-argument for a non-type\n      template-parameter, the first non-nested `>' is taken as the end\n      of the template parameter-list rather than a greater-than\n      operator.  */\n-  *is_non_type = true;\n   parameter_declarator\n      = cp_parser_parameter_declaration (parser, /*template_parm_p=*/true,\n \t\t\t\t\t/*parenthesized_p=*/NULL);\n@@ -13483,6 +13812,16 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type,\n \tcp_lexer_consume_token (parser->lexer);\n     }\n \n+  // The parameter may have been constrained.\n+  if (is_constrained_parameter (parameter_declarator))\n+    return finish_constrained_parameter (parser,\n+                                         parameter_declarator,\n+                                         is_non_type,\n+                                         is_parameter_pack);\n+\n+  // Now we're sure that the parameter is a non-type parameter.\n+  *is_non_type = true;\n+\n   parm = grokdeclarator (parameter_declarator->declarator,\n \t\t\t &parameter_declarator->decl_specifiers,\n \t\t\t TPARM, /*initialized=*/0,\n@@ -13599,6 +13938,16 @@ cp_parser_type_parameter (cp_parser* parser, bool *is_parameter_pack)\n \tcp_parser_template_parameter_list (parser);\n \t/* Look for the `>'.  */\n \tcp_parser_require (parser, CPP_GREATER, RT_GREATER);\n+\n+        // If template requirements are present, parse them.\n+\tif (flag_concepts)\n+          {\n+            tree reqs = get_shorthand_constraints (current_template_parms);\n+            if (tree r = cp_parser_requires_clause_opt (parser))\n+              reqs = conjoin_constraints (reqs, make_predicate_constraint (r));\n+            TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;\n+          }\n+\n \t/* Look for the `class' or 'typename' keywords.  */\n \tcp_parser_type_parameter_key (parser);\n         /* If the next token is an ellipsis, we have a template\n@@ -13833,6 +14182,11 @@ cp_parser_template_id (cp_parser *parser,\n       template_id\n \t= finish_template_type (templ, arguments, entering_scope);\n     }\n+  /* A template-like identifier may be a partial concept id. */\n+  else if (flag_concepts\n+           && (template_id = (cp_parser_maybe_partial_concept_id\n+\t\t\t      (parser, templ, arguments))))\n+    return template_id;\n   else if (variable_template_p (templ))\n     {\n       template_id = lookup_template_variable (templ, arguments);\n@@ -14844,6 +15198,11 @@ cp_parser_type_specifier (cp_parser* parser,\n      __typeof__ ( type-id )\n      __typeof__ ( type-id ) { initializer-list , [opt] }\n \n+   Concepts Extension:\n+\n+   simple-type-specifier:\n+     constrained-type-specifier\n+\n    Returns the indicated TYPE_DECL.  If DECL_SPECS is not NULL, it is\n    appropriately updated.  */\n \n@@ -14954,7 +15313,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t    }\n \n \t  if (cxx_dialect >= cxx14)\n-\t    type = synthesize_implicit_template_parm (parser);\n+\t    type = synthesize_implicit_template_parm (parser, NULL_TREE);\n \t  else\n \t    type = error_mark_node;\n \n@@ -15195,18 +15554,34 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n    typedef-name:\n      identifier\n \n+  Concepts:\n+\n+   type-name:\n+     concept-name\n+     partial-concept-id\n+\n+   concept-name:\n+     identifier\n+\n    Returns a TYPE_DECL for the type.  */\n \n static tree\n cp_parser_type_name (cp_parser* parser)\n+{\n+  return cp_parser_type_name (parser, /*typename_keyword_p=*/false);\n+}\n+\n+/* See above. */\n+static tree\n+cp_parser_type_name (cp_parser* parser, bool typename_keyword_p)\n {\n   tree type_decl;\n \n   /* We can't know yet whether it is a class-name or not.  */\n   cp_parser_parse_tentatively (parser);\n   /* Try a class-name.  */\n   type_decl = cp_parser_class_name (parser,\n-\t\t\t\t    /*typename_keyword_p=*/false,\n+\t\t\t\t    typename_keyword_p,\n \t\t\t\t    /*template_keyword_p=*/false,\n \t\t\t\t    none_type,\n \t\t\t\t    /*check_dependency_p=*/true,\n@@ -15236,11 +15611,16 @@ cp_parser_type_name (cp_parser* parser)\n \t Whereas [temp.names]/7 says:\n \t \n \t     A simple-template-id that names a class template\n-\t     specialization is a class-name.  */\n+\t     specialization is a class-name.\n+\n+         With concepts, this could also be a partial-concept-id that\n+         declares a non-type template parameter. */\n       if (type_decl != NULL_TREE\n \t  && TREE_CODE (type_decl) == TYPE_DECL\n \t  && TYPE_DECL_ALIAS_P (type_decl))\n \tgcc_assert (DECL_TEMPLATE_INSTANTIATION (type_decl));\n+      else if (is_constrained_parameter (type_decl))\n+        /* Don't do anything. */ ;\n       else\n \tcp_parser_simulate_error (parser);\n \n@@ -15252,14 +15632,131 @@ cp_parser_type_name (cp_parser* parser)\n   return type_decl;\n }\n \n-/* Parse a non-class type-name, that is, either an enum-name or a typedef-name.\n+/* Returns true if proto is a type parameter, but not a template\n+   template parameter.  */\n+static bool\n+check_type_concept (tree fn, tree proto)\n+{\n+  if (TREE_CODE (proto) != TYPE_DECL)\n+    {\n+      error (\"invalid use of non-type concept %qD\", fn);\n+      return false;\n+    }\n+  return true;\n+}\n+\n+/*  Check if DECL and ARGS can form a constrained-type-specifier.\n+    If ARGS is non-null, we try to form a concept check of the\n+    form DECL<?, ARGS> where ? is a wildcard that matches any\n+    kind of template argument. If ARGS is NULL, then we try to\n+    form a concept check of the form DECL<?>. */\n+\n+static tree\n+cp_parser_maybe_constrained_type_specifier (cp_parser *parser,\n+\t\t\t\t\t    tree decl, tree args)\n+{\n+  gcc_assert (args ? TREE_CODE (args) == TREE_VEC : true);\n+\n+  /* If we a constrained-type-specifier cannot be deduced. */\n+  if (parser->prevent_constrained_type_specifiers)\n+    return NULL_TREE;\n+\n+  /* A constrained type specifier can only be found in an\n+     overload set or as a reference to a template declaration.\n+\n+     FIXME: This might be masking a bug.  It's possible that\n+     that the deduction below is causing template specializations\n+     to be formed with the wildcard as an argument.  */\n+  if (TREE_CODE (decl) != OVERLOAD && TREE_CODE (decl) != TEMPLATE_DECL)\n+    return NULL_TREE;\n+\n+  /* Try to build a call expression that evaluates the\n+     concept. This can fail if the overload set refers\n+     only to non-templates. */\n+  tree placeholder = build_nt (WILDCARD_DECL);\n+  tree check = build_concept_check (decl, placeholder, args);\n+  if (check == error_mark_node)\n+    return NULL_TREE;\n+\n+  /* Deduce the checked constraint and the prototype parameter.\n+\n+     FIXME: In certain cases, failure to deduce should be a\n+     diagnosable error.  */\n+  tree conc;\n+  tree proto;\n+  if (!deduce_constrained_parameter (check, conc, proto))\n+    return NULL_TREE;\n+\n+  /* In template parameter scope, this results in a constrained\n+     parameter. Return a descriptor of that parm. */\n+  if (processing_template_parmlist)\n+    return build_constrained_parameter (conc, proto, args);\n+\n+  /* In any other context, a concept must be a type concept.\n+\n+     FIXME: A constrained-type-specifier can be a placeholder\n+     of any kind.  */\n+  if (!check_type_concept (conc, proto))\n+    return error_mark_node;\n+\n+  /* In a parameter-declaration-clause, constrained-type\n+     specifiers result in invented template parameters.  */\n+  if (parser->auto_is_implicit_function_template_parm_p)\n+    {\n+      tree x = build_constrained_parameter (conc, proto, args);\n+      return synthesize_implicit_template_parm (parser, x);\n+    }\n+  else\n+    {\n+     /* Otherwise, we're in a context where the constrained\n+        type name is deduced and the constraint applies\n+        after deduction. */\n+      return make_constrained_auto (conc, args);\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* If DECL refers to a concept, return a TYPE_DECL representing\n+   the result of using the constrained type specifier in the\n+   current context.  DECL refers to a concept if\n+\n+  - it is an overload set containing a function concept taking a single\n+    type argument, or\n+\n+  - it is a variable concept taking a single type argument.  */\n+\n+static tree\n+cp_parser_maybe_concept_name (cp_parser* parser, tree decl)\n+{\n+  return cp_parser_maybe_constrained_type_specifier (parser, decl, NULL_TREE);\n+}\n+\n+/* Check if DECL and ARGS form a partial-concept-id.  If so,\n+   assign ID to the resulting constrained placeholder.\n+\n+   Returns true if the partial-concept-id designates a placeholder\n+   and false otherwise. Note that *id is set to NULL_TREE in\n+   this case. */\n+\n+static tree\n+cp_parser_maybe_partial_concept_id (cp_parser *parser, tree decl, tree args)\n+{\n+  return cp_parser_maybe_constrained_type_specifier (parser, decl, args);\n+}\n+\n+/* Parse a non-class type-name, that is, either an enum-name, a typedef-name,\n+   or a concept-name.\n \n    enum-name:\n      identifier\n \n    typedef-name:\n      identifier\n \n+   concept-name:\n+     identifier\n+\n    Returns a TYPE_DECL for the type.  */\n \n static tree\n@@ -15278,6 +15775,17 @@ cp_parser_nonclass_name (cp_parser* parser)\n \n   type_decl = strip_using_decl (type_decl);\n   \n+  /* If we found an overload set, then it may refer to a concept-name. */\n+  if (flag_concepts\n+      && (TREE_CODE (type_decl) == OVERLOAD\n+\t  || BASELINK_P (type_decl)\n+\t  || variable_concept_p (type_decl)))\n+  {\n+    /* Determine whether the overload refers to a concept. */\n+    if (tree decl = cp_parser_maybe_concept_name (parser, type_decl))\n+      return decl;\n+  }\n+\n   if (TREE_CODE (type_decl) != TYPE_DECL\n       && (objc_is_id (identifier) || objc_is_class_name (identifier)))\n     {\n@@ -16637,6 +17145,14 @@ cp_parser_alias_declaration (cp_parser* parser)\n   if (decl == error_mark_node)\n     return decl;\n \n+  // Attach constraints to the alias declaration.\n+  if (flag_concepts && current_template_parms)\n+    {\n+      tree reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);\n+      tree constr = build_constraints (reqs, NULL_TREE);\n+      set_constraints (decl, constr);\n+    }\n+\n   cp_finish_decl (decl, NULL_TREE, 0, NULL_TREE, 0);\n \n   if (pushed_scope)\n@@ -17632,11 +18148,11 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t      else\n \t\t\tattrs = chainon (attr, attrs);\n \t\t    }\n+\t\t  tree requires_clause = NULL_TREE;\n \t\t  late_return = (cp_parser_late_return_type_opt\n-\t\t\t\t (parser, declarator,\n+\t\t\t\t (parser, declarator, requires_clause,\n \t\t\t\t  memfn ? cv_quals : -1));\n \n-\n \t\t  /* Parse the virt-specifier-seq.  */\n \t\t  virt_specifiers = cp_parser_virt_specifier_seq_opt (parser);\n \n@@ -17647,7 +18163,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t\t\t\t\t     virt_specifiers,\n \t\t\t\t\t\t     ref_qual,\n \t\t\t\t\t\t     exception_specification,\n-\t\t\t\t\t\t     late_return);\n+\t\t\t\t\t\t     late_return,\n+\t\t\t\t\t\t     requires_clause);\n \t\t  declarator->std_attributes = attrs;\n \t\t  /* Any subsequent parameter lists are to do with\n \t\t     return type, so are not those of the declared\n@@ -18369,7 +18886,7 @@ parsing_nsdmi (void)\n \n static tree\n cp_parser_late_return_type_opt (cp_parser* parser, cp_declarator *declarator,\n-\t\t\t\tcp_cv_quals quals)\n+\t\t\t\ttree& requires_clause, cp_cv_quals quals)\n {\n   cp_token *token;\n   tree type = NULL_TREE;\n@@ -18383,7 +18900,9 @@ cp_parser_late_return_type_opt (cp_parser* parser, cp_declarator *declarator,\n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n   /* A late-specified return type is indicated by an initial '->'. */\n-  if (token->type != CPP_DEREF && !(declare_simd_p || cilk_simd_fn_vector_p))\n+  if (token->type != CPP_DEREF\n+      && token->keyword != RID_REQUIRES\n+      && !(declare_simd_p || cilk_simd_fn_vector_p))\n     return NULL_TREE;\n \n   tree save_ccp = current_class_ptr;\n@@ -18402,6 +18921,10 @@ cp_parser_late_return_type_opt (cp_parser* parser, cp_declarator *declarator,\n       type = cp_parser_trailing_type_id (parser);\n     }\n \n+  /* Function declarations may be followed by a trailing\n+     requires-clause.  */\n+  requires_clause = cp_parser_requires_clause_opt (parser);\n+\n   if (cilk_simd_fn_vector_p)\n     declarator->std_attributes\n       = cp_parser_late_parsing_cilk_simd_fn_info (parser,\n@@ -18502,11 +19025,16 @@ cp_parser_type_id_1 (cp_parser* parser, bool is_template_arg,\n       && type_uses_auto (type_specifier_seq.type))\n     {\n       /* A type-id with type 'auto' is only ok if the abstract declarator\n-\t is a function declarator with a late-specified return type.  */\n+\t is a function declarator with a late-specified return type.\n+\n+         A type-id with 'auto' is also valid in a trailing-return-type\n+         in a compound-requirement. */\n       if (abstract_declarator\n \t  && abstract_declarator->kind == cdk_function\n \t  && abstract_declarator->u.function.late_return_type)\n \t/* OK */;\n+      else if (parser->in_result_type_constraint_p)\n+        /* OK */;\n       else\n \t{\n \t  error (\"invalid use of %<auto%>\");\n@@ -18539,7 +19067,8 @@ static tree cp_parser_template_type_arg (cp_parser *parser)\n   return r;\n }\n \n-static tree cp_parser_trailing_type_id (cp_parser *parser)\n+static tree\n+cp_parser_trailing_type_id (cp_parser *parser)\n {\n   return cp_parser_type_id_1 (parser, false, true);\n }\n@@ -19123,13 +19652,25 @@ cp_parser_parameter_declaration (cp_parser *parser,\n   /* If the next token is `=', then process a default argument.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_EQ))\n     {\n+      tree type = decl_specifiers.type;\n       token = cp_lexer_peek_token (parser->lexer);\n       /* If we are defining a class, then the tokens that make up the\n \t default argument must be saved and processed later.  */\n       if (!template_parm_p && at_class_scope_p ()\n \t  && TYPE_BEING_DEFINED (current_class_type)\n \t  && !LAMBDA_TYPE_P (current_class_type))\n \tdefault_argument = cp_parser_cache_defarg (parser, /*nsdmi=*/false);\n+\n+      // A constrained-type-specifier may declare a type template-parameter.\n+      else if (declares_constrained_type_template_parameter (type))\n+        default_argument\n+          = cp_parser_default_type_template_argument (parser);\n+\n+      // A constrained-type-specifier may declare a template-template-parameter.\n+      else if (declares_constrained_template_template_parameter (type))\n+        default_argument\n+          = cp_parser_default_template_template_argument (parser);\n+\n       /* Outside of a class definition, we can just parse the\n \t assignment-expression.  */\n       else\n@@ -19872,6 +20413,10 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n     = parser->in_unbraced_linkage_specification_p;\n   parser->in_unbraced_linkage_specification_p = false;\n \n+  // Associate constraints with the type.\n+  if (flag_concepts)\n+    type = associate_classtype_constraints (type);\n+\n   /* Start the class.  */\n   if (nested_name_specifier_p)\n     {\n@@ -20770,6 +21315,9 @@ cp_parser_member_declaration (cp_parser* parser)\n \n       return;\n     }\n+  /* Check for a template introduction.  */\n+  else if (cp_parser_template_declaration_after_export (parser, true))\n+    return;\n \n   /* Check for a using-declaration.  */\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_USING))\n@@ -22764,18 +23312,336 @@ cp_parser_label_declaration (cp_parser* parser)\n   cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n }\n \n-/* Support Functions */\n+// -------------------------------------------------------------------------- //\n+// Requires Clause\n \n-/* Looks up NAME in the current scope, as given by PARSER->SCOPE.\n-   NAME should have one of the representations used for an\n-   id-expression.  If NAME is the ERROR_MARK_NODE, the ERROR_MARK_NODE\n-   is returned.  If PARSER->SCOPE is a dependent type, then a\n-   SCOPE_REF is returned.\n+// Parse a requires clause.\n+//\n+//    requires-clause:\n+//      'requires' logical-or-expression\n+//\n+// The required logical-or-expression must be a constant expression. Note\n+// that we don't check that the expression is constepxr here. We defer until\n+// we analyze constraints and then, we only check atomic constraints.\n+static tree\n+cp_parser_requires_clause (cp_parser *parser)\n+{\n+  // Parse the requires clause so that it is not automatically folded.\n+  ++processing_template_decl;\n+  tree expr = cp_parser_binary_expression (parser, false, false,\n+\t\t\t\t\t   PREC_NOT_OPERATOR, NULL);\n+  --processing_template_decl;\n+  return expr;\n+}\n \n-   If NAME is a TEMPLATE_ID_EXPR, then it will be immediately\n-   returned; the name was already resolved when the TEMPLATE_ID_EXPR\n-   was formed.  Abstractly, such entities should not be passed to this\n-   function, because they do not need to be looked up, but it is\n+// Optionally parse a requires clause:\n+static tree\n+cp_parser_requires_clause_opt (cp_parser *parser)\n+{\n+  if (!cp_lexer_next_token_is_keyword (parser->lexer, RID_REQUIRES))\n+    return NULL_TREE;\n+  cp_lexer_consume_token (parser->lexer);\n+  return cp_parser_requires_clause (parser);\n+}\n+\n+\n+/*---------------------------------------------------------------------------\n+                           Requires expressions\n+---------------------------------------------------------------------------*/\n+\n+/* Parse a requires expression\n+\n+   requirement-expression:\n+       'requires' requirement-parameter-list [opt] requirement-body */\n+static tree\n+cp_parser_requires_expression (cp_parser *parser)\n+{\n+  gcc_assert (cp_lexer_next_token_is_keyword (parser->lexer, RID_REQUIRES));\n+  location_t loc = cp_lexer_consume_token (parser->lexer)->location;\n+\n+  /* A requires-expression shall appear only within a concept\n+     definition or a requires-clause.\n+\n+     TODO: Implement this diagnostic correctly. */\n+  if (!processing_template_decl)\n+    {\n+      error_at (loc, \"a requires expression cannot appear outside a template\");\n+      cp_parser_skip_to_end_of_statement (parser);\n+      return error_mark_node;\n+    }\n+\n+  tree parms, reqs;\n+  {\n+    /* Local parameters are delared as variables within the scope\n+       of the expression.  They are not visible past the end of\n+       the expression.  Expressions within the requires-expression\n+       are unevaluated.  */\n+    struct scope_sentinel\n+    {\n+      scope_sentinel ()\n+      {\n+\t++cp_unevaluated_operand;\n+\tbegin_scope (sk_block, NULL_TREE);\n+      }\n+\n+      ~scope_sentinel ()\n+      {\n+\tpop_bindings_and_leave_scope ();\n+\t--cp_unevaluated_operand;\n+      }\n+    } s;\n+\n+    /* Parse the optional parameter list. */\n+    if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+      {\n+\tparms = cp_parser_requirement_parameter_list (parser);\n+\tif (parms == error_mark_node)\n+\t  return error_mark_node;\n+      }\n+    else\n+      parms = NULL_TREE;\n+\n+    /* Parse the requirement body. */\n+    reqs = cp_parser_requirement_body (parser);\n+    if (reqs == error_mark_node)\n+      return error_mark_node;\n+  }\n+\n+  /* This needs to happen after pop_bindings_and_leave_scope, as it reverses\n+     the parm chain.  */\n+  grokparms (parms, &parms);\n+  return finish_requires_expr (parms, reqs);\n+}\n+\n+/* Parse a parameterized requirement.\n+\n+   requirement-parameter-list:\n+       '(' parameter-declaration-clause ')' */\n+static tree\n+cp_parser_requirement_parameter_list (cp_parser *parser)\n+{\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+    return error_mark_node;\n+\n+  tree parms = cp_parser_parameter_declaration_clause (parser);\n+\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+    return error_mark_node;\n+\n+  return parms;\n+}\n+\n+/* Parse the body of a requirement.\n+\n+   requirement-body:\n+       '{' requirement-list '}' */\n+static tree\n+cp_parser_requirement_body (cp_parser *parser)\n+{\n+  if (!cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))\n+    return error_mark_node;\n+\n+  tree reqs = cp_parser_requirement_list (parser);\n+\n+  if (!cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE))\n+    return error_mark_node;\n+\n+  return reqs;\n+}\n+\n+/* Parse a list of requirements.\n+\n+   requirement-list:\n+       requirement\n+       requirement-list ';' requirement[opt] */\n+static tree\n+cp_parser_requirement_list (cp_parser *parser)\n+{\n+  tree result = NULL_TREE;\n+  while (true)\n+    {\n+      tree req = cp_parser_requirement (parser);\n+      if (req == error_mark_node)\n+        return error_mark_node;\n+\n+      result = tree_cons (NULL_TREE, req, result);\n+\n+      /* If we see a semi-colon, consume it. */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n+\tcp_lexer_consume_token (parser->lexer);\n+\n+      /* Stop processing at the end of the list. */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))\n+        break;\n+    }\n+\n+  /* Reverse the order of requirements so they are analyzed in\n+     declaration order. */\n+  return nreverse (result);\n+}\n+\n+/* Parse a syntactic requirement or type requirement.\n+\n+     requirement:\n+       simple-requirement\n+       compound-requirement\n+       type-requirement\n+       nested-requirement */\n+static tree\n+cp_parser_requirement (cp_parser *parser)\n+{\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+    return cp_parser_compound_requirement (parser);\n+  else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_TYPENAME))\n+    return cp_parser_type_requirement (parser);\n+  else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_REQUIRES))\n+    return cp_parser_nested_requirement (parser);\n+  else\n+    return cp_parser_simple_requirement (parser);\n+}\n+\n+/* Parse a simple requirement.\n+\n+     simple-requirement:\n+       expression ';' */\n+static tree\n+cp_parser_simple_requirement (cp_parser *parser)\n+{\n+  tree expr = cp_parser_expression (parser, NULL, false, false);\n+  if (!expr || expr == error_mark_node)\n+    return error_mark_node;\n+\n+  if (!cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON))\n+    return error_mark_node;\n+\n+  return finish_simple_requirement (expr);\n+}\n+\n+/* Parse a type requirement\n+\n+     type-requirement\n+         nested-name-specifier [opt] required-type-name ';'\n+\n+     required-type-name:\n+         type-name\n+         'template' [opt] simple-template-id  */\n+static tree\n+cp_parser_type_requirement (cp_parser *parser)\n+{\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  // Save the scope before parsing name specifiers.\n+  tree saved_scope = parser->scope;\n+  tree saved_object_scope = parser->object_scope;\n+  tree saved_qualifying_scope = parser->qualifying_scope;\n+  cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/true);\n+  cp_parser_nested_name_specifier_opt (parser,\n+                                       /*typename_keyword_p=*/true,\n+                                       /*check_dependency_p=*/false,\n+                                       /*type_p=*/true,\n+                                       /*is_declaration=*/false);\n+\n+  tree type;\n+  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_TEMPLATE))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      type = cp_parser_template_id (parser,\n+                                    /*template_keyword_p=*/true,\n+                                    /*check_dependency=*/false,\n+                                    /*tag_type=*/none_type,\n+                                    /*is_declaration=*/false);\n+      type = make_typename_type (parser->scope, type, typename_type,\n+                                 /*complain=*/tf_error);\n+    }\n+  else\n+   type = cp_parser_type_name (parser, /*typename_keyword_p=*/true);\n+\n+  if (TREE_CODE (type) == TYPE_DECL)\n+    type = TREE_TYPE (type);\n+\n+  parser->scope = saved_scope;\n+  parser->object_scope = saved_object_scope;\n+  parser->qualifying_scope = saved_qualifying_scope;\n+\n+  if (type == error_mark_node)\n+    cp_parser_skip_to_end_of_statement (parser);\n+\n+  if (!cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON))\n+    return error_mark_node;\n+  if (type == error_mark_node)\n+    return error_mark_node;\n+\n+  return finish_type_requirement (type);\n+}\n+\n+/* Parse a compound requirement\n+\n+     compound-requirement:\n+         '{' expression '}' 'noexcept' [opt] trailing-return-type [opt] ';' */\n+static tree\n+cp_parser_compound_requirement (cp_parser *parser)\n+{\n+  /* Parse an expression enclosed in '{ }'s. */\n+  if (!cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))\n+    return error_mark_node;\n+\n+  tree expr = cp_parser_expression (parser, NULL, false, false);\n+  if (!expr || expr == error_mark_node)\n+    return error_mark_node;\n+\n+  if (!cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE))\n+    return error_mark_node;\n+\n+  /* Parse the optional noexcept. */\n+  bool noexcept_p = false;\n+  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_NOEXCEPT))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      noexcept_p = true;\n+    }\n+\n+  /* Parse the optional trailing return type. */\n+  tree type = NULL_TREE;\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_DEREF))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      bool saved_result_type_constraint_p = parser->in_result_type_constraint_p;\n+      parser->in_result_type_constraint_p = true;\n+      type = cp_parser_trailing_type_id (parser);\n+      parser->in_result_type_constraint_p = saved_result_type_constraint_p;\n+      if (type == error_mark_node)\n+        return error_mark_node;\n+    }\n+\n+  return finish_compound_requirement (expr, type, noexcept_p);\n+}\n+\n+/* Parse a nested requirement. This is the same as a requires clause.\n+\n+   nested-requirement:\n+     requires-clause */\n+static tree\n+cp_parser_nested_requirement (cp_parser *parser)\n+{\n+  cp_lexer_consume_token (parser->lexer);\n+  tree req = cp_parser_requires_clause (parser);\n+  if (req == error_mark_node)\n+    return error_mark_node;\n+  return finish_nested_requirement (req);\n+}\n+\n+/* Support Functions */\n+\n+/* Looks up NAME in the current scope, as given by PARSER->SCOPE.\n+   NAME should have one of the representations used for an\n+   id-expression.  If NAME is the ERROR_MARK_NODE, the ERROR_MARK_NODE\n+   is returned.  If PARSER->SCOPE is a dependent type, then a\n+   SCOPE_REF is returned.\n+\n+   If NAME is a TEMPLATE_ID_EXPR, then it will be immediately\n+   returned; the name was already resolved when the TEMPLATE_ID_EXPR\n+   was formed.  Abstractly, such entities should not be passed to this\n+   function, because they do not need to be looked up, but it is\n    simpler to check for this special case here, rather than at the\n    call-sites.\n \n@@ -23586,87 +24452,29 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n   return fn;\n }\n \n-/* Parse a template-declaration, assuming that the `export' (and\n-   `extern') keywords, if present, has already been scanned.  MEMBER_P\n-   is as for cp_parser_template_declaration.  */\n+/* Parse a template-declaration body (following argument list).  */\n \n static void\n-cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n+cp_parser_template_declaration_after_parameters (cp_parser* parser,\n+\t\t\t\t\t\t tree parameter_list,\n+\t\t\t\t\t\t bool member_p)\n {\n   tree decl = NULL_TREE;\n-  vec<deferred_access_check, va_gc> *checks;\n-  tree parameter_list;\n   bool friend_p = false;\n-  bool need_lang_pop;\n-  cp_token *token;\n-\n-  /* Look for the `template' keyword.  */\n-  token = cp_lexer_peek_token (parser->lexer);\n-  if (!cp_parser_require_keyword (parser, RID_TEMPLATE, RT_TEMPLATE))\n-    return;\n \n-  /* And the `<'.  */\n-  if (!cp_parser_require (parser, CPP_LESS, RT_LESS))\n-    return;\n-  if (at_class_scope_p () && current_function_decl)\n-    {\n-      /* 14.5.2.2 [temp.mem]\n-\n-         A local class shall not have member templates.  */\n-      error_at (token->location,\n-\t\t\"invalid declaration of member template in local class\");\n-      cp_parser_skip_to_end_of_block_or_statement (parser);\n-      return;\n-    }\n-  /* [temp]\n-\n-     A template ... shall not have C linkage.  */\n-  if (current_lang_name == lang_name_c)\n-    {\n-      error_at (token->location, \"template with C linkage\");\n-      /* Give it C++ linkage to avoid confusing other parts of the\n-\t front end.  */\n-      push_lang_context (lang_name_cplusplus);\n-      need_lang_pop = true;\n-    }\n-  else\n-    need_lang_pop = false;\n-\n-  /* We cannot perform access checks on the template parameter\n-     declarations until we know what is being declared, just as we\n-     cannot check the decl-specifier list.  */\n-  push_deferring_access_checks (dk_deferred);\n-\n-  /* If the next token is `>', then we have an invalid\n-     specialization.  Rather than complain about an invalid template\n-     parameter, issue an error message here.  */\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_GREATER))\n-    {\n-      cp_parser_error (parser, \"invalid explicit specialization\");\n-      begin_specialization ();\n-      parameter_list = NULL_TREE;\n-    }\n-  else\n-    {\n-      /* Parse the template parameters.  */\n-      parameter_list = cp_parser_template_parameter_list (parser);\n-    }\n+  /* We just processed one more parameter list.  */\n+  ++parser->num_template_parameter_lists;\n \n   /* Get the deferred access checks from the parameter list.  These\n      will be checked once we know what is being declared, as for a\n      member template the checks must be performed in the scope of the\n      class containing the member.  */\n-  checks = get_deferred_access_checks ();\n+  vec<deferred_access_check, va_gc> *checks = get_deferred_access_checks ();\n \n-  /* Look for the `>'.  */\n-  cp_parser_skip_to_end_of_template_parameter_list (parser);\n-  /* We just processed one more parameter list.  */\n-  ++parser->num_template_parameter_lists;\n-  /* If the next token is `template', there are more template\n-     parameters.  */\n-  if (cp_lexer_next_token_is_keyword (parser->lexer,\n-\t\t\t\t      RID_TEMPLATE))\n-    cp_parser_template_declaration_after_export (parser, member_p);\n+  /* Tentatively parse for a new template parameter list, which can either be\n+     the template keyword or a template introduction.  */\n+  if (cp_parser_template_declaration_after_export (parser, member_p))\n+    /* OK */;\n   else if (cxx_dialect >= cxx11\n \t   && cp_lexer_next_token_is_keyword (parser->lexer, RID_USING))\n     decl = cp_parser_alias_declaration (parser);\n@@ -23675,7 +24483,7 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n       /* There are no access checks when parsing a template, as we do not\n \t know if a specialization will be a friend.  */\n       push_deferring_access_checks (dk_no_check);\n-      token = cp_lexer_peek_token (parser->lexer);\n+      cp_token *token = cp_lexer_peek_token (parser->lexer);\n       decl = cp_parser_single_declaration (parser,\n \t\t\t\t\t   checks,\n \t\t\t\t\t   member_p,\n@@ -23750,13 +24558,10 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n \t\t   decl);\n \t}\n     }\n+\n   /* Register member declarations.  */\n   if (member_p && !friend_p && decl && !DECL_CLASS_TEMPLATE_P (decl))\n     finish_member_declaration (decl);\n-  /* For the erroneous case of a template with C linkage, we pushed an\n-     implicit C++ linkage scope; exit that scope now.  */\n-  if (need_lang_pop)\n-    pop_lang_context ();\n   /* If DECL is a function template, we must return to parse it later.\n      (Even though there is no definition, there might be default\n      arguments that need handling.)  */\n@@ -23765,6 +24570,182 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n     vec_safe_push (unparsed_funs_with_definitions, decl);\n }\n \n+/* Parse a template introduction header for a template-declaration.  Returns\n+   false if tentative parse fails.  */\n+\n+static bool\n+cp_parser_template_introduction (cp_parser* parser, bool member_p)\n+{\n+  cp_parser_parse_tentatively (parser);\n+\n+  tree saved_scope = parser->scope;\n+  tree saved_object_scope = parser->object_scope;\n+  tree saved_qualifying_scope = parser->qualifying_scope;\n+\n+  /* Look for the optional `::' operator.  */\n+  cp_parser_global_scope_opt (parser,\n+\t\t\t      /*current_scope_valid_p=*/false);\n+  /* Look for the nested-name-specifier.  */\n+  cp_parser_nested_name_specifier_opt (parser,\n+\t\t\t\t       /*typename_keyword_p=*/false,\n+\t\t\t\t       /*check_dependency_p=*/true,\n+\t\t\t\t       /*type_p=*/false,\n+\t\t\t\t       /*is_declaration=*/false);\n+\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  tree concept_name = cp_parser_identifier (parser);\n+\n+  /* Look up the concept for which we will be matching\n+     template parameters.  */\n+  tree tmpl_decl = cp_parser_lookup_name_simple (parser, concept_name,\n+\t\t\t\t\t\t token->location);\n+  parser->scope = saved_scope;\n+  parser->object_scope = saved_object_scope;\n+  parser->qualifying_scope = saved_qualifying_scope;\n+\n+  if (concept_name == error_mark_node)\n+    cp_parser_simulate_error (parser);\n+\n+  /* Look for opening brace for introduction.  */\n+  cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE);\n+\n+  if (!cp_parser_parse_definitely (parser))\n+    return false;\n+\n+  push_deferring_access_checks (dk_deferred);\n+\n+  /* Build vector of placeholder parameters and grab\n+     matching identifiers.  */\n+  tree introduction_list = cp_parser_introduction_list (parser);\n+\n+  /* The introduction-list shall not be empty.  */\n+  int nargs = TREE_VEC_LENGTH (introduction_list);\n+  if (nargs == 0)\n+    {\n+      error (\"empty introduction-list\");\n+      return true;\n+    }\n+\n+  /* Look for closing brace for introduction.  */\n+  if (!cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE))\n+    return true;\n+\n+  if (tmpl_decl == error_mark_node)\n+    {\n+      cp_parser_name_lookup_error (parser, concept_name, tmpl_decl, NLE_NULL,\n+\t\t\t\t   token->location);\n+      return true;\n+    }\n+\n+  /* Build and associate the constraint.  */\n+  tree parms = finish_template_introduction (tmpl_decl, introduction_list);\n+  if (parms && parms != error_mark_node)\n+    {\n+      cp_parser_template_declaration_after_parameters (parser, parms,\n+\t\t\t\t\t\t       member_p);\n+      return true;\n+    }\n+\n+  error_at (token->location, \"no matching concept for template-introduction\");\n+  return true;\n+}\n+\n+/* Parse a normal template-declaration following the template keyword.  */\n+\n+static void\n+cp_parser_explicit_template_declaration (cp_parser* parser, bool member_p)\n+{\n+  tree parameter_list;\n+  bool need_lang_pop;\n+  location_t location = input_location;\n+\n+  /* Look for the `<' token.  */\n+  if (!cp_parser_require (parser, CPP_LESS, RT_LESS))\n+    return;\n+  if (at_class_scope_p () && current_function_decl)\n+    {\n+      /* 14.5.2.2 [temp.mem]\n+\n+         A local class shall not have member templates.  */\n+      error_at (location,\n+                \"invalid declaration of member template in local class\");\n+      cp_parser_skip_to_end_of_block_or_statement (parser);\n+      return;\n+    }\n+  /* [temp]\n+\n+     A template ... shall not have C linkage.  */\n+  if (current_lang_name == lang_name_c)\n+    {\n+      error_at (location, \"template with C linkage\");\n+      /* Give it C++ linkage to avoid confusing other parts of the\n+         front end.  */\n+      push_lang_context (lang_name_cplusplus);\n+      need_lang_pop = true;\n+    }\n+  else\n+    need_lang_pop = false;\n+\n+  /* We cannot perform access checks on the template parameter\n+     declarations until we know what is being declared, just as we\n+     cannot check the decl-specifier list.  */\n+  push_deferring_access_checks (dk_deferred);\n+\n+  /* If the next token is `>', then we have an invalid\n+     specialization.  Rather than complain about an invalid template\n+     parameter, issue an error message here.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_GREATER))\n+    {\n+      cp_parser_error (parser, \"invalid explicit specialization\");\n+      begin_specialization ();\n+      parameter_list = NULL_TREE;\n+    }\n+  else\n+    {\n+      /* Parse the template parameters.  */\n+      parameter_list = cp_parser_template_parameter_list (parser);\n+    }\n+\n+  /* Look for the `>'.  */\n+  cp_parser_skip_to_end_of_template_parameter_list (parser);\n+\n+  /* Manage template requirements */\n+  if (flag_concepts)\n+  {\n+    tree reqs = get_shorthand_constraints (current_template_parms);\n+    if (tree r = cp_parser_requires_clause_opt (parser))\n+      reqs = conjoin_constraints (reqs, make_predicate_constraint (r));\n+    TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;\n+  }\n+\n+  cp_parser_template_declaration_after_parameters (parser, parameter_list,\n+\t\t\t\t\t\t   member_p);\n+\n+  /* For the erroneous case of a template with C linkage, we pushed an\n+     implicit C++ linkage scope; exit that scope now.  */\n+  if (need_lang_pop)\n+    pop_lang_context ();\n+}\n+\n+/* Parse a template-declaration, assuming that the `export' (and\n+   `extern') keywords, if present, has already been scanned.  MEMBER_P\n+   is as for cp_parser_template_declaration.  */\n+\n+static bool\n+cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n+{\n+  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_TEMPLATE))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      cp_parser_explicit_template_declaration (parser, member_p);\n+      return true;\n+    }\n+  else if (flag_concepts)\n+    return cp_parser_template_introduction (parser, member_p);\n+\n+  return false;\n+}\n+\n /* Perform the deferred access checks from a template-parameter-list.\n    CHECKS is a TREE_LIST of access checks, as returned by\n    get_deferred_access_checks.  */\n@@ -23832,6 +24813,12 @@ cp_parser_single_declaration (cp_parser* parser,\n     {\n       if (cp_parser_declares_only_class_p (parser))\n \t{\n+\t  // If this is a declaration, but not a definition, associate\n+\t  // any constraints with the type declaration. Constraints\n+\t  // are associated with definitions in cp_parser_class_specifier.\n+\t  if (declares_class_or_enum == 1)\n+\t    associate_classtype_constraints (decl_specifiers.type);\n+\n \t  decl = shadow_tag (&decl_specifiers);\n \n \t  /* In this case:\n@@ -33614,15 +34601,57 @@ tree_type_is_auto_or_concept (const_tree t)\n   return TREE_TYPE (t) && is_auto_or_concept (TREE_TYPE (t));\n }\n \n+/* Returns the template declaration being called or evaluated as\n+   part of the constraint check. Note that T must be a predicate\n+   constraint (it can't be any other kind of constraint). */\n+static tree\n+get_concept_from_constraint (tree t)\n+{\n+  gcc_assert (TREE_CODE (t) == PRED_CONSTR);\n+  t = PRED_CONSTR_EXPR (t);\n+  gcc_assert (TREE_CODE (t) == CALL_EXPR\n+              || TREE_CODE (t) == TEMPLATE_ID_EXPR\n+              || VAR_P (t));\n+\n+  if (TREE_CODE (t) == TEMPLATE_ID_EXPR)\n+    return DECL_TEMPLATE_RESULT (TREE_OPERAND (t, 0));\n+  if (VAR_P (t))\n+    return DECL_TEMPLATE_RESULT (DECL_TI_TEMPLATE (t));\n+  else\n+    {\n+      tree fn = CALL_EXPR_FN (t);\n+      tree ovl = TREE_OPERAND (fn, 0);\n+      tree tmpl = OVL_FUNCTION (ovl);\n+      return DECL_TEMPLATE_RESULT (tmpl);\n+    }\n+}\n+\n /* Add an implicit template type parameter to the CURRENT_TEMPLATE_PARMS\n    (creating a new template parameter list if necessary).  Returns the newly\n    created template type parm.  */\n \n tree\n-synthesize_implicit_template_parm  (cp_parser *parser)\n+synthesize_implicit_template_parm  (cp_parser *parser, tree constr)\n {\n   gcc_assert (current_binding_level->kind == sk_function_parms);\n \n+   /* Before committing to modifying any scope, if we're in an\n+      implicit template scope, and we're trying to synthesize a\n+      constrained parameter, try to find a previous parameter with\n+      the same name.  This is the same-type rule for abbreviated\n+      function templates.  */\n+  if (parser->implicit_template_scope && constr)\n+    {\n+      tree t = parser->implicit_template_parms;\n+      while (t)\n+        {\n+          tree c = get_concept_from_constraint (TREE_TYPE (t));\n+          if (c == CONSTRAINED_PARM_CONCEPT (constr))\n+            return TREE_VALUE (t);\n+          t = TREE_CHAIN (t);\n+        }\n+    }\n+\n   /* We are either continuing a function template that already contains implicit\n      template parameters, creating a new fully-implicit function template, or\n      extending an existing explicit function template with implicit template\n@@ -33731,14 +34760,18 @@ synthesize_implicit_template_parm  (cp_parser *parser)\n   tree synth_id = make_generic_type_name ();\n   tree synth_tmpl_parm = finish_template_type_parm (class_type_node,\n \t\t\t\t\t\t    synth_id);\n+\n+  // Attach the constraint to the parm before processing.\n+  tree node = build_tree_list (NULL_TREE, synth_tmpl_parm);\n+  TREE_TYPE (node) = constr;\n   tree new_parm\n     = process_template_parm (parser->implicit_template_parms,\n \t\t\t     input_location,\n-\t\t\t     build_tree_list (NULL_TREE, synth_tmpl_parm),\n+\t\t\t     node,\n \t\t\t     /*non_type=*/false,\n \t\t\t     /*param_pack=*/false);\n \n-\n+  // Chain the new parameter to the list of implicit parameters.\n   if (parser->implicit_template_parms)\n     parser->implicit_template_parms\n       = TREE_CHAIN (parser->implicit_template_parms);\n@@ -33768,6 +34801,15 @@ synthesize_implicit_template_parm  (cp_parser *parser)\n       TREE_VEC_ELT (new_parms, new_parm_idx) = parser->implicit_template_parms;\n     }\n \n+  // If the new parameter was constrained, we need to add that to the\n+  // constraints in the template parameter list.\n+  if (tree req = TEMPLATE_PARM_CONSTRAINTS (tree_last (new_parm)))\n+    {\n+      tree reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);\n+      reqs = conjoin_constraints (reqs, req);\n+      TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;\n+    }\n+\n   current_binding_level = entry_scope;\n \n   return new_type;"}, {"sha": "c7091c8e8e0f9b0cc5af11d3461a77a3be759f30", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -397,6 +397,15 @@ typedef struct GTY(()) cp_parser {\n      member definition using a generic type, it is the sk_class scope.  */\n   cp_binding_level* implicit_template_scope;\n \n+  /* True if parsing a result type in a compound requirement. This permits\n+     constrained-type-specifiers inside what would normally be a trailing\n+     return type. */\n+  bool in_result_type_constraint_p;\n+\n+  /* True if a constrained-type-specifier is not allowed in this\n+     context e.g., because they could never be deduced.  */\n+  int prevent_constrained_type_specifiers;\n+\n } cp_parser;\n \n /* In parser.c  */"}, {"sha": "1b64174653195323df5949fdcae78d2224dea03f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 772, "deletions": 91, "changes": 863, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -78,6 +78,23 @@ static GTY(()) tree saved_access_scope;\n    to the EXPR_STMT that is its result.  */\n static tree cur_stmt_expr;\n \n+// -------------------------------------------------------------------------- //\n+// Local Specialization Stack\n+//\n+// Implementation of the RAII helper for creating new local\n+// specializations.\n+local_specialization_stack::local_specialization_stack ()\n+  : saved (local_specializations)\n+{\n+  local_specializations = new hash_map<tree, tree>;\n+}\n+\n+local_specialization_stack::~local_specialization_stack ()\n+{\n+  delete local_specializations;\n+  local_specializations = saved;\n+}\n+\n /* True if we've recursed into fn_type_unification too many times.  */\n static bool excessive_deduction_depth;\n \n@@ -156,8 +173,6 @@ static tree expand_template_argument_pack (tree);\n static tree build_template_parm_index (int, int, int, tree, tree);\n static bool inline_needs_template_parms (tree, bool);\n static void push_inline_template_parms_recursive (tree, int);\n-static tree retrieve_local_specialization (tree);\n-static void register_local_specialization (tree, tree);\n static tree reduce_template_parm_level (tree, tree, int, tree, tsubst_flags_t);\n static int mark_template_parm (tree, void *);\n static int template_parm_this_level_p (tree, void *);\n@@ -196,17 +211,13 @@ static int invalid_nontype_parm_type_p (tree, tsubst_flags_t);\n static bool dependent_template_arg_p (tree);\n static bool any_template_arguments_need_structural_equality_p (tree);\n static bool dependent_type_p_r (tree);\n-static tree tsubst_expr\t(tree, tree, tsubst_flags_t, tree, bool);\n static tree tsubst_copy\t(tree, tree, tsubst_flags_t, tree);\n-static tree tsubst_pack_expansion (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_decl (tree, tree, tsubst_flags_t);\n static void perform_typedefs_access_check (tree tmpl, tree targs);\n static void append_type_to_template_for_access_check_1 (tree, tree, tree,\n \t\t\t\t\t\t\tlocation_t);\n static tree listify (tree);\n static tree listify_autos (tree, tree);\n-static tree template_parm_to_arg (tree t);\n-static tree current_template_args (void);\n static tree tsubst_template_parm (tree, tree, tsubst_flags_t);\n static tree instantiate_alias_template (tree, tree, tsubst_flags_t);\n static bool complex_alias_template_p (const_tree tmpl);\n@@ -818,6 +829,98 @@ check_explicit_instantiation_namespace (tree spec)\n \t       spec, current_namespace, ns);\n }\n \n+// Returns the type of a template specialization only if that\n+// specialization needs to be defined. Otherwise (e.g., if the type has\n+// already been defined), the function returns NULL_TREE.\n+static tree\n+maybe_new_partial_specialization (tree type)\n+{\n+  // An implicit instantiation of an incomplete type implies\n+  // the definition of a new class template.\n+  //\n+  //    template<typename T>\n+  //      struct S;\n+  //\n+  //    template<typename T>\n+  //      struct S<T*>;\n+  //\n+  // Here, S<T*> is an implicit instantiation of S whose type\n+  // is incomplete.\n+  if (CLASSTYPE_IMPLICIT_INSTANTIATION (type) && !COMPLETE_TYPE_P (type))\n+    return type;\n+\n+  // It can also be the case that TYPE is a completed specialization.\n+  // Continuing the previous example, suppose we also declare:\n+  //\n+  //    template<typename T>\n+  //      requires Integral<T>\n+  //        struct S<T*>;\n+  //\n+  // Here, S<T*> refers to the specialization S<T*> defined\n+  // above. However, we need to differentiate definitions because\n+  // we intend to define a new partial specialization. In this case,\n+  // we rely on the fact that the constraints are different for\n+  // this declaration than that above.\n+  //\n+  // Note that we also get here for injected class names and\n+  // late-parsed template definitions. We must ensure that we\n+  // do not create new type declarations for those cases.\n+  if (flag_concepts && CLASSTYPE_TEMPLATE_SPECIALIZATION (type))\n+    {\n+      tree tmpl = CLASSTYPE_TI_TEMPLATE (type);\n+      tree args = CLASSTYPE_TI_ARGS (type);\n+\n+      // If there are no template parameters, this cannot be a new\n+      // partial template specializtion?\n+      if (!current_template_parms)\n+        return NULL_TREE;\n+\n+      // If the constraints are not the same as those of the primary\n+      // then, we can probably create a new specialization.\n+      tree type_constr = current_template_constraints ();\n+\n+      if (type == TREE_TYPE (tmpl))\n+\tif (tree main_constr = get_constraints (tmpl))\n+\t  if (equivalent_constraints (type_constr, main_constr))\n+\t    return NULL_TREE;\n+\n+      // Also, if there's a pre-existing specialization with matching\n+      // constraints, then this also isn't new.\n+      tree specs = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n+      while (specs)\n+        {\n+          tree spec_tmpl = TREE_VALUE (specs);\n+          tree spec_args = TREE_PURPOSE (specs);\n+          tree spec_constr = get_constraints (spec_tmpl);\n+          if (comp_template_args (args, spec_args)\n+\t      && equivalent_constraints (type_constr, spec_constr))\n+            return NULL_TREE;\n+          specs = TREE_CHAIN (specs);\n+        }\n+\n+      // Create a new type node (and corresponding type decl)\n+      // for the newly declared specialization.\n+      tree t = make_class_type (TREE_CODE (type));\n+      CLASSTYPE_DECLARED_CLASS (t) = CLASSTYPE_DECLARED_CLASS (type);\n+      TYPE_FOR_JAVA (t) = TYPE_FOR_JAVA (type);\n+      SET_TYPE_TEMPLATE_INFO (t, build_template_info (tmpl, args));\n+\n+      /* We only need a separate type node for storing the definition of this\n+\t partial specialization; uses of S<T*> are unconstrained, so all are\n+\t equivalent.  So keep TYPE_CANONICAL the same.  */\n+      TYPE_CANONICAL (t) = TYPE_CANONICAL (type);\n+\n+      // Build the corresponding type decl.\n+      tree d = create_implicit_typedef (DECL_NAME (tmpl), t);\n+      DECL_CONTEXT (d) = TYPE_CONTEXT (t);\n+      DECL_SOURCE_LOCATION (d) = input_location;\n+\n+      return t;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* The TYPE is being declared.  If it is a template type, that means it\n    is a partial specialization.  Do appropriate error-checking.  */\n \n@@ -866,19 +969,19 @@ maybe_process_partial_specialization (tree type)\n \n \t Make sure that `C<int>' and `C<T*>' are implicit instantiations.  */\n \n-      if (CLASSTYPE_IMPLICIT_INSTANTIATION (type)\n-\t  && !COMPLETE_TYPE_P (type))\n+      if (tree t = maybe_new_partial_specialization (type))\n \t{\n-\t  if (!check_specialization_namespace (CLASSTYPE_TI_TEMPLATE (type))\n+\t  if (!check_specialization_namespace (CLASSTYPE_TI_TEMPLATE (t))\n \t      && !at_namespace_scope_p ())\n \t    return error_mark_node;\n-\t  SET_CLASSTYPE_TEMPLATE_SPECIALIZATION (type);\n-\t  DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (type)) = input_location;\n+\t  SET_CLASSTYPE_TEMPLATE_SPECIALIZATION (t);\n+\t  DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (t)) = input_location;\n \t  if (processing_template_decl)\n \t    {\n-\t      if (push_template_decl (TYPE_MAIN_DECL (type))\n-\t\t  == error_mark_node)\n+\t      tree decl = push_template_decl (TYPE_MAIN_DECL (t));\n+\t      if (decl == error_mark_node)\n \t\treturn error_mark_node;\n+\t      return TREE_TYPE (decl);\n \t    }\n \t}\n       else if (CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n@@ -1154,7 +1257,7 @@ retrieve_specialization (tree tmpl, tree args, hashval_t hash)\n \n /* Like retrieve_specialization, but for local declarations.  */\n \n-static tree\n+tree\n retrieve_local_specialization (tree tmpl)\n {\n   if (local_specializations == NULL)\n@@ -1546,8 +1649,7 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n   return spec;\n }\n \n-/* Returns true iff two spec_entry nodes are equivalent.  Only compares the\n-   TMPL and ARGS members, ignores SPEC.  */\n+/* Returns true iff two spec_entry nodes are equivalent.  */\n \n int comparing_specializations;\n \n@@ -1559,6 +1661,16 @@ spec_hasher::equal (spec_entry *e1, spec_entry *e2)\n   ++comparing_specializations;\n   equal = (e1->tmpl == e2->tmpl\n \t   && comp_template_args (e1->args, e2->args));\n+  if (equal && flag_concepts\n+      && VAR_P (DECL_TEMPLATE_RESULT (e1->tmpl))\n+      && uses_template_parms (e1->args))\n+    {\n+      /* Partial specializations of a variable template can be distinguished by\n+\t constraints.  */\n+      tree c1 = e1->spec ? get_constraints (e1->spec) : NULL_TREE;\n+      tree c2 = e2->spec ? get_constraints (e2->spec) : NULL_TREE;\n+      equal = equivalent_constraints (c1, c2);\n+    }\n   --comparing_specializations;\n \n   return equal;\n@@ -1785,7 +1897,7 @@ reregister_specialization (tree spec, tree tinfo, tree new_spec)\n /* Like register_specialization, but for local declarations.  We are\n    registering SPEC, an instantiation of TMPL.  */\n \n-static void\n+void\n register_local_specialization (tree spec, tree tmpl)\n {\n   local_specializations->put (tmpl, spec);\n@@ -1863,6 +1975,52 @@ print_candidates (tree fns)\n   gcc_assert (str == NULL);\n }\n \n+/* Get a (possibly) constrained template declaration for the\n+   purpose of ordering candidates.  */\n+static tree\n+get_template_for_ordering (tree list)\n+{\n+  gcc_assert (TREE_CODE (list) == TREE_LIST);\n+  tree f = TREE_VALUE (list);\n+  if (tree ti = DECL_TEMPLATE_INFO (f))\n+    return TI_TEMPLATE (ti);\n+  return f;\n+}\n+\n+/* Among candidates having the same signature, return the\n+   most constrained or NULL_TREE if there is no best candidate.\n+   If the signatures of candidates vary (e.g., template\n+   specialization vs. member function), then there can be no\n+   most constrained.\n+\n+   Note that we don't compare constraints on the functions\n+   themselves, but rather those of their templates. */\n+static tree\n+most_constrained_function (tree candidates)\n+{\n+  // Try to find the best candidate in a first pass.\n+  tree champ = candidates;\n+  for (tree c = TREE_CHAIN (champ); c; c = TREE_CHAIN (c))\n+    {\n+      int winner = more_constrained (get_template_for_ordering (champ),\n+                                     get_template_for_ordering (c));\n+      if (winner == -1)\n+        champ = c; // The candidate is more constrained\n+      else if (winner == 0)\n+        return NULL_TREE; // Neither is more constrained\n+    }\n+\n+  // Verify that the champ is better than previous candidates.\n+  for (tree c = candidates; c != champ; c = TREE_CHAIN (c)) {\n+    if (!more_constrained (get_template_for_ordering (champ),\n+                           get_template_for_ordering (c)))\n+      return NULL_TREE;\n+  }\n+\n+  return champ;\n+}\n+\n+\n /* Returns the template (one of the functions given by TEMPLATE_ID)\n    which can be specialized to match the indicated DECL with the\n    explicit template args given in TEMPLATE_ID.  The DECL may be\n@@ -1899,6 +2057,7 @@ determine_specialization (tree template_id,\n   tree targs;\n   tree explicit_targs;\n   tree candidates = NULL_TREE;\n+\n   /* A TREE_LIST of templates of which DECL may be a specialization.\n      The TREE_VALUE of each node is a TEMPLATE_DECL.  The\n      corresponding TREE_PURPOSE is the set of template arguments that,\n@@ -1960,7 +2119,8 @@ determine_specialization (tree template_id,\n       targs = coerce_template_parms (parms, explicit_targs, fns,\n \t\t\t\t     tf_warning_or_error,\n \t\t\t\t     /*req_all*/true, /*use_defarg*/true);\n-      templates = tree_cons (targs, fns, templates);\n+      if (targs != error_mark_node)\n+        templates = tree_cons (targs, fns, templates);\n     }\n   else for (; fns; fns = OVL_NEXT (fns))\n     {\n@@ -2035,7 +2195,11 @@ determine_specialization (tree template_id,\n \t  /* Function templates cannot be specializations; there are\n \t     no partial specializations of functions.  Therefore, if\n \t     the type of DECL does not match FN, there is no\n-\t     match.  */\n+\t     match.\n+\n+             Note that it should never be the case that we have both\n+             candidates added here, and for regular member functions\n+             below. */\n \t  if (tsk == tsk_template)\n \t    {\n \t      if (compparms (fn_arg_types, decl_arg_types))\n@@ -2056,7 +2220,12 @@ determine_specialization (tree template_id,\n \t       specialize TMPL will produce DECL.  */\n \t    continue;\n \n-\t  /* Make sure that the deduced arguments actually work.  */\n+          /* Remove, from the set of candidates, all those functions\n+             whose constraints are not satisfied. */\n+          if (flag_concepts && !constraints_satisfied_p (fn, targs))\n+            continue;\n+\n+          // Then, try to form the new function type.\n \t  insttype = tsubst (TREE_TYPE (fn), targs, tf_none, NULL_TREE);\n \t  if (insttype == error_mark_node)\n \t    continue;\n@@ -2114,10 +2283,17 @@ determine_specialization (tree template_id,\n \t      && DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n \t    decl_arg_types = TREE_CHAIN (decl_arg_types);\n \n-\t  if (compparms (TYPE_ARG_TYPES (TREE_TYPE (fn)),\n+\t  if (!compparms (TYPE_ARG_TYPES (TREE_TYPE (fn)),\n \t\t\t decl_arg_types))\n-\t    /* They match!  */\n-\t    candidates = tree_cons (NULL_TREE, fn, candidates);\n+            continue;\n+\n+          // If the deduced arguments do not satisfy the constraints,\n+          // this is not a candidate.\n+          if (flag_concepts && !constraints_satisfied_p (fn))\n+            continue;\n+\n+          // Add the candidate.\n+          candidates = tree_cons (NULL_TREE, fn, candidates);\n \t}\n     }\n \n@@ -2162,6 +2338,19 @@ determine_specialization (tree template_id,\n \t}\n     }\n \n+  // Concepts allows multiple declarations of member functions\n+  // with the same signature. Like above, we need to rely on\n+  // on the partial ordering of those candidates to determine which\n+  // is the best.\n+  if (flag_concepts && candidates && TREE_CHAIN (candidates))\n+    {\n+      if (tree cand = most_constrained_function (candidates))\n+        {\n+          candidates = cand;\n+          TREE_CHAIN (cand) = NULL_TREE;\n+        }\n+    }\n+\n   if (templates == NULL_TREE && candidates == NULL_TREE)\n     {\n       error (\"template-id %qD for %q+D does not match any template \"\n@@ -2190,6 +2379,10 @@ determine_specialization (tree template_id,\n     {\n       tree fn = TREE_VALUE (candidates);\n       *targs_out = copy_node (DECL_TI_ARGS (fn));\n+\n+      // Propagate the candidate's constraints to the declaration.\n+      set_constraints (decl, get_constraints (fn));\n+\n       /* DECL is a re-declaration or partial instantiation of a template\n \t function.  */\n       if (TREE_CODE (fn) == TEMPLATE_DECL)\n@@ -2448,6 +2641,7 @@ check_explicit_specialization (tree declarator,\n {\n   int have_def = flags & 2;\n   int is_friend = flags & 4;\n+  bool is_concept = flags & 8;\n   int specialization = 0;\n   int explicit_instantiation = 0;\n   int member_specialization = 0;\n@@ -2523,6 +2717,9 @@ check_explicit_specialization (tree declarator,\n \n       /* Fall through.  */\n     case tsk_expl_spec:\n+      if (is_concept)\n+        error (\"explicit specialization declared %<concept%>\");\n+\n       if (VAR_P (decl) && TREE_CODE (declarator) != TEMPLATE_ID_EXPR)\n \t/* In cases like template<> constexpr bool v = true;\n \t   We'll give an error in check_template_variable.  */\n@@ -2862,6 +3059,14 @@ check_explicit_specialization (tree declarator,\n               tree tmpl_func = DECL_TEMPLATE_RESULT (gen_tmpl);\n               gcc_assert (TREE_CODE (tmpl_func) == FUNCTION_DECL);\n \n+              /* A concept cannot be specialized.  */\n+              if (DECL_DECLARED_CONCEPT_P (tmpl_func))\n+                {\n+                  error (\"explicit specialization of function concept %qD\",\n+                         gen_tmpl);\n+                  return error_mark_node;\n+                }\n+\n               /* This specialization has the same linkage and visibility as\n                  the function template it specializes.  */\n               TREE_PUBLIC (decl) = TREE_PUBLIC (tmpl_func);\n@@ -2904,9 +3109,12 @@ check_explicit_specialization (tree declarator,\n \t  else if (VAR_P (decl))\n \t    DECL_COMDAT (decl) = false;\n \n-\t  /* Register this specialization so that we can find it\n-\t     again.  */\n-\t  decl = register_specialization (decl, gen_tmpl, targs, is_friend, 0);\n+\t  /* If this is a full specialization, register it so that we can find\n+\t     it again.  Partial specializations will be registered in\n+\t     process_partial_specialization.  */\n+\t  if (!processing_template_decl)\n+\t    decl = register_specialization (decl, gen_tmpl, targs,\n+\t\t\t\t\t    is_friend, 0);\n \n \t  /* A 'structor should already have clones.  */\n \t  gcc_assert (decl == error_mark_node\n@@ -3789,11 +3997,11 @@ process_template_parm (tree list, location_t parm_loc, tree parm,\n \t\t       bool is_non_type, bool is_parameter_pack)\n {\n   tree decl = 0;\n-  tree defval;\n   int idx = 0;\n \n   gcc_assert (TREE_CODE (parm) == TREE_LIST);\n-  defval = TREE_PURPOSE (parm);\n+  tree defval = TREE_PURPOSE (parm);\n+  tree constr = TREE_TYPE (parm);\n \n   if (list)\n     {\n@@ -3890,8 +4098,19 @@ process_template_parm (tree list, location_t parm_loc, tree parm,\n     }\n   DECL_ARTIFICIAL (decl) = 1;\n   SET_DECL_TEMPLATE_PARM_P (decl);\n+\n+  /* Build requirements for the type/template parameter.\n+     This must be done after SET_DECL_TEMPLATE_PARM_P or\n+     process_template_parm could fail. */\n+  tree reqs = finish_shorthand_constraint (parm, constr);\n+\n   pushdecl (decl);\n+\n+  /* Build the parameter node linking the parameter declaration,\n+     its default argument (if any), and its constraints (if any). */\n   parm = build_tree_list (defval, parm);\n+  TEMPLATE_PARM_CONSTRAINTS (parm) = reqs;\n+\n   return chainon (list, parm);\n }\n \n@@ -3926,6 +4145,16 @@ end_template_parm_list (tree parms)\n   return saved_parmlist;\n }\n \n+// Explicitly indicate the end of the template parameter list. We assume\n+// that the current template parameters have been constructed and/or\n+// managed explicitly, as when creating new template template parameters\n+// from a shorthand constraint.\n+void\n+end_template_parm_list ()\n+{\n+  --processing_template_parmlist;\n+}\n+\n /* end_template_decl is called after a template declaration is seen.  */\n \n void\n@@ -3948,7 +4177,7 @@ end_template_decl (void)\n    functions.  Note that If the TREE_LIST contains an error_mark\n    node, the returned argument is error_mark_node.  */\n \n-static tree\n+tree\n template_parm_to_arg (tree t)\n {\n \n@@ -4109,10 +4338,10 @@ maybe_update_decl_type (tree orig_type, tree scope)\n }\n \n /* Return a TEMPLATE_DECL corresponding to DECL, using the indicated\n-   template PARMS.  If MEMBER_TEMPLATE_P is true, the new template is\n-   a member template.  Used by push_template_decl below.  */\n+   template PARMS and constraints, CONSTR.  If MEMBER_TEMPLATE_P is true,\n+   the new  template is a member template. */\n \n-static tree\n+tree\n build_template_decl (tree decl, tree parms, bool member_template_p)\n {\n   tree tmpl = build_lang_decl (TEMPLATE_DECL, DECL_NAME (decl), NULL_TREE);\n@@ -4193,6 +4422,13 @@ process_partial_specialization (tree decl)\n \n   gcc_assert (current_template_parms);\n \n+  /* A concept cannot be specialized.  */\n+  if (flag_concepts && variable_concept_p (maintmpl))\n+    {\n+      error (\"specialization of variable concept %q#D\", maintmpl);\n+      return error_mark_node;\n+    }\n+\n   inner_parms = INNERMOST_TEMPLATE_PARMS (current_template_parms);\n   ntparms = TREE_VEC_LENGTH (inner_parms);\n \n@@ -4266,9 +4502,19 @@ process_partial_specialization (tree decl)\n      the implicit argument list of the primary template.  */\n   tree main_args\n     = TI_ARGS (get_template_info (DECL_TEMPLATE_RESULT (maintmpl)));\n-  if (comp_template_args (inner_args, INNERMOST_TEMPLATE_ARGS (main_args)))\n-    error (\"partial specialization %qD does not specialize \"\n-\t   \"any template arguments\", decl);\n+  if (comp_template_args (inner_args, INNERMOST_TEMPLATE_ARGS (main_args))\n+      && (!flag_concepts\n+\t  || !subsumes_constraints (current_template_constraints (),\n+\t\t\t\t    get_constraints (maintmpl))))\n+    {\n+      if (!flag_concepts)\n+        error (\"partial specialization %q+D does not specialize \"\n+\t       \"any template arguments\", decl);\n+      else\n+        error (\"partial specialization %q+D does not specialize any \"\n+\t       \"template arguments and is not more constrained than\", decl);\n+      inform (DECL_SOURCE_LOCATION (maintmpl), \"primary template here\");\n+    }\n \n   /* A partial specialization that replaces multiple parameters of the\n      primary template with a pack expansion is less specialized for those\n@@ -4411,6 +4657,7 @@ process_partial_specialization (tree decl)\n   if (TREE_CODE (decl) == TYPE_DECL)\n     gcc_assert (!COMPLETE_TYPE_P (type));\n \n+  // Build the template decl.\n   tree tmpl = build_template_decl (decl, current_template_parms,\n \t\t\t\t   DECL_MEMBER_TEMPLATE_P (maintmpl));\n   TREE_TYPE (tmpl) = type;\n@@ -4419,6 +4666,11 @@ process_partial_specialization (tree decl)\n   DECL_TEMPLATE_INFO (tmpl) = build_template_info (maintmpl, specargs);\n   DECL_PRIMARY_TEMPLATE (tmpl) = maintmpl;\n \n+  if (VAR_P (decl))\n+    /* We didn't register this in check_explicit_specialization so we could\n+       wait until the constraints were set.  */\n+    decl = register_specialization (decl, maintmpl, specargs, false, 0);\n+\n   DECL_TEMPLATE_SPECIALIZATIONS (maintmpl)\n     = tree_cons (specargs, tmpl,\n                  DECL_TEMPLATE_SPECIALIZATIONS (maintmpl));\n@@ -4965,7 +5217,8 @@ push_template_decl_real (tree decl, bool is_friend)\n \t     class-type, we must be redeclaring it here.  Make sure\n \t     that the redeclaration is valid.  */\n \t  redeclare_class_template (TREE_TYPE (decl),\n-\t\t\t\t    current_template_parms);\n+\t\t\t\t    current_template_parms,\n+\t\t\t\t    current_template_constraints ());\n \t  /* We don't need to create a new TEMPLATE_DECL; just use the\n \t     one we already had.  */\n \t  tmpl = TYPE_TI_TEMPLATE (TREE_TYPE (decl));\n@@ -5212,7 +5465,7 @@ add_inherited_template_parms (tree fn, tree inherited)\n      template <class T> struct S {};  */\n \n bool\n-redeclare_class_template (tree type, tree parms)\n+redeclare_class_template (tree type, tree parms, tree cons)\n {\n   tree tmpl;\n   tree tmpl_parms;\n@@ -5320,6 +5573,15 @@ redeclare_class_template (tree type, tree parms)\n \t}\n     }\n \n+  // Cannot redeclare a class template with a different set of constraints.\n+  if (!equivalent_constraints (get_constraints (tmpl), cons))\n+    {\n+      error_at (input_location, \"redeclaration %q#D with different \"\n+                                \"constraints\", tmpl);\n+      inform (DECL_SOURCE_LOCATION (tmpl),\n+              \"original declaration appeared here\");\n+    }\n+\n     return true;\n }\n \n@@ -6622,6 +6884,51 @@ canonicalize_type_argument (tree arg, tsubst_flags_t complain)\n   return canon;\n }\n \n+// A template declaration can be substituted for a constrained\n+// template template parameter only when the argument is more\n+// constrained than the parameter.\n+static bool\n+is_compatible_template_arg (tree parm, tree arg)\n+{\n+  tree parm_cons = get_constraints (parm);\n+\n+  /* For now, allow constrained template template arguments\n+     and unconstrained template template parameters.  */\n+  if (parm_cons == NULL_TREE)\n+    return true;\n+\n+  tree arg_cons = get_constraints (arg);\n+\n+  // If the template parameter is constrained, we need to rewrite its\n+  // constraints in terms of the ARG's template parameters. This ensures\n+  // that all of the template parameter types will have the same depth.\n+  //\n+  // Note that this is only valid when coerce_template_template_parm is\n+  // true for the innermost template parameters of PARM and ARG. In other\n+  // words, because coercion is successful, this conversion will be valid.\n+  if (parm_cons)\n+    {\n+      tree args = template_parms_to_args (DECL_TEMPLATE_PARMS (arg));\n+      parm_cons = tsubst_constraint_info (parm_cons,\n+\t\t\t\t\t  INNERMOST_TEMPLATE_ARGS (args),\n+\t\t\t\t\t  tf_none, NULL_TREE);\n+      if (parm_cons == error_mark_node)\n+        return false;\n+    }\n+\n+  return subsumes (parm_cons, arg_cons);\n+}\n+\n+// Convert a placeholder argument into a binding to the original\n+// parameter. The original parameter is saved as the TREE_TYPE of\n+// ARG.\n+static inline tree\n+convert_wildcard_argument (tree parm, tree arg)\n+{\n+  TREE_TYPE (arg) = parm;\n+  return arg;\n+}\n+\n /* Convert the indicated template ARG as necessary to match the\n    indicated template PARM.  Returns the converted ARG, or\n    error_mark_node if the conversion was unsuccessful.  Error and\n@@ -6644,6 +6951,10 @@ convert_template_argument (tree parm,\n   if (parm == error_mark_node)\n     return error_mark_node;\n \n+  /* Trivially convert placeholders. */\n+  if (TREE_CODE (arg) == WILDCARD_DECL)\n+    return convert_wildcard_argument (parm, arg);\n+\n   if (TREE_CODE (arg) == TREE_LIST\n       && TREE_CODE (TREE_VALUE (arg)) == OFFSET_REF)\n     {\n@@ -6811,6 +7122,22 @@ convert_template_argument (tree parm,\n \n \t\t  val = error_mark_node;\n \t\t}\n+\n+              // Check that the constraints are compatible before allowing the\n+              // substitution.\n+              if (val != error_mark_node)\n+                if (!is_compatible_template_arg (parm, arg))\n+                  {\n+\t\t    if (in_decl && (complain & tf_error))\n+                      {\n+                        error (\"constraint mismatch at argument %d in \"\n+                               \"template parameter list for %qD\",\n+                               i + 1, in_decl);\n+                        inform (input_location, \"  expected %qD but got %qD\",\n+                                parm, arg);\n+                      }\n+\t\t    val = error_mark_node;\n+                  }\n \t    }\n \t}\n       else\n@@ -6948,6 +7275,16 @@ coerce_template_parameter_pack (tree parms,\n \n       packed_args = make_tree_vec (TREE_VEC_LENGTH (packed_parms));\n     }\n+  /* Check if we have a placeholder pack, which indicates we're\n+     in the context of a introduction list.  In that case we want\n+     to match this pack to the single placeholder.  */\n+  else if (arg_idx < nargs\n+           && TREE_CODE (TREE_VEC_ELT (inner_args, arg_idx)) == WILDCARD_DECL\n+           && WILDCARD_PACK_P (TREE_VEC_ELT (inner_args, arg_idx)))\n+    {\n+      nargs = arg_idx + 1;\n+      packed_args = make_tree_vec (1);\n+    }\n   else\n     packed_args = make_tree_vec (nargs - arg_idx);\n \n@@ -7133,7 +7470,9 @@ coerce_template_parms (tree parms,\n     }\n   /* We can't pass a pack expansion to a non-pack parameter of an alias\n      template (DR 1430).  */\n-  else if (in_decl && DECL_ALIAS_TEMPLATE_P (in_decl)\n+  else if (in_decl\n+\t   && (DECL_ALIAS_TEMPLATE_P (in_decl)\n+\t       || concept_template_p (in_decl))\n \t   && variadic_args_p\n \t   && nargs - variadic_args_p < nparms - variadic_p)\n     {\n@@ -7147,8 +7486,14 @@ coerce_template_parms (tree parms,\n \t      if (PACK_EXPANSION_P (arg)\n \t\t  && !template_parameter_pack_p (parm))\n \t\t{\n-\t\t  error (\"pack expansion argument for non-pack parameter \"\n-\t\t\t \"%qD of alias template %qD\", parm, in_decl);\n+\t\t  if (DECL_ALIAS_TEMPLATE_P (in_decl))\n+\t\t    error_at (location_of (arg),\n+\t\t\t      \"pack expansion argument for non-pack parameter \"\n+\t\t\t      \"%qD of alias template %qD\", parm, in_decl);\n+\t\t  else\n+\t\t    error_at (location_of (arg),\n+\t\t\t      \"pack expansion argument for non-pack parameter \"\n+\t\t\t      \"%qD of concept %qD\", parm, in_decl);\n \t\t  inform (DECL_SOURCE_LOCATION (parm), \"declared here\");\n \t\t  goto found;\n \t\t}\n@@ -7318,6 +7663,30 @@ coerce_template_parms (tree parms,\n   return new_inner_args;\n }\n \n+/* Convert all template arguments to their appropriate types, and\n+   return a vector containing the innermost resulting template\n+   arguments.  If any error occurs, return error_mark_node. Error and\n+   warning messages are not issued.\n+\n+   Note that no function argument deduction is performed, and default\n+   arguments are used to fill in unspecified arguments. */\n+tree\n+coerce_template_parms (tree parms, tree args, tree in_decl)\n+{\n+  return coerce_template_parms (parms, args, in_decl, tf_none, true, true);\n+}\n+\n+/* Convert all template arguments to their appropriate type, and\n+   instantiate default arguments as needed. This returns a vector\n+   containing the innermost resulting template arguments, or\n+   error_mark_node if unsuccessful.  */\n+tree\n+coerce_template_parms (tree parms, tree args, tree in_decl,\n+                       tsubst_flags_t complain)\n+{\n+  return coerce_template_parms (parms, args, in_decl, complain, true, true);\n+}\n+\n /* Like coerce_template_parms.  If PARMS represents all template\n    parameters levels, this function returns a vector of vectors\n    representing all the resulting argument levels.  Note that in this\n@@ -7887,6 +8256,22 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n       if (entry)\n \treturn entry->spec;\n \n+      /* If the the template's constraints are not satisfied,\n+         then we cannot form a valid type.\n+\n+         Note that the check is deferred until after the hash\n+         lookup. This prevents redundant checks on previously\n+         instantiated specializations. */\n+      if (flag_concepts && !constraints_satisfied_p (gen_tmpl, arglist))\n+        {\n+          if (complain & tf_error)\n+            {\n+              error (\"template constraint failure\");\n+              diagnose_constraints (input_location, gen_tmpl, arglist);\n+            }\n+          return error_mark_node;\n+        }\n+\n       is_dependent_type = uses_template_parms (arglist);\n \n       /* If the deduced arguments are invalid, then the binding\n@@ -8130,6 +8515,7 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \t    : CLASSTYPE_TI_TEMPLATE (found);\n \t}\n \n+      // Build template info for the new specialization.\n       SET_TYPE_TEMPLATE_INFO (t, build_template_info (found, arglist));\n \n       elt.spec = t;\n@@ -8184,14 +8570,17 @@ lookup_template_class (tree d1, tree arglist, tree in_decl, tree context,\n   return ret;\n }\n \n-/* Return a TEMPLATE_ID_EXPR for the given variable template and ARGLIST.\n-   The type of the expression is the unknown_type_node since the\n-   template-id could refer to an explicit or partial specialization. */\n+/* Return a TEMPLATE_ID_EXPR for the given variable template and ARGLIST.  */\n \n tree\n lookup_template_variable (tree templ, tree arglist)\n {\n+  /* The type of the expression is NULL_TREE since the template-id could refer\n+     to an explicit or partial specialization. */\n   tree type = NULL_TREE;\n+  if (flag_concepts && variable_concept_p (templ))\n+    /* Except that concepts are always bool.  */\n+    type = boolean_type_node;\n   return build2 (TEMPLATE_ID_EXPR, type, templ, arglist);\n }\n \n@@ -8201,8 +8590,14 @@ tree\n finish_template_variable (tree var, tsubst_flags_t complain)\n {\n   tree templ = TREE_OPERAND (var, 0);\n-\n   tree arglist = TREE_OPERAND (var, 1);\n+\n+  /* We never want to return a VAR_DECL for a variable concept, since they\n+     aren't instantiated.  In a template, leave the TEMPLATE_ID_EXPR alone.  */\n+  bool concept_p = flag_concepts && variable_concept_p (templ);\n+  if (concept_p && processing_template_decl)\n+    return var;\n+\n   tree tmpl_args = DECL_TI_ARGS (DECL_TEMPLATE_RESULT (templ));\n   arglist = add_outermost_template_args (tmpl_args, arglist);\n \n@@ -8211,6 +8606,29 @@ finish_template_variable (tree var, tsubst_flags_t complain)\n \t\t\t\t\t     /*req_all*/true,\n \t\t\t\t\t     /*use_default*/true);\n \n+  if (flag_concepts && !constraints_satisfied_p (templ, arglist))\n+    {\n+      if (complain & tf_error)\n+\t{\n+\t  error (\"constraints for %qD not satisfied\", templ);\n+\t  diagnose_constraints (location_of (var), templ, arglist);\n+\t}\n+      return error_mark_node;\n+    }\n+\n+  /* If a template-id refers to a specialization of a variable\n+     concept, then the expression is true if and only if the\n+     concept's constraints are satisfied by the given template\n+     arguments.\n+\n+     NOTE: This is an extension of Concepts Lite TS that\n+     allows constraints to be used in expressions. */\n+  if (concept_p)\n+    {\n+      tree decl = DECL_TEMPLATE_RESULT (templ);\n+      return evaluate_variable_concept (decl, arglist);\n+    }\n+\n   return instantiate_template (templ, arglist, complain);\n }\n \f\n@@ -9013,7 +9431,8 @@ tsubst_friend_class (tree friend_tmpl, tree args)\n \n           saved_input_location = input_location;\n           input_location = DECL_SOURCE_LOCATION (friend_tmpl);\n-\t  redeclare_class_template (TREE_TYPE (tmpl), parms);\n+          tree cons = get_constraints (tmpl);\n+          redeclare_class_template (TREE_TYPE (tmpl), parms, cons);\n           input_location = saved_input_location;\n           \n \t}\n@@ -9831,7 +10250,7 @@ tsubst_template_arg (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n    instantiated from it at *SPEC_P, return a NONTYPE_ARGUMENT_PACK of them\n    and set *SPEC_P to point at the next point in the list.  */\n \n-static tree\n+tree\n extract_fnparm_pack (tree tmpl_parm, tree *spec_p)\n {\n   /* Collect all of the extra \"packed\" parameters into an\n@@ -10044,6 +10463,16 @@ gen_elem_of_pack_expansion_instantiation (tree pattern,\n     /* Expanding a fixed parameter pack from\n        coerce_template_parameter_pack.  */\n     t = tsubst_decl (pattern, args, complain);\n+  else if (pattern == error_mark_node)\n+    t = error_mark_node;\n+  else if (constraint_p (pattern))\n+    {\n+      if (processing_template_decl)\n+\tt = tsubst_constraint (pattern, args, complain, in_decl);\n+      else\n+\tt = (constraints_satisfied_p (pattern, args)\n+\t     ? boolean_true_node : boolean_false_node);\n+    }\n   else if (!TYPE_P (pattern))\n     t = tsubst_expr (pattern, args, complain, in_decl,\n \t\t     /*integral_constant_expression_p=*/false);\n@@ -10108,7 +10537,11 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n        }\n       if (TREE_CODE (parm_pack) == PARM_DECL)\n \t{\n-\t  if (PACK_EXPANSION_LOCAL_P (t))\n+\t  /* We know we have correct local_specializations if this\n+\t     expansion is at function scope, or if we're dealing with a\n+\t     local parameter in a requires expression; for the latter,\n+\t     tsubst_requires_expr set it up appropriately.  */\n+\t  if (PACK_EXPANSION_LOCAL_P (t) || CONSTRAINT_VAR_P (parm_pack))\n \t    arg_pack = retrieve_local_specialization (parm_pack);\n \t  else\n \t    {\n@@ -10788,6 +11221,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \tgcc_assert (DECL_LANG_SPECIFIC (r) != 0);\n \tDECL_CHAIN (r) = NULL_TREE;\n \n+        // Build new template info linking to the original template decl.\n \tDECL_TEMPLATE_INFO (r) = build_template_info (t, args);\n \n \tif (TREE_CODE (decl) == TYPE_DECL\n@@ -11041,6 +11475,15 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    && !grok_op_properties (r, /*complain=*/false))\n \t  RETURN (error_mark_node);\n \n+        /* When instantiating a constrained member, substitute\n+           into the constraints to create a new constraint.  */\n+        if (tree ci = get_constraints (t))\n+          if (member)\n+            {\n+              ci = tsubst_constraint_info (ci, argvec, complain, NULL_TREE);\n+              set_constraints (r, ci);\n+            }\n+\n \t/* Set up the DECL_TEMPLATE_INFO for R.  There's no need to do\n \t   this in the special friend case mentioned above where\n \t   GEN_TMPL is NULL.  */\n@@ -12098,6 +12541,12 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tint levels;\n \ttree arg = NULL_TREE;\n \n+\t/* Early in template argument deduction substitution, we don't\n+\t   want to reduce the level of 'auto', or it will be confused\n+\t   with a normal template parm in subsequent deduction.  */\n+\tif (is_auto (t) && (complain & tf_partial))\n+\t  return t;\n+\n \tr = NULL_TREE;\n \n \tgcc_assert (TREE_VEC_LENGTH (args) > 0);\n@@ -12238,12 +12687,6 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t     about the template parameter in question.  */\n \t  return t;\n \n-\t/* Early in template argument deduction substitution, we don't\n-\t   want to reduce the level of 'auto', or it will be confused\n-\t   with a normal template parm in subsequent deduction.  */\n-\tif (is_auto (t) && (complain & tf_partial))\n-\t  return t;\n-\n \t/* If we get here, we must have been looking at a parm for a\n \t   more deeply nested template.  Make a new version of this\n \t   template parameter, but with a lower level.  */\n@@ -12260,6 +12703,14 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t   complain | (code == TEMPLATE_TYPE_PARM\n \t\t\t       ? tf_ignore_bad_quals : 0));\n \t      }\n+\t    else if (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n+\t\t     && PLACEHOLDER_TYPE_CONSTRAINTS (t)\n+\t\t     && (r = (TEMPLATE_PARM_DESCENDANTS\n+\t\t\t      (TEMPLATE_TYPE_PARM_INDEX (t))))\n+\t\t     && (r = TREE_TYPE (r))\n+\t\t     && !PLACEHOLDER_TYPE_CONSTRAINTS (r))\n+\t      /* Break infinite recursion when substituting the constraints\n+\t\t of a constrained placeholder.  */;\n \t    else\n \t      {\n \t\tr = copy_type (t);\n@@ -12285,6 +12736,12 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\telse\n \t\t  TYPE_CANONICAL (r) = canonical_type_parameter (r);\n \n+\t\t/* Propagate constraints on placeholders.  */\n+                if (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n+                  if (tree constr = PLACEHOLDER_TYPE_CONSTRAINTS (t))\n+\t\t    PLACEHOLDER_TYPE_CONSTRAINTS (r)\n+\t\t      = tsubst_constraint (constr, args, complain, in_decl);\n+\n \t\tif (code == BOUND_TEMPLATE_TEMPLATE_PARM)\n \t\t  {\n \t\t    tree argvec = tsubst (TYPE_TI_ARGS (t), args,\n@@ -13934,7 +14391,7 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree initv,\n /* Like tsubst_copy for expressions, etc. but also does semantic\n    processing.  */\n \n-static tree\n+tree\n tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t     bool integral_constant_expression_p)\n {\n@@ -15911,6 +16368,9 @@ tsubst_copy_and_build (tree t,\n \t\t\t\t       complain));\n       }\n \n+    case REQUIRES_EXPR:\n+      RETURN (tsubst_requires_expr (t, args, complain, in_decl));\n+\n     default:\n       /* Handle Objective-C++ constructs, if appropriate.  */\n       {\n@@ -19194,6 +19654,16 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n \n   processing_template_decl--;\n \n+  /* If both deductions succeed, the partial ordering selects the more\n+     constrained template.  */\n+  if (!lose1 && !lose2)\n+    {\n+      tree c1 = get_constraints (DECL_TEMPLATE_RESULT (pat1));\n+      tree c2 = get_constraints (DECL_TEMPLATE_RESULT (pat2));\n+      lose1 = !subsumes_constraints (c1, c2);\n+      lose2 = !subsumes_constraints (c2, c1);\n+    }\n+\n   /* All things being equal, if the next argument is a pack expansion\n      for one function but not for the other, prefer the\n      non-variadic function.  FIXME this is bogus; see c++/41958.  */\n@@ -19262,6 +19732,11 @@ more_specialized_partial_spec (tree tmpl, tree pat1, tree pat2)\n     }\n   --processing_template_decl;\n \n+  /* If both deductions succeed, the partial ordering selects the more\n+     constrained template.  */\n+  if (!winner && any_deductions)\n+    return more_constrained (tmpl1, tmpl2);\n+\n   /* In the case of a tie where at least one of the templates\n      has a parameter pack at the end, the template with the most\n      non-packed parameters wins.  */\n@@ -19409,6 +19884,34 @@ get_partial_spec_bindings (tree tmpl, tree tparms, tree spec_args, tree args)\n   return deduced_args;\n }\n \n+// Compare two function templates T1 and T2 by deducing bindings\n+// from one against the other. If both deductions succeed, compare\n+// constraints to see which is more constrained.\n+static int\n+more_specialized_inst (tree t1, tree t2)\n+{\n+  int fate = 0;\n+  int count = 0;\n+\n+  if (get_bindings (t1, DECL_TEMPLATE_RESULT (t2), NULL_TREE, true))\n+    {\n+      --fate;\n+      ++count;\n+    }\n+\n+  if (get_bindings (t2, DECL_TEMPLATE_RESULT (t1), NULL_TREE, true))\n+    {\n+      ++fate;\n+      ++count;\n+    }\n+\n+  // If both deductions succeed, then one may be more constrained.\n+  if (count == 2 && fate == 0)\n+    fate = more_constrained (t1, t2);\n+\n+  return fate;\n+}\n+\n /* TEMPLATES is a TREE_LIST.  Each TREE_VALUE is a TEMPLATE_DECL.\n    Return the TREE_LIST node with the most specialized template, if\n    any.  If there is no most specialized template, the error_mark_node\n@@ -19430,18 +19933,7 @@ most_specialized_instantiation (tree templates)\n   champ = templates;\n   for (fn = TREE_CHAIN (templates); fn; fn = TREE_CHAIN (fn))\n     {\n-      int fate = 0;\n-\n-      if (get_bindings (TREE_VALUE (champ),\n-\t\t\tDECL_TEMPLATE_RESULT (TREE_VALUE (fn)),\n-\t\t\tNULL_TREE, /*check_ret=*/true))\n-\tfate--;\n-\n-      if (get_bindings (TREE_VALUE (fn),\n-\t\t\tDECL_TEMPLATE_RESULT (TREE_VALUE (champ)),\n-\t\t\tNULL_TREE, /*check_ret=*/true))\n-\tfate++;\n-\n+      int fate = more_specialized_inst (TREE_VALUE (champ), TREE_VALUE (fn));\n       if (fate == -1)\n \tchamp = fn;\n       else if (!fate)\n@@ -19458,17 +19950,13 @@ most_specialized_instantiation (tree templates)\n   if (champ)\n     /* Now verify that champ is better than everything earlier in the\n        instantiation list.  */\n-    for (fn = templates; fn != champ; fn = TREE_CHAIN (fn))\n-      if (get_bindings (TREE_VALUE (champ),\n-\t\t\tDECL_TEMPLATE_RESULT (TREE_VALUE (fn)),\n-\t\t\tNULL_TREE, /*check_ret=*/true)\n-\t  || !get_bindings (TREE_VALUE (fn),\n-\t\t\t    DECL_TEMPLATE_RESULT (TREE_VALUE (champ)),\n-\t\t\t    NULL_TREE, /*check_ret=*/true))\n-\t{\n-\t  champ = NULL_TREE;\n-\t  break;\n-\t}\n+    for (fn = templates; fn != champ; fn = TREE_CHAIN (fn)) {\n+      if (more_specialized_inst (TREE_VALUE (champ), TREE_VALUE (fn)) != 1)\n+      {\n+        champ = NULL_TREE;\n+        break;\n+      }\n+    }\n \n   processing_template_decl--;\n \n@@ -19629,8 +20117,15 @@ most_specialized_partial_spec (tree target, tsubst_flags_t complain)\n \t{\n \t  if (outer_args)\n \t    spec_args = add_to_template_args (outer_args, spec_args);\n-\t  list = tree_cons (spec_args, TREE_VALUE (t), list);\n-\t  TREE_TYPE (list) = TREE_TYPE (t);\n+\n+          /* Keep the candidate only if the constraints are satisfied,\n+             or if we're not compiling with concepts.  */\n+          if (!flag_concepts\n+              || constraints_satisfied_p (spec_tmpl, spec_args))\n+            {\n+              list = tree_cons (spec_args, TREE_VALUE (t), list);\n+              TREE_TYPE (list) = TREE_TYPE (t);\n+            }\n \t}\n     }\n \n@@ -20308,6 +20803,9 @@ instantiate_decl (tree d, int defer_ok,\n      functions and static member variables.  */\n   gcc_assert (VAR_OR_FUNCTION_DECL_P (d));\n \n+  /* A concept is never instantiated. */\n+  gcc_assert (!DECL_DECLARED_CONCEPT_P (d));\n+\n   /* Variables are never deferred; if instantiation is required, they\n      are instantiated right away.  That allows for better code in the\n      case that an expression refers to the value of the variable --\n@@ -21417,6 +21915,14 @@ value_dependent_expression_p (tree expression)\n \t\t|| has_value_dependent_address (op));\n       }\n \n+    case REQUIRES_EXPR:\n+      /* Treat all requires-expressions as value-dependent so\n+         we don't try to fold them.  */\n+      return true;\n+\n+    case TYPE_REQ:\n+      return dependent_type_p (TREE_OPERAND (expression, 0));\n+\n     case CALL_EXPR:\n       {\n \ttree fn = get_callee_fndecl (expression);\n@@ -21444,7 +21950,8 @@ value_dependent_expression_p (tree expression)\n     case TEMPLATE_ID_EXPR:\n       /* If a TEMPLATE_ID_EXPR involves a dependent name, it will be\n \t type-dependent.  */\n-      return type_dependent_expression_p (expression);\n+      return type_dependent_expression_p (expression)\n+\t|| variable_concept_p (TREE_OPERAND (expression, 0));\n \n     case CONSTRUCTOR:\n       {\n@@ -21516,7 +22023,9 @@ type_dependent_expression_p (tree expression)\n     return false;\n \n   /* An unresolved name is always dependent.  */\n-  if (identifier_p (expression) || TREE_CODE (expression) == USING_DECL)\n+  if (identifier_p (expression)\n+      || TREE_CODE (expression) == USING_DECL\n+      || TREE_CODE (expression) == WILDCARD_DECL)\n     return true;\n \n   /* Some expression forms are never type-dependent.  */\n@@ -21529,7 +22038,8 @@ type_dependent_expression_p (tree expression)\n       || TREE_CODE (expression) == TYPEID_EXPR\n       || TREE_CODE (expression) == DELETE_EXPR\n       || TREE_CODE (expression) == VEC_DELETE_EXPR\n-      || TREE_CODE (expression) == THROW_EXPR)\n+      || TREE_CODE (expression) == THROW_EXPR\n+      || TREE_CODE (expression) == REQUIRES_EXPR)\n     return false;\n \n   /* The types of these expressions depends only on the type to which\n@@ -21779,6 +22289,22 @@ instantiation_dependent_r (tree *tp, int *walk_subtrees,\n     case BIND_EXPR:\n       return *tp;\n \n+      /* Treat requires-expressions as dependent. */\n+    case REQUIRES_EXPR:\n+      return *tp;\n+\n+    case CALL_EXPR:\n+      /* Treat calls to function concepts as dependent. */\n+      if (function_concept_check_p (*tp))\n+        return *tp;\n+      break;\n+\n+    case TEMPLATE_ID_EXPR:\n+      /* And variable concepts.  */\n+      if (variable_concept_p (TREE_OPERAND (*tp, 0)))\n+\treturn *tp;\n+      break;\n+\n     default:\n       break;\n     }\n@@ -22379,6 +22905,20 @@ listify_autos (tree type, tree auto_node)\n \n tree\n do_auto_deduction (tree type, tree init, tree auto_node)\n+{\n+  return do_auto_deduction (type, init, auto_node,\n+                            tf_warning_or_error,\n+                            adc_unspecified);\n+}\n+\n+/* Replace occurrences of 'auto' in TYPE with the appropriate type deduced\n+   from INIT.  AUTO_NODE is the TEMPLATE_TYPE_PARM used for 'auto' in TYPE.\n+   The CONTEXT determines the context in which auto deduction is performed\n+   and is used to control error diagnostics.  */\n+\n+tree\n+do_auto_deduction (tree type, tree init, tree auto_node,\n+                   tsubst_flags_t complain, auto_deduction_context context)\n {\n   tree targs;\n \n@@ -22402,11 +22942,14 @@ do_auto_deduction (tree type, tree init, tree auto_node)\n \tinit = CONSTRUCTOR_ELT (init, 0)->value;\n       else\n \t{\n-\t  if (permerror (input_location, \"direct-list-initialization of \"\n-\t\t\t \"%<auto%> requires exactly one element\"))\n-\t    inform (input_location,\n-\t\t    \"for deduction to %<std::initializer_list%>, use copy-\"\n-\t\t    \"list-initialization (i.e. add %<=%> before the %<{%>)\");\n+          if (complain & tf_warning_or_error)\n+            {\n+\t      if (permerror (input_location, \"direct-list-initialization of \"\n+\t\t\t     \"%<auto%> requires exactly one element\"))\n+\t        inform (input_location,\n+\t\t        \"for deduction to %<std::initializer_list%>, use copy-\"\n+\t\t        \"list-initialization (i.e. add %<=%> before the %<{%>)\");\n+            }\n \t  type = listify_autos (type, auto_node);\n \t}\n     }\n@@ -22422,7 +22965,8 @@ do_auto_deduction (tree type, tree init, tree auto_node)\n \t= finish_decltype_type (init, id, tf_warning_or_error);\n       if (type != auto_node)\n \t{\n-\t  error (\"%qT as type rather than plain %<decltype(auto)%>\", type);\n+          if (complain & tf_error)\n+\t    error (\"%qT as type rather than plain %<decltype(auto)%>\", type);\n \t  return error_mark_node;\n \t}\n     }\n@@ -22442,7 +22986,8 @@ do_auto_deduction (tree type, tree init, tree auto_node)\n \t  if (processing_template_decl)\n \t    /* Try again at instantiation time.  */\n \t    return type;\n-\t  if (type && type != error_mark_node)\n+\t  if (type && type != error_mark_node\n+\t      && (complain & tf_error))\n \t    /* If type is error_mark_node a diagnostic must have been\n \t       emitted by now.  Also, having a mention to '<type error>'\n \t       in the diagnostic is not really useful to the user.  */\n@@ -22474,11 +23019,45 @@ do_auto_deduction (tree type, tree init, tree auto_node)\n \t       auto_node, TREE_TYPE (auto_node), TREE_VEC_ELT (targs, 0));\n       return error_mark_node;\n     }\n-  TREE_TYPE (auto_node) = TREE_VEC_ELT (targs, 0);\n+  if (context != adc_requirement)\n+    TREE_TYPE (auto_node) = TREE_VEC_ELT (targs, 0);\n+\n+  /* Check any placeholder constraints against the deduced type. */\n+  if (flag_concepts && !processing_template_decl)\n+    if (tree constr = PLACEHOLDER_TYPE_CONSTRAINTS (auto_node))\n+      {\n+        /* Use the deduced type to check the associated constraints. */\n+        if (!constraints_satisfied_p (constr, targs))\n+          {\n+            if (complain & tf_warning_or_error)\n+              {\n+                switch (context)\n+                  {\n+                  case adc_unspecified:\n+                    error(\"placeholder constraints not satisfied\");\n+                    break;\n+                  case adc_variable_type:\n+                    error (\"deduced initializer does not satisfy \"\n+                           \"placeholder constraints\");\n+                    break;\n+                  case adc_return_type:\n+                    error (\"deduced return type does not satisfy \"\n+                           \"placeholder constraints\");\n+                    break;\n+                  case adc_requirement:\n+                    error (\"deduced expression type does not saatisy \"\n+                           \"placeholder constraints\");\n+                    break;\n+                  }\n+                diagnose_constraints (input_location, constr, targs);\n+              }\n+            return error_mark_node;\n+          }\n+      }\n \n   if (processing_template_decl)\n     targs = add_to_template_args (current_template_args (), targs);\n-  return tsubst (type, targs, tf_warning_or_error, NULL_TREE);\n+  return tsubst (type, targs, complain, NULL_TREE);\n }\n \n /* Substitutes LATE_RETURN_TYPE for 'auto' in TYPE and returns the\n@@ -22716,6 +23295,108 @@ convert_generic_types_to_packs (tree parm, int start_idx, int end_idx)\n   return tsubst (parm, replacement, tf_none, NULL_TREE);\n }\n \n+/* Entries in the decl_constraint hash table. */\n+struct GTY((for_user)) constr_entry\n+{\n+  tree decl;\n+  tree ci;\n+};\n+\n+/* Hashing function and equality for constraint entries. */\n+struct constr_hasher : ggc_ptr_hash<constr_entry>\n+{\n+  static hashval_t hash (constr_entry *e)\n+  {\n+    return (hashval_t)DECL_UID (e->decl);\n+  }\n+\n+  static bool equal (constr_entry *e1, constr_entry *e2)\n+  {\n+    return e1->decl == e2->decl;\n+  }\n+};\n+\n+/* A mapping from declarations to constraint information. Note that\n+   both templates and their underlying declarations are mapped to the\n+   same constraint information.\n+\n+   FIXME: This is defined in pt.c because garbage collection\n+   code is not being generated for constraint.cc. */\n+\n+static GTY (()) hash_table<constr_hasher> *decl_constraints;\n+\n+/* Returns true iff cinfo contains a valid set of constraints.\n+   This is the case when the associated requirements have been\n+   successfully decomposed into lists of atomic constraints.\n+   That is, when the saved assumptions are not error_mark_node.  */\n+\n+bool\n+valid_constraints_p (tree cinfo)\n+{\n+  gcc_assert (cinfo);\n+  return CI_ASSUMPTIONS (cinfo) != error_mark_node;\n+}\n+\n+/* Returns the template constraints of declaration T. If T is not\n+   constrained, return NULL_TREE. Note that T must be non-null. */\n+\n+tree\n+get_constraints (tree t)\n+{\n+  gcc_assert (DECL_P (t));\n+  if (TREE_CODE (t) == TEMPLATE_DECL)\n+    t = DECL_TEMPLATE_RESULT (t);\n+  constr_entry elt = { t, NULL_TREE };\n+  constr_entry* found = decl_constraints->find (&elt);\n+  if (found)\n+    return found->ci;\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* Associate the given constraint information CI with the declaration\n+   T. If T is a template, then the constraints are associated with\n+   its underlying declaration. Don't build associations if CI is\n+   NULL_TREE.  */\n+\n+void\n+set_constraints (tree t, tree ci)\n+{\n+  if (!ci)\n+    return;\n+  gcc_assert (t);\n+  if (TREE_CODE (t) == TEMPLATE_DECL)\n+    t = DECL_TEMPLATE_RESULT (t);\n+  gcc_assert (!get_constraints (t));\n+  constr_entry elt = {t, ci};\n+  constr_entry** slot = decl_constraints->find_slot (&elt, INSERT);\n+  constr_entry* entry = ggc_alloc<constr_entry> ();\n+  *entry = elt;\n+  *slot = entry;\n+}\n+\n+/* Remove the associated constraints of the declaration T.  */\n+\n+void\n+remove_constraints (tree t)\n+{\n+  gcc_assert (DECL_P (t));\n+  if (TREE_CODE (t) == TEMPLATE_DECL)\n+    t = DECL_TEMPLATE_RESULT (t);\n+\n+  constr_entry elt = {t, NULL_TREE};\n+  constr_entry** slot = decl_constraints->find_slot (&elt, NO_INSERT);\n+  if (slot)\n+    decl_constraints->clear_slot (slot);\n+}\n+\n+/* Set up the hash table for constraint association. */\n+\n+void\n+init_constraint_processing (void)\n+{\n+  decl_constraints = hash_table<constr_hasher>::create_ggc(37);\n+}\n \n /* Set up the hash tables for template instantiations.  */\n "}, {"sha": "b0281df19b91ddf3fa464e9871bf3f92f3db7f4a", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -253,6 +253,19 @@ cxx_print_xnode (FILE *file, tree node, int indent)\n \t  fprintf (file, \"pending_template\");\n \t}\n       break;\n+    case CONSTRAINT_INFO:\n+      {\n+        tree_constraint_info *cinfo = (tree_constraint_info *)node;\n+        if (cinfo->template_reqs)\n+          print_node (file, \"template_reqs\", cinfo->template_reqs, indent+4);\n+        if (cinfo->declarator_reqs)\n+          print_node (file, \"declarator_reqs\", cinfo->declarator_reqs,\n+\t\t      indent+4);\n+        print_node (file, \"associated_constr\",\n+                          cinfo->associated_constr, indent+4);\n+        print_node_brief (file, \"assumptions\", cinfo->assumptions, indent+4);\n+        break;\n+      }\n     case ARGUMENT_PACK_SELECT:\n       print_node (file, \"pack\", ARGUMENT_PACK_SELECT_FROM_PACK (node),\n \t\t  indent+4);"}, {"sha": "90cd2438b366a94d5d5be6e91bb76f103d668c72", "filename": "gcc/cp/search.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -1203,6 +1203,12 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type,\n     }\n \n   type = complete_type (type);\n+\n+  /* Make sure we're looking for a member of the current instantiation in the\n+     right partial specialization.  */\n+  if (flag_concepts && dependent_type_p (type))\n+    type = currently_open_class (type);\n+\n   if (!basetype_path)\n     basetype_path = TYPE_BINFO (type);\n "}, {"sha": "7bbae06f71791e806684af70f8bf8e3b06acf808", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 89, "deletions": 1, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -2710,10 +2710,18 @@ finish_template_template_parm (tree aggr, tree identifier)\n {\n   tree decl = build_decl (input_location,\n \t\t\t  TYPE_DECL, identifier, NULL_TREE);\n+\n   tree tmpl = build_lang_decl (TEMPLATE_DECL, identifier, NULL_TREE);\n   DECL_TEMPLATE_PARMS (tmpl) = current_template_parms;\n   DECL_TEMPLATE_RESULT (tmpl) = decl;\n   DECL_ARTIFICIAL (decl) = 1;\n+\n+  // Associate the constraints with the underlying declaration,\n+  // not the template.\n+  tree reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);\n+  tree constr = build_constraints (reqs, NULL_TREE);\n+  set_constraints (decl, constr);\n+\n   end_template_decl ();\n \n   gcc_assert (DECL_TEMPLATE_PARMS (tmpl));\n@@ -2977,6 +2985,72 @@ finish_template_decl (tree parms)\n     end_specialization ();\n }\n \n+// Returns the template type of the class scope being entered. If we're\n+// entering a constrained class scope. TYPE is the class template\n+// scope being entered and we may need to match the intended type with\n+// a constrained specialization. For example:\n+//\n+//    template<Object T>\n+//      struct S { void f(); }; #1\n+//\n+//    template<Object T>\n+//      void S<T>::f() { }      #2\n+//\n+// We check, in #2, that S<T> refers precisely to the type declared by\n+// #1 (i.e., that the constraints match). Note that the following should\n+// be an error since there is no specialization of S<T> that is\n+// unconstrained, but this is not diagnosed here.\n+//\n+//    template<typename T>\n+//      void S<T>::f() { }\n+//\n+// We cannot diagnose this problem here since this function also matches\n+// qualified template names that are not part of a definition. For example:\n+//\n+//    template<Integral T, Floating_point U>\n+//      typename pair<T, U>::first_type void f(T, U);\n+//\n+// Here, it is unlikely that there is a partial specialization of\n+// pair constrained for for Integral and Floating_point arguments.\n+//\n+// The general rule is: if a constrained specialization with matching\n+// constraints is found return that type. Also note that if TYPE is not a\n+// class-type (e.g. a typename type), then no fixup is needed.\n+\n+static tree\n+fixup_template_type (tree type)\n+{\n+  // Find the template parameter list at the a depth appropriate to\n+  // the scope we're trying to enter.\n+  tree parms = current_template_parms;\n+  int depth = template_class_depth (type);\n+  for (int n = processing_template_decl; n > depth && parms; --n)\n+    parms = TREE_CHAIN (parms);\n+  if (!parms)\n+    return type;\n+  tree cur_reqs = TEMPLATE_PARMS_CONSTRAINTS (parms);\n+  tree cur_constr = build_constraints (cur_reqs, NULL_TREE);\n+\n+  // Search for a specialization whose type and constraints match.\n+  tree tmpl = CLASSTYPE_TI_TEMPLATE (type);\n+  tree specs = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n+  while (specs)\n+    {\n+      tree spec_constr = get_constraints (TREE_VALUE (specs));\n+\n+      // If the type and constraints match a specialization, then we\n+      // are entering that type.\n+      if (same_type_p (type, TREE_TYPE (specs))\n+\t  && equivalent_constraints (cur_constr, spec_constr))\n+        return TREE_TYPE (specs);\n+      specs = TREE_CHAIN (specs);\n+    }\n+\n+  // If no specialization matches, then must return the type\n+  // previously found.\n+  return type;\n+}\n+\n /* Finish processing a template-id (which names a type) of the form\n    NAME < ARGS >.  Return the TYPE_DECL for the type named by the\n    template-id.  If ENTERING_SCOPE is nonzero we are about to enter\n@@ -2990,6 +3064,16 @@ finish_template_type (tree name, tree args, int entering_scope)\n   type = lookup_template_class (name, args,\n \t\t\t\tNULL_TREE, NULL_TREE, entering_scope,\n \t\t\t\ttf_warning_or_error | tf_user);\n+\n+  /* If we might be entering the scope of a partial specialization,\n+     find the one with the right constraints.  */\n+  if (flag_concepts\n+      && entering_scope\n+      && CLASS_TYPE_P (type)\n+      && dependent_type_p (type)\n+      && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (type)))\n+    type = fixup_template_type (type);\n+\n   if (type == error_mark_node)\n     return type;\n   else if (CLASS_TYPE_P (type) && !alias_type_or_template_p (type))\n@@ -7442,6 +7526,9 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n     case CPTK_IS_POLYMORPHIC:\n       return (CLASS_TYPE_P (type1) && TYPE_POLYMORPHIC_P (type1));\n \n+    case CPTK_IS_SAME_AS:\n+      return same_type_p (type1, type2);\n+\n     case CPTK_IS_STD_LAYOUT:\n       return (std_layout_type_p (type1));\n \n@@ -7549,8 +7636,9 @@ finish_trait_expr (cp_trait_kind kind, tree type1, tree type2)\n     case CPTK_IS_CLASS:\n     case CPTK_IS_ENUM:\n     case CPTK_IS_UNION:\n+    case CPTK_IS_SAME_AS:\n       break;\n-    \n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "987ebe8e2aaadf74c3cccdf7d83ee87bad5d9915", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -2955,16 +2955,19 @@ cp_tree_equal (tree t1, tree t2)\n \t up for expressions that involve 'this' in a member function\n \t template.  */\n \n-      if (comparing_specializations)\n+      if (comparing_specializations && !CONSTRAINT_VAR_P (t1))\n \t/* When comparing hash table entries, only an exact match is\n \t   good enough; we don't want to replace 'this' with the\n-\t   version from another function.  */\n+\t   version from another function.  But be more flexible\n+\t   with local parameters in a requires-expression.  */\n \treturn false;\n \n       if (same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n \t{\n \t  if (DECL_ARTIFICIAL (t1) ^ DECL_ARTIFICIAL (t2))\n \t    return false;\n+\t  if (CONSTRAINT_VAR_P (t1) ^ CONSTRAINT_VAR_P (t2))\n+\t    return false;\n \t  if (DECL_ARTIFICIAL (t1)\n \t      || (DECL_PARM_LEVEL (t1) == DECL_PARM_LEVEL (t2)\n \t\t  && DECL_PARM_INDEX (t1) == DECL_PARM_INDEX (t2)))\n@@ -3000,6 +3003,10 @@ cp_tree_equal (tree t1, tree t2)\n       return (cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0))\n \t      && cp_tree_equal (TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1)));\n \n+    case CONSTRAINT_INFO:\n+      return cp_tree_equal (CI_ASSOCIATED_CONSTRAINTS (t1),\n+                            CI_ASSOCIATED_CONSTRAINTS (t2));\n+\n     case TREE_VEC:\n       {\n \tunsigned ix;\n@@ -3876,6 +3883,14 @@ cp_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func,\n       *walk_subtrees_p = 0;\n       break;\n  \n+    case REQUIRES_EXPR:\n+      // Only recurse through the nested expression. Do not\n+      // walk the parameter list. Doing so causes false\n+      // positives in the pack expansion checker since the\n+      // requires parameters are introduced as pack expansions.\n+      WALK_SUBTREE (TREE_OPERAND (*tp, 1));\n+      *walk_subtrees_p = 0;\n+      break;\n \n     default:\n       return NULL_TREE;"}, {"sha": "83fd34ca80ab337cc9add5330e9733bc60a6b6c4", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -3474,6 +3474,25 @@ cp_build_function_call_vec (tree function, vec<tree, va_gc> **params,\n \n   if (TREE_CODE (function) == FUNCTION_DECL)\n     {\n+      /* If the function is a non-template member function\n+         or a non-template friend, then we need to check the\n+         constraints.\n+\n+        Note that if overload resolution failed with a single\n+        candidate this function will be used to explicitly diagnose\n+        the failure for the single call expression. The check is\n+        technically redundant since we also would have failed in\n+        add_function_candidate. */\n+      if (flag_concepts\n+          && (complain & tf_error)\n+          && !constraints_satisfied_p (function))\n+        {\n+          error (\"cannot call function %qD\", function);\n+          location_t loc = DECL_SOURCE_LOCATION (function);\n+          diagnose_constraints (loc, function, NULL_TREE);\n+          return error_mark_node;\n+        }\n+\n       if (!mark_used (function, complain) && !(complain & tf_error))\n \treturn error_mark_node;\n       fndecl = function;"}, {"sha": "64d9a6ab0da4d286abc0c66435df8ddcf287560a", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -19280,7 +19280,8 @@ Predefined Macros,cpp,The GNU C Preprocessor}).\n * C++ Attributes::      Variable, function, and type attributes for C++ only.\n * Function Multiversioning::   Declaring multiple function versions.\n * Namespace Association:: Strong using-directives for namespace association.\n-* Type Traits::         Compiler support for type traits\n+* Type Traits::         Compiler support for type traits.\n+* C++ Concepts::        Improved support for generic programming.\n * Java Exceptions::     Tweaking exception handling to work with Java.\n * Deprecated Features:: Things will disappear from G++.\n * Backwards Compatibility:: Compatibilities with earlier definitions of C++.\n@@ -20076,6 +20077,52 @@ an enumeration type ([dcl.enum]).\n \n @end table\n \n+\n+@node C++ Concepts\n+@section C++ Concepts\n+\n+C++ concepts provide much-improved support for generic programming. In\n+particular, they allow the specification of constraints on template arguments.\n+The constraints are used to extend the usual overloading and partial\n+specialization capabilities of the language, allowing generic data structures\n+and algorithms to be ``refined'' based on their properties rather than their\n+type names.\n+\n+The following keywords are reserved for concepts.\n+\n+@table @code\n+@item assumes\n+States an expression as an assumption, and if possible, verifies that the\n+assumption is valid. For example, @code{assume(n > 0)}.\n+\n+@item axiom\n+Introduces an axiom definition. Axioms introduce requirements on values.\n+\n+@item forall\n+Introduces a universally quantified object in an axiom. For example,\n+@code{forall (int n) n + 0 == n}).\n+\n+@item concept\n+Introduces a concept definition. Concepts are sets of syntactic and semantic\n+requirements on types and their values.\n+\n+@item requires\n+Introduces constraints on template arguments or requirements for a member\n+function of a class template.\n+\n+@end table\n+\n+The front end also exposes a number of internal mechanism that can be used\n+to simplify the writing of type traits. Note that some of these traits are\n+likely to be removed in the future.\n+\n+@table @code\n+@item __is_same (type1, type2)\n+A binary type trait: true whenever the type arguments are the same.\n+\n+@end table\n+\n+\n @node Java Exceptions\n @section Java Exceptions\n "}, {"sha": "03b3ceae92810677aac0cd72b595bebe5f8d2abe", "filename": "gcc/testsuite/g++.dg/concepts/alias1.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  requires C<T>()\n+    using X = T*;\n+\n+struct S { };\n+\n+int main()\n+{\n+  X<S> x1;\n+}"}, {"sha": "d81188ed43547f93eeffb47f7b1a84afaa15e167", "filename": "gcc/testsuite/g++.dg/concepts/alias2.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<C T> using X = T*;\n+\n+struct S { };\n+\n+int main()\n+{\n+  X<S> x1;\n+}"}, {"sha": "e6ab66976a16d690505dfb6c170e4b9a8684308d", "filename": "gcc/testsuite/g++.dg/concepts/alias3.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias3.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  requires C<T>()\n+    using X = T*;\n+\n+int main()\n+{\n+  X<int> x1; // { dg-error \"constraint|invalid\" }\n+}"}, {"sha": "4227a44c042be903d64d8877abd542e1c88a26b3", "filename": "gcc/testsuite/g++.dg/concepts/alias4.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Falias4.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,19 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  requires C<T>()\n+    using X = T*;\n+\n+// BUG: Alias templates are expanded at the point of use, regardless\n+// of whether or not they are dependent. This causes T* to be substituted\n+// without acutally checking the constraints.\n+template<typename T>\n+  using Y = X<T>;\n+\n+int main()\n+{\n+  Y<int> y1; // { dg-error \"\" \"\" { xfail *-*-* } }\n+}"}, {"sha": "ea74a54da6c1b0627310d129ec2383da4ee2a1d2", "filename": "gcc/testsuite/g++.dg/concepts/class.C", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool Class() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool Union() { return __is_union(T); }\n+\n+\n+// Check ordering of specializations\n+template<typename T>\n+  concept bool One() { return sizeof(T) >= 4; }\n+\n+template<typename T>\n+  concept bool Two() { return One<T>() && sizeof(T) >= 8; }\n+\n+// Check non-overlapping specializations\n+template<typename T>\n+  struct S1 { static const int value = 0; };\n+\n+template<Class T>\n+  struct S1<T> { static const int value = 1; };\n+\n+template<Union T>\n+  struct S1<T> { static const int value = 2; };\n+\n+struct S { };\n+union U { };\n+\n+static_assert(S1<int>::value == 0, \"\");\n+static_assert(S1<S>::value == 1, \"\");\n+static_assert(S1<U>::value == 2, \"\");\n+\n+\n+// Check ordering of partial specializaitons\n+template<typename T>\n+  struct S2 { static const int value = 0;  };\n+\n+template<One T>\n+  struct S2<T> { static const int value = 1; };\n+\n+template<Two T>\n+  struct S2<T> { static const int value = 2; };\n+\n+struct one_type { char x[4]; };\n+struct two_type { char x[8]; };\n+\n+static_assert(S2<char>::value == 0, \"\");\n+static_assert(S2<one_type>::value == 1, \"\");\n+static_assert(S2<two_type>::value == 2, \"\");\n+\n+int main() { }"}, {"sha": "b213cb58b7e300864b0d84da95e95bdd98b96534", "filename": "gcc/testsuite/g++.dg/concepts/class1.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,14 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  requires C<T>()\n+    struct S { };\n+\n+struct X { };\n+\n+S<X> sx;\n+\n+int main() { }"}, {"sha": "2c3ea4483abc0600aabc27d8d82c4de1e070d2ad", "filename": "gcc/testsuite/g++.dg/concepts/class2.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,14 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  requires C<T>()\n+    struct S { };\n+\n+struct X { };\n+\n+S<int> sx; // { dg-error \"constraint|invalid\" }\n+\n+int main() { }"}, {"sha": "e3a1d2a949b67da8fac572e5f612750a1861fa4d", "filename": "gcc/testsuite/g++.dg/concepts/class3.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass3.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,14 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+// Check class redeclaration with alternative spellings.\n+template<typename T> requires C<T>() struct S;\n+template<C T> struct S { };\n+\n+struct X { };\n+\n+// S<X> sx;\n+\n+int main() { }"}, {"sha": "7ba825085523b496a52bba432772f6a4f427d152", "filename": "gcc/testsuite/g++.dg/concepts/class4.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass4.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,21 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool Class() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool Union() { return __is_union(T); }\n+\n+// Check non-overlapping specializations\n+template<typename T> struct S1 { static const int value = 0; };\n+template<Class T> struct S1<T> { static const int value = 1; };\n+template<Union T> struct S1<T> { static const int value = 2; };\n+\n+struct S { };\n+union U { };\n+\n+static_assert(S1<int>::value == 0, \"\");\n+static_assert(S1<S>::value == 1, \"\");\n+static_assert(S1<U>::value == 2, \"\");\n+\n+int main() { }"}, {"sha": "903bf2499558916fc1114e5e9012690f2b7414f6", "filename": "gcc/testsuite/g++.dg/concepts/class5.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass5.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,26 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool One() { return sizeof(T) >= 4; }\n+\n+template<typename T>\n+  concept bool Two() { return One<T>() && sizeof(T) >= 8; }\n+\n+// Check ordering of partial specializaitons\n+template<typename T>\n+  struct S2 { static const int value = 0;  };\n+\n+template<One T>\n+  struct S2<T> { static const int value = 1; };\n+\n+template<Two T>\n+  struct S2<T> { static const int value = 2; };\n+\n+struct one_type { char x[4]; };\n+struct two_type { char x[8]; };\n+\n+static_assert(S2<char>::value == 0, \"\");\n+static_assert(S2<one_type>::value == 1, \"\");\n+static_assert(S2<two_type>::value == 2, \"\");\n+\n+int main() { }"}, {"sha": "fe6b42d5557e680a9d7bab941c93347e88d4577d", "filename": "gcc/testsuite/g++.dg/concepts/class6.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass6.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool One() { return sizeof(T) >= 4; }\n+\n+template<typename T>\n+  concept bool Two() { return One<T>() && sizeof(T) >= 8; }\n+\n+// Check that there is no ecsacpe hatch\n+template<Two T> struct S4 { };\n+template<One T> struct S4<T> { }; // { dg-error \"does not specialize\" }\n+\n+struct one_type { char x[4]; };\n+\n+// Constraints are checked even when decls are not instantiatied.\n+S4<one_type>* x4b; // { dg-error \"constraint|invalid\" }\n+\n+int main() { }"}, {"sha": "fd21c43a037b208f09cefe781ac00a101ca9dc85", "filename": "gcc/testsuite/g++.dg/concepts/constrained-parm.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fconstrained-parm.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fconstrained-parm.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fconstrained-parm.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<const C T> struct S1 { };    // { dg-error \"cv-qualified\" }\n+template<volatile C T> struct S2 { }; // { dg-error \"cv-qualified\" }\n+template<C* T> struct S3 { };         // { dg-error \"invalid\" }\n+template<C const* T> struct S3a { };  // { dg-error \"invalid\" }\n+template<C* const T> struct S3b { };  // { dg-error \"invalid\" }\n+template<C& T> struct S4 { };         // { dg-error \"invalid\" }\n+template<C[3] T> struct S4 { };       // { dg-error \"invalid|expected\" }\n+template<C(*T)()> struct S5 { };      // { dg-error \"invalid\" }"}, {"sha": "67b56f962d0f7b296b6480a22d43faaf3988b286", "filename": "gcc/testsuite/g++.dg/concepts/decl-diagnose.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdecl-diagnose.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdecl-diagnose.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdecl-diagnose.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,32 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+typedef concept int CINT; // { dg-error \"'concept' cannot appear in a typedef declaration\" }\n+\n+void f(concept int); // { dg-error \"a parameter cannot be declared 'concept'\" }\n+\n+template<typename T>\n+concept int f2() { return 0; } // { dg-error \"return type\" }\n+concept bool f3(); // { dg-error \"no definition\" }\n+\n+struct X\n+{\n+  template<typename T>\n+  concept int f4() { return 0; } // { dg-error \"return type|member function\" }\n+  concept bool f5() { return true; } // { dg-error \"member function\" }\n+  template<typename T>\n+  static concept bool f6() { return true; } // { dg-error \"a concept cannot be a member function\" }\n+  static concept bool x; // { dg-error \"declared 'concept'\" }\n+  concept int x2; // { dg-error \"declared 'concept'\" }\n+  concept ~X(); // { dg-error \"a destructor cannot be 'concept'\" }\n+  concept X(); // { dg-error \"a constructor cannot be 'concept'\" }\n+};\n+\n+concept bool X2; // { dg-error \"non-template variable\" }\n+\n+template<typename T>\n+  concept bool X3; // { dg-error \"has no initializer\" }\n+\n+struct S {\n+  template<typename T>\n+    static concept bool C1 = true; // { dg-error \"static data member\" }\n+};"}, {"sha": "6ff3be94ba98b34a5b5fd38d12589377ca0482d7", "filename": "gcc/testsuite/g++.dg/concepts/deduction-constraint1.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdeduction-constraint1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdeduction-constraint1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdeduction-constraint1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/67007\n+// { dg-options -std=c++1z }\n+\n+template <class U>\n+concept bool A =\n+  requires (U u) { u; };\n+\n+template <class T>\n+concept bool B =\n+  requires (T t) { { t } -> A; };\n+\n+void foo(B);"}, {"sha": "f67fa0beacb0c9d8bad844e770de1cdd0b43a279", "filename": "gcc/testsuite/g++.dg/concepts/disjunction1.C", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdisjunction1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdisjunction1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdisjunction1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,59 @@\n+// PR c++/66962\n+// { dg-options -std=c++1z }\n+\n+template <typename> struct remove_cv;\n+template <typename> struct is_reference;\n+template <typename> void declval();\n+template <typename> struct is_constructible;\n+template <typename> struct is_nothrow_constructible;\n+template <typename _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n+template <typename> struct Trans_NS_extension_apply_list;\n+template <typename T> using _t = typename T::type;\n+template <class> void ImplicitlyConvertibleTo();\n+template <class> void Assignable();\n+template <class T, class... Args> int ConstructibleObject = requires { T{}; };\n+template <class T, class... Args>\n+concept bool BindableReference =\n+    is_reference<T>::value &&is_constructible<T>::value;\n+template <class T, class... Args> concept bool Constructible() {\n+  return ConstructibleObject<T> || BindableReference<T, Args...>;\n+}\n+template <class T> concept bool DefaultConstructible() {\n+  return Constructible<T>() && requires { new T[0]; };\n+}\n+template <class T> concept bool MoveConstructible() {\n+  return Constructible<T>() && ImplicitlyConvertibleTo<T>;\n+}\n+template <class T> concept bool Movable() {\n+  return MoveConstructible<T>() && Assignable<T &&>;\n+}\n+template <class, class> int Swappable_ = requires { 0; };\n+template <class T, class U> int Swappable();\n+template <class T> concept bool Dereferencable = requires{{0}};\n+template <Dereferencable R> using RvalueReferenceType = decltype(0);\n+template <class T> int IsValueType;\n+template <class> struct value_type;\n+template <class T>\n+requires IsValueType<\n+    _t<value_type<remove_cv_t<T>>>> using ValueType =\n+    _t<value_type<remove_cv_t<T>>>;\n+template <class I> concept bool Readable() {\n+  return Movable<I>() && DefaultConstructible<I>() &&\n+         Dereferencable<const I> && requires{{0}};\n+}\n+template <class Out, class T> concept bool MoveWritable() {\n+  return Movable<Out>() && DefaultConstructible<Out>() &&\n+         Dereferencable<Out>;\n+}\n+template <class In, class Out> concept bool IndirectlyMovable() {\n+  return Readable<In>() && Movable<ValueType<In>>() &&\n+         Constructible<ValueType<In>>() &&\n+         MoveWritable<Out, RvalueReferenceType<In>>() &&\n+         MoveWritable<Out, ValueType<In>>();\n+}\n+IndirectlyMovable { In, Out }\n+int is_nothrow_indirectly_movable_v =\n+    is_nothrow_constructible<ValueType<In>>::value;\n+template <Readable R1, Readable R2>\n+    requires IndirectlyMovable<R1, R2>() &&\n+    IndirectlyMovable<R2, R1>() void iter_swap2();"}, {"sha": "7f857fe4ecc0048bd48595b3594903c27b724f49", "filename": "gcc/testsuite/g++.dg/concepts/dr1430.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdr1430.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdr1430.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdr1430.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,34 @@\n+// PR c++/66092\n+// { dg-options \"-std=c++1z\" }\n+\n+#include <type_traits>\n+\n+template <typename T, typename U, typename... Args>\n+requires (sizeof...(Args) == 0)\n+  constexpr decltype(auto) check()\n+  {\n+    return std::integral_constant<bool, __is_same_as(T, U)>();\n+  }\n+\n+template <typename T, typename U, typename... Args>\n+requires (sizeof...(Args) > 0)\n+  constexpr decltype(auto) check()\n+  {\n+    return std::integral_constant<bool, __is_same_as(T, U)\n+        && decltype(check<U, Args...>())::value>();\n+  }\n+\n+template <typename T, typename U, typename... Args>\n+  concept bool Same()\n+  {\n+    return decltype(check<T, U, Args...>())::value;\n+  }\n+\n+template <typename... Args>\n+requires Same<Args...>()\t// { dg-error \"concept\" }\n+  void foo( Args... args ) {}\n+\n+int main()\n+{\n+  foo(1, 2, 3);\t\t\t// { dg-error \"\" }\n+}"}, {"sha": "c2ac7410f010570bfed4324b8550adbad5c12c9e", "filename": "gcc/testsuite/g++.dg/concepts/equiv.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fequiv.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fequiv.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fequiv.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,34 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+// Check equivalence of short- and longhand declarations.\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool D() { return __is_empty(T); }\n+\n+struct X { } x;\n+\n+void f1(C x);\n+template<C T> void f2(T x);\n+void f3(C x);\n+template<C T> void f4(T x) requires D<T>();\n+template<C T> void f5(T x) requires D<T>();\n+template<C T> void f6(T x) requires D<T>();\n+\n+int main() {\n+  f1(x);\n+  f2(x);\n+  f3(x);\n+  f4(x);\n+  f5(x);\n+  f6(x);\n+}\n+\n+template<typename T> requires C<T>() void f1(T x) { }\n+template<typename T> requires C<T>() void f2(T x) { }\n+template<C T> void f3(T x) { }\n+template<typename T> requires C<T>() void f4(T x) requires D<T>() { }\n+template<typename T> requires C<T>() and D<T>() void f5(T x) { }\n+template<typename T> void f6(T x) requires C<T>() and D<T>() { }"}, {"sha": "675fe2105f19cb7c3baf5f6ea98c5e558811201a", "filename": "gcc/testsuite/g++.dg/concepts/equiv2.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fequiv2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fequiv2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fequiv2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++1z\" }\n+\n+\n+// template<typename T>\n+// concept bool C() { return true; }\n+\n+\n+template<typename T>\n+concept bool C = true;\n+\n+void f1(C, C);\n+void f2(C, C);\n+void f3(C, C);\n+\n+int main() {\n+  f1(0, 0);\n+  f2(0, 0);\n+  f3(0, 0);\n+}\n+\n+void f1(C, C) { }\n+\n+template<C T>\n+void f2(T, T) { }\n+\n+template<typename T>\n+  requires C<T>\n+void f3(T, T) { }"}, {"sha": "3079ca50f6477d5266dfb52495af581b93e0b4d2", "filename": "gcc/testsuite/g++.dg/concepts/explicit-inst1.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-inst1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-inst1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-inst1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,21 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool D() { return C<T>() && __is_empty(T); }\n+\n+struct X { };\n+struct Y { int n; };\n+\n+template<typename T> void g(T) { } // #1\n+template<C T> void g(T) { } // #2\n+template<D T> void g(T) { } // #3\n+\n+// FIXME: How do I test that these generate the right symbols?\n+template void g(int); // Instantiate #1\n+template void g(X); // Instantitae #3\n+template void g(Y); // Instantiate #2\n+\n+int main() { }"}, {"sha": "5e75f4ff6313343d2a1f06dd6583322beb33c236", "filename": "gcc/testsuite/g++.dg/concepts/explicit-inst2.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-inst2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-inst2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-inst2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,24 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool D() { return C<T>() && __is_empty(T); }\n+\n+struct X { };\n+struct Y { int n; };\n+\n+template<typename T> struct S  { void f1() { } };  // #1\n+template<C T> struct S<T> { void f2() { } };      // #2\n+template<D T> struct S<T> { void f3() { } };      // #3\n+\n+template struct S<int>; // Instantiate #1\n+template struct S<X>; // Instantiate #2\n+template struct S<Y>; // Instantiate #2\n+\n+int main() {\n+  S<int> i; i.f1();\n+  S<X> x; x.f3();\n+  S<Y> y; y.f2();\n+}"}, {"sha": "a471657a750ecb625e1740df305f096a1681002a", "filename": "gcc/testsuite/g++.dg/concepts/explicit-inst3.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-inst3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-inst3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-inst3.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,27 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool D() { return C<T>() && __is_empty(T); }\n+\n+struct X { };\n+struct Y { int n; };\n+\n+template<typename T>\n+  struct S {\n+    void f() { }                 // #1\n+    void f() requires C<T>() { } // #2\n+\n+    void g() requires C<T>() { } // #1\n+    void g() requires D<T>() { } // #2\n+  };\n+\n+template void S<int>::f(); // #1\n+template void S<X>::f(); // #2\n+\n+template void S<X>::g(); // #2\n+template void S<Y>::g(); // #1\n+\n+int main() { }"}, {"sha": "b075c1009e8ef181d02f2934e96427b0f56d0f2d", "filename": "gcc/testsuite/g++.dg/concepts/explicit-inst4.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-inst4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-inst4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-inst4.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool D() { return C<T>() && __is_empty(T); }\n+\n+template<typename T>\n+  struct S {\n+    void g() requires C<T>() { } // #1\n+    void g() requires D<T>() { } // #2\n+  };\n+\n+template void S<int>::g(); // { dg-error \"match\" }\n+\n+int main() { }"}, {"sha": "6316410b950b399a928fb01654f8010f6f5e94fb", "filename": "gcc/testsuite/g++.dg/concepts/explicit-spec1.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++1z\" }\n+\n+#include <cassert>\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool D() { return C<T>() && __is_empty(T); }\n+\n+struct X { } x;\n+struct Y { int n; } y;\n+\n+template<typename T> void g(T) { } // #1\n+template<C T> void g(T) { }        // #2\n+template<D T> void g(T) { }     // #3\n+\n+int called;\n+\n+template<> void g(int) { called = 1; } // Specialization of #1\n+template<> void g<X>(X) { called = 2; } // Specialization of #3\n+template<> void g(Y) { called = 3; } // Specialization of #2\n+\n+int main() {\n+  g(0);\n+  assert(called == 1);\n+  g(x);\n+  assert(called == 2);\n+  g(y);\n+  assert(called == 3);\n+}"}, {"sha": "4f196243717b2351e7f30cadd9e170e2234fef71", "filename": "gcc/testsuite/g++.dg/concepts/explicit-spec2.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+struct X { };\n+\n+template<C T> struct S;\n+template<> struct S<X> { void f() { } };\n+\n+int main() {\n+  S<X> x; x.f();\n+}"}, {"sha": "29546b3b37c4e3dd44940e2070d785df3740cf06", "filename": "gcc/testsuite/g++.dg/concepts/explicit-spec3.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec3.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<C T> struct S;\n+\n+struct X { };\n+\n+// Not a valid explicit specialization, int does not satisfy C.\n+template<> struct S<int> { }; // { dg-error \"constraint\" }\n+\n+int main() { }"}, {"sha": "e9aacd51bbbac403a8e0b443458bb0e5c50f57b8", "filename": "gcc/testsuite/g++.dg/concepts/explicit-spec4.C", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec4.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,51 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++1z\" }\n+\n+#include <cassert>\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool D() { return C<T>() && __is_empty(T); }\n+\n+struct X { } x;\n+struct Y { int n; } y;\n+\n+int called = 0;\n+\n+template<typename T>\n+  struct S {\n+    void f() { called = 0; }                 // #1\n+    void f() requires C<T>() { called = 0; } // #2\n+\n+    void g() requires C<T>() { } // #1\n+    void g() requires D<T>() { } // #2\n+  };\n+\n+template<> void S<int>::f() { called = 1; } // Spec of #1\n+template<> void S<X>::f() { called = 2; } // Spec of #2\n+\n+template<> void S<X>::g() { called = 3; } // Spec of #2\n+template<> void S<Y>::g() { called = 4; } // Spec of #1\n+\n+int main() {\n+  S<double> sd;\n+  S<int> si;\n+  S<X> sx;\n+  S<Y> sy;\n+\n+  sd.f();\n+  assert(called == 0);\n+  si.f();\n+  assert(called == 1);\n+  sx.f();\n+  assert(called == 2);\n+  sy.f();\n+  assert(called == 0);\n+\n+  sx.g();\n+  assert(called == 3);\n+  sy.g();\n+  assert(called == 4);\n+}"}, {"sha": "8047278aa77efdedebb1284c9eeb092efde119db", "filename": "gcc/testsuite/g++.dg/concepts/explicit-spec5.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec5.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,21 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+#include <cassert>\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool D() { return C<T>() && __is_empty(T); }\n+\n+struct X { } x;\n+struct Y { int n; } y;\n+\n+int called = 0;\n+\n+template<typename T>\n+  struct S {\n+    void f() requires C<T>();\n+  };\n+\n+template<> void S<int>::f() { called = 1; } // { dg-error \"match\" }"}, {"sha": "3eba9ff7bfd054a604ee550901b7fe2d8c0412ed", "filename": "gcc/testsuite/g++.dg/concepts/explicit-spec6.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexplicit-spec6.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+struct A {\n+    template<class T2> void f1(T, T2); // member template\n+    template<class T2> void f2(T, T2); // member template\n+};\n+\n+template<>\n+template<class X1> void A<int>::f1(int, X1);\n+\n+// Specialization with template-id\n+template<>\n+template<> void A<int>::f2<char>(int, char);\n+\n+// Specialization with deduction\n+template<>\n+template<> void A<int>::f1(int, char);"}, {"sha": "5ae04e43a12eadf69012cfd30dff7f55f16b7dcd", "filename": "gcc/testsuite/g++.dg/concepts/expression.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++1z\" }\n+\n+#include <cassert>\n+#include <iostream>\n+\n+template<typename T>\n+  concept bool C1 = __is_class(T);\n+\n+template<typename T>\n+  concept bool C2() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool C3() { return requires (T a) { ++a; }; }\n+\n+int main() {\n+  if (C1<int>) assert(false);\n+  if (C2<int>()) assert(false);\n+  if (!C3<int>()) assert(false);\n+}"}, {"sha": "40c2034764a9c85c6ffeb9043a7e383c24ec460b", "filename": "gcc/testsuite/g++.dg/concepts/expression2.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,42 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+concept bool C1()\n+{\n+  return requires (T t) { t.f(); };\n+}\n+\n+template<typename T>\n+concept bool C2()\n+{\n+  return requires { typename T::type; };\n+}\n+\n+template<typename T>\n+  requires C1<T>()\n+void f1(T x) { }\n+\n+template<typename T>\n+  requires C2<T>()\n+void f2(T x) { }\n+\n+// Note that these declarations are private and therefore\n+// cannot satisify the constraints.\n+class S\n+{\n+  using type = int;\n+  void f() { }\n+} s;\n+\n+int main()\n+{\n+  f1(s); // { dg-error \"cannot call\" }\n+  f2(s); // { dg-error \"cannot call\" }\n+\n+  // When used in non-SFINAE contexts, make sure that we fail\n+  // the constraint check before emitting the access check\n+  // failures. The context is being presented constistently\n+  // in both cases.\n+  static_assert(C1<S>(), \"\"); // { dg-error \"failed\" }\n+  static_assert(C2<S>(), \"\"); // { dg-error \"failed\" }\n+}"}, {"sha": "eb8406f13b01effa09fa3a11c1eb16f00e0d5de9", "filename": "gcc/testsuite/g++.dg/concepts/expression3.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fexpression3.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,23 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+concept bool C()\n+{\n+  return requires (T& t) { t.~T(); };\n+}\n+\n+class S1\n+{\n+  ~S1() { }\n+};\n+\n+class S2\n+{\n+  ~S2() = delete;\n+};\n+\n+int main()\n+{\n+  static_assert(C<S1>(), \"\"); // { dg-error \"failed\" }\n+  static_assert(C<S2>(), \"\"); // { dg-error \"failed\" }\n+}"}, {"sha": "7bc787559ec851153ed4434dd0e2d3ccde5cd2eb", "filename": "gcc/testsuite/g++.dg/concepts/feature-macro.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffeature-macro.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffeature-macro.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffeature-macro.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,5 @@\n+// { dg-options -std=c++1z }\n+\n+#ifndef __cpp_concepts\n+#error __cpp_concepts not defined\n+#endif"}, {"sha": "385dcbc13cf175ee0deafafc52f90e6150e343fb", "filename": "gcc/testsuite/g++.dg/concepts/fn-concept1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn-concept1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn-concept1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn-concept1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool Tuple() { // { dg-error \"multiple statements\" }\n+    static_assert(T::value, \"\");\n+    return true;\n+  }\n+\n+  void f(Tuple&);"}, {"sha": "092c91c5b84c232f7a658c6d4e4e52f0d3672788", "filename": "gcc/testsuite/g++.dg/concepts/fn-concept2.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn-concept2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn-concept2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn-concept2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,7 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept auto C1() { return 0; } // { dg-error \"deduced return type\" }\n+\n+template<typename T>\n+  concept int C2() { return 0; } // { dg-error \"return type\" }"}, {"sha": "b2bdaf9188520a3bf5d3a0dcf7bcd1f32a832f39", "filename": "gcc/testsuite/g++.dg/concepts/fn1.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,25 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+struct S { } s;\n+\n+template<typename T>\n+  requires C<T>()\n+    void f(T x) { }\n+\n+// Calls are valid when arguments are dependent,\n+template<typename T>\n+  void g(T x) { f(x); }\n+\n+// Calls are checked when arguments are non-dependent.\n+template<typename T>\n+  void h(T x) {\n+    f(s);\n+  }\n+\n+int main() {\n+  f(s);\n+  g(s);\n+}"}, {"sha": "f4cd4c5ce346bf7125552fef0557818087c1148b", "filename": "gcc/testsuite/g++.dg/concepts/fn10.C", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn10.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,92 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++1z\" }\n+\n+// Test that constraint satisfaction checks work even when\n+// processing template declarations.\n+\n+namespace std\n+{\n+\n+struct ostream { };\n+ostream cout;\n+\n+template<typename T>\n+auto begin(T& t) -> decltype(t.begin()) { return t.begin(); }\n+\n+template<typename T>\n+auto begin(T const& t) -> decltype(t.begin()) { return t.begin(); }\n+\n+template<typename T>\n+auto end(T& t) -> decltype(t.end()) { return t.end(); }\n+\n+template<typename T>\n+auto end(T const& t) -> decltype(t.end()) { return t.end(); }\n+\n+} // namespace std\n+\n+\n+template <typename T>\n+  concept bool Float()\n+  {\n+    return __is_same_as( T, float );\n+  }\n+\n+template <typename T>\n+  constexpr decltype(auto) project( T t )\n+  {\n+    return t;\n+  }\n+\n+template <typename T>\n+  concept bool Concept()\n+  {\n+    return requires( T t ) {\n+      requires Float<decltype( project(t) )>();\n+    };\n+  }\n+\n+template <Concept E, Concept F>\n+  constexpr decltype(auto) operator<<( E&& e, F&& f ) {}\n+\n+template <Concept T>\n+  void foo( T t )\n+  {\n+    // Try to resolve operator<< from within a template context but\n+    // with non-dependent arguments. We need to ensure that template\n+    // processing is turned off whenever checking for satisfaction.\n+    std::cout << \"OK\"; // { dg-error \"no match\" }\n+  }\n+\n+\n+template <typename R>\n+concept bool Range()\n+{\n+  return requires( R r ) {\n+    requires __is_same_as(\n+      decltype(std::begin(r)), decltype(std::end(r)) );\n+  };\n+}\n+\n+struct A\n+{\n+  A() = default;\n+  A( const A& ) = default;\n+\n+  // Derivation from this class forces the instantiation of\n+  // this constructor, which results in the __is_same_as type\n+  // trait above to become error_mark_node in this declaration.\n+  template <Range R>\n+    explicit A( R&& r ) { }\n+};\n+\n+struct C : A\n+{\n+  C() = default;\n+  C( const C& ) = default;\n+};\n+\n+int main()\n+{\n+  C c; // OK\n+  return 0;\n+}"}, {"sha": "0aee852ce38f8e1a216f4a91e2a8e0a5cb927fdc", "filename": "gcc/testsuite/g++.dg/concepts/fn2.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  requires C<T>()\n+    void f(T x) { }\n+\n+// Non-dependent args are checked even in dependent scope.\n+template<typename T>\n+  void h(T x) {\n+    f(0); // { dg-error \"cannot call\" }\n+  }\n+\n+int main() {\n+  f(0); // { dg-error \"cannot call\" }\n+}"}, {"sha": "06402e02c3bbab6d9b22144415d1b30f943a9a6d", "filename": "gcc/testsuite/g++.dg/concepts/fn3.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn3.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++1z\" }\n+\n+#include <cassert>\n+\n+// Check partial ordering during overload resolution.\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool D() { return C<T>() and __is_empty(T); }\n+\n+struct S1 { } s1;\n+struct S2 { int n; } s2;\n+\n+int called = 0;\n+\n+template<C T> void f1(T x) { called = 1;}\n+template<D T> void f1(T x) { called = 2;}\n+\n+int main() {\n+  f1(s1); assert(called == 2);\n+  f1(s2); assert(called == 1);\n+}"}, {"sha": "5ced6a7f390d065b11f838081a67898848af5ee3", "filename": "gcc/testsuite/g++.dg/concepts/fn4.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn4.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool D() { return C<T>() and __is_empty(T); }\n+\n+struct S1 { } s1;\n+struct S2 { int n; } s2;\n+\n+template<C T> void f1(T x) { }\n+template<D T> void f1(T x) { }\n+\n+int main() {\n+  f1(0); // { dg-error \"matching\" }\n+}"}, {"sha": "b3c3f70a878952deff11f46b1285bea05be6b573", "filename": "gcc/testsuite/g++.dg/concepts/fn5.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn5.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,23 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+// Check shorthand notation.\n+\n+template<typename T>\n+  concept bool Type() { return true; }\n+\n+template<typename T, typename U>\n+  concept bool Same() { return __is_same_as(T, U); }\n+\n+template<Same<int> T> struct S1 { };\n+template<typename T, Same<T> U> struct S2 { };\n+\n+void f(Same<int> q) { }\n+void g(Type a, Same<decltype(a)> b) { }\n+\n+int main() {\n+  S1<char> s1;      // { dg-error \"constraint|invalid\" }\n+  S2<int, char> s2; // { dg-error \"constraint|invalid\" }\n+\n+  f('a');    // { dg-error \"cannot\" }\n+  g(0, 'a'); // { dg-error \"cannot\" }\n+}"}, {"sha": "73ef19a20a7743ed77c13db85260f0a93cc011c0", "filename": "gcc/testsuite/g++.dg/concepts/fn6.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn6.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,16 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+// Redefinition errors.\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool D() { return C<T>() and __is_empty(T); }\n+\n+template<C T> void f(T x) { }\n+template<typename T>\n+  requires C<T>()\n+    void f(T x) { } // { dg-error \"redefinition\" }\n+\n+int main() { }"}, {"sha": "2abd34a1e78039ad77cbdc55aba2f81b9a34a5f7", "filename": "gcc/testsuite/g++.dg/concepts/fn7.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn7.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,8 @@\n+// { dg-do link }\n+// { dg-options \"-std=c++1z\" }\n+\n+// FIXME: What is this actually testing?\n+\n+void f() requires true { }\n+\n+int main() { }"}, {"sha": "71141f6ff5572c063a4f5d81d5c4f2dd0f0ab9ca", "filename": "gcc/testsuite/g++.dg/concepts/fn8.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn8.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,27 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool Class() { return __is_class(T); }\n+\n+template<Class T> void f(T) { }\n+\n+template<typename T> void fn(T) { }\n+\n+auto p1 = &f<int>; // { dg-error \"no matches\" }\n+void (*p2)(int) = &f<int>; // { dg-error \"no matches\" }\n+void (*p3)(int) = &f; // { dg-error \"no matches\" }\n+\n+struct S {\n+  template<Class T> int f(T) { }\n+};\n+\n+auto p4 = &S::template f<int>; // { dg-error \"no matches\" }\n+int (S::*p6)(int) = &S::template f<int>; // { dg-error \"no matches\" }\n+int (S::*p7)(int) = &S::f; // { dg-error \"no matches\" }\n+\n+template<typename T>\n+  void g(T x) { }\n+\n+int main () {\n+  g(&f<int>); // { dg-error \"no matches\" }\n+}"}, {"sha": "b7ac4e10a8dad748b2bc45a770c9085bc4e7280a", "filename": "gcc/testsuite/g++.dg/concepts/fn9.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffn9.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,35 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++1z\" }\n+\n+#include <cassert>\n+\n+template<typename T>\n+  concept bool Class() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool Empty() { return Class<T>() and __is_empty(T); }\n+\n+template<Class T> int f(T) { return 1; }\n+template<Empty T> int f(T) { return 2; }\n+\n+struct S {\n+  template<Class T> int f(T) { return 1; }\n+  template<Empty T> int f(T) { return 2; }\n+} s;\n+\n+struct X { } x;\n+struct Y { X x; } y;\n+\n+int main () {\n+  auto p1 = &f<X>; // Empty f\n+  assert(p1(x) == 2);\n+\n+  auto p2 = &f<Y>; // Class f\n+  assert(p2(y) == 1);\n+\n+  auto p3 = &S::template f<X>; // Empty f\n+  assert((s.*p3)(x) == 2);\n+\n+  auto p4 = &S::template f<Y>; // Empty f\n+  assert((s.*p4)(y) == 1);\n+}"}, {"sha": "286e7697c73938f13bd6edac3e6629d988b54265", "filename": "gcc/testsuite/g++.dg/concepts/friend1.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffriend1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffriend1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffriend1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,34 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool Eq() { return requires(T t) { t == t; }; }\n+\n+struct Nt {\n+  template<Eq T> friend void f(T) { }\n+} nt;\n+\n+template<typename T> struct S;\n+\n+template<Eq T>\n+  void proc(S<T>*);\n+\n+template<typename T>\n+  struct S {\n+    friend bool operator==(S, S) requires Eq<T>() { return true; }\n+\n+    friend void proc<>(S*); // { dg-error \"does not match any template declaration\" }\n+  };\n+\n+struct X { } x;\n+\n+int main() {\n+  // f(0); // OK\n+  f(nt); // { dg-error \"cannot call\" }\n+  f(x);  // { dg-error \"not declared\" }\n+\n+  S<int> si;\n+  si == si; // OK\n+\n+  S<X> sx;\n+  sx == sx; // { dg-error \"no match\" }\n+}"}, {"sha": "38b230c4ff7ae336952f93d6370735d3336d821a", "filename": "gcc/testsuite/g++.dg/concepts/friend2.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffriend2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffriend2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ffriend2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,20 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool Eq() { return requires(T t) { t == t; }; }\n+\n+template<Eq T> struct Foo { };\n+\n+template<typename T>\n+  struct S { // { dg-error \"constraint failure\" }\n+    template<Eq U> friend class Bar;\n+\n+    friend class Foo<T>;\n+  };\n+\n+struct X { };\n+\n+int main() {\n+  S<int> si; // OK\n+  S<X> sx;\n+}"}, {"sha": "c6b74571954ee419de83993bb235573e78ddb88f", "filename": "gcc/testsuite/g++.dg/concepts/generic-fn-err.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fgeneric-fn-err.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fgeneric-fn-err.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fgeneric-fn-err.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,49 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<int N>\n+  concept bool Int() { return true; }\n+\n+template<template<typename> class X>\n+  concept bool Template() { return true; }\n+\n+struct S { };\n+\n+void f1(Int) { }      // { dg-error \"invalid\" }\n+void f2(Template) { } // { dg-error \"invalid\" }\n+\n+struct S1 {\n+  void f1(auto x) { }\n+  void f2(C x) { }\n+\n+  void f3(auto x) { }\n+  void f3(C x) { }\n+};\n+\n+template<C T>\n+  struct S2 {\n+    void f1(auto x) { }\n+    void f2(C x) { }\n+\n+    void h1(auto x);\n+    void h2(C x);\n+\n+    template<C U>\n+      void g(T t, U u) { }\n+  };\n+\n+int main() {\n+  S s;\n+\n+  S1 s1;\n+  s1.f2(0); // { dg-error \"matching\" }\n+\n+  S2<S> s2;\n+  s2.f2(0); // { dg-error \"matching\" }\n+  s2.h2(0); // { dg-error \"matching\" }\n+\n+  s2.g(s, 0); // { dg-error \"matching\" }\n+  s2.g(0, s); // { dg-error \"matching\" }\n+}"}, {"sha": "778356db1803a47384a129bffe38c6c1f8c788c1", "filename": "gcc/testsuite/g++.dg/concepts/generic-fn.C", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fgeneric-fn.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fgeneric-fn.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fgeneric-fn.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,157 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++1z\" }\n+\n+#include <cassert>\n+#include <type_traits>\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool Type() { return true; }\n+\n+struct S { };\n+\n+int called;\n+\n+// Basic terse notation\n+void f(auto x) { called = 1; }\n+void g(C x) { called = 2; }\n+\n+// Overloading generic functions\n+void h(auto x) { called = 1; }\n+void h(C x) { called = 2; }\n+\n+void p(auto x);\n+void p(C x);\n+\n+struct S1 {\n+  void f1(auto x) { called = 1; }\n+  void f2(C x) { called = 2; }\n+\n+  void f3(auto x) { called = 1; }\n+  void f3(C x) { called = 2; }\n+};\n+\n+template<C T>\n+  struct S2 {\n+    void f1(auto x) { called = 1; }\n+    void f2(C x) { called = 2; }\n+\n+    void f3(auto x) { called = 1; }\n+    void f3(C x) { called = 2; }\n+\n+    void h1(auto x);\n+    void h2(C x);\n+\n+    void h3(auto x);\n+    void h3(C x);\n+\n+    template<C U>\n+      void g1(T t, U u) { called = 1; }\n+\n+    template<C U>\n+      void g2(T t, U u);\n+  };\n+\n+\n+void ptr(C*) { called = 1; }\n+void ptr(const C*) { called = 2; }\n+\n+void ref(C&) { called = 1; }\n+void ref(const C&) { called = 2; }\n+\n+void\n+fwd_lvalue_ref(Type&& x) {\n+  using T = decltype(x);\n+  static_assert(std::is_lvalue_reference<T>::value, \"not an lvlaue reference\");\n+}\n+\n+void\n+fwd_const_lvalue_ref(Type&& x) {\n+  using T = decltype(x);\n+  static_assert(std::is_lvalue_reference<T>::value, \"not an lvalue reference\");\n+  using U = typename std::remove_reference<T>::type;\n+  static_assert(std::is_const<U>::value, \"not const-qualified\");\n+}\n+\n+void fwd_rvalue_ref(Type&& x) {\n+  using T = decltype(x);\n+  static_assert(std::is_rvalue_reference<T>::value, \"not an rvalue reference\");\n+}\n+\n+// Make sure we can use nested names speicifers for concept names.\n+namespace N {\n+  template<typename T>\n+    concept bool C() { return true; }\n+} // namesspace N\n+\n+void foo(N::C x) { }\n+\n+int main() {\n+  S s;\n+  const S cs;\n+\n+  f(0); assert(called == 1);\n+  g(s); assert(called == 2);\n+\n+  h(0); assert(called == 1);\n+  h(s); assert(called == 2);\n+\n+  S1 s1;\n+  s1.f1(0); assert(called == 1);\n+  s1.f2(s); assert(called == 2);\n+\n+  s1.f3(0); assert(called == 1);\n+  s1.f3(s); assert(called == 2);\n+\n+  S2<S> s2;\n+  s2.f1(0); assert(called == 1);\n+  s2.f2(s); assert(called == 2);\n+\n+  s2.f3(0); assert(called == 1);\n+  s2.f3(s); assert(called == 2);\n+\n+  s2.h1(0); assert(called == 1);\n+  s2.h2(s); assert(called == 2);\n+\n+  s2.h3(0); assert(called == 1);\n+  s2.h3(s); assert(called == 2);\n+\n+  s2.g1(s, s); assert(called == 1);\n+  s2.g2(s, s); assert(called == 2);\n+\n+  ptr(&s); assert(called == 1);\n+  ptr(&cs); assert(called == 2);\n+\n+  ref(s); assert(called == 1);\n+  ref(cs); assert(called == 2);\n+\n+  // Check forwarding problems\n+  fwd_lvalue_ref(s);\n+  fwd_const_lvalue_ref(cs);\n+  fwd_rvalue_ref(S());\n+\n+  foo(0);\n+}\n+\n+// Test that decl/def matching works.\n+\n+void p(auto x) { called = 1; }\n+void p(C x) { called = 2; }\n+\n+template<C T>\n+  void S2<T>::h1(auto x) { called = 1; }\n+\n+template<C T>\n+  void S2<T>::h2(C x) { called = 2; }\n+\n+template<C T>\n+  void S2<T>::h3(auto x) { called = 1; }\n+\n+template<C T>\n+  void S2<T>::h3(C x) { called = 2; }\n+\n+template<C T>\n+  template<C U>\n+    void S2<T>::g2(T t, U u) { called = 2; }"}, {"sha": "29433ade7b4feb52cded3d8862ff324750ed7ef2", "filename": "gcc/testsuite/g++.dg/concepts/inherit-ctor1.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,22 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  struct S1 { S1(double) requires C<T>() { } };\n+\n+struct S2 : S1<int> {\n+  using S1<int>::S1;\n+};\n+\n+template<typename T>\n+  struct S3 : S1<T> {\n+    using S1<T>::S1;\n+  };\n+\n+struct X { };\n+\n+int main() {\n+  S3<X> s(0.0);\n+}"}, {"sha": "4f39203db4c34e36dbd859b0a5c82e1c71a9878b", "filename": "gcc/testsuite/g++.dg/concepts/inherit-ctor2.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  struct S1 {\n+    S1(double) requires C<T>() { }\n+  };\n+\n+template<typename T>\n+  struct S2 : S1<T> { // { dg-error \"matching\" }\n+    using S1<T>::S1;\n+  };\n+\n+int main() {\n+  S2<int> s; // { dg-error \"deleted function\" }\n+}"}, {"sha": "3d0ddf210d12681a05101a0225ae9b7178e0d6f6", "filename": "gcc/testsuite/g++.dg/concepts/inherit-ctor3.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor3.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,21 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  struct S1 {\n+    template<C U>\n+      S1(U x) { }\n+  };\n+\n+template<typename T>\n+  struct S2 : S1<T> {\n+    using S1<T>::S1;\n+  };\n+\n+struct X { } x;\n+\n+int main() {\n+  S2<X> s = x;\n+}"}, {"sha": "cd9565f660f022e4b2bde85a7787758538c9beee", "filename": "gcc/testsuite/g++.dg/concepts/inherit-ctor4.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Finherit-ctor4.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  struct S1 {\n+    template<C U> S1(U x) { }\n+  };\n+\n+template<typename T>\n+  struct S2 : S1<T> {\n+    using S1<T>::S1;\n+  };\n+\n+int main() {\n+  S2<int> s(0); // { dg-error \"no matching function\" }\n+}"}, {"sha": "1b5f5d14b7e56b4ca663dd3de0527598d149fb27", "filename": "gcc/testsuite/g++.dg/concepts/intro1.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,38 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C = __is_class(T);\n+\n+C{T} void f1();\n+\n+struct S1\n+{\n+  C{T} void f2();\n+  C{T} static void f3();\n+};\n+\n+int main()\n+{\n+  S1 s;\n+\n+  f1<S1>();\n+  s.f2<S1>();\n+  S1::f3<S1>();\n+\n+  return 0;\n+}\n+\n+template<typename T>\n+  void f1() requires C<T>\n+  {\n+  }\n+\n+template<typename T>\n+  void S1::f2() requires C<T>\n+  {\n+  }\n+\n+template<typename T>\n+  void S1::f3() requires C<T>\n+  {\n+  }"}, {"sha": "91a1cacf9c0eacd47f4e674a9c37db4876df1190", "filename": "gcc/testsuite/g++.dg/concepts/intro2.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++1z\" }\n+\n+#include <cassert>\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<int N>\n+  concept bool P() { return true; }\n+\n+C{A} struct S1\n+{\n+  P{B} int f1();\n+};\n+\n+struct S2 {};\n+\n+int main()\n+{\n+  S1<S2> s;\n+\n+  assert(s.f1<10>() == sizeof(S2) + 10);\n+  return 0;\n+}\n+\n+C{A} P{B} int S1<A>::f1() { return B + sizeof(A); }"}, {"sha": "5dd95c698e12e422210d8df14c2080a3848b5b68", "filename": "gcc/testsuite/g++.dg/concepts/intro3.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro3.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename ... T>\n+  concept bool C1 = true;\n+\n+template<int ... N>\n+  concept bool C2 = true;\n+\n+C1{...A} void f1() {};\n+C2{...A} void f2() {};\n+\n+int main()\n+{\n+  f1<int, short, char>();\n+  f2<1, 2, 3>();\n+  return 0;\n+}"}, {"sha": "6d8aec3ff61649fe13948c6c63ef1ca990d82021", "filename": "gcc/testsuite/g++.dg/concepts/intro4.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro4.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,32 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename ... T>\n+  concept bool C1 = true;\n+\n+template<int ... N>\n+  concept bool C2 = true;\n+\n+template<typename T>\n+  concept bool C3 = __is_class(T);\n+\n+template<typename ... T>\n+  concept bool C4() { return true; }\n+template<int N>\n+  concept bool C4() { return true; }\n+\n+template<typename T, typename U = int>\n+  concept bool C5() { return __is_class(U); }\n+\n+C1{...A, B} void f1() {}; // { dg-error \"no matching|wrong number\" }\n+C1{A} void f2() {} // { dg-error \"cannot match pack|no matching concept\" }\n+C2{A, B} void f3() {}; // { dg-error \"cannot match pack|no matching concept\" }\n+C3{...A} void f4() {}; // { dg-error \"cannot match pack|no matching concept\" }\n+C4{A} void f5() {}; // { dg-error \"no matching concept\" }\n+C5{A, B} void f6() {};\n+\n+int main()\n+{\n+  // Defaults should not transfer\n+  f6<int>(); // { dg-error \"no matching\" }\n+  return 0;\n+}"}, {"sha": "64771cd6e251f8279083a1846987e2a6ed04b8a6", "filename": "gcc/testsuite/g++.dg/concepts/intro5.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro5.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T, typename U = int>\n+  concept bool C()\n+  {\n+     return sizeof(U) == sizeof(int);\n+  }\n+\n+C{A} void f1() {}\n+\n+int main()\n+{\n+  f1<char>();\n+  return 0;\n+}"}, {"sha": "4e168ef3c7dc837b5609835dd72c9149691a4efc", "filename": "gcc/testsuite/g++.dg/concepts/intro6.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro6.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/67003\n+// { dg-options \"-std=c++1z\" }\n+\n+namespace X {\n+  template<class>\n+  concept bool C = true;\n+}\n+\n+X::C{T}\n+void foo() {}\n+\n+int main() { foo<int>(); }"}, {"sha": "d92eafcfbd57c70a3cb47181e92a179fadd245a4", "filename": "gcc/testsuite/g++.dg/concepts/intro7.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fintro7.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/66985\n+// { dg-options \"-std=c++1z\" }\n+\n+template <template <class> class T>\n+concept bool _Valid = requires { typename T<int>; };\n+\n+template <template <class> class T>\n+struct __defer { };\n+\n+_Valid{T}\n+struct __defer<T> {\n+  using type = T<int>;\n+};"}, {"sha": "46404e3ad4f0fd1441e856fa7d0b701c70be3744", "filename": "gcc/testsuite/g++.dg/concepts/member-concept.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fmember-concept.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fmember-concept.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fmember-concept.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+struct Base {\n+  template<typename T>\n+    static concept bool D() { return __is_same_as(T, int); } // { dg-error \"a concept cannot be a member function\" }\n+\n+  template<typename T, typename U>\n+    static concept bool E() { return __is_same_as(T, U); } // { dg-error \"a concept cannot be a member function\" }\n+};"}, {"sha": "a62fe5ef22030b4694de7f4e7ef431066fbc9273", "filename": "gcc/testsuite/g++.dg/concepts/memfun-err.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fmemfun-err.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fmemfun-err.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fmemfun-err.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do run}\n+// { dg-options \"-std=c++1z\" }\n+\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool D() { return __is_empty(T); }\n+\n+struct X { } x;\n+struct Y { int n; } y;\n+\n+int called = 0;\n+\n+// Test constrained member definitions\n+template<typename T>\n+  struct S1 {\n+    void f1() requires C<T>() { }\n+    void g1() requires C<T>() and true;\n+    template<C U> void h1(U u) { called = 1; }\n+\n+    void g2() requires C<T>(); // { dg-error \"candidate\" }\n+  };\n+\n+template<typename T>\n+  void S1<T>::g2() requires D<T>() { } // { dg-error \"prototype\" }\n+\n+int main() {\n+  S1<X> sx;\n+  S1<Y> sy;\n+  S1<int> si;\n+\n+  si.f1(); // { dg-error \"matching\" }\n+  si.g1(); // { dg-error \"matching\" }\n+  si.h1(0); // { dg-error \"matching\" }\n+}"}, {"sha": "a96c01816534591eb956fc90a1b6ee8a9437c9f3", "filename": "gcc/testsuite/g++.dg/concepts/memfun.C", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fmemfun.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fmemfun.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fmemfun.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,112 @@\n+// { dg-do run}\n+// { dg-options \"-std=c++1z\" }\n+\n+#include <cassert>\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool D() { return __is_empty(T); }\n+\n+struct X { } x;\n+struct Y { int n; } y;\n+\n+int called = 0;\n+\n+// Test constrained member definitions\n+template<typename T>\n+  struct S1 {\n+    void f1() requires C<T>() { }\n+\n+    void f2() requires C<T>() { called = 1; }\n+    void f2() requires not C<T>() { called = 2; }\n+\n+    void f3() { called = 1; }\n+    void f3() requires C<T>() { called = 2; }\n+    void f3() requires C<T>() and D<T>() { called = 3; }\n+\n+    void g1() requires C<T>() and true;\n+\n+    void g2() requires C<T>();\n+    void g2() requires not C<T>();\n+\n+    void g3();\n+    void g3() requires C<T>();\n+    void g3() requires C<T>() and D<T>();\n+\n+    template<C U> void h1(U u) { called = 1; }\n+    template<C U> void h2(U u);\n+    template<C U> void h3(U u) requires D<U>();\n+  };\n+\n+template<C T>\n+  struct S2 {\n+    void f(T) requires D<T>();\n+  };\n+\n+\n+int main() {\n+  S1<X> sx;\n+  S1<Y> sy;\n+  S1<int> si;\n+\n+  // Defined in-class\n+  sx.f1();\n+  sx.f2(); assert(called == 1);\n+  sx.f3(); assert(called == 3);\n+\n+  sy.f1();\n+  sy.f2(); assert(called == 1);\n+  sy.f3(); assert(called == 2);\n+\n+  si.f2(); assert(called == 2);\n+  si.f3(); assert(called == 1);\n+\n+  // Member function template tests\n+  S1<int> s1i;\n+  s1i.h1(x); assert(called == 1);\n+  s1i.h2(x); assert(called == 2);\n+  s1i.h3(x); assert(called == 3);\n+\n+  // Defined out of class.\n+  sx.g1();\n+  sx.g2(); assert(called == 1);\n+  sx.g3(); assert(called == 3);\n+\n+  sy.g1();\n+  sy.g2(); assert(called == 1);\n+  sy.g3(); assert(called == 2);\n+\n+  si.g2(); assert(called == 2);\n+  si.g3(); assert(called == 1);\n+}\n+\n+template<typename T>\n+  void S1<T>::g1() requires C<T>() and true { }\n+\n+template<typename T>\n+  void S1<T>::g2() requires C<T>() { called = 1; }\n+\n+template<typename T>\n+  void S1<T>::g2() requires not C<T>() { called = 2; }\n+\n+template<typename T>\n+  void S1<T>::g3() { called = 1; }\n+\n+template<typename T>\n+  void S1<T>::g3() requires C<T>() { called = 2; }\n+\n+template<typename T>\n+  void S1<T>::g3() requires C<T>() and D<T>() { called = 3; }\n+\n+template<typename T>\n+  template<C U>\n+    void S1<T>::h2(U u) { called = 2; }\n+\n+template<typename T>\n+  template<C U>\n+      void S1<T>::h3(U u) requires D<U>() { called = 3; }\n+\n+template<C T>\n+  void S2<T>::f(T t) requires D<T>() { called = 4; }"}, {"sha": "114c12f85bc576b314339405d0c4fdee630873c9", "filename": "gcc/testsuite/g++.dg/concepts/partial-concept-id1.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-concept-id1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-concept-id1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-concept-id1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,33 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool Type() { return true; }\n+\n+template<typename T, typename U>\n+  concept bool Same() { return __is_same_as(T, U); }\n+\n+template<typename T, typename U>\n+  concept bool C1() { return true; }\n+\n+template<typename T, typename... Args>\n+  concept bool C2() { return true; }\n+\n+template<Same<int> T> struct S1 { };\n+template<typename T, Same<T> U> struct S2 { };\n+\n+void f(Same<int> q) { }\n+void g(Type a, Same<decltype(a)> b) { }\n+\n+void h0(Same<int>* a) { }\n+void h1(C1<int>* a) { }\n+void h2(C2<char, short, int, long>* a) { }\n+\n+int main() {\n+  S1<int> s1;\n+  S2<int, int> s2;\n+  f(0);\n+  g(0, 1);\n+  h0((int*)0);\n+  h1((int*)0);\n+  h2((int*)0);\n+}"}, {"sha": "fb754483db444db3101f4ad0700da4a02898daf1", "filename": "gcc/testsuite/g++.dg/concepts/partial-concept-id2.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-concept-id2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-concept-id2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-concept-id2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+// Make sure that we check partial concept ids\n+// with variable concepts.\n+\n+template<class A, class B>\n+concept bool C = true;\n+\n+template<C<int> D>\n+struct E\n+{\n+  int f = 0;\n+};\n+\n+E<double> e;"}, {"sha": "fe612d4ada0eaa5d9da475c96952a143f54ef9ba", "filename": "gcc/testsuite/g++.dg/concepts/partial-spec.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-spec.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-spec.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-spec.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+// Check that constraints don't break unconstrained partial\n+// specializations.\n+\n+template<typename T>\n+  struct S { };\n+\n+template<typename T>\n+  struct S<T*> { };\n+\n+template<>\n+  struct S<int> { };\n+\n+int main() { }"}, {"sha": "db7545586a9ae32fd745fd2200b66aa7f873ce0a", "filename": "gcc/testsuite/g++.dg/concepts/partial-spec2.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-spec2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-spec2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-spec2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,32 @@\n+// PR c++/67084\n+// { dg-options -std=c++1z }\n+\n+template <class T>\n+constexpr bool p = false;\n+\n+template <class T>\n+constexpr bool p<T*> = false;\n+\n+template <class T>\n+  requires true\n+constexpr bool p<T*> = false;\n+\n+template <class T>\n+  requires true && T() == 0\n+constexpr bool p<T*> = true;\n+\n+template <class T>\n+constexpr bool q = false;\n+\n+template <class T>\n+constexpr bool q<T*> = true;\n+\n+template <class T>\n+  requires false\n+constexpr bool q<T*> = false;\n+\n+template <class T>\n+  requires false && T() != 0\n+constexpr bool q<T*> = false;\n+\n+static_assert (p<int*>,\"\");"}, {"sha": "d73d7879a30457657493dac531508ce6d114a147", "filename": "gcc/testsuite/g++.dg/concepts/partial-spec3.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-spec3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-spec3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-spec3.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,7 @@\n+// { dg-options -std=c++1z }\n+\n+template <class T> struct A { };\n+template <class T> requires false struct A<T*> { };\n+template <class T> struct A<T*> { static int i; };\n+\n+int i = A<int*>::i;"}, {"sha": "d4b8e9c92f782f568490d850fe956b99d175d63c", "filename": "gcc/testsuite/g++.dg/concepts/partial-spec4.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-spec4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-spec4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-spec4.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,49 @@\n+// { dg-options -std=c++1z }\n+\n+template <class T> concept bool is_int = __is_same_as(T,int);\n+\n+template <class T> struct A { };\n+template <is_int T> struct A<T*> {\n+  typedef int I1;\n+  static const A<T*>::I1 j1 = 0;\n+  static int f();\n+};\n+template <is_int T> int A<T*>::f()\n+{ A<T*>::I1 i; return j1; }\n+\n+template <class T> struct A<T*> {\n+  typedef int I2;\n+  static const A<T*>::I2 j2 = 0;\n+  static int f();\n+};\n+template <class T> int A<T*>::f()\n+{ A<T*>::I2 i; return j2; }\n+\n+const int i1 = A<int*>::j1;\n+const int i2 = A<float*>::j2;\n+\n+template <class T> struct B;\n+\n+template <is_int T> struct B<T> {\n+  typedef int I4;\n+  static const B<T>::I4 j4 = 0;\n+  static int f();\n+};\n+template <is_int T> int B<T>::f()\n+{ B<T>::I4 i; return j4; }\n+\n+template <class T> struct B {\n+  typedef int I5;\n+  static const B<T>::I5 j5 = 0;\n+  static int f();\n+};\n+template <class T> int B<T>::f()\n+{ B<T>::I5 i; return j5; }\n+\n+int i4 = B<int>::j4;\n+int i5 = B<float>::j5;\n+int main()\n+{\n+  B<int>::f();\n+  B<float>::f();\n+}"}, {"sha": "dcf167bc4ae38d45e05a94b6653f76d2a87aef51", "filename": "gcc/testsuite/g++.dg/concepts/partial-spec5.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-spec5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-spec5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpartial-spec5.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/67138\n+// { dg-options -std=c++1z }\n+\n+template <class T>\n+concept bool _Auto = true;\n+\n+template <_Auto T>\n+struct test {};\n+\n+template <_Auto T>\n+  requires requires (T t) { t + t; }\n+struct test<T> {};"}, {"sha": "0b5a7cf278598d224bca07917b3581488b00eb16", "filename": "gcc/testsuite/g++.dg/concepts/placeholder1.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,34 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T, typename U>\n+struct is_same\n+{\n+  static constexpr bool value = false;\n+};\n+\n+template<typename T>\n+struct is_same<T, T>\n+{\n+  static constexpr bool value = true;\n+};\n+\n+template<class T, class U>\n+concept bool Same = is_same<T, U>::value;\n+\n+template<typename T>\n+concept bool C1 = true;\n+\n+template<typename T, typename U>\n+concept bool C2 = true;\n+\n+template<typename T>\n+concept bool C3() { return true; }\n+\n+template<typename T, typename U>\n+concept bool C4() { return true; }\n+\n+C1      c1 = 0;\n+C2<int> c2 = 0;\n+C3      c3 = 0;\n+C4<int> c4 = 0;\n+Same<int> s1 = 'a'; // { dg-error \"does not satisfy|is_same\" }"}, {"sha": "8165c8134f9d1c06f3ce15aa3ed6dda64cbf89ea", "filename": "gcc/testsuite/g++.dg/concepts/placeholder2.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,32 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+// Check argument deduction constraints.\n+// TODO: We shoul have more of these...\n+\n+template<typename T>\n+concept bool C1 = sizeof(T) == 0;\n+\n+template<typename T, typename U>\n+concept bool C2 = __is_same_as(T, U);\n+\n+\n+template<typename T>\n+concept bool D1()\n+{\n+  return requires (T t) { { t } -> C1; };\n+}\n+\n+template<typename T>\n+concept bool D2()\n+{\n+  return requires (T t) { { t } -> C2<void>; };\n+}\n+\n+void f1(D1) { }\n+void f2(D2) { }\n+\n+int main()\n+{\n+  f1(0); // { dg-error \"cannot call\" }\n+  f2(0); // { dg-error \"cannot call\" }\n+}"}, {"sha": "bd89551aa5bc6a5dd2744e888a6632927fe210bc", "filename": "gcc/testsuite/g++.dg/concepts/placeholder3.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder3.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/66218\n+// { dg-options \"-std=c++1z\" }\n+\n+template <class T, class U>\n+concept bool Same = __is_same_as(T, U);\n+\n+template <class T>\n+concept bool C =\n+  requires {\n+    { 0 } -> Same<T>;\n+  };\n+\n+template <C c>\n+constexpr bool f() { return true; }\n+\n+static_assert(f<double>(), \"\");\t// { dg-error \"\" }\n+static_assert(f<int>(), \"\");"}, {"sha": "e34fc94e6cf61074e24938451cc52150bdbf5d47", "filename": "gcc/testsuite/g++.dg/concepts/placeholder4.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder4.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,20 @@\n+// PR c++/66218\n+// { dg-options \"-std=c++1z\" }\n+\n+template <class T, class U>\n+concept bool Same = __is_same_as(T, U);\n+\n+template <class T>\n+concept bool C =\n+  requires {\n+    { 0 } -> Same<T>;\n+  };\n+\n+template <class T>\n+struct A {\n+  template <T t, C c>\n+  constexpr static bool f() { return true; }\n+};\n+\n+static_assert(A<int>::f<1,double>(), \"\");\t// { dg-error \"\" }\n+static_assert(A<char>::f<'a',int>(), \"\");"}, {"sha": "6aaf57b32879ecf6926ded3166d7955e98120173", "filename": "gcc/testsuite/g++.dg/concepts/placeholder5.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder5.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template <class T, class U>\n+concept bool Same = __is_same_as(T, U);\n+\n+const int i = 0;\n+template <class T>\n+concept bool C =\n+  requires {\n+    { &i } -> const Same<T>*;\n+  };\n+\n+template <C c>\n+constexpr bool f() { return true; }\n+\n+static_assert(f<double>(), \"\");\t// { dg-error \"\" }\n+static_assert(f<int>(), \"\");"}, {"sha": "c72e6c638f57e15dc33be62b3dc7459cb519294f", "filename": "gcc/testsuite/g++.dg/concepts/pr65552.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65552.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65552.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65552.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,19 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+concept bool Concept() {\n+  return requires () {\n+    typename T::member_type1;\n+    typename T::member_type2;\n+  };\n+}\n+\n+struct model {\n+  using member_type1 = int;\n+  using member_type2 = int;\n+};\n+\n+template<Concept C>\n+struct S {};\n+\n+S<model> s;"}, {"sha": "fa24b7be0e07bb3b26c988045d8d9640d43ba9c5", "filename": "gcc/testsuite/g++.dg/concepts/pr65575.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65575.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65575.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65575.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,23 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+concept bool C = false;\n+\n+int f1() requires false;\n+int& f2() requires false;\n+int* f3() requires false;\n+auto f4() -> int& requires false;\n+auto f5() -> int* requires false;\n+auto f6() -> int requires false;\n+\n+int (*p)() requires true; // { dg-error \"\" }\n+int (&p)() requires true; // { dg-error \"\" }\n+int g(int (*)() requires true); // { dg-error \"\" }\n+\n+int f() { }\n+\n+int\n+main()\n+{\n+  f1(); // { dg-error \"cannot call\" }\n+}"}, {"sha": "31dc87aa6c3ca843ecd92706fb6a28ae73ae8bbf", "filename": "gcc/testsuite/g++.dg/concepts/pr65634.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65634.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65634.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65634.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,19 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+concept bool C1() {\n+    return requires () {\n+               { T::smf() } noexcept;\n+           };\n+}\n+struct M1 {\n+    static void smf() noexcept;\n+};\n+template<typename T>\n+concept bool C2() {\n+    return C1<typename T::type>();\n+}\n+struct M2 {\n+    using type = M1;\n+};\n+static_assert(C2<M2>(), \"\");"}, {"sha": "8b6f2a1ad6eba7fe0e0e37a49d85911df0d2c3bc", "filename": "gcc/testsuite/g++.dg/concepts/pr65636.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65636.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65636.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65636.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+using TD = int;\n+\n+template<typename T>\n+concept bool C() {\n+  return requires () { typename TD; };\n+}\n+\n+static_assert(C<int>(), \"\");"}, {"sha": "bdbbd66e74746d228499e3c76edb01c3272e6284", "filename": "gcc/testsuite/g++.dg/concepts/pr65681.C", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65681.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65681.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65681.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,106 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+concept bool C()\n+{\n+  return requires (T t) { t.mf(); };\n+}\n+\n+template<typename T>\n+concept bool CA1()\n+{\n+  return C<typename T::ca1_type>();\n+}\n+\n+template<typename T>\n+concept bool CA2()\n+{\n+  return CA1<T>() && requires () { typename T::ca2_type; };\n+}\n+\n+template<typename T>\n+concept bool CA3()\n+{\n+  return CA2<T>() && requires () { typename T::ca3_type; };\n+}\n+\n+template<typename T>\n+concept bool CB1()\n+{\n+  return requires () { typename T::cb1_type; };\n+}\n+\n+template<typename T>\n+concept bool CB2()\n+{\n+  return CB1<T>() && requires () { typename T::cb2_type; };\n+}\n+\n+template<typename T>\n+concept bool CB3()\n+{\n+  return CB2<T>() && requires () { typename T::cb3_type; };\n+}\n+\n+\n+struct MC { void mf(); };\n+static_assert(C<MC>(), \"\");\n+\n+\n+struct MA1 { using ca1_type = MC; };\n+struct MA2 : MA1 { using ca2_type = int; };\n+struct MA3 : MA2 { using ca3_type = int; };\n+static_assert(CA1<MA1>(), \"\");\n+static_assert(CA2<MA2>(), \"\");\n+static_assert(CA3<MA3>(), \"\");\n+\n+struct MB1 { using cb1_type = int; };\n+struct MB2 : MB1 { using cb2_type = int; };\n+struct MB3 : MB2 { using cb3_type = int; };\n+static_assert(CB1<MB1>(), \"\");\n+static_assert(CB2<MB2>(), \"\");\n+static_assert(CB3<MB3>(), \"\");\n+\n+\n+template<typename T1, typename T2>\n+struct S;\n+\n+template<CA1 T1, CB1 T2>\n+struct S<T1, T2> // Specialization #1\n+{\n+  static constexpr int value = 1;\n+};\n+\n+template<CA1 T1, CB2 T2>\n+  requires !CA2<T1>()\n+struct S<T1, T2> // Specialization #2\n+{\n+  static constexpr int value = 2;\n+};\n+\n+template<CA2 T1, CB3 T2>\n+  requires !CA3<T1>()\n+struct S<T1, T2> // Specialization #3\n+{\n+  static constexpr int value = 3;\n+};\n+\n+S<MA1,MB1> s11;\n+S<MA1,MB2> s12;\n+S<MA1,MB3> s13;\n+S<MA2,MB1> s21;\n+S<MA2,MB2> s22;\n+S<MA2,MB3> s23;\n+S<MA3,MB1> s31;\n+S<MA3,MB2> s32;\n+S<MA3,MB3> s33;\n+\n+static_assert(S<MA1,MB1>::value == 1, \"\");\n+static_assert(S<MA1,MB2>::value == 2, \"\");\n+static_assert(S<MA1,MB3>::value == 2, \"\");\n+static_assert(S<MA2,MB1>::value == 1, \"\");\n+static_assert(S<MA2,MB2>::value == 1, \"\");\n+static_assert(S<MA2,MB3>::value == 3, \"\");\n+static_assert(S<MA3,MB1>::value == 1, \"\");\n+static_assert(S<MA3,MB2>::value == 1, \"\");\n+static_assert(S<MA3,MB3>::value == 1, \"\");"}, {"sha": "d0bb6a2afb85d66b8d933f717f4d8402ea88bbd0", "filename": "gcc/testsuite/g++.dg/concepts/pr65848.C", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65848.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65848.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65848.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,75 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+// Performance test... This should be fast.\n+\n+#include <type_traits>\n+\n+template<typename T>\n+concept bool Destructible() {\n+    return std::is_destructible<T>::value;\n+}\n+template<typename T, typename... Args>\n+concept bool Constructible() {\n+    return Destructible<T>() && std::is_constructible<T, Args...>::value;\n+}\n+template<typename T>\n+concept bool Move_constructible() {\n+    return Constructible<T, T&&>();\n+}\n+template<typename T>\n+concept bool Copy_constructible() {\n+    return Move_constructible<T>() && Constructible<T, const T&>();\n+}\n+template<typename T, typename U>\n+concept bool Assignable() {\n+    return std::is_assignable<T, U>::value;\n+}\n+template<typename T>\n+concept bool Move_assignable() {\n+    return Assignable<T&, T&&>();\n+}\n+template<typename T>\n+concept bool Copy_assignable() {\n+    return Move_assignable<T>() && Assignable<T&, const T&>();\n+}\n+template<typename T>\n+concept bool Copyable() {\n+    return Copy_constructible<T>() && Copy_assignable<T>();\n+}\n+\n+template<typename T>\n+concept bool C1() { return Copyable<T>(); }\n+template<typename T>\n+concept bool C2() { return C1<T>(); }\n+template<typename T>\n+concept bool C3() { return C2<T>(); }\n+template<typename T>\n+concept bool C4() { return C3<T>(); }\n+template<typename T>\n+concept bool C5() { return C4<T>(); }\n+template<typename T>\n+concept bool C6() { return C5<T>(); }\n+template<typename T>\n+concept bool C7() { return C6<T>(); }\n+template<typename T>\n+concept bool C8() { return C7<T>(); }\n+template<typename T>\n+concept bool C9() { return C8<T>(); }\n+template<typename T>\n+concept bool C10() { return C9<T>(); }\n+template<typename T>\n+concept bool C11() { return C10<T>(); }\n+\n+struct S1 {};\n+struct S2 {};\n+struct S3 {};\n+struct S4 {};\n+struct S5 {};\n+struct S6 {};\n+\n+static_assert(C11<S1>(), \"\");\n+static_assert(C11<S2>(), \"\");\n+static_assert(C11<S3>(), \"\");\n+static_assert(C11<S4>(), \"\");\n+static_assert(C11<S5>(), \"\");\n+static_assert(C11<S6>(), \"\");"}, {"sha": "4b0befa5599738cab72442d716880f627b48b769", "filename": "gcc/testsuite/g++.dg/concepts/pr65854.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65854.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65854.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr65854.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,24 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+// Handle alias templates in type requirements.\n+\n+template<typename T1, typename T2>\n+struct BTT { };\n+\n+template<typename T>\n+struct BTT<T,T> { using type = int; };\n+\n+template<typename T1, typename T2>\n+using Alias1 = typename BTT<T1, T2>::type;\n+\n+template<typename T1, typename T2>\n+concept bool C()\n+{\n+  return requires() { typename Alias1<T1, T2>; };\n+}\n+\n+template<typename T1, typename T2>\n+  requires C<T1, T2>()\n+int f();\n+\n+auto i = f<char, int>(); // { dg-error \"cannot call function\" }"}, {"sha": "ee9d1150fdbf70636146741d64a04dd1c83e1865", "filename": "gcc/testsuite/g++.dg/concepts/pr66091.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr66091.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr66091.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr66091.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,19 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+concept bool C1()\n+{\n+  return requires() { typename T::type1; };\n+}\n+\n+template<typename T>\n+concept bool C2()\n+{\n+  return C1<T>() && requires() { typename T::type2; };\n+}\n+\n+template<C1 T>\n+struct S {\n+  S& operator++() { return *this; }\n+  S& operator++() requires C2<T>() { return *this; }\n+};"}, {"sha": "0b7520e185c48c571a95e3253f0126e6dfad393c", "filename": "gcc/testsuite/g++.dg/concepts/req-neg1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq-neg1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq-neg1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq-neg1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+void f1(int a) requires true;         // OK\n+auto f2(int a) -> bool requires true; // OK\n+auto f3(int a) requires true -> bool; // { dg-error \"\" } requires-clause precedes trailing-return-type\n+typedef void fn_t() requires true;    // { dg-error \"typedef\" }\n+void (*pf)() requires true;           // { dg-error \"non-function\" }\n+void (*fn(int))() requires false;     // { dg-error \"return type\" }\n+void g(int (*)() requires true);      // { dg-error \"parameter|non-function\" }\n+auto* p = new (void(*)(char) requires true); // { dg-error \"type-id\" }"}, {"sha": "02d5de09ec9a206c5f731b82303514db2df20080", "filename": "gcc/testsuite/g++.dg/concepts/req1.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool Class () { return __is_class(T); }\n+\n+// Allow a requires-expression with no parms.\n+template<typename T>\n+  concept bool C = requires { typename T::type; };\n+\n+void f1(auto a) requires Class<decltype(a)>() { }\n+void f2(auto a) requires requires (decltype(a) x) { -x; } { }\n+\n+struct S { } s;\n+\n+// Allow non-type template parms as constraints.\n+template<bool B> requires B struct S0; // OK\n+\n+template<int N> requires N struct S1 { };      // { dg-error \"does not have type\" }\n+template<int N> requires N == 0 struct S2 { }; // OK\n+\n+template<typename T, T X> requires X struct S3 { }; // OK\n+S3<int, 0> s3a;      // { dg-error \"constraint failure|does not have type\" }\n+S3<bool, false> s3b; // { dg-error \"constraint failure\" }\n+\n+int main() {\n+  f1(s);\n+  f2(0);\n+}"}, {"sha": "bd3b4e3e2f5f85da5c7b16cfb2c882d5af424676", "filename": "gcc/testsuite/g++.dg/concepts/req10.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq10.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+// Test that standard conversions are checked with\n+// implicit conversion constraints.\n+\n+template<typename T, typename U>\n+concept bool C()\n+{\n+  return requires(T& t) { {t} -> U&; };\n+}\n+\n+struct B { };\n+class D : B { };\n+\n+int main()\n+{\n+  static_assert(C<D, B>(), \"\"); // { dg-error \"failed\" }\n+}"}, {"sha": "3e21c11113fdb5729627850351728a5f775eb863", "filename": "gcc/testsuite/g++.dg/concepts/req11.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq11.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,28 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+// Check that we can evaluate constant requires-expressions\n+// as constant expressions, for the curious case when they\n+// appear within predicate constraints.\n+\n+template<typename... Ts> struct variant { };\n+\n+template<typename T>\n+concept bool Streamable()\n+{\n+  return requires (T t) { t; };\n+}\n+\n+template<typename T>\n+concept bool Range()\n+{\n+  return requires (T t) { t; };\n+}\n+\n+template<class T>\n+  requires Streamable<T>() and not Range<T>()\n+void print(const T& x) { }\n+\n+int main()\n+{\n+  print(\"hello\"); // { dg-error \"cannot call\" }\n+}"}, {"sha": "7b23d113cb29059c8042fa1d0bfd13793397e463", "filename": "gcc/testsuite/g++.dg/concepts/req12.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq12.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/66218\n+// { dg-options \"-std=c++1z\" }\n+\n+#include <type_traits>\n+\n+template <class T, class U>\n+concept bool Same =\n+  std::is_same<T, U>::value;\n+\n+template <class T>\n+concept bool C =\n+  requires(T t) {\n+    { t } -> Same<T>;\n+  };\n+\n+template <class>\n+constexpr bool f() { return false; }\n+template <C>\n+constexpr bool f() { return true; }\n+\n+static_assert(f<char>(), \"\");\n+static_assert(f<int>(), \"\");\n+static_assert(f<double>(), \"\");\n+\n+int main() {}"}, {"sha": "54fcd8b0678cbc75cd2e9dc4f698d30cb4f1feea", "filename": "gcc/testsuite/g++.dg/concepts/req13.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq13.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/66758\n+// { dg-options \"-std=c++1z\" }\n+\n+template <class T, class...Args>\n+concept bool Constructible =\n+  requires(Args&&...args) {\n+    T{ ((Args&&)(args))... };\n+    new T{((Args&&)(args))...};\n+  };\n+\n+template <Constructible T> struct A { };\n+A<int> a;\n+"}, {"sha": "e86281a39313cd52d07dc3cb54847597e749d8b2", "filename": "gcc/testsuite/g++.dg/concepts/req14.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq14.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/66758\n+// { dg-options \"-std=c++1z\" }\n+\n+template <class T, class U>\n+concept bool C = requires (T t, U u) { t + u; };\n+\n+template <class T, class U>\n+requires C<T,U>\n+void f(T t, U u) { t + u; }\n+\n+int main()\n+{\n+  using T = decltype(f(42, 24));\n+}"}, {"sha": "09ebf89ef1be31e828a8f07f3bccd701a853430d", "filename": "gcc/testsuite/g++.dg/concepts/req15.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq15.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/66832\n+// { dg-options \"-std=c++1z\" }\n+\n+template <class T, class U, unsigned N>\n+  requires requires (T& t, U &u) { t.foo(); u.foo(); }\n+void foo_all( T (&t)[N], U (&u)[N] ) {\n+  for(auto& x : t)\n+      x.foo();\n+  for(auto& x : u)\n+      x.foo();\n+}\n+\n+struct S {\n+  void foo() {}\n+};\n+\n+int main() {\n+  S rg[4] {};\n+  foo_all(rg, rg);\n+}\n+"}, {"sha": "67ae5b5126cccc4148538422f197423dafc809e4", "filename": "gcc/testsuite/g++.dg/concepts/req16.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq16.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/66988\n+// { dg-options \"-std=c++1z\" }\n+\n+#include <type_traits>\n+\n+template <template <class> class T, class U>\n+concept bool _Valid = requires { typename T<U>; };\n+\n+template <class T>\n+using __t = typename T::type;\n+\n+template <class T>\n+struct __has_type : std::false_type { };\n+\n+template <class T>\n+  requires _Valid<__t, T>\n+struct __has_type<T> : std::true_type { };\n+\n+static_assert(!__has_type<int>(), \"\");"}, {"sha": "48bd0a8c2cd6122271df64326b8737e50ef13406", "filename": "gcc/testsuite/g++.dg/concepts/req17.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq17.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,20 @@\n+// PR c++/67018\n+// { dg-options \"-std=c++1z\" }\n+\n+template <typename T>\n+constexpr bool Val = true;\n+\n+template <class I>\n+concept bool InputIterator = requires (I i) {\n+  requires Val <decltype(i++)>;\n+};\n+\n+template <class I>\n+concept bool ForwardIterator = InputIterator<I> && true;\n+\n+template<InputIterator>\n+constexpr bool f() { return false; }\n+template<ForwardIterator>\n+constexpr bool f() { return true; }\n+\n+static_assert(f<int*>());"}, {"sha": "9a474376137edcd15c46248134885e55909b9a3d", "filename": "gcc/testsuite/g++.dg/concepts/req18.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq18.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template <class> struct all_same {\n+  static constexpr bool value = 1;\n+};\n+template <class T> concept bool Assignable\n+= requires(T t)\n+{\n+  requires all_same<decltype(t = 0)>::value;\n+};\n+\n+template <class I> requires !Assignable<I>\n+int dispatch();\n+template <Assignable>\n+void dispatch();\n+\n+int main() { dispatch<int *>(); }"}, {"sha": "a28f30b5b18d0a618e3ec1a8018860c392f811c4", "filename": "gcc/testsuite/g++.dg/concepts/req2.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,19 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool Class () { return __is_class(T); }\n+\n+void f1(auto a) requires Class<decltype(a)>() { }\n+\n+// FIXME: This is generating excess errors related to pretty\n+// printing the trailing requires expression.\n+void f2(auto a)\n+  requires requires (decltype(a) x) { -x; }\n+{ }\n+\n+struct S { } s;\n+\n+int main() {\n+  f1(0); // { dg-error \"cannot call\" }\n+  f2((void*)0); // { dg-error \"cannot call\" }\n+}"}, {"sha": "69581ee43eac2ed358393e1e3521576a8e458cd2", "filename": "gcc/testsuite/g++.dg/concepts/req3.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq3.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool Class () { return __is_class(T); }\n+\n+struct Test {\n+  void f(auto a) requires Class<decltype(a)>();\n+} test;\n+\n+struct S { }s;\n+\n+int main() {\n+  test.f(s);\n+}\n+\n+void Test::f(auto a) requires Class<decltype(a)>() { }"}, {"sha": "20778342e52bf05e2f3e9096ff2d432944b756a1", "filename": "gcc/testsuite/g++.dg/concepts/req4.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq4.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+struct fool {\n+  constexpr fool operator&&(fool) const { return {}; }\n+  constexpr fool operator||(fool) const { return {}; }\n+};\n+\n+template<typename T> constexpr fool p1() { return {}; }\n+template<typename T> constexpr fool p2() { return {}; }\n+\n+template<typename T>\n+  concept bool C() { return p1<T>() && p2<T>(); } // { dg-error \"does not have type\" }\n+\n+template<C T> void f(T x) { }\n+\n+int main() {\n+  f(0); // { dg-error \"cannot call\" }\n+}"}, {"sha": "c0af1f8849546efd0d3ddf268d051368bda7069e", "filename": "gcc/testsuite/g++.dg/concepts/req5.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq5.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+struct fool { };\n+\n+constexpr fool operator&&(fool, fool) { return {}; }\n+constexpr fool operator||(fool, fool) { return {}; }\n+\n+template<typename T> constexpr fool p1() { return {}; }\n+template<typename T> constexpr fool p2() { return {}; }\n+\n+template<typename T>\n+  concept bool C() { return p1<T>() && p2<T>(); } // { dg-error \"does not have type\" }\n+\n+template<C T> void f(T x) { }\n+\n+int main() {\n+  f(0); // { dg-error \"cannot call\" }\n+}"}, {"sha": "e4f20ecb67ca225dc5bc13aedd066c4897533490", "filename": "gcc/testsuite/g++.dg/concepts/req6.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq6.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+struct X { };\n+int operator==(X, X) { return 0; }\n+\n+template<typename T>\n+  concept bool C1() { return X(); }\n+\n+template<C1 T>\n+  void h(T) { } // { dg-error \"not|bool\" }\n+\n+template<typename T>\n+  concept bool C2() { return X() == X(); } // OK"}, {"sha": "51aba7b2e6f584a17593298ea8941b461251c3f2", "filename": "gcc/testsuite/g++.dg/concepts/req7.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq7.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,24 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+#include <vector>\n+\n+using namespace std;\n+\n+template<typename T>\n+  struct Sequence : std::false_type { };\n+\n+template<typename T>\n+  struct Predicate : std::false_type { };\n+\n+template<typename Seq, typename Fn>\n+  requires Sequence<Seq>{} and Predicate<Fn>{}\n+    bool all(const Seq& seq, Fn fn) {\n+      for(const auto& x : seq)\n+        if (not fn(x))\n+          return false;\n+      return true;\n+    }\n+\n+int main() {\n+  all(vector<int>{0, 2}, true); // { dg-error \"not|bool\" }\n+}"}, {"sha": "35c08541b60c725eed88a9c9d7aa09b56e0a3d63", "filename": "gcc/testsuite/g++.dg/concepts/req8.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq8.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++1z\" }\n+\n+// Check that type requirements are normalized correctly.\n+\n+template<typename T>\n+  concept bool Has_member_type() {\n+    return requires() { typename T::type; };\n+  }\n+\n+template<typename T>\n+  concept bool Concept() {\n+    return true && Has_member_type<T>();\n+  }\n+\n+template<Concept T>\n+  void foo( T t  ) { }"}, {"sha": "5654be0a0fe4634d53bdf5a8182502b997fd9aba", "filename": "gcc/testsuite/g++.dg/concepts/req9.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Freq9.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,24 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+struct S1 {};\n+\n+template<typename T>\n+concept bool C() { return requires(T x) { { x.fn() } -> S1<T>; }; }\n+\n+template<C U>\n+void fn(U x)\n+{\n+  x.fn();\n+}\n+\n+struct S2\n+{\n+  auto fn() const { return S1<S2>(); }\n+};\n+\n+int main()\n+{\n+  fn(S2{});\n+  return 0;\n+}"}, {"sha": "20a7fb6b1c354e71b2e79eea3ac7770570a422db", "filename": "gcc/testsuite/g++.dg/concepts/template-parm1.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,34 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C1 = __is_same_as(T, int);\n+\n+template<int N>\n+  concept bool C2 = N == 0;\n+\n+template<template<typename> class X>\n+  concept bool C3 = true;\n+\n+template<typename> struct Foo;\n+\n+// Type template parameters\n+template<C1 T = int> struct S1 { };\n+template<C1 = int> struct S2;\n+template<C1 T> struct S2 { };\n+\n+// Non-type template parameters\n+template<C2 N = 0> struct S3 { };\n+template<C2 = 0> struct S4;\n+template<C2 N> struct S4 { };\n+\n+// Template template parameters\n+template<C3 X = Foo> struct S5 { };\n+template<C3 = Foo> struct S6;\n+template<C3 X> struct S6 { };\n+\n+S1<> s1;\n+S2<> s2;\n+S3<> s3;\n+S4<> s4;\n+S5<> s5;\n+S6<> s6;"}, {"sha": "b80328995b0d738b9013641e7e98ff6429d350e1", "filename": "gcc/testsuite/g++.dg/concepts/template-parm10.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm10.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<int N, class T>\n+  concept bool P() { return true; }\n+\n+template<template<typename> class X, class T>\n+  concept bool Q() { return true; }\n+\n+template<P<int> N> void f() { }\n+template<Q<int> X> void g() { }\n+\n+template<typename> struct S { };\n+\n+int main() {\n+  f<0>();\n+  g<S>();\n+}"}, {"sha": "95ce78451167db2a264aa8cd3baff236f5f1020a", "filename": "gcc/testsuite/g++.dg/concepts/template-parm11.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm11.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+concept bool NameProvider()\n+{\n+  return requires(){\n+    typename T::_name_t::template _member_t<int>;\n+  };\n+}\n+\n+template<NameProvider... ColSpec>\n+void getTable(const ColSpec&...)\n+{}\n+\n+int f()\n+{\n+  getTable(7, 'a'); // { dg-error \"cannot call\" }\n+};"}, {"sha": "1639f26dbf103588f81d5c1f8f7ffbe8ab20dff0", "filename": "gcc/testsuite/g++.dg/concepts/template-parm12.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm12.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,20 @@\n+// Conceptized version of template/ttp23.C\n+// { dg-options \"-std=c++1z\" }\n+\n+template <class T> concept bool Foo = true;\n+\n+template <typename T> struct A {};\n+\n+template <template <Foo> class P>\n+struct B {\n+    template <template <Foo> class Q>\n+    friend bool foo (const B<Q>& a);\n+};\n+\n+template <template <typename> class Q>\n+bool foo (const B<Q>& a);\n+\n+void bar () {\n+  B<A> a;\n+  foo (a);\n+}"}, {"sha": "ad715e11a32411e116c69469eb23c9c96d0387b5", "filename": "gcc/testsuite/g++.dg/concepts/template-parm2.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,23 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C1 = __is_same_as(T, int);\n+\n+template<int N>\n+  concept bool C2 = N == 0;\n+\n+template<template<typename> class X>\n+  concept bool C3 = false;\n+\n+template<typename> struct Foo;\n+\n+// Instantiation of default arguments happens at the point of\n+// instantiation for the class.\n+\n+template<C1 T = char> struct S1 { };\n+template<C2 N = 1> struct S2 { };\n+template<C3 X = Foo> struct S3 { };\n+\n+S1<> s1; // { dg-error \"constraint failure|invalid type\" }\n+S2<> s2; // { dg-error \"constraint failure|invalid type\" }\n+S3<> s3; // { dg-error \"constraint failure|invalid type\" }"}, {"sha": "e412fb4ca1258b65616f3c7c93ad0fd31922a0c9", "filename": "gcc/testsuite/g++.dg/concepts/template-parm3.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm3.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,28 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C1 = __is_same_as(T, int);\n+\n+template<int N>\n+  concept bool C2 = N == 0;\n+\n+template<template<typename> class X>\n+  concept bool C3 = true;\n+\n+template<typename> struct Foo;\n+\n+template<C1...> struct S1;\n+template<C1... Ts> struct S1 { };\n+\n+template<C2...> struct S2;\n+template<C2... Ns> struct S2 { };\n+\n+template<C3...> struct S3;\n+template<C3... Xs> struct S3 { };\n+\n+S1<int, int, int> s1; // OK\n+S1<> s11;\n+S2<0, 0, 0> s2;\n+S2<> s22;\n+S3<Foo, Foo> s3;\n+S3<> s33;"}, {"sha": "a29bb11a6799c62f01ea020eb9e6a4aeaea10c0e", "filename": "gcc/testsuite/g++.dg/concepts/template-parm4.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm4.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,20 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C1 = __is_same_as(T, int);\n+\n+template<int N>\n+  concept bool C2 = N == 0;\n+\n+template<template<typename> class X>\n+  concept bool C3 = false;\n+\n+template<typename> struct Foo;\n+\n+template<C1... Ts> struct S1 { };\n+template<C2... Ns> struct S2 { };\n+template<C3... Xs> struct S3 { };\n+\n+S1<int, int, bool> s1; // { dg-error \"constraint failure|invalid type\" }\n+S2<0, 1, 2> s2; // { dg-error \"constraint failure|invalid type\" }\n+S3<Foo> s3; // { dg-error \"constraint failure|invalid type\" }"}, {"sha": "f33742becd25151ecb74e94de0c693a73042d451", "filename": "gcc/testsuite/g++.dg/concepts/template-parm5.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm5.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,19 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C1 = __is_same_as(T, int);\n+\n+template<int N>\n+  concept bool C2 = N == 0;\n+\n+template<template<typename> class X>\n+  concept bool C3 = true;\n+\n+template<typename> struct Foo;\n+\n+template<C1... Ts = int> struct S1; // { dg-error \"default argument\" }\n+template<C1... = int> struct S2; // { dg-error \"default argument\" }\n+template<C2... Ns = 0> struct S3; // { dg-error \"default argument\" }\n+template<C2... = 0> struct S4; // { dg-error \"default argument\" }\n+template<C3... Ts = Foo> struct S5; // { dg-error \"default argument\" }\n+template<C3... = Foo> struct S6; // { dg-error \"default argument\" }"}, {"sha": "d23f2594b4650b7b28dc374b5547b7a47f58b323", "filename": "gcc/testsuite/g++.dg/concepts/template-parm6.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm6.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,41 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename... Ts> struct are_same;\n+\n+template<>\n+  struct are_same<> {\n+    static constexpr bool value = true;\n+  };\n+\n+template<typename T>\n+  struct are_same<T> {\n+    static constexpr bool value = true;\n+  };\n+\n+template<typename T, typename U, typename... Ts>\n+  struct are_same<T, U, Ts...> {\n+    static constexpr bool value =\n+      __is_same_as(T, U) && are_same<U, Ts...>::value;\n+  };\n+\n+constexpr bool all_of() { return true; }\n+constexpr bool all_of(bool b) { return b; }\n+\n+template<typename... Ts>\n+  constexpr bool all_of(bool a, bool b, Ts... args) {\n+    return (a && b) && all_of(b, args...);\n+  }\n+\n+template<typename... Ts>\n+  concept bool C1 = are_same<Ts...>::value;\n+\n+template<bool... Bs>\n+  concept bool C2 = all_of(Bs...);\n+\n+template<C1... Ts> struct S1 { };\n+template<C1...> struct S2 { };\n+template<C2... Bs> struct S4 { };\n+template<C2...> struct S5 { };\n+\n+S1<int, int, int> s1;\n+S4<true, true, true> s4;"}, {"sha": "10869840fdde3946a7a0263a8a29b1f2ce5f3736", "filename": "gcc/testsuite/g++.dg/concepts/template-parm7.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm7.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,44 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename... Ts> struct are_same;\n+\n+template<>\n+  struct are_same<> {\n+    static constexpr bool value = true;\n+  };\n+\n+template<typename T>\n+  struct are_same<T> {\n+    static constexpr bool value = true;\n+  };\n+\n+template<typename T, typename U, typename... Ts>\n+  struct are_same<T, U, Ts...> {\n+    static constexpr bool value =\n+      __is_same_as(T, U) && are_same<U, Ts...>::value;\n+  };\n+\n+constexpr bool all_of() { return true; }\n+constexpr bool all_of(bool b) { return b; }\n+\n+template<typename... Ts>\n+  constexpr bool all_of(bool a, bool b, Ts... args) {\n+    return (a && b) && all_of(b, args...);\n+  }\n+\n+\n+template<typename... Ts>\n+  concept bool C1 = are_same<Ts...>::value;\n+\n+template<bool... Bs>\n+  concept bool C2 = all_of(Bs...);\n+\n+template<C1... Ts> struct S1 { }; // OK\n+S1<int, int, char> s1; // { dg-error \"constraint failure|invalid type\" }\n+template<C1 Ts> struct S2 { }; // { dg-error \"variadic constraint\"  }\n+\n+template<C2... Bs> struct S3 { }; // OK\n+S3<true, true, false> s3; // { dg-error \"constraint failure|invalid type\" }\n+template<C2 Bs> struct S4 { }; // { dg-error \"variadic constraint\" }\n+\n+int main() { }"}, {"sha": "f604d5a6a2b0cddbd2864c5748e10c1d9b1fb37e", "filename": "gcc/testsuite/g++.dg/concepts/template-parm8.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm8.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,21 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool D() { return C<T>() and __is_empty(T); }\n+\n+template<template<typename Q> requires C<Q>() class X>\n+  struct S { };\n+\n+// An unconstrained template can be used as an argument for any\n+// constrained template template parameter.\n+template<typename A> struct T0 { };\n+S<T0> x1;\n+\n+// Matching constraints are valid.\n+template<typename A> requires C<A>() struct T1 { };\n+S<T1> x2;\n+\n+int main() { }"}, {"sha": "7e6898405ae5263d10bdd71be2103e6b7d20fa39", "filename": "gcc/testsuite/g++.dg/concepts/template-parm9.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-parm9.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool D() { return C<T>() and __is_empty(T); }\n+\n+template<template<typename Q> requires C<Q>() class X>\n+  struct S { };\n+\n+template<typename A> requires true struct T0 { };\n+template<typename A> requires D<A>() struct T1 { };\n+\n+S<T0> x3; // { dg-error \"constraint mismatch|invalid type\" }\n+S<T1> x4; // { dg-error \"constraint mismatch|invalid type\" }\n+\n+int main() { }"}, {"sha": "40912843714b266aa1ec02254b1b4e6965a090ef", "filename": "gcc/testsuite/g++.dg/concepts/template-template-parm1.C", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-template-parm1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-template-parm1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftemplate-template-parm1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,56 @@\n+// PR c++/66937\n+// { dg-options -std=c++1z }\n+\n+#include <tuple>\n+\n+namespace detail\n+{\n+  template<typename T, template<typename...> class Sink>\n+  struct copy_tuple_args_impl;\n+\n+  template<typename... Args, template<typename...> class Sink>\n+  struct copy_tuple_args_impl<std::tuple<Args...>, Sink>\n+  {\n+    using type = Sink<Args...>;\n+  };\n+}\n+\n+// copy_tuple_args copies the template arguments of a tuple into another template\n+// copy_tuple_args does not care about constraints whatsoever.\n+template<typename Tuple, template<typename...> class Sink>\n+using copy_tuple_args = typename detail::copy_tuple_args_impl<Tuple, Sink>::type;\n+\n+// A concept of a column\n+template <typename T>\n+concept bool Column()\n+{\n+  return requires()\n+    {\n+      typename T::_name_t;\n+    };\n+}\n+\n+// column_list is constrained to Column arguments\n+template<Column... C>\n+struct column_list\n+{\n+};\n+\n+// Here are some columns\n+struct A\n+{\n+  using _name_t = int;\n+};\n+\n+struct B\n+{\n+  using _name_t = int;\n+};\n+\n+\n+int main()\n+{\n+  using ColumnTuple = std::tuple<A, B>;\n+  using ColumnList = copy_tuple_args<ColumnTuple, column_list>; // This fails, but should not\n+}\n+"}, {"sha": "f07c878747295e0b769a6dcf10fd29a4e9d5ed09", "filename": "gcc/testsuite/g++.dg/concepts/traits1.C", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftraits1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftraits1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftraits1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,97 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool Nothrow_assignable() { return __has_nothrow_assign(T); }\n+\n+template<typename T>\n+  concept bool Nothrow_constructible() { return __has_nothrow_constructor(T); }\n+\n+template<typename T>\n+  concept bool Nothrow_copyable() { return __has_nothrow_copy(T); }\n+\n+template<typename T>\n+  concept bool Trivially_assignable() { return __has_trivial_assign(T); }\n+\n+template<typename T>\n+  concept bool Trivially_constructible() { return __has_trivial_constructor(T); }\n+\n+template<typename T>\n+  concept bool Trivially_copyable() { return __has_trivial_copy(T); }\n+\n+template<typename T>\n+  concept bool Trivially_destructible() { return __has_trivial_destructor(T); }\n+\n+template<typename T>\n+  concept bool Dynamically_destructible() { return __has_virtual_destructor(T); }\n+\n+template<typename T>\n+  concept bool Abstract() { return __is_abstract(T); }\n+\n+template<typename T>\n+  concept bool Polymorphic() { return __is_polymorphic(T); }\n+\n+template<typename T>\n+  concept bool Class() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool Empty() { return __is_empty(T); }\n+\n+template<typename T>\n+  concept bool Enum() { return __is_enum(T); }\n+\n+template<typename T>\n+  concept bool Final() { return __is_final(T); }\n+\n+template<typename T>\n+  concept bool Literal_type() { return __is_literal_type(T); }\n+\n+template<typename T>\n+  concept bool Pod() { return __is_pod(T); }\n+\n+template<typename T>\n+  concept bool Standard_layout() { return __is_standard_layout(T); }\n+\n+template<typename T>\n+  concept bool Trivial() { return __is_trivial(T); }\n+\n+template<typename T>\n+  concept bool Union() { return __is_union(T); }\n+\n+template<Nothrow_assignable T> void f1() { }\n+template<Nothrow_copyable T> void f2() { }\n+template<Nothrow_constructible T> void f3() { }\n+template<Trivially_assignable T> void f4() { }\n+template<Trivially_copyable T> void f5() { }\n+template<Trivially_constructible T> void f6() { }\n+template<Trivially_destructible T> void f7() { }\n+template<Dynamically_destructible T> void f8() { }\n+template<Class T> void f9() { }\n+template<Empty T> void f10() { }\n+template<Standard_layout T> void f11() { }\n+template<Pod T> void f12() { }\n+template<Trivial T> void f13() { }\n+template<Polymorphic T> void f14() { }\n+template<Abstract T> void f15() { }\n+template<Final T> void f16() { }\n+template<Union T> void f17() { }\n+template<Enum T> void f18() { }\n+\n+int main() {\n+  f1<void>(); // { dg-error \"cannot call\" }\n+  f2<void>(); // { dg-error \"cannot call\" }\n+  f3<void>(); // { dg-error \"cannot call\" }\n+  f4<void>(); // { dg-error \"cannot call\" }\n+  f5<void>(); // { dg-error \"cannot call\" }\n+  f6<void>(); // { dg-error \"cannot call\" }\n+  f7<void>(); // { dg-error \"cannot call\" }\n+  f8<void>(); // { dg-error \"cannot call\" }\n+  f9<void>(); // { dg-error \"cannot call\" }\n+  f10<void>(); // { dg-error \"cannot call\" }\n+  f11<void>(); // { dg-error \"cannot call\" }\n+  f12<void>(); // { dg-error \"cannot call\" }\n+  f13<void>(); // { dg-error \"cannot call\" }\n+  f14<void>(); // { dg-error \"cannot call\" }\n+  f15<void>(); // { dg-error \"cannot call\" }\n+  f16<void>(); // { dg-error \"cannot call\" }\n+  f17<void>(); // { dg-error \"cannot call\" }\n+}"}, {"sha": "28ced34c63e39684ee053fcd7d3a695c88b37e5f", "filename": "gcc/testsuite/g++.dg/concepts/traits2.C", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftraits2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftraits2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Ftraits2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,98 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool Nothrow_assignable() { return __has_nothrow_assign(T); }\n+\n+template<typename T>\n+  concept bool Nothrow_constructible() { return __has_nothrow_constructor(T); }\n+\n+template<typename T>\n+  concept bool Nothrow_copyable() { return __has_nothrow_copy(T); }\n+\n+template<typename T>\n+  concept bool Trivially_assignable() { return __has_trivial_assign(T); }\n+\n+template<typename T>\n+  concept bool Trivially_constructible() { return __has_trivial_constructor(T); }\n+\n+template<typename T>\n+  concept bool Trivially_copyable() { return __has_trivial_copy(T); }\n+\n+template<typename T>\n+  concept bool Trivially_destructible() { return __has_trivial_destructor(T); }\n+\n+template<typename T>\n+  concept bool Dynamically_destructible() { return __has_virtual_destructor(T); }\n+\n+template<typename T>\n+  concept bool Abstract() { return __is_abstract(T); }\n+\n+template<typename T>\n+  concept bool Polymorphic() { return __is_polymorphic(T); }\n+\n+template<typename T>\n+  concept bool Class() { return __is_class(T); }\n+\n+template<typename T>\n+  concept bool Empty() { return __is_empty(T); }\n+\n+template<typename T>\n+  concept bool Enum() { return __is_enum(T); }\n+\n+template<typename T>\n+  concept bool Final() { return __is_final(T); }\n+\n+template<typename T>\n+  concept bool Literal_type() { return __is_literal_type(T); }\n+\n+template<typename T>\n+  concept bool Pod() { return __is_pod(T); }\n+\n+template<typename T>\n+  concept bool Standard_layout() { return __is_standard_layout(T); }\n+\n+template<typename T>\n+  concept bool Trivial() { return __is_trivial(T); }\n+\n+template<typename T>\n+  concept bool Union() { return __is_union(T); }\n+\n+template<Nothrow_assignable T> void f1();\n+template<Nothrow_copyable T> void f2();\n+template<Nothrow_constructible T> void f3();\n+template<Trivially_assignable T> void f4();\n+template<Trivially_copyable T> void f5();\n+template<Trivially_constructible T> void f6();\n+template<Trivially_destructible T> void f7();\n+template<Dynamically_destructible T> void f8();\n+template<Class T> void f9();\n+template<Empty T> void f10();\n+template<Standard_layout T> void f11();\n+template<Pod T> void f12();\n+template<Trivial T> void f13();\n+template<Polymorphic T> void f14();\n+template<Abstract T> void f15();\n+template<Final T> void f16();\n+template<Union T> void f17();\n+template<Enum T> void f18();\n+\n+\n+int main() {\n+  f1<void>(); // { dg-error \"cannot call\" }\n+  f2<void>(); // { dg-error \"cannot call\" }\n+  f3<void>(); // { dg-error \"cannot call\" }\n+  f4<void>(); // { dg-error \"cannot call\" }\n+  f5<void>(); // { dg-error \"cannot call\" }\n+  f6<void>(); // { dg-error \"cannot call\" }\n+  f7<void>(); // { dg-error \"cannot call\" }\n+  f8<void>(); // { dg-error \"cannot call\" }\n+  f9<void>(); // { dg-error \"cannot call\" }\n+  f10<void>(); // { dg-error \"cannot call\" }\n+  f11<void>(); // { dg-error \"cannot call\" }\n+  f12<void>(); // { dg-error \"cannot call\" }\n+  f13<void>(); // { dg-error \"cannot call\" }\n+  f14<void>(); // { dg-error \"cannot call\" }\n+  f15<void>(); // { dg-error \"cannot call\" }\n+  f16<void>(); // { dg-error \"cannot call\" }\n+  f17<void>(); // { dg-error \"cannot call\" }\n+}"}, {"sha": "eb8a2b797a3941c215cd0a1a86a0a50d59213333", "filename": "gcc/testsuite/g++.dg/concepts/var-concept1.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,26 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+concept bool C1 = __is_class(T);\n+\n+template<typename T>\n+concept bool C2 = requires (T t) { t; };\n+\n+void f1(C1, C1) { }\n+\n+template<typename T>\n+  requires C2<T>\n+void f2(T) { }\n+\n+void f3(C2) { }\n+\n+struct S1 {};\n+\n+int main ()\n+{\n+  f1(S1(), S1());\n+  f2(0);\n+  f3(0);\n+\n+  return 0;\n+}"}, {"sha": "71663bdec5fb5ab7e1da005f36f6139095dac7f4", "filename": "gcc/testsuite/g++.dg/concepts/var-concept2.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C1 = __is_class(T);\n+\n+template<typename U>\n+  requires C1<U>\n+  void f1(U, U) { }\n+\n+void f2(C1) {}\n+\n+int main ()\n+{\n+  f1(0, 0); // { dg-error \"cannot call\" }\n+  f2(1); // { dg-error \"cannot call\" }\n+  return 0;\n+}"}, {"sha": "c90102848d4edea611638a79b4382b290198c99a", "filename": "gcc/testsuite/g++.dg/concepts/var-concept3.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept3.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,22 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T>\n+  concept bool C1 = __is_class(T);\n+\n+template<typename T>\n+  concept bool C2() { return __is_class(T); }\n+\n+template<typename T>\n+  constexpr bool C3 = __is_class(T);\n+\n+\n+template<typename U>\n+  requires C1<U>() // { dg-error \"\" }\n+  void f1(U) { }\n+\n+template<typename U>\n+  requires C2<U> // { dg-error \"invalid reference\" }\n+  void f2(U) { }\n+\n+template<C3 T>  // { dg-error \"not a type\" }\n+  void f(T) { } // { dg-error \"\" }"}, {"sha": "b39835396165bf8dd0d181711206f92c302cb4e9", "filename": "gcc/testsuite/g++.dg/concepts/var-concept4.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept4.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,19 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T, typename U>\n+concept bool Same = __is_same_as(T, U);\n+\n+template<typename T0, typename T1, typename T2, typename... T3toN>\n+concept bool Same<T0, T1, T2, T3toN...> = true; // { dg-error \"wrong number|does not match\" }\n+\n+template<typename T>\n+concept bool C1 = true;\n+\n+template<typename T>\n+concept bool C1<T*> = true; // { dg-error \"specialization of variable concept\" }\n+\n+template<typename T>\n+concept bool C2 = true;\n+\n+template<>\n+concept bool C2<int> = true; // { dg-error \"non-template variable\" }"}, {"sha": "13f86dd31247d20b970080dc1a7dd8c3a7d436c0", "filename": "gcc/testsuite/g++.dg/concepts/var-concept5.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept5.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,14 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template<typename T1, typename T2>\n+concept bool C1 = true;\n+\n+template<typename T1, typename T2, typename T3>\n+concept bool C2 = true;\n+\n+\n+template<C1 T> // { dg-error \"not a type\" }\n+constexpr bool f1( )  { return true; }\n+\n+template<C2<int> T> // { dg-error \"expected\" }\n+constexpr bool f2( )  { return true; }"}, {"sha": "2f775fd62e0f5dcbbcdc811b2cb1c18df65f3d3e", "filename": "gcc/testsuite/g++.dg/concepts/var-concept6.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept6.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,4 @@\n+// { dg-options -std=c++1z }\n+\n+template <class T>\n+concept int C = true;\t\t// { dg-error \"bool\" }"}, {"sha": "79476c354166c87bed0ebeef02f6299da7443076", "filename": "gcc/testsuite/g++.dg/concepts/var-templ1.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-templ1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-templ1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-templ1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/67117\n+// { dg-options -std=c++1z }\n+\n+template <class T>\n+  requires false\n+constexpr bool v = true;\n+\n+template <class T>\n+constexpr bool f() { return true; }\n+\n+template <class T>\n+  requires v<T>\n+constexpr bool f() { return false; }\n+\n+static_assert(f<void>());\n+static_assert(v<void>);\t\t// { dg-error \"constraints\" }"}, {"sha": "e615f21457dd233bec4c0ce420cdbed929464c28", "filename": "gcc/testsuite/g++.dg/concepts/var-templ2.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-templ2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-templ2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-templ2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/67139\n+// { dg-options -std=c++1z }\n+\n+template <class T>\n+constexpr typename T::type::value_type _v = T::type::value;\n+\n+template <class T> concept bool IsTrue_() { return _v<T>; }\n+\n+template <class T> concept bool Unpossible() {\n+  return IsTrue_<T &&>();\n+}\n+\n+template <class> constexpr bool unpossible() { return false; }\n+Unpossible{ T }\n+constexpr bool unpossible() { return true; }\n+\n+static_assert((!unpossible<void>()), \"\");"}, {"sha": "ed3d4f1e01d7baa8a7be95df7bc5ec7e748bf4df", "filename": "gcc/testsuite/g++.dg/concepts/variadic1.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic1.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/66712\n+// { dg-options \"-std=c++1z\" }\n+\n+template <class T, class...Args>\n+concept bool _Constructible_ =\n+  requires (Args&&...args)\n+  {\n+    T{ ((Args&&)(args))... };\n+  };\n+\n+template <class T, class...Args>\n+constexpr bool _constructible_() { return false; }\n+\n+_Constructible_{T, ...Args}\n+constexpr bool _constructible_() { return true; }\n+\n+struct S\n+{\n+  S(int, char const *);\n+};\n+\n+int main()\n+{\n+  static_assert(_constructible_<S, int, char const *>(), \"\");\n+}"}, {"sha": "6c552771d59c646cc4fce56f363abc9bcc1c5bd3", "filename": "gcc/testsuite/g++.dg/concepts/variadic2.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971e17ff87337ad533b51c2dff0bbdf607fa1faf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvariadic2.C?ref=971e17ff87337ad533b51c2dff0bbdf607fa1faf", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template <class T> concept bool Copyable = requires (T t) { T(t); };\n+template <class T> concept bool Constructable = requires { T(); };\n+template <class T> concept bool Both = Copyable<T> && Constructable<T>;\n+\n+template <Copyable... Ts> void f(Ts...) { }\n+template <Both... Ts> void f(Ts...) { }\n+\n+int main()\n+{\n+  f(42);\n+}"}]}