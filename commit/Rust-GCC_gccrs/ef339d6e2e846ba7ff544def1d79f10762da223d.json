{"sha": "ef339d6e2e846ba7ff544def1d79f10762da223d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYzMzlkNmUyZTg0NmJhN2ZmNTQ0ZGVmMWQ3OWYxMDc2MmRhMjIzZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-01T11:22:35Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-01T11:22:35Z"}, "message": "Add a VEC_SERIES rtl code\n\nThis patch adds an rtl representation of a vector linear series\nof the form:\n\n  a[I] = BASE + I * STEP\n\nLike vec_duplicate;\n\n- the new rtx can be used for both constant and non-constant vectors\n- when used for constant vectors it is wrapped in a (const ...)\n- the constant form is only used for variable-length vectors;\n  fixed-length vectors still use CONST_VECTOR\n\nAt the moment the code is restricted to integer elements, to avoid\nconcerns over floating-point rounding.\n\n2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* doc/rtl.texi (vec_series): Document.\n\t(const): Say that the operand can be a vec_series.\n\t* rtl.def (VEC_SERIES): New rtx code.\n\t* rtl.h (const_vec_series_p_1): Declare.\n\t(const_vec_series_p): New function.\n\t* emit-rtl.h (gen_const_vec_series): Declare.\n\t(gen_vec_series): Likewise.\n\t* emit-rtl.c (const_vec_series_p_1, gen_const_vec_series)\n\t(gen_vec_series): Likewise.\n\t* optabs.c (expand_mult_highpart): Use gen_const_vec_series.\n\t* simplify-rtx.c (simplify_unary_operation): Handle negations\n\tof vector series.\n\t(simplify_binary_operation_series): New function.\n\t(simplify_binary_operation_1): Use it.  Handle VEC_SERIES.\n\t(test_vector_ops_series): New function.\n\t(test_vector_ops): Call it.\n\t* config/powerpcspe/altivec.md (altivec_lvsl): Use\n\tgen_const_vec_series.\n\t(altivec_lvsr): Likewise.\n\t* config/rs6000/altivec.md (altivec_lvsl, altivec_lvsr): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254297", "tree": {"sha": "e5beefe9a80252715c035780b1f4819d67302440", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5beefe9a80252715c035780b1f4819d67302440"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef339d6e2e846ba7ff544def1d79f10762da223d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef339d6e2e846ba7ff544def1d79f10762da223d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef339d6e2e846ba7ff544def1d79f10762da223d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef339d6e2e846ba7ff544def1d79f10762da223d/comments", "author": null, "committer": null, "parents": [{"sha": "06ec586d2c384ba016c784de3279f3770d9f399d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06ec586d2c384ba016c784de3279f3770d9f399d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06ec586d2c384ba016c784de3279f3770d9f399d"}], "stats": {"total": 318, "additions": 293, "deletions": 25}, "files": [{"sha": "19ed9536b1486e0c7533a4cb490bfb5e30546921", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef339d6e2e846ba7ff544def1d79f10762da223d", "patch": "@@ -1,3 +1,28 @@\n+2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* doc/rtl.texi (vec_series): Document.\n+\t(const): Say that the operand can be a vec_series.\n+\t* rtl.def (VEC_SERIES): New rtx code.\n+\t* rtl.h (const_vec_series_p_1): Declare.\n+\t(const_vec_series_p): New function.\n+\t* emit-rtl.h (gen_const_vec_series): Declare.\n+\t(gen_vec_series): Likewise.\n+\t* emit-rtl.c (const_vec_series_p_1, gen_const_vec_series)\n+\t(gen_vec_series): Likewise.\n+\t* optabs.c (expand_mult_highpart): Use gen_const_vec_series.\n+\t* simplify-rtx.c (simplify_unary_operation): Handle negations\n+\tof vector series.\n+\t(simplify_binary_operation_series): New function.\n+\t(simplify_binary_operation_1): Use it.  Handle VEC_SERIES.\n+\t(test_vector_ops_series): New function.\n+\t(test_vector_ops): Call it.\n+\t* config/powerpcspe/altivec.md (altivec_lvsl): Use\n+\tgen_const_vec_series.\n+\t(altivec_lvsr): Likewise.\n+\t* config/rs6000/altivec.md (altivec_lvsl, altivec_lvsr): Likewise.\n+\n 2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "81373f581d1fc35d8d3cc4cd3607357ab93870dd", "filename": "gcc/config/powerpcspe/altivec.md", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2Fconfig%2Fpowerpcspe%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2Fconfig%2Fpowerpcspe%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Faltivec.md?ref=ef339d6e2e846ba7ff544def1d79f10762da223d", "patch": "@@ -2456,13 +2456,10 @@\n     emit_insn (gen_altivec_lvsl_direct (operands[0], operands[1]));\n   else\n     {\n-      int i;\n-      rtx mask, perm[16], constv, vperm;\n+      rtx mask, constv, vperm;\n       mask = gen_reg_rtx (V16QImode);\n       emit_insn (gen_altivec_lvsl_direct (mask, operands[1]));\n-      for (i = 0; i < 16; ++i)\n-        perm[i] = GEN_INT (i);\n-      constv = gen_rtx_CONST_VECTOR (V16QImode, gen_rtvec_v (16, perm));\n+      constv = gen_const_vec_series (V16QImode, const0_rtx, const1_rtx);\n       constv = force_reg (V16QImode, constv);\n       vperm = gen_rtx_UNSPEC (V16QImode, gen_rtvec (3, mask, mask, constv),\n                               UNSPEC_VPERM);\n@@ -2488,13 +2485,10 @@\n     emit_insn (gen_altivec_lvsr_direct (operands[0], operands[1]));\n   else\n     {\n-      int i;\n-      rtx mask, perm[16], constv, vperm;\n+      rtx mask, constv, vperm;\n       mask = gen_reg_rtx (V16QImode);\n       emit_insn (gen_altivec_lvsr_direct (mask, operands[1]));\n-      for (i = 0; i < 16; ++i)\n-        perm[i] = GEN_INT (i);\n-      constv = gen_rtx_CONST_VECTOR (V16QImode, gen_rtvec_v (16, perm));\n+      constv = gen_const_vec_series (V16QImode, const0_rtx, const1_rtx);\n       constv = force_reg (V16QImode, constv);\n       vperm = gen_rtx_UNSPEC (V16QImode, gen_rtvec (3, mask, mask, constv),\n                               UNSPEC_VPERM);"}, {"sha": "d0fcd1c3d8a9cb4533301dad61268829559fbedf", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=ef339d6e2e846ba7ff544def1d79f10762da223d", "patch": "@@ -2574,13 +2574,10 @@\n     emit_insn (gen_altivec_lvsl_direct (operands[0], operands[1]));\n   else\n     {\n-      int i;\n-      rtx mask, perm[16], constv, vperm;\n+      rtx mask, constv, vperm;\n       mask = gen_reg_rtx (V16QImode);\n       emit_insn (gen_altivec_lvsl_direct (mask, operands[1]));\n-      for (i = 0; i < 16; ++i)\n-        perm[i] = GEN_INT (i);\n-      constv = gen_rtx_CONST_VECTOR (V16QImode, gen_rtvec_v (16, perm));\n+      constv = gen_const_vec_series (V16QImode, const0_rtx, const1_rtx);\n       constv = force_reg (V16QImode, constv);\n       vperm = gen_rtx_UNSPEC (V16QImode, gen_rtvec (3, mask, mask, constv),\n                               UNSPEC_VPERM);\n@@ -2615,13 +2612,10 @@\n     emit_insn (gen_altivec_lvsr_direct (operands[0], operands[1]));\n   else\n     {\n-      int i;\n-      rtx mask, perm[16], constv, vperm;\n+      rtx mask, constv, vperm;\n       mask = gen_reg_rtx (V16QImode);\n       emit_insn (gen_altivec_lvsr_direct (mask, operands[1]));\n-      for (i = 0; i < 16; ++i)\n-        perm[i] = GEN_INT (i);\n-      constv = gen_rtx_CONST_VECTOR (V16QImode, gen_rtvec_v (16, perm));\n+      constv = gen_const_vec_series (V16QImode, const0_rtx, const1_rtx);\n       constv = force_reg (V16QImode, constv);\n       vperm = gen_rtx_UNSPEC (V16QImode, gen_rtvec (3, mask, mask, constv),\n                               UNSPEC_VPERM);"}, {"sha": "30fc68830ec699896307c7eaf2e4865b7215f9f2", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=ef339d6e2e846ba7ff544def1d79f10762da223d", "patch": "@@ -1677,7 +1677,8 @@ are target-specific and typically represent some form of relocation\n operator.  @var{m} should be a valid address mode.\n \n The second use of @code{const} is to wrap a vector operation.\n-In this case @var{exp} must be a @code{vec_duplicate} expression.\n+In this case @var{exp} must be a @code{vec_duplicate} or\n+@code{vec_series} expression.\n \n @findex high\n @item (high:@var{m} @var{exp})\n@@ -2722,6 +2723,10 @@ the same submodes as the input vector mode or the scalar modes, and the\n number of output parts must be an integer multiple of the number of input\n parts.\n \n+@findex vec_series\n+@item (vec_series:@var{m} @var{base} @var{step})\n+This operation creates a vector in which element @var{i} is equal to\n+@samp{@var{base} + @var{i}*@var{step}}.  @var{m} must be a vector integer mode.\n @end table\n \n @node Conversions"}, {"sha": "cfe0fcec8e2b22af4e2eb90db16b7f415b75c860", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ef339d6e2e846ba7ff544def1d79f10762da223d", "patch": "@@ -5797,6 +5797,69 @@ gen_vec_duplicate (machine_mode mode, rtx x)\n   return gen_rtx_VEC_DUPLICATE (mode, x);\n }\n \n+/* A subroutine of const_vec_series_p that handles the case in which\n+   X is known to be an integer CONST_VECTOR.  */\n+\n+bool\n+const_vec_series_p_1 (const_rtx x, rtx *base_out, rtx *step_out)\n+{\n+  unsigned int nelts = CONST_VECTOR_NUNITS (x);\n+  if (nelts < 2)\n+    return false;\n+\n+  scalar_mode inner = GET_MODE_INNER (GET_MODE (x));\n+  rtx base = CONST_VECTOR_ELT (x, 0);\n+  rtx step = simplify_binary_operation (MINUS, inner,\n+\t\t\t\t\tCONST_VECTOR_ELT (x, 1), base);\n+  if (rtx_equal_p (step, CONST0_RTX (inner)))\n+    return false;\n+\n+  for (unsigned int i = 2; i < nelts; ++i)\n+    {\n+      rtx diff = simplify_binary_operation (MINUS, inner,\n+\t\t\t\t\t    CONST_VECTOR_ELT (x, i),\n+\t\t\t\t\t    CONST_VECTOR_ELT (x, i - 1));\n+      if (!rtx_equal_p (step, diff))\n+\treturn false;\n+    }\n+\n+  *base_out = base;\n+  *step_out = step;\n+  return true;\n+}\n+\n+/* Generate a vector constant of mode MODE in which element I has\n+   the value BASE + I * STEP.  */\n+\n+rtx\n+gen_const_vec_series (machine_mode mode, rtx base, rtx step)\n+{\n+  gcc_assert (CONSTANT_P (base) && CONSTANT_P (step));\n+\n+  int nunits = GET_MODE_NUNITS (mode);\n+  rtvec v = rtvec_alloc (nunits);\n+  scalar_mode inner_mode = GET_MODE_INNER (mode);\n+  RTVEC_ELT (v, 0) = base;\n+  for (int i = 1; i < nunits; ++i)\n+    RTVEC_ELT (v, i) = simplify_gen_binary (PLUS, inner_mode,\n+\t\t\t\t\t    RTVEC_ELT (v, i - 1), step);\n+  return gen_rtx_raw_CONST_VECTOR (mode, v);\n+}\n+\n+/* Generate a vector of mode MODE in which element I has the value\n+   BASE + I * STEP.  The result will be a constant if BASE and STEP\n+   are both constants.  */\n+\n+rtx\n+gen_vec_series (machine_mode mode, rtx base, rtx step)\n+{\n+  if (step == const0_rtx)\n+    return gen_vec_duplicate (mode, base);\n+  if (CONSTANT_P (base) && CONSTANT_P (step))\n+    return gen_const_vec_series (mode, base, step);\n+  return gen_rtx_VEC_SERIES (mode, base, step);\n+}\n+\n /* Generate a new vector constant for mode MODE and constant value\n    CONSTANT.  */\n "}, {"sha": "ab320e65e21ed75a3921ec8c0d48dc8206442730", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=ef339d6e2e846ba7ff544def1d79f10762da223d", "patch": "@@ -441,6 +441,9 @@ get_max_uid (void)\n extern rtx gen_const_vec_duplicate (machine_mode, rtx);\n extern rtx gen_vec_duplicate (machine_mode, rtx);\n \n+extern rtx gen_const_vec_series (machine_mode, rtx, rtx);\n+extern rtx gen_vec_series (machine_mode, rtx, rtx);\n+\n extern void set_decl_incoming_rtl (tree, rtx, bool);\n \n /* Return a memory reference like MEMREF, but with its mode changed"}, {"sha": "7b3d59532f07f2378455ea2a15935f543f8eef6a", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=ef339d6e2e846ba7ff544def1d79f10762da223d", "patch": "@@ -5785,13 +5785,13 @@ expand_mult_highpart (machine_mode mode, rtx op0, rtx op1,\n       for (i = 0; i < nunits; ++i)\n \tRTVEC_ELT (v, i) = GEN_INT (!BYTES_BIG_ENDIAN + (i & ~1)\n \t\t\t\t    + ((i & 1) ? nunits : 0));\n+      perm = gen_rtx_CONST_VECTOR (mode, v);\n     }\n   else\n     {\n-      for (i = 0; i < nunits; ++i)\n-\tRTVEC_ELT (v, i) = GEN_INT (2 * i + (BYTES_BIG_ENDIAN ? 0 : 1));\n+      int base = BYTES_BIG_ENDIAN ? 0 : 1;\n+      perm = gen_const_vec_series (mode, GEN_INT (base), GEN_INT (2));\n     }\n-  perm = gen_rtx_CONST_VECTOR (mode, v);\n \n   return expand_vec_perm (mode, m1, m2, perm, target);\n }"}, {"sha": "ee7b7e1952438e111c050fbbfb7ff0b0c79438af", "filename": "gcc/rtl.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=ef339d6e2e846ba7ff544def1d79f10762da223d", "patch": "@@ -710,6 +710,11 @@ DEF_RTL_EXPR(VEC_CONCAT, \"vec_concat\", \"ee\", RTX_BIN_ARITH)\n    an integer multiple of the number of input parts.  */\n DEF_RTL_EXPR(VEC_DUPLICATE, \"vec_duplicate\", \"e\", RTX_UNARY)\n \n+/* Creation of a vector in which element I has the value BASE + I * STEP,\n+   where BASE is the first operand and STEP is the second.  The result\n+   must have a vector integer mode.  */\n+DEF_RTL_EXPR(VEC_SERIES, \"vec_series\", \"ee\", RTX_BIN_ARITH)\n+\n /* Addition with signed saturation */\n DEF_RTL_EXPR(SS_PLUS, \"ss_plus\", \"ee\", RTX_COMM_ARITH)\n "}, {"sha": "a0f696592999559fcc032d947d8961b6c89e9459", "filename": "gcc/rtl.h", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ef339d6e2e846ba7ff544def1d79f10762da223d", "patch": "@@ -2816,6 +2816,51 @@ unwrap_const_vec_duplicate (T x)\n   return x;\n }\n \n+/* In emit-rtl.c.  */\n+extern bool const_vec_series_p_1 (const_rtx, rtx *, rtx *);\n+\n+/* Return true if X is a constant vector that contains a linear series\n+   of the form:\n+\n+   { B, B + S, B + 2 * S, B + 3 * S, ... }\n+\n+   for a nonzero S.  Store B and S in *BASE_OUT and *STEP_OUT on sucess.  */\n+\n+inline bool\n+const_vec_series_p (const_rtx x, rtx *base_out, rtx *step_out)\n+{\n+  if (GET_CODE (x) == CONST_VECTOR\n+      && GET_MODE_CLASS (GET_MODE (x)) == MODE_VECTOR_INT)\n+    return const_vec_series_p_1 (x, base_out, step_out);\n+  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == VEC_SERIES)\n+    {\n+      *base_out = XEXP (XEXP (x, 0), 0);\n+      *step_out = XEXP (XEXP (x, 0), 1);\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Return true if X is a vector that contains a linear series of the\n+   form:\n+\n+   { B, B + S, B + 2 * S, B + 3 * S, ... }\n+\n+   where B and S are constant or nonconstant.  Store B and S in\n+   *BASE_OUT and *STEP_OUT on sucess.  */\n+\n+inline bool\n+vec_series_p (const_rtx x, rtx *base_out, rtx *step_out)\n+{\n+  if (GET_CODE (x) == VEC_SERIES)\n+    {\n+      *base_out = XEXP (x, 0);\n+      *step_out = XEXP (x, 1);\n+      return true;\n+    }\n+  return const_vec_series_p (x, base_out, step_out);\n+}\n+\n /* Return the unpromoted (outer) mode of SUBREG_PROMOTED_VAR_P subreg X.  */\n \n inline scalar_int_mode"}, {"sha": "8bee8edc870f0ee50e6d30d5ddba334c361b6e4c", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 135, "deletions": 1, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef339d6e2e846ba7ff544def1d79f10762da223d/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=ef339d6e2e846ba7ff544def1d79f10762da223d", "patch": "@@ -927,7 +927,7 @@ static rtx\n simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n {\n   enum rtx_code reversed;\n-  rtx temp, elt;\n+  rtx temp, elt, base, step;\n   scalar_int_mode inner, int_mode, op_mode, op0_mode;\n \n   switch (code)\n@@ -1185,6 +1185,22 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \t      return simplify_gen_unary (TRUNCATE, int_mode, temp, inner);\n \t    }\n \t}\n+\n+      if (vec_series_p (op, &base, &step))\n+\t{\n+\t  /* Only create a new series if we can simplify both parts.  In other\n+\t     cases this isn't really a simplification, and it's not necessarily\n+\t     a win to replace a vector operation with a scalar operation.  */\n+\t  scalar_mode inner_mode = GET_MODE_INNER (mode);\n+\t  base = simplify_unary_operation (NEG, inner_mode, base, inner_mode);\n+\t  if (base)\n+\t    {\n+\t      step = simplify_unary_operation (NEG, inner_mode,\n+\t\t\t\t\t       step, inner_mode);\n+\t      if (step)\n+\t\treturn gen_vec_series (mode, base, step);\n+\t    }\n+\t}\n       break;\n \n     case TRUNCATE:\n@@ -2156,6 +2172,46 @@ simplify_binary_operation (enum rtx_code code, machine_mode mode,\n   return NULL_RTX;\n }\n \n+/* Subroutine of simplify_binary_operation_1 that looks for cases in\n+   which OP0 and OP1 are both vector series or vector duplicates\n+   (which are really just series with a step of 0).  If so, try to\n+   form a new series by applying CODE to the bases and to the steps.\n+   Return null if no simplification is possible.\n+\n+   MODE is the mode of the operation and is known to be a vector\n+   integer mode.  */\n+\n+static rtx\n+simplify_binary_operation_series (rtx_code code, machine_mode mode,\n+\t\t\t\t  rtx op0, rtx op1)\n+{\n+  rtx base0, step0;\n+  if (vec_duplicate_p (op0, &base0))\n+    step0 = const0_rtx;\n+  else if (!vec_series_p (op0, &base0, &step0))\n+    return NULL_RTX;\n+\n+  rtx base1, step1;\n+  if (vec_duplicate_p (op1, &base1))\n+    step1 = const0_rtx;\n+  else if (!vec_series_p (op1, &base1, &step1))\n+    return NULL_RTX;\n+\n+  /* Only create a new series if we can simplify both parts.  In other\n+     cases this isn't really a simplification, and it's not necessarily\n+     a win to replace a vector operation with a scalar operation.  */\n+  scalar_mode inner_mode = GET_MODE_INNER (mode);\n+  rtx new_base = simplify_binary_operation (code, inner_mode, base0, base1);\n+  if (!new_base)\n+    return NULL_RTX;\n+\n+  rtx new_step = simplify_binary_operation (code, inner_mode, step0, step1);\n+  if (!new_step)\n+    return NULL_RTX;\n+\n+  return gen_vec_series (mode, new_base, new_step);\n+}\n+\n /* Subroutine of simplify_binary_operation.  Simplify a binary operation\n    CODE with result mode MODE, operating on OP0 and OP1.  If OP0 and/or\n    OP1 are constant pool references, TRUEOP0 and TRUEOP1 represent the\n@@ -2335,6 +2391,14 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t  if (tem)\n \t    return tem;\n \t}\n+\n+      /* Handle vector series.  */\n+      if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n+\t{\n+\t  tem = simplify_binary_operation_series (code, mode, op0, op1);\n+\t  if (tem)\n+\t    return tem;\n+\t}\n       break;\n \n     case COMPARE:\n@@ -2546,6 +2610,14 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t      || plus_minus_operand_p (op1))\n \t  && (tem = simplify_plus_minus (code, mode, op0, op1)) != 0)\n \treturn tem;\n+\n+      /* Handle vector series.  */\n+      if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n+\t{\n+\t  tem = simplify_binary_operation_series (code, mode, op0, op1);\n+\t  if (tem)\n+\t    return tem;\n+\t}\n       break;\n \n     case MULT:\n@@ -3499,6 +3571,11 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n       /* ??? There are simplifications that can be done.  */\n       return 0;\n \n+    case VEC_SERIES:\n+      if (op1 == CONST0_RTX (GET_MODE_INNER (mode)))\n+\treturn gen_vec_duplicate (mode, op0);\n+      return 0;\n+\n     case VEC_SELECT:\n       if (!VECTOR_MODE_P (mode))\n \t{\n@@ -6494,6 +6571,60 @@ test_vector_ops_duplicate (machine_mode mode, rtx scalar_reg)\n     }\n }\n \n+/* Test vector simplifications involving VEC_SERIES in which the\n+   operands and result have vector mode MODE.  SCALAR_REG is a pseudo\n+   register that holds one element of MODE.  */\n+\n+static void\n+test_vector_ops_series (machine_mode mode, rtx scalar_reg)\n+{\n+  /* Test unary cases with VEC_SERIES arguments.  */\n+  scalar_mode inner_mode = GET_MODE_INNER (mode);\n+  rtx duplicate = gen_rtx_VEC_DUPLICATE (mode, scalar_reg);\n+  rtx neg_scalar_reg = gen_rtx_NEG (inner_mode, scalar_reg);\n+  rtx series_0_r = gen_rtx_VEC_SERIES (mode, const0_rtx, scalar_reg);\n+  rtx series_0_nr = gen_rtx_VEC_SERIES (mode, const0_rtx, neg_scalar_reg);\n+  rtx series_nr_1 = gen_rtx_VEC_SERIES (mode, neg_scalar_reg, const1_rtx);\n+  rtx series_r_m1 = gen_rtx_VEC_SERIES (mode, scalar_reg, constm1_rtx);\n+  rtx series_r_r = gen_rtx_VEC_SERIES (mode, scalar_reg, scalar_reg);\n+  rtx series_nr_nr = gen_rtx_VEC_SERIES (mode, neg_scalar_reg,\n+\t\t\t\t\t neg_scalar_reg);\n+  ASSERT_RTX_EQ (series_0_r,\n+\t\t simplify_unary_operation (NEG, mode, series_0_nr, mode));\n+  ASSERT_RTX_EQ (series_r_m1,\n+\t\t simplify_unary_operation (NEG, mode, series_nr_1, mode));\n+  ASSERT_RTX_EQ (series_r_r,\n+\t\t simplify_unary_operation (NEG, mode, series_nr_nr, mode));\n+\n+  /* Test that a VEC_SERIES with a zero step is simplified away.  */\n+  ASSERT_RTX_EQ (duplicate,\n+\t\t simplify_binary_operation (VEC_SERIES, mode,\n+\t\t\t\t\t    scalar_reg, const0_rtx));\n+\n+  /* Test PLUS and MINUS with VEC_SERIES.  */\n+  rtx series_0_1 = gen_const_vec_series (mode, const0_rtx, const1_rtx);\n+  rtx series_0_m1 = gen_const_vec_series (mode, const0_rtx, constm1_rtx);\n+  rtx series_r_1 = gen_rtx_VEC_SERIES (mode, scalar_reg, const1_rtx);\n+  ASSERT_RTX_EQ (series_r_r,\n+\t\t simplify_binary_operation (PLUS, mode, series_0_r,\n+\t\t\t\t\t    duplicate));\n+  ASSERT_RTX_EQ (series_r_1,\n+\t\t simplify_binary_operation (PLUS, mode, duplicate,\n+\t\t\t\t\t    series_0_1));\n+  ASSERT_RTX_EQ (series_r_m1,\n+\t\t simplify_binary_operation (PLUS, mode, duplicate,\n+\t\t\t\t\t    series_0_m1));\n+  ASSERT_RTX_EQ (series_0_r,\n+\t\t simplify_binary_operation (MINUS, mode, series_r_r,\n+\t\t\t\t\t    duplicate));\n+  ASSERT_RTX_EQ (series_r_m1,\n+\t\t simplify_binary_operation (MINUS, mode, duplicate,\n+\t\t\t\t\t    series_0_1));\n+  ASSERT_RTX_EQ (series_r_1,\n+\t\t simplify_binary_operation (MINUS, mode, duplicate,\n+\t\t\t\t\t    series_0_m1));\n+}\n+\n /* Verify some simplifications involving vectors.  */\n \n static void\n@@ -6506,6 +6637,9 @@ test_vector_ops ()\n \t{\n \t  rtx scalar_reg = make_test_reg (GET_MODE_INNER (mode));\n \t  test_vector_ops_duplicate (mode, scalar_reg);\n+\t  if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n+\t      && GET_MODE_NUNITS (mode) > 2)\n+\t    test_vector_ops_series (mode, scalar_reg);\n \t}\n     }\n }"}]}