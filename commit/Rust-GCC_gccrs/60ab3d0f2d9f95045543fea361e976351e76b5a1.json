{"sha": "60ab3d0f2d9f95045543fea361e976351e76b5a1", "node_id": "C_kwDOANBUbNoAKDYwYWIzZDBmMmQ5Zjk1MDQ1NTQzZmVhMzYxZTk3NjM1MWU3NmI1YTE", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-05-10T07:33:16Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-05-10T07:36:14Z"}, "message": "Fix internal error with vectorization on SPARC\n\nThis is a regression present since the 10.x series, but the underlying issue\nhas been there since the TARGET_VEC_PERM_CONST hook was implemented, in the\nform of an ICE when expanding a constant VEC_PERM_EXPR in V4QI, while the\nback-end only supports V8QI constant VEC_PERM_EXPRs.\n\ngcc/\n\tPR target/105292\n\t* config/sparc/sparc.cc (sparc_vectorize_vec_perm_const): Return\n\ttrue only for 8-byte vector modes.\n\ngcc/testsuite/\n\t* gcc.target/sparc/20220510-1.c: New test.", "tree": {"sha": "65b0178951a6a81152864e4691efe08c13ab4bf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65b0178951a6a81152864e4691efe08c13ab4bf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60ab3d0f2d9f95045543fea361e976351e76b5a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60ab3d0f2d9f95045543fea361e976351e76b5a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60ab3d0f2d9f95045543fea361e976351e76b5a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60ab3d0f2d9f95045543fea361e976351e76b5a1/comments", "author": null, "committer": null, "parents": [{"sha": "28896b38fabce818e59266b0063a46b3bc1b700f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28896b38fabce818e59266b0063a46b3bc1b700f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28896b38fabce818e59266b0063a46b3bc1b700f"}], "stats": {"total": 35, "additions": 33, "deletions": 2}, "files": [{"sha": "aca925befe15a65959dee05d4a2012386250cb0c", "filename": "gcc/config/sparc/sparc.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60ab3d0f2d9f95045543fea361e976351e76b5a1/gcc%2Fconfig%2Fsparc%2Fsparc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60ab3d0f2d9f95045543fea361e976351e76b5a1/gcc%2Fconfig%2Fsparc%2Fsparc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.cc?ref=60ab3d0f2d9f95045543fea361e976351e76b5a1", "patch": "@@ -13041,9 +13041,9 @@ sparc_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n   if (!TARGET_VIS2)\n     return false;\n \n-  /* All permutes are supported.  */\n+  /* All 8-byte permutes are supported.  */\n   if (!target)\n-    return true;\n+    return GET_MODE_SIZE (vmode) == 8;\n \n   /* Force target-independent code to convert constant permutations on other\n      modes down to V8QI.  Rely on this to avoid the complexity of the byte"}, {"sha": "f321cab8482e77e8544e38db466e7f3de4bb894b", "filename": "gcc/testsuite/gcc.target/sparc/20220510-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60ab3d0f2d9f95045543fea361e976351e76b5a1/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2F20220510-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60ab3d0f2d9f95045543fea361e976351e76b5a1/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2F20220510-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2F20220510-1.c?ref=60ab3d0f2d9f95045543fea361e976351e76b5a1", "patch": "@@ -0,0 +1,31 @@\n+/* PR target/105292 */\n+/* Reported by Koakuma <koachan+gccbugs@protonmail.com> */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mvis2\" } */\n+\n+extern void get_vbytes_v2 (unsigned);\n+\n+typedef struct {\n+  unsigned ctt_info;\n+  unsigned ctt_size;\n+} ctf_type_t;\n+\n+typedef struct {\n+  unsigned short cts_offset;\n+  unsigned short cts_bits;\n+} ctf_slice_t;\n+\n+void flip_types_len (ctf_type_t *t, int bsx1, int bsx2)\n+{\n+  const int kind = t->ctt_info;\n+\n+  get_vbytes_v2 (t->ctt_size);\n+\n+  if (kind == 4)\n+    {\n+      ctf_slice_t *s = (ctf_slice_t *)t;\n+      s->cts_offset = __builtin_bswap16(bsx1);\n+      s->cts_bits   = __builtin_bswap16(bsx2);\n+    }\n+}"}]}