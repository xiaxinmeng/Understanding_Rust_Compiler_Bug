{"sha": "f2bee2395180f0e45177ccdd92dca8f327679e46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJiZWUyMzk1MTgwZjBlNDUxNzdjY2RkOTJkY2E4ZjMyNzY3OWU0Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-12-11T11:11:47Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-12-11T11:11:47Z"}, "message": "[Ada] Fix -gnatR3 output for dynamically constrained record\n\n2018-12-11  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Add\n\tgnat_annotate_type local variable initialized to Empty.\n\t<E_Record_Subtype>: Set it to the Cloned_Subtype, if any.  For\n\ttypes, back-annotate alignment and size values earlier and only\n\tif the DECL was created here; otherwise, if gnat_annotate_type\n\tis present, take the values from it.\n\t(gnat_to_gnu_field): Add gnat_clause local variable.  If a\n\tcomponent clause is present, call validate_size only once on the\n\tEsize of the component.  Otherwise, in the packed case, do not\n\tcall validate_size again on the type of the component but\n\tretrieve directly its RM size.\n\t(components_to_record): Minor tweak.\n\t(set_rm_size): Remove useless test.\n\t* gcc-interface/trans.c (gnat_to_gnu): Do wrap the instance of a\n\tboolean discriminant attached to a variant part.\n\nFrom-SVN: r267008", "tree": {"sha": "ba9cc997c6aebee5701c710b57e0a025241db706", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba9cc997c6aebee5701c710b57e0a025241db706"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2bee2395180f0e45177ccdd92dca8f327679e46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2bee2395180f0e45177ccdd92dca8f327679e46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2bee2395180f0e45177ccdd92dca8f327679e46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2bee2395180f0e45177ccdd92dca8f327679e46/comments", "author": null, "committer": null, "parents": [{"sha": "619bfd9fef74000750b1683efc79909798104940", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/619bfd9fef74000750b1683efc79909798104940", "html_url": "https://github.com/Rust-GCC/gccrs/commit/619bfd9fef74000750b1683efc79909798104940"}], "stats": {"total": 249, "additions": 138, "deletions": 111}, "files": [{"sha": "1fd528ccaf570278bf7e007f53194e97ce91d63b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2bee2395180f0e45177ccdd92dca8f327679e46/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2bee2395180f0e45177ccdd92dca8f327679e46/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f2bee2395180f0e45177ccdd92dca8f327679e46", "patch": "@@ -1,3 +1,21 @@\n+2018-12-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Add\n+\tgnat_annotate_type local variable initialized to Empty.\n+\t<E_Record_Subtype>: Set it to the Cloned_Subtype, if any.  For\n+\ttypes, back-annotate alignment and size values earlier and only\n+\tif the DECL was created here; otherwise, if gnat_annotate_type\n+\tis present, take the values from it.\n+\t(gnat_to_gnu_field): Add gnat_clause local variable.  If a\n+\tcomponent clause is present, call validate_size only once on the\n+\tEsize of the component.  Otherwise, in the packed case, do not\n+\tcall validate_size again on the type of the component but\n+\tretrieve directly its RM size.\n+\t(components_to_record): Minor tweak.\n+\t(set_rm_size): Remove useless test.\n+\t* gcc-interface/trans.c (gnat_to_gnu): Do wrap the instance of a\n+\tboolean discriminant attached to a variant part.\n+\n 2018-12-11  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_aggr.adb (Array_Aggr_Subtype. Resolve_Aggr_Expr): Indicate"}, {"sha": "b2f92296a1a089623ab5eb570311eb5f297bf327", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 118, "deletions": 110, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2bee2395180f0e45177ccdd92dca8f327679e46/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2bee2395180f0e45177ccdd92dca8f327679e46/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=f2bee2395180f0e45177ccdd92dca8f327679e46", "patch": "@@ -287,6 +287,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n   const bool foreign = Has_Foreign_Convention (gnat_entity);\n   /* For a type, contains the equivalent GNAT node to be used in gigi.  */\n   Entity_Id gnat_equiv_type = Empty;\n+  /* For a type, contains the GNAT node to be used for back-annotation.  */\n+  Entity_Id gnat_annotate_type = Empty;\n   /* Temporary used to walk the GNAT tree.  */\n   Entity_Id gnat_temp;\n   /* Contains the GCC DECL node which is equivalent to the input GNAT node.\n@@ -3390,6 +3392,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t{\n \t  gnu_decl = gnat_to_gnu_entity (Cloned_Subtype (gnat_entity),\n \t\t\t\t\t NULL_TREE, false);\n+\t  gnat_annotate_type = Cloned_Subtype (gnat_entity);\n \t  saved = true;\n \t  break;\n \t}\n@@ -4228,7 +4231,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n       saved = true;\n     }\n \n-  /* If we are processing a type and there is either no decl for it or\n+  /* If we are processing a type and there is either no DECL for it or\n      we just made one, do some common processing for the type, such as\n      handling alignment and possible padding.  */\n   if (is_type && (!gnu_decl || this_made_decl))\n@@ -4324,6 +4327,97 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t because we need to accept arbitrary RM sizes on integral types.  */\n       set_rm_size (RM_Size (gnat_entity), gnu_type, gnat_entity);\n \n+      /* Back-annotate the alignment of the type if not already set.  */\n+      if (Unknown_Alignment (gnat_entity))\n+\t{\n+\t  unsigned int double_align, align;\n+\t  bool is_capped_double, align_clause;\n+\n+\t  /* If the default alignment of \"double\" or larger scalar types is\n+\t     specifically capped and this is not an array with an alignment\n+\t     clause on the component type, return the cap.  */\n+\t  if ((double_align = double_float_alignment) > 0)\n+\t    is_capped_double\n+\t      = is_double_float_or_array (gnat_entity, &align_clause);\n+\t  else if ((double_align = double_scalar_alignment) > 0)\n+\t    is_capped_double\n+\t      = is_double_scalar_or_array (gnat_entity, &align_clause);\n+\t  else\n+\t    is_capped_double = align_clause = false;\n+\n+\t  if (is_capped_double && !align_clause)\n+\t    align = double_align;\n+\t  else\n+\t    align = TYPE_ALIGN (gnu_type) / BITS_PER_UNIT;\n+\n+\t  Set_Alignment (gnat_entity, UI_From_Int (align));\n+\t}\n+\n+      /* Likewise for the size, if any.  */\n+      if (Unknown_Esize (gnat_entity) && TYPE_SIZE (gnu_type))\n+\t{\n+\t  tree gnu_size = TYPE_SIZE (gnu_type);\n+\n+\t  /* If the size is self-referential, annotate the maximum value.  */\n+\t  if (CONTAINS_PLACEHOLDER_P (gnu_size))\n+\t    gnu_size = max_size (gnu_size, true);\n+\n+\t  /* If we are just annotating types and the type is tagged, the tag\n+\t     and the parent components are not generated by the front-end so\n+\t     alignment and sizes must be adjusted if there is no rep clause.  */\n+\t  if (type_annotate_only\n+\t      && Is_Tagged_Type (gnat_entity)\n+\t      && Unknown_RM_Size (gnat_entity)\n+\t      && !VOID_TYPE_P (gnu_type)\n+\t      && (!TYPE_FIELDS (gnu_type)\n+\t\t  || integer_zerop (bit_position (TYPE_FIELDS (gnu_type)))))\n+\t    {\n+\t      tree offset;\n+\n+\t      if (Is_Derived_Type (gnat_entity))\n+\t\t{\n+\t\t  Entity_Id gnat_parent = Etype (Base_Type (gnat_entity));\n+\t\t  offset = UI_To_gnu (Esize (gnat_parent), bitsizetype);\n+\t\t  Set_Alignment (gnat_entity, Alignment (gnat_parent));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  unsigned int align\n+\t\t    = MAX (TYPE_ALIGN (gnu_type), POINTER_SIZE) / BITS_PER_UNIT;\n+\t\t  offset = bitsize_int (POINTER_SIZE);\n+\t\t  Set_Alignment (gnat_entity, UI_From_Int (align));\n+\t\t}\n+\n+\t      if (TYPE_FIELDS (gnu_type))\n+\t\toffset\n+\t\t  = round_up (offset, DECL_ALIGN (TYPE_FIELDS (gnu_type)));\n+\n+\t      gnu_size = size_binop (PLUS_EXPR, gnu_size, offset);\n+\t      gnu_size = round_up (gnu_size, POINTER_SIZE);\n+\t      Uint uint_size = annotate_value (gnu_size);\n+\t      Set_RM_Size (gnat_entity, uint_size);\n+\t      Set_Esize (gnat_entity, uint_size);\n+\t    }\n+\n+\t  /* If there is a rep clause, only adjust alignment and Esize.  */\n+\t  else if (type_annotate_only && Is_Tagged_Type (gnat_entity))\n+\t    {\n+\t      unsigned int align\n+\t\t= MAX (TYPE_ALIGN (gnu_type), POINTER_SIZE) / BITS_PER_UNIT;\n+\t      Set_Alignment (gnat_entity, UI_From_Int (align));\n+\t      gnu_size = round_up (gnu_size, POINTER_SIZE);\n+\t      Set_Esize (gnat_entity, annotate_value (gnu_size));\n+\t    }\n+\n+\t  /* Otherwise no adjustment is needed.  */\n+\t  else\n+\t    Set_Esize (gnat_entity, annotate_value (gnu_size));\n+\t}\n+\n+      /* Likewise for the RM size, if any.  */\n+      if (Unknown_RM_Size (gnat_entity) && TYPE_SIZE (gnu_type))\n+\tSet_RM_Size (gnat_entity, annotate_value (rm_size (gnu_type)));\n+\n       /* If we are at global level, GCC will have applied variable_size to\n \t the type, but that won't have done anything.  So, if it's not\n \t a constant or self-referential, call elaborate_expression_1 to\n@@ -4575,99 +4669,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t\t     debug_info_p, gnat_entity);\n     }\n \n-  /* If we got a type that is not dummy, back-annotate the alignment of the\n-     type if not already in the tree.  Likewise for the size, if any.  */\n-  if (is_type && !TYPE_IS_DUMMY_P (TREE_TYPE (gnu_decl)))\n+  /* Otherwise, for a type reusing an existing DECL, back-annotate values.  */\n+  else if (is_type\n+\t   && !TYPE_IS_DUMMY_P (TREE_TYPE (gnu_decl))\n+\t   && Present (gnat_annotate_type))\n     {\n-      gnu_type = TREE_TYPE (gnu_decl);\n-\n       if (Unknown_Alignment (gnat_entity))\n-\t{\n-\t  unsigned int double_align, align;\n-\t  bool is_capped_double, align_clause;\n-\n-\t  /* If the default alignment of \"double\" or larger scalar types is\n-\t     specifically capped and this is not an array with an alignment\n-\t     clause on the component type, return the cap.  */\n-\t  if ((double_align = double_float_alignment) > 0)\n-\t    is_capped_double\n-\t      = is_double_float_or_array (gnat_entity, &align_clause);\n-\t  else if ((double_align = double_scalar_alignment) > 0)\n-\t    is_capped_double\n-\t      = is_double_scalar_or_array (gnat_entity, &align_clause);\n-\t  else\n-\t    is_capped_double = align_clause = false;\n-\n-\t  if (is_capped_double && !align_clause)\n-\t    align = double_align;\n-\t  else\n-\t    align = TYPE_ALIGN (gnu_type) / BITS_PER_UNIT;\n-\n-\t  Set_Alignment (gnat_entity, UI_From_Int (align));\n-\t}\n-\n-      if (Unknown_Esize (gnat_entity) && TYPE_SIZE (gnu_type))\n-\t{\n-\t  tree gnu_size = TYPE_SIZE (gnu_type);\n-\n-\t  /* If the size is self-referential, annotate the maximum value.  */\n-\t  if (CONTAINS_PLACEHOLDER_P (gnu_size))\n-\t    gnu_size = max_size (gnu_size, true);\n-\n-\t  /* If we are just annotating types and the type is tagged, the tag\n-\t     and the parent components are not generated by the front-end so\n-\t     alignment and sizes must be adjusted if there is no rep clause.  */\n-\t  if (type_annotate_only\n-\t      && Is_Tagged_Type (gnat_entity)\n-\t      && Unknown_RM_Size (gnat_entity)\n-\t      && !VOID_TYPE_P (gnu_type)\n-\t      && (!TYPE_FIELDS (gnu_type)\n-\t\t  || integer_zerop (bit_position (TYPE_FIELDS (gnu_type)))))\n-\t    {\n-\t      tree offset;\n-\n-\t      if (Is_Derived_Type (gnat_entity))\n-\t\t{\n-\t\t  Entity_Id gnat_parent = Etype (Base_Type (gnat_entity));\n-\t\t  offset = UI_To_gnu (Esize (gnat_parent), bitsizetype);\n-\t\t  Set_Alignment (gnat_entity, Alignment (gnat_parent));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  unsigned int align\n-\t\t    = MAX (TYPE_ALIGN (gnu_type), POINTER_SIZE) / BITS_PER_UNIT;\n-\t\t  offset = bitsize_int (POINTER_SIZE);\n-\t\t  Set_Alignment (gnat_entity, UI_From_Int (align));\n-\t\t}\n-\n-\t      if (TYPE_FIELDS (gnu_type))\n-\t\toffset\n-\t\t  = round_up (offset, DECL_ALIGN (TYPE_FIELDS (gnu_type)));\n-\n-\t      gnu_size = size_binop (PLUS_EXPR, gnu_size, offset);\n-\t      gnu_size = round_up (gnu_size, POINTER_SIZE);\n-\t      Uint uint_size = annotate_value (gnu_size);\n-\t      Set_RM_Size (gnat_entity, uint_size);\n-\t      Set_Esize (gnat_entity, uint_size);\n-\t    }\n-\n-\t  /* If there is a rep clause, only adjust alignment and Esize.  */\n-\t  else if (type_annotate_only && Is_Tagged_Type (gnat_entity))\n-\t    {\n-\t      unsigned int align\n-\t\t= MAX (TYPE_ALIGN (gnu_type), POINTER_SIZE) / BITS_PER_UNIT;\n-\t      Set_Alignment (gnat_entity, UI_From_Int (align));\n-\t      gnu_size = round_up (gnu_size, POINTER_SIZE);\n-\t      Set_Esize (gnat_entity, annotate_value (gnu_size));\n-\t    }\n-\n-\t  /* Otherwise no adjustment is needed.  */\n-\t  else\n-\t    Set_Esize (gnat_entity, annotate_value (gnu_size));\n-\t}\n-\n-      if (Unknown_RM_Size (gnat_entity) && TYPE_SIZE (gnu_type))\n-\tSet_RM_Size (gnat_entity, annotate_value (rm_size (gnu_type)));\n+\tSet_Alignment (gnat_entity, Alignment (gnat_annotate_type));\n+      if (Unknown_Esize (gnat_entity))\n+\tSet_Esize (gnat_entity, Esize (gnat_annotate_type));\n+      if (Unknown_RM_Size (gnat_entity))\n+\tSet_RM_Size (gnat_entity, RM_Size (gnat_annotate_type));\n     }\n \n   /* If we haven't already, associate the ..._DECL node that we just made with\n@@ -6900,6 +6912,7 @@ static tree\n gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t\t   bool definition, bool debug_info_p)\n {\n+  const Node_Id gnat_clause = Component_Clause (gnat_field);\n   const Entity_Id gnat_record_type = Underlying_Type (Scope (gnat_field));\n   const Entity_Id gnat_field_type = Etype (gnat_field);\n   const bool is_atomic\n@@ -6934,12 +6947,15 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n   /* If a size is specified, use it.  Otherwise, if the record type is packed,\n      use the official RM size.  See \"Handling of Type'Size Values\" in Einfo\n      for further details.  */\n-  if (Known_Esize (gnat_field))\n-    gnu_size = validate_size (Esize (gnat_field), gnu_field_type,\n-\t\t\t      gnat_field, FIELD_DECL, false, true);\n+  if (Known_Esize (gnat_field) || Present (gnat_clause))\n+    gnu_size = validate_size (Esize (gnat_field), gnu_field_type, gnat_field,\n+\t\t\t      FIELD_DECL, false, true);\n   else if (packed == 1)\n-    gnu_size = validate_size (RM_Size (gnat_field_type), gnu_field_type,\n-\t\t\t      gnat_field, FIELD_DECL, false, true);\n+    {\n+      gnu_size = rm_size (gnu_field_type);\n+      if (TREE_CODE (gnu_size) != INTEGER_CST)\n+\tgnu_size = NULL_TREE;\n+    }\n   else\n     gnu_size = NULL_TREE;\n \n@@ -6972,7 +6988,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n       && (packed == 1\n \t  || (gnu_size\n \t      && (tree_int_cst_lt (gnu_size, TYPE_SIZE (gnu_field_type))\n-\t\t  || (Present (Component_Clause (gnat_field))\n+\t\t  || (Present (gnat_clause)\n \t\t      && !(UI_To_Int (Component_Bit_Offset (gnat_field))\n \t\t\t   % BITS_PER_UNIT == 0\n \t\t\t   && value_factor_p (gnu_size, BITS_PER_UNIT)))))))\n@@ -6997,14 +7013,11 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n       check_ok_for_atomic_type (gnu_field_type, gnat_field, false);\n     }\n \n-  if (Present (Component_Clause (gnat_field)))\n+  if (Present (gnat_clause))\n     {\n-      Node_Id gnat_clause = Component_Clause (gnat_field);\n       Entity_Id gnat_parent = Parent_Subtype (gnat_record_type);\n \n       gnu_pos = UI_To_gnu (Component_Bit_Offset (gnat_field), bitsizetype);\n-      gnu_size = validate_size (Esize (gnat_field), gnu_field_type,\n-\t\t\t\tgnat_field, FIELD_DECL, false, true);\n \n       /* Ensure the position does not overlap with the parent subtype, if there\n \t is one.  This test is omitted if the parent of the tagged type has a\n@@ -7585,17 +7598,16 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n       tree gnu_var_name\n \t= concat_name (get_identifier (Get_Name_String (Chars (gnat_discr))),\n \t\t       \"XVN\");\n-      tree gnu_union_type, gnu_union_name;\n+      tree gnu_union_name\n+\t= concat_name (gnu_name, IDENTIFIER_POINTER (gnu_var_name));\n+      tree gnu_union_type;\n       tree this_first_free_pos, gnu_variant_list = NULL_TREE;\n       bool union_field_needs_strict_alignment = false;\n       auto_vec <vinfo_t, 16> variant_types;\n       vinfo_t *gnu_variant;\n       unsigned int variants_align = 0;\n       unsigned int i;\n \n-      gnu_union_name\n-\t= concat_name (gnu_name, IDENTIFIER_POINTER (gnu_var_name));\n-\n       /* Reuse the enclosing union if this is an Unchecked_Union whose fields\n \t are all in the variant part, to match the layout of C unions.  There\n \t is an associated check below.  */\n@@ -8831,10 +8843,6 @@ set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n   if (uint_size == No_Uint)\n     return;\n \n-  /* Ignore a negative size since that corresponds to our back-annotation.  */\n-  if (UI_Lt (uint_size, Uint_0))\n-    return;\n-\n   /* Only issue an error if a Value_Size clause was explicitly given.\n      Otherwise, we'd be duplicating an error on the Size clause.  */\n   gnat_attr_node"}, {"sha": "35b71ef838ab66506f51e05ef6eda3ce645b3631", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2bee2395180f0e45177ccdd92dca8f327679e46/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2bee2395180f0e45177ccdd92dca8f327679e46/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=f2bee2395180f0e45177ccdd92dca8f327679e46", "patch": "@@ -8567,7 +8567,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  || kind == N_Indexed_Component\n \t  || kind == N_Selected_Component)\n       && TREE_CODE (get_base_type (gnu_result_type)) == BOOLEAN_TYPE\n-      && !lvalue_required_p (gnat_node, gnu_result_type, false, false))\n+      && !lvalue_required_p (gnat_node, gnu_result_type, false, false)\n+      && Nkind (Parent (gnat_node)) != N_Variant_Part)\n     {\n       gnu_result\n \t= build_binary_op (NE_EXPR, gnu_result_type,"}]}