{"sha": "8d946ecc4695b2075da22d77fff79de6a36401b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ5NDZlY2M0Njk1YjIwNzVkYTIyZDc3ZmZmNzlkZTZhMzY0MDFiOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-10-11T08:19:17Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-10-11T08:19:17Z"}, "message": "visium-modes.def (CC_NOOV): Rename into...\n\n\t* config/visium/visium-modes.def (CC_NOOV): Rename into...\n\t(CCNZ): ...this.\n\t(CC_BTST): Rename into...\n\t(CCC): ...this.\n\t* config/visium/predicates.md (real_add_operand): New.\n\t(visium_btst_operator): Rename into...\n\t(visium_equality_comparison_operator): ...this.\n\t(visium_noov_operator): Rename into...\n\t(visium_nz_comparison_operator): ...this.\n\t(visium_c_comparison_operator): New.\n\t(visium_branch_operator): Adjust and deal with all CC modes.\n\t* config/visium/visium.c (visium_adjust_cost): Adjust.\n\t(visium_split_double_add): Use the *_set_carry patterns.\n\t(visium_select_cc_mode): Add support for CCC mode and adjust.\n\t(output_cbranch): Adjust and use the carry-based operators for\n\tfloating-point comparisons.\n\t* config/visium/visium.md (flags_subst_arith): Adjust.\n\t(addsi3_insn_set_carry): New instruction.\n\t(subsi3_insn_set_carry): Likewise.\n\t(negsi2_insn_set_carry): Likewise.\n\t(btst): Adjust.\n\t(cmp<mode>_sne): Likewise.\n\t(cbranch<mode>4): Use ordered_comparison_operator.\n\t(cbranch<mode>4_insn): Likewise.\n\t(cbranchsi4_btst_insn): Adjust.\n\nFrom-SVN: r240969", "tree": {"sha": "8c77d0e1458c759a34b0694b8b52974cd42d6b6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c77d0e1458c759a34b0694b8b52974cd42d6b6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d946ecc4695b2075da22d77fff79de6a36401b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d946ecc4695b2075da22d77fff79de6a36401b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d946ecc4695b2075da22d77fff79de6a36401b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d946ecc4695b2075da22d77fff79de6a36401b9/comments", "author": null, "committer": null, "parents": [{"sha": "431e31a9f464e2213b06ad4f7e52ee1a4f1c4b38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/431e31a9f464e2213b06ad4f7e52ee1a4f1c4b38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/431e31a9f464e2213b06ad4f7e52ee1a4f1c4b38"}], "stats": {"total": 216, "additions": 152, "deletions": 64}, "files": [{"sha": "e2cc1bb7a392572a1a26797cf2f1e466f51d9a05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d946ecc4695b2075da22d77fff79de6a36401b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d946ecc4695b2075da22d77fff79de6a36401b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d946ecc4695b2075da22d77fff79de6a36401b9", "patch": "@@ -1,3 +1,31 @@\n+2016-10-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/visium/visium-modes.def (CC_NOOV): Rename into...\n+\t(CCNZ): ...this.\n+\t(CC_BTST): Rename into...\n+\t(CCC): ...this.\n+\t* config/visium/predicates.md (real_add_operand): New.\n+\t(visium_btst_operator): Rename into...\n+\t(visium_equality_comparison_operator): ...this.\n+\t(visium_noov_operator): Rename into...\n+\t(visium_nz_comparison_operator): ...this.\n+\t(visium_c_comparison_operator): New.\n+\t(visium_branch_operator): Adjust and deal with all CC modes.\n+\t* config/visium/visium.c (visium_adjust_cost): Adjust.\n+\t(visium_split_double_add): Use the *_set_carry patterns.\n+\t(visium_select_cc_mode): Add support for CCC mode and adjust.\n+\t(output_cbranch): Adjust and use the carry-based operators for\n+\tfloating-point comparisons.\n+\t* config/visium/visium.md (flags_subst_arith): Adjust.\n+\t(addsi3_insn_set_carry): New instruction.\n+\t(subsi3_insn_set_carry): Likewise.\n+\t(negsi2_insn_set_carry): Likewise.\n+\t(btst): Adjust.\n+\t(cmp<mode>_sne): Likewise.\n+\t(cbranch<mode>4): Use ordered_comparison_operator.\n+\t(cbranch<mode>4_insn): Likewise.\n+\t(cbranchsi4_btst_insn): Adjust.\n+\n 2016-10-11  Tom de Vries  <tom@codesourcery.com>\n \n \tPR middle-end/77558"}, {"sha": "5e08768666a38c5c76c6f45d06e4c4b8d571e5d0", "filename": "gcc/config/visium/predicates.md", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d946ecc4695b2075da22d77fff79de6a36401b9/gcc%2Fconfig%2Fvisium%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d946ecc4695b2075da22d77fff79de6a36401b9/gcc%2Fconfig%2Fvisium%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fpredicates.md?ref=8d946ecc4695b2075da22d77fff79de6a36401b9", "patch": "@@ -112,40 +112,55 @@\n        (and (match_code \"const_int\")\n             (match_test (\"INTVAL (op) >= -65535 && INTVAL (op) <= 65535\")))))\n \n+;; Return true if OP can be used as the second operand in a 32-bit or 64-bit\n+;; add or subtract instruction directly, i.e. without the reverse trick.\n+(define_predicate \"real_add_operand\"\n+  (ior (match_operand 0 \"gpc_reg_operand\")\n+       (and (match_code \"const_int\")\n+            (match_test (\"INTVAL (op) >= 0 && INTVAL (op) <= 65535\")))))\n+\n ;; Return true if OP is (or could be) outside the range 0 .. 65535, which is\n ;; the range of the immediate operands, but accept -1 for NOT.\n (define_predicate \"large_immediate_operand\"\n   (ior (match_code \"const,label_ref,symbol_ref\")\n        (and (match_code \"const_int\")\n             (match_test (\"INTVAL (op) < -1 || INTVAL (op) > 65535\")))))\n \n+;; Return true if OP is an equality comparison operator.\n+(define_predicate \"visium_equality_comparison_operator\"\n+  (match_code \"eq,ne\"))\n+\n+;; Return true if OP is a valid comparison operator for CCNZmode.\n+(define_special_predicate \"visium_nz_comparison_operator\"\n+  (match_code \"eq,ne,lt,ge\"))\n+\n+;; Return true if OP is a valid comparison operator for CCCmode.\n+(define_special_predicate \"visium_c_comparison_operator\"\n+  (match_code \"eq,ne,ltu,geu\"))\n+\n ;; Return true if OP is a valid FP comparison operator.\n (define_predicate \"visium_fp_comparison_operator\"\n   (match_code \"eq,ne,ordered,unordered,unlt,unle,ungt,unge,lt,le,gt,ge\"))\n \n-;; Return true if OP is a valid comparison operator for CC_BTSTmode.\n-(define_special_predicate \"visium_btst_operator\"\n-  (match_code \"eq,ne\"))\n-\n-;; Return true if OP is a valid comparison operator for CC_NOOVmode.\n-(define_special_predicate \"visium_noov_operator\"\n-  (match_code \"eq,ne,ge,lt\"))\n-\n ;; Return true if OP is a valid comparison operator for a branch.  This allows\n ;; the use of MATCH_OPERATOR to recognize all the branch insns.\n (define_predicate \"visium_branch_operator\"\n   (match_operand 0 \"comparison_operator\")\n {\n-  enum rtx_code code = GET_CODE (op);\n-  /* These 2 comparison codes are not supported.  */\n-  if (code == UNEQ || code == LTGT)\n-    return false;\n-  enum machine_mode cc_mode = GET_MODE (XEXP (op, 0));\n-  if (cc_mode == CC_NOOVmode)\n-    return visium_noov_operator (op, mode);\n-  if (cc_mode == CC_BTSTmode)\n-    return visium_btst_operator (op, mode);\n-  return true;\n+  switch (GET_MODE (XEXP (op, 0)))\n+    {\n+    case CCmode:\n+      return ordered_comparison_operator (op, mode);\n+    case CCNZmode:\n+      return visium_nz_comparison_operator (op, mode);\n+    case CCCmode:\n+      return visium_c_comparison_operator (op, mode);\n+    case CCFPmode:\n+    case CCFPEmode:\n+      return visium_fp_comparison_operator (op, mode);\n+    default:\n+      return false;\n+    }\n })\n \n ;; Return true if OP is a valid comparison operator for an integer cstore."}, {"sha": "980745ebfe75fc76bfc2bb82e72186a408884b72", "filename": "gcc/config/visium/visium-modes.def", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d946ecc4695b2075da22d77fff79de6a36401b9/gcc%2Fconfig%2Fvisium%2Fvisium-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d946ecc4695b2075da22d77fff79de6a36401b9/gcc%2Fconfig%2Fvisium%2Fvisium-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium-modes.def?ref=8d946ecc4695b2075da22d77fff79de6a36401b9", "patch": "@@ -19,19 +19,22 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Add any extra modes needed to represent the condition code.\n \n-   On the Visium, we have a \"no-overflow\" mode which is used when arithmetic\n-   instructions set the condition code.  Different branches are used in this\n-   case for some operations.\n+   We have a CCNZ mode which is used for implicit comparisons with zero when\n+   arithmetic instructions set the condition code.  Only the N and Z flags\n+   are valid in this mode, which means that only the =,!= and <,>= operators\n+   can be used in conjunction with it.\n \n-   We also have a \"bit-test\" mode which is used when the bit-test instruction\n-   sets the condition code.\n+   We also have a CCCmode which is used by the arithmetic instructions when\n+   they explicitly set the C flag (unsigned overflow) and by the bit-test\n+   instruction.  Only the =,!= and unsigned <,>= operators can be used in\n+   conjunction with it.\n \n    We also have two modes to indicate that the condition code is set by the\n    the floating-point unit.  One for comparisons which generate an exception\n    if the result is unordered (CCFPEmode) and one for comparisons which never\n    generate such an exception (CCFPmode).  */\n \n-CC_MODE (CC_NOOV);\n-CC_MODE (CC_BTST);\n+CC_MODE (CCNZ);\n+CC_MODE (CCC);\n CC_MODE (CCFP);\n CC_MODE (CCFPE);"}, {"sha": "4585af578949990c7f5dff163bdd7c0b671dfd00", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d946ecc4695b2075da22d77fff79de6a36401b9/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d946ecc4695b2075da22d77fff79de6a36401b9/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=8d946ecc4695b2075da22d77fff79de6a36401b9", "patch": "@@ -561,11 +561,12 @@ visium_adjust_cost (rtx_insn *insn, int dep_type, rtx_insn *dep_insn, int cost,\n \n \t      /* The logical instructions use CCmode and thus work with any\n \t\t comparison operator, whereas the arithmetic instructions use\n-\t\t CC_NOOVmode and thus work with only a small subset.  */\n+\t\t CCNZmode and thus work with only a small subset.  */\n \t      if (dep_attr_type == TYPE_LOGIC\n \t\t  || (dep_attr_type == TYPE_ARITH\n-\t\t      && visium_noov_operator (XEXP (src, 0),\n-\t\t\t\t\t       GET_MODE (XEXP (src, 0)))))\n+\t\t      && visium_nz_comparison_operator (XEXP (src, 0),\n+\t\t\t\t\t\t\tGET_MODE\n+\t\t\t\t\t\t\t(XEXP (src, 0)))))\n \t\treturn 0;\n \t    }\n \t}\n@@ -2113,23 +2114,20 @@ visium_split_double_add (enum rtx_code code, rtx op0, rtx op1, rtx op2)\n       op8 = gen_highpart (SImode, op2);\n     }\n \n-  /* This is the {add,sub,neg}si3_insn_set_flags pattern.  */\n   if (op4 == const0_rtx)\n-    x = gen_rtx_NEG (SImode, op5);\n+    pat = gen_negsi2_insn_set_carry (op3, op5);\n+  else if (code == MINUS)\n+    pat = gen_subsi3_insn_set_carry (op3, op4, op5);\n   else\n-    x = gen_rtx_fmt_ee (code, SImode, op4, op5);\n-  pat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));\n-  XVECEXP (pat, 0, 0) = gen_rtx_SET (op3, x);\n-  flags = gen_rtx_REG (CC_NOOVmode, FLAGS_REGNUM);\n-  x = gen_rtx_COMPARE (CC_NOOVmode, shallow_copy_rtx (x), const0_rtx);\n-  XVECEXP (pat, 0, 1) = gen_rtx_SET (flags, x);\n+    pat = gen_addsi3_insn_set_carry (op3, op4, op5);\n   emit_insn (pat);\n \n   /* This is the plus_[plus_]sltu_flags or minus_[minus_]sltu_flags pattern.  */\n   if (op8 == const0_rtx)\n     x = op7;\n   else\n     x = gen_rtx_fmt_ee (code, SImode, op7, op8);\n+  flags = gen_rtx_REG (CCCmode, FLAGS_REGNUM);\n   x = gen_rtx_fmt_ee (code, SImode, x, gen_rtx_LTU (SImode, flags, const0_rtx));\n   pat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));\n   XVECEXP (pat, 0, 0) = gen_rtx_SET (op6, x);\n@@ -2814,6 +2812,16 @@ visium_select_cc_mode (enum rtx_code code, rtx op0, rtx op1)\n \t}\n     }\n \n+  /* This is for the cmp<mode>_sne pattern.  */\n+  if (op1 == constm1_rtx)\n+    return CCCmode;\n+\n+  /* This is for the add<mode>3_insn_set_carry pattern.  */\n+  if ((code == LTU || code == GEU)\n+      && GET_CODE (op0) == PLUS\n+      && rtx_equal_p (XEXP (op0, 0), op1))\n+    return CCCmode;\n+\n   if (op1 != const0_rtx)\n     return CCmode;\n \n@@ -2825,17 +2833,17 @@ visium_select_cc_mode (enum rtx_code code, rtx op0, rtx op1)\n     case ASHIFT:\n     case LTU:\n     case LT:\n-      /* The V flag may be set differently from a COMPARE with zero.\n-\t The consequence is that a comparison operator testing V must\n-\t be turned into another operator not testing V and yielding\n-\t the same result for a comparison with zero.  That's possible\n-\t for GE/LT which become NC/NS respectively, but not for GT/LE\n-\t for which the altered operator doesn't exist on the Visium.  */\n-      return CC_NOOVmode;\n+      /* The C and V flags may be set differently from a COMPARE with zero.\n+\t The consequence is that a comparison operator testing C or V must\n+\t be turned into another operator not testing C or V and yielding\n+\t the same result for a comparison with zero.  That's possible for\n+\t GE/LT which become NC/NS respectively, but not for GT/LE for which\n+\t the altered operator doesn't exist on the Visium.  */\n+      return CCNZmode;\n \n     case ZERO_EXTRACT:\n       /* This is a btst, the result is in C instead of Z.  */\n-      return CC_BTSTmode;\n+      return CCCmode;\n \n     case CONST_INT:\n       /* This is a degenerate case, typically an uninitialized variable.  */\n@@ -3077,21 +3085,21 @@ output_cbranch (rtx label, enum rtx_code code, enum machine_mode cc_mode,\n   switch (code)\n     {\n     case NE:\n-      if (cc_mode == CC_BTSTmode)\n+      if (cc_mode == CCCmode)\n \tcond = \"cs\";\n       else\n \tcond = \"ne\";\n       break;\n \n     case EQ:\n-      if (cc_mode == CC_BTSTmode)\n+      if (cc_mode == CCCmode)\n \tcond = \"cc\";\n       else\n \tcond = \"eq\";\n       break;\n \n     case GE:\n-      if (cc_mode == CC_NOOVmode)\n+      if (cc_mode == CCNZmode)\n \tcond = \"nc\";\n       else\n \tcond = \"ge\";\n@@ -3110,8 +3118,8 @@ output_cbranch (rtx label, enum rtx_code code, enum machine_mode cc_mode,\n \n     case LT:\n       if (cc_mode == CCFPmode || cc_mode == CCFPEmode)\n-\tcond = \"ns\";\n-      else if (cc_mode == CC_NOOVmode)\n+\tcond = \"cs\"; /* or \"ns\" */\n+      else if (cc_mode == CCNZmode)\n \tcond = \"ns\";\n       else\n \tcond = \"lt\";\n@@ -3142,7 +3150,7 @@ output_cbranch (rtx label, enum rtx_code code, enum machine_mode cc_mode,\n       break;\n \n     case UNGE:\n-      cond = \"nc\";\n+      cond = \"cc\"; /* or \"nc\" */\n       break;\n \n     case UNGT:"}, {"sha": "de1c710f44121486fe8f7f3c365c447e0e1dbb09", "filename": "gcc/config/visium/visium.md", "status": "modified", "additions": 48, "deletions": 14, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d946ecc4695b2075da22d77fff79de6a36401b9/gcc%2Fconfig%2Fvisium%2Fvisium.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d946ecc4695b2075da22d77fff79de6a36401b9/gcc%2Fconfig%2Fvisium%2Fvisium.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.md?ref=8d946ecc4695b2075da22d77fff79de6a36401b9", "patch": "@@ -257,8 +257,8 @@\n    (clobber (reg:CC R_FLAGS))]\n   \"\"\n   [(set (match_dup 0) (match_dup 1))\n-   (set (reg:CC_NOOV R_FLAGS)\n-\t(compare:CC_NOOV (match_dup 1) (const_int 0)))])\n+   (set (reg:CCNZ R_FLAGS)\n+\t(compare:CCNZ (match_dup 1) (const_int 0)))])\n \n (define_subst_attr \"subst_arith\" \"flags_subst_arith\" \"_flags\" \"_set_flags\")\n \n@@ -809,6 +809,19 @@\n     addi    %0,%2\"\n   [(set_attr \"type\" \"arith\")])\n \n+(define_insn \"addsi3_insn_set_carry\"\n+  [(set (match_operand:SI 0 \"register_operand\"          \"=r,r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r,0\")\n+\t\t (match_operand:SI 2 \"real_add_operand\" \" r,J\")))\n+   (set (reg:CCC R_FLAGS)\n+\t(compare:CCC (plus:SI (match_dup 1) (match_dup 2))\n+\t\t     (match_dup 1)))]\n+  \"reload_completed\"\n+  \"@\n+    add.l   %0,%1,%2\n+    addi    %0,%2\"\n+  [(set_attr \"type\" \"arith\")])\n+\n (define_expand \"adddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n@@ -948,6 +961,18 @@\n     subi    %0,%2\"\n   [(set_attr \"type\" \"arith\")])\n \n+(define_insn \"subsi3_insn_set_carry\"\n+  [(set (match_operand:SI 0 \"register_operand\"           \"=r,r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \" r,0\")\n+\t\t  (match_operand:SI 2 \"real_add_operand\" \" r,J\")))\n+   (set (reg:CC R_FLAGS)\n+\t(compare:CC (match_dup 1) (match_dup 2)))]\n+  \"reload_completed\"\n+  \"@\n+    sub.l   %0,%r1,%2\n+    subi    %0,%2\"\n+  [(set_attr \"type\" \"arith\")])\n+\n (define_expand \"subdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(minus:DI (match_operand:DI 1 \"register_operand\" \"\")\n@@ -1041,6 +1066,15 @@\n   \"sub<s>   %0,r0,%1\"\n   [(set_attr \"type\" \"arith\")])\n \n+(define_insn \"negsi2_insn_set_carry\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (neg:SI (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (reg:CCC R_FLAGS)\n+\t(compare:CCC (not:SI (match_dup 1)) (const_int -1)))]\n+  \"reload_completed\"\n+  \"sub.l   %0,r0,%1\"\n+  [(set_attr \"type\" \"arith\")])\n+\n (define_expand \"negdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(neg:DI (match_operand:DI 1 \"register_operand\" \"\")))]\n@@ -1803,12 +1837,12 @@\n ; BITS_BIG_ENDIAN is defined to 1 so operand #1 counts from the MSB.\n \n (define_insn \"*btst\"\n-  [(set (reg:CC_BTST R_FLAGS)\n-\t(compare:CC_BTST (zero_extract:SI\n-\t\t\t   (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t   (const_int 1)\n-\t\t\t   (match_operand:QI 1 \"const_shift_operand\" \"K\"))\n-\t\t\t (const_int 0)))]\n+  [(set (reg:CCC R_FLAGS)\n+\t(compare:CCC (zero_extract:SI\n+\t\t       (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t       (const_int 1)\n+\t\t       (match_operand:QI 1 \"const_shift_operand\" \"K\"))\n+\t\t     (const_int 0)))]\n   \"reload_completed\"\n   \"lsr.l   r0,%0,32-%1\"\n   [(set_attr \"type\" \"logic\")])\n@@ -1832,9 +1866,9 @@\n   [(set_attr \"type\" \"cmp\")])\n \n (define_insn \"*cmp<mode>_sne\"\n-  [(set (reg:CC R_FLAGS)\n-\t(compare:CC (not:I (match_operand:I 0 \"register_operand\" \"r\"))\n-\t\t    (const_int -1)))]\n+  [(set (reg:CCC R_FLAGS)\n+\t(compare:CCC (not:I (match_operand:I 0 \"register_operand\" \"r\"))\n+\t\t     (const_int -1)))]\n   \"reload_completed\"\n   \"cmp<s>   r0,%0\"\n   [(set_attr \"type\" \"cmp\")])\n@@ -2065,7 +2099,7 @@\n \n (define_expand \"cbranch<mode>4\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n \t\t       [(match_operand:I 1 \"register_operand\")\n \t\t        (match_operand:I 2 \"reg_or_0_operand\")])\n \t\t      (label_ref (match_operand 3 \"\"))\n@@ -2075,7 +2109,7 @@\n \n (define_insn_and_split \"*cbranch<mode>4_insn\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n \t\t       [(match_operand:I 1 \"register_operand\" \"r\")\n  \t\t        (match_operand:I 2 \"reg_or_0_operand\" \"rO\")])\n \t\t      (label_ref (match_operand 3 \"\"))\n@@ -2093,7 +2127,7 @@\n \n (define_insn_and_split \"*cbranchsi4_btst_insn\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"visium_btst_operator\"\n+\t(if_then_else (match_operator 0 \"visium_equality_comparison_operator\"\n \t\t       [(zero_extract:SI\n \t\t\t   (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t   (const_int 1)"}]}