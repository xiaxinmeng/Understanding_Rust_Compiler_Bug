{"sha": "509c9d60e430b84903eb1232a70871aa93150623", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA5YzlkNjBlNDMwYjg0OTAzZWIxMjMyYTcwODcxYWE5MzE1MDYyMw==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2008-08-21T10:55:13Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2008-08-21T10:55:13Z"}, "message": "diagnostic.c (pedwarn_at): Rename as pedwarn.\n\n2008-08-21  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n\n\t* diagnostic.c (pedwarn_at): Rename as pedwarn.\n\t(pedwarn): Delete.\n\t* toplev.h (pedwarn_at): Likewise.\n\t* builtins.c: Update all calls to pedwarn.\n\t* c-lex.c: Likewise.\n\t* toplev.c: Likewise.\n\t* c-tree.h: Likewise.\n\t* c-decl.c: Likewise.\n\t* c-errors.c: Likewise.\n\t* c-typeck.c: Likewise.\n\t* c-common.c: Likewise.\n\t* c-parser.c: Likewise.\ncp/\n\t* typeck.c: Update all calls to pedwarn.\n\t* decl.c: Likewise.\n\t* call.c: Likewise.\n\t* error.c: Likewise.\n\t* pt.c: Likewise.\n\t* name-lookup.c: Likewise.\n\t* parser.c: Likewise.\nfortran/\t\n\t* f95-lang.c: Update all calls to pedwarn.\n\nFrom-SVN: r139373", "tree": {"sha": "83b0791500b25a6c18b622d8641f3ac55eb3f00b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83b0791500b25a6c18b622d8641f3ac55eb3f00b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/509c9d60e430b84903eb1232a70871aa93150623", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/509c9d60e430b84903eb1232a70871aa93150623", "html_url": "https://github.com/Rust-GCC/gccrs/commit/509c9d60e430b84903eb1232a70871aa93150623", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/509c9d60e430b84903eb1232a70871aa93150623/comments", "author": null, "committer": null, "parents": [{"sha": "2fb63453bdd24fff367b4ddb18c59b3972520728", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fb63453bdd24fff367b4ddb18c59b3972520728", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fb63453bdd24fff367b4ddb18c59b3972520728"}], "stats": {"total": 631, "additions": 336, "deletions": 295}, "files": [{"sha": "2f3db969cf604c80633a7d5b62e8a9155b861ebb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -1,3 +1,18 @@\n+2008-08-21  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\t* diagnostic.c (pedwarn_at): Rename as pedwarn.\n+\t(pedwarn): Delete.\n+\t* toplev.h (pedwarn_at): Likewise.\n+\t* builtins.c: Update all calls to pedwarn.\n+\t* c-lex.c: Likewise.\n+\t* toplev.c: Likewise.\n+\t* c-tree.h: Likewise.\n+\t* c-decl.c: Likewise.\n+\t* c-errors.c: Likewise.\n+\t* c-typeck.c: Likewise.\n+\t* c-common.c: Likewise.\n+\t* c-parser.c: Likewise.\n+\n 2008-08-20  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR target/31070"}, {"sha": "669567249848b53288373b34c2ecfd7f7a637665", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -7279,7 +7279,7 @@ fold_builtin_inf (tree type, int warn)\n      Thus we pedwarn to ensure this constraint violation is\n      diagnosed.  */\n   if (!MODE_HAS_INFINITIES (TYPE_MODE (type)) && warn)\n-    pedwarn (0, \"target format does not support infinity\");\n+    pedwarn (input_location, 0, \"target format does not support infinity\");\n \n   real_inf (&real);\n   return build_real (type, real);"}, {"sha": "d51c38f940b2c52aed0b55d8c65aade929ddff3f", "filename": "gcc/c-common.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -1044,7 +1044,7 @@ fname_decl (unsigned int rid, tree id)\n       input_location = saved_location;\n     }\n   if (!ix && !current_function_decl)\n-    pedwarn (0, \"%qD is not defined outside of function scope\", decl);\n+    pedwarn (input_location, 0, \"%qD is not defined outside of function scope\", decl);\n \n   return decl;\n }\n@@ -1093,7 +1093,7 @@ fix_string_type (tree value)\n \t   separate the %d from the 'C'.  'ISO' should not be\n \t   translated, but it may be moved after 'C%d' in languages\n \t   where modifiers follow nouns.  */\n-\tpedwarn (OPT_Woverlength_strings,\n+\tpedwarn (input_location, OPT_Woverlength_strings,\n \t\t \"string length %qd is greater than the length %qd \"\n \t\t \"ISO C%d compilers are required to support\",\n \t\t nchars - 1, nchars_max, relevant_std);\n@@ -1141,7 +1141,7 @@ constant_expression_warning (tree value)\n \t  || TREE_CODE (value) == VECTOR_CST\n \t  || TREE_CODE (value) == COMPLEX_CST)\n       && TREE_OVERFLOW (value))\n-    pedwarn (OPT_Woverflow, \"overflow in constant expression\");\n+    pedwarn (input_location, OPT_Woverflow, \"overflow in constant expression\");\n }\n \n /* The same as above but print an unconditional error.  */\n@@ -1359,7 +1359,7 @@ check_main_parameter_types (tree decl)\n        {\n        case 1:\n          if (TYPE_MAIN_VARIANT (type) != integer_type_node)\n-           pedwarn (OPT_Wmain, \"first argument of %q+D should be %<int%>\", \n+           pedwarn (input_location, OPT_Wmain, \"first argument of %q+D should be %<int%>\", \n \t\t    decl);\n          break;\n \n@@ -1368,7 +1368,7 @@ check_main_parameter_types (tree decl)\n              || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n              || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n                  != char_type_node))\n-           pedwarn (OPT_Wmain, \"second argument of %q+D should be %<char **%>\",\n+           pedwarn (input_location, OPT_Wmain, \"second argument of %q+D should be %<char **%>\",\n \t\t    decl);\n          break;\n \n@@ -1377,7 +1377,7 @@ check_main_parameter_types (tree decl)\n              || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n              || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n                  != char_type_node))\n-\t   pedwarn (OPT_Wmain, \"third argument of %q+D should probably be \"\n+\t   pedwarn (input_location, OPT_Wmain, \"third argument of %q+D should probably be \"\n \t\t    \"%<char **%>\", decl);\n          break;\n        }\n@@ -1387,7 +1387,7 @@ check_main_parameter_types (tree decl)\n     argument because it's only mentioned in an appendix of the\n     standard.  */\n   if (argct > 0 && (argct < 2 || argct > 3))\n-    pedwarn (OPT_Wmain, \"%q+D takes only zero or two arguments\", decl);\n+    pedwarn (input_location, OPT_Wmain, \"%q+D takes only zero or two arguments\", decl);\n }\n \n /* True if pointers to distinct types T1 and T2 can be converted to\n@@ -3285,19 +3285,19 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n \n   if (TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE)\n     {\n-      pedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+      pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t       \"pointer of type %<void *%> used in arithmetic\");\n       size_exp = integer_one_node;\n     }\n   else if (TREE_CODE (TREE_TYPE (result_type)) == FUNCTION_TYPE)\n     {\n-      pedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+      pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t       \"pointer to a function used in arithmetic\");\n       size_exp = integer_one_node;\n     }\n   else if (TREE_CODE (TREE_TYPE (result_type)) == METHOD_TYPE)\n     {\n-      pedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+      pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t       \"pointer to member function used in arithmetic\");\n       size_exp = integer_one_node;\n     }\n@@ -3806,7 +3806,7 @@ c_sizeof_or_alignof_type (tree type, bool is_sizeof, int complain)\n       if (is_sizeof)\n \t{\n \t  if (complain && (pedantic || warn_pointer_arith))\n-\t    pedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t    pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t\t     \"invalid application of %<sizeof%> to a function type\");\n           else if (!complain)\n             return error_mark_node;\n@@ -3819,7 +3819,7 @@ c_sizeof_or_alignof_type (tree type, bool is_sizeof, int complain)\n     {\n       if (type_code == VOID_TYPE\n \t  && complain && (pedantic || warn_pointer_arith))\n-\tpedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\tpedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t\t \"invalid application of %qs to a void type\", op_name);\n       else if (!complain)\n         return error_mark_node;\n@@ -4687,7 +4687,7 @@ c_add_case_label (splay_tree cases, tree cond, tree orig_type,\n \n   /* Case ranges are a GNU extension.  */\n   if (high_value)\n-    pedwarn (OPT_pedantic, \n+    pedwarn (input_location, OPT_pedantic, \n \t     \"range expressions in switch statements are non-standard\");\n \n   type = TREE_TYPE (cond);\n@@ -5001,7 +5001,7 @@ finish_label_address_expr (tree label)\n {\n   tree result;\n \n-  pedwarn (OPT_pedantic, \"taking the address of a label is non-standard\");\n+  pedwarn (input_location, OPT_pedantic, \"taking the address of a label is non-standard\");\n \n   if (label == error_mark_node)\n     return error_mark_node;"}, {"sha": "857e3f25d9e4d5938ce64508c925849fd5e6b59b", "filename": "gcc/c-decl.c", "status": "modified", "additions": 91, "deletions": 70, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -788,7 +788,7 @@ pop_scope (void)\n \t\t   && TREE_PUBLIC (p)\n \t\t   && !DECL_INITIAL (p)\n \t\t   && !flag_gnu89_inline)\n-\t    pedwarn (0, \"inline function %q+D declared but never defined\", p);\n+\t    pedwarn (input_location, 0, \"inline function %q+D declared but never defined\", p);\n \n \t  goto common_symbol;\n \n@@ -1225,7 +1225,8 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t       && TYPE_MAIN_VARIANT (TREE_TYPE (newtype)) == integer_type_node\n \t       && C_FUNCTION_IMPLICIT_INT (newdecl) && !DECL_INITIAL (olddecl))\n \t{\n-\t  pedwarned = pedwarn (0, \"conflicting types for %q+D\", newdecl);\n+\t  pedwarned = pedwarn (input_location, 0,\n+\t\t\t       \"conflicting types for %q+D\", newdecl);\n \t  /* Make sure we keep void as the return type.  */\n \t  TREE_TYPE (newdecl) = *newtypep = newtype = oldtype;\n \t  C_FUNCTION_IMPLICIT_INT (newdecl) = 0;\n@@ -1237,7 +1238,8 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t       && TYPE_MAIN_VARIANT (TREE_TYPE (oldtype)) == integer_type_node\n \t       && C_DECL_IMPLICIT (olddecl) && !DECL_INITIAL (olddecl))\n \t{\n-\t  pedwarned = pedwarn (0, \"conflicting types for %q+D\", newdecl);\n+\t  pedwarned = pedwarn (input_location, 0,\n+\t\t\t       \"conflicting types for %q+D\", newdecl);\n \t  /* Make sure we keep void as the return type.  */\n \t  TREE_TYPE (olddecl) = *oldtypep = oldtype = newtype;\n \t}\n@@ -2329,8 +2331,8 @@ implicit_decl_warning (tree id, tree olddecl)\n       bool warned;\n \n       if (flag_isoc99)\n-\twarned = pedwarn (OPT_Wimplicit_function_declaration, \n-\t\t\t  G_(\"implicit declaration of function %qE\"), id);\n+\twarned = pedwarn (input_location, OPT_Wimplicit_function_declaration,\n+\t\t\t  \"implicit declaration of function %qE\", id);\n       else \n \twarned = warning (OPT_Wimplicit_function_declaration, \n \t\t\t  G_(\"implicit declaration of function %qE\"), id);\n@@ -2882,16 +2884,18 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \t      if (warned != 1 && code != ENUMERAL_TYPE)\n \t\t/* Empty unnamed enum OK */\n \t\t{\n-\t\t  pedwarn (0, \"unnamed struct/union that defines no instances\");\n+\t\t  pedwarn (input_location, 0,\n+\t\t\t   \"unnamed struct/union that defines no instances\");\n \t\t  warned = 1;\n \t\t}\n \t    }\n \t  else if (!declspecs->tag_defined_p\n \t\t   && declspecs->storage_class != csc_none)\n \t    {\n \t      if (warned != 1)\n-\t\tpedwarn (0, \"empty declaration with storage class specifier \"\n-\t\t\t  \"does not redeclare tag\");\n+\t\tpedwarn (input_location, 0,\n+\t\t\t \"empty declaration with storage class specifier \"\n+\t\t\t \"does not redeclare tag\");\n \t      warned = 1;\n \t      pending_xref_error ();\n \t    }\n@@ -2901,7 +2905,8 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \t\t       || declspecs->restrict_p))\n \t    {\n \t      if (warned != 1)\n-\t\tpedwarn (0, \"empty declaration with type qualifier \"\n+\t\tpedwarn (input_location, 0,\n+\t\t\t \"empty declaration with type qualifier \"\n \t\t\t  \"does not redeclare tag\");\n \t      warned = 1;\n \t      pending_xref_error ();\n@@ -2922,14 +2927,15 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \t{\n \t  if (warned != 1 && !in_system_header)\n \t    {\n-\t      pedwarn (0, \"useless type name in empty declaration\");\n+\t      pedwarn (input_location, 0,\n+\t\t       \"useless type name in empty declaration\");\n \t      warned = 1;\n \t    }\n \t}\n     }\n   else if (warned != 1 && !in_system_header && declspecs->typedef_p)\n     {\n-      pedwarn (0, \"useless type name in empty declaration\");\n+      pedwarn (input_location, 0, \"useless type name in empty declaration\");\n       warned = 1;\n     }\n \n@@ -2976,7 +2982,7 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n   if (warned != 1)\n     {\n       if (!found_tag)\n-\tpedwarn (0, \"empty declaration\");\n+\tpedwarn (input_location, 0, \"empty declaration\");\n     }\n }\n \f\n@@ -3042,10 +3048,12 @@ build_array_declarator (tree expr, struct c_declspecs *quals, bool static_p,\n   if (!flag_isoc99)\n     {\n       if (static_p || quals != NULL)\n-\tpedwarn (OPT_pedantic, \"ISO C90 does not support %<static%> or type \"\n+\tpedwarn (input_location, OPT_pedantic,\n+\t\t \"ISO C90 does not support %<static%> or type \"\n \t\t \"qualifiers in parameter array declarators\");\n       if (vla_unspec_p)\n-\tpedwarn (OPT_pedantic, \"ISO C90 does not support %<[*]%> array declarators\");\n+\tpedwarn (input_location, OPT_pedantic,\n+\t\t \"ISO C90 does not support %<[*]%> array declarators\");\n     }\n   if (vla_unspec_p)\n     {\n@@ -3300,8 +3308,9 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n       && !TREE_READONLY (decl)\n       && DECL_DECLARED_INLINE_P (current_function_decl)\n       && DECL_EXTERNAL (current_function_decl))\n-    pedwarn (0, \"%q+D is static but declared in inline function %qD \"\n-\t      \"which is not static\", decl, current_function_decl);\n+    pedwarn (input_location, 0,\n+\t     \"%q+D is static but declared in inline function %qD \"\n+\t     \"which is not static\", decl, current_function_decl);\n \n   /* Add this decl to the current scope.\n      TEM may equal DECL or it may be a previous decl of the same name.  */\n@@ -3674,7 +3683,8 @@ mark_forward_parm_decls (void)\n \n   if (pedantic && !current_scope->warned_forward_parm_decls)\n     {\n-      pedwarn (OPT_pedantic, \"ISO C forbids forward parameter declarations\");\n+      pedwarn (input_location, OPT_pedantic,\n+\t       \"ISO C forbids forward parameter declarations\");\n       current_scope->warned_forward_parm_decls = true;\n     }\n \n@@ -3825,7 +3835,8 @@ check_bitfield_type_and_width (tree *type, tree *width, const char *orig_name)\n       && type_mv != integer_type_node\n       && type_mv != unsigned_type_node\n       && type_mv != boolean_type_node)\n-    pedwarn (OPT_pedantic, \"type of bit-field %qs is a GCC extension\", name);\n+    pedwarn (input_location, OPT_pedantic,\n+\t     \"type of bit-field %qs is a GCC extension\", name);\n \n   max_width = TYPE_PRECISION (*type);\n \n@@ -3862,20 +3873,20 @@ warn_variable_length_array (const char *name, tree size)\n       if (const_size)\n \t{\n \t  if (name)\n-\t    pedwarn (OPT_Wvla, \"ISO C90 forbids array %qs whose size \"\n+\t    pedwarn (input_location, OPT_Wvla, \"ISO C90 forbids array %qs whose size \"\n \t\t     \"can%'t be evaluated\",\n \t\t     name);\n \t  else\n-\t    pedwarn (OPT_Wvla, \"ISO C90 forbids array whose size \"\n+\t    pedwarn (input_location, OPT_Wvla, \"ISO C90 forbids array whose size \"\n \t\t     \"can%'t be evaluated\");\n \t}\n       else\n \t{\n \t  if (name) \n-\t    pedwarn (OPT_Wvla, \"ISO C90 forbids variable length array %qs\",\n+\t    pedwarn (input_location, OPT_Wvla, \"ISO C90 forbids variable length array %qs\",\n \t\t     name);\n \t  else\n-\t    pedwarn (OPT_Wvla, \"ISO C90 forbids variable length array\");\n+\t    pedwarn (input_location, OPT_Wvla, \"ISO C90 forbids variable length array\");\n \t}\n     }\n   else if (warn_vla > 0)\n@@ -4037,7 +4048,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  && funcdef_flag)\n \twarn_about_return_type = 1;\n       else \n-\tpedwarn_c99 (flag_isoc99 ? 0 : OPT_Wimplicit_int, \n+\tpedwarn_c99 (input_location, flag_isoc99 ? 0 : OPT_Wimplicit_int, \n \t\t     \"type defaults to %<int%> in declaration of %qs\", name);\n     }\n \n@@ -4066,11 +4077,11 @@ grokdeclarator (const struct c_declarator *declarator,\n   if (pedantic && !flag_isoc99)\n     {\n       if (constp > 1)\n-\tpedwarn (OPT_pedantic, \"duplicate %<const%>\");\n+\tpedwarn (input_location, OPT_pedantic, \"duplicate %<const%>\");\n       if (restrictp > 1)\n-\tpedwarn (OPT_pedantic, \"duplicate %<restrict%>\");\n+\tpedwarn (input_location, OPT_pedantic, \"duplicate %<restrict%>\");\n       if (volatilep > 1)\n-\tpedwarn (OPT_pedantic, \"duplicate %<volatile%>\");\n+\tpedwarn (input_location, OPT_pedantic, \"duplicate %<volatile%>\");\n     }\n   if (!flag_gen_aux_info && (TYPE_QUALS (element_type)))\n     type = TYPE_MAIN_VARIANT (type);\n@@ -4088,7 +4099,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  || storage_class == csc_typedef))\n     {\n       if (storage_class == csc_auto)\n-\tpedwarn ((current_scope == file_scope) ? 0 : OPT_pedantic, \n+\tpedwarn (input_location, \n+\t\t (current_scope == file_scope) ? 0 : OPT_pedantic, \n \t\t \"function definition declared %<auto%>\");\n       if (storage_class == csc_register)\n \terror (\"function definition declared %<register%>\");\n@@ -4145,7 +4157,8 @@ grokdeclarator (const struct c_declarator *declarator,\n       if (storage_class == csc_auto)\n \terror (\"file-scope declaration of %qs specifies %<auto%>\", name);\n       if (pedantic && storage_class == csc_register)\n-\tpedwarn (OPT_pedantic, \"file-scope declaration of %qs specifies %<register%>\", name);\n+\tpedwarn (input_location, OPT_pedantic,\n+\t\t \"file-scope declaration of %qs specifies %<register%>\", name);\n     }\n   else\n     {\n@@ -4258,7 +4271,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \t      }\n \n \t    if (pedantic && !in_system_header && flexible_array_type_p (type))\n-\t      pedwarn (OPT_pedantic, \"invalid use of structure with flexible array member\");\n+\t      pedwarn (input_location, OPT_pedantic,\n+\t\t       \"invalid use of structure with flexible array member\");\n \n \t    if (size == error_mark_node)\n \t      type = error_mark_node;\n@@ -4283,7 +4297,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t  }\n \n \t\tif (pedantic && integer_zerop (size))\n-\t\t  pedwarn (OPT_pedantic, \"ISO C forbids zero-size array %qs\", name);\n+\t\t  pedwarn (input_location, OPT_pedantic,\n+\t\t\t   \"ISO C forbids zero-size array %qs\", name);\n \n \t\tif (TREE_CODE (size) == INTEGER_CST)\n \t\t  {\n@@ -4355,7 +4370,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    else if (decl_context == FIELD)\n \t      {\n \t\tif (pedantic && !flag_isoc99 && !in_system_header)\n-\t\t  pedwarn (OPT_pedantic, \"ISO C90 does not support flexible array members\");\n+\t\t  pedwarn (input_location, OPT_pedantic,\n+\t\t\t   \"ISO C90 does not support flexible array members\");\n \n \t\t/* ISO C99 Flexible array members are effectively\n \t\t   identical to GCC's zero-length array extension.  */\n@@ -4500,7 +4516,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t   function definitions in ISO C; GCC used to used\n \t\t   them for noreturn functions.  */\n \t\tif (VOID_TYPE_P (type) && really_funcdef)\n-\t\t  pedwarn (0, \"function definition has qualified void return type\");\n+\t\t  pedwarn (input_location, 0,\n+\t\t\t   \"function definition has qualified void return type\");\n \t\telse\n \t\t  warning (OPT_Wignored_qualifiers,\n \t\t\t   \"type qualifiers ignored on function return type\");\n@@ -4532,7 +4549,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \n \t    if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n \t\t&& type_quals)\n-\t      pedwarn (OPT_pedantic, \"ISO C forbids qualified function types\");\n+\t      pedwarn (input_location, OPT_pedantic,\n+\t\t       \"ISO C forbids qualified function types\");\n \t    if (type_quals)\n \t      type = c_build_qualified_type (type, type_quals);\n \t    size_varies = 0;\n@@ -4613,15 +4631,16 @@ grokdeclarator (const struct c_declarator *declarator,\n       tree decl;\n       if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n \t  && type_quals)\n-\tpedwarn (OPT_pedantic, \"ISO C forbids qualified function types\");\n+\tpedwarn (input_location, OPT_pedantic,\n+\t\t \"ISO C forbids qualified function types\");\n       if (type_quals)\n \ttype = c_build_qualified_type (type, type_quals);\n       decl = build_decl (TYPE_DECL, declarator->u.id, type);\n       DECL_SOURCE_LOCATION (decl) = declarator->id_loc;\n       if (declspecs->explicit_signed_p)\n \tC_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;\n       if (declspecs->inline_p)\n-\tpedwarn (0, \"typedef %q+D declared %<inline%>\", decl);\n+\tpedwarn (input_location, 0,\"typedef %q+D declared %<inline%>\", decl);\n       return decl;\n     }\n \n@@ -4636,7 +4655,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t  && !declspecs->inline_p);\n       if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n \t  && type_quals)\n-\tpedwarn (OPT_pedantic, \"ISO C forbids const or volatile function types\");\n+\tpedwarn (input_location, OPT_pedantic,\n+\t\t \"ISO C forbids const or volatile function types\");\n       if (type_quals)\n \ttype = c_build_qualified_type (type, type_quals);\n       return type;\n@@ -4646,7 +4666,7 @@ grokdeclarator (const struct c_declarator *declarator,\n       && variably_modified_type_p (type, NULL_TREE))\n     {\n       /* C99 6.7.2.1p8 */\n-      pedwarn (OPT_pedantic, \n+      pedwarn (input_location, OPT_pedantic, \n \t       \"a member of a structure or union cannot have a variably modified type\");\n     }\n \n@@ -4701,7 +4721,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \telse if (TREE_CODE (type) == FUNCTION_TYPE)\n \t  {\n \t    if (type_quals)\n-\t      pedwarn (OPT_pedantic, \"ISO C forbids qualified function types\");\n+\t      pedwarn (input_location, OPT_pedantic,\n+\t\t       \"ISO C forbids qualified function types\");\n \t    if (type_quals)\n \t      type = c_build_qualified_type (type, type_quals);\n \t    type = build_pointer_type (type);\n@@ -4727,7 +4748,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \n \tDECL_ARG_TYPE (decl) = promoted_type;\n \tif (declspecs->inline_p)\n-\t  pedwarn (0, \"parameter %q+D declared %<inline%>\", decl);\n+\t  pedwarn (input_location, 0, \"parameter %q+D declared %<inline%>\", decl);\n       }\n     else if (decl_context == FIELD)\n       {\n@@ -4773,7 +4794,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t       GCC allows 'auto', perhaps with 'inline', to support\n \t       nested functions.  */\n \t    if (storage_class == csc_auto)\n-\t\tpedwarn (OPT_pedantic, \"invalid storage class for function %qs\", name);\n+\t\tpedwarn (input_location, OPT_pedantic, \"invalid storage class for function %qs\", name);\n \t    else if (storage_class == csc_static)\n \t      {\n \t\terror (\"invalid storage class for function %qs\", name);\n@@ -4789,7 +4810,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \tdecl = build_decl_attribute_variant (decl, decl_attr);\n \n \tif (pedantic && type_quals && !DECL_IN_SYSTEM_HEADER (decl))\n-\t  pedwarn (OPT_pedantic,\n+\t  pedwarn (input_location, OPT_pedantic,\n \t\t   \"ISO C forbids qualified function types\");\n \n \t/* GNU C interprets a volatile-qualified function type to indicate\n@@ -4832,7 +4853,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \tif (flag_hosted && MAIN_NAME_P (declarator->u.id))\n \t  {\n \t    if (declspecs->inline_p)\n-\t      pedwarn (0, \"cannot inline function %<main%>\");\n+\t      pedwarn (input_location, 0, \"cannot inline function %<main%>\");\n \t  }\n \telse if (declspecs->inline_p)\n \t  /* Record that the function is declared `inline'.  */\n@@ -4871,7 +4892,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  C_DECL_VARIABLE_SIZE (decl) = 1;\n \n \tif (declspecs->inline_p)\n-\t  pedwarn (0, \"variable %q+D declared %<inline%>\", decl);\n+\t  pedwarn (input_location, 0, \"variable %q+D declared %<inline%>\", decl);\n \n \t/* At file scope, an initialized extern declaration may follow\n \t   a static declaration.  In that case, DECL_EXTERNAL will be\n@@ -4979,7 +5000,7 @@ grokparms (struct c_arg_info *arg_info, bool funcdef_flag)\n   else if (arg_types && TREE_CODE (TREE_VALUE (arg_types)) == IDENTIFIER_NODE)\n     {\n       if (!funcdef_flag)\n-\tpedwarn (0, \"parameter names (without types) in function declaration\");\n+\tpedwarn (input_location, 0, \"parameter names (without types) in function declaration\");\n \n       arg_info->parms = arg_info->types;\n       arg_info->types = 0;\n@@ -5393,10 +5414,10 @@ grokfield (struct c_declarator *declarator, struct c_declspecs *declspecs,\n \t}\n       if (!ok)\n \t{\n-\t  pedwarn (0, \"declaration does not declare anything\");\n+\t  pedwarn (input_location, 0, \"declaration does not declare anything\");\n \t  return NULL_TREE;\n \t}\n-      pedwarn (OPT_pedantic, \"ISO C doesn%'t support unnamed structs/unions\");\n+      pedwarn (input_location, OPT_pedantic, \"ISO C doesn%'t support unnamed structs/unions\");\n     }\n \n   value = grokdeclarator (declarator, declspecs, FIELD, false,\n@@ -5495,16 +5516,16 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t  if (TREE_CODE (t) == UNION_TYPE)\n \t    {\n \t      if (fieldlist)\n-\t\tpedwarn (OPT_pedantic, \"union has no named members\");\n+\t\tpedwarn (input_location, OPT_pedantic, \"union has no named members\");\n \t      else\n-\t\tpedwarn (OPT_pedantic, \"union has no members\");\n+\t\tpedwarn (input_location, OPT_pedantic, \"union has no members\");\n \t    }\n \t  else\n \t    {\n \t      if (fieldlist)\n-\t\tpedwarn (OPT_pedantic, \"struct has no named members\");\n+\t\tpedwarn (input_location, OPT_pedantic, \"struct has no named members\");\n \t      else\n-\t\tpedwarn (OPT_pedantic, \"struct has no members\");\n+\t\tpedwarn (input_location, OPT_pedantic, \"struct has no members\");\n \t    }\n \t}\n     }\n@@ -5583,7 +5604,7 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \n       if (pedantic && !in_system_header && TREE_CODE (t) == RECORD_TYPE\n \t  && flexible_array_type_p (TREE_TYPE (x)))\n-\tpedwarn (OPT_pedantic, \n+\tpedwarn (input_location, OPT_pedantic, \n \t\t \"%Jinvalid use of structure with flexible array member\", x);\n \n       if (DECL_NAME (x))\n@@ -5974,8 +5995,8 @@ build_enumerator (struct c_enum_contents *the_enum, tree name, tree value,\n      (6.4.4.3/2 in the C99 Standard).  GCC allows any integer type as\n      an extension.  */\n   else if (!int_fits_type_p (value, integer_type_node))\n-    pedwarn_at (value_loc, OPT_pedantic, \n-\t\t\"ISO C restricts enumerator values to range of %<int%>\");\n+    pedwarn (value_loc, OPT_pedantic, \n+\t     \"ISO C restricts enumerator values to range of %<int%>\");\n \n   /* Set basis for default for next value.  */\n   the_enum->enum_next_value = build_binary_op (PLUS_EXPR, value,\n@@ -6087,7 +6108,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n     }\n \n   if (warn_about_return_type)\n-    pedwarn_c99 (flag_isoc99 ? 0 \n+    pedwarn_c99 (input_location, flag_isoc99 ? 0 \n \t\t : (warn_return_type ? OPT_Wreturn_type : OPT_Wimplicit_int),\n \t\t \"return type defaults to %<int%>\");\n \n@@ -6210,12 +6231,12 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n     {\n       if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (decl1)))\n \t  != integer_type_node)\n-\tpedwarn (OPT_Wmain, \"return type of %q+D is not %<int%>\", decl1);\n+\tpedwarn (input_location, OPT_Wmain, \"return type of %q+D is not %<int%>\", decl1);\n \n       check_main_parameter_types (decl1);\n \n       if (!TREE_PUBLIC (decl1))\n-\tpedwarn (OPT_Wmain, \"%q+D is normally a non-static function\", decl1);\n+\tpedwarn (input_location, OPT_Wmain, \"%q+D is normally a non-static function\", decl1);\n     }\n \n   /* Record the decl so that the function name is defined.\n@@ -6363,7 +6384,7 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t  warn_if_shadowing (decl);\n \n \t  if (flag_isoc99)\n-\t    pedwarn (0, \"type of %q+D defaults to %<int%>\", decl);\n+\t    pedwarn (input_location, 0, \"type of %q+D defaults to %<int%>\", decl);\n \t  else \n \t    warning (OPT_Wmissing_parameter_type, \"type of %q+D defaults to %<int%>\", decl);\n \t}\n@@ -6483,10 +6504,10 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t\t\t     \"doesn%'t match built-in prototype\", parm);\n \t\t  else\n \t\t    {\n-\t\t      pedwarn (OPT_pedantic, \"promoted argument %qD \"\n+\t\t      pedwarn (input_location, OPT_pedantic, \"promoted argument %qD \"\n \t\t\t       \"doesn%'t match prototype\", parm);\n-\t\t      pedwarn (OPT_pedantic, \"%Hprototype declaration\",\n-\t\t\t       &current_function_prototype_locus);\n+\t\t      pedwarn (current_function_prototype_locus, OPT_pedantic,\n+\t\t\t       \"prototype declaration\");\n \t\t    }\n \t\t}\n \t      else\n@@ -7119,7 +7140,7 @@ declspecs_add_qual (struct c_declspecs *specs, tree qual)\n       gcc_unreachable ();\n     }\n   if (dupe && !flag_isoc99)\n-    pedwarn (OPT_pedantic, \"duplicate %qE\", qual);\n+    pedwarn (input_location, OPT_pedantic, \"duplicate %qE\", qual);\n   return specs;\n }\n \n@@ -7168,7 +7189,7 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t\t      break;\n \t\t    }\n \t\t  if (pedantic && !flag_isoc99 && !in_system_header)\n-\t\t    pedwarn (OPT_Wlong_long, \"ISO C90 does not support %<long long%>\");\n+\t\t    pedwarn (input_location, OPT_Wlong_long, \"ISO C90 does not support %<long long%>\");\n \t\t  specs->long_long_p = 1;\n \t\t  break;\n \t\t}\n@@ -7292,7 +7313,7 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t    case RID_COMPLEX:\n \t      dupe = specs->complex_p;\n \t      if (!flag_isoc99 && !in_system_header)\n-\t\tpedwarn (OPT_pedantic, \"ISO C90 does not support complex types\");\n+\t\tpedwarn (input_location, OPT_pedantic, \"ISO C90 does not support complex types\");\n \t      if (specs->typespec_word == cts_void)\n \t\terror (\"both %<complex%> and %<void%> in \"\n \t\t       \"declaration specifiers\");\n@@ -7322,7 +7343,7 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      break;\n \t    case RID_SAT:\n \t      dupe = specs->saturating_p;\n-\t      pedwarn (OPT_pedantic, \"ISO C does not support saturating types\");\n+\t      pedwarn (input_location, OPT_pedantic, \"ISO C does not support saturating types\");\n \t      if (specs->typespec_word == cts_void)\n \t\terror (\"both %<_Sat%> and %<void%> in \"\n \t\t       \"declaration specifiers\");\n@@ -7519,7 +7540,7 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      }\n \t      if (!targetm.decimal_float_supported_p ())\n \t\terror (\"decimal floating point not supported for this target\");\n-\t      pedwarn (OPT_pedantic, \n+\t      pedwarn (input_location, OPT_pedantic, \n \t\t       \"ISO C does not support decimal floating point\");\n \t      return specs;\n \t    case RID_FRACT:\n@@ -7540,7 +7561,7 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      }\n \t      if (!targetm.fixed_point_supported_p ())\n \t\terror (\"fixed-point types not supported for this target\");\n-\t      pedwarn (OPT_pedantic, \n+\t      pedwarn (input_location, OPT_pedantic, \n \t\t       \"ISO C does not support fixed-point types\");\n \t      return specs;\n \t    default:\n@@ -7727,7 +7748,7 @@ finish_declspecs (struct c_declspecs *specs)\n       else if (specs->complex_p)\n \t{\n \t  specs->typespec_word = cts_double;\n-\t  pedwarn (OPT_pedantic, \n+\t  pedwarn (input_location, OPT_pedantic, \n \t\t   \"ISO C does not support plain %<complex%> meaning \"\n \t\t   \"%<double complex%>\");\n \t}\n@@ -7772,7 +7793,7 @@ finish_declspecs (struct c_declspecs *specs)\n \tspecs->type = char_type_node;\n       if (specs->complex_p)\n \t{\n-\t  pedwarn (OPT_pedantic, \n+\t  pedwarn (input_location, OPT_pedantic, \n \t\t   \"ISO C does not support complex integer types\");\n \t  specs->type = build_complex_type (specs->type);\n \t}\n@@ -7798,7 +7819,7 @@ finish_declspecs (struct c_declspecs *specs)\n \t\t       : integer_type_node);\n       if (specs->complex_p)\n \t{\n-\t  pedwarn (OPT_pedantic, \n+\t  pedwarn (input_location, OPT_pedantic, \n \t\t   \"ISO C does not support complex integer types\");\n \t  specs->type = build_complex_type (specs->type);\n \t}\n@@ -7949,7 +7970,7 @@ c_write_global_declarations_1 (tree globals)\n \t  && !TREE_PUBLIC (decl)\n \t  && C_DECL_USED (decl))\n \t{\n-\t  pedwarn (0, \"%q+F used but never defined\", decl);\n+\t  pedwarn (input_location, 0, \"%q+F used but never defined\", decl);\n \t  TREE_NO_WARNING (decl) = 1;\n \t}\n "}, {"sha": "454585893e12fd882afd57f87d24588395aec647", "filename": "gcc/c-errors.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fc-errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fc-errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-errors.c?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -31,13 +31,13 @@ along with GCC; see the file COPYING3.  If not see\n /* Issue an ISO C99 pedantic warning MSGID.  */\n \n void\n-pedwarn_c99 (int opt, const char *gmsgid, ...)\n+pedwarn_c99 (location_t location, int opt, const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n \n   va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, input_location,\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, location,\n \t\t       flag_isoc99 ? DK_PEDWARN : DK_WARNING);\n   diagnostic.option_index = opt;\n   report_diagnostic (&diagnostic);\n@@ -50,13 +50,13 @@ pedwarn_c99 (int opt, const char *gmsgid, ...)\n    (There is no flag_c90.)  */\n \n void\n-pedwarn_c90 (int opt, const char *gmsgid, ...)\n+pedwarn_c90 (location_t location, int opt, const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n \n   va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, input_location,\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, location,\n \t\t       flag_isoc99 ? DK_WARNING : DK_PEDWARN);\n   diagnostic.option_index = opt;\n   report_diagnostic (&diagnostic);"}, {"sha": "5b71c3b0d8fd512439048cc84245ab261c285ec8", "filename": "gcc/c-lex.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -587,8 +587,8 @@ interpret_integer (const cpp_token *token, unsigned int flags)\n   if (itk > itk_unsigned_long\n       && (flags & CPP_N_WIDTH) != CPP_N_LARGE\n       && !in_system_header && !flag_isoc99)\n-    pedwarn (0, \"integer constant is too large for %qs type\",\n-\t      (flags & CPP_N_UNSIGNED) ? \"unsigned long\" : \"long\");\n+    pedwarn (input_location, 0, \"integer constant is too large for %qs type\",\n+\t     (flags & CPP_N_UNSIGNED) ? \"unsigned long\" : \"long\");\n \n   value = build_int_cst_wide (type, integer.low, integer.high);\n \n@@ -642,7 +642,7 @@ interpret_float (const cpp_token *token, unsigned int flags)\n \t    return error_mark_node;\n \t  }\n \telse\n-\t  pedwarn (OPT_pedantic, \"non-standard suffix on floating constant\");\n+\t  pedwarn (input_location, OPT_pedantic, \"non-standard suffix on floating constant\");\n \n \ttype = c_common_type_for_mode (mode, 0);\n \tgcc_assert (type);\n@@ -684,7 +684,7 @@ interpret_float (const cpp_token *token, unsigned int flags)\n   if (REAL_VALUE_ISINF (real)) \n     {\n       if (!MODE_HAS_INFINITIES (TYPE_MODE (type)))\n-\tpedwarn (0, \"floating constant exceeds range of %qT\", type);\n+\tpedwarn (input_location, 0, \"floating constant exceeds range of %qT\", type);\n       else\n \twarning (OPT_Woverflow, \"floating constant exceeds range of %qT\", type);\n     }"}, {"sha": "7b7d86933320e22d35dd02ec6923f5b0aa37576b", "filename": "gcc/c-parser.c", "status": "modified", "additions": 42, "deletions": 62, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -967,8 +967,8 @@ c_parser_translation_unit (c_parser *parser)\n {\n   if (c_parser_next_token_is (parser, CPP_EOF))\n     {\n-      pedwarn (OPT_pedantic, \"%HISO C forbids an empty translation unit\",\n-\t       &c_parser_peek_token (parser)->location);\n+      pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, \n+\t       \"ISO C forbids an empty translation unit\");\n     }\n   else\n     {\n@@ -1052,9 +1052,8 @@ c_parser_external_declaration (c_parser *parser)\n \t}\n       break;\n     case CPP_SEMICOLON:\n-      pedwarn (OPT_pedantic, \n-\t       \"%HISO C does not allow extra %<;%> outside of a function\",\n-\t       &c_parser_peek_token (parser)->location);\n+      pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, \n+\t       \"ISO C does not allow extra %<;%> outside of a function\");\n       c_parser_consume_token (parser);\n       break;\n     case CPP_PRAGMA:\n@@ -1168,7 +1167,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,\n       else\n \t{\n \t  shadow_tag_warned (specs, 1);\n-\t  pedwarn (0, \"%Hempty declaration\", &here);\n+\t  pedwarn (here, 0, \"empty declaration\");\n \t}\n       c_parser_consume_token (parser);\n       return;\n@@ -1204,8 +1203,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,\n \t  if (!diagnosed_no_specs && !specs->declspecs_seen_p)\n \t    {\n \t      diagnosed_no_specs = true;\n-\t      pedwarn (0, \"%Hdata definition has no type or storage class\",\n-\t\t\t&here);\n+\t      pedwarn (here, 0, \"data definition has no type or storage class\");\n \t    }\n \t  /* Having seen a data definition, there cannot now be a\n \t     function definition.  */\n@@ -1274,7 +1272,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,\n       /* Function definition (nested or otherwise).  */\n       if (nested)\n \t{\n-\t  pedwarn (OPT_pedantic, \"%HISO C forbids nested functions\", &here);\n+\t  pedwarn (here, OPT_pedantic, \"ISO C forbids nested functions\");\n \t  c_push_function_context ();\n \t}\n       if (!start_function (specs, declarator, all_prefix_attrs))\n@@ -1674,8 +1672,7 @@ c_parser_enum_specifier (c_parser *parser)\n \t  if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n \t    {\n \t      if (seen_comma && !flag_isoc99)\n-\t\tpedwarn (OPT_pedantic, \"%Hcomma at end of enumerator list\", \n-\t\t\t &comma_loc);\n+\t\tpedwarn (comma_loc, OPT_pedantic, \"comma at end of enumerator list\");\n \t      c_parser_consume_token (parser);\n \t      break;\n \t    }\n@@ -1706,9 +1703,8 @@ c_parser_enum_specifier (c_parser *parser)\n   if (pedantic && !COMPLETE_TYPE_P (ret.spec))\n     {\n       gcc_assert (ident);\n-      pedwarn (OPT_pedantic,\n-\t       \"%HISO C forbids forward references to %<enum%> types\",\n-\t       &ident_loc);\n+      pedwarn (ident_loc, OPT_pedantic,\n+\t       \"ISO C forbids forward references to %<enum%> types\");\n     }\n   return ret;\n }\n@@ -1832,9 +1828,8 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t  /* Parse any stray semicolon.  */\n \t  if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n \t    {\n-\t      pedwarn (OPT_pedantic, \n-\t\t       \"%Hextra semicolon in struct or union specified\",\n-\t\t       &c_parser_peek_token (parser)->location);\n+\t      pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, \n+\t\t       \"extra semicolon in struct or union specified\");\n \t      c_parser_consume_token (parser);\n \t      continue;\n \t    }\n@@ -1862,8 +1857,8 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t  else\n \t    {\n \t      if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n-\t\tpedwarn (0, \"%Hno semicolon at end of struct or union\",\n-\t\t\t  &c_parser_peek_token (parser)->location);\n+\t\tpedwarn (c_parser_peek_token (parser)->location, 0, \n+\t\t\t \"no semicolon at end of struct or union\");\n \t      else\n \t\t{\n \t\t  c_parser_error (parser, \"expected %<;%>\");\n@@ -1954,9 +1949,8 @@ c_parser_struct_declaration (c_parser *parser)\n       tree ret;\n       if (!specs->type_seen_p)\n \t{\n-\t  pedwarn (OPT_pedantic, \n-\t\t   \"%HISO C forbids member declarations with no members\",\n-\t\t   &decl_loc);\n+\t  pedwarn (decl_loc, OPT_pedantic, \n+\t\t   \"ISO C forbids member declarations with no members\");\n \t  shadow_tag_warned (specs, pedantic);\n \t  ret = NULL_TREE;\n \t}\n@@ -3014,8 +3008,7 @@ c_parser_braced_init (c_parser *parser, tree type, bool nested_p)\n     really_start_incremental_init (type);\n   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n     {\n-      pedwarn (OPT_pedantic, \"%HISO C forbids empty initializer braces\",\n-\t       &brace_loc);\n+      pedwarn (brace_loc, OPT_pedantic, \"ISO C forbids empty initializer braces\");\n     }\n   else\n     {\n@@ -3060,9 +3053,8 @@ c_parser_initelt (c_parser *parser)\n       /* Old-style structure member designator.  */\n       set_init_label (c_parser_peek_token (parser)->value);\n       /* Use the colon as the error location.  */\n-      pedwarn (OPT_pedantic, \n-\t       \"%Hobsolete use of designated initializer with %<:%>\",\n-\t       &c_parser_peek_2nd_token (parser)->location);\n+      pedwarn (c_parser_peek_2nd_token (parser)->location, OPT_pedantic, \n+\t       \"obsolete use of designated initializer with %<:%>\");\n       c_parser_consume_token (parser);\n       c_parser_consume_token (parser);\n     }\n@@ -3191,9 +3183,8 @@ c_parser_initelt (c_parser *parser)\n \t\t  c_parser_consume_token (parser);\n \t\t  set_init_index (first, second);\n \t\t  if (second)\n-\t\t    pedwarn (OPT_pedantic, \n-\t\t\t     \"%HISO C forbids specifying range of \"\n-\t\t\t     \"elements to initialize\", &ellipsis_loc);\n+\t\t    pedwarn (ellipsis_loc, OPT_pedantic, \n+\t\t\t     \"ISO C forbids specifying range of elements to initialize\");\n \t\t}\n \t      else\n \t\tc_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,\n@@ -3205,20 +3196,15 @@ c_parser_initelt (c_parser *parser)\n \t  if (c_parser_next_token_is (parser, CPP_EQ))\n \t    {\n \t      if (!flag_isoc99)\n-\t\tpedwarn (OPT_pedantic, \n-\t\t\t \"%HISO C90 forbids specifying subobject \"\n-\t\t\t \"to initialize\", &des_loc);\n+\t\tpedwarn (des_loc, OPT_pedantic, \n+\t\t\t \"ISO C90 forbids specifying subobject to initialize\");\n \t      c_parser_consume_token (parser);\n \t    }\n \t  else\n \t    {\n \t      if (des_seen == 1)\n-\t\t{\n-\t\t  pedwarn (OPT_pedantic, \n-\t\t\t   \"%Hobsolete use of designated initializer \"\n-\t\t\t   \"without %<=%>\",\n-\t\t\t   &c_parser_peek_token (parser)->location);\n-\t\t}\n+\t\tpedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, \n+\t\t\t \"obsolete use of designated initializer without %<=%>\");\n \t      else\n \t\t{\n \t\t  struct c_expr init;\n@@ -3368,7 +3354,7 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t    }\n \t  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n \t}\n-      pedwarn (OPT_pedantic, \"%HISO C forbids label declarations\", &err_loc);\n+      pedwarn (err_loc, OPT_pedantic, \"ISO C forbids label declarations\");\n     }\n   /* We must now have at least one statement, label or declaration.  */\n   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n@@ -3399,11 +3385,11 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t  last_label = false;\n \t  c_parser_declaration_or_fndef (parser, true, true, true, true);\n \t  if (last_stmt)\n-\t    pedwarn_c90 ((pedantic && !flag_isoc99)\n+\t    pedwarn_c90 (loc, \n+\t\t\t (pedantic && !flag_isoc99)\n \t\t\t ? OPT_pedantic\n \t\t\t : OPT_Wdeclaration_after_statement,\n-\t\t\t \"%HISO C90 forbids mixed declarations and code\",\n-\t\t\t &loc);\n+\t\t\t \"ISO C90 forbids mixed declarations and code\");\n \t  last_stmt = false;\n \t}\n       else if (!last_label\n@@ -3428,11 +3414,10 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t\t disable this diagnostic.  */\n \t      restore_extension_diagnostics (ext);\n \t      if (last_stmt)\n-\t\tpedwarn_c90 ((pedantic && !flag_isoc99)\n+\t\tpedwarn_c90 (loc, (pedantic && !flag_isoc99)\n \t\t\t     ? OPT_pedantic\n \t\t\t     : OPT_Wdeclaration_after_statement,\n-\t\t\t     \"%HISO C90 forbids mixed declarations and code\",\n-\t\t\t     &loc);\n+\t\t\t     \"ISO C90 forbids mixed declarations and code\");\n \t      last_stmt = false;\n \t    }\n \t  else\n@@ -4446,9 +4431,8 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n   c_parser_consume_token (parser);\n   if (c_parser_next_token_is (parser, CPP_COLON))\n     {\n-      pedwarn (OPT_pedantic, \n-\t       \"%HISO C forbids omitting the middle term of a ?: expression\",\n-\t       &c_parser_peek_token (parser)->location);\n+      pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, \n+\t       \"ISO C forbids omitting the middle term of a ?: expression\");\n       /* Make sure first operand is calculated only once.  */\n       exp1.value = save_expr (default_conversion (cond.value));\n       cond.value = c_objc_common_truthvalue_conversion (exp1.value);\n@@ -5150,8 +5134,8 @@ c_parser_postfix_expression (c_parser *parser)\n \t  c_parser_compound_statement_nostart (parser);\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n-\t  pedwarn (OPT_pedantic, \n-\t\t   \"%HISO C forbids braced-groups within expressions\", &here);\n+\t  pedwarn (here, OPT_pedantic, \n+\t\t   \"ISO C forbids braced-groups within expressions\");\n \t  expr.value = c_finish_stmt_expr (stmt);\n \t  expr.original_code = ERROR_MARK;\n \t}\n@@ -5512,8 +5496,7 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n   maybe_warn_string_init (type, init);\n \n   if (!flag_isoc99)\n-    pedwarn (OPT_pedantic, \"%HISO C90 forbids compound literals\", \n-\t     &start_loc);\n+    pedwarn (start_loc, OPT_pedantic, \"ISO C90 forbids compound literals\");\n   expr.value = build_compound_literal (type, init.value);\n   expr.original_code = ERROR_MARK;\n   return c_parser_postfix_expression_after_primary (parser, expr);\n@@ -5814,9 +5797,8 @@ c_parser_objc_class_instance_variables (c_parser *parser)\n       /* Parse any stray semicolon.  */\n       if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n \t{\n-\t  pedwarn (OPT_pedantic, \n-\t\t   \"%Hextra semicolon in struct or union specified\",\n-\t\t   &c_parser_peek_token (parser)->location);\n+\t  pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, \n+\t\t   \"extra semicolon in struct or union specified\");\n \t  c_parser_consume_token (parser);\n \t  continue;\n \t}\n@@ -6032,9 +6014,8 @@ c_parser_objc_method_definition (c_parser *parser)\n   if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n     {\n       c_parser_consume_token (parser);\n-      pedwarn (OPT_pedantic, \n-\t       \"%Hextra semicolon in method definition specified\",\n-\t       &c_parser_peek_token (parser)->location);\n+      pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, \n+\t       \"extra semicolon in method definition specified\");\n     }\n   if (!c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n     {\n@@ -6070,9 +6051,8 @@ c_parser_objc_methodprotolist (c_parser *parser)\n       switch (c_parser_peek_token (parser)->type)\n \t{\n \tcase CPP_SEMICOLON:\n-\t  pedwarn (OPT_pedantic, \"%HISO C does not allow extra %<;%> \"\n-\t\t   \"outside of a function\",\n-\t\t   &c_parser_peek_token (parser)->location);\n+\t  pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, \n+\t\t   \"ISO C does not allow extra %<;%> outside of a function\");\n \t  c_parser_consume_token (parser);\n \t  break;\n \tcase CPP_PLUS:"}, {"sha": "1fe324544f33180c88f33a7a1816c3d6f3a68a00", "filename": "gcc/c-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -563,7 +563,7 @@ extern tree c_cast_expr (struct c_type_name *, tree);\n extern tree build_c_cast (tree, tree);\n extern void store_init_value (tree, tree);\n extern void error_init (const char *);\n-extern void pedwarn_init (int opt, const char *);\n+extern void pedwarn_init (location_t, int opt, const char *);\n extern void maybe_warn_string_init (tree, struct c_expr);\n extern void start_init (tree, tree, int);\n extern void finish_init (void);\n@@ -640,7 +640,7 @@ extern void c_write_global_declarations (void);\n #define ATTRIBUTE_GCC_CDIAG(m, n) ATTRIBUTE_NONNULL(m)\n #endif\n \n-extern void pedwarn_c90 (int opt, const char *, ...) ATTRIBUTE_GCC_CDIAG(2,3);\n-extern void pedwarn_c99 (int opt, const char *, ...) ATTRIBUTE_GCC_CDIAG(2,3);\n+extern void pedwarn_c90 (location_t, int opt, const char *, ...) ATTRIBUTE_GCC_CDIAG(3,4);\n+extern void pedwarn_c99 (location_t, int opt, const char *, ...) ATTRIBUTE_GCC_CDIAG(3,4);\n \n #endif /* ! GCC_C_TREE_H */"}, {"sha": "da5717a054887ca67ec9acb118ee1a67723bca1f", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 99, "deletions": 71, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -470,7 +470,7 @@ composite_type (tree t1, tree t2)\n \t\t      {\n \t\t\tTREE_VALUE (n) = composite_type (TREE_TYPE (memb),\n \t\t\t\t\t\t\t TREE_VALUE (p2));\n-\t\t\tpedwarn (OPT_pedantic, \n+\t\t\tpedwarn (input_location, OPT_pedantic, \n \t\t\t\t \"function types not truly compatible in ISO C\");\n \t\t\tgoto parm_done;\n \t\t      }\n@@ -495,7 +495,7 @@ composite_type (tree t1, tree t2)\n \t\t      {\n \t\t\tTREE_VALUE (n) = composite_type (TREE_TYPE (memb),\n \t\t\t\t\t\t\t TREE_VALUE (p1));\n-\t\t\tpedwarn (OPT_pedantic, \n+\t\t\tpedwarn (input_location, OPT_pedantic, \n \t\t\t\t \"function types not truly compatible in ISO C\");\n \t\t\tgoto parm_done;\n \t\t      }\n@@ -1040,7 +1040,7 @@ comp_target_types (tree ttl, tree ttr)\n   val = comptypes (mvl, mvr);\n \n   if (val == 2)\n-    pedwarn (OPT_pedantic, \"types are not quite compatible\");\n+    pedwarn (input_location, OPT_pedantic, \"types are not quite compatible\");\n   return val;\n }\n \f\n@@ -1363,7 +1363,7 @@ function_types_compatible_p (const_tree f1, const_tree f2)\n   /* 'volatile' qualifiers on a function's return type used to mean\n      the function is noreturn.  */\n   if (TYPE_VOLATILE (ret1) != TYPE_VOLATILE (ret2))\n-    pedwarn (0, \"function return types not compatible due to %<volatile%>\");\n+    pedwarn (input_location, 0, \"function return types not compatible due to %<volatile%>\");\n   if (TYPE_VOLATILE (ret1))\n     ret1 = build_qualified_type (TYPE_MAIN_VARIANT (ret1),\n \t\t\t\t TYPE_QUALS (ret1) & ~TYPE_QUAL_VOLATILE);\n@@ -2115,10 +2115,10 @@ build_array_ref (tree array, tree index)\n \t  while (TREE_CODE (foo) == COMPONENT_REF)\n \t    foo = TREE_OPERAND (foo, 0);\n \t  if (TREE_CODE (foo) == VAR_DECL && C_DECL_REGISTER (foo))\n-\t    pedwarn (OPT_pedantic, \n+\t    pedwarn (input_location, OPT_pedantic, \n \t\t     \"ISO C forbids subscripting %<register%> array\");\n \t  else if (!flag_isoc99 && !lvalue_p (foo))\n-\t    pedwarn (OPT_pedantic, \n+\t    pedwarn (input_location, OPT_pedantic, \n \t\t     \"ISO C90 forbids subscripting non-lvalue array\");\n \t}\n \n@@ -2233,8 +2233,8 @@ build_external_ref (tree id, int fun, location_t loc)\n \t   && (TREE_CODE (ref) != VAR_DECL || TREE_STATIC (ref))\n \t   && ! TREE_PUBLIC (ref)\n \t   && DECL_CONTEXT (ref) != current_function_decl)\n-    pedwarn (0, \"%H%qD is static but used in inline function %qD \"\n-\t      \"which is not static\", &loc, ref, current_function_decl);\n+    pedwarn (loc, 0, \"%qD is static but used in inline function %qD \"\n+\t     \"which is not static\", ref, current_function_decl);\n \n   return ref;\n }\n@@ -2457,7 +2457,7 @@ build_function_call (tree function, tree params)\n       if (TREE_CONSTANT (result)\n \t  && (name == NULL_TREE\n \t      || strncmp (IDENTIFIER_POINTER (name), \"__builtin_\", 10) != 0))\n-\tpedwarn_init (0, \"initializer element is not constant\");\n+\tpedwarn_init (input_location, 0, \"initializer element is not constant\");\n     }\n   else\n     result = fold_build_call_array (TREE_TYPE (fntype),\n@@ -2802,10 +2802,10 @@ pointer_diff (tree op0, tree op1)\n   tree orig_op1 = op1;\n \n   if (TREE_CODE (target_type) == VOID_TYPE)\n-    pedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+    pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t     \"pointer of type %<void *%> used in subtraction\");\n   if (TREE_CODE (target_type) == FUNCTION_TYPE)\n-    pedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+    pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t     \"pointer to a function used in subtraction\");\n \n   /* If the conversion to ptrdiff_type does anything like widening or\n@@ -2948,7 +2948,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n       else if (typecode == COMPLEX_TYPE)\n \t{\n \t  code = CONJ_EXPR;\n-\t  pedwarn (OPT_pedantic, \n+\t  pedwarn (input_location, OPT_pedantic, \n \t\t   \"ISO C does not support %<~%> for complex conjugation\");\n \t  if (!noconvert)\n \t    arg = default_conversion (arg);\n@@ -3020,8 +3020,8 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t{\n \t  tree real, imag;\n \n-\t  pedwarn (OPT_pedantic, \"ISO C does not support %<++%> and %<--%>\"\n-\t\t   \" on complex types\");\n+\t  pedwarn (input_location, OPT_pedantic, \n+\t\t   \"ISO C does not support %<++%> and %<--%> on complex types\");\n \n \t  arg = stabilize_reference (arg);\n \t  real = build_unary_op (REALPART_EXPR, arg, 1);\n@@ -3070,10 +3070,10 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t\t     || TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE)\n \t      {\n \t\tif (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n-\t\t  pedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t\t  pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t\t\t   \"wrong type argument to increment\");\n \t\telse\n-\t\t  pedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t\t  pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t\t\t   \"wrong type argument to decrement\");\n \t      }\n \n@@ -3349,7 +3349,7 @@ c_mark_addressable (tree exp)\n \t\t  (\"global register variable %qD used in nested function\", x);\n \t\treturn false;\n \t      }\n-\t    pedwarn (0, \"register variable %qD used in nested function\", x);\n+\t    pedwarn (input_location, 0, \"register variable %qD used in nested function\", x);\n \t  }\n \telse if (C_DECL_REGISTER (x))\n \t  {\n@@ -3457,7 +3457,7 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n   else if (code1 == VOID_TYPE || code2 == VOID_TYPE)\n     {\n       if (code1 != VOID_TYPE || code2 != VOID_TYPE)\n-\tpedwarn (OPT_pedantic, \n+\tpedwarn (input_location, OPT_pedantic, \n \t\t \"ISO C forbids conditional expr with only one void side\");\n       result_type = void_type_node;\n     }\n@@ -3472,29 +3472,33 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n       else if (VOID_TYPE_P (TREE_TYPE (type1)))\n \t{\n \t  if (TREE_CODE (TREE_TYPE (type2)) == FUNCTION_TYPE)\n-\t    pedwarn (OPT_pedantic, \"ISO C forbids conditional expr between \"\n+\t    pedwarn (input_location, OPT_pedantic, \n+\t\t     \"ISO C forbids conditional expr between \"\n \t\t     \"%<void *%> and function pointer\");\n \t  result_type = build_pointer_type (qualify_type (TREE_TYPE (type1),\n \t\t\t\t\t\t\t  TREE_TYPE (type2)));\n \t}\n       else if (VOID_TYPE_P (TREE_TYPE (type2)))\n \t{\n \t  if (TREE_CODE (TREE_TYPE (type1)) == FUNCTION_TYPE)\n-\t    pedwarn (OPT_pedantic, \"ISO C forbids conditional expr between \"\n+\t    pedwarn (input_location, OPT_pedantic, \n+\t\t     \"ISO C forbids conditional expr between \"\n \t\t     \"%<void *%> and function pointer\");\n \t  result_type = build_pointer_type (qualify_type (TREE_TYPE (type2),\n \t\t\t\t\t\t\t  TREE_TYPE (type1)));\n \t}\n       else\n \t{\n-\t  pedwarn (0, \"pointer type mismatch in conditional expression\");\n+\t  pedwarn (input_location, 0, \n+\t\t   \"pointer type mismatch in conditional expression\");\n \t  result_type = build_pointer_type (void_type_node);\n \t}\n     }\n   else if (code1 == POINTER_TYPE && code2 == INTEGER_TYPE)\n     {\n       if (!null_pointer_constant_p (orig_op2))\n-\tpedwarn (0, \"pointer/integer type mismatch in conditional expression\");\n+\tpedwarn (input_location, 0, \n+\t\t \"pointer/integer type mismatch in conditional expression\");\n       else\n \t{\n \t  op2 = null_pointer_node;\n@@ -3504,7 +3508,8 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n   else if (code2 == POINTER_TYPE && code1 == INTEGER_TYPE)\n     {\n       if (!null_pointer_constant_p (orig_op1))\n-\tpedwarn (0, \"pointer/integer type mismatch in conditional expression\");\n+\tpedwarn (input_location, 0, \n+\t\t \"pointer/integer type mismatch in conditional expression\");\n       else\n \t{\n \t  op1 = null_pointer_node;\n@@ -3617,7 +3622,7 @@ build_c_cast (tree type, tree expr)\n     {\n       if (TREE_CODE (type) == RECORD_TYPE\n \t  || TREE_CODE (type) == UNION_TYPE)\n-\tpedwarn (OPT_pedantic, \n+\tpedwarn (input_location, OPT_pedantic, \n \t\t \"ISO C forbids casting nonscalar to the same type\");\n     }\n   else if (TREE_CODE (type) == UNION_TYPE)\n@@ -3634,7 +3639,8 @@ build_c_cast (tree type, tree expr)\n \t{\n \t  tree t;\n \n-\t  pedwarn (OPT_pedantic, \"ISO C forbids casts to union type\");\n+\t  pedwarn (input_location, OPT_pedantic,\n+\t\t   \"ISO C forbids casts to union type\");\n \t  t = digest_init (type,\n \t\t\t   build_constructor_single (type, field, value),\n \t\t\t   true, 0);\n@@ -3745,7 +3751,7 @@ build_c_cast (tree type, tree expr)\n \t  && TREE_CODE (otype) == POINTER_TYPE\n \t  && TREE_CODE (TREE_TYPE (otype)) == FUNCTION_TYPE\n \t  && TREE_CODE (TREE_TYPE (type)) != FUNCTION_TYPE)\n-\tpedwarn (OPT_pedantic, \"ISO C forbids \"\n+\tpedwarn (input_location, OPT_pedantic, \"ISO C forbids \"\n \t\t \"conversion of function pointer to object pointer type\");\n \n       if (pedantic\n@@ -3754,7 +3760,7 @@ build_c_cast (tree type, tree expr)\n \t  && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n \t  && TREE_CODE (TREE_TYPE (otype)) != FUNCTION_TYPE\n \t  && !null_pointer_constant_p (value))\n-\tpedwarn (OPT_pedantic, \"ISO C forbids \"\n+\tpedwarn (input_location, OPT_pedantic, \"ISO C forbids \"\n \t\t \"conversion of object pointer to function pointer type\");\n \n       ovalue = value;\n@@ -3946,24 +3952,24 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n   /* This macro is used to emit diagnostics to ensure that all format\n      strings are complete sentences, visible to gettext and checked at\n      compile time.  */\n-#define WARN_FOR_ASSIGNMENT(AR, AS, IN, RE)\t\\\n+#define WARN_FOR_ASSIGNMENT(LOCATION, AR, AS, IN, RE)\t\\\n   do {\t\t\t\t\t\t\\\n     switch (errtype)\t\t\t\t\\\n       {\t\t\t\t\t\t\\\n       case ic_argpass:\t\t\t\t\\\n-\tpedwarn (0, AR, parmnum, rname);\t\\\n+\tpedwarn (LOCATION, 0, AR, parmnum, rname);\t\\\n \tbreak;\t\t\t\t\t\\\n       case ic_argpass_nonproto:\t\t\t\\\n \twarning (0, AR, parmnum, rname);\t\\\n \tbreak;\t\t\t\t\t\\\n       case ic_assign:\t\t\t\t\\\n-\tpedwarn (0, AS);\t\t\t\\\n+\tpedwarn (LOCATION, 0, AS);\t\t\t\\\n \tbreak;\t\t\t\t\t\\\n       case ic_init:\t\t\t\t\\\n-\tpedwarn (0, IN);\t\t\t\\\n+\tpedwarn (LOCATION, 0, IN);\t\t\t\\\n \tbreak;\t\t\t\t\t\\\n       case ic_return:\t\t\t\t\\\n-\tpedwarn (0, RE);\t\t\t\\\n+\tpedwarn (LOCATION, 0, RE);\t\t\t\\\n \tbreak;\t\t\t\t\t\\\n       default:\t\t\t\t\t\\\n \tgcc_unreachable ();\t\t\t\\\n@@ -4145,7 +4151,8 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t\t     function where an ordinary one is wanted, but not\n \t\t     vice-versa.  */\n \t\t  if (TYPE_QUALS (ttl) & ~TYPE_QUALS (ttr))\n-\t\t    WARN_FOR_ASSIGNMENT (G_(\"passing argument %d of %qE \"\n+\t\t    WARN_FOR_ASSIGNMENT (input_location,\n+\t\t\t\t\t G_(\"passing argument %d of %qE \"\n \t\t\t\t\t    \"makes qualified function \"\n \t\t\t\t\t    \"pointer from unqualified\"),\n \t\t\t\t\t G_(\"assignment makes qualified \"\n@@ -4158,7 +4165,8 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t\t\t\t\t    \"pointer from unqualified\"));\n \t\t}\n \t      else if (TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl))\n-\t\tWARN_FOR_ASSIGNMENT (G_(\"passing argument %d of %qE discards \"\n+\t\tWARN_FOR_ASSIGNMENT (input_location,\n+\t\t\t\t     G_(\"passing argument %d of %qE discards \"\n \t\t\t\t\t\"qualifiers from pointer target type\"),\n \t\t\t\t     G_(\"assignment discards qualifiers \"\n \t\t\t\t\t\"from pointer target type\"),\n@@ -4171,7 +4179,7 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t    }\n \n \t  if (!fundecl || !DECL_IN_SYSTEM_HEADER (fundecl))\n-\t    pedwarn (OPT_pedantic, \n+\t    pedwarn (input_location, OPT_pedantic, \n \t\t     \"ISO C prohibits argument conversion to union type\");\n \n \t  rhs = fold_convert (TREE_TYPE (memb), rhs);\n@@ -4257,7 +4265,8 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t\t  (VOID_TYPE_P (ttr)\n \t\t   && !null_pointer_constant_p (rhs)\n \t\t   && TREE_CODE (ttl) == FUNCTION_TYPE)))\n-\t    WARN_FOR_ASSIGNMENT (G_(\"ISO C forbids passing argument %d of \"\n+\t    WARN_FOR_ASSIGNMENT (input_location,\n+\t\t\t\t G_(\"ISO C forbids passing argument %d of \"\n \t\t\t\t    \"%qE between function pointer \"\n \t\t\t\t    \"and %<void *%>\"),\n \t\t\t\t G_(\"ISO C forbids assignment between \"\n@@ -4277,7 +4286,8 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t\t     qualifier are acceptable if the 'volatile' has been added\n \t\t     in by the Objective-C EH machinery.  */\n \t\t  if (!objc_type_quals_match (ttl, ttr))\n-\t\t    WARN_FOR_ASSIGNMENT (G_(\"passing argument %d of %qE discards \"\n+\t\t    WARN_FOR_ASSIGNMENT (input_location,\n+\t\t\t\t\t G_(\"passing argument %d of %qE discards \"\n \t\t\t\t\t    \"qualifiers from pointer target type\"),\n \t\t\t\t\t G_(\"assignment discards qualifiers \"\n \t\t\t\t\t    \"from pointer target type\"),\n@@ -4293,7 +4303,8 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t\t;\n \t      /* If there is a mismatch, do warn.  */\n \t      else if (warn_pointer_sign)\n-\t\tWARN_FOR_ASSIGNMENT (G_(\"pointer targets in passing argument \"\n+\t\tWARN_FOR_ASSIGNMENT (input_location,\n+\t\t\t\t     G_(\"pointer targets in passing argument \"\n \t\t\t\t\t\"%d of %qE differ in signedness\"),\n \t\t\t\t     G_(\"pointer targets in assignment \"\n \t\t\t\t\t\"differ in signedness\"),\n@@ -4310,7 +4321,8 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t\t it is okay to use a const or volatile function\n \t\t where an ordinary one is wanted, but not vice-versa.  */\n \t      if (TYPE_QUALS (ttl) & ~TYPE_QUALS (ttr))\n-\t\tWARN_FOR_ASSIGNMENT (G_(\"passing argument %d of %qE makes \"\n+\t\tWARN_FOR_ASSIGNMENT (input_location,\n+\t\t\t\t     G_(\"passing argument %d of %qE makes \"\n \t\t\t\t\t\"qualified function pointer \"\n \t\t\t\t\t\"from unqualified\"),\n \t\t\t\t     G_(\"assignment makes qualified function \"\n@@ -4324,7 +4336,8 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n       else\n \t/* Avoid warning about the volatile ObjC EH puts on decls.  */\n \tif (!objc_ok)\n-\t  WARN_FOR_ASSIGNMENT (G_(\"passing argument %d of %qE from \"\n+\t  WARN_FOR_ASSIGNMENT (input_location,\n+\t\t\t       G_(\"passing argument %d of %qE from \"\n \t\t\t\t  \"incompatible pointer type\"),\n \t\t\t       G_(\"assignment from incompatible pointer type\"),\n \t\t\t       G_(\"initialization from incompatible \"\n@@ -4346,7 +4359,8 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t or one that results from arithmetic, even including\n \t a cast to integer type.  */\n       if (!null_pointer_constant_p (rhs))\n-\tWARN_FOR_ASSIGNMENT (G_(\"passing argument %d of %qE makes \"\n+\tWARN_FOR_ASSIGNMENT (input_location,\n+\t\t\t     G_(\"passing argument %d of %qE makes \"\n \t\t\t\t\"pointer from integer without a cast\"),\n \t\t\t     G_(\"assignment makes pointer from integer \"\n \t\t\t\t\"without a cast\"),\n@@ -4359,7 +4373,8 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n     }\n   else if (codel == INTEGER_TYPE && coder == POINTER_TYPE)\n     {\n-      WARN_FOR_ASSIGNMENT (G_(\"passing argument %d of %qE makes integer \"\n+      WARN_FOR_ASSIGNMENT (input_location,\n+\t\t\t   G_(\"passing argument %d of %qE makes integer \"\n \t\t\t      \"from pointer without a cast\"),\n \t\t\t   G_(\"assignment makes integer from pointer \"\n \t\t\t      \"without a cast\"),\n@@ -4623,14 +4638,14 @@ error_init (const char *msgid)\n    component name is taken from the spelling stack.  */\n \n void\n-pedwarn_init (int opt, const char *msgid)\n+pedwarn_init (location_t location, int opt, const char *msgid)\n {\n   char *ofwhat;\n \n-  pedwarn (opt, \"%s\", _(msgid));\n+  pedwarn (location, opt, \"%s\", _(msgid));\n   ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n   if (*ofwhat)\n-    pedwarn (opt, \"(near initialization for %qs)\", ofwhat);\n+    pedwarn (location, opt, \"(near initialization for %qs)\", ofwhat);\n }\n \n /* Issue a warning for a bad initializer component.  \n@@ -4661,7 +4676,7 @@ maybe_warn_string_init (tree type, struct c_expr expr)\n       && TREE_CODE (type) == ARRAY_TYPE\n       && TREE_CODE (expr.value) == STRING_CST\n       && expr.original_code != STRING_CST)\n-    pedwarn_init (OPT_pedantic, \n+    pedwarn_init (input_location, OPT_pedantic, \n \t\t  \"array initialized from parenthesized string constant\");\n }\n \n@@ -4755,7 +4770,8 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n \t\t\t\t       TREE_STRING_LENGTH (inside_init)\n \t\t\t\t       - (TYPE_PRECISION (typ1)\n \t\t\t\t\t  / BITS_PER_UNIT)))\n-\t    pedwarn_init (0, \"initializer-string for array of chars is too long\");\n+\t    pedwarn_init (input_location, 0, \n+\t\t\t  \"initializer-string for array of chars is too long\");\n \n \t  return inside_init;\n \t}\n@@ -4873,7 +4889,8 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n \t  if (inside_init == error_mark_node)\n \t    error_init (\"initializer element is not constant\");\n \t  else\n-\t    pedwarn_init (OPT_pedantic, \"initializer element is not constant\");\n+\t    pedwarn_init (input_location, OPT_pedantic,\n+\t\t\t  \"initializer element is not constant\");\n \t  if (flag_pedantic_errors)\n \t    inside_init = error_mark_node;\n \t}\n@@ -5547,7 +5564,8 @@ pop_init_level (int implicit)\n \t  if (constructor_depth > 2)\n \t    error_init (\"initialization of flexible array member in a nested context\");\n \t  else\n-\t    pedwarn_init (OPT_pedantic, \"initialization of a flexible array member\");\n+\t    pedwarn_init (input_location, OPT_pedantic,\n+\t\t\t  \"initialization of a flexible array member\");\n \n \t  /* We have already issued an error message for the existence\n \t     of a flexible array member not at the end of the structure.\n@@ -6284,7 +6302,8 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n \t  value = error_mark_node;\n \t}\n       else if (require_constant_elements)\n-\tpedwarn (0, \"initializer element is not computable at load time\");\n+\tpedwarn (input_location, 0,\n+\t\t \"initializer element is not computable at load time\");\n     }\n \n   /* If this field is empty (and not at the end of structure),\n@@ -6611,7 +6630,8 @@ process_init_element (struct c_expr value)\n \n \t  if (constructor_fields == 0)\n \t    {\n-\t      pedwarn_init (0, \"excess elements in struct initializer\");\n+\t      pedwarn_init (input_location, 0,\n+\t\t\t    \"excess elements in struct initializer\");\n \t      break;\n \t    }\n \n@@ -6694,7 +6714,8 @@ process_init_element (struct c_expr value)\n \n \t  if (constructor_fields == 0)\n \t    {\n-\t      pedwarn_init (0, \"excess elements in union initializer\");\n+\t      pedwarn_init (input_location, 0,\n+\t\t\t    \"excess elements in union initializer\");\n \t      break;\n \t    }\n \n@@ -6781,7 +6802,8 @@ process_init_element (struct c_expr value)\n \t      && (tree_int_cst_lt (constructor_max_index, constructor_index)\n \t\t  || integer_all_onesp (constructor_max_index)))\n \t    {\n-\t      pedwarn_init (0, \"excess elements in array initializer\");\n+\t      pedwarn_init (input_location, 0,\n+\t\t\t    \"excess elements in array initializer\");\n \t      break;\n \t    }\n \n@@ -6811,7 +6833,8 @@ process_init_element (struct c_expr value)\n \t    always have a fixed size derived from their type.  */\n \t  if (tree_int_cst_lt (constructor_max_index, constructor_index))\n \t    {\n-\t      pedwarn_init (0, \"excess elements in vector initializer\");\n+\t      pedwarn_init (input_location, 0,\n+\t\t\t    \"excess elements in vector initializer\");\n \t      break;\n \t    }\n \n@@ -6835,7 +6858,8 @@ process_init_element (struct c_expr value)\n       else if (constructor_type != error_mark_node\n \t       && constructor_fields == 0)\n \t{\n-\t  pedwarn_init (0, \"excess elements in scalar initializer\");\n+\t  pedwarn_init (input_location, 0,\n+\t\t\t\"excess elements in scalar initializer\");\n \t  break;\n \t}\n       else\n@@ -7066,7 +7090,7 @@ c_finish_goto_label (tree label)\n tree\n c_finish_goto_ptr (tree expr)\n {\n-  pedwarn (OPT_pedantic, \"ISO C forbids %<goto *expr;%>\");\n+  pedwarn (input_location, OPT_pedantic, \"ISO C forbids %<goto *expr;%>\");\n   expr = convert (ptr_type_node, expr);\n   return add_stmt (build1 (GOTO_EXPR, void_type_node, expr));\n }\n@@ -7089,7 +7113,7 @@ c_finish_return (tree retval)\n       if ((warn_return_type || flag_isoc99)\n \t  && valtype != 0 && TREE_CODE (valtype) != VOID_TYPE)\n \t{\n-\t  pedwarn_c99 (flag_isoc99 ? 0 : OPT_Wreturn_type, \n+\t  pedwarn_c99 (input_location, flag_isoc99 ? 0 : OPT_Wreturn_type, \n \t\t       \"%<return%> with no value, in \"\n \t\t       \"function returning non-void\");\n \t  no_warning = true;\n@@ -7099,9 +7123,10 @@ c_finish_return (tree retval)\n     {\n       current_function_returns_null = 1;\n       if (TREE_CODE (TREE_TYPE (retval)) != VOID_TYPE)\n-\tpedwarn (0, \"%<return%> with a value, in function returning void\");\n+\tpedwarn (input_location, 0, \n+\t\t \"%<return%> with a value, in function returning void\");\n       else \n-\tpedwarn (OPT_pedantic, \"ISO C forbids \"\n+\tpedwarn (input_location, OPT_pedantic, \"ISO C forbids \"\n \t\t \"%<return%> with expression, in function returning void\");\n     }\n   else\n@@ -8178,20 +8203,21 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t whose value is 0 but which isn't a valid null ptr const.  */\n \t      if (pedantic && !null_pointer_constant_p (orig_op0)\n \t\t  && TREE_CODE (tt1) == FUNCTION_TYPE)\n-\t\tpedwarn (OPT_pedantic, \"ISO C forbids \"\n+\t\tpedwarn (input_location, OPT_pedantic, \"ISO C forbids \"\n \t\t\t \"comparison of %<void *%> with function pointer\");\n \t    }\n \t  else if (VOID_TYPE_P (tt1))\n \t    {\n \t      if (pedantic && !null_pointer_constant_p (orig_op1)\n \t\t  && TREE_CODE (tt0) == FUNCTION_TYPE)\n-\t\tpedwarn (OPT_pedantic, \"ISO C forbids \"\n+\t\tpedwarn (input_location, OPT_pedantic, \"ISO C forbids \"\n \t\t\t \"comparison of %<void *%> with function pointer\");\n \t    }\n \t  else\n \t    /* Avoid warning about the volatile ObjC EH puts on decls.  */\n \t    if (!objc_ok)\n-\t      pedwarn (0, \"comparison of distinct pointer types lacks a cast\");\n+\t      pedwarn (input_location, 0,\n+\t\t       \"comparison of distinct pointer types lacks a cast\");\n \n \t  if (result_type == NULL_TREE)\n \t    result_type = ptr_type_node;\n@@ -8215,12 +8241,12 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n \t  result_type = type0;\n-\t  pedwarn (0, \"comparison between pointer and integer\");\n+\t  pedwarn (input_location, 0, \"comparison between pointer and integer\");\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  result_type = type1;\n-\t  pedwarn (0, \"comparison between pointer and integer\");\n+\t  pedwarn (input_location, 0, \"comparison between pointer and integer\");\n \t}\n       break;\n \n@@ -8241,22 +8267,24 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t      result_type = common_pointer_type (type0, type1);\n \t      if (!COMPLETE_TYPE_P (TREE_TYPE (type0))\n \t\t  != !COMPLETE_TYPE_P (TREE_TYPE (type1)))\n-\t\tpedwarn (0, \"comparison of complete and incomplete pointers\");\n+\t\tpedwarn (input_location, 0,\n+\t\t\t \"comparison of complete and incomplete pointers\");\n \t      else if (TREE_CODE (TREE_TYPE (type0)) == FUNCTION_TYPE)\n-\t\tpedwarn (OPT_pedantic, \"ISO C forbids \"\n+\t\tpedwarn (input_location, OPT_pedantic, \"ISO C forbids \"\n \t\t\t \"ordered comparisons of pointers to functions\");\n \t    }\n \t  else\n \t    {\n \t      result_type = ptr_type_node;\n-\t      pedwarn (0, \"comparison of distinct pointer types lacks a cast\");\n+\t      pedwarn (input_location, 0,\n+\t\t       \"comparison of distinct pointer types lacks a cast\");\n \t    }\n \t}\n       else if (code0 == POINTER_TYPE && null_pointer_constant_p (orig_op1))\n \t{\n \t  result_type = type0;\n \t  if (pedantic)\n-\t    pedwarn (OPT_pedantic, \n+\t    pedwarn (input_location, OPT_pedantic, \n \t\t     \"ordered comparison of pointer with integer zero\");\n \t  else if (extra_warnings)\n \t    warning (OPT_Wextra,\n@@ -8265,18 +8293,18 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       else if (code1 == POINTER_TYPE && null_pointer_constant_p (orig_op0))\n \t{\n \t  result_type = type1;\n-\t  pedwarn (OPT_pedantic, \n+\t  pedwarn (input_location, OPT_pedantic, \n \t\t   \"ordered comparison of pointer with integer zero\");\n \t}\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n \t  result_type = type0;\n-\t  pedwarn (0, \"comparison between pointer and integer\");\n+\t  pedwarn (input_location, 0, \"comparison between pointer and integer\");\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  result_type = type1;\n-\t  pedwarn (0, \"comparison between pointer and integer\");\n+\t  pedwarn (input_location, 0, \"comparison between pointer and integer\");\n \t}\n       break;\n "}, {"sha": "91251947cd9a718b7c85cc290771edaeca605fa5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -1,3 +1,13 @@\n+2008-08-21  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\t* typeck.c: Update all calls to pedwarn.\n+\t* decl.c: Likewise.\n+\t* call.c: Likewise.\n+\t* error.c: Likewise.\n+\t* pt.c: Likewise.\n+\t* name-lookup.c: Likewise.\n+\t* parser.c: Likewise.\n+\n 2008-08-20  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR c++/35158"}, {"sha": "90fa20acfc848cb82c27be6d3f6275c74e823791", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -3404,7 +3404,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3,\n   if (!arg2)\n     {\n       if (complain & tf_error)\n-\tpedwarn (OPT_pedantic, \n+\tpedwarn (input_location, OPT_pedantic, \n \t\t \"ISO C++ forbids omitting the middle term of a ?: expression\");\n \n       /* Make sure that lvalues remain lvalues.  See g++.oliva/ext1.C.  */\n@@ -6766,7 +6766,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \t{\n \t  if (warn)\n \t    {\n-\t      pedwarn (0,\n+\t      pedwarn (input_location, 0,\n \t      \"ISO C++ says that these are ambiguous, even \"\n \t      \"though the worst conversion for the first is better than \"\n \t      \"the worst conversion for the second:\");"}, {"sha": "ec4fa7642491285dfe243618846d6c10ed6bf89e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -3810,7 +3810,7 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n       SET_ANON_AGGR_TYPE_P (declared_type);\n \n       if (TREE_CODE (declared_type) != UNION_TYPE && !in_system_header)\n-\tpedwarn (OPT_pedantic, \"ISO C++ prohibits anonymous structs\");\n+\tpedwarn (input_location, OPT_pedantic, \"ISO C++ prohibits anonymous structs\");\n     }\n \n   else\n@@ -7033,7 +7033,7 @@ check_static_variable_definition (tree decl, tree type)\n \t   \"static member %qD\",\n \t   decl);\n   else if (!INTEGRAL_TYPE_P (type))\n-    pedwarn (OPT_pedantic, \"ISO C++ forbids initialization of member constant \"\n+    pedwarn (input_location, OPT_pedantic, \"ISO C++ forbids initialization of member constant \"\n \t     \"%qD of non-integral type %qT\", decl, type);\n \n   return 0;\n@@ -7113,9 +7113,9 @@ compute_array_index_type (tree name, tree size)\n       else if (integer_zerop (size) && !in_system_header)\n \t{\n \t  if (name)\n-\t    pedwarn (OPT_pedantic, \"ISO C++ forbids zero-size array %qD\", name);\n+\t    pedwarn (input_location, OPT_pedantic, \"ISO C++ forbids zero-size array %qD\", name);\n \t  else\n-\t    pedwarn (OPT_pedantic, \"ISO C++ forbids zero-size array\");\n+\t    pedwarn (input_location, OPT_pedantic, \"ISO C++ forbids zero-size array\");\n \t}\n     }\n   else if (TREE_CONSTANT (size))\n@@ -7131,9 +7131,9 @@ compute_array_index_type (tree name, tree size)\n   else if (pedantic && warn_vla != 0)\n     {\n       if (name)\n-\tpedwarn (OPT_Wvla, \"ISO C++ forbids variable length array %qD\", name);\n+\tpedwarn (input_location, OPT_Wvla, \"ISO C++ forbids variable length array %qD\", name);\n       else\n-\tpedwarn (OPT_Wvla, \"ISO C++ forbids variable length array\");\n+\tpedwarn (input_location, OPT_Wvla, \"ISO C++ forbids variable length array\");\n     }\n   else if (warn_vla > 0)\n     {\n@@ -7767,7 +7767,7 @@ grokdeclarator (const cp_declarator *declarator,\n       else if (! is_main)\n \tpermerror (input_location, \"ISO C++ forbids declaration of %qs with no type\", name);\n       else if (pedantic)\n-\tpedwarn (OPT_pedantic,\n+\tpedwarn (input_location, OPT_pedantic,\n \t\t \"ISO C++ forbids declaration of %qs with no type\", name);\n       else\n \twarning (OPT_Wreturn_type,\n@@ -7823,7 +7823,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  ok = 1;\n \t  if (!explicit_int && !defaulted_int && !explicit_char && pedantic)\n \t    {\n-\t      pedwarn (OPT_pedantic, \n+\t      pedwarn (input_location, OPT_pedantic, \n \t\t       \"long, short, signed or unsigned used invalidly for %qs\",\n \t\t       name);\n \t      if (flag_pedantic_errors)\n@@ -7929,7 +7929,7 @@ grokdeclarator (const cp_declarator *declarator,\n       if (pedantic)\n \t{\n \t  tree bad_type = build_qualified_type (type, type_quals);\n-\t  pedwarn (OPT_pedantic, \n+\t  pedwarn (input_location, OPT_pedantic, \n \t\t   \"ignoring %qV qualifiers added to function type %qT\",\n \t\t   bad_type, type);\n \t}\n@@ -9159,11 +9159,11 @@ grokdeclarator (const cp_declarator *declarator,\n \t    && pedantic)\n \t  {\n \t    if (storage_class == sc_static)\n-\t      pedwarn (OPT_pedantic, \n+\t      pedwarn (input_location, OPT_pedantic, \n \t\t       \"%<static%> specified invalid for function %qs \"\n \t\t       \"declared out of global scope\", name);\n \t    else\n-\t      pedwarn (OPT_pedantic, \n+\t      pedwarn (input_location, OPT_pedantic, \n \t\t       \"%<inline%> specifier invalid for function %qs \"\n \t\t       \"declared out of global scope\", name);\n \t  }\n@@ -9252,7 +9252,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t      }\n \t    if (storage_class == sc_extern && pedantic)\n \t      {\n-\t\tpedwarn (OPT_pedantic, \n+\t\tpedwarn (input_location, OPT_pedantic, \n \t\t\t \"cannot explicitly declare member %q#D to have \"\n \t\t\t \"extern linkage\", decl);\n \t\tstorage_class = sc_none;\n@@ -10148,7 +10148,7 @@ grok_op_properties (tree decl, bool complain)\n \t    if (operator_code == POSTINCREMENT_EXPR\n \t\t|| operator_code == POSTDECREMENT_EXPR)\n \t      {\n-\t\tpedwarn (OPT_pedantic, \"%qD cannot have default arguments\", \n+\t\tpedwarn (input_location, OPT_pedantic, \"%qD cannot have default arguments\", \n \t\t\t decl);\n \t      }\n \t    else"}, {"sha": "395ede207f91d3f9c4e87d76ca8cceefc2db9309", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -2687,7 +2687,7 @@ maybe_warn_cpp0x (const char* str)\n     /* We really want to suppress this warning in system headers,\n        because libstdc++ uses variadic templates even when we aren't\n        in C++0x mode. */\n-    pedwarn (0, \"%s only available with -std=c++0x or -std=gnu++0x\", str);\n+    pedwarn (input_location, 0, \"%s only available with -std=c++0x or -std=gnu++0x\", str);\n }\n \n /* Warn about the use of variadic templates when appropriate.  */"}, {"sha": "c9a7e60d3bdb3039ab362d8196f112a45057f68b", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -725,7 +725,7 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \t  else if (t == wchar_decl_node)\n \t    {\n \t      if (! DECL_IN_SYSTEM_HEADER (x))\n-\t\tpedwarn (OPT_pedantic, \"redeclaration of %<wchar_t%> as %qT\",\n+\t\tpedwarn (input_location, OPT_pedantic, \"redeclaration of %<wchar_t%> as %qT\",\n \t\t\t TREE_TYPE (x));\n \t      \n \t      /* Throw away the redeclaration.  */\n@@ -796,11 +796,11 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \t\t\t\t\t  x_exception_spec,\n \t\t\t\t\t  true))\n \t\t    {\n-\t\t      pedwarn (0, \"declaration of %q#D with C language linkage\",\n+\t\t      pedwarn (input_location, 0, \"declaration of %q#D with C language linkage\",\n \t\t\t       x);\n-\t\t      pedwarn (0, \"conflicts with previous declaration %q+#D\",\n+\t\t      pedwarn (input_location, 0, \"conflicts with previous declaration %q+#D\",\n \t\t\t       previous);\n-\t\t      pedwarn (0, \"due to different exception specifications\");\n+\t\t      pedwarn (input_location, 0, \"due to different exception specifications\");\n \t\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \t\t    }\n \t\t}"}, {"sha": "357d1cba62604c1495b36efa8f39f2503f6ad508", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -2162,9 +2162,8 @@ cp_parser_check_decl_spec (cp_decl_specifier_seq *decl_specs,\n \t    error (\"%H%<long long long%> is too long for GCC\", &location);\n \t  else if (pedantic && !in_system_header && warn_long_long\n                    && cxx_dialect == cxx98)\n-\t    pedwarn (OPT_Wlong_long, \n-\t\t     \"%HISO C++ 1998 does not support %<long long%>\",\n-\t\t     &location);\n+\t    pedwarn (location, OPT_Wlong_long, \n+\t\t     \"ISO C++ 1998 does not support %<long long%>\");\n \t}\n       else if (count > 1)\n \t{\n@@ -3217,9 +3216,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n \t  {\n \t    /* Statement-expressions are not allowed by the standard.  */\n-\t    pedwarn (OPT_pedantic, \n-\t\t     \"%HISO C++ forbids braced-groups within expressions\",\n-\t\t     &token->location);\n+\t    pedwarn (token->location, OPT_pedantic, \n+\t\t     \"ISO C++ forbids braced-groups within expressions\");\n \n \t    /* And they're not allowed outside of a function-body; you\n \t       cannot, for example, write:\n@@ -4548,7 +4546,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t      {\n \t\t/* Warn the user that a compound literal is not\n \t\t   allowed in standard C++.  */\n-\t\tpedwarn (OPT_pedantic, \"ISO C++ forbids compound-literals\");\n+\t\tpedwarn (input_location, OPT_pedantic, \"ISO C++ forbids compound-literals\");\n \t\t/* For simplicity, we disallow compound literals in\n \t\t   constant-expressions.  We could\n \t\t   allow compound literals of integer type, whose\n@@ -7612,7 +7610,7 @@ cp_parser_jump_statement (cp_parser* parser)\n       if (cp_lexer_next_token_is (parser->lexer, CPP_MULT))\n \t{\n \t  /* Issue a warning about this use of a GNU extension.  */\n-\t  pedwarn (OPT_pedantic, \"%HISO C++ forbids computed gotos\", &token->location);\n+\t  pedwarn (token->location, OPT_pedantic, \"ISO C++ forbids computed gotos\");\n \t  /* Consume the '*' token.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  /* Parse the dependent expression.  */\n@@ -7752,7 +7750,7 @@ cp_parser_declaration_seq_opt (cp_parser* parser)\n \t     invalid.  Allow it unless we're being pedantic.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  if (!in_system_header)\n-\t    pedwarn (OPT_pedantic, \"extra %<;%>\");\n+\t    pedwarn (input_location, OPT_pedantic, \"extra %<;%>\");\n \t  continue;\n \t}\n \n@@ -11740,7 +11738,7 @@ cp_parser_enumerator_list (cp_parser* parser, tree type)\n       if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))\n \t{\n \t  if (!in_system_header)\n-\t    pedwarn (OPT_pedantic, \"comma at end of enumerator list\");\n+\t    pedwarn (input_location, OPT_pedantic, \"comma at end of enumerator list\");\n \t  break;\n \t}\n     }\n@@ -14384,7 +14382,7 @@ cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p)\n \t  && cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_COLON)\n \t{\n \t  /* Warn the user that they are using an extension.  */\n-\t  pedwarn (OPT_pedantic, \n+\t  pedwarn (input_location, OPT_pedantic, \n \t\t   \"ISO C++ does not allow designated initializers\");\n \t  /* Consume the identifier.  */\n \t  identifier = cp_lexer_consume_token (parser->lexer)->u.value;\n@@ -15408,7 +15406,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t{\n \t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n \t  if (!in_system_header_at (token->location))\n-\t    pedwarn (OPT_pedantic, \"%Hextra %<;%>\", &token->location);\n+\t    pedwarn (token->location, OPT_pedantic, \"extra %<;%>\");\n \t}\n       else\n \t{"}, {"sha": "43cf2b9662b9374030d9b933472e0a7a36ac7b09", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -14613,7 +14613,7 @@ do_decl_instantiation (tree decl, tree storage)\n   else if (storage == ridpointers[(int) RID_EXTERN])\n     {\n       if (!in_system_header && (cxx_dialect == cxx98))\n-\tpedwarn (OPT_pedantic, \n+\tpedwarn (input_location, OPT_pedantic, \n \t\t \"ISO C++ 1998 forbids the use of %<extern%> on explicit \"\n \t\t \"instantiations\");\n       extern_p = 1;\n@@ -14705,13 +14705,14 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \t  if (storage == ridpointers[(int) RID_EXTERN])\n \t    {\n \t      if (cxx_dialect == cxx98)\n-\t\tpedwarn(OPT_pedantic, \n-\t\t\t\"ISO C++ 1998 forbids the use of %<extern%> on \"\n-\t\t\t\"explicit instantiations\");\n+\t\tpedwarn (input_location, OPT_pedantic, \n+\t\t\t \"ISO C++ 1998 forbids the use of %<extern%> on \"\n+\t\t\t \"explicit instantiations\");\n \t    }\n \t  else\n-\t    pedwarn(OPT_pedantic, \"ISO C++ forbids the use of %qE on explicit \"\n-\t\t    \"instantiations\", storage);\n+\t    pedwarn (input_location, OPT_pedantic, \n+\t\t     \"ISO C++ forbids the use of %qE\"\n+\t\t     \" on explicit instantiations\", storage);\n \t}\n \n       if (storage == ridpointers[(int) RID_INLINE])"}, {"sha": "df126e8335943ec4ad5b20e13041c3d31fe2d7ec", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -512,7 +512,7 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n       tree result_type;\n \n       if (TYPE_PTRFN_P (t2) && (complain & tf_error))\n-\tpedwarn (OPT_pedantic, \"ISO C++ forbids %s \"\n+\tpedwarn (input_location, OPT_pedantic, \"ISO C++ forbids %s \"\n \t\t \"between pointer of type %<void *%> and pointer-to-function\",\n \t\t location);\n       result_type\n@@ -1280,7 +1280,7 @@ cxx_sizeof_or_alignof_type (tree type, enum tree_code op, bool complain)\n   if (TREE_CODE (type) == METHOD_TYPE)\n     {\n       if (complain)\n-\tpedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\tpedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t\t \"invalid application of %qs to a member function\", \n \t\t operator_name_info[(int) op].name);\n       value = size_one_node;\n@@ -2587,7 +2587,7 @@ build_array_ref (tree array, tree idx)\n \t}\n \n       if (!lvalue_p (array))\n-\tpedwarn (OPT_pedantic, \"ISO C++ forbids subscripting non-lvalue array\");\n+\tpedwarn (input_location, OPT_pedantic, \"ISO C++ forbids subscripting non-lvalue array\");\n \n       /* Note in C++ it is valid to subscript a `register' array, since\n \t it is valid to take the address of something with that\n@@ -2813,7 +2813,7 @@ cp_build_function_call (tree function, tree params, tsubst_flags_t complain)\n \n       /* Convert anything with function type to a pointer-to-function.  */\n       if (DECL_MAIN_P (function) && (complain & tf_error))\n-\tpedwarn (OPT_pedantic, \n+\tpedwarn (input_location, OPT_pedantic, \n \t\t \"ISO C++ forbids calling %<::main%> from within program\");\n \n       function = build_addr_func (function);\n@@ -5260,7 +5260,7 @@ convert_member_func_to_ptr (tree type, tree expr)\n \t      || TREE_CODE (intype) == METHOD_TYPE);\n \n   if (pedantic || warn_pmf2ptr)\n-    pedwarn (pedantic ? OPT_pedantic : OPT_Wpmf_conversions,\n+    pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpmf_conversions,\n \t     \"converting from %qT to %qT\", intype, type);\n \n   if (TREE_CODE (intype) == METHOD_TYPE)\n@@ -7164,7 +7164,7 @@ cp_apply_type_quals_to_decl (int type_quals, tree decl)\n       if (pedantic)\n \t{\n \t  tree bad_type = build_qualified_type (type, type_quals);\n-\t  pedwarn (OPT_pedantic, \n+\t  pedwarn (input_location, OPT_pedantic, \n \t\t   \"ignoring %qV qualifiers added to function type %qT\",\n \t\t   bad_type, type);\n \t}"}, {"sha": "02423fab7df8144ae3ac9cddef75ddf5a7a7a594", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -551,7 +551,7 @@ warning_at (location_t location, int opt, const char *gmsgid, ...)\n    Returns true if the warning was printed, false if it was inhibited.  */\n \n bool\n-pedwarn_at (location_t location, int opt, const char *gmsgid, ...)\n+pedwarn (location_t location, int opt, const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n@@ -563,21 +563,6 @@ pedwarn_at (location_t location, int opt, const char *gmsgid, ...)\n   return report_diagnostic (&diagnostic);\n }\n \n-/* Equivalent to pedwarn_at using INPUT_LOCATION.  */\n-\n-bool\n-pedwarn (int opt, const char *gmsgid, ...)\n-{\n-  diagnostic_info diagnostic;\n-  va_list ap;\n-\n-  va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, input_location, DK_PEDWARN);\n-  diagnostic.option_index = opt;\n-  va_end (ap);\n-  return report_diagnostic (&diagnostic);\n-}\n-\n /* A \"permissive\" error at LOCATION: issues an error unless\n    -fpermissive was given on the command line, in which case it issues\n    a warning.  Use this for things that really should be errors but we"}, {"sha": "6a2865b7fc75b0312963b5a2b52aa179c15f7049", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -1,3 +1,7 @@\n+2008-08-21  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\t* f95-lang.c: Update all calls to pedwarn.\n+\n 2008-08-18  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/37032"}, {"sha": "82da3b1d9afc7eb12d74e3068e2cb7de6452db92", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -604,7 +604,7 @@ gfc_mark_addressable (tree exp)\n \t\t       IDENTIFIER_POINTER (DECL_NAME (x)));\n \t\treturn false;\n \t      }\n-\t    pedwarn (0, \"register variable %qs used in nested function\",\n+\t    pedwarn (input_location, 0, \"register variable %qs used in nested function\",\n \t\t     IDENTIFIER_POINTER (DECL_NAME (x)));\n \t  }\n \telse if (DECL_REGISTER (x) && !TREE_ADDRESSABLE (x))\n@@ -629,7 +629,7 @@ gfc_mark_addressable (tree exp)\n \t      }\n #endif\n \n-\t    pedwarn (0, \"address of register variable %qs requested\",\n+\t    pedwarn (input_location, 0, \"address of register variable %qs requested\",\n \t\t     IDENTIFIER_POINTER (DECL_NAME (x)));\n \t  }\n "}, {"sha": "38d8eaf80afb28a6da31afc3debd4c248772656a", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -824,7 +824,7 @@ check_global_declaration_1 (tree decl)\n \t  || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n     {\n       if (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-\tpedwarn (0, \"%q+F used but never defined\", decl);\n+\tpedwarn (input_location, 0, \"%q+F used but never defined\", decl);\n       else\n \twarning (OPT_Wunused_function, \"%q+F declared %<static%> but never defined\", decl);\n       /* This symbol is effectively an \"extern\" declaration now.  */"}, {"sha": "00646132d5889f012c8f56efd6dec76b1a3a4cd3", "filename": "gcc/toplev.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509c9d60e430b84903eb1232a70871aa93150623/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=509c9d60e430b84903eb1232a70871aa93150623", "patch": "@@ -63,9 +63,8 @@ extern bool warning_at (location_t, int, const char *, ...)\n extern void error (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n extern void fatal_error (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2)\n      ATTRIBUTE_NORETURN;\n-/* Pass one of the OPT_W* from options.h as the first parameter.  */\n-extern bool pedwarn (int, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\n-extern bool pedwarn_at (location_t, int, const char *, ...) \n+/* Pass one of the OPT_W* from options.h as the second parameter.  */\n+extern bool pedwarn (location_t, int, const char *, ...) \n      ATTRIBUTE_GCC_DIAG(3,4);\n extern bool permerror (location_t, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\n extern void sorry (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);"}]}