{"sha": "7a66745357510da6a18759839e4d8fc4715166a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E2Njc0NTM1NzUxMGRhNmExODc1OTgzOWU0ZDhmYzQ3MTUxNjZhMA==", "commit": {"author": {"name": "Ville Voutilainen", "email": "ville.voutilainen@gmail.com", "date": "2016-06-05T17:39:10Z"}, "committer": {"name": "Ville Voutilainen", "email": "ville@gcc.gnu.org", "date": "2016-06-05T17:39:10Z"}, "message": "Protect allocator-overloads of tuple-from-tuple constructors from cases that would create dangling references.\n\n\tProtect allocator-overloads of tuple-from-tuple constructors\n\tfrom cases that would create dangling references.\n\t* include/std/tuple (tuple(allocator_arg_t, const _Alloc&,\n \tconst tuple<_UElements...>&), tuple(allocator_arg_t, const _Alloc&,\n \ttuple<_UElements...>&&)): Add a check for _NonNestedTuple.\n\t* testsuite/20_util/tuple/cons/nested_tuple_construct.cc: Adjust.\n\nFrom-SVN: r237106", "tree": {"sha": "109cc8e6e390f10f2dd43532ae7ba194cfaf4780", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/109cc8e6e390f10f2dd43532ae7ba194cfaf4780"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a66745357510da6a18759839e4d8fc4715166a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a66745357510da6a18759839e4d8fc4715166a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a66745357510da6a18759839e4d8fc4715166a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a66745357510da6a18759839e4d8fc4715166a0/comments", "author": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2d83bd2c78021ed68b04c9d426925ef947dddaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2d83bd2c78021ed68b04c9d426925ef947dddaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2d83bd2c78021ed68b04c9d426925ef947dddaf"}], "stats": {"total": 72, "additions": 64, "deletions": 8}, "files": [{"sha": "8ff4d16d0e3ccdb73e6c419c6d0ccd94861a42bb", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a66745357510da6a18759839e4d8fc4715166a0/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a66745357510da6a18759839e4d8fc4715166a0/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7a66745357510da6a18759839e4d8fc4715166a0", "patch": "@@ -1,3 +1,12 @@\n+2016-06-05  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tProtect allocator-overloads of tuple-from-tuple constructors\n+\tfrom cases that would create dangling references.\n+\t* include/std/tuple (tuple(allocator_arg_t, const _Alloc&,\n+\tconst tuple<_UElements...>&), tuple(allocator_arg_t, const _Alloc&,\n+\ttuple<_UElements...>&&)): Add a check for _NonNestedTuple.\n+\t* testsuite/20_util/tuple/cons/nested_tuple_construct.cc: Adjust.\n+\n 2016-05-29  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* doc/xml/manual/backwards_compatibility.xml: Adjust"}, {"sha": "17c820490300a0c180e90fa4f31d2eb6ed6b2176", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a66745357510da6a18759839e4d8fc4715166a0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a66745357510da6a18759839e4d8fc4715166a0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=7a66745357510da6a18759839e4d8fc4715166a0", "patch": "@@ -769,47 +769,59 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \ttuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)\n \t: _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }\n \n-      template<typename _Alloc, typename... _UElements, typename\n+      template<typename _Alloc, typename _Dummy = void,\n+\t       typename... _UElements, typename\n         enable_if<_TMCT<_UElements...>::template\n                     _ConstructibleTuple<_UElements...>()\n                   && _TMCT<_UElements...>::template\n-                    _ImplicitlyConvertibleTuple<_UElements...>(),\n+                    _ImplicitlyConvertibleTuple<_UElements...>()\n+                  && _TNTC<_Dummy>::template\n+                    _NonNestedTuple<tuple<_UElements...>&&>(),\n         bool>::type=true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      const tuple<_UElements...>& __in)\n \t: _Inherited(__tag, __a,\n \t             static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n \t{ }\n \n-      template<typename _Alloc, typename... _UElements, typename\n+      template<typename _Alloc, typename _Dummy = void,\n+\t       typename... _UElements, typename\n         enable_if<_TMCT<_UElements...>::template\n                     _ConstructibleTuple<_UElements...>()\n                   && !_TMCT<_UElements...>::template\n-                    _ImplicitlyConvertibleTuple<_UElements...>(),\n+                    _ImplicitlyConvertibleTuple<_UElements...>()\n+                  && _TNTC<_Dummy>::template\n+                    _NonNestedTuple<tuple<_UElements...>&&>(),\n         bool>::type=false>\n \texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      const tuple<_UElements...>& __in)\n \t: _Inherited(__tag, __a,\n \t             static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n \t{ }\n \n-      template<typename _Alloc, typename... _UElements, typename\n+      template<typename _Alloc, typename _Dummy = void,\n+\t       typename... _UElements, typename\n         enable_if<_TMCT<_UElements...>::template\n                     _MoveConstructibleTuple<_UElements...>()\n                   && _TMCT<_UElements...>::template\n-                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),\n+                    _ImplicitlyMoveConvertibleTuple<_UElements...>()\n+                  && _TNTC<_Dummy>::template\n+                    _NonNestedTuple<tuple<_UElements...>&&>(),\n         bool>::type=true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      tuple<_UElements...>&& __in)\n \t: _Inherited(__tag, __a,\n \t             static_cast<_Tuple_impl<0, _UElements...>&&>(__in))\n \t{ }\n \n-      template<typename _Alloc, typename... _UElements, typename\n+      template<typename _Alloc, typename _Dummy = void,\n+\t       typename... _UElements, typename\n         enable_if<_TMCT<_UElements...>::template\n                     _MoveConstructibleTuple<_UElements...>()\n                   && !_TMCT<_UElements...>::template\n-                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),\n+                    _ImplicitlyMoveConvertibleTuple<_UElements...>()\n+                  && _TNTC<_Dummy>::template\n+                    _NonNestedTuple<tuple<_UElements...>&&>(),\n         bool>::type=false>\n \texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      tuple<_UElements...>&& __in)"}, {"sha": "7f6423913d8f978c433728ebbafb7d1aded93b08", "filename": "libstdc++-v3/testsuite/20_util/tuple/cons/nested_tuple_construct.cc", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a66745357510da6a18759839e4d8fc4715166a0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fnested_tuple_construct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a66745357510da6a18759839e4d8fc4715166a0/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fnested_tuple_construct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fnested_tuple_construct.cc?ref=7a66745357510da6a18759839e4d8fc4715166a0", "patch": "@@ -63,6 +63,32 @@ void f3()\n   std::tuple<std::tuple<X>> t3{std::move(t2)};\n }\n \n+void f4()\n+{\n+  std::allocator<X> a;\n+  X v;\n+  std::tuple<X> t1{std::allocator_arg, a, v};\n+  std::tuple<std::tuple<X>&&> t2{std::allocator_arg, a, std::move(t1)};\n+  std::tuple<std::tuple<X>> t3{std::allocator_arg, a, std::move(t2)};\n+}\n+\n+void f5()\n+{\n+  std::allocator<X> a;\n+  X v;\n+  std::tuple<X> t1{std::allocator_arg, a, std::move(v)};\n+  std::tuple<std::tuple<X>&&> t2{std::allocator_arg, a, std::move(t1)};\n+  std::tuple<std::tuple<X>> t3{std::allocator_arg, a, std::move(t2)};\n+}\n+\n+void f6()\n+{\n+  std::allocator<X> a;\n+  std::tuple<X> t1{std::allocator_arg, a, X{}};\n+  std::tuple<std::tuple<X>&&> t2{std::allocator_arg, a, std::move(t1)};\n+  std::tuple<std::tuple<X>> t3{std::allocator_arg, a, std::move(t2)};\n+}\n+\n int main()\n {\n   f();\n@@ -74,4 +100,13 @@ int main()\n   f3();\n   VERIFY(result == \"DefMoveDtorMoveDtorDtor\");\n   result = \"\";\n+  f4();\n+  VERIFY(result == \"DefCopyMoveDtorDtorDtor\");\n+  result = \"\";\n+  f5();\n+  VERIFY(result == \"DefMoveMoveDtorDtorDtor\");\n+  result = \"\";\n+  f6();\n+  VERIFY(result == \"DefMoveDtorMoveDtorDtor\");\n+  result = \"\";\n }"}]}