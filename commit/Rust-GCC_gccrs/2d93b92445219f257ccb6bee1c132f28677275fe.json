{"sha": "2d93b92445219f257ccb6bee1c132f28677275fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ5M2I5MjQ0NTIxOWYyNTdjY2I2YmVlMWMxMzJmMjg2NzcyNzVmZQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-12-21T05:13:43Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-12-21T05:13:43Z"}, "message": "For PR java/4766:\n\n\t* jcf-write.c (generate_bytecode_insns) [TRY_FINALLY_EXPR]: Handle\n\tcase where `finally' clause can't complete normally.\n\nFrom-SVN: r48232", "tree": {"sha": "36baa1c00fd2cb358bf4097f778beffc6327cb84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36baa1c00fd2cb358bf4097f778beffc6327cb84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d93b92445219f257ccb6bee1c132f28677275fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d93b92445219f257ccb6bee1c132f28677275fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d93b92445219f257ccb6bee1c132f28677275fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d93b92445219f257ccb6bee1c132f28677275fe/comments", "author": null, "committer": null, "parents": [{"sha": "f2af50dbcf4d6274a4e9de58d023cfd9aa446fd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2af50dbcf4d6274a4e9de58d023cfd9aa446fd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2af50dbcf4d6274a4e9de58d023cfd9aa446fd6"}], "stats": {"total": 126, "additions": 88, "deletions": 38}, "files": [{"sha": "110454603964c7d8435cc073b889f8248860c1d5", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d93b92445219f257ccb6bee1c132f28677275fe/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d93b92445219f257ccb6bee1c132f28677275fe/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=2d93b92445219f257ccb6bee1c132f28677275fe", "patch": "@@ -1,3 +1,9 @@\n+2001-12-20  Tom Tromey  <tromey@redhat.com>\n+\n+\tFor PR java/4766:\n+\t* jcf-write.c (generate_bytecode_insns) [TRY_FINALLY_EXPR]: Handle\n+\tcase where `finally' clause can't complete normally.\n+\n 2001-12-20  Tom Tromey  <tromey@redhat.com>\n \n \tFixes PR java/5057:"}, {"sha": "f6c0bfa71de2cf6e16b19d09294e723283eb96a8", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 82, "deletions": 38, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d93b92445219f257ccb6bee1c132f28677275fe/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d93b92445219f257ccb6bee1c132f28677275fe/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=2d93b92445219f257ccb6bee1c132f28677275fe", "patch": "@@ -1348,7 +1348,7 @@ generate_bytecode_conditional (exp, true_label, false_label,\n     abort ();\n }\n \n-/* Call pending cleanups i.e. those for surrounding TRY_FINAL_EXPRs.\n+/* Call pending cleanups i.e. those for surrounding TRY_FINALLY_EXPRs.\n    but only as far out as LIMIT (since we are about to jump to the\n    emit label that is LIMIT). */\n \n@@ -1683,8 +1683,8 @@ generate_bytecode_insns (exp, target, state)\n \t   1.  the switch_expression (the value used to select the correct case);\n \t   2.  the switch_body;\n \t   3.  the switch_instruction (the tableswitch/loopupswitch instruction.).\n-\t   After code generation, we will re-order then in the order 1, 3, 2.\n-\t   This is to avoid an extra GOTOs. */\n+\t   After code generation, we will re-order them in the order 1, 3, 2.\n+\t   This is to avoid any extra GOTOs. */\n \tstruct jcf_switch_state sw_state;\n \tstruct jcf_block *expression_last; /* Last block of the switch_expression. */\n \tstruct jcf_block *body_last; /* Last block of the switch_body. */\n@@ -2298,7 +2298,8 @@ generate_bytecode_insns (exp, target, state)\n \t  {\n \t    tree catch_clause = TREE_OPERAND (clause, 0);\n \t    tree exception_decl = BLOCK_EXPR_DECLS (catch_clause);\n-\t    struct jcf_handler *handler = alloc_handler (start_label, end_label, state);\n+\t    struct jcf_handler *handler = alloc_handler (start_label,\n+\t\t\t\t\t\t\t end_label, state);\n \t    if (exception_decl == NULL_TREE)\n \t      handler->type = NULL_TREE;\n \t    else\n@@ -2314,8 +2315,8 @@ generate_bytecode_insns (exp, target, state)\n \n     case TRY_FINALLY_EXPR:\n       {\n-\tstruct jcf_block *finished_label,\n-\t  *finally_label, *start_label, *end_label;\n+\tstruct jcf_block *finished_label = NULL;\n+\tstruct jcf_block *finally_label, *start_label, *end_label;\n \tstruct jcf_handler *handler;\n \ttree try_block = TREE_OPERAND (exp, 0);\n \ttree finally = TREE_OPERAND (exp, 1);\n@@ -2325,15 +2326,26 @@ generate_bytecode_insns (exp, target, state)\n \n \tfinally_label = gen_jcf_label (state);\n \tstart_label = get_jcf_label_here (state);\n-\tfinally_label->pc = PENDING_CLEANUP_PC;\n-\tfinally_label->next = state->labeled_blocks;\n-\tstate->labeled_blocks = finally_label;\n-\tstate->num_finalizers++;\n+\t/* If the `finally' clause can complete normally, we emit it\n+\t   as a subroutine and let the other clauses call it via\n+\t   `jsr'.  If it can't complete normally, then we simply emit\n+\t   `goto's directly to it.  */\n+\tif (CAN_COMPLETE_NORMALLY (finally))\n+\t  {\n+\t    finally_label->pc = PENDING_CLEANUP_PC;\n+\t    finally_label->next = state->labeled_blocks;\n+\t    state->labeled_blocks = finally_label;\n+\t    state->num_finalizers++;\n+\t  }\n \n \tgenerate_bytecode_insns (try_block, target, state);\n-\tif (state->labeled_blocks != finally_label)\n-\t  abort();\n-\tstate->labeled_blocks = finally_label->next;\n+\n+\tif (CAN_COMPLETE_NORMALLY (finally))\n+\t  {\n+\t    if (state->labeled_blocks != finally_label)\n+\t      abort();\n+\t    state->labeled_blocks = finally_label->next;\n+\t  }\n \tend_label = get_jcf_label_here (state);\n \n \tif (end_label == start_label)\n@@ -2344,43 +2356,75 @@ generate_bytecode_insns (exp, target, state)\n \t    break;\n \t  }\n \n-\treturn_link = build_decl (VAR_DECL, NULL_TREE,\n-\t\t\t\t  return_address_type_node);\n-\tfinished_label = gen_jcf_label (state);\n-\n+\tif (CAN_COMPLETE_NORMALLY (finally))\n+\t  {\n+\t    return_link = build_decl (VAR_DECL, NULL_TREE,\n+\t\t\t\t      return_address_type_node);\n+\t    finished_label = gen_jcf_label (state);\n+\t  }\n \n \tif (CAN_COMPLETE_NORMALLY (try_block))\n \t  {\n-\t    emit_jsr (finally_label, state);\n-\t    emit_goto (finished_label, state);\n+\t    if (CAN_COMPLETE_NORMALLY (finally))\n+\t      {\n+\t\temit_jsr (finally_label, state);\n+\t\temit_goto (finished_label, state);\n+\t      }\n+\t    else\n+\t      emit_goto (finally_label, state);\n \t  }\n \n-\t/* Handle exceptions. */\n+\t/* Handle exceptions.  */\n \n \texception_type = build_pointer_type (throwable_type_node);\n-\texception_decl = build_decl (VAR_DECL, NULL_TREE, exception_type);\n-\tlocalvar_alloc (return_link, state);\n+\tif (CAN_COMPLETE_NORMALLY (finally))\n+\t  {\n+\t    /* We're going to generate a subroutine, so we'll need to\n+\t       save and restore the exception around the `jsr'.  */ \n+\t    exception_decl = build_decl (VAR_DECL, NULL_TREE, exception_type);\n+\t    localvar_alloc (return_link, state);\n+\t  }\n \thandler = alloc_handler (start_label, end_label, state);\n \thandler->type = NULL_TREE;\n-\tlocalvar_alloc (exception_decl, state);\n-\tNOTE_PUSH (1);\n-\temit_store (exception_decl, state);\n-\temit_jsr (finally_label, state);\n-\temit_load (exception_decl, state);\n-\tRESERVE (1);\n-\tOP1 (OPCODE_athrow);\n-\tNOTE_POP (1);\n-\n-\t/* The finally block.  First save return PC into return_link. */\n+\tif (CAN_COMPLETE_NORMALLY (finally))\n+\t  {\n+\t    localvar_alloc (exception_decl, state);\n+\t    NOTE_PUSH (1);\n+\t    emit_store (exception_decl, state);\n+\t    emit_jsr (finally_label, state);\n+\t    emit_load (exception_decl, state);\n+\t    RESERVE (1);\n+\t    OP1 (OPCODE_athrow);\n+\t    NOTE_POP (1);\n+\t  }\n+\telse\n+\t  {\n+\t    /* We're not generating a subroutine.  In this case we can\n+\t       simply have the exception handler pop the exception and\n+\t       then fall through to the `finally' block.  */\n+\t    NOTE_PUSH (1);\n+\t    emit_pop (1, state);\n+\t    NOTE_POP (1);\n+\t  }\n+\n+\t/* The finally block.  If we're generating a subroutine, first\n+\t   save return PC into return_link.  Otherwise, just generate\n+\t   the code for the `finally' block.  */\n \tdefine_jcf_label (finally_label, state);\n-\tNOTE_PUSH (1);\n-\temit_store (return_link, state);\n+\tif (CAN_COMPLETE_NORMALLY (finally))\n+\t  {\n+\t    NOTE_PUSH (1);\n+\t    emit_store (return_link, state);\n+\t  }\n \n \tgenerate_bytecode_insns (finally, IGNORE_TARGET, state);\n-\tmaybe_wide (OPCODE_ret, DECL_LOCAL_INDEX (return_link), state);\n-\tlocalvar_free (exception_decl, state);\n-\tlocalvar_free (return_link, state);\n-\tdefine_jcf_label (finished_label, state);\n+\tif (CAN_COMPLETE_NORMALLY (finally))\n+\t  {\n+\t    maybe_wide (OPCODE_ret, DECL_LOCAL_INDEX (return_link), state);\n+\t    localvar_free (exception_decl, state);\n+\t    localvar_free (return_link, state);\n+\t    define_jcf_label (finished_label, state);\n+\t  }\n       }\n       break;\n     case THROW_EXPR:"}]}