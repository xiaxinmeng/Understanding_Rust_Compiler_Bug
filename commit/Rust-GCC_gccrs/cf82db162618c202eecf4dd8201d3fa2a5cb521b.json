{"sha": "cf82db162618c202eecf4dd8201d3fa2a5cb521b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y4MmRiMTYyNjE4YzIwMmVlY2Y0ZGQ4MjAxZDNmYTJhNWNiNTIxYg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2012-02-01T19:40:25Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2012-02-01T19:40:25Z"}, "message": "re PR fortran/51958 (-ffrontend-optimize generates wrong code)\n\n2012-02-01  Thomas K\u00f6nig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/51958\n\t* frontend-passes.c (convert_elseif):  New function.\n\t(optimize_namespace):  Call it.\n\n2012-02-01  Thomas K\u00f6nig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/51958\n\t* gfortran.dg/function_optimize_10.f90:  New test.\n\nFrom-SVN: r183812", "tree": {"sha": "1c1de7aad1210ad2ec5aa0340fad68d471836ad3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c1de7aad1210ad2ec5aa0340fad68d471836ad3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf82db162618c202eecf4dd8201d3fa2a5cb521b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf82db162618c202eecf4dd8201d3fa2a5cb521b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf82db162618c202eecf4dd8201d3fa2a5cb521b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf82db162618c202eecf4dd8201d3fa2a5cb521b/comments", "author": null, "committer": null, "parents": [{"sha": "25f10bd4bb837a944f9bb4bb134867e36e4614b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25f10bd4bb837a944f9bb4bb134867e36e4614b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25f10bd4bb837a944f9bb4bb134867e36e4614b8"}], "stats": {"total": 132, "additions": 132, "deletions": 0}, "files": [{"sha": "593d7784c629c700f93752bb4a68894643b4bf5f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf82db162618c202eecf4dd8201d3fa2a5cb521b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf82db162618c202eecf4dd8201d3fa2a5cb521b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=cf82db162618c202eecf4dd8201d3fa2a5cb521b", "patch": "@@ -1,3 +1,9 @@\n+2012-02-01  Thomas K\u00f6nig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/51958\n+\t* frontend-passes.c (convert_elseif):  New function.\n+\t(optimize_namespace):  Call it.\n+\n 2012-02-01  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/52024"}, {"sha": "a86982fa3a702320b8991dd2991c8f331f637d8a", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf82db162618c202eecf4dd8201d3fa2a5cb521b/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf82db162618c202eecf4dd8201d3fa2a5cb521b/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=cf82db162618c202eecf4dd8201d3fa2a5cb521b", "patch": "@@ -510,6 +510,69 @@ convert_do_while (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n   return 0;\n }\n \n+/* Code callback function for converting\n+   if (a) then\n+   ...\n+   else if (b) then\n+   end if\n+\n+   into\n+   if (a) then\n+   else\n+     if (b) then\n+     end if\n+   end if\n+\n+   because otherwise common function elimination would place the BLOCKs\n+   into the wrong place.  */\n+\n+static int\n+convert_elseif (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\tvoid *data ATTRIBUTE_UNUSED)\n+{\n+  gfc_code *co = *c;\n+  gfc_code *c_if1, *c_if2, *else_stmt;\n+\n+  if (co->op != EXEC_IF)\n+    return 0;\n+\n+  /* This loop starts out with the first ELSE statement.  */\n+  else_stmt = co->block->block;\n+\n+  while (else_stmt != NULL)\n+    {\n+      gfc_code *next_else;\n+\n+      /* If there is no condition, we're done.  */\n+      if (else_stmt->expr1 == NULL)\n+\tbreak;\n+\n+      next_else = else_stmt->block;\n+\n+      /* Generate the new IF statement.  */\n+      c_if2 = XCNEW (gfc_code);\n+      c_if2->op = EXEC_IF;\n+      c_if2->expr1 = else_stmt->expr1;\n+      c_if2->next = else_stmt->next;\n+      c_if2->loc = else_stmt->loc;\n+      c_if2->block = next_else;\n+\n+      /* ... plus the one to chain it to.  */\n+      c_if1 = XCNEW (gfc_code);\n+      c_if1->op = EXEC_IF;\n+      c_if1->block = c_if2;\n+      c_if1->loc = else_stmt->loc;\n+\n+      /* Insert the new IF after the ELSE.  */\n+      else_stmt->expr1 = NULL;\n+      else_stmt->next = c_if1;\n+      else_stmt->block = NULL;\n+\n+      else_stmt = next_else;\n+    }\n+  /*  Don't walk subtrees.  */\n+  return 0;\n+}\n /* Optimize a namespace, including all contained namespaces.  */\n \n static void\n@@ -521,6 +584,7 @@ optimize_namespace (gfc_namespace *ns)\n   in_omp_workshare = false;\n \n   gfc_code_walker (&ns->code, convert_do_while, dummy_expr_callback, NULL);\n+  gfc_code_walker (&ns->code, convert_elseif, dummy_expr_callback, NULL);\n   gfc_code_walker (&ns->code, cfe_code, cfe_expr_0, NULL);\n   gfc_code_walker (&ns->code, optimize_code, optimize_expr, NULL);\n "}, {"sha": "1b3a406e48ae38438d73895a8bf0826441736e46", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf82db162618c202eecf4dd8201d3fa2a5cb521b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf82db162618c202eecf4dd8201d3fa2a5cb521b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cf82db162618c202eecf4dd8201d3fa2a5cb521b", "patch": "@@ -1,3 +1,8 @@\n+2012-02-01  Thomas K\u00f6nig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/51958\n+\t* gfortran.dg/function_optimize_10.f90:  New test.\n+\n 2012-02-01  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* go.test/go-test.exp (go-gc-tests): xfail test/nilptr.go runtime"}, {"sha": "0be6b997ae10011a6f2d524bb0ee24ed014644c8", "filename": "gcc/testsuite/gfortran.dg/function_optimize_10.f90", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf82db162618c202eecf4dd8201d3fa2a5cb521b/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf82db162618c202eecf4dd8201d3fa2a5cb521b/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_10.f90?ref=cf82db162618c202eecf4dd8201d3fa2a5cb521b", "patch": "@@ -0,0 +1,57 @@\n+! { do-do run }\n+! PR 51858 - this used to generate wrong code.\n+! Original test case by Don Simons.\n+\n+program main\n+  implicit none\n+  logical :: test1_ok\n+  logical :: test2_ok\n+  logical :: test3_ok\n+  character(len=1):: charq\n+\n+  charq = 'c'\n+  \n+  test1_ok = .true.\n+  test2_ok = .false.\n+  if (charq .eq. ' ') then\n+     test1_ok = .false.\n+  else if ((my_ichar(charq).ge.97 .and. my_ichar(charq).le.103)) then\n+     test2_OK = .true.\n+  end if\n+  if ((.not. test1_ok) .or. (.not. test2_ok)) call abort\n+\n+  test1_ok = .true.\n+  test2_ok = .true.\n+  test3_ok = .false.\n+\n+  if (charq .eq. ' ') then\n+     test1_ok = .false.\n+  else if ((my_ichar(charq).lt.97 .or. my_ichar(charq).gt.103)) then\n+     test2_ok = .false.\n+  else if ((my_ichar(charq).ge.97 .and. my_ichar(charq).le.103)) then\n+     test3_ok = .true.\n+  end if\n+  if ((.not. test1_ok) .or. (.not. test2_ok) .or. (.not. test3_ok)) call abort\n+\n+  test1_ok = .true.\n+  test2_ok = .true.\n+  test3_ok = .false.\n+\n+  if (charq .eq. ' ') then\n+     test1_ok = .false.\n+  else if ((my_ichar(charq).lt.97 .or. my_ichar(charq).gt.103)) then\n+     test2_ok = .false.\n+  else\n+     test3_ok = .true.\n+  end if\n+\n+  if ((.not. test1_ok) .or. (.not. test2_ok) .or. (.not. test3_ok)) call abort\n+\n+contains\n+  pure function my_ichar(c)\n+    integer :: my_ichar\n+    character(len=1), intent(in) :: c\n+    my_ichar = ichar(c)\n+  end function my_ichar\n+end program main\n+"}]}