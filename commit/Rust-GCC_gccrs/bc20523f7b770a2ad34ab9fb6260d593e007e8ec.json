{"sha": "bc20523f7b770a2ad34ab9fb6260d593e007e8ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMyMDUyM2Y3Yjc3MGEyYWQzNGFiOWZiNjI2MGQ1OTNlMDA3ZThlYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T06:21:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T06:21:26Z"}, "message": "[multiple changes]\n\n2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch4.adb: Use predefined unsigned type in all cases.\n\n2010-06-23  Bob Duff  <duff@adacore.com>\n\n\t* s-rannum.adb (Reset): Avoid overflow in calculation of Initiator.\n\t* g-pehage.ads: Minor comment fixes.\n\t* g-pehage.adb: Minor: Add some additional debugging printouts under\n\tVerbose flag.\n\n2010-06-23  Robert Dewar  <dewar@adacore.com>\n\n\t* binde.adb (Better_Choice): Always prefer Pure/Preelab.\n\t(Worse_Choice): Always prefer Pure/Preelab.\n\nFrom-SVN: r161246", "tree": {"sha": "055f02e3e3f13e394ea9082c561ba3e01e199a63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/055f02e3e3f13e394ea9082c561ba3e01e199a63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc20523f7b770a2ad34ab9fb6260d593e007e8ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc20523f7b770a2ad34ab9fb6260d593e007e8ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc20523f7b770a2ad34ab9fb6260d593e007e8ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc20523f7b770a2ad34ab9fb6260d593e007e8ec/comments", "author": null, "committer": null, "parents": [{"sha": "eeed09ef663f6c6f0c4f41f64d6029e6474263b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeed09ef663f6c6f0c4f41f64d6029e6474263b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eeed09ef663f6c6f0c4f41f64d6029e6474263b0"}], "stats": {"total": 324, "additions": 264, "deletions": 60}, "files": [{"sha": "8230b7394c4c47dca1ceca7cd0efc1fbd164eaf8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc20523f7b770a2ad34ab9fb6260d593e007e8ec/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc20523f7b770a2ad34ab9fb6260d593e007e8ec/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bc20523f7b770a2ad34ab9fb6260d593e007e8ec", "patch": "@@ -1,3 +1,19 @@\n+2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch4.adb: Use predefined unsigned type in all cases.\n+\n+2010-06-23  Bob Duff  <duff@adacore.com>\n+\n+\t* s-rannum.adb (Reset): Avoid overflow in calculation of Initiator.\n+\t* g-pehage.ads: Minor comment fixes.\n+\t* g-pehage.adb: Minor: Add some additional debugging printouts under\n+\tVerbose flag.\n+\n+2010-06-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* binde.adb (Better_Choice): Always prefer Pure/Preelab.\n+\t(Worse_Choice): Always prefer Pure/Preelab.\n+\n 2010-06-23  Vincent Celier  <celier@adacore.com>\n \n \t* a-reatim.adb: Call System.OS_Primitives.Initialize during elaboration"}, {"sha": "f4681906df1cd61485b6640825ff92aa2a5372a0", "filename": "gcc/ada/binde.adb", "status": "modified", "additions": 216, "deletions": 55, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc20523f7b770a2ad34ab9fb6260d593e007e8ec/gcc%2Fada%2Fbinde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc20523f7b770a2ad34ab9fb6260d593e007e8ec/gcc%2Fada%2Fbinde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.adb?ref=bc20523f7b770a2ad34ab9fb6260d593e007e8ec", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -224,25 +224,25 @@ package body Binde is\n       After  : Unit_Id;\n       R      : Succ_Reason;\n       Ea_Id  : Elab_All_Id := No_Elab_All_Link);\n-   --  Establish a successor link, Before must be elaborated before After,\n-   --  and the reason for the link is R. Ea_Id is the contents to be placed\n-   --  in the Elab_All_Link of the entry.\n+   --  Establish a successor link, Before must be elaborated before After, and\n+   --  the reason for the link is R. Ea_Id is the contents to be placed in the\n+   --  Elab_All_Link of the entry.\n \n    procedure Choose (Chosen : Unit_Id);\n-   --  Chosen is the next entry chosen in the elaboration order. This\n-   --  procedure updates all data structures appropriately.\n+   --  Chosen is the next entry chosen in the elaboration order. This procedure\n+   --  updates all data structures appropriately.\n \n    function Corresponding_Body (U : Unit_Id) return Unit_Id;\n    pragma Inline (Corresponding_Body);\n-   --  Given a unit which is a spec for which there is a separate body,\n-   --  return the unit id of the body. It is an error to call this routine\n-   --  with a unit that is not a spec, or which does not have a separate body.\n+   --  Given a unit which is a spec for which there is a separate body, return\n+   --  the unit id of the body. It is an error to call this routine with a unit\n+   --  that is not a spec, or which does not have a separate body.\n \n    function Corresponding_Spec (U : Unit_Id) return Unit_Id;\n    pragma Inline (Corresponding_Spec);\n-   --  Given a unit which is a body for which there is a separate spec,\n-   --  return the unit id of the spec. It is an error to call this routine\n-   --  with a unit that is not a body, or which does not have a separate spec.\n+   --  Given a unit which is a body for which there is a separate spec, return\n+   --  the unit id of the spec. It is an error to call this routine with a unit\n+   --  that is not a body, or which does not have a separate spec.\n \n    procedure Diagnose_Elaboration_Problem;\n    --  Called when no elaboration order can be found. Outputs an appropriate\n@@ -276,6 +276,10 @@ package body Binde is\n    pragma Inline (Is_Body_Unit);\n    --  Determines if given unit is a body\n \n+   function Is_Pure_Or_Preelab_Unit (U : Unit_Id) return Boolean;\n+   --  Returns True if corresponding unit is Pure or Preelaborate. Includes\n+   --  dealing with testing flags on spec if it is given a body.\n+\n    function Is_Waiting_Body (U : Unit_Id) return Boolean;\n    pragma Inline (Is_Waiting_Body);\n    --  Determines if U is a waiting body, defined as a body which has\n@@ -286,16 +290,16 @@ package body Binde is\n       Link : Elab_All_Id) return Elab_All_Id;\n    --  Make an Elab_All_Entries table entry with the given Unam and Link\n \n-   function Unit_Id_Of (Uname : Unit_Name_Type) return Unit_Id;\n-   --  This function uses the Info field set in the names table to obtain\n-   --  the unit Id of a unit, given its name id value.\n-\n-   function Worse_Choice (U1, U2 : Unit_Id) return Boolean;\n+   function Pessimistic_Better_Choice (U1, U2 : Unit_Id) return Boolean;\n    --  This is like Better_Choice, and has the same interface, but returns\n-   --  true if U1 is a worse choice than U2 in the sense of the -h (horrible\n+   --  true if U1 is a worse choice than U2 in the sense of the -p (pessimistic\n    --  elaboration order) switch. We still have to obey Ada rules, so it is\n    --  not quite the direct inverse of Better_Choice.\n \n+   function Unit_Id_Of (Uname : Unit_Name_Type) return Unit_Id;\n+   --  This function uses the Info field set in the names table to obtain\n+   --  the unit Id of a unit, given its name id value.\n+\n    procedure Write_Dependencies;\n    --  Write out dependencies (called only if appropriate option is set)\n \n@@ -323,7 +327,7 @@ package body Binde is\n       --  Note: the checks here are applied in sequence, and the ordering is\n       --  significant (i.e. the more important criteria are applied first).\n \n-      --  Prefer a waiting body to any other case\n+      --  Prefer a waiting body to one that is not a waiting body\n \n       if Is_Waiting_Body (U1) and then not Is_Waiting_Body (U2) then\n          if Debug_Flag_B then\n@@ -370,6 +374,28 @@ package body Binde is\n \n          return False;\n \n+      --  Prefer a pure or preelaborable unit to one that is not\n+\n+      elsif Is_Pure_Or_Preelab_Unit (U1)\n+              and then not\n+            Is_Pure_Or_Preelab_Unit (U2)\n+      then\n+         if Debug_Flag_B then\n+            Write_Line (\"  True: u1 is pure/preelab, u2 is not\");\n+         end if;\n+\n+         return True;\n+\n+      elsif Is_Pure_Or_Preelab_Unit (U2)\n+              and then not\n+            Is_Pure_Or_Preelab_Unit (U1)\n+      then\n+         if Debug_Flag_B then\n+            Write_Line (\"  False: u2 is pure/preelab, u1 is not\");\n+         end if;\n+\n+         return False;\n+\n       --  Prefer a body to a spec\n \n       elsif Is_Body_Unit (U1) and then not Is_Body_Unit (U2) then\n@@ -1141,7 +1167,7 @@ package body Binde is\n               or else ((not Pessimistic_Elab_Order)\n                          and then Better_Choice (U, Best_So_Far))\n               or else (Pessimistic_Elab_Order\n-                         and then Worse_Choice (U, Best_So_Far))\n+                         and then Pessimistic_Better_Choice (U, Best_So_Far))\n             then\n                if Debug_Flag_N then\n                   Write_Str (\"    tentatively chosen (best so far)\");\n@@ -1321,6 +1347,28 @@ package body Binde is\n         or else Units.Table (U).Utype = Is_Body_Only;\n    end Is_Body_Unit;\n \n+   -----------------------------\n+   -- Is_Pure_Or_Preelab_Unit --\n+   -----------------------------\n+\n+   function Is_Pure_Or_Preelab_Unit (U : Unit_Id) return Boolean is\n+   begin\n+      --  If we have a body with separate spec, test flags on the spec\n+\n+      if Units.Table (U).Utype = Is_Body then\n+         return Units.Table (U + 1).Preelab\n+                  or else\n+                Units.Table (U + 1).Pure;\n+\n+      --  Otherwise we have a spec or body acting as spec, test flags on unit\n+\n+      else\n+         return Units.Table (U).Preelab\n+                  or else\n+                Units.Table (U).Pure;\n+      end if;\n+   end Is_Pure_Or_Preelab_Unit;\n+\n    ---------------------\n    -- Is_Waiting_Body --\n    ---------------------\n@@ -1346,51 +1394,115 @@ package body Binde is\n       return Elab_All_Entries.Last;\n    end Make_Elab_Entry;\n \n-   ----------------\n-   -- Unit_Id_Of --\n-   ----------------\n-\n-   function Unit_Id_Of (Uname : Unit_Name_Type) return Unit_Id is\n-      Info : constant Int := Get_Name_Table_Info (Uname);\n-   begin\n-      pragma Assert (Info /= 0 and then Unit_Id (Info) /= No_Unit_Id);\n-      return Unit_Id (Info);\n-   end Unit_Id_Of;\n-\n-   ------------------\n-   -- Worse_Choice --\n-   ------------------\n+   -------------------------------\n+   -- Pessimistic_Better_Choice --\n+   -------------------------------\n \n-   function Worse_Choice (U1, U2 : Unit_Id) return Boolean is\n+   function Pessimistic_Better_Choice (U1, U2 : Unit_Id) return Boolean is\n       UT1 : Unit_Record renames Units.Table (U1);\n       UT2 : Unit_Record renames Units.Table (U2);\n \n    begin\n+      if Debug_Flag_B then\n+         Write_Str (\"Pessimistic_Better_Choice (\");\n+         Write_Unit_Name (UT1.Uname);\n+         Write_Str (\", \");\n+         Write_Unit_Name (UT2.Uname);\n+         Write_Line (\")\");\n+      end if;\n+\n       --  Note: the checks here are applied in sequence, and the ordering is\n       --  significant (i.e. the more important criteria are applied first).\n \n-      --  If either unit is internal, then use Better_Choice, since the\n-      --  language requires that predefined units not mess up in the choice\n-      --  of elaboration order, and for internal units, any problems are\n-      --  ours and not the programmers.\n+      --  If either unit is predefined or internal, then we use the normal\n+      --  Better_Choice rule, since we don't want to disturb the elaboration\n+      --  rules of the language with -p, same treatment for Pure/Preelab.\n+\n+      --  Prefer a predefined unit to a non-predefined unit\n \n-      if UT1.Internal or else UT2.Internal then\n-         return Better_Choice (U1, U2);\n+      if UT1.Predefined and then not UT2.Predefined then\n+         if Debug_Flag_B then\n+            Write_Line (\"  True: u1 is predefined, u2 is not\");\n+         end if;\n \n-      --  Prefer anything else to a waiting body (!)\n+         return True;\n+\n+      elsif UT2.Predefined and then not UT1.Predefined then\n+         if Debug_Flag_B then\n+            Write_Line (\"  False: u2 is predefined, u1 is not\");\n+         end if;\n+\n+         return False;\n+\n+      --  Prefer an internal unit to a non-internal unit\n+\n+      elsif UT1.Internal and then not UT2.Internal then\n+         if Debug_Flag_B then\n+            Write_Line (\"  True: u1 is internal, u2 is not\");\n+         end if;\n+\n+         return True;\n+\n+      elsif UT2.Internal and then not UT1.Internal then\n+         if Debug_Flag_B then\n+            Write_Line (\"  False: u2 is internal, u1 is not\");\n+         end if;\n+\n+         return False;\n+\n+      --  Prefer a pure or preelaborable unit to one that is not\n+\n+      elsif Is_Pure_Or_Preelab_Unit (U1)\n+              and then not\n+            Is_Pure_Or_Preelab_Unit (U2)\n+      then\n+         if Debug_Flag_B then\n+            Write_Line (\"  True: u1 is pure/preelab, u2 is not\");\n+         end if;\n+\n+         return True;\n+\n+      elsif Is_Pure_Or_Preelab_Unit (U2)\n+              and then not\n+            Is_Pure_Or_Preelab_Unit (U1)\n+      then\n+         if Debug_Flag_B then\n+            Write_Line (\"  False: u2 is pure/preelab, u1 is not\");\n+         end if;\n+\n+         return False;\n+\n+      --  Prefer anything else to a waiting body. We want to make bodies wait\n+      --  as long as possible, till we are forced to choose them!\n \n       elsif Is_Waiting_Body (U1) and then not Is_Waiting_Body (U2) then\n+         if Debug_Flag_B then\n+            Write_Line (\"  False: u1 is waiting body, u2 is not\");\n+         end if;\n+\n          return False;\n \n       elsif Is_Waiting_Body (U2) and then not Is_Waiting_Body (U1) then\n+         if Debug_Flag_B then\n+            Write_Line (\"  True: u2 is waiting body, u1 is not\");\n+         end if;\n+\n          return True;\n \n       --  Prefer a spec to a body (!)\n \n       elsif Is_Body_Unit (U1) and then not Is_Body_Unit (U2) then\n+         if Debug_Flag_B then\n+            Write_Line (\"  False: u1 is body, u2 is not\");\n+         end if;\n+\n          return False;\n \n       elsif Is_Body_Unit (U2) and then not Is_Body_Unit (U1) then\n+         if Debug_Flag_B then\n+            Write_Line (\"  True: u2 is body, u1 is not\");\n+         end if;\n+\n          return True;\n \n       --  If both are waiting bodies, then prefer the one whose spec is\n@@ -1404,12 +1516,24 @@ package body Binde is\n       --  A before the spec of B if it could. Since it could not, there it\n       --  must be the case that A depends on B. It is therefore a good idea\n       --  to put the body of B last so that if there is an elaboration order\n-      --  problem, we will find it (that's what horrible order is about)\n+      --  problem, we will find it (that's what pssimistic order is about)\n \n       elsif Is_Waiting_Body (U1) and then Is_Waiting_Body (U2) then\n-         return\n-           UNR.Table (Corresponding_Spec (U1)).Elab_Position <\n-           UNR.Table (Corresponding_Spec (U2)).Elab_Position;\n+         declare\n+            Result : constant Boolean :=\n+                       UNR.Table (Corresponding_Spec (U1)).Elab_Position <\n+                       UNR.Table (Corresponding_Spec (U2)).Elab_Position;\n+         begin\n+            if Debug_Flag_B then\n+               if Result then\n+                  Write_Line (\"  True: based on waiting body elab positions\");\n+               else\n+                  Write_Line (\"  False: based on waiting body elab positions\");\n+               end if;\n+            end if;\n+\n+            return Result;\n+         end;\n       end if;\n \n       --  Remaining choice rules are disabled by Debug flag -do\n@@ -1420,44 +1544,81 @@ package body Binde is\n          --  as Elaborate_Body_Desirable. In the normal case, we generally want\n          --  to delay the elaboration of these specs as long as possible, so\n          --  that bodies have better chance of being elaborated closer to the\n-         --  specs. Worse_Choice as usual wants to do the opposite and\n-         --  elaborate such specs as early as possible.\n+         --  specs. Pessimistic_Better_Choice as usual wants to do the opposite\n+         --  and elaborate such specs as early as possible.\n \n          --  If we have two units, one of which is a spec for which this flag\n          --  is set, and the other is not, we normally prefer to delay the spec\n-         --  for which the flag is set, and so Worse_Choice does the opposite.\n+         --  for which the flag is set, so again Pessimistic_Better_Choice does\n+         --  the opposite.\n \n          if not UT1.Elaborate_Body_Desirable\n            and then UT2.Elaborate_Body_Desirable\n          then\n+            if Debug_Flag_B then\n+               Write_Line (\"  False: u1 is elab body desirable, u2 is not\");\n+            end if;\n+\n             return False;\n \n          elsif not UT2.Elaborate_Body_Desirable\n            and then UT1.Elaborate_Body_Desirable\n          then\n+            if Debug_Flag_B then\n+               Write_Line (\"  True: u1 is elab body desirable, u2 is not\");\n+            end if;\n+\n             return True;\n \n             --  If we have two specs that are both marked as Elaborate_Body\n             --  desirable, we normally prefer the one whose body is nearer to\n             --  being able to be elaborated, based on the Num_Pred count. This\n             --  helps to ensure bodies are as close to specs as possible. As\n-            --  usual, Worse_Choice does the opposite.\n+            --  usual, Pessimistic_Better_Choice does the opposite.\n \n          elsif UT1.Elaborate_Body_Desirable\n            and then UT2.Elaborate_Body_Desirable\n          then\n-            return UNR.Table (Corresponding_Body (U1)).Num_Pred >=\n-              UNR.Table (Corresponding_Body (U2)).Num_Pred;\n+            declare\n+               Result : constant Boolean :=\n+                          UNR.Table (Corresponding_Body (U1)).Num_Pred >=\n+                          UNR.Table (Corresponding_Body (U2)).Num_Pred;\n+            begin\n+               if Debug_Flag_B then\n+                  if Result then\n+                     Write_Line (\"  True based on Num_Pred compare\");\n+                  else\n+                     Write_Line (\"  False based on Num_Pred compare\");\n+                  end if;\n+               end if;\n+\n+               return Result;\n+            end;\n          end if;\n       end if;\n \n       --  If we fall through, it means that no preference rule applies, so we\n       --  use alphabetical order to at least give a deterministic result. Since\n-      --  Worse_Choice is in the business of stirring up the order, we will\n-      --  use reverse alphabetical ordering.\n+      --  Pessimistic_Better_Choice is in the business of stirring up the\n+      --  order, we will use reverse alphabetical ordering.\n+\n+      if Debug_Flag_B then\n+         Write_Line (\"  choose on reverse alpha order\");\n+      end if;\n \n       return Uname_Less (UT2.Uname, UT1.Uname);\n-   end Worse_Choice;\n+   end Pessimistic_Better_Choice;\n+\n+   ----------------\n+   -- Unit_Id_Of --\n+   ----------------\n+\n+   function Unit_Id_Of (Uname : Unit_Name_Type) return Unit_Id is\n+      Info : constant Int := Get_Name_Table_Info (Uname);\n+   begin\n+      pragma Assert (Info /= 0 and then Unit_Id (Info) /= No_Unit_Id);\n+      return Unit_Id (Info);\n+   end Unit_Id_Of;\n \n    ------------------------\n    -- Write_Dependencies --"}, {"sha": "6a78a935080acc5708b6d3664ea601eebbe8f6e3", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc20523f7b770a2ad34ab9fb6260d593e007e8ec/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc20523f7b770a2ad34ab9fb6260d593e007e8ec/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=bc20523f7b770a2ad34ab9fb6260d593e007e8ec", "patch": "@@ -6927,7 +6927,7 @@ package body Exp_Ch4 is\n                Utyp := RTE (RE_Unsigned_16);\n \n             elsif RM_Size (Rtyp) = RM_Size (Standard_Unsigned) then\n-               Utyp := Typ;\n+               Utyp := RTE (RE_Unsigned_32);\n \n             else\n                Utyp := RTE (RE_Long_Long_Unsigned);"}, {"sha": "6c63c82cb497e7c66bfa9948cb00af7947858b7a", "filename": "gcc/ada/g-pehage.adb", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc20523f7b770a2ad34ab9fb6260d593e007e8ec/gcc%2Fada%2Fg-pehage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc20523f7b770a2ad34ab9fb6260d593e007e8ec/gcc%2Fada%2Fg-pehage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-pehage.adb?ref=bc20523f7b770a2ad34ab9fb6260d593e007e8ec", "patch": "@@ -33,6 +33,7 @@\n \n with Ada.IO_Exceptions;       use Ada.IO_Exceptions;\n with Ada.Characters.Handling; use Ada.Characters.Handling;\n+with Ada.Directories;\n \n with GNAT.Heap_Sort_G;\n with GNAT.OS_Lib;      use GNAT.OS_Lib;\n@@ -888,6 +889,11 @@ package body GNAT.Perfect_Hash_Generators is\n \n    procedure Finalize is\n    begin\n+      if Verbose then\n+         Put (Output, \"Finalize\");\n+         New_Line (Output);\n+      end if;\n+\n       --  Deallocate all the WT components (both initial and reduced\n       --  ones) to avoid memory leaks.\n \n@@ -1165,6 +1171,11 @@ package body GNAT.Perfect_Hash_Generators is\n       Tries  : Positive     := Default_Tries)\n    is\n    begin\n+      if Verbose then\n+         Put (Output, \"Initialize\");\n+         New_Line (Output);\n+      end if;\n+\n       --  Deallocate the part of the table concerning the reduced words.\n       --  Initial words are already present in the table. We may have reduced\n       --  words already there because a previous computation failed. We are\n@@ -1245,6 +1256,11 @@ package body GNAT.Perfect_Hash_Generators is\n       Len  : constant Natural := Value'Length;\n \n    begin\n+      if Verbose then\n+         Put (Output, \"Inserting \"\"\" & Value & \"\"\"\");\n+         New_Line (Output);\n+      end if;\n+\n       WT.Set_Last (NK);\n       WT.Table (NK) := New_Word (Value);\n       NK := NK + 1;\n@@ -1494,6 +1510,12 @@ package body GNAT.Perfect_Hash_Generators is\n \n    begin\n \n+      if Verbose then\n+         Put (Output,\n+              \"Producing \" & Ada.Directories.Current_Directory & \"/\" & FName);\n+         New_Line (Output);\n+      end if;\n+\n       File := Create_File (FName, Binary);\n \n       if File = Invalid_FD then"}, {"sha": "24f5bcff1b2627a2dabcb6f4a592d2b4adf7707a", "filename": "gcc/ada/g-pehage.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc20523f7b770a2ad34ab9fb6260d593e007e8ec/gcc%2Fada%2Fg-pehage.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc20523f7b770a2ad34ab9fb6260d593e007e8ec/gcc%2Fada%2Fg-pehage.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-pehage.ads?ref=bc20523f7b770a2ad34ab9fb6260d593e007e8ec", "patch": "@@ -124,11 +124,11 @@ package GNAT.Perfect_Hash_Generators is\n    procedure Compute (Position : String := Default_Position);\n    --  Compute the hash function. Position allows to define selection of\n    --  character positions used in the word hash function. Positions can be\n-   --  separated by commas and range like x-y may be used. Character '$'\n+   --  separated by commas and ranges like x-y may be used. Character '$'\n    --  represents the final character of a word. With an empty position, the\n    --  generator automatically produces positions to reduce the memory usage.\n-   --  Raise Too_Many_Tries in case that the algorithm does not succeed in less\n-   --  than Tries attempts (see Initialize).\n+   --  Raise Too_Many_Tries if the algorithm does not succeed within Tries\n+   --  attempts (see Initialize).\n \n    procedure Produce (Pkg_Name : String := Default_Pkg_Name);\n    --  Generate the hash function package Pkg_Name. This package includes the"}, {"sha": "d85dd2efacf1a134fb6e876ceb16a41d3dcbea03", "filename": "gcc/ada/s-rannum.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc20523f7b770a2ad34ab9fb6260d593e007e8ec/gcc%2Fada%2Fs-rannum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc20523f7b770a2ad34ab9fb6260d593e007e8ec/gcc%2Fada%2Fs-rannum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-rannum.adb?ref=bc20523f7b770a2ad34ab9fb6260d593e007e8ec", "patch": "@@ -484,7 +484,12 @@ package body System.Random_Numbers is\n    -----------\n \n    procedure Reset (Gen : Generator) is\n-      X : constant Unsigned_32 := Unsigned_32 ((Calendar.Clock - Y2K) * 64.0);\n+      Clock              : constant Time := Calendar.Clock;\n+      Duration_Since_Y2K : constant Duration := Clock - Y2K;\n+\n+      X : constant Unsigned_32 :=\n+            Unsigned_32'Mod (Unsigned_64 (Duration_Since_Y2K) * 64);\n+\n    begin\n       Init (Gen, X);\n    end Reset;"}]}