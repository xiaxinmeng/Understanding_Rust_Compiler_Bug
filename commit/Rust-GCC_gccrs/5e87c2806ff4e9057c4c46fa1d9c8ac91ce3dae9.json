{"sha": "5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU4N2MyODA2ZmY0ZTkwNTdjNGM0NmZhMWQ5YzhhYzkxY2UzZGFlOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-05-01T21:34:16Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-05-01T21:34:16Z"}, "message": "compiler,runtime: do more direct interfaces\n    \n    A direct interface is an interface whose data word contains the\n    actual data value, instead of a pointer to it. The gc toolchain\n    creates a direct interface if the value is pointer shaped, that\n    includes pointers (including unsafe.Pointer), functions, channels,\n    maps, and structs and arrays containing a single pointer-shaped\n    field. In gccgo, we only do this for pointers. This CL unifies\n    direct interface types with gc. This reduces allocations when\n    converting such types to interfaces.\n    \n    Our method functions used to always take pointer receivers, to\n    make interface calls easy. Now for direct interface types, their\n    value methods will take value receivers. For a pointer to those\n    types, when converted to interface, the interface data contains\n    the pointer. For that interface to call a value method, it will\n    need a wrapper method that dereference the pointer and invokes\n    the value method. The wrapper method, instead of the actual one,\n    is put into the itable of the pointer type.\n    \n    In the runtime, adjust funcPC for the new layout of interfaces of\n    functions.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/168409\n\nFrom-SVN: r270779", "tree": {"sha": "e3583babaa67131fcef04311cf265c9415582ca9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3583babaa67131fcef04311cf265c9415582ca9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/comments", "author": null, "committer": null, "parents": [{"sha": "1da37f43b21e0c35e57b627edfa99ec80d2976ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1da37f43b21e0c35e57b627edfa99ec80d2976ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1da37f43b21e0c35e57b627edfa99ec80d2976ee"}], "stats": {"total": 430, "additions": 388, "deletions": 42}, "files": [{"sha": "f5aa6a9d384369f9b3a4febbde78e8ac14dba82c", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9", "patch": "@@ -1,4 +1,4 @@\n-e0b906b13cbc947406c634aaf8b06270292bd7e0\n+b42744825e3f2d1d2981eedbb67d6ac6419b8122\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "0dd869bb9c2f2ed5d8c55861b9b70673dddc8359", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 90, "deletions": 16, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9", "patch": "@@ -292,11 +292,11 @@ Expression::convert_type_to_interface(Type* lhs_type, Expression* rhs,\n     }\n \n   Expression* obj;\n-  if (rhs_type->points_to() != NULL)\n+  if (rhs_type->is_direct_iface_type())\n     {\n       // We are assigning a pointer to the interface; the interface\n       // holds the pointer itself.\n-      obj = rhs;\n+      obj = unpack_direct_iface(rhs, location);\n     }\n   else\n     {\n@@ -310,6 +310,60 @@ Expression::convert_type_to_interface(Type* lhs_type, Expression* rhs,\n   return Expression::make_interface_value(lhs_type, first_field, obj, location);\n }\n \n+// Return an expression for the pointer-typed value of a direct interface\n+// type.  Specifically, for single field struct or array, get the single\n+// field, and do this recursively.  The reason for this is that we don't\n+// want to assign a struct or an array to a pointer-typed field.  The\n+// backend may not like that.\n+\n+Expression*\n+Expression::unpack_direct_iface(Expression* rhs, Location loc)\n+{\n+  Struct_type* st = rhs->type()->struct_type();\n+  if (st != NULL)\n+    {\n+      go_assert(st->field_count() == 1);\n+      Expression* field = Expression::make_field_reference(rhs, 0, loc);\n+      return unpack_direct_iface(field, loc);\n+    }\n+  Array_type* at = rhs->type()->array_type();\n+  if (at != NULL)\n+    {\n+      int64_t len;\n+      bool ok = at->int_length(&len);\n+      go_assert(ok && len == 1);\n+      Type* int_type = Type::lookup_integer_type(\"int\");\n+      Expression* index = Expression::make_integer_ul(0, int_type, loc);\n+      Expression* elem = Expression::make_array_index(rhs, index, NULL, NULL, loc);\n+      return unpack_direct_iface(elem, loc);\n+    }\n+  return rhs;\n+}\n+\n+// The opposite of unpack_direct_iface.\n+\n+Expression*\n+Expression::pack_direct_iface(Type* t, Expression* rhs, Location loc)\n+{\n+  if (rhs->type() == t)\n+    return rhs;\n+  Struct_type* st = t->struct_type();\n+  if (st != NULL)\n+    {\n+      Expression_list* vals = new Expression_list();\n+      vals->push_back(pack_direct_iface(st->field(0)->type(), rhs, loc));\n+      return Expression::make_struct_composite_literal(t, vals, loc);\n+    }\n+  Array_type* at = t->array_type();\n+  if (at != NULL)\n+    {\n+      Expression_list* vals = new Expression_list();\n+      vals->push_back(pack_direct_iface(at->element_type(), rhs, loc));\n+      return Expression::make_array_composite_literal(t, vals, loc);\n+    }\n+  return Expression::make_unsafe_cast(t, rhs, loc);\n+}\n+\n // Return an expression for the type descriptor of RHS.\n \n Expression*\n@@ -426,9 +480,11 @@ Expression::convert_interface_to_type(Type *lhs_type, Expression* rhs,\n   Expression* obj = Expression::make_interface_info(rhs, INTERFACE_INFO_OBJECT,\n                                                     location);\n \n-  // If the value is a pointer, then it is the value we want.\n+  // If the value is a direct interface, then it is the value we want.\n   // Otherwise it points to the value.\n-  if (lhs_type->points_to() == NULL)\n+  if (lhs_type->is_direct_iface_type())\n+    obj = Expression::pack_direct_iface(lhs_type, obj, location);\n+  else\n     {\n       obj = Expression::make_unsafe_cast(Type::make_pointer_type(lhs_type), obj,\n                                          location);\n@@ -3871,16 +3927,18 @@ Unsafe_type_conversion_expression::do_get_backend(Translate_context* context)\n                 && Type::are_convertible(t, et, NULL));\n     }\n   else if (t->map_type() != NULL)\n-    go_assert(et->map_type() != NULL);\n+    go_assert(et->map_type() != NULL || et->points_to() != NULL);\n   else if (t->channel_type() != NULL)\n-    go_assert(et->channel_type() != NULL);\n+    go_assert(et->channel_type() != NULL || et->points_to() != NULL);\n   else if (t->points_to() != NULL)\n     go_assert(et->points_to() != NULL\n               || et->channel_type() != NULL\n               || et->map_type() != NULL\n               || et->function_type() != NULL\n \t      || et->integer_type() != NULL\n               || et->is_nil_type());\n+  else if (t->function_type() != NULL)\n+    go_assert(et->points_to() != NULL);\n   else if (et->is_unsafe_pointer_type())\n     go_assert(t->points_to() != NULL\n \t      || (t->integer_type() != NULL\n@@ -3899,8 +3957,6 @@ Unsafe_type_conversion_expression::do_get_backend(Translate_context* context)\n               || et->map_type() != NULL\n               || et->channel_type() != NULL\n \t      || et->is_nil_type());\n-  else if (t->function_type() != NULL)\n-    go_assert(et->points_to() != NULL);\n   else\n     go_unreachable();\n \n@@ -6723,10 +6779,10 @@ Expression::comparison(Translate_context* context, Type* result_type,\n \t}\n \n       // The right operand is not an interface.  We need to take its\n-      // address if it is not a pointer.\n+      // address if it is not a direct interface type.\n       Expression* pointer_arg = NULL;\n-      if (right_type->points_to() != NULL)\n-        pointer_arg = right;\n+      if (right_type->is_direct_iface_type())\n+        pointer_arg = Expression::unpack_direct_iface(right, location);\n       else\n \t{\n           go_assert(right->is_addressable());\n@@ -9871,11 +9927,15 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function,\n   if (bme != NULL)\n     {\n       Named_object* methodfn = bme->function();\n+      Function_type* mft = (methodfn->is_function()\n+                            ? methodfn->func_value()->type()\n+                            : methodfn->func_declaration_value()->type());\n       Expression* first_arg = bme->first_argument();\n \n-      // We always pass a pointer when calling a method.\n-      if (first_arg->type()->points_to() == NULL\n-\t  && !first_arg->type()->is_error())\n+      // We always pass a pointer when calling a method, except for\n+      // direct interface types when calling a value method.\n+      if (!first_arg->type()->is_error()\n+          && !first_arg->type()->is_direct_iface_type())\n \t{\n \t  first_arg = Expression::make_unary(OPERATOR_AND, first_arg, loc);\n \t  // We may need to create a temporary variable so that we can\n@@ -9884,6 +9944,12 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function,\n \t  Unary_expression* ue = static_cast<Unary_expression*>(first_arg);\n \t  ue->set_create_temp();\n \t}\n+      else if (mft->receiver()->type()->points_to() == NULL\n+               && first_arg->type()->points_to() != NULL\n+               && first_arg->type()->points_to()->is_direct_iface_type())\n+        first_arg = Expression::make_dereference(first_arg,\n+                                                 Expression::NIL_CHECK_DEFAULT,\n+                                                 loc);\n \n       // If we are calling a method which was inherited from an\n       // embedded struct, and the method did not get a stub, then the\n@@ -16018,11 +16084,19 @@ Interface_mtable_expression::do_get_backend(Translate_context* context)\n       else\n \tm = st->method_function(p->name(), &is_ambiguous);\n       go_assert(m != NULL);\n-      Named_object* no = m->named_object();\n+      Named_object* no =\n+        (this->is_pointer_\n+         && this->type_->is_direct_iface_type()\n+         && m->is_value_method()\n+         ? m->iface_stub_object()\n+         : m->named_object());\n \n       go_assert(no->is_function() || no->is_function_declaration());\n \n-      Btype* fcn_btype = m->type()->get_backend_fntype(gogo);\n+      Function_type* fcn_type = (no->is_function()\n+                                 ? no->func_value()->type()\n+                                 : no->func_declaration_value()->type());\n+      Btype* fcn_btype = fcn_type->get_backend_fntype(gogo);\n       Backend::Btyped_identifier bmtype(p->name(), fcn_btype, loc);\n       bstructfields.push_back(bmtype);\n "}, {"sha": "af7b00c081d38ae00005e5bdae61f46911c85ed4", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9", "patch": "@@ -1036,6 +1036,11 @@ class Expression\n   static Expression*\n   check_bounds(Expression* val, Location);\n \n+  // Return an expression for constructing a direct interface type from a\n+  // pointer.\n+  static Expression*\n+  pack_direct_iface(Type*, Expression*, Location);\n+\n   // Dump an expression to a dump constext.\n   void\n   dump_expression(Ast_dump_context*) const;\n@@ -1197,6 +1202,9 @@ class Expression\n   static Expression*\n   convert_type_to_interface(Type*, Expression*, Location);\n \n+  static Expression*\n+  unpack_direct_iface(Expression*, Location);\n+\n   static Expression*\n   get_interface_type_descriptor(Expression*);\n "}, {"sha": "f45576ee77dc0ab53d8a6e0140a65e4e3ee20cf3", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9", "patch": "@@ -6039,7 +6039,7 @@ Function::build(Gogo* gogo, Named_object* named_function)\n \t  // the receiver is declared as a non-pointer type, then we\n \t  // copy the value into a local variable.\n \t  if ((*p)->var_value()->is_receiver()\n-\t      && (*p)->var_value()->type()->points_to() == NULL)\n+\t      && !(*p)->var_value()->type()->is_direct_iface_type())\n \t    {\n \t      std::string name = (*p)->name() + \".pointer\";\n \t      Type* var_type = (*p)->var_value()->type();\n@@ -7516,7 +7516,7 @@ Variable::get_backend_variable(Gogo* gogo, Named_object* function,\n       else\n \t{\n \t  bool is_parameter = this->is_parameter_;\n-\t  if (this->is_receiver_ && type->points_to() == NULL)\n+\t  if (this->is_receiver_ && !type->is_direct_iface_type())\n \t    is_parameter = false;\n \t  if (this->is_in_heap())\n \t    {"}, {"sha": "5796d2d245f21ca51085caee8c910d8707b8ab95", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 217, "deletions": 6, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9", "patch": "@@ -2313,6 +2313,49 @@ Type::write_named_equal(Gogo* gogo, Named_type* name)\n   gogo->add_statement(s);\n }\n \n+// Return whether this type is stored directly in an interface's\n+// data word.\n+//\n+// Since finalize_methods runs before type checking, we may see a\n+// malformed type like 'type T struct { x T }'. Use a visited map\n+// to avoid infinite recursion.\n+\n+bool\n+Type::is_direct_iface_type() const\n+{\n+  Unordered_set(const Type*) visited;\n+  return this->is_direct_iface_type_helper(&visited);\n+}\n+\n+bool\n+Type::is_direct_iface_type_helper(Unordered_set(const Type*)* visited) const\n+{\n+  if (this->points_to() != NULL\n+      || this->channel_type() != NULL\n+      || this->function_type() != NULL\n+      || this->map_type() != NULL)\n+    return true;\n+\n+  std::pair<Unordered_set(const Type*)::iterator, bool> ins\n+    = visited->insert(this);\n+  if (!ins.second)\n+    // malformed circular type\n+    return false;\n+\n+  const Struct_type* st = this->struct_type();\n+  if (st != NULL)\n+    return (st->field_count() == 1\n+            && st->field(0)->type()->is_direct_iface_type_helper(visited));\n+  const Array_type* at = this->array_type();\n+  if (at != NULL && !at->is_slice_type())\n+    {\n+      int64_t len;\n+      return (at->int_length(&len) && len == 1\n+              && at->element_type()->is_direct_iface_type_helper(visited));\n+    }\n+  return false;\n+}\n+\n // Return a composite literal for the type descriptor for a plain type\n // of kind RUNTIME_TYPE_KIND named NAME.\n \n@@ -2331,7 +2374,7 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n \n   if (!this->has_pointer())\n     runtime_type_kind |= RUNTIME_TYPE_KIND_NO_POINTERS;\n-  if (this->points_to() != NULL)\n+  if (this->is_direct_iface_type())\n     runtime_type_kind |= RUNTIME_TYPE_KIND_DIRECT_IFACE;\n   int64_t ptrsize;\n   int64_t ptrdata;\n@@ -3397,9 +3440,14 @@ Type::method_constructor(Gogo*, Type* method_type,\n       vals->push_back(Expression::make_unary(OPERATOR_AND, s, bloc));\n     }\n \n-  Named_object* no = (m->needs_stub_method()\n-\t\t      ? m->stub_object()\n-\t\t      : m->named_object());\n+  Named_object* no =\n+    ((this->points_to() != NULL\n+      && this->points_to()->is_direct_iface_type()\n+      && m->is_value_method())\n+     ? m->iface_stub_object()\n+     : (m->needs_stub_method()\n+        ? m->stub_object()\n+        : m->named_object()));\n \n   Function_type* mtype;\n   if (no->is_function())\n@@ -4708,9 +4756,11 @@ Function_type::get_backend_fntype(Gogo* gogo)\n           breceiver.name = Gogo::unpack_hidden_name(this->receiver_->name());\n \n           // We always pass the address of the receiver parameter, in\n-          // order to make interface calls work with unknown types.\n+          // order to make interface calls work with unknown types,\n+          // except for direct interface types where the interface call\n+          // actually passes value.\n           Type* rtype = this->receiver_->type();\n-          if (rtype->points_to() == NULL)\n+          if (!rtype->is_direct_iface_type())\n             rtype = Type::make_pointer_type(rtype);\n           breceiver.btype = rtype->get_backend(gogo);\n           breceiver.location = this->receiver_->location();\n@@ -11020,6 +11070,8 @@ Type::finalize_methods(Gogo* gogo, const Type* type, Location location,\n       *all_methods = NULL;\n     }\n   Type::build_stub_methods(gogo, type, *all_methods, location);\n+  if (type->is_direct_iface_type())\n+    Type::build_direct_iface_stub_methods(gogo, type, *all_methods, location);\n }\n \n // Add the methods for TYPE to *METHODS.  FIELD_INDEXES is used to\n@@ -11383,6 +11435,165 @@ Type::build_one_stub_method(Gogo* gogo, Method* method,\n   gogo->add_statement(Statement::make_return_from_call(call, location));\n }\n \n+// Build direct interface stub methods for TYPE as needed.  METHODS\n+// is the set of methods for the type.  LOCATION is the location of\n+// the type definition.\n+//\n+// This is for an interface holding a pointer to the type and invoking\n+// a value method.  The interface data is the pointer, and is passed\n+// to the stub, which dereferences it and passes to the actual method.\n+\n+void\n+Type::build_direct_iface_stub_methods(Gogo* gogo, const Type* type,\n+                                      Methods* methods, Location loc)\n+{\n+  if (methods == NULL)\n+    return;\n+\n+  for (Methods::const_iterator p = methods->begin();\n+       p != methods->end();\n+       ++p)\n+    {\n+      Method* m = p->second;\n+      if (!m->is_value_method())\n+        continue;\n+\n+      Type* receiver_type = const_cast<Type*>(type);\n+      receiver_type = Type::make_pointer_type(receiver_type);\n+      const std::string& name(p->first);\n+      Function_type* fntype = m->type();\n+\n+      static unsigned int counter;\n+      char buf[100];\n+      snprintf(buf, sizeof buf, \"$ptr%u\", counter);\n+      ++counter;\n+      Typed_identifier* receiver =\n+        new Typed_identifier(buf, receiver_type, m->receiver_location());\n+\n+      const Typed_identifier_list* params = fntype->parameters();\n+      Typed_identifier_list* stub_params;\n+      if (params == NULL || params->empty())\n+        stub_params = NULL;\n+      else\n+        {\n+          // We give each stub parameter a unique name.\n+          stub_params = new Typed_identifier_list();\n+          for (Typed_identifier_list::const_iterator pp = params->begin();\n+               pp != params->end();\n+               ++pp)\n+            {\n+              char pbuf[100];\n+              snprintf(pbuf, sizeof pbuf, \"$p%u\", counter);\n+              stub_params->push_back(Typed_identifier(pbuf, pp->type(),\n+                                                      pp->location()));\n+              ++counter;\n+            }\n+        }\n+\n+      const Typed_identifier_list* fnresults = fntype->results();\n+      Typed_identifier_list* stub_results;\n+      if (fnresults == NULL || fnresults->empty())\n+        stub_results = NULL;\n+      else\n+        {\n+          // We create the result parameters without any names, since\n+          // we won't refer to them.\n+          stub_results = new Typed_identifier_list();\n+          for (Typed_identifier_list::const_iterator pr = fnresults->begin();\n+               pr != fnresults->end();\n+               ++pr)\n+            stub_results->push_back(Typed_identifier(\"\", pr->type(),\n+                                                     pr->location()));\n+        }\n+\n+      Function_type* stub_type = Type::make_function_type(receiver,\n+                                                          stub_params,\n+                                                          stub_results,\n+                                                          fntype->location());\n+      if (fntype->is_varargs())\n+        stub_type->set_is_varargs();\n+\n+      // We only create the function in the package which creates the\n+      // type.\n+      const Package* package;\n+      if (type->named_type() == NULL)\n+        package = NULL;\n+      else\n+        package = type->named_type()->named_object()->package();\n+\n+      std::string stub_name = gogo->stub_method_name(package, name) + \"2\";\n+      Named_object* stub;\n+      if (package != NULL)\n+        stub = Named_object::make_function_declaration(stub_name, package,\n+                                                       stub_type, loc);\n+      else\n+        {\n+          stub = gogo->start_function(stub_name, stub_type, false,\n+                                      fntype->location());\n+          Type::build_one_iface_stub_method(gogo, m, buf, stub_params,\n+                                            fntype->is_varargs(), loc);\n+          gogo->finish_function(fntype->location());\n+\n+          if (type->named_type() == NULL && stub->is_function())\n+            stub->func_value()->set_is_unnamed_type_stub_method();\n+          if (m->nointerface() && stub->is_function())\n+            stub->func_value()->set_nointerface();\n+        }\n+\n+      m->set_iface_stub_object(stub);\n+    }\n+}\n+\n+// Build a stub method for METHOD of direct interface type T.\n+// RECEIVER_NAME is the name we used for the receiver.\n+// PARAMS is the list of function parameters.\n+//\n+// The stub looks like\n+//\n+// func ($ptr *T, PARAMS) {\n+//   (*$ptr).METHOD(PARAMS)\n+// }\n+\n+void\n+Type::build_one_iface_stub_method(Gogo* gogo, Method* method,\n+                                  const char* receiver_name,\n+                                  const Typed_identifier_list* params,\n+                                  bool is_varargs, Location loc)\n+{\n+  Named_object* receiver_object = gogo->lookup(receiver_name, NULL);\n+  go_assert(receiver_object != NULL);\n+\n+  Expression* expr = Expression::make_var_reference(receiver_object, loc);\n+  expr = Expression::make_dereference(expr,\n+                                      Expression::NIL_CHECK_DEFAULT,\n+                                      loc);\n+\n+  Expression_list* arguments;\n+  if (params == NULL || params->empty())\n+    arguments = NULL;\n+  else\n+    {\n+      arguments = new Expression_list();\n+      for (Typed_identifier_list::const_iterator p = params->begin();\n+           p != params->end();\n+           ++p)\n+        {\n+          Named_object* param = gogo->lookup(p->name(), NULL);\n+          go_assert(param != NULL);\n+          Expression* param_ref = Expression::make_var_reference(param,\n+                                                                 loc);\n+          arguments->push_back(param_ref);\n+        }\n+    }\n+\n+  Expression* func = method->bind_method(expr, loc);\n+  go_assert(func != NULL);\n+  Call_expression* call = Expression::make_call(func, arguments, is_varargs,\n+                                                loc);\n+\n+  gogo->add_statement(Statement::make_return_from_call(call, loc));\n+}\n+\n // Apply FIELD_INDEXES to EXPR.  The field indexes have to be applied\n // in reverse order.\n "}, {"sha": "721d1fc64ac151c1e1335ae478ad26d1dad53d1f", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9", "patch": "@@ -186,6 +186,22 @@ class Method\n     this->stub_ = no;\n   }\n \n+  // Get the direct interface method stub object.\n+  Named_object*\n+  iface_stub_object() const\n+  {\n+    go_assert(this->iface_stub_ != NULL);\n+    return this->iface_stub_;\n+  }\n+\n+  // Set the direct interface method stub object.\n+  void\n+  set_iface_stub_object(Named_object* no)\n+  {\n+    go_assert(this->iface_stub_ == NULL);\n+    this->iface_stub_ = no;\n+  }\n+\n   // Return true if this method should not participate in any\n   // interfaces.\n   bool\n@@ -196,7 +212,7 @@ class Method\n   // These objects are only built by the child classes.\n   Method(const Field_indexes* field_indexes, unsigned int depth,\n \t bool is_value_method, bool needs_stub_method)\n-    : field_indexes_(field_indexes), depth_(depth), stub_(NULL),\n+    : field_indexes_(field_indexes), depth_(depth), stub_(NULL), iface_stub_(NULL),\n       is_value_method_(is_value_method), needs_stub_method_(needs_stub_method),\n       is_ambiguous_(false)\n   { }\n@@ -230,6 +246,9 @@ class Method\n   // If a stub method is required, this is its object.  This is only\n   // set after stub methods are built in finalize_methods.\n   Named_object* stub_;\n+  // Stub object for direct interface type.  This is only set after\n+  // stub methods are built in finalize_methods.\n+  Named_object* iface_stub_;\n   // Whether this is a value method--a method that does not require a\n   // pointer.\n   bool is_value_method_;\n@@ -923,6 +942,11 @@ class Type\n   is_unsafe_pointer_type() const\n   { return this->points_to() != NULL && this->points_to()->is_void_type(); }\n \n+  // Return whether this type is stored directly in an interface's\n+  // data word.\n+  bool\n+  is_direct_iface_type() const;\n+\n   // Return a version of this type with any expressions copied, but\n   // only if copying the expressions will affect the size of the type.\n   // If there are no such expressions in the type (expressions can\n@@ -1321,6 +1345,15 @@ class Type\n \t\t\tconst Typed_identifier_list*, bool is_varargs,\n \t\t\tLocation);\n \n+  // Build direct interface stub methods for a type.\n+  static void\n+  build_direct_iface_stub_methods(Gogo*, const Type*, Methods*, Location);\n+\n+  static void\n+  build_one_iface_stub_method(Gogo*, Method*, const char*,\n+                              const Typed_identifier_list*,\n+                              bool, Location);\n+\n   static Expression*\n   apply_field_indexes(Expression*, const Method::Field_indexes*,\n \t\t      Location);\n@@ -1333,6 +1366,11 @@ class Type\n \t\t       bool* is_method, bool* found_pointer_method,\n \t\t       std::string* ambig1, std::string* ambig2);\n \n+  // Helper function for is_direct_iface_type, to prevent infinite\n+  // recursion.\n+  bool\n+  is_direct_iface_type_helper(Unordered_set(const Type*)*) const;\n+\n   // Get the backend representation for a type without looking in the\n   // hash table for identical types.\n   Btype*"}, {"sha": "9452255f9a63445ff0636fc883011cf99c67ca84", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9", "patch": "@@ -4136,7 +4136,6 @@ func TestArrayOfGenericAlg(t *testing.T) {\n }\n \n func TestArrayOfDirectIface(t *testing.T) {\n-\tt.Skip(\"skipping test because gccgo uses a different directiface value\")\n \t{\n \t\ttype T [1]*byte\n \t\ti1 := Zero(TypeOf(T{})).Interface()\n@@ -4775,9 +4774,6 @@ func TestStructOfGenericAlg(t *testing.T) {\n \t}\n }\n \n-/*\n-gccgo does not use the same directiface settings as gc.\n-\n func TestStructOfDirectIface(t *testing.T) {\n \t{\n \t\ttype T struct{ X [1]*byte }\n@@ -4826,7 +4822,6 @@ func TestStructOfDirectIface(t *testing.T) {\n \t\t}\n \t}\n }\n-*/\n \n type StructI int\n "}, {"sha": "fb2e5d4b6df95819ee7cbd3079026bfe98476976", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9", "patch": "@@ -2204,7 +2204,14 @@ func StructOf(fields []StructField) Type {\n \t\ttyp.equalfn = nil\n \t}\n \n-\ttyp.kind &^= kindDirectIface\n+\tswitch {\n+\tcase len(fs) == 1 && !ifaceIndir(fs[0].typ):\n+\t\t// structs of 1 direct iface type can be direct\n+\t\ttyp.kind |= kindDirectIface\n+\tdefault:\n+\t\ttyp.kind &^= kindDirectIface\n+\t}\n+\n \ttyp.uncommonType = nil\n \ttyp.ptrToThis = nil\n \n@@ -2405,7 +2412,13 @@ func ArrayOf(count int, elem Type) Type {\n \t\tarray.ptrdata = array.size // overestimate but ok; must match program\n \t}\n \n-\tarray.kind &^= kindDirectIface\n+\tswitch {\n+\tcase count == 1 && !ifaceIndir(typ):\n+\t\t// array of 1 direct iface type can be direct\n+\t\tarray.kind |= kindDirectIface\n+\tdefault:\n+\t\tarray.kind &^= kindDirectIface\n+\t}\n \n \tesize := typ.size\n "}, {"sha": "1c3a5f3d87f23f40a71d89fcaf63f02ef6de5d4f", "filename": "libgo/go/runtime/iface.go", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/libgo%2Fgo%2Fruntime%2Fiface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/libgo%2Fgo%2Fruntime%2Fiface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fiface.go?ref=5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9", "patch": "@@ -68,10 +68,9 @@ import (\n // pointer to memory that holds the value. It follows from this that\n // kindDirectIface can only be set for a type whose representation is\n // simply a pointer. In the current gccgo implementation, this is set\n-// only for pointer types (including unsafe.Pointer). In the future it\n-// could also be set for other types: channels, maps, functions,\n-// single-field structs and single-element arrays whose single field\n-// is simply a pointer.\n+// for types that are pointer-shaped, including unsafe.Pointer, channels,\n+// maps, functions, single-field structs and single-element arrays whose\n+// single field is simply a pointer-shaped type.\n \n // For a nil interface value both fields in the interface struct are nil.\n \n@@ -458,7 +457,11 @@ func ifaceE2T2(t *_type, e eface, ret unsafe.Pointer) bool {\n \t\ttypedmemclr(t, ret)\n \t\treturn false\n \t} else {\n-\t\ttypedmemmove(t, ret, e.data)\n+\t\tif isDirectIface(t) {\n+\t\t\t*(*unsafe.Pointer)(ret) = e.data\n+\t\t} else {\n+\t\t\ttypedmemmove(t, ret, e.data)\n+\t\t}\n \t\treturn true\n \t}\n }\n@@ -469,7 +472,11 @@ func ifaceI2T2(t *_type, i iface, ret unsafe.Pointer) bool {\n \t\ttypedmemclr(t, ret)\n \t\treturn false\n \t} else {\n-\t\ttypedmemmove(t, ret, i.data)\n+\t\tif isDirectIface(t) {\n+\t\t\t*(*unsafe.Pointer)(ret) = i.data\n+\t\t} else {\n+\t\t\ttypedmemmove(t, ret, i.data)\n+\t\t}\n \t\treturn true\n \t}\n }"}, {"sha": "ef3eeb156bf5ac932622de045f27f6779141ff72", "filename": "libgo/go/runtime/pprof/proto.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/libgo%2Fgo%2Fruntime%2Fpprof%2Fproto.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/libgo%2Fgo%2Fruntime%2Fpprof%2Fproto.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fproto.go?ref=5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9", "patch": "@@ -29,7 +29,7 @@ func funcPC(f interface{}) uintptr {\n \t\tdata unsafe.Pointer\n \t}\n \ti := (*iface)(unsafe.Pointer(&f))\n-\tr := **(**uintptr)(i.data)\n+\tr := *(*uintptr)(i.data)\n \tif internalcpu.FunctionDescriptors {\n \t\t// With PPC64 ELF ABI v1 function descriptors the\n \t\t// function address is a pointer to a struct whose"}, {"sha": "8146c1d0206f7d699b22e52f7fd5417f2fb4af18", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9", "patch": "@@ -446,7 +446,7 @@ func releaseSudog(s *sudog) {\n //go:nosplit\n func funcPC(f interface{}) uintptr {\n \ti := (*iface)(unsafe.Pointer(&f))\n-\tr := **(**uintptr)(i.data)\n+\tr := *(*uintptr)(i.data)\n \tif cpu.FunctionDescriptors {\n \t\t// With PPC64 ELF ABI v1 function descriptors the\n \t\t// function address is a pointer to a struct whose"}, {"sha": "31ff4747b98a467c8c3de089d7e50f62af6eda79", "filename": "libgo/runtime/go-callers.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/libgo%2Fruntime%2Fgo-callers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9/libgo%2Fruntime%2Fgo-callers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-callers.c?ref=5e87c2806ff4e9057c4c46fa1d9c8ac91ce3dae9", "patch": "@@ -75,7 +75,7 @@ callback (void *data, uintptr_t pc, const char *filename, int lineno,\n \treturn 0;\n       if (p - function > 3 && __builtin_strcmp (p - 3, \"..r\") == 0)\n \treturn 0;\n-      if (p - function > 6 && __builtin_strcmp (p - 6, \"..stub\") == 0)\n+      if (p - function > 6 && __builtin_strncmp (p - 6, \"..stub\", 6) == 0)\n \treturn 0;\n     }\n "}]}