{"sha": "777133fefb9704c957884216e44bf7ba25ca2fae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc3MTMzZmVmYjk3MDRjOTU3ODg0MjE2ZTQ0YmY3YmEyNWNhMmZhZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-01-30T01:37:13Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-01-30T01:37:13Z"}, "message": "libgo: Update Go library to master revision 15502/229081515358.\n\nFrom-SVN: r195569", "tree": {"sha": "ac10866a1e77c784cb9d48b872fd8013ba124fd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac10866a1e77c784cb9d48b872fd8013ba124fd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/777133fefb9704c957884216e44bf7ba25ca2fae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777133fefb9704c957884216e44bf7ba25ca2fae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/777133fefb9704c957884216e44bf7ba25ca2fae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777133fefb9704c957884216e44bf7ba25ca2fae/comments", "author": null, "committer": null, "parents": [{"sha": "900f0840363c7a110723b18024b361f22b8892b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/900f0840363c7a110723b18024b361f22b8892b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/900f0840363c7a110723b18024b361f22b8892b9"}], "stats": {"total": 256, "additions": 158, "deletions": 98}, "files": [{"sha": "5cf1a26a66fa7d431800ae3f1f991b318b8d4364", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=777133fefb9704c957884216e44bf7ba25ca2fae", "patch": "@@ -1,4 +1,4 @@\n-921e53d4863c\n+229081515358\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "29dbc26d4173d889d0fb55a8854abd514708be08", "filename": "libgo/go/encoding/json/bench_test.go", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fencoding%2Fjson%2Fbench_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fencoding%2Fjson%2Fbench_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fbench_test.go?ref=777133fefb9704c957884216e44bf7ba25ca2fae", "patch": "@@ -153,5 +153,37 @@ func BenchmarkCodeUnmarshalReuse(b *testing.B) {\n \t\t\tb.Fatal(\"Unmmarshal:\", err)\n \t\t}\n \t}\n-\tb.SetBytes(int64(len(codeJSON)))\n+}\n+\n+func BenchmarkUnmarshalString(b *testing.B) {\n+\tdata := []byte(`\"hello, world\"`)\n+\tvar s string\n+\n+\tfor i := 0; i < b.N; i++ {\n+\t\tif err := Unmarshal(data, &s); err != nil {\n+\t\t\tb.Fatal(\"Unmarshal:\", err)\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkUnmarshalFloat64(b *testing.B) {\n+\tvar f float64\n+\tdata := []byte(`3.14`)\n+\n+\tfor i := 0; i < b.N; i++ {\n+\t\tif err := Unmarshal(data, &f); err != nil {\n+\t\t\tb.Fatal(\"Unmarshal:\", err)\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkUnmarshalInt64(b *testing.B) {\n+\tvar x int64\n+\tdata := []byte(`3`)\n+\n+\tfor i := 0; i < b.N; i++ {\n+\t\tif err := Unmarshal(data, &x); err != nil {\n+\t\t\tb.Fatal(\"Unmarshal:\", err)\n+\t\t}\n+\t}\n }"}, {"sha": "95e91209184aa8afd2eccb34115c7a64f3c0e4c9", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=777133fefb9704c957884216e44bf7ba25ca2fae", "patch": "@@ -52,25 +52,6 @@ import (\n // an UnmarshalTypeError describing the earliest such error.\n //\n func Unmarshal(data []byte, v interface{}) error {\n-\n-\t// skip heavy processing for primitive values\n-\tvar first byte\n-\tvar i int\n-\tfor i, first = range data {\n-\t\tif !isSpace(rune(first)) {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tif first != '{' && first != '[' {\n-\t\trv := reflect.ValueOf(v)\n-\t\tif rv.Kind() != reflect.Ptr || rv.IsNil() {\n-\t\t\treturn &InvalidUnmarshalError{reflect.TypeOf(v)}\n-\t\t}\n-\t\tvar d decodeState\n-\t\td.literalStore(data[i:], rv.Elem(), false)\n-\t\treturn d.savedError\n-\t}\n-\n \td := new(decodeState).init(data)\n \n \t// Quick check for well-formedness."}, {"sha": "a91c6da01d3c1b3b90fb20f8b85b182158c2c01c", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=777133fefb9704c957884216e44bf7ba25ca2fae", "patch": "@@ -1059,12 +1059,33 @@ func TestUnmarshalTypeError(t *testing.T) {\n \tfor _, item := range decodeTypeErrorTests {\n \t\terr := Unmarshal([]byte(item.src), item.dest)\n \t\tif _, ok := err.(*UnmarshalTypeError); !ok {\n-\t\t\tt.Errorf(\"expected type error for Unmarshal(%q, type %T): got %v instead\",\n+\t\t\tt.Errorf(\"expected type error for Unmarshal(%q, type %T): got %T\",\n \t\t\t\titem.src, item.dest, err)\n \t\t}\n \t}\n }\n \n+var unmarshalSyntaxTests = []string{\n+\t\"tru\",\n+\t\"fals\",\n+\t\"nul\",\n+\t\"123e\",\n+\t`\"hello`,\n+\t`[1,2,3`,\n+\t`{\"key\":1`,\n+\t`{\"key\":1,`,\n+}\n+\n+func TestUnmarshalSyntax(t *testing.T) {\n+\tvar x interface{}\n+\tfor _, src := range unmarshalSyntaxTests {\n+\t\terr := Unmarshal([]byte(src), &x)\n+\t\tif _, ok := err.(*SyntaxError); !ok {\n+\t\t\tt.Errorf(\"expected syntax error for Unmarshal(%q): got %T\", src, err)\n+\t\t}\n+\t}\n+}\n+\n // Test handling of unexported fields that should be ignored.\n // Issue 4660\n type unexportedFields struct {"}, {"sha": "00f4726cf7f6dce09cbda73c271eeea1babad756", "filename": "libgo/go/encoding/json/stream.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fencoding%2Fjson%2Fstream.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fencoding%2Fjson%2Fstream.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fstream.go?ref=777133fefb9704c957884216e44bf7ba25ca2fae", "patch": "@@ -5,6 +5,7 @@\n package json\n \n import (\n+\t\"bytes\"\n \t\"errors\"\n \t\"io\"\n )\n@@ -58,6 +59,12 @@ func (dec *Decoder) Decode(v interface{}) error {\n \treturn err\n }\n \n+// Buffered returns a reader of the data remaining in the Decoder's\n+// buffer. The reader is valid until the next call to Decode.\n+func (dec *Decoder) Buffered() io.Reader {\n+\treturn bytes.NewReader(dec.buf)\n+}\n+\n // readValue reads a JSON value into dec.buf.\n // It returns the length of the encoding.\n func (dec *Decoder) readValue() (int, error) {"}, {"sha": "07c9e1d390c68db75a19a88a120d60e981594387", "filename": "libgo/go/encoding/json/stream_test.go", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go?ref=777133fefb9704c957884216e44bf7ba25ca2fae", "patch": "@@ -6,8 +6,10 @@ package json\n \n import (\n \t\"bytes\"\n+\t\"io/ioutil\"\n \t\"net\"\n \t\"reflect\"\n+\t\"strings\"\n \t\"testing\"\n )\n \n@@ -83,6 +85,28 @@ func TestDecoder(t *testing.T) {\n \t}\n }\n \n+func TestDecoderBuffered(t *testing.T) {\n+\tr := strings.NewReader(`{\"Name\": \"Gopher\"} extra `)\n+\tvar m struct {\n+\t\tName string\n+\t}\n+\td := NewDecoder(r)\n+\terr := d.Decode(&m)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif m.Name != \"Gopher\" {\n+\t\tt.Errorf(\"Name = %q; want Gopher\", m.Name)\n+\t}\n+\trest, err := ioutil.ReadAll(d.Buffered())\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif g, w := string(rest), \" extra \"; g != w {\n+\t\tt.Errorf(\"Remaining = %q; want %q\", g, w)\n+\t}\n+}\n+\n func nlines(s string, n int) string {\n \tif n <= 0 {\n \t\treturn \"\""}, {"sha": "a81be6aefe8476714bf88f83bdcbb756e6f26f62", "filename": "libgo/go/exp/ssa/blockopt.go", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fexp%2Fssa%2Fblockopt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fexp%2Fssa%2Fblockopt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssa%2Fblockopt.go?ref=777133fefb9704c957884216e44bf7ba25ca2fae", "patch": "@@ -5,10 +5,6 @@ package ssa\n // TODO(adonovan): instead of creating several \"unreachable\" blocks\n // per function in the Builder, reuse a single one (e.g. at Blocks[1])\n // to reduce garbage.\n-//\n-// TODO(adonovan): in the absence of multiway branch instructions,\n-// each BasicBlock has 0, 1, or 2 successors.  We should preallocate\n-// the backing array for the Succs slice inline in BasicBlock.\n \n import (\n \t\"fmt\"\n@@ -117,7 +113,7 @@ func fuseBlocks(f *Function, a *BasicBlock) bool {\n \t}\n \n \t// A inherits B's successors\n-\ta.Succs = b.Succs\n+\ta.Succs = append(a.succs2[:0], b.Succs...)\n \n \t// Fix up Preds links of all successors of B.\n \tfor _, c := range b.Succs {"}, {"sha": "6af5e1efcd5495dc4e3640cd38664d1cdcfadf6f", "filename": "libgo/go/exp/ssa/func.go", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fexp%2Fssa%2Ffunc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fexp%2Fssa%2Ffunc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssa%2Ffunc.go?ref=777133fefb9704c957884216e44bf7ba25ca2fae", "patch": "@@ -151,16 +151,27 @@ func (f *Function) labelledBlock(label *ast.Ident) *lblock {\n func (f *Function) addParam(name string, typ types.Type) *Parameter {\n \tv := &Parameter{\n \t\tName_: name,\n-\t\tType_: pointer(typ), // address of param\n+\t\tType_: typ,\n \t}\n \tf.Params = append(f.Params, v)\n \treturn v\n }\n \n-func (f *Function) addObjParam(obj types.Object) *Parameter {\n-\tp := f.addParam(obj.GetName(), obj.GetType())\n-\tf.objects[obj] = p\n-\treturn p\n+// addSpilledParam declares a parameter that is pre-spilled to the\n+// stack; the function body will load/store the spilled location.\n+// Subsequent registerization will eliminate spills where possible.\n+//\n+func (f *Function) addSpilledParam(obj types.Object) {\n+\tname := obj.GetName()\n+\tparam := f.addParam(name, obj.GetType())\n+\tspill := &Alloc{\n+\t\tName_: name + \"~\", // \"~\" means \"spilled\"\n+\t\tType_: pointer(obj.GetType()),\n+\t}\n+\tf.objects[obj] = spill\n+\tf.Locals = append(f.Locals, spill)\n+\tf.emit(spill)\n+\tf.emit(&Store{Addr: spill, Val: param})\n }\n \n // start initializes the function prior to generating SSA code for its body.\n@@ -186,7 +197,7 @@ func (f *Function) start(mode BuilderMode, idents map[*ast.Ident]types.Object) {\n \tif f.syntax.recvField != nil {\n \t\tfor _, field := range f.syntax.recvField.List {\n \t\t\tfor _, n := range field.Names {\n-\t\t\t\tf.addObjParam(idents[n])\n+\t\t\t\tf.addSpilledParam(idents[n])\n \t\t\t}\n \t\t\tif field.Names == nil {\n \t\t\t\tf.addParam(f.Signature.Recv.Name, f.Signature.Recv.Type)\n@@ -198,7 +209,7 @@ func (f *Function) start(mode BuilderMode, idents map[*ast.Ident]types.Object) {\n \tif f.syntax.paramFields != nil {\n \t\tfor _, field := range f.syntax.paramFields.List {\n \t\t\tfor _, n := range field.Names {\n-\t\t\t\tf.addObjParam(idents[n])\n+\t\t\t\tf.addSpilledParam(idents[n])\n \t\t\t}\n \t\t}\n \t}\n@@ -300,18 +311,18 @@ func (f *Function) addLocal(typ types.Type) *Alloc {\n func (f *Function) lookup(obj types.Object, escaping bool) Value {\n \tif v, ok := f.objects[obj]; ok {\n \t\tif escaping {\n-\t\t\tswitch v := v.(type) {\n-\t\t\tcase *Capture:\n-\t\t\t\t// TODO(adonovan): fix: we must support this case.\n-\t\t\t\t// Requires copying to a 'new' Alloc.\n-\t\t\t\tfmt.Fprintln(os.Stderr, \"Error: escaping reference to Capture\")\n-\t\t\tcase *Parameter:\n-\t\t\t\tv.Heap = true\n-\t\t\tcase *Alloc:\n-\t\t\t\tv.Heap = true\n-\t\t\tdefault:\n-\t\t\t\tpanic(fmt.Sprintf(\"Unexpected Function.objects kind: %T\", v))\n+\t\t\t// Walk up the chain of Captures.\n+\t\t\tx := v\n+\t\t\tfor {\n+\t\t\t\tif c, ok := x.(*Capture); ok {\n+\t\t\t\t\tx = c.Outer\n+\t\t\t\t} else {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n \t\t\t}\n+\t\t\t// By construction, all captures are ultimately Allocs in the\n+\t\t\t// naive SSA form.  Parameters are pre-spilled to the stack.\n+\t\t\tx.(*Alloc).Heap = true\n \t\t}\n \t\treturn v // function-local var (address)\n \t}\n@@ -340,7 +351,7 @@ func (f *Function) emit(instr Instruction) Value {\n func (f *Function) DumpTo(w io.Writer) {\n \tfmt.Fprintf(w, \"# Name: %s\\n\", f.FullName())\n \tfmt.Fprintf(w, \"# Declared at %s\\n\", f.Prog.Files.Position(f.Pos))\n-\tfmt.Fprintf(w, \"# Type: %s\\n\", f.Type())\n+\tfmt.Fprintf(w, \"# Type: %s\\n\", f.Signature)\n \n \tif f.Enclosing != nil {\n \t\tfmt.Fprintf(w, \"# Parent: %s\\n\", f.Enclosing.Name())\n@@ -411,6 +422,7 @@ func (f *Function) newBasicBlock(name string) *BasicBlock {\n \t\tName: fmt.Sprintf(\"%d.%s\", len(f.Blocks), name),\n \t\tFunc: f,\n \t}\n+\tb.Succs = b.succs2[:0]\n \tf.Blocks = append(f.Blocks, b)\n \treturn b\n }"}, {"sha": "eb0f7fc0b07904dee3fa9a801cd8116f8f2291bd", "filename": "libgo/go/exp/ssa/ssa.go", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fexp%2Fssa%2Fssa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fexp%2Fssa%2Fssa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssa%2Fssa.go?ref=777133fefb9704c957884216e44bf7ba25ca2fae", "patch": "@@ -246,42 +246,30 @@ type Function struct {\n // instructions, respectively).\n //\n type BasicBlock struct {\n-\tName         string        // label; no semantic significance\n-\tFunc         *Function     // containing function\n-\tInstrs       []Instruction // instructions in order\n-\tPreds, Succs []*BasicBlock // predecessors and successors\n+\tName         string         // label; no semantic significance\n+\tFunc         *Function      // containing function\n+\tInstrs       []Instruction  // instructions in order\n+\tPreds, Succs []*BasicBlock  // predecessors and successors\n+\tsuccs2       [2]*BasicBlock // initial space for Succs.\n }\n \n // Pure values ----------------------------------------\n \n // A Capture is a pointer to a lexically enclosing local variable.\n //\n-// The referent of a capture is a Parameter, Alloc or another Capture\n-// and is always considered potentially escaping, so Captures are\n-// always addresses in the heap, and have pointer types.\n+// The referent of a capture is an Alloc or another Capture and is\n+// always considered potentially escaping, so Captures are always\n+// addresses in the heap, and have pointer types.\n //\n type Capture struct {\n \tOuter Value // the Value captured from the enclosing context.\n }\n \n // A Parameter represents an input parameter of a function.\n //\n-// Parameters are addresses and thus have pointer types.\n-// TODO(adonovan): this will change.  We should just spill parameters\n-// to ordinary Alloc-style locals if they are ever used in an\n-// addressable context.  Then we can lose the Heap flag.\n-//\n-// In the common case where Heap=false, Parameters are pointers into\n-// the function's stack frame.  If the case where Heap=true because a\n-// parameter's address may escape from its function, Parameters are\n-// pointers into a space in the heap implicitly allocated during the\n-// function call.  (See also Alloc, which uses the Heap flag in a\n-// similar manner.)\n-//\n type Parameter struct {\n \tName_ string\n-\tType_ *types.Pointer\n-\tHeap  bool\n+\tType_ types.Type\n }\n \n // A Literal represents a literal nil, boolean, string or numeric"}, {"sha": "e2a47a556a70bc14cec8c93f2334a449a78a91f5", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=777133fefb9704c957884216e44bf7ba25ca2fae", "patch": "@@ -321,13 +321,7 @@ func (p *Package) IsCommand() bool {\n // ImportDir is like Import but processes the Go package found in\n // the named directory.\n func (ctxt *Context) ImportDir(dir string, mode ImportMode) (*Package, error) {\n-\tp, err := ctxt.Import(\".\", dir, mode)\n-\t// TODO(rsc,adg): breaks godoc net/http. Not sure why.\n-\t// See CL 7232047 and issue 4696.\n-\tif false && err == nil && !ctxt.isDir(p.Dir) {\n-\t\terr = fmt.Errorf(\"%q is not a directory\", p.Dir)\n-\t}\n-\treturn p, err\n+\treturn ctxt.Import(\".\", dir, mode)\n }\n \n // NoGoError is the error used by Import to describe a directory"}, {"sha": "d8cf98840d71f33ec435ce2f3cf2d13699661294", "filename": "libgo/go/go/build/build_test.go", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go?ref=777133fefb9704c957884216e44bf7ba25ca2fae", "patch": "@@ -5,7 +5,6 @@\n package build\n \n import (\n-\t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"runtime\"\n@@ -90,17 +89,6 @@ func TestLocalDirectory(t *testing.T) {\n \t}\n }\n \n-// golang.org/issue/3248\n-func TestBogusDirectory(t *testing.T) {\n-\treturn // See issue 4696.\n-\tconst dir = \"/foo/bar/baz/gopher\"\n-\t_, err := ImportDir(dir, FindOnly)\n-\twant := fmt.Sprintf(\"%q is not a directory\", filepath.FromSlash(dir))\n-\tif err == nil || err.Error() != want {\n-\t\tt.Errorf(\"got error %q, want %q\", err, want)\n-\t}\n-}\n-\n func TestShouldBuild(t *testing.T) {\n \tconst file1 = \"// +build tag1\\n\\n\" +\n \t\t\"package main\\n\""}, {"sha": "30a5ed91c447fa86887257daf01d8ba38c836c55", "filename": "libgo/runtime/go-traceback.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fruntime%2Fgo-traceback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fruntime%2Fgo-traceback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-traceback.c?ref=777133fefb9704c957884216e44bf7ba25ca2fae", "patch": "@@ -17,11 +17,11 @@ runtime_traceback ()\n   int32 c;\n \n   c = runtime_callers (1, pcbuf, sizeof pcbuf / sizeof pcbuf[0]);\n-  runtime_printtrace (pcbuf, c);\n+  runtime_printtrace (pcbuf, c, true);\n }\n \n void\n-runtime_printtrace (uintptr *pcbuf, int32 c)\n+runtime_printtrace (uintptr *pcbuf, int32 c, bool current)\n {\n   int32 i;\n \n@@ -32,7 +32,7 @@ runtime_printtrace (uintptr *pcbuf, int32 c)\n       intgo line;\n \n       if (__go_file_line (pcbuf[i], &fn, &file, &line)\n-\t  && runtime_showframe (fn))\n+\t  && runtime_showframe (fn, current))\n \t{\n \t  runtime_printf (\"%S\\n\", fn);\n \t  runtime_printf (\"\\t%S:%D\\n\", file, (int64) line);"}, {"sha": "7b9b578e46c1ebce1b1f7ed45d2e0f1b9436f45f", "filename": "libgo/runtime/panic.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fruntime%2Fpanic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fruntime%2Fpanic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fpanic.c?ref=777133fefb9704c957884216e44bf7ba25ca2fae", "patch": "@@ -86,6 +86,11 @@ runtime_dopanic(int32 unused __attribute__ ((unused)))\n void\n runtime_throw(const char *s)\n {\n+\tM *mp;\n+\n+\tmp = runtime_m();\n+\tif(mp->throwing == 0)\n+\t\tmp->throwing = 1;\n \truntime_startpanic();\n \truntime_printf(\"fatal error: %s\\n\", s);\n \truntime_dopanic(0);"}, {"sha": "b2e37f3915025ae57b873a1a9fafec50369e1b56", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=777133fefb9704c957884216e44bf7ba25ca2fae", "patch": "@@ -528,6 +528,7 @@ runtime_main(void)\n \tsetmcpumax(runtime_gomaxprocs);\n \truntime_sched.init = true;\n \tscvg = __go_go(runtime_MHeap_Scavenger, nil);\n+\tscvg->issystem = true;\n \tmain_init();\n \truntime_sched.init = false;\n \tif(!runtime_sched.lockmain)\n@@ -638,12 +639,16 @@ void\n runtime_tracebackothers(G * volatile me)\n {\n \tG * volatile gp;\n-\tTraceback traceback;\n+\tTraceback tb;\n+\tint32 traceback;\n \n-\ttraceback.gp = me;\n+\ttb.gp = me;\n+\ttraceback = runtime_gotraceback();\n \tfor(gp = runtime_allg; gp != nil; gp = gp->alllink) {\n \t\tif(gp == me || gp->status == Gdead)\n \t\t\tcontinue;\n+\t\tif(gp->issystem && traceback < 2)\n+\t\t\tcontinue;\n \t\truntime_printf(\"\\n\");\n \t\truntime_goroutineheader(gp);\n \n@@ -661,7 +666,7 @@ runtime_tracebackothers(G * volatile me)\n \t\t\tcontinue;\n \t\t}\n \n-\t\tgp->traceback = &traceback;\n+\t\tgp->traceback = &tb;\n \n #ifdef USING_SPLIT_STACK\n \t\t__splitstack_getcontext(&me->stack_context[0]);\n@@ -672,7 +677,7 @@ runtime_tracebackothers(G * volatile me)\n \t\t\truntime_gogo(gp);\n \t\t}\n \n-\t\truntime_printtrace(traceback.pcbuf, traceback.c);\n+\t\truntime_printtrace(tb.pcbuf, tb.c, false);\n \t\truntime_goroutinetrailer(gp);\n \t}\n }\n@@ -975,6 +980,7 @@ nextgandunlock(void)\n \tif((scvg == nil && runtime_sched.grunning == 0) ||\n \t   (scvg != nil && runtime_sched.grunning == 1 && runtime_sched.gwait == 0 &&\n \t    (scvg->status == Grunning || scvg->status == Gsyscall))) {\n+\t\tm->throwing = -1;  // do not dump full stacks\n \t\truntime_throw(\"all goroutines are asleep - deadlock!\");\n \t}\n "}, {"sha": "48ece55d18e1e778109416bd0e6950dfeec4b93a", "filename": "libgo/runtime/runtime.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fruntime%2Fruntime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fruntime%2Fruntime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.c?ref=777133fefb9704c957884216e44bf7ba25ca2fae", "patch": "@@ -132,10 +132,12 @@ runtime_cputicks(void)\n }\n \n bool\n-runtime_showframe(String s)\n+runtime_showframe(String s, bool current)\n {\n \tstatic int32 traceback = -1;\n-\t\n+\n+\tif(current && runtime_m()->throwing > 0)\n+\t\treturn 1;\n \tif(traceback < 0)\n \t\ttraceback = runtime_gotraceback();\n \treturn traceback > 1 || (__builtin_memchr(s.str, '.', s.len) != nil && __builtin_memcmp(s.str, \"runtime.\", 7) != 0);"}, {"sha": "de72f42bc55f58fdb7d57a025aa4efcbf83fa91d", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=777133fefb9704c957884216e44bf7ba25ca2fae", "patch": "@@ -178,6 +178,7 @@ struct\tG\n \tG*\tschedlink;\n \tbool\treadyonstop;\n \tbool\tispanic;\n+\tbool\tissystem;\n \tint8\traceignore; // ignore race detection events\n \tM*\tm;\t\t// for debuggers, but offset not hard-coded\n \tM*\tlockedm;\n@@ -208,6 +209,7 @@ struct\tM\n \tG*\tcurg;\t\t// current running goroutine\n \tint32\tid;\n \tint32\tmallocing;\n+\tint32\tthrowing;\n \tint32\tgcing;\n \tint32\tlocks;\n \tint32\tnomemprof;\n@@ -389,7 +391,7 @@ void\truntime_goroutineheader(G*);\n void\truntime_goroutinetrailer(G*);\n void\truntime_traceback();\n void\truntime_tracebackothers(G*);\n-void\truntime_printtrace(uintptr*, int32);\n+void\truntime_printtrace(uintptr*, int32, bool);\n String\truntime_gostringnocopy(const byte*);\n void*\truntime_mstart(void*);\n G*\truntime_malg(int32, byte**, size_t*);\n@@ -593,7 +595,7 @@ void\truntime_osyield(void);\n void\truntime_LockOSThread(void) __asm__ (GOSYM_PREFIX \"runtime.LockOSThread\");\n void\truntime_UnlockOSThread(void) __asm__ (GOSYM_PREFIX \"runtime.UnlockOSThread\");\n \n-bool\truntime_showframe(String);\n+bool\truntime_showframe(String, bool);\n \n uintptr\truntime_memlimit(void);\n "}, {"sha": "9a5cbdfed3b8a3b4db7128ce6249f6bc74e52978", "filename": "libgo/runtime/time.goc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fruntime%2Ftime.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777133fefb9704c957884216e44bf7ba25ca2fae/libgo%2Fruntime%2Ftime.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Ftime.goc?ref=777133fefb9704c957884216e44bf7ba25ca2fae", "patch": "@@ -110,8 +110,10 @@ addtimer(Timer *t)\n \t\t\truntime_ready(timers.timerproc);\n \t\t}\n \t}\n-\tif(timers.timerproc == nil)\n+\tif(timers.timerproc == nil) {\n \t\ttimers.timerproc = __go_go(timerproc, nil);\n+\t\ttimers.timerproc->issystem = true;\n+\t}\n }\n \n // Delete timer t from the heap."}]}