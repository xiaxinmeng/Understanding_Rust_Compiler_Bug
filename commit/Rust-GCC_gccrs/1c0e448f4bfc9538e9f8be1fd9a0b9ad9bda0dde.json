{"sha": "1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWMwZTQ0OGY0YmZjOTUzOGU5ZjhiZTFmZDlhMGI5YWQ5YmRhMGRkZQ==", "commit": {"author": {"name": "David Sherwood", "email": "david.sherwood@arm.com", "date": "2015-07-28T20:31:17Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-07-28T20:31:17Z"}, "message": "arm.c (neon_element_bits, [...]): Call GET_MODE_INNER unconditionally.\n\ngcc/\n2015-07-28  David Sherwood  <david.sherwood@arm.com>\n\n\t* config/arm/arm.c (neon_element_bits, neon_valid_immediate): Call\n\tGET_MODE_INNER unconditionally.\n\t* config/spu/spu.c (arith_immediate_p): Likewise.\n\t* config/i386/i386.c (ix86_build_signbit_mask): Likewise.\n\t* expmed.c (synth_mult): Remove check for VOIDmode result from\n\tGET_MODE_INNER.\n\t(expand_mult_const): Likewise.\n\t* fold-const.c (fold_binary_loc): Replace call to element_precision\n\twith call to GET_MODE_PRECISION.\n\t* genmodes.c (emit_mode_inner_inline): Replace void_mode->name with\n\tm->name.\n\t(emit_mode_inner): Likewise.\n\t* lto-streamer-out.c (lto_write_mode_table): Update GET_MODE_INNER\n\tresult check.\n\t* machmode.h (GET_MODE_UNIT_SIZE): Simplify.\n\t(GET_MODE_UNIT_PRECISION): Likewise.\n\t* rtlanal.c (subreg_get_info): Call GET_MODE_INNER unconditionally.\n\t* simplify-rtx.c (simplify_immed_subreg): Likewise.\n\t* stor-layout.c (bitwise_type_for_mode): Update assert.\n\t(element_precision): Remove.\n\nFrom-SVN: r226328", "tree": {"sha": "d215dd29e4cf213704a2c9a5dbe053e8d2c8665d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d215dd29e4cf213704a2c9a5dbe053e8d2c8665d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/comments", "author": {"login": "david-arm", "id": 57997763, "node_id": "MDQ6VXNlcjU3OTk3NzYz", "avatar_url": "https://avatars.githubusercontent.com/u/57997763?v=4", "gravatar_id": "", "url": "https://api.github.com/users/david-arm", "html_url": "https://github.com/david-arm", "followers_url": "https://api.github.com/users/david-arm/followers", "following_url": "https://api.github.com/users/david-arm/following{/other_user}", "gists_url": "https://api.github.com/users/david-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/david-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/david-arm/subscriptions", "organizations_url": "https://api.github.com/users/david-arm/orgs", "repos_url": "https://api.github.com/users/david-arm/repos", "events_url": "https://api.github.com/users/david-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/david-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "726858e30955b401a568f397e22c60062a9f57a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/726858e30955b401a568f397e22c60062a9f57a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/726858e30955b401a568f397e22c60062a9f57a3"}], "stats": {"total": 114, "additions": 49, "deletions": 65}, "files": [{"sha": "c3f78dd21d102e56e565ed1cc52c642fddfdc1be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde", "patch": "@@ -1,3 +1,26 @@\n+2015-07-28  David Sherwood  <david.sherwood@arm.com>\n+\n+\t* config/arm/arm.c (neon_element_bits, neon_valid_immediate): Call\n+\tGET_MODE_INNER unconditionally.\n+\t* config/spu/spu.c (arith_immediate_p): Likewise.\n+\t* config/i386/i386.c (ix86_build_signbit_mask): Likewise.\n+\t* expmed.c (synth_mult): Remove check for VOIDmode result from\n+\tGET_MODE_INNER.\n+\t(expand_mult_const): Likewise.\n+\t* fold-const.c (fold_binary_loc): Replace call to element_precision\n+\twith call to GET_MODE_PRECISION.\n+\t* genmodes.c (emit_mode_inner_inline): Replace void_mode->name with\n+\tm->name.\n+\t(emit_mode_inner): Likewise.\n+\t* lto-streamer-out.c (lto_write_mode_table): Update GET_MODE_INNER\n+\tresult check.\n+\t* machmode.h (GET_MODE_UNIT_SIZE): Simplify.\n+\t(GET_MODE_UNIT_PRECISION): Likewise.\n+\t* rtlanal.c (subreg_get_info): Call GET_MODE_INNER unconditionally.\n+\t* simplify-rtx.c (simplify_immed_subreg): Likewise.\n+\t* stor-layout.c (bitwise_type_for_mode): Update assert.\n+\t(element_precision): Remove.\n+\n 2015-07-28  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* target-insns.def (reload_load_address): New targetm instruction"}, {"sha": "723d27e4cbf429aa60a2e7fdd88c8cebcfad4521", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde", "patch": "@@ -12238,18 +12238,16 @@ neon_valid_immediate (rtx op, machine_mode mode, int inverse,\n   bool vector = GET_CODE (op) == CONST_VECTOR;\n \n   if (vector)\n-    {\n-      n_elts = CONST_VECTOR_NUNITS (op);\n-      innersize = GET_MODE_SIZE (GET_MODE_INNER (mode));\n-    }\n+    n_elts = CONST_VECTOR_NUNITS (op);\n   else\n     {\n       n_elts = 1;\n       if (mode == VOIDmode)\n \tmode = DImode;\n-      innersize = GET_MODE_SIZE (mode);\n     }\n \n+  innersize = GET_MODE_SIZE (GET_MODE_INNER (mode));\n+\n   /* Vectors of float constants.  */\n   if (GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n     {\n@@ -12832,10 +12830,7 @@ neon_const_bounds (rtx operand, HOST_WIDE_INT low, HOST_WIDE_INT high)\n HOST_WIDE_INT\n neon_element_bits (machine_mode mode)\n {\n-  if (mode == DImode)\n-    return GET_MODE_BITSIZE (mode);\n-  else\n-    return GET_MODE_BITSIZE (GET_MODE_INNER (mode));\n+  return GET_MODE_BITSIZE (GET_MODE_INNER (mode));\n }\n \n \f"}, {"sha": "4a2c57b983b62d5e514caed6b925b5c30d44bbae", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde", "patch": "@@ -19599,7 +19599,6 @@ ix86_build_signbit_mask (machine_mode mode, bool vect, bool invert)\n     case V8SFmode:\n     case V4SFmode:\n       vec_mode = mode;\n-      mode = GET_MODE_INNER (mode);\n       imode = SImode;\n       break;\n \n@@ -19610,7 +19609,6 @@ ix86_build_signbit_mask (machine_mode mode, bool vect, bool invert)\n     case V4DFmode:\n     case V2DFmode:\n       vec_mode = mode;\n-      mode = GET_MODE_INNER (mode);\n       imode = DImode;\n       break;\n \n@@ -19624,17 +19622,18 @@ ix86_build_signbit_mask (machine_mode mode, bool vect, bool invert)\n       gcc_unreachable ();\n     }\n \n-  w = wi::set_bit_in_zero (GET_MODE_BITSIZE (mode) - 1,\n-\t\t\t   GET_MODE_BITSIZE (mode));\n+  machine_mode inner_mode = GET_MODE_INNER (mode);\n+  w = wi::set_bit_in_zero (GET_MODE_BITSIZE (inner_mode) - 1,\n+\t\t\t   GET_MODE_BITSIZE (inner_mode));\n   if (invert)\n     w = wi::bit_not (w);\n \n   /* Force this value into the low part of a fp vector constant.  */\n   mask = immed_wide_int_const (w, imode);\n-  mask = gen_lowpart (mode, mask);\n+  mask = gen_lowpart (inner_mode, mask);\n \n   if (vec_mode == VOIDmode)\n-    return force_reg (mode, mask);\n+    return force_reg (inner_mode, mask);\n \n   v = ix86_build_const_vector (vec_mode, vect, mask);\n   return force_reg (vec_mode, v);"}, {"sha": "68840f51dc3daa3072eae55c13cce14da6fa6416", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde", "patch": "@@ -3391,9 +3391,7 @@ arith_immediate_p (rtx op, machine_mode mode,\n \n   constant_to_array (mode, op, arr);\n \n-  if (VECTOR_MODE_P (mode))\n-    mode = GET_MODE_INNER (mode);\n-\n+  mode = GET_MODE_INNER (mode);\n   bytes = GET_MODE_SIZE (mode);\n   mode = mode_for_size (GET_MODE_BITSIZE (mode), MODE_INT, 0);\n "}, {"sha": "3c70cdece38aff9bfe90f5f9c11438e81b766a37", "filename": "gcc/expmed.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde", "patch": "@@ -2427,8 +2427,6 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \n   /* Be prepared for vector modes.  */\n   imode = GET_MODE_INNER (mode);\n-  if (imode == VOIDmode)\n-    imode = mode;\n \n   maxm = MIN (BITS_PER_WORD, GET_MODE_BITSIZE (imode));\n \n@@ -3088,8 +3086,6 @@ expand_mult_const (machine_mode mode, rtx op0, HOST_WIDE_INT val,\n   /* Compare only the bits of val and val_so_far that are significant\n      in the result mode, to avoid sign-/zero-extension confusion.  */\n   nmode = GET_MODE_INNER (mode);\n-  if (nmode == VOIDmode)\n-    nmode = mode;\n   val &= GET_MODE_MASK (nmode);\n   val_so_far &= GET_MODE_MASK (nmode);\n   gcc_assert (val == val_so_far);"}, {"sha": "7f54ca2fe5175072f5591d6ba9044840ce9d6842", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde", "patch": "@@ -9421,7 +9421,7 @@ fold_binary_loc (location_t loc,\n \t    /* Only create rotates in complete modes.  Other cases are not\n \t       expanded properly.  */\n \t    && (element_precision (rtype)\n-\t\t== element_precision (TYPE_MODE (rtype))))\n+\t\t== GET_MODE_PRECISION (GET_MODE_INNER (TYPE_MODE (rtype)))))\n \t  {\n \t    tree tree01, tree11;\n \t    enum tree_code code01, code11;"}, {"sha": "f4db427ffe3365346a22b4f53ef9c2cd6bc59060", "filename": "gcc/genmodes.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde", "patch": "@@ -1039,7 +1039,7 @@ mode_inner_inline (machine_mode mode)\\n\\\n   for_all_modes (c, m)\n     printf (\"    case %smode: return %smode;\\n\", m->name,\n \t    c != MODE_PARTIAL_INT && m->component\n-\t    ? m->component->name : void_mode->name);\n+\t    ? m->component->name : m->name);\n \n   puts (\"\\\n     default: return mode_inner[mode];\\n\\\n@@ -1338,7 +1338,7 @@ emit_mode_inner (void)\n   for_all_modes (c, m)\n     tagged_printf (\"%smode\",\n \t\t   c != MODE_PARTIAL_INT && m->component\n-\t\t   ? m->component->name : void_mode->name,\n+\t\t   ? m->component->name : m->name,\n \t\t   m->name);\n \n   print_closer ();"}, {"sha": "1b88115b2c98fe54282a221a706cb76f454eaf35", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde", "patch": "@@ -2682,7 +2682,7 @@ lto_write_mode_table (void)\n     if (streamer_mode_table[i])\n       {\n \tmachine_mode m = (machine_mode) i;\n-\tif (GET_MODE_INNER (m) != VOIDmode)\n+\tif (GET_MODE_INNER (m) != m)\n \t  streamer_mode_table[(int) GET_MODE_INNER (m)] = 1;\n       }\n   /* First stream modes that have GET_MODE_INNER (m) == VOIDmode,\n@@ -2692,7 +2692,7 @@ lto_write_mode_table (void)\n       if (streamer_mode_table[i] && i != (int) VOIDmode && i != (int) BLKmode)\n \t{\n \t  machine_mode m = (machine_mode) i;\n-\t  if ((GET_MODE_INNER (m) == VOIDmode) ^ (pass == 0))\n+\t  if ((GET_MODE_INNER (m) == m) ^ (pass == 0))\n \t    continue;\n \t  bp_pack_value (&bp, m, 8);\n \t  bp_pack_enum (&bp, mode_class, MAX_MODE_CLASS, GET_MODE_CLASS (m));"}, {"sha": "6575517d132b0cf8ff9f572f3bd0b1287bd63231", "filename": "gcc/machmode.h", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde", "patch": "@@ -209,7 +209,9 @@ extern const unsigned HOST_WIDE_INT mode_mask_array[NUM_MACHINE_MODES];\n \n #define GET_MODE_MASK(MODE) mode_mask_array[MODE]\n \n-/* Return the mode of the inner elements in a vector.  */\n+/* Return the mode of the basic parts of MODE.  For vector modes this is the\n+   mode of the vector elements.  For complex modes it is the mode of the real\n+   and imaginary parts.  For other modes it is MODE itself.  */\n \n extern const unsigned char mode_inner[NUM_MACHINE_MODES];\n #if GCC_VERSION >= 4001\n@@ -220,21 +222,15 @@ extern const unsigned char mode_inner[NUM_MACHINE_MODES];\n #define GET_MODE_INNER(MODE) ((machine_mode) mode_inner[MODE])\n #endif\n \n-/* Get the size in bytes or bites of the basic parts of an\n+/* Get the size in bytes or bits of the basic parts of an\n    object of mode MODE.  */\n \n-#define GET_MODE_UNIT_SIZE(MODE)\t\t\\\n-  (GET_MODE_INNER (MODE) == VOIDmode\t\t\\\n-   ? GET_MODE_SIZE (MODE)\t\t\t\\\n-   : GET_MODE_SIZE (GET_MODE_INNER (MODE)))\n+#define GET_MODE_UNIT_SIZE(MODE) GET_MODE_SIZE (GET_MODE_INNER (MODE))\n \n #define GET_MODE_UNIT_BITSIZE(MODE) \\\n   ((unsigned short) (GET_MODE_UNIT_SIZE (MODE) * BITS_PER_UNIT))\n \n-#define GET_MODE_UNIT_PRECISION(MODE)\t\t\\\n-  (GET_MODE_INNER (MODE) == VOIDmode\t\t\\\n-   ? GET_MODE_PRECISION (MODE)\t\t\t\\\n-   : GET_MODE_PRECISION (GET_MODE_INNER (MODE)))\n+#define GET_MODE_UNIT_PRECISION(MODE) GET_MODE_PRECISION (GET_MODE_INNER (MODE))\n \n /* Get the number of units in the object.  */\n \n@@ -320,10 +316,6 @@ extern unsigned get_mode_alignment (machine_mode);\n \n #define GET_MODE_ALIGNMENT(MODE) get_mode_alignment (MODE)\n \n-/* Get the precision of the mode or its inner mode if it has one.  */\n-\n-extern unsigned int element_precision (machine_mode);\n-\n /* For each class, get the narrowest mode in that class.  */\n \n extern const unsigned char class_narrowest_mode[MAX_MODE_CLASS];"}, {"sha": "ef98f4bfb5cea1a825ae82cd3b08c3a7518318ab", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde", "patch": "@@ -3571,10 +3571,7 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n       machine_mode xmode_unit;\n \n       nregs_xmode = HARD_REGNO_NREGS_WITH_PADDING (xregno, xmode);\n-      if (GET_MODE_INNER (xmode) == VOIDmode)\n-\txmode_unit = xmode;\n-      else\n-\txmode_unit = GET_MODE_INNER (xmode);\n+      xmode_unit = GET_MODE_INNER (xmode);\n       gcc_assert (HARD_REGNO_NREGS_HAS_PADDING (xregno, xmode_unit));\n       gcc_assert (nregs_xmode\n \t\t  == (GET_MODE_NUNITS (xmode)"}, {"sha": "1a717cc1f27c76c11af9787d18c951a7b8bba398", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde", "patch": "@@ -5650,21 +5650,17 @@ simplify_immed_subreg (machine_mode outermode, rtx op,\n   value_start = byte * (BITS_PER_UNIT / value_bit);\n \n   /* Re-pack the value.  */\n+  num_elem = GET_MODE_NUNITS (outermode);\n \n   if (VECTOR_MODE_P (outermode))\n     {\n-      num_elem = GET_MODE_NUNITS (outermode);\n       result_v = rtvec_alloc (num_elem);\n       elems = &RTVEC_ELT (result_v, 0);\n-      outer_submode = GET_MODE_INNER (outermode);\n     }\n   else\n-    {\n-      num_elem = 1;\n-      elems = &result_s;\n-      outer_submode = outermode;\n-    }\n+    elems = &result_s;\n \n+  outer_submode = GET_MODE_INNER (outermode);\n   outer_class = GET_MODE_CLASS (outer_submode);\n   elem_bitsize = GET_MODE_BITSIZE (outer_submode);\n "}, {"sha": "9757777db66c26695f10d25b141a03d11c016c00", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=1c0e448f4bfc9538e9f8be1fd9a0b9ad9bda0dde", "patch": "@@ -491,7 +491,7 @@ bitwise_type_for_mode (machine_mode mode)\n   if (COMPLEX_MODE_P (mode))\n     return build_complex_type (inner_type);\n \n-  gcc_checking_assert (GET_MODE_INNER (mode) == VOIDmode);\n+  gcc_checking_assert (GET_MODE_INNER (mode) == mode);\n   return inner_type;\n }\n \n@@ -548,18 +548,6 @@ get_mode_alignment (machine_mode mode)\n   return MIN (BIGGEST_ALIGNMENT, MAX (1, mode_base_align[mode]*BITS_PER_UNIT));\n }\n \n-/* Return the precision of the mode, or for a complex or vector mode the\n-   precision of the mode of its elements.  */\n-\n-unsigned int\n-element_precision (machine_mode mode)\n-{\n-  if (COMPLEX_MODE_P (mode) || VECTOR_MODE_P (mode))\n-    mode = GET_MODE_INNER (mode);\n-\n-  return GET_MODE_PRECISION (mode);\n-}\n-\n /* Return the natural mode of an array, given that it is SIZE bytes in\n    total and has elements of type ELEM_TYPE.  */\n "}]}