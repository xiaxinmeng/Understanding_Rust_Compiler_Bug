{"sha": "bef5d8b61f6732bec53128324913bfa8a5093a07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVmNWQ4YjYxZjY3MzJiZWM1MzEyODMyNDkxM2JmYThhNTA5M2EwNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-11-24T18:50:26Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-11-24T18:50:26Z"}, "message": "optabs.h (force_expand_binop): Declare.\n\n\t* optabs.h (force_expand_binop): Declare.\n\t* optabs.c (force_expand_binop): Export.\n\t* stmt.c (shift_return_value): Delete.\n\t(expand_return): Don't call it.\n\t* expr.h (shift_return_value): Declare.\n\t* calls.c (shift_returned_value): Delete in favor of...\n\t(shift_return_value): ...this new function.  Leave the caller to check\n\tfor non-BLKmode values passed in the msb of a register.  Take said mode\n\tand a shift direction as argument.  Operate on the hard function value,\n\tnot a pseudo.\n\t(expand_call): Adjust accordingly.\n\t* function.c (expand_function_start): If a non-BLKmode return value\n\tis padded at the last significant end of the return register, use the\n\treturn value's natural mode for the DECL_RESULT, not the mode of the\n\tpadded register.\n\t(expand_function_end): Shift the same sort of return values left by\n\tthe appropriate amount.\n\nFrom-SVN: r91187", "tree": {"sha": "b60ced5605459fa37b62bcb5a6c1cced24e7b3fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b60ced5605459fa37b62bcb5a6c1cced24e7b3fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bef5d8b61f6732bec53128324913bfa8a5093a07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bef5d8b61f6732bec53128324913bfa8a5093a07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bef5d8b61f6732bec53128324913bfa8a5093a07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bef5d8b61f6732bec53128324913bfa8a5093a07/comments", "author": null, "committer": null, "parents": [{"sha": "6e2993bf5b71c17c2b60e0dec787750f44925e66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e2993bf5b71c17c2b60e0dec787750f44925e66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e2993bf5b71c17c2b60e0dec787750f44925e66"}], "stats": {"total": 192, "additions": 110, "deletions": 82}, "files": [{"sha": "3b2def722cca148ec6527fe90e03c67a0f193904", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef5d8b61f6732bec53128324913bfa8a5093a07/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef5d8b61f6732bec53128324913bfa8a5093a07/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bef5d8b61f6732bec53128324913bfa8a5093a07", "patch": "@@ -1,3 +1,23 @@\n+2004-11-24  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* optabs.h (force_expand_binop): Declare.\n+\t* optabs.c (force_expand_binop): Export.\n+\t* stmt.c (shift_return_value): Delete.\n+\t(expand_return): Don't call it.\n+\t* expr.h (shift_return_value): Declare.\n+\t* calls.c (shift_returned_value): Delete in favor of...\n+\t(shift_return_value): ...this new function.  Leave the caller to check\n+\tfor non-BLKmode values passed in the msb of a register.  Take said mode\n+\tand a shift direction as argument.  Operate on the hard function value,\n+\tnot a pseudo.\n+\t(expand_call): Adjust accordingly.\n+\t* function.c (expand_function_start): If a non-BLKmode return value\n+\tis padded at the last significant end of the return register, use the\n+\treturn value's natural mode for the DECL_RESULT, not the mode of the\n+\tpadded register.\n+\t(expand_function_end): Shift the same sort of return values left by\n+\tthe appropriate amount.\n+\n 2004-11-24  Matt Austern  <austern@apple.com>\n \n \t* recog.c (recog_memoized_1): Remove."}, {"sha": "3c4d13e9dada9f375d8aef8226b4e91bbafa9b70", "filename": "gcc/calls.c", "status": "modified", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef5d8b61f6732bec53128324913bfa8a5093a07/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef5d8b61f6732bec53128324913bfa8a5093a07/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=bef5d8b61f6732bec53128324913bfa8a5093a07", "patch": "@@ -147,7 +147,6 @@ static int check_sibcall_argument_overlap (rtx, struct arg_data *, int);\n \n static int combine_pending_stack_adjustment_and_call (int, struct args_size *,\n \t\t\t\t\t\t      unsigned int);\n-static bool shift_returned_value (tree, rtx *);\n static tree split_complex_values (tree);\n static tree split_complex_types (tree);\n \n@@ -1715,39 +1714,27 @@ check_sibcall_argument_overlap (rtx insn, struct arg_data *arg, int mark_stored_\n   return insn != NULL_RTX;\n }\n \n-/* If function value *VALUE was returned at the most significant end of a\n-   register, shift it towards the least significant end and convert it to\n-   TYPE's mode.  Return true and update *VALUE if some action was needed.\n+/* Given that a function returns a value of mode MODE at the most\n+   significant end of hard register VALUE, shift VALUE left or right\n+   as specified by LEFT_P.  Return true if some action was needed.  */\n \n-   TYPE is the type of the function's return value, which is known not\n-   to have mode BLKmode.  */\n-\n-static bool\n-shift_returned_value (tree type, rtx *value)\n+bool\n+shift_return_value (enum machine_mode mode, bool left_p, rtx value)\n {\n-  if (targetm.calls.return_in_msb (type))\n-    {\n-      HOST_WIDE_INT shift;\n+  HOST_WIDE_INT shift;\n \n-      shift = (GET_MODE_BITSIZE (GET_MODE (*value))\n-\t       - BITS_PER_UNIT * int_size_in_bytes (type));\n-      if (shift > 0)\n-\t{\n-\t  /* Shift the value into the low part of the register.  */\n-\t  *value = expand_binop (GET_MODE (*value), lshr_optab, *value,\n-\t\t\t\t GEN_INT (shift), 0, 1, OPTAB_WIDEN);\n-\n-\t  /* Truncate it to the type's mode, or its integer equivalent.\n-\t     This is subject to TRULY_NOOP_TRUNCATION.  */\n-\t  *value = convert_to_mode (int_mode_for_mode (TYPE_MODE (type)),\n-\t\t\t\t    *value, 0);\n-\n-\t  /* Now convert it to the final form.  */\n-\t  *value = gen_lowpart (TYPE_MODE (type), *value);\n-\t  return true;\n-\t}\n-    }\n-  return false;\n+  gcc_assert (REG_P (value) && HARD_REGISTER_P (value));\n+  shift = GET_MODE_BITSIZE (GET_MODE (value)) - GET_MODE_BITSIZE (mode);\n+  if (shift == 0)\n+    return false;\n+\n+  /* Use ashr rather than lshr for right shifts.  This is for the benefit\n+     of the MIPS port, which requires SImode values to be sign-extended\n+     when stored in 64-bit registers.  */\n+  if (!force_expand_binop (GET_MODE (value), left_p ? ashl_optab : ashr_optab,\n+\t\t\t   value, GEN_INT (shift), value, 1, OPTAB_WIDEN))\n+    gcc_unreachable ();\n+  return true;\n }\n \n /* Remove all REG_EQUIV notes found in the insn chain.  */\n@@ -2660,6 +2647,20 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t   next_arg_reg, valreg, old_inhibit_defer_pop, call_fusage,\n \t\t   flags, & args_so_far);\n \n+      /* If a non-BLKmode value is returned at the most significant end\n+\t of a register, shift the register right by the appropriate amount\n+\t and update VALREG accordingly.  BLKmode values are handled by the\n+\t group load/store machinery below.  */\n+      if (!structure_value_addr\n+\t  && !pcc_struct_value\n+\t  && TYPE_MODE (TREE_TYPE (exp)) != BLKmode\n+\t  && targetm.calls.return_in_msb (TREE_TYPE (exp)))\n+\t{\n+\t  if (shift_return_value (TYPE_MODE (TREE_TYPE (exp)), false, valreg))\n+\t    sibcall_failure = 1;\n+\t  valreg = gen_rtx_REG (TYPE_MODE (TREE_TYPE (exp)), REGNO (valreg));\n+\t}\n+\n       /* If call is cse'able, make appropriate pair of reg-notes around it.\n \t Test valreg so we don't crash; may safely ignore `const'\n \t if return type is void.  Disable for PARALLEL return values, because\n@@ -2851,12 +2852,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t  sibcall_failure = 1;\n \t}\n       else\n-\t{\n-\t  if (shift_returned_value (TREE_TYPE (exp), &valreg))\n-\t    sibcall_failure = 1;\n-\n-\t  target = copy_to_reg (valreg);\n-\t}\n+\ttarget = copy_to_reg (valreg);\n \n       if (targetm.calls.promote_function_return(funtype))\n \t{"}, {"sha": "780ad4dfdd48a6367b996b15074c8597c61b9072", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef5d8b61f6732bec53128324913bfa8a5093a07/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef5d8b61f6732bec53128324913bfa8a5093a07/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=bef5d8b61f6732bec53128324913bfa8a5093a07", "patch": "@@ -551,6 +551,8 @@ extern rtx hard_function_value (tree, tree, int);\n \n extern rtx prepare_call_address (rtx, rtx, rtx *, int, int);\n \n+extern bool shift_return_value (enum machine_mode, bool, rtx);\n+\n extern rtx expand_call (tree, rtx, int);\n \n extern void fixup_tail_calls (void);"}, {"sha": "1021fc2ecf39e9389d41d474bfadf2eb6bf4308e", "filename": "gcc/function.c", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef5d8b61f6732bec53128324913bfa8a5093a07/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef5d8b61f6732bec53128324913bfa8a5093a07/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=bef5d8b61f6732bec53128324913bfa8a5093a07", "patch": "@@ -4059,22 +4059,31 @@ expand_function_start (tree subr)\n     {\n       /* Compute the return values into a pseudo reg, which we will copy\n \t into the true return register after the cleanups are done.  */\n-\n-      /* In order to figure out what mode to use for the pseudo, we\n-\t figure out what the mode of the eventual return register will\n-\t actually be, and use that.  */\n-      rtx hard_reg\n-\t= hard_function_value (TREE_TYPE (DECL_RESULT (subr)),\n-\t\t\t       subr, 1);\n-\n-      /* Structures that are returned in registers are not aggregate_value_p,\n-\t so we may see a PARALLEL or a REG.  */\n-      if (REG_P (hard_reg))\n-\tSET_DECL_RTL (DECL_RESULT (subr), gen_reg_rtx (GET_MODE (hard_reg)));\n+      tree return_type = TREE_TYPE (DECL_RESULT (subr));\n+      if (TYPE_MODE (return_type) != BLKmode\n+\t  && targetm.calls.return_in_msb (return_type))\n+\t/* expand_function_end will insert the appropriate padding in\n+\t   this case.  Use the return value's natural (unpadded) mode\n+\t   within the function proper.  */\n+\tSET_DECL_RTL (DECL_RESULT (subr),\n+\t\t      gen_reg_rtx (TYPE_MODE (return_type)));\n       else\n \t{\n-\t  gcc_assert (GET_CODE (hard_reg) == PARALLEL);\n-\t  SET_DECL_RTL (DECL_RESULT (subr), gen_group_rtx (hard_reg));\n+\t  /* In order to figure out what mode to use for the pseudo, we\n+\t     figure out what the mode of the eventual return register will\n+\t     actually be, and use that.  */\n+\t  rtx hard_reg = hard_function_value (return_type, subr, 1);\n+\n+\t  /* Structures that are returned in registers are not\n+\t     aggregate_value_p, so we may see a PARALLEL or a REG.  */\n+\t  if (REG_P (hard_reg))\n+\t    SET_DECL_RTL (DECL_RESULT (subr),\n+\t\t\t  gen_reg_rtx (GET_MODE (hard_reg)));\n+\t  else\n+\t    {\n+\t      gcc_assert (GET_CODE (hard_reg) == PARALLEL);\n+\t      SET_DECL_RTL (DECL_RESULT (subr), gen_group_rtx (hard_reg));\n+\t    }\n \t}\n \n       /* Set DECL_REGISTER flag so that expand_function_end will copy the\n@@ -4368,10 +4377,22 @@ expand_function_end (void)\n \t  if (GET_MODE (real_decl_rtl) == BLKmode)\n \t    PUT_MODE (real_decl_rtl, GET_MODE (decl_rtl));\n \n+\t  /* If a non-BLKmode return value should be padded at the least\n+\t     significant end of the register, shift it left by the appropriate\n+\t     amount.  BLKmode results are handled using the group load/store\n+\t     machinery.  */\n+\t  if (TYPE_MODE (TREE_TYPE (decl_result)) != BLKmode\n+\t      && targetm.calls.return_in_msb (TREE_TYPE (decl_result)))\n+\t    {\n+\t      emit_move_insn (gen_rtx_REG (GET_MODE (decl_rtl),\n+\t\t\t\t\t   REGNO (real_decl_rtl)),\n+\t\t\t      decl_rtl);\n+\t      shift_return_value (GET_MODE (decl_rtl), true, real_decl_rtl);\n+\t    }\n \t  /* If a named return value dumped decl_return to memory, then\n \t     we may need to re-do the PROMOTE_MODE signed/unsigned\n \t     extension.  */\n-\t  if (GET_MODE (real_decl_rtl) != GET_MODE (decl_rtl))\n+\t  else if (GET_MODE (real_decl_rtl) != GET_MODE (decl_rtl))\n \t    {\n \t      int unsignedp = TYPE_UNSIGNED (TREE_TYPE (decl_result));\n "}, {"sha": "14f2b72350c4339bd1212229e2a88ab8f9c08b9c", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef5d8b61f6732bec53128324913bfa8a5093a07/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef5d8b61f6732bec53128324913bfa8a5093a07/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=bef5d8b61f6732bec53128324913bfa8a5093a07", "patch": "@@ -427,7 +427,7 @@ simplify_expand_binop (enum machine_mode mode, optab binoptab,\n /* Like simplify_expand_binop, but always put the result in TARGET.\n    Return true if the expansion succeeded.  */\n \n-static bool\n+bool\n force_expand_binop (enum machine_mode mode, optab binoptab,\n \t\t    rtx op0, rtx op1, rtx target, int unsignedp,\n \t\t    enum optab_methods methods)"}, {"sha": "76ec8dea2c802055396a0e1e8ca88b8450d874e3", "filename": "gcc/optabs.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef5d8b61f6732bec53128324913bfa8a5093a07/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef5d8b61f6732bec53128324913bfa8a5093a07/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=bef5d8b61f6732bec53128324913bfa8a5093a07", "patch": "@@ -425,6 +425,9 @@ extern rtx expand_ternary_op (enum machine_mode mode, optab ternary_optab,\n extern rtx expand_binop (enum machine_mode, optab, rtx, rtx, rtx, int,\n \t\t\t enum optab_methods);\n \n+extern bool force_expand_binop (enum machine_mode, optab, rtx, rtx, rtx, int,\n+\t\t\t\tenum optab_methods);\n+\n /* Expand a binary operation with both signed and unsigned forms.  */\n extern rtx sign_expand_binop (enum machine_mode, optab, optab, rtx, rtx,\n \t\t\t      rtx, int, enum optab_methods);"}, {"sha": "e22ae5aca166d10972f42e5ebe00b8fbfa6bd9b8", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef5d8b61f6732bec53128324913bfa8a5093a07/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef5d8b61f6732bec53128324913bfa8a5093a07/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=bef5d8b61f6732bec53128324913bfa8a5093a07", "patch": "@@ -110,7 +110,6 @@ static bool check_operand_nalternatives (tree, tree);\n static bool check_unique_operand_names (tree, tree);\n static char *resolve_operand_name_1 (char *, tree, tree);\n static void expand_null_return_1 (void);\n-static rtx shift_return_value (rtx);\n static void expand_value_return (rtx);\n static void do_jump_if_equal (rtx, rtx, rtx, int);\n static int estimate_case_costs (case_node_ptr);\n@@ -1500,33 +1499,6 @@ expand_naked_return (void)\n   emit_jump (end_label);\n }\n \n-/* If the current function returns values in the most significant part\n-   of a register, shift return value VAL appropriately.  The mode of\n-   the function's return type is known not to be BLKmode.  */\n-\n-static rtx\n-shift_return_value (rtx val)\n-{\n-  tree type;\n-\n-  type = TREE_TYPE (DECL_RESULT (current_function_decl));\n-  if (targetm.calls.return_in_msb (type))\n-    {\n-      rtx target;\n-      HOST_WIDE_INT shift;\n-\n-      target = DECL_RTL (DECL_RESULT (current_function_decl));\n-      shift = (GET_MODE_BITSIZE (GET_MODE (target))\n-\t       - BITS_PER_UNIT * int_size_in_bytes (type));\n-      if (shift > 0)\n-\tval = expand_shift (LSHIFT_EXPR, GET_MODE (target),\n-\t\t\t    gen_lowpart (GET_MODE (target), val),\n-\t\t\t    build_int_cst (NULL_TREE, shift), target, 1);\n-    }\n-  return val;\n-}\n-\n-\n /* Generate RTL to return from the current function, with value VAL.  */\n \n static void\n@@ -1737,7 +1709,7 @@ expand_return (tree retval)\n       val = expand_expr (retval_rhs, val, GET_MODE (val), 0);\n       val = force_not_mem (val);\n       /* Return the calculated value.  */\n-      expand_value_return (shift_return_value (val));\n+      expand_value_return (val);\n     }\n   else\n     {"}, {"sha": "25f2f13d62c3f42a26a3f8740b5c616189861ebd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef5d8b61f6732bec53128324913bfa8a5093a07/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef5d8b61f6732bec53128324913bfa8a5093a07/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bef5d8b61f6732bec53128324913bfa8a5093a07", "patch": "@@ -1,3 +1,7 @@\n+2004-11-24  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* gcc.c-torture/execute/20041124-1.c: New test.\n+\n 2004-11-24  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/template/deduce3.C: New test. "}, {"sha": "51ce2536ea9c4c06393d11332d8e5b2a1cf18151", "filename": "gcc/testsuite/gcc.c-torture/execute/20041124-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef5d8b61f6732bec53128324913bfa8a5093a07/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20041124-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef5d8b61f6732bec53128324913bfa8a5093a07/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20041124-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20041124-1.c?ref=bef5d8b61f6732bec53128324913bfa8a5093a07", "patch": "@@ -0,0 +1,10 @@\n+struct s { _Complex unsigned short x; };\n+struct s gs = { 100 + 200i };\n+struct s __attribute__((noinline)) foo (void) { return gs; }\n+\n+int main ()\n+{\n+  if (foo ().x != gs.x)\n+    abort ();\n+  exit (0);\n+}"}]}