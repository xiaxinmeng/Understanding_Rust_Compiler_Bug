{"sha": "06a103af0e61d634e1fa730a1865eb4e98748e72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZhMTAzYWYwZTYxZDYzNGUxZmE3MzBhMTg2NWViNGU5ODc0OGU3Mg==", "commit": {"author": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-04-06T02:08:27Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-04-06T02:08:27Z"}, "message": "dependency.c (get_no_elements): Delete function.\n\n\n\t* dependency.c (get_no_elements): Delete function.\n\t(get_deps): Delete function.\n\t(transform_sections): Delete function.\n\t(gfc_check_section_vs_section): Significant rewrite.\n\n\t* gfortran.dg/dependency_18.f90: New test case.\n\nFrom-SVN: r112731", "tree": {"sha": "8c11b67feff461e4f32143d851c423f06c54b719", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c11b67feff461e4f32143d851c423f06c54b719"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06a103af0e61d634e1fa730a1865eb4e98748e72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06a103af0e61d634e1fa730a1865eb4e98748e72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06a103af0e61d634e1fa730a1865eb4e98748e72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06a103af0e61d634e1fa730a1865eb4e98748e72/comments", "author": null, "committer": null, "parents": [{"sha": "0f681872e02f455fe4b6956175d9ba45c38cccf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f681872e02f455fe4b6956175d9ba45c38cccf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f681872e02f455fe4b6956175d9ba45c38cccf5"}], "stats": {"total": 291, "additions": 165, "deletions": 126}, "files": [{"sha": "e6db2efe197a99cd389dbb54920f38c53ff99b7a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06a103af0e61d634e1fa730a1865eb4e98748e72/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06a103af0e61d634e1fa730a1865eb4e98748e72/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=06a103af0e61d634e1fa730a1865eb4e98748e72", "patch": "@@ -1,3 +1,10 @@\n+2006-04-05  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* dependency.c (get_no_elements): Delete function.\n+\t(get_deps): Delete function.\n+\t(transform_sections): Delete function.\n+\t(gfc_check_section_vs_section): Significant rewrite.\n+\n 2006-04-04  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR fortran/25619\n@@ -11,15 +18,15 @@\n 2006-04-03  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/26891\n-\t* trans.h : Prototype for gfc_conv_missing_dummy.\n+\t* trans.h: Prototype for gfc_conv_missing_dummy.\n \t* trans-expr (gfc_conv_missing_dummy): New function\n \t(gfc_conv_function_call): Call it and tidy up some of the code.\n \t* trans-intrinsic (gfc_conv_intrinsic_function_args): The same.\n \n \tPR fortran/26976\n \t* array.c (gfc_array_dimen_size): If available, return shape[dimen].\n-\t* resolve.c (resolve_function): If available, use the argument shape for the\n-\tfunction expression.\n+\t* resolve.c (resolve_function): If available, use the argument\n+\tshape for the function expression.\n \t* iresolve.c (gfc_resolve_transfer): Set shape[0] = size.\n \n 2006-04-02  Erik Edelmann  <eedelman@gcc.gnu.org>\n@@ -64,7 +71,7 @@\n 2006-03-31  Asher Langton  <langton2@llnl.gov>\n \n \tPR fortran/25358\n-\t*expr.c (gfc_check_assign): Allow cray pointee to be assumes-size.\n+\t* expr.c (gfc_check_assign): Allow cray pointee to be assumes-size.\n \t\n 2006-03-30  Paul Thomas <paulthomas2@wanadoo.fr>\n             Bud Davis  <bdavis9659@sbcglobal.net>\n@@ -90,7 +97,7 @@\n 2006-03-28 Paul Thomas <pault@gcc.gnu.org>\n \n \tPR fortran/26779\n-\t*resolve.c (resolve_fl_procedure): Do not check the access of\n+\t* resolve.c (resolve_fl_procedure): Do not check the access of\n \tderived types for internal procedures.\n \n 2006-03-27  Jakub Jelinek  <jakub@redhat.com>"}, {"sha": "4634c1fd37cea9a119718125eb69cab496b61997", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 129, "deletions": 121, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06a103af0e61d634e1fa730a1865eb4e98748e72/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06a103af0e61d634e1fa730a1865eb4e98748e72/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=06a103af0e61d634e1fa730a1865eb4e98748e72", "patch": "@@ -1,5 +1,5 @@\n /* Dependency analysis\n-   Copyright (C) 2000, 2001, 2002, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2005, 2006 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n This file is part of GCC.\n@@ -702,118 +702,26 @@ gfc_check_dependency (gfc_expr * expr1, gfc_expr * expr2, bool identical)\n }\n \n \n-/* Calculates size of the array reference using lower bound, upper bound\n-   and stride.  */\n-\n-static void\n-get_no_of_elements(mpz_t ele, gfc_expr * u1, gfc_expr * l1, gfc_expr * s1)\n-{\n-  /* nNoOfEle = (u1-l1)/s1  */\n-\n-  mpz_sub (ele, u1->value.integer, l1->value.integer);\n-\n-  if (s1 != NULL)\n-    mpz_tdiv_q (ele, ele, s1->value.integer);\n-}\n-\n-\n-/* Returns if the ranges ((0..Y), (X1..X2))  overlap.  */\n-\n-static gfc_dependency\n-get_deps (mpz_t x1, mpz_t x2, mpz_t y)\n-{\n-  int start;\n-  int end;\n-\n-  start = mpz_cmp_ui (x1, 0);\n-  end = mpz_cmp (x2, y);\n-  \n-  /* Both ranges the same.  */\n-  if (start == 0 && end == 0)\n-    return GFC_DEP_EQUAL;\n-\n-  /* Distinct ranges.  */\n-  if ((start < 0 && mpz_cmp_ui (x2, 0) < 0)\n-      || (mpz_cmp (x1, y) > 0 && end > 0))\n-    return GFC_DEP_NODEP;\n-\n-  /* Overlapping, but with corresponding elements of the second range\n-     greater than the first.  */\n-  if (start > 0 && end > 0)\n-    return GFC_DEP_FORWARD;\n-\n-  /* Overlapping in some other way.  */\n-  return GFC_DEP_OVERLAP;\n-}\n-\n-\n-/* Perform the same linear transformation on sections l and r such that \n-   (l_start:l_end:l_stride) -> (0:no_of_elements)\n-   (r_start:r_end:r_stride) -> (X1:X2)\n-   Where r_end is implicit as both sections must have the same number of\n-   elements.\n-   Returns 0 on success, 1 of the transformation failed.  */\n-/* TODO: Should this be (0:no_of_elements-1) */\n-\n-static int\n-transform_sections (mpz_t X1, mpz_t X2, mpz_t no_of_elements,\n-\t\t    gfc_expr * l_start, gfc_expr * l_end, gfc_expr * l_stride,\n-\t\t    gfc_expr * r_start, gfc_expr * r_stride)\n-{\n-  if (NULL == l_start || NULL == l_end || NULL == r_start)\n-    return 1;\n-\n-  /* TODO : Currently we check the dependency only when start, end and stride\n-    are constant.  We could also check for equal (variable) values, and\n-    common subexpressions, eg. x vs. x+1.  */\n-\n-  if (l_end->expr_type != EXPR_CONSTANT\n-      || l_start->expr_type != EXPR_CONSTANT\n-      || r_start->expr_type != EXPR_CONSTANT\n-      || ((NULL != l_stride) && (l_stride->expr_type != EXPR_CONSTANT))\n-      || ((NULL != r_stride) && (r_stride->expr_type != EXPR_CONSTANT)))\n-    {\n-       return 1;\n-    }\n-\n-\n-  get_no_of_elements (no_of_elements, l_end, l_start, l_stride);\n-\n-  mpz_sub (X1, r_start->value.integer, l_start->value.integer);\n-  if (l_stride != NULL)\n-    mpz_cdiv_q (X1, X1, l_stride->value.integer);\n-  \n-  if (r_stride == NULL)\n-    mpz_set (X2, no_of_elements);\n-  else\n-    mpz_mul (X2, no_of_elements, r_stride->value.integer);\n-\n-  if (l_stride != NULL)\n-    mpz_cdiv_q (X2, X2, l_stride->value.integer);\n-  mpz_add (X2, X2, X1);\n-\n-  return 0;\n-}\n-  \n-\n /* Determines overlapping for two array sections.  */\n \n static gfc_dependency\n gfc_check_section_vs_section (gfc_ref * lref, gfc_ref * rref, int n)\n {\n+  gfc_array_ref l_ar;\n   gfc_expr *l_start;\n   gfc_expr *l_end;\n   gfc_expr *l_stride;\n+  gfc_expr *l_lower;\n+  gfc_expr *l_upper;\n+  int l_dir;\n \n+  gfc_array_ref r_ar;\n   gfc_expr *r_start;\n+  gfc_expr *r_end;\n   gfc_expr *r_stride;\n-\n-  gfc_array_ref l_ar;\n-  gfc_array_ref r_ar;\n-\n-  mpz_t no_of_elements;\n-  mpz_t X1, X2;\n-  gfc_dependency dep;\n+  gfc_expr *r_lower;\n+  gfc_expr *r_upper;\n+  int r_dir;\n \n   l_ar = lref->u.ar;\n   r_ar = rref->u.ar;\n@@ -825,36 +733,136 @@ gfc_check_section_vs_section (gfc_ref * lref, gfc_ref * rref, int n)\n   l_start = l_ar.start[n];\n   l_end = l_ar.end[n];\n   l_stride = l_ar.stride[n];\n+\n   r_start = r_ar.start[n];\n+  r_end = r_ar.end[n];\n   r_stride = r_ar.stride[n];\n \n-  /* if l_start is NULL take it from array specifier  */\n-  if (NULL == l_start && IS_ARRAY_EXPLICIT(l_ar.as))\n+  /* If l_start is NULL take it from array specifier.  */\n+  if (NULL == l_start && IS_ARRAY_EXPLICIT (l_ar.as))\n     l_start = l_ar.as->lower[n];\n-\n-  /* if l_end is NULL take it from array specifier  */\n-  if (NULL == l_end && IS_ARRAY_EXPLICIT(l_ar.as))\n+  /* If l_end is NULL take it from array specifier.  */\n+  if (NULL == l_end && IS_ARRAY_EXPLICIT (l_ar.as))\n     l_end = l_ar.as->upper[n];\n \n-  /* if r_start is NULL take it from array specifier  */\n-  if (NULL == r_start && IS_ARRAY_EXPLICIT(r_ar.as))\n+  /* If r_start is NULL take it from array specifier.  */\n+  if (NULL == r_start && IS_ARRAY_EXPLICIT (r_ar.as))\n     r_start = r_ar.as->lower[n];\n+  /* If r_end is NULL take it from array specifier.  */\n+  if (NULL == r_end && IS_ARRAY_EXPLICIT (r_ar.as))\n+    r_end = r_ar.as->upper[n];\n+\n+  /* Determine whether the l_stride is positive or negative.  */\n+  if (!l_stride)\n+    l_dir = 1;\n+  else if (l_stride->expr_type == EXPR_CONSTANT\n+           && l_stride->ts.type == BT_INTEGER)\n+    l_dir = mpz_sgn (l_stride->value.integer);\n+  else if (l_start && l_end)\n+    l_dir = gfc_dep_compare_expr (l_end, l_start);\n+  else\n+    l_dir = -2;\n+\n+  /* Determine whether the r_stride is positive or negative.  */\n+  if (!r_stride)\n+    r_dir = 1;\n+  else if (r_stride->expr_type == EXPR_CONSTANT\n+           && r_stride->ts.type == BT_INTEGER)\n+    r_dir = mpz_sgn (r_stride->value.integer);\n+  else if (r_start && r_end)\n+    r_dir = gfc_dep_compare_expr (r_end, r_start);\n+  else\n+    r_dir = -2;\n+\n+  /* The strides should never be zero.  */\n+  if (l_dir == 0 || r_dir == 0)\n+    return GFC_DEP_OVERLAP;\n \n-  mpz_init (X1);\n-  mpz_init (X2);\n-  mpz_init (no_of_elements);\n+  /* Determine LHS upper and lower bounds.  */\n+  if (l_dir == 1)\n+    {\n+      l_lower = l_start;\n+      l_upper = l_end;\n+    }\n+  else if (l_dir == -1)\n+    {\n+      l_lower = l_end;\n+      l_upper = l_start;\n+    }\n+  else\n+    {\n+      l_lower = NULL;\n+      l_upper = NULL;\n+    }\n \n-  if (transform_sections (X1, X2, no_of_elements,\n-\t\t\t  l_start, l_end, l_stride,\n-\t\t\t  r_start, r_stride))\n-    dep = GFC_DEP_OVERLAP;\n+  /* Determine RHS upper and lower bounds.  */\n+  if (r_dir == 1)\n+    {\n+      r_lower = r_start;\n+      r_upper = r_end;\n+    }\n+  else if (r_dir == -1)\n+    {\n+      r_lower = r_end;\n+      r_upper = r_start;\n+    }\n   else\n-    dep =  get_deps (X1, X2, no_of_elements);\n+    {\n+      r_lower = NULL;\n+      r_upper = NULL;\n+    }\n+\n+  /* Check whether the ranges are disjoint.  */\n+  if (l_upper && r_lower && gfc_dep_compare_expr (l_upper, r_lower) == -1)\n+    return GFC_DEP_NODEP;\n+  if (r_upper && l_lower && gfc_dep_compare_expr (r_upper, l_lower) == -1)\n+    return GFC_DEP_NODEP;\n+\n+  /* Handle cases like x:y:1 vs. x:z:-1 as GFC_DEP_EQUAL.  */\n+  if (l_start && r_start && gfc_dep_compare_expr (l_start, r_start) == 0)\n+    {\n+      if (l_dir == 1 && r_dir == -1)\n+        return GFC_DEP_EQUAL;\n+      if (l_dir == -1 && r_dir == 1)\n+        return GFC_DEP_EQUAL;\n+    }\n \n-  mpz_clear (no_of_elements);\n-  mpz_clear (X1);\n-  mpz_clear (X2);\n-  return dep;\n+  /* Handle cases like x:y:1 vs. z:y:-1 as GFC_DEP_EQUAL.  */\n+  if (l_end && r_end && gfc_dep_compare_expr (l_end, r_end) == 0)\n+    {\n+      if (l_dir == 1 && r_dir == -1)\n+        return GFC_DEP_EQUAL;\n+      if (l_dir == -1 && r_dir == 1)\n+        return GFC_DEP_EQUAL;\n+    }\n+\n+  /* Check for forward dependencies x:y vs. x+1:z.  */\n+  if (l_dir == 1 && r_dir == 1\n+      && l_start && r_start && gfc_dep_compare_expr (l_start, r_start) == -1\n+      && l_end && r_end && gfc_dep_compare_expr (l_end, r_end) == -1)\n+    {\n+      /* Check that the strides are the same.  */\n+      if (!l_stride && !r_stride)\n+\treturn GFC_DEP_FORWARD;\n+      if (l_stride && r_stride\n+\t  && gfc_dep_compare_expr (l_stride, r_stride) == 0)\n+\treturn GFC_DEP_FORWARD;\n+    }\n+\n+  /* Check for forward dependencies x:y:-1 vs. x-1:z:-1.  */\n+  if (l_dir == -1 && r_dir == -1\n+      && l_start && r_start && gfc_dep_compare_expr (l_start, r_start) == 1\n+      && l_end && r_end && gfc_dep_compare_expr (l_end, r_end) == 1)\n+    {\n+      /* Check that the strides are the same.  */\n+      if (!l_stride && !r_stride)\n+\treturn GFC_DEP_FORWARD;\n+      if (l_stride && r_stride\n+\t  && gfc_dep_compare_expr (l_stride, r_stride) == 0)\n+\treturn GFC_DEP_FORWARD;\n+    }\n+\n+  return GFC_DEP_OVERLAP;\n }\n \n "}, {"sha": "a9fa5b057d32c5fc3e130e83d691813b9286358c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06a103af0e61d634e1fa730a1865eb4e98748e72/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06a103af0e61d634e1fa730a1865eb4e98748e72/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=06a103af0e61d634e1fa730a1865eb4e98748e72", "patch": "@@ -1,3 +1,7 @@\n+2006-04-05  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gfortran.dg/dependency_18.f90: New test case.\n+\n 2006-04-05  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/26919"}, {"sha": "cb0799d1fab947dd2a37d0594525b48af534ae90", "filename": "gcc/testsuite/gfortran.dg/dependency_18.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06a103af0e61d634e1fa730a1865eb4e98748e72/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_18.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06a103af0e61d634e1fa730a1865eb4e98748e72/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_18.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_18.f90?ref=06a103af0e61d634e1fa730a1865eb4e98748e72", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -fdump-tree-original\" }\n+subroutine foo(a,i,j,k)\n+  integer, dimension (10) :: a\n+  integer :: i, j, k\n+\n+  a(1:5:2) = a(8:6:-1)\n+\n+  a(1:8) = a(2:9)\n+\n+  a(4:7) = a(4:1:-1)\n+\n+  a(i:i+2) = a(i+4:i+6)\n+\n+  a(j:1:-1) = a(j:5)\n+\n+  a(k:k+2) = a(k+1:k+3)\n+end subroutine\n+! { dg-final { scan-tree-dump-times \"malloc\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}