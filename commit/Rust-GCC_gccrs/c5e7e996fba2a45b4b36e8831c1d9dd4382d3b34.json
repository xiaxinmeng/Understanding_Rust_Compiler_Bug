{"sha": "c5e7e996fba2a45b4b36e8831c1d9dd4382d3b34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVlN2U5OTZmYmEyYTQ1YjRiMzZlODgzMWMxZDlkZDQzODJkM2IzNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-01-17T09:53:19Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-01-17T09:53:19Z"}, "message": "trans-stmt.c (gfc_trans_do): Conditionally compute countm1 dependent on sign of step...\n\n2013-01-17  Richard Biener  <rguenther@suse.de>\n\n\tfortran/\n\t* trans-stmt.c (gfc_trans_do): Conditionally compute countm1\n\tdependent on sign of step, avoids repeated evaluation of\n\tstep sign test.  Avoid undefined overflow issues by using unsigned\n\tarithmetic.\n\nFrom-SVN: r195260", "tree": {"sha": "cabd8dda4fc2522cef651699779a9f00b577ba59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cabd8dda4fc2522cef651699779a9f00b577ba59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5e7e996fba2a45b4b36e8831c1d9dd4382d3b34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5e7e996fba2a45b4b36e8831c1d9dd4382d3b34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5e7e996fba2a45b4b36e8831c1d9dd4382d3b34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5e7e996fba2a45b4b36e8831c1d9dd4382d3b34/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "df69b59879e493a6b42c3a750e303cc15b163cec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df69b59879e493a6b42c3a750e303cc15b163cec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df69b59879e493a6b42c3a750e303cc15b163cec"}], "stats": {"total": 76, "additions": 42, "deletions": 34}, "files": [{"sha": "730c41b4e1fa391b3a7cc196e6f2c48b8cd39c30", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e7e996fba2a45b4b36e8831c1d9dd4382d3b34/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e7e996fba2a45b4b36e8831c1d9dd4382d3b34/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c5e7e996fba2a45b4b36e8831c1d9dd4382d3b34", "patch": "@@ -1,3 +1,10 @@\n+2013-01-17  Richard Biener  <rguenther@suse.de>\n+\n+\t* trans-stmt.c (gfc_trans_do): Conditionally compute countm1\n+\tdependent on sign of step, avoids repeated evaluation of\n+\tstep sign test.  Avoid undefined overflow issues by using unsigned\n+\tarithmetic.\n+\n 2013-01-16  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/55983"}, {"sha": "14c37f715709d5d67c2527363b9a186ca380b4a9", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e7e996fba2a45b4b36e8831c1d9dd4382d3b34/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e7e996fba2a45b4b36e8831c1d9dd4382d3b34/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=c5e7e996fba2a45b4b36e8831c1d9dd4382d3b34", "patch": "@@ -1543,7 +1543,6 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n   tree cycle_label;\n   tree exit_label;\n   tree tmp;\n-  tree pos_step;\n   stmtblock_t block;\n   stmtblock_t body;\n   location_t loc;\n@@ -1588,8 +1587,6 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n \t|| tree_int_cst_equal (step, integer_minus_one_node)))\n     return gfc_trans_simple_do (code, &block, dovar, from, to, step, exit_cond);\n \n-  pos_step = fold_build2_loc (loc, GT_EXPR, boolean_type_node, step,\n-\t\t\t      build_zero_cst (type));\n \n   if (TREE_CODE (type) == INTEGER_TYPE)\n     utype = unsigned_type_for (type);\n@@ -1618,65 +1615,67 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n \n   /* Initialize loop count and jump to exit label if the loop is empty.\n      This code is executed before we enter the loop body. We generate:\n-     step_sign = sign(1,step);\n      if (step > 0)\n        {\n \t if (to < from)\n \t   goto exit_label;\n+\t countm1 = (to - from) / step;\n        }\n      else\n        {\n \t if (to > from)\n \t   goto exit_label;\n+\t countm1 = (from - to) / -step;\n        }\n-       countm1 = (to*step_sign - from*step_sign) / (step*step_sign);\n-\n-  */\n+   */\n \n   if (TREE_CODE (type) == INTEGER_TYPE)\n     {\n-      tree pos, neg, step_sign, to2, from2, step2;\n+      tree pos, neg, tou, fromu, stepu, tmp2;\n \n-      /* Calculate SIGN (1,step), as (step < 0 ? -1 : 1)  */\n-\n-      tmp = fold_build2_loc (loc, LT_EXPR, boolean_type_node, step,\n-\t\t\t     build_int_cst (TREE_TYPE (step), 0));\n-      step_sign = fold_build3_loc (loc, COND_EXPR, type, tmp,\n-\t\t\t\t   build_int_cst (type, -1),\n-\t\t\t\t   build_int_cst (type, 1));\n+      /* The distance from FROM to TO cannot always be represented in a signed\n+         type, thus use unsigned arithmetic, also to avoid any undefined\n+\t overflow issues.  */\n+      tou = fold_convert (utype, to);\n+      fromu = fold_convert (utype, from);\n+      stepu = fold_convert (utype, step);\n \n+      /* For a positive step, when to < from, exit, otherwise compute\n+         countm1 = ((unsigned)to - (unsigned)from) / (unsigned)step  */\n       tmp = fold_build2_loc (loc, LT_EXPR, boolean_type_node, to, from);\n+      tmp2 = fold_build2_loc (loc, TRUNC_DIV_EXPR, utype,\n+\t\t\t      fold_build2_loc (loc, MINUS_EXPR, utype,\n+\t\t\t\t\t       tou, fromu),\n+\t\t\t      stepu);\n       pos = fold_build3_loc (loc, COND_EXPR, void_type_node, tmp,\n \t\t\t     fold_build1_loc (loc, GOTO_EXPR, void_type_node,\n \t\t\t\t\t      exit_label),\n-\t\t\t     build_empty_stmt (loc));\n-\n-      tmp = fold_build2_loc (loc, GT_EXPR, boolean_type_node, to,\n-\t\t\t     from);\n+\t\t\t     fold_build2 (MODIFY_EXPR, void_type_node,\n+\t\t\t\t\t  countm1, tmp2));\n+\n+      /* For a negative step, when to > from, exit, otherwise compute\n+         countm1 = ((unsigned)from - (unsigned)to) / -(unsigned)step  */\n+      tmp = fold_build2_loc (loc, GT_EXPR, boolean_type_node, to, from);\n+      tmp2 = fold_build2_loc (loc, TRUNC_DIV_EXPR, utype,\n+\t\t\t      fold_build2_loc (loc, MINUS_EXPR, utype,\n+\t\t\t\t\t       fromu, tou),\n+\t\t\t      fold_build1_loc (loc, NEGATE_EXPR, utype, stepu));\n       neg = fold_build3_loc (loc, COND_EXPR, void_type_node, tmp,\n \t\t\t     fold_build1_loc (loc, GOTO_EXPR, void_type_node,\n \t\t\t\t\t      exit_label),\n-\t\t\t     build_empty_stmt (loc));\n-      tmp = fold_build3_loc (loc, COND_EXPR, void_type_node,\n-\t\t\t     pos_step, pos, neg);\n+\t\t\t     fold_build2 (MODIFY_EXPR, void_type_node,\n+\t\t\t\t\t  countm1, tmp2));\n \n-      gfc_add_expr_to_block (&block, tmp);\n+      tmp = fold_build2_loc (loc, LT_EXPR, boolean_type_node, step,\n+\t\t\t     build_int_cst (TREE_TYPE (step), 0));\n+      tmp = fold_build3_loc (loc, COND_EXPR, void_type_node, tmp, neg, pos);\n \n-      /* Calculate the loop count.  to-from can overflow, so\n-\t we cast to unsigned.  */\n-\n-      to2 = fold_build2_loc (loc, MULT_EXPR, type, step_sign, to);\n-      from2 = fold_build2_loc (loc, MULT_EXPR, type, step_sign, from);\n-      step2 = fold_build2_loc (loc, MULT_EXPR, type, step_sign, step);\n-      step2 = fold_convert (utype, step2);\n-      tmp = fold_build2_loc (loc, MINUS_EXPR, type, to2, from2);\n-      tmp = fold_convert (utype, tmp);\n-      tmp = fold_build2_loc (loc, TRUNC_DIV_EXPR, utype, tmp, step2);\n-      tmp = fold_build2_loc (loc, MODIFY_EXPR, void_type_node, countm1, tmp);\n       gfc_add_expr_to_block (&block, tmp);\n     }\n   else\n     {\n+      tree pos_step;\n+\n       /* TODO: We could use the same width as the real type.\n \t This would probably cause more problems that it solves\n \t when we implement \"long double\" types.  */\n@@ -1688,6 +1687,8 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n \n       /* We need a special check for empty loops:\n \t empty = (step > 0 ? to < from : to > from);  */\n+      pos_step = fold_build2_loc (loc, GT_EXPR, boolean_type_node, step,\n+\t\t\t\t  build_zero_cst (type));\n       tmp = fold_build3_loc (loc, COND_EXPR, boolean_type_node, pos_step,\n \t\t\t     fold_build2_loc (loc, LT_EXPR,\n \t\t\t\t\t      boolean_type_node, to, from),"}]}