{"sha": "d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgxNjNmNWNjMDY4MzQ3ZGZkNzRjYjAzYzllN2I2Y2ZjZDNhODQ2MA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2007-07-29T20:01:45Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2007-07-29T20:01:45Z"}, "message": "re PR libfortran/32858 (printf-capabilities for runtime_error())\n\n2007-07-29  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/32858\n\tPR libfortran/30814\n\t* configure.ac:  Added checks for presence of stdio.h and\n\tstdarg.h.  Test presence of vsnprintf().\n\t* configure: Regenerated.\n\t* config.h.in:  Regenerated.\n\t* libgfortran.h:  Include <stdio.h>.  Add printf attribute to\n\tprototype of runtime_error.  Remove prototype for st_sprintf.\n\tAdd prototype for st_vprintf.\n\t* runtime/main.c (store_exec_path):  Replace st_sprintf by sprintf.\n\t* runtime/error.c (st_sprintf):  Remove.\n\t(runtime_error):  Rewrite as a variadic function.  Call\n\tst_vprintf().\n\t* intrinsics/pack_generic.c:  Output extents of LHS and RHS for\n\tbounds error.\n\t* io/open.c (new_unit):  Replace st_sprintf by sprintf.\n\t* io/list_read.c (convert_integer):  Likewise.\n\t(parse_repeat):  Likewise.\n\t(read_logical):  Likewise.\n\t(read_character):  Likewise.\n\t(parse_real):  Likewise.\n\t(read_real):  Likewise.\n\t(check_type):  Likewise.\n\t(nml_parse_qualifyer):  Likewise.\n\t(nml_read_obj):  Likewise.\n\t(nml_get_ojb_data):  Likewise.\n\t* io/unix.c (init_error_stream):  Remove.\n\t(tempfile):  Replace st_sprintf by sprintf.\n\t(st_vprintf):  New function.\n\t(st_printf):  Rewrite to call st_vprintf.\n\t* io/transfer.c (require_type):  Replace st_sprintf by sprintf.\n\t* io/format.c (format_error):  Likewise.\n\t* io/write.c (nml_write_obj):  Likewise.\n\n2007-07-29  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/32858\n\tPR libfortran/30814\n\t* gfortran.dg/pack_bounds_1.f90:  Adjust to new error message.\n\nFrom-SVN: r127049", "tree": {"sha": "05a77906359d7bd336aba3bd8c097b7414e1f63a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05a77906359d7bd336aba3bd8c097b7414e1f63a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/comments", "author": null, "committer": null, "parents": [{"sha": "6a56381bf7e8825e08ec3a47bc14230528c82462", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a56381bf7e8825e08ec3a47bc14230528c82462", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a56381bf7e8825e08ec3a47bc14230528c82462"}], "stats": {"total": 450, "additions": 192, "deletions": 258}, "files": [{"sha": "7d4be5e8b300992416bf70ac6ec5330155ff5c41", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "patch": "@@ -1,3 +1,9 @@\n+2007-07-29  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/32858\n+\tPR libfortran/30814\n+\t* gfortran.dg/pack_bounds_1.f90:  Adjust to new error message.\n+\n 2007-07-29  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/31211"}, {"sha": "d1e185cc46eb00064a46adf05c2daf63ec125349", "filename": "gcc/testsuite/gfortran.dg/pack_bounds_1.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/gcc%2Ftestsuite%2Fgfortran.dg%2Fpack_bounds_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/gcc%2Ftestsuite%2Fgfortran.dg%2Fpack_bounds_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpack_bounds_1.f90?ref=d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "patch": "@@ -1,10 +1,10 @@\n ! { dg-do run }\n ! { dg-options \"-fbounds-check\" }\n-! { dg-shouldfail \"Incorrect extent in return value of  PACK intrinsic\" }\n+! { dg-shouldfail \"Incorrect extent in return value of PACK intrinsic; is 4, should be 5\" }\n ! PR 30814 - a bounds error with pack was not caught.\n program main\n   integer :: a(2,2), b(5)\n   a = reshape((/ 1, -1, 1, -1 /), shape(a))\n   b = pack(a, a /= 0)\n end program main\n-! { dg-output \"Fortran runtime error: Incorrect extent in return value of PACK intrinsic\" }\n+! { dg-output \"Fortran runtime error: Incorrect extent in return value of PACK intrinsic; is 4, should be 5\" }"}, {"sha": "71f0f0162245a27c167d3947c9d296f24ad9653f", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "patch": "@@ -1,3 +1,39 @@\n+2007-07-29  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/32858\n+\tPR libfortran/30814\n+\t* configure.ac:  Added checks for presence of stdio.h and\n+\tstdarg.h.  Test presence of vsnprintf().\n+\t* configure: Regenerated.\n+\t* config.h.in:  Regenerated.\n+\t* libgfortran.h:  Include <stdio.h>.  Add printf attribute to\n+\tprototype of runtime_error.  Remove prototype for st_sprintf.\n+\tAdd prototype for st_vprintf.\n+\t* runtime/main.c (store_exec_path):  Replace st_sprintf by sprintf.\n+\t* runtime/error.c (st_sprintf):  Remove.\n+\t(runtime_error):  Rewrite as a variadic function.  Call\n+\tst_vprintf().\n+\t* intrinsics/pack_generic.c:  Output extents of LHS and RHS for\n+\tbounds error.\n+\t* io/open.c (new_unit):  Replace st_sprintf by sprintf.\n+\t* io/list_read.c (convert_integer):  Likewise.\n+\t(parse_repeat):  Likewise.\n+\t(read_logical):  Likewise.\n+\t(read_character):  Likewise.\n+\t(parse_real):  Likewise.\n+\t(read_real):  Likewise.\n+\t(check_type):  Likewise.\n+\t(nml_parse_qualifyer):  Likewise.\n+\t(nml_read_obj):  Likewise.\n+\t(nml_get_ojb_data):  Likewise.\n+\t* io/unix.c (init_error_stream):  Remove.\n+\t(tempfile):  Replace st_sprintf by sprintf.\n+\t(st_vprintf):  New function.\n+\t(st_printf):  Rewrite to call st_vprintf.\n+\t* io/transfer.c (require_type):  Replace st_sprintf by sprintf.\n+\t* io/format.c (format_error):  Likewise.\n+\t* io/write.c (nml_write_obj):  Likewise.\n+\n 2007-07-27  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* io/transfer.c (st_set_nml_var_dim): Use index_type instead of"}, {"sha": "0779149d7465e42532f77725f3a3b9553cc3d1ab", "filename": "libgfortran/config.h.in", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig.h.in?ref=d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "patch": "@@ -270,6 +270,9 @@\n /* Define to 1 if you have the `ctime' function. */\n #undef HAVE_CTIME\n \n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#undef HAVE_DLFCN_H\n+\n /* Define to 1 if you have the `dup2' function. */\n #undef HAVE_DUP2\n \n@@ -594,9 +597,15 @@\n /* Define to 1 if you have the `stat' function. */\n #undef HAVE_STAT\n \n+/* Define to 1 if you have the <stdarg.h> header file. */\n+#undef HAVE_STDARG_H\n+\n /* Define to 1 if you have the <stdint.h> header file. */\n #undef HAVE_STDINT_H\n \n+/* Define to 1 if you have the <stdio.h> header file. */\n+#undef HAVE_STDIO_H\n+\n /* Define to 1 if you have the <stdlib.h> header file. */\n #undef HAVE_STDLIB_H\n \n@@ -696,6 +705,9 @@\n /* Define if target can unlink open files. */\n #undef HAVE_UNLINK_OPEN_FILE\n \n+/* Define to 1 if you have the `vsnprintf' function. */\n+#undef HAVE_VSNPRINTF\n+\n /* Define to 1 if you have the `wait' function. */\n #undef HAVE_WAIT\n \n@@ -729,6 +741,10 @@\n /* libm includes ynl */\n #undef HAVE_YNL\n \n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#undef LT_OBJDIR\n+\n /* Define to the address where bug reports for this package should be sent. */\n #undef PACKAGE_BUGREPORT\n "}, {"sha": "7e568a37764a9eb38e29a1e17e0463ee0f5d0b59", "filename": "libgfortran/configure", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "patch": "@@ -3359,6 +3359,7 @@ fi\n \n \n \n+\n # Check for symbol versioning (copied from libssp).\n echo \"$as_me:$LINENO: checking whether symbol versioning is supported\" >&5\n echo $ECHO_N \"checking whether symbol versioning is supported... $ECHO_C\" >&6\n@@ -4320,13 +4321,13 @@ if test \"${lt_cv_nm_interface+set}\" = set; then\n else\n   lt_cv_nm_interface=\"BSD nm\"\n   echo \"int some_variable = 0;\" > conftest.$ac_ext\n-  (eval echo \"\\\"\\$as_me:4323: $ac_compile\\\"\" >&5)\n+  (eval echo \"\\\"\\$as_me:4324: $ac_compile\\\"\" >&5)\n   (eval \"$ac_compile\" 2>conftest.err)\n   cat conftest.err >&5\n-  (eval echo \"\\\"\\$as_me:4326: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&5)\n+  (eval echo \"\\\"\\$as_me:4327: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&5)\n   (eval \"$NM \\\"conftest.$ac_objext\\\"\" 2>conftest.err > conftest.out)\n   cat conftest.err >&5\n-  (eval echo \"\\\"\\$as_me:4329: output\\\"\" >&5)\n+  (eval echo \"\\\"\\$as_me:4330: output\\\"\" >&5)\n   cat conftest.out >&5\n   if $GREP 'External.*some_variable' conftest.out > /dev/null; then\n     lt_cv_nm_interface=\"MS dumpbin\"\n@@ -5381,7 +5382,7 @@ ia64-*-hpux*)\n   ;;\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 5384 \"configure\"' > conftest.$ac_ext\n+  echo '#line 5385 \"configure\"' > conftest.$ac_ext\n   if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   (eval $ac_compile) 2>&5\n   ac_status=$?\n@@ -6486,11 +6487,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:6489: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:6490: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>conftest.err)\n    ac_status=$?\n    cat conftest.err >&5\n-   echo \"$as_me:6493: \\$? = $ac_status\" >&5\n+   echo \"$as_me:6494: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s \"$ac_outfile\"; then\n      # The compiler can only warn and ignore the option if not recognized\n      # So say no if there are warnings other than the usual output.\n@@ -6808,11 +6809,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:6811: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:6812: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>conftest.err)\n    ac_status=$?\n    cat conftest.err >&5\n-   echo \"$as_me:6815: \\$? = $ac_status\" >&5\n+   echo \"$as_me:6816: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s \"$ac_outfile\"; then\n      # The compiler can only warn and ignore the option if not recognized\n      # So say no if there are warnings other than the usual output.\n@@ -6913,11 +6914,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:6916: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:6917: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>out/conftest.err)\n    ac_status=$?\n    cat out/conftest.err >&5\n-   echo \"$as_me:6920: \\$? = $ac_status\" >&5\n+   echo \"$as_me:6921: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s out/conftest2.$ac_objext\n    then\n      # The compiler can only warn and ignore the option if not recognized\n@@ -6968,11 +6969,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:6971: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:6972: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>out/conftest.err)\n    ac_status=$?\n    cat out/conftest.err >&5\n-   echo \"$as_me:6975: \\$? = $ac_status\" >&5\n+   echo \"$as_me:6976: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s out/conftest2.$ac_objext\n    then\n      # The compiler can only warn and ignore the option if not recognized\n@@ -9820,7 +9821,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 9823 \"configure\"\n+#line 9824 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -9920,7 +9921,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 9923 \"configure\"\n+#line 9924 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -10250,7 +10251,7 @@ fi\n \n \n # Provide some information about the compiler.\n-echo \"$as_me:10253:\" \\\n+echo \"$as_me:10254:\" \\\n      \"checking for Fortran compiler version\" >&5\n ac_compiler=`set X $ac_compile; echo $2`\n { (eval echo \"$as_me:$LINENO: \\\"$ac_compiler --version </dev/null >&5\\\"\") >&5\n@@ -10486,7 +10487,7 @@ fi\n \n \n # Provide some information about the compiler.\n-echo \"$as_me:10489:\" \\\n+echo \"$as_me:10490:\" \\\n      \"checking for Fortran compiler version\" >&5\n ac_compiler=`set X $ac_compile; echo $2`\n { (eval echo \"$as_me:$LINENO: \\\"$ac_compiler --version </dev/null >&5\\\"\") >&5\n@@ -11202,11 +11203,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:11205: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:11206: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>conftest.err)\n    ac_status=$?\n    cat conftest.err >&5\n-   echo \"$as_me:11209: \\$? = $ac_status\" >&5\n+   echo \"$as_me:11210: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s \"$ac_outfile\"; then\n      # The compiler can only warn and ignore the option if not recognized\n      # So say no if there are warnings other than the usual output.\n@@ -11301,11 +11302,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:11304: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:11305: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>out/conftest.err)\n    ac_status=$?\n    cat out/conftest.err >&5\n-   echo \"$as_me:11308: \\$? = $ac_status\" >&5\n+   echo \"$as_me:11309: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s out/conftest2.$ac_objext\n    then\n      # The compiler can only warn and ignore the option if not recognized\n@@ -11353,11 +11354,11 @@ else\n    -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n    -e 's: [^ ]*conftest\\.: $lt_compiler_flag&:; t' \\\n    -e 's:$: $lt_compiler_flag:'`\n-   (eval echo \"\\\"\\$as_me:11356: $lt_compile\\\"\" >&5)\n+   (eval echo \"\\\"\\$as_me:11357: $lt_compile\\\"\" >&5)\n    (eval \"$lt_compile\" 2>out/conftest.err)\n    ac_status=$?\n    cat out/conftest.err >&5\n-   echo \"$as_me:11360: \\$? = $ac_status\" >&5\n+   echo \"$as_me:11361: \\$? = $ac_status\" >&5\n    if (exit $ac_status) && test -s out/conftest2.$ac_objext\n    then\n      # The compiler can only warn and ignore the option if not recognized\n@@ -14077,7 +14078,9 @@ fi\n \n \n \n-for ac_header in stdlib.h string.h unistd.h signal.h\n+\n+\n+for ac_header in stdio.h stdlib.h string.h unistd.h signal.h stdarg.h\n do\n as_ac_Header=`echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n if eval \"test \\\"\\${$as_ac_Header+set}\\\" = set\"; then\n@@ -18477,7 +18480,8 @@ done\n \n \n \n-for ac_func in gettimeofday stat fstat lstat getpwuid\n+\n+for ac_func in gettimeofday stat fstat lstat getpwuid vsnprintf\n do\n as_ac_var=`echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n echo \"$as_me:$LINENO: checking for $ac_func\" >&5"}, {"sha": "0c8532611d722c685d5a352dffd3f69240641606", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "patch": "@@ -176,7 +176,7 @@ AC_TYPE_OFF_T\n # check header files\n AC_STDC_HEADERS\n AC_HEADER_TIME\n-AC_HAVE_HEADERS(stdlib.h string.h unistd.h signal.h)\n+AC_HAVE_HEADERS(stdio.h stdlib.h string.h unistd.h signal.h stdarg.h)\n AC_CHECK_HEADERS(time.h sys/time.h sys/times.h sys/resource.h)\n AC_CHECK_HEADERS(sys/types.h sys/stat.h sys/wait.h floatingpoint.h ieeefp.h)\n AC_CHECK_HEADERS(fenv.h fptrap.h float.h execinfo.h pwd.h)\n@@ -192,7 +192,7 @@ AC_CHECK_FUNCS(getrusage times mkstemp strtof strtold snprintf ftruncate chsize)\n AC_CHECK_FUNCS(chdir strerror getlogin gethostname kill link symlink perror)\n AC_CHECK_FUNCS(sleep time ttyname signal alarm ctime clock access fork execl)\n AC_CHECK_FUNCS(wait setmode execvp pipe dup2 close fdopen strcasestr getrlimit)\n-AC_CHECK_FUNCS(gettimeofday stat fstat lstat getpwuid)\n+AC_CHECK_FUNCS(gettimeofday stat fstat lstat getpwuid vsnprintf)\n \n # Check for glibc backtrace functions\n AC_CHECK_FUNCS(backtrace backtrace_symbols)"}, {"sha": "a1998ad580b6a71ec02c0e6532019f7e96633b6d", "filename": "libgfortran/intrinsics/pack_generic.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fintrinsics%2Fpack_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fintrinsics%2Fpack_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fpack_generic.c?ref=d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "patch": "@@ -217,9 +217,13 @@ pack_internal (gfc_array_char *ret, const gfc_array_char *array,\n       else \n \t{\n \t  /* We come here because of range checking.  */\n-\t  if (total != ret->dim[0].ubound + 1 - ret->dim[0].lbound)\n-\t    runtime_error (\"Incorrect extent in return value of\"\n-\t\t\t   \" PACK intrinsic\");\n+\t  index_type ret_extent;\n+\n+\t  ret_extent = ret->dim[0].ubound + 1 - ret->dim[0].lbound;\n+\t  if (total != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return value of PACK intrinsic;\"\n+\t\t\t   \" is %ld, should be %ld\", (long int) total,\n+\t\t\t   (long int) ret_extent);\n \t}\n     }\n "}, {"sha": "c8cd2a7ed187974d424e9e7ef0fda872b9e8c95c", "filename": "libgfortran/io/format.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fio%2Fformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fio%2Fformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fformat.c?ref=d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "patch": "@@ -915,7 +915,7 @@ format_error (st_parameter_dt *dtp, const fnode *f, const char *message)\n   if (f != NULL)\n     fmt->format_string = f->source;\n \n-  st_sprintf (buffer, \"%s\\n\", message);\n+  sprintf (buffer, \"%s\\n\", message);\n \n   j = fmt->format_string - dtp->format;\n "}, {"sha": "41d4a604291f62ca88b80151ef2a1aad4a10a04f", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "patch": "@@ -464,8 +464,8 @@ convert_integer (st_parameter_dt *dtp, int length, int negative)\n \n       if (dtp->u.p.repeat_count == 0)\n \t{\n-\t  st_sprintf (message, \"Zero repeat count in item %d of list input\",\n-\t\t      dtp->u.p.item_count);\n+\t  sprintf (message, \"Zero repeat count in item %d of list input\",\n+\t\t   dtp->u.p.item_count);\n \n \t  generate_error (&dtp->common, ERROR_READ_VALUE, message);\n \t  m = 1;\n@@ -477,11 +477,11 @@ convert_integer (st_parameter_dt *dtp, int length, int negative)\n \n  overflow:\n   if (length == -1)\n-    st_sprintf (message, \"Repeat count overflow in item %d of list input\",\n-\t\tdtp->u.p.item_count);\n+    sprintf (message, \"Repeat count overflow in item %d of list input\",\n+\t     dtp->u.p.item_count);\n   else\n-    st_sprintf (message, \"Integer overflow while reading item %d\",\n-\t\tdtp->u.p.item_count);\n+    sprintf (message, \"Integer overflow while reading item %d\",\n+\t     dtp->u.p.item_count);\n \n   free_saved (dtp);\n   generate_error (&dtp->common, ERROR_READ_VALUE, message);\n@@ -527,9 +527,9 @@ parse_repeat (st_parameter_dt *dtp)\n \n \t  if (repeat > MAX_REPEAT)\n \t    {\n-\t      st_sprintf (message,\n-\t\t\t  \"Repeat count overflow in item %d of list input\",\n-\t\t\t  dtp->u.p.item_count);\n+\t      sprintf (message,\n+\t\t       \"Repeat count overflow in item %d of list input\",\n+\t\t       dtp->u.p.item_count);\n \n \t      generate_error (&dtp->common, ERROR_READ_VALUE, message);\n \t      return 1;\n@@ -540,9 +540,9 @@ parse_repeat (st_parameter_dt *dtp)\n \tcase '*':\n \t  if (repeat == 0)\n \t    {\n-\t      st_sprintf (message,\n-\t\t\t  \"Zero repeat count in item %d of list input\",\n-\t\t\t  dtp->u.p.item_count);\n+\t      sprintf (message,\n+\t\t       \"Zero repeat count in item %d of list input\",\n+\t\t       dtp->u.p.item_count);\n \n \t      generate_error (&dtp->common, ERROR_READ_VALUE, message);\n \t      return 1;\n@@ -563,8 +563,8 @@ parse_repeat (st_parameter_dt *dtp)\n \n   eat_line (dtp);\n   free_saved (dtp);\n-  st_sprintf (message, \"Bad repeat count in item %d of list input\",\n-\t      dtp->u.p.item_count);\n+  sprintf (message, \"Bad repeat count in item %d of list input\",\n+\t   dtp->u.p.item_count);\n   generate_error (&dtp->common, ERROR_READ_VALUE, message);\n   return 1;\n }\n@@ -708,7 +708,7 @@ read_logical (st_parameter_dt *dtp, int length)\n \n   eat_line (dtp);\n   free_saved (dtp);\n-  st_sprintf (message, \"Bad logical value while reading item %d\",\n+  sprintf (message, \"Bad logical value while reading item %d\",\n \t      dtp->u.p.item_count);\n   generate_error (&dtp->common, ERROR_READ_VALUE, message);\n   return;\n@@ -840,7 +840,7 @@ read_integer (st_parameter_dt *dtp, int length)\n   \n   eat_line (dtp);\n   free_saved (dtp);\n-  st_sprintf (message, \"Bad integer for item %d in list input\",\n+  sprintf (message, \"Bad integer for item %d in list input\",\n \t      dtp->u.p.item_count);\n   generate_error (&dtp->common, ERROR_READ_VALUE, message);\n \n@@ -1004,7 +1004,7 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n   else\n     {\n       free_saved (dtp);\n-      st_sprintf (message, \"Invalid string input in item %d\",\n+      sprintf (message, \"Invalid string input in item %d\",\n \t\t  dtp->u.p.item_count);\n       generate_error (&dtp->common, ERROR_READ_VALUE, message);\n     }\n@@ -1123,7 +1123,7 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n \n   eat_line (dtp);\n   free_saved (dtp);\n-  st_sprintf (message, \"Bad floating point number for item %d\",\n+  sprintf (message, \"Bad floating point number for item %d\",\n \t      dtp->u.p.item_count);\n   generate_error (&dtp->common, ERROR_READ_VALUE, message);\n \n@@ -1206,7 +1206,7 @@ read_complex (st_parameter_dt *dtp, int kind, size_t size)\n \n   eat_line (dtp);\n   free_saved (dtp);\n-  st_sprintf (message, \"Bad complex value in item %d of list input\",\n+  sprintf (message, \"Bad complex value in item %d of list input\",\n \t      dtp->u.p.item_count);\n   generate_error (&dtp->common, ERROR_READ_VALUE, message);\n }\n@@ -1421,7 +1421,7 @@ read_real (st_parameter_dt *dtp, int length)\n \n   eat_line (dtp);\n   free_saved (dtp);\n-  st_sprintf (message, \"Bad real number in item %d of list input\",\n+  sprintf (message, \"Bad real number in item %d of list input\",\n \t      dtp->u.p.item_count);\n   generate_error (&dtp->common, ERROR_READ_VALUE, message);\n }\n@@ -1437,7 +1437,7 @@ check_type (st_parameter_dt *dtp, bt type, int len)\n \n   if (dtp->u.p.saved_type != BT_NULL && dtp->u.p.saved_type != type)\n     {\n-      st_sprintf (message, \"Read type %s where %s was expected for item %d\",\n+      sprintf (message, \"Read type %s where %s was expected for item %d\",\n \t\t  type_name (dtp->u.p.saved_type), type_name (type),\n \t\t  dtp->u.p.item_count);\n \n@@ -1450,7 +1450,7 @@ check_type (st_parameter_dt *dtp, bt type, int len)\n \n   if (dtp->u.p.saved_length != len)\n     {\n-      st_sprintf (message,\n+      sprintf (message,\n \t\t  \"Read kind %d %s where kind %d is required for item %d\",\n \t\t  dtp->u.p.saved_length, type_name (dtp->u.p.saved_type), len,\n \t\t  dtp->u.p.item_count);\n@@ -1723,8 +1723,8 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t\t  if ((c==',' && dim == rank -1)\n \t\t      || (c==')' && dim < rank -1))\n \t\t    {\n-\t\t      st_sprintf (parse_err_msg,\n-\t\t\t\t  \"Bad number of index fields\");\n+\t\t      sprintf (parse_err_msg,\n+\t\t\t       \"Bad number of index fields\");\n \t\t      goto err_ret;\n \t\t    }\n \t\t  break;\n@@ -1739,21 +1739,21 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t\t  break;\n \n \t\tdefault:\n-\t\t  st_sprintf (parse_err_msg, \"Bad character in index\");\n+\t\t  sprintf (parse_err_msg, \"Bad character in index\");\n \t\t  goto err_ret;\n \t\t}\n \n \t      if ((c == ',' || c == ')') && indx == 0\n \t\t  && dtp->u.p.saved_string == 0)\n \t\t{\n-\t\t  st_sprintf (parse_err_msg, \"Null index field\");\n+\t\t  sprintf (parse_err_msg, \"Null index field\");\n \t\t  goto err_ret;\n \t\t}\n \n \t      if ((c == ':' && indx == 1 && dtp->u.p.saved_string == 0)\n \t\t  || (indx == 2 && dtp->u.p.saved_string == 0))\n \t\t{\n-\t\t  st_sprintf(parse_err_msg, \"Bad index triplet\");\n+\t\t  sprintf(parse_err_msg, \"Bad index triplet\");\n \t\t  goto err_ret;\n \t\t}\n \n@@ -1769,7 +1769,7 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t      /* Now read the index.  */\n \t      if (convert_integer (dtp, sizeof(ssize_t), neg))\n \t\t{\n-\t\t  st_sprintf (parse_err_msg, \"Bad integer in index\");\n+\t\t  sprintf (parse_err_msg, \"Bad integer in index\");\n \t\t  goto err_ret;\n \t\t}\n \t      break;\n@@ -1811,13 +1811,13 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t  || (ls[dim].end > (ssize_t)ad[dim].ubound)\n \t  || (ls[dim].end < (ssize_t)ad[dim].lbound))\n \t{\n-\t  st_sprintf (parse_err_msg, \"Index %d out of range\", dim + 1);\n+\t  sprintf (parse_err_msg, \"Index %d out of range\", dim + 1);\n \t  goto err_ret;\n \t}\n       if (((ls[dim].end - ls[dim].start ) * ls[dim].step < 0)\n \t  || (ls[dim].step == 0))\n \t{\n-\t  st_sprintf (parse_err_msg, \"Bad range in index %d\", dim + 1);\n+\t  sprintf (parse_err_msg, \"Bad range in index %d\", dim + 1);\n \t  goto err_ret;\n \t}\n \n@@ -2171,7 +2171,7 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n \t    goto incr_idx;\n \n           default:\n-\t    st_sprintf (nml_err_msg, \"Bad type for namelist object %s\",\n+\t    sprintf (nml_err_msg, \"Bad type for namelist object %s\",\n \t\t\tnl->var_name);\n \t    internal_error (&dtp->common, nml_err_msg);\n \t    goto nml_err_ret;\n@@ -2260,7 +2260,7 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n \n   if (dtp->u.p.repeat_count > 1)\n     {\n-       st_sprintf (nml_err_msg, \"Repeat count too large for namelist object %s\" ,\n+       sprintf (nml_err_msg, \"Repeat count too large for namelist object %s\" ,\n \t\t   nl->var_name );\n        goto nml_err_ret;\n     }\n@@ -2310,7 +2310,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n       c = next_char (dtp);\n       if (c != '?')\n \t{\n-\t  st_sprintf (nml_err_msg, \"namelist read: misplaced = sign\");\n+\t  sprintf (nml_err_msg, \"namelist read: misplaced = sign\");\n \t  goto nml_err_ret;\n \t}\n       nml_query (dtp, '=');\n@@ -2325,7 +2325,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n       nml_match_name (dtp, \"end\", 3);\n       if (dtp->u.p.nml_read_error)\n \t{\n-\t  st_sprintf (nml_err_msg, \"namelist not terminated with / or &end\");\n+\t  sprintf (nml_err_msg, \"namelist not terminated with / or &end\");\n \t  goto nml_err_ret;\n \t}\n     case '/':\n@@ -2384,11 +2384,11 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n   if (nl == NULL)\n     {\n       if (dtp->u.p.nml_read_error && *pprev_nl)\n-\tst_sprintf (nml_err_msg, \"Bad data for namelist object %s\",\n+\tsprintf (nml_err_msg, \"Bad data for namelist object %s\",\n \t\t    (*pprev_nl)->var_name);\n \n       else\n-\tst_sprintf (nml_err_msg, \"Cannot match namelist object name %s\",\n+\tsprintf (nml_err_msg, \"Cannot match namelist object name %s\",\n \t\t    dtp->u.p.saved_string);\n \n       goto nml_err_ret;\n@@ -2412,7 +2412,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n       if (nml_parse_qualifier (dtp, nl->dim, nl->ls, nl->var_rank,\n \t\t\t       parse_err_msg) == FAILURE)\n \t{\n-\t  st_sprintf (nml_err_msg, \"%s for namelist variable %s\",\n+\t  sprintf (nml_err_msg, \"%s for namelist variable %s\",\n \t\t      parse_err_msg, nl->var_name);\n \t  goto nml_err_ret;\n \t}\n@@ -2429,7 +2429,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \n       if (nl->type != GFC_DTYPE_DERIVED)\n \t{\n-\t  st_sprintf (nml_err_msg, \"Attempt to get derived component for %s\",\n+\t  sprintf (nml_err_msg, \"Attempt to get derived component for %s\",\n \t\t      nl->var_name);\n \t  goto nml_err_ret;\n \t}\n@@ -2457,7 +2457,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \n       if (nml_parse_qualifier (dtp, chd, ind, 1, parse_err_msg) == FAILURE)\n \t{\n-\t  st_sprintf (nml_err_msg, \"%s for namelist variable %s\",\n+\t  sprintf (nml_err_msg, \"%s for namelist variable %s\",\n \t\t      parse_err_msg, nl->var_name);\n \t  goto nml_err_ret;\n \t}\n@@ -2467,7 +2467,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \n       if (ind[0].step != 1)\n \t{\n-\t  st_sprintf (nml_err_msg,\n+\t  sprintf (nml_err_msg,\n \t\t      \"Bad step in substring for namelist object %s\",\n \t\t      nl->var_name);\n \t  goto nml_err_ret;\n@@ -2490,7 +2490,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \n   if (c == '(')\n     {\n-      st_sprintf (nml_err_msg, \"Qualifier for a scalar or non-character\"\n+      sprintf (nml_err_msg, \"Qualifier for a scalar or non-character\"\n \t\t  \" namelist object %s\", nl->var_name);\n       goto nml_err_ret;\n     }\n@@ -2514,7 +2514,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \n   if (c != '=')\n     {\n-      st_sprintf (nml_err_msg, \"Equal sign must follow namelist object name %s\",\n+      sprintf (nml_err_msg, \"Equal sign must follow namelist object name %s\",\n \t\t  nl->var_name);\n       goto nml_err_ret;\n     }"}, {"sha": "67f8804f522634dd86da6c9d327ab00f8a8ee9ba", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "patch": "@@ -389,19 +389,19 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n       switch (errno)\n \t{\n \tcase ENOENT: \n-\t  st_sprintf (msg, \"File '%s' does not exist\", path);\n+\t  sprintf (msg, \"File '%s' does not exist\", path);\n \t  break;\n \n \tcase EEXIST:\n-\t  st_sprintf (msg, \"File '%s' already exists\", path);\n+\t  sprintf (msg, \"File '%s' already exists\", path);\n \t  break;\n \n \tcase EACCES:\n-\t  st_sprintf (msg, \"Permission denied trying to open file '%s'\", path);\n+\t  sprintf (msg, \"Permission denied trying to open file '%s'\", path);\n \t  break;\n \n \tcase EISDIR:\n-\t  st_sprintf (msg, \"'%s' is a directory\", path);\n+\t  sprintf (msg, \"'%s' is a directory\", path);\n \t  break;\n \n \tdefault:"}, {"sha": "04f9f735f83d1eb753b85618433a9afe56f5569b", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "patch": "@@ -852,8 +852,8 @@ require_type (st_parameter_dt *dtp, bt expected, bt actual, const fnode *f)\n   if (actual == expected)\n     return 0;\n \n-  st_sprintf (buffer, \"Expected %s for item %d in formatted transfer, got %s\",\n-\t      type_name (expected), dtp->u.p.item_count, type_name (actual));\n+  sprintf (buffer, \"Expected %s for item %d in formatted transfer, got %s\",\n+\t   type_name (expected), dtp->u.p.item_count, type_name (actual));\n \n   format_error (dtp, f, buffer);\n   return 1;"}, {"sha": "e9ad164ba964b08e250563d882ff57becd862f9f", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 29, "deletions": 111, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "patch": "@@ -142,10 +142,6 @@ typedef struct\n }\n int_stream;\n \n-extern stream *init_error_stream (unix_stream *);\n-internal_proto(init_error_stream);\n-\n-\n /* This implementation of stream I/O is based on the paper:\n  *\n  *  \"Exploiting the advantages of mapped files for stream I/O\",\n@@ -1155,7 +1151,7 @@ tempfile (st_parameter_open *opp)\n \n   template = get_mem (strlen (tempdir) + 20);\n \n-  st_sprintf (template, \"%s/gfortrantmpXXXXXX\", tempdir);\n+  sprintf (template, \"%s/gfortrantmpXXXXXX\", tempdir);\n \n #ifdef HAVE_MKSTEMP\n \n@@ -1385,122 +1381,44 @@ error_stream (void)\n   return fd_to_stream (STDERR_FILENO, PROT_WRITE);\n }\n \n-/* init_error_stream()-- Return a pointer to the error stream.  This\n- * subroutine is called when the stream is needed, rather than at\n- * initialization.  We want to work even if memory has been seriously\n- * corrupted. */\n \n-stream *\n-init_error_stream (unix_stream *error)\n-{\n-  memset (error, '\\0', sizeof (*error));\n+/* st_vprintf()-- vprintf function for error output.  To avoid buffer\n+   overruns, we limit the length of the buffer to ST_VPRINTF_SIZE.  2k\n+   is big enough to completely fill a 80x25 terminal, so it shuld be\n+   OK.  We use a direct write() because it is simpler and least likely\n+   to be clobbered by memory corruption.  */\n \n-  error->fd = options.use_stderr ? STDERR_FILENO : STDOUT_FILENO;\n+#define ST_VPRINTF_SIZE 2048\n \n-  error->st.alloc_w_at = (void *) fd_alloc_w_at;\n-  error->st.sfree = (void *) fd_sfree;\n-\n-  error->unbuffered = 1;\n-  error->buffer = error->small_buffer;\n+int\n+st_vprintf (const char *format, va_list ap)\n+{\n+  static char buffer[ST_VPRINTF_SIZE];\n+  int written;\n+  int fd;\n \n-  return (stream *) error;\n+  fd = options.use_stderr ? STDERR_FILENO : STDOUT_FILENO;\n+#ifdef HAVE_VSNPRINTF\n+  written = vsnprintf(buffer, ST_VPRINTF_SIZE, format, ap);\n+#else\n+  written = __builtin_vsnprintf(buffer, ST_VPRINTF_SIZE, format, ap);\n+#endif\n+  written = write (fd, buffer, written);\n+  return written;\n }\n \n-/* st_printf()-- simple printf() function for streams that handles the\n- * formats %d, %s and %c.  This function handles printing of error\n- * messages that originate within the library itself, not from a user\n- * program. */\n+/* st_printf()-- printf() function for error output.  This just calls\n+   st_vprintf() to do the actual work.  */\n \n int\n st_printf (const char *format, ...)\n {\n-  int count, total;\n-  va_list arg;\n-  char *p;\n-  const char *q;\n-  stream *s;\n-  char itoa_buf[GFC_ITOA_BUF_SIZE];\n-  unix_stream err_stream;\n-\n-  total = 0;\n-  s = init_error_stream (&err_stream);\n-  va_start (arg, format);\n-\n-  for (;;)\n-    {\n-      count = 0;\n-\n-      while (format[count] != '%' && format[count] != '\\0')\n-\tcount++;\n-\n-      if (count != 0)\n-\t{\n-\t  p = salloc_w (s, &count);\n-\t  memmove (p, format, count);\n-\t  sfree (s);\n-\t}\n-\n-      total += count;\n-      format += count;\n-      if (*format++ == '\\0')\n-\tbreak;\n-\n-      switch (*format)\n-\t{\n-\tcase 'c':\n-\t  count = 1;\n-\n-\t  p = salloc_w (s, &count);\n-\t  *p = (char) va_arg (arg, int);\n-\n-\t  sfree (s);\n-\t  break;\n-\n-\tcase 'd':\n-\t  q = gfc_itoa (va_arg (arg, int), itoa_buf, sizeof (itoa_buf));\n-\t  count = strlen (q);\n-\n-\t  p = salloc_w (s, &count);\n-\t  memmove (p, q, count);\n-\t  sfree (s);\n-\t  break;\n-\n-\tcase 'x':\n-\t  q = xtoa (va_arg (arg, unsigned), itoa_buf, sizeof (itoa_buf));\n-\t  count = strlen (q);\n-\n-\t  p = salloc_w (s, &count);\n-\t  memmove (p, q, count);\n-\t  sfree (s);\n-\t  break;\n-\n-\tcase 's':\n-\t  q = va_arg (arg, char *);\n-\t  count = strlen (q);\n-\n-\t  p = salloc_w (s, &count);\n-\t  memmove (p, q, count);\n-\t  sfree (s);\n-\t  break;\n-\n-\tcase '\\0':\n-\t  return total;\n-\n-\tdefault:\n-\t  count = 2;\n-\t  p = salloc_w (s, &count);\n-\t  p[0] = format[-1];\n-\t  p[1] = format[0];\n-\t  sfree (s);\n-\t  break;\n-\t}\n-\n-      total += count;\n-      format++;\n-    }\n-\n-  va_end (arg);\n-  return total;\n+  int written;\n+  va_list ap;\n+  va_start (ap, format);\n+  written = st_vprintf(format, ap);\n+  va_end (ap);\n+  return written;\n }\n \n "}, {"sha": "9509711694a03baecd2a0340f5eaf3c212b8d0d8", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "patch": "@@ -1719,7 +1719,7 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \t{\n \t  if (rep_ctr > 1)\n \t    {\n-\t      st_sprintf(rep_buff, \" %d*\", rep_ctr);\n+\t      sprintf(rep_buff, \" %d*\", rep_ctr);\n \t      write_character (dtp, rep_buff, strlen (rep_buff));\n \t      dtp->u.p.no_leading_blank = 1;\n \t    }\n@@ -1792,7 +1792,7 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \t\t      ext_name[tot_len] = '(';\n \t\t      tot_len++;\n \t\t    }\n-\t\t  st_sprintf (ext_name + tot_len, \"%d\", (int) obj->ls[dim_i].idx);\n+\t\t  sprintf (ext_name + tot_len, \"%d\", (int) obj->ls[dim_i].idx);\n \t\t  tot_len += strlen (ext_name + tot_len);\n \t\t  ext_name[tot_len] = (dim_i == obj->var_rank - 1) ? ')' : ',';\n \t\t  tot_len++;"}, {"sha": "33c2e2cb2be0bcd9722ebed2e939a19d75fc895e", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "patch": "@@ -31,6 +31,7 @@ Boston, MA 02110-1301, USA.  */\n #ifndef LIBGFOR_H\n #define LIBGFOR_H\n \n+#include <stdio.h>\n #include <math.h>\n #include <stddef.h>\n #include <float.h>\n@@ -593,7 +594,8 @@ iexport_proto(os_error);\n extern void show_locus (st_parameter_common *);\n internal_proto(show_locus);\n \n-extern void runtime_error (const char *) __attribute__ ((noreturn));\n+extern void runtime_error (const char *, ...)\n+     __attribute__ ((noreturn, format (printf, 1, 2)));\n iexport_proto(runtime_error);\n \n extern void runtime_error_at (const char *, const char *)\n@@ -607,10 +609,6 @@ internal_proto(internal_error);\n extern const char *get_oserror (void);\n internal_proto(get_oserror);\n \n-extern void st_sprintf (char *, const char *, ...)\n-  __attribute__ ((format (printf, 2, 3)));\n-internal_proto(st_sprintf);\n-\n extern const char *translate_error (int);\n internal_proto(translate_error);\n \n@@ -688,6 +686,9 @@ extern int st_printf (const char *, ...)\n   __attribute__ ((format (printf, 1, 2)));\n internal_proto(st_printf);\n \n+extern int st_vprintf (const char *, va_list);\n+internal_proto(st_vprintf);\n+\n extern char * filename_from_unit (int);\n internal_proto(filename_from_unit);\n "}, {"sha": "4dda2277dcc2af712ac42a6c9d992f51dd0d7e60", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 8, "deletions": 59, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "patch": "@@ -185,63 +185,6 @@ xtoa (GFC_UINTEGER_LARGEST n, char *buffer, size_t len)\n   return p;\n }\n \n-\n-/* st_sprintf()-- Simple sprintf() for formatting memory buffers. */\n-\n-void\n-st_sprintf (char *buffer, const char *format, ...)\n-{\n-  va_list arg;\n-  char c;\n-  const char *p;\n-  int count;\n-  char itoa_buf[GFC_ITOA_BUF_SIZE];\n-\n-  va_start (arg, format);\n-\n-  for (;;)\n-    {\n-      c = *format++;\n-      if (c != '%')\n-\t{\n-\t  *buffer++ = c;\n-\t  if (c == '\\0')\n-\t    break;\n-\t  continue;\n-\t}\n-\n-      c = *format++;\n-      switch (c)\n-\t{\n-\tcase 'c':\n-\t  *buffer++ = (char) va_arg (arg, int);\n-\t  break;\n-\n-\tcase 'd':\n-\t  p = gfc_itoa (va_arg (arg, int), itoa_buf, sizeof (itoa_buf));\n-\t  count = strlen (p);\n-\n-\t  memcpy (buffer, p, count);\n-\t  buffer += count;\n-\t  break;\n-\n-\tcase 's':\n-\t  p = va_arg (arg, char *);\n-\t  count = strlen (p);\n-\n-\t  memcpy (buffer, p, count);\n-\t  buffer += count;\n-\t  break;\n-\n-\tdefault:\n-\t  *buffer++ = c;\n-\t}\n-    }\n-\n-  va_end (arg);\n-}\n-\n-\n /* show_locus()-- Print a line number and filename describing where\n  * something went wrong */\n \n@@ -306,10 +249,16 @@ iexport(os_error);\n  * invalid fortran program. */\n \n void\n-runtime_error (const char *message)\n+runtime_error (const char *message, ...)\n {\n+  va_list ap;\n+\n   recursion_check ();\n-  st_printf (\"Fortran runtime error: %s\\n\", message);\n+  st_printf (\"Fortran runtime error: \");\n+  va_start (ap, message);\n+  st_vprintf (message, ap);\n+  va_end (ap);\n+  st_printf (\"\\n\");\n   sys_exit (2);\n }\n iexport(runtime_error);"}, {"sha": "570e9591213eabb7c49c271e2979afad4fcfc04c", "filename": "libgfortran/runtime/main.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fruntime%2Fmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460/libgfortran%2Fruntime%2Fmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fmain.c?ref=d8163f5cc068347dfd74cb03c9e7b6cfcd3a8460", "patch": "@@ -126,7 +126,7 @@ store_exe_path (const char * argv0)\n \n   /* exe_path will be cwd + \"/\" + argv[0] + \"\\0\" */\n   path = malloc (strlen (cwd) + 1 + strlen (argv0) + 1);\n-  st_sprintf (path, \"%s%c%s\", cwd, DIR_SEPARATOR, argv0);\n+  sprintf (path, \"%s%c%s\", cwd, DIR_SEPARATOR, argv0);\n   exe_path = path;\n   please_free_exe_path_when_done = 1;\n }"}]}