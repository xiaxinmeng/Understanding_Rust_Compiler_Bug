{"sha": "32159434b627981d1b4c8ee1304f20422738fe94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzIxNTk0MzRiNjI3OTgxZDFiNGM4ZWUxMzA0ZjIwNDIyNzM4ZmU5NA==", "commit": {"author": {"name": "Christian Bruel", "email": "christian.bruel@st.com", "date": "2008-02-19T07:48:12Z"}, "committer": {"name": "Christian Bruel", "email": "chrbr@gcc.gnu.org", "date": "2008-02-19T07:48:12Z"}, "message": "fix alignment bug in packed structs for STRICT_ALIGNMENT targets\n\nCo-Authored-By: Zdenek Dvorak <ook@ucw.cz>\n\nFrom-SVN: r132416", "tree": {"sha": "95c5f542910b0d62fc039d0340cee3d8e1f9e5f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95c5f542910b0d62fc039d0340cee3d8e1f9e5f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32159434b627981d1b4c8ee1304f20422738fe94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32159434b627981d1b4c8ee1304f20422738fe94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32159434b627981d1b4c8ee1304f20422738fe94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32159434b627981d1b4c8ee1304f20422738fe94/comments", "author": null, "committer": null, "parents": [{"sha": "d9484c5ba90822bb7b53bdaca6d6b6de58a66282", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9484c5ba90822bb7b53bdaca6d6b6de58a66282", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9484c5ba90822bb7b53bdaca6d6b6de58a66282"}], "stats": {"total": 158, "additions": 86, "deletions": 72}, "files": [{"sha": "ee4927514604ed3a80434eee557dd0496024180e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32159434b627981d1b4c8ee1304f20422738fe94/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32159434b627981d1b4c8ee1304f20422738fe94/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32159434b627981d1b4c8ee1304f20422738fe94", "patch": "@@ -1,3 +1,8 @@\n+2008-02-19  Christian Bruel  <christian.bruel@st.com>\n+            Zdenek Dvorak  <ook@ucw.cz>\n+\t\n+        * tree-ssa-loop-ivopts.c (may_be_unaligned_p): Check step alignment.\n+\t\n 2008-02-19  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/33555"}, {"sha": "25f6b51ab3cbe35779ecba31e331ab091b5ef21a", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 81, "deletions": 72, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32159434b627981d1b4c8ee1304f20422738fe94/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32159434b627981d1b4c8ee1304f20422738fe94/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=32159434b627981d1b4c8ee1304f20422738fe94", "patch": "@@ -1391,10 +1391,75 @@ idx_record_use (tree base, tree *idx,\n   return true;\n }\n \n-/* Returns true if memory reference REF may be unaligned.  */\n+/* If we can prove that TOP = cst * BOT for some constant cst,\n+   store cst to MUL and return true.  Otherwise return false.\n+   The returned value is always sign-extended, regardless of the\n+   signedness of TOP and BOT.  */\n \n static bool\n-may_be_unaligned_p (tree ref)\n+constant_multiple_of (tree top, tree bot, double_int *mul)\n+{\n+  tree mby;\n+  enum tree_code code;\n+  double_int res, p0, p1;\n+  unsigned precision = TYPE_PRECISION (TREE_TYPE (top));\n+\n+  STRIP_NOPS (top);\n+  STRIP_NOPS (bot);\n+\n+  if (operand_equal_p (top, bot, 0))\n+    {\n+      *mul = double_int_one;\n+      return true;\n+    }\n+\n+  code = TREE_CODE (top);\n+  switch (code)\n+    {\n+    case MULT_EXPR:\n+      mby = TREE_OPERAND (top, 1);\n+      if (TREE_CODE (mby) != INTEGER_CST)\n+\treturn false;\n+\n+      if (!constant_multiple_of (TREE_OPERAND (top, 0), bot, &res))\n+\treturn false;\n+\n+      *mul = double_int_sext (double_int_mul (res, tree_to_double_int (mby)),\n+\t\t\t      precision);\n+      return true;\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      if (!constant_multiple_of (TREE_OPERAND (top, 0), bot, &p0)\n+\t  || !constant_multiple_of (TREE_OPERAND (top, 1), bot, &p1))\n+\treturn false;\n+\n+      if (code == MINUS_EXPR)\n+\tp1 = double_int_neg (p1);\n+      *mul = double_int_sext (double_int_add (p0, p1), precision);\n+      return true;\n+\n+    case INTEGER_CST:\n+      if (TREE_CODE (bot) != INTEGER_CST)\n+\treturn false;\n+\n+      p0 = double_int_sext (tree_to_double_int (top), precision);\n+      p1 = double_int_sext (tree_to_double_int (bot), precision);\n+      if (double_int_zero_p (p1))\n+\treturn false;\n+      *mul = double_int_sext (double_int_sdivmod (p0, p1, FLOOR_DIV_EXPR, &res),\n+\t\t\t      precision);\n+      return double_int_zero_p (res);\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Returns true if memory reference REF with step STEP may be unaligned.  */\n+\n+static bool\n+may_be_unaligned_p (tree ref, tree step)\n {\n   tree base;\n   tree base_type;\n@@ -1418,11 +1483,20 @@ may_be_unaligned_p (tree ref)\n   base_type = TREE_TYPE (base);\n   base_align = TYPE_ALIGN (base_type);\n \n-  if (mode != BLKmode\n-      && (base_align < GET_MODE_ALIGNMENT (mode)\n+  if (mode != BLKmode)\n+    {\n+      double_int mul;\n+      tree al = build_int_cst (TREE_TYPE (step),\n+\t\t\t       GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT);\n+\n+      if (base_align < GET_MODE_ALIGNMENT (mode)\n \t  || bitpos % GET_MODE_ALIGNMENT (mode) != 0\n-\t  || bitpos % BITS_PER_UNIT != 0))\n-    return true;\n+\t  || bitpos % BITS_PER_UNIT != 0)\n+\treturn true;\n+    \n+      if (! constant_multiple_of (step, al, &mul))\n+\treturn true;\n+    }\n \n   return false;\n }\n@@ -1549,7 +1623,7 @@ find_interesting_uses_address (struct ivopts_data *data, tree stmt, tree *op_p)\n \n       /* Moreover, on strict alignment platforms, check that it is\n \t sufficiently aligned.  */\n-      if (STRICT_ALIGNMENT && may_be_unaligned_p (base))\n+      if (STRICT_ALIGNMENT && may_be_unaligned_p (base, step))\n \tgoto fail;\n \n       base = build_fold_addr_expr (base);\n@@ -2585,71 +2659,6 @@ tree_int_cst_sign_bit (const_tree t)\n   return (w >> bitno) & 1;\n }\n \n-/* If we can prove that TOP = cst * BOT for some constant cst,\n-   store cst to MUL and return true.  Otherwise return false.\n-   The returned value is always sign-extended, regardless of the\n-   signedness of TOP and BOT.  */\n-\n-static bool\n-constant_multiple_of (tree top, tree bot, double_int *mul)\n-{\n-  tree mby;\n-  enum tree_code code;\n-  double_int res, p0, p1;\n-  unsigned precision = TYPE_PRECISION (TREE_TYPE (top));\n-\n-  STRIP_NOPS (top);\n-  STRIP_NOPS (bot);\n-\n-  if (operand_equal_p (top, bot, 0))\n-    {\n-      *mul = double_int_one;\n-      return true;\n-    }\n-\n-  code = TREE_CODE (top);\n-  switch (code)\n-    {\n-    case MULT_EXPR:\n-      mby = TREE_OPERAND (top, 1);\n-      if (TREE_CODE (mby) != INTEGER_CST)\n-\treturn false;\n-\n-      if (!constant_multiple_of (TREE_OPERAND (top, 0), bot, &res))\n-\treturn false;\n-\n-      *mul = double_int_sext (double_int_mul (res, tree_to_double_int (mby)),\n-\t\t\t      precision);\n-      return true;\n-\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-      if (!constant_multiple_of (TREE_OPERAND (top, 0), bot, &p0)\n-\t  || !constant_multiple_of (TREE_OPERAND (top, 1), bot, &p1))\n-\treturn false;\n-\n-      if (code == MINUS_EXPR)\n-\tp1 = double_int_neg (p1);\n-      *mul = double_int_sext (double_int_add (p0, p1), precision);\n-      return true;\n-\n-    case INTEGER_CST:\n-      if (TREE_CODE (bot) != INTEGER_CST)\n-\treturn false;\n-\n-      p0 = double_int_sext (tree_to_double_int (top), precision);\n-      p1 = double_int_sext (tree_to_double_int (bot), precision);\n-      if (double_int_zero_p (p1))\n-\treturn false;\n-      *mul = double_int_sext (double_int_sdivmod (p0, p1, FLOOR_DIV_EXPR, &res),\n-\t\t\t      precision);\n-      return double_int_zero_p (res);\n-\n-    default:\n-      return false;\n-    }\n-}\n-\n /* If A is (TYPE) BA and B is (TYPE) BB, and the types of BA and BB have the\n    same precision that is at least as wide as the precision of TYPE, stores\n    BA to A and BB to B, and returns the type of BA.  Otherwise, returns the"}]}