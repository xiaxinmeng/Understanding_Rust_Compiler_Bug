{"sha": "96fc428c75cc0b52a53f6f8231be83dd78dcec4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZmYzQyOGM3NWNjMGI1MmE1M2Y2ZjgyMzFiZTgzZGQ3OGRjZWM0ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-07-26T20:17:32Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-07-26T20:17:32Z"}, "message": "re PR tree-optimization/27882 (segfault in ipa-inline.c, if (e->callee->local.disregard_inline_limits)\n\n\tPR tree-optimization/27882\n\t* cgraph.c (cgraph_remove_node): Clear needed, reachable, next, previous\n\tand decl fields.\n\t* cgraphunit.c (cgraph_reset_node): Expect cgraph_remove_node to kill\n\tnext pointer\n\t(cgraph_analyze_compilation_unit): Likewise.\n\t* ipa.c (cgraph_remove_unreachable_nodes): Likewise.\n\t* ipa-inline.c (cgraph_decide_recursive_inlining): Likewise.\n\t(cgraph_early_inlinine): Make order garbage collected.\n\t* Makefile.in (gt-ipa-inline): New garbagecollected file.\n\nFrom-SVN: r115763", "tree": {"sha": "067f3bb521f2fed42cb3fd52c2a69fe71a9ac756", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/067f3bb521f2fed42cb3fd52c2a69fe71a9ac756"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96fc428c75cc0b52a53f6f8231be83dd78dcec4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96fc428c75cc0b52a53f6f8231be83dd78dcec4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96fc428c75cc0b52a53f6f8231be83dd78dcec4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96fc428c75cc0b52a53f6f8231be83dd78dcec4e/comments", "author": null, "committer": null, "parents": [{"sha": "88c4be5e484663d65d6e95c07e49d91dfa36f57e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88c4be5e484663d65d6e95c07e49d91dfa36f57e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88c4be5e484663d65d6e95c07e49d91dfa36f57e"}], "stats": {"total": 75, "additions": 55, "deletions": 20}, "files": [{"sha": "228a358e15907da0e0a678b9a5d3017b3dc82a4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fc428c75cc0b52a53f6f8231be83dd78dcec4e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fc428c75cc0b52a53f6f8231be83dd78dcec4e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96fc428c75cc0b52a53f6f8231be83dd78dcec4e", "patch": "@@ -1,3 +1,16 @@\n+2006-07-26  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimization/27882\n+\t* cgraph.c (cgraph_remove_node): Clear needed, reachable, next, previous\n+\tand decl fields.\n+\t* cgraphunit.c (cgraph_reset_node): Expect cgraph_remove_node to kill\n+\tnext pointer\n+\t(cgraph_analyze_compilation_unit): Likewise.\n+\t* ipa.c (cgraph_remove_unreachable_nodes): Likewise.\n+\t* ipa-inline.c (cgraph_decide_recursive_inlining): Likewise.\n+\t(cgraph_early_inlinine): Make order garbage collected.\n+\t* Makefile.in (gt-ipa-inline): New garbagecollected file.\n+\n 2006-07-26  Daniel Jacobowitz  <dan@codesourcery.com>\n \n \t* dbxout.c (output_types_sort): Add a comment."}, {"sha": "f65a5fbbb727a13929fba83be2f3dd5a1c99abfc", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fc428c75cc0b52a53f6f8231be83dd78dcec4e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fc428c75cc0b52a53f6f8231be83dd78dcec4e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=96fc428c75cc0b52a53f6f8231be83dd78dcec4e", "patch": "@@ -2299,10 +2299,10 @@ ipa-cp.o : ipa-cp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n    langhooks.h $(TARGET_H) $(CGRAPH_H) ipa-prop.h  \\\n    tree-flow.h $(TM_H) tree-pass.h $(FLAGS_H) $(TREE_H) \\\n    diagnostic.h\n-ipa-inline.o : ipa-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+ipa-inline.o : ipa-inline.c gt-ipa-inline.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \\\n    $(DIAGNOSTIC_H) $(FIBHEAP_H) $(PARAMS_H) $(TIMEVAR_H) tree-pass.h \\\n-   $(COVERAGE_H) $(HASHTAB_H)\n+   $(COVERAGE_H) $(HASHTAB_H) \n ipa-utils.o : ipa-utils.c $(IPA_UTILS_H) $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(C_COMMON_H) $(TREE_GIMPLE_H) \\\n@@ -2845,7 +2845,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/cgraph.h \\\n   $(srcdir)/c-common.h $(srcdir)/c-tree.h $(srcdir)/reload.h \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n-  $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c\\\n+  $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c $(srcdir)/ipa-inline.c \\\n   $(srcdir)/dbxout.c $(srcdir)/dwarf2out.c $(srcdir)/dwarf2asm.c \\\n   $(srcdir)/dojump.c $(srcdir)/tree-profile.c \\\n   $(srcdir)/emit-rtl.c $(srcdir)/except.c $(srcdir)/explow.c $(srcdir)/expr.c \\\n@@ -2899,7 +2899,7 @@ gt-tree-profile.h gt-tree-ssa-address.h \\\n gt-tree-ssanames.h gt-tree-iterator.h gt-gimplify.h \\\n gt-tree-phinodes.h gt-tree-nested.h \\\n gt-tree-ssa-operands.h gt-tree-ssa-propagate.h \\\n-gt-tree-ssa-structalias.h \\\n+gt-tree-ssa-structalias.h gt-ipa-inline.h \\\n gt-stringpool.h gt-targhooks.h gt-omp-low.h : s-gtype ; @true\n \n define echo_quoted_to_gtyp"}, {"sha": "8d841b46e0d398d135929249b709496ddfd53e96", "filename": "gcc/cgraph.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fc428c75cc0b52a53f6f8231be83dd78dcec4e/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fc428c75cc0b52a53f6f8231be83dd78dcec4e/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=96fc428c75cc0b52a53f6f8231be83dd78dcec4e", "patch": "@@ -452,6 +452,9 @@ cgraph_remove_node (struct cgraph_node *node)\n \n   cgraph_node_remove_callers (node);\n   cgraph_node_remove_callees (node);\n+  /* Incremental inlining access removed nodes stored in the postorder list.\n+     */\n+  node->needed = node->reachable = false;\n   while (node->nested)\n     cgraph_remove_node (node->nested);\n   if (node->origin)\n@@ -468,6 +471,8 @@ cgraph_remove_node (struct cgraph_node *node)\n     cgraph_nodes = node->next;\n   if (node->next)\n     node->next->previous = node->previous;\n+  node->next = NULL;\n+  node->previous = NULL;\n   slot = htab_find_slot (cgraph_hash, node, NO_INSERT);\n   if (*slot == node)\n     {\n@@ -515,6 +520,7 @@ cgraph_remove_node (struct cgraph_node *node)\n       DECL_STRUCT_FUNCTION (node->decl) = NULL;\n       DECL_INITIAL (node->decl) = error_mark_node;\n     }\n+  node->decl = NULL;\n   cgraph_n_nodes--;\n   /* Do not free the structure itself so the walk over chain can continue.  */\n }"}, {"sha": "606cd75ef922495af460a86dc7f182bdf90a9b09", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fc428c75cc0b52a53f6f8231be83dd78dcec4e/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fc428c75cc0b52a53f6f8231be83dd78dcec4e/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=96fc428c75cc0b52a53f6f8231be83dd78dcec4e", "patch": "@@ -419,11 +419,14 @@ cgraph_reset_node (struct cgraph_node *node)\n \n   if (!flag_unit_at_a_time)\n     {\n-      struct cgraph_node *n;\n+      struct cgraph_node *n, *next;\n \n-      for (n = cgraph_nodes; n; n = n->next)\n-\tif (n->global.inlined_to == node)\n-\t  cgraph_remove_node (n);\n+      for (n = cgraph_nodes; n; n = next)\n+\t{\n+\t  next = n->next;\n+\t  if (n->global.inlined_to == node)\n+\t    cgraph_remove_node (n);\n+\t}\n     }\n \n   cgraph_node_remove_callees (node);\n@@ -1009,7 +1012,7 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n void\n cgraph_finalize_compilation_unit (void)\n {\n-  struct cgraph_node *node;\n+  struct cgraph_node *node, *next;\n   /* Keep track of already processed nodes when called multiple times for\n      intermodule optimization.  */\n   static struct cgraph_node *first_analyzed;\n@@ -1091,9 +1094,10 @@ cgraph_finalize_compilation_unit (void)\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"\\nReclaiming functions:\");\n \n-  for (node = cgraph_nodes; node != first_analyzed; node = node->next)\n+  for (node = cgraph_nodes; node != first_analyzed; node = next)\n     {\n       tree decl = node->decl;\n+      next = node->next;\n \n       if (node->local.finalized && !DECL_SAVED_TREE (decl))\n \tcgraph_reset_node (node);"}, {"sha": "6bbfcf0c00ed9e34f140d8d877ac3f22cb14128c", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fc428c75cc0b52a53f6f8231be83dd78dcec4e/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fc428c75cc0b52a53f6f8231be83dd78dcec4e/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=96fc428c75cc0b52a53f6f8231be83dd78dcec4e", "patch": "@@ -570,7 +570,7 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node)\n   int probability = PARAM_VALUE (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY);\n   fibheap_t heap;\n   struct cgraph_edge *e;\n-  struct cgraph_node *master_clone;\n+  struct cgraph_node *master_clone, *next;\n   int depth = 0;\n   int n = 0;\n \n@@ -671,9 +671,12 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node)\n      into master clone gets queued just before master clone so we don't\n      need recursion.  */\n   for (node = cgraph_nodes; node != master_clone;\n-       node = node->next)\n-    if (node->global.inlined_to == master_clone)\n-      cgraph_remove_node (node);\n+       node = next)\n+    {\n+      next = node->next;\n+      if (node->global.inlined_to == master_clone)\n+\tcgraph_remove_node (node);\n+    }\n   cgraph_remove_node (master_clone);\n   /* FIXME: Recursive inlining actually reduces number of calls of the\n      function.  At this place we should probably walk the function and\n@@ -1150,16 +1153,19 @@ struct tree_opt_pass pass_ipa_inline =\n   0\t\t\t\t\t/* letter */\n };\n \n+/* Because inlining might remove no-longer reachable nodes, we need to\n+   keep the array visible to garbage collector to avoid reading collected\n+   out nodes.  */\n+static int nnodes;\n+static GTY ((length (\"nnodes\"))) struct cgraph_node **order;\n+\n /* Do inlining of small functions.  Doing so early helps profiling and other\n    passes to be somewhat more effective and avoids some code duplication in\n    later real inlining pass for testcases with very many function calls.  */\n static unsigned int\n cgraph_early_inlining (void)\n {\n   struct cgraph_node *node;\n-  int nnodes;\n-  struct cgraph_node **order =\n-    XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n   int i;\n \n   if (sorrycount || errorcount)\n@@ -1169,6 +1175,7 @@ cgraph_early_inlining (void)\n     gcc_assert (!node->aux);\n #endif\n \n+  order = ggc_alloc (sizeof (*order) * cgraph_n_nodes);\n   nnodes = cgraph_postorder (order);\n   for (i = nnodes - 1; i >= 0; i--)\n     {\n@@ -1186,7 +1193,9 @@ cgraph_early_inlining (void)\n   for (node = cgraph_nodes; node; node = node->next)\n     gcc_assert (!node->global.inlined_to);\n #endif\n-  free (order);\n+  ggc_free (order);\n+  order = NULL;\n+  nnodes = 0;\n   return 0;\n }\n \n@@ -1213,3 +1222,5 @@ struct tree_opt_pass pass_early_ipa_inline =\n   TODO_dump_cgraph | TODO_dump_func,\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n+\n+#include \"gt-ipa-inline.h\""}, {"sha": "b78709bc1662fafdf617051af93b5842d1600efc", "filename": "gcc/ipa.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fc428c75cc0b52a53f6f8231be83dd78dcec4e/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fc428c75cc0b52a53f6f8231be83dd78dcec4e/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=96fc428c75cc0b52a53f6f8231be83dd78dcec4e", "patch": "@@ -97,7 +97,7 @@ bool\n cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n {\n   struct cgraph_node *first = (void *) 1;\n-  struct cgraph_node *node;\n+  struct cgraph_node *node, *next;\n   bool changed = false;\n   int insns = 0;\n \n@@ -151,8 +151,9 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n      unanalyzed nodes so they look like for true extern functions to the rest\n      of code.  Body of such functions is released via remove_node once the\n      inline clones are eliminated.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n+  for (node = cgraph_nodes; node; node = next)\n     {\n+      next = node->next;\n       if (!node->aux)\n \t{\n \t  int local_insns;"}]}