{"sha": "6b4db50158952b893df977aff9eb1b470edbc65a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI0ZGI1MDE1ODk1MmI4OTNkZjk3N2FmZjllYjFiNDcwZWRiYzY1YQ==", "commit": {"author": {"name": "Mikhail Maltsev", "email": "maltsevm@gmail.com", "date": "2015-06-22T02:54:11Z"}, "committer": {"name": "Mikhail Maltsev", "email": "miyuki@gcc.gnu.org", "date": "2015-06-22T02:54:11Z"}, "message": "Use std::swap instead of manual swaps.\n\ngcc/\n\t* auto-inc-dec.c (reverse_mem, reverse_inc): Remove.\n\t(parse_add_or_inc): Use std::swap instead of reverse_{mem,inc}.\n\t(find_inc): Likewise.\n\t* combine.c (combine_simplify_rtx): Use std::swap instead of manually\n\tswapping.\n\t* df-core.c (df_worklist_dataflow_doublequeue): Likewise.\n\t* df-scan.c (df_swap_refs): Remove.\n\t(df_sort_and_compress_refs): Use std::swap instead of df_swap_refs.\n\t* dominance.c (link_roots): Use std::swap instead of manually swapping.\n\t* expr.c (expand_expr_real_2, do_store_flag): Likewise.\n\t* fold-const.c (fold_relational_const): Likewise.\n\t* genattrtab.c (simplify_test_exp): Likewise.\n\t* gimple-match-head.c (gimple_resimplify2, gimple_resimplify3,\n\tgimple_simplify): Likewise.\n\t* ifcvt.c (noce_try_abs, find_if_header): Likewise.\n\t* internal-fn.c (expand_addsub_overflow, expand_mul_overflow): Likewise.\n\t* ipa-devirt.c (add_type_duplicate): Likewise.\n\t* loop-iv.c (get_biv_step_1, iv_number_of_iterations): Likewise.\n\t* lra-lives.c (lra_setup_reload_pseudo_preferenced_hard_reg): Likewise.\n\t* lra.c (lra_create_copy): Likewise.\n\t* lto-streamer-out.c (DFS::DFS): Likewise.\n\t* modulo-sched.c (get_sched_window): Likewise.\n\t* omega.c (omega_pretty_print_problem): Likewise.\n\t* optabs.c (prepare_float_lib_cmp, expand_mult_highpart): Likewise.\n\t* reload1.c (reloads_unique_chain_p): Likewise.\n\t* sel-sched-ir.c (exchange_lv_sets, exchange_av_sets): Remove.\n\t(exchange_data_sets): Move logic from exchange_{av,lv}_sets here and\n\tuse std::swap.\n\t* simplify-rtx.c (simplify_unary_operation_1): Use std::swap instead of\n\tmanually swapping.\n\t* tree-if-conv.c (is_cond_scalar_reduction, predicate_scalar_phi,\n\tpredicate_mem_writes): Likewise.\n\t* tree-loop-distribution.c (pg_add_dependence_edges): Likewise.\n\t* tree-predcom.c (combine_chains): Likewise.\n\t* tree-ssa-alias.c (nonoverlapping_component_refs_p,\n\trefs_may_alias_p_1): Likewise.\n\t* tree-ssa-ifcombine.c (recognize_if_then_else): Likewise.\n\t* tree-ssa-loop-ivopts.c (extract_cond_operands): Likewise.\n\t* tree-ssa-loop-niter.c (refine_bounds_using_guard,\n\tnumber_of_iterations_cond): Likewise.\n\t* tree-ssa-phiopt.c (tree_ssa_phiopt_worker): Likewise.\n\t* tree-ssa-sccvn.c (vn_nary_op_compute_hash): Likewise.\n\t* tree-vect-slp.c (vect_build_slp_tree): Likewise.\n\t* tree-vect-stmts.c (supportable_widening_operation): Likewise.\n\t* tree-vrp.c (extract_range_from_binary_expr_1,\n\textract_range_from_unary_expr_1): Likewise.\n\ngcc/cp/\n\t* pt.c (maybe_adjust_types_for_deduction): Use std::swap instead of\n\tmanually swapping.\n\t* semantics.c (finish_omp_atomic): Likewise.\n\t* typeck.c (cp_build_array_ref): Likewise.\n\ngcc/c-family/\n\t* c-common.c (scalar_to_vector): Use std::swap instead of manually\n\tswapping.\n\nFrom-SVN: r224718", "tree": {"sha": "1fec84ba7505f22e0323120d58fb1ce0b4713b21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fec84ba7505f22e0323120d58fb1ce0b4713b21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b4db50158952b893df977aff9eb1b470edbc65a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b4db50158952b893df977aff9eb1b470edbc65a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b4db50158952b893df977aff9eb1b470edbc65a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b4db50158952b893df977aff9eb1b470edbc65a/comments", "author": {"login": "miyuki", "id": 4668268, "node_id": "MDQ6VXNlcjQ2NjgyNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/4668268?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miyuki", "html_url": "https://github.com/miyuki", "followers_url": "https://api.github.com/users/miyuki/followers", "following_url": "https://api.github.com/users/miyuki/following{/other_user}", "gists_url": "https://api.github.com/users/miyuki/gists{/gist_id}", "starred_url": "https://api.github.com/users/miyuki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miyuki/subscriptions", "organizations_url": "https://api.github.com/users/miyuki/orgs", "repos_url": "https://api.github.com/users/miyuki/repos", "events_url": "https://api.github.com/users/miyuki/events{/privacy}", "received_events_url": "https://api.github.com/users/miyuki/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b40bfc067d47a0f93b4c262e1d9033bf906188fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b40bfc067d47a0f93b4c262e1d9033bf906188fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b40bfc067d47a0f93b4c262e1d9033bf906188fa"}], "stats": {"total": 512, "additions": 162, "deletions": 350}, "files": [{"sha": "737178ca0ca42a31a48a537da02978933af48466", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -1,3 +1,52 @@\n+2015-06-22  Mikhail Maltsev  <maltsevm@gmail.com>\n+\n+\t* auto-inc-dec.c (reverse_mem, reverse_inc): Remove.\n+\t(parse_add_or_inc): Use std::swap instead of reverse_{mem,inc}.\n+\t(find_inc): Likewise.\n+\t* combine.c (combine_simplify_rtx): Use std::swap instead of manually\n+\tswapping.\n+\t* df-core.c (df_worklist_dataflow_doublequeue): Likewise.\n+\t* df-scan.c (df_swap_refs): Remove.\n+\t(df_sort_and_compress_refs): Use std::swap instead of df_swap_refs.\n+\t* dominance.c (link_roots): Use std::swap instead of manually swapping.\n+\t* expr.c (expand_expr_real_2, do_store_flag): Likewise.\n+\t* fold-const.c (fold_relational_const): Likewise.\n+\t* genattrtab.c (simplify_test_exp): Likewise.\n+\t* gimple-match-head.c (gimple_resimplify2, gimple_resimplify3,\n+\tgimple_simplify): Likewise.\n+\t* ifcvt.c (noce_try_abs, find_if_header): Likewise.\n+\t* internal-fn.c (expand_addsub_overflow, expand_mul_overflow): Likewise.\n+\t* ipa-devirt.c (add_type_duplicate): Likewise.\n+\t* loop-iv.c (get_biv_step_1, iv_number_of_iterations): Likewise.\n+\t* lra-lives.c (lra_setup_reload_pseudo_preferenced_hard_reg): Likewise.\n+\t* lra.c (lra_create_copy): Likewise.\n+\t* lto-streamer-out.c (DFS::DFS): Likewise.\n+\t* modulo-sched.c (get_sched_window): Likewise.\n+\t* omega.c (omega_pretty_print_problem): Likewise.\n+\t* optabs.c (prepare_float_lib_cmp, expand_mult_highpart): Likewise.\n+\t* reload1.c (reloads_unique_chain_p): Likewise.\n+\t* sel-sched-ir.c (exchange_lv_sets, exchange_av_sets): Remove.\n+\t(exchange_data_sets): Move logic from exchange_{av,lv}_sets here and\n+\tuse std::swap.\n+\t* simplify-rtx.c (simplify_unary_operation_1): Use std::swap instead of\n+\tmanually swapping.\n+\t* tree-if-conv.c (is_cond_scalar_reduction, predicate_scalar_phi,\n+\tpredicate_mem_writes): Likewise.\n+\t* tree-loop-distribution.c (pg_add_dependence_edges): Likewise.\n+\t* tree-predcom.c (combine_chains): Likewise.\n+\t* tree-ssa-alias.c (nonoverlapping_component_refs_p,\n+\trefs_may_alias_p_1): Likewise.\n+\t* tree-ssa-ifcombine.c (recognize_if_then_else): Likewise.\n+\t* tree-ssa-loop-ivopts.c (extract_cond_operands): Likewise.\n+\t* tree-ssa-loop-niter.c (refine_bounds_using_guard,\n+\tnumber_of_iterations_cond): Likewise.\n+\t* tree-ssa-phiopt.c (tree_ssa_phiopt_worker): Likewise.\n+\t* tree-ssa-sccvn.c (vn_nary_op_compute_hash): Likewise.\n+\t* tree-vect-slp.c (vect_build_slp_tree): Likewise.\n+\t* tree-vect-stmts.c (supportable_widening_operation): Likewise.\n+\t* tree-vrp.c (extract_range_from_binary_expr_1,\n+\textract_range_from_unary_expr_1): Likewise.\n+\n 2015-06-20  Marek Polacek  <polacek@redhat.com>\n \n \t* common.opt (fsanitize-undefined-trap-on-error): Add Driver."}, {"sha": "df52229322d79e17bc07d73067c1488760c7fdb6", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -767,28 +767,6 @@ get_next_ref (int regno, basic_block bb, rtx_insn **next_array)\n }\n \n \n-/* Reverse the operands in a mem insn.  */\n-\n-static void\n-reverse_mem (void)\n-{\n-  rtx tmp = mem_insn.reg1;\n-  mem_insn.reg1 = mem_insn.reg0;\n-  mem_insn.reg0 = tmp;\n-}\n-\n-\n-/* Reverse the operands in a inc insn.  */\n-\n-static void\n-reverse_inc (void)\n-{\n-  rtx tmp = inc_insn.reg1;\n-  inc_insn.reg1 = inc_insn.reg0;\n-  inc_insn.reg0 = tmp;\n-}\n-\n-\n /* Return true if INSN is of a form \"a = b op c\" where a and b are\n    regs.  op is + if c is a reg and +|- if c is a const.  Fill in\n    INC_INSN with what is found.\n@@ -857,7 +835,7 @@ parse_add_or_inc (rtx_insn *insn, bool before_mem)\n \t{\n \t  /* Reverse the two operands and turn *_ADD into *_INC since\n \t     a = c + a.  */\n-\t  reverse_inc ();\n+\t  std::swap (inc_insn.reg0, inc_insn.reg1);\n \t  inc_insn.form = before_mem ? FORM_PRE_INC : FORM_POST_INC;\n \t  return true;\n \t}\n@@ -1017,7 +995,7 @@ find_inc (bool first_try)\n \t find this.  Only try it once though.  */\n       if (first_try && !mem_insn.reg1_is_const)\n \t{\n-\t  reverse_mem ();\n+\t  std::swap (mem_insn.reg0, mem_insn.reg1);\n \t  return find_inc (false);\n \t}\n       else\n@@ -1118,7 +1096,7 @@ find_inc (bool first_try)\n \t\t    return false;\n \n \t\t  if (!rtx_equal_p (mem_insn.reg0, inc_insn.reg0))\n-\t\t    reverse_inc ();\n+\t\t    std::swap (inc_insn.reg0, inc_insn.reg1);\n \t\t}\n \n \t      other_insn\n@@ -1168,7 +1146,7 @@ find_inc (bool first_try)\n \t\t  /* See comment above on find_inc (false) call.  */\n \t\t  if (first_try)\n \t\t    {\n-\t\t      reverse_mem ();\n+\t\t      std::swap (mem_insn.reg0, mem_insn.reg1);\n \t\t      return find_inc (false);\n \t\t    }\n \t\t  else\n@@ -1187,7 +1165,7 @@ find_inc (bool first_try)\n \t    {\n \t      /* We know that mem_insn.reg0 must equal inc_insn.reg1\n \t\t or else we would not have found the inc insn.  */\n-\t      reverse_mem ();\n+\t      std::swap (mem_insn.reg0, mem_insn.reg1);\n \t      if (!rtx_equal_p (mem_insn.reg0, inc_insn.reg0))\n \t\t{\n \t\t  /* See comment above on find_inc (false) call.  */\n@@ -1226,7 +1204,7 @@ find_inc (bool first_try)\n \t    {\n \t      if (first_try)\n \t\t{\n-\t\t  reverse_mem ();\n+\t\t  std::swap (mem_insn.reg0, mem_insn.reg1);\n \t\t  return find_inc (false);\n \t\t}\n \t      else"}, {"sha": "39de58a9ea59b370f76d1c2ca3760fd12fdce3a1", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -1,3 +1,8 @@\n+2015-06-22  Mikhail Maltsev  <maltsevm@gmail.com>\n+\n+\t* c-common.c (scalar_to_vector): Use std::swap instead of manually\n+\tswapping.\n+\n 2015-06-17  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* array-notation-common.c: Do not include input.h, line-map.h or is-a.h."}, {"sha": "c39a36deb30dc0c5cb6c92dea147ae9dfdcabbf7", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -12605,11 +12605,9 @@ scalar_to_vector (location_t loc, enum tree_code code, tree op0, tree op1,\n       /* What about UNLT_EXPR?  */\n \tif (TREE_CODE (type0) == VECTOR_TYPE)\n \t  {\n-\t    tree tmp;\n \t    ret = stv_secondarg;\n-\t    /* Swap TYPE0 with TYPE1 and OP0 with OP1  */\n-\t    tmp = type0; type0 = type1; type1 = tmp;\n-\t    tmp = op0; op0 = op1; op1 = tmp;\n+\t    std::swap (type0, type1);\n+\t    std::swap (op0, op1);\n \t  }\n \n \tif (TREE_CODE (type0) == INTEGER_TYPE"}, {"sha": "f3802d7379a22b6eb9790cac3566ea2b32f477f6", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -5684,11 +5684,7 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,\n \t  /* Make sure we pass the constant operand if any as the second\n \t     one if this is a commutative operation.  */\n \t  if (CONSTANT_P (inner_op0) && COMMUTATIVE_ARITH_P (x))\n-\t    {\n-\t      rtx tem = inner_op0;\n-\t      inner_op0 = inner_op1;\n-\t      inner_op1 = tem;\n-\t    }\n+\t    std::swap (inner_op0, inner_op1);\n \t  inner = simplify_binary_operation (code == MINUS ? PLUS\n \t\t\t\t\t     : code == DIV ? MULT\n \t\t\t\t\t     : code,"}, {"sha": "7b3cd2ce7209e5141a5f29e40767d7b69f029784", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -1,3 +1,10 @@\n+2015-06-22  Mikhail Maltsev  <maltsevm@gmail.com>\n+\n+\t* pt.c (maybe_adjust_types_for_deduction): Use std::swap instead of\n+\tmanually swapping.\n+\t* semantics.c (finish_omp_atomic): Likewise.\n+\t* typeck.c (cp_build_array_ref): Likewise.\n+\n 2015-06-20  Mikhail Maltsev  <maltsevm@gmail.com>\n \n \tPR c++/65882"}, {"sha": "8800af819ec7ffde1ccc8453effc8b50a7857bec", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -16545,15 +16545,11 @@ maybe_adjust_types_for_deduction (unification_kind_t strict,\n       break;\n \n     case DEDUCE_CONV:\n-      {\n-\t/* Swap PARM and ARG throughout the remainder of this\n-\t   function; the handling is precisely symmetric since PARM\n-\t   will initialize ARG rather than vice versa.  */\n-\ttree* temp = parm;\n-\tparm = arg;\n-\targ = temp;\n-\tbreak;\n-      }\n+      /* Swap PARM and ARG throughout the remainder of this\n+\t function; the handling is precisely symmetric since PARM\n+\t will initialize ARG rather than vice versa.  */\n+      std::swap (parm, arg);\n+      break;\n \n     case DEDUCE_EXACT:\n       /* Core issue #873: Do the DR606 thing (see below) for these cases,"}, {"sha": "aeb5f7ba29848db5c039a0db46027ffe0c0c2d38", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -6870,9 +6870,7 @@ finish_omp_atomic (enum tree_code code, enum tree_code opcode, tree lhs,\n       bool swapped = false;\n       if (rhs1 && cp_tree_equal (lhs, rhs))\n \t{\n-\t  tree tem = rhs;\n-\t  rhs = rhs1;\n-\t  rhs1 = tem;\n+\t  std::swap (rhs, rhs1);\n \t  swapped = !commutative_tree_code (opcode);\n \t}\n       if (rhs1 && !cp_tree_equal (lhs, rhs1))"}, {"sha": "5b3fdfbf76b79ee345084e66d47348cdf2cfcf1b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -3179,11 +3179,7 @@ cp_build_array_ref (location_t loc, tree array, tree idx,\n \n     /* Put the integer in IND to simplify error checking.  */\n     if (TREE_CODE (TREE_TYPE (ar)) == INTEGER_TYPE)\n-      {\n-\ttree temp = ar;\n-\tar = ind;\n-\tind = temp;\n-      }\n+      std::swap (ar, ind);\n \n     if (ar == error_mark_node || ind == error_mark_node)\n       return error_mark_node;"}, {"sha": "ea1f16842a2f319c898430b8333f2ebc937916aa", "filename": "gcc/df-core.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -1043,10 +1043,7 @@ df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n       bitmap_iterator bi;\n       unsigned int index;\n \n-      /* Swap pending and worklist. */\n-      bitmap temp = worklist;\n-      worklist = pending;\n-      pending = temp;\n+      std::swap (pending, worklist);\n \n       EXECUTE_IF_SET_IN_BITMAP (worklist, 0, index, bi)\n \t{"}, {"sha": "ef9cdbbbe32ca414fee3504626e3e83dc694fc0a", "filename": "gcc/df-scan.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -2133,14 +2133,6 @@ df_ref_ptr_compare (const void *r1, const void *r2)\n   return df_ref_compare (*(const df_ref *) r1, *(const df_ref *) r2);\n }\n \n-static void\n-df_swap_refs (vec<df_ref, va_heap> *ref_vec, int i, int j)\n-{\n-  df_ref tmp = (*ref_vec)[i];\n-  (*ref_vec)[i] = (*ref_vec)[j];\n-  (*ref_vec)[j] = tmp;\n-}\n-\n /* Sort and compress a set of refs.  */\n \n static void\n@@ -2160,7 +2152,7 @@ df_sort_and_compress_refs (vec<df_ref, va_heap> *ref_vec)\n       df_ref r0 = (*ref_vec)[0];\n       df_ref r1 = (*ref_vec)[1];\n       if (df_ref_compare (r0, r1) > 0)\n-        df_swap_refs (ref_vec, 0, 1);\n+\tstd::swap ((*ref_vec)[0], (*ref_vec)[1]);\n     }\n   else\n     {"}, {"sha": "a9e042ef4b56b849c4c05febee39ad2e0d9c0adc", "filename": "gcc/dominance.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -484,11 +484,7 @@ link_roots (struct dom_info *di, TBB v, TBB w)\n   di->path_min[s] = di->path_min[w];\n   di->set_size[v] += di->set_size[w];\n   if (di->set_size[v] < 2 * di->set_size[w])\n-    {\n-      TBB tmp = s;\n-      s = di->set_child[v];\n-      di->set_child[v] = tmp;\n-    }\n+    std::swap (di->set_child[v], s);\n \n   /* Merge all subtrees.  */\n   while (s)"}, {"sha": "78904c24bf27630fa3e25e80884a3bea94718570", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -8426,11 +8426,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t Thus the following special case checks need only\n \t check the second operand.  */\n       if (TREE_CODE (treeop0) == INTEGER_CST)\n-\t{\n-\t  tree t1 = treeop0;\n-\t  treeop0 = treeop1;\n-\t  treeop1 = t1;\n-\t}\n+\tstd::swap (treeop0, treeop1);\n \n       /* First, check if we have a multiplication of one signed and one\n \t unsigned operand.  */\n@@ -8555,11 +8551,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t    def0 = get_def_for_expr (treeop1, NEGATE_EXPR);\n \t    /* Swap operands if the 2nd operand is fed by a negate.  */\n \t    if (def0)\n-\t      {\n-\t\ttree tem = treeop0;\n-\t\ttreeop0 = treeop1;\n-\t\ttreeop1 = tem;\n-\t      }\n+\t      std::swap (treeop0, treeop1);\n \t  }\n \tdef2 = get_def_for_expr (treeop2, NEGATE_EXPR);\n \n@@ -8606,11 +8598,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t Thus the following special case checks need only\n \t check the second operand.  */\n       if (TREE_CODE (treeop0) == INTEGER_CST)\n-\t{\n-\t  tree t1 = treeop0;\n-\t  treeop0 = treeop1;\n-\t  treeop1 = t1;\n-\t}\n+\tstd::swap (treeop0, treeop1);\n \n       /* Attempt to return something suitable for generating an\n \t indexed address, for machines that support that.  */\n@@ -10910,7 +10898,6 @@ do_store_flag (sepops ops, rtx target, machine_mode mode)\n {\n   enum rtx_code code;\n   tree arg0, arg1, type;\n-  tree tem;\n   machine_mode operand_mode;\n   int unsignedp;\n   rtx op0, op1;\n@@ -11033,7 +11020,7 @@ do_store_flag (sepops ops, rtx target, machine_mode mode)\n   if (TREE_CODE (arg0) == REAL_CST || TREE_CODE (arg0) == INTEGER_CST\n       || TREE_CODE (arg0) == FIXED_CST)\n     {\n-      tem = arg0; arg0 = arg1; arg1 = tem;\n+      std::swap (arg0, arg1);\n       code = swap_condition (code);\n     }\n "}, {"sha": "60aa210496005041d7f8e7bf1920dad9e79b898f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -15664,9 +15664,7 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n \n   if (code == LE_EXPR || code == GT_EXPR)\n     {\n-      tree tem = op0;\n-      op0 = op1;\n-      op1 = tem;\n+      std::swap (op0, op1);\n       code = swap_tree_comparison (code);\n     }\n "}, {"sha": "85ec738a9a433435c3b2cd589777eab47f27e30f", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -2532,11 +2532,7 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n \t  && compute_alternative_mask (right, IOR))\n \t{\n \t  if (GET_CODE (left) == IOR)\n-\t    {\n-\t      rtx tem = left;\n-\t      left = right;\n-\t      right = tem;\n-\t    }\n+\t    std::swap (left, right);\n \n \t  newexp = attr_rtx (IOR,\n \t\t\t     attr_rtx (AND, left, XEXP (right, 0)),"}, {"sha": "7b1f1ace8f9f91f7469d11c6870a5add2a6de36b", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -190,9 +190,7 @@ gimple_resimplify2 (gimple_seq *seq,\n \t  || commutative_tree_code (*res_code))\n       && tree_swap_operands_p (res_ops[0], res_ops[1], false))\n     {\n-      tree tem = res_ops[0];\n-      res_ops[0] = res_ops[1];\n-      res_ops[1] = tem;\n+      std::swap (res_ops[0], res_ops[1]);\n       if (TREE_CODE_CLASS ((enum tree_code) *res_code) == tcc_comparison)\n \t*res_code = swap_tree_comparison (*res_code);\n       canonicalized = true;\n@@ -262,9 +260,7 @@ gimple_resimplify3 (gimple_seq *seq,\n       && commutative_ternary_tree_code (*res_code)\n       && tree_swap_operands_p (res_ops[0], res_ops[1], false))\n     {\n-      tree tem = res_ops[0];\n-      res_ops[0] = res_ops[1];\n-      res_ops[1] = tem;\n+      std::swap (res_ops[0], res_ops[1]);\n       canonicalized = true;\n     }\n \n@@ -427,9 +423,7 @@ gimple_simplify (enum tree_code code, tree type,\n        || TREE_CODE_CLASS (code) == tcc_comparison)\n       && tree_swap_operands_p (op0, op1, false))\n     {\n-      tree tem = op0;\n-      op0 = op1;\n-      op1 = tem;\n+      std::swap (op0, op1);\n       if (TREE_CODE_CLASS (code) == tcc_comparison)\n \tcode = swap_tree_comparison (code);\n     }\n@@ -462,11 +456,7 @@ gimple_simplify (enum tree_code code, tree type,\n      generation.  */\n   if (commutative_ternary_tree_code (code)\n       && tree_swap_operands_p (op0, op1, false))\n-    {\n-      tree tem = op0;\n-      op0 = op1;\n-      op1 = tem;\n-    }\n+    std::swap (op0, op1);\n \n   code_helper rcode;\n   tree ops[3] = {};"}, {"sha": "7d4ad934003165a4d8ad672aa379563ba65b9f33", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -2065,7 +2065,7 @@ noce_try_abs (struct noce_if_info *if_info)\n     negate = 0;\n   else if (GET_CODE (b) == NEG && rtx_equal_p (XEXP (b, 0), a))\n     {\n-      c = a; a = b; b = c;\n+      std::swap (a, b);\n       negate = 1;\n     }\n   else if (GET_CODE (a) == NOT && rtx_equal_p (XEXP (a, 0), b))\n@@ -2075,7 +2075,7 @@ noce_try_abs (struct noce_if_info *if_info)\n     }\n   else if (GET_CODE (b) == NOT && rtx_equal_p (XEXP (b, 0), a))\n     {\n-      c = a; a = b; b = c;\n+      std::swap (a, b);\n       negate = 1;\n       one_cmpl = true;\n     }\n@@ -3390,11 +3390,7 @@ find_if_header (basic_block test_bb, int pass)\n   if (then_edge->flags & EDGE_FALLTHRU)\n     ;\n   else if (else_edge->flags & EDGE_FALLTHRU)\n-    {\n-      edge e = else_edge;\n-      else_edge = then_edge;\n-      then_edge = e;\n-    }\n+    std::swap (then_edge, else_edge);\n   else\n     /* Otherwise this must be a multiway branch of some sort.  */\n     return NULL;"}, {"sha": "c398c125bcf7e46c3724d8360b8a7d93bbf25a86", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -526,14 +526,10 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n       /* PLUS_EXPR is commutative, if operand signedness differs,\n \t canonicalize to the first operand being signed and second\n \t unsigned to simplify following code.  */\n-      rtx tem = op1;\n-      op1 = op0;\n-      op0 = tem;\n-      tree t = arg1;\n-      arg1 = arg0;\n-      arg0 = t;\n-      uns0_p = 0;\n-      uns1_p = 1;\n+      std::swap (op0, op1);\n+      std::swap (arg0, arg1);\n+      uns0_p = false;\n+      uns1_p = true;\n     }\n \n   /* u1 +- u2 -> ur  */\n@@ -674,9 +670,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t  int pos_neg0 = get_range_pos_neg (arg0);\n \t  if (pos_neg0 != 3 && pos_neg == 3)\n \t    {\n-\t      rtx tem = op1;\n-\t      op1 = op0;\n-\t      op0 = tem;\n+\t      std::swap (op0, op1);\n \t      pos_neg = pos_neg0;\n \t    }\n \t}\n@@ -781,22 +775,14 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t do_compare_rtx_and_jump will be just folded.  Otherwise try\n \t to use range info if available.  */\n       if (code == PLUS_EXPR && CONST_INT_P (op0))\n-\t{\n-\t  rtx tem = op0;\n-\t  op0 = op1;\n-\t  op1 = tem;\n-\t}\n+\tstd::swap (op0, op1);\n       else if (CONST_INT_P (op1))\n \t;\n       else if (code == PLUS_EXPR && TREE_CODE (arg0) == SSA_NAME)\n \t{\n \t  pos_neg = get_range_pos_neg (arg0);\n \t  if (pos_neg != 3)\n-\t    {\n-\t      rtx tem = op0;\n-\t      op0 = op1;\n-\t      op1 = tem;\n-\t    }\n+\t    std::swap (op0, op1);\n \t}\n       if (pos_neg == 3 && !CONST_INT_P (op1) && TREE_CODE (arg1) == SSA_NAME)\n \tpos_neg = get_range_pos_neg (arg1);\n@@ -1023,14 +1009,10 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n       /* Multiplication is commutative, if operand signedness differs,\n \t canonicalize to the first operand being signed and second\n \t unsigned to simplify following code.  */\n-      rtx tem = op1;\n-      op1 = op0;\n-      op0 = tem;\n-      tree t = arg1;\n-      arg1 = arg0;\n-      arg0 = t;\n-      uns0_p = 0;\n-      uns1_p = 1;\n+      std::swap (op0, op1);\n+      std::swap (arg0, arg1);\n+      uns0_p = false;\n+      uns1_p = true;\n     }\n \n   int pos_neg0 = get_range_pos_neg (arg0);"}, {"sha": "1bf4b1acb6b401b468f41c344575a67bc06802b2", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -1846,12 +1846,7 @@ add_type_duplicate (odr_type val, tree type)\n     }\n \n   if (prevail)\n-    {\n-      tree tmp = type;\n-\n-      type = val->type;\n-      val->type = tmp;\n-    }\n+    std::swap (val->type, type);\n \n   val->types_set->add (type);\n "}, {"sha": "c0d6a1d3f3fc85a686f808a6c66f0c51fd4544fd", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -664,7 +664,7 @@ get_biv_step_1 (df_ref def, rtx reg,\n \t\trtx *outer_step)\n {\n   rtx set, rhs, op0 = NULL_RTX, op1 = NULL_RTX;\n-  rtx next, nextr, tmp;\n+  rtx next, nextr;\n   enum rtx_code code;\n   rtx_insn *insn = DF_REF_INSN (def);\n   df_ref next_def;\n@@ -694,9 +694,7 @@ get_biv_step_1 (df_ref def, rtx reg,\n       op1 = XEXP (rhs, 1);\n \n       if (code == PLUS && CONSTANT_P (op0))\n-\t{\n-\t  tmp = op0; op0 = op1; op1 = tmp;\n-\t}\n+\tstd::swap (op0, op1);\n \n       if (!simple_reg_p (op0)\n \t  || !CONSTANT_P (op1))\n@@ -2347,7 +2345,7 @@ iv_number_of_iterations (struct loop *loop, rtx_insn *insn, rtx condition,\n \t\t\t struct niter_desc *desc)\n {\n   rtx op0, op1, delta, step, bound, may_xform, tmp, tmp0, tmp1;\n-  struct rtx_iv iv0, iv1, tmp_iv;\n+  struct rtx_iv iv0, iv1;\n   rtx assumption, may_not_xform;\n   enum rtx_code cond;\n   machine_mode mode, comp_mode;\n@@ -2410,7 +2408,7 @@ iv_number_of_iterations (struct loop *loop, rtx_insn *insn, rtx condition,\n       case GT:\n       case GEU:\n       case GTU:\n-\ttmp_iv = iv0; iv0 = iv1; iv1 = tmp_iv;\n+\tstd::swap (iv0, iv1);\n \tcond = swap_condition (cond);\n \tbreak;\n       case NE:"}, {"sha": "16e1f386b3e620b047753c55fe1835ae821d224a", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -572,16 +572,10 @@ lra_setup_reload_pseudo_preferenced_hard_reg (int regno,\n       && (lra_reg_info[regno].preferred_hard_regno_profit2\n \t  > lra_reg_info[regno].preferred_hard_regno_profit1))\n     {\n-      int temp;\n-\n-      temp = lra_reg_info[regno].preferred_hard_regno1;\n-      lra_reg_info[regno].preferred_hard_regno1\n-\t= lra_reg_info[regno].preferred_hard_regno2;\n-      lra_reg_info[regno].preferred_hard_regno2 = temp;\n-      temp = lra_reg_info[regno].preferred_hard_regno_profit1;\n-      lra_reg_info[regno].preferred_hard_regno_profit1\n-\t= lra_reg_info[regno].preferred_hard_regno_profit2;\n-      lra_reg_info[regno].preferred_hard_regno_profit2 = temp;\n+      std::swap (lra_reg_info[regno].preferred_hard_regno1,\n+\t\t lra_reg_info[regno].preferred_hard_regno2);\n+      std::swap (lra_reg_info[regno].preferred_hard_regno_profit1,\n+\t\t lra_reg_info[regno].preferred_hard_regno_profit2);\n     }\n   if (lra_dump_file != NULL)\n     {"}, {"sha": "5d1f429658f5b7c6a306e560a93bae246665f295", "filename": "gcc/lra.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -1377,11 +1377,8 @@ lra_create_copy (int regno1, int regno2, int freq)\n   regno1_dest_p = true;\n   if (regno1 > regno2)\n     {\n-      int temp = regno2;\n-\n+      std::swap (regno1, regno2);\n       regno1_dest_p = false;\n-      regno2 = regno1;\n-      regno1 = temp;\n     }\n   cp = new lra_copy ();\n   copy_vec.safe_push (cp);"}, {"sha": "363da4c02d7c52a97ce97fe5596bb59635227596", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -608,11 +608,8 @@ DFS::DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n \t\t    }\n \t\t}\n \t      for (unsigned i = 0; i < scc_entry_len; ++i)\n-\t\t{\n-\t\t  scc_entry tem = sccstack[first + i];\n-\t\t  sccstack[first + i] = sccstack[first + entry_start + i];\n-\t\t  sccstack[first + entry_start + i] = tem;\n-\t\t}\n+\t\tstd::swap (sccstack[first + i],\n+\t\t\t   sccstack[first + entry_start + i]);\n \n \t      if (scc_entry_len == 1)\n \t\t; /* We already sorted SCC deterministically in hash_scc.  */"}, {"sha": "60b39f81d180f13f77462956c0fae446d3b4bf39", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -2006,9 +2006,7 @@ get_sched_window (partial_schedule_ptr ps, ddg_node_ptr u_node,\n      node close to its successors.  */\n   if (pss_not_empty && count_succs >= count_preds)\n     {\n-      int tmp = end;\n-      end = start;\n-      start = tmp;\n+      std::swap (start, end);\n       step = -1;\n     }\n "}, {"sha": "829520a338ad65c1f313140ece256179d2e0fccd", "filename": "gcc/omega.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fomega.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fomega.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomega.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -547,11 +547,7 @@ omega_pretty_print_problem (FILE *file, omega_pb pb)\n \t\telse\n \t\t  {\n \t\t    if (pb->geqs[e].coef[v1] == 1)\n-\t\t      {\n-\t\t\tv3 = v2;\n-\t\t\tv2 = v1;\n-\t\t\tv1 = v3;\n-\t\t      }\n+\t\t      std::swap (v1, v2);\n \n \t\t    /* Relation is v1 <= v2 or v1 < v2.  */\n \t\t    po[v1][v2] = ((pb->geqs[e].coef[0] == 0) ? le : lt);"}, {"sha": "491341b888773257293c1409f8bd77cf0ee7205d", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -4383,8 +4383,7 @@ prepare_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison,\n       if (code_to_optab (swapped)\n \t  && (libfunc = optab_libfunc (code_to_optab (swapped), mode)))\n \t{\n-\t  rtx tmp;\n-\t  tmp = x; x = y; y = tmp;\n+\t  std::swap (x, y);\n \t  comparison = swapped;\n \t  break;\n \t}\n@@ -6967,11 +6966,7 @@ expand_mult_highpart (machine_mode mode, rtx op0, rtx op1,\n       tab1 = uns_p ? vec_widen_umult_lo_optab : vec_widen_smult_lo_optab;\n       tab2 = uns_p ? vec_widen_umult_hi_optab : vec_widen_smult_hi_optab;\n       if (BYTES_BIG_ENDIAN)\n-\t{\n-\t  optab t = tab1;\n-\t  tab1 = tab2;\n-\t  tab2 = t;\n-\t}\n+\tstd::swap (tab1, tab2);\n       break;\n     default:\n       gcc_unreachable ();"}, {"sha": "57837a1fc90871bb3c3cf042b0ac8f71decf7f23", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -5612,11 +5612,7 @@ reloads_unique_chain_p (int r1, int r2)\n \n   /* The following loop assumes that r1 is the reload that feeds r2.  */\n   if (r1 > r2)\n-    {\n-      int tmp = r2;\n-      r2 = r1;\n-      r1 = tmp;\n-    }\n+    std::swap (r1, r2);\n \n   for (i = 0; i < n_reloads; i ++)\n     /* Look for input reloads that aren't our two */"}, {"sha": "f9b7655af121f65fb0b083dc36ff62cae4228ba5", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 7, "deletions": 41, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -4414,51 +4414,17 @@ free_data_sets (basic_block bb)\n   free_av_set (bb);\n }\n \n-/* Exchange lv sets of TO and FROM.  */\n-static void\n-exchange_lv_sets (basic_block to, basic_block from)\n-{\n-  {\n-    regset to_lv_set = BB_LV_SET (to);\n-\n-    BB_LV_SET (to) = BB_LV_SET (from);\n-    BB_LV_SET (from) = to_lv_set;\n-  }\n-\n-  {\n-    bool to_lv_set_valid_p = BB_LV_SET_VALID_P (to);\n-\n-    BB_LV_SET_VALID_P (to) = BB_LV_SET_VALID_P (from);\n-    BB_LV_SET_VALID_P (from) = to_lv_set_valid_p;\n-  }\n-}\n-\n-\n-/* Exchange av sets of TO and FROM.  */\n-static void\n-exchange_av_sets (basic_block to, basic_block from)\n-{\n-  {\n-    av_set_t to_av_set = BB_AV_SET (to);\n-\n-    BB_AV_SET (to) = BB_AV_SET (from);\n-    BB_AV_SET (from) = to_av_set;\n-  }\n-\n-  {\n-    int to_av_level = BB_AV_LEVEL (to);\n-\n-    BB_AV_LEVEL (to) = BB_AV_LEVEL (from);\n-    BB_AV_LEVEL (from) = to_av_level;\n-  }\n-}\n-\n /* Exchange data sets of TO and FROM.  */\n void\n exchange_data_sets (basic_block to, basic_block from)\n {\n-  exchange_lv_sets (to, from);\n-  exchange_av_sets (to, from);\n+  /* Exchange lv sets of TO and FROM.  */\n+  std::swap (BB_LV_SET (from), BB_LV_SET (to));\n+  std::swap (BB_LV_SET_VALID_P (from), BB_LV_SET_VALID_P (to));\n+\n+  /* Exchange av sets of TO and FROM.  */\n+  std::swap (BB_AV_SET (from), BB_AV_SET (to));\n+  std::swap (BB_AV_LEVEL (from), BB_AV_LEVEL (to));\n }\n \n /* Copy data sets of FROM to TO.  */"}, {"sha": "521fecf566e7e0ee04c0c343afa255a819ec5d70", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -944,10 +944,7 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \t  in2 = simplify_gen_unary (NOT, op_mode, in2, op_mode);\n \n \t  if (GET_CODE (in2) == NOT && GET_CODE (in1) != NOT)\n-\t    {\n-\t      rtx tem = in2;\n-\t      in2 = in1; in1 = tem;\n-\t    }\n+\t    std::swap (in1, in2);\n \n \t  return gen_rtx_fmt_ee (GET_CODE (op) == IOR ? AND : IOR,\n \t\t\t\t mode, in1, in2);"}, {"sha": "e0ac936d72cfb2a4878452e2725e1475cd6ba137", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -1510,11 +1510,7 @@ is_cond_scalar_reduction (gimple phi, gimple *reduc, tree arg_0, tree arg_1,\n   /* Make R_OP1 to hold reduction variable.  */\n   if (r_op2 == PHI_RESULT (header_phi)\n       && reduction_op == PLUS_EXPR)\n-    {\n-      tree tmp = r_op1;\n-      r_op1 = r_op2;\n-      r_op2 = tmp;\n-    }\n+    std::swap (r_op1, r_op2);\n   else if (r_op1 != PHI_RESULT (header_phi))\n     return false;\n \n@@ -1708,11 +1704,7 @@ predicate_scalar_phi (gphi *phi, gimple_stmt_iterator *gsi)\n       second_edge = EDGE_PRED (bb, 1);\n       cond = bb_predicate (first_edge->src);\n       if (TREE_CODE (cond) == TRUTH_NOT_EXPR)\n-\t{\n-\t  edge tmp_edge = first_edge;\n-\t  first_edge = second_edge;\n-\t  second_edge = tmp_edge;\n-\t}\n+\tstd::swap (first_edge, second_edge);\n       if (EDGE_COUNT (first_edge->src->succs) > 1)\n \t{\n \t  cond = bb_predicate (second_edge->src);\n@@ -1795,11 +1787,7 @@ predicate_scalar_phi (gphi *phi, gimple_stmt_iterator *gsi)\n \n   /* Put element with max number of occurences to the end of ARGS.  */\n   if (max_ind != -1 && max_ind +1 != (int) args_len)\n-    {\n-      tree tmp = args[args_len - 1];\n-      args[args_len - 1] = args[max_ind];\n-      args[max_ind] = tmp;\n-    }\n+    std::swap (args[args_len - 1], args[max_ind]);\n \n   /* Handle one special case when number of arguments with different values\n      is equal 2 and one argument has the only occurrence.  Such PHI can be\n@@ -2174,11 +2162,7 @@ predicate_mem_writes (loop_p loop)\n \t    lhs = ifc_temp_var (type, unshare_expr (lhs), &gsi);\n \t    rhs = ifc_temp_var (type, unshare_expr (rhs), &gsi);\n \t    if (swap)\n-\t      {\n-\t\ttree tem = lhs;\n-\t\tlhs = rhs;\n-\t\trhs = tem;\n-\t      }\n+\t      std::swap (lhs, rhs);\n \t    cond = force_gimple_operand_gsi_1 (&gsi, unshare_expr (cond),\n \t\t\t\t\t       is_gimple_condexpr, NULL_TREE,\n \t\t\t\t\t       true, GSI_SAME_STMT);"}, {"sha": "19523b941d2a52de888d61103cf33f0e5af5d7d0", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -1360,9 +1360,7 @@ pg_add_dependence_edges (struct graph *rdg, vec<loop_p> loops, int dir,\n \tif (rdg_vertex_for_stmt (rdg, DR_STMT (dr1))\n \t    > rdg_vertex_for_stmt (rdg, DR_STMT (dr2)))\n \t  {\n-\t    data_reference_p tem = dr1;\n-\t    dr1 = dr2;\n-\t    dr2 = tem;\n+\t    std::swap (dr1, dr2);\n \t    this_dir = -this_dir;\n \t  }\n \tddr = initialize_data_dependence_relation (dr1, dr2, loops);\n@@ -1373,9 +1371,7 @@ pg_add_dependence_edges (struct graph *rdg, vec<loop_p> loops, int dir,\n \t  {\n \t    if (DDR_REVERSED_P (ddr))\n \t      {\n-\t\tdata_reference_p tem = dr1;\n-\t\tdr1 = dr2;\n-\t\tdr2 = tem;\n+\t\tstd::swap (dr1, dr2);\n \t\tthis_dir = -this_dir;\n \t      }\n \t    /* Known dependences can still be unordered througout the"}, {"sha": "eadad7e0ad2bd3eea4fe49e5eeb5270c70fcc831", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -2301,11 +2301,7 @@ combine_chains (chain_p ch1, chain_p ch2)\n     }\n \n   if (swap)\n-    {\n-      chain_p tmp = ch1;\n-      ch1 = ch2;\n-      ch2 = tmp;\n-    }\n+    std::swap (ch1, ch2);\n \n   new_chain = XCNEW (struct chain);\n   new_chain->type = CT_COMBINATION;"}, {"sha": "a1f0beeae6331790610ad8de6fb9b8eb08aaea2b", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -953,23 +953,15 @@ nonoverlapping_component_refs_p (const_tree x, const_tree y)\n   if (fieldsx.length () == 2)\n     {\n       if (ncr_compar (&fieldsx[0], &fieldsx[1]) == 1)\n-\t{\n-\t  const_tree tem = fieldsx[0];\n-\t  fieldsx[0] = fieldsx[1];\n-\t  fieldsx[1] = tem;\n-\t}\n+\tstd::swap (fieldsx[0], fieldsx[1]);\n     }\n   else\n     fieldsx.qsort (ncr_compar);\n \n   if (fieldsy.length () == 2)\n     {\n       if (ncr_compar (&fieldsy[0], &fieldsy[1]) == 1)\n-\t{\n-\t  const_tree tem = fieldsy[0];\n-\t  fieldsy[0] = fieldsy[1];\n-\t  fieldsy[1] = tem;\n-\t}\n+\tstd::swap (fieldsy[0], fieldsy[1]);\n     }\n   else\n     fieldsy.qsort (ncr_compar);\n@@ -1426,13 +1418,10 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n   /* Canonicalize the pointer-vs-decl case.  */\n   if (ind1_p && var2_p)\n     {\n-      HOST_WIDE_INT tmp1;\n-      tree tmp2;\n-      ao_ref *tmp3;\n-      tmp1 = offset1; offset1 = offset2; offset2 = tmp1;\n-      tmp1 = max_size1; max_size1 = max_size2; max_size2 = tmp1;\n-      tmp2 = base1; base1 = base2; base2 = tmp2;\n-      tmp3 = ref1; ref1 = ref2; ref2 = tmp3;\n+      std::swap (offset1, offset2);\n+      std::swap (max_size1, max_size2);\n+      std::swap (base1, base2);\n+      std::swap (ref1, ref2);\n       var1_p = true;\n       ind1_p = false;\n       var2_p = false;"}, {"sha": "f55a4528d4915d0560178549ac972d3965e48ba7", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -98,11 +98,7 @@ recognize_if_then_else (basic_block cond_bb,\n   t = EDGE_SUCC (cond_bb, 0);\n   e = EDGE_SUCC (cond_bb, 1);\n   if (!(t->flags & EDGE_TRUE_VALUE))\n-    {\n-      edge tmp = t;\n-      t = e;\n-      e = tmp;\n-    }\n+    std::swap (t, e);\n   if (!(t->flags & EDGE_TRUE_VALUE)\n       || !(e->flags & EDGE_FALSE_VALUE))\n     return false;"}, {"sha": "cab5acfc8d5b106ffdf5bc244995ee8fe2773be2", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -1485,8 +1485,8 @@ extract_cond_operands (struct ivopts_data *data, gimple stmt,\n   /* The objects returned when COND has constant operands.  */\n   static struct iv const_iv;\n   static tree zero;\n-  tree *op0 = &zero, *op1 = &zero, *tmp_op;\n-  struct iv *iv0 = &const_iv, *iv1 = &const_iv, *tmp_iv;\n+  tree *op0 = &zero, *op1 = &zero;\n+  struct iv *iv0 = &const_iv, *iv1 = &const_iv;\n   bool ret = false;\n \n   if (gimple_code (stmt) == GIMPLE_COND)\n@@ -1517,8 +1517,8 @@ extract_cond_operands (struct ivopts_data *data, gimple stmt,\n   if (integer_zerop (iv0->step))\n     {\n       /* Control variable may be on the other side.  */\n-      tmp_op = op0; op0 = op1; op1 = tmp_op;\n-      tmp_iv = iv0; iv0 = iv1; iv1 = tmp_iv;\n+      std::swap (op0, op1);\n+      std::swap (iv0, iv1);\n     }\n   ret = !integer_zerop (iv0->step) && integer_zerop (iv1->step);\n "}, {"sha": "213d72e3dc4af903b83a1fe84b9ab2f8bb23639f", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -73,8 +73,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"wide-int-print.h\"\n \n \n-#define SWAP(X, Y) do { affine_iv *tmp = (X); (X) = (Y); (Y) = tmp; } while (0)\n-\n /* The maximum number of dominator BBs we search for conditions\n    of loop header copies we use for simplifying a conditional\n    expression.  */\n@@ -301,7 +299,7 @@ refine_bounds_using_guard (tree type, tree varx, mpz_t offx,\n \t\t\t   tree c0, enum tree_code cmp, tree c1,\n \t\t\t   bounds *bnds)\n {\n-  tree varc0, varc1, tmp, ctype;\n+  tree varc0, varc1, ctype;\n   mpz_t offc0, offc1, loffx, loffy, bnd;\n   bool lbound = false;\n   bool no_wrap = nowrap_type_p (type);\n@@ -371,7 +369,7 @@ refine_bounds_using_guard (tree type, tree varx, mpz_t offx,\n \n   if (operand_equal_p (varx, varc1, 0))\n     {\n-      tmp = varc0; varc0 = varc1; varc1 = tmp;\n+      std::swap (varc0, varc1);\n       mpz_swap (offc0, offc1);\n       cmp = swap_tree_comparison (cmp);\n     }\n@@ -385,7 +383,7 @@ refine_bounds_using_guard (tree type, tree varx, mpz_t offx,\n \n   if (cmp == GT_EXPR || cmp == GE_EXPR)\n     {\n-      tmp = varx; varx = vary; vary = tmp;\n+      std::swap (varx, vary);\n       mpz_swap (offc0, offc1);\n       mpz_swap (loffx, loffy);\n       cmp = swap_tree_comparison (cmp);\n@@ -1365,7 +1363,7 @@ number_of_iterations_cond (struct loop *loop,\n   if (code == GE_EXPR || code == GT_EXPR\n       || (code == NE_EXPR && integer_zerop (iv0->step)))\n     {\n-      SWAP (iv0, iv1);\n+      std::swap (iv0, iv1);\n       code = swap_tree_comparison (code);\n     }\n "}, {"sha": "d2a5cee23295a3687b9f737c102a765937f5cdb2", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -237,12 +237,8 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)\n         ;\n       else if (EDGE_SUCC (bb2, 0)->dest == bb1)\n         {\n-\t  basic_block bb_tmp = bb1;\n-\t  edge e_tmp = e1;\n-\t  bb1 = bb2;\n-\t  bb2 = bb_tmp;\n-\t  e1 = e2;\n-\t  e2 = e_tmp;\n+\t  std::swap (bb1, bb2);\n+\t  std::swap (e1, e2);\n \t}\n       else if (do_store_elim\n \t       && EDGE_SUCC (bb1, 0)->dest == EDGE_SUCC (bb2, 0)->dest)"}, {"sha": "ccfa6b603ecf6d87f9e3ee60131c396eb932d740", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -2389,11 +2389,7 @@ vn_nary_op_compute_hash (const vn_nary_op_t vno1)\n   if (vno1->length == 2\n       && commutative_tree_code (vno1->opcode)\n       && tree_swap_operands_p (vno1->op[0], vno1->op[1], false))\n-    {\n-      tree temp = vno1->op[0];\n-      vno1->op[0] = vno1->op[1];\n-      vno1->op[1] = temp;\n-    }\n+    std::swap (vno1->op[0], vno1->op[1]);\n \n   hstate.add_int (vno1->opcode);\n   for (i = 0; i < vno1->length; ++i)"}, {"sha": "91ddc0fc4448eac798a669b4385c03e1616cd8ec", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -1124,9 +1124,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  for (j = 0; j < group_size; ++j)\n \t    if (!matches[j])\n \t      {\n-\t\tgimple tem = oprnds_info[0]->def_stmts[j];\n-\t\toprnds_info[0]->def_stmts[j] = oprnds_info[1]->def_stmts[j];\n-\t\toprnds_info[1]->def_stmts[j] = tem;\n+\t\tstd::swap (oprnds_info[0]->def_stmts[j],\n+\t\t\t   oprnds_info[1]->def_stmts[j]);\n \t\tdump_printf (MSG_NOTE, \"%d \", j);\n \t      }\n \t  dump_printf (MSG_NOTE, \"\\n\");"}, {"sha": "0b9c8d6e1f96a417f90dbe28b8fb78a1cd01eebc", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -8259,11 +8259,7 @@ supportable_widening_operation (enum tree_code code, gimple stmt,\n     }\n \n   if (BYTES_BIG_ENDIAN && c1 != VEC_WIDEN_MULT_EVEN_EXPR)\n-    {\n-      enum tree_code ctmp = c1;\n-      c1 = c2;\n-      c2 = ctmp;\n-    }\n+    std::swap (c1, c2);\n \n   if (code == FIX_TRUNC_EXPR)\n     {"}, {"sha": "fdaebe4c2fc37a52251f05a6dd67c8c435c326f6", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 5, "deletions": 25, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4db50158952b893df977aff9eb1b470edbc65a/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=6b4db50158952b893df977aff9eb1b470edbc65a", "patch": "@@ -2914,33 +2914,17 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t     prod3.  */\n \t  /* min0min1 > max0max1 */\n \t  if (wi::gts_p (prod0, prod3))\n-\t    {\n-\t      vrp_int tmp = prod3;\n-\t      prod3 = prod0;\n-\t      prod0 = tmp;\n-\t    }\n+\t    std::swap (prod0, prod3);\n \n \t  /* min0max1 > max0min1 */\n \t  if (wi::gts_p (prod1, prod2))\n-\t    {\n-\t      vrp_int tmp = prod2;\n-\t      prod2 = prod1;\n-\t      prod1 = tmp;\n-\t    }\n+\t    std::swap (prod1, prod2);\n \n \t  if (wi::gts_p (prod0, prod1))\n-\t    {\n-\t      vrp_int tmp = prod1;\n-\t      prod1 = prod0;\n-\t      prod0 = tmp;\n-\t    }\n+\t    std::swap (prod0, prod1);\n \n \t  if (wi::gts_p (prod2, prod3))\n-\t    {\n-\t      vrp_int tmp = prod3;\n-\t      prod3 = prod2;\n-\t      prod2 = tmp;\n-\t    }\n+\t    std::swap (prod2, prod3);\n \n \t  /* diff = max - min.  */\n \t  prod2 = prod3 - prod0;\n@@ -3723,11 +3707,7 @@ extract_range_from_unary_expr_1 (value_range_t *vr,\n \t{\n           /* If the range was reversed, swap MIN and MAX.  */\n \t  if (cmp == 1)\n-\t    {\n-\t      tree t = min;\n-\t      min = max;\n-\t      max = t;\n-\t    }\n+\t    std::swap (min, max);\n \t}\n \n       cmp = compare_values (min, max);"}]}