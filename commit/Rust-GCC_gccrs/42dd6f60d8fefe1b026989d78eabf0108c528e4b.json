{"sha": "42dd6f60d8fefe1b026989d78eabf0108c528e4b", "node_id": "C_kwDOANBUbNoAKDQyZGQ2ZjYwZDhmZWZlMWIwMjY5ODlkNzhlYWJmMDEwOGM1MjhlNGI", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2021-12-08T14:09:25Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-01-06T17:11:41Z"}, "message": "[Ada] Proof of System.Generic_Array_Operations at silver level\n\ngcc/ada/\n\n\t* libgnat/a-ngcoar.adb: Add pragma to ignore assertions in\n\tinstance.\n\t* libgnat/a-ngrear.adb: Likewise.\n\t* libgnat/s-gearop.adb: Prove implementation is free of runtime\n\terrors.\n\t* libgnat/s-gearop.ads: Add contracts to protect against runtime\n\terrors in the generic part.", "tree": {"sha": "7b686a5d340f20a1b1500b95aa472ec5d4003ce5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b686a5d340f20a1b1500b95aa472ec5d4003ce5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42dd6f60d8fefe1b026989d78eabf0108c528e4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42dd6f60d8fefe1b026989d78eabf0108c528e4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42dd6f60d8fefe1b026989d78eabf0108c528e4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42dd6f60d8fefe1b026989d78eabf0108c528e4b/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2bc32602c58f14cddc8634fe36141137e2861d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2bc32602c58f14cddc8634fe36141137e2861d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2bc32602c58f14cddc8634fe36141137e2861d1"}], "stats": {"total": 541, "additions": 490, "deletions": 51}, "files": [{"sha": "953cb0966d8a84e1c019bbbf5b4c4a10ea710b1e", "filename": "gcc/ada/libgnat/a-ngcoar.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42dd6f60d8fefe1b026989d78eabf0108c528e4b/gcc%2Fada%2Flibgnat%2Fa-ngcoar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42dd6f60d8fefe1b026989d78eabf0108c528e4b/gcc%2Fada%2Flibgnat%2Fa-ngcoar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ngcoar.adb?ref=42dd6f60d8fefe1b026989d78eabf0108c528e4b", "patch": "@@ -29,6 +29,17 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  Preconditions, postconditions, ghost code, loop invariants and assertions\n+--  in this unit are meant for analysis only, not for run-time checking, as it\n+--  would be too costly otherwise. This is enforced by setting the assertion\n+--  policy to Ignore.\n+\n+pragma Assertion_Policy (Pre            => Ignore,\n+                         Post           => Ignore,\n+                         Ghost          => Ignore,\n+                         Loop_Invariant => Ignore,\n+                         Assert         => Ignore);\n+\n with System.Generic_Array_Operations; use System.Generic_Array_Operations;\n \n package body Ada.Numerics.Generic_Complex_Arrays is"}, {"sha": "c34cdd686c06212caa0b460445c3e32b9ba60a8f", "filename": "gcc/ada/libgnat/a-ngrear.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42dd6f60d8fefe1b026989d78eabf0108c528e4b/gcc%2Fada%2Flibgnat%2Fa-ngrear.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42dd6f60d8fefe1b026989d78eabf0108c528e4b/gcc%2Fada%2Flibgnat%2Fa-ngrear.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ngrear.adb?ref=42dd6f60d8fefe1b026989d78eabf0108c528e4b", "patch": "@@ -36,6 +36,17 @@\n --  BLAS/LAPACK implementation. Finally, on some platforms there are more\n --  floating point types than supported by BLAS/LAPACK.\n \n+--  Preconditions, postconditions, ghost code, loop invariants and assertions\n+--  in this unit are meant for analysis only, not for run-time checking, as it\n+--  would be too costly otherwise. This is enforced by setting the assertion\n+--  policy to Ignore.\n+\n+pragma Assertion_Policy (Pre            => Ignore,\n+                         Post           => Ignore,\n+                         Ghost          => Ignore,\n+                         Loop_Invariant => Ignore,\n+                         Assert         => Ignore);\n+\n with Ada.Containers.Generic_Anonymous_Array_Sort; use Ada.Containers;\n \n with System; use System;"}, {"sha": "e86d982d55141bf637524700903162279338d175", "filename": "gcc/ada/libgnat/s-gearop.adb", "status": "modified", "additions": 293, "deletions": 28, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42dd6f60d8fefe1b026989d78eabf0108c528e4b/gcc%2Fada%2Flibgnat%2Fs-gearop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42dd6f60d8fefe1b026989d78eabf0108c528e4b/gcc%2Fada%2Flibgnat%2Fs-gearop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-gearop.adb?ref=42dd6f60d8fefe1b026989d78eabf0108c528e4b", "patch": "@@ -29,28 +29,59 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  Preconditions, postconditions, ghost code, loop invariants and assertions\n+--  in this unit are meant for analysis only, not for run-time checking, as it\n+--  would be too costly otherwise. This is enforced by setting the assertion\n+--  policy to Ignore.\n+\n+pragma Assertion_Policy (Pre            => Ignore,\n+                         Post           => Ignore,\n+                         Ghost          => Ignore,\n+                         Loop_Invariant => Ignore,\n+                         Assert         => Ignore);\n+\n with Ada.Numerics; use Ada.Numerics;\n-package body System.Generic_Array_Operations is\n+\n+package body System.Generic_Array_Operations\n+  with SPARK_Mode\n+is\n+   pragma Warnings\n+     (Off, \"aspect * not enforced on inlined subprogram\",\n+      Reason => \"Contracts in this unit are never executed\");\n+\n    function Check_Unit_Last\n      (Index : Integer;\n       Order : Positive;\n-      First : Integer) return Integer;\n+      First : Integer) return Integer\n+   with\n+     Pre => Index >= First\n+       and then First <= Integer'Last - Order + 1\n+       and then Index <= First + (Order - 1),\n+     Post => Check_Unit_Last'Result = First + (Order - 1);\n+\n    pragma Inline_Always (Check_Unit_Last);\n    --  Compute index of last element returned by Unit_Vector or Unit_Matrix.\n    --  A separate function is needed to allow raising Constraint_Error before\n    --  declaring the function result variable. The result variable needs to be\n    --  declared first, to allow front-end inlining.\n \n+   pragma Warnings (On, \"aspect * not enforced on inlined subprogram\");\n+\n    --------------\n    -- Diagonal --\n    --------------\n \n    function Diagonal (A : Matrix) return Vector is\n       N : constant Natural := Natural'Min (A'Length (1), A'Length (2));\n    begin\n-      return R : Vector (A'First (1) .. A'First (1) + N - 1) do\n+      return R : Vector (A'First (1) .. A'First (1) + (N - 1))\n+        with Relaxed_Initialization\n+      do\n          for J in 0 .. N - 1 loop\n             R (R'First + J) := A (A'First (1) + J, A'First (2) + J);\n+\n+            pragma Loop_Invariant\n+              (for all JJ in R'First .. R'First + J => R (JJ)'Initialized);\n          end loop;\n       end return;\n    end Diagonal;\n@@ -103,7 +134,10 @@ package body System.Generic_Array_Operations is\n         (M      : in out Matrix;\n          Target : Integer;\n          Source : Integer;\n-         Factor : Scalar);\n+         Factor : Scalar)\n+      with\n+        Pre => Target in M'Range (1)\n+          and then Source in M'Range (1);\n       --  Elementary row operation that subtracts Factor * M (Source, <>) from\n       --  M (Target, <>)\n \n@@ -131,6 +165,9 @@ package body System.Generic_Array_Operations is\n \n    begin\n       Do_Rows : for Row in reverse M'Range (1) loop\n+\n+         pragma Loop_Invariant (Max_Col <= M'Last (2));\n+\n          Find_Non_Zero : for Col in reverse M'First (2) .. Max_Col loop\n             if Is_Non_Zero (M (Row, Col)) then\n \n@@ -144,12 +181,15 @@ package body System.Generic_Array_Operations is\n                   --  equals Integer'First, which is true for aggregates\n                   --  without explicit bounds..\n \n-                  J : Integer := M'First (1);\n+                  J  : Integer := M'First (1);\n+                  NZ : constant Scalar := M (Row, Col);\n \n                begin\n                   while J < Row loop\n-                     Sub_Row (N, J, Row, (M (J, Col) / M (Row, Col)));\n-                     Sub_Row (M, J, Row, (M (J, Col) / M (Row, Col)));\n+                     pragma Loop_Invariant (J in M'Range (1));\n+\n+                     Sub_Row (N, J, Row, (M (J, Col) / NZ));\n+                     Sub_Row (M, J, Row, (M (J, Col) / NZ));\n                      J := J + 1;\n                   end loop;\n                end;\n@@ -189,19 +229,38 @@ package body System.Generic_Array_Operations is\n         (M      : in out Matrix;\n          Target : Integer;\n          Source : Integer;\n-         Factor : Scalar);\n+         Factor : Scalar)\n+      with\n+        Pre => Target in M'Range (1)\n+          and then Source in M'Range (1);\n       --  Subtrace Factor * M (Source, <>) from M (Target, <>)\n \n       procedure Divide_Row\n         (M, N  : in out Matrix;\n          Row   : Integer;\n-         Scale : Scalar);\n+         Scale : Scalar)\n+      with\n+        Pre => Row in M'Range (1)\n+          and then M'First (1) = N'First (1)\n+          and then M'Last (1) = N'Last (1)\n+          and then Scale /= Zero;\n       --  Divide M (Row) and N (Row) by Scale, and update Det\n \n       procedure Switch_Row\n         (M, N  : in out Matrix;\n          Row_1 : Integer;\n-         Row_2 : Integer);\n+         Row_2 : Integer)\n+      with\n+        Pre  => Row_1 in M'Range (1)\n+          and then Row_2 in M'Range (1)\n+          and then M'First (1) = N'First (1)\n+          and then M'Last (1) = N'Last (1),\n+        Post => (for all J in M'Range (2) =>\n+                   M (Row_1, J) = M'Old (Row_2, J)\n+                     and then M (Row_2, J) = M'Old (Row_1, J))\n+          and then (for all J in N'Range (2) =>\n+                      N (Row_1, J) = N'Old (Row_2, J)\n+                        and then N (Row_2, J) = N'Old (Row_1, J));\n       --  Exchange M (Row_1) and N (Row_1) with M (Row_2) and N (Row_2),\n       --  negating Det in the process.\n \n@@ -238,8 +297,7 @@ package body System.Generic_Array_Operations is\n          end loop;\n \n          for J in N'Range (2) loop\n-            N (Row - M'First (1) + N'First (1), J) :=\n-              N (Row - M'First (1) + N'First (1), J) / Scale;\n+            N (Row, J) := N (Row, J) / Scale;\n             pragma Annotate\n               (CodePeer, False_Positive, \"divide by zero\", \"Scale /= 0\");\n          end loop;\n@@ -254,7 +312,9 @@ package body System.Generic_Array_Operations is\n          Row_1 : Integer;\n          Row_2 : Integer)\n       is\n-         procedure Swap (X, Y : in out Scalar);\n+         procedure Swap (X, Y : in out Scalar)\n+         with\n+           Post => X = Y'Old and then Y = X'Old;\n          --  Exchange the values of X and Y\n \n          ----------\n@@ -276,11 +336,28 @@ package body System.Generic_Array_Operations is\n \n             for J in M'Range (2) loop\n                Swap (M (Row_1, J), M (Row_2, J));\n+               pragma Annotate\n+                 (GNATprove, False_Positive,\n+                  \"formal parameters \"\"X\"\" and \"\"Y\"\" might be aliased\",\n+                  \"Row_1 /= Row_2\");\n+\n+               pragma Loop_Invariant\n+                 (for all JJ in M'First (2) .. J =>\n+                    M (Row_1, JJ) = M'Loop_Entry (Row_2, JJ)\n+                      and then M (Row_2, JJ) = M'Loop_Entry (Row_1, JJ));\n             end loop;\n \n             for J in N'Range (2) loop\n-               Swap (N (Row_1 - M'First (1) + N'First (1), J),\n-                     N (Row_2 - M'First (1) + N'First (1), J));\n+               Swap (N (Row_1, J), N (Row_2, J));\n+               pragma Annotate\n+                 (GNATprove, False_Positive,\n+                  \"formal parameters \"\"X\"\" and \"\"Y\"\" might be aliased\",\n+                  \"Row_1 /= Row_2\");\n+\n+               pragma Loop_Invariant\n+                 (for all JJ in N'First (2) .. J =>\n+                    N (Row_1, JJ) = N'Loop_Entry (Row_2, JJ)\n+                      and then N (Row_2, JJ) = N'Loop_Entry (Row_1, JJ));\n             end loop;\n          end if;\n       end Switch_Row;\n@@ -295,6 +372,8 @@ package body System.Generic_Array_Operations is\n       Det := One;\n \n       for J in M'Range (2) loop\n+         pragma Loop_Invariant (Row >= M'First (1));\n+\n          declare\n             Max_Row : Integer := Row;\n             Max_Abs : Real'Base := 0.0;\n@@ -303,6 +382,10 @@ package body System.Generic_Array_Operations is\n             --  Find best pivot in column J, starting in row Row\n \n             for K in Row .. M'Last (1) loop\n+               pragma Loop_Invariant (Max_Row in M'Range (1));\n+               pragma Loop_Invariant\n+                 (if Max_Abs /= 0.0 then Max_Abs = abs M (Max_Row, J));\n+\n                declare\n                   New_Abs : constant Real'Base := abs M (K, J);\n                begin\n@@ -316,6 +399,8 @@ package body System.Generic_Array_Operations is\n             if Max_Abs > 0.0 then\n                Switch_Row (M, N, Row, Max_Row);\n \n+               pragma Assert (Max_Abs = abs M (Row, J));\n+\n                --  The temporaries below are necessary to force a copy of the\n                --  value and avoid improper aliasing.\n \n@@ -325,7 +410,7 @@ package body System.Generic_Array_Operations is\n                   Divide_Row (M, N, Row, Scale);\n                end;\n \n-               for U in Row + 1 .. M'Last (1) loop\n+               for U in Row .. M'Last (1) when U /= Row loop\n                   declare\n                      Factor : constant Scalar := M (U, J);\n                   begin\n@@ -379,7 +464,11 @@ package body System.Generic_Array_Operations is\n \n    begin\n       for J in X'Range loop\n+         pragma Loop_Invariant (Sum >= 0.0);\n          Sum := Sum + Result_Real'Base (abs X (J))**2;\n+         pragma Annotate\n+           (GNATprove, Intentional, \"float overflow check might fail\",\n+            \"Intermediate computation might overflow in L2_Norm\");\n       end loop;\n \n       return Sqrt (Sum);\n@@ -391,11 +480,25 @@ package body System.Generic_Array_Operations is\n \n    function Matrix_Elementwise_Operation (X : X_Matrix) return Result_Matrix is\n    begin\n-      return R : Result_Matrix (X'Range (1), X'Range (2)) do\n+      return R : Result_Matrix (X'Range (1), X'Range (2))\n+        with Relaxed_Initialization\n+      do\n          for J in R'Range (1) loop\n             for K in R'Range (2) loop\n                R (J, K) := Operation (X (J, K));\n+\n+               pragma Loop_Invariant\n+                 (for all JJ in R'First (1) .. J when JJ /= J =>\n+                    (for all KK in R'Range (2) => R (JJ, KK)'Initialized));\n+               pragma Loop_Invariant\n+                 (for all KK in R'First (2) .. K => R (J, KK)'Initialized);\n             end loop;\n+\n+            pragma Loop_Invariant\n+              (for all JJ in R'First (1) .. J when JJ /= J =>\n+                 (for all KK in R'Range (2) => R (JJ, KK)'Initialized));\n+            pragma Loop_Invariant\n+              (for all KK in R'Range (2) => R (J, KK)'Initialized);\n          end loop;\n       end return;\n    end Matrix_Elementwise_Operation;\n@@ -422,7 +525,9 @@ package body System.Generic_Array_Operations is\n       Right : Right_Matrix) return Result_Matrix\n    is\n    begin\n-      return R : Result_Matrix (Left'Range (1), Left'Range (2)) do\n+      return R : Result_Matrix (Left'Range (1), Left'Range (2))\n+        with Relaxed_Initialization\n+      do\n          if Left'Length (1) /= Right'Length (1)\n               or else\n             Left'Length (2) /= Right'Length (2)\n@@ -439,7 +544,19 @@ package body System.Generic_Array_Operations is\n                     Right\n                       (J - R'First (1) + Right'First (1),\n                        K - R'First (2) + Right'First (2)));\n+\n+               pragma Loop_Invariant\n+                 (for all JJ in R'First (1) .. J when JJ /= J =>\n+                    (for all KK in R'Range (2) => R (JJ, KK)'Initialized));\n+               pragma Loop_Invariant\n+                 (for all KK in R'First (2) .. K => R (J, KK)'Initialized);\n             end loop;\n+\n+            pragma Loop_Invariant\n+              (for all JJ in R'First (1) .. J when JJ /= J =>\n+                 (for all KK in R'Range (2) => R (JJ, KK)'Initialized));\n+            pragma Loop_Invariant\n+              (for all KK in R'Range (2) => R (J, KK)'Initialized);\n          end loop;\n       end return;\n    end Matrix_Matrix_Elementwise_Operation;\n@@ -454,7 +571,9 @@ package body System.Generic_Array_Operations is\n       Z : Z_Scalar) return Result_Matrix\n    is\n    begin\n-      return R : Result_Matrix (X'Range (1), X'Range (2)) do\n+      return R : Result_Matrix (X'Range (1), X'Range (2))\n+        with Relaxed_Initialization\n+      do\n          if X'Length (1) /= Y'Length (1)\n               or else\n             X'Length (2) /= Y'Length (2)\n@@ -471,7 +590,19 @@ package body System.Generic_Array_Operations is\n                     Y (J - R'First (1) + Y'First (1),\n                        K - R'First (2) + Y'First (2)),\n                     Z);\n+\n+               pragma Loop_Invariant\n+                 (for all JJ in R'First (1) .. J when JJ /= J =>\n+                    (for all KK in R'Range (2) => R (JJ, KK)'Initialized));\n+               pragma Loop_Invariant\n+                 (for all KK in R'First (2) .. K => R (J, KK)'Initialized);\n             end loop;\n+\n+            pragma Loop_Invariant\n+              (for all JJ in R'First (1) .. J when JJ /= J =>\n+                 (for all KK in R'Range (2) => R (JJ, KK)'Initialized));\n+            pragma Loop_Invariant\n+              (for all KK in R'Range (2) => R (J, KK)'Initialized);\n          end loop;\n       end return;\n    end Matrix_Matrix_Scalar_Elementwise_Operation;\n@@ -527,11 +658,25 @@ package body System.Generic_Array_Operations is\n       Right : Right_Scalar) return Result_Matrix\n    is\n    begin\n-      return R : Result_Matrix (Left'Range (1), Left'Range (2)) do\n+      return R : Result_Matrix (Left'Range (1), Left'Range (2))\n+        with Relaxed_Initialization\n+      do\n          for J in R'Range (1) loop\n             for K in R'Range (2) loop\n                R (J, K) := Operation (Left (J, K), Right);\n+\n+               pragma Loop_Invariant\n+                 (for all JJ in R'First (1) .. J when JJ /= J =>\n+                    (for all KK in R'Range (2) => R (JJ, KK)'Initialized));\n+               pragma Loop_Invariant\n+                 (for all KK in R'First (2) .. K => R (J, KK)'Initialized);\n             end loop;\n+\n+            pragma Loop_Invariant\n+              (for all JJ in R'First (1) .. J when JJ /= J =>\n+                 (for all KK in R'Range (2) => R (JJ, KK)'Initialized));\n+            pragma Loop_Invariant\n+              (for all KK in R'Range (2) => R (J, KK)'Initialized);\n          end loop;\n       end return;\n    end Matrix_Scalar_Elementwise_Operation;\n@@ -561,11 +706,25 @@ package body System.Generic_Array_Operations is\n       Right : Right_Matrix) return Result_Matrix\n    is\n    begin\n-      return R : Result_Matrix (Right'Range (1), Right'Range (2)) do\n+      return R : Result_Matrix (Right'Range (1), Right'Range (2))\n+        with Relaxed_Initialization\n+      do\n          for J in R'Range (1) loop\n             for K in R'Range (2) loop\n                R (J, K) := Operation (Left, Right (J, K));\n+\n+               pragma Loop_Invariant\n+                 (for all JJ in R'First (1) .. J when JJ /= J =>\n+                    (for all KK in R'Range (2) => R (JJ, KK)'Initialized));\n+               pragma Loop_Invariant\n+                 (for all KK in R'First (2) .. K => R (J, KK)'Initialized);\n             end loop;\n+\n+            pragma Loop_Invariant\n+              (for all JJ in R'First (1) .. J when JJ /= J =>\n+                 (for all KK in R'Range (2) => R (JJ, KK)'Initialized));\n+            pragma Loop_Invariant\n+              (for all KK in R'Range (2) => R (J, KK)'Initialized);\n          end loop;\n       end return;\n    end Scalar_Matrix_Elementwise_Operation;\n@@ -590,7 +749,9 @@ package body System.Generic_Array_Operations is\n    -- Sqrt --\n    ----------\n \n-   function Sqrt (X : Real'Base) return Real'Base is\n+   function Sqrt (X : Real'Base) return Real'Base\n+     with SPARK_Mode => Off  --  Not in SPARK due to use of Real'Exponent\n+   is\n       Root, Next : Real'Base;\n \n    begin\n@@ -651,7 +812,9 @@ package body System.Generic_Array_Operations is\n       Right : Right_Matrix) return Result_Matrix\n    is\n    begin\n-      return R : Result_Matrix (Left'Range (1), Right'Range (2)) do\n+      return R : Result_Matrix (Left'Range (1), Right'Range (2))\n+        with Relaxed_Initialization\n+      do\n          if Left'Length (2) /= Right'Length (1) then\n             raise Constraint_Error with\n               \"incompatible dimensions in matrix multiplication\";\n@@ -671,7 +834,19 @@ package body System.Generic_Array_Operations is\n \n                   R (J, K) := S;\n                end;\n+\n+               pragma Loop_Invariant\n+                 (for all JJ in R'First (1) .. J when JJ /= J =>\n+                    (for all KK in R'Range (2) => R (JJ, KK)'Initialized));\n+               pragma Loop_Invariant\n+                 (for all KK in R'First (2) .. K => R (J, KK)'Initialized);\n             end loop;\n+\n+            pragma Loop_Invariant\n+              (for all JJ in R'First (1) .. J when JJ /= J =>\n+                 (for all KK in R'Range (2) => R (JJ, KK)'Initialized));\n+            pragma Loop_Invariant\n+              (for all KK in R'Range (2) => R (J, KK)'Initialized);\n          end loop;\n       end return;\n    end  Matrix_Matrix_Product;\n@@ -681,10 +856,21 @@ package body System.Generic_Array_Operations is\n    ----------------------------\n \n    function Matrix_Vector_Solution (A : Matrix; X : Vector) return Vector is\n+\n+      procedure Ignore (M : Matrix)\n+      with\n+        Ghost,\n+        Depends => (null => M);\n+\n+      procedure Ignore (M : Matrix) is null;\n+      --  Ghost procedure to document that the value of argument M is ignored,\n+      --  which prevents a warning being issued about the value not being used\n+      --  in the rest of the code.\n+\n       N   : constant Natural := A'Length (1);\n       MA  : Matrix := A;\n-      MX  : Matrix (A'Range (1), 1 .. 1);\n-      R   : Vector (A'Range (2));\n+      MX  : Matrix (A'Range (1), 1 .. 1) with Relaxed_Initialization;\n+      R   : Vector (A'Range (2)) with Relaxed_Initialization;\n       Det : Scalar;\n \n    begin\n@@ -698,18 +884,29 @@ package body System.Generic_Array_Operations is\n \n       for J in 0 .. MX'Length (1) - 1 loop\n          MX (MX'First (1) + J, 1) := X (X'First + J);\n+\n+         pragma Loop_Invariant\n+           (for all JJ in MX'First (1) .. MX'First (1) + J =>\n+              MX (JJ, 1)'Initialized);\n       end loop;\n \n       Forward_Eliminate (MA, MX, Det);\n \n       if Det = Zero then\n          raise Constraint_Error with \"matrix is singular\";\n+         pragma Annotate\n+           (GNATprove, Intentional, \"exception might be raised\",\n+            \"An exception should be raised on a singular matrix\");\n       end if;\n \n       Back_Substitute (MA, MX);\n+      Ignore (MA);\n \n       for J in 0 .. R'Length - 1 loop\n          R (R'First + J) := MX (MX'First (1) + J, 1);\n+\n+         pragma Loop_Invariant\n+           (for all JJ in R'First .. R'First + J => R (JJ)'Initialized);\n       end loop;\n \n       return R;\n@@ -720,9 +917,20 @@ package body System.Generic_Array_Operations is\n    ----------------------------\n \n    function Matrix_Matrix_Solution (A, X : Matrix) return Matrix is\n+\n+      procedure Ignore (M : Matrix)\n+      with\n+        Ghost,\n+        Depends => (null => M);\n+\n+      procedure Ignore (M : Matrix) is null;\n+      --  Ghost procedure to document that the value of argument M is ignored,\n+      --  which prevents a warning being issued about the value not being used\n+      --  in the rest of the code.\n+\n       N   : constant Natural := A'Length (1);\n-      MA  : Matrix (A'Range (2), A'Range (2));\n-      MB  : Matrix (A'Range (2), X'Range (2));\n+      MA  : Matrix (A'Range (2), A'Range (2)) with Relaxed_Initialization;\n+      MB  : Matrix (A'Range (2), X'Range (2)) with Relaxed_Initialization;\n       Det : Scalar;\n \n    begin\n@@ -737,20 +945,53 @@ package body System.Generic_Array_Operations is\n       for J in 0 .. A'Length (1) - 1 loop\n          for K in MA'Range (2) loop\n             MA (MA'First (1) + J, K) := A (A'First (1) + J, K);\n+\n+            pragma Loop_Invariant\n+              (for all JJ in MA'First (1) .. MA'First (1) + J\n+                 when JJ /= MA'First (1) + J\n+               =>\n+                 (for all KK in MA'Range (2) =>\n+                    MA (JJ, KK)'Initialized));\n+            pragma Loop_Invariant\n+              (for all KK in MA'First (2) .. K =>\n+                 MA (MA'First (1) + J, KK)'Initialized);\n          end loop;\n \n          for K in MB'Range (2) loop\n             MB (MB'First (1) + J, K) := X (X'First (1) + J, K);\n+\n+            pragma Loop_Invariant\n+              (for all JJ in MB'First (1) .. MB'First (1) + J\n+                 when JJ /= MB'First (1) + J\n+               =>\n+                 (for all KK in MB'Range (2) =>\n+                    MB (JJ, KK)'Initialized));\n+            pragma Loop_Invariant\n+              (for all KK in MB'First (2) .. K =>\n+                 MB (MB'First (1) + J, KK)'Initialized);\n          end loop;\n+\n+         pragma Loop_Invariant\n+           (for all JJ in MA'First (1) .. MA'First (1) + J =>\n+              (for all KK in MA'Range (2) =>\n+                 MA (JJ, KK)'Initialized));\n+         pragma Loop_Invariant\n+           (for all JJ in MB'First (1) .. MB'First (1) + J =>\n+              (for all KK in MB'Range (2) =>\n+                 MB (JJ, KK)'Initialized));\n       end loop;\n \n       Forward_Eliminate (MA, MB, Det);\n \n       if Det = Zero then\n          raise Constraint_Error with \"matrix is singular\";\n+         pragma Annotate\n+           (GNATprove, Intentional, \"exception might be raised\",\n+            \"An exception should be raised on a singular matrix\");\n       end if;\n \n       Back_Substitute (MA, MB);\n+      Ignore (MA);\n \n       return MB;\n    end Matrix_Matrix_Solution;\n@@ -795,11 +1036,25 @@ package body System.Generic_Array_Operations is\n       Right : Right_Vector) return Matrix\n    is\n    begin\n-      return R : Matrix (Left'Range, Right'Range) do\n+      return R : Matrix (Left'Range, Right'Range)\n+        with Relaxed_Initialization\n+      do\n          for J in R'Range (1) loop\n             for K in R'Range (2) loop\n                R (J, K) := Left (J) * Right (K);\n+\n+               pragma Loop_Invariant\n+                 (for all JJ in R'First (1) .. J when JJ /= J =>\n+                    (for all KK in R'Range (2) => R (JJ, KK)'Initialized));\n+               pragma Loop_Invariant\n+                 (for all KK in R'First (2) .. K => R (J, KK)'Initialized);\n             end loop;\n+\n+            pragma Loop_Invariant\n+              (for all JJ in R'First (1) .. J when JJ /= J =>\n+                 (for all KK in R'Range (2) => R (JJ, KK)'Initialized));\n+            pragma Loop_Invariant\n+              (for all KK in R'Range (2) => R (J, KK)'Initialized);\n          end loop;\n       end return;\n    end Outer_Product;\n@@ -828,7 +1083,17 @@ package body System.Generic_Array_Operations is\n          for K in R'Range (2) loop\n             R (J, K) := A (K - R'First (2) + A'First (1),\n                            J - R'First (1) + A'First (2));\n+\n+            pragma Loop_Invariant\n+              (for all JJ in R'First (1) .. J when JJ /= J =>\n+                (for all K in R'Range (2) => R (JJ, K)'Initialized));\n+            pragma Loop_Invariant\n+              (for all KK in R'First (2) .. K => R (J, KK)'Initialized);\n          end loop;\n+\n+         pragma Loop_Invariant\n+           (for all JJ in R'First (1) .. J =>\n+             (for all K in R'Range (2) => R (JJ, K)'Initialized));\n       end loop;\n    end Transpose;\n "}, {"sha": "a3c0239fa07408a61e4be820116159f23cb91d6d", "filename": "gcc/ada/libgnat/s-gearop.ads", "status": "modified", "additions": 175, "deletions": 23, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42dd6f60d8fefe1b026989d78eabf0108c528e4b/gcc%2Fada%2Flibgnat%2Fs-gearop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42dd6f60d8fefe1b026989d78eabf0108c528e4b/gcc%2Fada%2Flibgnat%2Fs-gearop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-gearop.ads?ref=42dd6f60d8fefe1b026989d78eabf0108c528e4b", "patch": "@@ -29,8 +29,29 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package System.Generic_Array_Operations is\n-pragma Pure (Generic_Array_Operations);\n+--  Proof of this unit is only done up to silver level, i.e. absence of runtime\n+--  errors, and only regarding runtime checks that depend on the generic part,\n+--  ignoring runtime checks related to formal generic subprogram parameters\n+--  in instantiations. For example, contracts do not protect against scalar\n+--  overflows in arithmetic operations passed on as formal generic subprogram\n+--  parameters.\n+\n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced\n+--  by setting the corresponding assertion policy to Ignore. Postconditions\n+--  and contract cases should not be executed at runtime as well, in order\n+--  not to slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre            => Ignore,\n+                         Post           => Ignore,\n+                         Contract_Cases => Ignore,\n+                         Ghost          => Ignore);\n+\n+package System.Generic_Array_Operations\n+  with SPARK_Mode\n+is\n+\n+   pragma Pure (Generic_Array_Operations);\n \n    ---------------------\n    -- Back_Substitute --\n@@ -43,7 +64,10 @@ pragma Pure (Generic_Array_Operations);\n       with function \"*\" (Left, Right : Scalar) return Scalar is <>;\n       with function \"/\" (Left, Right : Scalar) return Scalar is <>;\n       with function Is_Non_Zero (X : Scalar) return Boolean is <>;\n-   procedure Back_Substitute (M, N : in out Matrix);\n+   procedure Back_Substitute (M, N : in out Matrix)\n+   with\n+     Pre => M'First (1) = N'First (1)\n+       and then M'Last (1) = N'Last (1);\n \n    --------------\n    -- Diagonal --\n@@ -53,7 +77,14 @@ pragma Pure (Generic_Array_Operations);\n       type Scalar is private;\n       type Vector is array (Integer range <>) of Scalar;\n       type Matrix is array (Integer range <>, Integer range <>) of Scalar;\n-   function Diagonal (A : Matrix) return Vector;\n+   function Diagonal (A : Matrix) return Vector\n+   with\n+     Pre => A'First (1) < A'Last (1)\n+       and then A'First (2) < A'Last (2)\n+       and then (if A'First (1) <= 0 then\n+                   A'Last (1) < Integer'Last + A'First (1))\n+       and then (if A'First (2) <= 0 then\n+                   A'Last (2) < Integer'Last + A'First (2));\n \n    -----------------------\n    -- Forward_Eliminate --\n@@ -76,7 +107,10 @@ pragma Pure (Generic_Array_Operations);\n    procedure Forward_Eliminate\n      (M   : in out Matrix;\n       N   : in out Matrix;\n-      Det : out Scalar);\n+      Det : out Scalar)\n+   with\n+     Pre => M'First (1) = N'First (1)\n+       and then M'Last (1) = N'Last (1);\n \n    --------------------------\n    -- Square_Matrix_Length --\n@@ -85,8 +119,14 @@ pragma Pure (Generic_Array_Operations);\n    generic\n       type Scalar is private;\n       type Matrix is array (Integer range <>, Integer range <>) of Scalar;\n-   function Square_Matrix_Length (A : Matrix) return Natural;\n-   --  If A is non-square, raise Constraint_Error,  else return its dimension\n+   function Square_Matrix_Length (A : Matrix) return Natural\n+   with\n+     Pre => (if A'First (1) <= 0 then\n+               A'Last (1) < Integer'Last + A'First (1))\n+       and then (if A'First (2) <= 0 then\n+                   A'Last (2) < Integer'Last + A'First (2))\n+       and then A'Length (1) = A'Length (2);\n+   --  If A is non-square, raise Constraint_Error, else return its dimension\n \n    ----------------------------------\n    -- Vector_Elementwise_Operation --\n@@ -129,7 +169,13 @@ pragma Pure (Generic_Array_Operations);\n               Right : Right_Scalar) return Result_Scalar;\n    function Vector_Vector_Elementwise_Operation\n      (Left  : Left_Vector;\n-      Right : Right_Vector) return Result_Vector;\n+      Right : Right_Vector) return Result_Vector\n+   with\n+     Pre => (if Left'First <= 0 then\n+               Left'Last < Integer'Last + Left'First)\n+       and then (if Right'First <= 0 then\n+                   Right'Last < Integer'Last + Right'First)\n+       and then Left'Length = Right'Length;\n \n    ------------------------------------------------\n    -- Vector_Vector_Scalar_Elementwise_Operation --\n@@ -150,7 +196,11 @@ pragma Pure (Generic_Array_Operations);\n    function Vector_Vector_Scalar_Elementwise_Operation\n      (X : X_Vector;\n       Y : Y_Vector;\n-      Z : Z_Scalar) return Result_Vector;\n+      Z : Z_Scalar) return Result_Vector\n+   with\n+     Pre => (if X'First <= 0 then X'Last < Integer'Last + X'First)\n+       and then (if Y'First <= 0 then Y'Last < Integer'Last + Y'First)\n+       and then X'Length = Y'Length;\n \n    -----------------------------------------\n    -- Matrix_Matrix_Elementwise_Operation --\n@@ -171,7 +221,18 @@ pragma Pure (Generic_Array_Operations);\n               Right : Right_Scalar) return Result_Scalar;\n    function Matrix_Matrix_Elementwise_Operation\n      (Left  : Left_Matrix;\n-      Right : Right_Matrix) return Result_Matrix;\n+      Right : Right_Matrix) return Result_Matrix\n+   with\n+     Pre => (if Left'First (1) <= 0 then\n+               Left'Last (1) < Integer'Last + Left'First (1))\n+       and then (if Right'First (1) <= 0 then\n+                   Right'Last (1) < Integer'Last + Right'First (1))\n+       and then Left'Length (1) = Right'Length (1)\n+       and then (if Left'First (2) <= 0 then\n+                   Left'Last (2) < Integer'Last + Left'First (2))\n+       and then (if Right'First (2) <= 0 then\n+                   Right'Last (2) < Integer'Last + Right'First (2))\n+       and then Left'Length (2) = Right'Length (2);\n \n    ------------------------------------------------\n    -- Matrix_Matrix_Scalar_Elementwise_Operation --\n@@ -193,7 +254,18 @@ pragma Pure (Generic_Array_Operations);\n    function Matrix_Matrix_Scalar_Elementwise_Operation\n      (X : X_Matrix;\n       Y : Y_Matrix;\n-      Z : Z_Scalar) return Result_Matrix;\n+      Z : Z_Scalar) return Result_Matrix\n+   with\n+     Pre => (if X'First (1) <= 0 then\n+               X'Last (1) < Integer'Last + X'First (1))\n+       and then (if Y'First (1) <= 0 then\n+                   Y'Last (1) < Integer'Last + Y'First (1))\n+       and then X'Length (1) = Y'Length (1)\n+       and then (if X'First (2) <= 0 then\n+                   X'Last (2) < Integer'Last + X'First (2))\n+       and then (if Y'First (2) <= 0 then\n+                   Y'Last (2) < Integer'Last + Y'First (2))\n+       and then X'Length (2) = Y'Length (2);\n \n    -----------------------------------------\n    -- Vector_Scalar_Elementwise_Operation --\n@@ -286,7 +358,13 @@ pragma Pure (Generic_Array_Operations);\n               Right : Result_Scalar) return Result_Scalar is <>;\n    function Inner_Product\n      (Left  : Left_Vector;\n-      Right : Right_Vector) return Result_Scalar;\n+      Right : Right_Vector) return Result_Scalar\n+   with\n+     Pre => (if Left'First <= 0 then\n+               Left'Last < Integer'Last + Left'First)\n+       and then (if Right'First <= 0 then\n+                   Right'Last < Integer'Last + Right'First)\n+       and then Left'Length = Right'Length;\n \n    -------------\n    -- L2_Norm --\n@@ -340,7 +418,13 @@ pragma Pure (Generic_Array_Operations);\n               Right : Result_Scalar) return Result_Scalar is <>;\n    function Matrix_Vector_Product\n      (Left  : Matrix;\n-      Right : Right_Vector) return Result_Vector;\n+      Right : Right_Vector) return Result_Vector\n+   with\n+     Pre => (if Left'First (2) <= 0 then\n+               Left'Last (2) < Integer'Last + Left'First (2))\n+       and then (if Right'First <= 0 then\n+                   Right'Last < Integer'Last + Right'First)\n+       and then Left'Length (2) = Right'Length;\n \n    ---------------------------\n    -- Vector_Matrix_Product --\n@@ -363,7 +447,13 @@ pragma Pure (Generic_Array_Operations);\n               Right : Result_Scalar) return Result_Scalar is <>;\n    function Vector_Matrix_Product\n      (Left  : Left_Vector;\n-      Right : Matrix) return Result_Vector;\n+      Right : Matrix) return Result_Vector\n+   with\n+     Pre => (if Left'First <= 0 then\n+               Left'Last < Integer'Last + Left'First)\n+       and then (if Right'First (1) <= 0 then\n+                   Right'Last (1) < Integer'Last + Right'First (1))\n+       and then Left'Length = Right'Length (1);\n \n    ---------------------------\n    -- Matrix_Matrix_Product --\n@@ -388,7 +478,13 @@ pragma Pure (Generic_Array_Operations);\n               Right : Result_Scalar) return Result_Scalar is <>;\n    function Matrix_Matrix_Product\n      (Left  : Left_Matrix;\n-      Right : Right_Matrix) return Result_Matrix;\n+      Right : Right_Matrix) return Result_Matrix\n+   with\n+     Pre => (if Left'First (2) <= 0 then\n+               Left'Last (2) < Integer'Last + Left'First (2))\n+       and then (if Right'First (1) <= 0 then\n+                   Right'Last (1) < Integer'Last + Right'First (1))\n+       and then Left'Length (2) = Right'Length (1);\n \n    ----------------------------\n    -- Matrix_Vector_Solution --\n@@ -404,7 +500,16 @@ pragma Pure (Generic_Array_Operations);\n              (M   : in out Matrix;\n               N   : in out Matrix;\n               Det : out Scalar) is <>;\n-   function Matrix_Vector_Solution (A : Matrix; X : Vector) return Vector;\n+   function Matrix_Vector_Solution (A : Matrix; X : Vector) return Vector\n+   with\n+     Pre => (if A'First (1) <= 0 then\n+               A'Last (1) < Integer'Last + A'First (1))\n+       and then (if A'First (2) <= 0 then\n+                   A'Last (2) < Integer'Last + A'First (2))\n+       and then A'Length (1) = A'Length (2)\n+       and then (if X'First <= 0 then\n+                   X'Last < Integer'Last + X'First)\n+       and then A'Length (1) = X'Length;\n \n    ----------------------------\n    -- Matrix_Matrix_Solution --\n@@ -419,7 +524,16 @@ pragma Pure (Generic_Array_Operations);\n              (M   : in out Matrix;\n               N   : in out Matrix;\n               Det : out Scalar) is <>;\n-   function Matrix_Matrix_Solution (A : Matrix; X : Matrix) return Matrix;\n+   function Matrix_Matrix_Solution (A : Matrix; X : Matrix) return Matrix\n+   with\n+     Pre => (if A'First (1) <= 0 then\n+               A'Last (1) < Integer'Last + A'First (1))\n+       and then (if A'First (2) <= 0 then\n+                   A'Last (2) < Integer'Last + A'First (2))\n+       and then A'Length (1) = A'Length (2)\n+       and then (if X'First (1) <= 0 then\n+                   X'Last (1) < Integer'Last + X'First (1))\n+       and then A'Length (1) = X'Length (1);\n \n    ----------\n    -- Sqrt --\n@@ -436,7 +550,10 @@ pragma Pure (Generic_Array_Operations);\n    generic\n       type Scalar is private;\n       type Matrix is array (Integer range <>, Integer range <>) of Scalar;\n-   procedure Swap_Column (A : in out Matrix; Left, Right : Integer);\n+   procedure Swap_Column (A : in out Matrix; Left, Right : Integer)\n+   with\n+     Pre => Left in A'Range (2)\n+       and then Right in A'Range (2);\n \n    ---------------\n    -- Transpose --\n@@ -445,7 +562,18 @@ pragma Pure (Generic_Array_Operations);\n    generic\n       type Scalar is private;\n       type Matrix is array (Integer range <>, Integer range <>) of Scalar;\n-   procedure Transpose (A : Matrix; R : out Matrix);\n+   procedure Transpose (A : Matrix; R : out Matrix)\n+   with\n+     Relaxed_Initialization => R,\n+     Pre  => A'First (1) = R'First (2)\n+       and then A'Last (1) = R'Last (2)\n+       and then A'First (2) = R'First (1)\n+       and then A'Last (2) = R'Last (1)\n+       and then (if A'First (1) < 0 then\n+                   A'Last (1) <= Integer'Last + A'First (1))\n+       and then (if A'First (2) < 0 then\n+                   A'Last (2) <= Integer'Last + A'First (2)),\n+     Post => R'Initialized;\n \n    -------------------------------\n    -- Update_Vector_With_Vector --\n@@ -457,7 +585,13 @@ pragma Pure (Generic_Array_Operations);\n       type X_Vector is array (Integer range <>) of X_Scalar;\n       type Y_Vector is array (Integer range <>) of Y_Scalar;\n       with procedure Update (X : in out X_Scalar; Y : Y_Scalar);\n-   procedure Update_Vector_With_Vector (X : in out X_Vector; Y : Y_Vector);\n+   procedure Update_Vector_With_Vector (X : in out X_Vector; Y : Y_Vector)\n+   with\n+     Pre => (if X'First <= 0 then\n+               X'Last < Integer'Last + X'First)\n+       and then (if Y'First <= 0 then\n+                   Y'Last < Integer'Last + Y'First)\n+       and then X'Length = Y'Length;\n \n    -------------------------------\n    -- Update_Matrix_With_Matrix --\n@@ -469,7 +603,18 @@ pragma Pure (Generic_Array_Operations);\n       type X_Matrix is array (Integer range <>, Integer range <>) of X_Scalar;\n       type Y_Matrix is array (Integer range <>, Integer range <>) of Y_Scalar;\n       with procedure Update (X : in out X_Scalar; Y : Y_Scalar);\n-   procedure Update_Matrix_With_Matrix (X : in out X_Matrix; Y : Y_Matrix);\n+   procedure Update_Matrix_With_Matrix (X : in out X_Matrix; Y : Y_Matrix)\n+   with\n+     Pre => (if X'First (1) <= 0 then\n+               X'Last (1) < Integer'Last + X'First (1))\n+       and then (if Y'First (1) <= 0 then\n+                   Y'Last (1) < Integer'Last + Y'First (1))\n+       and then X'Length (1) = Y'Length (1)\n+       and then (if X'First (2) <= 0 then\n+                   X'Last (2) < Integer'Last + X'First (2))\n+       and then (if Y'First (2) <= 0 then\n+                   Y'Last (2) < Integer'Last + Y'First (2))\n+       and then X'Length (2) = Y'Length (2);\n \n    -----------------\n    -- Unit_Matrix --\n@@ -483,7 +628,10 @@ pragma Pure (Generic_Array_Operations);\n    function Unit_Matrix\n      (Order   : Positive;\n       First_1 : Integer := 1;\n-      First_2 : Integer := 1) return Matrix;\n+      First_2 : Integer := 1) return Matrix\n+   with\n+     Pre => First_1 <= Integer'Last - Order + 1\n+       and then First_2 <= Integer'Last - Order + 1;\n \n    -----------------\n    -- Unit_Vector --\n@@ -497,6 +645,10 @@ pragma Pure (Generic_Array_Operations);\n    function Unit_Vector\n      (Index : Integer;\n       Order : Positive;\n-      First : Integer := 1) return Vector;\n+      First : Integer := 1) return Vector\n+   with\n+     Pre => Index >= First\n+       and then First <= Integer'Last - Order + 1\n+       and then Index <= First + (Order - 1);\n \n end System.Generic_Array_Operations;"}]}