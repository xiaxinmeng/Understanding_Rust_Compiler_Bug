{"sha": "d0cd8b44016194824049ec6ee453d6864b73bc01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBjZDhiNDQwMTYxOTQ4MjQwNDllYzZlZTQ1M2Q2ODY0YjczYmMwMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2001-06-06T21:52:52Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-06-06T21:52:52Z"}, "message": "cp-tree.h (THUNK_GENERATE_WITH_VTABLE_P): Lose.\n\n        * cp-tree.h (THUNK_GENERATE_WITH_VTABLE_P): Lose.\n        (struct lang_decl_flags): Lose generate_with_vtable_p.\n        (BV_GENERATE_THUNK_WITH_VTABLE_P): Lose.\n        * class.c (copy_virtuals): Adjust.\n        * decl2.c (mark_vtable_entries): Adjust.\n        * method.c (make_thunk, build_vtable_entry): Adjust.\n        * class.c (update_vtable_entry_for_fn): Only look as far as the\n        first defining class.\n        (build_vtbl_initializer): Put nothing in the slot for a function only\n        defined in a lost primary virtual base.\n        (add_vcall_offset_vtbl_entries_1): Use the same code for\n        the lost primary case and the normal case.\n        (dfs_unshared_virtual_bases): Don't lose a non-virtual primary base.\n        (get_vfield_offset, get_derived_offset): Lose.\n        (dfs_find_final_overrider): Use look_for_overrides_here.\n        (get_matching_virtual): New fn.\n        * semantics.c (emit_associated_thunks): Check BV_USE_VCALL_INDEX_P,\n        not BV_VCALL_INDEX.\n        * search.c (look_for_overrides_here): Split out from...\n        (look_for_overrides_r): Here.\n\n        * class.c (find_final_overrider): Return error_mark_node on error.\n\nFrom-SVN: r42949", "tree": {"sha": "54340a199d71a0aa015fcdf4fe886dffdcb11394", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54340a199d71a0aa015fcdf4fe886dffdcb11394"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0cd8b44016194824049ec6ee453d6864b73bc01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0cd8b44016194824049ec6ee453d6864b73bc01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0cd8b44016194824049ec6ee453d6864b73bc01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0cd8b44016194824049ec6ee453d6864b73bc01/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "acf97e0b7570b17a80d9b85d52a7cae9314a8f16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acf97e0b7570b17a80d9b85d52a7cae9314a8f16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acf97e0b7570b17a80d9b85d52a7cae9314a8f16"}], "stats": {"total": 508, "additions": 261, "deletions": 247}, "files": [{"sha": "8ba7f9f19668816a7dededfabcd3066d0a1989c3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0cd8b44016194824049ec6ee453d6864b73bc01/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0cd8b44016194824049ec6ee453d6864b73bc01/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d0cd8b44016194824049ec6ee453d6864b73bc01", "patch": "@@ -1,3 +1,30 @@\n+2001-06-06  Jason Merrill  <jason_merrill@redhat.com>\n+\n+\t* cp-tree.h (THUNK_GENERATE_WITH_VTABLE_P): Lose.\n+\t(struct lang_decl_flags): Lose generate_with_vtable_p.\n+\t(BV_GENERATE_THUNK_WITH_VTABLE_P): Lose.\n+\t* class.c (copy_virtuals): Adjust.\n+\t* decl2.c (mark_vtable_entries): Adjust.\n+\t* method.c (make_thunk, build_vtable_entry): Adjust.\n+\t* class.c (update_vtable_entry_for_fn): Only look as far as the\n+\tfirst defining class.\n+\t(build_vtbl_initializer): Put nothing in the slot for a function only \n+\tdefined in a lost primary virtual base.\n+\t(add_vcall_offset_vtbl_entries_1): Use the same code for \n+\tthe lost primary case and the normal case.\n+\t(dfs_unshared_virtual_bases): Don't lose a non-virtual primary base.\n+\t(get_vfield_offset, get_derived_offset): Lose.\n+\t(dfs_find_final_overrider): Use look_for_overrides_here.\n+\t(get_matching_virtual): New fn.\n+\t* semantics.c (emit_associated_thunks): Check BV_USE_VCALL_INDEX_P,\n+\tnot BV_VCALL_INDEX.\n+\t* search.c (look_for_overrides_here): Split out from...\n+\t(look_for_overrides_r): Here.\n+\n+\t* class.c (find_final_overrider): Return error_mark_node on error.\n+\n+\t* decl2.c (key_method): #if 0 accidental change.\n+\n 2001-06-06  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* call.c (convert_default_arg): Use INTEGRAL_TYPE_P."}, {"sha": "cdd92b5d4c203906af61521fce88c589614f8ed7", "filename": "gcc/cp/class.c", "status": "modified", "additions": 177, "deletions": 187, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0cd8b44016194824049ec6ee453d6864b73bc01/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0cd8b44016194824049ec6ee453d6864b73bc01/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d0cd8b44016194824049ec6ee453d6864b73bc01", "patch": "@@ -74,7 +74,7 @@ typedef struct vtbl_init_data_s\n   /* The negative-index vtable initializers built up so far.  These\n      are in order from least negative index to most negative index.  */\n   tree inits;\n-  /* The last (i.e., most negative entry in INITS.  */\n+  /* The last (i.e., most negative) entry in INITS.  */\n   tree* last_init;\n   /* The binfo for the virtual base for which we're building\n      vcall offset initializers.  */\n@@ -107,9 +107,8 @@ varray_type local_classes;\n static tree get_vfield_name PARAMS ((tree));\n static void finish_struct_anon PARAMS ((tree));\n static tree build_vbase_pointer PARAMS ((tree, tree));\n-static tree build_vtable_entry PARAMS ((tree, tree, tree, int));\n+static tree build_vtable_entry PARAMS ((tree, tree, tree));\n static tree get_vtable_name PARAMS ((tree));\n-static tree get_derived_offset PARAMS ((tree, tree));\n static tree get_basefndecls PARAMS ((tree, tree));\n static int build_primary_vtable PARAMS ((tree, tree));\n static int build_secondary_vtable PARAMS ((tree, tree));\n@@ -684,37 +683,6 @@ get_vtt_name (type)\n   return mangle_vtt_for_type (type);\n }\n \n-/* Return the offset to the main vtable for a given base BINFO.  */\n-\n-tree\n-get_vfield_offset (binfo)\n-     tree binfo;\n-{\n-  return\n-    size_binop (PLUS_EXPR, byte_position (TYPE_VFIELD (BINFO_TYPE (binfo))),\n-\t\tBINFO_OFFSET (binfo));\n-}\n-\n-/* Get the offset to the start of the original binfo that we derived\n-   this binfo from.  If we find TYPE first, return the offset only\n-   that far.  The shortened search is useful because the this pointer\n-   on method calling is expected to point to a DECL_CONTEXT (fndecl)\n-   object, and not a baseclass of it.   */\n-\n-static tree\n-get_derived_offset (binfo, type)\n-     tree binfo, type;\n-{\n-  tree offset1 = get_vfield_offset (TYPE_BINFO (BINFO_TYPE (binfo)));\n-  tree offset2;\n-\n-  while (!same_type_p (BINFO_TYPE (binfo), type))\n-    binfo = get_primary_binfo (binfo);\n-\n-  offset2 = get_vfield_offset (TYPE_BINFO (BINFO_TYPE (binfo)));\n-  return size_binop (MINUS_EXPR, offset1, offset2);\n-}\n-\n /* Create a VAR_DECL for a primary or secondary vtable for CLASS_TYPE.\n    (For a secondary vtable for B-in-D, CLASS_TYPE should be D, not B.)\n    Use NAME for the name of the vtable, and VTABLE_TYPE for its type.  */\n@@ -796,7 +764,6 @@ copy_virtuals (binfo)\n     {\n       BV_VCALL_INDEX (t) = NULL_TREE;\n       BV_USE_VCALL_INDEX_P (t) = 0;\n-      BV_GENERATE_THUNK_WITH_VTABLE_P (t) = 0;\n     }\n \n   return copies;\n@@ -1024,9 +991,11 @@ make_new_vtable (t, binfo)\n {\n   if (binfo == TYPE_BINFO (t))\n     /* In this case, it is *type*'s vtable we are modifying.  We start\n-       with the approximation that it's vtable is that of the\n+       with the approximation that its vtable is that of the\n        immediate base class.  */\n-    return build_primary_vtable (TYPE_BINFO (DECL_CONTEXT (TYPE_VFIELD (t))), \n+    /* ??? This actually passes TYPE_BINFO (t), not the primary base binfo,\n+       since we've updated DECL_CONTEXT (TYPE_VFIELD (t)) by now.  */\n+    return build_primary_vtable (TYPE_BINFO (DECL_CONTEXT (TYPE_VFIELD (t))),\n \t\t\t\t t);\n   else\n     /* This is our very own copy of `basetype' to play with.  Later,\n@@ -1077,7 +1046,12 @@ modify_vtable_entry (t, binfo, fndecl, delta, virtuals)\n       BV_FN (v) = fndecl;\n \n       /* Now assign virtual dispatch information, if unset.  We can\n-\t dispatch this, through any overridden base function.  */\n+\t dispatch this through any overridden base function.\n+\n+\t FIXME this can choose a secondary vtable if the primary is not\n+\t also lexically first, leading to useless conversions.\n+\t In the V3 ABI, there's no reason for DECL_VIRTUAL_CONTEXT to\n+\t ever be different from DECL_CONTEXT.  */\n       if (TREE_CODE (DECL_VINDEX (fndecl)) != INTEGER_CST)\n \t{\n \t  DECL_VINDEX (fndecl) = DECL_VINDEX (base_fndecl);\n@@ -1808,7 +1782,7 @@ mark_primary_virtual_base (binfo, base_binfo, type)\n   return base_binfo;\n }\n \n-/* If BINFO is an unmarked virtual binfo for a class with a primary\n+/* If BINFO is an unmarked virtual binfo for a class with a primary virtual\n    base, then BINFO has no primary base in this graph.  Called from\n    mark_primary_bases. */\n \n@@ -1817,7 +1791,8 @@ static tree dfs_unshared_virtual_bases (binfo, data)\n      void *data ATTRIBUTE_UNUSED;\n {\n   if (TREE_VIA_VIRTUAL (binfo) && !BINFO_MARKED (binfo)\n-      && CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo)))\n+      && CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo))\n+      && TREE_VIA_VIRTUAL (CLASSTYPE_PRIMARY_BINFO (BINFO_TYPE (binfo))))\n     BINFO_LOST_PRIMARY_P (binfo) = 1;\n \n   CLEAR_BINFO_MARKED (binfo);\n@@ -2542,13 +2517,8 @@ dfs_find_final_overrider (binfo, data)\n \t   path; \n \t   path = TREE_CHAIN (path))\n \t{\n-\t  for (method = TYPE_METHODS (BINFO_TYPE (TREE_VALUE (path)));\n-\t       method;\n-\t       method = TREE_CHAIN (method))\n-\t    if (DECL_VIRTUAL_P (method) \n-\t\t&& same_signature_p (method, ffod->fn))\n-\t      break;\n-\n+\t  method = look_for_overrides_here (BINFO_TYPE (TREE_VALUE (path)),\n+\t\t\t\t\t    ffod->fn);\n \t  if (method)\n \t    break;\n \t}\n@@ -2676,7 +2646,7 @@ find_final_overrider (t, binfo, fn)\n        struct T : virtual public R { virtual void f (); };\n        struct U : public S, public T { };\n \n-     is not -- there's no way  to decide whether to put `S::f' or\n+     is not -- there's no way to decide whether to put `S::f' or\n      `T::f' in the vtable for `R'.  \n      \n      The solution is to look at all paths to BINFO.  If we find\n@@ -2695,14 +2665,36 @@ find_final_overrider (t, binfo, fn)\n \n   /* If there was no winner, issue an error message.  */\n   if (!ffod.overriding_fn)\n-    cp_error (\"no unique final overrider for `%D' in `%T'\", fn, t);\n+    {\n+      cp_error (\"no unique final overrider for `%D' in `%T'\", fn, t);\n+      return error_mark_node;\n+    }\n \n   return build_tree_list (ffod.overriding_fn, ffod.overriding_base);\n }\n \n-/* Update a entry in the vtable for BINFO, which is in the hierarchy\n-   dominated by T.  FN has been overridden in BINFO; VIRTUALS points\n-   to the corresponding position in the BINFO_VIRTUALS list.  */\n+#if 0\n+/* Returns the function from the BINFO_VIRTUALS entry in T which matches\n+   the signature of FUNCTION_DECL FN, or NULL_TREE if none.  In other words,\n+   the function that the slot in T's primary vtable points to.  */\n+\n+static tree get_matching_virtual PARAMS ((tree, tree));\n+static tree\n+get_matching_virtual (t, fn)\n+     tree t, fn;\n+{\n+  tree f;\n+\n+  for (f = BINFO_VIRTUALS (TYPE_BINFO (t)); f; f = TREE_CHAIN (f))\n+    if (same_signature_p (BV_FN (f), fn))\n+      return BV_FN (f);\n+  return NULL_TREE;\n+}\n+#endif\n+\n+/* Update an entry in the vtable for BINFO, which is in the hierarchy\n+   dominated by T.  FN has been overriden in BINFO; VIRTUALS points to the\n+   corresponding position in the BINFO_VIRTUALS list.  */\n \n static void\n update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n@@ -2715,93 +2707,92 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n   tree overrider;\n   tree delta;\n   tree virtual_base;\n-  int generate_thunk_with_vtable_p;\n+  tree first_defn;\n \n-  /* Find the function which originally caused this vtable\n-     entry to be present.  */\n-  b = binfo;\n-  while (1)\n+  /* Find the nearest primary base (possibly binfo itself) which defines\n+     this function; this is the class the caller will convert to when\n+     calling FN through BINFO.  */\n+  for (b = binfo; ; b = get_primary_binfo (b))\n     {\n-      tree primary_base;\n-      tree f;\n-\n-      primary_base = get_primary_binfo (b);\n-      if (!primary_base)\n+      if (look_for_overrides_here (BINFO_TYPE (b), fn))\n \tbreak;\n-\n-      for (f = BINFO_VIRTUALS (TYPE_BINFO (BINFO_TYPE (primary_base)));\n-\t   f;\n-\t   f = TREE_CHAIN (f))\n-\tif (same_signature_p (BV_FN (f), fn))\n-\t  break;\n-\n-      if (!f)\n-\tbreak;\n-\n-      fn = BV_FN (f);\n-      b = primary_base;\n     }\n+  first_defn = b;\n \n   /* Find the final overrider.  */\n   overrider = find_final_overrider (t, b, fn);\n   if (overrider == error_mark_node)\n     return;\n \n-  /* Compute the constant adjustment to the `this' pointer.  The\n-     `this' pointer, when this function is called, will point at the\n-     class whose vtable this is.  */\n-  delta = size_binop (PLUS_EXPR,\n-\t\t      get_derived_offset (binfo,\n-\t\t\t\t\t  DECL_VIRTUAL_CONTEXT (fn)),\n-\t\t      BINFO_OFFSET (binfo));\n-\n   /* Assume that we will produce a thunk that convert all the way to\n      the final overrider, and not to an intermediate virtual base.  */\n   virtual_base = NULL_TREE;\n \n-  /* Assume that we will always generate thunks with the vtables that\n-     reference them.  */\n-  generate_thunk_with_vtable_p = 1;\n-\n   /* Under the new ABI, we will convert to an intermediate virtual\n      base first, and then use the vcall offset located there to finish\n      the conversion.  */\n   while (b)\n     {\n-      /* If we find BINFO, then the final overrider is in a class\n-\t derived from BINFO, so the thunks can be generated with\n-\t the final overrider.  */\n-      if (!virtual_base\n-\t  && same_type_p (BINFO_TYPE (b), BINFO_TYPE (binfo)))\n-\tgenerate_thunk_with_vtable_p = 0;\n-\n-\t  /* If we find the final overrider, then we can stop\n-\t     walking.  */\n+      /* If we find the final overrider, then we can stop\n+\t walking.  */\n       if (same_type_p (BINFO_TYPE (b), \n \t\t       BINFO_TYPE (TREE_VALUE (overrider))))\n \tbreak;\n \n-\t  /* If we find a virtual base, and we haven't yet found the\n-\t     overrider, then there is a virtual base between the\n-\t     declaring base and the final overrider.  */\n+      /* If we find a virtual base, and we haven't yet found the\n+\t overrider, then there is a virtual base between the\n+\t declaring base (first_defn) and the final overrider.  */\n       if (!virtual_base && TREE_VIA_VIRTUAL (b))\n-\t{\n-\t  generate_thunk_with_vtable_p = 1;\n-\t  virtual_base = b;\n-\t}\n+\tvirtual_base = b;\n \n       b = BINFO_INHERITANCE_CHAIN (b);\n     }\n \n+  /* Compute the constant adjustment to the `this' pointer.  The\n+     `this' pointer, when this function is called, will point at BINFO\n+     (or one of its primary bases, which are at the same offset).  */\n+\n   if (virtual_base)\n     /* The `this' pointer needs to be adjusted to the nearest virtual\n        base.  */\n-    delta = size_diffop (BINFO_OFFSET (virtual_base), delta);\n+    delta = size_diffop (BINFO_OFFSET (virtual_base),\n+\t\t\t BINFO_OFFSET (binfo));\n   else\n-    /* The `this' pointer needs to be adjusted from pointing to\n-       BINFO to pointing at the base where the final overrider\n-       appears.  */\n-    delta = size_diffop (BINFO_OFFSET (TREE_VALUE (overrider)), delta);\n+    {\n+      /* The `this' pointer needs to be adjusted from pointing to\n+\t BINFO to pointing at the base where the final overrider\n+\t appears.  */\n+      delta = size_diffop (BINFO_OFFSET (TREE_VALUE (overrider)),\n+\t\t\t   BINFO_OFFSET (binfo));\n+\n+#if 0\n+      /* Disable this optimization pending an ABI change, or until\n+\t we can force emission of the non-virtual thunk even if we don't\n+\t use it.  */\n+      if (! integer_zerop (delta))\n+\t{\n+\t  /* We'll need a thunk.  But if we have a (perhaps formerly)\n+\t     primary virtual base, we have a vcall slot for this function,\n+\t     so we can use it rather than create a non-virtual thunk.  */\n+\n+\t  b = get_primary_binfo (first_defn);\n+\t  for (; b; b = get_primary_binfo (b))\n+\t    {\n+\t      tree f = get_matching_virtual (BINFO_TYPE (b), fn);\n+\t      if (!f)\n+\t\t/* b doesn't have this function; no suitable vbase.  */\n+\t\tbreak;\n+\t      if (TREE_VIA_VIRTUAL (b))\n+\t\t{\n+\t\t  /* Found one; we can treat ourselves as a virtual base.  */\n+\t\t  virtual_base = binfo;\n+\t\t  delta = size_zero_node;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+#endif\n+    }\n \n   modify_vtable_entry (t, \n \t\t       binfo, \n@@ -2811,8 +2802,6 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n \n   if (virtual_base)\n     BV_USE_VCALL_INDEX_P (*virtuals) = 1;\n-  if (generate_thunk_with_vtable_p)\n-    BV_GENERATE_THUNK_WITH_VTABLE_P (*virtuals) = 1;\n }\n \n /* Called from modify_all_vtables via dfs_walk.  */\n@@ -2823,9 +2812,9 @@ dfs_modify_vtables (binfo, data)\n      void *data;\n {\n   if (/* There's no need to modify the vtable for a non-virtual\n-         primary base; we're not going to use that vtable anyhow\n-         (virtual primary bases can become non-primary in a\n-         class derivation of this one.) */\n+         primary base; we're not going to use that vtable anyhow.\n+\t We do still need to do this for virtual primary bases, as they\n+\t could become non-primary in a construction vtable.  */\n       (!BINFO_PRIMARY_P (binfo) || TREE_VIA_VIRTUAL (binfo))\n       /* Similarly, a base without a vtable needs no modification.  */\n       && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n@@ -5310,9 +5299,7 @@ finish_struct_1 (t)\n   layout_class_type (t, &empty, &vfuns,\n \t\t     &new_virtuals, &overridden_virtuals);\n \n-  /* Set up the DECL_FIELD_BITPOS of the vfield if we need to, as we\n-     might need to know it for setting up the offsets in the vtable\n-     (or in thunks) below.  */\n+  /* Make sure that we get our own copy of the vfield FIELD_DECL.  */\n   vfield = TYPE_VFIELD (t);\n   if (vfield != NULL_TREE\n       && DECL_FIELD_CONTEXT (vfield) != t)\n@@ -7667,7 +7654,7 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n      tree rtti_binfo;\n      int *non_fn_entries_p;\n {\n-  tree v;\n+  tree v, b;\n   tree vfun_inits;\n   tree vbase;\n   vtbl_init_data vid;\n@@ -7714,7 +7701,6 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n       tree fn;\n       tree pfn;\n       tree init;\n-      int generate_with_vtable_p = BV_GENERATE_THUNK_WITH_VTABLE_P (v);\n       \n       /* Pull the offset for `this', and the function to call, out of\n \t the list.  */\n@@ -7725,15 +7711,6 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n \t  vcall_index = BV_VCALL_INDEX (v);\n \t  my_friendly_assert (vcall_index != NULL_TREE, 20000621);\n \t}\n-      else if (vid.ctor_vtbl_p && BV_VCALL_INDEX (v))\n-        {\n-          /* In the original, we did not need to use the vcall index, even\n-             though there was one, but in a ctor vtable things might be\n-             different (a primary virtual base might have moved). Be\n-             conservative and use a vcall adjusting thunk.  */\n-\t  vcall_index = BV_VCALL_INDEX (v);\n-          generate_with_vtable_p = 1;\n-        }\n       else\n         vcall_index = NULL_TREE;\n \n@@ -7751,9 +7728,35 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n       pfn = build1 (ADDR_EXPR, vfunc_ptr_type_node, fn);\n       /* The address of a function can't change.  */\n       TREE_CONSTANT (pfn) = 1;\n+\n       /* Enter it in the vtable.  */\n-      init = build_vtable_entry (delta, vcall_index, pfn,\n-\t\t\t\t generate_with_vtable_p);\n+      init = build_vtable_entry (delta, vcall_index, pfn);\n+\n+      /* If the only definition of this function signature along our\n+\t primary base chain is from a lost primary, this vtable slot will\n+\t never be used, so just zero it out.  This is important to avoid\n+\t requiring extra thunks which cannot be generated with the function.\n+\n+\t We could also handle this in update_vtable_entry_for_fn; doing it\n+\t here means we zero out unused slots in ctor vtables as well,\n+\t rather than filling them with erroneous values (though harmless,\n+\t apart from relocation costs).  */\n+      if (fn != abort_fndecl)\n+\tfor (b = binfo; ; b = get_primary_binfo (b))\n+\t  {\n+\t    /* We found a defn before a lost primary; go ahead as normal.  */\n+\t    if (look_for_overrides_here (BINFO_TYPE (b), fn))\n+\t      break;\n+\n+\t    /* The nearest definition is from a lost primary; clear the\n+\t       slot.  */\n+\t    if (BINFO_LOST_PRIMARY_P (b))\n+\t      {\n+\t\tinit = size_zero_node;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\n       /* And add it to the chain of initializers.  */\n       vfun_inits = tree_cons (NULL_TREE, init, vfun_inits);\n     }\n@@ -7769,7 +7772,7 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n   return chainon (vid.inits, vfun_inits);\n }\n \n-/* Sets vid->inits to be the initializers for the vbase and vcall\n+/* Adds to vid->inits the initializers for the vbase and vcall\n    offsets in BINFO, which is in the hierarchy dominated by T.  */\n \n static void\n@@ -7877,8 +7880,8 @@ build_vbase_offset_vtbl_entries (binfo, vid)\n }\n \n /* Adds the initializers for the vcall offset entries in the vtable\n-   for BINFO (which is part of the class hierarchy dominated by T) to\n-   VID->INITS.  */\n+   for BINFO (which is part of the class hierarchy dominated by VID->DERIVED)\n+   to VID->INITS.  */\n \n static void\n build_vcall_offset_vtbl_entries (binfo, vid)\n@@ -7898,22 +7901,20 @@ build_vcall_offset_vtbl_entries (binfo, vid)\n      vtable.  For example:\n \n        class A { virtual void f (); };\n-       class B : virtual public A { };\n-       class C: virtual public A, public B {};\n-      \n-     Now imagine:\n-\n-       B* b = new C;\n-       b->f();\n-\n-     The location of `A' is not at a fixed offset relative to `B'; the\n-     offset depends on the complete object derived from `B'.  So, \n-     `B' vtable contains an entry for `f' that indicates by what\n-     amount the `this' pointer for `B' needs to be adjusted to arrive\n-     at `A'.  \n+       class B1 : virtual public A { virtual void f (); };\n+       class B2 : virtual public A { virtual void f (); };\n+       class C: public B1, public B2 { virtual void f (); };\n+\n+     A C object has a primary base of B1, which has a primary base of A.  A\n+     C also has a secondary base of B2, which no longer has a primary base\n+     of A.  So the B2-in-C construction vtable needs a secondary vtable for\n+     A, which will adjust the A* to a B2* to call f.  We have no way of\n+     knowing what (or even whether) this offset will be when we define B2,\n+     so we store this \"vcall offset\" in the A sub-vtable and look it up in\n+     a \"virtual thunk\" for B2::f.\n \n      We need entries for all the functions in our primary vtable and\n-     in our non-virtual bases vtables.  */\n+     in our non-virtual bases' secondary vtables.  */\n   vid->vbase = binfo;\n   /* Now, walk through the non-virtual bases, adding vcall offsets.  */\n   add_vcall_offset_vtbl_entries_r (binfo, vid);\n@@ -7930,7 +7931,9 @@ add_vcall_offset_vtbl_entries_r (binfo, vid)\n   tree primary_binfo;\n \n   /* Don't walk into virtual bases -- except, of course, for the\n-     virtual base for which we are building vcall offsets.  */\n+     virtual base for which we are building vcall offsets.  Any\n+     primary virtual base will have already had its offsets generated\n+     through the recursion in build_vcall_and_vbase_vtbl_entries.  */\n   if (TREE_VIA_VIRTUAL (binfo) && vid->vbase != binfo)\n     return;\n   \n@@ -7964,43 +7967,30 @@ add_vcall_offset_vtbl_entries_1 (binfo, vid)\n   tree base_virtuals;\n   tree orig_virtuals;\n   tree binfo_inits;\n-  int lost_primary = 0;\n-  /* If BINFO is a primary base, this is the least derived class of\n-     BINFO that is not a primary base.  */\n+  /* If BINFO is a primary base, the most derived class which has BINFO as\n+     a primary base; otherwise, just BINFO.  */\n   tree non_primary_binfo;\n \n   binfo_inits = NULL_TREE;\n \n-  /* We might be a primary base class.  Go up the inheritance\n-     hierarchy until we find the class of which we are a primary base:\n+  /* We might be a primary base class.  Go up the inheritance hierarchy\n+     until we find the most derived class of which we are a primary base:\n      it is the BINFO_VIRTUALS there that we need to consider.  */\n   non_primary_binfo = binfo;\n   while (BINFO_INHERITANCE_CHAIN (non_primary_binfo))\n     {\n       tree b;\n \n-      /* If we have reached a virtual base, then it must be the\n-\t virtual base for which we are building vcall offsets.  In\n-\t turn, the virtual base must be a (possibly indirect) primary\n-\t base of the class that we are initializing, or we wouldn't\n-\t care about its vtable offsets.  */\n+      /* If we have reached a virtual base, then it must be vid->vbase,\n+\t because we ignore other virtual bases in\n+\t add_vcall_offset_vtbl_entries_r.  In turn, it must be a primary\n+\t base (possibly multi-level) of vid->binfo, or we wouldn't\n+\t have called build_vcall_and_vbase_vtbl_entries for it.  But it\n+\t might be a lost primary, so just skip down to vid->binfo.  */\n       if (TREE_VIA_VIRTUAL (non_primary_binfo))\n \t{\n-\t  if (vid->ctor_vtbl_p)\n-\t    {\n-    \t      tree probe;\n-\t  \n-\t      for (probe = vid->binfo;\n-\t           probe != non_primary_binfo;\n-\t           probe = get_primary_binfo (probe))\n-\t        {\n-                  if (BINFO_LOST_PRIMARY_P (probe))\n-                    {\n-                      lost_primary = 1;\n-                      break;\n-                    }\n-\t        }\n-            }\n+\t  if (non_primary_binfo != vid->vbase)\n+\t    abort ();\n \t  non_primary_binfo = vid->binfo;\n \t  break;\n \t}\n@@ -8034,13 +8024,12 @@ add_vcall_offset_vtbl_entries_1 (binfo, vid)\n       tree vcall_offset;\n \n       /* Find the declaration that originally caused this function to\n-\t be present.  */\n+\t be present in BINFO_TYPE (binfo).  */\n       orig_fn = BV_FN (orig_virtuals);\n \n-      /* We do not need an entry if this function is declared in a\n-\t virtual base (or one of its virtual bases), and not\n-\t overridden in the section of the hierarchy dominated by the\n-\t virtual base for which we are building vcall offsets.  */\n+      /* When processing BINFO, we only want to generate vcall slots for\n+\t function slots introduced in BINFO.  So don't try to generate\n+\t one if the function isn't even defined in BINFO.  */\n       if (!same_type_p (DECL_CONTEXT (orig_fn), BINFO_TYPE (binfo)))\n \tcontinue;\n \n@@ -8071,16 +8060,19 @@ add_vcall_offset_vtbl_entries_1 (binfo, vid)\n       if (i != VARRAY_ACTIVE_SIZE (vid->fns))\n \tcontinue;\n \n-      /* The FN comes from BASE.  So, we must calculate the adjustment\n-\t from the virtual base that derived from BINFO to BASE.  */\n+      /* The FN comes from BASE.  So, we must calculate the adjustment from\n+\t vid->vbase to BASE.  We can just look for BASE in the complete\n+\t object because we are converting from a virtual base, so if there\n+\t were multiple copies, there would not be a unique final overrider\n+\t and vid->derived would be ill-formed.  */\n       base = DECL_CONTEXT (fn);\n       base_binfo = get_binfo (base, vid->derived, /*protect=*/0);\n \n       /* Compute the vcall offset.  */\n-      vcall_offset = BINFO_OFFSET (vid->vbase);\n-      if (lost_primary)\n-        vcall_offset = size_binop (PLUS_EXPR, vcall_offset,\n-                                   BINFO_OFFSET (vid->binfo));\n+      /* As mentioned above, the vbase we're working on is a primary base of\n+\t vid->binfo.  But it might be a lost primary, so its BINFO_OFFSET\n+         might be wrong, so we just use the BINFO_OFFSET from vid->binfo.  */\n+      vcall_offset = BINFO_OFFSET (vid->binfo);\n       vcall_offset = size_diffop (BINFO_OFFSET (base_binfo),\n \t\t                  vcall_offset);\n       vcall_offset = fold (build1 (NOP_EXPR, vtable_entry_type,\n@@ -8091,7 +8083,7 @@ add_vcall_offset_vtbl_entries_1 (binfo, vid)\n \n       /* Keep track of the vtable index where this vcall offset can be\n \t found.  For a construction vtable, we already made this\n-\t annotation when we build the original vtable.  */\n+\t annotation when we built the original vtable.  */\n       if (!vid->ctor_vtbl_p)\n \tBV_VCALL_INDEX (derived_virtuals) = vid->index;\n \n@@ -8172,11 +8164,10 @@ build_rtti_vtbl_entries (binfo, vid)\n    ABI.)  */\n \n static tree\n-build_vtable_entry (delta, vcall_index, entry, generate_with_vtable_p)\n+build_vtable_entry (delta, vcall_index, entry)\n      tree delta;\n      tree vcall_index;\n      tree entry;\n-     int generate_with_vtable_p;\n {\n   if (flag_vtable_thunks)\n     {\n@@ -8186,8 +8177,7 @@ build_vtable_entry (delta, vcall_index, entry, generate_with_vtable_p)\n       if ((!integer_zerop (delta) || vcall_index != NULL_TREE)\n \t  && fn != abort_fndecl)\n \t{\n-\t  entry = make_thunk (entry, delta, vcall_index,\n-\t\t\t      generate_with_vtable_p);\n+\t  entry = make_thunk (entry, delta, vcall_index);\n \t  entry = build1 (ADDR_EXPR, vtable_entry_type, entry);\n \t  TREE_READONLY (entry) = 1;\n \t  TREE_CONSTANT (entry) = 1;"}, {"sha": "b73626a331000a03ff99c74323bf2bd0340fb186", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0cd8b44016194824049ec6ee453d6864b73bc01/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0cd8b44016194824049ec6ee453d6864b73bc01/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d0cd8b44016194824049ec6ee453d6864b73bc01", "patch": "@@ -55,7 +55,6 @@ Boston, MA 02111-1307, USA.  */\n       BASELINK_P (in TREE_LIST)\n       ICS_ELLIPSIS_FLAG (in _CONV)\n       BINFO_ACCESS (in BINFO)\n-      BV_GENERATE_THUNK_WITH_VTABLE_P (in TREE_LIST)\n    2: IDENTIFIER_OPNAME_P.\n       TYPE_POLYMORHPIC_P (in _TYPE)\n       ICS_THIS_FLAG (in _CONV)\n@@ -133,10 +132,6 @@ Boston, MA 02111-1307, USA.  */\n \n      The BV_FN is the declaration for the virtual function itself.\n \n-     The BV_OVERRIDING_BASE is the binfo for the final overrider for\n-     this function.  (That binfo's BINFO_TYPE will always be the same\n-     as the DECL_CLASS_CONTEXT for the function.)\n-\n    BINFO_VTABLE\n      Sometimes this is a VAR_DECL.  Under the new ABI, it is instead\n      an expression with POINTER_TYPE pointing that gives the value\n@@ -1736,14 +1731,6 @@ struct lang_type\n /* Nonzero if we should use a virtual thunk for this entry.  */\n #define BV_USE_VCALL_INDEX_P(NODE) \\\n    (TREE_LANG_FLAG_0 (NODE))\n-\n-/* Nonzero if we should generate this thunk when the vtable that\n-   references it is emitted, rather than with the final overrider.  */\n-#define BV_GENERATE_THUNK_WITH_VTABLE_P(NODE) \\\n-  (TREE_LANG_FLAG_1 (NODE))\n-\n-/* The most derived class.  */\n-\n \f\n /* Nonzero for TREE_LIST node means that this list of things\n    is a list of parameters, as opposed to a list of expressions.  */\n@@ -1806,8 +1793,7 @@ struct lang_decl_flags\n   unsigned global_dtor_p : 1;\n   unsigned assignment_operator_p : 1;\n   unsigned anticipated_p : 1;\n-  unsigned generate_with_vtable_p : 1;\n-  /* Two unused bits.  */\n+  /* Three unused bits.  */\n \n   union {\n     /* In a FUNCTION_DECL, VAR_DECL, TYPE_DECL, or TEMPLATE_DECL, this\n@@ -3036,11 +3022,6 @@ enum ptrmemfunc_vbit_where_t\n #define THUNK_VCALL_OFFSET(DECL) \\\n   (DECL_LANG_SPECIFIC (DECL)->decl_flags.u2.vcall_offset)\n \n-/* Nonzero if this thunk should be generated with the vtable that\n-   references it.  */\n-#define THUNK_GENERATE_WITH_VTABLE_P(DECL) \\\n-  (DECL_LANG_SPECIFIC (DECL)->decl_flags.generate_with_vtable_p)\n-\n /* These macros provide convenient access to the various _STMT nodes\n    created when parsing template declarations.  */\n #define TRY_STMTS(NODE)         TREE_OPERAND (TRY_BLOCK_CHECK (NODE), 0)\n@@ -3716,7 +3697,6 @@ extern tree get_vtable_decl                     PARAMS ((tree, int));\n extern void add_method\t\t\t\tPARAMS ((tree, tree, int));\n extern int currently_open_class\t\t\tPARAMS ((tree));\n extern tree currently_open_derived_class\tPARAMS ((tree));\n-extern tree get_vfield_offset\t\t\tPARAMS ((tree));\n extern void duplicate_tag_error\t\t\tPARAMS ((tree));\n extern tree finish_struct\t\t\tPARAMS ((tree, tree));\n extern void finish_struct_1\t\t\tPARAMS ((tree));\n@@ -4083,7 +4063,7 @@ extern void init_method\t\t\t\tPARAMS ((void));\n extern void set_mangled_name_for_decl           PARAMS ((tree));\n extern tree build_opfncall\t\t\tPARAMS ((enum tree_code, int, tree, tree, tree));\n extern tree hack_identifier\t\t\tPARAMS ((tree, tree));\n-extern tree make_thunk\t\t\t\tPARAMS ((tree, tree, tree, int));\n+extern tree make_thunk\t\t\t\tPARAMS ((tree, tree, tree));\n extern void use_thunk\t\t\t\tPARAMS ((tree, int));\n extern void synthesize_method\t\t\tPARAMS ((tree));\n extern tree implicitly_declare_fn               PARAMS ((special_function_kind, tree, int));\n@@ -4202,6 +4182,7 @@ extern tree context_for_name_lookup\t\tPARAMS ((tree));\n extern tree lookup_conversions\t\t\tPARAMS ((tree));\n extern tree binfo_for_vtable\t\t\tPARAMS ((tree));\n extern tree binfo_from_vbase\t\t\tPARAMS ((tree));\n+extern tree look_for_overrides_here\t\tPARAMS ((tree, tree));\n extern tree dfs_walk                            PARAMS ((tree,\n \t\t\t\t\t\t       tree (*) (tree, void *),\n \t\t\t\t\t\t       tree (*) (tree, void *),"}, {"sha": "56c4dbc0c0fac50a61965d9251006e3e545943ec", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0cd8b44016194824049ec6ee453d6864b73bc01/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0cd8b44016194824049ec6ee453d6864b73bc01/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d0cd8b44016194824049ec6ee453d6864b73bc01", "patch": "@@ -2265,7 +2265,7 @@ mark_vtable_entries (decl)\n \t we know all the thunks we'll need when we emit a virtual\n \t function, so we emit the thunks there instead.  */\n       if (DECL_THUNK_P (fn)) \n-\tuse_thunk (fn, THUNK_GENERATE_WITH_VTABLE_P (fn));\n+\tuse_thunk (fn, /*emit_p=*/0);\n       mark_used (fn);\n     }\n }\n@@ -2369,7 +2369,12 @@ key_method (type)\n        method = TREE_CHAIN (method))\n     if (DECL_VINDEX (method) != NULL_TREE\n \t&& ! DECL_DECLARED_INLINE_P (method)\n-\t&& (! DECL_PURE_VIRTUAL_P (method) || DECL_DESTRUCTOR_P (method)))\n+\t&& (! DECL_PURE_VIRTUAL_P (method)\n+#if 0\n+\t    /* This would be nice, but we didn't think of it in time.  */\n+\t    || DECL_DESTRUCTOR_P (method)\n+#endif\n+\t    ))\n       return method;\n \n   return NULL_TREE;"}, {"sha": "4acf6b670b0331ba1926869611bb695bcfb0ce69", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0cd8b44016194824049ec6ee453d6864b73bc01/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0cd8b44016194824049ec6ee453d6864b73bc01/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=d0cd8b44016194824049ec6ee453d6864b73bc01", "patch": "@@ -295,11 +295,10 @@ request for member `%D' is ambiguous in multiple inheritance lattice\",\n    DELTA is the offset to this and VCALL_INDEX is zero.  */\n \n tree\n-make_thunk (function, delta, vcall_index, generate_with_vtable_p)\n+make_thunk (function, delta, vcall_index)\n      tree function;\n      tree delta;\n      tree vcall_index;\n-     int generate_with_vtable_p;\n {\n   tree thunk_id;\n   tree thunk;\n@@ -348,7 +347,6 @@ make_thunk (function, delta, vcall_index, generate_with_vtable_p)\n       DECL_INITIAL (thunk) = function;\n       THUNK_DELTA (thunk) = d;\n       THUNK_VCALL_OFFSET (thunk) = vcall_offset;\n-      THUNK_GENERATE_WITH_VTABLE_P (thunk) = generate_with_vtable_p;\n       /* The thunk itself is not a constructor or destructor, even if\n          the thing it is thunking to is.  */\n       DECL_INTERFACE_KNOWN (thunk) = 1;\n@@ -381,7 +379,6 @@ void\n use_thunk (thunk_fndecl, emit_p)\n      tree thunk_fndecl;\n      int emit_p;\n-     \n {\n   tree fnaddr;\n   tree function;"}, {"sha": "81826c175b6622f9fefc247ee7c295bdf50cae15", "filename": "gcc/cp/search.c", "status": "modified", "additions": 44, "deletions": 28, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0cd8b44016194824049ec6ee453d6864b73bc01/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0cd8b44016194824049ec6ee453d6864b73bc01/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=d0cd8b44016194824049ec6ee453d6864b73bc01", "patch": "@@ -2024,56 +2024,72 @@ look_for_overrides (type, fndecl)\n   return found;\n }\n \n-/* Look in TYPE for virtual functions overridden by FNDECL. Check both\n-   TYPE itself and its bases. */\n+/* Look in TYPE for virtual functions with the same signature as FNDECL.\n+   This differs from get_matching_virtual in that it will only return\n+   a function from TYPE.  */\n \n-static int\n-look_for_overrides_r (type, fndecl)\n+tree\n+look_for_overrides_here (type, fndecl)\n      tree type, fndecl;\n {\n   int ix;\n-  \n-  if (DECL_DESTRUCTOR_P (fndecl))\n+\n+  if (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fndecl))\n     ix = CLASSTYPE_DESTRUCTOR_SLOT;\n   else\n     ix = lookup_fnfields_1 (type, DECL_NAME (fndecl));\n   if (ix >= 0)\n     {\n       tree fns = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), ix);\n-      tree dtypes = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n-      tree thistype = DECL_STATIC_FUNCTION_P (fndecl)\n-                      ? NULL_TREE : TREE_TYPE (TREE_VALUE (dtypes));\n   \n       for (; fns; fns = OVL_NEXT (fns))\n         {\n           tree fn = OVL_CURRENT (fns);\n-          tree btypes = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-          \n+\n           if (!DECL_VIRTUAL_P (fn))\n-            /*  Not a virtual */;\n+            /* Not a virtual.  */;\n           else if (DECL_CONTEXT (fn) != type)\n-            /*  Introduced with a using declaration */;\n-\t  else if (thistype == NULL_TREE)\n+            /* Introduced with a using declaration.  */;\n+\t  else if (DECL_STATIC_FUNCTION_P (fndecl))\n \t    {\n-\t      if (compparms (TREE_CHAIN (btypes), dtypes))\n-                {\n-                  /* A static member function cannot match an inherited\n-                     virtual member function.  */\n-                  cp_error_at (\"`%#D' cannot be declared\", fndecl);\n-                  cp_error_at (\"  since `%#D' declared in base class\", fn);\n-                  return 1;\n-                }\n+\t      tree btypes = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+\t      tree dtypes = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+  \t      if (compparms (TREE_CHAIN (btypes), dtypes))\n+\t\treturn fn;\n             }\n           else if (same_signature_p (fndecl, fn))\n-            {\n-\t      /* It's definitely virtual, even if not explicitly set.  */\n-\t      DECL_VIRTUAL_P (fndecl) = 1;\n-\t      check_final_overrider (fndecl, fn);\n+\t    return fn;\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n \n-\t      return 1;\n-\t    }\n+/* Look in TYPE for virtual functions overridden by FNDECL. Check both\n+   TYPE itself and its bases. */\n+\n+static int\n+look_for_overrides_r (type, fndecl)\n+     tree type, fndecl;\n+{\n+  tree fn = look_for_overrides_here (type, fndecl);\n+  if (fn)\n+    {\n+      if (DECL_STATIC_FUNCTION_P (fndecl))\n+\t{\n+\t  /* A static member function cannot match an inherited\n+\t     virtual member function.  */\n+\t  cp_error_at (\"`%#D' cannot be declared\", fndecl);\n+\t  cp_error_at (\"  since `%#D' declared in base class\", fn);\n+\t}\n+      else\n+\t{\n+\t  /* It's definitely virtual, even if not explicitly set.  */\n+\t  DECL_VIRTUAL_P (fndecl) = 1;\n+\t  check_final_overrider (fndecl, fn);\n \t}\n+      return 1;\n     }\n+\n   /* We failed to find one declared in this class. Look in its bases.  */\n   return look_for_overrides (type, fndecl);\n }"}, {"sha": "9dddf230ddd90a2d587bd906e5be0e78f398ef68", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0cd8b44016194824049ec6ee453d6864b73bc01/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0cd8b44016194824049ec6ee453d6864b73bc01/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d0cd8b44016194824049ec6ee453d6864b73bc01", "patch": "@@ -2300,7 +2300,7 @@ emit_associated_thunks (fn)\n \tfor (v = BINFO_VIRTUALS (binfo); v; v = TREE_CHAIN (v))\n \t  if (BV_FN (v) == fn\n \t      && (!integer_zerop (BV_DELTA (v))\n-\t\t  || BV_VCALL_INDEX (v)))\n+\t\t  || BV_USE_VCALL_INDEX_P (v)))\n \t    {\n \t      tree thunk;\n \t      tree vcall_index;\n@@ -2317,8 +2317,7 @@ emit_associated_thunks (fn)\n \t\t\t\t\t  vfunc_ptr_type_node,\n \t\t\t\t\t  fn),\n \t\t\t\t  BV_DELTA (v),\n-\t\t\t\t  vcall_index,\n-\t\t\t\t  /*generate_with_vtable_p=*/0);\n+\t\t\t\t  vcall_index);\n \t      use_thunk (thunk, /*emit_p=*/1);\n \t    }\n     }"}, {"sha": "808e56d241e5f878cf6723c7eabd2520967c6528", "filename": "gcc/testsuite/g++.dg/mangle1.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0cd8b44016194824049ec6ee453d6864b73bc01/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmangle1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0cd8b44016194824049ec6ee453d6864b73bc01/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmangle1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmangle1.C?ref=d0cd8b44016194824049ec6ee453d6864b73bc01", "patch": "@@ -26,4 +26,3 @@ C c;\n // { dg-final { scan-assembler mangle1.C \"\\n_ZTT1C:\" } }\n // { dg-final { scan-assembler mangle1.C \"\\n_ZTV1A:\" } }\n // { dg-final { scan-assembler mangle1.C \"\\n_ZTV1C:\" } }\n-// { dg-final { scan-assembler mangle1.C \"\\n_ZTv0_n\\(12|24\\)_N1A1fEv:\" } }"}]}