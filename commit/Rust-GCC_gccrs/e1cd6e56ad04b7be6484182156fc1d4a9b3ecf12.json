{"sha": "e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFjZDZlNTZhZDA0YjdiZTY0ODQxODIxNTZmYzFkNGE5YjNlY2YxMg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-01-24T08:19:58Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-01-24T08:19:58Z"}, "message": "53rd Cygnus<->FSF merge\n\nFrom-SVN: r8794", "tree": {"sha": "2e419e0011c5d5a08784d03105e0a98dd36b2c32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e419e0011c5d5a08784d03105e0a98dd36b2c32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/comments", "author": null, "committer": null, "parents": [{"sha": "43238b97ad68430cc52df6df558c3fb4c62bb502", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43238b97ad68430cc52df6df558c3fb4c62bb502", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43238b97ad68430cc52df6df558c3fb4c62bb502"}], "stats": {"total": 2186, "additions": 1307, "deletions": 879}, "files": [{"sha": "6667807b4d35c23792b67a91707413bc4ce19494", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 369, "deletions": 6, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "patch": "@@ -1,18 +1,381 @@\n+Mon Jan 23 21:57:14 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* pt.c (tsubst): When we copy a node, don't forget to copy\n+\tTREE_CHAIN, we use it later.\n+\n+Mon Jan 23 03:33:47 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (convert_for_assignment): Initialize variable before use.\n+\n+Fri Jan 20 01:17:59 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* g++.c (main): Link with both libstdc++ and libg++ if called as\n+\tsomething ending with \"g++\", otherwise only libstdc++.  Move -lm to\n+\tthe end of the line.\n+\n+Thu Jan 19 15:43:11 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* call.c (build_method_call): Don't mess with 'this' before calling\n+        compute_conversion_costs.\n+\n+Wed Jan 18 15:40:55 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* search.c (get_matching_virtual): Give line number for previous\n+        declaration.\n+\n+\t* call.c (convert_harshness): Handle conversions to references\n+\tbetter.\n+\n+\t* cvt.c (build_up_reference): OK, handle {MIN,MAX}_EXPR *properly*.\n+\n+Wed Jan 18 15:21:38 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* class.c (instantiate_type): Use DECL_CHAIN to walk lists instead,\n+\tas the TREE_CHAIN for methods will take us to the next differently\n+\tnamed function, DECL_CHAIN won't.\n+\n+Wed Jan 18 14:26:59 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* tree.c (lvalue_p): Handle {MIN,MAX}_EXPR.\n+\n+\t* decl2.c (lang_decode_option): -Wall implies -Wparentheses.\n+\twarn_parentheses defaults to 0.\n+\n+\t* decl.c (grokparms): Put back call to require_instantiated_type.\n+\n+Tue Jan 17 19:56:15 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (exception_section): Use the data section on the rs6000.\n+\tChange calling convention for named_section.\n+\n+Wed Jan 17 18:20:57 1994  Fergus Henderson <fjh@munta.cs.mu.oz.au>\n+\n+        * cp-tree.h : Make if (x=0) warn with wall\n+        * parse.y : Make if (x=0) warn with wall\n+\n Tue Jan 17 14:12:00 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n-        * cvt.c (cp_convert): Just call truthvalue_conversion to convert to\n+\t* decl.c (BOOL_TYPE_SIZE): BITS_PER_WORD if SLOW_BYTE_ACCESS,\n+\tBITS_PER_UNIT otherwise.\n+\n+\t* search.c (get_matching_virtual): Don't check the binfo if the\n+\ttypes are the same.\n+\n+\t* cvt.c (cp_convert): Just call truthvalue_conversion to convert to\n         bool.\n \n Mon Jan 16 13:28:48 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n-        * various: Use boolean_type_node, boolean_true_node,\n-        boolean_false_node.\n+\t* various: Use boolean_type_node, boolean_true_node,\n+\tboolean_false_node.\n+\n+\t* search.c (get_matching_virtual): Allow covariant returns that\n+\tdon't require pointer adjustment.\n+\n+\t* typeck.c (build_conditional_expr): Don't call default_conversion\n+\ton ifexp.\n+\n+\t* cvt.c (build_up_reference): Handle MIN_EXPR and MAX_EXPR.\n+\n+\t* decl.c (grokdeclarator): Upgrade warning about &const to pedwarn.\n+\n+Sun Jan 15 22:17:32 1995  dcb@lovat.fmrco.COM (David Binderman)\n+\n+\t* pt.c (do_function_instantiation): Free targs once we're done.\n \n Sun Jan 15 22:17:32 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n-        * decl.c (BOOL_TYPE_SIZE): Defaults to BITS_PER_WORD.\n-        (init_decl_processing): Use BOOL_TYPE_SIZE instead of CHAR_TYPE_SIZE\n-        for bool.\n+\t* decl.c (BOOL_TYPE_SIZE): Defaults to BITS_PER_WORD.\n+\t(init_decl_processing): Use BOOL_TYPE_SIZE instead of CHAR_TYPE_SIZE\n+\tfor bool.\n+\n+Sat Jan 14 05:33:55 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl2.c (finish_file): We need to mess up if there are any\n+\tvariables in the list, not just if there is one with a constructor.\n+\n+Fri Jan 13 14:42:55 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (duplicate_decls): Propagate DECL_STATIC_{CON,DE}STRUCTOR.\n+\t(finish_function): Handle DECL_STATIC_{CON,DE}STRUCTOR.\n+\t(finish_function): Trust rest_of_compilation.\n+\n+\t* decl2.c (finish_file): Also call functions designated as static\n+\tconstructors/destructors.\n+\n+\t* decl.c (grokdeclarator): Allow access decls of operator functions.\n+\t(grokparms): Only do convert_for_initialization if the initializer\n+\thas a type.\n+\t(duplicate_decls): Put back push_obstacks_nochange call.\n+\n+\t* lex.c (real_yylex): Downgrade complaint about the escape sequence\n+\tbeing too large from pedwarn to warning.\n+\n+\t* decl.c (grokdeclarator): Don't complain about long long in system\n+\theaders.\n+\n+\t* lex.c (real_yylex): Handle digraphs.\n+\n+Thu Jan 12 12:17:24 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (init_decl_processing): -f{no-,}strict-prototype only\n+\taffects C linkage declarations now.\n+\n+\t* typeck.c (comp_target_types): Grok simple contravariant conversions.\n+\t(common_type): t1 and t2 are interchangeable.\n+\n+\t* various: Test return value of comp_target_types differently in\n+\tdifferent places; it now returns -1 for a contravariant conversion\n+\t(which is fine in symmetric cases).\n+\n+\t(common_type): Prefer long double to double even when\n+\tthey have the same precision.\n+\n+\t* decl.c (grokparms): Call convert_for_initialization to check\n+\tdefault arguments.\n+\n+\t* init.c (build_new): void_type_node has a size (of 0).\n+\n+\t* decl.c (decls_match): Also check for agreement of TREE_READONLY\n+\tand TREE_THIS_VOLATILE.\n+\t(push_class_level_binding): Properly handle shadowing of\n+\tnested tags by fields.\n+\n+\t* search.c (dfs_pushdecls): Ditto.\n+\n+\t* decl2.c (finish_file): Don't second-guess self-initialization.\n+\n+\t* cvt.c (convert_to_reference): Work with expr directly, rather than\n+\ta copy.\n+\n+\t* decl.c (push_overloaded_decl): Only shadow artificial TYPE_DECLs.\n+\n+\t* init.c (add_friend): Downgrade duplicate friend message from\n+\tpedwarn to warning.\n+\n+\t* decl.c (duplicate_decls): Push obstacks before calling common_type.\n+\n+Thu Jan 12 17:15:21 1995  Michael Ben-Gershon  <mybg@cs.huji.ac.il>\n+\n+\t* except.c (push_eh_entry): set LABEL_PRESERVE_P flag for\n+\texception table labels.\n+\t(expand_start_all_catch): Ditto.\n+\t(expand_leftover_cleanups): Ditto.\n+\t(expand_end_catch_block): Ditto.\n+\t* except.c (make_first_label): new function.\n+\t(expand_start_all_catch): add a call to make_first_label() before\n+\tusing a label as a jump destination.\n+\t(expand_end_all_catch): Ditto.\n+\t(expand_leftover_cleanups): Ditto.\n+\t(expand_end_catch_block): Ditto.\n+\t(expand_builtin_throw): Ditto.\n+\t(expand_throw): Ditto.\n+\t* except.c: Add ARM processor support for exception handling.\n+\n+Thu Jan 12 12:17:24 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t(complete_array_type): Copy code from C frontend.\n+\n+\t* lex.c (real_yylex): Don't multiply the length of a wide string\n+\tliteral by WCHAR_BYTES.\n+\n+\t* decl.c (pushdecl): Check for redeclaration of wchar_t here.\n+\t(duplicate_decls): Instead of here.\n+\t(define_label): Complain about a label named wchar_t.\n+\t(grokdeclarator): Complain about declarations of\n+\toperator-function-ids as non-functions.\n+\n+\t* typeck.c (unary_complex_lvalue): Also wrap prefix -- and ++ in\n+\tCOMPOUND_EXPRs.\n+\t(build_unary_op): Wrap unary plus in a NON_LVALUE_EXPR.\n+\n+\t* lex.c (real_yylex): Don't skip whitespace when reading the next\n+\tcharacter after ->.\n+\n+Wed Jan 11 16:32:49 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c: Allow cc1plus to be built with native compiler on rs6000.\n+\t(expand_start_all_catch): Add assemble_external calls for various\n+\troutines we call.\n+\t(expand_leftover_cleanups): Ditto.\n+\t(expand_start_catch_block): Ditto.\n+\t(do_unwind): Ditto.\n+\t(expand_builtin_throw): Ditto.\n+\n+Wed Jan 11 01:05:42 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (pushtag): Only look for a previous decl in the current\n+\tbinding level.  Use explicit global scope in DECL_NESTED_TYPENAME.\n+\n+\t* gxx.gperf: Add __signature__ and __sigof__ keywords.\n+\n+\t* decl2.c (lang_decode_option): -ansi does not set flag_no_asm.  It\n+\tdoes set flag_no_gnu_keywords and flag_operator_names.\n+\n+\t* lex.c (init_lex): 'overload' is not a keyword unless -traditional.\n+\tUnset extension keywords if -fno-gnu-keywords.\n+\tAllow operator names ('bitand') if -foperator-names.\n+\tNever unset 'asm'; -fno-asm only affects 'typeof'.\n+\n+\t* decl.c (lookup_name_real): The got_object special lookup only\n+\tapplies to types.\n+\n+Tue Jan 10 18:07:51 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* spew.c (yylex): Also use DECL_NESTED_TYPENAME if got_object is set.\n+\n+\t* parse.y (primary): Unset got_object after all rules that use the\n+        'object' nonterminal.\n+\t(object): Set got_object.\n+\n+\t* lex.h: Declare got_object.\n+\n+\t* decl.c (lookup_name_real): Also lookup names in the context of an\n+\tobject specified.\n+\n+Tue Jan 10 14:30:30 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (get_member_function_from_ptrfunc): Use ptrdiff_type_node\n+\tfor things that have to be added to pointers, not size_type.  Cures\n+\tproblems with pointer to members on Alphas.\n+\t(build_binary_op_nodefault): Ditto.\n+\t(get_delta_difference_: Ditto.\n+\t(build_ptrmemfunc): Ditto.\n+\n+Tue Jan 10 01:49:25 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (pushtag): Stick the new decl in TYPE_NAME before pushing\n+\tit.\n+\n+\t* typeck.c (build_component_ref): Don't build up a COMPONENT_REF\n+\twhen dealing with overloaded member functions; just act like\n+\tbuild_offset_ref.\n+\t(commonparms): Remove misleading comment.\n+\n+\t* decl.c (duplicate_decls): Complain about repeated default\n+\targuments here.\n+\t(redeclaration_error_message): Instead of here.\n+\t(pushdecl): Complain about missing default arguments here.\n+\t(grokparms): Instead of here.\n+\t(lookup_name_current_level): Also match on DECL_ASSEMBLER_NAME.\n+\t(grok_reference_init): Do not complain about missing initializer if\n+\tdeclared 'extern'.\n+\n+\t* search.c (lookup_field): Don't return a TYPE_DECL if there is a\n+\tfunction alternative and want_type is not set.\n+\n+Mon Jan  9 18:16:23 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (pushtag): Don't set TYPE_NAME to an identifier.  Do push\n+\tthe decl when the type has no TYPE_NAME.\n+\t(lookup_nested_type): Don't assume that type has TYPE_NAME set.\n+\t(lookup_name_real): Call lookup_field with want_type =\n+\tprefer_type.\n+\n+\t* search.c (lookup_field): Handle want_type properly in the presence\n+\tof fields with the same name.\n+\n+\t* decl.c (set_nested_typename): Set nested name for file-scope types\n+\tto include leading ::.\n+\t(pushdecl): Set the nested typename if the decl doesn't have one,\n+\trather than if the type's canonical decl doesn't have one.\n+\n+Mon Jan  9 16:48:16 1995  Steve Chamberlain  (sac@jonny.cygnus.com)\n+\n+\t* typeck.c (pointer_int_sum):  Use offset size when calculating\n+\tindex expression.\n+\n+Mon Jan  9 03:44:33 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (convert_for_assignment): Complain about contravariance\n+\tviolation here.\n+\t(comp_target_types): Instead of here.\n+\t(build_unary_op): resolve_offset_ref before checking for a valid\n+\ttype.\n+\n+\t* spew.c (yylex): Decrement looking_for_typename after we see a\n+\t_DEFN.\n+\n+\t* decl.c (pushdecl): Don't install an artificial TYPE_DECL in\n+        IDENTIFIER_LOCAL_VALUE if we already have a decl with that name.\n+\n+\t* typeck.c (convert_for_assignment): Converting pointers to bool\n+\tdoes not need a cast.\n+\n+Sun Jan  8 18:16:45 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* class.c (instantiate_type): Initialize nsubsts parm.\n+\n+\t* pt.c (do_function_instantiation): Ditto.\n+\n+Sat Jan  7 14:37:05 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* pt.c (tsubst): Use TREE_STATIC instead of DECL_INLINE &&\n+\tDECL_SAVED_INSNS to determine whether or not we've seen a definition\n+\tof this function.\n+\t(instantiate_template): Ditto.\n+\n+\t* call.c (convert_harshness): Allow const reference binding when\n+\tcalled from the overloading code, but not when called from\n+\tcan_convert (since it isn't a conversion).\n+\t(convert_harshness): Put back some disabled code.\n+\n+Fri Jan  6 14:10:57 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* call.c (convert_harshness): There is no implicit conversion from\n+\tvoid* to other pointer types (unless the parameter is (void*)0).\n+\t(convert_harshness): Non-lvalues do not convert to reference types.\n+\n+\t* class.c (finish_struct_methods): Still set\n+        TYPE_HAS_{INT,REAL}_CONVERSION.\n+\n+\t* call.c (can_convert): Don't use aggregate initialization.\n+\n+\t* cp-tree.h: Declare lookup_conversions.\n+\n+Thu Jan  5 21:08:00 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* parse.y (simple_stmt): Fix duplicate case value error messages to\n+\tbe more readable.\n+\n+Wed Jan  4 16:44:19 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* cvt.c (build_type_conversion): Total rewrite to use\n+\tconvert_harshness instead of reproducing conversion logic here.  Now\n+\tmuch shorter.\n+\n+\t* call.c (convert_harshness): Support conversions to bool.\n+\t(can_convert): Checks whether a conversion is less harsh\n+\tthan USER_CODE, for build_type_conversion.\n+\n+\t* search.c (add_conversions): Function for passing to dfs_walk which\n+\tadds all the type conversion operators in the current type to a list.\n+\t(lookup_conversions): Calls dfs_walk with add_conversions and return\n+\tthe list.\n+\t(dfs_walk): Don't require a qfn.\n+\n+\t* cp-tree.h: Lose CLASSTYPE_CONVERSIONS hackery.\n+\t(CLASSTYPE_FIRST_CONVERSION): Points to elt 1 of CLASSTYPE_METHOD_VEC.\n+\n+\t* class.c (finish_struct_bits): Lose CLASSTYPE_CONVERSIONS hackery.\n+\t(grow_method): A separate function for building onto the growing\n+\tmethod vector.\n+\t(finish_struct_methods): Use it.  Put all type conversion operators\n+\tright after the constructors.  Perhaps we should sort the methods\n+        alphabetically?\n+\n+Mon Jan  2 14:42:58 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* call.c (build_method_call): Lose another misleading shortcut.\n+\n+Fri Dec 30 17:57:30 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* gc.c (build_bltn_desc): Handle bool as a built-in type.\n+\n+Fri Dec 30 14:20:21 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* tree.c (layout_vbasetypes): Ensure that we don't loose alignment\n+\ton the complete type because of small virtual bases.\n \n Fri Dec 30 12:22:29 1994  Mike Stump  <mrs@cygnus.com>\n "}, {"sha": "7a71f400f86accbe33dbccf735af519da6f9b7bb", "filename": "gcc/cp/call.c", "status": "modified", "additions": 55, "deletions": 116, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "patch": "@@ -47,6 +47,7 @@ extern tree unary_complex_lvalue ();\n static struct harshness_code convert_harshness ();\n \n #define EVIL_RETURN(ARG)\t((ARG).code = EVIL_CODE, (ARG))\n+#define STD_RETURN(ARG)\t\t((ARG).code = STD_CODE, (ARG))\n #define QUAL_RETURN(ARG)\t((ARG).code = QUAL_CODE, (ARG))\n #define TRIVIAL_RETURN(ARG)\t((ARG).code = TRIVIAL_CODE, (ARG))\n #define ZERO_RETURN(ARG)\t((ARG).code = 0, (ARG))\n@@ -117,6 +118,7 @@ convert_harshness (type, parmtype, parm)\n   struct harshness_code h;\n   register enum tree_code codel;\n   register enum tree_code coder;\n+  int lvalue;\n \n   h.code = 0;\n   h.distance = 0;\n@@ -136,7 +138,12 @@ convert_harshness (type, parmtype, parm)\n       if (parm)\n \tparm = convert_from_reference (parm);\n       parmtype = TREE_TYPE (parmtype);\n+      lvalue = 1;\n     }\n+  else if (parm)\n+    lvalue = lvalue_p (parm);\n+  else\n+    lvalue = 0;\n \n   codel = TREE_CODE (type);\n   coder = TREE_CODE (parmtype);\n@@ -300,6 +307,14 @@ convert_harshness (type, parmtype, parm)\n   if (coder == VOID_TYPE)\n     return EVIL_RETURN (h);\n \n+  if (codel == BOOLEAN_TYPE)\n+    {\n+      if (INTEGRAL_CODE_P (coder) || coder == REAL_TYPE\n+\t  || coder == POINTER_TYPE || coder == OFFSET_TYPE)\n+\treturn STD_RETURN (h);\n+      return EVIL_RETURN (h);\n+    }\n+\n   if (INTEGRAL_CODE_P (codel))\n     {\n       /* Control equivalence of ints an enums.  */\n@@ -375,11 +390,10 @@ convert_harshness (type, parmtype, parm)\n       register tree ttr = TYPE_MAIN_VARIANT (TREE_TYPE (parmtype));\n       int penalty = 4 * (ttl != ttr);\n \n-      /* Anything converts to void *.  void * converts to anything.\n-\t Since these may be `const void *' (etc.) use VOID_TYPE\n-\t instead of void_type_node.  Otherwise, the targets must be the same,\n-\t except that we do allow (at some cost) conversion between signed and\n-\t unsigned pointer types.  */\n+      /* Anything converts to void *.  Since this may be `const void *'\n+\t (etc.) use VOID_TYPE instead of void_type_node.  Otherwise, the\n+\t targets must be the same, except that we do allow (at some cost)\n+\t conversion between signed and unsigned pointer types.  */\n \n       if ((TREE_CODE (ttl) == METHOD_TYPE\n \t   || TREE_CODE (ttl) == FUNCTION_TYPE)\n@@ -396,15 +410,16 @@ convert_harshness (type, parmtype, parm)\n \t}\n \n #if 1\n-      if (TREE_CODE (ttl) != VOID_TYPE && TREE_CODE (ttr) != VOID_TYPE)\n+      if (TREE_CODE (ttl) != VOID_TYPE\n+\t  && (TREE_CODE (ttr) != VOID_TYPE || !parm || !integer_zerop (parm)))\n \t{\n \t  if (TREE_UNSIGNED (ttl) != TREE_UNSIGNED (ttr))\n \t    {\n \t      ttl = unsigned_type (ttl);\n \t      ttr = unsigned_type (ttr);\n \t      penalty = 10;\n \t    }\n-\t  if (! comp_target_types (ttl, ttr, 0))\n+\t  if (comp_target_types (ttl, ttr, 0) <= 0)\n \t    return EVIL_RETURN (h);\n \t}\n #else\n@@ -414,7 +429,7 @@ convert_harshness (type, parmtype, parm)\n \t\t&& (ttl = unsigned_type (ttl),\n \t\t    ttr = unsigned_type (ttr),\n \t\t    penalty = 10, 0))\n-\t    || (comp_target_types (ttl, ttr, 0))))\n+\t    || (comp_target_types (ttl, ttr, 0) > 0)))\n \treturn EVIL_RETURN (h);\n #endif\n \n@@ -503,14 +518,21 @@ convert_harshness (type, parmtype, parm)\n \n       ttl = TREE_TYPE (type);\n \n-      /* When passing a non-const argument into a const reference (or vice\n-\t versa), dig it a little, so a non-const reference is preferred\n-\t over this one. (mrs) */\n-      if (TYPE_READONLY (ttl) != constp\n-\t  || TYPE_VOLATILE (ttl) != volatilep)\n-\tpenalty = 2;\n-      else\n-\tpenalty = 0;\n+      /* Only allow const reference binding if we were given a parm to deal\n+         with, since it isn't really a conversion.  This is a hack to\n+         prevent build_type_conversion from finding this conversion, but\n+         still allow overloading to find it.  */\n+      if (! lvalue && ! (parm && TYPE_READONLY (ttl)))\n+\treturn EVIL_RETURN (h);\n+\n+      if (TYPE_READONLY (ttl) < constp\n+\t  || TYPE_VOLATILE (ttl) < volatilep)\n+\treturn EVIL_RETURN (h);\n+\n+      /* When passing a non-const argument into a const reference, dig it a\n+\t little, so a non-const reference is preferred over this one.  */\n+      penalty = ((TYPE_READONLY (ttl) > constp)\n+\t\t + (TYPE_VOLATILE (ttl) > volatilep));\n \n       ttl = TYPE_MAIN_VARIANT (ttl);\n \n@@ -520,98 +542,17 @@ convert_harshness (type, parmtype, parm)\n \t  form = TREE_CODE (intype);\n \t}\n \n-      if (ttl == intype && penalty == 0)\n-\treturn ZERO_RETURN (h);\n-      else\n-\tpenalty = 2;\n-\n       ttr = intype;\n \n-      /* If the initializer is not an lvalue, then it does not\n-\t matter if we make life easier for the programmer\n-\t by creating a temporary variable with which to\n-\t hold the result.  */\n-      if (parm && (INTEGRAL_CODE_P (coder)\n-\t\t   || coder == REAL_TYPE)\n-\t  && ! lvalue_p (parm))\n-\t{\n-\t  h = convert_harshness (ttl, ttr, NULL_TREE);\n-\t  if (penalty > 2 || h.code != 0)\n-\t    h.code |= STD_CODE;\n-\t  else\n-\t    h.code |= TRIVIAL_CODE;\n-\t  h.distance = 0;\n-\t  return h;\n-\t}\n-\n-      if (TREE_UNSIGNED (ttl) ^ TREE_UNSIGNED (intype))\n-\t{\n-\t  ttl = unsigned_type (ttl);\n-\t  ttr = intype = unsigned_type (intype);\n-\t  penalty += 2;\n-\t}\n-\n-      if (ttl == ttr)\n-\t{\n-\t  if (penalty > 2)\n-\t    {\n-\t      h.code = STD_CODE;\n-\t      h.distance = 0;\n-\t    }\n-\t  else\n-\t    {\n-\t      h.code = TRIVIAL_CODE;\n-\t      /* We set this here so that build_overload_call_real will be\n-\t\t able to see the penalty we found, rather than just looking\n-\t\t at a TRIVIAL_CODE with no other information.  */\n-\t      h.int_penalty = penalty;\n-\t    }\n-\t  return h;\n-\t}\n+      /* Maybe handle conversion to base here?  */\n \n-      /* Pointers to voids always convert for pointers.  But\n-\t make them less natural than more specific matches.  */\n-      if (TREE_CODE (ttl) == POINTER_TYPE && TREE_CODE (ttr) == POINTER_TYPE)\n+      h = convert_harshness (ttl, ttr, NULL_TREE);\n+      if (penalty && h.code == 0)\n \t{\n-\t  if (TREE_TYPE (ttl) == void_type_node\n-\t      || TREE_TYPE (ttr) == void_type_node)\n-\t    {\n-\t      h.code = STD_CODE;\n-\t      h.distance = 0;\n-\t      return h;\n-\t    }\n-\t}\n-\n-      /* Here it does matter.  If this conversion is from derived to base,\n-\t allow it.  Otherwise, types must be compatible in the strong sense.  */\n-      if (TREE_CODE (ttl) == RECORD_TYPE && TREE_CODE (ttr) == RECORD_TYPE)\n-\t{\n-\t  int b_or_d = get_base_distance (ttl, ttr, 0, 0);\n-\t  if (b_or_d < 0)\n-\t    {\n-\t      b_or_d = get_base_distance (ttr, ttl, 0, 0);\n-\t      if (b_or_d < 0)\n-\t\treturn EVIL_RETURN (h);\n-\t      h.distance = -b_or_d;\n-\t    }\n-\t  /* Say that this conversion is relatively painless.\n-\t     If it turns out that there is a user-defined X(X&)\n-\t     constructor, then that will be invoked, but that's\n-\t     preferable to dealing with other user-defined conversions\n-\t     that may produce surprising results.  */\n-\t  else\n-\t    h.distance = b_or_d;\n-\t  h.code = STD_CODE;\n-\t  return h;\n-\t}\n-\n-      if (comp_target_types (ttl, intype, 1))\n-\t{\n-\t  if (penalty)\n-\t    h.code = STD_CODE;\n-\t  h.distance = 0;\n-\t  return h;\n+\t  h.code = QUAL_CODE;\n+\t  h.int_penalty = penalty;\n \t}\n+      return h;\n     }\n   if (codel == RECORD_TYPE && coder == RECORD_TYPE)\n     {\n@@ -631,6 +572,15 @@ convert_harshness (type, parmtype, parm)\n   return EVIL_RETURN (h);\n }\n \n+int\n+can_convert (to, from)\n+     tree to, from;\n+{\n+  struct harshness_code h;\n+  h = convert_harshness (to, from, NULL_TREE);\n+  return h.code < USER_CODE;\n+}\n+\n #ifdef DEBUG_MATCHING\n static char *\n print_harshness (h)\n@@ -2134,6 +2084,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t    basetype_path = TREE_VALUE (basetype_path);\n \t  basetype = BINFO_TYPE (basetype_path);\n \n+#if 0\n \t  /* Cast the instance variable if necessary.  */\n \t  if (basetype != TYPE_MAIN_VARIANT\n \t      (TREE_TYPE (TREE_TYPE (TREE_VALUE (parms)))))\n@@ -2152,6 +2103,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t     the access-control rewrite will make this change more cleanly.  */\n \t  if (TREE_VALUE (parms) == error_mark_node)\n \t    return error_mark_node;\n+#endif\n \n \t  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (function)))\n \t    function = DECL_CHAIN (function);\n@@ -2208,19 +2160,6 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t\t  && (cp->h.code & USER_CODE))\n \t\t\tcontinue;\n \n-\t\t      /* If we used default parameters, we must\n-\t\t\t check to see whether anyone else might\n-\t\t\t use them also, and report a possible\n-\t\t\t ambiguity.  */\n-\t\t      if (! TYPE_USES_MULTIPLE_INHERITANCE (save_basetype)\n-\t\t\t  && cp->harshness[len].distance == 0\n-\t\t\t  && cp->h.code < best)\n-\t\t\t{\n-\t\t\t  if (! DECL_STATIC_FUNCTION_P (function))\n-\t\t\t    TREE_VALUE (parms) = cp->arg;\n-\t\t\t  if (best == 1)\n-\t\t\t    goto found_and_maybe_warn;\n-\t\t\t}\n \t\t      cp++;\n \t\t    }\n \t\t}"}, {"sha": "807640677a10e0ce2fd47ad91e370f9d7793b37c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 122, "deletions": 139, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "patch": "@@ -1687,63 +1687,6 @@ finish_struct_bits (t, max_has_virtual)\n \t}\n     }\n \n-  /* Need to test METHOD_VEC here in case all methods\n-     (conversions and otherwise) are inherited.  */\n-  if (TYPE_HAS_CONVERSION (t) && method_vec != NULL_TREE)\n-    {\n-      tree first_conversions[last_conversion_type];\n-      tree last_conversions[last_conversion_type];\n-      enum conversion_type conv_index;\n-      tree *tmp;\n-      int i;\n-\n-      bzero ((char *) first_conversions, sizeof (first_conversions));\n-      bzero ((char *) last_conversions, sizeof (last_conversions));\n-      for (tmp = &TREE_VEC_ELT (method_vec, 1);\n-\t   tmp != TREE_VEC_END (method_vec); tmp += 1)\n-\t{\n-\t  /* ??? This should compare DECL_NAME (*tmp) == ansi_opname[TYPE_EXPR].  */\n-\t  if (IDENTIFIER_TYPENAME_P (DECL_ASSEMBLER_NAME (*tmp)))\n-\t    {\n-\t      tree fntype = TREE_TYPE (*tmp);\n-\t      tree return_type = TREE_TYPE (fntype);\n-\t      my_friendly_assert (TREE_CODE (fntype) == METHOD_TYPE, 171);\n-\n-\t      if (typecode_p (return_type, POINTER_TYPE))\n-\t\t{\n-\t\t  if (TYPE_READONLY (TREE_TYPE (return_type)))\n-\t\t    conv_index = constptr_conv;\n-\t\t  else\n-\t\t    conv_index = ptr_conv;\n-\t\t}\n-\t      else if (typecode_p (return_type, INTEGER_TYPE)\n-\t\t       || typecode_p (return_type, BOOLEAN_TYPE)\n-\t\t       || typecode_p (return_type, ENUMERAL_TYPE))\n-\t\t{\n-\t\t  TYPE_HAS_INT_CONVERSION (t) = 1;\n-\t\t  conv_index = int_conv;\n-\t\t}\n-\t      else if (typecode_p (return_type, REAL_TYPE))\n-\t\t{\n-\t\t  TYPE_HAS_REAL_CONVERSION (t) = 1;\n-\t\t  conv_index = real_conv;\n-\t\t}\n-\t      else\n-\t\tcontinue;\n-\n-\t      if (first_conversions[(int) conv_index] == NULL_TREE)\n-\t\tfirst_conversions[(int) conv_index] = *tmp;\n-\t      last_conversions[(int) conv_index] = *tmp;\n-\t    }\n-\t}\n-\n-      for (i = 0; i < (int) last_conversion_type; i++)\n-\tif (first_conversions[i] != last_conversions[i])\n-\t  CLASSTYPE_CONVERSION (t, i) = error_mark_node;\n-\telse\n-\t  CLASSTYPE_CONVERSION (t, i) = first_conversions[i];\n-    }\n-\n   /* If this type has constructors, force its mode to be BLKmode,\n      and force its TREE_ADDRESSABLE bit to be nonzero.  */\n   if (TYPE_NEEDS_CONSTRUCTING (t) || TYPE_NEEDS_DESTRUCTOR (t))\n@@ -1761,6 +1704,57 @@ finish_struct_bits (t, max_has_virtual)\n     }\n }\n \n+/* Add FN to the method_vec growing on the class_obstack.  Used by\n+   finish_struct_methods.  */\n+static void\n+grow_method (fn)\n+     tree fn;\n+{\n+  tree method_vec = (tree)obstack_base (&class_obstack);\n+  tree *testp = &TREE_VEC_ELT (method_vec, 0);\n+  if (*testp == NULL_TREE)\n+    testp++;\n+  while (((HOST_WIDE_INT) testp\n+\t  < (HOST_WIDE_INT) obstack_next_free (&class_obstack))\n+\t && DECL_NAME (*testp) != DECL_NAME (fn))\n+    testp++;\n+  if ((HOST_WIDE_INT) testp\n+      < (HOST_WIDE_INT) obstack_next_free (&class_obstack))\n+    {\n+      tree x, prev_x;\n+\n+      for (x = *testp; x; x = DECL_CHAIN (x))\n+\t{\n+\t  if (DECL_NAME (fn) == ansi_opname[(int) DELETE_EXPR]\n+\t      || DECL_NAME (fn) == ansi_opname[(int) VEC_DELETE_EXPR])\n+\t    {\n+\t      /* ANSI C++ June 5 1992 WP 12.5.5.1 */\n+\t      cp_error_at (\"`%D' overloaded\", fn);\n+\t      cp_error_at (\"previous declaration as `%D' here\", x);\n+\t    }\n+\t  if (DECL_ASSEMBLER_NAME (fn)==DECL_ASSEMBLER_NAME (x))\n+\t    {\n+\t      /* We complain about multiple destructors on sight,\n+\t\t so we do not repeat the warning here.  Friend-friend\n+\t\t ambiguities are warned about outside this loop.  */\n+\t      if (!DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fn)))\n+\t\tcp_error_at (\"ambiguous method `%#D' in structure\", fn);\n+\t      break;\n+\t    }\n+\t  prev_x = x;\n+\t}\n+      if (x == 0)\n+\t{\n+\t  if (*testp)\n+\t    DECL_CHAIN (prev_x) = fn;\n+\t  else\n+\t    *testp = fn;\n+\t}\n+    }\n+  else\n+    obstack_ptr_grow (&class_obstack, fn);\n+}\n+\n /* Warn about duplicate methods in fn_fields.  Also compact method\n    lists so that lookup can be made faster.\n \n@@ -1769,10 +1763,12 @@ finish_struct_bits (t, max_has_virtual)\n \n    Data Structure: List of method lists.  The outer list is a\n    TREE_LIST, whose TREE_PURPOSE field is the field name and the\n-   TREE_VALUE is the TREE_CHAIN of the FUNCTION_DECLs.  Friends are\n-   chained in the same way as member functions, but they live in the\n-   TREE_TYPE field of the outer list.  That allows them to be quickly\n-   deleted, and requires no extra storage.\n+   TREE_VALUE is the DECL_CHAIN of the FUNCTION_DECLs.  TREE_CHAIN\n+   links the entire list of methods for TYPE_METHODS.  Friends are\n+   chained in the same way as member functions (? TREE_CHAIN or\n+   DECL_CHAIN), but they live in the TREE_TYPE field of the outer\n+   list.  That allows them to be quickly deleted, and requires no\n+   extra storage.\n \n    If there are any constructors/destructors, they are moved to the\n    front of the list.  This makes pushclass more efficient.\n@@ -1789,6 +1785,8 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n      int nonprivate_method;\n {\n   tree method_vec;\n+  tree save_fn_fields = tree_cons (NULL_TREE, NULL_TREE, fn_fields);\n+  tree lastp;\n   tree name = constructor_name (t);\n   int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n \n@@ -1802,17 +1800,15 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n   obstack_free (&class_obstack, method_vec);\n   obstack_blank (&class_obstack, sizeof (struct tree_vec));\n \n-  while (fn_fields)\n+  /* First fill in entry 0 with the constructors, and the next few with\n+     type conversion operators (if any).  */\n+\n+  for (lastp = save_fn_fields; fn_fields; fn_fields = TREE_CHAIN (lastp))\n     {\n-      /* NEXT Pointer, TEST Pointer, and BASE Pointer.  */\n-      tree nextp, *testp;\n       tree fn_name = DECL_NAME (fn_fields);\n       if (fn_name == NULL_TREE)\n \tfn_name = name;\n \n-      nextp = TREE_CHAIN (fn_fields);\n-      TREE_CHAIN (fn_fields) = NULL_TREE;\n-\n       /* Clear out this flag.\n \n \t @@ Doug may figure out how to break\n@@ -1840,8 +1836,45 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n  \t\t    TYPE_HAS_NONPUBLIC_CTOR (t) = 2;\n  \t\t}\n  \t    }\n+\t  /* Constructors are handled easily in search routines.  */\n+\t  DECL_CHAIN (fn_fields) = TREE_VEC_ELT (method_vec, 0);\n+\t  TREE_VEC_ELT (method_vec, 0) = fn_fields;\n  \t}\n-      else if (fn_name == ansi_opname[(int) MODIFY_EXPR])\n+      else if (IDENTIFIER_TYPENAME_P (fn_name))\n+\t{\n+\t  tree return_type = TREE_TYPE (TREE_TYPE (fn_fields));\n+\n+\t  if (typecode_p (return_type, INTEGER_TYPE)\n+\t      || typecode_p (return_type, BOOLEAN_TYPE)\n+\t      || typecode_p (return_type, ENUMERAL_TYPE))\n+\t    TYPE_HAS_INT_CONVERSION (t) = 1;\n+\t  else if (typecode_p (return_type, REAL_TYPE))\n+\t    TYPE_HAS_REAL_CONVERSION (t) = 1;\n+\n+\t  grow_method (fn_fields);\n+\t}\n+      else\n+\t{\n+\t  lastp = fn_fields;\n+\t  continue;\n+\t}\n+\n+      TREE_CHAIN (lastp) = TREE_CHAIN (fn_fields);\n+      TREE_CHAIN (fn_fields) = NULL_TREE;\n+    }\n+\n+  fn_fields = TREE_CHAIN (save_fn_fields);\n+  while (fn_fields)\n+    {\n+      tree nextp;\n+      tree fn_name = DECL_NAME (fn_fields);\n+      if (fn_name == NULL_TREE)\n+\tfn_name = name;\n+\n+      nextp = TREE_CHAIN (fn_fields);\n+      TREE_CHAIN (fn_fields) = NULL_TREE;\n+\n+      if (fn_name == ansi_opname[(int) MODIFY_EXPR])\n \t{\n \t  tree parmtype = TREE_VALUE (FUNCTION_ARG_CHAIN (fn_fields));\n \n@@ -1854,65 +1887,12 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \t    }\n \t}\n \n-      /* Constructors are handled easily in search routines.  */\n-      if (fn_name == name)\n-\t{\n-\t  DECL_CHAIN (fn_fields) = TREE_VEC_ELT (method_vec, 0);\n-\t  TREE_VEC_ELT (method_vec, 0) = fn_fields;\n-\t}\n-      else\n-\t{\n-\t  testp = &TREE_VEC_ELT (method_vec, 0);\n-\t  if (*testp == NULL_TREE)\n-\t    testp++;\n-\t  while (((HOST_WIDE_INT) testp\n-\t\t  < (HOST_WIDE_INT) obstack_next_free (&class_obstack))\n-\t\t && DECL_NAME (*testp) != fn_name)\n-\t    testp++;\n-\t  if ((HOST_WIDE_INT) testp\n-\t      < (HOST_WIDE_INT) obstack_next_free (&class_obstack))\n-\t    {\n-\t      tree x, prev_x;\n-\n-\t      for (x = *testp; x; x = DECL_CHAIN (x))\n-\t\t{\n-\t\t  if (DECL_NAME (fn_fields) == ansi_opname[(int) DELETE_EXPR]\n-\t\t      || DECL_NAME (fn_fields)\n-\t\t         == ansi_opname[(int) VEC_DELETE_EXPR])\n-\t\t    {\n-\t\t      /* ANSI C++ June 5 1992 WP 12.5.5.1 */\n-\t\t      cp_error_at (\"`%D' overloaded\", fn_fields);\n-\t\t      cp_error_at (\"previous declaration as `%D' here\", x);\n-\t\t    }\n-\t\t  if (DECL_ASSEMBLER_NAME (fn_fields)==DECL_ASSEMBLER_NAME (x))\n-\t\t    {\n-\t\t      /* We complain about multiple destructors on sight,\n-\t\t\t so we do not repeat the warning here.  Friend-friend\n-\t\t\t ambiguities are warned about outside this loop.  */\n-\t\t      if (!DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fn_fields)))\n-\t\t\tcp_error_at (\"ambiguous method `%#D' in structure\",\n-\t\t\t\t     fn_fields);\n-\t\t      break;\n-\t\t    }\n-\t\t  prev_x = x;\n-\t\t}\n-\t      if (x == 0)\n-\t\t{\n-\t\t  if (*testp)\n-\t\t    DECL_CHAIN (prev_x) = fn_fields;\n-\t\t  else\n-\t\t    *testp = fn_fields;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      obstack_ptr_grow (&class_obstack, fn_fields);\n-\t      method_vec = (tree)obstack_base (&class_obstack);\n-\t    }\n-\t}\n+      grow_method (fn_fields);\n       fn_fields = nextp;\n     }\n \n+  /* Update in case method_vec has moved.  */\n+  method_vec = (tree)obstack_base (&class_obstack);\n   TREE_VEC_LENGTH (method_vec) = (tree *)obstack_next_free (&class_obstack)\n     - (&TREE_VEC_ELT (method_vec, 0));\n   obstack_finish (&class_obstack);\n@@ -4737,7 +4717,7 @@ instantiate_type (lhstype, rhs, complain)\n \t/* First look for an exact match  */\n \n \twhile (field && TREE_TYPE (field) != lhstype)\n-\t  field = TREE_CHAIN (field);\n+\t  field = DECL_CHAIN (field);\n \tif (field)\n \t  {\n \t    TREE_OPERAND (rhs, 1) = field;\n@@ -4747,13 +4727,13 @@ instantiate_type (lhstype, rhs, complain)\n \t/* No exact match found, look for a compatible function.  */\n \tfield = TREE_OPERAND (rhs, 1);\n \twhile (field && ! comptypes (lhstype, TREE_TYPE (field), 0))\n-\t  field = TREE_CHAIN (field);\n+\t  field = DECL_CHAIN (field);\n \tif (field)\n \t  {\n \t    TREE_OPERAND (rhs, 1) = field;\n-\t    field = TREE_CHAIN (field);\n+\t    field = DECL_CHAIN (field);\n \t    while (field && ! comptypes (lhstype, TREE_TYPE (field), 0))\n-\t      field = TREE_CHAIN (field);\n+\t      field = DECL_CHAIN (field);\n \t    if (field)\n \t      {\n \t\tif (complain)\n@@ -4821,7 +4801,7 @@ instantiate_type (lhstype, rhs, complain)\n \t\t  {\n \t\t    int n = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (elem));\n \t\t    tree *t = (tree *) alloca (sizeof (tree) * n);\n-\t\t    int i, d;\n+\t\t    int i, d = 0;\n \t\t    i = type_unification (DECL_TEMPLATE_PARMS (elem), t,\n \t\t\t\t\t  TYPE_ARG_TYPES (TREE_TYPE (elem)),\n \t\t\t\t\t  TYPE_ARG_TYPES (lhstype), &d, 0);\n@@ -4845,14 +4825,15 @@ instantiate_type (lhstype, rhs, complain)\n \n \t    /* No match found, look for a compatible function.  */\n \t    elem = get_first_fn (rhs);\n-\t    while (elem && ! comp_target_types (lhstype, TREE_TYPE (elem), 1))\n+\t    while (elem && comp_target_types (lhstype,\n+\t\t\t\t\t      TREE_TYPE (elem), 1) <= 0)\n \t      elem = DECL_CHAIN (elem);\n \t    if (elem)\n \t      {\n \t\ttree save_elem = elem;\n \t\telem = DECL_CHAIN (elem);\n-\t\twhile (elem && ! comp_target_types (lhstype, TREE_TYPE (elem),\n-\t\t\t\t\t\t    0))\n+\t\twhile (elem && comp_target_types (lhstype,\n+\t\t\t\t\t\t  TREE_TYPE (elem), 0) <= 0)\n \t\t  elem = DECL_CHAIN (elem);\n \t\tif (elem)\n \t\t  {\n@@ -4900,22 +4881,24 @@ instantiate_type (lhstype, rhs, complain)\n \t      if (comptypes (lhstype, TREE_TYPE (elem), 1))\n \t\treturn elem;\n \t      else\n-\t\telem = TREE_CHAIN (elem);\n+\t\telem = DECL_CHAIN (elem);\n \t  }\n \n \t/* No exact match found, look for a compatible method.  */\n \tfor (baselink = rhs; baselink;\n \t     baselink = next_baselink (baselink))\n \t  {\n \t    elem = TREE_VALUE (baselink);\n-\t    while (elem && ! comp_target_types (lhstype, TREE_TYPE (elem), 1))\n-\t      elem = TREE_CHAIN (elem);\n+\t    while (elem && comp_target_types (lhstype,\n+\t\t\t\t\t      TREE_TYPE (elem), 1) <= 0)\n+\t      elem = DECL_CHAIN (elem);\n \t    if (elem)\n \t      {\n \t\ttree save_elem = elem;\n-\t\telem = TREE_CHAIN (elem);\n-\t\twhile (elem && ! comp_target_types (lhstype, TREE_TYPE (elem), 0))\n-\t\t  elem = TREE_CHAIN (elem);\n+\t\telem = DECL_CHAIN (elem);\n+\t\twhile (elem && comp_target_types (lhstype,\n+\t\t\t\t\t\t  TREE_TYPE (elem), 0) <= 0)\n+\t\t  elem = DECL_CHAIN (elem);\n \t\tif (elem)\n \t\t  {\n \t\t    if (complain)\n@@ -4940,7 +4923,7 @@ instantiate_type (lhstype, rhs, complain)\n #endif\n \t  }\n \tif (complain)\n-\t  error (\"no static member functions named `%s'\",\n+\t  error (\"no compatible member functions named `%s'\",\n \t\t IDENTIFIER_POINTER (name));\n \treturn error_mark_node;\n       }"}, {"sha": "4f92ca3cf4a784fbae40154c6076d47060d12199", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "patch": "@@ -114,6 +114,14 @@ extern int pedantic;\n \n /* In a RECORD_TYPE or UNION_TYPE, nonzero if any component is read-only.  */\n #define C_TYPE_FIELDS_READONLY(type) TYPE_LANG_FLAG_0 (type)\n+\n+/* Record in each node resulting from a binary operator\n+   what operator was specified for it.  */\n+#define C_EXP_ORIGINAL_CODE(exp) ((enum tree_code) TREE_COMPLEXITY (exp))\n+\n+/* Store a value in that field.  */\n+#define C_SET_EXP_ORIGINAL_CODE(exp, code) \\\n+  (TREE_COMPLEXITY (exp) = (int)(code))\n \f\n /* If non-zero, a VAR_DECL whose cleanup will cause a throw to the\n    next exception handler.  */\n@@ -271,7 +279,8 @@ extern int interface_only, interface_unknown;\n \n extern int flag_elide_constructors;\n \n-/* Nonzero means handle things in ANSI, instead of GNU fashion.  */\n+/* Nonzero means enable obscure ANSI features and disable GNU extensions\n+   that might cause ANSI-compliant code to be miscompiled.  */\n \n extern int flag_ansi;\n \n@@ -369,9 +378,6 @@ enum languages { lang_c, lang_cplusplus };\n #define ACCESSIBLY_UNIQUELY_DERIVED_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, 1, (tree *)0) >= 0)\n #define DERIVED_FROM_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, 0, (tree *)0) != -1)\n \f\n-enum conversion_type { ptr_conv, constptr_conv, int_conv,\n-\t\t       real_conv, last_conversion_type };\n-\n /* Statistics show that while the GNU C++ compiler may generate\n    thousands of different types during a compilation run, it\n    generates relatively few (tens) of classtypes.  Because of this,\n@@ -492,7 +498,6 @@ struct lang_type\n   union tree_node *friend_classes;\n \n   char *mi_matrix;\n-  union tree_node *conversions[last_conversion_type];\n \n   union tree_node *rtti;\n \n@@ -657,6 +662,12 @@ struct lang_type\n /* List of lists of member functions defined in this class.  */\n #define CLASSTYPE_METHOD_VEC(NODE) TYPE_METHODS(NODE)\n \n+/* The first type conversion operator in the class (the others can be\n+   searched with TREE_CHAIN), or the first non-constructor function if\n+   there are no type conversion operators.  */\n+#define CLASSTYPE_FIRST_CONVERSION(NODE) \\\n+  TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (NODE), 1)\n+\n /* Pointer from any member function to the head of the list of\n    member functions of the type that member function belongs to.  */\n #define CLASSTYPE_BASELINK_VEC(NODE) (TYPE_LANG_SPECIFIC(NODE)->baselink_vec)\n@@ -807,12 +818,6 @@ struct lang_type\n    a type is derived from another or not.  */\n #define CLASSTYPE_MI_MATRIX(NODE) (TYPE_LANG_SPECIFIC(NODE)->mi_matrix)\n \n-/* If there is exactly one conversion to a non-void, non-const pointer type,\n-   remember that here.  If there are more than one, put\n-   `error_mark_node' here.  If there are none, this holds NULL_TREE.  */\n-#define CLASSTYPE_CONVERSION(NODE,KIND) \\\n-  (TYPE_LANG_SPECIFIC(NODE)->conversions[(int) KIND])\n-\n /* Say whether this node was declared as a \"class\" or a \"struct\".  */\n #define CLASSTYPE_DECLARED_CLASS(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.declared_class)\n /* whether this can be globalized.  */\n@@ -2243,6 +2248,7 @@ extern void print_search_statistics\t\tPROTO((void));\n extern void init_search_processing\t\tPROTO((void));\n extern void reinit_search_statistics\t\tPROTO((void));\n extern tree current_scope\t\t\tPROTO((void));\n+extern tree lookup_conversions\t\t\tPROTO((tree));\n \n /* in sig.c */\n extern tree build_signature_pointer_type\tPROTO((tree, int, int));"}, {"sha": "c42cb1aed6f99bde1da55ebd5e7f5feadc8382df", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 42, "deletions": 312, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "patch": "@@ -518,6 +518,18 @@ build_up_reference (type, arg, flags, checkconst)\n \t\t    build_up_reference (type, TREE_OPERAND (targ, 2),\n \t\t\t\t\tLOOKUP_PROTECT, checkconst));\n \n+      /* Undo the folding... */\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+      return build (COND_EXPR, type,\n+\t\t    build (TREE_CODE (targ) == MIN_EXPR ? LT_EXPR : GT_EXPR,\n+\t\t\t   boolean_type_node, TREE_OPERAND (targ, 0),\n+\t\t\t   TREE_OPERAND (targ, 1)),\n+\t\t    build_up_reference (type, TREE_OPERAND (targ, 0),\n+\t\t\t\t\tLOOKUP_PROTECT, checkconst),\n+\t\t    build_up_reference (type, TREE_OPERAND (targ, 1),\n+\t\t\t\t\tLOOKUP_PROTECT, checkconst));\n+\n     case WITH_CLEANUP_EXPR:\n       return build (WITH_CLEANUP_EXPR, type,\n \t\t    build_up_reference (type, TREE_OPERAND (targ, 0),\n@@ -666,11 +678,10 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n       if (form == REFERENCE_TYPE)\n \t{\n \t  tree type = TREE_TYPE (expr);\n-\t  tree tmp = copy_node (expr);\n-\t  TREE_TYPE (tmp) = build_pointer_type (TREE_TYPE (TREE_TYPE (expr)));\n-\t  rval = cp_convert (build_pointer_type (TREE_TYPE (reftype)), tmp,\n+\t  TREE_TYPE (expr) = build_pointer_type (TREE_TYPE (type));\n+\t  rval = cp_convert (build_pointer_type (TREE_TYPE (reftype)), expr,\n \t\t\t     convtype, flags);\n-\t  TREE_TYPE (tmp) = type;\n+\t  TREE_TYPE (expr) = type;\n \t  TREE_TYPE (rval) = reftype;\n \t  return rval;\n \t}\n@@ -1487,29 +1498,19 @@ build_type_conversion_1 (xtype, basetype, expr, typename, for_sure)\n \n    If (FOR_SURE & 1) is non-zero, then we allow this type conversion\n    to take place immediately.  Otherwise, we build a SAVE_EXPR\n-   which can be evaluated if the results are ever needed.\n+   which can be evaluated if the results are ever needed.  */\n \n-   If FOR_SURE >= 2, then we only look for exact conversions.\n-\n-   TYPE may be a reference type, in which case we first look\n-   for something that will convert to a reference type.  If\n-   that fails, we will try to look for something of the\n-   reference's target type, and then return a reference to that.  */\n tree\n build_type_conversion (code, xtype, expr, for_sure)\n      enum tree_code code;\n      tree xtype, expr;\n      int for_sure;\n {\n   /* C++: check to see if we can convert this aggregate type\n-     into the required scalar type.  */\n-  tree type, type_default;\n-  tree typename = build_typename_overload (xtype), *typenames;\n-  int n_variants = 0;\n-  tree basetype, save_basetype;\n-  tree rval;\n-  int exact_conversion = for_sure >= 2;\n-  for_sure &= 1;\n+     into the required type.  */\n+  tree basetype;\n+  tree conv;\n+  tree winner = NULL_TREE;\n \n   if (expr == error_mark_node)\n     return error_mark_node;\n@@ -1518,313 +1519,42 @@ build_type_conversion (code, xtype, expr, for_sure)\n   if (TREE_CODE (basetype) == REFERENCE_TYPE)\n     basetype = TREE_TYPE (basetype);\n \n-  if (TYPE_PTRMEMFUNC_P (basetype) && TREE_CODE (xtype) == BOOLEAN_TYPE)\n-    {\n-      /* We convert a pointer to member function into a boolean,\n-\t by just checking the index value, for == 0, we want false, for\n-\t != 0, we want true.  */\n-      return convert (xtype, build_component_ref (expr, index_identifier, 0, 0));\n-    }\n-\n   basetype = TYPE_MAIN_VARIANT (basetype);\n   if (! TYPE_LANG_SPECIFIC (basetype) || ! TYPE_HAS_CONVERSION (basetype))\n     return NULL_TREE;\n \n-  if (TREE_CODE (xtype) == POINTER_TYPE\n-      || TREE_CODE (xtype) == REFERENCE_TYPE)\n-    {\n-      /* Prepare to match a variant of this type.  */\n-      type = TYPE_MAIN_VARIANT (TREE_TYPE (xtype));\n-      for (n_variants = 0; type; type = TYPE_NEXT_VARIANT (type))\n-\tn_variants++;\n-      typenames = (tree *)alloca (n_variants * sizeof (tree));\n-      for (n_variants = 0, type = TYPE_MAIN_VARIANT (TREE_TYPE (xtype));\n-\t   type; n_variants++, type = TYPE_NEXT_VARIANT (type))\n-\t{\n-\t  if (type == TREE_TYPE (xtype))\n-\t    typenames[n_variants] = typename;\n-\t  else if (TREE_CODE (xtype) == POINTER_TYPE)\n-\t    typenames[n_variants] = build_typename_overload (build_pointer_type (type));\n-\t  else\n-\t    typenames[n_variants] = build_typename_overload (build_reference_type (type));\n-\t}\n-    }\n-\n-  save_basetype = basetype;\n-  type = xtype;\n-\n-  while (TYPE_HAS_CONVERSION (basetype))\n-    {\n-      int i;\n-      if (lookup_fnfields (TYPE_BINFO (basetype), typename, 0))\n-\treturn build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n-      for (i = 0; i < n_variants; i++)\n-\tif (typenames[i] != typename\n-\t    && lookup_fnfields (TYPE_BINFO (basetype), typenames[i], 0))\n-\t  return build_type_conversion_1 (xtype, basetype, expr, typenames[i], for_sure);\n-\n-      if (TYPE_BINFO_BASETYPES (basetype))\n-\tbasetype = TYPE_BINFO_BASETYPE (basetype, 0);\n-      else\n-\tbreak;\n-    }\n-\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    {\n-#if 0\n-      /* Only reference variable initializations can use a temporary; this\n-         must be handled elsewhere (like convert_to_reference and\n-         compute_conversion_costs).  */\n-\n-      type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n-      typename = build_typename_overload (type);\n-      basetype = save_basetype;\n-\n-      /* May need to build a temporary for this.  */\n-      while (TYPE_HAS_CONVERSION (basetype))\n-\t{\n-\t  if (lookup_fnfields (TYPE_BINFO (basetype), typename, 0))\n-\t    {\n-\t      int flags;\n-\n-\t      if (for_sure == 0)\n-\t\tflags = LOOKUP_PROTECT|LOOKUP_ONLYCONVERTING;\n-\t      else\n-\t\tflags = LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING;\n-\t      rval = build_method_call (expr,\n-\t\t\t\t\tconstructor_name_full (typename),\n-\t\t\t\t\tNULL_TREE, NULL_TREE, flags);\n-\t      if (rval == error_mark_node)\n-\t\t{\n-\t\t  if (for_sure == 0)\n-\t\t    return NULL_TREE;\n-\t\t  return error_mark_node;\n-\t\t}\n-\n-\t      return convert (xtype, rval);\n-\t    }\n-\t  if (TYPE_BINFO_BASETYPES (basetype))\n-\t    basetype = TYPE_BINFO_BASETYPE (basetype, 0);\n-\t  else\n-\t    break;\n-\t}\n-#endif\n-      /* No free conversions for reference types, right?.  */\n-      return NULL_TREE;\n-    }\n-\n-  if (exact_conversion)\n-    return NULL_TREE;\n-\n-  if (TREE_CODE (type) == BOOLEAN_TYPE)\n-    {\n-      tree as_int = build_type_conversion (code, long_long_unsigned_type_node, expr, 0);\n-      tree as_ptr = build_type_conversion (code, ptr_type_node, expr, 0);\n-      /* We are missing the conversion to pointer to member type. */\n-      /* We are missing the conversion to floating type. */\n-      if (as_int && as_ptr && for_sure)\n-\t{\n-\t  cp_error (\"ambiguous conversion from `%T' to `bool', can convert to integral type or pointer\", TREE_TYPE (expr));\n-\t  return error_mark_node;\n-\t}\n-      if (as_int)\n-\t{\n-\t  as_int = build_type_conversion (code, long_long_unsigned_type_node, expr, for_sure+exact_conversion*2);\n-\t  return convert (xtype, as_int);\n-\t}\n-      if (as_ptr)\n-\t{\n-\t  as_ptr = build_type_conversion (code, ptr_type_node, expr, for_sure+exact_conversion*2);\n-\t  return convert (xtype, as_ptr);\n-\t}\n-      return NULL_TREE;\n-    }\n-\n-  /* No perfect match found, try default.  */\n-#if 0 /* This is wrong; there is no standard conversion from void* to\n-         anything.  -jason */\n-  if (code == CONVERT_EXPR && TREE_CODE (type) == POINTER_TYPE)\n-    type_default = ptr_type_node;\n-  else\n-#endif\n-  if (type == void_type_node)\n-    return NULL_TREE;\n-  else\n-    {\n-      tree tmp = default_conversion (build1 (NOP_EXPR, type, integer_zero_node));\n-      if (tmp == error_mark_node)\n-\treturn NULL_TREE;\n-      type_default = TREE_TYPE (tmp);\n-    }\n-\n-  basetype = save_basetype;\n-\n-  if (type_default != type)\n-    {\n-      type = type_default;\n-      typename = build_typename_overload (type);\n-\n-      while (TYPE_HAS_CONVERSION (basetype))\n-\t{\n-\t  if (lookup_fnfields (TYPE_BINFO (basetype), typename, 0))\n-\t    return build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n-\t  if (TYPE_BINFO_BASETYPES (basetype))\n-\t    basetype = TYPE_BINFO_BASETYPE (basetype, 0);\n-\t  else\n-\t    break;\n-\t}\n-    }\n-\n-  if (TREE_CODE (type) == POINTER_TYPE && TYPE_READONLY (TREE_TYPE (type)))\n-    {\n-      /* Try converting to some other const pointer type and then using\n-         standard conversions. */\n-\n-      while (TYPE_HAS_CONVERSION (basetype))\n-\t{\n-\t  if (CLASSTYPE_CONVERSION (basetype, constptr_conv) != 0)\n-\t    {\n-\t      if (CLASSTYPE_CONVERSION (basetype, constptr_conv) == error_mark_node)\n-\t\treturn error_mark_node;\n-\t      typename = DECL_NAME (CLASSTYPE_CONVERSION (basetype, constptr_conv));\n-\t      return build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n-\t    }\n-\t  if (TYPE_BINFO_BASETYPES (basetype))\n-\t    basetype = TYPE_BINFO_BASETYPE (basetype, 0);\n-\t  else\n-\t    break;\n-\t}\n-    }\n-  if (TREE_CODE (type) == POINTER_TYPE)\n-    {\n-      /* Try converting to some other pointer type and then using standard\n-\t conversions.  */\n-\n-      while (TYPE_HAS_CONVERSION (basetype))\n-\t{\n-\t  if (CLASSTYPE_CONVERSION (basetype, ptr_conv) != 0)\n-\t    {\n-\t      if (CLASSTYPE_CONVERSION (basetype, ptr_conv) == error_mark_node)\n-\t\treturn error_mark_node;\n-\t      typename = DECL_NAME (CLASSTYPE_CONVERSION (basetype, ptr_conv));\n-\t      return build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n-\t    }\n-\t  if (TYPE_BINFO_BASETYPES (basetype))\n-\t    basetype = TYPE_BINFO_BASETYPE (basetype, 0);\n-\t  else\n-\t    break;\n-\t}\n-    }\n-\n-  /* Use the longer or shorter conversion that is appropriate.  Have\n-     to check against 0 because the conversion may come from a baseclass.  */\n-  if (TREE_CODE (type) == INTEGER_TYPE\n-      && TYPE_HAS_INT_CONVERSION (basetype)\n-      && CLASSTYPE_CONVERSION (basetype, int_conv) != 0\n-      && CLASSTYPE_CONVERSION (basetype, int_conv) != error_mark_node)\n-    {\n-      typename = DECL_NAME (CLASSTYPE_CONVERSION (basetype, int_conv));\n-      return build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n-    }\n+  /* Do we have an exact match?  */\n+  {\n+    tree typename = build_typename_overload (xtype);\n+    if (lookup_fnfields (TYPE_BINFO (basetype), typename, 0))\n+      return build_type_conversion_1 (xtype, basetype, expr, typename,\n+\t\t\t\t      for_sure);\n+  }\n \n-  if (TREE_CODE (type) == REAL_TYPE\n-      && TYPE_HAS_REAL_CONVERSION (basetype)\n-      && CLASSTYPE_CONVERSION (basetype, real_conv) != 0\n-      && CLASSTYPE_CONVERSION (basetype, real_conv) != error_mark_node)\n+  /* Nope; try looking for others.  */\n+  for (conv = lookup_conversions (basetype); conv; conv = TREE_CHAIN (conv))\n     {\n-      /* Only accept using an operator double() if there isn't a conflicting\n-\t operator int().  */\n-      if (TYPE_HAS_INT_CONVERSION (basetype))\n-\t{\n-\t  if (for_sure)\n-\t    {\n-\t      cp_error (\"two possible conversions for type `%T'\", type);\n-\t      return error_mark_node;\n-\t    }\n-\t  else\n-\t    return NULL_TREE;\n-\t}\n+      if (winner && TREE_PURPOSE (winner) == TREE_PURPOSE (conv))\n+\tcontinue;\n \n-      typename = DECL_NAME (CLASSTYPE_CONVERSION (basetype, real_conv));\n-      return build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n-    }\n-\n-  /* THESE ARE TOTAL KLUDGES.  */\n-  /* Default promotion yields no new alternatives, try\n-     conversions which are anti-default, such as\n-\n-     double -> float or int -> unsigned or unsigned -> long\n-\n-     */\n-  if (type_default == type\n-      && (INTEGRAL_TYPE_P (type) || TREE_CODE (type) == REAL_TYPE))\n-    {\n-      int not_again = 0;\n-\n-      if (type == double_type_node)\n-\ttypename = build_typename_overload (float_type_node);\n-      else if (type == integer_type_node)\n-\ttypename = build_typename_overload (unsigned_type_node);\n-      else if (type == unsigned_type_node)\n-\ttypename = build_typename_overload (long_integer_type_node);\n-\n-    again:\n-      basetype = save_basetype;\n-      while (TYPE_HAS_CONVERSION (basetype))\n-\t{\n-\t  if (lookup_fnfields (TYPE_BINFO (basetype), typename, 0))\n-\t    return build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n-\t  if (TYPE_BINFO_BASETYPES (basetype))\n-\t    basetype = TYPE_BINFO_BASETYPE (basetype, 0);\n-\t  else\n-\t    break;\n-\t}\n-      if (! not_again)\n+      if (can_convert (xtype, TREE_VALUE (conv)))\n \t{\n-\t  if (type == integer_type_node)\n+\t  if (winner)\n \t    {\n-\t      typename = build_typename_overload (long_integer_type_node);\n-\t      not_again = 1;\n-\t      goto again;\n+\t      cp_error (\"ambiguous conversion from `%T' to `%T'\", basetype,\n+\t\t\txtype);\n+\t      cp_error (\"  candidate conversion functions include `%T' and `%T'\",\n+\t\t\tTREE_VALUE (winner), TREE_VALUE (conv));\n+\t      return NULL_TREE;\n \t    }\n \t  else\n-\t    {\n-\t      typename = build_typename_overload (integer_type_node);\n-\t      not_again = 1;\n-\t      goto again;\n-\t    }\n+\t    winner = conv;\n \t}\n     }\n \n-  /* Now, try C promotions...\n-\n-     float -> int\n-     int -> float  */\n-\n-    basetype = save_basetype;\n-    if (TREE_CODE (type) == REAL_TYPE)\n-      type = integer_type_node;\n-    else if (TREE_CODE (type) == INTEGER_TYPE)\n-      if (TYPE_HAS_REAL_CONVERSION (basetype))\n-\ttype = double_type_node;\n-      else\n-\treturn NULL_TREE;\n-    else\n-      return NULL_TREE;\n-\n-    typename = build_typename_overload (type);\n-    while (TYPE_HAS_CONVERSION (basetype))\n-      {\n-\tif (lookup_fnfields (TYPE_BINFO (basetype), typename, 0))\n-\t  {\n-\t    rval = build_type_conversion_1 (xtype, basetype, expr, typename, for_sure);\n-\t    return rval;\n-\t  }\n-\tif (TYPE_BINFO_BASETYPES (basetype))\n-\t  basetype = TYPE_BINFO_BASETYPE (basetype, 0);\n-\telse\n-\t  break;\n-      }\n+  if (winner)\n+    return build_type_conversion_1 (xtype, basetype, expr,\n+\t\t\t\t    TREE_PURPOSE (winner), for_sure);\n \n   return NULL_TREE;\n }"}, {"sha": "a6d7e3f8e261b621fd84dbe517b061dcdf8ae453", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 241, "deletions": 162, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "patch": "@@ -49,6 +49,8 @@ extern int current_class_depth;\n \n extern tree cleanups_this_call;\n \n+extern tree static_ctors, static_dtors;\n+\n /* Stack of places to restore the search obstack back to.  */\n    \n /* Obstack used for remembering local class declarations (like\n@@ -94,7 +96,11 @@ static struct stack_level *decl_stack;\n #endif\n \n #ifndef BOOL_TYPE_SIZE\n+#ifdef SLOW_BYTE_ACCESS\n #define BOOL_TYPE_SIZE BITS_PER_WORD\n+#else\n+#define BOOL_TYPE_SIZE BITS_PER_UNIT\n+#endif\n #endif\n \n /* We let tm.h override the types used here, to handle trivial differences\n@@ -428,7 +434,8 @@ extern int flag_no_builtin;\n \n extern int flag_no_nonansi_builtin;\n \n-/* Nonzero means disable GNU extensions.  */\n+/* Nonzero means enable obscure ANSI features and disable GNU extensions\n+   that might cause ANSI-compliant code to be miscompiled.  */\n \n extern int flag_ansi;\n \n@@ -1638,27 +1645,25 @@ static void\n set_nested_typename (decl, classname, name, type)\n      tree decl, classname, name, type;\n {\n+  char *buf;\n   my_friendly_assert (TREE_CODE (decl) == TYPE_DECL, 136);\n-  if (classname != NULL_TREE)\n-    {\n-      char *buf;\n-      my_friendly_assert (TREE_CODE (classname) == IDENTIFIER_NODE, 137);\n-      my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 138);\n-      buf = (char *) alloca (4 + IDENTIFIER_LENGTH (classname)\n-\t\t\t     + IDENTIFIER_LENGTH (name));\n-      sprintf (buf, \"%s::%s\", IDENTIFIER_POINTER (classname),\n-\t       IDENTIFIER_POINTER (name));\n-      DECL_NESTED_TYPENAME (decl) = get_identifier (buf);\n-      TREE_MANGLED (DECL_NESTED_TYPENAME (decl)) = 1;\n-\n-      /* This is a special usage of IDENTIFIER_TYPE_VALUE which have no\n-\t correspondence in any binding_level.  This is ok since the\n-\t DECL_NESTED_TYPENAME is just a convenience identifier whose\n-\t IDENTIFIER_TYPE_VALUE will remain constant from now on.  */\n-      SET_IDENTIFIER_TYPE_VALUE (DECL_NESTED_TYPENAME (decl), type);\n-    }\n-  else\n-    DECL_NESTED_TYPENAME (decl) = name;\n+  if (classname == NULL_TREE)\n+    classname = get_identifier (\"\");\n+\n+  my_friendly_assert (TREE_CODE (classname) == IDENTIFIER_NODE, 137);\n+  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 138);\n+  buf = (char *) alloca (4 + IDENTIFIER_LENGTH (classname)\n+\t\t\t + IDENTIFIER_LENGTH (name));\n+  sprintf (buf, \"%s::%s\", IDENTIFIER_POINTER (classname),\n+\t   IDENTIFIER_POINTER (name));\n+  DECL_NESTED_TYPENAME (decl) = get_identifier (buf);\n+  TREE_MANGLED (DECL_NESTED_TYPENAME (decl)) = 1;\n+\n+  /* This is a special usage of IDENTIFIER_TYPE_VALUE which have no\n+     correspondence in any binding_level.  This is ok since the\n+     DECL_NESTED_TYPENAME is just a convenience identifier whose\n+     IDENTIFIER_TYPE_VALUE will remain constant from now on.  */\n+  SET_IDENTIFIER_TYPE_VALUE (DECL_NESTED_TYPENAME (decl), type);\n }\n \n /* Pop off extraneous binding levels left over due to syntax errors.  */\n@@ -1743,11 +1748,13 @@ pushtag (name, type, globalize)\n         context = current_scope ();\n       if (context)\n \tc_decl = TREE_CODE (context) == FUNCTION_DECL\n-\t  ? context : TYPE_NAME (context);\n+\t  ? context : TYPE_MAIN_DECL (context);\n \n+#if 0\n       /* Record the identifier as the type's name if it has none.  */\n       if (TYPE_NAME (type) == NULL_TREE)\n         TYPE_NAME (type) = name;\n+#endif\n       \n       /* Do C++ gratuitous typedefing.  */\n       if (IDENTIFIER_TYPE_VALUE (name) != type)\n@@ -1784,14 +1791,11 @@ pushtag (name, type, globalize)\n \t      else\n \t\td = TYPE_NAME (d);\n \n+\t      TYPE_NAME (type) = d;\n+\n \t      /* If it is anonymous, then we are called from pushdecl,\n-\t\t and we don't want to infinitely recurse.  Also, if the\n-\t\t name is already in scope, we don't want to push it\n-\t\t again--pushdecl is only for pushing new decls.  */\n-\t      if (! ANON_AGGRNAME_P (name)\n-\t\t  && TYPE_NAME (type)\n-\t\t  && (TREE_CODE (TYPE_NAME (type)) != TYPE_DECL\n-\t\t      || lookup_name (name, 1) != TYPE_NAME (type)))\n+\t\t and we don't want to infinitely recurse.  */\n+\t      if (! ANON_AGGRNAME_P (name))\n \t\t{\n \t\t  if (b->parm_flag == 2)\n \t\t    d = pushdecl_class_level (d);\n@@ -1815,6 +1819,9 @@ pushtag (name, type, globalize)\n \t\t  DECL_IGNORED_P (d) = 1;\n \t\t}\n #endif /* DWARF_DEBUGGING_INFO */\n+\n+\t      TYPE_NAME (type) = d;\n+\n \t      /* Make sure we're in this type's scope when we push the\n \t\t decl for a template, otherwise class_binding_level will\n \t\t be NULL and we'll end up dying inside of\n@@ -1830,11 +1837,10 @@ pushtag (name, type, globalize)\n \t      if (ANON_AGGRNAME_P (name))\n \t\tDECL_IGNORED_P (d) = 1;\n \t    }\n-\t  TYPE_NAME (type) = d;\n \n \t  if (context == NULL_TREE)\n \t    /* Non-nested class.  */\n-\t    DECL_NESTED_TYPENAME (d) = name;\n+\t    set_nested_typename (d, NULL_TREE, name, type);\n \t  else if (context && TREE_CODE (context) == FUNCTION_DECL)\n \t    {\n \t      /* Function-nested class.  */\n@@ -2036,7 +2042,9 @@ decls_match (newdecl, olddecl)\n       else if (TREE_TYPE (newdecl) == NULL_TREE)\n \ttypes_match = 0;\n       else\n-\ttypes_match = comptypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl), 1);\n+\ttypes_match = (comptypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl), 1)\n+\t\t       && TREE_READONLY (newdecl) == TREE_READONLY (olddecl)\n+\t\t       && TREE_THIS_VOLATILE (newdecl) == TREE_THIS_VOLATILE (olddecl));\n     }\n \n   return types_match;\n@@ -2226,16 +2234,6 @@ duplicate_decls (newdecl, olddecl)\n \t    return 0;\n \t}\n \n-      if (olddecl == wchar_decl_node)\n-\t{\n-\t  if (pedantic && ! DECL_IN_SYSTEM_HEADER (newdecl))\n-\t    cp_pedwarn (\"redeclaration of wchar_t as `%T'\",\n-\t\t\tTREE_TYPE (newdecl));\n-\n-\t  /* Throw away the redeclaration.  */\n-\t  return 1;\n-\t}\n-\n       /* Already complained about this, so don't do so again.  */\n       else if (current_class_type == NULL_TREE\n \t  || IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (newdecl)) != current_class_type)\n@@ -2281,6 +2279,39 @@ duplicate_decls (newdecl, olddecl)\n \t\t\tDECL_LANGUAGE (newdecl));\n \t    }\n \t}\n+\n+      if (TREE_CODE (olddecl) == FUNCTION_DECL)\n+\t{\n+\t  tree t1 = TYPE_ARG_TYPES (TREE_TYPE (olddecl));\n+\t  tree t2 = TYPE_ARG_TYPES (TREE_TYPE (newdecl));\n+\t  int i = 1;\n+\n+\t  if (TREE_CODE (TREE_TYPE (newdecl)) == METHOD_TYPE)\n+\t    t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2);\n+\t\n+\t  for (; t1 && t1 != void_list_node;\n+\t       t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2), i++)\n+\t    if (TREE_PURPOSE (t1) && TREE_PURPOSE (t2))\n+\t      {\n+\t\tif (simple_cst_equal (TREE_PURPOSE (t1), TREE_PURPOSE (t2)))\n+\t\t  {\n+\t\t    if (pedantic)\n+\t\t      {\n+\t\t\tcp_pedwarn (\"default argument given for parameter %d of `%#D'\",\n+\t\t\t\t    i, newdecl);\n+\t\t\tcp_pedwarn_at (\"after previous specification in `%#D'\",\n+\t\t\t\t       olddecl);\n+\t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    cp_error (\"default argument given for parameter %d of `%#D'\",\n+\t\t\t      i, newdecl);\n+\t\t    cp_error_at (\"conflicts with previous specification in `%#D'\",\n+\t\t\t\t olddecl);\n+\t\t  }\n+\t      }\n+\t}\n     }\n \n   /* If new decl is `static' and an `extern' was seen previously,\n@@ -2306,6 +2337,8 @@ duplicate_decls (newdecl, olddecl)\n \tDECL_NEXT_METHOD (newdecl) = DECL_NEXT_METHOD (olddecl);\n       if (DECL_PENDING_INLINE_INFO (newdecl) == (struct pending_inline *)0)\n \tDECL_PENDING_INLINE_INFO (newdecl) = DECL_PENDING_INLINE_INFO (olddecl);\n+      DECL_STATIC_CONSTRUCTOR (newdecl) |= DECL_STATIC_CONSTRUCTOR (olddecl);\n+      DECL_STATIC_DESTRUCTOR (newdecl) |= DECL_STATIC_DESTRUCTOR (olddecl);\n     }\n \n   /* Deal with C++: must preserve virtual function table size.  */\n@@ -2358,20 +2391,20 @@ duplicate_decls (newdecl, olddecl)\n     {\n       /* Automatically handles default parameters.  */\n       tree oldtype = TREE_TYPE (olddecl);\n-      /* Merge the data types specified in the two decls.  */\n-      tree newtype = common_type (TREE_TYPE (newdecl), TREE_TYPE (olddecl));\n+      tree newtype;\n \n-      /* Make sure we put the new type in the same obstack as the old ones.\n-\t If the old types are not both in the same obstack, use the permanent\n-\t one.  */\n-      if (oldtype && TYPE_OBSTACK (oldtype) == TYPE_OBSTACK (newtype))\n+      /* Make sure we put the new type in the same obstack as the old one.  */\n+      if (oldtype)\n \tpush_obstacks (TYPE_OBSTACK (oldtype), TYPE_OBSTACK (oldtype));\n       else\n \t{\n \t  push_obstacks_nochange ();\n \t  end_temporary_allocation ();\n \t}\n \n+      /* Merge the data types specified in the two decls.  */\n+      newtype = common_type (TREE_TYPE (newdecl), TREE_TYPE (olddecl));\n+\n       if (TREE_CODE (newdecl) == VAR_DECL)\n \tDECL_THIS_EXTERN (newdecl) |= DECL_THIS_EXTERN (olddecl);\n       /* Do this after calling `common_type' so that default\n@@ -2703,6 +2736,14 @@ pushdecl (x)\n \t\t   && ! DECL_TEMPLATE_IS_CLASS (x)))\n \t      && is_overloaded_fn (t))\n \t    /* don't do anything just yet */;\n+\t  else if (t == wchar_decl_node)\n+\t    {\n+\t      if (pedantic && ! DECL_IN_SYSTEM_HEADER (x))\n+\t\tcp_pedwarn (\"redeclaration of wchar_t as `%T'\", TREE_TYPE (x));\n+\n+\t      /* Throw away the redeclaration.  */\n+\t      return t;\n+\t    }\n \t  else if (TREE_CODE (t) != TREE_CODE (x))\n \t    {\n \t      if ((TREE_CODE (t) == TYPE_DECL && DECL_ARTIFICIAL (t))\n@@ -2796,9 +2837,8 @@ pushdecl (x)\n \t    }\n \t  my_friendly_assert (TREE_CODE (name) == TYPE_DECL, 140);\n \n-\t  if (DECL_NAME (name) && !DECL_NESTED_TYPENAME (name))\n-\t    set_nested_typename (x, current_class_name,\n-\t\t\t\t DECL_NAME (name), type);\n+\t  if (! DECL_NESTED_TYPENAME (x))\n+\t    set_nested_typename (x, current_class_name, DECL_NAME (x), type);\n \n \t  if (type != error_mark_node\n \t      && TYPE_NAME (type)\n@@ -2856,11 +2896,11 @@ pushdecl (x)\n \t  if (IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE && DECL_PUBLIC (x))\n \t    TREE_PUBLIC (name) = 1;\n \n-\t  /* Don't install a TYPE_DECL if we already have another\n-\t     sort of _DECL with that name.  */\n+\t  /* Don't install an artificial TYPE_DECL if we already have\n+\t     another _DECL with that name.  */\n \t  if (TREE_CODE (x) != TYPE_DECL\n \t      || t == NULL_TREE\n-\t      || TREE_CODE (t) == TYPE_DECL)\n+\t      || ! DECL_ARTIFICIAL (x))\n \t    IDENTIFIER_GLOBAL_VALUE (name) = x;\n \n \t  /* Don't forget if the function was used via an implicit decl.  */\n@@ -2892,8 +2932,15 @@ pushdecl (x)\n \t  tree oldlocal = IDENTIFIER_LOCAL_VALUE (name);\n \t  tree oldglobal = IDENTIFIER_GLOBAL_VALUE (name);\n \n-\t  b->shadowed = tree_cons (name, oldlocal, b->shadowed);\n-\t  IDENTIFIER_LOCAL_VALUE (name) = x;\n+\t  /* Don't install an artificial TYPE_DECL if we already have\n+\t     another _DECL with that name.  */\n+\t  if (TREE_CODE (x) != TYPE_DECL\n+\t      || t == NULL_TREE\n+\t      || ! DECL_ARTIFICIAL (x))\n+\t    {\n+\t      b->shadowed = tree_cons (name, oldlocal, b->shadowed);\n+\t      IDENTIFIER_LOCAL_VALUE (name) = x;\n+\t    }\n \n \t  /* If this is a TYPE_DECL, push it into the type value slot.  */\n \t  if (TREE_CODE (x) == TYPE_DECL)\n@@ -2968,11 +3015,25 @@ pushdecl (x)\n \t      if (warnstring)\n \t\twarning (warnstring, IDENTIFIER_POINTER (name));\n \t    }\n+\t}\n \n-\t  /* If storing a local value, there may already be one (inherited).\n-\t     If so, record it for restoration when this binding level ends.  */\n-\t  if (oldlocal != NULL_TREE)\n-\t    b->shadowed = tree_cons (name, oldlocal, b->shadowed);\n+      if (TREE_CODE (x) == FUNCTION_DECL)\n+\t{\n+\t  /* This is probably the wrong place to check this, but it has to\n+             come after the call to duplicate_decls.  */\n+\t  tree arg = TYPE_ARG_TYPES (TREE_TYPE (x));\n+\t  int saw_def = 0, i = 1;\n+\t  for (; arg && arg != void_list_node; arg = TREE_CHAIN (arg), ++i)\n+\t    {\n+\t      if (TREE_PURPOSE (arg))\n+\t\tsaw_def = 1;\n+\t      else if (saw_def)\n+\t\t{\n+\t\t  cp_error (\"default argument missing for parameter %d of `%#D'\",\n+\t\t\t    i, x);\n+\t\t  break;\n+\t\t}\n+\t    }\n \t}\n \n       /* Keep count of variables in this level with incomplete type.  */\n@@ -3168,6 +3229,10 @@ push_class_level_binding (name, x)\n      tree name;\n      tree x;\n {\n+  if (TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)\n+      && purpose_member (name, class_binding_level->class_shadowed))\n+    return;\n+\n   maybe_push_cache_obstack ();\n   class_binding_level->class_shadowed\n       = tree_cons (name, IDENTIFIER_CLASS_VALUE (name),\n@@ -3251,13 +3316,7 @@ push_overloaded_decl (decl, forgettable)\n \told = TREE_OPERAND (old, 0);\n       else\n #endif\n-      if (TREE_CODE (old) == VAR_DECL)\n-\t{\n-\t  cp_error_at (\"previous non-function declaration `%#D'\", old);\n-\t  cp_error (\"conflicts with function declaration `%#D'\", decl);\n-\t  return error_mark_node;\n-\t}\n-      else if (TREE_CODE (old) == TYPE_DECL)\n+      if (TREE_CODE (old) == TYPE_DECL && DECL_ARTIFICIAL (old))\n \t{\n \t  tree t = TREE_TYPE (old);\n \t  if (IS_AGGR_TYPE (t) && warn_shadow)\n@@ -3272,6 +3331,12 @@ push_overloaded_decl (decl, forgettable)\n \t    if (decl == tmp || duplicate_decls (decl, tmp))\n \t      return tmp;\n \t}\n+      else\n+\t{\n+\t  cp_error_at (\"previous non-function declaration `%#D'\", old);\n+\t  cp_error (\"conflicts with function declaration `%#D'\", decl);\n+\t  return error_mark_node;\n+\t}\n     }\n \n   if (old || TREE_CODE (decl) == TEMPLATE_DECL)\n@@ -3386,18 +3451,6 @@ redeclaration_error_message (newdecl, olddecl)\n \t  else\n \t    return \"redefinition of `%#D'\";\n \t}\n-\n-      {\n-\ttree t1 = TYPE_ARG_TYPES (TREE_TYPE (olddecl));\n-\ttree t2 = TYPE_ARG_TYPES (TREE_TYPE (newdecl));\n-\n-\tif (TREE_CODE (TREE_TYPE (newdecl)) == METHOD_TYPE)\n-\t  t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2);\n-\t\n-\tfor (; t1; t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2))\n-\t  if (TREE_PURPOSE (t1) && TREE_PURPOSE (t2))\n-\t    return \"duplicate default arguments given for `%#D'\";\n-      }\n       return 0;\n     }\n   else if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n@@ -3535,6 +3588,9 @@ define_label (filename, line, name)\n       decl = lookup_label (name);\n     }\n \n+  if (name == get_identifier (\"wchar_t\"))\n+    cp_pedwarn (\"label named wchar_t\");\n+\n   if (DECL_INITIAL (decl) != NULL_TREE)\n     {\n       cp_error (\"duplicate label `%D'\", decl);\n@@ -3866,9 +3922,9 @@ lookup_nested_type (type, context)\n \t  }\n \t  break;\n \tcase FUNCTION_DECL:\n-\t  return TYPE_IDENTIFIER (type) ?\n-\t    lookup_name (TYPE_IDENTIFIER (type), 1) : NULL_TREE;\n-\t  break;\n+\t  if (TYPE_NAME (type) && TYPE_IDENTIFIER (type))\n+\t    return lookup_name (TYPE_IDENTIFIER (type), 1);\n+\t  return NULL_TREE;\n \tdefault:\n \t  my_friendly_abort (12);\n \t}\n@@ -3893,60 +3949,74 @@ lookup_name_real (name, prefer_type, nonclass)\n {\n   register tree val;\n   int yylex = 0;\n+  tree from_obj = NULL_TREE;\n \n   if (prefer_type == -2)\n     {\n       extern int looking_for_typename;\n+      tree type;\n \n       yylex = 1;\n       prefer_type = looking_for_typename;\n+\n+      if (got_scope)\n+\ttype = got_scope;\n+      else\n+\ttype = got_object;\n       \n-      if (got_scope != NULL_TREE)\n+      if (type)\n \t{\n-\t  if (got_scope == error_mark_node)\n+\t  if (type == error_mark_node)\n \t    return error_mark_node;\n-\t  else if (got_scope == void_type_node)\n+\t  else if (type == void_type_node)\n \t    val = IDENTIFIER_GLOBAL_VALUE (name);\n-\t  else if (TREE_CODE (got_scope) == TEMPLATE_TYPE_PARM\n+\t  else if (TREE_CODE (type) == TEMPLATE_TYPE_PARM\n \t\t   /* TFIXME -- don't do this for UPTs in new model.  */\n-\t\t   || TREE_CODE (got_scope) == UNINSTANTIATED_P_TYPE)\n+\t\t   || TREE_CODE (type) == UNINSTANTIATED_P_TYPE)\n \t    {\n \t      if (prefer_type > 0)\n-\t\tval = create_nested_upt (got_scope, name);\n+\t\tval = create_nested_upt (type, name);\n \t      else\n \t\tval = NULL_TREE;\n \t    }\n-\t  else if (! IS_AGGR_TYPE (got_scope))\n+\t  else if (! IS_AGGR_TYPE (type))\n \t    /* Someone else will give an error about this if needed. */\n \t    val = NULL_TREE;\n-\t  else if (TYPE_BEING_DEFINED (got_scope))\n+\t  else if (TYPE_BEING_DEFINED (type))\n \t    {\n \t      val = IDENTIFIER_CLASS_VALUE (name);\n-\t      if (val && DECL_CONTEXT (val) != got_scope)\n+\t      if (val && DECL_CONTEXT (val) != type)\n \t\t{\n \t\t  struct binding_level *b = class_binding_level;\n \t\t  for (val = NULL_TREE; b; b = b->level_chain)\n \t\t    {\n \t\t      tree t = purpose_member (name, b->class_shadowed);\n \t\t      if (t && TREE_VALUE (t)\n-\t\t\t  && DECL_CONTEXT (TREE_VALUE (t)) == got_scope)\n+\t\t\t  && DECL_CONTEXT (TREE_VALUE (t)) == type)\n \t\t\t{\n \t\t\t  val = TREE_VALUE (t);\n \t\t\t  break;\n \t\t\t}\n \t\t    }\n \t\t}\n \t      if (val == NULL_TREE\n-\t\t  && CLASSTYPE_LOCAL_TYPEDECLS (got_scope))\n-\t\tval = lookup_field (got_scope, name, 0, 1);\n+\t\t  && CLASSTYPE_LOCAL_TYPEDECLS (type))\n+\t\tval = lookup_field (type, name, 0, 1);\n \t    }\n-\t  else if (got_scope == current_class_type)\n+\t  else if (type == current_class_type)\n \t    val = IDENTIFIER_CLASS_VALUE (name);\n \t  else\n-\t    val = lookup_field (got_scope, name, 0, 0);\n-\n-\t  goto done;\n+\t    val = lookup_field (type, name, 0, prefer_type);\n \t}\n+      else\n+\tval = NULL_TREE;\n+\n+      if (got_scope)\n+\tgoto done;\n+\n+      /* This special lookup only applies to types.  */\n+      else if (got_object && val && TREE_CODE (val) == TYPE_DECL)\n+\tfrom_obj = val;\n     }\n     \n   if (current_binding_level != global_binding_level\n@@ -3980,16 +4050,20 @@ lookup_name_real (name, prefer_type, nonclass)\n  done:\n   if (val)\n     {\n+      if (from_obj && from_obj != val)\n+\tcp_error (\"lookup in the scope of `%#T' does not match lookup in the current scope\",\n+\t\t  got_object);\n+\n       if ((TREE_CODE (val) == TEMPLATE_DECL && looking_for_template)\n \t  || TREE_CODE (val) == TYPE_DECL || prefer_type <= 0)\n-\treturn val;\n-\n-      if (IDENTIFIER_HAS_TYPE_VALUE (name))\n-\treturn TYPE_NAME (IDENTIFIER_TYPE_VALUE (name));\n-\n-      if (TREE_TYPE (val) == error_mark_node)\n-\treturn error_mark_node;\n+\t;\n+      else if (IDENTIFIER_HAS_TYPE_VALUE (name))\n+\tval = TYPE_NAME (IDENTIFIER_TYPE_VALUE (name));\n+      else if (TREE_TYPE (val) == error_mark_node)\n+\tval = error_mark_node;\n     }\n+  else if (from_obj)\n+    val = from_obj;\n \n   return val;\n }\n@@ -4031,7 +4105,7 @@ lookup_name_current_level (name)\n       while (1)\n \t{\n \t  for (t = b->names; t; t = TREE_CHAIN (t))\n-\t    if (DECL_NAME (t) == name)\n+\t    if (DECL_NAME (t) == name || DECL_ASSEMBLER_NAME (t) == name)\n \t      goto out;\n \t  if (b->keep == 2)\n \t    b = b->level_chain;\n@@ -4207,13 +4281,19 @@ init_decl_processing ()\n   int wchar_type_size;\n   tree temp;\n   tree array_domain_type;\n+  extern int flag_strict_prototype;\n \n   /* Have to make these distinct before we try using them.  */\n   lang_name_cplusplus = get_identifier (\"C++\");\n   lang_name_c = get_identifier (\"C\");\n \n-  if (flag_ansi || pedantic)\n-    strict_prototypes_lang_c = strict_prototypes_lang_cplusplus;\n+  if (flag_strict_prototype == 2)\n+    {\n+      if (pedantic)\n+\tstrict_prototypes_lang_c = strict_prototypes_lang_cplusplus;\n+    }\n+  else\n+    strict_prototypes_lang_c = flag_strict_prototype;\n \n   /* Initially, C.  */\n   current_lang_name = lang_name_c;\n@@ -5629,8 +5709,9 @@ grok_reference_init (decl, type, init, cleanupp)\n \n   if (init == NULL_TREE)\n     {\n-      if (DECL_LANG_SPECIFIC (decl) == 0\n-\t  || DECL_IN_AGGR_P (decl) == 0)\n+      if ((DECL_LANG_SPECIFIC (decl) == 0\n+\t   || DECL_IN_AGGR_P (decl) == 0)\n+\t  && ! DECL_THIS_EXTERN (decl))\n \t{\n \t  cp_error (\"`%D' declared as reference but not initialized\", decl);\n \t  if (TREE_CODE (decl) == VAR_DECL)\n@@ -6530,12 +6611,24 @@ complete_array_type (type, initial_value, do_default)\n       /* Note MAXINDEX  is really the maximum index,\n \t one less than the size.  */\n       if (TREE_CODE (initial_value) == STRING_CST)\n-\tmaxindex = build_int_2 (TREE_STRING_LENGTH (initial_value) - 1, 0);\n+\t{\n+\t  int eltsize\n+\t    = int_size_in_bytes (TREE_TYPE (TREE_TYPE (initial_value)));\n+\t  maxindex = build_int_2 ((TREE_STRING_LENGTH (initial_value)\n+\t\t\t\t   / eltsize) - 1, 0);\n+\t}\n       else if (TREE_CODE (initial_value) == CONSTRUCTOR)\n \t{\n-\t  register int nelts\n-\t    = list_length (CONSTRUCTOR_ELTS (initial_value));\n-\t  maxindex = build_int_2 (nelts - 1, - (nelts == 0));\n+\t  tree elts = CONSTRUCTOR_ELTS (initial_value);\n+\t  maxindex = size_binop (MINUS_EXPR, integer_zero_node, size_one_node);\n+\t  for (; elts; elts = TREE_CHAIN (elts))\n+\t    {\n+\t      if (TREE_PURPOSE (elts))\n+\t\tmaxindex = TREE_PURPOSE (elts);\n+\t      else\n+\t\tmaxindex = size_binop (PLUS_EXPR, maxindex, size_one_node);\n+\t    }\n+\t  maxindex = copy_node (maxindex);\n \t}\n       else\n \t{\n@@ -7281,6 +7374,14 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n   if (funcdef_flag && innermost_code != CALL_EXPR)\n     return 0;\n \n+  if (((dname && IDENTIFIER_OPNAME_P (dname)) || flags == TYPENAME_FLAG)\n+      && innermost_code != CALL_EXPR\n+      && ! (ctype && declspecs == NULL_TREE))\n+    {\n+      cp_error (\"declaration of `%D' as non-function\", dname);\n+      return void_type_node;\n+    }\n+\n   /* Anything declared one level down from the top level\n      must be one of the parameters of a function\n      (because the body is at least two levels down).  */\n@@ -7361,8 +7462,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t{\n \t\t  if (i == (int) RID_LONG && RIDBIT_SETP (i, specbits))\n \t\t    {\n-\t\t      if (pedantic && flag_ansi)\n-\t\t\tpedwarn (\"duplicate `long'\");\n+\t\t      if (pedantic && ! in_system_header)\n+\t\t\tpedwarn (\"ANSI C++ does not support `long long'\");\n \t\t      else if (longlong)\n \t\t\terror (\"`long long long' is too long for GCC\");\n \t\t      else\n@@ -7468,7 +7569,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n     }\n   else if (return_type == return_conversion)\n     {\n-      if (comp_target_types (type, ctor_return_type, 1) == 0)\n+      if (comptypes (type, ctor_return_type, 1) == 0)\n \tcp_error (\"operator `%T' declared to return `%T'\",\n \t\t  ctor_return_type, type);\n       else\n@@ -8022,7 +8123,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t  }\n \t\tif (TREE_READONLY_DECL_P (size))\n \t\t  size = decl_constant_value (size);\n-\t\tif (flag_ansi && integer_zerop (size))\n+\t\tif (pedantic && integer_zerop (size))\n \t\t  cp_pedwarn (\"ANSI C++ forbids zero-size array `%D'\", dname);\n \t\tif (TREE_CONSTANT (size))\n \t\t  {\n@@ -8037,7 +8138,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t  }\n \t\telse\n \t\t  {\n-\t\t    if (flag_ansi)\n+\t\t    if (pedantic)\n \t\t      {\n \t\t\tif (dname)\n \t\t\t  cp_pedwarn (\"ANSI C++ forbids variable-size array `%D'\",\n@@ -8384,9 +8485,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t  && (constp || volatilep))\n \t\t{\n \t\t  if (constp)\n-\t\t    warning (\"discarding `const' applied to a reference\");\n+\t\t    pedwarn (\"discarding `const' applied to a reference\");\n \t\t  if (volatilep)\n-\t\t    warning (\"discarding `volatile' applied to a reference\");\n+\t\t    pedwarn (\"discarding `volatile' applied to a reference\");\n \t\t  constp = volatilep = 0;\n \t\t}\n \t    }\n@@ -8956,7 +9057,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t   initialize the named nonstatic member....  This (or an\n \t\t   initializer list) is the only way to initialize\n \t\t   nonstatic const and reference members.  */\n-\t\telse if (flag_ansi || ! constp)\n+\t\telse if (pedantic || ! constp)\n \t\t  cp_pedwarn (\"ANSI C++ forbids initialization of %s `%D'\",\n \t\t\t      constp ? \"const member\" : \"member\", declarator);\n \t      }\n@@ -9103,7 +9204,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t    if (RIDBIT_SETP (RID_EXTERN, specbits))\n \t      {\n \t\tcurrent_extern_inline = 1;\n-\t\tif (flag_ansi)\n+\t\tif (pedantic)\n \t\t  pedwarn (\"ANSI C++ does not permit `extern inline'\");\n \t      }\n \t  }\n@@ -9450,12 +9551,19 @@ grokparms (first_parm, funcdef_flag)\n \t\t\t}\n \t\t      else\n \t\t\tinit = require_instantiated_type (type, init, integer_zero_node);\n+\n+\t\t      init = convert_for_initialization\n+\t\t\t(NULL_TREE, type, init, LOOKUP_NORMAL,\n+\t\t\t \"argument passing\", 0, 0);\n \t\t    }\n+#if 0 /* This is too early to check; trailing parms might be merged in by\n+\t duplicate_decls.  */\n \t\t  else if (any_init)\n \t\t    {\n \t\t      error (\"all trailing parameters must have default arguments\");\n \t\t      any_error = 1;\n \t\t    }\n+#endif\n \t\t}\n \t      else\n \t\tinit = NULL_TREE;\n@@ -11042,7 +11150,7 @@ store_return_init (return_id, init)\n {\n   tree decl = DECL_RESULT (current_function_decl);\n \n-  if (flag_ansi)\n+  if (pedantic)\n     /* Give this error as many times as there are occurrences,\n        so that users can use Emacs compilation buffers to find\n        and fix all such places.  */\n@@ -11539,45 +11647,11 @@ finish_function (lineno, call_poplevel, nested)\n   /* So we can tell if jump_optimize sets it to 1.  */\n   can_reach_end = 0;\n \n-  if (DECL_EXTERNAL (fndecl)\n-      /* This function is just along for the ride.  If we can make\n-\t it inline, that's great.  Otherwise, just punt it.  */\n-      && (DECL_INLINE (fndecl) == 0\n-\t  || flag_no_inline\n-\t  || function_cannot_inline_p (fndecl)\n-\t  /* ??? Compensate for Sun brain damage in dealing with\n-\t     data segments of PIC code.  */\n-\t  || (flag_pic\n-\t      && (DECL_CONSTRUCTOR_P (fndecl)\n-\t\t  || DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fndecl)))\n-\t      && CLASSTYPE_NEEDS_VIRTUAL_REINIT (TYPE_METHOD_BASETYPE (fntype)))))\n-\n-    {\n-      extern int rtl_dump_and_exit;\n-      int old_rtl_dump_and_exit = rtl_dump_and_exit;\n-      int inline_spec = DECL_INLINE (fndecl);\n-\n-      /* This throws away the code for FNDECL.  */\n-      rtl_dump_and_exit = 1;\n-      /* This throws away the memory of the code for FNDECL.  */\n-      if (flag_no_inline)\n-\tDECL_INLINE (fndecl) = 0;\n-      rest_of_compilation (fndecl);\n-      rtl_dump_and_exit = old_rtl_dump_and_exit;\n-      DECL_INLINE (fndecl) = inline_spec;\n-    }\n-  else\n-    {\n-      /* Run the optimizers and output the assembler code for this\n-         function.  */\n-      rest_of_compilation (fndecl);\n-    }\n+  /* Run the optimizers and output the assembler code for this function.  */\n+  rest_of_compilation (fndecl);\n \n-  if (DECL_INLINE (fndecl) && !TREE_ASM_WRITTEN (fndecl)\n-      && DECL_DEFER_OUTPUT (fndecl))\n-    {\n-      mark_inline_for_output (fndecl);\n-    }\n+  if (DECL_DEFER_OUTPUT (fndecl))\n+    mark_inline_for_output (fndecl);\n \n   if (ctype && TREE_ASM_WRITTEN (fndecl))\n     note_debug_info_needed (ctype);\n@@ -11628,6 +11702,11 @@ finish_function (lineno, call_poplevel, nested)\n \tDECL_ARGUMENTS (fndecl) = NULL_TREE;\n     }\n \n+  if (DECL_STATIC_CONSTRUCTOR (fndecl))\n+    static_ctors = perm_tree_cons (NULL_TREE, fndecl, static_ctors);\n+  if (DECL_STATIC_DESTRUCTOR (fndecl))\n+    static_dtors = perm_tree_cons (NULL_TREE, fndecl, static_dtors);\n+\n   /* Let the error reporting routines know that we're outside a function.  */\n   current_function_decl = NULL_TREE;\n   named_label_uses = NULL_TREE;"}, {"sha": "127e6b2cd925e1ee678c8d49d44e930846578802", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 48, "deletions": 20, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "patch": "@@ -64,6 +64,10 @@ static int global_temp_name_counter;\n /* Flag used when debugging spew.c */\n \n extern int spew_debug;\n+\n+/* Functions called along with real static constructors and destructors.  */\n+\n+tree static_ctors, static_dtors;\n \f\n /* C (and C++) language-specific option variables.  */\n \n@@ -80,6 +84,10 @@ int flag_short_double;\n \n int flag_no_asm;\n \n+/* Nonzero means don't recognize any extension keywords.  */\n+\n+int flag_no_gnu_keywords;\n+\n /* Nonzero means don't recognize the non-ANSI builtin functions.  */\n \n int flag_no_builtin;\n@@ -99,11 +107,12 @@ int flag_signed_bitfields = 1;\n \n /* Nonzero means handle `#ident' directives.  0 means ignore them.  */\n \n-int flag_no_ident = 0;\n+int flag_no_ident;\n \n-/* Nonzero means disable GNU extensions.  */\n+/* Nonzero means enable obscure ANSI features and disable GNU extensions\n+   that might cause ANSI-compliant code to be miscompiled.  */\n \n-int flag_ansi = 0;\n+int flag_ansi;\n \n /* Nonzero means do emit exported implementations of functions even if\n    they can be inlined.  */\n@@ -113,13 +122,13 @@ int flag_implement_inlines = 1;\n /* Nonzero means do emit exported implementations of templates, instead of\n    multiple static copies in each file that needs a definition. */\n \n-int flag_external_templates = 0;\n+int flag_external_templates;\n \n /* Nonzero means that the decision to emit or not emit the implementation of a\n    template depends on where the template is instantiated, rather than where\n    it is defined.  */\n \n-int flag_alt_external_templates = 0;\n+int flag_alt_external_templates;\n \n /* Nonzero means that implicit instantiations will be emitted if needed.  */\n \n@@ -139,7 +148,7 @@ int warn_ctor_dtor_privacy = 1;\n \n    Also causes output of vtables to be controlled by whether\n    we seen the class's first non-inline virtual function. */\n-int flag_vtable_thunks = 0;\n+int flag_vtable_thunks;\n \n /* Nonzero means give string constants the type `const char *'\n    to get extra warnings from them.  These warnings will be too numerous\n@@ -198,7 +207,7 @@ int warn_conversion;\n \n /* Warn if adding () is suggested.  */\n \n-int warn_parentheses = 1;\n+int warn_parentheses;\n \n /* Non-zero means warn in function declared in derived class has the\n    same name as a virtual in the base class, but fails to match the\n@@ -229,6 +238,7 @@ int dollars_in_ident = DOLLARS_IN_IDENTIFIERS;\n /* Nonzero for -fno-strict-prototype switch: do not consider empty\n    argument prototype to mean function takes no arguments.  */\n \n+int flag_strict_prototype = 2;\n int strict_prototype = 1;\n int strict_prototypes_lang_c, strict_prototypes_lang_cplusplus = 1;\n \n@@ -303,7 +313,7 @@ int flag_gc;\n \n /* Controls whether compiler generates 'type descriptor' that give\n    run-time type information.  */\n-int flag_rtti = 0;\n+int flag_rtti;\n \n /* Nonzero if we wish to output cross-referencing information\n    for the GNU class browser.  */\n@@ -319,21 +329,28 @@ extern int flag_gnu_xref;\n    In general, it is `reasonable' to assume that for many programs,\n    and better code can be generated in that case.  */\n \n-int flag_assume_nonnull_objects;\n+int flag_assume_nonnull_objects = 1;\n \n /* Nonzero if we want to support huge (> 2^(sizeof(short)*8-1) bytes)\n    objects. */\n+\n int flag_huge_objects;\n \n /* Nonzero if we want to conserve space in the .o files.  We do this\n    by putting uninitialized data and runtime initialized data into\n    .common instead of .data at the expense of not flaging multiple\n    definitions.  */\n+\n int flag_conserve_space;\n \n /* Nonzero if we want to obey access control semantics.  */\n+\n int flag_access_control = 1;\n \n+/* Nonzero if we want to understand the operator names, i.e. 'bitand'.  */\n+\n+int flag_operator_names;\n+\n /* Table of language-dependent -f options.\n    STRING is the option name.  VARIABLE is the address of the variable.\n    ON_VALUE is the value to store in VARIABLE\n@@ -355,7 +372,7 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"labels-ok\", &flag_labels_ok, 1},\n   {\"stats\", &flag_detailed_statistics, 1},\n   {\"this-is-variable\", &flag_this_is_variable, 1},\n-  {\"strict-prototype\", &strict_prototypes_lang_cplusplus, 1},\n+  {\"strict-prototype\", &flag_strict_prototype, 1},\n   {\"all-virtual\", &flag_all_virtual, 1},\n   {\"memoize-lookups\", &flag_memoize_lookups, 1},\n   {\"elide-constructors\", &flag_elide_constructors, 1},\n@@ -376,7 +393,9 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"vtable-thunks\", &flag_vtable_thunks, 1},\n   {\"short-temps\", &flag_short_temps, 1},\n   {\"access-control\", &flag_access_control, 1},\n-  {\"nonansi-builtins\", &flag_no_nonansi_builtin, 0}\n+  {\"nonansi-builtins\", &flag_no_nonansi_builtin, 0},\n+  {\"gnu-keywords\", &flag_no_gnu_keywords, 0},\n+  {\"operator-names\", &flag_operator_names, 1}\n };\n \n /* Decode the string P as a language-specific option.\n@@ -552,6 +571,7 @@ lang_decode_option (p)\n \t  warn_ctor_dtor_privacy = setting;\n \t  warn_switch = setting;\n \t  warn_format = setting;\n+\t  warn_parentheses = setting;\n \t  warn_missing_braces = setting;\n \t  warn_extern_inline = setting;\n \t  warn_nonvdtor = setting;\n@@ -569,8 +589,8 @@ lang_decode_option (p)\n       else return 0;\n     }\n   else if (!strcmp (p, \"-ansi\"))\n-    flag_no_asm = 1, dollars_in_ident = 0, flag_no_nonansi_builtin = 1,\n-    flag_ansi = 1;\n+    dollars_in_ident = 0, flag_no_nonansi_builtin = 1, flag_ansi = 1,\n+    flag_no_gnu_keywords = 1, flag_operator_names = 1;\n #ifdef SPEW_DEBUG\n   /* Undocumented, only ever used when you're invoking cc1plus by hand, since\n      it's probably safe to assume no sane person would ever want to use this\n@@ -2674,10 +2694,10 @@ finish_file ()\n      we'll need here.  */\n   push_lang_context (lang_name_c);\n \n-  /* Set up the name of the file-level functions we may need.  */\n-  /* Use a global object (which is already required to be unique over\n-     the program) rather than the file name (which imposes extra\n-     constraints).  -- Raeburn@MIT.EDU, 10 Jan 1990.  */\n+  if (static_ctors || vars || have_exception_handlers)\n+    needs_messing_up = 1;\n+  if (static_dtors)\n+    needs_cleaning = 1;\n \n   /* See if we really need the hassle.  */\n   while (vars && needs_cleaning == 0)\n@@ -2740,6 +2760,10 @@ finish_file ()\n       vars = TREE_CHAIN (vars);\n     }\n \n+  for (; static_dtors; static_dtors = TREE_CHAIN (static_dtors))\n+    expand_expr_stmt (build_function_call (TREE_VALUE (static_dtors),\n+\t\t\t\t\t   NULL_TREE));\n+      \n   expand_end_bindings (getdecls(), 1, 0);\n   poplevel (1, 0, 0);\n   pop_momentary ();\n@@ -2753,7 +2777,7 @@ finish_file ()\n  mess_up:\n   /* Must do this while we think we are at the top level.  */\n   vars = nreverse (static_aggregates);\n-  if (vars != NULL_TREE || have_exception_handlers)\n+  if (needs_messing_up)\n     {\n       fnname = get_file_function_name ('I');\n       start_function (void_list_node, build_parse_node (CALL_EXPR, fnname, void_list_node, NULL_TREE), 0, 0);\n@@ -2797,6 +2821,7 @@ finish_file ()\n \t\t the same acess rights as a member function.  */\n \t      DECL_CLASS_CONTEXT (current_function_decl) = DECL_CONTEXT (decl);\n \n+#if 0\n \t      if (init)\n \t\t{\n \t\t  if (TREE_CODE (init) == VAR_DECL)\n@@ -2815,7 +2840,6 @@ finish_file ()\n \t\t\t      && CONSTRUCTOR_ELTS (init) == NULL_TREE)\n \t\t\t    init = NULL_TREE;\n \t\t\t}\n-#if 0\n \t\t      else if (TREE_TYPE (decl) == TREE_TYPE (init))\n \t\t\t{\n #if 1\n@@ -2828,9 +2852,9 @@ finish_file ()\n \t\t\t  init = DECL_INITIAL (init);\n #endif\t\t\t\t/* 1 */\n \t\t\t}\n-#endif\t\t\t\t/* 0 */\n \t\t    }\n \t\t}\n+#endif\t\t\t\t/* 0 */\n \t      if (IS_AGGR_TYPE (TREE_TYPE (decl))\n \t\t  || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n \t\texpand_aggr_init (decl, init, 0, 0);\n@@ -2865,6 +2889,10 @@ finish_file ()\n \t  expand_cleanups_to (old_cleanups);\n \t}\n \n+      for (; static_ctors; static_ctors = TREE_CHAIN (static_ctors))\n+\texpand_expr_stmt (build_function_call (TREE_VALUE (static_ctors),\n+\t\t\t\t\t       NULL_TREE));\n+      \n       expand_end_bindings (getdecls(), 1, 0);\n       poplevel (1, 0, 0);\n       pop_momentary ();"}, {"sha": "1490f6fa191fbcfd441ddaff4562e7a8851c5ff9", "filename": "gcc/cp/except.c", "status": "modified", "additions": 94, "deletions": 8, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "patch": "@@ -43,7 +43,12 @@ tree builtin_return_address_fndecl;\n #define TRY_NEW_EH\n #endif\n #endif\n-#if defined(__i386) || defined(__rs6000) || defined(__hppa) || defined(__mc68000) || defined (__mips)\n+#ifdef _IBMR2\n+#ifndef __rs6000\n+#define __rs6000\n+#endif\n+#endif\n+#if defined(__i386) || defined(__rs6000) || defined(__hppa) || defined(__mc68000) || defined (__mips) || defined (__arm)\n #define TRY_NEW_EH\n #endif\n #endif\n@@ -123,6 +128,16 @@ expand_throw (exp)\n \n #else\n \n+/* Make 'label' the first numbered label of the current function */\n+void\n+make_first_label(label)\n+     rtx label;\n+{\n+  if (CODE_LABEL_NUMBER(label) < get_first_label_num())\n+    set_new_first_and_last_label_num (CODE_LABEL_NUMBER(label),\n+\t\t\t\t      max_label_num());\n+}\n+\n static int\n doing_eh (do_warn)\n      int do_warn;\n@@ -236,9 +251,16 @@ void\n exception_section ()\n {\n #ifdef ASM_OUTPUT_SECTION_NAME\n-  named_section (\".gcc_except_table\");\n+  named_section (NULL_TREE, \".gcc_except_table\");\n+#else\n+  if (flag_pic)\n+    data_section ();\n+  else\n+#if defined(__rs6000)\n+    data_section ();\n #else\n-  text_section ();\n+    readonly_data_section ();\n+#endif\n #endif\n }\n \n@@ -576,6 +598,10 @@ push_eh_entry (stack)\n   entry->exception_handler_label = gen_label_rtx ();\n   pop_rtl_from_perm ();\n \n+  LABEL_PRESERVE_P (entry->start_label) = 1;\n+  LABEL_PRESERVE_P (entry->end_label) = 1;\n+  LABEL_PRESERVE_P (entry->exception_handler_label) = 1;\n+\n   entry->finalization = NULL_TREE;\n \n   node->entry = entry;\n@@ -794,9 +820,9 @@ init_exception_processing ()\n   saved_throw_value = gen_rtx (REG, Pmode, 5);\n #endif\n #ifdef __rs6000\n-  saved_pc = gen_rtx (REG, Pmode, 12);\n-  saved_throw_type = gen_rtx (REG, Pmode, 13);\n-  saved_throw_value = gen_rtx (REG, Pmode, 14);\n+  saved_pc = gen_rtx (REG, Pmode, 13);\n+  saved_throw_type = gen_rtx (REG, Pmode, 14);\n+  saved_throw_value = gen_rtx (REG, Pmode, 15);\n #endif\n #ifdef __hppa\n   saved_pc = gen_rtx (REG, Pmode, 5);\n@@ -812,6 +838,11 @@ init_exception_processing ()\n   saved_pc = gen_rtx (REG, Pmode, 16);\n   saved_throw_type = gen_rtx (REG, Pmode, 17);\n   saved_throw_value = gen_rtx (REG, Pmode, 18);\n+#endif\n+#ifdef __arm\n+  saved_pc = gen_rtx (REG, Pmode, 7);\n+  saved_throw_type = gen_rtx (REG, Pmode, 8);\n+  saved_throw_value = gen_rtx (REG, Pmode, 9);\n #endif\n   new_eh_queue (&ehqueue);\n   new_eh_queue (&eh_table_output_queue);\n@@ -958,7 +989,13 @@ expand_start_all_catch ()\n   entry->end_label = gen_label_rtx ();\n   entry->exception_handler_label = gen_label_rtx ();\n   entry->finalization = TerminateFunctionCall;\n+  assemble_external (TREE_OPERAND (Terminate, 0));\n   pop_rtl_from_perm ();\n+\n+  LABEL_PRESERVE_P (entry->start_label) = 1;\n+  LABEL_PRESERVE_P (entry->end_label) = 1;\n+  LABEL_PRESERVE_P (entry->exception_handler_label) = 1;\n+\n   emit_label (entry->end_label);\n \n   enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (entry));\n@@ -969,6 +1006,7 @@ expand_start_all_catch ()\n   /* Will this help us not stomp on it? */\n   emit_insn (gen_rtx (USE, VOIDmode, saved_throw_type));\n   emit_insn (gen_rtx (USE, VOIDmode, saved_throw_value));\n+  make_first_label(throw_label);\n   emit_jump (throw_label);\n   emit_label (entry->exception_handler_label);\n   expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n@@ -992,6 +1030,7 @@ expand_end_all_catch ()\n   emit_move_insn (saved_pc, gen_rtx (LABEL_REF,\n \t\t\t\t     Pmode,\n \t\t\t\t     top_label_entry (&caught_return_label_stack)));\n+  make_first_label(throw_label);\n   emit_jump (throw_label);\n \n   /* Find the start of the catch block.  */\n@@ -1052,7 +1091,13 @@ expand_leftover_cleanups ()\n       entry.end_label = label;\n       entry.exception_handler_label = gen_label_rtx ();\n       entry.finalization = TerminateFunctionCall;\n+      assemble_external (TREE_OPERAND (Terminate, 0));\n       pop_rtl_from_perm ();\n+\n+      LABEL_PRESERVE_P (entry.start_label) = 1;\n+      LABEL_PRESERVE_P (entry.end_label) = 1;\n+      LABEL_PRESERVE_P (entry.exception_handler_label) = 1;\n+\n       emit_label (label);\n \n       enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (&entry));\n@@ -1063,6 +1108,7 @@ expand_leftover_cleanups ()\n       /* Will this help us not stomp on it? */\n       emit_insn (gen_rtx (USE, VOIDmode, saved_throw_type));\n       emit_insn (gen_rtx (USE, VOIDmode, saved_throw_value));\n+      make_first_label(throw_label);\n       emit_jump (throw_label);\n       emit_label (entry.exception_handler_label);\n       expand_expr (entry.finalization, const0_rtx, VOIDmode, 0);\n@@ -1143,6 +1189,7 @@ expand_start_catch_block (declspecs, declarator)\n \t\t\t\t    NULL_TREE));\n       catch_match_fcall = build_function_call (CatchMatch, params);\n       call_rtx = expand_call (catch_match_fcall, NULL_RTX, 0);\n+      assemble_external (TREE_OPERAND (CatchMatch, 0));\n \n       return_value_rtx =\n \thard_function_value (integer_type_node, catch_match_fcall);\n@@ -1192,6 +1239,7 @@ void expand_end_catch_block ()\n       emit_move_insn (saved_pc, gen_rtx (LABEL_REF,\n \t\t\t\t\t Pmode,\n \t\t\t\t\t top_label_entry (&caught_return_label_stack)));\n+      make_first_label(throw_label);\n       emit_jump (throw_label);\n       /* No associated finalization.  */\n       entry.finalization = NULL_TREE;\n@@ -1210,6 +1258,10 @@ void expand_end_catch_block ()\n       entry.start_label = start_protect_label_rtx;\n       entry.end_label = end_protect_label_rtx;\n \n+      LABEL_PRESERVE_P (entry.start_label) = 1;\n+      LABEL_PRESERVE_P (entry.end_label) = 1;\n+      LABEL_PRESERVE_P (entry.exception_handler_label) = 1;\n+\n       /* These set up a call to throw the caught exception into the outer\n        context.  */\n       enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (&entry));\n@@ -1279,6 +1331,7 @@ do_unwind (throw_label)\n \t\t\t\t\t    gen_rtx (LABEL_REF, Pmode, throw_label)), NULL_TREE);\n   \n   do_function_call (Unwind, params, NULL_TREE);\n+  assemble_external (TREE_OPERAND (Unwind, 0));\n   emit_barrier ();\n #endif\n #if m88k\n@@ -1304,9 +1357,18 @@ do_unwind (throw_label)\n \t\t\t\t\t\t     (HOST_WIDE_INT)m88k_debugger_offset (arg_pointer_rtx, 0))));\n #endif\n #endif\n+#ifdef __arm\n+  if (flag_omit_frame_pointer)\n+    sorry (\"this implementation of exception handling requires a frame pointer\");\n+\n+  emit_move_insn (stack_pointer_rtx,\n+\t\t  gen_rtx (MEM, SImode, plus_constant (hard_frame_pointer_rtx, -8)));\n+  emit_move_insn (hard_frame_pointer_rtx,\n+\t\t  gen_rtx (MEM, SImode, plus_constant (hard_frame_pointer_rtx, -12)));\n+#endif\n }\n \n-/* is called from expand_excpetion_blocks () to generate the code in a function\n+/* is called from expand_exception_blocks () to generate the code in a function\n    to \"throw\" if anything in the function needs to preform a throw.\n \n    expands \"throw\" as the following psuedo code:\n@@ -1333,12 +1395,14 @@ expand_builtin_throw ()\n   rtx unwind_and_throw = gen_label_rtx ();\n   rtx goto_unwind_and_throw = gen_label_rtx ();\n \n+  make_first_label(throw_label);\n   emit_label (throw_label);\n \n   /* search for an exception handler for the saved_pc */\n   return_val_rtx = do_function_call (FirstExceptionMatch,\n \t\t\t\t     tree_cons (NULL_TREE, make_tree (ptr_type_node, saved_pc), NULL_TREE),\n \t\t\t\t     ptr_type_node);\n+  assemble_external (TREE_OPERAND (FirstExceptionMatch, 0));\n \n   /* did we find one? */\n   emit_cmp_insn (return_val_rtx, const0_rtx, EQ, NULL_RTX,\n@@ -1354,30 +1418,51 @@ expand_builtin_throw ()\n   emit_label (gotta_rethrow_it);\n \n   /* call to  __builtin_return_address () */\n+#ifdef __arm\n+/* This replaces a 'call' to __builtin_return_address */\n+  return_val_rtx = gen_reg_rtx (Pmode);\n+  emit_move_insn (return_val_rtx, gen_rtx (MEM, SImode, plus_constant (hard_frame_pointer_rtx, -4)));\n+#else\n   params=tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n   fcall = build_function_call (BuiltinReturnAddress, params);\n   return_val_rtx = expand_expr (fcall, NULL_RTX, SImode, 0);\n+#endif\n \n   /* did __builtin_return_address () return a valid address? */\n   emit_cmp_insn (return_val_rtx, const0_rtx, EQ, NULL_RTX,\n \t\t GET_MODE (return_val_rtx), 0, 0);\n \n   emit_jump_insn (gen_beq (gotta_call_terminate));\n \n+#ifdef __arm\n+  /* On the ARM, '__builtin_return_address',  must have 4\n+     subtracted from it. */\n+  emit_insn (gen_add2_insn (return_val_rtx, GEN_INT (-4)));\n+\n+  /* If we are generating code for an ARM2/ARM3 machine or for an ARM6 in 26 bit\n+     mode, the condition codes must be masked out of the return value, or else\n+     they will confuse BuiltinReturnAddress.  This does not apply to ARM6 and\n+     later processors when running in 32 bit mode. */\n+  if (!TARGET_6)\n+    emit_insn (gen_rtx (SET, SImode, return_val_rtx, gen_rtx (AND, SImode, return_val_rtx, GEN_INT (0x03fffffc))));\n+#else\n #ifndef sparc\n   /* On the SPARC, __builtin_return_address is already -8, no need to\n      subtract any more from it. */\n   emit_insn (gen_add2_insn (return_val_rtx, GEN_INT (-1)));\n+#endif\n #endif\n \n   /* yes it did */\n   emit_move_insn (saved_pc, return_val_rtx);\n   do_unwind (throw_label);\n+  make_first_label(throw_label);\n   emit_jump (throw_label);\n \n   /* no it didn't --> therefore we need to call terminate */\n   emit_label (gotta_call_terminate);\n   do_function_call (Terminate, NULL_TREE, NULL_TREE);\n+  assemble_external (TREE_OPERAND (Terminate, 0));\n }\n \n \n@@ -1424,7 +1509,7 @@ expand_exception_blocks ()\n \n \t1. Allocate space to save the current PC onto the stack.\n \t2. Generate and emit a label and save its address into the\n-\t\tnewly allocate stack space since we can't save the pc directly.\n+\t\tnewly allocated stack space since we can't save the pc directly.\n \t3. If this is the first call to throw in this function:\n \t\tgenerate a label for the throw block\n \t4. jump to the throw block label.  */\n@@ -1476,6 +1561,7 @@ expand_throw (exp)\n       /* This part is easy, as we dont' have to do anything else.  */\n     }\n \n+  make_first_label(throw_label);\n   emit_jump (throw_label);\n }\n "}, {"sha": "1e37d3f4ce3227ef6c1bd19d671daefd68c98af1", "filename": "gcc/cp/gxx.gperf", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fgxx.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fgxx.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxx.gperf?ref=e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "patch": "@@ -19,8 +19,10 @@ __headof__, HEADOF, NORID\n __inline, SCSPEC, RID_INLINE\n __inline__, SCSPEC, RID_INLINE\n __label__, LABEL, NORID\n+__signature__, AGGR, RID_SIGNATURE\t/* Extension */,\n __signed, TYPESPEC, RID_SIGNED\n __signed__, TYPESPEC, RID_SIGNED\n+__sigof__, SIGOF, NORID\t\t/* Extension */,\n __typeof, TYPEOF, NORID\n __typeof__, TYPEOF, NORID\n __volatile, TYPE_QUAL, RID_VOLATILE"}, {"sha": "8a73e7ced1006797388ca69b0e65cbc741fcb6cc", "filename": "gcc/cp/init.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "patch": "@@ -2376,9 +2376,9 @@ add_friend (type, decl)\n \t    {\n \t      if (decl == TREE_VALUE (friends))\n \t\t{\n-\t\t  cp_pedwarn (\"`%D' is already a friend of class `%T'\",\n+\t\t  cp_warning (\"`%D' is already a friend of class `%T'\",\n \t\t\t      decl, type);\n-\t\t  cp_pedwarn_at (\"previous friend declaration of `%D'\",\n+\t\t  cp_warning_at (\"previous friend declaration of `%D'\",\n \t\t\t\t TREE_VALUE (friends));\n \t\t  return;\n \t\t}\n@@ -2948,12 +2948,15 @@ build_new (placement, decl, init, use_global_new)\n   else\n     size = size_in_bytes (type);\n \n+  if (true_type == void_type_node)\n+    {\n+      error (\"invalid type for new: `void'\");\n+      return error_mark_node;\n+    }\n+\n   if (TYPE_SIZE (true_type) == 0)\n     {\n-      if (true_type == void_type_node)\n-\terror (\"invalid type for new: `void'\");\n-      else\n-\tincomplete_type_error (0, true_type);\n+      incomplete_type_error (0, true_type);\n       return error_mark_node;\n     }\n "}, {"sha": "09424b092277301e3fe08e840779dcbfd0b23374", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "patch": "@@ -403,6 +403,8 @@ void\n init_lex ()\n {\n   extern char *(*decl_printable_name) ();\n+  extern int flag_no_gnu_keywords;\n+  extern int flag_operator_names;\n \n   int i;\n \n@@ -788,23 +790,21 @@ init_lex ()\n     }\n #endif\n \n-  if (! (flag_gc || flag_rtti))\n+  if (! (flag_gc || flag_rtti) || flag_no_gnu_keywords)\n     {\n       UNSET_RESERVED_WORD (\"classof\");\n       UNSET_RESERVED_WORD (\"headof\");\n     }\n-  if (! flag_handle_signatures)\n+  if (! flag_handle_signatures || flag_no_gnu_keywords)\n     {\n       /* Easiest way to not recognize signature\n \t handling extensions...  */\n       UNSET_RESERVED_WORD (\"signature\");\n       UNSET_RESERVED_WORD (\"sigof\");\n     }\n-  if (flag_no_asm)\n-    UNSET_RESERVED_WORD (\"asm\");\n-  if (flag_no_asm || flag_traditional)\n+  if (flag_no_asm || flag_no_gnu_keywords)\n     UNSET_RESERVED_WORD (\"typeof\");\n-  if (!flag_ansi)\n+  if (! flag_operator_names)\n     {\n       /* These are new ANSI keywords that may break code.  */\n       UNSET_RESERVED_WORD (\"and\");\n@@ -815,6 +815,8 @@ init_lex ()\n       UNSET_RESERVED_WORD (\"or\");\n       UNSET_RESERVED_WORD (\"xor\");\n     }\n+  if (! flag_traditional)\n+    UNSET_RESERVED_WORD (\"overload\");\n \n   token_count = init_parse ();\n   interface_unknown = 1;\n@@ -4211,7 +4213,7 @@ real_yylex ()\n \t\t  goto tryagain;\n \t\tif (width < HOST_BITS_PER_INT\n \t\t    && (unsigned) c >= (1 << width))\n-\t\t  pedwarn (\"escape sequence out of range for character\");\n+\t\t  warning (\"escape sequence out of range for character\");\n #ifdef MAP_CHARACTER\n \t\tif (isprint (c))\n \t\t  c = MAP_CHARACTER (c);\n@@ -4328,7 +4330,7 @@ real_yylex ()\n \t\tif (!wide_flag\n \t\t    && TYPE_PRECISION (char_type_node) < HOST_BITS_PER_INT\n \t\t    && c >= ((unsigned) 1 << TYPE_PRECISION (char_type_node)))\n-\t\t  pedwarn (\"escape sequence out of range for character\");\n+\t\t  warning (\"escape sequence out of range for character\");\n \t      }\n \t    else if (c == '\\n')\n \t      {\n@@ -4483,7 +4485,7 @@ real_yylex ()\n \t    }\n \telse if ((c == '-') && (c1 == '>'))\n \t  {\n-\t    nextchar = skip_white_space (getch ());\n+\t    nextchar = getch ();\n \t    if (nextchar == '*')\n \t      {\n \t\tnextchar = -1;\n@@ -4510,11 +4512,22 @@ real_yylex ()\n \t\tvalue = MIN_MAX;\n \t\tnextchar = c1;\n \t      }\n-\t    if (flag_ansi)\n+\t    if (pedantic)\n \t      pedwarn (\"use of `operator %s' is not standard C++\",\n \t\t       token_buffer);\n \t    goto done;\n \t  }\n+\t/* digraphs */\n+\telse if (c == '<' && c1 == '%')\n+\t  { value = '{'; goto done; }\n+\telse if (c == '<' && c1 == ':')\n+\t  { value = '['; goto done; }\n+\telse if (c == '%' && c1 == '>')\n+\t  { value = '}'; goto done; }\n+\telse if (c == '%' && c1 == ':')\n+\t  { value = '#'; goto done; }\n+\telse if (c == ':' && c1 == '>')\n+\t  { value = ']'; goto done; }\n \n \tnextchar = c1;\n \ttoken_buffer[1] = 0;"}, {"sha": "816aacd1d6a1593d33117a90bc339c2d3214e9fd", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "patch": "@@ -123,6 +123,7 @@ extern int looking_for_template;\n \n /* Tell the lexer where to look for names.  */\n extern tree got_scope;\n+extern tree got_object;\n \n /* Pending language change.\n    Positive is push count, negative is pop count.  */"}, {"sha": "882c2fdf70cc213a35800e8c9866532885c403fc", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "patch": "@@ -1246,7 +1246,8 @@ expr_no_commas:\n \t| expr_no_commas '?' xexpr ':' expr_no_commas\n \t\t{ $$ = build_x_conditional_expr ($$, $3, $5); }\n \t| expr_no_commas '=' expr_no_commas\n-\t\t{ $$ = build_modify_expr ($$, NOP_EXPR, $3); }\n+\t\t{ $$ = build_modify_expr ($$, NOP_EXPR, $3);\n+                  C_SET_EXP_ORIGINAL_CODE ($$, MODIFY_EXPR); }\n \t| expr_no_commas ASSIGN expr_no_commas\n \t\t{ register tree rval;\n \t\t  if ((rval = build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL, $$, $3,\n@@ -1333,7 +1334,12 @@ primary:\n \t| string\n \t\t{ $$ = combine_strings ($$); }\n \t| '(' expr ')'\n-\t\t{ $$ = $2; }\n+\t\t{ char class = TREE_CODE_CLASS (TREE_CODE ($2));\n+\t\t  if (class == 'e' || class == '1'\n+\t\t      || class == '2' || class == '<')\n+                    /* This inhibits warnings in truthvalue_conversion. */\n+\t\t    C_SET_EXP_ORIGINAL_CODE ($2, ERROR_MARK);\n+\t\t  $$ = $2; }\n \t| '(' error ')'\n \t\t{ $$ = error_mark_node; }\n \t| '('\n@@ -1538,11 +1544,14 @@ primary:\n \t| overqualified_id LEFT_RIGHT\n \t\t{ $$ = build_member_call (OP0 ($$), OP1 ($$), NULL_TREE); }\n \t| object unqualified_id  %prec UNARY\n-\t\t{ $$ = build_component_ref ($$, $2, NULL_TREE, 1); }\n+\t\t{ got_object = NULL_TREE;\n+\t\t  $$ = build_component_ref ($$, $2, NULL_TREE, 1); }\n \t| object qualified_id %prec UNARY\n-\t\t{ $$ = build_object_ref ($$, OP0 ($2), OP1 ($2)); }\n+\t\t{ got_object = NULL_TREE;\n+\t\t  $$ = build_object_ref ($$, OP0 ($2), OP1 ($2)); }\n \t| object unqualified_id '(' nonnull_exprlist ')'\n \t\t{\n+\t\t  got_object = NULL_TREE;\n #if 0\n \t\t  /* This is a future direction of this code, but because\n \t\t     build_x_function_call cannot always undo what is done\n@@ -1558,6 +1567,7 @@ primary:\n \t\t}\n \t| object unqualified_id LEFT_RIGHT\n \t\t{\n+\t\t  got_object = NULL_TREE;\n #if 0\n \t\t  /* This is a future direction of this code, but because\n \t\t     build_x_function_call cannot always undo what is done\n@@ -1573,6 +1583,7 @@ primary:\n \t\t}\n \t| object qualified_id '(' nonnull_exprlist ')'\n \t\t{\n+\t\t  got_object = NULL_TREE;\n \t\t  if (IS_SIGNATURE (IDENTIFIER_TYPE_VALUE (OP0 ($2))))\n \t\t    {\n \t\t      warning (\"signature name in scope resolution ignored\");\n@@ -1584,6 +1595,7 @@ primary:\n \t\t}\n \t| object qualified_id LEFT_RIGHT\n \t\t{\n+\t\t  got_object = NULL_TREE;\n \t\t  if (IS_SIGNATURE (IDENTIFIER_TYPE_VALUE (OP0 ($2))))\n \t\t    {\n \t\t      warning (\"signature name in scope resolution ignored\");\n@@ -1595,21 +1607,28 @@ primary:\n \t\t}\n \t/* p->int::~int() is valid -- 12.4 */\n \t| object '~' TYPESPEC LEFT_RIGHT\n-\t\t{ \n+\t\t{\n+\t\t  got_object = NULL_TREE;\n \t\t  if (TREE_CODE (TREE_TYPE ($1)) \n \t\t      != TREE_CODE (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE ($3))))\n \t\t    cp_error (\"`%E' is not of type `%T'\", $1, $3);\n \t\t  $$ = convert (void_type_node, $1);\n \t\t}\n \t| object TYPESPEC SCOPE '~' TYPESPEC LEFT_RIGHT\n-\t\t{ \n+\t\t{\n+\t\t  got_object = NULL_TREE;\n \t\t  if ($2 != $5)\n \t\t    cp_error (\"destructor specifier `%T::~%T()' must have matching names\", $2, $5);\n \t\t  if (TREE_CODE (TREE_TYPE ($1))\n \t\t      != TREE_CODE (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE ($2))))\n \t\t    cp_error (\"`%E' is not of type `%T'\", $1, $2);\n \t\t  $$ = convert (void_type_node, $1);\n \t\t}\n+\t| object error\n+\t\t{\n+\t\t  got_object = NULL_TREE;\n+\t\t  $$ = error_mark_node;\n+\t\t}\n \t;\n \n /* Not needed for now.\n@@ -1690,9 +1709,11 @@ nodecls:\n \t;\n \n object:\t  primary '.'\n+\t\t{ got_object = TREE_TYPE ($$); }\n \t| primary POINTSAT\n \t\t{\n-\t\t  $$ = build_x_arrow ($$);\n+\t\t  $$ = build_x_arrow ($$); \n+\t\t  got_object = TREE_TYPE ($$);\n \t\t}\n \t;\n \n@@ -3288,7 +3309,7 @@ simple_stmt:\n \t\t      else if (success == 2)\n \t\t\t{\n \t\t\t  cp_error (\"duplicate case value `%E'\", $2);\n-\t\t\t  cp_error_at (\"`%E' previously used here\", duplicate);\n+\t\t\t  cp_error_at (\"previously used here\", duplicate);\n \t\t\t}\n \t\t      else if (success == 3)\n \t\t\twarning (\"case value out of range\");"}, {"sha": "a9dfb84be3bbb12008aab03c3a286bd9538f8095", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "patch": "@@ -1257,6 +1257,8 @@ tsubst (t, args, nargs, in_decl)\n \t\ttype = newtype;\n \n \t\tfnargs = copy_node (DECL_ARGUMENTS (t));\n+\t\tTREE_CHAIN (fnargs) = TREE_CHAIN (DECL_ARGUMENTS (t));\n+\n \t\t/* In this case we need \"in-charge\" flag saying whether\n \t\t   this constructor is responsible for initialization\n \t\t   of virtual baseclasses or not.  */\n@@ -1419,7 +1421,7 @@ tsubst (t, args, nargs, in_decl)\n \t\t  r = build_lang_decl (FUNCTION_DECL, r, type);\n \t\t  DECL_ASSEMBLER_NAME (r) = a;\n \t\t}\n-\t      else if (DECL_INLINE (r) && DECL_SAVED_INSNS (r))\n+\t      else if (TREE_STATIC (r))\n \t\t{\n \t\t  /* This overrides the template version, use it. */\n \t\t  return r;\n@@ -1718,7 +1720,7 @@ instantiate_template (tmpl, targ_ptr)\n \n   /* If we have a preexisting version of this function, don't expand\n      the template version, use the other instead.  */\n-  if (DECL_INLINE (fndecl) && DECL_SAVED_INSNS (fndecl))\n+  if (TREE_STATIC (fndecl))\n     {\n       SET_DECL_TEMPLATE_SPECIALIZATION (fndecl);\n       p = (struct pending_inline *)0;\n@@ -2448,7 +2450,7 @@ do_function_instantiation (declspecs, declarator, storage)\n \t  {\n \t    int ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (fn));\n \t    tree *targs = (tree *) malloc (sizeof (tree) * ntparms);\n-\t    int i, dummy;\n+\t    int i, dummy = 0;\n \t    i = type_unification (DECL_TEMPLATE_PARMS (fn), targs,\n \t\t\t\t  TYPE_ARG_TYPES (TREE_TYPE (fn)),\n \t\t\t\t  TYPE_ARG_TYPES (TREE_TYPE (decl)),\n@@ -2460,6 +2462,7 @@ do_function_instantiation (declspecs, declarator, storage)\n \t\telse\n \t\t  result = instantiate_template (fn, targs);\n \t      }\n+\t    free (targs);\n \t  }\n     }\n   if (! result)"}, {"sha": "1c0e7122a860950c0eaab51fcd73b04f4631b6bc", "filename": "gcc/cp/search.c", "status": "modified", "additions": 118, "deletions": 19, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "patch": "@@ -1089,18 +1089,29 @@ lookup_field (xbasetype, name, protect, want_type)\n     entry = 0;\n \n   rval = lookup_field_1 (type, name);\n-  if (rval || lookup_fnfields_here (type, name)>=0)\n-    {\n-      rval_binfo = basetype_path;\n-      rval_binfo_h = rval_binfo;\n-    }\n-\n-  if (rval && TREE_CODE (rval) != TYPE_DECL && want_type)\n-    rval = NULL_TREE;\n \n-  if (rval)\n+  if (rval || lookup_fnfields_here (type, name) >= 0)\n     {\n-      if (protect)\n+      if (rval)\n+\t{\n+\t  if (want_type)\n+\t    {\n+\t      if (TREE_CODE (rval) != TYPE_DECL)\n+\t\t{\n+\t\t  rval = purpose_member (name, CLASSTYPE_TAGS (type));\n+\t\t  if (rval)\n+\t\t    rval = TYPE_MAIN_DECL (TREE_VALUE (rval));\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (TREE_CODE (rval) == TYPE_DECL\n+\t\t  && lookup_fnfields_here (type, name) >= 0)\n+\t\trval = NULL_TREE;\n+\t    }\n+\t}\n+\n+      if (protect && rval)\n \t{\n \t  if (TREE_PRIVATE (rval) | TREE_PROTECTED (rval))\n \t    this_v = compute_access (basetype_path, rval);\n@@ -1259,12 +1270,33 @@ lookup_field (xbasetype, name, protect, want_type)\n     if (entry)\n       TREE_VALUE (entry) = rval;\n \n-    if (want_type && (rval == NULL_TREE || TREE_CODE (rval) != TYPE_DECL))\n+    if (rval_binfo)\n       {\n-\trval = NULL_TREE;\n-\terrstr = 0;\n+\ttype = BINFO_TYPE (rval_binfo);\n+\n+\tif (rval)\n+\t  {\n+\t    if (want_type)\n+\t      {\n+\t\tif (TREE_CODE (rval) != TYPE_DECL)\n+\t\t  {\n+\t\t    rval = purpose_member (name, CLASSTYPE_TAGS (type));\n+\t\t    if (rval)\n+\t\t      rval = TYPE_MAIN_DECL (TREE_VALUE (rval));\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (TREE_CODE (rval) == TYPE_DECL\n+\t\t    && lookup_fnfields_here (type, name) >= 0)\n+\t\t  rval = NULL_TREE;\n+\t      }\n+\t  }\n       }\n \n+    if (rval == NULL_TREE)\n+      errstr = 0;\n+\n     /* If this FIELD_DECL defines its own access level, deal with that.  */\n     if (rval && errstr == 0\n \t&& ((protect&1) || entry)\n@@ -1948,11 +1980,51 @@ get_matching_virtual (binfo, fndecl, dtorp)\n \t\t   == TYPE_READONLY (instptr_type))\n \t\t  && compparms (TREE_CHAIN (btypes), TREE_CHAIN (dtypes), 3))\n \t\t{\n-\t\t  if (IDENTIFIER_ERROR_LOCUS (name) == NULL_TREE\n-\t\t      && ! comptypes (TREE_TYPE (TREE_TYPE (tmp)), drettype, 1))\n+\t\t  tree brettype = TREE_TYPE (TREE_TYPE (tmp));\n+\t\t  if (comptypes (brettype, drettype, 1))\n+\t\t    /* OK */;\n+\t\t  else if\n+\t\t    (TREE_CODE (brettype) == TREE_CODE (drettype)\n+\t\t     && (TREE_CODE (brettype) == POINTER_TYPE\n+\t\t\t || TREE_CODE (brettype) == REFERENCE_TYPE)\n+\t\t     && comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (brettype)),\n+\t\t\t\t   TYPE_MAIN_VARIANT (TREE_TYPE (drettype)),\n+\t\t\t\t   0))\n+\t\t      /* covariant return type */\n+\t\t    {\n+\t\t      tree b = TREE_TYPE (brettype), d = TREE_TYPE (drettype);\n+\t\t      if (TYPE_MAIN_VARIANT (b) != TYPE_MAIN_VARIANT (d))\n+\t\t\t{\n+\t\t\t  tree binfo = get_binfo (b, d, 1);\n+\t\t\t  if (binfo != error_mark_node\n+\t\t\t      && ! BINFO_OFFSET_ZEROP (binfo))\n+\t\t\t    sorry (\"adjusting pointers for covariant returns\");\n+\t\t\t}\n+\t\t      if (TYPE_READONLY (d) > TYPE_READONLY (b))\n+\t\t\t{\n+\t\t\t  cp_error (\"return type of `%#D' adds const\", fndecl);\n+\t\t\t  cp_error_at (\"  overriding definition as `%#D'\",\n+\t\t\t\t       tmp);\n+\t\t\t}\n+\t\t      else if (TYPE_VOLATILE (d) > TYPE_VOLATILE (b))\n+\t\t\t{\n+\t\t\t  cp_error (\"return type of `%#D' adds volatile\",\n+\t\t\t\t    fndecl);\n+\t\t\t  cp_error_at (\"  overriding definition as `%#D'\",\n+\t\t\t\t       tmp);\n+\t\t\t}\n+\t\t    }\n+\t\t  else if (IS_AGGR_TYPE_2 (brettype, drettype)\n+\t\t\t   && comptypes (brettype, drettype, 0))\n+\t\t    {\n+\t\t      error (\"invalid covariant return type (must use pointer or reference)\");\n+\t\t      cp_error_at (\"  overriding `%#D'\", tmp);\n+\t\t      cp_error (\"  with `%#D'\", fndecl);\n+\t\t    }\n+\t\t  else if (IDENTIFIER_ERROR_LOCUS (name) == NULL_TREE)\n \t\t    {\n \t\t      cp_error (\"conflicting return type specified for virtual function `%#D'\", fndecl);\n-\t\t      cp_error_at (\"overriding definition as `%#D'\", tmp);\n+\t\t      cp_error_at (\"  overriding definition as `%#D'\", tmp);\n \t\t      SET_IDENTIFIER_ERROR_LOCUS (name, basetype);\n \t\t    }\n \t\t  break;\n@@ -2192,7 +2264,7 @@ dfs_walk (binfo, fn, qfn)\n     {\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n \n-      if ((*qfn)(base_binfo))\n+      if (qfn == 0 || (*qfn)(base_binfo))\n \t{\n \t  if (fn == dfs_init_vbase_pointers)\n \t    {\n@@ -2800,8 +2872,14 @@ dfs_pushdecls (binfo)\n \t\t    ? DECL_CLASS_CONTEXT (value)\n \t\t      : DECL_CONTEXT (value);\n \n-\t\t  if (context && (context == type\n-\t\t\t\t  || TYPE_DERIVES_FROM (context, type)))\n+\t\t  if (context == type)\n+\t\t    {\n+\t\t      if (TREE_CODE (value) == TYPE_DECL\n+\t\t\t  && DECL_ARTIFICIAL (value))\n+\t\t\tvalue = fields;\n+\t\t      /* else the old value wins */\n+\t\t    }\n+\t\t  else if (context && TYPE_DERIVES_FROM (context, type))\n \t\t    value = fields;\n \t\t  else\n \t\t    value = tree_cons (NULL_TREE, fields,\n@@ -3210,3 +3288,24 @@ reinit_search_statistics ()\n   n_outer_fields_searched = 0;\n   n_contexts_saved = 0;\n }\n+\n+static tree conversions;\n+static void\n+add_conversions (binfo)\n+     tree binfo;\n+{\n+  tree tmp = CLASSTYPE_FIRST_CONVERSION (BINFO_TYPE (binfo));\n+  for (; tmp && IDENTIFIER_TYPENAME_P (DECL_NAME (tmp));\n+       tmp = TREE_CHAIN (tmp))\n+    conversions = tree_cons (DECL_NAME (tmp), TREE_TYPE (TREE_TYPE (tmp)),\n+\t\t\t     conversions);\n+}\n+\n+tree\n+lookup_conversions (type)\n+     tree type;\n+{\n+  conversions = NULL_TREE;\n+  dfs_walk (TYPE_BINFO (type), add_conversions, 0);\n+  return conversions;\n+}"}, {"sha": "296c8f6c7c55370749a12d45db5a0716b2594210", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "patch": "@@ -242,6 +242,7 @@ int looking_for_template;\n \n extern struct obstack *current_obstack, *saveable_obstack;\n tree got_scope;\n+tree got_object;\n \n int\n yylex()\n@@ -316,7 +317,7 @@ yylex()\n \t      if (lastiddecl != trrr)\n \t\t{\n \t\t  lastiddecl = trrr;\n-\t\t  if (got_scope)\n+\t\t  if (got_scope || got_object)\n \t\t    tmp_token.yylval.ttype = DECL_NESTED_TYPENAME (trrr);\n \t\t}\n \t      break;\n@@ -334,8 +335,11 @@ yylex()\n \tlastiddecl = trrr;\n       got_scope = NULL_TREE;\n       /* and fall through to... */\n+    case IDENTIFIER_DEFN:\n     case TYPENAME:\n+    case TYPENAME_DEFN:\n     case PTYPENAME:\n+    case PTYPENAME_DEFN:\n       consume_token ();\n       if (looking_for_typename > 0)\n \tlooking_for_typename--;"}, {"sha": "bb652c7387e58e1aae83f093ecba84a9e84d151e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "patch": "@@ -102,6 +102,11 @@ lvalue_p (ref)\n \n     case COMPOUND_EXPR:\n       return lvalue_p (TREE_OPERAND (ref, 1));\n+\n+    case MAX_EXPR:\n+    case MIN_EXPR:\n+      return (lvalue_p (TREE_OPERAND (ref, 0))\n+\t      && lvalue_p (TREE_OPERAND (ref, 1)));\n     }\n \n   return 0;\n@@ -570,9 +575,13 @@ layout_vbasetypes (rec, max)\n       BINFO_OFFSET (vbase_types) = offset;\n \n       if (TREE_CODE (TYPE_SIZE (basetype)) == INTEGER_CST)\n-\tconst_size += MAX (BITS_PER_UNIT,\n-\t\t\t   TREE_INT_CST_LOW (TYPE_SIZE (basetype))\n-\t\t\t   - TREE_INT_CST_LOW (CLASSTYPE_VBASE_SIZE (basetype)));\n+\t{\n+\t  /* Every virtual baseclass takes a least a UNIT, so that we can\n+\t     take it's address and get something different for each base.  */\n+\t  const_size += MAX (BITS_PER_UNIT,\n+\t\t\t     TREE_INT_CST_LOW (TYPE_SIZE (basetype))\n+\t\t\t     - TREE_INT_CST_LOW (CLASSTYPE_VBASE_SIZE (basetype)));\n+\t}\n       else if (var_size == 0)\n \tvar_size = TYPE_SIZE (basetype);\n       else\n@@ -581,6 +590,15 @@ layout_vbasetypes (rec, max)\n       vbase_types = TREE_CHAIN (vbase_types);\n     }\n \n+  if (const_size)\n+    {\n+      /* Because a virtual base might take a single byte above,\n+\t we have to re-adjust the total size to make sure it it\n+\t a multiple of the alignment.  */\n+      /* Give the whole object the alignment it wants.  */\n+      const_size = CEIL (const_size, record_align) * record_align;\n+    }\n+\n   /* Set the alignment in the complete type.  We don't set CLASSTYPE_ALIGN\n    here, as that is for this class, without any virtual base classes.  */\n   TYPE_ALIGN (rec) = record_align;"}, {"sha": "f226f28f22de4f5e540d89d0748b6e3555b9f626", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 105, "deletions": 55, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e1cd6e56ad04b7be6484182156fc1d4a9b3ecf12", "patch": "@@ -202,9 +202,6 @@ commonparms (p1, p2)\n     {\n       if (TREE_PURPOSE (p1) && !TREE_PURPOSE (p2))\n \t{\n-\t  /* We used to give a warning here that advised about a default\n-\t     argument being given in the prototype but not in the function's\n-\t     declaration.  It's best not to bother.  */\n \t  TREE_PURPOSE (n) = TREE_PURPOSE (p1);\n \t  any_change = 1;\n \t}\n@@ -352,6 +349,11 @@ common_type (t1, t2)\n \t  return build_type_attribute_variant (t1, attributes);\n \t}\n \n+      if (TYPE_MAIN_VARIANT (t1) == long_double_type_node\n+\t  || TYPE_MAIN_VARIANT (t2) == long_double_type_node)\n+\treturn build_type_attribute_variant (long_double_type_node,\n+\t\t\t\t\t     attributes);\t  \n+\n       /* Otherwise prefer the unsigned one.  */\n \n       if (TREE_UNSIGNED (t1))\n@@ -445,9 +447,12 @@ common_type (t1, t2)\n       my_friendly_assert (TYPE_MAIN_VARIANT (t1) == t1\n \t\t\t  && TYPE_MAIN_VARIANT (t2) == t2, 306);\n \n-      if (! binfo_or_else (t1, t2))\n-         compiler_error (\"common_type called with uncommon aggregate types\");\n-      return build_type_attribute_variant (t1, attributes);\n+      if (DERIVED_FROM_P (t1, t2) && binfo_or_else (t1, t2))\n+\treturn build_type_attribute_variant (t1, attributes);\n+      else if (binfo_or_else (t2, t1))\n+\treturn build_type_attribute_variant (t2, attributes);\n+      else\n+\tcompiler_error (\"common_type called with uncommon aggregate types\");\n \n     case METHOD_TYPE:\n       if (comptypes (TYPE_METHOD_BASETYPE (t1), TYPE_METHOD_BASETYPE (t2), 1)\n@@ -761,9 +766,7 @@ comp_target_types (ttl, ttr, nptrs)\n \tcase 1:\n \t  return 1;\n \tcase 2:\n-\t  cp_pedwarn (\"converting `%T' to `%T' is a contravariance violation\",\n-\t\t      ttr, ttl);\n-\t  return 1;\n+\t  return -1;\n \tdefault:\n \t  my_friendly_abort (112);\n \t}\n@@ -780,17 +783,17 @@ comp_target_types (ttl, ttr, nptrs)\n \treturn comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), nptrs);\n       else if (comptypes (TYPE_OFFSET_BASETYPE (ttl), TYPE_OFFSET_BASETYPE (ttr), 0)\n \t       && comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), nptrs))\n-\t{\n-\t  cp_pedwarn (\"converting `%T' to `%T' is a contravariance violation\",\n-\t\t      ttr, ttl);\n-\t  return 1;\n-\t}\n+\treturn -1;\n     }\n   else if (IS_AGGR_TYPE (ttl))\n     {\n       if (nptrs < 0)\n \treturn 0;\n-      return comptypes (TYPE_POINTER_TO (ttl), TYPE_POINTER_TO (ttr), 0);\n+      if (comptypes (TYPE_POINTER_TO (ttl), TYPE_POINTER_TO (ttr), 0))\n+\treturn 1;\n+      if (comptypes (TYPE_POINTER_TO (ttr), TYPE_POINTER_TO (ttl), 0))\n+\treturn -1;\n+      return 0;\n     }\n \n   return 0;\n@@ -1223,7 +1226,7 @@ c_sizeof_nowarn (type)\n \n   /* Convert in case a char is more than one unit.  */\n   t = size_binop (CEIL_DIV_EXPR, TYPE_SIZE (type), \n-\t\t     size_int (TYPE_PRECISION (char_type_node)));\n+\t\t  size_int (TYPE_PRECISION (char_type_node)));\n   force_fit_type (t, 0);\n   return t;\n }\n@@ -1665,7 +1668,14 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t  return error_mark_node;\n \t\t}\n \t      else\n-\t\treturn build (COMPONENT_REF, unknown_type_node, datum, fndecls);\n+\t\t{\n+\t\t  /* Just act like build_offset_ref, since the object does\n+                     not matter unless we're actually calling the function.  */\n+\t\t  tree t = build_tree_list (error_mark_node, fndecls);\n+\t\t  TREE_TYPE (t) = build_offset_type (basetype,\n+\t\t\t\t\t\t     unknown_type_node);\n+\t\t  return t;\n+\t\t}\n \t    }\n \n #if 0\n@@ -2187,12 +2197,13 @@ get_member_function_from_ptrfunc (instance_ptrptr, instance, function)\n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (function)))\n     {\n       tree fntype = TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (function));\n-      tree index = save_expr (convert (integer_type_node,\n-\t\t\t\t       build_component_ref (function,\n-\t\t\t\t\t\t\t    index_identifier,\n-\t\t\t\t\t\t\t    0, 0)));\n-      tree e1 = build (GT_EXPR, integer_type_node, index, integer_zero_node);\n-      tree delta = build_component_ref (function, delta_identifier, 0, 0);\n+      tree index = save_expr (build_component_ref (function,\n+\t\t\t\t\t\t   index_identifier,\n+\t\t\t\t\t\t   0, 0));\n+      tree e1 = build (GT_EXPR, delta_type_node, index,\n+\t\t       convert (delta_type_node, integer_zero_node));\n+      tree delta = convert (ptrdiff_type_node,\n+\t\t\t    build_component_ref (function, delta_identifier, 0, 0));\n       tree delta2 = DELTA2_FROM_PTRMEMFUNC (function);\n       tree e2;\n       tree e3;\n@@ -2208,11 +2219,11 @@ get_member_function_from_ptrfunc (instance_ptrptr, instance, function)\n       vtbl\n \t= build (PLUS_EXPR,\n \t\t build_pointer_type (build_pointer_type (vtable_entry_type)),\n-\t\t vtbl, convert (sizetype, delta2));\n+\t\t vtbl, convert (ptrdiff_type_node, delta2));\n       vtbl = build_indirect_ref (vtbl, NULL_PTR);\n-      aref = build_array_ref (vtbl, size_binop (MINUS_EXPR,\n-\t\t\t\t\t\tindex,\n-\t\t\t\t\t\tinteger_one_node));\n+      aref = build_array_ref (vtbl, build_binary_op (MINUS_EXPR,\n+\t\t\t\t\t\t     index,\n+\t\t\t\t\t\t     integer_one_node, 1));\n       if (! flag_vtable_thunks)\n \t{\n \t  aref = save_expr (aref);\n@@ -2222,14 +2233,14 @@ get_member_function_from_ptrfunc (instance_ptrptr, instance, function)\n \t  if (/* !building_cleanup && */ TREE_CODE (aref) == INDIRECT_REF)\n \t    TREE_OPERAND (aref, 0) = save_expr (TREE_OPERAND (aref, 0));\n       \n-\t  delta = build (PLUS_EXPR, integer_type_node,\n-\t\t\t build_conditional_expr (e1, build_component_ref (aref, delta_identifier, 0, 0), integer_zero_node),\n-\t\t\t delta);\n+\t  delta = build_binary_op (PLUS_EXPR,\n+\t\t\t\t   build_conditional_expr (e1, build_component_ref (aref, delta_identifier, 0, 0), integer_zero_node),\n+\t\t\t\t   delta, 1);\n \t}\n \n       *instance_ptrptr = build (PLUS_EXPR, TREE_TYPE (*instance_ptrptr),\n \t\t\t\t*instance_ptrptr,\n-\t\t\t\tconvert (integer_type_node, delta));\n+\t\t\t\tdelta);\n       if (flag_vtable_thunks)\n \te2 = aref;\n       else\n@@ -3162,7 +3173,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  tree delta21 = DELTA2_FROM_PTRMEMFUNC (op1);\n \t  tree e1, e2, e3;\n \t  tree integer_neg_one_node\n-\t    = size_binop (MINUS_EXPR, integer_zero_node, integer_one_node);\n+\t    = build_binary_op (MINUS_EXPR, integer_zero_node, integer_one_node, 1);\n \t  e1 = build_binary_op (EQ_EXPR, index0, index1, 1);\n \t  e2 = build_binary_op (NE_EXPR, index1, integer_neg_one_node, 1);\n \t  e2 = build_binary_op (TRUTH_ANDIF_EXPR, e2, build_binary_op (EQ_EXPR, delta20, delta21, 1), 1);\n@@ -3183,7 +3194,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  tree delta21 = integer_zero_node;\n \t  tree e1, e2, e3;\n \t  tree integer_neg_one_node\n-\t    = size_binop (MINUS_EXPR, integer_zero_node, integer_one_node);\n+\t    = build_binary_op (MINUS_EXPR, integer_zero_node, integer_one_node, 1);\n \t  if (TREE_CODE (TREE_OPERAND (op1, 0)) == FUNCTION_DECL\n \t      && DECL_VINDEX (TREE_OPERAND (op1, 0)))\n \t    {\n@@ -3828,9 +3839,17 @@ build_unary_op (code, xarg, noconvert)\n         errstring = \"wrong type argument to unary plus\";\n       else if (!noconvert)\n \targ = default_conversion (arg);\n+      arg = build1 (NON_LVALUE_EXPR, TREE_TYPE (arg), arg);\n       break;\n \n     case NEGATE_EXPR:\n+      if (typecode == OFFSET_TYPE)\n+\t{\n+\t  arg = resolve_offset_ref (arg);\n+\t  typecode = TREE_CODE (TREE_TYPE (arg));\n+\t  isaggrtype = IS_AGGR_TYPE_CODE (typecode);\n+\t}\n+\n       if (isaggrtype)\n \t{\n \t  if (!noconvert)\n@@ -3852,6 +3871,13 @@ build_unary_op (code, xarg, noconvert)\n       break;\n \n     case BIT_NOT_EXPR:\n+      if (typecode == OFFSET_TYPE)\n+\t{\n+\t  arg = resolve_offset_ref (arg);\n+\t  typecode = TREE_CODE (TREE_TYPE (arg));\n+\t  isaggrtype = IS_AGGR_TYPE_CODE (typecode);\n+\t}\n+\n       if (isaggrtype)\n \t{\n \t  if (!noconvert)\n@@ -3873,6 +3899,13 @@ build_unary_op (code, xarg, noconvert)\n       break;\n \n     case ABS_EXPR:\n+      if (typecode == OFFSET_TYPE)\n+\t{\n+\t  arg = resolve_offset_ref (arg);\n+\t  typecode = TREE_CODE (TREE_TYPE (arg));\n+\t  isaggrtype = IS_AGGR_TYPE_CODE (typecode);\n+\t}\n+\n       if (isaggrtype)\n \t{\n \t  if (!noconvert)\n@@ -3917,6 +3950,13 @@ build_unary_op (code, xarg, noconvert)\n \n       /* Report invalid types.  */\n \n+      if (typecode == OFFSET_TYPE)\n+\t{\n+\t  arg = resolve_offset_ref (arg);\n+\t  typecode = TREE_CODE (TREE_TYPE (arg));\n+\t  isaggrtype = IS_AGGR_TYPE_CODE (typecode);\n+\t}\n+\n       if (isaggrtype)\n \t{\n \t  arg = default_conversion (arg);\n@@ -4012,9 +4052,6 @@ build_unary_op (code, xarg, noconvert)\n \t    }\n \t  }\n \n-\tif (TREE_CODE (arg) == OFFSET_REF)\n-\t  arg = resolve_offset_ref (arg);\n-\n \t/* Complain about anything else that is not a true lvalue.  */\n \tif (!lvalue_or_else (arg, ((code == PREINCREMENT_EXPR\n \t\t\t\t    || code == POSTINCREMENT_EXPR)\n@@ -4244,7 +4281,9 @@ unary_complex_lvalue (code, arg)\n   if (TREE_CODE (arg) == COND_EXPR)\n     return rationalize_conditional_expr (code, arg);\n \n-  if (TREE_CODE (arg) == MODIFY_EXPR)\n+  if (TREE_CODE (arg) == MODIFY_EXPR\n+      || TREE_CODE (arg) == PREINCREMENT_EXPR\n+      || TREE_CODE (arg) == PREDECREMENT_EXPR)\n     return unary_complex_lvalue\n       (code, build (COMPOUND_EXPR, TREE_TYPE (TREE_OPERAND (arg, 0)),\n \t\t    arg, TREE_OPERAND (arg, 0)));\n@@ -4499,7 +4538,7 @@ build_conditional_expr (ifexp, op1, op2)\n       ifexp = op1 = save_expr (ifexp);\n     }\n \n-  ifexp = bool_truthvalue_conversion (default_conversion (ifexp));\n+  ifexp = bool_truthvalue_conversion (ifexp);\n \n   if (TREE_CODE (ifexp) == ERROR_MARK)\n     return error_mark_node;\n@@ -5780,8 +5819,7 @@ build_modify_expr (lhs, modifycode, rhs)\n       int from_array;\n       \n       /* Allow array assignment in compiler-generated code.  */\n-      if ((pedantic || flag_ansi)\n-\t  && ! DECL_ARTIFICIAL (current_function_decl))\n+      if (pedantic && ! DECL_ARTIFICIAL (current_function_decl))\n \tpedwarn (\"ANSI C++ forbids assignment of arrays\");\n \n       /* Have to wrap this in RTL_EXPR for two cases:\n@@ -6010,9 +6048,9 @@ get_delta_difference (from, to, force)\n \t{\n \t  warning (\"pointer to member conversion to virtual base class will only work if your very careful\");\n \t}\n-      return fold (size_binop (MINUS_EXPR,\n-\t\t\t       integer_zero_node,\n-\t\t\t       BINFO_OFFSET (binfo)));\n+      return build_binary_op (MINUS_EXPR,\n+\t\t\t      integer_zero_node,\n+\t\t\t      BINFO_OFFSET (binfo), 1);\n     }\n   if (TREE_VIA_VIRTUAL (binfo))\n     {\n@@ -6069,14 +6107,14 @@ build_ptrmemfunc (type, pfn, force)\n       if (TREE_CODE (pfn) != CONSTRUCTOR)\n \t{\n \t  tree e1, e2, e3;\n-\t  ndelta = convert (sizetype, build_component_ref (pfn, delta_identifier, 0, 0));\n-\t  ndelta2 = convert (sizetype, DELTA2_FROM_PTRMEMFUNC (pfn));\n+\t  ndelta = convert (ptrdiff_type_node, build_component_ref (pfn, delta_identifier, 0, 0));\n+\t  ndelta2 = convert (ptrdiff_type_node, DELTA2_FROM_PTRMEMFUNC (pfn));\n \t  index = build_component_ref (pfn, index_identifier, 0, 0);\n \t  delta = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn)))),\n \t\t\t\t\tTYPE_METHOD_BASETYPE (TREE_TYPE (type)),\n \t\t\t\t\tforce);\n-\t  delta = fold (size_binop (PLUS_EXPR, delta, ndelta));\n-\t  delta2 = fold (size_binop (PLUS_EXPR, ndelta2, delta2));\n+\t  delta = build_binary_op (PLUS_EXPR, delta, ndelta, 1);\n+\t  delta2 = build_binary_op (PLUS_EXPR, ndelta2, delta2, 1);\n \t  e1 = fold (build (GT_EXPR, integer_type_node, index, integer_zero_node));\n \t  \n \t  u = build_nt (CONSTRUCTOR, 0, tree_cons (delta2_identifier, delta2, NULL_TREE));\n@@ -6136,7 +6174,7 @@ build_ptrmemfunc (type, pfn, force)\n   delta = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (TREE_TYPE (pfn))),\n \t\t\t\tTYPE_METHOD_BASETYPE (TREE_TYPE (type)),\n \t\t\t\tforce);\n-  delta2 = fold (size_binop (PLUS_EXPR, delta2, delta));\n+  delta2 = build_binary_op (PLUS_EXPR, delta2, delta, 1);\n \n   if (TREE_CODE (TREE_OPERAND (pfn, 0)) != FUNCTION_DECL)\n     warning (\"assuming pointer to member function is non-virtual\");\n@@ -6159,7 +6197,7 @@ build_ptrmemfunc (type, pfn, force)\n     }\n   else\n     {\n-      index = fold (size_binop (MINUS_EXPR, integer_zero_node, integer_one_node));\n+      index = size_binop (MINUS_EXPR, integer_zero_node, integer_one_node);\n \n       npfn = build1 (NOP_EXPR, type, pfn);\n       TREE_CONSTANT (npfn) = TREE_CONSTANT (pfn);\n@@ -6306,6 +6344,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n     {\n       register tree ttl = TREE_TYPE (type);\n       register tree ttr;\n+      int ctt = 0;\n \n       if (coder == RECORD_TYPE)\n \t{\n@@ -6358,25 +6397,29 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t Meanwhile, the lhs target must have all the qualifiers of the rhs.  */\n       else if (TYPE_MAIN_VARIANT (ttl) == void_type_node\n \t       || TYPE_MAIN_VARIANT (ttr) == void_type_node\n-\t       || comp_target_types (type, rhstype, 1)\n+\t       || (ctt = comp_target_types (type, rhstype, 1))\n \t       || (unsigned_type (TYPE_MAIN_VARIANT (ttl))\n \t\t   == unsigned_type (TYPE_MAIN_VARIANT (ttr))))\n \t{\n \t  /* ARM $4.8, commentary on p39.  */\n \t  if (TYPE_MAIN_VARIANT (ttl) == void_type_node\n \t      && TREE_CODE (ttr) == OFFSET_TYPE)\n \t    {\n-\t      error (\"no standard conversion from pointer to member to `void *'\");\n+\t      cp_error (\"no standard conversion from `%T' to `void *'\", ttr);\n \t      return error_mark_node;\n \t    }\n \n+\t  if (ctt < 0)\n+\t    cp_pedwarn (\"converting `%T' to `%T' is a contravariance violation\",\n+\t\t\tttr, ttl);\n+\n \t  if (TYPE_MAIN_VARIANT (ttl) != void_type_node\n \t      && TYPE_MAIN_VARIANT (ttr) == void_type_node\n \t      && rhs != null_pointer_node)\n \t    {\n \t      if (coder == RECORD_TYPE)\n-\t\tpedwarn (\"implicit conversion of signature pointer to type `%s'\",\n-\t\t\t type_as_string (type, 0));\n+\t\tcp_pedwarn (\"implicit conversion of signature pointer to type `%T'\",\n+\t\t\t    type);\n \t      else\n \t\tpedwarn (\"ANSI C++ forbids implicit conversion from `void *' in %s\",\n \t\t\t errtype);\n@@ -6481,7 +6524,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t\tttl = unsigned_type (ttl);\n \t    }\n \n-\t  if (comp_target_types (ttl, ttr, nptrs))\n+\t  if (comp_target_types (ttl, ttr, nptrs) > 0)\n \t    {\n \t      if (add_quals)\n \t\t{\n@@ -6585,7 +6628,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t}\n       return null_pointer_node;\n     }\n-  else if ((codel == INTEGER_TYPE || codel == BOOLEAN_TYPE)\n+  else if (codel == INTEGER_TYPE\n \t   && (coder == POINTER_TYPE\n \t       || (coder == RECORD_TYPE\n \t\t   && (IS_SIGNATURE_POINTER (rhstype)\n@@ -6600,6 +6643,13 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t\t    errtype, type, rhstype);\n       return convert (type, rhs);\n     }\n+  else if (codel == BOOLEAN_TYPE\n+\t   && (coder == POINTER_TYPE\n+\t       || (coder == RECORD_TYPE\n+\t\t   && (IS_SIGNATURE_POINTER (rhstype)\n+\t\t       || TYPE_PTRMEMFUNC_FLAG (rhstype)\n+\t\t       || IS_SIGNATURE_REFERENCE (rhstype)))))\n+    return convert (type, rhs);\n \n   /* C++ */\n   else if (((coder == POINTER_TYPE && TREE_CODE (rhs) == ADDR_EXPR"}]}