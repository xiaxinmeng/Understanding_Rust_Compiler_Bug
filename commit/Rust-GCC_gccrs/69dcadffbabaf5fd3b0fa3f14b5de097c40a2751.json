{"sha": "69dcadffbabaf5fd3b0fa3f14b5de097c40a2751", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjlkY2FkZmZiYWJhZjVmZDNiMGZhM2YxNGI1ZGUwOTdjNDBhMjc1MQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2001-10-08T20:54:07Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2001-10-08T20:54:07Z"}, "message": "langhooks.h: New file.\n\n* langhooks.h: New file.\n* Makefile.in (OBJS): Added langhooks.o.\n(c-lang.o): Depend on langhooks.h.\n(c-common.o): Don't depend on tree-inline.h.\n(tree-inline.o): Depend on toplev.h.\n(langhooks.o): New rule.\n* c-common.c: Don't include tree-inline.h.\n(c_mark_lang_decl): Mark argument c as unused.\n(c_common_lang_init): Don't initialize hooks here.\n* c-lang.c: Include langhooks.h, then override some macros.\n(lang_hooks): Initialize with macros in langhooks.h.\n(c_init): Don't initialize hooks here.\n* toplev.c (struct lang_hooks_for_tree_inlining): New struct.\n(struct lang_hooks): Add tree_inlining.  Refer to langhooks.h.\n* tree-inline.c: Include toplev.h.  Don't define hook variables.\n* tree-inline.h: Don't define hook types nor declare hook\nvariables.  Move macros to...\n* langhooks.c: ... new file, as functions.  Adjust all callers.\n\nFrom-SVN: r46096", "tree": {"sha": "f37df892d870d138dc0e3460f96264fd2648883e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f37df892d870d138dc0e3460f96264fd2648883e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/comments", "author": null, "committer": null, "parents": [{"sha": "19551f2985c293a1041a0e7755627e87eb1559b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19551f2985c293a1041a0e7755627e87eb1559b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19551f2985c293a1041a0e7755627e87eb1559b7"}], "stats": {"total": 492, "additions": 352, "deletions": 140}, "files": [{"sha": "f21ad78f8202aebf1772ef68d22522ae58923995", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=69dcadffbabaf5fd3b0fa3f14b5de097c40a2751", "patch": "@@ -1,3 +1,24 @@\n+2001-10-08  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* langhooks.h: New file.\n+\t* Makefile.in (OBJS): Added langhooks.o.\n+\t(c-lang.o): Depend on langhooks.h.\n+\t(c-common.o): Don't depend on tree-inline.h.\n+\t(tree-inline.o): Depend on toplev.h.\n+\t(langhooks.o): New rule.\n+\t* c-common.c: Don't include tree-inline.h.\n+\t(c_mark_lang_decl): Mark argument c as unused.\n+\t(c_common_lang_init): Don't initialize hooks here.\n+\t* c-lang.c: Include langhooks.h, then override some macros.\n+\t(lang_hooks): Initialize with macros in langhooks.h.\n+\t(c_init): Don't initialize hooks here.\n+\t* toplev.c (struct lang_hooks_for_tree_inlining): New struct.\n+\t(struct lang_hooks): Add tree_inlining.  Refer to langhooks.h.\n+\t* tree-inline.c: Include toplev.h.  Don't define hook variables.\n+\t* tree-inline.h: Don't define hook types nor declare hook\n+\tvariables.  Move macros to...\n+\t* langhooks.c: ... new file, as functions.  Adjust all callers.\n+\n 2001-10-08  Jeffrey A Law  <law@cygnus.com>\n \n \t* sibcall.c (optimize_sibling_and_tail_recursive_calls): Call"}, {"sha": "b955d681d0c2b659a48b1e4ddd4d7076744b23a7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=69dcadffbabaf5fd3b0fa3f14b5de097c40a2751", "patch": "@@ -748,7 +748,7 @@ OBJS =\t\t\t\t\t\t\t\t\t\\\n  sdbout.o sibcall.o simplify-rtx.o splay-tree.o ssa.o ssa-ccp.o         \\\n  ssa-dce.o stmt.o stor-layout.o stringpool.o timevar.o toplev.o tree.o  \\\n  unroll.o varasm.o varray.o version.o xcoffout.o cfg.o cfganal.o\t\\\n- cfgbuild.o cfgcleanup.o cfgloop.o cfgrtl.o tree-inline.o \t\t\\\n+ cfgbuild.o cfgcleanup.o cfgloop.o cfgrtl.o tree-inline.o langhooks.o\t\\\n  $(GGC) $(out_object_file) $(EXTRA_OBJS)\n \n BACKEND = main.o libbackend.a\n@@ -1173,7 +1173,7 @@ c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) \\\n     $(TARGET_H) flags.h intl.h output.h $(EXPR_H) $(RTL_H) toplev.h $(TM_P_H)\n c-lang.o : c-lang.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) \\\n     $(GGC_H)  c-lex.h toplev.h diagnostic.h output.h function.h \\\n-    $(RTL_H) $(EXPR_H) tree-inline.h insn-config.h integrate.h\n+    $(RTL_H) $(EXPR_H) tree-inline.h insn-config.h integrate.h langhooks.h\n c-lex.o : c-lex.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) c-lex.h \\\n     debug.h $(C_TREE_H) \\\n     c-pragma.h input.h intl.h flags.h toplev.h output.h \\\n@@ -1249,8 +1249,7 @@ s-under: $(GCC_PASSES)\n \n c-common.o : c-common.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(OBSTACK_H) \\\n \t$(C_COMMON_H) flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n-\t$(EXPR_H) $(TM_P_H) builtin-types.def builtin-attrs.def $(TARGET_H) \\\n-\ttree-inline.h\n+\t$(EXPR_H) $(TM_P_H) builtin-types.def builtin-attrs.def $(TARGET_H)\n \n # A file used by all variants of C and some other languages.\n \n@@ -1349,11 +1348,13 @@ prefix.o: prefix.c $(CONFIG_H) $(SYSTEM_H) Makefile prefix.h\n \n convert.o: convert.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) flags.h convert.h toplev.h\n \n+langhooks.o : langhooks.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) toplev.h \\\n+   tree-inline.h\n tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) flags.h function.h toplev.h \\\n    $(GGC_H) $(HASHTAB_H) $(TARGET_H) output.h $(TM_P_H)\n tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) \\\n    expr.h flags.h params.h input.h insn-config.h $(INTEGRATE_H) \\\n-   $(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) \\\n+   $(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) toplev.h \\\n    $(C_COMMON_H) tree-inline.h\n print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(GGC_H)\n stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) flags.h \\"}, {"sha": "73bfcf0ea2a51f6d638ff978585c25eaa4271238", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=69dcadffbabaf5fd3b0fa3f14b5de097c40a2751", "patch": "@@ -22,7 +22,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"config.h\"\n #include \"system.h\"\n #include \"tree.h\"\n-#include \"tree-inline.h\"\n #include \"flags.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n@@ -3330,7 +3329,7 @@ mark_stmt_tree (p)\n \n void\n c_mark_lang_decl (c)\n-     struct c_lang_decl *c;\n+     struct c_lang_decl *c ATTRIBUTE_UNUSED;\n {\n }\n \n@@ -3831,8 +3830,6 @@ c_common_lang_init ()\n   if (flag_bounds_check < 0)\n     flag_bounds_check = flag_bounded_pointers;\n \n-  lang_anon_aggr_type_p = anon_aggr_type_p;\n-\n   /* Special format checking options don't work without -Wformat; warn if\n      they are used.  */\n   if (warn_format_y2k && !warn_format)"}, {"sha": "e1fd83eaa561908f30d12ab7ffbf5e07a98db0ba", "filename": "gcc/c-lang.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=69dcadffbabaf5fd3b0fa3f14b5de097c40a2751", "patch": "@@ -38,6 +38,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cpplib.h\"\n #include \"insn-config.h\"\n #include \"integrate.h\"\n+#include \"langhooks.h\"\n \n static int c_tree_printer PARAMS ((output_buffer *));\n static int c_missing_noreturn_ok_p PARAMS ((tree));\n@@ -47,12 +48,26 @@ static void c_post_options PARAMS ((void));\n static int c_disregard_inline_limits PARAMS ((tree));\n static int c_cannot_inline_tree_fn PARAMS ((tree *));\n \n+#undef LANG_HOOKS_INIT\n+#define LANG_HOOKS_INIT c_init\n+#undef LANG_HOOKS_INIT_OPTIONS\n+#define LANG_HOOKS_INIT_OPTIONS c_init_options\n+#undef LANG_HOOKS_DECODE_OPTION\n+#define LANG_HOOKS_DECODE_OPTION c_decode_option\n+#undef LANG_HOOKS_POST_OPTIONS\n+#define LANG_HOOKS_POST_OPTIONS c_post_options\n+#undef LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN\n+#define LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN \\\n+  c_cannot_inline_tree_fn\n+#undef LANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS\n+#define LANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS \\\n+  c_disregard_inline_limits\n+#undef LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P\n+#define LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P \\\n+  anon_aggr_type_p\n+\n /* Each front end provides its own.  */\n-struct lang_hooks lang_hooks = {c_init,\n-\t\t\t\tNULL, /* c_finish */\n-\t\t\t\tc_init_options,\n-\t\t\t\tc_decode_option,\n-\t\t\t\tc_post_options};\n+struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n /* Post-switch processing.  */\n static void\n@@ -112,8 +127,6 @@ c_init ()\n   diagnostic_format_decoder (global_dc) = &c_tree_printer;\n   lang_expand_decl_stmt = &c_expand_decl_stmt;\n   lang_missing_noreturn_ok_p = &c_missing_noreturn_ok_p;\n-  lang_disregard_inline_limits = &c_disregard_inline_limits;\n-  lang_cannot_inline_tree_fn = &c_cannot_inline_tree_fn;\n \n   c_parse_init ();\n }"}, {"sha": "dae764c24ab18fcc8912adf84e24932446519865", "filename": "gcc/langhooks.c", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=69dcadffbabaf5fd3b0fa3f14b5de097c40a2751", "patch": "@@ -0,0 +1,142 @@\n+/* Default language-specific hooks.\n+   Copyright 2001 Free Software Foundation, Inc.\n+   Contributed by Alexandre Oliva  <aoliva@redhat.com>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"toplev.h\"\n+#include \"tree.h\"\n+#include \"tree-inline.h\"\n+\n+/* lang_hooks.tree_inlining.walk_subtrees is called by walk_tree()\n+   after handling common cases, but before walking code-specific\n+   sub-trees.  If this hook is overridden for a language, it should\n+   handle language-specific tree codes, as well as language-specific\n+   information associated to common tree codes.  If a tree node is\n+   completely handled within this function, it should set *SUBTREES to\n+   0, so that generic handling isn't attempted.  For language-specific\n+   tree codes, generic handling would abort(), so make sure it is set\n+   properly.  Both SUBTREES and *SUBTREES is guaranteed to be non-zero\n+   when the function is called.  */\n+\n+tree\n+tree_inlining_default_hook_walk_subtrees (tp,subtrees,func,data,htab)\n+     tree *tp ATTRIBUTE_UNUSED;\n+     int *subtrees ATTRIBUTE_UNUSED;\n+     walk_tree_fn func ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n+     void *htab ATTRIBUTE_UNUSED;\n+{\n+  return NULL_TREE;\n+}\n+\n+/* lang_hooks.tree_inlining.cannot_inline_tree_fn is called to\n+   determine whether there are language-specific reasons for not\n+   inlining a given function.  */\n+\n+int\n+tree_inlining_default_hook_cannot_inline_tree_fn (fnp)\n+     tree *fnp ATTRIBUTE_UNUSED;\n+{\n+  return 0;\n+}\n+\n+/* lang_hooks.tree_inlining.disregard_inline_limits is called to\n+   determine whether a function should be considered for inlining even\n+   if it would exceed inlining limits.  */\n+\n+int\n+tree_inlining_default_hook_disregard_inline_limits (fn)\n+     tree fn ATTRIBUTE_UNUSED;\n+{\n+  return 0;\n+}\n+\n+/* lang_hooks.tree_inlining.add_pending_fn_decls is called before\n+   starting to inline a function, to push any language-specific\n+   functions that should not be inlined into the current function,\n+   into VAFNP.  PFN is the top of varray, and should be returned if no\n+   functions are pushed into VAFNP.  The top of the varray should be\n+   returned.  */\n+\n+tree\n+tree_inlining_default_hook_add_pending_fn_decls (vafnp, pfn)\n+     void *vafnp ATTRIBUTE_UNUSED;\n+     tree pfn;\n+{\n+  return pfn;\n+}\n+\n+/* lang_hooks.tree_inlining.tree_chain_matters_p indicates whether the\n+   TREE_CHAIN of a language-specific tree node is relevant, i.e.,\n+   whether it should be walked, copied and preserved across copies.  */\n+\n+int\n+tree_inlining_default_hook_tree_chain_matters_p (t)\n+     tree t ATTRIBUTE_UNUSED;\n+{\n+  return 0;\n+}\n+\n+/* lang_hooks.tree_inlining.auto_var_in_fn_p is called to determine\n+   whether VT is an automatic variable defined in function FT.  */\n+\n+int\n+tree_inlining_default_hook_auto_var_in_fn_p (var, fn)\n+     tree var, fn;\n+{\n+  return (DECL_P (var) && DECL_CONTEXT (var) == fn\n+\t  && (((TREE_CODE (var) == VAR_DECL || TREE_CODE (var) == PARM_DECL)\n+\t       && ! TREE_STATIC (var))\n+\t      || TREE_CODE (var) == LABEL_DECL\n+\t      || TREE_CODE (var) == RESULT_DECL));\n+}\n+\n+/* lang_hooks.tree_inlining.copy_res_decl_for_inlining should return a\n+   declaration for the result RES of function FN to be inlined into\n+   CALLER.  NDP points to an integer that should be set in case a new\n+   declaration wasn't created (presumably because RES was of aggregate\n+   type, such that a TARGET_EXPR is used for the result).  TEXPS is a\n+   pointer to a varray with the stack of TARGET_EXPRs seen while\n+   inlining functions into caller; the top of TEXPS is supposed to\n+   match RES.  */\n+\n+tree\n+tree_inlining_default_hook_copy_res_decl_for_inlining (res, fn, caller,\n+\t\t\t\t\t\t       dm, ndp, texps)\n+     tree res, fn, caller;\n+     void *dm ATTRIBUTE_UNUSED;\n+     int *ndp ATTRIBUTE_UNUSED;\n+     void *texps ATTRIBUTE_UNUSED;\n+{\n+  return copy_decl_for_inlining (res, fn, caller);\n+}\n+\n+/* lang_hooks.tree_inlining.anon_aggr_type_p determines whether T is a\n+   type node representing an anonymous aggregate (union, struct, etc),\n+   i.e., one whose members are in the same scope as the union itself.  */\n+\n+int\n+tree_inlining_default_hook_anon_aggr_type_p (t)\n+     tree t ATTRIBUTE_UNUSED;\n+{\n+  return 0;\n+}\n+"}, {"sha": "43335fa2ba6a422096e8ea5ad1e58eea22e4067f", "filename": "gcc/langhooks.h", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=69dcadffbabaf5fd3b0fa3f14b5de097c40a2751", "patch": "@@ -0,0 +1,114 @@\n+/* Macros to initialize the lang_hooks data structure.\n+   Copyright 2001 Free Software Foundation, Inc.\n+   Contributed by Alexandre Oliva  <aoliva@redhat.com>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifndef GCC_LANG_HOOKS_H\n+#define GCC_LANG_HOOKS_H\n+\n+/* Older hooks, that don't go in sub-structures for backward\n+   compatibility.  */\n+#ifndef LANG_HOOKS_INIT\n+#define LANG_HOOKS_INIT NULL\n+#endif\n+#ifndef LANG_HOOKS_FINISH\n+#define LANG_HOOKS_FINISH NULL\n+#endif\n+#ifndef LANG_HOOKS_INIT_OPTIONS\n+#define LANG_HOOKS_INIT_OPTIONS NULL\n+#endif\n+#ifndef LANG_HOOKS_DECODE_OPTION\n+#define LANG_HOOKS_DECODE_OPTION NULL\n+#endif\n+#ifndef LANG_HOOKS_POST_OPTIONS\n+#define LANG_HOOKS_POST_OPTIONS NULL\n+#endif\n+\n+/* Declarations of default tree inlining hooks.  */\n+tree tree_inlining_default_hook_walk_subtrees PARAMS ((tree*, int *,\n+\t\t\t\t\t\t       walk_tree_fn,\n+\t\t\t\t\t\t       void *, void *));\n+int tree_inlining_default_hook_cannot_inline_tree_fn PARAMS ((tree*));\n+int tree_inlining_default_hook_disregard_inline_limits PARAMS ((tree));\n+tree tree_inlining_default_hook_add_pending_fn_decls PARAMS ((void*, tree));\n+int tree_inlining_default_hook_tree_chain_matters_p PARAMS ((tree));\n+int tree_inlining_default_hook_auto_var_in_fn_p PARAMS ((tree, tree));\n+tree tree_inlining_default_hook_copy_res_decl_for_inlining PARAMS ((tree, tree,\n+\t\t\t\t\t\t\t\t    tree,\n+\t\t\t\t\t\t\t\t    void *,\n+\t\t\t\t\t\t\t\t    int *,\n+\t\t\t\t\t\t\t\t    void *));\n+int tree_inlining_default_hook_anon_aggr_type_p PARAMS ((tree));\n+\n+/* Tree inlining hooks.  */\n+#ifndef LANG_HOOKS_TREE_INLINING_WALK_SUBTREES\n+#define LANG_HOOKS_TREE_INLINING_WALK_SUBTREES \\\n+  tree_inlining_default_hook_walk_subtrees\n+#endif\n+#ifndef LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN\n+#define LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN \\\n+  tree_inlining_default_hook_cannot_inline_tree_fn\n+#endif\n+#ifndef LANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS\n+#define LANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS \\\n+  tree_inlining_default_hook_disregard_inline_limits\n+#endif\n+#ifndef LANG_HOOKS_TREE_INLINING_ADD_PENDING_FN_DECLS\n+#define LANG_HOOKS_TREE_INLINING_ADD_PENDING_FN_DECLS \\\n+  tree_inlining_default_hook_add_pending_fn_decls\n+#endif\n+#ifndef LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P\n+#define LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P \\\n+  tree_inlining_default_hook_tree_chain_matters_p\n+#endif\n+#ifndef LANG_HOOKS_TREE_INLINING_AUTO_VAR_IN_FN_P\n+#define LANG_HOOKS_TREE_INLINING_AUTO_VAR_IN_FN_P \\\n+  tree_inlining_default_hook_auto_var_in_fn_p\n+#endif\n+#ifndef LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING\n+#define LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING \\\n+  tree_inlining_default_hook_copy_res_decl_for_inlining\n+#endif\n+#ifndef LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P\n+#define LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P \\\n+  tree_inlining_default_hook_anon_aggr_type_p\n+#endif\n+\n+#define LANG_HOOKS_TREE_INLINING_INITIALIZER { \\\n+  LANG_HOOKS_TREE_INLINING_WALK_SUBTREES, \\\n+  LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN, \\\n+  LANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS, \\\n+  LANG_HOOKS_TREE_INLINING_ADD_PENDING_FN_DECLS, \\\n+  LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P, \\\n+  LANG_HOOKS_TREE_INLINING_AUTO_VAR_IN_FN_P, \\\n+  LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING, \\\n+  LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P \\\n+} \\\n+\n+/* The whole thing.  The structure is defined in toplev.h.  */\n+#define LANG_HOOKS_INITIALIZER { \\\n+  LANG_HOOKS_INIT, \\\n+  LANG_HOOKS_FINISH, \\\n+  LANG_HOOKS_INIT_OPTIONS, \\\n+  LANG_HOOKS_DECODE_OPTION, \\\n+  LANG_HOOKS_POST_OPTIONS, \\\n+  LANG_HOOKS_TREE_INLINING_INITIALIZER \\\n+}\n+\n+#endif /* GCC_LANG_HOOKS_H */"}, {"sha": "72fa2fd640aba41e4190cbc5cdc64fa1e4a1ca14", "filename": "gcc/toplev.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=69dcadffbabaf5fd3b0fa3f14b5de097c40a2751", "patch": "@@ -115,7 +115,31 @@ extern void check_global_declarations   PARAMS ((union tree_node **, int));\n extern const char *progname;\n extern const char *dump_base_name;\n \n+/* The following hooks are documented in langhooks.c.  Must not be\n+   NULL.  */\n+\n+struct lang_hooks_for_tree_inlining\n+{\n+  union tree_node *(*walk_subtrees) PARAMS ((union tree_node **, int *,\n+\t\t\t\t\t     union tree_node *(*)\n+\t\t\t\t\t     (union tree_node **,\n+\t\t\t\t\t      int *, void *),\n+\t\t\t\t\t     void *, void *));\n+  int (*cannot_inline_tree_fn) PARAMS ((union tree_node **));\n+  int (*disregard_inline_limits) PARAMS ((union tree_node *));\n+  union tree_node *(*add_pending_fn_decls) PARAMS ((void*, union tree_node *));\n+  int (*tree_chain_matters_p) PARAMS ((union tree_node *));\n+  int (*auto_var_in_fn_p) PARAMS ((union tree_node *, union tree_node *));\n+  union tree_node *(*copy_res_decl_for_inlining) PARAMS ((union tree_node *,\n+\t\t\t\t\t\t\t  union tree_node *,\n+\t\t\t\t\t\t\t  union tree_node *,\n+\t\t\t\t\t\t\t  void *, int *,\n+\t\t\t\t\t\t\t  void *));\n+  int (*anon_aggr_type_p) PARAMS ((union tree_node *));\n+};\n+\n /* Language-specific hooks.  Can be NULL unless otherwise specified.  */\n+\n struct lang_hooks\n {\n   /* Called first, to initialize the front end.  */\n@@ -141,6 +165,11 @@ struct lang_hooks\n \n   /* Called when all command line options have been processed.  */\n   void (*post_options) PARAMS ((void));\n+\n+  struct lang_hooks_for_tree_inlining tree_inlining;\n+\n+  /* Whenever you add entries here, make sure you adjust langhooks.h\n+     and langhooks.c accordingly.  */\n };\n \n /* Each front end provides its own.  */"}, {"sha": "da3f93adc02cdc05abdd0d7b0b3cec1ef16fee63", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=69dcadffbabaf5fd3b0fa3f14b5de097c40a2751", "patch": "@@ -21,6 +21,7 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n+#include \"toplev.h\"\n #include \"tree.h\"\n #include \"tree-inline.h\"\n #include \"rtl.h\"\n@@ -38,17 +39,6 @@ Boston, MA 02111-1307, USA.  */\n    this would require a shared function-as-trees infrastructure.  */\n #include \"c-common.h\" \n \n-/* Definitions of language hooks.  */\n-\n-treeopt_walk_subtrees_type *lang_walk_subtrees;\n-treeopt_cannot_inline_tree_fn_type *lang_cannot_inline_tree_fn;\n-treeopt_disregard_inline_limits_type *lang_disregard_inline_limits;\n-treeopt_add_pending_fn_decls_type *lang_add_pending_fn_decls;\n-treeopt_tree_chain_matters_p_type *lang_tree_chain_matters_p;\n-treeopt_auto_var_in_fn_p_type *lang_auto_var_in_fn_p;\n-treeopt_copy_res_decl_for_inlining_type *lang_copy_res_decl_for_inlining;\n-treeopt_anon_aggr_type_p *lang_anon_aggr_type_p;\n-\n /* 0 if we should not perform inlining.\n    1 if we should expand functions calls inline at the tree level.  \n    2 if we should consider *all* functions to be inline \n@@ -139,7 +129,7 @@ remap_decl (decl, id)\n \n   /* We only remap local variables in the current function.  */\n   fn = VARRAY_TOP_TREE (id->fns);\n-  if (! LANG_AUTO_VAR_IN_FN_P (decl, fn))\n+  if (! (*lang_hooks.tree_inlining.auto_var_in_fn_p) (decl, fn))\n     return NULL_TREE;\n \n   /* See if we have remapped this declaration.  */\n@@ -170,7 +160,7 @@ remap_decl (decl, id)\n \t}\n \n       if (! DECL_NAME (t) && TREE_TYPE (t)\n-\t  && LANG_ANON_AGGR_TYPE_P (TREE_TYPE (t)))\n+\t  && (*lang_hooks.tree_inlining.anon_aggr_type_p) (TREE_TYPE (t)))\n \t{\n \t  /* For a VAR_DECL of anonymous type, we must also copy the\n \t     member VAR_DECLS here and rechain the\n@@ -381,7 +371,7 @@ copy_body_r (tp, walk_subtrees, data)\n      variables.  We don't want to copy static variables; there's only\n      one of those, no matter how many times we inline the containing\n      function.  */\n-  else if (LANG_AUTO_VAR_IN_FN_P (*tp, fn))\n+  else if ((*lang_hooks.tree_inlining.auto_var_in_fn_p) (*tp, fn))\n     {\n       tree new_decl;\n \n@@ -423,7 +413,8 @@ copy_body_r (tp, walk_subtrees, data)\n \t}\n       else if (TREE_CODE (*tp) == MODIFY_EXPR\n \t       && TREE_OPERAND (*tp, 0) == TREE_OPERAND (*tp, 1)\n-\t       && LANG_AUTO_VAR_IN_FN_P (TREE_OPERAND (*tp, 0), fn))\n+\t       && ((*lang_hooks.tree_inlining.auto_var_in_fn_p)\n+\t\t   (TREE_OPERAND (*tp, 0), fn)))\n \t{\n \t  /* Some assignments VAR = VAR; don't generate any rtl code\n \t     and thus don't count as variable modification.  Avoid\n@@ -614,9 +605,9 @@ declare_return_variable (id, use_stmt)\n       return NULL_TREE;\n     }\n \n-  var = LANG_COPY_RES_DECL_FOR_INLINING (result, fn, VARRAY_TREE (id->fns, 0),\n-\t\t\t\t\t id->decl_map, &need_return_decl,\n-\t\t\t\t\t &id->target_exprs);\n+  var = ((*lang_hooks.tree_inlining.copy_res_decl_for_inlining)\n+\t (result, fn, VARRAY_TREE (id->fns, 0), id->decl_map,\n+\t  &need_return_decl, &id->target_exprs));\n \n   /* Register the VAR_DECL as the equivalent for the RESULT_DECL; that\n      way, when the RESULT_DECL is encountered, it will be\n@@ -682,7 +673,7 @@ inlinable_function_p (fn, id)\n   /* We can't inline functions that are too big.  Only allow a single\n      function to eat up half of our budget.  Make special allowance\n      for extern inline functions, though.  */\n-  else if (! LANG_DISREGARD_INLINE_LIMITS (fn)\n+  else if (! (*lang_hooks.tree_inlining.disregard_inline_limits) (fn)\n \t   && DECL_NUM_STMTS (fn) * INSNS_PER_STMT > MAX_INLINE_INSNS / 2)\n     ;\n   /* All is well.  We can inline this function.  Traditionally, GCC\n@@ -699,13 +690,13 @@ inlinable_function_p (fn, id)\n      be that we've done so much inlining already that we don't want to\n      risk too much inlining any more and thus halve the acceptable\n      size.  */\n-  if (! LANG_DISREGARD_INLINE_LIMITS (fn)\n+  if (! (*lang_hooks.tree_inlining.disregard_inline_limits) (fn)\n       && ((DECL_NUM_STMTS (fn) + (id ? id->inlined_stmts : 0)) * INSNS_PER_STMT\n \t  > MAX_INLINE_INSNS)\n       && DECL_NUM_STMTS (fn) * INSNS_PER_STMT > MAX_INLINE_INSNS / 4)\n     inlinable = 0;\n \n-  if (inlinable && LANG_CANNOT_INLINE_TREE_FN (&fn))\n+  if (inlinable && (*lang_hooks.tree_inlining.cannot_inline_tree_fn) (&fn))\n     inlinable = 0;\n   \n   /* If we don't have the function body available, we can't inline\n@@ -999,7 +990,8 @@ optimize_inline_calls (fn)\n       prev_fn = current_function_decl;\n     }\n \n-  prev_fn = LANG_ADD_PENDING_FN_DECLS (&id.fns, prev_fn);\n+  prev_fn = ((*lang_hooks.tree_inlining.add_pending_fn_decls)\n+\t     (&id.fns, prev_fn));\n   \n   /* Create the stack of TARGET_EXPRs.  */\n   VARRAY_TREE_INIT (id.target_exprs, 32, \"target_exprs\");\n@@ -1124,7 +1116,7 @@ walk_tree (tp, func, data, htab_)\n   if (!walk_subtrees)\n     {\n       if (statement_code_p (code) || code == TREE_LIST\n-\t  || LANG_TREE_CHAIN_MATTERS_P (*tp))\n+\t  || (*lang_hooks.tree_inlining.tree_chain_matters_p) (*tp))\n \t/* But we still need to check our siblings.  */\n \treturn walk_tree (&TREE_CHAIN (*tp), func, data, htab);\n       else\n@@ -1188,7 +1180,8 @@ walk_tree (tp, func, data, htab_)\n       return NULL_TREE;\n     }\n \n-  result = LANG_WALK_SUBTREES (tp, &walk_subtrees, func, data, htab);\n+  result = (*lang_hooks.tree_inlining.walk_subtrees) (tp, &walk_subtrees, func,\n+\t\t\t\t\t\t      data, htab);\n   if (result || ! walk_subtrees)\n     return result;\n \n@@ -1316,7 +1309,7 @@ copy_tree_r (tp, walk_subtrees, data)\n       || TREE_CODE_CLASS (code) == 's'\n       || code == TREE_LIST\n       || code == TREE_VEC\n-      || LANG_TREE_CHAIN_MATTERS_P (*tp))\n+      || (*lang_hooks.tree_inlining.tree_chain_matters_p) (*tp))\n     {\n       /* Because the chain gets clobbered when we make a copy, we save it\n \t here.  */\n@@ -1328,7 +1321,7 @@ copy_tree_r (tp, walk_subtrees, data)\n       /* Now, restore the chain, if appropriate.  That will cause\n \t walk_tree to walk into the chain as well.  */\n       if (code == PARM_DECL || code == TREE_LIST\n-\t  || LANG_TREE_CHAIN_MATTERS_P (*tp)\n+\t  || (*lang_hooks.tree_inlining.tree_chain_matters_p) (*tp)\n \t  || statement_code_p (code))\n \tTREE_CHAIN (*tp) = chain;\n "}, {"sha": "e8bc90a626accd1b5685ef78d9c8011c37d5f72e", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69dcadffbabaf5fd3b0fa3f14b5de097c40a2751/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=69dcadffbabaf5fd3b0fa3f14b5de097c40a2751", "patch": "@@ -32,104 +32,6 @@ tree copy_tree_r PARAMS ((tree*, int*, void*));\n void clone_body PARAMS ((tree, tree, void*));\n void remap_save_expr PARAMS ((tree*, void*, tree, int*));\n \n-/* LANG_WALK_SUBTREES is called by walk_tree() after handling common\n-   cases, but before walking code-specific sub-trees.  If\n-   lang_walk_subtrees is defined for a language, it should handle\n-   language-specific tree codes, as well as language-specific\n-   information associated to common tree codes.  If a tree node is\n-   completely handled within this function, it should set *SUBTREES to\n-   0, so that generic handling isn't attempted.  For language-specific\n-   tree codes, generic handling would abort(), so make sure it is set\n-   properly.  Both SUBTREES and *SUBTREES is guaranteed to be non-zero\n-   when the function is called.  */\n-\n-#define LANG_WALK_SUBTREES(TP,SUBTREES,FUNC,DATA,HTAB) \\\n-  (lang_walk_subtrees \\\n-   ? (*lang_walk_subtrees)((TP),(SUBTREES),(FUNC),(DATA),(HTAB)) \\\n-   : 0)\n-typedef tree treeopt_walk_subtrees_type PARAMS ((tree*, int*, walk_tree_fn,\n-\t\t\t\t\t\t void*, void*));\n-extern treeopt_walk_subtrees_type *lang_walk_subtrees;\n-\n-/* LANG_CANNOT_INLINE_TREE_FN is called to determine whether there are\n-   language-specific reasons for not inlining a given function.  */\n-\n-#define LANG_CANNOT_INLINE_TREE_FN(FNP) \\\n-  (lang_cannot_inline_tree_fn ? (*lang_cannot_inline_tree_fn)(FNP) : 0)\n-typedef int treeopt_cannot_inline_tree_fn_type PARAMS ((tree*));\n-extern treeopt_cannot_inline_tree_fn_type *lang_cannot_inline_tree_fn;\n-\n-/* LANG_DISREGARD_INLINE_LIMITS is called to determine whether a\n-   function should be inlined even if it would exceed inlining limits.  */\n-\n-#define LANG_DISREGARD_INLINE_LIMITS(FN) \\\n-  (lang_disregard_inline_limits ? (*lang_disregard_inline_limits)(FN) : 0)\n-typedef int treeopt_disregard_inline_limits_type PARAMS ((tree));\n-extern treeopt_disregard_inline_limits_type *lang_disregard_inline_limits;\n-\n-/* LANG_ADD_PENDING_FN_DECLS is called before starting to inline a\n-   function, to push any language-specific functions that should not\n-   be inlined into the current function, into VAFNP.  PFN is the top\n-   of varray, and should be returned if no functions are pushed into\n-   VAFNP.  The top of the varray should be returned.  */\n-\n-#define LANG_ADD_PENDING_FN_DECLS(VAFNP,PFN) \\\n-  (lang_add_pending_fn_decls \\\n-   ? (*lang_add_pending_fn_decls)((VAFNP),(PFN)) \\\n-   : (PFN))\n-typedef tree treeopt_add_pending_fn_decls_type PARAMS ((void*,tree));\n-extern treeopt_add_pending_fn_decls_type *lang_add_pending_fn_decls;\n-\n-/* LANG_TREE_CHAIN_MATTERS_P indicates whether the TREE_CHAIN of a\n-   language-specific tree node is relevant, i.e., whether it should be\n-   walked, copied and preserved across copies.  */\n-\n-#define LANG_TREE_CHAIN_MATTERS_P(T) \\\n-  (lang_tree_chain_matters_p ? (*lang_tree_chain_matters_p)(T) : 0)\n-typedef int treeopt_tree_chain_matters_p_type PARAMS ((tree));\n-extern treeopt_tree_chain_matters_p_type *lang_tree_chain_matters_p;\n-\n-/* LANG_AUTO_VAR_IN_FN_P is called to determine whether VT is an\n-   automatic variable defined in function FT.  */\n-\n-#define LANG_AUTO_VAR_IN_FN_P(VT,FT) \\\n-  (lang_auto_var_in_fn_p ? (*lang_auto_var_in_fn_p)((VT),(FT)) \\\n-   : (DECL_P (VT) && DECL_CONTEXT (VT) == (FT) \\\n-      && (((TREE_CODE (VT) == VAR_DECL || TREE_CODE (VT) == PARM_DECL) \\\n-\t   && ! TREE_STATIC (VT)) \\\n-\t  || TREE_CODE (VT) == LABEL_DECL \\\n-\t  || TREE_CODE (VT) == RESULT_DECL)))\n-typedef int treeopt_auto_var_in_fn_p_type PARAMS ((tree,tree));\n-extern treeopt_auto_var_in_fn_p_type *lang_auto_var_in_fn_p;\n-\n-/* LANG_COPY_RES_DECL_FOR_INLINING should return a declaration for the\n-   result RES of function FN to be inlined into CALLER.  NDP points to\n-   an integer that should be set in case a new declaration wasn't\n-   created (presumably because RES was of aggregate type, such that a\n-   TARGET_EXPR is used for the result).  TEXPS is a pointer to a\n-   varray with the stack of TARGET_EXPRs seen while inlining functions\n-   into caller; the top of TEXPS is supposed to match RES.  */\n-\n-#define LANG_COPY_RES_DECL_FOR_INLINING(RES,FN,CALLER,DM,NDP,TEXPS) \\\n-  (lang_copy_res_decl_for_inlining \\\n-   ? (*lang_copy_res_decl_for_inlining)((RES),(FN),(CALLER),\\\n-\t\t\t\t\t(DM),(NDP),(TEXPS)) \\\n-   : copy_decl_for_inlining ((RES), (FN), (CALLER)))\n-typedef tree treeopt_copy_res_decl_for_inlining_type PARAMS ((tree, tree,\n-\t\t\t\t\t\t\t      tree, void*,\n-\t\t\t\t\t\t\t      int*, void*));\n-extern treeopt_copy_res_decl_for_inlining_type\n-*lang_copy_res_decl_for_inlining;\n-\n-/* LANG_ANON_AGGR_TYPE_P determines whether T is a type node\n-   representing an anonymous aggregate (union, struct, etc), i.e., one\n-   whose members are in the same scope as the union itself.  */\n-\n-#define LANG_ANON_AGGR_TYPE_P(T) \\\n-  (lang_anon_aggr_type_p ? (*lang_anon_aggr_type_p)(T) : 0)\n-typedef int treeopt_anon_aggr_type_p PARAMS ((tree));\n-extern treeopt_anon_aggr_type_p *lang_anon_aggr_type_p;\n-\n /* 0 if we should not perform inlining.\n    1 if we should expand functions calls inline at the tree level.  \n    2 if we should consider *all* functions to be inline "}]}