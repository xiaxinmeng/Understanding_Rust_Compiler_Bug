{"sha": "74c176ca2f1fe702f6e46d86f634685480094335", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRjMTc2Y2EyZjFmZTcwMmY2ZTQ2ZDg2ZjYzNDY4NTQ4MDA5NDMzNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-08-24T20:06:52Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-08-24T20:10:26Z"}, "message": "libbacktrace: add Mach-O 64-bit FAT support\n\nlibbacktrace/:\n\t* macho.c (MACH_O_MH_MAGIC_FAT_64): Define.\n\t(MACH_O_MH_CIGAM_FAT_64): Define.\n\t(struct macho_fat_arch_64): Define.\n\t(macho_add_fat): Add and use is_64 parameter.\n\t(macho_add): Recognize 64-bit fat files.", "tree": {"sha": "63cf9c645ec97c8e98b4535e8187bc29732c73b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63cf9c645ec97c8e98b4535e8187bc29732c73b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74c176ca2f1fe702f6e46d86f634685480094335", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74c176ca2f1fe702f6e46d86f634685480094335", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74c176ca2f1fe702f6e46d86f634685480094335", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74c176ca2f1fe702f6e46d86f634685480094335/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d166f4a8773a43d925be006e713b7d81626ddb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d166f4a8773a43d925be006e713b7d81626ddb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d166f4a8773a43d925be006e713b7d81626ddb9"}], "stats": {"total": 72, "additions": 54, "deletions": 18}, "files": [{"sha": "bd737226ca62fe829341d90a69ecd64ce62b5c04", "filename": "libbacktrace/macho.c", "status": "modified", "additions": 54, "deletions": 18, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74c176ca2f1fe702f6e46d86f634685480094335/libbacktrace%2Fmacho.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74c176ca2f1fe702f6e46d86f634685480094335/libbacktrace%2Fmacho.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fmacho.c?ref=74c176ca2f1fe702f6e46d86f634685480094335", "patch": "@@ -75,7 +75,7 @@ struct macho_header_64\n \n struct macho_header_fat\n {\n-  uint32_t magic;\t/* Magic number (MACH_O_MH_MAGIC_FAT) */\n+  uint32_t magic;\t/* Magic number (MACH_O_MH_(MAGIC|CIGAM)_FAT(_64)?) */\n   uint32_t nfat_arch;   /* Number of components */\n };\n \n@@ -85,6 +85,8 @@ struct macho_header_fat\n #define MACH_O_MH_MAGIC_64\t0xfeedfacf\n #define MACH_O_MH_MAGIC_FAT\t0xcafebabe\n #define MACH_O_MH_CIGAM_FAT\t0xbebafeca\n+#define MACH_O_MH_MAGIC_FAT_64\t0xcafebabf\n+#define MACH_O_MH_CIGAM_FAT_64\t0xbfbafeca\n \n /* Value for the header filetype field.  */\n \n@@ -105,6 +107,20 @@ struct macho_fat_arch\n   uint32_t align;\t/* Alignment of this entry */\n };\n \n+/* A component of a 64-bit fat file.  This is used if the magic field\n+   is MAGIC_FAT_64.  This is only used when some file size or file\n+   offset is too large to represent in the 32-bit format.  */\n+\n+struct macho_fat_arch_64\n+{\n+  uint32_t cputype;\t/* CPU type */\n+  uint32_t cpusubtype;\t/* CPU subtype */\n+  uint64_t offset;\t/* File offset of this entry */\n+  uint64_t size;\t/* Size of this entry */\n+  uint32_t align;\t/* Alignment of this entry */\n+  uint32_t reserved;\t/* Reserved */\n+};\n+\n /* Values for the fat_arch cputype field (and the header cputype\n    field).  */\n \n@@ -740,14 +756,14 @@ static int\n macho_add_fat (struct backtrace_state *state, const char *filename,\n \t       int descriptor, int swapped, off_t offset,\n \t       const unsigned char *match_uuid, uintptr_t base_address,\n-\t       int skip_symtab, uint32_t nfat_arch,\n+\t       int skip_symtab, uint32_t nfat_arch, int is_64,\n \t       backtrace_error_callback error_callback, void *data,\n \t       fileline *fileline_fn, int *found_sym)\n {\n   int arch_view_valid;\n   unsigned int cputype;\n+  size_t arch_size;\n   struct backtrace_view arch_view;\n-  size_t archoffset;\n   unsigned int i;\n \n   arch_view_valid = 0;\n@@ -765,41 +781,57 @@ macho_add_fat (struct backtrace_state *state, const char *filename,\n   goto fail;\n #endif\n \n+  if (is_64)\n+    arch_size = sizeof (struct macho_fat_arch_64);\n+  else\n+    arch_size = sizeof (struct macho_fat_arch);\n+\n   if (!backtrace_get_view (state, descriptor, offset,\n-\t\t\t   nfat_arch * sizeof (struct macho_fat_arch),\n+\t\t\t   nfat_arch * arch_size,\n \t\t\t   error_callback, data, &arch_view))\n     goto fail;\n \n-  archoffset = 0;\n   for (i = 0; i < nfat_arch; ++i)\n     {\n-      struct macho_fat_arch fat_arch;\n+      struct macho_fat_arch_64 fat_arch;\n       uint32_t fcputype;\n \n-      memcpy (&fat_arch,\n-\t      ((const char *) arch_view.data\n-\t       + i * sizeof (struct macho_fat_arch)),\n-\t      sizeof fat_arch);\n+      if (is_64)\n+\tmemcpy (&fat_arch,\n+\t\t(const char *) arch_view.data + i * arch_size,\n+\t\tarch_size);\n+      else\n+\t{\n+\t  struct macho_fat_arch fat_arch_32;\n+\n+\t  memcpy (&fat_arch_32,\n+\t\t  (const char *) arch_view.data + i * arch_size,\n+\t\t  arch_size);\n+\t  fat_arch.cputype = fat_arch_32.cputype;\n+\t  fat_arch.cpusubtype = fat_arch_32.cpusubtype;\n+\t  fat_arch.offset = (uint64_t) fat_arch_32.offset;\n+\t  fat_arch.size = (uint64_t) fat_arch_32.size;\n+\t  fat_arch.align = fat_arch_32.align;\n+\t  fat_arch.reserved = 0;\n+\t}\n \n       fcputype = fat_arch.cputype;\n       if (swapped)\n \tfcputype = __builtin_bswap32 (fcputype);\n \n       if (fcputype == cputype)\n \t{\n-\t  uint32_t foffset;\n+\t  uint64_t foffset;\n \n \t  /* FIXME: What about cpusubtype?  */\n \t  foffset = fat_arch.offset;\n \t  if (swapped)\n-\t    foffset = __builtin_bswap32 (foffset);\n+\t    foffset = __builtin_bswap64 (foffset);\n \t  backtrace_release_view (state, &arch_view, error_callback, data);\n \t  return macho_add (state, filename, descriptor, foffset, match_uuid,\n \t\t\t    base_address, skip_symtab, error_callback, data,\n \t\t\t    fileline_fn, found_sym);\n \t}\n-\n-      archoffset += sizeof (struct macho_fat_arch);\n     }\n \n   error_callback (data, \"could not find executable in fat file\", 0);\n@@ -980,17 +1012,20 @@ macho_add (struct backtrace_state *state, const char *filename, int descriptor,\n       hdroffset = offset + sizeof (struct macho_header_64);\n       break;\n     case MACH_O_MH_MAGIC_FAT:\n+    case MACH_O_MH_MAGIC_FAT_64:\n       {\n \tstruct macho_header_fat fat_header;\n \n \thdroffset = offset + sizeof (struct macho_header_fat);\n \tmemcpy (&fat_header, &header, sizeof fat_header);\n \treturn macho_add_fat (state, filename, descriptor, 0, hdroffset,\n \t\t\t      match_uuid, base_address, skip_symtab,\n-\t\t\t      fat_header.nfat_arch, error_callback, data,\n-\t\t\t      fileline_fn, found_sym);\n+\t\t\t      fat_header.nfat_arch,\n+\t\t\t      header.magic == MACH_O_MH_MAGIC_FAT_64,\n+\t\t\t      error_callback, data, fileline_fn, found_sym);\n       }\n     case MACH_O_MH_CIGAM_FAT:\n+    case MACH_O_MH_CIGAM_FAT_64:\n       {\n \tstruct macho_header_fat fat_header;\n \tuint32_t nfat_arch;\n@@ -1000,8 +1035,9 @@ macho_add (struct backtrace_state *state, const char *filename, int descriptor,\n \tnfat_arch = __builtin_bswap32 (fat_header.nfat_arch);\n \treturn macho_add_fat (state, filename, descriptor, 1, hdroffset,\n \t\t\t      match_uuid, base_address, skip_symtab,\n-\t\t\t      nfat_arch, error_callback, data,\n-\t\t\t      fileline_fn, found_sym);\n+\t\t\t      nfat_arch,\n+\t\t\t      header.magic == MACH_O_MH_CIGAM_FAT_64,\n+\t\t\t      error_callback, data, fileline_fn, found_sym);\n       }\n     default:\n       error_callback (data, \"executable file is not in Mach-O format\", 0);"}]}