{"sha": "ae1152e5a01301c9dfec42fc5c117a9b782e353e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWUxMTUyZTVhMDEzMDFjOWRmZWM0MmZjNWMxMTdhOWI3ODJlMzUzZQ==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@st.com", "date": "2019-09-10T07:55:20Z"}, "committer": {"name": "Christophe Lyon", "email": "clyon@gcc.gnu.org", "date": "2019-09-10T07:55:20Z"}, "message": "[ARM/FDPIC v6 11/24] [ARM] FDPIC: Add support to unwind FDPIC signal frame\n\n2019-09-10  Christophe Lyon  <christophe.lyon@st.com>\n\tMicka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n\n\tlibgcc/\n\t* unwind-arm-common.inc (ARM_SET_R7_RT_SIGRETURN)\n\t(THUMB2_SET_R7_RT_SIGRETURN, FDPIC_LDR_R12_WITH_FUNCDESC)\n\t(FDPIC_LDR_R9_WITH_GOT, FDPIC_LDR_PC_WITH_RESTORER)\n\t(FDPIC_FUNCDESC_OFFSET, ARM_NEW_RT_SIGFRAME_UCONTEXT)\n\t(ARM_UCONTEXT_SIGCONTEXT, ARM_SIGCONTEXT_R0, FDPIC_T2_LDR_R12_WITH_FUNCDESC)\n\t(FDPIC_T2_LDR_R9_WITH_GOT, FDPIC_T2_LDR_PC_WITH_RESTORER): New.\n\t(__gnu_personality_sigframe_fdpic): New.\n\t(get_eit_entry): Add FDPIC signal frame support.\n\n\nCo-Authored-By: Micka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n\nFrom-SVN: r275573", "tree": {"sha": "960df666fc8fc26596e053be23670e2914ec724d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/960df666fc8fc26596e053be23670e2914ec724d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae1152e5a01301c9dfec42fc5c117a9b782e353e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae1152e5a01301c9dfec42fc5c117a9b782e353e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae1152e5a01301c9dfec42fc5c117a9b782e353e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae1152e5a01301c9dfec42fc5c117a9b782e353e/comments", "author": null, "committer": null, "parents": [{"sha": "e844c94f2a178b8f529a484ed0600b546c59c549", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e844c94f2a178b8f529a484ed0600b546c59c549", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e844c94f2a178b8f529a484ed0600b546c59c549"}], "stats": {"total": 135, "additions": 135, "deletions": 0}, "files": [{"sha": "d6d73e9660b81271bb37ad5dc5dc29fd2ab068fc", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae1152e5a01301c9dfec42fc5c117a9b782e353e/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae1152e5a01301c9dfec42fc5c117a9b782e353e/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=ae1152e5a01301c9dfec42fc5c117a9b782e353e", "patch": "@@ -1,3 +1,16 @@\n+2019-09-10  Christophe Lyon  <christophe.lyon@st.com>\n+\tMicka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n+\n+\tlibgcc/\n+\t* unwind-arm-common.inc (ARM_SET_R7_RT_SIGRETURN)\n+\t(THUMB2_SET_R7_RT_SIGRETURN, FDPIC_LDR_R12_WITH_FUNCDESC)\n+\t(FDPIC_LDR_R9_WITH_GOT, FDPIC_LDR_PC_WITH_RESTORER)\n+\t(FDPIC_FUNCDESC_OFFSET, ARM_NEW_RT_SIGFRAME_UCONTEXT)\n+\t(ARM_UCONTEXT_SIGCONTEXT, ARM_SIGCONTEXT_R0, FDPIC_T2_LDR_R12_WITH_FUNCDESC)\n+\t(FDPIC_T2_LDR_R9_WITH_GOT, FDPIC_T2_LDR_PC_WITH_RESTORER): New.\n+\t(__gnu_personality_sigframe_fdpic): New.\n+\t(get_eit_entry): Add FDPIC signal frame support.\n+\n 2019-09-10  Christophe Lyon  <christophe.lyon@st.com>\n \tMicka\u00ebl Gu\u00ean\u00e9 <mickael.guene@st.com>\n "}, {"sha": "c9a82b79bc85743fdcaa1e7855c9f2114bb3d1a6", "filename": "libgcc/unwind-arm-common.inc", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae1152e5a01301c9dfec42fc5c117a9b782e353e/libgcc%2Funwind-arm-common.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae1152e5a01301c9dfec42fc5c117a9b782e353e/libgcc%2Funwind-arm-common.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-arm-common.inc?ref=ae1152e5a01301c9dfec42fc5c117a9b782e353e", "patch": "@@ -30,6 +30,26 @@\n #include <sys/sdt.h>\n #endif\n \n+#if __FDPIC__\n+/* Load r7 with rt_sigreturn value.  */\n+#define ARM_SET_R7_RT_SIGRETURN\t\t0xe3a070ad\t/* mov   r7, #0xad */\n+#define THUMB2_SET_R7_RT_SIGRETURN\t0x07adf04f\t/* mov.w r7, #0xad */\n+\n+/* FDPIC jump to restorer sequence.  */\n+#define FDPIC_LDR_R12_WITH_FUNCDESC\t0xe59fc004\t/* ldr   r12, [pc, #4] */\n+#define FDPIC_LDR_R9_WITH_GOT\t\t0xe59c9004\t/* ldr   r9, [r12, #4] */\n+#define FDPIC_LDR_PC_WITH_RESTORER\t0xe59cf000\t/* ldr   pc, [r12] */\n+#define FDPIC_T2_LDR_R12_WITH_FUNCDESC  0xc008f8df\t/* ldr.w r12, [pc, #8] */\n+#define FDPIC_T2_LDR_R9_WITH_GOT\t0x9004f8dc\t/* ldr.w r9, [r12, #4] */\n+#define FDPIC_T2_LDR_PC_WITH_RESTORER   0xf000f8dc\t/* ldr.w pc, [r12] */\n+#define FDPIC_FUNCDESC_OFFSET\t\t12\n+\n+/* Signal frame offsets.  */\n+#define ARM_NEW_RT_SIGFRAME_UCONTEXT\t0x80\n+#define ARM_UCONTEXT_SIGCONTEXT\t\t0x14\n+#define ARM_SIGCONTEXT_R0\t\t0xc\n+#endif\n+\n /* We add a prototype for abort here to avoid creating a dependency on\n    target headers.  */\n extern void abort (void);\n@@ -199,6 +219,45 @@ search_EIT_table (const __EIT_entry * table, int nrec, _uw return_address)\n     }\n }\n \n+#if __FDPIC__\n+/* VFP is not restored, but this is sufficient to allow unwinding.  */\n+static _Unwind_Reason_Code\n+__gnu_personality_sigframe_fdpic (_Unwind_State state,\n+\t\t\t\t  _Unwind_Control_Block *ucbp,\n+\t\t\t\t  _Unwind_Context *context)\n+{\n+    unsigned int sp;\n+    unsigned int pc;\n+    unsigned int funcdesc;\n+    unsigned int handler;\n+    unsigned int first_handler_instruction;\n+    int i;\n+\n+    _Unwind_VRS_Get (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32, &sp);\n+    _Unwind_VRS_Get (context, _UVRSC_CORE, R_PC, _UVRSD_UINT32, &pc);\n+\n+    funcdesc = *(unsigned int *)((pc & ~1) + FDPIC_FUNCDESC_OFFSET);\n+    handler = *(unsigned int *)(funcdesc);\n+    first_handler_instruction = *(unsigned int *)(handler & ~1);\n+\n+    /* Adjust SP to point to the start of registers according to\n+       signal type.  */\n+    if (first_handler_instruction == ARM_SET_R7_RT_SIGRETURN\n+\t|| first_handler_instruction == THUMB2_SET_R7_RT_SIGRETURN)\n+\tsp += ARM_NEW_RT_SIGFRAME_UCONTEXT\n+\t  + ARM_UCONTEXT_SIGCONTEXT\n+\t  + ARM_SIGCONTEXT_R0;\n+    else\n+\tsp += ARM_UCONTEXT_SIGCONTEXT\n+\t  + ARM_SIGCONTEXT_R0;\n+    /* Restore regs saved on stack by the kernel.  */\n+    for (i = 0; i < 16; i++)\n+\t_Unwind_VRS_Set (context, _UVRSC_CORE, i, _UVRSD_UINT32, sp + 4 * i);\n+\n+    return _URC_CONTINUE_UNWIND;\n+}\n+#endif\n+\n /* Find the exception index table eintry for the given address.\n    Fill in the relevant fields of the UCB.\n    Returns _URC_FAILURE if an error occurred, _URC_OK on success.  */\n@@ -222,6 +281,27 @@ get_eit_entry (_Unwind_Control_Block *ucbp, _uw return_address)\n \t\t\t\t\t\t\t    &nrec);\n       if (!eitp)\n \t{\n+#if __FDPIC__\n+\t  /* If we are unwinding a signal handler then perhaps we have\n+\t     reached a trampoline.  Try to detect jump to restorer\n+\t     sequence.  */\n+\t  _uw *pc = (_uw *)((return_address+2) & ~1);\n+\t  if ((pc[0] == FDPIC_LDR_R12_WITH_FUNCDESC\n+\t       && pc[1] == FDPIC_LDR_R9_WITH_GOT\n+\t       && pc[2] == FDPIC_LDR_PC_WITH_RESTORER)\n+\t      || (pc[0] == FDPIC_T2_LDR_R12_WITH_FUNCDESC\n+\t\t  && pc[1] == FDPIC_T2_LDR_R9_WITH_GOT\n+\t\t  && pc[2] == FDPIC_T2_LDR_PC_WITH_RESTORER))\n+\t    {\n+\t      struct funcdesc_t *funcdesc\n+\t\t= (struct funcdesc_t *) &__gnu_personality_sigframe_fdpic;\n+\n+\t      UCB_PR_ADDR (ucbp) = funcdesc->ptr;\n+\t      UCB_PR_GOT (ucbp) = funcdesc->got;\n+\n+\t      return _URC_OK;\n+\t    }\n+#endif\n \t  UCB_PR_ADDR (ucbp) = 0;\n \t  return _URC_FAILURE;\n \t}\n@@ -236,6 +316,27 @@ get_eit_entry (_Unwind_Control_Block *ucbp, _uw return_address)\n \n   if (!eitp)\n     {\n+#if __FDPIC__\n+      /* If we are unwinding a signal handler then perhaps we have\n+\t reached a trampoline.  Try to detect jump to restorer\n+\t sequence.  */\n+      _uw *pc = (_uw *)((return_address+2) & ~1);\n+      if ((pc[0] == FDPIC_LDR_R12_WITH_FUNCDESC\n+\t   && pc[1] == FDPIC_LDR_R9_WITH_GOT\n+\t   && pc[2] == FDPIC_LDR_PC_WITH_RESTORER)\n+\t  || (pc[0] == FDPIC_T2_LDR_R12_WITH_FUNCDESC\n+\t      && pc[1] == FDPIC_T2_LDR_R9_WITH_GOT\n+\t      && pc[2] == FDPIC_T2_LDR_PC_WITH_RESTORER))\n+\t{\n+\t  struct funcdesc_t *funcdesc\n+\t    = (struct funcdesc_t *) &__gnu_personality_sigframe_fdpic;\n+\n+\t  UCB_PR_ADDR (ucbp) = funcdesc->ptr;\n+\t  UCB_PR_GOT (ucbp) = funcdesc->got;\n+\n+\t  return _URC_OK;\n+\t}\n+#endif\n       UCB_PR_ADDR (ucbp) = 0;\n       return _URC_FAILURE;\n     }\n@@ -244,6 +345,27 @@ get_eit_entry (_Unwind_Control_Block *ucbp, _uw return_address)\n   /* Can this frame be unwound at all?  */\n   if (eitp->content == EXIDX_CANTUNWIND)\n     {\n+#if __FDPIC__\n+      /* If we are unwinding a signal handler then perhaps we have\n+\t reached a trampoline.  Try to detect jump to restorer\n+\t sequence.  */\n+      _uw *pc = (_uw *)((return_address+2) & ~1);\n+      if ((pc[0] == FDPIC_LDR_R12_WITH_FUNCDESC\n+\t   && pc[1] == FDPIC_LDR_R9_WITH_GOT\n+\t   && pc[2] == FDPIC_LDR_PC_WITH_RESTORER)\n+\t  || (pc[0] == FDPIC_T2_LDR_R12_WITH_FUNCDESC\n+\t      && pc[1] == FDPIC_T2_LDR_R9_WITH_GOT\n+\t      && pc[2] == FDPIC_T2_LDR_PC_WITH_RESTORER))\n+\t{\n+\t  struct funcdesc_t *funcdesc\n+\t    = (struct funcdesc_t *) &__gnu_personality_sigframe_fdpic;\n+\n+\t  UCB_PR_ADDR (ucbp) = funcdesc->ptr;\n+\t  UCB_PR_GOT (ucbp) = funcdesc->got;\n+\n+\t  return _URC_OK;\n+\t}\n+#endif\n       UCB_PR_ADDR (ucbp) = 0;\n       return _URC_END_OF_STACK;\n     }"}]}