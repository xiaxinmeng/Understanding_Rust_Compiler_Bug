{"sha": "e8beba1cfc761cc35762283b3b44a355ef05e25b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThiZWJhMWNmYzc2MWNjMzU3NjIyODNiM2I0NGEzNTVlZjA1ZTI1Yg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-01-05T11:29:10Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-01-05T11:29:10Z"}, "message": "explow, aarch64: Fix force-Pmode-to-mem for ILP32 [PR97269]\n\nThis patch fixes a mode/rtx mismatch for ILP32 targets in:\n\n\t  mem = force_const_mem (ptr_mode, imm);\n\nwhere imm can be Pmode rather than ptr_mode.\n\nThe patch uses convert_memory_address to convert the Pmode address\nto ptr_mode before the call.  However, immediate addresses can in\ngeneral contain unspecs, and convert_memory_address wasn't set up\nto handle those.\n\nThe patch therefore adds some generic unspec handling to\nconvert_memory_address_addr_space_1.  As the comment says, we can add\na target hook if this behaviour turns out to be wrong for some targets.\nBut I think what the patch does is a strict improvement over the status\nquo: without it, we would try to force the unspec into a register,\nbut nevertheless wrap the result in a (const ...).  That in turn\nwould be invalid rtl and seems bound to generate an ICE later.\n\nI tested the explow.c part using -fstack-protector with local hacks\nto force SYMBOL_FORCE_TO_MEM for UNSPEC_SALT_ADDR.\n\nFixes c-c++-common/torture/pr57945.c and various other tests.\n\ngcc/\n\tPR target/97269\n\t* explow.c (convert_memory_address_addr_space_1): Handle UNSPECs\n\tnested in CONSTs.\n\t* config/aarch64/aarch64.c (aarch64_expand_mov_immediate): Use\n\tconvert_memory_address to convert symbolic immediates to ptr_mode\n\tbefore forcing them to memory.", "tree": {"sha": "1b0898b7078689eaba6d6ec3b72e778f40f09c89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b0898b7078689eaba6d6ec3b72e778f40f09c89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8beba1cfc761cc35762283b3b44a355ef05e25b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8beba1cfc761cc35762283b3b44a355ef05e25b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8beba1cfc761cc35762283b3b44a355ef05e25b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8beba1cfc761cc35762283b3b44a355ef05e25b/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eac8675225c4cdae347a11089f2b0a22ce920965", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eac8675225c4cdae347a11089f2b0a22ce920965", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eac8675225c4cdae347a11089f2b0a22ce920965"}], "stats": {"total": 25, "additions": 24, "deletions": 1}, "files": [{"sha": "88106bbcaf80129565a584a243cca5b0334785fa", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8beba1cfc761cc35762283b3b44a355ef05e25b/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8beba1cfc761cc35762283b3b44a355ef05e25b/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=e8beba1cfc761cc35762283b3b44a355ef05e25b", "patch": "@@ -5224,8 +5224,11 @@ aarch64_expand_mov_immediate (rtx dest, rtx imm)\n       switch (sty)\n \t{\n \tcase SYMBOL_FORCE_TO_MEM:\n+\t  if (int_mode != ptr_mode)\n+\t    imm = convert_memory_address (ptr_mode, imm);\n+\n \t  if (const_offset != 0\n-\t      && targetm.cannot_force_const_mem (int_mode, imm))\n+\t      && targetm.cannot_force_const_mem (ptr_mode, imm))\n \t    {\n \t      gcc_assert (can_create_pseudo_p ());\n \t      base = aarch64_force_temporary (int_mode, dest, base);"}, {"sha": "b6da277f6896a75e66319ad326ec3d84f89fa073", "filename": "gcc/explow.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8beba1cfc761cc35762283b3b44a355ef05e25b/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8beba1cfc761cc35762283b3b44a355ef05e25b/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=e8beba1cfc761cc35762283b3b44a355ef05e25b", "patch": "@@ -378,6 +378,26 @@ convert_memory_address_addr_space_1 (scalar_int_mode to_mode ATTRIBUTE_UNUSED,\n \t}\n       break;\n \n+    case UNSPEC:\n+      /* Assume that all UNSPECs in a constant address can be converted\n+\t operand-by-operand.  We could add a target hook if some targets\n+\t require different behavior.  */\n+      if (in_const && GET_MODE (x) == from_mode)\n+\t{\n+\t  unsigned int n = XVECLEN (x, 0);\n+\t  rtvec v = gen_rtvec (n);\n+\t  for (unsigned int i = 0; i < n; ++i)\n+\t    {\n+\t      rtx op = XVECEXP (x, 0, i);\n+\t      if (GET_MODE (op) == from_mode)\n+\t\top = convert_memory_address_addr_space_1 (to_mode, op, as,\n+\t\t\t\t\t\t\t  in_const, no_emit);\n+\t      RTVEC_ELT (v, i) = op;\n+\t    }\n+\t  return gen_rtx_UNSPEC (to_mode, v, XINT (x, 1));\n+\t}\n+      break;\n+\n     default:\n       break;\n     }"}]}