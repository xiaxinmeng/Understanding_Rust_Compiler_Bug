{"sha": "f2f4ef82f2d1a9f54bb8715b1f8b884ed8e1322a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJmNGVmODJmMmQxYTlmNTRiYjg3MTViMWY4Yjg4NGVkOGUxMzIyYQ==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2007-06-06T10:21:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:21:37Z"}, "message": "utils2.c (build_allocator): Provide the extra arguments to make_aligning_type for super-aligned objects...\n\n2007-04-20  Olivier Hainque  <hainque@adacore.com>\n\t    Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* utils2.c (build_allocator): Provide the extra arguments to\n\tmake_aligning_type for super-aligned objects allocated from the default\n\tpool. Leave enough room for a pointer before the aligning field, and\n\tstore the system's allocator return value there.\n\t(build_call_alloc_dealloc): When releasing a super-aligned object,\n\tretrieve the system's allocator return value from where build_allocator\n\thas stored it, just ahead of the adjusted address we are passed.\n\t(build_call_raise): Handle properly the generation of line numbers when\n\tthe node is marked No_Location.\n\t(compare_elmt_bitpos): Use tree_int_cst_compare.  Stabilize the sort\n\tby using DECL_UID on ties.\n\t(build_binary_op) <EQ_EXPR>: Accept fat pointer types with the same\n\tmain variant.\n\t(build_call_raise): Handle converting exception into goto; support new\n\targument KIND.\n\t(build_component_ref): Add new arg to build_call_raise.\n\nFrom-SVN: r125383", "tree": {"sha": "a783d6f6dfd52504c36708b00f389ea1fcf3e4f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a783d6f6dfd52504c36708b00f389ea1fcf3e4f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2f4ef82f2d1a9f54bb8715b1f8b884ed8e1322a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2f4ef82f2d1a9f54bb8715b1f8b884ed8e1322a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2f4ef82f2d1a9f54bb8715b1f8b884ed8e1322a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2f4ef82f2d1a9f54bb8715b1f8b884ed8e1322a/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b3a22f38ea7617e609a73938d0db11cf4f77f5dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3a22f38ea7617e609a73938d0db11cf4f77f5dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3a22f38ea7617e609a73938d0db11cf4f77f5dc"}], "stats": {"total": 193, "additions": 143, "deletions": 50}, "files": [{"sha": "e49ba30e273e87be15acaabf2e61cc97a48110f9", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 143, "deletions": 50, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2f4ef82f2d1a9f54bb8715b1f8b884ed8e1322a/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2f4ef82f2d1a9f54bb8715b1f8b884ed8e1322a/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=f2f4ef82f2d1a9f54bb8715b1f8b884ed8e1322a", "patch": "@@ -833,19 +833,22 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t}\n \n       /* Otherwise, the base types must be the same unless the objects are\n-\t records.  If we have records, use the best type and convert both\n-\t operands to that type.  */\n+\t fat pointers or records.  If we have records, use the best type and\n+\t convert both operands to that type.  */\n       if (left_base_type != right_base_type)\n \t{\n-\t  if (TREE_CODE (left_base_type) == RECORD_TYPE\n-\t      && TREE_CODE (right_base_type) == RECORD_TYPE)\n+\t  if (TYPE_FAT_POINTER_P (left_base_type)\n+\t      && TYPE_FAT_POINTER_P (right_base_type)\n+\t      && TYPE_MAIN_VARIANT (left_base_type)\n+\t\t == TYPE_MAIN_VARIANT (right_base_type))\n+\t    best_type = left_base_type;\n+\t  else if (TREE_CODE (left_base_type) == RECORD_TYPE\n+\t\t   && TREE_CODE (right_base_type) == RECORD_TYPE)\n \t    {\n \t      /* The only way these are permitted to be the same is if both\n \t\t types have the same name.  In that case, one of them must\n \t\t not be self-referential.  Use that one as the best type.\n \t\t Even better is if one is of fixed size.  */\n-\t      best_type = NULL_TREE;\n-\n \t      gcc_assert (TYPE_NAME (left_base_type)\n \t\t\t  && (TYPE_NAME (left_base_type)\n \t\t\t      == TYPE_NAME (right_base_type)));\n@@ -860,12 +863,12 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t\tbest_type = right_base_type;\n \t      else\n \t\tgcc_unreachable ();\n-\n-\t      left_operand = convert (best_type, left_operand);\n-\t      right_operand = convert (best_type, right_operand);\n \t    }\n \t  else\n \t    gcc_unreachable ();\n+\n+\t  left_operand = convert (best_type, left_operand);\n+\t  right_operand = convert (best_type, right_operand);\n \t}\n \n       /* If we are comparing a fat pointer against zero, we need to\n@@ -1459,28 +1462,60 @@ build_call_0_expr (tree fundecl)\n \n    GNAT_NODE is the gnat node conveying the source location for which the\n    error should be signaled, or Empty in which case the error is signaled on\n-   the current ref_file_name/input_line.  */\n+   the current ref_file_name/input_line.\n+\n+   KIND says which kind of exception this is for\n+   (N_Raise_{Constraint,Storage,Program}_Error).  */\n \n tree\n-build_call_raise (int msg, Node_Id gnat_node)\n+build_call_raise (int msg, Node_Id gnat_node, char kind)\n {\n   tree fndecl = gnat_raise_decls[msg];\n+  tree label = get_exception_label (kind);\n+  tree filename;\n+  int line_number;\n+  const char *str;\n+  int len;\n+\n+  /* If this is to be done as a goto, handle that case.  */\n+  if (label)\n+    {\n+      Entity_Id local_raise = Get_Local_Raise_Call_Entity ();\n+      tree gnu_result = build1 (GOTO_EXPR, void_type_node, label);\n+\n+      /* If Local_Raise is present, generate\n+\t Local_Raise (exception'Identity);  */\n+      if (Present (local_raise))\n+\t{\n+\t  tree gnu_local_raise\n+\t    = gnat_to_gnu_entity (local_raise, NULL_TREE, 0);\n+\t  tree gnu_exception_entity\n+\t    = gnat_to_gnu_entity (Get_RT_Exception_Entity (msg), NULL_TREE, 0);\n+\t  tree gnu_call\n+\t    = build_call_1_expr (gnu_local_raise,\n+\t\t\t\t build_unary_op (ADDR_EXPR, NULL_TREE,\n+\t\t\t\t\t\t gnu_exception_entity));\n+\n+\t  gnu_result = build2 (COMPOUND_EXPR, void_type_node,\n+\t\t\t       gnu_call, gnu_result);}\n+\n+      return gnu_result;\n+    }\n \n-  const char *str\n+  str\n     = (Debug_Flag_NN || Exception_Locations_Suppressed)\n       ? \"\"\n-      : (gnat_node != Empty)\n+      : (gnat_node != Empty && Sloc (gnat_node) != No_Location)\n         ? IDENTIFIER_POINTER\n           (get_identifier (Get_Name_String\n \t\t\t   (Debug_Source_Name\n \t\t\t    (Get_Source_File_Index (Sloc (gnat_node))))))\n         : ref_filename;\n \n-  int len = strlen (str) + 1;\n-  tree filename = build_string (len, str);\n-\n-  int line_number\n-    = (gnat_node != Empty)\n+  len = strlen (str) + 1;\n+  filename = build_string (len, str);\n+  line_number\n+    = (gnat_node != Empty && Sloc (gnat_node) != No_Location)\n       ? Get_Logical_Line_Number (Sloc(gnat_node)) : input_line;\n \n   TREE_TYPE (filename)\n@@ -1502,16 +1537,12 @@ compare_elmt_bitpos (const PTR rt1, const PTR rt2)\n {\n   tree elmt1 = * (tree *) rt1;\n   tree elmt2 = * (tree *) rt2;\n+  tree field1 = TREE_PURPOSE (elmt1);\n+  tree field2 = TREE_PURPOSE (elmt2);\n+  int ret;\n \n-  tree pos_field1 = bit_position (TREE_PURPOSE (elmt1));\n-  tree pos_field2 = bit_position (TREE_PURPOSE (elmt2));\n-\n-  if (tree_int_cst_equal (pos_field1, pos_field2))\n-    return 0;\n-  else if (tree_int_cst_lt (pos_field1, pos_field2))\n-    return -1;\n-  else\n-    return 1;\n+  ret = tree_int_cst_compare (bit_position (field1), bit_position (field2));\n+  return ret ? ret : (int) (DECL_UID (field1) - DECL_UID (field2));\n }\n \n /* Return a CONSTRUCTOR of TYPE whose list is LIST.  */\n@@ -1552,13 +1583,11 @@ gnat_build_constructor (tree type, tree list)\n \n   /* For record types with constant components only, sort field list\n      by increasing bit position.  This is necessary to ensure the\n-     constructor can be output as static data, which the gimplifier\n-     might force in various circumstances. */\n+     constructor can be output as static data.  */\n   if (allconstant && TREE_CODE (type) == RECORD_TYPE && n_elmts > 1)\n     {\n       /* Fill an array with an element tree per index, and ask qsort to order\n \t them according to what a bitpos comparison function says.  */\n-\n       tree *gnu_arr = (tree *) alloca (sizeof (tree) * n_elmts);\n       int i;\n \n@@ -1568,7 +1597,6 @@ gnat_build_constructor (tree type, tree list)\n       qsort (gnu_arr, n_elmts, sizeof (tree), compare_elmt_bitpos);\n \n       /* Then reconstruct the list from the sorted array contents.  */\n-\n       list = NULL_TREE;\n       for (i = n_elmts - 1; i >= 0; i--)\n \t{\n@@ -1701,7 +1729,8 @@ build_component_ref (tree record_variable, tree component,\n      abort.  */\n   gcc_assert (field);\n   return build1 (NULL_EXPR, TREE_TYPE (field),\n-\t\t build_call_raise (CE_Discriminant_Check_Failed, Empty));\n+\t\t build_call_raise (CE_Discriminant_Check_Failed, Empty,\n+\t\t\t\t   N_Raise_Constraint_Error));\n }\n \f\n /* Build a GCC tree to call an allocation or deallocation function.\n@@ -1785,7 +1814,34 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n     }\n \n   else if (gnu_obj)\n-    return build_call_1_expr (free_decl, gnu_obj);\n+    {\n+      /* If the required alignement was greater than what malloc guarantees,\n+\t what we have in gnu_obj here is an address dynamically adjusted to\n+\t match the requirement (see build_allocator).  What we need to pass\n+\t to free is the initial underlying allocator's return value, which\n+\t has been stored just in front of the block we have.  */\n+      if (align > BIGGEST_ALIGNMENT)\n+\t{\n+\t  /* We set GNU_OBJ\n+\t     as * (void **)((void *)GNU_OBJ - (void *)sizeof(void *))\n+\t     in two steps: */\n+\n+\t  /* GNU_OBJ (void *) = (void *)GNU_OBJ - (void *)sizeof (void *))  */\n+\t  gnu_obj\n+\t    = build_binary_op (MINUS_EXPR, ptr_void_type_node,\n+\t\t\t       convert (ptr_void_type_node, gnu_obj),\n+\t\t\t       convert (ptr_void_type_node,\n+\t\t\t\t\tTYPE_SIZE_UNIT (ptr_void_type_node)));\n+\n+\t  /* GNU_OBJ (void *) = *(void **)GNU_OBJ  */\n+\t  gnu_obj\n+\t    = build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t      convert (build_pointer_type (ptr_void_type_node),\n+\t\t\t\t       gnu_obj));\n+\t}\n+\n+      return build_call_1_expr (free_decl, gnu_obj);\n+    }\n \n   /* ??? For now, disable variable-sized allocators in the stack since\n      we can't yet gimplify an ALLOCATE_EXPR.  */\n@@ -1936,25 +1992,62 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n   if (TREE_CODE (size) == INTEGER_CST && TREE_OVERFLOW (size))\n     size = ssize_int (-1);\n \n-  /* If this is a type whose alignment is larger than the\n-     biggest we support in normal alignment and this is in\n-     the default storage pool, make an \"aligning type\", allocate\n-     it, point to the field we need, and return that.  */\n-  if (TYPE_ALIGN (type) > BIGGEST_ALIGNMENT\n-      && No (gnat_proc))\n+  /* If this is a type whose alignment is larger than what the underlying\n+     allocator supports and this is in the default storage pool, make an\n+     \"aligning\" record type with room to store a pointer before the field,\n+     allocate an object of that type, store the system's allocator return\n+     value just in front of the field and return the field's address.  */\n+\n+  if (TYPE_ALIGN (type) > BIGGEST_ALIGNMENT && No (gnat_proc))\n     {\n-      tree new_type = make_aligning_type (type, TYPE_ALIGN (type), size);\n+      /* Construct the aligning type with enough room for a pointer ahead\n+\t of the field, then allocate.  */\n+      tree record_type\n+\t= make_aligning_type (type, TYPE_ALIGN (type), size,\n+\t\t\t      BIGGEST_ALIGNMENT, POINTER_SIZE / BITS_PER_UNIT);\n \n-      result = build_call_alloc_dealloc (NULL_TREE, TYPE_SIZE_UNIT (new_type),\n-\t\t\t\t\t BIGGEST_ALIGNMENT, Empty,\n-\t\t\t\t\t Empty, gnat_node);\n-      result = save_expr (result);\n-      result = convert (build_pointer_type (new_type), result);\n-      result = build_unary_op (INDIRECT_REF, NULL_TREE, result);\n-      result = build_component_ref (result, NULL_TREE,\n-\t\t\t\t    TYPE_FIELDS (new_type), 0);\n-      result = convert (result_type,\n-\t\t\tbuild_unary_op (ADDR_EXPR, NULL_TREE, result));\n+      tree record, record_addr;\n+\n+      record_addr\n+\t= build_call_alloc_dealloc (NULL_TREE, TYPE_SIZE_UNIT (record_type),\n+\t\t\t\t    BIGGEST_ALIGNMENT, Empty, Empty,\n+\t\t\t\t    gnat_node);\n+\n+      record_addr\n+\t= convert (build_pointer_type (record_type),\n+\t\t   save_expr (record_addr));\n+\n+      record = build_unary_op (INDIRECT_REF, NULL_TREE, record_addr);\n+\n+      /* Our RESULT (the Ada allocator's value) is the super-aligned address\n+\t of the internal record field ... */\n+      result\n+\t= build_unary_op (ADDR_EXPR, NULL_TREE,\n+\t\t\t  build_component_ref\n+\t\t\t  (record, NULL_TREE, TYPE_FIELDS (record_type), 0));\n+      result = convert (result_type, result);\n+\n+      /* ... with the system allocator's return value stored just in\n+\t front.  */\n+      {\n+\ttree ptr_addr\n+\t  = build_binary_op (MINUS_EXPR, ptr_void_type_node,\n+\t\t\t     convert (ptr_void_type_node, result),\n+\t\t\t     convert (ptr_void_type_node,\n+\t\t\t\t      TYPE_SIZE_UNIT (ptr_void_type_node)));\n+\n+\ttree ptr_ref\n+\t  = convert (build_pointer_type (ptr_void_type_node), ptr_addr);\n+\n+\tresult\n+\t  = build2 (COMPOUND_EXPR, TREE_TYPE (result),\n+\t\t    build_binary_op (MODIFY_EXPR, NULL_TREE,\n+\t\t\t\t     build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t\t\t\t     ptr_ref),\n+\t\t\t\t     convert (ptr_void_type_node,\n+\t\t\t\t\t      record_addr)),\n+\t\t    result);\n+      }\n     }\n   else\n     result = convert (result_type,"}]}