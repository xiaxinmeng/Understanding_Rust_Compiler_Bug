{"sha": "b46ebd6c7beaf55974973de0f02d39299b733bc9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ2ZWJkNmM3YmVhZjU1OTc0OTczZGUwZjAyZDM5Mjk5YjczM2JjOQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-06-24T07:45:22Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-06-24T07:45:22Z"}, "message": "gimplify.c (gimplify_scan_omp_clauses) <case OMP_CLAUSE_MAP, [...]): Make sure OMP_CLAUSE_SIZE is non-NULL.\n\n\t* gimplify.c (gimplify_scan_omp_clauses) <case OMP_CLAUSE_MAP,\n\tOMP_CLAUSE_TO, OMP_CLAUSE_FROM): Make sure OMP_CLAUSE_SIZE is\n\tnon-NULL.\n\t<case OMP_CLAUSE_ALIGNED>: Gimplify OMP_CLAUSE_ALIGNED_ALIGNMENT.\n\t(gimplify_adjust_omp_clauses_1): Make sure OMP_CLAUSE_SIZE is\n\tnon-NULL.\n\t(gimplify_adjust_omp_clauses): Likewise.\n\t* omp-low.c (lower_rec_simd_input_clauses,\n\tlower_rec_input_clauses, expand_omp_simd): Handle non-constant\n\tsafelen the same as safelen(1).\n\t* tree-nested.c (convert_nonlocal_omp_clauses,\n\tconvert_local_omp_clauses): Handle OMP_CLAUSE_ALIGNED.  For\n\tOMP_CLAUSE_{MAP,TO,FROM} if not decl use walk_tree.\n\t(convert_nonlocal_reference_stmt, convert_local_reference_stmt):\n\tFixup handling of GIMPLE_OMP_TARGET.\n\t(convert_tramp_reference_stmt, convert_gimple_call): Handle\n\tGIMPLE_OMP_TARGET.\ngcc/fortran/\n\t* dump-parse-tree.c (show_omp_namelist): Use n->udr->udr instead\n\tof n->udr.\n\t* f95-lang.c (gfc_init_builtin_functions): Initialize\n\tBUILT_IN_ASSUME_ALIGNED.\n\t* gfortran.h (gfc_omp_namelist): Change udr field type to\n\tstruct gfc_omp_namelist_udr.\n\t(gfc_omp_namelist_udr): New type.\n\t(gfc_get_omp_namelist_udr): Define.\n\t(gfc_resolve_code): New prototype.\n\t* match.c (gfc_free_omp_namelist): Free name->udr.\n\t* module.c (intrinsics): Add INTRINSIC_USER.\n\t(fix_mio_expr): Likewise.\n\t(mio_expr): Handle INSTRINSIC_USER and non-resolved EXPR_FUNCTION.\n\t* openmp.c (gfc_match_omp_clauses): Adjust initialization of n->udr.\n\t(gfc_match_omp_declare_reduction): Treat len=: the same as len=*.\n\tSet attr.flavor on omp_{out,in,priv,orig} artificial variables.\n\t(struct resolve_omp_udr_callback_data): New type.\n\t(resolve_omp_udr_callback, resolve_omp_udr_callback2,\n\tresolve_omp_udr_clause): New functions.\n\t(resolve_omp_clauses): Adjust for n->udr changes, resolve UDR clauses\n\there.\n\t(omp_udr_callback): Don't check for implicitly declared functions\n\there.\n\t(gfc_resolve_omp_udr): Don't call gfc_resolve.  Don't check for\n\timplicitly declared subroutines here.\n\t* resolve.c (resolve_function): If value.function.isym is non-NULL,\n\tconsider it already resolved.\n\t(resolve_code): Renamed to ...\n\t(gfc_resolve_code): ... this.  No longer static.\n\t(gfc_resolve_blocks, generate_component_assignments, resolve_codes):\n\tAdjust callers.\n\t* trans-openmp.c (gfc_omp_privatize_by_reference): Don't privatize\n\tby reference type (C_PTR) variables.\n\t(gfc_omp_finish_clause): Make sure OMP_CLAUSE_SIZE is non-NULL.\n\t(gfc_trans_omp_udr_expr): Remove.\n\t(gfc_trans_omp_array_reduction_or_udr): Adjust for n->udr changes.\n\tDon't call gfc_trans_omp_udr_expr, even for sym->attr.dimension\n\texpand it as assignment or subroutine call.  Don't initialize\n\tvalue.function.isym.\ngcc/testsuite/\n\t* gfortran.dg/gomp/udr2.f90 (f7, f9): Add !$omp parallel with\n\treduction clause.\n\t* gfortran.dg/gomp/udr4.f90 (f4): Likewise.\n\tRemove Label is never defined expected error.\n\t* gfortran.dg/gomp/udr8.f90: New test.\nlibgomp/\n\t* testsuite/libgomp.fortran/aligned1.f03: New test.\n\t* testsuite/libgomp.fortran/nestedfn5.f90: New test.\n\t* testsuite/libgomp.fortran/target7.f90: Surround loop spawning\n\ttasks with !$omp parallel !$omp single.\n\t* testsuite/libgomp.fortran/target8.f90: New test.\n\t* testsuite/libgomp.fortran/udr4.f90 (foo UDR, bar UDR): Adjust\n\tnot to use trim in the combiner, instead call elemental function.\n\t(fn): New elemental function.\n\t* testsuite/libgomp.fortran/udr6.f90 (do_add, dp_add, dp_init):\n\tMake elemental.\n\t* testsuite/libgomp.fortran/udr7.f90 (omp_priv, omp_orig, omp_out,\n\tomp_in): Likewise.\n\t* testsuite/libgomp.fortran/udr12.f90: New test.\n\t* testsuite/libgomp.fortran/udr13.f90: New test.\n\t* testsuite/libgomp.fortran/udr14.f90: New test.\n\t* testsuite/libgomp.fortran/udr15.f90: New test.\n\nFrom-SVN: r211929", "tree": {"sha": "55405c922bb430cb45ea2427418eb2ed8cd74292", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55405c922bb430cb45ea2427418eb2ed8cd74292"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b46ebd6c7beaf55974973de0f02d39299b733bc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b46ebd6c7beaf55974973de0f02d39299b733bc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b46ebd6c7beaf55974973de0f02d39299b733bc9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b46ebd6c7beaf55974973de0f02d39299b733bc9/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "335123531f234436288975eb80d3655756878d29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/335123531f234436288975eb80d3655756878d29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/335123531f234436288975eb80d3655756878d29"}], "stats": {"total": 1754, "additions": 1513, "deletions": 241}, "files": [{"sha": "d99680af6f2bf3536e1bb29c1a10b5994d892180", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -1,3 +1,23 @@\n+2014-06-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gimplify.c (gimplify_scan_omp_clauses) <case OMP_CLAUSE_MAP,\n+\tOMP_CLAUSE_TO, OMP_CLAUSE_FROM): Make sure OMP_CLAUSE_SIZE is\n+\tnon-NULL.\n+\t<case OMP_CLAUSE_ALIGNED>: Gimplify OMP_CLAUSE_ALIGNED_ALIGNMENT.\n+\t(gimplify_adjust_omp_clauses_1): Make sure OMP_CLAUSE_SIZE is\n+\tnon-NULL.\n+\t(gimplify_adjust_omp_clauses): Likewise.\n+\t* omp-low.c (lower_rec_simd_input_clauses,\n+\tlower_rec_input_clauses, expand_omp_simd): Handle non-constant\n+\tsafelen the same as safelen(1).\n+\t* tree-nested.c (convert_nonlocal_omp_clauses,\n+\tconvert_local_omp_clauses): Handle OMP_CLAUSE_ALIGNED.  For\n+\tOMP_CLAUSE_{MAP,TO,FROM} if not decl use walk_tree.\n+\t(convert_nonlocal_reference_stmt, convert_local_reference_stmt):\n+\tFixup handling of GIMPLE_OMP_TARGET.\n+\t(convert_tramp_reference_stmt, convert_gimple_call): Handle\n+\tGIMPLE_OMP_TARGET.\n+\n 2014-06-24  Chung-Lin Tang  <cltang@codesourcery.com>\n \n \tPR tree-optimization/61554"}, {"sha": "57c5f8f4544d146df17209b2a0a9721c51be3cb4", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -1,3 +1,45 @@\n+2014-06-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* dump-parse-tree.c (show_omp_namelist): Use n->udr->udr instead\n+\tof n->udr.\n+\t* f95-lang.c (gfc_init_builtin_functions): Initialize\n+\tBUILT_IN_ASSUME_ALIGNED.\n+\t* gfortran.h (gfc_omp_namelist): Change udr field type to\n+\tstruct gfc_omp_namelist_udr.\n+\t(gfc_omp_namelist_udr): New type.\n+\t(gfc_get_omp_namelist_udr): Define.\n+\t(gfc_resolve_code): New prototype.\n+\t* match.c (gfc_free_omp_namelist): Free name->udr.\n+\t* module.c (intrinsics): Add INTRINSIC_USER.\n+\t(fix_mio_expr): Likewise.\n+\t(mio_expr): Handle INSTRINSIC_USER and non-resolved EXPR_FUNCTION.\n+\t* openmp.c (gfc_match_omp_clauses): Adjust initialization of n->udr.\n+\t(gfc_match_omp_declare_reduction): Treat len=: the same as len=*.\n+\tSet attr.flavor on omp_{out,in,priv,orig} artificial variables.\n+\t(struct resolve_omp_udr_callback_data): New type.\n+\t(resolve_omp_udr_callback, resolve_omp_udr_callback2,\n+\tresolve_omp_udr_clause): New functions.\n+\t(resolve_omp_clauses): Adjust for n->udr changes, resolve UDR clauses\n+\there.\n+\t(omp_udr_callback): Don't check for implicitly declared functions\n+\there.\n+\t(gfc_resolve_omp_udr): Don't call gfc_resolve.  Don't check for\n+\timplicitly declared subroutines here.\n+\t* resolve.c (resolve_function): If value.function.isym is non-NULL,\n+\tconsider it already resolved.\n+\t(resolve_code): Renamed to ...\n+\t(gfc_resolve_code): ... this.  No longer static.\n+\t(gfc_resolve_blocks, generate_component_assignments, resolve_codes):\n+\tAdjust callers.\n+\t* trans-openmp.c (gfc_omp_privatize_by_reference): Don't privatize\n+\tby reference type (C_PTR) variables.\n+\t(gfc_omp_finish_clause): Make sure OMP_CLAUSE_SIZE is non-NULL.\n+\t(gfc_trans_omp_udr_expr): Remove.\n+\t(gfc_trans_omp_array_reduction_or_udr): Adjust for n->udr changes.\n+\tDon't call gfc_trans_omp_udr_expr, even for sym->attr.dimension\n+\texpand it as assignment or subroutine call.  Don't initialize\n+\tvalue.function.isym.\n+\n 2014-06-23  Tobias Burnus  <burnus@net-b.de>\n \n \t* trans-decl.c (gfc_trans_deferred_vars): Fix handling of"}, {"sha": "19f83a9eff8f267632cf899f342344db868f52b1", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -1040,7 +1040,7 @@ show_omp_namelist (int list_type, gfc_omp_namelist *n)\n \t  case OMP_REDUCTION_IEOR: fputs (\"ieor:\", dumpfile); break;\n \t  case OMP_REDUCTION_USER:\n \t    if (n->udr)\n-\t      fprintf (dumpfile, \"%s:\", n->udr->name);\n+\t      fprintf (dumpfile, \"%s:\", n->udr->udr->name);\n \t    break;\n \t  default: break;\n \t  }"}, {"sha": "40f7f181cabe30ad0e3411d96c22bb09b159e040", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -1082,6 +1082,13 @@ gfc_init_builtin_functions (void)\n \t\t      BUILT_IN_TRAP, NULL, ATTR_NOTHROW_LEAF_LIST);\n   TREE_THIS_VOLATILE (builtin_decl_explicit (BUILT_IN_TRAP)) = 1;\n \n+  ftype = build_varargs_function_type_list (ptr_type_node, const_ptr_type_node,\n+\t\t\t\t\t    size_type_node, NULL_TREE);\n+  gfc_define_builtin (\"__builtin_assume_aligned\", ftype,\n+\t\t      BUILT_IN_ASSUME_ALIGNED,\n+\t\t      \"__builtin_assume_aligned\",\n+\t\t      ATTR_CONST_NOTHROW_LEAF_LIST);\n+\n   gfc_define_builtin (\"__emutls_get_address\",\n \t\t      builtin_types[BT_FN_PTR_PTR],\n \t\t      BUILT_IN_EMUTLS_GET_ADDRESS,"}, {"sha": "1c4638f331852a3efdaf017484f02337ce706132", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -1111,7 +1111,7 @@ typedef struct gfc_omp_namelist\n       gfc_omp_depend_op depend_op;\n       gfc_omp_map_op map_op;\n     } u;\n-  struct gfc_omp_udr *udr;\n+  struct gfc_omp_namelist_udr *udr;\n   struct gfc_omp_namelist *next;\n }\n gfc_omp_namelist;\n@@ -1237,6 +1237,15 @@ typedef struct gfc_omp_udr\n gfc_omp_udr;\n #define gfc_get_omp_udr() XCNEW (gfc_omp_udr)\n \n+typedef struct gfc_omp_namelist_udr\n+{\n+  struct gfc_omp_udr *udr;\n+  struct gfc_code *combiner;\n+  struct gfc_code *initializer;\n+}\n+gfc_omp_namelist_udr;\n+#define gfc_get_omp_namelist_udr() XCNEW (gfc_omp_namelist_udr)\n+\n /* The gfc_st_label structure is a BBT attached to a namespace that\n    records the usage of statement labels within that space.  */\n \n@@ -3011,6 +3020,7 @@ void gfc_free_association_list (gfc_association_list *);\n /* resolve.c */\n bool gfc_resolve_expr (gfc_expr *);\n void gfc_resolve (gfc_namespace *);\n+void gfc_resolve_code (gfc_code *, gfc_namespace *);\n void gfc_resolve_blocks (gfc_code *, gfc_namespace *);\n int gfc_impure_variable (gfc_symbol *);\n int gfc_pure (gfc_symbol *);"}, {"sha": "b3f47a8e73e42d37af06be26be693f0c1721b776", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -4577,6 +4577,14 @@ gfc_free_omp_namelist (gfc_omp_namelist *name)\n   for (; name; name = n)\n     {\n       gfc_free_expr (name->expr);\n+      if (name->udr)\n+\t{\n+\t  if (name->udr->combiner)\n+\t    gfc_free_statement (name->udr->combiner);\n+\t  if (name->udr->initializer)\n+\t    gfc_free_statement (name->udr->initializer);\n+\t  free (name->udr);\n+\t}\n       n = name->next;\n       free (name);\n     }"}, {"sha": "ec67960eae91dedf25b501d3aef46a2df5d28eb3", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -3136,6 +3136,7 @@ static const mstring intrinsics[] =\n     minit (\"LE\", INTRINSIC_LE_OS),\n     minit (\"NOT\", INTRINSIC_NOT),\n     minit (\"PARENTHESES\", INTRINSIC_PARENTHESES),\n+    minit (\"USER\", INTRINSIC_USER),\n     minit (NULL, -1)\n };\n \n@@ -3172,7 +3173,8 @@ fix_mio_expr (gfc_expr *e)\n \t  && !e->symtree->n.sym->attr.dummy)\n \te->symtree = ns_st;\n     }\n-  else if (e->expr_type == EXPR_FUNCTION && e->value.function.name)\n+  else if (e->expr_type == EXPR_FUNCTION\n+\t   && (e->value.function.name || e->value.function.isym))\n     {\n       gfc_symbol *sym;\n \n@@ -3287,6 +3289,32 @@ mio_expr (gfc_expr **ep)\n \t  mio_expr (&e->value.op.op2);\n \t  break;\n \n+\tcase INTRINSIC_USER:\n+\t  /* INTRINSIC_USER should not appear in resolved expressions,\n+\t     though for UDRs we need to stream unresolved ones.  */\n+\t  if (iomode == IO_OUTPUT)\n+\t    write_atom (ATOM_STRING, e->value.op.uop->name);\n+\t  else\n+\t    {\n+\t      char *name = read_string ();\n+\t      const char *uop_name = find_use_name (name, true);\n+\t      if (uop_name == NULL)\n+\t\t{\n+\t\t  size_t len = strlen (name);\n+\t\t  char *name2 = XCNEWVEC (char, len + 2);\n+\t\t  memcpy (name2, name, len);\n+\t\t  name2[len] = ' ';\n+\t\t  name2[len + 1] = '\\0';\n+\t\t  free (name);\n+\t\t  uop_name = name = name2;\n+\t\t}\n+\t      e->value.op.uop = gfc_get_uop (uop_name);\n+\t      free (name);\n+\t    }\n+\t  mio_expr (&e->value.op.op1);\n+\t  mio_expr (&e->value.op.op2);\n+\t  break;\n+\n \tdefault:\n \t  bad_module (\"Bad operator\");\n \t}\n@@ -3305,6 +3333,8 @@ mio_expr (gfc_expr **ep)\n \t    flag = 1;\n \t  else if (e->ref)\n \t    flag = 2;\n+\t  else if (e->value.function.isym == NULL)\n+\t    flag = 3;\n \t  else\n \t    flag = 0;\n \t  mio_integer (&flag);\n@@ -3316,14 +3346,19 @@ mio_expr (gfc_expr **ep)\n \t    case 2:\n \t      mio_ref_list (&e->ref);\n \t      break;\n+\t    case 3:\n+\t      break;\n \t    default:\n \t      write_atom (ATOM_STRING, e->value.function.isym->name);\n \t    }\n \t}\n       else\n \t{\n \t  require_atom (ATOM_STRING);\n-\t  e->value.function.name = gfc_get_string (atom_string);\n+\t  if (atom_string[0] == '\\0')\n+\t    e->value.function.name = NULL;\n+\t  else\n+\t    e->value.function.name = gfc_get_string (atom_string);\n \t  free (atom_string);\n \n \t  mio_integer (&flag);\n@@ -3335,6 +3370,8 @@ mio_expr (gfc_expr **ep)\n \t    case 2:\n \t      mio_ref_list (&e->ref);\n \t      break;\n+\t    case 3:\n+\t      break;\n \t    default:\n \t      require_atom (ATOM_STRING);\n \t      e->value.function.isym = gfc_find_function (atom_string);"}, {"sha": "68ba70f7ebe160bd86d4c3d3b65e61b4e3e50dd2", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 133, "deletions": 37, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -486,7 +486,11 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, unsigned int mask,\n \t\tfor (n = *head; n; n = n->next)\n \t\t  {\n \t\t    n->u.reduction_op = rop;\n-\t\t    n->udr = udr;\n+\t\t    if (udr)\n+\t\t      {\n+\t\t\tn->udr = gfc_get_omp_namelist_udr ();\n+\t\t\tn->udr->udr = udr;\n+\t\t      }\n \t\t  }\n \t      continue;\n \t    }\n@@ -1182,6 +1186,9 @@ gfc_match_omp_declare_reduction (void)\n   m = gfc_match_type_spec (&ts);\n   if (m != MATCH_YES)\n     return MATCH_ERROR;\n+  /* Treat len=: the same as len=*.  */\n+  if (ts.type == BT_CHARACTER)\n+    ts.deferred = false;\n   tss.safe_push (ts);\n \n   while (gfc_match_char (',') == MATCH_YES)\n@@ -1219,6 +1226,8 @@ gfc_match_omp_declare_reduction (void)\n       omp_in->n.sym->ts = tss[i];\n       omp_out->n.sym->attr.omp_udr_artificial_var = 1;\n       omp_in->n.sym->attr.omp_udr_artificial_var = 1;\n+      omp_out->n.sym->attr.flavor = FL_VARIABLE;\n+      omp_in->n.sym->attr.flavor = FL_VARIABLE;\n       gfc_commit_symbols ();\n       omp_udr->combiner_ns = combiner_ns;\n       omp_udr->omp_out = omp_out->n.sym;\n@@ -1249,6 +1258,8 @@ gfc_match_omp_declare_reduction (void)\n \t  omp_orig->n.sym->ts = tss[i];\n \t  omp_priv->n.sym->attr.omp_udr_artificial_var = 1;\n \t  omp_orig->n.sym->attr.omp_udr_artificial_var = 1;\n+\t  omp_priv->n.sym->attr.flavor = FL_VARIABLE;\n+\t  omp_orig->n.sym->attr.flavor = FL_VARIABLE;\n \t  gfc_commit_symbols ();\n \t  omp_udr->initializer_ns = initializer_ns;\n \t  omp_udr->omp_priv = omp_priv->n.sym;\n@@ -1900,6 +1911,104 @@ gfc_match_omp_end_single (void)\n }\n \n \n+struct resolve_omp_udr_callback_data\n+{\n+  gfc_symbol *sym1, *sym2;\n+};\n+\n+\n+static int\n+resolve_omp_udr_callback (gfc_expr **e, int *, void *data)\n+{\n+  struct resolve_omp_udr_callback_data *rcd\n+    = (struct resolve_omp_udr_callback_data *) data;\n+  if ((*e)->expr_type == EXPR_VARIABLE\n+      && ((*e)->symtree->n.sym == rcd->sym1\n+\t  || (*e)->symtree->n.sym == rcd->sym2))\n+    {\n+      gfc_ref *ref = gfc_get_ref ();\n+      ref->type = REF_ARRAY;\n+      ref->u.ar.where = (*e)->where;\n+      ref->u.ar.as = (*e)->symtree->n.sym->as;\n+      ref->u.ar.type = AR_FULL;\n+      ref->u.ar.dimen = 0;\n+      ref->next = (*e)->ref;\n+      (*e)->ref = ref;\n+    }\n+  return 0;\n+}\n+\n+\n+static int\n+resolve_omp_udr_callback2 (gfc_expr **e, int *, void *)\n+{\n+  if ((*e)->expr_type == EXPR_FUNCTION\n+      && (*e)->value.function.isym == NULL)\n+    {\n+      gfc_symbol *sym = (*e)->symtree->n.sym;\n+      if (!sym->attr.intrinsic\n+\t  && sym->attr.if_source == IFSRC_UNKNOWN)\n+\tgfc_error (\"Implicitly declared function %s used in \"\n+\t\t   \"!$OMP DECLARE REDUCTION at %L \", sym->name, &(*e)->where);\n+    }\n+  return 0;\n+}\n+\n+\n+static gfc_code *\n+resolve_omp_udr_clause (gfc_omp_namelist *n, gfc_namespace *ns,\n+\t\t\tgfc_symbol *sym1, gfc_symbol *sym2)\n+{\n+  gfc_code *copy;\n+  gfc_symbol sym1_copy, sym2_copy;\n+\n+  if (ns->code->op == EXEC_ASSIGN)\n+    {\n+      copy = gfc_get_code (EXEC_ASSIGN);\n+      copy->expr1 = gfc_copy_expr (ns->code->expr1);\n+      copy->expr2 = gfc_copy_expr (ns->code->expr2);\n+    }\n+  else\n+    {\n+      copy = gfc_get_code (EXEC_CALL);\n+      copy->symtree = ns->code->symtree;\n+      copy->ext.actual = gfc_copy_actual_arglist (ns->code->ext.actual);\n+    }\n+  copy->loc = ns->code->loc;\n+  sym1_copy = *sym1;\n+  sym2_copy = *sym2;\n+  *sym1 = *n->sym;\n+  *sym2 = *n->sym;\n+  sym1->name = sym1_copy.name;\n+  sym2->name = sym2_copy.name;\n+  ns->proc_name = ns->parent->proc_name;\n+  if (n->sym->attr.dimension)\n+    {\n+      struct resolve_omp_udr_callback_data rcd;\n+      rcd.sym1 = sym1;\n+      rcd.sym2 = sym2;\n+      gfc_code_walker (&copy, gfc_dummy_code_callback,\n+\t\t       resolve_omp_udr_callback, &rcd);\n+    }\n+  gfc_resolve_code (copy, gfc_current_ns);\n+  if (copy->op == EXEC_CALL && copy->resolved_isym == NULL)\n+    {\n+      gfc_symbol *sym = copy->resolved_sym;\n+      if (sym\n+\t  && !sym->attr.intrinsic\n+\t  && sym->attr.if_source == IFSRC_UNKNOWN)\n+\tgfc_error (\"Implicitly declared subroutine %s used in \"\n+\t\t   \"!$OMP DECLARE REDUCTION at %L \", sym->name,\n+\t\t   &copy->loc);\n+    }\n+  gfc_code_walker (&copy, gfc_dummy_code_callback,\n+\t\t   resolve_omp_udr_callback2, NULL);\n+  *sym1 = sym1_copy;\n+  *sym2 = sym2_copy;\n+  return copy;\n+}\n+\n+\n /* OpenMP directive resolving routines.  */\n \n static void\n@@ -2295,9 +2404,15 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t\tconst char *udr_name = NULL;\n \t\t\tif (n->udr)\n \t\t\t  {\n-\t\t\t    udr_name = n->udr->name;\n-\t\t\t    n->udr = gfc_find_omp_udr (NULL, udr_name,\n-\t\t\t\t\t\t       &n->sym->ts);\n+\t\t\t    udr_name = n->udr->udr->name;\n+\t\t\t    n->udr->udr\n+\t\t\t      = gfc_find_omp_udr (NULL, udr_name,\n+\t\t\t\t\t\t  &n->sym->ts);\n+\t\t\t    if (n->udr->udr == NULL)\n+\t\t\t      {\n+\t\t\t\tfree (n->udr);\n+\t\t\t\tn->udr = NULL;\n+\t\t\t      }\n \t\t\t  }\n \t\t\tif (n->udr == NULL)\n \t\t\t  {\n@@ -2337,7 +2452,20 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t\t\t       gfc_typename (&n->sym->ts), where);\n \t\t\t  }\n \t\t\telse\n-\t\t\t  n->u.reduction_op = OMP_REDUCTION_USER;\n+\t\t\t  {\n+\t\t\t    gfc_omp_udr *udr = n->udr->udr;\n+\t\t\t    n->u.reduction_op = OMP_REDUCTION_USER;\n+\t\t\t    n->udr->combiner\n+\t\t\t      = resolve_omp_udr_clause (n, udr->combiner_ns,\n+\t\t\t\t\t\t\tudr->omp_out,\n+\t\t\t\t\t\t\tudr->omp_in);\n+\t\t\t    if (udr->initializer_ns)\n+\t\t\t      n->udr->initializer\n+\t\t\t\t= resolve_omp_udr_clause (n,\n+\t\t\t\t\t\t\t  udr->initializer_ns,\n+\t\t\t\t\t\t\t  udr->omp_priv,\n+\t\t\t\t\t\t\t  udr->omp_orig);\n+\t\t\t  }\n \t\t      }\n \t\t    break;\n \t\t  case OMP_LIST_LINEAR:\n@@ -3317,15 +3445,6 @@ omp_udr_callback (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t\t       &(*e)->where);\n \t}\n     }\n-  else if ((*e)->expr_type == EXPR_FUNCTION\n-\t   && (*e)->value.function.isym == NULL)\n-    {\n-      gfc_symbol *sym = (*e)->symtree->n.sym;\n-      if (!sym->attr.intrinsic\n-\t  && sym->attr.if_source == IFSRC_UNKNOWN)\n-\tgfc_error (\"Implicitly declared function %s used in \"\n-\t\t   \"!$OMP DECLARE REDUCTION at %L \", sym->name, &(*e)->where);\n-    }\n   return 0;\n }\n \n@@ -3337,9 +3456,6 @@ gfc_resolve_omp_udr (gfc_omp_udr *omp_udr)\n   gfc_actual_arglist *a;\n   const char *predef_name = NULL;\n \n-  gfc_resolve (omp_udr->combiner_ns);\n-  if (omp_udr->initializer_ns)\n-    gfc_resolve (omp_udr->initializer_ns);\n   switch (omp_udr->rop)\n     {\n     case OMP_REDUCTION_PLUS:\n@@ -3394,16 +3510,6 @@ gfc_resolve_omp_udr (gfc_omp_udr *omp_udr)\n \tgfc_error (\"Subroutine call with alternate returns in combiner \"\n \t\t   \"of !$OMP DECLARE REDUCTION at %L\",\n \t\t   &omp_udr->combiner_ns->code->loc);\n-      if (omp_udr->combiner_ns->code->resolved_isym == NULL)\n-\t{\n-\t  gfc_symbol *sym = omp_udr->combiner_ns->code->resolved_sym;\n-\t  if (sym\n-\t      && !sym->attr.intrinsic\n-\t      && sym->attr.if_source == IFSRC_UNKNOWN)\n-\t    gfc_error (\"Implicitly declared subroutine %s used in \"\n-\t\t       \"!$OMP DECLARE REDUCTION at %L \", sym->name,\n-\t\t       &omp_udr->combiner_ns->code->loc);\n-\t}\n     }\n   if (omp_udr->initializer_ns)\n     {\n@@ -3429,16 +3535,6 @@ gfc_resolve_omp_udr (gfc_omp_udr *omp_udr)\n \t    gfc_error (\"One of actual subroutine arguments in INITIALIZER \"\n \t\t       \"clause of !$OMP DECLARE REDUCTION must be OMP_PRIV \"\n \t\t       \"at %L\", &omp_udr->initializer_ns->code->loc);\n-\t  if (omp_udr->initializer_ns->code->resolved_isym == NULL)\n-\t    {\n-\t      gfc_symbol *sym = omp_udr->initializer_ns->code->resolved_sym;\n-\t      if (sym\n-\t\t  && !sym->attr.intrinsic\n-\t\t  && sym->attr.if_source == IFSRC_UNKNOWN)\n-\t\tgfc_error (\"Implicitly declared subroutine %s used in \"\n-\t\t\t   \"!$OMP DECLARE REDUCTION at %L \", sym->name,\n-\t\t\t   &omp_udr->initializer_ns->code->loc);\n-\t    }\n \t}\n     }\n   else if (omp_udr->ts.type == BT_DERIVED"}, {"sha": "48b3a40f769d75a3b03cc68653622c6a372cd083", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -40,7 +40,7 @@ typedef enum seq_type\n seq_type;\n \n /* Stack to keep track of the nesting of blocks as we move through the\n-   code.  See resolve_branch() and resolve_code().  */\n+   code.  See resolve_branch() and gfc_resolve_code().  */\n \n typedef struct code_stack\n {\n@@ -2887,7 +2887,8 @@ resolve_function (gfc_expr *expr)\n \n   /* See if function is already resolved.  */\n \n-  if (expr->value.function.name != NULL)\n+  if (expr->value.function.name != NULL\n+      || expr->value.function.isym != NULL)\n     {\n       if (expr->ts.type == BT_UNKNOWN)\n \texpr->ts = sym->ts;\n@@ -4930,7 +4931,7 @@ resolve_variable (gfc_expr *e)\n   if (check_assumed_size_reference (sym, e))\n     return false;\n \n-  /* Deal with forward references to entries during resolve_code, to\n+  /* Deal with forward references to entries during gfc_resolve_code, to\n      satisfy, at least partially, 12.5.2.5.  */\n   if (gfc_current_ns->entries\n       && current_entry_id == sym->entry_id\n@@ -8979,8 +8980,6 @@ resolve_block_construct (gfc_code* code)\n /* Resolve lists of blocks found in IF, SELECT CASE, WHERE, FORALL, GOTO and\n    DO code nodes.  */\n \n-static void resolve_code (gfc_code *, gfc_namespace *);\n-\n void\n gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n {\n@@ -9072,7 +9071,7 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \t  gfc_internal_error (\"gfc_resolve_blocks(): Bad block type\");\n \t}\n \n-      resolve_code (b->next, ns);\n+      gfc_resolve_code (b->next, ns);\n     }\n }\n \n@@ -9520,7 +9519,7 @@ nonscalar_typebound_assign (gfc_symbol *derived, int depth)\n    The pointer assignments are taken care of by the intrinsic\n    assignment of the structure itself.  This function recursively adds\n    defined assignments where required.  The recursion is accomplished\n-   by calling resolve_code.\n+   by calling gfc_resolve_code.\n \n    When the lhs in a defined assignment has intent INOUT, we need a\n    temporary for the lhs.  In pseudo-code:\n@@ -9638,9 +9637,9 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)\n \t\t\t\t    comp1, comp2, (*code)->loc);\n \n       /* Convert the assignment if there is a defined assignment for\n-\t this type.  Otherwise, using the call from resolve_code,\n+\t this type.  Otherwise, using the call from gfc_resolve_code,\n \t recurse into its components.  */\n-      resolve_code (this_code, ns);\n+      gfc_resolve_code (this_code, ns);\n \n       if (this_code->op == EXEC_ASSIGN_CALL)\n \t{\n@@ -9804,8 +9803,8 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)\n /* Given a block of code, recursively resolve everything pointed to by this\n    code block.  */\n \n-static void\n-resolve_code (gfc_code *code, gfc_namespace *ns)\n+void\n+gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n {\n   int omp_workshare_save;\n   int forall_save, do_concurrent_save;\n@@ -10091,7 +10090,8 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \n \tcase EXEC_DO_WHILE:\n \t  if (code->expr1 == NULL)\n-\t    gfc_internal_error (\"resolve_code(): No expression on DO WHILE\");\n+\t    gfc_internal_error (\"gfc_resolve_code(): No expression on \"\n+\t\t\t\t\"DO WHILE\");\n \t  if (t\n \t      && (code->expr1->rank != 0\n \t\t  || code->expr1->ts.type != BT_LOGICAL))\n@@ -10233,7 +10233,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  break;\n \n \tdefault:\n-\t  gfc_internal_error (\"resolve_code(): Bad statement code\");\n+\t  gfc_internal_error (\"gfc_resolve_code(): Bad statement code\");\n \t}\n     }\n \n@@ -14696,7 +14696,7 @@ gfc_resolve_uops (gfc_symtree *symtree)\n    assign types to all intermediate expressions, make sure that all\n    assignments are to compatible types and figure out which names\n    refer to which functions or subroutines.  It doesn't check code\n-   block, which is handled by resolve_code.  */\n+   block, which is handled by gfc_resolve_code.  */\n \n static void\n resolve_types (gfc_namespace *ns)\n@@ -14785,7 +14785,7 @@ resolve_types (gfc_namespace *ns)\n }\n \n \n-/* Call resolve_code recursively.  */\n+/* Call gfc_resolve_code recursively.  */\n \n static void\n resolve_codes (gfc_namespace *ns)\n@@ -14811,7 +14811,7 @@ resolve_codes (gfc_namespace *ns)\n   old_obstack = labels_obstack;\n   bitmap_obstack_initialize (&labels_obstack);\n \n-  resolve_code (ns->code, ns);\n+  gfc_resolve_code (ns->code, ns);\n \n   bitmap_obstack_release (&labels_obstack);\n   labels_obstack = old_obstack;"}, {"sha": "458cfffa2d9b6031c8b91610008c0f32a35f0c74", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 46, "deletions": 137, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -53,11 +53,13 @@ gfc_omp_privatize_by_reference (const_tree decl)\n   if (TREE_CODE (type) == POINTER_TYPE)\n     {\n       /* Array POINTER/ALLOCATABLE have aggregate types, all user variables\n-\t that have POINTER_TYPE type and don't have GFC_POINTER_TYPE_P\n-\t set are supposed to be privatized by reference.  */\n+\t that have POINTER_TYPE type and aren't scalar pointers, scalar\n+\t allocatables, Cray pointees or C pointers are supposed to be\n+\t privatized by reference.  */\n       if (GFC_DECL_GET_SCALAR_POINTER (decl)\n \t  || GFC_DECL_GET_SCALAR_ALLOCATABLE (decl)\n-\t  || GFC_DECL_CRAY_POINTEE (decl))\n+\t  || GFC_DECL_CRAY_POINTEE (decl)\n+\t  || VOID_TYPE_P (TREE_TYPE (TREE_TYPE (decl))))\n \treturn false;\n \n       if (!DECL_ARTIFICIAL (decl)\n@@ -895,6 +897,7 @@ gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n       OMP_CLAUSE_SIZE (c4) = size_int (0);\n       decl = build_fold_indirect_ref (decl);\n       OMP_CLAUSE_DECL (c) = decl;\n+      OMP_CLAUSE_SIZE (c) = NULL_TREE;\n     }\n   if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n     {\n@@ -956,6 +959,10 @@ gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n       gimplify_and_add (stmt, pre_p);\n     }\n   tree last = c;\n+  if (OMP_CLAUSE_SIZE (c) == NULL_TREE)\n+    OMP_CLAUSE_SIZE (c)\n+      = DECL_P (decl) ? DECL_SIZE_UNIT (decl)\n+\t\t      : TYPE_SIZE_UNIT (TREE_TYPE (decl));\n   if (c2)\n     {\n       OMP_CLAUSE_CHAIN (c2) = OMP_CLAUSE_CHAIN (last);\n@@ -1182,78 +1189,6 @@ omp_udr_find_orig (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n   return 0;\n }\n \n-static tree\n-gfc_trans_omp_udr_expr (gfc_omp_namelist *n, bool is_initializer,\n-\t\t\tgfc_expr *syme, gfc_expr *outere)\n-{\n-  gfc_se symse, outerse;\n-  gfc_ss *symss, *outerss;\n-  gfc_loopinfo loop;\n-  stmtblock_t block, body;\n-  tree tem;\n-  int i;\n-  gfc_namespace *ns = (is_initializer\n-\t\t       ? n->udr->initializer_ns : n->udr->combiner_ns);\n-\n-  syme = gfc_copy_expr (syme);\n-  outere = gfc_copy_expr (outere);\n-  gfc_init_se (&symse, NULL);\n-  gfc_init_se (&outerse, NULL);\n-  gfc_start_block (&block);\n-  gfc_init_loopinfo (&loop);\n-  symss = gfc_walk_expr (syme);\n-  outerss = gfc_walk_expr (outere);\n-  gfc_add_ss_to_loop (&loop, symss);\n-  gfc_add_ss_to_loop (&loop, outerss);\n-  gfc_conv_ss_startstride (&loop);\n-  /* Enable loop reversal.  */\n-  for (i = 0; i < GFC_MAX_DIMENSIONS; i++)\n-    loop.reverse[i] = GFC_ENABLE_REVERSE;\n-  gfc_conv_loop_setup (&loop, &ns->code->loc);\n-  gfc_copy_loopinfo_to_se (&symse, &loop);\n-  gfc_copy_loopinfo_to_se (&outerse, &loop);\n-  symse.ss = symss;\n-  outerse.ss = outerss;\n-  gfc_mark_ss_chain_used (symss, 1);\n-  gfc_mark_ss_chain_used (outerss, 1);\n-  gfc_start_scalarized_body (&loop, &body);\n-  gfc_conv_expr (&symse, syme);\n-  gfc_conv_expr (&outerse, outere);\n-\n-  if (is_initializer)\n-    {\n-      n->udr->omp_priv->backend_decl = symse.expr;\n-      n->udr->omp_orig->backend_decl = outerse.expr;\n-    }\n-  else\n-    {\n-      n->udr->omp_out->backend_decl = outerse.expr;\n-      n->udr->omp_in->backend_decl = symse.expr;\n-    }\n-\n-  if (ns->code->op == EXEC_ASSIGN)\n-    tem = gfc_trans_assignment (ns->code->expr1, ns->code->expr2,\n-\t\t\t\tfalse, false);\n-  else\n-    tem = gfc_trans_call (ns->code, false, NULL_TREE, NULL_TREE, false);\n-  gfc_add_expr_to_block (&body, tem);\n-\n-  gcc_assert (symse.ss == gfc_ss_terminator\n-\t      && outerse.ss == gfc_ss_terminator);\n-  /* Generate the copying loops.  */\n-  gfc_trans_scalarizing_loops (&loop, &body);\n-\n-  /* Wrap the whole thing up.  */\n-  gfc_add_block_to_block (&block, &loop.pre);\n-  gfc_add_block_to_block (&block, &loop.post);\n-\n-  gfc_cleanup_loop (&loop);\n-  gfc_free_expr (syme);\n-  gfc_free_expr (outere);\n-\n-  return gfc_finish_block (&block);\n-}\n-\n static void\n gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n {\n@@ -1268,6 +1203,7 @@ gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n   locus old_loc = gfc_current_locus;\n   const char *iname;\n   bool t;\n+  gfc_omp_udr *udr = n->udr ? n->udr->udr : NULL;\n \n   decl = OMP_CLAUSE_DECL (c);\n   gfc_current_locus = where;\n@@ -1292,7 +1228,7 @@ gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n   init_val_sym.attr.flavor = FL_VARIABLE;\n   if (OMP_CLAUSE_REDUCTION_CODE (c) != ERROR_MARK)\n     backend_decl = omp_reduction_init (c, gfc_sym_type (&init_val_sym));\n-  else if (n->udr->initializer_ns)\n+  else if (udr->initializer_ns)\n     backend_decl = NULL;\n   else\n     switch (sym->ts.type)\n@@ -1334,34 +1270,18 @@ gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n   gcc_assert (symtree3 == root3);\n \n   memset (omp_var_copy, 0, sizeof omp_var_copy);\n-  if (n->udr)\n+  if (udr)\n     {\n-      omp_var_copy[0] = *n->udr->omp_out;\n-      omp_var_copy[1] = *n->udr->omp_in;\n-      if (sym->attr.dimension)\n-\t{\n-\t  n->udr->omp_out->ts = sym->ts;\n-\t  n->udr->omp_in->ts = sym->ts;\n-\t}\n-      else\n+      omp_var_copy[0] = *udr->omp_out;\n+      omp_var_copy[1] = *udr->omp_in;\n+      *udr->omp_out = outer_sym;\n+      *udr->omp_in = *sym;\n+      if (udr->initializer_ns)\n \t{\n-\t  *n->udr->omp_out = outer_sym;\n-\t  *n->udr->omp_in = *sym;\n-\t}\n-      if (n->udr->initializer_ns)\n-\t{\n-\t  omp_var_copy[2] = *n->udr->omp_priv;\n-\t  omp_var_copy[3] = *n->udr->omp_orig;\n-\t  if (sym->attr.dimension)\n-\t    {\n-\t      n->udr->omp_priv->ts = sym->ts;\n-\t      n->udr->omp_orig->ts = sym->ts;\n-\t    }\n-\t  else\n-\t    {\n-\t      *n->udr->omp_priv = *sym;\n-\t      *n->udr->omp_orig = outer_sym;\n-\t    }\n+\t  omp_var_copy[2] = *udr->omp_priv;\n+\t  omp_var_copy[3] = *udr->omp_orig;\n+\t  *udr->omp_priv = *sym;\n+\t  *udr->omp_orig = outer_sym;\n \t}\n     }\n \n@@ -1394,29 +1314,26 @@ gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n       t = gfc_resolve_expr (e2);\n       gcc_assert (t);\n     }\n-  else if (n->udr->initializer_ns == NULL)\n+  else if (udr->initializer_ns == NULL)\n     {\n       gcc_assert (sym->ts.type == BT_DERIVED);\n       e2 = gfc_default_initializer (&sym->ts);\n       gcc_assert (e2);\n       t = gfc_resolve_expr (e2);\n       gcc_assert (t);\n     }\n-  else if (n->udr->initializer_ns->code->op == EXEC_ASSIGN)\n+  else if (n->udr->initializer->op == EXEC_ASSIGN)\n     {\n-      if (!sym->attr.dimension)\n-\t{\n-\t  e2 = gfc_copy_expr (n->udr->initializer_ns->code->expr2);\n-\t  t = gfc_resolve_expr (e2);\n-\t  gcc_assert (t);\n-\t}\n+      e2 = gfc_copy_expr (n->udr->initializer->expr2);\n+      t = gfc_resolve_expr (e2);\n+      gcc_assert (t);\n     }\n-  if (n->udr && n->udr->initializer_ns)\n+  if (udr && udr->initializer_ns)\n     {\n       struct omp_udr_find_orig_data cd;\n-      cd.omp_udr = n->udr;\n+      cd.omp_udr = udr;\n       cd.omp_orig_seen = false;\n-      gfc_code_walker (&n->udr->initializer_ns->code,\n+      gfc_code_walker (&n->udr->initializer,\n \t\t       gfc_dummy_code_callback, omp_udr_find_orig, &cd);\n       if (cd.omp_orig_seen)\n \tOMP_CLAUSE_REDUCTION_OMP_ORIG_REF (c) = 1;\n@@ -1466,18 +1383,15 @@ gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n       iname = \"ieor\";\n       break;\n     case ERROR_MARK:\n-      if (n->udr->combiner_ns->code->op == EXEC_ASSIGN)\n+      if (n->udr->combiner->op == EXEC_ASSIGN)\n \t{\n-\t  if (!sym->attr.dimension)\n-\t    {\n-\t      gfc_free_expr (e3);\n-\t      e3 = gfc_copy_expr (n->udr->combiner_ns->code->expr1);\n-\t      e4 = gfc_copy_expr (n->udr->combiner_ns->code->expr2);\n-\t      t = gfc_resolve_expr (e3);\n-\t      gcc_assert (t);\n-\t      t = gfc_resolve_expr (e4);\n-\t      gcc_assert (t);\n-\t    }\n+\t  gfc_free_expr (e3);\n+\t  e3 = gfc_copy_expr (n->udr->combiner->expr1);\n+\t  e4 = gfc_copy_expr (n->udr->combiner->expr2);\n+\t  t = gfc_resolve_expr (e3);\n+\t  gcc_assert (t);\n+\t  t = gfc_resolve_expr (e4);\n+\t  gcc_assert (t);\n \t}\n       break;\n     default:\n@@ -1503,7 +1417,6 @@ gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n       e4->expr_type = EXPR_FUNCTION;\n       e4->where = where;\n       e4->symtree = symtree4;\n-      e4->value.function.isym = gfc_find_function (iname);\n       e4->value.function.actual = gfc_get_actual_arglist ();\n       e4->value.function.actual->expr = e3;\n       e4->value.function.actual->next = gfc_get_actual_arglist ();\n@@ -1522,10 +1435,8 @@ gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n   pushlevel ();\n   if (e2)\n     stmt = gfc_trans_assignment (e1, e2, false, false);\n-  else if (sym->attr.dimension)\n-    stmt = gfc_trans_omp_udr_expr (n, true, e1, e3);\n   else\n-    stmt = gfc_trans_call (n->udr->initializer_ns->code, false,\n+    stmt = gfc_trans_call (n->udr->initializer, false,\n \t\t\t   NULL_TREE, NULL_TREE, false);\n   if (TREE_CODE (stmt) != BIND_EXPR)\n     stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n@@ -1537,10 +1448,8 @@ gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n   pushlevel ();\n   if (e4)\n     stmt = gfc_trans_assignment (e3, e4, false, true);\n-  else if (sym->attr.dimension)\n-    stmt = gfc_trans_omp_udr_expr (n, false, e1, e3);\n   else\n-    stmt = gfc_trans_call (n->udr->combiner_ns->code, false,\n+    stmt = gfc_trans_call (n->udr->combiner, false,\n \t\t\t   NULL_TREE, NULL_TREE, false);\n   if (TREE_CODE (stmt) != BIND_EXPR)\n     stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n@@ -1566,14 +1475,14 @@ gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n   if (outer_sym.as)\n     gfc_free_array_spec (outer_sym.as);\n \n-  if (n->udr)\n+  if (udr)\n     {\n-      *n->udr->omp_out = omp_var_copy[0];\n-      *n->udr->omp_in = omp_var_copy[1];\n-      if (n->udr->initializer_ns)\n+      *udr->omp_out = omp_var_copy[0];\n+      *udr->omp_in = omp_var_copy[1];\n+      if (udr->initializer_ns)\n \t{\n-\t  *n->udr->omp_priv = omp_var_copy[2];\n-\t  *n->udr->omp_orig = omp_var_copy[3];\n+\t  *udr->omp_priv = omp_var_copy[2];\n+\t  *udr->omp_orig = omp_var_copy[3];\n \t}\n     }\n }"}, {"sha": "21ddcf7cf9eee9074d2fa2ead557562d1993e7a9", "filename": "gcc/gimplify.c", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -5993,14 +5993,21 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t  goto do_add;\n \n \tcase OMP_CLAUSE_MAP:\n-\t  if (OMP_CLAUSE_SIZE (c)\n-\t      && gimplify_expr (&OMP_CLAUSE_SIZE (c), pre_p,\n-\t\t\t\tNULL, is_gimple_val, fb_rvalue) == GS_ERROR)\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  if (error_operand_p (decl))\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  if (OMP_CLAUSE_SIZE (c) == NULL_TREE)\n+\t    OMP_CLAUSE_SIZE (c) = DECL_P (decl) ? DECL_SIZE_UNIT (decl)\n+\t\t\t\t  : TYPE_SIZE_UNIT (TREE_TYPE (decl));\n+\t  if (gimplify_expr (&OMP_CLAUSE_SIZE (c), pre_p,\n+\t\t\t     NULL, is_gimple_val, fb_rvalue) == GS_ERROR)\n \t    {\n \t      remove = true;\n \t      break;\n \t    }\n-\t  decl = OMP_CLAUSE_DECL (c);\n \t  if (!DECL_P (decl))\n \t    {\n \t      if (gimplify_expr (&OMP_CLAUSE_DECL (c), pre_p,\n@@ -6038,15 +6045,17 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \n \tcase OMP_CLAUSE_TO:\n \tcase OMP_CLAUSE_FROM:\n-\t  if (OMP_CLAUSE_SIZE (c)\n-\t      && gimplify_expr (&OMP_CLAUSE_SIZE (c), pre_p,\n-\t\t\t\tNULL, is_gimple_val, fb_rvalue) == GS_ERROR)\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  if (error_operand_p (decl))\n \t    {\n \t      remove = true;\n \t      break;\n \t    }\n-\t  decl = OMP_CLAUSE_DECL (c);\n-\t  if (error_operand_p (decl))\n+\t  if (OMP_CLAUSE_SIZE (c) == NULL_TREE)\n+\t    OMP_CLAUSE_SIZE (c) = DECL_P (decl) ? DECL_SIZE_UNIT (decl)\n+\t\t\t\t  : TYPE_SIZE_UNIT (TREE_TYPE (decl));\n+\t  if (gimplify_expr (&OMP_CLAUSE_SIZE (c), pre_p,\n+\t\t\t     NULL, is_gimple_val, fb_rvalue) == GS_ERROR)\n \t    {\n \t      remove = true;\n \t      break;\n@@ -6221,6 +6230,12 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t      remove = true;\n \t      break;\n \t    }\n+\t  if (gimplify_expr (&OMP_CLAUSE_ALIGNED_ALIGNMENT (c), pre_p, NULL,\n+\t\t\t     is_gimple_val, fb_rvalue) == GS_ERROR)\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n \t  if (!is_global_var (decl)\n \t      && TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE)\n \t    omp_add_variable (ctx, decl, GOVD_ALIGNED);\n@@ -6350,6 +6365,8 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n \t  OMP_CLAUSE_CHAIN (nc) = OMP_CLAUSE_CHAIN (clause);\n \t  OMP_CLAUSE_CHAIN (clause) = nc;\n \t}\n+      else\n+\tOMP_CLAUSE_SIZE (clause) = DECL_SIZE_UNIT (decl);\n     }\n   if (code == OMP_CLAUSE_FIRSTPRIVATE && (flags & GOVD_LASTPRIVATE) != 0)\n     {\n@@ -6518,6 +6535,8 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p)\n \t      OMP_CLAUSE_CHAIN (c) = nc;\n \t      c = nc;\n \t    }\n+\t  else if (OMP_CLAUSE_SIZE (c) == NULL_TREE)\n+\t    OMP_CLAUSE_SIZE (c) = DECL_SIZE_UNIT (decl);\n \t  break;\n \n \tcase OMP_CLAUSE_TO:\n@@ -6542,6 +6561,8 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p)\n \t\t\t\t       OMP_CLAUSE_SIZE (c), true);\n \t\t}\n \t    }\n+\t  else if (OMP_CLAUSE_SIZE (c) == NULL_TREE)\n+\t    OMP_CLAUSE_SIZE (c) = DECL_SIZE_UNIT (decl);\n \t  break;\n \n \tcase OMP_CLAUSE_REDUCTION:"}, {"sha": "adbd0eb6b26f7e4e1307f658520903d0324f140f", "filename": "gcc/omp-low.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -2996,8 +2996,10 @@ lower_rec_simd_input_clauses (tree new_var, omp_context *ctx, int &max_vf,\n \t{\n \t  tree c = find_omp_clause (gimple_omp_for_clauses (ctx->stmt),\n \t\t\t\t    OMP_CLAUSE_SAFELEN);\n-\t  if (c\n-\t      && compare_tree_int (OMP_CLAUSE_SAFELEN_EXPR (c), max_vf) == -1)\n+\t  if (c && TREE_CODE (OMP_CLAUSE_SAFELEN_EXPR (c)) != INTEGER_CST)\n+\t    max_vf = 1;\n+\t  else if (c && compare_tree_int (OMP_CLAUSE_SAFELEN_EXPR (c),\n+\t\t\t\t\t  max_vf) == -1)\n \t    max_vf = tree_to_shwi (OMP_CLAUSE_SAFELEN_EXPR (c));\n \t}\n       if (max_vf > 1)\n@@ -3745,8 +3747,9 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n       tree c = find_omp_clause (gimple_omp_for_clauses (ctx->stmt),\n \t\t\t\tOMP_CLAUSE_SAFELEN);\n       if (c == NULL_TREE\n-\t  || compare_tree_int (OMP_CLAUSE_SAFELEN_EXPR (c),\n-\t\t\t       max_vf) == 1)\n+\t  || (TREE_CODE (OMP_CLAUSE_SAFELEN_EXPR (c)) == INTEGER_CST\n+\t      && compare_tree_int (OMP_CLAUSE_SAFELEN_EXPR (c),\n+\t\t\t\t   max_vf) == 1))\n \t{\n \t  c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE_SAFELEN);\n \t  OMP_CLAUSE_SAFELEN_EXPR (c) = build_int_cst (integer_type_node,\n@@ -6900,8 +6903,10 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n       else\n \t{\n \t  safelen = OMP_CLAUSE_SAFELEN_EXPR (safelen);\n-\t  if (!tree_fits_uhwi_p (safelen)\n-\t      || tree_to_uhwi (safelen) > INT_MAX)\n+\t  if (TREE_CODE (safelen) != INTEGER_CST)\n+\t    loop->safelen = 0;\n+\t  else if (!tree_fits_uhwi_p (safelen)\n+\t\t   || tree_to_uhwi (safelen) > INT_MAX)\n \t    loop->safelen = INT_MAX;\n \t  else\n \t    loop->safelen = tree_to_uhwi (safelen);"}, {"sha": "279d4ee29cede607da669b8fb24d7e1f2069d04e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -1,3 +1,11 @@\n+2014-06-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gfortran.dg/gomp/udr2.f90 (f7, f9): Add !$omp parallel with\n+\treduction clause.\n+\t* gfortran.dg/gomp/udr4.f90 (f4): Likewise.\n+\tRemove Label is never defined expected error.\n+\t* gfortran.dg/gomp/udr8.f90: New test.\n+\n 2014-06-24  Markus Trippelsdorf  <markus@trippelsdorf.de>\n \n \tPR tree-optimization/61554"}, {"sha": "7038d1869d9b06d51d292fa69ee63f10f039d998", "filename": "gcc/testsuite/gfortran.dg/gomp/udr2.f90", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr2.f90?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -11,6 +11,10 @@ subroutine f7\n !$omp declare reduction (bar:real:omp_out = omp_out.or.omp_in) ! { dg-error \"Operands of logical operator\" }\n !$omp declare reduction (baz:real:omp_out = omp_out + omp_in)\n !$omp & initializer (a (omp_priv, omp_orig)) ! { dg-error \"Unclassifiable OpenMP directive\" }\n+  real :: r\n+  r = 0.0\n+!$omp parallel reduction (bar:r)\n+!$omp end parallel\n end subroutine f7\n subroutine f8\n   interface\n@@ -29,9 +33,15 @@ subroutine f9\n     integer :: x = 0\n     integer :: y = 0\n   end type dt\n+  integer :: i\n !$omp declare reduction (foo:integer:dt (omp_out, omp_in)) ! { dg-error \"which is not consistent with the CALL\" }\n !$omp declare reduction (bar:integer:omp_out = omp_out + omp_in) &\n !$omp & initializer (dt (omp_priv, omp_orig)) ! { dg-error \"which is not consistent with the CALL\" }\n+  i = 0\n+!$omp parallel reduction (foo : i)\n+!$omp end parallel\n+!$omp parallel reduction (bar : i)\n+!$omp end parallel\n end subroutine f9\n subroutine f10\n   integer :: a, b"}, {"sha": "b48c1090f27062c8d10eea02af93aeb843a249a7", "filename": "gcc/testsuite/gfortran.dg/gomp/udr4.f90", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr4.f90?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -23,6 +23,18 @@ subroutine f4\n !$omp & initializer(omp_priv = omp_in (omp_orig)) ! { dg-error \"Implicitly declared function omp_in used\" }\n !$omp declare reduction (id2:real:omp_out=omp_out+omp_in) &\n !$omp & initializer(omp_priv = baz (omp_orig)) ! { dg-error \"Implicitly declared function baz used\" }\n+  integer :: i\n+  real :: r\n+  i = 0\n+  r = 0\n+!$omp parallel reduction (foo: i, r)\n+!$omp end parallel\n+!$omp parallel reduction (bar: i, r)\n+!$omp end parallel\n+!$omp parallel reduction (id1: i, r)\n+!$omp end parallel\n+!$omp parallel reduction (id2: i, r)\n+!$omp end parallel\n end subroutine f4\n subroutine f5\n   interface\n@@ -37,8 +49,6 @@ end subroutine f5a\n !$omp & initializer (f5a (omp_priv, *20, omp_orig)) ! { dg-error \"Subroutine call with alternate returns in INITIALIZER clause\" }\n 10 continue\n 20 continue\n-! { dg-error \"Label\\[^\\n\\r]* is never defined\" \"\" { target *-*-* } 0 }\n-! { dg-prune-output \"<During initialization>\" }\n end subroutine f5\n subroutine f6\n   integer :: a"}, {"sha": "e040b3d1e8bbf896e1346803bca7dff1a668da63", "filename": "gcc/testsuite/gfortran.dg/gomp/udr8.f90", "status": "added", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr8.f90?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -0,0 +1,351 @@\n+! { dg-do compile }\n+! { dg-options \"-fmax-errors=1000 -fopenmp\" }\n+\n+module m\n+contains\n+  function fn1 (x, y)\n+    integer, intent(in) :: x, y\n+    integer :: fn1\n+    fn1 = x + 2 * y\n+  end function\n+  subroutine sub1 (x, y)\n+    integer, intent(in) :: y\n+    integer, intent(out) :: x\n+    x = y\n+  end subroutine\n+  function fn2 (x)\n+    integer, intent(in) :: x\n+    integer :: fn2\n+    fn2 = x\n+  end function\n+  subroutine sub2 (x, y)\n+    integer, intent(in) :: y\n+    integer, intent(inout) :: x\n+    x = x + y\n+  end subroutine\n+  function fn3 (x, y)\n+    integer, intent(in) :: x(:), y(:)\n+    integer :: fn3(lbound(x, 1):ubound(x, 1))\n+    fn3 = x + 2 * y\n+  end function\n+  subroutine sub3 (x, y)\n+    integer, intent(in) :: y(:)\n+    integer, intent(out) :: x(:)\n+    x = y\n+  end subroutine\n+  function fn4 (x)\n+    integer, intent(in) :: x(:)\n+    integer :: fn4(lbound(x, 1):ubound(x, 1))\n+    fn4 = x\n+  end function\n+  subroutine sub4 (x, y)\n+    integer, intent(in) :: y(:)\n+    integer, intent(inout) :: x(:)\n+    x = x + y\n+  end subroutine\n+  function fn5 (x, y)\n+    integer, intent(in) :: x(10), y(10)\n+    integer :: fn5(10)\n+    fn5 = x + 2 * y\n+  end function\n+  subroutine sub5 (x, y)\n+    integer, intent(in) :: y(10)\n+    integer, intent(out) :: x(10)\n+    x = y\n+  end subroutine\n+  function fn6 (x)\n+    integer, intent(in) :: x(10)\n+    integer :: fn6(10)\n+    fn6 = x\n+  end function\n+  subroutine sub6 (x, y)\n+    integer, intent(in) :: y(10)\n+    integer, intent(inout) :: x(10)\n+    x = x + y\n+  end subroutine\n+  function fn7 (x, y)\n+    integer, allocatable, intent(in) :: x(:), y(:)\n+    integer, allocatable :: fn7(:)\n+    fn7 = x + 2 * y\n+  end function\n+  subroutine sub7 (x, y)\n+    integer, allocatable, intent(in) :: y(:)\n+    integer, allocatable, intent(out) :: x(:)\n+    x = y\n+  end subroutine\n+  function fn8 (x)\n+    integer, allocatable, intent(in) :: x(:)\n+    integer, allocatable :: fn8(:)\n+    fn8 = x\n+  end function\n+  subroutine sub8 (x, y)\n+    integer, allocatable, intent(in) :: y(:)\n+    integer, allocatable, intent(inout) :: x(:)\n+    x = x + y\n+  end subroutine\n+end module\n+subroutine test1\n+  use m\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction (bar : integer : omp_out = fn1 (omp_out, omp_in)) & ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*scalar and rank-1\" }\n+!$omp & initializer (sub1 (omp_priv, omp_orig)) ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*scalar and rank-1\" }\n+!$omp declare reduction (baz : integer : sub2 (omp_out, omp_in)) & ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*scalar and rank-1\" }\n+!$omp initializer (omp_priv = fn2 (omp_orig)) ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*scalar and rank-1\" }\n+  integer :: a(10)\n+!$omp parallel reduction (foo : a)\n+!$omp end parallel\n+!$omp parallel reduction (bar : a)\n+!$omp end parallel\n+!$omp parallel reduction (baz : a)\n+!$omp end parallel\n+end subroutine test1\n+subroutine test2\n+  use m\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction (bar : integer : omp_out = fn1 (omp_out, omp_in)) &\n+!$omp & initializer (sub1 (omp_priv, omp_orig))\n+!$omp declare reduction (baz : integer : sub2 (omp_out, omp_in)) &\n+!$omp initializer (omp_priv = fn2 (omp_orig))\n+  integer :: a\n+!$omp parallel reduction (foo : a)\n+!$omp end parallel\n+!$omp parallel reduction (bar : a)\n+!$omp end parallel\n+!$omp parallel reduction (baz : a)\n+!$omp end parallel\n+end subroutine test2\n+subroutine test3\n+  use m\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction (bar : integer : omp_out = fn1 (omp_out, omp_in)) & ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*scalar and rank-1\" }\n+!$omp & initializer (sub1 (omp_priv, omp_orig)) ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*scalar and rank-1\" }\n+!$omp declare reduction (baz : integer : sub2 (omp_out, omp_in)) & ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*scalar and rank-1\" }\n+!$omp initializer (omp_priv = fn2 (omp_orig)) ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*scalar and rank-1\" }\n+  integer, allocatable :: a(:)\n+  allocate (a(10))\n+!$omp parallel reduction (foo : a)\n+!$omp end parallel\n+!$omp parallel reduction (bar : a)\n+!$omp end parallel\n+!$omp parallel reduction (baz : a)\n+!$omp end parallel\n+end subroutine test3\n+subroutine test4\n+  use m\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction (bar : integer : omp_out = fn1 (omp_out, omp_in)) &\n+!$omp & initializer (sub1 (omp_priv, omp_orig))\n+!$omp declare reduction (baz : integer : sub2 (omp_out, omp_in)) &\n+!$omp initializer (omp_priv = fn2 (omp_orig))\n+  integer, allocatable :: a\n+  allocate (a)\n+!$omp parallel reduction (foo : a)\n+!$omp end parallel\n+!$omp parallel reduction (bar : a)\n+!$omp end parallel\n+!$omp parallel reduction (baz : a)\n+!$omp end parallel\n+end subroutine test4\n+subroutine test5\n+  use m\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction (bar : integer : omp_out = fn3 (omp_out, omp_in)) &\n+!$omp & initializer (sub3 (omp_priv, omp_orig))\n+!$omp declare reduction (baz : integer : sub4 (omp_out, omp_in)) &\n+!$omp initializer (omp_priv = fn4 (omp_orig))\n+  integer :: a(10)\n+!$omp parallel reduction (foo : a)\n+!$omp end parallel\n+!$omp parallel reduction (bar : a)\n+!$omp end parallel\n+!$omp parallel reduction (baz : a)\n+!$omp end parallel\n+end subroutine test5\n+subroutine test6\n+  use m\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction (bar : integer : omp_out = fn3 (omp_out, omp_in)) & ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar|Incompatible ranks 0 and 1 in assignment\" }\n+!$omp & initializer (sub3 (omp_priv, omp_orig)) ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar\" }\n+!$omp declare reduction (baz : integer : sub4 (omp_out, omp_in)) & ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar\" }\n+!$omp initializer (omp_priv = fn4 (omp_orig)) ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar|Incompatible ranks 0 and 1 in assignment\" }\n+  integer :: a\n+!$omp parallel reduction (foo : a)\n+!$omp end parallel\n+!$omp parallel reduction (bar : a)\n+!$omp end parallel\n+!$omp parallel reduction (baz : a)\n+!$omp end parallel\n+end subroutine test6\n+subroutine test7\n+  use m\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction (bar : integer : omp_out = fn3 (omp_out, omp_in)) &\n+!$omp & initializer (sub3 (omp_priv, omp_orig))\n+!$omp declare reduction (baz : integer : sub4 (omp_out, omp_in)) &\n+!$omp initializer (omp_priv = fn4 (omp_orig))\n+  integer, allocatable :: a(:)\n+  allocate (a(10))\n+!$omp parallel reduction (foo : a)\n+!$omp end parallel\n+!$omp parallel reduction (bar : a)\n+!$omp end parallel\n+!$omp parallel reduction (baz : a)\n+!$omp end parallel\n+end subroutine test7\n+subroutine test8\n+  use m\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction (bar : integer : omp_out = fn3 (omp_out, omp_in)) & ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar|Incompatible ranks 0 and 1 in assignment\" }\n+!$omp & initializer (sub3 (omp_priv, omp_orig)) ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar\" }\n+!$omp declare reduction (baz : integer : sub4 (omp_out, omp_in)) & ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar\" }\n+!$omp initializer (omp_priv = fn4 (omp_orig)) ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar|Incompatible ranks 0 and 1 in assignment\" }\n+  integer, allocatable :: a\n+  allocate (a)\n+!$omp parallel reduction (foo : a)\n+!$omp end parallel\n+!$omp parallel reduction (bar : a)\n+!$omp end parallel\n+!$omp parallel reduction (baz : a)\n+!$omp end parallel\n+end subroutine test8\n+subroutine test9\n+  use m\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction (bar : integer : omp_out = fn5 (omp_out, omp_in)) &\n+!$omp & initializer (sub5 (omp_priv, omp_orig))\n+!$omp declare reduction (baz : integer : sub6 (omp_out, omp_in)) &\n+!$omp initializer (omp_priv = fn6 (omp_orig))\n+  integer :: a(10)\n+!$omp parallel reduction (foo : a)\n+!$omp end parallel\n+!$omp parallel reduction (bar : a)\n+!$omp end parallel\n+!$omp parallel reduction (baz : a)\n+!$omp end parallel\n+end subroutine test9\n+subroutine test10\n+  use m\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction (bar : integer : omp_out = fn5 (omp_out, omp_in)) & ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar|Incompatible ranks 0 and 1 in assignment\" }\n+!$omp & initializer (sub5 (omp_priv, omp_orig)) ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar\" }\n+!$omp declare reduction (baz : integer : sub6 (omp_out, omp_in)) & ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar\" }\n+!$omp initializer (omp_priv = fn6 (omp_orig)) ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar|Incompatible ranks 0 and 1 in assignment\" }\n+  integer :: a\n+!$omp parallel reduction (foo : a)\n+!$omp end parallel\n+!$omp parallel reduction (bar : a)\n+!$omp end parallel\n+!$omp parallel reduction (baz : a)\n+!$omp end parallel\n+end subroutine test10\n+subroutine test11\n+  use m\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction (bar : integer : omp_out = fn5 (omp_out, omp_in)) &\n+!$omp & initializer (sub5 (omp_priv, omp_orig))\n+!$omp declare reduction (baz : integer : sub6 (omp_out, omp_in)) &\n+!$omp initializer (omp_priv = fn6 (omp_orig))\n+  integer, allocatable :: a(:)\n+  allocate (a(10))\n+!$omp parallel reduction (foo : a)\n+!$omp end parallel\n+!$omp parallel reduction (bar : a)\n+!$omp end parallel\n+!$omp parallel reduction (baz : a)\n+!$omp end parallel\n+end subroutine test11\n+subroutine test12\n+  use m\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction (bar : integer : omp_out = fn5 (omp_out, omp_in)) & ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar|Incompatible ranks 0 and 1 in assignment\" }\n+!$omp & initializer (sub5 (omp_priv, omp_orig)) ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar\" }\n+!$omp declare reduction (baz : integer : sub6 (omp_out, omp_in)) & ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar\" }\n+!$omp initializer (omp_priv = fn6 (omp_orig)) ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar|Incompatible ranks 0 and 1 in assignment\" }\n+  integer, allocatable :: a\n+  allocate (a)\n+!$omp parallel reduction (foo : a)\n+!$omp end parallel\n+!$omp parallel reduction (bar : a)\n+!$omp end parallel\n+!$omp parallel reduction (baz : a)\n+!$omp end parallel\n+end subroutine test12\n+subroutine test13\n+  use m\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction (bar : integer : omp_out = & ! { dg-error \"Different shape for array assignment at \\[^\\n\\r]* on dimension 1 .9 and 10\" }\n+!$omp & fn5 (omp_out, omp_in)) & ! { dg-warning \"Actual argument contains too few elements for dummy argument \\[^\\n\\r]* .9/10\" }\n+!$omp & initializer (sub5 (omp_priv, omp_orig)) ! { dg-warning \"Actual argument contains too few elements for dummy argument \\[^\\n\\r]* .9/10\" }\n+!$omp declare reduction (baz : integer : sub6 (omp_out, omp_in)) & ! { dg-warning \"Actual argument contains too few elements for dummy argument \\[^\\n\\r]* .9/10\" }\n+!$omp initializer (omp_priv = & ! { dg-error \"Different shape for array assignment at \\[^\\n\\r]* on dimension 1 .9 and 10\" }\n+!$omp & fn6 (omp_orig)) ! { dg-warning \"Actual argument contains too few elements for dummy argument \\[^\\n\\r]* .9/10\" }\n+  integer :: a(9)\n+!$omp parallel reduction (foo : a)\n+!$omp end parallel\n+!$omp parallel reduction (bar : a)\n+!$omp end parallel\n+!$omp parallel reduction (baz : a)\n+!$omp end parallel\n+end subroutine test13\n+subroutine test14\n+  use m\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction (bar : integer : omp_out = fn7 (omp_out, omp_in)) & ! { dg-error \"Actual argument for \\[^\\n\\r]* must be ALLOCATABLE\" }\n+!$omp & initializer (sub7 (omp_priv, omp_orig)) ! { dg-error \"Actual argument for \\[^\\n\\r]* must be ALLOCATABLE\" }\n+!$omp declare reduction (baz : integer : sub8 (omp_out, omp_in)) & ! { dg-error \"Actual argument for \\[^\\n\\r]* must be ALLOCATABLE\" }\n+!$omp initializer (omp_priv = fn8 (omp_orig)) ! { dg-error \"Actual argument for \\[^\\n\\r]* must be ALLOCATABLE\" }\n+  integer :: a(10)\n+!$omp parallel reduction (foo : a)\n+!$omp end parallel\n+!$omp parallel reduction (bar : a)\n+!$omp end parallel\n+!$omp parallel reduction (baz : a)\n+!$omp end parallel\n+end subroutine test14\n+subroutine test15\n+  use m\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction (bar : integer : omp_out = fn7 (omp_out, omp_in)) & ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar|Incompatible ranks 0 and 1 in assignment\" }\n+!$omp & initializer (sub7 (omp_priv, omp_orig)) ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar\" }\n+!$omp declare reduction (baz : integer : sub8 (omp_out, omp_in)) & ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar\" }\n+!$omp initializer (omp_priv = fn8 (omp_orig)) ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar|Incompatible ranks 0 and 1 in assignment\" }\n+  integer :: a\n+!$omp parallel reduction (foo : a)\n+!$omp end parallel\n+!$omp parallel reduction (bar : a)\n+!$omp end parallel\n+!$omp parallel reduction (baz : a)\n+!$omp end parallel\n+end subroutine test15\n+subroutine test16\n+  use m\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction (bar : integer : omp_out = fn7 (omp_out, omp_in)) &\n+!$omp & initializer (sub7 (omp_priv, omp_orig))\n+!$omp declare reduction (baz : integer : sub8 (omp_out, omp_in)) &\n+!$omp initializer (omp_priv = fn8 (omp_orig))\n+  integer, allocatable :: a(:)\n+  allocate (a(10))\n+!$omp parallel reduction (foo : a)\n+!$omp end parallel\n+!$omp parallel reduction (bar : a)\n+!$omp end parallel\n+!$omp parallel reduction (baz : a)\n+!$omp end parallel\n+end subroutine test16\n+subroutine test17\n+  use m\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction (bar : integer : omp_out = fn7 (omp_out, omp_in)) & ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar|Incompatible ranks 0 and 1 in assignment\" }\n+!$omp & initializer (sub7 (omp_priv, omp_orig)) ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar\" }\n+!$omp declare reduction (baz : integer : sub8 (omp_out, omp_in)) & ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar\" }\n+!$omp initializer (omp_priv = fn8 (omp_orig)) ! { dg-error \"Rank mismatch in argument\\[^\\n\\r]*rank-1 and scalar|Incompatible ranks 0 and 1 in assignment\" }\n+  integer, allocatable :: a\n+  allocate (a)\n+!$omp parallel reduction (foo : a)\n+!$omp end parallel\n+!$omp parallel reduction (bar : a)\n+!$omp end parallel\n+!$omp parallel reduction (baz : a)\n+!$omp end parallel\n+end subroutine test17"}, {"sha": "5408fba1ff96d96eb8dc9328c4b0fe52ad985081", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 157, "deletions": 10, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -1151,8 +1151,29 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t    goto do_decl_clause;\n \t  wi->val_only = true;\n \t  wi->is_lhs = false;\n-\t  convert_nonlocal_reference_op (&OMP_CLAUSE_DECL (clause),\n-\t\t\t\t\t &dummy, wi);\n+\t  walk_tree (&OMP_CLAUSE_DECL (clause), convert_nonlocal_reference_op,\n+\t\t     wi, NULL);\n+\t  break;\n+\n+\tcase OMP_CLAUSE_ALIGNED:\n+\t  if (OMP_CLAUSE_ALIGNED_ALIGNMENT (clause))\n+\t    {\n+\t      wi->val_only = true;\n+\t      wi->is_lhs = false;\n+\t      convert_nonlocal_reference_op\n+\t\t(&OMP_CLAUSE_ALIGNED_ALIGNMENT (clause), &dummy, wi);\n+\t    }\n+\t  /* Like do_decl_clause, but don't add any suppression.  */\n+\t  decl = OMP_CLAUSE_DECL (clause);\n+\t  if (TREE_CODE (decl) == VAR_DECL\n+\t      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n+\t    break;\n+\t  if (decl_function_context (decl) != info->context)\n+\t    {\n+\t      OMP_CLAUSE_DECL (clause) = get_nonlocal_debug_decl (info, decl);\n+\t      if (OMP_CLAUSE_CODE (clause) != OMP_CLAUSE_PRIVATE)\n+\t\tneed_chain = true;\n+\t    }\n \t  break;\n \n \tcase OMP_CLAUSE_NOWAIT:\n@@ -1353,10 +1374,42 @@ convert_nonlocal_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       break;\n \n     case GIMPLE_OMP_TARGET:\n+      if (gimple_omp_target_kind (stmt) != GF_OMP_TARGET_KIND_REGION)\n+\t{\n+\t  save_suppress = info->suppress_expansion;\n+\t  convert_nonlocal_omp_clauses (gimple_omp_target_clauses_ptr (stmt),\n+\t\t\t\t\twi);\n+\t  info->suppress_expansion = save_suppress;\n+\t  walk_body (convert_nonlocal_reference_stmt,\n+\t\t     convert_nonlocal_reference_op, info,\n+\t\t     gimple_omp_body_ptr (stmt));\n+\t  break;\n+\t}\n       save_suppress = info->suppress_expansion;\n-      convert_nonlocal_omp_clauses (gimple_omp_target_clauses_ptr (stmt), wi);\n+      if (convert_nonlocal_omp_clauses (gimple_omp_target_clauses_ptr (stmt),\n+\t\t\t\t\twi))\n+\t{\n+\t  tree c, decl;\n+\t  decl = get_chain_decl (info);\n+\t  c = build_omp_clause (gimple_location (stmt), OMP_CLAUSE_MAP);\n+\t  OMP_CLAUSE_DECL (c) = decl;\n+\t  OMP_CLAUSE_MAP_KIND (c) = OMP_CLAUSE_MAP_TO;\n+\t  OMP_CLAUSE_SIZE (c) = DECL_SIZE_UNIT (decl);\n+\t  OMP_CLAUSE_CHAIN (c) = gimple_omp_target_clauses (stmt);\n+\t  gimple_omp_target_set_clauses (stmt, c);\n+\t}\n+\n+      save_local_var_chain = info->new_local_var_chain;\n+      info->new_local_var_chain = NULL;\n+\n       walk_body (convert_nonlocal_reference_stmt, convert_nonlocal_reference_op,\n \t\t info, gimple_omp_body_ptr (stmt));\n+\n+      if (info->new_local_var_chain)\n+\tdeclare_vars (info->new_local_var_chain,\n+\t\t      gimple_seq_first_stmt (gimple_omp_body (stmt)),\n+\t\t      false);\n+      info->new_local_var_chain = save_local_var_chain;\n       info->suppress_expansion = save_suppress;\n       break;\n \n@@ -1728,10 +1781,35 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t    goto do_decl_clause;\n \t  wi->val_only = true;\n \t  wi->is_lhs = false;\n-\t  convert_local_reference_op (&OMP_CLAUSE_DECL (clause),\n-\t\t\t\t      &dummy, wi);\n+\t  walk_tree (&OMP_CLAUSE_DECL (clause), convert_local_reference_op,\n+\t\t     wi, NULL);\n \t  break;\n \n+\tcase OMP_CLAUSE_ALIGNED:\n+\t  if (OMP_CLAUSE_ALIGNED_ALIGNMENT (clause))\n+\t    {\n+\t      wi->val_only = true;\n+\t      wi->is_lhs = false;\n+\t      convert_local_reference_op\n+\t\t(&OMP_CLAUSE_ALIGNED_ALIGNMENT (clause), &dummy, wi);\n+\t    }\n+\t  /* Like do_decl_clause, but don't add any suppression.  */\n+\t  decl = OMP_CLAUSE_DECL (clause);\n+\t  if (TREE_CODE (decl) == VAR_DECL\n+\t      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n+\t    break;\n+\t  if (decl_function_context (decl) == info->context\n+\t      && !use_pointer_in_frame (decl))\n+\t    {\n+\t      tree field = lookup_field_for_decl (info, decl, NO_INSERT);\n+\t      if (field)\n+\t\t{\n+\t\t  OMP_CLAUSE_DECL (clause)\n+\t\t    = get_local_debug_decl (info, decl, field);\n+\t\t  need_frame = true;\n+\t\t}\n+\t    }\n+\t  break;\n \n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n@@ -1862,10 +1940,38 @@ convert_local_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       break;\n \n     case GIMPLE_OMP_TARGET:\n+      if (gimple_omp_target_kind (stmt) != GF_OMP_TARGET_KIND_REGION)\n+\t{\n+\t  save_suppress = info->suppress_expansion;\n+\t  convert_local_omp_clauses (gimple_omp_target_clauses_ptr (stmt), wi);\n+\t  info->suppress_expansion = save_suppress;\n+\t  walk_body (convert_local_reference_stmt, convert_local_reference_op,\n+\t\t     info, gimple_omp_body_ptr (stmt));\n+\t  break;\n+\t}\n       save_suppress = info->suppress_expansion;\n-      convert_local_omp_clauses (gimple_omp_target_clauses_ptr (stmt), wi);\n-      walk_body (convert_local_reference_stmt, convert_local_reference_op,\n-\t\t info, gimple_omp_body_ptr (stmt));\n+      if (convert_local_omp_clauses (gimple_omp_target_clauses_ptr (stmt), wi))\n+\t{\n+\t  tree c;\n+\t  (void) get_frame_type (info);\n+\t  c = build_omp_clause (gimple_location (stmt), OMP_CLAUSE_MAP);\n+\t  OMP_CLAUSE_DECL (c) = info->frame_decl;\n+\t  OMP_CLAUSE_MAP_KIND (c) = OMP_CLAUSE_MAP_TOFROM;\n+\t  OMP_CLAUSE_SIZE (c) = DECL_SIZE_UNIT (info->frame_decl);\n+\t  OMP_CLAUSE_CHAIN (c) = gimple_omp_target_clauses (stmt);\n+\t  gimple_omp_target_set_clauses (stmt, c);\n+\t}\n+\n+      save_local_var_chain = info->new_local_var_chain;\n+      info->new_local_var_chain = NULL;\n+\n+      walk_body (convert_local_reference_stmt, convert_local_reference_op, info,\n+\t\t gimple_omp_body_ptr (stmt));\n+\n+      if (info->new_local_var_chain)\n+\tdeclare_vars (info->new_local_var_chain,\n+\t\t      gimple_seq_first_stmt (gimple_omp_body (stmt)), false);\n+      info->new_local_var_chain = save_local_var_chain;\n       info->suppress_expansion = save_suppress;\n       break;\n \n@@ -2166,6 +2272,13 @@ convert_tramp_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \tbreak;\n       }\n \n+    case GIMPLE_OMP_TARGET:\n+      if (gimple_omp_target_kind (stmt) != GF_OMP_TARGET_KIND_REGION)\n+\t{\n+\t  *handled_ops_p = false;\n+\t  return NULL_TREE;\n+\t}\n+      /* FALLTHRU */\n     case GIMPLE_OMP_PARALLEL:\n     case GIMPLE_OMP_TASK:\n       {\n@@ -2186,7 +2299,6 @@ convert_tramp_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n     default:\n       *handled_ops_p = false;\n       return NULL_TREE;\n-      break;\n     }\n \n   *handled_ops_p = true;\n@@ -2258,14 +2370,49 @@ convert_gimple_call (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       info->static_chain_added |= save_static_chain_added;\n       break;\n \n+    case GIMPLE_OMP_TARGET:\n+      if (gimple_omp_target_kind (stmt) != GF_OMP_TARGET_KIND_REGION)\n+\t{\n+\t  walk_body (convert_gimple_call, NULL, info, gimple_omp_body_ptr (stmt));\n+\t  break;\n+\t}\n+      save_static_chain_added = info->static_chain_added;\n+      info->static_chain_added = 0;\n+      walk_body (convert_gimple_call, NULL, info, gimple_omp_body_ptr (stmt));\n+      for (i = 0; i < 2; i++)\n+\t{\n+\t  tree c, decl;\n+\t  if ((info->static_chain_added & (1 << i)) == 0)\n+\t    continue;\n+\t  decl = i ? get_chain_decl (info) : info->frame_decl;\n+\t  /* Don't add CHAIN.* or FRAME.* twice.  */\n+\t  for (c = gimple_omp_target_clauses (stmt);\n+\t       c;\n+\t       c = OMP_CLAUSE_CHAIN (c))\n+\t    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t\t&& OMP_CLAUSE_DECL (c) == decl)\n+\t      break;\n+\t  if (c == NULL)\n+\t    {\n+\t      c = build_omp_clause (gimple_location (stmt), OMP_CLAUSE_MAP);\n+\t      OMP_CLAUSE_DECL (c) = decl;\n+\t      OMP_CLAUSE_MAP_KIND (c)\n+\t\t= i ? OMP_CLAUSE_MAP_TO : OMP_CLAUSE_MAP_TOFROM;\n+\t      OMP_CLAUSE_SIZE (c) = DECL_SIZE_UNIT (decl);\n+\t      OMP_CLAUSE_CHAIN (c) = gimple_omp_target_clauses (stmt);\n+\t      gimple_omp_target_set_clauses (stmt, c);\n+\t    }\n+\t}\n+      info->static_chain_added |= save_static_chain_added;\n+      break;\n+\n     case GIMPLE_OMP_FOR:\n       walk_body (convert_gimple_call, NULL, info,\n \t  \t gimple_omp_for_pre_body_ptr (stmt));\n       /* FALLTHRU */\n     case GIMPLE_OMP_SECTIONS:\n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_SINGLE:\n-    case GIMPLE_OMP_TARGET:\n     case GIMPLE_OMP_TEAMS:\n     case GIMPLE_OMP_MASTER:\n     case GIMPLE_OMP_TASKGROUP:"}, {"sha": "4b63b9a3ce0a03d737acd784b484530ccddfed03", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -1,3 +1,22 @@\n+2014-06-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/aligned1.f03: New test.\n+\t* testsuite/libgomp.fortran/nestedfn5.f90: New test.\n+\t* testsuite/libgomp.fortran/target7.f90: Surround loop spawning\n+\ttasks with !$omp parallel !$omp single.\n+\t* testsuite/libgomp.fortran/target8.f90: New test.\n+\t* testsuite/libgomp.fortran/udr4.f90 (foo UDR, bar UDR): Adjust\n+\tnot to use trim in the combiner, instead call elemental function.\n+\t(fn): New elemental function.\n+\t* testsuite/libgomp.fortran/udr6.f90 (do_add, dp_add, dp_init):\n+\tMake elemental.\n+\t* testsuite/libgomp.fortran/udr7.f90 (omp_priv, omp_orig, omp_out,\n+\tomp_in): Likewise.\n+\t* testsuite/libgomp.fortran/udr12.f90: New test.\n+\t* testsuite/libgomp.fortran/udr13.f90: New test.\n+\t* testsuite/libgomp.fortran/udr14.f90: New test.\n+\t* testsuite/libgomp.fortran/udr15.f90: New test.\n+\n 2014-06-18  Jakub Jelinek  <jakub@redhat.com>\n \n \t* omp_lib.f90.in (openmp_version): Set to 201307."}, {"sha": "67a9ab404236deefc31ff144f9f85d4670e1cfa1", "filename": "libgomp/testsuite/libgomp.fortran/aligned1.f03", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Faligned1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Faligned1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Faligned1.f03?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -0,0 +1,133 @@\n+! { dg-do run }\n+! { dg-options \"-fopenmp -fcray-pointer\" }\n+\n+  use iso_c_binding, only : c_ptr, c_ptrdiff_t, c_loc\n+  interface\n+    subroutine foo (x, y, z, w)\n+      use iso_c_binding, only : c_ptr\n+      real, pointer :: x(:), y(:), w(:)\n+      type(c_ptr) :: z\n+    end subroutine\n+    subroutine bar (x, y, z, w)\n+      use iso_c_binding, only : c_ptr\n+      real, pointer :: x(:), y(:), w(:)\n+      type(c_ptr) :: z\n+    end subroutine\n+    subroutine baz (x, c)\n+      real, pointer :: x(:)\n+      real, allocatable :: c(:)\n+    end subroutine\n+  end interface\n+  type dt\n+    real, allocatable :: a(:)\n+  end type\n+  type (dt) :: b(64)\n+  real, target :: a(4096+63)\n+  real, pointer :: p(:), q(:), r(:), s(:)\n+  real, allocatable :: c(:)\n+  integer(c_ptrdiff_t) :: o\n+  integer :: i\n+  o = 64 - mod (loc (a), 64)\n+  if (o == 64) o = 0\n+  o = o / sizeof(0.0)\n+  p => a(o + 1:o + 1024)\n+  q => a(o + 1025:o + 2048)\n+  r => a(o + 2049:o + 3072)\n+  s => a(o + 3073:o + 4096)\n+  do i = 1, 1024\n+    p(i) = i\n+    q(i) = i\n+    r(i) = i\n+    s(i) = i\n+  end do\n+  call foo (p, q, c_loc (r(1)), s)\n+  do i = 1, 1024\n+    if (p(i) /= i * i + 3 * i + 2) call abort\n+    p(i) = i\n+  end do\n+  call bar (p, q, c_loc (r(1)), s)\n+  do i = 1, 1024\n+    if (p(i) /= i * i + 3 * i + 2) call abort\n+  end do\n+  ! Attempt to create 64-byte aligned allocatable\n+  do i = 1, 64\n+    allocate (c(1023 + i))\n+    if (iand (loc (c(1)), 63) == 0) exit\n+    deallocate (c)\n+    allocate (b(i)%a(1023 + i))\n+    allocate (c(1023 + i))\n+    if (iand (loc (c(1)), 63) == 0) exit\n+    deallocate (c)\n+  end do\n+  if (allocated (c)) then\n+    do i = 1, 1024\n+      c(i) = 2 * i\n+    end do\n+    call baz (p, c)\n+    do i = 1, 1024\n+      if (p(i) /= i * i + 5 * i + 2) call abort\n+    end do\n+  end if\n+end\n+subroutine foo (x, y, z, w)\n+  use iso_c_binding, only : c_ptr, c_f_pointer\n+  real, pointer :: x(:), y(:), w(:), p(:)\n+  type(c_ptr) :: z\n+  integer :: i\n+  real :: pt(1024)\n+  pointer (ip, pt)\n+  ip = loc (w)\n+!$omp simd aligned (x, y : 64)\n+  do i = 1, 1024\n+    x(i) = x(i) * y(i) + 2.0\n+  end do\n+!$omp simd aligned (x, z : 64) private (p)\n+  do i = 1, 1024\n+    call c_f_pointer (z, p, shape=[1024])\n+    x(i) = x(i) + p(i)\n+  end do\n+!$omp simd aligned (x, ip : 64)\n+  do i = 1, 1024\n+    x(i) = x(i) + 2 * pt(i)\n+  end do\n+!$omp end simd\n+end subroutine\n+subroutine bar (x, y, z, w)\n+  use iso_c_binding, only : c_ptr, c_f_pointer\n+  real, pointer :: x(:), y(:), w(:), a(:), b(:)\n+  type(c_ptr) :: z, c\n+  integer :: i\n+  real :: pt(1024)\n+  pointer (ip, pt)\n+  ip = loc (w)\n+  a => x\n+  b => y\n+  c = z\n+!$omp simd aligned (a, b : 64)\n+  do i = 1, 1024\n+    a(i) = a(i) * b(i) + 2.0\n+  end do\n+!$omp simd aligned (a, c : 64)\n+  do i = 1, 1024\n+    block\n+      real, pointer :: p(:)\n+      call c_f_pointer (c, p, shape=[1024])\n+      a(i) = a(i) + p(i)\n+    end block\n+  end do\n+!$omp simd aligned (a, ip : 64)\n+  do i = 1, 1024\n+    a(i) = a(i) + 2 * pt(i)\n+  end do\n+!$omp end simd\n+end subroutine\n+subroutine baz (x, c)\n+  real, pointer :: x(:)\n+  real, allocatable :: c(:)\n+  integer :: i\n+!$omp simd aligned (x, c : 64)\n+  do i = 1, 1024\n+    x(i) = x(i) + c(i)\n+  end do\n+!$omp end simd\n+end subroutine baz"}, {"sha": "f67bd47e17d29aaa9b6a2bd918c927a5ecaa2376", "filename": "libgomp/testsuite/libgomp.fortran/nestedfn5.f90", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnestedfn5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnestedfn5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnestedfn5.f90?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -0,0 +1,96 @@\n+! { dg-do run }\n+\n+  interface\n+    subroutine bar (q)\n+      integer :: q(19:)\n+    end subroutine\n+  end interface\n+  integer :: q(7:15)\n+  q(:) = 5\n+  call bar (q)\n+end\n+subroutine bar (q)\n+  use iso_c_binding, only: c_ptr, c_loc, c_int\n+  integer :: a, b, c, d(2:3,4:5), q(19:), h, k, m, n, o, p\n+  integer(c_int), target :: e(64)\n+  type (c_ptr) :: f, g(64)\n+  logical :: l\n+  a = 1\n+  b = 2\n+  c = 3\n+  d = 4\n+  l = .false.\n+  f = c_loc (e)\n+  call foo\n+contains\n+  subroutine foo\n+    use iso_c_binding, only: c_sizeof\n+!$omp simd linear(a:2) linear(b:1)\n+    do a = 1, 20, 2\n+      b = b + 1\n+    end do\n+!$omp end simd\n+    if (a /= 21 .or. b /= 12) call abort\n+!$omp simd aligned(f : c_sizeof (e(1)))\n+    do b = 1, 64\n+      g(b) = f\n+    end do\n+!$omp end simd\n+!$omp parallel\n+!$omp single\n+!$omp taskgroup\n+!$omp task depend(out : a, d(2:2,4:5))\n+    a = a + 1\n+    d(2:2,4:5) = d(2:2,4:5) + 1\n+!$omp end task\n+!$omp task depend(in : a, d(2:2,4:5))\n+    if (a /= 22) call abort\n+    if (any (d(2:2,4:5) /= 5)) call abort\n+!$omp end task\n+!$omp end taskgroup\n+!$omp end single\n+!$omp end parallel\n+    b = 10\n+!$omp target data map (tofrom: a, d(2:3,4:4), q) map (from: l)\n+!$omp target map (tofrom: b, d(2:3,4:4))\n+    l = .false.\n+    if (a /= 22 .or. any (q /= 5)) l = .true.\n+    if (lbound (q, 1) /= 19 .or. ubound (q, 1) /= 27) l = .true.\n+    if (d(2,4) /= 5 .or. d(3,4) /= 4) l = .true.\n+    l = l .or. (b /= 10)\n+    a = 6\n+    b = 11\n+    q = 8\n+    d(2:3,4:4) = 9\n+!$omp end target\n+!$omp target update from (a, q, d(2:3,4:4), l)\n+    if (a /= 6 .or. l .or. b /= 11 .or. any (q /= 8)) call abort\n+    if (any (d(2:3,4:4) /= 9) .or. d(2,5) /= 5 .or. d(3,5) /= 4) call abort\n+    a = 12\n+    b = 13\n+    q = 14\n+    d = 15\n+!$omp target update to (a, q, d(2:3,4:4))\n+!$omp target map (tofrom: b, d(2:3,4:4))\n+    if (a /= 12 .or. b /= 13 .or. any (q /= 14)) l = .true.\n+    l = l .or. any (d(2:3,4:4) /= 15)\n+!$omp end target\n+    a = 0\n+    b = 1\n+    c = 100\n+    h = 8\n+    m = 0\n+    n = 64\n+    o = 16\n+    if (l) call abort\n+!$omp target teams distribute parallel do simd if (.not.l) device(a) &\n+!$omp & num_teams(b) dist_schedule(static, c) num_threads (h) &\n+!$omp & reduction (+: m) safelen (n) schedule(static, o)\n+    do p = 1, 64\n+      m = m + 1\n+    end do\n+!$omp end target teams distribute parallel do simd\n+    if (m /= 64) call abort\n+!$omp end target data\n+  end subroutine foo\n+end subroutine bar"}, {"sha": "0c977c44ae1d2c065682f25d710b3ffd2a46e032", "filename": "libgomp/testsuite/libgomp.fortran/target7.f90", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget7.f90?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -13,6 +13,8 @@ end function foo\n   do i = 1, n\n     a(i) = i\n   end do\n+  !$omp parallel\n+  !$omp single\n   do i = 1, n, c\n     !$omp task shared(a)\n       !$omp target map(a(i:i+c-1))\n@@ -23,6 +25,8 @@ end function foo\n       !$omp end target\n     !$omp end task\n   end do\n+  !$omp end single\n+  !$omp end parallel\n   do i = 1, n\n     if (a(i) /= i + 1) call abort\n   end do"}, {"sha": "0564e90e08eac0c1004612381d37fa586c4ea5b7", "filename": "libgomp/testsuite/libgomp.fortran/target8.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget8.f90?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+\n+  integer, parameter :: n = 1000\n+  integer, parameter :: c = 100\n+  integer :: i, j\n+  real :: a(n)\n+  do i = 1, n\n+    a(i) = i\n+  end do\n+  !$omp parallel\n+  !$omp single\n+  do i = 1, n, c\n+    !$omp task shared(a)\n+      !$omp target map(a(i:i+c-1))\n+        !$omp parallel do\n+          do j = i, i + c - 1\n+            a(j) = foo (a(j))\n+          end do\n+      !$omp end target\n+    !$omp end task\n+  end do\n+  !$omp end single\n+  !$omp end parallel\n+  do i = 1, n\n+    if (a(i) /= i + 1) call abort\n+  end do\n+contains\n+  real function foo (x)\n+    !$omp declare target\n+    real, intent(in) :: x\n+    foo = x + 1\n+  end function foo\n+end"}, {"sha": "601bca6a93e1ad09a34854ff008b28d2186c3d7f", "filename": "libgomp/testsuite/libgomp.fortran/udr12.f90", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr12.f90?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -0,0 +1,76 @@\n+! { dg-do run }\n+\n+  interface\n+    elemental subroutine sub1 (x, y)\n+      integer, intent(in) :: y\n+      integer, intent(out) :: x\n+    end subroutine\n+    elemental function fn2 (x)\n+      integer, intent(in) :: x\n+      integer :: fn2\n+    end function\n+  end interface\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction (bar : integer : omp_out = fn1 (omp_out, omp_in)) &\n+!$omp & initializer (sub1 (omp_priv, omp_orig))\n+!$omp declare reduction (baz : integer : sub2 (omp_out, omp_in)) &\n+!$omp initializer (omp_priv = fn2 (omp_orig))\n+  interface\n+    elemental function fn1 (x, y)\n+      integer, intent(in) :: x, y\n+      integer :: fn1\n+    end function\n+    elemental subroutine sub2 (x, y)\n+      integer, intent(in) :: y\n+      integer, intent(inout) :: x\n+    end subroutine\n+  end interface\n+  integer :: a(10), b, r\n+  a(:) = 0\n+  b = 0\n+  r = 0\n+!$omp parallel reduction (foo : a, b) reduction (+: r)\n+  a = a + 2\n+  b = b + 3\n+  r = r + 1\n+!$omp end parallel\n+  if (any (a /= 2 * r) .or. b /= 3 * r) call abort\n+  a(:) = 0\n+  b = 0\n+  r = 0\n+!$omp parallel reduction (bar : a, b) reduction (+: r)\n+  a = a + 2\n+  b = b + 3\n+  r = r + 1\n+!$omp end parallel\n+  if (any (a /= 4 * r) .or. b /= 6 * r) call abort\n+  a(:) = 0\n+  b = 0\n+  r = 0\n+!$omp parallel reduction (baz : a, b) reduction (+: r)\n+  a = a + 2\n+  b = b + 3\n+  r = r + 1\n+!$omp end parallel\n+  if (any (a /= 2 * r) .or. b /= 3 * r) call abort\n+end\n+elemental function fn1 (x, y)\n+  integer, intent(in) :: x, y\n+  integer :: fn1\n+  fn1 = x + 2 * y\n+end function\n+elemental subroutine sub1 (x, y)\n+  integer, intent(in) :: y\n+  integer, intent(out) :: x\n+  x = 0\n+end subroutine\n+elemental function fn2 (x)\n+  integer, intent(in) :: x\n+  integer :: fn2\n+  fn2 = x\n+end function\n+elemental subroutine sub2 (x, y)\n+  integer, intent(inout) :: x\n+  integer, intent(in) :: y\n+  x = x + y\n+end subroutine"}, {"sha": "0da1da4bc65b38708e6bf388ae503d4dc20660c9", "filename": "libgomp/testsuite/libgomp.fortran/udr13.f90", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr13.f90?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -0,0 +1,106 @@\n+! { dg-do run }\n+\n+  interface\n+    subroutine sub1 (x, y)\n+      integer, intent(in) :: y(:)\n+      integer, intent(out) :: x(:)\n+    end subroutine\n+    function fn2 (x, m1, m2, n1, n2)\n+      integer, intent(in) :: x(:,:), m1, m2, n1, n2\n+      integer :: fn2(m1:m2,n1:n2)\n+    end function\n+    subroutine sub3 (x, y)\n+      integer, allocatable, intent(in) :: y(:,:)\n+      integer, allocatable, intent(inout) :: x(:,:)\n+    end subroutine\n+  end interface\n+!$omp declare reduction (foo : integer : sub3 (omp_out, omp_in)) &\n+!$omp initializer (omp_priv = fn3 (omp_orig))\n+!$omp declare reduction (bar : integer : omp_out = fn1 (omp_out, omp_in, &\n+!$omp & lbound (omp_out, 1), ubound (omp_out, 1))) &\n+!$omp & initializer (sub1 (omp_priv, omp_orig))\n+!$omp declare reduction (baz : integer : sub2 (omp_out, omp_in)) &\n+!$omp initializer (omp_priv = fn2 (omp_orig, lbound (omp_priv, 1), &\n+!$omp ubound (omp_priv, 1), lbound (omp_priv, 2), ubound (omp_priv, 2)))\n+  interface\n+    function fn1 (x, y, m1, m2)\n+      integer, intent(in) :: x(:), y(:), m1, m2\n+      integer :: fn1(m1:m2)\n+    end function\n+    subroutine sub2 (x, y)\n+      integer, intent(in) :: y(:,:)\n+      integer, intent(inout) :: x(:,:)\n+    end subroutine\n+    function fn3 (x)\n+      integer, allocatable, intent(in) :: x(:,:)\n+      integer, allocatable :: fn3(:,:)\n+    end function\n+  end interface\n+  integer :: a(10), b(3:5,7:9), r\n+  integer, allocatable :: c(:,:)\n+  a(:) = 0\n+  r = 0\n+!$omp parallel reduction (bar : a) reduction (+: r)\n+  if (lbound (a, 1) /= 1 .or. ubound (a, 1) /= 10) call abort\n+  a = a + 2\n+  r = r + 1\n+!$omp end parallel\n+  if (any (a /= 4 * r) ) call abort\n+  b(:,:) = 0\n+  allocate (c (4:6,8:10))\n+  c(:,:) = 0\n+  r = 0\n+!$omp parallel reduction (baz : b, c) reduction (+: r)\n+  if (lbound (b, 1) /= 3 .or. ubound (b, 1) /= 5) call abort\n+  if (lbound (b, 2) /= 7 .or. ubound (b, 2) /= 9) call abort\n+  if (.not. allocated (c)) call abort\n+  if (lbound (c, 1) /= 4 .or. ubound (c, 1) /= 6) call abort\n+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 10) call abort\n+  b = b + 3\n+  c = c + 4\n+  r = r + 1\n+!$omp end parallel\n+  if (any (b /= 3 * r) .or. any (c /= 4 * r)) call abort\n+  deallocate (c)\n+  allocate (c (0:1,7:11))\n+  c(:,:) = 0\n+  r = 0\n+!$omp parallel reduction (foo : c) reduction (+: r)\n+  if (.not. allocated (c)) call abort\n+  if (lbound (c, 1) /= 0 .or. ubound (c, 1) /= 1) call abort\n+  if (lbound (c, 2) /= 7 .or. ubound (c, 2) /= 11) call abort\n+  c = c + 5\n+  r = r + 1\n+!$omp end parallel\n+  if (any (c /= 10 * r)) call abort\n+end\n+function fn1 (x, y, m1, m2)\n+  integer, intent(in) :: x(:), y(:), m1, m2\n+  integer :: fn1(m1:m2)\n+  fn1 = x + 2 * y\n+end function\n+subroutine sub1 (x, y)\n+  integer, intent(in) :: y(:)\n+  integer, intent(out) :: x(:)\n+  x = 0\n+end subroutine\n+function fn2 (x, m1, m2, n1, n2)\n+  integer, intent(in) :: x(:,:), m1, m2, n1, n2\n+  integer :: fn2(m1:m2,n1:n2)\n+  fn2 = x\n+end function\n+subroutine sub2 (x, y)\n+  integer, intent(inout) :: x(:,:)\n+  integer, intent(in) :: y(:,:)\n+  x = x + y\n+end subroutine\n+function fn3 (x)\n+  integer, allocatable, intent(in) :: x(:,:)\n+  integer, allocatable :: fn3(:,:)\n+  fn3 = x\n+end function\n+subroutine sub3 (x, y)\n+  integer, allocatable, intent(inout) :: x(:,:)\n+  integer, allocatable, intent(in) :: y(:,:)\n+  x = x + 2 * y\n+end subroutine"}, {"sha": "d6974585578b4c27f7db6907ff8c74c103dcac8e", "filename": "libgomp/testsuite/libgomp.fortran/udr14.f90", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr14.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr14.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr14.f90?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -0,0 +1,50 @@\n+! { dg-do run }\n+\n+  type dt\n+    integer :: g\n+    integer, allocatable :: h(:)\n+  end type\n+!$omp declare reduction (baz : dt : bar (omp_out, omp_in)) &\n+!$omp & initializer (foo (omp_priv, omp_orig))\n+  integer :: r\n+  type (dt), allocatable :: a(:)\n+  allocate (a(7:8))\n+  a(:)%g = 0\n+  a(7)%h = (/ 0, 0, 0 /)\n+  r = 0\n+!$omp parallel reduction(+:r) reduction (baz:a)\n+  if (.not.allocated (a)) call abort\n+  if (lbound (a, 1) /= 7 .or. ubound (a, 1) /= 8) call abort\n+  if (.not.allocated (a(7)%h)) call abort\n+  if (allocated (a(8)%h)) call abort\n+  if (lbound (a(7)%h, 1) /= 1 .or. ubound (a(7)%h, 1) /= 3) call abort\n+  a(:)%g = a(:)%g + 2\n+  a(7)%h = a(7)%h + 3\n+  r = r + 1\n+!$omp end parallel\n+  if (.not.allocated (a)) call abort\n+  if (lbound (a, 1) /= 7 .or. ubound (a, 1) /= 8) call abort\n+  if (.not.allocated (a(7)%h)) call abort\n+  if (allocated (a(8)%h)) call abort\n+  if (lbound (a(7)%h, 1) /= 1 .or. ubound (a(7)%h, 1) /= 3) call abort\n+  if (any (a(:)%g /= 2 * r) .or. any (a(7)%h(:) /= 3 * r)) call abort\n+contains\n+  subroutine foo (x, y)\n+    type (dt), allocatable :: x(:), y(:)\n+    if (allocated (x) .neqv. allocated (y)) call abort\n+    if (lbound (x, 1) /= lbound (y, 1)) call abort\n+    if (ubound (x, 1) /= ubound (y, 1)) call abort\n+    if (allocated (x(7)%h) .neqv. allocated (y(7)%h)) call abort\n+    if (allocated (x(8)%h) .neqv. allocated (y(8)%h)) call abort\n+    if (lbound (x(7)%h, 1) /= lbound (y(7)%h, 1)) call abort\n+    if (ubound (x(7)%h, 1) /= ubound (y(7)%h, 1)) call abort\n+    x(7)%g = 0\n+    x(7)%h = 0\n+    x(8)%g = 0\n+  end subroutine\n+  subroutine bar (x, y)\n+    type (dt), allocatable :: x(:), y(:)\n+    x(:)%g = x(:)%g + y(:)%g\n+    x(7)%h(:) = x(7)%h(:) + y(7)%h(:)\n+  end subroutine\n+end"}, {"sha": "2d1169568dd9a5d5bf209caa8e1c6a687f9dff36", "filename": "libgomp/testsuite/libgomp.fortran/udr15.f90", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr15.f90?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -0,0 +1,64 @@\n+! { dg-do run }\n+\n+module udr15m1\n+  integer, parameter :: a = 6\n+  integer :: b\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in)\n+!$omp declare reduction (.add. : integer : &\n+!$omp & omp_out = omp_out .add. f3 (omp_in, -4)) &\n+!$omp & initializer (s1 (omp_priv, omp_orig))\n+  interface operator (.add.)\n+    module procedure f1\n+  end interface\n+contains\n+  integer function f1 (x, y)\n+    integer, intent (in) :: x, y\n+    f1 = x + y\n+  end function f1\n+  integer function f3 (x, y)\n+    integer, intent (in) :: x, y\n+    f3 = iand (x, y)\n+  end function f3\n+  subroutine s1 (x, y)\n+    integer, intent (in) :: y\n+    integer, intent (out) :: x\n+    x = 3\n+  end subroutine s1\n+end module udr15m1\n+module udr15m2\n+  use udr15m1, f4 => f1, f5 => f3, s2 => s1, operator (.addtwo.) => operator (.add.)\n+  type dt\n+    integer :: x\n+  end type\n+!$omp declare reduction (+ : dt : omp_out = f6 (omp_out + omp_in)) &\n+!$omp & initializer (s3 (omp_priv))\n+  interface operator (+)\n+    module procedure f2\n+  end interface\n+contains\n+  type(dt) function f2 (x, y)\n+    type(dt), intent (in) :: x, y\n+    f2%x = x%x + y%x\n+  end function f2\n+  type(dt) function f6 (x)\n+    type(dt), intent (in) :: x\n+    f6%x = x%x\n+  end function f6\n+  subroutine s3 (x)\n+    type(dt), intent (out) :: x\n+    x = dt(0)\n+  end subroutine\n+end module udr15m2\n+  use udr15m2, operator (.addthree.) => operator (.addtwo.), &\n+               f7 => f4, f8 => f6, s4 => s3\n+  integer :: i, j\n+  type(dt) :: d\n+  j = 3\n+  d%x = 0\n+!$omp parallel do reduction (.addthree.: j) reduction (+ : d)\n+  do i = 1, 100\n+    j = j.addthree.iand (i, -4)\n+    d = d + dt(i)\n+  end do\n+  if (d%x /= 5050 .or. j /= 4903) call abort\n+end"}, {"sha": "89365476af7eda7ad9b5ea479ec07b24a469b99d", "filename": "libgomp/testsuite/libgomp.fortran/udr4.f90", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr4.f90?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -1,16 +1,22 @@\n ! { dg-do run }\n \n !$omp declare reduction (foo : character(kind=1, len=*) &\n-!$omp & : omp_out = trim(omp_out) // omp_in) initializer (omp_priv = '')\n+!$omp & : omp_out = fn (omp_out, omp_in)) initializer (omp_priv = '')\n !$omp declare reduction (bar : character(kind=1, len=:) &\n-!$omp & : omp_out = trim(omp_in) // omp_out) initializer (omp_priv = '')\n+!$omp & : omp_out = fn (omp_in, omp_out)) initializer (omp_priv = '')\n !$omp declare reduction (baz : character(kind=1, len=1) &\n !$omp & : omp_out = char (ichar (omp_out) + ichar (omp_in) &\n !$omp & - ichar ('0'))) initializer (omp_priv = '0')\n !$omp declare reduction (baz : character(kind=1, len=2) &\n !$omp & : omp_out = char (ichar (omp_out(1:1)) + ichar (omp_in(1:1)) &\n !$omp & - ichar ('0')) // char (ichar (omp_out(2:2)) + &\n !$omp & ichar (omp_in(2:2)) - ichar ('0'))) initializer (omp_priv = '00')\n+  interface\n+    elemental function fn (x, y)\n+      character (len=64), intent (in) :: x, y\n+      character (len=64) :: fn\n+    end function\n+  end interface\n   character(kind=1, len=64) :: c(-3:-2,1:1,7:8), d(2:3,-7:-5)\n   character(kind = 1, len=1) :: e(2:4)\n   character(kind = 1, len=1+1) :: f(8:10,9:10)\n@@ -37,3 +43,8 @@\n   if (any (f(:,:)(1:1).ne.char (ichar ('0') + 32))) call abort\n   if (any (f(:,:)(2:2).ne.char (ichar ('0') + 64))) call abort\n end\n+elemental function fn (x, y)\n+  character (len=64), intent (in) :: x, y\n+  character (len=64) :: fn\n+  fn = trim(x) // y\n+end function"}, {"sha": "20736fb79db34adcbb0c122228df93e15104796b", "filename": "libgomp/testsuite/libgomp.fortran/udr6.f90", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr6.f90?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -8,17 +8,18 @@ module m\n     real :: r = 0.0\n   end type\n contains\n-  function do_add(x, y)\n+  elemental function do_add(x, y)\n     type (dt), intent (in) :: x, y\n     type (dt) :: do_add\n     do_add%r = x%r + y%r\n   end function\n-  subroutine dp_add(x, y)\n-    double precision :: x, y\n+  elemental subroutine dp_add(x, y)\n+    double precision, intent (inout) :: x\n+    double precision, intent (in) :: y\n     x = x + y\n   end subroutine\n-  subroutine dp_init(x)\n-    double precision :: x\n+  elemental subroutine dp_init(x)\n+    double precision, intent (out) :: x\n     x = 0.0\n   end subroutine\n end module"}, {"sha": "42be00c3a16332fa66c5996195e5d6a87f856df3", "filename": "libgomp/testsuite/libgomp.fortran/udr7.f90", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46ebd6c7beaf55974973de0f02d39299b733bc9/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr7.f90?ref=b46ebd6c7beaf55974973de0f02d39299b733bc9", "patch": "@@ -3,17 +3,17 @@\n program udr7\n   implicit none\n   interface\n-    subroutine omp_priv (x, y, z)\n+    elemental subroutine omp_priv (x, y, z)\n       real, intent (in) :: x\n       real, intent (inout) :: y\n-      real, intent (in) :: z(:)\n+      real, intent (in) :: z\n     end subroutine omp_priv\n-    real function omp_orig (x)\n+    elemental real function omp_orig (x)\n       real, intent (in) :: x\n     end function omp_orig\n   end interface\n !$omp declare reduction (omp_priv : real : &\n-!$omp & omp_priv (omp_orig (omp_in), omp_out, (/ 1.0, 2.0, 3.0 /))) &\n+!$omp & omp_priv (omp_orig (omp_in), omp_out, 1.0)) &\n !$omp & initializer (omp_out (omp_priv, omp_in (omp_orig)))\n   real :: x (2:4, 1:1, -2:0)\n   integer :: i\n@@ -24,25 +24,23 @@ end function omp_orig\n   end do\n   if (any (x /= 2080.0)) call abort\n contains\n-  subroutine omp_out (x, y)\n+  elemental subroutine omp_out (x, y)\n     real, intent (out) :: x\n     real, intent (in) :: y\n-    if (y /= 4.0) call abort\n-    x = 0.0\n+    x = y - 4.0\n   end subroutine omp_out\n-  real function omp_in (x)\n+  elemental real function omp_in (x)\n     real, intent (in) :: x\n     omp_in = x + 4.0\n   end function omp_in\n end program udr7\n-subroutine omp_priv (x, y, z)\n+elemental subroutine omp_priv (x, y, z)\n   real, intent (in) :: x\n   real, intent (inout) :: y\n-  real, intent (in) :: z(:)\n-  if (any (z .ne. (/ 1.0, 2.0, 3.0 /))) call abort\n-  y = y + (x - 4.0)\n+  real, intent (in) :: z\n+  y = y + (x - 4.0) + (z - 1.0)\n end subroutine omp_priv\n-real function omp_orig (x)\n+elemental real function omp_orig (x)\n   real, intent (in) :: x\n   omp_orig = x + 4.0\n end function omp_orig"}]}