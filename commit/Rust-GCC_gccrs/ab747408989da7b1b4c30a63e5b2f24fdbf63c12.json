{"sha": "ab747408989da7b1b4c30a63e5b2f24fdbf63c12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI3NDc0MDg5ODlkYTdiMWI0YzMwYTYzZTViMmYyNGZkYmY2M2MxMg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2003-07-08T20:42:19Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-07-08T20:42:19Z"}, "message": "Makefile.in (fixinc.sh): Remove gnu-regex.[ch] from dependencies.\n\n\t* Makefile.in (fixinc.sh): Remove gnu-regex.[ch] from dependencies.\n\t* fixinc/Makefile.in: Remove all references to gnu-regex.[och].\n\t* fixinc/fixfixes.c, fixinc/fixincl.c, fixinc/fixlib.c\n\t* fixinc/fixtests.c: Use xregexec not regexec, xregcomp not regcomp.\n\t* fixinc/fixlib.h: Include xregex.h not gnu-regex.h.\n\t* fixinc/inclhack.def (hpux10_cpp_pow_inline, hpux11_cpp_pow_inline):\n\tEscape { and } characters which are not part of range expressions.\n\t* fixinc/fixincl.x: Regenerate.\n\nFrom-SVN: r69099", "tree": {"sha": "dde90177f55808dcd653cf0c7bb274ebfc6d3c81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dde90177f55808dcd653cf0c7bb274ebfc6d3c81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab747408989da7b1b4c30a63e5b2f24fdbf63c12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab747408989da7b1b4c30a63e5b2f24fdbf63c12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab747408989da7b1b4c30a63e5b2f24fdbf63c12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/comments", "author": null, "committer": null, "parents": [{"sha": "c094e9b948934171a90b20a0551558f5b92ddadf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c094e9b948934171a90b20a0551558f5b92ddadf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c094e9b948934171a90b20a0551558f5b92ddadf"}], "stats": {"total": 6419, "additions": 46, "deletions": 6373}, "files": [{"sha": "0218ff5a009074425b19504af4a2c4a101b66701", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab747408989da7b1b4c30a63e5b2f24fdbf63c12", "patch": "@@ -1,3 +1,14 @@\n+2003-07-08  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* Makefile.in (fixinc.sh): Remove gnu-regex.[ch] from dependencies.\n+\t* fixinc/Makefile.in: Remove all references to gnu-regex.[och].\n+\t* fixinc/fixfixes.c, fixinc/fixincl.c, fixinc/fixlib.c\n+\t* fixinc/fixtests.c: Use xregexec not regexec, xregcomp not regcomp.\n+\t* fixinc/fixlib.h: Include xregex.h not gnu-regex.h.\n+\t* fixinc/inclhack.def (hpux10_cpp_pow_inline, hpux11_cpp_pow_inline):\n+\tEscape { and } characters which are not part of range expressions.\n+\t* fixinc/fixincl.x: Regenerate.\n+\n 2003-07-08  Steven Bosscher  <steven@gcc.gnu.org>\n \n \tPR c/1687"}, {"sha": "24ac3af46966588d94328a937b1132bd613a3152", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ab747408989da7b1b4c30a63e5b2f24fdbf63c12", "patch": "@@ -2507,8 +2507,7 @@ fixinc.sh-warn = -Wno-error\n \n FIXINCSRCDIR=$(srcdir)/fixinc\n fixinc.sh: $(FIXINCSRCDIR)/mkfixinc.sh $(FIXINCSRCDIR)/fixincl.c \\\n-\t$(FIXINCSRCDIR)/procopen.c $(FIXINCSRCDIR)/gnu-regex.c \\\n-\t$(FIXINCSRCDIR)/server.c $(FIXINCSRCDIR)/gnu-regex.h \\\n+\t$(FIXINCSRCDIR)/procopen.c $(FIXINCSRCDIR)/server.c \\\n \t$(FIXINCSRCDIR)/server.h $(FIXINCSRCDIR)/inclhack.def specs.ready\n \t(MAKE=\"$(MAKE)\"; srcdir=`cd $(srcdir)/fixinc && ${PWD_COMMAND}` ; \\\n \tCC=\"$(CC_FOR_BUILD)\"; CFLAGS=\"$(BUILD_CFLAGS)\"; LDFLAGS=\"$(BUILD_LDFLAGS)\"; \\"}, {"sha": "1329e8f09d726421270a984aa633e8699e8eae34", "filename": "gcc/fixinc/Makefile.in", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2Ffixinc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2Ffixinc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2FMakefile.in?ref=ab747408989da7b1b4c30a63e5b2f24fdbf63c12", "patch": "@@ -68,12 +68,12 @@ INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. \\\n LIBERTY = ../../libiberty/libiberty.a\n \n ALLOBJ = fixincl.o fixtests.o fixfixes.o server.o procopen.o \\\n-      gnu-regex.o fixlib.o\n+      fixlib.o\n \n-TESTOBJ = fixincl.o fixlib.o fixtests.o gnu-regex.o\n-FIXOBJ  = fixfixes.o fixlib.o gnu-regex.o\n+TESTOBJ = fixincl.o fixlib.o fixtests.o\n+FIXOBJ  = fixfixes.o fixlib.o\n \n-HDR = server.h gnu-regex.h fixlib.h machname.h\n+HDR = server.h fixlib.h machname.h\n FI  = fixincl@build_exeext@\n AF  = applyfix@build_exeext@\n \n@@ -96,16 +96,13 @@ $(AF): $(FIXOBJ) $(LIBERTY)\n \n # String length warnings\n fixincl.o-warn = -Wno-error\n-# Signed/Unsigned warnings, but in code pulled from upstream.\n-gnu-regex.o-warn = -Wno-error\n \n $(ALLOBJ)   : $(HDR)\n fixincl.o   : fixincl.c  $(srcdir)/fixincl.x\n fixtests.o  : fixtests.c\n fixfixes.o  : fixfixes.c $(srcdir)/fixincl.x\n server.o    : server.c\n procopen.o  : procopen.c\n-gnu-regex.o : gnu-regex.c\n fixlib.o    : fixlib.c\n \n #  'machname.h' is built in the build directory."}, {"sha": "b3c75ae1c1e20ee7e5c099a35541567d89097dff", "filename": "gcc/fixinc/fixfixes.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2Ffixinc%2Ffixfixes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2Ffixinc%2Ffixfixes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixfixes.c?ref=ab747408989da7b1b4c30a63e5b2f24fdbf63c12", "patch": "@@ -291,7 +291,7 @@ FIX_PROC_HEAD( format_fix )\n    *  Replace every copy of the text we find\n    */\n   compile_re (pz_pat, &re, 1, \"format search-text\", \"format_fix\" );\n-  while (regexec (&re, text, 10, rm, 0) == 0)\n+  while (xregexec (&re, text, 10, rm, 0) == 0)\n     {\n       fwrite( text, rm[0].rm_so, 1, stdout );\n       format_write( pz_fmt, text, rm );\n@@ -341,7 +341,7 @@ FIX_PROC_HEAD( char_macro_use_fix )\n   compile_re (pat, &re, 1, \"macro pattern\", \"char_macro_use_fix\");\n \n   for (p = text;\n-       regexec (&re, p, 1, rm, 0) == 0;\n+       xregexec (&re, p, 1, rm, 0) == 0;\n        p = limit + 1)\n     {\n       /* p + rm[0].rm_eo is the first character of the macro replacement.\n@@ -426,7 +426,7 @@ FIX_PROC_HEAD( char_macro_def_fix )\n   compile_re (pat, &re, 1, \"macro pattern\", \"fix_char_macro_defines\");\n \n   for (p = text;\n-       regexec (&re, p, 1, rm, 0) == 0;\n+       xregexec (&re, p, 1, rm, 0) == 0;\n        p = limit + 1)\n     {\n       /* p + rm[0].rm_eo is the first character of the macro name.\n@@ -516,7 +516,7 @@ FIX_PROC_HEAD( machine_name_fix )\n   scratch[1] = '_';\n \n   for (base = text;\n-       regexec (label_re, base, 2, match, 0) == 0;\n+       xregexec (label_re, base, 2, match, 0) == 0;\n        base = limit)\n     {\n       base += match[0].rm_eo;\n@@ -547,7 +547,7 @@ FIX_PROC_HEAD( machine_name_fix )\n           if (base == limit)\n             break;\n \n-          if (regexec (name_re, base, 1, match, REG_NOTBOL))\n+          if (xregexec (name_re, base, 1, match, REG_NOTBOL))\n             goto done;  /* No remaining match in this file */\n \n           /* Match; is it on the line?  */\n@@ -608,7 +608,7 @@ FIX_PROC_HEAD( wrap_fix )\n    *  IF we do *not* match the no-wrap re, then we have a double negative.\n    *  A double negative means YES.\n    */\n-  if (regexec( &no_wrapping_re, text, 0, NULL, 0 ) != 0)\n+  if (xregexec( &no_wrapping_re, text, 0, NULL, 0 ) != 0)\n     {\n       /*\n        *  A single file can get wrapped more than once by different fixes.\n@@ -690,7 +690,7 @@ FIX_PROC_HEAD( gnu_type_fix )\n \n   compile_re (pz_pat, &re, 1, \"gnu type typedef\", \"gnu_type_fix\");\n \n-  while (regexec (&re, text, GTYPE_SE_CT+1, rm, 0) == 0)\n+  while (xregexec (&re, text, GTYPE_SE_CT+1, rm, 0) == 0)\n     {\n       text = emit_gnu_type (text, rm);\n     }"}, {"sha": "18a32fcfbecce09db566a1ca85bd6ca01644d18e", "filename": "gcc/fixinc/fixincl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2Ffixinc%2Ffixincl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2Ffixinc%2Ffixincl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.c?ref=ab747408989da7b1b4c30a63e5b2f24fdbf63c12", "patch": "@@ -693,7 +693,7 @@ egrep_test (pz_data, p_test)\n     fprintf (stderr, \"fixincl ERROR RE not compiled:  `%s'\\n\",\n              p_test->pz_test_text);\n #endif\n-  if (regexec (p_test->p_test_regex, pz_data, 0, 0, 0) == 0)\n+  if (xregexec (p_test->p_test_regex, pz_data, 0, 0, 0) == 0)\n     return APPLY_FIX;\n   return SKIP_FIX;\n }\n@@ -808,7 +808,7 @@ extract_quoted_files (pz_data, pz_fixed_file, p_re_match)\n         }\n \n       /* Find the next entry */\n-      if (regexec (&incl_quote_re, pz_incl_quot, 1, p_re_match, 0) != 0)\n+      if (xregexec (&incl_quote_re, pz_incl_quot, 1, p_re_match, 0) != 0)\n         break;\n     }\n }\n@@ -1315,7 +1315,7 @@ test_for_changes (read_fd)\n       /* Close the file and see if we have to worry about\n          `#include \"file.h\"' constructs.  */\n       fclose (out_fp);\n-      if (regexec (&incl_quote_re, pz_curr_data, 1, &match, 0) == 0)\n+      if (xregexec (&incl_quote_re, pz_curr_data, 1, &match, 0) == 0)\n         extract_quoted_files (pz_curr_data, pz_curr_file, &match);\n     }\n "}, {"sha": "b1a426d468ed5373bf68d0eaeb212028fd12f8f5", "filename": "gcc/fixinc/fixincl.x", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2Ffixinc%2Ffixincl.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2Ffixinc%2Ffixincl.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.x?ref=ab747408989da7b1b4c30a63e5b2f24fdbf63c12", "patch": "@@ -2,11 +2,11 @@\n  * \n  * DO NOT EDIT THIS FILE   (fixincl.x)\n  * \n- * It has been AutoGen-ed  Wednesday July  2, 2003 at 03:26:19 AM MEST\n+ * It has been AutoGen-ed  Tuesday July  8, 2003 at 01:41:54 PM PDT\n  * From the definitions    inclhack.def\n  * and the template file   fixincl\n  */\n-/* DO NOT CVS-MERGE THIS FILE, EITHER Wed Jul  2 03:26:20 MEST 2003\n+/* DO NOT CVS-MERGE THIS FILE, EITHER Tue Jul  8 13:41:54 PDT 2003\n  *\n  * You must regenerate it.  Use the ./genfixes script.\n  *\n@@ -1697,11 +1697,11 @@ tSCC zHpux10_Cpp_Pow_InlineList[] =\n  */\n tSCC zHpux10_Cpp_Pow_InlineSelect0[] =\n        \"^# +ifdef +__cplusplus\\n\\\n- +}\\n\\\n- +inline +double +pow\\\\(double +__d,int +__expon\\\\) +{\\n\\\n+ +\\\\}\\n\\\n+ +inline +double +pow\\\\(double +__d,int +__expon\\\\) +\\\\{\\n\\\n [ \\t]+return +pow\\\\(__d,\\\\(double\\\\)__expon\\\\);\\n\\\n- +}\\n\\\n- +extern +\\\"C\\\" +{\\n\\\n+ +\\\\}\\n\\\n+ +extern +\\\"C\\\" +\\\\{\\n\\\n #else\\n\\\n # +endif\";\n \n@@ -1738,9 +1738,9 @@ tSCC zHpux11_Cpp_Pow_InlineList[] =\n  *  content selection pattern - do fix if pattern found\n  */\n tSCC zHpux11_Cpp_Pow_InlineSelect0[] =\n-       \" +inline double pow\\\\(double d,int expon\\\\) {\\n\\\n+       \" +inline double pow\\\\(double d,int expon\\\\) \\\\{\\n\\\n  +return pow\\\\(d, \\\\(double\\\\)expon\\\\);\\n\\\n- +}\\n\";\n+ +\\\\}\\n\";\n \n #define    HPUX11_CPP_POW_INLINE_TEST_CT  1\n static tTestDesc aHpux11_Cpp_Pow_InlineTests[] = {"}, {"sha": "49edda776d176b0648de98a8341a87bf21b234f1", "filename": "gcc/fixinc/fixlib.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2Ffixinc%2Ffixlib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2Ffixinc%2Ffixlib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixlib.c?ref=ab747408989da7b1b4c30a63e5b2f24fdbf63c12", "patch": "@@ -131,7 +131,7 @@ template[ \\t]*<|\\\n       if (!compiled)\n \tcompile_re (cxxpat, &cxxre, 0, \"contents check\", \"is_cxx_header\");\n \n-      if (regexec (&cxxre, text, 0, 0, 0) == 0)\n+      if (xregexec (&cxxre, text, 0, 0, 0) == 0)\n \treturn BOOL_TRUE;\n     }\n \t\t   \n@@ -181,7 +181,7 @@ skip_quote( q, text )\n    Compile one regular expression pattern for later use.  PAT contains\n    the pattern, RE points to a regex_t structure (which should have\n    been bzeroed).  MATCH is 1 if we need to know where the regex\n-   matched, 0 if not. If regcomp fails, prints an error message and\n+   matched, 0 if not. If xregcomp fails, prints an error message and\n    aborts; E1 and E2 are strings to shove into the error message.\n \n    The patterns we search for are all egrep patterns.\n@@ -201,7 +201,7 @@ compile_re( pat, re, match, e1, e2 )\n \n   flags = (match ? REG_EXTENDED|REG_NEWLINE\n \t   : REG_EXTENDED|REG_NEWLINE|REG_NOSUB);\n-  err = regcomp (re, pat, flags);\n+  err = xregcomp (re, pat, flags);\n \n   if (err)\n     {"}, {"sha": "6287a2b8e560c1dae9ffcbb4f8bbc777359c53f8", "filename": "gcc/fixinc/fixlib.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2Ffixinc%2Ffixlib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2Ffixinc%2Ffixlib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixlib.h?ref=ab747408989da7b1b4c30a63e5b2f24fdbf63c12", "patch": "@@ -32,7 +32,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tm.h\"\n #include <signal.h>\n \n-#include \"gnu-regex.h\"\n+#include \"xregex.h\"\n #include \"machname.h\"\n #include \"libiberty.h\"\n "}, {"sha": "92bc10cc9d3e6a4f59ca71805f9d93d8a71e4e45", "filename": "gcc/fixinc/fixtests.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2Ffixinc%2Ffixtests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2Ffixinc%2Ffixtests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixtests.c?ref=ab747408989da7b1b4c30a63e5b2f24fdbf63c12", "patch": "@@ -82,7 +82,7 @@ TEST_FOR_FIX_PROC_HEAD( machine_name_test )\n   mn_get_regexps(&label_re, &name_re, \"machine_name_test\");\n \n   for (base = text;\n-       regexec (label_re, base, 2, match, 0) == 0;\n+       xregexec (label_re, base, 2, match, 0) == 0;\n        base = limit)\n     {\n       base += match[0].rm_eo;\n@@ -107,7 +107,7 @@ TEST_FOR_FIX_PROC_HEAD( machine_name_test )\n \t shouldn't matter since the name_re has no ^ anchor, but let's\n \t be accurate anyway.  */\n \n-      if (regexec (name_re, base, 1, match, REG_NOTBOL))\n+      if (xregexec (name_re, base, 1, match, REG_NOTBOL))\n \treturn SKIP_FIX;  /* No match in file - no fix needed */\n \n       /* Match; is it on the line?  */"}, {"sha": "3863a993a06d59805b61270485cc4cb8cec5422c", "filename": "gcc/fixinc/gnu-regex.c", "status": "removed", "additions": 0, "deletions": 5762, "changes": 5762, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c094e9b948934171a90b20a0551558f5b92ddadf/gcc%2Ffixinc%2Fgnu-regex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c094e9b948934171a90b20a0551558f5b92ddadf/gcc%2Ffixinc%2Fgnu-regex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fgnu-regex.c?ref=c094e9b948934171a90b20a0551558f5b92ddadf"}, {"sha": "392abf5f9a976f54ae4ae970bba46bd8e173c8ee", "filename": "gcc/fixinc/gnu-regex.h", "status": "removed", "additions": 0, "deletions": 572, "changes": 572, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c094e9b948934171a90b20a0551558f5b92ddadf/gcc%2Ffixinc%2Fgnu-regex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c094e9b948934171a90b20a0551558f5b92ddadf/gcc%2Ffixinc%2Fgnu-regex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fgnu-regex.h?ref=c094e9b948934171a90b20a0551558f5b92ddadf", "patch": "@@ -1,572 +0,0 @@\n-/* Definitions for data structures and routines for the regular\n-   expression library, version 0.12.\n-   Copyright (C) 1985, 1989, 1990, 1991, 1992, 1993, 1995, 1996, 1997, 1998\n-   Free Software Foundation, Inc.\n-\n-   NOTE: The canonical source of this file is maintained with the \n-   GNU C Library.  Bugs can be reported to bug-glibc@prep.ai.mit.edu.\n-\n-   This program is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by the\n-   Free Software Foundation; either version 2, or (at your option) any\n-   later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program; if not, write to the Free Software Foundation, \n-   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n-\n-#ifndef _REGEX_H\n-#define _REGEX_H 1\n-\n-/* Allow the use in C++ code.  */\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-/* POSIX says that <sys/types.h> must be included (by the caller) before\n-   <regex.h>.  */\n-\n-#if !defined _POSIX_C_SOURCE && !defined _POSIX_SOURCE && defined VMS\n-/* VMS doesn't have `size_t' in <sys/types.h>, even though POSIX says it\n-   should be there.  */\n-# include <stddef.h>\n-#endif\n-\n-/* The following two types have to be signed and unsigned integer type\n-   wide enough to hold a value of a pointer.  For most ANSI compilers\n-   ptrdiff_t and size_t should be likely OK.  Still size of these two\n-   types is 2 for Microsoft C.  Ugh... */\n-typedef long int s_reg_t;\n-typedef unsigned long int active_reg_t;\n-\n-/* The following bits are used to determine the regexp syntax we\n-   recognize.  The set/not-set meanings are chosen so that Emacs syntax\n-   remains the value 0.  The bits are given in alphabetical order, and\n-   the definitions shifted by one from the previous bit; thus, when we\n-   add or remove a bit, only one other definition need change.  */\n-typedef unsigned long int reg_syntax_t;\n-\n-/* If this bit is not set, then \\ inside a bracket expression is literal.\n-   If set, then such a \\ quotes the following character.  */\n-#define RE_BACKSLASH_ESCAPE_IN_LISTS ((unsigned long int) 1)\n-\n-/* If this bit is not set, then + and ? are operators, and \\+ and \\? are\n-     literals.\n-   If set, then \\+ and \\? are operators and + and ? are literals.  */\n-#define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS << 1)\n-\n-/* If this bit is set, then character classes are supported.  They are:\n-     [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],\n-     [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].\n-   If not set, then character classes are not supported.  */\n-#define RE_CHAR_CLASSES (RE_BK_PLUS_QM << 1)\n-\n-/* If this bit is set, then ^ and $ are always anchors (outside bracket\n-     expressions, of course).\n-   If this bit is not set, then it depends:\n-        ^  is an anchor if it is at the beginning of a regular\n-           expression or after an open-group or an alternation operator;\n-        $  is an anchor if it is at the end of a regular expression, or\n-           before a close-group or an alternation operator.\n-\n-   This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because\n-   POSIX draft 11.2 says that * etc. in leading positions is undefined.\n-   We already implemented a previous draft which made those constructs\n-   invalid, though, so we haven't changed the code back.  */\n-#define RE_CONTEXT_INDEP_ANCHORS (RE_CHAR_CLASSES << 1)\n-\n-/* If this bit is set, then special characters are always special\n-     regardless of where they are in the pattern.\n-   If this bit is not set, then special characters are special only in\n-     some contexts; otherwise they are ordinary.  Specifically,\n-     * + ? and intervals are only special when not after the beginning,\n-     open-group, or alternation operator.  */\n-#define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS << 1)\n-\n-/* If this bit is set, then *, +, ?, and { cannot be first in an re or\n-     immediately after an alternation or begin-group operator.  */\n-#define RE_CONTEXT_INVALID_OPS (RE_CONTEXT_INDEP_OPS << 1)\n-\n-/* If this bit is set, then . matches newline.\n-   If not set, then it doesn't.  */\n-#define RE_DOT_NEWLINE (RE_CONTEXT_INVALID_OPS << 1)\n-\n-/* If this bit is set, then . doesn't match NUL.\n-   If not set, then it does.  */\n-#define RE_DOT_NOT_NULL (RE_DOT_NEWLINE << 1)\n-\n-/* If this bit is set, nonmatching lists [^...] do not match newline.\n-   If not set, they do.  */\n-#define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL << 1)\n-\n-/* If this bit is set, either \\{...\\} or {...} defines an\n-     interval, depending on RE_NO_BK_BRACES.\n-   If not set, \\{, \\}, {, and } are literals.  */\n-#define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE << 1)\n-\n-/* If this bit is set, +, ? and | aren't recognized as operators.\n-   If not set, they are.  */\n-#define RE_LIMITED_OPS (RE_INTERVALS << 1)\n-\n-/* If this bit is set, newline is an alternation operator.\n-   If not set, newline is literal.  */\n-#define RE_NEWLINE_ALT (RE_LIMITED_OPS << 1)\n-\n-/* If this bit is set, then `{...}' defines an interval, and \\{ and \\}\n-     are literals.\n-  If not set, then `\\{...\\}' defines an interval.  */\n-#define RE_NO_BK_BRACES (RE_NEWLINE_ALT << 1)\n-\n-/* If this bit is set, (...) defines a group, and \\( and \\) are literals.\n-   If not set, \\(...\\) defines a group, and ( and ) are literals.  */\n-#define RE_NO_BK_PARENS (RE_NO_BK_BRACES << 1)\n-\n-/* If this bit is set, then \\<digit> matches <digit>.\n-   If not set, then \\<digit> is a back-reference.  */\n-#define RE_NO_BK_REFS (RE_NO_BK_PARENS << 1)\n-\n-/* If this bit is set, then | is an alternation operator, and \\| is literal.\n-   If not set, then \\| is an alternation operator, and | is literal.  */\n-#define RE_NO_BK_VBAR (RE_NO_BK_REFS << 1)\n-\n-/* If this bit is set, then an ending range point collating higher\n-     than the starting range point, as in [z-a], is invalid.\n-   If not set, then when ending range point collates higher than the\n-     starting range point, the range is ignored.  */\n-#define RE_NO_EMPTY_RANGES (RE_NO_BK_VBAR << 1)\n-\n-/* If this bit is set, then an unmatched ) is ordinary.\n-   If not set, then an unmatched ) is invalid.  */\n-#define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES << 1)\n-\n-/* If this bit is set, succeed as soon as we match the whole pattern,\n-   without further backtracking.  */\n-#define RE_NO_POSIX_BACKTRACKING (RE_UNMATCHED_RIGHT_PAREN_ORD << 1)\n-\n-/* If this bit is set, do not process the GNU regex operators.\n-   If not set, then the GNU regex operators are recognized. */\n-#define RE_NO_GNU_OPS (RE_NO_POSIX_BACKTRACKING << 1)\n-\n-/* If this bit is set, turn on internal regex debugging.\n-   If not set, and debugging was on, turn it off.\n-   This only works if regex.c is compiled -DDEBUG.\n-   We define this bit always, so that all that's needed to turn on\n-   debugging is to recompile regex.c; the calling code can always have\n-   this bit set, and it won't affect anything in the normal case. */\n-#define RE_DEBUG (RE_NO_GNU_OPS << 1)\n-\n-/* This global variable defines the particular regexp syntax to use (for\n-   some interfaces).  When a regexp is compiled, the syntax used is\n-   stored in the pattern buffer, so changing this does not affect\n-   already-compiled regexps.  */\n-extern reg_syntax_t re_syntax_options;\n-\f\n-/* Define combinations of the above bits for the standard possibilities.\n-   (The [[[ comments delimit what gets put into the Texinfo file, so\n-   don't delete them!)  */\n-/* [[[begin syntaxes]]] */\n-#define RE_SYNTAX_EMACS 0\n-\n-#define RE_SYNTAX_AWK\t\t\t\t\t\t\t\\\n-  (RE_BACKSLASH_ESCAPE_IN_LISTS   | RE_DOT_NOT_NULL\t\t\t\\\n-   | RE_NO_BK_PARENS              | RE_NO_BK_REFS\t\t\t\\\n-   | RE_NO_BK_VBAR                | RE_NO_EMPTY_RANGES\t\t\t\\\n-   | RE_DOT_NEWLINE\t\t  | RE_CONTEXT_INDEP_ANCHORS\t\t\\\n-   | RE_UNMATCHED_RIGHT_PAREN_ORD | RE_NO_GNU_OPS)\n-\n-#define RE_SYNTAX_GNU_AWK\t\t\t\t\t\t\\\n-  ((RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DEBUG)\t\\\n-   & ~(RE_DOT_NOT_NULL | RE_INTERVALS | RE_CONTEXT_INDEP_OPS))\n-\n-#define RE_SYNTAX_POSIX_AWK \t\t\t\t\t\t\\\n-  (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS\t\t\\\n-   | RE_INTERVALS\t    | RE_NO_GNU_OPS)\n-\n-#define RE_SYNTAX_GREP\t\t\t\t\t\t\t\\\n-  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES\t\t\t\t\\\n-   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS\t\t\t\t\\\n-   | RE_NEWLINE_ALT)\n-\n-#define RE_SYNTAX_EGREP\t\t\t\t\t\t\t\\\n-  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS\t\t\t\\\n-   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE\t\t\t\\\n-   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS\t\t\t\t\\\n-   | RE_NO_BK_VBAR)\n-\n-#define RE_SYNTAX_POSIX_EGREP\t\t\t\t\t\t\\\n-  (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES)\n-\n-/* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */\n-#define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC\n-\n-#define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC\n-\n-/* Syntax bits common to both basic and extended POSIX regex syntax.  */\n-#define _RE_SYNTAX_POSIX_COMMON\t\t\t\t\t\t\\\n-  (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL\t\t\\\n-   | RE_INTERVALS  | RE_NO_EMPTY_RANGES)\n-\n-#define RE_SYNTAX_POSIX_BASIC\t\t\t\t\t\t\\\n-  (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM)\n-\n-/* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes\n-   RE_LIMITED_OPS, i.e., \\? \\+ \\| are not recognized.  Actually, this\n-   isn't minimal, since other operators, such as \\`, aren't disabled.  */\n-#define RE_SYNTAX_POSIX_MINIMAL_BASIC\t\t\t\t\t\\\n-  (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)\n-\n-#define RE_SYNTAX_POSIX_EXTENDED\t\t\t\t\t\\\n-  (_RE_SYNTAX_POSIX_COMMON | RE_CONTEXT_INDEP_ANCHORS\t\t\t\\\n-   | RE_CONTEXT_INDEP_OPS  | RE_NO_BK_BRACES\t\t\t\t\\\n-   | RE_NO_BK_PARENS       | RE_NO_BK_VBAR\t\t\t\t\\\n-   | RE_UNMATCHED_RIGHT_PAREN_ORD)\n-\n-/* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS\n-   replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added.  */\n-#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED\t\t\t\t\\\n-  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS\t\t\t\\\n-   | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES\t\t\t\t\\\n-   | RE_NO_BK_PARENS        | RE_NO_BK_REFS\t\t\t\t\\\n-   | RE_NO_BK_VBAR\t    | RE_UNMATCHED_RIGHT_PAREN_ORD)\n-/* [[[end syntaxes]]] */\n-\f\n-/* Maximum number of duplicates an interval can allow.  Some systems\n-   (erroneously) define this in other header files, but we want our\n-   value, so remove any previous define.  */\n-#ifdef RE_DUP_MAX\n-# undef RE_DUP_MAX\n-#endif\n-/* If sizeof(int) == 2, then ((1 << 15) - 1) overflows.  */\n-#define RE_DUP_MAX (0x7fff)\n-\n-\n-/* POSIX `cflags' bits (i.e., information for `regcomp').  */\n-\n-/* If this bit is set, then use extended regular expression syntax.\n-   If not set, then use basic regular expression syntax.  */\n-#define REG_EXTENDED 1\n-\n-/* If this bit is set, then ignore case when matching.\n-   If not set, then case is significant.  */\n-#define REG_ICASE (REG_EXTENDED << 1)\n-\n-/* If this bit is set, then anchors do not match at newline\n-     characters in the string.\n-   If not set, then anchors do match at newlines.  */\n-#define REG_NEWLINE (REG_ICASE << 1)\n-\n-/* If this bit is set, then report only success or fail in regexec.\n-   If not set, then returns differ between not matching and errors.  */\n-#define REG_NOSUB (REG_NEWLINE << 1)\n-\n-\n-/* POSIX `eflags' bits (i.e., information for regexec).  */\n-\n-/* If this bit is set, then the beginning-of-line operator doesn't match\n-     the beginning of the string (presumably because it's not the\n-     beginning of a line).\n-   If not set, then the beginning-of-line operator does match the\n-     beginning of the string.  */\n-#define REG_NOTBOL 1\n-\n-/* Like REG_NOTBOL, except for the end-of-line.  */\n-#define REG_NOTEOL (1 << 1)\n-\n-\n-/* If any error codes are removed, changed, or added, update the\n-   `re_error_msg' table in regex.c.  */\n-typedef enum\n-{\n-#if (_XOPEN_SOURCE - 0) == 500\n-  REG_NOSYS = -1,\t/* This will never happen for this implementation.  */\n-#endif\n-\n-  REG_NOERROR = 0,\t/* Success.  */\n-  REG_NOMATCH,\t\t/* Didn't find a match (for regexec).  */\n-\n-  /* POSIX regcomp return error codes.  (In the order listed in the\n-     standard.)  */\n-  REG_BADPAT,\t\t/* Invalid pattern.  */\n-  REG_ECOLLATE,\t\t/* Not implemented.  */\n-  REG_ECTYPE,\t\t/* Invalid character class name.  */\n-  REG_EESCAPE,\t\t/* Trailing backslash.  */\n-  REG_ESUBREG,\t\t/* Invalid back reference.  */\n-  REG_EBRACK,\t\t/* Unmatched left bracket.  */\n-  REG_EPAREN,\t\t/* Parenthesis imbalance.  */\n-  REG_EBRACE,\t\t/* Unmatched \\{.  */\n-  REG_BADBR,\t\t/* Invalid contents of \\{\\}.  */\n-  REG_ERANGE,\t\t/* Invalid range end.  */\n-  REG_ESPACE,\t\t/* Ran out of memory.  */\n-  REG_BADRPT,\t\t/* No preceding re for repetition op.  */\n-\n-  /* Error codes we've added.  */\n-  REG_EEND,\t\t/* Premature end.  */\n-  REG_ESIZE,\t\t/* Compiled pattern bigger than 2^16 bytes.  */\n-  REG_ERPAREN\t\t/* Unmatched ) or \\); not returned from regcomp.  */\n-} reg_errcode_t;\n-\f\n-/* This data structure represents a compiled pattern.  Before calling\n-   the pattern compiler, the fields `buffer', `allocated', `fastmap',\n-   `translate', and `no_sub' can be set.  After the pattern has been\n-   compiled, the `re_nsub' field is available.  All other fields are\n-   private to the regex routines.  */\n-\n-#ifndef RE_TRANSLATE_TYPE\n-# define RE_TRANSLATE_TYPE char *\n-#endif\n-\n-struct re_pattern_buffer\n-{\n-/* [[[begin pattern_buffer]]] */\n-\t/* Space that holds the compiled pattern.  It is declared as\n-          `unsigned char *' because its elements are\n-           sometimes used as array indexes.  */\n-  unsigned char *buffer;\n-\n-\t/* Number of bytes to which `buffer' points.  */\n-  unsigned long int allocated;\n-\n-\t/* Number of bytes actually used in `buffer'.  */\n-  unsigned long int used;\n-\n-        /* Syntax setting with which the pattern was compiled.  */\n-  reg_syntax_t syntax;\n-\n-        /* Pointer to a fastmap, if any, otherwise zero.  re_search uses\n-           the fastmap, if there is one, to skip over impossible\n-           starting points for matches.  */\n-  char *fastmap;\n-\n-        /* Either a translate table to apply to all characters before\n-           comparing them, or zero for no translation.  The translation\n-           is applied to a pattern when it is compiled and to a string\n-           when it is matched.  */\n-  RE_TRANSLATE_TYPE translate;\n-\n-\t/* Number of subexpressions found by the compiler.  */\n-  size_t re_nsub;\n-\n-        /* Zero if this pattern cannot match the empty string, one else.\n-           Well, in truth it's used only in `re_search_2', to see\n-           whether or not we should use the fastmap, so we don't set\n-           this absolutely perfectly; see `re_compile_fastmap' (the\n-           `duplicate' case).  */\n-  unsigned can_be_null : 1;\n-\n-        /* If REGS_UNALLOCATED, allocate space in the `regs' structure\n-             for `max (RE_NREGS, re_nsub + 1)' groups.\n-           If REGS_REALLOCATE, reallocate space if necessary.\n-           If REGS_FIXED, use what's there.  */\n-#define REGS_UNALLOCATED 0\n-#define REGS_REALLOCATE 1\n-#define REGS_FIXED 2\n-  unsigned regs_allocated : 2;\n-\n-        /* Set to zero when `regex_compile' compiles a pattern; set to one\n-           by `re_compile_fastmap' if it updates the fastmap.  */\n-  unsigned fastmap_accurate : 1;\n-\n-        /* If set, `re_match_2' does not return information about\n-           subexpressions.  */\n-  unsigned no_sub : 1;\n-\n-        /* If set, a beginning-of-line anchor doesn't match at the\n-           beginning of the string.  */\n-  unsigned not_bol : 1;\n-\n-        /* Similarly for an end-of-line anchor.  */\n-  unsigned not_eol : 1;\n-\n-        /* If true, an anchor at a newline matches.  */\n-  unsigned newline_anchor : 1;\n-\n-/* [[[end pattern_buffer]]] */\n-};\n-\n-typedef struct re_pattern_buffer regex_t;\n-\f\n-/* Type for byte offsets within the string.  POSIX mandates this.  */\n-typedef int regoff_t;\n-\n-\n-/* This is the structure we store register match data in.  See\n-   regex.texinfo for a full description of what registers match.  */\n-struct re_registers\n-{\n-  unsigned num_regs;\n-  regoff_t *start;\n-  regoff_t *end;\n-};\n-\n-\n-/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,\n-   `re_match_2' returns information about at least this many registers\n-   the first time a `regs' structure is passed.  */\n-#ifndef RE_NREGS\n-# define RE_NREGS 30\n-#endif\n-\n-\n-/* POSIX specification for registers.  Aside from the different names than\n-   `re_registers', POSIX uses an array of structures, instead of a\n-   structure of arrays.  */\n-typedef struct\n-{\n-  regoff_t rm_so;  /* Byte offset from string's start to substring's start.  */\n-  regoff_t rm_eo;  /* Byte offset from string's start to substring's end.  */\n-} regmatch_t;\n-\f\n-/* Declarations for routines.  */\n-\n-/* To avoid duplicating every routine declaration -- once with a\n-   prototype (if we are ANSI), and once without (if we aren't) -- we\n-   use the following macro to declare argument types.  This\n-   unfortunately clutters up the declarations a bit, but I think it's\n-   worth it.  */\n-\n-#if __STDC__\n-\n-# define _RE_ARGS(args) args\n-\n-#else /* not __STDC__ */\n-\n-# define _RE_ARGS(args) ()\n-\n-#endif /* not __STDC__ */\n-\n-/* Sets the current default syntax to SYNTAX, and return the old syntax.\n-   You can also simply assign to the `re_syntax_options' variable.  */\n-extern reg_syntax_t __re_set_syntax _RE_ARGS ((reg_syntax_t syntax));\n-extern reg_syntax_t re_set_syntax _RE_ARGS ((reg_syntax_t syntax));\n-\n-/* Compile the regular expression PATTERN, with length LENGTH\n-   and syntax given by the global `re_syntax_options', into the buffer\n-   BUFFER.  Return NULL if successful, and an error string if not.  */\n-extern const char *__re_compile_pattern\n-  _RE_ARGS ((const char *pattern, size_t length,\n-             struct re_pattern_buffer *buffer));\n-extern const char *re_compile_pattern\n-  _RE_ARGS ((const char *pattern, size_t length,\n-             struct re_pattern_buffer *buffer));\n-\n-\n-/* Compile a fastmap for the compiled pattern in BUFFER; used to\n-   accelerate searches.  Return 0 if successful and -2 if was an\n-   internal error.  */\n-extern int __re_compile_fastmap _RE_ARGS ((struct re_pattern_buffer *buffer));\n-extern int re_compile_fastmap _RE_ARGS ((struct re_pattern_buffer *buffer));\n-\n-\n-/* Search in the string STRING (with length LENGTH) for the pattern\n-   compiled into BUFFER.  Start searching at position START, for RANGE\n-   characters.  Return the starting position of the match, -1 for no\n-   match, or -2 for an internal error.  Also return register\n-   information in REGS (if REGS and BUFFER->no_sub are nonzero).  */\n-extern int __re_search\n-  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,\n-            int length, int start, int range, struct re_registers *regs));\n-extern int re_search\n-  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,\n-            int length, int start, int range, struct re_registers *regs));\n-\n-\n-/* Like `re_search', but search in the concatenation of STRING1 and\n-   STRING2.  Also, stop searching at index START + STOP.  */\n-extern int __re_search_2\n-  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,\n-             int length1, const char *string2, int length2,\n-             int start, int range, struct re_registers *regs, int stop));\n-extern int re_search_2\n-  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,\n-             int length1, const char *string2, int length2,\n-             int start, int range, struct re_registers *regs, int stop));\n-\n-\n-/* Like `re_search', but return how many characters in STRING the regexp\n-   in BUFFER matched, starting at position START.  */\n-extern int __re_match\n-  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,\n-             int length, int start, struct re_registers *regs));\n-extern int re_match\n-  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,\n-             int length, int start, struct re_registers *regs));\n-\n-\n-/* Relates to `re_match' as `re_search_2' relates to `re_search'.  */\n-extern int __re_match_2\n-  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,\n-             int length1, const char *string2, int length2,\n-             int start, struct re_registers *regs, int stop));\n-extern int re_match_2\n-  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,\n-             int length1, const char *string2, int length2,\n-             int start, struct re_registers *regs, int stop));\n-\n-\n-/* Set REGS to hold NUM_REGS registers, storing them in STARTS and\n-   ENDS.  Subsequent matches using BUFFER and REGS will use this memory\n-   for recording register information.  STARTS and ENDS must be\n-   allocated with malloc, and must each be at least `NUM_REGS * sizeof\n-   (regoff_t)' bytes long.\n-\n-   If NUM_REGS == 0, then subsequent matches should allocate their own\n-   register data.\n-\n-   Unless this function is called, the first search or match using\n-   PATTERN_BUFFER will allocate its own register data, without\n-   freeing the old data.  */\n-extern void __re_set_registers\n-  _RE_ARGS ((struct re_pattern_buffer *buffer, struct re_registers *regs,\n-             unsigned num_regs, regoff_t *starts, regoff_t *ends));\n-extern void re_set_registers\n-  _RE_ARGS ((struct re_pattern_buffer *buffer, struct re_registers *regs,\n-             unsigned num_regs, regoff_t *starts, regoff_t *ends));\n-\n-#ifdef _REGEX_RE_COMP\n-# ifndef _CRAY\n-/* 4.2 bsd compatibility.  */\n-extern char *re_comp _RE_ARGS ((const char *));\n-extern int re_exec _RE_ARGS ((const char *));\n-# endif\n-#endif\n-\n-/* POSIX compatibility.  */\n-extern int __regcomp _RE_ARGS ((regex_t *__preg, const char *__pattern,\n-\t\t\t\tint __cflags));\n-extern int regcomp _RE_ARGS ((regex_t *__preg, const char *__pattern,\n-\t\t\t      int __cflags));\n-\n-extern int __regexec _RE_ARGS ((const regex_t *__preg,\n-\t\t\t\tconst char *__string, size_t __nmatch,\n-\t\t\t\tregmatch_t __pmatch[], int __eflags));\n-extern int regexec _RE_ARGS ((const regex_t *__preg,\n-\t\t\t      const char *__string, size_t __nmatch,\n-\t\t\t      regmatch_t __pmatch[], int __eflags));\n-\n-extern size_t __regerror _RE_ARGS ((int __errcode, const regex_t *__preg,\n-\t\t\t\t    char *__errbuf, size_t __errbuf_size));\n-extern size_t regerror _RE_ARGS ((int __errcode, const regex_t *__preg,\n-\t\t\t\t  char *__errbuf, size_t __errbuf_size));\n-\n-extern void __regfree _RE_ARGS ((regex_t *__preg));\n-extern void regfree _RE_ARGS ((regex_t *__preg));\n-\n-\n-#ifdef __cplusplus\n-}\n-#endif\t/* C++ */\n-\n-#endif /* regex.h */\n-\f\n-/*\n-Local variables:\n-make-backup-files: t\n-version-control: t\n-trim-versions-without-asking: nil\n-End:\n-*/"}, {"sha": "f77c5411d1422a986c789ebb304d39bfaaba778d", "filename": "gcc/fixinc/inclhack.def", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2Ffixinc%2Finclhack.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab747408989da7b1b4c30a63e5b2f24fdbf63c12/gcc%2Ffixinc%2Finclhack.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Finclhack.def?ref=ab747408989da7b1b4c30a63e5b2f24fdbf63c12", "patch": "@@ -1003,11 +1003,11 @@ fix = {\n     files     = fixinc-test-limits.h, math.h;\n     select    = <<-\tEND_POW_INLINE\n \t^# +ifdef +__cplusplus\n-\t +}\n-\t +inline +double +pow\\(double +__d,int +__expon\\) +{\n+\t +\\}\n+\t +inline +double +pow\\(double +__d,int +__expon\\) +\\{\n \t[ \t]+return +pow\\(__d,\\(double\\)__expon\\);\n-\t +}\n-\t +extern +\"C\" +{\n+\t +\\}\n+\t +extern +\"C\" +\\{\n \t#else\n \t# +endif\n \tEND_POW_INLINE;\n@@ -1029,9 +1029,9 @@ fix = {\n fix = {\n      hackname  = hpux11_cpp_pow_inline;\n      files     = math.h;\n-     select    = \" +inline double pow\\\\(double d,int expon\\\\) {\\n\"\n+     select    = \" +inline double pow\\\\(double d,int expon\\\\) \\\\{\\n\"\n                  \" +return pow\\\\(d, \\\\(double\\\\)expon\\\\);\\n\"\n-                 \" +}\\n\";\n+                 \" +\\\\}\\n\";\n      c_fix     = format;\n      c_fix_arg = \"\";\n "}]}