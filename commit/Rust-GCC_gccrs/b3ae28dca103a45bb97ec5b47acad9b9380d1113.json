{"sha": "b3ae28dca103a45bb97ec5b47acad9b9380d1113", "node_id": "C_kwDOANBUbNoAKGIzYWUyOGRjYTEwM2E0NWJiOTdlYzViNDdhY2FkOWI5MzgwZDExMTM", "commit": {"author": {"name": "Claire Dross", "email": "dross@adacore.com", "date": "2022-07-07T14:04:24Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-09-02T07:34:06Z"}, "message": "[Ada] Fix proof of runtime unit System.Value* and System.Image*\n\nRefactor specification of the Value* and Image* units and fix proofs.\n\ngcc/ada/\n\n\t* libgnat/a-nbnbig.ads: Add Always_Return annotation.\n\t* libgnat/s-vaispe.ads: New ghost unit for the specification of\n\tSystem.Value_I. Restore proofs.\n\t* libgnat/s-vauspe.ads: New ghost unit for the specification of\n\tSystem.Value_U. Restore proofs.\n\t* libgnat/s-valuei.adb: The specification only subprograms are\n\tmoved to System.Value_I_Spec. Restore proofs.\n\t* libgnat/s-valueu.adb: The specification only subprograms are\n\tmoved to System.Value_U_Spec. Restore proofs.\n\t* libgnat/s-valuti.ads\n\t(Uns_Params): Generic unit used to bundle together the\n\tspecification functions of System.Value_U_Spec.\n\t(Int_Params): Generic unit used to bundle together the\n\tspecification functions of System.Value_I_Spec.\n\t* libgnat/s-imagef.adb: It is now possible to instantiate the\n\tappropriate specification units instead of creating imported ghost\n\tsubprograms.\n\t* libgnat/s-imagei.adb: Update to refactoring of specifications\n\tand fix proofs.\n\t* libgnat/s-imageu.adb: Likewise.\n\t* libgnat/s-imgint.ads: Ghost parameters are grouped together in a\n\tpackage now.\n\t* libgnat/s-imglli.ads: Likewise.\n\t* libgnat/s-imgllu.ads: Likewise.\n\t* libgnat/s-imgllli.ads: Likewise.\n\t* libgnat/s-imglllu.ads: Likewise.\n\t* libgnat/s-imguns.ads: Likewise.\n\t* libgnat/s-vallli.ads: Likewise.\n\t* libgnat/s-valllli.ads: Likewise.\n\t* libgnat/s-imagei.ads: Likewise.\n\t* libgnat/s-imageu.ads: Likewise.\n\t* libgnat/s-vaispe.adb: Likewise.\n\t* libgnat/s-valint.ads: Likewise.\n\t* libgnat/s-valuei.ads: Likewise.\n\t* libgnat/s-valueu.ads: Likewise.\n\t* libgnat/s-vauspe.adb: Likewise.", "tree": {"sha": "758efad64a9473025b84166258a29c1f229079a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/758efad64a9473025b84166258a29c1f229079a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3ae28dca103a45bb97ec5b47acad9b9380d1113", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3ae28dca103a45bb97ec5b47acad9b9380d1113", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3ae28dca103a45bb97ec5b47acad9b9380d1113", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3ae28dca103a45bb97ec5b47acad9b9380d1113/comments", "author": {"login": "clairedross", "id": 8180017, "node_id": "MDQ6VXNlcjgxODAwMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/8180017?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clairedross", "html_url": "https://github.com/clairedross", "followers_url": "https://api.github.com/users/clairedross/followers", "following_url": "https://api.github.com/users/clairedross/following{/other_user}", "gists_url": "https://api.github.com/users/clairedross/gists{/gist_id}", "starred_url": "https://api.github.com/users/clairedross/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clairedross/subscriptions", "organizations_url": "https://api.github.com/users/clairedross/orgs", "repos_url": "https://api.github.com/users/clairedross/repos", "events_url": "https://api.github.com/users/clairedross/events{/privacy}", "received_events_url": "https://api.github.com/users/clairedross/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6713cc703c0914f993891d8ccb8167b29a8855cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6713cc703c0914f993891d8ccb8167b29a8855cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6713cc703c0914f993891d8ccb8167b29a8855cc"}], "stats": {"total": 3400, "additions": 1853, "deletions": 1547}, "files": [{"sha": "3979f147d2a18969027c575e3ba91aaca5381de2", "filename": "gcc/ada/libgnat/a-nbnbig.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fa-nbnbig.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fa-nbnbig.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-nbnbig.ads?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -32,6 +32,8 @@ package Ada.Numerics.Big_Numbers.Big_Integers_Ghost with\n    Ghost,\n    Pure\n is\n+   pragma Annotate (GNATprove, Always_Return, Big_Integers_Ghost);\n+\n    type Big_Integer is private\n      with Integer_Literal => From_Universal_Image;\n "}, {"sha": "bfe854038884fd3a2eac50433070ffd63b6ce7e4", "filename": "gcc/ada/libgnat/s-imagef.adb", "status": "modified", "additions": 10, "deletions": 63, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imagef.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imagef.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagef.adb?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -31,7 +31,8 @@\n \n with System.Image_I;\n with System.Img_Util; use System.Img_Util;\n-with System.Val_Util;\n+with System.Value_I_Spec;\n+with System.Value_U_Spec;\n \n package body System.Image_F is\n \n@@ -69,70 +70,16 @@ package body System.Image_F is\n    --  if the small is larger than 1, and smaller than 2**(Int'Size - 1) / 10\n    --  if the small is smaller than 1.\n \n-   --  Define ghost subprograms without implementation (marked as Import) to\n-   --  create a suitable package Int_Params for type Int, as instantiations\n-   --  of System.Image_F use for this type one of the derived integer types\n-   --  defined in Interfaces, instead of the standard signed integer types\n-   --  which are used to define System.Img_*.Int_Params.\n-\n-   type Uns_Option (Overflow : Boolean := False) is record\n-      case Overflow is\n-         when True =>\n-            null;\n-         when False =>\n-            Value : Uns := 0;\n-      end case;\n-   end record;\n-\n    Unsigned_Width_Ghost : constant Natural := Int'Width;\n \n-   function Wrap_Option (Value : Uns) return Uns_Option\n-     with Ghost, Import;\n-   function Only_Decimal_Ghost\n-     (Str      : String;\n-      From, To : Integer)\n-      return Boolean\n-     with Ghost, Import;\n-   function Hexa_To_Unsigned_Ghost (X : Character) return Uns\n-     with Ghost, Import;\n-   function Scan_Based_Number_Ghost\n-     (Str      : String;\n-      From, To : Integer;\n-      Base     : Uns := 10;\n-      Acc      : Uns := 0)\n-      return Uns_Option\n-     with Ghost, Import;\n-   function Is_Integer_Ghost (Str : String) return Boolean\n-     with Ghost, Import;\n-   procedure Prove_Iter_Scan_Based_Number_Ghost\n-     (Str1, Str2 : String;\n-      From, To : Integer;\n-      Base     : Uns := 10;\n-      Acc      : Uns := 0)\n-     with Ghost, Import;\n-   procedure Prove_Scan_Only_Decimal_Ghost (Str : String; Val : Int)\n-     with Ghost, Import;\n-   function Abs_Uns_Of_Int (Val : Int) return Uns\n-     with Ghost, Import;\n-   function Value_Integer (Str : String) return Int\n-     with Ghost, Import;\n-\n-   package Int_Params is new Val_Util.Int_Params\n-     (Int                                => Int,\n-      Uns                                => Uns,\n-      Uns_Option                         => Uns_Option,\n-      Unsigned_Width_Ghost               => Unsigned_Width_Ghost,\n-      Wrap_Option                        => Wrap_Option,\n-      Only_Decimal_Ghost                 => Only_Decimal_Ghost,\n-      Hexa_To_Unsigned_Ghost             => Hexa_To_Unsigned_Ghost,\n-      Scan_Based_Number_Ghost            => Scan_Based_Number_Ghost,\n-      Is_Integer_Ghost                   => Is_Integer_Ghost,\n-      Prove_Iter_Scan_Based_Number_Ghost => Prove_Iter_Scan_Based_Number_Ghost,\n-      Prove_Scan_Only_Decimal_Ghost      => Prove_Scan_Only_Decimal_Ghost,\n-      Abs_Uns_Of_Int                     => Abs_Uns_Of_Int,\n-      Value_Integer                      => Value_Integer);\n-\n-   package Image_I is new System.Image_I (Int_Params);\n+   package Uns_Spec is new System.Value_U_Spec (Uns);\n+   package Int_Spec is new System.Value_I_Spec (Int, Uns, Uns_Spec.Uns_Params);\n+\n+   package Image_I is new System.Image_I\n+     (Int                  => Int,\n+      Uns                  => Uns,\n+      Unsigned_Width_Ghost => Unsigned_Width_Ghost,\n+      Int_Params           => Int_Spec.Int_Params);\n \n    procedure Set_Image_Integer\n      (V : Int;"}, {"sha": "8997e3c5a7512e2a292399afd320ee1de44da14a", "filename": "gcc/ada/libgnat/s-imagei.adb", "status": "modified", "additions": 112, "deletions": 140, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imagei.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imagei.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagei.adb?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -46,42 +46,6 @@ package body System.Image_I is\n                             Post               => Ignore,\n                             Subprogram_Variant => Ignore);\n \n-   --  As a use_clause for Int_Params cannot be used for instances of this\n-   --  generic in System specs, rename all constants and subprograms.\n-\n-   Unsigned_Width_Ghost : constant Natural := Int_Params.Unsigned_Width_Ghost;\n-\n-   function Wrap_Option (Value : Uns) return Uns_Option\n-     renames Int_Params.Wrap_Option;\n-   function Only_Decimal_Ghost\n-     (Str      : String;\n-      From, To : Integer)\n-      return Boolean\n-      renames Int_Params.Only_Decimal_Ghost;\n-   function Hexa_To_Unsigned_Ghost (X : Character) return Uns\n-     renames Int_Params.Hexa_To_Unsigned_Ghost;\n-   function Scan_Based_Number_Ghost\n-     (Str      : String;\n-      From, To : Integer;\n-      Base     : Uns := 10;\n-      Acc      : Uns := 0)\n-      return Uns_Option\n-      renames Int_Params.Scan_Based_Number_Ghost;\n-   function Is_Integer_Ghost (Str : String) return Boolean\n-     renames Int_Params.Is_Integer_Ghost;\n-   procedure Prove_Iter_Scan_Based_Number_Ghost\n-     (Str1, Str2 : String;\n-      From, To : Integer;\n-      Base     : Uns := 10;\n-      Acc      : Uns := 0)\n-      renames Int_Params.Prove_Iter_Scan_Based_Number_Ghost;\n-   procedure Prove_Scan_Only_Decimal_Ghost (Str : String; Val : Int)\n-     renames Int_Params.Prove_Scan_Only_Decimal_Ghost;\n-   function Abs_Uns_Of_Int (Val : Int) return Uns\n-     renames Int_Params.Abs_Uns_Of_Int;\n-   function Value_Integer (Str : String) return Int\n-     renames Int_Params.Value_Integer;\n-\n    subtype Non_Positive is Int range Int'First .. 0;\n \n    function Uns_Of_Non_Positive (T : Non_Positive) return Uns is\n@@ -99,9 +63,9 @@ package body System.Image_I is\n        and then P <= S'Last - Unsigned_Width_Ghost + 1,\n      Post => S (S'First .. P'Old) = S'Old (S'First .. P'Old)\n        and then P in P'Old + 1 .. S'Last\n-       and then Only_Decimal_Ghost (S, From => P'Old + 1, To => P)\n-       and then Scan_Based_Number_Ghost (S, From => P'Old + 1, To => P)\n-         = Wrap_Option (Uns_Of_Non_Positive (T));\n+       and then UP.Only_Decimal_Ghost (S, From => P'Old + 1, To => P)\n+       and then UP.Scan_Based_Number_Ghost (S, From => P'Old + 1, To => P)\n+         = UP.Wrap_Option (Uns_Of_Non_Positive (T));\n    --  Set digits of absolute value of T, which is zero or negative. We work\n    --  with the negative of the value so that the largest negative number is\n    --  not a special case.\n@@ -182,11 +146,12 @@ package body System.Image_I is\n           and then P in 2 .. S'Last\n           and then S (1) in ' ' | '-'\n           and then (S (1) = '-') = (V < 0)\n-          and then Only_Decimal_Ghost (S, From => 2, To => P)\n-          and then Scan_Based_Number_Ghost (S, From => 2, To => P)\n-            = Wrap_Option (Abs_Uns_Of_Int (V)),\n-        Post => Is_Integer_Ghost (S (1 .. P))\n-          and then Value_Integer (S (1 .. P)) = V;\n+          and then UP.Only_Decimal_Ghost (S, From => 2, To => P)\n+          and then UP.Scan_Based_Number_Ghost (S, From => 2, To => P)\n+            = UP.Wrap_Option (IP.Abs_Uns_Of_Int (V)),\n+        Post => not System.Val_Util.Only_Space_Ghost (S, 1, P)\n+          and then IP.Is_Integer_Ghost (S (1 .. P))\n+          and then IP.Is_Value_Integer_Ghost (S (1 .. P), V);\n       --  Ghost lemma to prove the value of Value_Integer from the value of\n       --  Scan_Based_Number_Ghost and the sign on a decimal string.\n \n@@ -198,11 +163,14 @@ package body System.Image_I is\n          Str : constant String := S (1 .. P);\n       begin\n          pragma Assert (Str'First = 1);\n-         pragma Assert (Only_Decimal_Ghost (Str, From => 2, To => P));\n-         Prove_Iter_Scan_Based_Number_Ghost (S, Str, From => 2, To => P);\n-         pragma Assert (Scan_Based_Number_Ghost (Str, From => 2, To => P)\n-            = Wrap_Option (Abs_Uns_Of_Int (V)));\n-         Prove_Scan_Only_Decimal_Ghost (Str, V);\n+         pragma Assert (Str (2) /= ' ');\n+         pragma Assert\n+           (UP.Only_Decimal_Ghost (Str, From => 2, To => P));\n+         UP.Prove_Scan_Based_Number_Ghost_Eq (S, Str, From => 2, To => P);\n+         pragma Assert\n+           (UP.Scan_Based_Number_Ghost (Str, From => 2, To => P)\n+            = UP.Wrap_Option (IP.Abs_Uns_Of_Int (V)));\n+         IP.Prove_Scan_Only_Decimal_Ghost (Str, V);\n       end Prove_Value_Integer;\n \n    --  Start of processing for Image_Integer\n@@ -226,6 +194,8 @@ package body System.Image_I is\n \n          pragma Assert (P_Prev + Offset = 2);\n       end;\n+      pragma Assert (if V >= 0 then S (1) = ' ');\n+      pragma Assert (S (1) in ' ' | '-');\n \n       Prove_Value_Integer;\n    end Image_Integer;\n@@ -248,42 +218,78 @@ package body System.Image_I is\n       S_Init     : constant String := S with Ghost;\n       Uns_T      : constant Uns := Uns_Of_Non_Positive (T) with Ghost;\n       Uns_Value  : Uns := Uns_Of_Non_Positive (Value) with Ghost;\n-      Prev, Cur  : Uns_Option with Ghost;\n       Prev_Value : Uns with Ghost;\n       Prev_S     : String := S with Ghost;\n \n       --  Local ghost lemmas\n \n-      procedure Prove_Character_Val (RU : Uns; RI : Int)\n+      procedure Prove_Character_Val (RU : Uns; RI : Non_Positive)\n       with\n         Ghost,\n-        Pre  => RU in 0 .. 9\n-          and then RI in 0 .. 9,\n-        Post => Character'Val (48 + RU) in '0' .. '9'\n-          and then Character'Val (48 + RI) in '0' .. '9';\n+        Post => RU rem 10 in 0 .. 9\n+          and then -(RI rem 10) in 0 .. 9\n+          and then Character'Val (48 + RU rem 10) in '0' .. '9'\n+          and then Character'Val (48 - RI rem 10) in '0' .. '9';\n       --  Ghost lemma to prove the value of a character corresponding to the\n       --  next figure.\n \n+      procedure Prove_Euclidian (Val, Quot, Rest : Uns)\n+      with\n+        Ghost,\n+        Pre  => Quot = Val / 10\n+          and then Rest = Val rem 10,\n+        Post => Uns'Last - Rest >= 10 * Quot and then Val = 10 * Quot + Rest;\n+      --  Ghost lemma to prove the relation between the quotient/remainder of\n+      --  division by 10 and the initial value.\n+\n       procedure Prove_Hexa_To_Unsigned_Ghost (RU : Uns; RI : Int)\n       with\n         Ghost,\n         Pre  => RU in 0 .. 9\n           and then RI in 0 .. 9,\n-        Post => Hexa_To_Unsigned_Ghost (Character'Val (48 + RU)) = RU\n-          and then Hexa_To_Unsigned_Ghost (Character'Val (48 + RI)) = Uns (RI);\n+        Post => UP.Hexa_To_Unsigned_Ghost\n+            (Character'Val (48 + RU)) = RU\n+          and then UP.Hexa_To_Unsigned_Ghost\n+            (Character'Val (48 + RI)) = Uns (RI);\n       --  Ghost lemma to prove that Hexa_To_Unsigned_Ghost returns the source\n       --  figure when applied to the corresponding character.\n \n-      procedure Prove_Unchanged\n-      with\n-        Ghost,\n-        Pre  => P <= S'Last\n-          and then S_Init'First = S'First\n-          and then S_Init'Last = S'Last\n-          and then (for all K in S'First .. P => S (K) = S_Init (K)),\n-        Post => S (S'First .. P) = S_Init (S'First .. P);\n-      --  Ghost lemma to prove that the part of string S before P has not been\n-      --  modified.\n+      procedure Prove_Scan_Iter\n+        (S, Prev_S      : String;\n+         V, Prev_V, Res : Uns;\n+         P, Max         : Natural)\n+        with\n+          Ghost,\n+          Pre =>\n+            S'First = Prev_S'First and then S'Last = Prev_S'Last\n+            and then S'Last < Natural'Last and then\n+            Max in S'Range and then P in S'First .. Max and then\n+            (for all I in P + 1 .. Max => Prev_S (I) in '0' .. '9')\n+            and then (for all I in P + 1 .. Max => Prev_S (I) = S (I))\n+            and then S (P) in '0' .. '9'\n+            and then V <= Uns'Last / 10\n+            and then Uns'Last - UP.Hexa_To_Unsigned_Ghost (S (P))\n+              >= 10 * V\n+            and then Prev_V =\n+              V * 10 + UP.Hexa_To_Unsigned_Ghost (S (P))\n+            and then\n+              (if P = Max then Prev_V = Res\n+               else UP.Scan_Based_Number_Ghost\n+                 (Str  => Prev_S,\n+                  From => P + 1,\n+                  To   => Max,\n+                  Base => 10,\n+                  Acc  => Prev_V) = UP.Wrap_Option (Res)),\n+          Post =>\n+            (for all I in P .. Max => S (I) in '0' .. '9')\n+            and then UP.Scan_Based_Number_Ghost\n+              (Str  => S,\n+               From => P,\n+               To   => Max,\n+               Base => 10,\n+               Acc  => V) = UP.Wrap_Option (Res);\n+      --  Ghost lemma to prove that Scan_Based_Number_Ghost is preserved\n+      --  through an iteration of the loop.\n \n       procedure Prove_Uns_Of_Non_Positive_Value\n       with\n@@ -294,50 +300,44 @@ package body System.Image_I is\n       --  Ghost lemma to prove that the relation between Value and its unsigned\n       --  version is preserved.\n \n-      procedure Prove_Iter_Scan\n-        (Str1, Str2 : String;\n-         From, To : Integer;\n-         Base     : Uns := 10;\n-         Acc      : Uns := 0)\n-      with\n-        Ghost,\n-        Pre  => Str1'Last /= Positive'Last\n-          and then\n-            (From > To or else (From >= Str1'First and then To <= Str1'Last))\n-          and then Only_Decimal_Ghost (Str1, From, To)\n-          and then Str1'First = Str2'First\n-          and then Str1'Last = Str2'Last\n-          and then (for all J in From .. To => Str1 (J) = Str2 (J)),\n-        Post =>\n-          Scan_Based_Number_Ghost (Str1, From, To, Base, Acc)\n-            = Scan_Based_Number_Ghost (Str2, From, To, Base, Acc);\n-      --  Ghost lemma to prove that the result of Scan_Based_Number_Ghost only\n-      --  depends on the value of the argument string in the (From .. To) range\n-      --  of indexes. This is a wrapper on Prove_Iter_Scan_Based_Number_Ghost\n-      --  so that we can call it here on ghost arguments.\n-\n       -----------------------------\n       -- Local lemma null bodies --\n       -----------------------------\n \n-      procedure Prove_Character_Val (RU : Uns; RI : Int) is null;\n+      procedure Prove_Character_Val (RU : Uns; RI : Non_Positive) is null;\n+      procedure Prove_Euclidian (Val, Quot, Rest : Uns) is null;\n       procedure Prove_Hexa_To_Unsigned_Ghost (RU : Uns; RI : Int) is null;\n-      procedure Prove_Unchanged is null;\n       procedure Prove_Uns_Of_Non_Positive_Value is null;\n \n       ---------------------\n-      -- Prove_Iter_Scan --\n+      -- Prove_Scan_Iter --\n       ---------------------\n \n-      procedure Prove_Iter_Scan\n-        (Str1, Str2 : String;\n-         From, To : Integer;\n-         Base     : Uns := 10;\n-         Acc      : Uns := 0)\n+      procedure Prove_Scan_Iter\n+        (S, Prev_S      : String;\n+         V, Prev_V, Res : Uns;\n+         P, Max         : Natural)\n       is\n+         pragma Unreferenced (Res);\n       begin\n-         Prove_Iter_Scan_Based_Number_Ghost (Str1, Str2, From, To, Base, Acc);\n-      end Prove_Iter_Scan;\n+         UP.Lemma_Scan_Based_Number_Ghost_Step\n+           (Str  => S,\n+            From => P,\n+            To   => Max,\n+            Base => 10,\n+            Acc  => V);\n+         if P < Max then\n+            UP.Prove_Scan_Based_Number_Ghost_Eq\n+              (Prev_S, S, P + 1, Max, 10, Prev_V);\n+         else\n+            UP.Lemma_Scan_Based_Number_Ghost_Base\n+              (Str  => S,\n+               From => P + 1,\n+               To   => Max,\n+               Base => 10,\n+               Acc  => Prev_V);\n+         end if;\n+      end Prove_Scan_Iter;\n \n    --  Start of processing for Set_Digits\n \n@@ -383,13 +383,9 @@ package body System.Image_I is\n       for J in reverse  1 .. Nb_Digits loop\n          Lemma_Div_Commutation (Uns_Value, 10);\n          Lemma_Div_Twice (Big (Uns_T), Big_10 ** (Nb_Digits - J), Big_10);\n-         Prove_Character_Val (Uns_Value rem 10, -(Value rem 10));\n+         Prove_Character_Val (Uns_Value, Value);\n          Prove_Hexa_To_Unsigned_Ghost (Uns_Value rem 10, -(Value rem 10));\n          Prove_Uns_Of_Non_Positive_Value;\n-         pragma Assert (Uns_Value rem 10 = Uns_Of_Non_Positive (Value rem 10));\n-         pragma Assert (Uns_Value rem 10 = Uns (-(Value rem 10)));\n-         pragma Assert\n-           (Uns_Value = From_Big (Big (Uns_T) / Big_10 ** (Nb_Digits - J)));\n \n          Prev_Value := Uns_Value;\n          Prev_S := S;\n@@ -399,68 +395,44 @@ package body System.Image_I is\n          S (P + J) := Character'Val (48 - (Value rem 10));\n          Value := Value / 10;\n \n-         pragma Assert (S (P + J) in '0' .. '9');\n-         pragma Assert (Hexa_To_Unsigned_Ghost (S (P + J)) =\n-           From_Big (Big (Uns_T) / Big_10 ** (Nb_Digits - J)) rem 10);\n-         pragma Assert\n-           (for all K in P + J + 1 .. P + Nb_Digits => S (K) in '0' .. '9');\n+         Prove_Euclidian\n+           (Val  => Prev_Value,\n+            Quot => Uns_Value,\n+            Rest => UP.Hexa_To_Unsigned_Ghost (S (P + J)));\n \n-         Prev := Scan_Based_Number_Ghost\n-           (Str  => S,\n-            From => P + J + 1,\n-            To   => P + Nb_Digits,\n-            Base => 10,\n-            Acc  => Prev_Value);\n-         Cur := Scan_Based_Number_Ghost\n-           (Str  => S,\n-            From => P + J,\n-            To   => P + Nb_Digits,\n-            Base => 10,\n-            Acc  => Uns_Value);\n-         pragma Assert (Prev_Value = 10 * Uns_Value + (Prev_Value rem 10));\n-         pragma Assert\n-           (Prev_Value rem 10 = Hexa_To_Unsigned_Ghost (S (P + J)));\n-         pragma Assert\n-           (Prev_Value = 10 * Uns_Value + Hexa_To_Unsigned_Ghost (S (P + J)));\n-\n-         if J /= Nb_Digits then\n-            Prove_Iter_Scan\n-              (Prev_S, S, P + J + 1, P + Nb_Digits, 10, Prev_Value);\n-         end if;\n-\n-         pragma Assert (Prev = Cur);\n-         pragma Assert (Prev = Wrap_Option (Uns_T));\n+         Prove_Scan_Iter\n+           (S, Prev_S, Uns_Value, Prev_Value, Uns_T, P + J, P + Nb_Digits);\n \n          pragma Loop_Invariant (Uns_Value = Uns_Of_Non_Positive (Value));\n          pragma Loop_Invariant (Uns_Value <= Uns'Last / 10);\n          pragma Loop_Invariant\n            (for all K in S'First .. P => S (K) = S_Init (K));\n-         pragma Loop_Invariant (Only_Decimal_Ghost (S, P + J, P + Nb_Digits));\n+         pragma Loop_Invariant\n+           (UP.Only_Decimal_Ghost (S, P + J, P + Nb_Digits));\n          pragma Loop_Invariant\n            (for all K in P + J .. P + Nb_Digits => S (K) in '0' .. '9');\n          pragma Loop_Invariant (Pow = Big_10 ** (Nb_Digits - J + 1));\n          pragma Loop_Invariant (Big (Uns_Value) = Big (Uns_T) / Pow);\n          pragma Loop_Invariant\n-           (Scan_Based_Number_Ghost\n+           (UP.Scan_Based_Number_Ghost\n               (Str  => S,\n                From => P + J,\n                To   => P + Nb_Digits,\n                Base => 10,\n                Acc  => Uns_Value)\n-              = Wrap_Option (Uns_T));\n+              = UP.Wrap_Option (Uns_T));\n       end loop;\n \n       pragma Assert (Big (Uns_Value) = Big (Uns_T) / Big_10 ** (Nb_Digits));\n       pragma Assert (Uns_Value = 0);\n-      Prove_Unchanged;\n       pragma Assert\n-        (Scan_Based_Number_Ghost\n+        (UP.Scan_Based_Number_Ghost\n            (Str  => S,\n             From => P + 1,\n             To   => P + Nb_Digits,\n             Base => 10,\n             Acc  => Uns_Value)\n-         = Wrap_Option (Uns_T));\n+         = UP.Wrap_Option (Uns_T));\n \n       P := P + Nb_Digits;\n    end Set_Digits;"}, {"sha": "575c60abb2c849aae1049587a3753eaf49addc91", "filename": "gcc/ada/libgnat/s-imagei.ads", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imagei.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imagei.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagei.ads?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -48,19 +48,19 @@ pragma Assertion_Policy (Pre                => Ignore,\n with System.Val_Util;\n \n generic\n+   type Int is range <>;\n+   type Uns is mod <>;\n \n-   with package Int_Params is new System.Val_Util.Int_Params (<>);\n+   Unsigned_Width_Ghost : Natural;\n \n-package System.Image_I is\n-\n-   subtype Int is Int_Params.Int;\n-   use type Int_Params.Int;\n+   with package Int_Params is new System.Val_Util.Int_Params\n+     (Int => Int, Uns => Uns, others => <>)\n+   with Ghost;\n \n-   subtype Uns is Int_Params.Uns;\n-   use type Int_Params.Uns;\n-\n-   subtype Uns_Option is Int_Params.Uns_Option;\n-   use type Int_Params.Uns_Option;\n+package System.Image_I is\n+   package IP renames Int_Params;\n+   package UP renames IP.Uns_Params;\n+   use type UP.Uns_Option;\n \n    procedure Image_Integer\n      (V : Int;\n@@ -69,9 +69,9 @@ package System.Image_I is\n    with\n      Pre  => S'First = 1\n        and then S'Last < Integer'Last\n-       and then S'Last >= Int_Params.Unsigned_Width_Ghost,\n+       and then S'Last >= Unsigned_Width_Ghost,\n      Post => P in S'Range\n-       and then Int_Params.Value_Integer (S (1 .. P)) = V;\n+       and then IP.Is_Value_Integer_Ghost (S (1 .. P), V);\n    --  Computes Int'Image (V) and stores the result in S (1 .. P)\n    --  setting the resulting value of P. The caller guarantees that S\n    --  is long enough to hold the result, and that S'First is 1.\n@@ -87,23 +87,23 @@ package System.Image_I is\n        and then S'First <= S'Last\n        and then\n          (if V >= 0 then\n-            P <= S'Last - Int_Params.Unsigned_Width_Ghost + 1\n+            P <= S'Last - Unsigned_Width_Ghost + 1\n           else\n-            P <= S'Last - Int_Params.Unsigned_Width_Ghost),\n+            P <= S'Last - Unsigned_Width_Ghost),\n      Post => S (S'First .. P'Old) = S'Old (S'First .. P'Old)\n        and then\n          (declare\n             Minus  : constant Boolean := S (P'Old + 1) = '-';\n             Offset : constant Positive := (if V >= 0 then 1 else 2);\n-            Abs_V  : constant Uns := Int_Params.Abs_Uns_Of_Int (V);\n+            Abs_V  : constant Uns := IP.Abs_Uns_Of_Int (V);\n           begin\n             Minus = (V < 0)\n               and then P in P'Old + Offset .. S'Last\n-              and then Int_Params.Only_Decimal_Ghost\n+              and then UP.Only_Decimal_Ghost\n                 (S, From => P'Old + Offset, To => P)\n-              and then Int_Params.Scan_Based_Number_Ghost\n+              and then UP.Scan_Based_Number_Ghost\n                 (S, From => P'Old + Offset, To => P)\n-                = Int_Params.Wrap_Option (Abs_V));\n+                = UP.Wrap_Option (Abs_V));\n    --  Stores the image of V in S starting at S (P + 1), P is updated to point\n    --  to the last character stored. The value stored is identical to the value\n    --  of Int'Image (V) except that no leading space is stored when V is"}, {"sha": "0e1c2bb593fa4cc107db3457e6cd0def5672f284", "filename": "gcc/ada/libgnat/s-imageu.adb", "status": "modified", "additions": 92, "deletions": 102, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imageu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imageu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imageu.adb?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -147,11 +147,12 @@ package body System.Image_U is\n           and then S'Last < Integer'Last\n           and then P in 2 .. S'Last\n           and then S (1) = ' '\n-          and then Only_Decimal_Ghost (S, From => 2, To => P)\n-          and then Scan_Based_Number_Ghost (S, From => 2, To => P)\n-            = Wrap_Option (V),\n-        Post => Is_Unsigned_Ghost (S (1 .. P))\n-          and then Value_Unsigned (S (1 .. P)) = V;\n+          and then Uns_Params.Only_Decimal_Ghost (S, From => 2, To => P)\n+          and then Uns_Params.Scan_Based_Number_Ghost (S, From => 2, To => P)\n+            = Uns_Params.Wrap_Option (V),\n+        Post => not System.Val_Util.Only_Space_Ghost (S, 1, P)\n+          and then Uns_Params.Is_Unsigned_Ghost (S (1 .. P))\n+          and then Uns_Params.Is_Value_Unsigned_Ghost (S (1 .. P), V);\n       --  Ghost lemma to prove the value of Value_Unsigned from the value of\n       --  Scan_Based_Number_Ghost on a decimal string.\n \n@@ -163,11 +164,15 @@ package body System.Image_U is\n          Str : constant String := S (1 .. P);\n       begin\n          pragma Assert (Str'First = 1);\n-         pragma Assert (Only_Decimal_Ghost (Str, From => 2, To => P));\n-         Prove_Iter_Scan_Based_Number_Ghost (S, Str, From => 2, To => P);\n-         pragma Assert (Scan_Based_Number_Ghost (Str, From => 2, To => P)\n-            = Wrap_Option (V));\n-         Prove_Scan_Only_Decimal_Ghost (Str, V);\n+         pragma Assert (S (2) /= ' ');\n+         pragma Assert\n+           (Uns_Params.Only_Decimal_Ghost (Str, From => 2, To => P));\n+         Uns_Params.Prove_Scan_Based_Number_Ghost_Eq\n+           (S, Str, From => 2, To => P);\n+         pragma Assert\n+           (Uns_Params.Scan_Based_Number_Ghost (Str, From => 2, To => P)\n+            = Uns_Params.Wrap_Option (V));\n+         Uns_Params.Prove_Scan_Only_Decimal_Ghost (Str, V);\n       end Prove_Value_Unsigned;\n \n    --  Start of processing for Image_Unsigned\n@@ -196,7 +201,6 @@ package body System.Image_U is\n \n       Pow        : Big_Positive := 1 with Ghost;\n       S_Init     : constant String := S with Ghost;\n-      Prev, Cur  : Uns_Option with Ghost;\n       Prev_Value : Uns with Ghost;\n       Prev_S     : String := S with Ghost;\n \n@@ -205,8 +209,8 @@ package body System.Image_U is\n       procedure Prove_Character_Val (R : Uns)\n       with\n         Ghost,\n-        Pre  => R in 0 .. 9,\n-        Post => Character'Val (48 + R) in '0' .. '9';\n+        Post => R rem 10 in 0 .. 9\n+          and then Character'Val (48 + R rem 10) in '0' .. '9';\n       --  Ghost lemma to prove the value of a character corresponding to the\n       --  next figure.\n \n@@ -215,50 +219,54 @@ package body System.Image_U is\n         Ghost,\n         Pre  => Quot = Val / 10\n           and then Rest = Val rem 10,\n-        Post => Val = 10 * Quot + Rest;\n+        Post => Uns'Last - Rest >= 10 * Quot and then Val = 10 * Quot + Rest;\n       --  Ghost lemma to prove the relation between the quotient/remainder of\n       --  division by 10 and the initial value.\n \n       procedure Prove_Hexa_To_Unsigned_Ghost (R : Uns)\n       with\n         Ghost,\n         Pre  => R in 0 .. 9,\n-        Post => Hexa_To_Unsigned_Ghost (Character'Val (48 + R)) = R;\n+        Post => Uns_Params.Hexa_To_Unsigned_Ghost (Character'Val (48 + R)) = R;\n       --  Ghost lemma to prove that Hexa_To_Unsigned_Ghost returns the source\n       --  figure when applied to the corresponding character.\n \n-      procedure Prove_Unchanged\n-      with\n-        Ghost,\n-        Pre  => P <= S'Last\n-          and then S_Init'First = S'First\n-          and then S_Init'Last = S'Last\n-          and then (for all K in S'First .. P => S (K) = S_Init (K)),\n-        Post => S (S'First .. P) = S_Init (S'First .. P);\n-      --  Ghost lemma to prove that the part of string S before P has not been\n-      --  modified.\n-\n-      procedure Prove_Iter_Scan\n-        (Str1, Str2 : String;\n-         From, To : Integer;\n-         Base     : Uns := 10;\n-         Acc      : Uns := 0)\n-      with\n-        Ghost,\n-        Pre  => Str1'Last /= Positive'Last\n-          and then\n-            (From > To or else (From >= Str1'First and then To <= Str1'Last))\n-          and then Only_Decimal_Ghost (Str1, From, To)\n-          and then Str1'First = Str2'First\n-          and then Str1'Last = Str2'Last\n-          and then (for all J in From .. To => Str1 (J) = Str2 (J)),\n-        Post =>\n-          Scan_Based_Number_Ghost (Str1, From, To, Base, Acc)\n-            = Scan_Based_Number_Ghost (Str2, From, To, Base, Acc);\n-      --  Ghost lemma to prove that the result of Scan_Based_Number_Ghost only\n-      --  depends on the value of the argument string in the (From .. To) range\n-      --  of indexes. This is a wrapper on Prove_Iter_Scan_Based_Number_Ghost\n-      --  so that we can call it here on ghost arguments.\n+      procedure Prove_Scan_Iter\n+        (S, Prev_S      : String;\n+         V, Prev_V, Res : Uns;\n+         P, Max         : Natural)\n+        with\n+          Ghost,\n+          Pre =>\n+            S'First = Prev_S'First and then S'Last = Prev_S'Last\n+            and then S'Last < Natural'Last and then\n+            Max in S'Range and then P in S'First .. Max and then\n+            (for all I in P + 1 .. Max => Prev_S (I) in '0' .. '9')\n+            and then (for all I in P + 1 .. Max => Prev_S (I) = S (I))\n+            and then S (P) in '0' .. '9'\n+            and then V <= Uns'Last / 10\n+            and then Uns'Last - Uns_Params.Hexa_To_Unsigned_Ghost (S (P))\n+              >= 10 * V\n+            and then Prev_V =\n+              V * 10 + Uns_Params.Hexa_To_Unsigned_Ghost (S (P))\n+            and then\n+              (if P = Max then Prev_V = Res\n+               else Uns_Params.Scan_Based_Number_Ghost\n+                 (Str  => Prev_S,\n+                  From => P + 1,\n+                  To   => Max,\n+                  Base => 10,\n+                  Acc  => Prev_V) = Uns_Params.Wrap_Option (Res)),\n+          Post =>\n+            (for all I in P .. Max => S (I) in '0' .. '9')\n+            and then Uns_Params.Scan_Based_Number_Ghost\n+              (Str  => S,\n+               From => P,\n+               To   => Max,\n+               Base => 10,\n+               Acc  => V) = Uns_Params.Wrap_Option (Res);\n+      --  Ghost lemma to prove that Scan_Based_Number_Ghost is preserved\n+      --  through an iteration of the loop.\n \n       -----------------------------\n       -- Local lemma null bodies --\n@@ -267,21 +275,36 @@ package body System.Image_U is\n       procedure Prove_Character_Val (R : Uns) is null;\n       procedure Prove_Euclidian (Val, Quot, Rest : Uns) is null;\n       procedure Prove_Hexa_To_Unsigned_Ghost (R : Uns) is null;\n-      procedure Prove_Unchanged is null;\n \n       ---------------------\n-      -- Prove_Iter_Scan --\n+      -- Prove_Scan_Iter --\n       ---------------------\n \n-      procedure Prove_Iter_Scan\n-        (Str1, Str2 : String;\n-         From, To : Integer;\n-         Base     : Uns := 10;\n-         Acc      : Uns := 0)\n+      procedure Prove_Scan_Iter\n+        (S, Prev_S      : String;\n+         V, Prev_V, Res : Uns;\n+         P, Max         : Natural)\n       is\n+         pragma Unreferenced (Res);\n       begin\n-         Prove_Iter_Scan_Based_Number_Ghost (Str1, Str2, From, To, Base, Acc);\n-      end Prove_Iter_Scan;\n+         Uns_Params.Lemma_Scan_Based_Number_Ghost_Step\n+           (Str  => S,\n+            From => P,\n+            To   => Max,\n+            Base => 10,\n+            Acc  => V);\n+         if P < Max then\n+            Uns_Params.Prove_Scan_Based_Number_Ghost_Eq\n+              (Prev_S, S, P + 1, Max, 10, Prev_V);\n+         else\n+            Uns_Params.Lemma_Scan_Based_Number_Ghost_Base\n+              (Str  => S,\n+               From => P + 1,\n+               To   => Max,\n+               Base => 10,\n+               Acc  => Prev_V);\n+         end if;\n+      end Prove_Scan_Iter;\n \n    --  Start of processing for Set_Image_Unsigned\n \n@@ -313,6 +336,7 @@ package body System.Image_U is\n          Lemma_Non_Zero (Value);\n          pragma Assert (Pow <= Big (Uns'Last));\n       end loop;\n+      pragma Assert (Big (V) / (Big_10 ** Nb_Digits) = 0);\n \n       Value := V;\n       Pow := 1;\n@@ -323,77 +347,43 @@ package body System.Image_U is\n       for J in reverse 1 .. Nb_Digits loop\n          Lemma_Div_Commutation (Value, 10);\n          Lemma_Div_Twice (Big (V), Big_10 ** (Nb_Digits - J), Big_10);\n-         Prove_Character_Val (Value rem 10);\n+         Prove_Character_Val (Value);\n          Prove_Hexa_To_Unsigned_Ghost (Value rem 10);\n \n          Prev_Value := Value;\n          Prev_S := S;\n          Pow := Pow * 10;\n-\n          S (P + J) := Character'Val (48 + (Value rem 10));\n          Value := Value / 10;\n \n-         pragma Assert (S (P + J) in '0' .. '9');\n-         pragma Assert (Hexa_To_Unsigned_Ghost (S (P + J)) =\n-           From_Big (Big (V) / Big_10 ** (Nb_Digits - J)) rem 10);\n-         pragma Assert\n-           (for all K in P + J + 1 .. P + Nb_Digits => S (K) in '0' .. '9');\n-         pragma Assert\n-           (for all K in P + J + 1 .. P + Nb_Digits =>\n-              Hexa_To_Unsigned_Ghost (S (K)) =\n-                From_Big (Big (V) / Big_10 ** (Nb_Digits - (K - P))) rem 10);\n-\n-         Prev := Scan_Based_Number_Ghost\n-           (Str  => S,\n-            From => P + J + 1,\n-            To   => P + Nb_Digits,\n-            Base => 10,\n-            Acc  => Prev_Value);\n-         Cur := Scan_Based_Number_Ghost\n-           (Str  => S,\n-            From => P + J,\n-            To   => P + Nb_Digits,\n-            Base => 10,\n-            Acc  => Value);\n-\n-         if J /= Nb_Digits then\n-            Prove_Euclidian (Val  => Prev_Value,\n-                             Quot => Value,\n-                             Rest => Hexa_To_Unsigned_Ghost (S (P + J)));\n-            pragma Assert\n-              (Prev_Value = 10 * Value + Hexa_To_Unsigned_Ghost (S (P + J)));\n-            Prove_Iter_Scan\n-              (Prev_S, S, P + J + 1, P + Nb_Digits, 10, Prev_Value);\n-         end if;\n+         Prove_Euclidian\n+           (Val  => Prev_Value,\n+            Quot => Value,\n+            Rest => Uns_Params.Hexa_To_Unsigned_Ghost (S (P + J)));\n \n-         pragma Assert (Prev = Cur);\n-         pragma Assert (Prev = Wrap_Option (V));\n+         Prove_Scan_Iter\n+           (S, Prev_S, Value, Prev_Value, V, P + J, P + Nb_Digits);\n \n          pragma Loop_Invariant (Value <= Uns'Last / 10);\n          pragma Loop_Invariant\n            (for all K in S'First .. P => S (K) = S_Init (K));\n-         pragma Loop_Invariant (Only_Decimal_Ghost (S, P + J, P + Nb_Digits));\n-         pragma Loop_Invariant\n-           (for all K in P + J .. P + Nb_Digits => S (K) in '0' .. '9');\n          pragma Loop_Invariant\n-           (for all K in P + J .. P + Nb_Digits =>\n-              Hexa_To_Unsigned_Ghost (S (K)) =\n-                From_Big (Big (V) / Big_10 ** (Nb_Digits - (K - P))) rem 10);\n+           (Uns_Params.Only_Decimal_Ghost\n+              (S, From => P + J, To => P + Nb_Digits));\n          pragma Loop_Invariant (Pow = Big_10 ** (Nb_Digits - J + 1));\n          pragma Loop_Invariant (Big (Value) = Big (V) / Pow);\n          pragma Loop_Invariant\n-           (Scan_Based_Number_Ghost\n+           (Uns_Params.Scan_Based_Number_Ghost\n               (Str  => S,\n                From => P + J,\n                To   => P + Nb_Digits,\n                Base => 10,\n                Acc  => Value)\n-              = Wrap_Option (V));\n+              = Uns_Params.Wrap_Option (V));\n       end loop;\n+      pragma Assert (Big (Value) = Big (V) / (Big_10 ** Nb_Digits));\n       pragma Assert (Value = 0);\n \n-      Prove_Unchanged;\n-\n       P := P + Nb_Digits;\n    end Set_Image_Unsigned;\n "}, {"sha": "3d80ea9af5a820c6f5d908b4489a877e5e9de6cc", "filename": "gcc/ada/libgnat/s-imageu.ads", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imageu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imageu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imageu.ads?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -45,45 +45,22 @@ pragma Assertion_Policy (Pre                => Ignore,\n                          Ghost              => Ignore,\n                          Subprogram_Variant => Ignore);\n \n+with System.Val_Util;\n+\n generic\n \n    type Uns is mod <>;\n-   type Uns_Option is private;\n \n    --  Additional parameters for ghost subprograms used inside contracts\n \n    Unsigned_Width_Ghost : Natural;\n \n-   with function Wrap_Option (Value : Uns) return Uns_Option\n-      with Ghost;\n-   with function Only_Decimal_Ghost\n-     (Str      : String;\n-      From, To : Integer)\n-      return Boolean\n-      with Ghost;\n-   with function Hexa_To_Unsigned_Ghost (X : Character) return Uns\n-      with Ghost;\n-   with function Scan_Based_Number_Ghost\n-     (Str      : String;\n-      From, To : Integer;\n-      Base     : Uns := 10;\n-      Acc      : Uns := 0) return Uns_Option\n-      with Ghost;\n-   with function Is_Unsigned_Ghost (Str : String) return Boolean\n-      with Ghost;\n-   with function Value_Unsigned (Str : String) return Uns;\n-   with procedure Prove_Iter_Scan_Based_Number_Ghost\n-     (Str1, Str2 : String;\n-      From, To : Integer;\n-      Base     : Uns := 10;\n-      Acc      : Uns := 0)\n-      with Ghost;\n-   with procedure Prove_Scan_Only_Decimal_Ghost\n-     (Str : String;\n-      Val : Uns)\n-      with Ghost;\n+   with package Uns_Params is new System.Val_Util.Uns_Params\n+     (Uns => Uns, others => <>)\n+   with Ghost;\n \n package System.Image_U is\n+   use all type Uns_Params.Uns_Option;\n \n    procedure Image_Unsigned\n      (V : Uns;\n@@ -94,7 +71,7 @@ package System.Image_U is\n        and then S'Last < Integer'Last\n        and then S'Last >= Unsigned_Width_Ghost,\n      Post => P in S'Range\n-       and then Value_Unsigned (S (1 .. P)) = V;\n+       and then Uns_Params.Is_Value_Unsigned_Ghost (S (1 .. P), V);\n    pragma Inline (Image_Unsigned);\n    --  Computes Uns'Image (V) and stores the result in S (1 .. P) setting\n    --  the resulting value of P. The caller guarantees that S is long enough to\n@@ -112,9 +89,10 @@ package System.Image_U is\n        and then P <= S'Last - Unsigned_Width_Ghost + 1,\n      Post => S (S'First .. P'Old) = S'Old (S'First .. P'Old)\n        and then P in P'Old + 1 .. S'Last\n-       and then Only_Decimal_Ghost (S, From => P'Old + 1, To => P)\n-       and then Scan_Based_Number_Ghost (S, From => P'Old + 1, To => P)\n-         = Wrap_Option (V);\n+       and then Uns_Params.Only_Decimal_Ghost (S, From => P'Old + 1, To => P)\n+       and then Uns_Params.Scan_Based_Number_Ghost\n+         (S, From => P'Old + 1, To => P)\n+         = Uns_Params.Wrap_Option (V);\n    --  Stores the image of V in S starting at S (P + 1), P is updated to point\n    --  to the last character stored. The value stored is identical to the value\n    --  of Uns'Image (V) except that no leading space is stored. The caller"}, {"sha": "8672e58b083d6dad7021de9636cf46a726263f04", "filename": "gcc/ada/libgnat/s-imgint.ads", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imgint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imgint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgint.ads?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -48,36 +48,19 @@ pragma Assertion_Policy (Pre                => Ignore,\n with System.Image_I;\n with System.Unsigned_Types;\n with System.Val_Int;\n-with System.Val_Uns;\n-with System.Val_Util;\n with System.Wid_Uns;\n \n package System.Img_Int\n   with SPARK_Mode\n is\n    subtype Unsigned is Unsigned_Types.Unsigned;\n \n-   package Int_Params is new Val_Util.Int_Params\n-     (Int                                => Integer,\n-      Uns                                => Unsigned,\n-      Uns_Option                         => Val_Uns.Impl.Uns_Option,\n-      Unsigned_Width_Ghost               =>\n+   package Impl is new Image_I\n+     (Int                  => Integer,\n+      Uns                  => Unsigned,\n+      Unsigned_Width_Ghost =>\n          Wid_Uns.Width_Unsigned (0, Unsigned'Last),\n-      Only_Decimal_Ghost                 => Val_Uns.Impl.Only_Decimal_Ghost,\n-      Hexa_To_Unsigned_Ghost             =>\n-         Val_Uns.Impl.Hexa_To_Unsigned_Ghost,\n-      Wrap_Option                        => Val_Uns.Impl.Wrap_Option,\n-      Scan_Based_Number_Ghost            =>\n-         Val_Uns.Impl.Scan_Based_Number_Ghost,\n-      Prove_Iter_Scan_Based_Number_Ghost =>\n-         Val_Uns.Impl.Prove_Iter_Scan_Based_Number_Ghost,\n-      Is_Integer_Ghost                   => Val_Int.Impl.Is_Integer_Ghost,\n-      Prove_Scan_Only_Decimal_Ghost      =>\n-         Val_Int.Impl.Prove_Scan_Only_Decimal_Ghost,\n-      Abs_Uns_Of_Int                     => Val_Int.Impl.Abs_Uns_Of_Int,\n-      Value_Integer                      => Val_Int.Impl.Value_Integer);\n-\n-   package Impl is new Image_I (Int_Params);\n+      Int_Params           => System.Val_Int.Impl.Spec.Int_Params);\n \n    procedure Image_Integer\n      (V : Integer;"}, {"sha": "99c1951348d39e030178e6dc779c1a4da27d1cb5", "filename": "gcc/ada/libgnat/s-imglli.ads", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imglli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imglli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imglli.ads?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -48,36 +48,20 @@ pragma Assertion_Policy (Pre                => Ignore,\n with System.Image_I;\n with System.Unsigned_Types;\n with System.Val_LLI;\n-with System.Val_LLU;\n-with System.Val_Util;\n with System.Wid_LLU;\n \n package System.Img_LLI\n   with SPARK_Mode\n is\n    subtype Long_Long_Unsigned is Unsigned_Types.Long_Long_Unsigned;\n \n-   package Int_Params is new Val_Util.Int_Params\n-     (Int                                => Long_Long_Integer,\n-      Uns                                => Long_Long_Unsigned,\n-      Uns_Option                         => Val_LLU.Impl.Uns_Option,\n-      Unsigned_Width_Ghost               =>\n-         Wid_LLU.Width_Long_Long_Unsigned (0, Long_Long_Unsigned'Last),\n-      Only_Decimal_Ghost                 => Val_LLU.Impl.Only_Decimal_Ghost,\n-      Hexa_To_Unsigned_Ghost             =>\n-         Val_LLU.Impl.Hexa_To_Unsigned_Ghost,\n-      Wrap_Option                        => Val_LLU.Impl.Wrap_Option,\n-      Scan_Based_Number_Ghost            =>\n-         Val_LLU.Impl.Scan_Based_Number_Ghost,\n-      Prove_Iter_Scan_Based_Number_Ghost =>\n-         Val_LLU.Impl.Prove_Iter_Scan_Based_Number_Ghost,\n-      Is_Integer_Ghost                   => Val_LLI.Impl.Is_Integer_Ghost,\n-      Prove_Scan_Only_Decimal_Ghost      =>\n-         Val_LLI.Impl.Prove_Scan_Only_Decimal_Ghost,\n-      Abs_Uns_Of_Int                     => Val_LLI.Impl.Abs_Uns_Of_Int,\n-      Value_Integer                      => Val_LLI.Impl.Value_Integer);\n-\n-   package Impl is new Image_I (Int_Params);\n+   package Impl is new Image_I\n+     (Int                  => Long_Long_Integer,\n+      Uns                  => Long_Long_Unsigned,\n+      Unsigned_Width_Ghost =>\n+         Wid_LLU.Width_Long_Long_Unsigned\n+           (0, Long_Long_Unsigned'Last),\n+      Int_Params           => System.Val_LLI.Impl.Spec.Int_Params);\n \n    procedure Image_Long_Long_Integer\n      (V : Long_Long_Integer;"}, {"sha": "931c288d20e55157892de3c79101cdf11a76549d", "filename": "gcc/ada/libgnat/s-imgllli.ads", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imgllli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imgllli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgllli.ads?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -48,37 +48,20 @@ pragma Assertion_Policy (Pre                => Ignore,\n with System.Image_I;\n with System.Unsigned_Types;\n with System.Val_LLLI;\n-with System.Val_LLLU;\n-with System.Val_Util;\n with System.Wid_LLLU;\n \n package System.Img_LLLI\n   with SPARK_Mode\n is\n    subtype Long_Long_Long_Unsigned is Unsigned_Types.Long_Long_Long_Unsigned;\n \n-   package Int_Params is new Val_Util.Int_Params\n-     (Int                                => Long_Long_Long_Integer,\n-      Uns                                => Long_Long_Long_Unsigned,\n-      Uns_Option                         => Val_LLLU.Impl.Uns_Option,\n-      Unsigned_Width_Ghost               =>\n+   package Impl is new Image_I\n+     (Int                  => Long_Long_Long_Integer,\n+      Uns                  => Long_Long_Long_Unsigned,\n+      Unsigned_Width_Ghost =>\n          Wid_LLLU.Width_Long_Long_Long_Unsigned\n            (0, Long_Long_Long_Unsigned'Last),\n-      Only_Decimal_Ghost                 => Val_LLLU.Impl.Only_Decimal_Ghost,\n-      Hexa_To_Unsigned_Ghost             =>\n-         Val_LLLU.Impl.Hexa_To_Unsigned_Ghost,\n-      Wrap_Option                        => Val_LLLU.Impl.Wrap_Option,\n-      Scan_Based_Number_Ghost            =>\n-         Val_LLLU.Impl.Scan_Based_Number_Ghost,\n-      Prove_Iter_Scan_Based_Number_Ghost =>\n-         Val_LLLU.Impl.Prove_Iter_Scan_Based_Number_Ghost,\n-      Is_Integer_Ghost                   => Val_LLLI.Impl.Is_Integer_Ghost,\n-      Prove_Scan_Only_Decimal_Ghost      =>\n-         Val_LLLI.Impl.Prove_Scan_Only_Decimal_Ghost,\n-      Abs_Uns_Of_Int                     => Val_LLLI.Impl.Abs_Uns_Of_Int,\n-      Value_Integer                      => Val_LLLI.Impl.Value_Integer);\n-\n-   package Impl is new Image_I (Int_Params);\n+      Int_Params           => System.Val_LLLI.Impl.Spec.Int_Params);\n \n    procedure Image_Long_Long_Long_Integer\n      (V : Long_Long_Long_Integer;"}, {"sha": "53b39a8fdd22af1f32285a4042c17bba64db0560", "filename": "gcc/ada/libgnat/s-imglllu.ads", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imglllu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imglllu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imglllu.ads?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -56,23 +56,11 @@ is\n    subtype Long_Long_Long_Unsigned is Unsigned_Types.Long_Long_Long_Unsigned;\n \n    package Impl is new Image_U\n-     (Uns                                => Long_Long_Long_Unsigned,\n-      Uns_Option                         => Val_LLLU.Impl.Uns_Option,\n-      Unsigned_Width_Ghost               =>\n+     (Uns                  => Long_Long_Long_Unsigned,\n+      Unsigned_Width_Ghost =>\n          Wid_LLLU.Width_Long_Long_Long_Unsigned\n         (0, Long_Long_Long_Unsigned'Last),\n-      Only_Decimal_Ghost                 => Val_LLLU.Impl.Only_Decimal_Ghost,\n-      Hexa_To_Unsigned_Ghost             =>\n-         Val_LLLU.Impl.Hexa_To_Unsigned_Ghost,\n-      Wrap_Option                        => Val_LLLU.Impl.Wrap_Option,\n-      Scan_Based_Number_Ghost            =>\n-         Val_LLLU.Impl.Scan_Based_Number_Ghost,\n-      Is_Unsigned_Ghost                  => Val_LLLU.Impl.Is_Unsigned_Ghost,\n-      Value_Unsigned                     => Val_LLLU.Impl.Value_Unsigned,\n-      Prove_Iter_Scan_Based_Number_Ghost =>\n-         Val_LLLU.Impl.Prove_Iter_Scan_Based_Number_Ghost,\n-      Prove_Scan_Only_Decimal_Ghost      =>\n-         Val_LLLU.Impl.Prove_Scan_Only_Decimal_Ghost);\n+      Uns_Params           => System.Val_LLLU.Impl.Spec.Uns_Params);\n \n    procedure Image_Long_Long_Long_Unsigned\n      (V : Long_Long_Long_Unsigned;"}, {"sha": "28339cd7afe451aafd398ad5b52f45634921eb09", "filename": "gcc/ada/libgnat/s-imgllu.ads", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imgllu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imgllu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgllu.ads?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -56,22 +56,10 @@ is\n    subtype Long_Long_Unsigned is Unsigned_Types.Long_Long_Unsigned;\n \n    package Impl is new Image_U\n-     (Uns                                => Long_Long_Unsigned,\n-      Uns_Option                         => Val_LLU.Impl.Uns_Option,\n-      Unsigned_Width_Ghost               =>\n+     (Uns                  => Long_Long_Unsigned,\n+      Unsigned_Width_Ghost =>\n          Wid_LLU.Width_Long_Long_Unsigned (0, Long_Long_Unsigned'Last),\n-      Only_Decimal_Ghost                 => Val_LLU.Impl.Only_Decimal_Ghost,\n-      Hexa_To_Unsigned_Ghost             =>\n-         Val_LLU.Impl.Hexa_To_Unsigned_Ghost,\n-      Wrap_Option                        => Val_LLU.Impl.Wrap_Option,\n-      Scan_Based_Number_Ghost            =>\n-         Val_LLU.Impl.Scan_Based_Number_Ghost,\n-      Is_Unsigned_Ghost                  => Val_LLU.Impl.Is_Unsigned_Ghost,\n-      Value_Unsigned                     => Val_LLU.Impl.Value_Unsigned,\n-      Prove_Iter_Scan_Based_Number_Ghost =>\n-         Val_LLU.Impl.Prove_Iter_Scan_Based_Number_Ghost,\n-      Prove_Scan_Only_Decimal_Ghost      =>\n-         Val_LLU.Impl.Prove_Scan_Only_Decimal_Ghost);\n+      Uns_Params           => System.Val_LLU.Impl.Spec.Uns_Params);\n \n    procedure Image_Long_Long_Unsigned\n      (V : Long_Long_Unsigned;"}, {"sha": "120bd5db7df171fb84da46e052c65f2c803a3b00", "filename": "gcc/ada/libgnat/s-imguns.ads", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imguns.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-imguns.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imguns.ads?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -56,22 +56,10 @@ is\n    subtype Unsigned is Unsigned_Types.Unsigned;\n \n    package Impl is new Image_U\n-     (Uns                                => Unsigned,\n-      Uns_Option                         => Val_Uns.Impl.Uns_Option,\n-      Unsigned_Width_Ghost               =>\n+     (Uns                  => Unsigned,\n+      Unsigned_Width_Ghost =>\n          Wid_Uns.Width_Unsigned (0, Unsigned'Last),\n-      Only_Decimal_Ghost                 => Val_Uns.Impl.Only_Decimal_Ghost,\n-      Hexa_To_Unsigned_Ghost             =>\n-         Val_Uns.Impl.Hexa_To_Unsigned_Ghost,\n-      Wrap_Option                        => Val_Uns.Impl.Wrap_Option,\n-      Scan_Based_Number_Ghost            =>\n-         Val_Uns.Impl.Scan_Based_Number_Ghost,\n-      Is_Unsigned_Ghost                  => Val_Uns.Impl.Is_Unsigned_Ghost,\n-      Value_Unsigned                     => Val_Uns.Impl.Value_Unsigned,\n-      Prove_Iter_Scan_Based_Number_Ghost =>\n-         Val_Uns.Impl.Prove_Iter_Scan_Based_Number_Ghost,\n-      Prove_Scan_Only_Decimal_Ghost      =>\n-         Val_Uns.Impl.Prove_Scan_Only_Decimal_Ghost);\n+      Uns_Params           => System.Val_Uns.Impl.Spec.Uns_Params);\n \n    procedure Image_Unsigned\n      (V : Unsigned;"}, {"sha": "dca2fd782f5adfb8d4653f90e33c74890036ac33", "filename": "gcc/ada/libgnat/s-vaispe.adb", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-vaispe.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-vaispe.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vaispe.adb?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -0,0 +1,87 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                   S Y S T E M . V A L U E _ I _ S P E C                  --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2022-2022, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Assertion_Policy (Pre                => Ignore,\n+                         Post               => Ignore,\n+                         Contract_Cases     => Ignore,\n+                         Ghost              => Ignore,\n+                         Subprogram_Variant => Ignore);\n+\n+package body System.Value_I_Spec is\n+\n+   -----------------------------------\n+   -- Prove_Scan_Only_Decimal_Ghost --\n+   -----------------------------------\n+\n+   procedure Prove_Scan_Only_Decimal_Ghost (Str : String; Val : Int) is\n+      Non_Blank : constant Positive := First_Non_Space_Ghost\n+        (Str, Str'First, Str'Last);\n+      pragma Assert (Str (Str'First + 1) /= ' ');\n+      pragma Assert\n+        (if Val < 0 then Non_Blank = Str'First\n+         else\n+           Str (Str'First) = ' '\n+            and then Non_Blank = Str'First + 1);\n+      Minus     : constant Boolean := Str (Non_Blank) = '-';\n+      Fst_Num   : constant Positive :=\n+        (if Minus then Non_Blank + 1 else Non_Blank);\n+      pragma Assert (Fst_Num = Str'First + 1);\n+      Uval      : constant Uns := Abs_Uns_Of_Int (Val);\n+\n+      procedure Prove_Conversion_Is_Identity (Val : Int; Uval : Uns)\n+      with\n+        Pre  => Minus = (Val < 0)\n+          and then Uval = Abs_Uns_Of_Int (Val),\n+        Post => Uns_Is_Valid_Int (Minus, Uval)\n+          and then Is_Int_Of_Uns (Minus, Uval, Val);\n+      --  Local proof of the unicity of the signed representation\n+\n+      procedure Prove_Conversion_Is_Identity (Val : Int; Uval : Uns) is null;\n+\n+   --  Start of processing for Prove_Scan_Only_Decimal_Ghost\n+\n+   begin\n+      Prove_Conversion_Is_Identity (Val, Uval);\n+      pragma Assert\n+        (Uns_Params.Is_Raw_Unsigned_Format_Ghost (Str (Fst_Num .. Str'Last)));\n+      pragma Assert\n+        (Uns_Params.Scan_Split_No_Overflow_Ghost (Str, Fst_Num, Str'Last));\n+      Uns_Params.Lemma_Exponent_Unsigned_Ghost_Base (Uval, 0, 10);\n+      pragma Assert\n+        (Uns_Params.Raw_Unsigned_No_Overflow_Ghost (Str, Fst_Num, Str'Last));\n+      pragma Assert (Only_Space_Ghost\n+        (Str, Uns_Params.Raw_Unsigned_Last_Ghost\n+                        (Str, Fst_Num, Str'Last), Str'Last));\n+      pragma Assert (Is_Integer_Ghost (Str));\n+      pragma Assert (Is_Value_Integer_Ghost (Str, Val));\n+   end Prove_Scan_Only_Decimal_Ghost;\n+\n+end System.Value_I_Spec;"}, {"sha": "5a5e051620ab783a990665992a604b55054d75e5", "filename": "gcc/ada/libgnat/s-vaispe.ads", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-vaispe.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-vaispe.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vaispe.ads?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -0,0 +1,199 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                   S Y S T E M . V A L U E _ I _ S P E C                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2022-2022, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the specification entities using for the formal\n+--  verification of the routines for scanning signed integer values.\n+\n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre                => Ignore,\n+                         Post               => Ignore,\n+                         Contract_Cases     => Ignore,\n+                         Ghost              => Ignore,\n+                         Subprogram_Variant => Ignore);\n+\n+with System.Val_Util; use System.Val_Util;\n+\n+generic\n+\n+   type Int is range <>;\n+\n+   type Uns is mod <>;\n+\n+   --  Additional parameters for specification subprograms on modular Unsigned\n+   --  integers.\n+\n+   with package Uns_Params is new System.Val_Util.Uns_Params\n+     (Uns => Uns, others => <>)\n+   with Ghost;\n+\n+package System.Value_I_Spec with\n+   Ghost,\n+   SPARK_Mode,\n+   Annotate => (GNATprove, Always_Return)\n+is\n+   pragma Preelaborate;\n+   use all type Uns_Params.Uns_Option;\n+\n+   function Uns_Is_Valid_Int (Minus : Boolean; Uval : Uns) return Boolean is\n+     (if Minus then Uval <= Uns (Int'Last) + 1\n+      else Uval <= Uns (Int'Last))\n+   with Post => True;\n+   --  Return True if Uval (or -Uval when Minus is True) is a valid number of\n+   --  type Int.\n+\n+   function Is_Int_Of_Uns\n+     (Minus : Boolean;\n+      Uval  : Uns;\n+      Val   : Int)\n+      return Boolean\n+   is\n+     (if Minus and then Uval = Uns (Int'Last) + 1 then Val = Int'First\n+      elsif Minus then Val = -(Int (Uval))\n+      else Val = Int (Uval))\n+   with\n+     Pre  => Uns_Is_Valid_Int (Minus, Uval),\n+     Post => True;\n+   --  Return True if Uval (or -Uval when Minus is True) is equal to Val\n+\n+   function Abs_Uns_Of_Int (Val : Int) return Uns is\n+     (if Val = Int'First then Uns (Int'Last) + 1\n+      elsif Val < 0 then Uns (-Val)\n+      else Uns (Val));\n+   --  Return the unsigned absolute value of Val\n+\n+   function Slide_To_1 (Str : String) return String\n+   with\n+     Post =>\n+       Only_Space_Ghost (Str, Str'First, Str'Last) =\n+         (for all J in Str'First .. Str'Last =>\n+            Slide_To_1'Result (J - Str'First + 1) = ' ');\n+   --  Slides Str so that it starts at 1\n+\n+   function Slide_If_Necessary (Str : String) return String is\n+     (if Str'Last = Positive'Last then Slide_To_1 (Str) else Str);\n+   --  If Str'Last = Positive'Last then slides Str so that it starts at 1\n+\n+   function Is_Integer_Ghost (Str : String) return Boolean is\n+     (declare\n+        Non_Blank : constant Positive := First_Non_Space_Ghost\n+          (Str, Str'First, Str'Last);\n+        Fst_Num   : constant Positive :=\n+          (if Str (Non_Blank) in '+' | '-' then Non_Blank + 1 else Non_Blank);\n+      begin\n+        Uns_Params.Is_Raw_Unsigned_Format_Ghost (Str (Fst_Num .. Str'Last))\n+          and then Uns_Params.Raw_Unsigned_No_Overflow_Ghost\n+             (Str, Fst_Num, Str'Last)\n+          and then\n+            Uns_Is_Valid_Int\n+              (Minus => Str (Non_Blank) = '-',\n+               Uval  => Uns_Params.Scan_Raw_Unsigned_Ghost\n+                 (Str, Fst_Num, Str'Last))\n+          and then Only_Space_Ghost\n+            (Str, Uns_Params.Raw_Unsigned_Last_Ghost\n+             (Str, Fst_Num, Str'Last), Str'Last))\n+   with\n+     Pre => not Only_Space_Ghost (Str, Str'First, Str'Last)\n+       and then Str'Last /= Positive'Last,\n+     Post => True;\n+   --  Ghost function that determines if Str has the correct format for a\n+   --  signed number, consisting in some blank characters, an optional\n+   --  sign, a raw unsigned number which does not overflow and then some\n+   --  more blank characters.\n+\n+   function Is_Value_Integer_Ghost (Str : String; Val : Int) return Boolean is\n+     (declare\n+        Non_Blank : constant Positive := First_Non_Space_Ghost\n+          (Str, Str'First, Str'Last);\n+        Fst_Num   : constant Positive :=\n+          (if Str (Non_Blank) in '+' | '-' then Non_Blank + 1 else Non_Blank);\n+        Uval      : constant Uns :=\n+          Uns_Params.Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Str'Last);\n+      begin\n+        Is_Int_Of_Uns (Minus => Str (Non_Blank) = '-',\n+                       Uval  => Uval,\n+                       Val   => Val))\n+   with\n+     Pre => not Only_Space_Ghost (Str, Str'First, Str'Last)\n+       and then Str'Last /= Positive'Last\n+       and then Is_Integer_Ghost (Str),\n+     Post => True;\n+   --  Ghost function that returns True if Val is the value corresponding to\n+   --  the signed number represented by Str.\n+\n+   procedure Prove_Scan_Only_Decimal_Ghost (Str : String; Val : Int)\n+   with\n+     Ghost,\n+     Pre  => Str'Last /= Positive'Last\n+       and then Str'Length >= 2\n+       and then Str (Str'First) in ' ' | '-'\n+       and then (Str (Str'First) = '-') = (Val < 0)\n+       and then Uns_Params.Only_Decimal_Ghost (Str, Str'First + 1, Str'Last)\n+       and then Uns_Params.Scan_Based_Number_Ghost\n+         (Str, Str'First + 1, Str'Last)\n+         = Uns_Params.Wrap_Option (Abs_Uns_Of_Int (Val)),\n+     Post => Is_Integer_Ghost (Slide_If_Necessary (Str))\n+       and then Is_Value_Integer_Ghost (Str, Val);\n+   --  Ghost lemma used in the proof of 'Image implementation, to prove that\n+   --  the result of Value_Integer on a decimal string is the same as the\n+   --  signing the result of Scan_Based_Number_Ghost.\n+\n+   --  Bundle Int type with other types, constants and subprograms used in\n+   --  ghost code, so that this package can be instantiated once and used\n+   --  multiple times as generic formal for a given Int type.\n+\n+   package Int_Params is new System.Val_Util.Int_Params\n+     (Uns                             => Uns,\n+      Int                             => Int,\n+      P_Uns_Params                    => Uns_Params,\n+      P_Is_Integer_Ghost              => Is_Integer_Ghost,\n+      P_Is_Value_Integer_Ghost        => Is_Value_Integer_Ghost,\n+      P_Is_Int_Of_Uns                 => Is_Int_Of_Uns,\n+      P_Abs_Uns_Of_Int                => Abs_Uns_Of_Int,\n+      P_Prove_Scan_Only_Decimal_Ghost => Prove_Scan_Only_Decimal_Ghost);\n+\n+private\n+\n+   ----------------\n+   -- Slide_To_1 --\n+   ----------------\n+\n+   function Slide_To_1 (Str : String) return String is\n+     (declare\n+        Res : constant String (1 .. Str'Length) := Str;\n+      begin\n+        Res);\n+\n+end System.Value_I_Spec;"}, {"sha": "3872d7cc7e12bc1ec38001ad2ef154f59d3243c0", "filename": "gcc/ada/libgnat/s-valint.ads", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-valint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-valint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valint.ads?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -54,23 +54,10 @@ package System.Val_Int with SPARK_Mode is\n    subtype Unsigned is Unsigned_Types.Unsigned;\n \n    package Impl is new Value_I\n-     (Int                          => Integer,\n-      Uns                          => Unsigned,\n-      Scan_Raw_Unsigned            => Val_Uns.Scan_Raw_Unsigned,\n-      Uns_Option                   => Val_Uns.Impl.Uns_Option,\n-      Wrap_Option                  => Val_Uns.Impl.Wrap_Option,\n-      Is_Raw_Unsigned_Format_Ghost =>\n-         Val_Uns.Impl.Is_Raw_Unsigned_Format_Ghost,\n-      Raw_Unsigned_Overflows_Ghost =>\n-         Val_Uns.Impl.Raw_Unsigned_Overflows_Ghost,\n-      Scan_Raw_Unsigned_Ghost      =>\n-         Val_Uns.Impl.Scan_Raw_Unsigned_Ghost,\n-      Raw_Unsigned_Last_Ghost      =>\n-         Val_Uns.Impl.Raw_Unsigned_Last_Ghost,\n-      Only_Decimal_Ghost           =>\n-         Val_Uns.Impl.Only_Decimal_Ghost,\n-      Scan_Based_Number_Ghost      =>\n-         Val_Uns.Impl.Scan_Based_Number_Ghost);\n+     (Int               => Integer,\n+      Uns               => Unsigned,\n+      Scan_Raw_Unsigned => Val_Uns.Scan_Raw_Unsigned,\n+      Uns_Params        => System.Val_Uns.Impl.Spec.Uns_Params);\n \n    procedure Scan_Integer\n      (Str : String;"}, {"sha": "85bf28203b588c8f07c004ef8a6196b3d5cf810b", "filename": "gcc/ada/libgnat/s-vallli.ads", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-vallli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-vallli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vallli.ads?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -54,24 +54,10 @@ package System.Val_LLI with SPARK_Mode is\n    subtype Long_Long_Unsigned is Unsigned_Types.Long_Long_Unsigned;\n \n    package Impl is new Value_I\n-     (Int                          => Long_Long_Integer,\n-      Uns                          => Long_Long_Unsigned,\n-      Scan_Raw_Unsigned            =>\n-         Val_LLU.Scan_Raw_Long_Long_Unsigned,\n-      Uns_Option                   => Val_LLU.Impl.Uns_Option,\n-      Wrap_Option                  => Val_LLU.Impl.Wrap_Option,\n-      Is_Raw_Unsigned_Format_Ghost =>\n-         Val_LLU.Impl.Is_Raw_Unsigned_Format_Ghost,\n-      Raw_Unsigned_Overflows_Ghost =>\n-         Val_LLU.Impl.Raw_Unsigned_Overflows_Ghost,\n-      Scan_Raw_Unsigned_Ghost      =>\n-         Val_LLU.Impl.Scan_Raw_Unsigned_Ghost,\n-      Raw_Unsigned_Last_Ghost      =>\n-         Val_LLU.Impl.Raw_Unsigned_Last_Ghost,\n-      Only_Decimal_Ghost           =>\n-         Val_LLU.Impl.Only_Decimal_Ghost,\n-      Scan_Based_Number_Ghost      =>\n-         Val_LLU.Impl.Scan_Based_Number_Ghost);\n+     (Int               => Long_Long_Integer,\n+      Uns               => Long_Long_Unsigned,\n+      Scan_Raw_Unsigned => Val_LLU.Scan_Raw_Long_Long_Unsigned,\n+      Uns_Params        => System.Val_LLU.Impl.Spec.Uns_Params);\n \n    procedure Scan_Long_Long_Integer\n      (Str  : String;"}, {"sha": "e53fb0b0357c1fac1c54df50862dbbef1a3a46af", "filename": "gcc/ada/libgnat/s-valllli.ads", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-valllli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-valllli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valllli.ads?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -54,24 +54,10 @@ package System.Val_LLLI with SPARK_Mode is\n    subtype Long_Long_Long_Unsigned is Unsigned_Types.Long_Long_Long_Unsigned;\n \n    package Impl is new Value_I\n-     (Int                          => Long_Long_Long_Integer,\n-      Uns                          => Long_Long_Long_Unsigned,\n-      Scan_Raw_Unsigned            =>\n-         Val_LLLU.Scan_Raw_Long_Long_Long_Unsigned,\n-      Uns_Option                   => Val_LLLU.Impl.Uns_Option,\n-      Wrap_Option                  => Val_LLLU.Impl.Wrap_Option,\n-      Is_Raw_Unsigned_Format_Ghost =>\n-         Val_LLLU.Impl.Is_Raw_Unsigned_Format_Ghost,\n-      Raw_Unsigned_Overflows_Ghost =>\n-         Val_LLLU.Impl.Raw_Unsigned_Overflows_Ghost,\n-      Scan_Raw_Unsigned_Ghost      =>\n-         Val_LLLU.Impl.Scan_Raw_Unsigned_Ghost,\n-      Raw_Unsigned_Last_Ghost      =>\n-         Val_LLLU.Impl.Raw_Unsigned_Last_Ghost,\n-      Only_Decimal_Ghost           =>\n-         Val_LLLU.Impl.Only_Decimal_Ghost,\n-      Scan_Based_Number_Ghost      =>\n-         Val_LLLU.Impl.Scan_Based_Number_Ghost);\n+     (Int               => Long_Long_Long_Integer,\n+      Uns               => Long_Long_Long_Unsigned,\n+      Scan_Raw_Unsigned => Val_LLLU.Scan_Raw_Long_Long_Long_Unsigned,\n+      Uns_Params        => System.Val_LLLU.Impl.Spec.Uns_Params);\n \n    procedure Scan_Long_Long_Long_Integer\n      (Str  : String;"}, {"sha": "51764b20c9d837d1f57de84fd8361100b4199563", "filename": "gcc/ada/libgnat/s-valuei.adb", "status": "modified", "additions": 37, "deletions": 58, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-valuei.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-valuei.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuei.adb?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -41,59 +41,6 @@ package body System.Value_I is\n                             Assert_And_Cut     => Ignore,\n                             Subprogram_Variant => Ignore);\n \n-   -----------------------------------\n-   -- Prove_Scan_Only_Decimal_Ghost --\n-   -----------------------------------\n-\n-   procedure Prove_Scan_Only_Decimal_Ghost (Str : String; Val : Int) is\n-      Non_Blank : constant Positive := First_Non_Space_Ghost\n-        (Str, Str'First, Str'Last);\n-      pragma Assert\n-        (if Val < 0 then Non_Blank = Str'First\n-         else\n-            Only_Space_Ghost (Str, Str'First, Str'First)\n-            and then Non_Blank = Str'First + 1);\n-      Minus : constant Boolean := Str (Non_Blank) = '-';\n-      Fst_Num   : constant Positive :=\n-        (if Minus then Non_Blank + 1 else Non_Blank);\n-      pragma Assert (Fst_Num = Str'First + 1);\n-      Uval      : constant Uns :=\n-        Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Str'Last);\n-\n-      procedure Unique_Int_Of_Uns (Val1, Val2 : Int)\n-      with\n-        Pre  => Uns_Is_Valid_Int (Minus, Uval)\n-          and then Is_Int_Of_Uns (Minus, Uval, Val1)\n-          and then Is_Int_Of_Uns (Minus, Uval, Val2),\n-        Post => Val1 = Val2;\n-      --  Local proof of the unicity of the signed representation\n-\n-      procedure Unique_Int_Of_Uns (Val1, Val2 : Int) is null;\n-\n-   --  Start of processing for Prove_Scan_Only_Decimal_Ghost\n-\n-   begin\n-      pragma Assert (Minus = (Val < 0));\n-      pragma Assert (Uval = Abs_Uns_Of_Int (Val));\n-      pragma Assert (if Minus then Uval <= Uns (Int'Last) + 1\n-                     else Uval <= Uns (Int'Last));\n-      pragma Assert (Uns_Is_Valid_Int (Minus, Uval));\n-      pragma Assert\n-        (if Minus and then Uval = Uns (Int'Last) + 1 then Val = Int'First\n-         elsif Minus then Val = -(Int (Uval))\n-         else Val = Int (Uval));\n-      pragma Assert (Is_Int_Of_Uns (Minus, Uval, Val));\n-      pragma Assert\n-        (Is_Raw_Unsigned_Format_Ghost (Str (Fst_Num .. Str'Last)));\n-      pragma Assert\n-        (not Raw_Unsigned_Overflows_Ghost (Str, Fst_Num, Str'Last));\n-      pragma Assert (Only_Space_Ghost\n-        (Str, Raw_Unsigned_Last_Ghost (Str, Fst_Num, Str'Last), Str'Last));\n-      pragma Assert (Is_Integer_Ghost (Str));\n-      pragma Assert (Is_Value_Integer_Ghost (Str, Val));\n-      Unique_Int_Of_Uns (Val, Value_Integer (Str));\n-   end Prove_Scan_Only_Decimal_Ghost;\n-\n    ------------------\n    -- Scan_Integer --\n    ------------------\n@@ -104,6 +51,25 @@ package body System.Value_I is\n       Max : Integer;\n       Res : out Int)\n    is\n+      procedure Prove_Is_Int_Of_Uns\n+        (Minus : Boolean;\n+         Uval  : Uns;\n+         Val   : Int)\n+      with Ghost,\n+        Pre => Spec.Uns_Is_Valid_Int (Minus, Uval)\n+          and then\n+            (if Minus and then Uval = Uns (Int'Last) + 1 then Val = Int'First\n+             elsif Minus then Val = -(Int (Uval))\n+             else Val = Int (Uval)),\n+        Post => Spec.Is_Int_Of_Uns (Minus, Uval, Val);\n+      --  Unfold the definition of Is_Int_Of_Uns\n+\n+      procedure Prove_Is_Int_Of_Uns\n+        (Minus : Boolean;\n+         Uval  : Uns;\n+         Val   : Int)\n+      is null;\n+\n       Uval : Uns;\n       --  Unsigned result\n \n@@ -131,7 +97,8 @@ package body System.Value_I is\n       end if;\n \n       Scan_Raw_Unsigned (Str, Ptr, Max, Uval);\n-      pragma Assert (Uval = Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Max));\n+      pragma Assert\n+        (Uval = Uns_Params.Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Max));\n \n       --  Deal with overflow cases, and also with largest negative number\n \n@@ -152,6 +119,11 @@ package body System.Value_I is\n       else\n          Res := Int (Uval);\n       end if;\n+\n+      Prove_Is_Int_Of_Uns\n+        (Minus => Str (Non_Blank) = '-',\n+         Uval  => Uval,\n+         Val   => Res);\n    end Scan_Integer;\n \n    -------------------\n@@ -167,7 +139,15 @@ package body System.Value_I is\n       if Str'Last = Positive'Last then\n          declare\n             subtype NT is String (1 .. Str'Length);\n+            procedure Prove_Is_Integer_Ghost with\n+              Ghost,\n+              Pre  => Str'Length < Natural'Last\n+              and then not Only_Space_Ghost (Str, Str'First, Str'Last)\n+              and then Spec.Is_Integer_Ghost (Spec.Slide_To_1 (Str)),\n+              Post => Spec.Is_Integer_Ghost (NT (Str));\n+            procedure Prove_Is_Integer_Ghost is null;\n          begin\n+            Prove_Is_Integer_Ghost;\n             return Value_Integer (NT (Str));\n          end;\n \n@@ -187,8 +167,6 @@ package body System.Value_I is\n                else Non_Blank)\n             with Ghost;\n          begin\n-            pragma Assert\n-              (Is_Raw_Unsigned_Format_Ghost (Str (Fst_Num .. Str'Last)));\n \n             declare\n                P_Acc : constant not null access Integer := P'Access;\n@@ -197,12 +175,13 @@ package body System.Value_I is\n             end;\n \n             pragma Assert\n-              (P = Raw_Unsigned_Last_Ghost (Str, Fst_Num, Str'Last));\n+              (P = Uns_Params.Raw_Unsigned_Last_Ghost\n+                 (Str, Fst_Num, Str'Last));\n \n             Scan_Trailing_Blanks (Str, P);\n \n             pragma Assert\n-              (Is_Value_Integer_Ghost (Slide_If_Necessary (Str), V));\n+              (Spec.Is_Value_Integer_Ghost (Spec.Slide_If_Necessary (Str), V));\n             return V;\n          end;\n       end if;"}, {"sha": "3f78db6ee4348cedd329fca1131fed1021953511", "filename": "gcc/ada/libgnat/s-valuei.ads", "status": "modified", "additions": 21, "deletions": 167, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-valuei.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-valuei.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuei.ads?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -39,6 +39,7 @@ pragma Assertion_Policy (Pre                => Ignore,\n                          Subprogram_Variant => Ignore);\n \n with System.Val_Util; use System.Val_Util;\n+with System.Value_I_Spec;\n \n generic\n \n@@ -54,71 +55,15 @@ generic\n \n    --  Additional parameters for ghost subprograms used inside contracts\n \n-   type Uns_Option is private;\n-   with function Wrap_Option (Value : Uns) return Uns_Option\n-      with Ghost;\n-   with function Is_Raw_Unsigned_Format_Ghost (Str : String) return Boolean\n-      with Ghost;\n-   with function Raw_Unsigned_Overflows_Ghost\n-     (Str      : String;\n-      From, To : Integer)\n-      return Boolean\n-      with Ghost;\n-   with function Scan_Raw_Unsigned_Ghost\n-     (Str      : String;\n-      From, To : Integer)\n-      return Uns\n-      with Ghost;\n-   with function Raw_Unsigned_Last_Ghost\n-     (Str      : String;\n-      From, To : Integer)\n-      return Positive\n-      with Ghost;\n-   with function Only_Decimal_Ghost\n-     (Str      : String;\n-      From, To : Integer)\n-      return Boolean\n-      with Ghost;\n-   with function Scan_Based_Number_Ghost\n-     (Str      : String;\n-      From, To : Integer;\n-      Base     : Uns := 10;\n-      Acc      : Uns := 0)\n-      return Uns_Option\n-      with Ghost;\n+   with package Uns_Params is new System.Val_Util.Uns_Params\n+     (Uns => Uns, others => <>)\n+   with Ghost;\n \n package System.Value_I is\n    pragma Preelaborate;\n+   use all type Uns_Params.Uns_Option;\n \n-   function Uns_Is_Valid_Int (Minus : Boolean; Uval : Uns) return Boolean is\n-     (if Minus then Uval <= Uns (Int'Last) + 1\n-      else Uval <= Uns (Int'Last))\n-   with Ghost,\n-     Post => True;\n-   --  Return True if Uval (or -Uval when Minus is True) is a valid number of\n-   --  type Int.\n-\n-   function Is_Int_Of_Uns\n-     (Minus : Boolean;\n-      Uval  : Uns;\n-      Val   : Int)\n-      return Boolean\n-   is\n-     (if Minus and then Uval = Uns (Int'Last) + 1 then Val = Int'First\n-      elsif Minus then Val = -(Int (Uval))\n-      else Val = Int (Uval))\n-   with\n-     Ghost,\n-     Pre  => Uns_Is_Valid_Int (Minus, Uval),\n-     Post => True;\n-   --  Return True if Uval (or -Uval when Minus is True) is equal to Val\n-\n-   function Abs_Uns_Of_Int (Val : Int) return Uns is\n-     (if Val = Int'First then Uns (Int'Last) + 1\n-      elsif Val < 0 then Uns (-Val)\n-      else Uns (Val))\n-   with Ghost;\n-   --  Return the unsigned absolute value of Val\n+   package Spec is new System.Value_I_Spec (Int, Uns, Uns_Params);\n \n    procedure Scan_Integer\n      (Str : String;\n@@ -139,11 +84,13 @@ package System.Value_I is\n               (if Str (Non_Blank) in '+' | '-' then Non_Blank + 1\n                else Non_Blank);\n           begin\n-            Is_Raw_Unsigned_Format_Ghost (Str (Fst_Num .. Max))\n-              and then not Raw_Unsigned_Overflows_Ghost (Str, Fst_Num, Max)\n-              and then Uns_Is_Valid_Int\n+            Uns_Params.Is_Raw_Unsigned_Format_Ghost (Str (Fst_Num .. Max))\n+              and then Uns_Params.Raw_Unsigned_No_Overflow_Ghost\n+                (Str, Fst_Num, Max)\n+              and then Spec.Uns_Is_Valid_Int\n                 (Minus => Str (Non_Blank) = '-',\n-                 Uval  => Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Max))),\n+                 Uval  => Uns_Params.Scan_Raw_Unsigned_Ghost\n+                   (Str, Fst_Num, Max))),\n     Post =>\n       (declare\n          Non_Blank : constant Positive := First_Non_Space_Ghost\n@@ -152,12 +99,13 @@ package System.Value_I is\n            (if Str (Non_Blank) in '+' | '-' then Non_Blank + 1\n             else Non_Blank);\n          Uval      : constant Uns :=\n-            Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Max);\n+            Uns_Params.Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Max);\n        begin\n-         Is_Int_Of_Uns (Minus => Str (Non_Blank) = '-',\n-                        Uval  => Uval,\n-                        Val   => Res)\n-           and then Ptr.all = Raw_Unsigned_Last_Ghost (Str, Fst_Num, Max));\n+           Spec.Is_Int_Of_Uns (Minus => Str (Non_Blank) = '-',\n+                               Uval  => Uval,\n+                               Val   => Res)\n+           and then Ptr.all = Uns_Params.Raw_Unsigned_Last_Ghost\n+             (Str, Fst_Num, Max));\n    --  This procedure scans the string starting at Str (Ptr.all) for a valid\n    --  integer according to the syntax described in (RM 3.5(43)). The substring\n    --  scanned extends no further than Str (Max). There are three cases for the\n@@ -183,111 +131,17 @@ package System.Value_I is\n    --  special case of an all-blank string, and Ptr is unchanged, and hence\n    --  is greater than Max as required in this case.\n \n-   function Slide_To_1 (Str : String) return String\n-   with\n-     Ghost,\n-     Post =>\n-       Only_Space_Ghost (Str, Str'First, Str'Last) =\n-         (for all J in Str'First .. Str'Last =>\n-            Slide_To_1'Result (J - Str'First + 1) = ' ');\n-   --  Slides Str so that it starts at 1\n-\n-   function Slide_If_Necessary (Str : String) return String is\n-     (if Str'Last = Positive'Last then Slide_To_1 (Str) else Str)\n-   with\n-     Ghost,\n-     Post =>\n-       Only_Space_Ghost (Str, Str'First, Str'Last) =\n-       Only_Space_Ghost (Slide_If_Necessary'Result,\n-                         Slide_If_Necessary'Result'First,\n-                         Slide_If_Necessary'Result'Last);\n-   --  If Str'Last = Positive'Last then slides Str so that it starts at 1\n-\n-   function Is_Integer_Ghost (Str : String) return Boolean is\n-     (declare\n-        Non_Blank : constant Positive := First_Non_Space_Ghost\n-          (Str, Str'First, Str'Last);\n-        Fst_Num   : constant Positive :=\n-          (if Str (Non_Blank) in '+' | '-' then Non_Blank + 1 else Non_Blank);\n-      begin\n-        Is_Raw_Unsigned_Format_Ghost (Str (Fst_Num .. Str'Last))\n-          and then not Raw_Unsigned_Overflows_Ghost (Str, Fst_Num, Str'Last)\n-          and then\n-            Uns_Is_Valid_Int\n-              (Minus => Str (Non_Blank) = '-',\n-               Uval  => Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Str'Last))\n-          and then Only_Space_Ghost\n-            (Str, Raw_Unsigned_Last_Ghost (Str, Fst_Num, Str'Last), Str'Last))\n-   with\n-     Ghost,\n-     Pre => not Only_Space_Ghost (Str, Str'First, Str'Last)\n-       and then Str'Last /= Positive'Last,\n-     Post => True;\n-   --  Ghost function that determines if Str has the correct format for a\n-   --  signed number, consisting in some blank characters, an optional\n-   --  sign, a raw unsigned number which does not overflow and then some\n-   --  more blank characters.\n-\n-   function Is_Value_Integer_Ghost (Str : String; Val : Int) return Boolean is\n-     (declare\n-        Non_Blank : constant Positive := First_Non_Space_Ghost\n-          (Str, Str'First, Str'Last);\n-        Fst_Num   : constant Positive :=\n-          (if Str (Non_Blank) in '+' | '-' then Non_Blank + 1 else Non_Blank);\n-        Uval      : constant Uns :=\n-          Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Str'Last);\n-      begin\n-        Is_Int_Of_Uns (Minus => Str (Non_Blank) = '-',\n-                       Uval  => Uval,\n-                       Val   => Val))\n-   with\n-     Ghost,\n-     Pre => not Only_Space_Ghost (Str, Str'First, Str'Last)\n-       and then Str'Last /= Positive'Last\n-       and then Is_Integer_Ghost (Str),\n-     Post => True;\n-   --  Ghost function that returns True if Val is the value corresponding to\n-   --  the signed number represented by Str.\n-\n    function Value_Integer (Str : String) return Int\n    with\n      Pre => not Only_Space_Ghost (Str, Str'First, Str'Last)\n        and then Str'Length /= Positive'Last\n-       and then Is_Integer_Ghost (Slide_If_Necessary (Str)),\n-     Post => Is_Value_Integer_Ghost\n-       (Slide_If_Necessary (Str), Value_Integer'Result),\n+       and then Spec.Is_Integer_Ghost (Spec.Slide_If_Necessary (Str)),\n+     Post => Spec.Is_Value_Integer_Ghost\n+       (Spec.Slide_If_Necessary (Str), Value_Integer'Result),\n      Subprogram_Variant => (Decreases => Str'First);\n    --  Used in computing X'Value (Str) where X is a signed integer type whose\n    --  base range does not exceed the base range of Integer. Str is the string\n    --  argument of the attribute. Constraint_Error is raised if the string is\n    --  malformed, or if the value is out of range.\n \n-   procedure Prove_Scan_Only_Decimal_Ghost (Str : String; Val : Int)\n-   with\n-     Ghost,\n-     Pre  => Str'Last /= Positive'Last\n-       and then Str'Length >= 2\n-       and then Str (Str'First) in ' ' | '-'\n-       and then (Str (Str'First) = '-') = (Val < 0)\n-       and then Only_Decimal_Ghost (Str, Str'First + 1, Str'Last)\n-       and then Scan_Based_Number_Ghost (Str, Str'First + 1, Str'Last)\n-         = Wrap_Option (Abs_Uns_Of_Int (Val)),\n-     Post => Is_Integer_Ghost (Slide_If_Necessary (Str))\n-       and then Value_Integer (Str) = Val;\n-   --  Ghost lemma used in the proof of 'Image implementation, to prove that\n-   --  the result of Value_Integer on a decimal string is the same as the\n-   --  signing the result of Scan_Based_Number_Ghost.\n-\n-private\n-\n-   ----------------\n-   -- Slide_To_1 --\n-   ----------------\n-\n-   function Slide_To_1 (Str : String) return String is\n-     (declare\n-        Res : constant String (1 .. Str'Length) := Str;\n-      begin\n-        Res);\n-\n end System.Value_I;"}, {"sha": "8f19086508bce002d96df1527ae671313d2927b4", "filename": "gcc/ada/libgnat/s-valueu.adb", "status": "modified", "additions": 127, "deletions": 317, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-valueu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-valueu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valueu.adb?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -41,9 +41,12 @@ package body System.Value_U is\n                             Assert_And_Cut     => Ignore,\n                             Subprogram_Variant => Ignore);\n \n+   use type Spec.Uns_Option;\n+   use type Spec.Split_Value_Ghost;\n+\n    --  Local lemmas\n \n-   procedure Lemma_Digit_Is_Before_Last\n+   procedure Lemma_Digit_Not_Last\n      (Str  : String;\n       P    : Integer;\n       From : Integer;\n@@ -54,257 +57,47 @@ package body System.Value_U is\n        and then To in From .. Str'Last\n        and then Str (From) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F'\n        and then P in From .. To\n-       and then Str (P) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F',\n-     Post => P /= Last_Hexa_Ghost (Str (From .. To)) + 1;\n-   --  If the character at position P is a digit, P cannot be the position of\n-   --  of the first non-digit in Str.\n+       and then P <= Spec.Last_Hexa_Ghost (Str (From .. To)) + 1\n+       and then Spec.Is_Based_Format_Ghost (Str (From .. To)),\n+     Post =>\n+       (if Str (P) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F'\n+        then P <= Spec.Last_Hexa_Ghost (Str (From .. To)));\n \n-   procedure Lemma_End_Of_Scan\n+   procedure Lemma_Underscore_Not_Last\n      (Str  : String;\n+      P    : Integer;\n       From : Integer;\n-      To   : Integer;\n-      Base : Uns;\n-      Acc  : Uns)\n-   with Ghost,\n-     Pre  => Str'Last /= Positive'Last and then From > To,\n-     Post => Scan_Based_Number_Ghost (Str, From, To, Base, Acc) =\n-       (False, Acc);\n-   --  Unfold the definition of Scan_Based_Number_Ghost on an empty string\n-\n-   procedure Lemma_Scan_Digit\n-     (Str          : String;\n-      P            : Integer;\n-      Lst          : Integer;\n-      Digit        : Uns;\n-      Base         : Uns;\n-      Old_Acc      : Uns;\n-      Acc          : Uns;\n-      Scan_Val     : Uns_Option;\n-      Old_Overflow : Boolean;\n-      Overflow     : Boolean)\n-   with Ghost,\n-     Pre  => Str'Last /= Positive'Last\n-       and then Lst in Str'Range\n-       and then P in Str'First .. Lst\n-       and then Str (P) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F'\n-       and then Digit = Hexa_To_Unsigned_Ghost (Str (P))\n-       and then Only_Hexa_Ghost (Str, P, Lst)\n-       and then Base in 2 .. 16\n-       and then (if Digit < Base and then Old_Acc <= Uns'Last / Base\n-                 then Acc = Base * Old_Acc + Digit)\n-       and then (if Digit >= Base\n-                   or else Old_Acc > Uns'Last / Base\n-                   or else (Old_Acc > (Uns'Last - Base + 1) / Base\n-                            and then Acc < Uns'Last / Base)\n-                 then Overflow\n-                 else Overflow = Old_Overflow)\n-       and then\n-         (if not Old_Overflow then\n-           Scan_Val = Scan_Based_Number_Ghost\n-              (Str, P, Lst, Base, Old_Acc)),\n-     Post =>\n-        (if not Overflow then\n-           Scan_Val = Scan_Based_Number_Ghost\n-             (Str, P + 1, Lst, Base, Acc))\n-       and then\n-        (if Overflow then Old_Overflow or else Scan_Val.Overflow);\n-   --  Unfold the definition of Scan_Based_Number_Ghost when the string starts\n-   --  with a digit.\n-\n-   procedure Lemma_Scan_Underscore\n-     (Str      : String;\n-      P        : Integer;\n-      From     : Integer;\n-      To       : Integer;\n-      Lst      : Integer;\n-      Base     : Uns;\n-      Acc      : Uns;\n-      Scan_Val : Uns_Option;\n-      Overflow : Boolean;\n-      Ext      : Boolean)\n+      To   : Integer)\n    with Ghost,\n      Pre  => Str'Last /= Positive'Last\n        and then From in Str'Range\n        and then To in From .. Str'Last\n-       and then Lst <= To\n-       and then P in From .. Lst + 1\n-       and then P <= To\n-       and then\n-         (if Ext then\n-            Is_Based_Format_Ghost (Str (From .. To))\n-            and then Lst = Last_Hexa_Ghost (Str (From .. To))\n-          else Is_Natural_Format_Ghost (Str (From .. To))\n-            and then Lst = Last_Number_Ghost (Str (From .. To)))\n+       and then Str (From) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F'\n+       and then P in From .. To\n        and then Str (P) = '_'\n-       and then\n-         (if not Overflow then\n-           Scan_Val = Scan_Based_Number_Ghost (Str, P, Lst, Base, Acc)),\n-     Post => P + 1 <= Lst\n-       and then\n-         (if Ext then Str (P + 1) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F'\n-          else Str (P + 1) in '0' .. '9')\n-       and then\n-         (if not Overflow then\n-           Scan_Val = Scan_Based_Number_Ghost (Str, P + 1, Lst, Base, Acc));\n-   --  Unfold the definition of Scan_Based_Number_Ghost when the string starts\n-   --  with an underscore.\n+       and then P <= Spec.Last_Hexa_Ghost (Str (From .. To)) + 1\n+       and then Spec.Is_Based_Format_Ghost (Str (From .. To)),\n+     Post => P + 1 <= Spec.Last_Hexa_Ghost (Str (From .. To))\n+       and then Str (P + 1) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F';\n \n    -----------------------------\n    -- Local lemma null bodies --\n    -----------------------------\n \n-   procedure Lemma_Digit_Is_Before_Last\n+   procedure Lemma_Digit_Not_Last\n      (Str  : String;\n       P    : Integer;\n       From : Integer;\n       To   : Integer)\n    is null;\n \n-   procedure Lemma_End_Of_Scan\n-     (Str          : String;\n-      From         : Integer;\n-      To           : Integer;\n-      Base         : Uns;\n-      Acc          : Uns)\n-   is null;\n-\n-   procedure Lemma_Scan_Underscore\n-     (Str      : String;\n-      P        : Integer;\n-      From     : Integer;\n-      To       : Integer;\n-      Lst      : Integer;\n-      Base     : Uns;\n-      Acc      : Uns;\n-      Scan_Val : Uns_Option;\n-      Overflow : Boolean;\n-      Ext      : Boolean)\n+   procedure Lemma_Underscore_Not_Last\n+     (Str  : String;\n+      P    : Integer;\n+      From : Integer;\n+      To   : Integer)\n    is null;\n \n-   ---------------------\n-   -- Last_Hexa_Ghost --\n-   ---------------------\n-\n-   function Last_Hexa_Ghost (Str : String) return Positive is\n-   begin\n-      for J in Str'Range loop\n-         if Str (J) not in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' | '_' then\n-            return J - 1;\n-         end if;\n-\n-         pragma Loop_Invariant\n-           (for all K in Str'First .. J =>\n-              Str (K) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' | '_');\n-      end loop;\n-\n-      return Str'Last;\n-   end Last_Hexa_Ghost;\n-\n-   ----------------------\n-   -- Lemma_Scan_Digit --\n-   ----------------------\n-\n-   procedure Lemma_Scan_Digit\n-     (Str          : String;\n-      P            : Integer;\n-      Lst          : Integer;\n-      Digit        : Uns;\n-      Base         : Uns;\n-      Old_Acc      : Uns;\n-      Acc          : Uns;\n-      Scan_Val     : Uns_Option;\n-      Old_Overflow : Boolean;\n-      Overflow     : Boolean)\n-   is\n-      pragma Unreferenced (Str, P, Lst, Scan_Val, Overflow, Old_Overflow);\n-   begin\n-      if Digit >= Base then\n-         null;\n-\n-      elsif Old_Acc <= (Uns'Last - Base + 1) / Base then\n-         pragma Assert (not Scan_Overflows_Ghost (Digit, Base, Old_Acc));\n-\n-      elsif Old_Acc > Uns'Last / Base then\n-         null;\n-\n-      else\n-         pragma Assert\n-           ((Acc < Uns'Last / Base) =\n-              Scan_Overflows_Ghost (Digit, Base, Old_Acc));\n-      end if;\n-   end Lemma_Scan_Digit;\n-\n-   ----------------------------------------\n-   -- Prove_Iter_Scan_Based_Number_Ghost --\n-   ----------------------------------------\n-\n-   procedure Prove_Iter_Scan_Based_Number_Ghost\n-     (Str1, Str2 : String;\n-      From, To : Integer;\n-      Base     : Uns := 10;\n-      Acc      : Uns := 0)\n-   is\n-   begin\n-      if From > To then\n-         null;\n-      elsif Str1 (From) = '_' then\n-         Prove_Iter_Scan_Based_Number_Ghost\n-           (Str1, Str2, From + 1, To, Base, Acc);\n-      elsif Scan_Overflows_Ghost\n-        (Hexa_To_Unsigned_Ghost (Str1 (From)), Base, Acc)\n-      then\n-         null;\n-      else\n-         Prove_Iter_Scan_Based_Number_Ghost\n-           (Str1, Str2, From + 1, To, Base,\n-            Base * Acc + Hexa_To_Unsigned_Ghost (Str1 (From)));\n-      end if;\n-   end Prove_Iter_Scan_Based_Number_Ghost;\n-\n-   -----------------------------------\n-   -- Prove_Scan_Only_Decimal_Ghost --\n-   -----------------------------------\n-\n-   procedure Prove_Scan_Only_Decimal_Ghost\n-     (Str : String;\n-      Val : Uns)\n-   is\n-      Non_Blank : constant Positive := First_Non_Space_Ghost\n-        (Str, Str'First, Str'Last);\n-      pragma Assert (Non_Blank = Str'First + 1);\n-      Fst_Num   : constant Positive :=\n-        (if Str (Non_Blank) = '+' then Non_Blank + 1 else Non_Blank);\n-      pragma Assert (Fst_Num = Str'First + 1);\n-      Last_Num_Init   : constant Integer :=\n-        Last_Number_Ghost (Str (Str'First + 1 .. Str'Last));\n-      pragma Assert (Last_Num_Init = Str'Last);\n-      Starts_As_Based : constant Boolean :=\n-        Last_Num_Init < Str'Last - 1\n-        and then Str (Last_Num_Init + 1) in '#' | ':'\n-        and then Str (Last_Num_Init + 2) in\n-          '0' .. '9' | 'a' .. 'f' | 'A' .. 'F';\n-      pragma Assert (Starts_As_Based = False);\n-      Last_Num_Based  : constant Integer :=\n-        (if Starts_As_Based\n-         then Last_Hexa_Ghost (Str (Last_Num_Init + 2 .. Str'Last))\n-         else Last_Num_Init);\n-      pragma Assert (Last_Num_Based = Str'Last);\n-   begin\n-      pragma Assert\n-        (Is_Opt_Exponent_Format_Ghost (Str (Str'Last + 1 .. Str'Last)));\n-      pragma Assert\n-        (Is_Natural_Format_Ghost (Str (Str'First + 1 .. Str'Last)));\n-      pragma Assert\n-        (Is_Raw_Unsigned_Format_Ghost (Str (Str'First + 1 .. Str'Last)));\n-      pragma Assert\n-        (not Raw_Unsigned_Overflows_Ghost (Str, Str'First + 1, Str'Last));\n-      pragma Assert (Val = Exponent_Unsigned_Ghost (Val, 0, 10).Value);\n-      pragma Assert\n-        (Val = Scan_Raw_Unsigned_Ghost (Str, Str'First + 1, Str'Last));\n-      pragma Assert (Is_Unsigned_Ghost (Str));\n-      pragma Assert (Is_Value_Unsigned_Ghost (Str, Val));\n-   end Prove_Scan_Only_Decimal_Ghost;\n-\n    -----------------------\n    -- Scan_Raw_Unsigned --\n    -----------------------\n@@ -341,8 +134,8 @@ package body System.Value_U is\n       Last_Num_Init : constant Integer :=\n         Last_Number_Ghost (Str (Ptr.all .. Max))\n       with Ghost;\n-      Init_Val      : constant Uns_Option :=\n-        Scan_Based_Number_Ghost (Str, Ptr.all, Last_Num_Init)\n+      Init_Val      : constant Spec.Uns_Option :=\n+        Spec.Scan_Based_Number_Ghost (Str, Ptr.all, Last_Num_Init)\n       with Ghost;\n       Starts_As_Based : constant Boolean :=\n         Last_Num_Init < Max - 1\n@@ -352,17 +145,17 @@ package body System.Value_U is\n       with Ghost;\n       Last_Num_Based  : constant Integer :=\n         (if Starts_As_Based\n-         then Last_Hexa_Ghost (Str (Last_Num_Init + 2 .. Max))\n+         then Spec.Last_Hexa_Ghost (Str (Last_Num_Init + 2 .. Max))\n          else Last_Num_Init)\n       with Ghost;\n       Is_Based        : constant Boolean :=\n         Starts_As_Based\n         and then Last_Num_Based < Max\n         and then Str (Last_Num_Based + 1) = Str (Last_Num_Init + 1)\n       with Ghost;\n-      Based_Val       : constant Uns_Option :=\n+      Based_Val       : constant Spec.Uns_Option :=\n         (if Starts_As_Based and then not Init_Val.Overflow\n-         then Scan_Based_Number_Ghost\n+         then Spec.Scan_Based_Number_Ghost\n            (Str, Last_Num_Init + 2, Last_Num_Based, Init_Val.Value)\n          else Init_Val)\n       with Ghost;\n@@ -379,6 +172,7 @@ package body System.Value_U is\n       end if;\n \n       P := Ptr.all;\n+      Spec.Lemma_Scan_Based_Number_Ghost_Step (Str, P, Last_Num_Init);\n       Uval := Character'Pos (Str (P)) - Character'Pos ('0');\n       P := P + 1;\n \n@@ -392,9 +186,6 @@ package body System.Value_U is\n          Umax10 : constant Uns := Uns'Last / 10;\n          --  Numbers bigger than Umax10 overflow if multiplied by 10\n \n-         Old_Uval     : Uns with Ghost;\n-         Old_Overflow : Boolean with Ghost;\n-\n       begin\n          --  Loop through decimal digits\n          loop\n@@ -403,7 +194,7 @@ package body System.Value_U is\n               (if Overflow then Init_Val.Overflow);\n             pragma Loop_Invariant\n               (if not Overflow\n-               then Init_Val = Scan_Based_Number_Ghost\n+               then Init_Val = Spec.Scan_Based_Number_Ghost\n                  (Str, P, Last_Num_Init, Acc => Uval));\n \n             exit when P > Max;\n@@ -414,9 +205,8 @@ package body System.Value_U is\n \n             if Digit > 9 then\n                if Str (P) = '_' then\n-                  Lemma_Scan_Underscore\n-                    (Str, P, Ptr_Old, Max, Last_Num_Init, 10, Uval,\n-                     Init_Val, Overflow, False);\n+                  Spec.Lemma_Scan_Based_Number_Ghost_Underscore\n+                    (Str, P, Last_Num_Init, Acc => Uval);\n                   Scan_Underscore (Str, P, Ptr, Max, False);\n                else\n                   exit;\n@@ -425,11 +215,19 @@ package body System.Value_U is\n             --  Accumulate result, checking for overflow\n \n             else\n-               Old_Uval := Uval;\n-               Old_Overflow := Overflow;\n+               Spec.Lemma_Scan_Based_Number_Ghost_Step\n+                 (Str, P, Last_Num_Init, Acc => Uval);\n+               Spec.Lemma_Scan_Based_Number_Ghost_Overflow\n+                 (Str, P, Last_Num_Init, Acc => Uval);\n \n                if Uval <= Umax then\n+                  pragma Assert\n+                    (Spec.Hexa_To_Unsigned_Ghost (Str (P)) = Digit);\n                   Uval := 10 * Uval + Digit;\n+                  pragma Assert\n+                    (if not Overflow\n+                     then Init_Val = Spec.Scan_Based_Number_Ghost\n+                       (Str, P + 1, Last_Num_Init, Acc => Uval));\n \n                elsif Uval > Umax10 then\n                   Overflow := True;\n@@ -440,17 +238,17 @@ package body System.Value_U is\n                   if Uval < Umax10 then\n                      Overflow := True;\n                   end if;\n+                  pragma Assert\n+                    (if not Overflow\n+                     then Init_Val = Spec.Scan_Based_Number_Ghost\n+                       (Str, P + 1, Last_Num_Init, Acc => Uval));\n                end if;\n \n-               Lemma_Scan_Digit\n-                 (Str, P, Last_Num_Init, Digit, 10, Old_Uval, Uval, Init_Val,\n-                  Old_Overflow, Overflow);\n-\n                P := P + 1;\n             end if;\n          end loop;\n-         pragma Assert (P = Last_Num_Init + 1);\n-         pragma Assert (Init_Val.Overflow = Overflow);\n+         Spec.Lemma_Scan_Based_Number_Ghost_Base\n+            (Str, P, Last_Num_Init, Acc => Uval);\n       end;\n \n       pragma Assert_And_Cut\n@@ -488,18 +286,14 @@ package body System.Value_U is\n             UmaxB : constant Uns := Uns'Last / Base;\n             --  Numbers bigger than UmaxB overflow if multiplied by base\n \n-            Old_Uval     : Uns with Ghost;\n-            Old_Overflow : Boolean with Ghost;\n-\n          begin\n             pragma Assert\n               (if Str (P) in '0' .. '9' | 'A' .. 'F' | 'a' .. 'f'\n-               then Is_Based_Format_Ghost (Str (P .. Max)));\n+               then Spec.Is_Based_Format_Ghost (Str (P .. Max)));\n \n             --  Loop to scan out based integer value\n \n             loop\n-\n                --  We require a digit at this stage\n \n                if Str (P) in '0' .. '9' then\n@@ -519,6 +313,8 @@ package body System.Value_U is\n                --  already stored in Ptr.all.\n \n                else\n+                  Spec.Lemma_Scan_Based_Number_Ghost_Base\n+                    (Str, P, Last_Num_Based, Base, Uval);\n                   Uval := Base;\n                   Base := 10;\n                   pragma Assert (Ptr.all = Last_Num_Init + 1);\n@@ -529,25 +325,25 @@ package body System.Value_U is\n                   exit;\n                end if;\n \n-               Lemma_Digit_Is_Before_Last (Str, P, Last_Num_Init + 2, Max);\n-\n                pragma Loop_Invariant (P in P'Loop_Entry .. Last_Num_Based);\n                pragma Loop_Invariant\n                  (Str (P) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F'\n-                  and then Digit = Hexa_To_Unsigned_Ghost (Str (P)));\n+                  and then Digit = Spec.Hexa_To_Unsigned_Ghost (Str (P)));\n                pragma Loop_Invariant\n                  (if Overflow'Loop_Entry then Overflow);\n                pragma Loop_Invariant\n                  (if Overflow then\n-                    Overflow'Loop_Entry or else Based_Val.Overflow);\n+                    (Overflow'Loop_Entry or else Based_Val.Overflow));\n                pragma Loop_Invariant\n                  (if not Overflow\n-                  then Based_Val = Scan_Based_Number_Ghost\n+                  then Based_Val = Spec.Scan_Based_Number_Ghost\n                     (Str, P, Last_Num_Based, Base, Uval));\n                pragma Loop_Invariant (Ptr.all = Last_Num_Init + 1);\n \n-               Old_Uval := Uval;\n-               Old_Overflow := Overflow;\n+               Spec.Lemma_Scan_Based_Number_Ghost_Step\n+                 (Str, P, Last_Num_Based, Base, Uval);\n+               Spec.Lemma_Scan_Based_Number_Ghost_Overflow\n+                 (Str, P, Last_Num_Based, Base, Uval);\n \n                --  If digit is too large, just signal overflow and continue.\n                --  The idea here is to keep scanning as long as the input is\n@@ -560,6 +356,10 @@ package body System.Value_U is\n \n                elsif Uval <= Umax then\n                   Uval := Base * Uval + Digit;\n+                  pragma Assert\n+                    (if not Overflow\n+                     then Based_Val = Spec.Scan_Based_Number_Ghost\n+                       (Str, P + 1, Last_Num_Based, Base, Uval));\n \n                elsif Uval > UmaxB then\n                   Overflow := True;\n@@ -570,6 +370,10 @@ package body System.Value_U is\n                   if Uval < UmaxB then\n                      Overflow := True;\n                   end if;\n+                  pragma Assert\n+                    (if not Overflow\n+                     then Based_Val = Spec.Scan_Based_Number_Ghost\n+                       (Str, P + 1, Last_Num_Based, Base, Uval));\n                end if;\n \n                --  If at end of string with no base char, not a based number\n@@ -579,10 +383,6 @@ package body System.Value_U is\n \n                P := P + 1;\n \n-               Lemma_Scan_Digit\n-                 (Str, P - 1, Last_Num_Based, Digit, Base, Old_Uval, Uval,\n-                  Based_Val, Old_Overflow, Overflow);\n-\n                if P > Max then\n                   Ptr.all := P;\n                   Bad_Value (Str);\n@@ -592,48 +392,54 @@ package body System.Value_U is\n \n                if Str (P) = Base_Char then\n                   Ptr.all := P + 1;\n+                  pragma Assert (P = Last_Num_Based + 1);\n                   pragma Assert (Ptr.all = Last_Num_Based + 2);\n+                  pragma Assert (Starts_As_Based);\n+                  pragma Assert (Last_Num_Based < Max);\n+                  pragma Assert (Str (Last_Num_Based + 1) = Base_Char);\n+                  pragma Assert (Base_Char = Str (Last_Num_Init + 1));\n                   pragma Assert (Is_Based);\n-                  pragma Assert\n-                    (if not Overflow then\n-                       Based_Val = Scan_Based_Number_Ghost\n-                         (Str, P, Last_Num_Based, Base, Uval));\n-                  Lemma_End_Of_Scan (Str, P, Last_Num_Based, Base, Uval);\n-                  pragma Assert (if not Overflow then Uval = Based_Val.Value);\n+                  Spec.Lemma_Scan_Based_Number_Ghost_Base\n+                    (Str, P, Last_Num_Based, Base, Uval);\n                   exit;\n \n                --  Deal with underscore\n \n                elsif Str (P) = '_' then\n-                  Lemma_Scan_Underscore\n-                    (Str, P, Last_Num_Init + 2, Max, Last_Num_Based, Base,\n-                     Uval, Based_Val, Overflow, True);\n+                  Lemma_Underscore_Not_Last (Str, P, Last_Num_Init + 2, Max);\n+                  Spec.Lemma_Scan_Based_Number_Ghost_Underscore\n+                    (Str, P, Last_Num_Based, Base, Uval);\n                   Scan_Underscore (Str, P, Ptr, Max, True);\n                   pragma Assert\n                     (if not Overflow\n-                     then Based_Val = Scan_Based_Number_Ghost\n+                     then Based_Val = Spec.Scan_Based_Number_Ghost\n                        (Str, P, Last_Num_Based, Base, Uval));\n+                  pragma Assert (Str (P) /= '_');\n+                  pragma Assert (Str (P) /= Base_Char);\n                end if;\n+\n+               Lemma_Digit_Not_Last (Str, P, Last_Num_Init + 2, Max);\n+               pragma Assert (Str (P) /= '_');\n+               pragma Assert (Str (P) /= Base_Char);\n             end loop;\n          end;\n          pragma Assert\n            (if Starts_As_Based then P = Last_Num_Based + 1\n             else P = Last_Num_Init + 2);\n+         pragma Assert\n+           (Last_Num_Init < Max - 1\n+            and then Str (Last_Num_Init + 1) in '#' | ':');\n          pragma Assert\n            (Overflow =\n               (Init_Val.Overflow\n                or else Init_Val.Value not in 2 .. 16\n                or else (Starts_As_Based and then Based_Val.Overflow)));\n+         pragma Assert\n+           (Overflow /= Spec.Scan_Split_No_Overflow_Ghost (Str, Ptr_Old, Max));\n       end if;\n \n       pragma Assert_And_Cut\n-        (Overflow =\n-           (Init_Val.Overflow\n-            or else\n-              (Last_Num_Init < Max - 1\n-               and then Str (Last_Num_Init + 1) in '#' | ':'\n-               and then Init_Val.Value not in 2 .. 16)\n-            or else (Starts_As_Based and then Based_Val.Overflow))\n+        (Overflow /= Spec.Scan_Split_No_Overflow_Ghost (Str, Ptr_Old, Max)\n          and then\n            (if not Overflow then\n                 (if Is_Based then Uval = Based_Val.Value\n@@ -649,10 +455,12 @@ package body System.Value_U is\n \n       Scan_Exponent (Str, Ptr, Max, Expon);\n \n-      pragma Assert (Ptr.all = Raw_Unsigned_Last_Ghost (Str, Ptr_Old, Max));\n       pragma Assert\n-        (if Starts_As_Exponent_Format_Ghost (Str (First_Exp .. Max))\n-         then Expon = Scan_Exponent_Ghost (Str (First_Exp .. Max)));\n+        (Ptr.all = Spec.Raw_Unsigned_Last_Ghost (Str, Ptr_Old, Max));\n+      pragma Assert\n+        (if not Overflow\n+         then Spec.Scan_Split_Value_Ghost (Str, Ptr_Old, Max) =\n+           (Uval, Base, Expon));\n \n       if Expon /= 0 and then Uval /= 0 then\n \n@@ -664,8 +472,8 @@ package body System.Value_U is\n             UmaxB : constant Uns := Uns'Last / Base;\n             --  Numbers bigger than UmaxB overflow if multiplied by base\n \n-            Res_Val : constant Uns_Option :=\n-              Exponent_Unsigned_Ghost (Uval, Expon, Base)\n+            Res_Val : constant Spec.Uns_Option :=\n+              Spec.Exponent_Unsigned_Ghost (Uval, Expon, Base)\n             with Ghost;\n          begin\n             for J in 1 .. Expon loop\n@@ -674,48 +482,45 @@ package body System.Value_U is\n                pragma Loop_Invariant\n                  (if Overflow\n                   then Overflow'Loop_Entry or else Res_Val.Overflow);\n+               pragma Loop_Invariant (Uval /= 0);\n                pragma Loop_Invariant\n                  (if not Overflow\n-                  then Res_Val = Exponent_Unsigned_Ghost\n+                  then Res_Val = Spec.Exponent_Unsigned_Ghost\n                     (Uval, Expon - J + 1, Base));\n \n                pragma Assert\n-                 ((Uval > UmaxB) = Scan_Overflows_Ghost (0, Base, Uval));\n+                 ((Uval > UmaxB) = Spec.Scan_Overflows_Ghost (0, Base, Uval));\n \n                if Uval > UmaxB then\n+                  Spec.Lemma_Exponent_Unsigned_Ghost_Overflow\n+                     (Uval, Expon - J + 1, Base);\n                   Overflow := True;\n                   exit;\n                end if;\n \n+               Spec.Lemma_Exponent_Unsigned_Ghost_Step\n+                  (Uval, Expon - J + 1, Base);\n+\n                Uval := Uval * Base;\n             end loop;\n+            Spec.Lemma_Exponent_Unsigned_Ghost_Base (Uval, 0, Base);\n+\n             pragma Assert\n-              (Overflow = (Init_Val.Overflow\n-               or else\n-                 (Last_Num_Init < Max - 1\n-                  and then Str (Last_Num_Init + 1) in '#' | ':'\n-                  and then Init_Val.Value not in 2 .. 16)\n-               or else (Starts_As_Based and then Based_Val.Overflow)\n-               or else Res_Val.Overflow));\n-            pragma Assert\n-              (Overflow = Raw_Unsigned_Overflows_Ghost (Str, Ptr_Old, Max));\n-            pragma Assert\n-              (Exponent_Unsigned_Ghost (Uval, 0, Base) = (False, Uval));\n-            pragma Assert\n-              (if not Overflow then Uval = Res_Val.Value);\n-            pragma Assert\n-              (if not Overflow then\n-                  Uval = Scan_Raw_Unsigned_Ghost (Str, Ptr_Old, Max));\n+              (Overflow /=\n+                 Spec.Raw_Unsigned_No_Overflow_Ghost (Str, Ptr_Old, Max));\n+            pragma Assert (if not Overflow then Res_Val = (False, Uval));\n          end;\n       end if;\n+      Spec.Lemma_Exponent_Unsigned_Ghost_Base (Uval, Expon, Base);\n       pragma Assert\n         (if Expon = 0 or else Uval = 0 then\n-            Exponent_Unsigned_Ghost (Uval, Expon, Base) = (False, Uval));\n+            Spec.Exponent_Unsigned_Ghost (Uval, Expon, Base) = (False, Uval));\n       pragma Assert\n-        (Overflow = Raw_Unsigned_Overflows_Ghost (Str, Ptr_Old, Max));\n+        (Overflow /=\n+           Spec.Raw_Unsigned_No_Overflow_Ghost (Str, Ptr_Old, Max));\n       pragma Assert\n         (if not Overflow then\n-            Uval = Scan_Raw_Unsigned_Ghost (Str, Ptr_Old, Max));\n+            Uval = Spec.Scan_Raw_Unsigned_Ghost (Str, Ptr_Old, Max));\n \n       --  Return result, dealing with overflow\n \n@@ -774,7 +579,15 @@ package body System.Value_U is\n       if Str'Last = Positive'Last then\n          declare\n             subtype NT is String (1 .. Str'Length);\n+            procedure Prove_Is_Unsigned_Ghost with\n+              Ghost,\n+              Pre  => Str'Length < Natural'Last\n+              and then not Only_Space_Ghost (Str, Str'First, Str'Last)\n+              and then Spec.Is_Unsigned_Ghost (Spec.Slide_To_1 (Str)),\n+              Post => Spec.Is_Unsigned_Ghost (NT (Str));\n+            procedure Prove_Is_Unsigned_Ghost is null;\n          begin\n+            Prove_Is_Unsigned_Ghost;\n             return Value_Unsigned (NT (Str));\n          end;\n \n@@ -784,32 +597,29 @@ package body System.Value_U is\n          declare\n             V : Uns;\n             P : aliased Integer := Str'First;\n-\n             Non_Blank : constant Positive := First_Non_Space_Ghost\n               (Str, Str'First, Str'Last)\n             with Ghost;\n             Fst_Num   : constant Positive :=\n               (if Str (Non_Blank) = '+' then Non_Blank + 1 else Non_Blank)\n             with Ghost;\n          begin\n-            pragma Assert\n-              (Is_Raw_Unsigned_Format_Ghost (Str (Fst_Num .. Str'Last)));\n-\n             declare\n                P_Acc : constant not null access Integer := P'Access;\n             begin\n                Scan_Unsigned (Str, P_Acc, Str'Last, V);\n             end;\n \n             pragma Assert\n-              (P = Raw_Unsigned_Last_Ghost (Str, Fst_Num, Str'Last));\n+              (P = Spec.Raw_Unsigned_Last_Ghost (Str, Fst_Num, Str'Last));\n             pragma Assert\n-              (V = Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Str'Last));\n+              (V = Spec.Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Str'Last));\n \n             Scan_Trailing_Blanks (Str, P);\n \n             pragma Assert\n-              (Is_Value_Unsigned_Ghost (Slide_If_Necessary (Str), V));\n+              (Spec.Is_Value_Unsigned_Ghost\n+                 (Spec.Slide_If_Necessary (Str), V));\n             return V;\n          end;\n       end if;"}, {"sha": "466b96a6fa6099b72c8c8db34782c731c56bfad3", "filename": "gcc/ada/libgnat/s-valueu.ads", "status": "modified", "additions": 15, "deletions": 463, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-valueu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-valueu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valueu.ads?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -44,6 +44,7 @@ pragma Assertion_Policy (Pre                => Ignore,\n                          Ghost              => Ignore,\n                          Subprogram_Variant => Ignore);\n \n+with System.Value_U_Spec;\n with System.Val_Util; use System.Val_Util;\n \n generic\n@@ -53,317 +54,7 @@ generic\n package System.Value_U is\n    pragma Preelaborate;\n \n-   type Uns_Option (Overflow : Boolean := False) is record\n-      case Overflow is\n-         when True =>\n-            null;\n-         when False =>\n-            Value : Uns := 0;\n-      end case;\n-   end record;\n-\n-   function Wrap_Option (Value : Uns) return Uns_Option is\n-     (Overflow => False, Value => Value)\n-   with\n-     Ghost;\n-\n-   function Only_Decimal_Ghost\n-     (Str      : String;\n-      From, To : Integer)\n-      return Boolean\n-   is\n-      (for all J in From .. To => Str (J) in '0' .. '9')\n-   with\n-     Ghost,\n-     Pre => From > To or else (From >= Str'First and then To <= Str'Last);\n-   --  Ghost function that returns True if S has only decimal characters\n-   --  from index From to index To.\n-\n-   function Only_Hexa_Ghost (Str : String; From, To : Integer) return Boolean\n-   is\n-      (for all J in From .. To =>\n-          Str (J) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' | '_')\n-   with\n-     Ghost,\n-     Pre => From > To or else (From >= Str'First and then To <= Str'Last);\n-   --  Ghost function that returns True if S has only hexadecimal characters\n-   --  from index From to index To.\n-\n-   function Last_Hexa_Ghost (Str : String) return Positive\n-   with\n-     Ghost,\n-     Pre  => Str /= \"\"\n-       and then Str (Str'First) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F',\n-     Post => Last_Hexa_Ghost'Result in Str'Range\n-       and then (if Last_Hexa_Ghost'Result < Str'Last then\n-                   Str (Last_Hexa_Ghost'Result + 1) not in\n-                     '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' | '_')\n-       and then Only_Hexa_Ghost (Str, Str'First, Last_Hexa_Ghost'Result);\n-   --  Ghost function that returns the index of the last character in S that\n-   --  is either an hexadecimal digit or an underscore, which necessarily\n-   --  exists given the precondition on Str.\n-\n-   function Is_Based_Format_Ghost (Str : String) return Boolean\n-   is\n-     (Str /= \"\"\n-        and then Str (Str'First) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F'\n-        and then\n-        (declare\n-           L : constant Positive := Last_Hexa_Ghost (Str);\n-         begin\n-           Str (L) /= '_'\n-             and then (for all J in Str'First .. L =>\n-                         (if Str (J) = '_' then Str (J + 1) /= '_'))))\n-   with\n-     Ghost;\n-   --  Ghost function that determines if Str has the correct format for a\n-   --  based number, consisting in a sequence of hexadecimal digits possibly\n-   --  separated by single underscores. It may be followed by other characters.\n-\n-   function Hexa_To_Unsigned_Ghost (X : Character) return Uns is\n-     (case X is\n-         when '0' .. '9' => Character'Pos (X) - Character'Pos ('0'),\n-         when 'a' .. 'f' => Character'Pos (X) - Character'Pos ('a') + 10,\n-         when 'A' .. 'F' => Character'Pos (X) - Character'Pos ('A') + 10,\n-         when others     => raise Program_Error)\n-   with\n-     Ghost,\n-     Pre => X in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F';\n-   --  Ghost function that computes the value corresponding to an hexadecimal\n-   --  digit.\n-\n-   function Scan_Overflows_Ghost\n-     (Digit : Uns;\n-      Base  : Uns;\n-      Acc   : Uns) return Boolean\n-   is\n-     (Digit >= Base\n-      or else Acc > Uns'Last / Base\n-      or else Uns'Last - Digit < Base * Acc)\n-   with Ghost;\n-   --  Ghost function which returns True if Digit + Base * Acc overflows or\n-   --  Digit is greater than Base, as this is used by the algorithm for the\n-   --  test of overflow.\n-\n-   function Scan_Based_Number_Ghost\n-     (Str      : String;\n-      From, To : Integer;\n-      Base     : Uns := 10;\n-      Acc      : Uns := 0) return Uns_Option\n-   with\n-     Ghost,\n-     Subprogram_Variant => (Increases => From),\n-     Pre  => Str'Last /= Positive'Last\n-         and then\n-           (From > To or else (From >= Str'First and then To <= Str'Last))\n-         and then Only_Hexa_Ghost (Str, From, To);\n-   --  Ghost function that recursively computes the based number in Str,\n-   --  assuming Acc has been scanned already and scanning continues at index\n-   --  From.\n-\n-   function Exponent_Unsigned_Ghost\n-     (Value : Uns;\n-      Exp   : Natural;\n-      Base  : Uns := 10) return Uns_Option\n-   with\n-     Ghost,\n-     Subprogram_Variant => (Decreases => Exp);\n-   --  Ghost function that recursively computes Value * Base ** Exp\n-\n-   function Is_Raw_Unsigned_Format_Ghost (Str : String) return Boolean is\n-     (Is_Natural_Format_Ghost (Str)\n-      and then\n-        (declare\n-           Last_Num_Init   : constant Integer := Last_Number_Ghost (Str);\n-           Starts_As_Based : constant Boolean :=\n-             Last_Num_Init < Str'Last - 1\n-             and then Str (Last_Num_Init + 1) in '#' | ':'\n-             and then Str (Last_Num_Init + 2) in\n-               '0' .. '9' | 'a' .. 'f' | 'A' .. 'F';\n-           Last_Num_Based  : constant Integer :=\n-             (if Starts_As_Based\n-              then Last_Hexa_Ghost (Str (Last_Num_Init + 2 .. Str'Last))\n-              else Last_Num_Init);\n-           Is_Based        : constant Boolean :=\n-             Starts_As_Based\n-             and then Last_Num_Based < Str'Last\n-             and then Str (Last_Num_Based + 1) = Str (Last_Num_Init + 1);\n-           First_Exp       : constant Integer :=\n-             (if Is_Based then Last_Num_Based + 2 else Last_Num_Init + 1);\n-         begin\n-           (if Starts_As_Based then\n-              Is_Based_Format_Ghost (Str (Last_Num_Init + 2 .. Str'Last))\n-              and then Last_Num_Based < Str'Last)\n-            and then Is_Opt_Exponent_Format_Ghost\n-              (Str (First_Exp .. Str'Last))))\n-   with\n-     Ghost,\n-     Pre  => Str'Last /= Positive'Last,\n-     Post => True;\n-   --  Ghost function that determines if Str has the correct format for an\n-   --  unsigned number without a sign character.\n-   --  It is a natural number in base 10, optionally followed by a based\n-   --  number surrounded by delimiters # or :, optionally followed by an\n-   --  exponent part.\n-\n-   function Raw_Unsigned_Overflows_Ghost\n-     (Str      : String;\n-      From, To : Integer)\n-      return Boolean\n-   is\n-     (declare\n-        Last_Num_Init   : constant Integer :=\n-          Last_Number_Ghost (Str (From .. To));\n-        Init_Val        : constant Uns_Option :=\n-          Scan_Based_Number_Ghost (Str, From, Last_Num_Init);\n-        Starts_As_Based : constant Boolean :=\n-          Last_Num_Init < To - 1\n-          and then Str (Last_Num_Init + 1) in '#' | ':'\n-          and then Str (Last_Num_Init + 2) in\n-          '0' .. '9' | 'a' .. 'f' | 'A' .. 'F';\n-        Last_Num_Based  : constant Integer :=\n-          (if Starts_As_Based\n-           then Last_Hexa_Ghost (Str (Last_Num_Init + 2 .. To))\n-           else Last_Num_Init);\n-        Is_Based        : constant Boolean :=\n-          Starts_As_Based\n-          and then Last_Num_Based < To\n-          and then Str (Last_Num_Based + 1) = Str (Last_Num_Init + 1);\n-        Based_Val       : constant Uns_Option :=\n-          (if Starts_As_Based and then not Init_Val.Overflow\n-           then Scan_Based_Number_Ghost\n-             (Str, Last_Num_Init + 2, Last_Num_Based, Init_Val.Value)\n-           else Init_Val);\n-        First_Exp       : constant Integer :=\n-          (if Is_Based then Last_Num_Based + 2 else Last_Num_Init + 1);\n-        Expon           : constant Natural :=\n-          (if Starts_As_Exponent_Format_Ghost (Str (First_Exp .. To))\n-           then Scan_Exponent_Ghost (Str (First_Exp .. To))\n-           else 0);\n-      begin\n-        Init_Val.Overflow\n-        or else\n-          (Last_Num_Init < To - 1\n-           and then Str (Last_Num_Init + 1) in '#' | ':'\n-           and then Init_Val.Value not in 2 .. 16)\n-        or else\n-          (Starts_As_Based\n-           and then Based_Val.Overflow)\n-        or else\n-          (Starts_As_Exponent_Format_Ghost (Str (First_Exp .. To))\n-           and then\n-             (declare\n-                Base  : constant Uns :=\n-                  (if Is_Based then Init_Val.Value else 10);\n-                Value : constant Uns :=\n-                  (if Is_Based then Based_Val.Value else Init_Val.Value);\n-              begin\n-                Exponent_Unsigned_Ghost\n-                  (Value, Expon, Base).Overflow)))\n-   with\n-     Ghost,\n-     Pre  => Str'Last /= Positive'Last\n-       and then From in Str'Range\n-       and then To in From .. Str'Last\n-       and then Str (From) in '0' .. '9',\n-     Post => True;\n-   --  Ghost function that determines if the computation of the unsigned number\n-   --  represented by Str will overflow. The computation overflows if either:\n-   --    * The computation of the decimal part overflows,\n-   --    * The decimal part is followed by a valid delimiter for a based\n-   --      part, and the number corresponding to the base is not a valid base,\n-   --    * The computation of the based part overflows, or\n-   --    * There is an exponent and the computation of the exponentiation\n-   --      overflows.\n-\n-   function Scan_Raw_Unsigned_Ghost\n-     (Str      : String;\n-      From, To : Integer)\n-      return Uns\n-   is\n-     (declare\n-        Last_Num_Init   : constant Integer :=\n-          Last_Number_Ghost (Str (From .. To));\n-        Init_Val        : constant Uns_Option :=\n-          Scan_Based_Number_Ghost (Str, From, Last_Num_Init);\n-        Starts_As_Based : constant Boolean :=\n-          Last_Num_Init < To - 1\n-          and then Str (Last_Num_Init + 1) in '#' | ':'\n-          and then Str (Last_Num_Init + 2) in\n-          '0' .. '9' | 'a' .. 'f' | 'A' .. 'F';\n-        Last_Num_Based  : constant Integer :=\n-          (if Starts_As_Based\n-           then Last_Hexa_Ghost (Str (Last_Num_Init + 2 .. To))\n-           else Last_Num_Init);\n-        Is_Based        : constant Boolean :=\n-          Starts_As_Based\n-          and then Last_Num_Based < To\n-          and then Str (Last_Num_Based + 1) = Str (Last_Num_Init + 1);\n-        Based_Val       : constant Uns_Option :=\n-          (if Starts_As_Based and then not Init_Val.Overflow\n-           then Scan_Based_Number_Ghost\n-             (Str, Last_Num_Init + 2, Last_Num_Based, Init_Val.Value)\n-           else Init_Val);\n-        First_Exp       : constant Integer :=\n-          (if Is_Based then Last_Num_Based + 2 else Last_Num_Init + 1);\n-        Expon           : constant Natural :=\n-          (if Starts_As_Exponent_Format_Ghost (Str (First_Exp .. To))\n-           then Scan_Exponent_Ghost (Str (First_Exp .. To))\n-           else 0);\n-        Base            : constant Uns :=\n-          (if Is_Based then Init_Val.Value else 10);\n-        Value           : constant Uns :=\n-          (if Is_Based then Based_Val.Value else Init_Val.Value);\n-      begin\n-        Exponent_Unsigned_Ghost (Value, Expon, Base).Value)\n-   with\n-     Ghost,\n-     Pre  => Str'Last /= Positive'Last\n-       and then From in Str'Range\n-       and then To in From .. Str'Last\n-       and then Str (From) in '0' .. '9'\n-       and then not Raw_Unsigned_Overflows_Ghost (Str, From, To),\n-     Post => True;\n-   --  Ghost function that scans an unsigned number without a sign character\n-\n-   function Raw_Unsigned_Last_Ghost\n-     (Str      : String;\n-      From, To : Integer)\n-      return Positive\n-   is\n-     (declare\n-        Last_Num_Init   : constant Integer :=\n-          Last_Number_Ghost (Str (From .. To));\n-        Starts_As_Based : constant Boolean :=\n-          Last_Num_Init < To - 1\n-          and then Str (Last_Num_Init + 1) in '#' | ':'\n-          and then Str (Last_Num_Init + 2) in\n-          '0' .. '9' | 'a' .. 'f' | 'A' .. 'F';\n-        Last_Num_Based  : constant Integer :=\n-          (if Starts_As_Based\n-           then Last_Hexa_Ghost (Str (Last_Num_Init + 2 .. To))\n-           else Last_Num_Init);\n-        Is_Based        : constant Boolean :=\n-          Starts_As_Based\n-          and then Last_Num_Based < To\n-          and then Str (Last_Num_Based + 1) = Str (Last_Num_Init + 1);\n-        First_Exp       : constant Integer :=\n-          (if Is_Based then Last_Num_Based + 2 else Last_Num_Init + 1);\n-      begin\n-        (if not Starts_As_Exponent_Format_Ghost (Str (First_Exp .. To))\n-         then First_Exp\n-         elsif Str (First_Exp + 1) in '-' | '+' then\n-           Last_Number_Ghost (Str (First_Exp + 2 .. To)) + 1\n-         else Last_Number_Ghost (Str (First_Exp + 1 .. To)) + 1))\n-   with\n-     Ghost,\n-     Pre  => Str'Last /= Positive'Last\n-       and then From in Str'Range\n-       and then To in From .. Str'Last\n-       and then Str (From) in '0' .. '9',\n-     Post => Raw_Unsigned_Last_Ghost'Result in From .. To + 1;\n-   --  Ghost function that returns the position of the cursor once an unsigned\n-   --  number has been seen.\n+   package Spec is new System.Value_U_Spec (Uns);\n \n    procedure Scan_Raw_Unsigned\n      (Str : String;\n@@ -373,10 +64,10 @@ package System.Value_U is\n    with Pre => Str'Last /= Positive'Last\n      and then Ptr.all in Str'Range\n      and then Max in Ptr.all .. Str'Last\n-     and then Is_Raw_Unsigned_Format_Ghost (Str (Ptr.all .. Max)),\n-     Post => not Raw_Unsigned_Overflows_Ghost (Str, Ptr.all'Old, Max)\n-     and Res = Scan_Raw_Unsigned_Ghost (Str, Ptr.all'Old, Max)\n-     and Ptr.all = Raw_Unsigned_Last_Ghost (Str, Ptr.all'Old, Max);\n+     and then Spec.Is_Raw_Unsigned_Format_Ghost (Str (Ptr.all .. Max)),\n+     Post => Spec.Raw_Unsigned_No_Overflow_Ghost (Str, Ptr.all'Old, Max)\n+     and Res = Spec.Scan_Raw_Unsigned_Ghost (Str, Ptr.all'Old, Max)\n+     and Ptr.all = Spec.Raw_Unsigned_Last_Ghost (Str, Ptr.all'Old, Max);\n \n    --  This function scans the string starting at Str (Ptr.all) for a valid\n    --  integer according to the syntax described in (RM 3.5(43)). The substring\n@@ -464,175 +155,36 @@ package System.Value_U is\n           Fst_Num   : constant Positive :=\n             (if Str (Non_Blank) = '+' then Non_Blank + 1 else Non_Blank);\n         begin\n-          Is_Raw_Unsigned_Format_Ghost (Str (Fst_Num .. Max))),\n+          Spec.Is_Raw_Unsigned_Format_Ghost (Str (Fst_Num .. Max))),\n      Post =>\n        (declare\n           Non_Blank : constant Positive :=\n             First_Non_Space_Ghost (Str, Ptr.all'Old, Max);\n           Fst_Num   : constant Positive :=\n             (if Str (Non_Blank) = '+' then Non_Blank + 1 else Non_Blank);\n         begin\n-          not Raw_Unsigned_Overflows_Ghost (Str, Fst_Num, Max)\n-          and then Res = Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Max)\n-          and then Ptr.all = Raw_Unsigned_Last_Ghost (Str, Fst_Num, Max));\n+          Spec.Raw_Unsigned_No_Overflow_Ghost (Str, Fst_Num, Max)\n+          and then Res = Spec.Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Max)\n+          and then Ptr.all = Spec.Raw_Unsigned_Last_Ghost (Str, Fst_Num, Max));\n \n    --  Same as Scan_Raw_Unsigned, except scans optional leading\n    --  blanks, and an optional leading plus sign.\n    --\n    --  Note: if a minus sign is present, Constraint_Error will be raised.\n    --  Note: trailing blanks are not scanned.\n \n-   function Slide_To_1 (Str : String) return String\n-   with Ghost,\n-       Post =>\n-         Only_Space_Ghost (Str, Str'First, Str'Last) =\n-         (for all J in Str'First .. Str'Last =>\n-            Slide_To_1'Result (J - Str'First + 1) = ' ');\n-   --  Slides Str so that it starts at 1\n-\n-   function Slide_If_Necessary (Str : String) return String is\n-     (if Str'Last = Positive'Last then Slide_To_1 (Str) else Str)\n-   with Ghost,\n-       Post =>\n-         Only_Space_Ghost (Str, Str'First, Str'Last) =\n-         Only_Space_Ghost (Slide_If_Necessary'Result,\n-                           Slide_If_Necessary'Result'First,\n-                           Slide_If_Necessary'Result'Last);\n-   --  If Str'Last = Positive'Last then slides Str so that it starts at 1\n-\n-   function Is_Unsigned_Ghost (Str : String) return Boolean is\n-     (declare\n-        Non_Blank : constant Positive := First_Non_Space_Ghost\n-          (Str, Str'First, Str'Last);\n-        Fst_Num   : constant Positive :=\n-          (if Str (Non_Blank) = '+' then Non_Blank + 1 else Non_Blank);\n-      begin\n-        Is_Raw_Unsigned_Format_Ghost (Str (Fst_Num .. Str'Last))\n-          and then not Raw_Unsigned_Overflows_Ghost (Str, Fst_Num, Str'Last)\n-          and then Only_Space_Ghost\n-             (Str, Raw_Unsigned_Last_Ghost (Str, Fst_Num, Str'Last), Str'Last))\n-   with Ghost,\n-       Pre => not Only_Space_Ghost (Str, Str'First, Str'Last)\n-       and then Str'Last /= Positive'Last,\n-       Post => True;\n-   --  Ghost function that determines if Str has the correct format for an\n-   --  unsigned number, consisting in some blank characters, an optional\n-   --  + sign, a raw unsigned number which does not overflow and then some\n-   --  more blank characters.\n-\n-   function Is_Value_Unsigned_Ghost (Str : String; Val : Uns) return Boolean is\n-     (declare\n-        Non_Blank : constant Positive := First_Non_Space_Ghost\n-          (Str, Str'First, Str'Last);\n-        Fst_Num   : constant Positive :=\n-          (if Str (Non_Blank) = '+' then Non_Blank + 1 else Non_Blank);\n-      begin\n-        Val = Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Str'Last))\n-   with Ghost,\n-       Pre => not Only_Space_Ghost (Str, Str'First, Str'Last)\n-       and then Str'Last /= Positive'Last\n-       and then Is_Unsigned_Ghost (Str),\n-       Post => True;\n-   --  Ghost function that returns True if Val is the value corresponding to\n-   --  the unsigned number represented by Str.\n-\n    function Value_Unsigned\n      (Str : String) return Uns\n-   with Pre => not Only_Space_Ghost (Str, Str'First, Str'Last)\n-     and then Str'Length /= Positive'Last\n-     and then Is_Unsigned_Ghost (Slide_If_Necessary (Str)),\n+   with Pre => Str'Length /= Positive'Last\n+     and then not Only_Space_Ghost (Str, Str'First, Str'Last)\n+     and then Spec.Is_Unsigned_Ghost (Spec.Slide_If_Necessary (Str)),\n      Post =>\n-         Is_Value_Unsigned_Ghost\n-           (Slide_If_Necessary (Str), Value_Unsigned'Result),\n+         Spec.Is_Value_Unsigned_Ghost\n+           (Spec.Slide_If_Necessary (Str), Value_Unsigned'Result),\n      Subprogram_Variant => (Decreases => Str'First);\n    --  Used in computing X'Value (Str) where X is a modular integer type whose\n    --  modulus does not exceed the range of System.Unsigned_Types.Unsigned. Str\n    --  is the string argument of the attribute. Constraint_Error is raised if\n    --  the string is malformed, or if the value is out of range.\n \n-   procedure Prove_Iter_Scan_Based_Number_Ghost\n-     (Str1, Str2 : String;\n-      From, To : Integer;\n-      Base     : Uns := 10;\n-      Acc      : Uns := 0)\n-   with\n-     Ghost,\n-     Subprogram_Variant => (Increases => From),\n-     Pre  => Str1'Last /= Positive'Last\n-       and then Str2'Last /= Positive'Last\n-       and then\n-         (From > To or else (From >= Str1'First and then To <= Str1'Last))\n-       and then\n-         (From > To or else (From >= Str2'First and then To <= Str2'Last))\n-       and then Only_Hexa_Ghost (Str1, From, To)\n-       and then (for all J in From .. To => Str1 (J) = Str2 (J)),\n-     Post =>\n-       Scan_Based_Number_Ghost (Str1, From, To, Base, Acc)\n-         = Scan_Based_Number_Ghost (Str2, From, To, Base, Acc);\n-   --  Ghost lemma used in the proof of 'Image implementation, to prove the\n-   --  preservation of Scan_Based_Number_Ghost across an update in the string\n-   --  in lower indexes.\n-\n-   procedure Prove_Scan_Only_Decimal_Ghost\n-     (Str : String;\n-      Val : Uns)\n-   with\n-     Ghost,\n-     Pre  => Str'Last /= Positive'Last\n-       and then Str'Length >= 2\n-       and then Str (Str'First) = ' '\n-       and then Only_Decimal_Ghost (Str, Str'First + 1, Str'Last)\n-       and then Scan_Based_Number_Ghost (Str, Str'First + 1, Str'Last)\n-         = Wrap_Option (Val),\n-     Post => Is_Unsigned_Ghost (Slide_If_Necessary (Str))\n-       and then Value_Unsigned (Str) = Val;\n-   --  Ghost lemma used in the proof of 'Image implementation, to prove that\n-   --  the result of Value_Unsigned on a decimal string is the same as the\n-   --  result of Scan_Based_Number_Ghost.\n-\n-private\n-\n-   -----------------------------\n-   -- Exponent_Unsigned_Ghost --\n-   -----------------------------\n-\n-   function Exponent_Unsigned_Ghost\n-     (Value : Uns;\n-      Exp   : Natural;\n-      Base  : Uns := 10) return Uns_Option\n-   is\n-      (if Exp = 0 or Value = 0 then (Overflow => False, Value => Value)\n-       elsif Scan_Overflows_Ghost (0, Base, Value) then (Overflow => True)\n-       else Exponent_Unsigned_Ghost (Value * Base, Exp - 1, Base));\n-\n-   -----------------------------\n-   -- Scan_Based_Number_Ghost --\n-   -----------------------------\n-\n-   function Scan_Based_Number_Ghost\n-     (Str      : String;\n-      From, To : Integer;\n-      Base     : Uns := 10;\n-      Acc      : Uns := 0) return Uns_Option\n-   is\n-      (if From > To then (Overflow => False, Value => Acc)\n-       elsif Str (From) = '_'\n-       then Scan_Based_Number_Ghost (Str, From + 1, To, Base, Acc)\n-       elsif Scan_Overflows_Ghost\n-         (Hexa_To_Unsigned_Ghost (Str (From)), Base, Acc)\n-       then (Overflow => True)\n-       else Scan_Based_Number_Ghost\n-         (Str, From + 1, To, Base,\n-          Base * Acc + Hexa_To_Unsigned_Ghost (Str (From))));\n-\n-   ----------------\n-   -- Slide_To_1 --\n-   ----------------\n-\n-   function Slide_To_1 (Str : String) return String is\n-      (declare\n-         Res : constant String (1 .. Str'Length) := Str;\n-       begin\n-         Res);\n-\n end System.Value_U;"}, {"sha": "7c2da17aa53c0411a57e993ff8248a56b38a4d76", "filename": "gcc/ada/libgnat/s-valuti.ads", "status": "modified", "additions": 247, "deletions": 21, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-valuti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-valuti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuti.ads?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -374,48 +374,274 @@ is\n    --  no check for this case, the caller must ensure this condition is met.\n    pragma Warnings (GNATprove, On, \"\"\"Ptr\"\" is not modified\");\n \n-   --  Bundle Int type with other types, constants and subprograms used in\n+   --  Bundle Uns type with other types, constants and subprograms used in\n    --  ghost code, so that this package can be instantiated once and used\n-   --  multiple times as generic formal for a given Int type.\n+   --  multiple times as generic formal for a given Uns type.\n    generic\n-      type Int is range <>;\n       type Uns is mod <>;\n-      type Uns_Option is private;\n+      type P_Uns_Option is private with Ghost;\n+      with function P_Wrap_Option (Value : Uns) return P_Uns_Option\n+        with Ghost;\n+      with function P_Hexa_To_Unsigned_Ghost (X : Character) return Uns\n+        with Ghost;\n+      with function P_Scan_Overflows_Ghost\n+        (Digit : Uns;\n+         Base  : Uns;\n+         Acc   : Uns) return Boolean\n+        with Ghost;\n+      with function P_Is_Raw_Unsigned_Format_Ghost\n+        (Str : String) return Boolean\n+        with Ghost;\n+      with function P_Scan_Split_No_Overflow_Ghost\n+        (Str      : String;\n+         From, To : Integer)\n+      return Boolean\n+        with Ghost;\n+      with function P_Raw_Unsigned_No_Overflow_Ghost\n+        (Str      : String;\n+         From, To : Integer)\n+      return Boolean\n+        with Ghost;\n \n-      Unsigned_Width_Ghost : Natural;\n+      with function P_Exponent_Unsigned_Ghost\n+        (Value : Uns;\n+         Exp   : Natural;\n+         Base  : Uns := 10) return P_Uns_Option\n+        with Ghost;\n+      with procedure P_Lemma_Exponent_Unsigned_Ghost_Base\n+        (Value : Uns;\n+         Exp   : Natural;\n+         Base  : Uns := 10)\n+        with Ghost;\n+      with procedure P_Lemma_Exponent_Unsigned_Ghost_Overflow\n+        (Value : Uns;\n+         Exp   : Natural;\n+         Base  : Uns := 10)\n+        with Ghost;\n+      with procedure P_Lemma_Exponent_Unsigned_Ghost_Step\n+        (Value : Uns;\n+         Exp   : Natural;\n+         Base  : Uns := 10)\n+        with Ghost;\n \n-      with function Wrap_Option (Value : Uns) return Uns_Option\n-         with Ghost;\n-      with function Only_Decimal_Ghost\n+      with function P_Scan_Raw_Unsigned_Ghost\n         (Str      : String;\n          From, To : Integer)\n-         return Boolean\n-         with Ghost;\n-      with function Hexa_To_Unsigned_Ghost (X : Character) return Uns\n-         with Ghost;\n-      with function Scan_Based_Number_Ghost\n+      return Uns\n+        with Ghost;\n+      with procedure P_Lemma_Scan_Based_Number_Ghost_Base\n         (Str      : String;\n          From, To : Integer;\n          Base     : Uns := 10;\n          Acc      : Uns := 0)\n-         return Uns_Option\n-         with Ghost;\n-      with function Is_Integer_Ghost (Str : String) return Boolean\n-         with Ghost;\n-      with procedure Prove_Iter_Scan_Based_Number_Ghost\n+        with Ghost;\n+      with procedure P_Lemma_Scan_Based_Number_Ghost_Underscore\n+        (Str      : String;\n+         From, To : Integer;\n+         Base     : Uns := 10;\n+         Acc      : Uns := 0)\n+        with Ghost;\n+      with procedure P_Lemma_Scan_Based_Number_Ghost_Overflow\n+        (Str      : String;\n+         From, To : Integer;\n+         Base     : Uns := 10;\n+         Acc      : Uns := 0)\n+        with Ghost;\n+      with procedure P_Lemma_Scan_Based_Number_Ghost_Step\n+        (Str      : String;\n+         From, To : Integer;\n+         Base     : Uns := 10;\n+         Acc      : Uns := 0)\n+        with Ghost;\n+\n+      with function P_Raw_Unsigned_Last_Ghost\n+        (Str      : String;\n+         From, To : Integer)\n+      return Positive\n+        with Ghost;\n+      with function P_Only_Decimal_Ghost\n+        (Str      : String;\n+         From, To : Integer)\n+      return Boolean\n+        with Ghost;\n+      with function P_Scan_Based_Number_Ghost\n+        (Str      : String;\n+         From, To : Integer;\n+         Base     : Uns := 10;\n+         Acc      : Uns := 0)\n+      return P_Uns_Option\n+        with Ghost;\n+      with function P_Is_Unsigned_Ghost (Str : String) return Boolean\n+        with Ghost;\n+      with function P_Is_Value_Unsigned_Ghost\n+        (Str : String;\n+         Val : Uns) return Boolean\n+        with Ghost;\n+\n+      with procedure P_Prove_Scan_Only_Decimal_Ghost\n+        (Str : String;\n+         Val : Uns)\n+        with Ghost;\n+      with procedure P_Prove_Scan_Based_Number_Ghost_Eq\n         (Str1, Str2 : String;\n+         From, To   : Integer;\n+         Base       : Uns := 10;\n+         Acc        : Uns := 0)\n+        with Ghost;\n+\n+   package Uns_Params is\n+      subtype Uns_Option is P_Uns_Option with Ghost;\n+      function Wrap_Option (Value : Uns) return Uns_Option renames\n+        P_Wrap_Option;\n+      function Hexa_To_Unsigned_Ghost\n+        (X : Character) return Uns\n+         renames P_Hexa_To_Unsigned_Ghost;\n+      function Scan_Overflows_Ghost\n+        (Digit : Uns;\n+         Base  : Uns;\n+         Acc   : Uns) return Boolean\n+         renames P_Scan_Overflows_Ghost;\n+      function Is_Raw_Unsigned_Format_Ghost\n+        (Str : String) return Boolean\n+         renames P_Is_Raw_Unsigned_Format_Ghost;\n+      function Scan_Split_No_Overflow_Ghost\n+        (Str      : String;\n+         From, To : Integer) return Boolean\n+         renames P_Scan_Split_No_Overflow_Ghost;\n+      function Raw_Unsigned_No_Overflow_Ghost\n+        (Str      : String;\n+         From, To : Integer) return Boolean\n+         renames P_Raw_Unsigned_No_Overflow_Ghost;\n+\n+      function Exponent_Unsigned_Ghost\n+        (Value : Uns;\n+         Exp   : Natural;\n+         Base  : Uns := 10) return Uns_Option\n+         renames P_Exponent_Unsigned_Ghost;\n+      procedure Lemma_Exponent_Unsigned_Ghost_Base\n+        (Value : Uns;\n+         Exp   : Natural;\n+         Base  : Uns := 10)\n+         renames P_Lemma_Exponent_Unsigned_Ghost_Base;\n+      procedure Lemma_Exponent_Unsigned_Ghost_Overflow\n+        (Value : Uns;\n+         Exp   : Natural;\n+         Base  : Uns := 10)\n+         renames P_Lemma_Exponent_Unsigned_Ghost_Overflow;\n+      procedure Lemma_Exponent_Unsigned_Ghost_Step\n+        (Value : Uns;\n+         Exp   : Natural;\n+         Base  : Uns := 10)\n+         renames P_Lemma_Exponent_Unsigned_Ghost_Step;\n+\n+      function Scan_Raw_Unsigned_Ghost\n+        (Str      : String;\n+         From, To : Integer) return Uns\n+         renames P_Scan_Raw_Unsigned_Ghost;\n+      procedure Lemma_Scan_Based_Number_Ghost_Base\n+        (Str      : String;\n+         From, To : Integer;\n+         Base     : Uns := 10;\n+         Acc      : Uns := 0)\n+         renames P_Lemma_Scan_Based_Number_Ghost_Base;\n+      procedure Lemma_Scan_Based_Number_Ghost_Underscore\n+        (Str      : String;\n          From, To : Integer;\n          Base     : Uns := 10;\n          Acc      : Uns := 0)\n+         renames P_Lemma_Scan_Based_Number_Ghost_Underscore;\n+      procedure Lemma_Scan_Based_Number_Ghost_Overflow\n+        (Str      : String;\n+         From, To : Integer;\n+         Base     : Uns := 10;\n+         Acc      : Uns := 0)\n+         renames P_Lemma_Scan_Based_Number_Ghost_Overflow;\n+      procedure Lemma_Scan_Based_Number_Ghost_Step\n+        (Str      : String;\n+         From, To : Integer;\n+         Base     : Uns := 10;\n+         Acc      : Uns := 0)\n+         renames P_Lemma_Scan_Based_Number_Ghost_Step;\n+\n+      function Raw_Unsigned_Last_Ghost\n+        (Str      : String;\n+         From, To : Integer) return Positive\n+         renames P_Raw_Unsigned_Last_Ghost;\n+      function Only_Decimal_Ghost\n+        (Str      : String;\n+         From, To : Integer) return Boolean\n+         renames P_Only_Decimal_Ghost;\n+      function Scan_Based_Number_Ghost\n+        (Str      : String;\n+         From, To : Integer;\n+         Base     : Uns := 10;\n+         Acc      : Uns := 0) return Uns_Option\n+         renames P_Scan_Based_Number_Ghost;\n+      function Is_Unsigned_Ghost (Str : String) return Boolean\n+         renames P_Is_Unsigned_Ghost;\n+      function Is_Value_Unsigned_Ghost\n+        (Str : String;\n+         Val : Uns) return Boolean\n+         renames P_Is_Value_Unsigned_Ghost;\n+\n+      procedure Prove_Scan_Only_Decimal_Ghost\n+        (Str : String;\n+         Val : Uns)\n+         renames P_Prove_Scan_Only_Decimal_Ghost;\n+      procedure Prove_Scan_Based_Number_Ghost_Eq\n+        (Str1, Str2 : String;\n+         From, To   : Integer;\n+         Base       : Uns := 10;\n+         Acc        : Uns := 0)\n+      renames P_Prove_Scan_Based_Number_Ghost_Eq;\n+   end Uns_Params;\n+\n+   --  Bundle Int type with other types, constants and subprograms used in\n+   --  ghost code, so that this package can be instantiated once and used\n+   --  multiple times as generic formal for a given Int type.\n+   generic\n+      type Int is range <>;\n+      type Uns is mod <>;\n+\n+      with package P_Uns_Params is new System.Val_Util.Uns_Params\n+        (Uns => Uns, others => <>)\n+         with Ghost;\n+\n+      with function P_Abs_Uns_Of_Int (Val : Int) return Uns\n+         with Ghost;\n+      with function P_Is_Int_Of_Uns\n+        (Minus : Boolean;\n+         Uval  : Uns;\n+         Val   : Int)\n+      return Boolean\n          with Ghost;\n-      with procedure Prove_Scan_Only_Decimal_Ghost (Str : String; Val : Int)\n+      with function P_Is_Integer_Ghost (Str : String) return Boolean\n          with Ghost;\n-      with function Abs_Uns_Of_Int (Val : Int) return Uns\n+      with function P_Is_Value_Integer_Ghost\n+        (Str : String;\n+         Val : Int) return Boolean\n          with Ghost;\n-      with function Value_Integer (Str : String) return Int\n+      with procedure P_Prove_Scan_Only_Decimal_Ghost (Str : String; Val : Int)\n          with Ghost;\n \n    package Int_Params is\n+      package Uns_Params renames P_Uns_Params;\n+      function Abs_Uns_Of_Int (Val : Int) return Uns renames\n+        P_Abs_Uns_Of_Int;\n+      function Is_Int_Of_Uns\n+        (Minus : Boolean;\n+         Uval  : Uns;\n+         Val   : Int)\n+      return Boolean\n+         renames P_Is_Int_Of_Uns;\n+      function Is_Integer_Ghost (Str : String) return Boolean renames\n+        P_Is_Integer_Ghost;\n+      function Is_Value_Integer_Ghost\n+        (Str : String;\n+         Val : Int) return Boolean\n+         renames P_Is_Value_Integer_Ghost;\n+      procedure Prove_Scan_Only_Decimal_Ghost (Str : String; Val : Int) renames\n+        P_Prove_Scan_Only_Decimal_Ghost;\n    end Int_Params;\n \n private"}, {"sha": "1a870b9b99709ef345ee850989cd01a27e410776", "filename": "gcc/ada/libgnat/s-vauspe.adb", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-vauspe.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-vauspe.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vauspe.adb?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -0,0 +1,198 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                   S Y S T E M . V A L U E _ U _ S P E C                  --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2022-2022, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Assertion_Policy (Pre                => Ignore,\n+                         Post               => Ignore,\n+                         Contract_Cases     => Ignore,\n+                         Ghost              => Ignore,\n+                         Subprogram_Variant => Ignore);\n+\n+package body System.Value_U_Spec with SPARK_Mode is\n+\n+   -----------------------------\n+   -- Exponent_Unsigned_Ghost --\n+   -----------------------------\n+\n+   function Exponent_Unsigned_Ghost\n+     (Value : Uns;\n+      Exp   : Natural;\n+      Base  : Uns := 10) return Uns_Option\n+   is\n+      (if Exp = 0 or Value = 0 then (Overflow => False, Value => Value)\n+       elsif Scan_Overflows_Ghost (0, Base, Value) then (Overflow => True)\n+       else Exponent_Unsigned_Ghost (Value * Base, Exp - 1, Base));\n+\n+   ---------------------\n+   -- Last_Hexa_Ghost --\n+   ---------------------\n+\n+   function Last_Hexa_Ghost (Str : String) return Positive is\n+   begin\n+      for J in Str'Range loop\n+         if Str (J) not in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' | '_' then\n+            return J - 1;\n+         end if;\n+\n+         pragma Loop_Invariant\n+           (for all K in Str'First .. J =>\n+              Str (K) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' | '_');\n+      end loop;\n+\n+      return Str'Last;\n+   end Last_Hexa_Ghost;\n+\n+   -----------------------------\n+   -- Lemmas with null bodies --\n+   -----------------------------\n+\n+   procedure Lemma_Scan_Based_Number_Ghost_Base\n+     (Str      : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0)\n+   is null;\n+\n+   procedure Lemma_Scan_Based_Number_Ghost_Underscore\n+     (Str      : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0)\n+   is null;\n+\n+   procedure Lemma_Scan_Based_Number_Ghost_Overflow\n+     (Str      : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0)\n+   is null;\n+\n+   procedure Lemma_Scan_Based_Number_Ghost_Step\n+     (Str      : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0)\n+   is null;\n+\n+   procedure Lemma_Exponent_Unsigned_Ghost_Base\n+     (Value : Uns;\n+      Exp   : Natural;\n+      Base  : Uns := 10)\n+   is null;\n+\n+   procedure Lemma_Exponent_Unsigned_Ghost_Overflow\n+     (Value : Uns;\n+      Exp   : Natural;\n+      Base  : Uns := 10)\n+   is null;\n+\n+   procedure Lemma_Exponent_Unsigned_Ghost_Step\n+     (Value : Uns;\n+      Exp   : Natural;\n+      Base  : Uns := 10)\n+   is null;\n+\n+   --------------------------------------\n+   -- Prove_Scan_Based_Number_Ghost_Eq --\n+   --------------------------------------\n+\n+   procedure Prove_Scan_Based_Number_Ghost_Eq\n+     (Str1, Str2 : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0)\n+   is\n+   begin\n+      if From > To then\n+         null;\n+      elsif Str1 (From) = '_' then\n+         Prove_Scan_Based_Number_Ghost_Eq\n+           (Str1, Str2, From + 1, To, Base, Acc);\n+      elsif Scan_Overflows_Ghost\n+        (Hexa_To_Unsigned_Ghost (Str1 (From)), Base, Acc)\n+      then\n+         null;\n+      else\n+         Prove_Scan_Based_Number_Ghost_Eq\n+           (Str1, Str2, From + 1, To, Base,\n+            Base * Acc + Hexa_To_Unsigned_Ghost (Str1 (From)));\n+      end if;\n+   end Prove_Scan_Based_Number_Ghost_Eq;\n+\n+   -----------------------------------\n+   -- Prove_Scan_Only_Decimal_Ghost --\n+   -----------------------------------\n+\n+   procedure Prove_Scan_Only_Decimal_Ghost\n+     (Str : String;\n+      Val : Uns)\n+   is\n+      pragma Assert (Str (Str'First + 1) /= ' ');\n+      Non_Blank : constant Positive := First_Non_Space_Ghost\n+        (Str, Str'First, Str'Last);\n+      pragma Assert (Non_Blank = Str'First + 1);\n+      Fst_Num   : constant Positive :=\n+        (if Str (Non_Blank) = '+' then Non_Blank + 1 else Non_Blank);\n+      pragma Assert (Fst_Num = Str'First + 1);\n+   begin\n+      pragma Assert\n+        (Is_Raw_Unsigned_Format_Ghost (Str (Fst_Num .. Str'Last)));\n+      pragma Assert\n+        (Scan_Split_No_Overflow_Ghost (Str, Str'First + 1, Str'Last));\n+      pragma Assert\n+        ((Val, 10, 0) = Scan_Split_Value_Ghost (Str, Str'First + 1, Str'Last));\n+      pragma Assert\n+        (Raw_Unsigned_No_Overflow_Ghost (Str, Fst_Num, Str'Last));\n+      pragma Assert (Val = Exponent_Unsigned_Ghost (Val, 0, 10).Value);\n+      pragma Assert (Is_Unsigned_Ghost (Str));\n+      pragma Assert (Is_Value_Unsigned_Ghost (Str, Val));\n+   end Prove_Scan_Only_Decimal_Ghost;\n+\n+   -----------------------------\n+   -- Scan_Based_Number_Ghost --\n+   -----------------------------\n+\n+   function Scan_Based_Number_Ghost\n+     (Str      : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0) return Uns_Option\n+   is\n+      (if From > To then (Overflow => False, Value => Acc)\n+       elsif Str (From) = '_'\n+       then Scan_Based_Number_Ghost (Str, From + 1, To, Base, Acc)\n+       elsif Scan_Overflows_Ghost\n+         (Hexa_To_Unsigned_Ghost (Str (From)), Base, Acc)\n+       then (Overflow => True)\n+       else Scan_Based_Number_Ghost\n+         (Str, From + 1, To, Base,\n+          Base * Acc + Hexa_To_Unsigned_Ghost (Str (From))));\n+\n+end System.Value_U_Spec;"}, {"sha": "0d5c19e8c532685ceb026ebce28c1142721e54da", "filename": "gcc/ada/libgnat/s-vauspe.ads", "status": "added", "additions": 639, "deletions": 0, "changes": 639, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-vauspe.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ae28dca103a45bb97ec5b47acad9b9380d1113/gcc%2Fada%2Flibgnat%2Fs-vauspe.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vauspe.ads?ref=b3ae28dca103a45bb97ec5b47acad9b9380d1113", "patch": "@@ -0,0 +1,639 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                   S Y S T E M . V A L U E _ U _ S P E C                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2022-2022, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the specification entities using for the formal\n+--  verification of the routines for scanning modular Unsigned values.\n+\n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre                => Ignore,\n+                         Post               => Ignore,\n+                         Contract_Cases     => Ignore,\n+                         Ghost              => Ignore,\n+                         Subprogram_Variant => Ignore);\n+\n+with System.Val_Util; use System.Val_Util;\n+\n+generic\n+\n+   type Uns is mod <>;\n+\n+package System.Value_U_Spec with\n+   Ghost,\n+   SPARK_Mode,\n+   Annotate => (GNATprove, Always_Return)\n+is\n+   pragma Preelaborate;\n+\n+   type Uns_Option (Overflow : Boolean := False) is record\n+      case Overflow is\n+         when True =>\n+            null;\n+         when False =>\n+            Value : Uns := 0;\n+      end case;\n+   end record;\n+\n+   function Wrap_Option (Value : Uns) return Uns_Option is\n+     (Overflow => False, Value => Value);\n+\n+   function Only_Decimal_Ghost\n+     (Str      : String;\n+      From, To : Integer)\n+      return Boolean\n+   is\n+      (for all J in From .. To => Str (J) in '0' .. '9')\n+   with\n+     Pre => From > To or else (From >= Str'First and then To <= Str'Last);\n+   --  Ghost function that returns True if S has only decimal characters\n+   --  from index From to index To.\n+\n+   function Only_Hexa_Ghost (Str : String; From, To : Integer) return Boolean\n+   is\n+      (for all J in From .. To =>\n+          Str (J) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' | '_')\n+   with\n+     Pre => From > To or else (From >= Str'First and then To <= Str'Last);\n+   --  Ghost function that returns True if S has only hexadecimal characters\n+   --  from index From to index To.\n+\n+   function Last_Hexa_Ghost (Str : String) return Positive\n+   with\n+     Pre  => Str /= \"\"\n+       and then Str (Str'First) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F',\n+     Post => Last_Hexa_Ghost'Result in Str'Range\n+       and then (if Last_Hexa_Ghost'Result < Str'Last then\n+                   Str (Last_Hexa_Ghost'Result + 1) not in\n+                     '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' | '_')\n+       and then Only_Hexa_Ghost (Str, Str'First, Last_Hexa_Ghost'Result);\n+   --  Ghost function that returns the index of the last character in S that\n+   --  is either an hexadecimal digit or an underscore, which necessarily\n+   --  exists given the precondition on Str.\n+\n+   function Is_Based_Format_Ghost (Str : String) return Boolean\n+   is\n+     (Str /= \"\"\n+        and then Str (Str'First) in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F'\n+        and then\n+        (declare\n+           L : constant Positive := Last_Hexa_Ghost (Str);\n+         begin\n+           Str (L) /= '_'\n+             and then (for all J in Str'First .. L =>\n+                         (if Str (J) = '_' then Str (J + 1) /= '_'))));\n+   --  Ghost function that determines if Str has the correct format for a\n+   --  based number, consisting in a sequence of hexadecimal digits possibly\n+   --  separated by single underscores. It may be followed by other characters.\n+\n+   function Hexa_To_Unsigned_Ghost (X : Character) return Uns is\n+     (case X is\n+         when '0' .. '9' => Character'Pos (X) - Character'Pos ('0'),\n+         when 'a' .. 'f' => Character'Pos (X) - Character'Pos ('a') + 10,\n+         when 'A' .. 'F' => Character'Pos (X) - Character'Pos ('A') + 10,\n+         when others     => raise Program_Error)\n+   with\n+     Pre => X in '0' .. '9' | 'a' .. 'f' | 'A' .. 'F';\n+   --  Ghost function that computes the value corresponding to an hexadecimal\n+   --  digit.\n+\n+   function Scan_Overflows_Ghost\n+     (Digit : Uns;\n+      Base  : Uns;\n+      Acc   : Uns) return Boolean\n+   is\n+     (Digit >= Base\n+      or else Acc > Uns'Last / Base\n+      or else Uns'Last - Digit < Base * Acc);\n+   --  Ghost function which returns True if Digit + Base * Acc overflows or\n+   --  Digit is greater than Base, as this is used by the algorithm for the\n+   --  test of overflow.\n+\n+   function Scan_Based_Number_Ghost\n+     (Str      : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0) return Uns_Option\n+   with\n+     Subprogram_Variant => (Increases => From),\n+     Pre  => Str'Last /= Positive'Last\n+         and then\n+           (From > To or else (From >= Str'First and then To <= Str'Last))\n+         and then Only_Hexa_Ghost (Str, From, To);\n+   --  Ghost function that recursively computes the based number in Str,\n+   --  assuming Acc has been scanned already and scanning continues at index\n+   --  From.\n+\n+   --  Lemmas unfolding the recursive definition of Scan_Based_Number_Ghost\n+\n+   procedure Lemma_Scan_Based_Number_Ghost_Base\n+     (Str      : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0)\n+   with\n+     Global => null,\n+     Pre  => Str'Last /= Positive'Last\n+         and then\n+           (From > To or else (From >= Str'First and then To <= Str'Last))\n+         and then Only_Hexa_Ghost (Str, From, To),\n+     Post =>\n+      (if From > To\n+       then Scan_Based_Number_Ghost (Str, From, To, Base, Acc) =\n+         (Overflow => False, Value => Acc));\n+   --  Base case: Scan_Based_Number_Ghost returns Acc if From is bigger than To\n+\n+   procedure Lemma_Scan_Based_Number_Ghost_Underscore\n+     (Str      : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0)\n+   with\n+     Global => null,\n+     Pre  => Str'Last /= Positive'Last\n+         and then\n+           (From > To or else (From >= Str'First and then To <= Str'Last))\n+         and then Only_Hexa_Ghost (Str, From, To),\n+     Post =>\n+      (if From <= To and then Str (From) = '_'\n+       then Scan_Based_Number_Ghost (Str, From, To, Base, Acc) =\n+           Scan_Based_Number_Ghost (Str, From + 1, To, Base, Acc));\n+   --  Underscore case: underscores are ignored while scanning\n+\n+   procedure Lemma_Scan_Based_Number_Ghost_Overflow\n+     (Str      : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0)\n+   with\n+     Global => null,\n+     Pre  => Str'Last /= Positive'Last\n+         and then\n+           (From > To or else (From >= Str'First and then To <= Str'Last))\n+         and then Only_Hexa_Ghost (Str, From, To),\n+     Post =>\n+      (if From <= To\n+         and then Str (From) /= '_'\n+         and then Scan_Overflows_Ghost\n+           (Hexa_To_Unsigned_Ghost (Str (From)), Base, Acc)\n+       then Scan_Based_Number_Ghost (Str, From, To, Base, Acc) =\n+           (Overflow => True));\n+   --  Overflow case: scanning a digit which causes an overflow\n+\n+   procedure Lemma_Scan_Based_Number_Ghost_Step\n+     (Str      : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0)\n+   with\n+     Global => null,\n+     Pre  => Str'Last /= Positive'Last\n+         and then\n+           (From > To or else (From >= Str'First and then To <= Str'Last))\n+         and then Only_Hexa_Ghost (Str, From, To),\n+     Post =>\n+      (if From <= To\n+         and then Str (From) /= '_'\n+         and then not Scan_Overflows_Ghost\n+           (Hexa_To_Unsigned_Ghost (Str (From)), Base, Acc)\n+       then Scan_Based_Number_Ghost (Str, From, To, Base, Acc) =\n+         Scan_Based_Number_Ghost\n+           (Str, From + 1, To, Base,\n+            Base * Acc + Hexa_To_Unsigned_Ghost (Str (From))));\n+   --  Normal case: scanning a digit without overflows\n+\n+   function Exponent_Unsigned_Ghost\n+     (Value : Uns;\n+      Exp   : Natural;\n+      Base  : Uns := 10) return Uns_Option\n+   with\n+     Subprogram_Variant => (Decreases => Exp);\n+   --  Ghost function that recursively computes Value * Base ** Exp\n+\n+   --  Lemmas unfolding the recursive definition of Exponent_Unsigned_Ghost\n+\n+   procedure Lemma_Exponent_Unsigned_Ghost_Base\n+     (Value : Uns;\n+      Exp   : Natural;\n+      Base  : Uns := 10)\n+   with\n+     Post =>\n+       (if Exp = 0 or Value = 0\n+        then Exponent_Unsigned_Ghost (Value, Exp, Base) =\n+          (Overflow => False, Value => Value));\n+   --  Base case: Exponent_Unsigned_Ghost returns 0 if Value or Exp is 0\n+\n+   procedure Lemma_Exponent_Unsigned_Ghost_Overflow\n+     (Value : Uns;\n+      Exp   : Natural;\n+      Base  : Uns := 10)\n+   with\n+     Post =>\n+       (if Exp /= 0\n+          and then Value /= 0\n+          and then Scan_Overflows_Ghost (0, Base, Value)\n+        then Exponent_Unsigned_Ghost (Value, Exp, Base) = (Overflow => True));\n+   --  Overflow case: the next multiplication overflows\n+\n+   procedure Lemma_Exponent_Unsigned_Ghost_Step\n+     (Value : Uns;\n+      Exp   : Natural;\n+      Base  : Uns := 10)\n+   with\n+     Post =>\n+       (if Exp /= 0\n+          and then Value /= 0\n+          and then not Scan_Overflows_Ghost (0, Base, Value)\n+        then Exponent_Unsigned_Ghost (Value, Exp, Base) =\n+            Exponent_Unsigned_Ghost (Value * Base, Exp - 1, Base));\n+   --  Normal case: exponentiation without overflows\n+\n+   function Is_Raw_Unsigned_Format_Ghost (Str : String) return Boolean is\n+     (Is_Natural_Format_Ghost (Str)\n+      and then\n+        (declare\n+           Last_Num_Init   : constant Integer := Last_Number_Ghost (Str);\n+           Starts_As_Based : constant Boolean :=\n+             Last_Num_Init < Str'Last - 1\n+             and then Str (Last_Num_Init + 1) in '#' | ':'\n+             and then Str (Last_Num_Init + 2) in\n+               '0' .. '9' | 'a' .. 'f' | 'A' .. 'F';\n+           Last_Num_Based  : constant Integer :=\n+             (if Starts_As_Based\n+              then Last_Hexa_Ghost (Str (Last_Num_Init + 2 .. Str'Last))\n+              else Last_Num_Init);\n+           Is_Based        : constant Boolean :=\n+             Starts_As_Based\n+             and then Last_Num_Based < Str'Last\n+             and then Str (Last_Num_Based + 1) = Str (Last_Num_Init + 1);\n+           First_Exp       : constant Integer :=\n+             (if Is_Based then Last_Num_Based + 2 else Last_Num_Init + 1);\n+         begin\n+           (if Starts_As_Based then\n+              Is_Based_Format_Ghost (Str (Last_Num_Init + 2 .. Str'Last))\n+              and then Last_Num_Based < Str'Last)\n+            and then Is_Opt_Exponent_Format_Ghost\n+              (Str (First_Exp .. Str'Last))))\n+   with\n+     Pre  => Str'Last /= Positive'Last;\n+   --  Ghost function that determines if Str has the correct format for an\n+   --  unsigned number without a sign character.\n+   --  It is a natural number in base 10, optionally followed by a based\n+   --  number surrounded by delimiters # or :, optionally followed by an\n+   --  exponent part.\n+\n+   type Split_Value_Ghost is record\n+      Value : Uns;\n+      Base  : Uns;\n+      Expon : Natural;\n+   end record;\n+\n+   function Scan_Split_No_Overflow_Ghost\n+     (Str      : String;\n+      From, To : Integer)\n+      return Boolean\n+   is\n+     (declare\n+        Last_Num_Init   : constant Integer :=\n+          Last_Number_Ghost (Str (From .. To));\n+        Init_Val        : constant Uns_Option :=\n+          Scan_Based_Number_Ghost (Str, From, Last_Num_Init);\n+        Starts_As_Based : constant Boolean :=\n+          Last_Num_Init < To - 1\n+          and then Str (Last_Num_Init + 1) in '#' | ':'\n+          and then Str (Last_Num_Init + 2) in\n+          '0' .. '9' | 'a' .. 'f' | 'A' .. 'F';\n+        Last_Num_Based  : constant Integer :=\n+          (if Starts_As_Based\n+           then Last_Hexa_Ghost (Str (Last_Num_Init + 2 .. To))\n+           else Last_Num_Init);\n+        Based_Val       : constant Uns_Option :=\n+          (if Starts_As_Based and then not Init_Val.Overflow\n+           then Scan_Based_Number_Ghost\n+             (Str, Last_Num_Init + 2, Last_Num_Based, Init_Val.Value)\n+           else Init_Val);\n+      begin\n+        not Init_Val.Overflow\n+        and then\n+          (Last_Num_Init >= To - 1\n+           or else Str (Last_Num_Init + 1) not in '#' | ':'\n+           or else Init_Val.Value in 2 .. 16)\n+        and then\n+          (not Starts_As_Based\n+           or else not Based_Val.Overflow))\n+   with\n+     Pre  => Str'Last /= Positive'Last\n+       and then From in Str'Range\n+       and then To in From .. Str'Last\n+       and then Str (From) in '0' .. '9';\n+   --  Ghost function that determines if an overflow might occur while scanning\n+   --  the representation of an unsigned number. The computation overflows if\n+   --  either:\n+   --    * The computation of the decimal part overflows,\n+   --    * The decimal part is followed by a valid delimiter for a based\n+   --      part, and the number corresponding to the base is not a valid base,\n+   --      or\n+   --    * The computation of the based part overflows.\n+\n+   pragma Warnings (Off, \"constant * is not referenced\");\n+   function Scan_Split_Value_Ghost\n+     (Str      : String;\n+      From, To : Integer)\n+      return Split_Value_Ghost\n+   is\n+     (declare\n+        Last_Num_Init   : constant Integer :=\n+          Last_Number_Ghost (Str (From .. To));\n+        Init_Val        : constant Uns_Option :=\n+          Scan_Based_Number_Ghost (Str, From, Last_Num_Init);\n+        Starts_As_Based : constant Boolean :=\n+          Last_Num_Init < To - 1\n+          and then Str (Last_Num_Init + 1) in '#' | ':'\n+          and then Str (Last_Num_Init + 2) in\n+          '0' .. '9' | 'a' .. 'f' | 'A' .. 'F';\n+        Last_Num_Based  : constant Integer :=\n+          (if Starts_As_Based\n+           then Last_Hexa_Ghost (Str (Last_Num_Init + 2 .. To))\n+           else Last_Num_Init);\n+        Is_Based        : constant Boolean :=\n+          Starts_As_Based\n+          and then Last_Num_Based < To\n+          and then Str (Last_Num_Based + 1) = Str (Last_Num_Init + 1);\n+        Based_Val       : constant Uns_Option :=\n+          (if Starts_As_Based and then not Init_Val.Overflow\n+           then Scan_Based_Number_Ghost\n+             (Str, Last_Num_Init + 2, Last_Num_Based, Init_Val.Value)\n+           else Init_Val);\n+        First_Exp       : constant Integer :=\n+          (if Is_Based then Last_Num_Based + 2 else Last_Num_Init + 1);\n+        Expon           : constant Natural :=\n+          (if Starts_As_Exponent_Format_Ghost (Str (First_Exp .. To))\n+           then Scan_Exponent_Ghost (Str (First_Exp .. To))\n+           else 0);\n+        Base            : constant Uns :=\n+          (if Is_Based then Init_Val.Value else 10);\n+        Value           : constant Uns :=\n+          (if Is_Based then Based_Val.Value else Init_Val.Value);\n+      begin\n+        (Value => Value, Base => Base, Expon => Expon))\n+   with\n+     Pre => Str'Last /= Positive'Last\n+       and then From in Str'Range\n+       and then To in From .. Str'Last\n+       and then Str (From) in '0' .. '9'\n+       and then Scan_Split_No_Overflow_Ghost (Str, From, To);\n+   --  Ghost function that scans an unsigned number without a sign character\n+   --  and return a record containing the values scanned for its value, its\n+   --  base, and its exponent.\n+   pragma Warnings (On, \"constant * is not referenced\");\n+\n+   function Raw_Unsigned_No_Overflow_Ghost\n+     (Str      : String;\n+      From, To : Integer)\n+      return Boolean\n+   is\n+     (Scan_Split_No_Overflow_Ghost (Str, From, To)\n+      and then\n+        (declare\n+           Val : constant Split_Value_Ghost := Scan_Split_Value_Ghost\n+             (Str, From, To);\n+         begin\n+           not Exponent_Unsigned_Ghost\n+             (Val.Value, Val.Expon, Val.Base).Overflow))\n+   with\n+     Pre => Str'Last /= Positive'Last\n+       and then From in Str'Range\n+       and then To in From .. Str'Last\n+       and then Str (From) in '0' .. '9';\n+   --  Ghost function that determines if the computation of the unsigned number\n+   --  represented by Str will overflow. The computation overflows if either:\n+   --    * The scan of the string overflows, or\n+   --    * The computation of the exponentiation overflows.\n+\n+   function Scan_Raw_Unsigned_Ghost\n+     (Str      : String;\n+      From, To : Integer)\n+      return Uns\n+   is\n+     (declare\n+        Val : constant Split_Value_Ghost := Scan_Split_Value_Ghost\n+          (Str, From, To);\n+      begin\n+        Exponent_Unsigned_Ghost (Val.Value, Val.Expon, Val.Base).Value)\n+   with\n+     Pre  => Str'Last /= Positive'Last\n+       and then From in Str'Range\n+       and then To in From .. Str'Last\n+       and then Str (From) in '0' .. '9'\n+       and then Raw_Unsigned_No_Overflow_Ghost (Str, From, To);\n+   --  Ghost function that scans an unsigned number without a sign character\n+\n+   function Raw_Unsigned_Last_Ghost\n+     (Str      : String;\n+      From, To : Integer)\n+      return Positive\n+   is\n+     (declare\n+        Last_Num_Init   : constant Integer :=\n+          Last_Number_Ghost (Str (From .. To));\n+        Starts_As_Based : constant Boolean :=\n+          Last_Num_Init < To - 1\n+          and then Str (Last_Num_Init + 1) in '#' | ':'\n+          and then Str (Last_Num_Init + 2) in\n+          '0' .. '9' | 'a' .. 'f' | 'A' .. 'F';\n+        Last_Num_Based  : constant Integer :=\n+          (if Starts_As_Based\n+           then Last_Hexa_Ghost (Str (Last_Num_Init + 2 .. To))\n+           else Last_Num_Init);\n+        Is_Based        : constant Boolean :=\n+          Starts_As_Based\n+          and then Last_Num_Based < To\n+          and then Str (Last_Num_Based + 1) = Str (Last_Num_Init + 1);\n+        First_Exp       : constant Integer :=\n+          (if Is_Based then Last_Num_Based + 2 else Last_Num_Init + 1);\n+      begin\n+        (if not Starts_As_Exponent_Format_Ghost (Str (First_Exp .. To))\n+         then First_Exp\n+         elsif Str (First_Exp + 1) in '-' | '+' then\n+           Last_Number_Ghost (Str (First_Exp + 2 .. To)) + 1\n+         else Last_Number_Ghost (Str (First_Exp + 1 .. To)) + 1))\n+   with\n+     Pre  => Str'Last /= Positive'Last\n+       and then From in Str'Range\n+       and then To in From .. Str'Last\n+       and then Str (From) in '0' .. '9';\n+   --  Ghost function that returns the position of the cursor once an unsigned\n+   --  number has been seen.\n+\n+   function Slide_To_1 (Str : String) return String\n+   with\n+     Post =>\n+       Only_Space_Ghost (Str, Str'First, Str'Last) =\n+       (for all J in Str'First .. Str'Last =>\n+          Slide_To_1'Result (J - Str'First + 1) = ' ');\n+   --  Slides Str so that it starts at 1\n+\n+   function Slide_If_Necessary (Str : String) return String is\n+     (if Str'Last = Positive'Last then Slide_To_1 (Str) else Str);\n+   --  If Str'Last = Positive'Last then slides Str so that it starts at 1\n+\n+   function Is_Unsigned_Ghost (Str : String) return Boolean is\n+     (declare\n+        Non_Blank : constant Positive := First_Non_Space_Ghost\n+          (Str, Str'First, Str'Last);\n+        Fst_Num   : constant Positive :=\n+          (if Str (Non_Blank) = '+' then Non_Blank + 1 else Non_Blank);\n+      begin\n+        Is_Raw_Unsigned_Format_Ghost (Str (Fst_Num .. Str'Last))\n+          and then Raw_Unsigned_No_Overflow_Ghost (Str, Fst_Num, Str'Last)\n+          and then Only_Space_Ghost\n+             (Str, Raw_Unsigned_Last_Ghost (Str, Fst_Num, Str'Last), Str'Last))\n+   with\n+       Pre => not Only_Space_Ghost (Str, Str'First, Str'Last)\n+       and then Str'Last /= Positive'Last;\n+   --  Ghost function that determines if Str has the correct format for an\n+   --  unsigned number, consisting in some blank characters, an optional\n+   --  + sign, a raw unsigned number which does not overflow and then some\n+   --  more blank characters.\n+\n+   function Is_Value_Unsigned_Ghost (Str : String; Val : Uns) return Boolean is\n+     (declare\n+        Non_Blank : constant Positive := First_Non_Space_Ghost\n+          (Str, Str'First, Str'Last);\n+        Fst_Num   : constant Positive :=\n+          (if Str (Non_Blank) = '+' then Non_Blank + 1 else Non_Blank);\n+      begin\n+        Val = Scan_Raw_Unsigned_Ghost (Str, Fst_Num, Str'Last))\n+   with\n+       Pre => not Only_Space_Ghost (Str, Str'First, Str'Last)\n+       and then Str'Last /= Positive'Last\n+       and then Is_Unsigned_Ghost (Str);\n+   --  Ghost function that returns True if Val is the value corresponding to\n+   --  the unsigned number represented by Str.\n+\n+   procedure Prove_Scan_Based_Number_Ghost_Eq\n+     (Str1, Str2 : String;\n+      From, To : Integer;\n+      Base     : Uns := 10;\n+      Acc      : Uns := 0)\n+   with\n+     Subprogram_Variant => (Increases => From),\n+     Pre  => Str1'Last /= Positive'Last\n+       and then Str2'Last /= Positive'Last\n+       and then\n+         (From > To or else (From >= Str1'First and then To <= Str1'Last))\n+       and then\n+         (From > To or else (From >= Str2'First and then To <= Str2'Last))\n+       and then Only_Hexa_Ghost (Str1, From, To)\n+       and then (for all J in From .. To => Str1 (J) = Str2 (J)),\n+     Post =>\n+       Scan_Based_Number_Ghost (Str1, From, To, Base, Acc)\n+         = Scan_Based_Number_Ghost (Str2, From, To, Base, Acc);\n+   --  Scan_Based_Number_Ghost returns the same value on two slices which are\n+   --  equal.\n+\n+   procedure Prove_Scan_Only_Decimal_Ghost\n+     (Str : String;\n+      Val : Uns)\n+   with\n+     Pre  => Str'Last /= Positive'Last\n+       and then Str'Length >= 2\n+       and then Str (Str'First) = ' '\n+       and then Only_Decimal_Ghost (Str, Str'First + 1, Str'Last)\n+       and then Scan_Based_Number_Ghost (Str, Str'First + 1, Str'Last)\n+         = Wrap_Option (Val),\n+     Post => Is_Unsigned_Ghost (Slide_If_Necessary (Str))\n+       and then\n+         Is_Value_Unsigned_Ghost (Slide_If_Necessary (Str), Val);\n+   --  Ghost lemma used in the proof of 'Image implementation, to prove that\n+   --  the result of Value_Unsigned on a decimal string is the same as the\n+   --  result of Scan_Based_Number_Ghost.\n+\n+   --  Bundle Uns type with other types, constants and subprograms used in\n+   --  ghost code, so that this package can be instantiated once and used\n+   --  multiple times as generic formal for a given Int type.\n+\n+   package Uns_Params is new System.Val_Util.Uns_Params\n+     (Uns                                        => Uns,\n+      P_Uns_Option                               => Uns_Option,\n+      P_Wrap_Option                              => Wrap_Option,\n+      P_Hexa_To_Unsigned_Ghost                   => Hexa_To_Unsigned_Ghost,\n+      P_Scan_Overflows_Ghost                     => Scan_Overflows_Ghost,\n+      P_Is_Raw_Unsigned_Format_Ghost             =>\n+         Is_Raw_Unsigned_Format_Ghost,\n+      P_Scan_Split_No_Overflow_Ghost             =>\n+         Scan_Split_No_Overflow_Ghost,\n+      P_Raw_Unsigned_No_Overflow_Ghost           =>\n+         Raw_Unsigned_No_Overflow_Ghost,\n+      P_Exponent_Unsigned_Ghost                  => Exponent_Unsigned_Ghost,\n+      P_Lemma_Exponent_Unsigned_Ghost_Base       =>\n+         Lemma_Exponent_Unsigned_Ghost_Base,\n+      P_Lemma_Exponent_Unsigned_Ghost_Overflow   =>\n+         Lemma_Exponent_Unsigned_Ghost_Overflow,\n+      P_Lemma_Exponent_Unsigned_Ghost_Step       =>\n+         Lemma_Exponent_Unsigned_Ghost_Step,\n+      P_Scan_Raw_Unsigned_Ghost                  => Scan_Raw_Unsigned_Ghost,\n+      P_Lemma_Scan_Based_Number_Ghost_Base       =>\n+         Lemma_Scan_Based_Number_Ghost_Base,\n+      P_Lemma_Scan_Based_Number_Ghost_Underscore =>\n+         Lemma_Scan_Based_Number_Ghost_Underscore,\n+      P_Lemma_Scan_Based_Number_Ghost_Overflow   =>\n+         Lemma_Scan_Based_Number_Ghost_Overflow,\n+      P_Lemma_Scan_Based_Number_Ghost_Step       =>\n+         Lemma_Scan_Based_Number_Ghost_Step,\n+      P_Raw_Unsigned_Last_Ghost                  => Raw_Unsigned_Last_Ghost,\n+      P_Only_Decimal_Ghost                       => Only_Decimal_Ghost,\n+      P_Scan_Based_Number_Ghost                  => Scan_Based_Number_Ghost,\n+      P_Is_Unsigned_Ghost                        =>\n+         Is_Unsigned_Ghost,\n+      P_Is_Value_Unsigned_Ghost                  =>\n+         Is_Value_Unsigned_Ghost,\n+      P_Prove_Scan_Only_Decimal_Ghost            =>\n+         Prove_Scan_Only_Decimal_Ghost,\n+      P_Prove_Scan_Based_Number_Ghost_Eq         =>\n+         Prove_Scan_Based_Number_Ghost_Eq);\n+\n+private\n+\n+   ----------------\n+   -- Slide_To_1 --\n+   ----------------\n+\n+   function Slide_To_1 (Str : String) return String is\n+      (declare\n+         Res : constant String (1 .. Str'Length) := Str;\n+       begin\n+         Res);\n+\n+end System.Value_U_Spec;"}]}