{"sha": "562f552bd866b17d9425b443d341e1fb5f7d1184", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYyZjU1MmJkODY2YjE3ZDk0MjViNDQzZDM0MWUxZmI1ZjdkMTE4NA==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-12-06T14:39:25Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-12-06T14:39:25Z"}, "message": "re PR target/51409 ([avr] Build fails if configured for other languages than from c-family)\n\n\tPR target/51409\n\tPR target/49868\n\t* config/avr/avr.h (ADDR_SPACE_PGM, ADDR_SPACE_PGM1,\n\tADDR_SPACE_PGM2, ADDR_SPACE_PGM3, ADDR_SPACE_PGM4,\n\tADDR_SPACE_PGM5, ADDR_SPACE_PGMX): Write as enum.\n\t(avr_addrspace_t): New typedef.\n\t(avr_addrspace): New declaration.\n\t* config/avr/avr-c.c (avr_toupper): New static function.\n\t(avr_register_target_pragmas, avr_cpu_cpp_builtins): Use\n\tavr_addrspace to get address space information.\n\t* config/avr/avr.c (avr_addrspace): New variable.\n\t(avr_out_lpm, avr_pgm_check_var_decl, avr_insert_attributes,\n\tavr_asm_named_section, avr_section_type_flags,\n\tavr_asm_select_section, avr_addr_space_address_mode, \n\tavr_addr_space_convert, avr_emit_movmemhi): Use it.\n\t(avr_addr_space_pointer_mode): Forward to avr_addr_space_address_mode.\n\t(avr_pgm_segment): Remove.\n\nFrom-SVN: r182051", "tree": {"sha": "0cfaea0687caa989b7c511a83be4f8466b623d68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cfaea0687caa989b7c511a83be4f8466b623d68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/562f552bd866b17d9425b443d341e1fb5f7d1184", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/562f552bd866b17d9425b443d341e1fb5f7d1184", "html_url": "https://github.com/Rust-GCC/gccrs/commit/562f552bd866b17d9425b443d341e1fb5f7d1184", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/562f552bd866b17d9425b443d341e1fb5f7d1184/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5de62d003b15021508b780a17c9cdac6c2e773a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5de62d003b15021508b780a17c9cdac6c2e773a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5de62d003b15021508b780a17c9cdac6c2e773a5"}], "stats": {"total": 281, "additions": 175, "deletions": 106}, "files": [{"sha": "2375361dd7d82142d46740c478afcde01c740861", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/562f552bd866b17d9425b443d341e1fb5f7d1184/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/562f552bd866b17d9425b443d341e1fb5f7d1184/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=562f552bd866b17d9425b443d341e1fb5f7d1184", "patch": "@@ -1,3 +1,23 @@\n+2011-12-06  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/51409\n+\tPR target/49868\n+\t* config/avr/avr.h (ADDR_SPACE_PGM, ADDR_SPACE_PGM1,\n+\tADDR_SPACE_PGM2, ADDR_SPACE_PGM3, ADDR_SPACE_PGM4,\n+\tADDR_SPACE_PGM5, ADDR_SPACE_PGMX): Write as enum.\n+\t(avr_addrspace_t): New typedef.\n+\t(avr_addrspace): New declaration.\n+\t* config/avr/avr-c.c (avr_toupper): New static function.\n+\t(avr_register_target_pragmas, avr_cpu_cpp_builtins): Use\n+\tavr_addrspace to get address space information.\n+\t* config/avr/avr.c (avr_addrspace): New variable.\n+\t(avr_out_lpm, avr_pgm_check_var_decl, avr_insert_attributes,\n+\tavr_asm_named_section, avr_section_type_flags,\n+\tavr_asm_select_section, avr_addr_space_address_mode, \n+\tavr_addr_space_convert, avr_emit_movmemhi): Use it.\n+\t(avr_addr_space_pointer_mode): Forward to avr_addr_space_address_mode.\n+\t(avr_pgm_segment): Remove.\n+\n 2011-12-06  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/50601"}, {"sha": "97a1a5ea861f9097a269482a84f9dc0aa25679e6", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 41, "deletions": 14, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/562f552bd866b17d9425b443d341e1fb5f7d1184/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/562f552bd866b17d9425b443d341e1fb5f7d1184/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=562f552bd866b17d9425b443d341e1fb5f7d1184", "patch": "@@ -36,16 +36,39 @@\n void\n avr_register_target_pragmas (void)\n {\n-  c_register_addr_space (\"__pgm\", ADDR_SPACE_PGM);\n-  c_register_addr_space (\"__pgm1\", ADDR_SPACE_PGM1);\n-  c_register_addr_space (\"__pgm2\", ADDR_SPACE_PGM2);\n-  c_register_addr_space (\"__pgm3\", ADDR_SPACE_PGM3);\n-  c_register_addr_space (\"__pgm4\", ADDR_SPACE_PGM4);\n-  c_register_addr_space (\"__pgm5\", ADDR_SPACE_PGM5);\n-  c_register_addr_space (\"__pgmx\", ADDR_SPACE_PGMX);\n+  int i;\n+\n+  gcc_assert (ADDR_SPACE_GENERIC == ADDR_SPACE_RAM);\n+\n+  /* Register address spaces.  The order must be the same as in the respective\n+     enum from avr.h (or designated initialized must be used in avr.c).  */\n+\n+  for (i = 0; avr_addrspace[i].name; i++)\n+    {\n+      gcc_assert (i == avr_addrspace[i].id);\n+\n+      if (!ADDR_SPACE_GENERIC_P (i))\n+        c_register_addr_space (avr_addrspace[i].name, avr_addrspace[i].id);\n+    }\n }\n \n \n+/* Transorm LO into uppercase and write the result to UP.\n+   You must provide enough space for UP.  Return UP.  */\n+\n+static char*\n+avr_toupper (char *up, const char *lo)\n+{\n+  char *up0 = up;\n+  \n+  for (; *lo; lo++, up++)\n+    *up = TOUPPER (*lo);\n+\n+  *up = '\\0';\n+\n+  return up0;\n+}\n+             \n /* Worker function for TARGET_CPU_CPP_BUILTINS.  */\n \n void\n@@ -117,13 +140,17 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n   \n   if (!strcmp (lang_hooks.name, \"GNU C\"))\n     {\n-      cpp_define (pfile, \"__PGM=__pgm\");\n-      cpp_define (pfile, \"__PGM1=__pgm1\");\n-      cpp_define (pfile, \"__PGM2=__pgm2\");\n-      cpp_define (pfile, \"__PGM3=__pgm3\");\n-      cpp_define (pfile, \"__PGM4=__pgm4\");\n-      cpp_define (pfile, \"__PGM5=__pgm5\");\n-      cpp_define (pfile, \"__PGMX=__pgmx\");\n+      int i;\n+      \n+      for (i = 0; avr_addrspace[i].name; i++)\n+        if (!ADDR_SPACE_GENERIC_P (i))\n+          {\n+            const char *name = avr_addrspace[i].name;\n+            char *Name = (char*) alloca (1 + strlen (name));\n+\n+            cpp_define_formatted (pfile, \"%s=%s\",\n+                                  avr_toupper (Name, name), name);\n+          }\n     }\n \n   /* Define builtin macros so that the user can"}, {"sha": "a6ef59f1fa7598c20de94680b2298b39c93c947c", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 80, "deletions": 83, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/562f552bd866b17d9425b443d341e1fb5f7d1184/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/562f552bd866b17d9425b443d341e1fb5f7d1184/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=562f552bd866b17d9425b443d341e1fb5f7d1184", "patch": "@@ -55,11 +55,39 @@\n /* Return true if STR starts with PREFIX and false, otherwise.  */\n #define STR_PREFIX_P(STR,PREFIX) (0 == strncmp (STR, PREFIX, strlen (PREFIX)))\n \n-/* The 4 bits starting at SECTION_MACH_DEP are reverved to store\n-   1 + flash segment where progmem data is to be located.\n-   For example, data with __pgm2 is stored as (1+2) * SECTION_MACH_DEP.  */\n+/* The 4 bits starting at SECTION_MACH_DEP are reserved to store the\n+   address space where data is to be located.\n+   As the only non-generic address spaces are all located in Flash,\n+   this can be used to test if data shall go into some .progmem* section.\n+   This must be the rightmost field of machine dependent section flags.  */\n #define AVR_SECTION_PROGMEM (0xf * SECTION_MACH_DEP)\n \n+/* Known address spaces.  The order must be the same as in the respective\n+   enum from avr.h (or designated initialized must be used).  */\n+const avr_addrspace_t avr_addrspace[] =\n+{\n+    { ADDR_SPACE_RAM,  0, 2, \"\"     ,   0 },\n+    { ADDR_SPACE_PGM,  1, 2, \"__pgm\",   0 },\n+    { ADDR_SPACE_PGM1, 1, 2, \"__pgm1\",  1 },\n+    { ADDR_SPACE_PGM2, 1, 2, \"__pgm2\",  2 },\n+    { ADDR_SPACE_PGM3, 1, 2, \"__pgm3\",  3 },\n+    { ADDR_SPACE_PGM4, 1, 2, \"__pgm4\",  4 },\n+    { ADDR_SPACE_PGM5, 1, 2, \"__pgm5\",  5 },\n+    { ADDR_SPACE_PGMX, 1, 3, \"__pgmx\",  0 },\n+    { 0              , 0, 0, NULL,      0 }\n+};\n+\n+/* Map 64-k Flash segment to section prefix.  */\n+static const char* const progmem_section_prefix[6] =\n+  {\n+    \".progmem.data\",\n+    \".progmem1.data\",\n+    \".progmem2.data\",\n+    \".progmem3.data\",\n+    \".progmem4.data\",\n+    \".progmem5.data\"\n+  };\n+\n \n /* Prototypes for local helper functions.  */\n \n@@ -132,19 +160,10 @@ const struct mcu_type_s *avr_current_device;\n /* Section to put switch tables in.  */\n static GTY(()) section *progmem_swtable_section;\n \n-/* Unnamed section associated to __attribute__((progmem)) aka. PROGMEM.  */\n+/* Unnamed sections associated to __attribute__((progmem)) aka. PROGMEM\n+   or to address space __pgm*.  */\n static GTY(()) section *progmem_section[6];\n \n-static const char * const progmem_section_prefix[6] =\n-  {\n-    \".progmem.data\",\n-    \".progmem1.data\",\n-    \".progmem2.data\",\n-    \".progmem3.data\",\n-    \".progmem4.data\",\n-    \".progmem5.data\"\n-  };\n-\n /* To track if code will use .bss and/or .data.  */\n bool avr_need_clear_bss_p = false;\n bool avr_need_copy_data_p = false;\n@@ -462,29 +481,6 @@ avr_scalar_mode_supported_p (enum machine_mode mode)\n }\n \n \n-/* Return the segment number of pgm address space AS, i.e.\n-   the 64k block it lives in.\n-   Return -1 if unknown, i.e. 24-bit AS in flash.\n-   Return -2 for anything else.  */\n-\n-static int\n-avr_pgm_segment (addr_space_t as)\n-{\n-  switch (as)\n-    {\n-    default: return -2;\n-\n-    case ADDR_SPACE_PGMX:  return -1;\n-    case ADDR_SPACE_PGM:   return 0;\n-    case ADDR_SPACE_PGM1:  return 1;\n-    case ADDR_SPACE_PGM2:  return 2;\n-    case ADDR_SPACE_PGM3:  return 3;\n-    case ADDR_SPACE_PGM4:  return 4;\n-    case ADDR_SPACE_PGM5:  return 5;\n-    }\n-}\n-\n-\n /* Return TRUE if DECL is a VAR_DECL located in Flash and FALSE, otherwise.  */\n \n static bool\n@@ -2582,34 +2578,39 @@ avr_out_lpm (rtx insn, rtx *op, int *plen)\n   int n_bytes = GET_MODE_SIZE (GET_MODE (dest));\n   int regno_dest;\n   int segment;\n+  RTX_CODE code;\n+  \n+  addr_space_t as;\n \n   if (plen)\n     *plen = 0;\n   \n   if (MEM_P (dest))\n     {\n       warning (0, \"writing to address space %qs not supported\",\n-               c_addr_space_name (MEM_ADDR_SPACE (dest)));\n+               avr_addrspace[MEM_ADDR_SPACE (dest)].name);\n       \n       return \"\";\n     }\n \n-  addr = XEXP (src, 0);\n-\n-  segment = avr_pgm_segment (MEM_ADDR_SPACE (src));\n+  as = MEM_ADDR_SPACE (src);\n \n-  gcc_assert (REG_P (dest)\n-              && ((segment >= 0\n-                   && (REG_P (addr) || POST_INC == GET_CODE (addr)))\n-                  || (GET_CODE (addr) == LO_SUM && segment == -1)));\n+  addr = XEXP (src, 0);\n+  code = GET_CODE (addr);\n \n-  if (segment == -1)\n+  gcc_assert (REG_P (dest));\n+  \n+  if (as == ADDR_SPACE_PGMX)\n     {\n       /* We are called from avr_out_xload because someone wrote\n          __pgmx on a device with just one flash segment.  */\n \n+      gcc_assert (LO_SUM == code);\n+\n       addr = XEXP (addr, 1);\n     }\n+  else\n+    gcc_assert (REG == code || POST_INC == code);\n \n   xop[0] = dest;\n   xop[1] = addr;\n@@ -2619,11 +2620,10 @@ avr_out_lpm (rtx insn, rtx *op, int *plen)\n \n   regno_dest = REGNO (dest);\n \n-  /* Cut down segment number to a number the device actually\n-     supports.  We do this late to preserve the address space's\n-     name for diagnostics.  */\n+  /* Cut down segment number to a number the device actually supports.\n+     We do this late to preserve the address space's name for diagnostics.  */\n \n-  segment %= avr_current_arch->n_segments;\n+  segment = avr_addrspace[as].segment % avr_current_arch->n_segments;\n \n   /* Set RAMPZ as needed.  */\n \n@@ -2652,14 +2652,17 @@ avr_out_lpm (rtx insn, rtx *op, int *plen)\n         }\n       \n       xop[4] = xstring_e;\n-    }\n \n-  if ((segment == 0 && !AVR_HAVE_LPMX)\n-      || (segment != 0 && !AVR_HAVE_ELPMX))\n+      if (!AVR_HAVE_ELPMX)\n+        return avr_out_lpm_no_lpmx (insn, xop, plen);\n+    }\n+  else if (!AVR_HAVE_LPMX)\n     {\n       return avr_out_lpm_no_lpmx (insn, xop, plen);\n     }\n \n+  /* We have [E]LPMX: Output reading from Flash the comfortable way.  */\n+\n   switch (GET_CODE (addr))\n     {\n     default:\n@@ -6919,10 +6922,10 @@ avr_pgm_check_var_decl (tree node)\n     {\n       if (TYPE_P (node))\n         error (\"pointer targeting address space %qs must be const in %qT\",\n-               c_addr_space_name (as), node);\n+               avr_addrspace[as].name, node);\n       else\n         error (\"pointer targeting address space %qs must be const in %s %q+D\",\n-               c_addr_space_name (as), reason, node);\n+               avr_addrspace[as].name, reason, node);\n     }\n \n   return reason == NULL;\n@@ -6959,7 +6962,7 @@ avr_insert_attributes (tree node, tree *attributes)\n           const char *reason = \"__attribute__((progmem))\";\n \n           if (!ADDR_SPACE_GENERIC_P (as))\n-            reason = c_addr_space_name (as);\n+            reason = avr_addrspace[as].name;\n           \n           if (avr_log.progmem)\n             avr_edump (\"\\n%?: %t\\n%t\\n\", node, node0);\n@@ -7136,7 +7139,8 @@ avr_asm_named_section (const char *name, unsigned int flags, tree decl)\n {\n   if (flags & AVR_SECTION_PROGMEM)\n     {\n-      int segment = (flags & AVR_SECTION_PROGMEM) / SECTION_MACH_DEP - 1;\n+      addr_space_t as = (flags & AVR_SECTION_PROGMEM) / SECTION_MACH_DEP;\n+      int segment = avr_addrspace[as].segment % avr_current_arch->n_segments;\n       const char *old_prefix = \".rodata\";\n       const char *new_prefix = progmem_section_prefix[segment];\n       const char *sname = new_prefix;\n@@ -7165,7 +7169,6 @@ avr_asm_named_section (const char *name, unsigned int flags, tree decl)\n static unsigned int\n avr_section_type_flags (tree decl, const char *name, int reloc)\n {\n-  int prog;\n   unsigned int flags = default_section_type_flags (decl, name, reloc);\n \n   if (STR_PREFIX_P (name, \".noinit\"))\n@@ -7179,16 +7182,20 @@ avr_section_type_flags (tree decl, const char *name, int reloc)\n     }\n \n   if (decl && DECL_P (decl)\n-      && (prog = avr_progmem_p (decl, DECL_ATTRIBUTES (decl)), prog))\n+      && avr_progmem_p (decl, DECL_ATTRIBUTES (decl)))\n     {\n-      int segment = 0;\n+      addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (decl));\n+\n+      /* Attribute progmem puts data in generic address space.\n+         Set section flags as if it was in __pgm to get the right\n+         section prefix in the remainder.  */\n \n-      if (prog == 1)\n-        segment = avr_pgm_segment (TYPE_ADDR_SPACE (TREE_TYPE (decl)));\n+      if (ADDR_SPACE_GENERIC_P (as))\n+        as = ADDR_SPACE_PGM;\n \n+      flags |= as * SECTION_MACH_DEP;\n       flags &= ~SECTION_WRITE;\n       flags &= ~SECTION_BSS;\n-      flags |= (1 + segment % avr_current_arch->n_segments) * SECTION_MACH_DEP;\n     }\n   \n   return flags;\n@@ -7198,8 +7205,7 @@ avr_section_type_flags (tree decl, const char *name, int reloc)\n /* Implement `TARGET_ENCODE_SECTION_INFO'.  */\n \n static void\n-avr_encode_section_info (tree decl, rtx rtl,\n-                         int new_decl_p)\n+avr_encode_section_info (tree decl, rtx rtl, int new_decl_p)\n {\n   /* In avr_handle_progmem_attribute, DECL_INITIAL is not yet\n      readily available, see PR34734.  So we postpone the warning\n@@ -7224,19 +7230,13 @@ avr_encode_section_info (tree decl, rtx rtl,\n static section *\n avr_asm_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align)\n {\n-  int prog;\n-  \n   section * sect = default_elf_select_section (decl, reloc, align);\n   \n   if (decl && DECL_P (decl)\n-      && (prog = avr_progmem_p (decl, DECL_ATTRIBUTES (decl)), prog))\n+      && avr_progmem_p (decl, DECL_ATTRIBUTES (decl)))\n     {\n-      int segment = 0;\n-      \n-      if (prog == 1)\n-        segment = avr_pgm_segment (TYPE_ADDR_SPACE (TREE_TYPE (decl)));\n-\n-      segment %= avr_current_arch->n_segments;\n+      addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (decl));\n+      int segment = avr_addrspace[as].segment % avr_current_arch->n_segments;\n       \n       if (sect->common.flags & SECTION_NAMED)\n         {\n@@ -9386,7 +9386,7 @@ avr_case_values_threshold (void)\n static enum machine_mode\n avr_addr_space_address_mode (addr_space_t as)\n {\n-  return as == ADDR_SPACE_PGMX ? PSImode : HImode;\n+  return avr_addrspace[as].pointer_size == 3 ? PSImode : HImode;\n }\n \n \n@@ -9395,7 +9395,7 @@ avr_addr_space_address_mode (addr_space_t as)\n static enum machine_mode\n avr_addr_space_pointer_mode (addr_space_t as)\n {\n-  return as == ADDR_SPACE_PGMX ? PSImode : HImode;\n+  return avr_addr_space_address_mode (as);\n }\n \n \n@@ -9573,7 +9573,7 @@ avr_addr_space_convert (rtx src, tree type_from, tree type_to)\n         }\n       else\n         {\n-          int segment = avr_pgm_segment (as_from) % n_segments;\n+          int segment = avr_addrspace[as_from].segment % n_segments;\n \n           new_src = gen_reg_rtx (PSImode);\n           emit_insn (gen_n_extendhipsi2 (new_src, GEN_INT (segment), src));\n@@ -9642,15 +9642,12 @@ avr_emit_movmemhi (rtx *xop)\n     }\n   else\n     {\n-      int seg = avr_pgm_segment (as);\n+      int segment = avr_addrspace[as].segment % avr_current_arch->n_segments;\n       \n       addr1 = a_src;\n \n-      if (seg > 0\n-          && seg % avr_current_arch->n_segments > 0)\n-        {\n-          a_hi8 = GEN_INT (seg % avr_current_arch->n_segments);\n-        }\n+      if (segment)\n+        a_hi8 = GEN_INT (segment);\n     }\n \n   if (a_hi8"}, {"sha": "14effd86a6fdfca9600133b7ccf77e6f30e6a66f", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/562f552bd866b17d9425b443d341e1fb5f7d1184/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/562f552bd866b17d9425b443d341e1fb5f7d1184/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=562f552bd866b17d9425b443d341e1fb5f7d1184", "patch": "@@ -133,6 +133,40 @@ extern const struct mcu_type_s *avr_current_device;\n extern const struct mcu_type_s avr_mcu_types[];\n extern const struct base_arch_s avr_arch_types[];\n \n+typedef struct\n+{\n+  /* Id of the address space as used in c_register_addr_space */\n+  unsigned char id;\n+\n+  /* Flavour of memory: 0 = RAM, 1 = Flash */\n+  int memory_class;\n+\n+  /* Width of pointer (in bytes) */\n+  int pointer_size;\n+\n+  /* Name of the address space as visible to the user */\n+  const char *name;\n+\n+  /* Segment (i.e. 64k memory chunk) number.  */\n+  int segment;\n+} avr_addrspace_t;\n+\n+extern const avr_addrspace_t avr_addrspace[];\n+\n+/* Known address spaces */\n+\n+enum\n+  {\n+    ADDR_SPACE_RAM,\n+    ADDR_SPACE_PGM,\n+    ADDR_SPACE_PGM1,\n+    ADDR_SPACE_PGM2,\n+    ADDR_SPACE_PGM3,\n+    ADDR_SPACE_PGM4,\n+    ADDR_SPACE_PGM5,\n+    ADDR_SPACE_PGMX\n+  };\n+\n #define TARGET_CPU_CPP_BUILTINS()\tavr_cpu_cpp_builtins (pfile)\n \n #define AVR_HAVE_JMP_CALL (avr_current_arch->have_jmp_call && !TARGET_SHORT_CALLS)\n@@ -401,15 +435,6 @@ typedef struct avr_args {\n \n #define NO_FUNCTION_CSE\n \n-\n-#define ADDR_SPACE_PGM  1\n-#define ADDR_SPACE_PGM1 2\n-#define ADDR_SPACE_PGM2 3\n-#define ADDR_SPACE_PGM3 4\n-#define ADDR_SPACE_PGM4 5\n-#define ADDR_SPACE_PGM5 6\n-#define ADDR_SPACE_PGMX 7\n-\n #define REGISTER_TARGET_PRAGMAS()                                       \\\n   do {                                                                  \\\n     avr_register_target_pragmas();                                      \\"}]}