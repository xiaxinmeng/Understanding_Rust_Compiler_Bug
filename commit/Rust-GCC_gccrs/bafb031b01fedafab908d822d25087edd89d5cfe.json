{"sha": "bafb031b01fedafab908d822d25087edd89d5cfe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFmYjAzMWIwMWZlZGFmYWI5MDhkODIyZDI1MDg3ZWRkODlkNWNmZQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-02-20T00:17:04Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-02-20T00:17:04Z"}, "message": "sparc.h (TARGET_SWITCHES): Add -m{,no-}impure-text.\n\n\t* sparc/sparc.h (TARGET_SWITCHES): Add -m{,no-}impure-text.\n\t(MASK_IMPURE_TEXT, TARGET_IMPURE_TEXT): Define.\n\t(LINK_SPEC): Only add `-assert pure-text' if -mimpure-text wasn't used.\n\n\t* sparc/sparc.h (TARGET_CPU_sparc{,let,lite,64}): Define.\n\t({CPP,ASM}_DEFAULT_SPEC): Set from TARGET_CPU_foo.\n\t(SPARC_ARCH64 CPP_PREDEFINES): Define __arch64__.\n\t(CPP_SPEC): Add %(cpp_cpu).\n\t(CPP_CPU_SPEC): Define.\n\t(CC1_SPEC): Convert -m<cpu> to -mcpu=<cpu>.\n\t(ASM_SPEC): Add %(asm_cpu).\n\t(ASM_CPU_SPEC): Define.\n\t(EXTRA_SPECS,SUBTARGET_EXTRA_SPECS): Define.\n\t(OVERRIDE_OPTIONS): Call SUBTARGET_OVERRIDE_OPTIONS after\n\tsparc_override_options.\n\t({MASK,TARGET}_SUPERSPARC): Delete.\n\t({MASK,TARGET}_SPARCLET): Define.\n\t(MASK_ISA): Renamed from MASK_CPUS.\n\t({MASK,TARGET}_FRW): Delete.\n\t(TARGET_SWITCHES): Delete no-{v8,sparclite}.\n\t(sparc_cpu,sparc_cpu_string): Declare.\n\t({SUB,}TARGET_OPTIONS): Define.\n\t(FIXED_REGISTERS): Add definitions for sparc64 in 32 bit mode.\n\t(CONDITIONAL_REGISTER_USAGE): Don't set fixed_regs[234] if sparc64.\n\tDon't set call_used_regs[48..80] for sparc64 in 32 bit mode.\n\tDon't clobber fixed_regs[234] if -ffixed- was passed.\n\t(FRAME_POINTER_REQUIRED,INITIAL_FRAME_POINTER_OFFSET,\n\tBASE_{INCOMING_ARG,OUTGOING_VALUE}_REG,INCOMING_REGNO,OUTGOING_REGNO,\n\tFUNCTION_{PROLOGUE,EPILOGUE},DELAY_SLOTS_FOR_EPILOGUE): TARGET_FRW\n\trenamed to TARGET_FLAT.\n\t(ADJUST_COST): Change test for supersparc.\n\nFrom-SVN: r11320", "tree": {"sha": "5ea92d6619987efd5645e39db55cdccff89692be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ea92d6619987efd5645e39db55cdccff89692be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bafb031b01fedafab908d822d25087edd89d5cfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bafb031b01fedafab908d822d25087edd89d5cfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bafb031b01fedafab908d822d25087edd89d5cfe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bafb031b01fedafab908d822d25087edd89d5cfe/comments", "author": null, "committer": null, "parents": [{"sha": "f1fe6b073d79ddf86e58f7bc59ac1e181105fb6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1fe6b073d79ddf86e58f7bc59ac1e181105fb6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1fe6b073d79ddf86e58f7bc59ac1e181105fb6b"}], "stats": {"total": 333, "additions": 223, "deletions": 110}, "files": [{"sha": "07e3d5254b7ad31afb22b7f3defc0cf51333aa69", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 223, "deletions": 110, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bafb031b01fedafab908d822d25087edd89d5cfe/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bafb031b01fedafab908d822d25087edd89d5cfe/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=bafb031b01fedafab908d822d25087edd89d5cfe", "patch": "@@ -55,34 +55,57 @@ Boston, MA 02111-1307, USA.  */\n #define SPARC_ARCH64 0\n #endif\n \n+/* Values of TARGET_CPU_DEFAULT, set via -D in the Makefile.  */\n+#define TARGET_CPU_sparc     0\n+#define TARGET_CPU_sparclet  1\n+#define TARGET_CPU_sparclite 2\n+#define TARGET_CPU_sparc64   3\n+\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_sparc\n+#define CPP_DEFAULT_SPEC \"\"\n+#define ASM_DEFAULT_SPEC \"\"\n+#else\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_sparclet\n+#define CPP_DEFAULT_SPEC \"-D__sparclet__\"\n+#define ASM_DEFAULT_SPEC \"-Asparclet\"\n+#else\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_sparclite\n+#define CPP_DEFAULT_SPEC \"-D__sparclite__\"\n+#define ASM_DEFAULT_SPEC \"-Asparclite\"\n+#else\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_sparc64\n+/* ??? What does Sun's CC pass?  */\n+#define CPP_DEFAULT_SPEC \"-D__sparc_v9__\"\n+/* ??? It's not clear how other assemblers will handle this, so by default\n+   use GAS.  Sun's Solaris assembler recognizes -xarch=v8plus, but this case\n+   is handled in sol2.h.  */\n+#define ASM_DEFAULT_SPEC \"-Av9\"\n+#else\n+Unrecognized value in TARGET_CPU_DEFAULT.\n+#endif\n+#endif\n+#endif\n+#endif\n+\n /* Names to predefine in the preprocessor for this target machine.  */\n \n /* ??? The GCC_NEW_VARARGS macro is now obsolete, because gcc always uses\n    the right varags.h file when bootstrapping.  */\n+/* ??? It's not clear what value we want to use for -Acpu/machine for\n+   sparc64 in 32 bit environments, so for now we only use `sparc64' in\n+   64 bit environments.  */\n+/* ??? __arch64__ is subject to change.  */\n \n #if SPARC_ARCH64\n #define CPP_PREDEFINES \\\n-  \"-Dsparc -Dsun -Dunix -D__sparc_v9__ \\\n+  \"-Dsparc -Dsun -Dunix -D__arch64__ \\\n    -Asystem(unix) -Asystem(bsd) -Acpu(sparc64) -Amachine(sparc64)\"\n #else\n #define CPP_PREDEFINES \\\n   \"-Dsparc -Dsun -Dunix -D__GCC_NEW_VARARGS__ \\\n    -Asystem(unix) -Asystem(bsd) -Acpu(sparc) -Amachine(sparc)\"\n #endif\n \n-#define LIB_SPEC \"%{!shared:%{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} %{g:-lg}}\"\n-\n-/* Provide required defaults for linker -e and -d switches.  */\n-\n-#define LINK_SPEC \\\n- \"%{!shared:%{!nostdlib:%{!r*:%{!e*:-e start}}} -dc -dp} %{static:-Bstatic} \\\n-  %{assert*} %{shared:-assert pure-text}\"\n-\n-/* Special flags to the Sun-4 assembler when using pipe for input.  */\n-\n-#define ASM_SPEC \\\n-  \" %| %{R} %{!pg:%{!p:%{fpic:-k} %{fPIC:-k}}} %{keep-local-as-symbols:-L}\"\n-\n /* Define macros to distinguish architectures.  */\n \n #if SPARC_ARCH64\n@@ -91,27 +114,90 @@ Boston, MA 02111-1307, USA.  */\n %{mlong64:-D__LONG_MAX__=9223372036854775807LL} \\\n \"\n #else\n-#define CPP_SPEC \"\\\n+#define CPP_SPEC \"%(cpp_cpu)\"\n+#endif\n+\n+/* Common CPP definitions used by CPP_SPEC amongst the various targets\n+   for handling -mcpu=xxx switches.  */\n+#define CPP_CPU_SPEC \"\\\n+%{mcypress:} \\\n %{msparclite:-D__sparclite__} \\\n %{mf930:-D__sparclite__} %{mf934:-D__sparclite__} \\\n %{mv8:-D__sparc_v8__} \\\n-%{msupersparc:-D__supersparc__ -D__sparc_v8__}\t\\\n+%{msupersparc:-D__supersparc__ -D__sparc_v8__} \\\n+%{mcpu=sparclite:-D__sparclite__} \\\n+%{mcpu=f930:-D__sparclite__} %{mcpu=f934:-D__sparclite__} \\\n+%{mcpu=v8:-D__sparc_v8__} \\\n+%{mcpu=supersparc:-D__supersparc__ -D__sparc_v8__} \\\n+%{mcpu=v9:-D__sparc_v9__} \\\n+%{mcpu=ultrasparc:-D__sparc_v9__} \\\n+%{!mcpu*:%{!mcypress:%{!msparclite:%{!mf930:%{!mf934:%{!mv8:%{!msupersparc:%(cpp_default)}}}}}}} \\\n \"\n-#endif\n \n /* Prevent error on `-sun4' and `-target sun4' options.  */\n /* This used to translate -dalign to -malign, but that is no good\n    because it can't turn off the usual meaning of making debugging dumps.  */\n+/* Translate old style -m<cpu> into new style -mcpu=<cpu>.\n+   At some point support for -m<cpu> will be deleted.  */\n+\n+#define CC1_SPEC \"\\\n+%{sun4:} %{target:} \\\n+%{mcypress:-mcpu=cypress} \\\n+%{msparclite:-mcpu=sparclite} %{mf930:-mcpu=f930} %{mf934:-mcpu=f934} \\\n+%{mv8:-mcpu=v8} %{msupersparc:-mcpu=supersparc} \\\n+\"\n+\n+#define LIB_SPEC \"%{!shared:%{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} %{g:-lg}}\"\n+\n+/* Provide required defaults for linker -e and -d switches.  */\n+\n+#define LINK_SPEC \\\n+ \"%{!shared:%{!nostdlib:%{!r*:%{!e*:-e start}}} -dc -dp} %{static:-Bstatic} \\\n+  %{assert*} %{shared:%{!mimpure-text:-assert pure-text}}\"\n+\n+/* Special flags to the Sun-4 assembler when using pipe for input.  */\n+\n+#define ASM_SPEC \"\\\n+%| %{R} %{!pg:%{!p:%{fpic:-k} %{fPIC:-k}}} %{keep-local-as-symbols:-L} \\\n+%(asm_cpu) \\\n+\"\n+\n+/* Override in target specific files.  */\n+#define ASM_CPU_SPEC \"\\\n+%{msparclite:-Asparclite} \\\n+%{mf930:-Asparclite} %{mf934:-Asparclite} \\\n+%{mcpu=sparclite:-Asparclite} \\\n+%{mcpu=f930:-Asparclite} %{mcpu=f934:-Asparclite} \\\n+%{mcpu=v9:-Av9} \\\n+%{mcpu=ultrasparc:-Av9} \\\n+%{!mcpu*:%{!mcypress:%{!msparclite:%{!mf930:%{!mf934:%{!mv8:%{!msupersparc:%(asm_default)}}}}}}} \\\n+\"\n+\n+/* This macro defines names of additional specifications to put in the specs\n+   that can be used in various specifications like CC1_SPEC.  Its definition\n+   is an initializer with a subgrouping for each command option.\n+\n+   Each subgrouping contains a string constant, that defines the\n+   specification name, and a string constant that used by the GNU CC driver\n+   program.\n+\n+   Do not define this macro if it does not need to do anything.  */\n \n-#define CC1_SPEC \"%{sun4:} %{target:}\"\n+#define EXTRA_SPECS\t\t\t\t\t\\\n+  { \"cpp_cpu\",\t\tCPP_CPU_SPEC },\t\t\t\\\n+  { \"cpp_default\",\tCPP_DEFAULT_SPEC },\t\t\\\n+  { \"asm_cpu\",\t\tASM_CPU_SPEC },\t\t\t\\\n+  { \"asm_default\",\tASM_DEFAULT_SPEC },\t\t\\\n+  SUBTARGET_EXTRA_SPECS\n \n+#define SUBTARGET_EXTRA_SPECS\n+\f\n #if SPARC_ARCH64\n #define PTRDIFF_TYPE \"long long int\"\n #define SIZE_TYPE \"long long unsigned int\"\n #else\n #define PTRDIFF_TYPE \"int\"\n-/* In 2.4 it should work to delete this.\n-   #define SIZE_TYPE \"int\"  */\n+/* The default value for SIZE_TYPE is \"unsigned int\" which is what we want.  */\n #endif\n \n /* ??? This should be 32 bits for v9 but what can we do?  */\n@@ -141,8 +227,8 @@ void sparc_override_options ();\n \t  }\t\t\t\t\t\t\t\t\\\n \tflag_omit_frame_pointer = 0;\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n-    SUBTARGET_OVERRIDE_OPTIONS;\t\t\t\t\t\t\\\n     sparc_override_options ();\t\t\t\t\t\t\\\n+    SUBTARGET_OVERRIDE_OPTIONS;\t\t\t\t\t\t\\\n   } while (0)\n \n /* This is meant to be redefined in the host dependent files.  */\n@@ -191,44 +277,42 @@ extern int target_flags;\n #define MASK_SPARCLITE 0x10\n #define TARGET_SPARCLITE (target_flags & MASK_SPARCLITE)\n \n-/* Nonzero means we should schedule code for the TMS390Z55 SuperSparc chip.  */\n-#define MASK_SUPERSPARC 0x20\n-#define TARGET_SUPERSPARC (target_flags & MASK_SUPERSPARC)\n+/* Nonzero if we're compiling for the sparclet.  */\n+#define MASK_SPARCLET 0x20\n+#define TARGET_SPARCLET (target_flags & MASK_SPARCLET)\n \n /* Nonzero if we're compiling for v9 sparc.\n    Note that v9's can run in 32 bit mode so this doesn't necessarily mean\n-   the word size is 64.  It does mean that the extra fp regs are available\n-   as are the new instructions that don't require 64 bit words.  */\n+   the word size is 64.  */\n #define MASK_V9 0x40\n #define TARGET_V9 (target_flags & MASK_V9)\n \n-/* ??? Bit 0x80 currently unused.  */\n+/* Non-zero to generate code that uses the instructions deprecated in\n+   the v9 architecture.  This option only applies to v9 systems.  */\n+/* ??? This isn't user selectable yet.  It's used to enable such insns\n+   on 32 bit v9 systems and for the moment they're permanently disabled\n+   on 64 bit v9 systems.  */\n+#define MASK_DEPRECATED_V8_INSNS 0x80\n+#define TARGET_DEPRECATED_V8_INSNS (target_flags & MASK_DEPRECATED_V8_INSNS)\n \n-/* Mask of all CPU selection flags.\n-   ??? Migrate to -mcpu=?  */\n-#define MASK_CPUS (MASK_V8 + MASK_SPARCLITE + MASK_SUPERSPARC + MASK_V9)\n+/* Mask of all CPU selection flags.  */\n+#define MASK_ISA \\\n+(MASK_V8 + MASK_SPARCLITE + MASK_SPARCLET + MASK_V9 + MASK_DEPRECATED_V8_INSNS)\n \n-/* Nonzero means that we should generate code using a flat register window\n-   model, i.e. no save/restore instructions are generated, in the most\n-   efficient manner.  This code is not compatible with normal sparc code.  */\n-/* This is not a user selectable option yet, because it requires changes\n-   that are not yet switchable via command line arguments.  */\n-/* ??? This flag is deprecated and may disappear at some point.  */\n-#define MASK_FRW 0x100\n-#define TARGET_FRW (target_flags & MASK_FRW)\n+/* Non-zero means don't pass `-assert pure-text' to the linker.  */\n+#define MASK_IMPURE_TEXT 0x100\n+#define TARGET_IMPURE_TEXT (target_flags & MASK_IMPURE_TEXT)\n \n /* Nonzero means that we should generate code using a flat register window\n-   model, i.e. no save/restore instructions are generated, but which is\n-   compatible with normal sparc code.   This is the same as above, except\n-   that the frame pointer is %i7 instead of %fp.  */\n-/* ??? This use to be named TARGET_FRW_COMPAT.  At some point TARGET_FRW will\n-   go away, but until that time only use this one when necessary.\n-   -mflat sets both.  */\n+   model, i.e. no save/restore instructions are generated, which is\n+   compatible with normal sparc code.\n+   The frame pointer is %i7 instead of %fp.  */\n #define MASK_FLAT 0x200\n #define TARGET_FLAT (target_flags & MASK_FLAT)\n \n /* Nonzero means use the registers that the Sparc ABI reserves for\n-   application software.  This is the default for v8, but not v9.  */\n+   application software.  This must be the default to coincide with the\n+   setting in FIXED_REGISTERS.  */\n #define MASK_APP_REGS 0x400\n #define TARGET_APP_REGS (target_flags & MASK_APP_REGS)\n \n@@ -238,10 +322,7 @@ extern int target_flags;\n #define MASK_HARD_QUAD 0x800\n #define TARGET_HARD_QUAD (target_flags & MASK_HARD_QUAD)\n \n-/* Non-zero to generate code that uses the instructions deprecated in\n-   the v9 architecture.  This option only applies to v9 systems.  */\n-#define MASK_DEPRECATED_V8_INSNS 0x1000\n-#define TARGET_DEPRECATED_V8_INSNS (target_flags & MASK_DEPRECATED_V8_INSNS)\n+/* Bit 0x1000 currently unused.  */\n \n /* Nonzero if ints are 64 bits.\n    This automatically implies longs are 64 bits too.\n@@ -297,11 +378,6 @@ extern int target_flags;\n    where VALUE is the bits to set or minus the bits to clear.\n    An empty string NAME is used to identify the default VALUE.  */\n \n-/* The Fujitsu MB86930 is the original sparclite chip, with no fpu.\n-   The Fujitsu MB86934 is the recent sparclite chip, with an fpu.\n-   We use -mf930 and -mf934 options to choose which.\n-   ??? These should perhaps be -mcpu= options.  */\n-\n #define TARGET_SWITCHES  \\\n   { {\"fpu\", MASK_FPU},\t\t\t\\\n     {\"no-fpu\", -MASK_FPU},\t\t\\\n@@ -311,32 +387,31 @@ extern int target_flags;\n     {\"no-epilogue\", -MASK_EPILOGUE},\t\\\n     {\"unaligned-doubles\", MASK_UNALIGNED_DOUBLES}, \\\n     {\"no-unaligned-doubles\", -MASK_UNALIGNED_DOUBLES}, \\\n-    {\"supersparc\", -MASK_CPUS},\t\t\\\n-    {\"supersparc\", MASK_SUPERSPARC+MASK_V8}, \\\n-    {\"cypress\", -MASK_CPUS},\t\t\\\n-    {\"v8\", -MASK_CPUS},\t\t\t\\\n-    {\"v8\", MASK_V8},\t\t\t\\\n-    {\"no-v8\", -MASK_CPUS},\t\t\\\n-    {\"sparclite\", -MASK_CPUS},\t\t\\\n-    {\"sparclite\", MASK_SPARCLITE},\t\\\n-    {\"no-sparclite\", -MASK_CPUS},\t\\\n-    {\"f930\", -MASK_FPU-MASK_CPUS},\t\\\n-    {\"f930\", MASK_SPARCLITE},\t\t\\\n-    {\"f934\", -MASK_CPUS},\t\t\\\n-    {\"f934\", MASK_FPU+MASK_SPARCLITE},\t\\\n-    {\"flat\", MASK_FRW+MASK_FLAT},\t\\\n-    {\"no-flat\", -(MASK_FRW+MASK_FLAT)},\t\\\n+    {\"impure-text\", MASK_IMPURE_TEXT},\t\\\n+    {\"no-impure-text\", -MASK_IMPURE_TEXT}, \\\n+    {\"flat\", MASK_FLAT},\t\t\\\n+    {\"no-flat\", -MASK_FLAT},\t\t\\\n     {\"app-regs\", MASK_APP_REGS},\t\\\n     {\"no-app-regs\", -MASK_APP_REGS},\t\\\n     {\"hard-quad-float\", MASK_HARD_QUAD}, \\\n     {\"soft-quad-float\", -MASK_HARD_QUAD}, \\\n+    /* ??? These are coerced to -mcpu=.  Delete in 2.9.  */ \\\n+    {\"cypress\", 0},\t\t\t\\\n+    {\"sparclite\", 0},\t\t\t\\\n+    {\"f930\", 0},\t\t\t\\\n+    {\"f934\", 0},\t\t\t\\\n+    {\"v8\", 0},\t\t\t\t\\\n+    {\"supersparc\", 0},\t\t\t\\\n     SUBTARGET_SWITCHES\t\t\t\\\n     ARCH64_SWITCHES\t\t\t\\\n     { \"\", TARGET_DEFAULT}}\n \n+/* MASK_APP_REGS must always be the default because that's what\n+   FIXED_REGISTERS is set to and -ffixed- is processed before\n+   CONDITIONAL_REGISTER_USAGE is called (where we process -mno-app-regs).  */\n #define TARGET_DEFAULT (MASK_APP_REGS + MASK_EPILOGUE + MASK_FPU)\n \n-/* This is meant to be redefined in the host dependent files */\n+/* This is meant to be redefined in target specific files.  */\n #define SUBTARGET_SWITCHES\n \n /* ??? Until we support a combination 32/64 bit compiler, these options\n@@ -364,6 +439,37 @@ extern int target_flags;\n #else\n #define ARCH64_SWITCHES\n #endif\n+\n+extern enum attr_cpu sparc_cpu;\n+\n+/* This macro is similar to `TARGET_SWITCHES' but defines names of\n+   command options that have values.  Its definition is an\n+   initializer with a subgrouping for each command option.\n+\n+   Each subgrouping contains a string constant, that defines the\n+   fixed part of the option name, and the address of a variable. \n+   The variable, type `char *', is set to the variable part of the\n+   given option if the fixed part matches.  The actual option name\n+   is made by appending `-m' to the specified name.\n+\n+   Here is an example which defines `-mshort-data-NUMBER'.  If the\n+   given option is `-mshort-data-512', the variable `m88k_short_data'\n+   will be set to the string `\"512\"'.\n+\n+\textern char *m88k_short_data;\n+\t#define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }  */\n+\n+/* ??? This isn't as fancy as rs6000.h.  Maybe in time.  */\n+extern char *sparc_cpu_string;\n+\n+#define TARGET_OPTIONS \\\n+{ \\\n+  { \"cpu=\", &sparc_cpu_string }, \\\n+  SUBTARGET_OPTIONS \\\n+}\n+\n+/* This is meant to be redefined in target specific files.  */\n+#define SUBTARGET_OPTIONS\n \f\n /* target machine storage layout */\n \n@@ -558,8 +664,8 @@ extern int target_flags;\n    g5 through g7 are reserved for the operating system.\n    On v9 systems:\n    g1 and g5 are free to use as temporaries.\n-   g2-g4 are reserved for applications (the compiler will not normally use\n-   them, but they can be used as temporaries with -mapp-regs).\n+   g2-g4 are reserved for applications.  Gcc normally uses them as\n+   temporaries, but this can be disabled via the -mno-app-regs option.\n    g6-g7 are reserved for the operating system.\n    ??? Register 1 is used as a temporary by the 64 bit sethi pattern, so must\n    currently be a fixed register until this pattern is rewritten.\n@@ -568,7 +674,7 @@ extern int target_flags;\n \n #if SPARC_V9\n #define FIXED_REGISTERS  \\\n- {0, 1, 1, 1, 1, 0, 1, 1,\t\\\n+ {0, 1, 0, 0, 0, 0, 1, 1,\t\\\n   0, 0, 0, 0, 0, 0, 1, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 1, 1,\t\\\n@@ -604,7 +710,7 @@ extern int target_flags;\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.  */\n \n-#if SPARC_V9\n+#if SPARC_V9 && SPARC_ARCH64\n #define CALL_USED_REGISTERS  \\\n  {1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n@@ -623,6 +729,25 @@ extern int target_flags;\n \t\t\t\t\\\n   1, 1, 1, 1}\n #else\n+#if SPARC_V9 && ! SPARC_ARCH64\n+#define CALL_USED_REGISTERS  \\\n+ {1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 1, 1,\t\\\n+\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+\t\t\t\t\\\n+  1, 1, 1, 1}\n+#else\n #define CALL_USED_REGISTERS  \\\n  {1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n@@ -634,6 +759,7 @@ extern int target_flags;\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1}\n #endif\n+#endif\n \n /* If !TARGET_FPU, then make the fp registers fixed so that they won't\n    be allocated.  On v9, also make the fp cc regs fixed.  */\n@@ -643,31 +769,18 @@ do\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n     if (SPARC_V9 && ! SPARC_ARCH64)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n-\tint regno;\t\t\t\t\t\t\\\n-\tfor (regno = 1; regno <= 4; regno++)\t\t\t\\\n-\t  fixed_regs[regno] = 0;\t\t\t\t\\\n \tfixed_regs[5] = 1;\t\t\t\t\t\\\n-\tfor (regno = 48; regno < 80; regno++)\t\t\t\\\n-\t  call_used_regs[regno] = 1;\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n     if (! TARGET_FPU)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \tint regno;\t\t\t\t\t\t\\\n \tfor (regno = 32; regno < FIRST_PSEUDO_REGISTER; regno++) \\\n \t  fixed_regs[regno] = 1;\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n-    if (! TARGET_APP_REGS)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfixed_regs[2] = 1;\t\t\t\t\t\\\n-\tfixed_regs[3] = 1;\t\t\t\t\t\\\n-\tfixed_regs[4] = 1;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfixed_regs[2] = 0;\t\t\t\t\t\\\n-\tfixed_regs[3] = 0;\t\t\t\t\t\\\n-\tfixed_regs[4] = TARGET_MEDANY != 0;\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n+    /* Don't unfix g2-g4 if they were fixed with -ffixed-.  */\t\\\n+    fixed_regs[2] |= ! TARGET_APP_REGS;\t\t\t\t\\\n+    fixed_regs[3] |= ! TARGET_APP_REGS;\t\t\t\t\\\n+    fixed_regs[4] |= ! TARGET_APP_REGS || TARGET_MEDANY;\t\\\n     if (TARGET_FLAT)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \t/* Let the compiler believe the frame pointer is still\t\\\n@@ -764,8 +877,8 @@ extern int sparc_mode_class[];\n    flat window model.  However, the debugger won't be able to backtrace through\n    us with out it.  */\n #define FRAME_POINTER_REQUIRED \\\n-  (TARGET_FRW ? (current_function_calls_alloca || current_function_varargs \\\n-\t\t || !leaf_function_p ()) \\\n+  (TARGET_FLAT ? (current_function_calls_alloca || current_function_varargs \\\n+\t\t  || !leaf_function_p ()) \\\n    : ! (leaf_function_p () && only_leaf_regs_used ()))\n \n /* C statement to store the difference between the frame pointer\n@@ -775,7 +888,7 @@ extern int sparc_mode_class[];\n    it's not, there's no point in trying to eliminate the\n    frame pointer.  If it is a leaf function, we guessed right!  */\n #define INITIAL_FRAME_POINTER_OFFSET(VAR) \\\n-  ((VAR) = (TARGET_FRW ? sparc_flat_compute_frame_size (get_frame_size ()) \\\n+  ((VAR) = (TARGET_FLAT ? sparc_flat_compute_frame_size (get_frame_size ()) \\\n \t    : compute_frame_size (get_frame_size (), 1)))\n \n /* Base register for access to arguments of the function.  */\n@@ -1230,34 +1343,34 @@ extern char leaf_reg_remap[];\n #define BASE_OUTGOING_VALUE_REG(MODE) \\\n   (TARGET_ARCH64 \\\n    ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 \\\n-      : TARGET_FRW ? 8 : 24) \\\n+      : TARGET_FLAT ? 8 : 24) \\\n    : (((MODE) == SFmode || (MODE) == DFmode) && TARGET_FPU ? 32\t\\\n-      : (TARGET_FRW ? 8 : 24)))\n+      : (TARGET_FLAT ? 8 : 24)))\n #define BASE_PASSING_ARG_REG(MODE) \\\n   (TARGET_ARCH64 \\\n    ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 : 8) \\\n    : 8)\n #define BASE_INCOMING_ARG_REG(MODE) \\\n   (TARGET_ARCH64 \\\n    ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 \\\n-      : TARGET_FRW ? 8 : 24) \\\n-   : (TARGET_FRW ? 8 : 24))\n+      : TARGET_FLAT ? 8 : 24) \\\n+   : (TARGET_FLAT ? 8 : 24))\n \n /* Define this macro if the target machine has \"register windows\".  This\n    C expression returns the register number as seen by the called function\n    corresponding to register number OUT as seen by the calling function.\n    Return OUT if register number OUT is not an outbound register.  */\n \n #define INCOMING_REGNO(OUT) \\\n- ((TARGET_FRW || (OUT) < 8 || (OUT) > 15) ? (OUT) : (OUT) + 16)\n+ ((TARGET_FLAT || (OUT) < 8 || (OUT) > 15) ? (OUT) : (OUT) + 16)\n \n /* Define this macro if the target machine has \"register windows\".  This\n    C expression returns the register number as seen by the calling function\n    corresponding to register number IN as seen by the called function.\n    Return IN if register number IN is not an inbound register.  */\n \n #define OUTGOING_REGNO(IN) \\\n- ((TARGET_FRW || (IN) < 24 || (IN) > 31) ? (IN) : (IN) - 16)\n+ ((TARGET_FLAT || (IN) < 24 || (IN) > 31) ? (IN) : (IN) - 16)\n \n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n@@ -1568,8 +1681,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n    to do this is made in regclass.c.  */\n \n extern int leaf_function;\n-#define FUNCTION_PROLOGUE(FILE, SIZE)\t\t\t\t\\\n-  (TARGET_FRW ? sparc_flat_output_function_prologue (FILE, SIZE) \\\n+#define FUNCTION_PROLOGUE(FILE, SIZE) \\\n+  (TARGET_FLAT ? sparc_flat_output_function_prologue (FILE, SIZE) \\\n    : output_function_prologue (FILE, SIZE, leaf_function))\n \n /* Output assembler code to FILE to increment profiler label # LABELNO\n@@ -1956,14 +2069,14 @@ extern int current_function_outgoing_args_size;\n    because they occur inside of macros.  Sigh.  */\n extern union tree_node *current_function_decl;\n \n-#define FUNCTION_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n-  (TARGET_FRW ? sparc_flat_output_function_epilogue (FILE, SIZE) \\\n+#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n+  (TARGET_FLAT ? sparc_flat_output_function_epilogue (FILE, SIZE) \\\n    : output_function_epilogue (FILE, SIZE, leaf_function))\n \n-#define DELAY_SLOTS_FOR_EPILOGUE\t\\\n-  (TARGET_FRW ? sparc_flat_epilogue_delay_slots () : 1)\n-#define ELIGIBLE_FOR_EPILOGUE_DELAY(trial, slots_filled)\t\\\n-  (TARGET_FRW ? sparc_flat_eligible_for_epilogue_delay (trial, slots_filled) \\\n+#define DELAY_SLOTS_FOR_EPILOGUE \\\n+  (TARGET_FLAT ? sparc_flat_epilogue_delay_slots () : 1)\n+#define ELIGIBLE_FOR_EPILOGUE_DELAY(trial, slots_filled) \\\n+  (TARGET_FLAT ? sparc_flat_eligible_for_epilogue_delay (trial, slots_filled) \\\n    : eligible_for_epilogue_delay (trial, slots_filled))\n \f\n /* Output assembler code for a block containing the constant parts\n@@ -2591,8 +2704,8 @@ extern struct rtx_def *legitimize_pic_address ();\n \n /* Adjust the cost of dependencies.  */\n #define ADJUST_COST(INSN,LINK,DEP,COST) \\\n-  if (TARGET_SUPERSPARC) \\\n-  (COST) = supersparc_adjust_cost (INSN, LINK, DEP, COST)\n+  if (sparc_cpu == CPU_SUPERSPARC) \\\n+    (COST) = supersparc_adjust_cost (INSN, LINK, DEP, COST)\n \n /* Conditional branches with empty delay slots have a length of two.  */\n #define ADJUST_INSN_LENGTH(INSN, LENGTH)\t\\"}]}