{"sha": "31b5873d01cfb8aa27f5da175b8e8740c3e76370", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFiNTg3M2QwMWNmYjhhYTI3ZjVkYTE3NWI4ZTg3NDBjM2U3NjM3MA==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2007-09-26T10:43:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-09-26T10:43:34Z"}, "message": "freeze.adb (Freeze_Entity): Remove check for preelaborable initialization of a full view.\n\n2007-09-26  Gary Dismukes  <dismukes@adacore.com>\n\n\t* freeze.adb (Freeze_Entity): Remove check for preelaborable\n\tinitialization of a full view. This is moved to\n\tAnalyze_Package_Specification.\n\n\t* sem_ch7.adb (Analyze_Package_Specification): Add check for\n\tpreelaborable initialization of a full view in entity loop.\n\t(Uninstall_Declarations): If entity is a use-visible compilation unit,\n\tits child units are use-visible only if they are visible child units.\n\n\t* sem_util.adb (Is_Preelaborable_Expression): New function to determine\n\twhether an expression can be used within a type declaration that\n\trequires preelaborable init.\n\t(Check_Components): Replace inline code that does partial checking for\n\tpreelaborable default expressions with call to\n\tIs_Preelaborable_Expression.\n\t(Has_Preelaborable_Initialization): In the case of a generic actual\n\tsubtype, (that is, Is_Generic_Actual is True), return the result of\n\tapplying Has_Preelaborable_Initialization to the generic actual's base\n\ttype.\n\nFrom-SVN: r128789", "tree": {"sha": "5c033c0587d20e064772bc364f3412e79a42f858", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c033c0587d20e064772bc364f3412e79a42f858"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31b5873d01cfb8aa27f5da175b8e8740c3e76370", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31b5873d01cfb8aa27f5da175b8e8740c3e76370", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31b5873d01cfb8aa27f5da175b8e8740c3e76370", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31b5873d01cfb8aa27f5da175b8e8740c3e76370/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "af04dc07c565e452971c24476297f5cb6a50b2c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af04dc07c565e452971c24476297f5cb6a50b2c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af04dc07c565e452971c24476297f5cb6a50b2c6"}], "stats": {"total": 329, "additions": 275, "deletions": 54}, "files": [{"sha": "c55d46892fbb9f0d5ae158425603923349529cc3", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31b5873d01cfb8aa27f5da175b8e8740c3e76370/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31b5873d01cfb8aa27f5da175b8e8740c3e76370/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=31b5873d01cfb8aa27f5da175b8e8740c3e76370", "patch": "@@ -2542,15 +2542,13 @@ package body Freeze is\n       --  Case of a type or subtype being frozen\n \n       else\n-         --  Check preelaborable initialization for full type completing a\n-         --  private type for which pragma Preelaborable_Initialization given.\n-\n-         if Must_Have_Preelab_Init (E)\n-           and then not Has_Preelaborable_Initialization (E)\n-         then\n-            Error_Msg_N\n-              (\"full view of & does not have preelaborable initialization\", E);\n-         end if;\n+         --  We used to check here that a full type must have preelaborable\n+         --  initialization if it completes a private type specified with\n+         --  pragma Preelaborable_Intialization, but that missed cases where\n+         --  the types occur within a generic package, since the freezing\n+         --  that occurs within a containing scope generally skips traversal\n+         --  of a generic unit's declarations (those will be frozen within\n+         --  instances). This check was moved to Analyze_Package_Specification.\n \n          --  The type may be defined in a generic unit. This can occur when\n          --  freezing a generic function that returns the type (which is"}, {"sha": "40dceb2a2c23668d3a93eda48562687f42d18934", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31b5873d01cfb8aa27f5da175b8e8740c3e76370/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31b5873d01cfb8aa27f5da175b8e8740c3e76370/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=31b5873d01cfb8aa27f5da175b8e8740c3e76370", "patch": "@@ -1168,15 +1168,27 @@ package body Sem_Ch7 is\n          Set_First_Private_Entity (Id, Next_Entity (L));\n       end if;\n \n-      --  Check rule of 3.6(11), which in general requires waiting till all\n-      --  full types have been seen.\n-\n       E := First_Entity (Id);\n       while Present (E) loop\n+\n+         --  Check rule of 3.6(11), which in general requires waiting till all\n+         --  full types have been seen.\n+\n          if Ekind (E) = E_Record_Type or else Ekind (E) = E_Array_Type then\n             Check_Aliased_Component_Types (E);\n          end if;\n \n+         --  Check preelaborable initialization for full type completing a\n+         --  private type for which pragma Preelaborable_Initialization given.\n+\n+         if Is_Type (E)\n+           and then Must_Have_Preelab_Init (E)\n+           and then not Has_Preelaborable_Initialization (E)\n+         then\n+            Error_Msg_N\n+              (\"full view of & does not have preelaborable initialization\", E);\n+         end if;\n+\n          Next_Entity (E);\n       end loop;\n \n@@ -2024,8 +2036,24 @@ package body Sem_Ch7 is\n                            Type_In_Use\n                              (Etype (Next_Formal (First_Formal (Id))))));\n          else\n-            Set_Is_Potentially_Use_Visible (Id,\n-              In_Use (P) and not Is_Hidden (Id));\n+            if In_Use (P) and then not Is_Hidden (Id) then\n+\n+               --  A child unit of a use-visible package remains use-visible\n+               --  only if it is itself a visible child unit. Otherwise it\n+               --  would remain visible in other contexts where P is use-\n+               --  visible, because once compiled it stays in the entity list\n+               --  of its parent unit.\n+\n+               if Is_Child_Unit (Id) then\n+                  Set_Is_Potentially_Use_Visible (Id,\n+                    Is_Visible_Child_Unit (Id));\n+               else\n+                  Set_Is_Potentially_Use_Visible (Id);\n+               end if;\n+\n+            else\n+               Set_Is_Potentially_Use_Visible (Id, False);\n+            end if;\n          end if;\n \n          --  Local entities are not immediately visible outside of the package"}, {"sha": "a9d4aec18c63520d0d6aed4cd5ccd51d75c30833", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 235, "deletions": 40, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31b5873d01cfb8aa27f5da175b8e8740c3e76370/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31b5873d01cfb8aa27f5da175b8e8740c3e76370/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=31b5873d01cfb8aa27f5da175b8e8740c3e76370", "patch": "@@ -110,15 +110,14 @@ package body Sem_Util is\n             if Present (Full_View (Typ)) then\n                Nod := Type_Definition (Parent (Full_View (Typ)));\n \n-            --  If the full-view is not available we cannot do anything\n-            --  else here (the source has errors)\n+            --  If the full-view is not available we cannot do anything else\n+            --  here (the source has errors).\n \n             else\n                return Empty_List;\n             end if;\n \n-         --  The support for generic formals with interfaces is still\n-         --  missing???\n+         --  Support for generic formals with interfaces is still missing ???\n \n          elsif Nkind (Parent (Typ)) = N_Formal_Type_Declaration then\n             return Empty_List;\n@@ -2677,6 +2676,64 @@ package body Sem_Util is\n       raise Program_Error;\n    end Find_Corresponding_Discriminant;\n \n+   --------------------------\n+   -- Find_Overlaid_Object --\n+   --------------------------\n+\n+   function Find_Overlaid_Object (N : Node_Id) return Entity_Id is\n+      Expr  : Node_Id;\n+\n+   begin\n+      --  We are looking for one of the two following forms:\n+\n+      --    for X'Address use Y'Address\n+\n+      --  or\n+\n+      --    Const : constant Address := expr;\n+      --    ...\n+      --    for X'Address use Const;\n+\n+      --  In the second case, the expr is either Y'Address, or recursively a\n+      --  constant that eventually references Y'Address.\n+\n+      if Nkind (N) = N_Attribute_Definition_Clause\n+        and then Chars (N) = Name_Address\n+      then\n+         --  This loop checks the form of the expression for Y'Address where Y\n+         --  is an object entity name. The first loop checks the original\n+         --  expression in the attribute definition clause. Subsequent loops\n+         --  check referenced constants.\n+\n+         Expr := Expression (N);\n+         loop\n+            --  Check for Y'Address where Y is an object entity\n+\n+            if Nkind (Expr) = N_Attribute_Reference\n+              and then Attribute_Name (Expr) = Name_Address\n+              and then Is_Entity_Name (Prefix (Expr))\n+              and then Is_Object (Entity (Prefix (Expr)))\n+            then\n+               return Entity (Prefix (Expr));\n+\n+               --  Check for Const where Const is a constant entity\n+\n+            elsif Is_Entity_Name (Expr)\n+              and then Ekind (Entity (Expr)) = E_Constant\n+            then\n+               Expr := Constant_Value (Entity (Expr));\n+\n+            --  Anything else does not need checking\n+\n+            else\n+               exit;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      return Empty;\n+   end Find_Overlaid_Object;\n+\n    --------------------------------------------\n    -- Find_Overridden_Synchronized_Primitive --\n    --------------------------------------------\n@@ -4386,6 +4443,151 @@ package body Sem_Util is\n          Ent : Entity_Id;\n          Exp : Node_Id;\n \n+         function Is_Preelaborable_Expression (N : Node_Id) return Boolean;\n+         --  Returns True if and only if the expression denoted by N does not\n+         --  violate restrictions on preelaborable constructs (RM-10.2.1(5-9)).\n+\n+         ---------------------------------\n+         -- Is_Preelaborable_Expression --\n+         ---------------------------------\n+\n+         function Is_Preelaborable_Expression (N : Node_Id) return Boolean is\n+            Exp           : Node_Id;\n+            Assn          : Node_Id;\n+            Choice        : Node_Id;\n+            Comp_Type     : Entity_Id;\n+            Is_Array_Aggr : Boolean;\n+\n+         begin\n+            if Is_Static_Expression (N) then\n+               return True;\n+\n+            elsif Nkind (N) = N_Null then\n+               return True;\n+\n+            elsif Nkind (N) = N_Attribute_Reference\n+              and then\n+                (Attribute_Name (N) = Name_Access\n+                   or else\n+                 Attribute_Name (N) = Name_Unchecked_Access\n+                   or else\n+                 Attribute_Name (N) = Name_Unrestricted_Access)\n+            then\n+               return True;\n+\n+            elsif Nkind (N) = N_Qualified_Expression then\n+               return Is_Preelaborable_Expression (Expression (N));\n+\n+            --  For aggregates we have to check that each of the associations\n+            --  is preelaborable.\n+\n+            elsif Nkind (N) = N_Aggregate\n+              or else Nkind (N) = N_Extension_Aggregate\n+            then\n+               Is_Array_Aggr := Is_Array_Type (Etype (N));\n+\n+               if Is_Array_Aggr then\n+                  Comp_Type := Component_Type (Etype (N));\n+               end if;\n+\n+               --  Check the ancestor part of extension aggregates, which must\n+               --  be either the name of a type that has preelaborable init or\n+               --  an expression that is preelaborable.\n+\n+               if Nkind (N) = N_Extension_Aggregate then\n+                  declare\n+                     Anc_Part : constant Node_Id := Ancestor_Part (N);\n+\n+                  begin\n+                     if Is_Entity_Name (Anc_Part)\n+                       and then Is_Type (Entity (Anc_Part))\n+                     then\n+                        if not Has_Preelaborable_Initialization\n+                                 (Entity (Anc_Part))\n+                        then\n+                           return False;\n+                        end if;\n+\n+                     elsif not Is_Preelaborable_Expression (Anc_Part) then\n+                        return False;\n+                     end if;\n+                  end;\n+               end if;\n+\n+               --  Check positional associations\n+\n+               Exp := First (Expressions (N));\n+               while Present (Exp) loop\n+                  if not Is_Preelaborable_Expression (Exp) then\n+                     return False;\n+                  end if;\n+\n+                  Next (Exp);\n+               end loop;\n+\n+               --  Check named associations\n+\n+               Assn := First (Component_Associations (N));\n+               while Present (Assn) loop\n+                  Choice := First (Choices (Assn));\n+                  while Present (Choice) loop\n+                     if Is_Array_Aggr then\n+                        if Nkind (Choice) = N_Others_Choice then\n+                           null;\n+\n+                        elsif Nkind (Choice) = N_Range then\n+                           if not Is_Static_Range (Choice) then\n+                              return False;\n+                           end if;\n+\n+                        elsif not Is_Static_Expression (Choice) then\n+                           return False;\n+                        end if;\n+\n+                     else\n+                        Comp_Type := Etype (Choice);\n+                     end if;\n+\n+                     Next (Choice);\n+                  end loop;\n+\n+                  --  If the association has a <> at this point, then we have\n+                  --  to check whether the component's type has preelaborable\n+                  --  initialization. Note that this only occurs when the\n+                  --  association's corresponding component does not have a\n+                  --  default expression, the latter case having already been\n+                  --  expanded as an expression for the association.\n+\n+                  if Box_Present (Assn) then\n+                     if not Has_Preelaborable_Initialization (Comp_Type) then\n+                        return False;\n+                     end if;\n+\n+                  --  In the expression case we check whether the expression\n+                  --  is preelaborable.\n+\n+                  elsif\n+                    not Is_Preelaborable_Expression (Expression (Assn))\n+                  then\n+                     return False;\n+                  end if;\n+\n+                  Next (Assn);\n+               end loop;\n+\n+               --  If we get here then aggregate as a whole is preelaborable\n+\n+               return True;\n+\n+            --  All other cases are not preelaborable\n+\n+            else\n+               return False;\n+            end if;\n+         end Is_Preelaborable_Expression;\n+\n+      --  Start of processing for Check_Components\n+\n       begin\n          --  Loop through entities of record or protected type\n \n@@ -4400,47 +4602,27 @@ package body Sem_Util is\n             then\n                --  Get default expression if any. If there is no declaration\n                --  node, it means we have an internal entity. The parent and\n-               --  tag fields are examples of such entitires. For these\n-               --  cases, we just test the type of the entity.\n+               --  tag fields are examples of such entitires. For these cases,\n+               --  we just test the type of the entity.\n \n                if Present (Declaration_Node (Ent)) then\n                   Exp := Expression (Declaration_Node (Ent));\n                else\n                   Exp := Empty;\n                end if;\n \n-               --  A component has PI if it has no default expression and\n-               --  the component type has PI.\n+               --  A component has PI if it has no default expression and the\n+               --  component type has PI.\n \n                if No (Exp) then\n                   if not Has_Preelaborable_Initialization (Etype (Ent)) then\n                      Has_PE := False;\n                      exit;\n                   end if;\n \n-                  --  Or if expression obeys rules for preelaboration. For\n-                  --  now we approximate this by testing if the default\n-                  --  expression is a static expression or if it is an\n-                  --  access attribute reference, or the literal null.\n-\n-                  --  This is an approximation, it is probably incomplete???\n-\n-               elsif Is_Static_Expression (Exp) then\n-                  null;\n-\n-               elsif Nkind (Exp) = N_Attribute_Reference\n-                 and then (Attribute_Name (Exp) = Name_Access\n-                           or else\n-                           Attribute_Name (Exp) = Name_Unchecked_Access\n-                           or else\n-                           Attribute_Name (Exp) = Name_Unrestricted_Access)\n-               then\n-                  null;\n-\n-               elsif Nkind (Exp) = N_Null then\n-                  null;\n+               --  Require the default expression to be preelaborable\n \n-               else\n+               elsif not Is_Preelaborable_Expression (Exp) then\n                   Has_PE := False;\n                   exit;\n                end if;\n@@ -4462,6 +4644,15 @@ package body Sem_Util is\n          return True;\n       end if;\n \n+      --  If the type is a subtype representing a generic actual type, then\n+      --  test whether its base type has preelaborable initialization since\n+      --  the subtype representing the actual does not inherit this attribute\n+      --  from the actual or formal. (but maybe it should???)\n+\n+      if Is_Generic_Actual_Type (E) then\n+         return Has_Preelaborable_Initialization (Base_Type (E));\n+      end if;\n+\n       --  Other private types never have preelaborable initialization\n \n       if Is_Private_Type (E) then\n@@ -4586,24 +4777,21 @@ package body Sem_Util is\n             UT : constant Entity_Id := Underlying_Type (Btype);\n          begin\n             if No (UT) then\n-\n                if No (Full_View (Btype)) then\n                   return not Is_Generic_Type (Btype)\n                     and then not Is_Generic_Type (Root_Type (Btype));\n-\n                else\n                   return not Is_Generic_Type (Root_Type (Full_View (Btype)));\n                end if;\n-\n             else\n                return not Is_Frozen (UT) and then Has_Private_Component (UT);\n             end if;\n          end;\n+\n       elsif Is_Array_Type (Btype) then\n          return Has_Private_Component (Component_Type (Btype));\n \n       elsif Is_Record_Type (Btype) then\n-\n          Component := First_Component (Btype);\n          while Present (Component) loop\n             if Has_Private_Component (Etype (Component)) then\n@@ -4716,7 +4904,6 @@ package body Sem_Util is\n               or else Ekind (S) = E_Procedure)\n            and then Is_Generic_Instance (S)\n          then\n-\n             --  A child instance is always compiled in the context of a parent\n             --  instance. Nevertheless, the actuals are not analyzed in an\n             --  instance context. We detect this case by examining the current\n@@ -4910,7 +5097,8 @@ package body Sem_Util is\n    begin\n       Save_Interps (N, New_Prefix);\n       Rewrite (N,\n-        Make_Explicit_Dereference (Sloc (N), Prefix => New_Prefix));\n+        Make_Explicit_Dereference (Sloc (N),\n+          Prefix => New_Prefix));\n \n       Set_Etype (N, Designated_Type (Etype (New_Prefix)));\n \n@@ -4973,9 +5161,8 @@ package body Sem_Util is\n    -------------------\n \n    function Is_AAMP_Float (E : Entity_Id) return Boolean is\n-   begin\n       pragma Assert (Is_Type (E));\n-\n+   begin\n       return AAMP_On_Target\n          and then Is_Floating_Point_Type (E)\n          and then E = Base_Type (E);\n@@ -5072,8 +5259,8 @@ package body Sem_Util is\n    -------------------------\n \n    function Is_Ancestor_Package\n-     (E1  : Entity_Id;\n-      E2  : Entity_Id) return Boolean\n+     (E1 : Entity_Id;\n+      E2 : Entity_Id) return Boolean\n    is\n       Par : Entity_Id;\n \n@@ -5104,6 +5291,10 @@ package body Sem_Util is\n       function Is_Atomic_Prefix (N : Node_Id) return Boolean;\n       --  If prefix is an implicit dereference, examine designated type\n \n+      ----------------------\n+      -- Is_Atomic_Prefix --\n+      ----------------------\n+\n       function Is_Atomic_Prefix (N : Node_Id) return Boolean is\n       begin\n          if Is_Access_Type (Etype (N)) then\n@@ -5114,6 +5305,10 @@ package body Sem_Util is\n          end if;\n       end Is_Atomic_Prefix;\n \n+      ----------------------------------\n+      -- Object_Has_Atomic_Components --\n+      ----------------------------------\n+\n       function Object_Has_Atomic_Components (N : Node_Id) return Boolean is\n       begin\n          if Has_Atomic_Components (Etype (N))"}]}