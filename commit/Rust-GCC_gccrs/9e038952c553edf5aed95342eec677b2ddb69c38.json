{"sha": "9e038952c553edf5aed95342eec677b2ddb69c38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWUwMzg5NTJjNTUzZWRmNWFlZDk1MzQyZWVjNjc3YjJkZGI2OWMzOA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2014-03-27T18:49:44Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2014-03-27T18:49:44Z"}, "message": "re PR rtl-optimization/60650 ([ARM] LRA ICE in assign_by_spills)\n\n2014-03-27  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/60650\n\t* lra-asign.c (find_hard_regno_for, spill_for): Add parameter\n\tfirst_p.  Use it.\n\t(find_spills_for): New.\n\t(assign_by_spills): Pass the new parameter to find_hard_regno_for.\n\tSpill all pseudos on the second iteration.\n\n2014-03-27  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/60650\n\t* gcc.target/arm/pr60650.c: New.\n\nFrom-SVN: r208876", "tree": {"sha": "02adcc9591c9a5c68a583a04705fb4aa60f1a4b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02adcc9591c9a5c68a583a04705fb4aa60f1a4b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e038952c553edf5aed95342eec677b2ddb69c38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e038952c553edf5aed95342eec677b2ddb69c38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e038952c553edf5aed95342eec677b2ddb69c38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e038952c553edf5aed95342eec677b2ddb69c38/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ffcbf03ffb556b93c19b80bb59bd0429b980a504", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffcbf03ffb556b93c19b80bb59bd0429b980a504", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffcbf03ffb556b93c19b80bb59bd0429b980a504"}], "stats": {"total": 202, "additions": 141, "deletions": 61}, "files": [{"sha": "52cbe50b0404e85efa733065a45c958c3039a819", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e038952c553edf5aed95342eec677b2ddb69c38/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e038952c553edf5aed95342eec677b2ddb69c38/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e038952c553edf5aed95342eec677b2ddb69c38", "patch": "@@ -1,3 +1,12 @@\n+2014-03-27  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/60650\n+\t* lra-asign.c (find_hard_regno_for, spill_for): Add parameter\n+\tfirst_p.  Use it.\n+\t(find_spills_for): New.\n+\t(assign_by_spills): Pass the new parameter to find_hard_regno_for.\n+\tSpill all pseudos on the second iteration.\n+\n 2014-03-27  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/50347"}, {"sha": "cba8b8fc70cc1b6f3602e471421594a853efb8de", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 88, "deletions": 61, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e038952c553edf5aed95342eec677b2ddb69c38/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e038952c553edf5aed95342eec677b2ddb69c38/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=9e038952c553edf5aed95342eec677b2ddb69c38", "patch": "@@ -451,10 +451,16 @@ adjust_hard_regno_cost (int hard_regno, int incr)\n    that register.  (If several registers have equal cost, the one with\n    the highest priority wins.)  Return -1 on failure.\n \n+   If FIRST_P, return the first available hard reg ignoring other\n+   criteria, e.g. allocation cost.  This approach results in less hard\n+   reg pool fragmentation and permit to allocate hard regs to reload\n+   pseudos in complicated situations where pseudo sizes are different.\n+\n    If TRY_ONLY_HARD_REGNO >= 0, consider only that hard register,\n    otherwise consider all hard registers in REGNO's class.  */\n static int\n-find_hard_regno_for (int regno, int *cost, int try_only_hard_regno)\n+find_hard_regno_for (int regno, int *cost, int try_only_hard_regno,\n+\t\t     bool first_p)\n {\n   HARD_REG_SET conflict_set;\n   int best_cost = INT_MAX, best_priority = INT_MIN, best_usage = INT_MAX;\n@@ -630,7 +636,7 @@ find_hard_regno_for (int regno, int *cost, int try_only_hard_regno)\n \t      best_usage = lra_hard_reg_usage[hard_regno];\n \t    }\n \t}\n-      if (try_only_hard_regno >= 0)\n+      if (try_only_hard_regno >= 0 || (first_p && best_hard_regno >= 0))\n \tbreak;\n     }\n   if (best_hard_regno >= 0)\n@@ -816,9 +822,15 @@ static int *sorted_reload_pseudos;\n    to be spilled), we take into account not only how REGNO will\n    benefit from the spills but also how other reload pseudos not yet\n    assigned to hard registers benefit from the spills too.  In very\n-   rare cases, the function can fail and return -1.  */\n+   rare cases, the function can fail and return -1.\n+\n+   If FIRST_P, return the first available hard reg ignoring other\n+   criteria, e.g. allocation cost and cost of spilling non-reload\n+   pseudos.  This approach results in less hard reg pool fragmentation\n+   and permit to allocate hard regs to reload pseudos in complicated\n+   situations where pseudo sizes are different.  */\n static int\n-spill_for (int regno, bitmap spilled_pseudo_bitmap)\n+spill_for (int regno, bitmap spilled_pseudo_bitmap, bool first_p)\n {\n   int i, j, n, p, hard_regno, best_hard_regno, cost, best_cost, rclass_size;\n   int reload_hard_regno, reload_cost;\n@@ -905,7 +917,7 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap)\n \t      && (ira_reg_classes_intersect_p\n \t\t  [rclass][regno_allocno_class_array[reload_regno]])\n \t      && live_pseudos_reg_renumber[reload_regno] < 0\n-\t      && find_hard_regno_for (reload_regno, &cost, -1) < 0)\n+\t      && find_hard_regno_for (reload_regno, &cost, -1, first_p) < 0)\n \t    sorted_reload_pseudos[n++] = reload_regno;\n       EXECUTE_IF_SET_IN_BITMAP (&spill_pseudos_bitmap, 0, spill_regno, bi)\n \t{\n@@ -914,7 +926,7 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap)\n \t    fprintf (lra_dump_file, \" spill %d(freq=%d)\",\n \t\t     spill_regno, lra_reg_info[spill_regno].freq);\n \t}\n-      hard_regno = find_hard_regno_for (regno, &cost, -1);\n+      hard_regno = find_hard_regno_for (regno, &cost, -1, first_p);\n       if (hard_regno >= 0)\n \t{\n \t  assign_temporarily (regno, hard_regno);\n@@ -926,7 +938,7 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap)\n \t      lra_assert (live_pseudos_reg_renumber[reload_regno] < 0);\n \t      if ((reload_hard_regno\n \t\t   = find_hard_regno_for (reload_regno,\n-\t\t\t\t\t  &reload_cost, -1)) >= 0)\n+\t\t\t\t\t  &reload_cost, -1, first_p)) >= 0)\n \t\t{\n \t\t  if (lra_dump_file != NULL)\n \t\t    fprintf (lra_dump_file, \" assign %d(cost=%d)\",\n@@ -1148,8 +1160,8 @@ improve_inheritance (bitmap changed_pseudos)\n \t\t   regno, hard_regno, another_regno, another_hard_regno);\n \t      update_lives (another_regno, true);\n \t      lra_setup_reg_renumber (another_regno, -1, false);\n-\t      if (hard_regno\n-\t\t  == find_hard_regno_for (another_regno, &cost, hard_regno))\n+\t      if (hard_regno == find_hard_regno_for (another_regno, &cost,\n+\t\t\t\t\t\t     hard_regno, false))\n \t\tassign_hard_regno (hard_regno, another_regno);\n \t      else\n \t\tassign_hard_regno (another_hard_regno, another_regno);\n@@ -1166,15 +1178,50 @@ static bitmap_head all_spilled_pseudos;\n /* All pseudos whose allocation was changed.  */\n static bitmap_head changed_pseudo_bitmap;\n \n+\n+/* Add to LIVE_RANGE_HARD_REG_PSEUDOS all pseudos conflicting with\n+   REGNO and whose hard regs can be assigned to REGNO.  */\n+static void\n+find_all_spills_for (int regno)\n+{\n+  int p;\n+  lra_live_range_t r;\n+  unsigned int k;\n+  bitmap_iterator bi;\n+  enum reg_class rclass;\n+  bool *rclass_intersect_p;\n+\n+  rclass = regno_allocno_class_array[regno];\n+  rclass_intersect_p = ira_reg_classes_intersect_p[rclass];\n+  for (r = lra_reg_info[regno].live_ranges; r != NULL; r = r->next)\n+    {\n+      EXECUTE_IF_SET_IN_BITMAP (&live_hard_reg_pseudos[r->start], 0, k, bi)\n+\tif (rclass_intersect_p[regno_allocno_class_array[k]])\n+\t  sparseset_set_bit (live_range_hard_reg_pseudos, k);\n+      for (p = r->start + 1; p <= r->finish; p++)\n+\t{\n+\t  lra_live_range_t r2;\n+\n+\t  for (r2 = start_point_ranges[p];\n+\t       r2 != NULL;\n+\t       r2 = r2->start_next)\n+\t    {\n+\t      if (live_pseudos_reg_renumber[r2->regno] >= 0\n+\t\t  && rclass_intersect_p[regno_allocno_class_array[r2->regno]])\n+\t\tsparseset_set_bit (live_range_hard_reg_pseudos, r2->regno);\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Assign hard registers to reload pseudos and other pseudos.  */\n static void\n assign_by_spills (void)\n {\n   int i, n, nfails, iter, regno, hard_regno, cost, restore_regno;\n   rtx insn;\n-  basic_block bb;\n   bitmap_head changed_insns, do_not_assign_nonreload_pseudos;\n-  unsigned int u;\n+  unsigned int u, conflict_regno;\n   bitmap_iterator bi;\n   bool reload_p;\n   int max_regno = max_reg_num ();\n@@ -1211,10 +1258,10 @@ assign_by_spills (void)\n \t\t     ORIGINAL_REGNO (regno_reg_rtx[regno]),\n \t\t     lra_reg_info[regno].freq, regno_assign_info[regno].first,\n \t\t     regno_assign_info[regno_assign_info[regno].first].freq);\n-\t  hard_regno = find_hard_regno_for (regno, &cost, -1);\n+\t  hard_regno = find_hard_regno_for (regno, &cost, -1, iter == 1);\n \t  reload_p = ! bitmap_bit_p (&non_reload_pseudos, regno);\n \t  if (hard_regno < 0 && reload_p)\n-\t    hard_regno = spill_for (regno, &all_spilled_pseudos);\n+\t    hard_regno = spill_for (regno, &all_spilled_pseudos, iter == 1);\n \t  if (hard_regno < 0)\n \t    {\n \t      if (reload_p)\n@@ -1286,61 +1333,41 @@ assign_by_spills (void)\n \t  lra_assert (asm_p);\n \t  break;\n \t}\n-      /* This is a very rare event.  We can not assign a hard\n-\t register to reload pseudo because the hard register was\n-\t assigned to another reload pseudo on a previous\n-\t assignment pass.  For x86 example, on the 1st pass we\n-\t assigned CX (although another hard register could be used\n-\t for this) to reload pseudo in an insn, on the 2nd pass we\n-\t need CX (and only this) hard register for a new reload\n-\t pseudo in the same insn.  */\n+      /* This is a very rare event.  We can not assign a hard register\n+\t to reload pseudo because the hard register was assigned to\n+\t another reload pseudo on a previous assignment pass.  For x86\n+\t example, on the 1st pass we assigned CX (although another\n+\t hard register could be used for this) to reload pseudo in an\n+\t insn, on the 2nd pass we need CX (and only this) hard\n+\t register for a new reload pseudo in the same insn.  Another\n+\t possible situation may occur in assigning to multi-regs\n+\t reload pseudos when hard regs pool is too fragmented even\n+\t after spilling non-reload pseudos.\n+\n+\t We should do something radical here to succeed.  Here we\n+\t spill *all* conflicting pseudos and reassign them.  */\n       if (lra_dump_file != NULL)\n \tfprintf (lra_dump_file, \"  2nd iter for reload pseudo assignments:\\n\");\n+      sparseset_clear (live_range_hard_reg_pseudos);\n       for (i = 0; i < nfails; i++)\n \t{\n \t  if (lra_dump_file != NULL)\n \t    fprintf (lra_dump_file, \"\t Reload r%d assignment failure\\n\",\n \t\t     sorted_pseudos[i]);\n-\t  bitmap_ior_into (&changed_insns,\n-\t\t\t   &lra_reg_info[sorted_pseudos[i]].insn_bitmap);\n+\t  find_all_spills_for (sorted_pseudos[i]);\n+\t}\n+      EXECUTE_IF_SET_IN_SPARSESET (live_range_hard_reg_pseudos, conflict_regno)\n+\t{\n+\t  if ((int) conflict_regno >= lra_constraint_new_regno_start)\n+\t    sorted_pseudos[nfails++] = conflict_regno;\n+\t  if (lra_dump_file != NULL)\n+\t    fprintf (lra_dump_file, \"\t  Spill %s r%d(hr=%d, freq=%d)\\n\",\n+\t\t     pseudo_prefix_title (conflict_regno), conflict_regno,\n+\t\t     reg_renumber[conflict_regno],\n+\t\t     lra_reg_info[conflict_regno].freq);\n+\t  update_lives (conflict_regno, true);\n+\t  lra_setup_reg_renumber (conflict_regno, -1, false);\n \t}\n-\n-      /* FIXME: Look up the changed insns in the cached LRA insn data using\n-\t an EXECUTE_IF_SET_IN_BITMAP over changed_insns.  */\n-      FOR_EACH_BB_FN (bb, cfun)\n-\tFOR_BB_INSNS (bb, insn)\n-\tif (bitmap_bit_p (&changed_insns, INSN_UID (insn)))\n-\t  {\n-\t    lra_insn_recog_data_t data;\n-\t    struct lra_insn_reg *r;\n-\n-\t    data = lra_get_insn_recog_data (insn);\n-\t    for (r = data->regs; r != NULL; r = r->next)\n-\t      {\n-\t\tregno = r->regno;\n-\t\t/* A reload pseudo did not get a hard register on the\n-\t\t   first iteration because of the conflict with\n-\t\t   another reload pseudos in the same insn.  So we\n-\t\t   consider only reload pseudos assigned to hard\n-\t\t   registers.  We shall exclude inheritance pseudos as\n-\t\t   they can occur in original insns (not reload ones).\n-\t\t   We can omit the check for split pseudos because\n-\t\t   they occur only in move insns containing non-reload\n-\t\t   pseudos.  */\n-\t\tif (regno < lra_constraint_new_regno_start\n-\t\t    || bitmap_bit_p (&lra_inheritance_pseudos, regno)\n-\t\t    || reg_renumber[regno] < 0)\n-\t\t  continue;\n-\t\tsorted_pseudos[nfails++] = regno;\n-\t\tif (lra_dump_file != NULL)\n-\t\t  fprintf (lra_dump_file,\n-\t\t\t   \"\t  Spill reload r%d(hr=%d, freq=%d)\\n\",\n-\t\t\t   regno, reg_renumber[regno],\n-\t\t\t   lra_reg_info[regno].freq);\n-\t\tupdate_lives (regno, true);\n-\t\tlra_setup_reg_renumber (regno, -1, false);\n-\t      }\n-\t  }\n       n = nfails;\n     }\n   improve_inheritance (&changed_pseudo_bitmap);\n@@ -1382,7 +1409,7 @@ assign_by_spills (void)\n       for (i = 0; i < n; i++)\n \t{\n \t  regno = sorted_pseudos[i];\n-\t  hard_regno = find_hard_regno_for (regno, &cost, -1);\n+\t  hard_regno = find_hard_regno_for (regno, &cost, -1, false);\n \t  if (hard_regno >= 0)\n \t    {\n \t      assign_hard_regno (hard_regno, regno);"}, {"sha": "c18f8fa4830f505016c722c122d1d3991a5ceba2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e038952c553edf5aed95342eec677b2ddb69c38/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e038952c553edf5aed95342eec677b2ddb69c38/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9e038952c553edf5aed95342eec677b2ddb69c38", "patch": "@@ -1,3 +1,8 @@\n+2014-03-27  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/60650\n+\t* gcc.target/arm/pr60650.c: New.\n+\n 2014-03-27  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* gcc.target/s390/20140327-1.c: New testcase."}, {"sha": "bfa7f1e3c675129162c0f1896448af6f962d5136", "filename": "gcc/testsuite/gcc.target/arm/pr60650.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e038952c553edf5aed95342eec677b2ddb69c38/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr60650.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e038952c553edf5aed95342eec677b2ddb69c38/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr60650.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr60650.c?ref=9e038952c553edf5aed95342eec677b2ddb69c38", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-omit-frame-pointer -mabi=apcs-gnu -march=armv7-a\" } */\n+\n+struct super_block\n+{\n+  int s_blocksize_bits;\n+};\n+struct btrfs_fs_info\n+{\n+  struct super_block *sb;\n+};\n+struct btrfs_root\n+{\n+  struct btrfs_fs_info *fs_info;\n+} *b;\n+\n+\n+int a, c, d;\n+long long e;\n+\n+truncate_one_csum (struct btrfs_root *p1, long long p2, long long p3)\n+{\n+  int f, g, i = p1->fs_info->sb->s_blocksize_bits;\n+  g = a;\n+  long long h = p2 + p3;\n+  f = foo1 (b, 0, c, 0);\n+  e = f / g;\n+  e <<= p1->fs_info->sb->s_blocksize_bits;\n+  if (d < p2)\n+    {\n+      int j = e - h >> i;\n+      foo2 (p1, 0, j);\n+    }\n+  else\n+    {\n+      asm (\"1\\t.long \");\n+      __builtin_unreachable ();\n+    }\n+}"}]}