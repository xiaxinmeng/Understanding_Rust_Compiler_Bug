{"sha": "bde1427e3bb677f5120db529c16e3a0b2d3d0eae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRlMTQyN2UzYmI2NzdmNTEyMGRiNTI5YzE2ZTNhMGIyZDNkMGVhZQ==", "commit": {"author": {"name": "Aaron Luchko", "email": "aluchko@redhat.com", "date": "2005-07-07T20:54:04Z"}, "committer": {"name": "Aaron Luchko", "email": "aluchko@gcc.gnu.org", "date": "2005-07-07T20:54:04Z"}, "message": "* gnu/classpath/jdwp/processor/ReferenceTypeCommandSet.java:New\n        file.\n\nFrom-SVN: r101730", "tree": {"sha": "d6cb8684c40dc987495b432bcf2817e9aee778a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6cb8684c40dc987495b432bcf2817e9aee778a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bde1427e3bb677f5120db529c16e3a0b2d3d0eae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bde1427e3bb677f5120db529c16e3a0b2d3d0eae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bde1427e3bb677f5120db529c16e3a0b2d3d0eae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bde1427e3bb677f5120db529c16e3a0b2d3d0eae/comments", "author": null, "committer": null, "parents": [{"sha": "284bdbbd33049a015f43b6739fca6fc20b014934", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/284bdbbd33049a015f43b6739fca6fc20b014934", "html_url": "https://github.com/Rust-GCC/gccrs/commit/284bdbbd33049a015f43b6739fca6fc20b014934"}], "stats": {"total": 326, "additions": 326, "deletions": 0}, "files": [{"sha": "adb8e0d256ab016e81ad60e57dff6f0ff04315af", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde1427e3bb677f5120db529c16e3a0b2d3d0eae/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde1427e3bb677f5120db529c16e3a0b2d3d0eae/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=bde1427e3bb677f5120db529c16e3a0b2d3d0eae", "patch": "@@ -1,3 +1,8 @@\n+2005-07-07  Aaron Luchko  <aluchko@redhat.com>\n+\n+\t* gnu/classpath/jdwp/processor/ReferenceTypeCommandSet.java:New\n+\tfile.\n+\n 2005-07-07  Bryce McKinlay  <mckinlay@redhat.com>\n \n \t* testsuite/libjava.jacks/jacks.xfail: Remove 6.5.5.1-nested-4,"}, {"sha": "34def9f2d078df012900ec4a697b3cba094d4054", "filename": "libjava/gnu/classpath/jdwp/processor/ReferenceTypeCommandSet.java", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde1427e3bb677f5120db529c16e3a0b2d3d0eae/libjava%2Fgnu%2Fclasspath%2Fjdwp%2Fprocessor%2FReferenceTypeCommandSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde1427e3bb677f5120db529c16e3a0b2d3d0eae/libjava%2Fgnu%2Fclasspath%2Fjdwp%2Fprocessor%2FReferenceTypeCommandSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fclasspath%2Fjdwp%2Fprocessor%2FReferenceTypeCommandSet.java?ref=bde1427e3bb677f5120db529c16e3a0b2d3d0eae", "patch": "@@ -0,0 +1,321 @@\n+/* ReferenceTypeCommandSet.java -- lass to implement the ReferenceType\n+   Command Set\n+   Copyright (C) 2005 Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.classpath.jdwp.processor;\n+\n+import gnu.classpath.jdwp.IVirtualMachine;\n+import gnu.classpath.jdwp.Jdwp;\n+import gnu.classpath.jdwp.JdwpConstants;\n+import gnu.classpath.jdwp.exception.InvalidFieldException;\n+import gnu.classpath.jdwp.exception.JdwpException;\n+import gnu.classpath.jdwp.exception.JdwpInternalErrorException;\n+import gnu.classpath.jdwp.exception.NotImplementedException;\n+import gnu.classpath.jdwp.id.IdManager;\n+import gnu.classpath.jdwp.id.ObjectId;\n+import gnu.classpath.jdwp.id.ReferenceTypeId;\n+import gnu.classpath.jdwp.util.JdwpString;\n+import gnu.classpath.jdwp.util.Signature;\n+import gnu.classpath.jdwp.util.Value;\n+\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * A class representing the ReferenceType Command Set.\n+ * \n+ * @author Aaron Luchko <aluchko@redhat.com>\n+ */\n+public class ReferenceTypeCommandSet implements CommandSet\n+{\n+  // Our hook into the jvm\n+  private final IVirtualMachine vm = Jdwp.getIVirtualMachine();\n+\n+  // Manages all the different ids that are assigned by jdwp\n+  private final IdManager idMan = Jdwp.getIdManager();\n+\n+  public boolean runCommand(ByteBuffer bb, DataOutputStream os, byte command)\n+    throws JdwpException\n+  {\n+    try\n+      {\n+        switch (command)\n+          {\n+          case JdwpConstants.CommandSet.ReferenceType.SIGNATURE:\n+            executeSignature(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ReferenceType.CLASS_LOADER:\n+            executeClassLoader(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ReferenceType.MODIFIERS:\n+            executeModifiers(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ReferenceType.FIELDS:\n+            executeFields(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ReferenceType.METHODS:\n+            executeMethods(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ReferenceType.GET_VALUES:\n+            executeGetValues(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ReferenceType.SOURCE_FILE:\n+            executeSourceFile(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ReferenceType.NESTED_TYPES:\n+            executeNestedTypes(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ReferenceType.STATUS:\n+            executeStatus(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ReferenceType.INTERFACES:\n+            executeInterfaces(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ReferenceType.CLASS_OBJECT:\n+            executeClassObject(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ReferenceType.SOURCE_DEBUG_EXTENSION:\n+            executeSourceDebugExtension(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ReferenceType.SIGNATURE_WITH_GENERIC:\n+            executeSignatureWithGeneric(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ReferenceType.FIELDS_WITH_GENERIC:\n+            executeFieldWithGeneric(bb, os);\n+            break;\n+          case JdwpConstants.CommandSet.ReferenceType.METHODS_WITH_GENERIC:\n+            executeMethodsWithGeneric(bb, os);\n+            break;\n+          default:\n+            throw new NotImplementedException(\"Command \" + command +\n+              \" not found in String Reference Command Set.\");\n+          }\n+      }\n+    catch (IOException ex)\n+      {\n+        // The DataOutputStream we're using isn't talking to a socket at all\n+        // So if we throw an IOException we're in serious trouble\n+        throw new JdwpInternalErrorException(ex);\n+      }\n+    return true;\n+  }\n+\n+  private void executeSignature(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    ReferenceTypeId refId = idMan.readReferenceTypeId(bb);\n+    String sig = Signature.computeClassSignature(refId.getType());\n+    JdwpString.writeString(os, sig);\n+  }\n+\n+  private void executeClassLoader(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    ReferenceTypeId refId = idMan.readReferenceTypeId(bb);\n+\n+    Class clazz = refId.getType();\n+    ClassLoader loader = clazz.getClassLoader();\n+    ObjectId oid = idMan.getId(loader);\n+    oid.write(os);\n+  }\n+\n+  private void executeModifiers(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    ReferenceTypeId refId = idMan.readReferenceTypeId(bb);\n+\n+    Class clazz = refId.getType();\n+    os.writeInt(clazz.getModifiers());\n+  }\n+\n+  private void executeFields(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    ReferenceTypeId refId = idMan.readReferenceTypeId(bb);\n+    Class clazz = refId.getType();\n+\n+    Field[] fields = clazz.getFields();\n+    os.writeInt(fields.length);\n+    for (int i = 0; i < fields.length; i++)\n+      {\n+        Field field = fields[i];\n+        idMan.getId(field).write(os);\n+        JdwpString.writeString(os, field.getName());\n+        JdwpString.writeString(os, Signature.computeFieldSignature(field));\n+        os.writeInt(field.getModifiers());\n+      }\n+  }\n+\n+  private void executeMethods(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    ReferenceTypeId refId = idMan.readReferenceTypeId(bb);\n+    Class clazz = refId.getType();\n+\n+    Method[] methods = clazz.getMethods();\n+    os.writeInt(methods.length);\n+    for (int i = 0; i < methods.length; i++)\n+      {\n+        Method method = methods[i];\n+        idMan.getId(method).write(os);\n+        JdwpString.writeString(os, method.getName());\n+        JdwpString.writeString(os, Signature.computeMethodSignature(method));\n+        os.writeInt(method.getModifiers());\n+      }\n+  }\n+\n+  private void executeGetValues(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    ReferenceTypeId refId = idMan.readReferenceTypeId(bb);\n+    Class clazz = refId.getType();\n+\n+    int numFields = bb.getInt();\n+    os.writeInt(numFields); // Looks pointless but this is the protocol\n+    for (int i = 0; i < numFields; i++)\n+      {\n+        ObjectId fieldId = idMan.readId(bb);\n+        Field field = (Field) (fieldId.getObject());\n+        Class fieldClazz = field.getDeclaringClass();\n+\n+        // We don't actually need the clazz to get the field but we might as\n+        // well check that the debugger got it right\n+        if (fieldClazz.isAssignableFrom(clazz))\n+          Value.writeStaticValueFromField(os, field);\n+        else\n+          throw new InvalidFieldException(fieldId.getId());\n+      }\n+  }\n+\n+  private void executeSourceFile(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    ReferenceTypeId refId = idMan.readReferenceTypeId(bb);\n+    Class clazz = refId.getType();\n+\n+    // We'll need to go into the jvm for this unless there's an easier way\n+    String sourceFileName = vm.getSourceFile(clazz);\n+    JdwpString.writeString(os, sourceFileName);\n+    // clazz.getProtectionDomain().getCodeSource().getLocation();\n+  }\n+\n+  private void executeNestedTypes(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    ReferenceTypeId refId = idMan.readReferenceTypeId(bb);\n+    Class clazz = refId.getType();\n+    Class[] declaredClazzes = clazz.getDeclaredClasses();\n+    os.writeInt(declaredClazzes.length);\n+    for (int i = 0; i < declaredClazzes.length; i++)\n+      {\n+        Class decClazz = declaredClazzes[i];\n+        ReferenceTypeId clazzId = idMan.getReferenceTypeId(decClazz);\n+        clazzId.writeTagged(os);\n+      }\n+  }\n+\n+  private void executeStatus(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    ReferenceTypeId refId = idMan.readReferenceTypeId(bb);\n+    Class clazz = refId.getType();\n+\n+    // I don't think there's any other way to get this\n+    int status = vm.getStatus(clazz);\n+    os.writeInt(status);\n+  }\n+\n+  private void executeInterfaces(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    ReferenceTypeId refId = idMan.readReferenceTypeId(bb);\n+    Class clazz = refId.getType();\n+    Class[] interfaces = clazz.getInterfaces();\n+    os.writeInt(interfaces.length);\n+    for (int i = 0; i < interfaces.length; i++)\n+      {\n+        Class interfaceClass = interfaces[i];\n+        ReferenceTypeId intId = idMan.getReferenceTypeId(interfaceClass);\n+        intId.write(os);\n+      }\n+  }\n+\n+  private void executeClassObject(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    ReferenceTypeId refId = idMan.readReferenceTypeId(bb);\n+    Class clazz = refId.getType();\n+    ObjectId clazzObjectId = idMan.getId(clazz);\n+    clazzObjectId.write(os);\n+  }\n+\n+  private void executeSourceDebugExtension(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    // This command is optional, determined by VirtualMachines CapabilitiesNew\n+    // so we'll leave it till later to implement\n+    throw new NotImplementedException(\n+      \"Command SourceDebugExtension not implemented.\");\n+  }\n+\n+  private void executeSignatureWithGeneric(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    // We don't have generics yet\n+    throw new NotImplementedException(\n+      \"Command SourceDebugExtension not implemented.\");\n+  }\n+\n+  private void executeFieldWithGeneric(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    // We don't have generics yet\n+    throw new NotImplementedException(\n+      \"Command SourceDebugExtension not implemented.\");\n+  }\n+\n+  private void executeMethodsWithGeneric(ByteBuffer bb, DataOutputStream os)\n+    throws JdwpException, IOException\n+  {\n+    // We don't have generics yet\n+    throw new NotImplementedException(\n+      \"Command SourceDebugExtension not implemented.\");\n+  }\n+}"}]}