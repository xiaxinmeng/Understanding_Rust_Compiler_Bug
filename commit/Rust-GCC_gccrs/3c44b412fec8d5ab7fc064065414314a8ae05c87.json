{"sha": "3c44b412fec8d5ab7fc064065414314a8ae05c87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M0NGI0MTJmZWM4ZDVhYjdmYzA2NDA2NTQxNDMxNGE4YWUwNWM4Nw==", "commit": {"author": {"name": "Andrew Pinski", "email": "apinski@marvell.com", "date": "2021-06-29T03:48:44Z"}, "committer": {"name": "Andrew Pinski", "email": "apinski@marvell.com", "date": "2021-07-05T19:44:13Z"}, "message": "Fix PR 101237: Remove element_type call when used with the functions from real\n\nHONOR_SIGNED_ZEROS, HONOR_SIGN_DEPENDENT_ROUNDING, and HONOR_SNANS all\nhave an overload for taking a tree type now, so we should do that instead.\n\nOK?  Bootstrapped and tested on x86_64-linux-gnu.\n\ngcc/ChangeLog:\n\n\tPR middle-end/101237\n\t* fold-const.c (negate_expr_p): Remove call to element_mode\n\tand TREE_MODE/TREE_TYPE when calling HONOR_SIGNED_ZEROS,\n\tHONOR_SIGN_DEPENDENT_ROUNDING, and HONOR_SNANS.\n\t(fold_negate_expr_1): Likewise.\n\t(const_unop): Likewise.\n\t(fold_cond_expr_with_comparison): Likewise.\n\t(fold_binary_loc): Likewise.\n\t(fold_ternary_loc): Likewise.\n\t(tree_call_nonnegative_warnv_p): Likewise.\n\t* match.pd (-(A + B) -> (-B) - A): Likewise.", "tree": {"sha": "061137ae4cafb6d5e41cdf627b1fffd6501f655a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/061137ae4cafb6d5e41cdf627b1fffd6501f655a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c44b412fec8d5ab7fc064065414314a8ae05c87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c44b412fec8d5ab7fc064065414314a8ae05c87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c44b412fec8d5ab7fc064065414314a8ae05c87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c44b412fec8d5ab7fc064065414314a8ae05c87/comments", "author": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b5e8ee4f1ecc6d407f391695f65960bcbd63cff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b5e8ee4f1ecc6d407f391695f65960bcbd63cff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b5e8ee4f1ecc6d407f391695f65960bcbd63cff"}], "stats": {"total": 50, "additions": 25, "deletions": 25}, "files": [{"sha": "e0cdb75fb26356068478067c78c0a456d4763da8", "filename": "gcc/fold-const.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c44b412fec8d5ab7fc064065414314a8ae05c87/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c44b412fec8d5ab7fc064065414314a8ae05c87/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=3c44b412fec8d5ab7fc064065414314a8ae05c87", "patch": "@@ -432,8 +432,8 @@ negate_expr_p (tree t)\n       return negate_expr_p (TREE_OPERAND (t, 0));\n \n     case PLUS_EXPR:\n-      if (HONOR_SIGN_DEPENDENT_ROUNDING (element_mode (type))\n-\t  || HONOR_SIGNED_ZEROS (element_mode (type))\n+      if (HONOR_SIGN_DEPENDENT_ROUNDING (type)\n+\t  || HONOR_SIGNED_ZEROS (type)\n \t  || (ANY_INTEGRAL_TYPE_P (type)\n \t      && ! TYPE_OVERFLOW_WRAPS (type)))\n \treturn false;\n@@ -445,8 +445,8 @@ negate_expr_p (tree t)\n \n     case MINUS_EXPR:\n       /* We can't turn -(A-B) into B-A when we honor signed zeros.  */\n-      return !HONOR_SIGN_DEPENDENT_ROUNDING (element_mode (type))\n-\t     && !HONOR_SIGNED_ZEROS (element_mode (type))\n+      return !HONOR_SIGN_DEPENDENT_ROUNDING (type)\n+\t     && !HONOR_SIGNED_ZEROS (type)\n \t     && (! ANY_INTEGRAL_TYPE_P (type)\n \t\t || TYPE_OVERFLOW_WRAPS (type));\n \n@@ -468,7 +468,7 @@ negate_expr_p (tree t)\n       /* Fall through.  */\n \n     case RDIV_EXPR:\n-      if (! HONOR_SIGN_DEPENDENT_ROUNDING (element_mode (TREE_TYPE (t))))\n+      if (! HONOR_SIGN_DEPENDENT_ROUNDING (t))\n \treturn negate_expr_p (TREE_OPERAND (t, 1))\n \t       || negate_expr_p (TREE_OPERAND (t, 0));\n       break;\n@@ -605,8 +605,8 @@ fold_negate_expr_1 (location_t loc, tree t)\n       break;\n \n     case PLUS_EXPR:\n-      if (!HONOR_SIGN_DEPENDENT_ROUNDING (element_mode (type))\n-\t  && !HONOR_SIGNED_ZEROS (element_mode (type)))\n+      if (!HONOR_SIGN_DEPENDENT_ROUNDING (type)\n+\t  && !HONOR_SIGNED_ZEROS (type))\n \t{\n \t  /* -(A + B) -> (-B) - A.  */\n \t  if (negate_expr_p (TREE_OPERAND (t, 1)))\n@@ -628,8 +628,8 @@ fold_negate_expr_1 (location_t loc, tree t)\n \n     case MINUS_EXPR:\n       /* - (A - B) -> B - A  */\n-      if (!HONOR_SIGN_DEPENDENT_ROUNDING (element_mode (type))\n-\t  && !HONOR_SIGNED_ZEROS (element_mode (type)))\n+      if (!HONOR_SIGN_DEPENDENT_ROUNDING (type)\n+\t  && !HONOR_SIGNED_ZEROS (type))\n \treturn fold_build2_loc (loc, MINUS_EXPR, type,\n \t\t\t\tTREE_OPERAND (t, 1), TREE_OPERAND (t, 0));\n       break;\n@@ -641,7 +641,7 @@ fold_negate_expr_1 (location_t loc, tree t)\n       /* Fall through.  */\n \n     case RDIV_EXPR:\n-      if (! HONOR_SIGN_DEPENDENT_ROUNDING (element_mode (type)))\n+      if (! HONOR_SIGN_DEPENDENT_ROUNDING (type))\n \t{\n \t  tem = TREE_OPERAND (t, 1);\n \t  if (negate_expr_p (tem))\n@@ -1725,7 +1725,7 @@ const_unop (enum tree_code code, tree type, tree arg0)\n   /* Don't perform the operation, other than NEGATE and ABS, if\n      flag_signaling_nans is on and the operand is a signaling NaN.  */\n   if (TREE_CODE (arg0) == REAL_CST\n-      && HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n+      && HONOR_SNANS (arg0)\n       && REAL_VALUE_ISSIGNALING_NAN (TREE_REAL_CST (arg0))\n       && code != NEGATE_EXPR\n       && code != ABS_EXPR\n@@ -2135,7 +2135,7 @@ fold_convert_const_real_from_real (tree type, const_tree arg1)\n \n   /* Don't perform the operation if flag_signaling_nans is on\n      and the operand is a signaling NaN.  */\n-  if (HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg1)))\n+  if (HONOR_SNANS (arg1)\n       && REAL_VALUE_ISSIGNALING_NAN (TREE_REAL_CST (arg1)))\n     return NULL_TREE; \n \n@@ -5773,7 +5773,7 @@ fold_cond_expr_with_comparison (location_t loc, tree type,\n \n      Note that all these transformations are correct if A is\n      NaN, since the two alternatives (A and -A) are also NaNs.  */\n-  if (!HONOR_SIGNED_ZEROS (element_mode (type))\n+  if (!HONOR_SIGNED_ZEROS (type)\n       && (FLOAT_TYPE_P (TREE_TYPE (arg01))\n \t  ? real_zerop (arg01)\n \t  : integer_zerop (arg01))\n@@ -5842,7 +5842,7 @@ fold_cond_expr_with_comparison (location_t loc, tree type,\n      both transformations are correct when A is NaN: A != 0\n      is then true, and A == 0 is false.  */\n \n-  if (!HONOR_SIGNED_ZEROS (element_mode (type))\n+  if (!HONOR_SIGNED_ZEROS (type)\n       && integer_zerop (arg01) && integer_zerop (arg2))\n     {\n       if (comp_code == NE_EXPR)\n@@ -5877,7 +5877,7 @@ fold_cond_expr_with_comparison (location_t loc, tree type,\n      a number and A is not.  The conditions in the original\n      expressions will be false, so all four give B.  The min()\n      and max() versions would give a NaN instead.  */\n-  if (!HONOR_SIGNED_ZEROS (element_mode (type))\n+  if (!HONOR_SIGNED_ZEROS (type)\n       && operand_equal_for_comparison_p (arg01, arg2)\n       /* Avoid these transformations if the COND_EXPR may be used\n \t as an lvalue in the C++ front-end.  PR c++/19199.  */\n@@ -11005,8 +11005,8 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,\n \t  /* Fold __complex__ ( x, 0 ) + __complex__ ( 0, y )\n \t     to __complex__ ( x, y ).  This is not the same for SNaNs or\n \t     if signed zeros are involved.  */\n-\t  if (!HONOR_SNANS (element_mode (arg0))\n-              && !HONOR_SIGNED_ZEROS (element_mode (arg0))\n+\t  if (!HONOR_SNANS (arg0)\n+\t      && !HONOR_SIGNED_ZEROS (arg0)\n \t      && COMPLEX_FLOAT_TYPE_P (TREE_TYPE (arg0)))\n \t    {\n \t      tree rtype = TREE_TYPE (TREE_TYPE (arg0));\n@@ -11404,8 +11404,8 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,\n       /* Fold __complex__ ( x, 0 ) - __complex__ ( 0, y ) to\n \t __complex__ ( x, -y ).  This is not the same for SNaNs or if\n \t signed zeros are involved.  */\n-      if (!HONOR_SNANS (element_mode (arg0))\n-\t  && !HONOR_SIGNED_ZEROS (element_mode (arg0))\n+      if (!HONOR_SNANS (arg0)\n+\t  && !HONOR_SIGNED_ZEROS (arg0)\n \t  && COMPLEX_FLOAT_TYPE_P (TREE_TYPE (arg0)))\n         {\n \t  tree rtype = TREE_TYPE (TREE_TYPE (arg0));\n@@ -11509,7 +11509,7 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,\n \t     This is not the same for NaNs or if signed zeros are\n \t     involved.  */\n \t  if (!HONOR_NANS (arg0)\n-              && !HONOR_SIGNED_ZEROS (element_mode (arg0))\n+\t      && !HONOR_SIGNED_ZEROS (arg0)\n \t      && COMPLEX_FLOAT_TYPE_P (TREE_TYPE (arg0))\n \t      && TREE_CODE (arg1) == COMPLEX_CST\n \t      && real_zerop (TREE_REALPART (arg1)))\n@@ -12819,7 +12819,7 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n          Also try swapping the arguments and inverting the conditional.  */\n       if (COMPARISON_CLASS_P (arg0)\n \t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0), op1)\n-\t  && !HONOR_SIGNED_ZEROS (element_mode (op1)))\n+\t  && !HONOR_SIGNED_ZEROS (op1))\n \t{\n \t  tem = fold_cond_expr_with_comparison (loc, type, TREE_CODE (arg0),\n \t\t\t\t\t\tTREE_OPERAND (arg0, 0),\n@@ -12831,7 +12831,7 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \n       if (COMPARISON_CLASS_P (arg0)\n \t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0), op2)\n-\t  && !HONOR_SIGNED_ZEROS (element_mode (op2)))\n+\t  && !HONOR_SIGNED_ZEROS (op2))\n \t{\n \t  enum tree_code comp_code = TREE_CODE (arg0);\n \t  tree arg00 = TREE_OPERAND (arg0, 0);\n@@ -14713,7 +14713,7 @@ tree_call_nonnegative_warnv_p (tree type, combined_fn fn, tree arg0, tree arg1,\n     CASE_CFN_SQRT:\n     CASE_CFN_SQRT_FN:\n       /* sqrt(-0.0) is -0.0.  */\n-      if (!HONOR_SIGNED_ZEROS (element_mode (type)))\n+      if (!HONOR_SIGNED_ZEROS (type))\n \treturn true;\n       return RECURSE (arg0);\n "}, {"sha": "4e10d54383cb7717ed891c61b796536c8784cdc9", "filename": "gcc/match.pd", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c44b412fec8d5ab7fc064065414314a8ae05c87/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c44b412fec8d5ab7fc064065414314a8ae05c87/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=3c44b412fec8d5ab7fc064065414314a8ae05c87", "patch": "@@ -1458,8 +1458,8 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n /* -(A + B) -> (-B) - A.  */\n (simplify\n  (negate (plus:c @0 negate_expr_p@1))\n- (if (!HONOR_SIGN_DEPENDENT_ROUNDING (element_mode (type))\n-      && !HONOR_SIGNED_ZEROS (element_mode (type)))\n+ (if (!HONOR_SIGN_DEPENDENT_ROUNDING (type)\n+      && !HONOR_SIGNED_ZEROS (type))\n   (minus (negate @1) @0)))\n \n /* -(A - B) -> B - A.  */"}]}