{"sha": "8e99fb4f70a03741b3be630a290932c4de63ce23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU5OWZiNGY3MGEwMzc0MWIzYmU2MzBhMjkwOTMyYzRkZTYzY2UyMw==", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2004-07-22T15:36:05Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2004-07-22T15:36:05Z"}, "message": "[multiple changes]\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JTextArea.java\n\t(setLineWrap): Fire property change event after new value is set.\n\t(setTabSize): Likewise.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JTable.java\n\t(autoCreateColumnsFromModel): New field.\n\t(autoResizeMode): Likewise.\n\t(cellEditor): Likewise.\n\t(cellSelectionEnabled): Likewise.\n\t(columnModel): Likewise.\n\t(dataModel): Likewise.\n\t(defaultEditorsByColumnClass): Likewise.\n\t(defaultRenderersByColumnClass): Likewise.\n\t(editingColumn): Likewise.\n\t(editingRow): Likewise.\n\t(gridColor): Likewise.\n\t(preferredViewportSize): Likewise.\n\t(rowHeight): Likewise.\n\t(rowMargin): Likewise.\n\t(rowSelectionAllowed): Likewise.\n\t(selectionBackground): Likewise.\n\t(selectionForeground): Likewise.\n\t(selectionModel): Likewise.\n\t(showHorizontalLines): Likewise.\n\t(showVerticalLines): Likewise.\n\t(tableHeader): Likewise.\n\t(JTable): Implemented.\n\t(getColumnModel): Likewise.\n\t(getSelectedRow): Likewise.\n\t(getSelectionModel): Likewise.\n\t(setModel): Likewise.\n\t(setSelectionModel): Likewise.\n\t(createScrollPaneForTable): New method.\n\t(createDefaultDataModel): Likewise.\n\t(createDefaultListSelectionModel): Likewise.\n\t(getModel): Likewise.\n\t(getTableHeader): Likewise.\n\t(setTableHeader): Likewise.\n\t(getColumnSelectionAllowed): Likewise.\n\t(setColumnSelectionAllowed): Likewise.\n\t(getRowSelectionAllowed): Likewise.\n\t(setRowSelectionAllowed): Likewise.\n\t(getAutoResizeMode): Likewise.\n\t(setAutoResizeMode): Likewise.\n\t(getColumnCount): Likewise.\n\t(getRowCount): Likewise.\n\t(getCellRenderer): Likewise.\n\t* javax/swing/JTree.java\n\t(cellRenderer): New field.\n\t(editable): Likewise.\n\t(rootVisible): Likewise.\n\t(showsRootHandles): Likewise.\n\t(getModel): New method.\n\t(setModel): Likewise.\n\t(isEditable): Likewise.\n\t(setEditable): Likewise.\n\t(isRootVisbile): Likewise.\n\t(setRootVisible): Likewise.\n\t(getShowsRootHandles): Likewise.\n\t(setShowRootHandles): Likewise.\n\t(getCellRenderer): Likewise.\n\t(setCellRenderer): Likewise.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JFormattedTextField.java\n\t(setDocument): Implemented.\n\t* javax/swing/JRootPane.java:\n\tFixed javadocs.\n\t* javax/swing/JTable.java\n\t(getDefaultRenderer): New method.\n\t* javax/swing/JTextField.java\n\t(setFont): Likewise.\n\t(getPreferredSize): Likewise.\n\t* javax/swing/JToggleButton.java\n\t(getAccessibleContext): Fix javadoc.\n\t* javax/swing/JTree.java:\n\tAdd some javadocs.\n\t* javax/swing/JViewport.java:\n\tLikewise.\n\n2004-07-21  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkFileDialogPeer.java:\n\tCollect all native method declaration at the top.\n\t(create): Set the filename filter if necessary.\n\t(setDirectory): Call nativeSetDirectory().\n\t(setFilenameFilter): Implement.\n\t(filenameFilterCallback): New method.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkFileDialogPeer.c\n\t(create): Configure dialog to show hidden files.\n\t(filenameFilterCallback): New function.\n\t(nativeSetFilenameFilter): New function.\n\t(nativeSetDirectory): New function.\n\n2004-07-21  Kim Ho  <kho@redhat.com>\n\n\t* javax/swing/plaf/basic/BasicSliderUI.java:\n\tRan Jalopy.\n\t(paintTrack): Fill the track before painting\n\tthe borders.\n\n2004-07-21  Graydon Hoare  <graydon@redhat.com>\n\n\tpatch from Roman Kennke <roman@ontographics.com>\n\t* javax/swing/Spring.java: New file.\n\t* javax/swing/SpringLayout.java: New file.\n\t* Makefile.am: Add new files.\n\t* Makefile.in: Regenerate.\n\n2004-07-21  Graydon Hoare  <graydon@redhat.com>\n\n\t* javax/swing/plaf/basic/BasicSplitPaneUI.java: Minor layout fixes.\n\t* javax/swing/plaf/basic/BasicTabbedPaneUI.java: Likewise.\n\t* javax/swing/ScrollPaneLayout.java: Likewise.\n\n2004-07-21  Kim Ho  <kho@redhat.com>\n\n\t* javax/swing/DefaultDesktopManager.java:\n\t(findMinimum): Removed.\n\t(resizeFrame): Trust the UI to pass valid\n\tbounds.\n\t* javax/swing/JOptionPane.java:\n\tImplemented showInternalXXXDialog methods.\n\t(startModal): New method.\n\t* javax/swing/plaf/basic/BasicInternalFrameUI.java:\n\t(BorderListener::mouseDragged): Verify that the new\n\tbounds are valid before passing them to the DesktopManager.\n\t(preferredLayoutSize): Delegate\n\tto getSize.\n\t(minimumLayoutSize): Ditto.\n\t(getSize): New method.\n\t(GlassPaneDispatcher): Reimplemented by copying\n\ta stripped down LightweightDispatcher from Container.\n\t(getMinimumSize): Call minimumLayoutSize.\n\t* javax/swing/plaf/basic/BasicOptionPaneUI.java:\n\tRan Jalopy.\n\t(mousePressed): Add ability to properly close\n\tJInternalFrames.\n\t* javax/swing/plaf/basic/BasicToolBarUI.java:\n\t(DragWindow): Set owner for DragWindow.\n\n2004-07-21  Jerry Quinn  <jlquinn@optonline.net>\n\n\t* java/awt/image/ShortLookupTable.java: New file.\n\t* java/awt/image/ByteLookupTable.java: New file.\n\t* Makefile.am: Added new files.\n\t* Makefile.in: Regenerated.\n\n2004-07-21  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkFileDialogPeer.java\n\t(create(GtkContainerPeer)): New native method.\n\t(create()): Call native create(), passing in the parent frame\n\tas the paramter. Natively set the current file and directory.\n\t(setFile): Construct an absolute filename before passing it to\n\tthe native peer.\n\t(nativeGetDirectory): New method.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkFileDialogPeer.c\n\t(window_closed): Removed.\n\t(ok_clicked): Likewise.\n\t(cancel_clicked): Likewise.\n\t(handle_response): New method.\n\t(create): Use GtkFileChooserDialog.\n\t(connectSignals): Connect to handle_response.\n\t(nativeGetDirectory): New method.\n\t(nativeSetFile): Use GtkFileChooserDialog.\n\n2004-07-21  Jerry Quinn  <jlquinn@optonline.net>\n\n\t* java/awt/image/LookupTable.java: New file.\n\t* Makefile.am: Added new file.\n\t* Makefile.in: Regenerated.\n\n2004-07-21  Jerry Quinn  <jlquinn@optonline.net>\n\n\t* java/awt/image/Kernel.java: New file.\n\t* Makefile.am: Added new file.\n\t* Makefile.in: Regenerated.\n\n2004-07-21  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/JCheckBoxMenuItem.java: Fixed Javadocs.\n\t* javax/swing/JMenu.java: Likewise.\n\t* javax/swing/JMenuBar.java: Likewise.\n\t(MARGIN_CHANGED_PROPERTY): New property.\n\t(setMargin): Implemented.\n\t* javax/swing/JMenuItem.java: Fixed javadocs.\n\t* javax/swing/JPopupMenuUI.java: Fixed javadocs.\n\t(LABEL_CHANGED_PROPERTY): New property.\n\t(add): changed to use createActionComponent.\n\t(createActionComponent): Implemented.\n\t(setLabel): Fire PropertyChangeEvent if label property\n\tchanges.\n\t* javax/swing/JRadioButtonMenuItem.java: Fixed javadocs.\n\t* javax/swing/plaf/basic/BasicMenuBarUI.java: Likewise.\n\t(ContainerHandler): Repaint if margin property has changed.\n\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n\t(installUI): Call installComponents().\n\t(uninstallUI): Call uinstallComponents().\n\t* javax/swing/plaf/basic/BasicMenuUI.java:\n\tFixed javadocs.\n\t* javax/swing/plaf/basic/BasicPopupMenuUI.java:\n\tLikewise.\n\n2004-07-21  Kim Ho  <kho@redhat.com>\n\n\t* javax/swing/plaf/basic/BasicToolBarUI.java:\n\t(DragWindow): Use the right constructor.\n\n2004-07-21  Kim Ho  <kho@redhat.com>\n\n\t* javax/swing/JToolBar.java:\n\t(layoutContainer): Use getComponents.\n\t* javax/swing/plaf/basic/BasicToolBarUI.java:\n\t(DragWindow): Don't use SwingUtilities'\n\tgetOwnerFrame\n\t(ToolBarDialog): ditto.\n\n2004-07-21  Kim Ho  <kho@redhat.com>\n\n\t* javax/swing/JRootPane.java:\n\tRan jalopy.\n\t(layoutContainer): Set the glasspane's size to\n\tbe the same as the content pane.\n\t(createGlassPane): Set opaque property to false.\n\n2004-07-21  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* java/awt/Component.java (requestFocus()): Don't handle Panels\n\tspecially.\n\t(requestFocus(boolean)): Likewise.\n\t(requestFocusInWindow(boolean)): Likewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkPanelPeer.c (create):\n\tSet GTK_CAN_FOCUS flag.\n\n2004-07-21  Kim Ho  <kho@redhat.com>\n\n\t* Makefile.am: Added new file.\n\t* Makefile.in: Regenerated.\n\t* gcj/Makefile.in: Regenerated.\n\t* include/Makefile.in: Regenerated.\n\t* javax/swing/AbstractButton.java:\n\tAdd rollOverEnabled property.\n\t(setRolloverEnabled): Use new property.\n\t(isRolloverEnabled): Use new property.\n\t* javax/swing/JTabbedPane.java:\n\t(setComponent): Remove useless JTabbedPane.this.\n\t* javax/swing/JToolBar.java: Finish implementation.\n\t* javax/swing/plaf/basic/BasicArrowButton.java:\n\t(paint): Moved border painting to a border.\n\t* javax/swing/plaf/basic/BasicLookAndFeel.java:\n\tChange JToolBar look and feel defaults.\n\t* javax/swing/plaf/basic/BasicOptionPaneUI.java\n\t(actionPerformed): Return Integer index instead of name.\n\t(addButtonComponents): Check to see if component is\n\tJButton last.\n\t(createMessageArea): Don't use components that are not\n\tcompleted yet.\n\t(getIconForType): Use temporary icons.\n\t* javax/swing/plaf/basic/BasicSliderUI.java:\n\t(mousePressed): Do not return if it's on thumb.\n\t(paintMinorTickForHorizSlider): Use BLACK to paint ticks.\n\t(paintMinorTickForVertSlider): ditto.\n\t(paintMajorTickForHorizSlider): ditto.\n\t(paintMajorTickForVertSlider): ditto.\n\t* javax/swing/plaf/basic/BasicSplitPaneDivider.java:\n\tAdd a border around the SplitPaneDivider.\n\t* javax/swing/plaf/basic/BasicSplitPaneUI.java:\n\tRemove comments.\n\t* javax/swing/plaf/basic/BasicToolBarSeparatorUI.java:\n\tNew file. Implemented.\n\t* javax/swing/plaf/basic/BasicToolBarUI.java:\n\tImplemented.\n\t* testsuite/Makefile.in: Regenerated.\n\n2004-07-21  Graydon Hoare  <graydon@redhat.com>\n\n\t* javax/swing/Timer.java (run): Queue events each time cycle.\n\n2004-07-21  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkImagePainter.java\n\t(imageComplete): Call image.imageComplete().\n\t* java/awt/image/MemoryImageSource.java:\n\tReimplement consumers as a Vector instead of a Hashtable.  This is\n\tbecause enumeration on a Hashtable is not thread-safe.\n\t(addConsumer): Adapt to Vector consumers.\n\t(isConsumer): Adapt to Vector consumers.\n\t(removeConsumer): Adapt to Vector consumers.\n\t(startProduction): Adapt to Vector consumers. Call imageComplete()\n\twith STATICIMAGEDONE flag instead of SINGLEFRAME flag.\n\t(newPixels): Adapt to Vector consumers.\n\t(sendPicture): Set the color model of the image consumer.\n\t(newPixels(IIII)): Adapt to Vector consumers.\n\t(newPixels(IIIIB)): Adapt to Vector consumers.\n\n2004-07-21  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* java/awt/Component.java (deliverEvent): Implement.\n\t(postEvent): Implement.\n\t(handleEvent): Implement.\n\t(translateEvent): New method.\n\t(dispatchEventImpl): Document.  Add AWT 1.0 event handling.\n\t* java/awt/Container.java (deliverEvent): Implement.\n\t* java/awt/Event.java (paramString): Fix formatting.\n\t* java/awt/Font.java (toString): Likewise.\n\t* java/awt/Window.java (postEvent): Implement.\n\n2004-07-21  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* java/awt/DefaultKeyboardFocusManager.java (dispatchEvent):\n\tSet window's focus owner upon receiving a FOCUS_LOST event.\n\t* java/awt/Window.java (Window()): Refocus the previously\n\tfocused component within the window when the window regains the\n\ttop-level focus.\n\t(setFocusOwner): New method.\n\t* java/awt/Component.java (requestFocus): Add FIXME.\n\n\t* libgcj.pc.in: Remove library flags.\n\n2004-07-21  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkPanelPeer.java (handleEvent): Handle\n\tMOUSE_PRESSED event.\n\t* java/awt/Component.java (requestFocus()): Handle Panel\n\tspecially.  Post FOCUS_LOST event on opposite component.\n\t(requestFocus(boolean)): Likewise.\n\t(requestFocusInWindow(boolean)): Likewise.\n\t(paramString): Reorder dimension fields.\n\t* java/awt/Container.java (paramString): Fix string format.\n\t* java/awt/DefaultKeyboardFocusManager.java (dispatchEvent):\n\tHandle FOCUS_LOST events.  Don't handle Windows specially.  Only\n\tprocess key events if the focus owner is non-null.\n\t(dispatchKeyEvent): Likewise.\n\t* java/awt/Frame.java (paramString): Fix formatting.\n\t(generateName): New method.\n\t(getUniqueLong): Likewise.\n\t* java/awt/KeyboardFocusManager.java (getFocusOwner): Check if\n\tthe temporary focus owner is null.  If so, return the permanent\n\tfocus owner.\n\t* java/awt/Panel.java (generateName): New method.\n\t(getUniqueLong): Likewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c: Rework\n\tsignal handling to make callbacks more specific.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/text/Position.java\n\t(Bias): Implemented.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/LookAndFeel.java\n\t(provideErrorFeedback): New method.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JTextArea.java\n\t(tabSize): New field.\n\t(getTabSize): New method.\n\t(setTabSize): Likewise.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/ActionMap.java:\n\tFixed javadocs all over.\n\t(serialVersionUID): Made private.\n\t(parent): Don't explicitely initialize with default value.\n\t(get): SImplified.\n\t(keys): Reimplemented.\n\t(allKeys): Likewise.\n\t(convertSet): Removed.\n\t* javax/swing/ComponentInputMap.java:\n\tFixed javadocs all over.\n\t(ComponentInputMap): Implemented.\n\t(put): Likewise.\n\t(clear): Likewise.\n\t(remove): Likewise.\n\t(SetParent): Likewise.\n\t(getComponent): Likewise.\n\t* javax/swing/InputMap.java:\n\tFixed javadocs all over.\n\t(serialVersionUID): Made private.\n\t(parent): Don't explicitely initialize with default value.\n\t(get): SImplified.\n\t(keys): Reimplemented.\n\t(allKeys): Likewise.\n\t(convertSet): Removed.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/ActionMap.java,\n\tjavax/swing/ComponentInputMap.java,\n\tjavax/swing/InputMap.java,\n\tjavax/swing/table/DefaultTableColumnModel.java,\n\tjavax/swing/table/TableColumn.java,\n\tjavax/swing/table/TableColumnModel.java,\n\tjavax/swing/table/TableModel.java,\n\tjavax/swing/text/AbstractDocument.java,\n\tjavax/swing/text/TextAction.java:\n\tReformated.\n\n2004-07-21  Graydon Hoare  <graydon@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkToolkit.java (bufferedImageOrError):\n\tMake method non-static.\n\t* javax/swing/AbstractButton.java:\n\tRename fields to match property names where possible.\n\t(iconTextGap): New property.\n\t* javax/swing/JCheckBox.java: Match AbstractButton changes.\n\t(init) New method, call from after various constructors.\n\t* javax/swing/JComponent.java (revalidate):\n\tInvalidate before queueing repair.\n\t* javax/swing/JList.java (getPreferredScrollableViewportSize):\n\tReimplement in terms of visibleRowCount property.\n\t* javax/swing/JMenuButton.java: Match AbstractButton changes.\n\t* javax/swing/JScrollPane.java (createScrollListener):\n\tRemove tracing chatter.\n\t* javax/swing/JToggleButton.java: Match AbstractButton changes.\n\t* javax/swing/RepaintManager.java (addInvalidComponent):\n\tDon't invalidate.\n\t* javax/swing/ScrollPaneLayout.java: Various corrections to layout\n\tcalculations.\n\t* javax/swing/SwingUtilities.java (layoutCompoundLabel):\n\tMimic sun behavior on top left/right positioning.\n\t* javax/swing/ViewportLayout.java (preferredLayoutSize):\n\tRemove mistaken use of preferredScrollableViewportSize here.\n\t(layoutContainer): Use view's preferred size as basis.\n\t* javax/swing/plaf/basic/BasicButtonUI.java:\n\tSet, get, and use textIconGap property.\n\t(paint) Paint text returned from layout (with ellipsis).\n\t* javax/swing/plaf/basic/BasicListUI.java:\n\tRemove tracing chatter, correct various minor calculations.\n\t(getCellBounds): Update layout state before calculating.\n\t* javax/swing/plaf/basic/BasicLookAndFeel.java (Button.Margin):\n\tUse margin default similar to sun's.\n\t* javax/swing/plaf/basic/BasicScrollBarUI.java (ArrowIcon):\n\t(createIncreaseIcon): Center icon, minimize margins.\n\t(createDecreaseIcon): Likewise.\n\t* javax/swing/plaf/basic/BasicScrollPaneUI.java (installDefaults):\n\tImplement.\n\t(installUI): Call it.\n\t(uninstallDefaults): Implement.\n\t(uninstallUI): Call it.\n\t* javax/swing/plaf/basic/BasicToolBarUI.java (DragWindow):\n\tCall existing Window constructor.\n\t* javax/swing/plaf/basic/BasicViewportUI.java (paint):\n\tSet clip before painting.\n\n2004-07-21  Olga Rodimina <rodimina@redhat.com>\n\n\t* javax/swing/JMenuItem.java:\n\t(processMouseEvent): Reimplemented to deal with\n\tmouse drag events.\n\t(createMenuDragMouseEvent): New private helper method.\n\tCreates MenuDragMouseEvent.\n\t* javax/swing/MenuSelectionManager.java\n\t(componentForPoint): Implemented.\n\t(isComponentPartOfCurrentMenu): Made public.\n\t(processMouseEvent): Reimplemented to deal with\n\tmouse drag events.\n\t(setSelectedPath): Corrected small mistake that caused\n\tpath to be set incorrectly.\n\t(getPath): If given component is JMenu then also add this\n\tmenu's popup menu to the selected path.\n\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n\t(getPath): Ditto.\n\t(getPreferredSize): Call getPreferredMenuItemSize().\n\t(getPreferredItemSize): Moved code from getPreferredSize to here.\n\t(installListeners): Install MouseMotionListeners.\n\t(MouseInputHandler): Pass mouse release event to MenuSelectionManager\n\tif mouse wasn't released in the bounds of this menu item.\n\t(MenuDragMouseHandler): Implemented.\n\t* javax/swing/plaf/basic/BasicMenuUI.java:\n\t(installListeners): Install MouseMotionListener and\n\tMenuDrageMouseListener.\n\t(MenuDragMouseHandler): Implemented.\n\t* javax/swing/plaf/basic/BasicPopupMenuUI.java:\n\t(uninstallListeners): Implemented.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JCheckBox.java: Reformated.\n        (JCheckBox): Fixed all constructors.\n        (isBorderPaintedFlat): New method.\n        (setBorderPaintedFlat): New method.\n\t* javax/swing/JEditorPane.java\n        (createEditorKitForContentType): Made public.\n        (scrollToReference): Likewise.\n\t* javax/swing/JTextArea.java\n        (setLineWrap): Fire property change.\n\t* javax/swing/JToggleButton.java\n        (JToggleButton): New constructor.\n        (JToggleButton): Simplified.\n\t* javax/swing/text/AttributeSet.java\n        (FontAttribute): Renamed from FontCharacterAttribute.\n\t* javax/swing/text/JTextComponent.java\n        (KeyBinBinding): Added javadoc.\n        (JTextComponent): Likewise.\n        (getAccessibleContext): Fixed javadoc.\n\t* javax/swing/text/View.java\n        (View): Added javadoc.\n\t* javax/swing/text/TabableView.java: New file.\n\t* Makefile.am: Added javax/swing/text/TabableView.java.\n\t* Makefile.in: Regenerated.\n\n2004-07-21  Graydon Hoare  <graydon@redhat.com>\n\n\t* java/awt/image/BufferedImage.java (getSource): Remove tracing chatter.\n\t* gnu/java/awt/peer/gtk/GtkToolkit.java\n\t(GtkErrorImage): New helper class.\n\t(bufferedImageOrError): New helper method.\n\t(createImage): Use it.\n\n2004-07-21  David Jee  <djee@redhat.com>\n\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextComponentPeer.c\n\t(setCaretPosition): Scroll the text view so the new caret position\n\tis visible on screen.\n\n2004-07-21  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkContainerPeer.java\n\t(setBounds): Do not validate awtComponent here.\n\t* gnu/java/awt/peer/gtk/GtkScrollPanePeer.java\n\t(getPreferredSize): New method.\n\t* java/awt/ScrollPane.java\n\t(ScrollPane): Set default size to 100x100.\n\t(addNotify): If child is not a Panel, wrap it with a new Panel.\n\t(paramString): Implement.\n\n2004-07-21  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/JMenu.java:\n\t(setSelected): Display popup menu only if this menu\n\tis showing on the screen.\n\t* javax/swing/JPopupMenu.java:\n\t(processMouseEvent): Added comment.\n\t(processKeyEvent): Likewise.\n\t* javax/swing/MenuSelectionManager.java:\n\t(clearSelectedPath): Only fireStateChanged() after\n\tselected path was changed, not before.\n\t(setSelectedPath): Likewise.\n\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n\t(paintMenuItem): Corrected position of menu item's\n\ticon.\n\t* javax/swing/plaf/basic/BasicPopupMenuUI.java:\n\t(installUI): Correct setDefaultLightWeightPopupEnabled call.\n\t(popupMenuCanceled): Reimplemented.\n\t(popupMenuWillBecomeVisible): Select first menu item by default\n\twhen displaying free floating popup menus.\n\t(TopWindowListener): Reimplemented.\n\n2004-07-21  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* java/awt/Panel.java (dispatchEventImpl): Override to prevent\n\tPanel from being painted twice when it is first shown.\n\n2004-07-21  Olga Rodimina  <rodimina@redhat.com>\n\n\t* java/awt/Window.java: Reverted changes from my\n\tprevious patch for creating window without an owner.\n\t* javax/swing/SwingUtilities.java:\n\t(SwingUtilities.OwnerFrame): made static.\n\t(OwnerFrame.setVisible): New method. Overridden with\n\tempty implementation.\n\t(OwnerFrame.isShowing): New method. Ovverridden\n\tto return always true.\n\n2004-07-21  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java,\n\tjni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n\t(GtkComponentPeer): Remove temporary try/catch block.\n\t(setVisible): Call show and hide.\n\t(show): Make native.\n\t(hide): Likewise.\n\t(getArgs): Don't add \"visible\" argument.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c\n\t(property_notify_predicate): Return Bool instead of int.\n\t(find_layout): New function.\n\t(connectJObject): Call find_layout.\n\t(connectSignals): Likewise.\n\t(moveLayout): Likewise.\n\t(gtkLayoutSetVisible): Likewise.\n\n2004-07-21  Mark Wielaard  <mark@klomp.org>\n\n\t* java/awt/event/InvocationEvent.java (dispatch): Synchronize\n\ton notifier object before calling notifyAll().\n\n2004-07-21  Olga Rodimina  <rodimina@redhat.com>\n\n\t* java/awt/Window.java: Changed constructors to use new\n\tmethod that is described below. Constructors call this\n\tmethods only if newly created window should have an owner.\n\t(setWindowOwner): New method. Implementation for\n\tthis method is moved from this(owner,configuration).\n\t* javax/swing/JWindow.java:\n\t(JWindow): Reimplement to use SwingUtilities.ownerFrame\n\tinstead of owner.\n\t* javax/swing/SwingUtilities.java:\n\t(ownerFrame): Change type of this field to OwnerFrame.\n\t(getOwnerFrame): Changed to return object of type OwnerFrame.\n\t(SwingUtilities.OwnerFrame): New class. Represents owner\n\tof a Window that is not provided with one.\n\n2004-07-21  Olga Rodimina  <rodimina@redhat.com>\n\n\t*  javax/swing/AbstractButton.java:\n\t(configurePropertiesFromAction): Set action command\n\tto button's text by default if action command is not\n\texplicitely specified.\n\t* javax/swing/JMenu.java: Remove unnecessary listener\n\tand methods relevant to it.\n\t(setSelected): Reimplemented.\n\t(menuSelectionChanged): Moved most part of implementation to\n\tsetSelected() and call it instead.\n\t* javax/swing/JMenuItem.java:\n\t(init): Comment out statement that sets paint_border to false.\n\t(configurePropertiesFromAction): Do not set accelerator\n\tfor JMenu.\n\t(menuSelectionChanged): Change selected index in the selection\n\tmodel of menu item's parent.\n\t* javax/swing/JPopupMenu.java:\n\t(remove): Set constraints.fill field to GridBagConstraints.BOTH\n\tinstead of GridBagConstraints.HORIZONTAL.\n\t(insert): Likewise.\n\t(createActionChangeListener): Implemented.\n\t(setVisible): Correct location of HeavyWeightMenu and\n\tdon't firePopupMenuCanceled().\n\t(menuSelectionChanged): Implemented.\n\t(ActionChangeListener): New Listener. Implemented.\n\t* javax/swing/plaf/basic/BasicMenuBarUI.java:\n\t(BasicMenuBarUI.ContainerHandler): Implemented.\n\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n\t(paintMenuItem): Uncommented out code that paints\n\ticon, now that icons are working properly.\n\t(PropertyChangeListener): Implemented.\n\t* javax/swing/plaf/basic/BasicPopupMenuUI.java:\n\tAdded javadocs.\n\t(topWindowListener): New field.\n\t(Constructor): initialize topWindowListener.\n\t(BasicPopupMenuUI.TopWindowListener): Implemented.\n\t(BasicPopupMenuUI.PopupMenuHandler): Implemented.\n\t(BasicPopupMenuUI.TopWindowListener): New ComponentListener.\n\tImplemented.\n\n\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/plaf/basic/BasicButtonUI.java\n\t(paintFocus): Fixed method signature.\n\t(paintButtonPressed): Likewise.\n\t(paintButtonNormal): Likewise.\n\t(paintText): New method.\n\t* javax/swing/plaf/basic/BasicLabelUI.java\n\t(paint): Re-indented.\n\t* javax/swing/plaf/basic/BasicTextUI.java\n\t(installUI): Set parent textComponent to opaque.\n\t* javax/swing/text/DefaultHighlighter.java\n\t(checkPositions): New helper method.\n\t(addHighlight): Throws BadLocationException, check positions.\n\t(changeHighlight): Likewise.\n\t* javax/swing/text/EditorKit.java\n\t(EditorKit): Implements Serializable.\n\t* javax/swing/text/JTextComponent.java\n\t(getUI): Added javadoc.\n\t(setUI): Likewise.\n\t(upadteUI): Added javadoc, don't revalidate and repaint.\n\n2004-07-21  David Jee  <djee@redhat.com>\n\n\t* java/awt/GridBagLayout.java\n\t(ArrangeGrid): Use PREFERREDSIZE instead of MINSIZE.\n\t* javax/swing/AbstractButton.java\n\t(setText): Reindent.\n\t* javax/swing/RepaintManager.java\n\t(addInvalidComponent): Find the first ancestor that isValidateRoot().\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JFormattedTextField.java\n\t(value): New field.\n\t(JFormattedTextField): Implemented.\n\t(getValue): Likewise.\n\t(setValue): Likewise.\n\t* javax/swing/LookAndFeel.java\n\t(getSupportsWindowDecorations): New method.\n\t* javax/swing/UIDefaults.java:\n\tUse java.beans.PropertyChangeSupport instead of doing all ourself.\n\t(addPropertyChangeListener): Made public.\n\t(addResourceBundle): Likewise.\n\t(removeResourceBundle): Likewise.\n\t(setDefaultLocale): Likewise.\n\t* javax/swing/plaf/basic/BasicRootPaneUI.java\n\t(BasicRootPaneUI): Implements PropertyChangeListener.\n\t(propertyChange): New method.\n\t* javax/swing/plaf/basic/BasicTextUI.java\n\t(BasicHighlighter): New inner class.\n\t(createHighlighter): New method.\n\t* javax/swing/plaf/basic/BasicToolBarUI.java\n\t(DragWindow): Extends java.awt.Window.\n\t* javax/swing/text/JTextComponent.java\n\t(getDocument): Removed debug output.\n\t* javax/swing/plaf/basic/BasicTextFieldUI.java,\n\tjavax/swing/text/DefaultHighlighter.java,\n\tjavax/swing/text/FieldView.java,\n\tjavax/swing/text/PlainView.java: New files.\n\t* Makefile.am: Added new files.\n\t* Makefile.in: Regenerated.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JEditorPane.java\n\t(createDefaultEditorKit): Use javax.swing.text.DefaultEditorKit.\n\t(createEditorKitForContentType): Likewise.\n\t* javax/swing/text/DefaultEditorKit.java\n\t(serialVersionUID): Added constant field.\n\t(EndOfLineStringPropery): Fixed typo.\n\t(DefaultEditorKit): New constructor.\n\t* javax/swing/text/Segment.java:\n\tImport java.text.CharacterIterator.\n\t* javax/swing/text/CharacterIterator.java,\n\tjavax/swing/text/PlainEditorKit.java: Removed.\n\t* Makefile.am: Removed javax/swing/text/CharacterIterator.java and\n\tjavax/swing/text/PlainEditorKit.java.\n\t* Makefile.in: Regenerated.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JButton.java,\n\tjavax/swing/text/DefaultEditorKit.java,\n\tjavax/swing/text/EditorKit.java,\n\tjavax/swing/text/Segment.java,\n\tjavax/swing/text/StyledEditorKit.java:\n\tReformatted.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/ImageIcon.java\n\t(file): Removed.\n\t(description): Renamed from descr.\n\t(ImageIcon): Added missing constructors.\n\t(setParent): Removed.\n\t(setImageObserver): New method.\n\t(getImageObserver): New method.\n\t(paintIcon): Handle observer = null.\n\t* javax/swing/JButton.java\n\t(removeNotify): Fixed javadoc.\n\t(updateUI): Simplified.\n\t* javax/swing/JRootPane.java\n\t(serialVersionUID): New constant field.\n\t* javax/swing/UIManager.java:\n\tFixed javadocs all over.\n\t(setLookAndFeel): Throws UnsupportedLookAndFeelException.\n\t* javax/swing/text/AbstractDocument.java\n\t(createPosition): Throws BadLocationException.\n\t(getText): Likewise.\n\t(remove): Likewise.\n\t* javax/swing/text/ComponentView.java\n\t(modelToView): Likewise.\n\t* javax/swing/text/DefaultEditorKit.java:\n\tMade all public methods public.\n\t(read): Throws BadLocationException and IOException.\n\t(write): Likewise.\n\t* javax/swing/text/EditorKit.java:\n\tMade all public methods public.\n\t(serialVersionUID): New constant field.\n\t(clone): New method.\n\t(read): Throws BadLocationException and IOException.\n\t(write): Likewise.\n\t* javax/swing/text/Segment.java\n\t(array): Made public.\n\t(count): Likewise.\n\t(offset): Likewise.\n\t(Segment): New constructors.\n\t(clone): Reimplemented.\n\t* javax/swing/text/StyledEditorKit.java\n\t(serialVersionUID): New constant field.\n\n2004-07-21  Graydon Hoare  <graydon@redhat.com>\n\n\t* java/awt/image/BufferedImage.java\n\t(getSource): Implement.\n\t* javax/swing/ImageIcon.java\n\t(ImageIcon): Implement ctor.\n\t* javax/swing/ScrollPaneLayout.java\n\t(preferredLayoutSize): Be more careful about nulls.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/text/AttributeSet.java\n\t(CharacterAttribute): New interface\n\t(ColorAttribute): Likewise.\n\t(FontCharacterAttribute): Likewise.\n\t(ParagraphAttribute): Likewise.\n\t* javax/swing/text/DefaultCaret.java\n\t(moveCaret): New method.\n\t(positionCaret): Likewise.\n\t(repaint): Made protected.\n\t* javax/swing/text/JTextComponent.java\n\t(KeyBinding): Made it static.\n\t* javax/swing/text/View.java\n\t(getContainer): Honor parent == null.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/text/AbstractDocument.java:\n\tReformatted.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/plaf/basic/BasicRootPaneUI.java:\n\tImport javax.swing.UIManager explicitely.\n\t* javax/swing/plaf/basic/BasicTabbedPaneUI.java\n\t(ScrollingButton): Made it static.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/UIDefaults.java\n\t(ActiveValue): Made public.\n\t(LazyValue): Likewise.\n\t* javax/swing/plaf/basic/BasicTextUI.java\n\t(RootView): Reintroduced.\n\t(view): Removed.\n\t(rootView): New field.\n\t(installUI): Create document if needed, initialize rootView.\n\t(uninstallUI): Hanle rootView.\n\t(paint): Likewise.\n\t(getRootView): Likewise.\n\t(setView): Likewise.\n\t* javax/swing/text/DefaultCaret.java:\n\tRenamed all \"evt\" variables to \"event\".\n\n2004-07-21  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* libgcj.spec.in: Add -l-java-util-logging.\n\n2004-07-21  Andreas Tobler  <a.tobler@schweiz.ch>\n\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMainThread.c\n\t(init_dpi_conversion_factor): Check for int_dpi < 0 in case\n\tgtk-xft-dpi can no calculate the right value.\n\t(dpi_changed_cb): Mark *pspec as unsused.\n\n2004-07-21  David Jee  <djee@redhat.com>\n\n\t* java/awt/Component.java\n\t(move): Delegate to setBounds().\n\t(resize): Likewise.\n\t(reshape): Fix so it repaints parent and self only when necessary.\n\n2004-07-21  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java,\n\tjni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n\t(GtkComponentPeer): Revert previous patch from 2004-06-22.\n\t(setVisible): Likewise.\n\t(show): Likewise.\n\t(hide): Likewise.\n\t(getArgs): Likewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c\n\t(property_notify_predicate): Likewise.\n\t(find_layout): Likewise.\n\t(connectJObject): Likewise.\n\t(connectSignals): Likewise.\n\t(moveLayout): Likewise.\n\t(gtkLayoutSetVisible): Likewise.\n\n2004-07-21  Graydon Hoare  <graydon@redhat.com>\n\n\t* Makefile.am\n\t(jv_convert_LDADD):\n\t(gij_LDADD):\n\t(rmic_LDADD):\n\t(rmiregistry_LDADD): Add lib-java-util-logging.la\n\t* Makefile.in: Regenerate.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/text/AbstractDocument.java\n\t(replace): Dont use protected method of java.util.Vector directly.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/plaf/basic/BasicTextUI.java\n\t(installUI): Call specialized install methods.\n\t(installDefaults): New method.\n\t(installListeners): Likewise.\n\t(installKeyboardActions): Likewise.\n\t(uninstallUI): Likewise.\n\t(uninstallDefaults): New method.\n\t(uninstallListeners): Likewise.\n\t(uninstallKeyboardActions): Likewise.\n\t(getPropertyPrefix): New abstract method.\n\t(paint): Made final, just call paintSafely().\n\t(paintSavely): New method.\n\t(paintBackground): Likewise.\n\t(getVisibleEditorRect): Likewise.\n\t* javax/swing/text/LayeredHighlighter.java,\n\tjavax/swing/text/TabExpander.java: New files.\n\t* Makefile.am: Added javax/swing/text/LayeredHighlighter.java\n\tand javax/swing/text/TabExpander.java.\n\t* Makefile.in: Regenerated.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/plaf/basic/BasicTextUI.java\n\t(BasicTextUI): Made abstract.\n\t(BasicCaret): New inner class.\n\t(view): Don't explicitely initialize with \"null\".\n\t(textComponent): New field.\n\t(textColor): Removed.\n\t(disabledTextColor): Removed.\n\t(normalBackgroundColor): Removed.\n\t(RootView): Removed commented out inner class.\n\t(createUI): Removed.\n\t(createCaret): New method.\n\t(getComponent): Likewise.\n\t(installUI): Initialize textComponent only.\n\t(getPreferredSize): Use installed JTextComponent.\n\t(setView): New method.\n\t(create): Likewise.\n\t* javax/swing/text/JTextComponent.java\n\t(highlighter): New field.\n\t(caretColor): Likewise.\n\t(disabledTextColor): Likewise.\n\t(seletedTextColor): Likewise.\n\t(selectionColor): Likewise.\n\t(setUI): New method.\n\t(getCaretColor): Likewise.\n\t(setCaretColor): Likewise.\n\t(getDisabledColor): Likewise.\n\t(setDisabledColor): Likewise.\n\t(getSelectedTextColor): Likewise.\n\t(setSelectedTextColor): Likewise.\n\t(getSelectionColor): Likewise.\n\t(setSelectionColor): Likewise.\n\t(getHighlighter): Likewise.\n\t(setHighlighter): Likewise.\n\t(replaceSelection): Likewise.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/plaf/basic/BasicScrollPaneUI.java\n\t(BasicScrollPaneUI): Implements ScrollPaneConstants.\n\t* javax/swing/plaf/basic/BasicToolBarUI.java\n\t(BasicToolBarUI): Implements SwingConstants.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JPopupMenu.java: Removed CVS tags.\n\t* javax/swing/UIDefaults.java: Reformatted.\n\t* javax/swing/plaf/basic/BasicRootPaneUI.java:\n\tExplicitely import used classes.\n\n2004-07-21  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java,\n\tjni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n\t(GtkComponentPeer): Remove temporary try/catch block.\n\t(setVisible): Call show and hide.\n\t(show): Make native.\n\t(hide): Likewise.\n\t(getArgs): Don't add \"visible\" argument.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c\n\t(property_notify_predicate): Return Bool instead of int.\n\t(find_layout): New function.\n\t(connectJObject): Call find_layout.\n\t(connectSignals): Likewise.\n\t(moveLayout): Likewise.\n\t(gtkLayoutSetVisible): Likewise.\n\n2004-07-21  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/AbstractButton.java:\n\t(setDisplayedMnemonicIndex): Check if button\n\ttext is not null before checking its length.\n\t* javax/swing/JMenuItem.java:\n\t(processMouseEvent): Disarm menu item if mouse has\n\texited it.\n\t* javax/swing/plaf/basic/BasicMenuUI.java:\n\t(MouseInputHandler.mouseEntered): Do not raise\n\tpopup menu if this menu is already selected.\n\t(MouseInputHandler.mousePressed): Do not fire\n\tMenuEvents.\n\t(MenuHandler): Implemented.\n\n2004-07-21  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/JCheckBoxMenuItem.java: Added Javadoc.\n\t(getSelectedObjects): Implemented.\n\t* javax/swing/JRadioButtonMenuItem.java: Added Javadoc.\n\t* javax/swing/plaf/basic/BasicCheckBoxMenuItemUI.java:\n\tAdded javadoc for few methods.\n\t(processMouseEvent): Made public.\n\t* javax/swing/plaf/basic/BasicRadioButtonMenuItemUI.java\n\t(processMouseEvent): Likewise.\n\n2004-07-21  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/AbstractButton.java:\n\t(init): Set display mnemonic index to -1.\n\t(setMnemonic(char)): Use setMnemonic(int).\n\t(setMnemonic(int)): Set display mnemonic index.\n\t(getDisplayedMnemonicIndex): Change method signature\n\tby removing 'index' parameter.\n\t* javax/swing/plaf/basic/BasicLookAndFeel.java:\n\tAdded default for Menu.selectionBackground.\n\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n\t(paintMenuItem): Change background color of the selected\n\tmenu item.\n\t(paintText): Paint differently when menu item is disabled.\n\tAlso paint mnemonic if it appears in the menu item's label.\n\t(paintAccelerator): Paint accelerator differently\n\tif menu item is disabled.\n\t* javax/swing/plaf/basic/BasicMenuUI.java:\n\t(installDefaults): Install defaults for\n\tselectionForeground and selectionBackground.\n\t(uninstallDefaults): Uninstall defauls for\n\tselectionForeground and selectionBackground.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/text/AbstractDocument.java\n\t(BranchElement): Implemented.\n\t(LeafElement): Implemented.\n\t* javax/swing/text/DefaultCaret.java:\n\tImport used classes.\n\t(serialVersionUID): New constant.\n\t* javax/swing/text/JTextComponent.java\n\t(AccessibleJTextComponent): Removed dead declaration.\n\t(caretPos): Removed.\n\t(setCaret): New method.\n\t* javax/swing/text/PlainDocument.java\n\t(rootElement): New field.\n\t(PlainDocument): Initialize rootElement.\n\t(createDefaultRoot): New method.\n\t(getDefaultRootElement): Implemented.\n\t* javax/swing/text/View.java: Reformatted.\n\t* javax/swing/text/ViewFactory.java\n\t(create): Added javadoc.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/ToolTipManager.java: Reformatted.\n\n2004-07-21  Rodimina Olga  <rodimina@redhat.com>\n\n\t* javax/swing/AbstractButton.java\n\t(changeEvent): New field.\n\t(fireItemStateChanged): Change source of the event\n\tto 'this' before firing it to button listeners.\n\t(fireActionPerformed): Likewise.\n\t(fireStateChanged): Likewise.\n\t(createActionListener): Do not set source\n\tof the event to AbstractButton.\n\t* javax/swing/plaf/basic/BasicMenuBarUI.java:\n\t(ContainerHandler.componentAdded): Removed\n\tprint out statement.\n\t(ContainerHandler.componentRemoved): Likewise.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/text/Highlighter.java: New file.\n\t* Makefile.am: Added javax/swing/text/Highlighter.java.\n\t* Makefile.in: Regenerated.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/ToolTipManager.java\n\t(stillInsideTimerAction): Fixed constructor arguments.\n\t(outsideTimerAction): Likewise.\n\t(insideTimerAction): Likewise.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JButton.java: Reformatted.\n\t* javax/swing/JFormattedTextField.java\n\t(getUIClassID): Implemented.\n\t* javax/swing/JRootPane.java\n\t(serialVersionUID): New constant.\n\t* javax/swing/JTextField.java\n\t(align): New field.\n\t(JTextField): Simplified.\n\t(getUIClassID): New method.\n\t(getActionListeners): Added @since tag.\n\t(setColumns): Invalidate layout and repaint.\n\t(getHorizontalAlignment): New method.\n\t(setHorizontalAlignment): New method.\n\t(selectAll): Removed.\n\t* javax/swing/SwingUtilities.java\n\t(getAncestorOfClass): Removed redundant @see tag.\n\t(isLeftMouseButton): Fixed implementation.\n\t(isMiddleMouseButton): Likewise.\n\t(isRightMouseButton): Likewise.\n\t* javax/swing/text/AbstractDocument.java\n\t(AttributeContext.addAttribute): New method.\n\t(AttributeContext.addAttributes): New method.\n\t(AttributeContext.getEmptySet): New method.\n\t(AttributeContext.reclaim): New method.\n\t(AttributeContext.removeAttribute): New method.\n\t(AttributeContext.removeAttributes): New method.\n\t* javax/swing/text/Document.java\n\t(createPosition): Throws BadLocationException.\n\t(getText): Likewise.\n\t(remove): Likewise.\n\t* javax/swing/text/JTextComponent.java\n\t(getText): Return null if no document is set. Catch\n\tBadLocationException.\n\t(getUI): Return ui.\n\t(updateUI): Simplified.\n\n2004-07-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/JButton.java\n\t(removeNotify): Fixed javadoc.\n\t(updateUI): Simplified.\n\n2004-07-21  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/image/ImageDecoder.java\n\t(startProduction): Only add consumer if it's not added yet.\n\t* gnu/java/awt/peer/gtk/GdkPixbufDecoder.java\n\t(GdkPixbufDecoder): Don't call initState() here.\n\t(produce): Call initState() here, to ensure area_prepared and\n\tarea_updated signals are properly connected.\n\t* gnu/java/awt/peer/gtk/GtkImage.java\n\t(setColorModel): Use equals() to compare ColorModel objects.\n\t(setPixels): Likewise.\n\t* java/awt/image/ColorModel.java\n\t(equals): Fix typo. Use Arrays.equals() to compare int arrays.\n\t* java/awt/image/RGBImageFilter.java\n\t(setColorModel): Set consumer's color model.\n\t(setPixels): Use equals() to compare ColorModel objects.\n\nFrom-SVN: r85051", "tree": {"sha": "f12d115970aa1d943714b44a6955684fbb547d16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f12d115970aa1d943714b44a6955684fbb547d16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e99fb4f70a03741b3be630a290932c4de63ce23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e99fb4f70a03741b3be630a290932c4de63ce23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e99fb4f70a03741b3be630a290932c4de63ce23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e99fb4f70a03741b3be630a290932c4de63ce23/comments", "author": null, "committer": null, "parents": [{"sha": "4261159083dfcfea414490c157244ed20529255e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4261159083dfcfea414490c157244ed20529255e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4261159083dfcfea414490c157244ed20529255e"}], "stats": {"total": 14060, "additions": 10827, "deletions": 3233}, "files": [{"sha": "8b09956c72208904bac7bdc6fc2625b8fdff3f5b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 1143, "deletions": 0, "changes": 1143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -1,3 +1,1146 @@\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JTextArea.java\n+\t(setLineWrap): Fire property change event after new value is set.\n+\t(setTabSize): Likewise.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JTable.java\n+\t(autoCreateColumnsFromModel): New field.\n+\t(autoResizeMode): Likewise.\n+\t(cellEditor): Likewise.\n+\t(cellSelectionEnabled): Likewise.\n+\t(columnModel): Likewise.\n+\t(dataModel): Likewise.\n+\t(defaultEditorsByColumnClass): Likewise.\n+\t(defaultRenderersByColumnClass): Likewise.\n+\t(editingColumn): Likewise.\n+\t(editingRow): Likewise.\n+\t(gridColor): Likewise.\n+\t(preferredViewportSize): Likewise.\n+\t(rowHeight): Likewise.\n+\t(rowMargin): Likewise.\n+\t(rowSelectionAllowed): Likewise.\n+\t(selectionBackground): Likewise.\n+\t(selectionForeground): Likewise.\n+\t(selectionModel): Likewise.\n+\t(showHorizontalLines): Likewise.\n+\t(showVerticalLines): Likewise.\n+\t(tableHeader): Likewise.\n+\t(JTable): Implemented.\n+\t(getColumnModel): Likewise.\n+\t(getSelectedRow): Likewise.\n+\t(getSelectionModel): Likewise.\n+\t(setModel): Likewise.\n+\t(setSelectionModel): Likewise.\n+\t(createScrollPaneForTable): New method.\n+\t(createDefaultDataModel): Likewise.\n+\t(createDefaultListSelectionModel): Likewise.\n+\t(getModel): Likewise.\n+\t(getTableHeader): Likewise.\n+\t(setTableHeader): Likewise.\n+\t(getColumnSelectionAllowed): Likewise.\n+\t(setColumnSelectionAllowed): Likewise.\n+\t(getRowSelectionAllowed): Likewise.\n+\t(setRowSelectionAllowed): Likewise.\n+\t(getAutoResizeMode): Likewise.\n+\t(setAutoResizeMode): Likewise.\n+\t(getColumnCount): Likewise.\n+\t(getRowCount): Likewise.\n+\t(getCellRenderer): Likewise.\n+\t* javax/swing/JTree.java\n+\t(cellRenderer): New field.\n+\t(editable): Likewise.\n+\t(rootVisible): Likewise.\n+\t(showsRootHandles): Likewise.\n+\t(getModel): New method.\n+\t(setModel): Likewise.\n+\t(isEditable): Likewise.\n+\t(setEditable): Likewise.\n+\t(isRootVisbile): Likewise.\n+\t(setRootVisible): Likewise.\n+\t(getShowsRootHandles): Likewise.\n+\t(setShowRootHandles): Likewise.\n+\t(getCellRenderer): Likewise.\n+\t(setCellRenderer): Likewise.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JFormattedTextField.java\n+\t(setDocument): Implemented.\n+\t* javax/swing/JRootPane.java:\n+\tFixed javadocs.\n+\t* javax/swing/JTable.java\n+\t(getDefaultRenderer): New method.\n+\t* javax/swing/JTextField.java\n+\t(setFont): Likewise.\n+\t(getPreferredSize): Likewise.\n+\t* javax/swing/JToggleButton.java\n+\t(getAccessibleContext): Fix javadoc.\n+\t* javax/swing/JTree.java:\n+\tAdd some javadocs.\n+\t* javax/swing/JViewport.java:\n+\tLikewise.\n+\n+2004-07-21  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkFileDialogPeer.java:\n+\tCollect all native method declaration at the top.\n+\t(create): Set the filename filter if necessary.\n+\t(setDirectory): Call nativeSetDirectory().\n+\t(setFilenameFilter): Implement.\n+\t(filenameFilterCallback): New method.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkFileDialogPeer.c\n+\t(create): Configure dialog to show hidden files.\n+\t(filenameFilterCallback): New function. \n+\t(nativeSetFilenameFilter): New function.\n+\t(nativeSetDirectory): New function.\n+\n+2004-07-21  Kim Ho  <kho@redhat.com>\n+\n+\t* javax/swing/plaf/basic/BasicSliderUI.java:\n+\tRan Jalopy.\n+\t(paintTrack): Fill the track before painting\n+\tthe borders.\n+\n+2004-07-21  Graydon Hoare  <graydon@redhat.com>\n+\n+\tpatch from Roman Kennke <roman@ontographics.com>\n+\t* javax/swing/Spring.java: New file.\n+\t* javax/swing/SpringLayout.java: New file.\n+\t* Makefile.am: Add new files.\n+\t* Makefile.in: Regenerate.\n+\n+2004-07-21  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* javax/swing/plaf/basic/BasicSplitPaneUI.java: Minor layout fixes.\n+\t* javax/swing/plaf/basic/BasicTabbedPaneUI.java: Likewise.\n+\t* javax/swing/ScrollPaneLayout.java: Likewise.\n+\n+2004-07-21  Kim Ho  <kho@redhat.com>\n+\n+\t* javax/swing/DefaultDesktopManager.java:\n+\t(findMinimum): Removed.\n+\t(resizeFrame): Trust the UI to pass valid \n+\tbounds.\n+\t* javax/swing/JOptionPane.java:\n+\tImplemented showInternalXXXDialog methods.\n+\t(startModal): New method.\n+\t* javax/swing/plaf/basic/BasicInternalFrameUI.java:\n+\t(BorderListener::mouseDragged): Verify that the new \n+\tbounds are valid before passing them to the DesktopManager.\n+\t(preferredLayoutSize): Delegate\n+\tto getSize.\n+\t(minimumLayoutSize): Ditto.\n+\t(getSize): New method.\n+\t(GlassPaneDispatcher): Reimplemented by copying \n+\ta stripped down LightweightDispatcher from Container.\n+\t(getMinimumSize): Call minimumLayoutSize.\n+\t* javax/swing/plaf/basic/BasicOptionPaneUI.java:\n+\tRan Jalopy.\n+\t(mousePressed): Add ability to properly close \n+\tJInternalFrames.\n+\t* javax/swing/plaf/basic/BasicToolBarUI.java:\n+\t(DragWindow): Set owner for DragWindow.\n+\n+2004-07-21  Jerry Quinn  <jlquinn@optonline.net>\n+\n+\t* java/awt/image/ShortLookupTable.java: New file.\n+\t* java/awt/image/ByteLookupTable.java: New file.\n+\t* Makefile.am: Added new files.\n+\t* Makefile.in: Regenerated.\n+\n+2004-07-21  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkFileDialogPeer.java\n+\t(create(GtkContainerPeer)): New native method.\n+\t(create()): Call native create(), passing in the parent frame\n+\tas the paramter. Natively set the current file and directory.\n+\t(setFile): Construct an absolute filename before passing it to\n+\tthe native peer.\n+\t(nativeGetDirectory): New method.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkFileDialogPeer.c\n+\t(window_closed): Removed.\n+\t(ok_clicked): Likewise.\n+\t(cancel_clicked): Likewise.\n+\t(handle_response): New method.\n+\t(create): Use GtkFileChooserDialog.\n+\t(connectSignals): Connect to handle_response.\n+\t(nativeGetDirectory): New method.\n+\t(nativeSetFile): Use GtkFileChooserDialog.\n+\n+2004-07-21  Jerry Quinn  <jlquinn@optonline.net>\n+\n+\t* java/awt/image/LookupTable.java: New file.\n+\t* Makefile.am: Added new file.\n+\t* Makefile.in: Regenerated.\n+\n+2004-07-21  Jerry Quinn  <jlquinn@optonline.net>\n+\n+\t* java/awt/image/Kernel.java: New file.\n+\t* Makefile.am: Added new file.\n+\t* Makefile.in: Regenerated.\n+\n+2004-07-21  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* javax/swing/JCheckBoxMenuItem.java: Fixed Javadocs.\n+\t* javax/swing/JMenu.java: Likewise.\n+\t* javax/swing/JMenuBar.java: Likewise.\n+\t(MARGIN_CHANGED_PROPERTY): New property.\n+\t(setMargin): Implemented.\n+\t* javax/swing/JMenuItem.java: Fixed javadocs.\n+\t* javax/swing/JPopupMenuUI.java: Fixed javadocs.\n+\t(LABEL_CHANGED_PROPERTY): New property.\n+\t(add): changed to use createActionComponent.\n+\t(createActionComponent): Implemented.\t\n+\t(setLabel): Fire PropertyChangeEvent if label property\n+\tchanges.\n+\t* javax/swing/JRadioButtonMenuItem.java: Fixed javadocs.\n+\t* javax/swing/plaf/basic/BasicMenuBarUI.java: Likewise.\n+\t(ContainerHandler): Repaint if margin property has changed.\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n+\t(installUI): Call installComponents().\n+\t(uninstallUI): Call uinstallComponents().\n+\t* javax/swing/plaf/basic/BasicMenuUI.java:\n+\tFixed javadocs.\n+\t* javax/swing/plaf/basic/BasicPopupMenuUI.java:\n+\tLikewise.\n+\n+2004-07-21  Kim Ho  <kho@redhat.com>\n+\n+\t* javax/swing/plaf/basic/BasicToolBarUI.java:\n+\t(DragWindow): Use the right constructor.\n+\n+2004-07-21  Kim Ho  <kho@redhat.com>\n+\n+\t* javax/swing/JToolBar.java:\n+\t(layoutContainer): Use getComponents.\n+\t* javax/swing/plaf/basic/BasicToolBarUI.java:\n+\t(DragWindow): Don't use SwingUtilities' \n+\tgetOwnerFrame\n+\t(ToolBarDialog): ditto.\n+\n+2004-07-21  Kim Ho  <kho@redhat.com>\n+\n+\t* javax/swing/JRootPane.java:\n+\tRan jalopy.\n+\t(layoutContainer): Set the glasspane's size to \n+\tbe the same as the content pane.\n+\t(createGlassPane): Set opaque property to false.\n+\n+2004-07-21  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* java/awt/Component.java (requestFocus()): Don't handle Panels\n+\tspecially.\n+\t(requestFocus(boolean)): Likewise.\n+\t(requestFocusInWindow(boolean)): Likewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkPanelPeer.c (create):\n+\tSet GTK_CAN_FOCUS flag.\n+\n+2004-07-21  Kim Ho  <kho@redhat.com>\n+\n+\t* Makefile.am: Added new file.\n+\t* Makefile.in: Regenerated.\n+\t* gcj/Makefile.in: Regenerated.\n+\t* include/Makefile.in: Regenerated.\n+\t* javax/swing/AbstractButton.java:\n+\tAdd rollOverEnabled property.\n+\t(setRolloverEnabled): Use new property.\n+\t(isRolloverEnabled): Use new property.\n+\t* javax/swing/JTabbedPane.java:\n+\t(setComponent): Remove useless JTabbedPane.this.\n+\t* javax/swing/JToolBar.java: Finish implementation.\n+\t* javax/swing/plaf/basic/BasicArrowButton.java:\n+\t(paint): Moved border painting to a border.\n+\t* javax/swing/plaf/basic/BasicLookAndFeel.java:\n+\tChange JToolBar look and feel defaults.\n+\t* javax/swing/plaf/basic/BasicOptionPaneUI.java\n+\t(actionPerformed): Return Integer index instead of name.\n+\t(addButtonComponents): Check to see if component is\n+\tJButton last.\n+\t(createMessageArea): Don't use components that are not\n+\tcompleted yet.\n+\t(getIconForType): Use temporary icons.\n+\t* javax/swing/plaf/basic/BasicSliderUI.java:\n+\t(mousePressed): Do not return if it's on thumb.\n+\t(paintMinorTickForHorizSlider): Use BLACK to paint ticks.\n+\t(paintMinorTickForVertSlider): ditto.\n+\t(paintMajorTickForHorizSlider): ditto.\n+\t(paintMajorTickForVertSlider): ditto.\n+\t* javax/swing/plaf/basic/BasicSplitPaneDivider.java:\n+\tAdd a border around the SplitPaneDivider.\n+\t* javax/swing/plaf/basic/BasicSplitPaneUI.java:\n+\tRemove comments.\n+\t* javax/swing/plaf/basic/BasicToolBarSeparatorUI.java:\n+\tNew file. Implemented.\n+\t* javax/swing/plaf/basic/BasicToolBarUI.java:\n+\tImplemented.\n+\t* testsuite/Makefile.in: Regenerated.\n+\n+2004-07-21  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* javax/swing/Timer.java (run): Queue events each time cycle.\n+\n+2004-07-21  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkImagePainter.java\n+\t(imageComplete): Call image.imageComplete().\n+\t* java/awt/image/MemoryImageSource.java:\n+\tReimplement consumers as a Vector instead of a Hashtable.  This is\n+\tbecause enumeration on a Hashtable is not thread-safe.\n+\t(addConsumer): Adapt to Vector consumers.\n+\t(isConsumer): Adapt to Vector consumers.\n+\t(removeConsumer): Adapt to Vector consumers.\n+\t(startProduction): Adapt to Vector consumers. Call imageComplete()\n+\twith STATICIMAGEDONE flag instead of SINGLEFRAME flag.\n+\t(newPixels): Adapt to Vector consumers.\n+\t(sendPicture): Set the color model of the image consumer.\n+\t(newPixels(IIII)): Adapt to Vector consumers.\n+\t(newPixels(IIIIB)): Adapt to Vector consumers.\n+\n+2004-07-21  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* java/awt/Component.java (deliverEvent): Implement.\n+\t(postEvent): Implement.\n+\t(handleEvent): Implement.\n+\t(translateEvent): New method.\n+\t(dispatchEventImpl): Document.  Add AWT 1.0 event handling.\n+\t* java/awt/Container.java (deliverEvent): Implement.\n+\t* java/awt/Event.java (paramString): Fix formatting.\n+\t* java/awt/Font.java (toString): Likewise.\n+\t* java/awt/Window.java (postEvent): Implement.\n+\n+2004-07-21  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* java/awt/DefaultKeyboardFocusManager.java (dispatchEvent):\n+\tSet window's focus owner upon receiving a FOCUS_LOST event.\n+\t* java/awt/Window.java (Window()): Refocus the previously\n+\tfocused component within the window when the window regains the\n+\ttop-level focus.\n+\t(setFocusOwner): New method.\n+\t* java/awt/Component.java (requestFocus): Add FIXME.\n+\n+\t* libgcj.pc.in: Remove library flags.\n+\n+2004-07-21  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkPanelPeer.java (handleEvent): Handle\n+\tMOUSE_PRESSED event.\n+\t* java/awt/Component.java (requestFocus()): Handle Panel\n+\tspecially.  Post FOCUS_LOST event on opposite component.\n+\t(requestFocus(boolean)): Likewise.\n+\t(requestFocusInWindow(boolean)): Likewise.\n+\t(paramString): Reorder dimension fields.\n+\t* java/awt/Container.java (paramString): Fix string format.\n+\t* java/awt/DefaultKeyboardFocusManager.java (dispatchEvent):\n+\tHandle FOCUS_LOST events.  Don't handle Windows specially.  Only\n+\tprocess key events if the focus owner is non-null.\n+\t(dispatchKeyEvent): Likewise.\n+\t* java/awt/Frame.java (paramString): Fix formatting.\n+\t(generateName): New method.\n+\t(getUniqueLong): Likewise.\n+\t* java/awt/KeyboardFocusManager.java (getFocusOwner): Check if\n+\tthe temporary focus owner is null.  If so, return the permanent\n+\tfocus owner.\n+\t* java/awt/Panel.java (generateName): New method.\n+\t(getUniqueLong): Likewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c: Rework\n+\tsignal handling to make callbacks more specific.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/text/Position.java\n+\t(Bias): Implemented.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/LookAndFeel.java\n+\t(provideErrorFeedback): New method.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JTextArea.java\n+\t(tabSize): New field.\n+\t(getTabSize): New method.\n+\t(setTabSize): Likewise.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/ActionMap.java:\n+\tFixed javadocs all over.\n+\t(serialVersionUID): Made private.\n+\t(parent): Don't explicitely initialize with default value.\n+\t(get): SImplified.\n+\t(keys): Reimplemented.\n+\t(allKeys): Likewise.\n+\t(convertSet): Removed.\n+\t* javax/swing/ComponentInputMap.java:\n+\tFixed javadocs all over.\n+\t(ComponentInputMap): Implemented.\n+\t(put): Likewise.\n+\t(clear): Likewise.\n+\t(remove): Likewise.\n+\t(SetParent): Likewise.\n+\t(getComponent): Likewise.\n+\t* javax/swing/InputMap.java:\n+\tFixed javadocs all over.\n+\t(serialVersionUID): Made private.\n+\t(parent): Don't explicitely initialize with default value.\n+\t(get): SImplified.\n+\t(keys): Reimplemented.\n+\t(allKeys): Likewise.\n+\t(convertSet): Removed.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/ActionMap.java,\n+\tjavax/swing/ComponentInputMap.java,\n+\tjavax/swing/InputMap.java,\n+\tjavax/swing/table/DefaultTableColumnModel.java,\n+\tjavax/swing/table/TableColumn.java,\n+\tjavax/swing/table/TableColumnModel.java,\n+\tjavax/swing/table/TableModel.java,\n+\tjavax/swing/text/AbstractDocument.java,\n+\tjavax/swing/text/TextAction.java:\n+\tReformated.\n+\n+2004-07-21  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkToolkit.java (bufferedImageOrError): \n+\tMake method non-static.\n+\t* javax/swing/AbstractButton.java:\n+\tRename fields to match property names where possible.\n+\t(iconTextGap): New property.\n+\t* javax/swing/JCheckBox.java: Match AbstractButton changes.\n+\t(init) New method, call from after various constructors.\n+\t* javax/swing/JComponent.java (revalidate): \n+\tInvalidate before queueing repair.\n+\t* javax/swing/JList.java (getPreferredScrollableViewportSize):\n+\tReimplement in terms of visibleRowCount property.\n+\t* javax/swing/JMenuButton.java: Match AbstractButton changes.\n+\t* javax/swing/JScrollPane.java (createScrollListener): \n+\tRemove tracing chatter.\n+\t* javax/swing/JToggleButton.java: Match AbstractButton changes.\n+\t* javax/swing/RepaintManager.java (addInvalidComponent): \n+\tDon't invalidate.\n+\t* javax/swing/ScrollPaneLayout.java: Various corrections to layout\n+\tcalculations.\n+\t* javax/swing/SwingUtilities.java (layoutCompoundLabel): \n+\tMimic sun behavior on top left/right positioning.\n+\t* javax/swing/ViewportLayout.java (preferredLayoutSize):\n+\tRemove mistaken use of preferredScrollableViewportSize here.\n+\t(layoutContainer): Use view's preferred size as basis.\n+\t* javax/swing/plaf/basic/BasicButtonUI.java:\n+\tSet, get, and use textIconGap property.\n+\t(paint) Paint text returned from layout (with ellipsis).\n+\t* javax/swing/plaf/basic/BasicListUI.java:\n+\tRemove tracing chatter, correct various minor calculations.\n+\t(getCellBounds): Update layout state before calculating.\n+\t* javax/swing/plaf/basic/BasicLookAndFeel.java (Button.Margin):\n+\tUse margin default similar to sun's.\t\n+\t* javax/swing/plaf/basic/BasicScrollBarUI.java (ArrowIcon):\n+\t(createIncreaseIcon): Center icon, minimize margins.\n+\t(createDecreaseIcon): Likewise.\n+\t* javax/swing/plaf/basic/BasicScrollPaneUI.java (installDefaults):\n+\tImplement.\n+\t(installUI): Call it.\n+\t(uninstallDefaults): Implement.\n+\t(uninstallUI): Call it.\n+\t* javax/swing/plaf/basic/BasicToolBarUI.java (DragWindow):\n+\tCall existing Window constructor.\n+\t* javax/swing/plaf/basic/BasicViewportUI.java (paint):\n+\tSet clip before painting.\n+\n+2004-07-21  Olga Rodimina <rodimina@redhat.com>\n+\t\n+\t* javax/swing/JMenuItem.java:\n+\t(processMouseEvent): Reimplemented to deal with\n+\tmouse drag events.\n+\t(createMenuDragMouseEvent): New private helper method.\n+\tCreates MenuDragMouseEvent.\n+\t* javax/swing/MenuSelectionManager.java\n+\t(componentForPoint): Implemented.\n+\t(isComponentPartOfCurrentMenu): Made public.\n+\t(processMouseEvent): Reimplemented to deal with \n+\tmouse drag events.\n+\t(setSelectedPath): Corrected small mistake that caused\n+\tpath to be set incorrectly.\n+\t(getPath): If given component is JMenu then also add this\n+\tmenu's popup menu to the selected path.\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n+\t(getPath): Ditto.\n+\t(getPreferredSize): Call getPreferredMenuItemSize().\n+\t(getPreferredItemSize): Moved code from getPreferredSize to here.\n+\t(installListeners): Install MouseMotionListeners.\n+\t(MouseInputHandler): Pass mouse release event to MenuSelectionManager \n+\tif mouse wasn't released in the bounds of this menu item.\n+\t(MenuDragMouseHandler): Implemented.\n+\t* javax/swing/plaf/basic/BasicMenuUI.java:\n+\t(installListeners): Install MouseMotionListener and \n+\tMenuDrageMouseListener.\n+\t(MenuDragMouseHandler): Implemented.\n+\t* javax/swing/plaf/basic/BasicPopupMenuUI.java:\n+\t(uninstallListeners): Implemented.\n+\t\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JCheckBox.java: Reformated.\n+        (JCheckBox): Fixed all constructors.\n+        (isBorderPaintedFlat): New method.\n+        (setBorderPaintedFlat): New method.\n+\t* javax/swing/JEditorPane.java\n+        (createEditorKitForContentType): Made public.\n+        (scrollToReference): Likewise.\n+\t* javax/swing/JTextArea.java\n+        (setLineWrap): Fire property change.\n+\t* javax/swing/JToggleButton.java\n+        (JToggleButton): New constructor.\n+        (JToggleButton): Simplified.\n+\t* javax/swing/text/AttributeSet.java\n+        (FontAttribute): Renamed from FontCharacterAttribute.\n+\t* javax/swing/text/JTextComponent.java\n+        (KeyBinBinding): Added javadoc.\n+        (JTextComponent): Likewise.\n+        (getAccessibleContext): Fixed javadoc.\n+\t* javax/swing/text/View.java\n+        (View): Added javadoc.\n+\t* javax/swing/text/TabableView.java: New file.\n+\t* Makefile.am: Added javax/swing/text/TabableView.java.\n+\t* Makefile.in: Regenerated.\n+\n+2004-07-21  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* java/awt/image/BufferedImage.java (getSource): Remove tracing chatter.\n+\t* gnu/java/awt/peer/gtk/GtkToolkit.java \n+\t(GtkErrorImage): New helper class.\n+\t(bufferedImageOrError): New helper method.\n+\t(createImage): Use it.\n+\n+2004-07-21  David Jee  <djee@redhat.com>\n+\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextComponentPeer.c\n+\t(setCaretPosition): Scroll the text view so the new caret position\n+\tis visible on screen.\n+\n+2004-07-21  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkContainerPeer.java\n+\t(setBounds): Do not validate awtComponent here.\n+\t* gnu/java/awt/peer/gtk/GtkScrollPanePeer.java\n+\t(getPreferredSize): New method.\n+\t* java/awt/ScrollPane.java\n+\t(ScrollPane): Set default size to 100x100.\n+\t(addNotify): If child is not a Panel, wrap it with a new Panel.\n+\t(paramString): Implement.\n+\n+2004-07-21  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* javax/swing/JMenu.java:\n+\t(setSelected): Display popup menu only if this menu \n+\tis showing on the screen.\n+\t* javax/swing/JPopupMenu.java:\n+\t(processMouseEvent): Added comment.\n+\t(processKeyEvent): Likewise.\n+\t* javax/swing/MenuSelectionManager.java:\n+\t(clearSelectedPath): Only fireStateChanged() after\n+\tselected path was changed, not before.\n+\t(setSelectedPath): Likewise.\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n+\t(paintMenuItem): Corrected position of menu item's\n+\ticon.\n+\t* javax/swing/plaf/basic/BasicPopupMenuUI.java:\n+\t(installUI): Correct setDefaultLightWeightPopupEnabled call.\n+\t(popupMenuCanceled): Reimplemented.\n+\t(popupMenuWillBecomeVisible): Select first menu item by default \n+\twhen displaying free floating popup menus.\n+\t(TopWindowListener): Reimplemented.\n+\n+2004-07-21  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* java/awt/Panel.java (dispatchEventImpl): Override to prevent\n+\tPanel from being painted twice when it is first shown.\n+\n+2004-07-21  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* java/awt/Window.java: Reverted changes from my \n+\tprevious patch for creating window without an owner.\n+\t* javax/swing/SwingUtilities.java: \n+\t(SwingUtilities.OwnerFrame): made static.\n+\t(OwnerFrame.setVisible): New method. Overridden with\n+\tempty implementation.\n+\t(OwnerFrame.isShowing): New method. Ovverridden\n+\tto return always true.\n+\n+2004-07-21  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java,\n+\tjni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n+\t(GtkComponentPeer): Remove temporary try/catch block.\n+\t(setVisible): Call show and hide.\n+\t(show): Make native.\n+\t(hide): Likewise.\n+\t(getArgs): Don't add \"visible\" argument.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c\n+\t(property_notify_predicate): Return Bool instead of int.\n+\t(find_layout): New function.\n+\t(connectJObject): Call find_layout.\n+\t(connectSignals): Likewise.\n+\t(moveLayout): Likewise.\n+\t(gtkLayoutSetVisible): Likewise.\n+\n+2004-07-21  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/awt/event/InvocationEvent.java (dispatch): Synchronize\n+\ton notifier object before calling notifyAll().\n+\n+2004-07-21  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* java/awt/Window.java: Changed constructors to use new\n+\tmethod that is described below. Constructors call this\n+\tmethods only if newly created window should have an owner.\n+\t(setWindowOwner): New method. Implementation for\n+\tthis method is moved from this(owner,configuration).\n+\t* javax/swing/JWindow.java:\n+\t(JWindow): Reimplement to use SwingUtilities.ownerFrame\n+\tinstead of owner.\n+\t* javax/swing/SwingUtilities.java:\n+\t(ownerFrame): Change type of this field to OwnerFrame.\n+\t(getOwnerFrame): Changed to return object of type OwnerFrame.\n+\t(SwingUtilities.OwnerFrame): New class. Represents owner\n+\tof a Window that is not provided with one.\n+\n+2004-07-21  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t*  javax/swing/AbstractButton.java: \n+\t(configurePropertiesFromAction): Set action command\n+\tto button's text by default if action command is not \n+\texplicitely specified.\n+\t* javax/swing/JMenu.java: Remove unnecessary listener\n+\tand methods relevant to it.\n+\t(setSelected): Reimplemented.\n+\t(menuSelectionChanged): Moved most part of implementation to\n+\tsetSelected() and call it instead.\n+\t* javax/swing/JMenuItem.java: \n+\t(init): Comment out statement that sets paint_border to false.\n+\t(configurePropertiesFromAction): Do not set accelerator\n+\tfor JMenu.\n+\t(menuSelectionChanged): Change selected index in the selection\n+\tmodel of menu item's parent.\n+\t* javax/swing/JPopupMenu.java:\n+\t(remove): Set constraints.fill field to GridBagConstraints.BOTH\n+\tinstead of GridBagConstraints.HORIZONTAL.\n+\t(insert): Likewise.\n+\t(createActionChangeListener): Implemented.\n+\t(setVisible): Correct location of HeavyWeightMenu and \n+\tdon't firePopupMenuCanceled().\n+\t(menuSelectionChanged): Implemented.\n+\t(ActionChangeListener): New Listener. Implemented.\n+\t* javax/swing/plaf/basic/BasicMenuBarUI.java:\n+\t(BasicMenuBarUI.ContainerHandler): Implemented.\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n+\t(paintMenuItem): Uncommented out code that paints \n+\ticon, now that icons are working properly.\n+\t(PropertyChangeListener): Implemented.\n+\t* javax/swing/plaf/basic/BasicPopupMenuUI.java:\n+\tAdded javadocs.\n+\t(topWindowListener): New field.\n+\t(Constructor): initialize topWindowListener.\n+\t(BasicPopupMenuUI.TopWindowListener): Implemented.\t\n+\t(BasicPopupMenuUI.PopupMenuHandler): Implemented.\n+\t(BasicPopupMenuUI.TopWindowListener): New ComponentListener.\n+\tImplemented.\n+\t\n+\t\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/plaf/basic/BasicButtonUI.java\n+\t(paintFocus): Fixed method signature.\n+\t(paintButtonPressed): Likewise.\n+\t(paintButtonNormal): Likewise.\n+\t(paintText): New method.\n+\t* javax/swing/plaf/basic/BasicLabelUI.java\n+\t(paint): Re-indented.\n+\t* javax/swing/plaf/basic/BasicTextUI.java\n+\t(installUI): Set parent textComponent to opaque.\n+\t* javax/swing/text/DefaultHighlighter.java\n+\t(checkPositions): New helper method.\n+\t(addHighlight): Throws BadLocationException, check positions.\n+\t(changeHighlight): Likewise.\n+\t* javax/swing/text/EditorKit.java\n+\t(EditorKit): Implements Serializable.\n+\t* javax/swing/text/JTextComponent.java\n+\t(getUI): Added javadoc.\n+\t(setUI): Likewise.\n+\t(upadteUI): Added javadoc, don't revalidate and repaint.\n+\n+2004-07-21  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/GridBagLayout.java\n+\t(ArrangeGrid): Use PREFERREDSIZE instead of MINSIZE.\n+\t* javax/swing/AbstractButton.java\n+\t(setText): Reindent.\n+\t* javax/swing/RepaintManager.java\n+\t(addInvalidComponent): Find the first ancestor that isValidateRoot().\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JFormattedTextField.java\n+\t(value): New field.\n+\t(JFormattedTextField): Implemented.\n+\t(getValue): Likewise.\n+\t(setValue): Likewise.\n+\t* javax/swing/LookAndFeel.java\n+\t(getSupportsWindowDecorations): New method.\n+\t* javax/swing/UIDefaults.java:\n+\tUse java.beans.PropertyChangeSupport instead of doing all ourself.\n+\t(addPropertyChangeListener): Made public.\n+\t(addResourceBundle): Likewise.\n+\t(removeResourceBundle): Likewise.\n+\t(setDefaultLocale): Likewise.\n+\t* javax/swing/plaf/basic/BasicRootPaneUI.java\n+\t(BasicRootPaneUI): Implements PropertyChangeListener.\n+\t(propertyChange): New method.\n+\t* javax/swing/plaf/basic/BasicTextUI.java\n+\t(BasicHighlighter): New inner class.\n+\t(createHighlighter): New method.\n+\t* javax/swing/plaf/basic/BasicToolBarUI.java\n+\t(DragWindow): Extends java.awt.Window.\n+\t* javax/swing/text/JTextComponent.java\n+\t(getDocument): Removed debug output.\n+\t* javax/swing/plaf/basic/BasicTextFieldUI.java,\n+\tjavax/swing/text/DefaultHighlighter.java,\n+\tjavax/swing/text/FieldView.java,\n+\tjavax/swing/text/PlainView.java: New files.\n+\t* Makefile.am: Added new files.\n+\t* Makefile.in: Regenerated.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JEditorPane.java\n+\t(createDefaultEditorKit): Use javax.swing.text.DefaultEditorKit.\n+\t(createEditorKitForContentType): Likewise.\n+\t* javax/swing/text/DefaultEditorKit.java\n+\t(serialVersionUID): Added constant field.\n+\t(EndOfLineStringPropery): Fixed typo.\n+\t(DefaultEditorKit): New constructor.\n+\t* javax/swing/text/Segment.java:\n+\tImport java.text.CharacterIterator.\n+\t* javax/swing/text/CharacterIterator.java,\n+\tjavax/swing/text/PlainEditorKit.java: Removed.\n+\t* Makefile.am: Removed javax/swing/text/CharacterIterator.java and\n+\tjavax/swing/text/PlainEditorKit.java.\n+\t* Makefile.in: Regenerated.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JButton.java,\n+\tjavax/swing/text/DefaultEditorKit.java,\n+\tjavax/swing/text/EditorKit.java,\n+\tjavax/swing/text/Segment.java,\n+\tjavax/swing/text/StyledEditorKit.java:\n+\tReformatted.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/ImageIcon.java\n+\t(file): Removed.\n+\t(description): Renamed from descr.\n+\t(ImageIcon): Added missing constructors.\n+\t(setParent): Removed.\n+\t(setImageObserver): New method.\n+\t(getImageObserver): New method.\n+\t(paintIcon): Handle observer = null.\n+\t* javax/swing/JButton.java\n+\t(removeNotify): Fixed javadoc.\n+\t(updateUI): Simplified.\n+\t* javax/swing/JRootPane.java\n+\t(serialVersionUID): New constant field.\n+\t* javax/swing/UIManager.java:\n+\tFixed javadocs all over.\n+\t(setLookAndFeel): Throws UnsupportedLookAndFeelException.\n+\t* javax/swing/text/AbstractDocument.java\n+\t(createPosition): Throws BadLocationException.\n+\t(getText): Likewise.\n+\t(remove): Likewise.\n+\t* javax/swing/text/ComponentView.java\n+\t(modelToView): Likewise.\n+\t* javax/swing/text/DefaultEditorKit.java:\n+\tMade all public methods public.\n+\t(read): Throws BadLocationException and IOException.\n+\t(write): Likewise.\n+\t* javax/swing/text/EditorKit.java:\n+\tMade all public methods public.\n+\t(serialVersionUID): New constant field.\n+\t(clone): New method.\n+\t(read): Throws BadLocationException and IOException.\n+\t(write): Likewise.\n+\t* javax/swing/text/Segment.java\n+\t(array): Made public.\n+\t(count): Likewise.\n+\t(offset): Likewise.\n+\t(Segment): New constructors.\n+\t(clone): Reimplemented.\n+\t* javax/swing/text/StyledEditorKit.java\n+\t(serialVersionUID): New constant field.\n+\n+2004-07-21  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* java/awt/image/BufferedImage.java \n+\t(getSource): Implement.\n+\t* javax/swing/ImageIcon.java \n+\t(ImageIcon): Implement ctor.\n+\t* javax/swing/ScrollPaneLayout.java \n+\t(preferredLayoutSize): Be more careful about nulls.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/text/AttributeSet.java\n+\t(CharacterAttribute): New interface\n+\t(ColorAttribute): Likewise.\n+\t(FontCharacterAttribute): Likewise.\n+\t(ParagraphAttribute): Likewise.\n+\t* javax/swing/text/DefaultCaret.java\n+\t(moveCaret): New method.\n+\t(positionCaret): Likewise.\n+\t(repaint): Made protected.\n+\t* javax/swing/text/JTextComponent.java\n+\t(KeyBinding): Made it static.\n+\t* javax/swing/text/View.java\n+\t(getContainer): Honor parent == null.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/text/AbstractDocument.java:\n+\tReformatted.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/plaf/basic/BasicRootPaneUI.java:\n+\tImport javax.swing.UIManager explicitely.\n+\t* javax/swing/plaf/basic/BasicTabbedPaneUI.java\n+\t(ScrollingButton): Made it static.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/UIDefaults.java\n+\t(ActiveValue): Made public.\n+\t(LazyValue): Likewise.\n+\t* javax/swing/plaf/basic/BasicTextUI.java\n+\t(RootView): Reintroduced.\n+\t(view): Removed.\n+\t(rootView): New field.\n+\t(installUI): Create document if needed, initialize rootView.\n+\t(uninstallUI): Hanle rootView.\n+\t(paint): Likewise.\n+\t(getRootView): Likewise.\n+\t(setView): Likewise.\n+\t* javax/swing/text/DefaultCaret.java:\n+\tRenamed all \"evt\" variables to \"event\".\n+\n+2004-07-21  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* libgcj.spec.in: Add -l-java-util-logging.\n+\n+2004-07-21  Andreas Tobler  <a.tobler@schweiz.ch>\n+\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMainThread.c\n+\t(init_dpi_conversion_factor): Check for int_dpi < 0 in case\n+\tgtk-xft-dpi can no calculate the right value.\n+\t(dpi_changed_cb): Mark *pspec as unsused.\n+\n+2004-07-21  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/Component.java\n+\t(move): Delegate to setBounds().\n+\t(resize): Likewise.\n+\t(reshape): Fix so it repaints parent and self only when necessary.\n+\n+2004-07-21  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java,\n+\tjni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n+\t(GtkComponentPeer): Revert previous patch from 2004-06-22.\n+\t(setVisible): Likewise.\n+\t(show): Likewise.\n+\t(hide): Likewise.\n+\t(getArgs): Likewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c\n+\t(property_notify_predicate): Likewise.\n+\t(find_layout): Likewise.\n+\t(connectJObject): Likewise.\n+\t(connectSignals): Likewise.\n+\t(moveLayout): Likewise.\n+\t(gtkLayoutSetVisible): Likewise.\n+\n+2004-07-21  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* Makefile.am\n+\t(jv_convert_LDADD):\n+\t(gij_LDADD):\n+\t(rmic_LDADD):\n+\t(rmiregistry_LDADD): Add lib-java-util-logging.la\n+\t* Makefile.in: Regenerate.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/text/AbstractDocument.java\n+\t(replace): Dont use protected method of java.util.Vector directly.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/plaf/basic/BasicTextUI.java\n+\t(installUI): Call specialized install methods.\n+\t(installDefaults): New method.\n+\t(installListeners): Likewise.\n+\t(installKeyboardActions): Likewise.\n+\t(uninstallUI): Likewise.\n+\t(uninstallDefaults): New method.\n+\t(uninstallListeners): Likewise.\n+\t(uninstallKeyboardActions): Likewise.\n+\t(getPropertyPrefix): New abstract method.\n+\t(paint): Made final, just call paintSafely().\n+\t(paintSavely): New method.\n+\t(paintBackground): Likewise.\n+\t(getVisibleEditorRect): Likewise.\n+\t* javax/swing/text/LayeredHighlighter.java,\n+\tjavax/swing/text/TabExpander.java: New files.\n+\t* Makefile.am: Added javax/swing/text/LayeredHighlighter.java\n+\tand javax/swing/text/TabExpander.java.\n+\t* Makefile.in: Regenerated.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/plaf/basic/BasicTextUI.java\n+\t(BasicTextUI): Made abstract.\n+\t(BasicCaret): New inner class.\n+\t(view): Don't explicitely initialize with \"null\".\n+\t(textComponent): New field.\n+\t(textColor): Removed.\n+\t(disabledTextColor): Removed.\n+\t(normalBackgroundColor): Removed.\n+\t(RootView): Removed commented out inner class.\n+\t(createUI): Removed.\n+\t(createCaret): New method.\n+\t(getComponent): Likewise.\n+\t(installUI): Initialize textComponent only.\n+\t(getPreferredSize): Use installed JTextComponent.\n+\t(setView): New method.\n+\t(create): Likewise.\n+\t* javax/swing/text/JTextComponent.java\n+\t(highlighter): New field.\n+\t(caretColor): Likewise.\n+\t(disabledTextColor): Likewise.\n+\t(seletedTextColor): Likewise.\n+\t(selectionColor): Likewise.\n+\t(setUI): New method.\n+\t(getCaretColor): Likewise.\n+\t(setCaretColor): Likewise.\n+\t(getDisabledColor): Likewise.\n+\t(setDisabledColor): Likewise.\n+\t(getSelectedTextColor): Likewise.\n+\t(setSelectedTextColor): Likewise.\n+\t(getSelectionColor): Likewise.\n+\t(setSelectionColor): Likewise.\n+\t(getHighlighter): Likewise.\n+\t(setHighlighter): Likewise.\n+\t(replaceSelection): Likewise.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/plaf/basic/BasicScrollPaneUI.java\n+\t(BasicScrollPaneUI): Implements ScrollPaneConstants.\n+\t* javax/swing/plaf/basic/BasicToolBarUI.java\n+\t(BasicToolBarUI): Implements SwingConstants.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JPopupMenu.java: Removed CVS tags.\n+\t* javax/swing/UIDefaults.java: Reformatted.\n+\t* javax/swing/plaf/basic/BasicRootPaneUI.java:\n+\tExplicitely import used classes.\n+\n+2004-07-21  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java,\n+\tjni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n+\t(GtkComponentPeer): Remove temporary try/catch block.\n+\t(setVisible): Call show and hide.\n+\t(show): Make native.\n+\t(hide): Likewise.\n+\t(getArgs): Don't add \"visible\" argument.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c\n+\t(property_notify_predicate): Return Bool instead of int.\n+\t(find_layout): New function.\n+\t(connectJObject): Call find_layout.\n+\t(connectSignals): Likewise.\n+\t(moveLayout): Likewise.\n+\t(gtkLayoutSetVisible): Likewise.\n+\n+2004-07-21  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* javax/swing/AbstractButton.java:\n+\t(setDisplayedMnemonicIndex): Check if button\n+\ttext is not null before checking its length.\n+\t* javax/swing/JMenuItem.java:\n+\t(processMouseEvent): Disarm menu item if mouse has\n+\texited it.\n+\t* javax/swing/plaf/basic/BasicMenuUI.java:\n+\t(MouseInputHandler.mouseEntered): Do not raise\n+\tpopup menu if this menu is already selected.\n+\t(MouseInputHandler.mousePressed): Do not fire \n+\tMenuEvents.\n+\t(MenuHandler): Implemented.\t\n+\n+2004-07-21  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* javax/swing/JCheckBoxMenuItem.java: Added Javadoc.\n+\t(getSelectedObjects): Implemented.\n+\t* javax/swing/JRadioButtonMenuItem.java: Added Javadoc.\n+\t* javax/swing/plaf/basic/BasicCheckBoxMenuItemUI.java: \n+\tAdded javadoc for few methods.\n+\t(processMouseEvent): Made public.\n+\t* javax/swing/plaf/basic/BasicRadioButtonMenuItemUI.java\n+\t(processMouseEvent): Likewise.\n+\n+2004-07-21  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* javax/swing/AbstractButton.java:\n+\t(init): Set display mnemonic index to -1.\n+\t(setMnemonic(char)): Use setMnemonic(int).\n+\t(setMnemonic(int)): Set display mnemonic index.\n+\t(getDisplayedMnemonicIndex): Change method signature\n+\tby removing 'index' parameter.\n+\t* javax/swing/plaf/basic/BasicLookAndFeel.java:\n+\tAdded default for Menu.selectionBackground.\t\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n+\t(paintMenuItem): Change background color of the selected\n+\tmenu item.\n+\t(paintText): Paint differently when menu item is disabled.\n+\tAlso paint mnemonic if it appears in the menu item's label.\n+\t(paintAccelerator): Paint accelerator differently\n+\tif menu item is disabled.\n+\t* javax/swing/plaf/basic/BasicMenuUI.java:\n+\t(installDefaults): Install defaults for \n+\tselectionForeground and selectionBackground.\n+\t(uninstallDefaults): Uninstall defauls for \n+\tselectionForeground and selectionBackground.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/text/AbstractDocument.java\n+\t(BranchElement): Implemented.\n+\t(LeafElement): Implemented.\n+\t* javax/swing/text/DefaultCaret.java:\n+\tImport used classes.\n+\t(serialVersionUID): New constant.\n+\t* javax/swing/text/JTextComponent.java\n+\t(AccessibleJTextComponent): Removed dead declaration.\n+\t(caretPos): Removed.\n+\t(setCaret): New method.\n+\t* javax/swing/text/PlainDocument.java\n+\t(rootElement): New field.\n+\t(PlainDocument): Initialize rootElement.\n+\t(createDefaultRoot): New method.\n+\t(getDefaultRootElement): Implemented.\n+\t* javax/swing/text/View.java: Reformatted.\n+\t* javax/swing/text/ViewFactory.java\n+\t(create): Added javadoc.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/ToolTipManager.java: Reformatted.\n+\n+2004-07-21  Rodimina Olga  <rodimina@redhat.com>\n+\n+\t* javax/swing/AbstractButton.java\n+\t(changeEvent): New field.\n+\t(fireItemStateChanged): Change source of the event\n+\tto 'this' before firing it to button listeners.\n+\t(fireActionPerformed): Likewise.\n+\t(fireStateChanged): Likewise.\n+\t(createActionListener): Do not set source \n+\tof the event to AbstractButton.                                  \n+\t* javax/swing/plaf/basic/BasicMenuBarUI.java:\n+\t(ContainerHandler.componentAdded): Removed \n+\tprint out statement.\n+\t(ContainerHandler.componentRemoved): Likewise.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/text/Highlighter.java: New file.\n+\t* Makefile.am: Added javax/swing/text/Highlighter.java.\n+\t* Makefile.in: Regenerated.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/ToolTipManager.java\n+\t(stillInsideTimerAction): Fixed constructor arguments.\n+\t(outsideTimerAction): Likewise.\n+\t(insideTimerAction): Likewise.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JButton.java: Reformatted.\n+\t* javax/swing/JFormattedTextField.java\n+\t(getUIClassID): Implemented.\n+\t* javax/swing/JRootPane.java\n+\t(serialVersionUID): New constant.\n+\t* javax/swing/JTextField.java\n+\t(align): New field.\n+\t(JTextField): Simplified.\n+\t(getUIClassID): New method.\n+\t(getActionListeners): Added @since tag.\n+\t(setColumns): Invalidate layout and repaint.\n+\t(getHorizontalAlignment): New method.\n+\t(setHorizontalAlignment): New method.\n+\t(selectAll): Removed.\n+\t* javax/swing/SwingUtilities.java\n+\t(getAncestorOfClass): Removed redundant @see tag.\n+\t(isLeftMouseButton): Fixed implementation.\n+\t(isMiddleMouseButton): Likewise.\n+\t(isRightMouseButton): Likewise.\n+\t* javax/swing/text/AbstractDocument.java\n+\t(AttributeContext.addAttribute): New method.\n+\t(AttributeContext.addAttributes): New method.\n+\t(AttributeContext.getEmptySet): New method.\n+\t(AttributeContext.reclaim): New method.\n+\t(AttributeContext.removeAttribute): New method.\n+\t(AttributeContext.removeAttributes): New method.\n+\t* javax/swing/text/Document.java\n+\t(createPosition): Throws BadLocationException.\n+\t(getText): Likewise.\n+\t(remove): Likewise.\n+\t* javax/swing/text/JTextComponent.java\n+\t(getText): Return null if no document is set. Catch\n+\tBadLocationException.\n+\t(getUI): Return ui.\n+\t(updateUI): Simplified.\n+\n+2004-07-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/JButton.java\n+\t(removeNotify): Fixed javadoc.\n+\t(updateUI): Simplified.\n+\n+2004-07-21  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/image/ImageDecoder.java\n+\t(startProduction): Only add consumer if it's not added yet.\n+\t* gnu/java/awt/peer/gtk/GdkPixbufDecoder.java\n+\t(GdkPixbufDecoder): Don't call initState() here.\n+\t(produce): Call initState() here, to ensure area_prepared and\n+\tarea_updated signals are properly connected.\n+\t* gnu/java/awt/peer/gtk/GtkImage.java\n+\t(setColorModel): Use equals() to compare ColorModel objects.\n+\t(setPixels): Likewise.\n+\t* java/awt/image/ColorModel.java\n+\t(equals): Fix typo. Use Arrays.equals() to compare int arrays.\n+\t* java/awt/image/RGBImageFilter.java\n+\t(setColorModel): Set consumer's color model.\n+\t(setPixels): Use equals() to compare ColorModel objects.\n+\n 2004-07-21  Bryce McKinlay  <mckinlay@redhat.com>\n \n \t* java/net/URLConnection.java (position): New field."}, {"sha": "470c8a896caa59ae9429e94b335deaeb319bf2cb", "filename": "libjava/Makefile.am", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -1102,6 +1102,7 @@ java/awt/geom/GeneralPath.java \\\n java/awt/geom/QuadCurve2D.java \\\n java/awt/image/AffineTransformOp.java \\\n java/awt/image/BufferedImage.java \\\n+java/awt/image/ByteLookupTable.java \\\n java/awt/image/ColorModel.java \\\n java/awt/image/ComponentColorModel.java \\\n java/awt/image/ComponentSampleModel.java \\\n@@ -1117,11 +1118,14 @@ java/awt/image/ImageConsumer.java \\\n java/awt/image/ImageObserver.java \\\n java/awt/image/ImageProducer.java \\\n java/awt/image/IndexColorModel.java \\\n+java/awt/image/Kernel.java \\\n+java/awt/image/LookupTable.java \\\n java/awt/image/PackedColorModel.java \\\n java/awt/image/PixelInterleavedSampleModel.java \\\n java/awt/image/Raster.java \\\n java/awt/image/RasterOp.java \\\n java/awt/image/SampleModel.java \\\n+java/awt/image/ShortLookupTable.java \\\n java/awt/image/SinglePixelPackedSampleModel.java \\\n java/awt/image/WritableRaster.java \\\n java/awt/image/AreaAveragingScaleFilter.java \\\n@@ -1344,8 +1348,10 @@ javax/swing/plaf/basic/BasicSliderUI.java \\\n javax/swing/plaf/basic/BasicSplitPaneDivider.java \\\n javax/swing/plaf/basic/BasicSplitPaneUI.java \\\n javax/swing/plaf/basic/BasicTabbedPaneUI.java \\\n+javax/swing/plaf/basic/BasicTextFieldUI.java \\\n javax/swing/plaf/basic/BasicTextUI.java \\\n javax/swing/plaf/basic/BasicToggleButtonUI.java \\\n+javax/swing/plaf/basic/BasicToolBarSeparatorUI.java \\\n javax/swing/plaf/basic/BasicToolBarUI.java \\\n javax/swing/plaf/basic/BasicTreeUI.java \\\n javax/swing/plaf/basic/BasicViewportUI.java \\\n@@ -1459,6 +1465,8 @@ javax/swing/ListModel.java \\\n javax/swing/ListSelectionModel.java \\\n javax/swing/LookAndFeel.java \\\n javax/swing/Scrollable.java \\\n+javax/swing/Spring.java \\\n+javax/swing/SpringLayout.java \\\n javax/swing/SwingConstants.java \\\n javax/swing/SwingUtilities.java \\\n javax/swing/Timer.java \\\n@@ -1513,29 +1521,34 @@ javax/swing/text/AbstractDocument.java \\\n javax/swing/text/AttributeSet.java \\\n javax/swing/text/BadLocationException.java \\\n javax/swing/text/Caret.java \\\n-javax/swing/text/CharacterIterator.java \\\n javax/swing/text/ComponentView.java \\\n javax/swing/text/DefaultCaret.java \\\n javax/swing/text/DefaultEditorKit.java \\\n+javax/swing/text/DefaultHighlighter.java \\\n javax/swing/text/Document.java \\\n javax/swing/text/DocumentFilter.java \\\n javax/swing/text/EditorKit.java \\\n javax/swing/text/Element.java \\\n+javax/swing/text/FieldView.java \\\n javax/swing/text/GapContent.java \\\n+javax/swing/text/Highlighter.java \\\n javax/swing/text/JTextComponent.java \\\n javax/swing/text/Keymap.java \\\n+javax/swing/text/LayeredHighlighter.java \\\n+javax/swing/text/MutableAttributeSet.java \\\n+javax/swing/text/NavigationFilter.java \\\n javax/swing/text/PlainDocument.java \\\n-javax/swing/text/PlainEditorKit.java \\\n+javax/swing/text/PlainView.java \\\n javax/swing/text/Position.java \\\n javax/swing/text/Segment.java \\\n javax/swing/text/Style.java \\\n-javax/swing/text/View.java \\\n-javax/swing/text/ViewFactory.java \\\n-javax/swing/text/MutableAttributeSet.java \\\n-javax/swing/text/NavigationFilter.java \\\n javax/swing/text/StyledDocument.java \\\n javax/swing/text/StyledEditorKit.java \\\n+javax/swing/text/TabExpander.java \\\n+javax/swing/text/TabableView.java \\\n javax/swing/text/TextAction.java \\\n+javax/swing/text/View.java \\\n+javax/swing/text/ViewFactory.java \\\n javax/swing/text/html/HTML.java \\\n javax/swing/text/html/parser/ParserDelegator.java \\\n javax/swing/tree/TreeNode.java \\"}, {"sha": "08fe01245c6d68ffba3e2172f0fec68d5486111f", "filename": "libjava/Makefile.in", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -792,6 +792,7 @@ java/awt/geom/GeneralPath.java \\\n java/awt/geom/QuadCurve2D.java \\\n java/awt/image/AffineTransformOp.java \\\n java/awt/image/BufferedImage.java \\\n+java/awt/image/ByteLookupTable.java \\\n java/awt/image/ColorModel.java \\\n java/awt/image/ComponentColorModel.java \\\n java/awt/image/ComponentSampleModel.java \\\n@@ -807,11 +808,14 @@ java/awt/image/ImageConsumer.java \\\n java/awt/image/ImageObserver.java \\\n java/awt/image/ImageProducer.java \\\n java/awt/image/IndexColorModel.java \\\n+java/awt/image/Kernel.java \\\n+java/awt/image/LookupTable.java \\\n java/awt/image/PackedColorModel.java \\\n java/awt/image/PixelInterleavedSampleModel.java \\\n java/awt/image/Raster.java \\\n java/awt/image/RasterOp.java \\\n java/awt/image/SampleModel.java \\\n+java/awt/image/ShortLookupTable.java \\\n java/awt/image/SinglePixelPackedSampleModel.java \\\n java/awt/image/WritableRaster.java \\\n java/awt/image/AreaAveragingScaleFilter.java \\\n@@ -1034,8 +1038,10 @@ javax/swing/plaf/basic/BasicSliderUI.java \\\n javax/swing/plaf/basic/BasicSplitPaneDivider.java \\\n javax/swing/plaf/basic/BasicSplitPaneUI.java \\\n javax/swing/plaf/basic/BasicTabbedPaneUI.java \\\n+javax/swing/plaf/basic/BasicTextFieldUI.java \\\n javax/swing/plaf/basic/BasicTextUI.java \\\n javax/swing/plaf/basic/BasicToggleButtonUI.java \\\n+javax/swing/plaf/basic/BasicToolBarSeparatorUI.java \\\n javax/swing/plaf/basic/BasicToolBarUI.java \\\n javax/swing/plaf/basic/BasicTreeUI.java \\\n javax/swing/plaf/basic/BasicViewportUI.java \\\n@@ -1149,6 +1155,8 @@ javax/swing/ListModel.java \\\n javax/swing/ListSelectionModel.java \\\n javax/swing/LookAndFeel.java \\\n javax/swing/Scrollable.java \\\n+javax/swing/Spring.java \\\n+javax/swing/SpringLayout.java \\\n javax/swing/SwingConstants.java \\\n javax/swing/SwingUtilities.java \\\n javax/swing/Timer.java \\\n@@ -1203,29 +1211,34 @@ javax/swing/text/AbstractDocument.java \\\n javax/swing/text/AttributeSet.java \\\n javax/swing/text/BadLocationException.java \\\n javax/swing/text/Caret.java \\\n-javax/swing/text/CharacterIterator.java \\\n javax/swing/text/ComponentView.java \\\n javax/swing/text/DefaultCaret.java \\\n javax/swing/text/DefaultEditorKit.java \\\n+javax/swing/text/DefaultHighlighter.java \\\n javax/swing/text/Document.java \\\n javax/swing/text/DocumentFilter.java \\\n javax/swing/text/EditorKit.java \\\n javax/swing/text/Element.java \\\n+javax/swing/text/FieldView.java \\\n javax/swing/text/GapContent.java \\\n+javax/swing/text/Highlighter.java \\\n javax/swing/text/JTextComponent.java \\\n javax/swing/text/Keymap.java \\\n+javax/swing/text/LayeredHighlighter.java \\\n+javax/swing/text/MutableAttributeSet.java \\\n+javax/swing/text/NavigationFilter.java \\\n javax/swing/text/PlainDocument.java \\\n-javax/swing/text/PlainEditorKit.java \\\n+javax/swing/text/PlainView.java \\\n javax/swing/text/Position.java \\\n javax/swing/text/Segment.java \\\n javax/swing/text/Style.java \\\n-javax/swing/text/View.java \\\n-javax/swing/text/ViewFactory.java \\\n-javax/swing/text/MutableAttributeSet.java \\\n-javax/swing/text/NavigationFilter.java \\\n javax/swing/text/StyledDocument.java \\\n javax/swing/text/StyledEditorKit.java \\\n+javax/swing/text/TabExpander.java \\\n+javax/swing/text/TabableView.java \\\n javax/swing/text/TextAction.java \\\n+javax/swing/text/View.java \\\n+javax/swing/text/ViewFactory.java \\\n javax/swing/text/html/HTML.java \\\n javax/swing/text/html/parser/ParserDelegator.java \\\n javax/swing/tree/TreeNode.java \\\n@@ -3070,7 +3083,7 @@ LINK = $(LIBTOOL) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@\n DATA =  $(jar_DATA) $(pkgconfig_DATA) $(toolexecmainlib_DATA)\n \n DIST_COMMON =  README COPYING ChangeLog Makefile.am Makefile.in NEWS \\\n-THANKS TODO acinclude.m4 aclocal.m4 configure configure.in \\\n+THANKS acinclude.m4 aclocal.m4 configure configure.in \\\n libgcj-test.spec.in libgcj.pc.in libgcj.spec.in\n \n \n@@ -3669,6 +3682,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/awt/image/BufferStrategy.P \\\n .deps/java/awt/image/BufferedImage.P \\\n .deps/java/awt/image/BufferedImageOp.P \\\n+.deps/java/awt/image/ByteLookupTable.P \\\n .deps/java/awt/image/ColorModel.P \\\n .deps/java/awt/image/ComponentColorModel.P \\\n .deps/java/awt/image/ComponentSampleModel.P \\\n@@ -3685,7 +3699,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/awt/image/ImageObserver.P \\\n .deps/java/awt/image/ImageProducer.P \\\n .deps/java/awt/image/ImagingOpException.P \\\n-.deps/java/awt/image/IndexColorModel.P \\\n+.deps/java/awt/image/IndexColorModel.P .deps/java/awt/image/Kernel.P \\\n+.deps/java/awt/image/LookupTable.P \\\n .deps/java/awt/image/MemoryImageSource.P \\\n .deps/java/awt/image/PackedColorModel.P \\\n .deps/java/awt/image/PixelGrabber.P \\\n@@ -3695,6 +3710,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/awt/image/RasterOp.P .deps/java/awt/image/RenderedImage.P \\\n .deps/java/awt/image/ReplicateScaleFilter.P \\\n .deps/java/awt/image/SampleModel.P \\\n+.deps/java/awt/image/ShortLookupTable.P \\\n .deps/java/awt/image/SinglePixelPackedSampleModel.P \\\n .deps/java/awt/image/TileObserver.P \\\n .deps/java/awt/image/VolatileImage.P \\\n@@ -4587,6 +4603,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/javax/swing/ScrollPaneLayout.P .deps/javax/swing/Scrollable.P \\\n .deps/javax/swing/SingleSelectionModel.P \\\n .deps/javax/swing/SizeRequirements.P .deps/javax/swing/SizeSequence.P \\\n+.deps/javax/swing/Spring.P .deps/javax/swing/SpringLayout.P \\\n .deps/javax/swing/SwingConstants.P .deps/javax/swing/SwingUtilities.P \\\n .deps/javax/swing/Timer.P .deps/javax/swing/ToolTipManager.P \\\n .deps/javax/swing/UIDefaults.P .deps/javax/swing/UIManager.P \\\n@@ -4717,8 +4734,10 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/javax/swing/plaf/basic/BasicSplitPaneDivider.P \\\n .deps/javax/swing/plaf/basic/BasicSplitPaneUI.P \\\n .deps/javax/swing/plaf/basic/BasicTabbedPaneUI.P \\\n+.deps/javax/swing/plaf/basic/BasicTextFieldUI.P \\\n .deps/javax/swing/plaf/basic/BasicTextUI.P \\\n .deps/javax/swing/plaf/basic/BasicToggleButtonUI.P \\\n+.deps/javax/swing/plaf/basic/BasicToolBarSeparatorUI.P \\\n .deps/javax/swing/plaf/basic/BasicToolBarUI.P \\\n .deps/javax/swing/plaf/basic/BasicTreeUI.P \\\n .deps/javax/swing/plaf/basic/BasicViewportUI.P \\\n@@ -4736,23 +4755,26 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/javax/swing/text/AbstractDocument.P \\\n .deps/javax/swing/text/AttributeSet.P \\\n .deps/javax/swing/text/BadLocationException.P \\\n-.deps/javax/swing/text/Caret.P \\\n-.deps/javax/swing/text/CharacterIterator.P \\\n-.deps/javax/swing/text/ComponentView.P \\\n+.deps/javax/swing/text/Caret.P .deps/javax/swing/text/ComponentView.P \\\n .deps/javax/swing/text/DefaultCaret.P \\\n .deps/javax/swing/text/DefaultEditorKit.P \\\n+.deps/javax/swing/text/DefaultHighlighter.P \\\n .deps/javax/swing/text/Document.P \\\n .deps/javax/swing/text/DocumentFilter.P \\\n .deps/javax/swing/text/EditorKit.P .deps/javax/swing/text/Element.P \\\n-.deps/javax/swing/text/GapContent.P \\\n+.deps/javax/swing/text/FieldView.P .deps/javax/swing/text/GapContent.P \\\n+.deps/javax/swing/text/Highlighter.P \\\n .deps/javax/swing/text/JTextComponent.P .deps/javax/swing/text/Keymap.P \\\n+.deps/javax/swing/text/LayeredHighlighter.P \\\n .deps/javax/swing/text/MutableAttributeSet.P \\\n .deps/javax/swing/text/NavigationFilter.P \\\n .deps/javax/swing/text/PlainDocument.P \\\n-.deps/javax/swing/text/PlainEditorKit.P \\\n-.deps/javax/swing/text/Position.P .deps/javax/swing/text/Segment.P \\\n-.deps/javax/swing/text/Style.P .deps/javax/swing/text/StyledDocument.P \\\n+.deps/javax/swing/text/PlainView.P .deps/javax/swing/text/Position.P \\\n+.deps/javax/swing/text/Segment.P .deps/javax/swing/text/Style.P \\\n+.deps/javax/swing/text/StyledDocument.P \\\n .deps/javax/swing/text/StyledEditorKit.P \\\n+.deps/javax/swing/text/TabExpander.P \\\n+.deps/javax/swing/text/TabableView.P \\\n .deps/javax/swing/text/TextAction.P .deps/javax/swing/text/View.P \\\n .deps/javax/swing/text/ViewFactory.P .deps/javax/swing/text/html/HTML.P \\\n .deps/javax/swing/text/html/parser/ParserDelegator.P \\"}, {"sha": "233dfb1b28d462cfe889ff3dfc395ec0c5e78b05", "filename": "libjava/gnu/java/awt/image/ImageDecoder.java", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fimage%2FImageDecoder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fimage%2FImageDecoder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fimage%2FImageDecoder.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -98,7 +98,9 @@ public void removeConsumer (ImageConsumer ic)\n \n   public void startProduction (ImageConsumer ic)\n   {\n+    if (!isConsumer(ic))\n     addConsumer (ic);\n+\n     Vector list = (Vector) consumers.clone ();\n     try \n       {"}, {"sha": "5c7fd96003b535c39dc3dbeccf3981e666f55b1f", "filename": "libjava/gnu/java/awt/peer/gtk/GdkPixbufDecoder.java", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkPixbufDecoder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkPixbufDecoder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkPixbufDecoder.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -77,19 +77,16 @@ public class GdkPixbufDecoder extends gnu.java.awt.image.ImageDecoder\n   public GdkPixbufDecoder (String filename)\n   {\n     super (filename);\n-    initState ();\n   }\n   \n   public GdkPixbufDecoder (URL url)\n   {\n     super (url);\n-    initState ();\n   }\n \n   public GdkPixbufDecoder (byte[] imagedata, int imageoffset, int imagelength)\n   {\n     super (imagedata, imageoffset, imagelength);\n-    initState ();\n   }\n \n   // called back by native side\n@@ -135,6 +132,7 @@ public void produce (Vector v, InputStream is) throws IOException\n \n     byte bytes[] = new byte[4096];\n     int len = 0;\n+    initState();\n     while ((len = is.read (bytes)) != -1)\n       pumpBytes (bytes, len);\n     "}, {"sha": "15e73d9c3f7cc4351bcd907333bfd26a38641d06", "filename": "libjava/gnu/java/awt/peer/gtk/GtkComponentPeer.java", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -115,8 +115,6 @@ protected GtkComponentPeer (Component awtComponent)\n     this.awtComponent = awtComponent;\n     insets = new Insets (0, 0, 0, 0);\n \n-    /* temporary try/catch block until all peers use this creation method */\n-    try {\n       create ();\n       \n       GtkArgList args = new GtkArgList ();\n@@ -147,7 +145,7 @@ protected GtkComponentPeer (Component awtComponent)\n \n       Rectangle bounds = awtComponent.getBounds ();\n       setBounds (bounds.x, bounds.y, bounds.width, bounds.height);\n-    } catch (RuntimeException ex) { ; }\n+    setVisible (awtComponent.isVisible ());\n   }\n \n   public int checkImage (Image image, int width, int height, \n@@ -449,18 +447,14 @@ public Color getBackground ()\n \n   public void setVisible (boolean b)\n   {\n-    set (\"visible\", b);\n-  }\n-  \n-  public void hide () \n-  {\n-    setVisible (false);\n+    if (b)\n+      show ();\n+    else\n+      hide ();\n   }\n \n-  public void show () \n-  {\n-    setVisible (true);\n-  }\n+  public native void hide ();\n+  public native void show ();\n \n   protected void postMouseEvent(int id, long when, int mods, int x, int y, \n \t\t\t\tint clickCount, boolean popupTrigger) \n@@ -514,7 +508,6 @@ protected void postItemEvent (Object item, int stateChange)\n \n   public void getArgs (Component component, GtkArgList args)\n   {\n-    args.add (\"visible\", component.isVisible ());\n     args.add (\"sensitive\", component.isEnabled ());\n \n     ComponentPeer p;"}, {"sha": "040499724fd38856afba5513bdc6671d5febb0e0", "filename": "libjava/gnu/java/awt/peer/gtk/GtkContainerPeer.java", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkContainerPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkContainerPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkContainerPeer.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -90,7 +90,6 @@ public Insets insets()\n   public void setBounds (int x, int y, int width, int height)\n   {\n     super.setBounds (x, y, width, height);\n-    awtComponent.validate ();\n   }\n \n   public void setFont(Font f)"}, {"sha": "712247c4a852d2d0f145ad224d07ba497916b138", "filename": "libjava/gnu/java/awt/peer/gtk/GtkFileDialogPeer.java", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkFileDialogPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkFileDialogPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkFileDialogPeer.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -45,25 +45,42 @@\n import java.awt.event.WindowEvent;\n import java.awt.peer.FileDialogPeer;\n import java.io.FilenameFilter;\n+import java.io.File;\n \n public class GtkFileDialogPeer extends GtkDialogPeer implements FileDialogPeer\n {\n   static final String FS = System.getProperty(\"file.separator\");\n   \n   private String currentFile = null;\n   private String currentDirectory = null;\n+  private FilenameFilter filter;\n \n-  native void create ();\n+  native void create (GtkContainerPeer parent);\n+  native void connectJObject ();\n+  native void connectSignals ();\n+  native void nativeSetFile (String file);\n+  native public String nativeGetDirectory();\n+  native public void nativeSetDirectory(String directory);\n+  native void nativeSetFilenameFilter (FilenameFilter filter);\n+\n+  public void create() {\n+    create((GtkContainerPeer) awtComponent.getParent().getPeer());\n+\n+    FileDialog fd = (FileDialog) awtComponent;\n+\n+    setDirectory(fd.getDirectory());\n+    setFile(fd.getFile());\n+\n+    FilenameFilter filter = fd.getFilenameFilter();\n+    if (filter != null)\n+      setFilenameFilter(filter);\n+  }\n \n   public GtkFileDialogPeer (FileDialog fd)\n   {\n     super (fd);\n   }\n \n-  native void connectJObject ();\n-  native void connectSignals ();\n-  native void nativeSetFile (String file);\n-\n   public void setFile (String fileName)\n   {\n     /* If nothing changed do nothing.  This usually happens because\n@@ -80,26 +97,16 @@ public void setFile (String fileName)\n         return;\n       }\n \n-    // Remove any directory path from the filename\n-    int sepIndex = fileName.lastIndexOf (FS);\n-    if (sepIndex < 0)\n-      {\n+    // GtkFileChooser requires absolute filenames. If the given filename\n+    // is not absolute, let's construct it based on current directory.\n         currentFile = fileName;\n+    if (fileName.indexOf(FS) == 0)\n+      {\n         nativeSetFile (fileName);\n       }\n     else\n       {\n-        if (fileName.length() > (sepIndex + 1))\n-\t  {\n-\t    String fn = fileName.substring (sepIndex + 1);\n-            currentFile = fn;\n-            nativeSetFile (fn);\n-\t  }\n-\telse\n-\t  {\n-            currentFile = \"\";\n-            nativeSetFile (\"\");\n-\t  }\n+        nativeSetFile (nativeGetDirectory() + FS + fileName);\n       }\n   }\n \n@@ -120,20 +127,25 @@ public void setDirectory (String directory)\n       }\n       \n     currentDirectory = directory;\n-\n-    // Gtk expects the directory to end with a file separator\n-    if (directory.substring (directory.length () - 1).equals (FS))\n-      nativeSetFile (directory);\n-    else\n-      nativeSetFile (directory + FS);\n+    nativeSetDirectory (directory);\n   }\n \n   public void setFilenameFilter (FilenameFilter filter)\n   {\n-    /* GTK has no filter callbacks yet.  It works by setting a pattern\n-     * (see gtk_file_selection_complete), which we can't convert\n-     * to the callback paradigm. With GTK-2.4 there will be a\n-     * gtk_file_filter_add_custom function that we can use. */\n+    this.filter = filter;\n+    nativeSetFilenameFilter(filter);\n+  }\n+\n+  /* This method interacts with the native callback function of the\n+     same name.  The native function will extract the filename from the\n+     GtkFileFilterInfo object and send it to this method, which will\n+     in turn call the filter's accept() method and give back the return\n+     value. */\n+  boolean filenameFilterCallback (String fullname) {\n+    String filename = fullname.substring(fullname.lastIndexOf(FS) + 1);\n+    String dirname = fullname.substring(0, fullname.lastIndexOf(FS));\n+    File dir = new File(dirname);\n+    return filter.accept(dir, filename);\n   }\n \n   public Graphics getGraphics ()"}, {"sha": "27d3d6a0655f183367ba78b6179d741476c6a660", "filename": "libjava/gnu/java/awt/peer/gtk/GtkImage.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImage.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -202,7 +202,7 @@ public void setObserver (ImageObserver observer)\n   public synchronized void \n   setColorModel (ColorModel model)\n   {\n-    if (this.model == null || this.model == model)\n+    if (this.model == null || this.model.equals(model))\n       this.model = model;\n     else\n       isCacheable = false;\n@@ -235,7 +235,7 @@ public void setObserver (ImageObserver observer)\n     if (!isCacheable)\n       return;\n \n-    if (cm != model || pixelCache == null)\n+    if (!cm.equals(model) || pixelCache == null)\n       {\n \tisCacheable = false;\n \treturn;"}, {"sha": "d15cb4a4acf821ad4d252d358f43ab0cc6d80229", "filename": "libjava/gnu/java/awt/peer/gtk/GtkImagePainter.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImagePainter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImagePainter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImagePainter.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -246,5 +246,6 @@ width, height, convertPixels (pixels, model), offset,\n   public void \n   imageComplete (int status)\n   {\n+    image.imageComplete(status);\n   }\n }"}, {"sha": "0b5d0af43423aa2f261fce79e53e87421b7f6a01", "filename": "libjava/gnu/java/awt/peer/gtk/GtkPanelPeer.java", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkPanelPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkPanelPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkPanelPeer.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -38,7 +38,9 @@\n \n package gnu.java.awt.peer.gtk;\n \n+import java.awt.AWTEvent;\n import java.awt.Panel;\n+import java.awt.event.MouseEvent;\n import java.awt.peer.PanelPeer;\n \n public class GtkPanelPeer extends GtkContainerPeer\n@@ -51,4 +53,17 @@ public GtkPanelPeer (Panel p)\n   {\n     super (p);\n   }\n+\n+  public void handleEvent (AWTEvent event)\n+  {\n+    int id = event.getID();\n+\n+    switch (id)\n+      {\n+      case MouseEvent.MOUSE_PRESSED:\n+        awtComponent.requestFocusInWindow ();\n+        break;\n+      }\n+    super.handleEvent (event);\n+  }\n }"}, {"sha": "d0cbde034e23d6b80a1ba398a03b171a16950f92", "filename": "libjava/gnu/java/awt/peer/gtk/GtkScrollPanePeer.java", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkScrollPanePeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkScrollPanePeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkScrollPanePeer.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -39,6 +39,7 @@\n package gnu.java.awt.peer.gtk;\n \n import java.awt.Adjustable;\n+import java.awt.Dimension;\n import java.awt.ScrollPane;\n import java.awt.peer.ComponentPeer;\n import java.awt.peer.ScrollPanePeer;\n@@ -87,10 +88,10 @@ public void childResized (int width, int height)\n   native public int getVScrollbarWidth ();\n   native public void setScrollPosition (int x, int y);\n \n-//    public Dimension getPreferredSize ()\n-//    {\n-//      return new Dimension (60, 60);\n-//    }\n+  public Dimension getPreferredSize ()\n+  {\n+    return awtComponent.getSize();\n+  }\n \n   public void setUnitIncrement (Adjustable adj, int u)\n   {"}, {"sha": "9cc29b4b3a4f7244ed7f513e70df5375bc576397", "filename": "libjava/gnu/java/awt/peer/gtk/GtkToolkit.java", "status": "modified", "additions": 101, "deletions": 5, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkToolkit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkToolkit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkToolkit.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -44,13 +44,17 @@\n import java.awt.dnd.peer.DragSourceContextPeer;\n import java.awt.font.TextAttribute;\n import java.awt.im.InputMethodHighlight;\n+import java.awt.image.BufferedImage;\n import java.awt.image.ColorModel;\n import java.awt.image.ImageObserver;\n+import java.awt.image.ImageConsumer;\n import java.awt.image.ImageProducer;\n import java.awt.GraphicsEnvironment;\n import java.awt.peer.*;\n import java.net.URL;\n+import java.util.HashSet;\n import java.util.Hashtable;\n+import java.util.Iterator;\n import java.util.Map;\n import java.util.MissingResourceException;\n import java.util.Properties;\n@@ -127,10 +131,102 @@ public int checkImage (Image image, int width, int height,\n     return status;\n   }\n \n+  /** \n+   * A helper class to return to clients in cases where a BufferedImage is\n+   * desired but its construction fails.\n+   */\n+  private class GtkErrorImage extends Image\n+  {\n+    public GtkErrorImage()\n+    {\n+    }\n+\n+    public int getWidth(ImageObserver observer)\n+    {\n+      return -1;\n+    }\n+\n+    public int getHeight(ImageObserver observer)\n+    {\n+      return -1;\n+    }\n+\n+    public ImageProducer getSource()\n+    {\n+\n+      return new ImageProducer() \n+        {          \n+          HashSet consumers = new HashSet();          \n+          public void addConsumer(ImageConsumer ic)\n+          {\n+            consumers.add(ic);\n+          }\n+\n+          public boolean isConsumer(ImageConsumer ic)\n+          {\n+            return consumers.contains(ic);\n+          }\n+\n+          public void removeConsumer(ImageConsumer ic)\n+          {\n+            consumers.remove(ic);\n+          }\n+\n+          public void startProduction(ImageConsumer ic)\n+          {\n+            consumers.add(ic);\n+            Iterator i = consumers.iterator();\n+            while(i.hasNext())\n+              {\n+                ImageConsumer c = (ImageConsumer) i.next();\n+                c.imageComplete(ImageConsumer.IMAGEERROR);\n+              }\n+          }\n+          public void requestTopDownLeftRightResend(ImageConsumer ic)\n+          {\n+            startProduction(ic);\n+          }        \n+        };\n+    }\n+\n+    public Graphics getGraphics() \n+    { \n+      return null; \n+    }\n+\n+    public Object getProperty(String name, ImageObserver observer)\n+    {\n+      return null;\n+    }\n+    public Image getScaledInstance(int width, int height, int flags)\n+    {\n+      return new GtkErrorImage();\n+    }\n+\n+    public void flush() \n+    {\n+    }\n+  }\n+\n+\n+  /** \n+   * Helper to return either a BufferedImage -- the argument -- or a\n+   * GtkErrorImage if the argument is null.\n+   */\n+\n+  private Image bufferedImageOrError(BufferedImage b)\n+  {\n+    if (b == null) \n+      return new GtkErrorImage();\n+    else\n+      return b;\n+  }\n+\n+\n   public Image createImage (String filename)\n   {\n     if (useGraphics2D())\n-      return GdkPixbufDecoder.createBufferedImage (filename);\n+      return bufferedImageOrError(GdkPixbufDecoder.createBufferedImage (filename));\n     else\n       {\n         GdkPixbufDecoder d = new GdkPixbufDecoder (filename);\n@@ -143,7 +239,7 @@ public Image createImage (String filename)\n   public Image createImage (URL url)\n   {\n     if (useGraphics2D())\n-      return GdkPixbufDecoder.createBufferedImage (url);\n+      return bufferedImageOrError(GdkPixbufDecoder.createBufferedImage (url));\n     else\n       {\n         GdkPixbufDecoder d = new GdkPixbufDecoder (url);\n@@ -156,7 +252,7 @@ public Image createImage (URL url)\n   public Image createImage (ImageProducer producer) \n   {\n     if (useGraphics2D())\n-      return GdkPixbufDecoder.createBufferedImage (producer);\n+      return bufferedImageOrError(GdkPixbufDecoder.createBufferedImage (producer));\n     else\n       {\n         GtkImage image = new GtkImage (producer, null);\n@@ -169,9 +265,9 @@ public Image createImage (byte[] imagedata, int imageoffset,\n \t\t\t    int imagelength)\n   {\n     if (useGraphics2D())\n-      return GdkPixbufDecoder.createBufferedImage (imagedata,\n+      return bufferedImageOrError(GdkPixbufDecoder.createBufferedImage (imagedata,\n                                                    imageoffset, \n-                                                   imagelength);\n+                                                                        imagelength));\n     else\n       {\n         GdkPixbufDecoder d = new GdkPixbufDecoder (imagedata,"}, {"sha": "5cb792b1de43afbcf4fb0e4c436b12c0005c9ce8", "filename": "libjava/java/awt/Component.java", "status": "modified", "additions": 333, "deletions": 70, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FComponent.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -39,6 +39,7 @@\n package java.awt;\n \n import java.awt.dnd.DropTarget;\n+import java.awt.event.ActionEvent;\n import java.awt.event.ComponentEvent;\n import java.awt.event.ComponentListener;\n import java.awt.event.FocusEvent;\n@@ -48,6 +49,7 @@\n import java.awt.event.HierarchyListener;\n import java.awt.event.KeyEvent;\n import java.awt.event.KeyListener;\n+import java.awt.event.InputEvent;\n import java.awt.event.InputMethodEvent;\n import java.awt.event.InputMethodListener;\n import java.awt.event.MouseEvent;\n@@ -1175,30 +1177,7 @@ public void setLocation(int x, int y)\n    */\n   public void move(int x, int y)\n   {\n-    int oldx = this.x;\n-    int oldy = this.y;\n-\n-    if (this.x == x && this.y == y)\n-      return;\n-    invalidate ();\n-    this.x = x;\n-    this.y = y;\n-    if (peer != null)\n-      peer.setBounds (x, y, width, height);\n-\n-    // Erase old bounds and repaint new bounds for lightweights.\n-    if (isLightweight() && width != 0 && height !=0)\n-      {\n-        parent.repaint(oldx, oldy, width, height);\n-        repaint();\n-      }\n-\n-    if (oldx != x || oldy != y)\n-      {\n-        ComponentEvent ce = new ComponentEvent(this,\n-                                               ComponentEvent.COMPONENT_MOVED);\n-        getToolkit().getSystemEventQueue().postEvent(ce);\n-      }\n+    setBounds(x, y, this.width, this.height);\n   }\n \n   /**\n@@ -1262,32 +1241,7 @@ public void setSize(int width, int height)\n    */\n   public void resize(int width, int height)\n   {\n-    int oldwidth = this.width;\n-    int oldheight = this.height;\n-\n-    if (this.width == width && this.height == height)\n-      return;\n-    invalidate ();\n-    this.width = width;\n-    this.height = height;\n-    if (peer != null)\n-      peer.setBounds (x, y, width, height);\n-\n-    // Erase old bounds and repaint new bounds for lightweights.\n-    if (isLightweight())\n-      {\n-        if (oldwidth != 0 && oldheight != 0 && parent != null)\n-          parent.repaint(x, y, oldwidth, oldheight);\n-        if (width != 0 && height != 0)\n-          repaint();\n-      }\n-\n-    if (oldwidth != width || oldheight != height)\n-      {\n-        ComponentEvent ce =\n-          new ComponentEvent(this, ComponentEvent.COMPONENT_RESIZED);\n-        getToolkit().getSystemEventQueue().postEvent(ce);\n-      }\n+    setBounds(this.x, this.y, width, height);\n   }\n \n   /**\n@@ -1395,9 +1349,25 @@ public void reshape(int x, int y, int width, int height)\n     // Erase old bounds and repaint new bounds for lightweights.\n     if (isLightweight())\n       {\n-        if (oldwidth != 0 && oldheight != 0 && parent != null)\n+        boolean shouldRepaintParent = false;\n+        boolean shouldRepaintSelf = false;\n+\n+        if (parent != null)\n+          {\n+            Rectangle parentBounds = parent.getBounds();\n+            Rectangle oldBounds = new Rectangle(parent.getX() + oldx,\n+                                                parent.getY() + oldy,\n+                                                oldwidth, oldheight);\n+            Rectangle newBounds = new Rectangle(parent.getX() + x,\n+                                                parent.getY() + y,\n+                                                width, height);\n+            shouldRepaintParent = parentBounds.intersects(oldBounds);\n+            shouldRepaintSelf = parentBounds.intersects(newBounds);\n+          }\n+\n+        if (shouldRepaintParent)\n           parent.repaint(oldx, oldy, oldwidth, oldheight);\n-        if (width != 0 && height != 0)\n+        if (shouldRepaintSelf)\n           repaint();\n       }\n \n@@ -2255,14 +2225,17 @@ public Component getComponentAt(Point p)\n   }\n \n   /**\n-   * AWT 1.0 event dispatcher.\n+   * AWT 1.0 event delivery.\n    *\n-   * @param e the event to dispatch\n+   * Deliver an AWT 1.0 event to this Component.  This method simply\n+   * calls {@link #postEvent}.\n+   *\n+   * @param e the event to deliver\n    * @deprecated use {@link #dispatchEvent(AWTEvent)} instead\n    */\n   public void deliverEvent(Event e)\n   {\n-    // XXX Add backward compatibility handling.\n+    postEvent (e);\n   }\n \n   /**\n@@ -2284,16 +2257,24 @@ public final void dispatchEvent(AWTEvent e)\n   }\n \n   /**\n-   * AWT 1.0 event dispatcher.\n+   * AWT 1.0 event handler.\n    *\n-   * @param e the event to dispatch\n-   * @return false: since the method was deprecated, the return has no meaning\n+   * This method simply calls handleEvent and returns the result.\n+   *\n+   * @param e the event to handle\n+   * @return the result of handling <code>e</code>\n    * @deprecated use {@link #dispatchEvent(AWTEvent)} instead\n    */\n   public boolean postEvent(Event e)\n   {\n-    // XXX Add backward compatibility handling.\n-    return false;\n+    boolean handled = handleEvent (e);\n+\n+    if (!handled)\n+      // FIXME: need to translate event coordinates to parent's\n+      // coordinate space.\n+      handled = getParent ().postEvent (e);\n+\n+    return handled;\n   }\n \n   /**\n@@ -3170,20 +3151,61 @@ protected void processHierarchyBoundsEvent(HierarchyEvent e)\n   }\n \n   /**\n-   * AWT 1.0 event processor.\n+   * AWT 1.0 event handler.\n+   *\n+   * This method calls one of the event-specific handler methods.  For\n+   * example for key events, either {@link #keyDown (Event evt, int\n+   * key)} or {@link keyUp (Event evt, int key)} is called.  A derived\n+   * component can override one of these event-specific methods if it\n+   * only needs to handle certain event types.  Otherwise it can\n+   * override handleEvent itself and handle any event.\n    *\n    * @param evt the event to handle\n-   * @return false: since the method was deprecated, the return has no meaning\n+   * @return true if the event was handled, false otherwise\n    * @deprecated use {@link #processEvent(AWTEvent)} instead\n    */\n   public boolean handleEvent(Event evt)\n   {\n-    // XXX Add backward compatibility handling.\n+    switch (evt.id)\n+      {\n+\t// Handle key events.\n+      case Event.KEY_ACTION:\n+      case Event.KEY_PRESS:\n+\treturn keyDown (evt, evt.key);\n+      case Event.KEY_ACTION_RELEASE:\n+      case Event.KEY_RELEASE:\n+\treturn keyUp (evt, evt.key);\n+\n+\t// Handle mouse events.\n+      case Event.MOUSE_DOWN:\n+\treturn mouseDown (evt, evt.x, evt.y);\n+      case Event.MOUSE_UP:\n+\treturn mouseUp (evt, evt.x, evt.y);\n+      case Event.MOUSE_MOVE:\n+\treturn mouseMove (evt, evt.x, evt.y);\n+      case Event.MOUSE_DRAG:\n+\treturn mouseDrag (evt, evt.x, evt.y);\n+      case Event.MOUSE_ENTER:\n+\treturn mouseEnter (evt, evt.x, evt.y);\n+      case Event.MOUSE_EXIT:\n+\treturn mouseExit (evt, evt.x, evt.y);\n+\n+\t// Handle focus events.\n+      case Event.GOT_FOCUS:\n+\treturn gotFocus (evt, evt.arg);\n+      case Event.LOST_FOCUS:\n+\treturn lostFocus (evt, evt.arg);\n+\n+\t// Handle action event.\n+      case Event.ACTION_EVENT:\n+\treturn action (evt, evt.arg);\n+      }\n+    // Unknown event.\n     return false;\n   }\n \n   /**\n-   * AWT 1.0 mouse event.\n+   * AWT 1.0 mouse event handler.\n    *\n    * @param evt the event to handle\n    * @param x the x coordinate, ignored\n@@ -3686,7 +3708,20 @@ && isFocusable ())\n                     // lightweight component.  In either case we want to\n                     // post a FOCUS_GAINED event.\n                     EventQueue eq = Toolkit.getDefaultToolkit ().getSystemEventQueue ();\n-                    eq.postEvent (new FocusEvent(this, FocusEvent.FOCUS_GAINED));\n+                    synchronized (eq)\n+                      {\n+                        KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();\n+                        Component currentFocusOwner = manager.getGlobalPermanentFocusOwner ();\n+                        if (currentFocusOwner != null)\n+                          {\n+                            eq.postEvent (new FocusEvent(currentFocusOwner, FocusEvent.FOCUS_LOST,\n+                                                         false, this));\n+                            eq.postEvent (new FocusEvent(this, FocusEvent.FOCUS_GAINED, false,\n+                                                         currentFocusOwner));\n+                          }\n+                        else\n+                          eq.postEvent (new FocusEvent(this, FocusEvent.FOCUS_GAINED, false));\n+                      }\n                   }\n               }\n             else\n@@ -3759,9 +3794,25 @@ && isFocusable ())\n                     // lightweight component.  In either case we want to\n                     // post a FOCUS_GAINED event.\n                     EventQueue eq = Toolkit.getDefaultToolkit ().getSystemEventQueue ();\n+                    synchronized (eq)\n+                      {\n+                        KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();\n+                        Component currentFocusOwner = manager.getGlobalPermanentFocusOwner ();\n+                        if (currentFocusOwner != null)\n+                          {\n+                            eq.postEvent (new FocusEvent(currentFocusOwner,\n+                                                         FocusEvent.FOCUS_LOST,\n+                                                         temporary, this));\n+                            eq.postEvent (new FocusEvent(this,\n+                                                         FocusEvent.FOCUS_GAINED,\n+                                                         temporary,\n+                                                         currentFocusOwner));\n+                          }\n+                        else\n                     eq.postEvent (new FocusEvent(this, FocusEvent.FOCUS_GAINED, temporary));\n                   }\n               }\n+              }\n             else\n               // FIXME: need to add a focus listener to our top-level\n               // ancestor, so that we can post this event when it becomes\n@@ -3852,7 +3903,8 @@ && isFocusable ())\n                 // Check if top-level ancestor is currently focused window.\n                 if (focusedWindow == toplevel)\n                   {\n-                    if (peer != null)\n+                    if (peer != null\n+                        && !(this instanceof Window))\n                       // This call will cause a FOCUS_GAINED event to be\n                       // posted to the system event queue if the native\n                       // windowing system grants the focus request.\n@@ -3863,9 +3915,21 @@ && isFocusable ())\n                         // lightweight component.  In either case we want to\n                         // post a FOCUS_GAINED event.\n                         EventQueue eq = Toolkit.getDefaultToolkit ().getSystemEventQueue ();\n+                        synchronized (eq)\n+                          {\n+                            Component currentFocusOwner = manager.getGlobalPermanentFocusOwner ();\n+                            if (currentFocusOwner != null)\n+                              {\n+                                eq.postEvent (new FocusEvent(currentFocusOwner, FocusEvent.FOCUS_LOST,\n+                                                             temporary, this));\n+                                eq.postEvent (new FocusEvent(this, FocusEvent.FOCUS_GAINED, temporary,\n+                                                             currentFocusOwner));\n+                              }\n+                            else\n                         eq.postEvent (new FocusEvent(this, FocusEvent.FOCUS_GAINED, temporary));\n                       }\n                   }\n+                  }\n                 else\n                   return false;\n               }\n@@ -4041,8 +4105,8 @@ protected String paramString()\n     String name = getName();\n     if (name != null)\n       param.append(name).append(\",\");\n-    param.append(width).append(\"x\").append(height).append(\"+\").append(x)\n-      .append(\"+\").append(y);\n+    param.append(x).append(\",\").append(y).append(\",\").append(width)\n+      .append(\"x\").append(height);\n     if (! isValid())\n       param.append(\",invalid\");\n     if (! isVisible())\n@@ -4410,13 +4474,212 @@ GraphicsConfiguration getGraphicsConfigurationImpl()\n   }\n \n   /**\n-   * Implementation of dispatchEvent. Allows trusted package classes to\n-   * dispatch additional events first.\n+   * Translate an AWT 1.1 event ({@link AWTEvent}) into an AWT 1.0\n+   * event ({@link Event}).\n+   *\n+   * @param e an AWT 1.1 event to translate\n+   *\n+   * @return an AWT 1.0 event representing e\n+   */\n+  private Event translateEvent (AWTEvent e)\n+  {\n+    Component target = (Component) e.getSource ();\n+    Event translated = null;\n+\n+    if (e instanceof InputEvent)\n+      {\n+        InputEvent ie = (InputEvent) e;\n+        long when = ie.getWhen ();\n+\n+        int oldID = 0;\n+        int id = e.getID ();\n+\n+        int oldMods = 0;\n+        int mods = ie.getModifiers ();\n+\n+        if ((mods & InputEvent.BUTTON2_MASK) != 0)\n+          oldMods |= Event.META_MASK;\n+        else if ((mods & InputEvent.BUTTON3_MASK) != 0)\n+          oldMods |= Event.ALT_MASK;\n+\n+        if ((mods & (InputEvent.SHIFT_MASK | InputEvent.SHIFT_DOWN_MASK)) != 0)\n+          oldMods |= Event.SHIFT_MASK;\n+\n+        if ((mods & (InputEvent.CTRL_MASK | InputEvent.CTRL_DOWN_MASK)) != 0)\n+          oldMods |= Event.CTRL_MASK;\n+\n+        if ((mods & (InputEvent.META_MASK | InputEvent.META_DOWN_MASK)) != 0)\n+          oldMods |= Event.META_MASK;\n+\n+        if ((mods & (InputEvent.ALT_MASK | InputEvent.ALT_DOWN_MASK)) != 0)\n+          oldMods |= Event.ALT_MASK;\n+\n+        if (e instanceof MouseEvent)\n+          {\n+            if (id == MouseEvent.MOUSE_PRESSED)\n+              oldID = Event.MOUSE_DOWN;\n+            else if (id == MouseEvent.MOUSE_RELEASED)\n+              oldID = Event.MOUSE_UP;\n+            else if (id == MouseEvent.MOUSE_MOVED)\n+              oldID = Event.MOUSE_MOVE;\n+            else if (id == MouseEvent.MOUSE_DRAGGED)\n+              oldID = Event.MOUSE_DRAG;\n+            else if (id == MouseEvent.MOUSE_ENTERED)\n+              oldID = Event.MOUSE_ENTER;\n+            else if (id == MouseEvent.MOUSE_EXITED)\n+              oldID = Event.MOUSE_EXIT;\n+            else\n+              // No analogous AWT 1.0 mouse event.\n+              return null;\n+\n+            MouseEvent me = (MouseEvent) e;\n+\n+            translated = new Event (target, when, oldID,\n+                                    me.getX (), me.getY (), 0, oldMods);\n+          }\n+        else if (e instanceof KeyEvent)\n+          {\n+            if (id == KeyEvent.KEY_PRESSED)\n+              oldID = Event.KEY_PRESS;\n+            else if (e.getID () == KeyEvent.KEY_RELEASED)\n+              oldID = Event.KEY_RELEASE;\n+            else\n+              // No analogous AWT 1.0 key event.\n+              return null;\n+\n+            int oldKey = 0;\n+            int newKey = ((KeyEvent) e).getKeyCode ();\n+            switch (newKey)\n+              {\n+              case KeyEvent.VK_BACK_SPACE:\n+                oldKey = Event.BACK_SPACE;\n+                break;\n+              case KeyEvent.VK_CAPS_LOCK:\n+                oldKey = Event.CAPS_LOCK;\n+                break;\n+              case KeyEvent.VK_DELETE:\n+                oldKey = Event.DELETE;\n+                break;\n+              case KeyEvent.VK_DOWN:\n+              case KeyEvent.VK_KP_DOWN:\n+                oldKey = Event.DOWN;\n+                break;\n+              case KeyEvent.VK_END:\n+                oldKey = Event.END;\n+                break;\n+              case KeyEvent.VK_ENTER:\n+                oldKey = Event.ENTER;\n+                break;\n+              case KeyEvent.VK_ESCAPE:\n+                oldKey = Event.ESCAPE;\n+                break;\n+              case KeyEvent.VK_F1:\n+                oldKey = Event.F1;\n+                break;\n+              case KeyEvent.VK_F10:\n+                oldKey = Event.F10;\n+                break;\n+              case KeyEvent.VK_F11:\n+                oldKey = Event.F11;\n+                break;\n+              case KeyEvent.VK_F12:\n+                oldKey = Event.F12;\n+                break;\n+              case KeyEvent.VK_F2:\n+                oldKey = Event.F2;\n+                break;\n+              case KeyEvent.VK_F3:\n+                oldKey = Event.F3;\n+                break;\n+              case KeyEvent.VK_F4:\n+                oldKey = Event.F4;\n+                break;\n+              case KeyEvent.VK_F5:\n+                oldKey = Event.F5;\n+                break;\n+              case KeyEvent.VK_F6:\n+                oldKey = Event.F6;\n+                break;\n+              case KeyEvent.VK_F7:\n+                oldKey = Event.F7;\n+                break;\n+              case KeyEvent.VK_F8:\n+                oldKey = Event.F8;\n+                break;\n+              case KeyEvent.VK_F9:\n+                oldKey = Event.F9;\n+                break;\n+              case KeyEvent.VK_HOME:\n+                oldKey = Event.HOME;\n+                break;\n+              case KeyEvent.VK_INSERT:\n+                oldKey = Event.INSERT;\n+                break;\n+              case KeyEvent.VK_LEFT:\n+              case KeyEvent.VK_KP_LEFT:\n+                oldKey = Event.LEFT;\n+                break;\n+              case KeyEvent.VK_NUM_LOCK:\n+                oldKey = Event.NUM_LOCK;\n+                break;\n+              case KeyEvent.VK_PAUSE:\n+                oldKey = Event.PAUSE;\n+                break;\n+              case KeyEvent.VK_PAGE_DOWN:\n+                oldKey = Event.PGDN;\n+                break;\n+              case KeyEvent.VK_PAGE_UP:\n+                oldKey = Event.PGUP;\n+                break;\n+              case KeyEvent.VK_PRINTSCREEN:\n+                oldKey = Event.PRINT_SCREEN;\n+                break;\n+              case KeyEvent.VK_RIGHT:\n+              case KeyEvent.VK_KP_RIGHT:\n+                oldKey = Event.RIGHT;\n+                break;\n+              case KeyEvent.VK_SCROLL_LOCK:\n+                oldKey = Event.SCROLL_LOCK;\n+                break;\n+              case KeyEvent.VK_TAB:\n+                oldKey = Event.TAB;\n+                break;\n+              case KeyEvent.VK_UP:\n+              case KeyEvent.VK_KP_UP:\n+                oldKey = Event.UP;\n+                break;\n+              default:\n+                oldKey = newKey;\n+              }\n+\n+            translated = new Event (target, when, oldID,\n+                                    0, 0, oldKey, oldMods);\n+          }\n+      }\n+    else if (e instanceof ActionEvent)\n+      translated = new Event (target, Event.ACTION_EVENT,\n+                              ((ActionEvent) e).getActionCommand ());\n+\n+    return translated;\n+  }\n+\n+  /**\n+   * Implementation of dispatchEvent. Allows trusted package classes\n+   * to dispatch additional events first.  This implementation first\n+   * translates <code>e</code> to an AWT 1.0 event and sends the\n+   * result to {@link #postEvent}.  If the AWT 1.0 event is not\n+   * handled, and events of type <code>e</code> are enabled for this\n+   * component, e is passed on to {@link #processEvent}.\n    *\n    * @param e the event to dispatch\n    */\n   void dispatchEventImpl(AWTEvent e)\n   {\n+    Event oldEvent = translateEvent (e);\n+\n+    if (oldEvent != null)\n+      postEvent (oldEvent);\n+\n     if (eventTypeEnabled (e.id))\n       processEvent(e);\n   }"}, {"sha": "6c70e940e8ec327d552228495f39c0d6edcc48e3", "filename": "libjava/java/awt/Container.java", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FContainer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FContainer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FContainer.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -856,6 +856,16 @@ protected void processContainerEvent(ContainerEvent e)\n    */\n   public void deliverEvent(Event e)\n   {\n+    if (!handleEvent (e))\n+      {\n+        synchronized (getTreeLock ())\n+          {\n+            Component parent = getParent ();\n+\n+            if (parent != null)\n+              parent.deliverEvent (e);\n+          }\n+      }\n   }\n \n   /**\n@@ -1027,7 +1037,7 @@ protected String paramString()\n   {\n     String param = super.paramString();\n     if (layoutMgr != null)\n-      param = param + \",\" + layoutMgr.getClass().getName();\n+      param = param + \",layout=\" + layoutMgr.getClass().getName();\n \n     return param;\n   }"}, {"sha": "d4c8bdd4fa89d73baa90a799a413d8dab98bec00", "filename": "libjava/java/awt/DefaultKeyboardFocusManager.java", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FDefaultKeyboardFocusManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FDefaultKeyboardFocusManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FDefaultKeyboardFocusManager.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -162,16 +162,41 @@ else if (e instanceof FocusEvent)\n       {\n         Component target = (Component) e.getSource ();\n \n-        if (e.id == FocusEvent.FOCUS_GAINED\n-            && !(target instanceof Window))\n+        if (e.id == FocusEvent.FOCUS_GAINED)\n           {\n             if (((FocusEvent) e).isTemporary ())\n               setGlobalFocusOwner (target);\n             else\n               setGlobalPermanentFocusOwner (target);\n           }\n+        else if (e.id == FocusEvent.FOCUS_LOST)\n+          {\n+            // We need to set the window's focus owner here; we can't\n+            // set it when the window loses focus because by that time\n+            // the previous focus owner has already lost focus\n+            // (FOCUS_LOST events are delivered before\n+            // WINDOW_LOST_FOCUS events).\n+\n+            // Find the target Component's top-level ancestor.\n+            Container parent = target.getParent ();\n+\n+            while (parent != null\n+                   && !(parent instanceof Window))\n+              parent = parent.getParent ();\n+\n+            Window toplevel = parent == null ?\n+              (Window) target : (Window) parent;\n+\n+            Component focusOwner = getFocusOwner ();\n+            if (focusOwner != null)\n+              toplevel.setFocusOwner (focusOwner);\n+\n+            if (((FocusEvent) e).isTemporary ())\n+              setGlobalFocusOwner (null);\n+            else\n+              setGlobalPermanentFocusOwner (null);\n+          }\n \n-        if (!(target instanceof Window))\n           target.dispatchEvent (e);\n \n         return true;\n@@ -192,6 +217,8 @@ else if (e instanceof KeyEvent)\n         // processKeyEvent checks if this event represents a focus\n         // traversal key stroke.\n         Component focusOwner = getGlobalPermanentFocusOwner ();\n+\n+        if (focusOwner != null)\n         processKeyEvent (focusOwner, (KeyEvent) e);\n \n         if (e.isConsumed ())\n@@ -230,6 +257,7 @@ public boolean dispatchKeyEvent (KeyEvent e)\n   {\n     Component focusOwner = getGlobalPermanentFocusOwner ();\n \n+    if (focusOwner != null)\n     focusOwner.dispatchEvent (e);\n \n     // Loop through all registered KeyEventPostProcessors, giving"}, {"sha": "57e7c79f232e71cfd720c5a182d33d2d27ecbf8b", "filename": "libjava/java/awt/Event.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FEvent.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -163,7 +163,8 @@ public boolean metaDown ()\n \n   protected String paramString ()\n   {\n-    return \"id=\" + id + \",x=\" + x + \",y=\" + y + \"target=\" + target;\n+    return \"id=\" + id + \",x=\" + x + \",y=\" + y\n+      + \",target=\" + target + \",arg=\" + arg;\n   }\n \n   public boolean shiftDown() "}, {"sha": "6a3514758b735704c2f2837fbf4594d18b11f2c9", "filename": "libjava/java/awt/Font.java", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FFont.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FFont.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FFont.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -1268,10 +1268,9 @@ public int hashCode()\n   return(getClass().getName() \n          + \"(logical=\" + getName () \n          + \",family=\" + getFamily ()\n-         + \",face=\" + getFontName ()\n+         + \",name=\" + getFontName ()\n          + \",style=\" + getStyle ()\n-         + \",size=\" + getSize ()\n-         + \",transform=\" + getTransform () + \")\");\n+         + \",size=\" + getSize ());\n }\n \n "}, {"sha": "dd8cdeb00d173e92fe727d32b662e366d48e5b81", "filename": "libjava/java/awt/Frame.java", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FFrame.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FFrame.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FFrame.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -50,11 +50,6 @@\n   */\n public class Frame extends Window implements MenuContainer\n {\n-\n-/*\n- * Static Variables\n- */\n-\n /**\n   * Constant for the default cursor.\n   * @deprecated Replaced by <code>Cursor.DEFAULT_CURSOR</code> instead.\n@@ -148,12 +143,6 @@ public class Frame extends Window implements MenuContainer\n // Serialization version constant\n private static final long serialVersionUID = 2673458971256075116L;\n \n-/*************************************************************************/\n-\n-/*\n- * Instance Variables\n- */\n-\n /**\n   * @serial The version of the class data being serialized\n   * // FIXME: what is this value?\n@@ -208,11 +197,10 @@ public class Frame extends Window implements MenuContainer\n    */\n   private boolean undecorated = false;\n \n-/*************************************************************************/\n-\n /*\n- * Constructors\n+   * The number used to generate the name returned by getName.\n  */\n+  private static transient long next_frame_number = 0;\n \n /**\n   * Initializes a new instance of <code>Frame</code> that is not visible\n@@ -224,8 +212,6 @@ public class Frame extends Window implements MenuContainer\n   this(\"\");\n }\n \n-/*************************************************************************/\n-\n /**\n   * Initializes a new instance of <code>Frame</code> that is not visible\n   * and has the specified title.\n@@ -256,12 +242,6 @@ public class Frame extends Window implements MenuContainer\n   visible = false;\n }\n \n-/*************************************************************************/\n-\n-/*\n- * Instance Methods\n- */\n-\n /**\n   * Returns this frame's title string.\n   *\n@@ -273,8 +253,6 @@ public class Frame extends Window implements MenuContainer\n   return(title);\n }\n \n-/*************************************************************************/\n-\n /*\n  * Sets this frame's title to the specified value.\n  *\n@@ -288,8 +266,6 @@ public class Frame extends Window implements MenuContainer\n     ((FramePeer) peer).setTitle(title);\n }\n \n-/*************************************************************************/\n-\n /**\n   * Returns this frame's icon.\n   *\n@@ -302,8 +278,6 @@ public class Frame extends Window implements MenuContainer\n   return(icon);\n }\n \n-/*************************************************************************/\n-\n /**\n   * Sets this frame's icon to the specified value.\n   *\n@@ -317,8 +291,6 @@ public class Frame extends Window implements MenuContainer\n     ((FramePeer) peer).setIconImage(icon);\n }\n \n-/*************************************************************************/\n-\n /**\n   * Returns this frame's menu bar.\n   *\n@@ -331,8 +303,6 @@ public class Frame extends Window implements MenuContainer\n   return(menuBar);\n }\n \n-/*************************************************************************/\n-\n /**\n   * Sets this frame's menu bar.\n   *\n@@ -352,8 +322,6 @@ public class Frame extends Window implements MenuContainer\n   this.menuBar = menuBar;\n }\n \n-/*************************************************************************/\n-\n /**\n   * Tests whether or not this frame is resizable.  This will be \n   * <code>true</code> by default.\n@@ -367,8 +335,6 @@ public class Frame extends Window implements MenuContainer\n   return(resizable);\n }\n \n-/*************************************************************************/\n-\n /**\n   * Sets the resizability of this frame to the specified value.\n   *\n@@ -383,8 +349,6 @@ public class Frame extends Window implements MenuContainer\n     ((FramePeer) peer).setResizable(resizable);\n }\n \n-/*************************************************************************/\n-\n /**\n   * Returns the cursor type of the cursor for this window.  This will\n   * be one of the constants in this class.\n@@ -399,8 +363,6 @@ public class Frame extends Window implements MenuContainer\n   return(getCursor().getType());\n }\n \n-/*************************************************************************/\n-\n /**\n   * Sets the cursor for this window to the specified type.  The specified\n   * type should be one of the constants in this class.\n@@ -415,8 +377,6 @@ public class Frame extends Window implements MenuContainer\n   setCursor(new Cursor(type));\n }\n \n-/*************************************************************************/\n-\n /**\n   * Removes the specified component from this frame's menu.\n   *\n@@ -428,8 +388,6 @@ public class Frame extends Window implements MenuContainer\n   menuBar.remove(menu);\n }\n \n-/*************************************************************************/\n-\n /**\n   * Notifies this frame that it should create its native peer.\n   */\n@@ -450,17 +408,40 @@ public void removeNotify()\n   super.removeNotify();\n }\n \n-/*************************************************************************/\n-\n /**\n   * Returns a debugging string describing this window.\n   *\n   * @return A debugging string describing this window.\n   */\n-protected String\n-paramString()\n+  protected String paramString ()\n {\n-  return(getClass().getName());\n+    String title = getTitle ();\n+\n+    String resizable = \"\";\n+    if (isResizable ())\n+      resizable = \",resizable\";\n+\n+    String state = \"\";\n+    switch (getState ())\n+      {\n+      case NORMAL:\n+        state = \",normal\";\n+        break;\n+      case ICONIFIED:\n+        state = \",iconified\";\n+        break;\n+      case MAXIMIZED_BOTH:\n+        state = \",maximized-both\";\n+        break;\n+      case MAXIMIZED_HORIZ:\n+        state = \",maximized-horiz\";\n+        break;\n+      case MAXIMIZED_VERT:\n+        state = \",maximized-vert\";\n+        break;\n+      }\n+\n+    return super.paramString () + \",title=\" + title + resizable + state;\n }\n \n public static Frame[]\n@@ -553,5 +534,19 @@ public void setUndecorated (boolean undecorated)\n \n     this.undecorated = undecorated;\n   }\n-} // class Frame \n \n+  /**\n+   * Generate a unique name for this frame.\n+   *\n+   * @return A unique name for this frame.\n+   */\n+  String generateName ()\n+  {\n+    return \"frame\" + getUniqueLong ();\n+  }\n+\n+  private static synchronized long getUniqueLong ()\n+  {\n+    return next_frame_number++;\n+  }\n+}"}, {"sha": "1239f2cf7f4949f01265530b914730c1a6d005bd", "filename": "libjava/java/awt/GridBagLayout.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FGridBagLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FGridBagLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FGridBagLayout.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -340,7 +340,7 @@ protected void ArrangeGrid (Container parent)\n       if (components.length == 0)\n         return;\n \n-      GridBagLayoutInfo info = getLayoutInfo (parent, MINSIZE);\n+      GridBagLayoutInfo info = getLayoutInfo (parent, PREFERREDSIZE);\n       if (info.cols == 0 && info.rows == 0)\n         return;\n       layoutInfo = info;"}, {"sha": "e82c0d488252d39e61957464a9401bc3c3739776", "filename": "libjava/java/awt/KeyboardFocusManager.java", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FKeyboardFocusManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FKeyboardFocusManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FKeyboardFocusManager.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -246,7 +246,10 @@ public static void setCurrentKeyboardFocusManager (KeyboardFocusManager m)\n    */\n   public Component getFocusOwner ()\n   {\n-    return (Component) getObject (currentFocusOwners);\n+    Component owner = (Component) getObject (currentFocusOwners);\n+    if (owner == null)\n+      owner = (Component) getObject (currentPermanentFocusOwners);\n+    return owner;\n   }\n \n   /**"}, {"sha": "dbe322896d729c6de37a602ae5c4d4339eec1cbf", "filename": "libjava/java/awt/Panel.java", "status": "modified", "additions": 61, "deletions": 2, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FPanel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FPanel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FPanel.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -38,6 +38,7 @@\n \n package java.awt;\n \n+import java.awt.event.PaintEvent;\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n@@ -62,6 +63,19 @@ public class Panel extends Container implements Accessible\n   /** The cached accessible context. */\n   private transient AccessibleContext context;\n \n+  /** Flag set when the first system-requested paint event is\n+      dispatched. */\n+  private transient boolean initialSystemUpdateDone;\n+\n+  /** Flag set when the first application-requested paint event is\n+      consumed. */\n+  private transient boolean initialUpdateConsumed;\n+\n+  /*\n+   * The number used to generate the name returned by getName.\n+   */\n+  private static transient long next_panel_number = 0;\n+\n   /**\n    * Initializes a new instance of <code>Panel</code> that has a default\n    * layout manager of <code>FlowLayout</code>.\n@@ -83,6 +97,36 @@ public Panel(LayoutManager layoutManager)\n     setLayout(layoutManager);\n   }\n \n+  /**\n+   * Consume initial application-requested paint event if it has not\n+   * already been consumed, and if the initial system-requested paint\n+   * event has not already been handled.  Otherwise, call\n+   * super.dispatchEventImpl.  These extra steps are required to\n+   * prevent a Panel from being painted twice when it is initially\n+   * shown.\n+   *\n+   * @param e the event to dispatch\n+   */\n+  void dispatchEventImpl (AWTEvent e)\n+  {\n+    if (e instanceof PaintEvent)\n+      {\n+        if (e.id == PaintEvent.UPDATE)\n+          {\n+            if (!initialUpdateConsumed\n+                && !initialSystemUpdateDone)\n+              {\n+                e.consume ();\n+                initialUpdateConsumed = true;\n+              }\n+          }\n+        else if (e.id == PaintEvent.PAINT)\n+          initialSystemUpdateDone = true;\n+      }\n+    else\n+      super.dispatchEventImpl (e);\n+  }\n+\n   /**\n    * Notifies this object to create its native peer.\n    *\n@@ -141,5 +185,20 @@ public AccessibleRole getAccessibleRole()\n     {\n       return AccessibleRole.PANEL;\n     }\n-  } // class AccessibleAWTPanel\n-} // class Panel \n+  }\n+\n+  /**\n+   * Generate a unique name for this panel.\n+   *\n+   * @return A unique name for this panel.\n+   */\n+  String generateName ()\n+  {\n+    return \"panel\" + getUniqueLong ();\n+  }\n+\n+  private static synchronized long getUniqueLong ()\n+  {\n+    return next_panel_number++;\n+  }\n+}"}, {"sha": "457df0c0e264e8420f920070656dc00f497929fe", "filename": "libjava/java/awt/ScrollPane.java", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FScrollPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FScrollPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FScrollPane.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -157,6 +157,9 @@ public class ScrollPane extends Container implements Accessible\n     }\n \n   wheelScrollingEnabled = true;\n+\n+  // Default size.\n+  setSize(100,100);\n }\n \n /*************************************************************************/\n@@ -400,6 +403,15 @@ else if (dim.width > (viewsize.width - vScrollbarWidth))\n \n   setPeer((ComponentPeer)getToolkit().createScrollPane(this));\n   super.addNotify();\n+\n+  Component[] list = getComponents();\n+  if (list != null && list.length > 0 && ! (list[0] instanceof Panel))\n+  {\n+    Panel panel = new Panel();\n+    panel.setLayout(new BorderLayout());\n+    panel.add(list[0], BorderLayout.CENTER);\n+    add(panel);\n+  }\n }\n \n /*************************************************************************/\n@@ -527,7 +539,19 @@ protected final void addImpl (Component component, Object constraints,\n public String\n paramString()\n {\n-  return(getClass().getName());\n+  Insets insets = getInsets();\n+  return getName() + \",\"\n+         + getX() + \",\"\n+         + getY() + \",\"\n+         + getWidth() + \"x\" + getHeight() + \",\"\n+         + \"ScrollPosition=(\" + scrollPosition.getX() + \",\" \n+                              + scrollPosition.getY() + \"),\"\n+         + \"Insets=(\" + insets.top + \",\"\n+                      + insets.left + \",\"\n+                      + insets.bottom + \",\"\n+                      + insets.right + \"),\"\n+         + \"ScrollbarDisplayPolicy=\" + getScrollbarDisplayPolicy() + \",\"\n+         + \"wheelScrollingEnabled=\" + isWheelScrollingEnabled();\n }\n \n   /**"}, {"sha": "7397a1c1c330fd44a29e61cf641d9ab188782862", "filename": "libjava/java/awt/Window.java", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FWindow.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2FWindow.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FWindow.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -39,6 +39,8 @@\n package java.awt;\n \n import java.awt.event.ComponentEvent;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.WindowAdapter;\n import java.awt.event.WindowEvent;\n import java.awt.event.WindowFocusListener;\n import java.awt.event.WindowListener;\n@@ -85,6 +87,8 @@ public class Window extends Container implements Accessible\n \n   private transient boolean shown;\n \n+  private transient Component windowFocusOwner;\n+\n   /** \n    * This (package access) constructor is used by subclasses that want\n    * to build windows that do not have parents.  Eg. toplevel\n@@ -98,6 +102,33 @@ public class Window extends Container implements Accessible\n     // cycle roots.\n     focusCycleRoot = true;\n     setLayout(new BorderLayout());\n+\n+    addWindowFocusListener (new WindowAdapter ()\n+      {\n+        public void windowGainedFocus (WindowEvent event)\n+        {\n+          if (windowFocusOwner != null)\n+            {\n+              // FIXME: move this section and the other similar\n+              // sections in Component into a separate method.\n+              EventQueue eq = Toolkit.getDefaultToolkit ().getSystemEventQueue ();\n+              synchronized (eq)\n+                {\n+                  KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();\n+                  Component currentFocusOwner = manager.getGlobalPermanentFocusOwner ();\n+                  if (currentFocusOwner != null)\n+                    {\n+                      eq.postEvent (new FocusEvent (currentFocusOwner, FocusEvent.FOCUS_LOST,\n+                                                    false, windowFocusOwner));\n+                      eq.postEvent (new FocusEvent (windowFocusOwner, FocusEvent.FOCUS_GAINED,\n+                                                    false, currentFocusOwner));\n+                    }\n+                  else\n+                    eq.postEvent (new FocusEvent (windowFocusOwner, FocusEvent.FOCUS_GAINED, false));\n+                }\n+            }\n+        }\n+      });\n   }\n \n   Window(GraphicsConfiguration gc)\n@@ -658,8 +689,22 @@ public Component getFocusOwner ()\n     // The currently-focused Component belongs to the active Window.\n     if (activeWindow == this)\n       return manager.getFocusOwner ();\n+    else\n+      return windowFocusOwner;\n+  }\n \n-    return null;\n+  /**\n+   * Set the focus owner for this window.  This method is used to\n+   * remember which component was focused when this window lost\n+   * top-level focus, so that when it regains top-level focus the same\n+   * child component can be refocused.\n+   *\n+   * @param windowFocusOwner the component in this window that owns\n+   * the focus.\n+   */\n+  void setFocusOwner (Component windowFocusOwner)\n+  {\n+    this.windowFocusOwner = windowFocusOwner;\n   }\n \n   /**\n@@ -671,8 +716,7 @@ public Component getFocusOwner ()\n    */\n   public boolean postEvent(Event e)\n   {\n-    // FIXME\n-    return false;\n+    return handleEvent (e);\n   }\n \n   /**"}, {"sha": "b18779af146944ee270d40f0622381b26052e866", "filename": "libjava/java/awt/image/BufferedImage.java", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2Fimage%2FBufferedImage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2Fimage%2FBufferedImage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FBufferedImage.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -47,6 +47,8 @@\n import java.awt.color.ColorSpace;\n import java.util.Hashtable;\n import java.util.Vector;\n+import java.util.HashSet;\n+import java.util.Iterator;\n import gnu.java.awt.ComponentDataBlitOp;\n \n /**\n@@ -442,7 +444,57 @@ public SampleModel getSampleModel()\n     \n   public ImageProducer getSource()\n   {\n-    throw new UnsupportedOperationException(\"not implemented\");\n+    return new ImageProducer() {\n+        \n+        HashSet consumers = new HashSet();\n+\n+        public void addConsumer(ImageConsumer ic)\n+        {\n+          consumers.add(ic);\n+        }\n+\n+        public boolean isConsumer(ImageConsumer ic)\n+        {\n+          return consumers.contains(ic);\n+        }\n+\n+        public void removeConsumer(ImageConsumer ic)\n+        {\n+          consumers.remove(ic);\n+        }\n+\n+        public void startProduction(ImageConsumer ic)\n+        {\n+          int x = 0;\n+          int y = 0;\n+          int width = getWidth();\n+          int height = getHeight();\n+          int stride = width;\n+          int offset = 0;\n+          int[] pixels = getRGB(x, y, \n+                                width, height, \n+                                (int[])null, offset, stride);\n+          ColorModel model = getColorModel();\n+\n+          consumers.add(ic);\n+\n+          Iterator i = consumers.iterator();\n+          while(i.hasNext())\n+            {\n+              ImageConsumer c = (ImageConsumer) i.next();\n+              c.setHints(ImageConsumer.SINGLEPASS);\n+              c.setDimensions(getWidth(), getHeight());\n+              c.setPixels(x, y, width, height, model, pixels, offset, stride);\n+              c.imageComplete(ImageConsumer.STATICIMAGEDONE);\n+            }\n+        }\n+\n+        public void requestTopDownLeftRightResend(ImageConsumer ic)\n+        {\n+          startProduction(ic);\n+        }\n+\n+      };\n   }\n   \n   public Vector getSources()"}, {"sha": "572f6e9212d5b90aa1f2ebec772c857d152793d8", "filename": "libjava/java/awt/image/ByteLookupTable.java", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2Fimage%2FByteLookupTable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2Fimage%2FByteLookupTable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FByteLookupTable.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -0,0 +1,162 @@\n+/* ByteLookupTable.java -- Java class for a pixel translation table.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.image;\n+\n+/**\n+ * ByteLookupTable represents translation arrays for pixel values.  It wraps\n+ * one or more data arrays for each layer (or component) in an image, such as\n+ * Alpha, R, G, and B.  When doing translation, the offset is subtracted from\n+ * the pixel values to allow a subset of an array to be used.\n+ *\n+ * @author <a href=\"mailto:jlquinn@optonline.net\">Jerry Quinn</a>\n+ * @version 1.0\n+ */\n+public class ByteLookupTable extends LookupTable\n+{\n+  // Array of translation tables.\n+  private byte data[][];\n+\n+  /**\n+   * Creates a new <code>ByteLookupTable</code> instance.\n+   *\n+   * Offset is subtracted from pixel values when looking up in the translation\n+   * tables.  If data.length is one, the same table is applied to all pixel\n+   * components.\n+   * \n+   * @param offset Offset to be subtracted.\n+   * @param data Array of lookup tables.\n+   * @exception IllegalArgumentException if offset < 0 or data.length < 1.\n+   */\n+  public ByteLookupTable(int offset, byte[][] data)\n+    throws IllegalArgumentException\n+  {\n+    super(offset, data.length);\n+    this.data = data;\n+  }\n+\n+  /**\n+   * Creates a new <code>ByteLookupTable</code> instance.\n+   *\n+   * Offset is subtracted from pixel values when looking up in the translation\n+   * table.  The same table is applied to all pixel components.\n+   * \n+   * @param offset Offset to be subtracted.\n+   * @param data Lookup table for all components.\n+   * @exception IllegalArgumentException if offset < 0.\n+   */\n+  public ByteLookupTable(int offset, byte[] data)\n+    throws IllegalArgumentException\n+  {\n+    super(offset, 1);\n+    this.data = new byte[][] {data};\n+  }\n+\n+  /** Return the lookup tables. */\n+  public final byte[][] getTable()\n+  {\n+    return data;\n+  }\n+\n+  /**\n+   * Return translated values for a pixel.\n+   *\n+   * For each value in the pixel src, use the value minus offset as an index\n+   * in the component array and copy the value there to the output for the\n+   * component.  If dest is null, the output is a new array, otherwise the\n+   * translated values are written to dest.  Dest can be the same array as\n+   * src.\n+   *\n+   * For example, if the pixel src is [2, 4, 3], and offset is 1, the output\n+   * is [comp1[1], comp2[3], comp3[2]], where comp1, comp2, and comp3 are the\n+   * translation arrays.\n+   *\n+   * @param src Component values of a pixel.\n+   * @param dest Destination array for values, or null.\n+   * @return Translated values for the pixel.\n+   */\n+  public int[] lookupPixel(int[] src, int[] dst)\n+    throws ArrayIndexOutOfBoundsException\n+  {\n+    if (dst == null)\n+      dst = new int[numComponents];\n+\n+    if (data.length == 1)\n+      for (int i=0; i < src.length; i++)\n+\tdst[i] = data[0][src[i] - offset];\n+    else\n+      for (int i=0; i < src.length; i++)\n+\tdst[i] = data[i][src[i] - offset];\n+      \n+    return dst;\n+  }\n+\n+  /**\n+   * Return translated values for a pixel.\n+   *\n+   * For each value in the pixel src, use the value minus offset as an index\n+   * in the component array and copy the value there to the output for the\n+   * component.  If dest is null, the output is a new array, otherwise the\n+   * translated values are written to dest.  Dest can be the same array as\n+   * src.\n+   *\n+   * For example, if the pixel src is [2, 4, 3], and offset is 1, the output\n+   * is [comp1[1], comp2[3], comp3[2]], where comp1, comp2, and comp3 are the\n+   * translation arrays.\n+   *\n+   * @param src Component values of a pixel.\n+   * @param dest Destination array for values, or null.\n+   * @return Translated values for the pixel.\n+   */\n+  public byte[] lookupPixel(byte[] src, byte[] dst)\n+    throws ArrayIndexOutOfBoundsException\n+  {\n+    if (dst == null)\n+      dst = new byte[numComponents];\n+\n+    if (data.length == 1)\n+      for (int i=0; i < src.length; i++)\n+\tdst[i] = data[0][((int)src[i]) - offset];\n+    else\n+      for (int i=0; i < src.length; i++)\n+\tdst[i] = data[i][((int)src[i]) - offset];\n+      \n+    return dst;\n+\n+  }\n+}"}, {"sha": "87ab942917a462d53ae2de76b3619fed5993f365", "filename": "libjava/java/awt/image/ColorModel.java", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2Fimage%2FColorModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2Fimage%2FColorModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FColorModel.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -37,6 +37,7 @@\n \n package java.awt.image;\n \n+import java.util.Arrays;\n import java.awt.Point;\n import java.awt.Transparency;\n import java.awt.color.ColorSpace;\n@@ -551,8 +552,8 @@ public boolean equals(Object obj)\n       (transferType == o.transferType) &&\n       (transparency == o.transparency) &&\n       (hasAlpha == o.hasAlpha) &&\n-      (isAlphaPremultiplied == isAlphaPremultiplied) &&\n-      (bits.equals(o.bits)) &&\n+      (isAlphaPremultiplied == o.isAlphaPremultiplied) &&\n+      Arrays.equals(bits, o.bits) &&\n       (cspace.equals(o.cspace));\n   }\n "}, {"sha": "27d6ddd8faeaf250ff9acf6a0261f3b859d38416", "filename": "libjava/java/awt/image/Kernel.java", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2Fimage%2FKernel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2Fimage%2FKernel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FKernel.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -0,0 +1,136 @@\n+/* Kernel.java -- Java class for an image processing kernel\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.image;\n+\n+/**\n+ * Kernel represents an image processing kernel.  It gets used to hold\n+ * convolution filters among other purposes.  It stores an array of float\n+ * values representing a 2-dimensional array in row-major order.\n+ *\n+ * @author <a href=\"mailto:jlquinn@optonline.net\">Jerry Quinn</a>\n+ * @version 1.0\n+ */\n+public class Kernel implements Cloneable\n+{\n+  private final int width;\n+  private final int height;\n+  private final float[] data;\n+\n+  /**\n+   * Creates a new <code>Kernel</code> instance.\n+   *\n+   * @param width The 2D width of data.\n+   * @param height The 2D height of data.\n+   * @param data The source data array.\n+   * @exception IllegalArgumentException if width * height < data.length.\n+   */\n+  public Kernel(int width, int height, float[] data)\n+    throws IllegalArgumentException\n+  {\n+    this.width = width;\n+    this.height = height;\n+    if (data.length < width * height || width < 0 || height < 0)\n+      throw new IllegalArgumentException();\n+    this.data = new float[width * height];\n+    System.arraycopy(data, 0, this.data, 0, width * height);\n+  }\n+\n+  /**\n+   * Return the X origin: (width - 1) / 2\n+   */\n+  public final int getXOrigin()\n+  {\n+    return (width - 1) / 2;\n+  }\n+\n+  /**\n+   * Return the Y origin: (height - 1) / 2\n+   */\n+  public final int getYOrigin()\n+  {\n+    return (height - 1) / 2;\n+  }\n+\n+  /**\n+   * @return The kernel width.\n+   */\n+  public final int getWidth()\n+  {\n+    return width;\n+  }\n+\n+  /**\n+   * @return The kernel height.\n+   */\n+  public final int getHeight()\n+  {\n+    return height;\n+  }\n+\n+  /**\n+   * Return the kernel data.\n+   *\n+   * If data is null, allocates a new array and returns it.  Otherwise, the\n+   * kernel values are copied into data.\n+   *\n+   * @param data Array to copy values into, or null.\n+   * @return The array with copied values.\n+   * @exception IllegalArgumentException if data != null and too small.\n+   */\n+  public final float[] getKernelData(float[] data)\n+    throws IllegalArgumentException\n+  {\n+    if (data == null)\n+\treturn (float[])this.data.clone();\n+\n+    if (data.length < this.data.length)\n+      throw new IllegalArgumentException();\n+\n+    System.arraycopy(this.data, 0, data, 0, this.data.length);\n+    return data;\n+  }\n+\n+  /**\n+   * @return a clone of this Kernel.\n+   */\n+  public Object clone()\n+  {\n+    return new Kernel(width, height, data);\n+  }\n+}"}, {"sha": "eb89795c2c8b5b40387c122eb967b6eaddbb45c1", "filename": "libjava/java/awt/image/LookupTable.java", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2Fimage%2FLookupTable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2Fimage%2FLookupTable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FLookupTable.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -0,0 +1,109 @@\n+/* LookupTable.java -- Java class for a pixel translation table.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.image;\n+\n+/**\n+ * LookupTable represents translation arrays for pixel values.  It wraps one\n+ * or more data arrays for each layer (or component) in an image, such as\n+ * Alpha, R, G, and B.  When doing translation, the offset is subtracted from\n+ * the pixel values to allow a subset of an array to be used.\n+ *\n+ * @see ByteLookupTable\n+ * @see ShortLookupTable\n+ *\n+ * @author <a href=\"mailto:jlquinn@optonline.net\">Jerry Quinn</a>\n+ * @version 1.0\n+ */\n+public abstract class LookupTable\n+{\n+  // Not protected since that's part of the public API.\n+  int offset;\n+  int numComponents;\n+\n+  /**\n+   * Creates a new <code>LookupTable</code> instance.\n+   *\n+   * If numComponents is 1, the same translation table is used for all pixel\n+   * components.\n+   * \n+   * @param offset Offset to be subtracted.\n+   * @param numComponents Number of image components.\n+   * @exception IllegalArgumentException if offset < 0 or numComponents < 1.\n+   */\n+  protected LookupTable(int offset, int numComponents)\n+    throws IllegalArgumentException\n+  {\n+    if (offset < 0 || numComponents < 1)\n+      throw new IllegalArgumentException();\n+    this.offset = offset;\n+    this.numComponents = numComponents;\n+  }\n+\n+  /** Return the number of components. */\n+  public int getNumComponents()\n+  {\n+    return numComponents;\n+  }\n+\n+  /** Return the offset. */\n+  public int getOffset()\n+  {\n+    return offset;\n+  }\n+\n+  \n+  /**\n+   * Return translated values for a pixel.\n+   *\n+   * For each value in the pixel src, use the value minus offset as an index\n+   * in the component array and copy the value there to the output for the\n+   * component.  If dest is null, the output is a new array, otherwise the\n+   * translated values are written to dest.  Dest can be the same array as\n+   * src.\n+   *\n+   * For example, if the pixel src is [2, 4, 3], and offset is 1, the output\n+   * is [comp1[1], comp2[3], comp3[2]], where comp1, comp2, and comp3 are the\n+   * translation arrays.\n+   *\n+   * @param src Component values of a pixel.\n+   * @param dest Destination array for values, or null.\n+   * @return Translated values for the pixel.\n+   */\n+  public abstract int[] lookupPixel(int[] src, int[] dest);\n+}"}, {"sha": "ddd5800f14fafdbcc154159656226e65f03cb1a2", "filename": "libjava/java/awt/image/MemoryImageSource.java", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2Fimage%2FMemoryImageSource.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2Fimage%2FMemoryImageSource.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FMemoryImageSource.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -41,6 +41,7 @@\n import java.awt.Image;\n import java.util.Enumeration;\n import java.util.Hashtable;\n+import java.util.Vector;\n \n public class MemoryImageSource implements ImageProducer \n {\n@@ -49,7 +50,8 @@ public class MemoryImageSource implements ImageProducer\n     private int pixeli[], width, height, offset, scansize;\n     private byte pixelb[];\n     private ColorModel cm;\n-    private Hashtable props, consumers = new Hashtable();\n+    private Hashtable props = new Hashtable();\n+    private Vector consumers = new Vector();\n \n     /**\n        Constructs an ImageProducer from memory\n@@ -126,18 +128,18 @@ public MemoryImageSource(int w, int h,\n      * <code>ImageProducer</code>.  \n      */\n     public synchronized void addConsumer(ImageConsumer ic) {\n-\tif (consumers.containsKey(ic))\n+\tif (consumers.contains(ic))\n \t    return;\n \n-\tconsumers.put(ic, ic);\n+\tconsumers.addElement(ic);\n     }\n \n     /**\n      * Used to determine if the given <code>ImageConsumer</code> is\n      * already registered with this <code>ImageProducer</code>.  \n      */\n     public synchronized boolean isConsumer(ImageConsumer ic) {\n-\tif (consumers.containsKey(ic))\n+\tif (consumers.contains(ic))\n \t    return true;\n \treturn false;\n     }\n@@ -147,7 +149,7 @@ public synchronized boolean isConsumer(ImageConsumer ic) {\n      * registered consumers for this <code>ImageProducer</code>.  \n      */\n     public synchronized void removeConsumer(ImageConsumer ic) {\n-\tconsumers.remove(ic);\n+\tconsumers.removeElement(ic);\n     }\n \n     /**\n@@ -157,16 +159,16 @@ public synchronized void removeConsumer(ImageConsumer ic) {\n      * registered consumers.  \n      */\n     public void startProduction(ImageConsumer ic) {\n-\tif (!(consumers.containsKey(ic))) {\n-\t    consumers.put(ic, ic);\n+\tif (!(consumers.contains(ic))) {\n+\t    consumers.addElement(ic);\n \t}        \n-\tEnumeration e = consumers.elements();\n-\tfor( ; e.hasMoreElements(); ) {\n-\t\tic = (ImageConsumer)e.nextElement();\n+\n+\tVector list = (Vector) consumers.clone();\n+\tfor(int i = 0; i < list.size(); i++) {\n+\t    ic = (ImageConsumer) list.elementAt(i);\n \t\tsendPicture( ic );\n-\t\tic.imageComplete( ImageConsumer.SINGLEFRAME );\n+\t    ic.imageComplete( ImageConsumer.STATICIMAGEDONE );\n \t    }\t\n-\n     }\n \n     /**\n@@ -210,9 +212,9 @@ public void newPixels()\n     {\n \tif( animated == true ) {\n \t\tImageConsumer ic;\n-\t\tEnumeration e = consumers.elements();\n-\t\tfor( ; e.hasMoreElements(); ) {\n-\t\t\tic = (ImageConsumer)e.nextElement();\n+\t\tVector list = (Vector) consumers.clone();\n+\t\tfor(int i = 0; i < list.size(); i++) {\n+\t\t\tic = (ImageConsumer) list.elementAt(i);\n \t\t\tsendPicture( ic );\n \t\t\tic.imageComplete( ImageConsumer.SINGLEFRAME );\n \t\t    }\t\n@@ -227,6 +229,7 @@ private void sendPicture ( ImageConsumer ic )\n \t    ic.setProperties( props );\n \t}\n \tic.setDimensions(width, height);\n+\tic.setColorModel(cm);\n \tif( pixeli != null ) {\n \t    ic.setPixels( 0, 0, width, height, cm, pixeli, offset, scansize );\n \t} else {\n@@ -249,9 +252,9 @@ public synchronized void newPixels(int x,\n \t\t    newPixels();\n \t\t} else {\n \t\t    ImageConsumer ic;\n-\t\t    Enumeration e = consumers.elements();\n-\t\t    for( ; e.hasMoreElements(); ) {\n-\t\t\t    ic = (ImageConsumer)e.nextElement();\n+\t\t    Vector list = (Vector) consumers.clone();\n+\t\t    for(int i = 0; i < list.size(); i++) {\n+\t\t\t    ic = (ImageConsumer) list.elementAt(i);\n \t\t\t    ic.setHints( ImageConsumer.TOPDOWNLEFTRIGHT );\n \t\t\t    if( props != null ) {\n \t\t\t\tic.setProperties( props );\n@@ -294,9 +297,9 @@ public synchronized void newPixels(int x,\n \t\t    newPixels();\n \t\t} else {\n \t\t    ImageConsumer ic;\n-\t\t    Enumeration e = consumers.elements();\n-\t\t    for( ; e.hasMoreElements(); ) {\n-\t\t\t    ic = (ImageConsumer)e.nextElement();\n+\t\t    Vector list = (Vector) consumers.clone();\n+\t\t    for(int i = 0; i < list.size(); i++) {\n+\t\t\t    ic = (ImageConsumer) list.elementAt(i);\n \t\t\t    ic.setHints( ImageConsumer.TOPDOWNLEFTRIGHT );\n \t\t\t    if( props != null ) {\n \t\t\t\tic.setProperties( props );"}, {"sha": "819580e0057124c22b5ffb9a060592f56e5736b9", "filename": "libjava/java/awt/image/RGBImageFilter.java", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2Fimage%2FRGBImageFilter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2Fimage%2FRGBImageFilter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FRGBImageFilter.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -79,6 +79,10 @@ public void setColorModel(ColorModel model)\n \n \tif( ( model instanceof IndexColorModel) && canFilterIndexColorModel  ) {\n \t\tnewmodel = filterIndexColorModel( (IndexColorModel) model );\n+\t\tconsumer.setColorModel(newmodel);\n+\t    }\n+\telse {\n+\t\tconsumer.setColorModel(ColorModel.getRGBdefault());\n \t    }\n     }\n     "}, {"sha": "223d03bf53b9340a2455b198b46df12059e05871", "filename": "libjava/java/awt/image/ShortLookupTable.java", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2Fimage%2FShortLookupTable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjava%2Fawt%2Fimage%2FShortLookupTable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FShortLookupTable.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -0,0 +1,162 @@\n+/* ShortLookupTable.java -- Java class for a pixel translation table.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt.image;\n+\n+/**\n+ * ShortLookupTable represents translation arrays for pixel values.  It wraps\n+ * one or more data arrays for each layer (or component) in an image, such as\n+ * Alpha, R, G, and B.  When doing translation, the offset is subtracted from\n+ * the pixel values to allow a subset of an array to be used.\n+ *\n+ * @author <a href=\"mailto:jlquinn@optonline.net\">Jerry Quinn</a>\n+ * @version 1.0\n+ */\n+public class ShortLookupTable extends LookupTable\n+{\n+  // Array of translation tables.\n+  private short data[][];\n+\n+  /**\n+   * Creates a new <code>ShortLookupTable</code> instance.\n+   *\n+   * Offset is subtracted from pixel values when looking up in the translation\n+   * tables.  If data.length is one, the same table is applied to all pixel\n+   * components.\n+   * \n+   * @param offset Offset to be subtracted.\n+   * @param data Array of lookup tables.\n+   * @exception IllegalArgumentException if offset < 0 or data.length < 1.\n+   */\n+  public ShortLookupTable(int offset, short[][] data)\n+    throws IllegalArgumentException\n+  {\n+    super(offset, data.length);\n+    this.data = data;\n+  }\n+\n+  /**\n+   * Creates a new <code>ShortLookupTable</code> instance.\n+   *\n+   * Offset is subtracted from pixel values when looking up in the translation\n+   * table.  The same table is applied to all pixel components.\n+   * \n+   * @param offset Offset to be subtracted.\n+   * @param data Lookup table for all components.\n+   * @exception IllegalArgumentException if offset < 0.\n+   */\n+  public ShortLookupTable(int offset, short[] data)\n+    throws IllegalArgumentException\n+  {\n+    super(offset, 1);\n+    this.data = new short[][] {data};\n+  }\n+\n+  /** Return the lookup tables. */\n+  public final short[][] getTable()\n+  {\n+    return data;\n+  }\n+\n+  /**\n+   * Return translated values for a pixel.\n+   *\n+   * For each value in the pixel src, use the value minus offset as an index\n+   * in the component array and copy the value there to the output for the\n+   * component.  If dest is null, the output is a new array, otherwise the\n+   * translated values are written to dest.  Dest can be the same array as\n+   * src.\n+   *\n+   * For example, if the pixel src is [2, 4, 3], and offset is 1, the output\n+   * is [comp1[1], comp2[3], comp3[2]], where comp1, comp2, and comp3 are the\n+   * translation arrays.\n+   *\n+   * @param src Component values of a pixel.\n+   * @param dest Destination array for values, or null.\n+   * @return Translated values for the pixel.\n+   */\n+  public int[] lookupPixel(int[] src, int[] dst)\n+    throws ArrayIndexOutOfBoundsException\n+  {\n+    if (dst == null)\n+      dst = new int[numComponents];\n+\n+    if (data.length == 1)\n+      for (int i=0; i < src.length; i++)\n+\tdst[i] = data[0][src[i] - offset];\n+    else\n+      for (int i=0; i < src.length; i++)\n+\tdst[i] = data[i][src[i] - offset];\n+      \n+    return dst;\n+  }\n+\n+  /**\n+   * Return translated values for a pixel.\n+   *\n+   * For each value in the pixel src, use the value minus offset as an index\n+   * in the component array and copy the value there to the output for the\n+   * component.  If dest is null, the output is a new array, otherwise the\n+   * translated values are written to dest.  Dest can be the same array as\n+   * src.\n+   *\n+   * For example, if the pixel src is [2, 4, 3], and offset is 1, the output\n+   * is [comp1[1], comp2[3], comp3[2]], where comp1, comp2, and comp3 are the\n+   * translation arrays.\n+   *\n+   * @param src Component values of a pixel.\n+   * @param dest Destination array for values, or null.\n+   * @return Translated values for the pixel.\n+   */\n+  public short[] lookupPixel(short[] src, short[] dst)\n+    throws ArrayIndexOutOfBoundsException\n+  {\n+    if (dst == null)\n+      dst = new short[numComponents];\n+\n+    if (data.length == 1)\n+      for (int i=0; i < src.length; i++)\n+\tdst[i] = data[0][((int)src[i]) - offset];\n+    else\n+      for (int i=0; i < src.length; i++)\n+\tdst[i] = data[i][((int)src[i]) - offset];\n+      \n+    return dst;\n+\n+  }\n+}"}, {"sha": "3c2a4cdea7bc6f57632bb30ce0a9b89cff4d302a", "filename": "libjava/javax/swing/AbstractButton.java", "status": "modified", "additions": 133, "deletions": 83, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FAbstractButton.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FAbstractButton.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FAbstractButton.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -163,46 +163,52 @@ public abstract class AbstractButton extends JComponent\n   Icon pressed_icon;\n \n   /** The icon displayed when the button is disabled. */\n-  Icon disabled_icon;\n+  Icon disabeldIcon;\n \n   /** The icon displayed when the button is selected. */\n-  Icon selected_icon;\n+  Icon selectedIcon;\n \n   /** The icon displayed when the button is selected but disabled. */\n-  Icon disabled_selected_icon;\n+  Icon disabledSelectedIcon;\n \n   /** The icon displayed when the button is rolled over. */\n-  Icon rollover_icon;\n+  Icon rolloverIcon;\n \n   /** The icon displayed when the button is selected and rolled over. */\n-  Icon rollover_selected_icon;\n+  Icon rolloverSelectedIcon;\n \n   /** The icon currently displayed. */\n   Icon current_icon;\n \n   /** The text displayed in the button. */\n   String text;\n \n+  /** The gap between icon and text, if both icon and text are non-<code>null</code>. */\n+  int iconTextGap;\n+\n   /** The vertical alignment of the button's text and icon. */\n-  int vert_align;\n+  int verticalAlignment;\n \n   /** The horizontal alignment of the button's text and icon. */\n-  int hori_align;\n+  int horizontalAlignment;\n \n   /** The horizontal position of the button's text relative to its icon. */\n-  int hori_text_pos;\n+  int horizontalTextPosition;\n \n   /** The vertical position of the button's text relative to its icon. */\n-  int vert_text_pos;\n+  int verticalTextPosition;\n \n   /** Whether or not the button paints its border. */\n-  boolean paint_border;\n+  boolean borderPainted;\n \n   /** Whether or not the button paints its focus state. */\n-  boolean paint_focus;\n+  boolean focusPainted;\n \n   /** Whether or not the button fills its content area. */\n-  boolean content_area_filled;\n+  boolean contentAreaFilled;\n+  \n+  /** Whether rollover is enabled. */\n+  boolean rollOverEnabled;\n \n   /** The action taken when the button is clicked. */\n   Action action;\n@@ -230,6 +236,9 @@ public abstract class AbstractButton extends JComponent\n       Action. */\n   PropertyChangeListener actionPropertyChangeListener;\n   \n+  /** ChangeEvent that is fired to button's ChangeEventListeners  */  \n+  private ChangeEvent changeEvent = new ChangeEvent(this);\n+  \n   /** Fired in a PropertyChangeEvent when the \"borderPainted\" property changes. */\n   public static final String BORDER_PAINTED_CHANGED_PROPERTY = \"borderPainted\";\n   \n@@ -533,17 +542,20 @@ protected void init(String text, Icon icon)\n     model.addChangeListener(changeListener);\n     model.addItemListener(itemListener);\n \n-    hori_align = CENTER;\n-    hori_text_pos = TRAILING;\n-    vert_align = CENTER;\n-    vert_text_pos = CENTER;\n-    paint_border = true;\n-    content_area_filled = true;\n+    horizontalAlignment = CENTER;\n+    horizontalTextPosition = TRAILING;\n+    verticalAlignment = CENTER;\n+    verticalTextPosition = CENTER;\n+    borderPainted = true;\n+    contentAreaFilled = true;\n+\n+    iconTextGap = 4;\n \n     setAlignmentX(LEFT_ALIGNMENT);\n     setAlignmentY(CENTER_ALIGNMENT);\n \n     addFocusListener(new ButtonFocusListener());\n+    setDisplayedMnemonicIndex(-1);    \n  }\n  \n   /**\n@@ -642,6 +654,7 @@ public void removeChangeListener(ChangeListener l)\n    */\n   public void fireItemStateChanged(ItemEvent e)\n   {\n+    e.setSource(this);\n     EventListener[] ll = listenerList.getListeners(ItemListener.class);\n     for (int i = 0; i < ll.length; i++)\n       ((ItemListener)ll[i]).itemStateChanged(e);\n@@ -655,6 +668,7 @@ public void fireItemStateChanged(ItemEvent e)\n    */\n   public void fireActionPerformed(ActionEvent e)\n   {\n+    e.setSource(this);\n     EventListener[] ll = listenerList.getListeners(ActionListener.class);\n     for (int i = 0; i < ll.length; i++)\n       ((ActionListener)ll[i]).actionPerformed(e);\n@@ -671,7 +685,7 @@ public void fireStateChanged(ChangeEvent e)\n   {\n     EventListener[] ll = listenerList.getListeners(ChangeListener.class);\n     for (int i = 0; i < ll.length; i++)\n-      ((ChangeListener)ll[i]).stateChanged(e);\n+      ((ChangeListener)ll[i]).stateChanged(changeEvent);\n   }\n \n   /**\n@@ -699,14 +713,7 @@ public int getMnemonic()\n    */\n   public void setMnemonic(char mne)\n   {\n-    int old = getModel().getMnemonic();\n-    getModel().setMnemonic(mne);\n-    if (old != getModel().getMnemonic())\n-      {\n-        firePropertyChange(MNEMONIC_CHANGED_PROPERTY, old, (int) mne);        \n-        revalidate();\n-        repaint();\n-      }\n+    setMnemonic((int) mne);\n   }\n \n   /**\n@@ -720,10 +727,23 @@ public void setMnemonic(char mne)\n    */\n   public void setMnemonic(int mne)\n   {\n-    int old = mne;\n+    int old = getModel().getMnemonic();\n+\n+    if (old != mne)\n+      {\n     getModel().setMnemonic(mne);\n-    if (old != getModel().getMnemonic())\n+\n+\tif (text != null && ! text.equals(\"\"))\n       {\n+\t    // Since lower case char = upper case char for \n+\t    // mnemonic, we will convert both text and mnemonic \n+\t    // to upper case before checking if mnemonic character occurs\n+\t    // in the menu item text. \n+\t    int upperCaseMne = Character.toUpperCase((char) mne);\n+\t    String upperCaseText = text.toUpperCase();\n+\t    setDisplayedMnemonicIndex(upperCaseText.indexOf(upperCaseMne));\n+\t  }\n+\n         firePropertyChange(MNEMONIC_CHANGED_PROPERTY, old, mne);\n         revalidate();\n         repaint();\n@@ -748,7 +768,7 @@ public void setMnemonic(int mne)\n \n   public void setDisplayedMnemonicIndex(int index)\n   {\n-    if (index < -1 || index >= text.length())\n+    if (index < -1 || (text != null && index >= text.length()))\n       throw new IllegalArgumentException();\n     else\n       mnemonicIndex = index;\n@@ -761,7 +781,7 @@ public void setDisplayedMnemonicIndex(int index)\n    *\n    * @return An index into the button's \"text\" property\n    */\n-  public int getDisplayedMnemonicIndex(int index)\n+  public int getDisplayedMnemonicIndex()\n   {\n     return mnemonicIndex;\n   }\n@@ -770,17 +790,16 @@ public int getDisplayedMnemonicIndex(int index)\n   /**\n    * Set the \"rolloverEnabled\" property. When rollover is enabled, and the\n    * look and feel supports it, the button will change its icon to\n-   * rollover_icon, when the mouse passes over it.\n+   * rolloverIcon, when the mouse passes over it.\n    *\n    * @param r Whether or not to enable rollover icon changes\n    */\n   public void setRolloverEnabled(boolean r)\n   {\n-    boolean old = getModel().isRollover();\n-    getModel().setRollover(r);\n-    if (old != getModel().isRollover())\n+    if (rollOverEnabled != r)\n   {\n-        firePropertyChange(ROLLOVER_ENABLED_CHANGED_PROPERTY, old, r);\n+        rollOverEnabled = r;\n+        firePropertyChange(ROLLOVER_ENABLED_CHANGED_PROPERTY, !r, r);\n         revalidate();\n         repaint();\n       }\n@@ -794,7 +813,7 @@ public void setRolloverEnabled(boolean r)\n    */\n   public boolean isRolloverEnabled()\n   {\n-    return getModel().isRollover();\n+    return rollOverEnabled;\n   }\n \n   /**\n@@ -842,7 +861,7 @@ public void setEnabled(boolean b)\n    */\n   public int getHorizontalAlignment()\n   {\n-    return hori_align;\n+    return horizontalAlignment;\n   }\n \n   /**\n@@ -858,8 +877,8 @@ public int getHorizontalAlignment()\n    */\n   public void setHorizontalAlignment(int a)\n   {\n-    int old = hori_align;\n-    hori_align = a;\n+    int old = horizontalAlignment;\n+    horizontalAlignment = a;\n     if (old != a)\n       {\n         firePropertyChange(HORIZONTAL_ALIGNMENT_CHANGED_PROPERTY, old, a);\n@@ -879,7 +898,7 @@ public void setHorizontalAlignment(int a)\n    */\n   public int getHorizontalTextPosition()\n   {\n-    return hori_text_pos;\n+    return horizontalTextPosition;\n   }\n \n   /**\n@@ -895,8 +914,8 @@ public int getHorizontalTextPosition()\n    */\n   public void setHorizontalTextPosition(int t)\n   {\n-    int old = hori_text_pos;\n-    hori_text_pos = t;\n+    int old = horizontalTextPosition;\n+    horizontalTextPosition = t;\n     if (old != t)\n       {\n         firePropertyChange(HORIZONTAL_TEXT_POSITION_CHANGED_PROPERTY, old, t);\n@@ -915,7 +934,7 @@ public void setHorizontalTextPosition(int t)\n    */\n   public int getVerticalAlignment()\n   {\n-    return vert_align;\n+    return verticalAlignment;\n   }\n \n   /**\n@@ -930,8 +949,8 @@ public int getVerticalAlignment()\n    */\n   public void setVerticalAlignment(int a)\n   {\n-    int old = vert_align;\n-    vert_align = a;\n+    int old = verticalAlignment;\n+    verticalAlignment = a;\n     if (old != a)\n       {\n         firePropertyChange(VERTICAL_ALIGNMENT_CHANGED_PROPERTY, old, a);\n@@ -951,7 +970,7 @@ public void setVerticalAlignment(int a)\n    */\n   public int getVerticalTextPosition()\n   {\n-    return vert_text_pos;\n+    return verticalTextPosition;\n   }\n \n   /**\n@@ -967,8 +986,8 @@ public int getVerticalTextPosition()\n    */\n   public void setVerticalTextPosition(int t)\n   {\n-    int old = vert_text_pos;\n-    vert_text_pos = t;\n+    int old = verticalTextPosition;\n+    verticalTextPosition = t;\n     if (old != t)\n       {\n         firePropertyChange(VERTICAL_TEXT_POSITION_CHANGED_PROPERTY, old, t);\n@@ -986,7 +1005,7 @@ public void setVerticalTextPosition(int t)\n    */\n   public boolean isBorderPainted()\n   {\n-    return paint_border;\n+    return borderPainted;\n   }\n \n   /**\n@@ -998,8 +1017,8 @@ public boolean isBorderPainted()\n    */\n   public void setBorderPainted(boolean b)\n   {\n-    boolean old = paint_border;\n-        paint_border = b;\n+    boolean old = borderPainted;\n+        borderPainted = b;\n     if (b != old)\n       {\n         firePropertyChange(BORDER_PAINTED_CHANGED_PROPERTY, old, b);\n@@ -1139,6 +1158,33 @@ public void setText(String t)\n   }\n   }\n \n+  /**\n+   * Set the value of the {@link #iconTextGap} property.\n+   * \n+   * @param i The new value of the property\n+   */\n+  public void setIconTextGap(int i)\n+  {\n+    int old = iconTextGap;\n+    iconTextGap = i;\n+    if (old != i)\n+      {\n+        fireStateChanged(new ChangeEvent(this));\n+        revalidate();\n+        repaint();\n+      }\n+  }\n+\n+  /**\n+   * Get the value of the {@link #iconTextGap} property.\n+   *\n+   * @return The current value of the property\n+   */\n+  public int getIconTextGap()\n+  {\n+    return iconTextGap;\n+  }\n+\n   /**\n    * Return the button's \"margin\" property, which is an {@link Insets} object\n    * describing the distance between the button's border and its text and\n@@ -1214,11 +1260,11 @@ public void setPressedIcon(Icon pressedIcon)\n    */\n   public Icon getDisabledIcon()\n   {\n-    if (disabled_icon == null\n+    if (disabeldIcon == null\n \t&& default_icon instanceof ImageIcon)\n-      disabled_icon = new ImageIcon(GrayFilter.createDisabledImage(((ImageIcon) default_icon).getImage()));\n+      disabeldIcon = new ImageIcon(GrayFilter.createDisabledImage(((ImageIcon) default_icon).getImage()));\n       \n-    return disabled_icon;\n+    return disabeldIcon;\n   }\n \n   /**\n@@ -1230,9 +1276,9 @@ public Icon getDisabledIcon()\n    *\n    * @param disabledIcon The new \"disabledIcon\" property\n    */\n-  public void setDisabledIcon(Icon disabledIcon)\n+  public void setDisabledIcon(Icon d)\n   {\n-    disabled_icon = disabledIcon;\n+    disabeldIcon = d;\n     revalidate();\n     repaint();\n   }\n@@ -1248,7 +1294,7 @@ public void setDisabledIcon(Icon disabledIcon)\n    */\n   public boolean isFocusPainted()\n   {\n-    return paint_focus;\n+    return focusPainted;\n   }\n \n   /**\n@@ -1260,14 +1306,14 @@ public boolean isFocusPainted()\n    *\n    * @param b The new \"paintFocus\" property\n    */\n-  public void setFocusPainted(boolean b)\n+  public void setFocusPainted(boolean p)\n   {\n-    boolean old = paint_focus;\n-    paint_focus = b;\n+    boolean old = focusPainted;\n+    focusPainted = p;\n \n-    if (old != b)\n+    if (old != focusPainted)\n       {\n-        firePropertyChange(FOCUS_PAINTED_CHANGED_PROPERTY, old, b);\n+        firePropertyChange(FOCUS_PAINTED_CHANGED_PROPERTY, old, p);\n         revalidate();\n         repaint();\n       }\n@@ -1391,7 +1437,13 @@ protected  void configurePropertiesFromAction(Action a)\n         setToolTipText((String)(a.getValue(Action.SHORT_DESCRIPTION)));\n \tif (a.getValue(Action.MNEMONIC_KEY) != null)\n           setMnemonic(((Integer)(a.getValue(Action.MNEMONIC_KEY))).intValue());\n+        String actionCommand = (String)(a.getValue(Action.ACTION_COMMAND_KEY));\n+\n+        // Set actionCommand to button's text by default if it is not specified\n+        if (actionCommand != null)\n         setActionCommand((String)(a.getValue(Action.ACTION_COMMAND_KEY)));\n+\t else\n+\t   setActionCommand(getText());\n       }\n   }\n \n@@ -1416,7 +1468,6 @@ protected  ActionListener createActionListener()\n       {\n         public void actionPerformed(ActionEvent e)\n         {\n-          e.setSource(AbstractButton.this);\n           AbstractButton.this.fireActionPerformed(e);\n         }\n       };\n@@ -1489,7 +1540,6 @@ protected  ChangeListener createChangeListener()\n         public void stateChanged(ChangeEvent e)\n         {\n           AbstractButton.this.fireStateChanged(e);\n-          AbstractButton.this.revalidate();\n           AbstractButton.this.repaint();          \n         }\n       };\n@@ -1569,7 +1619,7 @@ public void doClick(int pressTime)\n    */\n   public Icon getDisabledSelectedIcon()\n   {\n-    return disabled_selected_icon;\n+    return disabledSelectedIcon;\n   }\n \n   /**\n@@ -1583,8 +1633,8 @@ public Icon getDisabledSelectedIcon()\n    */\n   public void setDisabledSelectedIcon(Icon disabledSelectedIcon)\n   {\n-    Icon old = disabled_selected_icon;\n-    disabled_selected_icon = disabledSelectedIcon;\n+    Icon old = disabledSelectedIcon;\n+    disabledSelectedIcon = disabledSelectedIcon;\n     if (old != disabledSelectedIcon)\n   {\n         firePropertyChange(DISABLED_SELECTED_ICON_CHANGED_PROPERTY, old, \n@@ -1604,7 +1654,7 @@ public void setDisabledSelectedIcon(Icon disabledSelectedIcon)\n    */\n   public Icon getRolloverIcon()\n   {\n-    return rollover_icon;\n+    return rolloverIcon;\n   }\n \n   /**\n@@ -1614,10 +1664,10 @@ public Icon getRolloverIcon()\n    *\n    * @param rolloverIcon The new rollover icon\n    */\n-  public void setRolloverIcon(Icon rolloverIcon)\n+  public void setRolloverIcon(Icon r)\n   {\n-    Icon old = rollover_icon;\n-    rollover_icon = rolloverIcon;\n+    Icon old = rolloverIcon;\n+    rolloverIcon = r;\n     if (old != rolloverIcon)\n   {\n         firePropertyChange(ROLLOVER_ICON_CHANGED_PROPERTY, old, \n@@ -1637,7 +1687,7 @@ public void setRolloverIcon(Icon rolloverIcon)\n    */\n   public Icon getRolloverSelectedIcon()\n   {\n-    return rollover_selected_icon;\n+    return rolloverSelectedIcon;\n   }\n \n   /**\n@@ -1648,10 +1698,10 @@ public Icon getRolloverSelectedIcon()\n    *\n    * @param rolloverSelectedIcon The new rollover selected icon\n    */\n-  public void setRolloverSelectedIcon(Icon rolloverSelectedIcon)\n+  public void setRolloverSelectedIcon(Icon r)\n   {\n-    Icon old = rollover_selected_icon;\n-    rollover_selected_icon = rolloverSelectedIcon;\n+    Icon old = rolloverSelectedIcon;\n+    rolloverSelectedIcon = r;\n     if (old != rolloverSelectedIcon)\n   {\n         firePropertyChange(ROLLOVER_SELECTED_ICON_CHANGED_PROPERTY, old, \n@@ -1673,7 +1723,7 @@ public void setRolloverSelectedIcon(Icon rolloverSelectedIcon)\n    */\n   public Icon getSelectedIcon()\n   {\n-    return selected_icon;\n+    return selectedIcon;\n   }\n \n   /**\n@@ -1685,10 +1735,10 @@ public Icon getSelectedIcon()\n    *\n    * @param selectedIcon The new selected icon\n    */\n-  public void setSelectedIcon(Icon selectedIcon)\n+  public void setSelectedIcon(Icon s)\n   {\n-    Icon old = selected_icon;\n-    selected_icon = selectedIcon;\n+    Icon old = selectedIcon;\n+    selectedIcon = s;\n     if (old != selectedIcon)\n     {\n         firePropertyChange(SELECTED_ICON_CHANGED_PROPERTY, old, \n@@ -1750,7 +1800,7 @@ public boolean imageUpdate(Image img, int infoflags, int x, int y, int w,\n    */\n   public boolean isContentAreaFilled()\n             {\n-    return content_area_filled;\n+    return contentAreaFilled;\n             }\n \n   /**\n@@ -1764,8 +1814,8 @@ public boolean isContentAreaFilled()\n    */\n   public void setContentAreaFilled(boolean b)\n             {\n-    boolean old = content_area_filled;\n-    content_area_filled = b;\n+    boolean old = contentAreaFilled;\n+    contentAreaFilled = b;\n     if (b != old)\n       {\n         firePropertyChange(CONTENT_AREA_FILLED_CHANGED_PROPERTY, old, b);"}, {"sha": "2a5c67aa4d35e4c8c15f2458a086dc5528a41db9", "filename": "libjava/javax/swing/ActionMap.java", "status": "modified", "additions": 94, "deletions": 121, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FActionMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FActionMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FActionMap.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -48,18 +48,15 @@\n import java.util.Map;\n import java.util.Set;\n \n+\n /**\n- * ActionMap\n  * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * @author Michael Koch\n  */\n-public class ActionMap implements Serializable\n+public class ActionMap\n+  implements Serializable\n {\n-  static final long serialVersionUID = -6277518704513986346L;\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n+  private static final long serialVersionUID = -6277518704513986346L;\n \n \t/**\n \t * actionMap\n@@ -69,170 +66,146 @@ public class ActionMap implements Serializable\n \t/**\n \t * parent\n \t */\n-\tprivate ActionMap parent = null;\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n+  private ActionMap parent;\n \n \t/**\n-\t * Constructor ActionMap\n+   * Creates a new <code>ActionMap</code> instance.\n \t */\n-\tpublic ActionMap() {\n-\t} // ActionMap()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n+  public ActionMap()\n+  {\n+  }\n \n \t/**\n-\t * get\n-\t * @param key TODO\n-\t * @returns Action\n+   * Returns an action associated with an object.\n+   *\n+   * @param key the key of the enty\n+   *\n+   * @return the action associated with key, may be null\n \t */\n-\tpublic Action get(Object key) {\n+  public Action get(Object key)\n+  {\n+    Object result = actionMap.get(key);\n \n-\t\t// Variables\n-\t\tObject\tresult;\n-\n-\t\t// Check Local store\n-\t\tresult = actionMap.get(key);\n-\n-\t\t// Check Parent\n-\t\tif (result == null) {\n+    if (result == null)\n \t\t\tresult = parent.get(key);\n-\t\t} // if\n \n \t\treturn (Action) result;\n-\n-\t} // get()\n+  }\n \n \t/**\n-\t * put\n-\t * @param key TODO\n-\t * @param action TODO\n+   * Puts a new <code>Action</code> into the <code>ActionMap</code>.\n+   * If action is null an existing entry will be removed.\n+   *\n+   * @param key the key for the entry\n+   * @param action the action.\n \t */\n-\tpublic void put(Object key, Action action) {\n-\t\tif (action == null) {\n+  public void put(Object key, Action action)\n+  {\n+    if (action == null)\n \t\t\tactionMap.remove(key);\n-\t\t} else {\n+    else\n \t\t\tactionMap.put(key, action);\n-\t\t} // if\n-\t} // put()\n+  }\n \n \t/**\n-\t * remove\n-\t * @param key TODO\n+   * Remove an entry from the <code>ActionMap</code>.\n+   *\n+   * @param key the key of the entry to remove\n \t */\n-\tpublic void remove(Object key) {\n+  public void remove(Object key)\n+  {\n \t\tactionMap.remove(key);\n-\t} // remove()\n+  }\n \n \t/**\n-\t * getParent\n-\t * @returns ActionMap\n+   * Returns the parent of this <code>ActionMap</code>.\n+   *\n+   * @return the parent, may be null.\n \t */\n-\tpublic ActionMap getParent() {\n+  public ActionMap getParent()\n+  {\n \t\treturn parent;\n-\t} // getParent()\n+  }\n \n \t/**\n-\t * setParent\n-\t * @param parentMap TODO\n+   * Sets a parent for this <code>ActionMap</code>.\n+   *\n+   * @param parentMap the new parent\n \t */\n-\tpublic void setParent(ActionMap parentMap) {\n+  public void setParent(ActionMap parentMap)\n+  {\n \t\tparent = parentMap;\n-\t} // setParent()\n+  }\n \n \t/**\n-\t * size\n-\t * @returns int\n+   * Returns the number of entries in this <code>ActionMap</code>.\n+   *\n+   * @return the number of entries\n \t */\n-\tpublic int size() {\n+  public int size()\n+  {\n \t\treturn actionMap.size();\n-\t} // size()\n+  }\n \n \t/**\n-\t * clear\n+   * Clears the <code>ActionMap</code>.\n \t */\n-\tpublic void clear() {\n+  public void clear()\n+  {\n \t\tactionMap.clear();\n-\t} // clear()\n+  }\n \n \t/**\n-\t * keys\n-\t * @returns Object[]\n+   * Returns all keys of entries in this <code>ActionMap</code>.\n+   *\n+   * @return an array of keys\n \t */\n-\tpublic Object[] keys() {\n-\t\treturn convertSet(actionMap.keySet());\n-\t} // keys()\n+  public Object[] keys()\n+  {\n+    return actionMap.keySet().toArray();\n+  }\n \n \t/**\n-\t * allKeys\n-\t * @returns Object[]\n+   * Returns all keys of entries in this <code>ActionMap</code>\n+   * and all its parents.\n+   *\n+   * @return an array of keys\n \t */\n-\tpublic Object[] allKeys() {\n-\n-\t\t// Variables\n-\t\tSet\t\t\tset;\n-\n-\t\t// Initialize\n-\t\tset = new HashSet();\n+  public Object[] allKeys()\n+  {\n+    Set set = new HashSet();\n \n-\t\t// Get Key Sets\n-\t\tif (parent != null) {\n+    if (parent != null)\n \t\t\tset.addAll(Arrays.asList(parent.allKeys()));\n-\t\t} // if\n-\t\tset.addAll(actionMap.keySet());\n \n-\t\treturn convertSet(set);\n-\n-\t} // allKeys()\n-\n-\tprivate Object[] convertSet(Set set) {\n-\n-\t\t// Variables\n-\t\tint\t\t\tindex;\n-\t\tIterator\titerator;\n-\t\tObject[]\tkeys;\n-\n-\t\t// Create Final array\n-\t\tkeys = new Object[set.size()];\n-\t\titerator = set.iterator();\n-\t\tindex = 0;\n-\t\twhile (iterator.hasNext()) {\n-\t\t\tkeys[index++] = iterator.next();\n-\t\t} // while\n-\n-\t\treturn keys;\n-\n-\t} // convertSet()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Interface: Serializable ------------------------------------\n-\t//-------------------------------------------------------------\n+    set.addAll(actionMap.keySet());\n+    return set.toArray();\n+  }\n \n \t/**\n \t * writeObject\n-\t * @param stream TODO\n-\t * @exception IOException TODO\n+   *\n+   * @param stream the stream to write to\n+   *\n+   * @exception IOException If an error occurs\n \t */\n-\tprivate void writeObject(ObjectOutputStream value0) throws IOException {\n+  private void writeObject(ObjectOutputStream stream)\n+    throws IOException\n+  {\n \t\t// TODO\n-\t} // writeObject()\n+  }\n \n \t/**\n \t * readObject\n-\t * @param stream TODO\n-\t * @exception ClassNotFoundException TODO\n-\t * @exception IOException TODO\n+   *\n+   * @param stream the stream to read from\n+   *\n+   * @exception ClassNotFoundException If the serialized class cannot be found\n+   * @exception IOException If an error occurs\n \t */\n-\tprivate void readObject(ObjectInputStream value0) throws ClassNotFoundException, IOException {\n+  private void readObject(ObjectInputStream stream)\n+    throws ClassNotFoundException, IOException\n+  {\n \t\t// TODO\n-\t} // readObject()\n-\n-\n-} // ActionMap\n+  }\n+}"}, {"sha": "84110c5f0f248202f61b6895df62f07e4c5f2c00", "filename": "libjava/javax/swing/ComponentInputMap.java", "status": "modified", "additions": 84, "deletions": 69, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FComponentInputMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FComponentInputMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FComponentInputMap.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -1,5 +1,5 @@\n /* ComponentInputMap.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,79 +37,94 @@\n \n package javax.swing;\n \n+\n /**\n- * ComponentInputMap\n  * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * @author Michael Koch\n  */\n-public class ComponentInputMap extends InputMap {\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n+public class ComponentInputMap extends InputMap\n+{\n \t/**\n-\t * component\n+   * The component to notify.\n \t */\n \tprivate JComponent component;\n \n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor ComponentInputMap\n-\t * @param value0 TODO\n-\t */\n-\tpublic ComponentInputMap(JComponent value0) {\n-\t\t// TODO\n-\t} // ComponentInputMap()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * put\n-\t * @param keystroke TODO\n-\t * @param value TODO\n-\t */\n-\tpublic void put(KeyStroke keystroke, Object value) {\n-\t\t// TODO\n-\t} // put()\n-\n \t/**\n-\t * clear\n-\t */\n-\tpublic void clear() {\n-\t\t// TODO\n-\t} // clear()\n-\n-\t/**\n-\t * remove\n-\t * @param keystroke TODO\n-\t */\n-\tpublic void remove(KeyStroke keystroke) {\n-\t\t// TODO\n-\t} // remove()\n-\n-\t/**\n-\t * setParent\n-\t * @param parent TODO\n-\t */\n-\tpublic void setParent(InputMap parent) {\n-\t\t// TODO\n-\t} // setParent()\n-\n-\t/**\n-\t * getComponent\n-\t * @returns JComponent\n-\t */\n-\tpublic JComponent getComponent() {\n-\t\treturn null; // TODO\n-\t} // getComponent()\n-\n-\n-} // ComponentInputMap\n+   * Creates <code>ComponentInputMap</code> object that notifies the given\n+   * component about changes to it.\n+   *\n+   * @param comp the component to notify\n+   *\n+   * @exception IllegalArgumentException if comp is null\n+   */\n+  public ComponentInputMap(JComponent comp)\n+  {\n+    if (comp == null)\n+      throw new IllegalArgumentException();\n+    \n+    this.component = comp;\n+  }\n+\n+  /**\n+   * Puts a new entry into the <code>InputMap</code>.\n+   * If actionMapKey is null an existing entry will be removed.\n+   *\n+   * @param keystroke the keystroke for the entry\n+   * @param actionMapKey the action.\n+   */\n+  public void put(KeyStroke keystroke, Object value)\n+  {\n+    super.put(keystroke, value);\n+    // FIXME: Notify component.\n+  }\n+\n+  /**\n+   * Clears the <code>InputMap</code>.\n+   */\n+  public void clear()\n+  {\n+    super.clear();\n+    // FIXME: Notify component.\n+  }\n+\n+  /**\n+   * Remove an entry from the <code>InputMap</code>.\n+   *\n+   * @param key the key of the entry to remove\n+   */\n+  public void remove(KeyStroke keystroke)\n+  {\n+    super.remove(keystroke);\n+    // FIXME: Notify component.\n+  }\n+\n+  /**\n+   * Sets a parent for this <code>ComponentInputMap</code>.\n+   *\n+   * @param parentMap the new parent\n+   *\n+   * @exception IllegalArgument if parentMap is not a\n+   * <code>ComponentInputMap</code> or not associated with the same component\n+   */\n+  public void setParent(InputMap parentMap)\n+  {\n+    if (! (parentMap instanceof ComponentInputMap))\n+      throw new IllegalArgumentException();\n+\n+    if (((ComponentInputMap) parentMap).getComponent() != component)\n+      throw new IllegalArgumentException();\n+   \n+    super.setParent(parentMap);\n+    // FIXME: Notify component.\n+  }\n+\n+  /**\n+   * Returns the component to notify about changes.\n+   *\n+   * @return a <code>JComponent</code> object\n+   */\n+  public JComponent getComponent()\n+  {\n+    return component;\n+  }\n+}"}, {"sha": "6678c931c6e7177df9f53d88ee74c0edfcebcc2d", "filename": "libjava/javax/swing/DefaultDesktopManager.java", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FDefaultDesktopManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FDefaultDesktopManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FDefaultDesktopManager.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -436,7 +436,6 @@ public void resizeFrame(JComponent component, int newX, int newY,\n                           int newWidth, int newHeight)\n   {\n     dragCache.setBounds(newX, newY, newWidth, newHeight);\n-    dragCache = findMinimum(dragCache, component);\n \n     if (currentDragMode == JDesktopPane.OUTLINE_DRAG_MODE)\n       {\n@@ -628,27 +627,4 @@ protected boolean wasIcon(JInternalFrame frame)\n   {\n     return frame.getWasIcon();\n   } // wasIcon()\n-\n-  /**\n-   * This is a helper method that determines the minimum size a \n-   * JInternalFrame can be resized to.\n-   *\n-   * @param r The desired size.\n-   * @param c The JComponent to find a minimum size for.\n-   *\n-   * @return The minimum size a JInternalFrame can be resized to.\n-   */\n-  private Rectangle findMinimum(Rectangle r, JComponent c)\n-  {\n-    if (r != null && c != null)\n-      {\n-\tDimension d = c.getPreferredSize();\n-\tif (d != null)\n-\t  {\n-\t    r.width = Math.max(d.width, r.width);\n-\t    r.height = Math.max(d.height, r.height);\n-\t  }\n-      }\n-    return r;\n-  }\n } // DefaultDesktopManager"}, {"sha": "c0e8e0d3117ad09314e173f2579f01a62b5abb91", "filename": "libjava/javax/swing/ImageIcon.java", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FImageIcon.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FImageIcon.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FImageIcon.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -41,6 +41,7 @@\n import java.awt.Graphics;\n import java.awt.Image;\n import java.awt.Toolkit;\n+import java.awt.image.ImageObserver;\n import java.io.Serializable;\n import java.net.URL;\n \n@@ -50,42 +51,62 @@\n {\n   private static final long serialVersionUID = 532615968316031794L;\n   Image image;\n-  String file;\n-  String descr;\n-  Component observer;\n+  String description;\n+  ImageObserver observer;\n \n-  public ImageIcon(String s)\n+  public ImageIcon()\n   {\n-    // if description is not specified, then file name becomes\n-    // desciption for this icon\n-    this(s, s);\n   }\n \n-  public ImageIcon(Image image)\n+  public ImageIcon(String file)\n+  {\n+    this(file, file);\n+  }\n+\n+  public ImageIcon(String file, String description)\n+  {\n+    this(Toolkit.getDefaultToolkit().getImage(file), description);\n+  }\n+\n+  public ImageIcon(byte[] imageData)\n+  {\n+    this(imageData, null);\n+  }\n+  \n+  public ImageIcon(byte[] imageData, String description)\n   {\n+    this(Toolkit.getDefaultToolkit().createImage(imageData), description);\n   }\n \n   public ImageIcon(URL url)\n   {\n-    image = Toolkit.getDefaultToolkit().getImage(url);\n+    this(url, null);\n   }\n \n-  public ImageIcon(String file, String descr)\n+  public ImageIcon(URL url, String description)\n   {\n-    this.file = file;\n-    this.descr = descr;\n+    this(Toolkit.getDefaultToolkit().getImage(url), description);\n+  }\n+\n+  public ImageIcon(Image image)\n+  {\n+    this(image, null);\n+  }\n \n-    image = Toolkit.getDefaultToolkit().getImage(file);\n-    if (image == null)\n-      return;\n+  public ImageIcon(Image image, String description)\n+  {\n+    this.image = Toolkit.getDefaultToolkit().createImage(image.getSource());\n+    this.description = description;\n+  }\n \n-    //loadImage(image);\n+  public ImageObserver getImageObserver()\n+  {\n+    return observer;\n   }\n \n-  // not in SUN's spec !!!\n-  public void setParent(Component p)\n+  public void setImageObserver(ImageObserver newObserver)\n   {\n-    observer = p;\n+    observer = newObserver;\n   }\n \n   public Image getImage()\n@@ -95,12 +116,12 @@ public Image getImage()\n \n   public String getDescription()\n   {\n-    return descr;\n+    return description;\n   }\n \n   public void setDescription(String description)\n   {\n-    this.descr = description;\n+    this.description = description;\n   }\n \n   public int getIconHeight()\n@@ -115,6 +136,6 @@ public int getIconWidth()\n \n   public void paintIcon(Component c, Graphics g, int x, int y)\n   {\n-    g.drawImage(image, x, y, observer);\n+    g.drawImage(image, x, y, observer != null ? observer : c);\n   }\n }"}, {"sha": "fdcc8280fd30d4939569d04a65e50eefbd92dfa3", "filename": "libjava/javax/swing/InputMap.java", "status": "modified", "additions": 99, "deletions": 125, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FInputMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FInputMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FInputMap.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -1,5 +1,5 @@\n /* InputMap.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,32 +35,30 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.io.Serializable;\n import java.util.Arrays;\n-import java.util.Iterator;\n import java.util.HashMap;\n import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.Map;\n import java.util.Set;\n \n+\n /**\n- * InputMap\n  * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * @author Michael Koch\n+ *\n+ * @since 1.3\n  */\n-public class InputMap implements Serializable\n+public class InputMap\n+  implements Serializable\n {\n-  static final long serialVersionUID = -5429059542008604257L;\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n+  private static final long serialVersionUID = -5429059542008604257L;\n \n \t/**\n \t * inputMap\n@@ -70,171 +68,147 @@ public class InputMap implements Serializable\n \t/**\n \t * parent\n \t */\n-\tprivate InputMap parent = null;\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n+  private InputMap parent;\n \n \t/**\n-\t * Constructor InputMap\n+   * Creates a new <code>InputMap</code> instance.\n \t */\n-\tpublic InputMap() {\n+  public InputMap()\n+  {\n \t\t// TODO\n-\t} // InputMap()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n+  }\n \n \t/**\n-\t * get\n-\t * @param value0 TODO\n-\t * @returns Object\n+   * Returns the binding for keystroke.\n+   *\n+   * @param key the key of the enty\n+   *\n+   * @return the binding associated with keystroke may be null\n \t */\n-\tpublic Object get(KeyStroke keystroke) {\n-\n-\t\t// Variables\n-\t\tObject\tresult;\n+  public Object get(KeyStroke keystroke)\n+  {\n+    Object result = inputMap.get(keystroke);\n \n-\t\t// Check Local store\n-\t\tresult = inputMap.get(keystroke);\n-\n-\t\t// Check Parent\n-\t\tif (result == null) {\n+    if (result == null)\n \t\t\tresult = parent.get(keystroke);\n-\t\t} // if\n-\n \t\treturn result;\n-\n-\t} // get()\n+  }\n \n \t/**\n-\t * put\n-\t * @param keystroke TODO\n-\t * @param actionMapKey TODO\n+   * Puts a new entry into the <code>InputMap</code>.\n+   * If actionMapKey is null an existing entry will be removed.\n+   *\n+   * @param keystroke the keystroke for the entry\n+   * @param actionMapKey the action.\n \t */\n-\tpublic void put(KeyStroke keystroke, Object actionMapKey) {\n-\t\tif (actionMapKey == null) {\n+  public void put(KeyStroke keystroke, Object actionMapKey)\n+  {\n+    if (actionMapKey == null)\n \t\t\tinputMap.remove(keystroke);\n-\t\t} else {\n+    else\n \t\t\tinputMap.put(keystroke, actionMapKey);\n-\t\t} // if\n-\t} // put()\n+  }\n \n \t/**\n-\t * remove\n-\t * @param keystroke TODO\n+   * Remove an entry from the <code>InputMap</code>.\n+   *\n+   * @param key the key of the entry to remove\n \t */\n-\tpublic void remove(KeyStroke keystroke) {\n+  public void remove(KeyStroke keystroke)\n+  {\n \t\tinputMap.remove(keystroke);\n-\t} // remove()\n+  }\n \n \t/**\n-\t * getParent\n-\t * @returns InputMap\n+   * Returns the parent of this <code>InputMap</code>.\n+   *\n+   * @return the parent, may be null.\n \t */\n-\tpublic InputMap getParent() {\n+  public InputMap getParent()\n+  {\n \t\treturn parent;\n-\t} // getParent()\n+  }\n \n \t/**\n-\t * setParent\n-\t * @param parentMap TODO\n+   * Sets a parent for this <code>InputMap</code>.\n+   *\n+   * @param parentMap the new parent\n \t */\n-\tpublic void setParent(InputMap parentMap) {\n+  public void setParent(InputMap parentMap)\n+  {\n \t\tparent = parentMap;\n-\t} // setParent()\n+  }\n \n \t/**\n-\t * size\n-\t * @returns int\n+   * Returns the number of entries in this <code>InputMap</code>.\n+   *\n+   * @return the number of entries\n \t */\n-\tpublic int size() {\n+  public int size()\n+  {\n \t\treturn inputMap.size();\n-\t} // size()\n+  }\n \n \t/**\n-\t * clear\n+   * Clears the <code>InputMap</code>.\n \t */\n-\tpublic void clear() {\n+  public void clear()\n+  {\n \t\tinputMap.clear();\n-\t} // clear()\n+  }\n \n \t/**\n-\t * keys\n-\t * @returns KeyStroke[]\n+   * Returns all keys of entries in this <code>InputMap</code>.\n+   *\n+   * @return an array of keys\n \t */\n-\tpublic KeyStroke[] keys() {\n-\t\treturn convertSet(inputMap.keySet());\n-\t} // keys()\n+  public KeyStroke[] keys()\n+  {\n+    KeyStroke[] array = new KeyStroke[size()];\n+    return (KeyStroke[]) inputMap.keySet().toArray(array);\n+  }\n \n \t/**\n-\t * allKeys\n-\t * @returns KeyStroke[]\n+   * Returns all keys of entries in this <code>InputMap</code>\n+   * and all its parents.\n+   *\n+   * @return an array of keys\n \t */\n-\tpublic KeyStroke[] allKeys() {\n+  public KeyStroke[] allKeys()\n+  {\n+    Set set = new HashSet();\n \n-\t\t// Variables\n-\t\tSet\t\t\tset;\n-\n-\t\t// Initialize\n-\t\tset = new HashSet();\n-\n-\t\t// Get Key Sets\n-\t\tif (parent != null) {\n+    if (parent != null)\n \t\t\tset.addAll(Arrays.asList(parent.allKeys()));\n-\t\t} // if\n-\t\tset.addAll(inputMap.keySet());\n-\n-\t\treturn convertSet(set);\n-\n-\t} // allKeys()\n-\n-\tprivate KeyStroke[] convertSet(Set set) {\n-\n-\t\t// Variables\n-\t\tint\t\t\tindex;\n-\t\tIterator\titerator;\n-\t\tKeyStroke[]\tkeys;\n \n-\t\t// Create Final array\n-\t\tkeys = new KeyStroke[set.size()];\n-\t\titerator = set.iterator();\n-\t\tindex = 0;\n-\t\twhile (iterator.hasNext()) {\n-\t\t\tkeys[index++] = (KeyStroke) iterator.next();\n-\t\t} // while\n-\n-\t\treturn keys;\n-\n-\t} // convertSet()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Interface: Serializable ------------------------------------\n-\t//-------------------------------------------------------------\n+    set.addAll(inputMap.keySet());\n+    KeyStroke[] array = new KeyStroke[size()];\n+    return (KeyStroke[]) set.toArray(array);\n+  }\n \n \t/**\n \t * writeObject\n-\t * @param stream TODO\n-\t * @exception IOException TODO\n+   *\n+   * @param stream the stream to write to\n+   *\n+   * @exception IOException If an error occurs\n \t */\n-\tprivate void writeObject(ObjectOutputStream stream) throws IOException {\n+  private void writeObject(ObjectOutputStream stream) throws IOException\n+  {\n \t\t// TODO\n-\t} // writeObject()\n+  }\n \n \t/**\n \t * readObject\n-\t * @param stream TODO\n-\t * @exception ClassNotFoundException TODO\n-\t * @exception IOException TODO\n+   *\n+   * @param stream the stream to read from\n+   *\n+   * @exception ClassNotFoundException If the serialized class cannot be found\n+   * @exception IOException If an error occurs\n \t */\n-\tprivate void readObject(ObjectInputStream stream) throws ClassNotFoundException, IOException {\n+  private void readObject(ObjectInputStream stream)\n+    throws ClassNotFoundException, IOException\n+  {\n \t\t// TODO\n-\t} // readObject()\n-\n-\n-} // InputMap\n+  }\n+}"}, {"sha": "13e3d57163479b5facc821f7658ebd9f437e1c2e", "filename": "libjava/javax/swing/JButton.java", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJButton.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJButton.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJButton.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -41,17 +41,18 @@\n import javax.accessibility.AccessibleContext;\n import javax.swing.plaf.ButtonUI;\n \n+\n /**\n  * An instance of JButton can be added to a panel, frame etc\n  *\n  * @author Ronald Veldema (rveldema@cs.vu.nl)\n  */\n-public class JButton extends AbstractButton implements Accessible \n+public class JButton extends AbstractButton\n+  implements Accessible\n {\n   private static final long serialVersionUID = -1907255238954382202L;\n-\n-    boolean def, is_def;\n-\n+  boolean def;\n+  boolean is_def;\n     \n     public JButton()\n     {\n@@ -98,8 +99,7 @@ public AccessibleContext getAccessibleContext()\n   \n     public String getUIClassID()\n     {\n-\t//Returns a string that specifies the name of the Look and Feel\n-\t//class that renders this component.  \n+    //Returns a string that specifies the name of the L&F class that renders this component.  \n \treturn \"ButtonUI\";\n     }\n   \n@@ -120,17 +120,23 @@ protected  String paramString()\n \treturn \"JButton\";\n     }\n     \n+  /**\n+   * Overrides JComponent.removeNotify to check if this button is currently\n+   * set as the default button on the RootPane, and if so, sets the RootPane's\n+   * default button to null to ensure the RootPane doesn't hold onto an invalid\n+   * button reference.\n+   */\n     public void removeNotify()\n     {\n-\t//Overrides JComponent.removeNotify to check if this button is currently set as the default button on the RootPane, and if so, sets the RootPane's default button to null to ensure the RootPane doesn't hold onto an invalid button reference.  \n     }\n     \n     public void setDefaultCapable(boolean defaultCapable)\n-    {\tdef = defaultCapable;    }\n+  {\n+    def = defaultCapable;\n+  }\n     \n     public void updateUI()\n     {\n-\tButtonUI b = (ButtonUI)UIManager.getUI(this);\n-\tsetUI(b);\n+    setUI((ButtonUI) UIManager.getUI(this));\n     }\n }"}, {"sha": "f5cc78aceda7760c8e0def61415ff84c56c33438", "filename": "libjava/javax/swing/JCheckBox.java", "status": "modified", "additions": 54, "deletions": 11, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJCheckBox.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJCheckBox.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJCheckBox.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -49,49 +49,92 @@ public class JCheckBox extends JToggleButton\n {\n   private static final long serialVersionUID = -5246739313864538930L;\n   \n+  private boolean borderPaintedFlat;\n+\n+  private void init()\n+  {\n+    borderPainted = false;\n+    contentAreaFilled = false;\n+  }\n+  \n     public JCheckBox()\n     {\n-\tthis(null, null);\n+    super();\n+    init();\n     }\n-    public JCheckBox(Action a)\n+\n+  public JCheckBox(Action action)\n     {\n-\tthis();\n-\tsetAction(a);\n+    super(action);\n+    init();\n     }\n \n     public JCheckBox(Icon icon)\n     { \n-\tthis(null, icon);\n+    super(icon);\n+    init();\n+  }    \n+  \n+  public JCheckBox(Icon icon, boolean selected)\n+  { \n+    super(icon, selected);\n+    init();\n     }    \n   \n     public JCheckBox(String text)\n     {\n-\tthis(text, null);\n+    super(text);\n+    init();\n+  }\n+      \n+  public JCheckBox(String text, boolean selected)\n+  {\n+    super(text, selected);\n+    init();\n     }\n       \n     public JCheckBox(String text, Icon icon)\n     {\n \tsuper(text, icon);\n-        paint_border = false;\n-        content_area_filled = false;\n+    init();\n     }\n \n+  public JCheckBox(String text, Icon icon, boolean selected)\n+  {\n+    super(text, icon, selected);\n+    init();\n+  }\n     \n+  /**\n+   * Gets the AccessibleContext associated with this JCheckBox.\n+   */\n     public AccessibleContext getAccessibleContext()\n     {\n-\t//Gets the AccessibleContext associated with this JCheckBox. \n \treturn null;\n     }\n   \n+  /**\n+   * Returns a string that specifies the name of the L&amp;F class\n+   * that renders this component.\n+   */\n     public String getUIClassID()\n     {\n-\t//Returns a string that specifies the name of the Look and Feel\n-\t//class that renders this component.  \n \treturn \"CheckBoxUI\";\n     }\n   \n     protected  String paramString()\n     {\n \treturn \"JCheckBox\";\n     }\n+\n+  public boolean isBorderPaintedFlat()\n+  {\n+    return borderPaintedFlat;\n+  }\n+\n+  public void setBorderPaintedFlat(boolean newValue)\n+  {\n+    firePropertyChange(\"borderPaintedFlat\", borderPaintedFlat, newValue);\n+    borderPaintedFlat = newValue;\n+  }\n }"}, {"sha": "e0ebb7f8dfc3b045fcdefcce1e58498f1ef79205", "filename": "libjava/javax/swing/JCheckBoxMenuItem.java", "status": "modified", "additions": 59, "deletions": 51, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJCheckBoxMenuItem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJCheckBoxMenuItem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJCheckBoxMenuItem.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -45,16 +45,28 @@\n \n \n /**\n- * DOCUMENT ME!\n+ * This class represents JCheckBoxMenuItem. Its behaviour is very similar\n+ * to JCheckBoxButton. Just like the JCheckBoxButton, user can check and\n+ * uncheck this menu item by clicking on it. Also setSelected()/setState()\n+ * can be use used for the same purpose. JCheckBoxMenuItem uses\n+ * ToggleButtonModel to keep track of its selection.\n  */\n public class JCheckBoxMenuItem extends JMenuItem implements SwingConstants,\n                                                             Accessible\n {\n   private static final long serialVersionUID = -6676402307973384715L;\n \n+  /** name for the UI delegate for this menuItem. */\n   private static final String uiClassID = \"CheckBoxMenuItemUI\";\n+\n+  /** Indicates whether this menu item is checked. */\n   private boolean state;\n-  private Object[] selectedObjects;\n+\n+  /**\n+   * This array contains text of this menu item if this menu item is in\n+   * checked state and null it is not.\n+   */\n+  private Object[] selectedObjects = new Object[1];\n \n   /**\n    * Creates a new JCheckBoxMenuItem object.\n@@ -65,29 +77,29 @@ public JCheckBoxMenuItem()\n   }\n \n   /**\n-   * Creates a new JCheckBoxMenuItem object.\n+   * Creates a new JCheckBoxMenuItem with given icon\n    *\n-   * @param icon DOCUMENT ME!\n+   * @param icon Icon for this menu item\n    */\n   public JCheckBoxMenuItem(Icon icon)\n   {\n     this(null, icon);\n   }\n \n   /**\n-   * Creates a new JCheckBoxMenuItem object.\n+   * Creates a new JCheckBoxMenuItem with given label\n    *\n-   * @param text DOCUMENT ME!\n+   * @param text Label for this menu item\n    */\n   public JCheckBoxMenuItem(String text)\n   {\n     this(text, null);\n   }\n \n   /**\n-   * Creates a new JCheckBoxMenuItem object.\n+   * Creates a new JCheckBoxMenuItem using given action\n    *\n-   * @param action DOCUMENT ME!\n+   * @param action Action for this menu item.\n    */\n   public JCheckBoxMenuItem(Action action)\n   {\n@@ -96,33 +108,35 @@ public JCheckBoxMenuItem(Action action)\n   }\n \n   /**\n-   * Creates a new JCheckBoxMenuItem object.\n+   * Creates a new JCheckBoxMenuItem object with given label and icon\n    *\n-   * @param text DOCUMENT ME!\n-   * @param icon DOCUMENT ME!\n+   * @param text Label for this menu item\n+   * @param icon Icon for this menu item\n    */\n   public JCheckBoxMenuItem(String text, Icon icon)\n   {\n     this(text, icon, false);\n   }\n \n   /**\n-   * Creates a new JCheckBoxMenuItem object.\n+   * Creates a new JCheckBoxMenuItem object using specified label and\n+   * marked as checked if given 'state' is true\n    *\n-   * @param text DOCUMENT ME!\n-   * @param state DOCUMENT ME!\n+   * @param text Label for this menu item\n+   * @param state True if this item should be in checked state and false otherwise\n    */\n   public JCheckBoxMenuItem(String text, boolean state)\n   {\n     this(text, null, state);\n   }\n \n   /**\n-   * Creates a new JCheckBoxMenuItem object.\n+   * Creates a new JCheckBoxMenuItem object with given label, icon,\n+   * and marked as checked if given 'state' is true\n    *\n-   * @param text DOCUMENT ME!\n-   * @param icon DOCUMENT ME!\n-   * @param state DOCUMENT ME!\n+   * @param text Label for this menu item\n+   * @param icon icon for this menu item\n+   * @param state  True if this item should be in checked state and false otherwise\n    */\n   public JCheckBoxMenuItem(String text, Icon icon, boolean state)\n   {\n@@ -131,81 +145,83 @@ public JCheckBoxMenuItem(String text, Icon icon, boolean state)\n     this.state = state;\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   *\n-   * @param stream DOCUMENT ME!\n-   *\n-   * @throws IOException DOCUMENT ME!\n-   */\n   private void writeObject(ObjectOutputStream stream) throws IOException\n   {\n-    // TODO\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method returns a name to identify which look and feel class will be\n+   * the UI delegate for the menuItem.\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return The Look and Feel classID. \"JCheckBoxMenuItemUI\"\n    */\n   public String getUIClassID()\n   {\n     return uiClassID;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns checked state for this check box menu item.\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return Returns true if this menu item is in checked state\n+   * and false otherwise.\n    */\n   public boolean getState()\n   {\n     return state;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets state for this check box menu item. If\n+   * given 'state' is true, then mark menu item as checked,\n+   * and uncheck this menu item otherwise.\n+   *\n+   * @param state new state for this menu item\n    *\n-   * @param state DOCUMENT ME!\n    */\n   public synchronized void setState(boolean state)\n   {\n     this.state = state;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method returns array containing label of this\n+   * menu item if it is selected and null otherwise.\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return Array containing label of this\n+   * menu item if this menu item is selected or null otherwise.\n    */\n   public Object[] getSelectedObjects()\n   {\n+    if (state == true)\n+      selectedObjects[0] = this.getText();\n+    else\n+      selectedObjects[0] = null;\n+\n     return selectedObjects;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+    * This method overrides JComponent.requestFocus with an empty\n+    * implementation, since JCheckBoxMenuItems should not\n+    * receve focus in general.\n    */\n   public void requestFocus()\n   {\n-    // TODO\n+    //  Should do nothing here\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * A string that describes this JCheckBoxMenuItem. Normally only used\n+   * for debugging.\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return A string describing this JCheckBoxMenuItem\n    */\n   protected String paramString()\n   {\n     return \"JCheckBoxMenuItem\";\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   *\n-   * @return $returnType$ DOCUMENT ME!\n-   */\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n@@ -214,9 +230,6 @@ public AccessibleContext getAccessibleContext()\n     return accessibleContext;\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   */\n   protected class AccessibleJCheckBoxMenuItem extends AccessibleJMenuItem\n   {\n     private static final long serialVersionUID = 1079958073579370777L;\n@@ -228,11 +241,6 @@ protected AccessibleJCheckBoxMenuItem()\n     {\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @return $returnType$ DOCUMENT ME!\n-     */\n     public AccessibleRole getAccessibleRole()\n     {\n       return AccessibleRole.CHECK_BOX;"}, {"sha": "e8f01d028b42c6f1106ff8df292f1502bbd249f1", "filename": "libjava/javax/swing/JComponent.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJComponent.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -1625,6 +1625,7 @@ public boolean requestDefaultFocus()\n    */\n   public void revalidate()\n   {\n+    invalidate();\n     RepaintManager.currentManager(this).addInvalidComponent(this);\n   }\n "}, {"sha": "a36eba757ee41dcd0ca56d6a16550575f1a0880a", "filename": "libjava/javax/swing/JEditorPane.java", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJEditorPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJEditorPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJEditorPane.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -39,15 +39,16 @@\n \n import java.awt.Dimension;\n import java.awt.event.KeyEvent;\n-import java.io.IOException;\n import java.io.InputStream;\n+import java.io.IOException;\n import java.net.URL;\n+\n import javax.accessibility.AccessibleContext;\n import javax.swing.event.HyperlinkEvent;\n import javax.swing.event.HyperlinkListener;\n+import javax.swing.text.DefaultEditorKit;\n import javax.swing.text.EditorKit;\n import javax.swing.text.JTextComponent;\n-import javax.swing.text.PlainEditorKit;\n \n \n public class JEditorPane extends JTextComponent\n@@ -82,12 +83,12 @@ public JEditorPane(URL url) throws IOException\n \n   protected EditorKit createDefaultEditorKit()\n   {\n-    return new PlainEditorKit();\n+    return new DefaultEditorKit();\n   }\n \n-  protected static EditorKit createEditorKitForContentType(String type)\n+  public static EditorKit createEditorKitForContentType(String type)\n   {\n-    return new PlainEditorKit();\n+    return new DefaultEditorKit();\n   }\n \n   /**\n@@ -197,7 +198,8 @@ protected void processComponentKeyEvent(KeyEvent e)\n   }\n \n   /**\n-   * Make sure that TAB and Shift-TAB events get consumed, so that awt doesn't attempt focus traversal.  \n+   * Make sure that TAB and Shift-TAB events get consumed,\n+   * so that awt doesn't attempt focus traversal.  \n    */\n   protected void processKeyEvent(KeyEvent e)\n   {\n@@ -228,16 +230,18 @@ public static void registerEditorKitForContentType(String type,\n   }\n \n   /**\n-   * Replaces the currently selected content with new content represented by the given string. \n+   * Replaces the currently selected content with new content represented\n+   * by the given string.\n    */\n   public void replaceSelection(String content)\n   {\n   }\n \n   /**\n-   * Scrolls the view to the given reference location (that is, the value returned by the UL.getRef method for the URL being displayed).  \n+   * Scrolls the view to the given reference location (that is, the value\n+   * returned by the UL.getRef method for the URL being displayed).\n    */\n-  protected void scrollToReference(String reference)\n+  public void scrollToReference(String reference)\n   {\n   }\n "}, {"sha": "b84d7cc0de31065c64a526af6b7279f9dafc96e3", "filename": "libjava/javax/swing/JFormattedTextField.java", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJFormattedTextField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJFormattedTextField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJFormattedTextField.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -131,6 +131,8 @@ public AbstractFormatterFactory ()\n   public static final int REVERT = 2;\n   public static final int PERSIST = 3;\n \n+  private Object value;\n+  \n   public JFormattedTextField ()\n   {\n     throw new InternalError (\"not implemented\");\n@@ -158,7 +160,7 @@ public JFormattedTextField (AbstractFormatterFactory factory, Object value)\n \n   public JFormattedTextField (Object value)\n   {\n-    throw new InternalError (\"not implemented\");\n+    this.value = value;\n   }\n \n   public void commitEdit ()\n@@ -189,12 +191,12 @@ public AbstractFormatterFactory getFormatterFactory ()\n \n   public String getUIClassID ()\n   {\n-    throw new InternalError (\"not implemented\");\n+    return \"FormattedTextFieldUI\";\n   }\n \n   public Object getValue ()\n   {\n-    throw new InternalError (\"not implemented\");\n+    return value;\n   }\n \n   protected void invalidEdit ()\n@@ -212,9 +214,15 @@ protected void processFocusEvent (FocusEvent evt)\n     throw new InternalError (\"not implemented\");\n   }\n \n-  public void setDocument (Document document)\n+  public void setDocument(Document newdoc)\n   {\n-    throw new InternalError (\"not implemented\");\n+    Document document = getDocument();\n+\n+    if (document == newdoc)\n+      return;\n+    \n+    setDocument(newdoc);\n+    firePropertyChange(\"document\", document, newdoc);\n   }\n \n   public void setLostFocusBehavior (int behavior)\n@@ -232,8 +240,8 @@ public void setFormatterFactory (AbstractFormatterFactory factory)\n     throw new InternalError (\"not implemented\");\n   }\n \n-  public void setValue (Object value)\n+  public void setValue (Object newValue)\n   {\n-    throw new InternalError (\"not implemented\");\n+    value = newValue;\n   }\n }"}, {"sha": "937d41cceac7180241d0db25de5141ca8125682e", "filename": "libjava/javax/swing/JList.java", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJList.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -994,7 +994,32 @@ public AccessibleContext getAccessibleContext()\n    */\n   public Dimension getPreferredScrollableViewportSize()\n   {\n-    return getPreferredSize();\n+    int vis = getVisibleRowCount();\n+    int nrows = getModel() == null ? 0 : getModel().getSize();\n+    // FIXME: this is a somewhat arbitrary default, but.. ?\n+    Dimension single = new Dimension(10, 10);;\n+    Rectangle bounds = null;\n+\n+    if (vis > nrows)\n+      {\n+        if (fixedCellWidth != -1 && \n+            fixedCellHeight != -1)\n+          {\n+            single = new Dimension(fixedCellWidth, fixedCellHeight);\n+          }\n+        else if (nrows != 0 && getUI() != null)\n+          {\n+            Rectangle tmp = getUI().getCellBounds(this, 0, 0);\n+            if (tmp != null)\n+              single = tmp.getSize();\n+          }\n+      }\n+    else if (getUI() != null)\n+      {\n+        return getUI().getCellBounds(this, 0, vis - 1).getSize();\n+      }\n+\n+    return new Dimension(single.width, single.height * vis);\n   }\n \n   /**"}, {"sha": "60e94418d40ffd9c1ca948cf3ce28d9cc5c76211", "filename": "libjava/javax/swing/JMenu.java", "status": "modified", "additions": 57, "deletions": 64, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJMenu.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJMenu.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJMenu.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -62,9 +62,19 @@\n \n \n /**\n+ * <p>\n  * This class represents a menu that can be added to a menu bar or\n- * to some other menu. When JMenu is selected it displays JPopupMenu\n- * containing its menu items.\n+ * can be a submenu in some other menu. When JMenu is selected it\n+ * displays JPopupMenu containing its menu items.\n+ * </p>\n+ *\n+ * <p>\n+ * JMenu's fires MenuEvents when this menu's selection changes. If this menu\n+ * is selected, then fireMenuSelectedEvent() is invoked. In case when menu is\n+ * deselected or cancelled, then fireMenuDeselectedEvent() or \n+ * fireMenuCancelledEvent() is invoked, respectivelly.\n+ * </p>\n+ *\n  */\n public class JMenu extends JMenuItem implements Accessible, MenuElement\n {\n@@ -76,10 +86,8 @@ public class JMenu extends JMenuItem implements Accessible, MenuElement\n   /** A Popup menu associated with this menu, which pops up when menu is selected */\n   private JPopupMenu popupMenu = new JPopupMenu();\n \n-  /** MenuChangeListener that listens to change events occuring in menu's model */\n-  private ChangeListener menuChangeListener;\n-\n-  /** MenuEvent */\n+  /** Whenever menu is selected or deselected the MenuEvent is fired to\n+     menu's registered listeners. */\n   private MenuEvent menuEvent = new MenuEvent(this);\n \n   /*Amount of time, in milliseconds, that should pass before popupMenu\n@@ -89,7 +97,8 @@ public class JMenu extends JMenuItem implements Accessible, MenuElement\n   /* PopupListener */\n   protected WinListener popupListener;\n \n-  /** Location at which popup menu associated with this menu will be displayed*/\n+  /** Location at which popup menu associated with this menu will be\n+     displayed */\n   private Point menuLocation;\n \n   /**\n@@ -98,8 +107,6 @@ public class JMenu extends JMenuItem implements Accessible, MenuElement\n   public JMenu()\n   {\n     super();\n-    menuChangeListener = createMenuChangeListener();\n-    getModel().addChangeListener(menuChangeListener);\n   }\n \n   /**\n@@ -110,8 +117,6 @@ public JMenu()\n   public JMenu(String text)\n   {\n     super(text);\n-    menuChangeListener = createMenuChangeListener();\n-    getModel().addChangeListener(menuChangeListener);\n   }\n \n   /**\n@@ -123,8 +128,7 @@ public JMenu(String text)\n   public JMenu(Action action)\n   {\n     super(action);\n-    menuChangeListener = createMenuChangeListener();\n-    getModel().addChangeListener(menuChangeListener);\n+    createActionChangeListener(this);\n   }\n \n   /**\n@@ -335,14 +339,52 @@ public boolean isSelected()\n \n   /**\n    * Changes this menu selected state if selected is true and false otherwise\n-   * This method fires menuEvents to model's registered listeners.\n+   * This method fires menuEvents to menu's registered listeners.\n    *\n    * @param selected true if the menu should be selected and false otherwise\n    */\n   public void setSelected(boolean selected)\n   {\n+    // if this menu selection is true, then activate this menu and \n+    // display popup associated with this menu\t\n+    if (selected)\n+      {\n     super.setArmed(true);\n+\tsuper.setSelected(true);\n+\n+\t// FIXME: The popup menu should be shown on the screen after certain\n+\t// number of seconds pass. The 'delay' property of this menu indicates\n+\t// this amount of seconds. 'delay' property is 0 by default.\n+\tif (this.isShowing())\n+\t  {\n     fireMenuSelected();\n+\n+\t    int x = 0;\n+\t    int y = 0;\n+\n+\t    if (menuLocation == null)\n+\t      {\n+\t\t// Calculate correct position of the popup. Note that location of the popup \n+\t\t// passed to show() should be relative to the popup's invoker\n+\t\tif (isTopLevelMenu())\n+\t\t  y = this.getHeight();\n+\t\telse\n+\t\t  x = this.getWidth();\n+\n+\t\tgetPopupMenu().show(this, x, y);\n+\t      }\n+\t    else\n+\t      getPopupMenu().show(this, menuLocation.x, menuLocation.y);\n+\t  }\n+      }\n+\n+    else\n+      {\n+\tsuper.setSelected(false);\n+\tsuper.setArmed(false);\n+\tfireMenuDeselected();\n+\tpopupMenu.setVisible(false);\n+      }\n   }\n \n   /**\n@@ -640,17 +682,6 @@ protected void fireMenuCanceled()\n       ((MenuListener) ll[i]).menuCanceled(menuEvent);\n   }\n \n-  /**\n-   * Creates MenuChangeListener to listen to change events occuring\n-   * in the model\n-   *\n-   * @return ChangeListener\n-   */\n-  private ChangeListener createMenuChangeListener()\n-  {\n-    return new MenuChangeListener();\n-  }\n-\n   /**\n    * Creates WinListener that listens to the menu;s popup menu.\n    *\n@@ -675,34 +706,7 @@ public void menuSelectionChanged(boolean changed)\n   {\n     // if this menu selection is true, then activate this menu and \n     // display popup associated with this menu\n-    if (changed)\n-      {\n-\tsetArmed(true);\n-\tfireMenuSelected();\n-\n-\tint x = 0;\n-\tint y = 0;\n-\tif (menuLocation == null)\n-\t  {\n-\t    // Calculate correct position of the popup. Note that location of the popup \n-\t    // passed to show() should be relative to the popup's invoker\n-\t    if (isTopLevelMenu())\n-\t      y = this.getHeight();\n-\t    else\n-\t      x = this.getWidth();\n-\n-\t    getPopupMenu().show(this, x, y);\n-\t  }\n-\telse\n-\t  getPopupMenu().show(this, menuLocation.x, menuLocation.y);\n-      }\n-\n-    else\n-      {\n-\tfireMenuDeselected();\n-\tpopupMenu.setVisible(false);\n-\tsetArmed(false);\n-      }\n+    setSelected(changed);\n   }\n \n   /**\n@@ -860,17 +864,6 @@ public void windowClosing(WindowEvent event)\n     }\n   }\n \n-  /** This class listens to ChangeEvent fired by menu's model*/\n-  protected class MenuChangeListener implements ChangeListener\n-  {\n-    /** This method is invoked when there is change in menu's model property */\n-    public void stateChanged(ChangeEvent e)\n-    {\n-      revalidate();\n-      repaint();\n-    }\n-  }\n-\n   /**\n    * This class listens to PropertyChangeEvents occuring in menu's action\n    */"}, {"sha": "f63b3630c3c131a96aec0622d313b486ab670438", "filename": "libjava/javax/swing/JMenuBar.java", "status": "modified", "additions": 57, "deletions": 25, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJMenuBar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJMenuBar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJMenuBar.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -66,7 +66,15 @@\n \n \n /**\n- * JMenuBar\n+ * <p>\n+ * JMenuBar is a container for menu's. For a menu bar to be seen on the\n+ * screen, at least one menu should be added to it. Just like adding\n+ * components to container, one can use add() to add menu's to the menu bar.\n+ * Menu's will be displayed in the menu  bar in the order they were added.\n+ * The JMenuBar uses selectionModel to keep track of selected menu index.\n+ * JMenuBar's selectionModel will fire ChangeEvents to its registered \n+ * listeners when the selected index changes.\n+ * </p>\n  */\n public class JMenuBar extends JComponent implements Accessible, MenuElement\n {\n@@ -76,6 +84,8 @@ public class JMenuBar extends JComponent implements Accessible, MenuElement\n   /** Fired in a PropertyChangeEvent when the \"model\" changes. */\n   public static final String MODEL_CHANGED_PROPERTY = \"model\";\n   \n+  /** Fired in a PropertyChangeEvent when the \"margin\" changes. */\n+  public static final String MARGIN_CHANGED_PROPERTY = \"margin\";\n   private static final long serialVersionUID = -8191026883931977036L;\n \n   /** JMenuBar's model. It keeps track of selected menu's index */\n@@ -112,7 +122,8 @@ public JMenu add(JMenu c)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method overrides addNotify() in the Container to register\n+   * this menu bar with the current keyboard manager.\n    */\n   public void addNotify()\n   {\n@@ -216,19 +227,22 @@ public JMenu getMenu(int index)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns number of menu's in this menu bar\n    *\n-   * @return DOCUMENT ME!\n+   * @return number of menu's in this menu bar\n    */\n   public int getMenuCount()\n   {\n     return getComponentCount();\n   }\n \n   /**\n-   * Returns selection model for this menu bar.\n+   * Returns selection model for this menu bar. SelectionModel\n+   * keeps track of the selected menu in the menu bar. Whenever\n+   * selected property of selectionModel changes, the ChangeEvent\n+   * will be fired its ChangeListeners.\n    *\n-   * @return selection mdoel for this menu bar.\n+   * @return selection model for this menu bar.\n    */\n   public SingleSelectionModel getSelectionModel()\n   {\n@@ -319,21 +333,24 @@ protected void paintBorder(Graphics g)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * A string that describes this JMenuBar. Normally only used\n+   * for debugging.\n    *\n-   * @return DOCUMENT ME!\n+   * @return A string describing this JMenuBar\n    */\n   protected String paramString()\n   {\n     return \"JMenuBar\";\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Process key events forwarded from MenuSelectionManager. This method\n+   * doesn't do anything. It is here to conform to the MenuElement interface.\n+   *\n+   * @param event event forwarded from MenuSelectionManager\n+   * @param path path to the menu element from which event was generated\n+   * @param manager MenuSelectionManager for the current menu hierarchy\n    *\n-   * @param e DOCUMENT ME!\n-   * @param path DOCUMENT ME!\n-   * @param manager DOCUMENT ME!\n    */\n   public void processKeyEvent(KeyEvent e, MenuElement[] path,\n                               MenuSelectionManager manager)\n@@ -342,11 +359,13 @@ public void processKeyEvent(KeyEvent e, MenuElement[] path,\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Process mouse events forwarded from MenuSelectionManager. This method\n+   * doesn't do anything. It is here to conform to the MenuElement interface.\n+   *\n+   * @param event event forwarded from MenuSelectionManager\n+   * @param path path to the menu element from which event was generated\n+   * @param manager MenuSelectionManager for the current menu hierarchy\n    *\n-   * @param event DOCUMENT ME!\n-   * @param path DOCUMENT ME!\n-   * @param manager DOCUMENT ME!\n    */\n   public void processMouseEvent(MouseEvent event, MenuElement[] path,\n                                 MenuSelectionManager manager)\n@@ -355,7 +374,8 @@ public void processMouseEvent(MouseEvent event, MenuElement[] path,\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method overrides removeNotify() in the Container to\n+   * unregister this menu bar from the current keyboard manager.\n    */\n   public void removeNotify()\n   {\n@@ -364,9 +384,10 @@ public void removeNotify()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets painting status of the border. If 'b' is true then menu bar's\n+   * border will be painted, and it will not be painted otherwise.\n    *\n-   * @param b DOCUMENT ME!\n+   * @param b indicates if menu bar's border should be painted.\n    */\n   public void setBorderPainted(boolean b)\n   {\n@@ -381,27 +402,38 @@ public void setBorderPainted(boolean b)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets help menu for this menu bar\n    *\n-   * @param menu DOCUMENT ME!\n+   * @param menu help menu\n    */\n   public void setHelpMenu(JMenu menu)\n   {\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets the menu bar's \"margin\" bound property,  which represents\n+   * distance between the menubar's border and its menus.\n+   * icon. When marging property is modified, PropertyChangeEvent will\n+   * be fired to menuBar's PropertyChangeListener's.\n+   *\n+   * @param m distance between the menubar's border and its menus.\n    *\n-   * @param m DOCUMENT ME!\n    */\n   public void setMargin(Insets m)\n   {\n+    if (m.equals(this.margin))\n+      {\n+\tInsets oldMargin = this.margin;\n+\tthis.margin = m;\n+\tfirePropertyChange(MARGIN_CHANGED_PROPERTY, oldMargin, margin);\n+      }\n+\n     this.margin = m;\n   }\n \n   /**\n-   * Changes menu bar's selection to the specifies menu.\n-   * This method updates selected index of menu bar's model,\n+   * Changes menu bar's selection to the specified menu.\n+   * This method updates selected index of menu bar's selection model,\n    * which results in a model firing change event.\n    *\n    * @param sel menu to select"}, {"sha": "b137271715d42365e27fa252a6dea4bf1445cb75", "filename": "libjava/javax/swing/JMenuItem.java", "status": "modified", "additions": 58, "deletions": 60, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJMenuItem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJMenuItem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJMenuItem.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -150,26 +150,11 @@ public JMenuItem(String text, int mnemonic)\n     setMnemonic(mnemonic);\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   *\n-   * @param stream DOCUMENT ME!\n-   *\n-   * @throws IOException DOCUMENT ME!\n-   * @throws ClassNotFoundException DOCUMENT ME!\n-   */\n   private void readObject(ObjectInputStream stream)\n                    throws IOException, ClassNotFoundException\n   {\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   *\n-   * @param stream DOCUMENT ME!\n-   *\n-   * @throws IOException DOCUMENT ME!\n-   */\n   private void writeObject(ObjectOutputStream stream) throws IOException\n   {\n   }\n@@ -186,10 +171,14 @@ protected void init(String text, Icon icon)\n \n     // Initializes properties for this menu item, that are different\n     // from Abstract button properties. \n-    paint_border = false;\n-    paint_focus = false;\n-    hori_align = JButton.LEFT;\n-    hori_text_pos = JButton.LEFT;\n+    /* NOTE: According to java specifications paint_border should be set to false,\n+      since menu item should not have a border. However running few java programs\n+      it seems that menu items and menues can have a border. Commenting\n+      out statement below for now. */\n+    //borderPainted = false;\n+    focusPainted = false;\n+    horizontalAlignment = JButton.LEFT;\n+    horizontalTextPosition = JButton.LEFT;\n   }\n \n   /**\n@@ -288,9 +277,7 @@ protected void configurePropertiesFromAction(Action action)\n   {\n     super.configurePropertiesFromAction(action);\n \n-    if (action == null)\n-      setAccelerator(null);\n-    else\n+    if (! (this instanceof JMenu) && action != null)\n       setAccelerator((KeyStroke) (action.getValue(Action.ACCELERATOR_KEY)));\n   }\n \n@@ -325,70 +312,76 @@ public void propertyChange(PropertyChangeEvent e)\n   public void processMouseEvent(MouseEvent event, MenuElement[] path,\n                                 MenuSelectionManager manager)\n   {\n+    // Fire MenuDragMouseEvents if mouse is being dragged.\n+    boolean dragged = (event.getModifiers() & InputEvent.BUTTON1_MASK) != 0;\n+    if (dragged)\n+      processMenuDragMouseEvent(createMenuDragMouseEvent(event, path, manager));\n+\n     switch (event.getID())\n       {\n       case MouseEvent.MOUSE_CLICKED:\n \tbreak;\n       case MouseEvent.MOUSE_ENTERED:\n-\tif (event.getSource() instanceof JMenuItem)\n-\t  {\n-\t    JMenuItem item = (JMenuItem) event.getSource();\n-\n-\t    ButtonModel model = item.getModel();\n-\t    if (item.isRolloverEnabled())\n+\tif (isRolloverEnabled())\n \t      model.setRollover(true);\n-\t  }\n \tbreak;\n       case MouseEvent.MOUSE_EXITED:\n-\tif (event.getSource() instanceof JMenuItem)\n-\t  {\n-\t    JMenuItem item = (JMenuItem) event.getSource();\n-\t    ButtonModel model = item.getModel();\n-\t    if (item.isRolloverEnabled())\n+\tif (isRolloverEnabled())\n \t      model.setRollover(false);\n-\t  }\n+\n+\t// for JMenu last element on the path is its popupMenu.\n+\t// JMenu shouldn't me disarmed.\t\n+\tif (! (path[path.length - 1] instanceof JPopupMenu) && ! dragged)\n+\t  setArmed(false);\n \tbreak;\n       case MouseEvent.MOUSE_PRESSED:\n-\tif (event.getSource() instanceof JMenuItem)\n-\t  {\n \t    if ((event.getModifiers() & InputEvent.BUTTON1_MASK) != 0)\n \t      {\n \t\tmodel.setArmed(true);\n \t\tmodel.setPressed(true);\n \t      }\n-\t  }\n \tbreak;\n       case MouseEvent.MOUSE_RELEASED:\n \tbreak;\n       case MouseEvent.MOUSE_MOVED:\n \tbreak;\n       case MouseEvent.MOUSE_DRAGGED:\n-\tMenuDragMouseEvent e = new MenuDragMouseEvent((Component) event\n-\t                                              .getSource(),\n-\t                                              event.getID(),\n-\t                                              event.getWhen(),\n-\t                                              event.getModifiers(),\n-\t                                              event.getX(),\n-\t                                              event.getY(),\n-\t                                              event.getClickCount(),\n-\t                                              event.isPopupTrigger(),\n-\t                                              path, manager);\n-\tprocessMenuDragMouseEvent(e);\n \tbreak;\n       }\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Creates MenuDragMouseEvent.\n    *\n-   * @param event DOCUMENT ME!\n-   * @param path DOCUMENT ME!\n-   * @param manager DOCUMENT ME!\n+   * @param event MouseEvent that occured while mouse was pressed.\n+   * @param path Path the the menu element where the dragging event was\n+   *        originated\n+   * @param manager MenuSelectionManager for the current menu hierarchy.\n+   *\n+   * @return new MenuDragMouseEvent\n+   */\n+  private MenuDragMouseEvent createMenuDragMouseEvent(MouseEvent event,\n+                                                      MenuElement[] path,\n+                                                      MenuSelectionManager manager)\n+  {\n+    return new MenuDragMouseEvent((Component) event.getSource(),\n+                                  event.getID(), event.getWhen(),\n+                                  event.getModifiers(), event.getX(),\n+                                  event.getY(), event.getClickCount(),\n+                                  event.isPopupTrigger(), path, manager);\n+  }\n+\n+  /**\n+   * Process key events forwarded from MenuSelectionManager.\n+   *\n+   * @param event event forwarded from MenuSelectionManager\n+   * @param path path to the menu element from which event was generated\n+   * @param manager MenuSelectionManager for the current menu hierarchy\n    */\n   public void processKeyEvent(KeyEvent event, MenuElement[] path,\n                               MenuSelectionManager manager)\n   {\n-    // TODO\n+    // Need to implement.\n   }\n \n   /**\n@@ -426,7 +419,7 @@ public void processMenuDragMouseEvent(MenuDragMouseEvent event)\n    */\n   public void processMenuKeyEvent(MenuKeyEvent event)\n   {\n-    // TODO\n+    // Need to implement.\n   }\n \n   /**\n@@ -535,9 +528,19 @@ protected void fireMenuKeyTyped(MenuKeyEvent event)\n   public void menuSelectionChanged(boolean changed)\n   {\n     if (changed)\n+      {\n       model.setArmed(true);\n+\n+\tif (this.getParent() instanceof JPopupMenu)\n+\t  ((JPopupMenu) this.getParent()).setSelected(this);\n+      }\n     else\n+      {\n       model.setArmed(false);\n+\n+\tif (this.getParent() instanceof JPopupMenu)\n+\t  ((JPopupMenu) this.getParent()).getSelectionModel().clearSelection();\n+      }\n   }\n \n   /**\n@@ -617,11 +620,6 @@ protected String paramString()\n     return \"JMenuItem\";\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   *\n-   * @return DOCUMENT ME!\n-   */\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)"}, {"sha": "070427072209eb4bdbc944ddddad6a248e6ca329", "filename": "libjava/javax/swing/JOptionPane.java", "status": "modified", "additions": 243, "deletions": 91, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJOptionPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJOptionPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJOptionPane.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -39,11 +39,15 @@\n \n import java.awt.Component;\n import java.awt.Dialog;\n+import java.awt.Dimension;\n import java.awt.Frame;\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n import javax.swing.Icon;\n+import javax.swing.JInternalFrame;\n+import javax.swing.event.InternalFrameAdapter;\n+import javax.swing.event.InternalFrameEvent;\n import javax.swing.plaf.OptionPaneUI;\n \n \n@@ -60,6 +64,7 @@ public class JOptionPane extends JComponent implements Accessible\n    */\n   protected class AccessibleJOptionPane extends JComponent.AccessibleJComponent\n   {\n+    /** DOCUMENT ME! */\n     private static final long serialVersionUID = 686071432213084821L;\n   \n     /**\n@@ -80,6 +85,7 @@ public AccessibleRole getAccessibleRole()\n     }\n   }\n \n+  /** DOCUMENT ME! */\n   private static final long serialVersionUID = 5231143276678566796L;\n   \n   /** The value returned when cancel option is selected. */\n@@ -373,6 +379,8 @@ public JDialog createDialog(Component parentComponent, String title)\n     dialog.getContentPane().add(this);\n     dialog.setModal(true);\n     dialog.setResizable(false);\n+    dialog.invalidate();\n+    dialog.repaint();\n \n     return dialog;\n   }\n@@ -394,8 +402,21 @@ public JInternalFrame createInternalFrame(Component parentComponent,\n                                             String title)\n                                      throws RuntimeException\n   {\n-    // FIXME: implement.\n-    return null;\n+    JDesktopPane toUse = getDesktopPaneForComponent(parentComponent);\n+    if (toUse == null)\n+      throw new RuntimeException(\"parentComponent does not have a valid parent\");\n+\n+    JInternalFrame frame = new JInternalFrame(title);\n+\n+    inputValue = UNINITIALIZED_VALUE;\n+    value = UNINITIALIZED_VALUE;\n+\n+    frame.setClosable(true);\n+    toUse.add(frame);\n+\n+    // FIXME: JLayeredPane broken? See bug # 16576\n+    // frame.setLayer(JLayeredPane.MODAL_LAYER);\n+    return frame;\n   }\n \n   /**\n@@ -421,7 +442,8 @@ public AccessibleContext getAccessibleContext()\n    */\n   public static JDesktopPane getDesktopPaneForComponent(Component parentComponent)\n   {\n-    return (JDesktopPane) SwingUtilities.getAncestorOfClass(JDesktopPane.class, parentComponent);\n+    return (JDesktopPane) SwingUtilities.getAncestorOfClass(JDesktopPane.class,\n+                                                            parentComponent);\n   }\n \n   /**\n@@ -434,7 +456,8 @@ public static JDesktopPane getDesktopPaneForComponent(Component parentComponent)\n    */\n   public static Frame getFrameForComponent(Component parentComponent)\n   {\n-    return (Frame) SwingUtilities.getAncestorOfClass(Frame.class, parentComponent);\n+    return (Frame) SwingUtilities.getAncestorOfClass(Frame.class,\n+                                                     parentComponent);\n   }\n \n   /**\n@@ -822,6 +845,7 @@ public static int showConfirmDialog(Component parentComponent, Object message)\n   {\n     JOptionPane pane = new JOptionPane(message);\n     JDialog dialog = pane.createDialog(parentComponent, \"Select an Option\");\n+\n     dialog.pack();\n     dialog.show();\n \n@@ -1064,199 +1088,281 @@ public static String showInputDialog(Object message,\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method shows an internal confirmation dialog with the given message.\n+   * The internal frame dialog will be placed in the first JDesktopPane\n+   * ancestor of the given parentComponent. This method will return the value\n+   * selected.\n    *\n-   * @param parentComponent DOCUMENT ME!\n-   * @param message DOCUMENT ME!\n+   * @param parentComponent The parent to find a JDesktopPane in.\n+   * @param message The message to display.\n    *\n-   * @return DOCUMENT ME!\n+   * @return The value selected.\n    */\n   public static int showInternalConfirmDialog(Component parentComponent,\n                                               Object message)\n   {\n-    // FIXME: implement\n-    return 0;\n+    JOptionPane pane = new JOptionPane(message);\n+    JInternalFrame frame = pane.createInternalFrame(parentComponent, null);\n+\n+    startModal(frame, pane);\n+\n+    return ((Integer) pane.getValue()).intValue();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method shows an internal confirmation dialog with the given message,\n+   * optionType and title. The internal frame dialog will be placed in the\n+   * first JDesktopPane ancestor of the given parentComponent.  This method\n+   * will return the selected value.\n    *\n-   * @param parentComponent DOCUMENT ME!\n-   * @param message DOCUMENT ME!\n-   * @param title DOCUMENT ME!\n-   * @param optionType DOCUMENT ME!\n+   * @param parentComponent The parent to find a JDesktopPane in.\n+   * @param message The message to display.\n+   * @param title The title to display.\n+   * @param optionType The option type.\n    *\n-   * @return DOCUMENT ME!\n+   * @return The selected value.\n    */\n   public static int showInternalConfirmDialog(Component parentComponent,\n                                               Object message, String title,\n                                               int optionType)\n   {\n-    // FIXME: implement  \n-    return 0;\n+    JOptionPane pane = new JOptionPane(message, PLAIN_MESSAGE, optionType);\n+    JInternalFrame frame = pane.createInternalFrame(parentComponent, title);\n+\n+    startModal(frame, pane);\n+\n+    return ((Integer) pane.getValue()).intValue();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method shows an internal confirmation dialog with the given message,\n+   * title, optionTypes and icon for the given message type. The internal\n+   * confirmation dialog will be placed in the first  instance of\n+   * JDesktopPane ancestor of the given parentComponent.\n    *\n-   * @param parentComponent DOCUMENT ME!\n-   * @param message DOCUMENT ME!\n-   * @param title DOCUMENT ME!\n-   * @param optionType DOCUMENT ME!\n-   * @param messageType DOCUMENT ME!\n+   * @param parentComponent The component to find a JDesktopPane in.\n+   * @param message The message to display.\n+   * @param title The title of the dialog.\n+   * @param optionType The option type.\n+   * @param messageType The message type.\n    *\n-   * @return DOCUMENT ME!\n+   * @return The selected value.\n    */\n   public static int showInternalConfirmDialog(Component parentComponent,\n                                               Object message, String title,\n                                               int optionType, int messageType)\n   {\n-    // FIXME: implement  \n-    return 0;\n+    JOptionPane pane = new JOptionPane(message, messageType, optionType);\n+    JInternalFrame frame = pane.createInternalFrame(parentComponent, title);\n+\n+    startModal(frame, pane);\n+\n+    return ((Integer) pane.getValue()).intValue();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method shows an internal confirmation dialog with the given message,\n+   * title, option type, message type, and icon. The internal frame dialog\n+   * will be placed in the first JDesktopPane ancestor  that is found in the\n+   * given parentComponent. This method returns  the selected value.\n    *\n-   * @param parentComponent DOCUMENT ME!\n-   * @param message DOCUMENT ME!\n-   * @param title DOCUMENT ME!\n-   * @param optionType DOCUMENT ME!\n-   * @param messageType DOCUMENT ME!\n-   * @param icon DOCUMENT ME!\n+   * @param parentComponent The parent to find a JDesktopPane in.\n+   * @param message The message to display.\n+   * @param title The title to display.\n+   * @param optionType The option type.\n+   * @param messageType The message type.\n+   * @param icon The icon to display.\n    *\n-   * @return DOCUMENT ME!\n+   * @return The selected value.\n    */\n   public static int showInternalConfirmDialog(Component parentComponent,\n                                               Object message, String title,\n                                               int optionType, int messageType,\n                                               Icon icon)\n   {\n-    // FIXME: implement  \n-    return 0;\n+    JOptionPane pane = new JOptionPane(message, messageType, optionType, icon);\n+    JInternalFrame frame = pane.createInternalFrame(parentComponent, title);\n+\n+    startModal(frame, pane);\n+\n+    return ((Integer) pane.getValue()).intValue();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method shows an internal input dialog with the given message. The\n+   * internal frame dialog will be placed in the first JDesktopPane ancestor\n+   * of the given parent component. This method returns the value input by\n+   * the user.\n    *\n-   * @param parentComponent DOCUMENT ME!\n-   * @param message DOCUMENT ME!\n+   * @param parentComponent The parent to find a JDesktopPane in.\n+   * @param message The message to display.\n    *\n-   * @return DOCUMENT ME!\n+   * @return The user selected value.\n    */\n   public static String showInternalInputDialog(Component parentComponent,\n                                                Object message)\n   {\n-    // FIXME: implement  \n-    return null;\n+    JOptionPane pane = new JOptionPane(message);\n+    pane.setWantsInput(true);\n+    JInternalFrame frame = pane.createInternalFrame(parentComponent, null);\n+\n+    startModal(frame, pane);\n+\n+    return (String) pane.getInputValue();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method shows an internal input dialog with the given message,  title\n+   * and message type. The internal input dialog will be placed in the first\n+   * JDesktopPane ancestor found in the given parent component. This method\n+   * will return the input value given by the user.\n    *\n-   * @param parentComponent DOCUMENT ME!\n-   * @param message DOCUMENT ME!\n-   * @param title DOCUMENT ME!\n-   * @param messageType DOCUMENT ME!\n+   * @param parentComponent The component to find a JDesktopPane in.\n+   * @param message The message to display.\n+   * @param title The title to display.\n+   * @param messageType The message type.\n    *\n-   * @return DOCUMENT ME!\n+   * @return The user input value.\n    */\n   public static String showInternalInputDialog(Component parentComponent,\n                                                Object message, String title,\n                                                int messageType)\n   {\n-    // FIXME: implement  \n-    return null;\n+    JOptionPane pane = new JOptionPane(message, messageType);\n+    pane.setWantsInput(true);\n+    JInternalFrame frame = pane.createInternalFrame(parentComponent, title);\n+\n+    startModal(frame, pane);\n+\n+    return (String) pane.getInputValue();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method shows an internal input dialog with the given message, title\n+   * message type, icon, selection value list and initial selection value.\n+   * The internal frame dialog will be placed in the first JDesktopPane\n+   * ancestor found in the given parent component. This method returns the\n+   * input value from the user.\n    *\n-   * @param parentComponent DOCUMENT ME!\n-   * @param message DOCUMENT ME!\n-   * @param title DOCUMENT ME!\n-   * @param messageType DOCUMENT ME!\n-   * @param icon DOCUMENT ME!\n-   * @param selectionValues DOCUMENT ME!\n-   * @param initialSelectionValue DOCUMENT ME!\n+   * @param parentComponent The parent to find a JDesktopPane in.\n+   * @param message The message to display.\n+   * @param title The title to display.\n+   * @param messageType The message type.\n+   * @param icon The icon to display.\n+   * @param selectionValues The selection value list.\n+   * @param initialSelectionValue The initial selection value.\n    *\n-   * @return DOCUMENT ME!\n+   * @return The user input value.\n    */\n   public static Object showInternalInputDialog(Component parentComponent,\n                                                Object message, String title,\n                                                int messageType, Icon icon,\n                                                Object[] selectionValues,\n                                                Object initialSelectionValue)\n   {\n-    // FIXME: implement  \n-    return null;\n+    JOptionPane pane = new JOptionPane(message, messageType);\n+    pane.setWantsInput(true);\n+    pane.setIcon(icon);\n+    pane.setSelectionValues(selectionValues);\n+    pane.setInitialSelectionValue(initialSelectionValue);\n+    JInternalFrame frame = pane.createInternalFrame(parentComponent, title);\n+\n+    startModal(frame, pane);\n+\n+    return (String) pane.getInputValue();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method shows an internal message dialog with the given message. The\n+   * internal frame dialog will be placed in the first JDesktopPane ancestor\n+   * found in the given parent component.\n    *\n-   * @param parentComponent DOCUMENT ME!\n-   * @param message DOCUMENT ME!\n+   * @param parentComponent The component to find a JDesktopPane in.\n+   * @param message The message to display.\n    */\n   public static void showInternalMessageDialog(Component parentComponent,\n                                                Object message)\n   {\n-    // FIXME: implement  \n+    JOptionPane pane = new JOptionPane(message);\n+    JInternalFrame frame = pane.createInternalFrame(parentComponent, null);\n+\n+    startModal(frame, pane);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method shows an internal message dialog with the given message,\n+   * title and message type. The internal message dialog is placed in the\n+   * first JDesktopPane ancestor found in the given parent component.\n    *\n-   * @param parentComponent DOCUMENT ME!\n-   * @param message DOCUMENT ME!\n-   * @param title DOCUMENT ME!\n-   * @param messageType DOCUMENT ME!\n+   * @param parentComponent The parent component to find a JDesktopPane in.\n+   * @param message The message to display.\n+   * @param title The title to display.\n+   * @param messageType The message type.\n    */\n   public static void showInternalMessageDialog(Component parentComponent,\n                                                Object message, String title,\n                                                int messageType)\n   {\n-    // FIXME: implement\n+    JOptionPane pane = new JOptionPane(message, messageType);\n+    JInternalFrame frame = pane.createInternalFrame(parentComponent, title);\n+\n+    startModal(frame, pane);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method shows an internal message dialog with the given message,\n+   * title, message type and icon. The internal message dialog is placed in\n+   * the first JDesktopPane ancestor found in the given parent component.\n    *\n-   * @param parentComponent DOCUMENT ME!\n-   * @param message DOCUMENT ME!\n-   * @param title DOCUMENT ME!\n-   * @param messageType DOCUMENT ME!\n-   * @param icon DOCUMENT ME!\n+   * @param parentComponent The component to find a JDesktopPane in.\n+   * @param message The message to display.\n+   * @param title The title to display.\n+   * @param messageType The message type.\n+   * @param icon The icon to display.\n    */\n   public static void showInternalMessageDialog(Component parentComponent,\n                                                Object message, String title,\n                                                int messageType, Icon icon)\n   {\n-    // FIXME: implement  \n+    JOptionPane pane = new JOptionPane(message, messageType);\n+    pane.setIcon(icon);\n+    JInternalFrame frame = pane.createInternalFrame(parentComponent, title);\n+\n+    startModal(frame, pane);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method displays an internal option dialog with the given message,\n+   * title, option type, message type, icon, option list, and initial option\n+   * value. The internal option dialog is placed in the first JDesktopPane\n+   * ancestor found in the parent component. This method returns the option\n+   * selected.\n    *\n-   * @param parentComponent DOCUMENT ME!\n-   * @param message DOCUMENT ME!\n-   * @param title DOCUMENT ME!\n-   * @param optionType DOCUMENT ME!\n-   * @param messageType DOCUMENT ME!\n-   * @param icon DOCUMENT ME!\n-   * @param options DOCUMENT ME!\n-   * @param initialValue DOCUMENT ME!\n+   * @param parentComponent The parent to find a JDesktopPane in.\n+   * @param message The message displayed.\n+   * @param title The title displayed.\n+   * @param optionType The option type.\n+   * @param messageType The message type.\n+   * @param icon The icon to display.\n+   * @param options The array of options.\n+   * @param initialValue The initial value selected.\n    *\n-   * @return DOCUMENT ME!\n+   * @return The option that was selected.\n    */\n   public static int showInternalOptionDialog(Component parentComponent,\n                                              Object message, String title,\n                                              int optionType, int messageType,\n                                              Icon icon, Object[] options,\n                                              Object initialValue)\n   {\n-    // FIXME: implement  \n-    return 0;\n+    JOptionPane pane = new JOptionPane(message, messageType, optionType, icon,\n+                                       options, initialValue);\n+\n+    JInternalFrame frame = pane.createInternalFrame(parentComponent, title);\n+\n+    startModal(frame, pane);\n+\n+    return ((Integer) pane.getValue()).intValue();\n   }\n \n   /**\n@@ -1338,6 +1444,7 @@ public static int showOptionDialog(Component parentComponent,\n   {\n     JOptionPane pane = new JOptionPane(message, messageType, optionType, icon,\n                                        options, initialValue);\n+\n     JDialog dialog = pane.createDialog(parentComponent, title);\n     dialog.pack();\n     dialog.show();\n@@ -1394,4 +1501,49 @@ private boolean validOptionType(int key)\n       }\n     return false;\n   }\n+\n+  /**\n+   * This helper method makes the JInternalFrame wait until it is notified by\n+   * an InternalFrameClosing event. This method also adds the given\n+   * JOptionPane to the JInternalFrame and sizes it according to the\n+   * JInternalFrame's preferred size.\n+   *\n+   * @param f The JInternalFrame to make modal.\n+   * @param pane The JOptionPane to add to the JInternalFrame.\n+   */\n+  private static void startModal(JInternalFrame f, JOptionPane pane)\n+  {\n+    f.getContentPane().add(pane);\n+    f.pack();\n+    f.show();\n+\n+    Dimension pref = f.getPreferredSize();\n+    f.setBounds(0, 0, pref.width, pref.height);\n+\n+    synchronized (f)\n+      {\n+\tfinal JInternalFrame tmp = f;\n+\ttmp.toFront();\n+\n+\tf.addInternalFrameListener(new InternalFrameAdapter()\n+\t    {\n+\t      public void internalFrameClosed(InternalFrameEvent e)\n+\t      {\n+\t\tsynchronized (tmp)\n+\t\t  {\n+\t\t    tmp.removeInternalFrameListener(this);\n+\t\t    tmp.notifyAll();\n+\t\t  }\n+\t      }\n+\t    });\n+\ttry\n+\t  {\n+\t    while (! f.isClosed())\n+\t      f.wait();\n+\t  }\n+\tcatch (InterruptedException ignored)\n+\t  {\n+\t  }\n+      }\n+  }\n }"}, {"sha": "9c06400de1056c0b0512e98ecec8b915ca20f623", "filename": "libjava/javax/swing/JPopupMenu.java", "status": "modified", "additions": 84, "deletions": 48, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJPopupMenu.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJPopupMenu.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJPopupMenu.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -68,7 +68,30 @@\n \n \n /**\n- * DOCUMENT ME!\n+ * JPopupMenu is a container that is used to display popup menu's menu\n+ * items. By default JPopupMenu is a lightweight container, however if it\n+ * is the case that JPopupMenu's bounds are outside of main window, then\n+ * heawyweight container will be used to display menu items. It is also\n+ * possible to change JPopupMenu's default  behavior and set JPopupMenu\n+ * to always use heavyweight container.\n+ *\n+ * JPopupMenu can be displayed anywhere; it is a floating free popup menu.\n+ * However before JPopupMenu is diplayed, its invoker property should be set.\n+ * JPopupMenu's invoker is a component relative to which popup menu is\n+ * displayed.\n+ *\n+ * JPopupMenu fires PopupMenuEvents to its registered listeners. Whenever\n+ * JPopupMenu becomes visible on the screen then PopupMenuEvent indicating\n+ * that popup menu became visible will be fired. In the case when\n+ * JPopupMenu becomes invisible or cancelled without selection, then\n+ * popupMenuBecomeInvisible() or popupMenuCancelled() methods of\n+ * PopupMenuListeners will be invoked.\n+ *\n+ * JPopupMenu also fires PropertyChangeEvents when its bound properties \n+ * change.In addittion to inheritted bound properties, JPopupMenu has \n+ * 'visible' bound property. When JPopupMenu becomes visible/invisible on\n+ * the screen it fires PropertyChangeEvents to its registered \n+ * PropertyChangeListeners.\n  */\n public class JPopupMenu extends JComponent implements Accessible, MenuElement\n {\n@@ -77,6 +100,9 @@ public class JPopupMenu extends JComponent implements Accessible, MenuElement\n   /** name for the UI delegate for this menuItem. */\n   private static final String uiClassID = \"PopupMenuUI\";\n \n+  /** Fire a PropertyChangeEvent when the \"borderPainted\" property changes. */\n+  public static final String LABEL_CHANGED_PROPERTY = \"label\";\n+\n   /* indicates if popup's menu border should be painted*/\n   private boolean borderPainted = true;\n \n@@ -98,7 +124,7 @@ public class JPopupMenu extends JComponent implements Accessible, MenuElement\n   /* Component that invokes popup menu. */\n   transient Component invoker;\n \n-  /* Label for this popup menu */\n+  /* Label for this popup menu. It is not used in most of the look and feel themes. */\n   private String label;\n \n   /*Amount of space between menuItem's in JPopupMenu and JPopupMenu's border */\n@@ -130,7 +156,6 @@ public JPopupMenu()\n \n     lightWeightPopupEnabled = DefaultLightWeightPopupEnabled;\n     selectionModel = new DefaultSingleSelectionModel();\n-\n     super.setVisible(false);\n   }\n \n@@ -141,29 +166,14 @@ public JPopupMenu()\n    */\n   public JPopupMenu(String label)\n   {\n-    this.label = label;\n+    setLabel(label);\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   *\n-   * @param stream DOCUMENT ME!\n-   *\n-   * @throws IOException DOCUMENT ME!\n-   * @throws ClassNotFoundException DOCUMENT ME!\n-   */\n   private void readObject(ObjectInputStream stream)\n                    throws IOException, ClassNotFoundException\n   {\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   *\n-   * @param stream DOCUMENT ME!\n-   *\n-   * @throws IOException DOCUMENT ME!\n-   */\n   private void writeObject(ObjectOutputStream stream) throws IOException\n   {\n   }\n@@ -205,7 +215,7 @@ public JMenuItem add(String text)\n    */\n   public JMenuItem add(Action action)\n   {\n-    JMenuItem item = new JMenuItem(action);\n+    JMenuItem item = createActionComponent(action);\n \n     if (action != null)\n       action.addPropertyChangeListener(createActionChangeListener(item));\n@@ -223,7 +233,7 @@ public void remove(int index)\n     super.remove(index);\n \n     GridBagConstraints constraints = new GridBagConstraints();\n-    constraints.fill = GridBagConstraints.HORIZONTAL;\n+    constraints.fill = GridBagConstraints.BOTH;\n     constraints.weightx = 100.0;\n     constraints.weighty = 100.0;\n \n@@ -258,7 +268,7 @@ public void insert(Action action, int index)\n   public void insert(Component component, int index)\n   {\n     GridBagConstraints constraints = new GridBagConstraints();\n-    constraints.fill = GridBagConstraints.HORIZONTAL;\n+    constraints.fill = GridBagConstraints.BOTH;\n     constraints.weightx = 100.0;\n     constraints.weighty = 100.0;\n \n@@ -385,27 +395,28 @@ public void setSelectionModel(SingleSelectionModel model)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Creates new menu item associated with a given action.\n    *\n-   * @param action DOCUMENT ME!\n+   * @param action Action used to create new menu item\n    *\n-   * @return DOCUMENT ME!\n+   * @return new created menu item associated with a given action.\n    */\n   protected JMenuItem createActionComponent(Action action)\n   {\n-    return null;\n+    return new JMenuItem(action);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Creates PropertyChangeListener that listens to PropertyChangeEvents\n+   * occuring in the Action associated with given menu item in this popup menu.\n    *\n-   * @param item DOCUMENT ME!\n+   * @param item MenuItem\n    *\n-   * @return DOCUMENT ME!\n+   * @return The PropertyChangeListener\n    */\n   protected PropertyChangeListener createActionChangeListener(JMenuItem item)\n   {\n-    return null;\n+    return new ActionChangeListener();\n   }\n \n   /**\n@@ -441,13 +452,20 @@ public String getLabel()\n   }\n \n   /**\n-   * Sets label for this popup menu\n+   * Sets label for this popup menu. This method fires PropertyChangeEvent\n+   * when the label property is changed. Please note that most\n+   * of the Look & Feel will ignore this property.\n    *\n    * @param label label for this popup menu\n    */\n   public void setLabel(String label)\n   {\n+    if (label != this.label)\n+      {\n+\tString oldLabel = this.label;\n     this.label = label;\n+\tfirePropertyChange(LABEL_CHANGED_PROPERTY, oldLabel, label);\n+      }\n   }\n \n   /**\n@@ -576,6 +594,7 @@ public void setVisible(boolean visible)\n \t      size = this.getPreferredSize();\n \t    else\n \t      size = this.getSize();\n+\n \t    if ((size.width > (rootContainer.getWidth() - popupLocation.x))\n \t        || (size.height > (rootContainer.getHeight() - popupLocation.y)))\n \t      fit = false;\n@@ -602,27 +621,15 @@ public void setVisible(boolean visible)\n \t      {\n \t\t// Subtract insets of the top-level container if popup menu's\n \t\t// top-left corner is inside it.\n-\t\tif (rootContainer.contains(popupLocation))\n-\t\t  {\n \t\t    Insets insets = rootContainer.getInsets();\n \t\t    popup.show(popupLocation.x - insets.left,\n \t\t               popupLocation.y - insets.top, size.width,\n \t\t               size.height);\n \t\t  }\n-\n-\t\telse\n-\t\t  popup.show(popupLocation.x, popupLocation.y, size.width,\n-\t\t             size.height);\n-\t      }\n \t  }\n \telse\n \t  {\n-\t    // popup menu was cancelled without selection\n-\t    if (! getSelectionModel().isSelected())\n-\t      firePopupMenuCanceled();\n-\n \t    firePopupMenuWillBecomeInvisible();\n-\n \t    popup.hide();\n \t  }\n       }\n@@ -790,7 +797,8 @@ protected String paramString()\n   }\n \n   /**\n-  * Process mouse events forwarded from MenuSelectionManager.\n+  * Process mouse events forwarded from MenuSelectionManager. This method \n+  * doesn't do anything. It is here to conform to the MenuElement interface.\n   *\n   * @param event event forwarded from MenuSelectionManager\n   * @param path path to the menu element from which event was generated\n@@ -799,18 +807,24 @@ protected String paramString()\n   public void processMouseEvent(MouseEvent event, MenuElement[] path,\n                                 MenuSelectionManager manager)\n   {\n+    // Empty Implementation. This method is needed for the implementation\n+    // of MenuElement interface\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Process key events forwarded from MenuSelectionManager. This method\n+   * doesn't do anything. It is here to conform to the MenuElement interface.\n+   *\n+   * @param event event forwarded from MenuSelectionManager\n+   * @param path path to the menu element from which event was generated\n+   * @param manager MenuSelectionManager for the current menu hierarchy\n    *\n-   * @param event DOCUMENT ME!\n-   * @param path DOCUMENT ME!\n-   * @param manager DOCUMENT ME!\n    */\n   public void processKeyEvent(KeyEvent event, MenuElement[] path,\n                               MenuSelectionManager manager)\n   {\n+    // Empty Implementation. This method is needed for the implementation\n+    // of MenuElement interface\n   }\n \n   /**\n@@ -822,6 +836,8 @@ public void processKeyEvent(KeyEvent event, MenuElement[] path,\n    */\n   public void menuSelectionChanged(boolean changed)\n   {\n+    if (! changed)\n+      setVisible(false);\n   }\n \n   /**\n@@ -938,6 +954,9 @@ public void show(int x, int y, int width, int height)\n      */\n     public void hide()\n     {\n+      // FIXME: Right now the lightweight container is removed from JLayered\n+      // pane. It is probably would be better in order to improve performance\n+      // to make the container invisible instead of removing it everytime.\n       JLayeredPane layeredPane;\n       layeredPane = SwingUtilities.getRootPane(invoker).getLayeredPane();\n       int index = layeredPane.getIndexOf(c);\n@@ -982,6 +1001,9 @@ public void show(int x, int y, int width, int height)\n      */\n     public void hide()\n     {\n+      // FIXME: Right now the lightweight container is removed from JLayered\n+      // pane. It is probably would be better in order to improve performance\n+      // to make the container invisible instead of removing it everytime.\n       JLayeredPane layeredPane;\n       layeredPane = SwingUtilities.getRootPane(invoker).getLayeredPane();\n       int index = layeredPane.getIndexOf(this);\n@@ -1028,6 +1050,9 @@ public void hide()\n     }\n   }\n \n+  /**\n+   * This is the separator that can be used in popup menu.\n+   */\n   public static class Separator extends JSeparator\n   {\n     public Separator()\n@@ -1053,4 +1078,15 @@ public AccessibleRole getAccessibleRole()\n       return AccessibleRole.POPUP_MENU;\n     }\n   }\n+\n+  /* This class resizes popup menu and repaints popup menu appropriately if one\n+   of item's action has changed */\n+  protected class ActionChangeListener implements PropertyChangeListener\n+  {\n+    public void propertyChange(PropertyChangeEvent evt)\n+    {\n+      JPopupMenu.this.revalidate();\n+      JPopupMenu.this.repaint();\n+    }\n+  }\n }"}, {"sha": "21e545eddd4e371e78a05c415bc563f440ab6e13", "filename": "libjava/javax/swing/JRadioButton.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJRadioButton.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJRadioButton.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJRadioButton.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -67,8 +67,8 @@ public JRadioButton(String text)\n     public JRadioButton(String text, Icon icon)\n     {\n \tsuper(text, icon);\n-        paint_border = false;\n-        content_area_filled = false;\n+        borderPainted = false;\n+        contentAreaFilled = false;\n     }\n \n     "}, {"sha": "4ced1a595f513507684578fc652b0945d7d95f35", "filename": "libjava/javax/swing/JRadioButtonMenuItem.java", "status": "modified", "additions": 41, "deletions": 47, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJRadioButtonMenuItem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJRadioButtonMenuItem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJRadioButtonMenuItem.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -42,15 +42,23 @@\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n \n \n /**\n- * DOCUMENT ME!\n+ * This class represents JRadioButtonMenuItem. Its behaviour is very similar\n+ * to JRadioButton. Just like JRadioButton, user can check and uncheck this\n+ * menu item by clicking on it. JRadioButtonMenuItem uses ToggleButtonModel\n+ * to keep track of its selection. If the JRadioButtonMenuItem is included in\n+ * the button group, then only one JRadioButtonMenuItem can be selected at\n+ * one time.\n  */\n public class JRadioButtonMenuItem extends JMenuItem implements Accessible\n {\n   private static final long serialVersionUID = 8482658191548521743L;\n \n+  /** name for the UI delegate for this radio button menu item. */\n   private static final String uiClassID = \"RadioButtonMenuItemUI\";\n \n   /**\n@@ -62,29 +70,29 @@ public JRadioButtonMenuItem()\n   }\n \n   /**\n-   * Creates a new JRadioButtonMenuItem object.\n+   * Creates a new JRadioButtonMenuItem with specified icon\n    *\n-   * @param icon DOCUMENT ME!\n+   * @param icon Icon to be used for this menu item\n    */\n   public JRadioButtonMenuItem(Icon icon)\n   {\n     this(null, icon);\n   }\n \n   /**\n-   * Creates a new JRadioButtonMenuItem object.\n+   * Creates a new JRadioButtonMenuItem with specified label\n    *\n-   * @param text DOCUMENT ME!\n+   * @param text Label for this menu item\n    */\n   public JRadioButtonMenuItem(String text)\n   {\n     this(text, null);\n   }\n \n   /**\n-   * Creates a new JRadioButtonMenuItem object.\n+   * Creates a new JRadioButtonMenuItem using specified action\n    *\n-   * @param action DOCUMENT ME!\n+   * @param action Action for this menu item\n    */\n   public JRadioButtonMenuItem(Action action)\n   {\n@@ -93,44 +101,47 @@ public JRadioButtonMenuItem(Action action)\n   }\n \n   /**\n-   * Creates a new JRadioButtonMenuItem object.\n+   * Creates a new JRadioButtonMenuItem with specified label and icon\n    *\n-   * @param text DOCUMENT ME!\n-   * @param icon DOCUMENT ME!\n+   * @param text Label for this menu item\n+   * @param icon Icon for this menu item\n    */\n   public JRadioButtonMenuItem(String text, Icon icon)\n   {\n     this(text, icon, false);\n   }\n \n   /**\n-   * Creates a new JRadioButtonMenuItem object.\n+   * Creates a new JRadioButtonMenuItem with specified label\n+   * and marked selected if 'selected' is true.\n    *\n-   * @param text DOCUMENT ME!\n-   * @param selected DOCUMENT ME!\n+   * @param text Text for this menu item\n+   * @param selected Selected state of this menu item\n    */\n   public JRadioButtonMenuItem(String text, boolean selected)\n   {\n     this(text, null, selected);\n   }\n \n   /**\n-   * Creates a new JRadioButtonMenuItem object.\n+   * Creates a new JRadioButtonMenuItem with specified icon\n+   * and given selected state\n    *\n-   * @param icon DOCUMENT ME!\n-   * @param selected DOCUMENT ME!\n+   * @param icon Icon for this menu item\n+   * @param selected Selected state for this menu item\n    */\n   public JRadioButtonMenuItem(Icon icon, boolean selected)\n   {\n     this(null, icon, selected);\n   }\n \n   /**\n-   * Creates a new JRadioButtonMenuItem object.\n+   * Creates a new JRadioButtonMenuItem with specified label,\n+   * icon and selected state.\n    *\n-   * @param text DOCUMENT ME!\n-   * @param icon DOCUMENT ME!\n-   * @param selected DOCUMENT ME!\n+   * @param text Label for this menu item\n+   * @param icon Icon to be use for this menu item\n+   * @param selected selected state of this menu item\n    */\n   public JRadioButtonMenuItem(String text, Icon icon, boolean selected)\n   {\n@@ -139,51 +150,42 @@ public JRadioButtonMenuItem(String text, Icon icon, boolean selected)\n     model.setSelected(selected);\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   *\n-   * @param stream DOCUMENT ME!\n-   *\n-   * @throws IOException DOCUMENT ME!\n-   */\n   private void writeObject(ObjectOutputStream stream) throws IOException\n   {\n-    // TODO\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method returns a name to identify which look and feel class will be\n+   * the UI delegate for the menuItem.\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return The Look and Feel classID. \"JRadioButtonMenuItemUI\"\n    */\n   public String getUIClassID()\n   {\n     return uiClassID;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method overrides JComponent.requestFocus with an empty\n+   * implementation, since JRadioButtonMenuItems should not\n+   * receve focus in general.\n    */\n   public void requestFocus()\n   {\n-    // TODO\n+    //  Should do nothing here\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * A string that describes this JRadioButtonMenuItem. Normally only used\n+   * for debugging.\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return A string describing this JRadioButtonMenuItem\n    */\n   protected String paramString()\n   {\n     return \"JRadioButtonMenuItem\";\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   *\n-   * @return $returnType$ DOCUMENT ME!\n-   */\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n@@ -192,9 +194,6 @@ public AccessibleContext getAccessibleContext()\n     return accessibleContext;\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   */\n   protected class AccessibleJRadioButtonMenuItem extends AccessibleJMenuItem\n   {\n     private static final long serialVersionUID = 4381471510145292179L;\n@@ -206,11 +205,6 @@ protected AccessibleJRadioButtonMenuItem()\n     {\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @return $returnType$ DOCUMENT ME!\n-     */\n     public AccessibleRole getAccessibleRole()\n     {\n       return AccessibleRole.RADIO_BUTTON;"}, {"sha": "34cd800889eea6ef1833e4ec19744a3003f7141a", "filename": "libjava/javax/swing/JRootPane.java", "status": "modified", "additions": 197, "deletions": 12, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJRootPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJRootPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJRootPane.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -48,15 +48,11 @@\n import javax.swing.plaf.RootPaneUI;\n \n /**\n- * This class is where JComponents are added to.\n- * Unlike awt where you could just say frame.add(),\n- * with swing you need to say frame.getRootPane()\n- * (which delivers an instance of this class)\n- * and add your components to that.\n- *\n- * It is implemented by several 'layers' (pane() should be read as plane())\n- * each on top of the others\n- * where you can add components to.\n+ * This class is where JComponents are added to. Unlike awt where you could\n+ * just say frame.add(), with swing you need to say frame.getRootPane()\n+ * (which delivers an instance of this class) and add your components to\n+ * that. It is implemented by several 'layers' (pane() should be read as\n+ * plane()) each on top of the others where you can add components to.\n  * (getContentPane(), getGlassPane(), getLayeredPane())\n  *\n  * @author Ronald Veldema (rveldema@cs.vu.nl)\n@@ -66,12 +62,21 @@ public class JRootPane extends JComponent\n   //  The class used to obtain the accessible role for this object.\n   protected static class AccessibleJRootPane\n   {\n+    /** DOCUMENT ME! */\n     private static final long serialVersionUID = 1082432482784468088L;\n \n+    /**\n+     * Creates a new <code>AccessibleJRootPane</code> object.\n+     */\n     protected AccessibleJRootPane()\n     {\n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n     public AccessibleRole getAccessibleRole()\n     {\n       return AccessibleRole.ROOT_PANE;\n@@ -82,34 +87,74 @@ public AccessibleRole getAccessibleRole()\n   // menuBar withing its layeredPane.\n   protected class RootLayout implements LayoutManager2, Serializable\n   {\n+    /** DOCUMENT ME! */\n     private static final long serialVersionUID = -4100116998559815027L;\n \n+    /**\n+     * Creates a new <code>RootLayout</code> object.\n+     */\n     protected RootLayout()\n     {\n     }\n     \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param comp DOCUMENT ME!\n+     * @param constraints DOCUMENT ME!\n+     */\n     public void addLayoutComponent(Component comp, Object constraints)\n     {\n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param name DOCUMENT ME!\n+     * @param comp DOCUMENT ME!\n+     */\n     public void addLayoutComponent(String name, Component comp)\n     {\n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param target DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n     public float getLayoutAlignmentX(Container target)\n     {\n       return target.getAlignmentX();\n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param target DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n     public float getLayoutAlignmentY(Container target)\n     {\n       return target.getAlignmentY();\n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param target DOCUMENT ME!\n+     */\n     public void invalidateLayout(Container target)\n     {\n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param c DOCUMENT ME!\n+     */\n     public void layoutContainer(Container c)\n     {\n       Dimension menuBarSize;\n@@ -146,13 +191,17 @@ public void layoutContainer(Container c)\n \t      menuBarSize = menuBar.getPreferredSize();\n \t      maxWidth = Math.max(menuBarSize.width, contentPaneSize.width);\n \t      menuBar.setBounds(0, 0, maxWidth, menuBarSize.height);\n+\t      glassPane.setBounds(0, menuBarSize.height, maxWidth,\n+\t                          contentPaneSize.height);\n \t      contentPane.setBounds(0, menuBarSize.height, maxWidth,\n \t                            contentPaneSize.height);\n \t      layeredPane.setSize(maxWidth,\n \t                          menuBarSize.height + contentPaneSize.height);\n \t    }\n \t  else\n \t    {\n+\t      glassPane.setBounds(0, 0, contentPaneSize.width,\n+\t                          contentPaneSize.height);\n \t      contentPane.setBounds(0, 0, contentPaneSize.width,\n \t                            contentPaneSize.height);\n \t      layeredPane.setSize(contentPaneSize.width, contentPaneSize.height);\n@@ -167,28 +216,55 @@ public void layoutContainer(Container c)\n \t\tmenuBarSize.height = containerSize.height;\n \t      menuBar.setBounds(0, 0, containerSize.width, menuBarSize.height);\n \t      int remainingHeight = containerSize.height - menuBarSize.height;\n+\t      glassPane.setBounds(0, menuBarSize.height, containerSize.width,\n+\t                          containerSize.height - menuBarSize.height);\n \t      contentPane.setBounds(0, menuBarSize.height,\n \t                            containerSize.width,\n \t                            (containerSize.height - menuBarSize.height));\n \t    }\n \t  else\n+\t    {\n+\t      glassPane.setBounds(0, 0, containerSize.width,\n+\t                          containerSize.height);\n \t    contentPane.setBounds(0, 0, containerSize.width,\n \t                          containerSize.height);\n+\t    }\n \n \t  layeredPane.setSize(containerSize.width, containerSize.height);\n         }\n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param target DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n     public Dimension maximumLayoutSize(Container target)\n     {\n       return preferredLayoutSize(target);\n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param target DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n     public Dimension minimumLayoutSize(Container target)\n     {\n       return preferredLayoutSize(target);\n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param c DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n     public Dimension preferredLayoutSize(Container c)\n     {\n       Dimension menuBarSize;\n@@ -204,9 +280,9 @@ public Dimension preferredLayoutSize(Container c)\n \t      int maxWidth;\n \t      menuBarSize = menuBar.getPreferredSize();\n \t      maxWidth = Math.max(menuBarSize.width, contentPaneSize.width);\n-\t      prefSize =\n-\t\tnew Dimension(maxWidth,\n-\t\t              contentPaneSize.height + menuBarSize.height);\n+\t      prefSize = new Dimension(maxWidth,\n+\t                               contentPaneSize.height\n+\t                               + menuBarSize.height);\n \t    }\n \t  else\n \t    prefSize = contentPaneSize;\n@@ -217,57 +293,114 @@ public Dimension preferredLayoutSize(Container c)\n       return prefSize;\n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param comp DOCUMENT ME!\n+     */\n     public void removeLayoutComponent(Component comp)\n     {\n     }\n   }\n \n+  /** DOCUMENT ME! */\n+  private static final long serialVersionUID = 8690748000348575668L;\n+\n+  /** DOCUMENT ME! */\n   protected Component glassPane;\n+\n+  /** DOCUMENT ME! */\n   protected JLayeredPane layeredPane;\n+\n+  /** DOCUMENT ME! */\n   protected JMenuBar menuBar;\n+\n+  /** DOCUMENT ME! */\n   protected Container contentPane;\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param m DOCUMENT ME!\n+   */\n   public void setJMenuBar(JMenuBar m)\n   {\n     menuBar = m;\n     getLayeredPane().add(menuBar, JLayeredPane.FRAME_CONTENT_LAYER);\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n   public JMenuBar getJMenuBar()\n   {\n     return menuBar;\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n   public boolean isValidateRoot()\n   {\n     return true;\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n   public Container getContentPane()\n   {\n     if (contentPane == null)\n       setContentPane(createContentPane());\n     return contentPane;\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param p DOCUMENT ME!\n+   */\n   public void setContentPane(Container p)\n   {\n     contentPane = p;\n     getLayeredPane().add(contentPane, JLayeredPane.FRAME_CONTENT_LAYER);\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param comp DOCUMENT ME!\n+   * @param constraints DOCUMENT ME!\n+   * @param index DOCUMENT ME!\n+   */\n   protected void addImpl(Component comp, Object constraints, int index)\n   {\n     super.addImpl(comp, constraints, index);\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n   public Component getGlassPane()\n   {\n     if (glassPane == null)\n       setGlassPane(createGlassPane());\n     return glassPane;\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param f DOCUMENT ME!\n+   */\n   public void setGlassPane(Component f)\n   {\n     if (glassPane != null)\n@@ -279,13 +412,23 @@ public void setGlassPane(Component f)\n     add(glassPane, 0);\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n   public JLayeredPane getLayeredPane()\n   {\n     if (layeredPane == null)\n       setLayeredPane(createLayeredPane());\n     return layeredPane;\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param f DOCUMENT ME!\n+   */\n   public void setLayeredPane(JLayeredPane f)\n   {\n     if (layeredPane != null)\n@@ -295,6 +438,9 @@ public void setLayeredPane(JLayeredPane f)\n     add(f, -1);\n   }\n \n+  /**\n+   * Creates a new <code>JRootPane</code> object.\n+   */\n   public JRootPane()\n   {\n     setLayout(createRootLayout());\n@@ -305,11 +451,21 @@ public JRootPane()\n     updateUI();\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n   protected LayoutManager createRootLayout()\n   {\n     return new RootLayout();\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n   protected JComponent createContentPane()\n   {\n     JPanel p = new JPanel();\n@@ -318,37 +474,66 @@ protected JComponent createContentPane()\n     return p;\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n   protected Component createGlassPane()\n   {\n     JPanel p = new JPanel();\n     p.setName(this.getName() + \".glassPane\");\n     p.setLayout(new BorderLayout());\n     p.setVisible(false);\n+    p.setOpaque(false);\n     return p;\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n   protected JLayeredPane createLayeredPane()\n   {\n     JLayeredPane l = new JLayeredPane();\n     l.setLayout(null);\n     return l;\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n   public RootPaneUI getUI()\n   {\n     return (RootPaneUI) ui;\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param ui DOCUMENT ME!\n+   */\n   public void setUI(RootPaneUI ui)\n   {\n     super.setUI(ui);\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   */\n   public void updateUI()\n   {\n     setUI((RootPaneUI) UIManager.getUI(this));\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n   public String getUIClassID()\n   {\n     return \"RootPaneUI\";"}, {"sha": "8ccee7a1763cc3d3009865ebc13f2e77770f9640", "filename": "libjava/javax/swing/JScrollPane.java", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJScrollPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJScrollPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJScrollPane.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -490,22 +490,15 @@ public void stateChanged(ChangeEvent event)\n             {\n               // if the viewport changed, we should update the VSB / HSB\n               // models according to the new vertical and horizontal sizes\n+\n               Rectangle vr = vp.getViewRect();\n               Dimension vs = vp.getViewSize();\n-              // System.err.println(\"got change from viewport, vr=\" + vr + \", vs=\" + vs);\n               if (vsb != null\n                   && (vsb.getMinimum() != 0\n                       || vsb.getMaximum() != vs.height\n                       || vsb.getValue() != vr.y\n                       || vsb.getVisibleAmount() != vr.height))\n-                {\n-                  //                   System.err.println(\"setting vsb to \"\n-                  //                                      + \"pos=\" + vr.y \n-                  //                                      + \", ext=\" + vr.height \n-                  //                                      + \", min=0\"\n-                  //                                      + \", max=\" + vs.height);\n                   vsb.setValue(vr.y, vr.height, 0, vs.height);\n-                }\n \n               if (hsb != null\n                   && (hsb.getMinimum() != 0"}, {"sha": "efe1abecc7ef775e3a6f33299a3f68142f8bc4d5", "filename": "libjava/javax/swing/JTabbedPane.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJTabbedPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJTabbedPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJTabbedPane.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -312,9 +312,9 @@ public Component getComponent()\n      */\n     public void setComponent(Component c)\n     {\n-      JTabbedPane.this.remove(component);\n+      remove(component);\n       this.component = c;\n-      JTabbedPane.this.add(c);\n+      add(c);\n     }\n \n     /**"}, {"sha": "c628b715218c8a9c2975b5c67ee01915dd7bda95", "filename": "libjava/javax/swing/JTable.java", "status": "modified", "additions": 200, "deletions": 15, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJTable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJTable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJTable.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -38,9 +38,11 @@\n \n package javax.swing;\n \n+import java.awt.Color;\n import java.awt.Dimension;\n import java.awt.Rectangle;\n import java.util.Vector;\n+import java.util.Hashtable;\n \n import javax.accessibility.Accessible;\n import javax.swing.event.CellEditorListener;\n@@ -51,6 +53,11 @@\n import javax.swing.event.TableColumnModelListener;\n import javax.swing.event.TableModelEvent;\n import javax.swing.event.TableModelListener;\n+import javax.swing.table.DefaultTableColumnModel;\n+import javax.swing.table.DefaultTableModel;\n+import javax.swing.table.JTableHeader;\n+import javax.swing.table.TableCellEditor;\n+import javax.swing.table.TableCellRenderer;\n import javax.swing.table.TableColumnModel;\n import javax.swing.table.TableModel;\n \n@@ -66,39 +73,115 @@ public class JTable extends JComponent\n   public static final int AUTO_RESIZE_OFF = 0;\n   public static final int AUTO_RESIZE_SUBSEQUENT_COLUMNS = 2;\n   \n+  protected boolean autoCreateColumnsFromModel;\n+  protected int autoResizeMode;\n+  protected TableCellEditor cellEditor;\n+  protected boolean cellSelectionEnabled;\n+  protected TableColumnModel columnModel;\n+  protected TableModel dataModel;\n+  protected Hashtable defaultEditorsByColumnClass;\n+  protected Hashtable defaultRenderersByColumnClass;\n+  protected int editingColumn;\n+  protected int editingRow;\n+  protected Color gridColor;\n+  protected Dimension preferredViewportSize;\n+  protected int rowHeight;\n+  protected int rowMargin;\n+  protected boolean rowSelectionAllowed;\n+  protected Color selectionBackground;\n+  protected Color selectionForeground;\n+  protected ListSelectionModel selectionModel;\n+  protected boolean showHorizontalLines;\n+  protected boolean showVerticalLines;\n+  protected JTableHeader tableHeader;\n+  \n+  /**\n+   * Creates a new <code>JTable</code> instance.\n+   */\n   public JTable ()\n   {\n-    throw new Error (\"Not implemented\");\n+    this(null, null, null);\n   }\n \n+  /**\n+   * Creates a new <code>JTable</code> instance.\n+   *\n+   * @param numRows an <code>int</code> value\n+   * @param numColumns an <code>int</code> value\n+   */\n   public JTable (int numRows, int numColumns)\n   {\n-    throw new Error (\"Not implemented\");\n+    this(new DefaultTableModel(numRows, numColumns));\n   }\n \n-  public JTable (Object[][] rowData, Object[] columnNames)\n+  /**\n+   * Creates a new <code>JTable</code> instance.\n+   *\n+   * @param data an <code>Object[][]</code> value\n+   * @param columnNames an <code>Object[]</code> value\n+   */\n+  public JTable(Object[][] data, Object[] columnNames)\n   {\n-    throw new Error (\"Not implemented\");\n+    this(new DefaultTableModel(data, columnNames));\n   }\n \n+  /**\n+   * Creates a new <code>JTable</code> instance.\n+   *\n+   * @param dm a <code>TableModel</code> value\n+   */\n   public JTable (TableModel dm)\n   {\n-    throw new Error (\"Not implemented\");\n+    this(dm, null, null);\n   }\n \n+  /**\n+   * Creates a new <code>JTable</code> instance.\n+   *\n+   * @param dm a <code>TableModel</code> value\n+   * @param cm a <code>TableColumnModel</code> value\n+   */\n   public JTable (TableModel dm, TableColumnModel cm)\n   {\n-    throw new Error (\"Not implemented\");\n+    this(dm, cm, null);\n   }\n \n+  /**\n+   * Creates a new <code>JTable</code> instance.\n+   *\n+   * @param dm a <code>TableModel</code> value\n+   * @param cm a <code>TableColumnModel</code> value\n+   * @param sm a <code>ListSelectionModel</code> value\n+   */\n   public JTable (TableModel dm, TableColumnModel cm, ListSelectionModel sm)\n   {\n-    throw new Error (\"Not implemented\");\n+    this.dataModel = dm == null ? createDefaultDataModel() : dm;\n+    this.columnModel = cm == null ? createDefaultColumnModel() : cm;\n+    this.selectionModel = sm == null ? createDefaultListSelectionModel() : sm;\n   }\n \n-  public JTable (Vector rowData, Vector columnNames)\n+  /**\n+   * Creates a new <code>JTable</code> instance.\n+   *\n+   * @param data a <code>Vector</code> value\n+   * @param columnNames a <code>Vector</code> value\n+   */\n+  public JTable(Vector data, Vector columnNames)\n   {\n-    throw new Error (\"Not implemented\");\n+    this(new DefaultTableModel(data, columnNames));\n+  }\n+\n+  /**\n+   * @deprecated 1.0.2, replaced by <code>new JScrollPane(JTable)</code>\n+   */\n+  public static JScrollPane createScrollPaneForTable(JTable table)\n+  {\n+    return new JScrollPane(table);\n+  }\n+\n+  public void clearSelection()\n+  {\n+    selectionModel.clearSelection();\n   }\n \n   public void columnAdded (TableColumnModelEvent event)\n@@ -126,6 +209,21 @@ public void columnSelectionChanged (ListSelectionEvent event)\n     throw new Error (\"Not implemented\");\n   }\n  \n+  protected TableColumnModel createDefaultColumnModel()\n+  {\n+    return new DefaultTableColumnModel();\n+  }\n+\n+  protected TableModel createDefaultDataModel()\n+  {\n+    return new DefaultTableModel();\n+  }\n+\n+  protected ListSelectionModel createDefaultListSelectionModel()\n+  {\n+    return new DefaultListSelectionModel();\n+  }\n+\n   public void editingCanceled (ChangeEvent event)\n   {\n     throw new Error (\"Not implemented\");\n@@ -138,7 +236,12 @@ public void editingStopped (ChangeEvent event)\n \n   public TableColumnModel getColumnModel ()\n   {\n-    throw new Error (\"Not implemented\");\n+    return columnModel;\n+  }\n+  \n+  public TableModel getModel()\n+  {\n+    return dataModel;\n   }\n   \n   public Dimension getPreferredScrollableViewportSize ()\n@@ -168,12 +271,15 @@ public int getScrollableUnitIncrement (Rectangle visibleRect, int orientation, i\n \n   public int getSelectedRow ()\n   {\n-    throw new Error (\"Not implemented\");\n+    return selectionModel.getMinSelectionIndex();\n   }\n   \n   public ListSelectionModel getSelectionModel ()\n   {\n-    throw new Error (\"Not implemented\");\n+    if (! rowSelectionAllowed)\n+      return null;\n+\n+    return selectionModel;\n   }\n \n   public void tableChanged (TableModelEvent event)\n@@ -183,7 +289,13 @@ public void tableChanged (TableModelEvent event)\n \n   public void setModel (TableModel model)\n   {\n-    throw new Error (\"Not implemented\");\n+    if (model == null)\n+      throw new IllegalArgumentException();\n+\n+    // FIXME: Should we deregister from old model ?\n+    \n+    dataModel = model;\n+    dataModel.addTableModelListener(this);\n   }\n \n   public void setSelectionMode (int selectionMode)\n@@ -193,7 +305,13 @@ public void setSelectionMode (int selectionMode)\n \n   public void setSelectionModel (ListSelectionModel model)\n   {\n-    throw new Error (\"Not implemented\");\n+    if (model == null)\n+      throw new IllegalArgumentException();\n+\n+    // FIXME: Should we deregister from old model ?\n+    \n+    selectionModel = model;\n+    selectionModel.addListSelectionListener(this);\n   }\n \n   public void setShowGrid (boolean showGrid)\n@@ -205,4 +323,71 @@ public void valueChanged (ListSelectionEvent event)\n   {\n     throw new Error (\"Not implemented\");\n   }\n-} // class JTable\n+\n+  public JTableHeader getTableHeader()\n+  {\n+    return tableHeader;\n+  }\n+\n+  public void setTableHeader(JTableHeader newHeader)\n+  {\n+    tableHeader = newHeader;\n+  }\n+\n+  public boolean getColumnSelectionAllowed()\n+  {\n+    return columnModel.getColumnSelectionAllowed();\n+  }\n+  \n+  public void setColumnSelectionAllowed(boolean flag)\n+  {\n+    columnModel.setColumnSelectionAllowed(flag);\n+  }\n+\n+  public boolean getRowSelectionAllowed()\n+  {\n+    return rowSelectionAllowed;\n+  }\n+  \n+  public void setRowSelectionAllowed(boolean flag)\n+  {\n+    rowSelectionAllowed = flag;\n+  }\n+\n+  public int getAutoResizeMode()\n+  {\n+    return autoResizeMode;\n+  }\n+\n+  public void setAutoResizeMode(int mode)\n+  {\n+    autoResizeMode = mode;\n+  }\n+\n+  public int getColumnCount()\n+  {\n+    return dataModel.getColumnCount();\n+  }\n+\n+  public int getRowCount()\n+  {\n+    return dataModel.getRowCount();\n+  }\n+\n+  public TableCellRenderer getCellRenderer(int row, int column)\n+  {\n+    TableCellRenderer renderer =\n+      columnModel.getColumn(column).getCellRenderer();\n+    \n+    if (renderer == null)\n+      renderer = getDefaultRenderer(dataModel.getColumnClass(column));\n+    \n+    return renderer;\n+  }\n+\n+  public TableCellRenderer getDefaultRenderer(Class columnClass)\n+  {\n+    // FIXME:\n+    return null;\n+  }\n+}"}, {"sha": "5cbc87dcdc49051fc9f3005536229a3ad66af6df", "filename": "libjava/javax/swing/JTextArea.java", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJTextArea.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJTextArea.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJTextArea.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -49,6 +49,7 @@ public class JTextArea extends JTextComponent\n   private int rows;\n   private int columns;\n   private boolean wrapping;\n+  private int tabSize = 8;\n \n   /**\n    * Creates a new <code>JTextArea</code> object.\n@@ -224,8 +225,28 @@ public boolean getLineWrap()\n    *\n    * @param wrapping true to enable line wrapping, false otherwise\n    */\n-  public void setLineWrap(boolean wrapping)\n+  public void setLineWrap(boolean flag)\n   {\n-    this.wrapping = wrapping;\n+    if (wrapping == flag)\n+      return;\n+\n+    boolean oldValue = wrapping;\n+    wrapping = flag;\n+    firePropertyChange(\"lineWrap\", oldValue, wrapping);\n+  }\n+\n+  public int getTabSize()\n+  {\n+    return tabSize;\n+  }\n+\n+  public void setTabSize(int newSize)\n+  {\n+    if (tabSize == newSize)\n+      return;\n+    \n+    int oldValue = tabSize;\n+    tabSize = newSize;\n+    firePropertyChange(\"tabSize\", oldValue, tabSize);\n   }\n }"}, {"sha": "8872af6906da9d975f4d575ba0a434c6a318ae03", "filename": "libjava/javax/swing/JTextField.java", "status": "modified", "additions": 56, "deletions": 6, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJTextField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJTextField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJTextField.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -37,6 +37,9 @@\n \n package javax.swing;\n \n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n import java.awt.event.ActionEvent;\n import java.awt.event.ActionListener;\n import javax.accessibility.AccessibleStateSet;\n@@ -78,6 +81,8 @@ public AccessibleStateSet getAccessibleStateSet()\n   \n   private int columns;\n \n+  private int align;\n+\n   /**\n    * Creates a new instance of <code>JTextField</code>.\n    */\n@@ -132,10 +137,7 @@ public JTextField(String text, int columns)\n    */\n   public JTextField(Document doc, String text, int columns)\n   {\n-    if (doc == null)\n-      doc = createDefaultModel();\n-\n-    setDocument(doc);\n+    setDocument(doc == null ? createDefaultModel() : doc);\n     setText(text);\n     setColumns(columns);\n   }\n@@ -151,6 +153,16 @@ protected Document createDefaultModel()\n     return new PlainDocument();\n   }\n \n+  /**\n+   * Returns the class ID for the UI.\n+   *\n+   * @return \"TextFieldUI\";\n+   */\n+  public String getUIClassID()\n+  {\n+    return \"TextFieldUI\";\n+  }\n+\n   /**\n    * Adds a new listener object to this text field.\n    *\n@@ -175,6 +187,8 @@ public void removeActionListener(ActionListener listener)\n    * Returns all registered <code>ActionListener</code> objects.\n    *\n    * @return an array of listeners\n+   *\n+   * @since 1.4\n    */\n   public ActionListener[] getActionListeners()\n   {\n@@ -210,10 +224,46 @@ public void setColumns(int columns)\n       throw new IllegalArgumentException();\n \n     this.columns = columns;\n-    // FIXME: Invalidate layout.\n+    invalidate();\n+    repaint();\n   }\n \n-  public void selectAll()\n+  public int getHorizontalAlignment()\n   {\n+    return align;\n+  }\n+\n+  public void setHorizontalAlignment(int newAlign)\n+  {\n+    int oldAlign = align;\n+    align = newAlign;\n+    invalidate();\n+    repaint();\n+    firePropertyChange(\"horizontalAlignment\", oldAlign, newAlign);\n+  }\n+\n+  public void setFont(Font newFont)\n+  {\n+    super.setFont(newFont);\n+    revalidate();\n+  }\n+\n+  public Dimension getPreferredSize()\n+  {\n+    Dimension size;\n+    FontMetrics fm = getFontMetrics(getFont());\n+    int fontHeight = fm.getMaxAscent() + fm.getMaxDescent();\n+    int columnWidth = fm.charWidth('m');\n+    \n+    if (columns != 0)\n+      {\n+\tsize = new Dimension(columns * columnWidth + 4, fontHeight + 4);\n+      }\n+    else\n+      {\n+\tsize = new Dimension(10, 10);\n+      }\n+\n+    return size;\n   }\n }"}, {"sha": "c04bcc36739f7aae7a3b45e6cc617e55060a2eab", "filename": "libjava/javax/swing/JToggleButton.java", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJToggleButton.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJToggleButton.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJToggleButton.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -81,15 +81,19 @@ public JToggleButton(Icon icon)\n     this(null, icon);\n   }    \n   \n+  public JToggleButton (Icon icon, boolean selected) \n+  {\n+    this(null, icon, selected);\n+  }\n+  \n   public JToggleButton(String text)\n   {\n     this(text, null);\n   }\n       \n   public JToggleButton(String text, boolean selected)\n   {\n-    this(text, null);\n-    setSelected(selected);\n+    this(text, null, selected);\n   }\n \n   public JToggleButton(String text, Icon icon)\n@@ -101,13 +105,15 @@ public JToggleButton (String text, Icon icon, boolean selected)\n   {\n     super(text, icon);\n \n-    hori_align = LEADING;\n+    horizontalAlignment = LEADING;\n     setModel(new ToggleButtonModel());\t\n     model.setSelected(selected);\n   }\n \n   /**\n-   * Gets the AccessibleContext associated with this JToggleButton.\n+   * Gets the AccessibleContext associated with this <code>JToggleButton</code>.\n+   *\n+   * @return the associated context\n    */\n   public AccessibleContext getAccessibleContext()\n   {"}, {"sha": "7b5121e76fc487e4fb5bfa2a4746fb5a6a277ddc", "filename": "libjava/javax/swing/JToolBar.java", "status": "modified", "additions": 505, "deletions": 228, "changes": 733, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJToolBar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJToolBar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJToolBar.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -38,6 +38,7 @@\n package javax.swing;\n \n import java.awt.Component;\n+import java.awt.Container;\n import java.awt.Dimension;\n import java.awt.Graphics;\n import java.awt.GridLayout;\n@@ -46,26 +47,31 @@\n import java.beans.PropertyChangeListener;\n import java.io.IOException;\n import java.io.ObjectOutputStream;\n-\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n import javax.accessibility.AccessibleStateSet;\n import javax.swing.plaf.ToolBarUI;\n \n+\n /**\n- * JToolBar\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * JToolBar is a component that provides a toolbar to Swing programs. Users\n+ * can add buttons (or actions that will be represented by JButtons) as well\n+ * as other components to the JToolBar. JToolBars can be dragged in and out\n+ * of their parent components. If the JToolBar is dragged out of the parent,\n+ * then it will be displayed in its own RootPaneContainer. For dragging to\n+ * work properly, JToolBars need to be placed in a Container that has a\n+ * BorderLayout. That parent Container cannot have components in the NORTH,\n+ * EAST, SOUTH,  or WEST components (that is not the JToolBar).\n  */\n-public class JToolBar extends JComponent \n-  implements SwingConstants, Accessible\n+public class JToolBar extends JComponent implements SwingConstants, Accessible\n {\n   /**\n    * AccessibleJToolBar\n    */\n   protected class AccessibleJToolBar extends AccessibleJComponent\n   {\n+    /** DOCUMENT ME! */\n     private static final long serialVersionUID = -5516888265903814215L;\n \n     /**\n@@ -77,6 +83,7 @@ protected AccessibleJToolBar()\n \n     /**\n      * getAccessibleStateSet\n+     *\n      * @return AccessibleStateSet\n      */\n     public AccessibleStateSet getAccessibleStateSet()\n@@ -86,6 +93,7 @@ public AccessibleStateSet getAccessibleStateSet()\n \n     /**\n      * getAccessibleRole\n+     *\n      * @return AccessibleRole\n      */\n     public AccessibleRole getAccessibleRole()\n@@ -95,409 +103,678 @@ public AccessibleRole getAccessibleRole()\n   }\n \n \t/**\n-\t * Separator\n+   * This is the private JToolBar layout manager.\n+   */\n+  private class DefaultToolBarLayout implements LayoutManager\n+  {\n+    /**\n+     * This method is called when a new component is added to the container.\n+     *\n+     * @param name The name of the component added.\n+     * @param comp The component that was added.\n \t */\n-\tpublic static class Separator extends JSeparator {\n+    public void addLayoutComponent(String name, Component comp)\n+    {\n+      // Do nothing.\n+    }\n \n-\t  private static final long serialVersionUID = -1656745644823105219L;\n+    /**\n+     * This method is called to lay out the given container  to position and\n+     * size the child components.\n+     *\n+     * @param c The container to lay out.\n+     *\n+     * @throws Error DOCUMENT ME!\n+     */\n+    public void layoutContainer(Container c)\n+    {\n+      if (! (c instanceof JToolBar))\n+\tthrow new Error(\"DefaultToolBarLayout can only be used on JToolBars.\");\n+      Insets insets = getInsets();\n+      Insets margin = getMargin();\n+      int middle;\n+      if (margin != null)\n+        {\n+\t  insets.left += margin.left;\n+\t  insets.top += margin.top;\n+\t  insets.bottom += margin.bottom;\n+\t  insets.right += margin.right;\n+        }\n+      Component[] components = c.getComponents();\n+      Dimension tdims = c.getSize();\n+      int start = 0;\n+      Dimension pref;\n     \n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n+      if (getOrientation() == SwingUtilities.HORIZONTAL)\n+        {\n+\t  start += insets.left;\n+\t  for (int i = 0; i < components.length; i++)\n+\t    {\n+\t      if (components[i] != null && components[i].isVisible())\n+\t        {\n+\t\t  pref = components[i].getPreferredSize();\n+\t\t  if (pref != null)\n+\t\t    {\n+\t\t      middle = (tdims.height - pref.height) / 2;\n+\t\t      components[i].setBounds(start, middle, pref.width,\n+\t\t                              pref.height);\n+\t\t      start += pref.width;\n+\t\t    }\n+\t        }\n+\t    }\n+        }\n+      else\n+        {\n+\t  start += insets.top;\n+\t  for (int i = 0; i < components.length; i++)\n+\t    {\n+\t      if (components[i] != null && components[i].isVisible())\n+\t        {\n+\t\t  pref = components[i].getPreferredSize();\n+\t\t  if (pref != null)\n+\t\t    {\n+\t\t      middle = (tdims.width - pref.width) / 2;\n+\t\t      components[i].setBounds(middle, start, pref.width,\n+\t\t                              pref.height);\n+\t\t      start += pref.height;\n+\t\t    }\n+\t        }\n+\t    }\n+        }\n+    }\n+\n+    /**\n+     * This method returns the minimum size of the given container given the\n+     * child components.\n+     *\n+     * @param parent The container to measure.\n+     *\n+     * @return The minimum size of the given container.\n+     */\n+    public Dimension minimumLayoutSize(Container parent)\n+    {\n+      return preferredLayoutSize(parent);\n+    }\n \n \t\t/**\n-\t\t * separatorSize\n+     * This method returns the preferred size of the given container given the\n+     * child components.\n+     *\n+     * @param parent The container to measure.\n+     *\n+     * @return The preferred size of the given container.\n \t\t */\n-\t\tprivate Dimension size;\n+    public Dimension preferredLayoutSize(Container parent)\n+    {\n+      int orientation = getOrientation();\n+      Component[] components = getComponents();\n \n+      int limit = 0;\n+      int total = 0;\n+      Dimension dims;\n \n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n+      int w = 0;\n+      int h = 0;\n+\n+      if (orientation == SwingConstants.HORIZONTAL)\n+        {\n+\t  for (int i = 0; i < components.length; i++)\n+\t    {\n+\t      dims = components[i].getPreferredSize();\n+\t      if (dims != null)\n+\t        {\n+\t\t  if (dims.height > limit)\n+\t\t    limit = dims.height;\n+\t\t  total += dims.width;\n+\t        }\n+\t    }\n+\t  w = total;\n+\t  h = limit;\n+        }\n+      else\n+        {\n+\t  for (int i = 0; i < components.length; i++)\n+\t    {\n+\t      dims = components[i].getPreferredSize();\n+\t      if (dims != null)\n+\t        {\n+\t\t  if (dims.width > limit)\n+\t\t    limit = dims.width;\n+\t\t  total += dims.height;\n+\t        }\n+\t    }\n+\t  w = limit;\n+\t  h = total;\n+        }\n+\n+      Insets insets = getInsets();\n+      w += insets.left + insets.right;\n+      h += insets.top + insets.bottom;\n+\n+      Insets margin = getMargin();\n+      if (margin != null)\n+        {\n+\t  w += margin.left + margin.right;\n+\t  h += margin.top + margin.bottom;\n+        }\n+\n+      return new Dimension(w, h);\n+    }\n \n \t\t/**\n-\t\t * Constructor Separator\n+     * This method is called when the given component  is removed from the\n+     * container.\n+     *\n+     * @param comp The component removed.\n \t\t */\n-\t\tpublic Separator() {\n-\t\t\t// TODO\n-\t\t} // Separator()\n+    public void removeLayoutComponent(Component comp)\n+    {\n+      // Do nothing.\n+    }\n+  }\n \n \t\t/**\n-\t\t * Constructor Separator\n-\t\t * @param size TODO\n+   * This is an extension of JSeparator used in toolbars. Unlike JSeparator,\n+   * nothing is painted for this Separator, it is only blank space that\n+   * separates components.\n \t\t */\n-\t\tpublic Separator(Dimension size) {\n-\t\t\t// TODO\n-\t\t} // Separator()\n+  public static class Separator extends JSeparator\n+  {\n+    /** DOCUMENT ME! */\n+    private static final long serialVersionUID = -1656745644823105219L;\n \n+    /**\n+     * Creates a new Separator object.\n+     */\n+    public Separator()\n+    {\n+      super();\n+    } // Separator()\n \n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n+    /**\n+     * Creates a new Separator object with the given size.\n+     *\n+     * @param size The size of the separator.\n+     */\n+    public Separator(Dimension size)\n+    {\n+      setPreferredSize(size);\n+    } // Separator()\n \n \t\t/**\n-\t\t * getUIClassID\n-\t\t * @returns String\n+     * This method returns the String ID of the UI class of  Separator.\n+     *\n+     * @return The UI class' String ID.\n \t\t */\n-\t\tpublic String getUIClassID() {\n-\t\t\treturn null; // TODO\n+    public String getUIClassID()\n+    {\n+      return \"ToolBarSeparatorUI\";\n \t\t} // getUIClassID()\n \n \t\t/**\n-\t\t * getPreferredSize\n-\t\t * @returns Dimension\n+     * This method returns the preferred size of the Separator.\n+     *\n+     * @return The preferred size of the Separator.\n \t\t */\n-\t\tpublic Dimension getPreferredSize() {\n-\t\t\treturn null; // TODO\n+    public Dimension getPreferredSize()\n+    {\n+      return super.getPreferredSize();\n \t\t} // getPreferredSize()\n \n \t\t/**\n-\t\t * getMaximumSize\n-\t\t * @returns Dimension\n+     * This method returns the maximum size of the Separator.\n+     *\n+     * @return The maximum size of the Separator.\n \t\t */\n-\t\tpublic Dimension getMaximumSize() {\n-\t\t\treturn null; // TODO\n+    public Dimension getMaximumSize()\n+    {\n+      return super.getPreferredSize();\n \t\t} // getMaximumSize()\n \n \t\t/**\n-\t\t * getMinimumSize\n-\t\t * @returns Dimension\n+     * This method returns the minimum size of the Separator.\n+     *\n+     * @return The minimum size of the Separator.\n \t\t */\n-\t\tpublic Dimension getMinimumSize() {\n-\t\t\treturn null; // TODO\n+    public Dimension getMinimumSize()\n+    {\n+      return super.getPreferredSize();\n \t\t} // getMinimumSize()\n \n \t\t/**\n-\t\t * getSeparatorSize\n-\t\t * @returns Dimension\n+     * This method returns the size of the Separator.\n+     *\n+     * @return The size of the Separator.\n \t\t */\n-\t\tpublic Dimension getSeparatorSize() {\n-\t\t\treturn null; // TODO\n+    public Dimension getSeparatorSize()\n+    {\n+      return super.getPreferredSize();\n \t\t} // getSeparatorSize()\n \n \t\t/**\n-\t\t * setSeparatorSize\n-\t\t * @param size TODO\n+     * This method sets the size of the Separator.\n+     *\n+     * @param size The new size of the Separator.\n \t\t */\n-\t\tpublic void setSeparatorSize(Dimension size) {\n-\t\t\t// TODO\n+    public void setSeparatorSize(Dimension size)\n+    {\n+      setPreferredSize(size);\n \t\t} // setSeparatorSize()\n-\n-\n \t} // Separator\n \n-//        /**\n-//         * DefaultJToolBarLayout\n-//         */\n-//        private class DefaultJToolBarLayout {\n-//\n-//            private void DefaultJToolBarLayout() {\n-//            }\n-//\n-//            private LayoutManager getLayout() {\n-//                switch (JToolBar.this.getOrientation()) {\n-//                    case HORIZONTAL: setLayout(new GridLayout(1, 0, 4, 4));\n-//                                     break;\n-//                    case VERTICAL: setLayout(new GridLayout(0, 1, 4, 4));\n-//                                   break;\n-//                }\n-//            }\n-//        } // DefaultJToolBarLayout\n-\n-\n+  /** DOCUMENT ME! */\n     private static final long serialVersionUID = -1269915519555129643L;\n     \n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n+  /** Whether the JToolBar paints its border. */\n+  private transient boolean paintBorder = true;\n \n-\t/**\n-\t * uiClassID\n-\t */\n-\tprivate static final String uiClassID = \"ToolBarUI\";\n+  /** The extra insets around the JToolBar. */\n+  private transient Insets margin;\n \n-\t/**\n-\t * paintBorder\n-\t */\n-\tprivate boolean paintBorder;\n-\n-\t/**\n-\t * margin\n-\t */\n-\tprivate Insets margin;\n+  /** Whether the JToolBar can float (and be dragged around). */\n+  private transient boolean floatable = true;\n \n-\t/**\n-\t * floatable\n-\t */\n-\tprivate boolean floatable;\n+  /** Whether the buttons will have rollover borders. */\n+  private transient boolean rollover;\n \n-\t/**\n-\t * orientation\n-\t */\n+  /** The orientation of the JToolBar. */\n \tprivate int orientation = HORIZONTAL;\n \n-//        protected transient DefaultJToolBarLayout toolbarLayout;\n-\n-\t/** Fired in a PropertyChangeEvent when the \"orientation\" property changes.\n-\t*/\n+  /** Fired in a PropertyChangeEvent when the orientation property changes. */\n \tpublic static final String ORIENTATION_CHANGED_PROPERTY = \"orientation\";\n \n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n+  /** Fired in a PropertyChangeEvent when the floatable property changes. */\n+  public static final String FLOATABLE_CHANGED_PROPERTY = \"floatable\";\n+\n+  /** Fired in a PropertyChangeEvent when the borderPainted property changes. */\n+  public static final String BORDER_PAINTED_CHANGED_PROPERTY = \"borderPainted\";\n+\n+  /** Fired in a PropertyChangeEvent when the margin property changes. */\n+  public static final String MARGIN_CHANGED_PROPERTY = \"margin\";\n+\n+  /** Fired in a PropertyChangeEvent when the rollover property changes. */\n+  public static final String ROLLOVER_CHANGED_PROPERTY = \"rollover\";\n \n \t/**\n-\t * Constructor JToolBar\n+   * This method creates a new JToolBar object with horizontal orientation\n+   * and no name.\n \t */\n-\tpublic JToolBar() {\n-          this(null);\n+  public JToolBar()\n+  {\n+    this(null, HORIZONTAL);\n \t} // JToolBar()\n \n \t/**\n-\t * Constructor JToolBar\n+   * This method creates a new JToolBar with the given orientation and  no\n+   * name.\n+   *\n \t * @param orientation JToolBar orientation (HORIZONTAL or VERTICAL)\n \t */\n-\tpublic JToolBar(int orientation) {\n+  public JToolBar(int orientation)\n+  {\n           this(null, orientation);\n \t} // JToolBar()\n \n \t/**\n-\t * Constructor JToolBar\n+   * This method creates a new JToolBar object with the given name and\n+   * horizontal orientation.\n+   *\n \t * @param name Name assigned to undocked tool bar.\n \t */\n-\tpublic JToolBar(String name) {\n+  public JToolBar(String name)\n+  {\n           this(name, HORIZONTAL);\n \t} // JToolBar()\n \n \t/**\n-\t * Constructor JToolBar\n+   * This method creates a new JToolBar object with the given name and\n+   * orientation.\n+   *\n \t * @param name Name assigned to undocked tool bar.\n \t * @param orientation JToolBar orientation (HORIZONTAL or VERTICAL)\n \t */\n-\tpublic JToolBar(String name, int orientation) {\n+  public JToolBar(String name, int orientation)\n+  {\n \t        setName(name);\n-\t\tif (orientation != HORIZONTAL && orientation != VERTICAL)\n-\t\t\tthrow new IllegalArgumentException(orientation + \" is not a legal orientation\");\n-\t\tthis.orientation = orientation;\n-//                toolbarLayout = new DefaultJToolBarLayout();\n+    setOrientation(orientation);\n+    setLayout(new DefaultToolBarLayout());\n+    revalidate();\n                 updateUI();\t\n \t} // JToolBar()\n \n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * writeObject\n-\t * @param stream TODO\n-\t * @exception IOException TODO\n-\t */\n-\tprivate void writeObject(ObjectOutputStream stream) throws IOException {\n-\t\t// TODO\n-\t} // writeObject()\n-\n \t/**\n-\t * add\n-\t * @param action TODO\n-\t * @returns JButton\n+   * This method adds a new JButton that performs the given Action to the\n+   * JToolBar.\n+   *\n+   * @param action The Action to add to the JToolBar.\n+   *\n+   * @return The JButton that wraps the Action.\n \t */\n-\tpublic JButton add(Action action) {\n-\t\treturn null; // TODO\n+  public JButton add(Action action)\n+  {\n+    JButton b = createActionComponent(action);\n+    add(b);\n+    return b;\n \t} // add()\n \n \t/**\n-\t * paintBorder\n-\t * @param graphics TODO\n+   * This method paints the border if the borderPainted property is true.\n+   *\n+   * @param graphics The graphics object to paint with.\n \t */\n-\tprotected void paintBorder(Graphics graphics) {\n-\t\t// TODO\n+  protected void paintBorder(Graphics graphics)\n+  {\n+    if (paintBorder && isFloatable())\n+      super.paintBorder(graphics);\n \t} // paintBorder()\n \n \t/**\n-\t * getUI\n-\t * @returns ToolBarUI\n+   * This method returns the UI class used to paint this JToolBar.\n+   *\n+   * @return The UI class for this JToolBar.\n \t */\n-\tpublic ToolBarUI getUI() {\n-\t    System.out.println(\"ui = \" + ui);\n+  public ToolBarUI getUI()\n+  {\n \t\treturn (ToolBarUI) ui;\n \t} // getUI()\n \n \t/**\n-\t * setUI\n-\t * @param ui TODO\n+   * This method sets the UI used with the JToolBar.\n+   *\n+   * @param ui The UI used with the JToolBar.\n \t */\n-\tpublic void setUI(ToolBarUI ui) {\n+  public void setUI(ToolBarUI ui)\n+  {\n \t\tsuper.setUI(ui);\n \t} // setUI()\n \n \t/**\n-\t * updateUI\n+   * This method resets the UI used to the Look and Feel defaults.\n \t */\n-\tpublic void updateUI() {\n+  public void updateUI()\n+  {\n           setUI((ToolBarUI)UIManager.getUI(this));\n+    revalidate();\n+    repaint();\n \t} // updateUI()\n \n \t/**\n-\t * getUIClassID\n-\t * @returns String\n+   * This method returns the String identifier for the UI class to the used\n+   * with the JToolBar.\n+   *\n+   * @return The String identifier for the UI class.\n \t */\n-\tpublic String getUIClassID() {\n-\t\treturn uiClassID;\n+  public String getUIClassID()\n+  {\n+    return \"ToolBarUI\";\n \t} // getUIClassID()\n \n \t/**\n-\t * getComponentIndex\n-\t * @param component TODO\n-\t * @returns int\n+   * This method sets the rollover property for the JToolBar. In rollover\n+   * mode, JButtons inside the JToolBar will only display their borders when\n+   * the mouse is moving over them.\n+   *\n+   * @param b The new rollover property.\n \t */\n-\tpublic int getComponentIndex(Component component) {\n-\t\treturn 0; // TODO\n+  public void setRollover(boolean b)\n+  {\n+    if (b != rollover)\n+      {\n+\trollover = b;\n+\tfirePropertyChange(ROLLOVER_CHANGED_PROPERTY, ! rollover, rollover);\n+\trevalidate();\n+\trepaint();\n+      }\n+  }\n+\n+  /**\n+   * This method returns the rollover property.\n+   *\n+   * @return The rollover property.\n+   */\n+  public boolean isRollover()\n+  {\n+    return rollover;\n+  }\n+\n+  /**\n+   * This method returns the index of the given component.\n+   *\n+   * @param component The component to find.\n+   *\n+   * @return The index of the given component.\n+   */\n+  public int getComponentIndex(Component component)\n+  {\n+    Component[] components = getComponents();\n+    if (components == null)\n+      return -1;\n+\n+    for (int i = 0; i < components.length; i++)\n+      if (components[i] == component)\n+\treturn i;\n+\n+    return -1;\n \t} // getComponentIndex()\n \n \t/**\n-\t * getComponentAtIndex\n-\t * @param index TODO\n-\t * @returns Component\n+   * This method returns the component at the given index.\n+   *\n+   * @param index The index of the component.\n+   *\n+   * @return The component at the given index.\n \t */\n-\tpublic Component getComponentAtIndex(int index) {\n-\t\treturn null; // TODO\n+  public Component getComponentAtIndex(int index)\n+  {\n+    return getComponent(index);\n \t} // getComponentAtIndex()\n \n \t/**\n-\t * getMargin\n-\t * @returns Insets\n+   * This method returns the margin property.\n+   *\n+   * @return The margin property.\n \t */\n-\tpublic Insets getMargin() {\n-\t\treturn null; // TODO\n+  public Insets getMargin()\n+  {\n+    return margin;\n \t} // getMargin()\n \n \t/**\n-\t * setMargin\n-\t * @param margin TODO\n+   * This method sets the margin property. The margin property determines the\n+   * extra space between the children components of the JToolBar and the\n+   * border.\n+   *\n+   * @param margin The margin property.\n \t */\n-\tpublic void setMargin(Insets margin) {\n-\t\t// TODO\n+  public void setMargin(Insets margin)\n+  {\n+    if ((this.margin != null && margin == null)\n+        || (this.margin == null && margin != null)\n+        || (margin != null && this.margin != null\n+        && (margin.left != this.margin.left\n+        || margin.right != this.margin.right || margin.top != this.margin.top\n+        || margin.bottom != this.margin.bottom)))\n+      {\n+\tInsets oldMargin = this.margin;\n+\tthis.margin = margin;\n+\tfirePropertyChange(MARGIN_CHANGED_PROPERTY, oldMargin, this.margin);\n+\trevalidate();\n+\trepaint();\n+      }\n \t} // setMargin()\n \n \t/**\n-\t * isBorderPainted\n-\t * @returns boolean\n+   * This method returns the borderPainted property.\n+   *\n+   * @return The borderPainted property.\n \t */\n-\tpublic boolean isBorderPainted() {\n-\t\treturn false; // TODO\n+  public boolean isBorderPainted()\n+  {\n+    return paintBorder;\n \t} // isBorderPainted()\n \n \t/**\n-\t * setBorderPainted\n-\t * @param painted TODO\n+   * This method sets the borderPainted property. If set to false, the border\n+   * will not be painted.\n+   *\n+   * @param painted Whether the border will be painted.\n \t */\n-\tpublic void setBorderPainted(boolean painted) {\n-\t\t// TODO\n+  public void setBorderPainted(boolean painted)\n+  {\n+    if (painted != paintBorder)\n+      {\n+\tpaintBorder = painted;\n+\tfirePropertyChange(BORDER_PAINTED_CHANGED_PROPERTY, ! paintBorder,\n+\t                   paintBorder);\n+\trepaint();\n+      }\n \t} // setBorderPainted()\n \n \t/**\n-\t * isFloatable\n-\t * @returns boolean\n+   * This method returns the floatable property.\n+   *\n+   * @return The floatable property.\n \t */\n-\tpublic boolean isFloatable() {\n-\t\treturn false; // TODO\n+  public boolean isFloatable()\n+  {\n+    return floatable;\n \t} // isFloatable()\n \n \t/**\n-\t * setFloatable\n-\t * @param floatable TODO\n+   * This method sets the floatable property. If set to false, the JToolBar\n+   * cannot be dragged.\n+   *\n+   * @param floatable Whether the JToolBar can be dragged.\n \t */\n-\tpublic void setFloatable(boolean floatable) {\n-\t\t// TODO\n+  public void setFloatable(boolean floatable)\n+  {\n+    if (floatable != this.floatable)\n+      {\n+\tthis.floatable = floatable;\n+\tfirePropertyChange(FLOATABLE_CHANGED_PROPERTY, ! floatable, floatable);\n+      }\n \t} // setFloatable()\n \n \t/**\n-\t * getOrientation\n-\t * @returns int\n+   * This method returns the orientation of the JToolBar.\n+   *\n+   * @return The orientation of the JToolBar.\n \t */\n-\tpublic int getOrientation() {\n-\t\treturn this.orientation;\n+  public int getOrientation()\n+  {\n+    return orientation;\n \t} // getOrientation()\n \n \t/**\n-\t * setLayout\n-\t * @param mgr\n+   * This method sets the layout manager to be used with the JToolBar.\n+   *\n+   * @param mgr The Layout Manager used with the JToolBar.\n \t */\n-\tpublic void setLayout(LayoutManager mgr) {\n+  public void setLayout(LayoutManager mgr)\n+  {\n \t    super.setLayout(mgr);\n+    revalidate();\n+    repaint();\n \t} // setLayout()\n \n \t/**\n-\t * setOrientation\n-\t * @param orientation\n+   * This method sets the orientation property for JToolBar.\n+   *\n+   * @param orientation The new orientation for JToolBar.\n+   *\n+   * @throws IllegalArgumentException If the orientation is not HORIZONTAL or\n+   *         VERTICAL.\n \t */\n-\tpublic void setOrientation(int orientation) {\n+  public void setOrientation(int orientation)\n+  {\n \t\tif (orientation != HORIZONTAL && orientation != VERTICAL)\n-\t\t\tthrow new IllegalArgumentException(orientation + \" is not a legal orientation\");\n+      throw new IllegalArgumentException(orientation\n+                                         + \" is not a legal orientation\");\n \t    if (orientation != this.orientation)\n \t    {\n \t\tint oldOrientation = this.orientation;\n \t\tthis.orientation = orientation;\n \t\tfirePropertyChange(ORIENTATION_CHANGED_PROPERTY, oldOrientation,\n \t\t\tthis.orientation);\n+\trevalidate();\n+\trepaint();\n \t    }\n \t} // setOrientation()\n \n \t/**\n-\t * addSeparator\n+   * This method adds a Separator of default size to the JToolBar.\n \t */\n-\tpublic void addSeparator() {\n-\t\t// TODO\n+  public void addSeparator()\n+  {\n+    add(new Separator());\n \t} // addSeparator()\n \n \t/**\n-\t * addSeparator\n-\t * @param size TODO\n+   * This method adds a Separator with the given size to the JToolBar.\n+   *\n+   * @param size The size of the Separator.\n \t */\n-\tpublic void addSeparator(Dimension size) {\n-\t\t// TODO\n+  public void addSeparator(Dimension size)\n+  {\n+    add(new Separator(size));\n \t} // addSeparator()\n \n \t/**\n-\t * createActionComponent\n-\t * @param action TODO\n-\t * @returns JButton\n+   * This method is used to create JButtons which can be added to the JToolBar\n+   * for the given action.\n+   *\n+   * @param action The action to create a JButton for.\n+   *\n+   * @return The JButton created from the action.\n \t */\n-\tprotected JButton createActionComponent(Action action) {\n-\t\treturn null; // TODO\n+  protected JButton createActionComponent(Action action)\n+  {\n+    return new JButton(action);\n \t} // createActionComponent()\n \n \t/**\n-\t * createActionChangeListener\n-\t * @param button TODO\n-\t * @returns PropertyChangeListener\n+   * This method creates a pre-configured PropertyChangeListener which updates\n+   * the control as changes are made to the Action. However, this is no\n+   * longer the recommended way of adding Actions to Containers. As such,\n+   * this method returns null.\n+   *\n+   * @param button The JButton to configure a PropertyChangeListener for.\n+   *\n+   * @return null.\n \t */\n-\tprotected PropertyChangeListener createActionChangeListener(JButton button) {\n-\t\treturn null; // TODO\n+  protected PropertyChangeListener createActionChangeListener(JButton button)\n+  {\n+    // XXX: As specified, this returns null. But seems kind of strange, usually deprecated methods don't just return null, verify!\n+    return null;\n \t} // createActionChangeListener()\n \n \t/**\n-\t * addImpl\n-\t * @param component TODO\n-\t * @param constraints TODO\n-\t * @param index TODO\n-\t */\n-  /*\n-\tprotected void addImpl(Component component, Object constraints, int index) {\n-\t\t// TODO\n-\t} // addImpl()\n+   * This method overrides Container's addImpl method. If a JButton is added,\n+   * it is disabled.\n+   *\n+   * @param component The Component to add.\n+   * @param constraints The Constraints placed on the component.\n+   * @param index The index to place the Component at.\n   */\n+  protected void addImpl(Component component, Object constraints, int index)\n+  {\n+    // XXX: Sun says disable button but test cases show otherwise.\n+    super.addImpl(component, constraints, index);\n+  } // addImpl()\n+\n \t/**\n-\t * paramString\n-\t * @returns String\n+   * This method returns a String description of the JToolBar.\n+   *\n+   * @return A String description of the JToolBar.\n \t */\n-\tprotected String paramString() {\n-\t\treturn null; // TODO\n+  protected String paramString()\n+  {\n+    return \"JToolBar\";\n \t} // paramString()\n \n   /**\n    * getAccessibleContext\n+   *\n    * @return AccessibleContext\n    */\n   public AccessibleContext getAccessibleContext()"}, {"sha": "4e81bff8422928aed9a48cb8d484942a035fa49b", "filename": "libjava/javax/swing/JTree.java", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJTree.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJTree.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJTree.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -50,6 +50,7 @@\n import javax.swing.event.TreeWillExpandListener;\n import javax.swing.plaf.TreeUI;\n import javax.swing.tree.ExpandVetoException;\n+import javax.swing.tree.TreeCellRenderer;\n import javax.swing.tree.TreeModel;\n import javax.swing.tree.TreeNode;\n import javax.swing.tree.TreePath;\n@@ -60,6 +61,10 @@ public class JTree extends JComponent\n {\n   private static final long serialVersionUID = 7559816092864483649L;\n \n+  protected TreeCellRenderer cellRenderer;\n+  protected boolean editable;\n+  protected boolean rootVisible;\n+  protected boolean showsRootHandles;\n   protected TreeModel treeModel;\n \n   /**\n@@ -142,31 +147,59 @@ protected static TreeModel createTreeModel(Object value)\n     return null;\n   }\n \n+  /**\n+   * Return the UI associated with this <code>JTree</code> object.\n+   *\n+   * @return the associated <code>TreeUI</code> object\n+   */\n   public TreeUI getUI()\n   {\n     return (TreeUI) ui;\n   }\n \n+  /**\n+   * Sets the UI associated with this <code>JTree</code> object.\n+   *\n+   * @param ui the <code>TreeUI</code> to associate\n+   */\n   public void setUI(TreeUI ui)\n   {\n     super.setUI(ui);\n   }\n \n+  /**\n+   * This method resets the UI used to the Look and Feel defaults..\n+   */\n   public void updateUI()\n   {\n     setUI((TreeUI) UIManager.getUI(this));\n   }\n \n+  /**\n+   * This method returns the String ID of the UI class of  Separator.\n+   *\n+   * @return The UI class' String ID.\n+   */\n   public String getUIClassID()\n   {\n     return \"TreeUI\";\n   }\n \n+  /**\n+   * Gets the AccessibleContext associated with this <code>JToggleButton</code>.\n+   *\n+   * @return the associated context\n+   */\n   public AccessibleContext getAccessibleContext()\n   {\n     return null;\n   }\n \n+  /**\n+   * Returns the preferred viewport size..\n+   *\n+   * @return the preferred size\n+   */\n   public Dimension getPreferredScrollableViewportSize()\n   {\n     return null;\n@@ -354,4 +387,87 @@ public void fireTreeWillExpand(TreePath path)\n     for (int index = 0; index < listeners.length; ++index)\n       listeners[index].treeWillExpand(event);\n   }\n+\n+  /**\n+   * Returns the model of this <code>JTree</code> object.\n+   *\n+   * @return the associated <code>TreeModel</code>\n+   */\n+  public TreeModel getModel()\n+  {\n+    return treeModel;\n+  }\n+\n+  /**\n+   * Sets the model to use in <code>JTree</object>.\n+   *\n+   * @param model the <code>TreeModel</code> to use\n+   */\n+  public void setModel(TreeModel model)\n+  {\n+    treeModel = model;\n+  }\n+\n+  /**\n+   * Checks if this <code>JTree</code> object is editable.\n+   *\n+   * @return <code>true</code> if this tree object is editable,\n+   * <code>false</code> otherwise\n+   */\n+  public boolean isEditable()\n+  {\n+    return editable;\n+  }\n+\n+  /**\n+   * Sets the <code>editable</code> property.\n+   *\n+   * @param flag <code>true</code> to make this tree object editable,\n+   * <code>false</code> otherwise\n+   */\n+  public void setEditable(boolean flag)\n+  {\n+    if (editable == flag)\n+      return;\n+\n+    boolean oldValue = editable;\n+    editable = flag;\n+    firePropertyChange(\"editable\", oldValue, editable);\n+  }\n+\n+  /**\n+   * Checks if the root element is visible.\n+   *\n+   * @return <code>true</code> if the root element is visible,\n+   * <code>false</code> otherwise\n+   */\n+  public boolean isRootVisbile()\n+  {\n+    return rootVisible;\n+  }\n+\n+  public void setRootVisible(boolean flag)\n+  {\n+    rootVisible = flag;\n+  }\n+\n+  public boolean getShowsRootHandles()\n+  {\n+    return showsRootHandles;\n+  }\n+\n+  public void setShowRootHandles(boolean flag)\n+  {\n+    showsRootHandles = flag;\n+  }\n+\n+  public TreeCellRenderer getCellRenderer()\n+  {\n+    return cellRenderer;\n+  }\n+  \n+  public void setCellRenderer(TreeCellRenderer newRenderer)\n+  {\n+    cellRenderer = newRenderer;\n+  }\n }"}, {"sha": "47ccdf7097f729ff09afefed5dcca2f266956e15", "filename": "libjava/javax/swing/JViewport.java", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJViewport.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJViewport.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJViewport.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -327,11 +327,19 @@ public void removeChangeListener(ChangeListener listener)\n     listenerList.remove(ChangeListener.class, listener);\n   }\n \n+  /**\n+   * This method returns the String ID of the UI class of  Separator.\n+   *\n+   * @return The UI class' String ID.\n+   */\n   public String getUIClassID()\n   {\n     return \"ViewportUI\";\n   }\n \n+  /**\n+   * This method resets the UI used to the Look and Feel defaults..\n+   */\n   public void updateUI()\n   {\n     setUI((ViewportUI) UIManager.getUI(this));"}, {"sha": "c035a1bd9cc340f3ecdf288bfe58a53024bb0e6b", "filename": "libjava/javax/swing/JWindow.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJWindow.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FJWindow.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJWindow.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -82,7 +82,7 @@ public class JWindow extends Window implements Accessible, RootPaneContainer\n \n     public JWindow()\n     {      \n-     \tsuper(null); // FIXME: This throws an exception.\n+      super(SwingUtilities.getOwnerFrame());\n     }\n \n     // huuu ?"}, {"sha": "dc28065c373b2cff98effea88a588bc57962d0e5", "filename": "libjava/javax/swing/LookAndFeel.java", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FLookAndFeel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FLookAndFeel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FLookAndFeel.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -37,6 +37,8 @@\n \n package javax.swing;\n \n+import java.awt.Component;\n+import java.awt.Toolkit;\n import javax.swing.text.JTextComponent;\n \n \n@@ -59,6 +61,20 @@ public UIDefaults getDefaults()\n \n   public abstract String getName();\n \n+  /**\n+   * Returns true when the Look and Feel supports window decorations,\n+   * false others. This method returns always false and needs to be overwritten\n+   * when the derived Look and Feel supports this.\n+   *\n+   * @return false\n+   *\n+   * @since 1.4\n+   */\n+  public boolean getSupportsWindowDecorations()\n+  {\n+    return false;\n+  }\n+  \n   /**\n    * UIManager.setLookAndFeel calls this method before the first call\n    * (and typically the only call) to getDefaults(). \n@@ -140,6 +156,18 @@ public static JTextComponent.KeyBinding[] makeKeyBindings(Object[] keyBindingLis\n     return null;\n   }\n \n+  /**\n+   * Invoked when the user attempts an invalid operation. The default implement\n+   * just beeps. Subclasses that wish to change this need to override this\n+   * method.\n+   *\n+   * @param component the component the error occured in\n+   */\n+  public void provideErrorFeedback(Component component)\n+  {\n+    Toolkit.getDefaultToolkit().beep();\n+  }\n+\n   /**\n    * Returns a string that displays and identifies this object's properties.\n    *"}, {"sha": "a61ca4ec51a4a7bf2f6992ab89e5302ac4ef1985", "filename": "libjava/javax/swing/MenuSelectionManager.java", "status": "modified", "additions": 90, "deletions": 23, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FMenuSelectionManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FMenuSelectionManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FMenuSelectionManager.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -38,6 +38,7 @@\n package javax.swing;\n \n import java.awt.Component;\n+import java.awt.Dimension;\n import java.awt.Point;\n import java.awt.event.KeyEvent;\n import java.awt.event.MouseEvent;\n@@ -124,24 +125,56 @@ public void clearSelectedPath()\n     for (int i = selectedPath.size() - 1; i >= 0; i--)\n       ((MenuElement) selectedPath.get(i)).menuSelectionChanged(false);\n \n-    // notify all listeners that the selected path was changed    \n-    fireStateChanged();\n-\n     // clear selected path\n     selectedPath.clear();\n+\n+    // notify all listeners that the selected path was changed    \n+    fireStateChanged();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method returns menu element on the selected path that contains\n+   * given source point. If no menu element on the selected path contains this\n+   * point, then null is returned.\n    *\n-   * @param source DOCUMENT ME!\n-   * @param sourcePoint DOCUMENT ME!\n+   * @param source Component relative to which sourcePoint is given\n+   * @param sourcePoint point for which we want to find menu element that contains it\n    *\n-   * @return DOCUMENT ME!\n+   * @return Returns menu element that contains given source point and belongs\n+   * to the currently selected path. Null is return if no such menu element found.\n    */\n   public Component componentForPoint(Component source, Point sourcePoint)\n   {\n-    throw new UnsupportedOperationException(\"not implemented\");\n+    // Convert sourcePoint to screen coordinates.\n+    Point sourcePointOnScreen = sourcePoint;\n+    SwingUtilities.convertPointToScreen(sourcePointOnScreen, source);\n+\n+    Point compPointOnScreen;\n+    Component resultComp = null;\n+\n+    // For each menu element on the selected path, express its location \n+    // in terms of screen coordinates and check if there is any \n+    // menu element on the selected path that contains given source point.\n+    for (int i = 0; i < selectedPath.size(); i++)\n+      {\n+\tComponent comp = ((Component) selectedPath.get(i));\n+        Dimension size = comp.getSize();\n+\n+\t// convert location of this menu item to screen coordinates\n+\tcompPointOnScreen = comp.getLocationOnScreen();\n+\n+\tif (compPointOnScreen.x <= sourcePointOnScreen.x\n+\t    && sourcePointOnScreen.x < compPointOnScreen.x + size.width\n+\t    && compPointOnScreen.y <= sourcePointOnScreen.y\n+\t    && sourcePointOnScreen.y < compPointOnScreen.y + size.height)\n+\t  {\n+\t    Point p = sourcePointOnScreen;\n+\t    SwingUtilities.convertPointFromScreen(p, comp);\n+\t    resultComp = SwingUtilities.getDeepestComponentAt(comp, p.x, p.y);\n+\t    break;\n+\t  }\n+      }\n+    return resultComp;\n   }\n \n   /**\n@@ -176,7 +209,7 @@ public MenuElement[] getSelectedPath()\n    * @param c Component for which to check\n    * @return True if specified component is part of current menu\n    */\n-  boolean isComponentPartOfCurrentMenu(Component c)\n+  public boolean isComponentPartOfCurrentMenu(Component c)\n   {\n     MenuElement[] subElements;\n     for (int i = 0; i < selectedPath.size(); i++)\n@@ -209,19 +242,42 @@ public void processKeyEvent(KeyEvent e)\n    */\n   public void processMouseEvent(MouseEvent event)\n   {\n-    Component c = ((Component) event.getSource());\n+    Component source = ((Component) event.getSource());\n+\n+    // In the case of drag event, event.getSource() returns component\n+    // where drag event originated. However menu element processing this \n+    // event should be the one over which mouse is currently located, \n+    // which is not necessary the source of the drag event.     \n+    Component mouseOverMenuComp;\n+\n+    // find over which menu element the mouse is currently located\n+    if (event.getID() == MouseEvent.MOUSE_DRAGGED\n+        || event.getID() == MouseEvent.MOUSE_RELEASED)\n+      mouseOverMenuComp = componentForPoint(source, event.getPoint());\n+    else\n+      mouseOverMenuComp = source;\n+\n+    // Process this event only if mouse is located over some menu element\n+    if (mouseOverMenuComp != null && (mouseOverMenuComp instanceof MenuElement))\n+      {\n+\tMenuElement[] path = getPath(mouseOverMenuComp);\n+\t((MenuElement) mouseOverMenuComp).processMouseEvent(event, path,\n+\t                                                    manager);\n \n-    MenuElement[] path = getPath(c);\n-    ((MenuElement) c).processMouseEvent(event, path, manager);\n+\t// FIXME: Java specification says that mouse events should be\n+\t// forwarded to subcomponents. The code below does it, but\n+\t// menu's work fine without it. This code is commented for now.\t  \n \n-    // forward events to subcomponents \n-    MenuElement[] subComponents = ((MenuElement) c).getSubElements();\n+\t/*\n+\tMenuElement[] subComponents = ((MenuElement) mouseOverMenuComp)\n+\t                              .getSubElements();\n \n     for (int i = 0; i < subComponents.length; i++)\n       {\n-\tif (subComponents[i] instanceof JMenuItem)\n \t  subComponents[i].processMouseEvent(event, path, manager);\n       }\n+\t*/\n+      }\n   }\n \n   /**\n@@ -237,13 +293,13 @@ public void setSelectedPath(MenuElement[] path)\n \treturn;\n       }\n \n-    fireStateChanged();\n-\n     int i;\n     int minSize = path.length; // size of the smaller path. \n \n     if (path.length > selectedPath.size())\n       {\n+\tminSize = selectedPath.size();\n+\n \t// if new selected path contains more elements then current\n \t// selection then first add all elements at \n \t// the indexes > selectedPath.size \n@@ -252,8 +308,6 @@ public void setSelectedPath(MenuElement[] path)\n \t    selectedPath.add(path[i]);\n \t    path[i].menuSelectionChanged(true);\n \t  }\n-\n-\tminSize = selectedPath.size();\n       }\n \n     else if (path.length < selectedPath.size())\n@@ -274,19 +328,21 @@ else if (path.length < selectedPath.size())\n     // same location and adjust selection until \n     // same menu elements will be encountered at the\n     // same index in both current and new selection path.\n-    MenuElement oldSelectedPath;\n+    MenuElement oldSelectedItem;\n \n     for (i = minSize - 1; i >= 0; i--)\n       {\n-\toldSelectedPath = (MenuElement) selectedPath.get(i);\n+\toldSelectedItem = (MenuElement) selectedPath.get(i);\n \n-\tif (path[i].equals(oldSelectedPath))\n+\tif (path[i].equals(oldSelectedItem))\n \t  break;\n \n-\toldSelectedPath.menuSelectionChanged(false);\n+\toldSelectedItem.menuSelectionChanged(false);\n \tpath[i].menuSelectionChanged(true);\n \tselectedPath.setElementAt(path[i], i);\n       }\n+\n+    fireStateChanged();\n   }\n \n   /**\n@@ -298,7 +354,18 @@ else if (path.length < selectedPath.size())\n    */\n   private MenuElement[] getPath(Component c)\n   {\n+    // FIXME: There is the same method in BasicMenuItemUI. However I\n+    // cannot use it here instead of this method, since I cannot assume that \n+    // all the menu elements on the selected path are JMenuItem or JMenu.\n+    // For now I've just duplicated it here. Please \n+    // fix me or delete me if another better approach will be found, and \n+    // this method will not be necessary.\n     ArrayList path = new ArrayList();\n+\n+    // if given component is JMenu, we also need to include \n+    // it's popup menu in the path \n+    if (c instanceof JMenu)\n+      path.add(((JMenu) c).getPopupMenu());\n     while (c instanceof MenuElement)\n       {\n \tpath.add(0, (MenuElement) c);"}, {"sha": "05b974f914c70b1b7c65bb55c9f0ffb0747f9666", "filename": "libjava/javax/swing/RepaintManager.java", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FRepaintManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FRepaintManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FRepaintManager.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -252,16 +252,22 @@ public static void setCurrentManager(RepaintManager manager)\n    */\n   public synchronized void addInvalidComponent(JComponent component)\n   {\n-    while ((component.getParent() != null)\n-           && (component.getParent() instanceof JComponent)\n-           && (component.isValidateRoot()))\n-      component = (JComponent) component.getParent();\n+    Component ancestor = component.getParent();\n+\n+    while (ancestor != null\n+           && (! (ancestor instanceof JComponent)\n+               || ! ((JComponent) ancestor).isValidateRoot() ))\n+      ancestor = ancestor.getParent();\n+\n+    if (ancestor != null\n+        && ancestor instanceof JComponent\n+        && ((JComponent) ancestor).isValidateRoot())\n+      component = (JComponent) ancestor;\n     \n     if (invalidComponents.contains(component))\n       return;\n \n     invalidComponents.add(component);\n-    component.invalidate();\n     \n     if (! repaintWorker.isLive())\n       {"}, {"sha": "5e51e1895eb436cec3dfcb202bf5633f2b07368e", "filename": "libjava/javax/swing/ScrollPaneLayout.java", "status": "modified", "additions": 78, "deletions": 49, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FScrollPaneLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FScrollPaneLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FScrollPaneLayout.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -44,6 +44,7 @@\n import java.awt.Insets;\n import java.awt.LayoutManager;\n import java.awt.Rectangle;\n+import java.awt.Point;\n import java.io.Serializable;\n import javax.swing.border.Border;\n \n@@ -197,9 +198,27 @@ else if (key == UPPER_LEFT_CORNER)\n     return null;\n   }\n \n+  private static void maybeSetPreferredSize(JComponent src, Dimension dim)\n+  {\n+    Dimension tmp = null;\n+    if (src != null)\n+      tmp = src.getPreferredSize();\n+    if (tmp != null)\n+      dim.setSize(tmp);        \n+  }\n+\n+  private static void maybeSetMinimumSize(JComponent src, Dimension dim)\n+  {\n+    Dimension tmp = null;\n+    if (src != null)\n+      tmp = src.getMinimumSize();\n+    if (tmp != null)\n+      dim.setSize(tmp);\n+  }\n+\n   public Dimension preferredLayoutSize(Container parent) \n   {\n-    if (parent instanceof JScrollPane)\n+    if (parent != null && parent instanceof JScrollPane)\n       {\n         JScrollPane sc = (JScrollPane) parent;\n         synchronized (sc.getTreeLock ())\n@@ -217,36 +236,38 @@ public Dimension preferredLayoutSize(Container parent)\n             Insets viewportInsets = null;\n \n             if (viewportBorder != null)\n+              {\n               viewportInsets = viewportBorder.getBorderInsets(parent);\n+                if (viewportInsets != null)\n+                  viewportInsetsSize.setSize(viewportInsets.left + viewportInsets.right,\n+                                             viewportInsets.top + viewportInsets.bottom);\n+              }\n \n             if (insets != null)\n               insetsSize.setSize(insets.left + insets.right,\n                                  insets.top + insets.bottom);\n \n             if (viewport != null)\n-              viewportSize.setSize(viewport.getPreferredSize());\n-\n-            if (colHead != null)\n-              columnHeaderSize.setSize(colHead.getPreferredSize());\n-            \n-            if (rowHead != null)\n-              rowHeaderSize.setSize(rowHead.getPreferredSize());\n-\n-            if (vsb != null)\n-              verticalScrollBarSize.setSize(vsb.getPreferredSize());\n-\n-            if (hsb != null)\n-              horizontalScrollBarSize.setSize(hsb.getPreferredSize());\n-\n-            /*\n-            System.err.println(\"widths: [vp=\" + viewportSize.width +\n-                               \", h=\" + columnHeaderSize.width +\n-                               \", sc=\" + horizontalScrollBarSize.width + \"]\");\n-\n-            System.err.println(\"heights: [vp=\" + viewportSize.height +\n-                               \", h=\" + rowHeaderSize.height +\n-                               \", sc=\" + verticalScrollBarSize.height + \"]\");                    \n-            */\n+              {\n+                Component view = null;\n+                Scrollable scr = null;\n+                Dimension pref = null;\n+                \n+                view = viewport.getView();\n+                if (view != null && view instanceof Scrollable)\n+                  scr = (Scrollable) view;\n+                if (scr != null)\n+                  pref = scr.getPreferredScrollableViewportSize();\n+                if (pref == null)\n+                  pref = viewport.getPreferredSize();\n+                if (pref != null)\n+                  viewportSize.setSize(pref);\n+              }\n+                       \n+            maybeSetPreferredSize(colHead, columnHeaderSize);\n+            maybeSetPreferredSize(rowHead, rowHeaderSize);\n+            maybeSetPreferredSize(vsb, verticalScrollBarSize);\n+            maybeSetPreferredSize(hsb, horizontalScrollBarSize);\n \n             return new Dimension(insetsSize.width \n                                  + viewportSize.width\n@@ -286,28 +307,26 @@ public Dimension minimumLayoutSize(Container parent)\n             Insets viewportInsets = null;\n \n             if (viewportBorder != null)\n+              {\n               viewportInsets = viewportBorder.getBorderInsets(parent);\n+                if (viewportInsets != null)\n+                  viewportInsetsSize.setSize(viewportInsets.left + viewportInsets.right,\n+                                             viewportInsets.top + viewportInsets.bottom);\n+              }\n \n             if (insets != null)\n               insetsSize.setSize(insets.left + insets.right,\n                                  insets.top + insets.bottom);\n \n-            if (viewport != null)\n-              viewportSize.setSize(viewport.getMinimumSize());\n-\n-            if (colHead != null)\n-              columnHeaderSize.setSize(colHead.getMinimumSize());\n-            \n-            if (rowHead != null)\n-              rowHeaderSize.setSize(rowHead.getMinimumSize());\n+            maybeSetMinimumSize(viewport, viewportSize);\n+            maybeSetMinimumSize(colHead, columnHeaderSize);\n+            maybeSetMinimumSize(rowHead, rowHeaderSize);\n \n-            if (vsb != null\n-                && vsbPolicy != VERTICAL_SCROLLBAR_NEVER)\n-              verticalScrollBarSize.setSize(vsb.getMinimumSize());\n+            if (vsbPolicy != VERTICAL_SCROLLBAR_NEVER)\n+              maybeSetMinimumSize(vsb, verticalScrollBarSize);\n \n-            if (hsb != null \n-                && hsbPolicy != HORIZONTAL_SCROLLBAR_NEVER)\n-              horizontalScrollBarSize.setSize(hsb.getMinimumSize());\n+            if (hsbPolicy != HORIZONTAL_SCROLLBAR_NEVER)\n+              maybeSetMinimumSize(hsb, horizontalScrollBarSize);\n             \n             return new Dimension(insetsSize.width \n                                  + viewportSize.width\n@@ -355,14 +374,15 @@ public void layoutContainer(Container parent)\n         JScrollPane sc = (JScrollPane) parent;\n         synchronized (sc.getTreeLock ())\n           {\n-            Rectangle scrollPaneBounds = sc.getBounds();\n             JViewport viewport = sc.getViewport();\n-            Dimension viewportSize = viewport.getSize();\n-            Dimension viewSize = viewport.getView().getSize(); \n+            Dimension viewSize = viewport.getViewSize(); \n+            Point viewPos = viewport.getViewPosition(); \n \n             int x1 = 0, x2 = 0, x3 = 0, x4 = 0;\n             int y1 = 0, y2 = 0, y3 = 0, y4 = 0;\n \n+            Rectangle scrollPaneBounds = SwingUtilities.calculateInnerArea(sc, null);\n+\n             x1 = scrollPaneBounds.x;\n             y1 = scrollPaneBounds.y;\n             x4 = scrollPaneBounds.x + scrollPaneBounds.width;\n@@ -381,26 +401,25 @@ public void layoutContainer(Container parent)\n             int vsbPolicy = sc.getVerticalScrollBarPolicy();\n             int hsbPolicy = sc.getHorizontalScrollBarPolicy();\n \n+            x3 = x4 - vsb.getPreferredSize().width;\n+            y3 = y4 - hsb.getPreferredSize().height;\n+\n             boolean showVsb = \n               (vsb != null)\n               && ((vsbPolicy == VERTICAL_SCROLLBAR_ALWAYS)\n                   || (vsbPolicy == VERTICAL_SCROLLBAR_AS_NEEDED \n-                      && viewSize.height > viewportSize.height));\n+                      && viewSize.height > (y3 - y2)));\n \n             boolean showHsb = \n               (hsb != null)\n               && ((hsbPolicy == HORIZONTAL_SCROLLBAR_ALWAYS)\n                   || (hsbPolicy == HORIZONTAL_SCROLLBAR_AS_NEEDED \n-                      && viewSize.width > viewportSize.width));\n+                      && viewSize.width > (x3 - x2)));\n             \n-            if (showVsb)\n-              x3 = x4 - vsb.getPreferredSize().width;\n-            else\n+            if (!showVsb)\n               x3 = x4;\n \n-            if (showHsb)\n-              y3 = y4 - hsb.getPreferredSize().height;\n-            else\n+            if (!showHsb)\n               y3 = y4;\n \n             // now set the layout\n@@ -415,10 +434,20 @@ public void layoutContainer(Container parent)\n               rowHead.setBounds(new Rectangle(x1, y2, x2-x1, y3-y2));\n \n             if (showVsb)\n+              {\n+                vsb.setVisible(true);\n \t      vsb.setBounds(new Rectangle(x3, y2, x4-x3, y3-y2));\n+              }\n+            else if (vsb != null)\n+              vsb.setVisible(false);\n \n             if (showHsb)\n+              {\n+                hsb.setVisible(true);\n               hsb.setBounds(new Rectangle(x2, y3, x3-x2, y4-y3));\n+              }\n+            else if (hsb != null)\n+              hsb.setVisible(false);\n \n             if (upperLeft != null)\n               upperLeft.setBounds(new Rectangle(x1, y1, x2-x1, y2-y1));"}, {"sha": "aa47e20e196a09c72cf18e18d5f4aaf14a8dd8bf", "filename": "libjava/javax/swing/Spring.java", "status": "added", "additions": 580, "deletions": 0, "changes": 580, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FSpring.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FSpring.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FSpring.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -0,0 +1,580 @@\n+/* Spring.java -- \n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing;\n+\n+/**\n+ * Calculates the space between component edges, that are layed out by\n+ * {@link SpringLayout}.\n+ * <p>\n+ * A Spring defines a minimum, preferred and maximum distance for each edge\n+ * (north, east, south, west) of a component.\n+ * </p>\n+ * However, springs are not static, their actual values are computed at\n+ * runtime. That means, if a Spring C is defined as the sum of Spring A and\n+ * Spring B, then the values (min, pref and max) are not calculated at\n+ * creation of Spring C, but instead always when {@link #getValue} is\n+ * called. So, when Spring A or Spring B changes, this is reflected in\n+ * Spring C.\n+ *\n+ * @author Roman Kennke (roman@ontographics.com)\n+ */\n+public abstract class Spring\n+{\n+\n+  /** Indicates a not-set value. **/\n+  public static final int UNSET = -2147483648;\n+\n+  /**\n+   * Creates a new Spring object. This constructor is used by the static\n+   * methods which create Springs.\n+   */\n+  protected Spring()\n+  {\n+  }\n+\n+  /**\n+   * Creates a Spring which min, pref and max values are all the same.\n+   * These kind of Springs are 'struts'.\n+   *\n+   * @param val the constant for min, pref and max values.\n+   * @return a Spring object with constant values for min, pref and max.\n+   */\n+  public static Spring constant(int val)\n+  {\n+    return new SimpleSpring(val, val, val);\n+  }\n+\n+  /** Creates a Spring which min, pref and max values are constants.\n+   * @param min the constant for the minimum value.\n+   * @param pref the constant for the preferred value.\n+   * @param max the constant for the maximum value.\n+   * @return a Spring object with constant values for min, pref and max.\n+   */\n+  public static Spring constant(int min, int pref, int max)\n+  {\n+    return new SimpleSpring(min, pref, max);\n+  }\n+\n+  /**\n+   * Returns the maximum value of the Spring.\n+   *\n+   * @return the maximum value.\n+   */\n+  public abstract int getMaximumValue();\n+\n+  /**\n+   * Returns the minimum value of this Spring.\n+   *\n+   * @return the minimum value.\n+   */\n+  public abstract int getMinimumValue();\n+\n+  /**\n+   * Return the preferred value of this Spring.\n+   *\n+   * @return the preferred value.\n+   */\n+  public abstract int getPreferredValue();\n+\n+  /**\n+   * Return the actual value of this Spring.\n+   *\n+   * @return the actual value of this Spring.\n+   */\n+  public abstract int getValue();\n+\n+  /**\n+   * Creates and returns a Spring, which always has the maximum values\n+   * min = max(min_s1, min_s2), pref = max(pref_s1, pref_s2), max =\n+   * max(max_s1, max_s2).\n+   *\n+   * @param s1 the first summand of the max Spring.\n+   * @param s2 the second summand of the max Spring.\n+   * @return a Spring which is max(s1, s2).\n+   */\n+  public static Spring max(Spring s1, Spring s2)\n+  {\n+    return new MaxSpring(s1, s2);\n+  }\n+\n+  /**\n+   * Creates and returns a Spring, which is always the negation of s.\n+   * min = -min_s, pref = -pref_s, max = -max_pref.\n+   *\n+   * @param s the Spring to be negated.\n+   * @return the negative of <code>s</code>.\n+   */\n+  public static Spring minus(Spring s)\n+  {\n+    return new MinusSpring(s);\n+  }\n+\n+  /**\n+   * Sets the actual value. If <code>value</code> is out of the (min, max)\n+   * bounds, then the value is adjusted, so that is inside these bounds.\n+   *\n+   * @param value the value to be set.\n+   */\n+  public abstract void setValue(int value);\n+\n+  /**\n+   * Creates and returns a Spring, which is always the sum of s1 and s2.\n+   * min_sum = min_s1 + min_s2, pref_sum = pref_s1 + pref_s2, max_sum =\n+   * max_s1 + max_s2.\n+   *\n+   * @param s1 the 1st summand of the sum Spring.\n+   * @param s2 the 2nd summand of the sum Spring.\n+   * @return a sum which is <code>s1 + s2</code>.\n+   */\n+  public static Spring sum(Spring s1, Spring s2)\n+  {\n+    return new AddSpring(s1, s2);\n+  }\n+\n+  /**\n+   * A simple Spring, that holds constant values for min, pref and max.\n+   *\n+   * @author Roman Kennke (roman@ontographics.com)\n+   */\n+  private static final class SimpleSpring extends Spring\n+  {\n+\n+    /** The constant value for min. */\n+    private final int min;\n+\n+    /** The constant value for pref. */\n+    private final int pref;\n+\n+    /** The constant value for max. */\n+    private final int max;\n+\n+    /** The actual value of the spring. */\n+    private int value;\n+\n+    /**\n+     * Creates a new SimpleSpring object.\n+     *\n+     * @param min the constant minimum value.\n+     * @param pref the constant preferred value.\n+     * @param max the constant maximum value.\n+     */\n+    public SimpleSpring(int newMin, int newPref, int newMax)\n+    {\n+      min = newMin;\n+      pref = newPref;\n+      max = newMax;\n+      value = Spring.UNSET;\n+    }\n+\n+    /**\n+     * Returns the maximum value of this Spring.\n+     *\n+     * @return the maximum value.\n+     */\n+    public int getMaximumValue()\n+    {\n+      return max;\n+    }\n+\n+    /**\n+     * Returns the minimum value of this Spring.\n+     *\n+     * @return the minimum value.\n+     */\n+    public int getMinimumValue()\n+    {\n+      return min;\n+    }\n+\n+    /**\n+     * Returns the preferred value of this Spring.\n+     *\n+     * @return the preferred value.\n+     */\n+    public int getPreferredValue()\n+    {\n+      return pref;\n+    }\n+\n+    /**\n+     * Return the actual current value of this Spring.\n+     *\n+     * @return the current value.\n+     */\n+    public int getValue()\n+    {\n+\n+      if (value == Spring.UNSET)\n+        {\n+          value = pref;\n+        }\n+\t    \n+      return value;\n+    }\n+\t\n+    /**\n+     * Sets the current value.\n+     *\n+     * @param val the value to be set.\n+     */\n+    public void setValue(int val)\n+    {\n+\n+      if (val > max)\n+        {\n+          value = max;\n+\t}\n+      else if (val < min)\n+        {\n+          value = min;\n+\t}\n+      else\n+        {\n+          value = val;\n+        }\n+    }\n+\n+  }\n+\n+\n+  /**\n+   * A Spring, that is the sum of two other Springs.\n+   *\n+   * @author Roman Kennke (roman@ontographics.com)\n+   */\n+  private static final class AddSpring extends Spring\n+  {\n+\n+    /** The springs, that are the 'operands' of this Spring. */\n+    private final Spring s1;\n+    private final Spring s2;\n+\n+    /** The current value for this Spring. */\n+    private int value;\n+\n+    /**\n+     * Creates a new AddSpring object.\n+     *\n+     * @param s1 the first operand.\n+     * @param s2 the second operand.\n+     */\n+    protected AddSpring(Spring s1, Spring s2)\n+    {\n+      super();\n+      this.s1 = s1;\n+      this.s2 = s2;\n+      value = Spring.UNSET;\n+    }\n+\n+    /**\n+     * Returns the maximum value of this Spring.\n+     *\n+     * @return the maximum value.\n+     */\n+    public int getMaximumValue()\n+    {\n+      int max1 = s1.getMaximumValue();\n+      int max2 = s2.getMaximumValue();\n+      return max1 + max2;\n+    }\n+\n+    /**\n+     * Return the minimum value of this Spring.\n+     *\n+     * @return the minimum value.\n+     */\n+    public int getMinimumValue()\n+    {\n+      int min1 = s1.getMinimumValue();\n+      int min2 = s2.getMinimumValue();\n+      return min1 + min2;\n+    }\n+\n+    /**\n+     * Returns the preferred value of this Spring.\n+     *\n+     * @return the preferred value.\n+     */\n+    public int getPreferredValue()\n+    {\n+      int pref1 = s1.getPreferredValue();\n+      int pref2 = s2.getPreferredValue();\n+      return pref1 + pref2;\n+    }\n+\n+    /**\n+     * Returns the actual current value of this Spring.\n+     *\n+     * @return the current value of this Spring.\n+     */\n+    public int getValue()\n+    {\n+      if (value == Spring.UNSET)\n+        {\n+          int val1 = s1.getValue();\n+          int val2 = s2.getValue();\n+          value = val1 + val2;\n+        }\n+      return value;\n+    }\n+\n+    /**\n+     * Sets the current value.\n+     *\n+     * @param val the value to be set.\n+     */\n+    public void setValue(int val)\n+    {\n+\n+      if (val > getMaximumValue())\n+        {\n+          value = getMaximumValue();\n+        }\n+      else if (val < getMinimumValue())\n+        {\n+          value = getMinimumValue();\n+        }\n+      else\n+        {\n+          value = val;\n+        }\n+\n+    }\n+\t\n+  }\n+\n+\n+  /**\n+   * A Spring that is calculated as the negation of another Spring.\n+   *\n+   * @author Roman Kennke (roman@ontographics.com)\n+   */\n+  private static final class MinusSpring extends Spring\n+  {\n+\n+    /** The Spring from which to calculate the negation. */\n+    private final Spring s;\n+\n+    /** The current value of this Spring. */\n+    private int value;\n+\n+    /**\n+     * Creates a new MinusSpring object.\n+     * @param s the Spring from which to calculate the negation.\n+     */\n+    protected MinusSpring(Spring s)\n+    {\n+      super();\n+      this.s = s;\n+      value = Spring.UNSET;\n+    }\n+\n+    /** Returns the maximum value of this Spring.\n+     *\n+     * @return the maximum value.\n+     */\n+    public int getMaximumValue()\n+    {\n+      return -s.getMinimumValue();\n+    }\n+\n+    /**\n+     * Returns the minimum value of this Spring.\n+     *\n+     * @return the minimum value.\n+     */\n+    public int getMinimumValue()\n+    {\n+      return -s.getMaximumValue();\n+    }\n+\n+    /**\n+     * Returns the preferred value of this Spring.\n+     *\n+     * @return the preferred value.\n+     */\n+    public int getPreferredValue()\n+    {\n+      return -s.getPreferredValue();\n+    }\n+\n+    /**\n+     * Returns the current value of this Spring.\n+     *\n+     * @return the current value.\n+     */\n+    public int getValue()\n+    {\n+      if (value == Spring.UNSET)\n+        {\n+\t  value = -s.getValue();\n+\t}\n+      return value;\n+    }\n+\n+    /**\n+     * Sets the current value.\n+     *\n+     * @param val the value to be set.\n+     */\n+    public void setValue(int val)\n+    {\n+    \n+      if (val > getMaximumValue())\n+        {\n+          value = getMaximumValue();\n+\t}\n+      else if (val < getMinimumValue())\n+\t{\n+          value = getMinimumValue();\n+        }\n+      else\n+\t{\n+\t  value = val;\n+        }\n+\n+    }\n+\n+  }\n+\n+\n+  /**\n+   * A Spring, that is calculated as the maximum of two Springs.\n+   *\n+   * @author Roman Kennke (roman@ontographics.com)\n+   */\n+  private static final class MaxSpring extends Spring\n+  {\n+\n+    /** The two other Springs from which to calculate the maximum. */\n+    private final Spring s1;\n+    private final Spring s2;\n+\n+    /** The current value of this Spring. */\n+    private int value;\n+\n+    /**\n+     * Creates a new MaxSpring object.\n+     *\n+     * @param s1 the 1st operand.\n+     * @param s2 the 2nd operand.\n+     */\n+    protected MaxSpring(Spring s1, Spring s2)\n+    {\n+      super();\n+      this.s1 = s1;\n+      this.s2 = s2;\n+      value = Spring.UNSET;\n+    }\n+\n+\n+    /**\n+     * Returns the maximum value of this Spring.\n+     *\n+     * @return the maximum value.\n+     */\n+    public int getMaximumValue()\n+    {\n+      int max1 = s1.getMaximumValue();\n+      int max2 = s2.getMaximumValue();\n+      return Math.max(max1, max2);\n+    }\n+\n+    /**\n+     * Returns the minimum value of this Spring.\n+     *\n+     * @return the minimum value.\n+     */\n+    public int getMinimumValue()\n+    {\n+      int min1 = s1.getMinimumValue();\n+      int min2 = s2.getMinimumValue();\n+      return Math.max(min1, min2);\n+    }\n+\n+    /**\n+     * Returns the preferred value of this Spring.\n+     *\n+     * @return the preferred value.\n+     */\n+    public int getPreferredValue()\n+    {\n+      int pref1 = s1.getPreferredValue();\n+      int pref2 = s2.getPreferredValue();\n+      return Math.max(pref1, pref2);\n+    }\n+\n+    /**\n+     * Returns the actual value of this Spring.\n+     *\n+     * @return the current value.\n+     */\n+    public int getValue()\n+    {\n+      if (value == Spring.UNSET)\n+        {\n+          int val1 = s1.getValue();\n+          int val2 = s2.getValue();\n+          value = Math.max(val1, val2);\n+      }\n+      return value;\n+    }\n+\n+    /**\n+     * Sets the current value.\n+     *\n+     * @param val the value to be set.\n+     */\n+    public void setValue(int val)\n+    {\n+\n+      if (val > getMaximumValue())\n+        {\n+          value = getMaximumValue();\n+\t}\n+      else if (val < getMinimumValue())\n+        {\n+          value = getMinimumValue();\n+        }\n+      else\n+        {\n+          value = val;\n+        }\n+    }\n+  }\n+}"}, {"sha": "60a50525f07c3dca92c11718c5a818a04445c2a2", "filename": "libjava/javax/swing/SpringLayout.java", "status": "added", "additions": 660, "deletions": 0, "changes": 660, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FSpringLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FSpringLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FSpringLayout.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -0,0 +1,660 @@\n+/* SpringLayout.java -- \n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.swing;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.LayoutManager2;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.Spring;\n+\n+/**\n+ * A very flexible layout manager. Components are laid out by defining the\n+ * relationships between them. The relationships are expressed as\n+ * {@link Spring}s. You can attach a Spring for each edge of a component and\n+ * link it to an edge of a different component. For example, you can say,\n+ * the northern edge of component A should be attached to the southern edge\n+ * of component B, and the space between them should be something between\n+ * x and y pixels, and preferably z pixels.\n+ * <p>While quite simple, this layout manager can be used to emulate most other\n+ * layout managers, and can also be used to solve some layout problems, which\n+ * would be hard to solve with other layout managers.</p>\n+ *\n+ * @author Roman Kennke (roman@ontographics.com)\n+ */\n+public class SpringLayout implements LayoutManager2\n+{\n+\n+  /** The right edge of a component. */\n+  public static final String EAST = \"East\";\n+\n+  /** The top edge of a component. */\n+  public static final String NORTH = \"North\";\n+\n+  /** The bottom edge of a component. */\n+  public static final String SOUTH = \"South\";\n+\n+  /** The left edge of a component. */\n+  public static final String WEST = \"West\";\n+\n+  /** maps components to their constraints. */\n+  private Map constraintsMap;\n+\n+  /**\n+   * The constraints that define the relationships between components.\n+   * Each Constraints object can hold 4 Springs: one for each edge of the\n+   * component. Additionally it can hold Springs for the components width\n+   * and the components height. Since the height and width constraints are\n+   * dependend on the other constraints, a component can be over-constraint.\n+   * In this case (like when all of NORTH, SOUTH and HEIGHT are constraint),\n+   * the values are adjusted, so that the mathematics still hold true.\n+   *\n+   * @author Roman Kennke (roman@ontographics.com)\n+   */\n+  public final static class Constraints\n+  {\n+\n+    // The constraints for each edge, and width and height.\n+    /** The Spring for the left edge. */\n+    private Spring x;\n+\n+    /** The Spring for the upper edge. */\n+    private Spring y;\n+\n+    /** The Spring for the height. */\n+    private Spring height;\n+\n+    /** The Spring for the width. */\n+    private Spring width;\n+\n+    /** The Spring for the right edge. */\n+    private Spring east;\n+\n+    /** The Spring for the bottom edge. */\n+    private Spring south;\n+\n+    /**\n+     * Creates a new Constraints object.\n+     * There is no constraint set.\n+     */\n+    public Constraints()\n+    {\n+      x = y = height = width = east = south = null;\n+    }\n+\n+    /**\n+     * Creates a new Constraints object.\n+     *\n+     * @param x the constraint for the left edge of the component.\n+     * @param y the constraint for the upper edge of the component.\n+     */\n+    public Constraints(Spring x, Spring y)\n+    {\n+      this.x = x;\n+      this.y = y;\n+      width = height = east = south = null;\n+    }\n+\n+    /**\n+     * Creates a new Constraints object.\n+     *\n+     * @param x the constraint for the left edge of the component.\n+     * @param y the constraint for the upper edge of the component.\n+     * @param width the constraint for the width of the component.\n+     * @param height the constraint for the height of the component.\n+     */\n+    public Constraints(Spring x, Spring y, Spring width, Spring height)\n+    {\n+      this.x = x;\n+      this.y = y;\n+      this.width = width;\n+      this.height = height;\n+      east = south = null;\n+    }\n+\n+    /**\n+     * Returns the constraint for the edge with the <code>edgeName</code>.\n+     * This is expected to be one of\n+     * {@link #EAST}, {@link #WEST}, {@link NORTH} or {@link SOUTH}.\n+     *\n+     * @param edgeName the name of the edge.\n+     * @return the constraint for the specified edge.\n+     */\n+    public Spring getConstraint(String edgeName)\n+    {\n+      Spring retVal = null;\n+      if (edgeName.equals(SpringLayout.NORTH))\n+\tretVal = y;\n+      else if (edgeName.equals(SpringLayout.WEST))\n+        retVal = x;\n+      else if (edgeName.equals(SpringLayout.SOUTH))\n+        {\n+          retVal = south;\n+\t  if ((retVal == null) && (y != null) && (height != null))\n+            retVal = Spring.sum(y, height);\n+        }\n+      else if (edgeName.equals(SpringLayout.EAST))\n+        {\n+          retVal = east;\n+          if ((retVal == null) && (x != null) && (width != null))\n+            retVal = Spring.sum(x, width);\n+\t}\n+\n+      return retVal;\n+    }\n+\n+    /**\n+     * Returns the constraint for the height of the component.\n+     *\n+     * @return the height constraint. \n+     */\n+    public Spring getHeight()\n+    {\n+      Spring retVal = height;\n+      if ((retVal == null) && (y != null) && (south != null))\n+        {\n+          retVal = Spring.sum(south, Spring.minus(y));\n+        }\n+      return retVal;\n+    }\n+\n+    /**\n+     * Returns the constraint for the width of the component.\n+     *\n+     * @return the width constraint.\n+     */\n+    public Spring getWidth()\n+    {\n+      Spring retVal = width;\n+      if ((retVal == null) && (x != null) && (east != null))\n+        {\n+          retVal = Spring.sum(east, Spring.minus(x));\n+\t}\n+      return retVal;\n+    }\n+\n+    /**\n+     * Returns the constraint for the left edge of the component.\n+     *\n+     * @return the left-edge constraint (== WEST).\n+     */\n+    public Spring getX()\n+    {\n+      Spring retVal = x;\n+      if ((retVal == null) && (width != null) && (east != null))\n+        {\n+          retVal = Spring.sum(east, Spring.minus(width));\n+        }\n+      return retVal;\n+    }\n+\n+    /**\n+     * Returns the constraint for the upper edge of the component.\n+     *\n+     * @return the upper-edge constraint (== NORTH).\n+     */\n+    public Spring getY()\n+    {\n+      Spring retVal = y;\n+      if ((retVal == null) && (height != null) && (south != null))\n+        {\n+          retVal = Spring.sum(south, Spring.minus(height));\n+        }\n+      return retVal;\n+    }\n+\n+    /**\n+     * Sets a constraint for the specified edge. If this leads to an\n+     * over-constrained situation, the constraints get adjusted, so that\n+     * the mathematics still hold true.\n+     *\n+     * @param edgeName the name of the edge, one of {@link #EAST},\n+     *     {@link #WEST}, {@link NORTH} or {@link SOUTH}.\n+     * @param s the constraint to be set.\n+     */\n+    public void setConstraint(String edgeName, Spring s)\n+    {\n+    \n+      if (edgeName.equals(SpringLayout.WEST))\n+        {\n+          x = s;\n+\t  if ((width != null) && (east != null))\n+            width = Spring.sum(east, Spring.minus(x));\n+        }\n+      else if (edgeName.equals(SpringLayout.NORTH))\n+        {\n+          y = s;\n+          if ((height != null) && (south != null))\n+          height = Spring.sum(south, Spring.minus(y));\n+        }\n+      else if (edgeName.equals(SpringLayout.EAST))\n+        {\n+          east = s;\n+          if ((x != null) && (width != null))\n+            x = Spring.sum(east, Spring.minus(width));\n+        }\n+      else if (edgeName.equals(SpringLayout.SOUTH))\n+        {\n+          south = s;\n+          if ((height != null) && (y != null))\n+\t    y = Spring.sum(south, Spring.minus(height));\n+        }\n+\n+    }\n+\n+    /**\n+     * Sets the height-constraint.\n+     *\n+     * @param s the constraint to be set.\n+     */\n+    public void setHeight(Spring s)\n+    {\n+      height = s;\n+      if ((south != null) && (y != null))\n+        south = Spring.sum(y, height);\n+\n+    }\n+\n+    /**\n+     * Sets the width-constraint.\n+     *\n+     * @param s the constraint to be set.\n+     */\n+    public void setWidth(Spring s)\n+    {\n+      width = s;\n+      if ((east != null) && (x != null))\n+        east = Spring.sum(x, width);\n+\n+    }\n+\n+    /**\n+     * Sets the WEST-constraint.\n+     *\n+     * @param s the constraint to be set.\n+     */\n+    public void setX(Spring s)\n+    {\n+      x = s;\n+      if ((width != null) && (east != null))\n+        width = Spring.sum(east, Spring.minus(x));\n+\n+    }\n+\n+    /**\n+     * Sets the NORTH-constraint.\n+     *\n+     * @param s the constraint to be set.\n+     */\n+    public void setY(Spring s)\n+    {\n+      y = s;\n+      if ((height != null) && (south != null))\n+        height = Spring.sum(south, Spring.minus(y));\n+\n+    }\n+  }\n+\n+  /**\n+   * Creates a new SpringLayout.\n+   */\n+  public SpringLayout()\n+  {\n+\n+    constraintsMap = new HashMap();\n+  }\n+\n+  /**\n+   * Adds a layout component and a constraint object to this layout.\n+   * This method is usually only called by a {@java.awt.Container}s add\n+   * Method.\n+   *\n+   * @param component the component to be added.\n+   * @param constraint the constraint to be set.\n+   */\n+  public void addLayoutComponent(Component component, Object constraint)\n+  {\n+    constraintsMap.put(component, constraint);\n+  }\n+\n+\n+  /**\n+   * Adds a layout component and a constraint object to this layout.\n+   * This method is usually only called by a {@java.awt.Container}s add\n+   * Method. This method does nothing, since SpringLayout does not manage\n+   * String-indexed components.\n+   *\n+   * @param component the component to be added.\n+   * @param constraint the constraint to be set.\n+   */\n+  public void addLayoutComponent(String name, Component c)\n+  {\n+    // do nothing here.\n+  }\n+\n+  /**\n+   * Returns the constraint of the edge named by <code>edgeName</code>.\n+   *\n+   * @param c the component from which to get the constraint.\n+   * @param edgeName the name of the edge, one of {@link #EAST},\n+   *     {@link #WEST}, {@link NORTH} or {@link SOUTH}.\n+   * @return the constraint of the edge <code>edgeName</code> of the\n+   * component c.\n+   */\n+  public Spring getConstraint(String edgeName, Component c)\n+  {\n+    Constraints constraints = getConstraints(c);\n+    return constraints.getConstraint(edgeName);\n+  }\n+\n+  /**\n+   * Returns the {@link Constraints} object associated with the specified\n+   * component.\n+   *\n+   * @param c the component for which to determine the constraint.\n+   * @return the {@link Constraints} object associated with the specified\n+   *      component.\n+   */\n+  public SpringLayout.Constraints getConstraints(Component c)\n+  {\n+    Constraints constraints = (Constraints) constraintsMap.get(c);\n+    if (constraints == null)\n+      {\n+        Container parent = c.getParent();\n+        constraints = new Constraints();\n+        if (parent != null)\n+          {\n+            constraints.setX\n+              (Spring.constant(parent.getInsets().left));\n+            constraints.setY\n+              (Spring.constant(parent.getInsets().top));\n+          }\n+        else\n+          {\n+            constraints.setX\n+              (Spring.constant(0));\n+            constraints.setY\n+              (Spring.constant(0));\n+\n+          }\n+        constraints.setWidth\n+          (Spring.constant(c.getMinimumSize().width,\n+                           c.getPreferredSize().width,\n+                           c.getMaximumSize().width));\n+        constraints.setHeight\n+          (Spring.constant(c.getMinimumSize().height,\n+                           c.getPreferredSize().height,\n+                           c.getMaximumSize().height));\n+\n+        constraintsMap.put(c, constraints);\n+\n+      }\n+\n+    return constraints;\n+  }\n+\n+  /**\n+   * Returns the X alignment of the Container <code>p</code>.\n+   *\n+   * @param p the {@link java.awt.Container} for which to determine the X\n+   *     alignment.\n+   * @return always 0.0\n+   */\n+  public float getLayoutAlignmentX(Container p)\n+  {\n+    return 0.0F;\n+  }\n+\n+  /**\n+   * Returns the Y alignment of the Container <code>p</code>.\n+   *\n+   * @param p the {@link java.awt.Container} for which to determine the Y\n+   *     alignment.\n+   * @return always 0.0\n+   */\n+  public float getLayoutAlignmentY(Container p)\n+  {\n+    return 0.0F;\n+  }\n+\n+  /**\n+   * Recalculate a possibly cached layout.\n+   */\n+  public void invalidateLayout(Container p)\n+  {\n+    // nothing to do here yet\n+  }\n+\n+  /**\n+   * Lays out the container <code>p</code>.\n+   *\n+   * @param p the container to be laid out.\n+   */\n+  public void layoutContainer(Container p)\n+  {\n+\n+    addLayoutComponent(p, new Constraints(Spring.constant(0),\n+                                          Spring.constant(0)));\n+\n+    int offsetX = p.getInsets().left;\n+    int offsetY = p.getInsets().right;\n+\n+    Component[] components = p.getComponents();\n+    for (int index = 0; index < components.length; index++)\n+      {\n+        Component c = components[index];\n+        Constraints constraints = getConstraints(c);\n+        int x = constraints.getX().getValue();\n+        int y = constraints.getY().getValue();\n+        int width = constraints.getWidth().getValue();\n+        int height = constraints.getHeight().getValue();\n+\n+        c.setLocation(x + offsetX, y + offsetY);\n+        c.setSize(width, height);\n+      }\n+\n+  }\n+\n+  /**\n+   * Calculates the maximum size of the layed out container. This\n+   * respects the maximum sizes of all contained components.\n+   *\n+   * @param p the container to be laid out.\n+   * @return the maximum size of the container.\n+   */\n+  public Dimension maximumLayoutSize(Container p)\n+  {\n+    int maxX = 0;\n+    int maxY = 0;\n+\n+    int offsetX = p.getInsets().left;\n+    int offsetY = p.getInsets().right;\n+\n+    Component[] components = p.getComponents();\n+    for (int index = 0; index < components.length; index++)\n+      {\n+        Component c = components[index];\n+        Constraints constraints = getConstraints(c);\n+        int x = constraints.getX().getMaximumValue();\n+        int y = constraints.getY().getMaximumValue();\n+        int width = constraints.getWidth().getMaximumValue();\n+        int height = constraints.getHeight().getMaximumValue();\n+\n+        int rightEdge = offsetX + x + width;\n+        if (rightEdge > maxX)\n+          maxX = rightEdge;\n+        int bottomEdge = offsetY + y + height;\n+        if (bottomEdge > maxY)\n+          maxY = bottomEdge;\n+      }\n+\n+    return new Dimension(maxX, maxY);\n+  }\n+\n+\n+  /**\n+   * Calculates the minimum size of the layed out container. This\n+   * respects the minimum sizes of all contained components.\n+   *\n+   * @param p the container to be laid out.\n+   * @return the minimum size of the container.\n+   */\n+  public Dimension minimumLayoutSize(Container p)\n+  {\n+    int maxX = 0;\n+    int maxY = 0;\n+\n+    int offsetX = p.getInsets().left;\n+    int offsetY = p.getInsets().right;\n+\n+    Component[] components = p.getComponents();\n+    for (int index = 0; index < components.length; index++)\n+      {\n+        Component c = components[index];\n+        Constraints constraints = getConstraints(c);\n+        int x = constraints.getX().getMinimumValue();\n+        int y = constraints.getY().getMinimumValue();\n+        int width = constraints.getWidth().getMinimumValue();\n+        int height = constraints.getHeight().getMinimumValue();\n+\n+        int rightEdge = offsetX + x + width;\n+        if (rightEdge > maxX)\n+          maxX = rightEdge;\n+        int bottomEdge = offsetY + y + height;\n+        if (bottomEdge > maxY)\n+          maxY = bottomEdge;\n+      }\n+\n+    return new Dimension(maxX, maxY);\n+  }\n+\n+  /**\n+   * Calculates the preferred size of the layed out container. This\n+   * respects the preferred sizes of all contained components.\n+   *\n+   * @param p the container to be laid out.\n+   * @return the preferred size of the container.\n+   */\n+  public Dimension preferredLayoutSize(Container p)\n+  {\n+    int maxX = 0;\n+    int maxY = 0;\n+\n+    int offsetX = p.getInsets().left;\n+    int offsetY = p.getInsets().right;\n+\n+    Component[] components = p.getComponents();\n+    for (int index = 0; index < components.length; index++)\n+      {\n+        Component c = components[index];\n+        Constraints constraints = getConstraints(c);\n+        int x = constraints.getX().getPreferredValue();\n+        int y = constraints.getY().getPreferredValue();\n+        int width = constraints.getWidth().getPreferredValue();\n+        int height = constraints.getHeight().getPreferredValue();\n+\n+        int rightEdge = offsetX + x + width;\n+        if (rightEdge > maxX)\n+          maxX = rightEdge;\n+        int bottomEdge = offsetY + y + height;\n+        if (bottomEdge > maxY)\n+          maxY = bottomEdge;\n+      }\n+\n+    return new Dimension(maxX, maxY);\n+  }\n+\n+  /**\n+   * Attaches the edge <code>e1</code> of component <code>c1</code> to\n+   * the edge <code>e2</code> of component <code>c2</code> width the\n+   * fixed strut <code>pad</code>.\n+   *\n+   * @param e1 the edge of component 1.\n+   * @param c1 the component 1.\n+   * @param pad the space between the components in pixels.\n+   * @param e2 the edge of component 2.\n+   * @param c2 the component 2.\n+   */\n+  public void putConstraint(String e1, Component c1, int pad, String e2, \n+                            Component c2)\n+  {\n+    Constraints constraints1 = getConstraints(c1);\n+    Constraints constraints2 = getConstraints(c2);\n+\n+    Spring strut = Spring.constant(pad);\n+    Spring otherEdge = constraints2.getConstraint(e2);\n+    constraints1.setConstraint(e1, Spring.sum(strut, otherEdge));\n+\n+  }\n+\n+  /**\n+   * Attaches the edge <code>e1</code> of component <code>c1</code> to\n+   * the edge <code>e2</code> of component <code>c2</code> width the\n+   * {@link Spring} <code>s</code>.\n+   *\n+   * @param e1 the edge of component 1.\n+   * @param c1 the component 1.\n+   * @param s the space between the components as a {@link Spring} object.\n+   * @param e2 the edge of component 2.\n+   * @param c2 the component 2.\n+   */\n+  public void putConstraint(String e1, Component c1, Spring s, String e2, \n+                            Component c2)\n+  {\n+    Constraints constraints1 = getConstraints(c1);\n+    Constraints constraints2 = getConstraints(c2);\n+\n+    Spring otherEdge = constraints2.getConstraint(e2);\n+    constraints1.setConstraint(e1, Spring.sum(s, otherEdge));\n+\n+  }\n+\n+  /**\n+   * Removes a layout component.\n+   * @param c the layout component to remove.\n+   */\n+  public void removeLayoutComponent(Component c)\n+  {\n+    // do nothing here\n+  }\n+}"}, {"sha": "62b156161f3f174837b1abeb362e8071de81ab69", "filename": "libjava/javax/swing/SwingUtilities.java", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FSwingUtilities.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FSwingUtilities.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FSwingUtilities.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -65,8 +65,11 @@\n  */\n public class SwingUtilities implements SwingConstants\n {\n-\n-  private static Frame ownerFrame;\n+  /** \n+   * This frame should be used as parent for JWindow or JDialog \n+   * that doesn't an owner\n+   */\n+  private static OwnerFrame ownerFrame;\n \n   /**\n    * Calculates the portion of the base rectangle which is inside the\n@@ -197,8 +200,6 @@ public static Container getAncestorNamed(String name, Component comp)\n    *\n    * @see #getAncestorOfClass\n    * @see #windowForComponent\n-   * @see \n-   * \n    */\n   public static Container getAncestorOfClass(Class c, Component comp)\n   {\n@@ -711,11 +712,14 @@ public static String layoutCompoundLabel(FontMetrics fm,\n       {\n       case TOP:\n         textR.y = 0;\n-        iconR.y = textR.height + textIconGap;\n+        iconR.y = (horizontalTextPosition == CENTER \n+                   ? textR.height + textIconGap : 0);\n         break;\n       case BOTTOM:\n         iconR.y = 0;\n-        textR.y = iconR.height + textIconGap;\n+        textR.y = (horizontalTextPosition == CENTER\n+                   ? iconR.height + textIconGap \n+                   : iconR.height - textR.height);\n         break;\n       case CENTER:\n         int centerLine = Math.max(textR.height, iconR.height) / 2;\n@@ -838,15 +842,15 @@ public static void paintComponent(Graphics g, Component c,\n   }\n   \n   /**\n-   * This method returns the common Frame owner used in JDialogs\n-   * when no owner is provided.\n+   * This method returns the common Frame owner used in JDialogs or\n+   * JWindow when no owner is provided.\n    *\n    * @return The common Frame \n    */\n   static Frame getOwnerFrame()\n   {\n     if (ownerFrame == null)\n-      ownerFrame = new Frame();\n+      ownerFrame = new OwnerFrame();\n     return ownerFrame;\n   }\n \n@@ -888,4 +892,23 @@ public static boolean isRightMouseButton(MouseEvent event)\n     return ((event.getModifiers() & InputEvent.BUTTON3_DOWN_MASK)\n \t     == InputEvent.BUTTON3_DOWN_MASK);\n   }\n+  \n+  /**\n+   * This frame should be used when constructing a Window/JDialog without\n+   * a parent. In this case, we are forced to use this frame as a window's\n+   * parent, because we simply cannot pass null instead of parent to Window\n+   * constructor, since doing it will result in NullPointerException.\n+   */\n+  private static class OwnerFrame extends Frame\n+  {\n+    public void setVisible(boolean b)\n+    {\n+      // Do nothing here. \n+    }\n+    \n+    public boolean isShowing()\n+    {\n+      return true;\n+    }\n+  }\n }"}, {"sha": "2b2920a1827384892e9118ec29961fe9b4e86384", "filename": "libjava/javax/swing/Timer.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FTimer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FTimer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FTimer.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -114,6 +114,7 @@ public void run()\n           while (running)\n             {\n               sleep(delay);\n+              queueEvent();\n               \n               if (logTimers)\n                 System.out.println(\"javax.swing.Timer -> clocktick\");"}, {"sha": "3a855f708c45d3f6e03d37a3111f16988a7dfc4d", "filename": "libjava/javax/swing/ToolTipManager.java", "status": "modified", "additions": 99, "deletions": 141, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FToolTipManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FToolTipManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FToolTipManager.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -43,135 +43,86 @@\n import java.awt.event.MouseEvent;\n import java.awt.event.MouseMotionListener;\n \n+\n /**\n  * ToolTipManager\n+ * \n  * @author\tAndrew Selkirk\n- * @version\t1.0\n  */\n-public class ToolTipManager extends MouseAdapter implements MouseMotionListener {\n-\n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n+public class ToolTipManager extends MouseAdapter\n+  implements MouseMotionListener\n+{\n \t/**\n \t * stillInsideTimerAction\n \t */\n-\tprotected class stillInsideTimerAction implements ActionListener {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n+  protected class stillInsideTimerAction\n+    implements ActionListener\n+  {\n \t\t/**\n \t\t * Constructor stillInsideTimerAction\n-\t\t * @param manager TODO\n \t\t */\n-\t\tprotected stillInsideTimerAction(ToolTipManager manager) {\n+    protected stillInsideTimerAction()\n+    {\n \t\t\t// TODO\n-\t\t} // stillInsideTimerAction()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n+    }\n \n \t\t/**\n \t\t * actionPerformed\n \t\t * @param event TODO\n \t\t */\n-\t\tpublic void actionPerformed(ActionEvent event) {\n+    public void actionPerformed(ActionEvent event)\n+    {\n \t\t\t// TODO\n-\t\t} // actionPerformed()\n-\n-\n-\t} // stillInsideTimerAction\n+    }\n+  }\n \n \t/**\n \t * outsideTimerAction\n \t */\n-\tprotected class outsideTimerAction implements ActionListener {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n+  protected class outsideTimerAction\n+    implements ActionListener\n+  {\n \t\t/**\n \t\t * Constructor outsideTimerAction\n-\t\t * @param manager TODO\n \t\t */\n-\t\tprotected outsideTimerAction(ToolTipManager manager) {\n+    protected outsideTimerAction()\n+    {\n \t\t\t// TODO\n-\t\t} // outsideTimerAction()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n+    }\n \n \t\t/**\n \t\t * actionPerformed\n \t\t * @param value0 TODO\n \t\t */\n-\t\tpublic void actionPerformed(ActionEvent event) {\n+    public void actionPerformed(ActionEvent event)\n+    {\n \t\t\t// TODO\n-\t\t} // actionPerformed()\n-\n-\n-\t} // outsideTimerAction\n+    }\n+  }\n \n \t/**\n \t * insideTimerAction\n \t */\n-\tprotected class insideTimerAction implements ActionListener {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n+  protected class insideTimerAction\n+    implements ActionListener\n+  {\n \t\t/**\n \t\t * Constructor insideTimerAction\n-\t\t * @param manager TODO\n \t\t */\n-\t\tprotected insideTimerAction(ToolTipManager manager) {\n+    protected insideTimerAction()\n+    {\n \t\t\t// TODO\n-\t\t} // insideTimerAction()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n+    }\n \n \t\t/**\n \t\t * actionPerformed\n \t\t * @param event TODO\n \t\t */\n-\t\tpublic void actionPerformed(ActionEvent event) {\n+    public void actionPerformed(ActionEvent event)\n+    {\n \t\t\t// TODO\n-\t\t} // actionPerformed()\n-\n-\n-\t} // insideTimerAction\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n+    }\n+  }\n \n \t/**\n \t * enterTimer\n@@ -228,166 +179,173 @@ public void actionPerformed(ActionEvent event) {\n \t */\n \tprotected boolean heavyWeightPopupEnabled;\n \n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n \t/**\n \t * Constructor ToolTipManager\n \t */\n-\tToolTipManager() {\n+  ToolTipManager()\n+  {\n \t\t// TODO\n-\t} // ToolTipManager()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n+  }\n \n \t/**\n \t * sharedInstance\n-\t * @returns ToolTipManager\n+   * @return ToolTipManager\n \t */\n-\tpublic static ToolTipManager sharedInstance() {\n+  public static ToolTipManager sharedInstance()\n+  {\n \t\treturn null; // TODO\n-\t} // sharedInstance()\n+  }\n \n \t/**\n \t * setEnabled\n \t * @param enabled TODO\n \t */\n-\tpublic void setEnabled(boolean enabled) {\n+  public void setEnabled(boolean enabled)\n+  {\n \t\t// TODO\n-\t} // setEnabled()\n+  }\n \n \t/**\n \t * isEnabled\n-\t * @returns boolean\n+   * @return boolean\n \t */\n-\tpublic boolean isEnabled() {\n+  public boolean isEnabled()\n+  {\n \t\treturn false; // TODO\n-\t} // isEnabled()\n+  }\n \n \t/**\n \t * isLightWeightPopupEnabled\n-\t * @returns boolean\n+   * @return boolean\n \t */\n-\tpublic boolean isLightWeightPopupEnabled() {\n+  public boolean isLightWeightPopupEnabled()\n+  {\n \t\treturn false; // TODO\n-\t} // isLightWeightPopupEnabled()\n+  }\n \n \t/**\n \t * setLightWeightPopupEnabled\n \t * @param enabled TODO\n \t */\n-\tpublic void setLightWeightPopupEnabled(boolean enabled) {\n+  public void setLightWeightPopupEnabled(boolean enabled)\n+  {\n \t\t// TODO\n-\t} // setLightWeightPopupEnabled()\n+  }\n \n \t/**\n \t * getInitialDelay\n-\t * @returns int\n+   * @return int\n \t */\n-\tpublic int getInitialDelay() {\n+  public int getInitialDelay()\n+  {\n \t\treturn 0; // TODO\n-\t} // getInitialDelay()\n+  }\n \n \t/**\n \t * setInitialDelay\n \t * @param delay TODO\n \t */\n-\tpublic void setInitialDelay(int delay) {\n+  public void setInitialDelay(int delay)\n+  {\n \t\t// TODO\n-\t} // setInitialDelay()\n+  }\n \n \t/**\n \t * getDismissDelay\n-\t * @returns int\n+   * @return int\n \t */\n-\tpublic int getDismissDelay() {\n+  public int getDismissDelay()\n+  {\n \t\treturn 0; // TODO\n-\t} // getDismissDelay()\n+  }\n \n \t/**\n \t * setDismissDelay\n \t * @param delay TODO\n \t */\n-\tpublic void setDismissDelay(int delay) {\n+  public void setDismissDelay(int delay)\n+  {\n \t\t// TODO\n-\t} // setDismissDelay()\n+  }\n \n \t/**\n \t * getReshowDelay\n-\t * @returns int\n+   * @return int\n \t */\n-\tpublic int getReshowDelay() {\n+  public int getReshowDelay()\n+  {\n \t\treturn 0; // TODO\n-\t} // getReshowDelay()\n+  }\n \n \t/**\n \t * setReshowDelay\n \t * @param delay TODO\n \t */\n-\tpublic void setReshowDelay(int delay) {\n+  public void setReshowDelay(int delay)\n+  {\n \t\t// TODO\n-\t} // setReshowDelay()\n+  }\n \n \t/**\n \t * registerComponent\n \t * @param component TODO\n \t */\n-\tpublic void registerComponent(JComponent component) {\n+  public void registerComponent(JComponent component)\n+  {\n \t\t// TODO\n-\t} // registerComponent()\n+  }\n \n \t/**\n \t * unregisterComponent\n \t * @param component TODO\n \t */\n-\tpublic void unregisterComponent(JComponent component) {\n+  public void unregisterComponent(JComponent component)\n+  {\n \t\t// TODO\n-\t} // unregisterComponent()\n+  }\n \n \t/**\n \t * mouseEntered\n \t * @param event TODO\n \t */\n-\tpublic void mouseEntered(MouseEvent event) {\n+  public void mouseEntered(MouseEvent event)\n+  {\n \t\t// TODO\n-\t} // mouseEntered()\n+  }\n \n \t/**\n \t * mouseExited\n \t * @param event TODO\n \t */\n-\tpublic void mouseExited(MouseEvent event) {\n+  public void mouseExited(MouseEvent event)\n+  {\n \t\t// TODO\n-\t} // mouseExited()\n+  }\n \n \t/**\n \t * mousePressed\n \t * @param event TODO\n \t */\n-\tpublic void mousePressed(MouseEvent event) {\n+  public void mousePressed(MouseEvent event)\n+  {\n \t\t// TODO\n-\t} // mousePressed()\n+  }\n \n \t/**\n \t * mouseDragged\n \t * @param event TODO\n \t */\n-\tpublic void mouseDragged(MouseEvent event) {\n+  public void mouseDragged(MouseEvent event)\n+  {\n \t\t// TODO\n-\t} // mouseDragged()\n+  }\n \n \t/**\n \t * mouseMoved\n \t * @param event TODO\n \t */\n-\tpublic void mouseMoved(MouseEvent event) {\n+  public void mouseMoved(MouseEvent event)\n+  {\n \t\t// TODO\n-\t} // mouseMoved()\n-\n-\n-} // ToolTipManager\n+  }\n+}"}, {"sha": "f72c2748cb095d3724dca2818d4fc1df146e0d61", "filename": "libjava/javax/swing/UIDefaults.java", "status": "modified", "additions": 23, "deletions": 35, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FUIDefaults.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FUIDefaults.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FUIDefaults.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -43,10 +43,9 @@\n import java.awt.Insets;\n import java.beans.PropertyChangeEvent;\n import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n import java.lang.reflect.Method;\n-import java.util.HashSet;\n import java.util.Hashtable;\n-import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.ListIterator;\n import java.util.Locale;\n@@ -66,15 +65,14 @@\n  */\n public class UIDefaults extends Hashtable\n {\n+  private LinkedList bundles;\n+  private Locale defaultLocale;\n+  private PropertyChangeSupport propertyChangeSupport;\n \n-  LinkedList bundles;\n-  Set listeners;\n-  Locale defaultLocale;\n-\n-  interface ActiveValue\n+  public interface ActiveValue\n   {\n     Object createValue(UIDefaults table);\n-  } // interface ActiveValue\n+  }\n \n   public static class LazyInputMap implements LazyValue\n   {\n@@ -93,12 +91,12 @@ public Object createValue(UIDefaults table)\n         }\n       return im;\n     }\n-  } // class LazyInputMap\n+  }\n \n-  interface LazyValue\n+  public interface LazyValue\n   {\n     Object createValue(UIDefaults table);\n-  } // interface LazyValue\n+  }\n \n   public static class ProxyLazyValue implements LazyValue\n   {\n@@ -209,28 +207,24 @@ public Object createValue (UIDefaults table)\n     {\n       return inner.createValue (table);\n     }\n-  } // class ProxyLazyValue\n+  }\n \n   private static final long serialVersionUID = 7341222528856548117L;\n \n   public UIDefaults()\n   {\n     bundles = new LinkedList ();\n-    listeners = new HashSet ();\n     defaultLocale = Locale.getDefault ();\n+    propertyChangeSupport = new PropertyChangeSupport(this);\n   }\n \n   public UIDefaults(Object[] entries)\n   {\n-    bundles = new LinkedList ();\n-    listeners = new HashSet ();\n-    defaultLocale = Locale.getDefault ();\n+    this();\n \n     for (int i = 0; (2*i+1) < entries.length; ++i)\n-      {\n         put (entries[2*i], entries[2*i+1]);\n       }\n-  }\n \n   public Object get(Object key)\n   {\n@@ -472,7 +466,6 @@ public ComponentUI getUI(JComponent target)\n         getUIError (\"InvocationTargetException (\"+ ite.getTargetException() \n \t\t    +\") calling createUI(...) on \" + cls.toString ());\n         return null;        \n-\n \t}\n     catch (Exception e)\n   {\n@@ -481,43 +474,38 @@ public ComponentUI getUI(JComponent target)\n       }\n   }\n \n-  void addPropertyChangeListener(PropertyChangeListener listener)\n+  public void addPropertyChangeListener(PropertyChangeListener listener)\n   {\n-    listeners.add (listener);\n+    propertyChangeSupport.addPropertyChangeListener(listener);\n   }\n \n   void removePropertyChangeListener(PropertyChangeListener listener)\n   {\n-    listeners.remove (listener);\n+    propertyChangeSupport.removePropertyChangeListener(listener);\n   }\n \n   public PropertyChangeListener[] getPropertyChangeListeners()\n   {\n-    return (PropertyChangeListener[]) listeners.toArray ();\n+    return propertyChangeSupport.getPropertyChangeListeners();\n   }\n \n-  protected void firePropertyChange(String property, Object o, Object n)\n+  protected void firePropertyChange(String property,\n+\t\t\t\t    Object oldValue, Object newValue)\n   {\n-    Iterator i = listeners.iterator ();\n-    PropertyChangeEvent pce = new PropertyChangeEvent (this, property, o, n);\n-    while (i.hasNext ())\n-      {\n-        PropertyChangeListener pcl = (PropertyChangeListener) i.next ();\n-        pcl.propertyChange (pce);\n-      }\n+    propertyChangeSupport.firePropertyChange(property, oldValue, newValue);\n   }\n \n-  void addResourceBundle(String name)\n+  public void addResourceBundle(String name)\n   {\n     bundles.addFirst (name);\n   }\n \n-  void removeResourceBundle(String name)\n+  public void removeResourceBundle(String name)\n   {\n     bundles.remove (name);\n   }\n \n-  void setDefaultLocale(Locale loc)\n+  public void setDefaultLocale(Locale loc)\n   {\n     defaultLocale = loc;\n   }\n@@ -526,4 +514,4 @@ public Locale getDefaultLocale()\n   {\n     return defaultLocale;\n   }\n-} // class UIDefaults\n+}"}, {"sha": "eca96f91078ad7aa04b4b193af29b9c6b7abc7f0", "filename": "libjava/javax/swing/UIManager.java", "status": "modified", "additions": 58, "deletions": 15, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FUIManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FUIManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FUIManager.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -87,18 +87,31 @@ public UIManager()\n     // Do nothing here.\n   }\n \n+  /**\n+   * Add a <code>PropertyChangeListener</code> to the listener list.\n+   *\n+   * @param listener the listener to add\n+   */\n   public static void addPropertyChangeListener (PropertyChangeListener listener)\n   {\n     // FIXME\n   }\n \n+  /**\n+   * Remove a <code>PropertyChangeListener</code> from the listener list.\n+   *\n+   * @param listener the listener to remove\n+   */\n   public static void removePropertyChangeListener (PropertyChangeListener listener)\n-    // Remove a PropertyChangeListener from the listener list. \n   {\n     // FIXME\n   }\n \n   /**\n+   * Returns an array of all added <code>PropertyChangeListener</code> objects.\n+   *\n+   * @return an array of listeners\n+   *\n    * @since 1.4\n    */\n   public static PropertyChangeListener[] getPropertyChangeListeners ()\n@@ -107,9 +120,11 @@ public static PropertyChangeListener[] getPropertyChangeListeners ()\n     throw new Error (\"Not implemented\");\n   }\n \n+  /**\n+   * Add a LookAndFeel to the list of auxiliary look and feels.\n+   */\n   public static void addAuxiliaryLookAndFeel (LookAndFeel l)\n   {\n-    // Add a LookAndFeel to the list of auxiliary look and feels. \n     if (aux_installed == null)\n       {\n         aux_installed = new LookAndFeel[1];\n@@ -201,14 +216,18 @@ public static Font getFont(Object key)\n     return (Font) getLookAndFeel().getDefaults().get(key);\n   }\n \n+  /**\n+   * Returns an Icon from the defaults table.\n+   */\n   public static Icon getIcon(Object key)\n-    // Returns an Icon from the defaults table. \n   {\n     return (Icon) getLookAndFeel().getDefaults().get(key);\n   }\n   \n+  /**\n+   * Returns an Insets object from the defaults table.\n+   */\n   public static Insets getInsets(Object key)\n-    // Returns an Insets object from the defaults table. \n   {\n     return (Insets) getLookAndFeel().getDefaults().getInsets(key);\n   }\n@@ -240,49 +259,71 @@ public static UIDefaults getLookAndFeelDefaults()\n     return getLookAndFeel().getDefaults();\n   }\n \n+  /**\n+   * Returns a string from the defaults table.\n+   */\n   public static String getString(Object key)\n-    // Returns a string from the defaults table. \n   {\n     return (String) getLookAndFeel().getDefaults().get(key);\n   }\n   \n+  /**\n+   * Returns the name of the LookAndFeel class that implements the\n+   * native systems look and feel if there is one, otherwise the name\n+   * of the default cross platform LookAndFeel class.\n+   */\n   public static String getSystemLookAndFeelClassName()\n-    // Returns the name of the LookAndFeel class that implements the native systems look and feel if there is one, otherwise the name of the default cross platform LookAndFeel class. \n   {\n     return getCrossPlatformLookAndFeelClassName();\n   }\n \n+  /**\n+   * Returns the L&amp;F object that renders the target component.\n+   */\n   public static ComponentUI getUI(JComponent target)\n-    // Returns the Look and Feel object that renders the target component. \n   {\n-    ComponentUI ui = getDefaults().getUI(target);\n-    //System.out.println(\"GET-UI-> \" + ui + \", for \" + target);\n-    return ui;\n+    return getDefaults().getUI(target);\n   }\n \n+  /**\n+   * Creates a new look and feel and adds it to the current array.\n+   */\n   public static void installLookAndFeel(String name, String className)\n-    // Creates a new look and feel and adds it to the current array. \n   {\n   }\n \n+  /**\n+   * Adds the specified look and feel to the current array and then calls\n+   * setInstalledLookAndFeels(javax.swing.UIManager.LookAndFeelInfo[]).\n+   */\n   public static void installLookAndFeel(LookAndFeelInfo info)\n-    // Adds the specified look and feel to the current array and then calls setInstalledLookAndFeels(javax.swing.UIManager.LookAndFeelInfo[]). \n   {\n   }\n \n+  /**\n+   * Stores an object in the defaults table.\n+   */\n   public static Object put(Object key, Object value)\n-    // Stores an object in the defaults table. \n   {\n     return getLookAndFeel().getDefaults().put(key,value);\n   }\n \n+  /**\n+   * Replaces the current array of installed LookAndFeelInfos.\n+   */\n   public static void setInstalledLookAndFeels(UIManager.LookAndFeelInfo[] infos)\n-    // Replaces the current array of installed LookAndFeelInfos. \n   {\n   }\n   \n+  /**\n+   * Set the current default look.\n+   */\n   public static void setLookAndFeel(LookAndFeel newLookAndFeel)\n+    throws UnsupportedLookAndFeelException\n   {\n+    if (! newLookAndFeel.isSupportedLookAndFeel())\n+      throw new UnsupportedLookAndFeelException(newLookAndFeel.getName());\n+    \n     if (look_and_feel != null)\n       look_and_feel.uninitialize();\n \n@@ -294,11 +335,13 @@ public static void setLookAndFeel(LookAndFeel newLookAndFeel)\n     //repaint();\n   }\n \n+  /**\n+   * Set the current default look and feel using a class name.\n+   */\n   public static void setLookAndFeel (String className)\n     throws ClassNotFoundException, InstantiationException, IllegalAccessException,\n     UnsupportedLookAndFeelException\n   {\n-    //          Set the current default look and feel using a class name.\n     Class c = Class.forName(className);\n     LookAndFeel a = (LookAndFeel) c.newInstance(); // throws class-cast-exception\n     setLookAndFeel(a);"}, {"sha": "4738baccd1abdb6fd7d2781bdc913984e4ac2492", "filename": "libjava/javax/swing/ViewportLayout.java", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FViewportLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2FViewportLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FViewportLayout.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -67,13 +67,6 @@ public Dimension preferredLayoutSize(Container parent)\n   {\n     JViewport vp = (JViewport)parent;\n     Component view = vp.getView();\n-    if (view instanceof Scrollable)\n-      {\n-        Scrollable sc = (Scrollable) view;\n-        Dimension d = sc.getPreferredScrollableViewportSize();\n-        return d;\n-      }\n-    else\n       return view.getPreferredSize();\n   }\n   public Dimension minimumLayoutSize(Container parent) \n@@ -126,7 +119,7 @@ public void layoutContainer(Container parent)\n     // the viewport require inputs in view space.\n \n     Rectangle portBounds = port.getViewRect();\n-    Dimension viewSize = port.getViewSize();\n+    Dimension viewPref = view.getPreferredSize();\n     Dimension viewMinimum = view.getMinimumSize();\n     Point portLowerRight = new Point(portBounds.x + portBounds.width,\n                                      portBounds.y + portBounds.height);\n@@ -135,12 +128,12 @@ public void layoutContainer(Container parent)\n     if (portBounds.height >= viewMinimum.height)\n       {\n         portBounds.y = 0;\n-        viewSize.height = portBounds.height;\n+        viewPref.height = portBounds.height;\n       }\n     else\n       {\n-        viewSize.height = viewMinimum.height;\n-        int overextension = portLowerRight.y - viewSize.height;\n+        viewPref.height = viewMinimum.height;\n+        int overextension = portLowerRight.y - viewPref.height;\n         if (overextension > 0)\n             portBounds.y -= overextension;\n       }\n@@ -149,17 +142,17 @@ public void layoutContainer(Container parent)\n     if (portBounds.width >= viewMinimum.width)\n       {\n         portBounds.x = 0;\n-        viewSize.width = portBounds.width;\n+        viewPref.width = portBounds.width;\n       }\n     else\n       {\n-        viewSize.width = viewMinimum.width;\n-        int overextension = portLowerRight.x - viewSize.width;\n+        viewPref.width = viewMinimum.width;\n+        int overextension = portLowerRight.x - viewPref.width;\n         if (overextension > 0)\n             portBounds.x -= overextension;\n       }\n \n     port.setViewPosition(portBounds.getLocation());\n-    port.setViewSize(viewSize);\n+    port.setViewSize(viewPref);\n   }\n }"}, {"sha": "b124501570390e8da708c5c0d7f7cfa78bde494c", "filename": "libjava/javax/swing/plaf/basic/BasicArrowButton.java", "status": "modified", "additions": 44, "deletions": 23, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicArrowButton.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicArrowButton.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicArrowButton.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -40,9 +40,11 @@\n import java.awt.Color;\n import java.awt.Component;\n import java.awt.Dimension;\n+import java.awt.Insets;\n import java.awt.Graphics;\n import java.awt.Polygon;\n import java.awt.Rectangle;\n+import javax.swing.border.Border;\n import javax.swing.Icon;\n import javax.swing.JButton;\n import javax.swing.SwingConstants;\n@@ -170,6 +172,47 @@ public void paintIconImpl(Graphics g, int x, int y, Color arrowColor)\n   /** The top and left edges of the button. */\n   private transient Color highlight = Color.BLACK;\n \n+  /** The border around the ArrowButton. */\n+  private transient Border tmpBorder = new Border()\n+  {\n+    public Insets getBorderInsets(Component c)\n+    {\n+      return new Insets(0, 0, 0, 0);\n+    }\n+    \n+    public boolean isBorderOpaque()\n+    {\n+      return false;\n+    }\n+    \n+    public void paintBorder(Component c, Graphics g, int x, int y, int w, int h)\n+    {\n+      Rectangle bounds = getBounds();\n+\n+      Color saved = g.getColor();\n+      g.setColor(highlight);\n+\n+      g.drawLine(bounds.x, bounds.y, bounds.x, bounds.y + bounds.height);\n+      g.drawLine(bounds.x, bounds.y, bounds.x + bounds.width, bounds.y);\n+\n+      g.setColor(shadow);\n+\n+      g.drawLine(bounds.x + 1, bounds.y + bounds.height - 1,\n+                 bounds.x + bounds.width - 1, bounds.y + bounds.height - 1);\n+      g.drawLine(bounds.x + bounds.width - 1, bounds.y + 1,\n+                 bounds.x + bounds.width - 1, bounds.y + bounds.height - 1);\n+\n+      g.setColor(darkShadow);\n+\n+      g.drawLine(bounds.x, bounds.y + bounds.height, bounds.x + bounds.width,\n+                 bounds.y + bounds.height);\n+      g.drawLine(bounds.x + bounds.width, bounds.y, bounds.x + bounds.width,\n+                 bounds.y + bounds.height);\n+\n+      g.setColor(saved);\n+    }\n+  };\n+\n   /**\n    * Creates a new BasicArrowButton object.\n    *\n@@ -179,6 +222,7 @@ public BasicArrowButton(int direction)\n   {\n     super();\n     setDirection(direction);\n+    setBorder(tmpBorder);\n   }\n \n   /**\n@@ -234,29 +278,6 @@ public void setDirection(int dir)\n   public void paint(Graphics g)\n   {\n     super.paint(g);\n-    Rectangle bounds = getBounds();\n-\n-    Color saved = g.getColor();\n-    g.setColor(highlight);\n-\n-    g.drawLine(bounds.x, bounds.y, bounds.x, bounds.y + bounds.height);\n-    g.drawLine(bounds.x, bounds.y, bounds.x + bounds.width, bounds.y);\n-\n-    g.setColor(shadow);\n-\n-    g.drawLine(bounds.x + 1, bounds.y + bounds.height - 1,\n-               bounds.x + bounds.width - 1, bounds.y + bounds.height - 1);\n-    g.drawLine(bounds.x + bounds.width - 1, bounds.y + 1,\n-               bounds.x + bounds.width - 1, bounds.y + bounds.height - 1);\n-\n-    g.setColor(darkShadow);\n-\n-    g.drawLine(bounds.x, bounds.y + bounds.height, bounds.x + bounds.width,\n-               bounds.y + bounds.height);\n-    g.drawLine(bounds.x + bounds.width, bounds.y, bounds.x + bounds.width,\n-               bounds.y + bounds.height);\n-\n-    g.setColor(saved);\n   }\n \n   /**"}, {"sha": "9134fb2e2e13d8fd885cc201c9f03f741c1240aa", "filename": "libjava/javax/swing/plaf/basic/BasicButtonUI.java", "status": "modified", "additions": 37, "deletions": 18, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -61,7 +61,7 @@ public class BasicButtonUI extends ButtonUI\n {\n   /** A constant used to pad out elements in the button's layout and\n       preferred size calculations. */\n-  int defaultTextIconGap = 3;\n+  int defaultTextIconGap = 4;\n \n   /** A constant added to the defaultTextIconGap to adjust the text\n       within this particular button. */\n@@ -92,6 +92,7 @@ protected void installDefaults(AbstractButton b)\n     b.setBackground(defaults.getColor(\"Button.background\"));\n     b.setMargin(defaults.getInsets(\"Button.margin\"));\n     b.setBorder(defaults.getBorder(\"Button.border\"));\n+    b.setIconTextGap(defaults.getInt(\"Button.textIconGap\"));\n     b.setOpaque(true);\n   }\n \n@@ -100,6 +101,7 @@ protected void uninstallDefaults(AbstractButton b)\n     b.setForeground(null);\n     b.setBackground(null);\n     b.setBorder(null);\n+    b.setIconTextGap(defaultTextIconGap);\n     b.setMargin(null);\n   }\n \n@@ -234,19 +236,19 @@ public void paint(Graphics g, JComponent c)\n                                                      b.getVerticalTextPosition(), \n                                                      b.getHorizontalTextPosition(),\n                                                      vr, ir, tr, \n-                                                     defaultTextIconGap \n+                                                     b.getIconTextGap() \n                                                      + defaultTextShiftOffset);\n     \n     if ((b.getModel().isArmed() && b.getModel().isPressed()) \n         || b.isSelected())\n-      paintButtonPressed(g, br, c);\n+      paintButtonPressed(g, b);\n     else\n       paintButtonNormal(g, br, c);\n \t\n     paintIcon(g, c, ir);\n     if (text != null)\n-      paintText(g, c, tr, b.getText());\n-    paintFocus(g, c, vr, tr, ir);\n+      paintText(g, b, tr, text);\n+    paintFocus(g, b, vr, tr, ir);\n   }\n \n   /**\n@@ -256,18 +258,17 @@ public void paint(Graphics g, JComponent c)\n    * \"focusPainted\" property is <code>true</code>.\n    *\n    * @param g Graphics context to paint with\n-   * @param c Component to paint the focus of\n+   * @param b Button to paint the focus of\n    * @param vr Visible rectangle, the area in which to paint\n    * @param tr Text rectangle, contained in visible rectangle\n    * @param ir Icon rectangle, contained in visible rectangle\n    *\n    * @see AbstractButton.isFocusPainted()\n    * @see JComponent.hasFocus()\n    */\n-  protected void paintFocus(Graphics g, JComponent c, Rectangle vr,\n+  protected void paintFocus(Graphics g, AbstractButton b, Rectangle vr,\n                             Rectangle tr, Rectangle ir)\n   {\n-    AbstractButton b = (AbstractButton) c;\n     if (b.hasFocus() && b.isFocusPainted())\n       {\n         Graphics2D g2 = (Graphics2D) g;\n@@ -313,13 +314,14 @@ protected void paintIcon(Graphics g, JComponent c, Rectangle iconRect)\n    * pressedBackgroundColor}.\n    *\n    * @param g The graphics context to paint with\n-   * @param area The area in which to paint\n-   * @param b The component to paint the state of\n+   * @param b The button to paint the state of\n    */\n-  protected void paintButtonPressed(Graphics g, Rectangle area, JComponent b)\n+  protected void paintButtonPressed(Graphics g, AbstractButton b)\n   {\n-    if (((AbstractButton)b).isContentAreaFilled())\n+    if (b.isContentAreaFilled())\n       {\n+\tRectangle area = new Rectangle();\n+\tSwingUtilities.calculateInnerArea(b, area);\n         g.setColor(b.getBackground().darker());\n         g.fillRect(area.x, area.y, area.width, area.height);\n       }\n@@ -334,7 +336,7 @@ protected void paintButtonPressed(Graphics g, Rectangle area, JComponent b)\n    * @param area The area in which to paint\n    * @param b The component to paint the state of\n    */\n-  protected void paintButtonNormal(Graphics g, Rectangle area, JComponent b)\n+  private void paintButtonNormal(Graphics g, Rectangle area, JComponent b)\n   {\n     if (((AbstractButton)b).isContentAreaFilled() && b.isOpaque())\n       {\n@@ -355,20 +357,37 @@ protected void paintButtonNormal(Graphics g, Rectangle area, JComponent b)\n   protected void paintText(Graphics g, JComponent c, Rectangle textRect,\n                            String text) \n   {\t\n-    Font f = c.getFont();\n+    paintText(g, (AbstractButton) c, textRect, text);\n+  }\n+\n+  /**\n+   * Paints the \"text\" property of an {@link AbstractButton}, using the\n+   * {@link textColor} color.\n+   *\n+   * @param g The graphics context to paint with\n+   * @param b The button to paint the state of\n+   * @param textRect The area in which to paint the text\n+   * @param text The text to paint\n+   *\n+   * @since 1.4\n+   */\n+  protected void paintText(Graphics g, AbstractButton b, Rectangle textRect,\n+\t\t\t   String text)\n+  {\n+    Font f = b.getFont();\n     g.setFont(f);\n     FontMetrics fm = g.getFontMetrics(f);\n \n-    if (c.isEnabled())\n+    if (b.isEnabled())\n       {\n-\tg.setColor(c.getForeground());\n+\tg.setColor(b.getForeground());\n \tg.drawString(text, textRect.x, textRect.y + fm.getAscent());\n       }\n     else\n       {\n-\tg.setColor(c.getBackground().brighter());\n+\tg.setColor(b.getBackground().brighter());\n \tg.drawString(text, textRect.x, textRect.y + fm.getAscent());\n-\tg.setColor(c.getBackground().darker());\n+\tg.setColor(b.getBackground().darker());\n \tg.drawString(text, textRect.x + 1, textRect.y + fm.getAscent() + 1);\n       }\n   } "}, {"sha": "c7d88d1a6ae758115a24aac473f2d11f345b4eee", "filename": "libjava/javax/swing/plaf/basic/BasicCheckBoxMenuItemUI.java", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicCheckBoxMenuItemUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicCheckBoxMenuItemUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicCheckBoxMenuItemUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -53,11 +53,12 @@\n public class BasicCheckBoxMenuItemUI extends BasicMenuItemUI\n {\n   /**\n-   * DOCUMENT ME!\n+   * Factory method to create a BasicCheckBoxMenuItemUI for the given {@link\n+   * JComponent}, which should be a JCheckBoxMenuItem\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c The {@link JComponent} a UI is being created for.\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return A BasicCheckBoxMenuItemUI for the {@link JComponent}.\n    */\n   public static ComponentUI createUI(final JComponent c)\n   {\n@@ -71,11 +72,12 @@ public static ComponentUI createUI(final JComponent c)\n    */\n   protected String getPropertyPrefix()\n   {\n-    return null; // TODO\n+    return null;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method installs the defaults that are defined in  the Basic look and\n+   * feel for this JRadioButtonMenuItem\n    */\n   protected void installDefaults()\n   {\n@@ -93,7 +95,8 @@ protected void installDefaults()\n    * @param path DOCUMENT ME!\n    * @param manager DOCUMENT ME!\n    */\n-  void processMouseEvent(JMenuItem item, MouseEvent e, MenuElement[] path,\n+  public void processMouseEvent(JMenuItem item, MouseEvent e,\n+                                MenuElement[] path,\n                          MenuSelectionManager manager)\n   {\n   }"}, {"sha": "d394b951b7ec2c0c9c2420f028332549fe6bbfa3", "filename": "libjava/javax/swing/plaf/basic/BasicInternalFrameUI.java", "status": "modified", "additions": 200, "deletions": 32, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicInternalFrameUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicInternalFrameUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicInternalFrameUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -37,6 +37,7 @@\n \n package javax.swing.plaf.basic;\n \n+import java.awt.AWTEvent;\n import java.awt.Color;\n import java.awt.Component;\n import java.awt.Container;\n@@ -179,6 +180,9 @@ protected class BorderListener extends MouseInputAdapter\n     /** The direction that the resize is occuring in. */\n     private transient int direction = -1;\n \n+    /** Cache rectangle that can be reused. */\n+    private transient Rectangle cacheRect = new Rectangle();\n+\n     /**\n      * This method is called when the mouse is clicked.\n      *\n@@ -204,6 +208,9 @@ public void mouseDragged(MouseEvent e)\n \treturn;\n       DesktopManager dm = getDesktopManager();\n       Rectangle b = frame.getBounds();\n+      Dimension min = frame.getMinimumSize();\n+      if (min == null)\n+\tmin = new Dimension(0, 0);\n       Insets insets = frame.getInsets();\n       int x = e.getX();\n       int y = e.getY();\n@@ -212,31 +219,43 @@ public void mouseDragged(MouseEvent e)\n \t  switch (direction)\n \t    {\n \t    case NORTH:\n-\t      dm.resizeFrame(frame, b.x, b.y + y, b.width, b.height - y);\n+\t      cacheRect.setBounds(b.x,\n+\t                          Math.min(b.y + y, b.y + b.height\n+\t                                   - min.height), b.width, b.height\n+\t                          - y);\n \t      break;\n \t    case NORTH_EAST:\n-\t      dm.resizeFrame(frame, b.x, b.y + y, x, b.height - y);\n+\t      cacheRect.setBounds(b.x,\n+\t                          Math.min(b.y + y, b.y + b.height\n+\t                                   - min.height), x, b.height - y);\n \t      break;\n \t    case EAST:\n-\t      dm.resizeFrame(frame, b.x, b.y, x, b.height);\n+\t      cacheRect.setBounds(b.x, b.y, x, b.height);\n \t      break;\n \t    case SOUTH_EAST:\n-\t      dm.resizeFrame(frame, b.x, b.y, x, y);\n+\t      cacheRect.setBounds(b.x, b.y, x, y);\n \t      break;\n \t    case SOUTH:\n-\t      dm.resizeFrame(frame, b.x, b.y, b.width, y);\n+\t      cacheRect.setBounds(b.x, b.y, b.width, y);\n \t      break;\n \t    case SOUTH_WEST:\n-\t      dm.resizeFrame(frame, b.x + x, b.y, b.width - x, y);\n+\t      cacheRect.setBounds(Math.min(b.x + x, b.x + b.width - min.width),\n+\t                          b.y, b.width - x, y);\n \t      break;\n \t    case WEST:\n-\t      dm.resizeFrame(frame, b.x + x, b.y, b.width - x, b.height);\n+\t      cacheRect.setBounds(Math.min(b.x + x, b.x + b.width - min.width),\n+\t                          b.y, b.width - x, b.height);\n \t      break;\n \t    case NORTH_WEST:\n-\t      dm.resizeFrame(frame, b.x + x, b.y + y, b.width - x, b.height\n-\t                     - y);\n+\t      cacheRect.setBounds(Math.min(b.x + x, b.x + b.width - min.width),\n+\t                          Math.min(b.y + y, b.y + b.height\n+\t                                   - min.height), b.width - x,\n+\t                          b.height - y);\n \t      break;\n \t    }\n+\t  dm.resizeFrame(frame, cacheRect.x, cacheRect.y,\n+\t                 Math.max(min.width, cacheRect.width),\n+\t                 Math.max(min.height, cacheRect.height));\n         }\n       else if (e.getSource() == titlePane)\n         {\n@@ -498,7 +517,7 @@ public void layoutContainer(Container c)\n      */\n     public Dimension minimumLayoutSize(Container c)\n     {\n-      return preferredLayoutSize(c);\n+      return getSize(c, true);\n     }\n \n     /**\n@@ -521,10 +540,25 @@ public Dimension maximumLayoutSize(Container c)\n      * @return The preferred dimensions for the JInternalFrame.\n      */\n     public Dimension preferredLayoutSize(Container c)\n+    {\n+      return getSize(c, false);\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param c DOCUMENT ME!\n+     * @param min DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    private Dimension getSize(Container c, boolean min)\n     {\n       Insets insets = frame.getInsets();\n \n       Dimension contentDims = frame.getContentPane().getPreferredSize();\n+      if (min)\n+\tcontentDims.width = contentDims.height = 0;\n       int nWidth = 0;\n       int nHeight = 0;\n       int sWidth = 0;\n@@ -578,8 +612,8 @@ public Dimension preferredLayoutSize(Container c)\n       int width = Math.max(sWidth, nWidth);\n       width = Math.max(width, contentDims.width + eWidth + wWidth);\n \n-      int height = Math.max(contentDims.height, eHeight);\n-      height = Math.max(height, wHeight);\n+      int height = Math.max(eHeight, wHeight);\n+      height = Math.max(height, contentDims.height);\n       height += nHeight + sHeight;\n \n       width += insets.left + insets.right;\n@@ -606,14 +640,26 @@ public void removeLayoutComponent(Component c)\n    */\n   protected class GlassPaneDispatcher implements MouseInputListener\n   {\n+    /** The MouseEvent target. */\n+    private transient Component mouseEventTarget;\n+\n+    /** The component pressed. */\n+    private transient Component pressedComponent;\n+\n+    /** The last component entered. */\n+    private transient Component lastComponentEntered;\n+\n+    /** The number of presses. */\n+    private transient int pressCount;\n+\n     /**\n      * This method is called when the mouse enters the glass pane.\n      *\n      * @param e The MouseEvent.\n      */\n     public void mouseEntered(MouseEvent e)\n     {\n-      dispatchFor(e);\n+      handleEvent(e);\n     }\n \n     /**\n@@ -623,7 +669,7 @@ public void mouseEntered(MouseEvent e)\n      */\n     public void mouseClicked(MouseEvent e)\n     {\n-      dispatchFor(e);\n+      handleEvent(e);\n     }\n \n     /**\n@@ -633,7 +679,7 @@ public void mouseClicked(MouseEvent e)\n      */\n     public void mouseDragged(MouseEvent e)\n     {\n-      dispatchFor(e);\n+      handleEvent(e);\n     }\n \n     /**\n@@ -643,7 +689,7 @@ public void mouseDragged(MouseEvent e)\n      */\n     public void mouseExited(MouseEvent e)\n     {\n-      dispatchFor(e);\n+      handleEvent(e);\n     }\n \n     /**\n@@ -653,7 +699,7 @@ public void mouseExited(MouseEvent e)\n      */\n     public void mouseMoved(MouseEvent e)\n     {\n-      dispatchFor(e);\n+      handleEvent(e);\n     }\n \n     /**\n@@ -664,7 +710,7 @@ public void mouseMoved(MouseEvent e)\n     public void mousePressed(MouseEvent e)\n     {\n       activateFrame(frame);\n-      dispatchFor(e);\n+      handleEvent(e);\n     }\n \n     /**\n@@ -674,27 +720,149 @@ public void mousePressed(MouseEvent e)\n      */\n     public void mouseReleased(MouseEvent e)\n     {\n-      dispatchFor(e);\n+      handleEvent(e);\n     }\n \n     /**\n-     * This helper method redispatches the MouseEvent to the  proper sub\n-     * component.\n+     * This method acquires a candidate component to dispatch the  MouseEvent\n+     * to.\n      *\n-     * @param e The MouseEvent.\n+     * @param me The MouseEvent to acquire a component for.\n      */\n-    private void dispatchFor(MouseEvent e)\n+    private void acquireComponentForMouseEvent(MouseEvent me)\n     {\n-      Component candidate = SwingUtilities.getDeepestComponentAt(frame.getRootPane()\n-                                                                      .getContentPane(),\n-                                                                 e.getX(),\n-                                                                 e.getY());\n-      if (candidate == null || candidate == frame.getRootPane().getGlassPane())\n+      int x = me.getX();\n+      int y = me.getY();\n+\n+      // Find the candidate which should receive this event.\n+      Component parent = frame.getContentPane();\n+      if (parent == null)\n \treturn;\n-      MouseEvent newevt = SwingUtilities.convertMouseEvent(frame.getRootPane()\n+      Component candidate = null;\n+      Point p = me.getPoint();\n+      while (candidate == null && parent != null)\n+        {\n+\t  candidate = SwingUtilities.getDeepestComponentAt(parent, p.x, p.y);\n+\t  if (candidate == null)\n+\t    {\n+\t      p = SwingUtilities.convertPoint(parent, p.x, p.y,\n+\t                                      parent.getParent());\n+\t      parent = parent.getParent();\n+\t    }\n+        }\n+\n+      // If the only candidate we found was the native container itself,\n+      // don't dispatch any event at all.  We only care about the lightweight\n+      // children here.\n+      if (candidate == frame.getContentPane())\n+\tcandidate = null;\n+\n+      // If our candidate is new, inform the old target we're leaving.\n+      if (lastComponentEntered != null && lastComponentEntered.isShowing()\n+          && lastComponentEntered != candidate)\n+        {\n+\t  Point tp = SwingUtilities.convertPoint(frame.getContentPane(), x, y,\n+\t                                         lastComponentEntered);\n+\t  MouseEvent exited = new MouseEvent(lastComponentEntered,\n+\t                                     MouseEvent.MOUSE_EXITED,\n+\t                                     me.getWhen(), me.getModifiers(),\n+\t                                     tp.x, tp.y, me.getClickCount(),\n+\t                                     me.isPopupTrigger(),\n+\t                                     me.getButton());\n+\t  lastComponentEntered.dispatchEvent(exited);\n+\t  lastComponentEntered = null;\n+        }\n+\n+      // If we have a candidate, maybe enter it.\n+      if (candidate != null)\n+        {\n+\t  mouseEventTarget = candidate;\n+\t  if (candidate.isLightweight() && candidate.isShowing()\n+\t      && candidate != frame.getContentPane()\n+\t      && candidate != lastComponentEntered)\n+\t    {\n+\t      lastComponentEntered = mouseEventTarget;\n+\t      Point cp = SwingUtilities.convertPoint(frame.getContentPane(),\n+\t                                             x, y, lastComponentEntered);\n+\t      MouseEvent entered = new MouseEvent(lastComponentEntered,\n+\t                                          MouseEvent.MOUSE_ENTERED,\n+\t                                          me.getWhen(),\n+\t                                          me.getModifiers(), cp.x,\n+\t                                          cp.y, me.getClickCount(),\n+\t                                          me.isPopupTrigger(),\n+\t                                          me.getButton());\n+\t      lastComponentEntered.dispatchEvent(entered);\n+\t    }\n+        }\n+\n+      if (me.getID() == MouseEvent.MOUSE_RELEASED\n+          || me.getID() == MouseEvent.MOUSE_PRESSED && pressCount > 0\n+          || me.getID() == MouseEvent.MOUSE_DRAGGED)\n+\t// If any of the following events occur while a button is held down,\n+\t// they should be dispatched to the same component to which the\n+\t// original MOUSE_PRESSED event was dispatched:\n+\t//   - MOUSE_RELEASED\n+\t//   - MOUSE_PRESSED: another button pressed while the first is held down\n+\t//   - MOUSE_DRAGGED\n+\tmouseEventTarget = pressedComponent;\n+      else if (me.getID() == MouseEvent.MOUSE_CLICKED)\n+        {\n+\t  // Don't dispatch CLICKED events whose target is not the same as the\n+\t  // target for the original PRESSED event.\n+\t  if (candidate != pressedComponent)\n+\t    mouseEventTarget = null;\n+\t  else if (pressCount == 0)\n+\t    pressedComponent = null;\n+        }\n+    }\n+\n+    /**\n+     * This is a helper method that dispatches the GlassPane MouseEvents to\n+     * the proper component.\n+     *\n+     * @param e The AWTEvent to be dispatched. Usually an instance of\n+     *        MouseEvent.\n+     */\n+    private void handleEvent(AWTEvent e)\n+    {\n+      if (e instanceof MouseEvent)\n+        {\n+\t  MouseEvent me = SwingUtilities.convertMouseEvent(frame.getRootPane()\n                                                                 .getGlassPane(),\n-                                                           e, candidate);\n-      candidate.dispatchEvent(newevt);\n+\t                                                   (MouseEvent) e,\n+\t                                                   frame.getRootPane()\n+\t                                                        .getGlassPane());\n+\n+\t  acquireComponentForMouseEvent(me);\n+\n+\t  // Avoid dispatching ENTERED and EXITED events twice.\n+\t  if (mouseEventTarget != null && mouseEventTarget.isShowing()\n+\t      && e.getID() != MouseEvent.MOUSE_ENTERED\n+\t      && e.getID() != MouseEvent.MOUSE_EXITED)\n+\t    {\n+\t      MouseEvent newEvt = SwingUtilities.convertMouseEvent(frame\n+\t                                                           .getContentPane(),\n+\t                                                           me,\n+\t                                                           mouseEventTarget);\n+\t      mouseEventTarget.dispatchEvent(newEvt);\n+\n+\t      switch (e.getID())\n+\t        {\n+\t\tcase MouseEvent.MOUSE_PRESSED:\n+\t\t  if (pressCount++ == 0)\n+\t\t    pressedComponent = mouseEventTarget;\n+\t\t  break;\n+\t\tcase MouseEvent.MOUSE_RELEASED:\n+\t\t  // Clear our memory of the original PRESSED event, only if\n+\t\t  // we're not expecting a CLICKED event after this. If\n+\t\t  // there is a CLICKED event after this, it will do clean up.\n+\t\t  if (--pressCount == 0\n+\t\t      && mouseEventTarget != pressedComponent)\n+\t\t    pressedComponent = null;\n+\t\t  break;\n+\t        }\n+\t    }\n+        }\n     }\n   }\n \n@@ -1108,7 +1276,7 @@ public Dimension getPreferredSize(JComponent x)\n    */\n   public Dimension getMinimumSize(JComponent x)\n   {\n-    return getPreferredSize(x);\n+    return internalFrameLayout.minimumLayoutSize(x);\n   }\n \n   /**"}, {"sha": "bd5c53b04ff4244561624e04b9774423517d9172", "filename": "libjava/javax/swing/plaf/basic/BasicListUI.java", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicListUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicListUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicListUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -121,7 +121,6 @@ class ListDataHandler implements ListDataListener\n      */\n     public void contentsChanged(ListDataEvent e)\n     {\n-      // System.err.println(this + \".contentsChanged(\" + e + \")\");\n       BasicListUI.this.damageLayout();\n     }\n \n@@ -132,7 +131,6 @@ public void contentsChanged(ListDataEvent e)\n      */\n     public void intervalAdded(ListDataEvent e)\n     {\n-      // System.err.println(this + \".intervalAdded(\" + e + \")\");\n       BasicListUI.this.damageLayout();\n     }\n \n@@ -143,7 +141,6 @@ public void intervalAdded(ListDataEvent e)\n      */\n     public void intervalRemoved(ListDataEvent e)\n     {\n-      // System.err.println(this + \".intervalRemoved(\" + e + \")\");\n       BasicListUI.this.damageLayout();\n     }\n   }\n@@ -161,7 +158,6 @@ class ListSelectionHandler implements ListSelectionListener\n      */\n     public void valueChanged(ListSelectionEvent e)\n     {\n-      //       System.err.println(this + \".valueChanged(\" + e + \")\");\n     }\n   }\n \n@@ -189,12 +185,10 @@ public void mouseClicked(MouseEvent event)\n      */\n     public void mousePressed(MouseEvent event)\n     {\n-      // System.err.println(\"got mouse click event \" + event);\n       int row = BasicListUI.this.convertYToRow(event.getY());\n       if (row == -1)\n         return;\n \n-      // System.err.println(\"clicked on row \" + row);\n       BasicListUI.this.list.setSelectedIndex(row);\n     }\n \n@@ -262,7 +256,6 @@ class PropertyChangeHandler implements PropertyChangeListener\n      */\n     public void propertyChange(PropertyChangeEvent e)\n     {\n-      // System.err.println(this + \".propertyChange(\" + e + \")\");\n       if (e.getSource() == BasicListUI.this.list)\n         {\n           if (e.getOldValue() != null && e.getOldValue() instanceof ListModel)\n@@ -357,6 +350,8 @@ else if (cellHeight != -1)\n    */\n   public Rectangle getCellBounds(JList l, int index1, int index2)\n   {\n+    maybeUpdateLayoutState();\n+\n     if (l != list || cellWidth == -1)\n       return null;\n \n@@ -366,6 +361,7 @@ public Rectangle getCellBounds(JList l, int index1, int index2)\n                                        getRowHeight(lo));\n     Rectangle hibounds = new Rectangle(0, convertRowToY(hi), cellWidth,\n                                        getRowHeight(hi));\n+\n     return lobounds.union(hibounds);\n   }\n \n@@ -408,7 +404,6 @@ int convertYToRow(int y0)\n       {\n         int h = getRowHeight(row);\n \n-        // System.err.println(\"convertYToRow(\" + y0 + \") vs. \" + h);\n         if (y0 < h)\n           return row;\n         y0 -= h;\n@@ -468,7 +463,6 @@ void damageLayout()\n    */\n   void maybeUpdateLayoutState()\n   {\n-    // System.err.println(this + \".maybeUpdateLayoutState()\");\n     if (updateLayoutStateNeeded != 0)\n       {\n         updateLayoutState();\n@@ -576,7 +570,6 @@ public void installUI(final JComponent c)\n     installDefaults();\n     installListeners();\n     installKeyboardActions();\n-    // System.err.println(this + \".installUI()\");\n     maybeUpdateLayoutState();\n   }\n \n@@ -618,11 +611,9 @@ public Dimension getMaximumSize(JComponent c)\n    */\n   public Dimension getPreferredSize(JComponent c)\n   {\n-    maybeUpdateLayoutState();\n     if (list.getModel().getSize() == 0)\n       return new Dimension(0, 0);\n-    int nrows = Math.min(list.getVisibleRowCount(), list.getModel().getSize());\n-    Rectangle bounds = getCellBounds(list, 0, nrows - 1);\n+    Rectangle bounds = getCellBounds(list, 0, list.getModel().getSize() - 1);\n     return bounds.getSize();\n   }\n \n@@ -678,7 +669,7 @@ void paintCell(Graphics g, int row, Rectangle bounds, ListCellRenderer rend,\n    */\n   public void paint(Graphics g, JComponent c)\n   {\n-    int nrows = Math.min(list.getVisibleRowCount(), list.getModel().getSize());\n+    int nrows = list.getModel().getSize();\n     if (nrows == 0)\n       return;\n \n@@ -687,11 +678,13 @@ public void paint(Graphics g, JComponent c)\n     ListModel model = list.getModel();\n     ListSelectionModel sel = list.getSelectionModel();\n     int lead = sel.getLeadSelectionIndex();\n+    Rectangle clip = g.getClipBounds();\n     paintBackground(g, list);\n \n     for (int row = 0; row < nrows; ++row)\n       {\n         Rectangle bounds = getCellBounds(list, row, row);\n+        if (bounds.intersects(clip))\n         paintCell(g, row, bounds, render, model, sel, lead);\n       }\n   }"}, {"sha": "324fa01ff08bf0c3c538f080f7c84e7edc54c416", "filename": "libjava/javax/swing/plaf/basic/BasicLookAndFeel.java", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -250,7 +250,7 @@ protected void initComponentDefaults(UIDefaults defaults)\n       \"Button.foreground\", new ColorUIResource(Color.black),\n       \"Button.highlight\", new ColorUIResource(Color.white),\n       \"Button.light\", new ColorUIResource(Color.lightGray.brighter()),\n-      \"Button.margin\", new InsetsUIResource(2, 2, 2, 2),\n+      \"Button.margin\", new InsetsUIResource(2, 14, 2, 14),\n       \"Button.shadow\", new ColorUIResource(Color.gray),\n       \"Button.textIconGap\", new Integer(4),\n       \"Button.textShiftOffset\", new Integer(0),\n@@ -493,7 +493,7 @@ protected void initComponentDefaults(UIDefaults defaults)\n         \"ENTER\", \"return\",\n         \"SPACE\", \"return\"\n       },\n-      \"Menutext.selectionBackground\", new ColorUIResource(lightPurple),\n+      \"Menu.selectionBackground\", new ColorUIResource(lightPurple),\n       \"Menu.selectionForeground\", new ColorUIResource(Color.black),\n       \"MenuBar.background\", new ColorUIResource(Color.lightGray),\n       \"MenuBar.border\", new BasicBorders.MenuBarBorder(null, null),\n@@ -875,12 +875,12 @@ protected void initComponentDefaults(UIDefaults defaults)\n       \"ToolBar.background\", new ColorUIResource(Color.lightGray),\n       \"ToolBar.border\", new BorderUIResource.EtchedBorderUIResource(),\n       \"ToolBar.dockingBackground\", new ColorUIResource(Color.lightGray),\n-      \"ToolBar.dockingForeground\", new ColorUIResource(Color.red),\n+      \"ToolBar.dockingForeground\", new ColorUIResource(11, 30, 143),\n       \"ToolBar.floatingBackground\", new ColorUIResource(Color.lightGray),\n-      \"ToolBar.floatingForeground\", new ColorUIResource(Color.darkGray),\n+      \"ToolBar.floatingForeground\", new ColorUIResource(113, 171, 212),\n       \"ToolBar.font\", new FontUIResource(\"Dialog\", Font.PLAIN, 12),\n       \"ToolBar.foreground\", new ColorUIResource(Color.black),\n-      \"ToolBar.separatorSize\", new DimensionUIResource(10, 10),\n+      \"ToolBar.separatorSize\", new DimensionUIResource(20, 20),\n       \"ToolTip.background\", new ColorUIResource(Color.white),\n       \"ToolTip.border\", new BorderUIResource.LineBorderUIResource(Color.lightGray),\n       \"ToolTip.font\", new FontUIResource(\"SansSerif\", Font.PLAIN, 12),"}, {"sha": "f0bd73fa0bf25a0339d64e6351693d0f06f8c2e3", "filename": "libjava/javax/swing/plaf/basic/BasicMenuBarUI.java", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuBarUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -101,9 +101,9 @@ public BasicMenuBarUI()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Creates ChangeListener\n    *\n-   * @return DOCUMENT ME!\n+   * @return The ChangeListener\n    */\n   protected ChangeListener createChangeListener()\n   {\n@@ -112,7 +112,7 @@ protected ChangeListener createChangeListener()\n \n   /**\n    * Creates ContainerListener() to listen for ContainerEvents\n-   * fired by JMenuBar\n+   * fired by JMenuBar.\n    *\n    * @return The ContainerListener\n    */\n@@ -242,7 +242,7 @@ protected void uninstallKeyboardActions()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Unregisters all the listeners that this UI delegate was using.\n    */\n   protected void uninstallListeners()\n   {\n@@ -273,7 +273,8 @@ public void stateChanged(ChangeEvent event)\n   }\n \n   /**\n-   * This class handles ContainerEvents fired by JMenuBar\n+   * This class handles ContainerEvents fired by JMenuBar. It revalidates\n+   * and repaints menu bar whenever menu is added or removed from it.\n    */\n   protected class ContainerHandler implements ContainerListener\n   {\n@@ -284,17 +285,19 @@ protected class ContainerHandler implements ContainerListener\n      */\n     public void componentAdded(ContainerEvent e)\n     {\n-      System.out.println(\"BasicMenuBar...componentAdded.. listener\");\n+      menuBar.revalidate();\n+      menuBar.repaint();\n     }\n \n     /**\n-     * This method is called whenever menu is removed from the menu bar\n+     * This method is called whenever menu is removed from the menu bar.\n      *\n      * @param e The ContainerEvent.\n      */\n     public void componentRemoved(ContainerEvent e)\n     {\n-      System.out.println(\"BasicMenuBar...componentRemoved.. listener\");\n+      menuBar.revalidate();\n+      menuBar.repaint();\n     }\n   }\n \n@@ -313,6 +316,8 @@ public void propertyChange(PropertyChangeEvent e)\n     {\n       if (e.getPropertyName().equals(JMenuBar.BORDER_PAINTED_CHANGED_PROPERTY))\n \tmenuBar.repaint();\n+      if (e.getPropertyName().equals(JMenuBar.MARGIN_CHANGED_PROPERTY))\n+\tmenuBar.repaint();\n     }\n   }\n }"}, {"sha": "e52d3f63e798290bf3303e69e8aa3acc4acf3379", "filename": "libjava/javax/swing/plaf/basic/BasicMenuItemUI.java", "status": "modified", "additions": 77, "deletions": 36, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuItemUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuItemUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuItemUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -35,7 +35,6 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing.plaf.basic;\n \n import java.awt.Color;\n@@ -152,7 +151,7 @@ public class BasicMenuItemUI extends MenuItemUI\n   protected Color selectionBackground;\n \n   /**\n-   * Color of the background that is used when menu item is selected.\n+   * Color of the text that is used when menu item is selected.\n    */\n   protected Color selectionForeground;\n \n@@ -276,6 +275,11 @@ public Dimension getMinimumSize(JComponent c)\n   public MenuElement[] getPath()\n   {\n     ArrayList path = new ArrayList();\n+\n+    // Path to menu should also include its popup menu.\n+    if (menuItem instanceof JMenu)\n+      path.add(((JMenu) menuItem).getPopupMenu());\n+\n     Component c = menuItem;\n     while (c instanceof MenuElement)\n       {\n@@ -305,19 +309,6 @@ public MenuElement[] getPath()\n   protected Dimension getPreferredMenuItemSize(JComponent c, Icon checkIcon,\n                                                Icon arrowIcon,\n                                                int defaultTextIconGap)\n-  {\n-    // FIXME: Need to implement.\n-    return null;\n-  }\n-\n-  /**\n-   * Returns preferred size of the given component\n-   *\n-   * @param c component for which to return preferred size\n-   *\n-   * @return $Dimension$ preferred size for the given component\n-   */\n-  public Dimension getPreferredSize(JComponent c)\n   {\n     JMenuItem m = (JMenuItem) c;\n     Dimension d = BasicGraphicsUtils.getPreferredButtonSize(m,\n@@ -361,10 +352,17 @@ public Dimension getPreferredSize(JComponent c)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns preferred size of the given component\n+   *\n+   * @param c component for which to return preferred size\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+   * @return $Dimension$ preferred size for the given component\n    */\n+  public Dimension getPreferredSize(JComponent c)\n+  {\n+    return getPreferredMenuItemSize(c, checkIcon, arrowIcon, defaultTextIconGap);\n+  }\n+\n   protected String getPropertyPrefix()\n   {\n     return null;\n@@ -416,6 +414,7 @@ protected void installKeyboardActions()\n   protected void installListeners()\n   {\n     menuItem.addMouseListener(mouseInputListener);\n+    menuItem.addMouseMotionListener(mouseInputListener);\n     menuItem.addMenuDragMouseListener(menuDragMouseListener);\n     menuItem.addMenuKeyListener(menuKeyListener);\n     menuItem.addPropertyChangeListener(propertyChangeListener);\n@@ -433,6 +432,7 @@ public void installUI(JComponent c)\n     super.installUI(c);\n     menuItem = (JMenuItem) c;\n     installDefaults();\n+    installComponents(menuItem);\n     installListeners();\n   }\n \n@@ -516,7 +516,7 @@ protected void paintMenuItem(Graphics g, JComponent c, Icon checkIcon,\n       {\n \tif (m.isContentAreaFilled())\n \t  {\n-\t    g.setColor(m.getBackground().darker());\n+\t    g.setColor(selectionBackground);\n \t    g.fillRect(br.x, br.y, br.width, br.height);\n \t  }\n       }\n@@ -529,6 +529,7 @@ protected void paintMenuItem(Graphics g, JComponent c, Icon checkIcon,\n \t  }\n       }\n \n+    // If this menu item is a JCheckBoxMenuItem then paint check icon\n     if (checkIcon != null)\n       {\n \tSwingUtilities.layoutCompoundLabel(m, fm, null, checkIcon, vertAlign,\n@@ -543,6 +544,7 @@ protected void paintMenuItem(Graphics g, JComponent c, Icon checkIcon,\n \tvr.x = cr.x + cr.width + defaultTextIconGap;\n       }\n \n+    // if this is a submenu, then paint arrow icon to indicate it.\n     if (arrowIcon != null && (c instanceof JMenu))\n       {\n \tif (! ((JMenu) c).isTopLevelMenu())\n@@ -555,27 +557,25 @@ protected void paintMenuItem(Graphics g, JComponent c, Icon checkIcon,\n \t  }\n       }\n \n-    // paint text and user menu icon if it exists\t     \n-    SwingUtilities.layoutCompoundLabel(c, fm, m.getText(), m.getIcon(),\n-                                       vertAlign, horAlign, vertTextPos,\n-                                       horTextPos, vr, ir, tr,\n-                                       defaultTextIconGap);\n-\n-    paintText(g, m, tr, m.getText());\n-\n     // paint icon\n     // FIXME: should paint different icon at different button state's.\n     // i.e disabled icon when button is disabled.. etc.\n-\n-    /*\n     Icon i = m.getIcon();\n     if (i != null)\n       {\n-         int x = ir.x;\n-         int y = ir.y;\n-         i.paintIcon(c, g, x, y);\n+\ti.paintIcon(c, g, vr.x, vr.y);\n+\n+\t// Adjust view rectangle, s.t text would be drawn after menu item's icon.\n+\tvr.x += i.getIconWidth() + defaultTextIconGap;\n       }\n-    */\n+\n+    // paint text and user menu icon if it exists\t     \n+    SwingUtilities.layoutCompoundLabel(c, fm, m.getText(), m.getIcon(),\n+                                       vertAlign, horAlign, vertTextPos,\n+                                       horTextPos, vr, ir, tr,\n+                                       defaultTextIconGap);\n+\n+    paintText(g, m, tr, m.getText());\n \n     // paint accelerator    \n     String acceleratorText = \"\";\n@@ -612,11 +612,28 @@ protected void paintText(Graphics g, JMenuItem menuItem, Rectangle textRect,\n     Font f = menuItem.getFont();\n     g.setFont(f);\n     FontMetrics fm = g.getFontMetrics(f);\n-    g.setColor(menuItem.getForeground());\n \n+    if (text != null && ! text.equals(\"\"))\n+      {\n+\tif (menuItem.isEnabled())\n+\t  g.setColor(menuItem.getForeground());\n+\telse\n+\t  // FIXME: should fix this to use 'disabledForeground', but its\n+\t  // default value in BasicLookAndFeel is null.\t  \n+\t  g.setColor(Color.gray);\n+\n+\tint mnemonicIndex = menuItem.getDisplayedMnemonicIndex();\n+\n+\tif (mnemonicIndex != -1)\n+\t  BasicGraphicsUtils.drawStringUnderlineCharAt(g, text, mnemonicIndex,\n+\t                                               textRect.x,\n+\t                                               textRect.y\n+\t                                               + fm.getAscent());\n+\telse\n     BasicGraphicsUtils.drawString(g, text, 0, textRect.x,\n                                   textRect.y + fm.getAscent());\n   }\n+  }\n \n   /**\n    * This method uninstalls the components for this {@link JMenuItem}.\n@@ -682,6 +699,7 @@ public void uninstallUI(JComponent c)\n   {\n     uninstallListeners();\n     uninstallDefaults();\n+    uninstallComponents(menuItem);\n     menuItem = null;\n   }\n \n@@ -751,7 +769,14 @@ private void paintAccelerator(Graphics g, JMenuItem menuItem,\n   {\n     g.setFont(acceleratorFont);\n     FontMetrics fm = g.getFontMetrics(acceleratorFont);\n+\n+    if (menuItem.isEnabled())\n     g.setColor(acceleratorForeground);\n+    else\n+      // FIXME: should fix this to use 'disabledForeground', but its\n+      // default value in BasicLookAndFeel is null.\n+      g.setColor(Color.gray);\n+\n     BasicGraphicsUtils.drawString(g, acceleratorText, 0, acceleratorRect.x,\n                                   acceleratorRect.y + fm.getAscent());\n   }\n@@ -859,14 +884,17 @@ public void mousePressed(MouseEvent e)\n      */\n     public void mouseReleased(MouseEvent e)\n     {\n-      Rectangle size = menuItem.getBounds(); //this.getParent().getSize();\n+      Rectangle size = menuItem.getBounds();\n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n       if (e.getX() > 0 && e.getX() < size.width && e.getY() > 0\n           && e.getY() < size.height)\n         {\n-\t  MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n \t  manager.clearSelectedPath();\n-\t  menuItem.doClick(0);\n+\t  menuItem.doClick();\n         }\n+\n+      else\n+\tmanager.processMouseEvent(e);\n     }\n   }\n \n@@ -882,6 +910,8 @@ protected class MenuDragMouseHandler implements MenuDragMouseListener\n      */\n     public void menuDragMouseDragged(MenuDragMouseEvent e)\n     {\n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+      manager.setSelectedPath(e.getPath());\n     }\n \n     /**\n@@ -892,6 +922,8 @@ public void menuDragMouseDragged(MenuDragMouseEvent e)\n      */\n     public void menuDragMouseEntered(MenuDragMouseEvent e)\n     {\n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+      manager.setSelectedPath(e.getPath());\n     }\n \n     /**\n@@ -912,6 +944,13 @@ public void menuDragMouseExited(MenuDragMouseEvent e)\n      */\n     public void menuDragMouseReleased(MenuDragMouseEvent e)\n     {\n+      MenuElement[] path = e.getPath();\n+\n+      if (path[path.length - 1] instanceof JMenuItem)\n+\t((JMenuItem) path[path.length - 1]).doClick();\n+\n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+      manager.clearSelectedPath();\n     }\n   }\n \n@@ -963,6 +1002,8 @@ protected class PropertyChangeHandler implements PropertyChangeListener\n      */\n     public void propertyChange(PropertyChangeEvent evt)\n     {\n+      menuItem.revalidate();\n+      menuItem.repaint();\n     }\n   }\n }"}, {"sha": "01dca763dbd2de2976ee33c72ac0cc92acc776ec", "filename": "libjava/javax/swing/plaf/basic/BasicMenuUI.java", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -213,8 +213,11 @@ protected void installDefaults()\n     acceleratorFont = defaults.getFont(\"Menu.acceleratorFont\");\n     acceleratorForeground = defaults.getColor(\"Menu.acceleratorForeground\");\n     acceleratorSelectionForeground = defaults.getColor(\"Menu.acceleratorSelectionForeground\");\n+    selectionBackground = defaults.getColor(\"Menu.selectionBackground\");\n+    selectionForeground = defaults.getColor(\"Menu.selectionForeground\");\n     arrowIcon = defaults.getIcon(\"Menu.arrowIcon\");\n     oldBorderPainted = defaults.getBoolean(\"Menu.borderPainted\");\n+    menuItem.setOpaque(true);\n   }\n \n   /**\n@@ -233,7 +236,9 @@ protected void installKeyboardActions()\n   protected void installListeners()\n   {\n     ((JMenu) menuItem).addMouseListener(mouseInputListener);\n+    ((JMenu) menuItem).addMouseMotionListener(mouseInputListener);\n     ((JMenu) menuItem).addMenuListener(menuListener);\n+    ((JMenu) menuItem).addMenuDragMouseListener(menuDragMouseListener);\n   }\n \n   protected void setupPostTimer(JMenu menu)\n@@ -254,6 +259,8 @@ protected void uninstallDefaults()\n     acceleratorFont = null;\n     acceleratorForeground = null;\n     acceleratorSelectionForeground = null;\n+    selectionBackground = null;\n+    selectionForeground = null;\n     arrowIcon = null;\n   }\n \n@@ -304,11 +311,10 @@ public void mouseEntered(MouseEvent e)\n                selected. (If nothing was selected, menu should be pressed before\n                it will be selected)      \n       */\n-      \n       JMenu menu = (JMenu) menuItem;\n       if (! menu.isTopLevelMenu()\n           || (menu.isTopLevelMenu()\n-          && (((JMenuBar) menu.getParent()).isSelected())))\n+          && (((JMenuBar) menu.getParent()).isSelected() && ! menu.isArmed())))\n         {\n \t  // set new selection and forward this event to MenuSelectionManager\n \t  MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n@@ -329,7 +335,6 @@ public void mouseMoved(MouseEvent e)\n \n     public void mousePressed(MouseEvent e)\n     {\n-\n       MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n       JMenu menu = (JMenu) menuItem;\n       manager.processMouseEvent(e);\n@@ -339,11 +344,9 @@ public void mousePressed(MouseEvent e)\n       if (menu.isTopLevelMenu())\n         {\n \t  if (menu.getPopupMenu().isVisible())\n-\t    {\n \t      // If menu is visible and menu button was pressed.. \n \t      // then need to cancel the menu\n \t      manager.clearSelectedPath();\n-\t    }\n \t  else\n \t    {\n \t      // Display the menu\n@@ -374,30 +377,44 @@ protected class MenuHandler implements MenuListener\n   {\n     /**\n      * This method is called when menu is cancelled. The menu is cancelled\n-     * when its popup menu is closed without selection.\n+     * when its popup menu is closed without selection. It clears selected index\n+     * in the selectionModel of the menu parent.\n      *\n      * @param e The MenuEvent.\n      */\n     public void menuCanceled(MenuEvent e)\n     {\n+      menuDeselected(e);\n     }\n \n     /**\n-     * This method is called when menu is deselected.\n+     * This method is called when menu is deselected. It clears selected index\n+     * in the selectionModel of the menu parent.\n      *\n      * @param e The MenuEvent.\n      */\n     public void menuDeselected(MenuEvent e)\n     {\n+      JMenu menu = (JMenu) menuItem;\n+      if (menu.isTopLevelMenu())\n+\t((JMenuBar) menu.getParent()).getSelectionModel().clearSelection();\n+      else\n+\t((JPopupMenu) menu.getParent()).getSelectionModel().clearSelection();\n     }\n \n     /**\n-     * This method is called when menu is selected.\n+     * This method is called when menu is selected.  It sets selected index\n+     * in the selectionModel of the menu parent.\n      *\n      * @param e The MenuEvent.\n      */\n     public void menuSelected(MenuEvent e)\n     {\n+      JMenu menu = (JMenu) menuItem;\n+      if (menu.isTopLevelMenu())\n+\t((JMenuBar) menu.getParent()).setSelected(menu);\n+      else\n+\t((JPopupMenu) menu.getParent()).setSelected(menu);\n     }\n   }\n \n@@ -426,31 +443,35 @@ public void stateChanged(ChangeEvent e)\n   }\n \n   /**\n-   * This class handles mouse dragged events.\n+   * This class handles mouse dragged events occuring in the menu.\n    */\n   protected class MenuDragMouseHandler implements MenuDragMouseListener\n   {\n     /**\n-     * Tbis method is invoked when mouse is dragged over the menu item.\n+     * This method is invoked when mouse is dragged over the menu item.\n      *\n      * @param e The MenuDragMouseEvent\n      */\n     public void menuDragMouseDragged(MenuDragMouseEvent e)\n     {\n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+      manager.setSelectedPath(e.getPath());\n     }\n \n     /**\n-     * Tbis method is invoked when mouse enters the menu item while it is\n+     * This method is invoked when mouse enters the menu item while it is\n      * being dragged.\n      *\n      * @param e The MenuDragMouseEvent\n      */\n     public void menuDragMouseEntered(MenuDragMouseEvent e)\n     {\n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+      manager.setSelectedPath(e.getPath());\n     }\n \n     /**\n-     * Tbis method is invoked when mouse exits the menu item while\n+     * This method is invoked when mouse exits the menu item while\n      * it is being dragged\n      *\n      * @param e The MenuDragMouseEvent\n@@ -460,7 +481,7 @@ public void menuDragMouseExited(MenuDragMouseEvent e)\n     }\n \n     /**\n-     * Tbis method is invoked when mouse was dragged and released\n+     * This method is invoked when mouse was dragged and released\n      * inside the menu item.\n      *\n      * @param e The MenuDragMouseEvent"}, {"sha": "8a696b8cbc10e9219cfb56adb2b82e10c0bdd217", "filename": "libjava/javax/swing/plaf/basic/BasicOptionPaneUI.java", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicOptionPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicOptionPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicOptionPaneUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -56,13 +56,15 @@\n import java.awt.event.ActionListener;\n import java.beans.PropertyChangeEvent;\n import java.beans.PropertyChangeListener;\n+import java.beans.PropertyVetoException;\n import javax.swing.Box;\n import javax.swing.BoxLayout;\n import javax.swing.Icon;\n import javax.swing.JButton;\n import javax.swing.JComboBox;\n import javax.swing.JComponent;\n import javax.swing.JDialog;\n+import javax.swing.JInternalFrame;\n import javax.swing.JLabel;\n import javax.swing.JList;\n import javax.swing.JOptionPane;\n@@ -111,7 +113,7 @@ public void actionPerformed(ActionEvent e)\n       Object value = new Integer(JOptionPane.CLOSED_OPTION);\n       Object[] options = optionPane.getOptions();\n       if (options != null)\n-\tvalue = options[buttonIndex];\n+\tvalue = new Integer(buttonIndex);\n       else\n         {\n \t  String text = ((JButton) e.getSource()).getText();\n@@ -131,6 +133,20 @@ public void actionPerformed(ActionEvent e)\n \n       if (owner instanceof JDialog)\n \t((JDialog) owner).dispose();\n+\n+      //else we probably have some kind of internal frame.\n+      JInternalFrame inf = (JInternalFrame) SwingUtilities.getAncestorOfClass(JInternalFrame.class,\n+                                                                              optionPane);\n+      if (inf != null)\n+        {\n+\t  try\n+\t    {\n+\t      inf.setClosed(true);\n+\t    }\n+\t  catch (PropertyVetoException pve)\n+\t    {\n+\t    }\n+        }\n     }\n   }\n \n@@ -642,10 +658,10 @@ protected void addButtonComponents(Container container, Object[] buttons,\n \t\t  toAdd = new JButton((Icon) buttons[i]);\n \t\telse\n \t\t  toAdd = new JButton(buttons[i].toString());\n-\t\t((JButton) toAdd).addActionListener(createButtonActionListener(i));\n \t\thasCustomComponents = true;\n \t      }\n-\n+\t    if (toAdd instanceof JButton)\n+\t      ((JButton) toAdd).addActionListener(createButtonActionListener(i));\n \t    if (i == initialIndex)\n \t      initialFocusComponent = toAdd;\n \t    container.add(toAdd);\n@@ -837,8 +853,7 @@ protected Container createMessageArea()\n     {\n     public Dimension getPreferredSize()\n     {\n-      int w = Math.max(optionPane.getSize().width,\n-                       minimumWidth);\n+\t  int w = Math.max(optionPane.getSize().width, minimumWidth);\n       Insets i = optionPane.getInsets();\n       Dimension orig = super.getPreferredSize();\n       Dimension value = new Dimension(w - i.left - i.right - iconSize,\n@@ -856,10 +871,13 @@ public Dimension getPreferredSize()\n       {\n \tObject[] selection = optionPane.getSelectionValues();\n \n+//\tif (selection == null)\n+//\t  inputComponent = new JTextField();\n+//\telse if (selection.length < 20)\n+//\t  inputComponent = new JComboBox(selection);\n+\t// FIXME: Uncomment when the widgets are done.\n \tif (selection == null)\n-\t  inputComponent = new JTextField();\n-\telse if (selection.length < 20)\n-\t  inputComponent = new JComboBox(selection);\n+\t  inputComponent = null;\n \telse\n \t  inputComponent = new JList(selection);\n \tif (inputComponent != null)\n@@ -972,7 +990,9 @@ protected Icon getIconForType(int messageType)\n \ttmp = questionIcon;\n \tbreak;\n       }\n-    return new IconUIResource(tmp);\n+    return tmp;\n+    // FIXME: Don't cast till the default icons are in.\n+    // return new IconUIResource(tmp);\n   }\n \n   /**"}, {"sha": "f5b3e24c277f2200883d2bdbe9fb8dd8c07f8461", "filename": "libjava/javax/swing/plaf/basic/BasicPopupMenuUI.java", "status": "modified", "additions": 142, "deletions": 63, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicPopupMenuUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicPopupMenuUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicPopupMenuUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -40,15 +40,20 @@\n import java.awt.AWTKeyStroke;\n import java.awt.BasicStroke;\n import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n import java.awt.Dimension;\n import java.awt.Font;\n import java.awt.FontMetrics;\n import java.awt.Graphics;\n import java.awt.Graphics2D;\n import java.awt.GridBagLayout;\n+import java.awt.GridLayout;\n import java.awt.Insets;\n import java.awt.Rectangle;\n import java.awt.Stroke;\n+import java.awt.event.ComponentEvent;\n+import java.awt.event.ComponentListener;\n import java.awt.event.FocusAdapter;\n import java.awt.event.FocusEvent;\n import java.awt.event.FocusListener;\n@@ -88,54 +93,67 @@\n \n \n /**\n- * DOCUMENT ME!\n+ * UI Delegate for JPopupMenu\n  */\n public class BasicPopupMenuUI extends PopupMenuUI\n {\n+  /* popupMenu for which this UI delegate is for*/\n   protected JPopupMenu popupMenu;\n+\n+  /* MouseInputListener listens to mouse events */\n   private static transient MouseInputListener mouseInputListener;\n+\n+  /* PopupMenuListener listens to popup menu events fired by JPopupMenu*/\n   private transient PopupMenuListener popupMenuListener;\n \n+  /* ComponentListener listening to popupMenu's invoker. */\n+  private TopWindowListener topWindowListener;\n+\n   /**\n    * Creates a new BasicPopupMenuUI object.\n    */\n   public BasicPopupMenuUI()\n   {\n     popupMenuListener = new PopupMenuHandler();\n     mouseInputListener = new MouseInputHandler();\n+    topWindowListener = new TopWindowListener();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Factory method to create a BasicPopupMenuUI for the given {@link\n+   * JComponent}, which should be a {@link JMenuItem}.\n    *\n-   * @param x DOCUMENT ME!\n+   * @param x The {@link JComponent} a UI is being created for.\n    *\n-   * @return DOCUMENT ME!\n+   * @return A BasicPopupMenuUI for the {@link JComponent}.\n    */\n   public static ComponentUI createUI(JComponent x)\n   {\n     return new BasicPopupMenuUI();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Installs and initializes all fields for this UI delegate. Any properties\n+   * of the UI that need to be initialized and/or set to defaults will be\n+   * done now. It will also install any listeners necessary.\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c The {@link JComponent} that is having this UI installed.\n    */\n   public void installUI(JComponent c)\n   {\n     super.installUI(c);\n     popupMenu = (JPopupMenu) c;\n     popupMenu.setLayout(new GridBagLayout());\n     popupMenu.setBorderPainted(true);\n-    popupMenu.setDefaultLightWeightPopupEnabled(true);\n+    JPopupMenu.setDefaultLightWeightPopupEnabled(true);\n \n     installDefaults();\n     installListeners();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method installs the defaults that are defined in  the Basic look and\n+   * feel for this {@link JPopupMenu}.\n    */\n   public void installDefaults()\n   {\n@@ -148,7 +166,7 @@ public void installDefaults()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method installs the listeners for the {@link JMenuItem}.\n    */\n   protected void installListeners()\n   {\n@@ -158,16 +176,19 @@ protected void installListeners()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method installs the keyboard actions for this {@link JPopupMenu}.\n    */\n   protected void installKeyboardActions()\n   {\n+    // FIXME: Need to implement\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Performs the opposite of installUI. Any properties or resources that need\n+   * to be cleaned up will be done now. It will also uninstall any listeners\n+   * it has. In addition, any properties of this UI will be nulled.\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c The {@link JComponent} that is having this UI uninstalled.\n    */\n   public void uninstallUI(JComponent c)\n   {\n@@ -177,7 +198,8 @@ public void uninstallUI(JComponent c)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method uninstalls the defaults and sets any objects created during\n+   * install to null\n    */\n   protected void uninstallDefaults()\n   {\n@@ -188,164 +210,221 @@ protected void uninstallDefaults()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Unregisters all the listeners that this UI delegate was using.\n    */\n   protected void uninstallListeners()\n   {\n+    popupMenu.removeMouseListener(mouseInputListener);\n+    popupMenu.removeMouseMotionListener(mouseInputListener);\n+    popupMenu.removePopupMenuListener(popupMenuListener);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Uninstalls any keyboard actions.\n    */\n   protected void uninstallKeyboardActions()\n   {\n+    // FIXME: Need to implement\n   }\n \n   /**\n-   * DOCUMENT ME!\n+  * This method returns the minimum size of the JPopupMenu.\n    *\n-   * @param c DOCUMENT ME!\n+  * @param c The JComponent to find a size for.\n    *\n-   * @return DOCUMENT ME!\n+  * @return The minimum size.\n    */\n   public Dimension getMinimumSize(JComponent c)\n   {\n     return null;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method returns the preferred size of the JPopupMenu.\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c The JComponent to find a size for.\n    *\n-   * @return DOCUMENT ME!\n+   * @return The preferred size.\n    */\n   public Dimension getPreferredSize(JComponent c)\n   {\n     return null;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This method returns the minimum size of the JPopupMenu.\n    *\n-   * @param c DOCUMENT ME!\n+   * @param c The JComponent to find a size for.\n    *\n-   * @return DOCUMENT ME!\n+   * @return The minimum size.\n    */\n   public Dimension getMaximumSize(JComponent c)\n   {\n     return null;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Return true if given mouse event is a platform popup trigger,\n+   * and false otherwise\n    *\n-   * @param e DOCUMENT ME!\n+   * @param e MouseEvent that is to be checked for popup trigger event\n    *\n-   * @return DOCUMENT ME!\n+   * @return true if given mouse event is a platform popup trigger,\n+   * and false otherwise\n    */\n   public boolean isPopupTrigger(MouseEvent e)\n   {\n     return false;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * This listener handles PopupMenuEvents fired by JPopupMenu\n    */\n-  protected class PopupMenuHandler implements PopupMenuListener\n+  private class PopupMenuHandler implements PopupMenuListener\n   {\n     /**\n-     * DOCUMENT ME!\n+     * This method is invoked when JPopupMenu is cancelled.\n      *\n-     * @param event DOCUMENT ME!\n+     * @param event the PopupMenuEvent\n      */\n     public void popupMenuCanceled(PopupMenuEvent event)\n     {\n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+      manager.clearSelectedPath();\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * This method is invoked when JPopupMenu becomes invisible\n      *\n-     * @param event DOCUMENT ME!\n+     * @param event the PopupMenuEvent\n      */\n     public void popupMenuWillBecomeInvisible(PopupMenuEvent event)\n     {\n+      // remove listener that listens to component events fired \n+      // by the top - level window that this popup belongs to.\n+      Component invoker = popupMenu.getInvoker();\n+\n+      Container rootContainer = (Container) SwingUtilities.getRoot(invoker);\n+      rootContainer.removeComponentListener(topWindowListener);\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * This method is invoked when JPopupMenu becomes visible\n      *\n-     * @param event DOCUMENT ME!\n+     * @param event the PopupMenuEvent\n      */\n     public void popupMenuWillBecomeVisible(PopupMenuEvent event)\n     {\n+      // Adds topWindowListener to top-level window to listener to \n+      // ComponentEvents fired by it. We need to cancel this popup menu\n+      // if topWindow to which this popup belongs was resized or moved.\n+      Component invoker = popupMenu.getInvoker();\n+      Container rootContainer = (Container) SwingUtilities.getRoot(invoker);\n+      rootContainer.addComponentListener(topWindowListener);\n+\n+      // if this popup menu is a free floating popup menu,\n+      // then by default its first element should be always selected when\n+      // this popup menu becomes visible. \n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+\n+      if (manager.getSelectedPath().length == 0)\n+        {\n+\t  // Set selected path to point to the first item in the popup menu\n+\t  MenuElement[] path = new MenuElement[2];\n+\t  path[0] = popupMenu;\n+\t  Component[] comps = popupMenu.getComponents();\n+\t  if (comps.length != 0 && comps[0] instanceof MenuElement)\n+\t    path[1] = (MenuElement) comps[0];\n+\t  manager.setSelectedPath(path);\n+        }\n     }\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * ComponentListener that listens to Component Events fired by the\n+   * top - level window to which popup menu belongs. If top-level\n+   * window was resized, moved or hidded then popup menu will\n+   * be hidded and selected path of current menu hierarchy will be set\n+   * to null.\n+   *\n    */\n-  protected class MouseInputHandler implements MouseInputListener\n+  private class TopWindowListener implements ComponentListener\n   {\n     /**\n-     * DOCUMENT ME!\n+     * This method is invoked when top-level window is resized.\n+     * This method closes current menu hierarchy.\n      *\n-     * @param e DOCUMENT ME!\n+     * @param e The ComponentEvent\n      */\n-    public void mouseClicked(MouseEvent e)\n+    public void componentResized(ComponentEvent e)\n     {\n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+      manager.clearSelectedPath();\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * This method is invoked when top-level window is moved.\n+     * This method closes current menu hierarchy.\n      *\n-     * @param e DOCUMENT ME!\n+     * @param e The ComponentEvent\n      */\n-    public void mouseDragged(MouseEvent e)\n+    public void componentMoved(ComponentEvent e)\n     {\n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+      manager.clearSelectedPath();\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * This method is invoked when top-level window is shown\n+     * This method does nothing by default.\n      *\n-     * @param e DOCUMENT ME!\n+     * @param e The ComponentEvent\n      */\n-    public void mouseEntered(MouseEvent e)\n+    public void componentShown(ComponentEvent e)\n     {\n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+      manager.clearSelectedPath();\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * This method is invoked when top-level window is hidden\n+     * This method closes current menu hierarchy.\n      *\n-     * @param e DOCUMENT ME!\n+     * @param e The ComponentEvent\n      */\n+    public void componentHidden(ComponentEvent e)\n+    {\n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+      manager.clearSelectedPath();\n+    }\n+  }\n+\n+  private class MouseInputHandler implements MouseInputListener\n+  {\n+    public void mouseClicked(MouseEvent e)\n+    {\n+    }\n+\n+    public void mouseDragged(MouseEvent e)\n+    {\n+    }\n+\n+    public void mouseEntered(MouseEvent e)\n+    {\n+    }\n+\n     public void mouseExited(MouseEvent e)\n     {\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @param e DOCUMENT ME!\n-     */\n     public void mouseMoved(MouseEvent e)\n     {\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @param e DOCUMENT ME!\n-     */\n     public void mousePressed(MouseEvent e)\n     {\n     }\n \n-    /**\n-     * DOCUMENT ME!\n-     *\n-     * @param e DOCUMENT ME!\n-     */\n     public void mouseReleased(MouseEvent e)\n     {\n     }"}, {"sha": "a63c95fbc55482fdc5fe72647f69d320a8715e09", "filename": "libjava/javax/swing/plaf/basic/BasicRadioButtonMenuItemUI.java", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRadioButtonMenuItemUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRadioButtonMenuItemUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRadioButtonMenuItemUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -38,7 +38,6 @@\n package javax.swing.plaf.basic;\n \n import java.awt.event.MouseEvent;\n-\n import javax.swing.JComponent;\n import javax.swing.JMenuItem;\n import javax.swing.MenuElement;\n@@ -49,7 +48,7 @@\n \n \n /**\n- * DOCUMENT ME!\n+ * UI Delegator for JRadioButtonMenuItem\n  */\n public class BasicRadioButtonMenuItemUI extends BasicMenuItemUI\n {\n@@ -64,11 +63,12 @@ public BasicRadioButtonMenuItemUI()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+    * Factory method to create a BasicRadioButtonMenuItemUI for the given {@link\n+    * JComponent}, which should be a JRadioButtonMenuItem.\n    *\n-   * @param b DOCUMENT ME!\n+    * @param b The {@link JComponent} a UI is being created for.\n    *\n-   * @return $returnType$ DOCUMENT ME!\n+    * @return A BasicRadioButtonMenuItemUI for the {@link JComponent}.\n    */\n   public static ComponentUI createUI(JComponent b)\n   {\n@@ -83,7 +83,6 @@ public static ComponentUI createUI(JComponent b)\n   protected String getPropertyPrefix()\n   {\n     return null;\n-    // TODO\n   }\n \n   /**\n@@ -94,7 +93,8 @@ protected String getPropertyPrefix()\n    * @param path DOCUMENT ME!\n    * @param manager DOCUMENT ME!\n    */\n-  void processMouseEvent(JMenuItem item, MouseEvent e, MenuElement[] path,\n+  public void processMouseEvent(JMenuItem item, MouseEvent e,\n+                                MenuElement[] path,\n                          MenuSelectionManager manager)\n   {\n   }"}, {"sha": "7201549a2095c2bcb40409719257ce0900719a0b", "filename": "libjava/javax/swing/plaf/basic/BasicRootPaneUI.java", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRootPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRootPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRootPaneUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -38,12 +38,16 @@\n \n package javax.swing.plaf.basic;\n \n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n import javax.swing.JComponent;\n+import javax.swing.UIManager;\n import javax.swing.plaf.ComponentUI;\n import javax.swing.plaf.RootPaneUI;\n \n \n public class BasicRootPaneUI extends RootPaneUI\n+  implements PropertyChangeListener\n {\n     public static ComponentUI createUI(JComponent x) \n     {\n@@ -53,7 +57,11 @@ public static ComponentUI createUI(JComponent x)\n     public void installUI(JComponent c)\n     {\n       c.setOpaque(true);\n-      c.setBackground(javax.swing.UIManager.getColor(\"control\"));\n+    c.setBackground(UIManager.getColor(\"control\"));\n       super.installUI(c);\n     }\n+\n+  public void propertyChange(PropertyChangeEvent event)\n+  {\n+  }\n }"}, {"sha": "913b3260b9102a0070b9a67e7d23efa429bbbb45", "filename": "libjava/javax/swing/plaf/basic/BasicScrollBarUI.java", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollBarUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -548,14 +548,9 @@ public void paintIcon(Component c, Graphics g, int x, int y)\n                                                               3));\n \n   /** The Icon that points right. */\n-  private static Icon rightIcon = new arrowIcon(new Polygon(new int[]\n-                                                               {\n-                                                                 3, 7, 3\n-                                                               },\n-                                                               new int[]\n-                                                               {\n-                                                                 2, 5, 8\n-                                                               }, 3));\n+  private static Icon rightIcon = new arrowIcon(new Polygon(new int[] { 3, 7, 3},\n+                                                            new int[] { 2, 5, 8}, \n+                                                            3));\n \n   /**\n    * This method adds a component to the layout.\n@@ -606,7 +601,15 @@ protected ArrowButtonListener createArrowButtonListener()\n   protected JButton createIncreaseButton(int orientation)\n   {\n     if (incrButton == null)\n+      {\n       incrButton = new JButton();\n+        incrButton.setMargin(new Insets(0,0,0,0));\n+        incrButton.setHorizontalAlignment(SwingConstants.CENTER);\n+        incrButton.setHorizontalTextPosition(SwingConstants.CENTER);\n+        incrButton.setVerticalAlignment(SwingConstants.CENTER);\n+        incrButton.setVerticalTextPosition(SwingConstants.CENTER);\n+      }\n+    \n     if (orientation == SwingConstants.HORIZONTAL)\n       incrButton.setIcon(rightIcon);\n     else\n@@ -626,7 +629,15 @@ protected JButton createIncreaseButton(int orientation)\n   protected JButton createDecreaseButton(int orientation)\n   {\n     if (decrButton == null)\n+      {\n       decrButton = new JButton();\n+        decrButton.setMargin(new Insets(0,0,0,0));\n+        decrButton.setHorizontalAlignment(SwingConstants.CENTER);\n+        decrButton.setHorizontalTextPosition(SwingConstants.CENTER);\n+        decrButton.setVerticalAlignment(SwingConstants.CENTER);\n+        decrButton.setVerticalTextPosition(SwingConstants.CENTER);\n+      }\n+\n     if (orientation == SwingConstants.HORIZONTAL)\n       decrButton.setIcon(leftIcon);\n     else"}, {"sha": "4d70412479ad75ee7dcd95ffc358901f6289db29", "filename": "libjava/javax/swing/plaf/basic/BasicScrollPaneUI.java", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollPaneUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -43,24 +43,53 @@\n \n import javax.swing.JComponent;\n import javax.swing.JScrollPane;\n+import javax.swing.ScrollPaneConstants;\n import javax.swing.ScrollPaneLayout;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n import javax.swing.plaf.ComponentUI;\n import javax.swing.plaf.ScrollPaneUI;\n \n public class BasicScrollPaneUI extends ScrollPaneUI\n+  implements ScrollPaneConstants\n {\n \n     public static ComponentUI createUI(final JComponent c) \n     {\n \treturn new BasicScrollPaneUI();\n     }\n \n+  protected void installDefaults(JScrollPane p)\n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+    p.setForeground(defaults.getColor(\"ScrollPane.foreground\"));\n+    p.setBackground(defaults.getColor(\"ScrollPane.background\"));\n+    p.setFont(defaults.getFont(\"ScrollPane.font\"));\n+    p.setBorder(defaults.getBorder(\"ScrollPane.border\"));\n+    p.setOpaque(true);\n+  }\n+\n+  protected void uninstallDefaults(JScrollPane p)\n+  {\n+    p.setForeground(null);\n+    p.setBackground(null);\n+    p.setFont(null);\n+    p.setBorder(null);\n+  }\n     \n     public void installUI(final JComponent c) \n     {\n \tsuper.installUI(c);\n+    this.installDefaults((JScrollPane)c);\n+  }\n+\n+  public void uninstallUI(final JComponent c) \n+  {\n+    super.uninstallUI(c);\n+    this.uninstallDefaults((JScrollPane)c);\n     }\n     \n+    \n     public Dimension getMinimumSize(JComponent c) \n     {\n \tJScrollPane p = (JScrollPane ) c;"}, {"sha": "7334b2e0eb3e10c7227a90209dbe0ccd1a340097", "filename": "libjava/javax/swing/plaf/basic/BasicSliderUI.java", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSliderUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSliderUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSliderUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -58,7 +58,6 @@\n import java.beans.PropertyChangeListener;\n import java.util.Dictionary;\n import java.util.Enumeration;\n-\n import javax.swing.BoundedRangeModel;\n import javax.swing.JComponent;\n import javax.swing.JLabel;\n@@ -152,7 +151,6 @@ public void stateChanged(ChangeEvent e)\n     {\n       // Maximum, minimum, and extent values will be taken\n       // care of automatically when the slider is repainted.\n-      \n       // Only thing that needs recalculation is the thumb.\n       calculateThumbLocation();\n       slider.repaint();\n@@ -232,12 +230,12 @@ else if (e.getPropertyName().equals(JSlider.MODEL_CHANGED_PROPERTY))\n \tslider.getModel().addChangeListener(changeListener);\n \tcalculateThumbLocation();\n       }\n+\n       // elif the componentOrientation changes (this is a bound property,\n       // just undocumented) we change leftToRightCache. In Sun's \n       // implementation, the LTR cache changes on a repaint. This is strange\n       // since there is no need to do so. We could events here and \n       // update the cache. \n-      \n       // elif the border/insets change, we recalculateInsets.\n       slider.repaint();\n     }\n@@ -330,8 +328,9 @@ protected class TrackListener extends MouseInputAdapter\n     /** The current Y position of the mouse. */\n     protected int currentMouseY;\n \n-    /** The offset between the current slider value\n-        and the cursor's position. */\n+    /**\n+     * The offset between the current slider value and the cursor's position.\n+     */\n     protected int offset;\n \n     /**\n@@ -390,9 +389,6 @@ public void mousePressed(MouseEvent e)\n       if (slider.getSnapToTicks())\n \tvalue = findClosestTick(value);\n \n-      if (value == slider.getValue())\n-\treturn;\n-\n       // If the thumb is hit, then we don't need to set the timers to move it. \n       if (!thumbRect.contains(e.getPoint()))\n         {\n@@ -857,8 +853,8 @@ protected void uninstallKeyboardActions(JSlider slider)\n    */\n \n   /**\n-   * This method returns the preferred size when the slider is\n-   * horizontally oriented.\n+   * This method returns the preferred size when the slider is horizontally\n+   * oriented.\n    *\n    * @return The dimensions of the preferred horizontal size.\n    */\n@@ -868,8 +864,9 @@ public Dimension getPreferredHorizontalSize()\n     \n     // The width should cover all the labels (which are usually the\n     // deciding factor of the width)\n-    int width = getWidthOfWidestLabel() * (slider.getLabelTable() == null ? \n-                                           0 : slider.getLabelTable().size());\n+    int width = getWidthOfWidestLabel() * (slider.getLabelTable() == null ? 0\n+                                                                          : slider.getLabelTable()\n+                                                                                  .size());\n     \n     // If there are not enough labels.\n     // This number is pretty much arbitrary, but it looks nice.\n@@ -878,62 +875,61 @@ public Dimension getPreferredHorizontalSize()\n     \n     // We can only draw inside of the focusRectangle, so we have to\n     // pad it with insets.\n-    width += insets.left + insets.right + focusInsets.left + \n-             focusInsets.right;\n+    width += insets.left + insets.right + focusInsets.left + focusInsets.right;\n       \n     // Height is determined by the thumb, the ticks and the labels.\n     int height = thumbHeight;\n \n-    if (slider.getPaintTicks() && slider.getMajorTickSpacing() > 0 ||\n-        slider.getMinorTickSpacing() > 0)\n+    if (slider.getPaintTicks() && slider.getMajorTickSpacing() > 0\n+        || slider.getMinorTickSpacing() > 0)\n       height += tickHeight;\n \n     if (slider.getPaintLabels())\n       height += getHeightOfTallestLabel();\n     \n-    height += insets.top + insets.bottom + focusInsets.top + \n-              focusInsets.bottom;\n+    height += insets.top + insets.bottom + focusInsets.top\n+    + focusInsets.bottom;\n \t      \n     return new Dimension(width, height);\n   }\n \n   /**\n-   * This method returns the preferred size when the slider is\n-   * vertically oriented.\n+   * This method returns the preferred size when the slider is vertically\n+   * oriented.\n    *\n    * @return The dimensions of the preferred vertical size.\n    */\n   public Dimension getPreferredVerticalSize()\n   {\n     Insets insets = slider.getInsets();\n     \n-    int height = getHeightOfTallestLabel() * (slider.getLabelTable() == null ? \n-                                              0 : slider.getLabelTable().size());\n+    int height = getHeightOfTallestLabel() * (slider.getLabelTable() == null\n+                                              ? 0 : slider.getLabelTable()\n+                                                          .size());\n     \n     if (height < 200)\n       height = 200;\n       \n-    height += insets.top + insets.bottom + focusInsets.top + \n-             focusInsets.bottom;\n+    height += insets.top + insets.bottom + focusInsets.top\n+    + focusInsets.bottom;\n \n     int width = thumbHeight;\n     \n-    if (slider.getPaintTicks() && slider.getMajorTickSpacing() > 0 ||\n-        slider.getMinorTickSpacing() > 0)\n+    if (slider.getPaintTicks() && slider.getMajorTickSpacing() > 0\n+        || slider.getMinorTickSpacing() > 0)\n       width += tickHeight;\n \n     if (slider.getPaintLabels())\n       width += getWidthOfWidestLabel();\n \n-    width += insets.left + insets.right + focusInsets.left + \n-             focusInsets.right;\n+    width += insets.left + insets.right + focusInsets.left + focusInsets.right;\n \t     \n     return new Dimension(width, height);\n   }\n \n   /**\n-   * This method returns the minimum size when the slider is\n-   * horizontally oriented.\n+   * This method returns the minimum size when the slider is horizontally\n+   * oriented.\n    *\n    * @return The dimensions of the minimum horizontal size.\n    */\n@@ -943,8 +939,8 @@ public Dimension getMinimumHorizontalSize()\n   }\n \n   /**\n-   * This method returns the minimum size of the slider when it \n-   * is vertically oriented.\n+   * This method returns the minimum size of the slider when it  is vertically\n+   * oriented.\n    *\n    * @return The dimensions of the minimum vertical size.\n    */\n@@ -1005,8 +1001,8 @@ public Dimension getMaximumSize(JComponent c)\n   }\n   \n   /**\n-   * This method calculates all the sizes of the rectangles by delegating\n-   * to the helper methods calculateXXXRect.\n+   * This method calculates all the sizes of the rectangles by delegating to\n+   * the helper methods calculateXXXRect.\n    */\n    protected void calculateGeometry()\n    {\n@@ -1539,18 +1535,17 @@ public void paintTrack(Graphics g)\n \tc.translate((trackRect.width / 2) + (width / 2), trackRect.height);\n \td.translate((trackRect.width / 2) + (width / 2), 0);\n       }\n-    high = new Polygon(new int[] { b.x, c.x, d.x },\n-                       new int[] { b.y, c.y, d.y }, 3);\n-    shadow = new Polygon(new int[] { b.x, a.x, d.x },\n-                         new int[] { b.y, a.y, d.y }, 3);\n+    g.setColor(Color.GRAY);\n+    g.fillRect(a.x, a.y, width, height);\n \n     g.setColor(getHighlightColor());\n-    g.drawPolygon(high);\n+    g.drawLine(b.x, b.y, c.x, c.y);\n+    g.drawLine(c.x, c.y, d.x, d.y);\n+\n     g.setColor(getShadowColor());\n-    g.drawPolygon(shadow);\n+    g.drawLine(b.x, b.y, a.x, a.y);\n+    g.drawLine(a.x, a.y, d.x, d.y);\n \n-    g.setColor(Color.GRAY);\n-    g.fillRect(a.x + 1, a.y + 1, width - 2, height - 2);\n     g.setColor(saved_color);\n   }\n \n@@ -1662,8 +1657,11 @@ protected void paintMinorTickForHorizSlider(Graphics g,\n                                               Rectangle tickBounds, int x)\n   {\n     int y = tickRect.y + tickRect.height / 4;\n+    Color saved = g.getColor();\n+    g.setColor(Color.BLACK);\n \n     g.drawLine(x, y, x, y + tickRect.height / 4);\n+    g.setColor(saved);\n   }\n \n   /**\n@@ -1678,8 +1676,11 @@ protected void paintMajorTickForHorizSlider(Graphics g,\n                                               Rectangle tickBounds, int x)\n   {\n     int y = tickRect.y + tickRect.height / 4;\n+    Color saved = g.getColor();\n+    g.setColor(Color.BLACK);\n \n     g.drawLine(x, y, x, y + tickRect.height / 2);\n+    g.setColor(saved);\n   }\n \n   /**\n@@ -1694,8 +1695,11 @@ protected void paintMinorTickForVertSlider(Graphics g, Rectangle tickBounds,\n                                              int y)\n   {\n     int x = tickRect.x + tickRect.width / 4;\n+    Color saved = g.getColor();\n+    g.setColor(Color.BLACK);\n \n     g.drawLine(x, y, x + tickRect.width / 4, y);\n+    g.setColor(saved);\n   }\n \n   /**\n@@ -1710,8 +1714,11 @@ protected void paintMajorTickForVertSlider(Graphics g, Rectangle tickBounds,\n                                              int y)\n   {\n     int x = tickRect.x + tickRect.width / 4;\n+    Color saved = g.getColor();\n+    g.setColor(Color.BLACK);\n \n     g.drawLine(x, y, x + tickRect.width / 2, y);\n+    g.setColor(saved);\n   }\n \n   /**\n@@ -1786,7 +1793,6 @@ protected void paintHorizontalLabel(Graphics g, int value, Component label)\n     // the labels may not fit inside the slider's bounds. Rather than mucking \n     // with font sizes and possible icon sizes, we'll set the bounds for\n     // the label and let it get clipped.\n-\n     Dimension dim = label.getPreferredSize();\n     int w = (int) dim.getWidth();\n     int h = (int) dim.getHeight();\n@@ -1804,8 +1810,6 @@ protected void paintHorizontalLabel(Graphics g, int value, Component label)\n     //        |          |\n     //        |          |\n     //  The label must move w/2 to the right to fit directly under the value.\n-    \n-    \n     int xpos = xPositionForValue(value) - w / 2;\n     int ypos = labelRect.y;\n "}, {"sha": "e06eb05f580d3aa2cb8c79cb546bf76c14e98a1c", "filename": "libjava/javax/swing/plaf/basic/BasicSplitPaneDivider.java", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneDivider.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneDivider.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneDivider.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -157,6 +157,29 @@ public class BasicSplitPaneDivider extends Container\n    * buttons. */\n   private transient int currentDividerLocation = 1;\n \n+  private transient Border tmpBorder = new Border()\n+  {\n+    public Insets getBorderInsets(Component c)\n+    {\n+      return new Insets(2, 2, 2, 2);\n+    }\n+    \n+    public boolean isBorderOpaque()\n+    {\n+      return false;\n+    }\n+    \n+    public void paintBorder(Component c, Graphics g, int x, int y, int width, int height)\n+    {\n+      Color saved = g.getColor();\n+      g.setColor(Color.BLACK);\n+      \n+      g.drawRect(x + 2, y + 2, width - 4, height - 4);\n+      \n+      g.setColor(saved);\n+    }\n+  };\n+\n   /**\n    * Constructs a new divider.\n    *\n@@ -167,6 +190,7 @@ public BasicSplitPaneDivider(BasicSplitPaneUI ui)\n     setLayout(new DividerLayout());\n     setBasicSplitPaneUI(ui);\n     setDividerSize(splitPane.getDividerSize());\n+    setBorder(tmpBorder);\n   }\n \n   /**"}, {"sha": "f73b52045babbeddfbc6e4ca368b23adf31213f2", "filename": "libjava/javax/swing/plaf/basic/BasicSplitPaneUI.java", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -133,7 +133,7 @@ else if (place.equals(JSplitPane.BOTTOM)\n \tthrow new IllegalArgumentException(\"Illegal placement in JSplitPane\");\n       components[i] = component;\n       resetSizeAt(i);\n-      layoutContainer(splitPane);\n+      splitPane.revalidate();\n       splitPane.repaint();\n     }\n \n@@ -1265,15 +1265,9 @@ public void setDividerLocation(JSplitPane jc, int location)\n     tmpSizes[1] = layoutManager.getAvailableSize(splitPane.getSize(),\n                                                  splitPane.getInsets())\n                   - tmpSizes[0] - tmpSizes[1];\n-    Point p = divider.getLocation();\n \n-//    if (getOrientation() == JSplitPane.HORIZONTAL_SPLIT)\n-    //    setLastDragLocation(p.x);\n-//    else\n-//      setLastDragLocation(p.y);\n     layoutManager.setSizes(tmpSizes);\n-    layoutManager.layoutContainer(splitPane);\n-\n+    splitPane.revalidate();\n     splitPane.repaint();\n   }\n \n@@ -1414,7 +1408,7 @@ protected void resetLayoutManager()\n     getSplitPane().setLayout(layoutManager);\n \n     // invalidating by itself does not invalidate the layout.\n-    getSplitPane().invalidate();\n+    getSplitPane().revalidate();\n   }\n \n   /**\n@@ -1437,7 +1431,7 @@ protected void startDragging()\n \tnonContinuousLayoutDivider.setVisible(true);\n \tnonContinuousLayoutDivider.setBounds(divider.getBounds());\n       }\n-    splitPane.invalidate();\n+    splitPane.revalidate();\n     splitPane.repaint();\n   }\n "}, {"sha": "44e302b0188ef21f43c59731d1922c73d0ba359e", "filename": "libjava/javax/swing/plaf/basic/BasicTabbedPaneUI.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTabbedPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTabbedPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTabbedPaneUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -1108,7 +1108,7 @@ public void stateChanged(ChangeEvent e)\n     {\n       selectedRun = getRunForTab(tabPane.getTabCount(),\n                                  tabPane.getSelectedIndex());\n-      tabPane.layout();\n+      tabPane.revalidate();\n       tabPane.repaint();\n     }\n   }"}, {"sha": "b43fd97cf07e61edfe073c61d0637748828dd242", "filename": "libjava/javax/swing/plaf/basic/BasicTextFieldUI.java", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextFieldUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextFieldUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextFieldUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -0,0 +1,82 @@\n+/* BasicTextFieldUI.java\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.swing.plaf.basic;\n+\n+import java.beans.PropertyChangeEvent;\n+\n+import javax.swing.JComponent;\n+import javax.swing.JTextField;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.text.Element;\n+import javax.swing.text.FieldView;\n+import javax.swing.text.PlainDocument;\n+import javax.swing.text.View;\n+\n+public class BasicTextFieldUI extends BasicTextUI\n+{\n+  public BasicTextFieldUI()\n+  {\n+    super();\n+  }\n+\n+  public View create(Element elem)\n+  {\n+    return new FieldView(elem);\n+  }\n+  \n+  public static ComponentUI createUI(JComponent c)\n+  {\n+    return new BasicTextFieldUI();\n+  }\n+\n+  protected String getPropertyPrefix()\n+  {\n+    return \"TextField\";\n+  }\n+\n+  public void installUI(JComponent c)\n+  {\n+    super.installUI(c);\n+  }\n+\n+  protected void propertyChange(PropertyChangeEvent event)\n+  {\n+    // Does nothing by default.\n+  }\n+}"}, {"sha": "817a5e4a290c4076e876faee360989fb9c844092", "filename": "libjava/javax/swing/plaf/basic/BasicTextUI.java", "status": "modified", "additions": 184, "deletions": 34, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -1,5 +1,5 @@\n /* BasicTextUI.java\n-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,95 +35,219 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package javax.swing.plaf.basic;\n \n import java.awt.Color;\n+import java.awt.Container;\n import java.awt.Dimension;\n import java.awt.Graphics;\n+import java.awt.Insets;\n import java.awt.Point;\n import java.awt.Rectangle;\n+import java.awt.Shape;\n+\n import javax.swing.JComponent;\n import javax.swing.plaf.ComponentUI;\n import javax.swing.plaf.TextUI;\n+import javax.swing.plaf.UIResource;\n import javax.swing.text.BadLocationException;\n+import javax.swing.text.Caret;\n+import javax.swing.text.DefaultCaret;\n import javax.swing.text.DefaultEditorKit;\n+import javax.swing.text.DefaultHighlighter;\n+import javax.swing.text.Document;\n import javax.swing.text.EditorKit;\n import javax.swing.text.Element;\n+import javax.swing.text.Highlighter;\n import javax.swing.text.JTextComponent;\n+import javax.swing.text.PlainDocument;\n import javax.swing.text.Position;\n import javax.swing.text.View;\n import javax.swing.text.ViewFactory;\n \n \n-public class BasicTextUI extends TextUI\n+public abstract class BasicTextUI extends TextUI\n   implements ViewFactory\n {\n-  int gap = 3;\n-  View view = null; // was: new RootView();\n-  Color textColor;\n-  Color disabledTextColor;\n-  Color normalBackgroundColor;\n-  EditorKit kit = new DefaultEditorKit();\n+  public static class BasicCaret extends DefaultCaret\n+    implements UIResource\n+  {\n+    public BasicCaret()\n+    {\n+    }\n+  }\n+\n+  public static class BasicHighlighter extends DefaultHighlighter\n+    implements UIResource\n+  {\n+    public BasicHighlighter()\n+    {\n+    }\n+  }\n \n-  /* *****************************************************************\n-   * This View is way too incomplete to be of any use. To avoid errors\n-   * when compiling with the Sun JDK, it has been commented out.\n-   *                            -- Sascha Brawer (brawer@dandelis.ch)\n-   *\n-   * (begin of commented out section)\n-  class RootView extends View\n+  private class RootView extends View\n   {\n-      RootView()\n+    private JTextComponent textComponent;\n+    private View view;\n+    \n+    public RootView(JTextComponent parent)\n       {\n           super(null);\n+      textComponent = parent;\n       }\n-      public void paint(Graphics g, Shape s)\n+\n+    public void setView(View v)\n       {\n           if (view != null)\n+\tview.setParent(null);\n+      \n+      if (v != null)\n+\tv.setParent(null);\n+\n+      view = v;\n+    }\n+\n+    public Container getContainer()\n               {\n-                  Rectangle r = s.getBounds();\n+      return textComponent;\n+    }\n+\n+    public float getPreferredSpan(int axis)\n+    {\n+      if (view != null)\n+\treturn view.getPreferredSpan(axis);\n \n-                  view.setSize((int)r.getWidth(),\n-                               (int)r.getHeight());\n-                  view.paint(g, s);\n+      return Integer.MAX_VALUE;\n               }\n+\n+    public void paint(Graphics g, Shape s)\n+    {\n+      System.out.println(\"Michael: BasicTextUI.RootView.paint\");\n+      \n+      if (view != null)\n+\tview.paint(g, s);\n       }\n   }\n-  * (end of commented out section)\n-  *************************************************************** */\n+  \n+  RootView rootView;\n+  JTextComponent textComponent;\n+  int gap = 3;\n+  EditorKit kit = new DefaultEditorKit();\n+\n   public BasicTextUI()\n   {\n   }\n \n-  public static ComponentUI createUI(final JComponent c)\n+  protected Caret createCaret()\n   {\n-    return new BasicTextUI();\n+    return new BasicCaret();\n+  }\n+\n+  protected Highlighter createHighlighter()\n+  {\n+    return new BasicHighlighter();\n+  }\n+  \n+  protected final JTextComponent getComponent()\n+  {\n+    return textComponent;\n   }\n \n   public void installUI(final JComponent c)\n   {\n     super.installUI(c);\n+    c.setOpaque(true);\n \n-    textColor = new Color(0, 0, 0);\n-    disabledTextColor = new Color(130, 130, 130);\n-    normalBackgroundColor = new Color(192, 192, 192);\n+    textComponent = (JTextComponent) c;\n+\n+    Document doc = textComponent.getDocument();\n+    if (doc == null)\n+      {\n+\tdoc = new PlainDocument();\n+\ttextComponent.setDocument(doc);\n   }\n \n-  public Dimension getPreferredSize(JComponent c)\n+    rootView = new RootView(textComponent);\n+    setView(create(doc.getDefaultRootElement()));\n+    \n+    installDefaults();\n+    installListeners();\n+    installKeyboardActions();\n+  }\n+\n+  protected void installDefaults()\n+  {\n+  }\n+\n+  protected void installListeners()\n   {\n-    JTextComponent b = (JTextComponent) c;\n+  }\n \n-    View v = getRootView(b);\n+  protected void installKeyboardActions()\n+  {\n+  }\n+  \n+  public void uninstallUI(final JComponent c)\n+  {\n+    super.uninstallUI(c);\n+    rootView = null;\n+\n+    uninstallDefaults();\n+    uninstallListeners();\n+    uninstallKeyboardActions();\n+  }\n+\n+  protected void uninstallDefaults()\n+  {\n+  }\n+\n+  protected void uninstallListeners()\n+  {\n+  }\n+\n+  protected void uninstallKeyboardActions()\n+  {\n+  }\n+  \n+  protected abstract String getPropertyPrefix();\n+\n+  public Dimension getPreferredSize(JComponent c)\n+  {\n+    View v = getRootView(textComponent);\n \n     float w = v.getPreferredSpan(View.X_AXIS);\n     float h = v.getPreferredSpan(View.Y_AXIS);\n \n     return new Dimension((int) w, (int) h);\n   }\n \n-  public void paint(Graphics g, JComponent c)\n+  public final void paint(Graphics g, JComponent c)\n   {\n-    //\tview.paint(\n+    paintSafely(g);\n+  }\n+\n+  protected void paintSafely(Graphics g)\n+  {\n+    Caret caret = textComponent.getCaret();\n+    Highlighter highlighter = textComponent.getHighlighter();\n+    \n+    if (textComponent.isOpaque())\n+      paintBackground(g);\n+    \n+    rootView.paint(g, getVisibleEditorRect());\n+\n+    if (highlighter != null)\n+      highlighter.paint(g);\n+\n+    if (caret != null)\n+      caret.paint(g);\n+  }\n+\n+  protected void paintBackground(Graphics g)\n+  {\n+    g.setColor(Color.WHITE); // FIXME: set background color\n+    g.fillRect(0, 0, textComponent.getWidth(), textComponent.getHeight());\n   }\n \n   public void damageRange(JTextComponent t, int p0, int p1)\n@@ -151,7 +275,7 @@ public int getNextVisualPositionFrom(JTextComponent t, int pos,\n \n   public View getRootView(JTextComponent t)\n   {\n-    return view;\n+    return rootView;\n   }\n \n   public Rectangle modelToView(JTextComponent t, int pos)\n@@ -181,4 +305,30 @@ public View create(Element elem)\n     // subclasses have to implement this to get this functionality\n     return null;\n   }\n+\n+  public View create(Element elem, int p0, int p1)\n+  {\n+    // subclasses have to implement this to get this functionality\n+    return null;\n+  }\n+  \n+  protected Rectangle getVisibleEditorRect()\n+  {\n+    int width = textComponent.getWidth();\n+    int height = textComponent.getHeight();\n+\n+    if (width <= 0 || height <= 0)\n+      return null;\n+\t\n+    Insets insets = textComponent.getInsets();\n+    return new Rectangle(insets.left, insets.top,\n+\t\t\t width - insets.left + insets.right,\n+\t\t\t height - insets.top + insets.bottom);\n+  }\n+\n+  protected final void setView(View view)\n+  {\n+    rootView.setView(view);\n+    view.setParent(rootView);\n+  }\n }"}, {"sha": "f35968c65300325d836c7bdda127420da49d978f", "filename": "libjava/javax/swing/plaf/basic/BasicToolBarSeparatorUI.java", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToolBarSeparatorUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToolBarSeparatorUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToolBarSeparatorUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -0,0 +1,132 @@\n+/* BasicToolBarSeparatorUI.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.Rectangle;\n+import javax.swing.JComponent;\n+import javax.swing.JToolBar.Separator;\n+import javax.swing.JSeparator;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.SeparatorUI;\n+\n+\n+/**\n+ * The Basic Look and Feel UI delegate for Separator.\n+ */\n+public class BasicToolBarSeparatorUI extends BasicSeparatorUI\n+{\n+  private transient Dimension size;\n+\n+  /**\n+   * Creates a new UI delegate for the given JComponent.\n+   *\n+   * @param c The JComponent to create a delegate for.\n+   *\n+   * @return A new BasicToolBarSeparatorUI.\n+   */\n+  public static ComponentUI createUI(JComponent c)\n+  {\n+    return new BasicToolBarSeparatorUI();\n+  }\n+\n+  /**\n+   * This method installs the defaults that are given by the Basic L&F.\n+   *\n+   * @param s The Separator that is being installed.\n+   */\n+  protected void installDefaults(JSeparator s)\n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+    \n+    size = defaults.getDimension(\"ToolBar.separatorSize\");\n+  }\n+\n+  /**\n+   * This method does nothing as a Separator is just blank space.\n+   *\n+   * @param g The Graphics object to paint with\n+   * @param c The JComponent to paint.\n+   */\n+  public void paint(Graphics g, JComponent c)\n+  {\n+    // Do nothing.\n+  }\n+\n+  /**\n+   * This method returns the preferred size of the  JComponent.\n+   *\n+   * @param c The JComponent to measure.\n+   *\n+   * @return The preferred size.\n+   */\n+  public Dimension getPreferredSize(JComponent c)\n+  {\n+    return size;\n+  }\n+\n+  /**\n+   * This method returns the minimum size of the JComponent.\n+   *\n+   * @param c The JComponent to measure.\n+   *\n+   * @return The minimum size.\n+   */\n+  public Dimension getMinimumSize(JComponent c)\n+  {\n+    return size;\n+  }\n+\n+  /**\n+   * This method returns the maximum size of the JComponent.\n+   *\n+   * @param c The JComponent to measure.\n+   *\n+   * @return The maximum size.\n+   */\n+  public Dimension getMaximumSize(JComponent c)\n+  {\n+    return size;\n+  }\n+}"}, {"sha": "4fb142b1c9e793593a6e23ee7b5694e3e07bcbaf", "filename": "libjava/javax/swing/plaf/basic/BasicToolBarUI.java", "status": "modified", "additions": 1187, "deletions": 90, "changes": 1277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToolBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToolBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToolBarUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -37,304 +37,1401 @@\n \n package javax.swing.plaf.basic;\n \n+import java.awt.BorderLayout;\n+import java.awt.Color;\n import java.awt.Component;\n import java.awt.ComponentOrientation;\n import java.awt.Container;\n-import java.awt.Color;\n import java.awt.Dimension;\n+import java.awt.Graphics;\n import java.awt.GridLayout;\n+import java.awt.Insets;\n import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Window;\n+import java.awt.event.ContainerEvent;\n+import java.awt.event.ContainerListener;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.event.WindowListener;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n import java.util.Enumeration;\n-import javax.swing.JFrame;\n+import java.util.Hashtable;\n import javax.swing.JButton;\n import javax.swing.JComponent;\n+import javax.swing.JDialog;\n+import javax.swing.JFrame;\n import javax.swing.JToolBar;\n import javax.swing.RootPaneContainer;\n+import javax.swing.SwingConstants;\n+import javax.swing.SwingUtilities;\n import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.border.Border;\n import javax.swing.event.MouseInputListener;\n-\n-import java.beans.PropertyChangeListener;\n-import java.awt.event.ContainerListener;\n-import java.awt.event.FocusListener;\n-import java.awt.event.MouseAdapter;\n-import java.awt.event.MouseEvent;\n-import java.awt.event.WindowListener;\n-\n+import javax.swing.plaf.BorderUIResource;\n+import javax.swing.plaf.BorderUIResource.EtchedBorderUIResource;\n import javax.swing.plaf.ComponentUI;\n import javax.swing.plaf.ToolBarUI;\n+import javax.swing.plaf.UIResource;\n \n-public class BasicToolBarUI extends ToolBarUI\n+\n+/**\n+ * This is the Basic Look and Feel UI class for JToolBar.\n+ */\n+public class BasicToolBarUI extends ToolBarUI implements SwingConstants\n {\n+  /** Static owner of all DragWindows. */\n+  private static JFrame owner = new JFrame();\n+\n+  /** The border used when the JToolBar is in nonrollover mode. */\n+  private static Border nonRolloverBorder;\n \n-  public class DragWindow\n-  {}\n+  /** The border used when the JToolBar is in rollover mode. */\n+  private static Border rolloverBorder;\n \n+  /** The last known BorderLayout constraint before floating. */\n     protected String constraintBeforeFloating;\n+\n+  /** The last known orientation of the JToolBar before floating. */\n+  private int lastGoodOrientation;\n+\n+  /** The color of the border when it is dockable. */\n     protected Color dockingBorderColor;\n+\n+  /** The background color of the JToolBar when it is dockable. */\n     protected Color dockingColor;\n+\n+  /** The docking listener responsible for mouse events on the JToolBar. */\n     protected MouseInputListener dockingListener;\n-    //protected KeyStroke downKey\n-    //          Deprecated. As of Java 2 platform v1.3.\n+\n+  /** The window used for dragging the JToolBar. */\n     protected BasicToolBarUI.DragWindow dragWindow;\n+\n+  /** The color of the border when it is not dockable. */\n     protected Color floatingBorderColor;\n+\n+  /** The background color of the JToolBar when it is not dockable. */\n     protected Color floatingColor;\n+\n+  /** The index of the focused component. */\n     protected int focusedCompIndex;\n-    //protected KeyStroke leftKey;\n-    //          Deprecated. As of Java 2 platform v1.3.\n+\n+  /** The PropertyChangeListener for the JToolBar. */\n     protected PropertyChangeListener propertyListener;\n-    //protected KeyStroke rightKey;\n-    //          Deprecated. As of Java 2 platform v1.3.\n+\n+  /** The JToolBar this UI delegate is responsible for. */\n     protected JToolBar toolBar;\n+\n+  /** The Container listener for the JToolBar. */\n     protected ContainerListener toolBarContListener;\n-    protected FocusListener toolBarFocusListener;\n-    //        protected KeyStroke upKey;\n-    //        Deprecated. As of Java 2 platform v1.3.\n \n-    private Dimension maximumSize;\n-    private Dimension minimumSize;\n-    private Dimension preferredSize;\n-    private boolean floating;\n-    private boolean rolloverBorders;\n+  /** The Focus listener for the JToolBar. */\n+  protected FocusListener toolBarFocusListener;\n+\n+  /**\n+   * The floating window that is responsible for holding the JToolBar when it\n+   * is dragged outside of its original parent.\n+   */\n+  private transient Window floatFrame;\n+\n+  /** The original parent of the JToolBar. */\n+  private transient Container origParent;\n+\n+  /** A hashtable of components and their original borders. */\n+  private transient Hashtable borders;\n+\n+  /** A window listener for the floatable frame. */\n+  private transient WindowListener windowListener;\n \n-    BasicToolBarUI(JToolBar b)\n+  /** A set of cached bounds of the JToolBar. */\n+  private transient Dimension cachedBounds;\n+\n+  /** The cached orientation of the JToolBar. */\n+  private transient int cachedOrientation;\n+\n+  /**\n+   * This method creates a new BasicToolBarUI object for the given JToolBar.\n+   *\n+   * @param b The JToolBar to represent with this UI.\n+   */\n+  public BasicToolBarUI(JToolBar b)\n     {\n \tsuper();\n     }\n \n-    /* Can Component c dock at Point p? */\n-    boolean canDock(Component c, Point p)\n+  /**\n+   * This method returns whether the JToolBar can dock at the given position.\n+   *\n+   * @param c The component to try to dock in.\n+   * @param p The position of the mouse cursor relative to the given\n+   *        component.\n+   *\n+   * @return Whether the JToolBar can dock.\n+   */\n+  protected boolean canDock(Component c, Point p)\n     {\n+    if (areaOfClick(c, p) != -1)\n+      return true;\n+\n \treturn false;\n     }\n \n+  /**\n+   * This helper method returns the position of the JToolBar if it can dock.\n+   *\n+   * @param c The component to try to dock in.\n+   * @param p The position of the mouse cursor relative to the given\n+   *        component.\n+   *\n+   * @return One of the SwingConstants directions or -1 if the JToolBar can't\n+   *         dock.\n+   */\n+  private int areaOfClick(Component c, Point p)\n+  {\n+    // Has to dock in immediate parent, not eventual root container.\n+    Rectangle pBounds = c.getBounds();\n+\n+    // XXX: In Sun's implementation, the space the toolbar has to dock is dependent on the size it had last.\n+    Dimension d = toolBar.getSize();\n+    int limit = Math.min(d.width, d.height);\n+\n+    // The order of checking is 1. top 2. bottom 3. left 4. right\n+    if (! pBounds.contains(p))\n+      return -1;\n+\n+    if (p.y < limit)\n+      return SwingConstants.NORTH;\n+\n+    if (p.y > (pBounds.height - limit))\n+      return SwingConstants.SOUTH;\n+\n+    if (p.x < limit)\n+      return SwingConstants.WEST;\n+\n+    if (p.x > (pBounds.width - limit))\n+      return SwingConstants.EAST;\n+\n+    return -1;\n+  }\n+\n+  /**\n+   * This method creates a new DockingListener for the JToolBar.\n+   *\n+   * @return A new DockingListener for the JToolBar.\n+   */\n     protected MouseInputListener createDockingListener()\n     {\n-      return null;\n+    return new DockingListener(toolBar);\n     }\n \n+  /**\n+   * This method creates a new DragWindow for the given JToolBar.\n+   *\n+   * @param toolbar The JToolBar to create a DragWindow for.\n+   *\n+   * @return A new DragWindow.\n+   */\n     protected BasicToolBarUI.DragWindow createDragWindow(JToolBar toolbar)\n     {\n-      return null;\n+    return new DragWindow();\n     }\n \n+  /**\n+   * This method creates a new floating frame for the JToolBar. By default,\n+   * this UI uses createFloatingWindow instead. This method of creating a\n+   * floating frame is deprecated.\n+   *\n+   * @param toolbar The JToolBar to create a floating frame for.\n+   *\n+   * @return A new floating frame.\n+   */\n     protected JFrame createFloatingFrame(JToolBar toolbar)\n     {\n+    // FIXME: Though deprecated, this should still work.\n       return null;\n     }\n \n+  /**\n+   * This method creates a new floating window for the JToolBar. This is the\n+   * method used by default to create a floating container for the JToolBar.\n+   *\n+   * @param toolbar The JToolBar to create a floating window for.\n+   *\n+   * @return A new floating window.\n+   */\n     protected RootPaneContainer createFloatingWindow(JToolBar toolbar)\n     {\n-      return null;\n+    // This one is used by default though.\n+    return new ToolBarDialog();\n     }\n \n+  /**\n+   * This method creates a new WindowListener for the JToolBar.\n+   *\n+   * @return A new WindowListener.\n+   */\n     protected WindowListener createFrameListener()\n     {\n-      return null;\n+    return new FrameListener();\n     }\n \n+  /**\n+   * This method creates a new nonRolloverBorder for JButtons when the\n+   * JToolBar's rollover property is set to false.\n+   *\n+   * @return A new NonRolloverBorder.\n+   */\n     protected Border createNonRolloverBorder()\n     {\n-      return null;\n+    return new EtchedBorderUIResource();\n     }\n \n+  /**\n+   * This method creates a new PropertyChangeListener for the JToolBar.\n+   *\n+   * @return A new PropertyChangeListener.\n+   */\n     protected PropertyChangeListener createPropertyListener()\n     {\n-      return null;\n+    return new PropertyListener();\n     }\n \n+  /**\n+   * This method creates a new rollover border for JButtons when the\n+   * JToolBar's rollover property is set to true.\n+   *\n+   * @return A new rollover border.\n+   */\n     protected Border createRolloverBorder()\n     {\n-      return null;\n+    return new EtchedBorderUIResource()\n+      {\n+\tpublic void paintBorder(Component c, Graphics g, int x, int y,\n+\t                        int width, int height)\n+\t{\n+\t  if (c instanceof JButton)\n+\t    {\n+\t      if (((JButton) c).getModel().isRollover())\n+\t\tsuper.paintBorder(c, g, x, y, width, height);\n+\t    }\n+\t}\n+      };\n     }\n \n+  /**\n+   * This method creates a new Container listener for the JToolBar.\n+   *\n+   * @return A new Container listener.\n+   */\n     protected ContainerListener createToolBarContListener()\n     {\n-      return null;\n+    return new ToolBarContListener();\n     }\n \n+  /**\n+   * This method creates a new FocusListener for the JToolBar.\n+   *\n+   * @return A new FocusListener for the JToolBar.\n+   */\n     protected FocusListener createToolBarFocusListener()\n     {\n-      return null;\n+    return new ToolBarFocusListener();\n     }\n \n+  /**\n+   * This method creates a new UI delegate for the given JComponent.\n+   *\n+   * @param c The JComponent to create a UI delegate for.\n+   *\n+   * @return A new UI delegate.\n+   */\n     public static ComponentUI createUI(JComponent c)\n     {\n \treturn new BasicToolBarUI((JToolBar) c);\n     }\n \n+  /**\n+   * This method is called to drag the DragWindow around when the JToolBar is\n+   * being dragged around.\n+   *\n+   * @param position The mouse cursor coordinates relative to the JToolBar.\n+   * @param origin The screen position of the JToolBar.\n+   */\n     protected void dragTo(Point position, Point origin)\n     {\n+    int loc = areaOfClick(origParent,\n+                          SwingUtilities.convertPoint(toolBar, position,\n+                                                      origParent));\n+\n+    if (loc != -1)\n+      {\n+\tdragWindow.setBorderColor(dockingBorderColor);\n+\tdragWindow.setBackground(dockingColor);\n+      }\n+    else\n+      {\n+\tdragWindow.setBorderColor(floatingBorderColor);\n+\tdragWindow.setBackground(floatingColor);\n+      }\n+\n+    int w = 0;\n+    int h = 0;\n+\n+    boolean tmp = ((loc == SwingConstants.NORTH)\n+                  || (loc == SwingConstants.SOUTH) || (loc == -1));\n+\n+    if (((cachedOrientation == SwingConstants.HORIZONTAL) && tmp)\n+        || ((cachedOrientation == VERTICAL) && ! tmp))\n+      {\n+\tw = cachedBounds.width;\n+\th = cachedBounds.height;\n+      }\n+    else\n+      {\n+\tw = cachedBounds.height;\n+\th = cachedBounds.width;\n     }\n \n+    Point p = dragWindow.getOffset();\n+    Insets insets = toolBar.getInsets();\n+\n+    dragWindow.setBounds((origin.x + position.x) - p.x\n+                         - ((insets.left + insets.right) / 2),\n+                         (origin.y + position.y) - p.y\n+                         - ((insets.top + insets.bottom) / 2), w, h);\n+\n+    if (! dragWindow.isVisible())\n+      dragWindow.show();\n+  }\n+\n+  /**\n+   * This method is used at the end of a drag session to place the frame in\n+   * either its original parent as a docked JToolBar or in its floating\n+   * frame.\n+   *\n+   * @param position The position of the mouse cursor relative to the\n+   *        JToolBar.\n+   * @param origin The screen position of the JToolBar before the drag session\n+   *        started.\n+   */\n     protected void floatAt(Point position, Point origin)\n     {\n+    Point p = new Point(position);\n+    int aoc = areaOfClick(origParent,\n+                          SwingUtilities.convertPoint(toolBar, p, origParent));\n+\n+    Container oldParent = toolBar.getParent();\n+\n+    oldParent.remove(toolBar);\n+    oldParent.doLayout();\n+    oldParent.repaint();\n+\n+    Container newParent;\n+\n+    if (aoc == -1)\n+      newParent = ((RootPaneContainer) floatFrame).getContentPane();\n+    else\n+      {\n+\tfloatFrame.hide();\n+\tnewParent = origParent;\n     }\n \n-    /* Return the Color which is displayed when over a docking area */\n-    Color getDockingColor()\n+    String constraint;\n+    switch (aoc)\n+      {\n+      case SwingConstants.EAST:\n+\tconstraint = BorderLayout.EAST;\n+\tbreak;\n+      case SwingConstants.NORTH:\n+\tconstraint = BorderLayout.NORTH;\n+\tbreak;\n+      case SwingConstants.SOUTH:\n+\tconstraint = BorderLayout.SOUTH;\n+\tbreak;\n+      case SwingConstants.WEST:\n+\tconstraint = BorderLayout.WEST;\n+\tbreak;\n+      default:\n+\tconstraint = BorderLayout.CENTER;\n+\tbreak;\n+      }\n+\n+    int newOrientation = SwingConstants.HORIZONTAL;\n+    if ((aoc != -1)\n+        && ((aoc == SwingConstants.EAST) || (aoc == SwingConstants.WEST)))\n+      newOrientation = SwingConstants.VERTICAL;\n+\n+    if (aoc != -1)\n+      {\n+\tconstraintBeforeFloating = constraint;\n+\tlastGoodOrientation = newOrientation;\n+      }\n+\n+    newParent.add(toolBar, constraint);\n+\n+    setFloating(aoc == -1, null);\n+    toolBar.setOrientation(newOrientation);\n+\n+    Insets insets = floatFrame.getInsets();\n+    Dimension dims = toolBar.getPreferredSize();\n+    p = dragWindow.getOffset();\n+    setFloatingLocation((position.x + origin.x) - p.x\n+                        - ((insets.left + insets.right) / 2),\n+                        (position.y + origin.y) - p.y\n+                        - ((insets.top + insets.bottom) / 2));\n+\n+    if (aoc == -1)\n+      {\n+\tfloatFrame.pack();\n+\tfloatFrame.setSize(dims.width + insets.left + insets.right,\n+\t                   dims.height + insets.top + insets.bottom);\n+\tfloatFrame.show();\n+      }\n+\n+    newParent.invalidate();\n+    newParent.validate();\n+    newParent.repaint();\n+  }\n+\n+  /**\n+   * This method returns the docking color.\n+   *\n+   * @return The docking color.\n+   */\n+  public Color getDockingColor()\n     {\n \treturn dockingColor;\n     }\n \n-    /* Return the Color which is displayed when over a floating area */\n-    Color getFloatingColor()\n+  /**\n+   * This method returns the Color which is displayed when over a floating\n+   * area.\n+   *\n+   * @return The color which is displayed when over a floating area.\n+   */\n+  public Color getFloatingColor()\n     {\n \treturn floatingColor;\n     }\n \n-    /* See ComponentUI */\n+  /**\n+   * This method returns the maximum size of the given JComponent for this UI.\n+   *\n+   * @param c The JComponent to find the maximum size for.\n+   *\n+   * @return The maximum size for this UI.\n+   */\n   public Dimension getMaximumSize(JComponent c)\n     {\n-      return null;\n+    return getPreferredSize(c);\n     }\n \n-    /* See ComponentUI */\n+  /**\n+   * This method returns the minimum size of the given JComponent for this UI.\n+   *\n+   * @param c The JComponent to find a minimum size for.\n+   *\n+   * @return The minimum size for this UI.\n+   */\n   public Dimension getMinimumSize(JComponent c)\n     {\n-      return null;\n+    return getPreferredSize(c);\n     }\n \n-    /* See ComponentUI */\n+  /**\n+   * This method returns the preferred size of the given JComponent for this\n+   * UI.\n+   *\n+   * @param c The JComponent to find a preferred size for.\n+   *\n+   * @return The preferred size for this UI.\n+   */\n   public Dimension getPreferredSize(JComponent c)\n     {\n-      return null;\n+    return toolBar.getLayout().preferredLayoutSize(c);\n     }\n \n+  /**\n+   * This method installs the needed components for the JToolBar.\n+   */\n     protected void installComponents()\n     {\n+    floatFrame = (Window) createFloatingWindow(toolBar);\n+\n+    dragWindow = createDragWindow(toolBar);\n+\n+    cachedBounds = toolBar.getPreferredSize();\n+    cachedOrientation = toolBar.getOrientation();\n+\n+    nonRolloverBorder = createNonRolloverBorder();\n+    rolloverBorder = createRolloverBorder();\n+\n+    borders = new Hashtable();\n+\n+    fillHashtable();\n     }\n \n+  /**\n+   * This method installs the defaults as specified by the look and feel.\n+   */\n     protected void installDefaults()\n     {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+\n+    toolBar.setBorder(new ToolBarBorder());\n+    toolBar.setBackground(defaults.getColor(\"ToolBar.background\"));\n+    toolBar.setForeground(defaults.getColor(\"ToolBar.foreground\"));\n+    toolBar.setFont(defaults.getFont(\"ToolBar.font\"));\n+\n+    dockingBorderColor = defaults.getColor(\"ToolBar.dockingForeground\");\n+    dockingColor = defaults.getColor(\"ToolBar.dockingBackground\");\n+\n+    floatingBorderColor = defaults.getColor(\"ToolBar.floatingForeground\");\n+    floatingColor = defaults.getColor(\"ToolBar.floatingBackground\");\n     }\n \n+  /**\n+   * This method installs the keyboard actions for the JToolBar as specified\n+   * by the look and feel.\n+   */\n     protected void installKeyboardActions()\n     {\n+    // FIXME: implement.\n     }\n \n+  /**\n+   * This method installs listeners for the JToolBar.\n+   *\n+   * @param toolbar The JToolBar to register listeners for.\n+   */\n     protected void installListeners(JToolBar toolbar)\n     {\n-    \ttoolbar.addMouseListener(new MouseAdapter() {\n-\t\tpublic void mouseClicked(MouseEvent event) {\n-\t\t\tSystem.err.println(\"toolbar clicked\");\n-\t\t}\n-\t} );\n-    }\n+    dockingListener = createDockingListener();\n+    toolBar.addMouseListener(dockingListener);\n+    toolBar.addMouseMotionListener(dockingListener);\n \n-    /* Call setBorderToNonRollover for each child component of c */\n+    propertyListener = createPropertyListener();\n+    toolBar.addPropertyChangeListener(propertyListener);\n+\n+    toolBarContListener = createToolBarContListener();\n+    toolBar.addContainerListener(toolBarContListener);\n+\n+    windowListener = createFrameListener();\n+    floatFrame.addWindowListener(windowListener);\n+\n+    toolBarFocusListener = createToolBarFocusListener();\n+    toolBar.addFocusListener(toolBarFocusListener);\n+  }\n+\n+  /**\n+   * This method installs non rollover borders for each component inside the\n+   * given JComponent.\n+   *\n+   * @param c The JComponent whose children need to have non rollover borders\n+   *        installed.\n+   */\n     protected void installNonRolloverBorders(JComponent c)\n     {\n+    Component[] components = toolBar.getComponents();\n+\n+    for (int i = 0; i < components.length; i++)\n+      setBorderToNonRollover(components[i]);\n     }\n \n-    /* Call setBorderToNormal for each child component of c */\n+  /**\n+   * This method installs normal (or their original) borders for each\n+   * component inside the given JComponent.\n+   *\n+   * @param c The JComponent whose children need to have their original\n+   *        borders installed.\n+   */\n     protected void installNormalBorders(JComponent c)\n     {\n+    Component[] components = toolBar.getComponents();\n+\n+    for (int i = 0; i < components.length; i++)\n+      setBorderToNormal(components[i]);\n     }\n \n-    /* Call setBorderToRollover for each child component of c */\n+  /**\n+   * This method install rollover borders for each component inside the given\n+   * JComponent.\n+   *\n+   * @param c The JComponent whose children need to have rollover borders\n+   *        installed.\n+   */\n     protected void installRolloverBorders(JComponent c)\n     {\n+    Component[] components = toolBar.getComponents();\n+\n+    for (int i = 0; i < components.length; i++)\n+      setBorderToRollover(components[i]);\n     }\n \n+  /**\n+   * This method fills the borders hashtable with a list of components that\n+   * are JButtons and their borders.\n+   */\n+  private void fillHashtable()\n+  {\n+    Component[] c = toolBar.getComponents();\n+\n+    for (int i = 0; i < c.length; i++)\n+      {\n+\tif (c[i] instanceof JButton)\n+\t  {\n+\t    // Don't really care about anything other than JButtons\n+\t    JButton b = (JButton) c[i];\n+\n+\t    if (b.getBorder() != null)\n+\t      borders.put(b, b.getBorder());\n+\t  }\n+      }\n+  }\n+\n+  /**\n+   * This method installs the UI for the given JComponent.\n+   *\n+   * @param c The JComponent to install a UI for.\n+   */\n     public void installUI(JComponent c)\n     {\n \tsuper.installUI(c);\n+\n \tif (c instanceof JToolBar)\n \t{\n \t    toolBar = (JToolBar) c;\n \t    toolBar.setOpaque(true);\n-\t    switch (toolBar.getOrientation()) {\n-\t\tcase 0: toolBar.setLayout(new GridLayout(1, 0, 4, 4));\n-\t\t\t\t break;\n-\t\tcase 1: toolBar.setLayout(new GridLayout(0, 1, 4, 4));\n-\t\t\t       break;\n-\t    }\n+\tinstallDefaults();\n+\tinstallComponents();\n \t    installListeners(toolBar);\n+\tinstallKeyboardActions();\n \t}\n     }\n \n-    boolean isFloating()\n+  /**\n+   * This method returns whether the JToolBar is floating.\n+   *\n+   * @return Whether the JToolBar is floating.\n+   */\n+  public boolean isFloating()\n     {\n-\treturn false;\n+    return floatFrame.isVisible();\n     }\n \n-    boolean isRolloverBorders()\n+  /**\n+   * This method returns whether rollover borders have been set.\n+   *\n+   * @return Whether rollover borders have been set.\n+   */\n+  public boolean isRolloverBorders()\n     {\n-\treturn false;\n+    return toolBar.isRollover();\n     }\n \n+  /**\n+   * This method navigates in the given direction giving focus to the next\n+   * component in the given direction.\n+   *\n+   * @param direction The direction to give focus to.\n+   */\n     protected void navigateFocusedComp(int direction)\n     {\n+    // FIXME: Implement.\n     }\n \n-    /* Make Component c have a non-rollover border (created by\n-       createNonRolloverBorder). */\n+  /**\n+   * This method sets the border of the given component to a non rollover\n+   * border.\n+   *\n+   * @param c The Component whose border needs to be set.\n+   */\n     protected void setBorderToNonRollover(Component c)\n     {\n+    if (c instanceof JButton)\n+      {\n+\tJButton b = (JButton) c;\n+\tb.setRolloverEnabled(false);\n+\tb.setBorder(nonRolloverBorder);\n+      }\n     }\n \n-    /* Make Component c have the border that it originally had before being\n-       added to the toolbar. */\n+  /**\n+   * This method sets the border of the given component to its original value.\n+   *\n+   * @param c The Component whose border needs to be set.\n+   */\n     protected void setBorderToNormal(Component c)\n     {\n+    if (c instanceof JButton)\n+      {\n+\tJButton b = (JButton) c;\n+\tBorder border = (Border) borders.get(b);\n+\tb.setBorder(border);\n+      }\n     }\n \n-    /* Make Component c have a rollover border (created by\n-       createRolloverBorder). */\n+  /**\n+   * This method sets the border of the given component to a rollover border.\n+   *\n+   * @param c The Component whose border needs to be set.\n+   */\n     protected void setBorderToRollover(Component c)\n     {\n+    if (c instanceof JButton)\n+      {\n+\tJButton b = (JButton) c;\n+\tb.setRolloverEnabled(true);\n+\tb.setBorder(rolloverBorder);\n+      }\n     }\n \n-    /* Display in Color c when over a docking area */\n-    void setDockingColor(Color c)\n+  /**\n+   * This method sets the docking color.\n+   *\n+   * @param c The docking color.\n+   */\n+  public void setDockingColor(Color c)\n     {\n \tdockingColor = c;\n     }\n \n-    void setFloating(boolean b, Point p)\n+  /**\n+   * This method sets the floating property for the JToolBar.\n+   *\n+   * @param b Whether the JToolBar is floating.\n+   * @param p FIXME\n+   */\n+  public void setFloating(boolean b, Point p)\n+  {\n+    // FIXME: use p for something. It's not location\n+    // since we already have setFloatingLocation.\n+    floatFrame.setVisible(b);\n+  }\n+\n+  /**\n+   * This method sets the color displayed when the JToolBar is not in a\n+   * dockable area.\n+   *\n+   * @param c The floating color.\n+   */\n+  public void setFloatingColor(Color c)\n     {\n+    floatingColor = c;\n     }\n \n-    /* Display in Color c when over a floating area */\n-    void setFloatingColor(Color c)\n+  /**\n+   * This method sets the floating location of the JToolBar.\n+   *\n+   * @param x The x coordinate for the floating frame.\n+   * @param y The y coordinate for the floating frame.\n+   */\n+  public void setFloatingLocation(int x, int y)\n+  {\n+    // x,y are the coordinates of the new JFrame created to store the toolbar\n+    // XXX: The floating location is bogus is not floating.\n+    floatFrame.setLocation(x, y);\n+    floatFrame.invalidate();\n+    floatFrame.validate();\n+    floatFrame.repaint();\n+  }\n+\n+  /**\n+   * This is a convenience method for changing the orientation of the\n+   * JToolBar.\n+   *\n+   * @param orientation The new orientation.\n+   */\n+  public void setOrientation(int orientation)\n+  {\n+    toolBar.setOrientation(orientation);\n+  }\n+\n+  /**\n+   * This method changes the child components to have rollover borders if the\n+   * given parameter is true. Otherwise, the components are set to have non\n+   * rollover borders.\n+   *\n+   * @param rollover Whether the children will have rollover borders.\n+   */\n+  public void setRolloverBorders(boolean rollover)\n+  {\n+    if (rollover)\n+      installRolloverBorders(toolBar);\n+    else\n+      installNonRolloverBorders(toolBar);\n+  }\n+\n+  /**\n+   * This method uninstall UI installed components from the JToolBar.\n+   */\n+  protected void uninstallComponents()\n     {\n-\tfloatingColor = c;\n+    installNormalBorders(toolBar);\n+    borders = null;\n+    rolloverBorder = null;\n+    nonRolloverBorder = null;\n+    cachedBounds = null;\n+\n+    floatFrame = null;\n+    dragWindow = null;\n+  }\n+\n+  /**\n+   * This method removes the defaults installed by the Look and Feel.\n+   */\n+  protected void uninstallDefaults()\n+  {\n+    toolBar.setBackground(null);\n+    toolBar.setForeground(null);\n+    toolBar.setFont(null);\n+\n+    dockingBorderColor = null;\n+    dockingColor = null;\n+    floatingBorderColor = null;\n+    floatingColor = null;\n     }\n \n-    void setFloatingLocation(int x, int y)\n+  /**\n+   * This method uninstalls keyboard actions installed by the UI.\n+   */\n+  protected void uninstallKeyboardActions()\n     {\n+    // FIXME: implement.\n     }\n \n-    void setOrientation(int orientation)\n+  /**\n+   * This method uninstalls listeners installed by the UI.\n+   */\n+  protected void uninstallListeners()\n     {\n+    toolBar.removeFocusListener(toolBarFocusListener);\n+    toolBarFocusListener = null;\n+\n+    floatFrame.removeWindowListener(windowListener);\n+    windowListener = null;\n+\n+    toolBar.removeContainerListener(toolBarContListener);\n+    toolBarContListener = null;\n+\n+    toolBar.removeMouseMotionListener(dockingListener);\n+    toolBar.removeMouseListener(dockingListener);\n+    dockingListener = null;\n     }\n \n-    /* Set flag to enable rollover borders for the toolbar */\n-    void setRolloverBorders(boolean rollover)\n+  /**\n+   * This method uninstalls the UI.\n+   *\n+   * @param c The JComponent that is having this UI removed.\n+   */\n+  public void uninstallUI(JComponent c)\n+    {\n+    uninstallKeyboardActions();\n+    uninstallListeners();\n+    uninstallComponents();\n+    uninstallDefaults();\n+    toolBar = null;\n+  }\n+\n+  /**\n+   * This is the MouseHandler class that allows the user to drag the JToolBar\n+   * in and out of the parent and dock it if it can.\n+   */\n+  protected class DockingListener implements MouseInputListener\n+  {\n+    /** Whether the JToolBar is being dragged. */\n+    protected boolean isDragging;\n+\n+    /**\n+     * The origin point. This point is saved from the beginning press and is\n+     * used until the end of the drag session.\n+     */\n+    protected Point origin;\n+\n+    /** The JToolBar being dragged. */\n+    protected JToolBar toolBar;\n+\n+    /**\n+     * Creates a new DockingListener object.\n+     *\n+     * @param t The JToolBar this DockingListener is being used for.\n+     */\n+    public DockingListener(JToolBar t)\n     {\n-\trolloverBorders = rollover;\n+      toolBar = t;\n     }\n \n-    protected void uninstallComponents()\n+    /**\n+     * This method is called when the mouse is clicked.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseClicked(MouseEvent e)\n     {\n+      // Don't care.\n     }\n \n-    protected void uninstallDefaults()\n+    /**\n+     * This method is called when the mouse is dragged. It delegates the drag\n+     * painting to the dragTo method.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseDragged(MouseEvent e)\n     {\n+      if (isDragging)\n+\tdragTo(e.getPoint(), origin);\n     }\n \n-    protected void uninstallKeyboardActions()\n+    /**\n+     * This method is called when the mouse enters the JToolBar.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseEntered(MouseEvent e)\n     {\n+      // Don't care (yet).\n     }\n \n-    protected void uninstallListeners()\n+    /**\n+     * This method is called when the mouse exits the JToolBar.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseExited(MouseEvent e)\n     {\n+      // Don't care (yet).\n     }\n \n-  public void uninstallUI(JComponent c)\n+    /**\n+     * This method is called when the mouse is moved in the JToolBar.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseMoved(MouseEvent e)\n+    {\n+    }\n+\n+    /**\n+     * This method is called when the mouse is pressed in the JToolBar. If the\n+     * press doesn't occur in a place where it causes the JToolBar to be\n+     * dragged, it returns. Otherwise, it starts a drag session.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mousePressed(MouseEvent e)\n+    {\n+      if (! toolBar.isFloatable())\n+\treturn;\n+\n+      Point ssd = e.getPoint();\n+      Insets insets = toolBar.getInsets();\n+\n+      // Verify that this click occurs in the top inset.\n+      if (toolBar.getOrientation() == SwingConstants.HORIZONTAL)\n+        {\n+\t  if (e.getX() > insets.left)\n+\t    return;\n+    }\n+      else\n+        {\n+\t  if (e.getY() > insets.top)\n+\t    return;\n+        }\n+\n+      origin = new Point(0, 0);\n+      SwingUtilities.convertPointToScreen(ssd, toolBar);\n+\n+      if (! (SwingUtilities.getAncestorOfClass(Window.class, toolBar) instanceof UIResource))\n+\t// Need to know who keeps the toolBar if it gets dragged back into it.\n+\torigParent = toolBar.getParent();\n+\n+      SwingUtilities.convertPointToScreen(origin, toolBar);\n+\n+      isDragging = true;\n+\n+      if (dragWindow != null)\n+\tdragWindow.setOffset(new Point(e.getX(), e.getY()));\n+\n+      dragTo(e.getPoint(), origin);\n+    }\n+\n+    /**\n+     * This method is called when the mouse is released from the JToolBar.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseReleased(MouseEvent e)\n+    {\n+      if (! isDragging || ! toolBar.isFloatable())\n+\treturn;\n+\n+      isDragging = false;\n+      floatAt(e.getPoint(), origin);\n+      dragWindow.hide();\n+    }\n+  }\n+\n+  /**\n+   * This is the window that appears when the JToolBar is being dragged\n+   * around.\n+   */\n+  protected class DragWindow extends Window\n+  {\n+    /**\n+     * The current border color. It changes depending on whether the JToolBar\n+     * is over a place that allows it to dock.\n+     */\n+    private Color borderColor;\n+\n+    /** The between the mouse and the top left corner of the window. */\n+    private Point offset;\n+\n+    /**\n+     * Creates a new DragWindow object.\n+     */\n+    private DragWindow()\n+    {\n+      super(owner);\n+    }\n+\n+    /**\n+     * The color that the border should be.\n+     *\n+     * @return The border color.\n+     */\n+    public Color getBorderColor()\n+    {\n+      if (borderColor == null)\n+\treturn Color.BLACK;\n+\n+      return borderColor;\n+    }\n+\n+    /**\n+     * This method returns the insets for the DragWindow.\n+     *\n+     * @return The insets for the DragWindow.\n+     */\n+    public Insets getInsets()\n+    {\n+      // This window has no decorations, so insets are empty.\n+      return new Insets(0, 0, 0, 0);\n+    }\n+\n+    /**\n+     * This method returns the mouse offset from the top left corner of the\n+     * DragWindow.\n+     *\n+     * @return The mouse offset.\n+     */\n+    public Point getOffset()\n+    {\n+      return offset;\n+    }\n+\n+    /**\n+     * This method paints the DragWindow.\n+     *\n+     * @param g The Graphics object to paint with.\n+     */\n+    public void paint(Graphics g)\n+    {\n+      //  No visiting children necessary.\n+      Color saved = g.getColor();\n+      Rectangle b = getBounds();\n+\n+      g.setColor(getBorderColor());\n+      g.drawRect(0, 0, b.width - 1, b.height - 1);\n+\n+      g.setColor(saved);\n+    }\n+\n+    /**\n+     * This method changes the border color.\n+     *\n+     * @param c The new border color.\n+     */\n+    public void setBorderColor(Color c)\n+    {\n+      borderColor = c;\n+    }\n+\n+    /**\n+     * This method changes the mouse offset.\n+     *\n+     * @param p The new mouse offset.\n+     */\n+    public void setOffset(Point p)\n     {\n+      offset = p;\n     }\n \n+    /**\n+     * FIXME: Do something.\n+     *\n+     * @param o DOCUMENT ME!\n+     */\n+    public void setOrientation(int o)\n+    {\n+      // FIXME: implement.\n+    }\n+  }\n+\n+  /**\n+   * This helper class listens for Window events from the floatable window and\n+   * if it is closed, returns the JToolBar to the last known good location.\n+   */\n+  protected class FrameListener extends WindowAdapter\n+  {\n+    /**\n+     * This method is called when the floating window is closed.\n+     *\n+     * @param e The WindowEvent.\n+     */\n+    public void windowClosing(WindowEvent e)\n+    {\n+      Container parent = toolBar.getParent();\n+      parent.remove(toolBar);\n+\n+      if (origParent != null)\n+        {\n+\t  origParent.add(toolBar,\n+\t                 (constraintBeforeFloating != null)\n+\t                 ? constraintBeforeFloating : BorderLayout.NORTH);\n+\t  toolBar.setOrientation(lastGoodOrientation);\n+        }\n+\n+      origParent.invalidate();\n+      origParent.validate();\n+      origParent.repaint();\n+    }\n+  }\n+\n+  /**\n+   * This helper class listens for PropertyChangeEvents from the JToolBar.\n+   */\n+  protected class PropertyListener implements PropertyChangeListener\n+  {\n+    /**\n+     * This method is called when a property from the JToolBar is changed.\n+     *\n+     * @param e The PropertyChangeEvent.\n+     */\n+    public void propertyChange(PropertyChangeEvent e)\n+    {\n+      // FIXME: need name properties so can change floatFrame title.\n+      if (e.getPropertyName().equals(JToolBar.ROLLOVER_CHANGED_PROPERTY))\n+\tsetRolloverBorders(toolBar.isRollover());\n+    }\n+  }\n+\n+  /**\n+   * This helper class listens for components added to and removed from the\n+   * JToolBar.\n+   */\n+  protected class ToolBarContListener implements ContainerListener\n+  {\n+    /**\n+     * This method is responsible for setting rollover or non rollover for new\n+     * buttons added to the JToolBar.\n+     *\n+     * @param e The ContainerEvent.\n+     */\n+    public void componentAdded(ContainerEvent e)\n+    {\n+      if (e.getChild() instanceof JButton)\n+        {\n+\t  JButton b = (JButton) e.getChild();\n+\n+\t  if (b.getBorder() != null)\n+\t    borders.put(b, b.getBorder());\n+        }\n+\n+      if (isRolloverBorders())\n+\tsetBorderToRollover(e.getChild());\n+      else\n+\tsetBorderToNonRollover(e.getChild());\n+\n+      cachedBounds = toolBar.getPreferredSize();\n+      cachedOrientation = toolBar.getOrientation();\n+    }\n+\n+    /**\n+     * This method is responsible for giving the child components their\n+     * original borders when they are removed.\n+     *\n+     * @param e The ContainerEvent.\n+     */\n+    public void componentRemoved(ContainerEvent e)\n+    {\n+      setBorderToNormal(e.getChild());\n+      cachedBounds = toolBar.getPreferredSize();\n+      cachedOrientation = toolBar.getOrientation();\n+    }\n+  }\n+\n+  /**\n+   * This is the floating window that is returned when getFloatingWindow is\n+   * called.\n+   */\n+  private class ToolBarDialog extends JDialog implements UIResource\n+  {\n+    /**\n+     * Creates a new ToolBarDialog object with the name given by the JToolBar.\n+     */\n+    public ToolBarDialog()\n+    {\n+      super();\n+      setName((toolBar.getName() != null) ? toolBar.getName() : \"\");\n+    }\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected class ToolBarFocusListener implements FocusListener\n+  {\n+    /**\n+     * Creates a new ToolBarFocusListener object.\n+     */\n+    protected ToolBarFocusListener()\n+    {\n+      // FIXME: implement.\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param e DOCUMENT ME!\n+     */\n+    public void focusGained(FocusEvent e)\n+    {\n+      // FIXME: implement.\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param e DOCUMENT ME!\n+     */\n+    public void focusLost(FocusEvent e)\n+    {\n+      // FIXME: implement.\n+    }\n+  }\n+\n+  /**\n+   * This helper class acts as the border for the JToolBar.\n+   */\n+  private static class ToolBarBorder implements Border\n+  {\n+    /** The size of the larger, draggable side of the border. */\n+    private static int offset = 10;\n+\n+    /** The other sides. */\n+    private static int regular = 2;\n+\n+    /**\n+     * This method returns the border insets for the JToolBar.\n+     *\n+     * @param c The Component to find insets for.\n+     *\n+     * @return The border insets.\n+     */\n+    public Insets getBorderInsets(Component c)\n+    {\n+      if (c instanceof JToolBar)\n+        {\n+\t  JToolBar tb = (JToolBar) c;\n+\t  int orientation = tb.getOrientation();\n+\n+\t  if (! tb.isFloatable())\n+\t    return new Insets(regular, regular, regular, regular);\n+\t  else if (orientation == SwingConstants.HORIZONTAL)\n+\t    return new Insets(regular, offset, regular, regular);\n+\t  else\n+\t    return new Insets(offset, regular, regular, regular);\n+        }\n+\n+      return new Insets(0, 0, 0, 0);\n+    }\n+\n+    /**\n+     * This method returns whether the border is opaque.\n+     *\n+     * @return Whether the border is opaque.\n+     */\n+    public boolean isBorderOpaque()\n+    {\n+      return false;\n+    }\n+\n+    /**\n+     * This method paints the ribbed area of the border.\n+     *\n+     * @param g The Graphics object to paint with.\n+     * @param x The x coordinate of the area.\n+     * @param y The y coordinate of the area.\n+     * @param w The width of the area.\n+     * @param h The height of the area.\n+     * @param size The size of the bump.\n+     * @param c The color of the bumps.\n+     */\n+    private void paintBumps(Graphics g, int x, int y, int w, int h, int size,\n+                            Color c)\n+    {\n+      Color saved = g.getColor();\n+      g.setColor(c);\n+\n+      int hgap = 2 * size;\n+      int vgap = 4 * size;\n+      int count = 0;\n+\n+      for (int i = x; i < (w + x); i += hgap)\n+\tfor (int j = ((count++ % 2) == 0) ? y : (y + (2 * size)); j < (h + y);\n+\t     j += vgap)\n+\t  g.fillRect(i, j, size, size);\n+\n+      g.setColor(saved);\n+    }\n+\n+    /**\n+     * This method paints the border around the given Component.\n+     *\n+     * @param c The Component whose border is being painted.\n+     * @param g The Graphics object to paint with.\n+     * @param x The x coordinate of the component.\n+     * @param y The y coordinate of the component.\n+     * @param width The width of the component.\n+     * @param height The height of the component.\n+     */\n+    public void paintBorder(Component c, Graphics g, int x, int y, int width,\n+                            int height)\n+    {\n+      if (c instanceof JToolBar)\n+        {\n+\t  JToolBar tb = (JToolBar) c;\n+\n+\t  int orientation = tb.getOrientation();\n+\n+\t  if (orientation == SwingConstants.HORIZONTAL)\n+\t    {\n+\t      paintBumps(g, x, y, offset, height, 1, Color.WHITE);\n+\t      paintBumps(g, x + 1, y + 1, offset - 1, height - 1, 1, Color.GRAY);\n+\t    }\n+\t  else\n+\t    {\n+\t      paintBumps(g, x, y, width, offset, 1, Color.WHITE);\n+\t      paintBumps(g, x + 1, y + 1, width - 1, offset - 1, 1, Color.GRAY);\n+\t    }\n+        }\n+    }\n+  }\n }"}, {"sha": "feefacaae9b2573a8edc1fd62d9dcaec72c2b251", "filename": "libjava/javax/swing/plaf/basic/BasicViewportUI.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicViewportUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicViewportUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicViewportUI.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -173,6 +173,7 @@ public void paint(Graphics g, JComponent c)\n         g.clearRect(0, 0, portBounds.width, portBounds.height);\n       }\n \n+    g2.setClip(g.getClipBounds());\n     g2.translate(-pos.x, -pos.y);\n     try \n       {"}, {"sha": "ea46ce5672bb3d40e5d6e0bd5af0f33764023c7f", "filename": "libjava/javax/swing/table/DefaultTableColumnModel.java", "status": "modified", "additions": 110, "deletions": 96, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftable%2FDefaultTableColumnModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftable%2FDefaultTableColumnModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftable%2FDefaultTableColumnModel.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -35,7 +35,6 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing.table;\n \n import java.beans.PropertyChangeEvent;\n@@ -52,21 +51,18 @@\n import javax.swing.event.TableColumnModelEvent;\n import javax.swing.event.TableColumnModelListener;\n \n+\n /**\n  * DefaultTableColumnModel\n  * @author\tAndrew Selkirk\n  * @version\t1.0\n  */\n public class DefaultTableColumnModel\n-  implements TableColumnModel, PropertyChangeListener,\n-             ListSelectionListener, Serializable\n+  implements TableColumnModel, PropertyChangeListener, ListSelectionListener,\n+             Serializable\n {\n   static final long serialVersionUID = 6580012493508960512L;\n \n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n \t/**\n \t * tableColumns\n \t */\n@@ -102,265 +98,283 @@\n \t */\n \tprotected int totalColumnWidth;\n \n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n \t/**\n \t * Constructor DefaultTableColumnModel\n \t */\n-\tpublic DefaultTableColumnModel() {\n+  public DefaultTableColumnModel()\n+  {\n \t\t// TODO\n-\t} // DefaultTableColumnModel()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n+  }\n \n \t/**\n \t * addColumn\n \t * @param value0 TODO\n \t */\n-\tpublic void addColumn(TableColumn value0) {\n+  public void addColumn(TableColumn value0)\n+  {\n \t\t// TODO\n-\t} // addColumn()\n+  }\n \n \t/**\n \t * removeColumn\n \t * @param value0 TODO\n \t */\n-\tpublic void removeColumn(TableColumn value0) {\n+  public void removeColumn(TableColumn value0)\n+  {\n \t\t// TODO\n-\t} // removeColumn()\n+  }\n \n \t/**\n \t * moveColumn\n \t * @param value0 TODO\n \t * @param value1 TODO\n \t */\n-\tpublic void moveColumn(int value0, int value1) {\n+  public void moveColumn(int value0, int value1)\n+  {\n \t\t// TODO\n-\t} // moveColumn()\n+  }\n \n \t/**\n \t * setColumnMargin\n \t * @param value0 TODO\n \t */\n-\tpublic void setColumnMargin(int value0) {\n+  public void setColumnMargin(int value0)\n+  {\n \t\t// TODO\n-\t} // setColumnMargin()\n+  }\n \n \t/**\n \t * getColumnCount\n-\t * @returns int\n+   * @return int\n \t */\n-\tpublic int getColumnCount() {\n+  public int getColumnCount()\n+  {\n \t\treturn 0; // TODO\n-\t} // getColumnCount()\n+  }\n \n \t/**\n \t * getColumns\n-\t * @returns Enumeration\n+   * @return Enumeration\n \t */\n-\tpublic Enumeration getColumns() {\n+  public Enumeration getColumns()\n+  {\n \t\treturn null; // TODO\n-\t} // getColumns()\n+  }\n \n \t/**\n \t * getColumnIndex\n \t * @param value0 TODO\n-\t * @returns int\n+   * @return int\n \t */\n-\tpublic int getColumnIndex(Object value0) {\n+  public int getColumnIndex(Object value0)\n+  {\n \t\treturn 0; // TODO\n-\t} // getColumnIndex()\n+  }\n \n \t/**\n \t * getColumn\n \t * @param value0 TODO\n-\t * @returns TableColumn\n+   * @return TableColumn\n \t */\n-\tpublic TableColumn getColumn(int value0) {\n+  public TableColumn getColumn(int value0)\n+  {\n \t\treturn null; // TODO\n-\t} // getColumn()\n+  }\n \n \t/**\n \t * getColumnMargin\n-\t * @returns int\n+   * @return int\n \t */\n-\tpublic int getColumnMargin() {\n+  public int getColumnMargin()\n+  {\n \t\treturn 0; // TODO\n-\t} // getColumnMargin()\n+  }\n \n \t/**\n \t * getColumnIndexAtX\n \t * @param value0 TODO\n-\t * @returns int\n+   * @return int\n \t */\n-\tpublic int getColumnIndexAtX(int value0) {\n+  public int getColumnIndexAtX(int value0)\n+  {\n \t\treturn 0; // TODO\n-\t} // getColumnIndexAtX()\n+  }\n \n \t/**\n \t * getTotalColumnWidth\n-\t * @returns int\n+   * @return int\n \t */\n-\tpublic int getTotalColumnWidth() {\n+  public int getTotalColumnWidth()\n+  {\n \t\treturn 0; // TODO\n-\t} // getTotalColumnWidth()\n+  }\n \n \t/**\n \t * setSelectionModel\n \t * @param value0 TODO\n \t */\n-\tpublic void setSelectionModel(ListSelectionModel value0) {\n+  public void setSelectionModel(ListSelectionModel value0)\n+  {\n \t\t// TODO\n-\t} // setSelectionModel()\n+  }\n \n \t/**\n \t * getSelectionModel\n-\t * @returns ListSelectionModel\n+   * @return ListSelectionModel\n \t */\n-\tpublic ListSelectionModel getSelectionModel() {\n+  public ListSelectionModel getSelectionModel()\n+  {\n \t\treturn null; // TODO\n-\t} // getSelectionModel()\n+  }\n \n \t/**\n \t * setColumnSelectionAllowed\n \t * @param value0 TODO\n \t */\n-\tpublic void setColumnSelectionAllowed(boolean value0) {\n+  public void setColumnSelectionAllowed(boolean value0)\n+  {\n \t\t// TODO\n-\t} // setColumnSelectionAllowed()\n+  }\n \n \t/**\n \t * getColumnSelectionAllowed\n-\t * @returns boolean\n+   * @return boolean\n \t */\n-\tpublic boolean getColumnSelectionAllowed() {\n+  public boolean getColumnSelectionAllowed()\n+  {\n \t\treturn false; // TODO\n-\t} // getColumnSelectionAllowed()\n+  }\n \n \t/**\n \t * getSelectedColumns\n-\t * @returns int[]\n+   * @return int[]\n \t */\n-\tpublic int[] getSelectedColumns() {\n+  public int[] getSelectedColumns()\n+  {\n \t\treturn null; // TODO\n-\t} // getSelectedColumns()\n+  }\n \n \t/**\n \t * getSelectedColumnCount\n-\t * @returns int\n+   * @return int\n \t */\n-\tpublic int getSelectedColumnCount() {\n+  public int getSelectedColumnCount()\n+  {\n \t\treturn 0; // TODO\n-\t} // getSelectedColumnCount()\n+  }\n \n \t/**\n \t * addColumnModelListener\n \t * @param value0 TODO\n \t */\n-\tpublic void addColumnModelListener(TableColumnModelListener value0) {\n+  public void addColumnModelListener(TableColumnModelListener value0)\n+  {\n \t\t// TODO\n-\t} // addColumnModelListener()\n+  }\n \n \t/**\n \t * removeColumnModelListener\n \t * @param value0 TODO\n \t */\n-\tpublic void removeColumnModelListener(TableColumnModelListener value0) {\n+  public void removeColumnModelListener(TableColumnModelListener value0)\n+  {\n \t\t// TODO\n-\t} // removeColumnModelListener()\n+  }\n \n \t/**\n \t * fireColumnAdded\n \t * @param value0 TODO\n \t */\n-\tprotected void fireColumnAdded(TableColumnModelEvent value0) {\n+  protected void fireColumnAdded(TableColumnModelEvent value0)\n+  {\n \t\t// TODO\n-\t} // fireColumnAdded()\n+  }\n \n \t/**\n \t * fireColumnRemoved\n \t * @param value0 TODO\n \t */\n-\tprotected void fireColumnRemoved(TableColumnModelEvent value0) {\n+  protected void fireColumnRemoved(TableColumnModelEvent value0)\n+  {\n \t\t// TODO\n-\t} // fireColumnRemoved()\n+  }\n \n \t/**\n \t * fireColumnMoved\n \t * @param value0 TODO\n \t */\n-\tprotected void fireColumnMoved(TableColumnModelEvent value0) {\n+  protected void fireColumnMoved(TableColumnModelEvent value0)\n+  {\n \t\t// TODO\n-\t} // fireColumnMoved()\n+  }\n \n \t/**\n \t * fireColumnSelectionChanged\n \t * @param value0 TODO\n \t */\n-\tprotected void fireColumnSelectionChanged(ListSelectionEvent value0) {\n+  protected void fireColumnSelectionChanged(ListSelectionEvent value0)\n+  {\n \t\t// TODO\n-\t} // fireColumnSelectionChanged()\n+  }\n \n \t/**\n \t * fireColumnMarginChanged\n \t */\n-\tprotected void fireColumnMarginChanged() {\n+  protected void fireColumnMarginChanged()\n+  {\n \t\t// TODO\n-\t} // fireColumnMarginChanged()\n+  }\n \n \t/**\n \t * getListeners\n \t * @param value0 TODO\n-\t * @returns EventListener[]\n+   * @return EventListener[]\n \t */\n-\tpublic EventListener[] getListeners(Class value0) {\n+  public EventListener[] getListeners(Class value0)\n+  {\n \t\treturn null; // TODO\n-\t} // getListeners()\n+  }\n \n \t/**\n \t * propertyChange\n \t * @param value0 TODO\n \t */\n-\tpublic void propertyChange(PropertyChangeEvent value0) {\n+  public void propertyChange(PropertyChangeEvent value0)\n+  {\n \t\t// TODO\n-\t} // propertyChange()\n+  }\n \n \t/**\n \t * valueChanged\n \t * @param value0 TODO\n \t */\n-\tpublic void valueChanged(ListSelectionEvent value0) {\n+  public void valueChanged(ListSelectionEvent value0)\n+  {\n \t\t// TODO\n-\t} // valueChanged()\n+  }\n \n \t/**\n \t * createSelectionModel\n-\t * @returns ListSelectionModel\n+   * @return ListSelectionModel\n \t */\n-\tprotected ListSelectionModel createSelectionModel() {\n+  protected ListSelectionModel createSelectionModel()\n+  {\n \t\treturn null; // TODO\n-\t} // createSelectionModel()\n+  }\n \n \t/**\n \t * recalcWidthCache\n \t */\n-\tprotected void recalcWidthCache() {\n+  protected void recalcWidthCache()\n+  {\n \t\t// TODO\n-\t} // recalcWidthCache()\n+  }\n \n \t/**\n \t * invalidateWidthCache\n \t */\n-\tprivate void invalidateWidthCache() {\n+  private void invalidateWidthCache()\n+  {\n \t\t// TODO\n-\t} // invalidateWidthCache()\n-\n-\n-} // DefaultTableColumnModel\n-\n+  }\n+}"}, {"sha": "39ae1bd5d0b155f547716fb4f7eaa070db7bd963", "filename": "libjava/javax/swing/table/TableColumn.java", "status": "modified", "additions": 135, "deletions": 128, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftable%2FTableColumn.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftable%2FTableColumn.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftable%2FTableColumn.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -35,26 +35,23 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing.table;\n \n import java.beans.PropertyChangeListener;\n import java.io.Serializable;\n import javax.swing.event.SwingPropertyChangeSupport;\n \n+\n /**\n  * TableColumn\n  * @author\tAndrew Selkirk\n  * @version\t1.0\n  */\n-public class TableColumn implements Serializable\n+public class TableColumn\n+  implements Serializable\n {\n   static final long serialVersionUID = -6113660025878112608L;\n \n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n \t/**\n \t * COLUMN_WIDTH_PROPERTY\n \t */\n@@ -138,36 +135,35 @@ public class TableColumn implements Serializable\n \t/**\n \t * changeSupport\n \t */\n-\tprivate SwingPropertyChangeSupport changeSupport = new SwingPropertyChangeSupport(this);\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n+  private SwingPropertyChangeSupport changeSupport =\n+    new SwingPropertyChangeSupport(this);\n \n \t/**\n \t * Constructor TableColumn\n \t */\n-\tpublic TableColumn() {\n+  public TableColumn()\n+  {\n \t\tthis(0, 75, null, null);\n-\t} // TableColumn()\n+  }\n \n \t/**\n \t * Constructor TableColumn\n \t * @param modelIndex TODO\n \t */\n-\tpublic TableColumn(int modelIndex) {\n+  public TableColumn(int modelIndex)\n+  {\n \t\tthis(modelIndex, 75, null, null);\n-\t} // TableColumn()\n+  }\n \n \t/**\n \t * Constructor TableColumn\n \t * @param modelIndex TODO\n \t * @param width TODO\n \t */\n-\tpublic TableColumn(int modelIndex, int width) {\n+  public TableColumn(int modelIndex, int width)\n+  {\n \t\tthis(modelIndex, width, null, null);\n-\t} // TableColumn()\n+  }\n \n \t/**\n \t * Constructor TableColumn\n@@ -177,48 +173,48 @@ public TableColumn(int modelIndex, int width) {\n \t * @param cellEditor TODO\n \t */\n \tpublic TableColumn(int modelIndex, int width,\n-\t\t\tTableCellRenderer cellRenderer, TableCellEditor cellEditor) {\n+                     TableCellRenderer cellRenderer, TableCellEditor cellEditor)\n+  {\n \t\tthis.modelIndex = modelIndex;\n \t\tthis.width = width;\n \t\tthis.preferredWidth = width;\n \t\tthis.cellRenderer = cellRenderer;\n \t\tthis.cellEditor = cellEditor;\n \t\tthis.headerValue = null;\n \t\tthis.identifier = null;\n-\t} // TableColumn()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n+  }\n \n \t/**\n \t * firePropertyChange\n \t * @param property TODO\n \t * @param oldValue TODO\n \t * @param newValue TODO\n \t */\n-\tprivate void firePropertyChange(String property, Object oldValue, Object newValue) {\n+  private void firePropertyChange(String property, Object oldValue,\n+                                  Object newValue)\n+  {\n \t\tchangeSupport.firePropertyChange(property, oldValue, newValue);\n-\t} // firePropertyChange()\n+  }\n \n \t/**\n \t * firePropertyChange\n \t * @param property TODO\n \t * @param oldValue TODO\n \t * @param newValue TODO\n \t */\n-\tprivate void firePropertyChange(String property, int oldValue, int newValue) {\n+  private void firePropertyChange(String property, int oldValue, int newValue)\n+  {\n \t\tfirePropertyChange(property, new Integer(oldValue), new Integer(newValue));\n-\t} // firePropertyChange()\n+  }\n \n \t/**\n \t * firePropertyChange\n \t * @param property TODO\n \t * @param oldValue TODO\n \t * @param newValue TODO\n \t */\n-\tprivate void firePropertyChange(String property, boolean oldValue, boolean newValue)\n+  private void firePropertyChange(String property, boolean oldValue,\n+                                  boolean newValue)\n \t{\n \t\tfirePropertyChange(property, new Boolean(oldValue), new Boolean(newValue));\n \t}\n@@ -227,43 +223,46 @@ private void firePropertyChange(String property, boolean oldValue, boolean newVa\n \t * setModelIndex\n \t * @param modelIndex TODO\n \t */\n-\tpublic void setModelIndex(int modelIndex) {\n+  public void setModelIndex(int modelIndex)\n+  {\n \t\tthis.modelIndex = modelIndex;\n-\t} // setModelIndex()\n+  }\n \n \t/**\n \t * getModelIndex\n-\t * @returns int\n+   * @return int\n \t */\n-\tpublic int getModelIndex() {\n+  public int getModelIndex()\n+  {\n \t\treturn modelIndex;\n-\t} // getModelIndex()\n+  }\n \n \t/**\n \t * setIdentifier\n \t * @param identifier TODO\n \t */\n-\tpublic void setIdentifier(Object identifier) {\n+  public void setIdentifier(Object identifier)\n+  {\n \t\tthis.identifier = identifier;\n-\t} // setIdentifier()\n+  }\n \n \t/**\n \t * getIdentifier\n-\t * @returns Object\n+   * @return Object\n \t */\n-\tpublic Object getIdentifier() {\n-\t\tif (identifier == null) {\n+  public Object getIdentifier()\n+  {\n+    if (identifier == null)\n \t\t\treturn getHeaderValue();\n-\t\t} // if\n \t\treturn identifier;\n-\t} // getIdentifier()\n+  }\n \n \t/**\n \t * setHeaderValue\n \t * @param headerValue TODO\n \t */\n-\tpublic void setHeaderValue(Object headerValue) {\n-\n+  public void setHeaderValue(Object headerValue)\n+  {\n \t\t// Variables\n \t\tObject\toldValue;\n \n@@ -274,25 +273,24 @@ public void setHeaderValue(Object headerValue) {\n \t\tthis.headerValue = headerValue;\n \n \t\t// Notify Listeners of change\n-\t\tfirePropertyChange(HEADER_VALUE_PROPERTY, \n-\t\t\t\toldValue, headerValue);\n-\n-\t} // setHeaderValue()\n+    firePropertyChange(HEADER_VALUE_PROPERTY, oldValue, headerValue);\n+  }\n \n \t/**\n \t * getHeaderValue\n-\t * @returns Object\n+   * @return Object\n \t */\n-\tpublic Object getHeaderValue() {\n+  public Object getHeaderValue()\n+  {\n \t\treturn headerValue;\n-\t} // getHeaderValue()\n+  }\n \n \t/**\n \t * setHeaderRenderer\n \t * @param headerRenderer TODO\n \t */\n-\tpublic void setHeaderRenderer(TableCellRenderer headerRenderer) {\n-\n+  public void setHeaderRenderer(TableCellRenderer headerRenderer)\n+  {\n \t\t// Variables\n \t\tTableCellRenderer\toldRenderer;\n \n@@ -303,25 +301,24 @@ public void setHeaderRenderer(TableCellRenderer headerRenderer) {\n \t\tthis.headerRenderer = headerRenderer;\n \n \t\t// Notify Listeners of change\n-\t\tfirePropertyChange(HEADER_RENDERER_PROPERTY, \n-\t\t\t\toldRenderer, headerRenderer);\n-\n-\t} // setHeaderRenderer()\n+    firePropertyChange(HEADER_RENDERER_PROPERTY, oldRenderer, headerRenderer);\n+  }\n \n \t/**\n \t * getHeaderRenderer\n-\t * @returns TableCellRenderer\n+   * @return TableCellRenderer\n \t */\n-\tpublic TableCellRenderer getHeaderRenderer() {\n+  public TableCellRenderer getHeaderRenderer()\n+  {\n \t\treturn headerRenderer;\n-\t} // getHeaderRenderer()\n+  }\n \n \t/**\n \t * setCellRenderer\n \t * @param cellRenderer TODO\n \t */\n-\tpublic void setCellRenderer(TableCellRenderer cellRenderer) {\n-\n+  public void setCellRenderer(TableCellRenderer cellRenderer)\n+  {\n \t\t// Variables\n \t\tTableCellRenderer\toldRenderer;\n \n@@ -332,187 +329,197 @@ public void setCellRenderer(TableCellRenderer cellRenderer) {\n \t\tthis.cellRenderer = cellRenderer;\n \n \t\t// Notify Listeners of change\n-\t\tfirePropertyChange(CELL_RENDERER_PROPERTY, \n-\t\t\t\toldRenderer, cellRenderer);\n-\n-\t} // setCellRenderer()\n+    firePropertyChange(CELL_RENDERER_PROPERTY, oldRenderer, cellRenderer);\n+  }\n \n \t/**\n \t * getCellRenderer\n-\t * @returns TableCellRenderer\n+   * @return TableCellRenderer\n \t */\n-\tpublic TableCellRenderer getCellRenderer() {\n+  public TableCellRenderer getCellRenderer()\n+  {\n \t\treturn cellRenderer;\n-\t} // getCellRenderer()\n+  }\n \n \t/**\n \t * setCellEditor\n \t * @param cellEditor TODO\n \t */\n-\tpublic void setCellEditor(TableCellEditor cellEditor) {\n+  public void setCellEditor(TableCellEditor cellEditor)\n+  {\n \t\tthis.cellEditor = cellEditor;\n-\t} // setCellEditor()\n+  }\n \n \t/**\n \t * getCellEditor\n-\t * @returns TableCellEditor\n+   * @return TableCellEditor\n \t */\n-\tpublic TableCellEditor getCellEditor() {\n+  public TableCellEditor getCellEditor()\n+  {\n \t\treturn cellEditor;\n-\t} // getCellEditor()\n+  }\n \n \t/**\n \t * setWidth\n \t * @param width TODO\n \t */\n-\tpublic void setWidth(int width) {\n-\n+  public void setWidth(int width)\n+  {\n \t\t// Variables\n \t\tint\toldWidth;\n \n \t\t// Get Old Width\n \t\toldWidth = this.width;\n \n \t\t// Adjust Width within Limits\n-\t\tif (width < minWidth) {\n+    if (width < minWidth)\n \t\t\tthis.width = minWidth;\n-\t\t} else if (width > maxWidth) {\n+    else if (width > maxWidth)\n \t\t\tthis.width = maxWidth;\n-\t\t} else {\n+    else\n \t\t\tthis.width = width;\n-\t\t} // if\n \n-\t\t// Fire Property Change\n \t\tfirePropertyChange(COLUMN_WIDTH_PROPERTY, oldWidth, this.width);\n-\n-\t} // setWidth()\n+  }\n \n \t/**\n \t * getWidth\n-\t * @returns int\n+   * @return int\n \t */\n-\tpublic int getWidth() {\n+  public int getWidth()\n+  {\n \t\treturn width;\n-\t} // getWidth()\n+  }\n \n \t/**\n \t * setPreferredWidth\n \t * @param preferredWidth TODO\n \t */\n-\tpublic void setPreferredWidth(int preferredWidth) {\n-\t\tif (preferredWidth < minWidth) {\n+  public void setPreferredWidth(int preferredWidth)\n+  {\n+    if (preferredWidth < minWidth)\n \t\t\tthis.preferredWidth = minWidth;\n-\t\t} else if (preferredWidth > maxWidth) {\n+    else if (preferredWidth > maxWidth)\n \t\t\tthis.preferredWidth = maxWidth;\n-\t\t} else {\n+    else\n \t\t\tthis.preferredWidth = preferredWidth;\n-\t\t} // if\n-\t} // setPreferredWidth()\n+  }\n \n \t/**\n \t * getPreferredWidth\n-\t * @returns int\n+   * @return int\n \t */\n-\tpublic int getPreferredWidth() {\n+  public int getPreferredWidth()\n+  {\n \t\treturn preferredWidth;\n-\t} // getPreferredWidth()\n+  }\n \n \t/**\n \t * setMinWidth\n \t * @param minWidth TODO\n \t */\n-\tpublic void setMinWidth(int minWidth) {\n+  public void setMinWidth(int minWidth)\n+  {\n \t\tthis.minWidth = minWidth;\n \t\tsetWidth(getWidth());\n \t\tsetPreferredWidth(getPreferredWidth());\n-\t} // setMinWidth()\n+  }\n \n \t/**\n \t * getMinWidth\n-\t * @returns int\n+   * @return int\n \t */\n-\tpublic int getMinWidth() {\n+  public int getMinWidth()\n+  {\n \t\treturn minWidth;\n-\t} // getMinWidth()\n+  }\n \n \t/**\n \t * setMaxWidth\n \t * @param maxWidth TODO\n \t */\n-\tpublic void setMaxWidth(int maxWidth) {\n+  public void setMaxWidth(int maxWidth)\n+  {\n \t\tthis.maxWidth = maxWidth;\n \t\tsetWidth(getWidth());\n \t\tsetPreferredWidth(getPreferredWidth());\n-\t} // setMaxWidth()\n+  }\n \n \t/**\n \t * getMaxWidth\n-\t * @returns int\n+   * @return int\n \t */\n-\tpublic int getMaxWidth() {\n+  public int getMaxWidth()\n+  {\n \t\treturn maxWidth;\n-\t} // getMaxWidth()\n+  }\n \n \t/**\n \t * setResizable\n \t * @param isResizable TODO\n \t */\n-\tpublic void setResizable(boolean isResizable) {\n+  public void setResizable(boolean isResizable)\n+  {\n \t\tthis.isResizable = isResizable;\n-\t} // setResizable()\n+  }\n \n \t/**\n \t * getResizable\n-\t * @returns boolean\n+   * @return boolean\n \t */\n-\tpublic boolean getResizable() {\n+  public boolean getResizable()\n+  {\n \t\treturn isResizable;\n-\t} // getResizable()\n+  }\n \n \t/**\n \t * sizeWidthToFit\n \t */\n-\tpublic void sizeWidthToFit() {\n+  public void sizeWidthToFit()\n+  {\n \t\t// TODO\n-\t} // sizeWidthToFit()\n+  }\n \n \t/**\n \t * disableResizedPosting\n \t */\n-\tpublic void disableResizedPosting() {\n+  public void disableResizedPosting()\n+  {\n \t\t// Does nothing\n-\t} // disableResizedPosting()\n+  }\n \n \t/**\n \t * enableResizedPosting\n \t */\n-\tpublic void enableResizedPosting() {\n+  public void enableResizedPosting()\n+  {\n \t\t// Does nothing\n-\t} // enableResizedPosting()\n+  }\n \n \t/**\n \t * addPropertyChangeListener\n-\t * @param listener TODO\n+   * @param listener the listener to all\n \t */\n-\tpublic synchronized void addPropertyChangeListener(PropertyChangeListener listener) {\n+  public synchronized void addPropertyChangeListener(PropertyChangeListener listener)\n+  {\n \t\tchangeSupport.addPropertyChangeListener(listener);\n-\t} // addPropertyChangeListener()\n+  }\n \n \t/**\n \t * removePropertyChangeListener\n-\t * @param listener TODO\n+   * @param listener the listener to remove\n \t */\n-\tpublic synchronized void removePropertyChangeListener(PropertyChangeListener listener) {\n+  public synchronized void removePropertyChangeListener(PropertyChangeListener listener)\n+  {\n \t\tchangeSupport.removePropertyChangeListener(listener);\n-\t} // removePropertyChangeListener()\n+  }\n \n \t/**\n \t * createDefaultHeaderRenderer\n-\t * @returns TableCellRenderer\n+   * @return TableCellRenderer\n \t */\n-\tprotected TableCellRenderer createDefaultHeaderRenderer() {\n+  protected TableCellRenderer createDefaultHeaderRenderer()\n+  {\n \t\treturn new DefaultTableCellRenderer();\n-\t} // createDefaultHeaderRenderer()\n-\n-\n-} // TableColumn\n+  }\n+}"}, {"sha": "ef0897d165b5505995a606016e04de298f8b0a9c", "filename": "libjava/javax/swing/table/TableColumnModel.java", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftable%2FTableColumnModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftable%2FTableColumnModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftable%2FTableColumnModel.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -37,17 +37,17 @@\n \n package javax.swing.table;\n \n-// Imports\n import java.util.Enumeration;\n import javax.swing.ListSelectionModel;\n import javax.swing.event.TableColumnModelListener;\n \n+\n /**\n  * TableColumnModel public interface\n  * @author Andrew Selkirk\n  */\n-public interface TableColumnModel {\n-\n+public interface TableColumnModel\n+{\n \t/**\n \t * addColumn\n \t * @param column TableColumn\n@@ -75,13 +75,13 @@ public interface TableColumnModel {\n \n \t/**\n \t * getColumnCount\n-\t * @returns Column count\n+   * @return Column count\n \t */\n \tint getColumnCount();\n \n \t/**\n \t * getColumns\n-\t * @returns Enumeration of columns\n+   * @return Enumeration of columns\n \t */\n \tEnumeration getColumns();\n \n@@ -99,19 +99,19 @@ public interface TableColumnModel {\n \n \t/**\n \t * getColumnMargin\n-\t * @returns Column margin\n+   * @return Column margin\n \t */\n \tint getColumnMargin();\n \n \t/**\n \t * getColumnIndexAtX\n-\t * @returns Column index as position x\n+   * @return Column index as position x\n \t */\n \tint getColumnIndexAtX(int xPosition);\n \n \t/**\n \t * getTotalColumnWidth\n-\t * @returns Total column width\n+   * @return Total column width\n \t */\n \tint getTotalColumnWidth();\n \n@@ -123,19 +123,19 @@ public interface TableColumnModel {\n \n \t/**\n \t * getColumnSelectionAllowed\n-\t * @returns true if column selection allowed, false otherwise\n+   * @return true if column selection allowed, false otherwise\n \t */\n \tboolean getColumnSelectionAllowed();\n \n \t/**\n \t * getSelectedColumns\n-\t * @returns Selected columns\n+   * @return Selected columns\n \t */\n \tint[] getSelectedColumns();\n \n \t/**\n \t * getSelectedColumnCount\n-\t * @returns Count of selected columns\n+   * @return Count of selected columns\n \t */\n \tint getSelectedColumnCount();\n \n@@ -162,6 +162,4 @@ public interface TableColumnModel {\n \t * @param listener TableColumnModelListener\n \t */\n \tvoid removeColumnModelListener(TableColumnModelListener listener);\n-\n-\n-} // TableColumnModel\n+}"}, {"sha": "a4732d061b9d60de0f75aeee10f885a4d7ff5c6d", "filename": "libjava/javax/swing/table/TableModel.java", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftable%2FTableModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftable%2FTableModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftable%2FTableModel.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -37,54 +37,54 @@\n \n package javax.swing.table;\n \n-// Imports\n import javax.swing.event.TableModelListener;\n \n+\n /**\n  * TableModel public interface\n  * @author Andrew Selkirk\n  */\n-public interface TableModel {\n-\n+public interface TableModel\n+{\n \t/**\n \t * getRowCount\n-\t * @returns row count\n+   * @return row count\n \t */\n \tint getRowCount();\n \n \t/**\n \t * getColumnCount\n-\t * @returns column count\n+   * @return column count\n \t */\n \tint getColumnCount();\n \n \t/**\n \t * getColumnName\n \t * @param columnIndex Column index\n-\t * @returns Column name\n+   * @return Column name\n \t */\n \tString getColumnName(int columnIndex);\n \n \t/**\n \t * getColumnClass\n \t * @param columnIndex Column index\n-\t * @returns Column class\n+   * @return Column class\n \t */\n \tClass getColumnClass(int columnIndex);\n \n \t/**\n \t * isCellEditable\n \t * @param rowIndex Row index\n \t * @param columnIndex Column index\n-\t * @returns true if editable, false otherwise\n+   * @return true if editable, false otherwise\n \t */\n \tboolean isCellEditable(int rowIndex, int columnIndex);\n \n \t/**\n \t * getValueAt\n \t * @param rowIndex Row index\n \t * @param columnIndex Column index\n-\t * @returns Value at specified indices\n+   * @return Value at specified indices\n \t */\n \tObject getValueAt(int rowIndex, int columnIndex);\n \n@@ -107,6 +107,4 @@ public interface TableModel {\n \t * @param listener TableModelListener\n \t */\n \tvoid removeTableModelListener(TableModelListener listener);\n-\n-\n-} // TableModel\n+}"}, {"sha": "c1ea098c0a9d54c3807b8e2e04e878f0c71f24e2", "filename": "libjava/javax/swing/text/AbstractDocument.java", "status": "modified", "additions": 322, "deletions": 235, "changes": 557, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FAbstractDocument.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FAbstractDocument.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FAbstractDocument.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -42,7 +42,6 @@\n import java.util.Enumeration;\n import java.util.EventListener;\n import java.util.Vector;\n-\n import javax.swing.event.DocumentEvent;\n import javax.swing.event.DocumentListener;\n import javax.swing.event.EventListenerList;\n@@ -57,232 +56,15 @@\n public abstract class AbstractDocument\n   implements Document, Serializable\n {\n-  public abstract class AbstractElement\n-    implements Element, TreeNode, Serializable\n-  {\n-    private static final long serialVersionUID = 1265312733007397733L;\n-    \n-    int count;\n-    int offset;\n-    AttributeSet attr;\n-    Vector elts = new Vector();\n-    String name;\n-    Element parent;\n-    Vector kids = new Vector();\n-    TreeNode tree_parent;\n-\n-    public AbstractElement(Element p, AttributeSet s)\n-    {\n-      parent = p;\n-      attr = s;\n-    }\n-\n-    public Enumeration children()\n-    {\n-      return kids.elements();\n-    }\n-\n-    public boolean getAllowsChildren()\n-    {\n-      return true;\n-    }\n-\n-    public TreeNode getChildAt(int index)\n-    {\n-      return (TreeNode) kids.elementAt(index);\n-    }\n-\n-    public int getChildCount()\n-    {\n-      return kids.size();\n-    }\n-\n-    public int getIndex(TreeNode node)\n-    {\n-      return kids.indexOf(node);\n-    }\n-\n-    public TreeNode getParent()\n-    {\n-      return tree_parent;\n-    }\n-\n-    public AttributeSet getAttributes()\n-    {\n-      return attr;\n-    }\n-\n-    public Document getDocument()\n-    {\n-      return AbstractDocument.this;\n-    }\n-\n-    public Element getElement(int index)\n-    {\n-      return (Element) elts.elementAt(index);\n-    }\n-\n-    public String getName()\n-    {\n-      return name;\n-    }\n-\n-    public Element getParentElement()\n-    {\n-      return parent;\n-    }\n-\n-    public abstract boolean isLeaf();\n-\n-    public abstract int getEndOffset();\n-\n-    public abstract int getElementCount();\n-\n-    public abstract int getElementIndex(int offset);\n-\n-    public abstract int getStartOffset();\n-  }\n-\n-  public interface AttributeContext\n-  {\n-  }\n-\n-  public class BranchElement extends AbstractElement\n-  {\n-    private static final long serialVersionUID = -8595176318868717313L;\n-    \n-    public BranchElement(Element e, AttributeSet a, int s, int end)\n-    {\n-      super(e, a);\n-    }\n-\n-    public boolean isLeaf()\n-    {\n-      return false;\n-    }\n-\n-    public int getEndOffset()\n-    {\n-      return 0;\n-    }\n-\n-    public int getElementCount()\n-    {\n-      return 0;\n-    }\n-\n-    public int getElementIndex(int offset)\n-    {\n-      return 0;\n-    }\n-\n-    public int getStartOffset()\n-    {\n-      return 0;\n-    }\n-  }\n-\n-  public interface Content\n-  {\n-    Position createPosition(int offset) throws BadLocationException;\n-\n-    int length();\n-\n-    UndoableEdit insertString(int where, String str)\n-      throws BadLocationException;\n-\n-    UndoableEdit remove(int where, int nitems) throws BadLocationException;\n-\n-    String getString(int where, int len) throws BadLocationException;\n-\n-    void getChars(int where, int len, Segment txt) throws BadLocationException;\n-  }\n-\n-  public class DefaultDocumentEvent extends CompoundEdit\n-    implements DocumentEvent\n-  {\n-    private static final long serialVersionUID = -7406103236022413522L;\n-    \n-    public int len;\n-    public int off;\n-\n-    public Document getDocument()\n-    {\n-      return AbstractDocument.this;\n-    }\n-\n-    public int getLength()\n-    {\n-      return len;\n-    }\n-\n-    public int getOffset()\n-    {\n-      return off;\n-    }\n-\n-    public DocumentEvent.EventType getType()\n-    {\n-      return null;\n-    }\n-\n-    public DocumentEvent.ElementChange getChange(Element elem)\n-    {\n-      return null;\n-    }\n-  }\n-\n-  public static class ElementEdit extends AbstractUndoableEdit\n-  {\n-    private static final long serialVersionUID = -1216620962142928304L;\n-  }\n-\n-  public class LeafElement extends AbstractElement\n-  {\n-    private static final long serialVersionUID = 5115368706941283802L;\n-    \n-    public LeafElement(Element e, AttributeSet a, int s, int end)\n-    {\n-      super(e, a);\n-    }\n-\n-    public boolean isLeaf()\n-    {\n-      return true;\n-    }\n-\n-    public int getEndOffset()\n-    {\n-      return 0;\n-    }\n-\n-    public int getElementCount()\n-    {\n-      return 0;\n-    }\n-\n-    public int getElementIndex(int offset)\n-    {\n-      return 0;\n-    }\n-\n-    public int getStartOffset()\n-    {\n-      return 0;\n-    }\n-  }\n-\n   private static final long serialVersionUID = -116069779446114664L;\n-\n   protected static final String BAD_LOCATION = \"document location failure\";\n-\n   public static final String BidiElementName = \"bidi level\";\n   public static final String ContentElementName = \"content\";\n   public static final String ParagraphElementName = \"paragraph\";\n   public static final String SectionElementName = \"section\";\n   public static final String ElementNameAttribute = \"$ename\";\n-  \n   Content content;\n+  protected EventListenerList listenerList = new EventListenerList();\n \n   protected AbstractDocument(Content doc)\n   {\n@@ -294,8 +76,6 @@ protected AbstractDocument(Content doc, AttributeContext context)\n     content = doc;\n   }\n \n-  protected EventListenerList listenerList = new EventListenerList();\n-\n   // these still need to be implemented by a derived class:\n   public abstract Element getParagraphElement(int pos);\n \n@@ -312,14 +92,16 @@ protected Element createLeafElement(Element parent, AttributeSet a, int p0,\n     return new LeafElement(parent, a, p0, p1 - p0);\n   }\n \n-  public Position createPosition(int offs)\n+  public Position createPosition(final int offset) throws BadLocationException\n   {\n-    final int a = offs;\n+    if (offset < 0 || offset > getLength())\n+      throw new BadLocationException(getText(0, getLength()), offset);\n+\n     return new Position()\n       {\n \tpublic int getOffset()\n \t{\n-\t  return a;\n+\t  return offset;\n \t}\n       };\n   }\n@@ -416,21 +198,13 @@ public Position getStartPosition()\n     return null;\n   }\n \n-  public String getText(int offset, int length)\n-  {\n-    try\n+  public String getText(int offset, int length) throws BadLocationException\n       {\n \treturn content.getString(offset, length);\n       }\n-    catch (Exception e)\n-      {\n-\tSystem.out.println(\"Hmmm, fail to getText: \" + offset + \" -> \"\n-\t                   + length);\n-\treturn null;\n-      }\n-  }\n \n   public void getText(int offset, int length, Segment txt)\n+    throws BadLocationException\n   {\n     String a = getText(offset, length);\n \n@@ -439,6 +213,7 @@ public void getText(int offset, int length, Segment txt)\n \ttxt.offset = 0;\n \ttxt.count = 0;\n \ttxt.array = new char[0];\n+\n \treturn;\n       }\n \n@@ -478,7 +253,7 @@ public void readUnlock()\n   {\n   }\n \n-  public void remove(int offs, int len)\n+  public void remove(int offset, int length) throws BadLocationException\n   {\n   }\n \n@@ -565,4 +340,316 @@ protected void writeLock()\n   protected void writeUnlock()\n   {\n   }\n+\n+  public interface AttributeContext\n+  {\n+    AttributeSet addAttribute(AttributeSet old, Object name, Object value);\n+\n+    AttributeSet addAttributes(AttributeSet old, AttributeSet attributes);\n+\n+    AttributeSet getEmptySet();\n+\n+    void reclaim(AttributeSet attributes);\n+\n+    AttributeSet removeAttribute(AttributeSet old, Object name);\n+\n+    AttributeSet removeAttributes(AttributeSet old, AttributeSet attributes);\n+\n+    AttributeSet removeAttributes(AttributeSet old, Enumeration names);\n+  }\n+\n+  public interface Content\n+  {\n+    Position createPosition(int offset) throws BadLocationException;\n+\n+    int length();\n+\n+    UndoableEdit insertString(int where, String str)\n+      throws BadLocationException;\n+\n+    UndoableEdit remove(int where, int nitems) throws BadLocationException;\n+\n+    String getString(int where, int len) throws BadLocationException;\n+\n+    void getChars(int where, int len, Segment txt) throws BadLocationException;\n+  }\n+\n+  public abstract class AbstractElement\n+    implements Element, TreeNode, Serializable\n+  {\n+    private static final long serialVersionUID = 1265312733007397733L;\n+    int count;\n+    int offset;\n+    AttributeSet attr;\n+    Vector elts = new Vector();\n+    String name;\n+    Element parent;\n+    Vector kids = new Vector();\n+    TreeNode tree_parent;\n+\n+    public AbstractElement(Element p, AttributeSet s)\n+    {\n+      parent = p;\n+      attr = s;\n+    }\n+\n+    public Enumeration children()\n+    {\n+      return kids.elements();\n+    }\n+\n+    public boolean getAllowsChildren()\n+    {\n+      return true;\n+    }\n+\n+    public TreeNode getChildAt(int index)\n+    {\n+      return (TreeNode) kids.elementAt(index);\n+    }\n+\n+    public int getChildCount()\n+    {\n+      return kids.size();\n+    }\n+\n+    public int getIndex(TreeNode node)\n+    {\n+      return kids.indexOf(node);\n+    }\n+\n+    public TreeNode getParent()\n+    {\n+      return tree_parent;\n+    }\n+\n+    public AttributeSet getAttributes()\n+    {\n+      return attr;\n+    }\n+\n+    public Document getDocument()\n+    {\n+      return AbstractDocument.this;\n+    }\n+\n+    public Element getElement(int index)\n+    {\n+      return (Element) elts.elementAt(index);\n+    }\n+\n+    public String getName()\n+    {\n+      return name;\n+    }\n+\n+    public Element getParentElement()\n+    {\n+      return parent;\n+    }\n+\n+    public abstract boolean isLeaf();\n+\n+    public abstract int getEndOffset();\n+\n+    public abstract int getElementCount();\n+\n+    public abstract int getElementIndex(int offset);\n+\n+    public abstract int getStartOffset();\n+  }\n+\n+  public class BranchElement extends AbstractElement\n+  {\n+    private static final long serialVersionUID = -8595176318868717313L;\n+    private int start;\n+    private int end;\n+    private Vector children = new Vector();\n+\n+    public BranchElement(Element parent, AttributeSet attributes, int start,\n+                         int end)\n+    {\n+      super(parent, attributes);\n+      this.start = start;\n+      this.end = end;\n+    }\n+\n+    public Enumeration children()\n+    {\n+      return children.elements();\n+    }\n+\n+    public boolean getAllowsChildren()\n+    {\n+      return true;\n+    }\n+\n+    public Element getElement(int index)\n+    {\n+      return (Element) children.get(index);\n+    }\n+\n+    public int getElementCount()\n+    {\n+      return children.size();\n+    }\n+\n+    public int getElementIndex(int offset)\n+    {\n+      return children.indexOf(positionToElement(offset));\n+    }\n+\n+    public int getEndOffset()\n+    {\n+      return end;\n+    }\n+\n+    public String getName()\n+    {\n+      return \"AbstractDocument.BranchElement\";\n+    }\n+\n+    public int getStartOffset()\n+    {\n+      return start;\n+    }\n+\n+    public boolean isLeaf()\n+    {\n+      return false;\n+    }\n+\n+    public Element positionToElement(int position)\n+    {\n+      // XXX: There is surely a better algorithm\n+      // as beginning from first element each time.\n+      for (int index = 0; index < children.size(); ++index)\n+        {\n+\t  Element elem = (Element) children.get(index);\n+\n+\t  if ((elem.getStartOffset() <= position)\n+\t      && (position < elem.getEndOffset()))\n+\t    return elem;\n+        }\n+\n+      return null;\n+    }\n+\n+    public void replace(int offset, int length, Element[] elems)\n+    {\n+      for (int index = 0; index < length; ++index)\n+\tchildren.removeElementAt(offset);\n+\n+      for (int index = 0; index < elems.length; ++index)\n+\tchildren.add(offset + index, elems[index]);\n+    }\n+\n+    public String toString()\n+    {\n+      return getName() + \": \" + \"content\";\n+    }\n+  }\n+\n+  public class DefaultDocumentEvent extends CompoundEdit\n+    implements DocumentEvent\n+  {\n+    private static final long serialVersionUID = -7406103236022413522L;\n+    public int len;\n+    public int off;\n+\n+    public Document getDocument()\n+    {\n+      return AbstractDocument.this;\n+    }\n+\n+    public int getLength()\n+    {\n+      return len;\n+    }\n+\n+    public int getOffset()\n+    {\n+      return off;\n+    }\n+\n+    public DocumentEvent.EventType getType()\n+    {\n+      return null;\n+    }\n+\n+    public DocumentEvent.ElementChange getChange(Element elem)\n+    {\n+      return null;\n+    }\n+  }\n+\n+  public static class ElementEdit extends AbstractUndoableEdit\n+  {\n+    private static final long serialVersionUID = -1216620962142928304L;\n+  }\n+\n+  public class LeafElement extends AbstractElement\n+  {\n+    private static final long serialVersionUID = 5115368706941283802L;\n+    private int start;\n+    private int end;\n+\n+    public LeafElement(Element parent, AttributeSet attributes, int start,\n+                       int end)\n+    {\n+      super(parent, attributes);\n+      this.start = start;\n+      this.end = end;\n+    }\n+\n+    public Enumeration children()\n+    {\n+      return null;\n+    }\n+\n+    public boolean getAllowsChildren()\n+    {\n+      return false;\n+    }\n+\n+    public Element getElement()\n+    {\n+      return null;\n+    }\n+\n+    public int getElementCount()\n+    {\n+      return 0;\n+    }\n+\n+    public int getElementIndex(int offset)\n+    {\n+      return -1;\n+    }\n+\n+    public int getEndOffset()\n+    {\n+      return end;\n+    }\n+\n+    public String getName()\n+    {\n+      return \"AbstractDocument.LeafElement\";\n+    }\n+\n+    public int getStartOffset()\n+    {\n+      return start;\n+    }\n+\n+    public boolean isLeaf()\n+    {\n+      return true;\n+    }\n+\n+    public String toString()\n+    {\n+      return getName() + \": \" + \"content\";\n+    }\n+  }\n }"}, {"sha": "3c31767cf3a3f40edebe880682dd2ee8a16117ad", "filename": "libjava/javax/swing/text/AttributeSet.java", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FAttributeSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FAttributeSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FAttributeSet.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -41,6 +41,22 @@\n \n public interface AttributeSet\n { \n+  static interface CharacterAttribute\n+  {\n+  }\n+\n+  static interface ColorAttribute\n+  {\n+  }\n+\n+  static interface FontAttribute\n+  {\n+  }\n+\n+  static interface ParagraphAttribute\n+  {\n+  }\n+  \n     boolean containsAttribute(Object name, Object value);\n     boolean containsAttributes(AttributeSet attributes);\n     AttributeSet copyAttributes();"}, {"sha": "0305a717462a2fdd630a2082319629f84f9da31a", "filename": "libjava/javax/swing/text/ComponentView.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FComponentView.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FComponentView.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FComponentView.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -79,6 +79,7 @@ public float getPreferredSpan(int axis)\n     }\n \n     public Shape modelToView(int pos, Shape a, Position.Bias b)\n+      throws BadLocationException\n     {\n \treturn null;\n     }"}, {"sha": "968bf1ffdf60925da0325581adb28a8519eebd09", "filename": "libjava/javax/swing/text/DefaultCaret.java", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FDefaultCaret.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FDefaultCaret.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FDefaultCaret.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -41,7 +41,9 @@\n import java.awt.Graphics;\n import java.awt.Point;\n import java.awt.Rectangle;\n+import java.awt.event.FocusEvent;\n import java.awt.event.FocusListener;\n+import java.awt.event.MouseEvent;\n import java.awt.event.MouseListener;\n import java.awt.event.MouseMotionListener;\n import java.util.EventListener;\n@@ -54,6 +56,8 @@\n public class DefaultCaret extends Rectangle\n   implements Caret, FocusListener, MouseListener, MouseMotionListener\n {\n+  private static final long serialVersionUID = 228155774675466193L;\n+  \n   protected ChangeEvent changeEvent = new ChangeEvent(this);\n   protected EventListenerList listenerList = new EventListenerList();\n   \n@@ -67,39 +71,47 @@ public class DefaultCaret extends Rectangle\n   boolean vis = true;\n \n \n-  public void mouseDragged(java.awt.event.MouseEvent evt)\n+  public void mouseDragged(MouseEvent event)\n+  {\n+  }\n+\n+  public void mouseMoved(MouseEvent event)\n+  {\n+  }\n+\n+  public void mouseClicked(MouseEvent event)\n   {\n   }\n \n-  public void mouseMoved(java.awt.event.MouseEvent evt)\n+  public void mouseEntered(MouseEvent event)\n   {\n   }\n \n-  public void mouseClicked(java.awt.event.MouseEvent evt)\n+  public void mouseExited(MouseEvent event)\n   {\n   }\n \n-  public void mouseEntered(java.awt.event.MouseEvent evt)\n+  public void mousePressed(MouseEvent event)\n   {\n   }\n \n-  public void mouseExited(java.awt.event.MouseEvent evt)\n+  public void mouseReleased(MouseEvent event)\n   {\n   }\n \n-  public void mousePressed(java.awt.event.MouseEvent evt)\n+  public void focusGained(FocusEvent event)\n   {\n   }\n \n-  public void mouseReleased(java.awt.event.MouseEvent evt)\n+  public void focusLost(FocusEvent event)\n   {\n   }\n \n-  public void focusGained(java.awt.event.FocusEvent evt)\n+  protected void moveCaret(MouseEvent event)\n   {\n   }\n \n-  public void focusLost(java.awt.event.FocusEvent evt)\n+  protected void positionCaret(MouseEvent event)\n   {\n   }\n \n@@ -144,7 +156,7 @@ public boolean isSelectionVisible()\n     return vis_sel;\n   }\n \n-  private void repaint()\n+  protected final void repaint()\n   {\n     if (parent != null)\n       parent.repaint();"}, {"sha": "8611de5a0eb914813e8de9392c69a43e681c609a", "filename": "libjava/javax/swing/text/DefaultEditorKit.java", "status": "modified", "additions": 38, "deletions": 17, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FDefaultEditorKit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FDefaultEditorKit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FDefaultEditorKit.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -38,14 +38,17 @@\n package javax.swing.text;\n \n import java.io.InputStream;\n+import java.io.IOException;\n import java.io.OutputStream;\n import java.io.Reader;\n import java.io.Writer;\n import javax.swing.Action;\n import javax.swing.JEditorPane;\n \n+\n public class DefaultEditorKit extends EditorKit\n {\n+  private static final long serialVersionUID = 9017245433028523428L;\n   public static final String backwardAction = \"caret-backward\";\n   public static final String beepAction = \"beep\";\n   public static final String beginAction = \"caret-begin\";\n@@ -60,7 +63,7 @@ public class DefaultEditorKit extends EditorKit\n   public static final String downAction = \"caret-down\";\n   public static final String endAction = \"caret-end\";\n   public static final String endLineAction = \"caret-end-line\";\n-  public static final String endOfLineStringProperty = \"__EndOfLine__\";\n+  public static final String EndOfLineStringProperty = \"__EndOfLine__\";\n   public static final String endParagraphAction = \"caret-end-paragraph\";\n   public static final String endWordAction = \"caret-end-word\";\n   public static final String forwardAction = \"caret-forward\";\n@@ -77,65 +80,83 @@ public class DefaultEditorKit extends EditorKit\n   public static final String selectionBackwardAction = \"selection-backward\";\n   public static final String selectionBeginAction = \"selection-begin\";\n   public static final String selectionBeginLineAction = \"selection-begin-line\";\n-  public static final String selectionBeginParagraphAction = \"selection-begin-paragraph\";\n+  public static final String selectionBeginParagraphAction =\n+    \"selection-begin-paragraph\";\n   public static final String selectionBeginWordAction = \"selection-begin-word\";\n   public static final String selectionDownAction = \"selection-down\";\n   public static final String selectionEndAction = \"selection-end\";\n   public static final String selectionEndLineAction = \"selection-end-line\";\n-  public static final String selectionEndParagraphAction = \"selection-end-paragraph\";\n+  public static final String selectionEndParagraphAction =\n+    \"selection-end-paragraph\";\n   public static final String selectionEndWordAction = \"selection-end-word\";\n   public static final String selectionForwardAction = \"selection-forward\";\n   public static final String selectionNextWordAction = \"selection-next-word\";\n-  public static final String selectionPreviousWordAction = \"selection-previous-word\";\n+  public static final String selectionPreviousWordAction =\n+    \"selection-previous-word\";\n   public static final String selectionUpAction = \"selection-up\";\n   public static final String selectLineAction = \"select-line\";\n   public static final String selectParagraphAction = \"select-paragraph\";\n   public static final String selectWordAction = \"select-word\";\n   public static final String upAction = \"caret-up\";\n   public static final String writableAction = \"set-writable\";\n \n-    void deinstall(JEditorPane c)\n+  public DefaultEditorKit()\n+  {\n+  }\n+\n+  /**\n+   * Called when the kit is being removed from the JEditorPane.\n+   */\n+  public void deinstall(JEditorPane c)\n     {\n-\t//      Called when the kit is being removed from the JEditorPane. \n     }\n-    void install(JEditorPane c)\n+\n+  public void install(JEditorPane c)\n     {\n     }\n \n-    Caret createCaret()\n+  public Caret createCaret()\n     {\n \treturn null;\n     }\n-    Document createDefaultDocument()\n+\n+  public Document createDefaultDocument()\n     {\n         return new PlainDocument();\n     }\n \n-    Action[] getActions()\n+  public Action[] getActions()\n     {\n \treturn null;\n     }\n \n-    String getContentType()\n+  public String getContentType()\n     {\n \treturn \"text/plain\";\n     }\n     \n-    ViewFactory getViewFactory()\n+  public ViewFactory getViewFactory()\n     {\n \treturn null;\n     }\n-    void read(InputStream in, Document doc, int pos)\n+\n+  public void read(InputStream in, Document doc, int pos)\n+    throws BadLocationException, IOException\n     {\n     }\n-    void read(Reader in, Document doc, int pos)\n+\n+  public void read(Reader in, Document doc, int pos)\n+    throws BadLocationException, IOException\n     {\n     }\n-    void write(OutputStream out, Document doc, int pos, int len)\n+\n+  public void write(OutputStream out, Document doc, int pos, int len)\n+    throws BadLocationException, IOException\n     {\n     }\n-    void write(Writer out, Document doc, int pos, int len)\n+\n+  public void write(Writer out, Document doc, int pos, int len)\n+    throws BadLocationException, IOException\n     {\n     }\n }\n-"}, {"sha": "003d17d1a8e5cf9394af22b441be29ac64f3250b", "filename": "libjava/javax/swing/text/DefaultHighlighter.java", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FDefaultHighlighter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FDefaultHighlighter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FDefaultHighlighter.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -0,0 +1,150 @@\n+/* DefaultHighlighter.java --\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.swing.text;\n+\n+import java.awt.Graphics;\n+import java.awt.Shape;\n+import java.util.Vector;\n+\n+import javax.swing.text.JTextComponent;\n+import javax.swing.text.View;\n+\n+\n+public class DefaultHighlighter extends LayeredHighlighter\n+{\n+  private class HighlightEntry\n+  {\n+    int p0;\n+    int p1;\n+    Highlighter.HighlightPainter painter;\n+\n+    public HighlightEntry(int p0, int p1, Highlighter.HighlightPainter painter)\n+    {\n+      this.p0 = p0;\n+      this.p1 = p1;\n+      this.painter = painter;\n+    }\n+\n+    public int getStartPosition()\n+    {\n+      return p0;\n+    }\n+\n+    public int getEndPosition()\n+    {\n+      return p1;\n+    }\n+\n+    public Highlighter.HighlightPainter getPainter()\n+    {\n+      return painter;\n+    }\n+  }\n+\n+  private JTextComponent textComponent;\n+  private Vector highlights = new Vector();\n+  \n+  public DefaultHighlighter()\n+  {\n+  }\n+\n+  private void checkPositions(int p0, int p1)\n+    throws BadLocationException\n+  {\n+    if (p0 < 0)\n+      throw new BadLocationException(\"DefaultHighlighter\", p0);\n+    \n+    if (p1 < p0)\n+      throw new BadLocationException(\"DefaultHighlighter\", p1);\n+  }\n+\n+  public void install(JTextComponent c)\n+  {\n+    textComponent = c;\n+    removeAllHighlights();\n+  }\n+\n+  public void deinstall(JTextComponent c)\n+  {\n+    textComponent = null;\n+  }\n+\n+  public Object addHighlight(int p0, int p1, Highlighter.HighlightPainter painter)\n+    throws BadLocationException\n+  {\n+    checkPositions(p0, p1);\n+    HighlightEntry entry = new HighlightEntry(p0, p1, painter);\n+    highlights.add(entry);\n+    return entry;\n+  }\n+\n+  public void removeHighlight(Object tag)\n+  {\n+    highlights.remove(tag);\n+  }\n+\n+  public void removeAllHighlights()\n+  {\n+    highlights.clear();\n+  }\n+\n+  public Highlighter.Highlight[] getHighlights()\n+  {\n+    return null;\n+  }\n+\n+  public void changeHighlight(Object tag, int p0, int p1)\n+    throws BadLocationException\n+  {\n+    checkPositions(p0, p1);\n+    HighlightEntry entry = (HighlightEntry) tag;\n+    entry.p0 = p0;\n+    entry.p1 = p1;\n+  }\n+\n+  public void paintLayeredHighlights(Graphics g, int p0, int p1,\n+                                     Shape viewBounds, JTextComponent editor,\n+                                     View view)\n+  {\n+  }\n+\n+  public void paint(Graphics g)\n+  {\n+  }\n+}"}, {"sha": "d197924bdf9c1f0e2e8a08de378b288d380a3e9e", "filename": "libjava/javax/swing/text/Document.java", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FDocument.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FDocument.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FDocument.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -50,7 +50,8 @@\n \n   void addUndoableEditListener(UndoableEditListener listener);\n \n-  Position createPosition(int offs);\n+  Position createPosition(int offs)\n+    throws BadLocationException;\n \n   Element getDefaultRootElement();\n \n@@ -64,16 +65,19 @@\n \n   Position getStartPosition();\n \n-  String getText(int offset, int length);\n+  String getText(int offset, int length)\n+    throws BadLocationException;\n \n-  void getText(int offset, int length, Segment txt);\n+  void getText(int offset, int length, Segment txt)\n+    throws BadLocationException;\n \n   void insertString(int offset, String str, AttributeSet a)\n     throws BadLocationException;\n \n   void putProperty(Object key, Object value);\n \n-  void remove(int offs, int len);\n+  void remove(int offs, int len)\n+    throws BadLocationException;\n \n   void removeDocumentListener(DocumentListener listener);\n "}, {"sha": "0609332f0b85c24b80d16941078fac481d05ba3b", "filename": "libjava/javax/swing/text/EditorKit.java", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FEditorKit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FEditorKit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FEditorKit.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -38,38 +38,58 @@\n package javax.swing.text;\n \n import java.io.InputStream;\n+import java.io.IOException;\n import java.io.OutputStream;\n import java.io.Reader;\n+import java.io.Serializable;\n import java.io.Writer;\n import javax.swing.Action;\n import javax.swing.JEditorPane;\n \n-public abstract class EditorKit implements Cloneable\n+\n+public abstract class EditorKit\n+  implements Cloneable, Serializable\n {\n-    EditorKit()\n+  private static final long serialVersionUID = -5044124649345887822L;\n+  \n+  public EditorKit()\n     {\n     }\n \n-    EditorKit(EditorKit kit)\n+  public Object clone()\n     {\n+    try\n+      {\n+\treturn super.clone();\n     }\n-\n-    void deinstall(JEditorPane c)\n+    catch (CloneNotSupportedException e)\n     {\n-\t//      Called when the kit is being removed from the JEditorPane. \n+\treturn null;\n     }\n-    void install(JEditorPane c)\n+  }\n+\n+  /**\n+   * Called when the kit is being removed from the JEditorPane.\n+   */\n+  public void deinstall(JEditorPane c)\n     {\n     }\n \n-    abstract  Caret createCaret();\n-    abstract  Document createDefaultDocument();\n-    abstract  Action[] getActions();\n-    abstract  String getContentType();\n-    abstract  ViewFactory getViewFactory();\n-    abstract  void read(InputStream in, Document doc, int pos);\n-    abstract  void read(Reader in, Document doc, int pos);\n-    abstract  void write(OutputStream out, Document doc, int pos, int len);\n-    abstract  void write(Writer out, Document doc, int pos, int len);    \n+  public void install(JEditorPane c)\n+  {\n }\n \n+  public abstract Caret createCaret();\n+  public abstract Document createDefaultDocument();\n+  public abstract Action[] getActions();\n+  public abstract String getContentType();\n+  public abstract ViewFactory getViewFactory();\n+  public abstract void read(InputStream in, Document doc, int pos)\n+    throws BadLocationException, IOException;\n+  public abstract void read(Reader in, Document doc, int pos)\n+    throws BadLocationException, IOException;\n+  public abstract void write(OutputStream out, Document doc, int pos, int len)\n+    throws BadLocationException, IOException;\n+  public abstract void write(Writer out, Document doc, int pos, int len)\n+    throws BadLocationException, IOException;\n+}"}, {"sha": "29a00acfa3c9b4516a594315cbb821c883a7bc52", "filename": "libjava/javax/swing/text/FieldView.java", "status": "renamed", "additions": 57, "deletions": 63, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FFieldView.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FFieldView.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FFieldView.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -1,5 +1,5 @@\n-/* PlainEditorKit.java -- \n-   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n+/* FieldView.java -- \n+   Copyright (C) 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,69 +35,63 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package javax.swing.text;\n \n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.io.Reader;\n-import java.io.Writer;\n-import javax.swing.Action;\n-import javax.swing.JEditorPane;\n+import java.awt.Component;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Shape;\n+\n \n-public class PlainEditorKit extends EditorKit\n+public class FieldView extends PlainView\n {\n-    public PlainEditorKit()\n-    {\n-    }\n-\n-    public PlainEditorKit(PlainEditorKit kit)\n-    {\n-\tsuper(kit);\n-    }\n-\n-    protected Object clone()  \n-    {\n-\treturn new PlainEditorKit(this);\n-    }\n-    void deinstall(JEditorPane c)\n-    {\n-\t//      Called when the kit is being removed from the JEditorPane. \n-    }\n-    void install(JEditorPane c)\n-    {\n-    }\n-\n-    Caret createCaret()\n-    {\n-\treturn null;\n-    }\n-    Document createDefaultDocument()\n-    {\n-\treturn null;\n-    }\n-    Action[] getActions()\n-    {\n-\treturn null;\n-    }\n-    String getContentType()\n-    {\n-\treturn null;\n-    }\n-    ViewFactory getViewFactory()\n-    {\n-\treturn null;\n-    }\n-    void read(InputStream in, Document doc, int pos)\n-    {\t\n-    }\n-    void read(Reader in, Document doc, int pos)\n-    {\n-    }\n-    void write(OutputStream out, Document doc, int pos, int len)\n-    {\n-    }\n-    void write(Writer out, Document doc, int pos, int len)\n-    {\n-    }\n-}\n+  public FieldView(Element elem)\n+  {\n+    super(elem);\n+  }\n+\n+  protected FontMetrics getFontMetrics()\n+  {\n+    Component container = getContainer();\n+    return container.getFontMetrics(container.getFont());\n+  }\n+\n+  public float getPreferredSpan(int axis)\n+  {\n+    if (axis != X_AXIS && axis != Y_AXIS)\n+      throw new IllegalArgumentException();\n \n+    FontMetrics fm = getFontMetrics();\n+\n+    if (axis == Y_AXIS)\n+      return fm.getHeight();\n+\n+    String text;\n+    Element elem = getElement();\n+\n+    try\n+      {\n+\ttext = elem.getDocument().getText(elem.getStartOffset(),\n+\t\t\t\t\t  elem.getEndOffset());\n+      }\n+    catch (BadLocationException e)\n+      {\n+\t// This should never happen.\n+\ttext = \"\";\n+\tSystem.out.println(\"Michael: FieldView.getPreferredSpan: Error\");\n+      }\n+    \n+    return fm.stringWidth(text);\n+  }\n+\n+  public int getResizeWeight(int axis)\n+  {\n+    return axis = axis == X_AXIS ? 1 : 0;\n+  }\n+  \n+  public void paint(Graphics g, Shape s)\n+  {\n+    drawLine(0, g, 0, 0);\n+  }\n+}", "previous_filename": "libjava/javax/swing/text/PlainEditorKit.java"}, {"sha": "77471d177687798aba5dd749170e2808ba51845a", "filename": "libjava/javax/swing/text/Highlighter.java", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FHighlighter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FHighlighter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FHighlighter.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -0,0 +1,80 @@\n+/* Highlighter.java --\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.swing.text;\n+\n+import java.awt.Graphics;\n+import java.awt.Shape;\n+\n+\n+public interface Highlighter\n+{\n+  public interface Highlight\n+  {\n+    int getEndOffset();\n+\n+    int getStartOffset();\n+\n+    HighlightPainter getPainter();\n+  }\n+\n+  public interface HighlightPainter\n+  {\n+    public void paint(Graphics g, int p0, int p1, Shape bounds,\n+\t\t      JTextComponent c);\n+  }\n+  \n+  void install(JTextComponent c);\n+\n+  void deinstall(JTextComponent c);\n+\n+  Object addHighlight(int p0, int p1, HighlightPainter p)\n+    throws BadLocationException;\n+\n+  void removeAllHighlights();\n+\n+  void removeHighlight(Object tag);\n+\n+  void changeHighlight(Object tag, int p0, int p1)\n+    throws BadLocationException;\n+\n+  Highlight[] getHighlights();\n+\n+  void paint(Graphics g);\n+}\n+"}, {"sha": "e44c5296d86bfc8c0f9cafbed62a1fa3ea50d4ef", "filename": "libjava/javax/swing/text/JTextComponent.java", "status": "modified", "additions": 145, "deletions": 17, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FJTextComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FJTextComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FJTextComponent.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -38,6 +38,7 @@\n package javax.swing.text;\n \n import java.awt.AWTEvent;\n+import java.awt.Color;\n import java.awt.Component;\n import java.awt.Dimension;\n import java.awt.Image;\n@@ -67,12 +68,6 @@\n public abstract class JTextComponent extends JComponent\n   implements Scrollable, Accessible\n {\n-//    public class AccessibleJTextComponent extends AccessibleJComponent\n-//      implements AccessibleText, CaretListener, DocumentListener,\n-//                 AccessibleAction, AccessibleEditableText\n-//    {\n-//    }\n-\n   /**\n    * AccessibleJTextComponent\n    */\n@@ -81,11 +76,6 @@ public class AccessibleJTextComponent extends AccessibleJComponent\n   {\n     private static final long serialVersionUID = 7664188944091413696L;\n \n-    /**\n-     * caretPos\n-     */\n-    int caretPos;\n-\n     /**\n      * Constructor AccessibleJTextComponent\n      * @param component TODO\n@@ -280,6 +270,12 @@ public String getBeforeIndex(int value0, int value1)\n     public KeyStroke key;\n     public String actionName;\n \n+    /**\n+     * Creates a new <code>KeyBinding</code> instance.\n+     *\n+     * @param key a <code>KeyStroke</code> value\n+     * @param actionName a <code>String</code> value\n+     */\n     public KeyBinding(KeyStroke key, String actionName)\n     {\n       this.key = key;\n@@ -294,8 +290,16 @@ public KeyBinding(KeyStroke key, String actionName)\n \n   private Document doc;\n   private Caret caret;\n+  private Highlighter highlighter;\n+  private Color caretColor;\n+  private Color disabledTextColor;\n+  private Color selectedTextColor;\n+  private Color selectionColor;\n   private boolean editable;\n \n+  /**\n+   * Creates a new <code>JTextComponent</code> instance.\n+   */\n   public JTextComponent()\n   {\n     enableEvents(AWTEvent.KEY_EVENT_MASK);\n@@ -311,13 +315,13 @@ public void setDocument(Document s)\n \n   public Document getDocument()\n   {\n-    if (doc == null)\n-      System.out.println(\"doc == null !!!\");\n     return doc;\n   }\n \n   /**\n-   * Get the AccessibleContext of this object\n+   * Get the <code>AccessibleContext<code> of this object.\n+   *\n+   * @return an <code>AccessibleContext</code> object\n    */\n   public AccessibleContext getAccessibleContext()\n   {\n@@ -351,7 +355,18 @@ public void setText(String text)\n    */\n   public String getText()\n   {\n-    return getDocument().getText(0, getDocument().getLength());\n+    if (doc == null)\n+      return null;\n+\n+    try\n+      {\n+\treturn doc.getText(0, doc.getLength());\n+      }\n+    catch (BadLocationException e)\n+      {\n+\t// This should never happen.\n+\treturn \"\";\n+      }\n   }\n \n   /**\n@@ -389,14 +404,33 @@ protected String paramString()\n     return \"JTextComponent\";\n   }\n \n+  /**\n+   * This method returns the label's UI delegate.\n+   *\n+   * @return The label's UI delegate.\n+   */\n   public TextUI getUI()\n   {\n-    return (TextUI) UIManager.getUI(this);\n+    return (TextUI) ui;\n+  }\n+\n+  /**\n+   * This method sets the label's UI delegate.\n+   *\n+   * @param ui The label's UI delegate.\n+   */\n+  public void setUI(TextUI newUI)\n+  {\n+    super.setUI(newUI);\n   }\n \n+  /**\n+   * This method resets the label's UI delegate to the default UI for the\n+   * current look and feel.\n+   */\n   public void updateUI()\n   {\n-    setUI(getUI());\n+    setUI((TextUI) UIManager.getUI(this));\n   }\n \n   public Dimension getPreferredScrollableViewportSize()\n@@ -447,6 +481,61 @@ public Caret getCaret()\n     return caret;\n   }\n \n+  /**\n+   * Sets a new <code>Caret</code> for this text component.\n+   *\n+   * @param newCaret the new <code>Caret</code> to set\n+   */\n+  public void setCaret(Caret newCaret)\n+  {\n+    firePropertyChange(\"caret\", caret, newCaret);\n+    caret = newCaret;\n+  }\n+\n+  public Color getCaretColor()\n+  {\n+    return caretColor;\n+  }\n+\n+  public void setCaretColor(Color newColor)\n+  {\n+    firePropertyChange(\"caretColor\", caretColor, newColor);\n+    caretColor = newColor;\n+  }\n+\n+  public Color getDisabledTextColor()\n+  {\n+    return disabledTextColor;\n+  }\n+\n+  public void setDisabledTextColor(Color newColor)\n+  {\n+    firePropertyChange(\"disabledTextColor\", caretColor, newColor);\n+    disabledTextColor = newColor;\n+  }\n+\n+  public Color getSelectedTextColor()\n+  {\n+    return selectedTextColor;\n+  }\n+\n+  public void setSelectedTextColor(Color newColor)\n+  {\n+    firePropertyChange(\"selectedTextColor\", caretColor, newColor);\n+    selectedTextColor = newColor;\n+  }\n+\n+  public Color getSelectionColor()\n+  {\n+    return selectionColor;\n+  }\n+\n+  public void setSelectionColor(Color newColor)\n+  {\n+    firePropertyChange(\"selectionColor\", caretColor, newColor);\n+    selectionColor = newColor;\n+  }\n+\n   /**\n    * Retrisves the current caret position.\n    *\n@@ -488,6 +577,17 @@ public void moveCaretPosition(int position)\n     caret.moveDot(position);\n   }\n \n+  public Highlighter getHighlighter()\n+  {\n+    return highlighter;\n+  }\n+\n+  public void setHighlighter(Highlighter newHighlighter)\n+  {\n+    firePropertyChange(\"highlighter\", highlighter, newHighlighter);\n+    highlighter = newHighlighter;\n+  }\n+\n   /**\n    * Returns the start postion of the currently selected text.\n    *\n@@ -556,6 +656,34 @@ public void selectAll()\n     select(0, doc.getLength());\n   }\n \n+  public synchronized void replaceSelection(String content)\n+  {\n+    int dot = caret.getDot();\n+    int mark = caret.getMark();\n+\n+    // If content is empty delete selection.\n+    if (content == null)\n+      {\n+\tcaret.setDot(dot);\n+\treturn;\n+      }\n+\n+    try\n+      {\n+\t// Remove selected text.\n+\tif (dot != mark)\n+\t  doc.remove(Math.min(dot, mark), Math.max(dot, mark));\n+\n+\t// Insert new text.\n+\tdoc.insertString(Math.min(dot, mark), content, null);\n+      }\n+    catch (BadLocationException e)\n+      {\n+\t// This should never happen.\n+\tSystem.out.println(\"Michael: JTextComponent.replaceSelection: Error\");\n+      }\n+  }\n+\n   public boolean getScrollableTracksViewportHeight()\n   {\n     if (getParent() instanceof JViewport)"}, {"sha": "45932217a02ee760ff08d3276daa09e85a531b37", "filename": "libjava/javax/swing/text/LayeredHighlighter.java", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FLayeredHighlighter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FLayeredHighlighter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FLayeredHighlighter.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -0,0 +1,61 @@\n+/* LayeredHighlighter.java --\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.text;\n+\n+import java.awt.Graphics;\n+import java.awt.Shape;\n+\n+import javax.swing.text.JTextComponent;\n+import javax.swing.text.View;\n+\n+\n+public abstract class LayeredHighlighter\n+  implements Highlighter\n+{\n+  public abstract static class LayerPainter\n+    implements Highlighter.HighlightPainter\n+  {\n+    public abstract Shape paintLayer(Graphics g, int p0, int p1,\n+\t\t\t\t     Shape viewBounds, JTextComponent editor,\n+\t\t\t\t     View view);\n+  }\n+  \n+  public abstract void paintLayeredHighlights(Graphics g, int p0, int p1,\n+                                              Shape viewBounds,\n+                                              JTextComponent editor, View view);\n+}"}, {"sha": "4a8adfca54d7328fedb6ee59d4c5a439530b24ce", "filename": "libjava/javax/swing/text/PlainDocument.java", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FPlainDocument.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FPlainDocument.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FPlainDocument.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -44,6 +44,7 @@ public class PlainDocument extends AbstractDocument\n   public static final String lineLimitAttribute = \"lineLimit\";\n   public static final String tabSizeAttribute = \"tabSize\";\n \n+  private Element rootElement;\n   private int tabSize;\n   \n   public PlainDocument()\n@@ -55,11 +56,22 @@ public PlainDocument(AbstractDocument.Content content)\n   {\n     super(content);\n     tabSize = 8;\n+    rootElement = createDefaultRoot();\n+  }\n+\n+  protected AbstractDocument.AbstractElement createDefaultRoot()\n+  {\n+    BranchElement rootElement =\n+      (BranchElement) createBranchElement(null, null);\n+    Element[] lines = new Element[1];\n+    lines[0] = createLeafElement(rootElement, null, 0, 1);\n+    rootElement.replace(0, 0, lines);\n+    return rootElement;\n   }\n \n   public Element getDefaultRootElement()\n   {\n-    return null;\n+    return rootElement;\n   }\n \n   public Element getParagraphElement(int pos)"}, {"sha": "229c7e193b0d9d108d1f468128c74fa40deb79ad", "filename": "libjava/javax/swing/text/PlainView.java", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FPlainView.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FPlainView.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FPlainView.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -0,0 +1,122 @@\n+/* PlainView.java -- \n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.swing.text;\n+\n+import java.awt.Color;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Rectangle;\n+import java.awt.Shape;\n+\n+\n+public class PlainView extends View\n+  implements TabExpander\n+{\n+  protected FontMetrics metrics;\n+\n+  public PlainView(Element elem)\n+  {\n+    super(elem);\n+  }\n+  \n+  public void drawLine(int lineIndex, Graphics g, int x, int y)\n+  {\n+    try\n+      {\n+\tmetrics = g.getFontMetrics();\n+\t// FIXME: Selected text are not drawn yet.\n+\tdrawUnselectedText(g, x, y, 0, getDocument().getLength());\n+\t//drawSelectedText(g, , , , );\n+      }\n+    catch (BadLocationException e)\n+      {\n+\t// This should never happen.\n+      }\n+  }\n+\n+  public int drawSelectedText(Graphics g, int x, int y, int p0, int p1)\n+    throws BadLocationException\n+  {\n+    String text = getDocument().getText(p0, p1);\n+    g.setColor(Color.WHITE);\n+    g.drawString(text, x, y);\n+    return metrics.stringWidth(text);\n+  }\n+\n+  public int drawUnselectedText(Graphics g, int x, int y, int p0, int p1)\n+    throws BadLocationException\n+  {\n+    String text = getDocument().getText(p0, p1);\n+    g.setColor(Color.BLACK);\n+    g.drawString(text, x, y);\n+    return metrics.stringWidth(text);\n+  }\n+\n+  public void paint(Graphics g, Shape s)\n+  {\n+    System.out.println(\"Michael: PlainView.paint\");\n+    \n+    Rectangle rect = s.getBounds();\n+\n+    g.setColor(Color.WHITE);\n+    g.fillRect(rect.x, rect.y, rect.width, rect.height);\n+    \n+    // FIXME: Text may be scrolled.\n+    drawLine(0, g, rect.x, rect.y);\n+  }\n+\n+  public int getTabSize()\n+  {\n+    return 8;\n+  }\n+\n+  public float nextTabStop(float x, int tabStop)\n+  {\n+    System.out.println(\"Michael: PlainView.nextTabpStop: missing implementation\");\n+    return x;\n+  }\n+\n+  public float getPreferredSpan(int axis)\n+  {\n+    if (axis != X_AXIS && axis != Y_AXIS)\n+      throw new IllegalArgumentException();\n+\n+    return 10;\n+  }\n+}\n\\ No newline at end of file"}, {"sha": "64a91f2e1a4682af496d6b38dedda9690ea6c9aa", "filename": "libjava/javax/swing/text/Position.java", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FPosition.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FPosition.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FPosition.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -1,5 +1,5 @@\n /* Position.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -42,6 +42,20 @@\n {\n     static class Bias\n     {\n+    public static final Bias Backward = new Bias(\"backward\");\n+    public static final Bias Forward = new Bias(\"forward\");\n+\n+    private String name;\n+    \n+    private Bias(String n)\n+    {\n+      name = n;\n+    }\n+\n+    public String toString()\n+    {\n+      return name;\n+    }\n     }\n     \n     int getOffset();"}, {"sha": "69e2fecfc3884fedcf7828ec3d4865e8c40a1eb2", "filename": "libjava/javax/swing/text/Segment.java", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FSegment.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FSegment.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FSegment.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "patch": "@@ -37,22 +37,38 @@\n \n package javax.swing.text;\n \n-public class Segment implements Cloneable, CharacterIterator\n+import java.text.CharacterIterator;\n+\n+\n+public class Segment\n+  implements Cloneable, CharacterIterator\n {\n-    char[] array;\n-    int count;\n-    int offset;\n+  public char[] array;\n+  public int count;\n+  public int offset;\n+\n+  public Segment()\n+  {\n+  }\n+\n+  public Segment(char[] array, int offset, int count)\n+  {\n+    this.array = array;\n+    this.offset = offset;\n+    this.count = count;\n+  }\n     \n     public Object clone()\n     {\n-\ttry {\n+    try\n+      {\n \t    return super.clone();\n-\t} catch (Exception e) {\n-\t    System.err.println(\"Huuuhhh, this class implements cloneable !!!!!!\");\n-\t    System.err.println(\"I think there is a bug in this JVM somewhere\");\n \t}\n+    catch (CloneNotSupportedException e)\n+      {\n \treturn null;\n     }\n+  }\n     \n     public char current()\n     {\n@@ -74,25 +90,30 @@ public int getEndIndex()\n     {\n \treturn offset + count;\n     }\n+\n     public int getIndex()\n     {\n \treturn offset;\n     }\n+\n     public char last()\n     {\n \toffset = getEndIndex() - 1;\n \treturn array[offset];\n     }\n+\n     public char next()\n     {\n \toffset++;\n \treturn array[offset];\n     }\n+\n     public char previous()\n     {\n \toffset--;\n \treturn array[offset];\n     }\n+\n     public char setIndex(int position)\n     {\n \toffset = position;\n@@ -104,4 +125,3 @@ public String toString()\n \treturn new String(array, offset, count);\n     }\n }\n-"}, {"sha": "d3db03e208d679b7fc08f4db2eaf53dc6ae579db", "filename": "libjava/javax/swing/text/StyledEditorKit.java", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FStyledEditorKit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FStyledEditorKit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FStyledEditorKit.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23"}, {"sha": "56940f552a53b81d2eaa7968a5b9c10052083764", "filename": "libjava/javax/swing/text/TabExpander.java", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FTabExpander.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FTabExpander.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FTabExpander.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23"}, {"sha": "9d244be19c799cb7328a3d51b25b5bbf18c516fd", "filename": "libjava/javax/swing/text/TabableView.java", "status": "renamed", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FTabableView.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FTabableView.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FTabableView.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23", "previous_filename": "libjava/javax/swing/text/CharacterIterator.java"}, {"sha": "5fee0e8640d756984094856b5f62ed5d889d791c", "filename": "libjava/javax/swing/text/TextAction.java", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FTextAction.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FTextAction.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FTextAction.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23"}, {"sha": "6c5a9c296dde25881f1c79c2c299ad1bc51b1cd3", "filename": "libjava/javax/swing/text/View.java", "status": "modified", "additions": 71, "deletions": 43, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FView.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FView.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FView.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23"}, {"sha": "52be67ba557db6e3db52712da37c2982b34ef4cc", "filename": "libjava/javax/swing/text/ViewFactory.java", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FViewFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjavax%2Fswing%2Ftext%2FViewFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FViewFactory.java?ref=8e99fb4f70a03741b3be630a290932c4de63ce23"}, {"sha": "6bc24872dfa59d4aaee6a7ec4b19eaf8b1fb598e", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c?ref=8e99fb4f70a03741b3be630a290932c4de63ce23"}, {"sha": "95bec4a10be5251f0614fd9b76682546cde7b72e", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkFileDialogPeer.c", "status": "modified", "additions": 120, "deletions": 74, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkFileDialogPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkFileDialogPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkFileDialogPeer.c?ref=8e99fb4f70a03741b3be630a290932c4de63ce23"}, {"sha": "a9da539f223abfce1860be2c8881e276a2db560a", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMainThread.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkMainThread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkMainThread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkMainThread.c?ref=8e99fb4f70a03741b3be630a290932c4de63ce23"}, {"sha": "835c2348d399fb3abbcc568cde639cf78d77d5c4", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkPanelPeer.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkPanelPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkPanelPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkPanelPeer.c?ref=8e99fb4f70a03741b3be630a290932c4de63ce23"}, {"sha": "2d62c33a4d7c6ab7fd9797d0b83aa22cd774c22f", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextComponentPeer.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkTextComponentPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkTextComponentPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkTextComponentPeer.c?ref=8e99fb4f70a03741b3be630a290932c4de63ce23"}, {"sha": "4d11e6201bc1b698d65b8e8c07ada79f76efb129", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c", "status": "modified", "additions": 103, "deletions": 79, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkWindowPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e99fb4f70a03741b3be630a290932c4de63ce23/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkWindowPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkWindowPeer.c?ref=8e99fb4f70a03741b3be630a290932c4de63ce23"}]}