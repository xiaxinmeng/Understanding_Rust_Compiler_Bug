{"sha": "932670198f01eab28395bc628962f0e339bd2982", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMyNjcwMTk4ZjAxZWFiMjgzOTViYzYyODk2MmYwZTMzOWJkMjk4Mg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-02-09T23:28:55Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-02-09T23:28:55Z"}, "message": "* java/util/Timer.java: New version from Classpath.\n\nFrom-SVN: r39573", "tree": {"sha": "f3b7bdbe68d45481ed0248db636deddbb8a80942", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3b7bdbe68d45481ed0248db636deddbb8a80942"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/932670198f01eab28395bc628962f0e339bd2982", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/932670198f01eab28395bc628962f0e339bd2982", "html_url": "https://github.com/Rust-GCC/gccrs/commit/932670198f01eab28395bc628962f0e339bd2982", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/932670198f01eab28395bc628962f0e339bd2982/comments", "author": null, "committer": null, "parents": [{"sha": "0e206b71aab6068420185d98893ee2de8545737a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e206b71aab6068420185d98893ee2de8545737a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e206b71aab6068420185d98893ee2de8545737a"}], "stats": {"total": 925, "additions": 496, "deletions": 429}, "files": [{"sha": "93a23bce13d4bc53839bf9bb1158f706315aaaba", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932670198f01eab28395bc628962f0e339bd2982/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932670198f01eab28395bc628962f0e339bd2982/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=932670198f01eab28395bc628962f0e339bd2982", "patch": "@@ -1,3 +1,7 @@\n+2001-02-09  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/util/Timer.java: New version from Classpath.\n+\n 2001-02-09  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* java/lang/Double.java (doubleToRawLongBits): Now native."}, {"sha": "d00c93768cb567e825b116ddd3e9d0ef5a727853", "filename": "libjava/java/util/Timer.java", "status": "modified", "additions": 492, "deletions": 429, "changes": 921, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932670198f01eab28395bc628962f0e339bd2982/libjava%2Fjava%2Futil%2FTimer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932670198f01eab28395bc628962f0e339bd2982/libjava%2Fjava%2Futil%2FTimer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FTimer.java?ref=932670198f01eab28395bc628962f0e339bd2982", "patch": "@@ -1,13 +1,13 @@\n /* Timer.java -- Timer that runs TimerTasks at a later time.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -50,476 +50,539 @@\n  * @since 1.3\n  * @author Mark Wielaard (mark@klomp.org)\n  */\n-public class Timer {\n-\n-    /**\n-     * Priority Task Queue.\n-     * TimerTasks are kept in a binary heap.\n-     * The scheduler calls sleep() on the queue when it has nothing to do or\n-     * has to wait. A sleeping scheduler can be notified by calling interrupt()\n-     * which is automatically called by the enqueue(), cancel() and\n-     * timerFinalized() methods.\n-     */\n-    private static final class TaskQueue {\n-\n-        /** Default size of this queue */\n-        private final int DEFAULT_SIZE = 32;\n-\n-        /** Wheter to return null when there is nothing in the queue */\n-        private boolean nullOnEmpty;\n-\n-        /**\n-         * The heap containing all the scheduled TimerTasks\n-         * sorted by the TimerTask.scheduled field.\n-         * Null when the stop() method has been called.\n-         */\n-        private TimerTask heap[];\n-\n-        /**\n-         * The actual number of elements in the heap\n-         * Can be less then heap.length.\n-         * Note that heap[0] is used as a sentinel.\n-         */\n-        private int elements;\n-\n-        /**\n-         * Creates a TaskQueue of default size without any elements in it.\n-         */\n-        public TaskQueue() {\n-            heap = new TimerTask[DEFAULT_SIZE];\n-            elements = 0;\n-            nullOnEmpty = false;\n-        }\n-\n-        /**\n-         * Adds a TimerTask at the end of the heap.\n-         * Grows the heap if necessary by doubling the heap in size.\n-         */\n-        private void add(TimerTask task) {\n-            elements++;\n-            if (elements == heap.length) {\n-                TimerTask new_heap[] = new TimerTask[heap.length*2];\n-                System.arraycopy(heap, 0, new_heap, 0, heap.length);\n-                heap = new_heap;\n-            }\n-            heap[elements] = task;\n-        }\n-\n-        /**\n-         * Removes the last element from the heap.\n-         * Shrinks the heap in half if\n-         * elements+DEFAULT_SIZE/2 <= heap.length/4.\n-         */\n-        private void remove() {\n-            // clear the entry first\n-            heap[elements] = null;\n-            elements--;\n-            if (elements+DEFAULT_SIZE/2 <= (heap.length/4)) {\n-                TimerTask new_heap[] = new TimerTask[heap.length/2];\n-                System.arraycopy(heap, 0, new_heap, 0, elements+1);\n-            }\n-        }\n-\n-        /**\n-         * Adds a task to the queue and puts it at the correct place\n-         * in the heap.\n-         */\n-        public synchronized void enqueue(TimerTask task) {\n- \n-           // Check if it is legal to add another element\n-            if (heap == null) {\n-                throw new IllegalStateException\n-                    (\"cannot enqueue when stop() has been called on queue\");\n-            }\n-\n-            heap[0] = task; // sentinel\n-            add(task); // put the new task at the end\n-            // Now push the task up in the heap until it has reached its place\n-            int child = elements;\n-            int parent = child / 2;\n-            while (heap[parent].scheduled > task.scheduled) {\n-                heap[child] = heap[parent];\n-                child = parent;\n-                parent = child / 2;\n-            }\n-            // This is the correct place for the new task\n-            heap[child] = task;\n-            heap[0] = null; // clear sentinel\n-            // Maybe sched() is waiting for a new element\n-            this.notify();\n-        }\n-\n-        /**\n-         * Returns the top element of the queue.\n-         * Can return null when no task is in the queue.\n-         */\n-        private TimerTask top() {\n-            if (elements == 0) {\n-                return null;\n-            } else {\n-                return heap[1];\n-            }\n-        }\n-\n-        /**\n-         * Returns the top task in the Queue.\n-         * Removes the element from the heap and reorders the heap first.\n-         * Can return null when there is nothing in the queue.\n-         */\n-        public synchronized TimerTask serve() {\n-            // The task to return\n-            TimerTask task = null;\n-            \n-            while (task == null) {\n-                // Get the next task\n-                task = top();\n-                \n-                // return null when asked to stop\n-                // or if asked to return null when the queue is empty\n-                if ((heap == null) || (task == null && nullOnEmpty)) {\n-                    return null;\n-                }\n-                \n-                // Do we have a task?\n-                if (task != null) {\n-                    // The time to wait until the task should be served\n-                    long time = task.scheduled-System.currentTimeMillis();\n-                    if (time > 0) {\n-                        // This task should not yet be served\n-                        // So wait until this task is ready\n-                        // or something else happens to the queue\n-                        task = null; // set to null to make sure we call top()\n-                        try {\n-                            this.wait(time);\n-                        } catch (InterruptedException _) {}\n-                    }\n-                } else {\n-                    // wait until a task is added\n-                    // or something else happens to the queue\n-                    try {\n-                        this.wait();\n-                    } catch (InterruptedException _) {}\n-                }\n-            }\n-            \n-            // reconstruct the heap\n-            TimerTask lastTask = heap[elements];\n-            remove();\n-            \n-            // drop lastTask at the beginning and move it down the heap\n-            int parent = 1;\n-            int child = 2;\n-            heap[1] = lastTask;\n-            while(child <= elements) {\n-                if (child < elements) {\n-                    if (heap[child].scheduled > heap[child+1].scheduled) {\n-                        child++;\n-                    }\n-                }\n-                \n-                if (lastTask.scheduled <= heap[child].scheduled)\n-                    break; // found the correct place (the parent) - done\n-                \n-                heap[parent] = heap[child];\n-                parent = child;\n-                child = parent*2;\n-            }\n-\n-            // this is the correct new place for the lastTask\n-            heap[parent] = lastTask;\n-\n-            // return the task\n-            return task;\n-        }\n-\n-    \n-        /**\n-         * When nullOnEmpty is true the serve() method will return null when\n-         * there are no tasks in the queue, otherwise it will wait until\n-         * a new element is added to the queue. It is used to indicate to\n-         * the scheduler that no new tasks will ever be added to the queue.\n-         */\n-        public synchronized void setNullOnEmpty(boolean nullOnEmpty) {\n-            this.nullOnEmpty = nullOnEmpty;\n-            this.notify();\n-        }\n-\n-        /**\n-         * When this method is called the current and all future calls to\n-         * serve() will return null. It is used to indicate to the Scheduler\n-         * that it should stop executing since no more tasks will come.\n-         */\n-        public synchronized void stop() {\n-            this.heap = null;\n-            this.notify();\n-        }\n-        \n-    } // TaskQueue\n+public class Timer\n+{\n+  /**\n+   * Priority Task Queue.\n+   * TimerTasks are kept in a binary heap.\n+   * The scheduler calls sleep() on the queue when it has nothing to do or\n+   * has to wait. A sleeping scheduler can be notified by calling interrupt()\n+   * which is automatically called by the enqueue(), cancel() and\n+   * timerFinalized() methods.\n+   */\n+  private static final class TaskQueue\n+  {\n+    /** Default size of this queue */\n+    private final int DEFAULT_SIZE = 32;\n+\n+    /** Wheter to return null when there is nothing in the queue */\n+    private boolean nullOnEmpty;\n \n     /**\n-     * The scheduler that executes all the tasks on a particular TaskQueue,\n-     * reschedules any repeating tasks and that waits when no task has to be\n-     * executed immediatly. Stops running when canceled or when the parent\n-     * Timer has been finalized and no more tasks have to be executed.\n+     * The heap containing all the scheduled TimerTasks\n+     * sorted by the TimerTask.scheduled field.\n+     * Null when the stop() method has been called.\n      */\n-    private static final class Scheduler implements Runnable {\n-\n-        // The priority queue containing all the TimerTasks.\n-        private TaskQueue queue;\n-\n-        /**\n-         * Creates a new Scheduler that will schedule the tasks on the\n-         * given TaskQueue.\n-         */\n-        public Scheduler(TaskQueue queue) {\n-            this.queue = queue;\n-        }\n-\n-        public void run() {\n-            TimerTask task;\n-            while((task = queue.serve()) != null) {\n-                // If this task has not been canceled\n-                if (task.scheduled >= 0) {\n-\n-                    // Mark execution time\n-                    task.lastExecutionTime = task.scheduled;\n-\n-                    // Repeatable task?\n-                    if (task.period < 0) {\n-                        // Last time this task is executed\n-                        task.scheduled = -1;\n-                    }\n-\n-                    // Run the task\n-                    try {\n-                        task.run();\n-                    } catch (Throwable t) {/* ignore all errors */}\n-                }\n-\n-                // Calculate next time and possibly re-enqueue\n-                if (task.scheduled >= 0) {\n-                    if (task.fixed) {\n-                        task.scheduled += task.period;\n-                    } else {\n-                        task.scheduled = task.period +\n-                            System.currentTimeMillis();\n-                    }\n-                    queue.enqueue(task);\n-                }\n-            }\n-        }\n-    } // Scheduler\n-\n-    // Number of Timers created.\n-    // Used for creating nice Thread names.\n-    private static int  nr = 0;\n-\n-    // The queue that all the tasks are put in.\n-    // Given to the scheduler\n-    private TaskQueue queue;\n-\n-    // The Scheduler that does all the real work\n-    private Scheduler scheduler;\n-\n-    // Used to run the scheduler.\n-    // Also used to checked if the Thread is still running by calling\n-    // thread.isAlive(). Sometimes a Thread is suddenly killed by the system\n-    // (if it belonged to an Applet).\n-    private Thread thread;\n-    \n-    // When cancelled we don't accept any more TimerTasks.\n-    private boolean canceled;\n-\n-    /**\n-     * Creates a new Timer with a non deamon Thread as Scheduler, with normal\n-     * priority and a default name.\n-     */\n-    public Timer() {\n-        this(false);\n-    }\n+    private TimerTask heap[];\n \n     /**\n-     * Creates a new Timer with a deamon Thread as scheduler if deamon is true,\n-     * with normal priority and a default name.\n+     * The actual number of elements in the heap\n+     * Can be less then heap.length.\n+     * Note that heap[0] is used as a sentinel.\n      */\n-    public Timer(boolean daemon) {\n-        this(daemon, Thread.NORM_PRIORITY);\n-    }\n+    private int elements;\n \n     /**\n-     * Creates a new Timer with a deamon Thread as scheduler if deamon is true,\n-     * with the priority given and a default name.\n+     * Creates a TaskQueue of default size without any elements in it.\n      */\n-    private Timer(boolean daemon, int priority) {\n-        this(daemon, priority, \"Timer-\" + (++nr));\n+    public TaskQueue()\n+    {\n+      heap = new TimerTask[DEFAULT_SIZE];\n+      elements = 0;\n+      nullOnEmpty = false;\n     }\n \n     /**\n-     * Creates a new Timer with a deamon Thread as scheduler if deamon is true,\n-     * with the priority and name given.E\n+     * Adds a TimerTask at the end of the heap.\n+     * Grows the heap if necessary by doubling the heap in size.\n      */\n-    private Timer(boolean daemon, int priority, String name) {\n-        canceled = false;\n-        queue = new TaskQueue();\n-        scheduler = new Scheduler(queue);\n-        thread = new Thread(scheduler, name);\n-        thread.setDaemon(daemon);\n-        thread.setPriority(priority);\n-        thread.start();\n+    private void add(TimerTask task)\n+    {\n+      elements++;\n+      if (elements == heap.length)\n+\t{\n+\t  TimerTask new_heap[] = new TimerTask[heap.length * 2];\n+\t  System.arraycopy(heap, 0, new_heap, 0, heap.length);\n+\t  heap = new_heap;\n+\t}\n+      heap[elements] = task;\n     }\n \n     /**\n-     * Cancels the execution of the scheduler. If a task is executing it will\n-     * normally finish execution, but no other tasks will be executed and no\n-     * more tasks can be scheduled.\n+     * Removes the last element from the heap.\n+     * Shrinks the heap in half if\n+     * elements+DEFAULT_SIZE/2 <= heap.length/4.\n      */\n-    public void cancel() {\n-        canceled = true;\n-        queue.stop();\n+    private void remove()\n+    {\n+      // clear the entry first\n+      heap[elements] = null;\n+      elements--;\n+      if (elements + DEFAULT_SIZE / 2 <= (heap.length / 4))\n+\t{\n+\t  TimerTask new_heap[] = new TimerTask[heap.length / 2];\n+\t  System.arraycopy(heap, 0, new_heap, 0, elements + 1);\n+\t  heap = new_heap;\n+\t}\n     }\n \n     /**\n-     * Schedules the task at Time time, repeating every period\n-     * milliseconds if period is positive and at a fixed rate if fixed is true.\n-     *\n-     * @exception IllegalArgumentException if time is negative\n-     * @exception IllegalStateException if the task was already scheduled or\n-     * canceled or this Timer is canceled or the scheduler thread has died\n+     * Adds a task to the queue and puts it at the correct place\n+     * in the heap.\n      */\n-    private void schedule(TimerTask task,\n-                          long time,\n-                          long period,\n-                          boolean fixed) {\n-\n-        if (time < 0)\n-            throw new IllegalArgumentException(\"negative time\");\n-\n-        if (task.scheduled == 0 && task.lastExecutionTime == -1) {\n-            task.scheduled = time;\n-            task.period = period;\n-            task.fixed = fixed;\n-        } else {\n-            throw new IllegalStateException\n-                (\"task was already scheduled or canceled\");\n-        }\n-\n-        if (!this.canceled && this.thread != null) {\n-            queue.enqueue(task);\n-        } else {\n-            throw new IllegalStateException\n-                (\"timer was canceled or scheduler thread has died\");\n-        }\n-    }\n-\n-    private static void positiveDelay(long delay) {\n-        if (delay < 0) {\n-            throw new IllegalArgumentException(\"delay is negative\");\n-        }\n-    }\n-\n-    private static void positivePeriod(long period) {\n-        if (period < 0) {\n-            throw new IllegalArgumentException(\"period is negative\");\n-        }\n+    public synchronized void enqueue(TimerTask task)\n+    {\n+      // Check if it is legal to add another element\n+      if (heap == null)\n+\t{\n+\t  throw new IllegalStateException\n+\t    (\"cannot enqueue when stop() has been called on queue\");\n+\t}\n+\n+      heap[0] = task;\t\t// sentinel\n+      add(task);\t\t// put the new task at the end\n+      // Now push the task up in the heap until it has reached its place\n+      int child = elements;\n+      int parent = child / 2;\n+      while (heap[parent].scheduled > task.scheduled)\n+\t{\n+\t  heap[child] = heap[parent];\n+\t  child = parent;\n+\t  parent = child / 2;\n+\t}\n+      // This is the correct place for the new task\n+      heap[child] = task;\n+      heap[0] = null;\t\t// clear sentinel\n+      // Maybe sched() is waiting for a new element\n+      this.notify();\n     }\n \n     /**\n-     * Schedules the task at the specified data for one time execution.\n-     *\n-     * @exception IllegalArgumentException if date.getTime() is negative\n-     * @exception IllegalStateException if the task was already scheduled or\n-     * canceled or this Timer is canceled or the scheduler thread has died\n+     * Returns the top element of the queue.\n+     * Can return null when no task is in the queue.\n      */\n-    public void schedule(TimerTask task, Date date) {\n-        long time = date.getTime();\n-        schedule(task, time, -1, false);\n+    private TimerTask top()\n+    {\n+      if (elements == 0)\n+\t{\n+\t  return null;\n+\t}\n+      else\n+\t{\n+\t  return heap[1];\n+\t}\n     }\n \n     /**\n-     * Schedules the task at the specified date and reschedules the task every\n-     * period milliseconds after the last execution of the task finishes until\n-     * this timer or the task is canceled.\n-     *\n-     * @exception IllegalArgumentException if period or date.getTime() is\n-     * negative\n-     * @exception IllegalStateException if the task was already scheduled or\n-     * canceled or this Timer is canceled or the scheduler thread has died\n+     * Returns the top task in the Queue.\n+     * Removes the element from the heap and reorders the heap first.\n+     * Can return null when there is nothing in the queue.\n      */\n-    public void schedule(TimerTask task, Date date, long period) {\n-        positivePeriod(period);\n-        long time = date.getTime();\n-        schedule(task, time, period, false);\n+    public synchronized TimerTask serve()\n+    {\n+      // The task to return\n+      TimerTask task = null;\n+\n+      while (task == null)\n+\t{\n+\t  // Get the next task\n+\t  task = top();\n+\n+\t  // return null when asked to stop\n+\t  // or if asked to return null when the queue is empty\n+\t  if ((heap == null) || (task == null && nullOnEmpty))\n+\t    {\n+\t      return null;\n+\t    }\n+\n+\t  // Do we have a task?\n+\t  if (task != null)\n+\t    {\n+\t      // The time to wait until the task should be served\n+\t      long time = task.scheduled - System.currentTimeMillis();\n+\t      if (time > 0)\n+\t\t{\n+\t\t  // This task should not yet be served\n+\t\t  // So wait until this task is ready\n+\t\t  // or something else happens to the queue\n+\t\t  task = null;\t// set to null to make sure we call top()\n+\t\t  try\n+\t\t    {\n+\t\t      this.wait(time);\n+\t\t    }\n+\t\t  catch (InterruptedException _)\n+\t\t    {\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      // wait until a task is added\n+\t      // or something else happens to the queue\n+\t      try\n+\t\t{\n+\t\t  this.wait();\n+\t\t}\n+\t      catch (InterruptedException _)\n+\t\t{\n+\t\t}\n+\t    }\n+\t}\n+\n+      // reconstruct the heap\n+      TimerTask lastTask = heap[elements];\n+      remove();\n+\n+      // drop lastTask at the beginning and move it down the heap\n+      int parent = 1;\n+      int child = 2;\n+      heap[1] = lastTask;\n+      while (child <= elements)\n+\t{\n+\t  if (child < elements)\n+\t    {\n+\t      if (heap[child].scheduled > heap[child + 1].scheduled)\n+\t\t{\n+\t\t  child++;\n+\t\t}\n+\t    }\n+\n+\t  if (lastTask.scheduled <= heap[child].scheduled)\n+\t    break;\t\t// found the correct place (the parent) - done\n+\n+\t  heap[parent] = heap[child];\n+\t  parent = child;\n+\t  child = parent * 2;\n+\t}\n+\n+      // this is the correct new place for the lastTask\n+      heap[parent] = lastTask;\n+\n+      // return the task\n+      return task;\n     }\n \n     /**\n-     * Schedules the task after the specified delay milliseconds for one time\n-     * execution.\n-     *\n-     * @exception IllegalArgumentException if delay or\n-     * System.currentTimeMillis + delay is negative\n-     * @exception IllegalStateException if the task was already scheduled or\n-     * canceled or this Timer is canceled or the scheduler thread has died\n+     * When nullOnEmpty is true the serve() method will return null when\n+     * there are no tasks in the queue, otherwise it will wait until\n+     * a new element is added to the queue. It is used to indicate to\n+     * the scheduler that no new tasks will ever be added to the queue.\n      */\n-    public void schedule(TimerTask task, long delay) {\n-        positiveDelay(delay);\n-        long time = System.currentTimeMillis() + delay;\n-        schedule(task, time, -1, false);\n+    public synchronized void setNullOnEmpty(boolean nullOnEmpty)\n+    {\n+      this.nullOnEmpty = nullOnEmpty;\n+      this.notify();\n     }\n \n     /**\n-     * Schedules the task after the delay milliseconds and reschedules the\n-     * task every period milliseconds after the last execution of the task\n-     * finishes until this timer or the task is canceled.\n-     *\n-     * @exception IllegalArgumentException if delay or period is negative\n-     * @exception IllegalStateException if the task was already scheduled or\n-     * canceled or this Timer is canceled or the scheduler thread has died\n+     * When this method is called the current and all future calls to\n+     * serve() will return null. It is used to indicate to the Scheduler\n+     * that it should stop executing since no more tasks will come.\n      */\n-    public void schedule(TimerTask task, long delay, long period) {\n-        positiveDelay(delay);\n-        positivePeriod(period);\n-        long time = System.currentTimeMillis() + delay;\n-        schedule(task, time, period, false);\n+    public synchronized void stop()\n+    {\n+      this.heap = null;\n+      this.notify();\n     }\n \n-    /**\n-     * Schedules the task at the specified date and reschedules the task at a\n-     * fixed rate every period milliseconds until this timer or the task is\n-     * canceled.\n-     *\n-     * @exception IllegalArgumentException if period or date.getTime() is\n-     * negative\n-     * @exception IllegalStateException if the task was already scheduled or\n-     * canceled or this Timer is canceled or the scheduler thread has died\n-     */\n-    public void scheduleAtFixedRate(TimerTask task, Date date, long period) {\n-        positivePeriod(period);\n-        long time = date.getTime();\n-        schedule(task, time, period, true);\n-    }\n+  }\t\t\t\t// TaskQueue\n+\n+  /**\n+   * The scheduler that executes all the tasks on a particular TaskQueue,\n+   * reschedules any repeating tasks and that waits when no task has to be\n+   * executed immediatly. Stops running when canceled or when the parent\n+   * Timer has been finalized and no more tasks have to be executed.\n+   */\n+  private static final class Scheduler implements Runnable\n+  {\n+    // The priority queue containing all the TimerTasks.\n+    private TaskQueue queue;\n \n     /**\n-     * Schedules the task after the delay milliseconds and reschedules the task\n-     * at a fixed rate every period milliseconds until this timer or the task\n-     * is canceled.\n-     *\n-     * @exception IllegalArgumentException if delay or\n-     * System.currentTimeMillis + delay is negative\n-     * @exception IllegalStateException if the task was already scheduled or\n-     * canceled or this Timer is canceled or the scheduler thread has died\n+     * Creates a new Scheduler that will schedule the tasks on the\n+     * given TaskQueue.\n      */\n-    public void scheduleAtFixedRate(TimerTask task, long delay, long period) {\n-        positiveDelay(delay);\n-        positivePeriod(period);\n-        long time = System.currentTimeMillis() + delay;\n-        schedule(task, time, period, true);\n+    public Scheduler(TaskQueue queue)\n+    {\n+      this.queue = queue;\n     }\n \n-    /**\n-     * Tells the scheduler that the Timer task died\n-     * so there will be no more new tasks scheduled.\n-     */\n-    protected void finalize() {\n-        queue.setNullOnEmpty(true);\n+    public void run()\n+    {\n+      TimerTask task;\n+      while ((task = queue.serve()) != null)\n+\t{\n+\t  // If this task has not been canceled\n+\t  if (task.scheduled >= 0)\n+\t    {\n+\n+\t      // Mark execution time\n+\t      task.lastExecutionTime = task.scheduled;\n+\n+\t      // Repeatable task?\n+\t      if (task.period < 0)\n+\t\t{\n+\t\t  // Last time this task is executed\n+\t\t  task.scheduled = -1;\n+\t\t}\n+\n+\t      // Run the task\n+\t      try\n+\t\t{\n+\t\t  task.run();\n+\t\t}\n+\t      catch (Throwable t)\n+\t\t{\t\t\n+\t\t  /* ignore all errors */\n+\t\t}\n+\t    }\n+\n+\t  // Calculate next time and possibly re-enqueue\n+\t  if (task.scheduled >= 0)\n+\t    {\n+\t      if (task.fixed)\n+\t\t{\n+\t\t  task.scheduled += task.period;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  task.scheduled = task.period + System.currentTimeMillis();\n+\t\t}\n+\t      queue.enqueue(task);\n+\t    }\n+\t}\n     }\n+  }\t\t\t\t// Scheduler\n+\n+  // Number of Timers created.\n+  // Used for creating nice Thread names.\n+  private static int nr = 0;\n+\n+  // The queue that all the tasks are put in.\n+  // Given to the scheduler\n+  private TaskQueue queue;\n+\n+  // The Scheduler that does all the real work\n+  private Scheduler scheduler;\n+\n+  // Used to run the scheduler.\n+  // Also used to checked if the Thread is still running by calling\n+  // thread.isAlive(). Sometimes a Thread is suddenly killed by the system\n+  // (if it belonged to an Applet).\n+  private Thread thread;\n+\n+  // When cancelled we don't accept any more TimerTasks.\n+  private boolean canceled;\n+\n+  /**\n+   * Creates a new Timer with a non deamon Thread as Scheduler, with normal\n+   * priority and a default name.\n+   */\n+  public Timer()\n+  {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new Timer with a deamon Thread as scheduler if deamon is true,\n+   * with normal priority and a default name.\n+   */\n+  public Timer(boolean daemon)\n+  {\n+    this(daemon, Thread.NORM_PRIORITY);\n+  }\n+\n+  /**\n+   * Creates a new Timer with a deamon Thread as scheduler if deamon is true,\n+   * with the priority given and a default name.\n+   */\n+  private Timer(boolean daemon, int priority)\n+  {\n+    this(daemon, priority, \"Timer-\" + (++nr));\n+  }\n+\n+  /**\n+   * Creates a new Timer with a deamon Thread as scheduler if deamon is true,\n+   * with the priority and name given.E\n+   */\n+  private Timer(boolean daemon, int priority, String name)\n+  {\n+    canceled = false;\n+    queue = new TaskQueue();\n+    scheduler = new Scheduler(queue);\n+    thread = new Thread(scheduler, name);\n+    thread.setDaemon(daemon);\n+    thread.setPriority(priority);\n+    thread.start();\n+  }\n+\n+  /**\n+   * Cancels the execution of the scheduler. If a task is executing it will\n+   * normally finish execution, but no other tasks will be executed and no\n+   * more tasks can be scheduled.\n+   */\n+  public void cancel()\n+  {\n+    canceled = true;\n+    queue.stop();\n+  }\n+\n+  /**\n+   * Schedules the task at Time time, repeating every period\n+   * milliseconds if period is positive and at a fixed rate if fixed is true.\n+   *\n+   * @exception IllegalArgumentException if time is negative\n+   * @exception IllegalStateException if the task was already scheduled or\n+   * canceled or this Timer is canceled or the scheduler thread has died\n+   */\n+  private void schedule(TimerTask task, long time, long period, boolean fixed)\n+  {\n+    if (time < 0)\n+      throw new IllegalArgumentException(\"negative time\");\n+\n+    if (task.scheduled == 0 && task.lastExecutionTime == -1)\n+      {\n+\ttask.scheduled = time;\n+\ttask.period = period;\n+\ttask.fixed = fixed;\n+      }\n+    else\n+      {\n+\tthrow new IllegalStateException\n+\t  (\"task was already scheduled or canceled\");\n+      }\n+\n+    if (!this.canceled && this.thread != null)\n+      {\n+\tqueue.enqueue(task);\n+      }\n+    else\n+      {\n+\tthrow new IllegalStateException\n+\t  (\"timer was canceled or scheduler thread has died\");\n+      }\n+  }\n+\n+  private static void positiveDelay(long delay)\n+  {\n+    if (delay < 0)\n+      {\n+\tthrow new IllegalArgumentException(\"delay is negative\");\n+      }\n+  }\n+\n+  private static void positivePeriod(long period)\n+  {\n+    if (period < 0)\n+      {\n+\tthrow new IllegalArgumentException(\"period is negative\");\n+      }\n+  }\n+\n+  /**\n+   * Schedules the task at the specified data for one time execution.\n+   *\n+   * @exception IllegalArgumentException if date.getTime() is negative\n+   * @exception IllegalStateException if the task was already scheduled or\n+   * canceled or this Timer is canceled or the scheduler thread has died\n+   */\n+  public void schedule(TimerTask task, Date date)\n+  {\n+    long time = date.getTime();\n+    schedule(task, time, -1, false);\n+  }\n+\n+  /**\n+   * Schedules the task at the specified date and reschedules the task every\n+   * period milliseconds after the last execution of the task finishes until\n+   * this timer or the task is canceled.\n+   *\n+   * @exception IllegalArgumentException if period or date.getTime() is\n+   * negative\n+   * @exception IllegalStateException if the task was already scheduled or\n+   * canceled or this Timer is canceled or the scheduler thread has died\n+   */\n+  public void schedule(TimerTask task, Date date, long period)\n+  {\n+    positivePeriod(period);\n+    long time = date.getTime();\n+    schedule(task, time, period, false);\n+  }\n+\n+  /**\n+   * Schedules the task after the specified delay milliseconds for one time\n+   * execution.\n+   *\n+   * @exception IllegalArgumentException if delay or\n+   * System.currentTimeMillis + delay is negative\n+   * @exception IllegalStateException if the task was already scheduled or\n+   * canceled or this Timer is canceled or the scheduler thread has died\n+   */\n+  public void schedule(TimerTask task, long delay)\n+  {\n+    positiveDelay(delay);\n+    long time = System.currentTimeMillis() + delay;\n+    schedule(task, time, -1, false);\n+  }\n+\n+  /**\n+   * Schedules the task after the delay milliseconds and reschedules the\n+   * task every period milliseconds after the last execution of the task\n+   * finishes until this timer or the task is canceled.\n+   *\n+   * @exception IllegalArgumentException if delay or period is negative\n+   * @exception IllegalStateException if the task was already scheduled or\n+   * canceled or this Timer is canceled or the scheduler thread has died\n+   */\n+  public void schedule(TimerTask task, long delay, long period)\n+  {\n+    positiveDelay(delay);\n+    positivePeriod(period);\n+    long time = System.currentTimeMillis() + delay;\n+    schedule(task, time, period, false);\n+  }\n+\n+  /**\n+   * Schedules the task at the specified date and reschedules the task at a\n+   * fixed rate every period milliseconds until this timer or the task is\n+   * canceled.\n+   *\n+   * @exception IllegalArgumentException if period or date.getTime() is\n+   * negative\n+   * @exception IllegalStateException if the task was already scheduled or\n+   * canceled or this Timer is canceled or the scheduler thread has died\n+   */\n+  public void scheduleAtFixedRate(TimerTask task, Date date, long period)\n+  {\n+    positivePeriod(period);\n+    long time = date.getTime();\n+    schedule(task, time, period, true);\n+  }\n+\n+  /**\n+   * Schedules the task after the delay milliseconds and reschedules the task\n+   * at a fixed rate every period milliseconds until this timer or the task\n+   * is canceled.\n+   *\n+   * @exception IllegalArgumentException if delay or\n+   * System.currentTimeMillis + delay is negative\n+   * @exception IllegalStateException if the task was already scheduled or\n+   * canceled or this Timer is canceled or the scheduler thread has died\n+   */\n+  public void scheduleAtFixedRate(TimerTask task, long delay, long period)\n+  {\n+    positiveDelay(delay);\n+    positivePeriod(period);\n+    long time = System.currentTimeMillis() + delay;\n+    schedule(task, time, period, true);\n+  }\n+\n+  /**\n+   * Tells the scheduler that the Timer task died\n+   * so there will be no more new tasks scheduled.\n+   */\n+  protected void finalize()\n+  {\n+    queue.setNullOnEmpty(true);\n+  }\n }"}]}