{"sha": "b15e4689e6b6c582c89d57eeb79fedc8b6081aeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE1ZTQ2ODllNmI2YzU4MmM4OWQ1N2VlYjc5ZmVkYzhiNjA4MWFlYg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2016-02-26T17:42:06Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2016-02-26T17:42:06Z"}, "message": "[hsa] Satisfy conditional move operand type constrains\n\n2016-02-26  Martin Jambor  <mjambor@suse.cz>\n\n\t* hsa.h (is_a_helper): New overload for hsa_op_immed for\n\thsa_op_with_type operands.\n\t(hsa_unsigned_type_for_type): Declare.\n\t* hsa.c (hsa_unsigned_type_for_type): New function.\n\t* hsa-gen.c (gen_hsa_binary_operation): Use hsa_unsigned_type_for_type.\n\t(gen_hsa_insns_for_operation_assignment): Satisfy constrains of\n\tthe finalizer.  Do not emit extra move.\n\nFrom-SVN: r233749", "tree": {"sha": "8379ac80524de2a88452679ab20844956ad1fd06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8379ac80524de2a88452679ab20844956ad1fd06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b15e4689e6b6c582c89d57eeb79fedc8b6081aeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b15e4689e6b6c582c89d57eeb79fedc8b6081aeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b15e4689e6b6c582c89d57eeb79fedc8b6081aeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b15e4689e6b6c582c89d57eeb79fedc8b6081aeb/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "02108bb58c6905cc74eb4833067f39f92f5c9a6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02108bb58c6905cc74eb4833067f39f92f5c9a6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02108bb58c6905cc74eb4833067f39f92f5c9a6e"}], "stats": {"total": 58, "additions": 41, "deletions": 17}, "files": [{"sha": "bf03f181b164f7319f1759f15120415a219d1677", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15e4689e6b6c582c89d57eeb79fedc8b6081aeb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15e4689e6b6c582c89d57eeb79fedc8b6081aeb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b15e4689e6b6c582c89d57eeb79fedc8b6081aeb", "patch": "@@ -1,3 +1,13 @@\n+2016-02-26  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* hsa.h (is_a_helper): New overload for hsa_op_immed for\n+\thsa_op_with_type operands.\n+\t(hsa_unsigned_type_for_type): Declare.\n+\t* hsa.c (hsa_unsigned_type_for_type): New function.\n+\t* hsa-gen.c (gen_hsa_binary_operation): Use hsa_unsigned_type_for_type.\n+\t(gen_hsa_insns_for_operation_assignment): Satisfy constrains of\n+\tthe finalizer.  Do not emit extra move.\n+\n 2016-02-26  Martin Jambor  <mjambor@suse.cz>\n \n \t* hsa-gen.c (gen_hsa_ternary_atomic_for_builtin): Fail in presence of"}, {"sha": "be402ddda71e034032892da35a67b6a37e2bdb63", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15e4689e6b6c582c89d57eeb79fedc8b6081aeb/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15e4689e6b6c582c89d57eeb79fedc8b6081aeb/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=b15e4689e6b6c582c89d57eeb79fedc8b6081aeb", "patch": "@@ -3022,7 +3022,7 @@ gen_hsa_binary_operation (int opcode, hsa_op_reg *dest,\n       && is_a <hsa_op_immed *> (op2))\n     {\n       hsa_op_immed *i = dyn_cast <hsa_op_immed *> (op2);\n-      i->set_type (hsa_uint_for_bitsize (hsa_type_bit_size (i->m_type)));\n+      i->set_type (hsa_unsigned_type_for_type (i->m_type));\n     }\n \n   hsa_insn_basic *insn = new hsa_insn_basic (3, opcode, dest->m_type, dest,\n@@ -3233,27 +3233,21 @@ gen_hsa_insns_for_operation_assignment (gimple *assign, hsa_bb *hbb)\n \t    ctrl = r;\n \t  }\n \n-\thsa_op_with_type *rhs2_reg = hsa_reg_or_immed_for_gimple_op (rhs2, hbb);\n-\thsa_op_with_type *rhs3_reg = hsa_reg_or_immed_for_gimple_op (rhs3, hbb);\n-\n-\tBrigType16_t btype = hsa_bittype_for_type (dest->m_type);\n-\thsa_op_reg *tmp = new hsa_op_reg (btype);\n+\thsa_op_with_type *op2 = hsa_reg_or_immed_for_gimple_op (rhs2, hbb);\n+\thsa_op_with_type *op3 = hsa_reg_or_immed_for_gimple_op (rhs3, hbb);\n \n-\trhs2_reg->m_type = btype;\n-\trhs3_reg->m_type = btype;\n+\tBrigType16_t utype = hsa_unsigned_type_for_type (dest->m_type);\n+\tif (is_a <hsa_op_immed *> (op2))\n+\t  op2->m_type = utype;\n+\tif (is_a <hsa_op_immed *> (op3))\n+\t  op3->m_type = utype;\n \n \thsa_insn_basic *insn\n-\t  = new hsa_insn_basic (4, BRIG_OPCODE_CMOV, tmp->m_type, tmp, ctrl,\n-\t\t\t\trhs2_reg, rhs3_reg);\n+\t  = new hsa_insn_basic (4, BRIG_OPCODE_CMOV,\n+\t\t\t\thsa_bittype_for_type (dest->m_type),\n+\t\t\t\tdest, ctrl, op2, op3);\n \n \thbb->append_insn (insn);\n-\n-\t/* As operands of a CMOV insn must be Bx types, we have to emit\n-\t   a conversion insn.  */\n-\thsa_insn_basic *mov = new hsa_insn_basic (2, BRIG_OPCODE_MOV,\n-\t\t\t\t\t\t  dest->m_type, dest, tmp);\n-\thbb->append_insn (mov);\n-\n \treturn;\n       }\n     case COMPLEX_EXPR:"}, {"sha": "9537e295cb52935d9f792e10a19eb52059dae4fc", "filename": "gcc/hsa.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15e4689e6b6c582c89d57eeb79fedc8b6081aeb/gcc%2Fhsa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15e4689e6b6c582c89d57eeb79fedc8b6081aeb/gcc%2Fhsa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa.c?ref=b15e4689e6b6c582c89d57eeb79fedc8b6081aeb", "patch": "@@ -472,6 +472,14 @@ hsa_bittype_for_type (BrigType16_t t)\n   return hsa_bittype_for_bitsize (hsa_type_bit_size (t));\n }\n \n+/* Return HSA unsigned integer type with the same size as the type T.  */\n+\n+BrigType16_t\n+hsa_unsigned_type_for_type (BrigType16_t t)\n+{\n+  return hsa_uint_for_bitsize (hsa_type_bit_size (t));\n+}\n+\n /* Return true if and only if TYPE is a floating point number type.  */\n \n bool"}, {"sha": "275a954f88dee5bd373070dc3ecf1bbe8603b207", "filename": "gcc/hsa.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15e4689e6b6c582c89d57eeb79fedc8b6081aeb/gcc%2Fhsa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15e4689e6b6c582c89d57eeb79fedc8b6081aeb/gcc%2Fhsa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa.h?ref=b15e4689e6b6c582c89d57eeb79fedc8b6081aeb", "patch": "@@ -199,6 +199,17 @@ is_a_helper <hsa_op_immed *>::test (hsa_op_base *p)\n   return p->m_kind == BRIG_KIND_OPERAND_CONSTANT_BYTES;\n }\n \n+/* Likewise, but for a more specified base. */\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <hsa_op_immed *>::test (hsa_op_with_type *p)\n+{\n+  return p->m_kind == BRIG_KIND_OPERAND_CONSTANT_BYTES;\n+}\n+\n+\n /* HSA register operand.  */\n \n class hsa_op_reg : public hsa_op_with_type\n@@ -1326,6 +1337,7 @@ BrigType16_t hsa_bittype_for_bitsize (unsigned bitsize);\n BrigType16_t hsa_uint_for_bitsize (unsigned bitsize);\n BrigType16_t hsa_float_for_bitsize (unsigned bitsize);\n BrigType16_t hsa_bittype_for_type (BrigType16_t t);\n+BrigType16_t hsa_unsigned_type_for_type (BrigType16_t t);\n bool hsa_type_float_p (BrigType16_t type);\n bool hsa_type_integer_p (BrigType16_t type);\n bool hsa_btype_p (BrigType16_t type);"}]}