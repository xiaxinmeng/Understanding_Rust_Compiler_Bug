{"sha": "2be7973ec183d9ee031773b142a25bc14b9fcab5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJlNzk3M2VjMTgzZDllZTAzMTc3M2IxNDJhMjViYzE0YjlmY2FiNQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1997-03-28T22:32:02Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1997-03-28T22:32:02Z"}, "message": "entered into RCS\n\nFrom-SVN: r13809", "tree": {"sha": "831660c5f25018d1fcbf760c48bb54b6bde0b4a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/831660c5f25018d1fcbf760c48bb54b6bde0b4a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2be7973ec183d9ee031773b142a25bc14b9fcab5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2be7973ec183d9ee031773b142a25bc14b9fcab5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2be7973ec183d9ee031773b142a25bc14b9fcab5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2be7973ec183d9ee031773b142a25bc14b9fcab5/comments", "author": null, "committer": null, "parents": [{"sha": "3bc97c561621afe775c96497c11da4fac7229060", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bc97c561621afe775c96497c11da4fac7229060", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bc97c561621afe775c96497c11da4fac7229060"}], "stats": {"total": 344, "additions": 344, "deletions": 0}, "files": [{"sha": "9c6d77da7d4c80a88e45cceeab0cb79e6f5912a1", "filename": "gcc/gcov.texi", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be7973ec183d9ee031773b142a25bc14b9fcab5/gcc%2Fgcov.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be7973ec183d9ee031773b142a25bc14b9fcab5/gcc%2Fgcov.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.texi?ref=2be7973ec183d9ee031773b142a25bc14b9fcab5", "patch": "@@ -0,0 +1,344 @@\n+@c Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+@c This is part of the GCC manual.\n+@c For copying conditions, see the file gcc.texi.\n+\n+@node Gcov\n+@chapter @code{gcov}: a Test Coverage Program\n+\n+@code{gcov} is a tool you can use in conjunction with @sc{gnu} CC to\n+test code coverage in your programs.\n+\n+This chapter describes version 1.5 of @code{gcov}.\n+\n+@menu\n+* Gcov Intro::         \t        Introduction to gcov.\n+* Invoking Gcov::       \tHow to use gcov.\n+* Gcov and Optimization::       Using gcov with GCC optimization.\n+* Gcov Data Files::             The files used by gcov.\n+@end menu\n+\n+@node Gcov Intro\n+@section Introduction to @code{gcov}\n+\n+@code{gcov} is a test coverage program.  Use it in concert with @sc{gnu}\n+CC to analyze your programs to help create more efficient, faster\n+running code.  You can use @code{gcov} as a profiling tool to help\n+discover where your optimization efforts will best affect your code.  You\n+can also use @code{gcov} along with the other profiling tool,\n+@code{gprof}, to assess which parts of your code use the greatest amount\n+of computing time.\n+\n+Profiling tools help you analyze your code's performance.  Using a\n+profiler such as @code{gcov} or @code{gprof}, you can find out some\n+basic performance statistics, such as:\n+\n+@itemize @bullet\n+@item\n+how often each line of code executes\n+\n+@item\n+what lines of code are actually executed\n+\n+@item\n+how much computing time each section of code uses\n+@end itemize\n+\n+Once you know these things about how your code works when compiled, you\n+can look at each module to see which modules should be optimized.\n+@code{gcov} helps you determine where to work on optimization.\n+\n+Software developers also use coverage testing in concert with\n+testsuites, to make sure software is actually good enough for a release.\n+Testsuites can verify that a program works as expected; a coverage\n+program tests to see how much of the program is exercised by the\n+testsuite.  Developers can then determine what kinds of test cases need\n+to be added to the testsuites to create both better testing and a better\n+final product.\n+\n+You should compile your code without optimization if you plan to use\n+@code{gcov} because the optimization, by combining some lines of code\n+into one function, may not give you as much information as you need to\n+look for `hot spots' where the code is using a great deal of computer\n+time.  Likewise, because @code{gcov} accumulates statistics by line (at\n+the lowest resolution), it works best with a programming style that\n+places only one statement on each line.  If you use complicated macros\n+that expand to loops or to other control structures, the statistics are\n+less helpful---they only report on the line where the macro call\n+appears.  If your complex macros behave like functions, you can replace\n+them with inline functions to solve this problem.\n+\n+@code{gcov} creates a logfile called @file{@var{sourcefile}.gcov} which\n+indicates how many times each line of a source file @file{@var{sourcefile}.c}\n+has executed.  You can use these logfiles along with @code{gprof} to aid\n+in fine-tuning the performance of your programs.  @code{gprof} gives\n+timing information you can use along with the information you get from\n+@code{gcov}.\n+\n+@code{gcov} works only on code compiled with @sc{gnu} CC.  It is not\n+compatible with any other profiling or test coverage mechanism.\n+\n+@node Invoking Gcov\n+@section Invoking gcov\n+\n+@smallexample\n+gcov [-b] [-v] [-n] [-l] [-f] [-o directory] @var{sourcefile}\n+@end smallexample\n+\n+@table @code\n+@item -b \n+Write branch frequencies to the output file, and write branch summary\n+info to the standard output.  This option allows you to see how often\n+each branch in your program was taken.\n+\n+@item -v\n+Display the @code{gcov} version number (on the standard error stream).\n+\n+@item -n\n+Do not create the @code{gcov} output file.\n+\n+@item -l\n+Create long file names for included source files.  For example, if the\n+header file @samp{x.h} contains code, and was included in the file\n+@samp{a.c}, then running @code{gcov} on the file @samp{a.c} will produce\n+an output file called @samp{a.c.x.h.gcov} instead of @samp{x.h.gcov}.\n+This can be useful if @samp{x.h} is included in multiple source files.\n+\n+@item -f\n+Output summaries for each function in addition to the file level summary.\n+\n+@item -o\n+The directory where the object files live.  Gcov will search for @code{.bb},\n+@code{.bbg}, and @code{.da} files in this directory.\n+@end table\n+\n+@need 3000\n+When using @code{gcov}, you must first compile your program with two\n+special @sc{gnu} CC options: @samp{-fprofile-arcs -ftest-coverage}.\n+This tells the compiler to generate additional information needed by\n+gcov (basically a flow graph of the program) and also includes\n+additional code in the object files for generating the extra profiling\n+information needed by gcov.  These additional files are placed in the\n+directory where the source code is located.\n+\n+Running the program will cause profile output to be generated.  For each\n+source file compiled with -fprofile-arcs, an accompanying @code{.da}\n+file will be placed in the source directory.\n+\n+Running @code{gcov} with your program's source file names as arguments\n+will now produce a listing of the code along with frequency of execution\n+for each line.  For example, if your program is called @samp{tmp.c}, this\n+is what you see when you use the basic @code{gcov} facility:\n+\n+@smallexample\n+$ gcc -fprofile-arcs -ftest-coverage tmp.c\n+$ a.out\n+$ gcov tmp.c\n+ 87.50% of 8 source lines executed in file tmp.c\n+Creating tmp.c.gcov.\n+@end smallexample\n+\n+The file @file{tmp.c.gcov} contains output from @code{gcov}. \n+Here is a sample:\n+\n+@smallexample\n+                main()\n+                @{\n+           1      int i, total;\n+                \n+           1      total = 0;\n+                \n+          11      for (i = 0; i < 10; i++)\n+          10        total += i;\n+                \n+           1      if (total != 45)\n+      ######        printf (\"Failure\\n\");\n+                  else\n+           1        printf (\"Success\\n\");\n+           1    @}\n+@end smallexample\n+\n+@need 450\n+When you use the @samp{-b} option, your output looks like this:\n+\n+@smallexample\n+$ gcov -b tmp.c\n+ 87.50% of 8 source lines executed in file tmp.c\n+ 80.00% of 5 branches executed in file tmp.c\n+ 80.00% of 5 branches taken at least once in file tmp.c\n+ 50.00% of 2 calls executed in file tmp.c\n+Creating tmp.c.gcov.\n+@end smallexample\n+\n+Here is a sample of a resulting @file{tmp.c.gcov} file:\n+\n+@smallexample\n+                main()\n+                @{\n+           1      int i, total;\n+                \n+           1      total = 0;\n+                \n+          11      for (i = 0; i < 10; i++)\n+branch 0 taken = 91%\n+branch 1 taken = 100%\n+branch 2 taken = 100%\n+          10        total += i;\n+                \n+           1      if (total != 45)\n+branch 0 taken = 100%\n+      ######        printf (\"Failure\\n\");\n+call 0 never executed\n+branch 1 never executed\n+                  else\n+           1        printf (\"Success\\n\");\n+call 0 returns = 100%\n+           1    @}\n+@end smallexample\n+\n+For each basic block, a line is printed after the last line of the basic\n+block describing the branch or call that ends the basic block.  There can\n+be multiple branches and calls listed for a single source line if there\n+are multiple basic blocks that end on that line.  In this case, the\n+branches and calls are each given a number.  There is no simple way to map\n+these branches and calls back to source constructs.  In general, though,\n+the lowest numbered branch or call will correspond to the leftmost construct\n+on the source line.\n+\n+For a branch, if it was executed at least once, then a percentage\n+indicating the number of times the branch was taken divided by the\n+number of times the branch was executed will be printed.  Otherwise, the\n+message ``never executed'' is printed.\n+\n+For a call, if it was executed at least once, then a percentage\n+indicating the number of times the call returned divided by the number\n+of times the call was executed will be printed.  This will usually be\n+100%, but may be less for functions call @code{exit} or @code{longjmp},\n+and thus may not return everytime they are called.\n+\n+The execution counts are cumulative.  If the example program were\n+executed again without removing the @code{.da} file, the count for the\n+number of times each line in the source was executed would be added to\n+the results of the previous run(s).  This is potentially useful in\n+several ways.  For example, it could be used to accumulate data over a\n+number of program runs as part of a test verification suite, or to\n+provide more accurate long-term information over a large number of\n+program runs.\n+\n+The data in the @code{.da} files is saved immediately before the program\n+exits.  For each source file compiled with -fprofile-arcs, the profiling\n+code first attempts to read in an existing @code{.da} file; if the file\n+doesn't match the executable (differing number of basic block counts) it\n+will ignore the contents of the file.  It then adds in the new execution\n+counts and finally writes the data to the file.\n+\n+@node Gcov and Optimization\n+@section Using @code{gcov} with GCC Optimization\n+\n+If you plan to use @code{gcov} to help optimize your code, you must\n+first compile your program with two special @sc{gnu} CC options:\n+@samp{-fprofile-arcs -ftest-coverage}.  Aside from that, you can use any\n+other @sc{gnu} CC options; but if you want to prove that every single line\n+in your program was executed, you should not compile with optimization\n+at the same time.  On some machines the optimizer can eliminate some\n+simple code lines by combining them with other lines.  For example, code\n+like this:\n+\n+@smallexample\n+if (a != b)\n+  c = 1;\n+else\n+  c = 0;\n+@end smallexample\n+\n+@noindent\n+can be compiled into one instruction on some machines.  In this case,\n+there is no way for @code{gcov} to calculate separate execution counts\n+for each line because there isn't separate code for each line.  Hence\n+the @code{gcov} output looks like this if you compiled the program with\n+optimization:\n+\n+@smallexample\n+      100  if (a != b)\n+      100    c = 1;\n+      100  else\n+      100    c = 0;\n+@end smallexample\n+\n+The output shows that this block of code, combined by optimization,\n+executed 100 times.  In one sense this result is correct, because there\n+was only one instruction representing all four of these lines.  However,\n+the output does not indicate how many times the result was 0 and how\n+many times the result was 1.\n+\n+@node Gcov Data Files\n+@section Brief description of @code{gcov} data files\n+\n+@code{gcov} uses three files for doing profiling.  The names of these\n+files are derived from the original @emph{source} file by substituting\n+the file suffix with either @code{.bb}, @code{.bbg}, or @code{.da}.  All\n+of these files are placed in the same directory as the source file, and\n+contain data stored in a platform-independent method.\n+\n+The @code{.bb} and @code{.bbg} files are generated when the source file\n+is compiled with the @sc{gnu} CC @samp{-ftest-coverage} option.  The\n+@code{.bb} file contains a list of source files (including headers),\n+functions within those files, and line numbers corresponding to each\n+basic block in the source file.\n+\n+The @code{.bb} file format consists of several lists of 4-byte integers\n+which correspond to the line numbers of each basic block in the\n+file.  Each list is terminated by a line number of 0.  A line number of -1\n+is used to designate that the source file name (padded to a 4-byte\n+boundary and followed by another -1) follows.  In addition, a line number\n+of -2 is used to designate that the name of a function (also padded to a\n+4-byte boundary and followed by a -2) follows.\n+\n+The @code{.bbg} file is used to reconstruct the program flow graph for\n+the source file.  It contains a list of the program flow arcs (possible\n+branches taken from one basic block to another) for each function which,\n+in combination with the @code{.bb} file, enables gcov to reconstruct the\n+program flow.\n+\n+In the @code{.bbg} file, the format is:\n+@smallexample\n+        number of basic blocks for function #0 (4-byte number)\n+        total number of arcs for function #0 (4-byte number)\n+        count of arcs in basic block #0 (4-byte number)\n+        destination basic block of arc #0 (4-byte number)\n+        flag bits (4-byte number)\n+        destination basic block of arc #1 (4-byte number)\n+        flag bits (4-byte number)\n+        ...\n+        destination basic block of arc #N (4-byte number)\n+        flag bits (4-byte number)\n+        count of arcs in basic block #1 (4-byte number)\n+        destination basic block of arc #0 (4-byte number)\n+        flag bits (4-byte number)\n+        ...\n+@end smallexample\n+\n+A -1 (stored as a 4-byte number) is used to separate each function's\n+list of basic blocks, and to verify that the file has been read\n+correctly.\n+\n+The @code{.da} file is generated when a program containing object files\n+built with the @sc{gnu} CC @samp{-fprofile-arcs} option is executed.  A\n+separate @code{.da} file is created for each source file compiled with\n+this option, and the name of the @code{.da} file is stored as an\n+absolute pathname in the resulting object file.  This path name is\n+derived from the source file name by substituting a @code{.da} suffix.\n+\n+The format of the @code{.da} file is fairly simple.  The first 8-byte\n+number is the number of counts in the file, followed by the counts\n+(stored as 8-byte numbers).  Each count corresponds to the number of\n+times each arc in the program is executed.  The counts are cumulative;\n+each time the program is executed, it attemps to combine the existing\n+@code{.da} files with the new counts for this invocation of the\n+program.  It ignores the contents of any @code{.da} files whose number of\n+arcs doesn't correspond to the current program, and merely overwrites\n+them instead.\n+\n+All three of these files use the functions in @code{gcov-io.h} to store\n+integers; the functions in this header provide a machine-independent\n+mechanism for storing and retrieving data from a stream.\n+"}]}