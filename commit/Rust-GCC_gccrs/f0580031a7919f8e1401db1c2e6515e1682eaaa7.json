{"sha": "f0580031a7919f8e1401db1c2e6515e1682eaaa7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA1ODAwMzFhNzkxOWY4ZTE0MDFkYjFjMmU2NTE1ZTE2ODJlYWFhNw==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2008-09-23T13:51:58Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2008-09-23T13:51:58Z"}, "message": "re PR libgcj/8995 (race cases in interpreter)\n\n2008-09-17  Andrew Haley  <aph@redhat.com>\n\n        PR libgcj/8995:\n\n        * defineclass.cc (_Jv_ClassReader::handleCodeAttribute):\n        Initialize thread_count.\n        * include/java-interp.h (_Jv_InterpMethod::thread_count): New\n        field.\n         (_Jv_InterpMethod::rewrite_insn_mutex): New mutex.\n        (_Jv_InterpFrame:: _Jv_InterpFrame): Pass frame_type.\n        * interpret.cc\n        (ThreadCountAdjuster): New class.\n        (_Jv_InterpMethod::thread_count): New field.\n        (_Jv_InitInterpreter): Initialize rewrite_insn_mutex.\n        Increment and decrement thread_count field in methods.\n        * interpret-run.cc (REWRITE_INSN): Check thread_count <= 1.\n        (REWRITE_INSN): Likewise.\n        Declare a ThreadCountAdjuster.\n        * java/lang/reflect/natVMProxy.cc (run_proxy): Initialize frame\n        type as frame_proxy.\n\nFrom-SVN: r140593", "tree": {"sha": "5aa7ac0da62ededbaab14350de950b012a5759a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5aa7ac0da62ededbaab14350de950b012a5759a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0580031a7919f8e1401db1c2e6515e1682eaaa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0580031a7919f8e1401db1c2e6515e1682eaaa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0580031a7919f8e1401db1c2e6515e1682eaaa7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0580031a7919f8e1401db1c2e6515e1682eaaa7/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5c0466b537af28f3cf7aff8d29c884a3c5725459", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c0466b537af28f3cf7aff8d29c884a3c5725459", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c0466b537af28f3cf7aff8d29c884a3c5725459"}], "stats": {"total": 186, "additions": 155, "deletions": 31}, "files": [{"sha": "4bf454731af4d9a44e83c9d7319d4326e3402155", "filename": "libjava/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0580031a7919f8e1401db1c2e6515e1682eaaa7/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0580031a7919f8e1401db1c2e6515e1682eaaa7/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f0580031a7919f8e1401db1c2e6515e1682eaaa7", "patch": "@@ -1,3 +1,24 @@\n+2008-09-17  Andrew Haley  <aph@redhat.com>\n+\n+\tPR libgcj/8995:\n+\t\n+\t* defineclass.cc (_Jv_ClassReader::handleCodeAttribute):\n+\tInitialize thread_count.\n+\t* include/java-interp.h (_Jv_InterpMethod::thread_count): New\n+\tfield.\n+\t (_Jv_InterpMethod::rewrite_insn_mutex): New mutex.\n+\t(_Jv_InterpFrame:: _Jv_InterpFrame): Pass frame_type.\n+\t* interpret.cc\n+\t(ThreadCountAdjuster): New class.\n+\t(_Jv_InterpMethod::thread_count): New field.\n+\t(_Jv_InitInterpreter): Initialize rewrite_insn_mutex.\n+\tIncrement and decrement thread_count field in methods.\n+\t* interpret-run.cc (REWRITE_INSN): Check thread_count <= 1.\n+\t(REWRITE_INSN): Likewise.\n+\tDeclare a ThreadCountAdjuster.\n+\t* java/lang/reflect/natVMProxy.cc (run_proxy): Initialize frame\n+\ttype as frame_proxy.\n+\n 2008-09-05  David Daney  <ddaney@avtrex.com>\n \n \t* configure.ac (reduced-reflection): New AC_ARG_ENABLE."}, {"sha": "4c4e0a7f45de396a6ea093d65c26e40600fffb19", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0580031a7919f8e1401db1c2e6515e1682eaaa7/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0580031a7919f8e1401db1c2e6515e1682eaaa7/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=f0580031a7919f8e1401db1c2e6515e1682eaaa7", "patch": "@@ -1682,7 +1682,9 @@ void _Jv_ClassReader::handleCodeAttribute\n   method->prepared       = NULL;\n   method->line_table_len = 0;\n   method->line_table     = NULL;\n-\n+#ifdef DIRECT_THREADED\n+  method->thread_count   = 0;\n+#endif\n \n   // grab the byte code!\n   memcpy ((void*) method->bytecode (),"}, {"sha": "c088e9f010db3baadfbc83307a204c2019c1a8b2", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 84, "deletions": 2, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0580031a7919f8e1401db1c2e6515e1682eaaa7/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0580031a7919f8e1401db1c2e6515e1682eaaa7/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=f0580031a7919f8e1401db1c2e6515e1682eaaa7", "patch": "@@ -175,6 +175,17 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n   static pc_t breakpoint_insn;\n #ifdef DIRECT_THREADED\n   static insn_slot bp_insn_slot;\n+\n+public:\n+  // Mutex to prevent a data race between threads when rewriting\n+  // instructions.  See interpret-run.cc for an explanation of its use.\n+  static _Jv_Mutex_t rewrite_insn_mutex;\n+\n+  // The count of threads executing this method.\n+  long thread_count;\n+\n+private:\n+\n #else\n   static unsigned char bp_insn_opcode;\n #endif\n@@ -455,9 +466,10 @@ class _Jv_InterpFrame : public _Jv_Frame\n   jobject obj_ptr;\n \n   _Jv_InterpFrame (void *meth, java::lang::Thread *thr, jclass proxyCls = NULL,\n-                   pc_t *pc = NULL)\n+                   pc_t *pc = NULL, \n+\t\t   _Jv_FrameType frame_type = frame_interpreter)\n   : _Jv_Frame (reinterpret_cast<_Jv_MethodBase *> (meth), thr,\n-\t             frame_interpreter)\n+\t             frame_type)\n   {\n     next_interp = (_Jv_InterpFrame *) thr->interp_frame;\n     proxyClass = proxyCls;\n@@ -501,6 +513,76 @@ class _Jv_NativeFrame : public _Jv_Frame\n   }\n };\n \n+#ifdef DIRECT_THREADED\n+// This class increments and decrements the thread_count field in an\n+// interpreted method.  On entry to the interpreter a\n+// ThreadCountAdjuster is created when increments the thread_count in\n+// the current method and uses the next_interp field in the frame to\n+// find the previous method and decrement its thread_count.\n+class ThreadCountAdjuster\n+{\n+\n+  // A class used to handle the rewrite_insn_mutex while we're\n+  // adjusting the thread_count in a method.  Unlocking the mutex in a\n+  // destructor ensures that it's unlocked even if (for example) a\n+  // segfault occurs in the critical section.\n+  class MutexLock\n+  {\n+  private:\n+    _Jv_Mutex_t *mutex;\n+  public:\n+    MutexLock (_Jv_Mutex_t *m)\n+    {\n+      mutex = m;\n+      _Jv_MutexLock (mutex);\n+    }\n+    ~MutexLock ()\n+    {\n+      _Jv_MutexUnlock (mutex);\n+    }\n+  };\n+\n+  _Jv_InterpMethod *method;\n+  _Jv_InterpMethod *next_method;\n+\n+public:\n+\n+  ThreadCountAdjuster (_Jv_InterpMethod *m, _Jv_InterpFrame *fr)\n+  {\n+    MutexLock lock (&::_Jv_InterpMethod::rewrite_insn_mutex);\n+\n+    method = m;\n+    next_method = NULL;\n+\n+    _Jv_InterpFrame *next_interp = fr->next_interp;\n+\n+    // Record the fact that we're executing this method and that\n+    // we're no longer executing the method that called us.\n+    method->thread_count++;\n+\n+    if (next_interp && next_interp->frame_type == frame_interpreter)\n+      {\n+\tnext_method \n+\t  = reinterpret_cast<_Jv_InterpMethod *> (next_interp->meth);\n+\tnext_method->thread_count--;\n+      }\n+  }\n+\n+  ~ThreadCountAdjuster ()\n+  {\n+    MutexLock lock (&::_Jv_InterpMethod::rewrite_insn_mutex);\n+\n+    // We're going to return to the method that called us, so bump its\n+    // thread_count and decrement our own.\n+\n+    method->thread_count--;\n+\n+    if (next_method)\n+      next_method->thread_count++;\n+  }\n+};\n+#endif // DIRECT_THREADED\n+\n #endif /* INTERPRETER */\n \n #endif /* __JAVA_INTERP_H__ */"}, {"sha": "059195360edaec7232b34cea9243a0a6557a3644", "filename": "libjava/interpret-run.cc", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0580031a7919f8e1401db1c2e6515e1682eaaa7/libjava%2Finterpret-run.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0580031a7919f8e1401db1c2e6515e1682eaaa7/libjava%2Finterpret-run.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret-run.cc?ref=f0580031a7919f8e1401db1c2e6515e1682eaaa7", "patch": "@@ -29,6 +29,10 @@ details.  */\n   _Jv_InterpFrame frame_desc (meth, thread);\n #endif\n \n+#ifdef DIRECT_THREADED\n+  ThreadCountAdjuster adj (meth, &frame_desc);\n+#endif // DIRECT_THREADED\n+\n   _Jv_word stack[meth->max_stack];\n   _Jv_word *sp = stack;\n \n@@ -361,20 +365,29 @@ details.  */\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n+// We fail to rewrite a breakpoint if there is another thread\n+// currently executing this method.  This is a bug, but there's\n+// nothing else we can do that doesn't cause a data race.\n #undef REWRITE_INSN\n #define REWRITE_INSN(INSN,SLOT,VALUE)\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (pc[-2].insn == breakpoint_insn->insn)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tusing namespace ::gnu::gcj::jvmti;\t\t\t\t\\\n-\tjlocation location = meth->insn_index (pc - 2);\t\t\t\\\n-\t_Jv_RewriteBreakpointInsn (meth->self, location, (pc_t) INSN);\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      pc[-2].insn = INSN;\t\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _Jv_MutexLock (&rewrite_insn_mutex);\t\t\t\t\\\n+      if (meth->thread_count <= 1)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (pc[-2].insn == breakpoint_insn->insn)\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      using namespace ::gnu::gcj::jvmti;\t\t\t\\\n+\t      jlocation location = meth->insn_index (pc - 2);\t\t\\\n+\t      _Jv_RewriteBreakpointInsn (meth->self, location, (pc_t) INSN); \\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    pc[-2].insn = INSN;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    pc[-1].SLOT = VALUE;\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n+\t  pc[-1].SLOT = VALUE;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      _Jv_MutexUnlock (&rewrite_insn_mutex);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n #undef INTERP_REPORT_EXCEPTION\n@@ -383,23 +396,23 @@ details.  */\n #undef NEXT_INSN\n #define NEXT_INSN goto *((pc++)->insn)\n \n-// REWRITE_INSN does nothing.\n-//\n // Rewriting a multi-word instruction in the presence of multiple\n-// threads leads to a data race if a thread reads part of an\n-// instruction while some other thread is rewriting that instruction.\n-// For example, an invokespecial instruction may be rewritten to\n-// invokespecial_resolved and its operand changed from an index to a\n-// pointer while another thread is executing invokespecial.  This\n-// other thread then reads the pointer that is now the operand of\n-// invokespecial_resolved and tries to use it as an index.\n-//\n-// Fixing this requires either spinlocks, a more elaborate data\n-// structure, or even per-thread allocated pages.  It's clear from the\n-// locking in meth->compile below that the presence of multiple\n-// threads was contemplated when this code was written, but the full\n-// consequences were not fully appreciated.\n-#define REWRITE_INSN(INSN,SLOT,VALUE)\n+// threads is a data race if a thread reads part of an instruction\n+// while some other thread is rewriting that instruction.  We detect\n+// more than one thread executing a method and don't rewrite the\n+// instruction.  A thread entering a method blocks on\n+// rewrite_insn_mutex until the write is complete.\n+#define REWRITE_INSN(INSN,SLOT,VALUE)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    _Jv_MutexLock (&rewrite_insn_mutex);\t\\\n+    if (meth->thread_count <= 1)\t\t\\\n+      {\t\t\t\t\t\t\\\n+\tpc[-2].insn = INSN;\t\t\t\\\n+\tpc[-1].SLOT = VALUE;\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+    _Jv_MutexUnlock (&rewrite_insn_mutex);\t\\\n+  }\t\t\t\t\t\t\\\n+  while (0)\n \n #undef INTERP_REPORT_EXCEPTION\n #define INTERP_REPORT_EXCEPTION(Jthrowable) /* not needed when not debugging */"}, {"sha": "dc1114f65f1f30cebde85238ce0bd3ec6d46c3be", "filename": "libjava/interpret.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0580031a7919f8e1401db1c2e6515e1682eaaa7/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0580031a7919f8e1401db1c2e6515e1682eaaa7/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=f0580031a7919f8e1401db1c2e6515e1682eaaa7", "patch": "@@ -78,10 +78,15 @@ static void find_catch_location (jthrowable, jthread, jmethodID *, jlong *);\n // the Class monitor as user code in another thread could hold it.\n static _Jv_Mutex_t compile_mutex;\n \n+// See class ThreadCountAdjuster and REWRITE_INSN for how this is\n+// used.\n+_Jv_Mutex_t _Jv_InterpMethod::rewrite_insn_mutex;\n+\n void\n _Jv_InitInterpreter()\n {\n   _Jv_MutexInit (&compile_mutex);\n+  _Jv_MutexInit (&_Jv_InterpMethod::rewrite_insn_mutex);\n }\n #else\n void _Jv_InitInterpreter() {}"}, {"sha": "4c3fd74f91c6d359064450077d4010c2c9120e2c", "filename": "libjava/java/lang/reflect/natVMProxy.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0580031a7919f8e1401db1c2e6515e1682eaaa7/libjava%2Fjava%2Flang%2Freflect%2FnatVMProxy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0580031a7919f8e1401db1c2e6515e1682eaaa7/libjava%2Fjava%2Flang%2Freflect%2FnatVMProxy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatVMProxy.cc?ref=f0580031a7919f8e1401db1c2e6515e1682eaaa7", "patch": "@@ -350,7 +350,8 @@ run_proxy (ffi_cif *cif,\n   // than about Proxy.class itself.  FRAME_DESC has a destructor so it\n   // cleans up automatically when this proxy invocation returns.\n   Thread *thread = Thread::currentThread();\n-  _Jv_InterpFrame frame_desc (self->self, thread, proxyClass);\n+  _Jv_InterpFrame frame_desc (self->self, thread, proxyClass,\n+\t\t\t      NULL, frame_proxy);\n \n   // The method to invoke is saved in $Proxy0.m[method_index].\n   // FIXME: We could somewhat improve efficiency by storing a pointer"}]}