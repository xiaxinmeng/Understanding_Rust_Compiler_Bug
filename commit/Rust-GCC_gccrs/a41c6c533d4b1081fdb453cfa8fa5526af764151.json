{"sha": "a41c6c533d4b1081fdb453cfa8fa5526af764151", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQxYzZjNTMzZDRiMTA4MWZkYjQ1M2NmYThmYTU1MjZhZjc2NDE1MQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2002-09-16T14:13:12Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2002-09-16T14:13:12Z"}, "message": "s390.c: (legitimize_la_operand): Remove, replace by ...\n\n\t* config/s390/s390.c: (legitimize_la_operand): Remove, replace by ...\n\t(s390_load_address): ... this new function.\n\t(s390_decompose_address): Allow the argument pointer and all\n\tvirtual registers as 'pointer' registers.\n\t(s390_expand_plus_operand): Use s390_load_address.\n\tconfig/s390/s390.md (movti, movdi, movdf splitters): Likewise.\n\t(\"force_la_31\"): New insn pattern.\n\tconfig/s390/s390-protos.h (legitimize_la_operand): Remove.\n\t(s390_load_address): Add prototype.\n\n\t* config/s390/s390.c: Include \"optabs.h\".\n\t(s390_expand_movstr, s390_expand_clrstr, s390_expand_cmpstr): New.\n\tconfig/s390/s390-protos.h (s390_expand_movstr, s390_expand_clrstr,\n\ts390_expand_cmpstr): Add prototypes.\n\tconfig/s390/s390.md (\"movstrdi\", \"movstrsi\"): Call s390_expand_movstr.\n\t(\"movstrdi_short\"): Rename to \"movstr_short_64\".  Change predicates\n\tfor operands 0 and 1 to \"memory_operand\".  Add type attribute.\n\t(\"movstrsi_short\"): Rename to \"movstr_short_31\".  Change predicates\n\tfor operands 0 and 1 to \"memory_operand\".  Add type attribute.\n\t(\"movstrdi_long\", \"movstrsi_long\"): Remove.\n\t(\"movstrdi_64\"): Rename to \"movstr_long_64\". Add type attribute.\n\t(\"movstrsi_31\"): Rename to \"movstr_long_31\". Add type attribute.\n\t(\"clrstrdi\", \"clrstrsi\"): Call s390_expand_clrstr.\n\t(\"clrstrsico\"): Remove, replace by ...\n\t(\"clrstr_short_64\", \"clrstr_short_31\"): ... these new patterns.\n\t(\"clrstrsi_64\"): Rename to \"clrstr_long_64\".\n\t(\"clrstrsi_31\"): Rename to \"clrstr_long_31\".\n\t(\"cmpstrdi\", \"cmpstrsi\"): Call s390_expand_cmpstr.\n\t(\"cmpstr_const\"): Remove, replace by ...\n\t(\"cmpstr_short_64\", \"cmpstr_short_31\"): ... these new patterns.\n\t(\"cmpstr_64\"): Rename to \"cmpstr_long_64\".\n\t(\"cmpstr_31\"): Rename to \"cmpstr_long_31\".\n\nFrom-SVN: r57191", "tree": {"sha": "a83ab7a7dbef43d5e69a4f7b11903ad532081100", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a83ab7a7dbef43d5e69a4f7b11903ad532081100"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a41c6c533d4b1081fdb453cfa8fa5526af764151", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a41c6c533d4b1081fdb453cfa8fa5526af764151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a41c6c533d4b1081fdb453cfa8fa5526af764151", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a41c6c533d4b1081fdb453cfa8fa5526af764151/comments", "author": null, "committer": null, "parents": [{"sha": "2a4ecff3cb06cb624dbe48b5d42f60e85dd9506b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a4ecff3cb06cb624dbe48b5d42f60e85dd9506b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a4ecff3cb06cb624dbe48b5d42f60e85dd9506b"}], "stats": {"total": 1023, "additions": 553, "deletions": 470}, "files": [{"sha": "b9611076c32e0267e03c10a3bb2e949c21c0967c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41c6c533d4b1081fdb453cfa8fa5526af764151/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41c6c533d4b1081fdb453cfa8fa5526af764151/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a41c6c533d4b1081fdb453cfa8fa5526af764151", "patch": "@@ -1,3 +1,38 @@\n+2002-09-16  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.c: (legitimize_la_operand): Remove, replace by ...\n+\t(s390_load_address): ... this new function.\n+\t(s390_decompose_address): Allow the argument pointer and all\n+\tvirtual registers as 'pointer' registers.\n+\t(s390_expand_plus_operand): Use s390_load_address.\n+\tconfig/s390/s390.md (movti, movdi, movdf splitters): Likewise.\n+\t(\"force_la_31\"): New insn pattern.\n+\tconfig/s390/s390-protos.h (legitimize_la_operand): Remove.\n+\t(s390_load_address): Add prototype.\n+\n+\t* config/s390/s390.c: Include \"optabs.h\".\n+\t(s390_expand_movstr, s390_expand_clrstr, s390_expand_cmpstr): New.\n+\tconfig/s390/s390-protos.h (s390_expand_movstr, s390_expand_clrstr, \n+\ts390_expand_cmpstr): Add prototypes.\n+\tconfig/s390/s390.md (\"movstrdi\", \"movstrsi\"): Call s390_expand_movstr.\n+\t(\"movstrdi_short\"): Rename to \"movstr_short_64\".  Change predicates\n+\tfor operands 0 and 1 to \"memory_operand\".  Add type attribute.\n+\t(\"movstrsi_short\"): Rename to \"movstr_short_31\".  Change predicates\n+\tfor operands 0 and 1 to \"memory_operand\".  Add type attribute.\n+\t(\"movstrdi_long\", \"movstrsi_long\"): Remove.\n+\t(\"movstrdi_64\"): Rename to \"movstr_long_64\". Add type attribute.\n+\t(\"movstrsi_31\"): Rename to \"movstr_long_31\". Add type attribute.\n+\t(\"clrstrdi\", \"clrstrsi\"): Call s390_expand_clrstr.\n+\t(\"clrstrsico\"): Remove, replace by ...\n+\t(\"clrstr_short_64\", \"clrstr_short_31\"): ... these new patterns.\n+\t(\"clrstrsi_64\"): Rename to \"clrstr_long_64\".\n+\t(\"clrstrsi_31\"): Rename to \"clrstr_long_31\".\n+\t(\"cmpstrdi\", \"cmpstrsi\"): Call s390_expand_cmpstr.\n+\t(\"cmpstr_const\"): Remove, replace by ...\n+\t(\"cmpstr_short_64\", \"cmpstr_short_31\"): ... these new patterns.\n+\t(\"cmpstr_64\"): Rename to \"cmpstr_long_64\".\n+\t(\"cmpstr_31\"): Rename to \"cmpstr_long_31\".\n+\n 2002-09-16  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* ABOUT-NLS: Follow spelling conventions."}, {"sha": "c66207ad0727b46e5507842ab3b9621631334705", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41c6c533d4b1081fdb453cfa8fa5526af764151/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41c6c533d4b1081fdb453cfa8fa5526af764151/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=a41c6c533d4b1081fdb453cfa8fa5526af764151", "patch": "@@ -49,7 +49,6 @@ extern enum machine_mode s390_tm_ccmode PARAMS ((rtx, rtx, int));\n extern enum machine_mode s390_select_ccmode PARAMS ((enum rtx_code, rtx, rtx));\n extern int symbolic_reference_mentioned_p PARAMS ((rtx));\n extern int legitimate_la_operand_p PARAMS ((rtx));\n-extern rtx legitimize_la_operand PARAMS ((rtx));\n extern int legitimate_pic_operand_p PARAMS ((rtx));\n extern int legitimate_constant_p PARAMS ((rtx));\n extern int legitimate_reload_constant_p PARAMS ((rtx));\n@@ -61,6 +60,10 @@ extern enum reg_class s390_secondary_input_reload_class PARAMS ((enum reg_class,\n extern int s390_plus_operand PARAMS ((rtx, enum machine_mode));\n extern void s390_expand_plus_operand PARAMS ((rtx, rtx, rtx));\n extern void emit_pic_move PARAMS ((rtx *, enum machine_mode));\n+extern void s390_load_address PARAMS ((rtx, rtx));\n+extern void s390_expand_movstr PARAMS ((rtx, rtx, rtx));\n+extern void s390_expand_clrstr PARAMS ((rtx, rtx));\n+extern void s390_expand_cmpstr PARAMS ((rtx, rtx, rtx, rtx));\n \n extern void s390_output_symbolic_const PARAMS ((FILE *, rtx));\n extern void print_operand_address PARAMS ((FILE *, rtx));"}, {"sha": "549f3171e4e7dc0efab9871ce7283fab912b042f", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 325, "deletions": 24, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41c6c533d4b1081fdb453cfa8fa5526af764151/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41c6c533d4b1081fdb453cfa8fa5526af764151/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=a41c6c533d4b1081fdb453cfa8fa5526af764151", "patch": "@@ -46,6 +46,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"target-def.h\"\n #include \"debug.h\"\n #include \"langhooks.h\"\n+#include \"optabs.h\"\n \n static bool s390_assemble_integer PARAMS ((rtx, unsigned int, int));\n static int s390_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n@@ -1458,8 +1459,7 @@ s390_expand_plus_operand (target, src, scratch)\n   /* Emit the LOAD ADDRESS pattern.  Note that reload of PLUS\n      is only ever performed on addresses, so we can mark the\n      sum as legitimate for LA in any case.  */\n-  src = legitimize_la_operand (src);\n-  emit_insn (gen_rtx_SET (VOIDmode, target, src));\n+  s390_load_address (target, src);\n }\n \n \n@@ -1548,6 +1548,9 @@ s390_decompose_address (addr, out)\n \t  || ((reload_completed || reload_in_progress)\n \t      && frame_pointer_needed\n \t      && REGNO (base) == HARD_FRAME_POINTER_REGNUM)\n+\t  || REGNO (base) == ARG_POINTER_REGNUM\n+\t  || (REGNO (base) >= FIRST_VIRTUAL_REGISTER\n+\t      && REGNO (base) <= LAST_VIRTUAL_REGISTER)\n           || (flag_pic\n               && REGNO (base) == PIC_OFFSET_TABLE_REGNUM))\n         pointer = TRUE;\n@@ -1573,6 +1576,9 @@ s390_decompose_address (addr, out)\n \t  || ((reload_completed || reload_in_progress)\n \t      && frame_pointer_needed\n \t      && REGNO (indx) == HARD_FRAME_POINTER_REGNUM)\n+\t  || REGNO (indx) == ARG_POINTER_REGNUM\n+\t  || (REGNO (indx) >= FIRST_VIRTUAL_REGISTER\n+\t      && REGNO (indx) <= LAST_VIRTUAL_REGISTER)\n           || (flag_pic\n               && REGNO (indx) == PIC_OFFSET_TABLE_REGNUM))\n         pointer = TRUE;\n@@ -1737,30 +1743,19 @@ legitimate_la_operand_p (op)\n   return FALSE;\n }\n \n-/* Return a modified variant of OP that is guaranteed to\n-   be accepted by legitimate_la_operand_p.  */\n+/* Emit a forced load-address operation to load SRC into DST.\n+   This will use the LOAD ADDRESS instruction even in situations\n+   where legitimate_la_operand_p (SRC) returns false.  */\n \n-rtx\n-legitimize_la_operand (op)\n-     register rtx op;\n+void\n+s390_load_address (dst, src)\n+     rtx dst;\n+     rtx src;\n {\n-  struct s390_address addr;\n-  if (!s390_decompose_address (op, &addr))\n-    abort ();\n-\n-  if (TARGET_64BIT || addr.pointer)\n-    return op;\n-\n-  if (!addr.base)\n-    abort ();\n-\n-  op = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr.base), 101);\n-  if (addr.indx)\n-    op = gen_rtx_PLUS (Pmode, op, addr.indx);\n-  if (addr.disp)\n-    op = gen_rtx_PLUS (Pmode, op, addr.disp);\n-\n-  return op; \n+  if (TARGET_64BIT)\n+    emit_move_insn (dst, src);\n+  else\n+    emit_insn (gen_force_la_31 (dst, src));\n }\n \n /* Return a legitimate reference for ORIG (an address) using the\n@@ -2148,6 +2143,312 @@ legitimize_address (x, oldx, mode)\n   return x;\n }\n \n+/* Emit code to move LEN bytes from DST to SRC.  */\n+\n+void\n+s390_expand_movstr (dst, src, len)\n+     rtx dst;\n+     rtx src;\n+     rtx len;\n+{\n+  rtx (*gen_short) PARAMS ((rtx, rtx, rtx)) = \n+    TARGET_64BIT ? gen_movstr_short_64 : gen_movstr_short_31;\n+  rtx (*gen_long) PARAMS ((rtx, rtx, rtx, rtx)) = \n+    TARGET_64BIT ? gen_movstr_long_64 : gen_movstr_long_31;\n+\n+\n+  if (GET_CODE (len) == CONST_INT && INTVAL (len) >= 0 && INTVAL (len) <= 256)\n+    {\n+      if (INTVAL (len) > 0)\n+        emit_insn ((*gen_short) (dst, src, GEN_INT (INTVAL (len) - 1)));\n+    }\n+\n+  else if (TARGET_MVCLE)\n+    {\n+      enum machine_mode double_mode = TARGET_64BIT ? TImode : DImode;\n+      enum machine_mode single_mode = TARGET_64BIT ? DImode : SImode;\n+      rtx reg0 = gen_reg_rtx (double_mode);\n+      rtx reg1 = gen_reg_rtx (double_mode);\n+\n+      emit_move_insn (gen_highpart (single_mode, reg0), \n+\t\t      force_operand (XEXP (dst, 0), NULL_RTX));\n+      emit_move_insn (gen_highpart (single_mode, reg1), \n+\t\t      force_operand (XEXP (src, 0), NULL_RTX));\n+\n+      convert_move (gen_lowpart (single_mode, reg0), len, 1);\n+      convert_move (gen_lowpart (single_mode, reg1), len, 1);\n+\n+      emit_insn ((*gen_long) (reg0, reg1, reg0, reg1));\n+    }\n+\n+  else\n+    {\n+      rtx dst_addr, src_addr, count, blocks, temp;\n+      rtx end_label = gen_label_rtx ();\n+      enum machine_mode mode;\n+      tree type;\n+\n+      mode = GET_MODE (len);\n+      if (mode == VOIDmode)\n+        mode = word_mode;\n+\n+      type = (*lang_hooks.types.type_for_mode) (mode, 1);\n+      if (!type)\n+        abort ();\n+\n+      dst_addr = gen_reg_rtx (Pmode);\n+      src_addr = gen_reg_rtx (Pmode);\n+      count = gen_reg_rtx (mode);\n+      blocks = gen_reg_rtx (mode);\n+\n+      convert_move (count, len, 1);\n+      emit_cmp_and_jump_insns (count, const0_rtx, \n+\t\t\t       EQ, NULL_RTX, mode, 1, end_label);\n+\n+      emit_move_insn (dst_addr, force_operand (XEXP (dst, 0), NULL_RTX));\n+      emit_move_insn (src_addr, force_operand (XEXP (src, 0), NULL_RTX));\n+      dst = change_address (dst, VOIDmode, dst_addr);\n+      src = change_address (src, VOIDmode, src_addr);\n+     \n+      temp = expand_binop (mode, add_optab, count, constm1_rtx, count, 1, 0);\n+      if (temp != count)\n+        emit_move_insn (count, temp);\n+\n+      temp = expand_binop (mode, ashr_optab, count, GEN_INT (8), blocks, 1, 0);\n+      if (temp != blocks)\n+        emit_move_insn (blocks, temp);\n+\n+      expand_start_loop (1);\n+      expand_exit_loop_top_cond (0, build (NE_EXPR, type,\n+\t\t\t\t\t   make_tree (type, blocks),\n+\t\t\t\t\t   make_tree (type, const0_rtx)));\n+\n+      emit_insn ((*gen_short) (dst, src, GEN_INT (255)));\n+      s390_load_address (dst_addr, \n+\t\t\t gen_rtx_PLUS (Pmode, dst_addr, GEN_INT (256)));\n+      s390_load_address (src_addr, \n+\t\t\t gen_rtx_PLUS (Pmode, src_addr, GEN_INT (256)));\n+      \n+      temp = expand_binop (mode, add_optab, blocks, constm1_rtx, blocks, 1, 0);\n+      if (temp != blocks)\n+        emit_move_insn (blocks, temp);\n+\n+      expand_end_loop ();\n+\n+      emit_insn ((*gen_short) (dst, src, convert_to_mode (word_mode, count, 1)));\n+      emit_label (end_label);\n+    }\n+}\n+\n+/* Emit code to clear LEN bytes at DST.  */\n+\n+void\n+s390_expand_clrstr (dst, len)\n+     rtx dst;\n+     rtx len;\n+{\n+  rtx (*gen_short) PARAMS ((rtx, rtx)) = \n+    TARGET_64BIT ? gen_clrstr_short_64 : gen_clrstr_short_31;\n+  rtx (*gen_long) PARAMS ((rtx, rtx, rtx)) = \n+    TARGET_64BIT ? gen_clrstr_long_64 : gen_clrstr_long_31;\n+\n+\n+  if (GET_CODE (len) == CONST_INT && INTVAL (len) >= 0 && INTVAL (len) <= 256)\n+    {\n+      if (INTVAL (len) > 0)\n+        emit_insn ((*gen_short) (dst, GEN_INT (INTVAL (len) - 1)));\n+    }\n+\n+  else if (TARGET_MVCLE)\n+    {\n+      enum machine_mode double_mode = TARGET_64BIT ? TImode : DImode;\n+      enum machine_mode single_mode = TARGET_64BIT ? DImode : SImode;\n+      rtx reg0 = gen_reg_rtx (double_mode);\n+      rtx reg1 = gen_reg_rtx (double_mode);\n+\n+      emit_move_insn (gen_highpart (single_mode, reg0), \n+\t\t      force_operand (XEXP (dst, 0), NULL_RTX));\n+      convert_move (gen_lowpart (single_mode, reg0), len, 1);\n+\n+      emit_move_insn (gen_highpart (single_mode, reg1), const0_rtx);\n+      emit_move_insn (gen_lowpart (single_mode, reg1), const0_rtx);\n+\n+      emit_insn ((*gen_long) (reg0, reg1, reg0));\n+    }\n+\n+  else\n+    {\n+      rtx dst_addr, src_addr, count, blocks, temp;\n+      rtx end_label = gen_label_rtx ();\n+      enum machine_mode mode;\n+      tree type;\n+\n+      mode = GET_MODE (len);\n+      if (mode == VOIDmode)\n+        mode = word_mode;\n+\n+      type = (*lang_hooks.types.type_for_mode) (mode, 1);\n+      if (!type)\n+        abort ();\n+\n+      dst_addr = gen_reg_rtx (Pmode);\n+      src_addr = gen_reg_rtx (Pmode);\n+      count = gen_reg_rtx (mode);\n+      blocks = gen_reg_rtx (mode);\n+\n+      convert_move (count, len, 1);\n+      emit_cmp_and_jump_insns (count, const0_rtx, \n+\t\t\t       EQ, NULL_RTX, mode, 1, end_label);\n+\n+      emit_move_insn (dst_addr, force_operand (XEXP (dst, 0), NULL_RTX));\n+      dst = change_address (dst, VOIDmode, dst_addr);\n+     \n+      temp = expand_binop (mode, add_optab, count, constm1_rtx, count, 1, 0);\n+      if (temp != count)\n+        emit_move_insn (count, temp);\n+\n+      temp = expand_binop (mode, ashr_optab, count, GEN_INT (8), blocks, 1, 0);\n+      if (temp != blocks)\n+        emit_move_insn (blocks, temp);\n+\n+      expand_start_loop (1);\n+      expand_exit_loop_top_cond (0, build (NE_EXPR, type,\n+\t\t\t\t\t   make_tree (type, blocks),\n+\t\t\t\t\t   make_tree (type, const0_rtx)));\n+\n+      emit_insn ((*gen_short) (dst, GEN_INT (255)));\n+      s390_load_address (dst_addr, \n+\t\t\t gen_rtx_PLUS (Pmode, dst_addr, GEN_INT (256)));\n+      \n+      temp = expand_binop (mode, add_optab, blocks, constm1_rtx, blocks, 1, 0);\n+      if (temp != blocks)\n+        emit_move_insn (blocks, temp);\n+\n+      expand_end_loop ();\n+\n+      emit_insn ((*gen_short) (dst, convert_to_mode (word_mode, count, 1)));\n+      emit_label (end_label);\n+    }\n+}\n+\n+/* Emit code to compare LEN bytes at OP0 with those at OP1,\n+   and return the result in TARGET.  */\n+\n+void\n+s390_expand_cmpstr (target, op0, op1, len)\n+     rtx target;\n+     rtx op0;\n+     rtx op1;\n+     rtx len;\n+{\n+  rtx (*gen_short) PARAMS ((rtx, rtx, rtx)) = \n+    TARGET_64BIT ? gen_cmpstr_short_64 : gen_cmpstr_short_31;\n+  rtx (*gen_long) PARAMS ((rtx, rtx, rtx, rtx)) = \n+    TARGET_64BIT ? gen_cmpstr_long_64 : gen_cmpstr_long_31;\n+  rtx (*gen_result) PARAMS ((rtx)) =\n+    GET_MODE (target) == DImode ? gen_cmpint_di : gen_cmpint_si;\n+\n+  op0 = protect_from_queue (op0, 0);\n+  op1 = protect_from_queue (op1, 0);\n+  len = protect_from_queue (len, 0);\n+\n+  if (GET_CODE (len) == CONST_INT && INTVAL (len) >= 0 && INTVAL (len) <= 256)\n+    {\n+      if (INTVAL (len) > 0)\n+        {\n+          emit_insn ((*gen_short) (op0, op1, GEN_INT (INTVAL (len) - 1)));\n+          emit_insn ((*gen_result) (target));\n+        }\n+      else\n+        emit_move_insn (target, const0_rtx);\n+    }\n+\n+  else if (TARGET_MVCLE)\n+    {\n+      enum machine_mode double_mode = TARGET_64BIT ? TImode : DImode;\n+      enum machine_mode single_mode = TARGET_64BIT ? DImode : SImode;\n+      rtx reg0 = gen_reg_rtx (double_mode);\n+      rtx reg1 = gen_reg_rtx (double_mode);\n+\n+      emit_move_insn (gen_highpart (single_mode, reg0), \n+\t\t      force_operand (XEXP (op0, 0), NULL_RTX));\n+      emit_move_insn (gen_highpart (single_mode, reg1), \n+\t\t      force_operand (XEXP (op1, 0), NULL_RTX));\n+\n+      convert_move (gen_lowpart (single_mode, reg0), len, 1);\n+      convert_move (gen_lowpart (single_mode, reg1), len, 1);\n+\n+      emit_insn ((*gen_long) (reg0, reg1, reg0, reg1));\n+      emit_insn ((*gen_result) (target));\n+    }\n+\n+  else\n+    {\n+      rtx addr0, addr1, count, blocks, temp;\n+      rtx end_label = gen_label_rtx ();\n+      enum machine_mode mode;\n+      tree type;\n+\n+      mode = GET_MODE (len);\n+      if (mode == VOIDmode)\n+        mode = word_mode;\n+\n+      type = (*lang_hooks.types.type_for_mode) (mode, 1);\n+      if (!type)\n+        abort ();\n+\n+      addr0 = gen_reg_rtx (Pmode);\n+      addr1 = gen_reg_rtx (Pmode);\n+      count = gen_reg_rtx (mode);\n+      blocks = gen_reg_rtx (mode);\n+\n+      convert_move (count, len, 1);\n+      emit_cmp_and_jump_insns (count, const0_rtx, \n+\t\t\t       EQ, NULL_RTX, mode, 1, end_label);\n+\n+      emit_move_insn (addr0, force_operand (XEXP (op0, 0), NULL_RTX));\n+      emit_move_insn (addr1, force_operand (XEXP (op1, 0), NULL_RTX));\n+      op0 = change_address (op0, VOIDmode, addr0);\n+      op1 = change_address (op1, VOIDmode, addr1);\n+     \n+      temp = expand_binop (mode, add_optab, count, constm1_rtx, count, 1, 0);\n+      if (temp != count)\n+        emit_move_insn (count, temp);\n+\n+      temp = expand_binop (mode, ashr_optab, count, GEN_INT (8), blocks, 1, 0);\n+      if (temp != blocks)\n+        emit_move_insn (blocks, temp);\n+\n+      expand_start_loop (1);\n+      expand_exit_loop_top_cond (0, build (NE_EXPR, type,\n+\t\t\t\t\t   make_tree (type, blocks),\n+\t\t\t\t\t   make_tree (type, const0_rtx)));\n+\n+      emit_insn ((*gen_short) (op0, op1, GEN_INT (255)));\n+      temp = gen_rtx_NE (VOIDmode, gen_rtx_REG (CCSmode, 33), const0_rtx);\n+      temp = gen_rtx_IF_THEN_ELSE (VOIDmode, temp, \n+\t\t\tgen_rtx_LABEL_REF (VOIDmode, end_label), pc_rtx);\n+      temp = gen_rtx_SET (VOIDmode, pc_rtx, temp);\n+      emit_jump_insn (temp);\n+\n+      s390_load_address (addr0, \n+\t\t\t gen_rtx_PLUS (Pmode, addr0, GEN_INT (256)));\n+      s390_load_address (addr1, \n+\t\t\t gen_rtx_PLUS (Pmode, addr1, GEN_INT (256)));\n+      \n+      temp = expand_binop (mode, add_optab, blocks, constm1_rtx, blocks, 1, 0);\n+      if (temp != blocks)\n+        emit_move_insn (blocks, temp);\n+\n+      expand_end_loop ();\n+\n+      emit_insn ((*gen_short) (op0, op1, convert_to_mode (word_mode, count, 1)));\n+      emit_label (end_label);\n+\n+      emit_insn ((*gen_result) (target));\n+    }\n+}\n+\n /* In the name of slightly smaller debug output, and to cater to\n    general assembler losage, recognize various UNSPEC sequences\n    and turn them back into a direct symbol reference.  */"}, {"sha": "100758408db82084954c23534b2a1e96def0f4c3", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 189, "deletions": 445, "changes": 634, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41c6c533d4b1081fdb453cfa8fa5526af764151/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41c6c533d4b1081fdb453cfa8fa5526af764151/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=a41c6c533d4b1081fdb453cfa8fa5526af764151", "patch": "@@ -832,10 +832,13 @@\n         (match_operand:TI 1 \"memory_operand\" \"\"))]\n   \"TARGET_64BIT && reload_completed\n    && !s_operand (operands[1], VOIDmode)\"\n-  [(set (match_dup 2) (match_dup 3))\n-   (set (match_dup 0) (mem:TI (match_dup 2)))]\n-  \"operands[2] = operand_subword (operands[0], 1, 0, TImode);\n-   operands[3] = legitimize_la_operand (XEXP (operands[1], 0));\")\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"\n+{\n+  rtx addr = operand_subword (operands[0], 1, 0, TImode);\n+  s390_load_address (addr, XEXP (operands[1], 0));\n+  operands[1] = replace_equiv_address (operands[1], addr);\n+}\")\n \n ;\n ; movdi instruction pattern(s).\n@@ -981,10 +984,13 @@\n    && !fp_operand (operands[0], VOIDmode)\n    && !fp_operand (operands[1], VOIDmode)\n    && !s_operand (operands[1], VOIDmode)\"\n-  [(set (match_dup 2) (match_dup 3))\n-   (set (match_dup 0) (mem:DI (match_dup 2)))]\n-  \"operands[2] = operand_subword (operands[0], 1, 0, DImode);\n-   operands[3] = legitimize_la_operand (XEXP (operands[1], 0));\")\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"\n+{\n+  rtx addr = operand_subword (operands[0], 1, 0, DImode);\n+  s390_load_address (addr, XEXP (operands[1], 0));\n+  operands[1] = replace_equiv_address (operands[1], addr);\n+}\")\n \n ;\n ; movsi instruction pattern(s).\n@@ -1254,10 +1260,13 @@\n    && !fp_operand (operands[0], VOIDmode)\n    && !fp_operand (operands[1], VOIDmode)\n    && !s_operand (operands[1], VOIDmode)\"\n-  [(set (match_dup 2) (match_dup 3))\n-   (set (match_dup 0) (mem:DI (match_dup 2)))]\n-  \"operands[2] = operand_subword (operands[0], 1, 0, DFmode);\n-   operands[3] = legitimize_la_operand (XEXP (operands[1], 0));\")\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"\n+{\n+  rtx addr = operand_subword (operands[0], 1, 0, DFmode);\n+  s390_load_address (addr, XEXP (operands[1], 0));\n+  operands[1] = replace_equiv_address (operands[1], addr);\n+}\")\n \n ;\n ; movsf instruction pattern(s).\n@@ -1503,172 +1512,31 @@\n ;;\n \n ;\n-; movstrdi instruction pattern(s).\n+; movstrM instruction pattern(s).\n ;\n \n (define_expand \"movstrdi\"\n-   [(set (match_operand:BLK 0 \"general_operand\" \"\")\n-         (match_operand:BLK 1 \"general_operand\" \"\"))\n-    (use (match_operand:DI 2 \"general_operand\" \"\"))\n-    (match_operand 3 \"\" \"\")]\n-    \"TARGET_64BIT\"\n-    \"\n-{\n-  rtx addr0, addr1;\n-\n-  addr0 = force_operand (XEXP (operands[0], 0), NULL_RTX);\n-  addr1 = force_operand (XEXP (operands[1], 0), NULL_RTX);\n-\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) <= 256)\n-    {\n-      operands[0] = change_address (operands[0], VOIDmode, addr0);\n-      operands[1] = change_address (operands[1], VOIDmode, addr1);\n-      operands[2] = GEN_INT (INTVAL (operands[2]) - 1);\n-\n-      emit_insn (gen_movstrdi_short (operands[0], operands[1], operands[2]));\n-      DONE;\n-    } \n-  else \n-    {\n-      if (TARGET_MVCLE) \n-\t{\n-          /* implementation suggested by  Richard Henderson <rth@cygnus.com> */\n-          rtx reg0 = gen_reg_rtx (TImode);\n-          rtx reg1 = gen_reg_rtx (TImode);\n-          rtx len = operands[2];\n-\n-          if (! CONSTANT_P (len))\n-            len = force_reg (DImode, len);\n-\n-          /* Load up the address+length pairs.  */\n-\n-          emit_move_insn (gen_highpart (DImode, reg0), addr0);\n-          emit_move_insn (gen_lowpart (DImode, reg0), len);\n-\n-          emit_move_insn (gen_highpart (DImode, reg1), addr1);\n-          emit_move_insn (gen_lowpart (DImode, reg1), len);\n-\n-          /* MOVE */\n-          emit_insn (gen_movstrdi_64 (reg0, reg1, reg0, reg1));\n-          DONE;\n-        }\n-      else\n-\t{\n-          rtx label1 = gen_label_rtx ();\n-          rtx label2 = gen_label_rtx ();\n-          rtx reg0, reg1, len, blocks;\n-      \t\t\n-          reg0 = gen_reg_rtx (DImode);\n-          reg1 = gen_reg_rtx (DImode);\n-          len = gen_reg_rtx (DImode);\n-          blocks = gen_reg_rtx (DImode);\n-\n-          emit_move_insn (len, operands[2]);\t\n-          emit_insn (gen_cmpdi (len, const0_rtx));\n-          emit_jump_insn (gen_beq (label1));\n-          emit_move_insn (reg0, addr0);\n-          emit_move_insn (reg1, addr1);\n-          emit_insn (gen_adddi3 (len, len, constm1_rtx));\n-          emit_insn (gen_ashrdi3 (blocks, len, GEN_INT (8)));\n-          emit_insn (gen_cmpdi (blocks, const0_rtx));\n-          emit_jump_insn (gen_beq (label2));\n-          emit_insn (gen_movstrdi_long (reg0, reg1, reg0, reg1, blocks, blocks));\n-          emit_label (label2); \n-\t  operands[0] = change_address (operands[0], VOIDmode, reg0);\n-\t  operands[1] = change_address (operands[1], VOIDmode, reg1);\n-          emit_insn (gen_movstrdi_short (operands[0], operands[1], len));\n-          emit_label (label1); \n-          DONE;\t   \n-       }\t \n-    }\n-}\")\n-\n-;\n-; movstrsi instruction pattern(s).\n-;\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+        (match_operand:BLK 1 \"memory_operand\" \"\"))\n+   (use (match_operand:DI 2 \"general_operand\" \"\"))\n+   (match_operand 3 \"\" \"\")]\n+  \"TARGET_64BIT\"\n+  \"s390_expand_movstr (operands[0], operands[1], operands[2]); DONE;\")\n \n (define_expand \"movstrsi\"\n-   [(set (match_operand:BLK 0 \"general_operand\" \"\")\n-         (match_operand:BLK 1 \"general_operand\" \"\"))\n-    (use (match_operand:SI 2 \"general_operand\" \"\"))\n-    (match_operand 3 \"\" \"\")]\n-    \"!TARGET_64BIT\"\n-    \"\n-{\n-  rtx addr0 = force_operand (XEXP (operands[0], 0), NULL_RTX);\n-  rtx addr1 = force_operand (XEXP (operands[1], 0), NULL_RTX);\n-\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) <= 256)\n-    {\n-      operands[0] = change_address (operands[0], VOIDmode, addr0);\n-      operands[1] = change_address (operands[1], VOIDmode, addr1);\n-      operands[2] = GEN_INT (INTVAL (operands[2]) - 1);\n-\n-      emit_insn (gen_movstrsi_short (operands[0], operands[1], operands[2]));\n-      DONE;\n-    } \n-  else \n-    {\n-      if (TARGET_MVCLE) \n-\t{\n-          /* implementation suggested by  Richard Henderson <rth@cygnus.com> */\n-          rtx reg0 = gen_reg_rtx (DImode);\n-          rtx reg1 = gen_reg_rtx (DImode);\n-          rtx len = operands[2];\n-\n-\n-          if (! CONSTANT_P (len))\n-            len = force_reg (SImode, len);\n-\n-          /* Load up the address+length pairs.  */\n-\n-          emit_move_insn (gen_highpart (SImode, reg0), addr0);\n-          emit_move_insn (gen_lowpart (SImode, reg0), len);\n-\n-          emit_move_insn (gen_highpart (SImode, reg1), addr1);\n-          emit_move_insn (gen_lowpart (SImode, reg1), len);\n-\n-          /* MOVE */\n-          emit_insn (gen_movstrsi_31 (reg0, reg1, reg0, reg1));\n-          DONE;\n-        }\n-      else\n-\t{\n-          rtx label1 = gen_label_rtx ();\n-          rtx label2 = gen_label_rtx ();\n-          rtx reg0, reg1, len, blocks;\n-      \t\t\n-          reg0 = gen_reg_rtx (SImode);\n-          reg1 = gen_reg_rtx (SImode);\n-\t  len = gen_reg_rtx (SImode); \n-\t  blocks = gen_reg_rtx (SImode); \n-\t  \n-\t  emit_move_insn (len, operands[2]);\n-          emit_insn (gen_cmpsi (len, const0_rtx));\n-          emit_jump_insn (gen_beq (label1));\n-          emit_move_insn (reg0, addr0);\n-          emit_move_insn (reg1, addr1);\n-          emit_insn (gen_addsi3 (len, len, constm1_rtx));\n-          emit_insn (gen_ashrsi3 (blocks, len, GEN_INT (8)));\n-          emit_insn (gen_cmpsi (blocks, const0_rtx));\n-          emit_jump_insn (gen_beq (label2));\n-          emit_insn (gen_movstrsi_long (reg0, reg1, reg0, reg1, blocks, blocks));\n-          emit_label (label2); \n-\t  operands[0] = change_address (operands[0], VOIDmode, reg0);\n-\t  operands[1] = change_address (operands[1], VOIDmode, reg1);\n-          emit_insn (gen_movstrsi_short (operands[0], operands[1], len));\n-          emit_label (label1); \n-          DONE;\t   \n-       }\t \n-    }\n-}\")\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+        (match_operand:BLK 1 \"memory_operand\" \"\"))\n+   (use (match_operand:SI 2 \"general_operand\" \"\"))\n+   (match_operand 3 \"\" \"\")]\n+  \"\"\n+  \"s390_expand_movstr (operands[0], operands[1], operands[2]); DONE;\")\n \n ; Move a block that is up to 256 bytes in length.\n ; The block length is taken as (operands[2] % 256) + 1.\n \n-(define_insn \"movstrdi_short\"\n-  [(set (match_operand:BLK 0 \"s_operand\" \"=Q,Q\")\n-        (match_operand:BLK 1 \"s_operand\" \"Q,Q\"))\n+(define_insn \"movstr_short_64\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q,Q\")\n+        (match_operand:BLK 1 \"memory_operand\" \"Q,Q\"))\n    (use (match_operand:DI 2 \"nonmemory_operand\" \"n,a\"))\n    (clobber (match_scratch:DI 3 \"=X,&a\"))]\n   \"TARGET_64BIT\"\n@@ -1689,12 +1557,13 @@\n     }\n }\"\n   [(set_attr \"op_type\" \"SS,NN\")\n+   (set_attr \"type\"    \"cs,cs\")\n    (set_attr \"atype\"   \"mem,mem\")\n    (set_attr \"length\"  \"*,14\")])\n \n-(define_insn \"movstrsi_short\"\n-  [(set (match_operand:BLK 0 \"s_operand\" \"=Q,Q\")\n-        (match_operand:BLK 1 \"s_operand\" \"Q,Q\"))\n+(define_insn \"movstr_short_31\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q,Q\")\n+        (match_operand:BLK 1 \"memory_operand\" \"Q,Q\"))\n    (use (match_operand:SI 2 \"nonmemory_operand\" \"n,a\"))\n    (clobber (match_scratch:SI 3 \"=X,&a\"))]\n   \"!TARGET_64BIT\"\n@@ -1715,64 +1584,13 @@\n     }\n }\"\n   [(set_attr \"op_type\" \"SS,NN\")\n+   (set_attr \"type\"    \"cs,cs\")\n    (set_attr \"atype\"   \"mem,mem\")\n    (set_attr \"length\"  \"*,14\")])\n \n-; Move a block that is a multiple of 256 bytes in length\n+; Move a block of arbitrary length.\n \n-(define_insn \"movstrdi_long\"\n-  [(set (match_operand:DI 4 \"register_operand\" \"=d\")\n-        (const_int 0))\n-   (set (match_operand:DI 0 \"register_operand\" \"=a\")\n-        (plus:DI (match_operand:DI 2 \"register_operand\" \"0\")\n-                 (ashift:DI (match_operand:DI 5 \"register_operand\" \"4\")\n-                            (const_int 8))))\n-   (set (match_operand:DI 1 \"register_operand\" \"=a\")\n-        (plus:DI (match_operand:DI 3 \"register_operand\" \"1\")\n-                 (ashift:DI (match_dup 5) (const_int 8))))\n-   (set (mem:BLK (match_dup 2))\n-        (mem:BLK (match_dup 3)))\n-   (use (match_dup 5))]\n-  \"TARGET_64BIT\"\n-  \"*\n-{\n-  output_asm_insn (\\\"mvc\\\\t0(256,%0),0(%1)\\\", operands);\n-  output_asm_insn (\\\"la\\\\t%0,256(%0)\\\", operands);\n-  output_asm_insn (\\\"la\\\\t%1,256(%1)\\\", operands);\n-  return \\\"brct\\\\t%4,.-14\\\";\n-}\"\n-  [(set_attr \"op_type\" \"NN\")\n-   (set_attr \"atype\"   \"mem\")\n-   (set_attr \"length\"  \"18\")])\n-\n-(define_insn \"movstrsi_long\"\n-  [(set (match_operand:SI 4 \"register_operand\" \"=d\")\n-        (const_int 0))\n-   (set (match_operand:SI 0 \"register_operand\" \"=a\")\n-        (plus:SI (match_operand:SI 2 \"register_operand\" \"0\")\n-                 (ashift:SI (match_operand:SI 5 \"register_operand\" \"4\")\n-                            (const_int 8))))\n-   (set (match_operand:SI 1 \"register_operand\" \"=a\")\n-        (plus:SI (match_operand:SI 3 \"register_operand\" \"1\")\n-                 (ashift:SI (match_dup 5) (const_int 8))))\n-   (set (mem:BLK (match_dup 2))\n-        (mem:BLK (match_dup 3)))\n-   (use (match_dup 5))]\n-  \"!TARGET_64BIT\"\n-  \"*\n-{\n-  output_asm_insn (\\\"mvc\\\\t0(256,%0),0(%1)\\\", operands);\n-  output_asm_insn (\\\"la\\\\t%0,256(%0)\\\", operands);\n-  output_asm_insn (\\\"la\\\\t%1,256(%1)\\\", operands);\n-  return \\\"brct\\\\t%4,.-14\\\";\n-}\"\n-  [(set_attr \"op_type\" \"NN\")\n-   (set_attr \"atype\"   \"mem\")\n-   (set_attr \"length\"  \"18\")])\n-\n-; Move a block that is larger than 255 bytes in length.\n-\n-(define_insn \"movstrdi_64\"\n+(define_insn \"movstr_long_64\"\n   [(set (match_operand:TI 0 \"register_operand\" \"=d\")\n         (ashift:TI (plus:TI (match_operand:TI 2 \"register_operand\" \"0\")\n                             (lshiftrt:TI (match_dup 2) (const_int 64)))\n@@ -1787,10 +1605,11 @@\n   \"TARGET_64BIT\"\n   \"mvcle\\\\t%0,%1,0\\;jo\\\\t.-4\"\n   [(set_attr \"op_type\" \"NN\")\n+   (set_attr \"type\"    \"vs\")\n    (set_attr \"atype\"   \"mem\")\n    (set_attr \"length\"  \"8\")])\n \n-(define_insn \"movstrsi_31\"\n+(define_insn \"movstr_long_31\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (ashift:DI (plus:DI (match_operand:DI 2 \"register_operand\" \"0\")\n                             (lshiftrt:DI (match_dup 2) (const_int 32)))\n@@ -1804,112 +1623,93 @@\n    (clobber (reg:CC 33))]\n   \"!TARGET_64BIT\"\n   \"mvcle\\\\t%0,%1,0\\;jo\\\\t.-4\"\n-   [(set_attr \"op_type\" \"NN\")\n-    (set_attr \"atype\" \"mem\")\n-    (set_attr \"length\"  \"8\")])\n+  [(set_attr \"op_type\" \"NN\")\n+   (set_attr \"type\"    \"vs\")\n+   (set_attr \"atype\"   \"mem\")\n+   (set_attr \"length\"  \"8\")])\n \n ;\n-; clrstrdi instruction pattern(s).\n+; clrstrM instruction pattern(s).\n ;\n \n (define_expand \"clrstrdi\"\n-  [(set (match_operand:BLK 0 \"general_operand\" \"\")\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n         (const_int 0))\n    (use (match_operand:DI 1 \"general_operand\" \"\"))\n    (match_operand 2 \"\" \"\")]\n   \"TARGET_64BIT\"\n-  \"\n-{\n-   rtx addr = force_operand (XEXP (operands[0], 0), NULL_RTX);\n-\n-   operands[0] = change_address (operands[0], VOIDmode, addr);\n-\n-   if (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) < 256)\n-     {\n-        emit_insn (gen_clrstrsico (operands[0], operands[1]));\n-        DONE;\n-     }\n-   else\n-     {\n-      rtx reg0 = gen_reg_rtx (TImode);\n-      rtx reg1 = gen_reg_rtx (TImode);\n-      rtx len = operands[1];\n-\n-      if (! CONSTANT_P (len))\n-          len = force_reg (DImode, len);\n-\n-      /* Load up the address+length pairs.  */\n-\n-      emit_move_insn (gen_highpart (DImode, reg0), addr);\n-      emit_move_insn (gen_lowpart (DImode, reg0), len);\n-\n-      emit_move_insn (gen_lowpart (DImode, reg1), const0_rtx);\n- \n-      /* Clear! */\n-      emit_insn (gen_clrstrsi_64 (reg0, reg1, reg0));\n-      DONE;\t\n-     }\n-}\")\n-\n-;\n-; clrstrsi instruction pattern(s).\n-;\n+  \"s390_expand_clrstr (operands[0], operands[1]); DONE;\")\n \n (define_expand \"clrstrsi\"\n-  [(set (match_operand:BLK 0 \"general_operand\" \"\")\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n         (const_int 0))\n    (use (match_operand:SI 1 \"general_operand\" \"\"))\n    (match_operand 2 \"\" \"\")]\n-   \"!TARGET_64BIT\"\n-   \"\n-{\n-   rtx addr = force_operand (XEXP (operands[0], 0), NULL_RTX);\n-\n-   operands[0] = change_address (operands[0], VOIDmode, addr);\n-\n-   if (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) < 256)\n-     {\n-        emit_insn (gen_clrstrsico (operands[0], operands[1]));\n-        DONE;\n-     }\n-   else\n-     {\n-      rtx reg0 = gen_reg_rtx (DImode);\n-      rtx reg1 = gen_reg_rtx (DImode);\n-      rtx len = operands[1];\n-\n-      if (! CONSTANT_P (len))\n-          len = force_reg (SImode, len);\n+  \"\"\n+  \"s390_expand_clrstr (operands[0], operands[1]); DONE;\")\n \n-      /* Load up the address+length pairs.  */\n+; Clear a block that is up to 256 bytes in length.\n+; The block length is taken as (operands[2] % 256) + 1.\n \n-      emit_move_insn (gen_highpart (SImode, reg0), addr);\n-      emit_move_insn (gen_lowpart (SImode, reg0), len);\n+(define_insn \"clrstr_short_64\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q,Q\")\n+        (const_int 0))\n+   (use (match_operand:DI 1 \"nonmemory_operand\" \"n,a\"))\n+   (clobber (match_scratch:DI 2 \"=X,&a\"))\n+   (clobber (reg:CC 33))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+      case 0:\n+\treturn \\\"xc\\\\t%O0(%b1+1,%R0),%0\\\";\n \n-      emit_move_insn (gen_lowpart (SImode, reg1), const0_rtx);\n- \n-      /* CLear! */\n-      emit_insn (gen_clrstrsi_31 (reg0, reg1, reg0));\n-      DONE;\t\n-     }\n-}\")\n+      case 1:\n+\toutput_asm_insn (\\\"bras\\\\t%2,.+10\\\", operands);\n+\toutput_asm_insn (\\\"xc\\\\t%O0(1,%R0),%0\\\", operands);\n+\treturn \\\"ex\\\\t%1,0(%2)\\\";\n \n-; Clear memory with length less than 256 bytes \n+      default:\n+        abort ();\n+    }\n+}\"\n+  [(set_attr \"op_type\" \"SS,NN\")\n+   (set_attr \"type\"    \"cs,cs\")\n+   (set_attr \"atype\"   \"mem,mem\")\n+   (set_attr \"length\"  \"*,14\")])\n \n-(define_insn \"clrstrsico\"\n-  [(set (match_operand:BLK 0 \"s_operand\" \"=Q\")\n+(define_insn \"clrstr_short_31\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q,Q\")\n         (const_int 0))\n-   (use (match_operand 1 \"immediate_operand\" \"I\"))\n+   (use (match_operand:SI 1 \"nonmemory_operand\" \"n,a\"))\n+   (clobber (match_scratch:SI 2 \"=X,&a\"))\n    (clobber (reg:CC 33))]\n-  \"\"\n-  \"xc\\\\t%O0(%1,%R0),%0\"\t\n-  [(set_attr \"op_type\" \"RS\")\n-   (set_attr \"type\"    \"cs\")\n-   (set_attr \"atype\"   \"mem\")])\n+  \"!TARGET_64BIT\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+      case 0:\n+\treturn \\\"xc\\\\t%O0(%b1+1,%R0),%0\\\";\n+\n+      case 1:\n+\toutput_asm_insn (\\\"bras\\\\t%2,.+10\\\", operands);\n+\toutput_asm_insn (\\\"xc\\\\t%O0(1,%R0),%0\\\", operands);\n+\treturn \\\"ex\\\\t%1,0(%2)\\\";\n+\n+      default:\n+        abort ();\n+    }\n+}\"\n+  [(set_attr \"op_type\" \"SS,NN\")\n+   (set_attr \"type\"    \"cs,cs\")\n+   (set_attr \"atype\"   \"mem,mem\")\n+   (set_attr \"length\"  \"*,14\")])\n \n-; Clear memory with length greater 256 bytes or lenght not constant\n+; Clear a block of arbitrary length.\n \n-(define_insn \"clrstrsi_64\"\n+(define_insn \"clrstr_long_64\"\n   [(set (match_operand:TI 0 \"register_operand\" \"=d\")\n         (ashift:TI (plus:TI (match_operand:TI 2 \"register_operand\" \"0\")\n                             (lshiftrt:TI (match_dup 2) (const_int 64)))\n@@ -1925,7 +1725,7 @@\n    (set_attr \"type\"    \"vs\")\n    (set_attr \"length\"  \"8\")])\n \n-(define_insn \"clrstrsi_31\"\n+(define_insn \"clrstr_long_31\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (ashift:DI (plus:DI (match_operand:DI 2 \"register_operand\" \"0\")\n                             (lshiftrt:DI (match_dup 2) (const_int 32)))\n@@ -1942,157 +1742,91 @@\n    (set_attr \"length\"  \"8\")])\n \n ;\n-; cmpstrdi instruction pattern(s).\n+; cmpstrM instruction pattern(s).\n ;\n \n (define_expand \"cmpstrdi\"\n-   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-         (compare:DI (match_operand:BLK 1 \"general_operand\" \"\")\n-                  (match_operand:BLK 2 \"general_operand\" \"\") ) )\n-             (use (match_operand:DI 3  \"general_operand\" \"\"))\n-             (use (match_operand:DI 4  \"\" \"\"))]\n-   \"TARGET_64BIT\"\n-   \"\n-{\n-  rtx addr0, addr1;\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+        (compare:DI (match_operand:BLK 1 \"memory_operand\" \"\")\n+                    (match_operand:BLK 2 \"memory_operand\" \"\") ) )\n+   (use (match_operand:DI 3 \"general_operand\" \"\"))\n+   (use (match_operand:DI 4 \"\" \"\"))]\n+  \"TARGET_64BIT\"\n+  \"s390_expand_cmpstr (operands[0], operands[1], \n+                       operands[2], operands[3]); DONE;\")\n \n-  /* for pre/post increment */\n-  operands[1] = protect_from_queue (operands[1], 0);\n-  operands[2] = protect_from_queue (operands[2], 0);\n-  operands[3] = protect_from_queue (operands[3], 0);\n+(define_expand \"cmpstrsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (compare:SI (match_operand:BLK 1 \"memory_operand\" \"\")\n+                    (match_operand:BLK 2 \"memory_operand\" \"\") ) )\n+   (use (match_operand:SI 3 \"general_operand\" \"\"))\n+   (use (match_operand:SI 4 \"\" \"\"))]\n+  \"\"\n+  \"s390_expand_cmpstr (operands[0], operands[1], \n+                       operands[2], operands[3]); DONE;\")\n \n-  addr0 = force_operand (XEXP (operands[1], 0), NULL_RTX);\n-  addr1 = force_operand (XEXP (operands[2], 0), NULL_RTX);\n+; Compare a block that is up to 256 bytes in length.\n+; The block length is taken as (operands[2] % 256) + 1.\n \n-  if (GET_CODE (operands[3]) == CONST_INT && INTVAL (operands[3]) < 256) \n+(define_insn \"cmpstr_short_64\"\n+  [(set (reg:CCS 33)\n+        (compare:CCS (match_operand:BLK 0 \"memory_operand\" \"=Q,Q\")\n+                     (match_operand:BLK 1 \"memory_operand\" \"Q,Q\")))\n+   (use (match_operand:DI 2 \"nonmemory_operand\" \"n,a\"))\n+   (clobber (match_scratch:DI 3 \"=X,&a\"))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  switch (which_alternative)\n     {\n-      if (INTVAL (operands[3]) == 0) {\n-\temit_move_insn (operands[0], operands[3]);\n-\tDONE;\n-      }\n-\n-      operands[1] = change_address (operands[1], VOIDmode, addr0);\n-      operands[2] = change_address (operands[2], VOIDmode, addr1);\n-\n-      emit_insn (gen_cmpstr_const (operands[1], operands[2], operands[3]));\n-      emit_insn (gen_cmpint_di (operands[0]));\n-      DONE;\n-    }\n-  else\n-    {\t\n-      /* implementation suggested by  Richard Henderson <rth@cygnus.com> */\n-      rtx reg0 = gen_reg_rtx (TImode);\n-      rtx reg1 = gen_reg_rtx (TImode);\n-      rtx len = operands[3];\n-\n-      if (! CONSTANT_P (len))\n-          len = force_reg (DImode, len);\n-\n-      /* Load up the address+length pairs.  */\n-      emit_move_insn (gen_highpart (DImode, reg0), addr0); \n-      emit_move_insn (gen_lowpart (DImode, reg0), len);\n+      case 0:\n+\treturn \\\"clc\\\\t%O0(%b2+1,%R0),%1\\\";\n \n-      emit_move_insn (gen_highpart (DImode, reg1), addr1);\n-      emit_move_insn (gen_lowpart (DImode, reg1), len);\n+      case 1:\n+\toutput_asm_insn (\\\"bras\\\\t%3,.+10\\\", operands);\n+\toutput_asm_insn (\\\"clc\\\\t%O0(1,%R0),%1\\\", operands);\n+\treturn \\\"ex\\\\t%2,0(%3)\\\";\n \n-      /* Compare! */\n-      emit_insn (gen_cmpstr_64 (reg0, reg1, reg0, reg1));\n-      emit_insn (gen_cmpint_di (operands[0]));\n-      DONE;\n+      default:\n+        abort ();\n     }\n-}\")\n-\n-;\n-; cmpstrsi instruction pattern(s).\n-;\n+}\"\n+  [(set_attr \"op_type\" \"SS,NN\")\n+   (set_attr \"type\"    \"cs,cs\")\n+   (set_attr \"atype\"   \"mem,mem\")\n+   (set_attr \"length\"  \"*,14\")])\n \n-(define_expand \"cmpstrsi\"\n-   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-         (compare:SI (match_operand:BLK 1 \"general_operand\" \"\")\n-                  (match_operand:BLK 2 \"general_operand\" \"\") ) )\n-             (use (match_operand:SI 3  \"general_operand\" \"\"))\n-             (use (match_operand:SI 4  \"\" \"\"))]\n-   \"\"\n-   \"\n+(define_insn \"cmpstr_short_31\"\n+  [(set (reg:CCS 33)\n+        (compare:CCS (match_operand:BLK 0 \"memory_operand\" \"=Q,Q\")\n+                     (match_operand:BLK 1 \"memory_operand\" \"Q,Q\")))\n+   (use (match_operand:SI 2 \"nonmemory_operand\" \"n,a\"))\n+   (clobber (match_scratch:SI 3 \"=X,&a\"))]\n+  \"!TARGET_64BIT\"\n+  \"*\n {\n-  rtx addr0, addr1;\n-\n-  /* for pre/post increment */\n-  operands[1] = protect_from_queue (operands[1], 0);\n-  operands[2] = protect_from_queue (operands[2], 0);\n-  operands[3] = protect_from_queue (operands[3], 0);\n-\n-  addr0 = force_operand (XEXP (operands[1], 0), NULL_RTX);\n-  addr1 = force_operand (XEXP (operands[2], 0), NULL_RTX);\n-\n-  if (GET_CODE (operands[3]) == CONST_INT && INTVAL (operands[3]) < 256) \n+  switch (which_alternative)\n     {\n-      if (INTVAL (operands[3]) == 0) {\n-\temit_move_insn (operands[0], operands[3]);\n-\tDONE;\n-      }\n-\n-      operands[1] = change_address (operands[1], VOIDmode, addr0);\n-      operands[2] = change_address (operands[2], VOIDmode, addr1);\n-\n-      emit_insn (gen_cmpstr_const (operands[1], operands[2], operands[3]));\n-      emit_insn (gen_cmpint_si (operands[0]));\n-      DONE;\n-    }\n-  else\n-    {\t\n-      /* implementation suggested by  Richard Henderson <rth@cygnus.com> */\n-      rtx reg0, reg1;\n-      rtx len = operands[3];\n-\n-      if (TARGET_64BIT)\n-\t{\n-\t  reg0 = gen_reg_rtx (TImode);\n-\t  reg1 = gen_reg_rtx (TImode);\n-\t}\n-      else\n-\t{\n-\t  reg0 = gen_reg_rtx (DImode);\n-\t  reg1 = gen_reg_rtx (DImode);\n-        }  \n-\n-      if (! CONSTANT_P (len))\n-          len = force_reg (Pmode, len);\n-\n-      /* Load up the address+length pairs.  */\n-      emit_move_insn (gen_highpart (Pmode, reg0), addr0); \n-      emit_move_insn (gen_lowpart (Pmode, reg0), len);\n-\n-      emit_move_insn (gen_highpart (Pmode, reg1), addr1);\n-      emit_move_insn (gen_lowpart (Pmode, reg1), len);\n+      case 0:\n+\treturn \\\"clc\\\\t%O0(%b2+1,%R0),%1\\\";\n \n-      /* Compare! */\n-      if (TARGET_64BIT) \n-          emit_insn (gen_cmpstr_64 (reg0, reg1, reg0, reg1));\n-      else\n-          emit_insn (gen_cmpstr_31 (reg0, reg1, reg0, reg1));\n+      case 1:\n+\toutput_asm_insn (\\\"bras\\\\t%3,.+10\\\", operands);\n+\toutput_asm_insn (\\\"clc\\\\t%O0(1,%R0),%1\\\", operands);\n+\treturn \\\"ex\\\\t%2,0(%3)\\\";\n \n-      emit_insn (gen_cmpint_si (operands[0]));\n-      DONE;\n+      default:\n+        abort ();\n     }\n-}\")\n-\n-; Compare a block that is less than 256 bytes in length.\n-\n-(define_insn \"cmpstr_const\"\n-  [(set (reg:CCS 33)\n-        (compare:CCS (match_operand:BLK 0 \"s_operand\" \"Q\")\n-                     (match_operand:BLK 1 \"s_operand\" \"Q\")))\n-   (use (match_operand 2 \"immediate_operand\" \"I\"))]\n-  \"(unsigned) INTVAL (operands[2]) < 256\"\n-  \"clc\\\\t%O0(%c2,%R0),%1\"\n-  [(set_attr \"op_type\" \"SS\")\n-   (set_attr \"atype\"   \"mem\")\n-   (set_attr \"type\"    \"cs\")])\n+}\"\n+  [(set_attr \"op_type\" \"SS,NN\")\n+   (set_attr \"type\"    \"cs,cs\")\n+   (set_attr \"atype\"   \"mem,mem\")\n+   (set_attr \"length\"  \"*,14\")])\n \n-; Compare a block that is larger than 255 bytes in length.\n+; Compare a block of arbitrary length.\n \n-(define_insn \"cmpstr_64\"\n+(define_insn \"cmpstr_long_64\"\n   [(clobber (match_operand:TI 0 \"register_operand\" \"=d\"))\n    (clobber (match_operand:TI 1 \"register_operand\" \"=d\"))\n    (set (reg:CCS 33)\n@@ -2106,7 +1840,7 @@\n    (set_attr \"atype\"   \"mem\")\n    (set_attr \"type\"    \"vs\")])\n \n-(define_insn \"cmpstr_31\"\n+(define_insn \"cmpstr_long_31\"\n   [(clobber (match_operand:DI 0 \"register_operand\" \"=d\"))\n    (clobber (match_operand:DI 1 \"register_operand\" \"=d\"))\n    (set (reg:CCS 33)\n@@ -3372,6 +3106,16 @@\n    (set_attr \"atype\"    \"mem\")\n    (set_attr \"type\"     \"la\")])\n \n+(define_insn \"force_la_31\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (match_operand:QI 1 \"address_operand\" \"p\"))\n+   (use (const_int 0))]\n+  \"!TARGET_64BIT\"\n+  \"la\\\\t%0,%a1\"\n+  [(set_attr \"op_type\"  \"RX\")\n+   (set_attr \"atype\"    \"mem\")\n+   (set_attr \"type\"     \"la\")])\n+\n (define_expand \"reload_insi\"\n   [(parallel [(match_operand:SI 0 \"register_operand\" \"=a\")\n               (match_operand:SI 1 \"s390_plus_operand\" \"\")"}]}