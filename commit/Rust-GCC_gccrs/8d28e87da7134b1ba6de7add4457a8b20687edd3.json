{"sha": "8d28e87da7134b1ba6de7add4457a8b20687edd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQyOGU4N2RhNzEzNGIxYmE2ZGU3YWRkNDQ1N2E4YjIwNjg3ZWRkMw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2003-07-03T23:50:05Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2003-07-03T23:50:05Z"}, "message": "cfglayout.c (cfg_layout_duplicate_bb): Do not update frequencies at all if edge is not specified.\n\n\t* cfglayout.c (cfg_layout_duplicate_bb): Do not update frequencies\n\tat all if edge is not specified.\n\t(can_copy_bbs_p, copy_bbs): New.\n\t* cfglayout.h (can_copy_bbs_p, copy_bbs): Declare.\n\t* cfgloop.c (get_loop_body): Comment more precisely.\n\t* cfgloopmanip.c (copy_bbs, record_exit_edges): Removed.\n\t(scale_bbs_frequencies): Fix comment typo.\n\t(can_duplicate_loop_p): Use can_copy_bbs_p.\n\t(duplicate_loop_to_header_edge): Simplify by using copy_bbs.\n\nFrom-SVN: r68906", "tree": {"sha": "f71a6c934abe134dd6b13c539736910da43d4680", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f71a6c934abe134dd6b13c539736910da43d4680"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d28e87da7134b1ba6de7add4457a8b20687edd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d28e87da7134b1ba6de7add4457a8b20687edd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d28e87da7134b1ba6de7add4457a8b20687edd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d28e87da7134b1ba6de7add4457a8b20687edd3/comments", "author": null, "committer": null, "parents": [{"sha": "694abeb6a7e64ba5aa18d9ae579585cb41dd53ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/694abeb6a7e64ba5aa18d9ae579585cb41dd53ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/694abeb6a7e64ba5aa18d9ae579585cb41dd53ee"}], "stats": {"total": 532, "additions": 244, "deletions": 288}, "files": [{"sha": "c85ed81c6b2e3061ee80a6a443c5f7bb497040ad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d28e87da7134b1ba6de7add4457a8b20687edd3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d28e87da7134b1ba6de7add4457a8b20687edd3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d28e87da7134b1ba6de7add4457a8b20687edd3", "patch": "@@ -1,3 +1,15 @@\n+2003-07-03  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* cfglayout.c (cfg_layout_duplicate_bb): Do not update frequencies\n+\tat all if edge is not specified.\n+\t(can_copy_bbs_p, copy_bbs): New.\n+\t* cfglayout.h (can_copy_bbs_p, copy_bbs): Declare.\n+\t* cfgloop.c (get_loop_body): Comment more precisely.\n+\t* cfgloopmanip.c (copy_bbs, record_exit_edges): Removed.\n+\t(scale_bbs_frequencies): Fix comment typo.\n+\t(can_duplicate_loop_p): Use can_copy_bbs_p.\n+\t(duplicate_loop_to_header_edge): Simplify by using copy_bbs.\n+\n 2003-07-03  Devang Patel <dpatel@apple.com>\n \n \t* c-opts.c (c_common_parse_file): Remove extra"}, {"sha": "3a6b92500b6e1effd7053d061f8c77d2f505f162", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 142, "deletions": 14, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d28e87da7134b1ba6de7add4457a8b20687edd3/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d28e87da7134b1ba6de7add4457a8b20687edd3/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=8d28e87da7134b1ba6de7add4457a8b20687edd3", "patch": "@@ -985,7 +985,9 @@ duplicate_insn_chain (rtx from, rtx to)\n   delete_insn (last);\n   return insn;\n }\n-/* Create a duplicate of the basic block BB and redirect edge E into it.  */\n+/* Create a duplicate of the basic block BB and redirect edge E into it.\n+   If E is not specified, BB is just copied, but updating the frequencies\n+   etc. is left to the caller.  */\n \n basic_block\n cfg_layout_duplicate_bb (basic_block bb, edge e)\n@@ -1046,32 +1048,41 @@ cfg_layout_duplicate_bb (basic_block bb, edge e)\n \t is no need to actually check for duplicated edges.  */\n       n = unchecked_make_edge (new_bb, s->dest, s->flags);\n       n->probability = s->probability;\n-      if (new_count)\n-\t/* Take care for overflows!  */\n-\tn->count = s->count * (new_count * 10000 / bb->count) / 10000;\n+      if (e && bb->count)\n+\t{\n+\t  /* Take care for overflows!  */\n+\t  n->count = s->count * (new_count * 10000 / bb->count) / 10000;\n+\t  s->count -= n->count;\n+\t}\n       else\n-\tn->count = 0;\n-      s->count -= n->count;\n+\tn->count = s->count;\n+      n->aux = s->aux;\n     }\n \n-  new_bb->count = new_count;\n-  bb->count -= new_count;\n-\n   if (e)\n     {\n+      new_bb->count = new_count;\n+      bb->count -= new_count;\n+\n       new_bb->frequency = EDGE_FREQUENCY (e);\n       bb->frequency -= EDGE_FREQUENCY (e);\n \n       redirect_edge_and_branch_force (e, new_bb);\n-    }\n \n-  if (bb->count < 0)\n-    bb->count = 0;\n-  if (bb->frequency < 0)\n-    bb->frequency = 0;\n+      if (bb->count < 0)\n+\tbb->count = 0;\n+      if (bb->frequency < 0)\n+\tbb->frequency = 0;\n+    }\n+  else\n+    {\n+      new_bb->count = bb->count;\n+      new_bb->frequency = bb->frequency;\n+    }\n \n   new_bb->rbi->original = bb;\n   bb->rbi->copy = new_bb;\n+\n   return new_bb;\n }\n \f\n@@ -1167,4 +1178,121 @@ cfg_layout_finalize (void)\n #endif\n }\n \n+/* Checks whether all N blocks in BBS array can be copied.  */\n+bool\n+can_copy_bbs_p (basic_block *bbs, unsigned n)\n+{\n+  unsigned i;\n+  edge e;\n+  int ret = true;\n+\n+  for (i = 0; i < n; i++)\n+    bbs[i]->rbi->duplicated = 1;\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      /* In case we should redirect abnormal edge during duplication, fail.  */\n+      for (e = bbs[i]->succ; e; e = e->succ_next)\n+\tif ((e->flags & EDGE_ABNORMAL)\n+\t    && e->dest->rbi->duplicated)\n+\t  {\n+\t    ret = false;\n+\t    goto end;\n+\t  }\n+\n+      if (!cfg_layout_can_duplicate_bb_p (bbs[i]))\n+\t{\n+\t  ret = false;\n+\t  break;\n+\t}\n+    }\n+\n+end:\n+  for (i = 0; i < n; i++)\n+    bbs[i]->rbi->duplicated = 0;\n+\n+  return ret;\n+}\n+\n+/* Duplicates N basic blocks stored in array BBS.  Newly created basic blocks\n+   are placed into array NEW_BBS in the same order.  Edges from basic blocks\n+   in BBS are also duplicated and copies of those of them\n+   that lead into BBS are redirected to appropriate newly created block.  The\n+   function assigns bbs into loops (copy of basic block bb is assigned to\n+   bb->loop_father->copy loop, so this must be set up correctly in advance)\n+   and updates dominators locally (LOOPS structure that contains the information\n+   about dominators is passed to enable this).\n+\n+   BASE is the superloop to that basic block belongs; if its header or latch\n+   is copied, we do not set the new blocks as header or latch.\n+\n+   Created copies of N_EDGES edges in array EDGES are stored in array NEW_EDGES,\n+   also in the same order.  */\n+\n+void\n+copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n+\t  edge *edges, unsigned n_edges, edge *new_edges,\n+\t  struct loop *base, struct loops *loops)\n+{\n+  unsigned i, j;\n+  basic_block bb, new_bb, dom_bb;\n+  edge e;\n+\n+  /* Duplicate bbs, update dominators, assign bbs to loops.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      /* Duplicate.  */\n+      bb = bbs[i];\n+      new_bb = new_bbs[i] = cfg_layout_duplicate_bb (bb, NULL);\n+      bb->rbi->duplicated = 1;\n+      /* Add to loop.  */\n+      add_bb_to_loop (new_bb, bb->loop_father->copy);\n+      add_to_dominance_info (loops->cfg.dom, new_bb);\n+      /* Possibly set header.  */\n+      if (bb->loop_father->header == bb && bb->loop_father != base)\n+\tnew_bb->loop_father->header = new_bb;\n+      /* Or latch.  */\n+      if (bb->loop_father->latch == bb && bb->loop_father != base)\n+\tnew_bb->loop_father->latch = new_bb;\n+    }\n+\n+  /* Set dominators.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      bb = bbs[i];\n+      new_bb = new_bbs[i];\n+\n+      dom_bb = get_immediate_dominator (loops->cfg.dom, bb);\n+      if (dom_bb->rbi->duplicated)\n+\t{\n+\t  dom_bb = dom_bb->rbi->copy;\n+\t  set_immediate_dominator (loops->cfg.dom, new_bb, dom_bb);\n+\t}\n+    }\n+\n+  /* Redirect edges.  */\n+  for (j = 0; j < n_edges; j++)\n+    new_edges[j] = NULL;\n+  for (i = 0; i < n; i++)\n+    {\n+      new_bb = new_bbs[i];\n+      bb = bbs[i];\n+\n+      for (e = new_bb->succ; e; e = e->succ_next)\n+\t{\n+\t  for (j = 0; j < n_edges; j++)\n+\t    if (edges[j] && edges[j]->src == bb && edges[j]->dest == e->dest)\n+\t      new_edges[j] = e;\n+\n+\t  if (!e->dest->rbi->duplicated)\n+\t    continue;\n+\t  redirect_edge_and_branch_force (e, e->dest->rbi->copy);\n+\t}\n+    }\n+\n+  /* Clear information about duplicates.  */\n+  for (i = 0; i < n; i++)\n+    bbs[i]->rbi->duplicated = 0;\n+}\n+\n #include \"gt-cfglayout.h\""}, {"sha": "3258fe8fba568a7ef500baeef5a9e71ecb453e9d", "filename": "gcc/cfglayout.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d28e87da7134b1ba6de7add4457a8b20687edd3/gcc%2Fcfglayout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d28e87da7134b1ba6de7add4457a8b20687edd3/gcc%2Fcfglayout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.h?ref=8d28e87da7134b1ba6de7add4457a8b20687edd3", "patch": "@@ -41,4 +41,7 @@ extern bool cfg_layout_can_duplicate_bb_p (basic_block);\n extern basic_block cfg_layout_duplicate_bb (basic_block, edge);\n extern void insn_locators_initialize (void);\n extern void reemit_insn_block_notes (void);\n+extern bool can_copy_bbs_p (basic_block *, unsigned);\n+extern void copy_bbs (basic_block *, unsigned, basic_block *,\n+\t\t      edge *, unsigned, edge *, struct loop *, struct loops *);\n extern void cfg_layout_initialize_rbi\t(basic_block);"}, {"sha": "fac614ff28b9f718098afc92db76c4ea91e3c3c6", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d28e87da7134b1ba6de7add4457a8b20687edd3/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d28e87da7134b1ba6de7add4457a8b20687edd3/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=8d28e87da7134b1ba6de7add4457a8b20687edd3", "patch": "@@ -960,7 +960,9 @@ glb_enum_p (basic_block bb, void *glb_header)\n   return bb != (basic_block) glb_header;\n }\n \n-/* Gets basic blocks of a loop.  */\n+/* Gets basic blocks of a LOOP.  Header is the 0-th block, rest is in dfs\n+   order against direction of edges from latch.  Specially, if\n+   header != latch, latch is the 1-st block.  */\n basic_block *\n get_loop_body (const struct loop *loop)\n {"}, {"sha": "31ecc6cfe9762f6905ac0602c78aba39761a1fae", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 84, "deletions": 273, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d28e87da7134b1ba6de7add4457a8b20687edd3/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d28e87da7134b1ba6de7add4457a8b20687edd3/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=8d28e87da7134b1ba6de7add4457a8b20687edd3", "patch": "@@ -36,8 +36,6 @@ static void copy_loops_to (struct loops *, struct loop **, int,\n \t\t\t   struct loop *);\n static void loop_redirect_edge (edge, basic_block);\n static bool loop_delete_branch_edge (edge, int);\n-static void copy_bbs (basic_block *, int, edge, edge, basic_block **,\n-\t\t      struct loops *, edge *, edge *, int);\n static void remove_bbs (dominance_info, basic_block *, int);\n static bool rpe_enum_p (basic_block, void *);\n static int find_path (edge, dominance_info, basic_block **);\n@@ -49,8 +47,6 @@ static void fix_bb_placements (struct loops *, basic_block);\n static void place_new_loop (struct loops *, struct loop *);\n static void scale_loop_frequencies (struct loop *, int, int);\n static void scale_bbs_frequencies (basic_block *, int, int, int);\n-static void record_exit_edges (edge, basic_block *, int, edge *, unsigned *,\n-\t\t\t       int);\n static basic_block create_preheader (struct loop *, dominance_info, int);\n static void fix_irreducible_loops (basic_block);\n \n@@ -820,219 +816,31 @@ loop_delete_branch_edge (edge e, int really_delete)\n   return false;  /* To avoid warning, cannot get here.  */\n }\n \n-/* Duplicates N basic blocks stored in array BBS (they form a body of\n-   duplicated loop).  Newly created basic blocks are placed into array NEW_BBS\n-   that we allocate.  Edges from basic blocks in BBS are also duplicated and\n-   copies of those of them that lead into BBS are redirected to appropriate\n-   newly created block.  The function also assigns bbs into loops and updates\n-   dominators.  If ADD_IRREDUCIBLE_FLAG is set, newly created basic blocks that\n-   are not members of any inner loop are marked irreducible.\n-\n-   Additionally, we perform following manipulation with edges:\n-   We have two special edges given. LATCH_EDGE is the latch edge of the\n-   duplicated loop and leads into its header (one of blocks in BBS);\n-   it does not have necessarily lead from one of the blocks, because\n-   we may be copying the loop body several times in unrolling.\n-   Edge ENTRY leads also leads to header, and it is either latch or entry\n-   edge.  Copy of LATCH_EDGE is redirected to header and is stored in\n-   HEADER_EDGE, the ENTRY edge is redirected into copy of header and\n-   returned as COPY_HEADER_EDGE.  The effect is following:\n-   if LATCH_EDGE == ENTRY, then the loop is unrolled by one copy,\n-     HEADER_EDGE is latch of a new loop, COPY_HEADER_EDGE leads from original\n-     latch source to first block in copy.\n-   if LATCH_EDGE != ENTRY, then the loop is peeled by one copy,\n-     HEADER_EDGE is entry edge of the loop, COPY_HEADER_EDGE leads from\n-     original entry block to first block in peeled copy.\n- */\n-static void\n-copy_bbs (basic_block *bbs, int n, edge entry, edge latch_edge,\n-\t  basic_block **new_bbs, struct loops *loops, edge *header_edge,\n-\t  edge *copy_header_edge, int add_irreducible_flag)\n-{\n-  int i;\n-  basic_block bb, new_bb, header = entry->dest, dom_bb;\n-  edge e;\n-\n-  /* Duplicate bbs, update dominators, assign bbs to loops.  */\n-  (*new_bbs) = xcalloc (n, sizeof (basic_block));\n-  for (i = 0; i < n; i++)\n-    {\n-      /* Duplicate.  */\n-      bb = bbs[i];\n-      new_bb = (*new_bbs)[i] = cfg_layout_duplicate_bb (bb, NULL);\n-      new_bb->rbi->duplicated = 1;\n-      /* Add to loop.  */\n-      add_bb_to_loop (new_bb, bb->loop_father->copy);\n-      add_to_dominance_info (loops->cfg.dom, new_bb);\n-      /* Possibly set header.  */\n-      if (bb->loop_father->header == bb && bb != header)\n-\tnew_bb->loop_father->header = new_bb;\n-      /* Or latch.  */\n-      if (bb->loop_father->latch == bb &&\n-\t  bb->loop_father != header->loop_father)\n-\tnew_bb->loop_father->latch = new_bb;\n-      /* Take care of irreducible loops.  */\n-      if (add_irreducible_flag\n-\t  && bb->loop_father == header->loop_father)\n-\tnew_bb->flags |= BB_IRREDUCIBLE_LOOP;\n-    }\n-\n-  /* Set dominators.  */\n-  for (i = 0; i < n; i++)\n-    {\n-      bb = bbs[i];\n-      new_bb = (*new_bbs)[i];\n-      if (bb != header)\n-\t{\n-\t  /* For anything else than loop header, just copy it.  */\n-\t  dom_bb = get_immediate_dominator (loops->cfg.dom, bb);\n-\t  dom_bb = dom_bb->rbi->copy;\n-\t}\n-      else\n-\t{\n-\t  /* Copy of header is dominated by entry source.  */\n-\t  dom_bb = entry->src;\n-\t}\n-      if (!dom_bb)\n-\tabort ();\n-      set_immediate_dominator (loops->cfg.dom, new_bb, dom_bb);\n-    }\n-\n-  /* Redirect edges.  */\n-  for (i = 0; i < n; i++)\n-    {\n-      edge e_pred;\n-      new_bb = (*new_bbs)[i];\n-      bb = bbs[i];\n-      for (e = bb->pred; e; e = e_pred)\n-\t{\n-\t  basic_block src = e->src;\n-\n-\t  e_pred = e->pred_next;\n-\n-\t  if (!src->rbi->duplicated)\n-\t    continue;\n-\n-\t  /* Leads to copied loop and it is not latch edge, redirect it.  */\n-\t  if (bb != header)\n-\t    loop_redirect_edge (e, new_bb);\n-\n-\t  if (add_irreducible_flag\n-\t      && (bb->loop_father == header->loop_father\n-\t\t  || src->rbi->original->loop_father == header->loop_father))\n-\t    e->flags |= EDGE_IRREDUCIBLE_LOOP;\n-\t}\n-    }\n-\n-  /* Redirect header edge.  */\n-  bb = latch_edge->src->rbi->copy;\n-  for (e = bb->succ; e->dest != latch_edge->dest; e = e->succ_next);\n-  *header_edge = e;\n-  loop_redirect_edge (*header_edge, header);\n-\n-  /* Redirect entry to copy of header.  */\n-  loop_redirect_edge (entry, header->rbi->copy);\n-  *copy_header_edge = entry;\n-\n-  /* Clear information about duplicates.  */\n-  for (i = 0; i < n; i++)\n-    (*new_bbs)[i]->rbi->duplicated = 0;\n-}\n-\n /* Check whether LOOP's body can be duplicated.  */\n bool\n can_duplicate_loop_p (struct loop *loop)\n {\n-  basic_block *bbs;\n-  unsigned i;\n-\n-  bbs = get_loop_body (loop);\n-\n-  for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      edge e;\n-\n-      /* In case loop contains abnormal edge we can not redirect,\n-         we can't perform duplication.  */\n-\n-      for (e = bbs[i]->succ; e; e = e->succ_next)\n-\tif ((e->flags & EDGE_ABNORMAL)\n-\t    && flow_bb_inside_loop_p (loop, e->dest))\n-\t  {\n-\t    free (bbs);\n-\t    return false;\n-\t  }\n+  int ret;\n+  basic_block *bbs = get_loop_body (loop);\n \n-      if (!cfg_layout_can_duplicate_bb_p (bbs[i]))\n-\t{\n-\t  free (bbs);\n-\t  return false;\n-\t}\n-    }\n+  ret = can_copy_bbs_p (bbs, loop->num_nodes);\n   free (bbs);\n-\n-  return true;\n-}\n-\n-/* Record edges, leading from NBBS basic blocks stored in BBS, that were created\n-   by copying ORIG edge (or just ORIG edge if IS_ORIG is set).\n-   If ORIG is NULL, then record all edges coming outside of BBS. Store them\n-   into TO_REMOVE array that must be large enough to hold them all; their\n-   number is returned in N_TO_REMOVE.  */\n-static void\n-record_exit_edges (edge orig, basic_block *bbs, int nbbs, edge *to_remove,\n-\t\t   unsigned int *n_to_remove, int is_orig)\n-{\n-  sbitmap my_blocks;\n-  int i;\n-  edge e;\n-\n-  if (orig)\n-    {\n-      if (is_orig)\n-\t{\n-\t  to_remove[(*n_to_remove)++] = orig;\n-\t  return;\n-\t}\n-\n-      for (e = orig->src->rbi->copy->succ; e; e = e->succ_next)\n-\tif (e->dest == orig->dest)\n-\t  break;\n-      if (!e)\n-\tabort ();\n-\n-      to_remove[(*n_to_remove)++] = e;\n-    }\n-  else\n-    {\n-      my_blocks = sbitmap_alloc (last_basic_block);\n-      sbitmap_zero (my_blocks);\n-      for (i = 0; i < nbbs; i++)\n-        SET_BIT (my_blocks, bbs[i]->index);\n-\n-      for (i = 0; i < nbbs; i++)\n-\tfor (e = bbs[i]->succ; e; e = e->succ_next)\n-\t  if (e->dest == EXIT_BLOCK_PTR ||\n-\t      !TEST_BIT (my_blocks, e->dest->index))\n-\t    to_remove[(*n_to_remove)++] = e;\n-\n-      free (my_blocks);\n-    }\n+  \n+  return ret;\n }\n \n-\n #define RDIV(X,Y) (((X) + (Y) / 2) / (Y))\n \n-/* Duplicates body of LOOP to given edge E NDUPL times.  Takes care of\n-   updating LOOPS structure and dominators.  E's destination must be LOOP\n-   header for this to work, i.e. it must be entry or latch edge of this loop;\n-   these are unique, as the loops must have preheaders for this function to\n-   work correctly (in case E is latch, the function unrolls the loop, if E is\n-   entry edge, it peels the loop).  Store edges created by copying ORIG edge\n-   (if NULL, then all edges leaving loop) from copies corresponding to set\n-   bits in WONT_EXIT bitmap (bit 0 corresponds to original LOOP body, the\n-   other copies are numbered in order given by control flow through them)\n-   into TO_REMOVE array.  Returns false if duplication is impossible.  */\n+/* Duplicates body of LOOP to given edge E NDUPL times.  Takes care of updating\n+   LOOPS structure and dominators.  E's destination must be LOOP header for\n+   this to work, i.e. it must be entry or latch edge of this loop; these are\n+   unique, as the loops must have preheaders for this function to work\n+   correctly (in case E is latch, the function unrolls the loop, if E is entry\n+   edge, it peels the loop).  Store edges created by copying ORIG edge from\n+   copies corresponding to set bits in WONT_EXIT bitmap (bit 0 corresponds to\n+   original LOOP body, the other copies are numbered in order given by control\n+   flow through them) into TO_REMOVE array.  Returns false if duplication is\n+   impossible.  */\n int\n duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n \t\t\t       unsigned int ndupl, sbitmap wont_exit,\n@@ -1045,7 +853,10 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n   basic_block header = loop->header, latch = loop->latch;\n   basic_block *new_bbs, *bbs, *first_active;\n   basic_block new_bb, bb, first_active_latch = NULL;\n-  edge ae, latch_edge, he;\n+  edge ae, latch_edge;\n+  edge spec_edges[2], new_spec_edges[2];\n+#define SE_LATCH 0\n+#define SE_ORIG 1\n   unsigned i, j, n;\n   int is_latch = (latch == e->src);\n   int scale_act = 0, *scale_step = NULL, scale_main = 0;\n@@ -1070,17 +881,18 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n   bbs = get_loop_body (loop);\n \n   /* Check whether duplication is possible.  */\n-\n-  for (i = 0; i < loop->num_nodes; i++)\n+  if (!can_copy_bbs_p (bbs, loop->num_nodes))\n     {\n-      if (!cfg_layout_can_duplicate_bb_p (bbs[i]))\n-\t{\n-\t  free (bbs);\n-\t  return false;\n-\t}\n+      free (bbs);\n+      return false;\n     }\n+  new_bbs = xmalloc (sizeof (basic_block) * loop->num_nodes);\n \n-  add_irreducible_flag = !is_latch && (e->flags & EDGE_IRREDUCIBLE_LOOP);\n+  /* In case we are doing loop peeling and the loop is in the middle of\n+     irreducible region, the peeled copies will be inside it too.  */\n+  add_irreducible_flag = e->flags & EDGE_IRREDUCIBLE_LOOP;\n+  if (is_latch && add_irreducible_flag)\n+    abort ();\n \n   /* Find edge from latch.  */\n   latch_edge = loop_latch_edge (loop);\n@@ -1140,7 +952,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n     }\n \n   /* Loop the new bbs will belong to.  */\n-  target = find_common_loop (e->src->loop_father, e->dest->loop_father);\n+  target = e->src->loop_father;\n \n   /* Original loops.  */\n   n_orig_loops = 0;\n@@ -1152,98 +964,97 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n \n   loop->copy = target;\n \n-  /* Original basic blocks.  */\n   n = loop->num_nodes;\n \n-  first_active = xcalloc(n, sizeof (basic_block));\n+  first_active = xmalloc (n * sizeof (basic_block));\n   if (is_latch)\n     {\n       memcpy (first_active, bbs, n * sizeof (basic_block));\n       first_active_latch = latch;\n     }\n \n-  /* Record exit edges in original loop body.  */\n-  if (TEST_BIT (wont_exit, 0))\n-    record_exit_edges (orig, bbs, n, to_remove, n_to_remove, true);\n+  /* Record exit edge in original loop body.  */\n+  if (orig && TEST_BIT (wont_exit, 0))\n+    to_remove[(*n_to_remove)++] = orig;\n+\n+  spec_edges[SE_ORIG] = orig;\n+  spec_edges[SE_LATCH] = latch_edge;\n \n   for (j = 0; j < ndupl; j++)\n     {\n       /* Copy loops.  */\n       copy_loops_to (loops, orig_loops, n_orig_loops, target);\n \n       /* Copy bbs.  */\n-      copy_bbs (bbs, n, e, latch_edge, &new_bbs, loops,\n-\t\t&e, &he, add_irreducible_flag);\n+      copy_bbs (bbs, n, new_bbs, spec_edges, 2, new_spec_edges, loop, loops);\n+\n+      /* Redirect the special edges.  */\n       if (is_latch)\n-\tloop->latch = latch->rbi->copy;\n+\t{\n+\t  redirect_edge_and_branch_force (latch_edge, new_bbs[0]);\n+\t  redirect_edge_and_branch_force (new_spec_edges[SE_LATCH],\n+\t\t\t\t\t  loop->header);\n+\t  set_immediate_dominator (loops->cfg.dom, new_bbs[0], latch);\n+\t  latch = loop->latch = new_bbs[1];\n+\t  e = latch_edge = new_spec_edges[SE_LATCH];\n+\t}\n+      else\n+\t{\n+\t  redirect_edge_and_branch_force (new_spec_edges[SE_LATCH],\n+\t\t\t\t\t  loop->header);\n+\t  redirect_edge_and_branch_force (e, new_bbs[0]);\n+\t  set_immediate_dominator (loops->cfg.dom, new_bbs[0], e->src);\n+\t  e = new_spec_edges[SE_LATCH];\n+\t}\n \n-      /* Record exit edges in this copy.  */\n-      if (TEST_BIT (wont_exit, j + 1))\n-\trecord_exit_edges (orig, new_bbs, n, to_remove, n_to_remove, false);\n+      /* Record exit edge in this copy.  */\n+      if (orig && TEST_BIT (wont_exit, j + 1))\n+\tto_remove[(*n_to_remove)++] = new_spec_edges[SE_ORIG];\n \n-      /* Set counts and frequencies.  */\n-      for (i = 0; i < n; i++)\n+      /* Note whether the blocks and edges belong to an irreducible loop.  */\n+      if (add_irreducible_flag)\n \t{\n-\t  new_bb = new_bbs[i];\n-\t  bb = bbs[i];\n-\n-\t  if (flags & DLTHE_FLAG_UPDATE_FREQ)\n+\t  for (i = 0; i < n; i++)\n \t    {\n-\t      new_bb->count = RDIV (scale_act * bb->count, REG_BR_PROB_BASE);\n-\t      new_bb->frequency = RDIV (scale_act * bb->frequency,\n-\t\t\t\t\tREG_BR_PROB_BASE);\n+\t      new_bb = new_bbs[i];\n+\t      if (new_bb->loop_father == target)\n+\t\tnew_bb->flags |= BB_IRREDUCIBLE_LOOP;\n+\n+\t      for (ae = new_bb->succ; ae; ae = ae->succ_next)\n+\t\tif (ae->src->loop_father == target\n+\t\t    || ae->dest->loop_father == target)\n+\t\t  ae->flags |= EDGE_IRREDUCIBLE_LOOP;\n \t    }\n-\t  else\n-\t    {\n-\t      new_bb->count = bb->count;\n-\t      new_bb->frequency = bb->frequency;\n-\t    }\n-\n-\t  for (ae = new_bb->succ; ae; ae = ae->succ_next)\n-\t    ae->count = RDIV (new_bb->count * ae->probability,\n-\t\t\t      REG_BR_PROB_BASE);\n \t}\n-      if (flags & DLTHE_FLAG_UPDATE_FREQ)\n-\tscale_act = RDIV (scale_act * scale_step[j], REG_BR_PROB_BASE);\n \n+      /* Record the first copy in the control flow order if it is not\n+\t the original loop (i.e. in case of peeling).  */\n       if (!first_active_latch)\n \t{\n \t  memcpy (first_active, new_bbs, n * sizeof (basic_block));\n-\t  first_active_latch = latch->rbi->copy;\n+\t  first_active_latch = new_bbs[1];\n \t}\n \n-      free (new_bbs);\n-\n-      /* Original loop header is dominated by latch copy\n-\t if we duplicated on its only entry edge.  */\n-      if (!is_latch && !header->pred->pred_next->pred_next)\n-\tset_immediate_dominator (loops->cfg.dom, header, latch->rbi->copy);\n-      if (is_latch && j == 0)\n+      /* Set counts and frequencies.  */\n+      if (flags & DLTHE_FLAG_UPDATE_FREQ)\n \t{\n-\t  /* Update edge from latch.  */\n-\t  for (latch_edge = header->rbi->copy->pred;\n-\t       latch_edge->src != latch;\n-\t       latch_edge = latch_edge->pred_next);\n+\t  scale_bbs_frequencies (new_bbs, n, scale_act, REG_BR_PROB_BASE);\n+\t  scale_act = RDIV (scale_act * scale_step[j], REG_BR_PROB_BASE);\n \t}\n     }\n-  /* Now handle original loop.  */\n-\n-  /* Update edge counts.  */\n+  free (new_bbs);\n+  free (orig_loops);\n+  \n+  /* Update the original loop.  */\n+  if (!is_latch)\n+    set_immediate_dominator (loops->cfg.dom, e->dest, e->src);\n   if (flags & DLTHE_FLAG_UPDATE_FREQ)\n     {\n-      for (i = 0; i < n; i++)\n-\t{\n-\t  bb = bbs[i];\n-\t  bb->count = RDIV (scale_main * bb->count, REG_BR_PROB_BASE);\n-\t  bb->frequency = RDIV (scale_main * bb->frequency, REG_BR_PROB_BASE);\n-\t  for (ae = bb->succ; ae; ae = ae->succ_next)\n-\t    ae->count = RDIV (bb->count * ae->probability, REG_BR_PROB_BASE);\n-\t}\n+      scale_bbs_frequencies (bbs, n, scale_main, REG_BR_PROB_BASE);\n       free (scale_step);\n     }\n-  free (orig_loops);\n \n-  /* Update dominators of other blocks if affected.  */\n+  /* Update dominators of outer blocks if affected.  */\n   for (i = 0; i < n; i++)\n     {\n       basic_block dominated, dom_bb, *dom_bbs;"}]}