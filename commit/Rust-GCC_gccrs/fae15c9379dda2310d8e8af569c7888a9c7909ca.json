{"sha": "fae15c9379dda2310d8e8af569c7888a9c7909ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFlMTVjOTM3OWRkYTIzMTBkOGU4YWY1NjljNzg4OGE5Yzc5MDljYQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2002-04-29T22:34:36Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2002-04-29T22:34:36Z"}, "message": "2002-04-29  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tMerging code from dfa-branch:\n\nFrom-SVN: r52915", "tree": {"sha": "711c3d2354156033007c12671e96ba4e545ef452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/711c3d2354156033007c12671e96ba4e545ef452"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fae15c9379dda2310d8e8af569c7888a9c7909ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fae15c9379dda2310d8e8af569c7888a9c7909ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fae15c9379dda2310d8e8af569c7888a9c7909ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fae15c9379dda2310d8e8af569c7888a9c7909ca/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a2ff290c023adcda10f3dec64397812c907c4f48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2ff290c023adcda10f3dec64397812c907c4f48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2ff290c023adcda10f3dec64397812c907c4f48"}], "stats": {"total": 14192, "additions": 12622, "deletions": 1570}, "files": [{"sha": "8160501c622a3ac70b742fd308b4845c91a564c3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 362, "deletions": 0, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -1,3 +1,365 @@\n+2002-04-29  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tMerging code from dfa-branch:\n+\t\n+\t2002-04-24  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c (output_reserv_sets): Fix typo.\n+\n+\t2002-04-23  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c (output_reserv_sets): Remove\n+\tnext_cycle_output_flag.\n+\n+\tThu Apr 18 08:57:06 2002  Jeffrey A Law  (law@redhat.com)\n+\n+        * sched-rgn.c (init_ready_list): Make the DFA code handle\n+        USE/CLOBBER insns in the same way as the traditional\n+        scheduler.\n+        (new_ready): Similarly..\n+\n+\t2002-04-17  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* haifa-sched.c (schedule_block): Change the DFA state only after\n+\tissuing insn.\n+\n+\tWed Apr 17 15:38:36 2002  Jeffrey A Law  (law@redhat.com)\n+\n+\t* pa.c (hppa_use_dfa_pipeline_interface): New function.\n+\t(TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE): Define.\n+\t(override_options): Add PA7300 scheduling support.\n+\t(pa_adjust_cost): Update various comments.  Properly\n+\thandle anti and output dependencies when using the\n+\tDFA scheduler.\n+\t(pa_issue_rate): Add PA7300 scheduling support.\n+\t(pa_can_combine_p): Call extract_insn before calling\n+\tconstrain_operands (taken from mainline tree).\n+\t* pa.h (enum processor_type): Add PROCESSOR_PA7300.\n+\t* pa.md (cpu attr): Add 7300.  Rewrite pipeline\n+\tdescriptions using DFA descriptions.  Add PA7300\n+\tscheduling support.\n+\n+\t2002-03-30  David S. Miller  <davem@redhat.com>\n+\n+\tAdd UltraSPARC-III DFA scheduling support.\n+\t* config/sparc/sparc.md (define_attr type): Add fpcrmove.\n+\tUpdate FP conditional move on register insn patterns to use it, as\n+\tappropriate.\n+\t(define_attr cpu): Add ultrasparc3.\n+\t(define_attr us3load_type): New, update integer load patterns to\n+\tset it, as appropriate.\n+\t(define_automaton): Add ultrasparc3_0 and ultrasparc3_1.\n+\t(rest): Add UltraSPARC3 scheduling description.\n+\t* config/sparc/sparc.h (TARGET_CPU_ultrasparc3): New.\n+\t(PROCESSOR_ULTRASPARC3): New.\n+\t({ASM,CPP}_CPU64_DEFAULT_SPEC): Handle ultrasparc3.\n+\t({ASM,CPP}_CPU_SPEC): Likewise.\n+\t(REGISTER_MOVE_COST): Likewise.\n+\t(RTX_COSTS): Likewise.\n+\t* config/sparc/sparc.c (sparc_override_options,\n+\tsparc_initialize_trampoline, sparc64_initialize_trampoline,\n+\tsparc_use_dfa_pipeline_interface, sparc_use_sched_lookahead,\n+\tsparc_issue_rate): Likewise.\n+\t* config/sparc/sol2.h: Likewise.\n+\t* config/sparc/sol2-sld-64.h: Likewise.\n+\t* config/sparc/linux64.h: Likewise.\n+\t\n+\t2002-03-22  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* doc/md.texi: Add comments about usage the latency time for the\n+\tdifferent dependencies and about case when two or more conditions\n+\tin different define_insn_reservations returns TRUE for an insn.\n+\n+\t* doc/md.texi: Add reference for automaton based pipeline\n+\tdescription.\n+\t\n+\t2002-03-04  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* doc/passes.texi: Add missed information about genattrtab.\n+\n+\t2002-03-01  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c (output_automata_list_transition_code): Check\n+\tautomata_list on NULL.\n+\n+\t2002-02-28  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c (output_insn_code_cases,\n+\toutput_automata_list_min_issue_delay_code,\n+\toutput_automata_list_transition_code,\n+\toutput_automata_list_state_alts_code): Comment the functions.\n+\n+\t2002-02-22  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c (automata_list_el_t): New typedef.\n+\t(get_free_automata_list_el,free_automata_list_el,\n+\tfree_automata_list, automata_list_hash, automata_list_eq_p,\n+\tinitiate_automata_lists, automata_list_start, automata_list_add,\n+\tautomata_list_finish, finish_automata_lists,\n+\toutput_insn_code_cases, output_automata_list_min_issue_delay_code,\n+\toutput_automata_list_transition_code,\n+\toutput_automata_list_state_alts_code, add_automaton_state,\n+\tform_important_insn_automata_lists): New functions and prototypes.\n+\t(insn_reserv_decl): Add members important_automata_list and\n+\tprocessed_p.\n+\t(ainsn): Add members important_p.\n+\t(automata_list_el): New structure.\n+\t(first_free_automata_list_el, current_automata_list,\n+\tautomata_list_table): New global variables.\n+\t(create_ainsns): Initiate member important_p.\n+\t(output_internal_min_issue_delay_func): Generate the switch and\n+\tcall output_insn_code_cases.\n+\t(output_internal_trans_func, output_internal_state_alts_func):\n+\tDitto.\n+\t(generate): Call initiate_automata_lists.\n+\t(automaton_states): New global variable.\n+\t(expand_automata): Call form_important_insn_automata_lists.\n+\t(write_automata): Call finish_automata_lists.\n+\t\n+\t2002-02-21  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c (add_excls, add_presence_absence): Check that\n+        cpu units in the sets belong the same automaton.\n+\n+\t* rtl.def (EXCLUSION_SET, PRESENCE_SET, ABSENCE_SET): Add comment\n+\tabout that cpu units in the sets belong the same automaton.\n+\n+\t* doc/md.texi: Ditto.\n+\t\n+\t2001-12-20  Naveen Sharma,Nitin Gupta     <naveens@noida.hcltech.com,niting@noida.hcltech.com>\n+\n+\t* config/sh/sh.c (sh_use_dfa_interface): New function.\n+\n+\t(sh_issue_rate): New Function.\n+\tTARGET_SCHED_USE_DFA_PIPELINE_INTERFACE: define.\n+\tTARGET_SCHED_ISSUE_RATE: define.\n+\n+\t* config/sh/sh.md: Add DFA based pipeline description for SH4.\n+\n+\t(define_attr insn_class): New attribute used for DFA \n+         scheduling.\n+\t(define_insn cmpgtsi_t): Set attribute insn_class mt_group.\n+\t(cmpgesi_t,cmpgtusi_t,cmpgeusi_t,cmpeqsi_t,\n+\t cmpeqdi_t): Likewise.\n+\n+\t(add,addc1,addsi3,subc,subc1,*subsi3_internal,\n+\t negc,negsi2,ashldi3_k,lshrdi3_k,ashrdi3_k): Set insn_class \n+\t ex_group.\n+\t(iorsi3,rotlsi3_1,rotlsi3_31,rotlsi3_16): Likewise.\n+\t   \n+\t2001-10-03  Vladimir Makarov  <vmakarov@toke.toronto.redhat.com>\n+\n+\t* haifa-sched.c (queue_to_ready): Remove unnecessary condition for\n+\tbreak.\n+\n+\t2001-10-03  Vladimir Makarov  <vmakarov@toke.toronto.redhat.com>\n+\n+\t* genautomata.c (DFA_INSN_CODES_LENGTH_VARIABLE_NAME): New macro.\n+\t(output_dfa_insn_code_func): Expand dfa_insn_codes if it is\n+\tnecessary.\n+\t(output_dfa_start_func): Initiate new variable insn_codes_length,\n+\t(write_automata): Output definition of the new variable.\n+\t\n+\t2001-10-02  David S. Miller  <davem@redhat.com>\n+\n+\t* haifa-sched.c (advance_one_cycle): New function.\n+\t(schedule_block): Use it.\n+\t(queue_to_ready): Use it, and also make sure to advance the DFA\n+\tstate on all stall cycles, not just those where insn_queue links\n+\tare found.\n+\n+\t2001-10-02  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* haifa-sched.c (max_issue): Remove last_p argument.  Only return\n+\tnon-zero if the highest-priority instruction could be scheduled.\n+\t(choose_ready): Remove last argument from max_issue call.\n+\n+\t2001-09-28  David S. Miller  <davem@redhat.com>\n+\n+\t* config/sparc/sparc.c (sparc_use_sched_lookahead): Use 4 for\n+\tultrasparc and 3 for other multi-issue sparcs.\n+\n+\t2001-09-27  David S. Miller  <davem@redhat.com>\n+\n+\t* config/sparc/sparc.md (cycle_display): New pattern.\n+\t* config/sparc/sparc.c (sparc_cycle_display): New.\n+\t(TARGET_SCHED_CYCLE_DISPLAY): Set it.\n+\n+\t2001-09-25  David S. Miller  <davem@redhat.com>\n+\n+\tConvert all of Sparc scheduling to DFA\n+\t* config/sparc/sparc.md: Kill all define_function_unit\n+\tdirectives and replace with DFA equivalent.\n+\t* config/sparc/sparc.c (ultrasparc_adjust_cost,\n+\tmark_ultrasparc_pipeline_state, ultra_cmove_results_ready_p,\n+\tultra_fpmode_conflict_exists, ultra_find_type,\n+\tultra_build_types_avail, ultra_flush_pipeline,\n+\tultra_rescan_pipeline_state, ultrasparc_sched_reorder,\n+\tultrasparc_variable_issue, ultrasparc_sched_init,\n+\tsparc_variable_issue, sparc_sched_reorder, ultra_code_from_mask,\n+\tultra_schedule_insn, ultra_code_names, ultra_pipe_hist,\n+\tultra_cur_hist, ultra_cycles_elapsed): Kill.\n+\t(sparc_use_dfa_pipeline_interface, sparc_use_sched_lookahead,\n+\tultrasparc_store_bypass_p): New.\n+\t* config/sparc/sparc-protos.h (ultrasparc_store_bypass_p):\n+\tDeclare.\n+\n+\t2001-09-24  David S. Miller  <davem@redhat.com>\n+\n+\t* haifa-sched.c (ready_remove): Fix thinko, we want to copy around\n+\tready->vec[foo] not ready[foo].\n+\n+\t2001-09-07  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* doc/md.texi: Correct examples for define_insn_reservations\n+\t`mult' and `div'.\n+\n+\t2001-09-07  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c (create_automata): Print message about creation of\n+\teach automaton.\n+\t(generate): Remove printing meease about creation of\n+\tautomata.\n+\n+\t2001-09-05  David S. Miller  <davem@redhat.com>\n+\n+\t* config/sparc/linux.h: Set CPLUSPLUS_CPP_SPEC.\n+\t* config/sparc/linux64.h: Likewise.\n+\n+\t2001-08-31  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* haifa-sched.c (insn_cost, schedule_insn, queue_to_ready,\n+\tschedule_block, sched_init, sched_finish): Add missed calls of\n+\tuse_dfa_pipeline_interface.\n+\n+\t* sched-rgn.c (init_ready_list, new_ready, debug_dependencies):\n+\tDitto.\n+\n+\t* sched-vis.c (get_visual_tbl_length): Ditto.\n+\t\n+\t2001-08-27  Richard Henderson  <rth@redhat.com>\n+\n+\t* genattr.c (main): Emit state_t even when not doing scheduling.\n+\n+\t2001-08-27  Richard Henderson  <rth@redhat.com>\n+\n+\t* genautomata.c (expand_automata): Always create a description.\n+\n+\t2001-08-27  Vladimir Makarov  <vmakarov@touchme.toronto.redhat.com>\n+\n+        * rtl.def (DEFINE_CPU_UNIT, DEFINE_QUERY_CPU_UNIT, EXCLUSION_SET,\n+\tPRESENCE_SET, ABSENCE_SET, DEFINE_BYPASS, DEFINE_AUTOMATON,\n+\tAUTOMATA_OPTION, DEFINE_RESERVATION, DEFINE_INSN_RESERVATION): New\n+\tRTL constructions.\n+\n+\t* genattr.c (main): New variable num_insn_reservations.  Increase\n+\tit if there is DEFINE_INSN_RESERVATION.  Output automaton based\n+\tpipeline hazard recognizer interface.\n+\n+\t* genattrtab.h: New file.\n+\n+\t* genattrtab.c: Include genattrtab.h.\n+\t(attr_printf, check_attr_test, make_internal_attr,\n+\tmake_numeric_value): Move protypes into genattrtab.h.  Define them\n+\tas external.\n+\t(num_dfa_decls): New global variable.\n+\t(main): Process DEFINE_CPU_UNIT, DEFINE_QUERY_CPU_UNIT,\n+\tDEFINE_BYPASS, EXCLUSION_SET, PRESENCE_SET, ABSENCE_SET,\n+\tDEFINE_AUTOMATON, AUTOMATA_OPTION, DEFINE_RESERVATION,\n+\tDEFINE_INSN_RESERVATION.  Call expand_automata and write_automata.\n+\n+\t* genautomata.c: New file.\n+\n+\t* rtl.h (LINK_COST_ZERO, LINK_COST_FREE): Remove them.\n+\n+        * sched-int.h: (curr_state): Add the external definition for\n+\tautomaton pipeline interface.\n+\t(haifa_insn_data): Add comments for members blockage and units.\n+\n+\t* target-def.h (TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE,\n+\tTARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN,\n+\tTARGET_SCHED_DFA_PRE_CYCLE_INSN,\n+\tTARGET_SCHED_INIT_DFA_POST_CYCLE_INSN,\n+\tTARGET_SCHED_DFA_POST_CYCLE_INSN,\n+\tTARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD,\n+\tTARGET_SCHED_INIT_DFA_BUBBLES, TARGET_SCHED_DFA_BUBBLE): New\n+\tmacros.\n+\t(TARGET_SCHED): Use the new macros.\n+\n+\t* target.h (use_dfa_pipeline_interface, init_dfa_pre_cycle_insn,\n+\tdfa_pre_cycle_insn, init_dfa_post_cycle_insn, dfa_post_cycle_insn,\n+\tfirst_cycle_multipass_dfa_lookahead, init_dfa_bubbles,\n+\tdfa_bubble): New members in gcc_target.sched.\n+\n+        * haifa-sched.c (insert_schedule_bubbles_p): New variable.\n+\t(MAX_INSN_QUEUE_INDEX): New macro for automaton interface.\n+\t(insn_queue): Redefine it as pointer to array.\n+\t(NEXT_Q, NEXT_Q_AFTER): Use MAX_INSN_QUEUE_INDEX instead of\n+\tINSN_QUEUE_SIZE.\n+\t(max_insn_queue_index_macro_value): New variable.\n+\t(curr_state, dfa_state_size, ready_try): New varaibles for\n+\tautomaton interface.\n+\t(ready_element, ready_remove, max_issue): New function prototypes\n+\tfor automaton interface.\n+\t(choose_ready): New function prototype.\n+\t(insn_unit, blockage_range): Add comments.\n+\t(unit_last_insn, unit_tick, unit_n_insns): Define them for case\n+\tFUNCTION_UNITS_SIZE == 0.\n+\t(insn_issue_delay, actual_hazard_this_instance, schedule_unit,\n+\tactual_hazard, potential_hazard): Add comments.\n+\t(insn_cost): Use cost -1 as undefined value.  Remove\n+\tLINK_COST_ZERO and LINK_COST_FREE.  Add new code for automaton\n+\tpipeline interface.\n+\t(ready_element, ready_remove): New functions for automaton\n+\tinterface.\n+\t(schedule_insn): Add new code for automaton pipeline interface.\n+\t(queue_to_ready): Add new code for automaton pipeline interface.\n+\tUse MAX_INSN_QUEUE_INDEX instead of INSN_QUEUE_SIZE.\n+\t(debug_ready_list): Print newline when the queue is empty.\n+\t(max_issue): New function for automaton pipeline interface.\n+\t(choose_ready): New function.\n+\t(schedule_block): Add new code for automaton pipeline interface.\n+\tPrint ready list before scheduling each insn.\n+\t(sched_init): Add new code for automaton pipeline interface.\n+\tInitiate insn cost by -1.\n+\t(sched_finish): Free the current automaton state and finalize\n+\tautomaton pipeline interface.\n+\n+\t* sched-rgn.c: Include target.h.\n+\t(init_ready_list, new_ready, debug_dependencies): Add new code for\n+\tautomaton pipeline interface.\n+\n+\t* sched-vis.c: Include target.h.\n+\t(get_visual_tbl_length): Add code for automaton interface.\n+\t(target_units, print_block_visualization):  Add comments.\n+\n+        * Makefile.in (GETRUNTIME, HASHTAB, HOST_GETRUNTIME, HOST_HASHTAB,\n+\tUSE_HOST_GETRUNTIME, USE_HOST_HASHTAB, HOST_VARRAY): New variables.\n+\t(sched-rgn.o, sched-vis.o): Add new dependency file target.h.\n+\t(getruntime.o, genautomata.o): New entries.\n+\t(genattrtab.o): Add new dependency file genattrtab.h.\n+\t(genattrtab): Add new dependencies.  Link it with `libm.a'.\n+\t(getruntime.o, hashtab.o): New entries for canadian cross.\n+\n+\t* doc/md.texi: Description of automaton based model.\n+\n+\t* doc/tm.texi (TARGET_SCHED_ISSUE_RATE, TARGET_SCHED_ADJUST_COST):\n+\tAdd comments.\n+\t(TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE,\n+\tTARGET_SCHED_DFA_PRE_CYCLE_INSN,\n+\tTARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN,\n+\tTARGET_SCHED_DFA_POST_CYCLE_INSN,\n+\tTARGET_SCHED_INIT_DFA_POST_CYCLE_INSN,\n+\tTARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD,\n+\tTARGET_SCHED_INIT_DFA_BUBBLES, TARGET_SCHED_DFA_BUBBLE): The new\n+\thook descriptions.\n+\t(TRADITIONAL_PIPELINE_INTERFACE, DFA_PIPELINE_INTERFACE,\n+\tMAX_DFA_ISSUE_RATE): New macro descriptions.\n+\n+\t* doc/contrib.texi: Add dfa based scheduler contribution.\n+\n+\t* doc/gcc.texi: Add more information about genattrtab.\n+\n Mon Apr 29 17:19:10 2002  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* reload1.c (eliminate_regs, case SUBREG): Fix typo in"}, {"sha": "8407632dcfad20bb822845818d5a467b15a9dec2", "filename": "gcc/Makefile.in", "status": "modified", "additions": 83, "deletions": 7, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -344,6 +344,14 @@ LIBICONV = @LIBICONV@\n # List of internationalization subdirectories.\n INTL_SUBDIRS = intl\n \n+# Change this to a null string if obstacks are installed in the\n+# system library.\n+OBSTACK=obstack.o\n+\n+# The following object files is used by genautomata.\n+GETRUNTIME = getruntime.o\n+HASHTAB = hashtab.o\n+\n # The GC method to be used on this system.\n GGC=@GGC@.o\n \n@@ -475,6 +483,12 @@ HOST_CFLAGS= @HOST_CFLAGS@ -DGENERATOR_FILE\n # Native linker and preprocessor flags.  For x-fragment overrides.\n HOST_LDFLAGS=$(LDFLAGS)\n HOST_CPPFLAGS=$(ALL_CPPFLAGS)\n+HOST_OBSTACK=$(OBSTACK)\n+HOST_VFPRINTF=$(VFPRINTF)\n+HOST_DOPRINT=$(DOPRINT)\n+HOST_GETRUNTIME=$(GETRUNTIME)\n+HOST_HASHTAB=$(HASHTAB)\n+HOST_STRSTR=$(STRSTR)\n \n # Actual name to use when installing a native compiler.\n GCC_INSTALL_NAME = `echo gcc|sed '$(program_transform_name)'`\n@@ -598,8 +612,17 @@ ALL_CPPFLAGS = $(CPPFLAGS) $(X_CPPFLAGS) $(T_CPPFLAGS)\n LIBIBERTY = ../libiberty/libiberty.a\n BUILD_LIBIBERTY = @FORBUILD@/libiberty/libiberty.a\n \n-# Dependencies on the intl and portability libraries.\n-LIBDEPS= $(INTLDEPS) $(LIBIBERTY)\n+USE_HOST_OBSTACK= ` case \"${HOST_OBSTACK}\" in ?*) echo ${HOST_PREFIX}${HOST_OBSTACK} ;; esac `\n+USE_HOST_VFPRINTF= ` case \"${HOST_VFPRINTF}\" in ?*) echo ${HOST_PREFIX}${HOST_VFPRINTF} ;; esac `\n+USE_HOST_DOPRINT= ` case \"${HOST_DOPRINT}\" in ?*) echo ${HOST_PREFIX}${HOST_DOPRINT} ;; esac `\n+USE_HOST_GETRUNTIME= ` case \"${HOST_GETRUNTIME}\" in ?*) echo ${HOST_PREFIX}${HOST_GETRUNTIME} ;; esac `\n+USE_HOST_HASHTAB= ` case \"${HOST_HASHTAB}\" in ?*) echo ${HOST_PREFIX}${HOST_HASHTAB} ;; esac `\n+USE_HOST_STRSTR= ` case \"${HOST_STRSTR}\" in ?*) echo ${HOST_PREFIX}${HOST_STRSTR} ;; esac `\n+\n+# Dependency on the intl, portability libraries, obstack or whatever\n+# library facilities are not installed in the system libraries.\n+# We don't use USE_* because backquote expansion doesn't work in deps.\n+LIBDEPS= $(INTLLIBS) $(LIBIBERTY) $(OBSTACK) $(VFPRINTF) $(DOPRINT) $(STRSTR)\n \n # Likewise, for use in the tools that must run on this machine\n # even if we are cross-building GCC.\n@@ -618,6 +641,7 @@ HOST_RTL = $(HOST_PREFIX)rtl.o read-rtl.o $(HOST_PREFIX)bitmap.o \\\n \n HOST_PRINT = $(HOST_PREFIX)print-rtl.o\n HOST_ERRORS = $(HOST_PREFIX)errors.o\n+HOST_VARRAY = $(HOST_PREFIX)varray.o\n \n # Specify the directories to be searched for header files.\n # Both . and srcdir are used, in that order,\n@@ -1319,6 +1343,17 @@ line-map.o: line-map.c line-map.h intl.h $(CONFIG_H) $(SYSTEM_H)\n ggc-none.o: ggc-none.c $(GCONFIG_H) $(SYSTEM_H) $(GGC_H)\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n+obstack.o: $(srcdir)/../libiberty/obstack.c $(GCONFIG_H)\n+\trm -f obstack.c\n+\t$(LN_S) $(srcdir)/../libiberty/obstack.c obstack.c\n+\t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\tobstack.c $(OUTPUT_OPTION)\n+\n+getruntime.o: $(srcdir)/../libiberty/getruntime.c $(CONFIG_H)\n+\trm -f getruntime.c\n+\t$(LN_S) $(srcdir)/../libiberty/getruntime.c getruntime.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) getruntime.c\n+\n prefix.o: prefix.c $(CONFIG_H) $(SYSTEM_H) Makefile prefix.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t-DPREFIX=\\\"$(prefix)\\\" \\\n@@ -1558,12 +1593,13 @@ sched-deps.o : sched-deps.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) sched-int.h \\\n    $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h cselib.h $(PARAMS_H) $(TM_P_H)\n sched-rgn.o : sched-rgn.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) sched-int.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \\\n-   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H)\n+   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) $(TARGET_H)\n sched-ebb.o : sched-ebb.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) sched-int.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \\\n    $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H)\n sched-vis.o : sched-vis.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) sched-int.h \\\n-   hard-reg-set.h $(BASIC_BLOCK_H) $(INSN_ATTR_H) $(REGS_H) $(TM_P_H)\n+   hard-reg-set.h $(BASIC_BLOCK_H) $(INSN_ATTR_H) $(REGS_H) $(TM_P_H) \\\n+   $(TARGET_H)\n final.o : final.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h intl.h \\\n    $(REGS_H) $(RECOG_H) conditions.h insn-config.h $(INSN_ATTR_H) function.h \\\n    real.h output.h hard-reg-set.h except.h debug.h xcoffout.h \\\n@@ -1868,14 +1904,18 @@ genattr$(build_exeext) : genattr.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HO\n genattr.o : genattr.c $(RTL_H) $(HCONFIG_H) $(SYSTEM_H) errors.h gensupport.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genattr.c $(OUTPUT_OPTION)\n \n-genattrtab$(build_exeext) : genattrtab.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n+genattrtab$(build_exeext) : genattrtab.o genautomata.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_VARRAY) $(HOST_PREFIX)$(HOST_GETRUNTIME) $(HOST_LIBDEPS)\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n-\t genattrtab.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBS)\n+\t genattrtab.o genautomata.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_VARRAY) $(USE_HOST_GETRUNTIME) $(HOST_LIBS) -lm\n \n genattrtab.o : genattrtab.c $(RTL_H) $(OBSTACK_H) $(HCONFIG_H) \\\n-  $(SYSTEM_H) errors.h $(GGC_H) gensupport.h\n+  $(SYSTEM_H) errors.h $(GGC_H) gensupport.h genattrtab.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genattrtab.c $(OUTPUT_OPTION)\n \n+genautomata.o : genautomata.c $(RTL_H) $(OBSTACK_H) $(HCONFIG_H) \\\n+  $(SYSTEM_H) errors.h varray.h hash.h genattrtab.h\n+\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genautomata.c $(OUTPUT_OPTION)\n+\n genoutput$(build_exeext) : genoutput.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n \t genoutput.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBS)\n@@ -1921,11 +1961,47 @@ $(HOST_PREFIX_1)bitmap.o: $(srcdir)/bitmap.c $(HCONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n \tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/bitmap.c > $(HOST_PREFIX)bitmap.c\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)bitmap.c $(OUTPUT_OPTION)\n \n+$(HOST_PREFIX_1)obstack.o: $(srcdir)/../libiberty/obstack.c $(HCONFIG_H)\n+\trm -f $(HOST_PREFIX)obstack.c\n+\tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/../libiberty/obstack.c > $(HOST_PREFIX)obstack.c\n+\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)obstack.c $(OUTPUT_OPTION)\n+\n+$(HOST_PREFIX_1)getruntime.o: $(srcdir)/../libiberty/getruntime.c\n+\trm -f $(HOST_PREFIX)getruntime.c\n+\tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/../libiberty/getruntime.c > $(HOST_PREFIX)getruntime.c\n+\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)getruntime.c $(OUTPUT_OPTION)\n+\n+$(HOST_PREFIX_1)hashtab.o: $(srcdir)/../libiberty/hashtab.c\n+\trm -f $(HOST_PREFIX)hashtab.c\n+\tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/../libiberty/hashtab.c > $(HOST_PREFIX)hashtab.c\n+\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)hashtab.c $(OUTPUT_OPTION)\n+\n+$(HOST_PREFIX_1)vfprintf.o: $(srcdir)/../libiberty/vfprintf.c $(HCONFIG_H)\n+\trm -f $(HOST_PREFIX)vfprintf.c\n+\tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/../libiberty/vfprintf.c > $(HOST_PREFIX)vfprintf.c\n+\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)vfprintf.c $(OUTPUT_OPTION)\n+\n+$(HOST_PREFIX_1)doprint.o: doprint.c $(HCONFIG_H)\n+\trm -f $(HOST_PREFIX)doprint.c\n+\tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/doprint.c > $(HOST_PREFIX)doprint.c\n+\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)doprint.c $(OUTPUT_OPTION)\n+\n+$(HOST_PREFIX_1)strstr.o: $(srcdir)/../libiberty/strstr.c $(HCONFIG_H)\n+\trm -f $(HOST_PREFIX)strstr.c\n+\tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/../libiberty/strstr.c > $(HOST_PREFIX)strstr.c\n+\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)strstr.c $(OUTPUT_OPTION)\n+\n $(HOST_PREFIX_1)errors.o: errors.c $(HCONFIG_H) $(SYSTEM_H) errors.h\n \trm -f $(HOST_PREFIX)errors.c\n \tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/errors.c > $(HOST_PREFIX)errors.c\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)errors.c $(OUTPUT_OPTION)\n \n+\n+# This satisfies the dependency that we get if you cross-compile a compiler\n+# that does not need to compile doprint or whatever.\n+$(HOST_PREFIX_1):\n+\t$(STAMP) $(HOST_PREFIX_1)\n+\n $(HOST_PREFIX_1)ggc-none.o: ggc-none.c $(HCONFIG_H) $(SYSTEM_H) $(GCC_H)\n \trm -f $(HOST_PREFIX)ggc-none.c\n \tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/ggc-none.c > $(HOST_PREFIX)ggc-none.c"}, {"sha": "0cb46cd05bf61adb4971f878e99ff94bfef31821", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -49,6 +49,17 @@ Boston, MA 02111-1307, USA.  */\n #include \"target.h\"\n #include \"target-def.h\"\n \n+static int hppa_use_dfa_pipeline_interface PARAMS ((void));\n+\n+#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE \n+#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hppa_use_dfa_pipeline_interface\n+\n+static int\n+hppa_use_dfa_pipeline_interface ()\n+{\n+  return 1;\n+}\n+\n #ifndef DO_FRAME_NOTES\n #ifdef INCOMING_RETURN_ADDR_RTX\n #define DO_FRAME_NOTES 1\n@@ -172,14 +183,19 @@ override_options ()\n       pa_cpu_string = \"7200\";\n       pa_cpu = PROCESSOR_7200;\n     }\n+  else if (pa_cpu_string && ! strcmp (pa_cpu_string, \"7300\"))\n+    {\n+      pa_cpu_string = \"7300\";\n+      pa_cpu = PROCESSOR_7300;\n+    }\n   else if (pa_cpu_string && ! strcmp (pa_cpu_string, \"8000\"))\n     {\n       pa_cpu_string = \"8000\";\n       pa_cpu = PROCESSOR_8000;\n     }\n   else\n     {\n-      warning (\"unknown -mschedule= option (%s).\\nValid options are 700, 7100, 7100LC, 7200, and 8000\\n\", pa_cpu_string);\n+      warning (\"unknown -mschedule= option (%s).\\nValid options are 700, 7100, 7100LC, 7200, 7300, and 8000\\n\", pa_cpu_string);\n     }\n \n   /* Set the instruction set architecture.  */\n@@ -3929,7 +3945,7 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \t\t{\n \t\tcase TYPE_FPLOAD:\n \t\t  /* This cost 3 cycles, not 2 as the md says for the\n-\t\t     700 and 7100.  */\n+\t\t     700 and 7100, 7100lc, 7200 and 7300.  */\n \t\t  return cost + 1;\n \n \t\tcase TYPE_FPALU:\n@@ -3947,6 +3963,11 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \t\t  return cost;\n \t\t}\n \t    }\n+\n+\t  /* A flop-flop true depenendency where the sizes of the operand\n+\t     carrying the dependency is difference causes an additional\n+\t     cycle stall on the 7100lc, 7200, and 7300.   Similarly for\n+\t     a fpload-flop true dependency.  */\n \t}\n \n       /* For other data dependencies, the default cost specified in the\n@@ -3989,7 +4010,10 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \t\t     preceding arithmetic operation has finished if\n \t\t     the target of the fpload is any of the sources\n \t\t     (or destination) of the arithmetic operation.  */\n-\t\t  return cost - 1;\n+\t\t  if (hppa_use_dfa_pipeline_interface ())\n+\t\t    return insn_default_latency (dep_insn) - 1;\n+\t\t  else\n+\t\t    return cost - 1;\n \n \t\tdefault:\n \t\t  return 0;\n@@ -4024,7 +4048,10 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \t\t     preceding divide or sqrt operation has finished if\n \t\t     the target of the ALU flop is any of the sources\n \t\t     (or destination) of the divide or sqrt operation.  */\n-\t\t  return cost - 2;\n+\t\t  if (hppa_use_dfa_pipeline_interface ())\n+\t\t    return insn_default_latency (dep_insn) - 2;\n+\t\t  else\n+\t\t    return cost - 2;\n \n \t\tdefault:\n \t\t  return 0;\n@@ -4069,8 +4096,15 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \t\t  /* A fpload can't be issued until one cycle before a\n \t\t     preceding arithmetic operation has finished if\n \t\t     the target of the fpload is the destination of the\n-\t\t     arithmetic operation.  */\n-\t\t  return cost - 1;\n+\t\t     arithmetic operation. \n+\n+\t\t     Exception: For PA7100LC, PA7200 and PA7300, the cost\n+\t\t     is 3 cycles, unless they bundle together.   We also\n+\t\t     pay the penalty if the second insn is a fpload.  */\n+\t\t  if (hppa_use_dfa_pipeline_interface ())\n+\t\t    return insn_default_latency (dep_insn) - 1;\n+\t\t  else\n+\t\t    return cost - 1;\n \n \t\tdefault:\n \t\t  return 0;\n@@ -4105,7 +4139,10 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \t\t     preceding divide or sqrt operation has finished if\n \t\t     the target of the ALU flop is also the target of\n \t\t     the divide or sqrt operation.  */\n-\t\t  return cost - 2;\n+\t\t  if (hppa_use_dfa_pipeline_interface ())\n+\t\t    return insn_default_latency (dep_insn) - 2;\n+\t\t  else\n+\t\t    return cost - 2;\n \n \t\tdefault:\n \t\t  return 0;\n@@ -4165,6 +4202,7 @@ pa_issue_rate ()\n     case PROCESSOR_7100:\treturn 2;\n     case PROCESSOR_7100LC:\treturn 2;\n     case PROCESSOR_7200:\treturn 2;\n+    case PROCESSOR_7300:\treturn 2;\n     case PROCESSOR_8000:\treturn 4;\n \n     default:"}, {"sha": "0fd96bcb3b72dd4c1e944bc44c1ef28f8d7e07f5", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -41,6 +41,7 @@ enum processor_type\n   PROCESSOR_7100,\n   PROCESSOR_7100LC,\n   PROCESSOR_7200,\n+  PROCESSOR_7300,\n   PROCESSOR_8000\n };\n "}, {"sha": "ca99b3249e207f0e2debdff69115a6e2e8d4a30b", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 223, "deletions": 141, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -44,7 +44,7 @@\n ;;\n ;; FIXME: Add 800 scheduling for completeness?\n \n-(define_attr \"cpu\" \"700,7100,7100LC,7200,8000\" (const (symbol_ref \"pa_cpu_attr\")))\n+(define_attr \"cpu\" \"700,7100,7100LC,7200,7300,8000\" (const (symbol_ref \"pa_cpu_attr\")))\n \n ;; Length (in # of bytes).\n (define_attr \"length\" \"\"\n@@ -139,35 +139,10 @@\n \t\t       (const_int 0)))\n   [(eq_attr \"in_branch_delay\" \"true\") (nil) (nil)])\n \n-;; Function units of the HPPA. The following data is for the 700 CPUs\n-;; (Mustang CPU + Timex FPU aka PA-89) because that's what I have the docs for.\n-;; Scheduling instructions for PA-83 machines according to the Snake\n-;; constraints shouldn't hurt.\n-\n-;; (define_function_unit {name} {num-units} {n-users} {test}\n-;;                       {ready-delay} {issue-delay} [{conflict-list}])\n-\n-;; The integer ALU.\n-;; (Noted only for documentation; units that take one cycle do not need to\n-;; be specified.)\n-\n-;; (define_function_unit \"alu\" 1 0\n-;;  (and (eq_attr \"type\" \"unary,shift,nullshift,binary,move,address\")\n-;;\t (eq_attr \"cpu\" \"700\"))\n-;;  1 0)\n-\n-\n ;; Memory. Disregarding Cache misses, the Mustang memory times are:\n ;; load: 2, fpload: 3\n ;; store, fpstore: 3, no D-cache operations should be scheduled.\n \n-(define_function_unit \"pa700memory\" 1 0\n-  (and (eq_attr \"type\" \"load,fpload\")\n-       (eq_attr \"cpu\" \"700\")) 2 0)\n-(define_function_unit \"pa700memory\" 1 0 \n-  (and (eq_attr \"type\" \"store,fpstore\")\n-       (eq_attr \"cpu\" \"700\")) 3 3)\n-\n ;; The Timex (aka 700) has two floating-point units: ALU, and MUL/DIV/SQRT.\n ;; Timings:\n ;; Instruction\tTime\tUnit\tMinimum Distance (unit contention)\n@@ -186,44 +161,73 @@\n ;; fdiv,dbl\t12\tMPY\t12\n ;; fsqrt,sgl\t14\tMPY\t14\n ;; fsqrt,dbl\t18\tMPY\t18\n+;;\n+;; We don't model fmpyadd/fmpysub properly as those instructions\n+;; keep both the FP ALU and MPY units busy.  Given that these\n+;; processors are obsolete, I'm not going to spend the time to\n+;; model those instructions correctly.\n \n-(define_function_unit \"pa700fp_alu\" 1 0\n+(define_automaton \"pa700\")\n+(define_cpu_unit \"dummy_700,mem_700,fpalu_700,fpmpy_700\" \"pa700\")\n+\n+(define_insn_reservation \"W0\" 4\n   (and (eq_attr \"type\" \"fpcc\")\n-       (eq_attr \"cpu\" \"700\")) 4 2)\n-(define_function_unit \"pa700fp_alu\" 1 0\n+       (eq_attr \"cpu\" \"700\"))\n+  \"fpalu_700*2\")\n+\n+(define_insn_reservation \"W1\" 3\n   (and (eq_attr \"type\" \"fpalu\")\n-       (eq_attr \"cpu\" \"700\")) 3 2)\n-(define_function_unit \"pa700fp_mpy\" 1 0\n+       (eq_attr \"cpu\" \"700\"))\n+  \"fpalu_700*2\")\n+\n+(define_insn_reservation \"W2\" 3\n   (and (eq_attr \"type\" \"fpmulsgl,fpmuldbl\")\n-       (eq_attr \"cpu\" \"700\")) 3 2)\n-(define_function_unit \"pa700fp_mpy\" 1 0\n+       (eq_attr \"cpu\" \"700\"))\n+  \"fpmpy_700*2\")\n+\n+(define_insn_reservation \"W3\" 10\n   (and (eq_attr \"type\" \"fpdivsgl\")\n-       (eq_attr \"cpu\" \"700\")) 10 10)\n-(define_function_unit \"pa700fp_mpy\" 1 0\n+       (eq_attr \"cpu\" \"700\"))\n+  \"fpmpy_700*10\")\n+\n+(define_insn_reservation \"W4\" 12\n   (and (eq_attr \"type\" \"fpdivdbl\")\n-       (eq_attr \"cpu\" \"700\")) 12 12)\n-(define_function_unit \"pa700fp_mpy\" 1 0\n+       (eq_attr \"cpu\" \"700\"))\n+  \"fpmpy_700*12\")\n+\n+(define_insn_reservation \"W5\" 14\n   (and (eq_attr \"type\" \"fpsqrtsgl\")\n-       (eq_attr \"cpu\" \"700\")) 14 14)\n-(define_function_unit \"pa700fp_mpy\" 1 0\n+       (eq_attr \"cpu\" \"700\"))\n+  \"fpmpy_700*14\")\n+\n+(define_insn_reservation \"W6\" 18\n   (and (eq_attr \"type\" \"fpsqrtdbl\")\n-       (eq_attr \"cpu\" \"700\")) 18 18)\n+       (eq_attr \"cpu\" \"700\"))\n+  \"fpmpy_700*18\")\n+\n+(define_insn_reservation \"W7\" 2\n+  (and (eq_attr \"type\" \"load,fpload\")\n+       (eq_attr \"cpu\" \"700\"))\n+  \"mem_700\")\n+\n+(define_insn_reservation \"W8\" 3\n+  (and (eq_attr \"type\" \"store,fpstore\")\n+       (eq_attr \"cpu\" \"700\"))\n+  \"mem_700*3\")\n+\n+(define_insn_reservation \"W9\" 1\n+  (and (eq_attr \"type\" \"!fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,load,fpload,store,fpstore\")\n+       (eq_attr \"cpu\" \"700\"))\n+  \"dummy_700\")\n \n ;; Function units for the 7100 and 7150.  The 7100/7150 can dual-issue\n ;; floating point computations with non-floating point computations (fp loads\n ;; and stores are not fp computations).\n ;;\n-\n ;; Memory. Disregarding Cache misses, memory loads take two cycles; stores also\n ;; take two cycles, during which no Dcache operations should be scheduled.\n ;; Any special cases are handled in pa_adjust_cost.  The 7100, 7150 and 7100LC\n ;; all have the same memory characteristics if one disregards cache misses.\n-(define_function_unit \"pa7100memory\" 1 0\n-  (and (eq_attr \"type\" \"load,fpload\")\n-       (eq_attr \"cpu\" \"7100,7100LC\")) 2 0)\n-(define_function_unit \"pa7100memory\" 1 0 \n-  (and (eq_attr \"type\" \"store,fpstore\")\n-       (eq_attr \"cpu\" \"7100,7100LC\")) 2 2)\n \n ;; The 7100/7150 has three floating-point units: ALU, MUL, and DIV.\n ;; Timings:\n@@ -243,41 +247,46 @@\n ;; fdiv,dbl\t15\tDIV\t15\n ;; fsqrt,sgl\t8\tDIV\t8\n ;; fsqrt,dbl\t15\tDIV\t15\n+;;\n+;; We don't really model the FP ALU/MPY units properly (they are\n+;; distinct subunits in the FP unit).  However, there can never be\n+;; a functional unit; conflict given the latency and issue rates\n+;; for those units.\n \n-(define_function_unit \"pa7100fp_alu\" 1 0\n-  (and (eq_attr \"type\" \"fpcc,fpalu\")\n-       (eq_attr \"cpu\" \"7100\")) 2 1)\n-(define_function_unit \"pa7100fp_mpy\" 1 0\n-  (and (eq_attr \"type\" \"fpmulsgl,fpmuldbl\")\n-       (eq_attr \"cpu\" \"7100\")) 2 1)\n-(define_function_unit \"pa7100fp_div\" 1 0\n+(define_automaton \"pa7100\")\n+(define_cpu_unit \"i_7100, f_7100,fpmac_7100,fpdivsqrt_7100,mem_7100\" \"pa7100\")\n+\n+(define_insn_reservation \"X0\" 2\n+  (and (eq_attr \"type\" \"fpcc,fpalu,fpmulsgl,fpmuldbl\")\n+       (eq_attr \"cpu\" \"7100\"))\n+  \"f_7100,fpmac_7100\")\n+\n+(define_insn_reservation \"X1\" 8\n   (and (eq_attr \"type\" \"fpdivsgl,fpsqrtsgl\")\n-       (eq_attr \"cpu\" \"7100\")) 8 8)\n-(define_function_unit \"pa7100fp_div\" 1 0\n-  (and (eq_attr \"type\" \"fpdivdbl,fpsqrtdbl\")\n-       (eq_attr \"cpu\" \"7100\")) 15 15)\n+       (eq_attr \"cpu\" \"7100\"))\n+  \"f_7100+fpdivsqrt_7100,fpdivsqrt_7100*7\")\n \n-;; To encourage dual issue we define function units corresponding to\n-;; the instructions which can be dual issued.    This is a rather crude\n-;; approximation, the \"pa7100nonflop\" test in particular could be refined.\n-(define_function_unit \"pa7100flop\" 1 1\n-  (and\n-    (eq_attr \"type\" \"fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpsqrtsgl,fpdivdbl,fpsqrtdbl\")\n-    (eq_attr \"cpu\" \"7100\")) 1 1)\n+(define_insn_reservation \"X2\" 15\n+  (and (eq_attr \"type\" \"fpdivdbl,fpsqrtdbl\")\n+       (eq_attr \"cpu\" \"7100\"))\n+  \"f_7100+fpdivsqrt_7100,fpdivsqrt_7100*14\")\n \n-(define_function_unit \"pa7100nonflop\" 1 1\n-  (and\n-    (eq_attr \"type\" \"!fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpsqrtsgl,fpdivdbl,fpsqrtdbl\")\n-    (eq_attr \"cpu\" \"7100\")) 1 1)\n+(define_insn_reservation \"X3\" 2\n+  (and (eq_attr \"type\" \"load,fpload\")\n+       (eq_attr \"cpu\" \"7100\"))\n+  \"i_7100+mem_7100\")\n \n+(define_insn_reservation \"X4\" 2\n+  (and (eq_attr \"type\" \"store,fpstore\")\n+       (eq_attr \"cpu\" \"7100\"))\n+  \"i_7100+mem_7100,mem_7100\")\n \n-;; Memory subsystem works just like 7100/7150 (except for cache miss times which\n-;; we don't model here).  \n+(define_insn_reservation \"X5\" 1\n+  (and (eq_attr \"type\" \"!fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpsqrtsgl,fpdivdbl,fpsqrtdbl,load,fpload,store,fpstore\")\n+       (eq_attr \"cpu\" \"7100\"))\n+  \"i_7100\")\n \n ;; The 7100LC has three floating-point units: ALU, MUL, and DIV.\n-;; Note divides and sqrt flops lock the cpu until the flop is\n-;; finished.  fmpy and xmpyu (fmpyi) lock the cpu for one cycle.\n-;; There's no way to avoid the penalty.\n ;; Timings:\n ;; Instruction\tTime\tUnit\tMinimum Distance (unit contention)\n ;; fcpy\t\t2\tALU\t1\n@@ -299,106 +308,179 @@\n ;; fdiv,dbl\t15\tDIV\t15\n ;; fsqrt,sgl\t8\tDIV\t8\n ;; fsqrt,dbl\t15\tDIV\t15\n-\n-(define_function_unit \"pa7100LCfp_alu\" 1 0\n+;;\n+;; The PA7200 is just like the PA7100LC except that there is\n+;; no store-store penalty.\n+;;\n+;; The PA7300 is just like the PA7200 except that there is\n+;; no store-load penalty.\n+;;\n+;; Note there are some aspects of the 7100LC we are not modeling\n+;; at the moment.  I'll be reviewing the 7100LC scheduling info\n+;; shortly and updating this description.\n+;;\n+;;   load-load pairs\n+;;   store-store pairs\n+;;   fmpyadd,dbl\n+;;   fmpysub,dbl\n+;;   other issue modeling\n+\n+(define_automaton \"pa7100lc\")\n+(define_cpu_unit \"i0_7100lc, i1_7100lc, f_7100lc\" \"pa7100lc\")\n+(define_cpu_unit \"fpalu_7100lc,fpdivsqrt_7100lc,fpmul_7100lc\" \"pa7100lc\")\n+(define_cpu_unit \"mem_7100lc\" \"pa7100lc\")\n+\n+(define_insn_reservation \"Y0\" 2\n   (and (eq_attr \"type\" \"fpcc,fpalu\")\n-       (eq_attr \"cpu\" \"7100LC,7200\")) 2 1)\n-(define_function_unit \"pa7100LCfp_mpy\" 1 0\n+       (eq_attr \"cpu\" \"7100LC,7200,7300\"))\n+  \"f_7100lc,fpalu_7100lc\")\n+\n+(define_insn_reservation \"Y1\" 2\n   (and (eq_attr \"type\" \"fpmulsgl\")\n-       (eq_attr \"cpu\" \"7100LC,7200\")) 2 1)\n-(define_function_unit \"pa7100LCfp_mpy\" 1 0\n+       (eq_attr \"cpu\" \"7100LC,7200,7300\"))\n+  \"f_7100lc,fpmul_7100lc\")\n+\n+(define_insn_reservation \"Y2\" 3\n   (and (eq_attr \"type\" \"fpmuldbl\")\n-       (eq_attr \"cpu\" \"7100LC,7200\")) 3 2)\n-(define_function_unit \"pa7100LCfp_div\" 1 0\n+       (eq_attr \"cpu\" \"7100LC,7200,7300\"))\n+  \"f_7100lc,fpmul_7100lc,fpmul_7100lc\")\n+\n+(define_insn_reservation \"Y3\" 8\n   (and (eq_attr \"type\" \"fpdivsgl,fpsqrtsgl\")\n-       (eq_attr \"cpu\" \"7100LC,7200\")) 8 8)\n-(define_function_unit \"pa7100LCfp_div\" 1 0\n-  (and (eq_attr \"type\" \"fpdivdbl,fpsqrtdbl\")\n-       (eq_attr \"cpu\" \"7100LC,7200\")) 15 15)\n+       (eq_attr \"cpu\" \"7100LC,7200,7300\"))\n+  \"f_7100lc+fpdivsqrt_7100lc,fpdivsqrt_7100lc*7\")\n \n-;; Define the various functional units for dual-issue.\n+(define_insn_reservation \"Y4\" 15\n+  (and (eq_attr \"type\" \"fpdivdbl,fpsqrtdbl\")\n+       (eq_attr \"cpu\" \"7100LC,7200,7300\"))\n+  \"f_7100lc+fpdivsqrt_7100lc,fpdivsqrt_7100lc*14\")\n \n-;; There's only one floating point unit.\n-(define_function_unit \"pa7100LCflop\" 1 1\n-  (and\n-    (eq_attr \"type\" \"fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpsqrtsgl,fpdivdbl,fpsqrtdbl\")\n-    (eq_attr \"cpu\" \"7100LC,7200\")) 1 1)\n+(define_insn_reservation \"Y5\" 2\n+  (and (eq_attr \"type\" \"load,fpload\")\n+       (eq_attr \"cpu\" \"7100LC,7200,7300\"))\n+  \"i1_7100lc+mem_7100lc\")\n \n-;; Shifts and memory ops execute in only one of the integer ALUs\n-(define_function_unit \"pa7100LCshiftmem\" 1 1\n-  (and\n-    (eq_attr \"type\" \"shift,nullshift,load,fpload,store,fpstore\")\n-    (eq_attr \"cpu\" \"7100LC,7200\")) 1 1)\n+(define_insn_reservation \"Y6\" 2\n+  (and (eq_attr \"type\" \"store,fpstore\")\n+       (eq_attr \"cpu\" \"7100LC\"))\n+  \"i1_7100lc+mem_7100lc,mem_7100lc\")\n \n-;; We have two basic ALUs.\n-(define_function_unit \"pa7100LCalu\" 2 1\n-  (and\n-    (eq_attr \"type\" \"!fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpsqrtsgl,fpdivdbl,fpsqrtdbl\")\n-   (eq_attr \"cpu\" \"7100LC,7200\")) 1 1)\n+(define_insn_reservation \"Y7\" 1\n+  (and (eq_attr \"type\" \"shift,nullshift\")\n+       (eq_attr \"cpu\" \"7100LC,7200,7300\"))\n+  \"i1_7100lc\")\n \n-;; I don't have complete information on the PA7200; however, most of\n-;; what I've heard makes it look like a 7100LC without the store-store\n-;; penalty.  So that's how we'll model it.\n+(define_insn_reservation \"Y8\" 1\n+  (and (eq_attr \"type\" \"!fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpsqrtsgl,fpdivdbl,fpsqrtdbl,load,fpload,store,fpstore,shift,nullshift\")\n+       (eq_attr \"cpu\" \"7100LC,7200,7300\"))\n+  \"(i0_7100lc|i1_7100lc)\")\n \n-;; Memory. Disregarding Cache misses, memory loads and stores take\n-;; two cycles.  Any special cases are handled in pa_adjust_cost.\n-(define_function_unit \"pa7200memory\" 1 0\n-  (and (eq_attr \"type\" \"load,fpload,store,fpstore\")\n-       (eq_attr \"cpu\" \"7200\")) 2 0)\n+;; The 7200 has a store-load penalty\n+(define_insn_reservation \"Y9\" 2\n+  (and (eq_attr \"type\" \"store,fpstore\")\n+       (eq_attr \"cpu\" \"7200\"))\n+  \"i0_7100lc,mem_7100lc\")\n \n-;; I don't have detailed information on the PA7200 FP pipeline, so I\n-;; treat it just like the 7100LC pipeline.\n-;; Similarly for the multi-issue fake units.\n+;; The 7300 has no penalty for store-store or store-load\n+(define_insn_reservation \"YA\" 2\n+  (and (eq_attr \"type\" \"store,fpstore\")\n+       (eq_attr \"cpu\" \"7300\"))\n+  \"i0_7100lc\")\n \n-;; \n ;; Scheduling for the PA8000 is somewhat different than scheduling for a\n ;; traditional architecture.\n ;;\n ;; The PA8000 has a large (56) entry reorder buffer that is split between\n ;; memory and non-memory operations.\n ;;\n-;; The PA800 can issue two memory and two non-memory operations per cycle to\n-;; the function units.  Similarly, the PA8000 can retire two memory and two\n-;; non-memory operations per cycle.\n+;; The PA8000 can issue two memory and two non-memory operations per cycle to\n+;; the function units, with the exception of branches and multi-output\n+;; instructions.  The PA8000 can retire two non-memory operations per cycle\n+;; and two memory operations per cycle, only one of which may be a store.\n ;;\n ;; Given the large reorder buffer, the processor can hide most latencies.\n ;; According to HP, they've got the best results by scheduling for retirement\n ;; bandwidth with limited latency scheduling for floating point operations.\n ;; Latency for integer operations and memory references is ignored.\n ;;\n-;; We claim floating point operations have a 2 cycle latency and are\n-;; fully pipelined, except for div and sqrt which are not pipelined.\n ;;\n-;; It is not necessary to define the shifter and integer alu units.\n+;; We claim floating point operations have a 2 cycle latency and are\n+;; fully pipelined, except for div and sqrt which are not pipelined and\n+;; take from 17 to 31 cycles to complete.\n ;;\n-;; These first two define_unit_unit descriptions model retirement from\n-;; the reorder buffer.\n-(define_function_unit \"pa8000lsu\" 2 1\n+;; It's worth noting that there is no way to saturate all the functional\n+;; units on the PA8000 as there is not enough issue bandwidth.\n+\n+(define_automaton \"pa8000\")\n+(define_cpu_unit \"inm0_8000, inm1_8000, im0_8000, im1_8000\" \"pa8000\")\n+(define_cpu_unit \"rnm0_8000, rnm1_8000, rm0_8000, rm1_8000\" \"pa8000\")\n+(define_cpu_unit \"store_8000\" \"pa8000\")\n+(define_cpu_unit \"f0_8000, f1_8000\" \"pa8000\")\n+(define_cpu_unit \"fdivsqrt0_8000, fdivsqrt1_8000\" \"pa8000\")\n+(define_reservation \"inm_8000\" \"inm0_8000 | inm1_8000\")\n+(define_reservation \"im_8000\" \"im0_8000 | im1_8000\")\n+(define_reservation \"rnm_8000\" \"rnm0_8000 | rnm1_8000\")\n+(define_reservation \"rm_8000\" \"rm0_8000 | rm1_8000\")\n+(define_reservation \"f_8000\" \"f0_8000 | f1_8000\")\n+(define_reservation \"fdivsqrt_8000\" \"fdivsqrt0_8000 | fdivsqrt1_8000\")\n+\n+;; We can issue any two memops per cycle, but we can only retire\n+;; one memory store per cycle.  We assume that the reorder buffer\n+;; will hide any memory latencies per HP's recommendation.\n+(define_insn_reservation \"Z0\" 0\n   (and\n-    (eq_attr \"type\" \"load,fpload,store,fpstore\")\n-    (eq_attr \"cpu\" \"8000\")) 1 1)\n+    (eq_attr \"type\" \"load,fpload\")\n+    (eq_attr \"cpu\" \"8000\"))\n+  \"im_8000,rm_8000\")\n \n-(define_function_unit \"pa8000alu\" 2 1\n+(define_insn_reservation \"Z1\" 0\n   (and\n-    (eq_attr \"type\" \"!load,fpload,store,fpstore\")\n-    (eq_attr \"cpu\" \"8000\")) 1 1)\n-\n-;; Claim floating point ops have a 2 cycle latency, excluding div and\n-;; sqrt, which are not pipelined and issue to different units.\n-(define_function_unit \"pa8000fmac\" 2 0\n+    (eq_attr \"type\" \"store,fpstore\")\n+    (eq_attr \"cpu\" \"8000\"))\n+  \"im_8000,rm_8000+store_8000\")\n+\n+;; We can issue and retire two non-memory operations per cycle with\n+;; a few exceptions (branches).  This group catches those we want\n+;; to assume have zero latency.\n+(define_insn_reservation \"Z2\" 0\n   (and\n-    (eq_attr \"type\" \"fpcc,fpalu,fpmulsgl,fpmuldbl\")\n-    (eq_attr \"cpu\" \"8000\")) 2 1)\n+    (eq_attr \"type\" \"!load,fpload,store,fpstore,uncond_branch,branch,cbranch,fbranch,call,dyncall,multi,milli,parallel_branch,fpcc,fpalu,fpmulsgl,fpmuldbl,fpsqrtsgl,fpsqrtdbl,fpdivsgl,fpdivdbl\")\n+    (eq_attr \"cpu\" \"8000\"))\n+  \"inm_8000,rnm_8000\")\n \n-(define_function_unit \"pa8000fdiv\" 2 1\n+;; Branches use both slots in the non-memory issue and\n+;; retirement unit.\n+(define_insn_reservation \"Z3\" 0\n   (and\n-    (eq_attr \"type\" \"fpdivsgl,fpsqrtsgl\")\n-    (eq_attr \"cpu\" \"8000\")) 17 17)\n+    (eq_attr \"type\" \"uncond_branch,branch,cbranch,fbranch,call,dyncall,multi,milli,parallel_branch\")\n+    (eq_attr \"cpu\" \"8000\"))\n+  \"inm0_8000+inm1_8000,rnm0_8000+rnm1_8000\")\n+\n+;; We partial latency schedule the floating point units.\n+;; They can issue/retire two at a time in the non-memory\n+;; units.  We fix their latency at 2 cycles and they\n+;; are fully pipelined.\n+(define_insn_reservation \"Z4\" 1\n+ (and\n+   (eq_attr \"type\" \"fpcc,fpalu,fpmulsgl,fpmuldbl\")\n+   (eq_attr \"cpu\" \"8000\"))\n+ \"inm_8000,f_8000,rnm_8000\")\n+\n+;; The fdivsqrt units are not pipelined and have a very long latency.  \n+;; To keep the DFA from exploding, we do not show all the\n+;; reservations for the divsqrt unit.\n+(define_insn_reservation \"Z5\" 17\n+ (and\n+   (eq_attr \"type\" \"fpdivsgl,fpsqrtsgl\")\n+   (eq_attr \"cpu\" \"8000\"))\n+ \"inm_8000,fdivsqrt_8000*6,rnm_8000\")\n+\n+(define_insn_reservation \"Z6\" 31\n+ (and\n+   (eq_attr \"type\" \"fpdivdbl,fpsqrtdbl\")\n+   (eq_attr \"cpu\" \"8000\"))\n+ \"inm_8000,fdivsqrt_8000*6,rnm_8000\")\n \n-(define_function_unit \"pa8000fdiv\" 2 1\n-  (and\n-    (eq_attr \"type\" \"fpdivdbl,fpsqrtdbl\")\n-    (eq_attr \"cpu\" \"8000\")) 31 31)\n \n \f\n ;; Compare instructions."}, {"sha": "5eee362610be91d960d663b803ca46b5c6269b8e", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -197,6 +197,9 @@ static void sh_insert_attributes PARAMS ((tree, tree *));\n static void sh_asm_named_section PARAMS ((const char *, unsigned int));\n #endif\n static int sh_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n+static int sh_use_dfa_interface PARAMS ((void));\n+static int sh_issue_rate PARAMS ((void));\n+\n static bool sh_cannot_modify_jumps_p PARAMS ((void));\n \n static bool sh_ms_bitfield_layout_p PARAMS ((tree));\n@@ -226,6 +229,12 @@ static bool sh_ms_bitfield_layout_p PARAMS ((tree));\n #undef TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST sh_adjust_cost\n \n+#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE \n+#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE \\\n+\t\t\t\tsh_use_dfa_interface\n+#undef TARGET_SCHED_ISSUE_RATE\n+#define TARGET_SCHED_ISSUE_RATE sh_issue_rate\n+\n #undef TARGET_CANNOT_MODIFY_JUMPS_P\n #define TARGET_CANNOT_MODIFY_JUMPS_P sh_cannot_modify_jumps_p\n \n@@ -6726,6 +6735,29 @@ sh_pr_n_sets ()\n   return REG_N_SETS (TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG);\n }\n \n+/* This Function Returns non zero if DFA based scheduler\n+   interface is to be used.At present supported only for\n+   SH4.  */\n+static int\n+sh_use_dfa_interface()\n+{\n+        if (TARGET_SH4)\n+                return 1;\n+        else\n+                return 0;\n+}\n+\n+/* This function returns \"2\" that signifies dual issue \n+   for SH4 processor.To be used by DFA pipeline description.  */\n+static int\n+sh_issue_rate()\n+{\n+\tif(TARGET_SH4)\n+\t\treturn 2;\n+\telse\n+\t\treturn 1;\n+}\n+\n /* SHmedia requires registers for branches, so we can't generate new\n    branches past reload.  */\n static bool"}, {"sha": "95aaa0d06f1f1fd6ed798754f347c5dc107f4146", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 405, "deletions": 49, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -195,6 +195,28 @@\n  \"cbranch,jump,jump_ind,arith,arith3,arith3b,dyn_shift,other,load,load_si,store,move,fmove,smpy,dmpy,return,pload,prset,pstore,prget,pcload,pcload_si,pt,ptabs,rte,sfunc,call,fp,fdiv,dfp_arith,dfp_cmp,dfp_conv,dfdiv,gp_fpul,nil\"\n   (const_string \"other\"))\n \n+;; We define a new attribute namely \"insn_class\".We use\n+;; this for DFA based pipeline description.\n+;; Although the \"type\" attribute covers almost all insn \n+;; classes,it is more convenient to define new attribute\n+;; for certain reservations.\n+;;\n+;; mt_group      SH4 \"mt\" group instructions.\n+;;\n+;; ex_group      SH4 \"ex\" group instructions.They mostly\n+;;               overlap with arithmetic instructions but\n+;;               new attribute defined to distinguish from\n+;;\t         mt group instructions.\n+;;\n+;; lds_to_fpscr  The \"type\" attribute couldn't sufficiently\n+;;               distinguish it from others.It is part of \n+;;               new attribute.Similar case with ldsmem_to_fpscr\n+;;\t  \t and cwb. \n+\n+(define_attr \"insn_class\"\n+\t     \"mt_group,ex_group,lds_to_fpscr,ldsmem_to_fpscr,cwb,none\"\n+\t     (const_string \"none\"))\n+\n ;; Indicate what precision must be selected in fpscr for this insn, if any.\n \n (define_attr \"fp_mode\" \"single,double,none\" (const_string \"none\"))\n@@ -631,7 +653,8 @@\n \t\t       (match_operand:SI 1 \"arith_operand\" \"L,r\"))\n \t       (const_int 0)))]\n   \"TARGET_SH1\"\n-  \"tst\t%1,%0\")\n+  \"tst\t%1,%0\"\n+  [(set_attr \"insn_class\" \"mt_group\")])\n \n ;; ??? Perhaps should only accept reg/constant if the register is reg 0.\n ;; That would still allow reload to create cmpi instructions, but would\n@@ -647,7 +670,8 @@\n   \"@\n \ttst\t%0,%0\n \tcmp/eq\t%1,%0\n-\tcmp/eq\t%1,%0\")\n+\tcmp/eq\t%1,%0\"\n+   [(set_attr \"insn_class\" \"mt_group,mt_group,mt_group\")])\n \n (define_insn \"cmpgtsi_t\"\n   [(set (reg:SI T_REG)\n@@ -656,7 +680,8 @@\n   \"TARGET_SH1\"\n   \"@\n \tcmp/gt\t%1,%0\n-\tcmp/pl\t%0\")\n+\tcmp/pl\t%0\"\n+   [(set_attr \"insn_class\" \"mt_group,mt_group\")])\n \n (define_insn \"cmpgesi_t\"\n   [(set (reg:SI T_REG)\n@@ -665,8 +690,9 @@\n   \"TARGET_SH1\"\n   \"@\n \tcmp/ge\t%1,%0\n-\tcmp/pz\t%0\")\n-\f\n+\tcmp/pz\t%0\"\n+   [(set_attr \"insn_class\" \"mt_group,mt_group\")])\n+\n ;; -------------------------------------------------------------------------\n ;; SImode unsigned integer comparisons\n ;; -------------------------------------------------------------------------\n@@ -676,14 +702,16 @@\n \t(geu:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n \t\t(match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n-  \"cmp/hs\t%1,%0\")\n+  \"cmp/hs\t%1,%0\"\n+   [(set_attr \"insn_class\" \"mt_group\")])\n \n (define_insn \"cmpgtusi_t\"\n   [(set (reg:SI T_REG)\n \t(gtu:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n \t\t(match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n-  \"cmp/hi\t%1,%0\")\n+  \"cmp/hi\t%1,%0\"\n+   [(set_attr \"insn_class\" \"mt_group\")])\n \n ;; We save the compare operands in the cmpxx patterns and use them when\n ;; we generate the branch.\n@@ -1050,7 +1078,8 @@\n \t(ltu:SI (plus:SI (match_dup 1) (match_dup 2)) (match_dup 1)))]\n   \"TARGET_SH1\"\n   \"addc\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"addc1\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n@@ -1060,7 +1089,8 @@\n    (clobber (reg:SI T_REG))]\n   \"TARGET_SH1\"\n   \"addc\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_expand \"addsi3\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n@@ -1088,8 +1118,9 @@\n \t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n   \"TARGET_SH1\"\n   \"add\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")])\n-\f\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n+\n ;; -------------------------------------------------------------------------\n ;; Subtraction instructions\n ;; -------------------------------------------------------------------------\n@@ -1155,7 +1186,8 @@\n \t(gtu:SI (minus:SI (match_dup 1) (match_dup 2)) (match_dup 1)))]\n   \"TARGET_SH1\"\n   \"subc\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"subc1\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n@@ -1165,15 +1197,17 @@\n    (clobber (reg:SI T_REG))]\n   \"TARGET_SH1\"\n   \"subc\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"*subsi3_internal\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(minus:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n \t\t  (match_operand:SI 2 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n   \"sub\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"*subsi3_media\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n@@ -1909,7 +1943,8 @@\n \t\t(match_operand:SI 2 \"logical_operand\" \"r,L\")))]\n   \"TARGET_SH1\"\n   \"and\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n ;; If the constant is 255, then emit a extu.b instruction instead of an\n ;; and, since that will give better code.\n@@ -1951,7 +1986,8 @@\n \t\t(match_operand:SI 2 \"logical_operand\" \"r,L\")))]\n   \"TARGET_SH1\"\n   \"or\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"iordi3\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r,r\")\n@@ -1968,7 +2004,8 @@\n \t\t(match_operand:SI 2 \"logical_operand\" \"L,r\")))]\n   \"TARGET_SH1\"\n   \"xor\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"xordi3\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r,r\")\n@@ -1991,7 +2028,8 @@\n \t(lshiftrt:SI (match_dup 1) (const_int 31)))]\n   \"TARGET_SH1\"\n   \"rotl\t%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"rotlsi3_31\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n@@ -2000,15 +2038,17 @@\n    (clobber (reg:SI T_REG))]\n   \"TARGET_SH1\"\n   \"rotr\t%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"rotlsi3_16\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(rotate:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n \t\t   (const_int 16)))]\n   \"TARGET_SH1\"\n   \"swap.w\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+  (set_attr \"insn_class\" \"ex_group\")])\n \n (define_expand \"rotlsi3\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n@@ -2072,7 +2112,8 @@\n \t\t   (const_int 8)))]\n   \"TARGET_SH1\"\n   \"swap.b\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_expand \"rotlhi3\"\n   [(set (match_operand:HI 0 \"arith_reg_operand\" \"\")\n@@ -2114,7 +2155,8 @@\n      (clobber (match_dup 4))])]\n   \"operands[4] = gen_rtx_SCRATCH (SImode);\"\n   [(set_attr \"length\" \"*,*,*,4\")\n-   (set_attr \"type\" \"dyn_shift,arith,arith,arith\")])\n+   (set_attr \"type\" \"dyn_shift,arith,arith,arith\")\n+   (set_attr \"insn_class\" \"ex_group,ex_group,ex_group,ex_group\")])\n \n (define_insn \"ashlhi3_k\"\n   [(set (match_operand:HI 0 \"arith_reg_operand\" \"=r,r\")\n@@ -2124,7 +2166,8 @@\n   \"@\n \tadd\t%0,%0\n \tshll%O2\t%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"ashlsi3_n\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n@@ -2141,7 +2184,8 @@\n \t       (eq (symbol_ref \"shift_insns_rtx (insn)\") (const_int 3))\n \t       (const_string \"6\")]\n \t      (const_string \"8\")))\n-   (set_attr \"type\" \"arith\")])\n+   (set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n@@ -2229,7 +2273,8 @@\n    (clobber (reg:SI T_REG))]\n   \"TARGET_SH1 && INTVAL (operands[2]) == 1\"\n   \"shar\t%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n ;; We can't do HImode right shifts correctly unless we start out with an\n ;; explicit zero / sign extension; doing that would result in worse overall\n@@ -2288,15 +2333,17 @@\n \t(lt:SI (match_dup 1) (const_int 0)))]\n   \"TARGET_SH1\"\n   \"shll\t%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"ashrsi3_d\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n \t\t     (neg:SI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))]\n   \"TARGET_SH3\"\n   \"shad\t%2,%0\"\n-  [(set_attr \"type\" \"dyn_shift\")])\n+  [(set_attr \"type\" \"dyn_shift\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"ashrsi3_n\"\n   [(set (reg:SI R4_REG)\n@@ -2346,7 +2393,8 @@\n \t\t     (neg:SI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))]\n   \"TARGET_SH3\"\n   \"shld\t%2,%0\"\n-  [(set_attr \"type\" \"dyn_shift\")])\n+  [(set_attr \"type\" \"dyn_shift\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n ;;  Only the single bit shift clobbers the T bit.\n \n@@ -2357,7 +2405,8 @@\n    (clobber (reg:SI T_REG))]\n   \"TARGET_SH1 && CONST_OK_FOR_M (INTVAL (operands[2]))\"\n   \"shlr\t%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"lshrsi3_k\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n@@ -2366,7 +2415,8 @@\n   \"TARGET_SH1 && CONST_OK_FOR_K (INTVAL (operands[2]))\n    && ! CONST_OK_FOR_M (INTVAL (operands[2]))\"\n   \"shlr%O2\t%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"lshrsi3_n\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n@@ -2444,7 +2494,8 @@\n   \"TARGET_SH1\"\n   \"shll\t%R0\\;rotcl\t%S0\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"arith\")])\n+   (set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"ashldi3_media\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r,r\")\n@@ -2483,7 +2534,8 @@\n   \"TARGET_SH1\"\n   \"shlr\t%S0\\;rotcr\t%R0\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"arith\")])\n+   (set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"lshrdi3_media\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r,r\")\n@@ -2522,7 +2574,8 @@\n   \"TARGET_SH1\"\n   \"shar\t%S0\\;rotcr\t%R0\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"arith\")])\n+   (set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"ashrdi3_media\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r,r\")\n@@ -2756,7 +2809,8 @@\n \t\t\t     (const_int 16))))]\n   \"TARGET_SH1\"\n   \"xtrct\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"xtrct_right\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n@@ -2766,8 +2820,9 @@\n \t\t\t   (const_int 16))))]\n   \"TARGET_SH1\"\n   \"xtrct\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")])\n-\f\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n+\n ;; -------------------------------------------------------------------------\n ;; Unary arithmetic\n ;; -------------------------------------------------------------------------\n@@ -2781,7 +2836,8 @@\n \t       (const_int 0)))]\n   \"TARGET_SH1\"\n   \"negc\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"*negdi_media\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n@@ -2819,14 +2875,16 @@\n \t(neg:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n   \"neg\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"one_cmplsi2\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(not:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n   \"not\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_expand \"one_cmpldi2\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n@@ -2872,22 +2930,25 @@\n \t(zero_extend:SI (match_operand:HI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n   \"extu.w\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"zero_extendqisi2\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(zero_extend:SI (match_operand:QI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n   \"extu.b\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n \n (define_insn \"zero_extendqihi2\"\n   [(set (match_operand:HI 0 \"arith_reg_operand\" \"=r\")\n \t(zero_extend:HI (match_operand:QI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n   \"extu.b\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")])\n-\f\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"insn_class\" \"ex_group\")])\n+\n ;; -------------------------------------------------------------------------\n ;; Sign extension instructions\n ;; -------------------------------------------------------------------------\n@@ -2941,7 +3002,8 @@\n   \"@\n \texts.w\t%1,%0\n    \tmov.w\t%1,%0\"\n-  [(set_attr \"type\" \"arith,load\")])\n+  [(set_attr \"type\" \"arith,load\")\n+   (set_attr \"insn_class\" \"ex_group,*\")])\n \n (define_insn \"extendqisi2\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,r\")\n@@ -2950,7 +3012,8 @@\n   \"@\n \texts.b\t%1,%0\n \tmov.b\t%1,%0\"\n-  [(set_attr \"type\" \"arith,load\")])\n+  [(set_attr \"type\" \"arith,load\")\n+   (set_attr \"insn_class\" \"ex_group,*\")])\n \n (define_insn \"extendqihi2\"\n   [(set (match_operand:HI 0 \"arith_reg_operand\" \"=r,r\")\n@@ -2959,8 +3022,9 @@\n   \"@\n \texts.b\t%1,%0\n \tmov.b\t%1,%0\"\n-  [(set_attr \"type\" \"arith,load\")])\n-\f\n+  [(set_attr \"type\" \"arith,load\")\n+   (set_attr \"insn_class\" \"ex_group,*\")])\n+\n ;; -------------------------------------------------------------------------\n ;; Move instructions\n ;; -------------------------------------------------------------------------\n@@ -3070,6 +3134,7 @@\n \tlds.l\t%1,%0\n \tfake\t%1,%0\"\n   [(set_attr \"type\" \"pcload_si,move,*,load_si,move,prget,move,store,store,pstore,move,prset,load,pload,pcload_si\")\n+   (set_attr \"insn_class\"  \"*,*,mt_group,*,*,*,*,*,*,*,*,*,*,*,*\")\n    (set_attr \"length\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,*\")])\n \n ;; t/r must come after r/r, lest reload will try to reload stuff like\n@@ -3227,7 +3292,8 @@\n    (clobber (match_scratch:SI 2 \"=&r\"))]\n   \"TARGET_HARD_SH4\"\n   \"ocbwb\\\\t@%0\\;extu.w\\\\t%0,%2\\;or\\\\t%1,%2\\;mov.l\\\\t%0,@%2\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"insn_class\" \"cwb\")])\n \n (define_insn \"ic_invalidate_line_media\"\n   [(unspec_volatile [(match_operand 0 \"register_operand\" \"r\")]\n@@ -7415,7 +7481,8 @@\n \tmov.l\t%1,%0\n \tsts\tfpscr,%0\"\n   [(set_attr \"length\" \"0,2,2,4,2,2,2,2\")\n-   (set_attr \"type\" \"dfp_conv,dfp_conv,load,dfp_conv,dfp_conv,move,store,gp_fpul\")])\n+   (set_attr \"type\" \"dfp_conv,dfp_conv,load,dfp_conv,dfp_conv,move,store,gp_fpul\")\n+   (set_attr \"insn_class\" \"ldsmem_to_fpscr,*,*,lds_to_fpscr,*,*,*,*\")])\n \n (define_split\n   [(set (reg:PSI FPSCR_REG)\n@@ -8557,3 +8624,292 @@\n   \"TARGET_SH1\"\n   \"mov.l @r15+,r15\\;mov.l @r15+,r0\"\n   [(set_attr \"length\" \"4\")])\n+\n+;; The following description  models the\n+;; SH4 pipeline using the DFA based scheduler. \n+;; The DFA based description is better way to model \n+;; a superscalar pipeline as compared to function unit\n+;; reservation model.   \n+;; 1. The function unit based model is oriented to describe at most one \n+;;    unit reservation by each insn. It is difficult to model unit reservations in multiple \n+;;    pipeline units by same insn. This can be done using DFA based description.\n+;; 2. The execution performance of DFA based scheduler does not depend on processor complexity.\n+;; 3. Writing all unit reservations for an instruction class is more natural description \n+;;    of the pipeline and makes interface of the hazard recognizer simpler than the \n+;;    old function unit based model.\n+;; 4. The DFA model is richer and is a part of greater overall framework of RCSP.\n+\n+\n+;; Two automata are defined to reduce number of states\n+;; which a single large automaton will have.(Factoring)\n+\n+(define_automaton \"inst_pipeline,fpu_pipe\")\n+\n+;; This unit is basically the decode unit of the processor.\n+;; Since SH4 is a dual issue machine,it is as if there are two \n+;; units so that any insn can be processed by either one\n+;; of the decoding unit.\n+\n+(define_cpu_unit \"pipe_01,pipe_02\" \"inst_pipeline\")\n+\n+\n+;; The fixed point arithmetic calculator(?? EX Unit).\n+\n+(define_cpu_unit  \"int\" \"inst_pipeline\")\n+\n+;; f1_1 and f1_2 are floating point units.Actually there is\n+;; a f1 unit which can overlap with other f1 unit but\n+;; not another F1 unit.It is as though there were two\n+;; f1 units.\n+\n+(define_cpu_unit \"f1_1,f1_2\" \"fpu_pipe\")\n+\n+;; The floating point units.\n+\n+(define_cpu_unit \"F1,F2,F3,FS\" \"fpu_pipe\")\n+\n+;; This is basically the MA unit of SH4\n+;; used in LOAD/STORE pipeline.\n+\n+(define_cpu_unit \"memory\" \"inst_pipeline\")\n+\n+;; The address calculator used for branch instructions.\n+;; This will be reserved with \"issue\" of branch instructions\n+;; and this is to make sure that  no two branch instructions \n+;; can be issued in parallel. \n+\n+(define_cpu_unit \"pcr_addrcalc\" \"inst_pipeline\")\n+\n+;; ----------------------------------------------------\n+;; This reservation is to simplify the dual issue description.\n+\n+(define_reservation  \"issue\"  \"pipe_01|pipe_02\")\n+\n+;; This is to express the locking of D stage.\n+\n+(define_reservation  \"d_lock\" \"pipe_01+pipe_02\")\n+\n+;; This is to simplify description where F1,F2,FS\n+;; are used simultaneously.\n+\n+(define_reservation \"fpu\" \"F1+F2+FS\")\n+\n+;; This is to highlight the fact that f1 \n+;; cannot overlap with F1.\n+\n+(exclusion_set  \"f1_1,f1_2\" \"F1\")\n+\n+;; Although reg moves have a latency of zero \n+;; we need to highlight that they use D stage\n+;; for one cycle.\n+\n+(define_insn_reservation \"reg_mov\" 0\n+               (eq_attr \"type\" \"move,fmove\")\n+              \"issue\")\n+\n+;; Other MT  group intructions(1 step operations)\n+;; Group:\tMT\n+;; Latency: \t1\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"mt\" 1\n+                      (eq_attr \"insn_class\" \"mt_group\")\n+                      \"issue,nothing\")\n+\n+;; Fixed Point Arithmetic Instructions(1 step operations)\n+;; Group:\tEX\n+;; Latency: \t1\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"simple_arith\" 1 \n+            (eq_attr \"insn_class\" \"ex_group\")\n+            \"issue,int\")\n+\n+;; Load Store instructions. (MOV.[BWL]@(d,GBR)\n+;; Group:\tLS\n+;; Latency: \t2\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"load_store\" 2\n+       (eq_attr \"type\" \"load,load_si,pcload,pcload_si,store\")\n+       \"issue,memory*2\")\n+\n+;; Branch (BF,BF/S,BT,BT/S,BRA)\n+;; Group:\tBR\n+;; Latency: \t2 (or 1) Actually Observed to be 5/7\n+;; Issue Rate: \t1\n+;; The latency is 1 when displacement is 0.\n+;; This reservation can be further broken into 2\n+;;    1. branch_zero : One with latency 1 and in the TEST \n+;;       part it also checks for 0 (ZERO) displacement \n+;;    2. branch: Latency 2.\n+\n+(define_insn_reservation \"branch_zero\"  5\n+             (and (eq_attr \"type\" \"cbranch\")\n+\t\t  (eq_attr \"length\" \"2\"))\n+             \"(issue+pcr_addrcalc),pcr_addrcalc,nothing\")\n+\n+(define_insn_reservation \"branch\"  7\n+             (eq_attr \"type\" \"cbranch\")\n+             \"(issue+pcr_addrcalc),pcr_addrcalc,nothing\")\n+\n+;; Branch Far (JMP,RTS,BRAF)\n+;; Group:\tCO\n+;; Latency: \t3\n+;; Issue Rate: \t2\n+;;    Since issue stage (D stage) is blocked for 2nd cycle, \n+;;    cpu_unit  int  is reserved since it might be required for far\n+;;    address calculation.\n+\n+(define_insn_reservation \"branch_far\" 12\n+         (and (eq_attr \"type\" \"jump,return\")\n+\t      (eq_attr \"length\" \"6\"))\n+         \"d_lock*2,int+pcr_addrcalc,pcr_addrcalc\")\n+\n+;; RTE\n+;; Group:\tCO\n+;; atency: \t5\n+;; Issue Rate: \t5\n+;; this instruction can be executed in any of the pipelines \n+;; and blocks the pipeline for next 4 stages.\n+\n+(define_insn_reservation \"return_from_exp\" 5\n+          (eq_attr \"type\" \"rte\")\n+         \"(issue+pcr_addrcalc),d_lock*4,int+pcr_addrcalc,nothing\")\n+\n+;; OCBP, OCBWB\n+;; Group:\tCO\n+;; Latency: \t5\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"ocbwb\"  5\n+          (eq_attr \"insn_class\" \"cwb\") \n+ \t   \"issue,(int+memory),memory*5\")\n+\t\t\n+;; LDS to PR,JSR\n+;; Group:\tCO\n+;; Latency: \t3\n+;; Issue Rate: \t2\n+;; The SX stage is blocked for last 2 cycles.\n+\n+(define_insn_reservation \"lds_to_pr\" 3 \n+          (eq_attr \"type\" \"prset,call,sfunc\") \n+          \"(issue+pcr_addrcalc),(issue+int+pcr_addrcalc),(int+pcr_addrcalc)*2\")\n+\n+;; LDS.L to PR \n+;; Group:\tCO\n+;; Latency: \t3\n+;; Issue Rate: \t2\n+;; The SX unit is blocked for last 2 cycles.\n+ \n+(define_insn_reservation \"ldsmem_to_pr\"  3\n+      (eq_attr \"type\" \"pload\") \n+     \"(issue+pcr_addrcalc),(issue+int+pcr_addrcalc),(int+memory+pcr_addrcalc),(int+pcr_addrcalc)\")\n+\n+;; STS from PR\n+;; Group:\tCO\n+;; Latency: \t2\n+;; Issue Rate: \t2\n+;; The SX unit in second and third cycles.\n+\n+(define_insn_reservation \"sts_from_pr\" 2\n+        (eq_attr \"type\" \"prget\")\n+       \"(issue+pcr_addrcalc),(pipe_01+int+pcr_addrcalc),(int+pcr_addrcalc),nothing\")\n+\n+;; STS.L from PR\n+;; Group:\tCO\n+;; Latency: \t2\n+;; Issue Rate: \t2\n+\n+(define_insn_reservation \"prload_mem\" 2 \n+          (eq_attr \"type\" \"pstore\")\n+           \"(issue+pcr_addrcalc),(pipe_01+int+pcr_addrcalc),(int+memory+pcr_addrcalc),memory\")\n+\n+;; LDS to FPSCR\n+;; Group:\tCO\n+;; Latency: \t4\n+;; Issue Rate: \t1\n+;; F1 is blocked for last three cycles. \n+\n+(define_insn_reservation \"fpscr_store\" 4\n+        (eq_attr \"insn_class\" \"lds_to_fpscr\")\n+       \"issue,int,F1*3\")\n+\n+;; LDS.L to FPSCR\n+;; Group:\tCO\n+;; Latency: \t1 / 4\n+;; Latency to update Rn is 1 and latency to update FPSCR is 4\n+;; Issue Rate: \t1\n+;; F1 is blocked for last three cycles.\n+\n+(define_insn_reservation \"fpscr_store_mem\" 4\n+        (eq_attr \"insn_class\"  \"ldsmem_to_fpscr\") \n+        \"issue,(int+memory),(F1+memory),F1*2\")\n+\n+\f\n+;; Fixed point multiplication (DMULS.L DMULU.L MUL.L MULS.W,MULU.W)\n+;; Group:\tCO\n+;; Latency: \t4 / 4\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"multi\" 4\n+\t(eq_attr \"type\" \"smpy,dmpy\")\n+ \t\"issue,(issue+int+f1_1),(int+f1_1),(f1_1|f1_2)*2,F2,FS\")\n+\n+\n+;; Single precision floating point computation FCMP/EQ,\n+;; FCP/GT, FADD, FLOAT, FMAC, FMUL, FSUB, FTRC, FRVHG, FSCHG\n+;; Group:\tFE\n+;; Latency: \t4\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"fp_arith\"  4\n+              (eq_attr \"type\" \"fp\")\n+ \t      \"issue,F1,F2,FS\")\n+\n+;; Single Precision FDIV/SQRT\n+;; Group:\tFE\n+;; Latency: \t12/13\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"fp_div\" 13\n+               (eq_attr \"type\" \"fdiv\")\n+               \"issue,F1+F3,F1+F2+F3,F3*7,F1+F3,F2,FS\")\n+\n+;; Double Precision floating point computation\n+;; (FCNVDS, FCNVSD, FLOAT, FTRC)\n+;; Group:\tFE\n+;; Latency: \t(3,4)/5\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"dp_float\" 5\n+         (eq_attr \"type\" \"dfp_conv\")\n+\t \"issue,F1,F1+F2,F2+FS,FS\")\n+\n+;; Double-precision floating-point (FADD ,FMUL,FSUB) \n+;; Group:\tFE\n+;; Latency: \t(7,8)/9\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"fp_double_arith\" 9\n+        (eq_attr \"type\" \"dfp_arith\")\n+\t\"issue,F1,F1+F2,fpu*4,F2+FS,FS\")\n+\n+;; Double-precision FCMP (FCMP/EQ,FCMP/GT) \n+;; Group:\tFE\n+;; Latency: \t3/5\n+;; Issue Rate: \t2\n+\n+(define_insn_reservation \"fp_double_cmp\" 5 \n+        (eq_attr \"type\" \"dfp_cmp\")\n+\t\"issue,(issue+F1),F1+F2,F2+FS,FS\")\n+\n+;; Double precision FDIV/SQRT\n+;; Group:\tFE\n+;; Latency: \t(24,25)/26\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"dp_div\" 26\n+        (eq_attr \"type\" \"dfdiv\")\n+ \t\"issue,F1+F3,F1+F2+F3,F2+F3+FS,F3*16,F1+F3,F1+F2+F3,fpu+F3,F2+FS,FS\")\n+"}, {"sha": "fef6ecb6db0f9bb26bdf8606e83253c812282c86", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -117,6 +117,8 @@ extern char *sparc_v8plus_shift PARAMS ((rtx *, rtx, const char *));\n    32 bits of REG are 0 before INSN.  */   \n extern int sparc_check_64 PARAMS ((rtx, rtx));\n extern rtx gen_df_reg PARAMS ((rtx, int));\n+/* Used for DFA scheduling when cpu is ultrasparc.  */\n+extern int ultrasparc_store_bypass_p PARAMS ((rtx, rtx));\n extern int sparc_extra_constraint_check PARAMS ((rtx, int, int));\n #endif /* RTX_CODE */\n "}, {"sha": "2f7633638bc467db2f93639d72589ae0e323e3fa", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 101, "deletions": 919, "changes": 1020, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -140,22 +140,14 @@ static int function_arg_slotno\tPARAMS ((const CUMULATIVE_ARGS *,\n \n static int supersparc_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n static int hypersparc_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n-static int ultrasparc_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n \n static void sparc_output_addr_vec PARAMS ((rtx));\n static void sparc_output_addr_diff_vec PARAMS ((rtx));\n static void sparc_output_deferred_case_vectors PARAMS ((void));\n static void sparc_add_gc_roots    PARAMS ((void));\n-static void mark_ultrasparc_pipeline_state PARAMS ((void *));\n static int check_return_regs PARAMS ((rtx));\n static int epilogue_renumber PARAMS ((rtx *, int));\n static bool sparc_assemble_integer PARAMS ((rtx, unsigned int, int));\n-static int ultra_cmove_results_ready_p PARAMS ((rtx));\n-static int ultra_fpmode_conflict_exists PARAMS ((enum machine_mode));\n-static rtx *ultra_find_type PARAMS ((int, rtx *, int));\n-static void ultra_build_types_avail PARAMS ((rtx *, int));\n-static void ultra_flush_pipeline PARAMS ((void));\n-static void ultra_rescan_pipeline_state PARAMS ((rtx *, int));\n static int set_extends PARAMS ((rtx));\n static void output_restore_regs PARAMS ((FILE *, int));\n static void sparc_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n@@ -169,15 +161,13 @@ static void sparc_nonflat_function_prologue PARAMS ((FILE *, HOST_WIDE_INT,\n #ifdef OBJECT_FORMAT_ELF\n static void sparc_elf_asm_named_section PARAMS ((const char *, unsigned int));\n #endif\n-static void ultrasparc_sched_reorder PARAMS ((FILE *, int, rtx *, int));\n-static int ultrasparc_variable_issue PARAMS ((rtx));\n-static void ultrasparc_sched_init PARAMS ((void));\n \n static int sparc_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n static int sparc_issue_rate PARAMS ((void));\n-static int sparc_variable_issue PARAMS ((FILE *, int, rtx, int));\n static void sparc_sched_init PARAMS ((FILE *, int, int));\n-static int sparc_sched_reorder PARAMS ((FILE *, int, rtx *, int *, int));\n+static int sparc_use_dfa_pipeline_interface PARAMS ((void));\n+static int sparc_use_sched_lookahead PARAMS ((void));\n+static rtx sparc_cycle_display PARAMS ((int, rtx));\n \f\n /* Option handling.  */\n \n@@ -231,12 +221,14 @@ enum processor_type sparc_cpu;\n #define TARGET_SCHED_ADJUST_COST sparc_adjust_cost\n #undef TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE sparc_issue_rate\n-#undef TARGET_SCHED_VARIABLE_ISSUE\n-#define TARGET_SCHED_VARIABLE_ISSUE sparc_variable_issue\n #undef TARGET_SCHED_INIT\n #define TARGET_SCHED_INIT sparc_sched_init\n-#undef TARGET_SCHED_REORDER\n-#define TARGET_SCHED_REORDER sparc_sched_reorder\n+#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n+#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE sparc_use_dfa_pipeline_interface\n+#undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n+#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD sparc_use_sched_lookahead\n+#undef TARGET_SCHED_CYCLE_DISPLAY\n+#define TARGET_SCHED_CYCLE_DISPLAY sparc_cycle_display\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -273,6 +265,7 @@ sparc_override_options ()\n     { TARGET_CPU_supersparc, \"supersparc\" },\n     { TARGET_CPU_v9, \"v9\" },\n     { TARGET_CPU_ultrasparc, \"ultrasparc\" },\n+    { TARGET_CPU_ultrasparc3, \"ultrasparc3\" },\n     { 0, 0 }\n   };\n   const struct cpu_default *def;\n@@ -305,6 +298,9 @@ sparc_override_options ()\n     /* Although insns using %y are deprecated, it is a clear win on current\n        ultrasparcs.  */\n     \t\t\t\t\t\t    |MASK_DEPRECATED_V8_INSNS},\n+    /* TI ultrasparc III */\n+    /* ??? Check if %y issue still holds true in ultra3.  */\n+    { \"ultrasparc3\", PROCESSOR_ULTRASPARC3, MASK_ISA, MASK_V9|MASK_DEPRECATED_V8_INSNS},\n     { 0, 0, 0, 0 }\n   };\n   const struct cpu_table *cpu;\n@@ -417,7 +413,9 @@ sparc_override_options ()\n     target_flags &= ~MASK_STACK_BIAS;\n     \n   /* Supply a default value for align_functions.  */\n-  if (align_functions == 0 && sparc_cpu == PROCESSOR_ULTRASPARC)\n+  if (align_functions == 0\n+      && (sparc_cpu == PROCESSOR_ULTRASPARC\n+\t  || sparc_cpu == PROCESSOR_ULTRASPARC3))\n     align_functions = 32;\n \n   /* Validate PCC_STRUCT_RETURN.  */\n@@ -6479,7 +6477,8 @@ sparc64_initialize_trampoline (tramp, fnaddr, cxt)\n   emit_move_insn (gen_rtx_MEM (DImode, plus_constant (tramp, 24)), fnaddr);\n   emit_insn (gen_flushdi (validize_mem (gen_rtx_MEM (DImode, tramp))));\n \n-  if (sparc_cpu != PROCESSOR_ULTRASPARC)\n+  if (sparc_cpu != PROCESSOR_ULTRASPARC\n+      && sparc_cpu != PROCESSOR_ULTRASPARC3)\n     emit_insn (gen_flushdi (validize_mem (gen_rtx_MEM (DImode, plus_constant (tramp, 8)))));\n }\n \f\n@@ -7331,157 +7330,6 @@ hypersparc_adjust_cost (insn, link, dep_insn, cost)\n   return cost;\n }\n \n-static int\n-ultrasparc_adjust_cost (insn, link, dep_insn, cost)\n-     rtx insn;\n-     rtx link;\n-     rtx dep_insn;\n-     int cost;\n-{\n-  enum attr_type insn_type, dep_type;\n-  rtx pat = PATTERN(insn);\n-  rtx dep_pat = PATTERN (dep_insn);\n-\n-  if (recog_memoized (insn) < 0 || recog_memoized (dep_insn) < 0)\n-    return cost;\n-\n-  insn_type = get_attr_type (insn);\n-  dep_type = get_attr_type (dep_insn);\n-\n-  /* Nothing issues in parallel with integer multiplies, so\n-     mark as zero cost since the scheduler can not do anything\n-     about it.  */\n-  if (insn_type == TYPE_IMUL || insn_type == TYPE_IDIV)\n-    return 0;\n-\n-#define SLOW_FP(dep_type) \\\n-(dep_type == TYPE_FPSQRTS || dep_type == TYPE_FPSQRTD || \\\n- dep_type == TYPE_FPDIVS || dep_type == TYPE_FPDIVD)\n-\n-  switch (REG_NOTE_KIND (link))\n-    {\n-    case 0:\n-      /* Data dependency; DEP_INSN writes a register that INSN reads some\n-\t cycles later.  */\n-\n-      if (dep_type == TYPE_CMOVE)\n-\t{\n-\t  /* Instructions that read the result of conditional moves cannot\n-\t     be in the same group or the following group.  */\n-\t  return cost + 1;\n-\t}\n-\n-      switch (insn_type)\n-\t{\n-\t  /* UltraSPARC can dual issue a store and an instruction setting\n-\t     the value stored, except for divide and square root.  */\n-\tcase TYPE_FPSTORE:\n-\t  if (! SLOW_FP (dep_type))\n-\t    return 0;\n-\t  return cost;\n-\n-\tcase TYPE_STORE:\n-\t  if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET)\n-\t    return cost;\n-\n-\t  if (rtx_equal_p (SET_DEST (dep_pat), SET_SRC (pat)))\n-\t    /* The dependency between the two instructions is on the data\n-\t       that is being stored.  Assume that the address of the store\n-\t       is not also dependent.  */\n-\t    return 0;\n-\t  return cost;\n-\n-\tcase TYPE_LOAD:\n-\tcase TYPE_SLOAD:\n-\tcase TYPE_FPLOAD:\n-\t  /* A load does not return data until at least 11 cycles after\n-\t     a store to the same location.  3 cycles are accounted for\n-\t     in the load latency; add the other 8 here.  */\n-\t  if (dep_type == TYPE_STORE || dep_type == TYPE_FPSTORE)\n-\t    {\n-\t      /* If the addresses are not equal this may be a false\n-\t\t dependency because pointer aliasing could not be\n-\t\t determined.  Add only 2 cycles in that case.  2 is\n-\t\t an arbitrary compromise between 8, which would cause\n-\t\t the scheduler to generate worse code elsewhere to\n-\t\t compensate for a dependency which might not really\n-\t\t exist, and 0.  */\n-\t      if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET\n-\t\t  || GET_CODE (SET_SRC (pat)) != MEM\n-\t\t  || GET_CODE (SET_DEST (dep_pat)) != MEM\n-\t\t  || ! rtx_equal_p (XEXP (SET_SRC (pat), 0),\n-\t\t\t\t    XEXP (SET_DEST (dep_pat), 0)))\n-\t\treturn cost + 2;\n-\n-\t      return cost + 8;\n-\t    }\n-\t  return cost;\n-\n-\tcase TYPE_BRANCH:\n-\t  /* Compare to branch latency is 0.  There is no benefit from\n-\t     separating compare and branch.  */\n-\t  if (dep_type == TYPE_COMPARE)\n-\t    return 0;\n-\t  /* Floating point compare to branch latency is less than\n-\t     compare to conditional move.  */\n-\t  if (dep_type == TYPE_FPCMP)\n-\t    return cost - 1;\n-\t  return cost;\n-\n-\tcase TYPE_FPCMOVE:\n-\t  /* FMOVR class instructions can not issue in the same cycle\n-\t     or the cycle after an instruction which writes any\n-\t     integer register.  Model this as cost 2 for dependent\n-\t     instructions.  */\n-\t  if (dep_type == TYPE_IALU\n-\t      && cost < 2)\n-\t    return 2;\n-\t  /* Otherwise check as for integer conditional moves.  */\n-\n-\tcase TYPE_CMOVE:\n-\t  /* Conditional moves involving integer registers wait until\n-\t     3 cycles after loads return data.  The interlock applies\n-\t     to all loads, not just dependent loads, but that is hard\n-\t     to model.  */\n-\t  if (dep_type == TYPE_LOAD || dep_type == TYPE_SLOAD)\n-\t    return cost + 3;\n-\t  return cost;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-      break;\n-\n-    case REG_DEP_ANTI:\n-      /* Divide and square root lock destination registers for full latency.  */\n-      if (! SLOW_FP (dep_type))\n-\treturn 0;\n-      break;\n-\n-    case REG_DEP_OUTPUT:\n-      /* IEU and FPU instruction that have the same destination\n-\t register cannot be grouped together.  */\n-      return cost + 1;\n-\n-    default:\n-      break;\n-    }\n-\n-  /* Other costs not accounted for:\n-     - Single precision floating point loads lock the other half of\n-       the even/odd register pair.\n-     - Several hazards associated with ldd/std are ignored because these\n-       instructions are rarely generated for V9.\n-     - The floating point pipeline can not have both a single and double\n-       precision operation active at the same time.  Format conversions\n-       and graphics instructions are given honorary double precision status.\n-     - call and jmpl are always the first instruction in a group.  */\n-\n-  return cost;\n-\n-#undef SLOW_FP\n-}\n-\n static int\n sparc_adjust_cost(insn, link, dep, cost)\n      rtx insn;\n@@ -7498,792 +7346,143 @@ sparc_adjust_cost(insn, link, dep, cost)\n     case PROCESSOR_SPARCLITE86X:\n       cost = hypersparc_adjust_cost (insn, link, dep, cost);\n       break;\n-    case PROCESSOR_ULTRASPARC:\n-      cost = ultrasparc_adjust_cost (insn, link, dep, cost);\n-      break;\n     default:\n       break;\n     }\n   return cost;\n }\n \n-/* This describes the state of the UltraSPARC pipeline during\n-   instruction scheduling.  */\n-\n-#define TMASK(__x)\t((unsigned)1 << ((int)(__x)))\n-#define UMASK(__x)\t((unsigned)1 << ((int)(__x)))\n-\n-enum ultra_code { NONE=0, /* no insn at all\t\t\t\t*/\n-\t\t  IEU0,   /* shifts and conditional moves\t\t*/\n-\t\t  IEU1,   /* condition code setting insns, calls+jumps\t*/\n-\t\t  IEUN,   /* all other single cycle ieu insns\t\t*/\n-\t\t  LSU,    /* loads and stores\t\t\t\t*/\n-\t\t  CTI,    /* branches\t\t\t\t\t*/\n-\t\t  FPM,    /* FPU pipeline 1, multiplies and divides\t*/\n-\t\t  FPA,    /* FPU pipeline 2, all other operations\t*/\n-\t\t  SINGLE, /* single issue instructions\t\t\t*/\n-\t\t  NUM_ULTRA_CODES };\n-\n-static enum ultra_code ultra_code_from_mask PARAMS ((int));\n-static void ultra_schedule_insn PARAMS ((rtx *, rtx *, int, enum ultra_code));\n-\n-static const char *const ultra_code_names[NUM_ULTRA_CODES] = {\n-  \"NONE\", \"IEU0\", \"IEU1\", \"IEUN\", \"LSU\", \"CTI\",\n-  \"FPM\", \"FPA\", \"SINGLE\" };\n-\n-struct ultrasparc_pipeline_state {\n-  /* The insns in this group.  */\n-  rtx group[4];\n-\n-  /* The code for each insn.  */\n-  enum ultra_code codes[4];\n-\n-  /* Which insns in this group have been committed by the\n-     scheduler.  This is how we determine how many more\n-     can issue this cycle.  */\n-  char commit[4];\n-\n-  /* How many insns in this group.  */\n-  char group_size;\n-\n-  /* Mask of free slots still in this group.  */\n-  char free_slot_mask;\n-\n-  /* The slotter uses the following to determine what other\n-     insn types can still make their way into this group.  */\n-  char contents [NUM_ULTRA_CODES];\n-  char num_ieu_insns;\n-};\n-\n-#define ULTRA_NUM_HIST\t8\n-static struct ultrasparc_pipeline_state ultra_pipe_hist[ULTRA_NUM_HIST];\n-static int ultra_cur_hist;\n-static int ultra_cycles_elapsed;\n-\n-#define ultra_pipe\t(ultra_pipe_hist[ultra_cur_hist])\n-\n-/* Given TYPE_MASK compute the ultra_code it has.  */\n-static enum ultra_code\n-ultra_code_from_mask (type_mask)\n-     int type_mask;\n-{\n-  if (type_mask & (TMASK (TYPE_SHIFT) | TMASK (TYPE_CMOVE)))\n-    return IEU0;\n-  else if (type_mask & (TMASK (TYPE_COMPARE) |\n-\t\t\tTMASK (TYPE_CALL) |\n-\t\t\tTMASK (TYPE_SIBCALL) |\n-\t\t\tTMASK (TYPE_UNCOND_BRANCH)))\n-    return IEU1;\n-  else if (type_mask & TMASK (TYPE_IALU))\n-    return IEUN;\n-  else if (type_mask & (TMASK (TYPE_LOAD) | TMASK (TYPE_SLOAD) |\n-\t\t\tTMASK (TYPE_STORE) | TMASK (TYPE_FPLOAD) |\n-\t\t\tTMASK (TYPE_FPSTORE)))\n-    return LSU;\n-  else if (type_mask & (TMASK (TYPE_FPMUL) | TMASK (TYPE_FPDIVS) |\n-\t\t\tTMASK (TYPE_FPDIVD) | TMASK (TYPE_FPSQRTS) |\n-\t\t\tTMASK (TYPE_FPSQRTD)))\n-    return FPM;\n-  else if (type_mask & (TMASK (TYPE_FPMOVE) | TMASK (TYPE_FPCMOVE) |\n-\t\t\tTMASK (TYPE_FP) | TMASK (TYPE_FPCMP)))\n-    return FPA;\n-  else if (type_mask & TMASK (TYPE_BRANCH))\n-    return CTI;\n-\n-  return SINGLE;\n-}\n-\n-/* Check INSN (a conditional move) and make sure that it's\n-   results are available at this cycle.  Return 1 if the\n-   results are in fact ready.  */\n-static int\n-ultra_cmove_results_ready_p (insn)\n-     rtx insn;\n+static void\n+sparc_sched_init (dump, sched_verbose, max_ready)\n+     FILE *dump ATTRIBUTE_UNUSED;\n+     int sched_verbose ATTRIBUTE_UNUSED;\n+     int max_ready ATTRIBUTE_UNUSED;\n {\n-  struct ultrasparc_pipeline_state *up;\n-  int entry, slot;\n-\n-  /* If this got dispatched in the previous\n-     group, the results are not ready.  */\n-  entry = (ultra_cur_hist - 1) & (ULTRA_NUM_HIST - 1);\n-  up = &ultra_pipe_hist[entry];\n-  slot = 4;\n-  while (--slot >= 0)\n-    if (up->group[slot] == insn)\n-      return 0;\n-\n-  return 1;\n }\n-\n-/* Walk backwards in pipeline history looking for FPU\n-   operations which use a mode different than FPMODE and\n-   will create a stall if an insn using FPMODE were to be\n-   dispatched this cycle.  */\n+  \n static int\n-ultra_fpmode_conflict_exists (fpmode)\n-     enum machine_mode fpmode;\n+sparc_use_dfa_pipeline_interface ()\n {\n-  int hist_ent;\n-  int hist_lim;\n-\n-  hist_ent = (ultra_cur_hist - 1) & (ULTRA_NUM_HIST - 1);\n-  if (ultra_cycles_elapsed < 4)\n-    hist_lim = ultra_cycles_elapsed;\n-  else\n-    hist_lim = 4;\n-  while (hist_lim > 0)\n-    {\n-      struct ultrasparc_pipeline_state *up = &ultra_pipe_hist[hist_ent];\n-      int slot = 4;\n-\n-      while (--slot >= 0)\n-\t{\n-\t  rtx insn = up->group[slot];\n-\t  enum machine_mode this_mode;\n-\t  rtx pat;\n-\n-\t  if (! insn\n-\t      || GET_CODE (insn) != INSN\n-\t      || (pat = PATTERN (insn)) == 0\n-\t      || GET_CODE (pat) != SET)\n-\t    continue;\n-\n-\t  this_mode = GET_MODE (SET_DEST (pat));\n-\t  if ((this_mode != SFmode\n-\t       && this_mode != DFmode)\n-\t      || this_mode == fpmode)\n-\t    continue;\n-\n-\t  /* If it is not FMOV, FABS, FNEG, FDIV, or FSQRT then\n-\t     we will get a stall.  Loads and stores are independent\n-\t     of these rules.  */\n-\t  if (GET_CODE (SET_SRC (pat)) != ABS\n-\t      && GET_CODE (SET_SRC (pat)) != NEG\n-\t      && ((TMASK (get_attr_type (insn)) &\n-\t\t   (TMASK (TYPE_FPDIVS) | TMASK (TYPE_FPDIVD) |\n-\t\t    TMASK (TYPE_FPMOVE) | TMASK (TYPE_FPSQRTS) |\n-\t\t    TMASK (TYPE_FPSQRTD) |\n-                    TMASK (TYPE_LOAD) | TMASK (TYPE_STORE))) == 0))\n-\t    return 1;\n-\t}\n-      hist_lim--;\n-      hist_ent = (hist_ent - 1) & (ULTRA_NUM_HIST - 1);\n-    }\n-\n-  /* No conflicts, safe to dispatch.  */\n+  if ((1 << sparc_cpu) &\n+      ((1 << PROCESSOR_ULTRASPARC) | (1 << PROCESSOR_CYPRESS) |\n+       (1 << PROCESSOR_SUPERSPARC) | (1 << PROCESSOR_HYPERSPARC) |\n+       (1 << PROCESSOR_SPARCLITE86X) | (1 << PROCESSOR_TSC701) |\n+       (1 << PROCESSOR_ULTRASPARC3)))\n+    return 1;\n   return 0;\n }\n \n-/* Find an instruction in LIST which has one of the\n-   type attributes enumerated in TYPE_MASK.  START\n-   says where to begin the search.\n-\n-   NOTE: This scheme depends upon the fact that we\n-         have less than 32 distinct type attributes.  */\n-\n-static int ultra_types_avail;\n-\n-static rtx *\n-ultra_find_type (type_mask, list, start)\n-     int type_mask;\n-     rtx *list;\n-     int start;\n-{\n-  int i;\n-\n-  /* Short circuit if no such insn exists in the ready\n-     at the moment.  */\n-  if ((type_mask & ultra_types_avail) == 0)\n-    return 0;\n-\n-  for (i = start; i >= 0; i--)\n-    {\n-      rtx insn = list[i];\n-\n-      if (recog_memoized (insn) >= 0\n-\t  && (TMASK(get_attr_type (insn)) & type_mask))\n-\t{\n-\t  enum machine_mode fpmode = SFmode;\n-\t  rtx pat = 0;\n-\t  int slot;\n-\t  int check_depend = 0;\n-\t  int check_fpmode_conflict = 0;\n-\n-\t  if (GET_CODE (insn) == INSN\n-\t      && (pat = PATTERN(insn)) != 0\n-\t      && GET_CODE (pat) == SET\n-\t      && !(type_mask & (TMASK (TYPE_STORE) |\n-\t\t\t\tTMASK (TYPE_FPSTORE))))\n-\t    {\n-\t      check_depend = 1;\n-\t      if (GET_MODE (SET_DEST (pat)) == SFmode\n-\t\t  || GET_MODE (SET_DEST (pat)) == DFmode)\n-\t\t{\n-\t\t  fpmode = GET_MODE (SET_DEST (pat));\n-\t\t  check_fpmode_conflict = 1;\n-\t\t}\n-\t    }\n-\n-\t  slot = 4;\n-\t  while(--slot >= 0)\n-\t    {\n-\t      rtx slot_insn = ultra_pipe.group[slot];\n-\t      rtx slot_pat;\n-\n-\t      /* Already issued, bad dependency, or FPU\n-\t\t mode conflict.  */\n-\t      if (slot_insn != 0\n-\t\t  && (slot_pat = PATTERN (slot_insn)) != 0\n-\t\t  && ((insn == slot_insn)\n-\t\t      || (check_depend == 1\n-\t\t\t  && GET_CODE (slot_insn) == INSN\n-\t\t\t  && GET_CODE (slot_pat) == SET\n-\t\t\t  && ((GET_CODE (SET_DEST (slot_pat)) == REG\n-\t\t\t       && GET_CODE (SET_SRC (pat)) == REG\n-\t\t\t       && REGNO (SET_DEST (slot_pat)) ==\n-\t\t\t            REGNO (SET_SRC (pat)))\n-\t\t\t      || (GET_CODE (SET_DEST (slot_pat)) == SUBREG\n-\t\t\t\t  && GET_CODE (SET_SRC (pat)) == SUBREG\n-\t\t\t\t  && REGNO (SUBREG_REG (SET_DEST (slot_pat))) ==\n-\t\t\t\t       REGNO (SUBREG_REG (SET_SRC (pat)))\n-\t\t\t\t  && SUBREG_BYTE (SET_DEST (slot_pat)) ==\n-\t\t\t\t       SUBREG_BYTE (SET_SRC (pat)))))\n-\t\t      || (check_fpmode_conflict == 1\n-\t\t\t  && GET_CODE (slot_insn) == INSN\n-\t\t\t  && GET_CODE (slot_pat) == SET\n-\t\t\t  && (GET_MODE (SET_DEST (slot_pat)) == SFmode\n-\t\t\t      || GET_MODE (SET_DEST (slot_pat)) == DFmode)\n-\t\t\t  && GET_MODE (SET_DEST (slot_pat)) != fpmode)))\n-\t\tgoto next;\n-\t    }\n-\n-\t  /* Check for peculiar result availability and dispatch\n-\t     interference situations.  */\n-\t  if (pat != 0\n-\t      && ultra_cycles_elapsed > 0)\n-\t    {\n-\t      rtx link;\n-\n-\t      for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n-\t\t{\n-\t\t  rtx link_insn = XEXP (link, 0);\n-\t\t  if (GET_CODE (link_insn) == INSN\n-\t\t      && recog_memoized (link_insn) >= 0\n-\t\t      && (TMASK (get_attr_type (link_insn)) &\n-\t\t\t  (TMASK (TYPE_CMOVE) | TMASK (TYPE_FPCMOVE)))\n-\t\t      && ! ultra_cmove_results_ready_p (link_insn))\n-\t\t    goto next;\n-\t\t}\n-\n-\t      if (check_fpmode_conflict\n-\t\t  && ultra_fpmode_conflict_exists (fpmode))\n-\t\tgoto next;\n-\t    }\n-\n-\t  return &list[i];\n-\t}\n-    next:\n-      ;\n-    }\n+static int\n+sparc_use_sched_lookahead ()\n+{\n+  if (sparc_cpu == PROCESSOR_ULTRASPARC\n+      || sparc_cpu == PROCESSOR_ULTRASPARC3)\n+    return 4;\n+  if ((1 << sparc_cpu) &\n+      ((1 << PROCESSOR_SUPERSPARC) | (1 << PROCESSOR_HYPERSPARC) |\n+       (1 << PROCESSOR_SPARCLITE86X)))\n+    return 3;\n   return 0;\n }\n \n-static void\n-ultra_build_types_avail (ready, n_ready)\n-  rtx *ready;\n-  int n_ready;\n+static rtx\n+sparc_cycle_display (clock, last)\n+     int clock;\n+     rtx last;\n {\n-  int i = n_ready - 1;\n-\n-  ultra_types_avail = 0;\n-  while(i >= 0)\n-    {\n-      rtx insn = ready[i];\n+  if (reload_completed)\n+    return emit_insn_after (gen_cycle_display (GEN_INT (clock)), last);\n+  else\n+    return last;\n+}\n \n-      if (recog_memoized (insn) >= 0)\n-\tultra_types_avail |= TMASK (get_attr_type (insn));\n+/* Make sure that the dependency between OUT_INSN and\n+   IN_INSN (a store) is on the store data not the address\n+   operand(s) of the store.  */\n \n-      i -= 1;\n-    }\n-}\n+int\n+ultrasparc_store_bypass_p (out_insn, in_insn)\n+     rtx out_insn, in_insn;\n+{\n+  rtx out_pat, in_pat;\n+  unsigned int regno;\n \n-/* Place insn pointed to my IP into the pipeline.\n-   Make element THIS of READY be that insn if it\n-   is not already.  TYPE indicates the pipeline class\n-   this insn falls into.  */\n-static void\n-ultra_schedule_insn (ip, ready, this, type)\n-     rtx *ip;\n-     rtx *ready;\n-     int this;\n-     enum ultra_code type;\n-{\n-  int pipe_slot;\n-  char mask = ultra_pipe.free_slot_mask;\n-  rtx temp;\n+  if (recog_memoized (in_insn) < 0)\n+    return 0;\n \n-  /* Obtain free slot.  */\n-  for (pipe_slot = 0; pipe_slot < 4; pipe_slot++)\n-    if ((mask & (1 << pipe_slot)) != 0)\n-      break;\n-  if (pipe_slot == 4)\n+  if (get_attr_type (in_insn) != TYPE_STORE\n+      && get_attr_type (in_insn) != TYPE_FPSTORE)\n     abort ();\n \n-  /* In it goes, and it hasn't been committed yet.  */\n-  ultra_pipe.group[pipe_slot] = *ip;\n-  ultra_pipe.codes[pipe_slot] = type;\n-  ultra_pipe.contents[type] = 1;\n-  if (UMASK (type) &\n-      (UMASK (IEUN) | UMASK (IEU0) | UMASK (IEU1)))\n-    ultra_pipe.num_ieu_insns += 1;\n+  out_pat = PATTERN (out_insn);\n+  in_pat = PATTERN (in_insn);\n \n-  ultra_pipe.free_slot_mask = (mask & ~(1 << pipe_slot));\n-  ultra_pipe.group_size += 1;\n-  ultra_pipe.commit[pipe_slot] = 0;\n+  if ((GET_CODE (out_pat) != SET\n+       && GET_CODE (out_pat) != PARALLEL)\n+      || GET_CODE (in_pat) != SET)\n+    abort ();\n \n-  /* Update ready list.  */\n-  temp = *ip;\n-  while (ip != &ready[this])\n+  if (GET_CODE (SET_SRC (in_pat)) == REG)\n     {\n-      ip[0] = ip[1];\n-      ++ip;\n+      regno = REGNO (SET_SRC (in_pat));\n     }\n-  *ip = temp;\n-}\n-\n-/* Advance to the next pipeline group.  */\n-static void\n-ultra_flush_pipeline ()\n-{\n-  ultra_cur_hist = (ultra_cur_hist + 1) & (ULTRA_NUM_HIST - 1);\n-  ultra_cycles_elapsed += 1;\n-  memset ((char *) &ultra_pipe, 0, sizeof ultra_pipe);\n-  ultra_pipe.free_slot_mask = 0xf;\n-}\n-\n-/* Init our data structures for this current block.  */\n-static void\n-ultrasparc_sched_init ()\n-{\n-  memset ((char *) ultra_pipe_hist, 0, sizeof ultra_pipe_hist);\n-  ultra_cur_hist = 0;\n-  ultra_cycles_elapsed = 0;\n-  ultra_pipe.free_slot_mask = 0xf;\n-}\n-\n-static void\n-sparc_sched_init (dump, sched_verbose, max_ready)\n-     FILE *dump ATTRIBUTE_UNUSED;\n-     int sched_verbose ATTRIBUTE_UNUSED;\n-     int max_ready ATTRIBUTE_UNUSED;\n-{\n-  if (sparc_cpu == PROCESSOR_ULTRASPARC)\n-    ultrasparc_sched_init ();\n-}\n-  \n-/* INSN has been scheduled, update pipeline commit state\n-   and return how many instructions are still to be\n-   scheduled in this group.  */\n-static int\n-ultrasparc_variable_issue (insn)\n-     rtx insn;\n-{\n-  struct ultrasparc_pipeline_state *up = &ultra_pipe;\n-  int i, left_to_fire;\n-\n-  left_to_fire = 0;\n-  for (i = 0; i < 4; i++)\n+  else if (GET_CODE (SET_SRC (in_pat)) == SUBREG)\n     {\n-      if (up->group[i] == 0)\n-\tcontinue;\n-\n-      if (up->group[i] == insn)\n-\t{\n-\t  up->commit[i] = 1;\n-\t}\n-      else if (! up->commit[i])\n-\tleft_to_fire++;\n+      regno = REGNO (SUBREG_REG (SET_SRC (in_pat)));\n     }\n-\n-  return left_to_fire;\n-}\n-\n-static int\n-sparc_variable_issue (dump, sched_verbose, insn, cim)\n-     FILE *dump ATTRIBUTE_UNUSED;\n-     int sched_verbose ATTRIBUTE_UNUSED;\n-     rtx insn;\n-     int cim;\n-{\n-  if (sparc_cpu == PROCESSOR_ULTRASPARC)\n-    return ultrasparc_variable_issue (insn);\n   else\n-    return cim - 1;\n-}\n-\n-/* In actual_hazard_this_instance, we may have yanked some\n-   instructions from the ready list due to conflict cost\n-   adjustments.  If so, and such an insn was in our pipeline\n-   group, remove it and update state.  */\n-static void\n-ultra_rescan_pipeline_state (ready, n_ready)\n-     rtx *ready;\n-     int n_ready;\n-{\n-  struct ultrasparc_pipeline_state *up = &ultra_pipe;\n-  int i;\n+    return 0;\n \n-  for (i = 0; i < 4; i++)\n+  if (GET_CODE (out_pat) == PARALLEL)\n     {\n-      rtx insn = up->group[i];\n-      int j;\n+      int i;\n \n-      if (! insn)\n-\tcontinue;\n+      for (i = 0; i < XVECLEN (out_pat, 0); i++)\n+\t{\n+\t  rtx exp = XVECEXP (out_pat, 0, i);\n \n-      /* If it has been committed, then it was removed from\n-\t the ready list because it was actually scheduled,\n-\t and that is not the case we are searching for here.  */\n-      if (up->commit[i] != 0)\n-\tcontinue;\n+\t  if (GET_CODE (exp) != SET)\n+\t    return 0;\n \n-      for (j = n_ready - 1; j >= 0; j--)\n-\tif (ready[j] == insn)\n-\t  break;\n+\t  if (GET_CODE (SET_DEST (exp)) == REG\n+\t      && regno == REGNO (SET_DEST (exp)))\n+\t    return 1;\n \n-      /* If we didn't find it, toss it.  */\n-      if (j < 0)\n-\t{\n-\t  enum ultra_code ucode = up->codes[i];\n-\n-\t  up->group[i] = 0;\n-\t  up->codes[i] = NONE;\n-\t  up->contents[ucode] = 0;\n-\t  if (UMASK (ucode) &\n-\t      (UMASK (IEUN) | UMASK (IEU0) | UMASK (IEU1)))\n-\t    up->num_ieu_insns -= 1;\n-\n-\t  up->free_slot_mask |= (1 << i);\n-\t  up->group_size -= 1;\n-\t  up->commit[i] = 0;\n+\t  if (GET_CODE (SET_DEST (exp)) == SUBREG\n+\t      && regno == REGNO (SUBREG_REG (SET_DEST (exp))))\n+\t    return 1;\n \t}\n     }\n-}\n-\n-static void\n-ultrasparc_sched_reorder (dump, sched_verbose, ready, n_ready)\n-     FILE *dump;\n-     int sched_verbose;\n-     rtx *ready;\n-     int n_ready;\n-{\n-  struct ultrasparc_pipeline_state *up = &ultra_pipe;\n-  int i, this_insn;\n-\n-  if (sched_verbose)\n+  else if (GET_CODE (SET_DEST (out_pat)) == REG)\n     {\n-      int n;\n-\n-      fprintf (dump, \"\\n;;\\tUltraSPARC Looking at [\");\n-      for (n = n_ready - 1; n >= 0; n--)\n-\t{\n-\t  rtx insn = ready[n];\n-\t  enum ultra_code ucode;\n-\n-\t  if (recog_memoized (insn) < 0)\n-\t    continue;\n-\t  ucode = ultra_code_from_mask (TMASK (get_attr_type (insn)));\n-\t  if (n != 0)\n-\t    fprintf (dump, \"%s(%d) \",\n-\t\t     ultra_code_names[ucode],\n-\t\t     INSN_UID (insn));\n-\t  else\n-\t    fprintf (dump, \"%s(%d)\",\n-\t\t     ultra_code_names[ucode],\n-\t\t     INSN_UID (insn));\n-\t}\n-      fprintf (dump, \"]\\n\");\n+      return regno == REGNO (SET_DEST (out_pat));\n     }\n-\n-  this_insn = n_ready - 1;\n-\n-  /* Skip over junk we don't understand.  */\n-  while ((this_insn >= 0)\n-\t && recog_memoized (ready[this_insn]) < 0)\n-    this_insn--;\n-\n-  ultra_build_types_avail (ready, this_insn + 1);\n-\n-  while (this_insn >= 0) {\n-    int old_group_size = up->group_size;\n-\n-    if (up->group_size != 0)\n-      {\n-\tint num_committed;\n-\n-\tnum_committed = (up->commit[0] + up->commit[1] +\n-\t\t\t up->commit[2] + up->commit[3]);\n-\t/* If nothing has been commited from our group, or all of\n-\t   them have.  Clear out the (current cycle's) pipeline\n-\t   state and start afresh.  */\n-\tif (num_committed == 0\n-\t    || num_committed == up->group_size)\n-\t  {\n-\t    ultra_flush_pipeline ();\n-\t    up = &ultra_pipe;\n-\t    old_group_size = 0;\n-\t  }\n-\telse\n-\t  {\n-\t    /* OK, some ready list insns got requeued and thus removed\n-\t       from the ready list.  Account for this fact.  */\n-\t    ultra_rescan_pipeline_state (ready, n_ready);\n-\n-\t    /* Something \"changed\", make this look like a newly\n-\t       formed group so the code at the end of the loop\n-\t       knows that progress was in fact made.  */\n-\t    if (up->group_size != old_group_size)\n-\t      old_group_size = 0;\n-\t  }\n-      }\n-\n-    if (up->group_size == 0)\n-      {\n-\t/* If the pipeline is (still) empty and we have any single\n-\t   group insns, get them out now as this is a good time.  */\n-\trtx *ip = ultra_find_type ((TMASK (TYPE_RETURN) | TMASK (TYPE_IDIV) |\n-\t\t\t\t    TMASK (TYPE_IMUL) | TMASK (TYPE_CMOVE) |\n-\t\t\t\t    TMASK (TYPE_MULTI) | TMASK (TYPE_MISC)),\n-\t\t\t\t   ready, this_insn);\n-\tif (ip)\n-\t  {\n-\t    ultra_schedule_insn (ip, ready, this_insn, SINGLE);\n-\t    break;\n-\t  }\n-\n-\t/* If we are not in the process of emptying out the pipe, try to\n-\t   obtain an instruction which must be the first in it's group.  */\n-\tip = ultra_find_type ((TMASK (TYPE_CALL) |\n-\t\t\t       TMASK (TYPE_SIBCALL) |\n-\t\t\t       TMASK (TYPE_CALL_NO_DELAY_SLOT) |\n-\t\t\t       TMASK (TYPE_UNCOND_BRANCH)),\n-\t\t\t      ready, this_insn);\n-\tif (ip)\n-\t  {\n-\t    ultra_schedule_insn (ip, ready, this_insn, IEU1);\n-\t    this_insn--;\n-\t  }\n-\telse if ((ip = ultra_find_type ((TMASK (TYPE_FPDIVS) |\n-\t\t\t\t\t TMASK (TYPE_FPDIVD) |\n-\t\t\t\t\t TMASK (TYPE_FPSQRTS) |\n-\t\t\t\t\t TMASK (TYPE_FPSQRTD)),\n-\t\t\t\t\tready, this_insn)) != 0)\n-\t  {\n-\t    ultra_schedule_insn (ip, ready, this_insn, FPM);\n-\t    this_insn--;\n-\t  }\n-      }\n-\n-    /* Try to fill the integer pipeline.  First, look for an IEU0 specific\n-       operation.  We can't do more IEU operations if the first 3 slots are\n-       all full or we have dispatched two IEU insns already.  */\n-    if ((up->free_slot_mask & 0x7) != 0\n-\t&& up->num_ieu_insns < 2\n-\t&& up->contents[IEU0] == 0\n-\t&& up->contents[IEUN] == 0)\n-      {\n-\trtx *ip = ultra_find_type (TMASK(TYPE_SHIFT), ready, this_insn);\n-\tif (ip)\n-\t  {\n-\t    ultra_schedule_insn (ip, ready, this_insn, IEU0);\n-\t    this_insn--;\n-\t  }\n-      }\n-\n-    /* If we can, try to find an IEU1 specific or an unnamed\n-       IEU instruction.  */\n-    if ((up->free_slot_mask & 0x7) != 0\n-\t&& up->num_ieu_insns < 2)\n-      {\n-\trtx *ip = ultra_find_type ((TMASK (TYPE_IALU) |\n-\t\t\t\t    (up->contents[IEU1] == 0 ? TMASK (TYPE_COMPARE) : 0)),\n-\t\t\t\t   ready, this_insn);\n-\tif (ip)\n-\t  {\n-\t    rtx insn = *ip;\n-\n-\t    ultra_schedule_insn (ip, ready, this_insn,\n-\t\t\t\t (!up->contents[IEU1]\n-\t\t\t\t  && get_attr_type (insn) == TYPE_COMPARE)\n-\t\t\t\t ? IEU1 : IEUN);\n-\t    this_insn--;\n-\t  }\n-      }\n-\n-    /* If only one IEU insn has been found, try to find another unnamed\n-       IEU operation or an IEU1 specific one.  */\n-    if ((up->free_slot_mask & 0x7) != 0\n-\t&& up->num_ieu_insns < 2)\n-      {\n-\trtx *ip;\n-\tint tmask = TMASK (TYPE_IALU);\n-\n-\tif (!up->contents[IEU1])\n-\t  tmask |= TMASK (TYPE_COMPARE);\n-\tip = ultra_find_type (tmask, ready, this_insn);\n-\tif (ip)\n-\t  {\n-\t    rtx insn = *ip;\n-\n-\t    ultra_schedule_insn (ip, ready, this_insn,\n-\t\t\t\t (!up->contents[IEU1]\n-\t\t\t\t  && get_attr_type (insn) == TYPE_COMPARE)\n-\t\t\t\t ? IEU1 : IEUN);\n-\t    this_insn--;\n-\t  }\n-      }\n-\n-    /* Try for a load or store, but such an insn can only be issued\n-       if it is within' one of the first 3 slots.  */\n-    if ((up->free_slot_mask & 0x7) != 0\n-        && up->contents[LSU] == 0)\n-      {\n-\trtx *ip = ultra_find_type ((TMASK (TYPE_LOAD) | TMASK (TYPE_SLOAD) |\n-\t\t\t\t   TMASK (TYPE_STORE) | TMASK (TYPE_FPLOAD) |\n-\t\t\t\t   TMASK (TYPE_FPSTORE)), ready, this_insn);\n-\tif (ip)\n-\t  {\n-\t    ultra_schedule_insn (ip, ready, this_insn, LSU);\n-\t    this_insn--;\n-\t  }\n-      }\n-\n-    /* Now find FPU operations, first FPM class.  But not divisions or\n-       square-roots because those will break the group up.  Unlike all\n-       the previous types, these can go in any slot.  */\n-    if (up->free_slot_mask != 0\n-\t&& up->contents[FPM] == 0)\n-      {\n-\trtx *ip = ultra_find_type (TMASK (TYPE_FPMUL), ready, this_insn);\n-\tif (ip)\n-\t  {\n-\t    ultra_schedule_insn (ip, ready, this_insn, FPM);\n-\t    this_insn--;\n-\t  }\n-      }\n-    \n-    /* Continue on with FPA class if we have not filled the group already.  */\n-    if (up->free_slot_mask != 0\n-\t&& up->contents[FPA] == 0)\n-      {\n-\trtx *ip = ultra_find_type ((TMASK (TYPE_FPMOVE) | TMASK (TYPE_FPCMOVE) |\n-\t\t\t\t    TMASK (TYPE_FP) | TMASK (TYPE_FPCMP)),\n-\t\t\t\t   ready, this_insn);\n-\tif (ip)\n-\t  {\n-\t    ultra_schedule_insn (ip, ready, this_insn, FPA);\n-\t    this_insn--;\n-\t  }\n-      }\n-\n-    /* Finally, maybe stick a branch in here.  */\n-    if (up->free_slot_mask != 0\n-\t&& up->contents[CTI] == 0)\n-      {\n-\trtx *ip = ultra_find_type (TMASK (TYPE_BRANCH), ready, this_insn);\n-\n-\t/* Try to slip in a branch only if it is one of the\n-\t   next 2 in the ready list.  */\n-\tif (ip && ((&ready[this_insn] - ip) < 2))\n-\t  {\n-\t    ultra_schedule_insn (ip, ready, this_insn, CTI);\n-\t    this_insn--;\n-\t  }\n-      }\n-\n-    up->group_size = 0;\n-    for (i = 0; i < 4; i++)\n-      if ((up->free_slot_mask & (1 << i)) == 0)\n-\tup->group_size++;\n-\n-    /* See if we made any progress...  */\n-    if (old_group_size != up->group_size)\n-      break;\n-\n-    /* Clean out the (current cycle's) pipeline state\n-       and try once more.  If we placed no instructions\n-       into the pipeline at all, it means a real hard\n-       conflict exists with some earlier issued instruction\n-       so we must advance to the next cycle to clear it up.  */\n-    if (up->group_size == 0)\n-      {\n-\tultra_flush_pipeline ();\n-\tup = &ultra_pipe;\n-      }\n-    else\n-      {\n-\tmemset ((char *) &ultra_pipe, 0, sizeof ultra_pipe);\n-\tultra_pipe.free_slot_mask = 0xf;\n-      }\n-  }\n-\n-  if (sched_verbose)\n+  else if (GET_CODE (SET_DEST (out_pat)) == SUBREG)\n     {\n-      int n, gsize;\n-\n-      fprintf (dump, \";;\\tUltraSPARC Launched   [\");\n-      gsize = up->group_size;\n-      for (n = 0; n < 4; n++)\n-\t{\n-\t  rtx insn = up->group[n];\n-\n-\t  if (! insn)\n-\t    continue;\n-\n-\t  gsize -= 1;\n-\t  if (gsize != 0)\n-\t    fprintf (dump, \"%s(%d) \",\n-\t\t     ultra_code_names[up->codes[n]],\n-\t\t     INSN_UID (insn));\n-\t  else\n-\t    fprintf (dump, \"%s(%d)\",\n-\t\t     ultra_code_names[up->codes[n]],\n-\t\t     INSN_UID (insn));\n-\t}\n-      fprintf (dump, \"]\\n\");\n+      return regno == REGNO (SUBREG_REG (SET_DEST (out_pat)));\n     }\n-}\n \n-static int\n-sparc_sched_reorder (dump, sched_verbose, ready, n_readyp, clock)\n-     FILE *dump;\n-     int sched_verbose;\n-     rtx *ready;\n-     int *n_readyp;\n-     int clock ATTRIBUTE_UNUSED;\n-{\n-  if (sparc_cpu == PROCESSOR_ULTRASPARC)\n-    ultrasparc_sched_reorder (dump, sched_verbose, ready, *n_readyp);\n-  return sparc_issue_rate ();\n+  return 0;\n }\n \n-static int                                                           \n+static int\n sparc_issue_rate ()\n {\n   switch (sparc_cpu)\n     {\n-    default:                                 \n-      return 1;                                                    \n-    case PROCESSOR_V9:                                                \n+    default:\n+      return 1;\n+    case PROCESSOR_V9:\n       /* Assume V9 processors are capable of at least dual-issue.  */\n       return 2;\n-    case PROCESSOR_SUPERSPARC:                                        \n-      return 3;                                                      \n+    case PROCESSOR_SUPERSPARC:\n+      return 3;\n     case PROCESSOR_HYPERSPARC:\n     case PROCESSOR_SPARCLITE86X:\n       return 2;\n-    case PROCESSOR_ULTRASPARC:                                            \n-      return 4;                                                    \n+    case PROCESSOR_ULTRASPARC:\n+    case PROCESSOR_ULTRASPARC3:\n+      return 4;\n     }\n }\n \n@@ -8564,21 +7763,6 @@ sparc_profile_hook (labelno)\n   emit_library_call (fun, LCT_NORMAL, VOIDmode, 1, lab, Pmode);\n }\n \f\n-/* Mark ARG, which is really a struct ultrasparc_pipline_state *, for\n-   GC.  */\n-\n-static void\n-mark_ultrasparc_pipeline_state (arg)\n-     void *arg;\n-{\n-  struct ultrasparc_pipeline_state *ups;\n-  size_t i;\n-\n-  ups = (struct ultrasparc_pipeline_state *) arg;\n-  for (i = 0; i < ARRAY_SIZE (ups->group); ++i)\n-    ggc_mark_rtx (ups->group[i]);\n-}\n-\n /* Called to register all of our global variables with the garbage\n    collector.  */\n \n@@ -8591,8 +7775,6 @@ sparc_add_gc_roots ()\n   ggc_add_rtx_root (&get_pc_symbol, 1);\n   ggc_add_rtx_root (&sparc_addr_diff_list, 1);\n   ggc_add_rtx_root (&sparc_addr_list, 1);\n-  ggc_add_root (ultra_pipe_hist, ARRAY_SIZE (ultra_pipe_hist),\n-\t\tsizeof (ultra_pipe_hist[0]), &mark_ultrasparc_pipeline_state);\n }\n \n #ifdef OBJECT_FORMAT_ELF"}, {"sha": "04dcbe3ab90d394fa4fa453d6d3d777554cdb385", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -122,9 +122,11 @@ extern enum cmodel sparc_cmodel;\n #define TARGET_CPU_sparcv9\t7\t/* alias */\n #define TARGET_CPU_sparc64\t7\t/* alias */\n #define TARGET_CPU_ultrasparc\t8\n+#define TARGET_CPU_ultrasparc3\t9\n \n #if TARGET_CPU_DEFAULT == TARGET_CPU_v9 \\\n- || TARGET_CPU_DEFAULT == TARGET_CPU_ultrasparc\n+ || TARGET_CPU_DEFAULT == TARGET_CPU_ultrasparc \\\n+ || TARGET_CPU_DEFAULT == TARGET_CPU_ultrasparc3\n \n #define CPP_CPU32_DEFAULT_SPEC \"\"\n #define ASM_CPU32_DEFAULT_SPEC \"\"\n@@ -141,6 +143,10 @@ extern enum cmodel sparc_cmodel;\n #define CPP_CPU64_DEFAULT_SPEC \"-D__sparc_v9__\"\n #define ASM_CPU64_DEFAULT_SPEC \"-Av9a\"\n #endif\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_ultrasparc3\n+#define CPP_CPU64_DEFAULT_SPEC \"-D__sparc_v9__\"\n+#define ASM_CPU64_DEFAULT_SPEC \"-Av9b\"\n+#endif\n \n #else\n \n@@ -230,6 +236,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n %{mcpu=sparclite86x:-D__sparclite86x__} \\\n %{mcpu=v9:-D__sparc_v9__} \\\n %{mcpu=ultrasparc:-D__sparc_v9__} \\\n+%{mcpu=ultrasparc3:-D__sparc_v9__} \\\n %{!mcpu*:%{!mcypress:%{!msparclite:%{!mf930:%{!mf934:%{!mv8:%{!msupersparc:%(cpp_cpu_default)}}}}}}} \\\n \"\n \n@@ -296,6 +303,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n %{mv8plus:-Av8plus} \\\n %{mcpu=v9:-Av9} \\\n %{mcpu=ultrasparc:%{!mv8plus:-Av9a}} \\\n+%{mcpu=ultrasparc3:%{!mv8plus:-Av9b}} \\\n %{!mcpu*:%{!mcypress:%{!msparclite:%{!mf930:%{!mf934:%{!mv8:%{!msupersparc:%(asm_cpu_default)}}}}}}} \\\n \"\n \n@@ -623,7 +631,8 @@ enum processor_type {\n   PROCESSOR_SPARCLET,\n   PROCESSOR_TSC701,\n   PROCESSOR_V9,\n-  PROCESSOR_ULTRASPARC\n+  PROCESSOR_ULTRASPARC,\n+  PROCESSOR_ULTRASPARC3\n };\n \n /* This is set from -m{cpu,tune}=xxx.  */\n@@ -2622,7 +2631,8 @@ do {                                                                    \\\n   (((FP_REG_CLASS_P (CLASS1) && GENERAL_OR_I64 (CLASS2)) \\\n     || (GENERAL_OR_I64 (CLASS1) && FP_REG_CLASS_P (CLASS2)) \\\n     || (CLASS1) == FPCC_REGS || (CLASS2) == FPCC_REGS)\t\t\\\n-   ? (sparc_cpu == PROCESSOR_ULTRASPARC ? 12 : 6) : 2)\n+   ? ((sparc_cpu == PROCESSOR_ULTRASPARC \\\n+       || sparc_cpu == PROCESSOR_ULTRASPARC3) ? 12 : 6) : 2)\n \n /* Provide the cost of a branch.  For pre-v9 processors we use\n    a value of 3 to take into account the potential annulling of\n@@ -2653,6 +2663,8 @@ do {                                                                    \\\n     if (sparc_cpu == PROCESSOR_ULTRASPARC)\t\t\\\n       return (GET_MODE (X) == DImode ?\t\t\t\\\n               COSTS_N_INSNS (34) : COSTS_N_INSNS (19));\t\\\n+    if (sparc_cpu == PROCESSOR_ULTRASPARC3)\t\t\\\n+      return COSTS_N_INSNS (6);\t\t\t\t\\\n     return TARGET_HARD_MUL ? COSTS_N_INSNS (5) : COSTS_N_INSNS (25); \\\n   case DIV:\t\t\t\t\t\t\\\n   case UDIV:\t\t\t\t\t\t\\\n@@ -2661,6 +2673,9 @@ do {                                                                    \\\n     if (sparc_cpu == PROCESSOR_ULTRASPARC)\t\t\\\n       return (GET_MODE (X) == DImode ?\t\t\t\\\n               COSTS_N_INSNS (68) : COSTS_N_INSNS (37));\t\\\n+    if (sparc_cpu == PROCESSOR_ULTRASPARC3)\t\t\\\n+      return (GET_MODE (X) == DImode ?\t\t\t\\\n+              COSTS_N_INSNS (71) : COSTS_N_INSNS (40));\t\\\n     return COSTS_N_INSNS (25);\t\t\t\t\\\n   /* Make FLOAT and FIX more expensive than CONST_DOUBLE,\\\n      so that cse will favor the latter.  */\t\t\\"}, {"sha": "c6b280679d0d1552c914a8bc0e604be4669d952f", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 436, "deletions": 233, "changes": 669, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -44,6 +44,7 @@\n ;;\t\t\t16\tembmedany_textlo\n ;;\t\t\t18\tsethm\n ;;\t\t\t19\tsetlo\n+;;\t\t\t20\tcycle_display\n ;;\n ;; UNSPEC_VOLATILE:\t0\tblockage\n ;;\t\t\t1\tflush_register_windows\n@@ -61,7 +62,7 @@\n \n ;; Attribute for cpu type.\n ;; These must match the values for enum processor_type in sparc.h.\n-(define_attr \"cpu\" \"v7,cypress,v8,supersparc,sparclite,f930,f934,hypersparc,sparclite86x,sparclet,tsc701,v9,ultrasparc\"\n+(define_attr \"cpu\" \"v7,cypress,v8,supersparc,sparclite,f930,f934,hypersparc,sparclite86x,sparclet,tsc701,v9,ultrasparc,ultrasparc3\"\n   (const (symbol_ref \"sparc_cpu_attr\")))\n \n ;; Attribute for the instruction set.\n@@ -82,9 +83,8 @@\n \n ;; Insn type.\n \n-;; If you add any new type here, please update ultrasparc_sched_reorder too.\n (define_attr \"type\"\n-  \"ialu,compare,shift,load,sload,store,uncond_branch,branch,call,sibcall,call_no_delay_slot,return,imul,idiv,fpload,fpstore,fp,fpmove,fpcmove,fpcmp,fpmul,fpdivs,fpdivd,fpsqrts,fpsqrtd,cmove,multi,misc\"\n+  \"ialu,compare,shift,load,sload,store,uncond_branch,branch,call,sibcall,call_no_delay_slot,return,imul,idiv,fpload,fpstore,fp,fpmove,fpcmove,fpcrmove,fpcmp,fpmul,fpdivs,fpdivd,fpsqrts,fpsqrtd,cmove,multi,misc\"\n   (const_string \"ialu\"))\n \n ;; true if branch/call has empty delay slot and will emit a nop in it\n@@ -163,6 +163,9 @@\n ;; FP precision.\n (define_attr \"fptype\" \"single,double\" (const_string \"single\"))\n \n+;; UltraSPARC-III integer load type.\n+(define_attr \"us3load_type\" \"2cycle,3cycle\" (const_string \"2cycle\"))\n+\n (define_asm_attributes\n   [(set_attr \"length\" \"2\")\n    (set_attr \"type\" \"multi\")])\n@@ -245,344 +248,525 @@\n   [(eq_attr \"in_uncond_branch_delay\" \"true\")\n    (nil) (nil)])\n    \n-;; Function units of the SPARC\n-\n-;; (define_function_unit {name} {num-units} {n-users} {test}\n-;;                       {ready-delay} {issue-delay} [{conflict-list}])\n+;; DFA scheduling on the SPARC\n \n-;; The integer ALU.\n-;; (Noted only for documentation; units that take one cycle do not need to\n-;; be specified.)\n+(define_automaton \"cypress_0,cypress_1,supersparc_0,supersparc_1,hypersparc_0,hypersparc_1,sparclet,ultrasparc_0,ultrasparc_1,ultrasparc3_0,ultrasparc3_1\")\n \n-;; On the sparclite, integer multiply takes 1, 3, or 5 cycles depending on\n-;; the inputs.\n+;; Cypress scheduling\n \n-;; ---- cypress CY7C602 scheduling:\n-;; Memory with load-delay of 1 (i.e., 2 cycle load).\n+(define_cpu_unit \"cyp_memory, cyp_fpalu\" \"cypress_0\")\n+(define_cpu_unit \"cyp_fpmds\" \"cypress_1\")\n \n-(define_function_unit \"memory\" 1 0 \n+(define_insn_reservation \"cyp_load\" 2\n   (and (eq_attr \"cpu\" \"cypress\")\n     (eq_attr \"type\" \"load,sload,fpload\"))\n-  2 2)\n-\n-;; SPARC has two floating-point units: the FP ALU,\n-;; and the FP MUL/DIV/SQRT unit.\n-;; Instruction timings on the CY7C602 are as follows\n-;; FABSs\t4\n-;; FADDs/d\t5/5\n-;; FCMPs/d\t4/4\n-;; FDIVs/d\t23/37\n-;; FMOVs\t4\n-;; FMULs/d\t5/7\n-;; FNEGs\t4\n-;; FSQRTs/d\t34/63\n-;; FSUBs/d\t5/5\n-;; FdTOi/s\t5/5\n-;; FsTOi/d\t5/5\n-;; FiTOs/d\t9/5\n-\n-;; The CY7C602 can only support 2 fp isnsn simultaneously.\n-;; More insns cause the chip to stall.\n-\n-(define_function_unit \"fp_alu\" 1 0\n+  \"cyp_memory, nothing\")\n+\n+(define_insn_reservation \"cyp_fp_alu\" 5\n   (and (eq_attr \"cpu\" \"cypress\")\n     (eq_attr \"type\" \"fp,fpmove\"))\n-  5 5)\n+  \"cyp_fpalu, nothing*3\")\n \n-(define_function_unit \"fp_mds\" 1 0\n+(define_insn_reservation \"cyp_fp_mult\" 7\n   (and (eq_attr \"cpu\" \"cypress\")\n     (eq_attr \"type\" \"fpmul\"))\n-  7 7)\n+  \"cyp_fpmds, nothing*5\")\n \n-(define_function_unit \"fp_mds\" 1 0\n+(define_insn_reservation \"cyp_fp_div\" 37\n   (and (eq_attr \"cpu\" \"cypress\")\n     (eq_attr \"type\" \"fpdivs,fpdivd\"))\n-  37 37)\n+  \"cyp_fpmds, nothing*35\")\n \n-(define_function_unit \"fp_mds\" 1 0\n+(define_insn_reservation \"cyp_fp_sqrt\" 63\n   (and (eq_attr \"cpu\" \"cypress\")\n     (eq_attr \"type\" \"fpsqrts,fpsqrtd\"))\n-  63 63)\n+  \"cyp_fpmds, nothing*61\")\n+\n+;; SuperSPARC scheduling\n+\n+(define_cpu_unit \"ss_memory, ss_shift, ss_iwport0, ss_iwport1\" \"supersparc_0\")\n+(define_cpu_unit \"ss_fpalu\" \"supersparc_0\")\n+(define_cpu_unit \"ss_fpmds\" \"supersparc_1\")\n \n-;; ----- The TMS390Z55 scheduling\n-;; The Supersparc can issue 1 - 3 insns per cycle: up to two integer,\n-;; one ld/st, one fp.\n-;; Memory delivers its result in one cycle to IU, zero cycles to FP\n+(define_reservation \"ss_iwport\" \"(ss_iwport0 | ss_iwport1)\")\n \n-(define_function_unit \"memory\" 1 0\n+(define_insn_reservation \"ss_iuload\" 1\n   (and (eq_attr \"cpu\" \"supersparc\")\n     (eq_attr \"type\" \"load,sload\"))\n-  1 1)\n+  \"ss_memory\")\n \n-(define_function_unit \"memory\" 1 0\n+;; Ok, fpu loads deliver the result in zero cycles.  But we\n+;; have to show the ss_memory reservation somehow, thus...\n+(define_insn_reservation \"ss_fpload\" 0\n   (and (eq_attr \"cpu\" \"supersparc\")\n     (eq_attr \"type\" \"fpload\"))\n-  0 1)\n+  \"ss_memory\")\n \n-(define_function_unit \"memory\" 1 0\n+(define_bypass 0 \"ss_fpload\" \"ss_fp_alu,ss_fp_mult,ss_fp_divs,ss_fp_divd,ss_fp_sqrt\")\n+\n+(define_insn_reservation \"ss_store\" 1\n   (and (eq_attr \"cpu\" \"supersparc\")\n     (eq_attr \"type\" \"store,fpstore\"))\n-  1 1)\n+  \"ss_memory\")\n \n-(define_function_unit \"shift\" 1 0\n+(define_insn_reservation \"ss_ialu_shift\" 1\n   (and (eq_attr \"cpu\" \"supersparc\")\n     (eq_attr \"type\" \"shift\"))\n-  1 1)\n-\n-;; There are only two write ports to the integer register file\n-;; A store also uses a write port\n+  \"ss_shift + ss_iwport\")\n \n-(define_function_unit \"iwport\" 2 0\n+(define_insn_reservation \"ss_ialu_any\" 1\n   (and (eq_attr \"cpu\" \"supersparc\")\n     (eq_attr \"type\" \"load,sload,store,shift,ialu\"))\n-  1 1)\n-\n-;; Timings; throughput/latency\n-;; FADD     1/3    add/sub, format conv, compar, abs, neg\n-;; FMUL     1/3\n-;; FDIVs    4/6\n-;; FDIVd    7/9\n-;; FSQRTs   6/8\n-;; FSQRTd  10/12\n-;; IMUL     4/4\n-\n-(define_function_unit \"fp_alu\" 1 0\n+  \"ss_iwport\")\n+\n+(define_insn_reservation \"ss_fp_alu\" 3\n   (and (eq_attr \"cpu\" \"supersparc\")\n     (eq_attr \"type\" \"fp,fpmove,fpcmp\"))\n-  3 1)\n+  \"ss_fpalu, nothing*2\")\n \n-(define_function_unit \"fp_mds\" 1 0\n+(define_insn_reservation \"ss_fp_mult\" 3\n   (and (eq_attr \"cpu\" \"supersparc\")\n     (eq_attr \"type\" \"fpmul\"))\n-  3 1)\n+  \"ss_fpmds, nothing*2\")\n \n-(define_function_unit \"fp_mds\" 1 0\n+(define_insn_reservation \"ss_fp_divs\" 6\n   (and (eq_attr \"cpu\" \"supersparc\")\n     (eq_attr \"type\" \"fpdivs\"))\n-  6 4)\n+  \"ss_fpmds*4, nothing*2\")\n \n-(define_function_unit \"fp_mds\" 1 0\n+(define_insn_reservation \"ss_fp_divd\" 9\n   (and (eq_attr \"cpu\" \"supersparc\")\n     (eq_attr \"type\" \"fpdivd\"))\n-  9 7)\n+  \"ss_fpmds*7, nothing*2\")\n \n-(define_function_unit \"fp_mds\" 1 0\n+(define_insn_reservation \"ss_fp_sqrt\" 12\n   (and (eq_attr \"cpu\" \"supersparc\")\n     (eq_attr \"type\" \"fpsqrts,fpsqrtd\"))\n-  12 10)\n+  \"ss_fpmds*10, nothing*2\")\n \n-(define_function_unit \"fp_mds\" 1 0\n+(define_insn_reservation \"ss_imul\" 4\n   (and (eq_attr \"cpu\" \"supersparc\")\n     (eq_attr \"type\" \"imul\"))\n-  4 4)\n+  \"ss_fpmds*4\")\n \n-;; ----- hypersparc/sparclite86x scheduling\n-;; The Hypersparc can issue 1 - 2 insns per cycle.  The dual issue cases are:\n-;; L-Ld/St I-Int F-Float B-Branch LI/LF/LB/II/IF/IB/FF/FB\n-;; II/FF case is only when loading a 32 bit hi/lo constant\n-;; Single issue insns include call, jmpl, u/smul, u/sdiv, lda, sta, fcmp\n-;; Memory delivers its result in one cycle to IU\n+;; HyperSPARC/sparclite86x scheduling\n \n-(define_function_unit \"memory\" 1 0\n+(define_cpu_unit \"hs_memory,hs_branch,hs_shift,hs_fpalu\" \"hypersparc_0\")\n+(define_cpu_unit \"hs_fpmds\" \"hypersparc_1\")\n+\n+(define_insn_reservation \"hs_load\" 1\n   (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n     (eq_attr \"type\" \"load,sload,fpload\"))\n-  1 1)\n+  \"hs_memory\")\n \n-(define_function_unit \"memory\" 1 0\n+(define_insn_reservation \"hs_store\" 2\n   (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n     (eq_attr \"type\" \"store,fpstore\"))\n-  2 1)\n+  \"hs_memory, nothing\")\n \n-(define_function_unit \"sparclite86x_branch\" 1 0\n+(define_insn_reservation \"hs_slbranch\" 1\n   (and (eq_attr \"cpu\" \"sparclite86x\")\n     (eq_attr \"type\" \"branch\"))\n-  1 1)\n+  \"hs_branch\")\n \n-;; integer multiply insns \n-(define_function_unit \"sparclite86x_shift\" 1 0\n+(define_insn_reservation \"hs_slshift\" 1\n   (and (eq_attr \"cpu\" \"sparclite86x\")\n     (eq_attr \"type\" \"shift\"))\n-  1 1)\n+  \"hs_shift\")\n \n-(define_function_unit \"fp_alu\" 1 0\n+(define_insn_reservation \"hs_fp_alu\" 1\n   (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n     (eq_attr \"type\" \"fp,fpmove,fpcmp\"))\n-  1 1)\n+  \"hs_fpalu\")\n \n-(define_function_unit \"fp_mds\" 1 0\n+(define_insn_reservation \"hs_fp_mult\" 1\n   (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n     (eq_attr \"type\" \"fpmul\"))\n-  1 1)\n+  \"hs_fpmds\")\n \n-(define_function_unit \"fp_mds\" 1 0\n+(define_insn_reservation \"hs_fp_divs\" 8\n   (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n     (eq_attr \"type\" \"fpdivs\"))\n-  8 6)\n+  \"hs_fpmds*6, nothing*2\")\n \n-(define_function_unit \"fp_mds\" 1 0\n+(define_insn_reservation \"hs_fp_divd\" 12\n   (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n     (eq_attr \"type\" \"fpdivd\"))\n-  12 10)\n+  \"hs_fpmds*10, nothing*2\")\n \n-(define_function_unit \"fp_mds\" 1 0\n+(define_insn_reservation \"hs_fp_sqrt\" 17\n   (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n     (eq_attr \"type\" \"fpsqrts,fpsqrtd\"))\n-  17 15)\n+  \"hs_fpmds*15, nothing*2\")\n \n-(define_function_unit \"fp_mds\" 1 0\n+(define_insn_reservation \"hs_imul\" 17\n   (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n     (eq_attr \"type\" \"imul\"))\n-  17 15)\n+  \"hs_fpmds*15, nothing*2\")\n \n-;; ----- sparclet tsc701 scheduling\n-;; The tsc701 issues 1 insn per cycle.\n-;; Results may be written back out of order.\n+;; Sparclet tsc701 scheduling\n \n-;; Loads take 2 extra cycles to complete and 4 can be buffered at a time.\n+(define_cpu_unit \"sl_load0,sl_load1,sl_load2,sl_load3\" \"sparclet\")\n+(define_cpu_unit \"sl_store,sl_imul\" \"sparclet\")\n \n-(define_function_unit \"tsc701_load\" 4 1\n-  (and (eq_attr \"cpu\" \"tsc701\")\n-    (eq_attr \"type\" \"load,sload\"))\n-  3 1)\n+(define_reservation \"sl_load_any\" \"(sl_load0 | sl_load1 | sl_load2 | sl_load3)\")\n+(define_reservation \"sl_load_all\" \"(sl_load0 + sl_load1 + sl_load2 + sl_load3)\")\n \n-;; Stores take 2(?) extra cycles to complete.\n-;; It is desirable to not have any memory operation in the following 2 cycles.\n-;; (??? or 2 memory ops in the case of std).\n+(define_insn_reservation \"sl_ld\" 3\n+  (and (eq_attr \"cpu\" \"tsc701\")\n+   (eq_attr \"type\" \"load,sload\"))\n+  \"sl_load_any, sl_load_any, sl_load_any\")\n \n-(define_function_unit \"tsc701_store\" 1 0\n+(define_insn_reservation \"sl_st\" 3\n   (and (eq_attr \"cpu\" \"tsc701\")\n     (eq_attr \"type\" \"store\"))\n-  3 3\n-  [(eq_attr \"type\" \"load,sload,store\")])\n+  \"(sl_store+sl_load_all)*3\")\n \n-;; The multiply unit has a latency of 5.\n-(define_function_unit \"tsc701_mul\" 1 0\n+(define_insn_reservation \"sl_imul\" 5\n   (and (eq_attr \"cpu\" \"tsc701\")\n     (eq_attr \"type\" \"imul\"))\n-  5 5)\n-\n-;; ----- The UltraSPARC-1 scheduling\n-;; UltraSPARC has two integer units.  Shift instructions can only execute\n-;; on IE0.  Condition code setting instructions, call, and jmpl (including\n-;; the ret and retl pseudo-instructions) can only execute on IE1.\n-;; Branch on register uses IE1, but branch on condition code does not.\n-;; Conditional moves take 2 cycles.  No other instruction can issue in the\n-;; same cycle as a conditional move.\n-;; Multiply and divide take many cycles during which no other instructions\n-;; can issue.\n-;; Memory delivers its result in two cycles (except for signed loads,\n-;; which take one cycle more).  One memory instruction can be issued per\n-;; cycle.\n-\n-(define_function_unit \"memory\" 1 0\n+  \"sl_imul*5\")\n+\n+;; UltraSPARC-I/II scheduling\n+\n+(define_cpu_unit \"us1_fdivider,us1_fpm\" \"ultrasparc_0\");\n+(define_cpu_unit \"us1_fpa,us1_load_writeback\" \"ultrasparc_1\")\n+(define_cpu_unit \"us1_fps_0,us1_fps_1,us1_fpd_0,us1_fpd_1\" \"ultrasparc_1\")\n+(define_cpu_unit \"us1_slot0,us1_slot1,us1_slot2,us1_slot3\" \"ultrasparc_1\")\n+(define_cpu_unit \"us1_ieu0,us1_ieu1,us1_cti,us1_lsu\" \"ultrasparc_1\")\n+\n+(define_reservation \"us1_slot012\" \"(us1_slot0 | us1_slot1 | us1_slot2)\")\n+(define_reservation \"us1_slotany\" \"(us1_slot0 | us1_slot1 | us1_slot2 | us1_slot3)\")\n+(define_reservation \"us1_single_issue\" \"us1_slot0 + us1_slot1 + us1_slot2 + us1_slot3\")\n+\n+(define_reservation \"us1_fp_single\" \"(us1_fps_0 | us1_fps_1)\")\n+(define_reservation \"us1_fp_double\" \"(us1_fpd_0 | us1_fpd_1)\")\n+;; This is a simplified representation of the issue at hand.\n+;; For most cases, going from one FP precision type insn to another\n+;; just breaks up the insn group.  However for some cases, such\n+;; a situation causes the second insn to stall 2 more cycles.\n+(exclusion_set \"us1_fps_0,us1_fps_1\" \"us1_fpd_0,us1_fpd_1\")\n+\n+;; If we have to schedule an ieu1 specific instruction and we want\n+;; to reserve the ieu0 unit as well, we must reserve it first.  So for\n+;; example we could not schedule this sequence:\n+;;\tCOMPARE\t\tIEU1\n+;;\tIALU\t\tIEU0\n+;; but we could schedule them together like this:\n+;;\tIALU\t\tIEU0\n+;;\tCOMPARE\t\tIEU1\n+;; This basically requires that ieu0 is reserved before ieu1 when\n+;; it is required that both be reserved.\n+(absence_set \"us1_ieu0\" \"us1_ieu1\")\n+\n+;; This defines the slotting order.  Most IEU instructions can only\n+;; execute in the first three slots, FPU and branches can go into\n+;; any slot.  We represent instructions which \"break the group\"\n+;; as requiring reservation of us1_slot0.\n+(absence_set \"us1_slot0\" \"us1_slot1,us1_slot2,us1_slot3\")\n+(absence_set \"us1_slot1\" \"us1_slot2,us1_slot3\")\n+(absence_set \"us1_slot2\" \"us1_slot3\")\n+\n+(define_insn_reservation \"us1_simple_ieuN\" 1\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"load,fpload\"))\n-  2 1)\n+    (eq_attr \"type\" \"ialu\"))\n+  \"(us1_ieu0 | us1_ieu1) + us1_slot012\")\n \n-(define_function_unit \"memory\" 1 0\n+(define_insn_reservation \"us1_simple_ieu0\" 1\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"sload\"))\n-  3 1)\n+    (eq_attr \"type\" \"shift\"))\n+  \"us1_ieu0 + us1_slot012\")\n \n-(define_function_unit \"memory\" 1 0\n+(define_insn_reservation \"us1_simple_ieu1\" 1\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"store,fpstore\"))\n-  1 1)\n+    (eq_attr \"type\" \"compare\"))\n+  \"us1_ieu1 + us1_slot012\")\n \n-(define_function_unit \"ieuN\" 2 0\n+(define_insn_reservation \"us1_cmove\" 2\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"ialu,shift,compare,call,sibcall,call_no_delay_slot,uncond_branch\"))\n-  1 1)\n+    (eq_attr \"type\" \"cmove\"))\n+  \"us1_single_issue, nothing\")\n \n-(define_function_unit \"ieu0\" 1 0\n+(define_insn_reservation \"us1_imul\" 1\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"shift\"))\n-  1 1)\n+    (eq_attr \"type\" \"imul\"))\n+  \"us1_single_issue\")\n \n-(define_function_unit \"ieu0\" 1 0\n+(define_insn_reservation \"us1_idiv\" 1\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"cmove\"))\n-  2 1)\n+    (eq_attr \"type\" \"idiv\"))\n+  \"us1_single_issue\")\n \n-(define_function_unit \"ieu1\" 1 0\n+;; For loads, the \"delayed return mode\" behavior of the chip\n+;; is represented using the us1_load_writeback resource.\n+(define_insn_reservation \"us1_load\" 2\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"compare,call,sibcall,call_no_delay_slot,uncond_branch\"))\n-  1 1)\n+    (eq_attr \"type\" \"load,fpload\"))\n+  \"us1_lsu + us1_slot012, us1_load_writeback\")\n+\n+(define_insn_reservation \"us1_load_signed\" 3\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"sload\"))\n+  \"us1_lsu + us1_slot012, nothing, us1_load_writeback\")\n \n-(define_function_unit \"cti\" 1 0\n+(define_insn_reservation \"us1_store\" 1\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"store,fpstore\"))\n+  \"us1_lsu + us1_slot012\")\n+\n+(define_insn_reservation \"us1_branch\" 1\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n     (eq_attr \"type\" \"branch\"))\n-  1 1)\n-\n-;; Timings; throughput/latency\n-;; FMOV     1/1    fmov, fabs, fneg\n-;; FMOVcc   1/2\n-;; FADD     1/3    add/sub, format conv, compar\n-;; FMUL     1/3\n-;; FDIVs    12/12\n-;; FDIVd    22/22\n-;; FSQRTs   12/12\n-;; FSQRTd   22/22\n-;; FCMP takes 1 cycle to branch, 2 cycles to conditional move.\n-;;\n-;; FDIV{s,d}/FSQRT{s,d} are given their own unit since they only\n-;; use the FPM multiplier for final rounding 3 cycles before the\n-;; end of their latency and we have no real way to model that.\n-;;\n-;; ??? This is really bogus because the timings really depend upon\n-;; who uses the result.  We should record who the user is with\n-;; more descriptive 'type' attribute names and account for these\n-;; issues in ultrasparc_adjust_cost. \n+  \"us1_cti + us1_slotany\")\n \n-(define_function_unit \"fadd\" 1 0\n+(define_insn_reservation \"us1_call_jmpl\" 1\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"fpmove\"))\n-  1 1)\n+    (eq_attr \"type\" \"call,sibcall,call_no_delay_slot,uncond_branch\"))\n+  \"us1_cti + us1_ieu1 + us1_slot0\")\n+\n+(define_insn_reservation \"us1_fmov_single\" 1\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fpmove\"))\n+       (eq_attr \"fptype\" \"single\"))\n+  \"us1_fpa + us1_fp_single + us1_slotany\")\n+\n+(define_insn_reservation \"us1_fmov_double\" 1\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fpmove\"))\n+       (eq_attr \"fptype\" \"double\"))\n+  \"us1_fpa + us1_fp_double + us1_slotany\")\n+\n+(define_insn_reservation \"us1_fcmov_single\" 2\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fpcmove,fpcrmove\"))\n+       (eq_attr \"fptype\" \"single\"))\n+  \"us1_fpa + us1_fp_single + us1_slotany, nothing\")\n+\n+(define_insn_reservation \"us1_fcmov_double\" 2\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fpcmove,fpcrmove\"))\n+       (eq_attr \"fptype\" \"double\"))\n+  \"us1_fpa + us1_fp_double + us1_slotany, nothing\")\n+\n+(define_insn_reservation \"us1_faddsub_single\" 4\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fp\"))\n+       (eq_attr \"fptype\" \"single\"))\n+  \"us1_fpa + us1_fp_single + us1_slotany, nothing*3\")\n+\n+(define_insn_reservation \"us1_faddsub_double\" 4\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fp\"))\n+       (eq_attr \"fptype\" \"double\"))\n+  \"us1_fpa + us1_fp_double + us1_slotany, nothing*3\")\n+\n+(define_insn_reservation \"us1_fpcmp_single\" 1\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fpcmp\"))\n+       (eq_attr \"fptype\" \"single\"))\n+  \"us1_fpa + us1_fp_single + us1_slotany\")\n+\n+(define_insn_reservation \"us1_fpcmp_double\" 1\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fpcmp\"))\n+       (eq_attr \"fptype\" \"double\"))\n+  \"us1_fpa + us1_fp_double + us1_slotany\")\n+\n+(define_insn_reservation \"us1_fmult_single\" 4\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fpmul\"))\n+       (eq_attr \"fptype\" \"single\"))\n+  \"us1_fpm + us1_fp_single + us1_slotany, nothing*3\")\n+\n+(define_insn_reservation \"us1_fmult_double\" 4\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fpmul\"))\n+       (eq_attr \"fptype\" \"double\"))\n+  \"us1_fpm + us1_fp_double + us1_slotany, nothing*3\")\n+\n+;; This is actually in theory dangerous, because it is possible\n+;; for the chip to prematurely dispatch the dependant instruction\n+;; in the G stage, resulting in a 9 cycle stall.  However I have never\n+;; been able to trigger this case myself even with hand written code,\n+;; so it must require some rare complicated pipeline state.\n+(define_bypass 3\n+   \"us1_faddsub_single,us1_faddsub_double,us1_fmult_single,us1_fmult_double\"\n+   \"us1_faddsub_single,us1_faddsub_double,us1_fmult_single,us1_fmult_double\")\n+\n+;; Floating point divide and square root use the multiplier unit\n+;; for final rounding 3 cycles before the divide/sqrt is complete.\n+\n+(define_insn_reservation \"us1_fdivs\"\n+  13\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"fpdivs,fpsqrts\"))\n+  \"(us1_fpm + us1_fdivider + us1_slot0), us1_fdivider*8, (us1_fpm + us1_fdivider), us1_fdivider*2\"\n+  )\n \n-(define_function_unit \"fadd\" 1 0\n+(define_bypass\n+  12\n+  \"us1_fdivs\"\n+  \"us1_faddsub_single,us1_faddsub_double,us1_fmult_single,us1_fmult_double\")\n+\n+(define_insn_reservation \"us1_fdivd\"\n+  23\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"fpdivd,fpsqrtd\"))\n+  \"(us1_fpm + us1_fdivider + us1_slot0), us1_fdivider*18, (us1_fpm + us1_fdivider), us1_fdivider*2\"\n+  )\n+(define_bypass\n+  22\n+  \"us1_fdivd\"\n+  \"us1_faddsub_single,us1_faddsub_double,us1_fmult_single,us1_fmult_double\")\n+\n+;; Any store may multi issue with the insn creating the source\n+;; data as long as that creating insn is not an FPU div/sqrt.\n+;; We need a special guard function because this bypass does\n+;; not apply to the address inputs of the store.\n+(define_bypass 0 \"us1_simple_ieuN,us1_simple_ieu1,us1_simple_ieu0,us1_faddsub_single,us1_faddsub_double,us1_fmov_single,us1_fmov_double,us1_fcmov_single,us1_fcmov_double,us1_fmult_single,us1_fmult_double\" \"us1_store\"\n+   \"ultrasparc_store_bypass_p\")\n+\n+;; An integer branch may execute in the same cycle as the compare\n+;; creating the condition codes.\n+(define_bypass 0 \"us1_simple_ieu1\" \"us1_branch\")\n+\n+;; UltraSPARC-III scheduling\n+;;\n+;; A much simpler beast, no silly slotting rules and both\n+;; integer units are fully symmetric.  It does still have\n+;; single-issue instructions though.\n+\n+(define_cpu_unit \"us3_a0,us3_a1,us3_ms,us3_br,us3_fpm\" \"ultrasparc3_0\")\n+(define_cpu_unit \"us3_slot0,us3_slot1,us3_slot2,us3_slot3,us3_fpa\" \"ultrasparc3_1\")\n+(define_cpu_unit \"us3_load_writeback\" \"ultrasparc3_1\")\n+\n+(define_reservation \"us3_slotany\" \"(us3_slot0 | us3_slot1 | us3_slot2 | us3_slot3)\")\n+(define_reservation \"us3_single_issue\" \"us3_slot0 + us3_slot1 + us3_slot2 + us3_slot3\")\n+(define_reservation \"us3_ax\" \"(us3_a0 | us3_a1)\")\n+\n+(define_insn_reservation \"us3_integer\" 1\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"ialu,shift,compare\"))\n+  \"us3_ax + us3_slotany\")\n+\n+(define_insn_reservation \"us3_cmove\" 2\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"cmove\"))\n+  \"us3_ms + us3_br + us3_slotany, nothing\")\n+\n+;; ??? Not entirely accurate.\n+;; ??? It can run from 6 to 9 cycles.  The first cycle the MS pipe\n+;; ??? is needed, and the instruction group is broken right after\n+;; ??? the imul.  Then 'helper' instructions are generated to perform\n+;; ??? each further stage of the multiplication, each such 'helper' is\n+;; ??? single group.  So, the reservation aspect is represented accurately\n+;; ??? here, but the variable cycles are not.\n+;; ??? Currently I have no idea how to determine the variability, but once\n+;; ??? known we can simply add a define_bypass or similar to model it.\n+(define_insn_reservation \"us3_imul\" 6\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"imul\"))\n+  \"us3_ms + us3_slotany, us3_single_issue*5\")\n+\n+(define_insn_reservation \"us3_idiv\" 71\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"idiv\"))\n+  \"us3_ms + us3_slotany, us3_single_issue*70\")\n+\n+;; UltraSPARC-III has a similar load delay as UltraSPARC-I/II except\n+;; that all loads except 32-bit/64-bit unsigned loads take the extra\n+;; delay for sign/zero extension.\n+(define_insn_reservation \"us3_2cycle_load\" 2\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (and (eq_attr \"type\" \"load,fpload\")\n+      (eq_attr \"us3load_type\" \"2cycle\")))\n+  \"us3_ms + us3_slotany, us3_load_writeback\")\n+\n+(define_insn_reservation \"us3_load_delayed\" 3\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (and (eq_attr \"type\" \"load,sload\")\n+      (eq_attr \"us3load_type\" \"3cycle\")))\n+  \"us3_ms + us3_slotany, nothing, us3_load_writeback\")\n+\n+(define_insn_reservation \"us3_store\" 1\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"store,fpstore\"))\n+  \"us3_ms + us3_slotany\")\n+\n+(define_insn_reservation \"us3_branch\" 1\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"branch\"))\n+  \"us3_br + us3_slotany\")\n+\n+(define_insn_reservation \"us3_call_jmpl\" 1\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"call,sibcall,call_no_delay_slot,uncond_branch\"))\n+  \"us3_br + us3_ms + us3_slotany\")\n+\n+(define_insn_reservation \"us3_fmov\" 3\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"fpmove\"))\n+  \"us3_fpa + us3_slotany, nothing*2\")\n+\n+(define_insn_reservation \"us3_fcmov\" 3\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n     (eq_attr \"type\" \"fpcmove\"))\n-  2 1)\n+  \"us3_fpa + us3_br + us3_slotany, nothing*2\")\n \n-(define_function_unit \"fadd\" 1 0\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n+(define_insn_reservation \"us3_fcrmov\" 3\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"fpcrmove\"))\n+  \"us3_fpa + us3_ms + us3_slotany, nothing*2\")\n+\n+(define_insn_reservation \"us3_faddsub\" 4\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n     (eq_attr \"type\" \"fp\"))\n-  3 1)\n+  \"us3_fpa + us3_slotany, nothing*3\")\n \n-(define_function_unit \"fadd\" 1 0\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n+(define_insn_reservation \"us3_fpcmp\" 5\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n     (eq_attr \"type\" \"fpcmp\"))\n-  2 1)\n+  \"us3_fpa + us3_slotany, nothing*4\")\n \n-(define_function_unit \"fmul\" 1 0\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n+(define_insn_reservation \"us3_fmult\" 4\n+ (and (eq_attr \"cpu\" \"ultrasparc3\")\n     (eq_attr \"type\" \"fpmul\"))\n-  3 1)\n+  \"us3_fpm + us3_slotany, nothing*3\")\n \n-(define_function_unit \"fadd\" 1 0\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"fpcmove\"))\n-  2 1)\n-\n-(define_function_unit \"fdiv\" 1 0\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n+(define_insn_reservation \"us3_fdivs\" 17\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n     (eq_attr \"type\" \"fpdivs\"))\n-  12 12)\n+  \"(us3_fpm + us3_slotany), us3_fpm*14, nothing*2\")\n \n-(define_function_unit \"fdiv\" 1 0\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"fpdivd\"))\n-  22 22)\n-\n-(define_function_unit \"fdiv\" 1 0\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n+(define_insn_reservation \"us3_fsqrts\" 20\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n     (eq_attr \"type\" \"fpsqrts\"))\n-  12 12)\n+  \"(us3_fpm + us3_slotany), us3_fpm*17, nothing*2\")\n \n-(define_function_unit \"fdiv\" 1 0\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n+(define_insn_reservation \"us3_fdivd\" 20\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"fpdivd\"))\n+  \"(us3_fpm + us3_slotany), us3_fpm*17, nothing*2\")\n+\n+(define_insn_reservation \"us3_fsqrtd\" 29\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n     (eq_attr \"type\" \"fpsqrtd\"))\n-  22 22)\n+  \"(us3_fpm + us3_slotany), us3_fpm*26, nothing*2\")\n+\n+;; Any store may multi issue with the insn creating the source\n+;; data as long as that creating insn is not an FPU div/sqrt.\n+;; We need a special guard function because this bypass does\n+;; not apply to the address inputs of the store.\n+(define_bypass 0 \"us3_integer,us3_faddsub,us3_fmov,us3_fcmov,us3_fmult\" \"us3_store\"\n+   \"ultrasparc_store_bypass_p\")\n+\n+;; An integer branch may execute in the same cycle as the compare\n+;; creating the condition codes.\n+(define_bypass 0 \"us3_integer\" \"us3_branch\")\n+\n+;; If FMOVfcc is user of FPCMP, latency is only 1 cycle.\n+(define_bypass 1 \"us3_fpcmp\" \"us3_fcmov\")\n+\n \f\n ;; Compare instructions.\n ;; This controls RTL generation and register allocation.\n@@ -2181,7 +2365,8 @@\n    mov\\\\t%1, %0\n    ldub\\\\t%1, %0\n    stb\\\\t%r1, %0\"\n-  [(set_attr \"type\" \"*,load,store\")])\n+  [(set_attr \"type\" \"*,load,store\")\n+   (set_attr \"us3load_type\" \"*,3cycle,*\")])\n \n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"general_operand\" \"\")\n@@ -2255,7 +2440,8 @@\n    sethi\\\\t%%hi(%a1), %0\n    lduh\\\\t%1, %0\n    sth\\\\t%r1, %0\"\n-  [(set_attr \"type\" \"*,*,load,store\")])\n+  [(set_attr \"type\" \"*,*,load,store\")\n+   (set_attr \"us3load_type\" \"*,*,3cycle,*\")])\n \n ;; We always work with constants here.\n (define_insn \"*movhi_lo_sum\"\n@@ -4404,7 +4590,7 @@\n   \"@\n    fmovrs%D1\\\\t%2, %3, %0\n    fmovrs%d1\\\\t%2, %4, %0\"\n-  [(set_attr \"type\" \"fpcmove\")])\n+  [(set_attr \"type\" \"fpcrmove\")])\n \n (define_insn \"movdf_cc_reg_sp64\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e,e\")\n@@ -4417,7 +4603,7 @@\n   \"@\n    fmovrd%D1\\\\t%2, %3, %0\n    fmovrd%d1\\\\t%2, %4, %0\"\n-  [(set_attr \"type\" \"fpcmove\")\n+  [(set_attr \"type\" \"fpcrmove\")\n    (set_attr \"fptype\" \"double\")])\n \n (define_insn \"*movtf_cc_reg_hq_sp64\"\n@@ -4431,7 +4617,7 @@\n   \"@\n    fmovrq%D1\\\\t%2, %3, %0\n    fmovrq%d1\\\\t%2, %4, %0\"\n-  [(set_attr \"type\" \"fpcmove\")])\n+  [(set_attr \"type\" \"fpcrmove\")])\n \n (define_insn \"*movtf_cc_reg_sp64\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n@@ -4521,7 +4707,8 @@\n \t(zero_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n   \"\"\n   \"lduh\\\\t%1, %0\"\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_expand \"zero_extendqihi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n@@ -4536,7 +4723,8 @@\n   \"@\n    and\\\\t%1, 0xff, %0\n    ldub\\\\t%1, %0\"\n-  [(set_attr \"type\" \"*,load\")])\n+  [(set_attr \"type\" \"*,load\")\n+   (set_attr \"us3load_type\" \"*,3cycle\")])\n \n (define_expand \"zero_extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -4551,7 +4739,8 @@\n   \"@\n    and\\\\t%1, 0xff, %0\n    ldub\\\\t%1, %0\"\n-  [(set_attr \"type\" \"*,load\")])\n+  [(set_attr \"type\" \"*,load\")\n+   (set_attr \"us3load_type\" \"*,3cycle\")])\n \n (define_expand \"zero_extendqidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -4566,7 +4755,8 @@\n   \"@\n    and\\\\t%1, 0xff, %0\n    ldub\\\\t%1, %0\"\n-  [(set_attr \"type\" \"*,load\")])\n+  [(set_attr \"type\" \"*,load\")\n+   (set_attr \"us3load_type\" \"*,3cycle\")])\n \n (define_expand \"zero_extendhidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -4597,7 +4787,8 @@\n \t(zero_extend:DI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n   \"TARGET_ARCH64\"\n   \"lduh\\\\t%1, %0\"\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n \n \n ;; ??? Write truncdisi pattern using sra?\n@@ -4803,7 +4994,8 @@\n \t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n   \"\"\n   \"ldsh\\\\t%1, %0\"\n-  [(set_attr \"type\" \"sload\")])\n+  [(set_attr \"type\" \"sload\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_expand \"extendqihi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n@@ -4843,7 +5035,8 @@\n \t(sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n   \"\"\n   \"ldsb\\\\t%1, %0\"\n-  [(set_attr \"type\" \"sload\")])\n+  [(set_attr \"type\" \"sload\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_expand \"extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -4874,7 +5067,8 @@\n \t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n   \"\"\n   \"ldsb\\\\t%1, %0\"\n-  [(set_attr \"type\" \"sload\")])\n+  [(set_attr \"type\" \"sload\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_expand \"extendqidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -4905,7 +5099,8 @@\n \t(sign_extend:DI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n   \"TARGET_ARCH64\"\n   \"ldsb\\\\t%1, %0\"\n-  [(set_attr \"type\" \"sload\")])\n+  [(set_attr \"type\" \"sload\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_expand \"extendhidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -4936,7 +5131,8 @@\n \t(sign_extend:DI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n   \"TARGET_ARCH64\"\n   \"ldsh\\\\t%1, %0\"\n-  [(set_attr \"type\" \"sload\")])\n+  [(set_attr \"type\" \"sload\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_expand \"extendsidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -4951,7 +5147,8 @@\n   \"@\n   sra\\\\t%1, 0, %0\n   ldsw\\\\t%1, %0\"\n-  [(set_attr \"type\" \"shift,sload\")])\n+  [(set_attr \"type\" \"shift,sload\")\n+   (set_attr \"us3load_type\" \"*,3cycle\")])\n \f\n ;; Special pattern for optimizing bit-field compares.  This is needed\n ;; because combine uses this as a canonical form.\n@@ -9507,3 +9704,9 @@\n   \"TARGET_V9\"\n   \"t%C0\\\\t%%xcc, %1\"\n   [(set_attr \"type\" \"misc\")])\n+\n+(define_insn \"cycle_display\"\n+  [(unspec [(match_operand 0 \"const_int_operand\" \"\")] 20)]\n+  \"\"\n+  \"! cycle %0\"\n+  [(set_attr \"length\" \"0\")])"}, {"sha": "cab46f08f39b9a948ad3a2785f9f53903dfae33e", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -330,9 +330,10 @@ Andrew MacLeod for his ongoing work in building a real EH system,\n various code generation improvements, work on the global optimizer, etc.\n \n @item\n-Vladimir Makarov for hacking some ugly i960 problems, PowerPC\n-hacking improvements to compile-time performance and overall knowledge\n-and direction in the area of instruction scheduling.\n+Vladimir Makarov for hacking some ugly i960 problems, PowerPC hacking\n+improvements to compile-time performance, overall knowledge and\n+direction in the area of instruction scheduling, and design and\n+implementation of the automaton based instruction scheduler.\n \n @item\n Bob Manson for his behind the scenes work on dejagnu."}, {"sha": "6a173521e22af1c4053c9b97f0e3bdc7e442c48b", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 503, "deletions": 25, "changes": 528, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -3871,13 +3871,14 @@ in the compiler.\n @cindex instruction splitting\n @cindex splitting instructions\n \n-There are two cases where you should specify how to split a pattern into\n-multiple insns.  On machines that have instructions requiring delay\n-slots (@pxref{Delay Slots}) or that have instructions whose output is\n-not available for multiple cycles (@pxref{Function Units}), the compiler\n-phases that optimize these cases need to be able to move insns into\n-one-instruction delay slots.  However, some insns may generate more than one\n-machine instruction.  These insns cannot be placed into a delay slot.\n+There are two cases where you should specify how to split a pattern\n+into multiple insns.  On machines that have instructions requiring\n+delay slots (@pxref{Delay Slots}) or that have instructions whose\n+output is not available for multiple cycles (@pxref{Processor pipeline\n+description}), the compiler phases that optimize these cases need to\n+be able to move insns into one-instruction delay slots.  However, some\n+insns may generate more than one machine instruction.  These insns\n+cannot be placed into a delay slot.\n \n Often you can rewrite the single insn as a list of individual insns,\n each corresponding to one machine instruction.  The disadvantage of\n@@ -4497,7 +4498,7 @@ to track the condition codes.\n * Insn Lengths::        Computing the length of insns.\n * Constant Attributes:: Defining attributes that are constant.\n * Delay Slots::         Defining delay slots required for a machine.\n-* Function Units::      Specifying information for insn scheduling.\n+* Processor pipeline description:: Specifying information for insn scheduling.\n @end menu\n \n @node Defining Attributes\n@@ -5127,14 +5128,101 @@ branch is true, we might represent this as follows:\n @end smallexample\n @c the above is *still* too long.  --mew 4feb93\n \n-@node Function Units\n-@subsection Specifying Function Units\n+@node Processor pipeline description\n+@subsection Specifying processor pipeline description\n+@cindex processor pipeline description\n+@cindex processor functional units\n+@cindex instruction latency time\n+@cindex interlock delays\n+@cindex data dependence delays\n+@cindex reservation delays\n+@cindex pipeline hazard recognizer\n+@cindex automaton based pipeline description\n+@cindex regular expressions\n+@cindex deterministic finite state automaton\n+@cindex automaton based scheduler\n+@cindex RISC\n+@cindex VLIW\n+\n+To achieve better productivity most modern processors\n+(super-pipelined, superscalar @acronym{RISC}, and @acronym{VLIW}\n+processors) have many @dfn{functional units} on which several\n+instructions can be executed simultaneously.  An instruction starts\n+execution if its issue conditions are satisfied.  If not, the\n+instruction is interlocked until its conditions are satisfied.  Such\n+@dfn{interlock (pipeline) delay} causes interruption of the fetching\n+of successor instructions (or demands nop instructions, e.g. for some\n+MIPS processors).\n+\n+There are two major kinds of interlock delays in modern processors.\n+The first one is a data dependence delay determining @dfn{instruction\n+latency time}.  The instruction execution is not started until all\n+source data have been evaluated by prior instructions (there are more\n+complex cases when the instruction execution starts even when the data\n+are not availaible but will be ready in given time after the\n+instruction execution start).  Taking the data dependence delays into\n+account is simple.  The data dependence (true, output, and\n+anti-dependence) delay between two instructions is given by a\n+constant.  In most cases this approach is adequate.  The second kind\n+of interlock delays is a reservation delay.  The reservation delay\n+means that two instructions under execution will be in need of shared\n+processors resources, i.e. buses, internal registers, and/or\n+functional units, which are reserved for some time.  Taking this kind\n+of delay into account is complex especially for modern @acronym{RISC}\n+processors.\n+\n+The task of exploiting more processor parallelism is solved by an\n+instruction scheduler.  For better solution of this problem, the\n+instruction scheduler has to have an adequate description of the\n+processor parallelism (or @dfn{pipeline description}).  Currently GCC\n+has two ways to describe processor parallelism.  The first one is old\n+and originated from instruction scheduler written by Michael Tiemann\n+and described in the first subsequent section.  The second one was\n+created later.  It is based on description of functional unit\n+reservations by processor instructions with the aid of @dfn{regular\n+expressions}.  This is so called @dfn{automaton based description}.\n+\n+Gcc instruction scheduler uses a @dfn{pipeline hazard recognizer} to\n+figure out the possibility of the instruction issue by the processor\n+on given simulated processor cycle.  The pipeline hazard recognizer is\n+a code generated from the processor pipeline description.  The\n+pipeline hazard recognizer generated from the automaton based\n+description is more sophisticated and based on deterministic finite\n+state automaton (@acronym{DFA}) and therefore faster than one\n+generated from the old description.  Also its speed is not depended on\n+processor complexity.  The instruction issue is possible if there is\n+a transition from one automaton state to another one.\n+\n+You can use any model to describe processor pipeline characteristics\n+or even a mix of them.  You could use the old description for some\n+processor submodels and the @acronym{DFA}-based one for the rest\n+processor submodels.\n+\n+In general, the usage of the automaton based description is more\n+preferable.  Its model is more rich.  It permits to describe more\n+accurately pipeline characteristics of processors which results in\n+improving code quality (although sometimes only on several percent\n+fractions).  It will be also used as an infrastructure to implement\n+sophisticated and practical insn scheduling which will try many\n+instruction sequences to choose the best one.\n+\n+\n+@menu\n+* Old pipeline description:: Specifying information for insn scheduling.\n+* Automaton pipeline description:: Describing insn pipeline characteristics.\n+* Comparison of the two descriptions:: Drawbacks of the old pipeline description\n+@end menu\n+\n+@node Old pipeline description\n+@subsubsection Specifying Function Units\n+@cindex old pipeline description\n @cindex function units, for scheduling\n \n-On most RISC machines, there are instructions whose results are not\n-available for a specific number of cycles.  Common cases are instructions\n-that load data from memory.  On many machines, a pipeline stall will result\n-if the data is referenced too soon after the load instruction.\n+On most @acronym{RISC} machines, there are instructions whose results\n+are not available for a specific number of cycles.  Common cases are\n+instructions that load data from memory.  On many machines, a pipeline\n+stall will result if the data is referenced too soon after the load\n+instruction.\n \n In addition, many newer microprocessors have multiple function units, usually\n one for integer and one for floating point, and often will incur pipeline\n@@ -5148,13 +5236,14 @@ due to function unit conflicts.\n \n For the purposes of the specifications in this section, a machine is\n divided into @dfn{function units}, each of which execute a specific\n-class of instructions in first-in-first-out order.  Function units that\n-accept one instruction each cycle and allow a result to be used in the\n-succeeding instruction (usually via forwarding) need not be specified.\n-Classic RISC microprocessors will normally have a single function unit,\n-which we can call @samp{memory}.  The newer ``superscalar'' processors\n-will often have function units for floating point operations, usually at\n-least a floating point adder and multiplier.\n+class of instructions in first-in-first-out order.  Function units\n+that accept one instruction each cycle and allow a result to be used\n+in the succeeding instruction (usually via forwarding) need not be\n+specified.  Classic @acronym{RISC} microprocessors will normally have\n+a single function unit, which we can call @samp{memory}.  The newer\n+``superscalar'' processors will often have function units for floating\n+point operations, usually at least a floating point adder and\n+multiplier.\n \n @findex define_function_unit\n Each usage of a function units by a class of insns is specified with a\n@@ -5217,10 +5306,10 @@ Typical uses of this vector are where a floating point function unit can\n pipeline either single- or double-precision operations, but not both, or\n where a memory unit can pipeline loads, but not stores, etc.\n \n-As an example, consider a classic RISC machine where the result of a\n-load instruction is not available for two cycles (a single ``delay''\n-instruction is required) and where only one load instruction can be executed\n-simultaneously.  This would be specified as:\n+As an example, consider a classic @acronym{RISC} machine where the\n+result of a load instruction is not available for two cycles (a single\n+``delay'' instruction is required) and where only one load instruction\n+can be executed simultaneously.  This would be specified as:\n \n @smallexample\n (define_function_unit \"memory\" 1 1 (eq_attr \"type\" \"load\") 2 0)\n@@ -5246,6 +5335,395 @@ used during their execution and there is no way of representing that\n conflict.  We welcome any examples of how function unit conflicts work\n in such processors and suggestions for their representation.\n \n+@node Automaton pipeline description\n+@subsubsection Describing instruction pipeline characteristics\n+@cindex automaton based pipeline description\n+\n+This section describes constructions of the automaton based processor\n+pipeline description.  The order of all mentioned below constructions\n+in the machine description file is not important.\n+\n+@findex define_automaton\n+@cindex pipeline hazard recognizer\n+The following optional construction describes names of automata\n+generated and used for the pipeline hazards recognition.  Sometimes\n+the generated finite state automaton used by the pipeline hazard\n+recognizer is large.  If we use more one automaton and bind functional\n+units to the automata, the summary size of the automata usually is\n+less than the size of the single automaton.  If there is no one such\n+construction, only one finite state automaton is generated.\n+\n+@smallexample\n+(define_automaton @var{automata-names})\n+@end smallexample\n+\n+@var{automata-names} is a string giving names of the automata.  The\n+names are separated by commas.  All the automata should have unique names.\n+The automaton name is used in construction @code{define_cpu_unit} and\n+@code{define_query_cpu_unit}.\n+\n+@findex define_cpu_unit\n+@cindex processor functional units\n+Each processor functional unit used in description of instruction\n+reservations should be described by the following construction.\n+\n+@smallexample\n+(define_cpu_unit @var{unit-names} [@var{automaton-name}])\n+@end smallexample\n+\n+@var{unit-names} is a string giving the names of the functional units\n+separated by commas.  Don't use name @samp{nothing}, it is reserved\n+for other goals.\n+\n+@var{automaton-name} is a string giving the name of automaton with\n+which the unit is bound.  The automaton should be described in\n+construction @code{define_automaton}.  You should give\n+@dfn{automaton-name}, if there is a defined automaton.\n+\n+@findex define_query_cpu_unit\n+@cindex querying function unit reservations\n+The following construction describes CPU functional units analogously\n+to @code{define_cpu_unit}.  If we use automata without their\n+minimization, the reservation of such units can be queried for an\n+automaton state.  The instruction scheduler never queries reservation\n+of functional units for given automaton state.  So as a rule, you\n+don't need this construction.  This construction could be used for\n+future code generation goals (e.g. to generate @acronym{VLIW} insn\n+templates).\n+\n+@smallexample\n+(define_query_cpu_unit @var{unit-names} [@var{automaton-name}])\n+@end smallexample\n+\n+@var{unit-names} is a string giving names of the functional units\n+separated by commas.\n+\n+@var{automaton-name} is a string giving name of the automaton with\n+which the unit is bound.\n+\n+@findex define_insn_reservation\n+@cindex instruction latency time\n+@cindex regular expressions\n+@cindex data bypass\n+The following construction is major one to describe pipeline\n+characteristics of an instruction.\n+\n+@smallexample\n+(define_insn_reservation @var{insn-name} @var{default_latency}\n+                         @var{condition} @var{regexp})\n+@end smallexample\n+\n+@var{default_latency} is a number giving latency time of the\n+instruction.  There is an important difference between the old\n+description and the automaton based pipeline description.  The latency\n+time is used for all dependencies when we use the old description.  In\n+the automaton based pipeline description, given latency time is used\n+only for true dependencies.  The cost of anti-dependencies is always\n+zero and the cost of output dependencies is the difference between\n+latency times of the producing and consuming insns (if the difference\n+is negative, the cost is considered to be zero).  You always can\n+change the default costs for any description by using target hook\n+@code{TARGET_SCHED_ADJUST_COST} (@pxref{Scheduling}).\n+\n+@var{insn-names} is a string giving internal name of the insn.  The\n+internal names are used in constructions @code{define_bypass} and in\n+the automaton description file generated for debugging.  The internal\n+name has nothing common with the names in @code{define_insn}.  It is a\n+good practice to use insn classes described in the processor manual.\n+\n+@var{condition} defines what RTL insns are described by this\n+construction.  You should remember that you will be in trouble if\n+@var{condition} for two or more different\n+@code{define_insn_reservation} constructions is TRUE for an insn.  In\n+this case what reservation will be used for the insn is not defined.\n+Such cases are not checked during generation of the pipeline hazards\n+recognizer because in general recognizing that two conditions may have\n+the same value is quite difficult (especially if the conditions\n+contain @code{symbol_ref}).  It is also not checked during the\n+pipeline hazard recognizer work because it would slow down the\n+recognizer considerably.\n+\n+@var{regexp} is a string describing reservation of the cpu functional\n+units by the instruction.  The reservations are described by a regular\n+expression according to the following syntax:\n+\n+@smallexample\n+       regexp = regexp \",\" oneof\n+              | oneof\n+\n+       oneof = oneof \"|\" allof\n+             | allof\n+\n+       allof = allof \"+\" repeat\n+             | repeat\n+ \n+       repeat = element \"*\" number\n+              | element\n+\n+       element = cpu_function_unit_name\n+               | reservation_name\n+               | result_name\n+               | \"nothing\"\n+               | \"(\" regexp \")\"\n+@end smallexample\n+\n+@itemize @bullet\n+@item\n+@samp{,} is used for describing the start of the next cycle in\n+the reservation.\n+\n+@item\n+@samp{|} is used for describing a reservation described by the first\n+regular expression @strong{or} a reservation described by the second\n+regular expression @strong{or} etc.\n+\n+@item\n+@samp{+} is used for describing a reservation described by the first\n+regular expression @strong{and} a reservation described by the\n+second regular expression @strong{and} etc.\n+\n+@item\n+@samp{*} is used for convenience and simply means a sequence in which\n+the regular expression are repeated @var{number} times with cycle\n+advancing (see @samp{,}).\n+\n+@item\n+@samp{cpu_function_unit_name} denotes reservation of the named\n+functional unit.\n+\n+@item\n+@samp{reservation_name} --- see description of construction\n+@samp{define_reservation}.\n+\n+@item\n+@samp{nothing} denotes no unit reservations.\n+@end itemize\n+\n+@findex define_reservation\n+Sometimes unit reservations for different insns contain common parts.\n+In such case, you can simplify the pipeline description by describing\n+the common part by the following construction\n+\n+@smallexample\n+(define_reservation @var{reservation-name} @var{regexp})\n+@end smallexample\n+\n+@var{reservation-name} is a string giving name of @var{regexp}.\n+Functional unit names and reservation names are in the same name\n+space.  So the reservation names should be different from the\n+functional unit names and can not be reserved name @samp{nothing}.\n+\n+@findex define_bypass\n+@cindex instruction latency time\n+@cindex data bypass\n+The following construction is used to describe exceptions in the\n+latency time for given instruction pair.  This is so called bypasses.\n+\n+@smallexample\n+(define_bypass @var{number} @var{out_insn_names} @var{in_insn_names}\n+               [@var{guard}])\n+@end smallexample\n+\n+@var{number} defines when the result generated by the instructions\n+given in string @var{out_insn_names} will be ready for the\n+instructions given in string @var{in_insn_names}.  The instructions in\n+the string are separated by commas.\n+\n+@var{guard} is an optional string giving name of a C function which\n+defines an additional guard for the bypass.  The function will get the\n+two insns as parameters.  If the function returns zero the bypass will\n+be ignored for this case.  The additional guard is necessary to\n+recognize complicated bypasses, e.g. when consumer is only an address\n+of insn @samp{store} (not a stored value).\n+\n+@findex exclusion_set\n+@findex presence_set\n+@findex absence_set\n+@cindex VLIW\n+@cindex RISC\n+Usually the following three constructions are used to describe\n+@acronym{VLIW} processors (more correctly to describe a placement of\n+small insns into @acronym{VLIW} insn slots).  Although they can be\n+used for @acronym{RISC} processors too.\n+\n+@smallexample\n+(exclusion_set @var{unit-names} @var{unit-names})\n+(presence_set @var{unit-names} @var{unit-names})\n+(absence_set @var{unit-names} @var{unit-names})\n+@end smallexample\n+\n+@var{unit-names} is a string giving names of functional units\n+separated by commas.\n+\n+The first construction (@samp{exclusion_set}) means that each\n+functional unit in the first string can not be reserved simultaneously\n+with a unit whose name is in the second string and vice versa.  For\n+example, the construction is useful for describing processors\n+(e.g. some SPARC processors) with a fully pipelined floating point\n+functional unit which can execute simultaneously only single floating\n+point insns or only double floating point insns.\n+\n+The second construction (@samp{presence_set}) means that each\n+functional unit in the first string can not be reserved unless at\n+least one of units whose names are in the second string is reserved.\n+This is an asymmetric relation.  For example, it is useful for\n+description that @acronym{VLIW} @samp{slot1} is reserved after\n+@samp{slot0} reservation.\n+\n+The third construction (@samp{absence_set}) means that each functional\n+unit in the first string can be reserved only if each unit whose name\n+is in the second string is not reserved.  This is an asymmetric\n+relation (actually @samp{exclusion_set} is analogous to this one but\n+it is symmetric).  For example, it is useful for description that\n+@acronym{VLIW} @samp{slot0} can not be reserved after @samp{slot1} or\n+@samp{slot2} reservation.\n+\n+All functional units mentioned in a set should belong the same\n+automaton.\n+\n+@findex automata_option\n+@cindex deterministic finite state automaton\n+@cindex nondeterministic finite state automaton\n+@cindex finite state automaton minimization\n+You can control the generator of the pipeline hazard recognizer with\n+the following construction.\n+\n+@smallexample\n+(automata_option @var{options})\n+@end smallexample\n+\n+@var{options} is a string giving options which affect the generated\n+code.  Currently there are the following options:\n+\n+@itemize @bullet\n+@item\n+@dfn{no-minimization} makes no minimization of the automaton.  This is\n+only worth to do when we are going to query CPU functional unit\n+reservations in an automaton state.\n+\n+@item\n+@dfn{w} means a generation of the file describing the result\n+automaton.  The file can be used to verify the description.\n+\n+@item\n+@dfn{ndfa} makes nondeterministic finite state automata.  This affects\n+the treatment of operator @samp{|} in the regular expressions.  The\n+usual treatment of the operator is to try the first alternative and,\n+if the reservation is not possible, the second alternative.  The\n+nondeterministic treatment means trying all alternatives, some of them\n+may be rejected by reservations in the subsequent insns.  You can not\n+query functional unit reservations in nondeterministic automaton\n+states.\n+@end itemize\n+\n+As an example, consider a superscalar @acronym{RISC} machine which can\n+issue three insns (two integer insns and one floating point insn) on\n+the cycle but can finish only two insns.  To describe this, we define\n+the following functional units.\n+\n+@smallexample\n+(define_cpu_unit \"i0_pipeline, i1_pipeline, f_pipeline\")\n+(define_cpu_unit \"port_0, port1\")\n+@end smallexample\n+\n+All simple integer insns can be executed in any integer pipeline and\n+their result is ready in two cycles.  The simple integer insns are\n+issued into the first pipeline unless it is reserved, otherwise they\n+are issued into the second pipeline.  Integer division and\n+multiplication insns can be executed only in the second integer\n+pipeline and their results are ready correspondingly in 8 and 4\n+cycles.  The integer division is not pipelined, i.e. the subsequent\n+integer division insn can not be issued until the current division\n+insn finished.  Floating point insns are fully pipelined and their\n+results are ready in 3 cycles.  There is also additional one cycle\n+delay in the usage by integer insns of result produced by floating\n+point insns.  To describe all of this we could specify\n+\n+@smallexample\n+(define_cpu_unit \"div\")\n+\n+(define_insn_reservation \"simple\" 2 (eq_attr \"cpu\" \"int\")\n+                         \"(i0_pipeline | i1_pipeline), (port_0 | port1)\")\n+\n+(define_insn_reservation \"mult\" 4 (eq_attr \"cpu\" \"mult\")\n+                         \"i1_pipeline, nothing*2, (port_0 | port1)\")\n+\n+(define_insn_reservation \"div\" 8 (eq_attr \"cpu\" \"div\")\n+                         \"i1_pipeline, div*7, div + (port_0 | port1)\")\n+\n+(define_insn_reservation \"float\" 3 (eq_attr \"cpu\" \"float\")\n+                         \"f_pipeline, nothing, (port_0 | port1))\n+\n+(define_bypass 4 \"float\" \"simple,mut,div\")\n+@end smallexample\n+\n+To simplify the description we could describe the following reservation\n+\n+@smallexample\n+(define_reservation \"finish\" \"port0|port1\")\n+@end smallexample\n+\n+and use it in all @code{define_insn_reservation} as in the following\n+construction\n+\n+@smallexample\n+(define_insn_reservation \"simple\" 2 (eq_attr \"cpu\" \"int\")\n+                         \"(i0_pipeline | i1_pipeline), finish\")\n+@end smallexample\n+\n+\n+@node Comparison of the two descriptions\n+@subsubsection Drawbacks of the old pipeline description\n+@cindex old pipeline description\n+@cindex automaton based pipeline description\n+@cindex processor functional units\n+@cindex interlock delays\n+@cindex instruction latency time\n+@cindex pipeline hazard recognizer\n+@cindex data bypass\n+\n+The old instruction level parallelism description and the pipeline\n+hazards recognizer based on it have the following drawbacks in\n+comparison with the @acronym{DFA}-based ones:\n+  \n+@itemize @bullet\n+@item\n+Each functional unit is believed to be reserved at the instruction\n+execution start.  This is a very inaccurate model for modern\n+processors.\n+\n+@item\n+An inadequate description of instruction latency times.  The latency\n+time is bound with a functional unit reserved by an instruction not\n+with the instruction itself.  In other words, the description is\n+oriented to describe at most one unit reservation by each instruction.\n+It also does not permit to describe special bypasses between\n+instruction pairs.\n+\n+@item\n+The implementation of the pipeline hazard recognizer interface has\n+constraints on number of functional units.  This is a number of bits\n+in integer on the host machine.\n+\n+@item\n+The interface to the pipeline hazard recognizer is more complex than\n+one to the automaton based pipeline recognizer.\n+\n+@item\n+An unnatural description when you write an unit and a condition which\n+selects instructions using the unit.  Writing all unit reservations\n+for an instruction (an instruction class) is more natural.\n+\n+@item\n+The recognition of the interlock delays has slow implementation.  GCC\n+scheduler supports structures which describe the unit reservations.\n+The more processor has functional units, the slower pipeline hazard\n+recognizer.  Such implementation would become slower when we enable to\n+reserve functional units not only at the instruction execution start.\n+The automaton based pipeline hazard recognizer speed is not depended\n+on processor complexity.\n+@end itemize\n+\n @node Conditional Execution\n @section Conditional Execution\n @cindex conditional execution"}, {"sha": "cdc694bf5c3500854c995482e1d7ceb87a6d68ac", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -654,6 +654,8 @@ Several passes use instruction attributes.  A definition of the\n attributes defined for a particular machine is in file\n @file{insn-attr.h}, which is generated from the machine description by\n the program @file{genattr}.  The file @file{insn-attrtab.c} contains\n-subroutines to obtain the attribute values for insns.  It is generated\n-from the machine description by the program @file{genattrtab}.\n+subroutines to obtain the attribute values for insns and information\n+about processor pipeline characteristics for the instruction\n+scheduler.  It is generated from the machine description by the\n+program @file{genattrtab}.\n @end itemize"}, {"sha": "0157ef83840c669ecb9256acaede18cd1e8e2b67", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 157, "deletions": 9, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -5401,11 +5401,19 @@ hooks for this purpose.  It is usually enough to define just a few of\n them: try the first ones in this list first.\n \n @deftypefn {Target Hook} int TARGET_SCHED_ISSUE_RATE (void)\n-This hook returns the maximum number of instructions that can ever issue\n-at the same time on the target machine.  The default is one.  This value\n-must be constant over the entire compilation.  If you need it to vary\n-depending on what the instructions are, you must use\n+This hook returns the maximum number of instructions that can ever\n+issue at the same time on the target machine.  The default is one.\n+Although the insn scheduler can define itself the possibility of issue\n+an insn on the same cycle, the value can serve as an additional\n+constraint to issue insns on the same simulated processor cycle (see\n+hooks @samp{TARGET_SCHED_REORDER} and @samp{TARGET_SCHED_REORDER2}).\n+This value must be constant over the entire compilation.  If you need\n+it to vary depending on what the instructions are, you must use\n @samp{TARGET_SCHED_VARIABLE_ISSUE}.\n+\n+You could use the value of macro @samp{MAX_DFA_ISSUE_RATE} to return\n+the value of the hook @samp{TARGET_SCHED_ISSUE_RATE} for the automaton\n+based pipeline interface.\n @end deftypefn\n \n @deftypefn {Target Hook} int TARGET_SCHED_VARIABLE_ISSUE (FILE *@var{file}, int @var{verbose}, rtx @var{insn}, int @var{more})\n@@ -5421,12 +5429,18 @@ instruction that was scheduled.\n @end deftypefn\n \n @deftypefn {Target Hook} int TARGET_SCHED_ADJUST_COST (rtx @var{insn}, rtx @var{link}, rtx @var{dep_insn}, int @var{cost})\n-This function corrects the value of @var{cost} based on the relationship\n-between @var{insn} and @var{dep_insn} through the dependence @var{link}.\n-It should return the new value.  The default is to make no adjustment to\n-@var{cost}.  This can be used for example to specify to the scheduler\n+This function corrects the value of @var{cost} based on the\n+relationship between @var{insn} and @var{dep_insn} through the\n+dependence @var{link}.  It should return the new value.  The default\n+is to make no adjustment to @var{cost}.  This can be used for example\n+to specify to the scheduler using the traditional pipeline description\n that an output- or anti-dependence does not incur the same cost as a\n-data-dependence.\n+data-dependence.  If the scheduler using the automaton based pipeline\n+description, the cost of anti-dependence is zero and the cost of\n+output-dependence is maximum of one and the difference of latency\n+times of the first and the second insns.  If these values are not\n+acceptable, you could use the hook to modify them too.  See also\n+@pxref{Automaton pipeline description}.\n @end deftypefn\n \n @deftypefn {Target Hook} int TARGET_SCHED_ADJUST_PRIORITY (rtx @var{insn}, int @var{priority})\n@@ -5492,6 +5506,140 @@ RTL dumps and assembly output.  Define this hook only if you need this\n level of detail about what the scheduler is doing.\n @end deftypefn\n \n+@deftypefn {Target Hook} int TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE (void)\n+This hook is called many times during insn scheduling.  If the hook\n+returns nonzero, the automaton based pipeline description is used for\n+insn scheduling.  Otherwise the traditional pipeline description is\n+used.  The default is usage of the traditional pipeline description.\n+\n+You should also remember that to simplify the insn scheduler sources\n+an empty traditional pipeline description interface is generated even\n+if there is no a traditional pipeline description in the @file{.md}\n+file.  The same is true for the automaton based pipeline description.\n+That means that you should be accurate in defining the hook.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} int TARGET_SCHED_DFA_PRE_CYCLE_INSN (void)\n+The hook returns an RTL insn.  The automaton state used in the\n+pipeline hazard recognizer is changed as if the insn were scheduled\n+when the new simulated processor cycle starts.  Usage of the hook may\n+simplify the automaton pipeline description for some @acronym{VLIW}\n+processors.  If the hook is defined, it is used only for the automaton\n+based pipeline description.  The default is not to change the state\n+when the new simulated processor cycle starts.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN (void)\n+The hook can be used to initialize data used by the previous hook.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} int TARGET_SCHED_DFA_POST_CYCLE_INSN (void)\n+The hook is analogous to @samp{TARGET_SCHED_DFA_PRE_CYCLE_INSN} but used\n+to changed the state as if the insn were scheduled when the new\n+simulated processor cycle finishes.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN (void)\n+The hook is analogous to @samp{TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN} but\n+used to initialize data used by the previous hook.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} int TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD (void)\n+This hook controls better choosing an insn from the ready insn queue\n+for the @acronym{DFA}-based insn scheduler.  Usually the scheduler\n+chooses the first insn from the queue.  If the hook returns a positive\n+value, an additional scheduler code tries all permutations of\n+@samp{TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD ()}\n+subsequent ready insns to choose an insn whose issue will result in\n+maximal number of issued insns on the same cycle.  For the\n+@acronym{VLIW} processor, the code could actually solve the problem of\n+packing simple insns into the @acronym{VLIW} insn.  Of course, if the\n+rules of @acronym{VLIW} packing are described in the automaton.\n+\n+This code also could be used for superscalar @acronym{RISC}\n+processors.  Let us consider a superscalar @acronym{RISC} processor\n+with 3 pipelines.  Some insns can be executed in pipelines @var{A} or\n+@var{B}, some insns can be executed only in pipelines @var{B} or\n+@var{C}, and one insn can be executed in pipeline @var{B}.  The\n+processor may issue the 1st insn into @var{A} and the 2nd one into\n+@var{B}.  In this case, the 3rd insn will wait for freeing @var{B}\n+until the next cycle.  If the scheduler issues the 3rd insn the first,\n+the processor could issue all 3 insns per cycle.\n+\n+Actually this code demonstrates advantages of the automaton based\n+pipeline hazard recognizer.  We try quickly and easy many insn\n+schedules to choose the best one.\n+\n+The default is no multipass scheduling.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SCHED_INIT_DFA_BUBBLES (void)\n+The @acronym{DFA}-based scheduler could take the insertion of nop\n+operations for better insn scheduling into account.  It can be done\n+only if the multi-pass insn scheduling works (see hook\n+@samp{TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD}).\n+\n+Let us consider a @acronym{VLIW} processor insn with 3 slots.  Each\n+insn can be placed only in one of the three slots.  We have 3 ready\n+insns @var{A}, @var{B}, and @var{C}.  @var{A} and @var{C} can be\n+placed only in the 1st slot, @var{B} can be placed only in the 3rd\n+slot.  We described the automaton which does not permit empty slot\n+gaps between insns (usually such description is simpler).  Without\n+this code the scheduler would place each insn in 3 separate\n+@acronym{VLIW} insns.  If the scheduler places a nop insn into the 2nd\n+slot, it could place the 3 insns into 2 @acronym{VLIW} insns.  What is\n+the nop insn is returned by hook @samp{TARGET_SCHED_DFA_BUBBLE}.  Hook\n+@samp{TARGET_SCHED_INIT_DFA_BUBBLES} can be used to initialize or\n+create the nop insns.\n+\n+You should remember that the scheduler does not insert the nop insns.\n+It is not wise because of the following optimizations.  The scheduler\n+only considers such possibility to improve the result schedule.  The\n+nop insns should be inserted lately, e.g. on the final phase.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} rtx TARGET_SCHED_DFA_BUBBLE (int @var{index})\n+This hook @samp{FIRST_CYCLE_MULTIPASS_SCHEDULING} is used to insert\n+nop operations for better insn scheduling when @acronym{DFA}-based\n+scheduler makes multipass insn scheduling (see also description of\n+hook @samp{TARGET_SCHED_INIT_DFA_BUBBLES}).  This hook\n+returns a nop insn with given @var{index}.  The indexes start with\n+zero.  The hook should return @code{NULL} if there are no more nop\n+insns with indexes greater than given index.\n+@end deftypefn\n+\n+Macros in the following table are generated by the program\n+@file{genattr} and can be useful for writing the hooks.\n+\n+@table @code\n+@findex TRADITIONAL_PIPELINE_INTERFACE\n+@item TRADITIONAL_PIPELINE_INTERFACE\n+The macro definition is generated if there is a traditional pipeline\n+description in @file{.md} file. You should also remember that to\n+simplify the insn scheduler sources an empty traditional pipeline\n+description interface is generated even if there is no a traditional\n+pipeline description in the @file{.md} file.  The macro can be used to\n+distinguish the two types of the traditional interface.\n+\n+@findex DFA_PIPELINE_INTERFACE\n+@item DFA_PIPELINE_INTERFACE\n+The macro definition is generated if there is an automaton pipeline\n+description in @file{.md} file.  You should also remember that to\n+simplify the insn scheduler sources an empty automaton pipeline\n+description interface is generated even if there is no an automaton\n+pipeline description in the @file{.md} file.  The macro can be used to\n+distinguish the two types of the automaton interface.\n+\n+@findex MAX_DFA_ISSUE_RATE\n+@item MAX_DFA_ISSUE_RATE\n+The macro definition is generated in the automaton based pipeline\n+description interface.  Its value is calculated from the automaton\n+based pipeline description and is equal to maximal number of all insns\n+described in constructions @samp{define_insn_reservation} which can be\n+issued on the same processor cycle.\n+\n+@end table\n+\n @node Sections\n @section Dividing the Output into Sections (Texts, Data, @dots{})\n @c the above section title is WAY too long.  maybe cut the part between"}, {"sha": "60045ff808373593bbc0a8af1db4a433df158c0d", "filename": "gcc/genattr.c", "status": "modified", "additions": 106, "deletions": 1, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -193,6 +193,7 @@ main (argc, argv)\n   int have_delay = 0;\n   int have_annul_true = 0;\n   int have_annul_false = 0;\n+  int num_insn_reservations = 0;\n   int num_units = 0;\n   struct range all_simultaneity, all_multiplicity;\n   struct range all_ready_cost, all_issue_delay, all_blockage;\n@@ -308,10 +309,18 @@ main (argc, argv)\n \t  extend_range (&all_issue_delay,\n \t\t\tunit->issue_delay.min, unit->issue_delay.max);\n \t}\n+      else if (GET_CODE (desc) == DEFINE_INSN_RESERVATION)\n+\tnum_insn_reservations++;\n     }\n \n-  if (num_units > 0)\n+  if (num_units > 0 || num_insn_reservations > 0)\n     {\n+      if (num_units > 0)\n+\tprintf (\"#define TRADITIONAL_PIPELINE_INTERFACE 1\\n\");\n+\n+      if (num_insn_reservations > 0)\n+\tprintf (\"#define DFA_PIPELINE_INTERFACE 1\\n\");\n+\n       /* Compute the range of blockage cost values.  See genattrtab.c\n \t for the derivation.  BLOCKAGE (E,C) when SIMULTANEITY is zero is\n \n@@ -348,6 +357,102 @@ main (argc, argv)\n \n       write_units (num_units, &all_multiplicity, &all_simultaneity,\n \t\t   &all_ready_cost, &all_issue_delay, &all_blockage);\n+\n+      /* Output interface for pipeline hazards recognition based on\n+\t DFA (deterministic finite state automata.  */\n+      printf (\"\\n/* DFA based pipeline interface.  */\");\n+      printf (\"\\n#ifndef AUTOMATON_STATE_ALTS\\n\");\n+      printf (\"#define AUTOMATON_STATE_ALTS 0\\n\");\n+      printf (\"#endif\\n\\n\");\n+      printf (\"#ifndef CPU_UNITS_QUERY\\n\");\n+      printf (\"#define CPU_UNITS_QUERY 0\\n\");\n+      printf (\"#endif\\n\\n\");\n+      /* Interface itself: */\n+      printf (\"extern int max_dfa_issue_rate;\\n\\n\");\n+      printf (\"/* The following macro value is calculated from the\\n\");\n+      printf (\"   automaton based pipeline description and is equal to\\n\");\n+      printf (\"   maximal number of all insns described in constructions\\n\");\n+      printf (\"   `define_insn_reservation' which can be issued on the\\n\");\n+      printf (\"   same processor cycle. */\\n\");\n+      printf (\"#define MAX_DFA_ISSUE_RATE max_dfa_issue_rate\\n\\n\");\n+      printf (\"/* Insn latency time defined in define_insn_reservation. */\\n\");\n+      printf (\"extern int insn_default_latency PARAMS ((rtx));\\n\\n\");\n+      printf (\"/* Return nonzero if there is a bypass for given insn\\n\");\n+      printf (\"   which is a data producer.  */\\n\");\n+      printf (\"extern int bypass_p PARAMS ((rtx));\\n\\n\");\n+      printf (\"/* Insn latency time on data consumed by the 2nd insn.\\n\");\n+      printf (\"   Use the function if bypass_p returns nonzero for\\n\");\n+      printf (\"   the 1st insn. */\\n\");\n+      printf (\"extern int insn_latency PARAMS ((rtx, rtx));\\n\\n\");\n+      printf (\"/* The following function returns number of alternative\\n\");\n+      printf (\"   reservations of given insn.  It may be used for better\\n\");\n+      printf (\"   insns scheduling heuristics. */\\n\");\n+      printf (\"extern int insn_alts PARAMS ((rtx));\\n\\n\");\n+      printf (\"/* Maximal possible number of insns waiting results being\\n\");\n+      printf (\"   produced by insns whose execution is not finished. */\\n\");\n+      printf (\"extern int max_insn_queue_index;\\n\\n\");\n+      printf (\"/* Pointer to data describing current state of DFA.  */\\n\");\n+      printf (\"typedef void *state_t;\\n\\n\");\n+      printf (\"/* Size of the data in bytes.  */\\n\");\n+      printf (\"extern int state_size PARAMS ((void));\\n\\n\");\n+      printf (\"/* Initiate given DFA state, i.e. Set up the state\\n\");\n+      printf (\"   as all functional units were not reserved.  */\\n\");\n+      printf (\"extern void state_reset PARAMS ((state_t));\\n\");\n+      printf (\"/* The following function returns negative value if given\\n\");\n+      printf (\"   insn can be issued in processor state described by given\\n\");\n+      printf (\"   DFA state.  In this case, the DFA state is changed to\\n\");\n+      printf (\"   reflect the current and future reservations by given\\n\");\n+      printf (\"   insn.  Otherwise the function returns minimal time\\n\");\n+      printf (\"   delay to issue the insn.  This delay may be zero\\n\");\n+      printf (\"   for superscalar or VLIW processors.  If the second\\n\");\n+      printf (\"   parameter is NULL the function changes given DFA state\\n\");\n+      printf (\"   as new processor cycle started.  */\\n\");\n+      printf (\"extern int state_transition PARAMS ((state_t, rtx));\\n\");\n+      printf (\"\\n#if AUTOMATON_STATE_ALTS\\n\");\n+      printf (\"/* The following function returns number of possible\\n\");\n+      printf (\"   alternative reservations of given insn in given\\n\");\n+      printf (\"   DFA state.  It may be used for better insns scheduling\\n\");\n+      printf (\"   heuristics.  By default the function is defined if\\n\");\n+      printf (\"   macro AUTOMATON_STATE_ALTS is defined because its\\n\");\n+      printf (\"   implementation may require much memory.  */\\n\");\n+      printf (\"extern int state_alts PARAMS ((state_t, rtx));\\n\");\n+      printf (\"#endif\\n\\n\");\n+      printf (\"extern int min_issue_delay PARAMS ((state_t, rtx));\\n\");\n+      printf (\"/* The following function returns nonzero if no one insn\\n\");\n+      printf (\"   can be issued in current DFA state. */\\n\");\n+      printf (\"extern int state_dead_lock_p PARAMS ((state_t));\\n\");\n+      printf (\"/* The function returns minimal delay of issue of the 2nd\\n\");\n+      printf (\"   insn after issuing the 1st insn in given DFA state.\\n\");\n+      printf (\"   The 1st insn should be issued in given state (i.e.\\n\");\n+      printf (\"    state_transition should return negative value for\\n\");\n+      printf (\"    the insn and the state).  Data dependencies between\\n\");\n+      printf (\"    the insns are ignored by the function.  */\\n\");\n+      printf\n+\t(\"extern int min_insn_conflict_delay PARAMS ((state_t, rtx, rtx));\\n\");\n+      printf (\"/* The following function outputs reservations for given\\n\");\n+      printf (\"   insn as they are described in the corresponding\\n\");\n+      printf (\"   define_insn_reservation.  */\\n\");\n+      printf (\"extern void print_reservation PARAMS ((FILE *, rtx));\\n\");\n+      printf (\"\\n#if CPU_UNITS_QUERY\\n\");\n+      printf (\"/* The following function returns code of functional unit\\n\");\n+      printf (\"   with given name (see define_cpu_unit). */\\n\");\n+      printf (\"extern int get_cpu_unit_code PARAMS ((const char *));\\n\");\n+      printf (\"/* The following function returns nonzero if functional\\n\");\n+      printf (\"   unit with given code is currently reserved in given\\n\");\n+      printf (\"   DFA state.  */\\n\");\n+      printf (\"extern int cpu_unit_reservation_p PARAMS ((state_t, int));\\n\");\n+      printf (\"#endif\\n\\n\");\n+      printf (\"/* Initiate and finish work with DFA.  They should be\\n\");\n+      printf (\"   called as the first and the last interface\\n\");\n+      printf (\"   functions.  */\\n\");\n+      printf (\"extern void dfa_start PARAMS ((void));\\n\");\n+      printf (\"extern void dfa_finish PARAMS ((void));\\n\");\n+    }\n+  else\n+    {\n+      /* Otherwise we do no scheduling, but we need these typedefs\n+\t in order to avoid uglifying other code with more ifdefs.  */\n+      printf (\"typedef void *state_t;\\n\\n\");\n     }\n \n   /* Output flag masks for use by reorg.  "}, {"sha": "d78972cc87ca1153750e467b974ef30d0dfae5b3", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 65, "deletions": 15, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -115,6 +115,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"obstack.h\"\n #include \"errors.h\"\n \n+#include \"genattrtab.h\"\n+\n static struct obstack obstack1, obstack2;\n struct obstack *hash_obstack = &obstack1;\n struct obstack *temp_obstack = &obstack2;\n@@ -309,6 +311,8 @@ static int have_annul_true, have_annul_false;\n static int num_units, num_unit_opclasses;\n static int num_insn_ents;\n \n+int num_dfa_decls;\n+\n /* Used as operand to `operate_exp':  */\n \n enum operator {PLUS_OP, MINUS_OP, POS_MINUS_OP, EQ_OP, OR_OP, ORX_OP, MAX_OP, MIN_OP, RANGE_OP};\n@@ -371,10 +375,7 @@ static void attr_hash_add_rtx\tPARAMS ((int, rtx));\n static void attr_hash_add_string PARAMS ((int, char *));\n static rtx attr_rtx\t\tPARAMS ((enum rtx_code, ...));\n static rtx attr_rtx_1\t\tPARAMS ((enum rtx_code, va_list));\n-static char *attr_printf\tPARAMS ((unsigned int, const char *, ...))\n-  ATTRIBUTE_PRINTF_2;\n static char *attr_string        PARAMS ((const char *, int));\n-static rtx check_attr_test\tPARAMS ((rtx, int, int));\n static rtx check_attr_value\tPARAMS ((rtx, struct attr_desc *));\n static rtx convert_set_attr_alternative PARAMS ((rtx, struct insn_def *));\n static rtx convert_set_attr\tPARAMS ((rtx, struct insn_def *));\n@@ -458,10 +459,8 @@ static void write_const_num_delay_slots PARAMS ((void));\n static int n_comma_elts\t\tPARAMS ((const char *));\n static char *next_comma_elt\tPARAMS ((const char **));\n static struct attr_desc *find_attr PARAMS ((const char *, int));\n-static void make_internal_attr\tPARAMS ((const char *, rtx, int));\n static struct attr_value *find_most_used  PARAMS ((struct attr_desc *));\n static rtx find_single_value\tPARAMS ((struct attr_desc *));\n-static rtx make_numeric_value\tPARAMS ((int));\n static void extend_range\tPARAMS ((struct range *, int, int));\n static rtx attr_eq\t\tPARAMS ((const char *, const char *));\n static const char *attr_numeral\tPARAMS ((int));\n@@ -739,7 +738,7 @@ attr_rtx VPARAMS ((enum rtx_code code, ...))\n \n    rtx attr_printf (len, format, [arg1, ..., argn])  */\n \n-static char *\n+char *\n attr_printf VPARAMS ((unsigned int len, const char *fmt, ...))\n {\n   char str[256];\n@@ -920,7 +919,7 @@ attr_copy_rtx (orig)\n \n    Return the new expression, if any.  */\n \n-static rtx\n+rtx\n check_attr_test (exp, is_const, lineno)\n      rtx exp;\n      int is_const;\n@@ -5880,7 +5879,7 @@ find_attr (name, create)\n \n /* Create internal attribute with the given default value.  */\n \n-static void\n+void\n make_internal_attr (name, value, special)\n      const char *name;\n      rtx value;\n@@ -5947,7 +5946,7 @@ find_single_value (attr)\n \n /* Return (attr_value \"n\") */\n \n-static rtx\n+rtx\n make_numeric_value (n)\n      int n;\n {\n@@ -6097,6 +6096,7 @@ from the machine description file `md'.  */\\n\\n\");\n \n   /* Read the machine description.  */\n \n+  initiate_automaton_gen (argc, argv);\n   while (1)\n     {\n       int lineno;\n@@ -6125,6 +6125,46 @@ from the machine description file `md'.  */\\n\\n\");\n \t  gen_unit (desc, lineno);\n \t  break;\n \n+\tcase DEFINE_CPU_UNIT:\n+\t  gen_cpu_unit (desc);\n+\t  break;\n+\t  \n+\tcase DEFINE_QUERY_CPU_UNIT:\n+\t  gen_query_cpu_unit (desc);\n+\t  break;\n+\t  \n+\tcase DEFINE_BYPASS:\n+\t  gen_bypass (desc);\n+\t  break;\n+\t  \n+\tcase EXCLUSION_SET:\n+\t  gen_excl_set (desc);\n+\t  break;\n+\t  \n+\tcase PRESENCE_SET:\n+\t  gen_presence_set (desc);\n+\t  break;\n+\t  \n+\tcase ABSENCE_SET:\n+\t  gen_absence_set (desc);\n+\t  break;\n+\t  \n+\tcase DEFINE_AUTOMATON:\n+\t  gen_automaton (desc);\n+\t  break;\n+\t  \n+\tcase AUTOMATA_OPTION:\n+\t  gen_automata_option (desc);\n+\t  break;\n+\t  \n+\tcase DEFINE_RESERVATION:\n+\t  gen_reserv (desc);\n+\t  break;\n+\t  \n+\tcase DEFINE_INSN_RESERVATION:\n+\t  gen_insn_reserv (desc);\n+\t  break;\n+\n \tdefault:\n \t  break;\n \t}\n@@ -6149,9 +6189,14 @@ from the machine description file `md'.  */\\n\\n\");\n   if (num_delays)\n     expand_delays ();\n \n-  /* Expand DEFINE_FUNCTION_UNIT information into new attributes.  */\n-  if (num_units)\n-    expand_units ();\n+  if (num_units || num_dfa_decls)\n+    {\n+      /* Expand DEFINE_FUNCTION_UNIT information into new attributes.  */\n+      expand_units ();\n+      /* Build DFA, output some functions and expand DFA information\n+\t into new attributes.  */\n+      expand_automata ();\n+    }\n \n   printf (\"#include \\\"config.h\\\"\\n\");\n   printf (\"#include \\\"system.h\\\"\\n\");\n@@ -6226,9 +6271,14 @@ from the machine description file `md'.  */\\n\\n\");\n \twrite_eligible_delay (\"annul_false\");\n     }\n \n-  /* Write out information about function units.  */\n-  if (num_units)\n-    write_function_unit_info ();\n+  if (num_units || num_dfa_decls)\n+    {\n+      /* Write out information about function units.  */\n+      write_function_unit_info ();\n+      /* Output code for pipeline hazards recognition based on DFA\n+\t (deterministic finite state automata. */\n+      write_automata ();\n+    }\n \n   /* Write out constant delay slot info */\n   write_const_num_delay_slots ();"}, {"sha": "ea1f23991eacc60f51d717a7c1e799c8845f6b39", "filename": "gcc/genattrtab.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fgenattrtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fgenattrtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.h?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -0,0 +1,43 @@\n+/* External definitions of source files of genattrtab.\n+   Copyright (C)  2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Defined in genattrtab.c: */\n+extern rtx check_attr_test\tPARAMS ((rtx, int, int));\n+extern rtx make_numeric_value\tPARAMS ((int));\n+extern void make_internal_attr\tPARAMS ((const char *, rtx, int));\n+extern char *attr_printf\tPARAMS ((unsigned int, const char *, ...))\n+  ATTRIBUTE_PRINTF_2;\n+\n+extern int num_dfa_decls;\n+\n+/* Defined in genautomata.c: */\n+extern void gen_cpu_unit\t\tPARAMS ((rtx));\n+extern void gen_query_cpu_unit\t\tPARAMS ((rtx));\n+extern void gen_bypass\t\t\tPARAMS ((rtx));\n+extern void gen_excl_set\t\tPARAMS ((rtx));\n+extern void gen_presence_set\t\tPARAMS ((rtx));\n+extern void gen_absence_set\t\tPARAMS ((rtx));\n+extern void gen_automaton\t\tPARAMS ((rtx));\n+extern void gen_automata_option\t\tPARAMS ((rtx));\n+extern void gen_reserv   \t\tPARAMS ((rtx));\n+extern void gen_insn_reserv     \tPARAMS ((rtx));\n+extern void initiate_automaton_gen\tPARAMS ((int, char **));\n+extern void expand_automata             PARAMS ((void));\n+extern void write_automata              PARAMS ((void));"}, {"sha": "76a57bb3b43fa6b13085647d0c74d8d39f89364e", "filename": "gcc/genautomata.c", "status": "added", "additions": 9162, "deletions": 0, "changes": 9162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca"}, {"sha": "2ac8121801f2194768f4f673378900409f36fd74", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 565, "deletions": 106, "changes": 671, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -158,6 +158,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n static int issue_rate;\n \n+/* If the following variable value is non zero, the scheduler inserts\n+   bubbles (nop insns).  The value of variable affects on scheduler\n+   behavior only if automaton pipeline interface with multipass\n+   scheduling is used and hook dfa_bubble is defined.  */\n+int insert_schedule_bubbles_p = 0;\n+\n /* sched-verbose controls the amount of debugging output the\n    scheduler prints.  It is controlled by -fsched-verbose=N:\n    N>0 and no -DSR : the output is directed to stderr.\n@@ -254,14 +260,39 @@ static rtx note_list;\n    passes or stalls are introduced.  */\n \n /* Implement a circular buffer to delay instructions until sufficient\n-   time has passed.  INSN_QUEUE_SIZE is a power of two larger than\n-   MAX_BLOCKAGE and MAX_READY_COST computed by genattr.c.  This is the\n-   longest time an isnsn may be queued.  */\n-static rtx insn_queue[INSN_QUEUE_SIZE];\n+   time has passed.  For the old pipeline description interface,\n+   INSN_QUEUE_SIZE is a power of two larger than MAX_BLOCKAGE and\n+   MAX_READY_COST computed by genattr.c.  For the new pipeline\n+   description interface, MAX_INSN_QUEUE_INDEX is a power of two minus\n+   one which is larger than maximal time of instruction execution\n+   computed by genattr.c on the base maximal time of functional unit\n+   reservations and geting a result.  This is the longest time an\n+   insn may be queued.  */\n+\n+#define MAX_INSN_QUEUE_INDEX max_insn_queue_index_macro_value\n+\n+static rtx *insn_queue;\n static int q_ptr = 0;\n static int q_size = 0;\n-#define NEXT_Q(X) (((X)+1) & (INSN_QUEUE_SIZE-1))\n-#define NEXT_Q_AFTER(X, C) (((X)+C) & (INSN_QUEUE_SIZE-1))\n+#define NEXT_Q(X) (((X)+1) & MAX_INSN_QUEUE_INDEX)\n+#define NEXT_Q_AFTER(X, C) (((X)+C) & MAX_INSN_QUEUE_INDEX)\n+\n+/* The following variable defines value for macro\n+   MAX_INSN_QUEUE_INDEX.  */\n+static int max_insn_queue_index_macro_value;\n+\n+/* The following variable value refers for all current and future\n+   reservations of the processor units.  */\n+state_t curr_state;\n+\n+/* The following variable value is size of memory representing all\n+   current and future reservations of the processor units.  It is used\n+   only by DFA based scheduler.  */\n+static size_t dfa_state_size;\n+\n+/* The following array is used to find the best insn from ready when\n+   the automaton pipeline interface is used.  */\n+static char *ready_try;\n \n /* Describe the ready list of the scheduler.\n    VEC holds space enough for all insns in the current region.  VECLEN\n@@ -280,18 +311,23 @@ struct ready_list\n };\n \n /* Forward declarations.  */\n+\n+/* The scheduler using only DFA description should never use the\n+   following five functions:  */\n static unsigned int blockage_range PARAMS ((int, rtx));\n static void clear_units PARAMS ((void));\n static void schedule_unit PARAMS ((int, rtx, int));\n static int actual_hazard PARAMS ((int, rtx, int, int));\n static int potential_hazard PARAMS ((int, rtx, int));\n+\n static int priority PARAMS ((rtx));\n static int rank_for_schedule PARAMS ((const PTR, const PTR));\n static void swap_sort PARAMS ((rtx *, int));\n static void queue_insn PARAMS ((rtx, int));\n static void schedule_insn PARAMS ((rtx, struct ready_list *, int));\n static void find_insn_reg_weight PARAMS ((int));\n static void adjust_priority PARAMS ((rtx));\n+static void advance_one_cycle PARAMS ((void));\n \n /* Notes handling mechanism:\n    =========================\n@@ -331,6 +367,14 @@ static void debug_ready_list PARAMS ((struct ready_list *));\n static rtx move_insn1 PARAMS ((rtx, rtx));\n static rtx move_insn PARAMS ((rtx, rtx));\n \n+/* The following functions are used to implement multi-pass scheduling\n+   on the first cycle.  It is used only for DFA based scheduler.  */\n+static rtx ready_element PARAMS ((struct ready_list *, int));\n+static rtx ready_remove PARAMS ((struct ready_list *, int));\n+static int max_issue PARAMS ((struct ready_list *, state_t, int *));\n+\n+static rtx choose_ready PARAMS ((struct ready_list *));\n+\n #endif /* INSN_SCHEDULING */\n \f\n /* Point to state used for the current scheduling pass.  */\n@@ -354,7 +398,8 @@ static rtx last_scheduled_insn;\n    returned by function_units_used.  A function unit is encoded as the\n    unit number if the value is non-negative and the compliment of a\n    mask if the value is negative.  A function unit index is the\n-   non-negative encoding.  */\n+   non-negative encoding.  The scheduler using only DFA description\n+   should never use the following function.  */\n \n HAIFA_INLINE int\n insn_unit (insn)\n@@ -391,7 +436,9 @@ insn_unit (insn)\n /* Compute the blockage range for executing INSN on UNIT.  This caches\n    the value returned by the blockage_range_function for the unit.\n    These values are encoded in an int where the upper half gives the\n-   minimum value and the lower half gives the maximum value.  */\n+   minimum value and the lower half gives the maximum value.  The\n+   scheduler using only DFA description should never use the following\n+   function.  */\n \n HAIFA_INLINE static unsigned int\n blockage_range (unit, insn)\n@@ -415,20 +462,38 @@ blockage_range (unit, insn)\n   return range;\n }\n \n-/* A vector indexed by function unit instance giving the last insn to use\n-   the unit.  The value of the function unit instance index for unit U\n-   instance I is (U + I * FUNCTION_UNITS_SIZE).  */\n+/* A vector indexed by function unit instance giving the last insn to\n+   use the unit.  The value of the function unit instance index for\n+   unit U instance I is (U + I * FUNCTION_UNITS_SIZE).  The scheduler\n+   using only DFA description should never use the following variable.  */\n+#if FUNCTION_UNITS_SIZE\n static rtx unit_last_insn[FUNCTION_UNITS_SIZE * MAX_MULTIPLICITY];\n+#else\n+static rtx unit_last_insn[1];\n+#endif\n \n-/* A vector indexed by function unit instance giving the minimum time when\n-   the unit will unblock based on the maximum blockage cost.  */\n+/* A vector indexed by function unit instance giving the minimum time\n+   when the unit will unblock based on the maximum blockage cost.  The\n+   scheduler using only DFA description should never use the following\n+   variable.  */\n+#if FUNCTION_UNITS_SIZE\n static int unit_tick[FUNCTION_UNITS_SIZE * MAX_MULTIPLICITY];\n+#else\n+static int unit_tick[1];\n+#endif\n \n /* A vector indexed by function unit number giving the number of insns\n-   that remain to use the unit.  */\n+   that remain to use the unit.  The scheduler using only DFA\n+   description should never use the following variable.  */\n+#if FUNCTION_UNITS_SIZE\n static int unit_n_insns[FUNCTION_UNITS_SIZE];\n+#else\n+static int unit_n_insns[1];\n+#endif\n \n-/* Access the unit_last_insn array.  Used by the visualization code.  */\n+/* Access the unit_last_insn array.  Used by the visualization code.\n+   The scheduler using only DFA description should never use the\n+   following function.  */\n \n rtx\n get_unit_last_insn (instance)\n@@ -447,7 +512,8 @@ clear_units ()\n   memset ((char *) unit_n_insns, 0, sizeof (unit_n_insns));\n }\n \n-/* Return the issue-delay of an insn.  */\n+/* Return the issue-delay of an insn.  The scheduler using only DFA\n+   description should never use the following function.  */\n \n HAIFA_INLINE int\n insn_issue_delay (insn)\n@@ -477,7 +543,8 @@ insn_issue_delay (insn)\n \n /* Return the actual hazard cost of executing INSN on the unit UNIT,\n    instance INSTANCE at time CLOCK if the previous actual hazard cost\n-   was COST.  */\n+   was COST.  The scheduler using only DFA description should never\n+   use the following function.  */\n \n HAIFA_INLINE int\n actual_hazard_this_instance (unit, instance, insn, clock, cost)\n@@ -513,8 +580,9 @@ actual_hazard_this_instance (unit, instance, insn, clock, cost)\n   return cost;\n }\n \n-/* Record INSN as having begun execution on the units encoded by UNIT at\n-   time CLOCK.  */\n+/* Record INSN as having begun execution on the units encoded by UNIT\n+   at time CLOCK.  The scheduler using only DFA description should\n+   never use the following function.  */\n \n HAIFA_INLINE static void\n schedule_unit (unit, insn, clock)\n@@ -545,8 +613,10 @@ schedule_unit (unit, insn, clock)\n \tschedule_unit (i, insn, clock);\n }\n \n-/* Return the actual hazard cost of executing INSN on the units encoded by\n-   UNIT at time CLOCK if the previous actual hazard cost was COST.  */\n+/* Return the actual hazard cost of executing INSN on the units\n+   encoded by UNIT at time CLOCK if the previous actual hazard cost\n+   was COST.  The scheduler using only DFA description should never\n+   use the following function.  */\n \n HAIFA_INLINE static int\n actual_hazard (unit, insn, clock, cost)\n@@ -591,11 +661,13 @@ actual_hazard (unit, insn, clock, cost)\n }\n \n /* Return the potential hazard cost of executing an instruction on the\n-   units encoded by UNIT if the previous potential hazard cost was COST.\n-   An insn with a large blockage time is chosen in preference to one\n-   with a smaller time; an insn that uses a unit that is more likely\n-   to be used is chosen in preference to one with a unit that is less\n-   used.  We are trying to minimize a subsequent actual hazard.  */\n+   units encoded by UNIT if the previous potential hazard cost was\n+   COST.  An insn with a large blockage time is chosen in preference\n+   to one with a smaller time; an insn that uses a unit that is more\n+   likely to be used is chosen in preference to one with a unit that\n+   is less used.  We are trying to minimize a subsequent actual\n+   hazard.  The scheduler using only DFA description should never use\n+   the following function.  */\n \n HAIFA_INLINE static int\n potential_hazard (unit, insn, cost)\n@@ -648,62 +720,69 @@ insn_cost (insn, link, used)\n {\n   int cost = INSN_COST (insn);\n \n-  if (cost == 0)\n+  if (cost < 0)\n     {\n-      recog_memoized (insn);\n-\n-      /* A USE insn, or something else we don't need to understand.\n-         We can't pass these directly to result_ready_cost because it will\n-         trigger a fatal error for unrecognizable insns.  */\n-      if (INSN_CODE (insn) < 0)\n+      /* A USE insn, or something else we don't need to\n+\t understand.  We can't pass these directly to\n+\t result_ready_cost or insn_default_latency because it will\n+\t trigger a fatal error for unrecognizable insns.  */\n+      if (recog_memoized (insn) < 0)\n \t{\n-\t  INSN_COST (insn) = 1;\n-\t  return 1;\n+\t  INSN_COST (insn) = 0;\n+\t  return 0;\n \t}\n       else\n \t{\n-\t  cost = result_ready_cost (insn);\n-\n-\t  if (cost < 1)\n-\t    cost = 1;\n-\n+\t  if (targetm.sched.use_dfa_pipeline_interface\n+\t      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+\t    cost = insn_default_latency (insn);\n+\t  else\n+\t    cost = result_ready_cost (insn);\n+\t  \n+\t  if (cost < 0)\n+\t    cost = 0;\n+\t  \n \t  INSN_COST (insn) = cost;\n \t}\n     }\n \n   /* In this case estimate cost without caring how insn is used.  */\n-  if (link == 0 && used == 0)\n+  if (link == 0 || used == 0)\n     return cost;\n \n-  /* A USE insn should never require the value used to be computed.  This\n-     allows the computation of a function's result and parameter values to\n-     overlap the return and call.  */\n-  recog_memoized (used);\n-  if (INSN_CODE (used) < 0)\n-    LINK_COST_FREE (link) = 1;\n-\n-  /* If some dependencies vary the cost, compute the adjustment.  Most\n-     commonly, the adjustment is complete: either the cost is ignored\n-     (in the case of an output- or anti-dependence), or the cost is\n-     unchanged.  These values are cached in the link as LINK_COST_FREE\n-     and LINK_COST_ZERO.  */\n-\n-  if (LINK_COST_FREE (link))\n+  /* A USE insn should never require the value used to be computed.\n+     This allows the computation of a function's result and parameter\n+     values to overlap the return and call.  */\n+  if (recog_memoized (used) < 0)\n     cost = 0;\n-  else if (!LINK_COST_ZERO (link) && targetm.sched.adjust_cost)\n+  else\n     {\n-      int ncost = (*targetm.sched.adjust_cost) (used, link, insn, cost);\n-\n-      if (ncost < 1)\n+      if (targetm.sched.use_dfa_pipeline_interface\n+\t  && (*targetm.sched.use_dfa_pipeline_interface) ())\n \t{\n-\t  LINK_COST_FREE (link) = 1;\n-\t  ncost = 0;\n+\t  if (INSN_CODE (insn) >= 0)\n+\t    {\n+\t      if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n+\t\tcost = 0;\n+\t      else if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n+\t\t{\n+\t\t  cost = (insn_default_latency (insn)\n+\t\t\t  - insn_default_latency (used));\n+\t\t  if (cost <= 0)\n+\t\t    cost = 1;\n+\t\t}\n+\t      else if (bypass_p (insn))\n+\t\tcost = insn_latency (insn, used);\n+\t    }\n \t}\n-      if (cost == ncost)\n-\tLINK_COST_ZERO (link) = 1;\n-      cost = ncost;\n-    }\n \n+      if (targetm.sched.adjust_cost)\n+\tcost = (*targetm.sched.adjust_cost) (used, link, insn, cost);\n+\n+      if (cost < 0)\n+\tcost = 0;\n+    }\n+  \n   return cost;\n }\n \n@@ -930,6 +1009,48 @@ ready_remove_first (ready)\n   return t;\n }\n \n+/* The following code implements multi-pass scheduling for the first\n+   cycle.  In other words, we will try to choose ready insn which\n+   permits to start maximum number of insns on the same cycle.  */\n+\n+/* Return a pointer to the element INDEX from the ready.  INDEX for\n+   insn with the highest priority is 0, and the lowest priority has\n+   N_READY - 1.  */\n+\n+HAIFA_INLINE static rtx\n+ready_element (ready, index)\n+     struct ready_list *ready;\n+     int index;\n+{\n+  if (ready->n_ready == 0 || index >= ready->n_ready)\n+    abort ();\n+  return ready->vec[ready->first - index];\n+}\n+\n+/* Remove the element INDEX from the ready list and return it.  INDEX\n+   for insn with the highest priority is 0, and the lowest priority\n+   has N_READY - 1.  */\n+\n+HAIFA_INLINE static rtx\n+ready_remove (ready, index)\n+     struct ready_list *ready;\n+     int index;\n+{\n+  rtx t;\n+  int i;\n+\n+  if (index == 0)\n+    return ready_remove_first (ready);\n+  if (ready->n_ready == 0 || index >= ready->n_ready)\n+    abort ();\n+  t = ready->vec[ready->first - index];\n+  ready->n_ready--;\n+  for (i = index; i < ready->n_ready; i++)\n+    ready->vec[ready->first - i] = ready->vec[ready->first - i - 1];\n+  return t;\n+}\n+\n+\n /* Sort the ready list READY by ascending priority, using the SCHED_SORT\n    macro.  */\n \n@@ -961,6 +1082,25 @@ adjust_priority (prev)\n       (*targetm.sched.adjust_priority) (prev, INSN_PRIORITY (prev));\n }\n \n+/* Advance time on one cycle.  */\n+HAIFA_INLINE static void\n+advance_one_cycle ()\n+{\n+  if (targetm.sched.use_dfa_pipeline_interface\n+      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+    {\n+      if (targetm.sched.dfa_pre_cycle_insn)\n+\tstate_transition (curr_state,\n+\t\t\t  (*targetm.sched.dfa_pre_cycle_insn) ());\n+\n+      state_transition (curr_state, NULL);\n+\n+      if (targetm.sched.dfa_post_cycle_insn)\n+\tstate_transition (curr_state,\n+\t\t\t  (*targetm.sched.dfa_post_cycle_insn) ());\n+    }\n+}\n+\n /* Clock at which the previous instruction was issued.  */\n static int last_clock_var;\n \n@@ -976,26 +1116,50 @@ schedule_insn (insn, ready, clock)\n      int clock;\n {\n   rtx link;\n-  int unit;\n+  int unit = 0;\n \n-  unit = insn_unit (insn);\n+  if (!targetm.sched.use_dfa_pipeline_interface\n+      || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+    unit = insn_unit (insn);\n \n   if (sched_verbose >= 2)\n     {\n-      fprintf (sched_dump, \";;\\t\\t--> scheduling insn <<<%d>>> on unit \",\n-\t       INSN_UID (insn));\n-      insn_print_units (insn);\n+\n+      if (targetm.sched.use_dfa_pipeline_interface\n+\t  && (*targetm.sched.use_dfa_pipeline_interface) ())\n+\t{\n+\t  fprintf (sched_dump,\n+\t\t   \";;\\t\\t--> scheduling insn <<<%d>>>:reservation \",\n+\t\t   INSN_UID (insn));\n+\t  \n+\t  if (recog_memoized (insn) < 0)\n+\t    fprintf (sched_dump, \"nothing\");\n+\t  else\n+\t    print_reservation (sched_dump, insn);\n+\t}\n+      else\n+\t{\n+\t  fprintf (sched_dump, \";;\\t\\t--> scheduling insn <<<%d>>> on unit \",\n+\t\t   INSN_UID (insn));\n+\t  insn_print_units (insn);\n+\t}\n+\n       fprintf (sched_dump, \"\\n\");\n     }\n \n-  if (sched_verbose && unit == -1)\n-    visualize_no_unit (insn);\n+  if (!targetm.sched.use_dfa_pipeline_interface\n+      || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+    {\n+      if (sched_verbose && unit == -1)\n+\tvisualize_no_unit (insn);\n \n-  if (MAX_BLOCKAGE > 1 || issue_rate > 1 || sched_verbose)\n-    schedule_unit (unit, insn, clock);\n \n-  if (INSN_DEPEND (insn) == 0)\n-    return;\n+      if (MAX_BLOCKAGE > 1 || issue_rate > 1 || sched_verbose)\n+\tschedule_unit (unit, insn, clock);\n+      \n+      if (INSN_DEPEND (insn) == 0)\n+\treturn;\n+    }\n \n   for (link = INSN_DEPEND (insn); link != 0; link = XEXP (link, 1))\n     {\n@@ -1037,7 +1201,9 @@ schedule_insn (insn, ready, clock)\n      to issue on the same cycle as the previous insn.  A machine\n      may use this information to decide how the instruction should\n      be aligned.  */\n-  if (reload_completed && issue_rate > 1)\n+  if (reload_completed && issue_rate > 1\n+      && GET_CODE (PATTERN (insn)) != USE\n+      && GET_CODE (PATTERN (insn)) != CLOBBER)\n     {\n       PUT_MODE (insn, clock > last_clock_var ? TImode : VOIDmode);\n       last_clock_var = clock;\n@@ -1464,7 +1630,7 @@ queue_to_ready (ready)\n     {\n       int stalls;\n \n-      for (stalls = 1; stalls < INSN_QUEUE_SIZE; stalls++)\n+      for (stalls = 1; stalls <= MAX_INSN_QUEUE_INDEX; stalls++)\n \t{\n \t  if ((link = insn_queue[NEXT_Q_AFTER (q_ptr, stalls)]))\n \t    {\n@@ -1483,13 +1649,19 @@ queue_to_ready (ready)\n \t\t}\n \t      insn_queue[NEXT_Q_AFTER (q_ptr, stalls)] = 0;\n \n-\t      if (ready->n_ready)\n-\t\tbreak;\n+\t      advance_one_cycle ();\n+\n+\t      break;\n \t    }\n+\n+\t  advance_one_cycle ();\n \t}\n \n-      if (sched_verbose && stalls)\n+      if ((!targetm.sched.use_dfa_pipeline_interface\n+\t   || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+\t  && sched_verbose && stalls)\n \tvisualize_stall_cycles (stalls);\n+\n       q_ptr = NEXT_Q_AFTER (q_ptr, stalls);\n       clock_var += stalls;\n     }\n@@ -1505,7 +1677,10 @@ debug_ready_list (ready)\n   int i;\n \n   if (ready->n_ready == 0)\n-    return;\n+    {\n+      fprintf (sched_dump, \"\\n\");\n+      return;\n+    }\n \n   p = ready_lastpos (ready);\n   for (i = 0; i < ready->n_ready; i++)\n@@ -1617,6 +1792,113 @@ move_insn (insn, last)\n   return retval;\n }\n \n+/* The following function returns maximal (or close to maximal) number\n+   of insns which can be issued on the same cycle and one of which\n+   insns is insns with the best rank (the last insn in READY).  To\n+   make this function tries different samples of ready insns.  READY\n+   is current queue `ready'.  Global array READY_TRY reflects what\n+   insns are already issued in this try.  STATE is current processor\n+   state.  If the function returns nonzero, INDEX will contain index\n+   of the best insn in READY.  The following function is used only for\n+   first cycle multipass scheduling.  */\n+\n+static int\n+max_issue (ready, state, index)\n+     struct ready_list *ready;\n+     state_t state;\n+     int *index;\n+{\n+  int i, best, n, temp_index, delay;\n+  state_t temp_state;\n+  rtx insn;\n+  int max_lookahead = (*targetm.sched.first_cycle_multipass_dfa_lookahead) ();\n+\n+  if (state_dead_lock_p (state))\n+    return 0;\n+\n+  temp_state = alloca (dfa_state_size);\n+  best = 0;\n+  \n+  for (i = 0; i < ready->n_ready; i++)\n+    if (!ready_try [i])\n+      {\n+\tinsn = ready_element (ready, i);\n+\t\n+\tif (INSN_CODE (insn) < 0)\n+\t  continue;\n+\t\n+\tmemcpy (temp_state, state, dfa_state_size);\n+\t\n+\tdelay = state_transition (temp_state, insn);\n+\t\n+\tif (delay == 0)\n+\t  {\n+\t    if (!targetm.sched.dfa_bubble)\n+\t      continue;\n+\t    else\n+\t      {\n+\t\tint j;\n+\t\trtx bubble;\n+\t\t\n+\t\tfor (j = 0;\n+\t\t     (bubble = (*targetm.sched.dfa_bubble) (j)) != NULL_RTX;\n+\t\t     j++)\n+\t\t  if (state_transition (temp_state, bubble) < 0\n+\t\t      && state_transition (temp_state, insn) < 0)\n+\t\t    break;\n+\t\t\n+\t\tif (bubble == NULL_RTX)\n+\t\t  continue;\n+\t      }\n+\t  }\n+\telse if (delay > 0)\n+\t  continue;\n+\t\n+\t--max_lookahead;\n+\t\n+\tif (max_lookahead < 0)\n+\t  break;\n+\t\n+\tready_try [i] = 1;\n+\n+\tn = max_issue (ready, temp_state, &temp_index);\n+\tif (n > 0 || ready_try[0])\n+\t  n += 1;\n+\n+\tif (best < n)\n+\t  {\n+\t    best = n;\n+\t    *index = i;\n+\t  }\n+\tready_try [i] = 0;\n+      }\n+  \n+  return best;\n+}\n+\n+/* The following function chooses insn from READY and modifies\n+   *N_READY and READY.  The following function is used only for first\n+   cycle multipass scheduling.  */\n+\n+static rtx\n+choose_ready (ready)\n+     struct ready_list *ready;\n+{\n+  if (!targetm.sched.first_cycle_multipass_dfa_lookahead\n+      || (*targetm.sched.first_cycle_multipass_dfa_lookahead) () <= 0)\n+    return ready_remove_first (ready);\n+  else\n+    {\n+      /* Try to choose the better insn.  */\n+      int index;\n+\n+      if (max_issue (ready, curr_state, &index) == 0)\n+\treturn ready_remove_first (ready);\n+      else\n+\treturn ready_remove (ready, index);\n+    }\n+}\n+\n /* Called from backends from targetm.sched.reorder to emit stuff into\n    the instruction stream.  */\n \n@@ -1638,7 +1920,9 @@ schedule_block (b, rgn_n_insns)\n      int rgn_n_insns;\n {\n   struct ready_list ready;\n+  int first_cycle_insn_p;\n   int can_issue_more;\n+  state_t temp_state = NULL;  /* It is used for multipass scheduling.  */\n \n   /* Head/tail info for this block.  */\n   rtx prev_head = current_sched_info->prev_head;\n@@ -1671,14 +1955,27 @@ schedule_block (b, rgn_n_insns)\n       init_block_visualization ();\n     }\n \n-  clear_units ();\n+  if (targetm.sched.use_dfa_pipeline_interface\n+      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+    state_reset (curr_state);\n+  else\n+    clear_units ();\n \n   /* Allocate the ready list.  */\n   ready.veclen = rgn_n_insns + 1 + issue_rate;\n   ready.first = ready.veclen - 1;\n   ready.vec = (rtx *) xmalloc (ready.veclen * sizeof (rtx));\n   ready.n_ready = 0;\n \n+  if (targetm.sched.use_dfa_pipeline_interface\n+      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+    {\n+      /* It is used for first cycle multipass scheduling.  */\n+      temp_state = alloca (dfa_state_size);\n+      ready_try = (char *) xmalloc ((rgn_n_insns + 1) * sizeof (char));\n+      memset (ready_try, 0, (rgn_n_insns + 1) * sizeof (char));\n+    }\n+\n   (*current_sched_info->init_ready_list) (&ready);\n \n   if (targetm.sched.md_init)\n@@ -1691,8 +1988,16 @@ schedule_block (b, rgn_n_insns)\n      queue.  */\n   q_ptr = 0;\n   q_size = 0;\n-  last_clock_var = 0;\n-  memset ((char *) insn_queue, 0, sizeof (insn_queue));\n+\n+  if (!targetm.sched.use_dfa_pipeline_interface\n+      || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+    max_insn_queue_index_macro_value = INSN_QUEUE_SIZE - 1;\n+  else\n+    max_insn_queue_index_macro_value = max_insn_queue_index;\n+\n+  insn_queue = (rtx *) alloca ((MAX_INSN_QUEUE_INDEX + 1) * sizeof (rtx));\n+  memset ((char *) insn_queue, 0, (MAX_INSN_QUEUE_INDEX + 1) * sizeof (rtx));\n+  last_clock_var = -1;\n \n   /* Start just before the beginning of time.  */\n   clock_var = -1;\n@@ -1702,12 +2007,18 @@ schedule_block (b, rgn_n_insns)\n     {\n       clock_var++;\n \n+      advance_one_cycle ();\n+\n       /* Add to the ready list all pending insns that can be issued now.\n          If there are no ready insns, increment clock until one\n          is ready and add all pending insns at that point to the ready\n          list.  */\n       queue_to_ready (&ready);\n \n+      if (sched_verbose && targetm.sched.cycle_display)\n+\tlast_scheduled_insn\n+\t  = (*targetm.sched.cycle_display) (clock_var, last_scheduled_insn);\n+\n       if (ready.n_ready == 0)\n \tabort ();\n \n@@ -1730,24 +2041,127 @@ schedule_block (b, rgn_n_insns)\n       else\n \tcan_issue_more = issue_rate;\n \n-      if (sched_verbose && targetm.sched.cycle_display)\n-\tlast_scheduled_insn\n-\t  = (*targetm.sched.cycle_display) (clock_var, last_scheduled_insn);\n-\n-      if (sched_verbose)\n+      first_cycle_insn_p = 1;\n+      for (;;)\n \t{\n-\t  fprintf (sched_dump, \"\\n;;\\tReady list (t =%3d):  \", clock_var);\n-\t  debug_ready_list (&ready);\n-\t}\n+\t  rtx insn;\n+\t  int cost;\n+\n+\t  if (sched_verbose)\n+\t    {\n+\t      fprintf (sched_dump, \";;\\tReady list (t =%3d):  \",\n+\t\t       clock_var);\n+\t      debug_ready_list (&ready);\n+\t    }\n+\n+\t  if (!targetm.sched.use_dfa_pipeline_interface\n+\t      || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+\t    {\n+\t      if (ready.n_ready == 0 || !can_issue_more\n+\t\t  || !(*current_sched_info->schedule_more_p) ())\n+\t\tbreak;\n+\t      insn = choose_ready (&ready);\n+\t      cost = actual_hazard (insn_unit (insn), insn, clock_var, 0);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (ready.n_ready == 0 || !can_issue_more\n+\t\t  || state_dead_lock_p (curr_state)\n+\t\t  || !(*current_sched_info->schedule_more_p) ())\n+\t\tbreak;\n+\t      \n+\t      /* Select and remove the insn from the ready list.  */\n+\t      insn = choose_ready (&ready);\n+\t      \n+\t      memcpy (temp_state, curr_state, dfa_state_size);\n+\t      if (recog_memoized (insn) < 0)\n+\t\t{\n+\t\t  if (!first_cycle_insn_p\n+\t\t      && (GET_CODE (PATTERN (insn)) == ASM_INPUT\n+\t\t\t  || asm_noperands (PATTERN (insn)) >= 0))\n+\t\t    /* This is asm insn which is tryed to be issued on the\n+\t\t       cycle not first.  Issue it on the next cycle.  */\n+\t\t    cost = 1;\n+\t\t  else\n+\t\t    /* A USE insn, or something else we don't need to\n+\t\t       understand.  We can't pass these directly to\n+\t\t       state_transition because it will trigger a\n+\t\t       fatal error for unrecognizable insns.  */\n+\t\t    cost = 0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  cost = state_transition (temp_state, insn);\n+\n+\t\t  if (targetm.sched.first_cycle_multipass_dfa_lookahead\n+\t\t      && targetm.sched.dfa_bubble)\n+\t\t    {\n+\t\t      if (cost == 0)\n+\t\t\t{\n+\t\t\t  int j;\n+\t\t\t  rtx bubble;\n+\t\t\t  \n+\t\t\t  for (j = 0;\n+\t\t\t       (bubble = (*targetm.sched.dfa_bubble) (j))\n+\t\t\t\t != NULL_RTX;\n+\t\t\t       j++)\n+\t\t\t    {\n+\t\t\t      memcpy (temp_state, curr_state, dfa_state_size);\n+\t\t\t      \n+\t\t\t      if (state_transition (temp_state, bubble) < 0\n+\t\t\t\t  && state_transition (temp_state, insn) < 0)\n+\t\t\t\tbreak;\n+\t\t\t    }\n+\t\t\t  \n+\t\t\t  if (bubble != NULL_RTX)\n+\t\t\t    {\n+\t\t\t      if (insert_schedule_bubbles_p)\n+\t\t\t\t{\n+\t\t\t\t  rtx copy;\n+\t\t\t\t  \n+\t\t\t\t  copy = copy_rtx (PATTERN (bubble));\n+\t\t\t\t  emit_insn_after (copy, last_scheduled_insn);\n+\t\t\t\t  last_scheduled_insn\n+\t\t\t\t    = NEXT_INSN (last_scheduled_insn);\n+\t\t\t\t  INSN_CODE (last_scheduled_insn)\n+\t\t\t\t    = INSN_CODE (bubble);\n+\t\t\t\t  \n+\t\t\t\t  /* Annotate the same for the first insns\n+\t\t\t\t     scheduling by using mode.  */\n+\t\t\t\t  PUT_MODE (last_scheduled_insn,\n+\t\t\t\t\t    (clock_var > last_clock_var\n+\t\t\t\t\t     ? clock_var - last_clock_var\n+\t\t\t\t\t     : VOIDmode));\n+\t\t\t\t  last_clock_var = clock_var;\n+\t\t\t\t  \n+\t\t\t\t  if (sched_verbose >= 2)\n+\t\t\t\t    {\n+\t\t\t\t      fprintf (sched_dump,\n+\t\t\t\t\t       \";;\\t\\t--> scheduling bubble insn <<<%d>>>:reservation \",\n+\t\t\t\t\t       INSN_UID (last_scheduled_insn));\n+\t\t\t\t      \n+\t\t\t\t      if (recog_memoized (last_scheduled_insn)\n+\t\t\t\t\t  < 0)\n+\t\t\t\t\tfprintf (sched_dump, \"nothing\");\n+\t\t\t\t      else\n+\t\t\t\t\tprint_reservation\n+\t\t\t\t\t  (sched_dump, last_scheduled_insn);\n+\t\t\t\t      \n+\t\t\t\t      fprintf (sched_dump, \"\\n\");\n+\t\t\t\t    }\n+\t\t\t\t}\n+\t\t\t      cost = -1;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  if (cost < 0)\n+\t\t    cost = 0;\n+\t\t  else if (cost == 0)\n+\t\t    cost = 1;\n+\t\t}\n+\t    }\n \n-      /* Issue insns from ready list.  */\n-      while (ready.n_ready != 0\n-\t     && can_issue_more\n-\t     && (*current_sched_info->schedule_more_p) ())\n-\t{\n-\t  /* Select and remove the insn from the ready list.  */\n-\t  rtx insn = ready_remove_first (&ready);\n-\t  int cost = actual_hazard (insn_unit (insn), insn, clock_var, 0);\n \n \t  if (cost >= 1)\n \t    {\n@@ -1760,6 +2174,10 @@ schedule_block (b, rgn_n_insns)\n \n \t  last_scheduled_insn = move_insn (insn, last_scheduled_insn);\n \n+\t  if (targetm.sched.use_dfa_pipeline_interface\n+\t      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+\t    memcpy (curr_state, temp_state, dfa_state_size);\n+\t    \n \t  if (targetm.sched.variable_issue)\n \t    can_issue_more =\n \t      (*targetm.sched.variable_issue) (sched_dump, sched_verbose,\n@@ -1770,6 +2188,8 @@ schedule_block (b, rgn_n_insns)\n \t  schedule_insn (insn, &ready, clock_var);\n \n \tnext:\n+\t  first_cycle_insn_p = 0;\n+\n \t  if (targetm.sched.reorder2)\n \t    {\n \t      /* Sort the ready list based on priority.  */\n@@ -1783,8 +2203,10 @@ schedule_block (b, rgn_n_insns)\n \t    }\n \t}\n \n-      /* Debug info.  */\n-      if (sched_verbose)\n+      if ((!targetm.sched.use_dfa_pipeline_interface\n+\t   || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+\t  && sched_verbose)\n+\t/* Debug info.  */\n \tvisualize_scheduled_insns (clock_var);\n     }\n \n@@ -1796,7 +2218,9 @@ schedule_block (b, rgn_n_insns)\n     {\n       fprintf (sched_dump, \";;\\tReady list (final):  \");\n       debug_ready_list (&ready);\n-      print_block_visualization (\"\");\n+      if (!targetm.sched.use_dfa_pipeline_interface\n+\t  || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+\tprint_block_visualization (\"\");\n     }\n \n   /* Sanity check -- queue must be empty now.  Meaningless if region has\n@@ -1841,6 +2265,10 @@ schedule_block (b, rgn_n_insns)\n   current_sched_info->tail = tail;\n \n   free (ready.vec);\n+\n+  if (targetm.sched.use_dfa_pipeline_interface\n+      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+    free (ready_try);\n }\n \f\n /* Set_priorities: compute priority of each insn in the block.  */\n@@ -1882,6 +2310,7 @@ sched_init (dump_file)\n {\n   int luid, b;\n   rtx insn;\n+  int i;\n \n   /* Disable speculative loads in their presence if cc0 defined.  */\n #ifdef HAVE_cc0\n@@ -1909,6 +2338,27 @@ sched_init (dump_file)\n \n   h_i_d = (struct haifa_insn_data *) xcalloc (old_max_uid, sizeof (*h_i_d));\n \n+  for (i = 0; i < old_max_uid; i++)\n+    h_i_d [i].cost = -1;\n+\n+  if (targetm.sched.use_dfa_pipeline_interface\n+      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+    {\n+      if (targetm.sched.init_dfa_pre_cycle_insn)\n+\t(*targetm.sched.init_dfa_pre_cycle_insn) ();\n+      \n+      if (targetm.sched.init_dfa_post_cycle_insn)\n+\t(*targetm.sched.init_dfa_post_cycle_insn) ();\n+      \n+      if (targetm.sched.first_cycle_multipass_dfa_lookahead\n+\t  && targetm.sched.init_dfa_bubbles)\n+\t(*targetm.sched.init_dfa_bubbles) ();\n+      \n+      dfa_start ();\n+      dfa_state_size = state_size ();\n+      curr_state = xmalloc (dfa_state_size);\n+    }\n+\n   h_i_d[0].luid = 0;\n   luid = 1;\n   for (b = 0; b < n_basic_blocks; b++)\n@@ -1966,8 +2416,10 @@ sched_init (dump_file)\n \t}\n     }\n \n-  /* Find units used in this function, for visualization.  */\n-  if (sched_verbose)\n+  if ((!targetm.sched.use_dfa_pipeline_interface\n+       || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+      && sched_verbose)\n+    /* Find units used in this function, for visualization.  */\n     init_target_units ();\n \n   /* ??? Add a NOTE after the last insn of the last basic block.  It is not\n@@ -1997,6 +2449,13 @@ void\n sched_finish ()\n {\n   free (h_i_d);\n+\n+  if (targetm.sched.use_dfa_pipeline_interface\n+      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+    {\n+      free (curr_state);\n+      dfa_finish ();\n+    }\n   free_dependency_caches ();\n   end_alias_analysis ();\n   if (write_symbols != NO_DEBUG)"}, {"sha": "71c2ef18ab1149e9db650d24da0ce02558cdcef2", "filename": "gcc/rtl.def", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -341,6 +341,147 @@ DEF_RTL_EXPR(SEQUENCE, \"sequence\", \"E\", 'x')\n /* Refers to the address of its argument.  This is only used in alias.c.  */\n DEF_RTL_EXPR(ADDRESS, \"address\", \"e\", 'm')\n \n+/* ----------------------------------------------------------------------\n+   Constructions for CPU pipeline description described by NDFAs.\n+   These do not appear in actual rtl code in the compiler.\n+   ---------------------------------------------------------------------- */\n+\n+/* (define_cpu_unit string [string]) describes cpu functional\n+   units (separated by comma).\n+\n+   1st operand: Names of cpu functional units.\n+   2nd operand: Name of automaton (see comments for DEFINE_AUTOMATON).\n+\n+   All define_reservations, define_cpu_units, and\n+   define_query_cpu_units should have unique names which may not be\n+   \"nothing\".  */\n+DEF_RTL_EXPR(DEFINE_CPU_UNIT, \"define_cpu_unit\", \"sS\", 'x')\n+\n+/* (define_query_cpu_unit string [string]) describes cpu functional\n+   units analogously to define_cpu_unit.  If we use automaton without\n+   minimization, the reservation of such units can be queried for\n+   automaton state.  */\n+DEF_RTL_EXPR(DEFINE_QUERY_CPU_UNIT, \"define_query_cpu_unit\", \"sS\", 'x')\n+\n+/* (exclusion_set string string) means that each CPU functional unit\n+   in the first string can not be reserved simultaneously with any\n+   unit whose name is in the second string and vise versa.  CPU units\n+   in the string are separated by commas.  For example, it is useful\n+   for description CPU with fully pipelined floating point functional\n+   unit which can execute simultaneously only single floating point\n+   insns or only double floating point insns.  All CPU functional\n+   units in a set should belong the same automaton.  */\n+DEF_RTL_EXPR(EXCLUSION_SET, \"exclusion_set\", \"ss\", 'x')\n+\n+/* (presence_set string string) means that each CPU functional unit in\n+   the first string can not be reserved unless at least one of units\n+   whose names are in the second string is reserved.  This is an\n+   asymmetric relation.  CPU units in the string are separated by\n+   commas.  For example, it is useful for description that slot1 is\n+   reserved after slot0 reservation for VLIW processor.  All CPU\n+   functional units in a set should belong the same automaton.  */\n+DEF_RTL_EXPR(PRESENCE_SET, \"presence_set\", \"ss\", 'x')\n+\n+/* (absence_set string string) means that each CPU functional unit in\n+   the first string can not be reserved only if each unit whose name\n+   is in the second string is not reserved.  This is an asymmetric\n+   relation (actually exclusion set is analogous to this one but it is\n+   symmetric).  CPU units in the string are separated by commas.  For\n+   example, it is useful for description that slot0 can not be\n+   reserved after slot1 or slot2 reservation for VLIW processor.  All\n+   CPU functional units in a set should belong the same automaton.  */\n+DEF_RTL_EXPR(ABSENCE_SET, \"absence_set\", \"ss\", 'x')\n+\n+/* (define_bypass number out_insn_names in_insn_names) names bypass\n+   with given latency (the first number) from insns given by the first\n+   string (see define_insn_reservation) into insns given by the second\n+   string.  Insn names in the strings are separated by commas.  The\n+   third operand is optional name of function which is additional\n+   guard for the bypass.  The function will get the two insns as\n+   parameters.  If the function returns zero the bypass will be\n+   ignored for this case.  Additional guard is necessary to recognize\n+   complicated bypasses, e.g. when consumer is load address.  */\n+DEF_RTL_EXPR(DEFINE_BYPASS, \"define_bypass\", \"issS\", 'x')\n+\n+/* (define_automaton string) describes names of automata generated and\n+   used for pipeline hazards recognition.  The names are separated by\n+   comma.  Actually it is possibly to generate the single automaton\n+   but unfortunately it can be very large.  If we use more one\n+   automata, the summary size of the automata usually is less than the\n+   single one.  The automaton name is used in define_cpu_unit and\n+   define_query_cpu_unit.  All automata should have unique names.  */\n+DEF_RTL_EXPR(DEFINE_AUTOMATON, \"define_automaton\", \"s\", 'x')\n+\n+/* (automata_option string) describes option for generation of\n+   automata.  Currently there are the following options:\n+\n+   o \"no-minimization\" which makes no minimization of automata.  This\n+     is only worth to do when we are going to query CPU functional\n+     unit reservations in an automaton state.\n+\n+   o \"w\" which means generation of file describing the result\n+     automaton.  The file can be used for the description verification.\n+\n+   o \"ndfa\" which makes nondeterministic finite state automata.  */\n+DEF_RTL_EXPR(AUTOMATA_OPTION, \"automata_option\", \"s\", 'x')\n+\n+/* (define_reservation string string) names reservation (the first\n+   string) of cpu functional units (the 2nd string).  Sometimes unit\n+   reservations for different insns contain common parts.  In such\n+   case, you can describe common part and use its name (the 1st\n+   parameter) in regular expression in define_insn_reservation.  All\n+   define_reservations, define_cpu_units, and define_query_cpu_units\n+   should have unique names which may not be \"nothing\".  */\n+DEF_RTL_EXPR(DEFINE_RESERVATION, \"define_reservation\", \"ss\", 'x')\n+\n+/* (define_insn_reservation name default_latency condition regexpr)\n+   describes reservation of cpu functional units (the 3nd operand) for\n+   instruction which is selected by the condition (the 2nd parameter).\n+   The first parameter is used for output of debugging information.\n+   The reservations are described by a regular expression according\n+   the following syntax:\n+\n+       regexp = regexp \",\" oneof\n+              | oneof\n+\n+       oneof = oneof \"|\" allof\n+             | allof\n+\n+       allof = allof \"+\" repeat\n+             | repeat\n+ \n+       repeat = element \"*\" number\n+              | element\n+\n+       element = cpu_function_unit_name\n+               | reservation_name\n+               | result_name\n+               | \"nothing\"\n+               | \"(\" regexp \")\"\n+\n+       1. \",\" is used for describing start of the next cycle in\n+       reservation.\n+\n+       2. \"|\" is used for describing the reservation described by the\n+       first regular expression *or* the reservation described by the\n+       second regular expression *or* etc.\n+\n+       3. \"+\" is used for describing the reservation described by the\n+       first regular expression *and* the reservation described by the\n+       second regular expression *and* etc.\n+\n+       4. \"*\" is used for convinience and simply means sequence in\n+       which the regular expression are repeated NUMBER times with\n+       cycle advancing (see \",\").\n+\n+       5. cpu functional unit name which means its reservation.\n+\n+       6. reservation name -- see define_reservation.\n+\n+       7. string \"nothing\" means no units reservation.  */\n+\n+DEF_RTL_EXPR(DEFINE_INSN_RESERVATION, \"define_insn_reservation\", \"sies\", 'x')\n+\n /* ----------------------------------------------------------------------\n    Expressions used for insn attributes.  These also do not appear in\n    actual rtl code in the compiler."}, {"sha": "453592916bcbbecdad2d17d49d50adab55c69ee2", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -130,11 +130,9 @@ struct rtx_def\n   /* 1 in an INSN if it can alter flow of control\n      within this function.\n      MEM_KEEP_ALIAS_SET_P in a MEM.\n-     LINK_COST_ZERO in an INSN_LIST.\n      SET_IS_RETURN_P in a SET.  */\n   unsigned int jump : 1;\n-  /* 1 in an INSN if it can call another function.\n-     LINK_COST_FREE in an INSN_LIST.  */\n+  /* 1 in an INSN if it can call another function.  */\n   unsigned int call : 1;\n   /* 1 in a REG if value of this expression will never change during\n      the current function, even though it is not manifestly constant.\n@@ -983,16 +981,6 @@ do {\t\t\t\t\t\t\\\n    with the preceding insn.  */\n #define SCHED_GROUP_P(INSN) ((INSN)->in_struct)\n \n-/* During sched, for the LOG_LINKS of an insn, these cache the adjusted\n-   cost of the dependence link.  The cost of executing an instruction\n-   may vary based on how the results are used.  LINK_COST_ZERO is 1 when\n-   the cost through the link varies and is unchanged (i.e., the link has\n-   zero additional cost).  LINK_COST_FREE is 1 when the cost through the\n-   link is zero (i.e., the link makes the cost free).  In other cases,\n-   the adjustment to the cost is recomputed each time it is needed.  */\n-#define LINK_COST_ZERO(X) ((X)->jump)\n-#define LINK_COST_FREE(X) ((X)->call)\n-\n /* For a SET rtx, SET_DEST is the place that is set\n    and SET_SRC is the value it is set to.  */\n #define SET_DEST(RTX) XC2EXP(RTX, 0, SET, CLOBBER)"}, {"sha": "2b18c28badc9647579f6f783d8c3d383ad032c6b", "filename": "gcc/sched-int.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -20,6 +20,9 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n+/* Pointer to data describing the current DFA state.  */\n+extern state_t curr_state;\n+\n /* Forward declaration.  */\n struct ready_list;\n \n@@ -184,7 +187,7 @@ struct haifa_insn_data\n   int dep_count;\n \n   /* An encoding of the blockage range function.  Both unit and range\n-     are coded.  */\n+     are coded.  This member is used only for old pipeline interface.  */\n   unsigned int blockage;\n \n   /* Number of instructions referring to this insn.  */\n@@ -196,7 +199,8 @@ struct haifa_insn_data\n \n   short cost;\n \n-  /* An encoding of the function units used.  */\n+  /* An encoding of the function units used.  This member is used only\n+     for old pipeline interface.  */\n   short units;\n \n   /* This weight is an estimation of the insn's contribution to"}, {"sha": "0d41ec77dc755a4df244a4ce16f2a1067830f920", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 76, "deletions": 23, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -62,6 +62,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"recog.h\"\n #include \"cfglayout.h\"\n #include \"sched-int.h\"\n+#include \"target.h\"\n \n /* Define when we want to do count REG_DEAD notes before and after scheduling\n    for sanity checking.  We can't do that when conditional execution is used,\n@@ -2057,7 +2058,14 @@ init_ready_list (ready)\n \n \t    if (!CANT_MOVE (insn)\n \t\t&& (!IS_SPECULATIVE_INSN (insn)\n-\t\t    || (insn_issue_delay (insn) <= 3\n+\t\t    || ((((!targetm.sched.use_dfa_pipeline_interface\n+\t\t\t   || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+\t\t\t  && insn_issue_delay (insn) <= 3)\n+\t\t\t || (targetm.sched.use_dfa_pipeline_interface\n+\t\t\t     && (*targetm.sched.use_dfa_pipeline_interface) ()\n+\t\t\t     && (recog_memoized (insn) < 0\n+\t\t\t         || min_insn_conflict_delay (curr_state,\n+\t\t\t\t\t\t\t     insn, insn) <= 3)))\n \t\t\t&& check_live (insn, bb_src)\n \t\t\t&& is_exception_free (insn, bb_src, target_bb))))\n \t      {\n@@ -2165,7 +2173,15 @@ new_ready (next)\n       && (!IS_VALID (INSN_BB (next))\n \t  || CANT_MOVE (next)\n \t  || (IS_SPECULATIVE_INSN (next)\n-\t      && (insn_issue_delay (next) > 3\n+\t      && (0\n+\t\t  || (targetm.sched.use_dfa_pipeline_interface\n+\t\t      && (*targetm.sched.use_dfa_pipeline_interface) ()\n+\t\t      && recog_memoized (next) >= 0\n+\t\t      && min_insn_conflict_delay (curr_state, next,\n+\t\t\t\t\t\t  next) > 3)\n+\t\t  || ((!targetm.sched.use_dfa_pipeline_interface\n+\t\t       || !(*targetm.sched.use_dfa_pipeline_interface) ())\n+\t\t      && insn_issue_delay (next) > 3)\n \t\t  || !check_live (next, INSN_BB (next))\n \t\t  || !is_exception_free (next, INSN_BB (next), target_bb)))))\n     return 0;\n@@ -2589,14 +2605,27 @@ debug_dependencies ()\n \t  fprintf (sched_dump, \"\\n;;   --- Region Dependences --- b %d bb %d \\n\",\n \t\t   BB_TO_BLOCK (bb), bb);\n \n-\t  fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%11s%6s\\n\",\n-\t  \"insn\", \"code\", \"bb\", \"dep\", \"prio\", \"cost\", \"blockage\", \"units\");\n-\t  fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%11s%6s\\n\",\n-\t  \"----\", \"----\", \"--\", \"---\", \"----\", \"----\", \"--------\", \"-----\");\n+\t  if (targetm.sched.use_dfa_pipeline_interface\n+\t      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+\t    {\n+\t      fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%14s\\n\",\n+\t\t       \"insn\", \"code\", \"bb\", \"dep\", \"prio\", \"cost\",\n+\t\t       \"reservation\");\n+\t      fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%14s\\n\",\n+\t\t       \"----\", \"----\", \"--\", \"---\", \"----\", \"----\",\n+\t\t       \"-----------\");\n+\t    }\n+\t  else\n+\t    {\n+\t      fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%11s%6s\\n\",\n+\t      \"insn\", \"code\", \"bb\", \"dep\", \"prio\", \"cost\", \"blockage\", \"units\");\n+\t      fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%11s%6s\\n\",\n+\t      \"----\", \"----\", \"--\", \"---\", \"----\", \"----\", \"--------\", \"-----\");\n+\t    }\n+\n \t  for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n \t    {\n \t      rtx link;\n-\t      int unit, range;\n \n \t      if (! INSN_P (insn))\n \t\t{\n@@ -2616,22 +2645,46 @@ debug_dependencies ()\n \t\t  continue;\n \t\t}\n \n-\t      unit = insn_unit (insn);\n-\t      range = (unit < 0\n-\t\t || function_units[unit].blockage_range_function == 0) ? 0 :\n-\t\tfunction_units[unit].blockage_range_function (insn);\n-\t      fprintf (sched_dump,\n-\t\t       \";;   %s%5d%6d%6d%6d%6d%6d  %3d -%3d   \",\n-\t\t       (SCHED_GROUP_P (insn) ? \"+\" : \" \"),\n-\t\t       INSN_UID (insn),\n-\t\t       INSN_CODE (insn),\n-\t\t       INSN_BB (insn),\n-\t\t       INSN_DEP_COUNT (insn),\n-\t\t       INSN_PRIORITY (insn),\n-\t\t       insn_cost (insn, 0, 0),\n-\t\t       (int) MIN_BLOCKAGE_COST (range),\n-\t\t       (int) MAX_BLOCKAGE_COST (range));\n-\t      insn_print_units (insn);\n+\t      if (targetm.sched.use_dfa_pipeline_interface\n+\t\t  && (*targetm.sched.use_dfa_pipeline_interface) ())\n+\t\t{\n+\t\t  fprintf (sched_dump,\n+\t\t\t   \";;   %s%5d%6d%6d%6d%6d%6d   \",\n+\t\t\t   (SCHED_GROUP_P (insn) ? \"+\" : \" \"),\n+\t\t\t   INSN_UID (insn),\n+\t\t\t   INSN_CODE (insn),\n+\t\t\t   INSN_BB (insn),\n+\t\t\t   INSN_DEP_COUNT (insn),\n+\t\t\t   INSN_PRIORITY (insn),\n+\t\t\t   insn_cost (insn, 0, 0));\n+\t\t  \n+\t\t  if (recog_memoized (insn) < 0)\n+\t\t    fprintf (sched_dump, \"nothing\");\n+\t\t  else\n+\t\t    print_reservation (sched_dump, insn);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  int unit = insn_unit (insn);\n+\t\t  int range\n+\t\t    = (unit < 0\n+\t\t       || function_units[unit].blockage_range_function == 0\n+\t\t       ? 0\n+\t\t       : function_units[unit].blockage_range_function (insn));\n+\t\t  fprintf (sched_dump,\n+\t\t\t   \";;   %s%5d%6d%6d%6d%6d%6d  %3d -%3d   \",\n+\t\t\t   (SCHED_GROUP_P (insn) ? \"+\" : \" \"),\n+\t\t\t   INSN_UID (insn),\n+\t\t\t   INSN_CODE (insn),\n+\t\t\t   INSN_BB (insn),\n+\t\t\t   INSN_DEP_COUNT (insn),\n+\t\t\t   INSN_PRIORITY (insn),\n+\t\t\t   insn_cost (insn, 0, 0),\n+\t\t\t   (int) MIN_BLOCKAGE_COST (range),\n+\t\t\t   (int) MAX_BLOCKAGE_COST (range));\n+\t\t  insn_print_units (insn);\n+\t\t}\n+\n \t      fprintf (sched_dump, \"\\t: \");\n \t      for (link = INSN_DEPEND (insn); link; link = XEXP (link, 1))\n \t\tfprintf (sched_dump, \"%d \", INSN_UID (XEXP (link, 0)));"}, {"sha": "d3e8472b3be96db0058ff633ccfbf71ac326e08e", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -31,14 +31,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"basic-block.h\"\n #include \"insn-attr.h\"\n #include \"sched-int.h\"\n+#include \"target.h\"\n \n #ifdef INSN_SCHEDULING\n /* target_units bitmask has 1 for each unit in the cpu.  It should be\n    possible to compute this variable from the machine description.\n    But currently it is computed by examining the insn list.  Since\n    this is only needed for visualization, it seems an acceptable\n    solution.  (For understanding the mapping of bits to units, see\n-   definition of function_units[] in \"insn-attrtab.c\".)  */\n+   definition of function_units[] in \"insn-attrtab.c\".)  The scheduler\n+   using only DFA description should never use the following variable.  */\n \n static int target_units = 0;\n \n@@ -122,6 +124,14 @@ get_visual_tbl_length ()\n   int n, n1;\n   char *s;\n \n+  if (targetm.sched.use_dfa_pipeline_interface\n+      && (*targetm.sched.use_dfa_pipeline_interface) ())\n+    {\n+      visual_tbl_line_length = 1;\n+      return 1; /* Can't return 0 because that will cause problems\n+                   with alloca.  */\n+    }\n+\n   /* Compute length of one field in line.  */\n   s = (char *) alloca (INSN_LEN + 6);\n   sprintf (s, \"  %33s\", \"uname\");\n@@ -815,7 +825,8 @@ print_insn (buf, x, verbose)\n     }\n }\t\t\t\t/* print_insn */\n \n-/* Print visualization debugging info.  */\n+/* Print visualization debugging info.  The scheduler using only DFA\n+   description should never use the following function.  */\n \n void\n print_block_visualization (s)"}, {"sha": "7d287a76b50dd1e48dc8fb8d9712f035dc9d62b8", "filename": "gcc/target-def.h", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -145,16 +145,33 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_SCHED_REORDER 0\n #define TARGET_SCHED_REORDER2 0\n #define TARGET_SCHED_CYCLE_DISPLAY 0\n-\n-#define TARGET_SCHED\t{TARGET_SCHED_ADJUST_COST,\t\\\n-\t\t\t TARGET_SCHED_ADJUST_PRIORITY,\t\\\n-\t\t\t TARGET_SCHED_ISSUE_RATE,\t\\\n-\t\t\t TARGET_SCHED_VARIABLE_ISSUE,\t\\\n-\t\t\t TARGET_SCHED_INIT,\t\t\\\n-\t\t\t TARGET_SCHED_FINISH,\t\t\\\n-\t\t\t TARGET_SCHED_REORDER,\t\t\\\n-\t\t\t TARGET_SCHED_REORDER2,\t\t\\\n-\t\t\t TARGET_SCHED_CYCLE_DISPLAY}\n+#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE 0\n+#define TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN 0\n+#define TARGET_SCHED_DFA_PRE_CYCLE_INSN 0\n+#define TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN 0\n+#define TARGET_SCHED_DFA_POST_CYCLE_INSN 0\n+#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD 0\n+#define TARGET_SCHED_INIT_DFA_BUBBLES 0\n+#define TARGET_SCHED_DFA_BUBBLE 0\n+\n+#define TARGET_SCHED\t\t\t\t\t\t\\\n+  {TARGET_SCHED_ADJUST_COST,\t\t\t\t\t\\\n+   TARGET_SCHED_ADJUST_PRIORITY,\t\t\t\t\\\n+   TARGET_SCHED_ISSUE_RATE,\t\t\t\t\t\\\n+   TARGET_SCHED_VARIABLE_ISSUE,\t\t\t\t\t\\\n+   TARGET_SCHED_INIT,\t\t\t\t\t\t\\\n+   TARGET_SCHED_FINISH,\t\t\t\t\t\t\\\n+   TARGET_SCHED_REORDER,\t\t\t\t\t\\\n+   TARGET_SCHED_REORDER2,\t\t\t\t\t\\\n+   TARGET_SCHED_CYCLE_DISPLAY,\t\t\t\t\t\\\n+   TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE,\t\t\t\\\n+   TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN,\t\t\t\\\n+   TARGET_SCHED_DFA_PRE_CYCLE_INSN,\t\t\t\t\\\n+   TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN,\t\t\t\\\n+   TARGET_SCHED_DFA_POST_CYCLE_INSN,\t\t\t\t\\\n+   TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD,\t\t\\\n+   TARGET_SCHED_INIT_DFA_BUBBLES,\t\t\t\t\\\n+   TARGET_SCHED_DFA_BUBBLE}\n \n /* All in tree.c.  */\n #define TARGET_MERGE_DECL_ATTRIBUTES merge_decl_attributes"}, {"sha": "6d8103e1930558b2018790db79942801b6119459", "filename": "gcc/target.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae15c9379dda2310d8e8af569c7888a9c7909ca/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=fae15c9379dda2310d8e8af569c7888a9c7909ca", "patch": "@@ -136,6 +136,47 @@ struct gcc_target\n        insn in the new chain we're building.  Returns a new LAST.\n        The default is to do nothing.  */\n     rtx (* cycle_display) PARAMS ((int clock, rtx last));\n+    /* The following member value is a pointer to a function returning\n+       nonzero if we should use DFA based scheduling.  The default is\n+       to use the old pipeline scheduler.  */\n+    int (* use_dfa_pipeline_interface) PARAMS ((void));\n+    /* The values of all the following members are used only for the\n+       DFA based scheduler: */\n+    /* The values of the following four members are pointers to\n+       functions used to simplify the automaton descriptions.\n+       dfa_pre_cycle_insn and dfa_post_cycle_insn give functions\n+       returning insns which are used to change the pipeline hazard\n+       recognizer state when the new simulated processor cycle\n+       correspondingly starts and finishes.  The function defined by\n+       init_dfa_pre_cycle_insn and init_dfa_post_cycle_insn are used\n+       to initialize the corresponding insns.  The default values of\n+       the memebers result in not changing the automaton state when\n+       the new simulated processor cycle correspondingly starts and\n+       finishes.  */\n+    void (* init_dfa_pre_cycle_insn) PARAMS ((void));\n+    rtx (* dfa_pre_cycle_insn) PARAMS ((void));\n+    void (* init_dfa_post_cycle_insn) PARAMS ((void));\n+    rtx (* dfa_post_cycle_insn) PARAMS ((void));\n+    /* The following member value is a pointer to a function returning value\n+       which defines how many insns in queue `ready' will we try for\n+       multi-pass scheduling.  if the member value is nonzero and the\n+       function returns positive value, the DFA based scheduler will make\n+       multi-pass scheduling for the first cycle.  In other words, we will\n+       try to choose ready insn which permits to start maximum number of\n+       insns on the same cycle.  */\n+    int (* first_cycle_multipass_dfa_lookahead) PARAMS ((void));\n+    /* The values of the following members are pointers to functions\n+       used to improve the first cycle multipass scheduling by\n+       inserting nop insns.  dfa_scheduler_bubble gives a function\n+       returning a nop insn with given index.  The indexes start with\n+       zero.  The function should return NULL if there are no more nop\n+       insns with indexes greater than given index.  To initialize the\n+       nop insn the function given by member\n+       init_dfa_scheduler_bubbles is used.  The default values of the\n+       members result in not inserting nop insns during the multipass\n+       scheduling.  */\n+    void (* init_dfa_bubbles) PARAMS ((void));\n+    rtx (* dfa_bubble) PARAMS ((int));\n   } sched;\n \n   /* Given two decls, merge their attributes and return the result.  */"}]}