{"sha": "7a208c0b6726d7b48b7c78ef8ce91b3f279ec228", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2EyMDhjMGI2NzI2ZDdiNDhiN2M3OGVmOGNlOTFiM2YyNzllYzIyOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-09T21:28:52Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-09T21:28:52Z"}, "message": "(scan_decls): Handle declarations with multiple comma-separated\ndeclarators.\n\nFrom-SVN: r9912", "tree": {"sha": "a8f7bf11b13480d972c6aea77d35b516ef580646", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8f7bf11b13480d972c6aea77d35b516ef580646"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a208c0b6726d7b48b7c78ef8ce91b3f279ec228", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a208c0b6726d7b48b7c78ef8ce91b3f279ec228", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a208c0b6726d7b48b7c78ef8ce91b3f279ec228", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a208c0b6726d7b48b7c78ef8ce91b3f279ec228/comments", "author": null, "committer": null, "parents": [{"sha": "37811a734e0548dcc1d24e695db5a153ca42c8ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37811a734e0548dcc1d24e695db5a153ca42c8ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37811a734e0548dcc1d24e695db5a153ca42c8ee"}], "stats": {"total": 117, "additions": 84, "deletions": 33}, "files": [{"sha": "cc44a75db6c65ca93cd2bea35857836143c695c1", "filename": "gcc/scan-decls.c", "status": "modified", "additions": 84, "deletions": 33, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a208c0b6726d7b48b7c78ef8ce91b3f279ec228/gcc%2Fscan-decls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a208c0b6726d7b48b7c78ef8ce91b3f279ec228/gcc%2Fscan-decls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan-decls.c?ref=7a208c0b6726d7b48b7c78ef8ce91b3f279ec228", "patch": "@@ -1,5 +1,5 @@\n /* scan-decls.c - Extracts declarations from cpp output.\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1995 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -53,8 +53,26 @@ skip_to_closing_brace (pfile)\n }\n \n /* This function scans a C source file (actually, the output of cpp),\n-   reading from FP.  It looks for function declarations, and certain\n-   other interesting sequences (external variables and macros).  */\n+   reading from FP.  It looks for function declarations, and\n+   external variable declarations.  \n+\n+   The following grammar (as well as some extra stuff) is recognized:\n+\n+   declaration:\n+     (decl-specifier)* declarator (\",\" declarator)* \";\"\n+   decl-specifier:\n+     identifier\n+     keyword\n+     extern \"C\"\n+   declarator:\n+     (ptr-operator)* dname [ \"(\" argument-declaration-list \")\" ]\n+   ptr-operator:\n+     (\"*\" | \"&\") (\"const\" | \"volatile\")*\n+   dname:\n+     identifier\n+\n+Here dname is the actual name being declared.\n+*/\n \n int\n scan_decls (pfile, argc, argv)\n@@ -64,10 +82,13 @@ scan_decls (pfile, argc, argv)\n {\n   int saw_extern, saw_inline;\n   int old_written;\n+  /* If declarator_start is non-zero, it marks the start of the current\n+     declarator.  If it is zero, we are either still parsing the\n+     decl-specs, or prev_id_start marks the start of the declarator. */\n+  int declarator_start;\n   int prev_id_start, prev_id_end;\n   enum cpp_token token;\n \n-\n  new_statement:\n   CPP_SET_WRITTEN (pfile, 0);\n   token = cpp_get_token (pfile);\n@@ -96,40 +117,18 @@ scan_decls (pfile, argc, argv)\n     goto new_statement;\n   if (token != CPP_NAME)\n     goto new_statement;\n-  if (strcmp (pfile->token_buffer, \"inline\") == 0)\n-     {\n-      saw_inline = 1;\n-      CPP_SET_WRITTEN (pfile, 0);\n-      token = cpp_get_non_space_token (pfile);\n-    }\n-  if (strcmp (pfile->token_buffer, \"extern\") == 0)\n-    {\n-      saw_extern = 1;\n-      CPP_SET_WRITTEN (pfile, 0);\n-      token = cpp_get_non_space_token (pfile);\n-      if (token == CPP_STRING\n-\t  && strcmp (pfile->token_buffer, \"\\\"C\\\"\") == 0)\n-\t{\n-\t  CPP_SET_WRITTEN (pfile, 0);\n-\t  current_extern_C = 1;\n-\t  token = cpp_get_non_space_token (pfile);\n-\t  if (token == CPP_LPAREN)\n-\t    {\n-\t      brace_nesting++;\n-\t      extern_C_braces[extern_C_braces_length++] = brace_nesting;\n-\t      goto new_statement;\n-\t    }\n-\t  token = cpp_get_non_space_token (pfile);\n-\t}\n-    }\n-  prev_id_start = NULL;\n+\n+  prev_id_start = 0;\n+  declarator_start = 0;\n   for (;;)\n     {\n       int start_written = CPP_WRITTEN (pfile);\n       token = cpp_get_token (pfile);\n+    handle_token:\n       switch (token)\n \t{\n \tcase CPP_LPAREN:\n+\t  /* Looks like this is the start of a formal parameter list. */\n \t  if (prev_id_start)\n \t    {\n \t      int nesting = 1;\n@@ -168,9 +167,18 @@ scan_decls (pfile, argc, argv)\n \t\t  skip_to_closing_brace (pfile);\n \t\t  goto new_statement;\n \t\t}\n-\t      goto handle_statement;\n+\t      goto maybe_handle_comma;\n \t    }\n \t  break;\n+\tcase CPP_OTHER:\n+\t  if (CPP_WRITTEN (pfile) == start_written + 1\n+\t      && (CPP_PWRITTEN (pfile)[-1] == '*'\n+\t\t  || CPP_PWRITTEN (pfile)[-1] == '&'))\n+\t    declarator_start = start_written;\n+\t  else\n+\t    goto handle_statement;\n+\t  break;\n+\tcase CPP_COMMA:\n \tcase CPP_SEMICOLON:\n \t  if (prev_id_start && saw_extern)\n \t    {\n@@ -179,8 +187,48 @@ scan_decls (pfile, argc, argv)\n \t\t\t\t pfile->token_buffer,\n \t\t\t\t prev_id_start);\n \t    }\n-\t  goto new_statement;\n+\t  /* ... fall through ... */\n+\tmaybe_handle_comma:\n+\t  if (token != CPP_COMMA)\n+\t    goto new_statement;\n+\thandle_comma:\n+\t  /* Handle multiple declarators in a single declaration,\n+\t     as in:  extern char *strcpy (), *strcat (), ... ; */\n+\t  if (declarator_start == 0)\n+\t    declarator_start = prev_id_start;\n+\t  CPP_SET_WRITTEN (pfile, declarator_start);\n+\t  break;\n \tcase CPP_NAME:\n+\t  /* \"inline\" and \"extern\" are recognized but skipped */\n+\t  if (strcmp (pfile->token_buffer, \"inline\") == 0)\n+\t    {\n+\t      saw_inline = 1;\n+\t      CPP_SET_WRITTEN (pfile, start_written);\n+\t    }\n+\t  if (strcmp (pfile->token_buffer, \"extern\") == 0)\n+\t    {\n+\t      saw_extern = 1;\n+\t      CPP_SET_WRITTEN (pfile, start_written);\n+\t      token = cpp_get_non_space_token (pfile);\n+\t      if (token == CPP_STRING\n+\t\t  && strcmp (pfile->token_buffer, \"\\\"C\\\"\") == 0)\n+\t\t{\n+\t\t  CPP_SET_WRITTEN (pfile, start_written);\n+\t\t  current_extern_C = 1;\n+\t\t  token = cpp_get_non_space_token (pfile);\n+\t\t  if (token == CPP_LBRACE)\n+\t\t    {\n+\t\t      brace_nesting++;\n+\t\t      extern_C_braces[extern_C_braces_length++]\n+\t\t\t= brace_nesting;\n+\t\t      goto new_statement;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tgoto handle_token;\n+\t      break;\n+\t    }\n+\t  /* This may be the name of a variable or function. */\n \t  prev_id_start = start_written;\n \t  prev_id_end = CPP_WRITTEN (pfile);\n \t  break;\n@@ -192,6 +240,9 @@ scan_decls (pfile, argc, argv)\n \t  goto new_statement;  /* handle_statement? */\n \t  \n \tcase CPP_HSPACE:  case CPP_VSPACE:  case CPP_COMMENT:  case CPP_POP:\n+\t  /* Skip initial white space. */\n+\t  if (start_written == 0)\n+\t    CPP_SET_WRITTEN (pfile, 0);\n \t  break;\n \n \t default:"}]}