{"sha": "93330ea10a357abf2055c883935abf71102cbbec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMzMzBlYTEwYTM1N2FiZjIwNTVjODgzOTM1YWJmNzExMDJjYmJlYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-09-12T18:00:49Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-09-12T18:00:49Z"}, "message": "i386.c (ix86_split_ashldi): Special case op1 as one or minus one.\n\n        * config/i386/i386.c (ix86_split_ashldi): Special case op1 as one\n        or minus one.\n        (ix86_split_ashrdi, ix86_split_lshrdi): Clean up conditions for\n        post-reload, and scratch NULL.\n        * config/i386/i386.md (testqi_1): Use FLAGS_REG name.\n        (x86_shift_adj_2): Use ix86_expand_clear.\n        (ashldi3): Remove CMOVE expansion difference.\n        (ashldi3_1): Remove.\n        (*ashldi3_1): Rename from *ashldi3_2.  Use reg_or_pm1_operand and\n        add constraints for immediates.  New peephole for split-with-temp.\n        Run splitter after peep2 pass.\n        (ashrdi3, ashrdi3_1, ashrdi3_2): Similarly.\n        (lshrdi3, lshrdi3_1, lshrdi3_2): Similarly.\n        (setcc_2): Rename with *.\n        * config/i386/predicates.md (reg_or_pm1_operand): New.\n        (ashldi_input_operand): New.\n\nFrom-SVN: r87398", "tree": {"sha": "47f88fcf83667c18889732010296a8f09cd360c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47f88fcf83667c18889732010296a8f09cd360c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93330ea10a357abf2055c883935abf71102cbbec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93330ea10a357abf2055c883935abf71102cbbec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93330ea10a357abf2055c883935abf71102cbbec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93330ea10a357abf2055c883935abf71102cbbec/comments", "author": null, "committer": null, "parents": [{"sha": "21076c8ec342f7610a684e60bee243f111a2d0fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21076c8ec342f7610a684e60bee243f111a2d0fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21076c8ec342f7610a684e60bee243f111a2d0fd"}], "stats": {"total": 310, "additions": 170, "deletions": 140}, "files": [{"sha": "578495b549237000a8d689f4cfc7fd17886f8a20", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93330ea10a357abf2055c883935abf71102cbbec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93330ea10a357abf2055c883935abf71102cbbec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93330ea10a357abf2055c883935abf71102cbbec", "patch": "@@ -1,3 +1,22 @@\n+2004-09-12  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.c (ix86_split_ashldi): Special case op1 as one\n+\tor minus one.\n+\t(ix86_split_ashrdi, ix86_split_lshrdi): Clean up conditions for\n+\tpost-reload, and scratch NULL.\n+\t* config/i386/i386.md (testqi_1): Use FLAGS_REG name.\n+\t(x86_shift_adj_2): Use ix86_expand_clear.\n+\t(ashldi3): Remove CMOVE expansion difference.\n+\t(ashldi3_1): Remove.\n+\t(*ashldi3_1): Rename from *ashldi3_2.  Use reg_or_pm1_operand and\n+\tadd constraints for immediates.  New peephole for split-with-temp.\n+\tRun splitter after peep2 pass.\n+\t(ashrdi3, ashrdi3_1, ashrdi3_2): Similarly.\n+\t(lshrdi3, lshrdi3_1, lshrdi3_2): Similarly.\n+\t(setcc_2): Rename with *.\n+\t* config/i386/predicates.md (reg_or_pm1_operand): New.\n+\t(ashldi_input_operand): New.\n+\n 2004-09-12  Richard Henderson  <rth@redhat.com\n \n \t* print-rtl.c (print_decl_name): New."}, {"sha": "c1911092419826ab67ff1416af65a620b362fbf7", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 77, "deletions": 32, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93330ea10a357abf2055c883935abf71102cbbec/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93330ea10a357abf2055c883935abf71102cbbec/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=93330ea10a357abf2055c883935abf71102cbbec", "patch": "@@ -10019,30 +10019,88 @@ ix86_split_ashldi (rtx *operands, rtx scratch)\n \t  emit_insn (gen_x86_shld_1 (high[0], low[0], GEN_INT (count)));\n \t  ix86_expand_ashlsi3_const (low[0], count);\n \t}\n+      return;\n     }\n-  else\n+\n+  split_di (operands, 1, low, high);\n+\n+  if (operands[1] == const1_rtx)\n     {\n-      if (!rtx_equal_p (operands[0], operands[1]))\n-\temit_move_insn (operands[0], operands[1]);\n+      /* Assuming we've chosen a QImode capable registers, then 1LL << N\n+\t can be done with two 32-bit shifts, no branches, no cmoves.  */\n+      if (ANY_QI_REG_P (low[0]) && ANY_QI_REG_P (high[0]))\n+\t{\n+\t  rtx s, d, flags = gen_rtx_REG (CCZmode, FLAGS_REG);\n \n-      split_di (operands, 1, low, high);\n+\t  ix86_expand_clear (low[0]);\n+\t  ix86_expand_clear (high[0]);\n+\t  emit_insn (gen_testqi_ccz_1 (operands[2], GEN_INT (32)));\n+\t  \n+\t  d = gen_lowpart (QImode, low[0]);\n+\t  d = gen_rtx_STRICT_LOW_PART (VOIDmode, d);\n+\t  s = gen_rtx_EQ (QImode, flags, const0_rtx);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, d, s));\n \n-      emit_insn (gen_x86_shld_1 (high[0], low[0], operands[2]));\n-      emit_insn (gen_ashlsi3 (low[0], low[0], operands[2]));\n+\t  d = gen_lowpart (QImode, high[0]);\n+\t  d = gen_rtx_STRICT_LOW_PART (VOIDmode, d);\n+\t  s = gen_rtx_NE (QImode, flags, const0_rtx);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, d, s));\n+\t}\n \n-      if (TARGET_CMOVE && (! no_new_pseudos || scratch))\n+      /* Otherwise, we can get the same results by manually performing\n+\t a bit extract operation on bit 5, and then performing the two\n+\t shifts.  The two methods of getting 0/1 into low/high are exactly\n+\t the same size.  Avoiding the shift in the bit extract case helps\n+\t pentium4 a bit; no one else seems to care much either way.  */\n+      else\n \t{\n-\t  if (! no_new_pseudos)\n-\t    scratch = force_reg (SImode, const0_rtx);\n+\t  rtx x;\n+\n+\t  if (TARGET_PARTIAL_REG_STALL && !optimize_size)\n+\t    x = gen_rtx_ZERO_EXTEND (SImode, operands[2]);\n \t  else\n-\t    emit_move_insn (scratch, const0_rtx);\n+\t    x = gen_lowpart (SImode, operands[2]);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, high[0], x));\n \n-\t  emit_insn (gen_x86_shift_adj_1 (high[0], low[0], operands[2],\n-\t\t\t\t\t  scratch));\n+\t  emit_insn (gen_lshrsi3 (high[0], high[0], GEN_INT (5)));\n+\t  emit_insn (gen_andsi3 (high[0], high[0], GEN_INT (1)));\n+\t  emit_move_insn (low[0], high[0]);\n+\t  emit_insn (gen_xorsi3 (low[0], low[0], GEN_INT (1)));\n \t}\n+\n+      emit_insn (gen_ashlsi3 (low[0], low[0], operands[2]));\n+      emit_insn (gen_ashlsi3 (high[0], high[0], operands[2]));\n+      return;\n+    }\n+\n+  if (operands[1] == constm1_rtx)\n+    {\n+      /* For -1LL << N, we can avoid the shld instruction, because we\n+\t know that we're shifting 0...31 ones into a -1.  */\n+      emit_move_insn (low[0], constm1_rtx);\n+      if (optimize_size)\n+        emit_move_insn (high[0], low[0]);\n       else\n-\temit_insn (gen_x86_shift_adj_2 (high[0], low[0], operands[2]));\n+\temit_move_insn (high[0], constm1_rtx);\n     }\n+  else\n+    {\n+      if (!rtx_equal_p (operands[0], operands[1]))\n+\temit_move_insn (operands[0], operands[1]);\n+\n+      split_di (operands, 1, low, high);\n+      emit_insn (gen_x86_shld_1 (high[0], low[0], operands[2]));\n+    }\n+\n+  emit_insn (gen_ashlsi3 (low[0], low[0], operands[2]));\n+\n+  if (TARGET_CMOVE && scratch)\n+    {\n+      ix86_expand_clear (scratch);\n+      emit_insn (gen_x86_shift_adj_1 (high[0], low[0], operands[2], scratch));\n+    }\n+  else\n+    emit_insn (gen_x86_shift_adj_2 (high[0], low[0], operands[2]));\n }\n \n void\n@@ -10066,15 +10124,8 @@ ix86_split_ashrdi (rtx *operands, rtx scratch)\n       else if (count >= 32)\n \t{\n \t  emit_move_insn (low[0], high[1]);\n-\n-\t  if (! reload_completed)\n-\t    emit_insn (gen_ashrsi3 (high[0], low[0], GEN_INT (31)));\n-\t  else\n-\t    {\n-\t      emit_move_insn (high[0], low[0]);\n-\t      emit_insn (gen_ashrsi3 (high[0], high[0], GEN_INT (31)));\n-\t    }\n-\n+\t  emit_move_insn (high[0], low[0]);\n+\t  emit_insn (gen_ashrsi3 (high[0], high[0], GEN_INT (31)));\n \t  if (count > 32)\n \t    emit_insn (gen_ashrsi3 (low[0], low[0], GEN_INT (count - 32)));\n \t}\n@@ -10096,10 +10147,8 @@ ix86_split_ashrdi (rtx *operands, rtx scratch)\n       emit_insn (gen_x86_shrd_1 (low[0], high[0], operands[2]));\n       emit_insn (gen_ashrsi3 (high[0], high[0], operands[2]));\n \n-      if (TARGET_CMOVE && (! no_new_pseudos || scratch))\n+      if (TARGET_CMOVE && scratch)\n \t{\n-\t  if (! no_new_pseudos)\n-\t    scratch = gen_reg_rtx (SImode);\n \t  emit_move_insn (scratch, high[0]);\n \t  emit_insn (gen_ashrsi3 (scratch, scratch, GEN_INT (31)));\n \t  emit_insn (gen_x86_shift_adj_1 (low[0], high[0], operands[2],\n@@ -10124,7 +10173,7 @@ ix86_split_lshrdi (rtx *operands, rtx scratch)\n       if (count >= 32)\n \t{\n \t  emit_move_insn (low[0], high[1]);\n-\t  emit_move_insn (high[0], const0_rtx);\n+\t  ix86_expand_clear (high[0]);\n \n \t  if (count > 32)\n \t    emit_insn (gen_lshrsi3 (low[0], low[0], GEN_INT (count - 32)));\n@@ -10148,13 +10197,9 @@ ix86_split_lshrdi (rtx *operands, rtx scratch)\n       emit_insn (gen_lshrsi3 (high[0], high[0], operands[2]));\n \n       /* Heh.  By reversing the arguments, we can reuse this pattern.  */\n-      if (TARGET_CMOVE && (! no_new_pseudos || scratch))\n+      if (TARGET_CMOVE && scratch)\n \t{\n-\t  if (! no_new_pseudos)\n-\t    scratch = force_reg (SImode, const0_rtx);\n-\t  else\n-\t    emit_move_insn (scratch, const0_rtx);\n-\n+\t  ix86_expand_clear (scratch);\n \t  emit_insn (gen_x86_shift_adj_1 (low[0], high[0], operands[2],\n \t\t\t\t\t  scratch));\n \t}"}, {"sha": "f2f3fbedbdfd19e06e9d3d44873dc6e1e3a8da74", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 63, "deletions": 108, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93330ea10a357abf2055c883935abf71102cbbec/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93330ea10a357abf2055c883935abf71102cbbec/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=93330ea10a357abf2055c883935abf71102cbbec", "patch": "@@ -1906,7 +1906,7 @@\n (define_split\n   [(set (match_operand:DI 0 \"push_operand\" \"\")\n         (match_operand:DI 1 \"immediate_operand\" \"\"))]\n-  \"TARGET_64BIT && (flow2_completed || (reload_completed && !flag_peephole2))\n+  \"TARGET_64BIT && (flag_peephole2 ? flow2_completed : reload_completed)\n    && !symbolic_operand (operands[1], DImode)\n    && !x86_64_immediate_operand (operands[1], DImode)\"\n   [(set (match_dup 0) (match_dup 1))\n@@ -2168,7 +2168,7 @@\n (define_split\n   [(set (match_operand:DI 0 \"memory_operand\" \"\")\n         (match_operand:DI 1 \"immediate_operand\" \"\"))]\n-  \"TARGET_64BIT && (flow2_completed || (reload_completed && !flag_peephole2))\n+  \"TARGET_64BIT && (flag_peephole2 ? flow2_completed : reload_completed)\n    && !symbolic_operand (operands[1], DImode)\n    && !x86_64_immediate_operand (operands[1], DImode)\"\n   [(set (match_dup 2) (match_dup 3))\n@@ -7924,7 +7924,7 @@\n   \"\")\n \n (define_insn \"*testqi_1\"\n-  [(set (reg 17)\n+  [(set (reg FLAGS_REG)\n         (compare (and:QI (match_operand:QI 0 \"nonimmediate_operand\" \"%!*a,q,qm,r\")\n \t\t\t (match_operand:QI 1 \"general_operand\" \"n,n,qn,n\"))\n \t\t (const_int 0)))]\n@@ -10623,20 +10623,11 @@\n ;; than 31.\n \n (define_expand \"ashldi3\"\n-  [(parallel [(set (match_operand:DI 0 \"shiftdi_operand\" \"\")\n-\t\t   (ashift:DI (match_operand:DI 1 \"shiftdi_operand\" \"\")\n-\t\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n+  [(set (match_operand:DI 0 \"shiftdi_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"ashldi_input_operand\" \"\")\n+\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-{\n-  if (!TARGET_64BIT && TARGET_CMOVE && ! immediate_operand (operands[2], QImode))\n-    {\n-      emit_insn (gen_ashldi3_1 (operands[0], operands[1], operands[2]));\n-      DONE;\n-    }\n-  ix86_expand_binary_operator (ASHIFT, DImode, operands);\n-  DONE;\n-})\n+  \"ix86_expand_binary_operator (ASHIFT, DImode, operands); DONE;\")\n \n (define_insn \"*ashldi3_1_rex64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,r\")\n@@ -10738,41 +10729,35 @@\n \t   (const_string \"ishift\")))\n    (set_attr \"mode\" \"DI\")])\n \n-(define_insn \"ashldi3_1\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"Jc\")))\n-   (clobber (match_scratch:SI 3 \"=&r\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_CMOVE\"\n-  \"#\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-(define_insn \"*ashldi3_2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"Jc\")))\n+(define_insn \"*ashldi3_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r,r\")\n+\t(ashift:DI (match_operand:DI 1 \"reg_or_pm1_operand\" \"n,0\")\n+\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"Jc,Jc\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"!TARGET_64BIT\"\n   \"#\"\n   [(set_attr \"type\" \"multi\")])\n \n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n-   (clobber (match_scratch:SI 3 \"\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_CMOVE && reload_completed\"\n+;; By default we don't ask for a scratch register, because when DImode\n+;; values are manipulated, registers are already at a premium.  But if\n+;; we have one handy, we won't turn it away.\n+(define_peephole2\n+  [(match_scratch:SI 3 \"r\")\n+   (parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t\t   (ashift:DI (match_operand:DI 1 \"nonmemory_operand\" \"\")\n+\t\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (reg:CC FLAGS_REG))])\n+   (match_dup 3)]\n+  \"!TARGET_64BIT && TARGET_CMOVE\"\n   [(const_int 0)]\n   \"ix86_split_ashldi (operands, operands[3]); DONE;\")\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"nonmemory_operand\" \"\")\n \t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && reload_completed\"\n+  \"!TARGET_64BIT && (flag_peephole2 ? flow2_completed : reload_completed)\"\n   [(const_int 0)]\n   \"ix86_split_ashldi (operands, NULL_RTX); DONE;\")\n \n@@ -10829,7 +10814,7 @@\n   JUMP_LABEL (tmp) = label;\n \n   emit_move_insn (operands[0], operands[1]);\n-  emit_move_insn (operands[1], const0_rtx);\n+  ix86_expand_clear (operands[1]);\n \n   emit_label (label);\n   LABEL_NUSES (label) = 1;\n@@ -11346,27 +11331,19 @@\n ;; See comment above `ashldi3' about how this works.\n \n (define_expand \"ashrdi3\"\n-  [(parallel [(set (match_operand:DI 0 \"shiftdi_operand\" \"\")\n-\t\t   (ashiftrt:DI (match_operand:DI 1 \"shiftdi_operand\" \"\")\n-\t\t\t\t(match_operand:QI 2 \"nonmemory_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n+  [(set (match_operand:DI 0 \"shiftdi_operand\" \"\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"shiftdi_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-{\n-  if (!TARGET_64BIT && TARGET_CMOVE && ! immediate_operand (operands[2], QImode))\n-    {\n-      emit_insn (gen_ashrdi3_1 (operands[0], operands[1], operands[2]));\n-      DONE;\n-    }\n-  ix86_expand_binary_operator (ASHIFTRT, DImode, operands);\n-  DONE;\n-})\n+  \"ix86_expand_binary_operator (ASHIFTRT, DImode, operands); DONE;\")\n \n-(define_insn \"ashrdi3_63_rex64\"\n+(define_insn \"*ashrdi3_63_rex64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=*d,rm\")\n \t(ashiftrt:DI (match_operand:DI 1 \"nonimmediate_operand\" \"*a,0\")\n \t\t     (match_operand:DI 2 \"const_int_operand\" \"i,i\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && INTVAL (operands[2]) == 63 && (TARGET_USE_CLTD || optimize_size)\n+  \"TARGET_64BIT && INTVAL (operands[2]) == 63\n+   && (TARGET_USE_CLTD || optimize_size)\n    && ix86_binary_operator_ok (ASHIFTRT, DImode, operands)\"\n   \"@\n    {cqto|cqo}\n@@ -11441,18 +11418,7 @@\n   [(set_attr \"type\" \"ishift\")\n    (set_attr \"mode\" \"DI\")])\n \n-\n-(define_insn \"ashrdi3_1\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"Jc\")))\n-   (clobber (match_scratch:SI 3 \"=&r\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_CMOVE\"\n-  \"#\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-(define_insn \"*ashrdi3_2\"\n+(define_insn \"*ashrdi3_1\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"Jc\")))\n@@ -11461,13 +11427,17 @@\n   \"#\"\n   [(set_attr \"type\" \"multi\")])\n \n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n-   (clobber (match_scratch:SI 3 \"\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_CMOVE && reload_completed\"\n+;; By default we don't ask for a scratch register, because when DImode\n+;; values are manipulated, registers are already at a premium.  But if\n+;; we have one handy, we won't turn it away.\n+(define_peephole2\n+  [(match_scratch:SI 3 \"r\")\n+   (parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t\t   (ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t        (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (reg:CC FLAGS_REG))])\n+   (match_dup 3)]\n+  \"!TARGET_64BIT && TARGET_CMOVE\"\n   [(const_int 0)]\n   \"ix86_split_ashrdi (operands, operands[3]); DONE;\")\n \n@@ -11476,7 +11446,7 @@\n \t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && reload_completed\"\n+  \"!TARGET_64BIT && (flag_peephole2 ? flow2_completed : reload_completed)\"\n   [(const_int 0)]\n   \"ix86_split_ashrdi (operands, NULL_RTX); DONE;\")\n \n@@ -11858,20 +11828,11 @@\n ;; See comment above `ashldi3' about how this works.\n \n (define_expand \"lshrdi3\"\n-  [(parallel [(set (match_operand:DI 0 \"shiftdi_operand\" \"\")\n-\t\t   (lshiftrt:DI (match_operand:DI 1 \"shiftdi_operand\" \"\")\n-\t\t\t        (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n+  [(set (match_operand:DI 0 \"shiftdi_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"shiftdi_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-{\n-  if (!TARGET_64BIT && TARGET_CMOVE && ! immediate_operand (operands[2], QImode))\n-    {\n-      emit_insn (gen_lshrdi3_1 (operands[0], operands[1], operands[2]));\n-      DONE;\n-    }\n-  ix86_expand_binary_operator (LSHIFTRT, DImode, operands);\n-  DONE;\n-})\n+  \"ix86_expand_binary_operator (LSHIFTRT, DImode, operands); DONE;\")\n \n (define_insn \"*lshrdi3_1_one_bit_rex64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n@@ -11937,17 +11898,7 @@\n   [(set_attr \"type\" \"ishift\")\n    (set_attr \"mode\" \"DI\")])\n \n-(define_insn \"lshrdi3_1\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"Jc\")))\n-   (clobber (match_scratch:SI 3 \"=&r\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_CMOVE\"\n-  \"#\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-(define_insn \"*lshrdi3_2\"\n+(define_insn \"*lshrdi3_1\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"Jc\")))\n@@ -11956,13 +11907,17 @@\n   \"#\"\n   [(set_attr \"type\" \"multi\")])\n \n-(define_split \n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n-   (clobber (match_scratch:SI 3 \"\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_CMOVE && reload_completed\"\n+;; By default we don't ask for a scratch register, because when DImode\n+;; values are manipulated, registers are already at a premium.  But if\n+;; we have one handy, we won't turn it away.\n+(define_peephole2\n+  [(match_scratch:SI 3 \"r\")\n+   (parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t\t   (lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t        (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (reg:CC FLAGS_REG))])\n+   (match_dup 3)]\n+  \"!TARGET_64BIT && TARGET_CMOVE\"\n   [(const_int 0)]\n   \"ix86_split_lshrdi (operands, operands[3]); DONE;\")\n \n@@ -11971,7 +11926,7 @@\n \t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && reload_completed\"\n+  \"!TARGET_64BIT && (flag_peephole2 ? flow2_completed : reload_completed)\"\n   [(const_int 0)]\n   \"ix86_split_lshrdi (operands, NULL_RTX); DONE;\")\n \n@@ -12840,7 +12795,7 @@\n   [(set_attr \"type\" \"setcc\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"setcc_2\"\n+(define_insn \"*setcc_2\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm\"))\n \t(match_operator:QI 1 \"ix86_comparison_operator\"\n \t  [(reg 17) (const_int 0)]))]"}, {"sha": "96be8b9bc67b79484ad28cab8096dfe3baca635f", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93330ea10a357abf2055c883935abf71102cbbec/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93330ea10a357abf2055c883935abf71102cbbec/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=93330ea10a357abf2055c883935abf71102cbbec", "patch": "@@ -553,12 +553,23 @@\n   return op == const1_rtx || op == constm1_rtx;\n })\n \n+;; True for registers, or 1 or -1.  Used to optimize double-word shifts.\n+(define_predicate \"reg_or_pm1_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"op == const1_rtx || op == constm1_rtx\"))))\n+\n ;; True if OP is acceptable as operand of DImode shift expander.\n (define_predicate \"shiftdi_operand\"\n   (if_then_else (match_test \"TARGET_64BIT\")\n     (match_operand 0 \"nonimmediate_operand\")\n     (match_operand 0 \"register_operand\")))\n \n+(define_predicate \"ashldi_input_operand\"\n+  (if_then_else (match_test \"TARGET_64BIT\")\n+    (match_operand 0 \"nonimmediate_operand\")\n+    (match_operand 0 \"reg_or_pm1_operand\")))\n+\n ;; Return true if OP is a vector load from the constant pool with just\n ;; the first element non-zero.\n (define_predicate \"zero_extended_scalar_load_operand\""}]}