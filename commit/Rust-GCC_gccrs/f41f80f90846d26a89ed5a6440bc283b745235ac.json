{"sha": "f41f80f90846d26a89ed5a6440bc283b745235ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQxZjgwZjkwODQ2ZDI2YTg5ZWQ1YTY0NDBiYzI4M2I3NDUyMzVhYw==", "commit": {"author": {"name": "Teresa Johnson", "email": "tejohnson@google.com", "date": "2013-04-29T13:22:46Z"}, "committer": {"name": "Teresa Johnson", "email": "tejohnson@gcc.gnu.org", "date": "2013-04-29T13:22:46Z"}, "message": "This patch fixes PR bootstrap/57077.\n\nThis patch fixes PR bootstrap/57077. Certain new uses of apply_probability\nare actually scaling the counts up, and the scale factor should not \nbe treated as a probability as the value may exceed REG_BR_PROB_BASE.\nOne example (from the PR) is when scaling counts up in LTO when merging\nprofiles. Another example I found when preparing the patch to use\nthe rounding divide in more places is when inlining COMDAT functions.\n\nAdd new helper function apply_scale that does the scaling without\nthe probability range check. I audited the new uses of apply_probability\nand changed the calls as appropriate.\n\n2013-04-29  Teresa Johnson  <tejohnson@google.com>\n\n\tPR bootstrap/57077\n\t* basic-block.h (apply_scale): New function.\n\t(apply_probability): Use apply_scale.\n\t* gimple-streamer-in.c (input_bb): Ditto.\n\t* lto-streamer-in.c (input_cfg): Ditto.\n\t* lto-cgraph.c (merge_profile_summaries): Ditto.\n\t* tree-optimize.c (execute_fixup_cfg): Ditto.\n\t* tree-inline.c (copy_bb): Update comment to use\n\tapply_scale.\n\t(copy_edges_for_bb): Ditto.\n\t(copy_cfg_body): Ditto.\n\nFrom-SVN: r198416", "tree": {"sha": "9daf54908866e15052bfcfc011bc4753b4b363fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9daf54908866e15052bfcfc011bc4753b4b363fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f41f80f90846d26a89ed5a6440bc283b745235ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f41f80f90846d26a89ed5a6440bc283b745235ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f41f80f90846d26a89ed5a6440bc283b745235ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f41f80f90846d26a89ed5a6440bc283b745235ac/comments", "author": {"login": "teresajohnson", "id": 20446403, "node_id": "MDQ6VXNlcjIwNDQ2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/20446403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/teresajohnson", "html_url": "https://github.com/teresajohnson", "followers_url": "https://api.github.com/users/teresajohnson/followers", "following_url": "https://api.github.com/users/teresajohnson/following{/other_user}", "gists_url": "https://api.github.com/users/teresajohnson/gists{/gist_id}", "starred_url": "https://api.github.com/users/teresajohnson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/teresajohnson/subscriptions", "organizations_url": "https://api.github.com/users/teresajohnson/orgs", "repos_url": "https://api.github.com/users/teresajohnson/repos", "events_url": "https://api.github.com/users/teresajohnson/events{/privacy}", "received_events_url": "https://api.github.com/users/teresajohnson/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "315bbd2e3c15dea3528259be2aee2876dec33843", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315bbd2e3c15dea3528259be2aee2876dec33843", "html_url": "https://github.com/Rust-GCC/gccrs/commit/315bbd2e3c15dea3528259be2aee2876dec33843"}], "stats": {"total": 68, "additions": 46, "deletions": 22}, "files": [{"sha": "1529dd37f14ada3b10694c9cea4a847698ef85bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41f80f90846d26a89ed5a6440bc283b745235ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41f80f90846d26a89ed5a6440bc283b745235ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f41f80f90846d26a89ed5a6440bc283b745235ac", "patch": "@@ -1,3 +1,17 @@\n+2013-04-29  Teresa Johnson  <tejohnson@google.com>\n+\n+\tPR bootstrap/57077\n+\t* basic-block.h (apply_scale): New function.\n+\t(apply_probability): Use apply_scale.\n+\t* gimple-streamer-in.c (input_bb): Ditto.\n+\t* lto-streamer-in.c (input_cfg): Ditto.\n+\t* lto-cgraph.c (merge_profile_summaries): Ditto.\n+\t* tree-optimize.c (execute_fixup_cfg): Ditto.\n+\t* tree-inline.c (copy_bb): Update comment to use\n+\tapply_scale.\n+\t(copy_edges_for_bb): Ditto.\n+\t(copy_cfg_body): Ditto.\n+\n 2013-04-29  Tom de Vries  <tom@codesourcery.com>\n \n \t* tree-ssa-tail-merge.c (find_same_succ_bb): Skip loop latch bbs."}, {"sha": "eed320c9ea0a39e87fd3b96229d908a0999c768d", "filename": "gcc/basic-block.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41f80f90846d26a89ed5a6440bc283b745235ac/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41f80f90846d26a89ed5a6440bc283b745235ac/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=f41f80f90846d26a89ed5a6440bc283b745235ac", "patch": "@@ -500,7 +500,7 @@ struct edge_list\n \t\t\t\t\t      REG_BR_PROB_BASE)\n \n /* Compute a scale factor (or probability) suitable for scaling of\n-   gcov_type values via apply_probability().  */\n+   gcov_type values via apply_probability() and apply_scale().  */\n #define GCOV_COMPUTE_SCALE(num,den) \\\n   ((den) ? RDIV ((num) * REG_BR_PROB_BASE, (den)) : REG_BR_PROB_BASE)\n \n@@ -952,13 +952,23 @@ combine_probabilities (int prob1, int prob2)\n   return RDIV (prob1 * prob2, REG_BR_PROB_BASE);\n }\n \n+/* Apply scale factor SCALE on frequency or count FREQ. Use this\n+   interface when potentially scaling up, so that SCALE is not\n+   constrained to be < REG_BR_PROB_BASE.  */\n+\n+static inline gcov_type\n+apply_scale (gcov_type freq, int scale)\n+{\n+  return RDIV (freq * scale, REG_BR_PROB_BASE);\n+}\n+\n /* Apply probability PROB on frequency or count FREQ.  */\n \n static inline gcov_type\n apply_probability (gcov_type freq, int prob)\n {\n   check_probability (prob);\n-  return RDIV (freq * prob, REG_BR_PROB_BASE);\n+  return apply_scale (freq, prob);\n }\n \n /* Return inverse probability for PROB.  */"}, {"sha": "03fbe91bbe2fbaf68c93f4101e23f04e8f8bd8f4", "filename": "gcc/gimple-streamer-in.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41f80f90846d26a89ed5a6440bc283b745235ac/gcc%2Fgimple-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41f80f90846d26a89ed5a6440bc283b745235ac/gcc%2Fgimple-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.c?ref=f41f80f90846d26a89ed5a6440bc283b745235ac", "patch": "@@ -329,8 +329,8 @@ input_bb (struct lto_input_block *ib, enum LTO_tags tag,\n   index = streamer_read_uhwi (ib);\n   bb = BASIC_BLOCK_FOR_FUNCTION (fn, index);\n \n-  bb->count = apply_probability (streamer_read_gcov_count (ib),\n-                                 count_materialization_scale);\n+  bb->count = apply_scale (streamer_read_gcov_count (ib),\n+                           count_materialization_scale);\n   bb->frequency = streamer_read_hwi (ib);\n   bb->flags = streamer_read_hwi (ib);\n "}, {"sha": "cead76b0cd227ea3f7d948771e50c727f58da538", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41f80f90846d26a89ed5a6440bc283b745235ac/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41f80f90846d26a89ed5a6440bc283b745235ac/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=f41f80f90846d26a89ed5a6440bc283b745235ac", "patch": "@@ -1347,10 +1347,10 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n                                         file_data->profile_info.runs);\n \tlto_gcov_summary.sum_max\n             = MAX (lto_gcov_summary.sum_max,\n-                   apply_probability (file_data->profile_info.sum_max, scale));\n+                   apply_scale (file_data->profile_info.sum_max, scale));\n \tlto_gcov_summary.sum_all\n             = MAX (lto_gcov_summary.sum_all,\n-                   apply_probability (file_data->profile_info.sum_all, scale));\n+                   apply_scale (file_data->profile_info.sum_all, scale));\n         /* Save a pointer to the profile_info with the largest\n            scaled sum_all and the scale for use in merging the\n            histogram.  */\n@@ -1372,8 +1372,8 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n       /* Scale up the min value as we did the corresponding sum_all\n          above. Use that to find the new histogram index.  */\n       gcov_type scaled_min\n-          = apply_probability (saved_profile_info->histogram[h_ix].min_value,\n-                               saved_scale);\n+          = apply_scale (saved_profile_info->histogram[h_ix].min_value,\n+                         saved_scale);\n       /* The new index may be shared with another scaled histogram entry,\n          so we need to account for a non-zero histogram entry at new_ix.  */\n       unsigned new_ix = gcov_histo_index (scaled_min);\n@@ -1386,8 +1386,8 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n          here and place the scaled cumulative counter value in the bucket\n          corresponding to the scaled minimum counter value.  */\n       lto_gcov_summary.histogram[new_ix].cum_value\n-          += apply_probability (saved_profile_info->histogram[h_ix].cum_value,\n-                                saved_scale);\n+          += apply_scale (saved_profile_info->histogram[h_ix].cum_value,\n+                          saved_scale);\n       lto_gcov_summary.histogram[new_ix].num_counters\n           += saved_profile_info->histogram[h_ix].num_counters;\n     }\n@@ -1419,8 +1419,8 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n \tif (scale == REG_BR_PROB_BASE)\n \t  continue;\n \tfor (edge = node->callees; edge; edge = edge->next_callee)\n-\t  edge->count = apply_probability (edge->count, scale);\n-\tnode->count = apply_probability (node->count, scale);\n+\t  edge->count = apply_scale (edge->count, scale);\n+\tnode->count = apply_scale (node->count, scale);\n       }\n }\n "}, {"sha": "87158bf0b33a704e27eb8a26716508c54b1b5b82", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41f80f90846d26a89ed5a6440bc283b745235ac/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41f80f90846d26a89ed5a6440bc283b745235ac/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=f41f80f90846d26a89ed5a6440bc283b745235ac", "patch": "@@ -635,8 +635,8 @@ input_cfg (struct lto_input_block *ib, struct function *fn,\n \n \t  dest_index = streamer_read_uhwi (ib);\n \t  probability = (int) streamer_read_hwi (ib);\n-\t  count = apply_probability ((gcov_type) streamer_read_gcov_count (ib),\n-                                     count_materialization_scale);\n+\t  count = apply_scale ((gcov_type) streamer_read_gcov_count (ib),\n+                               count_materialization_scale);\n \t  edge_flags = streamer_read_uhwi (ib);\n \n \t  dest = BASIC_BLOCK_FOR_FUNCTION (fn, dest_index);"}, {"sha": "69455cebf791178d5c5f9a5878973239d4fca458", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41f80f90846d26a89ed5a6440bc283b745235ac/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41f80f90846d26a89ed5a6440bc283b745235ac/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=f41f80f90846d26a89ed5a6440bc283b745235ac", "patch": "@@ -1519,7 +1519,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n      basic_block_info automatically.  */\n   copy_basic_block = create_basic_block (NULL, (void *) 0,\n                                          (basic_block) prev->aux);\n-  /* Update to use apply_probability().  */\n+  /* Update to use apply_scale().  */\n   copy_basic_block->count = bb->count * count_scale / REG_BR_PROB_BASE;\n \n   /* We are going to rebuild frequencies from scratch.  These values\n@@ -1891,7 +1891,7 @@ copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb,\n \t    && old_edge->dest->aux != EXIT_BLOCK_PTR)\n \t  flags |= EDGE_FALLTHRU;\n \tnew_edge = make_edge (new_bb, (basic_block) old_edge->dest->aux, flags);\n-        /* Update to use apply_probability().  */\n+        /* Update to use apply_scale().  */\n \tnew_edge->count = old_edge->count * count_scale / REG_BR_PROB_BASE;\n \tnew_edge->probability = old_edge->probability;\n       }\n@@ -2278,7 +2278,7 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n \t    incoming_frequency += EDGE_FREQUENCY (e);\n \t    incoming_count += e->count;\n \t  }\n-      /* Update to use apply_probability().  */\n+      /* Update to use apply_scale().  */\n       incoming_count = incoming_count * count_scale / REG_BR_PROB_BASE;\n       /* Update to use EDGE_FREQUENCY.  */\n       incoming_frequency"}, {"sha": "0948d2e6977984c4c4b51d047901c63a4d2d9b2b", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41f80f90846d26a89ed5a6440bc283b745235ac/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41f80f90846d26a89ed5a6440bc283b745235ac/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=f41f80f90846d26a89ed5a6440bc283b745235ac", "patch": "@@ -131,15 +131,15 @@ execute_fixup_cfg (void)\n                             ENTRY_BLOCK_PTR->count);\n \n   ENTRY_BLOCK_PTR->count = cgraph_get_node (current_function_decl)->count;\n-  EXIT_BLOCK_PTR->count = apply_probability (EXIT_BLOCK_PTR->count,\n-                                             count_scale);\n+  EXIT_BLOCK_PTR->count = apply_scale (EXIT_BLOCK_PTR->count,\n+                                       count_scale);\n \n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n-    e->count = apply_probability (e->count, count_scale);\n+    e->count = apply_scale (e->count, count_scale);\n \n   FOR_EACH_BB (bb)\n     {\n-      bb->count = apply_probability (bb->count, count_scale);\n+      bb->count = apply_scale (bb->count, count_scale);\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n@@ -172,7 +172,7 @@ execute_fixup_cfg (void)\n \t}\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n-        e->count = apply_probability (e->count, count_scale);\n+        e->count = apply_scale (e->count, count_scale);\n \n       /* If we have a basic block with no successors that does not\n \t end with a control statement or a noreturn call end it with"}]}