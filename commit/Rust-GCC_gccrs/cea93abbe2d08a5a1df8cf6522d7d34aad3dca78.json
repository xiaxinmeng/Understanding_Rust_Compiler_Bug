{"sha": "cea93abbe2d08a5a1df8cf6522d7d34aad3dca78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VhOTNhYmJlMmQwOGE1YTFkZjhjZjY1MjJkN2QzNGFhZDNkY2E3OA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-06-13T20:28:08Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-06-13T20:28:08Z"}, "message": "re PR libfortran/35863 ([F2003] Implement ENCODING=\"UTF-8\")\n\n2008-06-13  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/35863\n\t* libgfortran.h: Change l8_to_l4_offset to big_endian and add endian_off.\n\t* runtime/main.c: Fix error in comment. Change l8_to_l4_offset to\n\tbig_endian. (determine_endianness): Add endian_off and set its value\n\taccording to big_endian.\n\t* gfortran.map: Add symbol for new _gfortran_transfer_character_wide.\n\t* io/io.h: Add prototype declarations for new functions.\n\t* io/list_read.c (list_formatted_read_scalar): Modify to handle kind=4.\n\t(list_formatted_read): Calculate stride based on kind for character type\n\tand use it when calling list_formatted_read_scalar.\n\t* io/inquire.c (inquire_via_unit): Change l8_to_l4_offset to big_endian.\n\t* io/open.c (st_open): Change l8_to_l4_offset to big_endian.\n\t* io/read.c (read_a_char4): New function to handle formatted read.\n\t* io/write.c: Define GFC_CHAR4(x) to improve readability of code.\n\t(write_a_char4): New function to handle formatted write.\n\t(write_character): Modify to accept the kind parameter and adjust for\n\tendianess of the machine. (list_formatted_write): Calculate the stride\n\tresulting from the kind and adjust the list_formatted_write_scalar call\n\taccordingly. (nml_write_obj): Adjust calls to write_character.\n\t(namelist_write): Likewise.\n\t* io/transfer.c (formatted_transfer_scaler): Rename 'len' argument to\n\t'kind' argument to better describe what it is. Add calls to new\n\tfunctions for kind == 4. (formatted_transfer): Modify to handle the case\n\tof type character and kind equals 4 to pass in the kind to the transfer\n\troutines. (transfer_character_wide): Add this new function.\n\t(transfer_array): Don't set kind to the character string length. Adjust\n\tstrides bases on character kind.\n\t(unformatted_read): Adjust size based on kind for character types.\n\t(unformatted_write): Likewise. (data_transfer_init): Change\n\tl8_to_l4_offset to big_endian.\n\nFrom-SVN: r136763", "tree": {"sha": "6519779ba74e7e856024b0c512587694f342c5db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6519779ba74e7e856024b0c512587694f342c5db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/comments", "author": null, "committer": null, "parents": [{"sha": "c5f4d1cc2f628f7ab48b905896082fcdfedfe889", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5f4d1cc2f628f7ab48b905896082fcdfedfe889", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5f4d1cc2f628f7ab48b905896082fcdfedfe889"}], "stats": {"total": 549, "additions": 420, "deletions": 129}, "files": [{"sha": "044896764a98610116ef672fd27473b028784fb3", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=cea93abbe2d08a5a1df8cf6522d7d34aad3dca78", "patch": "@@ -1,3 +1,36 @@\n+2008-06-13  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/35863\n+\t* libgfortran.h: Change l8_to_l4_offset to big_endian and add endian_off.\n+\t* runtime/main.c: Fix error in comment. Change l8_to_l4_offset to\n+\tbig_endian. (determine_endianness): Add endian_off and set its value\n+\taccording to big_endian.\n+\t* gfortran.map: Add symbol for new _gfortran_transfer_character_wide.\n+\t* io/io.h: Add prototype declarations for new functions.\n+\t* io/list_read.c (list_formatted_read_scalar): Modify to handle kind=4.\n+\t(list_formatted_read): Calculate stride based on kind for character type\n+\tand use it when calling list_formatted_read_scalar.\n+\t* io/inquire.c (inquire_via_unit): Change l8_to_l4_offset to big_endian.\n+\t* io/open.c (st_open): Change l8_to_l4_offset to big_endian.\n+\t* io/read.c (read_a_char4): New function to handle formatted read.\n+\t* io/write.c: Define GFC_CHAR4(x) to improve readability of code.\n+\t(write_a_char4): New function to handle formatted write.\n+\t(write_character): Modify to accept the kind parameter and adjust for\n+\tendianess of the machine. (list_formatted_write): Calculate the stride\n+\tresulting from the kind and adjust the list_formatted_write_scalar call\n+\taccordingly. (nml_write_obj): Adjust calls to write_character.\n+\t(namelist_write): Likewise.\n+\t* io/transfer.c (formatted_transfer_scaler): Rename 'len' argument to\n+\t'kind' argument to better describe what it is. Add calls to new\n+\tfunctions for kind == 4. (formatted_transfer): Modify to handle the case\n+\tof type character and kind equals 4 to pass in the kind to the transfer\n+\troutines. (transfer_character_wide): Add this new function.\n+\t(transfer_array): Don't set kind to the character string length. Adjust\n+\tstrides bases on character kind.\n+\t(unformatted_read): Adjust size based on kind for character types.\n+\t(unformatted_write): Likewise. (data_transfer_init): Change\n+\tl8_to_l4_offset to big_endian. \n+\n 2008-06-13  Tobias Burnus  <burnus@net-b.de>\n \n \t* configure.ac (AM_CFLAGS): Remove -Werror again."}, {"sha": "0671b60fb86f0457c84e937f0f9df95dd12449f1", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=cea93abbe2d08a5a1df8cf6522d7d34aad3dca78", "patch": "@@ -1083,6 +1083,7 @@ GFORTRAN_1.1 {\n     _gfortran_string_trim_char4;\n     _gfortran_string_verify_char4;\n     _gfortran_st_wait;\n+    _gfortran_transfer_character_wide;\n     _gfortran_transpose_char4;\n     _gfortran_unpack0_char4;\n     _gfortran_unpack1_char4;"}, {"sha": "f2b1599ed87a43675d34f0eaef288e9dc3f49bf0", "filename": "libgfortran/io/fbuf.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fio%2Ffbuf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fio%2Ffbuf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffbuf.c?ref=cea93abbe2d08a5a1df8cf6522d7d34aad3dca78", "patch": "@@ -157,7 +157,7 @@ fbuf_seek (gfc_unit * u, gfc_offset off)\n   /* Moving to the left past the flushed marked would imply moving past\n      the left tab limit, which is never allowed. So return error if\n      that is attempted.  */\n-  if (pos < u->fbuf->flushed)\n+  if (pos < (gfc_offset) u->fbuf->flushed)\n     return -1;\n   u->fbuf->pos = pos;\n   return 0;"}, {"sha": "9eb63d7b4d700dab82b0bb2d67bd4dd5fb539c31", "filename": "libgfortran/io/inquire.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fio%2Finquire.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fio%2Finquire.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Finquire.c?ref=cea93abbe2d08a5a1df8cf6522d7d34aad3dca78", "patch": "@@ -268,10 +268,9 @@ inquire_via_unit (st_parameter_inquire *iqp, gfc_unit * u)\n \t  case ENCODING_DEFAULT:\n \t    p = \"UNKNOWN\";\n \t    break;\n-\t  /* TODO: Enable UTF-8 case here when implemented.\n \t  case ENCODING_UTF8:\n \t    p = \"UTF-8\";\n-\t    break; */\n+\t    break;\n \t  default:\n \t    internal_error (&iqp->common, \"inquire_via_unit(): Bad encoding\");\n \t  }\n@@ -497,13 +496,13 @@ inquire_via_unit (st_parameter_inquire *iqp, gfc_unit * u)\n       else\n \tswitch (u->flags.convert)\n \t  {\n-\t    /*  l8_to_l4_offset is 0 for little-endian, 1 for big-endian.  */\n+\t    /*  big_endian is 0 for little-endian, 1 for big-endian.  */\n \t  case GFC_CONVERT_NATIVE:\n-\t    p = l8_to_l4_offset ? \"BIG_ENDIAN\" : \"LITTLE_ENDIAN\";\n+\t    p = big_endian ? \"BIG_ENDIAN\" : \"LITTLE_ENDIAN\";\n \t    break;\n \n \t  case GFC_CONVERT_SWAP:\n-\t    p = l8_to_l4_offset ? \"LITTLE_ENDIAN\" : \"BIG_ENDIAN\";\n+\t    p = big_endian ? \"LITTLE_ENDIAN\" : \"BIG_ENDIAN\";\n \t    break;\n \n \t  default:"}, {"sha": "cb7147db39868f4f0ca59a3d5ae50b6145691855", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=cea93abbe2d08a5a1df8cf6522d7d34aad3dca78", "patch": "@@ -869,6 +869,9 @@ internal_proto(convert_real);\n extern void read_a (st_parameter_dt *, const fnode *, char *, int);\n internal_proto(read_a);\n \n+extern void read_a_char4 (st_parameter_dt *, const fnode *, char *, int);\n+internal_proto(read_a);\n+\n extern void read_f (st_parameter_dt *, const fnode *, char *, int);\n internal_proto(read_f);\n \n@@ -904,6 +907,9 @@ internal_proto(namelist_write);\n extern void write_a (st_parameter_dt *, const fnode *, const char *, int);\n internal_proto(write_a);\n \n+extern void write_a_char4 (st_parameter_dt *, const fnode *, const char *, int);\n+internal_proto(write_a_char4);\n+\n extern void write_b (st_parameter_dt *, const fnode *, const char *, int);\n internal_proto(write_b);\n "}, {"sha": "c99e3a8c23b5314bd16ffba35b57af1768a03fbc", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=cea93abbe2d08a5a1df8cf6522d7d34aad3dca78", "patch": "@@ -1728,7 +1728,8 @@ list_formatted_read_scalar (st_parameter_dt *dtp, volatile bt type, void *p,\n \t\t\t    int kind, size_t size)\n {\n   char c;\n-  int m;\n+  gfc_char4_t *q;\n+  int i, m;\n   jmp_buf eof_jump;\n \n   dtp->u.p.namelist_mode = 0;\n@@ -1831,17 +1832,33 @@ list_formatted_read_scalar (st_parameter_dt *dtp, volatile bt type, void *p,\n \n     case BT_CHARACTER:\n       if (dtp->u.p.saved_string)\n-       {\n+\t{\n \t  m = ((int) size < dtp->u.p.saved_used)\n \t      ? (int) size : dtp->u.p.saved_used;\n-\t  memcpy (p, dtp->u.p.saved_string, m);\n-       }\n+\t  if (kind == 1)\n+\t    memcpy (p, dtp->u.p.saved_string, m);\n+\t  else\n+\t    {\n+\t      q = (gfc_char4_t *) p;\n+\t      for (i = 0; i < m; i++)\n+\t\tq[i] = (unsigned char) dtp->u.p.saved_string[i];\n+\t    }\n+\t}\n       else\n \t/* Just delimiters encountered, nothing to copy but SPACE.  */\n         m = 0;\n \n       if (m < (int) size)\n-\tmemset (((char *) p) + m, ' ', size - m);\n+\t{\n+\t  if (kind == 1)\n+\t    memset (((char *) p) + m, ' ', size - m);\n+\t  else\n+\t    {\n+\t      q = (gfc_char4_t *) p;\n+\t      for (i = m; i < (int) size; i++)\n+\t\tq[i] = (unsigned char) ' ';\n+\t    }\n+\t}\n       break;\n \n     case BT_NULL:\n@@ -1862,14 +1879,16 @@ list_formatted_read (st_parameter_dt *dtp, bt type, void *p, int kind,\n {\n   size_t elem;\n   char *tmp;\n+  size_t stride = type == BT_CHARACTER ?\n+\t\t  size * GFC_SIZE_OF_CHAR_KIND(kind) : size;\n \n   tmp = (char *) p;\n \n   /* Big loop over all the elements.  */\n   for (elem = 0; elem < nelems; elem++)\n     {\n       dtp->u.p.item_count++;\n-      list_formatted_read_scalar (dtp, type, tmp + size*elem, kind, size);\n+      list_formatted_read_scalar (dtp, type, tmp + stride*elem, kind, size);\n     }\n }\n "}, {"sha": "4a78efa01fc7880b8614511a9d02049863725675", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=cea93abbe2d08a5a1df8cf6522d7d34aad3dca78", "patch": "@@ -107,7 +107,7 @@ static const st_option decimal_opt[] =\n \n static const st_option encoding_opt[] =\n {\n-  /* TODO { \"utf-8\", ENCODING_UTF8}, */\n+  { \"utf-8\", ENCODING_UTF8},\n   { \"default\", ENCODING_DEFAULT},\n   { NULL, 0}\n };\n@@ -795,7 +795,7 @@ st_open (st_parameter_open *opp)\n \tconv = compile_options.convert;\n     }\n   \n-  /* We use l8_to_l4_offset, which is 0 on little-endian machines\n+  /* We use big_endian, which is 0 on little-endian machines\n      and 1 on big-endian machines.  */\n   switch (conv)\n     {\n@@ -804,11 +804,11 @@ st_open (st_parameter_open *opp)\n       break;\n       \n     case GFC_CONVERT_BIG:\n-      conv = l8_to_l4_offset ? GFC_CONVERT_NATIVE : GFC_CONVERT_SWAP;\n+      conv = big_endian ? GFC_CONVERT_NATIVE : GFC_CONVERT_SWAP;\n       break;\n       \n     case GFC_CONVERT_LITTLE:\n-      conv = l8_to_l4_offset ? GFC_CONVERT_SWAP : GFC_CONVERT_NATIVE;\n+      conv = big_endian ? GFC_CONVERT_SWAP : GFC_CONVERT_NATIVE;\n       break;\n       \n     default:"}, {"sha": "11a1ac018f7667b3a6021619b1382804c001077b", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=cea93abbe2d08a5a1df8cf6522d7d34aad3dca78", "patch": "@@ -270,6 +270,43 @@ read_a (st_parameter_dt *dtp, const fnode *f, char *p, int length)\n     memset (p + m, ' ', n);\n }\n \n+void\n+read_a_char4 (st_parameter_dt *dtp, const fnode *f, char *p, int length)\n+{\n+  char *s;\n+  gfc_char4_t *dest;\n+  int m, n, wi, status;\n+  size_t w;\n+\n+  wi = f->u.w;\n+  if (wi == -1) /* '(A)' edit descriptor  */\n+    wi = length;\n+\n+  w = wi;\n+\n+  s = gfc_alloca (w);\n+\n+  /* Read in w bytes, treating comma as not a separator.  */\n+  dtp->u.p.sf_read_comma = 0;\n+  status = read_block_form (dtp, s, &w);\n+  dtp->u.p.sf_read_comma =\n+    dtp->u.p.decimal_status == DECIMAL_COMMA ? 0 : 1;\n+  \n+  if (status == FAILURE)\n+    return;\n+  if (w > (size_t) length)\n+     s += (w - length);\n+\n+  m = ((int) w > length) ? length : (int) w;\n+  \n+  dest = (gfc_char4_t *) p;\n+  \n+  for (n = 0; n < m; n++, dest++, s++)\n+    *dest = (unsigned char ) *s;\n+\n+  for (n = 0; n < length - (int) w; n++, dest++)\n+    *dest = (unsigned char) ' ';\n+}\n \n /* eat_leading_spaces()-- Given a character pointer and a width,\n  * ignore the leading spaces.  */"}, {"sha": "fd63139146ee953a5886cb884d4534a94156faf1", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 116, "deletions": 66, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=cea93abbe2d08a5a1df8cf6522d7d34aad3dca78", "patch": "@@ -54,6 +54,7 @@ Boston, MA 02110-1301, USA.  */\n       transfer_integer\n       transfer_logical\n       transfer_character\n+      transfer_character_wide\n       transfer_real\n       transfer_complex\n \n@@ -76,6 +77,9 @@ export_proto(transfer_logical);\n extern void transfer_character (st_parameter_dt *, void *, int);\n export_proto(transfer_character);\n \n+extern void transfer_character_wide (st_parameter_dt *, void *, int, int);\n+export_proto(transfer_character_wide);\n+\n extern void transfer_complex (st_parameter_dt *, void *, int);\n export_proto(transfer_complex);\n \n@@ -730,35 +734,43 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n \n static void\n unformatted_read (st_parameter_dt *dtp, bt type,\n-\t\t  void *dest, int kind __attribute__((unused)),\n-\t\t  size_t size, size_t nelems)\n+\t\t  void *dest, int kind, size_t size, size_t nelems)\n {\n   size_t i, sz;\n \n-  /* Currently, character implies size=1.  */\n   if (dtp->u.p.current_unit->flags.convert == GFC_CONVERT_NATIVE\n-      || size == 1 || type == BT_CHARACTER)\n+      || size == 1)\n     {\n       sz = size * nelems;\n+      if (type == BT_CHARACTER)\n+\tsz *= GFC_SIZE_OF_CHAR_KIND(kind);\n       read_block_direct (dtp, dest, &sz);\n     }\n   else\n     {\n       char buffer[16];\n       char *p;\n-      \n+\n+      p = dest;\n+\n+      /* Handle wide chracters.  */\n+      if (type == BT_CHARACTER && kind != 1)\n+\t{\n+\t  nelems *= size;\n+\t  size = kind;\n+\t}\n+\n       /* Break up complex into its constituent reals.  */\n       if (type == BT_COMPLEX)\n \t{\n \t  nelems *= 2;\n \t  size /= 2;\n \t}\n-      p = dest;\n       \n       /* By now, all complex variables have been split into their\n \t constituent reals.  */\n       \n-      for (i=0; i<nelems; i++)\n+      for (i = 0; i < nelems; i++)\n \t{\n  \t  read_block_direct (dtp, buffer, &size);\n  \t  reverse_memcpy (p, buffer, size);\n@@ -775,20 +787,30 @@ unformatted_read (st_parameter_dt *dtp, bt type,\n \n static void\n unformatted_write (st_parameter_dt *dtp, bt type,\n-\t\t   void *source, int kind __attribute__((unused)),\n-\t\t   size_t size, size_t nelems)\n+\t\t   void *source, int kind, size_t size, size_t nelems)\n {\n   if (dtp->u.p.current_unit->flags.convert == GFC_CONVERT_NATIVE ||\n-      size == 1 || type == BT_CHARACTER)\n+      size == 1)\n     {\n-      size *= nelems;\n-      write_buf (dtp, source, size);\n+      size_t stride = type == BT_CHARACTER ?\n+\t\t  size * GFC_SIZE_OF_CHAR_KIND(kind) : size;\n+\n+      write_buf (dtp, source, stride * nelems);\n     }\n   else\n     {\n       char buffer[16];\n       char *p;\n       size_t i;\n+\n+      p = source;\n+\n+      /* Handle wide chracters.  */\n+      if (type == BT_CHARACTER && kind != 1)\n+\t{\n+\t  nelems *= size;\n+\t  size = kind;\n+\t}\n   \n       /* Break up complex into its constituent reals.  */\n       if (type == BT_COMPLEX)\n@@ -797,16 +819,13 @@ unformatted_write (st_parameter_dt *dtp, bt type,\n \t  size /= 2;\n \t}      \n \n-      p = source;\n-\n       /* By now, all complex variables have been split into their\n \t constituent reals.  */\n \n-\n-      for (i=0; i<nelems; i++)\n+      for (i = 0; i < nelems; i++)\n \t{\n \t  reverse_memcpy(buffer, p, size);\n- \t  p+= size;\n+ \t  p += size;\n \t  write_buf (dtp, buffer, size);\n \t}\n     }\n@@ -904,7 +923,7 @@ require_type (st_parameter_dt *dtp, bt expected, bt actual, const fnode *f)\n    of the next element, then comes back here to process it.  */\n \n static void\n-formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n+formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t\t\t   size_t size)\n {\n   char scratch[SCRATCH_SIZE];\n@@ -1004,9 +1023,9 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t    return;\n \n \t  if (dtp->u.p.mode == READING)\n-\t    read_decimal (dtp, f, p, len);\n+\t    read_decimal (dtp, f, p, kind);\n \t  else\n-\t    write_i (dtp, f, p, len);\n+\t    write_i (dtp, f, p, kind);\n \n \t  break;\n \n@@ -1019,9 +1038,9 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t    return;\n \n \t  if (dtp->u.p.mode == READING)\n-\t    read_radix (dtp, f, p, len, 2);\n+\t    read_radix (dtp, f, p, kind, 2);\n \t  else\n-\t    write_b (dtp, f, p, len);\n+\t    write_b (dtp, f, p, kind);\n \n \t  break;\n \n@@ -1034,9 +1053,9 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t    return;\n \n \t  if (dtp->u.p.mode == READING)\n-\t    read_radix (dtp, f, p, len, 8);\n+\t    read_radix (dtp, f, p, kind, 8);\n \t  else\n-\t    write_o (dtp, f, p, len);\n+\t    write_o (dtp, f, p, kind);\n \n \t  break;\n \n@@ -1049,31 +1068,43 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t    return;\n \n \t  if (dtp->u.p.mode == READING)\n-\t    read_radix (dtp, f, p, len, 16);\n+\t    read_radix (dtp, f, p, kind, 16);\n \t  else\n-\t    write_z (dtp, f, p, len);\n+\t    write_z (dtp, f, p, kind);\n \n \t  break;\n \n \tcase FMT_A:\n \t  if (n == 0)\n \t    goto need_data;\n \n+\t  /* It is possible to have FMT_A with something not BT_CHARACTER such\n+\t     as when writing out hollerith strings, so check both type\n+\t     and kind before calling wide character routines.  */\n \t  if (dtp->u.p.mode == READING)\n-\t    read_a (dtp, f, p, len);\n+\t    {\n+\t      if (type == BT_CHARACTER && kind == 4)\n+\t\tread_a_char4 (dtp, f, p, size);\n+\t      else\n+\t\tread_a (dtp, f, p, size);\n+\t    }\n \t  else\n-\t    write_a (dtp, f, p, len);\n-\n+\t    {\n+\t      if (type == BT_CHARACTER && kind == 4)\n+\t\twrite_a_char4 (dtp, f, p, size);\n+\t      else\n+\t\twrite_a (dtp, f, p, size);\n+\t    }\n \t  break;\n \n \tcase FMT_L:\n \t  if (n == 0)\n \t    goto need_data;\n \n \t  if (dtp->u.p.mode == READING)\n-\t    read_l (dtp, f, p, len);\n+\t    read_l (dtp, f, p, kind);\n \t  else\n-\t    write_l (dtp, f, p, len);\n+\t    write_l (dtp, f, p, kind);\n \n \t  break;\n \n@@ -1084,9 +1115,9 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t    return;\n \n \t  if (dtp->u.p.mode == READING)\n-\t    read_f (dtp, f, p, len);\n+\t    read_f (dtp, f, p, kind);\n \t  else\n-\t    write_d (dtp, f, p, len);\n+\t    write_d (dtp, f, p, kind);\n \n \t  break;\n \n@@ -1097,9 +1128,9 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t    return;\n \n \t  if (dtp->u.p.mode == READING)\n-\t    read_f (dtp, f, p, len);\n+\t    read_f (dtp, f, p, kind);\n \t  else\n-\t    write_e (dtp, f, p, len);\n+\t    write_e (dtp, f, p, kind);\n \t  break;\n \n \tcase FMT_EN:\n@@ -1109,9 +1140,9 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t    return;\n \n \t  if (dtp->u.p.mode == READING)\n-\t    read_f (dtp, f, p, len);\n+\t    read_f (dtp, f, p, kind);\n \t  else\n-\t    write_en (dtp, f, p, len);\n+\t    write_en (dtp, f, p, kind);\n \n \t  break;\n \n@@ -1122,9 +1153,9 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t    return;\n \n \t  if (dtp->u.p.mode == READING)\n-\t    read_f (dtp, f, p, len);\n+\t    read_f (dtp, f, p, kind);\n \t  else\n-\t    write_es (dtp, f, p, len);\n+\t    write_es (dtp, f, p, kind);\n \n \t  break;\n \n@@ -1135,9 +1166,9 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t    return;\n \n \t  if (dtp->u.p.mode == READING)\n-\t    read_f (dtp, f, p, len);\n+\t    read_f (dtp, f, p, kind);\n \t  else\n-\t    write_f (dtp, f, p, len);\n+\t    write_f (dtp, f, p, kind);\n \n \t  break;\n \n@@ -1148,16 +1179,19 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t    switch (type)\n \t      {\n \t      case BT_INTEGER:\n-\t\tread_decimal (dtp, f, p, len);\n+\t\tread_decimal (dtp, f, p, kind);\n \t\tbreak;\n \t      case BT_LOGICAL:\n-\t\tread_l (dtp, f, p, len);\n+\t\tread_l (dtp, f, p, kind);\n \t\tbreak;\n \t      case BT_CHARACTER:\n-\t\tread_a (dtp, f, p, len);\n+\t\tif (kind == 4)\n+\t\t  read_a_char4 (dtp, f, p, size);\n+\t\telse\n+\t\t  read_a (dtp, f, p, size);\n \t\tbreak;\n \t      case BT_REAL:\n-\t\tread_f (dtp, f, p, len);\n+\t\tread_f (dtp, f, p, kind);\n \t\tbreak;\n \t      default:\n \t\tgoto bad_type;\n@@ -1166,19 +1200,22 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t    switch (type)\n \t      {\n \t      case BT_INTEGER:\n-\t\twrite_i (dtp, f, p, len);\n+\t\twrite_i (dtp, f, p, kind);\n \t\tbreak;\n \t      case BT_LOGICAL:\n-\t\twrite_l (dtp, f, p, len);\n+\t\twrite_l (dtp, f, p, kind);\t\n \t\tbreak;\n \t      case BT_CHARACTER:\n-\t\twrite_a (dtp, f, p, len);\n+\t\tif (kind == 4)\n+\t\t  write_a_char4 (dtp, f, p, size);\n+\t\telse\n+\t\t  write_a (dtp, f, p, size);\n \t\tbreak;\n \t      case BT_REAL:\n \t\tif (f->u.real.w == 0)\n-\t\t  write_real (dtp, p, len);\n+\t\t  write_real (dtp, p, kind);\n \t\telse\n-\t\t  write_d (dtp, f, p, len);\n+\t\t  write_d (dtp, f, p, kind);\n \t\tbreak;\n \t      default:\n \t      bad_type:\n@@ -1407,12 +1444,13 @@ formatted_transfer (st_parameter_dt *dtp, bt type, void *p, int kind,\n   char *tmp;\n \n   tmp = (char *) p;\n-\n+  size_t stride = type == BT_CHARACTER ?\n+\t\t  size * GFC_SIZE_OF_CHAR_KIND(kind) : size;\n   /* Big loop over all the elements.  */\n   for (elem = 0; elem < nelems; elem++)\n     {\n       dtp->u.p.item_count++;\n-      formatted_transfer_scalar (dtp, type, tmp + size*elem, kind, size);\n+      formatted_transfer_scalar (dtp, type, tmp + stride*elem, kind, size);\n     }\n }\n \n@@ -1465,10 +1503,26 @@ transfer_character (st_parameter_dt *dtp, void *p, int len)\n   if (len == 0 && p == NULL)\n     p = empty_string;\n \n-  /* Currently we support only 1 byte chars, and the library is a bit\n-     confused of character kind vs. length, so we kludge it by setting\n-     kind = length.  */\n-  dtp->u.p.transfer (dtp, BT_CHARACTER, p, len, len, 1);\n+  /* Set kind here to 1.  */\n+  dtp->u.p.transfer (dtp, BT_CHARACTER, p, 1, len, 1);\n+}\n+\n+void\n+transfer_character_wide (st_parameter_dt *dtp, void *p, int len, int kind)\n+{\n+  static char *empty_string[0];\n+\n+  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n+    return;\n+\n+  /* Strings of zero length can have p == NULL, which confuses the\n+     transfer routines into thinking we need more data elements.  To avoid\n+     this, we give them a nice pointer.  */\n+  if (len == 0 && p == NULL)\n+    p = empty_string;\n+\n+  /* Here we pass the actual kind value.  */\n+  dtp->u.p.transfer (dtp, BT_CHARACTER, p, kind, len, 1);\n }\n \n \n@@ -1522,13 +1576,7 @@ transfer_array (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n       break;\n     case GFC_DTYPE_CHARACTER:\n       iotype = BT_CHARACTER;\n-      /* FIXME: Currently dtype contains the charlen, which is\n-\t clobbered if charlen > 2**24. That's why we use a separate\n-\t argument for the charlen. However, if we want to support\n-\t non-8-bit charsets we need to fix dtype to contain\n-\t sizeof(chartype) and fix the code below.  */\n       size = charlen;\n-      kind = charlen;\n       break;\n     case GFC_DTYPE_DERIVED:\n       internal_error (&dtp->common,\n@@ -1542,7 +1590,9 @@ transfer_array (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n-      stride[n] = desc->dim[n].stride;\n+      stride[n] = iotype == BT_CHARACTER ?\n+\t\t  desc->dim[n].stride * GFC_SIZE_OF_CHAR_KIND(kind) :\n+\t\t  desc->dim[n].stride;\n       extent[n] = desc->dim[n].ubound + 1 - desc->dim[n].lbound;\n \n       /* If the extent of even one dimension is zero, then the entire\n@@ -1815,7 +1865,7 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n      if (conv == GFC_CONVERT_NONE)\n        conv = compile_options.convert;\n \n-     /* We use l8_to_l4_offset, which is 0 on little-endian machines\n+     /* We use big_endian, which is 0 on little-endian machines\n \tand 1 on big-endian machines.  */\n      switch (conv)\n        {\n@@ -1824,11 +1874,11 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \t break;\n \t \n        case GFC_CONVERT_BIG:\n-\t conv = l8_to_l4_offset ? GFC_CONVERT_NATIVE : GFC_CONVERT_SWAP;\n+\t conv = big_endian ? GFC_CONVERT_NATIVE : GFC_CONVERT_SWAP;\n \t break;\n       \n        case GFC_CONVERT_LITTLE:\n-\t conv = l8_to_l4_offset ? GFC_CONVERT_SWAP : GFC_CONVERT_NATIVE;\n+\t conv = big_endian ? GFC_CONVERT_SWAP : GFC_CONVERT_NATIVE;\n \t break;\n \t \n        default:"}, {"sha": "ed50e0d5705e57a1f2601156bcf830ee0363b3c1", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 185, "deletions": 37, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=cea93abbe2d08a5a1df8cf6522d7d34aad3dca78", "patch": "@@ -124,6 +124,108 @@ write_a (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n #endif\n }\n \n+\n+/* The primary difference between write_a_char4 and write_a is that we have to\n+   deal with writing from the first byte of the 4-byte character and take care\n+   of endianess.  This currently implements encoding=\"default\" which means we\n+   write the lowest significant byte. If the 3 most significant bytes are\n+   not representable emit a '?'.  TODO: Implement encoding=\"UTF-8\"\n+   which will process all 4 bytes and translate to the encoded output.  */\n+\n+void\n+write_a_char4 (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n+{\n+  int wlen;\n+  char *p;\n+  gfc_char4_t *q;\n+\n+  wlen = f->u.string.length < 0\n+\t || (f->format == FMT_G && f->u.string.length == 0)\n+\t ? len : f->u.string.length;\n+\n+  q = (gfc_char4_t *) source;\n+#ifdef HAVE_CRLF\n+  /* If this is formatted STREAM IO convert any embedded line feed characters\n+     to CR_LF on systems that use that sequence for newlines.  See F2003\n+     Standard sections 10.6.3 and 9.9 for further information.  */\n+  if (is_stream_io (dtp))\n+    {\n+      const char crlf[] = \"\\r\\n\";\n+      int i, j, bytes;\n+      gfc_char4_t *qq;\n+      bytes = 0;\n+\n+      /* Write out any padding if needed.  */\n+      if (len < wlen)\n+\t{\n+\t  p = write_block (dtp, wlen - len);\n+\t  if (p == NULL)\n+\t    return;\n+\t  memset (p, ' ', wlen - len);\n+\t}\n+\n+      /* Scan the source string looking for '\\n' and convert it if found.  */\n+      qq = (gfc_char4_t *) source;\n+      for (i = 0; i < wlen; i++)\n+\t{\n+\t  if (qq[i] == '\\n')\n+\t    {\n+\t      /* Write out the previously scanned characters in the string.  */\n+\t      if (bytes > 0)\n+\t\t{\n+\t\t  p = write_block (dtp, bytes);\n+\t\t  if (p == NULL)\n+\t\t    return;\n+\t\t  for (j = 0; j < bytes; j++)\n+\t\t    p[j] = q[j] > 255 ? '?' : (unsigned char) q[j];\n+\t\t  bytes = 0;\n+\t\t}\n+\n+\t      /* Write out the CR_LF sequence.  */ \n+\t      p = write_block (dtp, 2);\n+              if (p == NULL)\n+                return;\n+\t      memcpy (p, crlf, 2);\n+\t    }\n+\t  else\n+\t    bytes++;\n+\t}\n+\n+      /*  Write out any remaining bytes if no LF was found.  */\n+      if (bytes > 0)\n+\t{\n+\t  p = write_block (dtp, bytes);\n+\t  if (p == NULL)\n+\t    return;\n+\t  for (j = 0; j < bytes; j++)\n+\t    p[j] = q[j] > 255 ? '?' : (unsigned char) q[j];\n+\t}\n+    }\n+  else\n+    {\n+#endif\n+      int j;\n+      p = write_block (dtp, wlen);\n+      if (p == NULL)\n+\treturn;\n+\n+      if (wlen < len)\n+\t{\n+\t  for (j = 0; j < wlen; j++)\n+\t    p[j] = q[j] > 255 ? '?' : (unsigned char) q[j];\n+\t}\n+      else\n+\t{\n+\t  memset (p, ' ', wlen - len);\n+\t  for (j = wlen - len; j < wlen; j++)\n+\t    p[j] = q[j] > 255 ? '?' : (unsigned char) q[j];\n+\t}\n+#ifdef HAVE_CRLF\n+    }\n+#endif\n+}\n+\n+\n static GFC_INTEGER_LARGEST\n extract_int (const void *p, int len)\n {\n@@ -639,10 +741,12 @@ write_integer (st_parameter_dt *dtp, const char *source, int length)\n    the strings if the file has been opened in that mode.  */\n \n static void\n-write_character (st_parameter_dt *dtp, const char *source, int length)\n+write_character (st_parameter_dt *dtp, const char *source, int kind, int length)\n {\n   int i, extra;\n   char *p, d;\n+  gfc_char4_t *q;\n+\n \n   switch (dtp->u.p.delim_status)\n     {\n@@ -657,35 +761,77 @@ write_character (st_parameter_dt *dtp, const char *source, int length)\n       break;\n     }\n \n-  if (d == ' ')\n-    extra = 0;\n-  else\n+  if (kind == 1)\n     {\n-      extra = 2;\n+      if (d == ' ')\n+\textra = 0;\n+      else\n+\t{\n+\t  extra = 2;\n \n-      for (i = 0; i < length; i++)\n-\tif (source[i] == d)\n-\t  extra++;\n-    }\n+\t    for (i = 0; i < length; i++)\n+\t      if (source[i] == d)\n+\t\textra++;\n+\t}\n \n-  p = write_block (dtp, length + extra);\n-  if (p == NULL)\n-    return;\n+      p = write_block (dtp, length + extra);\n+      if (p == NULL)\n+\treturn;\n+\n+      if (d == ' ')\n+\tmemcpy (p, source, length);\n+      else\n+\t{\n+\t  *p++ = d;\n \n-  if (d == ' ')\n-    memcpy (p, source, length);\n+\t  for (i = 0; i < length; i++)\n+            {\n+              *p++ = source[i];\n+              if (source[i] == d)\n+\t\t*p++ = d;\n+\t    }\n+\n+\t  *p = d;\n+\t}\n+    }\n   else\n     {\n-      *p++ = d;\n-\n-      for (i = 0; i < length; i++)\n+      /* We have to scan the source string looking for delimiters to determine\n+\t how large the write block needs to be.  */\n+      if (d == ' ')\n+\textra = 0;\n+      else\n \t{\n-\t  *p++ = source[i];\n-\t  if (source[i] == d)\n-\t    *p++ = d;\n+\t  extra = 2;\n+\n+\t  q = (gfc_char4_t *) source;\n+\t  for (i = 0; i < length; i++, q++)\n+\t    if (*q == (gfc_char4_t) d)\n+\t      extra++;\n \t}\n \n-      *p = d;\n+      p = write_block (dtp, length + extra);\n+      if (p == NULL)\n+\treturn;\n+\n+      if (d == ' ')\n+\t{\n+\t  q = (gfc_char4_t *) source;\n+\t  for (i = 0; i < length; i++, q++)\n+\t    p[i] = *q > 255 ? '?' : (unsigned char) *q;\n+\t}\n+      else\n+\t{\n+\t  *p++ = d;\n+\t  q = (gfc_char4_t *) source;\n+\t  for (i = 0; i < length; i++, q++)\n+\t    {\n+\t      *p++ = *q > 255 ? '?' : (unsigned char) *q;\n+\t      if (*q == (gfc_char4_t) d)\n+\t\t*p++ = d;\n+\t    }\n+\t  *p = d;\n+\t}\n     }\n }\n \n@@ -796,7 +942,7 @@ list_formatted_write_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n       write_logical (dtp, p, kind);\n       break;\n     case BT_CHARACTER:\n-      write_character (dtp, p, kind);\n+      write_character (dtp, p, kind, size);\n       break;\n     case BT_REAL:\n       write_real (dtp, p, kind);\n@@ -818,14 +964,16 @@ list_formatted_write (st_parameter_dt *dtp, bt type, void *p, int kind,\n {\n   size_t elem;\n   char *tmp;\n+  size_t stride = type == BT_CHARACTER ?\n+\t\t  size * GFC_SIZE_OF_CHAR_KIND(kind) : size;\n \n   tmp = (char *) p;\n \n   /* Big loop over all the elements.  */\n   for (elem = 0; elem < nelems; elem++)\n     {\n       dtp->u.p.item_count++;\n-      list_formatted_write_scalar (dtp, type, tmp + size*elem, kind, size);\n+      list_formatted_write_scalar (dtp, type, tmp + elem * stride, kind, size);\n     }\n }\n \n@@ -889,9 +1037,9 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n   if (obj->type != GFC_DTYPE_DERIVED)\n     {\n #ifdef HAVE_CRLF\n-      write_character (dtp, \"\\r\\n \", 3);\n+      write_character (dtp, \"\\r\\n \", 1, 3);\n #else\n-      write_character (dtp, \"\\n \", 2);\n+      write_character (dtp, \"\\n \", 1, 2);\n #endif\n       len = 0;\n       if (base)\n@@ -900,15 +1048,15 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \t  for (dim_i = 0; dim_i < (index_type) strlen (base_name); dim_i++)\n             {\n \t      cup = toupper (base_name[dim_i]);\n-\t      write_character (dtp, &cup, 1);\n+\t      write_character (dtp, &cup, 1, 1);\n             }\n \t}\n       for (dim_i =len; dim_i < (index_type) strlen (obj->var_name); dim_i++)\n \t{\n \t  cup = toupper (obj->var_name[dim_i]);\n-\t  write_character (dtp, &cup, 1);\n+\t  write_character (dtp, &cup, 1, 1);\n \t}\n-      write_character (dtp, \"=\", 1);\n+      write_character (dtp, \"=\", 1, 1);\n     }\n \n   /* Counts the number of data output on a line, including names.  */\n@@ -978,7 +1126,7 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \t  if (rep_ctr > 1)\n \t    {\n \t      sprintf(rep_buff, \" %d*\", rep_ctr);\n-\t      write_character (dtp, rep_buff, strlen (rep_buff));\n+\t      write_character (dtp, rep_buff, 1, strlen (rep_buff));\n \t      dtp->u.p.no_leading_blank = 1;\n \t    }\n \t  num++;\n@@ -1003,7 +1151,7 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \t\tdtp->u.p.delim_status = DELIM_QUOTE;\n \t      if (dtp->u.p.nml_delim == '\\'')\n \t\tdtp->u.p.delim_status = DELIM_APOSTROPHE;\n-\t      write_character (dtp, p, obj->string_length);\n+\t      write_character (dtp, p, 1, obj->string_length);\n \t      dtp->u.p.delim_status = tmp_delim;\n               break;\n \n@@ -1093,14 +1241,14 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \t     to column 2. Reset the repeat counter.  */\n \n \t  dtp->u.p.no_leading_blank = 0;\n-\t  write_character (dtp, &semi_comma, 1);\n+\t  write_character (dtp, &semi_comma, 1, 1);\n \t  if (num > 5)\n \t    {\n \t      num = 0;\n #ifdef HAVE_CRLF\n-\t      write_character (dtp, \"\\r\\n \", 3);\n+\t      write_character (dtp, \"\\r\\n \", 1, 3);\n #else\n-\t      write_character (dtp, \"\\n \", 2);\n+\t      write_character (dtp, \"\\n \", 1, 2);\n #endif\n \t    }\n \t  rep_ctr = 1;\n@@ -1164,13 +1312,13 @@ namelist_write (st_parameter_dt *dtp)\n   /* Temporarily disable namelist delimters.  */\n   dtp->u.p.delim_status = DELIM_NONE;\n \n-  write_character (dtp, \"&\", 1);\n+  write_character (dtp, \"&\", 1, 1);\n \n   /* Write namelist name in upper case - f95 std.  */\n   for (i = 0 ;i < dtp->namelist_name_len ;i++ )\n     {\n       c = toupper (dtp->namelist_name[i]);\n-      write_character (dtp, &c ,1);\n+      write_character (dtp, &c, 1 ,1);\n     }\n \n   if (dtp->u.p.ionml != NULL)\n@@ -1184,9 +1332,9 @@ namelist_write (st_parameter_dt *dtp)\n     }\n \n #ifdef HAVE_CRLF\n-  write_character (dtp, \"  /\\r\\n\", 5);\n+  write_character (dtp, \"  /\\r\\n\", 1, 5);\n #else\n-  write_character (dtp, \"  /\\n\", 4);\n+  write_character (dtp, \"  /\\n\", 1, 4);\n #endif\n \n   /* Restore the original delimiter.  */"}, {"sha": "8c0f1b4a796f42e6a3cd0c3b3f40aa58cf9ef2dd", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=cea93abbe2d08a5a1df8cf6522d7d34aad3dca78", "patch": "@@ -272,13 +272,12 @@ typedef GFC_UINTEGER_4 gfc_char4_t;\n    simply equal to the kind parameter itself.  */\n #define GFC_SIZE_OF_CHAR_KIND(kind) (kind)\n \n-\n /* This will be 0 on little-endian machines and one on big-endian machines.  */\n-extern int l8_to_l4_offset;\n-internal_proto(l8_to_l4_offset);\n+extern int big_endian;\n+internal_proto(big_endian);\n \n #define GFOR_POINTER_TO_L1(p, kind) \\\n-  (l8_to_l4_offset * (kind - 1) + (GFC_LOGICAL_1 *)(p))\n+  (big_endian * (kind - 1) + (GFC_LOGICAL_1 *)(p))\n \n #define GFC_INTEGER_1_HUGE \\\n   (GFC_INTEGER_1)((((GFC_UINTEGER_1)1) << 7) - 1)"}, {"sha": "71b481a7deb1a94b38963138cbb5985314be4921", "filename": "libgfortran/runtime/main.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fruntime%2Fmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea93abbe2d08a5a1df8cf6522d7d34aad3dca78/libgfortran%2Fruntime%2Fmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fmain.c?ref=cea93abbe2d08a5a1df8cf6522d7d34aad3dca78", "patch": "@@ -45,10 +45,9 @@ stupid_function_name_for_static_linking (void)\n   return;\n }\n \n-/* This is the offset (in bytes) required to cast from logical(8)* to\n-   logical(4)*. and still get the same result.  Will be 0 for little-endian\n-   machines and 4 for big-endian machines.  */\n-int l8_to_l4_offset = 0;\n+/* This will be 0 for little-endian\n+   machines and 1 for big-endian machines.  */\n+int big_endian = 0;\n \n \n /* Figure out endianness for this machine.  */\n@@ -64,9 +63,9 @@ determine_endianness (void)\n \n   u.l8 = 1;\n   if (u.l4[0])\n-    l8_to_l4_offset = 0;\n+    big_endian = 0;\n   else if (u.l4[1])\n-    l8_to_l4_offset = 1;\n+    big_endian = 1;\n   else\n     runtime_error (\"Unable to determine machine endianness\");\n }"}]}