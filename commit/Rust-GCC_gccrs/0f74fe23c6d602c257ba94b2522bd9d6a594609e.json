{"sha": "0f74fe23c6d602c257ba94b2522bd9d6a594609e", "node_id": "C_kwDOANBUbNoAKDBmNzRmZTIzYzZkNjAyYzI1N2JhOTRiMjUyMmJkOWQ2YTU5NDYwOWU", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-15T17:54:12Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-16T14:19:22Z"}, "message": "Refactor operator overloading work to be more reuseable", "tree": {"sha": "ad89becf15b24cd82ba0dbae9cb03c1a9a4d2727", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad89becf15b24cd82ba0dbae9cb03c1a9a4d2727"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f74fe23c6d602c257ba94b2522bd9d6a594609e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f74fe23c6d602c257ba94b2522bd9d6a594609e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f74fe23c6d602c257ba94b2522bd9d6a594609e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f74fe23c6d602c257ba94b2522bd9d6a594609e/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7fb60bb626f7b936bf117636db777a5f0df30c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7fb60bb626f7b936bf117636db777a5f0df30c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7fb60bb626f7b936bf117636db777a5f0df30c9"}], "stats": {"total": 965, "additions": 368, "deletions": 597}, "files": [{"sha": "8902574baec3f70fc6a09a6be896d727c0e3cf26", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 119, "deletions": 183, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f74fe23c6d602c257ba94b2522bd9d6a594609e/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f74fe23c6d602c257ba94b2522bd9d6a594609e/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=0f74fe23c6d602c257ba94b2522bd9d6a594609e", "patch": "@@ -39,100 +39,18 @@ CompileExpr::visit (HIR::ArithmeticOrLogicalExpr &expr)\n   TyTy::FnType *fntype;\n   bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n     expr.get_mappings ().get_hirid (), &fntype);\n-  if (!is_op_overload)\n+  if (is_op_overload)\n     {\n-      translated = ctx->get_backend ()->arithmetic_or_logical_expression (\n-\top, lhs, rhs, expr.get_locus ());\n+      auto lang_item_type\n+\t= Analysis::RustLangItem::OperatorToLangItem (expr.get_expr_type ());\n+      translated = resolve_operator_overload (lang_item_type, expr, lhs, rhs,\n+\t\t\t\t\t      expr.get_lhs (), expr.get_rhs ());\n       return;\n     }\n \n-  // lookup the resolved name\n-  NodeId resolved_node_id = UNKNOWN_NODEID;\n-  if (!ctx->get_resolver ()->lookup_resolved_name (\n-\texpr.get_mappings ().get_nodeid (), &resolved_node_id))\n-    {\n-      rust_error_at (expr.get_locus (), \"failed to lookup resolved MethodCall\");\n-      return;\n-    }\n-\n-  // reverse lookup\n-  HirId ref;\n-  if (!ctx->get_mappings ()->lookup_node_to_hir (\n-\texpr.get_mappings ().get_crate_num (), resolved_node_id, &ref))\n-    {\n-      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n-      return;\n-    }\n-\n-  TyTy::BaseType *receiver = nullptr;\n-  bool ok\n-    = ctx->get_tyctx ()->lookup_receiver (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t  &receiver);\n-  rust_assert (ok);\n-\n-  bool is_dyn_dispatch\n-    = receiver->get_root ()->get_kind () == TyTy::TypeKind::DYNAMIC;\n-  bool is_generic_receiver = receiver->get_kind () == TyTy::TypeKind::PARAM;\n-  if (is_generic_receiver)\n-    {\n-      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n-      receiver = p->resolve ();\n-    }\n-\n-  if (is_dyn_dispatch)\n-    {\n-      const TyTy::DynamicObjectType *dyn\n-\t= static_cast<const TyTy::DynamicObjectType *> (receiver->get_root ());\n-\n-      std::vector<HIR::Expr *> arguments;\n-      arguments.push_back (expr.get_rhs ());\n-\n-      translated = compile_dyn_dispatch_call (dyn, receiver, fntype, lhs,\n-\t\t\t\t\t      arguments, expr.get_locus ());\n-      return;\n-    }\n-\n-  // lookup compiled functions since it may have already been compiled\n-  HIR::PathIdentSegment segment_name (\"add\");\n-  Bexpression *fn_expr\n-    = resolve_method_address (fntype, ref, receiver, segment_name,\n-\t\t\t      expr.get_mappings (), expr.get_locus ());\n-\n-  // lookup the autoderef mappings\n-  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n-  ok = ctx->get_tyctx ()->lookup_autoderef_mappings (\n-    expr.get_mappings ().get_hirid (), &adjustments);\n-  rust_assert (ok);\n-\n-  Bexpression *self = lhs;\n-  for (auto &adjustment : *adjustments)\n-    {\n-      switch (adjustment.get_type ())\n-\t{\n-\tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n-\tcase Resolver::Adjustment::AdjustmentType::MUT_REF:\n-\t  self = ctx->get_backend ()->address_expression (\n-\t    self, expr.get_lhs ()->get_locus ());\n-\t  break;\n-\n-\tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n-\t  Btype *expected_type\n-\t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n-\t  self = ctx->get_backend ()->indirect_expression (\n-\t    expected_type, self, true, /* known_valid*/\n-\t    expr.get_lhs ()->get_locus ());\n-\t  break;\n-\t}\n-    }\n-\n-  std::vector<Bexpression *> args;\n-  args.push_back (self); // adjusted self\n-  args.push_back (rhs);\n-\n-  auto fncontext = ctx->peek_fn ();\n   translated\n-    = ctx->get_backend ()->call_expression (fncontext.fndecl, fn_expr, args,\n-\t\t\t\t\t    nullptr, expr.get_locus ());\n+    = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n+\t\t\t\t\t\t\t     expr.get_locus ());\n }\n \n void\n@@ -148,106 +66,30 @@ CompileExpr::visit (HIR::CompoundAssignmentExpr &expr)\n   TyTy::FnType *fntype;\n   bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n     expr.get_mappings ().get_hirid (), &fntype);\n-  if (!is_op_overload)\n+  if (is_op_overload)\n     {\n-      auto operator_expr\n-\t= ctx->get_backend ()->arithmetic_or_logical_expression (\n-\t  op, lhs, rhs, expr.get_locus ());\n-      Bstatement *assignment\n-\t= ctx->get_backend ()->assignment_statement (fn.fndecl, lhs,\n-\t\t\t\t\t\t     operator_expr,\n-\t\t\t\t\t\t     expr.get_locus ());\n+      auto lang_item_type\n+\t= Analysis::RustLangItem::CompoundAssignmentOperatorToLangItem (\n+\t  expr.get_expr_type ());\n+      auto compound_assignment\n+\t= resolve_operator_overload (lang_item_type, expr, lhs, rhs,\n+\t\t\t\t     expr.get_left_expr ().get (),\n+\t\t\t\t     expr.get_right_expr ().get ());\n+      auto assignment\n+\t= ctx->get_backend ()->expression_statement (fn.fndecl,\n+\t\t\t\t\t\t     compound_assignment);\n       ctx->add_statement (assignment);\n-      return;\n-    }\n-\n-  // lookup the resolved name\n-  NodeId resolved_node_id = UNKNOWN_NODEID;\n-  if (!ctx->get_resolver ()->lookup_resolved_name (\n-\texpr.get_mappings ().get_nodeid (), &resolved_node_id))\n-    {\n-      rust_error_at (expr.get_locus (), \"failed to lookup resolved MethodCall\");\n-      return;\n-    }\n-\n-  // reverse lookup\n-  HirId ref;\n-  if (!ctx->get_mappings ()->lookup_node_to_hir (\n-\texpr.get_mappings ().get_crate_num (), resolved_node_id, &ref))\n-    {\n-      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n-      return;\n-    }\n-\n-  TyTy::BaseType *receiver = nullptr;\n-  bool ok\n-    = ctx->get_tyctx ()->lookup_receiver (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t  &receiver);\n-  rust_assert (ok);\n \n-  bool is_dyn_dispatch\n-    = receiver->get_root ()->get_kind () == TyTy::TypeKind::DYNAMIC;\n-  bool is_generic_receiver = receiver->get_kind () == TyTy::TypeKind::PARAM;\n-  if (is_generic_receiver)\n-    {\n-      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n-      receiver = p->resolve ();\n-    }\n-\n-  if (is_dyn_dispatch)\n-    {\n-      const TyTy::DynamicObjectType *dyn\n-\t= static_cast<const TyTy::DynamicObjectType *> (receiver->get_root ());\n-\n-      std::vector<HIR::Expr *> arguments;\n-      arguments.push_back (expr.get_right_expr ().get ());\n-\n-      translated = compile_dyn_dispatch_call (dyn, receiver, fntype, lhs,\n-\t\t\t\t\t      arguments, expr.get_locus ());\n       return;\n     }\n \n-  // lookup compiled functions since it may have already been compiled\n-  HIR::PathIdentSegment segment_name (\"add_assign\");\n-  Bexpression *fn_expr\n-    = resolve_method_address (fntype, ref, receiver, segment_name,\n-\t\t\t      expr.get_mappings (), expr.get_locus ());\n-\n-  // lookup the autoderef mappings\n-  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n-  ok = ctx->get_tyctx ()->lookup_autoderef_mappings (\n-    expr.get_mappings ().get_hirid (), &adjustments);\n-  rust_assert (ok);\n-\n-  Bexpression *self = lhs;\n-  for (auto &adjustment : *adjustments)\n-    {\n-      switch (adjustment.get_type ())\n-\t{\n-\tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n-\tcase Resolver::Adjustment::AdjustmentType::MUT_REF:\n-\t  self = ctx->get_backend ()->address_expression (\n-\t    self, expr.get_left_expr ()->get_locus ());\n-\t  break;\n-\n-\tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n-\t  Btype *expected_type\n-\t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n-\t  self = ctx->get_backend ()->indirect_expression (\n-\t    expected_type, self, true, /* known_valid*/\n-\t    expr.get_left_expr ()->get_locus ());\n-\t  break;\n-\t}\n-    }\n-\n-  std::vector<Bexpression *> args;\n-  args.push_back (self); // adjusted self\n-  args.push_back (rhs);\n-\n-  auto fncontext = ctx->peek_fn ();\n-  translated\n-    = ctx->get_backend ()->call_expression (fncontext.fndecl, fn_expr, args,\n-\t\t\t\t\t    nullptr, expr.get_locus ());\n+  auto operator_expr\n+    = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n+\t\t\t\t\t\t\t     expr.get_locus ());\n+  Bstatement *assignment\n+    = ctx->get_backend ()->assignment_statement (fn.fndecl, lhs, operator_expr,\n+\t\t\t\t\t\t expr.get_locus ());\n+  ctx->add_statement (assignment);\n }\n \n Bexpression *\n@@ -427,5 +269,99 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n     }\n }\n \n+Bexpression *\n+CompileExpr::resolve_operator_overload (\n+  Analysis::RustLangItem::ItemType lang_item_type, HIR::OperatorExpr &expr,\n+  Bexpression *lhs, Bexpression *rhs, HIR::Expr *lhs_expr, HIR::Expr *rhs_expr)\n+{\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  rust_assert (is_op_overload);\n+\n+  // lookup the resolved name\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+  bool ok = ctx->get_resolver ()->lookup_resolved_name (\n+    expr.get_mappings ().get_nodeid (), &resolved_node_id);\n+  rust_assert (ok);\n+\n+  // reverse lookup\n+  HirId ref;\n+  ok = ctx->get_mappings ()->lookup_node_to_hir (\n+    expr.get_mappings ().get_crate_num (), resolved_node_id, &ref);\n+  rust_assert (ok);\n+\n+  TyTy::BaseType *receiver = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_receiver (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t   &receiver);\n+  rust_assert (ok);\n+\n+  bool is_dyn_dispatch\n+    = receiver->get_root ()->get_kind () == TyTy::TypeKind::DYNAMIC;\n+  bool is_generic_receiver = receiver->get_kind () == TyTy::TypeKind::PARAM;\n+  if (is_generic_receiver)\n+    {\n+      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n+      receiver = p->resolve ();\n+    }\n+\n+  if (is_dyn_dispatch)\n+    {\n+      const TyTy::DynamicObjectType *dyn\n+\t= static_cast<const TyTy::DynamicObjectType *> (receiver->get_root ());\n+\n+      std::vector<HIR::Expr *> arguments;\n+      arguments.push_back (rhs_expr);\n+\n+      return compile_dyn_dispatch_call (dyn, receiver, fntype, lhs, arguments,\n+\t\t\t\t\texpr.get_locus ());\n+    }\n+\n+  // lookup compiled functions since it may have already been compiled\n+  HIR::PathIdentSegment segment_name (\n+    Analysis::RustLangItem::ToString (lang_item_type));\n+  Bexpression *fn_expr\n+    = resolve_method_address (fntype, ref, receiver, segment_name,\n+\t\t\t      expr.get_mappings (), expr.get_locus ());\n+\n+  // lookup the autoderef mappings\n+  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_autoderef_mappings (\n+    expr.get_mappings ().get_hirid (), &adjustments);\n+  rust_assert (ok);\n+\n+  // FIXME refactor this out\n+  Bexpression *self = lhs;\n+  for (auto &adjustment : *adjustments)\n+    {\n+      switch (adjustment.get_type ())\n+\t{\n+\tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n+\tcase Resolver::Adjustment::AdjustmentType::MUT_REF:\n+\t  self\n+\t    = ctx->get_backend ()->address_expression (self,\n+\t\t\t\t\t\t       lhs_expr->get_locus ());\n+\t  break;\n+\n+\tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n+\t  Btype *expected_type\n+\t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n+\t  self\n+\t    = ctx->get_backend ()->indirect_expression (expected_type, self,\n+\t\t\t\t\t\t\ttrue, /* known_valid*/\n+\t\t\t\t\t\t\tlhs_expr->get_locus ());\n+\t  break;\n+\t}\n+    }\n+\n+  std::vector<Bexpression *> args;\n+  args.push_back (self); // adjusted self\n+  args.push_back (rhs);\n+\n+  auto fncontext = ctx->peek_fn ();\n+  return ctx->get_backend ()->call_expression (fncontext.fndecl, fn_expr, args,\n+\t\t\t\t\t       nullptr, expr.get_locus ());\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "7238d45a27095a0444c395c1968124f1a621979c", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f74fe23c6d602c257ba94b2522bd9d6a594609e/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f74fe23c6d602c257ba94b2522bd9d6a594609e/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=0f74fe23c6d602c257ba94b2522bd9d6a594609e", "patch": "@@ -1005,6 +1005,12 @@ class CompileExpr : public HIRCompileBase\n \t\t\t\t       Analysis::NodeMapping expr_mappings,\n \t\t\t\t       Location expr_locus);\n \n+  Bexpression *\n+  resolve_operator_overload (Analysis::RustLangItem::ItemType lang_item_type,\n+\t\t\t     HIR::OperatorExpr &expr, Bexpression *lhs,\n+\t\t\t     Bexpression *rhs, HIR::Expr *lhs_expr,\n+\t\t\t     HIR::Expr *rhs_expr);\n+\n private:\n   CompileExpr (Context *ctx)\n     : HIRCompileBase (ctx), translated (nullptr), capacity_expr (nullptr)"}, {"sha": "37cd6b303dd36ad65d79ce3f656afd570792b1c4", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 243, "deletions": 414, "changes": 657, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f74fe23c6d602c257ba94b2522bd9d6a594609e/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f74fe23c6d602c257ba94b2522bd9d6a594609e/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=0f74fe23c6d602c257ba94b2522bd9d6a594609e", "patch": "@@ -483,207 +483,24 @@ class TypeCheckExpr : public TypeCheckBase\n     if (result->get_kind () == TyTy::TypeKind::ERROR)\n       return;\n \n-    // in order to probe of the correct type paths we need the root type, which\n-    // strips any references\n-    const TyTy::BaseType *root = lhs->get_root ();\n-\n-    // look up lang item for arithmetic type\n-    std::vector<PathProbeCandidate> candidates;\n     auto lang_item_type\n       = Analysis::RustLangItem::CompoundAssignmentOperatorToLangItem (\n \texpr.get_expr_type ());\n-    std::string associated_item_name\n-      = Analysis::RustLangItem::ToString (lang_item_type);\n-    DefId respective_lang_item_id = UNKNOWN_DEFID;\n-    bool lang_item_defined\n-      = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n-\n-    // probe for the lang-item\n-    if (lang_item_defined)\n-      {\n-\tbool receiver_is_type_param\n-\t  = root->get_kind () == TyTy::TypeKind::PARAM;\n-\tbool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n-\n-\tbool receiver_is_generic = receiver_is_type_param || receiver_is_dyn;\n-\tbool probe_bounds = true;\n-\tbool probe_impls = !receiver_is_generic;\n-\tbool ignore_mandatory_trait_items = !receiver_is_generic;\n-\n-\tcandidates = PathProbeType::Probe (\n-\t  root, HIR::PathIdentSegment (associated_item_name), probe_impls,\n-\t  probe_bounds, ignore_mandatory_trait_items, respective_lang_item_id);\n-      }\n-\n-    // autoderef\n-    std::vector<Adjustment> adjustments;\n-    PathProbeCandidate *resolved_candidate\n-      = MethodResolution::Select (candidates, lhs, adjustments);\n-\n-    // is this the case we are recursive\n-    // handle the case where we are within the impl block for this lang_item\n-    // otherwise we end up with a recursive operator overload such as the i32\n-    // operator overload trait\n-    if (lang_item_defined && resolved_candidate != nullptr)\n-      {\n-\tTypeCheckContextItem &fn_context = context->peek_context ();\n-\tif (fn_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n-\t  {\n-\t    auto &impl_item = fn_context.get_impl_item ();\n-\t    HIR::ImplBlock *parent = impl_item.first;\n-\t    HIR::Function *fn = impl_item.second;\n-\n-\t    if (parent->has_trait_ref ()\n-\t\t&& fn->get_function_name ().compare (associated_item_name) == 0)\n-\t      {\n-\t\tTraitReference *trait_reference\n-\t\t  = TraitResolver::Lookup (*parent->get_trait_ref ().get ());\n-\t\tif (!trait_reference->is_error ())\n-\t\t  {\n-\t\t    TyTy::BaseType *lookup = nullptr;\n-\t\t    bool ok\n-\t\t      = context->lookup_type (fn->get_mappings ().get_hirid (),\n-\t\t\t\t\t      &lookup);\n-\t\t    rust_assert (ok);\n-\t\t    rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n-\n-\t\t    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n-\t\t    rust_assert (fntype->is_method ());\n-\n-\t\t    Adjuster adj (lhs);\n-\t\t    TyTy::BaseType *adjusted = adj.adjust_type (adjustments);\n-\n-\t\t    bool is_lang_item_impl\n-\t\t      = trait_reference->get_mappings ().get_defid ()\n-\t\t\t== respective_lang_item_id;\n-\t\t    bool self_is_lang_item_self\n-\t\t      = fntype->get_self_type ()->is_equal (*adjusted);\n-\t\t    bool recursive_operator_overload\n-\t\t      = is_lang_item_impl && self_is_lang_item_self;\n-\n-\t\t    lang_item_defined = !recursive_operator_overload;\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n-\n-    bool have_implementation_for_lang_item = resolved_candidate != nullptr;\n-    if (!lang_item_defined || !have_implementation_for_lang_item)\n-      {\n-\tbool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n-\tbool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n-\tbool valid = valid_lhs && valid_rhs;\n-\tif (!valid)\n-\t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"cannot apply this operator to types %s and %s\",\n-\t\t\t   lhs->as_string ().c_str (),\n-\t\t\t   rhs->as_string ().c_str ());\n-\t    return;\n-\t  }\n-\n-\t// nothing left to do\n-\treturn;\n-      }\n-\n-    // now its just like a method-call-expr\n-    context->insert_receiver (expr.get_mappings ().get_hirid (), lhs);\n-\n-    // store the adjustments for code-generation to know what to do\n-    context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\tstd::move (adjustments));\n-\n-    TyTy::BaseType *lookup_tyty = resolved_candidate->ty;\n-    NodeId resolved_node_id\n-      = resolved_candidate->is_impl_candidate ()\n-\t  ? resolved_candidate->item.impl.impl_item->get_impl_mappings ()\n-\t      .get_nodeid ()\n-\t  : resolved_candidate->item.trait.item_ref->get_mappings ()\n-\t      .get_nodeid ();\n-\n-    rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n-    TyTy::BaseType *lookup = lookup_tyty;\n-    TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n-    rust_assert (fn->is_method ());\n-\n-    if (root->get_kind () == TyTy::TypeKind::ADT)\n-      {\n-\tconst TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n-\tif (adt->has_substitutions () && fn->needs_substitution ())\n-\t  {\n-\t    // consider the case where we have:\n-\t    //\n-\t    // struct Foo<X,Y>(X,Y);\n-\t    //\n-\t    // impl<T> Foo<T, i32> {\n-\t    //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n-\t    // }\n-\t    //\n-\t    // In this case we end up with an fn type of:\n-\t    //\n-\t    // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n-\t    //\n-\t    // This means the instance or self we are calling this method for\n-\t    // will be substituted such that we can get the inherited type\n-\t    // arguments but then need to use the turbo fish if available or\n-\t    // infer the remaining arguments. Luckily rust does not allow for\n-\t    // default types GenericParams on impl blocks since these must\n-\t    // always be at the end of the list\n-\n-\t    auto s = fn->get_self_type ()->get_root ();\n-\t    rust_assert (s->can_eq (adt, false, false));\n-\t    rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n-\t    const TyTy::ADTType *self_adt\n-\t      = static_cast<const TyTy::ADTType *> (s);\n-\n-\t    // we need to grab the Self substitutions as the inherit type\n-\t    // parameters for this\n-\t    if (self_adt->needs_substitution ())\n-\t      {\n-\t\trust_assert (adt->was_substituted ());\n-\n-\t\tTyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n-\t\t  = GetUsedSubstArgs::From (adt);\n-\n-\t\tTyTy::SubstitutionArgumentMappings inherit_type_args\n-\t\t  = self_adt->solve_mappings_from_receiver_for_self (\n-\t\t    used_args_in_prev_segment);\n-\n-\t\t// there may or may not be inherited type arguments\n-\t\tif (!inherit_type_args.is_error ())\n-\t\t  {\n-\t\t    // need to apply the inherited type arguments to the\n-\t\t    // function\n-\t\t    lookup = fn->handle_substitions (inherit_type_args);\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n+    bool operator_overloaded\n+      = resolve_operator_overload (lang_item_type, expr, lhs, rhs);\n+    if (operator_overloaded)\n+      return;\n \n-    // type check the arguments\n-    TyTy::FnType *type = static_cast<TyTy::FnType *> (lookup);\n-    rust_assert (type->num_params () == 2);\n-    auto fnparam = type->param_at (1);\n-    auto resolved_argument_type = fnparam.second->unify (rhs);\n-    if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n+    bool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n+    bool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n+    bool valid = valid_lhs && valid_rhs;\n+    if (!valid)\n       {\n \trust_error_at (expr.get_locus (),\n-\t\t       \"Type Resolution failure on parameter\");\n+\t\t       \"cannot apply this operator to types %s and %s\",\n+\t\t       lhs->as_string ().c_str (), rhs->as_string ().c_str ());\n \treturn;\n       }\n-\n-    // get the return type\n-    TyTy::BaseType *function_ret_tyty = fn->get_return_type ()->clone ();\n-\n-    // store the expected fntype\n-    context->insert_operator_overload (expr.get_mappings ().get_hirid (), type);\n-\n-    // set up the resolved name on the path\n-    resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n-\t\t\t\t    resolved_node_id);\n-\n-    // return the result of the function back\n-    infered = function_ret_tyty;\n   }\n \n   void visit (HIR::IdentifierExpr &expr) override\n@@ -879,239 +696,61 @@ class TypeCheckExpr : public TypeCheckBase\n \t\t\t\t\t     expr.get_locus ());\n \n \t  // mark the type for this implicit node\n-\t  context->insert_type (capacity_mapping,\n-\t\t\t\tnew TyTy::USizeType (\n-\t\t\t\t  capacity_mapping.get_hirid ()));\n-\n-\t  Bexpression *capacity\n-\t    = ConstFold::ConstFoldExpr::fold (&literal_capacity);\n-\n-\t  Analysis::NodeMapping array_mapping (crate_num, UNKNOWN_NODEID,\n-\t\t\t\t\t       mappings->get_next_hir_id (\n-\t\t\t\t\t\t crate_num),\n-\t\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n-\n-\t  TyTy::ArrayType *array\n-\t    = new TyTy::ArrayType (array_mapping.get_hirid (), capacity,\n-\t\t\t\t   TyTy::TyVar (u8->get_ref ()));\n-\t  context->insert_type (array_mapping, array);\n-\n-\t  infered = new TyTy::ReferenceType (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t     TyTy::TyVar (array->get_ref ()),\n-\t\t\t\t\t     Mutability::Imm);\n-\t}\n-\tbreak;\n-\n-      default:\n-\tgcc_unreachable ();\n-\tbreak;\n-      }\n-\n-    infered = infered->clone ();\n-  }\n-\n-  void visit (HIR::ArithmeticOrLogicalExpr &expr) override\n-  {\n-    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs (), false);\n-    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs (), false);\n-\n-    // in order to probe of the correct type paths we need the root type, which\n-    // strips any references\n-    const TyTy::BaseType *root = lhs->get_root ();\n-\n-    // look up lang item for arithmetic type\n-    std::vector<PathProbeCandidate> candidates;\n-    auto lang_item_type\n-      = Analysis::RustLangItem::OperatorToLangItem (expr.get_expr_type ());\n-    std::string associated_item_name\n-      = Analysis::RustLangItem::ToString (lang_item_type);\n-    DefId respective_lang_item_id = UNKNOWN_DEFID;\n-    bool lang_item_defined\n-      = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n-\n-    // handle the case where we are within the impl block for this lang_item\n-    // otherwise we end up with a recursive operator overload such as the i32\n-    // operator overload trait\n-    if (lang_item_defined)\n-      {\n-\tTypeCheckContextItem &fn_context = context->peek_context ();\n-\tif (fn_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n-\t  {\n-\t    auto &impl_item = fn_context.get_impl_item ();\n-\t    HIR::ImplBlock *parent = impl_item.first;\n-\t    HIR::Function *fn = impl_item.second;\n-\n-\t    if (parent->has_trait_ref ()\n-\t\t&& fn->get_function_name ().compare (associated_item_name) == 0)\n-\t      {\n-\t\tTraitReference *trait_reference\n-\t\t  = TraitResolver::Lookup (*parent->get_trait_ref ().get ());\n-\t\tif (!trait_reference->is_error ())\n-\t\t  {\n-\t\t    TyTy::BaseType *lookup = nullptr;\n-\t\t    bool ok\n-\t\t      = context->lookup_type (fn->get_mappings ().get_hirid (),\n-\t\t\t\t\t      &lookup);\n-\t\t    rust_assert (ok);\n-\t\t    rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n-\n-\t\t    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n-\t\t    rust_assert (fntype->is_method ());\n-\n-\t\t    bool is_lang_item_impl\n-\t\t      = trait_reference->get_mappings ().get_defid ()\n-\t\t\t== respective_lang_item_id;\n-\t\t    bool self_is_lang_item_self\n-\t\t      = fntype->get_self_type ()->is_equal (*lhs);\n-\n-\t\t    bool recursive_operator_overload\n-\t\t      = is_lang_item_impl && self_is_lang_item_self;\n-\t\t    lang_item_defined = !recursive_operator_overload;\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n-\n-    // probe for the lang-item\n-    if (lang_item_defined)\n-      {\n-\tbool receiver_is_type_param\n-\t  = root->get_kind () == TyTy::TypeKind::PARAM;\n-\tbool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n-\n-\tbool receiver_is_generic = receiver_is_type_param || receiver_is_dyn;\n-\tbool probe_bounds = true;\n-\tbool probe_impls = !receiver_is_generic;\n-\tbool ignore_mandatory_trait_items = !receiver_is_generic;\n-\n-\tcandidates = PathProbeType::Probe (\n-\t  root, HIR::PathIdentSegment (associated_item_name), probe_impls,\n-\t  probe_bounds, ignore_mandatory_trait_items, respective_lang_item_id);\n-      }\n-\n-    bool have_implementation_for_lang_item = candidates.size () > 0;\n-    if (!lang_item_defined || !have_implementation_for_lang_item)\n-      {\n-\tbool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n-\tbool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n-\tbool valid = valid_lhs && valid_rhs;\n-\tif (!valid)\n-\t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"cannot apply this operator to types %s and %s\",\n-\t\t\t   lhs->as_string ().c_str (),\n-\t\t\t   rhs->as_string ().c_str ());\n-\t    return;\n-\t  }\n-\n-\tinfered = lhs->unify (rhs);\n-\treturn;\n-      }\n-\n-    // now its just like a method-call-expr\n-    context->insert_receiver (expr.get_mappings ().get_hirid (), lhs);\n-\n-    // autoderef\n-    std::vector<Adjustment> adjustments;\n-    PathProbeCandidate *resolved_candidate\n-      = MethodResolution::Select (candidates, lhs, adjustments);\n-    rust_assert (resolved_candidate != nullptr);\n-\n-    // store the adjustments for code-generation to know what to do\n-    context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\tstd::move (adjustments));\n-\n-    TyTy::BaseType *lookup_tyty = resolved_candidate->ty;\n-    NodeId resolved_node_id\n-      = resolved_candidate->is_impl_candidate ()\n-\t  ? resolved_candidate->item.impl.impl_item->get_impl_mappings ()\n-\t      .get_nodeid ()\n-\t  : resolved_candidate->item.trait.item_ref->get_mappings ()\n-\t      .get_nodeid ();\n-\n-    rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n-    TyTy::BaseType *lookup = lookup_tyty;\n-    TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n-    rust_assert (fn->is_method ());\n-\n-    if (root->get_kind () == TyTy::TypeKind::ADT)\n-      {\n-\tconst TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n-\tif (adt->has_substitutions () && fn->needs_substitution ())\n-\t  {\n-\t    // consider the case where we have:\n-\t    //\n-\t    // struct Foo<X,Y>(X,Y);\n-\t    //\n-\t    // impl<T> Foo<T, i32> {\n-\t    //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n-\t    // }\n-\t    //\n-\t    // In this case we end up with an fn type of:\n-\t    //\n-\t    // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n-\t    //\n-\t    // This means the instance or self we are calling this method for\n-\t    // will be substituted such that we can get the inherited type\n-\t    // arguments but then need to use the turbo fish if available or\n-\t    // infer the remaining arguments. Luckily rust does not allow for\n-\t    // default types GenericParams on impl blocks since these must\n-\t    // always be at the end of the list\n+\t  context->insert_type (capacity_mapping,\n+\t\t\t\tnew TyTy::USizeType (\n+\t\t\t\t  capacity_mapping.get_hirid ()));\n \n-\t    auto s = fn->get_self_type ()->get_root ();\n-\t    rust_assert (s->can_eq (adt, false, false));\n-\t    rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n-\t    const TyTy::ADTType *self_adt\n-\t      = static_cast<const TyTy::ADTType *> (s);\n+\t  Bexpression *capacity\n+\t    = ConstFold::ConstFoldExpr::fold (&literal_capacity);\n \n-\t    // we need to grab the Self substitutions as the inherit type\n-\t    // parameters for this\n-\t    if (self_adt->needs_substitution ())\n-\t      {\n-\t\trust_assert (adt->was_substituted ());\n+\t  Analysis::NodeMapping array_mapping (crate_num, UNKNOWN_NODEID,\n+\t\t\t\t\t       mappings->get_next_hir_id (\n+\t\t\t\t\t\t crate_num),\n+\t\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n \n-\t\tTyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n-\t\t  = GetUsedSubstArgs::From (adt);\n+\t  TyTy::ArrayType *array\n+\t    = new TyTy::ArrayType (array_mapping.get_hirid (), capacity,\n+\t\t\t\t   TyTy::TyVar (u8->get_ref ()));\n+\t  context->insert_type (array_mapping, array);\n \n-\t\tTyTy::SubstitutionArgumentMappings inherit_type_args\n-\t\t  = self_adt->solve_mappings_from_receiver_for_self (\n-\t\t    used_args_in_prev_segment);\n+\t  infered = new TyTy::ReferenceType (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t     TyTy::TyVar (array->get_ref ()),\n+\t\t\t\t\t     Mutability::Imm);\n+\t}\n+\tbreak;\n \n-\t\t// there may or may not be inherited type arguments\n-\t\tif (!inherit_type_args.is_error ())\n-\t\t  {\n-\t\t    // need to apply the inherited type arguments to the\n-\t\t    // function\n-\t\t    lookup = fn->handle_substitions (inherit_type_args);\n-\t\t  }\n-\t      }\n-\t  }\n+      default:\n+\tgcc_unreachable ();\n+\tbreak;\n       }\n \n-    // type check the arguments\n-    TyTy::FnType *type = static_cast<TyTy::FnType *> (lookup);\n-    rust_assert (type->num_params () == 2);\n-    auto fnparam = type->param_at (1);\n-    auto resolved_argument_type = fnparam.second->unify (rhs);\n-    if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n+    infered = infered->clone ();\n+  }\n+\n+  void visit (HIR::ArithmeticOrLogicalExpr &expr) override\n+  {\n+    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs (), false);\n+    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs (), false);\n+\n+    auto lang_item_type\n+      = Analysis::RustLangItem::OperatorToLangItem (expr.get_expr_type ());\n+    bool operator_overloaded\n+      = resolve_operator_overload (lang_item_type, expr, lhs, rhs);\n+    if (operator_overloaded)\n+      return;\n+\n+    bool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n+    bool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n+    bool valid = valid_lhs && valid_rhs;\n+    if (!valid)\n       {\n \trust_error_at (expr.get_locus (),\n-\t\t       \"Type Resolution failure on parameter\");\n+\t\t       \"cannot apply this operator to types %s and %s\",\n+\t\t       lhs->as_string ().c_str (), rhs->as_string ().c_str ());\n \treturn;\n       }\n \n-    // get the return type\n-    TyTy::BaseType *function_ret_tyty = fn->get_return_type ()->clone ();\n-\n-    // store the expected fntype\n-    context->insert_operator_overload (expr.get_mappings ().get_hirid (), type);\n-\n-    // set up the resolved name on the path\n-    resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n-\t\t\t\t    resolved_node_id);\n-\n-    // return the result of the function back\n-    infered = function_ret_tyty;\n+    infered = lhs->unify (rhs);\n   }\n \n   void visit (HIR::ComparisonExpr &expr) override\n@@ -1573,6 +1212,196 @@ class TypeCheckExpr : public TypeCheckBase\n     infered = expr_to_convert->cast (tyty_to_convert_to);\n   }\n \n+protected:\n+  bool\n+  resolve_operator_overload (Analysis::RustLangItem::ItemType lang_item_type,\n+\t\t\t     HIR::OperatorExpr &expr, TyTy::BaseType *lhs,\n+\t\t\t     TyTy::BaseType *rhs)\n+  {\n+    // in order to probe of the correct type paths we need the root type, which\n+    // strips any references\n+    const TyTy::BaseType *root = lhs->get_root ();\n+\n+    // look up lang item for arithmetic type\n+    std::vector<PathProbeCandidate> candidates;\n+    std::string associated_item_name\n+      = Analysis::RustLangItem::ToString (lang_item_type);\n+    DefId respective_lang_item_id = UNKNOWN_DEFID;\n+    bool lang_item_defined\n+      = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+    // probe for the lang-item\n+    if (lang_item_defined)\n+      {\n+\tbool receiver_is_type_param\n+\t  = root->get_kind () == TyTy::TypeKind::PARAM;\n+\tbool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n+\n+\tbool receiver_is_generic = receiver_is_type_param || receiver_is_dyn;\n+\tbool probe_bounds = true;\n+\tbool probe_impls = !receiver_is_generic;\n+\tbool ignore_mandatory_trait_items = !receiver_is_generic;\n+\n+\tcandidates = PathProbeType::Probe (\n+\t  root, HIR::PathIdentSegment (associated_item_name), probe_impls,\n+\t  probe_bounds, ignore_mandatory_trait_items, respective_lang_item_id);\n+      }\n+\n+    // autoderef\n+    std::vector<Adjustment> adjustments;\n+    PathProbeCandidate *resolved_candidate\n+      = MethodResolution::Select (candidates, lhs, adjustments);\n+\n+    // is this the case we are recursive\n+    // handle the case where we are within the impl block for this lang_item\n+    // otherwise we end up with a recursive operator overload such as the i32\n+    // operator overload trait\n+    if (lang_item_defined && resolved_candidate != nullptr)\n+      {\n+\tTypeCheckContextItem &fn_context = context->peek_context ();\n+\tif (fn_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n+\t  {\n+\t    auto &impl_item = fn_context.get_impl_item ();\n+\t    HIR::ImplBlock *parent = impl_item.first;\n+\t    HIR::Function *fn = impl_item.second;\n+\n+\t    if (parent->has_trait_ref ()\n+\t\t&& fn->get_function_name ().compare (associated_item_name) == 0)\n+\t      {\n+\t\tTraitReference *trait_reference\n+\t\t  = TraitResolver::Lookup (*parent->get_trait_ref ().get ());\n+\t\tif (!trait_reference->is_error ())\n+\t\t  {\n+\t\t    TyTy::BaseType *lookup = nullptr;\n+\t\t    bool ok\n+\t\t      = context->lookup_type (fn->get_mappings ().get_hirid (),\n+\t\t\t\t\t      &lookup);\n+\t\t    rust_assert (ok);\n+\t\t    rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+\t\t    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n+\t\t    rust_assert (fntype->is_method ());\n+\n+\t\t    Adjuster adj (lhs);\n+\t\t    TyTy::BaseType *adjusted = adj.adjust_type (adjustments);\n+\n+\t\t    bool is_lang_item_impl\n+\t\t      = trait_reference->get_mappings ().get_defid ()\n+\t\t\t== respective_lang_item_id;\n+\t\t    bool self_is_lang_item_self\n+\t\t      = fntype->get_self_type ()->is_equal (*adjusted);\n+\t\t    bool recursive_operator_overload\n+\t\t      = is_lang_item_impl && self_is_lang_item_self;\n+\n+\t\t    lang_item_defined = !recursive_operator_overload;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+    bool have_implementation_for_lang_item = resolved_candidate != nullptr;\n+    if (!lang_item_defined || !have_implementation_for_lang_item)\n+      {\n+\t// no operator overload exists for this\n+\treturn false;\n+      }\n+\n+    // now its just like a method-call-expr\n+    context->insert_receiver (expr.get_mappings ().get_hirid (), lhs);\n+\n+    // store the adjustments for code-generation to know what to do\n+    context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\tstd::move (adjustments));\n+\n+    TyTy::BaseType *lookup_tyty = resolved_candidate->ty;\n+    NodeId resolved_node_id\n+      = resolved_candidate->is_impl_candidate ()\n+\t  ? resolved_candidate->item.impl.impl_item->get_impl_mappings ()\n+\t      .get_nodeid ()\n+\t  : resolved_candidate->item.trait.item_ref->get_mappings ()\n+\t      .get_nodeid ();\n+\n+    rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+    TyTy::BaseType *lookup = lookup_tyty;\n+    TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+    rust_assert (fn->is_method ());\n+\n+    if (root->get_kind () == TyTy::TypeKind::ADT)\n+      {\n+\tconst TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n+\tif (adt->has_substitutions () && fn->needs_substitution ())\n+\t  {\n+\t    // consider the case where we have:\n+\t    //\n+\t    // struct Foo<X,Y>(X,Y);\n+\t    //\n+\t    // impl<T> Foo<T, i32> {\n+\t    //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n+\t    // }\n+\t    //\n+\t    // In this case we end up with an fn type of:\n+\t    //\n+\t    // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n+\t    //\n+\t    // This means the instance or self we are calling this method for\n+\t    // will be substituted such that we can get the inherited type\n+\t    // arguments but then need to use the turbo fish if available or\n+\t    // infer the remaining arguments. Luckily rust does not allow for\n+\t    // default types GenericParams on impl blocks since these must\n+\t    // always be at the end of the list\n+\n+\t    auto s = fn->get_self_type ()->get_root ();\n+\t    rust_assert (s->can_eq (adt, false, false));\n+\t    rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n+\t    const TyTy::ADTType *self_adt\n+\t      = static_cast<const TyTy::ADTType *> (s);\n+\n+\t    // we need to grab the Self substitutions as the inherit type\n+\t    // parameters for this\n+\t    if (self_adt->needs_substitution ())\n+\t      {\n+\t\trust_assert (adt->was_substituted ());\n+\n+\t\tTyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n+\t\t  = GetUsedSubstArgs::From (adt);\n+\n+\t\tTyTy::SubstitutionArgumentMappings inherit_type_args\n+\t\t  = self_adt->solve_mappings_from_receiver_for_self (\n+\t\t    used_args_in_prev_segment);\n+\n+\t\t// there may or may not be inherited type arguments\n+\t\tif (!inherit_type_args.is_error ())\n+\t\t  {\n+\t\t    // need to apply the inherited type arguments to the\n+\t\t    // function\n+\t\t    lookup = fn->handle_substitions (inherit_type_args);\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+    // type check the arguments\n+    TyTy::FnType *type = static_cast<TyTy::FnType *> (lookup);\n+    rust_assert (type->num_params () == 2);\n+    auto fnparam = type->param_at (1);\n+    fnparam.second->unify (rhs); // typecheck the rhs\n+\n+    // get the return type\n+    TyTy::BaseType *function_ret_tyty = fn->get_return_type ()->clone ();\n+\n+    // store the expected fntype\n+    context->insert_operator_overload (expr.get_mappings ().get_hirid (), type);\n+\n+    // set up the resolved name on the path\n+    resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t    resolved_node_id);\n+\n+    // return the result of the function back\n+    infered = function_ret_tyty;\n+\n+    return true;\n+  }\n+\n private:\n   TypeCheckExpr (bool inside_loop)\n     : TypeCheckBase (), infered (nullptr), infered_array_elems (nullptr),"}]}