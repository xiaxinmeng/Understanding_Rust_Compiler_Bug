{"sha": "4a2caf6ced93a63e1703870ed67385d3f89da474", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGEyY2FmNmNlZDkzYTYzZTE3MDM4NzBlZDY3Mzg1ZDNmODlkYTQ3NA==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2015-03-10T09:50:41Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2015-03-10T09:50:41Z"}, "message": "re PR target/65296 ([avr] fix various issues with specs file generation)\n\n\tPR target/65296\n\t* config.gcc (extra_options) [avr]: Remove.\n\t(extra_gcc_objs) [avr]: Use driver-avr.o, avr-devices.o.\n\t(tm_file) [avr]: Add avr/specs.h after avr/avr.h.\n\t(tm_defines) [avr-*-rtems*]: Add WITH_RTEMS.\n\t* config/avr/avr.opt (config/avr/avr-arch.h): Remove include.\n\t(-mmcu=): Add Var and MissingArgError properties.\n\t(-march=): Remove.\n\t* config/avr/genmultilib.awk: Use -mmcu= instead of -march=.\n\t* config/avr/t-multilib: Regenerate.\n\t* config/avr/specs.h: New file.\n\t* config/avr/driver-avr.c: New file.\n\t* config/avr/genopt.sh: Remove file.\n\t* config/avr/avr-tables.opt: Remove file.\n\t* config/avr/predicates.md (avr_current_arch): Rename to avr_arch.\n\t* config/avr/avr-c.c: Same.\n\t* avr-arch.h: Same.\n\t(avr_current_device): Remove proto.\n\t* config/avr/avr.h (avr_current_arch): Rename to avr_arch.\n\t(AVR_HAVE_8BIT_SP): Don't depend on avr_current_device.\n\t(EXTRA_SPEC_FUNCTIONS): Define.\n\t(avr_devicespecs_file): New specs function proto.\n\t(DRIVER_SELF_SPECS): Use device-specs-file spec function.\n\t* config/avr/avr.c (avr_current_arch): Rename to avr_arch.\n\t(avr_current_device): Remove definition and usage.\u0007\n\t(avr_set_core_architecture): New static function.\n\t(avr_option_override): Use it.\n\t* config/avr/avr-devices.c (diagnostic.h, avr-arch.h): Include them.\n\t(mcu_name): New static array.\n\t(comparator, avr_archs_str, avr_mcus_str): New static functions.\n\t(avr_inform_devices, avr_inform_core_architectures): New functions.\n\t* config/avr/gen-avr-mmcu-specs.c (avr-arch.h, specs.h): Include.\n\t(avrlibc.h) [WITH_AVRLIBC]: Include.\n\t(../rtems.h, rtems.h) [WITH_RTEMS]: Include.\n\t(print_mcu): Rewrite from scratch.\n\t* config/avr/avrlibc.h (LIB_SPEC, LIBGCC_SPEC, STARTFILE_SPEC):\n\tForward to avr-specific specs defined in device-specs file.\n\t* config/avr/t-avr (driver-avr.o): New rule.\n\t(avr-devices.o): Depend on avr-arch.h.\n\t(avr-mcus): No more depend on avr-tables.opt.\n\t(avr-tables.opt): Remove rule.\n\t(install-device-specs): Use INSTALL_DATA, not INSTALL_PROGRAM.\n\nFrom-SVN: r221316", "tree": {"sha": "fa8390902e4ef79ccff88b2c2384679848448dc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa8390902e4ef79ccff88b2c2384679848448dc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a2caf6ced93a63e1703870ed67385d3f89da474", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a2caf6ced93a63e1703870ed67385d3f89da474", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a2caf6ced93a63e1703870ed67385d3f89da474", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a2caf6ced93a63e1703870ed67385d3f89da474/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "768fbdd49e8535486ea71eebc507c3b813521a1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/768fbdd49e8535486ea71eebc507c3b813521a1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/768fbdd49e8535486ea71eebc507c3b813521a1b"}], "stats": {"total": 1008, "additions": 659, "deletions": 349}, "files": [{"sha": "357d629fccccf2ea2e90fed9a303f38e6d70f14e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a2caf6ced93a63e1703870ed67385d3f89da474", "patch": "@@ -1,3 +1,49 @@\n+2015-03-10  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/65296\n+\t* config.gcc (extra_options) [avr]: Remove.\n+\t(extra_gcc_objs) [avr]: Use driver-avr.o, avr-devices.o.\n+\t(tm_file) [avr]: Add avr/specs.h after avr/avr.h.\n+\t(tm_defines) [avr-*-rtems*]: Add WITH_RTEMS.\n+\n+\t* config/avr/avr.opt (config/avr/avr-arch.h): Remove include.\n+\t(-mmcu=): Add Var and MissingArgError properties.\n+\t(-march=): Remove.\n+\t* config/avr/genmultilib.awk: Use -mmcu= instead of -march=.\n+\t* config/avr/t-multilib: Regenerate.\n+\t* config/avr/specs.h: New file.\n+\t* config/avr/driver-avr.c: New file.\n+\t* config/avr/genopt.sh: Remove file.\n+\t* config/avr/avr-tables.opt: Remove file.\n+\t* config/avr/predicates.md (avr_current_arch): Rename to avr_arch.\n+\t* config/avr/avr-c.c: Same.\n+\t* avr-arch.h: Same.\n+\t(avr_current_device): Remove proto.\n+\t* config/avr/avr.h (avr_current_arch): Rename to avr_arch.\n+\t(AVR_HAVE_8BIT_SP): Don't depend on avr_current_device.\n+\t(EXTRA_SPEC_FUNCTIONS): Define.\n+\t(avr_devicespecs_file): New specs function proto.\n+\t(DRIVER_SELF_SPECS): Use device-specs-file spec function.\n+\t* config/avr/avr.c (avr_current_arch): Rename to avr_arch.\n+\t(avr_current_device): Remove definition and usage.\u0007\n+\t(avr_set_core_architecture): New static function.\n+\t(avr_option_override): Use it.\n+\t* config/avr/avr-devices.c (diagnostic.h, avr-arch.h): Include them.\n+\t(mcu_name): New static array.\n+\t(comparator, avr_archs_str, avr_mcus_str): New static functions.\n+\t(avr_inform_devices, avr_inform_core_architectures): New functions.\n+\t* config/avr/gen-avr-mmcu-specs.c (avr-arch.h, specs.h): Include.\n+\t(avrlibc.h) [WITH_AVRLIBC]: Include.\n+\t(../rtems.h, rtems.h) [WITH_RTEMS]: Include.\n+\t(print_mcu): Rewrite from scratch.\n+\t* config/avr/avrlibc.h (LIB_SPEC, LIBGCC_SPEC, STARTFILE_SPEC):\n+\tForward to avr-specific specs defined in device-specs file.\n+\t* config/avr/t-avr (driver-avr.o): New rule.\n+\t(avr-devices.o): Depend on avr-arch.h.\n+\t(avr-mcus): No more depend on avr-tables.opt.\n+\t(avr-tables.opt): Remove rule.\n+\t(install-device-specs): Use INSTALL_DATA, not INSTALL_PROGRAM.\n+\n 2015-03-10  Ilya Enkovich  <ilya.enkovich@intel.com>\n \n \t* c-family/c.opt (fchkp-use-wrappers): New."}, {"sha": "cb08a5cc58db53bef2167fe5678a589fd447c248", "filename": "gcc/config.gcc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=4a2caf6ced93a63e1703870ed67385d3f89da474", "patch": "@@ -330,7 +330,6 @@ avr-*-*)\n \tcpu_type=avr\n \tc_target_objs=\"avr-c.o\"\n \tcxx_target_objs=\"avr-c.o\"\n-\textra_options=\"${extra_options} avr/avr-tables.opt\"\n \t;;\n bfin*-*)\n \tcpu_type=bfin\n@@ -1090,18 +1089,21 @@ arm*-*-eabi* | arm*-*-symbianelf* | arm*-*-rtems*)\n \ttm_file=\"${tm_file} arm/aout.h vxworks-dummy.h arm/arm.h\"\n \t;;\n avr-*-rtems*)\n-\ttm_file=\"elfos.h avr/elf.h avr/avr-arch.h avr/avr.h dbxelf.h avr/rtems.h rtems.h newlib-stdint.h\"\n+\ttm_file=\"elfos.h avr/elf.h avr/avr-arch.h avr/avr.h avr/specs.h dbxelf.h avr/rtems.h rtems.h newlib-stdint.h\"\n+\ttm_defines=\"${tm_defines} WITH_RTEMS\"\n \ttmake_file=\"${tmake_file} avr/t-avr avr/t-multilib avr/t-rtems\"\n+\textra_gcc_objs=\"driver-avr.o avr-devices.o\"\n \textra_objs=\"avr-devices.o avr-log.o\"\n \t;;\n avr-*-*)\n-\ttm_file=\"elfos.h avr/elf.h avr/avr-arch.h avr/avr.h dbxelf.h avr/avr-stdint.h\"\n+\ttm_file=\"elfos.h avr/elf.h avr/avr-arch.h avr/avr.h avr/specs.h dbxelf.h avr/avr-stdint.h\"\n \tif test x${with_avrlibc} != xno; then\n \t    tm_file=\"${tm_file} ${cpu_type}/avrlibc.h\"\n \t    tm_defines=\"${tm_defines} WITH_AVRLIBC\"\n \tfi\n \ttmake_file=\"${tmake_file} avr/t-avr avr/t-multilib\"\n \tuse_gcc_stdint=wrap\n+\textra_gcc_objs=\"driver-avr.o avr-devices.o\"\n \textra_objs=\"avr-devices.o avr-log.o\"\n \t;;\n bfin*-elf*)"}, {"sha": "baf780beb486bca20c1c7fa08dce2810e0831a0e", "filename": "gcc/config/avr/avr-arch.h", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Favr-arch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Favr-arch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-arch.h?ref=4a2caf6ced93a63e1703870ed67385d3f89da474", "patch": "@@ -22,9 +22,11 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef AVR_ARCH_H\n #define AVR_ARCH_H\n \n+#define AVR_MMCU_DEFAULT \"avr2\"\n+\n /* This enum supplies indices into the avr_arch_types[] table below. */\n \n-enum avr_arch\n+enum avr_arch_id\n {\n   ARCH_UNKNOWN,\n   ARCH_AVR1,\n@@ -92,7 +94,7 @@ typedef struct\n   const char *const macro;\n \n   /* Architecture name.  */\n-  const char *const arch_name;\n+  const char *const name;\n } avr_arch_t;\n \n \n@@ -104,7 +106,7 @@ typedef struct\n   const char *const name;\n \n   /* Index in avr_arch_types[].  */\n-  enum avr_arch arch;\n+  enum avr_arch_id arch_id;\n \n   /* device specific feature */\n   int dev_attribute;\n@@ -166,7 +168,7 @@ enum avr_device_specific_features\n typedef struct\n {\n   /* Architecture ID.  */\n-  enum avr_arch arch;\n+  enum avr_arch_id arch_id;\n \n   /* textinfo source to describe the archtiecture.  */\n   const char *texinfo;\n@@ -175,9 +177,11 @@ typedef struct\n /* Preprocessor macros to define depending on MCU type.  */\n \n extern const avr_arch_t avr_arch_types[];\n-extern const avr_arch_t *avr_current_arch;\n+extern const avr_arch_t *avr_arch;\n \n extern const avr_mcu_t avr_mcu_types[];\n-extern const avr_mcu_t *avr_current_device;\n+\n+extern void avr_inform_devices (void);\n+extern void avr_inform_core_architectures (void);\n \n #endif /* AVR_ARCH_H */"}, {"sha": "351982f1179cb312d36c55c3861147d5aef1cec1", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=4a2caf6ced93a63e1703870ed67385d3f89da474", "patch": "@@ -305,8 +305,11 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n \n   builtin_define_std (\"AVR\");\n \n-  if (avr_current_arch->macro)\n-    cpp_define_formatted (pfile, \"__AVR_ARCH__=%s\", avr_current_arch->macro);\n+  /* __AVR_DEVICE_NAME__ and  avr_mcu_types[].macro like __AVR_ATmega8__\n+\t are defined by -D command option, see device-specs file.  */\n+\n+  if (avr_arch->macro)\n+    cpp_define_formatted (pfile, \"__AVR_ARCH__=%s\", avr_arch->macro);\n   if (AVR_HAVE_RAMPD)    cpp_define (pfile, \"__AVR_HAVE_RAMPD__\");\n   if (AVR_HAVE_RAMPX)    cpp_define (pfile, \"__AVR_HAVE_RAMPX__\");\n   if (AVR_HAVE_RAMPY)    cpp_define (pfile, \"__AVR_HAVE_RAMPY__\");\n@@ -316,14 +319,14 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n   if (AVR_HAVE_MOVW)     cpp_define (pfile, \"__AVR_HAVE_MOVW__\");\n   if (AVR_HAVE_LPMX)     cpp_define (pfile, \"__AVR_HAVE_LPMX__\");\n \n-  if (avr_current_arch->asm_only)\n+  if (avr_arch->asm_only)\n     cpp_define (pfile, \"__AVR_ASM_ONLY__\");\n   if (AVR_HAVE_MUL)\n     {\n       cpp_define (pfile, \"__AVR_ENHANCED__\");\n       cpp_define (pfile, \"__AVR_HAVE_MUL__\");\n     }\n-  if (avr_current_arch->have_jmp_call)\n+  if (avr_arch->have_jmp_call)\n     {\n       cpp_define (pfile, \"__AVR_MEGA__\");\n       cpp_define (pfile, \"__AVR_HAVE_JMP_CALL__\");\n@@ -347,7 +350,7 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n       cpp_define (pfile, \"__AVR_TINY_PM_BASE_ADDRESS__=0x4000\");\n     }\n \n-  if (avr_current_arch->have_eijmp_eicall)\n+  if (AVR_HAVE_EIJMP_EICALL)\n     {\n       cpp_define (pfile, \"__AVR_HAVE_EIJMP_EICALL__\");\n       cpp_define (pfile, \"__AVR_3_BYTE_PC__\");\n@@ -362,11 +365,10 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n   else\n     cpp_define (pfile, \"__AVR_HAVE_16BIT_SP__\");\n \n-  if (avr_sp8)\n-    cpp_define (pfile, \"__AVR_SP8__\");\n-\n   if (AVR_HAVE_SPH)\n     cpp_define (pfile, \"__AVR_HAVE_SPH__\");\n+  else\n+    cpp_define (pfile, \"__AVR_SP8__\");\n \n   if (TARGET_NO_INTERRUPTS)\n     cpp_define (pfile, \"__NO_INTERRUPTS__\");\n@@ -375,15 +377,15 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n     {\n       cpp_define (pfile, \"__AVR_ERRATA_SKIP__\");\n \n-      if (avr_current_arch->have_jmp_call)\n+      if (AVR_HAVE_JMP_CALL)\n         cpp_define (pfile, \"__AVR_ERRATA_SKIP_JMP_CALL__\");\n     }\n \n   if (TARGET_RMW)\n     cpp_define (pfile, \"__AVR_ISA_RMW__\");\n \n   cpp_define_formatted (pfile, \"__AVR_SFR_OFFSET__=0x%x\",\n-                        avr_current_arch->sfr_offset);\n+                        avr_arch->sfr_offset);\n \n #ifdef WITH_AVRLIBC\n   cpp_define (pfile, \"__WITH_AVRLIBC__\");"}, {"sha": "082e789f6f830fabb857f2738b14ea5519fd04ca", "filename": "gcc/config/avr/avr-devices.c", "status": "modified", "additions": 99, "deletions": 1, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Favr-devices.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Favr-devices.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-devices.c?ref=4a2caf6ced93a63e1703870ed67385d3f89da474", "patch": "@@ -21,17 +21,20 @@\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"diagnostic.h\"\n #include \"tm.h\"\n #endif /* IN_GEN_AVR_MMCU_TEXI */\n \n+#include \"avr-arch.h\"\n+\n /* List of all known AVR MCU architectures.\n    Order as of enum avr_arch from avr.h.  */\n \n const avr_arch_t\n avr_arch_types[] =\n {\n   /* unknown device specified */\n-  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, NULL,  \"avr2\"  },\n+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, NULL, AVR_MMCU_DEFAULT },\n   /*\n     A  M  J  LM E  E  E  X  R  T  d S   S O   A\n     S  U  M  PO L  L  I  M  A  I  a t   F ff  r\n@@ -116,3 +119,98 @@ avr_mcu_types[] =\n   { NULL, ARCH_UNKNOWN, AVR_ISA_NONE, NULL, 0, 0, 0, NULL }\n };\n \n+\n+\f\n+\n+#ifndef IN_GEN_AVR_MMCU_TEXI\n+\n+/* Copy-pastes from `gen-avr-mmcu-texi.c' follow...  */\n+\n+static const char*\n+mcu_name[sizeof avr_mcu_types / sizeof avr_mcu_types[0]];\n+\n+static int\n+comparator (const void *va, const void *vb)\n+{\n+  const char *a = *(const char* const*) va;\n+  const char *b = *(const char* const*) vb;\n+\n+  while (*a && *b)\n+    {\n+      /* Make letters smaller than digits so that `atmega16a' follows\n+         `atmega16' without `atmega161' etc. between them.  */\n+      \n+      if (ISALPHA (*a) && ISDIGIT (*b))\n+        return -1;\n+\n+      if (ISDIGIT (*a) && ISALPHA (*b))\n+        return 1;\n+\n+      if (*a != *b)\n+        return *a - *b;\n+      \n+      a++;\n+      b++;\n+    }\n+\n+  return *a - *b;\n+}\n+\n+\n+static char*\n+avr_archs_str (void)\n+{\n+  char *archs = concat (\"\", NULL);\n+\n+  // Build of core architectures' names.\n+\n+  for (const avr_mcu_t *mcu = avr_mcu_types; mcu->name; mcu++)\n+    if (!mcu->macro)\n+      archs = concat (archs, \" \", avr_arch_types[mcu->arch_id].name, NULL);\n+\n+  return archs;\n+}\n+\n+  \n+static char*\n+avr_mcus_str (void)\n+{\n+  size_t n_mcus = 0;\n+  char *mcus = concat (\"\", NULL);\n+\n+  // Build array of proper devices' names.\n+\n+  for (const avr_mcu_t *mcu = avr_mcu_types; mcu->name; mcu++)\n+    if (mcu->macro)\n+      mcu_name[n_mcus++] = mcu->name;\n+\n+  // Sort MCUs so that they are displayed in the same canonical order as\n+  // in doc/avr-mcus.texi.\n+\n+  qsort (mcu_name, n_mcus, sizeof (char*), comparator);\n+\n+  for (size_t i = 0; i < n_mcus; i++)\n+    mcus = concat (mcus, \" \", mcu_name[i], NULL);\n+\n+  return mcus;\n+}\n+\n+\n+void\n+avr_inform_devices (void)\n+{\n+  char *mcus = avr_mcus_str ();\n+  inform (input_location, \"devices natively supported:%s\", mcus);\n+  free (mcus);\n+}\n+\n+\n+void\n+avr_inform_core_architectures (void)\n+{\n+  char *archs = avr_archs_str ();\n+  inform (input_location, \"supported core architectures:%s\", archs);\n+  free (archs);\n+}\n+\n+#endif // IN_GEN_AVR_MMCU_TEXI"}, {"sha": "547f785b06ee1d4bcf5d2d6b45c0534a38e47807", "filename": "gcc/config/avr/avr-mcus.def", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Favr-mcus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Favr-mcus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-mcus.def?ref=4a2caf6ced93a63e1703870ed67385d3f89da474", "patch": "@@ -24,11 +24,10 @@\n    This will regenerate / update the following source files:\n \n    -  $(srcdir)/config/avr/t-multilib\n-   -  $(srcdir)/config/avr/avr-tables.opt\n    -  $(srcdir)/doc/avr-mmcu.texi\n \n    After that, rebuild everything and check-in the new sources to the repo.\n-   The device list below has to be kept in sync with AVR-LibC.\n+   The device list below should be kept in sync with AVR-LibC.\n \n \n    Before including this file, define a macro:\n@@ -53,8 +52,7 @@\n \n        N_FLASH       Number of 64 KiB flash segments, rounded up.\n \n-       LIBRARY_NAME  Used by the driver to linke startup code from avr-libc\n-                     as of  crt<LIBRARY_NAME>.o\n+       LIBRARY_NAME  Used to define __AVR_DEV_LIB_NAME__.\n \n    \"avr2\" must be first for the \"0\" default to work as intended.  */\n "}, {"sha": "66e54fc683f1104866e0fa6d32b35c66543ca803", "filename": "gcc/config/avr/avr-tables.opt", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768fbdd49e8535486ea71eebc507c3b813521a1b/gcc%2Fconfig%2Favr%2Favr-tables.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768fbdd49e8535486ea71eebc507c3b813521a1b/gcc%2Fconfig%2Favr%2Favr-tables.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-tables.opt?ref=768fbdd49e8535486ea71eebc507c3b813521a1b", "patch": "@@ -1,73 +0,0 @@\n-; -*- buffer-read-only: t -*-\n-; Generated automatically by genopt.sh from avr-mcus.def.\n-\n-; Copyright (C) 2011-2015 Free Software Foundation, Inc.\n-;\n-; This file is part of GCC.\n-;\n-; GCC is free software; you can redistribute it and/or modify it under\n-; the terms of the GNU General Public License as published by the Free\n-; Software Foundation; either version 3, or (at your option) any later\n-; version.\n-;\n-; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-; for more details.\n-;\n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING3.  If not see\n-; <http://www.gnu.org/licenses/>.\n-\n-Enum\n-Name(avr_arch) Type(enum avr_arch)\n-Known MCU architectures:\n-\n-EnumValue\n-Enum(avr_arch) String(avr2) Value(ARCH_AVR2)\n-\n-EnumValue\n-Enum(avr_arch) String(avr25) Value(ARCH_AVR25)\n-\n-EnumValue\n-Enum(avr_arch) String(avr3) Value(ARCH_AVR3)\n-\n-EnumValue\n-Enum(avr_arch) String(avr31) Value(ARCH_AVR31)\n-\n-EnumValue\n-Enum(avr_arch) String(avr35) Value(ARCH_AVR35)\n-\n-EnumValue\n-Enum(avr_arch) String(avr4) Value(ARCH_AVR4)\n-\n-EnumValue\n-Enum(avr_arch) String(avr5) Value(ARCH_AVR5)\n-\n-EnumValue\n-Enum(avr_arch) String(avr51) Value(ARCH_AVR51)\n-\n-EnumValue\n-Enum(avr_arch) String(avr6) Value(ARCH_AVR6)\n-\n-EnumValue\n-Enum(avr_arch) String(avrxmega2) Value(ARCH_AVRXMEGA2)\n-\n-EnumValue\n-Enum(avr_arch) String(avrxmega4) Value(ARCH_AVRXMEGA4)\n-\n-EnumValue\n-Enum(avr_arch) String(avrxmega5) Value(ARCH_AVRXMEGA5)\n-\n-EnumValue\n-Enum(avr_arch) String(avrxmega6) Value(ARCH_AVRXMEGA6)\n-\n-EnumValue\n-Enum(avr_arch) String(avrxmega7) Value(ARCH_AVRXMEGA7)\n-\n-EnumValue\n-Enum(avr_arch) String(avrtiny) Value(ARCH_AVRTINY)\n-\n-EnumValue\n-Enum(avr_arch) String(avr1) Value(ARCH_AVR1)\n-"}, {"sha": "68d5ddc9ee79dd2026aebbc9a55fa753c92e5ede", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 66, "deletions": 43, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=4a2caf6ced93a63e1703870ed67385d3f89da474", "patch": "@@ -234,10 +234,7 @@ static GTY(()) rtx xstring_empty;\n static GTY(()) rtx xstring_e;\n \n /* Current architecture.  */\n-const avr_arch_t *avr_current_arch;\n-\n-/* Current device.  */\n-const avr_mcu_t *avr_current_device;\n+const avr_arch_t *avr_arch;\n \n /* Section to put switch tables in.  */\n static GTY(()) section *progmem_swtable_section;\n@@ -380,6 +377,49 @@ avr_register_passes (void)\n }\n \n \n+/* Set `avr_arch' as specified by `-mmcu='.\n+   Return true on success.  */\n+\n+static bool\n+avr_set_core_architecture (void)\n+{\n+  /* Search for mcu core architecture.  */\n+\n+  if (!avr_mmcu)\n+    avr_mmcu = AVR_MMCU_DEFAULT;\n+\n+  avr_arch = &avr_arch_types[0];\n+\n+  for (const avr_mcu_t *mcu = avr_mcu_types; ; mcu++)\n+    {\n+      if (NULL == mcu->name)\n+        {\n+          /* Reached the end of `avr_mcu_types'.  This should actually never\n+             happen as options are provided by device-specs.  It could be a\n+             typo in a device-specs or calling the compiler proper directly\n+             with -mmcu=<device>. */\n+\n+          error (\"unknown core architecture %qs specified with %qs\",\n+                 avr_mmcu, \"-mmcu=\");\n+          avr_inform_core_architectures ();\n+          break;\n+        }\n+      else if (0 == strcmp (mcu->name, avr_mmcu)\n+               // Is this a proper architecture ? \n+               && NULL == mcu->macro)\n+        {\n+          avr_arch = &avr_arch_types[mcu->arch_id];\n+          if (avr_n_flash < 0)\n+            avr_n_flash = mcu->n_flash;\n+\n+          return true;\n+        }\n+    }\n+\n+  return false;\n+}\n+\n+\n /* Implement `TARGET_OPTION_OVERRIDE'.  */\n \n static void\n@@ -424,39 +464,24 @@ avr_option_override (void)\n   if (flag_pie == 2)\n     warning (OPT_fPIE, \"-fPIE is not supported\");\n \n-  /* Search for mcu arch.\n-     ??? We should probably just put the architecture-default device\n-     settings in the architecture struct and remove any notion of a current\n-     device from gcc.  */\n-\n-  for (avr_current_device = avr_mcu_types; ; avr_current_device++)\n-    {\n-      if (!avr_current_device->name)\n-        fatal_error (input_location, \"mcu not found\");\n-      if (!avr_current_device->macro\n-          && avr_current_device->arch == avr_arch_index)\n-        break;\n-    }\n-\n-  avr_current_arch = &avr_arch_types[avr_arch_index];\n-  if (avr_n_flash < 0)\n-    avr_n_flash = avr_current_device->n_flash;\n+  if (!avr_set_core_architecture())\n+    return;\n \n   /* RAM addresses of some SFRs common to all devices in respective arch. */\n \n   /* SREG: Status Register containing flags like I (global IRQ) */\n-  avr_addr.sreg = 0x3F + avr_current_arch->sfr_offset;\n+  avr_addr.sreg = 0x3F + avr_arch->sfr_offset;\n \n   /* RAMPZ: Address' high part when loading via ELPM */\n-  avr_addr.rampz = 0x3B + avr_current_arch->sfr_offset;\n+  avr_addr.rampz = 0x3B + avr_arch->sfr_offset;\n \n-  avr_addr.rampy = 0x3A + avr_current_arch->sfr_offset;\n-  avr_addr.rampx = 0x39 + avr_current_arch->sfr_offset;\n-  avr_addr.rampd = 0x38 + avr_current_arch->sfr_offset;\n-  avr_addr.ccp = (AVR_TINY ? 0x3C : 0x34) + avr_current_arch->sfr_offset;\n+  avr_addr.rampy = 0x3A + avr_arch->sfr_offset;\n+  avr_addr.rampx = 0x39 + avr_arch->sfr_offset;\n+  avr_addr.rampd = 0x38 + avr_arch->sfr_offset;\n+  avr_addr.ccp = (AVR_TINY ? 0x3C : 0x34) + avr_arch->sfr_offset;\n \n   /* SP: Stack Pointer (SP_H:SP_L) */\n-  avr_addr.sp_l = 0x3D + avr_current_arch->sfr_offset;\n+  avr_addr.sp_l = 0x3D + avr_arch->sfr_offset;\n   avr_addr.sp_h = avr_addr.sp_l + 1;\n \n   init_machine_status = avr_init_machine_status;\n@@ -2328,7 +2353,7 @@ avr_print_operand (FILE *file, rtx x, int code)\n           else\n             {\n               fprintf (file, HOST_WIDE_INT_PRINT_HEX,\n-                       ival - avr_current_arch->sfr_offset);\n+                       ival - avr_arch->sfr_offset);\n             }\n         }\n       else\n@@ -2396,7 +2421,7 @@ avr_print_operand (FILE *file, rtx x, int code)\n     {\n       if (GET_CODE (x) == SYMBOL_REF && (SYMBOL_REF_FLAGS (x) & SYMBOL_FLAG_IO))\n \tavr_print_operand_address\n-\t  (file, plus_constant (HImode, x, -avr_current_arch->sfr_offset));\n+\t  (file, plus_constant (HImode, x, -avr_arch->sfr_offset));\n       else\n \tfatal_insn (\"bad address, not an I/O address:\", x);\n     }\n@@ -9246,12 +9271,11 @@ avr_pgm_check_var_decl (tree node)\n       if (avr_addrspace[as].segment >= avr_n_flash)\n         {\n           if (TYPE_P (node))\n-            error (\"%qT uses address space %qs beyond flash of %qs\",\n-                   node, avr_addrspace[as].name, avr_current_device->name);\n+            error (\"%qT uses address space %qs beyond flash of %d KiB\",\n+                   node, avr_addrspace[as].name, avr_n_flash);\n           else\n-            error (\"%s %q+D uses address space %qs beyond flash of %qs\",\n-                   reason, node, avr_addrspace[as].name,\n-                   avr_current_device->name);\n+            error (\"%s %q+D uses address space %qs beyond flash of %d KiB\",\n+                   reason, node, avr_addrspace[as].name, avr_n_flash);\n         }\n       else\n         {\n@@ -9297,15 +9321,14 @@ avr_insert_attributes (tree node, tree *attributes)\n \n       if (avr_addrspace[as].segment >= avr_n_flash)\n         {\n-          error (\"variable %q+D located in address space %qs\"\n-                 \" beyond flash of %qs\",\n-                 node, avr_addrspace[as].name, avr_current_device->name);\n+          error (\"variable %q+D located in address space %qs beyond flash \"\n+                 \"of %d KiB\", node, avr_addrspace[as].name, avr_n_flash);\n         }\n       else if (!AVR_HAVE_LPM && avr_addrspace[as].pointer_size > 2)\n \t{\n           error (\"variable %q+D located in address space %qs\"\n-                 \" which is not supported by %qs\",\n-                 node, avr_addrspace[as].name, avr_current_arch->arch_name);\n+                 \" which is not supported for architecture %qs\",\n+                 node, avr_addrspace[as].name, avr_arch->name);\n \t}\n \n       if (!TYPE_READONLY (node0)\n@@ -9723,10 +9746,10 @@ avr_asm_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align)\n static void\n avr_file_start (void)\n {\n-  int sfr_offset = avr_current_arch->sfr_offset;\n+  int sfr_offset = avr_arch->sfr_offset;\n \n-  if (avr_current_arch->asm_only)\n-    error (\"MCU %qs supported for assembler only\", avr_current_device->name);\n+  if (avr_arch->asm_only)\n+    error (\"architecture %qs supported for assembler only\", avr_mmcu);\n \n   default_file_start ();\n "}, {"sha": "9963766fe91a5c5297a524bb260e03b2ea560d3c", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=4a2caf6ced93a63e1703870ed67385d3f89da474", "patch": "@@ -60,19 +60,19 @@ enum\n \n #define TARGET_CPU_CPP_BUILTINS()\tavr_cpu_cpp_builtins (pfile)\n \n-#define AVR_HAVE_JMP_CALL (avr_current_arch->have_jmp_call)\n-#define AVR_HAVE_MUL (avr_current_arch->have_mul)\n-#define AVR_HAVE_MOVW (avr_current_arch->have_movw_lpmx)\n+#define AVR_HAVE_JMP_CALL (avr_arch->have_jmp_call)\n+#define AVR_HAVE_MUL (avr_arch->have_mul)\n+#define AVR_HAVE_MOVW (avr_arch->have_movw_lpmx)\n #define AVR_HAVE_LPM (!AVR_TINY)\n-#define AVR_HAVE_LPMX (avr_current_arch->have_movw_lpmx)\n-#define AVR_HAVE_ELPM (avr_current_arch->have_elpm)\n-#define AVR_HAVE_ELPMX (avr_current_arch->have_elpmx)\n-#define AVR_HAVE_RAMPD (avr_current_arch->have_rampd)\n-#define AVR_HAVE_RAMPX (avr_current_arch->have_rampd)\n-#define AVR_HAVE_RAMPY (avr_current_arch->have_rampd)\n-#define AVR_HAVE_RAMPZ (avr_current_arch->have_elpm             \\\n-                        || avr_current_arch->have_rampd)\n-#define AVR_HAVE_EIJMP_EICALL (avr_current_arch->have_eijmp_eicall)\n+#define AVR_HAVE_LPMX (avr_arch->have_movw_lpmx)\n+#define AVR_HAVE_ELPM (avr_arch->have_elpm)\n+#define AVR_HAVE_ELPMX (avr_arch->have_elpmx)\n+#define AVR_HAVE_RAMPD (avr_arch->have_rampd)\n+#define AVR_HAVE_RAMPX (avr_arch->have_rampd)\n+#define AVR_HAVE_RAMPY (avr_arch->have_rampd)\n+#define AVR_HAVE_RAMPZ (avr_arch->have_elpm             \\\n+                        || avr_arch->have_rampd)\n+#define AVR_HAVE_EIJMP_EICALL (avr_arch->have_eijmp_eicall)\n \n /* Handling of 8-bit SP versus 16-bit SP is as follows:\n \n@@ -90,17 +90,16 @@ FIXME: DRIVER_SELF_SPECS has changed.\n    __AVR_HAVE_8BIT_SP__ and __AVR_HAVE_16BIT_SP__.  During multilib generation\n    there is always __AVR_SP8__ == __AVR_HAVE_8BIT_SP__.  */\n \n-#define AVR_HAVE_8BIT_SP                                 \\\n-  ((avr_current_device->dev_attribute & AVR_SHORT_SP)    \\\n-   || TARGET_TINY_STACK || avr_sp8)\n+#define AVR_HAVE_8BIT_SP                        \\\n+  (TARGET_TINY_STACK || avr_sp8)\n \n #define AVR_HAVE_SPH (!avr_sp8)\n \n #define AVR_2_BYTE_PC (!AVR_HAVE_EIJMP_EICALL)\n #define AVR_3_BYTE_PC (AVR_HAVE_EIJMP_EICALL)\n \n-#define AVR_XMEGA (avr_current_arch->xmega_p)\n-#define AVR_TINY  (avr_current_arch->tiny_p)\n+#define AVR_XMEGA (avr_arch->xmega_p)\n+#define AVR_TINY  (avr_arch->tiny_p)\n \n #define BITS_BIG_ENDIAN 0\n #define BYTES_BIG_ENDIAN 0\n@@ -492,25 +491,24 @@ typedef struct avr_args\n #define ADJUST_INSN_LENGTH(INSN, LENGTH)                \\\n     (LENGTH = avr_adjust_insn_length (INSN, LENGTH))\n \n-#define DRIVER_SELF_SPECS                                       \\\n-  \" %{!mmcu=*:%{!march=*:-specs=device-specs/specs-avr2%s} \"    \\\n-  \"           %{march=*:-specs=device-specs/specs-%*%s}} \"      \\\n-  \" %{mmcu=*:-specs=device-specs/specs-%*%s %<mmcu=*} \"\n+extern const char *avr_devicespecs_file (int, const char**);\n \n-/* We want cc1plus used as a preprocessor to pick up the cpp spec from the\n-   per-device spec files  */\n-#define CPLUSPLUS_CPP_SPEC \"%(cpp)\"\n+#define EXTRA_SPEC_FUNCTIONS                                   \\\n+  { \"device-specs-file\", avr_devicespecs_file },\n \n-#define LIBSTDCXX \"gcc\"\n-/* No libstdc++ for now.  Empty string doesn't work.  */\n+/* Driver self specs has lmited functionality w.r.t. '%s' for dynamic specs.\n+   Apply '%s' to a static string to inflate the file (directory) name which\n+   is used to diagnose problems with reading the specs file.  */\n \n-/* The actual definition will come from the device-specific spec file.  */\n-#define STARTFILE_SPEC \"\"\n+#undef  DRIVER_SELF_SPECS\n+#define DRIVER_SELF_SPECS                       \\\n+  \" %:device-specs-file(device-specs%s %{mmcu=*:%*})\"\n \n-#define ENDFILE_SPEC \"\"\n+/* No libstdc++ for now.  Empty string doesn't work.  */\n+#define LIBSTDCXX \"gcc\"\n \n-/* This is the default without any -mmcu=* option (AT90S*).  */\n-#define MULTILIB_DEFAULTS { \"mmcu=avr2\" }\n+/* This is the default without any -mmcu=* option.  */\n+#define MULTILIB_DEFAULTS { \"mmcu=\" AVR_MMCU_DEFAULT }\n \n #define TEST_HARD_REG_CLASS(CLASS, REGNO) \\\n   TEST_HARD_REG_BIT (reg_class_contents[ (int) (CLASS)], REGNO)"}, {"sha": "d99c56eae60caa621bd693e8d54da6bb3b25997d", "filename": "gcc/config/avr/avr.opt", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Favr.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Favr.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.opt?ref=4a2caf6ced93a63e1703870ed67385d3f89da474", "patch": "@@ -18,21 +18,14 @@\n ; along with GCC; see the file COPYING3.  If not see\n ; <http://www.gnu.org/licenses/>.\n \n-HeaderInclude\n-config/avr/avr-arch.h\n-\n mcall-prologues\n Target Report Mask(CALL_PROLOGUES)\n Use subroutines for function prologues and epilogues\n \n mmcu=\n-Target RejectNegative Joined\n+Target RejectNegative Joined Var(avr_mmcu) MissingArgError(missing device or architecture after %qs)\n -mmcu=MCU\tSelect the target MCU\n \n-march=\n-Target RejectNegative Joined Var(avr_arch_index) Init(ARCH_AVR2) Enum(avr_arch)\n--march=ARCH Select target architecture\n-\n mn-flash=\n Target RejectNegative Joined Var(avr_n_flash) UInteger Init(-1)\n Set the number of 64 KiB flash segments"}, {"sha": "a49ecedd2beb36ecf911a1cd89151b6835537499", "filename": "gcc/config/avr/avrlibc.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Favrlibc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Favrlibc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favrlibc.h?ref=4a2caf6ced93a63e1703870ed67385d3f89da474", "patch": "@@ -27,6 +27,18 @@ along with GCC; see the file COPYING3.  If not see\n    \n */\n \n+#undef  LIB_SPEC\n+#define LIB_SPEC                                \\\n+  \" -lc %(avrlibc_devicelib) \"\n+\n+#undef  LIBGCC_SPEC\n+#define LIBGCC_SPEC                             \\\n+  \" -lgcc -lm \"\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC                          \\\n+  \" %(avrlibc_startfile) \"\n+\n #undef  LINK_GCC_C_SEQUENCE_SPEC\n #define LINK_GCC_C_SEQUENCE_SPEC \\\n   \"--start-group %G %L --end-group\""}, {"sha": "4b39910eb00f04c3d40968d47ed377f108d3959a", "filename": "gcc/config/avr/driver-avr.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Fdriver-avr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Fdriver-avr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fdriver-avr.c?ref=4a2caf6ced93a63e1703870ed67385d3f89da474", "patch": "@@ -0,0 +1,124 @@\n+/* Subroutines for the gcc driver.\n+   Copyright (C) 2009-2015 Free Software Foundation, Inc.\n+   Contributed by Georg-Johann Lay <avr@gjlay.de>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"diagnostic.h\"\n+#include \"tm.h\"\n+\n+static const char dir_separator_str[] = { DIR_SEPARATOR, 0 };\n+\n+static const char specfiles_doc_url[] =\n+  \"http://gcc.gnu.org/onlinedocs/gcc/Spec-Files.html\";\n+\n+\n+static const char*\n+avr_diagnose_devicespecs_error (const char *mcu, const char *filename)\n+{\n+  error (\"cannot access device-specs for %qs expected at %qs\",\n+         mcu, filename);\n+\n+  // Inform about natively supported devices and cores.\n+\n+  if (strncmp (mcu, \"avr\", strlen (\"avr\")))\n+    avr_inform_devices ();\n+\n+  avr_inform_core_architectures ();\n+\n+  inform (input_location, \"you can provide your own specs files, \"\n+          \"see <%s> for details\", specfiles_doc_url);\n+\n+  return \"\";\n+}\n+\n+\n+/* Implement spec function `device-specs-file\u00b4.\n+\n+   Compose -specs=<specs-file-name>.  If everything went well then argv[0]\n+   is the inflated specs directory and argv[1] is a device or core name as\n+   supplied to -mmcu=*.  */\n+\n+const char*\n+avr_devicespecs_file (int argc, const char **argv)\n+{\n+  char *specfile_name;\n+  const char *mmcu = NULL;\n+\n+#ifdef DEBUG_SPECS\n+  if (verbose_flag)\n+    fnotice (stderr, \"Running spec function '%s' with %d args\\n\\n\",\n+             __FUNCTION__, argc);\n+#endif\n+\n+  switch (argc)\n+    {\n+    case 0:\n+      fatal_error (input_location,\n+                   \"bad usage of spec function %qs\", \"device-specs-file\");\n+      return \"\";\n+\n+    case 1:\n+      mmcu = AVR_MMCU_DEFAULT;\n+      break;\n+\n+    case 2:\n+      mmcu = argv[1];\n+      break;\n+\n+    default:\n+      error (\"specified option %qs more than once\", \"-mmcu=\");\n+      return \"\";\n+    }\n+\n+  specfile_name = concat (argv[0], dir_separator_str, \"specs-\", mmcu, NULL);\n+\n+#ifdef DEBUG_SPECS\n+  if (verbose_flag)\n+    fnotice (stderr, \"'%s': mmcu='%s'\\n'%s': specfile='%s'\\n\\n\",\n+             __FUNCTION__, mmcu, __FUNCTION__, specfile_name);\n+#endif\n+\n+  // Filter out silly -mmcu= arguments like \"foo bar\".\n+\n+  for (const char *s = mmcu; *s; s++)\n+    if (!ISALNUM (*s)\n+        && '-' != *s\n+        && '_' != *s)\n+      {\n+        error (\"strange device name %qs after %qs: bad character %qc\",\n+               mmcu, \"-mmcu=\", *s);\n+        return \"\";\n+      }\n+\n+  if (/* When building / configuring the compiler we might get a relative path\n+         as supplied by \"-B.\".  Assume that the specs file exists and MCU is\n+         a core, not a proper device then, i.e. we have \"-mmcu=avr*\".  */\n+      (0 == strncmp (mmcu, \"avr\", strlen (\"avr\"))\n+       && specfile_name[0] == '.')\n+      /* vanilla */\n+      || (IS_ABSOLUTE_PATH (specfile_name)\n+          && !access (specfile_name, R_OK)))\n+    {\n+      return concat (\"-specs=\", specfile_name, NULL);\n+    }\n+\n+  return avr_diagnose_devicespecs_error (mmcu, specfile_name);\n+}"}, {"sha": "bdc747c65809eef40fd3fd82ed52a819eb53f71d", "filename": "gcc/config/avr/gen-avr-mmcu-specs.c", "status": "modified", "additions": 146, "deletions": 81, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Fgen-avr-mmcu-specs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Fgen-avr-mmcu-specs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fgen-avr-mmcu-specs.c?ref=4a2caf6ced93a63e1703870ed67385d3f89da474", "patch": "@@ -23,20 +23,31 @@\n \n #define IN_GEN_AVR_MMCU_TEXI\n \n-#include \"avr-arch.h\"\n #include \"avr-devices.c\"\n \n+// Get rid of \"defaults.h\".  We just need tm.h for `WITH_AVRLIBS' and\n+// and `WITH_RTEMS'.  */\n #define GCC_DEFAULTS_H\n \n #include \"tm.h\"\n \n+// Mimic the include order as specified in config.gcc::tm_file.\n+\n+#include \"specs.h\"\n+\n #if defined (WITH_AVRLIBC)\n-static const bool with_avrlibc = true;\n-#else\n-static const bool with_avrlibc = false;\n-#endif /* WITH_AVRLIBC */\n+#include \"avrlibc.h\"\n+#endif\n+\n+#if defined (WITH_RTEMS)\n+#include \"../rtems.h\"\n+#include \"rtems.h\"\n+#endif\n \n \n+#define SPECFILE_DOC_URL                                \\\n+  \"http://gcc.gnu.org/onlinedocs/gcc/Spec-Files.html\"\n+\n /* Return true iff STR starts with PREFIX.  */\n \n static bool\n@@ -46,17 +57,41 @@ str_prefix_p (const char *str, const char *prefix)\n }\n \n \n+static const char header[] =\n+  \"#\\n\"\n+  \"# Generated by   : ./gcc/config/avr/gen-avr-mmcu-specs.c\\n\"\n+  \"# Generated from : ./gcc/config/gcc.c\\n\"\n+  \"#                  ./gcc/config/avr/specs.h\\n\"\n+#if defined (WITH_RTEMS)\n+  \"#                  ./gcc/config/rtems.h\\n\"\n+  \"#                  ./gcc/config/avr/rtems.h\\n\"\n+#endif\n+#if defined (WITH_AVRLIBC)\n+  \"#                  ./gcc/config/avr/avrlibc.h\\n\"\n+#endif\n+  \"# Used by        : avr-gcc compiler driver\\n\"\n+  \"# Used for       : building command options for sub-processes\\n\"\n+  \"#\\n\"\n+  \"# See <\" SPECFILE_DOC_URL \">\\n\"\n+  \"# for a documentation of spec files.\\n\"\n+  \"\\n\";\n+\n+\n static void\n print_mcu (const avr_mcu_t *mcu)\n {\n   const char *sp8_spec;\n   const avr_mcu_t *arch_mcu;\n+  const avr_arch_t *arch;\n+  enum avr_arch_id arch_id = mcu->arch_id;\n \n   for (arch_mcu = mcu; arch_mcu->macro; )\n     arch_mcu--;\n-  if (arch_mcu->arch != mcu->arch)\n+  if (arch_mcu->arch_id != arch_id)\n     exit (EXIT_FAILURE);\n \n+  arch = &avr_arch_types[arch_id];\n+\n   char name[100];\n   if (snprintf (name, sizeof name, \"specs-%s\", mcu->name) >= (int) sizeof name)\n    exit (EXIT_FAILURE);\n@@ -66,107 +101,137 @@ print_mcu (const avr_mcu_t *mcu)\n   bool errata_skip = 0 != (mcu->dev_attribute & AVR_ERRATA_SKIP);\n   bool rmw = 0 != (mcu->dev_attribute & AVR_ISA_RMW);\n   bool sp8 = 0 != (mcu->dev_attribute & AVR_SHORT_SP);\n+  bool is_arch = NULL == mcu->macro;\n+  bool is_device = ! is_arch;\n \n-  if (mcu->macro == NULL\n-      && (mcu->arch == ARCH_AVR2 || mcu->arch == ARCH_AVR25))\n+  if (is_arch\n+      && (ARCH_AVR2 == arch_id\n+          || ARCH_AVR25 == arch_id))\n     {\n       // Leave \"avr2\" and \"avr25\" alone.  These two architectures are\n       // the only ones that mix devices with 8-bit SP and 16-bit SP.\n       sp8_spec = \"\";\n     }\n   else\n     {\n-      sp8_spec = sp8\n-        ? \" -msp8\"\n-        : \" %<msp8\";\n+      sp8_spec = sp8 ? \"-msp8\" :\"%<msp8\";\n     }\n \n-  const char *errata_skip_spec = errata_skip\n-    ? \" %{!mno-skip-bug:-mskip-bug}\"\n-    : \" %{!mskip-bug:-mno-skip-bug}\";\n+  fprintf (f, \"#\\n\"\n+           \"# Auto-generated specs for AVR \");\n+  if (is_arch)\n+    fprintf (f, \"core architecture %s\\n\", arch->name);\n+  else\n+    fprintf (f, \"device %s (core %s, %d-bit SP)\\n\",\n+             mcu->name, arch->name, sp8 ? 8 : 16);\n+  fprintf (f, \"%s\\n\", header);\n+\n+  // avrlibc-specific specs for linking / thelinker.\n \n-  const char *rmw_spec = rmw\n-    ? \" %{!mno-rmw: -mrmw}\"\n-    : \" %{mrmw}\";\n+  fprintf (f, \"*avrlibc_startfile:\\n\");\n+  if (is_device)\n+    fprintf (f, \"\\tdev/%s/crt1.o%%s\", mcu->name);\n+  fprintf (f, \"\\n\\n\");\n \n-  const char *arch_name = avr_arch_types[mcu->arch].arch_name;\n+  fprintf (f, \"*avrlibc_devicelib:\\n\");\n+  if (is_device)\n+    fprintf (f, \"\\tdev/%s/libdev.a%%s\", mcu->name);\n+  fprintf (f, \"\\n\\n\");\n \n-  fprintf (f, \"*self_spec:\\n\"\n-           \" %%{!march=*:-march=%s}\"\n-           \" %s\\n\\n\", arch_name, sp8_spec);\n+  // avr-specific specs for the compilation / the compiler proper.\n \n-  if (mcu->macro)\n-    fprintf (f, \"*cpp:\\n-D__AVR_DEV_LIB_NAME__=%s -D%s \"\n-\t     \"-D__AVR_DEVICE_NAME__=%s\\n\\n\",\n-\t     mcu->library_name, mcu->macro, mcu->name);\n+  fprintf (f, \"*cc1_n_flash:\\n\"\n+           \"\\t%%{!mn-flash=*:-mn-flash=%d}\\n\\n\", mcu->n_flash);\n+\n+  fprintf (f, \"*cc1_rmw:\\n%s\\n\\n\", rmw\n+           ? \"\\t%{!mno-rmw: -mrmw}\"\n+           : \"\\t%{mrmw}\");\n+\n+  fprintf (f, \"*cc1_errata_skip:\\n%s\\n\\n\", errata_skip\n+           ? \"\\t%{!mno-skip-bug: -mskip-bug}\"\n+           : \"\\t%{!mskip-bug: -mno-skip-bug}\");\n+\n+  // avr-specific specs for assembling / the assembler.\n+\n+  fprintf (f, \"*asm_arch:\\n\\t-mmcu=%s\\n\\n\", arch->name);\n+\n+  fprintf (f, \"*asm_relax:\\n\\t%s\\n\\n\", ASM_RELAX_SPEC);\n \n-  fprintf (f, \"*cc1:\\n%s%s\", errata_skip_spec, rmw_spec);\n-  if (mcu->n_flash != arch_mcu->n_flash)\n-    fprintf (f, \" %%{!mn-flash:-mn-flash=%d}\", mcu->n_flash);\n+  fprintf (f, \"*asm_rmw:\\n%s\\n\\n\", rmw\n+           ? \"\\t%{!mno-rmw: -mrmw}\"\n+           : \"\\t%{mrmw}\");\n+\n+  fprintf (f, \"*asm_errata_skip:\\n%s\\n\\n\", errata_skip\n+           ? \"\\t%{mno-skip-bug}\"\n+           : \"\\t%{!mskip-bug: -mno-skip-bug}\");\n+\n+  // avr-specific specs for linking / the linker.\n+\n+  int wrap_k =\n+    str_prefix_p (mcu->name, \"at90usb8\") ? 8\n+    : str_prefix_p (mcu->name, \"atmega16\") ? 16\n+    : (str_prefix_p (mcu->name, \"atmega32\")\n+       || str_prefix_p (mcu->name, \"at90can32\")) ? 32\n+    : (str_prefix_p (mcu->name, \"atmega64\")\n+       || str_prefix_p (mcu->name, \"at90can64\")\n+       || str_prefix_p (mcu->name, \"at90usb64\")) ? 64\n+    : 0;\n+\n+  fprintf (f, \"*link_pmem_wrap:\\n\");\n+  if (wrap_k)\n+    fprintf (f, \"\\t%%{mpmem-wrap-around: --pmem-wrap-around=%dk}\", wrap_k);\n   fprintf (f, \"\\n\\n\");\n \n-  fprintf (f, \"*cc1plus:\\n%s%s \", errata_skip_spec, rmw_spec);\n-  if (mcu->n_flash != arch_mcu->n_flash)\n-    fprintf (f, \" %%{!mn-flash:-mn-flash=%d}\", mcu->n_flash);\n-  fprintf (f, (\" %%{!frtti: -fno-rtti}\"\n-               \" %%{!fenforce-eh-specs: -fno-enforce-eh-specs}\"\n-               \" %%{!fexceptions: -fno-exceptions}\\n\\n\"));\n-\n-  fprintf (f, \"*asm:\\n\"\n-           \" %%{march=*:-mmcu=%%*}\"\n-           \" %%{mrelax: --mlink-relax}\"\n-           \" %s%s\\n\\n\", rmw_spec, (errata_skip\n-                                  ? \" %{mno-skip-bug}\"\n-                                  : \" %{!mskip-bug:-mno-skip-bug}\"));\n-  fprintf (f, \"*link:\\n\"\n-           \" %%{mrelax:--relax\");\n-  {\n-    int wrap_k =\n-      str_prefix_p (mcu->name, \"at90usb8\") ? 8\n-      : str_prefix_p (mcu->name, \"atmega16\") ? 16\n-      : (str_prefix_p (mcu->name, \"atmega32\")\n-         || str_prefix_p (mcu->name, \"at90can32\")) ? 32\n-      : (str_prefix_p (mcu->name, \"atmega64\")\n-        || str_prefix_p (mcu->name, \"at90can64\")\n-        || str_prefix_p (mcu->name, \"at90usb64\")) ? 64\n-      : 0;\n-\n-    if (wrap_k)\n-      fprintf (f, \" %%{mpmem-wrap-around: --pmem-wrap-around=%dk}\", wrap_k);\n-  }\n-  fprintf (f, \"}\"\n-           \" %%{march=*:-m%%*}\");\n+  fprintf (f, \"*link_relax:\\n\\t%s\\n\\n\", LINK_RELAX_SPEC);\n+\n+  fprintf (f, \"*link_arch:\\n\\t%s\\n\\n\", LINK_ARCH_SPEC);\n \n+  fprintf (f, \"*link_data_start:\\n\");\n   if (mcu->data_section_start\n-      != avr_arch_types[mcu->arch].default_data_section_start)\n-    fprintf (f, \" -Tdata 0x%lX\", 0x800000UL + mcu->data_section_start);\n+      != arch->default_data_section_start)\n+    fprintf (f, \"\\t-Tdata 0x%lX\", 0x800000UL + mcu->data_section_start);\n+  fprintf (f, \"\\n\\n\");\n \n+  fprintf (f, \"*link_text_start:\\n\");\n   if (mcu->text_section_start != 0x0)\n-    fprintf (f, \" -Ttext 0x%lX\", 0UL + mcu->text_section_start);\n+    fprintf (f, \"\\t-Ttext 0x%lX\", 0UL + mcu->text_section_start);\n+  fprintf (f, \"\\n\\n\");\n+\n+  // Default specs.  Rewritten to the device-specific specs file so\n+  // they can be adjusted as needed.\n+     \n+  bool has_libs = arch_id != ARCH_AVR1;\n+\n+  fprintf (f, \"*self_spec:\\n\");\n+  if (is_device)\n+    fprintf (f, \"\\t%%{!mmcu=avr*: %%<mmcu=* -mmcu=%s} \", arch->name);\n+  fprintf (f, \"%s\\n\\n\", sp8_spec);\n+\n+  fprintf (f, \"*cpp:\\n\");\n+  if (is_device)\n+    fprintf (f,\"\\t-D__AVR_DEV_LIB_NAME__=%s\"\n+             \" -D%s\"\n+\t     \" -D__AVR_DEVICE_NAME__=%s\",\n+\t     mcu->library_name, mcu->macro, mcu->name);\n+  fprintf (f, \"\\n\\n\");\n \n-  fprintf (f, \" %%{shared:%%eshared is not supported}\\n\\n\");\n+  fprintf (f, \"*cc1:\\n\\t%s\\n\\n\", CC1_SPEC);\n \n-  bool has_libs = mcu->arch != ARCH_AVR1;\n+  fprintf (f, \"*cc1plus:\\n\\t%s\\n\\n\", CC1PLUS_SPEC);\n \n-  fprintf (f, \"*lib:\\n\");\n-  if (has_libs)\n-    {\n-      fprintf (f, \"-lc\");\n-      if (with_avrlibc\n-          && mcu->macro)\n-\tfprintf (f, \" dev/%s/libdev.a%%s\", mcu->name);\n-    }\n-  fprintf (f, \"\\n\\n\");\n+  fprintf (f, \"*asm:\\n\\t%s\\n\\n\", ASM_SPEC);\n \n-  fprintf (f, \"*libgcc:\\n\");\n-  if (has_libs)\n-    fprintf (f, with_avrlibc\n-             ? \"-lgcc -lm\"\n-             : \"-lgcc\");\n-  fprintf (f, \"\\n\\n\");\n+  fprintf (f, \"*link:\\n\\t%s\\n\\n\", LINK_SPEC);\n+\n+  fprintf (f, \"*lib:\\n\\t%s\\n\\n\", has_libs ? LIB_SPEC : \"\");\n+\n+  fprintf (f, \"*libgcc:\\n\\t%s\\n\\n\", has_libs ? LIBGCC_SPEC : \"\");\n+\n+  fprintf (f, \"*startfile:\\n\\t%s\\n\\n\", STARTFILE_SPEC);\n+\n+  fprintf (f, \"*endfile:\\n%s\\n\\n\", ENDFILE_SPEC);\n \n-  fprintf (f, \"*startfile:\\n\"\n-           \"dev/%s/crt1.o%%s\\n\\n\", mcu->name);\n+  fprintf (f, \"# End of file\\n\");\n }\n \n "}, {"sha": "ea0de49f9d74a810d188fe272d04c23655a2e0a8", "filename": "gcc/config/avr/gen-avr-mmcu-texi.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Fgen-avr-mmcu-texi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Fgen-avr-mmcu-texi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fgen-avr-mmcu-texi.c?ref=4a2caf6ced93a63e1703870ed67385d3f89da474", "patch": "@@ -22,7 +22,6 @@\n \n #define IN_GEN_AVR_MMCU_TEXI\n \n-#include \"avr-arch.h\"\n #include \"avr-devices.c\"\n \n static const char*\n@@ -97,7 +96,7 @@ print_mcus (size_t n_mcus)\n \n int main (void)\n {\n-  enum avr_arch arch = ARCH_UNKNOWN;\n+  enum avr_arch_id arch_id = ARCH_UNKNOWN;\n   size_t i, n_mcus = 0;\n   const avr_mcu_t *mcu;\n \n@@ -120,18 +119,18 @@ int main (void)\n     {\n       if (mcu->macro == NULL)\n         {\n-          arch = mcu->arch;\n+          arch_id = mcu->arch_id;\n \n           /* Start a new architecture:  Flush the MCUs collected so far.  */\n \n           print_mcus (n_mcus);\n           n_mcus = 0;\n \n           for (i = 0; i < sizeof (avr_texinfo) / sizeof (*avr_texinfo); i++)\n-            if (arch == avr_texinfo[i].arch)\n+            if (arch_id == avr_texinfo[i].arch_id)\n               printf (\"@item %s\\n%s\\n\", mcu->name, avr_texinfo[i].texinfo);\n         }\n-      else if (arch == (enum avr_arch) mcu->arch)\n+      else if (arch_id == (enum avr_arch_id) mcu->arch_id)\n         {\n           mcu_name[n_mcus++] = mcu->name;\n         }"}, {"sha": "903322edecb67c1ae31297228c0c9ab9dddfde22", "filename": "gcc/config/avr/genmultilib.awk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Fgenmultilib.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Fgenmultilib.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fgenmultilib.awk?ref=4a2caf6ced93a63e1703870ed67385d3f89da474", "patch": "@@ -97,7 +97,7 @@ BEGIN {\n \tcores[n_cores] = core\n \tn_cores++\n \ttiny_stack[core] = 0\n-\toption[core] = \"march=\" core\n+\toption[core] = \"mmcu=\" core\n \n \tnext\n     }"}, {"sha": "39775cadd14a1f6d5f5b8badda0e6650fdf78335", "filename": "gcc/config/avr/genopt.sh", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768fbdd49e8535486ea71eebc507c3b813521a1b/gcc%2Fconfig%2Favr%2Fgenopt.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768fbdd49e8535486ea71eebc507c3b813521a1b/gcc%2Fconfig%2Favr%2Fgenopt.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fgenopt.sh?ref=768fbdd49e8535486ea71eebc507c3b813521a1b", "patch": "@@ -1,58 +0,0 @@\n-#!/bin/sh\n-# Generate avr-tables.opt from the list in avr-mcus.def.\n-# Copyright (C) 2011-2015 Free Software Foundation, Inc.\n-#\n-# This file is part of GCC.\n-#\n-# GCC is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3, or (at your option)\n-# any later version.\n-#\n-# GCC is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-cat <<EOF\n-; -*- buffer-read-only: t -*-\n-; Generated automatically by genopt.sh from avr-mcus.def.\n-\n-; Copyright (C) 2011-2015 Free Software Foundation, Inc.\n-;\n-; This file is part of GCC.\n-;\n-; GCC is free software; you can redistribute it and/or modify it under\n-; the terms of the GNU General Public License as published by the Free\n-; Software Foundation; either version 3, or (at your option) any later\n-; version.\n-;\n-; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-; for more details.\n-;\n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING3.  If not see\n-; <http://www.gnu.org/licenses/>.\n-\n-Enum\n-Name(avr_arch) Type(enum avr_arch)\n-Known MCU architectures:\n-\n-EOF\n-\n-awk -F'[(, \t]+' 'BEGIN {\n-}\n-/^AVR_MCU.*NULL/ {\n-    name = $2\n-    value = $3\n-    gsub(\"\\\"\", \"\", name)\n-    print \"EnumValue\"\n-    print \"Enum(avr_arch) String(\" name \") Value(\" value \")\"\n-    print \"\"\n-}' $1"}, {"sha": "2d12bc690168891f0aaae52606d7f81c7a21466c", "filename": "gcc/config/avr/predicates.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fpredicates.md?ref=4a2caf6ced93a63e1703870ed67385d3f89da474", "patch": "@@ -45,21 +45,21 @@\n ;; Return true if OP is a valid address for lower half of I/O space.\n (define_special_predicate \"low_io_address_operand\"\n   (ior (and (match_code \"const_int\")\n-\t    (match_test \"IN_RANGE (INTVAL (op) - avr_current_arch->sfr_offset,\n+\t    (match_test \"IN_RANGE (INTVAL (op) - avr_arch->sfr_offset,\n \t\t\t\t   0, 0x20 - GET_MODE_SIZE (mode))\"))\n        (and (match_code \"symbol_ref\")\n \t    (match_test \"SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_IO_LOW\"))))\n \n ;; Return true if OP is a valid address for high half of I/O space.\n (define_predicate \"high_io_address_operand\"\n   (and (match_code \"const_int\")\n-       (match_test \"IN_RANGE (INTVAL (op) - avr_current_arch->sfr_offset,\n+       (match_test \"IN_RANGE (INTVAL (op) - avr_arch->sfr_offset,\n                               0x20, 0x3F)\")))\n \n ;; Return true if OP is a valid address of I/O space.\n (define_special_predicate \"io_address_operand\"\n   (ior (and (match_code \"const_int\")\n-\t    (match_test \"IN_RANGE (INTVAL (op) - avr_current_arch->sfr_offset,\n+\t    (match_test \"IN_RANGE (INTVAL (op) - avr_arch->sfr_offset,\n \t\t\t\t   0, 0x40 - GET_MODE_SIZE (mode))\"))\n        (and (match_code \"symbol_ref\")\n \t    (match_test \"SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_IO\"))))"}, {"sha": "b592692eecb9a6be567140fd762d5369303e58bc", "filename": "gcc/config/avr/specs.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Fspecs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Fspecs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fspecs.h?ref=4a2caf6ced93a63e1703870ed67385d3f89da474", "patch": "@@ -0,0 +1,77 @@\n+/* Specs definitions for Atmel AVR back end.\n+\n+   Copyright (C) 2012-2015 Free Software Foundation, Inc.\n+   Contributed by Georg-Johann Lay (avr@gjlay.de)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+/* Default specs layout.  The actual definitions might be superseeded\n+   by device- or OS- specific files, like avrlibc.h, ../rtems.h, etc.\n+   The specs are repeated in the device specs files.  Subspecs are\n+   specs known to GCC or specs defined in the device specs files.  */\n+\n+\n+#undef  CPLUSPLUS_CPP_SPEC\n+#define CPLUSPLUS_CPP_SPEC                      \\\n+  \"%(cpp)\"\n+\n+#undef  CC1_SPEC\n+#define CC1_SPEC                                \\\n+  \"%(cc1_n_flash) \"                             \\\n+  \"%(cc1_errata_skip) \"                         \\\n+  \"%(cc1_rmw) \"\n+\n+#undef  CC1PLUS_SPEC\n+#define CC1PLUS_SPEC                                    \\\n+  \"%(cc1) \"                                             \\\n+  \"%{!frtti:-fno-rtti} \"                                \\\n+  \"%{!fenforce-eh-specs:-fno-enforce-eh-specs} \"        \\\n+  \"%{!fexceptions:-fno-exceptions} \"\n+\n+#define ASM_RELAX_SPEC                          \\\n+  \"%{mrelax:--mlink-relax} \"\n+\n+#undef  ASM_SPEC\n+#define ASM_SPEC                                \\\n+  \"%(asm_arch) \"                                \\\n+  \"%(asm_relax) \"                               \\\n+  \"%(asm_rmw) \"                                 \\\n+  \"%(asm_errata_skip) \"\n+\n+#define LINK_ARCH_SPEC                          \\\n+  \"%{mmcu=*:-m%*} \"\n+\n+#define LINK_RELAX_SPEC                         \\\n+  \"%{mrelax:--relax %(link_pmem_wrap)} \"\n+\n+#undef  LINK_SPEC\n+#define LINK_SPEC                               \\\n+  \"%(link_arch) \"                               \\\n+  \"%(link_data_start) \"                         \\\n+  \"%(link_text_start) \"                         \\\n+  \"%(link_relax) \"                              \\\n+  \"%{shared:%eshared is not supported} \"\n+\n+#undef  LIB_SPEC\n+#define LIB_SPEC \" -lc \"\n+\n+#undef  LIBGCC_SPEC\n+#define LIBGCC_SPEC \" -lgcc \"\n+\n+#define STARTFILE_SPEC \"\"\n+#define ENDFILE_SPEC \"\""}, {"sha": "e2975612ed1b3bfc1afc18fae48ab2c016c20181", "filename": "gcc/config/avr/t-avr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Ft-avr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Ft-avr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Ft-avr?ref=4a2caf6ced93a63e1703870ed67385d3f89da474", "patch": "@@ -16,8 +16,14 @@\n # along with GCC; see the file COPYING3.  If not see\n # <http://www.gnu.org/licenses/>.\n \n+driver-avr.o: $(srcdir)/config/avr/driver-avr.c \\\n+  $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+  $(srcdir)/config/avr/avr-arch.h $(TM_H)\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n+\n avr-devices.o: $(srcdir)/config/avr/avr-devices.c \\\n   $(srcdir)/config/avr/avr-mcus.def \\\n+  $(srcdir)/config/avr/avr-arch.h \\\n   $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n \n@@ -49,15 +55,9 @@ AVR_MCUS = $(srcdir)/config/avr/avr-mcus.def\n .PHONY: avr-mcus\n \n avr-mcus: $(srcdir)/config/avr/t-multilib \\\n-\t  $(srcdir)/config/avr/avr-tables.opt \\\n \t  $(srcdir)/doc/avr-mmcu.texi ; @true\n \n-# Make sure that -mmcu= is supported for devices from avr-mcus.def and\n-# all -mmcu= values are displayed on the help screen\n-$(srcdir)/config/avr/avr-tables.opt: $(srcdir)/config/avr/genopt.sh $(AVR_MCUS)\n-\t$(SHELL) $< $(AVR_MCUS) > $@\n-\n-# Make sure that -mmcu= support is in sync with -mmcu= documentation.\n+# Make sure that native -mmcu= support is in sync with -mmcu= documentation.\n gen-avr-mmcu-texi$(build_exeext): $(srcdir)/config/avr/gen-avr-mmcu-texi.c \\\n   $(AVR_MCUS) $(srcdir)/config/avr/avr-devices.c \\\n   $(srcdir)/config/avr/avr-arch.h\n@@ -84,7 +84,7 @@ install-device-specs: s-device-specs installdirs\n \t-rm -rf $(DESTDIR)$(libsubdir)/device-specs\n \tmkdir $(DESTDIR)$(libsubdir)/device-specs\n \t-for file in device-specs/*; do \\\n-\t$(INSTALL_PROGRAM) $${file} $(DESTDIR)$(libsubdir)/$${file}; \\\n+\t\t$(INSTALL_DATA) $${file} $(DESTDIR)$(libsubdir)/$${file}; \\\n \tdone\n \n # Map -mmcu= to the right multilib variant"}, {"sha": "4f80db757c77ab9180f2374488d8d8e38a572fd1", "filename": "gcc/config/avr/t-multilib", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Ft-multilib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2caf6ced93a63e1703870ed67385d3f89da474/gcc%2Fconfig%2Favr%2Ft-multilib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Ft-multilib?ref=4a2caf6ced93a63e1703870ed67385d3f89da474", "patch": "@@ -21,21 +21,21 @@\n # along with GCC; see the file COPYING3.  If not see\n # <http://www.gnu.org/licenses/>.\n \n-MULTILIB_OPTIONS = march=avr2/march=avr25/march=avr3/march=avr31/march=avr35/march=avr4/march=avr5/march=avr51/march=avr6/march=avrxmega2/march=avrxmega4/march=avrxmega5/march=avrxmega6/march=avrxmega7/march=avrtiny msp8\n+MULTILIB_OPTIONS = mmcu=avr2/mmcu=avr25/mmcu=avr3/mmcu=avr31/mmcu=avr35/mmcu=avr4/mmcu=avr5/mmcu=avr51/mmcu=avr6/mmcu=avrxmega2/mmcu=avrxmega4/mmcu=avrxmega5/mmcu=avrxmega6/mmcu=avrxmega7/mmcu=avrtiny msp8\n \n MULTILIB_DIRNAMES =  avr2 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avrxmega2 avrxmega4 avrxmega5 avrxmega6 avrxmega7 avrtiny tiny-stack avr25/tiny-stack\n \n MULTILIB_EXCEPTIONS = \\\n-\tmarch=avr3/msp8 \\\n-\tmarch=avr31/msp8 \\\n-\tmarch=avr35/msp8 \\\n-\tmarch=avr4/msp8 \\\n-\tmarch=avr5/msp8 \\\n-\tmarch=avr51/msp8 \\\n-\tmarch=avr6/msp8 \\\n-\tmarch=avrxmega2/msp8 \\\n-\tmarch=avrxmega4/msp8 \\\n-\tmarch=avrxmega5/msp8 \\\n-\tmarch=avrxmega6/msp8 \\\n-\tmarch=avrxmega7/msp8 \\\n-\tmarch=avrtiny/msp8\n+\tmmcu=avr3/msp8 \\\n+\tmmcu=avr31/msp8 \\\n+\tmmcu=avr35/msp8 \\\n+\tmmcu=avr4/msp8 \\\n+\tmmcu=avr5/msp8 \\\n+\tmmcu=avr51/msp8 \\\n+\tmmcu=avr6/msp8 \\\n+\tmmcu=avrxmega2/msp8 \\\n+\tmmcu=avrxmega4/msp8 \\\n+\tmmcu=avrxmega5/msp8 \\\n+\tmmcu=avrxmega6/msp8 \\\n+\tmmcu=avrxmega7/msp8 \\\n+\tmmcu=avrtiny/msp8"}]}