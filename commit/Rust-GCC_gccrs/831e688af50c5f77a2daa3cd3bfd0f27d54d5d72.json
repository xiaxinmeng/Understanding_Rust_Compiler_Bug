{"sha": "831e688af50c5f77a2daa3cd3bfd0f27d54d5d72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMxZTY4OGFmNTBjNWY3N2EyZGFhM2NkM2JmZDBmMjdkNTRkNWQ3Mg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-07-12T10:03:10Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-07-12T10:03:10Z"}, "message": "fold-const.h (get_array_ctor_element_at_index): Adjust.\n\n2019-07-12  Richard Biener  <rguenther@suse.de>\n\n\t* fold-const.h (get_array_ctor_element_at_index): Adjust.\n\t* fold-const.c (get_array_ctor_element_at_index): Add\n\tctor_idx output parameter informing the caller where in\n\tthe constructor the element was (not) found.  Add early exit\n\tfor when the ctor is sorted.\n\t* gimple-fold.c (fold_array_ctor_reference): Support constant\n\tfolding across multiple array elements.\n\n\t* gcc.dg/tree-ssa/vector-7.c: New testcase.\n\nFrom-SVN: r273435", "tree": {"sha": "ea4a80650c7c4334d9576ee571c395e345cfec8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea4a80650c7c4334d9576ee571c395e345cfec8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/831e688af50c5f77a2daa3cd3bfd0f27d54d5d72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/831e688af50c5f77a2daa3cd3bfd0f27d54d5d72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/831e688af50c5f77a2daa3cd3bfd0f27d54d5d72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/831e688af50c5f77a2daa3cd3bfd0f27d54d5d72/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e067f9924bad423bf6265b75414d3160e6cf660a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e067f9924bad423bf6265b75414d3160e6cf660a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e067f9924bad423bf6265b75414d3160e6cf660a"}], "stats": {"total": 183, "additions": 167, "deletions": 16}, "files": [{"sha": "bd47dddc524f4e3462030810a27e2088a7d5d321", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/831e688af50c5f77a2daa3cd3bfd0f27d54d5d72/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/831e688af50c5f77a2daa3cd3bfd0f27d54d5d72/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=831e688af50c5f77a2daa3cd3bfd0f27d54d5d72", "patch": "@@ -1,3 +1,13 @@\n+2019-07-12  Richard Biener  <rguenther@suse.de>\n+\n+\t* fold-const.h (get_array_ctor_element_at_index): Adjust.\n+\t* fold-const.c (get_array_ctor_element_at_index): Add\n+\tctor_idx output parameter informing the caller where in\n+\tthe constructor the element was (not) found.  Add early exit\n+\tfor when the ctor is sorted.\n+\t* gimple-fold.c (fold_array_ctor_reference): Support constant\n+\tfolding across multiple array elements.\n+\n 2019-07-12  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* cfgexpand.c (expand_gimple_stmt_1) <GIMPLE_RETURN>: If the statement"}, {"sha": "74544bfe5c2e3079db42cb911b434e4dbd7bfd08", "filename": "gcc/fold-const.c", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/831e688af50c5f77a2daa3cd3bfd0f27d54d5d72/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/831e688af50c5f77a2daa3cd3bfd0f27d54d5d72/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=831e688af50c5f77a2daa3cd3bfd0f27d54d5d72", "patch": "@@ -11839,10 +11839,15 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n }\n \n /* Gets the element ACCESS_INDEX from CTOR, which must be a CONSTRUCTOR\n-   of an array (or vector).  */\n+   of an array (or vector).  *CTOR_IDX if non-NULL is updated with the\n+   constructor element index of the value returned.  If the element is\n+   not found NULL_TREE is returned and *CTOR_IDX is updated to\n+   the index of the element after the ACCESS_INDEX position (which\n+   may be outside of the CTOR array).  */\n \n tree\n-get_array_ctor_element_at_index (tree ctor, offset_int access_index)\n+get_array_ctor_element_at_index (tree ctor, offset_int access_index,\n+\t\t\t\t unsigned *ctor_idx)\n {\n   tree index_type = NULL_TREE;\n   offset_int low_bound = 0;\n@@ -11869,7 +11874,7 @@ get_array_ctor_element_at_index (tree ctor, offset_int access_index)\n \t\t     TYPE_SIGN (index_type));\n \n   offset_int max_index;\n-  unsigned HOST_WIDE_INT cnt;\n+  unsigned cnt;\n   tree cfield, cval;\n \n   FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), cnt, cfield, cval)\n@@ -11897,11 +11902,26 @@ get_array_ctor_element_at_index (tree ctor, offset_int access_index)\n \t  max_index = index;\n \t}\n \n-    /* Do we have match?  */\n-    if (wi::cmpu (access_index, index) >= 0\n-\t&& wi::cmpu (access_index, max_index) <= 0)\n-      return cval;\n-  }\n+      /* Do we have match?  */\n+      if (wi::cmpu (access_index, index) >= 0)\n+\t{\n+\t  if (wi::cmpu (access_index, max_index) <= 0)\n+\t    {\n+\t      if (ctor_idx)\n+\t\t*ctor_idx = cnt;\n+\t      return cval;\n+\t    }\n+\t}\n+      else if (in_gimple_form)\n+\t/* We're past the element we search for.  Note during parsing\n+\t   the elements might not be sorted.\n+\t   ???  We should use a binary search and a flag on the\n+\t   CONSTRUCTOR as to whether elements are sorted in declaration\n+\t   order.  */\n+\tbreak;\n+    }\n+  if (ctor_idx)\n+    *ctor_idx = cnt;\n   return NULL_TREE;\n }\n "}, {"sha": "eab2b47a260a52f6d2b5c8439936e9f3ae82539a", "filename": "gcc/fold-const.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/831e688af50c5f77a2daa3cd3bfd0f27d54d5d72/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/831e688af50c5f77a2daa3cd3bfd0f27d54d5d72/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=831e688af50c5f77a2daa3cd3bfd0f27d54d5d72", "patch": "@@ -67,7 +67,8 @@ extern tree fold_build_call_array_loc (location_t, tree, tree, int, tree *);\n #define fold_build_call_array_initializer(T1,T2,N,T4)\\\n    fold_build_call_array_initializer_loc (UNKNOWN_LOCATION, T1, T2, N, T4)\n extern tree fold_build_call_array_initializer_loc (location_t, tree, tree, int, tree *);\n-extern tree get_array_ctor_element_at_index (tree, offset_int);\n+extern tree get_array_ctor_element_at_index (tree, offset_int,\n+\t\t\t\t\t     unsigned * = NULL);\n extern bool fold_convertible_p (const_tree, const_tree);\n #define fold_convert(T1,T2)\\\n    fold_convert_loc (UNKNOWN_LOCATION, T1, T2)"}, {"sha": "be83620deee4d9cf2283802c6abad0d12de487a8", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 84, "deletions": 7, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/831e688af50c5f77a2daa3cd3bfd0f27d54d5d72/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/831e688af50c5f77a2daa3cd3bfd0f27d54d5d72/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=831e688af50c5f77a2daa3cd3bfd0f27d54d5d72", "patch": "@@ -6716,14 +6716,13 @@ fold_array_ctor_reference (tree type, tree ctor,\n   elt_size = wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (ctor))));\n \n   /* When TYPE is non-null, verify that it specifies a constant-sized\n-     accessed not larger than size of array element.  Avoid division\n+     access of a multiple of the array element size.  Avoid division\n      by zero below when ELT_SIZE is zero, such as with the result of\n      an initializer for a zero-length array or an empty struct.  */\n   if (elt_size == 0\n       || (type\n \t  && (!TYPE_SIZE_UNIT (type)\n-\t      || TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST\n-\t      || elt_size < wi::to_offset (TYPE_SIZE_UNIT (type)))))\n+\t      || TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST)))\n     return NULL_TREE;\n \n   /* Compute the array index we look for.  */\n@@ -6734,10 +6733,88 @@ fold_array_ctor_reference (tree type, tree ctor,\n   /* And offset within the access.  */\n   inner_offset = offset % (elt_size.to_uhwi () * BITS_PER_UNIT);\n \n-  /* See if the array field is large enough to span whole access.  We do not\n-     care to fold accesses spanning multiple array indexes.  */\n-  if (inner_offset + size > elt_size.to_uhwi () * BITS_PER_UNIT)\n-    return NULL_TREE;\n+  if (size > elt_size.to_uhwi () * BITS_PER_UNIT)\n+    {\n+      /* native_encode_expr constraints.  */\n+      if (size > MAX_BITSIZE_MODE_ANY_MODE\n+\t  || size % BITS_PER_UNIT != 0\n+\t  || inner_offset % BITS_PER_UNIT != 0)\n+\treturn NULL_TREE;\n+\n+      unsigned ctor_idx;\n+      tree val = get_array_ctor_element_at_index (ctor, access_index,\n+\t\t\t\t\t\t  &ctor_idx);\n+      if (!val && ctor_idx >= CONSTRUCTOR_NELTS  (ctor))\n+\treturn build_zero_cst (type);\n+\n+      /* native-encode adjacent ctor elements.  */\n+      unsigned char buf[MAX_BITSIZE_MODE_ANY_MODE / BITS_PER_UNIT];\n+      unsigned bufoff = 0;\n+      offset_int index = 0;\n+      offset_int max_index = access_index;\n+      constructor_elt *elt = CONSTRUCTOR_ELT (ctor, ctor_idx);\n+      if (!val)\n+\tval = build_zero_cst (TREE_TYPE (TREE_TYPE (ctor)));\n+      else if (!CONSTANT_CLASS_P (val))\n+\treturn NULL_TREE;\n+      if (!elt->index)\n+\t;\n+      else if (TREE_CODE (elt->index) == RANGE_EXPR)\n+\t{\n+\t  index = wi::to_offset (TREE_OPERAND (elt->index, 0));\n+\t  max_index = wi::to_offset (TREE_OPERAND (elt->index, 1));\n+\t}\n+      else\n+\tindex = max_index = wi::to_offset (elt->index);\n+      index = wi::umax (index, access_index);\n+      do\n+\t{\n+\t  int len = native_encode_expr (val, buf + bufoff,\n+\t\t\t\t\telt_size.to_uhwi (),\n+\t\t\t\t\tinner_offset / BITS_PER_UNIT);\n+\t  if (len != elt_size - inner_offset / BITS_PER_UNIT)\n+\t    return NULL_TREE;\n+\t  inner_offset = 0;\n+\t  bufoff += len;\n+\n+\t  access_index += 1;\n+\t  if (wi::cmpu (access_index, index) == 0)\n+\t    val = elt->value;\n+\t  else if (wi::cmpu (access_index, max_index) > 0)\n+\t    {\n+\t      ctor_idx++;\n+\t      if (ctor_idx >= CONSTRUCTOR_NELTS (ctor))\n+\t\t{\n+\t\t  val = build_zero_cst (TREE_TYPE (TREE_TYPE (ctor)));\n+\t\t  ++max_index;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  elt = CONSTRUCTOR_ELT (ctor, ctor_idx);\n+\t\t  index = 0;\n+\t\t  max_index = access_index;\n+\t\t  if (!elt->index)\n+\t\t    ;\n+\t\t  else if (TREE_CODE (elt->index) == RANGE_EXPR)\n+\t\t    {\n+\t\t      index = wi::to_offset (TREE_OPERAND (elt->index, 0));\n+\t\t      max_index = wi::to_offset (TREE_OPERAND (elt->index, 1));\n+\t\t    }\n+\t\t  else\n+\t\t    index = max_index = wi::to_offset (elt->index);\n+\t\t  index = wi::umax (index, access_index);\n+\t\t  if (wi::cmpu (access_index, index) == 0)\n+\t\t    val = elt->value;\n+\t\t  else\n+\t\t    val = build_zero_cst (TREE_TYPE (TREE_TYPE (ctor)));\n+\t\t}\n+\t    }\n+\t}\n+      while (bufoff < size / BITS_PER_UNIT);\n+      *suboff += size;\n+      return native_interpret_expr (type, buf, size / BITS_PER_UNIT);\n+    }\n+\n   if (tree val = get_array_ctor_element_at_index (ctor, access_index))\n     {\n       if (!size && TREE_CODE (val) != CONSTRUCTOR)"}, {"sha": "dfda37f912c0df24ab73517be524594c1afaeff2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/831e688af50c5f77a2daa3cd3bfd0f27d54d5d72/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/831e688af50c5f77a2daa3cd3bfd0f27d54d5d72/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=831e688af50c5f77a2daa3cd3bfd0f27d54d5d72", "patch": "@@ -1,3 +1,7 @@\n+2019-07-12  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/vector-7.c: New testcase.\n+\n 2019-07-12  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-c++-common/gomp/order-1.c: New test."}, {"sha": "ebfe15dcfc86ca6ce1c48bc59d812dc18350c596", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vector-7.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/831e688af50c5f77a2daa3cd3bfd0f27d54d5d72/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvector-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/831e688af50c5f77a2daa3cd3bfd0f27d54d5d72/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvector-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvector-7.c?ref=831e688af50c5f77a2daa3cd3bfd0f27d54d5d72", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+typedef __INT8_TYPE__ v16qi __attribute__((vector_size(16),may_alias,aligned(1)));\n+typedef __INT32_TYPE__ v4si __attribute__((vector_size(16),may_alias,aligned(1)));\n+\n+const __INT32_TYPE__ x[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n+const __INT8_TYPE__ y[32]\n+  = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n+      16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 };\n+const __INT32_TYPE__ z[8] = { [3] = 3, [1] = 1 };\n+\n+int\n+main()\n+{\n+  v4si v1 = *(v4si *)(x + 1);\n+  for (unsigned i = 0; i < 4; ++i)\n+    if (v1[i] != (v4si) { 2, 3, 4, 5 }[i])\n+      __builtin_abort ();\n+  v4si v2 = *(v4si *)z;\n+  for (unsigned i = 0; i < 4; ++i)\n+    if (v2[i] != (v4si) { 0, 1, 0, 3 }[i])\n+      __builtin_abort ();\n+  v4si v3 = *(v4si *)(y + 1);\n+  for (unsigned i = 0; i < 4; ++i)\n+    if (v3[i] !=\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+\t(v4si) { 0x01020304, 0x05060708, 0x090a0b0c, 0x0d0e0f01 }[i]\n+#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+\t(v4si) { 0x04030201, 0x08070605, 0x0c0b0a09, 0x100f0e0d }[i]\n+#else\n+\tv3[i]\n+#endif\n+       )\n+      __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"abort\" \"optimized\" } } */"}]}