{"sha": "9a004410d9f64d658864a899ab911ae9a31c444c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEwMDQ0MTBkOWY2NGQ2NTg4NjRhODk5YWI5MTFhZTlhMzFjNDQ0Yw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-01-10T19:40:55Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-01-10T19:40:55Z"}, "message": "Preserving locations for variable-uses and constants (PR c++/43486)\n\nThis patch implements location wrapper nodes, preserving source locations\nof the uses of variables and constants in various places in the\nC++ frontend: at the arguments at callsites, and for typeid, alignof,\nsizeof, and offsetof.\n\nFor example, it allows the C++ FE to underline the pertinent argument\nfor mismatching calls, for such expressions, improving:\n\nextern int callee (int one, const char *two, float three);\n\nint caller (int first, int second, float third)\n{\n  return callee (first, second, third);\n}\n\nfrom\n\ntest.cc: In function 'int caller(int, int, float)':\ntest.cc:5:38: error: invalid conversion from 'int' to 'const char*' [-fpermissive]\n   return callee (first, second, third);\n                                      ^\ntest.cc:1:41: note:   initializing argument 2 of 'int callee(int, const char*, float)'\n extern int callee (int one, const char *two, float three);\n                             ~~~~~~~~~~~~^~~\n\nto:\n\ntest.cc: In function 'int caller(int, int, float)':\ntest.cc:5:25: error: invalid conversion from 'int' to 'const char*' [-fpermissive]\n   return callee (first, second, third);\n                         ^~~~~~\ntest.cc:1:41: note:   initializing argument 2 of 'int callee(int, const char*, float)'\n extern int callee (int one, const char *two, float three);\n                             ~~~~~~~~~~~~^~~\n\nThis is the combination of the following patches:\n\n  \"[PATCH 01/14] C++: preserve locations within build_address\"\n     https://gcc.gnu.org/ml/gcc-patches/2017-11/msg00883.html\n\n  \"[PATCH v2.4 of 02/14] Support for adding and stripping location_t wrapper nodes\"\n    https://gcc.gnu.org/ml/gcc-patches/2018-01/msg00591.html\n\n  \"[PATCH] Eliminate location wrappers in tree_nop_conversion/STRIP_NOPS\"\n    https://gcc.gnu.org/ml/gcc-patches/2017-12/msg01330.html\n\n  \"[PATCH v4 of 03/14] C++: add location_t wrapper nodes during parsing (minimal impl)\"\n    https://gcc.gnu.org/ml/gcc-patches/2018-01/msg00660.html\n\n  \"[PATCH 04/14] Update testsuite to show improvements\"\n    https://gcc.gnu.org/ml/gcc-patches/2017-11/msg00891.html\n\n  \"[v3 of 05/14] C++: handle locations wrappers when calling warn_for_memset\"\n    https://gcc.gnu.org/ml/gcc-patches/2017-12/msg01378.html\n\n  \"[PATCH 07/14] reject_gcc_builtin: strip any location wrappers\"\n    https://gcc.gnu.org/ml/gcc-patches/2017-11/msg00886.html\n\n  \"[v3 of PATCH 08/14] cp/tree.c: strip location wrappers in lvalue_kind\"\n    https://gcc.gnu.org/ml/gcc-patches/2017-12/msg01433.html\n\n  \"[PATCH 09/14] Strip location wrappers in null_ptr_cst_p\"\n    https://gcc.gnu.org/ml/gcc-patches/2017-11/msg00888.html\n\n  \"[PATCH 11/14] Handle location wrappers in string_conv_p\"\n    https://gcc.gnu.org/ml/gcc-patches/2017-11/msg00890.html\n\n  \"[PATCH 12/14] C++: introduce null_node_p\"\n    https://gcc.gnu.org/ml/gcc-patches/2017-11/msg00894.html\n\n  \"[v3 of PATCH 13/14] c-format.c: handle location wrappers\"\n    https://gcc.gnu.org/ml/gcc-patches/2017-12/msg01494.html\n\n  \"[PATCH 14/14] pp_c_cast_expression: don't print casts for location wrappers\"\n    https://gcc.gnu.org/ml/gcc-patches/2017-11/msg00893.html\n\n  \"[v3 of PATCH 15/14] Use fold_for_warn in get_atomic_generic_size\"\n    https://gcc.gnu.org/ml/gcc-patches/2017-12/msg01380.html\n\n  \"[PATCH] Add selftest for \"fold_for_warn (error_mark_node)\"\"\n    https://gcc.gnu.org/ml/gcc-patches/2017-12/msg01385.html\n\ngcc/c-family/ChangeLog:\n\tPR c++/43486\n\t* c-common.c: Include \"selftest.h\".\n\t(get_atomic_generic_size): Perform the test for integral type\n\tbefore the range test for any integer constant, fixing indentation\n\tof braces.  Call fold_for_warn before testing for an INTEGER_CST.\n\t(reject_gcc_builtin): Strip any location wrapper from EXPR.\n\t(selftest::test_fold_for_warn): New function.\n\t(selftest::c_common_c_tests): New function.\n\t(selftest::c_family_tests): Call it, and\n\tselftest::c_pretty_print_c_tests.\n\t* c-common.h (selftest::c_pretty_print_c_tests): New decl.\n\t* c-format.c (check_format_arg): Convert VAR_P check to a\n\tfold_for_warn.\n\t* c-pretty-print.c: Include \"selftest.h\".\n\t(pp_c_cast_expression): Don't print casts for location wrappers.\n\t(selftest::assert_c_pretty_printer_output): New function.\n\t(ASSERT_C_PRETTY_PRINTER_OUTPUT): New macro.\n\t(selftest::test_location_wrappers): New function.\n\t(selftest::c_pretty_print_c_tests): New function.\n\t* c-warn.c (warn_for_memset): Call fold_for_warn on the arguments.\n\ngcc/cp/ChangeLog:\n\tPR c++/43486\n\t* call.c (null_ptr_cst_p): Strip location wrappers when\n\tconverting from '0' to a pointer type in C++11 onwards.\n\t(conversion_null_warnings): Replace comparison with null_node with\n\tcall to null_node_p.\n\t(build_over_call): Likewise.\n\t* cp-gimplify.c (cp_fold): Remove the early bailout when\n\tprocessing_template_decl.\n\t* cp-lang.c (selftest::run_cp_tests): Call\n\tselftest::cp_pt_c_tests and selftest::cp_tree_c_tests.\n\t* cp-tree.h (cp_expr::maybe_add_location_wrapper): New method.\n\t(selftest::run_cp_tests): Move decl to bottom of file.\n\t(null_node_p): New inline function.\n\t(selftest::cp_pt_c_tests): New decl.\n\t(selftest::cp_tree_c_tests): New decl.\n\t* cvt.c (build_expr_type_conversion): Replace comparison with\n\tnull_node with call to null_node_p.\n\t* error.c (args_to_string): Likewise.\n\t* except.c (build_throw): Likewise.\n\t* mangle.c (write_expression): Skip location wrapper nodes.\n\t* parser.c (literal_integer_zerop): New function.\n\t(cp_parser_postfix_expression): Call maybe_add_location_wrapper on\n\tthe result for RID_TYPEID. Pass true for new \"wrap_locations_p\"\n\tparam of cp_parser_parenthesized_expression_list.  When calling\n\twarn_for_memset, replace integer_zerop calls with\n\tliteral_integer_zerop, eliminating the double logical negation\n\tcast to bool.  Eliminate the special-casing for CONST_DECL in\n\tfavor of the fold_for_warn within warn_for_memset.\n\t(cp_parser_parenthesized_expression_list): Add \"wrap_locations_p\"\n\tparam, defaulting to false.  Convert \"expr\" to a cp_expr, and call\n\tmaybe_add_location_wrapper on it when wrap_locations_p is true.\n\t(cp_parser_unary_expression): Call maybe_add_location_wrapper on\n\tthe result for RID_ALIGNOF and RID_SIZEOF.\n\t(cp_parser_builtin_offsetof): Likewise.\n\t* pt.c: Include \"selftest.h\".\n\t(tsubst_copy): Handle location wrappers.\n\t(tsubst_copy_and_build): Likewise.\n\t(build_non_dependent_expr): Likewise.\n\t(selftest::test_build_non_dependent_expr): New function.\n\t(selftest::cp_pt_c_tests): New function.\n\t* tree.c: Include \"selftest.h\".\n\t(lvalue_kind): Handle VIEW_CONVERT_EXPR location wrapper nodes.\n\t(selftest::test_lvalue_kind): New function.\n\t(selftest::cp_tree_c_tests): New function.\n\t* typeck.c (string_conv_p): Strip any location wrapper from \"exp\".\n\t(cp_build_binary_op): Replace comparison with null_node with call\n\tto null_node_p.\n\t(build_address): Use location of operand when building address\n\texpression.\n\ngcc/testsuite/ChangeLog:\n\tPR c++/43486\n\t* g++.dg/diagnostic/param-type-mismatch.C: Update expected results\n\tto reflect that the arguments are correctly underlined.\n\t* g++.dg/plugin/diagnostic-test-expressions-1.C: Add test coverage\n\tfor globals, params, locals and literals.\n\t(test_sizeof): Directly test the location of \"sizeof\", rather than\n\twhen used in compound expressions.\n\t(test_alignof): Likewise for \"alignof\".\n\t(test_string_literals): Likewise for string literals.\n\t(test_numeric_literals): Likewise for numeric literals.\n\t(test_builtin_offsetof): Likewise for \"__builtin_offsetof\".\n\t(test_typeid): Likewise for typeid.\n\t(test_unary_plus): New.\n\t* g++.dg/warn/Wformat-1.C: Add tests of pointer arithmetic on\n\tformat strings.\n\ngcc/ChangeLog:\n\tPR c++/43486\n\t* tree-core.h: Document EXPR_LOCATION_WRAPPER_P's usage of\n\t\"public_flag\".\n\t* tree.c (tree_nop_conversion): Return true for location wrapper\n\tnodes.\n\t(maybe_wrap_with_location): New function.\n\t(selftest::check_strip_nops): New function.\n\t(selftest::test_location_wrappers): New function.\n\t(selftest::tree_c_tests): Call it.\n\t* tree.h (STRIP_ANY_LOCATION_WRAPPER): New macro.\n\t(maybe_wrap_with_location): New decl.\n\t(EXPR_LOCATION_WRAPPER_P): New macro.\n\t(location_wrapper_p): New inline function.\n\t(tree_strip_any_location_wrapper): New inline function.\n\nFrom-SVN: r256448", "tree": {"sha": "74d2d62696c26cee3eb63313868f3150f67c4aa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74d2d62696c26cee3eb63313868f3150f67c4aa3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a004410d9f64d658864a899ab911ae9a31c444c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a004410d9f64d658864a899ab911ae9a31c444c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a004410d9f64d658864a899ab911ae9a31c444c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a004410d9f64d658864a899ab911ae9a31c444c/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "60d87d86163186669af4b0f493be462e2aadca77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60d87d86163186669af4b0f493be462e2aadca77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60d87d86163186669af4b0f493be462e2aadca77"}], "stats": {"total": 913, "additions": 749, "deletions": 164}, "files": [{"sha": "a292768d13a23e1edc614863b65fa024dc721984", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -1,3 +1,20 @@\n+2018-01-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/43486\n+\t* tree-core.h: Document EXPR_LOCATION_WRAPPER_P's usage of\n+\t\"public_flag\".\n+\t* tree.c (tree_nop_conversion): Return true for location wrapper\n+\tnodes.\n+\t(maybe_wrap_with_location): New function.\n+\t(selftest::check_strip_nops): New function.\n+\t(selftest::test_location_wrappers): New function.\n+\t(selftest::tree_c_tests): Call it.\n+\t* tree.h (STRIP_ANY_LOCATION_WRAPPER): New macro.\n+\t(maybe_wrap_with_location): New decl.\n+\t(EXPR_LOCATION_WRAPPER_P): New macro.\n+\t(location_wrapper_p): New inline function.\n+\t(tree_strip_any_location_wrapper): New inline function.\n+\n 2018-01-10  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/83735"}, {"sha": "d6b60856eaf61b720ad183ae22bb01ad2dc30747", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -1,3 +1,26 @@\n+2018-01-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/43486\n+\t* c-common.c: Include \"selftest.h\".\n+\t(get_atomic_generic_size): Perform the test for integral type\n+\tbefore the range test for any integer constant, fixing indentation\n+\tof braces.  Call fold_for_warn before testing for an INTEGER_CST.\n+\t(reject_gcc_builtin): Strip any location wrapper from EXPR.\n+\t(selftest::test_fold_for_warn): New function.\n+\t(selftest::c_common_c_tests): New function.\n+\t(selftest::c_family_tests): Call it, and\n+\tselftest::c_pretty_print_c_tests.\n+\t* c-common.h (selftest::c_pretty_print_c_tests): New decl.\n+\t* c-format.c (check_format_arg): Convert VAR_P check to a\n+\tfold_for_warn.\n+\t* c-pretty-print.c: Include \"selftest.h\".\n+\t(pp_c_cast_expression): Don't print casts for location wrappers.\n+\t(selftest::assert_c_pretty_printer_output): New function.\n+\t(ASSERT_C_PRETTY_PRINTER_OUTPUT): New macro.\n+\t(selftest::test_location_wrappers): New function.\n+\t(selftest::c_pretty_print_c_tests): New function.\n+\t* c-warn.c (warn_for_memset): Call fold_for_warn on the arguments.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "097d192c8691c9339cdd24599a77466277926046", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n #include \"substring-locations.h\"\n #include \"spellcheck.h\"\n+#include \"selftest.h\"\n \n cpp_reader *parse_in;\t\t/* Declared in c-pragma.h.  */\n \n@@ -6737,8 +6738,15 @@ get_atomic_generic_size (location_t loc, tree function,\n   for (x = n_param - n_model ; x < n_param; x++)\n     {\n       tree p = (*params)[x];\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (p)))\n+\t{\n+\t  error_at (loc, \"non-integer memory model argument %d of %qE\", x + 1,\n+\t\t    function);\n+\t  return 0;\n+\t}\n+      p = fold_for_warn (p);\n       if (TREE_CODE (p) == INTEGER_CST)\n-        {\n+\t{\n \t  /* memmodel_base masks the low 16 bits, thus ignore any bits above\n \t     it by using TREE_INT_CST_LOW instead of tree_to_*hwi.  Those high\n \t     bits will be checked later during expansion in target specific\n@@ -6748,14 +6756,7 @@ get_atomic_generic_size (location_t loc, tree function,\n \t\t\t\"invalid memory model argument %d of %qE\", x + 1,\n \t\t\tfunction);\n \t}\n-      else\n-\tif (!INTEGRAL_TYPE_P (TREE_TYPE (p)))\n-\t  {\n-\t    error_at (loc, \"non-integer memory model argument %d of %qE\", x + 1,\n-\t\t   function);\n-\t    return 0;\n-\t  }\n-      }\n+    }\n \n   return size_0;\n }\n@@ -7846,6 +7847,8 @@ reject_gcc_builtin (const_tree expr, location_t loc /* = UNKNOWN_LOCATION */)\n   if (TREE_CODE (expr) == ADDR_EXPR)\n     expr = TREE_OPERAND (expr, 0);\n \n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n   if (TREE_TYPE (expr)\n       && TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE\n       && TREE_CODE (expr) == FUNCTION_DECL\n@@ -8187,12 +8190,30 @@ maybe_suggest_missing_token_insertion (rich_location *richloc,\n \n namespace selftest {\n \n+/* Verify that fold_for_warn on error_mark_node is safe.  */\n+\n+static void\n+test_fold_for_warn ()\n+{\n+  ASSERT_EQ (error_mark_node, fold_for_warn (error_mark_node));\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+static void\n+c_common_c_tests ()\n+{\n+  test_fold_for_warn ();\n+}\n+\n /* Run all of the tests within c-family.  */\n \n void\n c_family_tests (void)\n {\n+  c_common_c_tests ();\n   c_format_c_tests ();\n+  c_pretty_print_c_tests ();\n   c_spellcheck_cc_tests ();\n }\n "}, {"sha": "d090881e95d5f66ba65aae12d606c08b54719950", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -1450,6 +1450,7 @@ namespace selftest {\n   /* Declarations for specific families of tests within c-family,\n      by source file, in alphabetical order.  */\n   extern void c_format_c_tests (void);\n+  extern void c_pretty_print_c_tests (void);\n   extern void c_spellcheck_cc_tests (void);\n \n   /* The entrypoint for running all of the above tests.  */"}, {"sha": "7a69d5a295cf639875258128029170cd00829bf1", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -1536,12 +1536,10 @@ check_format_arg (void *ctx, tree format_tree,\n \n   location_t fmt_param_loc = EXPR_LOC_OR_LOC (format_tree, input_location);\n \n-  if (VAR_P (format_tree))\n-    {\n-      /* Pull out a constant value if the front end didn't.  */\n-      format_tree = decl_constant_value (format_tree);\n-      STRIP_NOPS (format_tree);\n-    }\n+  /* Pull out a constant value if the front end didn't, and handle location\n+     wrappers.  */\n+  format_tree = fold_for_warn (format_tree);\n+  STRIP_NOPS (format_tree);\n \n   if (integer_zerop (format_tree))\n     {"}, {"sha": "c9dd8aefff9beaadf54350b0a5be99c6a45954ba", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"intl.h\"\n #include \"tree-pretty-print.h\"\n+#include \"selftest.h\"\n \n /* The pretty-printer code is primarily designed to closely follow\n    (GNU) C and C++ grammars.  That is to be contrasted with spaghetti\n@@ -1809,7 +1810,8 @@ pp_c_cast_expression (c_pretty_printer *pp, tree e)\n     case FIX_TRUNC_EXPR:\n     CASE_CONVERT:\n     case VIEW_CONVERT_EXPR:\n-      pp_c_type_cast (pp, TREE_TYPE (e));\n+      if (!location_wrapper_p (e))\n+\tpp_c_type_cast (pp, TREE_TYPE (e));\n       pp_c_cast_expression (pp, TREE_OPERAND (e, 0));\n       break;\n \n@@ -2400,3 +2402,65 @@ pp_c_tree_decl_identifier (c_pretty_printer *pp, tree t)\n \n   pp_c_identifier (pp, name);\n }\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Selftests for pretty-printing trees.  */\n+\n+/* Verify that EXPR printed by c_pretty_printer is EXPECTED, using\n+   LOC as the effective location for any failures.  */\n+\n+static void\n+assert_c_pretty_printer_output (const location &loc, const char *expected,\n+\t\t\t\ttree expr)\n+{\n+  c_pretty_printer pp;\n+  pp.expression (expr);\n+  ASSERT_STREQ_AT (loc, expected, pp_formatted_text (&pp));\n+}\n+\n+/* Helper function for calling assert_c_pretty_printer_output.\n+   This is to avoid having to write SELFTEST_LOCATION.  */\n+\n+#define ASSERT_C_PRETTY_PRINTER_OUTPUT(EXPECTED, EXPR) \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\\\n+    assert_c_pretty_printer_output ((SELFTEST_LOCATION),\t\\\n+\t\t\t\t    (EXPECTED),\t\t\\\n+\t\t\t\t    (EXPR));\t\t\t\\\n+  SELFTEST_END_STMT\n+\n+/* Verify that location wrappers don't show up in pretty-printed output.  */\n+\n+static void\n+test_location_wrappers ()\n+{\n+  /* VAR_DECL.  */\n+  tree id = get_identifier (\"foo\");\n+  tree decl = build_decl (UNKNOWN_LOCATION, VAR_DECL, id,\n+\t\t\t  integer_type_node);\n+  tree wrapped_decl = maybe_wrap_with_location (decl, BUILTINS_LOCATION);\n+  ASSERT_NE (wrapped_decl, decl);\n+  ASSERT_C_PRETTY_PRINTER_OUTPUT (\"foo\", decl);\n+  ASSERT_C_PRETTY_PRINTER_OUTPUT (\"foo\", wrapped_decl);\n+\n+  /* INTEGER_CST.  */\n+  tree int_cst = build_int_cst (integer_type_node, 42);\n+  tree wrapped_cst = maybe_wrap_with_location (int_cst, BUILTINS_LOCATION);\n+  ASSERT_NE (wrapped_cst, int_cst);\n+  ASSERT_C_PRETTY_PRINTER_OUTPUT (\"42\", int_cst);\n+  ASSERT_C_PRETTY_PRINTER_OUTPUT (\"42\", wrapped_cst);\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+c_pretty_print_c_tests ()\n+{\n+  test_location_wrappers ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* CHECKING_P */"}, {"sha": "7d87c455ec0c7dacd6774b41c362a5bb6a37c6a5", "filename": "gcc/c-family/c-warn.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fc-family%2Fc-warn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fc-family%2Fc-warn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.c?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -1868,6 +1868,9 @@ void\n warn_for_memset (location_t loc, tree arg0, tree arg2,\n \t\t int literal_zero_mask)\n {\n+  arg0 = fold_for_warn (arg0);\n+  arg2 = fold_for_warn (arg2);\n+\n   if (warn_memset_transposed_args\n       && integer_zerop (arg2)\n       && (literal_zero_mask & (1 << 2)) != 0"}, {"sha": "d24c9343620a668275bde875640863479e025257", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -1,3 +1,55 @@\n+2018-01-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/43486\n+\t* call.c (null_ptr_cst_p): Strip location wrappers when\n+\tconverting from '0' to a pointer type in C++11 onwards.\n+\t(conversion_null_warnings): Replace comparison with null_node with\n+\tcall to null_node_p.\n+\t(build_over_call): Likewise.\n+\t* cp-gimplify.c (cp_fold): Remove the early bailout when\n+\tprocessing_template_decl.\n+\t* cp-lang.c (selftest::run_cp_tests): Call\n+\tselftest::cp_pt_c_tests and selftest::cp_tree_c_tests.\n+\t* cp-tree.h (cp_expr::maybe_add_location_wrapper): New method.\n+\t(selftest::run_cp_tests): Move decl to bottom of file.\n+\t(null_node_p): New inline function.\n+\t(selftest::cp_pt_c_tests): New decl.\n+\t(selftest::cp_tree_c_tests): New decl.\n+\t* cvt.c (build_expr_type_conversion): Replace comparison with\n+\tnull_node with call to null_node_p.\n+\t* error.c (args_to_string): Likewise.\n+\t* except.c (build_throw): Likewise.\n+\t* mangle.c (write_expression): Skip location wrapper nodes.\n+\t* parser.c (literal_integer_zerop): New function.\n+\t(cp_parser_postfix_expression): Call maybe_add_location_wrapper on\n+\tthe result for RID_TYPEID. Pass true for new \"wrap_locations_p\"\n+\tparam of cp_parser_parenthesized_expression_list.  When calling\n+\twarn_for_memset, replace integer_zerop calls with\n+\tliteral_integer_zerop, eliminating the double logical negation\n+\tcast to bool.  Eliminate the special-casing for CONST_DECL in\n+\tfavor of the fold_for_warn within warn_for_memset.\n+\t(cp_parser_parenthesized_expression_list): Add \"wrap_locations_p\"\n+\tparam, defaulting to false.  Convert \"expr\" to a cp_expr, and call\n+\tmaybe_add_location_wrapper on it when wrap_locations_p is true.\n+\t(cp_parser_unary_expression): Call maybe_add_location_wrapper on\n+\tthe result for RID_ALIGNOF and RID_SIZEOF.\n+\t(cp_parser_builtin_offsetof): Likewise.\n+\t* pt.c: Include \"selftest.h\".\n+\t(tsubst_copy): Handle location wrappers.\n+\t(tsubst_copy_and_build): Likewise.\n+\t(build_non_dependent_expr): Likewise.\n+\t(selftest::test_build_non_dependent_expr): New function.\n+\t(selftest::cp_pt_c_tests): New function.\n+\t* tree.c: Include \"selftest.h\".\n+\t(lvalue_kind): Handle VIEW_CONVERT_EXPR location wrapper nodes.\n+\t(selftest::test_lvalue_kind): New function.\n+\t(selftest::cp_tree_c_tests): New function.\n+\t* typeck.c (string_conv_p): Strip any location wrapper from \"exp\".\n+\t(cp_build_binary_op): Replace comparison with null_node with call\n+\tto null_node_p.\n+\t(build_address): Use location of operand when building address\n+\texpression.\n+\n 2018-01-10  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/82541"}, {"sha": "c822a70a017668b3aedff2dfa50eba3962bfa02b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -528,6 +528,8 @@ null_ptr_cst_p (tree t)\n \n   if (cxx_dialect >= cxx11)\n     {\n+      STRIP_ANY_LOCATION_WRAPPER (t);\n+\n       /* Core issue 903 says only literal 0 is a null pointer constant.  */\n       if (TREE_CODE (type) == INTEGER_TYPE\n \t  && !char_type_p (type)\n@@ -6531,7 +6533,7 @@ static void\n conversion_null_warnings (tree totype, tree expr, tree fn, int argnum)\n {\n   /* Issue warnings about peculiar, but valid, uses of NULL.  */\n-  if (expr == null_node && TREE_CODE (totype) != BOOLEAN_TYPE\n+  if (null_node_p (expr) && TREE_CODE (totype) != BOOLEAN_TYPE\n       && ARITHMETIC_TYPE_P (totype))\n     {\n       source_location loc =\n@@ -7865,7 +7867,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n              func(NULL);\n            }\n       */\n-      if (arg == null_node\n+      if (null_node_p (arg)\n           && DECL_TEMPLATE_INFO (fn)\n           && cand->template_decl\n           && !(flags & LOOKUP_EXPLICIT_TMPL_ARGS))"}, {"sha": "e97247c13843aba91591626f977288b45af6dc17", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -2064,7 +2064,7 @@ clear_fold_cache (void)\n \n /*  This function tries to fold an expression X.\n     To avoid combinatorial explosion, folding results are kept in fold_cache.\n-    If we are processing a template or X is invalid, we don't fold at all.\n+    If X is invalid, we don't fold at all.\n     For performance reasons we don't cache expressions representing a\n     declaration or constant.\n     Function returns X or its folded variant.  */\n@@ -2081,8 +2081,7 @@ cp_fold (tree x)\n   if (!x || x == error_mark_node)\n     return x;\n \n-  if (processing_template_decl\n-      || (EXPR_P (x) && (!TREE_TYPE (x) || TREE_TYPE (x) == error_mark_node)))\n+  if (EXPR_P (x) && (!TREE_TYPE (x) || TREE_TYPE (x) == error_mark_node))\n     return x;\n \n   /* Don't bother to cache DECLs or constants.  */"}, {"sha": "6007094e0a6f7446dbc36436a421b9a1a2ace593", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -247,6 +247,8 @@ run_cp_tests (void)\n   c_family_tests ();\n \n   /* Additional C++-specific tests.  */\n+  cp_pt_c_tests ();\n+  cp_tree_c_tests ();\n }\n \n } // namespace selftest"}, {"sha": "9c6c1791e1acc31db3775c0c702579f6ec11f18d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -93,6 +93,12 @@ class cp_expr\n     set_location (make_location (m_loc, start, finish));\n   }\n \n+  cp_expr& maybe_add_location_wrapper ()\n+  {\n+    m_value = maybe_wrap_with_location (m_value, m_loc);\n+    return *this;\n+  }\n+\n  private:\n   tree m_value;\n   location_t m_loc;\n@@ -7422,12 +7428,6 @@ extern tree cp_ubsan_maybe_instrument_downcast\t(location_t, tree, tree, tree);\n extern tree cp_ubsan_maybe_instrument_cast_to_vbase (location_t, tree, tree);\n extern void cp_ubsan_maybe_initialize_vtbl_ptrs (tree);\n \n-#if CHECKING_P\n-namespace selftest {\n-  extern void run_cp_tests (void);\n-} // namespace selftest\n-#endif /* #if CHECKING_P */\n-\n /* Inline bodies.  */\n \n inline tree\n@@ -7458,6 +7458,24 @@ named_decl_hash::equal (const value_type existing, compare_type candidate)\n   return candidate == name;\n }\n \n+inline bool\n+null_node_p (const_tree expr)\n+{\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+  return expr == null_node;\n+}\n+\n+#if CHECKING_P\n+namespace selftest {\n+  extern void run_cp_tests (void);\n+\n+  /* Declarations for specific families of tests within cp,\n+     by source file, in alphabetical order.  */\n+  extern void cp_pt_c_tests ();\n+  extern void cp_tree_c_tests (void);\n+} // namespace selftest\n+#endif /* #if CHECKING_P */\n+\n /* -- end of C++ */\n \n #endif /* ! GCC_CP_TREE_H */"}, {"sha": "7ed2aad613606c45ce1e4b6a985cf55a753bc3e3", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -1642,7 +1642,7 @@ build_expr_type_conversion (int desires, tree expr, bool complain)\n   tree conv = NULL_TREE;\n   tree winner = NULL_TREE;\n \n-  if (expr == null_node\n+  if (null_node_p (expr)\n       && (desires & WANT_INT)\n       && !(desires & WANT_NULL))\n     {"}, {"sha": "cb1dcf362013eed259bae0890986f363471b334e", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -3230,7 +3230,7 @@ args_to_string (tree p, int verbose)\n   reinit_cxx_pp ();\n   for (; p; p = TREE_CHAIN (p))\n     {\n-      if (TREE_VALUE (p) == null_node)\n+      if (null_node_p (TREE_VALUE (p)))\n \tpp_cxx_ws_string (cxx_pp, \"NULL\");\n       else\n \tdump_type (cxx_pp, error_type (TREE_VALUE (p)), flags);"}, {"sha": "669bf9f6eaf5c6f2c8e02ea2293134c6ae5ad1c5", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -577,7 +577,7 @@ build_throw (tree exp)\n       return exp;\n     }\n \n-  if (exp == null_node)\n+  if (exp && null_node_p (exp))\n     warning (0, \"throwing NULL, which has integral, not pointer type\");\n \n   if (exp != NULL_TREE)"}, {"sha": "94c4bed2848690352ad9308794c8bfd9c9ccf2bf", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -2890,6 +2890,7 @@ write_expression (tree expr)\n   /* Skip NOP_EXPR and CONVERT_EXPR.  They can occur when (say) a pointer\n      argument is converted (via qualification conversions) to another type.  */\n   while (CONVERT_EXPR_CODE_P (code)\n+\t || location_wrapper_p (expr)\n \t /* Parentheses aren't mangled.  */\n \t || code == PAREN_EXPR\n \t || code == NON_LVALUE_EXPR)"}, {"sha": "b16597ce9b78af2ca906b50fb6a37686bb5c27e0", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -2047,7 +2047,8 @@ static tree cp_parser_postfix_open_square_expression\n static tree cp_parser_postfix_dot_deref_expression\n   (cp_parser *, enum cpp_ttype, cp_expr, bool, cp_id_kind *, location_t);\n static vec<tree, va_gc> *cp_parser_parenthesized_expression_list\n-  (cp_parser *, int, bool, bool, bool *, location_t * = NULL);\n+  (cp_parser *, int, bool, bool, bool *, location_t * = NULL,\n+   bool = false);\n /* Values for the second parameter of cp_parser_parenthesized_expression_list.  */\n enum { non_attr = 0, normal_attr = 1, id_attr = 2 };\n static void cp_parser_pseudo_destructor_name\n@@ -6620,6 +6621,16 @@ cp_parser_compound_literal_p (cp_parser *parser)\n   return compound_literal_p;\n }\n \n+/* Return true if EXPR is the integer constant zero or a complex constant\n+   of zero, without any folding, but ignoring location wrappers.  */\n+\n+static bool\n+literal_integer_zerop (const_tree expr)\n+{\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+  return integer_zerop (expr);\n+}\n+\n /* Parse a postfix-expression.\n \n    postfix-expression:\n@@ -6831,6 +6842,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    location_t typeid_loc\n \t      = make_location (start_loc, start_loc, close_paren->location);\n \t    postfix_expression.set_location (typeid_loc);\n+\t    postfix_expression.maybe_add_location_wrapper ();\n \t  }\n       }\n       break;\n@@ -7088,7 +7100,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t    (parser, non_attr,\n \t\t     /*cast_p=*/false, /*allow_expansion_p=*/true,\n \t\t     /*non_constant_p=*/NULL,\n-\t\t     /*close_paren_loc=*/&close_paren_loc));\n+\t\t     /*close_paren_loc=*/&close_paren_loc,\n+\t\t     /*wrap_locations_p=*/true));\n \t    if (is_builtin_constant_p)\n \t      {\n \t\tparser->integral_constant_expression_p\n@@ -7164,10 +7177,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\ttree arg0 = (*args)[0];\n \t\ttree arg1 = (*args)[1];\n \t\ttree arg2 = (*args)[2];\n-\t\tint literal_mask = ((!!integer_zerop (arg1) << 1)\n-\t\t\t\t    | (!!integer_zerop (arg2) << 2));\n-\t\tif (TREE_CODE (arg2) == CONST_DECL)\n-\t\t  arg2 = DECL_INITIAL (arg2);\n+\t\tint literal_mask = ((literal_integer_zerop (arg1) << 1)\n+\t\t\t\t    | (literal_integer_zerop (arg2) << 2));\n \t\twarn_for_memset (input_location, arg0, arg2, literal_mask);\n \t      }\n \n@@ -7621,6 +7632,10 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n    ALLOW_EXPANSION_P is true if this expression allows expansion of an\n    argument pack.\n \n+   WRAP_LOCATIONS_P is true if expressions within this list for which\n+   CAN_HAVE_LOCATION_P is false should be wrapped with nodes expressing\n+   their source locations.\n+\n    Returns a vector of trees.  Each element is a representation of an\n    assignment-expression.  NULL is returned if the ( and or ) are\n    missing.  An empty, but allocated, vector is returned on no\n@@ -7640,7 +7655,8 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t\t\t\t\t bool cast_p,\n                                          bool allow_expansion_p,\n \t\t\t\t\t bool *non_constant_p,\n-\t\t\t\t\t location_t *close_paren_loc)\n+\t\t\t\t\t location_t *close_paren_loc,\n+\t\t\t\t\t bool wrap_locations_p)\n {\n   vec<tree, va_gc> *expression_list;\n   bool fold_expr_p = is_attribute_list != non_attr;\n@@ -7663,12 +7679,12 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n     = parser->greater_than_is_operator_p;\n   parser->greater_than_is_operator_p = true;\n \n+  cp_expr expr (NULL_TREE);\n+\n   /* Consume expressions until there are no more.  */\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n     while (true)\n       {\n-\ttree expr;\n-\n \t/* At the beginning of attribute lists, check to see if the\n \t   next token is an identifier.  */\n \tif (is_attribute_list == id_attr\n@@ -7722,11 +7738,14 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n                 expr = make_pack_expansion (expr);\n               }\n \n+\t    if (wrap_locations_p)\n+\t      expr.maybe_add_location_wrapper ();\n+\n \t     /* Add it to the list.  We add error_mark_node\n \t\texpressions to the list, so that we can still tell if\n \t\tthe correct form for a parenthesized expression-list\n \t\tis found. That gives better errors.  */\n-\t    vec_safe_push (expression_list, expr);\n+\t    vec_safe_push (expression_list, expr.get_value ());\n \n \t    if (expr == error_mark_node)\n \t      goto skip_comma;\n@@ -7992,6 +8011,7 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \n \t    cp_expr ret_expr (ret);\n \t    ret_expr.set_location (compound_loc);\n+\t    ret_expr = ret_expr.maybe_add_location_wrapper ();\n \t    return ret_expr;\n \t  }\n \n@@ -9831,6 +9851,7 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n   parser->integral_constant_expression_p = save_ice_p;\n   parser->non_integral_constant_expression_p = save_non_ice_p;\n \n+  expr = expr.maybe_add_location_wrapper ();\n   return expr;\n }\n "}, {"sha": "bb5908fb85319203e3f33677454a6b41d63e628a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 76, "deletions": 7, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"type-utils.h\"\n #include \"gimplify.h\"\n #include \"gcc-rich-location.h\"\n+#include \"selftest.h\"\n \n /* The type of functions taking a tree, and some additional data, and\n    returning an int.  */\n@@ -14924,6 +14925,18 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t/* Ordinary template template argument.  */\n \treturn t;\n \n+    case NON_LVALUE_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+\t{\n+\t  /* Handle location wrappers by substituting the wrapped node\n+\t     first, *then* reusing the resulting type.  Doing the type\n+\t     first ensures that we handle template parameters and\n+\t     parameter pack expansions.  */\n+\t  gcc_assert (location_wrapper_p (t));\n+\t  tree op0 = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\t  return maybe_wrap_with_location (op0, EXPR_LOCATION (t));\n+\t}\n+\n     case CAST_EXPR:\n     case REINTERPRET_CAST_EXPR:\n     case CONST_CAST_EXPR:\n@@ -18291,6 +18304,16 @@ tsubst_copy_and_build (tree t,\n     case REQUIRES_EXPR:\n       RETURN (tsubst_requires_expr (t, args, complain, in_decl));\n \n+    case NON_LVALUE_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+      /* We should only see these for location wrapper nodes, or within\n+\t instantiate_non_dependent_expr (when args is NULL_TREE).  */\n+      gcc_assert (location_wrapper_p (t) || args == NULL_TREE);\n+      if (location_wrapper_p (t))\n+\tRETURN (maybe_wrap_with_location (RECUR (TREE_OPERAND (t, 0)),\n+\t\t\t\t\t  EXPR_LOCATION (t)));\n+      /* fallthrough.  */\n+\n     default:\n       /* Handle Objective-C++ constructs, if appropriate.  */\n       {\n@@ -24982,6 +25005,7 @@ resolve_typename_type (tree type, bool only_current_p)\n tree\n build_non_dependent_expr (tree expr)\n {\n+  tree orig_expr = expr;\n   tree inner_expr;\n \n   /* When checking, try to get a constant value for all non-dependent\n@@ -24998,6 +25022,8 @@ build_non_dependent_expr (tree expr)\n       && !expanding_concept ())\n     fold_non_dependent_expr (expr);\n \n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n   /* Preserve OVERLOADs; the functions must be available to resolve\n      types.  */\n   inner_expr = expr;\n@@ -25009,36 +25035,36 @@ build_non_dependent_expr (tree expr)\n     inner_expr = TREE_OPERAND (inner_expr, 1);\n   if (is_overloaded_fn (inner_expr)\n       || TREE_CODE (inner_expr) == OFFSET_REF)\n-    return expr;\n+    return orig_expr;\n   /* There is no need to return a proxy for a variable.  */\n   if (VAR_P (expr))\n-    return expr;\n+    return orig_expr;\n   /* Preserve string constants; conversions from string constants to\n      \"char *\" are allowed, even though normally a \"const char *\"\n      cannot be used to initialize a \"char *\".  */\n   if (TREE_CODE (expr) == STRING_CST)\n-    return expr;\n+    return orig_expr;\n   /* Preserve void and arithmetic constants, as an optimization -- there is no\n      reason to create a new node.  */\n   if (TREE_CODE (expr) == VOID_CST\n       || TREE_CODE (expr) == INTEGER_CST\n       || TREE_CODE (expr) == REAL_CST)\n-    return expr;\n+    return orig_expr;\n   /* Preserve THROW_EXPRs -- all throw-expressions have type \"void\".\n      There is at least one place where we want to know that a\n      particular expression is a throw-expression: when checking a ?:\n      expression, there are special rules if the second or third\n      argument is a throw-expression.  */\n   if (TREE_CODE (expr) == THROW_EXPR)\n-    return expr;\n+    return orig_expr;\n \n   /* Don't wrap an initializer list, we need to be able to look inside.  */\n   if (BRACE_ENCLOSED_INITIALIZER_P (expr))\n-    return expr;\n+    return orig_expr;\n \n   /* Don't wrap a dummy object, we need to be able to test for it.  */\n   if (is_dummy_object (expr))\n-    return expr;\n+    return orig_expr;\n \n   if (TREE_CODE (expr) == COND_EXPR)\n     return build3 (COND_EXPR,\n@@ -26601,4 +26627,47 @@ print_template_statistics (void)\n \t   type_specializations->collisions ());\n }\n \n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Verify that build_non_dependent_expr () works, for various expressions,\n+   and that location wrappers don't affect the results.  */\n+\n+static void\n+test_build_non_dependent_expr ()\n+{\n+  location_t loc = BUILTINS_LOCATION;\n+\n+  /* Verify constants, without and with location wrappers.  */\n+  tree int_cst = build_int_cst (integer_type_node, 42);\n+  ASSERT_EQ (int_cst, build_non_dependent_expr (int_cst));\n+\n+  tree wrapped_int_cst = maybe_wrap_with_location (int_cst, loc);\n+  ASSERT_TRUE (location_wrapper_p (wrapped_int_cst));\n+  ASSERT_EQ (wrapped_int_cst, build_non_dependent_expr (wrapped_int_cst));\n+\n+  tree string_lit = build_string (4, \"foo\");\n+  TREE_TYPE (string_lit) = char_array_type_node;\n+  string_lit = fix_string_type (string_lit);\n+  ASSERT_EQ (string_lit, build_non_dependent_expr (string_lit));\n+\n+  tree wrapped_string_lit = maybe_wrap_with_location (string_lit, loc);\n+  ASSERT_TRUE (location_wrapper_p (wrapped_string_lit));\n+  ASSERT_EQ (wrapped_string_lit,\n+\t     build_non_dependent_expr (wrapped_string_lit));\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+cp_pt_c_tests ()\n+{\n+  test_build_non_dependent_expr ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* #if CHECKING_P */\n+\n #include \"gt-cp-pt.h\""}, {"sha": "ed51c28858f951ec1ca587620e2d4458b94c64bd", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"flags.h\"\n+#include \"selftest.h\"\n \n static tree bot_manip (tree *, int *, void *);\n static tree bot_replace (tree *, int *, void *);\n@@ -240,6 +241,11 @@ lvalue_kind (const_tree ref)\n     case NON_DEPENDENT_EXPR:\n       return lvalue_kind (TREE_OPERAND (ref, 0));\n \n+    case VIEW_CONVERT_EXPR:\n+      if (location_wrapper_p (ref))\n+\treturn lvalue_kind (TREE_OPERAND (ref, 0));\n+      /* Fallthrough.  */\n+\n     default:\n       if (!TREE_TYPE (ref))\n \treturn clk_none;\n@@ -5346,4 +5352,64 @@ lang_check_failed (const char* file, int line, const char* function)\n }\n #endif /* ENABLE_TREE_CHECKING */\n \n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Verify that lvalue_kind () works, for various expressions,\n+   and that location wrappers don't affect the results.  */\n+\n+static void\n+test_lvalue_kind ()\n+{\n+  location_t loc = BUILTINS_LOCATION;\n+\n+  /* Verify constants and parameters, without and with\n+     location wrappers.  */\n+  tree int_cst = build_int_cst (integer_type_node, 42);\n+  ASSERT_EQ (clk_none, lvalue_kind (int_cst));\n+\n+  tree wrapped_int_cst = maybe_wrap_with_location (int_cst, loc);\n+  ASSERT_TRUE (location_wrapper_p (wrapped_int_cst));\n+  ASSERT_EQ (clk_none, lvalue_kind (wrapped_int_cst));\n+\n+  tree string_lit = build_string (4, \"foo\");\n+  TREE_TYPE (string_lit) = char_array_type_node;\n+  string_lit = fix_string_type (string_lit);\n+  ASSERT_EQ (clk_ordinary, lvalue_kind (string_lit));\n+\n+  tree wrapped_string_lit = maybe_wrap_with_location (string_lit, loc);\n+  ASSERT_TRUE (location_wrapper_p (wrapped_string_lit));\n+  ASSERT_EQ (clk_ordinary, lvalue_kind (wrapped_string_lit));\n+\n+  tree parm = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n+\t\t\t  get_identifier (\"some_parm\"),\n+\t\t\t  integer_type_node);\n+  ASSERT_EQ (clk_ordinary, lvalue_kind (parm));\n+\n+  tree wrapped_parm = maybe_wrap_with_location (parm, loc);\n+  ASSERT_TRUE (location_wrapper_p (wrapped_parm));\n+  ASSERT_EQ (clk_ordinary, lvalue_kind (wrapped_parm));\n+\n+  /* Verify that lvalue_kind of std::move on a parm isn't\n+     affected by location wrappers.  */\n+  tree rvalue_ref_of_parm = move (parm);\n+  ASSERT_EQ (clk_rvalueref, lvalue_kind (rvalue_ref_of_parm));\n+  tree rvalue_ref_of_wrapped_parm = move (wrapped_parm);\n+  ASSERT_EQ (clk_rvalueref, lvalue_kind (rvalue_ref_of_wrapped_parm));\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+cp_tree_c_tests ()\n+{\n+  test_lvalue_kind ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* #if CHECKING_P */\n+\n+\n #include \"gt-cp-tree.h\""}, {"sha": "669a2b45bfdddcfdfff11979a9396bf971e046ff", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -2202,6 +2202,8 @@ string_conv_p (const_tree totype, const_tree exp, int warn)\n       && !same_type_p (t, wchar_type_node))\n     return 0;\n \n+  STRIP_ANY_LOCATION_WRAPPER (exp);\n+\n   if (TREE_CODE (exp) == STRING_CST)\n     {\n       /* Make sure that we don't try to convert between char and wide chars.  */\n@@ -4317,7 +4319,7 @@ cp_build_binary_op (location_t location,\n     }\n \n   /* Issue warnings about peculiar, but valid, uses of NULL.  */\n-  if ((orig_op0 == null_node || orig_op1 == null_node)\n+  if ((null_node_p (orig_op0) || null_node_p (orig_op1))\n       /* It's reasonable to use pointer values as operands of &&\n \t and ||, so NULL is no exception.  */\n       && code != TRUTH_ANDIF_EXPR && code != TRUTH_ORIF_EXPR \n@@ -5734,7 +5736,7 @@ build_address (tree t)\n   if (error_operand_p (t) || !cxx_mark_addressable (t))\n     return error_mark_node;\n   gcc_checking_assert (TREE_CODE (t) != CONSTRUCTOR);\n-  t = build_fold_addr_expr (t);\n+  t = build_fold_addr_expr_loc (EXPR_LOCATION (t), t);\n   if (TREE_CODE (t) != ADDR_EXPR)\n     t = rvalue (t);\n   return t;"}, {"sha": "6091e59998b46304d9a736bf3a68a5fe922801d4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -1,3 +1,21 @@\n+2018-01-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/43486\n+\t* g++.dg/diagnostic/param-type-mismatch.C: Update expected results\n+\tto reflect that the arguments are correctly underlined.\n+\t* g++.dg/plugin/diagnostic-test-expressions-1.C: Add test coverage\n+\tfor globals, params, locals and literals.\n+\t(test_sizeof): Directly test the location of \"sizeof\", rather than\n+\twhen used in compound expressions.\n+\t(test_alignof): Likewise for \"alignof\".\n+\t(test_string_literals): Likewise for string literals.\n+\t(test_numeric_literals): Likewise for numeric literals.\n+\t(test_builtin_offsetof): Likewise for \"__builtin_offsetof\".\n+\t(test_typeid): Likewise for typeid.\n+\t(test_unary_plus): New.\n+\t* g++.dg/warn/Wformat-1.C: Add tests of pointer arithmetic on\n+\tformat strings.\n+\n 2018-01-10  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/pr82618.c (dg-options): Add -mno-stv."}, {"sha": "5fcde0b7755465e3fb4c0b3af1e1f9e43c68bd20", "filename": "gcc/testsuite/g++.dg/diagnostic/param-type-mismatch.C", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fparam-type-mismatch.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fparam-type-mismatch.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fparam-type-mismatch.C?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -1,9 +1,6 @@\n // { dg-options \"-fdiagnostics-show-caret\" }\n \n-/* A collection of calls where argument 2 is of the wrong type.\n-\n-   TODO: we should put the caret and underline for the diagnostic\n-   at the second argument, rather than the close paren.  */\n+/* A collection of calls where argument 2 is of the wrong type.  */\n \n /* decl, with argname.  */\n \n@@ -14,7 +11,7 @@ int test_1 (int first, int second, float third)\n   return callee_1 (first, second, third); // { dg-error \"invalid conversion from 'int' to 'const char\\\\*'\" }\n   /* { dg-begin-multiline-output \"\" }\n    return callee_1 (first, second, third);\n-                                        ^\n+                           ^~~~~~\n      { dg-end-multiline-output \"\" } */\n   // { dg-message \"initializing argument 2 of 'int callee_1\\\\(int, const char\\\\*, float\\\\)'\" \"\" { target *-*-* } callee_1 }\n   /* { dg-begin-multiline-output \"\" }\n@@ -32,7 +29,7 @@ int test_2 (int first, int second, float third)\n   return callee_2 (first, second, third); // { dg-error \"invalid conversion from 'int' to 'const char\\\\*'\" }\n   /* { dg-begin-multiline-output \"\" }\n    return callee_2 (first, second, third);\n-                                        ^\n+                           ^~~~~~\n      { dg-end-multiline-output \"\" } */\n   // { dg-message \"initializing argument 2 of 'int callee_2\\\\(int, const char\\\\*, float\\\\)'\" \"\" { target *-*-* } callee_2 }\n   /* { dg-begin-multiline-output \"\" }\n@@ -53,7 +50,7 @@ int test_3 (int first, int second, float third)\n   return callee_3 (first, second, third); // { dg-error \"invalid conversion from 'int' to 'const char\\\\*'\" }\n   /* { dg-begin-multiline-output \"\" }\n    return callee_3 (first, second, third);\n-                                        ^\n+                           ^~~~~~\n      { dg-end-multiline-output \"\" } */\n   // { dg-message \"initializing argument 2 of 'int callee_3\\\\(int, const char\\\\*, float\\\\)'\" \"\" { target *-*-* } callee_3 }\n   /* { dg-begin-multiline-output \"\" }\n@@ -71,7 +68,7 @@ int test_4 (int first, int second, float third)\n   return s4::member_1 (first, second, third); // { dg-error \"invalid conversion from 'int' to 'const char\\\\*'\" }\n   /* { dg-begin-multiline-output \"\" }\n    return s4::member_1 (first, second, third);\n-                                            ^\n+                               ^~~~~~\n      { dg-end-multiline-output \"\" } */\n   /* { dg-begin-multiline-output \"\" }\n  struct s4 { static int member_1 (int one, const char *two, float three); };\n@@ -89,7 +86,7 @@ int test_5 (int first, int second, float third)\n   return inst.member_1 (first, second, third); // { dg-error \"invalid conversion from 'int' to 'const char\\\\*'\" }\n   /* { dg-begin-multiline-output \"\" }\n    return inst.member_1 (first, second, third);\n-                                             ^\n+                                ^~~~~~\n      { dg-end-multiline-output \"\" } */\n   /* { dg-begin-multiline-output \"\" }\n  struct s5 { int member_1 (int one, const char *two, float three); };\n@@ -106,7 +103,7 @@ int test_6 (int first, int second, float third, s6 *ptr)\n   return ptr->member_1 (first, second, third); // { dg-error \"invalid conversion from 'int' to 'const char\\\\*'\" }\n   /* { dg-begin-multiline-output \"\" }\n    return ptr->member_1 (first, second, third);\n-                                             ^\n+                                ^~~~~~\n      { dg-end-multiline-output \"\" } */\n   /* { dg-begin-multiline-output \"\" }\n  struct s6 { int member_1 (int one, const char *two, float three); };\n@@ -128,7 +125,7 @@ int test_7 (int first, int second, float third)\n      { dg-end-multiline-output \"\" } */\n   /* { dg-begin-multiline-output \"\" }\n    return test_7 <const char *> (first, second, third);\n-                                                     ^\n+                                        ^~~~~~\n      { dg-end-multiline-output \"\" } */\n   /* { dg-begin-multiline-output \"\" }\n  int test_7 (int one, T two, float three);\n@@ -146,7 +143,7 @@ int test_8 (int first, int second, float third)\n   return s8 <const char *>::member_1 (first, second, third); // { dg-error \"invalid conversion from 'int' to 'const char\\\\*'\" }\n   /* { dg-begin-multiline-output \"\" }\n    return s8 <const char *>::member_1 (first, second, third);\n-                                                           ^\n+                                              ^~~~~~\n      { dg-end-multiline-output \"\" } */\n   /* { dg-begin-multiline-output \"\" }\n  struct s8 { static int member_1 (int one, T two, float three); };\n@@ -165,7 +162,7 @@ int test_9 (int first, int second, float third)\n   return inst.member_1 (first, second, third); // { dg-error \"invalid conversion from 'int' to 'const char\\\\*'\" }\n   /* { dg-begin-multiline-output \"\" }\n    return inst.member_1 (first, second, third);\n-                                             ^\n+                                ^~~~~~\n      { dg-end-multiline-output \"\" } */\n   /* { dg-begin-multiline-output \"\" }\n  struct s9 { int member_1 (int one, T two, float three); };\n@@ -182,7 +179,7 @@ int test_10 (int first, int second, float third)\n   return callee_10 (first, second, third); // { dg-error \"invalid conversion from 'int' to 'int \\\\(\\\\*\\\\)\\\\(int, int\\\\)'\" }\n   /* { dg-begin-multiline-output \"\" }\n    return callee_10 (first, second, third);\n-                                         ^\n+                            ^~~~~~\n      { dg-end-multiline-output \"\" } */\n   // { dg-message \"initializing argument 2 of 'int callee_10\\\\(int, int \\\\(\\\\*\\\\)\\\\(int, int\\\\), float\\\\)'\" \"\" { target *-*-* } callee_10 }\n   /* { dg-begin-multiline-output \"\" }\n@@ -200,7 +197,7 @@ int test_11 (int first, int second, float third)\n   return callee_11 (first, second, third); // { dg-error \"invalid conversion from 'int' to 'int \\\\(\\\\*\\\\)\\\\(int, int\\\\)'\" }\n   /* { dg-begin-multiline-output \"\" }\n    return callee_11 (first, second, third);\n-                                         ^\n+                            ^~~~~~\n      { dg-end-multiline-output \"\" } */\n   // { dg-message \"initializing argument 2 of 'int callee_11\\\\(int, int \\\\(\\\\*\\\\)\\\\(int, int\\\\), float\\\\)'\" \"\" { target *-*-* } callee_11 }\n   /* { dg-begin-multiline-output \"\" }"}, {"sha": "c08fec4d019dd18957e95b003e862610093002a2", "filename": "gcc/testsuite/g++.dg/plugin/diagnostic-test-expressions-1.C", "status": "modified", "additions": 156, "deletions": 100, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdiagnostic-test-expressions-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdiagnostic-test-expressions-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdiagnostic-test-expressions-1.C?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -19,6 +19,113 @@ extern void __emit_expression_range (int dummy, ...);\n \n int global;\n \n+void test_global (void)\n+{\n+  __emit_expression_range (0, global); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, global);\n+                               ^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_param (int param)\n+{\n+  __emit_expression_range (0, param); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, param);\n+                               ^~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_local (void)\n+{\n+  int local = 5;\n+\n+  __emit_expression_range (0, local); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, local);\n+                               ^~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_integer_constants (void)\n+{\n+  __emit_expression_range (0, 1234); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, 1234);\n+                               ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  /* Ensure that zero works.  */\n+\n+  __emit_expression_range (0, 0); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, 0);\n+                               ^\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_character_constants (void)\n+{\n+  __emit_expression_range (0, 'a'); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, 'a');\n+                               ^~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_floating_constants (void)\n+{\n+  __emit_expression_range (0, 98.6); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, 98.6);\n+                               ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, .6); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, .6);\n+                               ^~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, 98.); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, 98.);\n+                               ^~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, 6.022140857e23 ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, 6.022140857e23 );\n+                               ^~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, 98.6f ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, 98.6f );\n+                               ^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, 6.022140857e23l ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, 6.022140857e23l );\n+                               ^~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+enum test_enum {\n+  TEST_ENUM_VALUE\n+};\n+\n+void test_enumeration_constant (void)\n+{\n+  __emit_expression_range (0, TEST_ENUM_VALUE ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, TEST_ENUM_VALUE );\n+                               ^~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n void test_parentheses (int a, int b)\n {\n   __emit_expression_range (0, (a + b) ); /* { dg-warning \"range\" } */\n@@ -103,67 +210,36 @@ void test_postfix_incdec (int i)\n \n void test_sizeof (int i)\n {\n-  __emit_expression_range (0, sizeof(int) + i); /* { dg-warning \"range\" } */\n+  __emit_expression_range (0, sizeof i ); /* { dg-warning \"range\" } */\n /* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, sizeof(int) + i);\n-                               ~~~~~~~~~~~~^~~\n-   { dg-end-multiline-output \"\" } */\n-\n-  __emit_expression_range (0, i + sizeof(int)); /* { dg-warning \"range\" } */\n-/* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, i + sizeof(int));\n-                               ~~^~~~~~~~~~~~~\n-   { dg-end-multiline-output \"\" } */\n-\n-  __emit_expression_range (0, sizeof i + i); /* { dg-warning \"range\" } */\n-/* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, sizeof i + i);\n-                               ~~~~~~~~~^~~\n+   __emit_expression_range (0, sizeof i );\n+                               ^~~~~~~~\n    { dg-end-multiline-output \"\" } */\n \n-  __emit_expression_range (0, i + sizeof i); /* { dg-warning \"range\" } */\n+  __emit_expression_range (0, sizeof (char) ); /* { dg-warning \"range\" } */\n /* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, i + sizeof i);\n-                               ~~^~~~~~~~~~\n+   __emit_expression_range (0, sizeof (char) );\n+                               ^~~~~~~~~~~~~\n    { dg-end-multiline-output \"\" } */\n }\n \n void test_alignof (int i)\n {\n-  __emit_expression_range (0, alignof(int) + i); /* { dg-warning \"range\" } */\n-/* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, alignof(int) + i);\n-                               ~~~~~~~~~~~~~^~~\n-   { dg-end-multiline-output \"\" } */\n-\n-  __emit_expression_range (0, i + alignof(int)); /* { dg-warning \"range\" } */\n+  __emit_expression_range (0, alignof(int)); /* { dg-warning \"range\" } */\n /* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, i + alignof(int));\n-                               ~~^~~~~~~~~~~~~~\n-   { dg-end-multiline-output \"\" } */\n-\n-  __emit_expression_range (0, __alignof__(int) + i); /* { dg-warning \"range\" } */\n-/* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, __alignof__(int) + i);\n-                               ~~~~~~~~~~~~~~~~~^~~\n-   { dg-end-multiline-output \"\" } */\n-\n-  __emit_expression_range (0, i + __alignof__(int)); /* { dg-warning \"range\" } */\n-/* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, i + __alignof__(int));\n-                               ~~^~~~~~~~~~~~~~~~~~\n+   __emit_expression_range (0, alignof(int));\n+                               ^~~~~~~~~~~~\n    { dg-end-multiline-output \"\" } */\n \n-  __emit_expression_range (0, __alignof__ i + i); /* { dg-warning \"range\" } */\n+  __emit_expression_range (0, __alignof__(int)); /* { dg-warning \"range\" } */\n /* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, __alignof__ i + i);\n-                               ~~~~~~~~~~~~~~^~~\n+   __emit_expression_range (0, __alignof__(int));\n+                               ^~~~~~~~~~~~~~~~\n    { dg-end-multiline-output \"\" } */\n-\n-  __emit_expression_range (0, i + __alignof__ i); /* { dg-warning \"range\" } */\n+  __emit_expression_range (0, __alignof__ i); /* { dg-warning \"range\" } */\n /* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, i + __alignof__ i);\n-                               ~~^~~~~~~~~~~~~~~\n+   __emit_expression_range (0, __alignof__ i);\n+                               ^~~~~~~~~~~~~\n    { dg-end-multiline-output \"\" } */\n }\n \n@@ -200,6 +276,15 @@ void test_indirection (int *ptr)\n    { dg-end-multiline-output \"\" } */\n }\n \n+void test_unary_plus (int i)\n+{\n+  __emit_expression_range (0, +i ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, +i );\n+                               ^~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n void test_unary_minus (int i)\n {\n   __emit_expression_range (0, -i ); /* { dg-warning \"range\" } */\n@@ -471,53 +556,36 @@ void test_comma_operator (int a, int b)\n \n /* Literals.  **************************************************/\n \n-/* We can't test the ranges of literals directly, since the underlying\n-   tree nodes don't retain a location.  However, we can test that they\n-   have ranges during parsing by building compound expressions using\n-   them, and verifying the ranges of the compound expressions.  */\n-\n-void test_string_literals (int i)\n+void test_string_literals ()\n {\n-  __emit_expression_range (0, \"foo\"[i] ); /* { dg-warning \"range\" } */\n+  __emit_expression_range (0, \"0123456789\"); /* { dg-warning \"range\" } */\n /* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, \"foo\"[i] );\n-                               ~~~~~~~^\n+   __emit_expression_range (0, \"0123456789\");\n+                               ^~~~~~~~~~~~\n    { dg-end-multiline-output \"\" } */\n \n-  __emit_expression_range (0, &\"foo\" \"bar\" ); /* { dg-warning \"range\" } */\n+  __emit_expression_range (0, \"foo\" \"bar\" ); /* { dg-warning \"range\" } */\n /* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, &\"foo\" \"bar\" );\n-                               ^~~~~~~~~~~~\n+   __emit_expression_range (0, \"foo\" \"bar\" );\n+                               ^~~~~~~~~~~\n    { dg-end-multiline-output \"\" } */\n }\n \n void test_numeric_literals (int i)\n {\n-  __emit_expression_range (0, 42 + i ); /* { dg-warning \"range\" } */\n+  __emit_expression_range (0, 42 ); /* { dg-warning \"range\" } */\n /* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, 42 + i );\n-                               ~~~^~~\n-   { dg-end-multiline-output \"\" } */\n-\n-  __emit_expression_range (0, i + 42 ); /* { dg-warning \"range\" } */\n-/* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, i + 42 );\n-                               ~~^~~~\n+   __emit_expression_range (0, 42 );\n+                               ^~\n    { dg-end-multiline-output \"\" } */\n \n   /* Verify locations of negative literals (via folding of\n      unary negation).  */\n \n-  __emit_expression_range (0, -42 + i ); /* { dg-warning \"range\" } */\n+  __emit_expression_range (0, -42 ); /* { dg-warning \"range\" } */\n /* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, -42 + i );\n-                               ~~~~^~~\n-   { dg-end-multiline-output \"\" } */\n-\n-  __emit_expression_range (0, i + -42 ); /* { dg-warning \"range\" } */\n-/* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, i + -42 );\n-                               ~~^~~~~\n+   __emit_expression_range (0, -42 );\n+                               ^~~\n    { dg-end-multiline-output \"\" } */\n \n   __emit_expression_range (0, i ? 0 : -1 ); /* { dg-warning \"range\" } */\n@@ -638,16 +706,10 @@ struct s { int i; float f; };\n \n void test_builtin_offsetof (int i)\n {\n-  __emit_expression_range (0,  i + __builtin_offsetof (struct s, f) );  /* { dg-warning \"range\" } */\n+  __emit_expression_range (0,  __builtin_offsetof (struct s, f) );  /* { dg-warning \"range\" } */\n /* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0,  i + __builtin_offsetof (struct s, f) );\n-                                ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-   { dg-end-multiline-output \"\" } */\n-\n-  __emit_expression_range (0,  __builtin_offsetof (struct s, f) + i );  /* { dg-warning \"range\" } */\n-/* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0,  __builtin_offsetof (struct s, f) + i );\n-                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n+   __emit_expression_range (0,  __builtin_offsetof (struct s, f) );\n+                                ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n    { dg-end-multiline-output \"\" } */\n }\n \n@@ -856,28 +918,22 @@ namespace std\n \n void test_typeid (int i)\n {\n-  __emit_expression_range (0, &typeid(i)); /* { dg-warning \"range\" } */\n+  __emit_expression_range (0, typeid(i)); /* { dg-warning \"range\" } */\n /* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, &typeid(i));\n-                               ^~~~~~~~~~\n-   { dg-end-multiline-output \"\" } */\n-\n-  __emit_expression_range (0, &typeid(int)); /* { dg-warning \"range\" } */\n-/* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, &typeid(int));\n-                               ^~~~~~~~~~~~\n+   __emit_expression_range (0, typeid(i));\n+                               ^~~~~~~~~\n    { dg-end-multiline-output \"\" } */\n \n-  __emit_expression_range (0, &typeid(i * 2)); /* { dg-warning \"range\" } */\n+  __emit_expression_range (0, typeid(int)); /* { dg-warning \"range\" } */\n /* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, &typeid(i * 2));\n-                               ^~~~~~~~~~~~~~\n+   __emit_expression_range (0, typeid(int));\n+                               ^~~~~~~~~~~\n    { dg-end-multiline-output \"\" } */\n \n-  __emit_expression_range (0, typeid(int).foo); /* { dg-warning \"range\" } */\n+  __emit_expression_range (0, typeid(i * 2)); /* { dg-warning \"range\" } */\n /* { dg-begin-multiline-output \"\" }\n-   __emit_expression_range (0, typeid(int).foo);\n-                               ~~~~~~~~~~~~^~~\n+   __emit_expression_range (0, typeid(i * 2));\n+                               ^~~~~~~~~~~~~\n    { dg-end-multiline-output \"\" } */\n }\n "}, {"sha": "f2e772aec950a32dec221d9fc5defd8d61275794", "filename": "gcc/testsuite/g++.dg/warn/Wformat-1.C", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWformat-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWformat-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWformat-1.C?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -7,4 +7,6 @@ foo (void)\n {\n   const char *const msg = \"abc\";\n   bar (1, msg);\n+  bar (1, msg + 1);\n+  bar (1, 1 + msg);\n }"}, {"sha": "56acd10a6535884f9b6591338f48a25ad81e9a6d", "filename": "gcc/tree-core.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -1116,6 +1116,9 @@ struct GTY(()) tree_base {\n        SSA_NAME_IS_VIRTUAL_OPERAND in\n \t   SSA_NAME\n \n+       EXPR_LOCATION_WRAPPER_P in\n+\t   NON_LVALUE_EXPR, VIEW_CONVERT_EXPR\n+\n    private_flag:\n \n        TREE_PRIVATE in"}, {"sha": "bed59d33bb2c72ec5882c7367e44389f90e98593", "filename": "gcc/tree.c", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -12167,6 +12167,8 @@ tree_nop_conversion (const_tree exp)\n {\n   tree outer_type, inner_type;\n \n+  if (location_wrapper_p (exp))\n+    return true;\n   if (!CONVERT_EXPR_P (exp)\n       && TREE_CODE (exp) != NON_LVALUE_EXPR)\n     return false;\n@@ -14093,6 +14095,42 @@ set_source_range (tree expr, source_range src_range)\n   return adhoc;\n }\n \n+/* Return EXPR, potentially wrapped with a node expression LOC,\n+   if !CAN_HAVE_LOCATION_P (expr).\n+\n+   NON_LVALUE_EXPR is used for wrapping constants, apart from STRING_CST.\n+   VIEW_CONVERT_EXPR is used for wrapping non-constants and STRING_CST.\n+\n+   Wrapper nodes can be identified using location_wrapper_p.  */\n+\n+tree\n+maybe_wrap_with_location (tree expr, location_t loc)\n+{\n+  if (expr == NULL)\n+    return NULL;\n+  if (loc == UNKNOWN_LOCATION)\n+    return expr;\n+  if (CAN_HAVE_LOCATION_P (expr))\n+    return expr;\n+  /* We should only be adding wrappers for constants and for decls,\n+     or for some exceptional tree nodes (e.g. BASELINK in the C++ FE).  */\n+  gcc_assert (CONSTANT_CLASS_P (expr)\n+\t      || DECL_P (expr)\n+\t      || EXCEPTIONAL_CLASS_P (expr));\n+\n+  /* For now, don't add wrappers to exceptional tree nodes, to minimize\n+     any impact of the wrapper nodes.  */\n+  if (EXCEPTIONAL_CLASS_P (expr))\n+    return expr;\n+\n+  tree_code code = (CONSTANT_CLASS_P (expr) && TREE_CODE (expr) != STRING_CST\n+\t\t    ? NON_LVALUE_EXPR : VIEW_CONVERT_EXPR);\n+  tree wrapper = build1_loc (loc, code, TREE_TYPE (expr), expr);\n+  /* Mark this node as being a wrapper.  */\n+  EXPR_LOCATION_WRAPPER_P (wrapper) = 1;\n+  return wrapper;\n+}\n+\n /* Return the name of combined function FN, for debugging purposes.  */\n \n const char *\n@@ -14464,6 +14502,70 @@ test_vector_cst_patterns ()\n   check_vector_cst_fill (elements, build_vector (vector_type, elements), 4);\n }\n \n+/* Verify that STRIP_NOPS (NODE) is EXPECTED.\n+   Helper function for test_location_wrappers, to deal with STRIP_NOPS\n+   modifying its argument in-place.  */\n+\n+static void\n+check_strip_nops (tree node, tree expected)\n+{\n+  STRIP_NOPS (node);\n+  ASSERT_EQ (expected, node);\n+}\n+\n+/* Verify location wrappers.  */\n+\n+static void\n+test_location_wrappers ()\n+{\n+  location_t loc = BUILTINS_LOCATION;\n+\n+  /* Wrapping a constant.  */\n+  tree int_cst = build_int_cst (integer_type_node, 42);\n+  ASSERT_FALSE (CAN_HAVE_LOCATION_P (int_cst));\n+  ASSERT_FALSE (location_wrapper_p (int_cst));\n+\n+  tree wrapped_int_cst = maybe_wrap_with_location (int_cst, loc);\n+  ASSERT_TRUE (location_wrapper_p (wrapped_int_cst));\n+  ASSERT_EQ (loc, EXPR_LOCATION (wrapped_int_cst));\n+  ASSERT_EQ (int_cst, tree_strip_any_location_wrapper (wrapped_int_cst));\n+\n+  /* Wrapping a STRING_CST.  */\n+  tree string_cst = build_string (4, \"foo\");\n+  ASSERT_FALSE (CAN_HAVE_LOCATION_P (string_cst));\n+  ASSERT_FALSE (location_wrapper_p (string_cst));\n+\n+  tree wrapped_string_cst = maybe_wrap_with_location (string_cst, loc);\n+  ASSERT_TRUE (location_wrapper_p (wrapped_string_cst));\n+  ASSERT_EQ (VIEW_CONVERT_EXPR, TREE_CODE (wrapped_string_cst));\n+  ASSERT_EQ (loc, EXPR_LOCATION (wrapped_string_cst));\n+  ASSERT_EQ (string_cst, tree_strip_any_location_wrapper (wrapped_string_cst));\n+\n+\n+  /* Wrapping a variable.  */\n+  tree int_var = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+\t\t\t     get_identifier (\"some_int_var\"),\n+\t\t\t     integer_type_node);\n+  ASSERT_FALSE (CAN_HAVE_LOCATION_P (int_var));\n+  ASSERT_FALSE (location_wrapper_p (int_var));\n+\n+  tree wrapped_int_var = maybe_wrap_with_location (int_var, loc);\n+  ASSERT_TRUE (location_wrapper_p (wrapped_int_var));\n+  ASSERT_EQ (loc, EXPR_LOCATION (wrapped_int_var));\n+  ASSERT_EQ (int_var, tree_strip_any_location_wrapper (wrapped_int_var));\n+\n+  /* Verify that \"reinterpret_cast<int>(some_int_var)\" is not a location\n+     wrapper.  */\n+  tree r_cast = build1 (NON_LVALUE_EXPR, integer_type_node, int_var);\n+  ASSERT_FALSE (location_wrapper_p (r_cast));\n+  ASSERT_EQ (r_cast, tree_strip_any_location_wrapper (r_cast));\n+\n+  /* Verify that STRIP_NOPS removes wrappers.  */\n+  check_strip_nops (wrapped_int_cst, int_cst);\n+  check_strip_nops (wrapped_string_cst, string_cst);\n+  check_strip_nops (wrapped_int_var, int_var);\n+}\n+\n /* Run all of the selftests within this file.  */\n \n void\n@@ -14473,6 +14575,7 @@ tree_c_tests ()\n   test_identifiers ();\n   test_labels ();\n   test_vector_cst_patterns ();\n+  test_location_wrappers ();\n }\n \n } // namespace selftest"}, {"sha": "f47e2338d2d9ac9dc949d5ce863cba5d065a843d", "filename": "gcc/tree.h", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a004410d9f64d658864a899ab911ae9a31c444c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9a004410d9f64d658864a899ab911ae9a31c444c", "patch": "@@ -483,6 +483,12 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n #define STRIP_USELESS_TYPE_CONVERSION(EXP) \\\n   (EXP) = tree_ssa_strip_useless_type_conversions (EXP)\n \n+/* Remove any VIEW_CONVERT_EXPR or NON_LVALUE_EXPR that's purely\n+   in use to provide a location_t.  */\n+\n+#define STRIP_ANY_LOCATION_WRAPPER(EXP) \\\n+  (EXP) = tree_strip_any_location_wrapper (CONST_CAST_TREE (EXP))\n+\n /* Nonzero if TYPE represents a vector type.  */\n \n #define VECTOR_TYPE_P(TYPE) (TREE_CODE (TYPE) == VECTOR_TYPE)\n@@ -1180,6 +1186,8 @@ get_expr_source_range (tree expr)\n \n extern void protected_set_expr_location (tree, location_t);\n \n+extern tree maybe_wrap_with_location (tree, location_t);\n+\n /* In a TARGET_EXPR node.  */\n #define TARGET_EXPR_SLOT(NODE) TREE_OPERAND_CHECK_CODE (NODE, TARGET_EXPR, 0)\n #define TARGET_EXPR_INITIAL(NODE) TREE_OPERAND_CHECK_CODE (NODE, TARGET_EXPR, 1)\n@@ -3726,6 +3734,45 @@ valid_vector_subparts_p (poly_uint64 subparts)\n   return true;\n }\n \n+/* In NON_LVALUE_EXPR and VIEW_CONVERT_EXPR, set when this node is merely a\n+   wrapper added to express a location_t on behalf of the node's child\n+   (e.g. by maybe_wrap_with_location).  */\n+\n+#define EXPR_LOCATION_WRAPPER_P(NODE) \\\n+  (TREE_CHECK2(NODE, NON_LVALUE_EXPR, VIEW_CONVERT_EXPR)->base.public_flag)\n+\n+/* Test if EXP is merely a wrapper node, added to express a location_t\n+   on behalf of the node's child (e.g. by maybe_wrap_with_location).  */\n+\n+inline bool\n+location_wrapper_p (const_tree exp)\n+{\n+  /* A wrapper node has code NON_LVALUE_EXPR or VIEW_CONVERT_EXPR, and\n+     the flag EXPR_LOCATION_WRAPPER_P is set.\n+     It normally has the same type as its operand, but it can have a\n+     different one if the type of the operand has changed (e.g. when\n+     merging duplicate decls).\n+\n+     NON_LVALUE_EXPR is used for wrapping constants, apart from STRING_CST.\n+     VIEW_CONVERT_EXPR is used for wrapping non-constants and STRING_CST.  */\n+  if ((TREE_CODE (exp) == NON_LVALUE_EXPR\n+       || TREE_CODE (exp) == VIEW_CONVERT_EXPR)\n+      && EXPR_LOCATION_WRAPPER_P (exp))\n+    return true;\n+  return false;\n+}\n+\n+/* Implementation of STRIP_ANY_LOCATION_WRAPPER.  */\n+\n+inline tree\n+tree_strip_any_location_wrapper (tree exp)\n+{\n+  if (location_wrapper_p (exp))\n+    return TREE_OPERAND (exp, 0);\n+  else\n+    return exp;\n+}\n+\n #define error_mark_node\t\t\tglobal_trees[TI_ERROR_MARK]\n \n #define intQI_type_node\t\t\tglobal_trees[TI_INTQI_TYPE]"}]}