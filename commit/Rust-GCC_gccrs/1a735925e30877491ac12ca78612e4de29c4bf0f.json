{"sha": "1a735925e30877491ac12ca78612e4de29c4bf0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE3MzU5MjVlMzA4Nzc0OTFhYzEyY2E3ODYxMmU0ZGUyOWM0YmYwZg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-10-05T14:05:54Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-10-05T14:05:54Z"}, "message": "re PR lto/41552 (Undefined references with -flto, dependent on object file ordering)\n\n2009-10-05  Richard Guenther  <rguenther@suse.de>\n\n\tPR lto/41552\n\tPR lto/41487\n\t* lto-symtab.c (struct lto_symtab_base_def): Remove.\n\t(struct lto_symtab_identifier_def): Likewise.\n\t(struct lto_symtab_decl_def): Likewise.\n\t(struct lto_symtab_entry_def): New.\n\t(lto_symtab_identifier_t): Rename to ...\n\t(lto_symtab_entry_t): ... this.\n\t(lto_symtab_decls): Remove.\n\t(lto_symtab_base_hash): Rename to ...\n\t(lto_symtab_entry_hash): ... this.\n\t(lto_symtab_base_eq): Rename to ...\n\t(lto_symtab_entry_eq): ... this.\n\t(lto_symtab_base_marked_p): Rename to ...\n\t(lto_symtab_entry_marked_p): ... this.\n\t(lto_symtab_identifier_marked_p): Remove.\n\t(lto_symtab_decl_marked_p): Likewise.\n\t(lto_symtab_maybe_init_hash_tables): Rename to ...\n\t(lto_symtab_maybe_init_hash_table): ... this.\n\t(lto_symtab_set_resolution_and_file_data): Remove.\n\t(lto_symtab_register_decl): New function.\n\t(lto_symtab_get_identifier): Remove.\n\t(lto_symtab_get): New function.\n\t(lto_symtab_get_resolution): Adjust.\n\t(lto_symtab_get_identifier_decl): Remove.\n\t(lto_symtab_set_identifier_decl): Likewise.\n\t(lto_symtab_merge_decl): Rename to ...\n\t(lto_symtab_merge): ... this.  Rewrite.\n\t(lto_symtab_merge_var): Remove.\n\t(lto_symtab_merge_fn): Likewise.\n\t(lto_symtab_prevailing_decl): Adjust.\n\t(lto_cgraph_replace_node): New function.\n\t(lto_symtab_merge_decls_2): Likewise.\n\t(lto_symtab_merge_decls_1): Likewise.\n\t(lto_symtab_fixup_var_decls): Likewise.\n\t(lto_symtab_resolve_symbols): Likewise.\n\t(lto_symtab_merge_decls): Likewise.\n\t(lto_symtab_prevailing_decl): Adjust.\n\t(lto_symtab_get_symtab_def): Remove.\n\t(lto_symtab_get_file_data): Likewise.\n\t(lto_symtab_clear_resolution): Adjust.\n\t(lto_symtab_clear_resolution): Likewise.\n\t* lto-cgraph.c (input_edge): Do not merge cgraph nodes here.\n\t(input_cgraph_1): Likewise.\n\t* lto-streamer-in.c (get_resolution): Do not provide fake\n\tsymbol resolutions here.\n\t(deferred_global_decls): Remove.\n\t(lto_register_deferred_decls_in_symtab): Likewise.\n\t(lto_register_var_decl_in_symtab): Change signature, register\n\tvariable via lto_symtab_register_decl.\n\t(lto_register_function_decl_in_symtab): Likewise.\n\t(lto_read_tree): Adjust.\n\t* lto-streamer.h (lto_register_deferred_decls_in_symtab): Remove.\n\t(lto_symtab_merge_var): Likewise.\n\t(lto_symtab_merge_fn): Likewise.\n\t(lto_symtab_register_decl): Declare.\n\t(lto_symtab_merge_decls): Likewise.\n\n\tlto/\n\t* lto.c (lto_read_decls): Do not register deferred decls.\n\t(read_cgraph_and_symbols): Delay symbol and cgraph merging\n\tuntil after reading the IPA summaries.\n\n\t* g++.dg/lto/20091002-1_0.C: Adjust flags.\n\t* g++.dg/lto/20091004-1_0.C: New testcase.\n\t* g++.dg/lto/20091004-1_1.C: Likewise.\n\t* g++.dg/lto/20091004-2_0.C: Likewise.\n\t* g++.dg/lto/20091004-2_1.C: Likewise.\n\t* g++.dg/lto/20091004-3_0.C: Likewise.\n\t* g++.dg/lto/20091004-3_1.C: Likewise.\n\nFrom-SVN: r152450", "tree": {"sha": "666c7b939b006e039aeec82b1397690b52070e18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/666c7b939b006e039aeec82b1397690b52070e18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a735925e30877491ac12ca78612e4de29c4bf0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a735925e30877491ac12ca78612e4de29c4bf0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a735925e30877491ac12ca78612e4de29c4bf0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a735925e30877491ac12ca78612e4de29c4bf0f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e9d85fa6a7fdd48c00c02b8ad915a75d3b025708", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d85fa6a7fdd48c00c02b8ad915a75d3b025708", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9d85fa6a7fdd48c00c02b8ad915a75d3b025708"}], "stats": {"total": 1108, "additions": 638, "deletions": 470}, "files": [{"sha": "5da6b90eb8735306a9df5def1ba467c90daa0d4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a735925e30877491ac12ca78612e4de29c4bf0f", "patch": "@@ -1,3 +1,63 @@\n+2009-10-05  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR lto/41552\n+\tPR lto/41487\n+\t* lto-symtab.c (struct lto_symtab_base_def): Remove.\n+\t(struct lto_symtab_identifier_def): Likewise.\n+\t(struct lto_symtab_decl_def): Likewise.\n+\t(struct lto_symtab_entry_def): New.\n+\t(lto_symtab_identifier_t): Rename to ...\n+\t(lto_symtab_entry_t): ... this.\n+\t(lto_symtab_decls): Remove.\n+\t(lto_symtab_base_hash): Rename to ...\n+\t(lto_symtab_entry_hash): ... this.\n+\t(lto_symtab_base_eq): Rename to ...\n+\t(lto_symtab_entry_eq): ... this.\n+\t(lto_symtab_base_marked_p): Rename to ...\n+\t(lto_symtab_entry_marked_p): ... this.\n+\t(lto_symtab_identifier_marked_p): Remove.\n+\t(lto_symtab_decl_marked_p): Likewise.\n+\t(lto_symtab_maybe_init_hash_tables): Rename to ...\n+\t(lto_symtab_maybe_init_hash_table): ... this.\n+\t(lto_symtab_set_resolution_and_file_data): Remove.\n+\t(lto_symtab_register_decl): New function.\n+\t(lto_symtab_get_identifier): Remove.\n+\t(lto_symtab_get): New function.\n+\t(lto_symtab_get_resolution): Adjust.\n+\t(lto_symtab_get_identifier_decl): Remove.\n+\t(lto_symtab_set_identifier_decl): Likewise.\n+\t(lto_symtab_merge_decl): Rename to ...\n+\t(lto_symtab_merge): ... this.  Rewrite.\n+\t(lto_symtab_merge_var): Remove.\n+\t(lto_symtab_merge_fn): Likewise.\n+\t(lto_symtab_prevailing_decl): Adjust.\n+\t(lto_cgraph_replace_node): New function.\n+\t(lto_symtab_merge_decls_2): Likewise.\n+\t(lto_symtab_merge_decls_1): Likewise.\n+\t(lto_symtab_fixup_var_decls): Likewise.\n+\t(lto_symtab_resolve_symbols): Likewise.\n+\t(lto_symtab_merge_decls): Likewise.\n+\t(lto_symtab_prevailing_decl): Adjust.\n+\t(lto_symtab_get_symtab_def): Remove.\n+\t(lto_symtab_get_file_data): Likewise.\n+\t(lto_symtab_clear_resolution): Adjust.\n+\t(lto_symtab_clear_resolution): Likewise.\n+\t* lto-cgraph.c (input_edge): Do not merge cgraph nodes here.\n+\t(input_cgraph_1): Likewise.\n+\t* lto-streamer-in.c (get_resolution): Do not provide fake\n+\tsymbol resolutions here.\n+\t(deferred_global_decls): Remove.\n+\t(lto_register_deferred_decls_in_symtab): Likewise.\n+\t(lto_register_var_decl_in_symtab): Change signature, register\n+\tvariable via lto_symtab_register_decl.\n+\t(lto_register_function_decl_in_symtab): Likewise.\n+\t(lto_read_tree): Adjust.\n+\t* lto-streamer.h (lto_register_deferred_decls_in_symtab): Remove.\n+\t(lto_symtab_merge_var): Likewise.\n+\t(lto_symtab_merge_fn): Likewise.\n+\t(lto_symtab_register_decl): Declare.\n+\t(lto_symtab_merge_decls): Likewise.\n+\n 2009-10-05  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/23821"}, {"sha": "47ccccd51f46c1d3f63bc25306b2717285e3e392", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 3, "deletions": 46, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=1a735925e30877491ac12ca78612e4de29c4bf0f", "patch": "@@ -527,8 +527,6 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes)\n   unsigned int nest;\n   cgraph_inline_failed_t inline_failed;\n   struct bitpack_d *bp;\n-  tree prevailing_callee;\n-  tree prevailing_caller;\n   enum ld_plugin_symbol_resolution caller_resolution;\n \n   caller = VEC_index (cgraph_node_ptr, nodes, lto_input_sleb128 (ib));\n@@ -539,8 +537,6 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes)\n   if (callee == NULL || callee->decl == NULL_TREE)\n     internal_error (\"bytecode stream: no callee found while reading edge\");\n \n-  caller_resolution = lto_symtab_get_resolution (caller->decl);\n-\n   count = (gcov_type) lto_input_sleb128 (ib);\n \n   bp = lto_input_bitpack (ib);\n@@ -550,37 +546,13 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes)\n   freq = (int) bp_unpack_value (bp, HOST_BITS_PER_INT);\n   nest = (unsigned) bp_unpack_value (bp, 30);\n \n-  /* If the caller was preempted, don't create the edge.  */\n+  /* If the caller was preempted, don't create the edge.\n+     ???  Should we ever have edges from a preempted caller?  */\n+  caller_resolution = lto_symtab_get_resolution (caller->decl);\n   if (caller_resolution == LDPR_PREEMPTED_REG\n       || caller_resolution == LDPR_PREEMPTED_IR)\n     return;\n \n-  prevailing_callee = lto_symtab_prevailing_decl (callee->decl);\n-\n-  /* Make sure the caller is the prevailing decl.  */\n-  prevailing_caller = lto_symtab_prevailing_decl (caller->decl);\n-\n-  if (prevailing_callee != callee->decl)\n-    {\n-      struct lto_file_decl_data *file_data;\n-\n-      /* We cannot replace a clone!  */\n-      gcc_assert (callee == cgraph_node (callee->decl));\n-\n-      callee = cgraph_node (prevailing_callee);\n-      gcc_assert (callee);\n-\n-      /* If LGEN (cc1 or cc1plus) had nothing to do with the node, it\n-\t might not have created it. In this case, we just created a\n-\t new node in the above call to cgraph_node. Mark the file it\n-\t came from. */\n-      file_data = lto_symtab_get_file_data (prevailing_callee);\n-      if (callee->local.lto_file_data)\n-\tgcc_assert (callee->local.lto_file_data == file_data);\n-      else\n-\tcallee->local.lto_file_data = file_data;\n-    }\n-\n   edge = cgraph_create_edge (caller, callee, NULL, count, freq, nest);\n   edge->lto_stmt_uid = stmt_id;\n   edge->inline_failed = inline_failed;\n@@ -630,21 +602,6 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n \tnode->global.inlined_to = NULL;\n     }\n \n-  for (i = 0; VEC_iterate (cgraph_node_ptr, nodes, i, node); i++)\n-    {\n-      tree prevailing = lto_symtab_prevailing_decl (node->decl);\n-\n-      if (prevailing != node->decl)\n-\t{\n-\t  cgraph_remove_node (node);\n-\t  VEC_replace (cgraph_node_ptr, nodes, i, NULL);\n-\t}\n-    }\n-\n-  for (i = 0; VEC_iterate (cgraph_node_ptr, nodes, i, node); i++)\n-    if (node && cgraph_decide_is_function_needed (node, node->decl))\n-      cgraph_mark_needed_node (node);\n-\n   VEC_free (cgraph_node_ptr, heap, nodes);\n }\n "}, {"sha": "175a1e771e7248d19ff6664b3ce9b5f6e4f0598a", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 18, "deletions": 84, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=1a735925e30877491ac12ca78612e4de29c4bf0f", "patch": "@@ -1347,44 +1347,8 @@ get_resolution (struct data_in *data_in, unsigned index)\n       return ret;\n     }\n   else\n-    {\n-      /* Fake symbol resolution if no resolution file was provided.  */\n-      tree t = lto_streamer_cache_get (data_in->reader_cache, index);\n-\n-      gcc_assert (TREE_PUBLIC (t));\n-\n-      /* There should be no DECL_ABSTRACT in the middle end.  */\n-      gcc_assert (!DECL_ABSTRACT (t));\n-\n-      /* If T is a weak definition, we select the first one we see to\n-\t be the prevailing definition.  */\n-      if (DECL_WEAK (t))\n-\t{\n-\t  tree prevailing_decl;\n-\t  if (DECL_EXTERNAL (t))\n-\t    return LDPR_RESOLVED_IR;\n-\n-\t  /* If this is the first time we see T, it won't have a\n-\t     prevailing definition yet.  */\n-\t  prevailing_decl = lto_symtab_prevailing_decl (t);\n-\t  if (prevailing_decl == t\n-\t      || prevailing_decl == NULL_TREE\n-\t      || DECL_EXTERNAL (prevailing_decl))\n-\t    return LDPR_PREVAILING_DEF;\n-\t  else\n-\t    return LDPR_PREEMPTED_IR;\n-\t}\n-      else\n-\t{\n-\t  /* For non-weak definitions, extern declarations are assumed\n-\t     to be resolved elsewhere (LDPR_RESOLVED_IR), otherwise T\n-\t     is a prevailing definition.  */\n-\t  if (DECL_EXTERNAL (t))\n-\t    return LDPR_RESOLVED_IR;\n-\t  else\n-\t    return LDPR_PREVAILING_DEF;\n-\t}\n-    }\n+    /* Delay resolution finding until decl merging.  */\n+    return LDPR_UNKNOWN;\n }\n \n \n@@ -2243,55 +2207,13 @@ lto_input_tree_pointers (struct lto_input_block *ib, struct data_in *data_in,\n     }\n }\n \n-static VEC(tree, heap) *deferred_global_decls;\n-\n-/* Register the queued global decls with the symtab.  DATA_IN contains\n-   tables and descriptors for the file being read.*/\n-\n-void\n-lto_register_deferred_decls_in_symtab (struct data_in *data_in)\n-{\n-  unsigned i;\n-  tree decl;\n-\n-  for (i = 0; VEC_iterate (tree, deferred_global_decls, i, decl); ++i)\n-    {\n-      enum ld_plugin_symbol_resolution resolution;\n-      int ix;\n-\n-      if (!lto_streamer_cache_lookup (data_in->reader_cache, decl, &ix))\n-\tgcc_unreachable ();\n-\n-      /* Register and adjust the decls type.  */\n-      TREE_TYPE (decl) = gimple_register_type (TREE_TYPE (decl));\n-\n-      if (TREE_CODE (decl) == VAR_DECL)\n-\t{\n-\t  gcc_assert (TREE_PUBLIC (decl));\n-\t  resolution = get_resolution (data_in, ix);\n-\t  lto_symtab_merge_var (decl, resolution);\n-\t}\n-      else if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t{\n-\t  gcc_assert (TREE_PUBLIC (decl) && !DECL_ABSTRACT (decl));\n-\t  resolution = get_resolution (data_in, ix);\n-\t  lto_symtab_merge_fn (decl, resolution, data_in->file_data);\n-\t}\n-      else\n-\tgcc_unreachable ();\n-    }\n-\n-  VEC_free (tree, heap, deferred_global_decls);\n-  deferred_global_decls = NULL;\n-}\n-\n \n /* Register DECL with the global symbol table and change its\n    name if necessary to avoid name clashes for static globals across\n    different files.  */\n \n static void\n-lto_register_var_decl_in_symtab (tree decl)\n+lto_register_var_decl_in_symtab (struct data_in *data_in, tree decl)\n {\n   /* Register symbols with file or global scope to mark what input\n      file has their definition.  */\n@@ -2319,7 +2241,13 @@ lto_register_var_decl_in_symtab (tree decl)\n   /* If this variable has already been declared, queue the\n      declaration for merging.  */\n   if (TREE_PUBLIC (decl))\n-    VEC_safe_push (tree, heap, deferred_global_decls, decl);\n+    {\n+      int ix;\n+      if (!lto_streamer_cache_lookup (data_in->reader_cache, decl, &ix))\n+\tgcc_unreachable ();\n+      lto_symtab_register_decl (decl, get_resolution (data_in, ix),\n+\t\t\t\tdata_in->file_data);\n+    }\n }\n \n \n@@ -2380,7 +2308,13 @@ lto_register_function_decl_in_symtab (struct data_in *data_in, tree decl)\n   /* If this variable has already been declared, queue the\n      declaration for merging.  */\n   if (TREE_PUBLIC (decl) && !DECL_ABSTRACT (decl))\n-    VEC_safe_push (tree, heap, deferred_global_decls, decl);\n+    {\n+      int ix;\n+      if (!lto_streamer_cache_lookup (data_in->reader_cache, decl, &ix))\n+\tgcc_unreachable ();\n+      lto_symtab_register_decl (decl, get_resolution (data_in, ix),\n+\t\t\t\tdata_in->file_data);\n+    }\n }\n \n \n@@ -2481,7 +2415,7 @@ lto_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n     gcc_assert (!lto_stream_as_builtin_p (result));\n \n   if (TREE_CODE (result) == VAR_DECL)\n-    lto_register_var_decl_in_symtab (result);\n+    lto_register_var_decl_in_symtab (data_in, result);\n   else if (TREE_CODE (result) == FUNCTION_DECL && !DECL_BUILT_IN (result))\n     lto_register_function_decl_in_symtab (data_in, result);\n "}, {"sha": "c4d66b7a65afeb2bf57d8e910a2175d71f1d7a6d", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=1a735925e30877491ac12ca78612e4de29c4bf0f", "patch": "@@ -823,7 +823,6 @@ extern struct data_in *lto_data_in_create (struct lto_file_decl_data *,\n \t\t\t\t    const char *, unsigned,\n \t\t\t\t    VEC(ld_plugin_symbol_resolution_t,heap) *);\n extern void lto_data_in_delete (struct data_in *);\n-extern void lto_register_deferred_decls_in_symtab (struct data_in *);\n \n \n /* In lto-streamer-out.c  */\n@@ -845,12 +844,11 @@ void input_cgraph (void);\n \n \n /* In lto-symtab.c.  */\n-extern void lto_symtab_merge_var (tree, enum ld_plugin_symbol_resolution);\n-extern void lto_symtab_merge_fn (tree, enum ld_plugin_symbol_resolution,\n-                                 struct lto_file_decl_data *);\n+extern void lto_symtab_register_decl (tree, ld_plugin_symbol_resolution_t,\n+\t\t\t\t      struct lto_file_decl_data *);\n+extern void lto_symtab_merge_decls (void);\n extern tree lto_symtab_prevailing_decl (tree decl);\n extern enum ld_plugin_symbol_resolution lto_symtab_get_resolution (tree decl);\n-struct lto_file_decl_data *lto_symtab_get_file_data (tree decl);\n extern void lto_symtab_clear_resolution (tree decl);\n \n "}, {"sha": "85e3c6c9f938ae226557e5337efea93edf3543c5", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 365, "deletions": 281, "changes": 646, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=1a735925e30877491ac12ca78612e4de29c4bf0f", "patch": "@@ -33,114 +33,80 @@ along with GCC; see the file COPYING3.  If not see\n /* Vector to keep track of external variables we've seen so far.  */\n VEC(tree,gc) *lto_global_var_decls;\n \n-/* Base type for resolution map. It maps NODE to resolution.  */\n+/* Symbol table entry.  */\n \n-struct GTY(()) lto_symtab_base_def\n+struct GTY(()) lto_symtab_entry_def\n {\n-  /* Key is either an IDENTIFIER or a DECL.  */\n-  tree node;\n-};\n-typedef struct lto_symtab_base_def *lto_symtab_base_t;\n-\n-struct GTY(()) lto_symtab_identifier_def\n-{\n-  struct lto_symtab_base_def base;\n+  /* The symbol table entry key, an IDENTIFIER.  */\n+  tree id;\n+  /* The symbol table entry, a DECL.  */\n   tree decl;\n-};\n-typedef struct lto_symtab_identifier_def *lto_symtab_identifier_t;\n-\n-struct GTY(()) lto_symtab_decl_def\n-{\n-  struct lto_symtab_base_def base;\n-  enum ld_plugin_symbol_resolution resolution;\n+  /* LTO file-data and symbol resolution for this decl.  */\n   struct lto_file_decl_data * GTY((skip (\"\"))) file_data;\n+  enum ld_plugin_symbol_resolution resolution;\n+  /* Pointer to the next entry with the same key.  Before decl merging\n+     this links all symbols from the different TUs.  After decl merging\n+     this links merged but incompatible decls, thus all prevailing ones\n+     remaining.  */\n+  struct lto_symtab_entry_def *next;\n };\n-typedef struct lto_symtab_decl_def *lto_symtab_decl_t;\n+typedef struct lto_symtab_entry_def *lto_symtab_entry_t;\n \n /* A poor man's symbol table. This hashes identifier to prevailing DECL\n    if there is one. */\n \n-static GTY ((if_marked (\"lto_symtab_identifier_marked_p\"),\n-\t     param_is (struct lto_symtab_identifier_def)))\n+static GTY ((if_marked (\"lto_symtab_entry_marked_p\"),\n+\t     param_is (struct lto_symtab_entry_def)))\n   htab_t lto_symtab_identifiers;\n \n-static GTY ((if_marked (\"lto_symtab_decl_marked_p\"),\n-\t     param_is (struct lto_symtab_decl_def)))\n-  htab_t lto_symtab_decls;\n-\n-/* Return the hash value of an lto_symtab_base_t object pointed to by P.  */\n+/* Return the hash value of an lto_symtab_entry_t object pointed to by P.  */\n \n static hashval_t\n-lto_symtab_base_hash (const void *p)\n+lto_symtab_entry_hash (const void *p)\n {\n-  const struct lto_symtab_base_def *base =\n-    (const struct lto_symtab_base_def*) p;\n-  return htab_hash_pointer (base->node);\n+  const struct lto_symtab_entry_def *base =\n+    (const struct lto_symtab_entry_def *) p;\n+  return htab_hash_pointer (base->id);\n }\n \n-/* Return non-zero if P1 and P2 points to lto_symtab_base_def structs\n-   corresponding to the same tree node.  */\n+/* Return non-zero if P1 and P2 points to lto_symtab_entry_def structs\n+   corresponding to the same symbol.  */\n \n static int\n-lto_symtab_base_eq (const void *p1, const void *p2)\n+lto_symtab_entry_eq (const void *p1, const void *p2)\n {\n-  const struct lto_symtab_base_def *base1 =\n-     (const struct lto_symtab_base_def *) p1;\n-  const struct lto_symtab_base_def *base2 =\n-     (const struct lto_symtab_base_def *) p2;\n-  return (base1->node == base2->node);\n+  const struct lto_symtab_entry_def *base1 =\n+     (const struct lto_symtab_entry_def *) p1;\n+  const struct lto_symtab_entry_def *base2 =\n+     (const struct lto_symtab_entry_def *) p2;\n+  return (base1->id == base2->id);\n }\n \n-/* Returns non-zero if P points to an lto_symtab_base_def struct that needs\n+/* Returns non-zero if P points to an lto_symtab_entry_def struct that needs\n    to be marked for GC.  */ \n \n static int\n-lto_symtab_base_marked_p (const void *p)\n+lto_symtab_entry_marked_p (const void *p)\n {\n-  const struct lto_symtab_base_def *base =\n-     (const struct lto_symtab_base_def *) p;\n+  const struct lto_symtab_entry_def *base =\n+     (const struct lto_symtab_entry_def *) p;\n \n-  /* Keep this only if the key node is marked.  */\n-  return ggc_marked_p (base->node);\n-}\n-\n-/* Returns non-zero if P points to an lto_symtab_identifier_def struct that\n-   needs to be marked for GC.  */ \n-\n-static int\n-lto_symtab_identifier_marked_p (const void *p)\n-{\n-  return lto_symtab_base_marked_p (p);\n-}\n-\n-/* Returns non-zero if P points to an lto_symtab_decl_def struct that needs\n-   to be marked for GC.  */ \n-\n-static int\n-lto_symtab_decl_marked_p (const void *p)\n-{\n-  return lto_symtab_base_marked_p (p);\n+  /* Keep this only if the decl or the chain is marked.  */\n+  return (ggc_marked_p (base->decl)\n+\t  || (base->next && ggc_marked_p (base->next)));\n }\n \n-#define lto_symtab_identifier_eq\tlto_symtab_base_eq\n-#define lto_symtab_identifier_hash\tlto_symtab_base_hash\n-#define lto_symtab_decl_eq\t\tlto_symtab_base_eq\n-#define lto_symtab_decl_hash\t\tlto_symtab_base_hash\n-\n /* Lazily initialize resolution hash tables.  */\n \n static void\n-lto_symtab_maybe_init_hash_tables (void)\n+lto_symtab_maybe_init_hash_table (void)\n {\n-  if (!lto_symtab_identifiers)\n-    {\n-      lto_symtab_identifiers =\n-\thtab_create_ggc (1021, lto_symtab_identifier_hash,\n-\t\t\t lto_symtab_identifier_eq, NULL);\n-      lto_symtab_decls =\n-\thtab_create_ggc (1021, lto_symtab_decl_hash,\n-\t\t\t lto_symtab_decl_eq, NULL);\n-    }\n+  if (lto_symtab_identifiers)\n+    return;\n+\n+  lto_symtab_identifiers =\n+    htab_create_ggc (1021, lto_symtab_entry_hash,\n+\t\t     lto_symtab_entry_eq, NULL);\n }\n \n /* Returns true iff the union of ATTRIBUTES_1 and ATTRIBUTES_2 can be\n@@ -465,237 +431,366 @@ lto_symtab_compatible (tree old_decl, tree new_decl)\n   return true;\n }\n \n+/* Registers DECL with the LTO symbol table as having resolution RESOLUTION\n+   and read from FILE_DATA. */\n \n-/* Marks decl DECL as having resolution RESOLUTION. */\n-\n-static void\n-lto_symtab_set_resolution_and_file_data (tree decl,\n-\t\t\t\t\t ld_plugin_symbol_resolution_t\n-\t\t\t\t\t resolution,\n-\t\t\t\t\t struct lto_file_decl_data *file_data)\n+void\n+lto_symtab_register_decl (tree decl,\n+\t\t\t  ld_plugin_symbol_resolution_t resolution,\n+\t\t\t  struct lto_file_decl_data *file_data)\n {\n-  lto_symtab_decl_t new_entry;\n+  lto_symtab_entry_t new_entry;\n   void **slot;\n \n-  gcc_assert (decl);\n-\n-  gcc_assert (TREE_PUBLIC (decl));\n-  gcc_assert (TREE_CODE (decl) != FUNCTION_DECL || !DECL_ABSTRACT (decl));\n-\n-  new_entry = GGC_CNEW (struct lto_symtab_decl_def);\n-  new_entry->base.node = decl;\n+  /* Check that declarations reaching this function do not have\n+     properties inconsistent with having external linkage.  If any of\n+     these asertions fail, then the object file reader has failed to\n+     detect these cases and issue appropriate error messages.  */\n+  gcc_assert (decl\n+\t      && TREE_PUBLIC (decl)\n+\t      && (TREE_CODE (decl) == VAR_DECL\n+\t\t  || TREE_CODE (decl) == FUNCTION_DECL)\n+\t      && DECL_ASSEMBLER_NAME_SET_P (decl));\n+  if (TREE_CODE (decl) == VAR_DECL)\n+    gcc_assert (!(DECL_EXTERNAL (decl) && DECL_INITIAL (decl)));\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    gcc_assert (!DECL_ABSTRACT (decl));\n+\n+  new_entry = GGC_CNEW (struct lto_symtab_entry_def);\n+  new_entry->id = DECL_ASSEMBLER_NAME (decl);\n+  new_entry->decl = decl;\n   new_entry->resolution = resolution;\n   new_entry->file_data = file_data;\n   \n-  lto_symtab_maybe_init_hash_tables ();\n-  slot = htab_find_slot (lto_symtab_decls, new_entry, INSERT);\n-  gcc_assert (!*slot);\n+  lto_symtab_maybe_init_hash_table ();\n+  slot = htab_find_slot (lto_symtab_identifiers, new_entry, INSERT);\n+  new_entry->next = (lto_symtab_entry_t) *slot;\n   *slot = new_entry;\n }\n \n-/* Get the lto_symtab_identifier_def struct associated with ID\n-   if there is one.  If there is none and INSERT_P is true, create\n-   a new one.  */\n+/* Get the lto_symtab_entry_def struct associated with ID\n+   if there is one.  */\n \n-static lto_symtab_identifier_t\n-lto_symtab_get_identifier (tree id, bool insert_p)\n+static lto_symtab_entry_t\n+lto_symtab_get (tree id)\n {\n-  struct lto_symtab_identifier_def temp;\n-  lto_symtab_identifier_t symtab_id;\n+  struct lto_symtab_entry_def temp;\n   void **slot;\n \n-  lto_symtab_maybe_init_hash_tables ();\n-  temp.base.node = id;\n-  slot = htab_find_slot (lto_symtab_identifiers, &temp,\n-\t\t\t insert_p ? INSERT : NO_INSERT);\n-  if (insert_p)\n-    {\n-      if (*slot)\n-\treturn (lto_symtab_identifier_t) *slot;\n-      else\n-\t{\n-\t  symtab_id = GGC_CNEW (struct lto_symtab_identifier_def);\n-\t  symtab_id->base.node = id;\n-\t  *slot = symtab_id;\n-\t  return symtab_id;\n-\t}\n-    }\n-  else\n-    return slot ? (lto_symtab_identifier_t) *slot : NULL;\n+  lto_symtab_maybe_init_hash_table ();\n+  temp.id = id;\n+  slot = htab_find_slot (lto_symtab_identifiers, &temp, NO_INSERT);\n+  return slot ? (lto_symtab_entry_t) *slot : NULL;\n }\n \n-/* Return the DECL associated with an IDENTIFIER ID or return NULL_TREE\n-   if there is none.  */\n+/* Get the linker resolution for DECL.  */\n \n-static tree\n-lto_symtab_get_identifier_decl (tree id)\n+enum ld_plugin_symbol_resolution\n+lto_symtab_get_resolution (tree decl)\n {\n-  lto_symtab_identifier_t symtab_id = lto_symtab_get_identifier (id, false);\n-  return symtab_id ? symtab_id->decl : NULL_TREE;\n-}\n+  lto_symtab_entry_t e;\n \n-/* SET the associated DECL of an IDENTIFIER ID to be DECL.  */\n+  gcc_assert (DECL_ASSEMBLER_NAME_SET_P (decl));\n \n-static void\n-lto_symtab_set_identifier_decl (tree id, tree decl)\n-{\n-  lto_symtab_identifier_t symtab_id = lto_symtab_get_identifier (id, true);\n-  symtab_id->decl = decl;\n+  e = lto_symtab_get (DECL_ASSEMBLER_NAME (decl));\n+  while (e && e->decl != decl)\n+    e = e->next;\n+  if (!e)\n+    return LDPR_UNKNOWN;\n+\n+  return e->resolution;\n }\n \n-/* Common helper function for merging variable and function declarations.\n-   NEW_DECL is the newly found decl. RESOLUTION is the decl's resolution\n-   provided by the linker. */\n+/* Replace the cgraph node OLD_NODE with NEW_NODE in the cgraph, merging\n+   all edges and removing the old node.  */\n \n static void\n-lto_symtab_merge_decl (tree new_decl,\n-\t\t       enum ld_plugin_symbol_resolution resolution,\n-\t\t       struct lto_file_decl_data *file_data)\n+lto_cgraph_replace_node (struct cgraph_node *old_node,\n+\t\t\t struct cgraph_node *new_node)\n {\n-  tree old_decl;\n-  tree name;\n-  ld_plugin_symbol_resolution_t old_resolution;\n-\n-  gcc_assert (TREE_CODE (new_decl) == VAR_DECL\n-\t      || TREE_CODE (new_decl) == FUNCTION_DECL);\n-\n-  gcc_assert (TREE_PUBLIC (new_decl));\n-\n-  gcc_assert (DECL_LANG_SPECIFIC (new_decl) == NULL);\n-\n-  /* Check that declarations reaching this function do not have\n-     properties inconsistent with having external linkage.  If any of\n-     these asertions fail, then the object file reader has failed to\n-     detect these cases and issue appropriate error messages.  */\n-  if (TREE_CODE (new_decl) == VAR_DECL)\n-    gcc_assert (!(DECL_EXTERNAL (new_decl) && DECL_INITIAL (new_decl)));\n+  struct cgraph_edge *e, *next;\n+\n+  /* Merge node flags.  */\n+  if (old_node->needed)\n+    cgraph_mark_needed_node (new_node);\n+  if (old_node->reachable)\n+    cgraph_mark_reachable_node (new_node);\n+  if (old_node->address_taken)\n+    cgraph_mark_address_taken_node (new_node);\n+\n+  /* Redirect all incoming edges.  */\n+  for (e = old_node->callers; e; e = next)\n+    {\n+      next = e->next_caller;\n+      cgraph_redirect_edge_callee (e, new_node);\n+    }\n \n-  /* Remember the resolution of this symbol. */\n-  lto_symtab_set_resolution_and_file_data (new_decl, resolution, file_data);\n+  /* There are not supposed to be any outgoing edges from a node we\n+     replace.  Still this can happen for multiple instances of weak\n+     functions.\n+     ???  For now do what the old code did.  Do not create edges for them.  */\n+  for (e = old_node->callees; e; e = next)\n+    {\n+      next = e->next_callee;\n+      cgraph_remove_edge (e);\n+    }\n \n-  /* Ensure DECL_ASSEMBLER_NAME will not set assembler name.  */\n-  gcc_assert (DECL_ASSEMBLER_NAME_SET_P (new_decl));\n+  /* Finally remove the replaced node.  */\n+  cgraph_remove_node (old_node);\n+}\n \n-  /* Retrieve the previous declaration.  */\n-  name = DECL_ASSEMBLER_NAME (new_decl);\n-  old_decl = lto_symtab_get_identifier_decl (name);\n+/* Merge two variable or function symbol table entries ENTRY1 and ENTRY2.\n+   Return the prevailing one or NULL if a merge is not possible.  */\n \n-  /* If there was no previous declaration, then there is nothing to\n-     merge.  */\n-  if (!old_decl)\n-    {\n-      lto_symtab_set_identifier_decl (name, new_decl);\n-      VEC_safe_push (tree, gc, lto_global_var_decls, new_decl);\n-      return;\n-    }\n+static lto_symtab_entry_t\n+lto_symtab_merge (lto_symtab_entry_t entry1, lto_symtab_entry_t entry2)\n+{\n+  tree old_decl = entry1->decl;\n+  tree new_decl = entry2->decl;\n+  ld_plugin_symbol_resolution_t old_resolution = entry1->resolution;\n+  ld_plugin_symbol_resolution_t new_resolution = entry2->resolution;\n+  struct cgraph_node *old_node = NULL;\n+  struct cgraph_node *new_node = NULL;\n \n   /* Give ODR violation errors.  */\n-  old_resolution = lto_symtab_get_resolution (old_decl);\n-  if (resolution == LDPR_PREVAILING_DEF\n-      || resolution == LDPR_PREVAILING_DEF_IRONLY)\n+  if (new_resolution == LDPR_PREVAILING_DEF\n+      || new_resolution == LDPR_PREVAILING_DEF_IRONLY)\n     {\n       if ((old_resolution == LDPR_PREVAILING_DEF\n \t   || old_resolution == LDPR_PREVAILING_DEF_IRONLY)\n-\t  && (old_resolution != resolution || flag_no_common))\n+\t  && (old_resolution != new_resolution || flag_no_common))\n \t{\n \t  error_at (DECL_SOURCE_LOCATION (new_decl),\n \t\t    \"%qD has already been defined\", new_decl);\n \t  inform (DECL_SOURCE_LOCATION (old_decl),\n \t\t  \"previously defined here\");\n-\t  return;\n+\t  return NULL;\n \t}\n     }\n \n-  /* The linker may ask us to combine two incompatible symbols.\n-     Find a decl we can merge with or chain it in the list of decls\n-     for that symbol.  */\n-  while (old_decl\n-\t && !lto_symtab_compatible (old_decl, new_decl))\n-    old_decl = (tree) DECL_LANG_SPECIFIC (old_decl);\n-  if (!old_decl)\n-    {\n-      old_decl = lto_symtab_get_identifier_decl (name);\n-      while (DECL_LANG_SPECIFIC (old_decl) != NULL)\n-\told_decl = (tree) DECL_LANG_SPECIFIC (old_decl);\n-      DECL_LANG_SPECIFIC (old_decl) = (struct lang_decl *) new_decl;\n-      return;\n-    }\n+  /* The linker may ask us to combine two incompatible symbols.  */\n+  if (!lto_symtab_compatible (old_decl, new_decl))\n+    return NULL;\n+\n+  if (TREE_CODE (old_decl) == FUNCTION_DECL)\n+    old_node = cgraph_get_node (old_decl);\n+  if (TREE_CODE (new_decl) == FUNCTION_DECL)\n+    new_node = cgraph_get_node (new_decl);\n \n   /* Merge decl state in both directions, we may still end up using\n      the new decl.  */\n   TREE_ADDRESSABLE (old_decl) |= TREE_ADDRESSABLE (new_decl);\n   TREE_ADDRESSABLE (new_decl) |= TREE_ADDRESSABLE (old_decl);\n \n-  gcc_assert (resolution != LDPR_UNKNOWN\n-\t      && resolution != LDPR_UNDEF\n+  gcc_assert (new_resolution != LDPR_UNKNOWN\n+\t      && new_resolution != LDPR_UNDEF\n \t      && old_resolution != LDPR_UNKNOWN\n \t      && old_resolution != LDPR_UNDEF);\n \n-  if (resolution == LDPR_PREVAILING_DEF\n-      || resolution == LDPR_PREVAILING_DEF_IRONLY)\n+  if (new_resolution == LDPR_PREVAILING_DEF\n+      || new_resolution == LDPR_PREVAILING_DEF_IRONLY\n+      || (!old_node && new_node))\n     {\n-      tree decl;\n-      gcc_assert (old_resolution == LDPR_PREEMPTED_IR\n+      gcc_assert ((!old_node && new_node)\n+\t\t  || old_resolution == LDPR_PREEMPTED_IR\n \t\t  || old_resolution ==  LDPR_RESOLVED_IR\n-\t\t  || (old_resolution == resolution && !flag_no_common));\n-      DECL_LANG_SPECIFIC (new_decl) = DECL_LANG_SPECIFIC (old_decl);\n-      DECL_LANG_SPECIFIC (old_decl) = NULL;\n-      decl = lto_symtab_get_identifier_decl (name);\n-      if (decl == old_decl)\n-\t{\n-\t  lto_symtab_set_identifier_decl (name, new_decl);\n-\t  return;\n-\t}\n-      while ((tree) DECL_LANG_SPECIFIC (decl) != old_decl)\n-\tdecl = (tree) DECL_LANG_SPECIFIC (decl);\n-      DECL_LANG_SPECIFIC (decl) = (struct lang_decl *) new_decl;\n-      return;\n+\t\t  || (old_resolution == new_resolution && !flag_no_common));\n+      if (old_node)\n+\tlto_cgraph_replace_node (old_node, new_node);\n+      /* Choose new_decl, entry2.  */\n+      return entry2;\n     }\n \n-  if (resolution == LDPR_PREEMPTED_REG\n-      || resolution == LDPR_RESOLVED_EXEC\n-      || resolution == LDPR_RESOLVED_DYN)\n+  if (new_resolution == LDPR_PREEMPTED_REG\n+      || new_resolution == LDPR_RESOLVED_EXEC\n+      || new_resolution == LDPR_RESOLVED_DYN)\n     gcc_assert (old_resolution == LDPR_PREEMPTED_REG\n \t\t|| old_resolution == LDPR_RESOLVED_EXEC\n \t\t|| old_resolution == LDPR_RESOLVED_DYN);\n \n-  if (resolution == LDPR_PREEMPTED_IR\n-      || resolution == LDPR_RESOLVED_IR)\n+  if (new_resolution == LDPR_PREEMPTED_IR\n+      || new_resolution == LDPR_RESOLVED_IR)\n     gcc_assert (old_resolution == LDPR_PREVAILING_DEF\n \t\t|| old_resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t|| old_resolution == LDPR_PREEMPTED_IR\n \t\t|| old_resolution == LDPR_RESOLVED_IR);\n \n-  return;\n+  if (new_node)\n+    lto_cgraph_replace_node (new_node, old_node);\n+\n+  /* Choose old_decl, entry1.  */\n+  return entry1;\n }\n \n+/* Resolve the symbol with the candidates in the chain *SLOT and store\n+   their resolutions.  */\n \n-/* Merge the VAR_DECL NEW_VAR with resolution RESOLUTION with any previous\n-   declaration with the same name. */\n+static void\n+lto_symtab_resolve_symbols (void **slot)\n+{\n+  lto_symtab_entry_t e = (lto_symtab_entry_t) *slot;\n \n-void\n-lto_symtab_merge_var (tree new_var, enum ld_plugin_symbol_resolution resolution)\n+  /* If the chain is already resolved there is nothing to do.  */\n+  if (e->resolution != LDPR_UNKNOWN)\n+    return;\n+\n+  /* This is a poor mans resolver.  */\n+  for (; e; e = e->next)\n+    {\n+      gcc_assert (e->resolution == LDPR_UNKNOWN);\n+      if (DECL_EXTERNAL (e->decl)\n+\t  || (TREE_CODE (e->decl) == FUNCTION_DECL\n+\t      && !cgraph_get_node (e->decl)))\n+\te->resolution = LDPR_RESOLVED_IR;\n+      else\n+\t{\n+\t  if (TREE_READONLY (e->decl))\n+\t    e->resolution = LDPR_PREVAILING_DEF_IRONLY;\n+\t  else\n+\t    e->resolution = LDPR_PREVAILING_DEF;\n+\t}\n+    }\n+}\n+\n+/* Merge one symbol table chain to a (set of) prevailing decls.  */\n+\n+static void\n+lto_symtab_merge_decls_2 (void **slot)\n+{\n+  lto_symtab_entry_t e2, e1;\n+\n+  /* Nothing to do for a single entry.  */\n+  e1 = (lto_symtab_entry_t) *slot;\n+  if (!e1->next)\n+    return;\n+\n+  /* Try to merge each entry with each other entry.  In case of a\n+     single prevailing decl this is linear.  */\n+restart:\n+  for (; e1; e1 = e1->next)\n+    for (e2 = e1->next; e2; e2 = e2->next)\n+      {\n+\tlto_symtab_entry_t prevailing = lto_symtab_merge (e1, e2);\n+\tif (prevailing == e1)\n+\t  {\n+\t    lto_symtab_entry_t tmp = prevailing;\n+\t    while (tmp->next != e2)\n+\t      tmp = tmp->next;\n+\t    tmp->next = e2->next;\n+\t    e2->next = NULL;\n+\t    e2 = tmp;\n+\t  }\n+\telse if (prevailing == e2)\n+\t  {\n+\t    lto_symtab_entry_t tmp = (lto_symtab_entry_t) *slot;\n+\t    if (tmp == e1)\n+\t      {\n+\t\t*slot = e1->next;\n+\t\ttmp = e1->next;\n+\t      }\n+\t    else\n+\t      {\n+\t\twhile (tmp->next != e1)\n+\t\t  tmp = tmp->next;\n+\t\ttmp->next = e1->next;\n+\t      }\n+\t    e1->next = NULL;\n+\t    e1 = tmp;\n+\t    goto restart;\n+\t  }\n+      }\n+}\n+\n+/* Fixup the chain of prevailing variable decls *SLOT that are commonized\n+   during link-time.  */\n+\n+static void\n+lto_symtab_fixup_var_decls (void **slot)\n+{\n+  lto_symtab_entry_t e = (lto_symtab_entry_t) *slot;\n+  tree size = bitsize_zero_node;\n+\n+  /* Find the largest prevailing decl and move it to the front of the chain.\n+     This is the decl we will output as representative for the common\n+     section.  */\n+  size = bitsize_zero_node;\n+  if (e->resolution == LDPR_PREVAILING_DEF_IRONLY\n+      || e->resolution == LDPR_PREVAILING_DEF)\n+    size = DECL_SIZE (e->decl);\n+  for (; e->next;)\n+    {\n+      lto_symtab_entry_t next = e->next;\n+      if ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t   || next->resolution == LDPR_PREVAILING_DEF)\n+\t  && tree_int_cst_lt (size, DECL_SIZE (next->decl)))\n+\t{\n+\t  size = DECL_SIZE (next->decl);\n+\t  e->next = next->next;\n+\t  next->next = (lto_symtab_entry_t) *slot;\n+\t  *slot = next;\n+\t}\n+      else\n+\te = next;\n+    }\n+\n+  /* Mark everything apart from the first var as written out.  */\n+  e = (lto_symtab_entry_t) *slot;\n+  for (e = e->next; e; e = e->next)\n+    TREE_ASM_WRITTEN (e->decl) = true;\n+}\n+\n+/* Helper to process the decl chain for the symbol table entry *SLOT.  */\n+\n+static int\n+lto_symtab_merge_decls_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n {\n-  lto_symtab_merge_decl (new_var, resolution, NULL);\n+  lto_symtab_entry_t e;\n+\n+  /* Compute the symbol resolutions.  */\n+  lto_symtab_resolve_symbols (slot);\n+\n+  /* Register and adjust types of the entries.  */\n+  for (e = (lto_symtab_entry_t) *slot; e; e = e->next)\n+    TREE_TYPE (e->decl) = gimple_register_type (TREE_TYPE (e->decl));\n+\n+  /* Merge the chain to a (hopefully) single prevailing decl.  */\n+  lto_symtab_merge_decls_2 (slot);\n+\n+  /* ???  Ideally we should delay all diagnostics until this point to\n+     avoid duplicates.  */\n+\n+  /* All done for FUNCTION_DECLs.  */\n+  e = (lto_symtab_entry_t) *slot;\n+  if (TREE_CODE (e->decl) == FUNCTION_DECL)\n+    return 1;\n+\n+  /* Fixup variables in case there are multiple prevailing ones.  */\n+  if (e->next)\n+    lto_symtab_fixup_var_decls (slot);\n+\n+  /* Insert all variable decls into the global variable decl vector.  */\n+  for (e = (lto_symtab_entry_t) *slot; e; e = e->next)\n+    VEC_safe_push (tree, gc, lto_global_var_decls, e->decl);\n+\n+  return 1;\n }\n \n-/* Merge the FUNCTION_DECL NEW_FN with resolution RESOLUTION with any previous\n-   declaration with the same name. */\n+/* Resolve and merge all symbol table chains to a prevailing decl.  */\n \n void\n-lto_symtab_merge_fn (tree new_fn, enum ld_plugin_symbol_resolution resolution,\n-\t\t     struct lto_file_decl_data *file_data)\n+lto_symtab_merge_decls (void)\n {\n-  lto_symtab_merge_decl (new_fn, resolution, file_data);\n+  lto_symtab_maybe_init_hash_table ();\n+  htab_traverse (lto_symtab_identifiers, lto_symtab_merge_decls_1, NULL);\n }\n \n+\n /* Given the decl DECL, return the prevailing decl with the same name. */\n \n tree\n lto_symtab_prevailing_decl (tree decl)\n {\n-  tree ret;\n-  gcc_assert (decl);\n+  lto_symtab_entry_t ret;\n \n   /* Builtins and local symbols are their own prevailing decl.  */\n   if (!TREE_PUBLIC (decl) || is_builtin_fn (decl))\n@@ -709,74 +804,35 @@ lto_symtab_prevailing_decl (tree decl)\n   gcc_assert (DECL_ASSEMBLER_NAME_SET_P (decl));\n \n   /* Walk through the list of candidates and return the one we merged to.  */\n-  ret = lto_symtab_get_identifier_decl (DECL_ASSEMBLER_NAME (decl));\n-  if (!ret\n-      || DECL_LANG_SPECIFIC (ret) == NULL)\n-    return ret;\n+  ret = lto_symtab_get (DECL_ASSEMBLER_NAME (decl));\n+  if (!ret)\n+    return NULL_TREE;\n+\n+  /* If there is only one candidate return it.  */\n+  if (ret->next == NULL)\n+    return ret->decl;\n \n   /* If there are multiple decls to choose from find the one we merged\n      with and return that.  */\n   while (ret)\n     {\n-      if (gimple_types_compatible_p (TREE_TYPE (decl), TREE_TYPE (ret)))\n-\treturn ret;\n+      if (gimple_types_compatible_p (TREE_TYPE (decl), TREE_TYPE (ret->decl)))\n+\treturn ret->decl;\n \n-      ret = (tree) DECL_LANG_SPECIFIC (ret);\n+      ret = ret->next;\n     }\n \n   gcc_unreachable ();\n }\n \n-/* Return the hash table entry of DECL. */\n-\n-static struct lto_symtab_decl_def *\n-lto_symtab_get_symtab_def (tree decl)\n-{\n-  struct lto_symtab_decl_def temp, *symtab_decl;\n-  void **slot;\n-\n-  gcc_assert (decl);\n-\n-  lto_symtab_maybe_init_hash_tables ();\n-  temp.base.node = decl;\n-  slot = htab_find_slot (lto_symtab_decls, &temp, NO_INSERT);\n-  gcc_assert (slot && *slot);\n-  symtab_decl = (struct lto_symtab_decl_def*) *slot;\n-  return symtab_decl;\n-}\n-\n-/* Return the resolution of DECL. */\n-\n-enum ld_plugin_symbol_resolution\n-lto_symtab_get_resolution (tree decl)\n-{\n-  gcc_assert (decl);\n-\n-  if (!TREE_PUBLIC (decl) || is_builtin_fn (decl))\n-    return LDPR_PREVAILING_DEF_IRONLY;\n-\n-  /* FIXME lto: There should be no DECL_ABSTRACT in the middle end. */\n-  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_ABSTRACT (decl))\n-    return LDPR_PREVAILING_DEF_IRONLY;\n-\n-  return lto_symtab_get_symtab_def (decl)->resolution;\n-}\n-\n-/* Return the file of DECL. */\n-\n-struct lto_file_decl_data *\n-lto_symtab_get_file_data (tree decl)\n-{\n-  return lto_symtab_get_symtab_def (decl)->file_data;\n-}\n-\n /* Remove any storage used to store resolution of DECL.  */\n \n void\n lto_symtab_clear_resolution (tree decl)\n {\n-  struct lto_symtab_decl_def temp;\n-  gcc_assert (decl);\n+  struct lto_symtab_entry_def temp;\n+  lto_symtab_entry_t head;\n+  void **slot;\n \n   if (!TREE_PUBLIC (decl))\n     return;\n@@ -785,9 +841,37 @@ lto_symtab_clear_resolution (tree decl)\n   if (TREE_CODE (decl) == FUNCTION_DECL && DECL_ABSTRACT (decl))\n     return;\n \n-  lto_symtab_maybe_init_hash_tables ();\n-  temp.base.node = decl;\n-  htab_remove_elt (lto_symtab_decls, &temp);\n+  gcc_assert (DECL_ASSEMBLER_NAME_SET_P (decl));\n+\n+  lto_symtab_maybe_init_hash_table ();\n+  temp.id = DECL_ASSEMBLER_NAME (decl);\n+  slot = htab_find_slot (lto_symtab_identifiers, &temp, NO_INSERT);\n+  if (!*slot)\n+    return;\n+\n+  head = (lto_symtab_entry_t) *slot;\n+  if (head->decl == decl)\n+    {\n+      if (head->next)\n+\t{\n+\t  *slot = head->next;\n+\t  head->next = NULL;\n+\t}\n+      else\n+\thtab_remove_elt (lto_symtab_identifiers, &temp);\n+    }\n+  else\n+    {\n+      lto_symtab_entry_t e;\n+      while (head->next && head->next->decl != decl)\n+\thead = head->next;\n+      if (head->next)\n+\t{\n+\t  e = head->next;\n+\t  head->next = e->next;\n+\t  e->next = NULL;\n+\t}\n+    }\n }\n \n #include \"gt-lto-symtab.h\""}, {"sha": "c4ee42ae6a241bd61c0591753f4b2bb655b643a4", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=1a735925e30877491ac12ca78612e4de29c4bf0f", "patch": "@@ -1,3 +1,11 @@\n+2009-10-05  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR lto/41552\n+\tPR lto/41487\n+\t* lto.c (lto_read_decls): Do not register deferred decls.\n+\t(read_cgraph_and_symbols): Delay symbol and cgraph merging\n+\tuntil after reading the IPA summaries.\n+\n 2009-10-02  Rafael Avila de Espindola  <espindola@google.com>\n \n \t* Make-lang.in (lto/lto-lang.o): Don't depend on lto/common.h."}, {"sha": "daefa823db38fb9b6d401b8256b25c8bc36ce5e4", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 12, "deletions": 53, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=1a735925e30877491ac12ca78612e4de29c4bf0f", "patch": "@@ -244,10 +244,6 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n   /* Set the current decl state to be the global state. */\n   decl_data->current_decl_state = decl_data->global_decl_state;\n \n-  /* After each CU is read register and possibly merge global\n-     symbols and their types.  */\n-  lto_register_deferred_decls_in_symtab (data_in);\n-\n   lto_data_in_delete (data_in);\n }\n \n@@ -1763,6 +1759,7 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   unsigned int i, last_file_ix;\n   struct lto_file_decl_data **all_file_decl_data;\n   FILE *resolution;\n+  struct cgraph_node *node;\n \n   lto_stats.num_input_files = nfiles;\n \n@@ -1821,60 +1818,22 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   /* Read the callgraph.  */\n   input_cgraph ();\n \n+  /* Read the IPA summary data.  */\n   ipa_read_summaries ();\n \n-  timevar_push (TV_IPA_LTO_DECL_IO);\n-\n-  lto_fixup_decls (all_file_decl_data);\n+  /* Merge global decls.  */\n+  lto_symtab_merge_decls ();\n \n-  /* See if we have multiple decls for a symbol and choose the largest\n-     one to generate the common.  */\n-  for (i = 0; i < VEC_length (tree, lto_global_var_decls); ++i)\n-    {\n-      tree decl = VEC_index (tree, lto_global_var_decls, i);\n-      tree prev_decl = NULL_TREE;\n-      tree size;\n-\n-      if (TREE_CODE (decl) != VAR_DECL\n-\t  || !DECL_LANG_SPECIFIC (decl))\n-\tcontinue;\n-\n-      /* Find the preceeding decl of the largest one.  */\n-      size = DECL_SIZE (decl);\n-      do\n-\t{\n-\t  tree next = (tree) DECL_LANG_SPECIFIC (decl);\n-\t  if (tree_int_cst_lt (size, DECL_SIZE (next)))\n-\t    {\n-\t      size = DECL_SIZE (next);\n-\t      prev_decl = decl;\n-\t    }\n-\t  decl = next;\n-\t}\n-      while (DECL_LANG_SPECIFIC (decl));\n+  /* Mark cgraph nodes needed in the merged cgraph.\n+     ???  Is this really necessary?  */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (cgraph_decide_is_function_needed (node, node->decl))\n+      cgraph_mark_needed_node (node);\n \n-      /* If necessary move the largest decl to the front of the\n-\t chain.  */\n-      if (prev_decl != NULL_TREE)\n-\t{\n-\t  decl = (tree) DECL_LANG_SPECIFIC (prev_decl);\n-\t  DECL_LANG_SPECIFIC (prev_decl) = DECL_LANG_SPECIFIC (decl);\n-\t  DECL_LANG_SPECIFIC (decl)\n-\t    = (struct lang_decl *) VEC_index (tree, lto_global_var_decls, i);\n-\t  VEC_replace (tree, lto_global_var_decls, i, decl);\n-\t}\n+  timevar_push (TV_IPA_LTO_DECL_IO);\n \n-      /* Mark everything apart from the first var as written out and\n-         unlink the chain.  */\n-      decl = VEC_index (tree, lto_global_var_decls, i);\n-      while (DECL_LANG_SPECIFIC (decl))\n-\t{\n-\t  tree next = (tree) DECL_LANG_SPECIFIC (decl);\n-\t  DECL_LANG_SPECIFIC (decl) = NULL;\n-\t  decl = next;\n-\t  TREE_ASM_WRITTEN (decl) = true;\n-\t}\n-    }\n+  /* Fixup all decls and types.  */\n+  lto_fixup_decls (all_file_decl_data);\n \n   /* FIXME lto. This loop needs to be changed to use the pass manager to\n      call the ipa passes directly.  */"}, {"sha": "67a74284b648e0167976047840718bae6a554799", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1a735925e30877491ac12ca78612e4de29c4bf0f", "patch": "@@ -1,3 +1,15 @@\n+2009-10-05  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR lto/41552\n+\tPR lto/41487\n+\t* g++.dg/lto/20091002-1_0.C: Adjust flags.\n+\t* g++.dg/lto/20091004-1_0.C: New testcase.\n+\t* g++.dg/lto/20091004-1_1.C: Likewise.\n+\t* g++.dg/lto/20091004-2_0.C: Likewise.\n+\t* g++.dg/lto/20091004-2_1.C: Likewise.\n+\t* g++.dg/lto/20091004-3_0.C: Likewise.\n+\t* g++.dg/lto/20091004-3_1.C: Likewise.\n+\n 2009-10-05  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/23821"}, {"sha": "ad1ecf673f50fed1c8d5d5f7956c4e0aeeaef951", "filename": "gcc/testsuite/g++.dg/lto/20091002-1_0.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091002-1_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091002-1_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091002-1_0.C?ref=1a735925e30877491ac12ca78612e4de29c4bf0f", "patch": "@@ -1,5 +1,5 @@\n // { dg-lto-do link }\n-// { dg-lto-options {{-fPIC}} }\n+// { dg-lto-options {{-fPIC -flto}} }\n // { dg-extra-ld-options \"-fPIC -shared\" }\n \n namespace std __attribute__ ((__visibility__ (\"default\")))"}, {"sha": "d65cf29fff1e4a32d97669c1688bcd11131f2c33", "filename": "gcc/testsuite/g++.dg/lto/20091004-1_0.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091004-1_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091004-1_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091004-1_0.C?ref=1a735925e30877491ac12ca78612e4de29c4bf0f", "patch": "@@ -0,0 +1,35 @@\n+// { dg-lto-do link }\n+// { dg-lto-options {{-fPIC -O -flto}} }\n+\n+typedef double Real;\n+class Vector {\n+    int dimen;\n+    Real* val;\n+public:\n+    Vector& operator=(const Vector& vec);\n+    Vector(int p_dimen, Real *p_val)\n+\t: dimen(p_dimen), val(p_val)    { }\n+    int dim() const;\n+};\n+class DVector : public Vector {\n+public:\n+    void reDim(int newdim);\n+    explicit DVector(const Vector& old);\n+    DVector& operator=(const Vector& vec)    {\n+\treDim(vec.dim());\n+\tVector::operator=(vec);\n+    }\n+};\n+Vector& Vector::operator=(const Vector& vec)\n+{\n+  dimen = vec.dimen;\n+  val = vec.val;\n+}\n+int Vector::dim() const { return dimen; }\n+DVector::DVector(const Vector& old) : Vector(0, 0)\n+{\n+  *this = old;\n+}\n+void DVector::reDim(int newdim) {}\n+int main() {}\n+"}, {"sha": "0328abaae277a57f64e187c576f982891b9085b8", "filename": "gcc/testsuite/g++.dg/lto/20091004-1_1.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091004-1_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091004-1_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091004-1_1.C?ref=1a735925e30877491ac12ca78612e4de29c4bf0f", "patch": "@@ -0,0 +1,26 @@\n+typedef double Real;\n+class Vector {\n+    int dimen;\n+    Real* val;\n+public:\n+    Vector& operator=(const Vector& vec);\n+    Vector(int p_dimen, Real *p_val)\n+\t: dimen(p_dimen), val(p_val)    { }\n+    int dim() const;\n+};\n+class DVector : public Vector {\n+public:\n+    void reDim(int newdim);\n+    explicit DVector(const Vector& old);\n+    DVector& operator=(const Vector& vec)    {\n+\treDim(vec.dim());\n+\tVector::operator=(vec);\n+    }\n+};\n+class SLUFactor  {\n+    DVector vec;\n+    void solveRight (Vector& x, const Vector& b);\n+};\n+void SLUFactor::solveRight (Vector& x, const Vector& b) {\n+    vec = b;\n+}"}, {"sha": "321e50bc28d7b4454d5e0547f0aa4aa2fe60950e", "filename": "gcc/testsuite/g++.dg/lto/20091004-2_0.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091004-2_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091004-2_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091004-2_0.C?ref=1a735925e30877491ac12ca78612e4de29c4bf0f", "patch": "@@ -0,0 +1,29 @@\n+// { dg-lto-do link }\n+// { dg-lto-options {{-fPIC -O -flto}} }\n+\n+typedef double Real;\n+class Vector {\n+    int dimen;\n+    Real* val;\n+public:\n+    Vector& operator=(const Vector& vec);\n+    Vector(int p_dimen, Real *p_val)\n+\t: dimen(p_dimen), val(p_val)    { }\n+    int dim() const;\n+};\n+class DVector : public Vector {\n+public:\n+    void reDim(int newdim);\n+    explicit DVector(const Vector& old);\n+    DVector& operator=(const Vector& vec)    {\n+\treDim(vec.dim());\n+\tVector::operator=(vec);\n+    }\n+};\n+class SLUFactor  {\n+    DVector vec;\n+    void solveRight (Vector& x, const Vector& b);\n+};\n+void SLUFactor::solveRight (Vector& x, const Vector& b) {\n+    vec = b;\n+}"}, {"sha": "9bbcd51f754dd6f522bfe9d726623ca8812458d7", "filename": "gcc/testsuite/g++.dg/lto/20091004-2_1.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091004-2_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091004-2_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091004-2_1.C?ref=1a735925e30877491ac12ca78612e4de29c4bf0f", "patch": "@@ -0,0 +1,32 @@\n+typedef double Real;\n+class Vector {\n+    int dimen;\n+    Real* val;\n+public:\n+    Vector& operator=(const Vector& vec);\n+    Vector(int p_dimen, Real *p_val)\n+\t: dimen(p_dimen), val(p_val)    { }\n+    int dim() const;\n+};\n+class DVector : public Vector {\n+public:\n+    void reDim(int newdim);\n+    explicit DVector(const Vector& old);\n+    DVector& operator=(const Vector& vec)    {\n+\treDim(vec.dim());\n+\tVector::operator=(vec);\n+    }\n+};\n+Vector& Vector::operator=(const Vector& vec)\n+{\n+  dimen = vec.dimen;\n+  val = vec.val;\n+}\n+int Vector::dim() const { return dimen; }\n+DVector::DVector(const Vector& old) : Vector(0, 0)\n+{\n+  *this = old;\n+}\n+void DVector::reDim(int newdim) {}\n+int main() {}\n+"}, {"sha": "124eea5e4ebd820aee65285eaa1240f948cfbeec", "filename": "gcc/testsuite/g++.dg/lto/20091004-3_0.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091004-3_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091004-3_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091004-3_0.C?ref=1a735925e30877491ac12ca78612e4de29c4bf0f", "patch": "@@ -0,0 +1,18 @@\n+// { dg-lto-do assemble }\n+// { dg-lto-options {{-O -flto}} }\n+\n+extern \"C\" double sqrt (double __x) throw ();\n+typedef double VECTOR[3];\n+enum { X = 0,  Y = 1,  Z = 2,  T = 3 };\n+inline void VLength(double& a, const VECTOR b)\n+{\n+  a = sqrt(b[X] * b[X] + b[Y] * b[Y] + b[Z] * b[Z]);\n+}\n+void\n+determine_subpatch_flatness(void)\n+{\n+  double temp1;\n+  VECTOR TempV;\n+  VLength(temp1, TempV);\n+  VLength(temp1, TempV);\n+}"}, {"sha": "641c7495b4fcad8a578cf928dcfe013fd62f36fe", "filename": "gcc/testsuite/g++.dg/lto/20091004-3_1.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091004-3_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a735925e30877491ac12ca78612e4de29c4bf0f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091004-3_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20091004-3_1.C?ref=1a735925e30877491ac12ca78612e4de29c4bf0f", "patch": "@@ -0,0 +1,16 @@\n+extern \"C\" double sqrt (double __x) throw ();\n+typedef double VECTOR[3];\n+enum { X = 0,  Y = 1,  Z = 2,  T = 3 };\n+inline void VLength(double& a, const VECTOR b)\n+{\n+  a = sqrt(b[X] * b[X] + b[Y] * b[Y] + b[Z] * b[Z]);\n+}\n+int\n+All_Torus_Intersections(void)\n+{\n+  double len;\n+  VECTOR D;\n+  VLength(len, D);\n+  VLength(len, D);\n+}\n+"}]}