{"sha": "c8a27c401821b4d29c28add396177637f9f381d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzhhMjdjNDAxODIxYjRkMjljMjhhZGQzOTYxNzc2MzdmOWYzODFkNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-09-09T06:43:47Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-09-09T06:43:47Z"}, "message": "rtl.def (DEBUG_IMPLICIT_PTR): New rtl code.\n\n\t* rtl.def (DEBUG_IMPLICIT_PTR): New rtl code.\n\t* rtl.h (DEBUG_IMPLICIT_PTR_DECL): Define.\n\t* rtl.c (rtx_equal_p_cb, rtx_equal_p): Handle DEBUG_IMPLICIT_PTR.\n\t* print-rtl.c (print_rtx): Likewise.\n\t* cselib.c (rtx_equal_for_cselib_p, cselib_hash_rtx): Likewise.\n\t* cfgexpand.c (expand_debug_expr): Generate DEBUG_IMPLICIT_PTR\n\tfor ADDR_EXPR with non-addressable object.\n\t* dwarf2out.c (enum dw_val_class): Add dw_val_class_decl_ref.\n\t(struct dw_val_struct): Add v.val_decl_ref.\n\t(dwarf_stack_op_name, output_loc_operands, output_loc_operands_raw):\n\tHandle DW_OP_GNU_implicit_pointer.\n\t(size_of_loc_descr): Likewise.  Fix up DW_OP_call_ref size.\n\t(get_ref_die_offset_label): New function.\n\t(implicit_ptr_descriptor): New function.\n\t(mem_loc_descriptor): Handle DEBUG_IMPLICIT_PTR.\n\t(loc_descriptor): Likewise.\n\t(gen_variable_die): Put even definitions into decl_die_table.\n\t(resolve_addr_in_expr): Resolve still unresolved\n\tDW_OP_GNU_implicit_pointer operands, if it can't be resolved\n\treturn false.\n\t(dwarf2out_finish): Call output_location_lists after outputting\n\t.debug_info and .debug_abbrev instead of before.\n\n\t* dwarf2.h (DW_OP_GNU_implicit_pointer): New.\n\n2010-09-09  Roland McGrath  <roland@redhat.com>\n\n\t* dwarf2out.c (DWARF_REF_SIZE): Define.\n\t(size_of_loc_descr): Use it for DW_OP_call_ref.\n\nFrom-SVN: r164050", "tree": {"sha": "95afa643e40b04b8d3422e12829ab8707b957836", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95afa643e40b04b8d3422e12829ab8707b957836"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8a27c401821b4d29c28add396177637f9f381d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8a27c401821b4d29c28add396177637f9f381d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8a27c401821b4d29c28add396177637f9f381d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8a27c401821b4d29c28add396177637f9f381d5/comments", "author": null, "committer": null, "parents": [{"sha": "eed023ccd5bb3b3bc9690b79d18c645637527e43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eed023ccd5bb3b3bc9690b79d18c645637527e43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eed023ccd5bb3b3bc9690b79d18c645637527e43"}], "stats": {"total": 206, "additions": 191, "deletions": 15}, "files": [{"sha": "b815a39d993fec43221080eb81edcfca09bf8beb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a27c401821b4d29c28add396177637f9f381d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a27c401821b4d29c28add396177637f9f381d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c8a27c401821b4d29c28add396177637f9f381d5", "patch": "@@ -1,3 +1,33 @@\n+2010-09-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* rtl.def (DEBUG_IMPLICIT_PTR): New rtl code.\n+\t* rtl.h (DEBUG_IMPLICIT_PTR_DECL): Define.\n+\t* rtl.c (rtx_equal_p_cb, rtx_equal_p): Handle DEBUG_IMPLICIT_PTR.\n+\t* print-rtl.c (print_rtx): Likewise.\n+\t* cselib.c (rtx_equal_for_cselib_p, cselib_hash_rtx): Likewise.\n+\t* cfgexpand.c (expand_debug_expr): Generate DEBUG_IMPLICIT_PTR\n+\tfor ADDR_EXPR with non-addressable object.\n+\t* dwarf2out.c (enum dw_val_class): Add dw_val_class_decl_ref.\n+\t(struct dw_val_struct): Add v.val_decl_ref.\n+\t(dwarf_stack_op_name, output_loc_operands, output_loc_operands_raw):\n+\tHandle DW_OP_GNU_implicit_pointer.\n+\t(size_of_loc_descr): Likewise.  Fix up DW_OP_call_ref size.\n+\t(get_ref_die_offset_label): New function.\n+\t(implicit_ptr_descriptor): New function.\n+\t(mem_loc_descriptor): Handle DEBUG_IMPLICIT_PTR.\n+\t(loc_descriptor): Likewise.\n+\t(gen_variable_die): Put even definitions into decl_die_table.\n+\t(resolve_addr_in_expr): Resolve still unresolved\n+\tDW_OP_GNU_implicit_pointer operands, if it can't be resolved\n+\treturn false.\n+\t(dwarf2out_finish): Call output_location_lists after outputting\n+\t.debug_info and .debug_abbrev instead of before.\n+\n+2010-09-09  Roland McGrath  <roland@redhat.com>\n+\n+\t* dwarf2out.c (DWARF_REF_SIZE): Define.\n+\t(size_of_loc_descr): Use it for DW_OP_call_ref.\n+\n 2010-09-09  Alan Modra  <amodra@gmail.com>\n \n \t* doc/invoke.text: Reinstate mcmodel=medium."}, {"sha": "42372769049a6113535882d8832de878a3d16eed", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a27c401821b4d29c28add396177637f9f381d5/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a27c401821b4d29c28add396177637f9f381d5/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=c8a27c401821b4d29c28add396177637f9f381d5", "patch": "@@ -2911,7 +2911,32 @@ expand_debug_expr (tree exp)\n     case ADDR_EXPR:\n       op0 = expand_debug_expr (TREE_OPERAND (exp, 0));\n       if (!op0 || !MEM_P (op0))\n-\treturn NULL;\n+\t{\n+\t  if ((TREE_CODE (TREE_OPERAND (exp, 0)) == VAR_DECL\n+\t       || TREE_CODE (TREE_OPERAND (exp, 0)) == PARM_DECL\n+\t       || TREE_CODE (TREE_OPERAND (exp, 0)) == RESULT_DECL)\n+\t      && !TREE_ADDRESSABLE (TREE_OPERAND (exp, 0)))\n+\t    return gen_rtx_DEBUG_IMPLICIT_PTR (mode, TREE_OPERAND (exp, 0));\n+\n+\t  if (handled_component_p (TREE_OPERAND (exp, 0)))\n+\t    {\n+\t      HOST_WIDE_INT bitoffset, bitsize, maxsize;\n+\t      tree decl\n+\t\t= get_ref_base_and_extent (TREE_OPERAND (exp, 0),\n+\t\t\t\t\t   &bitoffset, &bitsize, &maxsize);\n+\t      if ((TREE_CODE (decl) == VAR_DECL\n+\t\t   || TREE_CODE (decl) == PARM_DECL\n+\t\t   || TREE_CODE (decl) == RESULT_DECL)\n+\t\t  && !TREE_ADDRESSABLE (decl)\n+\t\t  && (bitoffset % BITS_PER_UNIT) == 0\n+\t\t  && bitsize > 0\n+\t\t  && bitsize == maxsize)\n+\t\treturn plus_constant (gen_rtx_DEBUG_IMPLICIT_PTR (mode, decl),\n+\t\t\t\t      bitoffset / BITS_PER_UNIT);\n+\t    }\n+\n+\t  return NULL;\n+\t}\n \n       op0 = convert_debug_memory_address (mode, XEXP (op0, 0));\n "}, {"sha": "05029fa286ce04984ba10c11f667967278529d12", "filename": "gcc/cselib.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a27c401821b4d29c28add396177637f9f381d5/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a27c401821b4d29c28add396177637f9f381d5/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=c8a27c401821b4d29c28add396177637f9f381d5", "patch": "@@ -700,6 +700,10 @@ rtx_equal_for_cselib_p (rtx x, rtx y)\n     case DEBUG_EXPR:\n       return 0;\n \n+    case DEBUG_IMPLICIT_PTR:\n+      return DEBUG_IMPLICIT_PTR_DECL (x)\n+\t     == DEBUG_IMPLICIT_PTR_DECL (y);\n+\n     case LABEL_REF:\n       return XEXP (x, 0) == XEXP (y, 0);\n \n@@ -834,6 +838,11 @@ cselib_hash_rtx (rtx x, int create)\n \t      + DEBUG_TEMP_UID (DEBUG_EXPR_TREE_DECL (x));\n       return hash ? hash : (unsigned int) DEBUG_EXPR;\n \n+    case DEBUG_IMPLICIT_PTR:\n+      hash += ((unsigned) DEBUG_IMPLICIT_PTR << 7)\n+\t      + DECL_UID (DEBUG_IMPLICIT_PTR_DECL (x));\n+      return hash ? hash : (unsigned int) DEBUG_IMPLICIT_PTR;\n+\n     case CONST_INT:\n       hash += ((unsigned) CONST_INT << 7) + INTVAL (x);\n       return hash ? hash : (unsigned int) CONST_INT;"}, {"sha": "11707fbbe5b863811757bb9afa8c2610dd06e8dc", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 102, "deletions": 13, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a27c401821b4d29c28add396177637f9f381d5/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a27c401821b4d29c28add396177637f9f381d5/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=c8a27c401821b4d29c28add396177637f9f381d5", "patch": "@@ -4294,6 +4294,7 @@ enum dw_val_class\n   dw_val_class_macptr,\n   dw_val_class_file,\n   dw_val_class_data8,\n+  dw_val_class_decl_ref,\n   dw_val_class_vms_delta\n };\n \n@@ -4332,6 +4333,7 @@ typedef struct GTY(()) dw_val_struct {\n       unsigned char GTY ((tag (\"dw_val_class_flag\"))) val_flag;\n       struct dwarf_file_data * GTY ((tag (\"dw_val_class_file\"))) val_file;\n       unsigned char GTY ((tag (\"dw_val_class_data8\"))) val_data8[8];\n+      tree GTY ((tag (\"dw_val_class_decl_ref\"))) val_decl_ref;\n       struct dw_val_vms_delta_union\n \t{\n \t  char * lbl1;\n@@ -4695,6 +4697,8 @@ dwarf_stack_op_name (unsigned int op)\n       return \"DW_OP_GNU_uninit\";\n     case DW_OP_GNU_encoded_addr:\n       return \"DW_OP_GNU_encoded_addr\";\n+    case DW_OP_GNU_implicit_pointer:\n+      return \"DW_OP_GNU_implicit_pointer\";\n \n     default:\n       return \"OP_<unknown>\";\n@@ -4798,6 +4802,9 @@ loc_list_plus_const (dw_loc_list_ref list_head, HOST_WIDE_INT offset)\n     loc_descr_plus_const (&d->expr, offset);\n }\n \n+#define DWARF_REF_SIZE\t\\\n+  (dwarf_version == 2 ? DWARF2_ADDR_SIZE : DWARF_OFFSET_SIZE)\n+\n /* Return the size of a location descriptor.  */\n \n static unsigned long\n@@ -4904,12 +4911,15 @@ size_of_loc_descr (dw_loc_descr_ref loc)\n       size += 4;\n       break;\n     case DW_OP_call_ref:\n-      size += DWARF2_ADDR_SIZE;\n+      size += DWARF_REF_SIZE;\n       break;\n     case DW_OP_implicit_value:\n       size += size_of_uleb128 (loc->dw_loc_oprnd1.v.val_unsigned)\n \t      + loc->dw_loc_oprnd1.v.val_unsigned;\n       break;\n+    case DW_OP_GNU_implicit_pointer:\n+      size += DWARF_REF_SIZE + size_of_sleb128 (loc->dw_loc_oprnd2.v.val_int);\n+      break;\n     default:\n       break;\n     }\n@@ -4946,6 +4956,7 @@ size_of_locs (dw_loc_descr_ref loc)\n }\n \n static HOST_WIDE_INT extract_int (const unsigned char *, unsigned);\n+static void get_ref_die_offset_label (char *, dw_die_ref);\n \n /* Output location description stack opcode's operands (if any).  */\n \n@@ -5165,6 +5176,17 @@ output_loc_operands (dw_loc_descr_ref loc)\n \t}\n       break;\n \n+    case DW_OP_GNU_implicit_pointer:\n+      {\n+\tchar label[MAX_ARTIFICIAL_LABEL_BYTES\n+\t\t   + HOST_BITS_PER_WIDE_INT / 2 + 2];\n+\tgcc_assert (val1->val_class == dw_val_class_die_ref);\n+\tget_ref_die_offset_label (label, val1->v.val_die_ref.die);\n+\tdw2_asm_output_offset (DWARF_REF_SIZE, label, debug_info_section, NULL);\n+\tdw2_asm_output_data_sleb128 (val2->v.val_int, NULL);\n+      }\n+      break;\n+\n     default:\n       /* Other codes have no operands.  */\n       break;\n@@ -5303,6 +5325,10 @@ output_loc_operands_raw (dw_loc_descr_ref loc)\n       dw2_asm_output_data_sleb128_raw (val2->v.val_int);\n       break;\n \n+    case DW_OP_GNU_implicit_pointer:\n+      gcc_unreachable ();\n+      break;\n+\n     default:\n       /* Other codes have no operands.  */\n       break;\n@@ -6514,6 +6540,15 @@ is_tagged_type (const_tree type)\n \t  || code == QUAL_UNION_TYPE || code == ENUMERAL_TYPE);\n }\n \n+/* Set label to debug_info_section_label + die_offset of a DIE reference.  */\n+\n+static void\n+get_ref_die_offset_label (char *label, dw_die_ref ref)\n+{\n+  sprintf (label, \"%s+\" HOST_WIDE_INT_PRINT_DEC,\n+\t   debug_info_section_label, ref->die_offset);\n+}\n+\n /* Convert a DIE tag into its string name.  */\n \n static const char *\n@@ -13651,6 +13686,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n     case CONCAT:\n     case CONCATN:\n     case VAR_LOCATION:\n+    case DEBUG_IMPLICIT_PTR:\n       expansion_failed (NULL_TREE, rtl,\n \t\t\t\"CONCAT/CONCATN/VAR_LOCATION is handled only by loc_descriptor\");\n       return 0;\n@@ -14240,6 +14276,35 @@ concatn_loc_descriptor (rtx concatn, enum var_init_status initialized)\n   return cc_loc_result;\n }\n \n+/* Helper function for loc_descriptor.  Return DW_OP_GNU_implicit_pointer\n+   for DEBUG_IMPLICIT_PTR RTL.  */\n+\n+static dw_loc_descr_ref\n+implicit_ptr_descriptor (rtx rtl, HOST_WIDE_INT offset)\n+{\n+  dw_loc_descr_ref ret;\n+  dw_die_ref ref;\n+\n+  gcc_assert (TREE_CODE (DEBUG_IMPLICIT_PTR_DECL (rtl)) == VAR_DECL\n+\t      || TREE_CODE (DEBUG_IMPLICIT_PTR_DECL (rtl)) == PARM_DECL\n+\t      || TREE_CODE (DEBUG_IMPLICIT_PTR_DECL (rtl)) == RESULT_DECL);\n+  ref = lookup_decl_die (DEBUG_IMPLICIT_PTR_DECL (rtl));\n+  ret = new_loc_descr (DW_OP_GNU_implicit_pointer, 0, offset);\n+  ret->dw_loc_oprnd2.val_class = dw_val_class_const;\n+  if (ref)\n+    {\n+      ret->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+      ret->dw_loc_oprnd1.v.val_die_ref.die = ref;\n+      ret->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+    }\n+  else\n+    {\n+      ret->dw_loc_oprnd1.val_class = dw_val_class_decl_ref;\n+      ret->dw_loc_oprnd1.v.val_decl_ref = DEBUG_IMPLICIT_PTR_DECL (rtl);\n+    }\n+  return ret;\n+}\n+\n /* Output a proper Dwarf location descriptor for a variable or parameter\n    which is either allocated in a register or in a memory location.  For a\n    register, we just generate an OP_REG and the register number.  For a\n@@ -14457,6 +14522,19 @@ loc_descriptor (rtx rtl, enum machine_mode mode,\n \t}\n       break;\n \n+    case DEBUG_IMPLICIT_PTR:\n+      loc_result = implicit_ptr_descriptor (rtl, 0);\n+      break;\n+\n+    case PLUS:\n+      if (GET_CODE (XEXP (rtl, 0)) == DEBUG_IMPLICIT_PTR\n+\t  && CONST_INT_P (XEXP (rtl, 1)))\n+\t{\n+\t  loc_result\n+\t    = implicit_ptr_descriptor (XEXP (rtl, 0), INTVAL (XEXP (rtl, 1)));\n+\t  break;\n+\t}\n+      /* FALLTHRU */\n     default:\n       if (GET_MODE_CLASS (mode) == MODE_INT && GET_MODE (rtl) == mode\n \t  && GET_MODE_SIZE (GET_MODE (rtl)) <= DWARF2_ADDR_SIZE\n@@ -19190,7 +19268,7 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n   if (declaration)\n     add_AT_flag (var_die, DW_AT_declaration, 1);\n \n-  if (decl && (DECL_ABSTRACT (decl) || declaration))\n+  if (decl && (DECL_ABSTRACT (decl) || declaration || old_die == NULL))\n     equate_decl_number_to_die (decl, var_die);\n \n   if (! declaration\n@@ -22150,6 +22228,17 @@ resolve_addr_in_expr (dw_loc_descr_ref loc)\n \t    && loc->dw_loc_oprnd2.val_class == dw_val_class_addr\n \t    && resolve_one_addr (&loc->dw_loc_oprnd2.v.val_addr, NULL)))\n       return false;\n+    else if (loc->dw_loc_opc == DW_OP_GNU_implicit_pointer\n+\t     && loc->dw_loc_oprnd1.val_class == dw_val_class_decl_ref)\n+      {\n+\tdw_die_ref ref\n+\t  = lookup_decl_die (loc->dw_loc_oprnd1.v.val_decl_ref);\n+\tif (ref == NULL)\n+\t  return false;\n+\tloc->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\tloc->dw_loc_oprnd1.v.val_die_ref.die = ref;\n+\tloc->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+      }\n   return true;\n }\n \n@@ -22429,17 +22518,6 @@ dwarf2out_finish (const char *filename)\n \tadd_ranges (NULL);\n     }\n \n-  /* Output location list section if necessary.  */\n-  if (have_location_lists)\n-    {\n-      /* Output the location lists info.  */\n-      switch_to_section (debug_loc_section);\n-      ASM_GENERATE_INTERNAL_LABEL (loc_section_label,\n-\t\t\t\t   DEBUG_LOC_SECTION_LABEL, 0);\n-      ASM_OUTPUT_LABEL (asm_out_file, loc_section_label);\n-      output_location_lists (die);\n-    }\n-\n   if (debug_info_level >= DINFO_LEVEL_NORMAL)\n     add_AT_lineptr (comp_unit_die, DW_AT_stmt_list,\n \t\t    debug_line_section_label);\n@@ -22481,6 +22559,17 @@ dwarf2out_finish (const char *filename)\n   switch_to_section (debug_abbrev_section);\n   output_abbrev_section ();\n \n+  /* Output location list section if necessary.  */\n+  if (have_location_lists)\n+    {\n+      /* Output the location lists info.  */\n+      switch_to_section (debug_loc_section);\n+      ASM_GENERATE_INTERNAL_LABEL (loc_section_label,\n+\t\t\t\t   DEBUG_LOC_SECTION_LABEL, 0);\n+      ASM_OUTPUT_LABEL (asm_out_file, loc_section_label);\n+      output_location_lists (die);\n+    }\n+\n   /* Output public names table if necessary.  */\n   if (!VEC_empty (pubname_entry, pubname_table))\n     {"}, {"sha": "04d79594b73c24f6dc9b35112d075e08bf354988", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a27c401821b4d29c28add396177637f9f381d5/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a27c401821b4d29c28add396177637f9f381d5/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=c8a27c401821b4d29c28add396177637f9f381d5", "patch": "@@ -533,7 +533,10 @@ print_rtx (const_rtx in_rtx)\n \n       case 't':\n #ifndef GENERATOR_FILE\n-\tdump_addr (outfile, \" \", XTREE (in_rtx, i));\n+\tif (i == 0 && GET_CODE (in_rtx) == DEBUG_IMPLICIT_PTR)\n+\t  print_mem_expr (outfile, DEBUG_IMPLICIT_PTR_DECL (in_rtx));\n+\telse\n+\t  dump_addr (outfile, \" \", XTREE (in_rtx, i));\n #endif\n \tbreak;\n "}, {"sha": "3a6affc594f5fd8e848fd2cd504e57a4b56e91c7", "filename": "gcc/rtl.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a27c401821b4d29c28add396177637f9f381d5/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a27c401821b4d29c28add396177637f9f381d5/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=c8a27c401821b4d29c28add396177637f9f381d5", "patch": "@@ -407,6 +407,10 @@ rtx_equal_p_cb (const_rtx x, const_rtx y, rtx_equal_p_callback_function cb)\n     case CONST_FIXED:\n       return 0;\n \n+    case DEBUG_IMPLICIT_PTR:\n+      return DEBUG_IMPLICIT_PTR_DECL (x)\n+\t     == DEBUG_IMPLICIT_PTR_DECL (y);\n+\n     default:\n       break;\n     }\n@@ -527,6 +531,10 @@ rtx_equal_p (const_rtx x, const_rtx y)\n     case CONST_FIXED:\n       return 0;\n \n+    case DEBUG_IMPLICIT_PTR:\n+      return DEBUG_IMPLICIT_PTR_DECL (x)\n+\t     == DEBUG_IMPLICIT_PTR_DECL (y);\n+\n     default:\n       break;\n     }"}, {"sha": "282cca6be2680cb51fdc0a160928a840c865a3cb", "filename": "gcc/rtl.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a27c401821b4d29c28add396177637f9f381d5/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a27c401821b4d29c28add396177637f9f381d5/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=c8a27c401821b4d29c28add396177637f9f381d5", "patch": "@@ -711,6 +711,10 @@ DEF_RTL_EXPR(US_TRUNCATE, \"us_truncate\", \"e\", RTX_UNARY)\n    initialization status of variables.  */\n DEF_RTL_EXPR(VAR_LOCATION, \"var_location\", \"tei\", RTX_EXTRA)\n \n+/* Used in VAR_LOCATION for a pointer to a decl that is no longer\n+   addressable.  */\n+DEF_RTL_EXPR(DEBUG_IMPLICIT_PTR, \"debug_implicit_ptr\", \"t\", RTX_OBJ)\n+\n /* All expressions from this point forward appear only in machine\n    descriptions.  */\n #ifdef GENERATOR_FILE"}, {"sha": "f490a0c29e3e0e1b6554c0bffb983c38830d2cf3", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a27c401821b4d29c28add396177637f9f381d5/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a27c401821b4d29c28add396177637f9f381d5/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=c8a27c401821b4d29c28add396177637f9f381d5", "patch": "@@ -933,6 +933,9 @@ extern const char * const reg_note_name[];\n /* DEBUG_EXPR_DECL corresponding to a DEBUG_EXPR RTX.  */\n #define DEBUG_EXPR_TREE_DECL(RTX) XCTREE (RTX, 0, DEBUG_EXPR)\n \n+/* VAR_DECL/PARM_DECL DEBUG_IMPLICIT_PTR takes address of.  */\n+#define DEBUG_IMPLICIT_PTR_DECL(RTX) XCTREE (RTX, 0, DEBUG_IMPLICIT_PTR)\n+\n /* Possible initialization status of a variable.   When requested\n    by the user, this information is tracked and recorded in the DWARF\n    debug information, along with the variable's location.  */"}, {"sha": "ec24917ee9a27bd14d445c6b62baeb3c78b9858d", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a27c401821b4d29c28add396177637f9f381d5/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a27c401821b4d29c28add396177637f9f381d5/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=c8a27c401821b4d29c28add396177637f9f381d5", "patch": "@@ -1,3 +1,7 @@\n+2010-09-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* dwarf2.h (DW_OP_GNU_implicit_pointer): New.\n+\n 2010-07-06  Ken Werner  <ken.werner@de.ibm.com>\n \n \t* floatformat.h (floatformat_ieee_half_big): Add declaration."}, {"sha": "fea23ad61e493c81bb8a3951e2669313baa3aafb", "filename": "include/dwarf2.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a27c401821b4d29c28add396177637f9f381d5/include%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a27c401821b4d29c28add396177637f9f381d5/include%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdwarf2.h?ref=c8a27c401821b4d29c28add396177637f9f381d5", "patch": "@@ -622,6 +622,7 @@ enum dwarf_location_atom\n     /* The following is for marking variables that are uninitialized.  */\n     DW_OP_GNU_uninit     = 0xf0,\n     DW_OP_GNU_encoded_addr = 0xf1,\n+    DW_OP_GNU_implicit_pointer = 0xf2,\n     /* HP extensions.  */\n     DW_OP_HP_unknown     = 0xe0, /* Ouch, the same as GNU_push_tls_address.  */\n     DW_OP_HP_is_value    = 0xe1,"}]}