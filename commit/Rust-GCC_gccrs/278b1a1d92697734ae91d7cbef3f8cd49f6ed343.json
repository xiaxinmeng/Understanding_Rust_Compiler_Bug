{"sha": "278b1a1d92697734ae91d7cbef3f8cd49f6ed343", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc4YjFhMWQ5MjY5NzczNGFlOTFkN2NiZWYzZjhjZDQ5ZjZlZDM0Mw==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-12-01T17:25:30Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-12-01T17:25:30Z"}, "message": "Avoid the analysis of data references after the translation out of SSA.\n\n2010-11-26  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* graphite-sese-to-poly.c (analyze_drs): Removed.\n\t(build_scop_drs): Do not call analyze_drs.\n\t(analyze_drs_in_stmts): New.\n\t(insert_stmts): New.\n\t(insert_out_of_ssa_copy): Call analyze_drs_in_stmts.\n\t(insert_out_of_ssa_copy_on_edge): Same.\n\t(rewrite_close_phi_out_of_ssa): Call insert_stmts.\n\t(rewrite_phi_out_of_ssa): Same.\n\t(rewrite_cross_bb_scalar_dependence): Same.\n\t(split_reduction_stmt): Move data references in the new basic blocks.\n\t(translate_scalar_reduction_to_array_for_stmt): Call insert_stmts.\n\nFrom-SVN: r167350", "tree": {"sha": "2e9010a052068a5ef9d980a369bd60ea8b52df32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e9010a052068a5ef9d980a369bd60ea8b52df32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/278b1a1d92697734ae91d7cbef3f8cd49f6ed343", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/278b1a1d92697734ae91d7cbef3f8cd49f6ed343", "html_url": "https://github.com/Rust-GCC/gccrs/commit/278b1a1d92697734ae91d7cbef3f8cd49f6ed343", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/278b1a1d92697734ae91d7cbef3f8cd49f6ed343/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87b286c4dede5457d333cd76cc7b43a1ed9a7107", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87b286c4dede5457d333cd76cc7b43a1ed9a7107", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87b286c4dede5457d333cd76cc7b43a1ed9a7107"}], "stats": {"total": 201, "additions": 134, "deletions": 67}, "files": [{"sha": "65bf3f380d4e8393e008399ba79b9ae15428ad54", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/278b1a1d92697734ae91d7cbef3f8cd49f6ed343/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/278b1a1d92697734ae91d7cbef3f8cd49f6ed343/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=278b1a1d92697734ae91d7cbef3f8cd49f6ed343", "patch": "@@ -1,4 +1,18 @@\n-2010-11-29  Sebastian Pop  <sebastian.pop@amd.com>\n+2010-12-01  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-sese-to-poly.c (analyze_drs): Removed.\n+\t(build_scop_drs): Do not call analyze_drs.\n+\t(analyze_drs_in_stmts): New.\n+\t(insert_stmts): New.\n+\t(insert_out_of_ssa_copy): Call analyze_drs_in_stmts.\n+\t(insert_out_of_ssa_copy_on_edge): Same.\n+\t(rewrite_close_phi_out_of_ssa): Call insert_stmts.\n+\t(rewrite_phi_out_of_ssa): Same.\n+\t(rewrite_cross_bb_scalar_dependence): Same.\n+\t(split_reduction_stmt): Move data references in the new basic blocks.\n+\t(translate_scalar_reduction_to_array_for_stmt): Call insert_stmts.\n+\n+2010-12-01  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* sese.c (rename_uses): Do not handle ADDR_EXPR in LHS of assignments.\n "}, {"sha": "b5c600417c254eb5122f9d344dfd940116e3210e", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/278b1a1d92697734ae91d7cbef3f8cd49f6ed343/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/278b1a1d92697734ae91d7cbef3f8cd49f6ed343/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=278b1a1d92697734ae91d7cbef3f8cd49f6ed343", "patch": "@@ -1,3 +1,17 @@\n+2010-11-26  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-sese-to-poly.c (analyze_drs): Removed.\n+\t(build_scop_drs): Do not call analyze_drs.\n+\t(analyze_drs_in_stmts): New.\n+\t(insert_stmts): New.\n+\t(insert_out_of_ssa_copy): Call analyze_drs_in_stmts.\n+\t(insert_out_of_ssa_copy_on_edge): Same.\n+\t(rewrite_close_phi_out_of_ssa): Call insert_stmts.\n+\t(rewrite_phi_out_of_ssa): Same.\n+\t(rewrite_cross_bb_scalar_dependence): Same.\n+\t(split_reduction_stmt): Move data references in the new basic blocks.\n+\t(translate_scalar_reduction_to_array_for_stmt): Call insert_stmts.\n+\n 2010-11-26  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* sese.c (rename_uses): Do not handle ADDR_EXPR in LHS of assignments."}, {"sha": "b5bc91423707ff0254d66cd8c538cc4862b82a38", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 105, "deletions": 66, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/278b1a1d92697734ae91d7cbef3f8cd49f6ed343/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/278b1a1d92697734ae91d7cbef3f8cd49f6ed343/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=278b1a1d92697734ae91d7cbef3f8cd49f6ed343", "patch": "@@ -1956,36 +1956,6 @@ dump_alias_graphs (VEC (data_reference_p, heap) *drs)\n     }\n }\n \n-/* Recompute all the data references of BB and add them to the\n-   GBB_DATA_REFS vector.  */\n-\n-static void\n-analyze_drs (scop_p scop, basic_block bb)\n-{\n-  loop_p nest;\n-  poly_bb_p pbb;\n-  gimple_stmt_iterator gsi;\n-  gimple_bb_p gbb;\n-\n-  if (!bb_in_sese_p (bb, SCOP_REGION (scop)))\n-    return;\n-\n-  nest = outermost_loop_in_sese (SCOP_REGION (scop), bb);\n-  pbb = pbb_from_bb (bb);\n-  gbb = PBB_BLACK_BOX (pbb);\n-\n-  VEC_free (data_reference_p, heap, GBB_DATA_REFS (gbb));\n-  GBB_DATA_REFS (gbb) = VEC_alloc (data_reference_p, heap, 3);\n-\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple stmt = gsi_stmt (gsi);\n-      if (!is_gimple_debug (stmt))\n-\tgraphite_find_data_references_in_stmt (nest, stmt,\n-\t\t\t\t\t       &GBB_DATA_REFS (gbb));\n-    }\n-}\n-\n /* Build data references in SCOP.  */\n \n static void\n@@ -1999,14 +1969,11 @@ build_scop_drs (scop_p scop)\n   /* Remove all the PBBs that do not have data references: these basic\n      blocks are not handled in the polyhedral representation.  */\n   for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n-    {\n-      analyze_drs (scop, GBB_BB (PBB_BLACK_BOX (pbb)));\n-      if (VEC_empty (data_reference_p, GBB_DATA_REFS (PBB_BLACK_BOX (pbb))))\n-\t{\n-\t  VEC_ordered_remove (poly_bb_p, SCOP_BBS (scop), i);\n-\t  i--;\n-\t}\n-    }\n+    if (VEC_empty (data_reference_p, GBB_DATA_REFS (PBB_BLACK_BOX (pbb))))\n+      {\n+\tVEC_ordered_remove (poly_bb_p, SCOP_BBS (scop), i);\n+\ti--;\n+      }\n \n   FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     for (j = 0; VEC_iterate (data_reference_p,\n@@ -2051,21 +2018,73 @@ gsi_for_phi_node (gimple stmt)\n   return psi;\n }\n \n+/* Analyze all the data references of STMTS and add them to the\n+   GBB_DATA_REFS vector of BB.  */\n+\n+static void\n+analyze_drs_in_stmts (scop_p scop, basic_block bb, VEC (gimple, heap) *stmts)\n+{\n+  loop_p nest;\n+  poly_bb_p pbb;\n+  gimple_bb_p gbb;\n+  gimple stmt;\n+  int i;\n+\n+  if (!bb_in_sese_p (bb, SCOP_REGION (scop)))\n+    return;\n+\n+  nest = outermost_loop_in_sese (SCOP_REGION (scop), bb);\n+  pbb = pbb_from_bb (bb);\n+  gbb = gbb_from_bb (bb);\n+\n+  FOR_EACH_VEC_ELT (gimple, stmts, i, stmt)\n+    if (!is_gimple_debug (stmt))\n+      graphite_find_data_references_in_stmt (nest, stmt,\n+\t\t\t\t\t     &GBB_DATA_REFS (gbb));\n+}\n+\n+/* Insert STMT at the end of the STMTS sequence and then insert the\n+   statements from STMTS at INSERT_GSI and call analyze_drs_in_stmts\n+   on STMTS.  */\n+\n+static void\n+insert_stmts (scop_p scop, gimple stmt, gimple_seq stmts,\n+\t      gimple_stmt_iterator insert_gsi)\n+{\n+  gimple_stmt_iterator gsi;\n+  VEC (gimple, heap) *x = VEC_alloc (gimple, heap, 3);\n+\n+  if (!stmts)\n+    stmts = gimple_seq_alloc ();\n+\n+  gsi = gsi_last (stmts);\n+  gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+  for (gsi = gsi_start (stmts); !gsi_end_p (gsi); gsi_next (&gsi))\n+    VEC_safe_push (gimple, heap, x, gsi_stmt (gsi));\n+\n+  gsi_insert_seq_before (&insert_gsi, stmts, GSI_SAME_STMT);\n+  analyze_drs_in_stmts (scop, gsi_bb (insert_gsi), x);\n+  VEC_free (gimple, heap, x);\n+}\n+\n /* Insert the assignment \"RES := EXPR\" just after AFTER_STMT.  */\n \n static void\n-insert_out_of_ssa_copy (tree res, tree expr, gimple after_stmt)\n+insert_out_of_ssa_copy (scop_p scop, tree res, tree expr, gimple after_stmt)\n {\n   gimple_seq stmts;\n   gimple_stmt_iterator si;\n   gimple_stmt_iterator gsi;\n   tree var = force_gimple_operand (expr, &stmts, true, NULL_TREE);\n   gimple stmt = gimple_build_assign (res, var);\n+  VEC (gimple, heap) *x = VEC_alloc (gimple, heap, 3);\n \n   if (!stmts)\n     stmts = gimple_seq_alloc ();\n   si = gsi_last (stmts);\n   gsi_insert_after (&si, stmt, GSI_NEW_STMT);\n+  for (gsi = gsi_start (stmts); !gsi_end_p (gsi); gsi_next (&gsi))\n+    VEC_safe_push (gimple, heap, x, gsi_stmt (gsi));\n \n   if (gimple_code (after_stmt) == GIMPLE_PHI)\n     {\n@@ -2077,6 +2096,9 @@ insert_out_of_ssa_copy (tree res, tree expr, gimple after_stmt)\n       gsi = gsi_for_stmt (after_stmt);\n       gsi_insert_seq_after (&gsi, stmts, GSI_NEW_STMT);\n     }\n+\n+  analyze_drs_in_stmts (scop, gimple_bb (after_stmt), x);\n+  VEC_free (gimple, heap, x);\n }\n \n /* Creates a poly_bb_p for basic_block BB from the existing PBB.  */\n@@ -2113,12 +2135,16 @@ insert_out_of_ssa_copy_on_edge (scop_p scop, edge e, tree res, tree expr)\n   tree var = force_gimple_operand (expr, &stmts, true, NULL_TREE);\n   gimple stmt = gimple_build_assign (res, var);\n   basic_block bb;\n+  VEC (gimple, heap) *x = VEC_alloc (gimple, heap, 3);\n \n   if (!stmts)\n     stmts = gimple_seq_alloc ();\n \n   gsi = gsi_last (stmts);\n   gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+  for (gsi = gsi_start (stmts); !gsi_end_p (gsi); gsi_next (&gsi))\n+    VEC_safe_push (gimple, heap, x, gsi_stmt (gsi));\n+\n   gsi_insert_seq_on_edge (e, stmts);\n   gsi_commit_edge_inserts ();\n   bb = gimple_bb (stmt);\n@@ -2128,6 +2154,9 @@ insert_out_of_ssa_copy_on_edge (scop_p scop, edge e, tree res, tree expr)\n \n   if (!gbb_from_bb (bb))\n     new_pbb_from_pbb (scop, pbb_from_bb (e->src), bb);\n+\n+  analyze_drs_in_stmts (scop, bb, x);\n+  VEC_free (gimple, heap, x);\n }\n \n /* Creates a zero dimension array of the same type as VAR.  */\n@@ -2269,16 +2298,17 @@ rewrite_close_phi_out_of_ssa (scop_p scop, gimple_stmt_iterator *psi)\n       stmt = gimple_build_assign (res, zero_dim_array);\n \n       if (TREE_CODE (arg) == SSA_NAME)\n-\tinsert_out_of_ssa_copy (zero_dim_array, arg,\n+\tinsert_out_of_ssa_copy (scop, zero_dim_array, arg,\n \t\t\t\tSSA_NAME_DEF_STMT (arg));\n       else\n \tinsert_out_of_ssa_copy_on_edge (scop, single_pred_edge (bb),\n \t\t\t\t\tzero_dim_array, arg);\n     }\n \n   remove_phi_node (psi, false);\n-  gsi_insert_before (&gsi, stmt, GSI_NEW_STMT);\n   SSA_NAME_DEF_STMT (res) = stmt;\n+\n+  insert_stmts (scop, stmt, NULL, gsi_after_labels (bb));\n }\n \n /* Rewrite out of SSA the reduction phi node at PSI by creating a zero\n@@ -2293,7 +2323,6 @@ rewrite_phi_out_of_ssa (scop_p scop, gimple_stmt_iterator *psi)\n   tree res = gimple_phi_result (phi);\n   tree var = SSA_NAME_VAR (res);\n   tree zero_dim_array = create_zero_dim_array (var, \"phi_out_of_ssa\");\n-  gimple_stmt_iterator gsi;\n   gimple stmt;\n   gimple_seq stmts;\n \n@@ -2306,26 +2335,19 @@ rewrite_phi_out_of_ssa (scop_p scop, gimple_stmt_iterator *psi)\n \t pattern matching of the vectorizer.  */\n       if (TREE_CODE (arg) == SSA_NAME\n \t  && e->src == bb->loop_father->latch)\n-\tinsert_out_of_ssa_copy (zero_dim_array, arg,\n+\tinsert_out_of_ssa_copy (scop, zero_dim_array, arg,\n \t\t\t\tSSA_NAME_DEF_STMT (arg));\n       else\n \tinsert_out_of_ssa_copy_on_edge (scop, e, zero_dim_array, arg);\n     }\n \n   var = force_gimple_operand (zero_dim_array, &stmts, true, NULL_TREE);\n \n-  if (!stmts)\n-    stmts = gimple_seq_alloc ();\n-\n   stmt = gimple_build_assign (res, var);\n   remove_phi_node (psi, false);\n   SSA_NAME_DEF_STMT (res) = stmt;\n \n-  gsi = gsi_last (stmts);\n-  gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n-\n-  gsi = gsi_after_labels (bb);\n-  gsi_insert_seq_before (&gsi, stmts, GSI_NEW_STMT);\n+  insert_stmts (scop, stmt, stmts, gsi_after_labels (bb));\n }\n \n /* Rewrite the degenerate phi node at position PSI from the degenerate\n@@ -2395,22 +2417,19 @@ rewrite_reductions_out_of_ssa (scop_p scop)\n    read from ZERO_DIM_ARRAY.  */\n \n static void\n-rewrite_cross_bb_scalar_dependence (tree zero_dim_array,\n+rewrite_cross_bb_scalar_dependence (scop_p scop, tree zero_dim_array,\n \t\t\t\t    tree def, gimple use_stmt)\n {\n   tree var = SSA_NAME_VAR (def);\n   gimple name_stmt = gimple_build_assign (var, zero_dim_array);\n   tree name = make_ssa_name (var, name_stmt);\n   ssa_op_iter iter;\n   use_operand_p use_p;\n-  gimple_stmt_iterator gsi;\n \n   gcc_assert (gimple_code (use_stmt) != GIMPLE_PHI);\n \n   gimple_assign_set_lhs (name_stmt, name);\n-\n-  gsi = gsi_for_stmt (use_stmt);\n-  gsi_insert_before (&gsi, name_stmt, GSI_NEW_STMT);\n+  insert_stmts (scop, name_stmt, NULL, gsi_for_stmt (use_stmt));\n \n   FOR_EACH_SSA_USE_OPERAND (use_p, use_stmt, iter, SSA_OP_ALL_USES)\n     if (operand_equal_p (def, USE_FROM_PTR (use_p), 0))\n@@ -2534,12 +2553,12 @@ rewrite_cross_bb_scalar_deps (scop_p scop, gimple_stmt_iterator *gsi)\n \t  {\n \t    zero_dim_array = create_zero_dim_array\n \t      (SSA_NAME_VAR (def), \"Cross_BB_scalar_dependence\");\n-\t    insert_out_of_ssa_copy (zero_dim_array, def,\n+\t    insert_out_of_ssa_copy (scop, zero_dim_array, def,\n \t\t\t\t    SSA_NAME_DEF_STMT (def));\n \t    gsi_next (gsi);\n \t  }\n \n-\trewrite_cross_bb_scalar_dependence (zero_dim_array,\n+\trewrite_cross_bb_scalar_dependence (scop, zero_dim_array,\n \t\t\t\t\t    def, use_stmt);\n       }\n \n@@ -2626,7 +2645,10 @@ split_reduction_stmt (scop_p scop, gimple stmt)\n {\n   basic_block bb = gimple_bb (stmt);\n   poly_bb_p pbb = pbb_from_bb (bb);\n+  gimple_bb_p gbb = gbb_from_bb (bb);\n   edge e1;\n+  int i;\n+  data_reference_p dr;\n \n   /* Do not split basic blocks with no writes to memory: the reduction\n      will be the only write to memory.  */\n@@ -2644,6 +2666,22 @@ split_reduction_stmt (scop_p scop, gimple stmt)\n       e1 = split_pbb (scop, pbb, bb, gsi_stmt (gsi));\n     }\n \n+  /* A part of the data references will end in a different basic block\n+     after the split: move the DRs from the original GBB to the newly\n+     created GBB1.  */\n+  FOR_EACH_VEC_ELT (data_reference_p, GBB_DATA_REFS (gbb), i, dr)\n+    {\n+      basic_block bb1 = gimple_bb (DR_STMT (dr));\n+\n+      if (bb1 != bb)\n+\t{\n+\t  gimple_bb_p gbb1 = gbb_from_bb (bb1);\n+\t  VEC_safe_push (data_reference_p, heap, GBB_DATA_REFS (gbb1), dr);\n+\t  VEC_ordered_remove (data_reference_p, GBB_DATA_REFS (gbb), i);\n+\t  i--;\n+\t}\n+    }\n+\n   return e1->dest;\n }\n \n@@ -2870,18 +2908,19 @@ detect_commutative_reduction (gimple stmt, VEC (gimple, heap) **in,\n    knowing that its recursive phi node is LOOP_PHI.  */\n \n static void\n-translate_scalar_reduction_to_array_for_stmt (tree red, gimple stmt,\n-\t\t\t\t\t      gimple loop_phi)\n+translate_scalar_reduction_to_array_for_stmt (scop_p scop, tree red,\n+\t\t\t\t\t      gimple stmt, gimple loop_phi)\n {\n   tree res = gimple_phi_result (loop_phi);\n   gimple assign = gimple_build_assign (res, red);\n-  gimple_stmt_iterator insert_gsi = gsi_after_labels (gimple_bb (loop_phi));\n+  gimple_stmt_iterator gsi;\n \n-  gsi_insert_before (&insert_gsi, assign, GSI_SAME_STMT);\n+  insert_stmts (scop, assign, NULL, gsi_after_labels (gimple_bb (loop_phi)));\n \n   assign = gimple_build_assign (red, gimple_assign_lhs (stmt));\n-  insert_gsi = gsi_for_stmt (stmt);\n-  gsi_insert_after (&insert_gsi, assign, GSI_SAME_STMT);\n+  gsi = gsi_for_stmt (stmt);\n+  gsi_next (&gsi);\n+  insert_stmts (scop, assign, NULL, gsi);\n }\n \n /* Removes the PHI node and resets all the debug stmts that are using\n@@ -2953,13 +2992,13 @@ translate_scalar_reduction_to_array (scop_p scop,\n \t  red = create_zero_dim_array\n \t    (gimple_assign_lhs (stmt), \"Commutative_Associative_Reduction\");\n \t  translate_scalar_reduction_to_array_for_stmt\n-\t    (red, stmt, VEC_index (gimple, in, 1));\n+\t    (scop, red, stmt, VEC_index (gimple, in, 1));\n \t  continue;\n \t}\n \n       if (i == VEC_length (gimple, in) - 1)\n \t{\n-\t  insert_out_of_ssa_copy (gimple_phi_result (close_phi), red,\n+\t  insert_out_of_ssa_copy (scop, gimple_phi_result (close_phi), red,\n \t\t\t\t  close_phi);\n \t  insert_out_of_ssa_copy_on_edge\n \t    (scop, edge_initial_value_for_loop_phi (loop_phi),"}]}