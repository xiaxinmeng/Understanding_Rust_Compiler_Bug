{"sha": "af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYyYmJjNTFkMzg3OWI2ZTdhMDNiNGRjMmQ0YWIwMTdhOTgyNzBiYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-07-01T20:46:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-07-01T20:46:40Z"}, "message": "cfg.c (scale_bbs_frequencies): New function.\n\n\t* cfg.c (scale_bbs_frequencies): New function.\n\t* cfg.h (scale_bbs_frequencies): Declare it.\n\t* cfgloopanal.c (single_likely_exit): Cleanup.\n\t* cfgloopmanip.c (scale_loop_frequencies): Take profile_probability\n\tas parameter.\n\t(scale_loop_profile): Likewise.\n\t(loop_version): Likewise.\n\t(create_empty_loop_on_edge): Update.\n\t* cfgloopmanip.h (scale_loop_frequencies, scale_loop_profile,\n\tscale_loop_frequencies, scale_loop_profile, loopify,\n\tloop_version): Update prototypes.\n\t* modulo-sched.c (sms_schedule): Update.\n\t* predict.c (unlikely_executed_edge_p): Also check probability.\n\t(probably_never_executed_edge_p): Fix typo.\n\t* tree-if-conv.c (version_loop_for_if_conversion): Update.\n\t* tree-parloops.c (gen_parallel_loop): Update.\n\t* tree-ssa-loop-ivcanon.c (try_peel_loop): Update.\n\t* tree-ssa-loop-manip.c (tree_transform_and_unroll_loop): Update.\n\t* tree-ssa-loop-split.c (split_loop): Update.\n\t* tree-ssa-loop-unswitch.c (tree_unswitch_loop): Update.\n\t* tree-vect-loop-manip.c (vect_do_peeling): Update.\n\t(vect_loop_versioning): Update.\n\t* tree-vect-loop.c (scale_profile_for_vect_loop): Update.\n\nFrom-SVN: r249872", "tree": {"sha": "7af6a2ca2adedc6bef10ea8e3c46425031abf858", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7af6a2ca2adedc6bef10ea8e3c46425031abf858"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/comments", "author": null, "committer": null, "parents": [{"sha": "e39df5466d0cde13fd47e612f20ef2b0ac117e2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e39df5466d0cde13fd47e612f20ef2b0ac117e2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e39df5466d0cde13fd47e612f20ef2b0ac117e2b"}], "stats": {"total": 234, "additions": 132, "deletions": 102}, "files": [{"sha": "36696807dc34e3bcfeade35a45e8a86ea233f4ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "patch": "@@ -1,3 +1,29 @@\n+2017-07-01  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cfg.c (scale_bbs_frequencies): New function.\n+\t* cfg.h (scale_bbs_frequencies): Declare it.\n+\t* cfgloopanal.c (single_likely_exit): Cleanup.\n+\t* cfgloopmanip.c (scale_loop_frequencies): Take profile_probability\n+\tas parameter.\n+\t(scale_loop_profile): Likewise.\n+\t(loop_version): Likewise.\n+\t(create_empty_loop_on_edge): Update.\n+\t* cfgloopmanip.h (scale_loop_frequencies, scale_loop_profile,\n+\tscale_loop_frequencies, scale_loop_profile, loopify,\n+\tloop_version): Update prototypes.\n+\t* modulo-sched.c (sms_schedule): Update.\n+\t* predict.c (unlikely_executed_edge_p): Also check probability.\n+\t(probably_never_executed_edge_p): Fix typo.\n+\t* tree-if-conv.c (version_loop_for_if_conversion): Update.\n+\t* tree-parloops.c (gen_parallel_loop): Update.\n+\t* tree-ssa-loop-ivcanon.c (try_peel_loop): Update.\n+\t* tree-ssa-loop-manip.c (tree_transform_and_unroll_loop): Update.\n+\t* tree-ssa-loop-split.c (split_loop): Update.\n+\t* tree-ssa-loop-unswitch.c (tree_unswitch_loop): Update.\n+\t* tree-vect-loop-manip.c (vect_do_peeling): Update.\n+\t(vect_loop_versioning): Update.\n+\t* tree-vect-loop.c (scale_profile_for_vect_loop): Update.\n+\n 2017-07-01  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* trans-mem.c (split_bb_make_tm_edge): Update profile."}, {"sha": "01e68aeda518994f82ef57c4422e0c94cded68a7", "filename": "gcc/cfg.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "patch": "@@ -1051,6 +1051,26 @@ scale_bbs_frequencies_profile_count (basic_block *bbs, int nbbs,\n     }\n }\n \n+/* Multiply all frequencies of basic blocks in array BBS of length NBBS\n+   by NUM/DEN, in profile_count arithmetic.  More accurate than previous\n+   function but considerably slower.  */\n+void\n+scale_bbs_frequencies (basic_block *bbs, int nbbs,\n+\t\t       profile_probability p)\n+{\n+  int i;\n+  edge e;\n+\n+  for (i = 0; i < nbbs; i++)\n+    {\n+      edge_iterator ei;\n+      bbs[i]->frequency = p.apply (bbs[i]->frequency);\n+      bbs[i]->count = bbs[i]->count.apply_probability (p);\n+      FOR_EACH_EDGE (e, ei, bbs[i]->succs)\n+\te->count =  e->count.apply_probability (p);\n+    }\n+}\n+\n /* Helper types for hash tables.  */\n \n struct htab_bb_copy_original_entry"}, {"sha": "81b243a1a9e17a187414d25b2840028bd436fff3", "filename": "gcc/cfg.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Fcfg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Fcfg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.h?ref=af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "patch": "@@ -109,6 +109,7 @@ extern void scale_bbs_frequencies_gcov_type (basic_block *, int, gcov_type,\n \t\t\t\t\t     gcov_type);\n extern void scale_bbs_frequencies_profile_count (basic_block *, int,\n \t\t\t\t\t     profile_count, profile_count);\n+extern void scale_bbs_frequencies (basic_block *, int, profile_probability);\n extern void initialize_original_copy_tables (void);\n extern void reset_original_copy_tables (void);\n extern void free_original_copy_tables (void);"}, {"sha": "73710abac6e2e6637bff0b91286459b30e17a1b1", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "patch": "@@ -469,16 +469,12 @@ single_likely_exit (struct loop *loop)\n   exits = get_loop_exit_edges (loop);\n   FOR_EACH_VEC_ELT (exits, i, ex)\n     {\n-      if (ex->flags & (EDGE_EH | EDGE_ABNORMAL_CALL))\n-\tcontinue;\n-      /* The constant of 5 is set in a way so noreturn calls are\n-\t ruled out by this test.  The static branch prediction algorithm\n-         will not assign such a low probability to conditionals for usual\n-         reasons.\n-\t FIXME: Turn to likely_never_executed  */\n-      if ((profile_status_for_fn (cfun) != PROFILE_ABSENT\n-\t   && ex->probability < profile_probability::from_reg_br_prob_base (5))\n-\t  || ex->count == profile_count::zero ())\n+      if (probably_never_executed_edge_p (cfun, ex)\n+\t  /* We want to rule out paths to noreturns but not low probabilities\n+\t     resulting from adjustments or combining.\n+\t     FIXME: once we have better quality tracking, make this more\n+\t     robust.  */\n+\t  || ex->probability <= profile_probability::very_unlikely ())\n \tcontinue;\n       if (!found)\n \tfound = ex;"}, {"sha": "a7d0e612eb26f120702334da34f442bf19178bbd", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "patch": "@@ -488,38 +488,42 @@ add_loop (struct loop *loop, struct loop *outer)\n   free (bbs);\n }\n \n-/* Multiply all frequencies in LOOP by NUM/DEN.  */\n+/* Scale profile of loop by P.  */\n \n void\n-scale_loop_frequencies (struct loop *loop, int num, int den)\n+scale_loop_frequencies (struct loop *loop, profile_probability p)\n {\n   basic_block *bbs;\n \n   bbs = get_loop_body (loop);\n-  scale_bbs_frequencies_int (bbs, loop->num_nodes, num, den);\n+  scale_bbs_frequencies (bbs, loop->num_nodes, p);\n   free (bbs);\n }\n \n-/* Multiply all frequencies in LOOP by SCALE/REG_BR_PROB_BASE.\n+/* Scale profile in LOOP by P.\n    If ITERATION_BOUND is non-zero, scale even further if loop is predicted\n    to iterate too many times.  */\n \n void\n-scale_loop_profile (struct loop *loop, int scale, gcov_type iteration_bound)\n+scale_loop_profile (struct loop *loop, profile_probability p,\n+\t\t    gcov_type iteration_bound)\n {\n   gcov_type iterations = expected_loop_iterations_unbounded (loop);\n   edge e;\n   edge_iterator ei;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \";; Scaling loop %i with scale %f, \"\n-\t     \"bounding iterations to %i from guessed %i\\n\",\n-\t     loop->num, (double)scale / REG_BR_PROB_BASE,\n-\t     (int)iteration_bound, (int)iterations);\n+    {\n+      fprintf (dump_file, \";; Scaling loop %i with scale \",\n+\t       loop->num);\n+      p.dump (dump_file);\n+      fprintf (dump_file, \" bounding iterations to %i from guessed %i\\n\",\n+\t       (int)iteration_bound, (int)iterations);\n+    }\n \n   /* See if loop is predicted to iterate too many times.  */\n   if (iteration_bound && iterations > 0\n-      && apply_probability (iterations, scale) > iteration_bound)\n+      && p.apply (iterations) > iteration_bound)\n     {\n       /* Fixing loop profile for different trip count is not trivial; the exit\n \t probabilities has to be updated to match and frequencies propagated down\n@@ -569,7 +573,7 @@ scale_loop_profile (struct loop *loop, int scale, gcov_type iteration_bound)\n       /* Roughly speaking we want to reduce the loop body profile by the\n \t difference of loop iterations.  We however can do better if\n \t we look at the actual profile, if it is available.  */\n-      scale = RDIV (iteration_bound * scale, iterations);\n+      p = p.apply_scale (iteration_bound, iterations);\n \n       bool determined = false;\n       if (loop->header->count.initialized_p ())\n@@ -582,9 +586,8 @@ scale_loop_profile (struct loop *loop, int scale, gcov_type iteration_bound)\n \n \t  if (count_in > profile_count::zero () )\n \t    {\n-\t      scale = GCOV_COMPUTE_SCALE (count_in.to_gcov_type ()\n-\t\t\t\t\t  * iteration_bound,\n-                                          loop->header->count.to_gcov_type ());\n+\t      p = count_in.probability_in (loop->header->count.apply_scale\n+\t\t\t\t\t\t (iteration_bound, 1));\n \t      determined = true;\n \t    }\n \t}\n@@ -597,18 +600,19 @@ scale_loop_profile (struct loop *loop, int scale, gcov_type iteration_bound)\n \t      freq_in += EDGE_FREQUENCY (e);\n \n \t  if (freq_in != 0)\n-\t    scale = GCOV_COMPUTE_SCALE (freq_in * iteration_bound,\n-                                        loop->header->frequency);\n+\t    p = profile_probability::probability_in_gcov_type\n+\t\t\t (freq_in * iteration_bound, loop->header->frequency);\n \t}\n-      if (!scale)\n-\tscale = 1;\n+      if (!(p > profile_probability::never ()))\n+\tp = profile_probability::very_unlikely ();\n     }\n \n-  if (scale == REG_BR_PROB_BASE)\n+  if (p >= profile_probability::always ()\n+      || !p.initialized_p ())\n     return;\n \n   /* Scale the actual probabilities.  */\n-  scale_loop_frequencies (loop, scale, REG_BR_PROB_BASE);\n+  scale_loop_frequencies (loop, p);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \";; guessed iterations are now %i\\n\",\n \t     (int)expected_loop_iterations_unbounded (loop));\n@@ -778,7 +782,6 @@ create_empty_loop_on_edge (edge entry_edge,\n   gcond *cond_expr;\n   tree exit_test;\n   edge exit_e;\n-  int prob;\n \n   gcc_assert (entry_edge && initial_value && stride && upper_bound && iv);\n \n@@ -802,9 +805,7 @@ create_empty_loop_on_edge (edge entry_edge,\n   add_loop (loop, outer);\n \n   /* TODO: Fix frequencies and counts.  */\n-  prob = REG_BR_PROB_BASE / 2;\n-\n-  scale_loop_frequencies (loop, REG_BR_PROB_BASE - prob, REG_BR_PROB_BASE);\n+  scale_loop_frequencies (loop, profile_probability::even ());\n \n   /* Update dominators.  */\n   update_dominators_in_loop (loop);\n@@ -862,7 +863,8 @@ create_empty_loop_on_edge (edge entry_edge,\n struct loop *\n loopify (edge latch_edge, edge header_edge,\n \t basic_block switch_bb, edge true_edge, edge false_edge,\n-\t bool redirect_all_edges, unsigned true_scale, unsigned false_scale)\n+\t bool redirect_all_edges, profile_probability true_scale,\n+\t profile_probability false_scale)\n {\n   basic_block succ_bb = latch_edge->dest;\n   basic_block pred_bb = header_edge->src;\n@@ -915,8 +917,8 @@ loopify (edge latch_edge, edge header_edge,\n \t  e->count = switch_bb->count.apply_probability (e->probability);\n \t}\n     }\n-  scale_loop_frequencies (loop, false_scale, REG_BR_PROB_BASE);\n-  scale_loop_frequencies (succ_bb->loop_father, true_scale, REG_BR_PROB_BASE);\n+  scale_loop_frequencies (loop, false_scale);\n+  scale_loop_frequencies (succ_bb->loop_father, true_scale);\n   update_dominators_in_loop (loop);\n \n   return loop;\n@@ -1683,7 +1685,7 @@ struct loop *\n loop_version (struct loop *loop,\n \t      void *cond_expr, basic_block *condition_bb,\n \t      profile_probability then_prob, profile_probability else_prob,\n-\t      unsigned then_scale, unsigned else_scale,\n+\t      profile_probability then_scale, profile_probability else_scale,\n \t      bool place_after)\n {\n   basic_block first_head, second_head;"}, {"sha": "2eab70f3adae63860e1e1cf34c1df8db11ff5ed6", "filename": "gcc/cfgloopmanip.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Fcfgloopmanip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Fcfgloopmanip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.h?ref=af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "patch": "@@ -37,14 +37,14 @@ extern edge mfb_kj_edge;\n extern bool remove_path (edge, bool * = NULL, bitmap = NULL);\n extern void place_new_loop (struct function *, struct loop *);\n extern void add_loop (struct loop *, struct loop *);\n-extern void scale_loop_frequencies (struct loop *, int, int);\n-extern void scale_loop_profile (struct loop *, int, gcov_type);\n+extern void scale_loop_frequencies (struct loop *, profile_probability);\n+extern void scale_loop_profile (struct loop *, profile_probability, gcov_type);\n extern edge create_empty_if_region_on_edge (edge, tree);\n extern struct loop *create_empty_loop_on_edge (edge, tree, tree, tree, tree,\n \t\t\t\t\t       tree *, tree *, struct loop *);\n extern struct loop *loopify (edge, edge,\n \t\t\t     basic_block, edge, edge, bool,\n-\t\t\t     unsigned, unsigned);\n+\t\t\t     profile_probability, profile_probability);\n extern void unloop (struct loop *, bool *, bitmap);\n extern void copy_loop_info (struct loop *loop, struct loop *target);\n extern struct loop * duplicate_loop (struct loop *, struct loop *);\n@@ -60,6 +60,6 @@ extern void force_single_succ_latches (void);\n struct loop * loop_version (struct loop *, void *,\n \t\t\t    basic_block *,\n \t\t\t    profile_probability, profile_probability,\n-\t\t\t    unsigned, unsigned, bool);\n+\t\t\t    profile_probability, profile_probability, bool);\n \n #endif /* GCC_CFGLOOPMANIP_H */"}, {"sha": "f85011e90c216875a8fdb27eb3de86547c7157b8", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "patch": "@@ -1718,9 +1718,7 @@ sms_schedule (void)\n \n \t      loop_version (loop, comp_rtx, &condition_bb,\n \t  \t\t    prob, prob.invert (),\n-\t\t\t    prob.to_reg_br_prob_base (),\n-\t\t\t    prob.invert ().to_reg_br_prob_base (),\n-\t\t\t    true);\n+\t\t\t    prob, prob.invert (), true);\n \t     }\n \n \t  /* Set new iteration count of loop kernel.  */"}, {"sha": "4d01bf357efd4eb6ae971601144ce9337b32c63d", "filename": "gcc/predict.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "patch": "@@ -245,7 +245,8 @@ probably_never_executed_bb_p (struct function *fun, const_basic_block bb)\n static bool\n unlikely_executed_edge_p (edge e)\n {\n-  return e->count == profile_count::zero ()\n+  return (e->count == profile_count::zero ()\n+\t  || e->probability == profile_probability::never ())\n \t || (e->flags & (EDGE_EH | EDGE_FAKE));\n }\n \n@@ -254,8 +255,8 @@ unlikely_executed_edge_p (edge e)\n bool\n probably_never_executed_edge_p (struct function *fun, edge e)\n {\n-  if (e->count.initialized_p ())\n-    unlikely_executed_edge_p (e);\n+  if (unlikely_executed_edge_p (e))\n+    return true;\n   return probably_never_executed (fun, e->count, EDGE_FREQUENCY (e));\n }\n "}, {"sha": "ca29c762299a1d7835669fd209f368a99cad2213", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "patch": "@@ -2569,7 +2569,8 @@ version_loop_for_if_conversion (struct loop *loop)\n   new_loop = loop_version (loop, cond, &cond_bb,\n \t\t\t   profile_probability::always (),\n \t\t\t   profile_probability::always (),\n-\t\t\t   REG_BR_PROB_BASE, REG_BR_PROB_BASE, true);\n+\t\t\t   profile_probability::always (),\n+\t\t\t   profile_probability::always (), true);\n   free_original_copy_tables ();\n \n   for (unsigned i = 0; i < save_length; i++)"}, {"sha": "cf9bc36936c5ed5599669f9b1a56dd610637167e", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "patch": "@@ -2251,7 +2251,6 @@ gen_parallel_loop (struct loop *loop,\n   gimple_seq stmts;\n   edge entry, exit;\n   struct clsn_data clsn_data;\n-  unsigned prob;\n   location_t loc;\n   gimple *cond_stmt;\n   unsigned int m_p_thread=2;\n@@ -2358,12 +2357,11 @@ gen_parallel_loop (struct loop *loop,\n       initialize_original_copy_tables ();\n \n       /* We assume that the loop usually iterates a lot.  */\n-      prob = 4 * REG_BR_PROB_BASE / 5;\n       loop_version (loop, many_iterations_cond, NULL,\n-\t\t    profile_probability::from_reg_br_prob_base (prob),\n-\t\t    profile_probability::from_reg_br_prob_base\n-\t\t\t\t (REG_BR_PROB_BASE - prob),\n-\t\t    prob, REG_BR_PROB_BASE - prob, true);\n+\t\t    profile_probability::likely (),\n+\t\t    profile_probability::unlikely (),\n+\t\t    profile_probability::likely (),\n+\t\t    profile_probability::unlikely (), true);\n       update_ssa (TODO_update_ssa);\n       free_original_copy_tables ();\n     }"}, {"sha": "efb199aaaa25d3bd3c44bcf437c9e6e74b4f46ec", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "patch": "@@ -1104,12 +1104,13 @@ try_peel_loop (struct loop *loop,\n \tentry_freq += e->src->frequency;\n \tgcc_assert (!flow_bb_inside_loop_p (loop, e->src));\n       }\n-  int scale = 1;\n+  profile_probability p = profile_probability::very_unlikely ();\n   if (loop->header->count > 0)\n-    scale = entry_count.probability_in (loop->header->count).to_reg_br_prob_base ();\n+    p = entry_count.probability_in (loop->header->count);\n   else if (loop->header->frequency)\n-    scale = RDIV (entry_freq * REG_BR_PROB_BASE, loop->header->frequency);\n-  scale_loop_profile (loop, scale, 0);\n+    p = profile_probability::probability_in_gcov_type\n+\t\t (entry_freq, loop->header->frequency);\n+  scale_loop_profile (loop, p, 0);\n   bitmap_set_bit (peeled_loops, loop->num);\n   return true;\n }"}, {"sha": "b2f5f16b52a14a6a72898fb5e3323d1cf52a81d2", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "patch": "@@ -1212,7 +1212,7 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   gimple_stmt_iterator bsi;\n   use_operand_p op;\n   bool ok;\n-  unsigned i, prob, prob_entry, scale_unrolled, scale_rest;\n+  unsigned i, prob, prob_entry, scale_unrolled;\n   profile_count freq_e, freq_h;\n   gcov_type new_est_niter = niter_for_unrolled_loop (loop, factor);\n   unsigned irr = loop_preheader_edge (loop)->flags & EDGE_IRREDUCIBLE_LOOP;\n@@ -1241,14 +1241,16 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n      of this change (scale the frequencies of blocks before and after the exit\n      by appropriate factors).  */\n   scale_unrolled = prob_entry;\n-  scale_rest = REG_BR_PROB_BASE;\n \n   new_loop = loop_version (loop, enter_main_cond, NULL,\n \t\t\t   profile_probability::from_reg_br_prob_base\n \t\t\t\t (prob_entry),\n \t\t\t   profile_probability::from_reg_br_prob_base\n \t\t\t\t (REG_BR_PROB_BASE - prob_entry),\n-\t\t\t   scale_unrolled, scale_rest, true);\n+\t\t\t   profile_probability::from_reg_br_prob_base\n+\t\t\t\t(scale_unrolled),\n+\t\t\t   profile_probability::guessed_always (),\n+\t\t\t   true);\n   gcc_assert (new_loop != NULL);\n   update_ssa (TODO_update_ssa);\n \n@@ -1369,14 +1371,11 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n     }\n   if (freq_h > 0)\n     {\n-      gcov_type scale;\n       /* Avoid dropping loop body profile counter to 0 because of zero count\n \t in loop's preheader.  */\n       if (freq_e == profile_count::zero ())\n         freq_e = profile_count::from_gcov_type (1);\n-      /* This should not overflow.  */\n-      scale = freq_e.probability_in (freq_h).to_reg_br_prob_base ();\n-      scale_loop_frequencies (loop, scale, REG_BR_PROB_BASE);\n+      scale_loop_frequencies (loop, freq_e.probability_in (freq_h));\n     }\n \n   exit_bb = single_pred (loop->latch);"}, {"sha": "e454cc5dc93817393e7c5bd7f5f70e76286535e5", "filename": "gcc/tree-ssa-loop-split.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Ftree-ssa-loop-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Ftree-ssa-loop-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-split.c?ref=af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "patch": "@@ -564,7 +564,8 @@ split_loop (struct loop *loop1, struct tree_niter_desc *niter)\n \tstruct loop *loop2 = loop_version (loop1, cond, &cond_bb,\n \t\t\t\t\t   profile_probability::always (),\n \t\t\t\t\t   profile_probability::always (),\n-\t\t\t\t\t   REG_BR_PROB_BASE, REG_BR_PROB_BASE,\n+\t\t\t\t\t   profile_probability::always (),\n+\t\t\t\t\t   profile_probability::always (),\n \t\t\t\t\t   true);\n \tgcc_assert (loop2);\n \tupdate_ssa (TODO_update_ssa);"}, {"sha": "8482be5e543fe05a55cceb2f4af9814073365d5f", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "patch": "@@ -490,12 +490,10 @@ tree_unswitch_loop (struct loop *loop,\n \n   extract_true_false_edges_from_block (unswitch_on, &edge_true, &edge_false);\n   prob_true = edge_true->probability;\n-  int p = prob_true.initialized_p () ? prob_true.to_reg_br_prob_base ()\n-\t\t\t\t     : REG_BR_PROB_BASE / 2;\n   return loop_version (loop, unshare_expr (cond),\n \t\t       NULL, prob_true,\n \t\t       prob_true.invert (),\n-\t\t       p, REG_BR_PROB_BASE - p,\n+\t\t       prob_true, prob_true.invert (),\n \t\t       false);\n }\n "}, {"sha": "95b7ea06d282fe58d1ad19e56000304cedb49c65", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "patch": "@@ -1720,10 +1720,8 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t needs to be scaled back later.  */\n       basic_block bb_before_loop = loop_preheader_edge (loop)->src;\n       if (prob_vector.initialized_p ())\n-      scale_bbs_frequencies_int (&bb_before_loop, 1,\n-\t\t\t\t prob_vector.to_reg_br_prob_base (),\n-\t\t\t\t REG_BR_PROB_BASE);\n-      scale_loop_profile (loop, prob_vector.to_reg_br_prob_base (), bound);\n+      scale_bbs_frequencies (&bb_before_loop, 1, prob_vector);\n+      scale_loop_profile (loop, prob_vector, bound);\n     }\n \n   tree niters_prolog = build_int_cst (type, 0);\n@@ -1771,11 +1769,8 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t  e = (e != guard_e ? e : EDGE_PRED (guard_to, 1));\n \t  slpeel_update_phi_nodes_for_guard1 (prolog, loop, guard_e, e);\n \n-\t  scale_bbs_frequencies_int (&bb_after_prolog, 1,\n-\t\t\t\t     prob_prolog.to_reg_br_prob_base (),\n-\t\t\t\t     REG_BR_PROB_BASE);\n-\t  scale_loop_profile (prolog, prob_prolog.to_reg_br_prob_base (),\n-\t\t\t      bound_prolog);\n+\t  scale_bbs_frequencies (&bb_after_prolog, 1, prob_prolog);\n+\t  scale_loop_profile (prolog, prob_prolog, bound_prolog);\n \t}\n       /* Update init address of DRs.  */\n       vect_update_inits_of_drs (loop_vinfo, niters_prolog);\n@@ -1850,10 +1845,15 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t  guard_to->frequency = guard_bb->frequency;\n \t  guard_to->count = guard_bb->count;\n \t  single_succ_edge (guard_to)->count = guard_to->count;\n-\t  /* Scale probability of epilog loop back.  */\n+\t  /* Scale probability of epilog loop back.\n+\t     FIXME: We should avoid scaling down and back up.  Profile may\n+\t     get lost if we scale down to 0.  */\n \t  int scale_up = REG_BR_PROB_BASE * REG_BR_PROB_BASE\n \t\t\t / prob_vector.to_reg_br_prob_base ();\n-\t  scale_loop_frequencies (epilog, scale_up, REG_BR_PROB_BASE);\n+\t  basic_block *bbs = get_loop_body (loop);\n+\t  scale_bbs_frequencies_int (bbs, loop->num_nodes, scale_up,\n+\t\t\t\t     REG_BR_PROB_BASE);\n+\t  free (bbs);\n \t}\n \n       basic_block bb_before_epilog = loop_preheader_edge (epilog)->src;\n@@ -1891,11 +1891,9 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t    {\n \t      prob_epilog = prob_vector * prob_epilog + prob_vector.invert ();\n \n-\t      scale_bbs_frequencies_int (&bb_before_epilog, 1,\n-\t\t\t\t\t prob_epilog.to_reg_br_prob_base (),\n-\t\t\t\t\t REG_BR_PROB_BASE);\n+\t      scale_bbs_frequencies (&bb_before_epilog, 1, prob_epilog);\n \t    }\n-\t  scale_loop_profile (epilog, prob_epilog.to_reg_br_prob_base (), bound);\n+\t  scale_loop_profile (epilog, prob_epilog, bound);\n \t}\n       else\n \tslpeel_update_phi_nodes_for_lcssa (epilog);\n@@ -2138,7 +2136,7 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n   tree cond_expr = NULL_TREE;\n   gimple_seq cond_expr_stmt_list = NULL;\n   tree arg;\n-  unsigned prob = 4 * REG_BR_PROB_BASE / 5;\n+  profile_probability prob = profile_probability::likely ();\n   gimple_seq gimplify_stmt_list = NULL;\n   tree scalar_loop_iters = LOOP_VINFO_NITERS (loop_vinfo);\n   bool version_align = LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo);\n@@ -2177,12 +2175,8 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n       /* We don't want to scale SCALAR_LOOP's frequencies, we need to\n \t scale LOOP's frequencies instead.  */\n       nloop = loop_version (scalar_loop, cond_expr, &condition_bb,\n-\t\t\t    profile_probability::guessed_always ().apply_scale \n-\t\t\t\t(prob, REG_BR_PROB_BASE),\n-\t\t\t    profile_probability::guessed_always ().apply_scale\n-\t\t\t\t (REG_BR_PROB_BASE - prob, REG_BR_PROB_BASE),\n-\t\t\t    REG_BR_PROB_BASE, REG_BR_PROB_BASE - prob, true);\n-      scale_loop_frequencies (loop, prob, REG_BR_PROB_BASE);\n+\t\t\t    prob, prob.invert (), prob, prob.invert (), true);\n+      scale_loop_frequencies (loop, prob);\n       /* CONDITION_BB was created above SCALAR_LOOP's preheader,\n \t while we need to move it above LOOP's preheader.  */\n       e = loop_preheader_edge (loop);\n@@ -2209,11 +2203,7 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n     }\n   else\n     nloop = loop_version (loop, cond_expr, &condition_bb,\n-\t\t\t  profile_probability::guessed_always ().apply_scale \n-\t\t\t      (prob, REG_BR_PROB_BASE),\n-\t\t\t  profile_probability::guessed_always ().apply_scale\n-\t\t\t       (REG_BR_PROB_BASE - prob, REG_BR_PROB_BASE),\n-\t\t\t  prob, REG_BR_PROB_BASE - prob, true);\n+\t\t\t  prob, prob.invert (), prob, prob.invert (), true);\n \n   if (version_niter)\n     {"}, {"sha": "f75b943e1b57abd19eb8202f220da41d09bf88af", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=af2bbc51d3879b6e7a03b4dc2d4ab017a98270ba", "patch": "@@ -7118,16 +7118,14 @@ scale_profile_for_vect_loop (struct loop *loop, unsigned vf)\n     }\n   if (freq_h > 0)\n     {\n-      gcov_type scale;\n+      profile_probability p;\n \n       /* Avoid dropping loop body profile counter to 0 because of zero count\n \t in loop's preheader.  */\n       if (!(freq_e > profile_count::from_gcov_type (1)))\n        freq_e = profile_count::from_gcov_type (1);\n-      /* This should not overflow.  */\n-      scale = freq_e.apply_scale (new_est_niter + 1, 1).probability_in (freq_h)\n-\t\t\t.to_reg_br_prob_base ();\n-      scale_loop_frequencies (loop, scale, REG_BR_PROB_BASE);\n+      p = freq_e.apply_scale (new_est_niter + 1, 1).probability_in (freq_h);\n+      scale_loop_frequencies (loop, p);\n     }\n \n   basic_block exit_bb = single_pred (loop->latch);"}]}