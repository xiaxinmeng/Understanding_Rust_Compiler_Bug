{"sha": "848cf1e0f0ca447b2f44a8a0c7637e7d65931c69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ4Y2YxZTBmMGNhNDQ3YjJmNDRhOGEwYzc2MzdlN2Q2NTkzMWM2OQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-07-18T15:32:21Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-07-18T15:32:21Z"}, "message": "decl.c (lookup_nested_type): Remove.\n\n\t* decl.c (lookup_nested_type): Remove.\n\t(pushtag): Don't call it.\n\nFrom-SVN: r28166", "tree": {"sha": "5b452d1a564d5d82914bb48d480b5714e206d3e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b452d1a564d5d82914bb48d480b5714e206d3e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/848cf1e0f0ca447b2f44a8a0c7637e7d65931c69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/848cf1e0f0ca447b2f44a8a0c7637e7d65931c69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/848cf1e0f0ca447b2f44a8a0c7637e7d65931c69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/848cf1e0f0ca447b2f44a8a0c7637e7d65931c69/comments", "author": null, "committer": null, "parents": [{"sha": "bdfdb7495bc2eb289de6692941ef8e3fd1eff374", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdfdb7495bc2eb289de6692941ef8e3fd1eff374", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdfdb7495bc2eb289de6692941ef8e3fd1eff374"}], "stats": {"total": 107, "additions": 32, "deletions": 75}, "files": [{"sha": "b7f0458c24564770991ba08a251a69ec872e4367", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848cf1e0f0ca447b2f44a8a0c7637e7d65931c69/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848cf1e0f0ca447b2f44a8a0c7637e7d65931c69/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=848cf1e0f0ca447b2f44a8a0c7637e7d65931c69", "patch": "@@ -1,3 +1,8 @@\n+1999-07-18  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* decl.c (lookup_nested_type): Remove.\n+\t(pushtag): Don't call it.\n+\n Sat Jul 17 23:51:30 1999  Jeffrey A Law  (law@cygnus.com)\n \n         * Makefile.in (INTERFACE): Bump to 2."}, {"sha": "21ddd1def202dea35928256760ca5dce06eba940", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 16, "deletions": 75, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848cf1e0f0ca447b2f44a8a0c7637e7d65931c69/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848cf1e0f0ca447b2f44a8a0c7637e7d65931c69/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=848cf1e0f0ca447b2f44a8a0c7637e7d65931c69", "patch": "@@ -132,7 +132,6 @@ static struct stack_level *decl_stack;\n #endif\n \n static tree grokparms\t\t\t\tPROTO((tree, int));\n-static tree lookup_nested_type\t\t\tPROTO((tree, tree));\n static const char *redeclaration_error_message\tPROTO((tree, tree));\n \n static struct stack_level *push_decl_level PROTO((struct stack_level *,\n@@ -2867,9 +2866,8 @@ pushtag (name, type, globalize)\n       if (IDENTIFIER_TYPE_VALUE (name) != type)\n         {\n           register tree d = NULL_TREE;\n-\t  int newdecl = 0, in_class = 0;\n+\t  int in_class = 0;\n \t  tree context;\n-\t  tree c_decl = NULL_TREE;\n \n \t  context = type ? TYPE_CONTEXT (type) : NULL_TREE;\n \t  if (! context)\n@@ -2885,31 +2883,19 @@ pushtag (name, type, globalize)\n \t\t   containing the local class, not the namespace scope.  */\n \t\tcontext = hack_decl_function_context (get_type_decl (cs));\n \t    }\n-\t  if (context)\n-\t    c_decl = TREE_CODE (context) == FUNCTION_DECL\n-\t      ? context : TYPE_MAIN_DECL (context);\n-\n \t  if (!context)\n \t    context = current_namespace;\n \n \t  if ((b->pseudo_global && b->level_chain->parm_flag == 2)\n \t      || b->parm_flag == 2)\n \t    in_class = 1;\n-\t  else\n-\t    d = lookup_nested_type (type, c_decl);\n \n-\t  if (d == NULL_TREE)\n-\t    {\n-\t      newdecl = 1;\n-\t      d = build_decl (TYPE_DECL, name, type);\n-\t      if (current_lang_name == lang_name_java)\n-\t\tTYPE_FOR_JAVA (type) = 1;\n-\t      SET_DECL_ARTIFICIAL (d);\n-\t      if (! in_class)\n-\t\tset_identifier_type_value_with_scope (name, type, b);\n-\t    }\n-\t  else\n-\t    d = TYPE_MAIN_DECL (d);\n+\t  d = build_decl (TYPE_DECL, name, type);\n+\t  if (current_lang_name == lang_name_java)\n+\t    TYPE_FOR_JAVA (type) = 1;\n+\t  SET_DECL_ARTIFICIAL (d);\n+\t  if (! in_class)\n+\t    set_identifier_type_value_with_scope (name, type, b);\n \n \t  TYPE_NAME (type) = d;\n \t  DECL_CONTEXT (d) = FROB_CONTEXT (context);\n@@ -2919,7 +2905,7 @@ pushtag (name, type, globalize)\n \n \t  if (b->parm_flag == 2)\n \t    {\n-\t      if (newdecl && !PROCESSING_REAL_TEMPLATE_DECL_P ())\n+\t      if (!PROCESSING_REAL_TEMPLATE_DECL_P ())\n \t\t/* Put this TYPE_DECL on the TYPE_FIELDS list for the\n \t\t   class.  But if it's a member template class, we\n \t\t   want the TEMPLATE_DECL, not the TYPE_DECL, so this\n@@ -2931,17 +2917,14 @@ pushtag (name, type, globalize)\n \t  else\n \t    d = pushdecl_with_scope (d, b);\n \n-\t  if (newdecl)\n-\t    {\n-\t      if (ANON_AGGRNAME_P (name))\n-\t\tDECL_IGNORED_P (d) = 1;\n-\n-\t      TYPE_CONTEXT (type) = DECL_CONTEXT (d);\n-\t      DECL_ASSEMBLER_NAME (d) = DECL_NAME (d);\n-\t      if (!uses_template_parms (type))\n-\t\tDECL_ASSEMBLER_NAME (d)\n-\t\t  = get_identifier (build_overload_name (type, 1, 1));\n-\t    }\n+\t  if (ANON_AGGRNAME_P (name))\n+\t    DECL_IGNORED_P (d) = 1;\n+\n+\t  TYPE_CONTEXT (type) = DECL_CONTEXT (d);\n+\t  DECL_ASSEMBLER_NAME (d) = DECL_NAME (d);\n+\t  if (!uses_template_parms (type))\n+\t    DECL_ASSEMBLER_NAME (d)\n+\t      = get_identifier (build_overload_name (type, 1, 1));\n         }\n       if (b->parm_flag == 2)\n \t{\n@@ -5301,48 +5284,6 @@ lookup_tag_reverse (type, name)\n   return NULL_TREE;\n }\n \f\n-/* Lookup TYPE in CONTEXT (a chain of nested types or a FUNCTION_DECL).\n-   Return the type value, or NULL_TREE if not found.  */\n-\n-static tree\n-lookup_nested_type (type, context)\n-     tree type;\n-     tree context;\n-{\n-  if (context == NULL_TREE)\n-    return NULL_TREE;\n-  while (context)\n-    {\n-      switch (TREE_CODE (context))\n-\t{\n-\tcase TYPE_DECL:\n-\t  {\n-\t    tree ctype = TREE_TYPE (context);\n-\t    tree match = value_member (type, CLASSTYPE_TAGS (ctype));\n-\t    if (match)\n-\t      return TREE_VALUE (match);\n-\t    context = DECL_CONTEXT (context);\n-\n-\t    /* When we have a nested class whose member functions have\n-\t       local types (e.g., a set of enums), we'll arrive here\n-\t       with the DECL_CONTEXT as the actual RECORD_TYPE node for\n-\t       the enclosing class.  Instead, we want to make sure we\n-\t       come back in here with the TYPE_DECL, not the RECORD_TYPE.  */\n-\t    if (context && TREE_CODE (context) == RECORD_TYPE)\n-\t      context = TREE_CHAIN (context);\n-\t  }\n-\t  break;\n-\tcase FUNCTION_DECL:\n-\t  if (TYPE_NAME (type) && TYPE_IDENTIFIER (type))\n-\t    return lookup_name (TYPE_IDENTIFIER (type), 1);\n-\t  return NULL_TREE;\n-\tdefault:\n-\t  my_friendly_abort (12);\n-\t}\n-    }\n-  return NULL_TREE;\n-}\n-\n /* Look up NAME in the NAMESPACE.  */\n \n tree"}, {"sha": "624502373b64a08121b7f03db54dcde2aa75b811", "filename": "gcc/testsuite/g++.old-deja/g++.ns/crash4.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848cf1e0f0ca447b2f44a8a0c7637e7d65931c69/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ns%2Fcrash4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848cf1e0f0ca447b2f44a8a0c7637e7d65931c69/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ns%2Fcrash4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ns%2Fcrash4.C?ref=848cf1e0f0ca447b2f44a8a0c7637e7d65931c69", "patch": "@@ -0,0 +1,11 @@\n+// Build don't link:\n+// Origin: Geoffrey Furnish <furnish@actel.com>\n+\n+namespace N {\n+\n+    template<class T> class C\n+    {\n+        template<class U> friend class C;\n+    };\n+\n+}"}]}