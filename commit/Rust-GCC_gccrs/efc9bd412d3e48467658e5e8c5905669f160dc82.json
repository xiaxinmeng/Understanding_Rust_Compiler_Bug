{"sha": "efc9bd412d3e48467658e5e8c5905669f160dc82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZjOWJkNDEyZDNlNDg0Njc2NThlNWU4YzU5MDU2NjlmMTYwZGM4Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-05-19T22:27:28Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-05-19T22:27:28Z"}, "message": "cse.c (cse_basic_block): Only call find_reg_note if REG_NOTES not 0.\n\n\t* cse.c (cse_basic_block): Only call find_reg_note if REG_NOTES not 0.\n\t* reload.c (find_equiv_reg): Likewise.\n\t* alias.c (init_alias_analysis): Likewise.\n\tOnly call prologue_epilogue_contains on insns.\n\t* basic-block.h (REG_SET_TO_HARD_REG_SET): Call new function.\n\t* bb-reorder.c (hard-reg-set.h): Include earlier.\n\t* haifa-sched.c (hard-reg-set.h): Likewise.\n\t* ifcvt.c (hard-reg-set.h): Likewise.\n\t* local-alloc.c (hard-reg-set.h): Likewise.\n\t* loop.c (hard-reg-set.h): Likewise.\n\t* predict.c (hard-reg-set.h): Likewise.\n\t* regrename.c (hard-reg-set.h): Likewise.\n\t* flow.c (hard-reg-set.h): Likewise.\n\t(reg_set_to_hard_reg_set): New function.\n\t* bitmap.c (regs.h, basic-block.h): No longer include.\n\t(bitmap.h): Now include.\n\t* conflict.c (hard-reg-set.h): Include.\n\t* profile.c (hard-reg-set.h): Likewise.\n\t* print-rtl.c (hard-reg-set.h): Likewise.\n\t* sbitmap.c (hard-reg-set.h): Likewise.\n\t* toplev.c (hard-reg-set.h): Likewise.\n\t* unroll.c (hard-reg-set.h, basic-block.h): Likewise.\n\t* hard-reg-set.h (reg_names): Now constant.\n\t* regs.h (reg_names): Likewise.\n\t* regclass.c (reg_names): Likewise.\n\t* loop.h (basic-block.h): No longer include.\n\t(bitmap.h): Now include.\n\t* reload1.c (order_regs_for_reload): Avoid loop over reg sets.\n\t* Makefile.in (LOOP_H, sbitmap.o, profile.o): Reflect above changes.\n\t(toplev.o, print-rtl.o, conflict.o, unroll.o, bitmap.o): Likewise.\n\nFrom-SVN: r34039", "tree": {"sha": "8f88314b754c91c4f21319edf9d007c274a0a151", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f88314b754c91c4f21319edf9d007c274a0a151"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efc9bd412d3e48467658e5e8c5905669f160dc82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efc9bd412d3e48467658e5e8c5905669f160dc82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efc9bd412d3e48467658e5e8c5905669f160dc82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efc9bd412d3e48467658e5e8c5905669f160dc82/comments", "author": null, "committer": null, "parents": [{"sha": "c280e37af477f21bc3503b2ae3598118d58be01e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c280e37af477f21bc3503b2ae3598118d58be01e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c280e37af477f21bc3503b2ae3598118d58be01e"}], "stats": {"total": 240, "additions": 159, "deletions": 81}, "files": [{"sha": "2d140d8713b92b9b6b4b393dba5afc5d03e61872", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -1,3 +1,36 @@\n+Fri May 19 18:16:31 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* cse.c (cse_basic_block): Only call find_reg_note if REG_NOTES not 0.\n+\t* reload.c (find_equiv_reg): Likewise.\n+\t* alias.c (init_alias_analysis): Likewise.\n+\tOnly call prologue_epilogue_contains on insns.\n+\t* basic-block.h (REG_SET_TO_HARD_REG_SET): Call new function.\n+\t* bb-reorder.c (hard-reg-set.h): Include earlier.\n+\t* haifa-sched.c (hard-reg-set.h): Likewise.\n+\t* ifcvt.c (hard-reg-set.h): Likewise.\n+\t* local-alloc.c (hard-reg-set.h): Likewise.\n+\t* loop.c (hard-reg-set.h): Likewise.\n+\t* predict.c (hard-reg-set.h): Likewise.\n+\t* regrename.c (hard-reg-set.h): Likewise.\n+\t* flow.c (hard-reg-set.h): Likewise.\n+\t(reg_set_to_hard_reg_set): New function.\n+\t* bitmap.c (regs.h, basic-block.h): No longer include.\n+\t(bitmap.h): Now include.\n+\t* conflict.c (hard-reg-set.h): Include.\n+\t* profile.c (hard-reg-set.h): Likewise.\n+\t* print-rtl.c (hard-reg-set.h): Likewise.\n+\t* sbitmap.c (hard-reg-set.h): Likewise.\n+\t* toplev.c (hard-reg-set.h): Likewise.\n+\t* unroll.c (hard-reg-set.h, basic-block.h): Likewise.\n+\t* hard-reg-set.h (reg_names): Now constant.\n+\t* regs.h (reg_names): Likewise.\n+\t* regclass.c (reg_names): Likewise.\n+\t* loop.h (basic-block.h): No longer include.\n+\t(bitmap.h): Now include.\n+\t* reload1.c (order_regs_for_reload): Avoid loop over reg sets.\n+\t* Makefile.in (LOOP_H, sbitmap.o, profile.o): Reflect above changes.\n+\t(toplev.o, print-rtl.o, conflict.o, unroll.o, bitmap.o): Likewise.\n+\n 2000-05-19  Jan Hubicka  <jh@suse.cz>\n \t    Richard Henderson  <rth@cygnus.com>\n "}, {"sha": "bee8c2aa54b9f6f6aebe6fb8c6ae5dbf3c92db2b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -771,7 +771,7 @@ RECOG_H = recog.h\n EXPR_H = expr.h insn-codes.h\n REGS_H = regs.h varray.h $(MACHMODE_H)\n INTEGRATE_H = integrate.h varray.h\n-LOOP_H = loop.h varray.h basic-block.h\n+LOOP_H = loop.h varray.h bitmap.h\n GCC_H = gcc.h version.h\n GGC_H = ggc.h varray.h\n TIMEVAR_H = timevar.h timevar.def\n@@ -1111,7 +1111,8 @@ c-iterate.o: c-iterate.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) c-tree.h \\\n mbchar.o: mbchar.c $(CONFIG_H) system.h mbchar.h\n graph.o: graph.c $(CONFIG_H) system.h toplev.h flags.h output.h $(RTL_H) \\\n     function.h hard-reg-set.h $(BASIC_BLOCK_H) graph.h\n-sbitmap.o: sbitmap.c $(CONFIG_H) system.h $(RTL_H) flags.h $(BASIC_BLOCK_H)\n+sbitmap.o: sbitmap.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h \\\n+    $(BASIC_BLOCK_H)\n \n COLLECT2_OBJS = collect2.o tlink.o hash.o intl.o underscore.o version.o\n collect2$(exeext): $(COLLECT2_OBJS) $(LIBDEPS)\n@@ -1235,15 +1236,16 @@ diagnostic.o : diagnostic.c diagnostic.h \\\n toplev.o : toplev.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) function.h \\\n    flags.h input.h insn-attr.h xcoffout.h defaults.h output.h \\\n    insn-codes.h insn-config.h intl.h $(RECOG_H) Makefile toplev.h dwarfout.h \\\n-   dwarf2out.h sdbout.h dbxout.h $(EXPR_H) $(BASIC_BLOCK_H) graph.h loop.h \\\n-   except.h regs.h $(TIMEVAR_H) $(lang_options_files)\n+   dwarf2out.h sdbout.h dbxout.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) \\\n+   graph.h loop.h  except.h regs.h $(TIMEVAR_H) $(lang_options_files)\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(MAYBE_USE_COLLECT2) \\\n \t  -DTARGET_NAME=\\\"$(target_alias)\\\" \\\n \t  -c `echo $(srcdir)/toplev.c | sed 's,^\\./,,'`\n \n rtl.o : rtl.c $(CONFIG_H) system.h $(RTL_H) bitmap.h $(GGC_H) toplev.h\n \n-print-rtl.o : print-rtl.c $(CONFIG_H) system.h $(RTL_H) $(BASIC_BLOCK_H)\n+print-rtl.o : print-rtl.c $(CONFIG_H) system.h $(RTL_H) hard-reg-set.h \\\n+    $(BASIC_BLOCK_H)\n rtlanal.o : rtlanal.c $(CONFIG_H) system.h $(RTL_H)\n errors.o : errors.c $(CONFIG_H) system.h errors.h\n \n@@ -1322,16 +1324,16 @@ lcm.o : lcm.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n ssa.o : ssa.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) $(BASIC_BLOCK_H) \\\n    output.h insn-config.h\n conflict.o : conflict.c $(CONFIG_H) system.h $(OBSTACK_H) $(HASHTAB_H) \\\n-   $(RTL_H) $(BASIC_BLOCK_H)\n-profile.o : profile.c $(CONFIG_H) system.h $(RTL_H) flags.h insn-flags.h \\\n-   gcov-io.h $(TREE_H) output.h $(REGS_H) toplev.h function.h insn-config.h \\\n-   $(GGC_H)\n+   $(RTL_H) hard-reg-set.h $(BASIC_BLOCK_H)\n+profile.o : profile.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n+   insn-flags.h insn-config.h output.h $(REGS_H) $(EXPR_H) function.h \\\n+   gcov-io.h toplev.h $(GGC_H) hard-reg-set.h $(BASIC_BLOCK_H)\n loop.o : loop.c $(CONFIG_H) system.h $(RTL_H) flags.h $(LOOP_H) insn-config.h \\\n    insn-flags.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) real.h \\\n    $(BASIC_BLOCK_H) function.h toplev.h varray.h except.h cselib.h\n unroll.o : unroll.c $(CONFIG_H) system.h $(RTL_H) insn-config.h function.h \\\n    $(INTEGRATE_H) $(REGS_H) $(RECOG_H) flags.h $(EXPR_H) $(LOOP_H) toplev.h \\\n-   varray.h \n+   hard-reg-set.h varray.h $(BASIC_BLOCK_H)\n flow.o : flow.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n    insn-flags.h function.h except.h $(EXPR_H)\n@@ -1685,7 +1687,7 @@ $(HOST_PREFIX_1)print-rtl.o: $(srcdir)/print-rtl.c $(CONFIG_H) \\\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)print-rtl.c\n \n $(HOST_PREFIX_1)bitmap.o: $(srcdir)/bitmap.c $(CONFIG_H) system.h $(RTL_H) \\\n-  flags.h $(BASIC_BLOCK_H) $(REGS_H)\n+  flags.h bitmap.h\n \trm -f $(HOST_PREFIX)bitmap.c\n \tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/bitmap.c > $(HOST_PREFIX)bitmap.c\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)bitmap.c"}, {"sha": "56dfc9d63874386845dfe22207205fc6435c0408", "filename": "gcc/alias.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -1704,19 +1704,22 @@ init_alias_analysis ()\n       /* Walk the insns adding values to the new_reg_base_value array.  */\n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \t{\n-#if defined (HAVE_prologue) || defined (HAVE_epilogue)\n-\t  if (prologue_epilogue_contains (insn))\n-\t    continue;\n-#endif\n \t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t    {\n \t      rtx note, set;\n+\n+#if defined (HAVE_prologue) || defined (HAVE_epilogue)\n+\t      if (prologue_epilogue_contains (insn))\n+\t\tcontinue;\n+#endif\n+\n \t      /* If this insn has a noalias note, process it,  Otherwise,\n \t         scan for sets.  A simple set will have no side effects\n \t         which could change the base value of any other register. */\n \n \t      if (GET_CODE (PATTERN (insn)) == SET\n-\t\t  && (find_reg_note (insn, REG_NOALIAS, NULL_RTX)))\n+\t\t  && REG_NOTES (insn) != 0\n+\t\t  && find_reg_note (insn, REG_NOALIAS, NULL_RTX))\n \t\trecord_set (SET_DEST (PATTERN (insn)), NULL_RTX, NULL);\n \t      else\n \t\tnote_stores (PATTERN (insn), record_set, NULL);\n@@ -1726,6 +1729,7 @@ init_alias_analysis ()\n \t      if (set != 0\n \t\t  && GET_CODE (SET_DEST (set)) == REG\n \t\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n+\t\t  && REG_NOTES (insn) != 0\n \t\t  && (((note = find_reg_note (insn, REG_EQUAL, 0)) != 0\n \t\t       && REG_N_SETS (REGNO (SET_DEST (set))) == 1)\n \t\t      || (note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != 0)"}, {"sha": "fcdab68fe6ec08499b2da48e6035ea95ad2d17f1", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -70,13 +70,11 @@ typedef bitmap regset;\n #define REGNO_REG_SET_P(TO, REG) bitmap_bit_p (TO, REG)\n \n /* Copy the hard registers in a register set to the hard register set.  */\n+extern void reg_set_to_hard_reg_set PARAMS ((HARD_REG_SET *, bitmap));\n #define REG_SET_TO_HARD_REG_SET(TO, FROM)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  int i_;\t\t\t\t\t\t\t\t\\\n   CLEAR_HARD_REG_SET (TO);\t\t\t\t\t\t\\\n-  for (i_ = 0; i_ < FIRST_PSEUDO_REGISTER; i_++)\t\t\t\\\n-    if (REGNO_REG_SET_P (FROM, i_))\t\t\t\t\t\\\n-      SET_HARD_REG_BIT (TO, i_);\t\t\t\t\t\\\n+  reg_set_to_hard_reg_set (&TO, FROM);\t\t\t\t\t\\\n } while (0)\n \n /* Loop over all registers in REGSET, starting with MIN, setting REGNUM to the"}, {"sha": "ac1b990717cacd3c7bfb68ad3b2478d2aaa1e167", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -29,10 +29,10 @@\n #include \"tree.h\"\n #include \"rtl.h\"\n #include \"tm_p.h\"\n+#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"insn-config.h\"\n #include \"regs.h\"\n-#include \"hard-reg-set.h\"\n #include \"flags.h\"\n #include \"output.h\"\n #include \"function.h\""}, {"sha": "d1588d8b7ebd190303e3f734e38eb6fa0e57b58e", "filename": "gcc/bitmap.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -23,8 +23,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"flags.h\"\n #include \"obstack.h\"\n-#include \"regs.h\"\n-#include \"basic-block.h\"\n+#include \"bitmap.h\"\n \n /* Obstack to allocate bitmap elements from.  */\n static struct obstack bitmap_obstack;"}, {"sha": "f8e860930581c7325f7668867eda9d0998f01f5f", "filename": "gcc/conflict.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fconflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fconflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconflict.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -30,6 +30,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"hashtab.h\"\n #include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n \n /* Use malloc to allocate obstack chunks.  */"}, {"sha": "9f2f007fb76409f127ee37ece69e9a505629d1bb", "filename": "gcc/cse.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -7017,10 +7017,13 @@ cse_basic_block (from, to, next_branch, around_loop)\n \t     its destination is the result of the block and hence should be\n \t     recorded.  */\n \n-\t  if ((p = find_reg_note (insn, REG_LIBCALL, NULL_RTX)))\n-\t    libcall_insn = XEXP (p, 0);\n-\t  else if (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-\t    libcall_insn = NULL_RTX;\n+\t  if (REG_NOTES (insn) != 0)\n+\t    {\n+\t      if ((p = find_reg_note (insn, REG_LIBCALL, NULL_RTX)))\n+\t\tlibcall_insn = XEXP (p, 0);\n+\t      else if (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n+\t\tlibcall_insn = 0;\n+\t    }\n \n \t  cse_insn (insn, libcall_insn);\n \t}"}, {"sha": "8c3eb830fe9963f7670bb7ff44c8fcc2e6588259", "filename": "gcc/flow.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -124,10 +124,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"rtl.h\"\n #include \"tm_p.h\"\n+#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"insn-config.h\"\n #include \"regs.h\"\n-#include \"hard-reg-set.h\"\n #include \"flags.h\"\n #include \"output.h\"\n #include \"function.h\"\n@@ -7483,6 +7483,7 @@ flow_loops_find (loops)\n \n \n /* Return non-zero if edge E enters header of LOOP from outside of LOOP.  */\n+\n int\n flow_loop_outside_edge_p (loop, e)\n      const struct loop *loop;\n@@ -7496,6 +7497,7 @@ flow_loop_outside_edge_p (loop, e)\n \n \n /* Clear LOG_LINKS fields of insns in a chain.  */\n+\n void\n clear_log_links (insns)\n      rtx insns;\n@@ -7505,3 +7507,25 @@ clear_log_links (insns)\n     if (GET_RTX_CLASS (GET_CODE (i)) == 'i')\n       LOG_LINKS (i) = 0;\n }\n+\n+/* Given a register bitmap, turn on the bits in a HARD_REG_SET that\n+   correspond to the hard registers, if any, set in that map.  This\n+   could be done far more efficiently by having all sorts of special-cases\n+   with moving single words, but probably isn't worth the trouble.  */\n+\n+void\n+reg_set_to_hard_reg_set (to, from)\n+     HARD_REG_SET *to;\n+     bitmap from;\n+{\n+  int i;\n+\n+  EXECUTE_IF_SET_IN_BITMAP\n+    (from, 0, i,\n+     {\n+       if (i >= FIRST_PSEUDO_REGISTER)\n+\t return;\n+       SET_HARD_REG_BIT (*to, i);\n+     });\n+}\n+"}, {"sha": "616db55b21797f2fc0616acaf8687e1ea35d2e28", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -161,10 +161,10 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"rtl.h\"\n #include \"tm_p.h\"\n+#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"regs.h\"\n #include \"function.h\"\n-#include \"hard-reg-set.h\"\n #include \"flags.h\"\n #include \"insn-config.h\"\n #include \"insn-attr.h\""}, {"sha": "6f1972f5620a0d8dd089f6b06b8b7fc26c5096e1", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -471,4 +471,4 @@ extern int n_non_fixed_regs;\n \n /* Vector indexed by hardware reg giving its name.  */\n \n-extern const char *reg_names[FIRST_PSEUDO_REGISTER];\n+extern const char * const reg_names[FIRST_PSEUDO_REGISTER];"}, {"sha": "d2bb6bd57261602d31e08585d8ffc98da62ecb94", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -27,10 +27,10 @@\n #include \"flags.h\"\n #include \"insn-config.h\"\n #include \"recog.h\"\n+#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"expr.h\"\n #include \"output.h\"\n-#include \"hard-reg-set.h\"\n #include \"tm_p.h\"\n \n "}, {"sha": "bd6492980ea92c9f424dc4fa1145136076fad616", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -65,10 +65,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"tm_p.h\"\n #include \"flags.h\"\n+#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"regs.h\"\n #include \"function.h\"\n-#include \"hard-reg-set.h\"\n #include \"insn-config.h\"\n #include \"insn-attr.h\"\n #include \"recog.h\""}, {"sha": "df3ee526a68527eff9313ac6ae8eac1ca95c8215", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -42,11 +42,11 @@ Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"function.h\"\n #include \"expr.h\"\n+#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"insn-config.h\"\n #include \"insn-flags.h\"\n #include \"regs.h\"\n-#include \"hard-reg-set.h\"\n #include \"recog.h\"\n #include \"flags.h\"\n #include \"real.h\""}, {"sha": "3b8cb7a14e0aab58b15b98bc2db8c40d6e7f7508", "filename": "gcc/loop.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -19,7 +19,8 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"varray.h\"\n-#include \"basic-block.h\"\n+#include \"bitmap.h\"\n+\n /* Flags passed to loop_optimize.  */\n #define LOOP_UNROLL 1\n #define LOOP_BCT 2"}, {"sha": "837f2d7f52020457e8547d439b961b6098402e22", "filename": "gcc/predict.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -26,6 +26,7 @@\n        Wu and Larus; MICRO-27.\n    [3] \"Corpus-based Static Branch Prediction\"\n        Calder, Grunwald, Lindsay, Martin, Mozer, and Zorn; PLDI '95.\n+\n */\n \n \n@@ -34,10 +35,10 @@\n #include \"tree.h\"\n #include \"rtl.h\"\n #include \"tm_p.h\"\n+#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"insn-config.h\"\n #include \"regs.h\"\n-#include \"hard-reg-set.h\"\n #include \"flags.h\"\n #include \"output.h\"\n #include \"function.h\""}, {"sha": "544e54408569e67373a91751c1a4b826b2cf4cdc", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -25,9 +25,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"real.h\"\n #include \"flags.h\"\n+#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n \n-\n /* How to print out a register name.\n    We don't use PRINT_REG because some definitions of PRINT_REG\n    don't work here.  */"}, {"sha": "627d6e403dcf5c621447eefb9fb4bac401e9df9f", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -46,6 +46,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"gcov-io.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n+#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n \n "}, {"sha": "f4ed192f4f520b225a33c666da31d0a9b02aaff7", "filename": "gcc/regclass.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -162,7 +162,7 @@ enum reg_class reg_class_superunion[N_REG_CLASSES][N_REG_CLASSES];\n \n /* Array containing all of the register names */\n \n-const char *reg_names[] = REGISTER_NAMES;\n+const char * const reg_names[] = REGISTER_NAMES;\n \n /* For each hard register, the widest mode object that it can contain.\n    This will be a MODE_INT mode if the register can hold integers.  Otherwise"}, {"sha": "d2afeeca26cc33be1f2a04ca16142a8a635d4dda", "filename": "gcc/regrename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -22,10 +22,10 @@\n #include \"system.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"insn-config.h\"\n #include \"regs.h\"\n-#include \"hard-reg-set.h\"\n #include \"flags.h\"\n #include \"output.h\"\n #include \"function.h\""}, {"sha": "0f35ae66c8b1a458d3afd324540362ad4e4acce2", "filename": "gcc/regs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -137,7 +137,7 @@ extern char regs_ever_live[FIRST_PSEUDO_REGISTER];\n \n /* Vector indexed by hardware reg giving its name.  */\n \n-extern const char *reg_names[FIRST_PSEUDO_REGISTER];\n+extern const char * const reg_names[FIRST_PSEUDO_REGISTER];\n \n /* For each hard register, the widest mode object that it can contain.\n    This will be a MODE_INT mode if the register can hold integers.  Otherwise"}, {"sha": "e94a3037be4a9c2a538b73ceae5fbebf2edf797a", "filename": "gcc/reload.c", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -6032,27 +6032,30 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \t\t  /* If we are looking for a constant,\n \t\t     and something equivalent to that constant was copied\n \t\t     into a reg, we can use that reg.  */\n-\t\t  || (goal_const && (tem = find_reg_note (p, REG_EQUIV,\n-\t\t\t\t\t\t\t  NULL_RTX))\n-\t\t      && rtx_equal_p (XEXP (tem, 0), goal)\n-\t\t      && (valueno = true_regnum (valtry = SET_DEST (pat))) >= 0)\n-\t\t  || (goal_const && (tem = find_reg_note (p, REG_EQUIV,\n-\t\t\t\t\t\t\t  NULL_RTX))\n-\t\t      && GET_CODE (SET_DEST (pat)) == REG\n-\t\t      && GET_CODE (XEXP (tem, 0)) == CONST_DOUBLE\n-\t\t      && GET_MODE_CLASS (GET_MODE (XEXP (tem, 0))) == MODE_FLOAT\n-\t\t      && GET_CODE (goal) == CONST_INT\n-\t\t      && 0 != (goaltry = operand_subword (XEXP (tem, 0), 0, 0,\n+\t\t  || (goal_const && REG_NOTES (p) != 0\n+\t\t      && (tem = find_reg_note (p, REG_EQUIV, NULL_RTX))\n+\t\t      && ((rtx_equal_p (XEXP (tem, 0), goal)\n+\t\t\t   && (valueno\n+\t\t\t       = true_regnum (valtry = SET_DEST (pat))) >= 0)\n+\t\t\t  || (GET_CODE (SET_DEST (pat)) == REG\n+\t\t\t      && GET_CODE (XEXP (tem, 0)) == CONST_DOUBLE\n+\t\t\t      && (GET_MODE_CLASS (GET_MODE (XEXP (tem, 0)))\n+\t\t\t\t  == MODE_FLOAT)\n+\t\t\t      && GET_CODE (goal) == CONST_INT\n+\t\t\t      && 0 != (goaltry\n+\t\t\t\t       = operand_subword (XEXP (tem, 0), 0, 0,\n \t\t\t\t\t\t\t  VOIDmode))\n-\t\t      && rtx_equal_p (goal, goaltry)\n-\t\t      && (valtry = operand_subword (SET_DEST (pat), 0, 0,\n-\t\t\t\t\t\t    VOIDmode))\n-\t\t      && (valueno = true_regnum (valtry)) >= 0)\n+\t\t\t      && rtx_equal_p (goal, goaltry)\n+\t\t\t      && (valtry\n+\t\t\t\t  = operand_subword (SET_DEST (pat), 0, 0,\n+\t\t\t\t\t\t     VOIDmode))\n+\t\t\t      && (valueno = true_regnum (valtry)) >= 0)))\n \t\t  || (goal_const && (tem = find_reg_note (p, REG_EQUIV,\n \t\t\t\t\t\t\t  NULL_RTX))\n \t\t      && GET_CODE (SET_DEST (pat)) == REG\n \t\t      && GET_CODE (XEXP (tem, 0)) == CONST_DOUBLE\n-\t\t      && GET_MODE_CLASS (GET_MODE (XEXP (tem, 0))) == MODE_FLOAT\n+\t\t      && (GET_MODE_CLASS (GET_MODE (XEXP (tem, 0)))\n+\t\t\t  == MODE_FLOAT)\n \t\t      && GET_CODE (goal) == CONST_INT\n \t\t      && 0 != (goaltry = operand_subword (XEXP (tem, 0), 1, 0,\n \t\t\t\t\t\t\t  VOIDmode))\n@@ -6081,7 +6084,7 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \n   /* Don't try to re-use something that is killed in this insn.  We want\n      to be able to trust REG_UNUSED notes.  */\n-  if (find_reg_note (where, REG_UNUSED, value))\n+  if (REG_NOTES (where) != 0 && find_reg_note (where, REG_UNUSED, value))\n     return 0;\n \n   /* If we propose to get the value from the stack pointer or if GOAL is"}, {"sha": "3ff2b4555fc4a7687c53cb4835332e4bed43c3ec", "filename": "gcc/reload1.c", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -1210,6 +1210,7 @@ reload (first, global, dumpfile)\n    fatal_insn later.  We clear the corresponding regnos in the live\n    register sets to avoid this.\n    The whole thing is rather sick, I'm afraid.  */\n+\n static void\n maybe_fix_stack_asms ()\n {\n@@ -1512,29 +1513,29 @@ count_pseudo (reg)\n \n /* Calculate the SPILL_COST and SPILL_ADD_COST arrays and determine the\n    contents of BAD_SPILL_REGS for the insn described by CHAIN.  */\n+\n static void\n order_regs_for_reload (chain)\n      struct insn_chain *chain;\n {\n   register int i, j;\n+  HARD_REG_SET used_by_pseudos;\n+  HARD_REG_SET used_by_pseudos2;\n \n-  COPY_HARD_REG_SET (bad_spill_regs, bad_spill_regs_global);\n+  COPY_HARD_REG_SET (bad_spill_regs, fixed_reg_set);\n \n   memset (spill_cost, 0, sizeof spill_cost);\n   memset (spill_add_cost, 0, sizeof spill_add_cost);\n \n   /* Count number of uses of each hard reg by pseudo regs allocated to it\n-     and then order them by decreasing use.  */\n+     and then order them by decreasing use.  First exclude hard registers\n+     that are live in or across this insn.  */\n+\n+  REG_SET_TO_HARD_REG_SET (used_by_pseudos, &chain->live_throughout);\n+  REG_SET_TO_HARD_REG_SET (used_by_pseudos2, &chain->dead_or_set);\n+  IOR_HARD_REG_SET (bad_spill_regs, used_by_pseudos);\n+  IOR_HARD_REG_SET (bad_spill_regs, used_by_pseudos2);\n \n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      /* Test the various reasons why we can't use a register for\n-\t spilling in this insn.  */\n-      if (fixed_regs[i]\n-\t  || REGNO_REG_SET_P (&chain->live_throughout, i)\n-\t  || REGNO_REG_SET_P (&chain->dead_or_set, i))\n-\tSET_HARD_REG_BIT (bad_spill_regs, i);\n-    }\n   /* Now find out which pseudos are allocated to it, and update\n      hard_reg_n_uses.  */\n   CLEAR_REG_SET (&pseudos_counted);\n@@ -3517,20 +3518,21 @@ finish_spills (global, dumpfile)\n     else\n       spill_reg_order[i] = -1;\n \n-  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    if (REGNO_REG_SET_P (&spilled_pseudos, i))\n-      {\n-\t/* Record the current hard register the pseudo is allocated to in\n-\t   pseudo_previous_regs so we avoid reallocating it to the same\n-\t   hard reg in a later pass.  */\n-\tif (reg_renumber[i] < 0)\n-\t  abort ();\n-\tSET_HARD_REG_BIT (pseudo_previous_regs[i], reg_renumber[i]);\n-\t/* Mark it as no longer having a hard register home.  */\n-\treg_renumber[i] = -1;\n-\t/* We will need to scan everything again.  */\n-\tsomething_changed = 1;\n-      }\n+  EXECUTE_IF_SET_IN_REG_SET\n+    (&spilled_pseudos, FIRST_PSEUDO_REGISTER, i,\n+     {\n+       /* Record the current hard register the pseudo is allocated to in\n+\t  pseudo_previous_regs so we avoid reallocating it to the same\n+\t  hard reg in a later pass.  */\n+       if (reg_renumber[i] < 0)\n+\t abort ();\n+\n+       SET_HARD_REG_BIT (pseudo_previous_regs[i], reg_renumber[i]);\n+       /* Mark it as no longer having a hard register home.  */\n+       reg_renumber[i] = -1;\n+       /* We will need to scan everything again.  */\n+       something_changed = 1;\n+     });\n \n   /* Retry global register allocation if possible.  */\n   if (global)\n@@ -5062,6 +5064,7 @@ allocate_reload_reg (chain, r, last_reload)\n /* Initialize all the tables needed to allocate reload registers.\n    CHAIN is the insn currently being processed; SAVE_RELOAD_REG_RTX\n    is the array we use to restore the reg_rtx field for every reload.  */\n+\n static void\n choose_reload_regs_init (chain, save_reload_reg_rtx)\n      struct insn_chain *chain;\n@@ -5093,6 +5096,7 @@ choose_reload_regs_init (chain, save_reload_reg_rtx)\n     compute_use_by_pseudos (&reg_used_in_insn, &chain->live_throughout);\n     compute_use_by_pseudos (&reg_used_in_insn, &chain->dead_or_set);\n   }\n+\n   for (i = 0; i < reload_n_operands; i++)\n     {\n       CLEAR_HARD_REG_SET (reload_reg_used_in_output[i]);"}, {"sha": "e3f9a9fd74d4f2f022ae327b8080939dac98ac1f", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -22,6 +22,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"rtl.h\"\n #include \"flags.h\"\n+#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n \n /* Bitmap manipulation routines.  */"}, {"sha": "9f13b9a528d562183f5ee8c05dcc2a3969d2843e", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -54,6 +54,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"function.h\"\n #include \"toplev.h\"\n #include \"expr.h\"\n+#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"intl.h\"\n #include \"ggc.h\""}, {"sha": "f234a81490e07f845b311f3d6be6ab4c289071de", "filename": "gcc/unroll.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc9bd412d3e48467658e5e8c5905669f160dc82/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=efc9bd412d3e48467658e5e8c5905669f160dc82", "patch": "@@ -160,6 +160,8 @@ enum unroll_types { UNROLL_COMPLETELY, UNROLL_MODULO, UNROLL_NAIVE };\n #include \"expr.h\"\n #include \"loop.h\"\n #include \"toplev.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n \n /* This controls which loops are unrolled, and by how much we unroll\n    them.  */"}]}