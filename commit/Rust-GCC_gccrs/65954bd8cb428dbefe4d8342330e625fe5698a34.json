{"sha": "65954bd8cb428dbefe4d8342330e625fe5698a34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU5NTRiZDhjYjQyOGRiZWZlNGQ4MzQyMzMwZTYyNWZlNTY5OGEzNA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-03-22T22:47:07Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-03-22T22:47:07Z"}, "message": "i386.h (PREFERRED_STACK_BOUNDARY): Define.\n\n        * i386.h (PREFERRED_STACK_BOUNDARY): Define.\n        * i386.c (ix86_compute_frame_size): New function.\n        (ix86_prologue, ix86_epilogue): Use it.\n        * i386.h (INITIAL_ELIMINATION_OFFSET): Likewise.\n        * reload1.c: Provide default for PREFERRED_STACK_BOUNDARY.\n\nFrom-SVN: r25909", "tree": {"sha": "d8dc24a26f9c03f1b7eaccf483d3d5ca94317f2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8dc24a26f9c03f1b7eaccf483d3d5ca94317f2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65954bd8cb428dbefe4d8342330e625fe5698a34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65954bd8cb428dbefe4d8342330e625fe5698a34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65954bd8cb428dbefe4d8342330e625fe5698a34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65954bd8cb428dbefe4d8342330e625fe5698a34/comments", "author": null, "committer": null, "parents": [{"sha": "8af456c81af749f27bf88197a3a380b5f0d25b10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8af456c81af749f27bf88197a3a380b5f0d25b10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8af456c81af749f27bf88197a3a380b5f0d25b10"}], "stats": {"total": 125, "additions": 98, "deletions": 27}, "files": [{"sha": "b6d9332f3df431198318c41414d488c44d81ecd1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65954bd8cb428dbefe4d8342330e625fe5698a34/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65954bd8cb428dbefe4d8342330e625fe5698a34/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65954bd8cb428dbefe4d8342330e625fe5698a34", "patch": "@@ -1,3 +1,14 @@\n+Mon Mar 22 23:41:49 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* i386.h (PREFERRED_STACK_BOUNDARY): Define.\n+\n+Mon Mar 22 23:41:31 1999  John Wehle  (john@feith.com)\n+\n+\t* i386.c (ix86_compute_frame_size): New function.\n+\t(ix86_prologue, ix86_epilogue): Use it.\n+\t* i386.h (INITIAL_ELIMINATION_OFFSET): Likewise.\n+\t* reload1.c: Provide default for PREFERRED_STACK_BOUNDARY.\n+\n Mon Mar 22 18:06:59 1999  Jim Wilson  <wilson@cygnus.com>\n \n \t* mips/mips.h (TARGET_SWITCHES, TARGET_OPTIONS): Add option doc"}, {"sha": "a989cac66ecf76ff4d1bda70f0390199e2a0c55e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 65, "deletions": 16, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65954bd8cb428dbefe4d8342330e625fe5698a34/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65954bd8cb428dbefe4d8342330e625fe5698a34/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=65954bd8cb428dbefe4d8342330e625fe5698a34", "patch": "@@ -2077,6 +2077,62 @@ load_pic_register (do_rtl)\n     emit_insn (gen_blockage ());\n }\n \n+/* Compute the size of local storage taking into consideration the\n+   desired stack alignment which is to be maintained.  Also determine\n+   the number of registers saved below the local storage.  */\n+\n+HOST_WIDE_INT\n+ix86_compute_frame_size (size, nregs_on_stack)\n+     HOST_WIDE_INT size;\n+     int *nregs_on_stack;\n+{\n+  int limit;\n+  int nregs;\n+  int regno;\n+  int padding;\n+  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n+\t\t\t\t  || current_function_uses_const_pool);\n+  HOST_WIDE_INT total_size;\n+\n+  limit = frame_pointer_needed\n+\t  ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM;\n+\n+  nregs = 0;\n+\n+  for (regno = limit - 1; regno >= 0; regno--)\n+    if ((regs_ever_live[regno] && ! call_used_regs[regno])\n+\t|| (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n+      nregs++;\n+\n+  padding = 0;\n+  total_size = size + (nregs * UNITS_PER_WORD);\n+\n+#ifdef PREFERRED_STACK_BOUNDARY\n+  {\n+    int offset;\n+    int preferred_alignment = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n+\n+    offset = 4;\n+    if (frame_pointer_needed)\n+      offset += UNITS_PER_WORD;\n+\n+    total_size += offset;\n+    \n+    padding = ((total_size + preferred_alignment - 1)\n+\t       & -preferred_alignment) - total_size;\n+\n+    if (padding < (((offset + preferred_alignment - 1)\n+\t\t    & -preferred_alignment) - offset))\n+      padding += preferred_alignment;\n+  }\n+#endif\n+\n+  if (nregs_on_stack)\n+    *nregs_on_stack = nregs;\n+\n+  return size + padding;\n+}\n+\n static void\n ix86_prologue (do_rtl)\n      int do_rtl;\n@@ -2086,7 +2142,7 @@ ix86_prologue (do_rtl)\n   rtx xops[4];\n   int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n \t\t\t\t  || current_function_uses_const_pool);\n-  long tsize = get_frame_size ();\n+  HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (), (int *)0);\n   rtx insn;\n   int cfa_offset = INCOMING_FRAME_SP_OFFSET, cfa_store_offset = cfa_offset;\n \n@@ -2299,28 +2355,18 @@ ix86_epilogue (do_rtl)\n      int do_rtl;\n {\n   register int regno;\n-  register int nregs, limit;\n-  int offset;\n+  register int limit;\n+  int nregs;\n   rtx xops[3];\n   int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n \t\t\t\t  || current_function_uses_const_pool);\n   int sp_valid = !frame_pointer_needed || current_function_sp_is_unchanging;\n-  long tsize = get_frame_size ();\n-\n-  /* Compute the number of registers to pop */\n-\n-  limit = (frame_pointer_needed ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n-\n-  nregs = 0;\n-\n-  for (regno = limit - 1; regno >= 0; regno--)\n-    if ((regs_ever_live[regno] && ! call_used_regs[regno])\n-\t|| (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n-      nregs++;\n+  HOST_WIDE_INT offset;\n+  HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (), &nregs);\n \n   /* sp is often unreliable so we may have to go off the frame pointer. */\n \n-  offset = - tsize - (nregs * UNITS_PER_WORD);\n+  offset = -(tsize + nregs * UNITS_PER_WORD);\n \n   xops[2] = stack_pointer_rtx;\n \n@@ -2340,6 +2386,9 @@ ix86_epilogue (do_rtl)\n      less work than reloading sp and popping the register.  Otherwise,\n      restore sp (if necessary) and pop the registers. */\n \n+  limit = frame_pointer_needed\n+\t  ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM;\n+\n   if (nregs > 1 || sp_valid)\n     {\n       if ( !sp_valid )"}, {"sha": "417627f2afdeaa7de9dfdc7949881223b070336b", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65954bd8cb428dbefe4d8342330e625fe5698a34/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65954bd8cb428dbefe4d8342330e625fe5698a34/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=65954bd8cb428dbefe4d8342330e625fe5698a34", "patch": "@@ -410,6 +410,10 @@ extern int ix86_arch;\n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n #define STACK_BOUNDARY 32\n \n+/* We want to keep the stack aligned to 64bits when possible.  But the\n+   compiler can not rely on the stack having this alignment.*/\n+#define PREFERRED_STACK_BOUNDARY 64\n+\n /* Allocation boundary (in *bits*) for the code of a function.\n    For i486, we get better performance by aligning to a cache\n    line (i.e. 16 byte) boundary.  */\n@@ -1627,20 +1631,23 @@ do {\t\t\t\t\t\t\\\n     (OFFSET) = 8;\t/* Skip saved PC and previous frame pointer */\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      int regno;\t\t\t\t\t\t\t\\\n-      int offset = 0;\t\t\t\t\t\t\t\\\n+      int nregs;\t\t\t\t\t\t\t\\\n+      int offset;\t\t\t\t\t\t\t\\\n+      int preferred_alignment = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT; \\\n+      HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (),\t\\\n+\t\t\t\t\t\t     &nregs);\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\t\\\n-\tif ((regs_ever_live[regno] && ! call_used_regs[regno])\t\t\\\n-\t    || ((current_function_uses_pic_offset_table\t\t\t\\\n-\t\t || current_function_uses_const_pool)\t\t\t\\\n-\t\t&& flag_pic && regno == PIC_OFFSET_TABLE_REGNUM))\t\\\n-\t  offset += 4;\t\t\t\t\t\t\t\\\n+      (OFFSET) = (tsize + nregs * UNITS_PER_WORD);\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      (OFFSET) = offset + get_frame_size ();\t\t\t\t\\\n+      offset = 4;\t\t\t\t\t\t\t\\\n+      if (frame_pointer_needed)\t\t\t\t\t\t\\\n+\toffset += UNITS_PER_WORD;\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n-\t(OFFSET) += 4;\t/* Skip saved PC */\t\t\t\t\\\n+      if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t\t\\\n+\t(OFFSET) += offset;\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t(OFFSET) -= ((offset + preferred_alignment - 1)\t\t\t\\\n+\t\t     & -preferred_alignment) - offset;\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \f"}, {"sha": "621594af60744cbc825c7595c25afa89b894fe8a", "filename": "gcc/reload1.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65954bd8cb428dbefe4d8342330e625fe5698a34/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65954bd8cb428dbefe4d8342330e625fe5698a34/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=65954bd8cb428dbefe4d8342330e625fe5698a34", "patch": "@@ -39,6 +39,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"real.h\"\n #include \"toplev.h\"\n \n+#if !defined PREFERRED_STACK_BOUNDARY && defined STACK_BOUNDARY\n+#define PREFERRED_STACK_BOUNDARY STACK_BOUNDARY\n+#endif\n+\n /* This file contains the reload pass of the compiler, which is\n    run after register allocation has been done.  It checks that\n    each insn is valid (operands required to be in registers really"}]}