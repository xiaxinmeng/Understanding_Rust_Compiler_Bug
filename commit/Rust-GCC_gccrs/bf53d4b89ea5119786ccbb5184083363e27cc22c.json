{"sha": "bf53d4b89ea5119786ccbb5184083363e27cc22c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY1M2Q0Yjg5ZWE1MTE5Nzg2Y2NiYjUxODQwODMzNjNlMjdjYzIyYw==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2014-01-30T18:59:55Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2014-01-30T18:59:55Z"}, "message": "rs6000.c (rs6000_expand_vector_init): Use gen_vsx_xxspltw_v4sf_direct instead of gen_vsx_xxspltw_v4sf...\n\ngcc:\n\n2014-01-30  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* gcc/config/rs6000/rs6000.c (rs6000_expand_vector_init): Use\n\tgen_vsx_xxspltw_v4sf_direct instead of gen_vsx_xxspltw_v4sf;\n\tremove element index adjustment for endian (now handled in vsx.md\n\tand altivec.md).\n\t(altivec_expand_vec_perm_const): Use\n\tgen_altivec_vsplt[bhw]_direct instead of gen_altivec_vsplt[bhw].\n\t* gcc/config/rs6000/vsx.md (UNSPEC_VSX_XXSPLTW): New unspec.\n\t(vsx_xxspltw_<mode>): Adjust element index for little endian.\n\t* gcc/config/rs6000/altivec.md (altivec_vspltb): Divide into a\n\tdefine_expand and a new define_insn *altivec_vspltb_internal;\n\tadjust for -maltivec=be on a little endian target.\n\t(altivec_vspltb_direct): New.\n\t(altivec_vsplth): Divide into a define_expand and a new\n\tdefine_insn *altivec_vsplth_internal; adjust for -maltivec=be on a\n\tlittle endian target.\n\t(altivec_vsplth_direct): New.\n\t(altivec_vspltw): Divide into a define_expand and a new\n\tdefine_insn *altivec_vspltw_internal; adjust for -maltivec=be on a\n\tlittle endian target.\n\t(altivec_vspltw_direct): New.\n\t(altivec_vspltsf): Divide into a define_expand and a new\n\tdefine_insn *altivec_vspltsf_internal; adjust for -maltivec=be on\n\ta little endian target.\n\ngcc/testsuite:\n\n2014-01-30  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* gcc.dg/vmx/splat.c: New.\n\t* gcc.dg/vmx/splat-vsx.c: New.\n\t* gcc.dg/vmx/splat-be-order.c: New.\n\t* gcc.dg/vmx/splat-vsx-be-order.c: New.\n\t* gcc.dg/vmx/eg-5.c: Remove special casing for little endian.\n\t* gcc.dg/vmx/sn7153.c: Add special casing for little endian.\n\nFrom-SVN: r207318", "tree": {"sha": "71b6431cdc43ae3837914a5da1f510e614f92350", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71b6431cdc43ae3837914a5da1f510e614f92350"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf53d4b89ea5119786ccbb5184083363e27cc22c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf53d4b89ea5119786ccbb5184083363e27cc22c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf53d4b89ea5119786ccbb5184083363e27cc22c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf53d4b89ea5119786ccbb5184083363e27cc22c/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c965e18748995d2ce9a13395152fd0da295da573", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c965e18748995d2ce9a13395152fd0da295da573", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c965e18748995d2ce9a13395152fd0da295da573"}], "stats": {"total": 406, "additions": 383, "deletions": 23}, "files": [{"sha": "3aba416fef0ade8c6fa2a6c2a41fc5d29f4f6cc3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf53d4b89ea5119786ccbb5184083363e27cc22c", "patch": "@@ -1,3 +1,29 @@\n+2014-01-30  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* gcc/config/rs6000/rs6000.c (rs6000_expand_vector_init): Use\n+\tgen_vsx_xxspltw_v4sf_direct instead of gen_vsx_xxspltw_v4sf;\n+\tremove element index adjustment for endian (now handled in vsx.md\n+\tand altivec.md).\n+\t(altivec_expand_vec_perm_const): Use\n+\tgen_altivec_vsplt[bhw]_direct instead of gen_altivec_vsplt[bhw].\n+\t* gcc/config/rs6000/vsx.md (UNSPEC_VSX_XXSPLTW): New unspec.\n+\t(vsx_xxspltw_<mode>): Adjust element index for little endian.\n+\t* gcc/config/rs6000/altivec.md (altivec_vspltb): Divide into a\n+\tdefine_expand and a new define_insn *altivec_vspltb_internal;\n+\tadjust for -maltivec=be on a little endian target.\n+\t(altivec_vspltb_direct): New.\n+\t(altivec_vsplth): Divide into a define_expand and a new\n+\tdefine_insn *altivec_vsplth_internal; adjust for -maltivec=be on a\n+\tlittle endian target.\n+\t(altivec_vsplth_direct): New.\n+\t(altivec_vspltw): Divide into a define_expand and a new\n+\tdefine_insn *altivec_vspltw_internal; adjust for -maltivec=be on a\n+\tlittle endian target.\n+\t(altivec_vspltw_direct): New.\n+\t(altivec_vspltsf): Divide into a define_expand and a new\n+\tdefine_insn *altivec_vspltsf_internal; adjust for -maltivec=be on\n+\ta little endian target.\n+\n 2014-01-30  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/59993"}, {"sha": "aacd3fbc0d6f7be27ca3448beb2de272d6f74e0d", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 148, "deletions": 5, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=bf53d4b89ea5119786ccbb5184083363e27cc22c", "patch": "@@ -1600,44 +1600,187 @@\n   \"vsumsws %0,%1,%2\"\n   [(set_attr \"type\" \"veccomplex\")])\n \n-(define_insn \"altivec_vspltb\"\n+(define_expand \"altivec_vspltb\"\n+  [(match_operand:V16QI 0 \"register_operand\" \"\")\n+   (match_operand:V16QI 1 \"register_operand\" \"\")\n+   (match_operand:QI 2 \"u5bit_cint_operand\" \"\")]\n+  \"TARGET_ALTIVEC\"\n+{\n+  rtvec v;\n+  rtx x;\n+\n+  /* Special handling for LE with -maltivec=be.  We have to reflect\n+     the actual selected index for the splat in the RTL.  */\n+  if (!BYTES_BIG_ENDIAN && VECTOR_ELT_ORDER_BIG)\n+    operands[2] = GEN_INT (15 - INTVAL (operands[2]));\n+\n+  v = gen_rtvec (1, operands[2]);\n+  x = gen_rtx_VEC_SELECT (QImode, operands[1], gen_rtx_PARALLEL (VOIDmode, v));\n+  x = gen_rtx_VEC_DUPLICATE (V16QImode, x);\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], x));\n+  DONE;\n+})\n+\n+(define_insn \"*altivec_vspltb_internal\"\n   [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n         (vec_duplicate:V16QI\n \t (vec_select:QI (match_operand:V16QI 1 \"register_operand\" \"v\")\n \t\t\t(parallel\n \t\t\t [(match_operand:QI 2 \"u5bit_cint_operand\" \"\")]))))]\n   \"TARGET_ALTIVEC\"\n+{\n+  /* For true LE, this adjusts the selected index.  For LE with \n+     -maltivec=be, this reverses what was done in the define_expand\n+     because the instruction already has big-endian bias.  */\n+  if (!BYTES_BIG_ENDIAN)\n+    operands[2] = GEN_INT (15 - INTVAL (operands[2]));\n+\n+  return \"vspltb %0,%1,%2\";\n+}\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"altivec_vspltb_direct\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n+        (unspec:V16QI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n+\t               (match_operand:QI 2 \"u5bit_cint_operand\" \"i\")]\n+                      UNSPEC_VSPLT_DIRECT))]\n+  \"TARGET_ALTIVEC\"\n   \"vspltb %0,%1,%2\"\n   [(set_attr \"type\" \"vecperm\")])\n \n-(define_insn \"altivec_vsplth\"\n+(define_expand \"altivec_vsplth\"\n+  [(match_operand:V8HI 0 \"register_operand\" \"\")\n+   (match_operand:V8HI 1 \"register_operand\" \"\")\n+   (match_operand:QI 2 \"u5bit_cint_operand\" \"\")]\n+  \"TARGET_ALTIVEC\"\n+{\n+  rtvec v;\n+  rtx x;\n+\n+  /* Special handling for LE with -maltivec=be.  We have to reflect\n+     the actual selected index for the splat in the RTL.  */\n+  if (!BYTES_BIG_ENDIAN && VECTOR_ELT_ORDER_BIG)\n+    operands[2] = GEN_INT (7 - INTVAL (operands[2]));\n+\n+  v = gen_rtvec (1, operands[2]);\n+  x = gen_rtx_VEC_SELECT (HImode, operands[1], gen_rtx_PARALLEL (VOIDmode, v));\n+  x = gen_rtx_VEC_DUPLICATE (V8HImode, x);\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], x));\n+  DONE;\n+})\n+\n+(define_insn \"*altivec_vsplth_internal\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n \t(vec_duplicate:V8HI\n \t (vec_select:HI (match_operand:V8HI 1 \"register_operand\" \"v\")\n \t\t\t(parallel\n \t\t\t [(match_operand:QI 2 \"u5bit_cint_operand\" \"\")]))))]\n   \"TARGET_ALTIVEC\"\n+{\n+  /* For true LE, this adjusts the selected index.  For LE with \n+     -maltivec=be, this reverses what was done in the define_expand\n+     because the instruction already has big-endian bias.  */\n+  if (!BYTES_BIG_ENDIAN)\n+    operands[2] = GEN_INT (7 - INTVAL (operands[2]));\n+\n+  return \"vsplth %0,%1,%2\";\n+}\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"altivec_vsplth_direct\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n+        (unspec:V8HI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n+                      (match_operand:QI 2 \"u5bit_cint_operand\" \"i\")]\n+                     UNSPEC_VSPLT_DIRECT))]\n+  \"TARGET_ALTIVEC\"\n   \"vsplth %0,%1,%2\"\n   [(set_attr \"type\" \"vecperm\")])\n \n-(define_insn \"altivec_vspltw\"\n+(define_expand \"altivec_vspltw\"\n+  [(match_operand:V4SI 0 \"register_operand\" \"\")\n+   (match_operand:V4SI 1 \"register_operand\" \"\")\n+   (match_operand:QI 2 \"u5bit_cint_operand\" \"\")]\n+  \"TARGET_ALTIVEC\"\n+{\n+  rtvec v;\n+  rtx x;\n+\n+  /* Special handling for LE with -maltivec=be.  We have to reflect\n+     the actual selected index for the splat in the RTL.  */\n+  if (!BYTES_BIG_ENDIAN && VECTOR_ELT_ORDER_BIG)\n+    operands[2] = GEN_INT (3 - INTVAL (operands[2]));\n+\n+  v = gen_rtvec (1, operands[2]);\n+  x = gen_rtx_VEC_SELECT (SImode, operands[1], gen_rtx_PARALLEL (VOIDmode, v));\n+  x = gen_rtx_VEC_DUPLICATE (V4SImode, x);\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], x));\n+  DONE;\n+})\n+\n+(define_insn \"*altivec_vspltw_internal\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n \t(vec_duplicate:V4SI\n \t (vec_select:SI (match_operand:V4SI 1 \"register_operand\" \"v\")\n \t\t\t(parallel\n \t\t\t [(match_operand:QI 2 \"u5bit_cint_operand\" \"i\")]))))]\n   \"TARGET_ALTIVEC\"\n+{\n+  /* For true LE, this adjusts the selected index.  For LE with \n+     -maltivec=be, this reverses what was done in the define_expand\n+     because the instruction already has big-endian bias.  */\n+  if (!BYTES_BIG_ENDIAN)\n+    operands[2] = GEN_INT (3 - INTVAL (operands[2]));\n+\n+  return \"vspltw %0,%1,%2\";\n+}\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"altivec_vspltw_direct\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n+                      (match_operand:QI 2 \"u5bit_cint_operand\" \"i\")]\n+                     UNSPEC_VSPLT_DIRECT))]\n+  \"TARGET_ALTIVEC\"\n   \"vspltw %0,%1,%2\"\n   [(set_attr \"type\" \"vecperm\")])\n \n-(define_insn \"altivec_vspltsf\"\n+(define_expand \"altivec_vspltsf\"\n+  [(match_operand:V4SF 0 \"register_operand\" \"\")\n+   (match_operand:V4SF 1 \"register_operand\" \"\")\n+   (match_operand:QI 2 \"u5bit_cint_operand\" \"\")]\n+  \"TARGET_ALTIVEC\"\n+{\n+  rtvec v;\n+  rtx x;\n+\n+  /* Special handling for LE with -maltivec=be.  We have to reflect\n+     the actual selected index for the splat in the RTL.  */\n+  if (!BYTES_BIG_ENDIAN && VECTOR_ELT_ORDER_BIG)\n+    operands[2] = GEN_INT (3 - INTVAL (operands[2]));\n+\n+  v = gen_rtvec (1, operands[2]);\n+  x = gen_rtx_VEC_SELECT (SFmode, operands[1], gen_rtx_PARALLEL (VOIDmode, v));\n+  x = gen_rtx_VEC_DUPLICATE (V4SFmode, x);\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], x));\n+  DONE;\n+})\n+\n+(define_insn \"*altivec_vspltsf_internal\"\n   [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n \t(vec_duplicate:V4SF\n \t (vec_select:SF (match_operand:V4SF 1 \"register_operand\" \"v\")\n \t\t\t(parallel\n \t\t\t [(match_operand:QI 2 \"u5bit_cint_operand\" \"i\")]))))]\n   \"VECTOR_UNIT_ALTIVEC_P (V4SFmode)\"\n-  \"vspltw %0,%1,%2\"\n+{\n+  /* For true LE, this adjusts the selected index.  For LE with \n+     -maltivec=be, this reverses what was done in the define_expand\n+     because the instruction already has big-endian bias.  */\n+  if (!BYTES_BIG_ENDIAN)\n+    operands[2] = GEN_INT (3 - INTVAL (operands[2]));\n+\n+  return \"vspltw %0,%1,%2\";\n+}\n   [(set_attr \"type\" \"vecperm\")])\n \n (define_insn \"altivec_vspltis<VI_char>\""}, {"sha": "ec5f5bf1beabb9a0c1df3d69541eedbe6ec5261c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=bf53d4b89ea5119786ccbb5184083363e27cc22c", "patch": "@@ -5485,7 +5485,7 @@ rs6000_expand_vector_init (rtx target, rtx vals)\n \t\t      : gen_vsx_xscvdpsp_scalar (freg, sreg));\n \n \t  emit_insn (cvt);\n-\t  emit_insn (gen_vsx_xxspltw_v4sf (target, freg, const0_rtx));\n+\t  emit_insn (gen_vsx_xxspltw_v4sf_direct (target, freg, const0_rtx));\n \t}\n       else\n \t{\n@@ -5522,11 +5522,9 @@ rs6000_expand_vector_init (rtx target, rtx vals)\n \t\t\t\t\t      gen_rtx_SET (VOIDmode,\n \t\t\t\t\t\t\t   target, mem),\n \t\t\t\t\t      x)));\n-      field = (BYTES_BIG_ENDIAN ? const0_rtx\n-\t       : GEN_INT (GET_MODE_NUNITS (mode) - 1));\n       x = gen_rtx_VEC_SELECT (inner_mode, target,\n \t\t\t      gen_rtx_PARALLEL (VOIDmode,\n-\t\t\t\t\t\tgen_rtvec (1, field)));\n+\t\t\t\t\t\tgen_rtvec (1, const0_rtx)));\n       emit_insn (gen_rtx_SET (VOIDmode, target,\n \t\t\t      gen_rtx_VEC_DUPLICATE (mode, x)));\n       return;\n@@ -29980,7 +29978,7 @@ altivec_expand_vec_perm_const (rtx operands[4])\n \t{\n           if (!BYTES_BIG_ENDIAN)\n             elt = 15 - elt;\n-\t  emit_insn (gen_altivec_vspltb (target, op0, GEN_INT (elt)));\n+\t  emit_insn (gen_altivec_vspltb_direct (target, op0, GEN_INT (elt)));\n \t  return true;\n \t}\n \n@@ -29993,8 +29991,8 @@ altivec_expand_vec_perm_const (rtx operands[4])\n \t    {\n \t      int field = BYTES_BIG_ENDIAN ? elt / 2 : 7 - elt / 2;\n \t      x = gen_reg_rtx (V8HImode);\n-\t      emit_insn (gen_altivec_vsplth (x, gen_lowpart (V8HImode, op0),\n-\t\t\t\t\t     GEN_INT (field)));\n+\t      emit_insn (gen_altivec_vsplth_direct (x, gen_lowpart (V8HImode, op0),\n+\t\t\t\t\t\t    GEN_INT (field)));\n \t      emit_move_insn (target, gen_lowpart (V16QImode, x));\n \t      return true;\n \t    }\n@@ -30012,8 +30010,8 @@ altivec_expand_vec_perm_const (rtx operands[4])\n \t    {\n \t      int field = BYTES_BIG_ENDIAN ? elt / 4 : 3 - elt / 4;\n \t      x = gen_reg_rtx (V4SImode);\n-\t      emit_insn (gen_altivec_vspltw (x, gen_lowpart (V4SImode, op0),\n-\t\t\t\t\t     GEN_INT (field)));\n+\t      emit_insn (gen_altivec_vspltw_direct (x, gen_lowpart (V4SImode, op0),\n+\t\t\t\t\t\t    GEN_INT (field)));\n \t      emit_move_insn (target, gen_lowpart (V16QImode, x));\n \t      return true;\n \t    }"}, {"sha": "c6d558ad6157d124fc608a3b31ea09d15773fa58", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=bf53d4b89ea5119786ccbb5184083363e27cc22c", "patch": "@@ -213,6 +213,7 @@\n    UNSPEC_VSX_ROUND_I\n    UNSPEC_VSX_ROUND_IC\n    UNSPEC_VSX_SLDWI\n+   UNSPEC_VSX_XXSPLTW\n   ])\n \n ;; VSX moves\n@@ -1751,6 +1752,20 @@\n \t  (parallel\n \t   [(match_operand:QI 2 \"u5bit_cint_operand\" \"i,i\")]))))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n+{\n+  if (!BYTES_BIG_ENDIAN)\n+    operands[2] = GEN_INT (3 - INTVAL (operands[2]));\n+\n+  return \"xxspltw %x0,%x1,%2\";\n+}\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"vsx_xxspltw_<mode>_direct\"\n+  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=wf,?wa\")\n+        (unspec:VSX_W [(match_operand:VSX_W 1 \"vsx_register_operand\" \"wf,wa\")\n+                       (match_operand:QI 2 \"u5bit_cint_operand\" \"i,i\")]\n+                      UNSPEC_VSX_XXSPLTW))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"xxspltw %x0,%x1,%2\"\n   [(set_attr \"type\" \"vecperm\")])\n "}, {"sha": "d8d8c076bda3fbb455cb3f2d5867bf98594efe57", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bf53d4b89ea5119786ccbb5184083363e27cc22c", "patch": "@@ -1,3 +1,12 @@\n+2014-01-30  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* gcc.dg/vmx/splat.c: New.\n+\t* gcc.dg/vmx/splat-vsx.c: New.\n+\t* gcc.dg/vmx/splat-be-order.c: New.\n+\t* gcc.dg/vmx/splat-vsx-be-order.c: New.\n+\t* gcc.dg/vmx/eg-5.c: Remove special casing for little endian.\n+\t* gcc.dg/vmx/sn7153.c: Add special casing for little endian.\n+\n 2014-01-30  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/59993"}, {"sha": "eb4b4e028368d813a4274f38833db3e8be6a1b6a", "filename": "gcc/testsuite/gcc.dg/vmx/eg-5.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Feg-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Feg-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Feg-5.c?ref=bf53d4b89ea5119786ccbb5184083363e27cc22c", "patch": "@@ -6,19 +6,10 @@ matvecmul4 (vector float c0, vector float c1, vector float c2,\n {\n   /* Set result to a vector of f32 0's */\n   vector float result = ((vector float){0.,0.,0.,0.});\n-\n-#ifdef __LITTLE_ENDIAN__\n-  result  = vec_madd (c0, vec_splat (v, 3), result);\n-  result  = vec_madd (c1, vec_splat (v, 2), result);\n-  result  = vec_madd (c2, vec_splat (v, 1), result);\n-  result  = vec_madd (c3, vec_splat (v, 0), result);\n-#else\n   result  = vec_madd (c0, vec_splat (v, 0), result);\n   result  = vec_madd (c1, vec_splat (v, 1), result);\n   result  = vec_madd (c2, vec_splat (v, 2), result);\n   result  = vec_madd (c3, vec_splat (v, 3), result);\n-#endif\n-\n   return result;\n }\n "}, {"sha": "2381a891cd378bf796e1467b25da022505c9e780", "filename": "gcc/testsuite/gcc.dg/vmx/sn7153.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Fsn7153.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Fsn7153.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Fsn7153.c?ref=bf53d4b89ea5119786ccbb5184083363e27cc22c", "patch": "@@ -34,7 +34,11 @@ main()\n \n void validate_sat()\n {\n+#ifdef __LITTLE_ENDIAN__\n+  if (vec_any_ne(vec_splat(vec_mfvscr(), 0), ((vector unsigned short){1,1,1,1,1,1,1,1})))\n+#else\n   if (vec_any_ne(vec_splat(vec_mfvscr(), 7), ((vector unsigned short){1,1,1,1,1,1,1,1})))\n+#endif\n     {\n       union {vector unsigned short v; unsigned short s[8];} u;\n       u.v = vec_mfvscr();"}, {"sha": "e265ae4be200dc4de97e938369760f29b5bf95db", "filename": "gcc/testsuite/gcc.dg/vmx/splat-be-order.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Fsplat-be-order.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Fsplat-be-order.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Fsplat-be-order.c?ref=bf53d4b89ea5119786ccbb5184083363e27cc22c", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-options \"-maltivec=be -mabi=altivec -std=gnu99 -mno-vsx\" } */\n+\n+#include \"harness.h\"\n+\n+static void test()\n+{\n+  /* Input vectors.  */\n+  vector unsigned char vuc = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  vector signed char vsc = {-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7};\n+  vector unsigned short vus = {0,1,2,3,4,5,6,7};\n+  vector signed short vss = {-4,-3,-2,-1,0,1,2,3};\n+  vector unsigned int vui = {0,1,2,3};\n+  vector signed int vsi = {-2,-1,0,1};\n+  vector float vf = {-2.0,-1.0,0.0,1.0};\n+\n+  /* Result vectors.  */\n+  vector unsigned char vucr;\n+  vector signed char vscr;\n+  vector unsigned short vusr;\n+  vector signed short vssr;\n+  vector unsigned int vuir;\n+  vector signed int vsir;\n+  vector float vfr;\n+\n+  /* Expected result vectors.  */\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+  vector unsigned char vucer = {14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14};\n+  vector signed char vscer = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};\n+  vector unsigned short vuser = {0,0,0,0,0,0,0,0};\n+  vector signed short vsser = {3,3,3,3,3,3,3,3};\n+  vector unsigned int vuier = {1,1,1,1};\n+  vector signed int vsier = {-2,-2,-2,-2};\n+  vector float vfer = {0.0,0.0,0.0,0.0};\n+#else\n+  vector unsigned char vucer = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\n+  vector signed char vscer = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\n+  vector unsigned short vuser = {7,7,7,7,7,7,7,7};\n+  vector signed short vsser = {-4,-4,-4,-4,-4,-4,-4,-4};\n+  vector unsigned int vuier = {2,2,2,2};\n+  vector signed int vsier = {1,1,1,1};\n+  vector float vfer = {-1.0,-1.0,-1.0,-1.0};\n+#endif\n+\n+  vucr = vec_splat (vuc, 1);\n+  vscr = vec_splat (vsc, 8);\n+  vusr = vec_splat (vus, 7);\n+  vssr = vec_splat (vss, 0);\n+  vuir = vec_splat (vui, 2);\n+  vsir = vec_splat (vsi, 3);\n+  vfr  = vec_splat (vf,  1);\n+\n+  check (vec_all_eq (vucr, vucer), \"vuc\");\n+  check (vec_all_eq (vscr, vscer), \"vsc\");\n+  check (vec_all_eq (vusr, vuser), \"vus\");\n+  check (vec_all_eq (vssr, vsser), \"vss\");\n+  check (vec_all_eq (vuir, vuier), \"vui\");\n+  check (vec_all_eq (vsir, vsier), \"vsi\");\n+  check (vec_all_eq (vfr,  vfer ), \"vf\");\n+}"}, {"sha": "cd389bd0f66d664878bc4aa6c8fd2695c440f888", "filename": "gcc/testsuite/gcc.dg/vmx/splat-vsx-be-order.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Fsplat-vsx-be-order.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Fsplat-vsx-be-order.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Fsplat-vsx-be-order.c?ref=bf53d4b89ea5119786ccbb5184083363e27cc22c", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-maltivec=be -mabi=altivec -std=gnu99 -mvsx\" } */\n+\n+#include \"harness.h\"\n+\n+static void test()\n+{\n+  /* Input vectors.  */\n+  vector unsigned int vui = {0,1,2,3};\n+  vector signed int vsi = {-2,-1,0,1};\n+  vector float vf = {-2.0,-1.0,0.0,1.0};\n+\n+  /* Result vectors.  */\n+  vector unsigned int vuir;\n+  vector signed int vsir;\n+  vector float vfr;\n+\n+  /* Expected result vectors.  */\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+  vector unsigned int vuier = {1,1,1,1};\n+  vector signed int vsier = {-2,-2,-2,-2};\n+  vector float vfer = {0.0,0.0,0.0,0.0};\n+#else\n+  vector unsigned int vuier = {2,2,2,2};\n+  vector signed int vsier = {1,1,1,1};\n+  vector float vfer = {-1.0,-1.0,-1.0,-1.0};\n+#endif\n+\n+  vuir = vec_splat (vui, 2);\n+  vsir = vec_splat (vsi, 3);\n+  vfr  = vec_splat (vf,  1);\n+\n+  check (vec_all_eq (vuir, vuier), \"vui\");\n+  check (vec_all_eq (vsir, vsier), \"vsi\");\n+  check (vec_all_eq (vfr,  vfer ), \"vf\");\n+}"}, {"sha": "5a6e7dfe46c34fff64b2e2154418ccbed4183e30", "filename": "gcc/testsuite/gcc.dg/vmx/splat-vsx.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Fsplat-vsx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Fsplat-vsx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Fsplat-vsx.c?ref=bf53d4b89ea5119786ccbb5184083363e27cc22c", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-maltivec -mabi=altivec -std=gnu99 -mvsx\" } */\n+\n+#include \"harness.h\"\n+\n+static void test()\n+{\n+  /* Input vectors.  */\n+  vector unsigned int vui = {0,1,2,3};\n+  vector signed int vsi = {-2,-1,0,1};\n+  vector float vf = {-2.0,-1.0,0.0,1.0};\n+\n+  /* Result vectors.  */\n+  vector unsigned int vuir;\n+  vector signed int vsir;\n+  vector float vfr;\n+\n+  /* Expected result vectors.  */\n+  vector unsigned int vuier = {2,2,2,2};\n+  vector signed int vsier = {1,1,1,1};\n+  vector float vfer = {-1.0,-1.0,-1.0,-1.0};\n+\n+  vuir = vec_splat (vui, 2);\n+  vsir = vec_splat (vsi, 3);\n+  vfr  = vec_splat (vf,  1);\n+\n+  check (vec_all_eq (vuir, vuier), \"vui\");\n+  check (vec_all_eq (vsir, vsier), \"vsi\");\n+  check (vec_all_eq (vfr,  vfer ), \"vf\");\n+}"}, {"sha": "e45974ac9101215c8eecb7b0cd3bfa4578bde2f9", "filename": "gcc/testsuite/gcc.dg/vmx/splat.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Fsplat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf53d4b89ea5119786ccbb5184083363e27cc22c/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Fsplat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Fsplat.c?ref=bf53d4b89ea5119786ccbb5184083363e27cc22c", "patch": "@@ -0,0 +1,47 @@\n+#include \"harness.h\"\n+\n+static void test()\n+{\n+  /* Input vectors.  */\n+  vector unsigned char vuc = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  vector signed char vsc = {-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7};\n+  vector unsigned short vus = {0,1,2,3,4,5,6,7};\n+  vector signed short vss = {-4,-3,-2,-1,0,1,2,3};\n+  vector unsigned int vui = {0,1,2,3};\n+  vector signed int vsi = {-2,-1,0,1};\n+  vector float vf = {-2.0,-1.0,0.0,1.0};\n+\n+  /* Result vectors.  */\n+  vector unsigned char vucr;\n+  vector signed char vscr;\n+  vector unsigned short vusr;\n+  vector signed short vssr;\n+  vector unsigned int vuir;\n+  vector signed int vsir;\n+  vector float vfr;\n+\n+  /* Expected result vectors.  */\n+  vector unsigned char vucer = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\n+  vector signed char vscer = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\n+  vector unsigned short vuser = {7,7,7,7,7,7,7,7};\n+  vector signed short vsser = {-4,-4,-4,-4,-4,-4,-4,-4};\n+  vector unsigned int vuier = {2,2,2,2};\n+  vector signed int vsier = {1,1,1,1};\n+  vector float vfer = {-1.0,-1.0,-1.0,-1.0};\n+\n+  vucr = vec_splat (vuc, 1);\n+  vscr = vec_splat (vsc, 8);\n+  vusr = vec_splat (vus, 7);\n+  vssr = vec_splat (vss, 0);\n+  vuir = vec_splat (vui, 2);\n+  vsir = vec_splat (vsi, 3);\n+  vfr  = vec_splat (vf,  1);\n+\n+  check (vec_all_eq (vucr, vucer), \"vuc\");\n+  check (vec_all_eq (vscr, vscer), \"vsc\");\n+  check (vec_all_eq (vusr, vuser), \"vus\");\n+  check (vec_all_eq (vssr, vsser), \"vss\");\n+  check (vec_all_eq (vuir, vuier), \"vui\");\n+  check (vec_all_eq (vsir, vsier), \"vsi\");\n+  check (vec_all_eq (vfr,  vfer ), \"vf\");\n+}"}]}