{"sha": "3fa8871b0c1386f60e32929c0aa307a99b5a5b65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZhODg3MWIwYzEzODZmNjBlMzI5MjljMGFhMzA3YTk5YjVhNWI2NQ==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2017-05-17T16:30:53Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2017-05-17T16:30:53Z"}, "message": "c-common.c: Use NULL_TREE instead of 0 where appropriate.\n\n\t* c-common.c: Use NULL_TREE instead of 0 where appropriate.\n\t* c-warn.c: Likewise.\n\n\t* c-decl.c: Use NULL_TREE instead of 0 where appropriate.\n\t* c-typeck.c: Likewise.\n\nFrom-SVN: r248161", "tree": {"sha": "c97cf529321ffc989c99eb376ae271846c864986", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c97cf529321ffc989c99eb376ae271846c864986"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fa8871b0c1386f60e32929c0aa307a99b5a5b65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fa8871b0c1386f60e32929c0aa307a99b5a5b65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fa8871b0c1386f60e32929c0aa307a99b5a5b65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fa8871b0c1386f60e32929c0aa307a99b5a5b65/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "26bddba34ab4735eba9f5a5da4399f348ce39674", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26bddba34ab4735eba9f5a5da4399f348ce39674", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26bddba34ab4735eba9f5a5da4399f348ce39674"}], "stats": {"total": 353, "additions": 184, "deletions": 169}, "files": [{"sha": "28c97be9a09a4beab9832e6f8146a17c1f17e5ed", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa8871b0c1386f60e32929c0aa307a99b5a5b65/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa8871b0c1386f60e32929c0aa307a99b5a5b65/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=3fa8871b0c1386f60e32929c0aa307a99b5a5b65", "patch": "@@ -1,3 +1,8 @@\n+2017-05-17  Marek Polacek  <polacek@redhat.com>\n+\n+\t* c-common.c: Use NULL_TREE instead of 0 where appropriate.\n+\t* c-warn.c: Likewise.\n+\n 2017-05-17  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tImplement new C++ intrinsics __is_assignable and __is_constructible."}, {"sha": "bd9b512408386c9de24d25f39aff2f28dd6bf32f", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa8871b0c1386f60e32929c0aa307a99b5a5b65/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa8871b0c1386f60e32929c0aa307a99b5a5b65/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=3fa8871b0c1386f60e32929c0aa307a99b5a5b65", "patch": "@@ -2989,7 +2989,7 @@ shorten_compare (location_t loc, tree *op0_ptr, tree *op1_ptr,\n       if (!real1 && !real2 && integer_zerop (primop1)\n \t  && TYPE_UNSIGNED (*restype_ptr))\n \t{\n-\t  tree value = 0;\n+\t  tree value = NULL_TREE;\n \t  /* All unsigned values are >= 0, so we warn.  However,\n \t     if OP0 is a constant that is >= 0, the signedness of\n \t     the comparison isn't an issue, so suppress the\n@@ -3022,7 +3022,7 @@ shorten_compare (location_t loc, tree *op0_ptr, tree *op1_ptr,\n \t      break;\n \t    }\n \n-\t  if (value != 0)\n+\t  if (value != NULL_TREE)\n \t    {\n \t      /* Don't forget to evaluate PRIMOP0 if it has side effects.  */\n \t      if (TREE_SIDE_EFFECTS (primop0))\n@@ -4651,10 +4651,10 @@ self_promoting_args_p (const_tree parms)\n       if (type == error_mark_node)\n \tcontinue;\n \n-      if (TREE_CHAIN (t) == 0 && type != void_type_node)\n+      if (TREE_CHAIN (t) == NULL_TREE && type != void_type_node)\n \treturn 0;\n \n-      if (type == 0)\n+      if (type == NULL_TREE)\n \treturn 0;\n \n       if (TYPE_MAIN_VARIANT (type) == float_type_node)\n@@ -5579,7 +5579,7 @@ check_function_arguments_recurse (void (*callback)\n \t    format_num = tree_to_uhwi (format_num_expr);\n \n \t    for (inner_arg = first_call_expr_arg (param, &iter), i = 1;\n-\t\t inner_arg != 0;\n+\t\t inner_arg != NULL_TREE;\n \t\t inner_arg = next_call_expr_arg (&iter), i++)\n \t      if (i == format_num)\n \t\t{"}, {"sha": "1b2a8d89ff2bc784de9aa08d369bd2f6f1220aa0", "filename": "gcc/c-family/c-warn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa8871b0c1386f60e32929c0aa307a99b5a5b65/gcc%2Fc-family%2Fc-warn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa8871b0c1386f60e32929c0aa307a99b5a5b65/gcc%2Fc-family%2Fc-warn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.c?ref=3fa8871b0c1386f60e32929c0aa307a99b5a5b65", "patch": "@@ -1078,7 +1078,7 @@ match_case_to_enum_1 (tree key, tree type, tree label)\n   else\n     print_hex (key, buf);\n \n-  if (TYPE_NAME (type) == 0)\n+  if (TYPE_NAME (type) == NULL_TREE)\n     warning_at (DECL_SOURCE_LOCATION (CASE_LABEL (label)),\n \t\twarn_switch ? OPT_Wswitch : OPT_Wswitch_enum,\n \t\t\"case value %qs not in enumerated type\","}, {"sha": "8d5503107e9693be49d28f3c2461d25008e62fb3", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa8871b0c1386f60e32929c0aa307a99b5a5b65/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa8871b0c1386f60e32929c0aa307a99b5a5b65/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=3fa8871b0c1386f60e32929c0aa307a99b5a5b65", "patch": "@@ -1,3 +1,8 @@\n+2017-05-17  Marek Polacek  <polacek@redhat.com>\n+\n+\t* c-decl.c: Use NULL_TREE instead of 0 where appropriate.\n+\t* c-typeck.c: Likewise.\n+\n 2017-05-17  Marek Polacek  <polacek@redhat.com>\n \n \tPR sanitizer/80659"}, {"sha": "55fc53e228bb311bcdfe5c84399395e5ad4a280b", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 73, "deletions": 71, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa8871b0c1386f60e32929c0aa307a99b5a5b65/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa8871b0c1386f60e32929c0aa307a99b5a5b65/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=3fa8871b0c1386f60e32929c0aa307a99b5a5b65", "patch": "@@ -809,7 +809,7 @@ c_finish_incomplete_decl (tree decl)\n       if (type != error_mark_node\n \t  && TREE_CODE (type) == ARRAY_TYPE\n \t  && !DECL_EXTERNAL (decl)\n-\t  && TYPE_DOMAIN (type) == 0)\n+\t  && TYPE_DOMAIN (type) == NULL_TREE)\n \t{\n \t  warning_at (DECL_SOURCE_LOCATION (decl),\n \t\t      0, \"array %q+D assumed to have one element\", decl);\n@@ -1146,7 +1146,7 @@ pop_scope (void)\n \n   /* If appropriate, create a BLOCK to record the decls for the life\n      of this function.  */\n-  block = 0;\n+  block = NULL_TREE;\n   if (keep)\n     {\n       block = make_node (BLOCK);\n@@ -1157,7 +1157,7 @@ pop_scope (void)\n       for (p = scope->blocks; p; p = BLOCK_CHAIN (p))\n \tBLOCK_SUPERCONTEXT (p) = block;\n \n-      BLOCK_VARS (block) = 0;\n+      BLOCK_VARS (block) = NULL_TREE;\n     }\n \n   /* The TYPE_CONTEXTs for all of the tagged types belonging to this\n@@ -1230,9 +1230,9 @@ pop_scope (void)\n \t  /* Propagate TREE_ADDRESSABLE from nested functions to their\n \t     containing functions.  */\n \t  if (!TREE_ASM_WRITTEN (p)\n-\t      && DECL_INITIAL (p) != 0\n+\t      && DECL_INITIAL (p) != NULL_TREE\n \t      && TREE_ADDRESSABLE (p)\n-\t      && DECL_ABSTRACT_ORIGIN (p) != 0\n+\t      && DECL_ABSTRACT_ORIGIN (p) != NULL_TREE\n \t      && DECL_ABSTRACT_ORIGIN (p) != p)\n \t    TREE_ADDRESSABLE (DECL_ABSTRACT_ORIGIN (p)) = 1;\n \t  if (!DECL_EXTERNAL (p)\n@@ -1677,18 +1677,18 @@ diagnose_arglist_conflict (tree newdecl, tree olddecl,\n \n   if (TREE_CODE (olddecl) != FUNCTION_DECL\n       || !comptypes (TREE_TYPE (oldtype), TREE_TYPE (newtype))\n-      || !((!prototype_p (oldtype) && DECL_INITIAL (olddecl) == 0)\n-\t   || (!prototype_p (newtype) && DECL_INITIAL (newdecl) == 0)))\n+      || !((!prototype_p (oldtype) && DECL_INITIAL (olddecl) == NULL_TREE)\n+\t   || (!prototype_p (newtype) && DECL_INITIAL (newdecl) == NULL_TREE)))\n     return;\n \n   t = TYPE_ARG_TYPES (oldtype);\n-  if (t == 0)\n+  if (t == NULL_TREE)\n     t = TYPE_ARG_TYPES (newtype);\n   for (; t; t = TREE_CHAIN (t))\n     {\n       tree type = TREE_VALUE (t);\n \n-      if (TREE_CHAIN (t) == 0\n+      if (TREE_CHAIN (t) == NULL_TREE\n \t  && TYPE_MAIN_VARIANT (type) != void_type_node)\n \t{\n \t  inform (input_location, \"a parameter list with an ellipsis can%'t match \"\n@@ -2297,7 +2297,7 @@ static void\n merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n {\n   bool new_is_definition = (TREE_CODE (newdecl) == FUNCTION_DECL\n-\t\t\t    && DECL_INITIAL (newdecl) != 0);\n+\t\t\t    && DECL_INITIAL (newdecl) != NULL_TREE);\n   bool new_is_prototype = (TREE_CODE (newdecl) == FUNCTION_DECL\n \t\t\t   && prototype_p (TREE_TYPE (newdecl)));\n   bool old_is_prototype = (TREE_CODE (olddecl) == FUNCTION_DECL\n@@ -2412,13 +2412,14 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t   && DECL_IN_SYSTEM_HEADER (newdecl)\n \t   && !DECL_IN_SYSTEM_HEADER (olddecl))\n     DECL_SOURCE_LOCATION (olddecl) = DECL_SOURCE_LOCATION (newdecl);\n-  else if ((DECL_INITIAL (newdecl) == 0 && DECL_INITIAL (olddecl) != 0)\n+  else if ((DECL_INITIAL (newdecl) == NULL_TREE\n+\t    && DECL_INITIAL (olddecl) != NULL_TREE)\n \t   || (old_is_prototype && !new_is_prototype\n \t       && !C_DECL_BUILTIN_PROTOTYPE (olddecl)))\n     DECL_SOURCE_LOCATION (newdecl) = DECL_SOURCE_LOCATION (olddecl);\n \n   /* Merge the initialization information.  */\n-   if (DECL_INITIAL (newdecl) == 0)\n+   if (DECL_INITIAL (newdecl) == NULL_TREE)\n     DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n \n   /* Merge the threadprivate attribute.  */\n@@ -2938,8 +2939,8 @@ pushdecl (tree x)\n   if (DECL_EXTERNAL (x) || scope == file_scope)\n     {\n       tree type = TREE_TYPE (x);\n-      tree vistype = 0;\n-      tree visdecl = 0;\n+      tree vistype = NULL_TREE;\n+      tree visdecl = NULL_TREE;\n       bool type_saved = false;\n       if (b && !B_IN_EXTERNAL_SCOPE (b)\n \t  && VAR_OR_FUNCTION_DECL_P (b->decl)\n@@ -3355,7 +3356,7 @@ tree\n implicitly_declare (location_t loc, tree functionid)\n {\n   struct c_binding *b;\n-  tree decl = 0;\n+  tree decl = NULL_TREE;\n   tree asmspec_tree;\n \n   for (b = I_SYMBOL_BINDING (functionid); b; b = b->shadowed)\n@@ -3473,7 +3474,7 @@ undeclared_variable (location_t loc, tree id)\n   static bool already = false;\n   struct c_scope *scope;\n \n-  if (current_function_decl == 0)\n+  if (current_function_decl == NULL_TREE)\n     {\n       const char *guessed_id = lookup_name_fuzzy (id, FUZZY_LOOKUP_NAME);\n       if (guessed_id)\n@@ -3767,7 +3768,7 @@ define_label (location_t location, tree name)\n \n   if (label\n       && ((DECL_CONTEXT (label) == current_function_decl\n-\t   && DECL_INITIAL (label) != 0)\n+\t   && DECL_INITIAL (label) != NULL_TREE)\n \t  || (DECL_CONTEXT (label) != current_function_decl\n \t      && C_DECLARED_LABEL_FLAG (label))))\n     {\n@@ -3960,10 +3961,10 @@ tag_exists_p (enum tree_code code, tree name)\n void\n pending_xref_error (void)\n {\n-  if (pending_invalid_xref != 0)\n+  if (pending_invalid_xref != NULL_TREE)\n     error_at (pending_invalid_xref_location, \"%qE defined as wrong kind of tag\",\n \t      pending_invalid_xref);\n-  pending_invalid_xref = 0;\n+  pending_invalid_xref = NULL_TREE;\n }\n \n \f\n@@ -4123,7 +4124,7 @@ c_init_decl_processing (void)\n   /* Initialize reserved words for parser.  */\n   c_parse_init ();\n \n-  current_function_decl = 0;\n+  current_function_decl = NULL_TREE;\n \n   gcc_obstack_init (&parser_obstack);\n \n@@ -4297,7 +4298,7 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \t      warned = 1;\n \t    }\n \n-\t  if (name == 0)\n+\t  if (name == NULL_TREE)\n \t    {\n \t      if (warned != 1 && code != ENUMERAL_TYPE)\n \t\t/* Empty unnamed enum OK */\n@@ -4346,7 +4347,7 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \t    }\n \t  else\n \t    {\n-\t      pending_invalid_xref = 0;\n+\t      pending_invalid_xref = NULL_TREE;\n \t      t = lookup_tag (code, name, true, NULL);\n \n \t      if (t == NULL_TREE)\n@@ -4373,7 +4374,7 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n       warned = 1;\n     }\n \n-  pending_invalid_xref = 0;\n+  pending_invalid_xref = NULL_TREE;\n \n   if (declspecs->inline_p)\n     {\n@@ -4859,7 +4860,7 @@ finish_decl (tree decl, location_t init_loc, tree init,\n \t     tree origtype, tree asmspec_tree)\n {\n   tree type;\n-  bool was_incomplete = (DECL_SIZE (decl) == 0);\n+  bool was_incomplete = (DECL_SIZE (decl) == NULL_TREE);\n   const char *asmspec = 0;\n \n   /* If a name was specified, get the string.  */\n@@ -4877,12 +4878,12 @@ finish_decl (tree decl, location_t init_loc, tree init,\n     record_types_used_by_current_var_decl (decl);\n \n   /* If `start_decl' didn't like having an initialization, ignore it now.  */\n-  if (init != 0 && DECL_INITIAL (decl) == 0)\n-    init = 0;\n+  if (init != NULL_TREE && DECL_INITIAL (decl) == NULL_TREE)\n+    init = NULL_TREE;\n \n   /* Don't crash if parm is initialized.  */\n   if (TREE_CODE (decl) == PARM_DECL)\n-    init = 0;\n+    init = NULL_TREE;\n \n   if (init)\n     store_init_value (init_loc, decl, init, origtype);\n@@ -4895,7 +4896,7 @@ finish_decl (tree decl, location_t init_loc, tree init,\n \n   /* Deduce size of array from initialization, if not already known.  */\n   if (TREE_CODE (type) == ARRAY_TYPE\n-      && TYPE_DOMAIN (type) == 0\n+      && TYPE_DOMAIN (type) == NULL_TREE\n       && TREE_CODE (decl) != TYPE_DECL)\n     {\n       bool do_default\n@@ -4967,11 +4968,11 @@ finish_decl (tree decl, location_t init_loc, tree init,\n       if (init && TREE_CODE (init) == CONSTRUCTOR)\n \tadd_flexible_array_elts_to_size (decl, init);\n \n-      if (DECL_SIZE (decl) == 0 && TREE_TYPE (decl) != error_mark_node\n+      if (DECL_SIZE (decl) == NULL_TREE && TREE_TYPE (decl) != error_mark_node\n \t  && COMPLETE_TYPE_P (TREE_TYPE (decl)))\n \tlayout_decl (decl, 0);\n \n-      if (DECL_SIZE (decl) == 0\n+      if (DECL_SIZE (decl) == NULL_TREE\n \t  /* Don't give an error if we already gave one earlier.  */\n \t  && TREE_TYPE (decl) != error_mark_node\n \t  && (TREE_STATIC (decl)\n@@ -4980,7 +4981,7 @@ finish_decl (tree decl, location_t init_loc, tree init,\n \t\t Also if it is not file scope.\n \t\t Otherwise, let it through, but if it is not `extern'\n \t\t then it may cause an error message later.  */\n-\t      ? (DECL_INITIAL (decl) != 0\n+\t      ? (DECL_INITIAL (decl) != NULL_TREE\n \t\t || !DECL_FILE_SCOPE_P (decl))\n \t      /* An automatic variable with an incomplete type\n \t\t is an error.  */\n@@ -4996,7 +4997,7 @@ finish_decl (tree decl, location_t init_loc, tree init,\n \t  && TREE_STATIC (decl))\n \tincomplete_record_decls.safe_push (decl);\n \n-      if (is_global_var (decl) && DECL_SIZE (decl) != 0)\n+      if (is_global_var (decl) && DECL_SIZE (decl) != NULL_TREE)\n \t{\n \t  if (TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST)\n \t    constant_expression_warning (DECL_SIZE (decl));\n@@ -5117,8 +5118,8 @@ finish_decl (tree decl, location_t init_loc, tree init,\n \t      /* If we used it already as memory, it must stay in memory.  */\n \t      TREE_ADDRESSABLE (decl) = TREE_USED (decl);\n \t      /* If it's still incomplete now, no init will save it.  */\n-\t      if (DECL_SIZE (decl) == 0)\n-\t\tDECL_INITIAL (decl) = 0;\n+\t      if (DECL_SIZE (decl) == NULL_TREE)\n+\t\tDECL_INITIAL (decl) = NULL_TREE;\n \t    }\n \t}\n     }\n@@ -5647,7 +5648,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-    if (name == 0)\n+    if (name == NULL_TREE)\n       {\n \tgcc_assert (decl_context == PARM\n \t\t    || decl_context == TYPENAME\n@@ -7066,7 +7067,7 @@ grokparms (struct c_arg_info *arg_info, bool funcdef_flag)\n       error (\"%<[*]%> not allowed in other than function prototype scope\");\n     }\n \n-  if (arg_types == 0 && !funcdef_flag\n+  if (arg_types == NULL_TREE && !funcdef_flag\n       && !in_system_header_at (input_location))\n     warning (OPT_Wstrict_prototypes,\n \t     \"function declaration isn%'t a prototype\");\n@@ -7084,7 +7085,7 @@ grokparms (struct c_arg_info *arg_info, bool funcdef_flag)\n       else\n \targ_info->parms = arg_info->types;\n \n-      arg_info->types = 0;\n+      arg_info->types = NULL_TREE;\n       return 0;\n     }\n   else\n@@ -7179,10 +7180,10 @@ get_parm_info (bool ellipsis, tree expr)\n   struct c_binding *b = current_scope->bindings;\n   struct c_arg_info *arg_info = build_arg_info ();\n \n-  tree parms    = 0;\n+  tree parms = NULL_TREE;\n   vec<c_arg_tag, va_gc> *tags = NULL;\n-  tree types    = 0;\n-  tree others   = 0;\n+  tree types = NULL_TREE;\n+  tree others = NULL_TREE;\n \n   bool gave_void_only_once_err = false;\n \n@@ -7283,7 +7284,7 @@ get_parm_info (bool ellipsis, tree expr)\n \t     (it's impossible to call such a function with type-\n \t     correct arguments).  An anonymous union parm type is\n \t     meaningful as a GNU extension, so don't warn for that.  */\n-\t  if (TREE_CODE (decl) != UNION_TYPE || b->id != 0)\n+\t  if (TREE_CODE (decl) != UNION_TYPE || b->id != NULL_TREE)\n \t    {\n \t      if (b->id)\n \t\t/* The %s will be one of 'struct', 'union', or 'enum'.  */\n@@ -7686,7 +7687,7 @@ detect_field_duplicates_hash (tree fieldlist,\n   tree_node **slot;\n \n   for (x = fieldlist; x ; x = DECL_CHAIN (x))\n-    if ((y = DECL_NAME (x)) != 0)\n+    if ((y = DECL_NAME (x)) != NULL_TREE)\n       {\n \tslot = htab->find_slot (y, INSERT);\n \tif (*slot)\n@@ -7866,21 +7867,21 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n   /* If this type was previously laid out as a forward reference,\n      make sure we lay it out again.  */\n \n-  TYPE_SIZE (t) = 0;\n+  TYPE_SIZE (t) = NULL_TREE;\n \n   decl_attributes (&t, attributes, (int) ATTR_FLAG_TYPE_IN_PLACE);\n \n   if (pedantic)\n     {\n       for (x = fieldlist; x; x = DECL_CHAIN (x))\n \t{\n-\t  if (DECL_NAME (x) != 0)\n+\t  if (DECL_NAME (x) != NULL_TREE)\n \t    break;\n \t  if (flag_isoc11 && RECORD_OR_UNION_TYPE_P (TREE_TYPE (x)))\n \t    break;\n \t}\n \n-      if (x == 0)\n+      if (x == NULL_TREE)\n \t{\n \t  if (TREE_CODE (t) == UNION_TYPE)\n \t    {\n@@ -8018,7 +8019,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \t\t= c_build_bitfield_integer_type (width, TYPE_UNSIGNED (type));\n \t      SET_DECL_MODE (field, TYPE_MODE (TREE_TYPE (field)));\n \t    }\n-\t  DECL_INITIAL (field) = 0;\n+\t  DECL_INITIAL (field) = NULL_TREE;\n \t}\n       else if (TYPE_REVERSE_STORAGE_ORDER (t)\n \t       && TREE_CODE (field) == FIELD_DECL\n@@ -8218,7 +8219,7 @@ start_enum (location_t loc, struct c_enum_contents *the_enum, tree name)\n \n   C_TYPE_BEING_DEFINED (enumtype) = 1;\n \n-  if (TYPE_VALUES (enumtype) != 0)\n+  if (TYPE_VALUES (enumtype) != NULL_TREE)\n     {\n       /* This enum is a named one that has been declared already.  */\n       error_at (loc, \"redeclaration of %<enum %E%>\", name);\n@@ -8227,7 +8228,7 @@ start_enum (location_t loc, struct c_enum_contents *the_enum, tree name)\n \n       /* Completely replace its old definition.\n \t The old enumerators remain defined, however.  */\n-      TYPE_VALUES (enumtype) = 0;\n+      TYPE_VALUES (enumtype) = NULL_TREE;\n     }\n \n   the_enum->enum_next_value = integer_zero_node;\n@@ -8260,7 +8261,7 @@ tree\n finish_enum (tree enumtype, tree values, tree attributes)\n {\n   tree pair, tem;\n-  tree minnode = 0, maxnode = 0;\n+  tree minnode = NULL_TREE, maxnode = NULL_TREE;\n   int precision;\n   signop sign;\n   bool toplevel = (file_scope == current_scope);\n@@ -8326,7 +8327,7 @@ finish_enum (tree enumtype, tree values, tree attributes)\n   TYPE_MAX_VALUE (enumtype) = TYPE_MAX_VALUE (tem);\n   TYPE_UNSIGNED (enumtype) = TYPE_UNSIGNED (tem);\n   SET_TYPE_ALIGN (enumtype, TYPE_ALIGN (tem));\n-  TYPE_SIZE (enumtype) = 0;\n+  TYPE_SIZE (enumtype) = NULL_TREE;\n   TYPE_PRECISION (enumtype) = TYPE_PRECISION (tem);\n \n   layout_type (enumtype);\n@@ -8421,17 +8422,17 @@ build_enumerator (location_t decl_loc, location_t loc,\n \n   /* Validate and default VALUE.  */\n \n-  if (value != 0)\n+  if (value != NULL_TREE)\n     {\n       /* Don't issue more errors for error_mark_node (i.e. an\n \t undeclared identifier) - just ignore the value expression.  */\n       if (value == error_mark_node)\n-\tvalue = 0;\n+\tvalue = NULL_TREE;\n       else if (!INTEGRAL_TYPE_P (TREE_TYPE (value)))\n \t{\n \t  error_at (loc, \"enumerator value for %qE is not an integer constant\",\n \t\t    name);\n-\t  value = 0;\n+\t  value = NULL_TREE;\n \t}\n       else\n \t{\n@@ -8447,7 +8448,7 @@ build_enumerator (location_t decl_loc, location_t loc,\n \t    {\n \t      error (\"enumerator value for %qE is not an integer constant\",\n \t\t     name);\n-\t      value = 0;\n+\t      value = NULL_TREE;\n \t    }\n \t  else\n \t    {\n@@ -8460,7 +8461,7 @@ build_enumerator (location_t decl_loc, location_t loc,\n   /* Default based on previous value.  */\n   /* It should no longer be possible to have NON_LVALUE_EXPR\n      in the default.  */\n-  if (value == 0)\n+  if (value == NULL_TREE)\n     {\n       value = the_enum->enum_next_value;\n       if (the_enum->enum_overflow)\n@@ -8546,7 +8547,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \n   /* If the declarator is not suitable for a function definition,\n      cause a syntax error.  */\n-  if (decl1 == 0\n+  if (decl1 == NULL_TREE\n       || TREE_CODE (decl1) != FUNCTION_DECL)\n     return 0;\n \n@@ -8594,20 +8595,21 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n   DECL_INITIAL (decl1) = error_mark_node;\n \n   /* A nested function is not global.  */\n-  if (current_function_decl != 0)\n+  if (current_function_decl != NULL_TREE)\n     TREE_PUBLIC (decl1) = 0;\n \n   /* If this definition isn't a prototype and we had a prototype declaration\n      before, copy the arg type info from that prototype.  */\n   old_decl = lookup_name_in_scope (DECL_NAME (decl1), current_scope);\n   if (old_decl && TREE_CODE (old_decl) != FUNCTION_DECL)\n-    old_decl = 0;\n+    old_decl = NULL_TREE;\n   current_function_prototype_locus = UNKNOWN_LOCATION;\n   current_function_prototype_built_in = false;\n   current_function_prototype_arg_types = NULL_TREE;\n   if (!prototype_p (TREE_TYPE (decl1)))\n     {\n-      if (old_decl != 0 && TREE_CODE (TREE_TYPE (old_decl)) == FUNCTION_TYPE\n+      if (old_decl != NULL_TREE\n+\t  && TREE_CODE (TREE_TYPE (old_decl)) == FUNCTION_TYPE\n \t  && comptypes (TREE_TYPE (TREE_TYPE (decl1)),\n \t\t\tTREE_TYPE (TREE_TYPE (old_decl))))\n \t{\n@@ -8676,7 +8678,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n   /* Optionally warn of any def with no previous prototype\n      if the function has already been used.  */\n   else if (warn_missing_prototypes\n-\t   && old_decl != 0\n+\t   && old_decl != NULL_TREE\n \t   && old_decl != error_mark_node\n \t   && TREE_USED (old_decl)\n \t   && !prototype_p (TREE_TYPE (old_decl)))\n@@ -8685,7 +8687,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n   /* Optionally warn of any global def with no previous declaration.  */\n   else if (warn_missing_declarations\n \t   && TREE_PUBLIC (decl1)\n-\t   && old_decl == 0\n+\t   && old_decl == NULL_TREE\n \t   && !MAIN_NAME_P (DECL_NAME (decl1))\n \t   && !DECL_DECLARED_INLINE_P (decl1))\n     warning_at (loc, OPT_Wmissing_declarations,\n@@ -8694,7 +8696,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n   /* Optionally warn of any def with no previous declaration\n      if the function has already been used.  */\n   else if (warn_missing_declarations\n-\t   && old_decl != 0\n+\t   && old_decl != NULL_TREE\n \t   && old_decl != error_mark_node\n \t   && TREE_USED (old_decl)\n \t   && C_DECL_IMPLICIT (old_decl))\n@@ -8838,11 +8840,11 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n      decl in the appropriate TREE_PURPOSE slot of the parmids chain.  */\n   for (parm = parmids; parm; parm = TREE_CHAIN (parm))\n     {\n-      if (TREE_VALUE (parm) == 0)\n+      if (TREE_VALUE (parm) == NULL_TREE)\n \t{\n \t  error_at (DECL_SOURCE_LOCATION (fndecl),\n \t\t    \"parameter name missing from parameter list\");\n-\t  TREE_PURPOSE (parm) = 0;\n+\t  TREE_PURPOSE (parm) = NULL_TREE;\n \t  continue;\n \t}\n \n@@ -8866,7 +8868,7 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t    {\n \t      error_at (DECL_SOURCE_LOCATION (decl),\n \t\t\t\"multiple parameters named %qD\", decl);\n-\t      TREE_PURPOSE (parm) = 0;\n+\t      TREE_PURPOSE (parm) = NULL_TREE;\n \t      continue;\n \t    }\n \t  /* If the declaration says \"void\", complain and turn it into\n@@ -8948,7 +8950,7 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n   /* Chain the declarations together in the order of the list of\n      names.  Store that chain in the function decl, replacing the\n      list of names.  Update the current scope to match.  */\n-  DECL_ARGUMENTS (fndecl) = 0;\n+  DECL_ARGUMENTS (fndecl) = NULL_TREE;\n \n   for (parm = parmids; parm; parm = TREE_CHAIN (parm))\n     if (TREE_PURPOSE (parm))\n@@ -8964,7 +8966,7 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t    DECL_CHAIN (last) = TREE_PURPOSE (parm);\n \t    last = TREE_PURPOSE (parm);\n \t  }\n-      DECL_CHAIN (last) = 0;\n+      DECL_CHAIN (last) = NULL_TREE;\n     }\n \n   /* If there was a previous prototype,\n@@ -9068,14 +9070,14 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t\t}\n \t    }\n \t}\n-      TYPE_ACTUAL_ARG_TYPES (TREE_TYPE (fndecl)) = 0;\n+      TYPE_ACTUAL_ARG_TYPES (TREE_TYPE (fndecl)) = NULL_TREE;\n     }\n \n   /* Otherwise, create a prototype that would match.  */\n \n   else\n     {\n-      tree actual = 0, last = 0, type;\n+      tree actual = NULL_TREE, last = NULL_TREE, type;\n \n       for (parm = DECL_ARGUMENTS (fndecl); parm; parm = DECL_CHAIN (parm))\n \t{\n@@ -9558,7 +9560,7 @@ c_pop_function_context (void)\n       /* But DECL_INITIAL must remain nonzero so we know this\n \t was an actual function definition.  */\n       DECL_INITIAL (current_function_decl) = error_mark_node;\n-      DECL_ARGUMENTS (current_function_decl) = 0;\n+      DECL_ARGUMENTS (current_function_decl) = NULL_TREE;\n     }\n \n   c_stmt_tree = p->base.x_stmt_tree;\n@@ -11122,7 +11124,7 @@ c_write_global_declarations_1 (tree globals)\n \t standard's definition of \"used\", and set TREE_NO_WARNING so\n \t that check_global_declaration doesn't repeat the check.  */\n       if (TREE_CODE (decl) == FUNCTION_DECL\n-\t  && DECL_INITIAL (decl) == 0\n+\t  && DECL_INITIAL (decl) == NULL_TREE\n \t  && DECL_EXTERNAL (decl)\n \t  && !TREE_PUBLIC (decl))\n \t{"}, {"sha": "4c75c3237bd831d57fd70dda3baf1dd894d464ca", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 95, "deletions": 92, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa8871b0c1386f60e32929c0aa307a99b5a5b65/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa8871b0c1386f60e32929c0aa307a99b5a5b65/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=3fa8871b0c1386f60e32929c0aa307a99b5a5b65", "patch": "@@ -216,7 +216,7 @@ c_incomplete_type_error (location_t loc, const_tree value, const_tree type)\n   if (TREE_CODE (type) == ERROR_MARK)\n     return;\n \n-  if (value != 0 && (VAR_P (value) || TREE_CODE (value) == PARM_DECL))\n+  if (value != NULL_TREE && (VAR_P (value) || TREE_CODE (value) == PARM_DECL))\n     error_at (loc, \"%qD has an incomplete type %qT\", value, type);\n   else\n     {\n@@ -422,8 +422,8 @@ composite_type (tree t1, tree t2)\n \tt1_complete = COMPLETE_TYPE_P (t1);\n \tt2_complete = COMPLETE_TYPE_P (t2);\n \n-\td1_zero = d1 == 0 || !TYPE_MAX_VALUE (d1);\n-\td2_zero = d2 == 0 || !TYPE_MAX_VALUE (d2);\n+\td1_zero = d1 == NULL_TREE || !TYPE_MAX_VALUE (d1);\n+\td2_zero = d2 == NULL_TREE || !TYPE_MAX_VALUE (d2);\n \n \td1_variable = (!d1_zero\n \t\t       && (TREE_CODE (TYPE_MIN_VALUE (d1)) != INTEGER_CST\n@@ -505,13 +505,13 @@ composite_type (tree t1, tree t2)\n \t  return build_type_attribute_variant (t2, attributes);\n \n \t/* Simple way if one arg fails to specify argument types.  */\n-\tif (TYPE_ARG_TYPES (t1) == 0)\n+\tif (TYPE_ARG_TYPES (t1) == NULL_TREE)\n \t {\n \t    t1 = build_function_type (valtype, TYPE_ARG_TYPES (t2));\n \t    t1 = build_type_attribute_variant (t1, attributes);\n \t    return qualify_type (t1, t2);\n \t }\n-\tif (TYPE_ARG_TYPES (t2) == 0)\n+\tif (TYPE_ARG_TYPES (t2) == NULL_TREE)\n \t {\n \t   t1 = build_function_type (valtype, TYPE_ARG_TYPES (t1));\n \t   t1 = build_type_attribute_variant (t1, attributes);\n@@ -536,12 +536,12 @@ composite_type (tree t1, tree t2)\n \t  {\n \t    /* A null type means arg type is not specified.\n \t       Take whatever the other function type has.  */\n-\t    if (TREE_VALUE (p1) == 0)\n+\t    if (TREE_VALUE (p1) == NULL_TREE)\n \t      {\n \t\tTREE_VALUE (n) = TREE_VALUE (p2);\n \t\tgoto parm_done;\n \t      }\n-\t    if (TREE_VALUE (p2) == 0)\n+\t    if (TREE_VALUE (p2) == NULL_TREE)\n \t      {\n \t\tTREE_VALUE (n) = TREE_VALUE (p1);\n \t\tgoto parm_done;\n@@ -1178,10 +1178,10 @@ comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p,\n \t  return 0;\n \n \tif (different_types_p != NULL\n-\t    && (d1 == 0) != (d2 == 0))\n+\t    && (d1 == NULL_TREE) != (d2 == NULL_TREE))\n \t  *different_types_p = true;\n \t/* Sizes must match unless one is missing or variable.  */\n-\tif (d1 == 0 || d2 == 0 || d1 == d2)\n+\tif (d1 == NULL_TREE || d2 == NULL_TREE || d1 == d2)\n \t  break;\n \n \td1_zero = !TYPE_MAX_VALUE (d1);\n@@ -1642,13 +1642,13 @@ function_types_compatible_p (const_tree f1, const_tree f2,\n   args2 = TYPE_ARG_TYPES (f2);\n \n   if (different_types_p != NULL\n-      && (args1 == 0) != (args2 == 0))\n+      && (args1 == NULL_TREE) != (args2 == NULL_TREE))\n     *different_types_p = true;\n \n   /* An unspecified parmlist matches any specified parmlist\n      whose argument types don't need default promotions.  */\n \n-  if (args1 == 0)\n+  if (args1 == NULL_TREE)\n     {\n       if (!self_promoting_args_p (args2))\n \treturn 0;\n@@ -1661,7 +1661,7 @@ function_types_compatible_p (const_tree f1, const_tree f2,\n \tval = 2;\n       return val;\n     }\n-  if (args2 == 0)\n+  if (args2 == NULL_TREE)\n     {\n       if (!self_promoting_args_p (args1))\n \treturn 0;\n@@ -1694,11 +1694,11 @@ type_lists_compatible_p (const_tree args1, const_tree args2,\n   while (1)\n     {\n       tree a1, mv1, a2, mv2;\n-      if (args1 == 0 && args2 == 0)\n+      if (args1 == NULL_TREE && args2 == NULL_TREE)\n \treturn val;\n       /* If one list is shorter than the other,\n \t they fail to match.  */\n-      if (args1 == 0 || args2 == 0)\n+      if (args1 == NULL_TREE || args2 == NULL_TREE)\n \treturn 0;\n       mv1 = a1 = TREE_VALUE (args1);\n       mv2 = a2 = TREE_VALUE (args2);\n@@ -1717,14 +1717,14 @@ type_lists_compatible_p (const_tree args1, const_tree args2,\n \t but nothing is specified about what type it has.\n \t So match anything that self-promotes.  */\n       if (different_types_p != NULL\n-\t  && (a1 == 0) != (a2 == 0))\n+\t  && (a1 == NULL_TREE) != (a2 == NULL_TREE))\n \t*different_types_p = true;\n-      if (a1 == 0)\n+      if (a1 == NULL_TREE)\n \t{\n \t  if (c_type_promotes_to (a2) != a2)\n \t    return 0;\n \t}\n-      else if (a2 == 0)\n+      else if (a2 == NULL_TREE)\n \t{\n \t  if (c_type_promotes_to (a1) != a1)\n \t    return 0;\n@@ -1741,7 +1741,7 @@ type_lists_compatible_p (const_tree args1, const_tree args2,\n \t  /* Allow  wait (union {union wait *u; int *i} *)\n \t     and  wait (union wait *)  to be compatible.  */\n \t  if (TREE_CODE (a1) == UNION_TYPE\n-\t      && (TYPE_NAME (a1) == 0\n+\t      && (TYPE_NAME (a1) == NULL_TREE\n \t\t  || TYPE_TRANSPARENT_AGGR (a1))\n \t      && TREE_CODE (TYPE_SIZE (a1)) == INTEGER_CST\n \t      && tree_int_cst_equal (TYPE_SIZE (a1),\n@@ -1762,11 +1762,11 @@ type_lists_compatible_p (const_tree args1, const_tree args2,\n \t\t\t\t\t  different_types_p))\n \t\t    break;\n \t\t}\n-\t      if (memb == 0)\n+\t      if (memb == NULL_TREE)\n \t\treturn 0;\n \t    }\n \t  else if (TREE_CODE (a2) == UNION_TYPE\n-\t\t   && (TYPE_NAME (a2) == 0\n+\t\t   && (TYPE_NAME (a2) == NULL_TREE\n \t\t       || TYPE_TRANSPARENT_AGGR (a2))\n \t\t   && TREE_CODE (TYPE_SIZE (a2)) == INTEGER_CST\n \t\t   && tree_int_cst_equal (TYPE_SIZE (a2),\n@@ -1787,7 +1787,7 @@ type_lists_compatible_p (const_tree args1, const_tree args2,\n \t\t\t\t\t  different_types_p))\n \t\t    break;\n \t\t}\n-\t      if (memb == 0)\n+\t      if (memb == NULL_TREE)\n \t\treturn 0;\n \t    }\n \t  else\n@@ -1831,11 +1831,11 @@ decl_constant_value (tree decl)\n   if (/* Don't change a variable array bound or initial value to a constant\n \t in a place where a variable is invalid.  Note that DECL_INITIAL\n \t isn't valid for a PARM_DECL.  */\n-      current_function_decl != 0\n+      current_function_decl != NULL_TREE\n       && TREE_CODE (decl) != PARM_DECL\n       && !TREE_THIS_VOLATILE (decl)\n       && TREE_READONLY (decl)\n-      && DECL_INITIAL (decl) != 0\n+      && DECL_INITIAL (decl) != NULL_TREE\n       && TREE_CODE (DECL_INITIAL (decl)) != ERROR_MARK\n       /* This is invalid if initial value is not constant.\n \t If it has either a function call, a memory reference,\n@@ -2777,7 +2777,7 @@ build_external_ref (location_t loc, tree id, int fun, tree *type)\n     {\n       if (!in_sizeof && !in_typeof)\n \tC_DECL_USED (ref) = 1;\n-      else if (DECL_INITIAL (ref) == 0\n+      else if (DECL_INITIAL (ref) == NULL_TREE\n \t       && DECL_EXTERNAL (ref)\n \t       && !TREE_PUBLIC (ref))\n \trecord_maybe_used_decl (ref);\n@@ -2800,20 +2800,20 @@ build_external_ref (location_t loc, tree id, int fun, tree *type)\n       ref = DECL_INITIAL (ref);\n       TREE_CONSTANT (ref) = 1;\n     }\n-  else if (current_function_decl != 0\n+  else if (current_function_decl != NULL_TREE\n \t   && !DECL_FILE_SCOPE_P (current_function_decl)\n \t   && (VAR_OR_FUNCTION_DECL_P (ref)\n \t       || TREE_CODE (ref) == PARM_DECL))\n     {\n       tree context = decl_function_context (ref);\n \n-      if (context != 0 && context != current_function_decl)\n+      if (context != NULL_TREE && context != current_function_decl)\n \tDECL_NONLOCAL (ref) = 1;\n     }\n   /* C99 6.7.4p3: An inline definition of a function with external\n      linkage ... shall not contain a reference to an identifier with\n      internal linkage.  */\n-  else if (current_function_decl != 0\n+  else if (current_function_decl != NULL_TREE\n \t   && DECL_DECLARED_INLINE_P (current_function_decl)\n \t   && DECL_EXTERNAL (current_function_decl)\n \t   && VAR_OR_FUNCTION_DECL_P (ref)\n@@ -3003,7 +3003,7 @@ build_function_call_vec (location_t loc, vec<location_t> arg_loc,\n \t\t\t tree function, vec<tree, va_gc> *params,\n \t\t\t vec<tree, va_gc> *origtypes)\n {\n-  tree fntype, fundecl = 0;\n+  tree fntype, fundecl = NULL_TREE;\n   tree name = NULL_TREE, result;\n   tree tem;\n   int nargs;\n@@ -3337,7 +3337,7 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t      }\n \t}\n \n-      if (type != 0)\n+      if (type != NULL_TREE)\n \t{\n \t  /* Formal parm type is specified by a function prototype.  */\n \n@@ -3552,7 +3552,7 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \n   gcc_assert (parmnum == vec_safe_length (values));\n \n-  if (typetail != 0 && TREE_VALUE (typetail) != void_type_node)\n+  if (typetail != NULL_TREE && TREE_VALUE (typetail) != void_type_node)\n     {\n       error_at (loc, \"too few arguments to function %qE\", function);\n       inform_declaration (fundecl);\n@@ -4162,7 +4162,7 @@ build_unary_op (location_t location, enum tree_code code, tree xarg,\n {\n   /* No default_conversion here.  It causes trouble for ADDR_EXPR.  */\n   tree arg = xarg;\n-  tree argtype = 0;\n+  tree argtype = NULL_TREE;\n   enum tree_code typecode;\n   tree val;\n   tree ret = error_mark_node;\n@@ -4651,7 +4651,7 @@ build_unary_op (location_t location, enum tree_code code, tree xarg,\n       gcc_unreachable ();\n     }\n \n-  if (argtype == 0)\n+  if (argtype == NULL_TREE)\n     argtype = TREE_TYPE (arg);\n   if (TREE_CODE (arg) == INTEGER_CST)\n     ret = (require_constant_value\n@@ -6906,7 +6906,7 @@ store_init_value (location_t init_loc, tree decl, tree init, tree origtype)\n \n   /* Check if we need to set array size from compound literal size.  */\n   if (TREE_CODE (type) == ARRAY_TYPE\n-      && TYPE_DOMAIN (type) == 0\n+      && TYPE_DOMAIN (type) == NULL_TREE\n       && value != error_mark_node)\n     {\n       tree inside_init = init;\n@@ -7162,8 +7162,8 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \t    }\n \n \t  TREE_TYPE (inside_init) = type;\n-\t  if (TYPE_DOMAIN (type) != 0\n-\t      && TYPE_SIZE (type) != 0\n+\t  if (TYPE_DOMAIN (type) != NULL_TREE\n+\t      && TYPE_SIZE (type) != NULL_TREE\n \t      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)\n \t    {\n \t      unsigned HOST_WIDE_INT len = TREE_STRING_LENGTH (inside_init);\n@@ -7235,7 +7235,7 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n   /* Any type can be initialized\n      from an expression of the same type, optionally with braces.  */\n \n-  if (inside_init && TREE_TYPE (inside_init) != 0\n+  if (inside_init && TREE_TYPE (inside_init) != NULL_TREE\n       && (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (inside_init)),\n \t\t     TYPE_MAIN_VARIANT (type))\n \t  || (code == ARRAY_TYPE\n@@ -7576,7 +7576,7 @@ start_init (tree decl, tree asmspec_tree ATTRIBUTE_UNUSED, int top_level,\n   constructor_designated = 0;\n   constructor_top_level = top_level;\n \n-  if (decl != 0 && decl != error_mark_node)\n+  if (decl != NULL_TREE && decl != error_mark_node)\n     {\n       require_constant_value = TREE_STATIC (decl);\n       require_constant_elements\n@@ -7650,7 +7650,7 @@ really_start_incremental_init (tree type)\n {\n   struct constructor_stack *p = XNEW (struct constructor_stack);\n \n-  if (type == 0)\n+  if (type == NULL_TREE)\n     type = TREE_TYPE (constructor_decl);\n \n   if (VECTOR_TYPE_P (type)\n@@ -7700,8 +7700,9 @@ really_start_incremental_init (tree type)\n     {\n       constructor_fields = TYPE_FIELDS (constructor_type);\n       /* Skip any nameless bit fields at the beginning.  */\n-      while (constructor_fields != 0 && DECL_C_BIT_FIELD (constructor_fields)\n-\t     && DECL_NAME (constructor_fields) == 0)\n+      while (constructor_fields != NULL_TREE\n+\t     && DECL_C_BIT_FIELD (constructor_fields)\n+\t     && DECL_NAME (constructor_fields) == NULL_TREE)\n \tconstructor_fields = DECL_CHAIN (constructor_fields);\n \n       constructor_unfilled_fields = constructor_fields;\n@@ -7764,7 +7765,7 @@ finish_implicit_inits (location_t loc, struct obstack *braced_init_obstack)\n   while (constructor_stack->implicit)\n     {\n       if (RECORD_OR_UNION_TYPE_P (constructor_type)\n-\t  && constructor_fields == 0)\n+\t  && constructor_fields == NULL_TREE)\n \tprocess_init_element (input_location,\n \t\t\t      pop_init_level (loc, 1, braced_init_obstack,\n \t\t\t\t\t      last_init_list_comma),\n@@ -7819,7 +7820,7 @@ push_init_level (location_t loc, int implicit,\n   p->erroneous = constructor_erroneous;\n   p->pending_elts = constructor_pending_elts;\n   p->depth = constructor_depth;\n-  p->replacement_value.value = 0;\n+  p->replacement_value.value = NULL_TREE;\n   p->replacement_value.original_code = ERROR_MARK;\n   p->replacement_value.original_type = NULL;\n   p->implicit = implicit;\n@@ -7849,13 +7850,13 @@ push_init_level (location_t loc, int implicit,\n \n   /* Don't die if an entire brace-pair level is superfluous\n      in the containing level.  */\n-  if (constructor_type == 0)\n+  if (constructor_type == NULL_TREE)\n     ;\n   else if (RECORD_OR_UNION_TYPE_P (constructor_type))\n     {\n       /* Don't die if there are extra init elts at the end.  */\n-      if (constructor_fields == 0)\n-\tconstructor_type = 0;\n+      if (constructor_fields == NULL_TREE)\n+\tconstructor_type = NULL_TREE;\n       else\n \t{\n \t  constructor_type = TREE_TYPE (constructor_fields);\n@@ -7873,11 +7874,11 @@ push_init_level (location_t loc, int implicit,\n       constructor_depth++;\n     }\n \n-  if (constructor_type == 0)\n+  if (constructor_type == NULL_TREE)\n     {\n       error_init (loc, \"extra brace group at end of initializer\");\n-      constructor_fields = 0;\n-      constructor_unfilled_fields = 0;\n+      constructor_fields = NULL_TREE;\n+      constructor_unfilled_fields = NULL_TREE;\n       return;\n     }\n \n@@ -7905,8 +7906,9 @@ push_init_level (location_t loc, int implicit,\n     {\n       constructor_fields = TYPE_FIELDS (constructor_type);\n       /* Skip any nameless bit fields at the beginning.  */\n-      while (constructor_fields != 0 && DECL_C_BIT_FIELD (constructor_fields)\n-\t     && DECL_NAME (constructor_fields) == 0)\n+      while (constructor_fields != NULL_TREE\n+\t     && DECL_C_BIT_FIELD (constructor_fields)\n+\t     && DECL_NAME (constructor_fields) == NULL_TREE)\n \tconstructor_fields = DECL_CHAIN (constructor_fields);\n \n       constructor_unfilled_fields = constructor_fields;\n@@ -7982,7 +7984,7 @@ pop_init_level (location_t loc, int implicit,\n {\n   struct constructor_stack *p;\n   struct c_expr ret;\n-  ret.value = 0;\n+  ret.value = NULL_TREE;\n   ret.original_code = ERROR_MARK;\n   ret.original_type = NULL;\n \n@@ -8097,7 +8099,7 @@ pop_init_level (location_t loc, int implicit,\n     /* If this closes a superfluous brace pair,\n        just pass out the element between them.  */\n     ret = p->replacement_value;\n-  else if (constructor_type == 0)\n+  else if (constructor_type == NULL_TREE)\n     ;\n   else if (!RECORD_OR_UNION_TYPE_P (constructor_type)\n \t   && TREE_CODE (constructor_type) != ARRAY_TYPE\n@@ -8168,7 +8170,7 @@ pop_init_level (location_t loc, int implicit,\n   constructor_stack = p->next;\n   free (p);\n \n-  if (ret.value == 0 && constructor_stack == 0)\n+  if (ret.value == NULL_TREE && constructor_stack == 0)\n     ret.value = error_mark_node;\n   return ret;\n }\n@@ -8185,7 +8187,7 @@ set_designator (location_t loc, int array,\n \n   /* Don't die if an entire brace-pair level is superfluous\n      in the containing level.  */\n-  if (constructor_type == 0)\n+  if (constructor_type == NULL_TREE)\n     return 1;\n \n   /* If there were errors in this designator list already, bail out\n@@ -8305,7 +8307,7 @@ set_init_index (location_t loc, tree first, tree last,\n \n   if (TREE_CODE (first) != INTEGER_CST)\n     error_init (loc, \"nonconstant array index in initializer\");\n-  else if (last != 0 && TREE_CODE (last) != INTEGER_CST)\n+  else if (last != NULL_TREE && TREE_CODE (last) != INTEGER_CST)\n     error_init (loc, \"nonconstant array index in initializer\");\n   else if (TREE_CODE (constructor_type) != ARRAY_TYPE)\n     error_init (loc, \"array index in non-array initializer\");\n@@ -8329,21 +8331,21 @@ set_init_index (location_t loc, tree first, tree last,\n       if (last)\n \t{\n \t  if (tree_int_cst_equal (first, last))\n-\t    last = 0;\n+\t    last = NULL_TREE;\n \t  else if (tree_int_cst_lt (last, first))\n \t    {\n \t      error_init (loc, \"empty index range in initializer\");\n-\t      last = 0;\n+\t      last = NULL_TREE;\n \t    }\n \t  else\n \t    {\n \t      last = convert (bitsizetype, last);\n-\t      if (constructor_max_index != 0\n+\t      if (constructor_max_index != NULL_TREE\n \t\t  && tree_int_cst_lt (constructor_max_index, last))\n \t\t{\n \t\t  error_init (loc, \"array index range in initializer exceeds \"\n \t\t\t      \"array bounds\");\n-\t\t  last = 0;\n+\t\t  last = NULL_TREE;\n \t\t}\n \t    }\n \t}\n@@ -8376,7 +8378,7 @@ set_init_label (location_t loc, tree fieldname, location_t fieldname_loc,\n \n   field = lookup_field (constructor_type, fieldname);\n \n-  if (field == 0)\n+  if (field == NULL_TREE)\n     {\n       tree guessed_id = lookup_field_fuzzy (constructor_type, fieldname);\n       if (guessed_id)\n@@ -8674,9 +8676,9 @@ set_nonincremental_init (struct obstack * braced_init_obstack)\n     {\n       constructor_unfilled_fields = TYPE_FIELDS (constructor_type);\n       /* Skip any nameless bit fields at the beginning.  */\n-      while (constructor_unfilled_fields != 0\n+      while (constructor_unfilled_fields != NULL_TREE\n \t     && DECL_C_BIT_FIELD (constructor_unfilled_fields)\n-\t     && DECL_NAME (constructor_unfilled_fields) == 0)\n+\t     && DECL_NAME (constructor_unfilled_fields) == NULL_TREE)\n \tconstructor_unfilled_fields = TREE_CHAIN (constructor_unfilled_fields);\n \n     }\n@@ -9044,14 +9046,14 @@ output_init_element (location_t loc, tree value, tree origtype,\n \t= DECL_CHAIN (constructor_unfilled_fields);\n \n       /* Skip any nameless bit fields.  */\n-      while (constructor_unfilled_fields != 0\n+      while (constructor_unfilled_fields != NULL_TREE\n \t     && DECL_C_BIT_FIELD (constructor_unfilled_fields)\n-\t     && DECL_NAME (constructor_unfilled_fields) == 0)\n+\t     && DECL_NAME (constructor_unfilled_fields) == NULL_TREE)\n \tconstructor_unfilled_fields =\n \t  DECL_CHAIN (constructor_unfilled_fields);\n     }\n   else if (TREE_CODE (constructor_type) == UNION_TYPE)\n-    constructor_unfilled_fields = 0;\n+    constructor_unfilled_fields = NULL_TREE;\n \n   /* Now output any pending elements which have become next.  */\n   if (pending)\n@@ -9081,7 +9083,7 @@ output_pending_init_elements (int all, struct obstack * braced_init_obstack)\n      output it.  Otherwise, set NEXT to the element\n      that comes first among those still pending.  */\n \n-  next = 0;\n+  next = NULL_TREE;\n   while (elt)\n     {\n       if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n@@ -9132,7 +9134,7 @@ output_pending_init_elements (int all, struct obstack * braced_init_obstack)\n \t  tree ctor_unfilled_bitpos, elt_bitpos;\n \n \t  /* If the current record is complete we are done.  */\n-\t  if (constructor_unfilled_fields == 0)\n+\t  if (constructor_unfilled_fields == NULL_TREE)\n \t    break;\n \n \t  ctor_unfilled_bitpos = bit_position (constructor_unfilled_fields);\n@@ -9186,7 +9188,7 @@ output_pending_init_elements (int all, struct obstack * braced_init_obstack)\n \n   /* Ordinarily return, but not if we want to output all\n      and there are elements left.  */\n-  if (!(all && next != 0))\n+  if (!(all && next != NULL_TREE))\n     return;\n \n   /* If it's not incremental, just skip over the gap, so that after\n@@ -9219,7 +9221,8 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t\t      struct obstack * braced_init_obstack)\n {\n   tree orig_value = value.value;\n-  int string_flag = orig_value != 0 && TREE_CODE (orig_value) == STRING_CST;\n+  int string_flag\n+    = (orig_value != NULL_TREE && TREE_CODE (orig_value) == STRING_CST);\n   bool strict_string = value.original_code == STRING_CST;\n   bool was_designated = designator_depth != 0;\n \n@@ -9244,15 +9247,15 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n       return;\n     }\n \n-  if (constructor_stack->replacement_value.value != 0)\n+  if (constructor_stack->replacement_value.value != NULL_TREE)\n     {\n       error_init (loc, \"excess elements in struct initializer\");\n       return;\n     }\n \n   /* Ignore elements of a brace group if it is entirely superfluous\n      and has already been diagnosed.  */\n-  if (constructor_type == 0)\n+  if (constructor_type == NULL_TREE)\n     return;\n \n   if (!implicit && warn_designated_init && !was_designated\n@@ -9269,7 +9272,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n   while (constructor_stack->implicit)\n     {\n       if (RECORD_OR_UNION_TYPE_P (constructor_type)\n-\t  && constructor_fields == 0)\n+\t  && constructor_fields == NULL_TREE)\n \tprocess_init_element (loc,\n \t\t\t      pop_init_level (loc, 1, braced_init_obstack,\n \t\t\t\t\t      last_init_list_comma),\n@@ -9315,7 +9318,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t  tree fieldtype;\n \t  enum tree_code fieldcode;\n \n-\t  if (constructor_fields == 0)\n+\t  if (constructor_fields == NULL_TREE)\n \t    {\n \t      pedwarn_init (loc, 0, \"excess elements in struct initializer\");\n \t      break;\n@@ -9365,14 +9368,14 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t    }\n \n \t  /* Accept a string constant to initialize a subarray.  */\n-\t  if (value.value != 0\n+\t  if (value.value != NULL_TREE\n \t      && fieldcode == ARRAY_TYPE\n \t      && INTEGRAL_TYPE_P (TREE_TYPE (fieldtype))\n \t      && string_flag)\n \t    value.value = orig_value;\n \t  /* Otherwise, if we have come to a subaggregate,\n \t     and we don't have an element of its type, push into it.  */\n-\t  else if (value.value != 0\n+\t  else if (value.value != NULL_TREE\n \t\t   && value.value != error_mark_node\n \t\t   && TYPE_MAIN_VARIANT (TREE_TYPE (value.value)) != fieldtype\n \t\t   && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE\n@@ -9418,17 +9421,17 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \n \t  constructor_fields = DECL_CHAIN (constructor_fields);\n \t  /* Skip any nameless bit fields at the beginning.  */\n-\t  while (constructor_fields != 0\n+\t  while (constructor_fields != NULL_TREE\n \t\t && DECL_C_BIT_FIELD (constructor_fields)\n-\t\t && DECL_NAME (constructor_fields) == 0)\n+\t\t && DECL_NAME (constructor_fields) == NULL_TREE)\n \t    constructor_fields = DECL_CHAIN (constructor_fields);\n \t}\n       else if (TREE_CODE (constructor_type) == UNION_TYPE)\n \t{\n \t  tree fieldtype;\n \t  enum tree_code fieldcode;\n \n-\t  if (constructor_fields == 0)\n+\t  if (constructor_fields == NULL_TREE)\n \t    {\n \t      pedwarn_init (loc, 0,\n \t\t\t    \"excess elements in union initializer\");\n@@ -9457,14 +9460,14 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t\t     \"of unions\");\n \n \t  /* Accept a string constant to initialize a subarray.  */\n-\t  if (value.value != 0\n+\t  if (value.value != NULL_TREE\n \t      && fieldcode == ARRAY_TYPE\n \t      && INTEGRAL_TYPE_P (TREE_TYPE (fieldtype))\n \t      && string_flag)\n \t    value.value = orig_value;\n \t  /* Otherwise, if we have come to a subaggregate,\n \t     and we don't have an element of its type, push into it.  */\n-\t  else if (value.value != 0\n+\t  else if (value.value != NULL_TREE\n \t\t   && value.value != error_mark_node\n \t\t   && TYPE_MAIN_VARIANT (TREE_TYPE (value.value)) != fieldtype\n \t\t   && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE\n@@ -9491,22 +9494,22 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t      constructor_unfilled_fields = DECL_CHAIN (constructor_fields);\n \t    }\n \n-\t  constructor_fields = 0;\n+\t  constructor_fields = NULL_TREE;\n \t}\n       else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n \t{\n \t  tree elttype = TYPE_MAIN_VARIANT (TREE_TYPE (constructor_type));\n \t  enum tree_code eltcode = TREE_CODE (elttype);\n \n \t  /* Accept a string constant to initialize a subarray.  */\n-\t  if (value.value != 0\n+\t  if (value.value != NULL_TREE\n \t      && eltcode == ARRAY_TYPE\n \t      && INTEGRAL_TYPE_P (TREE_TYPE (elttype))\n \t      && string_flag)\n \t    value.value = orig_value;\n \t  /* Otherwise, if we have come to a subaggregate,\n \t     and we don't have an element of its type, push into it.  */\n-\t  else if (value.value != 0\n+\t  else if (value.value != NULL_TREE\n \t\t   && value.value != error_mark_node\n \t\t   && TYPE_MAIN_VARIANT (TREE_TYPE (value.value)) != elttype\n \t\t   && (eltcode == RECORD_TYPE || eltcode == ARRAY_TYPE\n@@ -9516,7 +9519,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t      continue;\n \t    }\n \n-\t  if (constructor_max_index != 0\n+\t  if (constructor_max_index != NULL_TREE\n \t      && (tree_int_cst_lt (constructor_max_index, constructor_index)\n \t\t  || integer_all_onesp (constructor_max_index)))\n \t    {\n@@ -9584,7 +9587,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n       /* Handle the sole element allowed in a braced initializer\n \t for a scalar variable.  */\n       else if (constructor_type != error_mark_node\n-\t       && constructor_fields == 0)\n+\t       && constructor_fields == NULL_TREE)\n \t{\n \t  pedwarn_init (loc, 0,\n \t\t\t\"excess elements in scalar initializer\");\n@@ -9597,7 +9600,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t\t\t\t strict_string, constructor_type,\n \t\t\t\t NULL_TREE, 1, implicit,\n \t\t\t\t braced_init_obstack);\n-\t  constructor_fields = 0;\n+\t  constructor_fields = NULL_TREE;\n \t}\n \n       /* Handle range initializers either at this level or anywhere higher\n@@ -9896,7 +9899,7 @@ c_finish_return (location_t loc, tree retval, tree origtype)\n     {\n       current_function_returns_null = 1;\n       if ((warn_return_type || flag_isoc99)\n-\t  && valtype != 0 && TREE_CODE (valtype) != VOID_TYPE)\n+\t  && valtype != NULL_TREE && TREE_CODE (valtype) != VOID_TYPE)\n \t{\n \t  bool warned_here;\n \t  if (flag_isoc99)\n@@ -9913,7 +9916,7 @@ c_finish_return (location_t loc, tree retval, tree origtype)\n \t\t    \"declared here\");\n \t}\n     }\n-  else if (valtype == 0 || TREE_CODE (valtype) == VOID_TYPE)\n+  else if (valtype == NULL_TREE || TREE_CODE (valtype) == VOID_TYPE)\n     {\n       current_function_returns_null = 1;\n       bool warned_here;\n@@ -10757,11 +10760,11 @@ build_binary_op (location_t location, enum tree_code code,\n \n   /* Nonzero means create the expression with this type, rather than\n      RESULT_TYPE.  */\n-  tree build_type = 0;\n+  tree build_type = NULL_TREE;\n \n   /* Nonzero means after finally constructing the expression\n      convert it to this type.  */\n-  tree final_type = 0;\n+  tree final_type = NULL_TREE;\n \n   /* Nonzero if this is an operation like MIN or MAX which can\n      safely be computed in short if both args are promoted shorts.\n@@ -11733,7 +11736,7 @@ build_binary_op (location_t location, enum tree_code code,\n \t    = shorten_compare (location, &xop0, &xop1, &xresult_type,\n \t\t\t       &xresultcode);\n \n-\t  if (val != 0)\n+\t  if (val != NULL_TREE)\n \t    {\n \t      ret = val;\n \t      goto return_build_binary_op;\n@@ -11854,7 +11857,7 @@ build_binary_op (location_t location, enum tree_code code,\n \t   : fold_build2_loc (location, resultcode, build_type, op0, op1));\n   else\n     ret = build2 (resultcode, build_type, op0, op1);\n-  if (final_type != 0)\n+  if (final_type != NULL_TREE)\n     ret = convert (final_type, ret);\n \n  return_build_binary_op:"}]}