{"sha": "90ca6847bbd0c7b2debb5a985d7f49e464f68577", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBjYTY4NDdiYmQwYzdiMmRlYmI1YTk4NWQ3ZjQ5ZTQ2NGY2ODU3Nw==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2019-11-27T09:16:24Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2019-11-27T09:16:24Z"}, "message": "PR 92463 - Cleanups due to minimum MPFR version bump to 3.1.0\n\n        PR middle-end/92463\n        * configure.ac: Use MPFR_RNDN instead of GMP's MP_RNDN.\n        * configure: Regenerate\n\n        gcc/\n        PR middle-end/92463\n        * builtins.c (do_mpfr_ckconv, do_mpc_ckconv, do_mpfr_remquo,\n        do_mpfr_lgamma_r, do_mpc_arg2): Use MPFR_RNDx instead of GMP_RNDx,\n        mpfr_rnd_t instead of mp_rnd_t.\n        * fold-const-call.c (do_mpfr_ckconv, do_mpfr_arg1, do_mpfr_sincos,\n        do_mpfr_arg2, do_mpfr_arg3, do_mpc_arg1, do_mpc_arg2): Likewise.\n        * gimple-ssa-sprintf.c (format_floating_max, format_floating):\n        Use mpfr_exp_t instead of mp_exp_t.\n        * real.c (real_from_string, dconst_e_ptr, dconst_sqrt2_ptr): Use\n        MPFR_RNDx instead of GMP_RNDx.\n        * realmpfr.c (real_from_mpfr, mpfr_from_real): Use mpfr_rnd_t and\n        mpfr_exp_t instead mp_rnd_t and mp_exp_t, respectively.\n        * realmpfr.h (real_from_mpfr, mpfr_from_real): Use mpfr_rnd_t instead\n        of mp_rnd_t and remove MPFR_RNDx poisoning.\n        * ubsan.c (ubsan_instrument_float_cast): MPFR_RNDx instead of GMP_RNDx.\n\n        fortran/\n        PR middle-end/92463\n        * arith.c (gfc_check_real_range): Replace mp_exp_t by mpfr_exp_t.\n\nFrom-SVN: r278761", "tree": {"sha": "77faad3e0aaed75d74d5c9bba0e0f93db909089f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77faad3e0aaed75d74d5c9bba0e0f93db909089f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90ca6847bbd0c7b2debb5a985d7f49e464f68577", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90ca6847bbd0c7b2debb5a985d7f49e464f68577", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90ca6847bbd0c7b2debb5a985d7f49e464f68577", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90ca6847bbd0c7b2debb5a985d7f49e464f68577/comments", "author": null, "committer": null, "parents": [{"sha": "1f9fae28095488a9accd1e7688116ed4d145b03f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f9fae28095488a9accd1e7688116ed4d145b03f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f9fae28095488a9accd1e7688116ed4d145b03f"}], "stats": {"total": 171, "additions": 98, "deletions": 73}, "files": [{"sha": "cedd89b9be88da4c09e47f9c9b9f675b5fb2317f", "filename": "ChangeLog", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ca6847bbd0c7b2debb5a985d7f49e464f68577/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ca6847bbd0c7b2debb5a985d7f49e464f68577/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=90ca6847bbd0c7b2debb5a985d7f49e464f68577", "patch": "@@ -1,3 +1,9 @@\n+2019-11-27  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\tPR middle-end/92463\n+\t* configure.ac: Use MPFR_RNDN instead of GMP's MP_RNDN.\n+\t* configure: Regenerate\n+\n 2019-11-20  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* configure.ac: Use https for gcc.gnu.org.\n@@ -14,9 +20,9 @@\n \n 2019-11-11  Janne Blomqvist  <jb@gcc.gnu.org>\n \n-        PR fortran/91828\n-        * configure.ac: Bump minimum MPFR to 3.1.0, recommended to 3.1.6+.\n-        * configure: Regenerated.\n+\tPR fortran/91828\n+\t* configure.ac: Bump minimum MPFR to 3.1.0, recommended to 3.1.6+.\n+\t* configure: Regenerated.\n \n 2019-10-21  Jason Merrill  <jason@redhat.com>\n "}, {"sha": "f6027397cedd5c28cd821a0bc7629d6537393ecf", "filename": "configure", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ca6847bbd0c7b2debb5a985d7f49e464f68577/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ca6847bbd0c7b2debb5a985d7f49e464f68577/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=90ca6847bbd0c7b2debb5a985d7f49e464f68577", "patch": "@@ -5865,9 +5865,9 @@ main ()\n     int t;\n     mpfr_init (n);\n     mpfr_init (x);\n-    mpfr_atan2 (n, n, x, GMP_RNDN);\n-    mpfr_erfc (n, x, GMP_RNDN);\n-    mpfr_subnormalize (x, t, GMP_RNDN);\n+    mpfr_atan2 (n, n, x, MPFR_RNDN);\n+    mpfr_erfc (n, x, MPFR_RNDN);\n+    mpfr_subnormalize (x, t, MPFR_RNDN);\n     mpfr_clear(n);\n     mpfr_clear(x);\n     mpc_init2 (c, 53);"}, {"sha": "50e2fa135b10486170f68ffa162dcbeee2adff90", "filename": "configure.ac", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ca6847bbd0c7b2debb5a985d7f49e464f68577/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ca6847bbd0c7b2debb5a985d7f49e464f68577/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=90ca6847bbd0c7b2debb5a985d7f49e464f68577", "patch": "@@ -1641,9 +1641,9 @@ if test -d ${srcdir}/gcc && test \"x$have_gmp\" = xno; then\n     int t;\n     mpfr_init (n);\n     mpfr_init (x);\n-    mpfr_atan2 (n, n, x, GMP_RNDN);\n-    mpfr_erfc (n, x, GMP_RNDN);\n-    mpfr_subnormalize (x, t, GMP_RNDN);\n+    mpfr_atan2 (n, n, x, MPFR_RNDN);\n+    mpfr_erfc (n, x, MPFR_RNDN);\n+    mpfr_subnormalize (x, t, MPFR_RNDN);\n     mpfr_clear(n);\n     mpfr_clear(x);\n     mpc_init2 (c, 53);"}, {"sha": "d46ba4cbc4e2aee07df3c3244969d9438380adbe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90ca6847bbd0c7b2debb5a985d7f49e464f68577", "patch": "@@ -1,3 +1,21 @@\n+2019-11-27  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\tPR middle-end/92463\n+\t* builtins.c (do_mpfr_ckconv, do_mpc_ckconv, do_mpfr_remquo,\n+\tdo_mpfr_lgamma_r, do_mpc_arg2): Use MPFR_RNDx instead of GMP_RNDx,\n+\tmpfr_rnd_t instead of mp_rnd_t.\n+\t* fold-const-call.c (do_mpfr_ckconv, do_mpfr_arg1, do_mpfr_sincos,\n+\tdo_mpfr_arg2, do_mpfr_arg3, do_mpc_arg1, do_mpc_arg2): Likewise.\n+\t* gimple-ssa-sprintf.c (format_floating_max, format_floating):\n+\tUse mpfr_exp_t instead of mp_exp_t.\n+\t* real.c (real_from_string, dconst_e_ptr, dconst_sqrt2_ptr): Use\n+\tMPFR_RNDx instead of GMP_RNDx.\n+\t* realmpfr.c (real_from_mpfr, mpfr_from_real): Use mpfr_rnd_t and\n+\tmpfr_exp_t instead mp_rnd_t and mp_exp_t, respectively.\n+\t* realmpfr.h (real_from_mpfr, mpfr_from_real): Use mpfr_rnd_t instead\n+\tof mp_rnd_t and remove MPFR_RNDx poisoning.\n+\t* ubsan.c (ubsan_instrument_float_cast): MPFR_RNDx instead of GMP_RNDx.\n+\n 2019-11-27  Kewen Lin  <linkw@gcc.gnu.org>\n \n \tPR tree-optimization/91790"}, {"sha": "36319a97b52271849d8fb7f6e34deb501575e237", "filename": "gcc/builtins.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=90ca6847bbd0c7b2debb5a985d7f49e464f68577", "patch": "@@ -11045,7 +11045,7 @@ do_mpfr_ckconv (mpfr_srcptr m, tree type, int inexact)\n     {\n       REAL_VALUE_TYPE rr;\n \n-      real_from_mpfr (&rr, m, type, GMP_RNDN);\n+      real_from_mpfr (&rr, m, type, MPFR_RNDN);\n       /* Proceed iff GCC's REAL_VALUE_TYPE can hold the MPFR value,\n \t check for overflow/underflow.  If the REAL_VALUE_TYPE is zero\n \t but the mpft_t is not, then we underflowed in the\n@@ -11085,8 +11085,8 @@ do_mpc_ckconv (mpc_srcptr m, tree type, int inexact, int force_convert)\n     {\n       REAL_VALUE_TYPE re, im;\n \n-      real_from_mpfr (&re, mpc_realref (m), TREE_TYPE (type), GMP_RNDN);\n-      real_from_mpfr (&im, mpc_imagref (m), TREE_TYPE (type), GMP_RNDN);\n+      real_from_mpfr (&re, mpc_realref (m), TREE_TYPE (type), MPFR_RNDN);\n+      real_from_mpfr (&im, mpc_imagref (m), TREE_TYPE (type), MPFR_RNDN);\n       /* Proceed iff GCC's REAL_VALUE_TYPE can hold the MPFR values,\n \t check for overflow/underflow.  If the REAL_VALUE_TYPE is zero\n \t but the mpft_t is not, then we underflowed in the\n@@ -11138,14 +11138,14 @@ do_mpfr_remquo (tree arg0, tree arg1, tree arg_quo)\n         {\n \t  const struct real_format *fmt = REAL_MODE_FORMAT (TYPE_MODE (type));\n \t  const int prec = fmt->p;\n-\t  const mp_rnd_t rnd = fmt->round_towards_zero? GMP_RNDZ : GMP_RNDN;\n+\t  const mpfr_rnd_t rnd = fmt->round_towards_zero? MPFR_RNDZ : MPFR_RNDN;\n \t  tree result_rem;\n \t  long integer_quo;\n \t  mpfr_t m0, m1;\n \n \t  mpfr_inits2 (prec, m0, m1, NULL);\n-\t  mpfr_from_real (m0, ra0, GMP_RNDN);\n-\t  mpfr_from_real (m1, ra1, GMP_RNDN);\n+\t  mpfr_from_real (m0, ra0, MPFR_RNDN);\n+\t  mpfr_from_real (m1, ra1, MPFR_RNDN);\n \t  mpfr_clear_flags ();\n \t  mpfr_remquo (m0, &integer_quo, m0, m1, rnd);\n \t  /* Remquo is independent of the rounding mode, so pass\n@@ -11218,13 +11218,13 @@ do_mpfr_lgamma_r (tree arg, tree arg_sg, tree type)\n         {\n \t  const struct real_format *fmt = REAL_MODE_FORMAT (TYPE_MODE (type));\n \t  const int prec = fmt->p;\n-\t  const mp_rnd_t rnd = fmt->round_towards_zero? GMP_RNDZ : GMP_RNDN;\n+\t  const mpfr_rnd_t rnd = fmt->round_towards_zero? MPFR_RNDZ : MPFR_RNDN;\n \t  int inexact, sg;\n \t  mpfr_t m;\n \t  tree result_lg;\n \n \t  mpfr_init2 (m, prec);\n-\t  mpfr_from_real (m, ra, GMP_RNDN);\n+\t  mpfr_from_real (m, ra, MPFR_RNDN);\n \t  mpfr_clear_flags ();\n \t  inexact = mpfr_lgamma (m, &sg, m, rnd);\n \t  result_lg = do_mpfr_ckconv (m, type, inexact);\n@@ -11287,7 +11287,8 @@ do_mpc_arg2 (tree arg0, tree arg1, tree type, int do_nonfinite,\n \t  const struct real_format *const fmt =\n \t    REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (type)));\n \t  const int prec = fmt->p;\n-\t  const mp_rnd_t rnd = fmt->round_towards_zero ? GMP_RNDZ : GMP_RNDN;\n+\t  const mpfr_rnd_t rnd = fmt->round_towards_zero\n+\t\t\t\t ? MPFR_RNDZ : MPFR_RNDN;\n \t  const mpc_rnd_t crnd = fmt->round_towards_zero ? MPC_RNDZZ : MPC_RNDNN;\n \t  int inexact;\n \t  mpc_t m0, m1;"}, {"sha": "c4f52fb3c1576c3f205326c1024f4579a4ac5378", "filename": "gcc/fold-const-call.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2Ffold-const-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2Ffold-const-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.c?ref=90ca6847bbd0c7b2debb5a985d7f49e464f68577", "patch": "@@ -99,7 +99,7 @@ do_mpfr_ckconv (real_value *result, mpfr_srcptr m, bool inexact,\n     return false;\n \n   REAL_VALUE_TYPE tmp;\n-  real_from_mpfr (&tmp, m, format, GMP_RNDN);\n+  real_from_mpfr (&tmp, m, format, MPFR_RNDN);\n \n   /* Proceed iff GCC's REAL_VALUE_TYPE can hold the MPFR values.\n      If the REAL_VALUE_TYPE is zero but the mpft_t is not, then we\n@@ -130,11 +130,11 @@ do_mpfr_arg1 (real_value *result,\n     return false;\n \n   int prec = format->p;\n-  mp_rnd_t rnd = format->round_towards_zero ? GMP_RNDZ : GMP_RNDN;\n+  mpfr_rnd_t rnd = format->round_towards_zero ? MPFR_RNDZ : MPFR_RNDN;\n   mpfr_t m;\n \n   mpfr_init2 (m, prec);\n-  mpfr_from_real (m, arg, GMP_RNDN);\n+  mpfr_from_real (m, arg, MPFR_RNDN);\n   mpfr_clear_flags ();\n   bool inexact = func (m, m, rnd);\n   bool ok = do_mpfr_ckconv (result, m, inexact, format);\n@@ -160,11 +160,11 @@ do_mpfr_sincos (real_value *result_sin, real_value *result_cos,\n     return false;\n \n   int prec = format->p;\n-  mp_rnd_t rnd = format->round_towards_zero ? GMP_RNDZ : GMP_RNDN;\n+  mpfr_rnd_t rnd = format->round_towards_zero ? MPFR_RNDZ : MPFR_RNDN;\n   mpfr_t m, ms, mc;\n \n   mpfr_inits2 (prec, m, ms, mc, NULL);\n-  mpfr_from_real (m, arg, GMP_RNDN);\n+  mpfr_from_real (m, arg, MPFR_RNDN);\n   mpfr_clear_flags ();\n   bool inexact = mpfr_sin_cos (ms, mc, m, rnd);\n   bool ok = (do_mpfr_ckconv (result_sin, ms, inexact, format)\n@@ -193,12 +193,12 @@ do_mpfr_arg2 (real_value *result,\n     return false;\n \n   int prec = format->p;\n-  mp_rnd_t rnd = format->round_towards_zero ? GMP_RNDZ : GMP_RNDN;\n+  mpfr_rnd_t rnd = format->round_towards_zero ? MPFR_RNDZ : MPFR_RNDN;\n   mpfr_t m0, m1;\n \n   mpfr_inits2 (prec, m0, m1, NULL);\n-  mpfr_from_real (m0, arg0, GMP_RNDN);\n-  mpfr_from_real (m1, arg1, GMP_RNDN);\n+  mpfr_from_real (m0, arg0, MPFR_RNDN);\n+  mpfr_from_real (m1, arg1, MPFR_RNDN);\n   mpfr_clear_flags ();\n   bool inexact = func (m0, m0, m1, rnd);\n   bool ok = do_mpfr_ckconv (result, m0, inexact, format);\n@@ -216,19 +216,19 @@ do_mpfr_arg2 (real_value *result,\n \n static bool\n do_mpfr_arg2 (real_value *result,\n-\t      int (*func) (mpfr_ptr, long, mpfr_srcptr, mp_rnd_t),\n+\t      int (*func) (mpfr_ptr, long, mpfr_srcptr, mpfr_rnd_t),\n \t      const wide_int_ref &arg0, const real_value *arg1,\n \t      const real_format *format)\n {\n   if (format->b != 2 || !real_isfinite (arg1))\n     return false;\n \n   int prec = format->p;\n-  mp_rnd_t rnd = format->round_towards_zero ? GMP_RNDZ : GMP_RNDN;\n+  mpfr_rnd_t rnd = format->round_towards_zero ? MPFR_RNDZ : MPFR_RNDN;\n   mpfr_t m;\n \n   mpfr_init2 (m, prec);\n-  mpfr_from_real (m, arg1, GMP_RNDN);\n+  mpfr_from_real (m, arg1, MPFR_RNDN);\n   mpfr_clear_flags ();\n   bool inexact = func (m, arg0.to_shwi (), m, rnd);\n   bool ok = do_mpfr_ckconv (result, m, inexact, format);\n@@ -260,13 +260,13 @@ do_mpfr_arg3 (real_value *result,\n     return false;\n \n   int prec = format->p;\n-  mp_rnd_t rnd = format->round_towards_zero ? GMP_RNDZ : GMP_RNDN;\n+  mpfr_rnd_t rnd = format->round_towards_zero ? MPFR_RNDZ : MPFR_RNDN;\n   mpfr_t m0, m1, m2;\n \n   mpfr_inits2 (prec, m0, m1, m2, NULL);\n-  mpfr_from_real (m0, arg0, GMP_RNDN);\n-  mpfr_from_real (m1, arg1, GMP_RNDN);\n-  mpfr_from_real (m2, arg2, GMP_RNDN);\n+  mpfr_from_real (m0, arg0, MPFR_RNDN);\n+  mpfr_from_real (m1, arg1, MPFR_RNDN);\n+  mpfr_from_real (m2, arg2, MPFR_RNDN);\n   mpfr_clear_flags ();\n   bool inexact = func (m0, m0, m1, m2, rnd);\n   bool ok = do_mpfr_ckconv (result, m0, inexact, format);\n@@ -296,8 +296,8 @@ do_mpc_ckconv (real_value *result_real, real_value *result_imag,\n     return false;\n \n   REAL_VALUE_TYPE tmp_real, tmp_imag;\n-  real_from_mpfr (&tmp_real, mpc_realref (m), format, GMP_RNDN);\n-  real_from_mpfr (&tmp_imag, mpc_imagref (m), format, GMP_RNDN);\n+  real_from_mpfr (&tmp_real, mpc_realref (m), format, MPFR_RNDN);\n+  real_from_mpfr (&tmp_imag, mpc_imagref (m), format, MPFR_RNDN);\n \n   /* Proceed iff GCC's REAL_VALUE_TYPE can hold the MPFR values.\n      If the REAL_VALUE_TYPE is zero but the mpft_t is not, then we\n@@ -341,8 +341,8 @@ do_mpc_arg1 (real_value *result_real, real_value *result_imag,\n   mpc_t m;\n \n   mpc_init2 (m, prec);\n-  mpfr_from_real (mpc_realref (m), arg_real, GMP_RNDN);\n-  mpfr_from_real (mpc_imagref (m), arg_imag, GMP_RNDN);\n+  mpfr_from_real (mpc_realref (m), arg_real, MPFR_RNDN);\n+  mpfr_from_real (mpc_imagref (m), arg_imag, MPFR_RNDN);\n   mpfr_clear_flags ();\n   bool inexact = func (m, m, crnd);\n   bool ok = do_mpc_ckconv (result_real, result_imag, m, inexact, format);\n@@ -378,10 +378,10 @@ do_mpc_arg2 (real_value *result_real, real_value *result_imag,\n \n   mpc_init2 (m0, prec);\n   mpc_init2 (m1, prec);\n-  mpfr_from_real (mpc_realref (m0), arg0_real, GMP_RNDN);\n-  mpfr_from_real (mpc_imagref (m0), arg0_imag, GMP_RNDN);\n-  mpfr_from_real (mpc_realref (m1), arg1_real, GMP_RNDN);\n-  mpfr_from_real (mpc_imagref (m1), arg1_imag, GMP_RNDN);\n+  mpfr_from_real (mpc_realref (m0), arg0_real, MPFR_RNDN);\n+  mpfr_from_real (mpc_imagref (m0), arg0_imag, MPFR_RNDN);\n+  mpfr_from_real (mpc_realref (m1), arg1_real, MPFR_RNDN);\n+  mpfr_from_real (mpc_imagref (m1), arg1_imag, MPFR_RNDN);\n   mpfr_clear_flags ();\n   bool inexact = func (m0, m0, m1, crnd);\n   bool ok = do_mpc_ckconv (result_real, result_imag, m0, inexact, format);"}, {"sha": "25252501b1921dca16455665d475a59cf24703d8", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=90ca6847bbd0c7b2debb5a985d7f49e464f68577", "patch": "@@ -1,3 +1,8 @@\n+2019-11-27  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\tPR middle-end/92463\n+\t* arith.c (gfc_check_real_range): Replace mp_exp_t by mpfr_exp_t.\n+\n 2019-11-25  Harald Anlauf  <anlauf@gmx.de>\n \n \tPR fortran/92629"}, {"sha": "7f048da95830f3dacacf7f242f7eeb5bfb149bf5", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=90ca6847bbd0c7b2debb5a985d7f49e464f68577", "patch": "@@ -385,8 +385,8 @@ gfc_check_real_range (mpfr_t p, int kind)\n \n       /* Set emin and emax for the current model number.  */\n       en = gfc_real_kinds[i].min_exponent - gfc_real_kinds[i].digits + 1;\n-      mpfr_set_emin ((mp_exp_t) en);\n-      mpfr_set_emax ((mp_exp_t) gfc_real_kinds[i].max_exponent);\n+      mpfr_set_emin ((mpfr_exp_t) en);\n+      mpfr_set_emax ((mpfr_exp_t) gfc_real_kinds[i].max_exponent);\n       mpfr_check_range (q, 0, GFC_RND_MODE);\n       mpfr_subnormalize (q, 0, GFC_RND_MODE);\n "}, {"sha": "2bbb2b37ac3eee3e28319ab5b555804a842bb68e", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=90ca6847bbd0c7b2debb5a985d7f49e464f68577", "patch": "@@ -1606,7 +1606,7 @@ format_floating_max (tree type, char spec, HOST_WIDE_INT prec)\n      round-to-nearest mode.  */\n   mpfr_t x;\n   mpfr_init2 (x, rfmt->p);\n-  mpfr_from_real (x, &rv, GMP_RNDN);\n+  mpfr_from_real (x, &rv, MPFR_RNDN);\n \n   /* Return a value one greater to account for the leading minus sign.  */\n   unsigned HOST_WIDE_INT r\n@@ -1953,7 +1953,7 @@ format_floating (const directive &dir, tree arg, const vr_values *)\n \t   rounding in either direction can result in longer output.  */\n \tmpfr_t mpfrval;\n \tmpfr_init2 (mpfrval, rfmt->p);\n-\tmpfr_from_real (mpfrval, rvp, i ? GMP_RNDU : GMP_RNDD);\n+\tmpfr_from_real (mpfrval, rvp, i ? MPFR_RNDU : MPFR_RNDD);\n \n \t/* Use the MPFR rounding specifier to round down in the first\n \t   iteration and then up.  In most but not all cases this will"}, {"sha": "134240a6be988cc8edaad061ad1b5da87b6900a7", "filename": "gcc/real.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=90ca6847bbd0c7b2debb5a985d7f49e464f68577", "patch": "@@ -2104,7 +2104,7 @@ real_from_string (REAL_VALUE_TYPE *r, const char *str)\n \n       /* Nonzero value, possibly overflowing or underflowing.  */\n       mpfr_init2 (m, SIGNIFICAND_BITS);\n-      inexact = mpfr_strtofr (m, str, NULL, 10, GMP_RNDZ);\n+      inexact = mpfr_strtofr (m, str, NULL, 10, MPFR_RNDZ);\n       /* The result should never be a NaN, and because the rounding is\n \t toward zero should never be an infinity.  */\n       gcc_assert (!mpfr_nan_p (m) && !mpfr_inf_p (m));\n@@ -2120,7 +2120,7 @@ real_from_string (REAL_VALUE_TYPE *r, const char *str)\n \t}\n       else\n \t{\n-\t  real_from_mpfr (r, m, NULL_TREE, GMP_RNDZ);\n+\t  real_from_mpfr (r, m, NULL_TREE, MPFR_RNDZ);\n \t  /* 1 to 3 bits may have been shifted off (with a sticky bit)\n \t     because the hex digits used in real_from_mpfr did not\n \t     start with a digit 8 to f, but the exponent bounds above\n@@ -2431,9 +2431,9 @@ dconst_e_ptr (void)\n     {\n       mpfr_t m;\n       mpfr_init2 (m, SIGNIFICAND_BITS);\n-      mpfr_set_ui (m, 1, GMP_RNDN);\n-      mpfr_exp (m, m, GMP_RNDN);\n-      real_from_mpfr (&value, m, NULL_TREE, GMP_RNDN);\n+      mpfr_set_ui (m, 1, MPFR_RNDN);\n+      mpfr_exp (m, m, MPFR_RNDN);\n+      real_from_mpfr (&value, m, NULL_TREE, MPFR_RNDN);\n       mpfr_clear (m);\n \n     }\n@@ -2474,8 +2474,8 @@ dconst_sqrt2_ptr (void)\n     {\n       mpfr_t m;\n       mpfr_init2 (m, SIGNIFICAND_BITS);\n-      mpfr_sqrt_ui (m, 2, GMP_RNDN);\n-      real_from_mpfr (&value, m, NULL_TREE, GMP_RNDN);\n+      mpfr_sqrt_ui (m, 2, MPFR_RNDN);\n+      real_from_mpfr (&value, m, NULL_TREE, MPFR_RNDN);\n       mpfr_clear (m);\n     }\n   return &value;\n@@ -5410,13 +5410,13 @@ build_sinatan_real (REAL_VALUE_TYPE * r, tree type)\n \n   mpfr_inits (mpfr_const1, mpfr_c, mpfr_maxval, NULL);\n \n-  mpfr_from_real (mpfr_const1, &dconst1, GMP_RNDN);\n-  mpfr_from_real (mpfr_maxval, &maxval,  GMP_RNDN);\n+  mpfr_from_real (mpfr_const1, &dconst1, MPFR_RNDN);\n+  mpfr_from_real (mpfr_maxval, &maxval,  MPFR_RNDN);\n \n-  mpfr_sub (mpfr_c, mpfr_maxval, mpfr_const1, GMP_RNDN);\n-  mpfr_sqrt (mpfr_c, mpfr_c, GMP_RNDZ);\n+  mpfr_sub (mpfr_c, mpfr_maxval, mpfr_const1, MPFR_RNDN);\n+  mpfr_sqrt (mpfr_c, mpfr_c, MPFR_RNDZ);\n \n-  real_from_mpfr (r, mpfr_c, fmt, GMP_RNDZ);\n+  real_from_mpfr (r, mpfr_c, fmt, MPFR_RNDZ);\n   \n   mpfr_clears (mpfr_const1, mpfr_c, mpfr_maxval, NULL);\n }"}, {"sha": "a760ae124c32a4c95f08771e407e6a47a712d513", "filename": "gcc/realmpfr.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2Frealmpfr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2Frealmpfr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frealmpfr.c?ref=90ca6847bbd0c7b2debb5a985d7f49e464f68577", "patch": "@@ -28,7 +28,7 @@\n    for initializing and clearing the MPFR parameter.  */\n \n void\n-mpfr_from_real (mpfr_ptr m, const REAL_VALUE_TYPE *r, mp_rnd_t rndmode)\n+mpfr_from_real (mpfr_ptr m, const REAL_VALUE_TYPE *r, mpfr_rnd_t rndmode)\n {\n   /* We use a string as an intermediate type.  */\n   char buf[128];\n@@ -59,11 +59,11 @@ mpfr_from_real (mpfr_ptr m, const REAL_VALUE_TYPE *r, mp_rnd_t rndmode)\n \n void\n real_from_mpfr (REAL_VALUE_TYPE *r, mpfr_srcptr m, const real_format *format,\n-\t\tmp_rnd_t rndmode)\n+\t\tmpfr_rnd_t rndmode)\n {\n   /* We use a string as an intermediate type.  */\n   char buf[128], *rstr;\n-  mp_exp_t exp;\n+  mpfr_exp_t exp;\n \n   /* Take care of Infinity and NaN.  */\n   if (mpfr_inf_p (m))\n@@ -105,7 +105,8 @@ real_from_mpfr (REAL_VALUE_TYPE *r, mpfr_srcptr m, const real_format *format,\n    mode RNDMODE.  TYPE is only relevant if M is a NaN.  */\n \n void\n-real_from_mpfr (REAL_VALUE_TYPE *r, mpfr_srcptr m, tree type, mp_rnd_t rndmode)\n+real_from_mpfr (REAL_VALUE_TYPE *r, mpfr_srcptr m, tree type,\n+\t\tmpfr_rnd_t rndmode)\n {\n   real_from_mpfr (r, m, type ? REAL_MODE_FORMAT (TYPE_MODE (type)) : NULL,\n \t\t  rndmode);"}, {"sha": "ebb44fd859d01e6dce10860252eef4c48aa948d5", "filename": "gcc/realmpfr.h", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2Frealmpfr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2Frealmpfr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frealmpfr.h?ref=90ca6847bbd0c7b2debb5a985d7f49e464f68577", "patch": "@@ -27,15 +27,9 @@\n /* Convert between MPFR and REAL_VALUE_TYPE.  The caller is\n    responsible for initializing and clearing the MPFR parameter.  */\n \n-extern void real_from_mpfr (REAL_VALUE_TYPE *, mpfr_srcptr, tree, mp_rnd_t);\n+extern void real_from_mpfr (REAL_VALUE_TYPE *, mpfr_srcptr, tree, mpfr_rnd_t);\n extern void real_from_mpfr (REAL_VALUE_TYPE *, mpfr_srcptr,\n-\t\t\t    const real_format *, mp_rnd_t);\n-extern void mpfr_from_real (mpfr_ptr, const REAL_VALUE_TYPE *, mp_rnd_t);\n-\n-#if (GCC_VERSION >= 3000)\n-  /* For compatibility with mpfr 2.4 and earlier, we want to only use\n-     GMP_RND*.  */\n-  #pragma GCC poison MPFR_RNDN MPFR_RNDZ MPFR_RNDU MPFR_RNDD\n-#endif\n+\t\t\t    const real_format *, mpfr_rnd_t);\n+extern void mpfr_from_real (mpfr_ptr, const REAL_VALUE_TYPE *, mpfr_rnd_t);\n \n #endif /* ! GCC_REALGMP_H */"}, {"sha": "f12674b5649e97f254c374ec19af4d77a7c36f89", "filename": "gcc/ubsan.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90ca6847bbd0c7b2debb5a985d7f49e464f68577/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=90ca6847bbd0c7b2debb5a985d7f49e464f68577", "patch": "@@ -1860,7 +1860,7 @@ ubsan_instrument_float_cast (location_t loc, tree type, tree expr)\n \t representable decimal number greater or equal than\n \t 1 << (prec - !uns_p).  */\n       mpfr_init2 (m, prec + 2);\n-      mpfr_set_ui_2exp (m, 1, prec - !uns_p, GMP_RNDN);\n+      mpfr_set_ui_2exp (m, 1, prec - !uns_p, MPFR_RNDN);\n       mpfr_snprintf (buf, sizeof buf, \"%.*RUe\", p - 1, m);\n       decimal_real_from_string (&maxval, buf);\n       max = build_real (expr_type, maxval);\n@@ -1873,8 +1873,8 @@ ubsan_instrument_float_cast (location_t loc, tree type, tree expr)\n \t  /* Use mpfr_snprintf rounding to compute the largest\n \t     representable decimal number less or equal than\n \t     (-1 << (prec - 1)) - 1.  */\n-\t  mpfr_set_si_2exp (m, -1, prec - 1, GMP_RNDN);\n-\t  mpfr_sub_ui (m, m, 1, GMP_RNDN);\n+\t  mpfr_set_si_2exp (m, -1, prec - 1, MPFR_RNDN);\n+\t  mpfr_sub_ui (m, m, 1, MPFR_RNDN);\n \t  mpfr_snprintf (buf, sizeof buf, \"%.*RDe\", p - 1, m);\n \t  decimal_real_from_string (&minval, buf);\n \t  min = build_real (expr_type, minval);"}]}