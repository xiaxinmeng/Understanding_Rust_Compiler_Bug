{"sha": "66bd936126108cd95d354322bd99aaee1742d437", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZiZDkzNjEyNjEwOGNkOTVkMzU0MzIyYmQ5OWFhZWUxNzQyZDQzNw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-10-14T20:31:15Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-10-14T20:31:15Z"}, "message": "(jump_optimize): Check for if (...) { x = a; goto l; } x = b;\n\nFrom-SVN: r12960", "tree": {"sha": "d541fbfdf6094f8a786938742b8fa72d8598455e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d541fbfdf6094f8a786938742b8fa72d8598455e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66bd936126108cd95d354322bd99aaee1742d437", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66bd936126108cd95d354322bd99aaee1742d437", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66bd936126108cd95d354322bd99aaee1742d437", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66bd936126108cd95d354322bd99aaee1742d437/comments", "author": null, "committer": null, "parents": [{"sha": "61b32c02009f839bb9b02b9a6d4e6fb140aee1a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61b32c02009f839bb9b02b9a6d4e6fb140aee1a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61b32c02009f839bb9b02b9a6d4e6fb140aee1a4"}], "stats": {"total": 90, "additions": 90, "deletions": 0}, "files": [{"sha": "b6d0bdcbe06670f0bedb94d75f4dbd917c20b4cf", "filename": "gcc/jump.c", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66bd936126108cd95d354322bd99aaee1742d437/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66bd936126108cd95d354322bd99aaee1742d437/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=66bd936126108cd95d354322bd99aaee1742d437", "patch": "@@ -863,6 +863,96 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t}\n \t    }\n \n+\t  /* Simplify   if (...) { x = a; goto l; } x = b; by converting it\n+\t     to         x = a; if (...) goto l; x = b;\n+\t     if A is sufficiently simple, the test doesn't involve X,\n+\t     and nothing in the test modifies A or X.\n+\n+\t     If we have small register classes, we also can't do this if X\n+\t     is a hard register.\n+\n+\t     If the \"x = a;\" insn has any REG_NOTES, we don't do this because\n+\t     of the possibility that we are running after CSE and there is a\n+\t     REG_EQUAL note that is only valid if the branch has already been\n+\t     taken.  If we move the insn with the REG_EQUAL note, we may\n+\t     fold the comparison to always be false in a later CSE pass.\n+\t     (We could also delete the REG_NOTES when moving the insn, but it\n+\t     seems simpler to not move it.)  An exception is that we can move\n+\t     the insn if the only note is a REG_EQUAL or REG_EQUIV whose\n+\t     value is the same as \"a\".\n+\n+\t     INSN is the goto.\n+\n+\t     We set:\n+\n+\t     TEMP to the jump insn preceding \"x = a;\"\n+\t     TEMP1 to X\n+\t     TEMP2 to the insn that sets \"x = b;\"\n+\t     TEMP3 to the insn that sets \"x = a;\"\n+\t     TEMP4 to the set of \"x = a\";  */\n+\n+\t  if (this_is_simplejump\n+\t      && (temp2 = next_active_insn (insn)) != 0\n+\t      && GET_CODE (temp2) == INSN\n+\t      && (temp4 = single_set (temp2)) != 0\n+\t      && GET_CODE (temp1 = SET_DEST (temp4)) == REG\n+#ifdef SMALL_REGISTER_CLASSES\n+\t      && REGNO (temp1) >= FIRST_PSEUDO_REGISTER\n+#endif\n+\n+\t      && (temp3 = prev_active_insn (insn)) != 0\n+\t      && GET_CODE (temp3) == INSN\n+\t      && (temp4 = single_set (temp3)) != 0\n+\t      && rtx_equal_p (SET_DEST (temp4), temp1)\n+\t      && (GET_CODE (SET_SRC (temp4)) == REG\n+\t\t  || GET_CODE (SET_SRC (temp4)) == SUBREG\n+\t\t  || CONSTANT_P (SET_SRC (temp4)))\n+\t      && (REG_NOTES (temp3) == 0\n+\t\t  || ((REG_NOTE_KIND (REG_NOTES (temp3)) == REG_EQUAL\n+\t\t       || REG_NOTE_KIND (REG_NOTES (temp3)) == REG_EQUIV)\n+\t\t      && XEXP (REG_NOTES (temp3), 1) == 0\n+\t\t      && rtx_equal_p (XEXP (REG_NOTES (temp3), 0),\n+\t\t\t\t      SET_SRC (temp4))))\n+\t      && (temp = prev_active_insn (temp3)) != 0\n+\t      && condjump_p (temp) && ! simplejump_p (temp)\n+\t      /* TEMP must skip over the \"x = a;\" insn */\n+\t      && prev_real_insn (JUMP_LABEL (temp)) == insn\n+\t      && no_labels_between_p (temp, insn))\n+\t    {\n+\t      rtx prev_label = JUMP_LABEL (temp);\n+\t      rtx insert_after = prev_nonnote_insn (temp);\n+\n+#ifdef HAVE_cc0\n+\t      /* We cannot insert anything between a set of cc and its use.  */\n+\t      if (insert_after && GET_RTX_CLASS (GET_CODE (insert_after)) == 'i'\n+\t\t  && sets_cc0_p (PATTERN (insert_after)))\n+\t\tinsert_after = prev_nonnote_insn (insert_after);\n+#endif\n+\t      ++LABEL_NUSES (prev_label);\n+\n+\t      if (insert_after\n+\t\t  && no_labels_between_p (insert_after, temp)\n+\t\t  && ! reg_referenced_between_p (temp1, insert_after, temp)\n+\t\t  && ! reg_set_between_p (temp1, insert_after, temp)\n+\t\t  && (GET_CODE (SET_SRC (temp4)) == CONST_INT\n+\t\t      || ! reg_set_between_p (SET_SRC (temp4),\n+\t\t\t\t\t      insert_after, temp))\n+\t\t  && invert_jump (temp, JUMP_LABEL (insn)))\n+\t\t{\n+\t\t  emit_insn_after_with_line_notes (PATTERN (temp3),\n+\t\t\t\t\t\t   insert_after, temp3);\n+\t\t  delete_insn (temp3);\n+\t\t  delete_insn (insn);\n+\t\t  /* Set NEXT to an insn that we know won't go away.  */\n+\t\t  next = temp2;\n+\t\t  changed = 1;\n+\t\t}\n+\t      if (prev_label && --LABEL_NUSES (prev_label) == 0)\n+\t\tdelete_insn (prev_label);\n+\t      if (changed)\n+\t\tcontinue;\n+\t    }\n+\n #ifndef HAVE_cc0\n \t  /* If we have if (...) x = exp;  and branches are expensive,\n \t     EXP is a single insn, does not have any side effects, cannot"}]}