{"sha": "c18c98c0ade56bc46ce65bbf5cdff26a2577c990", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE4Yzk4YzBhZGU1NmJjNDZjZTY1YmJmNWNkZmYyNmEyNTc3Yzk5MA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-05-07T07:28:14Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-05-07T07:28:14Z"}, "message": "re PR middle-end/36106 (#pragma omp atomic issues with floating point types)\n\n\tPR middle-end/36106\n\t* omp-low.c (expand_omp_atomic_pipeline): Load value using the\n\tintegral type rather than floating point, then VIEW_CONVERT_EXPR\n\tto the floating point type.\n\n\t* testsuite/libgomp.c/atomic-5.c: New test.\n\t* testsuite/libgomp.c/atomic-6.c: New test.\n\t* testsuite/libgomp.c/autopar-1.c: New test.\n\nFrom-SVN: r135027", "tree": {"sha": "8a49369b064d64c16fa89af2d0a836f7966d2e98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a49369b064d64c16fa89af2d0a836f7966d2e98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c18c98c0ade56bc46ce65bbf5cdff26a2577c990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c18c98c0ade56bc46ce65bbf5cdff26a2577c990", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c18c98c0ade56bc46ce65bbf5cdff26a2577c990", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c18c98c0ade56bc46ce65bbf5cdff26a2577c990/comments", "author": null, "committer": null, "parents": [{"sha": "537d4fa684f272ea72c1c8db58e4f1dcd3b7cda4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/537d4fa684f272ea72c1c8db58e4f1dcd3b7cda4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/537d4fa684f272ea72c1c8db58e4f1dcd3b7cda4"}], "stats": {"total": 253, "additions": 210, "deletions": 43}, "files": [{"sha": "6147e35535698106583794c15ac24967b2648c0b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c18c98c0ade56bc46ce65bbf5cdff26a2577c990/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c18c98c0ade56bc46ce65bbf5cdff26a2577c990/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c18c98c0ade56bc46ce65bbf5cdff26a2577c990", "patch": "@@ -1,4 +1,15 @@\n-2008-05-08  Uros Bizjak  <ubizjak@gmail.com>\n+2008-05-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/36106\n+\t* omp-low.c (expand_omp_atomic_pipeline): Load value using the\n+\tintegral type rather than floating point, then VIEW_CONVERT_EXPR\n+\tto the floating point type.\n+\n+\t* testsuite/libgomp.c/atomic-5.c: New test.\n+\t* testsuite/libgomp.c/atomic-6.c: New test.\n+\t* testsuite/libgomp.c/autopar-1.c: New test.\n+\n+2008-05-07  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (ix86_expand_copysign): Force non-zero constant\n \tTFmode op0 to register."}, {"sha": "1d3bf7b1f9c119e057bd8bf57f66263950456dc8", "filename": "gcc/omp-low.c", "status": "modified", "additions": 71, "deletions": 42, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c18c98c0ade56bc46ce65bbf5cdff26a2577c990/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c18c98c0ade56bc46ce65bbf5cdff26a2577c990/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=c18c98c0ade56bc46ce65bbf5cdff26a2577c990", "patch": "@@ -3758,7 +3758,7 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n \t\t\t    tree addr, tree loaded_val, tree stored_val,\n \t\t\t    int index)\n {\n-  tree loadedi, storedi, initial, new_stored, new_storedi, old_vali;\n+  tree loadedi, storedi, initial, new_storedi, old_vali;\n   tree type, itype, cmpxchg, iaddr;\n   block_stmt_iterator bsi;\n   basic_block loop_header = single_succ (load_bb);\n@@ -3775,81 +3775,110 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n   /* Load the initial value, replacing the OMP_ATOMIC_LOAD.  */\n   bsi = bsi_last (load_bb);\n   gcc_assert (TREE_CODE (bsi_stmt (bsi)) == OMP_ATOMIC_LOAD);\n-  initial = force_gimple_operand_bsi (&bsi, build_fold_indirect_ref (addr),\n+  /* For floating-point values, we'll need to view-convert them to integers\n+     so that we can perform the atomic compare and swap.  Simplify the\n+     following code by always setting up the \"i\"ntegral variables.  */\n+  if (!INTEGRAL_TYPE_P (type) && !POINTER_TYPE_P (type))\n+    {\n+      iaddr = create_tmp_var (build_pointer_type (itype), NULL);\n+      x = build_gimple_modify_stmt (iaddr,\n+\t\t\t\t    fold_convert (TREE_TYPE (iaddr), addr));\n+      force_gimple_operand_bsi (&bsi, x, true, NULL_TREE,\n+\t\t\t\ttrue, BSI_SAME_STMT);\n+      DECL_NO_TBAA_P (iaddr) = 1;\n+      DECL_POINTER_ALIAS_SET (iaddr) = 0;\n+      loadedi = create_tmp_var (itype, NULL);\n+      if (gimple_in_ssa_p (cfun))\n+\t{\n+\t  add_referenced_var (iaddr);\n+\t  add_referenced_var (loadedi);\n+\t  loadedi = make_ssa_name (loadedi, NULL);\n+\t}\n+    }\n+  else\n+    {\n+      iaddr = addr;\n+      loadedi = loaded_val;\n+    }\n+  initial = force_gimple_operand_bsi (&bsi, build_fold_indirect_ref (iaddr),\n \t\t\t\t      true, NULL_TREE, true, BSI_SAME_STMT);\n-  /* Move the value to the LOADED_VAL temporary.  */\n+\n+  /* Move the value to the LOADEDI temporary.  */\n   if (gimple_in_ssa_p (cfun))\n     {\n       gcc_assert (phi_nodes (loop_header) == NULL_TREE);\n-      phi = create_phi_node (loaded_val, loop_header);\n-      SSA_NAME_DEF_STMT (loaded_val) = phi;\n+      phi = create_phi_node (loadedi, loop_header);\n+      SSA_NAME_DEF_STMT (loadedi) = phi;\n       SET_USE (PHI_ARG_DEF_PTR_FROM_EDGE (phi, single_succ_edge (load_bb)),\n \t       initial);\n     }\n   else\n     bsi_insert_before (&bsi,\n-\t\t       build_gimple_modify_stmt (loaded_val, initial),\n+\t\t       build_gimple_modify_stmt (loadedi, initial),\n \t\t       BSI_SAME_STMT);\n+  if (loadedi != loaded_val)\n+    {\n+      block_stmt_iterator bsi2;\n+\n+      x = build1 (VIEW_CONVERT_EXPR, type, loadedi);\n+      bsi2 = bsi_start (loop_header);\n+      if (gimple_in_ssa_p (cfun))\n+\t{\n+\t  x = force_gimple_operand_bsi (&bsi2, x, true, NULL_TREE,\n+\t\t\t\t\ttrue, BSI_SAME_STMT);\n+\t  x = build_gimple_modify_stmt (loaded_val, x);\n+\t  bsi_insert_before (&bsi2, x, BSI_SAME_STMT);\n+\t  SSA_NAME_DEF_STMT (loaded_val) = x;\n+\t}\n+      else\n+\t{\n+\t  x = build_gimple_modify_stmt (loaded_val, x);\n+\t  force_gimple_operand_bsi (&bsi2, x, true, NULL_TREE,\n+\t\t\t\t    true, BSI_SAME_STMT);\n+\t}\n+    }\n   bsi_remove (&bsi, true);\n \n   bsi = bsi_last (store_bb);\n   gcc_assert (TREE_CODE (bsi_stmt (bsi)) == OMP_ATOMIC_STORE);\n \n-  /* For floating-point values, we'll need to view-convert them to integers\n-     so that we can perform the atomic compare and swap.  Simplify the \n-     following code by always setting up the \"i\"ntegral variables.  */\n-  if (INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type))\n-    {\n-      loadedi = loaded_val;\n-      storedi = stored_val;\n-      iaddr = addr;\n-    }\n+  if (iaddr == addr)\n+    storedi = stored_val;\n   else\n-    {\n-      loadedi = force_gimple_operand_bsi (&bsi,\n-\t\t\t\t\t  build1 (VIEW_CONVERT_EXPR, itype,\n-\t\t\t\t\t\t  loaded_val), true,\n-\t\t\t\t\t  NULL_TREE, true, BSI_SAME_STMT);\n-      storedi =\n-\tforce_gimple_operand_bsi (&bsi,\n-\t\t\t\t  build1 (VIEW_CONVERT_EXPR, itype,\n-\t\t\t\t\t  stored_val), true, NULL_TREE, true,\n-\t\t\t\t  BSI_SAME_STMT);\n-      iaddr = fold_convert (build_pointer_type (itype), addr);\n-    }\n+    storedi =\n+      force_gimple_operand_bsi (&bsi,\n+\t\t\t\tbuild1 (VIEW_CONVERT_EXPR, itype,\n+\t\t\t\t\tstored_val), true, NULL_TREE, true,\n+\t\t\t\tBSI_SAME_STMT);\n \n   /* Build the compare&swap statement.  */\n   new_storedi = build_call_expr (cmpxchg, 3, iaddr, loadedi, storedi);\n   new_storedi = force_gimple_operand_bsi (&bsi,\n \t\t\t\t\t  fold_convert (itype, new_storedi),\n \t\t\t\t\t  true, NULL_TREE,\n \t\t\t\t\t  true, BSI_SAME_STMT);\n-  if (storedi == stored_val)\n-    new_stored = new_storedi;\n-  else\n-    new_stored = force_gimple_operand_bsi (&bsi,\n-\t\t\t\t\t   build1 (VIEW_CONVERT_EXPR, type,\n-\t\t\t\t\t\t   new_storedi), true,\n-\t\t\t\t\t   NULL_TREE, true, BSI_SAME_STMT);\n \n   if (gimple_in_ssa_p (cfun))\n     old_vali = loadedi;\n   else\n     {\n       old_vali = create_tmp_var (itype, NULL);\n+      if (gimple_in_ssa_p (cfun))\n+\tadd_referenced_var (old_vali);\n       x = build_gimple_modify_stmt (old_vali, loadedi);\n-      bsi_insert_before (&bsi, x, BSI_SAME_STMT);\n+      force_gimple_operand_bsi (&bsi, x, true, NULL_TREE,\n+\t\t\t\ttrue, BSI_SAME_STMT);\n \n-      x = build_gimple_modify_stmt (loaded_val, new_stored);\n-      bsi_insert_before (&bsi, x, BSI_SAME_STMT);\n+      x = build_gimple_modify_stmt (loadedi, new_storedi);\n+      force_gimple_operand_bsi (&bsi, x, true, NULL_TREE,\n+\t\t\t\ttrue, BSI_SAME_STMT);\n     }\n \n   /* Note that we always perform the comparison as an integer, even for\n      floating point.  This allows the atomic operation to properly \n      succeed even with NaNs and -0.0.  */\n-  x = build3 (COND_EXPR, void_type_node,\n-\t      build2 (NE_EXPR, boolean_type_node,\n-\t\t      new_storedi, old_vali), NULL_TREE, NULL_TREE);\n+  x = build2 (NE_EXPR, boolean_type_node, new_storedi, old_vali);\n+  x = build3 (COND_EXPR, void_type_node, x, NULL_TREE, NULL_TREE);\n   bsi_insert_before (&bsi, x, BSI_SAME_STMT);\n \n   /* Update cfg.  */\n@@ -3859,12 +3888,12 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n \n   e = make_edge (store_bb, loop_header, EDGE_TRUE_VALUE);\n \n-  /* Copy the new value to loaded_val (we already did that before the condition\n+  /* Copy the new value to loadedi (we already did that before the condition\n      if we are not in SSA).  */\n   if (gimple_in_ssa_p (cfun))\n     {\n       phi = phi_nodes (loop_header);\n-      SET_USE (PHI_ARG_DEF_PTR_FROM_EDGE (phi, e), new_stored);\n+      SET_USE (PHI_ARG_DEF_PTR_FROM_EDGE (phi, e), new_storedi);\n     }\n \n   /* Remove OMP_ATOMIC_STORE.  */"}, {"sha": "3e98750e75159150e11f56ee5223f270a75bcff2", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c18c98c0ade56bc46ce65bbf5cdff26a2577c990/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c18c98c0ade56bc46ce65bbf5cdff26a2577c990/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=c18c98c0ade56bc46ce65bbf5cdff26a2577c990", "patch": "@@ -1,3 +1,10 @@\n+2008-05-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/36106\n+\t* testsuite/libgomp.c/atomic-5.c: New test.\n+\t* testsuite/libgomp.c/atomic-6.c: New test.\n+\t* testsuite/libgomp.c/autopar-1.c: New test.\n+\n 2008-04-21  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* acinclude.m4 (LIBGOMP_CHECK_SYNC_BUILTINS)"}, {"sha": "3b4b0f11d6464e43726d38bb9a57d16ca26e6feb", "filename": "libgomp/testsuite/libgomp.c/atomic-5.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c18c98c0ade56bc46ce65bbf5cdff26a2577c990/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c18c98c0ade56bc46ce65bbf5cdff26a2577c990/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-5.c?ref=c18c98c0ade56bc46ce65bbf5cdff26a2577c990", "patch": "@@ -0,0 +1,40 @@\n+/* PR middle-end/36106 */\n+/* { dg-options \"-O2\" } */\n+/* { dg-options \"-O2 -mcx16\" { target { { i?86-*-* x86_64-*-* } && lp64 } } } */\n+\n+#ifdef __x86_64__\n+# include \"../../../gcc/config/i386/cpuid.h\"\n+#endif\n+\n+extern void abort (void);\n+\n+int __attribute__((noinline))\n+do_test (void)\n+{\n+  long double d = .0L;\n+  int i;\n+  #pragma omp parallel for shared (d)\n+    for (i = 0; i < 10; i++)\n+      #pragma omp atomic\n+\td += 1.0L;\n+  if (d != 10.0L)\n+    abort ();\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{\n+#ifdef __x86_64__\n+  unsigned int eax, ebx, ecx, edx;\n+\n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+    return 0;\n+\n+  if (ecx & bit_CMPXCHG16B)\n+    do_test ();\n+#else\n+  do_test ();\n+#endif\n+  return 0;\n+}"}, {"sha": "949fc3d73da995640a7042ec52672e9f5414e1c0", "filename": "libgomp/testsuite/libgomp.c/atomic-6.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c18c98c0ade56bc46ce65bbf5cdff26a2577c990/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c18c98c0ade56bc46ce65bbf5cdff26a2577c990/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-6.c?ref=c18c98c0ade56bc46ce65bbf5cdff26a2577c990", "patch": "@@ -0,0 +1,36 @@\n+/* PR middle-end/36106 */\n+/* { dg-options \"-O2\" } */\n+/* { dg-options \"-O2 -march=i586\" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */\n+\n+#ifdef __i386__\n+# include \"../../../gcc/config/i386/cpuid.h\"\n+#endif\n+\n+extern void abort (void);\n+\n+union { unsigned long long l; double d; } u = { .l = 0x7ff0000000072301ULL };\n+\n+int __attribute__((noinline))\n+do_test (void)\n+{\n+#pragma omp atomic\n+  u.d += 1.0L;\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{\n+#ifdef __i386__\n+  unsigned int eax, ebx, ecx, edx;\n+\n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+    return 0;\n+\n+  if (edx & bit_CMPXCHG8B)\n+    do_test ();\n+#else\n+  do_test ();\n+#endif\n+  return 0;\n+}"}, {"sha": "e56549b484554ed52b52153bd83198b5652bd84a", "filename": "libgomp/testsuite/libgomp.c/autopar-1.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c18c98c0ade56bc46ce65bbf5cdff26a2577c990/libgomp%2Ftestsuite%2Flibgomp.c%2Fautopar-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c18c98c0ade56bc46ce65bbf5cdff26a2577c990/libgomp%2Ftestsuite%2Flibgomp.c%2Fautopar-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fautopar-1.c?ref=c18c98c0ade56bc46ce65bbf5cdff26a2577c990", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do run } */\n+/* { dg-options \"-ftree-parallelize-loops=4 -O2 -ffast-math\" } */\n+\n+extern void abort (void);\n+\n+double d[1024], e[1024];\n+int f[1024], g[1024];\n+\n+double __attribute__((noinline))\n+foo (void)\n+{\n+  double s = 0.0;\n+  int i;\n+  for (i = 0; i < 1024; i++)\n+    s += d[i] - e[i];\n+  return s;\n+}\n+\n+int __attribute__((noinline))\n+bar (void)\n+{\n+  int s = 0, i;\n+  for (i = 0; i < 1024; i++)\n+    s += f[i] - g[i];\n+  return s;\n+}\n+\n+int\n+main (void)\n+{\n+  int i;\n+  for (i = 0; i < 1024; i++)\n+    {\n+      d[i] = i * 2;\n+      e[i] = i;\n+      f[i] = i * 2;\n+      g[i] = i;\n+    }\n+  if (foo () != 1023 * 1024 / 2)\n+    abort ();\n+  if (bar () != 1023 * 1024 / 2)\n+    abort ();\n+  return 0;\n+}"}]}