{"sha": "d018b46e328163477ca334b844bb7ea9f99c42f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDAxOGI0NmUzMjgxNjM0NzdjYTMzNGI4NDRiYjdlYTlmOTljNDJmNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-06-28T22:25:52Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-06-28T22:25:52Z"}, "message": "arm: Convert thumb1 prologue to rtl.\n\n\t* config/arm/arm.c (arm_output_function_prologue): Don't call\n\tthumb1_output_function_prologue.\n\t(arm_expand_prologue): Avoid dead store.\n\t(number_of_first_bit_set): Use ctz_hwi.\n\t(thumb1_emit_multi_reg_push): New.\n\t(thumb1_expand_prologue): Merge thumb1_output_function_prologue\n\tto emit the entire prologue as rtl.\n\t(thumb1_output_interwork): Split out from\n\tthumb1_output_function_prologue.\n\t(thumb1_output_function_prologue): Remove.\n\t(arm_attr_length_push_multi): Handle thumb1.\n\t* config/arm/arm.md (VUNSPEC_THUMB1_INTERWORK): New.\n\t(prologue_thumb1_interwork): New.\n\t(*push_multi): Allow thumb1; use push_mult_memory_operand.\n\t* config/arm/predicates.md (push_mult_memory_operand): New.\n\nFrom-SVN: r175605", "tree": {"sha": "b1586d5c102be17c270f77a234a8541ca6a5fc98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1586d5c102be17c270f77a234a8541ca6a5fc98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d018b46e328163477ca334b844bb7ea9f99c42f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d018b46e328163477ca334b844bb7ea9f99c42f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d018b46e328163477ca334b844bb7ea9f99c42f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d018b46e328163477ca334b844bb7ea9f99c42f7/comments", "author": null, "committer": null, "parents": [{"sha": "97269a2340c812667bc083a1927f646d76d90b37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97269a2340c812667bc083a1927f646d76d90b37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97269a2340c812667bc083a1927f646d76d90b37"}], "stats": {"total": 622, "additions": 365, "deletions": 257}, "files": [{"sha": "fafbae50af14ca4f76e62f207df25608aadb2fc6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d018b46e328163477ca334b844bb7ea9f99c42f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d018b46e328163477ca334b844bb7ea9f99c42f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d018b46e328163477ca334b844bb7ea9f99c42f7", "patch": "@@ -1,3 +1,21 @@\n+2011-06-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/arm/arm.c (arm_output_function_prologue): Don't call\n+\tthumb1_output_function_prologue.\n+\t(arm_expand_prologue): Avoid dead store.\n+\t(number_of_first_bit_set): Use ctz_hwi.\n+\t(thumb1_emit_multi_reg_push): New.\n+\t(thumb1_expand_prologue): Merge thumb1_output_function_prologue\n+\tto emit the entire prologue as rtl.\n+\t(thumb1_output_interwork): Split out from\n+\tthumb1_output_function_prologue.\n+\t(thumb1_output_function_prologue): Remove.\n+\t(arm_attr_length_push_multi): Handle thumb1.\n+\t* config/arm/arm.md (VUNSPEC_THUMB1_INTERWORK): New.\n+\t(prologue_thumb1_interwork): New.\n+\t(*push_multi): Allow thumb1; use push_mult_memory_operand.\n+\t* config/arm/predicates.md (push_mult_memory_operand): New.\n+\n 2011-06-28  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/sparc/sync.md (*stbar): Delete.\n@@ -863,7 +881,7 @@\n \n 2011-06-20  Changpeng Fang  <changpeng.fang@amd.com>\n \n-        PR i386/49089\n+\tPR i386/49089\n \t* config/i386/i386.c (avx256_split_unaligned_load): New definition.\n \t(avx256_split_unaligned_store): New definition.\n \t(ix86_option_override_internal): Enable avx256 unaligned load/store"}, {"sha": "2f7c508cfc5211c647d969240c0a8f380ffaa11a", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d018b46e328163477ca334b844bb7ea9f99c42f7/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d018b46e328163477ca334b844bb7ea9f99c42f7/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=d018b46e328163477ca334b844bb7ea9f99c42f7", "patch": "@@ -176,6 +176,7 @@ extern void arm_init_expanders (void);\n extern const char *thumb_unexpanded_epilogue (void);\n extern void thumb1_expand_prologue (void);\n extern void thumb1_expand_epilogue (void);\n+extern const char *thumb1_output_interwork (void);\n #ifdef TREE_CODE\n extern int is_called_in_ARM_mode (tree);\n #endif"}, {"sha": "be036594a8c6e16fbe066ffaad0efa6c55c07c3a", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 306, "deletions": 254, "changes": 560, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d018b46e328163477ca334b844bb7ea9f99c42f7/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d018b46e328163477ca334b844bb7ea9f99c42f7/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=d018b46e328163477ca334b844bb7ea9f99c42f7", "patch": "@@ -126,7 +126,6 @@ static tree arm_handle_notshared_attribute (tree *, tree, tree, int, bool *);\n #endif\n static void arm_output_function_epilogue (FILE *, HOST_WIDE_INT);\n static void arm_output_function_prologue (FILE *, HOST_WIDE_INT);\n-static void thumb1_output_function_prologue (FILE *, HOST_WIDE_INT);\n static int arm_comp_type_attributes (const_tree, const_tree);\n static void arm_set_default_type_attributes (tree);\n static int arm_adjust_cost (rtx, rtx, rtx, int);\n@@ -14571,11 +14570,9 @@ arm_output_function_prologue (FILE *f, HOST_WIDE_INT frame_size)\n {\n   unsigned long func_type;\n \n+  /* ??? Do we want to print some of the below anyway?  */\n   if (TARGET_THUMB1)\n-    {\n-      thumb1_output_function_prologue (f, frame_size);\n-      return;\n-    }\n+    return;\n \n   /* Sanity check.  */\n   gcc_assert (!arm_ccfsm_state && !arm_target_insn);\n@@ -15873,7 +15870,7 @@ arm_expand_prologue (void)\n \t  /* Interrupt functions must not corrupt any registers.\n \t     Creating a frame pointer however, corrupts the IP\n \t     register, so we must push it first.  */\n-\t  insn = emit_multi_reg_push (1 << IP_REGNUM);\n+\t  emit_multi_reg_push (1 << IP_REGNUM);\n \n \t  /* Do not set RTX_FRAME_RELATED_P on this insn.\n \t     The dwarf stack unwinding code only wants to see one\n@@ -20121,14 +20118,73 @@ arm_expand_builtin (tree exp,\n inline static int\n number_of_first_bit_set (unsigned mask)\n {\n-  int bit;\n+  return ctz_hwi (mask);\n+}\n+\n+/* Like emit_multi_reg_push, but allowing for a different set of \n+   registers to be described as saved.  MASK is the set of registers\n+   to be saved; REAL_REGS is the set of registers to be described as\n+   saved.  If REAL_REGS is 0, only describe the stack adjustment.  */\n \n-  for (bit = 0;\n-       (mask & (1 << bit)) == 0;\n-       ++bit)\n-    continue;\n+static rtx\n+thumb1_emit_multi_reg_push (unsigned long mask, unsigned long real_regs)\n+{\n+  unsigned long regno;\n+  rtx par[10], tmp, reg, insn;\n+  int i, j;\n+\n+  /* Build the parallel of the registers actually being stored.  */\n+  for (i = 0; mask; ++i, mask &= mask - 1)\n+    {\n+      regno = ctz_hwi (mask);\n+      reg = gen_rtx_REG (SImode, regno);\n \n-  return bit;\n+      if (i == 0)\n+\ttmp = gen_rtx_UNSPEC (BLKmode, gen_rtvec (1, reg), UNSPEC_PUSH_MULT);\n+      else\n+\ttmp = gen_rtx_USE (VOIDmode, reg);\n+\n+      par[i] = tmp;\n+    }\n+\n+  tmp = plus_constant (stack_pointer_rtx, -4 * i);\n+  tmp = gen_rtx_PRE_MODIFY (Pmode, stack_pointer_rtx, tmp);\n+  tmp = gen_frame_mem (BLKmode, tmp);\n+  tmp = gen_rtx_SET (VOIDmode, tmp, par[0]);\n+  par[0] = tmp;\n+\n+  tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (i, par));\n+  insn = emit_insn (tmp);\n+\n+  /* Always build the stack adjustment note for unwind info.  */\n+  tmp = plus_constant (stack_pointer_rtx, -4 * i);\n+  tmp = gen_rtx_SET (VOIDmode, stack_pointer_rtx, tmp);\n+  par[0] = tmp;\n+\n+  /* Build the parallel of the registers recorded as saved for unwind.  */\n+  for (j = 0; real_regs; ++j, real_regs &= real_regs - 1)\n+    {\n+      regno = ctz_hwi (real_regs);\n+      reg = gen_rtx_REG (SImode, regno);\n+\n+      tmp = plus_constant (stack_pointer_rtx, j * 4);\n+      tmp = gen_frame_mem (SImode, tmp);\n+      tmp = gen_rtx_SET (VOIDmode, tmp, reg);\n+      RTX_FRAME_RELATED_P (tmp) = 1;\n+      par[j + 1] = tmp;\n+    }\n+\n+  if (j == 0)\n+    tmp = par[0];\n+  else\n+    {\n+      RTX_FRAME_RELATED_P (par[0]) = 1;\n+      tmp = gen_rtx_SEQUENCE (VOIDmode, gen_rtvec_v (j + 1, par));\n+    }\n+\n+  add_reg_note (insn, REG_FRAME_RELATED_EXPR, tmp);\n+\n+  return insn;\n }\n \n /* Emit code to push or pop registers to or from the stack.  F is the\n@@ -21004,17 +21060,20 @@ thumb_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n     }\n }\n \n-/* Generate the rest of a function's prologue.  */\n+/* Generate the function's prologue.  */\n+\n void\n thumb1_expand_prologue (void)\n {\n-  rtx insn, dwarf;\n+  rtx insn;\n \n   HOST_WIDE_INT amount;\n   arm_stack_offsets *offsets;\n   unsigned long func_type;\n   int regno;\n   unsigned long live_regs_mask;\n+  unsigned long l_mask;\n+  unsigned high_regs_pushed = 0;\n \n   func_type = arm_current_func_type ();\n \n@@ -21028,8 +21087,206 @@ thumb1_expand_prologue (void)\n       return;\n     }\n \n+  if (is_called_in_ARM_mode (current_function_decl))\n+    emit_insn (gen_prologue_thumb1_interwork ());\n+\n   offsets = arm_get_frame_offsets ();\n   live_regs_mask = offsets->saved_regs_mask;\n+\n+  /* Extract a mask of the ones we can give to the Thumb's push instruction.  */\n+  l_mask = live_regs_mask & 0x40ff;\n+  /* Then count how many other high registers will need to be pushed.  */\n+  high_regs_pushed = bit_count (live_regs_mask & 0x0f00);\n+\n+  if (crtl->args.pretend_args_size)\n+    {\n+      rtx x = GEN_INT (-crtl->args.pretend_args_size);\n+\n+      if (cfun->machine->uses_anonymous_args)\n+\t{\n+\t  int num_pushes = ARM_NUM_INTS (crtl->args.pretend_args_size);\n+\t  unsigned long mask;\n+\n+\t  mask = 1ul << (LAST_ARG_REGNUM + 1);\n+\t  mask -= 1ul << (LAST_ARG_REGNUM + 1 - num_pushes);\n+\n+\t  insn = thumb1_emit_multi_reg_push (mask, 0);\n+\t}\n+      else\n+\t{\n+\t  insn = emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t\tstack_pointer_rtx, x));\n+\t}\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  if (TARGET_BACKTRACE)\n+    {\n+      HOST_WIDE_INT offset = 0;\n+      unsigned work_register;\n+      rtx work_reg, x, arm_hfp_rtx;\n+\n+      /* We have been asked to create a stack backtrace structure.\n+         The code looks like this:\n+\n+\t 0   .align 2\n+\t 0   func:\n+         0     sub   SP, #16         Reserve space for 4 registers.\n+\t 2     push  {R7}            Push low registers.\n+         4     add   R7, SP, #20     Get the stack pointer before the push.\n+         6     str   R7, [SP, #8]    Store the stack pointer\n+\t\t\t\t\t(before reserving the space).\n+         8     mov   R7, PC          Get hold of the start of this code + 12.\n+        10     str   R7, [SP, #16]   Store it.\n+        12     mov   R7, FP          Get hold of the current frame pointer.\n+        14     str   R7, [SP, #4]    Store it.\n+        16     mov   R7, LR          Get hold of the current return address.\n+        18     str   R7, [SP, #12]   Store it.\n+        20     add   R7, SP, #16     Point at the start of the\n+\t\t\t\t\tbacktrace structure.\n+        22     mov   FP, R7          Put this value into the frame pointer.  */\n+\n+      work_register = thumb_find_work_register (live_regs_mask);\n+      work_reg = gen_rtx_REG (SImode, work_register);\n+      arm_hfp_rtx = gen_rtx_REG (SImode, ARM_HARD_FRAME_POINTER_REGNUM);\n+\n+      insn = emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t    stack_pointer_rtx, GEN_INT (-16)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      if (l_mask)\n+\t{\n+\t  insn = thumb1_emit_multi_reg_push (l_mask, l_mask);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\n+\t  offset = bit_count (l_mask) * UNITS_PER_WORD;\n+\t}\n+\n+      x = GEN_INT (offset + 16 + crtl->args.pretend_args_size);\n+      emit_insn (gen_addsi3 (work_reg, stack_pointer_rtx, x));\n+\n+      x = plus_constant (stack_pointer_rtx, offset + 4);\n+      x = gen_frame_mem (SImode, x);\n+      emit_move_insn (x, work_reg);\n+\n+      /* Make sure that the instruction fetching the PC is in the right place\n+\t to calculate \"start of backtrace creation code + 12\".  */\n+      /* ??? The stores using the common WORK_REG ought to be enough to\n+\t prevent the scheduler from doing anything weird.  Failing that\n+\t we could always move all of the following into an UNSPEC_VOLATILE.  */\n+      if (l_mask)\n+\t{\n+\t  x = gen_rtx_REG (SImode, PC_REGNUM);\n+\t  emit_move_insn (work_reg, x);\n+\n+\t  x = plus_constant (stack_pointer_rtx, offset + 12);\n+\t  x = gen_frame_mem (SImode, x);\n+\t  emit_move_insn (x, work_reg);\n+\n+\t  emit_move_insn (work_reg, arm_hfp_rtx);\n+\n+\t  x = plus_constant (stack_pointer_rtx, offset);\n+\t  x = gen_frame_mem (SImode, x);\n+\t  emit_move_insn (x, work_reg);\n+\t}\n+      else\n+\t{\n+\t  emit_move_insn (work_reg, arm_hfp_rtx);\n+\n+\t  x = plus_constant (stack_pointer_rtx, offset);\n+\t  x = gen_frame_mem (SImode, x);\n+\t  emit_move_insn (x, work_reg);\n+\n+\t  x = gen_rtx_REG (SImode, PC_REGNUM);\n+\t  emit_move_insn (work_reg, x);\n+\n+\t  x = plus_constant (stack_pointer_rtx, offset + 12);\n+\t  x = gen_frame_mem (SImode, x);\n+\t  emit_move_insn (x, work_reg);\n+\t}\n+\n+      x = gen_rtx_REG (SImode, LR_REGNUM);\n+      emit_move_insn (work_reg, x);\n+\n+      x = plus_constant (stack_pointer_rtx, offset + 8);\n+      x = gen_frame_mem (SImode, x);\n+      emit_move_insn (x, work_reg);\n+\n+      x = GEN_INT (offset + 12);\n+      emit_insn (gen_addsi3 (work_reg, stack_pointer_rtx, x));\n+\n+      emit_move_insn (arm_hfp_rtx, work_reg);\n+    }\n+  /* Optimization:  If we are not pushing any low registers but we are going\n+     to push some high registers then delay our first push.  This will just\n+     be a push of LR and we can combine it with the push of the first high\n+     register.  */\n+  else if ((l_mask & 0xff) != 0\n+\t   || (high_regs_pushed == 0 && l_mask))\n+    {\n+      unsigned long mask = l_mask;\n+      mask |= (1 << thumb1_extra_regs_pushed (offsets, true)) - 1;\n+      insn = thumb1_emit_multi_reg_push (mask, mask);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  if (high_regs_pushed)\n+    {\n+      unsigned pushable_regs;\n+      unsigned next_hi_reg;\n+\n+      for (next_hi_reg = 12; next_hi_reg > LAST_LO_REGNUM; next_hi_reg--)\n+\tif (live_regs_mask & (1 << next_hi_reg))\n+\t  break;\n+\n+      pushable_regs = l_mask & 0xff;\n+\n+      if (pushable_regs == 0)\n+\tpushable_regs = 1 << thumb_find_work_register (live_regs_mask);\n+\n+      while (high_regs_pushed > 0)\n+\t{\n+\t  unsigned long real_regs_mask = 0;\n+\n+\t  for (regno = LAST_LO_REGNUM; regno >= 0; regno --)\n+\t    {\n+\t      if (pushable_regs & (1 << regno))\n+\t\t{\n+\t\t  emit_move_insn (gen_rtx_REG (SImode, regno),\n+\t\t\t\t  gen_rtx_REG (SImode, next_hi_reg));\n+\n+\t\t  high_regs_pushed --;\n+\t\t  real_regs_mask |= (1 << next_hi_reg);\n+\n+\t\t  if (high_regs_pushed)\n+\t\t    {\n+\t\t      for (next_hi_reg --; next_hi_reg > LAST_LO_REGNUM;\n+\t\t\t   next_hi_reg --)\n+\t\t\tif (live_regs_mask & (1 << next_hi_reg))\n+\t\t\t  break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      pushable_regs &= ~((1 << regno) - 1);\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  /* If we had to find a work register and we have not yet\n+\t     saved the LR then add it to the list of regs to push.  */\n+\t  if (l_mask == (1 << LR_REGNUM))\n+\t    {\n+\t      pushable_regs |= l_mask;\n+\t      real_regs_mask |= l_mask;\n+\t      l_mask = 0;\n+\t    }\n+\n+\t  insn = thumb1_emit_multi_reg_push (pushable_regs, real_regs_mask);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+    }\n+\n   /* Load the pic register before setting the frame pointer,\n      so we can use r7 as a temporary work register.  */\n   if (flag_pic && arm_pic_register != INVALID_REGNUM)\n@@ -21055,7 +21312,7 @@ thumb1_expand_prologue (void)\n \t}\n       else\n \t{\n-\t  rtx reg;\n+\t  rtx reg, dwarf;\n \n \t  /* The stack decrement is too big for an immediate value in a single\n \t     insn.  In theory we could issue multiple subtracts, but after\n@@ -21083,12 +21340,12 @@ thumb1_expand_prologue (void)\n \n \t  insn = emit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t\t\tstack_pointer_rtx, reg));\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\n \t  dwarf = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n \t\t\t       plus_constant (stack_pointer_rtx,\n \t\t\t\t\t      -amount));\n-\t  RTX_FRAME_RELATED_P (dwarf) = 1;\n \t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n     }\n \n@@ -21165,253 +21422,45 @@ thumb1_expand_epilogue (void)\n     emit_use (gen_rtx_REG (SImode, LR_REGNUM));\n }\n \n-static void\n-thumb1_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n-{\n-  arm_stack_offsets *offsets;\n-  unsigned long live_regs_mask = 0;\n-  unsigned long l_mask;\n-  unsigned high_regs_pushed = 0;\n-  int cfa_offset = 0;\n-  int regno;\n+/* Implementation of insn prologue_thumb1_interwork.  This is the first\n+   \"instruction\" of a function called in ARM mode.  Swap to thumb mode.  */\n \n-  if (IS_NAKED (arm_current_func_type ()))\n-    return;\n-\n-  if (is_called_in_ARM_mode (current_function_decl))\n-    {\n-      const char * name;\n+const char *\n+thumb1_output_interwork (void)\n+{\n+  const char * name;\n+  FILE *f = asm_out_file;\n \n-      gcc_assert (GET_CODE (DECL_RTL (current_function_decl)) == MEM);\n-      gcc_assert (GET_CODE (XEXP (DECL_RTL (current_function_decl), 0))\n-\t\t  == SYMBOL_REF);\n-      name = XSTR  (XEXP (DECL_RTL (current_function_decl), 0), 0);\n+  gcc_assert (GET_CODE (DECL_RTL (current_function_decl)) == MEM);\n+  gcc_assert (GET_CODE (XEXP (DECL_RTL (current_function_decl), 0))\n+\t      == SYMBOL_REF);\n+  name = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n \n-      /* Generate code sequence to switch us into Thumb mode.  */\n-      /* The .code 32 directive has already been emitted by\n-\t ASM_DECLARE_FUNCTION_NAME.  */\n-      asm_fprintf (f, \"\\torr\\t%r, %r, #1\\n\", IP_REGNUM, PC_REGNUM);\n-      asm_fprintf (f, \"\\tbx\\t%r\\n\", IP_REGNUM);\n+  /* Generate code sequence to switch us into Thumb mode.  */\n+  /* The .code 32 directive has already been emitted by\n+     ASM_DECLARE_FUNCTION_NAME.  */\n+  asm_fprintf (f, \"\\torr\\t%r, %r, #1\\n\", IP_REGNUM, PC_REGNUM);\n+  asm_fprintf (f, \"\\tbx\\t%r\\n\", IP_REGNUM);\n \n-      /* Generate a label, so that the debugger will notice the\n-\t change in instruction sets.  This label is also used by\n-\t the assembler to bypass the ARM code when this function\n-\t is called from a Thumb encoded function elsewhere in the\n-\t same file.  Hence the definition of STUB_NAME here must\n-\t agree with the definition in gas/config/tc-arm.c.  */\n+  /* Generate a label, so that the debugger will notice the\n+     change in instruction sets.  This label is also used by\n+     the assembler to bypass the ARM code when this function\n+     is called from a Thumb encoded function elsewhere in the\n+     same file.  Hence the definition of STUB_NAME here must\n+     agree with the definition in gas/config/tc-arm.c.  */\n \n #define STUB_NAME \".real_start_of\"\n \n-      fprintf (f, \"\\t.code\\t16\\n\");\n+  fprintf (f, \"\\t.code\\t16\\n\");\n #ifdef ARM_PE\n-      if (arm_dllexport_name_p (name))\n-        name = arm_strip_name_encoding (name);\n+  if (arm_dllexport_name_p (name))\n+    name = arm_strip_name_encoding (name);\n #endif\n-      asm_fprintf (f, \"\\t.globl %s%U%s\\n\", STUB_NAME, name);\n-      fprintf (f, \"\\t.thumb_func\\n\");\n-      asm_fprintf (f, \"%s%U%s:\\n\", STUB_NAME, name);\n-    }\n-\n-  if (crtl->args.pretend_args_size)\n-    {\n-      /* Output unwind directive for the stack adjustment.  */\n-      if (arm_except_unwind_info (&global_options) == UI_TARGET)\n-\tfprintf (f, \"\\t.pad #%d\\n\",\n-\t\t crtl->args.pretend_args_size);\n-\n-      if (cfun->machine->uses_anonymous_args)\n-\t{\n-\t  int num_pushes;\n-\n-\t  fprintf (f, \"\\tpush\\t{\");\n-\n-\t  num_pushes = ARM_NUM_INTS (crtl->args.pretend_args_size);\n-\n-\t  for (regno = LAST_ARG_REGNUM + 1 - num_pushes;\n-\t       regno <= LAST_ARG_REGNUM;\n-\t       regno++)\n-\t    asm_fprintf (f, \"%r%s\", regno,\n-\t\t\t regno == LAST_ARG_REGNUM ? \"\" : \", \");\n-\n-\t  fprintf (f, \"}\\n\");\n-\t}\n-      else\n-\tasm_fprintf (f, \"\\tsub\\t%r, %r, #%d\\n\",\n-\t\t     SP_REGNUM, SP_REGNUM,\n-\t\t     crtl->args.pretend_args_size);\n-\n-      /* We don't need to record the stores for unwinding (would it\n-\t help the debugger any if we did?), but record the change in\n-\t the stack pointer.  */\n-      if (dwarf2out_do_frame ())\n-\t{\n-\t  char *l = dwarf2out_cfi_label (false);\n-\n-\t  cfa_offset = cfa_offset + crtl->args.pretend_args_size;\n-\t  dwarf2out_def_cfa (l, SP_REGNUM, cfa_offset);\n-\t}\n-    }\n+  asm_fprintf (f, \"\\t.globl %s%U%s\\n\", STUB_NAME, name);\n+  fprintf (f, \"\\t.thumb_func\\n\");\n+  asm_fprintf (f, \"%s%U%s:\\n\", STUB_NAME, name);\n \n-  /* Get the registers we are going to push.  */\n-  offsets = arm_get_frame_offsets ();\n-  live_regs_mask = offsets->saved_regs_mask;\n-  /* Extract a mask of the ones we can give to the Thumb's push instruction.  */\n-  l_mask = live_regs_mask & 0x40ff;\n-  /* Then count how many other high registers will need to be pushed.  */\n-  high_regs_pushed = bit_count (live_regs_mask & 0x0f00);\n-\n-  if (TARGET_BACKTRACE)\n-    {\n-      unsigned offset;\n-      unsigned work_register;\n-\n-      /* We have been asked to create a stack backtrace structure.\n-         The code looks like this:\n-\n-\t 0   .align 2\n-\t 0   func:\n-         0     sub   SP, #16         Reserve space for 4 registers.\n-\t 2     push  {R7}            Push low registers.\n-         4     add   R7, SP, #20     Get the stack pointer before the push.\n-         6     str   R7, [SP, #8]    Store the stack pointer (before reserving the space).\n-         8     mov   R7, PC          Get hold of the start of this code plus 12.\n-        10     str   R7, [SP, #16]   Store it.\n-        12     mov   R7, FP          Get hold of the current frame pointer.\n-        14     str   R7, [SP, #4]    Store it.\n-        16     mov   R7, LR          Get hold of the current return address.\n-        18     str   R7, [SP, #12]   Store it.\n-        20     add   R7, SP, #16     Point at the start of the backtrace structure.\n-        22     mov   FP, R7          Put this value into the frame pointer.  */\n-\n-      work_register = thumb_find_work_register (live_regs_mask);\n-\n-      if (arm_except_unwind_info (&global_options) == UI_TARGET)\n-\tasm_fprintf (f, \"\\t.pad #16\\n\");\n-\n-      asm_fprintf\n-\t(f, \"\\tsub\\t%r, %r, #16\\t%@ Create stack backtrace structure\\n\",\n-\t SP_REGNUM, SP_REGNUM);\n-\n-      if (dwarf2out_do_frame ())\n-\t{\n-\t  char *l = dwarf2out_cfi_label (false);\n-\n-\t  cfa_offset = cfa_offset + 16;\n-\t  dwarf2out_def_cfa (l, SP_REGNUM, cfa_offset);\n-\t}\n-\n-      if (l_mask)\n-\t{\n-\t  thumb_pushpop (f, l_mask, 1, &cfa_offset, l_mask);\n-\t  offset = bit_count (l_mask) * UNITS_PER_WORD;\n-\t}\n-      else\n-\toffset = 0;\n-\n-      asm_fprintf (f, \"\\tadd\\t%r, %r, #%d\\n\", work_register, SP_REGNUM,\n-\t\t   offset + 16 + crtl->args.pretend_args_size);\n-\n-      asm_fprintf (f, \"\\tstr\\t%r, [%r, #%d]\\n\", work_register, SP_REGNUM,\n-\t\t   offset + 4);\n-\n-      /* Make sure that the instruction fetching the PC is in the right place\n-\t to calculate \"start of backtrace creation code + 12\".  */\n-      if (l_mask)\n-\t{\n-\t  asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", work_register, PC_REGNUM);\n-\t  asm_fprintf (f, \"\\tstr\\t%r, [%r, #%d]\\n\", work_register, SP_REGNUM,\n-\t\t       offset + 12);\n-\t  asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", work_register,\n-\t\t       ARM_HARD_FRAME_POINTER_REGNUM);\n-\t  asm_fprintf (f, \"\\tstr\\t%r, [%r, #%d]\\n\", work_register, SP_REGNUM,\n-\t\t       offset);\n-\t}\n-      else\n-\t{\n-\t  asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", work_register,\n-\t\t       ARM_HARD_FRAME_POINTER_REGNUM);\n-\t  asm_fprintf (f, \"\\tstr\\t%r, [%r, #%d]\\n\", work_register, SP_REGNUM,\n-\t\t       offset);\n-\t  asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", work_register, PC_REGNUM);\n-\t  asm_fprintf (f, \"\\tstr\\t%r, [%r, #%d]\\n\", work_register, SP_REGNUM,\n-\t\t       offset + 12);\n-\t}\n-\n-      asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", work_register, LR_REGNUM);\n-      asm_fprintf (f, \"\\tstr\\t%r, [%r, #%d]\\n\", work_register, SP_REGNUM,\n-\t\t   offset + 8);\n-      asm_fprintf (f, \"\\tadd\\t%r, %r, #%d\\n\", work_register, SP_REGNUM,\n-\t\t   offset + 12);\n-      asm_fprintf (f, \"\\tmov\\t%r, %r\\t\\t%@ Backtrace structure created\\n\",\n-\t\t   ARM_HARD_FRAME_POINTER_REGNUM, work_register);\n-    }\n-  /* Optimization:  If we are not pushing any low registers but we are going\n-     to push some high registers then delay our first push.  This will just\n-     be a push of LR and we can combine it with the push of the first high\n-     register.  */\n-  else if ((l_mask & 0xff) != 0\n-\t   || (high_regs_pushed == 0 && l_mask))\n-    {\n-      unsigned long mask = l_mask;\n-      mask |= (1 << thumb1_extra_regs_pushed (offsets, true)) - 1;\n-      thumb_pushpop (f, mask, 1, &cfa_offset, mask);\n-    }\n-\n-  if (high_regs_pushed)\n-    {\n-      unsigned pushable_regs;\n-      unsigned next_hi_reg;\n-\n-      for (next_hi_reg = 12; next_hi_reg > LAST_LO_REGNUM; next_hi_reg--)\n-\tif (live_regs_mask & (1 << next_hi_reg))\n-\t  break;\n-\n-      pushable_regs = l_mask & 0xff;\n-\n-      if (pushable_regs == 0)\n-\tpushable_regs = 1 << thumb_find_work_register (live_regs_mask);\n-\n-      while (high_regs_pushed > 0)\n-\t{\n-\t  unsigned long real_regs_mask = 0;\n-\n-\t  for (regno = LAST_LO_REGNUM; regno >= 0; regno --)\n-\t    {\n-\t      if (pushable_regs & (1 << regno))\n-\t\t{\n-\t\t  asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", regno, next_hi_reg);\n-\n-\t\t  high_regs_pushed --;\n-\t\t  real_regs_mask |= (1 << next_hi_reg);\n-\n-\t\t  if (high_regs_pushed)\n-\t\t    {\n-\t\t      for (next_hi_reg --; next_hi_reg > LAST_LO_REGNUM;\n-\t\t\t   next_hi_reg --)\n-\t\t\tif (live_regs_mask & (1 << next_hi_reg))\n-\t\t\t  break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      pushable_regs &= ~((1 << regno) - 1);\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  /* If we had to find a work register and we have not yet\n-\t     saved the LR then add it to the list of regs to push.  */\n-\t  if (l_mask == (1 << LR_REGNUM))\n-\t    {\n-\t      thumb_pushpop (f, pushable_regs | (1 << LR_REGNUM),\n-\t\t\t     1, &cfa_offset,\n-\t\t\t     real_regs_mask | (1 << LR_REGNUM));\n-\t      l_mask = 0;\n-\t    }\n-\t  else\n-\t    thumb_pushpop (f, pushable_regs, 1, &cfa_offset, real_regs_mask);\n-\t}\n-    }\n+  return \"\";\n }\n \n /* Handle the case of a double word load into a low register from\n@@ -23949,6 +23998,9 @@ arm_attr_length_push_multi(rtx parallel_op, rtx first_op)\n   /* ARM mode.  */\n   if (TARGET_ARM)\n     return 4;\n+  /* Thumb1 mode.  */\n+  if (TARGET_THUMB1)\n+    return 2;\n \n   /* Thumb2 mode.  */\n   regno = REGNO (first_op);"}, {"sha": "2bf3551a4141f805aa59c6b5f980e1c50cd698f7", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d018b46e328163477ca334b844bb7ea9f99c42f7/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d018b46e328163477ca334b844bb7ea9f99c42f7/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=d018b46e328163477ca334b844bb7ea9f99c42f7", "patch": "@@ -116,6 +116,8 @@\n                         ;   instruction epilogue sequence that isn't expanded\n                         ;   into normal RTL.  Used for both normal and sibcall\n                         ;   epilogues.\n+  VUNSPEC_THUMB1_INTERWORK ; `prologue_thumb1_interwork' insn, used to swap\n+\t\t\t;   modes from arm to thumb.\n   VUNSPEC_ALIGN         ; `align' insn.  Used at the head of a minipool table\n                         ;   for inlined constants.\n   VUNSPEC_POOL_END      ; `end-of-table'.  Used to mark the end of a minipool\n@@ -10121,6 +10123,13 @@\n   \"\n )\n \n+(define_insn \"prologue_thumb1_interwork\"\n+  [(unspec_volatile [(const_int 0)] VUNSPEC_THUMB1_INTERWORK)]\n+  \"TARGET_THUMB1\"\n+  \"* return thumb1_output_interwork ();\"\n+  [(set_attr \"length\" \"8\")]\n+)\n+\n ;; Note - although unspec_volatile's USE all hard registers,\n ;; USEs are ignored after relaod has completed.  Thus we need\n ;; to add an unspec of the link register to ensure that flow\n@@ -10365,10 +10374,10 @@\n ;; in a C function arm_attr_length_push_multi.\n (define_insn \"*push_multi\"\n   [(match_parallel 2 \"multi_register_push\"\n-    [(set (match_operand:BLK 0 \"memory_operand\" \"=m\")\n+    [(set (match_operand:BLK 0 \"push_mult_memory_operand\" \"\")\n \t  (unspec:BLK [(match_operand:SI 1 \"s_register_operand\" \"\")]\n \t\t      UNSPEC_PUSH_MULT))])]\n-  \"TARGET_32BIT\"\n+  \"\"\n   \"*\n   {\n     int num_saves = XVECLEN (operands[2], 0);"}, {"sha": "215d58df5168c44c2c4e5f8e2d5e668222f0cfdd", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d018b46e328163477ca334b844bb7ea9f99c42f7/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d018b46e328163477ca334b844bb7ea9f99c42f7/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=d018b46e328163477ca334b844bb7ea9f99c42f7", "patch": "@@ -508,6 +508,34 @@\n   return true;\n })\n \n+(define_predicate \"push_mult_memory_operand\"\n+  (match_code \"mem\")\n+{\n+  /* ??? Given how PUSH_MULT is generated in the prologues, is there\n+     any point in testing for thumb1 specially?  All of the variants\n+     use the same form.  */\n+  if (TARGET_THUMB1)\n+    {\n+      /* ??? No attempt is made to represent STMIA, or validate that\n+\t the stack adjustment matches the register count.  This is\n+\t true of the ARM/Thumb2 path as well.  */\n+      rtx x = XEXP (op, 0);\n+      if (GET_CODE (x) != PRE_MODIFY)\n+\treturn false;\n+      if (XEXP (x, 0) != stack_pointer_rtx)\n+\treturn false;\n+      x = XEXP (x, 1);\n+      if (GET_CODE (x) != PLUS)\n+\treturn false;\n+      if (XEXP (x, 0) != stack_pointer_rtx)\n+\treturn false;\n+      return CONST_INT_P (XEXP (x, 1));\n+    }\n+\n+  /* ARM and Thumb2 handle pre-modify in their legitimate_address.  */\n+  return memory_operand (op, mode);\n+})\n+\n ;;-------------------------------------------------------------------------\n ;;\n ;; Thumb predicates"}]}