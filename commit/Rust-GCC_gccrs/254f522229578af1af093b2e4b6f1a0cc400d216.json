{"sha": "254f522229578af1af093b2e4b6f1a0cc400d216", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU0ZjUyMjIyOTU3OGFmMWFmMDkzYjJlNGI2ZjFhMGNjNDAwZDIxNg==", "commit": {"author": {"name": "Chen Liqin", "email": "liqin@sunnorth.com.cn", "date": "2007-10-18T06:53:22Z"}, "committer": {"name": "Chen Liqin", "email": "liqin@gcc.gnu.org", "date": "2007-10-18T06:53:22Z"}, "message": "Because we merge score3 and score7 into the same backend,\n\nso make a lot of changes in the code structure.\n\nChangelog:\n        * config.gcc : update score-*-elf(extra_objs).\n        * config/score/mac.md : Remove.\n        * config/score/misc.md : Remove.\n        * config/score/score7.md : Remove.\n        * config/score/score-mdaux.h : Remove.\n        * config/score/score-mdaux.c : Remove.\n        * config/score/score-version.h : Remove.\n        * config/score/score-generic.md : New.\n        * config/score/score3.h : New.\n        * config/score/score3.c : New.\n        * config/score/score7.h : New.\n        * config/score/score7.c : New.\n        * config/score/mul-div.S : add flush_cache score3 support.\n        * config/score/elf.h : Fix some typos.\n        * config/score/score.md : merge score3 and score7 pattern.\n        * config/score/score.c : use to seperate which target it used.\n        * config/score/score.h : use to seperate the target macro.\n        * config/score/score.opt : remove -mmac option , add -mscore3,\n        -mscore3d and -march OPTION support.\n\nFrom-SVN: r129431", "tree": {"sha": "21c6e2a418217219d93231a9992172c5df2f5047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21c6e2a418217219d93231a9992172c5df2f5047"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/254f522229578af1af093b2e4b6f1a0cc400d216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/254f522229578af1af093b2e4b6f1a0cc400d216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/254f522229578af1af093b2e4b6f1a0cc400d216", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/254f522229578af1af093b2e4b6f1a0cc400d216/comments", "author": null, "committer": null, "parents": [{"sha": "23710ddde48ab95c906e89280383aa0c99eea2f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23710ddde48ab95c906e89280383aa0c99eea2f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23710ddde48ab95c906e89280383aa0c99eea2f1"}], "stats": {"total": 11148, "additions": 7884, "deletions": 3264}, "files": [{"sha": "1bf4a2def8f0e5b36b65dd79f382bc561c40c5c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=254f522229578af1af093b2e4b6f1a0cc400d216", "patch": "@@ -1,3 +1,25 @@\n+2007-10-18  Chen Liqin  <liqin@sunnorth.com.cn>\n+\n+        * config.gcc : update score-*-elf(extra_objs).\n+        * config/score/mac.md : Remove.\n+        * config/score/misc.md : Remove.\n+        * config/score/score7.md : Remove.\n+        * config/score/score-mdaux.h : Remove.\n+        * config/score/score-mdaux.c : Remove.\n+        * config/score/score-version.h : Remove.\n+        * config/score/score-generic.md : New.\n+        * config/score/score3.h : New.\n+        * config/score/score3.c : New.\n+        * config/score/score7.h : New.\n+        * config/score/score7.c : New.\n+        * config/score/mul-div.S : add flush_cache score3 support.\n+        * config/score/elf.h : Fix some typos.\n+        * config/score/score.md : merge score3 and score7 pattern.\n+        * config/score/score.c : use to seperate which target it used.\n+        * config/score/score.h : use to seperate the target macro.\n+        * config/score/score.opt : remove -mmac option , add -mscore3,\n+        -mscore3d and -march OPTION support.\n+ \n 2007-10-17  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \t* cfgexpand.c (expand_stack_vars): Add checking to make sure"}, {"sha": "864fa7ce25a44aee08a8a73cc5a3df76a187b21f", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=254f522229578af1af093b2e4b6f1a0cc400d216", "patch": "@@ -2127,7 +2127,7 @@ s390x-ibm-tpf*)\n score-*-elf)\n         tm_file=\"dbxelf.h elfos.h score/elf.h score/score.h\"\n         tmake_file=score/t-score-elf\n-        extra_objs=\"score-mdaux.o\"\n+        extra_objs=\"score7.o score3.o\"\n         ;;\n sh-*-elf* | sh[12346l]*-*-elf* | sh*-*-kaos* | \\\n sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \\"}, {"sha": "b1d3a2ba98be0f0231ece1c311918de4760e0417", "filename": "gcc/config/score/crti.asm", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fcrti.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fcrti.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fcrti.asm?ref=254f522229578af1af093b2e4b6f1a0cc400d216", "patch": "@@ -34,6 +34,7 @@\n \n # This file makes a stack frame for the contents of the .init and\n # .fini sections.\n+.extern _stack\n \n #ifndef __pic__\n .section .init, \"ax\", @progbits\n@@ -88,9 +89,13 @@ _fini:\n         .weak   _start\n         .ent    _start\n         .frame  r0, 0, r3, 0\n-        .mask   0x00000000,0\n+        .mask   0x00000000, 0\n _start:\n-        la      r28, _gp\n+        mv      r29, r3\n+        bl      0f\n+0:\n+        .cpload r3\n+        mv      r3, r29\n         la      r8, __bss_start\n         la      r9, __bss_end__\n         sub!    r9, r8\n@@ -102,22 +107,23 @@ _start:\n         sw      r9, [r8]+, 4\n         bcnz    1b\n         la      r0, _stack\n-        ldiu!   r4, 0\n-        ldiu!   r5, 0\n-        la      r29, main\n+        bl      _init\n+        la      r4, _end\n+        la      r29, _init_argv\n         brl     r29\n         la      r29, exit\n         brl     r29\n         .end    _start\n \n         .weak   _init_argv\n-        .ent\n+        .ent _init_argv\n         .frame  r0, 0, r3, 0\n         .mask   0x00000000, 0\n _init_argv:\n         ldiu!   r4, 0\n         ldiu!   r5, 0\n-        j       main\n+        la      r29, main\n+        brl     r29\n         .end    _init_argv\n \n         .globl  _init\n@@ -126,13 +132,11 @@ _init:\n         addi    r0, -32\n         sw      r3, [r0, 20]\n \n-.section .fini, \"ax\", @progbits\n+        .section .fini, \"ax\", @progbits\n         .globl  _fini\n         .type   _fini, %function\n _fini:\n         addi    r0, -32\n         sw      r3, [r0, 20]\n \n #endif\n-\n-"}, {"sha": "d04373ecd85affed3687f0781be406dd8c887839", "filename": "gcc/config/score/elf.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Felf.h?ref=254f522229578af1af093b2e4b6f1a0cc400d216", "patch": "@@ -32,16 +32,16 @@\n #define TYPE_OPERAND_FMT        \"@%s\"\n \n #undef TYPE_ASM_OP\n-#define TYPE_ASM_OP        \"\\t.type\\t\"\n+#define TYPE_ASM_OP             \"\\t.type\\t\"\n \n #undef SIZE_ASM_OP\n-#define SIZE_ASM_OP        \"\\t.size\\t\"\n+#define SIZE_ASM_OP             \"\\t.size\\t\"\n \n /* A c expression whose value is a string containing the\n    assembler operation to identify the following data as\n    uninitialized global data.  */\n #ifndef BSS_SECTION_ASM_OP\n-#define BSS_SECTION_ASM_OP        \"\\t.section\\t.bss\"\n+#define BSS_SECTION_ASM_OP      \"\\t.section\\t.bss\"\n #endif\n \n #ifndef ASM_OUTPUT_ALIGNED_BSS"}, {"sha": "0b534958d0e1d20287fde11d9b3ebd7cdc468fdd", "filename": "gcc/config/score/mac.md", "status": "removed", "additions": 0, "deletions": 180, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23710ddde48ab95c906e89280383aa0c99eea2f1/gcc%2Fconfig%2Fscore%2Fmac.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23710ddde48ab95c906e89280383aa0c99eea2f1/gcc%2Fconfig%2Fscore%2Fmac.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fmac.md?ref=23710ddde48ab95c906e89280383aa0c99eea2f1", "patch": "@@ -1,180 +0,0 @@\n-;;  Machine description for Sunplus S+CORE\n-;;  Copyright (C) 2005, 2007\n-;;  Free Software Foundation, Inc.\n-;;  Contributed by Sunnorth.\n-\n-;; This file is part of GCC.\n-\n-;; GCC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 3, or (at your option)\n-;; any later version.\n-\n-;; GCC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n-\n-(define_insn \"smaxsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (smax:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                 (match_operand:SI 2 \"register_operand\" \"d\")))]\n-  \"TARGET_MAC || TARGET_SCORE7D\"\n-  \"max     %0, %1, %2\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"sminsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (smin:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                 (match_operand:SI 2 \"register_operand\" \"d\")))]\n-  \"TARGET_MAC || TARGET_SCORE7D\"\n-  \"min     %0, %1, %2\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"abssi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (abs:SI (match_operand:SI 1 \"register_operand\" \"d\")))]\n-  \"TARGET_MAC || TARGET_SCORE7D\"\n-  \"abs     %0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"clzsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (clz:SI (match_operand:SI 1 \"register_operand\" \"d\")))]\n-  \"TARGET_MAC || TARGET_SCORE7D\"\n-  \"clz     %0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"sffs\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (unspec:SI [(match_operand:SI 1 \"register_operand\" \"d\")] SFFS))]\n-  \"TARGET_MAC || TARGET_SCORE7D\"\n-  \"bitrev  %0, %1, r0\\;clz     %0, %0\\;addi    %0, 0x1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"ffssi2\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n-        (ffs:SI (match_operand:SI 1 \"register_operand\")))]\n-  \"TARGET_MAC || TARGET_SCORE7D\"\n-{\n-  emit_insn (gen_sffs (operands[0], operands[1]));\n-  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (CC_NZmode, CC_REGNUM),\n-                          gen_rtx_COMPARE (CC_NZmode, operands[0],\n-                                           GEN_INT (33))));\n-  emit_insn (gen_movsicc_internal (operands[0],\n-             gen_rtx_fmt_ee (EQ, VOIDmode, operands[0], GEN_INT (33)),\n-             GEN_INT (0),\n-             operands[0]));\n-  DONE;\n-})\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"loreg_operand\" \"\")\n-        (match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (match_operand:SI 2 \"hireg_operand\" \"\")\n-        (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"TARGET_MAC || TARGET_SCORE7D\"\n-  [(parallel\n-       [(set (match_dup 0) (match_dup 1))\n-        (set (match_dup 2) (match_dup 3))])])\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"hireg_operand\" \"\")\n-        (match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (match_operand:SI 2 \"loreg_operand\" \"\")\n-        (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"TARGET_MAC || TARGET_SCORE7D\"\n-  [(parallel\n-       [(set (match_dup 2) (match_dup 3))\n-        (set (match_dup 0) (match_dup 1))])])\n-\n-(define_insn \"movtohilo\"\n-  [(parallel\n-       [(set (match_operand:SI 0 \"loreg_operand\" \"=l\")\n-             (match_operand:SI 1 \"register_operand\" \"d\"))\n-        (set (match_operand:SI 2 \"hireg_operand\" \"=h\")\n-             (match_operand:SI 3 \"register_operand\" \"d\"))])]\n-  \"TARGET_MAC || TARGET_SCORE7D\"\n-  \"mtcehl  %3, %1\"\n-  [(set_attr \"type\" \"fce\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"mulsi3addsi\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l,l,d\")\n-        (plus:SI (mult:SI (match_operand:SI 2 \"register_operand\" \"d,d,d\")\n-                          (match_operand:SI 3 \"register_operand\" \"d,d,d\"))\n-                 (match_operand:SI 1 \"register_operand\" \"0,d,l\")))\n-   (clobber (reg:SI HI_REGNUM))]\n-  \"TARGET_MAC || TARGET_SCORE7D\"\n-  \"@\n-   mad     %2, %3\n-   mtcel%S1 %1\\;mad     %2, %3\n-   mad      %2, %3\\;mfcel%S0 %0\"\n-  [(set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"mulsi3subsi\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l,l,d\")\n-        (minus:SI (match_operand:SI 1 \"register_operand\" \"0,d,l\")\n-                  (mult:SI (match_operand:SI 2 \"register_operand\" \"d,d,d\")\n-                           (match_operand:SI 3 \"register_operand\" \"d,d,d\"))))\n-   (clobber (reg:SI HI_REGNUM))]\n-  \"TARGET_MAC || TARGET_SCORE7D\"\n-  \"@\n-   msb     %2, %3\n-   mtcel%S1 %1\\;msb     %2, %3\n-   msb     %2, %3\\;mfcel%S0 %0\"\n-  [(set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"mulsidi3adddi\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-        (plus:DI (mult:DI\n-                  (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"%d\"))\n-                  (sign_extend:DI (match_operand:SI 3 \"register_operand\" \"d\")))\n-                 (match_operand:DI 1 \"register_operand\" \"0\")))]\n-  \"TARGET_MAC || TARGET_SCORE7D\"\n-  \"mad     %2, %3\"\n-  [(set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"umulsidi3adddi\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-        (plus:DI (mult:DI\n-                  (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"%d\"))\n-                  (zero_extend:DI (match_operand:SI 3 \"register_operand\" \"d\")))\n-                 (match_operand:DI 1 \"register_operand\" \"0\")))]\n-  \"TARGET_MAC || TARGET_SCORE7D\"\n-  \"madu    %2, %3\"\n-  [(set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"mulsidi3subdi\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-        (minus:DI\n-         (match_operand:DI 1 \"register_operand\" \"0\")\n-         (mult:DI\n-          (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"%d\"))\n-          (sign_extend:DI (match_operand:SI 3 \"register_operand\" \"d\")))))]\n-  \"TARGET_MAC || TARGET_SCORE7D\"\n-  \"msb     %2, %3\"\n-  [(set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"umulsidi3subdi\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-        (minus:DI\n-         (match_operand:DI 1 \"register_operand\" \"0\")\n-         (mult:DI (zero_extend:DI\n-                   (match_operand:SI 2 \"register_operand\" \"%d\"))\n-                  (zero_extend:DI\n-                   (match_operand:SI 3 \"register_operand\" \"d\")))))]\n-  \"TARGET_MAC || TARGET_SCORE7D\"\n-  \"msbu    %2, %3\"\n-  [(set_attr \"mode\" \"DI\")])"}, {"sha": "c9b293d244c9ebab2446d9c4b0940ba906aa6932", "filename": "gcc/config/score/misc.md", "status": "removed", "additions": 0, "deletions": 381, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23710ddde48ab95c906e89280383aa0c99eea2f1/gcc%2Fconfig%2Fscore%2Fmisc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23710ddde48ab95c906e89280383aa0c99eea2f1/gcc%2Fconfig%2Fscore%2Fmisc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fmisc.md?ref=23710ddde48ab95c906e89280383aa0c99eea2f1", "patch": "@@ -1,381 +0,0 @@\n-;;  Machine description for Sunplus S+CORE\n-;;  Copyright (C) 2005, 2007\n-;;  Free Software Foundation, Inc.\n-;;  Contributed by Sunnorth.\n-\n-;; This file is part of GCC.\n-\n-;; GCC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 3, or (at your option)\n-;; any later version.\n-\n-;; GCC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n-\n-(define_insn \"pushsi\"\n-  [(set (match_operand:SI 0 \"push_operand\" \"=<\")\n-        (match_operand:SI 1 \"register_operand\" \"d\"))]\n-  \"\"\n-  \"push!   %1, [r0]\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"popsi\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (match_operand:SI 1 \"pop_operand\" \">\"))]\n-  \"\"\n-  \"pop!    %0, [r0]\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"g32reg_operand\" \"\")\n-        (match_operand:SI 1 \"loreg_operand\" \"\"))\n-   (set (match_operand:SI 2 \"g32reg_operand\" \"\")\n-        (match_operand:SI 3 \"hireg_operand\" \"\"))]\n-  \"\"\n-  [(parallel\n-       [(set (match_dup 0) (match_dup 1))\n-        (set (match_dup 2) (match_dup 3))])])\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"g32reg_operand\" \"\")\n-        (match_operand:SI 1 \"hireg_operand\" \"\"))\n-   (set (match_operand:SI 2 \"g32reg_operand\" \"\")\n-        (match_operand:SI 3 \"loreg_operand\" \"\"))]\n-  \"\"\n-  [(parallel\n-       [(set (match_dup 2) (match_dup 3))\n-        (set (match_dup 0) (match_dup 1))])])\n-\n-(define_insn \"movhilo\"\n-  [(parallel\n-       [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-             (match_operand:SI 1 \"loreg_operand\" \"\"))\n-        (set (match_operand:SI 2 \"register_operand\" \"=d\")\n-             (match_operand:SI 3 \"hireg_operand\" \"\"))])]\n-  \"\"\n-  \"mfcehl  %2, %0\"\n-  [(set_attr \"type\" \"fce\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"movsicc\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (if_then_else:SI (match_operator 1 \"comparison_operator\"\n-                          [(reg:CC CC_REGNUM) (const_int 0)])\n-                         (match_operand:SI 2 \"register_operand\" \"\")\n-                         (match_operand:SI 3 \"register_operand\" \"\")))]\n-  \"\"\n-{\n-  mdx_movsicc (operands);\n-})\n-\n-(define_insn \"movsicc_internal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (if_then_else:SI (match_operator 1 \"comparison_operator\"\n-                          [(reg:CC CC_REGNUM) (const_int 0)])\n-                         (match_operand:SI 2 \"arith_operand\" \"d\")\n-                         (match_operand:SI 3 \"arith_operand\" \"0\")))]\n-  \"\"\n-  \"mv%C1   %0, %2\"\n-  [(set_attr \"type\" \"cndmv\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"zero_extract_bittst\"\n-  [(set (reg:CC_NZ CC_REGNUM)\n-        (compare:CC_NZ (unspec:SI\n-                        [(match_operand:SI 0 \"register_operand\" \"*e,d\")\n-                         (match_operand:SI 1 \"const_uimm5\" \"\")]\n-                        BITTST)\n-                       (const_int 0)))]\n-  \"\"\n-  \"@\n-   bittst!  %0, %c1\n-   bittst.c %0, %c1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"up_c\" \"yes\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"extzv\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (zero_extract (match_operand:SI 1 \"memory_operand\" \"\")\n-                      (match_operand:SI 2 \"immediate_operand\" \"\")\n-                      (match_operand:SI 3 \"immediate_operand\" \"\")))]\n-  \"!TARGET_SCORE5U && !TARGET_LITTLE_ENDIAN && TARGET_ULS\"\n-{\n-  if (mdx_unaligned_load (operands))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n-(define_expand \"insv\"\n-  [(set (zero_extract (match_operand:SI 0 \"memory_operand\" \"\")\n-                      (match_operand:SI 1 \"immediate_operand\" \"\")\n-                      (match_operand:SI 2 \"immediate_operand\" \"\"))\n-        (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"!TARGET_SCORE5U && !TARGET_LITTLE_ENDIAN && TARGET_ULS\"\n-{\n-  if (mdx_unaligned_store (operands))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n-(define_expand \"extv\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (sign_extract (match_operand:SI 1 \"memory_operand\" \"\")\n-                      (match_operand:SI 2 \"immediate_operand\" \"\")\n-                      (match_operand:SI 3 \"immediate_operand\" \"\")))]\n-  \"!TARGET_SCORE5U && !TARGET_LITTLE_ENDIAN && TARGET_ULS\"\n-{\n-  if (mdx_unaligned_load (operands))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n-(define_expand \"movmemsi\"\n-  [(parallel [(set (match_operand:BLK 0 \"general_operand\")\n-                   (match_operand:BLK 1 \"general_operand\"))\n-              (use (match_operand:SI 2 \"\"))\n-              (use (match_operand:SI 3 \"const_int_operand\"))])]\n-  \"!TARGET_SCORE5U && TARGET_ULS\"\n-{\n-  if (mdx_block_move (operands))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n-(define_insn \"move_lbu_a\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-                 (match_operand:SI 2 \"const_simm12\" \"\")))\n-   (set (match_operand:QI 3 \"register_operand\" \"=d\")\n-        (mem:QI (match_dup 1)))]\n-  \"\"\n-  \"lbu     %3, [%1]+, %2\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"move_lhu_a\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-                 (match_operand:SI 2 \"const_simm12\" \"\")))\n-   (set (match_operand:HI 3 \"register_operand\" \"=d\")\n-        (mem:HI (match_dup 1)))]\n-  \"\"\n-  \"lhu     %3, [%1]+, %2\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"move_lw_a\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-                 (match_operand:SI 2 \"const_simm12\" \"\")))\n-   (set (match_operand:SI 3 \"register_operand\" \"=d\")\n-        (mem:SI (match_dup 1)))]\n-  \"\"\n-  \"lw      %3, [%1]+, %2\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"move_sb_a\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-                 (match_operand:SI 2 \"const_simm12\" \"\")))\n-   (set (mem:QI (match_dup 1))\n-        (match_operand:QI 3 \"register_operand\" \"d\"))]\n-  \"\"\n-  \"sb      %3, [%1]+, %2\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"move_sh_a\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-                 (match_operand:SI 2 \"const_simm12\" \"\")))\n-   (set (mem:HI (match_dup 1))\n-        (match_operand:HI 3 \"register_operand\" \"d\"))]\n-  \"\"\n-  \"sh      %3, [%1]+, %2\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"move_sw_a\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-                 (match_operand:SI 2 \"const_simm12\" \"\")))\n-   (set (mem:SI (match_dup 1))\n-        (match_operand:SI 3 \"register_operand\" \"d\"))]\n-  \"\"\n-  \"sw      %3, [%1]+, %2\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"move_lbu_b\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-                 (match_operand:SI 2 \"const_simm12\" \"\")))\n-   (set (match_operand:QI 3 \"register_operand\" \"=d\")\n-        (mem:QI (plus:SI (match_dup 1)\n-                         (match_dup 2))))]\n-  \"\"\n-  \"lbu     %3, [%1, %2]+\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"move_lhu_b\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-                 (match_operand:SI 2 \"const_simm12\" \"\")))\n-   (set (match_operand:HI 3 \"register_operand\" \"=d\")\n-        (mem:HI (plus:SI (match_dup 1)\n-                         (match_dup 2))))]\n-  \"\"\n-  \"lhu     %3, [%1, %2]+\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"move_lw_b\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-                 (match_operand:SI 2 \"const_simm12\" \"\")))\n-   (set (match_operand:SI 3 \"register_operand\" \"=d\")\n-        (mem:SI (plus:SI (match_dup 1)\n-                         (match_dup 2))))]\n-  \"\"\n-  \"lw      %3, [%1, %2]+\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"move_sb_b\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-                 (match_operand:SI 2 \"const_simm12\" \"\")))\n-   (set (mem:QI (plus:SI (match_dup 1)\n-                         (match_dup 2)))\n-        (match_operand:QI 3 \"register_operand\" \"d\"))]\n-  \"\"\n-  \"sb      %3, [%1, %2]+\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"move_sh_b\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-                 (match_operand:SI 2 \"const_simm12\" \"\")))\n-   (set (mem:HI (plus:SI (match_dup 1)\n-                         (match_dup 2)))\n-        (match_operand:HI 3 \"register_operand\" \"d\"))]\n-  \"\"\n-  \"sh      %3, [%1, %2]+\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"move_sw_b\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-                 (match_operand:SI 2 \"const_simm12\" \"\")))\n-   (set (mem:SI (plus:SI (match_dup 1)\n-                         (match_dup 2)))\n-        (match_operand:SI 3 \"register_operand\" \"d\"))]\n-  \"\"\n-  \"sw      %3, [%1, %2]+\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"move_lcb\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-                 (const_int 4)))\n-   (set (reg:SI LC_REGNUM)\n-        (unspec:SI [(mem:BLK (match_dup 1))] LCB))]\n-  \"!TARGET_SCORE5U && !TARGET_LITTLE_ENDIAN && TARGET_ULS\"\n-  \"lcb     [%1]+\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"move_lcw\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-                 (const_int 4)))\n-   (set (match_operand:SI 2 \"register_operand\" \"=d\")\n-        (unspec:SI [(mem:BLK (match_dup 1))\n-                    (reg:SI LC_REGNUM)] LCW))\n-   (set (reg:SI LC_REGNUM)\n-        (unspec:SI [(mem:BLK (match_dup 1))] LCB))]\n-  \"!TARGET_SCORE5U && !TARGET_LITTLE_ENDIAN && TARGET_ULS\"\n-  \"lcw     %2, [%1]+\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"move_lce\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-                 (const_int 4)))\n-   (set (match_operand:SI 2 \"register_operand\" \"=d\")\n-        (unspec:SI [(mem:BLK (match_dup 1))\n-                    (reg:SI LC_REGNUM)] LCE))]\n-  \"!TARGET_SCORE5U && !TARGET_LITTLE_ENDIAN && TARGET_ULS\"\n-  \"lce     %2, [%1]+\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"move_scb\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-                 (const_int 4)))\n-   (set (mem:BLK (match_dup 1))\n-        (unspec:BLK [(match_operand:SI 2 \"register_operand\" \"d\")] SCB))\n-   (set (reg:SI SC_REGNUM)\n-        (unspec:SI [(match_dup 2)] SCLC))]\n-  \"!TARGET_SCORE5U && !TARGET_LITTLE_ENDIAN && TARGET_ULS\"\n-  \"scb     %2, [%1]+\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"move_scw\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-                 (const_int 4)))\n-   (set (mem:BLK (match_dup 1))\n-        (unspec:BLK [(match_operand:SI 2 \"register_operand\" \"d\")\n-                     (reg:SI SC_REGNUM)] SCW))\n-   (set (reg:SI SC_REGNUM)\n-        (unspec:SI [(match_dup 2)] SCLC))]\n-  \"!TARGET_SCORE5U && !TARGET_LITTLE_ENDIAN && TARGET_ULS\"\n-  \"scw     %2, [%1]+\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"move_sce\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-                 (const_int 4)))\n-   (set (mem:BLK (match_dup 1))\n-        (unspec:BLK [(reg:SI SC_REGNUM)] SCE))]\n-  \"!TARGET_SCORE5U && !TARGET_LITTLE_ENDIAN && TARGET_ULS\"\n-  \"sce     [%1]+\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"andsi3_extzh\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (and:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                (const_int 65535)))]\n-  \"\"\n-  \"extzh   %0, %1\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"mode\" \"SI\")])\n-"}, {"sha": "2015b3b79d9c2705e61803496ba4004462b0b333", "filename": "gcc/config/score/mul-div.S", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fmul-div.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fmul-div.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fmul-div.S?ref=254f522229578af1af093b2e4b6f1a0cc400d216", "patch": "@@ -14,8 +14,8 @@\n    License for more details.\n \n    You should have received a copy of the GNU General Public License\n-\talong with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n \n #define ra r3\n #define a0 r4\n@@ -34,6 +34,10 @@\n #if !defined(L_mulsi3) && !defined(L_divsi3)\n        .text\n        .global _flush_cache\n+#ifdef __score3__\n+_flush_cache:\n+        br      r3\n+#else\n _flush_cache:\n         srli    r9, r5, 4\n         mv      r8, r4\n@@ -70,6 +74,7 @@ _flush_cache:\n         bcnz    2b\n         br      r3\n #endif\n+#endif\n \n /* FUNCTION\n    (U) INT32 v0 = __mulsi3 ((U) INT32 a0, (U) INT32 a1);\n@@ -205,6 +210,10 @@ __modsi3:\n         .set pic\n         .text\n         .global _flush_cache\n+#ifdef __score3__\n+_flush_cache:\n+        br      r3\n+#else\n _flush_cache:\n         addi    r0, -8                  # pic used\n         .cpload r29                     # pic used\n@@ -245,6 +254,7 @@ _flush_cache:\n         addi    r0, 8                   # pic used\n         br      r3\n #endif\n+#endif\n \n /* FUNCTION\n    (U) INT32 v0 = __mulsi3 ((U) INT32 a0, (U) INT32 a1);\n@@ -345,7 +355,6 @@ __umodsi3:\n         .cpload r29                     # pic used\n         li      t1, 0\n         mv      t3, ra\n-#       jl      __udivsi3\n         la      r29, __udivsi3\n         brl     r29\n         mv      r4, a1\n@@ -374,7 +383,6 @@ __divsi3:\n         .cpload r29                     # pic used\n         mv      t3, ra\n         xor     t2, a0, a1\n-#       jl      __orgsi3\n         la      r29, __orgsi3\n         brl     r29\n __divsi3_adjust:\n@@ -394,7 +402,6 @@ __modsi3:\n         .cpload r29                     # pic used\n         mv      t3, ra\n         mv      t2, a0\n-#       jl      __orgsi3\n         la      r29, __orgsi3\n         brl     r29\n         mv      r4, a1"}, {"sha": "bd80df59bf8a9f25e78896968da6ee7b2e63d616", "filename": "gcc/config/score/predicates.md", "status": "modified", "additions": 93, "deletions": 13, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fpredicates.md?ref=254f522229578af1af093b2e4b6f1a0cc400d216", "patch": "@@ -17,29 +17,51 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n+(define_predicate \"const_uimm5\"\n+  (match_code \"const_int\")\n+{\n+  return IMM_IN_RANGE (INTVAL (op), 5, 0);\n+})\n+\n+(define_predicate \"const_simm12\"\n+  (match_code \"const_int\")\n+{\n+  return IMM_IN_RANGE (INTVAL (op), 12, 1);\n+})\n+\n+(define_predicate \"const_simm15\"\n+  (match_code \"const_int\")\n+{\n+  return IMM_IN_RANGE (INTVAL (op), 15, 1);\n+})\n+\n (define_predicate \"arith_operand\"\n   (ior (match_code \"const_int\")\n        (match_operand 0 \"register_operand\")))\n \n+(define_predicate \"score_register_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  return (GET_CODE (op) == REG)\n+          && (REGNO (op) != CC_REGNUM);\n+})\n+\n (define_predicate \"const_call_insn_operand\"\n   (match_code \"const,symbol_ref,label_ref\")\n {\n   enum score_symbol_type symbol_type;\n \n-  return (mda_symbolic_constant_p (op, &symbol_type)\n+  return (score_symbolic_constant_p (op, &symbol_type)\n           && (symbol_type == SYMBOL_GENERAL));\n })\n \n (define_predicate \"call_insn_operand\"\n   (ior (match_operand 0 \"const_call_insn_operand\")\n        (match_operand 0 \"register_operand\")))\n \n-(define_predicate \"const_uimm5\"\n-  (match_code \"const_int\")\n-{\n-  return IMM_IN_RANGE (INTVAL (op), 5, 0);\n-})\n-\n (define_predicate \"hireg_operand\"\n   (and (match_code \"reg\")\n        (match_test \"REGNO (op) == HI_REGNUM\")))\n@@ -62,15 +84,73 @@\n (define_predicate \"branch_nz_operator\"\n   (match_code \"eq,ne,lt,ge\"))\n \n-(define_predicate \"const_simm12\"\n-  (match_code \"const_int\")\n+(define_predicate \"score_load_multiple_operation\"\n+  (match_code \"parallel\")\n {\n-  return IMM_IN_RANGE (INTVAL (op), 12, 1);\n+  int count = XVECLEN (op, 0);\n+  int dest_regno;\n+  rtx src_addr;\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != MEM)\n+    return 0;\n+\n+  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n+  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0);\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (elt) != SET\n+          || GET_CODE (SET_DEST (elt)) != REG\n+          || GET_MODE (SET_DEST (elt)) != SImode\n+          || REGNO (SET_DEST (elt)) != (unsigned) (dest_regno + i)\n+          || GET_CODE (SET_SRC (elt)) != MEM\n+          || GET_MODE (SET_SRC (elt)) != SImode\n+          || GET_CODE (XEXP (SET_SRC (elt), 0)) != POST_INC)\n+        return 0;\n+    }\n+\n+  return 1;\n })\n \n-(define_predicate \"const_simm15\"\n-  (match_code \"const_int\")\n+(define_predicate \"score_store_multiple_operation\"\n+  (match_code \"parallel\")\n {\n-  return IMM_IN_RANGE (INTVAL (op), 15, 1);\n+  int count = XVECLEN (op, 0);\n+  int src_regno;\n+  rtx dest_addr;\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != MEM\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != REG)\n+    return 0;\n+\n+  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n+  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, 0)), 0);\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (elt) != SET\n+          || GET_CODE (SET_SRC (elt)) != REG\n+          || GET_MODE (SET_SRC (elt)) != SImode\n+          || REGNO (SET_SRC (elt)) != (unsigned) (src_regno + i)\n+          || GET_CODE (SET_DEST (elt)) != MEM\n+          || GET_MODE (SET_DEST (elt)) != SImode\n+          || GET_CODE (XEXP (SET_DEST (elt), 0)) != PRE_DEC)\n+        return 0;\n+    }\n+\n+  return 1;\n })\n "}, {"sha": "67855da895e1d1f70809ba87cdc730601e4a30b5", "filename": "gcc/config/score/score-conv.h", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore-conv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore-conv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-conv.h?ref=254f522229578af1af093b2e4b6f1a0cc400d216", "patch": "@@ -17,11 +17,16 @@\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n \n-#ifndef SCORE_CONV_0601\n-#define SCORE_CONV_0601\n+#ifndef GCC_SCORE_CONV_H\n+#define GCC_SCORE_CONV_H\n \n extern int target_flags;\n \n+/* Define the information needed to generate branch insns.  This is\n+   stored from the compare operation.  */\n+extern GTY(()) rtx cmp_op0;\n+extern GTY(()) rtx cmp_op1;\n+\n #define GP_REG_FIRST                    0U\n #define GP_REG_LAST                     31U\n #define GP_REG_NUM                      (GP_REG_LAST - GP_REG_FIRST + 1U)\n@@ -40,47 +45,38 @@ extern int target_flags;\n \n #define GP_REG_P(REGNO)        REG_CONTAIN (REGNO, GP_REG_FIRST, GP_REG_NUM)\n \n+#define G8_REG_P(REGNO)        REG_CONTAIN (REGNO, GP_REG_FIRST, 8)\n+\n #define G16_REG_P(REGNO)       REG_CONTAIN (REGNO, GP_REG_FIRST, 16)\n \n #define CE_REG_P(REGNO)        REG_CONTAIN (REGNO, CE_REG_FIRST, CE_REG_NUM)\n \n-#define UIMM_IN_RANGE(V, W)  ((V) >= 0 && (V) < ((HOST_WIDE_INT) 1 << (W)))\n+#define GR_REG_CLASS_P(C)        ((C) == G16_REGS || (C) == G32_REGS)\n+#define SP_REG_CLASS_P(C) \\\n+  ((C) == CN_REG || (C) == LC_REG || (C) == SC_REG || (C) == SP_REGS)\n+#define CP_REG_CLASS_P(C) \\\n+  ((C) == CP1_REGS || (C) == CP2_REGS || (C) == CP3_REGS || (C) == CPA_REGS)\n+#define CE_REG_CLASS_P(C) \\\n+  ((C) == HI_REG || (C) == LO_REG || (C) == CE_REGS)\n+\n+#define UIMM_IN_RANGE(V, W)    ((V) >= 0 && (V) < ((HOST_WIDE_INT) 1 << (W)))\n \n #define SIMM_IN_RANGE(V, W)                            \\\n   ((V) >= (-1 * ((HOST_WIDE_INT) 1 << ((W) - 1)))      \\\n    && (V) < (1 * ((HOST_WIDE_INT) 1 << ((W) - 1))))\n \n-#define IMM_IN_RANGE(V, W, S) \\\n+#define IMM_IN_RANGE(V, W, S)  \\\n   ((S) ? SIMM_IN_RANGE (V, W) : UIMM_IN_RANGE (V, W))\n \n-#define IMM_IS_POW_OF_2(V, E1, E2)                \\\n+#define IMM_IS_POW_OF_2(V, E1, E2)                 \\\n   ((V) >= ((unsigned HOST_WIDE_INT) 1 << (E1))     \\\n    && (V) <= ((unsigned HOST_WIDE_INT) 1 << (E2))  \\\n    && ((V) & ((V) - 1)) == 0)\n \n-#define SCORE_STACK_ALIGN(LOC)          (((LOC) + 3) & ~3)\n-\n-#define SCORE_MAX_FIRST_STACK_STEP      (0x3ff0)\n-\n-#define SCORE_SDATA_MAX                 score_sdata_max ()\n-\n-#define DEFAULT_SDATA_MAX               8\n-\n-#define CONST_HIGH_PART(VALUE) \\\n-  (((VALUE) + 0x8000) & ~(unsigned HOST_WIDE_INT) 0xffff)\n-\n-#define CONST_LOW_PART(VALUE)           ((VALUE) - CONST_HIGH_PART (VALUE))\n-\n-#define PROLOGUE_TEMP_REGNUM            (GP_REG_FIRST + 8)\n-\n-#define EPILOGUE_TEMP_REGNUM            (GP_REG_FIRST + 8)\n-\n enum score_symbol_type\n {\n   SYMBOL_GENERAL,\n-  SYMBOL_SMALL_DATA     /* The symbol refers to something in a small data section.  */\n+  SYMBOL_SMALL_DATA  /* The symbol refers to something in a small data section  */\n };\n \n-int score_sdata_max (void);\n-\n #endif"}, {"sha": "f3341c5a3764e70e2d7b1dd97cb4fda222826407", "filename": "gcc/config/score/score-generic.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore-generic.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore-generic.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-generic.md?ref=254f522229578af1af093b2e4b6f1a0cc400d216", "patch": "@@ -1,5 +1,5 @@\n ;;  Machine description for Sunplus S+CORE\n-;;  Sunplus S+CORE 7 Pipeline Description\n+;;  Sunplus S+CORE Pipeline Description\n ;;  Copyright (C) 2005, 2007\n ;;  Free Software Foundation, Inc.\n ;;  Contributed by Sunnorth.", "previous_filename": "gcc/config/score/score7.md"}, {"sha": "7eb51530a6b83bb38528962bf84a49b57f2debe1", "filename": "gcc/config/score/score-mdaux.c", "status": "removed", "additions": 0, "deletions": 1058, "changes": 1058, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23710ddde48ab95c906e89280383aa0c99eea2f1/gcc%2Fconfig%2Fscore%2Fscore-mdaux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23710ddde48ab95c906e89280383aa0c99eea2f1/gcc%2Fconfig%2Fscore%2Fscore-mdaux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-mdaux.c?ref=23710ddde48ab95c906e89280383aa0c99eea2f1", "patch": "@@ -1,1058 +0,0 @@\n-/* score-mdaux.c for Sunplus S+CORE processor\n-   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n-   Contributed by Sunnorth\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include <signal.h>\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"insn-attr.h\"\n-#include \"recog.h\"\n-#include \"toplev.h\"\n-#include \"output.h\"\n-#include \"tree.h\"\n-#include \"function.h\"\n-#include \"expr.h\"\n-#include \"optabs.h\"\n-#include \"flags.h\"\n-#include \"reload.h\"\n-#include \"tm_p.h\"\n-#include \"ggc.h\"\n-#include \"gstab.h\"\n-#include \"hashtab.h\"\n-#include \"debug.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-#include \"integrate.h\"\n-#include \"langhooks.h\"\n-#include \"cfglayout.h\"\n-#include \"score-mdaux.h\"\n-\n-#define BITSET_P(VALUE, BIT)      (((VALUE) & (1L << (BIT))) != 0)\n-#define INS_BUF_SZ                100\n-\n-/* Define the information needed to generate branch insns.  This is\n-   stored from the compare operation.  */\n-rtx cmp_op0, cmp_op1;\n-\n-static char ins[INS_BUF_SZ + 8];\n-\n-/* Return true if SYMBOL is a SYMBOL_REF and OFFSET + SYMBOL points\n-   to the same object as SYMBOL.  */\n-static int\n-score_offset_within_object_p (rtx symbol, HOST_WIDE_INT offset)\n-{\n-  if (GET_CODE (symbol) != SYMBOL_REF)\n-    return 0;\n-\n-  if (CONSTANT_POOL_ADDRESS_P (symbol)\n-      && offset >= 0\n-      && offset < (int)GET_MODE_SIZE (get_pool_mode (symbol)))\n-    return 1;\n-\n-  if (SYMBOL_REF_DECL (symbol) != 0\n-      && offset >= 0\n-      && offset < int_size_in_bytes (TREE_TYPE (SYMBOL_REF_DECL (symbol))))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Split X into a base and a constant offset, storing them in *BASE\n-   and *OFFSET respectively.  */\n-static void\n-score_split_const (rtx x, rtx *base, HOST_WIDE_INT *offset)\n-{\n-  *offset = 0;\n-\n-  if (GET_CODE (x) == CONST)\n-    x = XEXP (x, 0);\n-\n-  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-    {\n-      *offset += INTVAL (XEXP (x, 1));\n-      x = XEXP (x, 0);\n-    }\n-\n-  *base = x;\n-}\n-\n-/* Classify symbol X, which must be a SYMBOL_REF or a LABEL_REF.  */\n-static enum\n-score_symbol_type score_classify_symbol (rtx x)\n-{\n-  if (GET_CODE (x) == LABEL_REF)\n-    return SYMBOL_GENERAL;\n-\n-  gcc_assert (GET_CODE (x) == SYMBOL_REF);\n-\n-  if (CONSTANT_POOL_ADDRESS_P (x))\n-    {\n-      if (GET_MODE_SIZE (get_pool_mode (x)) <= SCORE_SDATA_MAX)\n-        return SYMBOL_SMALL_DATA;\n-      return SYMBOL_GENERAL;\n-    }\n-  if (SYMBOL_REF_SMALL_P (x))\n-    return SYMBOL_SMALL_DATA;\n-  return SYMBOL_GENERAL;\n-}\n-\n-/* Return true if the current function must save REGNO.  */\n-static int\n-score_save_reg_p (unsigned int regno)\n-{\n-  /* Check call-saved registers.  */\n-  if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n-    return 1;\n-\n-  /* We need to save the old frame pointer before setting up a new one.  */\n-  if (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\n-    return 1;\n-\n-  /* We need to save the incoming return address if it is ever clobbered\n-     within the function.  */\n-  if (regno == RA_REGNUM && df_regs_ever_live_p (regno))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Return one word of double-word value OP, taking into account the fixed\n-   endianness of certain registers.  HIGH_P is true to select the high part,\n-   false to select the low part.  */\n-static rtx\n-subw (rtx op, int high_p)\n-{\n-  unsigned int byte;\n-  enum machine_mode mode = GET_MODE (op);\n-\n-  if (mode == VOIDmode)\n-    mode = DImode;\n-\n-  byte = (TARGET_LITTLE_ENDIAN ? high_p : !high_p) ? UNITS_PER_WORD : 0;\n-\n-  if (GET_CODE (op) == REG && REGNO (op) == HI_REGNUM)\n-    return gen_rtx_REG (SImode, high_p ? HI_REGNUM : LO_REGNUM);\n-\n-  if (GET_CODE (op) == MEM)\n-    return adjust_address (op, SImode, byte);\n-\n-  return simplify_gen_subreg (SImode, op, mode, byte);\n-}\n-\n-struct score_frame_info *\n-mda_cached_frame (void)\n-{\n-  static struct score_frame_info _frame_info;\n-  return &_frame_info;\n-}\n-\n-/* Return the bytes needed to compute the frame pointer from the current\n-   stack pointer.  SIZE is the size (in bytes) of the local variables.  */\n-struct score_frame_info *\n-mda_compute_frame_size (HOST_WIDE_INT size)\n-{\n-  unsigned int regno;\n-  struct score_frame_info *f = mda_cached_frame ();\n-\n-  memset (f, 0, sizeof (struct score_frame_info));\n-  f->gp_reg_size = 0;\n-  f->mask = 0;\n-  f->var_size = SCORE_STACK_ALIGN (size);\n-  f->args_size = current_function_outgoing_args_size;\n-  f->cprestore_size = flag_pic ? UNITS_PER_WORD : 0;\n-  if (f->var_size == 0 && current_function_is_leaf)\n-    f->args_size = f->cprestore_size = 0;\n-\n-  if (f->args_size == 0 && current_function_calls_alloca)\n-    f->args_size = UNITS_PER_WORD;\n-\n-  f->total_size = f->var_size + f->args_size + f->cprestore_size;\n-  for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n-    {\n-      if (score_save_reg_p (regno))\n-        {\n-          f->gp_reg_size += GET_MODE_SIZE (SImode);\n-          f->mask |= 1 << (regno - GP_REG_FIRST);\n-        }\n-    }\n-\n-  if (current_function_calls_eh_return)\n-    {\n-      unsigned int i;\n-      for (i = 0;; ++i)\n-        {\n-          regno = EH_RETURN_DATA_REGNO (i);\n-          if (regno == INVALID_REGNUM)\n-            break;\n-          f->gp_reg_size += GET_MODE_SIZE (SImode);\n-          f->mask |= 1 << (regno - GP_REG_FIRST);\n-        }\n-    }\n-\n-  f->total_size += f->gp_reg_size;\n-  f->num_gp = f->gp_reg_size / UNITS_PER_WORD;\n-\n-  if (f->mask)\n-    {\n-      HOST_WIDE_INT offset;\n-      offset = (f->args_size + f->cprestore_size + f->var_size\n-                + f->gp_reg_size - GET_MODE_SIZE (SImode));\n-      f->gp_sp_offset = offset;\n-    }\n-  else\n-    f->gp_sp_offset = 0;\n-\n-  return f;\n-}\n-\n-/* Generate the prologue instructions for entry into a S+core function.  */\n-void\n-mdx_prologue (void)\n-{\n-#define EMIT_PL(_rtx)        RTX_FRAME_RELATED_P (_rtx) = 1\n-\n-  struct score_frame_info *f = mda_compute_frame_size (get_frame_size ());\n-  HOST_WIDE_INT size;\n-  int regno;\n-\n-  size = f->total_size - f->gp_reg_size;\n-\n-  if (flag_pic)\n-    emit_insn (gen_cpload ());\n-\n-  for (regno = (int) GP_REG_LAST; regno >= (int) GP_REG_FIRST; regno--)\n-    {\n-      if (BITSET_P (f->mask, regno - GP_REG_FIRST))\n-        {\n-          rtx mem = gen_rtx_MEM (SImode,\n-                                 gen_rtx_PRE_DEC (SImode, stack_pointer_rtx));\n-          rtx reg = gen_rtx_REG (SImode, regno);\n-          if (!current_function_calls_eh_return)\n-            MEM_READONLY_P (mem) = 1;\n-          EMIT_PL (emit_insn (gen_pushsi (mem, reg)));\n-        }\n-    }\n-\n-  if (size > 0)\n-    {\n-      rtx insn;\n-\n-      if (CONST_OK_FOR_LETTER_P (-size, 'L'))\n-        EMIT_PL (emit_insn (gen_add3_insn (stack_pointer_rtx,\n-                                           stack_pointer_rtx,\n-                                           GEN_INT (-size))));\n-      else\n-        {\n-          EMIT_PL (emit_move_insn (gen_rtx_REG (Pmode, PROLOGUE_TEMP_REGNUM),\n-                                   GEN_INT (size)));\n-          EMIT_PL (emit_insn\n-                   (gen_sub3_insn (stack_pointer_rtx,\n-                                   stack_pointer_rtx,\n-                                   gen_rtx_REG (Pmode,\n-                                                PROLOGUE_TEMP_REGNUM))));\n-        }\n-      insn = get_last_insn ();\n-      REG_NOTES (insn) =\n-        alloc_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-                         gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-                                      plus_constant (stack_pointer_rtx,\n-                                                     -size)),\n-                                      REG_NOTES (insn));\n-    }\n-\n-  if (frame_pointer_needed)\n-    EMIT_PL (emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx));\n-\n-  if (flag_pic && f->cprestore_size)\n-    {\n-      if (frame_pointer_needed)\n-        emit_insn (gen_cprestore_use_fp (GEN_INT (size - f->cprestore_size)));\n-      else\n-        emit_insn (gen_cprestore_use_sp (GEN_INT (size - f->cprestore_size)));\n-    }\n-\n-#undef EMIT_PL\n-}\n-\n-/* Generate the epilogue instructions in a S+core function.  */\n-void\n-mdx_epilogue (int sibcall_p)\n-{\n-  struct score_frame_info *f = mda_compute_frame_size (get_frame_size ());\n-  HOST_WIDE_INT size;\n-  int regno;\n-  rtx base;\n-\n-  size = f->total_size - f->gp_reg_size;\n-\n-  if (!frame_pointer_needed)\n-    base = stack_pointer_rtx;\n-  else\n-    base = hard_frame_pointer_rtx;\n-\n-  if (size)\n-    {\n-      if (CONST_OK_FOR_LETTER_P (size, 'L'))\n-        emit_insn (gen_add3_insn (base, base, GEN_INT (size)));\n-      else\n-        {\n-          emit_move_insn (gen_rtx_REG (Pmode, EPILOGUE_TEMP_REGNUM),\n-                          GEN_INT (size));\n-          emit_insn (gen_add3_insn (base, base,\n-                                    gen_rtx_REG (Pmode,\n-                                                 EPILOGUE_TEMP_REGNUM)));\n-        }\n-    }\n-\n-  if (base != stack_pointer_rtx)\n-    emit_move_insn (stack_pointer_rtx, base);\n-\n-  if (current_function_calls_eh_return)\n-    emit_insn (gen_add3_insn (stack_pointer_rtx,\n-                              stack_pointer_rtx,\n-                              EH_RETURN_STACKADJ_RTX));\n-\n-  for (regno = (int) GP_REG_FIRST; regno <= (int) GP_REG_LAST; regno++)\n-    {\n-      if (BITSET_P (f->mask, regno - GP_REG_FIRST))\n-        {\n-          rtx mem = gen_rtx_MEM (SImode,\n-                                 gen_rtx_POST_INC (SImode, stack_pointer_rtx));\n-          rtx reg = gen_rtx_REG (SImode, regno);\n-\n-          if (!current_function_calls_eh_return)\n-            MEM_READONLY_P (mem) = 1;\n-\n-          emit_insn (gen_popsi (reg, mem));\n-        }\n-    }\n-\n-  if (!sibcall_p)\n-    emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, RA_REGNUM)));\n-}\n-\n-/* Return true if X is a valid base register for the given mode.\n-   Allow only hard registers if STRICT.  */\n-int\n-mda_valid_base_register_p (rtx x, int strict)\n-{\n-  if (!strict && GET_CODE (x) == SUBREG)\n-    x = SUBREG_REG (x);\n-\n-  return (GET_CODE (x) == REG\n-          && score_regno_mode_ok_for_base_p (REGNO (x), strict));\n-}\n-\n-/* Return true if X is a valid address for machine mode MODE.  If it is,\n-   fill in INFO appropriately.  STRICT is true if we should only accept\n-   hard base registers.  */\n-int\n-mda_classify_address (struct score_address_info *info,\n-                      enum machine_mode mode, rtx x, int strict)\n-{\n-  info->code = GET_CODE (x);\n-\n-  switch (info->code)\n-    {\n-    case REG:\n-    case SUBREG:\n-      info->type = ADD_REG;\n-      info->reg = x;\n-      info->offset = const0_rtx;\n-      return mda_valid_base_register_p (info->reg, strict);\n-    case PLUS:\n-      info->type = ADD_REG;\n-      info->reg = XEXP (x, 0);\n-      info->offset = XEXP (x, 1);\n-      return (mda_valid_base_register_p (info->reg, strict)\n-              && GET_CODE (info->offset) == CONST_INT\n-              && IMM_IN_RANGE (INTVAL (info->offset), 15, 1));\n-    case PRE_DEC:\n-    case POST_DEC:\n-    case PRE_INC:\n-    case POST_INC:\n-      if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (SImode))\n-        return false;\n-      info->type = ADD_REG;\n-      info->reg = XEXP (x, 0);\n-      info->offset = GEN_INT (GET_MODE_SIZE (mode));\n-      return mda_valid_base_register_p (info->reg, strict);\n-    case CONST_INT:\n-      info->type = ADD_CONST_INT;\n-      return IMM_IN_RANGE (INTVAL (x), 15, 1);\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      info->type = ADD_SYMBOLIC;\n-      return (mda_symbolic_constant_p (x, &info->symbol_type)\n-              && (info->symbol_type == SYMBOL_GENERAL\n-                  || info->symbol_type == SYMBOL_SMALL_DATA));\n-    default:\n-      return 0;\n-    }\n-}\n-\n-void\n-mda_gen_cmp (enum machine_mode mode)\n-{\n-  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, CC_REGNUM),\n-                          gen_rtx_COMPARE (mode, cmp_op0, cmp_op1)));\n-}\n-\n-/* Return true if X is a symbolic constant that can be calculated in\n-   the same way as a bare symbol.  If it is, store the type of the\n-   symbol in *SYMBOL_TYPE.  */\n-int\n-mda_symbolic_constant_p (rtx x, enum score_symbol_type *symbol_type)\n-{\n-  HOST_WIDE_INT offset;\n-\n-  score_split_const (x, &x, &offset);\n-  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n-    *symbol_type = score_classify_symbol (x);\n-  else\n-    return 0;\n-\n-  if (offset == 0)\n-    return 1;\n-\n-  /* if offset > 15bit, must reload  */\n-  if (!IMM_IN_RANGE (offset, 15, 1))\n-    return 0;\n-\n-  switch (*symbol_type)\n-    {\n-    case SYMBOL_GENERAL:\n-      return 1;\n-    case SYMBOL_SMALL_DATA:\n-      return score_offset_within_object_p (x, offset);\n-    }\n-  gcc_unreachable ();\n-}\n-\n-void\n-mdx_movsicc (rtx *ops)\n-{\n-  enum machine_mode mode;\n-\n-  mode = score_select_cc_mode (GET_CODE (ops[1]), ops[2], ops[3]);\n-  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, CC_REGNUM),\n-                          gen_rtx_COMPARE (mode, cmp_op0, cmp_op1)));\n-}\n-\n-/* Call and sibcall pattern all need call this function.  */\n-void\n-mdx_call (rtx *ops, bool sib)\n-{\n-  rtx addr = XEXP (ops[0], 0);\n-  if (!call_insn_operand (addr, VOIDmode))\n-    {\n-      rtx oaddr = addr;\n-      addr = gen_reg_rtx (Pmode);\n-      gen_move_insn (addr, oaddr);\n-    }\n-\n-  if (sib)\n-    emit_call_insn (gen_sibcall_internal (addr, ops[1]));\n-  else\n-    emit_call_insn (gen_call_internal (addr, ops[1]));\n-}\n-\n-/* Call value and sibcall value pattern all need call this function.  */\n-void\n-mdx_call_value (rtx *ops, bool sib)\n-{\n-  rtx result = ops[0];\n-  rtx addr = XEXP (ops[1], 0);\n-  rtx arg = ops[2];\n-\n-  if (!call_insn_operand (addr, VOIDmode))\n-    {\n-      rtx oaddr = addr;\n-      addr = gen_reg_rtx (Pmode);\n-      gen_move_insn (addr, oaddr);\n-    }\n-\n-  if (sib)\n-    emit_call_insn (gen_sibcall_value_internal (result, addr, arg));\n-  else\n-    emit_call_insn (gen_call_value_internal (result, addr, arg));\n-}\n-\n-/* Machine Split  */\n-void\n-mds_movdi (rtx *ops)\n-{\n-  rtx dst = ops[0];\n-  rtx src = ops[1];\n-  rtx dst0 = subw (dst, 0);\n-  rtx dst1 = subw (dst, 1);\n-  rtx src0 = subw (src, 0);\n-  rtx src1 = subw (src, 1);\n-\n-  if (GET_CODE (dst0) == REG && reg_overlap_mentioned_p (dst0, src))\n-    {\n-      emit_move_insn (dst1, src1);\n-      emit_move_insn (dst0, src0);\n-    }\n-  else\n-    {\n-      emit_move_insn (dst0, src0);\n-      emit_move_insn (dst1, src1);\n-    }\n-}\n-\n-void\n-mds_zero_extract_andi (rtx *ops)\n-{\n-  if (INTVAL (ops[1]) == 1 && const_uimm5 (ops[2], SImode))\n-    emit_insn (gen_zero_extract_bittst (ops[0], ops[2]));\n-  else\n-    {\n-      unsigned HOST_WIDE_INT mask;\n-      mask = (0xffffffffU & ((1U << INTVAL (ops[1])) - 1U));\n-      mask = mask << INTVAL (ops[2]);\n-      emit_insn (gen_andsi3_cmp (ops[3], ops[0],\n-                                 gen_int_mode (mask, SImode)));\n-    }\n-}\n-\n-/* Check addr could be present as PRE/POST mode.  */\n-static bool\n-mda_pindex_mem (rtx addr)\n-{\n-  if (GET_CODE (addr) == MEM)\n-    {\n-      switch (GET_CODE (XEXP (addr, 0)))\n-        {\n-        case PRE_DEC:\n-        case POST_DEC:\n-        case PRE_INC:\n-        case POST_INC:\n-          return true;\n-        default:\n-          break;\n-        }\n-    }\n-  return false;\n-}\n-\n-/* Output asm code for ld/sw insn.  */\n-static int\n-pr_addr_post (rtx *ops, int idata, int iaddr, char *ip, enum mda_mem_unit unit)\n-{\n-  struct score_address_info ai;\n-\n-  gcc_assert (GET_CODE (ops[idata]) == REG);\n-  gcc_assert (mda_classify_address (&ai, SImode, XEXP (ops[iaddr], 0), true));\n-\n-  if (!mda_pindex_mem (ops[iaddr])\n-      && ai.type == ADD_REG\n-      && GET_CODE (ai.offset) == CONST_INT\n-      && G16_REG_P (REGNO (ops[idata]))\n-      && G16_REG_P (REGNO (ai.reg)))\n-    {\n-      if (INTVAL (ai.offset) == 0)\n-        {\n-          ops[iaddr] = ai.reg;\n-          return snprintf (ip, INS_BUF_SZ,\n-                           \"!        %%%d, [%%%d]\", idata, iaddr);\n-        }\n-      if (REGNO (ai.reg) == HARD_FRAME_POINTER_REGNUM)\n-        {\n-          HOST_WIDE_INT offset = INTVAL (ai.offset);\n-          if (MDA_ALIGN_UNIT (offset, unit)\n-              && CONST_OK_FOR_LETTER_P (offset >> unit, 'J'))\n-            {\n-              ops[iaddr] = ai.offset;\n-              return snprintf (ip, INS_BUF_SZ,\n-                               \"p!        %%%d, %%c%d\", idata, iaddr);\n-            }\n-        }\n-    }\n-  return snprintf (ip, INS_BUF_SZ, \"        %%%d, %%a%d\", idata, iaddr);\n-}\n-\n-/* Output asm insn for load.  */\n-const char *\n-mdp_linsn (rtx *ops, enum mda_mem_unit unit, bool sign)\n-{\n-  const char *pre_ins[] =\n-    {\"lbu\", \"lhu\", \"lw\", \"??\", \"lb\", \"lh\", \"lw\", \"??\"};\n-  char *ip;\n-\n-  strcpy (ins, pre_ins[(sign ? 4 : 0) + unit]);\n-  ip = ins + strlen (ins);\n-\n-  if ((!sign && unit != MDA_HWORD)\n-      || (sign && unit != MDA_BYTE))\n-    pr_addr_post (ops, 0, 1, ip, unit);\n-  else\n-    snprintf (ip, INS_BUF_SZ, \"        %%0, %%a1\");\n-\n-  return ins;\n-}\n-\n-/* Output asm insn for store.  */\n-const char *\n-mdp_sinsn (rtx *ops, enum mda_mem_unit unit)\n-{\n-  const char *pre_ins[] = {\"sb\", \"sh\", \"sw\"};\n-  char *ip;\n-\n-  strcpy (ins, pre_ins[unit]);\n-  ip = ins + strlen (ins);\n-  pr_addr_post (ops, 1, 0, ip, unit);\n-  return ins;\n-}\n-\n-/* Output asm insn for load immediate.  */\n-const char *\n-mdp_limm (rtx *ops)\n-{\n-  HOST_WIDE_INT v;\n-\n-  gcc_assert (GET_CODE (ops[0]) == REG);\n-  gcc_assert (GET_CODE (ops[1]) == CONST_INT);\n-\n-  v = INTVAL (ops[1]);\n-  if (G16_REG_P (REGNO (ops[0])) && IMM_IN_RANGE (v, 8, 0))\n-    return \"ldiu!   %0, %c1\";\n-  else if (IMM_IN_RANGE (v, 16, 1))\n-    return \"ldi     %0, %c1\";\n-  else if ((v & 0xffff) == 0)\n-    return \"ldis    %0, %U1\";\n-  else\n-    return \"li      %0, %c1\";\n-}\n-\n-/* Output asm insn for move.  */\n-const char *\n-mdp_move (rtx *ops)\n-{\n-  gcc_assert (GET_CODE (ops[0]) == REG);\n-  gcc_assert (GET_CODE (ops[1]) == REG);\n-\n-  if (G16_REG_P (REGNO (ops[0])))\n-    {\n-      if (G16_REG_P (REGNO (ops[1])))\n-        return \"mv!     %0, %1\";\n-      else\n-        return \"mlfh!   %0, %1\";\n-    }\n-  else if (G16_REG_P (REGNO (ops[1])))\n-    return \"mhfl!   %0, %1\";\n-  else\n-    return \"mv      %0, %1\";\n-}\n-\n-/* Emit lcb/lce insns.  */\n-bool\n-mdx_unaligned_load (rtx *ops)\n-{\n-  rtx dst = ops[0];\n-  rtx src = ops[1];\n-  rtx len = ops[2];\n-  rtx off = ops[3];\n-  rtx addr_reg;\n-\n-  if (INTVAL (len) != BITS_PER_WORD\n-      || (INTVAL (off) % BITS_PER_UNIT) != 0)\n-    return false;\n-\n-  gcc_assert (GET_MODE_SIZE (GET_MODE (dst)) == GET_MODE_SIZE (SImode));\n-\n-  addr_reg = copy_addr_to_reg (XEXP (src, 0));\n-  emit_insn (gen_move_lcb (addr_reg, addr_reg));\n-  emit_insn (gen_move_lce (addr_reg, addr_reg, dst));\n-\n-  return true;\n-}\n-\n-/* Emit scb/sce insns.  */\n-bool\n-mdx_unaligned_store (rtx *ops)\n-{\n-  rtx dst = ops[0];\n-  rtx len = ops[1];\n-  rtx off = ops[2];\n-  rtx src = ops[3];\n-  rtx addr_reg;\n-\n-  if (INTVAL(len) != BITS_PER_WORD\n-      || (INTVAL(off) % BITS_PER_UNIT) != 0)\n-    return false;\n-\n-  gcc_assert (GET_MODE_SIZE (GET_MODE (src)) == GET_MODE_SIZE (SImode));\n-\n-  addr_reg = copy_addr_to_reg (XEXP (dst, 0));\n-  emit_insn (gen_move_scb (addr_reg, addr_reg, src));\n-  emit_insn (gen_move_sce (addr_reg, addr_reg));\n-\n-  return true;\n-}\n-\n-/* If length is short, generate move insns straight.  */\n-static void\n-mdx_block_move_straight (rtx dst, rtx src, HOST_WIDE_INT length)\n-{\n-  HOST_WIDE_INT leftover;\n-  int i, reg_count;\n-  rtx *regs;\n-\n-  leftover = length % UNITS_PER_WORD;\n-  length -= leftover;\n-  reg_count = length / UNITS_PER_WORD;\n-\n-  regs = alloca (sizeof (rtx) * reg_count);\n-  for (i = 0; i < reg_count; i++)\n-    regs[i] = gen_reg_rtx (SImode);\n-\n-  /* Load from src to regs.  */\n-  if (MEM_ALIGN (src) >= BITS_PER_WORD)\n-    {\n-      HOST_WIDE_INT offset = 0;\n-      for (i = 0; i < reg_count; offset += UNITS_PER_WORD, i++)\n-        emit_move_insn (regs[i], adjust_address (src, SImode, offset));\n-    }\n-  else if (reg_count >= 1)\n-    {\n-      rtx src_reg = copy_addr_to_reg (XEXP (src, 0));\n-\n-      emit_insn (gen_move_lcb (src_reg, src_reg));\n-      for (i = 0; i < (reg_count - 1); i++)\n-        emit_insn (gen_move_lcw (src_reg, src_reg, regs[i]));\n-      emit_insn (gen_move_lce (src_reg, src_reg, regs[i]));\n-    }\n-\n-  /* Store regs to dest.  */\n-  if (MEM_ALIGN (dst) >= BITS_PER_WORD)\n-    {\n-      HOST_WIDE_INT offset = 0;\n-      for (i = 0; i < reg_count; offset += UNITS_PER_WORD, i++)\n-        emit_move_insn (adjust_address (dst, SImode, offset), regs[i]);\n-    }\n-  else if (reg_count >= 1)\n-    {\n-      rtx dst_reg = copy_addr_to_reg (XEXP (dst, 0));\n-\n-      emit_insn (gen_move_scb (dst_reg, dst_reg, regs[0]));\n-      for (i = 1; i < reg_count; i++)\n-        emit_insn (gen_move_scw (dst_reg, dst_reg, regs[i]));\n-      emit_insn (gen_move_sce (dst_reg, dst_reg));\n-    }\n-\n-  /* Mop up any left-over bytes.  */\n-  if (leftover > 0)\n-    {\n-      src = adjust_address (src, BLKmode, length);\n-      dst = adjust_address (dst, BLKmode, length);\n-      move_by_pieces (dst, src, leftover,\n-                      MIN (MEM_ALIGN (src), MEM_ALIGN (dst)), 0);\n-    }\n-}\n-\n-/* Generate loop head when dst or src is unaligned.  */\n-static void\n-mdx_block_move_loop_head (rtx dst_reg, HOST_WIDE_INT dst_align,\n-                          rtx src_reg, HOST_WIDE_INT src_align,\n-                          HOST_WIDE_INT length)\n-{\n-  bool src_unaligned = (src_align < BITS_PER_WORD);\n-  bool dst_unaligned = (dst_align < BITS_PER_WORD);\n-\n-  rtx temp = gen_reg_rtx (SImode);\n-\n-  gcc_assert (length == UNITS_PER_WORD);\n-\n-  if (src_unaligned)\n-    {\n-      emit_insn (gen_move_lcb (src_reg, src_reg));\n-      emit_insn (gen_move_lcw (src_reg, src_reg, temp));\n-    }\n-  else\n-    emit_insn (gen_move_lw_a (src_reg,\n-                              src_reg, gen_int_mode (4, SImode), temp));\n-\n-  if (dst_unaligned)\n-    emit_insn (gen_move_scb (dst_reg, dst_reg, temp));\n-  else\n-    emit_insn (gen_move_sw_a (dst_reg,\n-                              dst_reg, gen_int_mode (4, SImode), temp));\n-}\n-\n-/* Generate loop body, copy length bytes per iteration.  */\n-static void\n-mdx_block_move_loop_body (rtx dst_reg, HOST_WIDE_INT dst_align,\n-                          rtx src_reg, HOST_WIDE_INT src_align,\n-                          HOST_WIDE_INT length)\n-{\n-  int reg_count = length / UNITS_PER_WORD;\n-  rtx *regs = alloca (sizeof (rtx) * reg_count);\n-  int i;\n-  bool src_unaligned = (src_align < BITS_PER_WORD);\n-  bool dst_unaligned = (dst_align < BITS_PER_WORD);\n-\n-  for (i = 0; i < reg_count; i++)\n-    regs[i] = gen_reg_rtx (SImode);\n-\n-  if (src_unaligned)\n-    {\n-      for (i = 0; i < reg_count; i++)\n-        emit_insn (gen_move_lcw (src_reg, src_reg, regs[i]));\n-    }\n-  else\n-    {\n-      for (i = 0; i < reg_count; i++)\n-        emit_insn (gen_move_lw_a (src_reg,\n-                                  src_reg, gen_int_mode (4, SImode), regs[i]));\n-    }\n-\n-  if (dst_unaligned)\n-    {\n-      for (i = 0; i < reg_count; i++)\n-        emit_insn (gen_move_scw (dst_reg, dst_reg, regs[i]));\n-    }\n-  else\n-    {\n-      for (i = 0; i < reg_count; i++)\n-        emit_insn (gen_move_sw_a (dst_reg,\n-                                  dst_reg, gen_int_mode (4, SImode), regs[i]));\n-    }\n-}\n-\n-/* Generate loop foot, copy the leftover bytes.  */\n-static void\n-mdx_block_move_loop_foot (rtx dst_reg, HOST_WIDE_INT dst_align,\n-                          rtx src_reg, HOST_WIDE_INT src_align,\n-                          HOST_WIDE_INT length)\n-{\n-  bool src_unaligned = (src_align < BITS_PER_WORD);\n-  bool dst_unaligned = (dst_align < BITS_PER_WORD);\n-\n-  HOST_WIDE_INT leftover;\n-\n-  leftover = length % UNITS_PER_WORD;\n-  length -= leftover;\n-\n-  if (length > 0)\n-    mdx_block_move_loop_body (dst_reg, dst_align,\n-                              src_reg, src_align, length);\n-\n-  if (dst_unaligned)\n-    emit_insn (gen_move_sce (dst_reg, dst_reg));\n-\n-  if (leftover > 0)\n-    {\n-      HOST_WIDE_INT src_adj = src_unaligned ? -4 : 0;\n-      HOST_WIDE_INT dst_adj = dst_unaligned ? -4 : 0;\n-      rtx temp;\n-\n-      gcc_assert (leftover < UNITS_PER_WORD);\n-\n-      if (leftover >= UNITS_PER_WORD / 2\n-          && src_align >= BITS_PER_WORD / 2\n-          && dst_align >= BITS_PER_WORD / 2)\n-        {\n-          temp = gen_reg_rtx (HImode);\n-          emit_insn (gen_move_lhu_b (src_reg, src_reg,\n-                                     gen_int_mode (src_adj, SImode), temp));\n-          emit_insn (gen_move_sh_b (dst_reg, dst_reg,\n-                                    gen_int_mode (dst_adj, SImode), temp));\n-          leftover -= UNITS_PER_WORD / 2;\n-          src_adj = UNITS_PER_WORD / 2;\n-          dst_adj = UNITS_PER_WORD / 2;\n-        }\n-\n-      while (leftover > 0)\n-        {\n-          temp = gen_reg_rtx (QImode);\n-          emit_insn (gen_move_lbu_b (src_reg, src_reg,\n-                                     gen_int_mode (src_adj, SImode), temp));\n-          emit_insn (gen_move_sb_b (dst_reg, dst_reg,\n-                                    gen_int_mode (dst_adj, SImode), temp));\n-          leftover--;\n-          src_adj = 1;\n-          dst_adj = 1;\n-        }\n-    }\n-}\n-\n-#define MIN_MOVE_REGS 3\n-#define MIN_MOVE_BYTES (MIN_MOVE_REGS * UNITS_PER_WORD)\n-#define MAX_MOVE_REGS 4\n-#define MAX_MOVE_BYTES (MAX_MOVE_REGS * UNITS_PER_WORD)\n-\n-/* The length is large, generate a loop if necessary.\n-   The loop is consisted by loop head/body/foot.  */\n-static void\n-mdx_block_move_loop (rtx dst, rtx src, HOST_WIDE_INT length)\n-{\n-  HOST_WIDE_INT src_align = MEM_ALIGN (src);\n-  HOST_WIDE_INT dst_align = MEM_ALIGN (dst);\n-  HOST_WIDE_INT loop_mov_bytes;\n-  HOST_WIDE_INT iteration = 0;\n-  HOST_WIDE_INT head_length = 0, leftover;\n-  rtx label, src_reg, dst_reg, final_dst;\n-\n-  bool gen_loop_head = (src_align < BITS_PER_WORD\n-                        || dst_align < BITS_PER_WORD);\n-\n-  if (gen_loop_head)\n-    head_length += UNITS_PER_WORD;\n-\n-  for (loop_mov_bytes = MAX_MOVE_BYTES;\n-       loop_mov_bytes >= MIN_MOVE_BYTES;\n-       loop_mov_bytes -= UNITS_PER_WORD)\n-    {\n-      iteration = (length - head_length) / loop_mov_bytes;\n-      if (iteration > 1)\n-        break;\n-    }\n-  if (iteration <= 1)\n-    {\n-      mdx_block_move_straight (dst, src, length);\n-      return;\n-    }\n-\n-  leftover = (length - head_length) % loop_mov_bytes;\n-  length -= leftover;\n-\n-  src_reg = copy_addr_to_reg (XEXP (src, 0));\n-  dst_reg = copy_addr_to_reg (XEXP (dst, 0));\n-  final_dst = expand_simple_binop (Pmode, PLUS, dst_reg, GEN_INT (length),\n-                                   0, 0, OPTAB_WIDEN);\n-\n-  if (gen_loop_head)\n-    mdx_block_move_loop_head (dst_reg, dst_align,\n-                              src_reg, src_align, head_length);\n-\n-  label = gen_label_rtx ();\n-  emit_label (label);\n-\n-  mdx_block_move_loop_body (dst_reg, dst_align,\n-                            src_reg, src_align, loop_mov_bytes);\n-\n-  emit_insn (gen_cmpsi (dst_reg, final_dst));\n-  emit_jump_insn (gen_bne (label));\n-\n-  mdx_block_move_loop_foot (dst_reg, dst_align,\n-                            src_reg, src_align, leftover);\n-}\n-\n-/* Generate block move, for misc.md: \"movmemsi\".  */\n-bool\n-mdx_block_move (rtx *ops)\n-{\n-  rtx dst = ops[0];\n-  rtx src = ops[1];\n-  rtx length = ops[2];\n-\n-  if (TARGET_LITTLE_ENDIAN\n-      && (MEM_ALIGN (src) < BITS_PER_WORD || MEM_ALIGN (dst) < BITS_PER_WORD)\n-      && INTVAL (length) >= UNITS_PER_WORD)\n-    return false;\n-\n-  if (GET_CODE (length) == CONST_INT)\n-    {\n-      if (INTVAL (length) <= 2 * MAX_MOVE_BYTES)\n-        {\n-           mdx_block_move_straight (dst, src, INTVAL (length));\n-           return true;\n-        }\n-      else if (optimize &&\n-               !(flag_unroll_loops || flag_unroll_all_loops))\n-        {\n-          mdx_block_move_loop (dst, src, INTVAL (length));\n-          return true;\n-        }\n-    }\n-  return false;\n-}\n-\n-/* Generate add insn.  */\n-const char *\n-mdp_select_add_imm (rtx *ops, bool set_cc)\n-{\n-  HOST_WIDE_INT v = INTVAL (ops[2]);\n-\n-  gcc_assert (GET_CODE (ops[2]) == CONST_INT);\n-  gcc_assert (REGNO (ops[0]) == REGNO (ops[1]));\n-\n-  if (set_cc && G16_REG_P (REGNO (ops[0])))\n-    {\n-      if (v > 0 && IMM_IS_POW_OF_2 ((unsigned HOST_WIDE_INT) v, 0, 15))\n-        {\n-          ops[2] = GEN_INT (ffs (v) - 1);\n-          return \"addei!  %0, %c2\";\n-        }\n-\n-      if (v < 0 && IMM_IS_POW_OF_2 ((unsigned HOST_WIDE_INT) (-v), 0, 15))\n-        {\n-          ops[2] = GEN_INT (ffs (-v) - 1);\n-          return \"subei!  %0, %c2\";\n-        }\n-    }\n-\n-  if (set_cc)\n-    return \"addi.c  %0, %c2\";\n-  else\n-    return \"addi    %0, %c2\";\n-}\n-\n-/* Output arith insn.  */\n-const char *\n-mdp_select (rtx *ops, const char *inst_pre,\n-            bool commu, const char *letter, bool set_cc)\n-{\n-  gcc_assert (GET_CODE (ops[0]) == REG);\n-  gcc_assert (GET_CODE (ops[1]) == REG);\n-\n-  if (set_cc && G16_REG_P (REGNO (ops[0]))\n-      && (GET_CODE (ops[2]) == REG ? G16_REG_P (REGNO (ops[2])) : 1)\n-      && REGNO (ops[0]) == REGNO (ops[1]))\n-    {\n-      snprintf (ins, INS_BUF_SZ, \"%s!  %%0, %%%s2\", inst_pre, letter);\n-      return ins;\n-    }\n-\n-  if (commu && set_cc && G16_REG_P (REGNO (ops[0]))\n-      && G16_REG_P (REGNO (ops[1]))\n-      && REGNO (ops[0]) == REGNO (ops[2]))\n-    {\n-      gcc_assert (GET_CODE (ops[2]) == REG);\n-      snprintf (ins, INS_BUF_SZ, \"%s!  %%0, %%%s1\", inst_pre, letter);\n-      return ins;\n-    }\n-\n-  if (set_cc)\n-    snprintf (ins, INS_BUF_SZ, \"%s.c  %%0, %%1, %%%s2\", inst_pre, letter);\n-  else\n-    snprintf (ins, INS_BUF_SZ, \"%s    %%0, %%1, %%%s2\", inst_pre, letter);\n-  return ins;\n-}\n-"}, {"sha": "99a40601305196d2bc5bae3a2fb404d2d0104d0e", "filename": "gcc/config/score/score-mdaux.h", "status": "removed", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23710ddde48ab95c906e89280383aa0c99eea2f1/gcc%2Fconfig%2Fscore%2Fscore-mdaux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23710ddde48ab95c906e89280383aa0c99eea2f1/gcc%2Fconfig%2Fscore%2Fscore-mdaux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-mdaux.h?ref=23710ddde48ab95c906e89280383aa0c99eea2f1", "patch": "@@ -1,115 +0,0 @@\n-/* score-mdaux.h for Sunplus S+CORE processor\n-   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n-   Contributed by Sunnorth\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef SCORE_MDAUX_0621\n-#define SCORE_MDAUX_0621\n-\n-/* Machine Auxiliary Functions.  */\n-enum score_address_type\n-{\n-  ADD_REG,\n-  ADD_CONST_INT,\n-  ADD_SYMBOLIC\n-};\n-#ifdef RTX_CODE\n-struct score_address_info\n-{\n-  enum score_address_type type;\n-  rtx reg;\n-  rtx offset;\n-  enum rtx_code code;\n-  enum score_symbol_type symbol_type;\n-};\n-#endif\n-\n-struct score_frame_info\n-{\n-  HOST_WIDE_INT total_size;       /* bytes that the entire frame takes up  */\n-  HOST_WIDE_INT var_size;         /* bytes that variables take up  */\n-  HOST_WIDE_INT args_size;        /* bytes that outgoing arguments take up  */\n-  HOST_WIDE_INT gp_reg_size;      /* bytes needed to store gp regs  */\n-  HOST_WIDE_INT gp_sp_offset;     /* offset from new sp to store gp registers  */\n-  HOST_WIDE_INT cprestore_size;   /* # bytes that the .cprestore slot takes up  */\n-  unsigned int  mask;             /* mask of saved gp registers  */\n-  int num_gp;                     /* number of gp registers saved  */\n-};\n-\n-typedef void (*score_save_restore_fn) (rtx, rtx);\n-\n-int mda_valid_base_register_p (rtx x, int strict);\n-\n-#ifdef RTX_CODE\n-int mda_classify_address (struct score_address_info *info,\n-                          enum machine_mode mode, rtx x, int strict);\n-\n-struct score_frame_info *mda_compute_frame_size (HOST_WIDE_INT size);\n-\n-struct score_frame_info *mda_cached_frame (void);\n-\n-void mda_gen_cmp (enum machine_mode mode);\n-#endif\n-\n-int mda_symbolic_constant_p (rtx x, enum score_symbol_type *symbol_type);\n-\n-int mda_bp (void);\n-\n-/* Machine Expand.  */\n-void mdx_prologue (void);\n-\n-void mdx_epilogue (int sibcall_p);\n-\n-void mdx_movsicc (rtx *ops);\n-\n-void mdx_call (rtx *ops, bool sibcall);\n-\n-void mdx_call_value (rtx *ops, bool sibcall);\n-\n-/* Machine Split.  */\n-void mds_movdi (rtx *ops);\n-\n-void mds_zero_extract_andi (rtx *ops);\n-\n-/* Machine Print.  */\n-enum mda_mem_unit {MDA_BYTE = 0, MDA_HWORD = 1, MDA_WORD = 2};\n-\n-#define MDA_ALIGN_UNIT(V, UNIT)   !(V & ((1 << UNIT) - 1))\n-\n-const char * mdp_linsn (rtx *ops, enum mda_mem_unit unit, bool sign);\n-\n-const char * mdp_sinsn (rtx *ops, enum mda_mem_unit unit);\n-\n-const char * mdp_select_add_imm (rtx *ops, bool set_cc);\n-\n-const char * mdp_select (rtx *ops, const char *inst_pre,\n-                        bool commu, const char *letter, bool set_cc);\n-\n-const char * mdp_limm (rtx *ops);\n-\n-const char * mdp_move (rtx *ops);\n-\n-/* Machine unaligned memory load/store. */\n-bool mdx_unaligned_load (rtx* ops);\n-\n-bool mdx_unaligned_store (rtx* ops);\n-\n-bool mdx_block_move (rtx* ops);\n-\n-#endif\n-"}, {"sha": "c240d8272dc62659cb1651fc2c3e8f5afb00cc4a", "filename": "gcc/config/score/score-protos.h", "status": "modified", "additions": 72, "deletions": 68, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-protos.h?ref=254f522229578af1af093b2e4b6f1a0cc400d216", "patch": "@@ -17,76 +17,80 @@\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n \n-#ifndef __SCORE_PROTOS_H__\n-#define __SCORE_PROTOS_H__\n-\n-extern enum reg_class score_char_to_class[];\n-\n-void score_override_options (void);\n-\n-void score_init_expanders (void);\n-\n-int score_hard_regno_mode_ok (unsigned int, enum machine_mode);\n-\n-int score_reg_class (int regno);\n-\n-enum reg_class score_preferred_reload_class (rtx x, enum reg_class class);\n-\n-enum reg_class score_secondary_reload_class (enum reg_class class,\n-                                             enum machine_mode mode, rtx x);\n-\n-int score_const_ok_for_letter_p (HOST_WIDE_INT value, char c);\n-\n-int score_extra_constraint (rtx op, char c);\n-\n-rtx score_return_addr (int count, rtx frame);\n-\n-HOST_WIDE_INT score_initial_elimination_offset (int from, int to);\n-\n-rtx score_function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-                        tree type, int named);\n-\n-int score_arg_partial_nregs (const CUMULATIVE_ARGS *cum,\n-                             enum machine_mode mode, tree type, int named);\n-\n-void score_init_cumulative_args (CUMULATIVE_ARGS *cum,\n-                                 tree fntype, rtx libname);\n-\n-void score_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-                                 tree type, int named);\n-\n-rtx score_function_value (const_tree valtype, const_tree func, enum machine_mode mode);\n-\n-rtx score_va_arg (tree va_list, tree type);\n-\n-void score_initialize_trampoline (rtx ADDR, rtx FUNC, rtx CHAIN);\n-\n-int score_address_p (enum machine_mode mode, rtx x, int strict);\n-\n-int score_legitimize_address (rtx *xloc);\n-\n-int score_regno_mode_ok_for_base_p (int regno, int strict);\n-\n-int score_register_move_cost (enum machine_mode mode, enum reg_class to,\n-                              enum reg_class from);\n-\n-void score_declare_object (FILE *stream, const char *name,\n-                           const char *directive, const char *fmt, ...)\n-     ATTRIBUTE_PRINTF_4;\n-\n-void score_declare_object_name (FILE *stream, const char *name, tree decl);\n-\n-int score_output_external (FILE *file, tree decl, const char *name);\n-\n-void score_print_operand (FILE *file, rtx op, int letter);\n-\n-void score_print_operand_address (FILE *file, rtx addr);\n+#ifndef GCC_SCORE_PROTOS_H\n+#define GCC_SCORE_PROTOS_H\n+\n+/* Machine Print.  */\n+enum score_mem_unit {SCORE_BYTE = 0, SCORE_HWORD = 1, SCORE_WORD = 2};\n+\n+#define SCORE_ALIGN_UNIT(V, UNIT)   !(V & ((1 << UNIT) - 1))\n+\n+extern void score_gen_cmp (enum machine_mode mode);\n+extern void score_prologue (void);\n+extern void score_epilogue (int sibcall_p);\n+extern void score_call (rtx *ops, bool sib);\n+extern void score_call_value (rtx *ops, bool sib);\n+extern void score_movdi (rtx *ops);\n+extern void score_zero_extract_andi (rtx *ops);\n+extern const char * score_linsn (rtx *ops, enum score_mem_unit unit, bool sign);\n+extern const char * score_sinsn (rtx *ops, enum score_mem_unit unit);\n+extern const char * score_limm (rtx *ops);\n+extern const char * score_move (rtx *ops);\n+extern bool score_unaligned_load (rtx* ops);\n+extern bool score_unaligned_store (rtx* ops);\n+extern bool score_block_move (rtx* ops);\n+extern int score_address_cost (rtx addr);\n+extern rtx score_function_arg (const CUMULATIVE_ARGS *cum,\n+                               enum machine_mode mode,\n+                               tree type, int named);\n+extern int score_address_p (enum machine_mode mode, rtx x, int strict);\n+extern int score_reg_class (int regno);\n+extern int score_register_move_cost (enum machine_mode mode, enum reg_class to,\n+                                     enum reg_class from);\n+extern int score_hard_regno_mode_ok (unsigned int, enum machine_mode);\n+extern int score_const_ok_for_letter_p (HOST_WIDE_INT value, char c);\n+extern int score_extra_constraint (rtx op, char c);\n+extern rtx score_return_addr (int count, rtx frame);\n+extern void score_initialize_trampoline (rtx ADDR, rtx FUNC, rtx CHAIN);\n+extern int score_regno_mode_ok_for_base_p (int regno, int strict);\n+extern void score_function_arg_advance (CUMULATIVE_ARGS *cum,\n+                                        enum machine_mode mode,\n+                                        tree type, int named);\n+extern void score_init_cumulative_args (CUMULATIVE_ARGS *cum,\n+                                        tree fntype, rtx libname);\n+extern void score_declare_object (FILE *stream, const char *name,\n+                                  const char *directive, const char *fmt, ...);\n+extern int score_output_external (FILE *file, tree decl, const char *name);\n+extern void score_override_options (void);\n+extern enum reg_class score_secondary_reload_class (enum reg_class class,\n+                                                    enum machine_mode mode,\n+                                                    rtx x);\n+extern rtx score_function_value (tree valtype, tree func,\n+                                 enum machine_mode mode);\n+extern enum reg_class score_preferred_reload_class (rtx x,\n+                                                    enum reg_class class);\n+extern HOST_WIDE_INT score_initial_elimination_offset (int from, int to);\n+extern void score_print_operand (FILE *file, rtx op, int letter);\n+extern void score_print_operand_address (FILE *file, rtx addr);\n+extern int score_legitimize_address (rtx *xloc);\n+extern int score_arg_partial_bytes (CUMULATIVE_ARGS *cum,\n+                                    enum machine_mode mode,\n+                                    tree type, bool named);\n+extern int score_symbolic_constant_p (rtx x,\n+                                      enum score_symbol_type *symbol_type);\n+extern void score_movsicc (rtx *ops);\n+extern const char * score_select_add_imm (rtx *ops, bool set_cc);\n+extern const char * score_select (rtx *ops, const char *inst_pre, bool commu,\n+                                  const char *letter, bool set_cc);\n+extern const char * score_output_casesi (rtx *operands);\n+extern const char * score_rpush (rtx *ops);\n+extern const char * score_rpop (rtx *ops);\n+extern bool score_rtx_costs (rtx x, int code, int outer_code, int *total);\n \n #ifdef RTX_CODE\n-enum machine_mode score_select_cc_mode (enum rtx_code op, rtx x, rtx y);\n+extern enum machine_mode score_select_cc_mode (enum rtx_code op, rtx x, rtx y);\n #endif\n \n-#include \"score-mdaux.h\"\n-\n-#endif /* __SCORE_PROTOS_H__  */\n+extern struct extern_list *extern_head;\n \n+#endif /* GCC_SCORE_PROTOS_H  */"}, {"sha": "0a54af16218a6fa8cfaef718bcb9fab7074d9aff", "filename": "gcc/config/score/score-version.h", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23710ddde48ab95c906e89280383aa0c99eea2f1/gcc%2Fconfig%2Fscore%2Fscore-version.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23710ddde48ab95c906e89280383aa0c99eea2f1/gcc%2Fconfig%2Fscore%2Fscore-version.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-version.h?ref=23710ddde48ab95c906e89280383aa0c99eea2f1", "patch": "@@ -1,20 +0,0 @@\n-/* score-version.h for Sunplus S+CORE processor\n-   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#define SCORE_GCC_VERSION \"1.2\""}, {"sha": "56c6c47708281149ada4452e0f101e7a1fa22fa5", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 799, "deletions": 957, "changes": 1756, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=254f522229578af1af093b2e4b6f1a0cc400d216", "patch": "@@ -22,7 +22,6 @@\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n-#include <signal.h>\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -48,69 +47,52 @@\n #include \"target-def.h\"\n #include \"integrate.h\"\n #include \"langhooks.h\"\n-#include \"cfglayout.h\"\n-#include \"score-mdaux.h\"\n-\n-#define GR_REG_CLASS_P(C)        ((C) == G16_REGS || (C) == G32_REGS)\n-#define SP_REG_CLASS_P(C) \\\n-  ((C) == CN_REG || (C) == LC_REG || (C) == SC_REG || (C) == SP_REGS)\n-#define CP_REG_CLASS_P(C) \\\n-  ((C) == CP1_REGS || (C) == CP2_REGS || (C) == CP3_REGS || (C) == CPA_REGS)\n-#define CE_REG_CLASS_P(C) \\\n-  ((C) == HI_REG || (C) == LO_REG || (C) == CE_REGS)\n-\n-static int score_arg_partial_bytes (CUMULATIVE_ARGS *,\n-                                    enum machine_mode, tree, bool);\n-\n-static int score_symbol_insns (enum score_symbol_type);\n-\n-static int score_address_insns (rtx, enum machine_mode);\n-\n-static bool score_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *);\n-\n-static int score_address_cost (rtx);\n+#include \"score7.h\"\n+#include \"score3.h\"\n \n #undef  TARGET_ASM_FILE_START\n-#define TARGET_ASM_FILE_START           th_asm_file_start\n+#define TARGET_ASM_FILE_START           score_asm_file_start\n \n #undef  TARGET_ASM_FILE_END\n-#define TARGET_ASM_FILE_END             th_asm_file_end\n+#define TARGET_ASM_FILE_END             score_asm_file_end\n \n #undef  TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE    th_function_prologue\n+#define TARGET_ASM_FUNCTION_PROLOGUE    score_function_prologue\n \n #undef  TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE    th_function_epilogue\n+#define TARGET_ASM_FUNCTION_EPILOGUE    score_function_epilogue\n+\n+#undef TARGET_DEFAULT_TARGET_FLAGS\n+#define TARGET_DEFAULT_TARGET_FLAGS     TARGET_DEFAULT\n+#undef TARGET_HANDLE_OPTION\n+#define TARGET_HANDLE_OPTION            score_handle_option\n \n #undef  TARGET_SCHED_ISSUE_RATE\n-#define TARGET_SCHED_ISSUE_RATE         th_issue_rate\n+#define TARGET_SCHED_ISSUE_RATE         score_issue_rate\n \n #undef TARGET_ASM_SELECT_RTX_SECTION\n-#define TARGET_ASM_SELECT_RTX_SECTION   th_select_rtx_section\n+#define TARGET_ASM_SELECT_RTX_SECTION   score_select_rtx_section\n \n #undef  TARGET_IN_SMALL_DATA_P\n-#define TARGET_IN_SMALL_DATA_P          th_in_small_data_p\n+#define TARGET_IN_SMALL_DATA_P          score_in_small_data_p\n \n #undef  TARGET_FUNCTION_OK_FOR_SIBCALL\n-#define TARGET_FUNCTION_OK_FOR_SIBCALL  th_function_ok_for_sibcall\n+#define TARGET_FUNCTION_OK_FOR_SIBCALL  score_function_ok_for_sibcall\n \n #undef TARGET_STRICT_ARGUMENT_NAMING\n-#define TARGET_STRICT_ARGUMENT_NAMING   th_strict_argument_naming\n+#define TARGET_STRICT_ARGUMENT_NAMING   hook_bool_CUMULATIVE_ARGS_true\n \n #undef TARGET_ASM_OUTPUT_MI_THUNK\n-#define TARGET_ASM_OUTPUT_MI_THUNK      th_output_mi_thunk\n-\n-#undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n-#define TARGET_ASM_CAN_OUTPUT_MI_THUNK  hook_bool_const_tree_hwi_hwi_const_tree_true\n+#define TARGET_ASM_OUTPUT_MI_THUNK      score_output_mi_thunk\n \n #undef TARGET_PROMOTE_FUNCTION_ARGS\n-#define TARGET_PROMOTE_FUNCTION_ARGS    hook_bool_const_tree_true\n+#define TARGET_PROMOTE_FUNCTION_ARGS    hook_bool_tree_true\n \n #undef TARGET_PROMOTE_FUNCTION_RETURN\n-#define TARGET_PROMOTE_FUNCTION_RETURN  hook_bool_const_tree_true\n+#define TARGET_PROMOTE_FUNCTION_RETURN  hook_bool_tree_true\n \n #undef TARGET_PROMOTE_PROTOTYPES\n-#define TARGET_PROMOTE_PROTOTYPES       hook_bool_const_tree_true\n+#define TARGET_PROMOTE_PROTOTYPES       hook_bool_tree_true\n \n #undef TARGET_MUST_PASS_IN_STACK\n #define TARGET_MUST_PASS_IN_STACK       must_pass_in_stack_var_size\n@@ -130,437 +112,263 @@ static int score_address_cost (rtx);\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST             score_address_cost\n \n-#undef TARGET_DEFAULT_TARGET_FLAGS\n-#define TARGET_DEFAULT_TARGET_FLAGS     TARGET_DEFAULT\n+struct extern_list *extern_head = 0;\n+rtx cmp_op0, cmp_op1;\n+\n+/* default 0 = NO_REGS  */\n+enum reg_class score_char_to_class[256];\n \n /* Implement TARGET_RETURN_IN_MEMORY.  In S+core,\n    small structures are returned in a register.\n    Objects with varying size must still be returned in memory.  */\n static bool\n-score_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n+score_return_in_memory (tree type, tree fndecl ATTRIBUTE_UNUSED)\n {\n-  return ((TYPE_MODE (type) == BLKmode)\n-          || (int_size_in_bytes (type) > 2 * UNITS_PER_WORD)\n-          || (int_size_in_bytes (type) == -1));\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_return_in_memory (type, fndecl);\n+  else if (TARGET_SCORE3)\n+    return score3_return_in_memory (type, fndecl);\n+\n+  gcc_unreachable ();\n }\n \n /* Return nonzero when an argument must be passed by reference.  */\n static bool\n score_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n-                         enum machine_mode mode, const_tree type,\n+                         enum machine_mode mode, tree type,\n                          bool named ATTRIBUTE_UNUSED)\n {\n   /* If we have a variable-sized parameter, we have no choice.  */\n   return targetm.calls.must_pass_in_stack (mode, type);\n }\n \n-/* Return a legitimate address for REG + OFFSET.  */\n-static rtx\n-score_add_offset (rtx temp ATTRIBUTE_UNUSED, rtx reg, HOST_WIDE_INT offset)\n-{\n-  if (!IMM_IN_RANGE (offset, 15, 1))\n-    {\n-      reg = expand_simple_binop (GET_MODE (reg), PLUS,\n-                                 gen_int_mode (offset & 0xffffc000,\n-                                               GET_MODE (reg)),\n-                                 reg, NULL, 0, OPTAB_WIDEN);\n-      offset &= 0x3fff;\n-    }\n-\n-  return plus_constant (reg, offset);\n-}\n-\n /* Implement TARGET_ASM_OUTPUT_MI_THUNK.  Generate rtl rather than asm text\n    in order to avoid duplicating too much logic from elsewhere.  */\n static void\n-th_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n-                    HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n-                    tree function)\n-{\n-  rtx this, temp1, temp2, insn, fnaddr;\n-\n-  /* Pretend to be a post-reload pass while generating rtl.  */\n-  reload_completed = 1;\n-\n-  /* Mark the end of the (empty) prologue.  */\n-  emit_note (NOTE_INSN_PROLOGUE_END);\n- \n-  /* We need two temporary registers in some cases.  */\n-  temp1 = gen_rtx_REG (Pmode, 8);\n-  temp2 = gen_rtx_REG (Pmode, 9);\n-\n-  /* Find out which register contains the \"this\" pointer.  */\n-  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n-    this = gen_rtx_REG (Pmode, ARG_REG_FIRST + 1);\n-  else\n-    this = gen_rtx_REG (Pmode, ARG_REG_FIRST);\n-\n-  /* Add DELTA to THIS.  */\n-  if (delta != 0)\n-    {\n-      rtx offset = GEN_INT (delta);\n-      if (!CONST_OK_FOR_LETTER_P (delta, 'L'))\n-        {\n-          emit_move_insn (temp1, offset);\n-          offset = temp1;\n-        }\n-      emit_insn (gen_add3_insn (this, this, offset));\n-    }\n-\n-  /* If needed, add *(*THIS + VCALL_OFFSET) to THIS.  */\n-  if (vcall_offset != 0)\n-    {\n-      rtx addr;\n-\n-      /* Set TEMP1 to *THIS.  */\n-      emit_move_insn (temp1, gen_rtx_MEM (Pmode, this));\n-\n-      /* Set ADDR to a legitimate address for *THIS + VCALL_OFFSET.  */\n-      addr = score_add_offset (temp2, temp1, vcall_offset);\n-\n-      /* Load the offset and add it to THIS.  */\n-      emit_move_insn (temp1, gen_rtx_MEM (Pmode, addr));\n-      emit_insn (gen_add3_insn (this, this, temp1));\n-    }\n-\n-  /* Jump to the target function.  */\n-  fnaddr = XEXP (DECL_RTL (function), 0);\n-  insn = emit_call_insn (gen_sibcall_internal (fnaddr, const0_rtx));\n-  SIBLING_CALL_P (insn) = 1;\n-\n-  /* Run just enough of rest_of_compilation.  This sequence was\n-     \"borrowed\" from alpha.c.  */\n-  insn = get_insns ();\n-  insn_locators_alloc ();\n-  split_all_insns_noflow ();\n-  shorten_branches (insn);\n-  final_start_function (insn, file, 1);\n-  final (insn, file, 1);\n-  final_end_function ();\n-\n-  /* Clean up the vars set above.  Note that final_end_function resets\n-     the global pointer for us.  */\n-  reload_completed = 0;\n-}\n-\n-/* Implement TARGET_STRICT_ARGUMENT_NAMING.  */\n-static bool\n-th_strict_argument_naming (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED)\n+score_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n+                       HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n+                       tree function)\n {\n-  return true;\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_output_mi_thunk (file, thunk_fndecl, delta,\n+                                   vcall_offset, function);\n+  else if (TARGET_SCORE3)\n+    return score3_output_mi_thunk (file, thunk_fndecl, delta,\n+                                   vcall_offset, function);\n+  gcc_unreachable ();\n }\n \n /* Implement TARGET_FUNCTION_OK_FOR_SIBCALL.  */\n static bool\n-th_function_ok_for_sibcall (ATTRIBUTE_UNUSED tree decl,\n-                            ATTRIBUTE_UNUSED tree exp)\n+score_function_ok_for_sibcall (ATTRIBUTE_UNUSED tree decl,\n+                               ATTRIBUTE_UNUSED tree exp)\n {\n   return true;\n }\n \n-struct score_arg_info\n-{\n-  /* The argument's size, in bytes.  */\n-  unsigned int num_bytes;\n-\n-  /* The number of words passed in registers, rounded up.  */\n-  unsigned int reg_words;\n-\n-  /* The offset of the first register from GP_ARG_FIRST or FP_ARG_FIRST,\n-     or ARG_REG_NUM if the argument is passed entirely on the stack.  */\n-  unsigned int reg_offset;\n-\n-  /* The number of words that must be passed on the stack, rounded up.  */\n-  unsigned int stack_words;\n-\n-  /* The offset from the start of the stack overflow area of the argument's\n-     first stack word.  Only meaningful when STACK_WORDS is nonzero.  */\n-  unsigned int stack_offset;\n-};\n-\n-/* Fill INFO with information about a single argument.  CUM is the\n-   cumulative state for earlier arguments.  MODE is the mode of this\n-   argument and TYPE is its type (if known).  NAMED is true if this\n-   is a named (fixed) argument rather than a variable one.  */\n-static void\n-classify_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-              tree type, int named, struct score_arg_info *info)\n-{\n-  int even_reg_p;\n-  unsigned int num_words, max_regs;\n-\n-  even_reg_p = 0;\n-  if (GET_MODE_CLASS (mode) == MODE_INT\n-      || GET_MODE_CLASS (mode) == MODE_FLOAT)\n-    even_reg_p = (GET_MODE_SIZE (mode) > UNITS_PER_WORD);\n-  else\n-    if (type != NULL_TREE && TYPE_ALIGN (type) > BITS_PER_WORD && named)\n-      even_reg_p = 1;\n-\n-  if (TARGET_MUST_PASS_IN_STACK (mode, type))\n-    info->reg_offset = ARG_REG_NUM;\n-  else\n-    {\n-      info->reg_offset = cum->num_gprs;\n-      if (even_reg_p)\n-        info->reg_offset += info->reg_offset & 1;\n-    }\n-\n-  if (mode == BLKmode)\n-    info->num_bytes = int_size_in_bytes (type);\n-  else\n-    info->num_bytes = GET_MODE_SIZE (mode);\n-\n-  num_words = (info->num_bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-  max_regs = ARG_REG_NUM - info->reg_offset;\n-\n-  /* Partition the argument between registers and stack.  */\n-  info->reg_words = MIN (num_words, max_regs);\n-  info->stack_words = num_words - info->reg_words;\n-\n-  /* The alignment applied to registers is also applied to stack arguments.  */\n-  if (info->stack_words)\n-    {\n-      info->stack_offset = cum->stack_words;\n-      if (even_reg_p)\n-        info->stack_offset += info->stack_offset & 1;\n-    }\n-}\n-\n /* Set up the stack and frame (if desired) for the function.  */\n static void\n-th_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n+score_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n-  const char *fnname;\n-  struct score_frame_info *f = mda_cached_frame ();\n-  HOST_WIDE_INT tsize = f->total_size;\n-\n-  fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n-  if (!flag_inhibit_size_directive)\n-    {\n-      fputs (\"\\t.ent\\t\", file);\n-      assemble_name (file, fnname);\n-      fputs (\"\\n\", file);\n-    }\n-  assemble_name (file, fnname);\n-  fputs (\":\\n\", file);\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_function_prologue (file, size);\n+  else if (TARGET_SCORE3)\n+    return score3_function_prologue (file, size);\n \n-  if (!flag_inhibit_size_directive)\n-    {\n-      fprintf (file,\n-               \"\\t.frame\\t%s,\" HOST_WIDE_INT_PRINT_DEC \",%s, %d\\t\\t\"\n-               \"# vars= \" HOST_WIDE_INT_PRINT_DEC \", regs= %d\"\n-               \", args= \" HOST_WIDE_INT_PRINT_DEC\n-               \", gp= \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-               (reg_names[(frame_pointer_needed)\n-                ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM]),\n-               tsize,\n-               reg_names[RA_REGNUM],\n-               current_function_is_leaf ? 1 : 0,\n-               f->var_size,\n-               f->num_gp,\n-               f->args_size,\n-               f->cprestore_size);\n-\n-      fprintf(file, \"\\t.mask\\t0x%08x,\" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-              f->mask,\n-              (f->gp_sp_offset - f->total_size));\n-    }\n+  gcc_unreachable ();\n }\n \n /* Do any necessary cleanup after a function to restore stack, frame,\n    and regs.  */\n static void\n-th_function_epilogue (FILE *file,\n-                      HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n+score_function_epilogue (FILE *file,\n+                         HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n-  if (!flag_inhibit_size_directive)\n-    {\n-      const char *fnname;\n-      fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n-      fputs (\"\\t.end\\t\", file);\n-      assemble_name (file, fnname);\n-      fputs (\"\\n\", file);\n-    }\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_function_epilogue (file, size);\n+  else if (TARGET_SCORE3)\n+    return score3_function_epilogue (file, size);\n+\n+  gcc_unreachable ();\n }\n \n /* Implement TARGET_SCHED_ISSUE_RATE.  */\n static int\n-th_issue_rate (void)\n+score_issue_rate (void)\n {\n   return 1;\n }\n \n-/* Returns true if X contains a SYMBOL_REF.  */\n-static bool\n-symbolic_expression_p (rtx x)\n-{\n-  if (GET_CODE (x) == SYMBOL_REF)\n-    return true;\n-\n-  if (GET_CODE (x) == CONST)\n-    return symbolic_expression_p (XEXP (x, 0));\n-\n-  if (UNARY_P (x))\n-    return symbolic_expression_p (XEXP (x, 0));\n-\n-  if (ARITHMETIC_P (x))\n-    return (symbolic_expression_p (XEXP (x, 0))\n-            || symbolic_expression_p (XEXP (x, 1)));\n-\n-  return false;\n-}\n-\n /* Choose the section to use for the constant rtx expression X that has\n    mode MODE.  */\n static section *\n-th_select_rtx_section (enum machine_mode mode, rtx x,\n-                       unsigned HOST_WIDE_INT align)\n+score_select_rtx_section (enum machine_mode mode, rtx x,\n+                          unsigned HOST_WIDE_INT align)\n {\n-  if (GET_MODE_SIZE (mode) <= SCORE_SDATA_MAX)\n-    return get_named_section (0, \".sdata\", 0);\n-  else if (flag_pic && symbolic_expression_p (x))\n-    return get_named_section (0, \".data.rel.ro\", 3);\n-  else\n-    return mergeable_constant_section (mode, align, 0);\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_select_rtx_section (mode, x, align);\n+  else if (TARGET_SCORE3)\n+    return score3_select_rtx_section (mode, x, align);\n+\n+  gcc_unreachable ();\n }\n \n /* Implement TARGET_IN_SMALL_DATA_P.  */\n static bool\n-th_in_small_data_p (const_tree decl)\n+score_in_small_data_p (tree decl)\n {\n-  HOST_WIDE_INT size;\n-\n-  if (TREE_CODE (decl) == STRING_CST\n-      || TREE_CODE (decl) == FUNCTION_DECL)\n-    return false;\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_in_small_data_p (decl);\n+  else if (TARGET_SCORE3)\n+    return score3_in_small_data_p (decl);\n \n-  if (TREE_CODE (decl) == VAR_DECL && DECL_SECTION_NAME (decl) != 0)\n-    {\n-      const char *name;\n-      name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n-      if (strcmp (name, \".sdata\") != 0\n-          && strcmp (name, \".sbss\") != 0)\n-        return true;\n-      if (!DECL_EXTERNAL (decl))\n-        return false;\n-    }\n-  size = int_size_in_bytes (TREE_TYPE (decl));\n-  return (size > 0 && size <= SCORE_SDATA_MAX);\n+  gcc_unreachable ();\n }\n \n /* Implement TARGET_ASM_FILE_START.  */\n static void\n-th_asm_file_start (void)\n+score_asm_file_start (void)\n {\n+  if (TARGET_SCORE5)\n+    fprintf (asm_out_file, \"# Sunplus S+core5 %s rev=%s\\n\",\n+             TARGET_LITTLE_ENDIAN ? \"el\" : \"eb\", SCORE_GCC_VERSION);\n+  else if (TARGET_SCORE5U)\n+    fprintf (asm_out_file, \"# Sunplus S+core5u %s rev=%s\\n\",\n+             TARGET_LITTLE_ENDIAN ? \"el\" : \"eb\", SCORE_GCC_VERSION);\n+  else if (TARGET_SCORE7D)\n+    fprintf (asm_out_file, \"# Sunplus S+core7d %s rev=%s\\n\",\n+             TARGET_LITTLE_ENDIAN ? \"el\" : \"eb\", SCORE_GCC_VERSION);\n+  else if (TARGET_SCORE7)\n+    fprintf (asm_out_file, \"# Sunplus S+core7 %s rev=%s\\n\",\n+             TARGET_LITTLE_ENDIAN ? \"el\" : \"eb\", SCORE_GCC_VERSION);\n+  else if (TARGET_SCORE3D)\n+    fprintf (asm_out_file, \"# Sunplus S+core3d %s rev=%s\\n\",\n+             TARGET_LITTLE_ENDIAN ? \"el\" : \"eb\", SCORE_GCC_VERSION);\n+  else if (TARGET_SCORE3)\n+    fprintf (asm_out_file, \"# Sunplus S+core3 %s rev=%s\\n\",\n+             TARGET_LITTLE_ENDIAN ? \"el\" : \"eb\", SCORE_GCC_VERSION);\n+  else\n+    fprintf (asm_out_file, \"# Sunplus S+core unknown %s rev=%s\\n\",\n+             TARGET_LITTLE_ENDIAN ? \"el\" : \"eb\", SCORE_GCC_VERSION);\n+\n   default_file_start ();\n-  fprintf (asm_out_file, ASM_COMMENT_START\n-           \"GCC for S+core %s \\n\", SCORE_GCC_VERSION);\n \n   if (flag_pic)\n     fprintf (asm_out_file, \"\\t.set pic\\n\");\n }\n \n /* Implement TARGET_ASM_FILE_END.  When using assembler macros, emit\n    .externs for any small-data variables that turned out to be external.  */\n-struct extern_list *extern_head = 0;\n-\n static void\n-th_asm_file_end (void)\n+score_asm_file_end (void)\n {\n-  tree name_tree;\n-  struct extern_list *p;\n-  if (extern_head)\n-    {\n-      fputs (\"\\n\", asm_out_file);\n-      for (p = extern_head; p != 0; p = p->next)\n-        {\n-          name_tree = get_identifier (p->name);\n-          if (!TREE_ASM_WRITTEN (name_tree)\n-              && TREE_SYMBOL_REFERENCED (name_tree))\n-            {\n-              TREE_ASM_WRITTEN (name_tree) = 1;\n-              fputs (\"\\t.extern\\t\", asm_out_file);\n-              assemble_name (asm_out_file, p->name);\n-              fprintf (asm_out_file, \", %d\\n\", p->size);\n-            }\n-        }\n-    }\n-}\n-\n-static unsigned int sdata_max;\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_asm_file_end ();\n+  else if (TARGET_SCORE3)\n+    return score3_asm_file_end ();\n \n-int\n-score_sdata_max (void)\n-{\n-  return sdata_max;\n+  gcc_unreachable ();\n }\n \n-/* default 0 = NO_REGS  */\n-enum reg_class score_char_to_class[256];\n+#define MASK_ALL_CPU_BITS \\\n+  (MASK_SCORE5 | MASK_SCORE5U | MASK_SCORE7 | MASK_SCORE7D \\\n+   | MASK_SCORE3 | MASK_SCORE3D)\n \n-/* Implement OVERRIDE_OPTIONS macro.  */\n-void\n-score_override_options (void)\n+/* Implement TARGET_HANDLE_OPTION.  */\n+static bool\n+score_handle_option (size_t code, const char *arg, int value ATTRIBUTE_UNUSED)\n {\n-  flag_pic = false;\n-  if (!flag_pic)\n-    sdata_max = g_switch_set ? g_switch_value : DEFAULT_SDATA_MAX;\n-  else\n+  switch (code)\n     {\n-      sdata_max = 0;\n-      if (g_switch_set && (g_switch_value != 0))\n-        warning (0, \"-fPIC and -G are incompatible\");\n-    }\n+    case OPT_mscore7d:\n+      target_flags &= ~(MASK_ALL_CPU_BITS);\n+      target_flags |= MASK_SCORE7 | MASK_SCORE7D;\n+      return true;\n \n-  score_char_to_class['d'] = G32_REGS;\n-  score_char_to_class['e'] = G16_REGS;\n-  score_char_to_class['t'] = T32_REGS;\n+    case OPT_mscore3d:\n+      target_flags &= ~(MASK_ALL_CPU_BITS);\n+      target_flags |= MASK_SCORE3 | MASK_SCORE3D;\n+      return true;\n \n-  score_char_to_class['h'] = HI_REG;\n-  score_char_to_class['l'] = LO_REG;\n-  score_char_to_class['x'] = CE_REGS;\n+    case OPT_march_:\n+      if (strcmp (arg, \"score5\") == 0)\n+        {\n+          target_flags &= ~(MASK_ALL_CPU_BITS);\n+          target_flags |= MASK_SCORE5;\n+          return true;\n+        }\n+      else if (strcmp (arg, \"score5u\") == 0)\n+        {\n+          target_flags &= ~(MASK_ALL_CPU_BITS);\n+          target_flags |= MASK_SCORE5U;\n+          return true;\n+        }\n+      else if (strcmp (arg, \"score7\") == 0)\n+        {\n+          target_flags &= ~(MASK_ALL_CPU_BITS);\n+          target_flags |= MASK_SCORE7;\n+          return true;\n+        }\n+      else if (strcmp (arg, \"score7d\") == 0)\n+        {\n+          target_flags &= ~(MASK_ALL_CPU_BITS);\n+          target_flags |= MASK_SCORE7 | MASK_SCORE7D;\n+          return true;\n+        }\n+      else if (strcmp (arg, \"score3\") == 0)\n+        {\n+          target_flags &= ~(MASK_ALL_CPU_BITS);\n+          target_flags |= MASK_SCORE3;\n+          return true;\n+        }\n+      else if (strcmp (arg, \"score3d\") == 0)\n+        {\n+          target_flags &= ~(MASK_ALL_CPU_BITS);\n+          target_flags |= MASK_SCORE3 | MASK_SCORE3D;\n+          return true;\n+        }\n+      else\n+        return false;\n \n-  score_char_to_class['q'] = CN_REG;\n-  score_char_to_class['y'] = LC_REG;\n-  score_char_to_class['z'] = SC_REG;\n-  score_char_to_class['a'] = SP_REGS;\n+    default:\n+      return true;\n+    }\n+}\n \n-  score_char_to_class['c'] = CR_REGS;\n+/* Implement OVERRIDE_OPTIONS macro.  */\n+void\n+score_override_options (void)\n+{\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_override_options ();\n+  else if (TARGET_SCORE3)\n+    return score3_override_options ();\n \n-  score_char_to_class['b'] = CP1_REGS;\n-  score_char_to_class['f'] = CP2_REGS;\n-  score_char_to_class['i'] = CP3_REGS;\n-  score_char_to_class['j'] = CPA_REGS;\n+  return score7_override_options ();\n }\n \n /* Implement REGNO_REG_CLASS macro.  */\n int\n score_reg_class (int regno)\n {\n-  int c;\n-  gcc_assert (regno >= 0 && regno < FIRST_PSEUDO_REGISTER);\n-\n-  if (regno == FRAME_POINTER_REGNUM\n-      || regno == ARG_POINTER_REGNUM)\n-    return ALL_REGS;\n-\n-  for (c = 0; c < N_REG_CLASSES; c++)\n-    if (TEST_HARD_REG_BIT (reg_class_contents[c], regno))\n-      return c;\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_reg_class (regno);\n+  else if (TARGET_SCORE3)\n+    return score3_reg_class (regno);\n \n-  return NO_REGS;\n+  gcc_unreachable ();\n }\n \n /* Implement PREFERRED_RELOAD_CLASS macro.  */\n enum reg_class\n score_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class class)\n {\n-  if (reg_class_subset_p (G16_REGS, class))\n-    return G16_REGS;\n-  if (reg_class_subset_p (G32_REGS, class))\n-    return G32_REGS;\n-  return class;\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_preferred_reload_class (x, class);\n+  else if (TARGET_SCORE3)\n+    return score3_preferred_reload_class (x, class);\n+\n+  gcc_unreachable ();\n }\n \n /* Implement SECONDARY_INPUT_RELOAD_CLASS\n@@ -570,74 +378,49 @@ score_secondary_reload_class (enum reg_class class,\n                               enum machine_mode mode ATTRIBUTE_UNUSED,\n                               rtx x)\n {\n-  int regno = -1;\n-  if (GET_CODE (x) == REG || GET_CODE(x) == SUBREG)\n-    regno = true_regnum (x);\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_secondary_reload_class (class, mode, x);\n+  else if (TARGET_SCORE3)\n+    return score3_secondary_reload_class (class, mode, x);\n \n-  if (!GR_REG_CLASS_P (class))\n-    return GP_REG_P (regno) ? NO_REGS : G32_REGS;\n-  return NO_REGS;\n+  gcc_unreachable ();\n }\n \n /* Implement CONST_OK_FOR_LETTER_P macro.  */\n-/* imm constraints\n-   I        imm16 << 16\n-   J        uimm5\n-   K        uimm16\n-   L        simm16\n-   M        uimm14\n-   N        simm14  */\n int\n score_const_ok_for_letter_p (HOST_WIDE_INT value, char c)\n {\n-  switch (c)\n-    {\n-    case 'I': return ((value & 0xffff) == 0);\n-    case 'J': return IMM_IN_RANGE (value, 5, 0);\n-    case 'K': return IMM_IN_RANGE (value, 16, 0);\n-    case 'L': return IMM_IN_RANGE (value, 16, 1);\n-    case 'M': return IMM_IN_RANGE (value, 14, 0);\n-    case 'N': return IMM_IN_RANGE (value, 14, 1);\n-    default : return 0;\n-    }\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_const_ok_for_letter_p (value, c);\n+  else if (TARGET_SCORE3)\n+    return score3_const_ok_for_letter_p (value, c);\n+\n+  gcc_unreachable ();\n }\n \n /* Implement EXTRA_CONSTRAINT macro.  */\n-/* Z        symbol_ref  */\n int\n score_extra_constraint (rtx op, char c)\n {\n-  switch (c)\n-    {\n-    case 'Z':\n-      return GET_CODE (op) == SYMBOL_REF;\n-    default:\n-      gcc_unreachable ();\n-    }\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_extra_constraint (op, c);\n+  else if (TARGET_SCORE3)\n+    return score3_extra_constraint (op, c);\n+\n+  gcc_unreachable ();\n }\n \n /* Return truth value on whether or not a given hard register\n    can support a given mode.  */\n int\n score_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n {\n-  int size = GET_MODE_SIZE (mode);\n-  enum mode_class class = GET_MODE_CLASS (mode);\n-\n-  if (class == MODE_CC)\n-    return regno == CC_REGNUM;\n-  else if (regno == FRAME_POINTER_REGNUM\n-           || regno == ARG_POINTER_REGNUM)\n-    return class == MODE_INT;\n-  else if (GP_REG_P (regno))\n-    /* ((regno <= (GP_REG_LAST- HARD_REGNO_NREGS (dummy, mode)) + 1)  */\n-    return !(regno & 1) || (size <= UNITS_PER_WORD);\n-  else if (CE_REG_P (regno))\n-    return (class == MODE_INT\n-            && ((size <= UNITS_PER_WORD)\n-                || (regno == CE_REG_FIRST && size == 2 * UNITS_PER_WORD)));\n-  else\n-    return (class == MODE_INT) && (size <= UNITS_PER_WORD);\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_hard_regno_mode_ok (regno, mode);\n+  else if (TARGET_SCORE3)\n+    return score3_hard_regno_mode_ok (regno, mode);\n+\n+  gcc_unreachable ();\n }\n \n /* Implement INITIAL_ELIMINATION_OFFSET.  FROM is either the frame\n@@ -647,16 +430,12 @@ HOST_WIDE_INT\n score_initial_elimination_offset (int from,\n                                   int to ATTRIBUTE_UNUSED)\n {\n-  struct score_frame_info *f = mda_compute_frame_size (get_frame_size ());\n-  switch (from)\n-    {\n-    case ARG_POINTER_REGNUM:\n-      return f->total_size;\n-    case FRAME_POINTER_REGNUM:\n-      return 0;\n-    default:\n-      gcc_unreachable ();\n-    }\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_initial_elimination_offset (from, to);\n+  else if (TARGET_SCORE3)\n+    return score3_initial_elimination_offset (from, to);\n+\n+  gcc_unreachable ();\n }\n \n /* Argument support functions.  */\n@@ -675,143 +454,89 @@ void\n score_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n                             tree type, int named)\n {\n-  struct score_arg_info info;\n-  classify_arg (cum, mode, type, named, &info);\n-  cum->num_gprs = info.reg_offset + info.reg_words;\n-  if (info.stack_words > 0)\n-    cum->stack_words = info.stack_offset + info.stack_words;\n-  cum->arg_number++;\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_function_arg_advance (cum, mode, type, named);\n+  else if (TARGET_SCORE3)\n+    return score3_function_arg_advance (cum, mode, type, named);\n+\n+  gcc_unreachable ();\n }\n \n /* Implement TARGET_ARG_PARTIAL_BYTES macro.  */\n-static int\n+int\n score_arg_partial_bytes (CUMULATIVE_ARGS *cum,\n                          enum machine_mode mode, tree type, bool named)\n {\n-  struct score_arg_info info;\n-  classify_arg (cum, mode, type, named, &info);\n-  return info.stack_words > 0 ? info.reg_words * UNITS_PER_WORD : 0;\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_arg_partial_bytes (cum, mode, type, named);\n+  else if (TARGET_SCORE3)\n+    return score3_arg_partial_bytes (cum, mode, type, named);\n+\n+  gcc_unreachable ();\n }\n \n /* Implement FUNCTION_ARG macro.  */\n rtx\n score_function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n                     tree type, int named)\n {\n-  struct score_arg_info info;\n-\n-  if (mode == VOIDmode || !named)\n-    return 0;\n-\n-  classify_arg (cum, mode, type, named, &info);\n-\n-  if (info.reg_offset == ARG_REG_NUM)\n-    return 0;\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_function_arg (cum, mode, type, named);\n+  else if (TARGET_SCORE3)\n+    return score3_function_arg (cum, mode, type, named);\n \n-  if (!info.stack_words)\n-    return gen_rtx_REG (mode, ARG_REG_FIRST + info.reg_offset);\n-  else\n-    {\n-      rtx ret = gen_rtx_PARALLEL (mode, rtvec_alloc (info.reg_words));\n-      unsigned int i, part_offset = 0;\n-      for (i = 0; i < info.reg_words; i++)\n-        {\n-          rtx reg;\n-          reg = gen_rtx_REG (SImode, ARG_REG_FIRST + info.reg_offset + i);\n-          XVECEXP (ret, 0, i) = gen_rtx_EXPR_LIST (SImode, reg,\n-                                                   GEN_INT (part_offset));\n-          part_offset += UNITS_PER_WORD;\n-        }\n-      return ret;\n-    }\n+  gcc_unreachable ();\n }\n \n /* Implement FUNCTION_VALUE and LIBCALL_VALUE.  For normal calls,\n    VALTYPE is the return type and MODE is VOIDmode.  For libcalls,\n    VALTYPE is null and MODE is the mode of the return value.  */\n rtx\n-score_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED,\n+score_function_value (tree valtype, tree func ATTRIBUTE_UNUSED,\n                       enum machine_mode mode)\n {\n-  if (valtype)\n-    {\n-      int unsignedp;\n-      mode = TYPE_MODE (valtype);\n-      unsignedp = TYPE_UNSIGNED (valtype);\n-      mode = promote_mode (valtype, mode, &unsignedp, 1);\n-    }\n-  return gen_rtx_REG (mode, RT_REGNUM);\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_function_value (valtype, func, mode);\n+  else if (TARGET_SCORE3)\n+    return score3_function_value (valtype, func, mode);\n+\n+  gcc_unreachable ();\n }\n \n /* Implement INITIALIZE_TRAMPOLINE macro.  */\n void\n score_initialize_trampoline (rtx ADDR, rtx FUNC, rtx CHAIN)\n {\n-#define FFCACHE          \"_flush_cache\"\n-#define CODE_SIZE        (TRAMPOLINE_INSNS * UNITS_PER_WORD)\n-\n-  rtx pfunc, pchain;\n-\n-  pfunc = plus_constant (ADDR, CODE_SIZE);\n-  pchain = plus_constant (ADDR, CODE_SIZE + GET_MODE_SIZE (SImode));\n-\n-  emit_move_insn (gen_rtx_MEM (SImode, pfunc), FUNC);\n-  emit_move_insn (gen_rtx_MEM (SImode, pchain), CHAIN);\n-  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, FFCACHE),\n-                     0, VOIDmode, 2,\n-                     ADDR, Pmode,\n-                     GEN_INT (TRAMPOLINE_SIZE), SImode);\n-#undef FFCACHE\n-#undef CODE_SIZE\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_initialize_trampoline (ADDR, FUNC, CHAIN);\n+  else if (TARGET_SCORE3)\n+    return score3_initialize_trampoline (ADDR, FUNC, CHAIN);\n+\n+  gcc_unreachable ();\n }\n \n /* This function is used to implement REG_MODE_OK_FOR_BASE_P macro.  */\n int\n score_regno_mode_ok_for_base_p (int regno, int strict)\n {\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    {\n-      if (!strict)\n-        return 1;\n-      regno = reg_renumber[regno];\n-    }\n-  if (regno == ARG_POINTER_REGNUM\n-      || regno == FRAME_POINTER_REGNUM)\n-    return 1;\n-  return GP_REG_P (regno);\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_regno_mode_ok_for_base_p (regno, strict);\n+  else if (TARGET_SCORE3)\n+    return score3_regno_mode_ok_for_base_p (regno, strict);\n+\n+  gcc_unreachable ();\n }\n \n /* Implement GO_IF_LEGITIMATE_ADDRESS macro.  */\n int\n score_address_p (enum machine_mode mode, rtx x, int strict)\n {\n-  struct score_address_info addr;\n-\n-  return mda_classify_address (&addr, mode, x, strict);\n-}\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_address_p (mode, x, strict);\n+  else if (TARGET_SCORE3)\n+    return score3_address_p (mode, x, strict);\n \n-/* Copy VALUE to a register and return that register.  If new psuedos\n-   are allowed, copy it into a new register, otherwise use DEST.  */\n-static rtx\n-score_force_temporary (rtx dest, rtx value)\n-{\n-  if (can_create_pseudo_p ())\n-    return force_reg (Pmode, value);\n-  else\n-    {\n-      emit_move_insn (copy_rtx (dest), value);\n-      return dest;\n-    }\n-}\n-\n-/* Return a LO_SUM expression for ADDR.  TEMP is as for score_force_temporary\n-   and is used to load the high part into a register.  */\n-static rtx\n-score_split_symbol (rtx temp, rtx addr)\n-{\n-  rtx high = score_force_temporary (temp,\n-                                    gen_rtx_HIGH (Pmode, copy_rtx (addr)));\n-  return gen_rtx_LO_SUM (Pmode, high, addr);\n+  gcc_unreachable ();\n }\n \n /* This function is used to implement LEGITIMIZE_ADDRESS.  If *XLOC can\n@@ -820,25 +545,12 @@ score_split_symbol (rtx temp, rtx addr)\n int\n score_legitimize_address (rtx *xloc)\n {\n-  enum score_symbol_type symbol_type;\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_legitimize_address (xloc);\n+  else if (TARGET_SCORE3)\n+    return score3_legitimize_address (xloc);\n \n-  if (mda_symbolic_constant_p (*xloc, &symbol_type)\n-      && symbol_type == SYMBOL_GENERAL)\n-    {\n-      *xloc = score_split_symbol (0, *xloc);\n-      return 1;\n-    }\n-\n-  if (GET_CODE (*xloc) == PLUS\n-      && GET_CODE (XEXP (*xloc, 1)) == CONST_INT)\n-    {\n-      rtx reg = XEXP (*xloc, 0);\n-      if (!mda_valid_base_register_p (reg, 0))\n-        reg = copy_to_mode_reg (Pmode, reg);\n-      *xloc = score_add_offset (NULL, reg, INTVAL (XEXP (*xloc, 1)));\n-      return 1;\n-    }\n-  return 0;\n+  gcc_unreachable ();\n }\n \n /* Return a number assessing the cost of moving a register in class\n@@ -847,503 +559,633 @@ int\n score_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n                           enum reg_class from, enum reg_class to)\n {\n-  if (GR_REG_CLASS_P (from))\n-    {\n-      if (GR_REG_CLASS_P (to))\n-        return 2;\n-      else if (SP_REG_CLASS_P (to))\n-        return 4;\n-      else if (CP_REG_CLASS_P (to))\n-        return 5;\n-      else if (CE_REG_CLASS_P (to))\n-        return 6;\n-    }\n-  if (GR_REG_CLASS_P (to))\n-    {\n-      if (GR_REG_CLASS_P (from))\n-        return 2;\n-      else if (SP_REG_CLASS_P (from))\n-        return 4;\n-      else if (CP_REG_CLASS_P (from))\n-        return 5;\n-      else if (CE_REG_CLASS_P (from))\n-        return 6;\n-    }\n-  return 12;\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_register_move_cost (mode, from, to);\n+  else if (TARGET_SCORE3)\n+    return score3_register_move_cost (mode, from, to);\n+\n+  gcc_unreachable ();\n }\n \n-/* Return the number of instructions needed to load a symbol of the\n-   given type into a register.  */\n-static int\n-score_symbol_insns (enum score_symbol_type type)\n+/* Implement TARGET_RTX_COSTS macro.  */\n+bool\n+score_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n-  switch (type)\n-    {\n-    case SYMBOL_GENERAL:\n-      return 2;\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_rtx_costs (x, code, outer_code, total);\n+  else if (TARGET_SCORE3)\n+    return score3_rtx_costs (x, code, outer_code, total);\n \n-    case SYMBOL_SMALL_DATA:\n-      return 1;\n-    }\n+  gcc_unreachable ();\n+}\n+\n+/* Implement TARGET_ADDRESS_COST macro.  */\n+int\n+score_address_cost (rtx addr)\n+{\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_address_cost (addr);\n+  else if (TARGET_SCORE3)\n+    return score3_address_cost (addr);\n \n   gcc_unreachable ();\n }\n \n-/* Return the number of instructions needed to load or store a value\n-   of mode MODE at X.  Return 0 if X isn't valid for MODE.  */\n-static int\n-score_address_insns (rtx x, enum machine_mode mode)\n+/* Implement ASM_OUTPUT_EXTERNAL macro.  */\n+int\n+score_output_external (FILE *file ATTRIBUTE_UNUSED,\n+                       tree decl, const char *name)\n {\n-  struct score_address_info addr;\n-  int factor;\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_output_external (file, decl, name);\n+  else if (TARGET_SCORE3)\n+    return score3_output_external (file, decl, name);\n \n-  if (mode == BLKmode)\n-    factor = 1;\n-  else\n-    factor = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-\n-  if (mda_classify_address (&addr, mode, x, false))\n-    switch (addr.type)\n-      {\n-      case ADD_REG:\n-      case ADD_CONST_INT:\n-        return factor;\n-\n-      case ADD_SYMBOLIC:\n-        return factor * score_symbol_insns (addr.symbol_type);\n-      }\n-  return 0;\n+  gcc_unreachable ();\n }\n \n-/* Implement TARGET_RTX_COSTS macro.  */\n-static bool\n-score_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n-                 int *total)\n+/* Implement RETURN_ADDR_RTX.  Note, we do not support moving\n+   back to a previous frame.  */\n+rtx\n+score_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_return_addr (count, frame);\n+  else if (TARGET_SCORE3)\n+    return score3_return_addr (count, frame);\n \n-  switch (code)\n-    {\n-    case CONST_INT:\n-      if (outer_code == SET)\n-        {\n-          if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n-              || CONST_OK_FOR_LETTER_P (INTVAL (x), 'L'))\n-            *total = COSTS_N_INSNS (1);\n-          else\n-            *total = COSTS_N_INSNS (2);\n-        }\n-      else if (outer_code == PLUS || outer_code == MINUS)\n-        {\n-          if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'N'))\n-            *total = 0;\n-          else if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n-                   || CONST_OK_FOR_LETTER_P (INTVAL (x), 'L'))\n-            *total = 1;\n-          else\n-            *total = COSTS_N_INSNS (2);\n-        }\n-      else if (outer_code == AND || outer_code == IOR)\n-        {\n-          if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'M'))\n-            *total = 0;\n-          else if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n-                   || CONST_OK_FOR_LETTER_P (INTVAL (x), 'K'))\n-            *total = 1;\n-          else\n-            *total = COSTS_N_INSNS (2);\n-        }\n-      else\n-        {\n-          *total = 0;\n-        }\n-      return true;\n+  gcc_unreachable ();\n+}\n \n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-    case CONST_DOUBLE:\n-      *total = COSTS_N_INSNS (2);\n-      return true;\n+/* Implement PRINT_OPERAND macro.  */\n+void\n+score_print_operand (FILE *file, rtx op, int c)\n+{\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_print_operand (file, op, c);\n+  else if (TARGET_SCORE3)\n+    return score3_print_operand (file, op, c);\n \n-    case MEM:\n-      {\n-        /* If the address is legitimate, return the number of\n-           instructions it needs, otherwise use the default handling.  */\n-        int n = score_address_insns (XEXP (x, 0), GET_MODE (x));\n-        if (n > 0)\n-          {\n-            *total = COSTS_N_INSNS (n + 1);\n-            return true;\n-          }\n-        return false;\n-      }\n+  gcc_unreachable ();\n+}\n \n-    case FFS:\n-      *total = COSTS_N_INSNS (6);\n-      return true;\n+/* Implement PRINT_OPERAND_ADDRESS macro.  */\n+void\n+score_print_operand_address (FILE *file, rtx x)\n+{\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_print_operand_address (file, x);\n+  else if (TARGET_SCORE3)\n+    return score3_print_operand_address (file, x);\n \n-    case NOT:\n-      *total = COSTS_N_INSNS (1);\n-      return true;\n+  gcc_unreachable ();\n+}\n \n-    case AND:\n-    case IOR:\n-    case XOR:\n-      if (mode == DImode)\n-        {\n-          *total = COSTS_N_INSNS (2);\n-          return true;\n-        }\n-      return false;\n+/* Implement SELECT_CC_MODE macro.  */\n+enum machine_mode\n+score_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n+{\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_select_cc_mode (op, x, y);\n+  else if (TARGET_SCORE3)\n+    return score3_select_cc_mode (op, x, y);\n \n-    case ASHIFT:\n-    case ASHIFTRT:\n-    case LSHIFTRT:\n-      if (mode == DImode)\n-        {\n-          *total = COSTS_N_INSNS ((GET_CODE (XEXP (x, 1)) == CONST_INT)\n-                                  ? 4 : 12);\n-          return true;\n-        }\n-      return false;\n+  gcc_unreachable ();\n+}\n \n-    case ABS:\n-      *total = COSTS_N_INSNS (4);\n-      return true;\n+/* Return true if X is a symbolic constant that can be calculated in\n+   the same way as a bare symbol.  If it is, store the type of the\n+   symbol in *SYMBOL_TYPE.  */\n+int\n+score_symbolic_constant_p (rtx x, enum score_symbol_type *symbol_type)\n+{\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_symbolic_constant_p (x, symbol_type);\n+  else if (TARGET_SCORE3)\n+    return score3_symbolic_constant_p (x, symbol_type);\n \n-    case PLUS:\n-    case MINUS:\n-      if (mode == DImode)\n-        {\n-          *total = COSTS_N_INSNS (4);\n-          return true;\n-        }\n-      *total = COSTS_N_INSNS (1);\n-      return true;\n+  gcc_unreachable ();\n+}\n \n-    case NEG:\n-      if (mode == DImode)\n-        {\n-          *total = COSTS_N_INSNS (4);\n-          return true;\n-        }\n-      return false;\n+/* Generate the prologue instructions for entry into a S+core function.  */\n+void\n+score_prologue (void)\n+{\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_prologue ();\n+  else if (TARGET_SCORE3)\n+    return score3_prologue ();\n \n-    case MULT:\n-      *total = optimize_size ? COSTS_N_INSNS (2) : COSTS_N_INSNS (12);\n-      return true;\n+  gcc_unreachable ();\n+}\n \n-    case DIV:\n-    case MOD:\n-    case UDIV:\n-    case UMOD:\n-      *total = optimize_size ? COSTS_N_INSNS (2) : COSTS_N_INSNS (33);\n-      return true;\n+/* Generate the epilogue instructions in a S+core function.  */\n+void\n+score_epilogue (int sibcall_p)\n+{\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_epilogue (sibcall_p);\n+  else if (TARGET_SCORE3)\n+    return score3_epilogue (sibcall_p);\n \n-    case SIGN_EXTEND:\n-    case ZERO_EXTEND:\n-      switch (GET_MODE (XEXP (x, 0)))\n-        {\n-        case QImode:\n-        case HImode:\n-          if (GET_CODE (XEXP (x, 0)) == MEM)\n-            {\n-              *total = COSTS_N_INSNS (2);\n-\n-              if (!TARGET_LITTLE_ENDIAN &&\n-                  side_effects_p (XEXP (XEXP (x, 0), 0)))\n-                *total = 100;\n-            }\n-          else\n-            *total = COSTS_N_INSNS (1);\n-          break;\n-\n-        default:\n-          *total = COSTS_N_INSNS (1);\n-          break;\n-        }\n-      return true;\n+  gcc_unreachable ();\n+}\n \n-    default:\n-      return false;\n-    }\n+void\n+score_gen_cmp (enum machine_mode mode)\n+{\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_gen_cmp (mode);\n+  else if (TARGET_SCORE3)\n+    return score3_gen_cmp (mode);\n+\n+  gcc_unreachable ();\n }\n \n-/* Implement TARGET_ADDRESS_COST macro.  */\n-int\n-score_address_cost (rtx addr)\n+/* Call and sibcall pattern all need call this function.  */\n+void\n+score_call (rtx *ops, bool sib)\n {\n-  return score_address_insns (addr, SImode);\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_call (ops, sib);\n+  else if (TARGET_SCORE3)\n+    return score3_call (ops, sib);\n+\n+  gcc_unreachable ();\n }\n \n-/* Implement ASM_OUTPUT_EXTERNAL macro.  */\n-int\n-score_output_external (FILE *file ATTRIBUTE_UNUSED,\n-                       tree decl, const char *name)\n+/* Call value and sibcall value pattern all need call this function.  */\n+void\n+score_call_value (rtx *ops, bool sib)\n {\n-  register struct extern_list *p;\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_call_value (ops, sib);\n+  else if (TARGET_SCORE3)\n+    return score3_call_value (ops, sib);\n \n-  if (th_in_small_data_p (decl))\n-    {\n-      p = (struct extern_list *) ggc_alloc (sizeof (struct extern_list));\n-      p->next = extern_head;\n-      p->name = name;\n-      p->size = int_size_in_bytes (TREE_TYPE (decl));\n-      extern_head = p;\n-    }\n-  return 0;\n+  gcc_unreachable ();\n }\n \n-/* Output format asm string.  */\n void\n-score_declare_object (FILE *stream, const char *name,\n-                      const char *directive, const char *fmt, ...)\n+score_movsicc (rtx *ops)\n {\n-  va_list ap;\n-  fputs (directive, stream);\n-  assemble_name (stream, name);\n-  va_start (ap, fmt);\n-  vfprintf (stream, fmt, ap);\n-  va_end (ap);\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_movsicc (ops);\n+  else if (TARGET_SCORE3)\n+    return score3_movsicc (ops);\n+\n+  gcc_unreachable ();\n }\n \n-/* Implement RETURN_ADDR_RTX.  Note, we do not support moving\n-   back to a previous frame.  */\n-rtx\n-score_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)\n+/* Machine Split  */\n+void\n+score_movdi (rtx *ops)\n {\n-  if (count != 0)\n-    return const0_rtx;\n-  return get_hard_reg_initial_val (Pmode, RA_REGNUM);\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_movdi (ops);\n+  else if (TARGET_SCORE3)\n+    return score3_movdi (ops);\n+\n+  gcc_unreachable ();\n }\n \n-/* Implement PRINT_OPERAND macro.  */\n-/* Score-specific operand codes:\n-   '['        print .set nor1 directive\n-   ']'        print .set r1 directive\n-   'U'        print hi part of a CONST_INT rtx\n-   'E'        print log2(v)\n-   'F'        print log2(~v)\n-   'D'        print SFmode const double\n-   'S'        selectively print \"!\" if operand is 15bit instruction accessible\n-   'V'        print \"v!\" if operand is 15bit instruction accessible, or \"lfh!\"\n-   'L'        low  part of DImode reg operand\n-   'H'        high part of DImode reg operand\n-   'C'        print part of opcode for a branch condition.  */\n void\n-score_print_operand (FILE *file, rtx op, int c)\n+score_zero_extract_andi (rtx *ops)\n+{\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_zero_extract_andi (ops);\n+  else if (TARGET_SCORE3)\n+    return score3_zero_extract_andi (ops);\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Output asm insn for move.  */\n+const char *\n+score_move (rtx *ops)\n+{\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_move (ops);\n+  else if (TARGET_SCORE3)\n+    return score3_move (ops);\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Output asm insn for load.  */\n+const char *\n+score_linsn (rtx *ops, enum score_mem_unit unit, bool sign)\n+{\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_linsn (ops, unit, sign);\n+  else if (TARGET_SCORE3)\n+    return score3_linsn (ops, unit, sign);\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Output asm insn for store.  */\n+const char *\n+score_sinsn (rtx *ops, enum score_mem_unit unit)\n+{\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_sinsn (ops, unit);\n+  else if (TARGET_SCORE3)\n+    return score3_sinsn (ops, unit);\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Output asm insn for load immediate.  */\n+const char *\n+score_limm (rtx *ops)\n+{\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_limm (ops);\n+  else if (TARGET_SCORE3)\n+    return score3_limm (ops);\n+\n+  gcc_unreachable ();\n+}\n+\n+\n+/* Generate add insn.  */\n+const char *\n+score_select_add_imm (rtx *ops, bool set_cc)\n {\n-  enum rtx_code code = -1;\n-  if (!PRINT_OPERAND_PUNCT_VALID_P (c))\n-    code = GET_CODE (op);\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_select_add_imm (ops, set_cc);\n+  else if (TARGET_SCORE3)\n+    return score3_select_add_imm (ops, set_cc);\n \n-  if (c == '[')\n+  gcc_unreachable ();\n+}\n+\n+/* Output arith insn.  */\n+const char *\n+score_select (rtx *ops, const char *inst_pre,\n+            bool commu, const char *letter, bool set_cc)\n+{\n+  if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n+    return score7_select (ops, inst_pre, commu, letter, set_cc);\n+  else if (TARGET_SCORE3)\n+    return score3_select (ops, inst_pre, commu, letter, set_cc);\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Output switch case insn, only supported in score3.  */\n+const char *\n+score_output_casesi (rtx *operands)\n+{\n+  if (TARGET_SCORE3)\n+    return score3_output_casesi (operands);\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Output rpush insn, only supported in score3.  */\n+const char *\n+score_rpush (rtx *operands)\n+{\n+  if (TARGET_SCORE3)\n+    return score3_rpush (operands);\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Output rpop insn, only supported in score3.  */\n+const char *\n+score_rpop (rtx *operands)\n+{\n+  if (TARGET_SCORE3)\n+    return score3_rpop (operands);\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Emit lcb/lce insns.  */\n+bool\n+score_unaligned_load (rtx *ops)\n+{\n+  rtx dst = ops[0];\n+  rtx src = ops[1];\n+  rtx len = ops[2];\n+  rtx off = ops[3];\n+  rtx addr_reg;\n+\n+  if (INTVAL (len) != BITS_PER_WORD\n+      || (INTVAL (off) % BITS_PER_UNIT) != 0)\n+    return false;\n+\n+  gcc_assert (GET_MODE_SIZE (GET_MODE (dst)) == GET_MODE_SIZE (SImode));\n+\n+  addr_reg = copy_addr_to_reg (XEXP (src, 0));\n+  emit_insn (gen_move_lcb (addr_reg, addr_reg));\n+  emit_insn (gen_move_lce (addr_reg, addr_reg, dst));\n+\n+  return true;\n+}\n+\n+/* Emit scb/sce insns.  */\n+bool\n+score_unaligned_store (rtx *ops)\n+{\n+  rtx dst = ops[0];\n+  rtx len = ops[1];\n+  rtx off = ops[2];\n+  rtx src = ops[3];\n+  rtx addr_reg;\n+\n+  if (INTVAL(len) != BITS_PER_WORD\n+      || (INTVAL(off) % BITS_PER_UNIT) != 0)\n+    return false;\n+\n+  gcc_assert (GET_MODE_SIZE (GET_MODE (src)) == GET_MODE_SIZE (SImode));\n+\n+  addr_reg = copy_addr_to_reg (XEXP (dst, 0));\n+  emit_insn (gen_move_scb (addr_reg, addr_reg, src));\n+  emit_insn (gen_move_sce (addr_reg, addr_reg));\n+\n+  return true;\n+}\n+\n+/* If length is short, generate move insns straight.  */\n+static void\n+score_block_move_straight (rtx dst, rtx src, HOST_WIDE_INT length)\n+{\n+  HOST_WIDE_INT leftover;\n+  int i, reg_count;\n+  rtx *regs;\n+\n+  leftover = length % UNITS_PER_WORD;\n+  length -= leftover;\n+  reg_count = length / UNITS_PER_WORD;\n+\n+  regs = alloca (sizeof (rtx) * reg_count);\n+  for (i = 0; i < reg_count; i++)\n+    regs[i] = gen_reg_rtx (SImode);\n+\n+  /* Load from src to regs.  */\n+  if (MEM_ALIGN (src) >= BITS_PER_WORD)\n     {\n-      fprintf (file, \".set r1\\n\");\n+      HOST_WIDE_INT offset = 0;\n+      for (i = 0; i < reg_count; offset += UNITS_PER_WORD, i++)\n+        emit_move_insn (regs[i], adjust_address (src, SImode, offset));\n     }\n-  else if (c == ']')\n+  else if (reg_count >= 1)\n     {\n-      fprintf (file, \"\\n\\t.set nor1\");\n+      rtx src_reg = copy_addr_to_reg (XEXP (src, 0));\n+\n+      emit_insn (gen_move_lcb (src_reg, src_reg));\n+      for (i = 0; i < (reg_count - 1); i++)\n+        emit_insn (gen_move_lcw (src_reg, src_reg, regs[i]));\n+      emit_insn (gen_move_lce (src_reg, src_reg, regs[i]));\n     }\n-  else if (c == 'U')\n+\n+  /* Store regs to dest.  */\n+  if (MEM_ALIGN (dst) >= BITS_PER_WORD)\n     {\n-      gcc_assert (code == CONST_INT);\n-      fprintf (file, HOST_WIDE_INT_PRINT_HEX,\n-               (INTVAL (op) >> 16) & 0xffff);\n+      HOST_WIDE_INT offset = 0;\n+      for (i = 0; i < reg_count; offset += UNITS_PER_WORD, i++)\n+        emit_move_insn (adjust_address (dst, SImode, offset), regs[i]);\n     }\n-  else if (c == 'D')\n+  else if (reg_count >= 1)\n     {\n-      if (GET_CODE (op) == CONST_DOUBLE)\n-        {\n-          rtx temp = gen_lowpart (SImode, op);\n-          gcc_assert (GET_MODE (op) == SFmode);\n-          fprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (temp) & 0xffffffff);\n-        }\n-      else\n-        output_addr_const (file, op);\n+      rtx dst_reg = copy_addr_to_reg (XEXP (dst, 0));\n+\n+      emit_insn (gen_move_scb (dst_reg, dst_reg, regs[0]));\n+      for (i = 1; i < reg_count; i++)\n+        emit_insn (gen_move_scw (dst_reg, dst_reg, regs[i]));\n+      emit_insn (gen_move_sce (dst_reg, dst_reg));\n     }\n-  else if (c == 'S')\n+\n+  /* Mop up any left-over bytes.  */\n+  if (leftover > 0)\n     {\n-      gcc_assert (code == REG);\n-      if (G16_REG_P (REGNO (op)))\n-        fprintf (file, \"!\");\n+      src = adjust_address (src, BLKmode, length);\n+      dst = adjust_address (dst, BLKmode, length);\n+      move_by_pieces (dst, src, leftover,\n+                      MIN (MEM_ALIGN (src), MEM_ALIGN (dst)), 0);\n     }\n-  else if (c == 'V')\n+}\n+\n+/* Generate loop head when dst or src is unaligned.  */\n+static void\n+score_block_move_loop_head (rtx dst_reg, HOST_WIDE_INT dst_align,\n+                            rtx src_reg, HOST_WIDE_INT src_align,\n+                            HOST_WIDE_INT length)\n+{\n+  bool src_unaligned = (src_align < BITS_PER_WORD);\n+  bool dst_unaligned = (dst_align < BITS_PER_WORD);\n+\n+  rtx temp = gen_reg_rtx (SImode);\n+\n+  gcc_assert (length == UNITS_PER_WORD);\n+\n+  if (src_unaligned)\n     {\n-      gcc_assert (code == REG);\n-      fprintf (file, G16_REG_P (REGNO (op)) ? \"v!\" : \"lfh!\");\n+      emit_insn (gen_move_lcb (src_reg, src_reg));\n+      emit_insn (gen_move_lcw (src_reg, src_reg, temp));\n     }\n-  else if (c == 'C')\n-    {\n-      enum machine_mode mode = GET_MODE (XEXP (op, 0));\n+  else\n+    emit_insn (gen_move_lw_a (src_reg,\n+                              src_reg, gen_int_mode (4, SImode), temp));\n \n-      switch (code)\n-        {\n-        case EQ: fputs (\"eq\", file); break;\n-        case NE: fputs (\"ne\", file); break;\n-        case GT: fputs (\"gt\", file); break;\n-        case GE: fputs (mode != CCmode ? \"pl\" : \"ge\", file); break;\n-        case LT: fputs (mode != CCmode ? \"mi\" : \"lt\", file); break;\n-        case LE: fputs (\"le\", file); break;\n-        case GTU: fputs (\"gtu\", file); break;\n-        case GEU: fputs (\"cs\", file); break;\n-        case LTU: fputs (\"cc\", file); break;\n-        case LEU: fputs (\"leu\", file); break;\n-        default:\n-          output_operand_lossage (\"invalid operand for code: '%c'\", code);\n-        }\n-    }\n-  else if (c == 'E')\n-    {\n-      unsigned HOST_WIDE_INT i;\n-      unsigned HOST_WIDE_INT pow2mask = 1;\n-      unsigned HOST_WIDE_INT val;\n+  if (dst_unaligned)\n+    emit_insn (gen_move_scb (dst_reg, dst_reg, temp));\n+  else\n+    emit_insn (gen_move_sw_a (dst_reg,\n+                              dst_reg, gen_int_mode (4, SImode), temp));\n+}\n \n-      val = INTVAL (op);\n-      for (i = 0; i < 32; i++)\n-        {\n-          if (val == pow2mask)\n-            break;\n-          pow2mask <<= 1;\n-        }\n-      gcc_assert (i < 32);\n-      fprintf (file, HOST_WIDE_INT_PRINT_HEX, i);\n+/* Generate loop body, copy length bytes per iteration.  */\n+static void\n+score_block_move_loop_body (rtx dst_reg, HOST_WIDE_INT dst_align,\n+                            rtx src_reg, HOST_WIDE_INT src_align,\n+                            HOST_WIDE_INT length)\n+{\n+  int reg_count = length / UNITS_PER_WORD;\n+  rtx *regs = alloca (sizeof (rtx) * reg_count);\n+  int i;\n+  bool src_unaligned = (src_align < BITS_PER_WORD);\n+  bool dst_unaligned = (dst_align < BITS_PER_WORD);\n+\n+  for (i = 0; i < reg_count; i++)\n+    regs[i] = gen_reg_rtx (SImode);\n+\n+  if (src_unaligned)\n+    {\n+      for (i = 0; i < reg_count; i++)\n+        emit_insn (gen_move_lcw (src_reg, src_reg, regs[i]));\n     }\n-  else if (c == 'F')\n+  else\n     {\n-      unsigned HOST_WIDE_INT i;\n-      unsigned HOST_WIDE_INT pow2mask = 1;\n-      unsigned HOST_WIDE_INT val;\n-\n-      val = ~INTVAL (op);\n-      for (i = 0; i < 32; i++)\n-        {\n-          if (val == pow2mask)\n-            break;\n-          pow2mask <<= 1;\n-        }\n-      gcc_assert (i < 32);\n-      fprintf (file, HOST_WIDE_INT_PRINT_HEX, i);\n+      for (i = 0; i < reg_count; i++)\n+        emit_insn (gen_move_lw_a (src_reg,\n+                                  src_reg, gen_int_mode (4, SImode), regs[i]));\n     }\n-  else if (code == REG)\n+\n+  if (dst_unaligned)\n     {\n-      int regnum = REGNO (op);\n-      if ((c == 'H' && !WORDS_BIG_ENDIAN)\n-          || (c == 'L' && WORDS_BIG_ENDIAN))\n-        regnum ++;\n-      fprintf (file, \"%s\", reg_names[regnum]);\n+      for (i = 0; i < reg_count; i++)\n+        emit_insn (gen_move_scw (dst_reg, dst_reg, regs[i]));\n     }\n   else\n     {\n-      switch (code)\n-        {\n-        case MEM:\n-          score_print_operand_address (file, op);\n-          break;\n-        default:\n-          output_addr_const (file, op);\n-        }\n+      for (i = 0; i < reg_count; i++)\n+        emit_insn (gen_move_sw_a (dst_reg,\n+                                  dst_reg, gen_int_mode (4, SImode), regs[i]));\n     }\n }\n \n-/* Implement PRINT_OPERAND_ADDRESS macro.  */\n-void\n-score_print_operand_address (FILE *file, rtx x)\n+/* Generate loop foot, copy the leftover bytes.  */\n+static void\n+score_block_move_loop_foot (rtx dst_reg, HOST_WIDE_INT dst_align,\n+                            rtx src_reg, HOST_WIDE_INT src_align,\n+                            HOST_WIDE_INT length)\n {\n-  struct score_address_info addr;\n-  enum rtx_code code = GET_CODE (x);\n-  enum machine_mode mode = GET_MODE (x);\n+  bool src_unaligned = (src_align < BITS_PER_WORD);\n+  bool dst_unaligned = (dst_align < BITS_PER_WORD);\n+\n+  HOST_WIDE_INT leftover;\n \n-  if (code == MEM)\n-    x = XEXP (x, 0);\n+  leftover = length % UNITS_PER_WORD;\n+  length -= leftover;\n \n-  if (mda_classify_address (&addr, mode, x, true))\n+  if (length > 0)\n+    score_block_move_loop_body (dst_reg, dst_align,\n+                              src_reg, src_align, length);\n+\n+  if (dst_unaligned)\n+    emit_insn (gen_move_sce (dst_reg, dst_reg));\n+\n+  if (leftover > 0)\n     {\n-      switch (addr.type)\n+      HOST_WIDE_INT src_adj = src_unaligned ? -4 : 0;\n+      HOST_WIDE_INT dst_adj = dst_unaligned ? -4 : 0;\n+      rtx temp;\n+\n+      gcc_assert (leftover < UNITS_PER_WORD);\n+\n+      if (leftover >= UNITS_PER_WORD / 2\n+          && src_align >= BITS_PER_WORD / 2\n+          && dst_align >= BITS_PER_WORD / 2)\n+        {\n+          temp = gen_reg_rtx (HImode);\n+          emit_insn (gen_move_lhu_b (src_reg, src_reg,\n+                                     gen_int_mode (src_adj, SImode), temp));\n+          emit_insn (gen_move_sh_b (dst_reg, dst_reg,\n+                                    gen_int_mode (dst_adj, SImode), temp));\n+          leftover -= UNITS_PER_WORD / 2;\n+          src_adj = UNITS_PER_WORD / 2;\n+          dst_adj = UNITS_PER_WORD / 2;\n+        }\n+\n+      while (leftover > 0)\n         {\n-        case ADD_REG:\n-          {\n-            switch (addr.code)\n-              {\n-              case PRE_DEC:\n-                fprintf (file, \"[%s,-%ld]+\", reg_names[REGNO (addr.reg)],\n-                         INTVAL (addr.offset));\n-                break;\n-              case POST_DEC:\n-                fprintf (file, \"[%s]+,-%ld\", reg_names[REGNO (addr.reg)],\n-                         INTVAL (addr.offset));\n-                break;\n-              case PRE_INC:\n-                fprintf (file, \"[%s, %ld]+\", reg_names[REGNO (addr.reg)],\n-                         INTVAL (addr.offset));\n-                break;\n-              case POST_INC:\n-                fprintf (file, \"[%s]+, %ld\", reg_names[REGNO (addr.reg)],\n-                         INTVAL (addr.offset));\n-                break;\n-              default:\n-                if (INTVAL(addr.offset) == 0)\n-                  fprintf(file, \"[%s]\", reg_names[REGNO (addr.reg)]);\n-                else \n-                  fprintf(file, \"[%s, %ld]\", reg_names[REGNO (addr.reg)], \n-                          INTVAL(addr.offset));\n-                break;\n-              }\n-          }\n-          return;\n-        case ADD_CONST_INT:\n-        case ADD_SYMBOLIC:\n-          output_addr_const (file, x);\n-          return;\n+          temp = gen_reg_rtx (QImode);\n+          emit_insn (gen_move_lbu_b (src_reg, src_reg,\n+                                     gen_int_mode (src_adj, SImode), temp));\n+          emit_insn (gen_move_sb_b (dst_reg, dst_reg,\n+                                    gen_int_mode (dst_adj, SImode), temp));\n+          leftover--;\n+          src_adj = 1;\n+          dst_adj = 1;\n         }\n     }\n-  print_rtl (stderr, x);\n-  gcc_unreachable ();\n }\n \n-/* Implement SELECT_CC_MODE macro.  */\n-enum machine_mode\n-score_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n+#define MIN_MOVE_REGS 3\n+#define MIN_MOVE_BYTES (MIN_MOVE_REGS * UNITS_PER_WORD)\n+#define MAX_MOVE_REGS 4\n+#define MAX_MOVE_BYTES (MAX_MOVE_REGS * UNITS_PER_WORD)\n+\n+/* The length is large, generate a loop if necessary.\n+   The loop is consisted by loop head/body/foot.  */\n+static void\n+score_block_move_loop (rtx dst, rtx src, HOST_WIDE_INT length)\n {\n-  if ((op == EQ || op == NE || op == LT || op == GE)\n-      && y == const0_rtx\n-      && GET_MODE (x) == SImode)\n+  HOST_WIDE_INT src_align = MEM_ALIGN (src);\n+  HOST_WIDE_INT dst_align = MEM_ALIGN (dst);\n+  HOST_WIDE_INT loop_mov_bytes;\n+  HOST_WIDE_INT iteration = 0;\n+  HOST_WIDE_INT head_length = 0, leftover;\n+  rtx label, src_reg, dst_reg, final_dst;\n+\n+  bool gen_loop_head = (src_align < BITS_PER_WORD\n+                        || dst_align < BITS_PER_WORD);\n+\n+  if (gen_loop_head)\n+    head_length += UNITS_PER_WORD;\n+\n+  for (loop_mov_bytes = MAX_MOVE_BYTES;\n+       loop_mov_bytes >= MIN_MOVE_BYTES;\n+       loop_mov_bytes -= UNITS_PER_WORD)\n     {\n-      switch (GET_CODE (x))\n-        {\n-        case PLUS:\n-        case MINUS:\n-        case NEG:\n-        case AND:\n-        case IOR:\n-        case XOR:\n-        case NOT:\n-        case ASHIFT:\n-        case LSHIFTRT:\n-        case ASHIFTRT:\n-          return CC_NZmode;\n-\n-        case SIGN_EXTEND:\n-        case ZERO_EXTEND:\n-        case ROTATE:\n-        case ROTATERT:\n-          return (op == LT || op == GE) ? CC_Nmode : CCmode;\n-\n-        default:\n-          return CCmode;\n-        }\n+      iteration = (length - head_length) / loop_mov_bytes;\n+      if (iteration > 1)\n+        break;\n     }\n-\n-  if ((op == EQ || op == NE)\n-      && (GET_CODE (y) == NEG)\n-      && register_operand (XEXP (y, 0), SImode)\n-      && register_operand (x, SImode))\n+  if (iteration <= 1)\n     {\n-      return CC_NZmode;\n+      score_block_move_straight (dst, src, length);\n+      return;\n     }\n \n-  return CCmode;\n+  leftover = (length - head_length) % loop_mov_bytes;\n+  length -= leftover;\n+\n+  src_reg = copy_addr_to_reg (XEXP (src, 0));\n+  dst_reg = copy_addr_to_reg (XEXP (dst, 0));\n+  final_dst = expand_simple_binop (Pmode, PLUS, dst_reg, GEN_INT (length),\n+                                   0, 0, OPTAB_WIDEN);\n+\n+  if (gen_loop_head)\n+    score_block_move_loop_head (dst_reg, dst_align,\n+                              src_reg, src_align, head_length);\n+\n+  label = gen_label_rtx ();\n+  emit_label (label);\n+\n+  score_block_move_loop_body (dst_reg, dst_align,\n+                            src_reg, src_align, loop_mov_bytes);\n+\n+  emit_insn (gen_cmpsi (dst_reg, final_dst));\n+  emit_jump_insn (gen_bne (label));\n+\n+  score_block_move_loop_foot (dst_reg, dst_align,\n+                            src_reg, src_align, leftover);\n+}\n+\n+/* Generate block move, for misc.md: \"movmemsi\".  */\n+bool\n+score_block_move (rtx *ops)\n+{\n+  rtx dst = ops[0];\n+  rtx src = ops[1];\n+  rtx length = ops[2];\n+\n+  if (TARGET_LITTLE_ENDIAN\n+      && (MEM_ALIGN (src) < BITS_PER_WORD || MEM_ALIGN (dst) < BITS_PER_WORD)\n+      && INTVAL (length) >= UNITS_PER_WORD)\n+    return false;\n+\n+  if (GET_CODE (length) == CONST_INT)\n+    {\n+      if (INTVAL (length) <= 2 * MAX_MOVE_BYTES)\n+        {\n+          score_block_move_straight (dst, src, INTVAL (length));\n+          return true;\n+        }\n+      else if (optimize &&\n+               !(flag_unroll_loops || flag_unroll_all_loops))\n+        {\n+          score_block_move_loop (dst, src, INTVAL (length));\n+          return true;\n+        }\n+    }\n+  return false;\n }\n \n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "8a1efb6f4f571627dd1a825b03464efaa3f6e0a7", "filename": "gcc/config/score/score.h", "status": "modified", "additions": 191, "deletions": 66, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.h?ref=254f522229578af1af093b2e4b6f1a0cc400d216", "patch": "@@ -19,30 +19,53 @@\n    <http://www.gnu.org/licenses/>.  */\n \n #include \"score-conv.h\"\n-#include \"score-version.h\"\n-\n-/* Define the information needed to generate branch insns.  This is\n-   stored from the compare operation.  */\n-extern GTY(()) rtx cmp_op0;\n-extern GTY(()) rtx cmp_op1;\n \n /* Controlling the Compilation Driver.  */\n #undef SWITCH_TAKES_ARG\n #define SWITCH_TAKES_ARG(CHAR) \\\n   (DEFAULT_SWITCH_TAKES_ARG (CHAR) || (CHAR) == 'G')\n \n-/* CC1_SPEC is the set of arguments to pass to the compiler proper.  */\n+#undef CPP_SPEC\n+#define CPP_SPEC                 \"%{mscore3:-D__score3__} %{G*}\"\n+\n #undef CC1_SPEC\n-#define CC1_SPEC                 \"%{G*} %{!mel:-meb}\"\n+#define CC1_SPEC                 \"%{!mel:-meb} %{mel:-mel } \\\n+%{!mscore*:-mscore7}    \\\n+%{mscore3:-mscore3}     \\\n+%{mscore3d:-mscore3d}   \\\n+%{mscore7:-mscore7}     \\\n+%{mscore7d:-mscore7d}   \\\n+%{G*}\"\n \n #undef ASM_SPEC\n-#define ASM_SPEC \\\n-  \"%{!mel:-EB} %{mel:-EL} %{mscore5:-SCORE5} %{mscore5u:-SCORE5U} \\\n-   %{mscore7:%{!mmac:-SCORE7}} %{mscore7:%{mmac:-SCORE7D}} \\\n-   %{mscore7d:-SCORE7D} %{G*}\"\n+#define ASM_SPEC                 \"%{!mel:-EB} %{mel:-EL} \\\n+%{!mscore*:-march=score7}         \\\n+%{mscore7:-march=score7}          \\\n+%{mscore7d:-march=score7}         \\\n+%{mscore3:-march=score3}          \\\n+%{mscore3d:-march=score3}         \\\n+%{march=score5:-march=score7}     \\\n+%{march=score5u:-march=score7}    \\\n+%{march=score7:-march=score7}     \\\n+%{march=score7d:-march=score7}    \\\n+%{march=score3:-march=score3}     \\\n+%{march=score3d:-march=score3}    \\\n+%{G*}\"\n \n #undef LINK_SPEC\n-#define LINK_SPEC                \"%{!mel:-EB} %{mel:-EL} %{G*}\"\n+#define LINK_SPEC                \"%{!mel:-EB} %{mel:-EL} \\\n+%{!mscore*:-mscore7_elf}          \\\n+%{mscore7:-mscore7_elf}           \\\n+%{mscore7d:-mscore7_elf}          \\\n+%{mscore3:-mscore3_elf}           \\\n+%{mscore3d:-mscore3_elf}          \\\n+%{march=score5:-mscore7_elf}      \\\n+%{march=score5u:-mscore7_elf}     \\\n+%{march=score7:-mscore7_elf}      \\\n+%{march=score7d:-mscore7_elf}     \\\n+%{march=score3:-mscore3_elf}      \\\n+%{march=score3d:-mscore3_elf}     \\\n+%{G*}\"\n \n /* Run-time Target Specification.  */\n #define TARGET_CPU_CPP_BUILTINS()               \\\n@@ -54,16 +77,26 @@ extern GTY(()) rtx cmp_op1;\n       builtin_define (\"__scorele__\");           \\\n     else                                        \\\n       builtin_define (\"__scorebe__\");           \\\n+    if (TARGET_SCORE5)                          \\\n+      builtin_define (\"__score5__\");            \\\n     if (TARGET_SCORE5U)                         \\\n       builtin_define (\"__score5u__\");           \\\n-    else                                        \\\n+    if (TARGET_SCORE7)                          \\\n       builtin_define (\"__score7__\");            \\\n+    if (TARGET_SCORE7D)                         \\\n+      builtin_define (\"__score7d__\");           \\\n+    if (TARGET_SCORE3)                          \\\n+      builtin_define (\"__score3__\");            \\\n+    if (TARGET_SCORE3D)                         \\\n+      builtin_define (\"__score3d__\");           \\\n   } while (0)\n \n-#define TARGET_DEFAULT         MASK_SCORE7\n+#define TARGET_DEFAULT         0\n+\n+#define SCORE_GCC_VERSION      \"1.6\"\n \n #define TARGET_VERSION \\\n-  fprintf (stderr, \"Sunplus S+CORE %s\", SCORE_GCC_VERSION);\n+      fprintf (stderr, \"Sunplus S+core rev=%s\", SCORE_GCC_VERSION);\n \n #define OVERRIDE_OPTIONS       score_override_options ()\n \n@@ -415,6 +448,7 @@ enum reg_class\n /* The class value for index registers.  */\n #define INDEX_REG_CLASS                NO_REGS\n \n+extern enum reg_class score_char_to_class[256];\n #define REG_CLASS_FROM_LETTER(C)       score_char_to_class[(unsigned char) (C)]\n \n /* Addressing modes, and classification of registers for them.  */\n@@ -619,28 +653,58 @@ typedef struct score_args\n /* Generating Code for Profiling  */\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n-#define FUNCTION_PROFILER(FILE, LABELNO)                           \\\n-{                                                                  \\\n-  fprintf (FILE, \" .set r1  \\n\");                                  \\\n-  fprintf (FILE, \" mv   r%d,r%d \\n\", AT_REGNUM, RA_REGNUM);        \\\n-  fprintf (FILE, \" subi r%d, %d \\n\", STACK_POINTER_REGNUM, 8);     \\\n-  fprintf (FILE, \" jl   _mcount \\n\");                              \\\n-  fprintf (FILE, \" .set nor1 \\n\");                                 \\\n-}\n+#define FUNCTION_PROFILER(FILE, LABELNO)                              \\\n+  do {                                                                \\\n+    if (TARGET_SCORE7)                                                \\\n+      {                                                               \\\n+        fprintf (FILE, \" .set r1  \\n\");                               \\\n+        fprintf (FILE, \" mv   r%d,r%d \\n\", AT_REGNUM, RA_REGNUM);     \\\n+        fprintf (FILE, \" subi r%d, %d \\n\", STACK_POINTER_REGNUM, 8);  \\\n+        fprintf (FILE, \" jl   _mcount \\n\");                           \\\n+        fprintf (FILE, \" .set nor1 \\n\");                              \\\n+      }                                                               \\\n+    else if (TARGET_SCORE3)                                           \\\n+      {                                                               \\\n+        fprintf (FILE, \" .set r1  \\n\");                               \\\n+        fprintf (FILE, \" mv!   r%d,r%d \\n\", AT_REGNUM, RA_REGNUM);    \\\n+        fprintf (FILE, \" addi! r%d, %d \\n\", STACK_POINTER_REGNUM, -8);\\\n+        fprintf (FILE, \" jl   _mcount \\n\");                           \\\n+        fprintf (FILE, \" .set nor1 \\n\");                              \\\n+      }                                                               \\\n+  } while (0)\n \n-#define TRAMPOLINE_TEMPLATE(STREAM)                                \\\n-{                                                                  \\\n-  fprintf (STREAM, \"\\t.set r1\\n\");                                 \\\n-  fprintf (STREAM, \"\\tmv r31, r3\\n\");                              \\\n-  fprintf (STREAM, \"\\tbl nextinsn\\n\");                             \\\n-  fprintf (STREAM, \"nextinsn:\\n\");                                 \\\n-  fprintf (STREAM, \"\\tlw r1, [r3, 6*4-8]\\n\");                      \\\n-  fprintf (STREAM, \"\\tlw r23, [r3, 6*4-4]\\n\");                     \\\n-  fprintf (STREAM, \"\\tmv r3, r31\\n\");                              \\\n-  fprintf (STREAM, \"\\tbr! r1\\n\");                                  \\\n-  fprintf (STREAM, \"\\tnop!\\n\");                                    \\\n-  fprintf (STREAM, \"\\t.set nor1\\n\");                               \\\n-}\n+#define TRAMPOLINE_TEMPLATE(STREAM)                                   \\\n+  do {                                                                \\\n+    if (TARGET_SCORE7)                                                \\\n+      {                                                               \\\n+        fprintf (STREAM, \"\\t.set r1\\n\");                              \\\n+        fprintf (STREAM, \"\\tmv r31, r3\\n\");                           \\\n+        fprintf (STREAM, \"\\tbl nextinsn\\n\");                          \\\n+        fprintf (STREAM, \"nextinsn:\\n\");                              \\\n+        fprintf (STREAM, \"\\tlw r1, [r3, 6*4-8]\\n\");                   \\\n+        fprintf (STREAM, \"\\tlw r23, [r3, 6*4-4]\\n\");                  \\\n+        fprintf (STREAM, \"\\tmv r3, r31\\n\");                           \\\n+        fprintf (STREAM, \"\\tbr! r1\\n\");                               \\\n+        fprintf (STREAM, \"\\tnop!\\n\");                                 \\\n+        fprintf (STREAM, \"\\t.set nor1\\n\");                            \\\n+      }                                                               \\\n+    else if (TARGET_SCORE3)                                           \\\n+      {                                                               \\\n+        fprintf (STREAM, \"\\t.set r1\\n\");                              \\\n+        fprintf (STREAM, \"\\tmv! r31, r3\\n\");                          \\\n+        fprintf (STREAM, \"\\tnop!\\n\");                                 \\\n+        fprintf (STREAM, \"\\tbl nextinsn\\n\");                          \\\n+        fprintf (STREAM, \"nextinsn:\\n\");                              \\\n+        fprintf (STREAM, \"\\tlw! r1, [r3, 6*4-8]\\n\");                  \\\n+        fprintf (STREAM, \"\\tnop!\\n\");                                 \\\n+        fprintf (STREAM, \"\\tlw r23, [r3, 6*4-4]\\n\");                  \\\n+        fprintf (STREAM, \"\\tmv! r3, r31\\n\");                          \\\n+        fprintf (STREAM, \"\\tnop!\\n\");                                 \\\n+        fprintf (STREAM, \"\\tbr! r1\\n\");                               \\\n+        fprintf (STREAM, \"\\tnop!\\n\");                                 \\\n+        fprintf (STREAM, \"\\t.set nor1\\n\");                            \\\n+      }                                                               \\\n+  } while (0)\n \n /* Trampolines for Nested Functions.  */\n #define TRAMPOLINE_INSNS                6\n@@ -765,17 +829,23 @@ typedef struct score_args\n /* Output of Uninitialized Variables.  */\n /* This says how to define a global common symbol.  */\n #define ASM_OUTPUT_ALIGNED_DECL_COMMON(STREAM, DECL, NAME, SIZE, ALIGN)     \\\n-  score_declare_object (STREAM, NAME, \"\\n\\t.comm\\t\",                        \\\n-                        \",\"HOST_WIDE_INT_PRINT_UNSIGNED\",%u\\n\",             \\\n-                        SIZE, ALIGN / BITS_PER_UNIT);\n+  do {                                                                      \\\n+    fputs (\"\\n\\t.comm\\t\", STREAM);                                          \\\n+    assemble_name (STREAM, NAME);                                           \\\n+    fprintf (STREAM, \" , \" HOST_WIDE_INT_PRINT_UNSIGNED \", %u\\n\",           \\\n+             SIZE, ALIGN / BITS_PER_UNIT);                                  \\\n+  } while (0)\n \n /* This says how to define a local common symbol (i.e., not visible to\n    linker).  */\n #undef ASM_OUTPUT_ALIGNED_LOCAL\n-#define ASM_OUTPUT_ALIGNED_LOCAL(STREAM, NAME, SIZE, ALIGN)            \\\n-  score_declare_object (STREAM, NAME, \"\\n\\t.lcomm\\t\",                  \\\n-                        \",\"HOST_WIDE_INT_PRINT_UNSIGNED\",%u\\n\",        \\\n-                        SIZE, ALIGN / BITS_PER_UNIT);\n+#define ASM_OUTPUT_ALIGNED_LOCAL(STREAM, NAME, SIZE, ALIGN)                 \\\n+  do {                                                                      \\\n+    fputs (\"\\n\\t.lcomm\\t\", STREAM);                                         \\\n+    assemble_name (STREAM, NAME);                                           \\\n+    fprintf (STREAM, \" , \" HOST_WIDE_INT_PRINT_UNSIGNED \", %u\\n\",           \\\n+             SIZE, ALIGN / BITS_PER_UNIT);                                  \\\n+  } while (0)\n \n /* Globalizing directive for a label.  */\n #define GLOBAL_ASM_OP                   \"\\t.globl\\t\"\n@@ -790,8 +860,11 @@ typedef struct score_args\n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\n \n #undef ASM_DECLARE_OBJECT_NAME\n-#define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL) \\\n-  score_declare_object (STREAM, NAME, \"\", \":\\n\")\n+#define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL)   \\\n+  do {                                                \\\n+    assemble_name (STREAM, NAME);                     \\\n+    fprintf (STREAM, \":\\n\");                          \\\n+  } while (0)\n \n /* This says how to output an external.  It would be possible not to\n    output anything and let undefined symbol become external. However\n@@ -808,7 +881,7 @@ typedef struct score_args\n \n /* Local compiler-generated symbols must have a prefix that the assembler\n    understands.  */\n-#define LOCAL_LABEL_PREFIX              \".\"\n+#define LOCAL_LABEL_PREFIX              (TARGET_SCORE7 ? \".\" : \"$\")\n \n #undef ASM_GENERATE_INTERNAL_LABEL\n #define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM) \\\n@@ -859,32 +932,88 @@ typedef struct score_args\n #define USER_LABEL_PREFIX        \"\"\n \n /* This is how to output an insn to push a register on the stack.  */\n-#define ASM_OUTPUT_REG_PUSH(STREAM, REGNO)       \\\n-  do {                                           \\\n-    fprintf (STREAM, \"\\tpush! %s,[%s]\\n\",        \\\n-             reg_names[REGNO],                   \\\n-             reg_names[STACK_POINTER_REGNUM]);   \\\n+#define ASM_OUTPUT_REG_PUSH(STREAM, REGNO)           \\\n+  do {                                               \\\n+    if (TARGET_SCORE7)                               \\\n+        fprintf (STREAM, \"\\tpush! %s,[%s]\\n\",        \\\n+                 reg_names[REGNO],                   \\\n+                 reg_names[STACK_POINTER_REGNUM]);   \\\n+    else if (TARGET_SCORE3)                          \\\n+        fprintf (STREAM, \"\\tpush!\\t%s\\n\",            \\\n+                 reg_names[REGNO]);                  \\\n   } while (0)\n \n /* This is how to output an insn to pop a register from the stack.  */\n-#define ASM_OUTPUT_REG_POP(STREAM, REGNO)        \\\n-  do {                                           \\\n-    fprintf (STREAM, \"\\tpop! %s,[%s]\\n\",         \\\n-             reg_names[REGNO],                   \\\n-             reg_names[STACK_POINTER_REGNUM]);   \\\n+#define ASM_OUTPUT_REG_POP(STREAM, REGNO)            \\\n+  do {                                               \\\n+    if (TARGET_SCORE7)                               \\\n+      fprintf (STREAM, \"\\tpop! %s,[%s]\\n\",           \\\n+               reg_names[REGNO],                     \\\n+               reg_names[STACK_POINTER_REGNUM]);     \\\n+    else if (TARGET_SCORE3)                          \\\n+      fprintf (STREAM, \"\\tpop!\\t%s\\n\",               \\\n+               reg_names[REGNO]);                    \\\n   } while (0)\n \n /* Output of Dispatch Tables.  */\n /* This is how to output an element of a case-vector.  We can make the\n    entries PC-relative in GP-relative when .gp(d)word is supported.  */\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)              \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)                \\\n+  do {                                                                    \\\n+    if (TARGET_SCORE7)                                                    \\\n+      if (flag_pic)                                                       \\\n+        fprintf (STREAM, \"\\t.gpword %sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE); \\\n+      else                                                                \\\n+        fprintf (STREAM, \"\\t.word %sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE);   \\\n+    else if (TARGET_SCORE3)                                               \\\n+      {                                                                   \\\n+        switch (GET_MODE(BODY))                                           \\\n+          {                                                               \\\n+          case QImode: /* TBB */                                          \\\n+            asm_fprintf (STREAM, \"\\t.byte\\t(%LL%d-%LL%d_tbb)/2\\n\",        \\\n+                         VALUE, REL);                                     \\\n+            break;                                                        \\\n+          case HImode: /* TBH */                                          \\\n+            asm_fprintf (STREAM, \"\\t.2byte\\t(%LL%d-%LL%d_tbb)/2\\n\",       \\\n+                         VALUE, REL);                                     \\\n+            break;                                                        \\\n+          case SImode:                                                    \\\n+            if (flag_pic)                                                 \\\n+              fprintf (STREAM, \"\\t.gpword %sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE); \\\n+            else                                                          \\\n+              fprintf (STREAM, \"\\t.word %sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE);   \\\n+            break;                                                        \\\n+          default:                                                        \\\n+            gcc_unreachable();                                            \\\n+          }                                                               \\\n+      }                                                                   \\\n+  } while (0)\n+\n+/* Jump table alignment is explicit in ASM_OUTPUT_CASE_LABEL.  */\n+#define ADDR_VEC_ALIGN(JUMPTABLE) (GET_MODE (PATTERN (JUMPTABLE)) == SImode ? 2 \\\n+                                   : GET_MODE (PATTERN (JUMPTABLE)) == HImode ? 1 : 0)\n+\n+/* This is how to output a label which precedes a jumptable.  Since\n+   Score3 instructions are 2 bytes, we may need explicit alignment here.  */\n+#undef  ASM_OUTPUT_CASE_LABEL\n+#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, JUMPTABLE)             \\\n   do {                                                                  \\\n-    if (flag_pic)                                                       \\\n-      fprintf (STREAM, \"\\t.gpword %sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE); \\\n-    else                                                                \\\n-      fprintf (STREAM, \"\\t.word %sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE);   \\\n+      if ((TARGET_SCORE7) && GET_MODE (PATTERN (JUMPTABLE)) == SImode)  \\\n+        ASM_OUTPUT_ALIGN (FILE, 2);                                     \\\n+      (*targetm.asm_out.internal_label) (FILE, PREFIX, NUM);            \\\n   } while (0)\n \n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE                SImode\n+\n+#define CASE_VECTOR_PC_RELATIVE         (TARGET_SCORE3)\n+\n+#define CASE_VECTOR_SHORTEN_MODE(min, max, body)                \\\n+   ((min < 0 || max >= 0x2000 || TARGET_SCORE7) ? SImode        \\\n+   : (max >= 0x200) ? HImode                                    \\\n+   : QImode)\n+\n /* This is how to output an element of a case-vector that is absolute.  */\n #define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE) \\\n   fprintf (STREAM, \"\\t.word %sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE)\n@@ -927,10 +1056,6 @@ typedef struct score_args\n /* The DWARF 2 CFA column which tracks the return address.  */\n #define DWARF_FRAME_RETURN_COLUMN       3\n \n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE                SImode\n-\n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n #define WORD_REGISTER_OPERATIONS"}, {"sha": "e616c57aa7ef8ba8d3ae860fb326ae2780e321c2", "filename": "gcc/config/score/score.md", "status": "modified", "additions": 2522, "deletions": 353, "changes": 2875, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.md?ref=254f522229578af1af093b2e4b6f1a0cc400d216"}, {"sha": "e521f7a1f44b94322b82f1b101a696972af877cb", "filename": "gcc/config/score/score.opt", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.opt?ref=254f522229578af1af093b2e4b6f1a0cc400d216", "patch": "@@ -34,10 +34,6 @@ muls\n Target RejectNegative Report Mask(ULS)\n Enable unaligned load/store instruction\n \n-mmac\n-Target RejectNegative Report Mask(MAC)\n-Enable mac instruction\n-\n mscore5\n Target RejectNegative Report Mask(SCORE5)\n Support SCORE 5 ISA\n@@ -53,3 +49,15 @@ Support SCORE 7 ISA\n mscore7d\n Target RejectNegative Report Mask(SCORE7D)\n Support SCORE 7D ISA\n+\n+mscore3\n+Target RejectNegative Report Mask(SCORE3)\n+Support SCORE 3 ISA\n+\n+mscore3d\n+Target RejectNegative Report Mask(SCORE3D)\n+Support SCORE 3d ISA\n+\n+march=\n+Target RejectNegative Joined\n+Specify the name of the target architecture"}, {"sha": "f268cbaf2df2db0b19e4e9e98692a1f44ce7030e", "filename": "gcc/config/score/score3.c", "status": "added", "additions": 1945, "deletions": 0, "changes": 1945, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore3.c?ref=254f522229578af1af093b2e4b6f1a0cc400d216", "patch": "@@ -0,0 +1,1945 @@\n+/* score3.c for Sunplus S+CORE processor\n+   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+   Contributed by Sunnorth\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-attr.h\"\n+#include \"recog.h\"\n+#include \"toplev.h\"\n+#include \"output.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"flags.h\"\n+#include \"reload.h\"\n+#include \"tm_p.h\"\n+#include \"ggc.h\"\n+#include \"gstab.h\"\n+#include \"hashtab.h\"\n+#include \"debug.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"integrate.h\"\n+#include \"langhooks.h\"\n+#include \"cfglayout.h\"\n+#include \"score3.h\"\n+\n+#define BITSET_P(VALUE, BIT)      (((VALUE) & (1L << (BIT))) != 0)\n+#define INS_BUF_SZ                128\n+\n+/* Define the information needed to generate branch insns.  This is\n+   stored from the compare operation.  */\n+extern rtx cmp_op0, cmp_op1;\n+extern enum reg_class score_char_to_class[256];\n+\n+static int score3_sdata_max;\n+static char score3_ins[INS_BUF_SZ + 8];\n+\n+/* Return true if SYMBOL is a SYMBOL_REF and OFFSET + SYMBOL points\n+   to the same object as SYMBOL.  */\n+static int\n+score3_offset_within_object_p (rtx symbol, HOST_WIDE_INT offset)\n+{\n+  if (GET_CODE (symbol) != SYMBOL_REF)\n+    return 0;\n+\n+  if (CONSTANT_POOL_ADDRESS_P (symbol)\n+      && offset >= 0\n+      && offset < (int)GET_MODE_SIZE (get_pool_mode (symbol)))\n+    return 1;\n+\n+  if (SYMBOL_REF_DECL (symbol) != 0\n+      && offset >= 0\n+      && offset < int_size_in_bytes (TREE_TYPE (SYMBOL_REF_DECL (symbol))))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Split X into a base and a constant offset, storing them in *BASE\n+   and *OFFSET respectively.  */\n+static void\n+score3_split_const (rtx x, rtx *base, HOST_WIDE_INT *offset)\n+{\n+  *offset = 0;\n+\n+  if (GET_CODE (x) == CONST)\n+    x = XEXP (x, 0);\n+\n+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    {\n+      *offset += INTVAL (XEXP (x, 1));\n+      x = XEXP (x, 0);\n+    }\n+\n+  *base = x;\n+}\n+\n+/* Classify symbol X, which must be a SYMBOL_REF or a LABEL_REF.  */\n+static enum score_symbol_type\n+score3_classify_symbol (rtx x)\n+{\n+  if (GET_CODE (x) == LABEL_REF)\n+    return SYMBOL_GENERAL;\n+\n+  gcc_assert (GET_CODE (x) == SYMBOL_REF);\n+\n+  if (CONSTANT_POOL_ADDRESS_P (x))\n+    {\n+      if (GET_MODE_SIZE (get_pool_mode (x)) <= SCORE3_SDATA_MAX)\n+        return SYMBOL_SMALL_DATA;\n+      return SYMBOL_GENERAL;\n+    }\n+  if (SYMBOL_REF_SMALL_P (x))\n+    return SYMBOL_SMALL_DATA;\n+  return SYMBOL_GENERAL;\n+}\n+\n+/* Return true if the current function must save REGNO.  */\n+static int\n+score3_save_reg_p (unsigned int regno)\n+{\n+  /* Check call-saved registers.  */\n+  if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n+    return 1;\n+\n+  /* We need to save the old frame pointer before setting up a new one.  */\n+  if (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\n+    return 1;\n+\n+  /* We need to save the incoming return address if it is ever clobbered\n+     within the function.  */\n+  if (regno == RA_REGNUM && df_regs_ever_live_p (regno))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return one word of double-word value OP, taking into account the fixed\n+   endianness of certain registers.  HIGH_P is true to select the high part,\n+   false to select the low part.  */\n+static rtx\n+score3_subw (rtx op, int high_p)\n+{\n+  unsigned int byte;\n+  enum machine_mode mode = GET_MODE (op);\n+\n+  if (mode == VOIDmode)\n+    mode = DImode;\n+\n+  byte = (TARGET_LITTLE_ENDIAN ? high_p : !high_p) ? UNITS_PER_WORD : 0;\n+\n+  if (GET_CODE (op) == REG && REGNO (op) == HI_REGNUM)\n+    return gen_rtx_REG (SImode, high_p ? HI_REGNUM : LO_REGNUM);\n+\n+  if (GET_CODE (op) == MEM)\n+    return adjust_address (op, SImode, byte);\n+\n+  return simplify_gen_subreg (SImode, op, mode, byte);\n+}\n+\n+static struct score3_frame_info *\n+score3_cached_frame (void)\n+{\n+  static struct score3_frame_info _frame_info;\n+  return &_frame_info;\n+}\n+\n+/* Return the bytes needed to compute the frame pointer from the current\n+   stack pointer.  SIZE is the size (in bytes) of the local variables.  */\n+static struct score3_frame_info *\n+score3_compute_frame_size (HOST_WIDE_INT size)\n+{\n+  unsigned int regno;\n+  struct score3_frame_info *f = score3_cached_frame ();\n+\n+  memset (f, 0, sizeof (struct score3_frame_info));\n+  f->gp_reg_size = 0;\n+  f->mask = 0;\n+  f->var_size = SCORE3_STACK_ALIGN (size);\n+  f->args_size = current_function_outgoing_args_size;\n+  f->cprestore_size = flag_pic ? UNITS_PER_WORD : 0;\n+\n+  if (f->var_size == 0 && current_function_is_leaf)\n+    f->args_size = f->cprestore_size = 0;\n+\n+  if (f->args_size == 0 && current_function_calls_alloca)\n+    f->args_size = UNITS_PER_WORD;\n+\n+  f->total_size = f->var_size + f->args_size + f->cprestore_size;\n+  for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n+    {\n+      if (score3_save_reg_p (regno))\n+        {\n+          f->gp_reg_size += GET_MODE_SIZE (SImode);\n+          f->mask |= 1 << (regno - GP_REG_FIRST);\n+        }\n+    }\n+\n+  if (current_function_calls_eh_return)\n+    {\n+      unsigned int i;\n+      for (i = 0;; ++i)\n+        {\n+          regno = EH_RETURN_DATA_REGNO (i);\n+          if (regno == INVALID_REGNUM)\n+            break;\n+          f->gp_reg_size += GET_MODE_SIZE (SImode);\n+          f->mask |= 1 << (regno - GP_REG_FIRST);\n+        }\n+    }\n+\n+  f->total_size += f->gp_reg_size;\n+  f->num_gp = f->gp_reg_size / UNITS_PER_WORD;\n+\n+  if (f->mask)\n+    {\n+      HOST_WIDE_INT offset;\n+      offset = (f->args_size + f->cprestore_size + f->var_size\n+                + f->gp_reg_size - GET_MODE_SIZE (SImode));\n+      f->gp_sp_offset = offset;\n+    }\n+  else\n+    f->gp_sp_offset = 0;\n+\n+  return f;\n+}\n+\n+/* Return true if X is a valid base register for the given mode.\n+   Allow only hard registers if STRICT.  */\n+static int\n+score3_valid_base_register_p (rtx x, int strict)\n+{\n+  if (!strict && GET_CODE (x) == SUBREG)\n+    x = SUBREG_REG (x);\n+\n+  return (GET_CODE (x) == REG\n+          && score3_regno_mode_ok_for_base_p (REGNO (x), strict));\n+}\n+\n+/* Return true if X is a valid address for machine mode MODE.  If it is,\n+   fill in INFO appropriately.  STRICT is true if we should only accept\n+   hard base registers.  */\n+static int\n+score3_classify_address (struct score3_address_info *info,\n+                         enum machine_mode mode, rtx x, int strict)\n+{\n+  info->code = GET_CODE (x);\n+\n+  switch (info->code)\n+    {\n+    case REG:\n+    case SUBREG:\n+      info->type = SCORE3_ADD_REG;\n+      info->reg = x;\n+      info->offset = const0_rtx;\n+      return score3_valid_base_register_p (info->reg, strict);\n+    case PLUS:\n+      info->type = SCORE3_ADD_REG;\n+      info->reg = XEXP (x, 0);\n+      info->offset = XEXP (x, 1);\n+      return (score3_valid_base_register_p (info->reg, strict)\n+              && GET_CODE (info->offset) == CONST_INT\n+              && IMM_IN_RANGE (INTVAL (info->offset), 15, 1));\n+    case PRE_DEC:\n+    case POST_DEC:\n+    case PRE_INC:\n+    case POST_INC:\n+      if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (SImode))\n+        return false;\n+      info->type = SCORE3_ADD_REG;\n+      info->reg = XEXP (x, 0);\n+      info->offset = GEN_INT (GET_MODE_SIZE (mode));\n+      return score3_valid_base_register_p (info->reg, strict);\n+    case CONST_INT:\n+      info->type = SCORE3_ADD_CONST_INT;\n+      return 1;\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      info->type = SCORE3_ADD_SYMBOLIC;\n+      return (score3_symbolic_constant_p (x, &info->symbol_type)\n+              && (info->symbol_type == SYMBOL_GENERAL\n+                  || info->symbol_type == SYMBOL_SMALL_DATA));\n+    default:\n+      return 0;\n+    }\n+}\n+\n+bool\n+score3_return_in_memory (tree type, tree fndecl ATTRIBUTE_UNUSED)\n+{\n+    return ((TYPE_MODE (type) == BLKmode)\n+            || (int_size_in_bytes (type) > 2 * UNITS_PER_WORD)\n+            || (int_size_in_bytes (type) == -1));\n+}\n+\n+/* Return a legitimate address for REG + OFFSET.  */\n+static rtx\n+score3_add_offset (rtx reg, HOST_WIDE_INT offset)\n+{\n+  if (!IMM_IN_RANGE (offset, 15, 1))\n+    {\n+      reg = expand_simple_binop (GET_MODE (reg), PLUS,\n+                                 gen_int_mode (offset & 0xffffc000,\n+                                               GET_MODE (reg)),\n+                                 reg, NULL, 0, OPTAB_WIDEN);\n+      offset &= 0x3fff;\n+    }\n+\n+  return plus_constant (reg, offset);\n+}\n+\n+/* Implement TARGET_ASM_OUTPUT_MI_THUNK.  Generate rtl rather than asm text\n+   in order to avoid duplicating too much logic from elsewhere.  */\n+void\n+score3_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n+                        HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n+                        tree function)\n+{\n+  rtx this, temp1, insn, fnaddr;\n+\n+  /* Pretend to be a post-reload pass while generating rtl.  */\n+  reload_completed = 1;\n+\n+  /* Mark the end of the (empty) prologue.  */\n+  emit_note (NOTE_INSN_PROLOGUE_END);\n+\n+  /* We need two temporary registers in some cases.  */\n+  temp1 = gen_rtx_REG (Pmode, 8);\n+\n+  /* Find out which register contains the \"this\" pointer.  */\n+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n+    this = gen_rtx_REG (Pmode, ARG_REG_FIRST + 1);\n+  else\n+    this = gen_rtx_REG (Pmode, ARG_REG_FIRST);\n+\n+  /* Add DELTA to THIS.  */\n+  if (delta != 0)\n+    {\n+      rtx offset = GEN_INT (delta);\n+      if (!CONST_OK_FOR_LETTER_P (delta, 'L'))\n+        {\n+          emit_move_insn (temp1, offset);\n+          offset = temp1;\n+        }\n+      emit_insn (gen_add3_insn (this, this, offset));\n+    }\n+\n+  /* If needed, add *(*THIS + VCALL_OFFSET) to THIS.  */\n+  if (vcall_offset != 0)\n+    {\n+      rtx addr;\n+\n+      /* Set TEMP1 to *THIS.  */\n+      emit_move_insn (temp1, gen_rtx_MEM (Pmode, this));\n+\n+      /* Set ADDR to a legitimate address for *THIS + VCALL_OFFSET.  */\n+      addr = score3_add_offset (temp1, vcall_offset);\n+\n+      /* Load the offset and add it to THIS.  */\n+      emit_move_insn (temp1, gen_rtx_MEM (Pmode, addr));\n+      emit_insn (gen_add3_insn (this, this, temp1));\n+    }\n+\n+  /* Jump to the target function.  */\n+  fnaddr = XEXP (DECL_RTL (function), 0);\n+  insn = emit_call_insn (gen_sibcall_internal_score3 (fnaddr, const0_rtx));\n+  SIBLING_CALL_P (insn) = 1;\n+\n+  /* Run just enough of rest_of_compilation.  This sequence was\n+     \"borrowed\" from alpha.c.  */\n+  insn = get_insns ();\n+  insn_locators_alloc ();\n+  split_all_insns_noflow ();\n+  shorten_branches (insn);\n+  final_start_function (insn, file, 1);\n+  final (insn, file, 1);\n+  final_end_function ();\n+\n+  /* Clean up the vars set above.  Note that final_end_function resets\n+     the global pointer for us.  */\n+  reload_completed = 0;\n+}\n+\n+/* Copy VALUE to a register and return that register.  If new psuedos\n+   are allowed, copy it into a new register, otherwise use DEST.  */\n+static rtx\n+score3_force_temporary (rtx dest, rtx value)\n+{\n+  if (can_create_pseudo_p ())\n+    return force_reg (Pmode, value);\n+  else\n+    {\n+      emit_move_insn (copy_rtx (dest), value);\n+      return dest;\n+    }\n+}\n+\n+/* Return a LO_SUM expression for ADDR.  TEMP is as for score_force_temporary\n+   and is used to load the high part into a register.  */\n+static rtx\n+score3_split_symbol (rtx temp, rtx addr)\n+{\n+  rtx high = score3_force_temporary (temp,\n+                                     gen_rtx_HIGH (Pmode, copy_rtx (addr)));\n+  return gen_rtx_LO_SUM (Pmode, high, addr);\n+}\n+\n+/* This function is used to implement LEGITIMIZE_ADDRESS.  If *XLOC can\n+   be legitimized in a way that the generic machinery might not expect,\n+   put the new address in *XLOC and return true.  */\n+int\n+score3_legitimize_address (rtx *xloc)\n+{\n+  enum score_symbol_type symbol_type;\n+\n+  if (score3_symbolic_constant_p (*xloc, &symbol_type)\n+      && symbol_type == SYMBOL_GENERAL)\n+    {\n+      *xloc = score3_split_symbol (0, *xloc);\n+      return 1;\n+    }\n+\n+  if (GET_CODE (*xloc) == PLUS\n+      && GET_CODE (XEXP (*xloc, 1)) == CONST_INT)\n+    {\n+      rtx reg = XEXP (*xloc, 0);\n+      if (!score3_valid_base_register_p (reg, 0))\n+        reg = copy_to_mode_reg (Pmode, reg);\n+      *xloc = score3_add_offset (reg, INTVAL (XEXP (*xloc, 1)));\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Fill INFO with information about a single argument.  CUM is the\n+   cumulative state for earlier arguments.  MODE is the mode of this\n+   argument and TYPE is its type (if known).  NAMED is true if this\n+   is a named (fixed) argument rather than a variable one.  */\n+static void\n+score3_classify_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+                     tree type, int named, struct score3_arg_info *info)\n+{\n+  int even_reg_p;\n+  unsigned int num_words, max_regs;\n+\n+  even_reg_p = 0;\n+  if (GET_MODE_CLASS (mode) == MODE_INT\n+      || GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    even_reg_p = (GET_MODE_SIZE (mode) > UNITS_PER_WORD);\n+  else\n+    if (type != NULL_TREE && TYPE_ALIGN (type) > BITS_PER_WORD && named)\n+      even_reg_p = 1;\n+\n+  if (TARGET_MUST_PASS_IN_STACK (mode, type))\n+    info->reg_offset = ARG_REG_NUM;\n+  else\n+    {\n+      info->reg_offset = cum->num_gprs;\n+      if (even_reg_p)\n+        info->reg_offset += info->reg_offset & 1;\n+    }\n+\n+  if (mode == BLKmode)\n+    info->num_bytes = int_size_in_bytes (type);\n+  else\n+    info->num_bytes = GET_MODE_SIZE (mode);\n+\n+  num_words = (info->num_bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  max_regs = ARG_REG_NUM - info->reg_offset;\n+\n+  /* Partition the argument between registers and stack.  */\n+  info->reg_words = MIN (num_words, max_regs);\n+  info->stack_words = num_words - info->reg_words;\n+\n+  /* The alignment applied to registers is also applied to stack arguments.  */\n+  if (info->stack_words)\n+    {\n+      info->stack_offset = cum->stack_words;\n+      if (even_reg_p)\n+        info->stack_offset += info->stack_offset & 1;\n+    }\n+}\n+\n+/* Set up the stack and frame (if desired) for the function.  */\n+void\n+score3_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n+{\n+  const char *fnname;\n+  struct score3_frame_info *f = score3_cached_frame ();\n+  HOST_WIDE_INT tsize = f->total_size;\n+\n+  fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n+  if (!flag_inhibit_size_directive)\n+    {\n+      fputs (\"\\t.ent\\t\", file);\n+      assemble_name (file, fnname);\n+      fputs (\"\\n\", file);\n+    }\n+  assemble_name (file, fnname);\n+  fputs (\":\\n\", file);\n+\n+  if (!flag_inhibit_size_directive)\n+    {\n+      fprintf (file,\n+               \"\\t.frame\\t%s,\" HOST_WIDE_INT_PRINT_DEC \",%s, %d\\t\\t\"\n+               \"# vars= \" HOST_WIDE_INT_PRINT_DEC \", regs= %d\"\n+               \", args= \" HOST_WIDE_INT_PRINT_DEC\n+               \", gp= \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+               (reg_names[(frame_pointer_needed)\n+                ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM]),\n+               tsize,\n+               reg_names[RA_REGNUM],\n+               current_function_is_leaf ? 1 : 0,\n+               f->var_size,\n+               f->num_gp,\n+               f->args_size,\n+               f->cprestore_size);\n+\n+      fprintf(file, \"\\t.mask\\t0x%08x,\" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+              f->mask,\n+              (f->gp_sp_offset - f->total_size));\n+    }\n+}\n+\n+/* Do any necessary cleanup after a function to restore stack, frame,\n+   and regs.  */\n+void\n+score3_function_epilogue (FILE *file,\n+                          HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n+{\n+  if (!flag_inhibit_size_directive)\n+    {\n+      const char *fnname;\n+      fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n+      fputs (\"\\t.end\\t\", file);\n+      assemble_name (file, fnname);\n+      fputs (\"\\n\", file);\n+    }\n+}\n+\n+/* Returns true if X contains a SYMBOL_REF.  */\n+static bool\n+score3_symbolic_expression_p (rtx x)\n+{\n+  if (GET_CODE (x) == SYMBOL_REF)\n+    return true;\n+\n+  if (GET_CODE (x) == CONST)\n+    return score3_symbolic_expression_p (XEXP (x, 0));\n+\n+  if (UNARY_P (x))\n+    return score3_symbolic_expression_p (XEXP (x, 0));\n+\n+  if (ARITHMETIC_P (x))\n+    return (score3_symbolic_expression_p (XEXP (x, 0))\n+            || score3_symbolic_expression_p (XEXP (x, 1)));\n+\n+  return false;\n+}\n+\n+/* Choose the section to use for the constant rtx expression X that has\n+   mode MODE.  */\n+section *\n+score3_select_rtx_section (enum machine_mode mode, rtx x,\n+                           unsigned HOST_WIDE_INT align)\n+{\n+  if (GET_MODE_SIZE (mode) <= SCORE3_SDATA_MAX)\n+    return get_named_section (0, \".sdata\", 0);\n+  else if (flag_pic && score3_symbolic_expression_p (x))\n+    return get_named_section (0, \".data.rel.ro\", 3);\n+  else\n+    return mergeable_constant_section (mode, align, 0);\n+}\n+\n+/* Implement TARGET_IN_SMALL_DATA_P.  */\n+bool\n+score3_in_small_data_p (tree decl)\n+{\n+  HOST_WIDE_INT size;\n+\n+  if (TREE_CODE (decl) == STRING_CST\n+      || TREE_CODE (decl) == FUNCTION_DECL)\n+    return false;\n+\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_SECTION_NAME (decl) != 0)\n+    {\n+      const char *name;\n+      name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n+      if (strcmp (name, \".sdata\") != 0\n+          && strcmp (name, \".sbss\") != 0)\n+        return true;\n+      if (!DECL_EXTERNAL (decl))\n+        return false;\n+    }\n+  size = int_size_in_bytes (TREE_TYPE (decl));\n+  return (size > 0 && size <= SCORE3_SDATA_MAX);\n+}\n+\n+/* Implement TARGET_ASM_FILE_START.  */\n+void\n+score3_asm_file_start (void)\n+{\n+  default_file_start ();\n+  fprintf (asm_out_file, ASM_COMMENT_START\n+           \"GCC for S+core %s \\n\", SCORE_GCC_VERSION);\n+\n+  if (flag_pic)\n+    fprintf (asm_out_file, \"\\t.set pic\\n\");\n+}\n+\n+/* Implement TARGET_ASM_FILE_END.  When using assembler macros, emit\n+   .externs for any small-data variables that turned out to be external.  */\n+void\n+score3_asm_file_end (void)\n+{\n+  tree name_tree;\n+  struct extern_list *p;\n+  if (extern_head)\n+    {\n+      fputs (\"\\n\", asm_out_file);\n+      for (p = extern_head; p != 0; p = p->next)\n+        {\n+          name_tree = get_identifier (p->name);\n+          if (!TREE_ASM_WRITTEN (name_tree)\n+              && TREE_SYMBOL_REFERENCED (name_tree))\n+            {\n+              TREE_ASM_WRITTEN (name_tree) = 1;\n+              fputs (\"\\t.extern\\t\", asm_out_file);\n+              assemble_name (asm_out_file, p->name);\n+              fprintf (asm_out_file, \", %d\\n\", p->size);\n+            }\n+        }\n+    }\n+}\n+\n+/* Implement OVERRIDE_OPTIONS macro.  */\n+void\n+score3_override_options (void)\n+{\n+  flag_pic = false;\n+  if (!flag_pic)\n+    score3_sdata_max = g_switch_set ? g_switch_value : SCORE3_DEFAULT_SDATA_MAX;\n+  else\n+    {\n+      score3_sdata_max = 0;\n+      if (g_switch_set && (g_switch_value != 0))\n+        warning (0, \"-fPIC and -G are incompatible\");\n+    }\n+\n+  score_char_to_class['d'] = G32_REGS;\n+  score_char_to_class['e'] = G16_REGS;\n+  score_char_to_class['t'] = T32_REGS;\n+\n+  score_char_to_class['h'] = HI_REG;\n+  score_char_to_class['l'] = LO_REG;\n+  score_char_to_class['x'] = CE_REGS;\n+\n+  score_char_to_class['q'] = CN_REG;\n+  score_char_to_class['y'] = LC_REG;\n+  score_char_to_class['z'] = SC_REG;\n+  score_char_to_class['a'] = SP_REGS;\n+\n+  score_char_to_class['c'] = CR_REGS;\n+}\n+\n+/* Implement REGNO_REG_CLASS macro.  */\n+int\n+score3_reg_class (int regno)\n+{\n+  int c;\n+  gcc_assert (regno >= 0 && regno < FIRST_PSEUDO_REGISTER);\n+\n+  if (regno == FRAME_POINTER_REGNUM\n+      || regno == ARG_POINTER_REGNUM)\n+    return ALL_REGS;\n+\n+  for (c = 0; c < N_REG_CLASSES; c++)\n+    if (TEST_HARD_REG_BIT (reg_class_contents[c], regno))\n+      return c;\n+\n+  return NO_REGS;\n+}\n+\n+/* Implement PREFERRED_RELOAD_CLASS macro.  */\n+enum reg_class\n+score3_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class class)\n+{\n+  if (reg_class_subset_p (G16_REGS, class))\n+    return G16_REGS;\n+  if (reg_class_subset_p (G32_REGS, class))\n+    return G32_REGS;\n+  return class;\n+}\n+\n+/* Implement SECONDARY_INPUT_RELOAD_CLASS\n+   and SECONDARY_OUTPUT_RELOAD_CLASS macro.  */\n+enum reg_class\n+score3_secondary_reload_class (enum reg_class class,\n+                               enum machine_mode mode ATTRIBUTE_UNUSED,\n+                               rtx x)\n+{\n+  int regno = -1;\n+  if (GET_CODE (x) == REG || GET_CODE(x) == SUBREG)\n+    regno = true_regnum (x);\n+\n+  if (!GR_REG_CLASS_P (class))\n+    return GP_REG_P (regno) ? NO_REGS : G32_REGS;\n+  return NO_REGS;\n+}\n+\n+/* Implement CONST_OK_FOR_LETTER_P macro.  */\n+/* imm constraints\n+   I        imm16 << 16\n+   J        uimm5\n+   K        uimm16\n+   L        simm16\n+   M        uimm14\n+   N        simm14\n+   O        simm14\n+   P        simm5\n+   Q        uimm32  */\n+int\n+score3_const_ok_for_letter_p (HOST_WIDE_INT value, char c)\n+{\n+  switch (c)\n+    {\n+    case 'I': return ((value & 0xffff) == 0);\n+    case 'J': return IMM_IN_RANGE (value, 5, 0);\n+    case 'K': return IMM_IN_RANGE (value, 16, 0);\n+    case 'L': return IMM_IN_RANGE (value, 16, 1);\n+    case 'M': return IMM_IN_RANGE (value, 14, 0);\n+    case 'N': return IMM_IN_RANGE (value, 14, 1);\n+    case 'O': return IMM_IN_RANGE (value, 5, 1);\n+    case 'P': return IMM_IN_RANGE (value, 6, 1);\n+    case 'Q': return score_extra_constraint (GEN_INT(value), c);\n+    default : return 0;\n+    }\n+}\n+\n+/* Implement EXTRA_CONSTRAINT macro.  */\n+/*\n+   Q        uimm32\n+   Z        symbol_ref  */\n+int\n+score3_extra_constraint (rtx op, char c)\n+{\n+  switch (c)\n+    {\n+    case 'Q': return IMM_IN_RANGE (INTVAL(op), 32, 0);\n+    case 'Z':\n+      return GET_CODE (op) == SYMBOL_REF;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Return truth value on whether or not a given hard register\n+   can support a given mode.  */\n+int\n+score3_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n+{\n+  int size = GET_MODE_SIZE (mode);\n+  enum mode_class class = GET_MODE_CLASS (mode);\n+\n+  if (class == MODE_CC)\n+    return regno == CC_REGNUM;\n+  else if (regno == FRAME_POINTER_REGNUM\n+           || regno == ARG_POINTER_REGNUM)\n+    return class == MODE_INT;\n+  else if (GP_REG_P (regno))\n+    return !(regno & 1) || (size <= UNITS_PER_WORD);\n+  else if (CE_REG_P (regno))\n+    return (class == MODE_INT\n+            && ((size <= UNITS_PER_WORD)\n+                || (regno == CE_REG_FIRST && size == 2 * UNITS_PER_WORD)));\n+  else\n+    return (class == MODE_INT) && (size <= UNITS_PER_WORD);\n+}\n+\n+/* Implement INITIAL_ELIMINATION_OFFSET.  FROM is either the frame\n+   pointer or argument pointer.  TO is either the stack pointer or\n+   hard frame pointer.  */\n+HOST_WIDE_INT\n+score3_initial_elimination_offset (int from,\n+                                   int to ATTRIBUTE_UNUSED)\n+{\n+  struct score3_frame_info *f = score3_compute_frame_size (get_frame_size ());\n+  switch (from)\n+    {\n+    case ARG_POINTER_REGNUM:\n+      return f->total_size;\n+    case FRAME_POINTER_REGNUM:\n+      return 0;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Implement FUNCTION_ARG_ADVANCE macro.  */\n+void\n+score3_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+                             tree type, int named)\n+{\n+  struct score3_arg_info info;\n+  score3_classify_arg (cum, mode, type, named, &info);\n+  cum->num_gprs = info.reg_offset + info.reg_words;\n+  if (info.stack_words > 0)\n+    cum->stack_words = info.stack_offset + info.stack_words;\n+  cum->arg_number++;\n+}\n+\n+/* Implement TARGET_ARG_PARTIAL_BYTES macro.  */\n+int\n+score3_arg_partial_bytes (CUMULATIVE_ARGS *cum,\n+                          enum machine_mode mode, tree type, bool named)\n+{\n+  struct score3_arg_info info;\n+  score3_classify_arg (cum, mode, type, named, &info);\n+  return info.stack_words > 0 ? info.reg_words * UNITS_PER_WORD : 0;\n+}\n+\n+/* Implement FUNCTION_ARG macro.  */\n+rtx\n+score3_function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+                     tree type, int named)\n+{\n+  struct score3_arg_info info;\n+\n+  if (mode == VOIDmode || !named)\n+    return 0;\n+\n+  score3_classify_arg (cum, mode, type, named, &info);\n+\n+  if (info.reg_offset == ARG_REG_NUM)\n+    return 0;\n+\n+  if (!info.stack_words)\n+    return gen_rtx_REG (mode, ARG_REG_FIRST + info.reg_offset);\n+  else\n+    {\n+      rtx ret = gen_rtx_PARALLEL (mode, rtvec_alloc (info.reg_words));\n+      unsigned int i, part_offset = 0;\n+      for (i = 0; i < info.reg_words; i++)\n+        {\n+          rtx reg;\n+          reg = gen_rtx_REG (SImode, ARG_REG_FIRST + info.reg_offset + i);\n+          XVECEXP (ret, 0, i) = gen_rtx_EXPR_LIST (SImode, reg,\n+                                                   GEN_INT (part_offset));\n+          part_offset += UNITS_PER_WORD;\n+        }\n+      return ret;\n+    }\n+}\n+\n+/* Implement FUNCTION_VALUE and LIBCALL_VALUE.  For normal calls,\n+   VALTYPE is the return type and MODE is VOIDmode.  For libcalls,\n+   VALTYPE is null and MODE is the mode of the return value.  */\n+rtx\n+score3_function_value (tree valtype, tree func ATTRIBUTE_UNUSED,\n+                       enum machine_mode mode)\n+{\n+  if (valtype)\n+    {\n+      int unsignedp;\n+      mode = TYPE_MODE (valtype);\n+      unsignedp = TYPE_UNSIGNED (valtype);\n+      mode = promote_mode (valtype, mode, &unsignedp, 1);\n+    }\n+  return gen_rtx_REG (mode, RT_REGNUM);\n+}\n+\n+/* Implement INITIALIZE_TRAMPOLINE macro.  */\n+void\n+score3_initialize_trampoline (rtx ADDR, rtx FUNC, rtx CHAIN)\n+{\n+#define FFCACHE          \"_flush_cache\"\n+#define CODE_SIZE        (TRAMPOLINE_INSNS * UNITS_PER_WORD)\n+\n+  rtx pfunc, pchain;\n+\n+  pfunc = plus_constant (ADDR, CODE_SIZE);\n+  pchain = plus_constant (ADDR, CODE_SIZE + GET_MODE_SIZE (SImode));\n+\n+  emit_move_insn (gen_rtx_MEM (SImode, pfunc), FUNC);\n+  emit_move_insn (gen_rtx_MEM (SImode, pchain), CHAIN);\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, FFCACHE),\n+                     0, VOIDmode, 2,\n+                     ADDR, Pmode,\n+                     GEN_INT (TRAMPOLINE_SIZE), SImode);\n+#undef FFCACHE\n+#undef CODE_SIZE\n+}\n+\n+/* This function is used to implement REG_MODE_OK_FOR_BASE_P macro.  */\n+int\n+score3_regno_mode_ok_for_base_p (int regno, int strict)\n+{\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      if (!strict)\n+        return 1;\n+      regno = reg_renumber[regno];\n+    }\n+  if (regno == ARG_POINTER_REGNUM\n+      || regno == FRAME_POINTER_REGNUM)\n+    return 1;\n+  return GP_REG_P (regno);\n+}\n+\n+/* Implement GO_IF_LEGITIMATE_ADDRESS macro.  */\n+int\n+score3_address_p (enum machine_mode mode, rtx x, int strict)\n+{\n+  struct score3_address_info addr;\n+\n+  return score3_classify_address (&addr, mode, x, strict);\n+}\n+\n+/* Return a number assessing the cost of moving a register in class\n+   FROM to class TO. */\n+int\n+score3_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+                           enum reg_class from, enum reg_class to)\n+{\n+  if (GR_REG_CLASS_P (from))\n+    {\n+      if (GR_REG_CLASS_P (to))\n+        return 2;\n+      else if (SP_REG_CLASS_P (to))\n+        return 4;\n+      else if (CP_REG_CLASS_P (to))\n+        return 5;\n+      else if (CE_REG_CLASS_P (to))\n+        return 6;\n+    }\n+  if (GR_REG_CLASS_P (to))\n+    {\n+      if (GR_REG_CLASS_P (from))\n+        return 2;\n+      else if (SP_REG_CLASS_P (from))\n+        return 4;\n+      else if (CP_REG_CLASS_P (from))\n+        return 5;\n+      else if (CE_REG_CLASS_P (from))\n+        return 6;\n+    }\n+  return 12;\n+}\n+\n+/* Return the number of instructions needed to load a symbol of the\n+   given type into a register.  */\n+static int\n+score3_symbol_insns (enum score_symbol_type type)\n+{\n+  switch (type)\n+    {\n+    case SYMBOL_GENERAL:\n+      return 2;\n+\n+    case SYMBOL_SMALL_DATA:\n+      return 1;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Return the number of instructions needed to load or store a value\n+   of mode MODE at X.  Return 0 if X isn't valid for MODE.  */\n+static int\n+score3_address_insns (rtx x, enum machine_mode mode)\n+{\n+  struct score3_address_info addr;\n+  int factor;\n+\n+  if (mode == BLKmode)\n+    factor = 1;\n+  else\n+    factor = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  if (score3_classify_address (&addr, mode, x, false))\n+    switch (addr.type)\n+      {\n+      case SCORE3_ADD_REG:\n+      case SCORE3_ADD_CONST_INT:\n+        return factor;\n+\n+      case SCORE3_ADD_SYMBOLIC:\n+        return factor * score3_symbol_insns (addr.symbol_type);\n+      }\n+  return 0;\n+}\n+\n+/* Implement TARGET_RTX_COSTS macro.  */\n+bool\n+score3_rtx_costs (rtx x, int code, int outer_code, int *total)\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      if (outer_code == SET)\n+        {\n+          if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n+              || CONST_OK_FOR_LETTER_P (INTVAL (x), 'L'))\n+            *total = COSTS_N_INSNS (1);\n+          else\n+            *total = COSTS_N_INSNS (2);\n+        }\n+      else if (outer_code == PLUS || outer_code == MINUS)\n+        {\n+          if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'N'))\n+            *total = 0;\n+          else if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n+                   || CONST_OK_FOR_LETTER_P (INTVAL (x), 'L'))\n+            *total = 1;\n+          else\n+            *total = COSTS_N_INSNS (2);\n+        }\n+      else if (outer_code == AND || outer_code == IOR)\n+        {\n+          if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'M'))\n+            *total = 0;\n+          else if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n+                   || CONST_OK_FOR_LETTER_P (INTVAL (x), 'K'))\n+            *total = 1;\n+          else\n+            *total = COSTS_N_INSNS (2);\n+        }\n+      else\n+        {\n+          *total = 0;\n+        }\n+      return true;\n+\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case CONST_DOUBLE:\n+      *total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case MEM:\n+      {\n+        /* If the address is legitimate, return the number of\n+           instructions it needs, otherwise use the default handling.  */\n+        int n = score3_address_insns (XEXP (x, 0), GET_MODE (x));\n+        if (n > 0)\n+          {\n+            *total = COSTS_N_INSNS (n + 1);\n+            return true;\n+          }\n+        return false;\n+      }\n+\n+    case FFS:\n+      *total = COSTS_N_INSNS (6);\n+      return true;\n+\n+    case NOT:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      if (mode == DImode)\n+        {\n+          *total = COSTS_N_INSNS (2);\n+          return true;\n+        }\n+      return false;\n+\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      if (mode == DImode)\n+        {\n+          *total = COSTS_N_INSNS ((GET_CODE (XEXP (x, 1)) == CONST_INT)\n+                                  ? 4 : 12);\n+          return true;\n+        }\n+      return false;\n+\n+    case ABS:\n+      *total = COSTS_N_INSNS (4);\n+      return true;\n+\n+    case PLUS:\n+    case MINUS:\n+      if (mode == DImode)\n+        {\n+          *total = COSTS_N_INSNS (4);\n+          return true;\n+        }\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case NEG:\n+      if (mode == DImode)\n+        {\n+          *total = COSTS_N_INSNS (4);\n+          return true;\n+        }\n+      return false;\n+\n+    case MULT:\n+      *total = optimize_size ? COSTS_N_INSNS (2) : COSTS_N_INSNS (12);\n+      return true;\n+\n+    case DIV:\n+    case MOD:\n+    case UDIV:\n+    case UMOD:\n+      *total = optimize_size ? COSTS_N_INSNS (2) : COSTS_N_INSNS (33);\n+      return true;\n+\n+    case SIGN_EXTEND:\n+    case ZERO_EXTEND:\n+      switch (GET_MODE (XEXP (x, 0)))\n+        {\n+        case QImode:\n+        case HImode:\n+          if (GET_CODE (XEXP (x, 0)) == MEM)\n+            {\n+              *total = COSTS_N_INSNS (2);\n+\n+              if (!TARGET_LITTLE_ENDIAN &&\n+                  side_effects_p (XEXP (XEXP (x, 0), 0)))\n+                *total = 100;\n+            }\n+          else\n+            *total = COSTS_N_INSNS (1);\n+          break;\n+\n+        default:\n+          *total = COSTS_N_INSNS (1);\n+          break;\n+        }\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Implement TARGET_ADDRESS_COST macro.  */\n+int\n+score3_address_cost (rtx addr)\n+{\n+  return score3_address_insns (addr, SImode);\n+}\n+\n+/* Implement ASM_OUTPUT_EXTERNAL macro.  */\n+int\n+score3_output_external (FILE *file ATTRIBUTE_UNUSED,\n+                        tree decl, const char *name)\n+{\n+  register struct extern_list *p;\n+\n+  if (score3_in_small_data_p (decl))\n+    {\n+      p = (struct extern_list *) ggc_alloc (sizeof (struct extern_list));\n+      p->next = extern_head;\n+      p->name = name;\n+      p->size = int_size_in_bytes (TREE_TYPE (decl));\n+      extern_head = p;\n+    }\n+  return 0;\n+}\n+\n+/* Implement RETURN_ADDR_RTX.  Note, we do not support moving\n+   back to a previous frame.  */\n+rtx\n+score3_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)\n+{\n+  if (count != 0)\n+    return const0_rtx;\n+  return get_hard_reg_initial_val (Pmode, RA_REGNUM);\n+}\n+\n+/* Implement PRINT_OPERAND macro.  */\n+/* Score-specific operand codes:\n+   '['        print .set nor1 directive\n+   ']'        print .set r1 directive\n+   'U'        print hi part of a CONST_INT rtx\n+   'E'        print log2(v)\n+   'F'        print log2(~v)\n+   'D'        print SFmode const double\n+   'S'        selectively print \"!\" if operand is 15bit instruction accessible\n+   'V'        print \"v!\" if operand is 15bit instruction accessible, or \"lfh!\"\n+   'L'        low  part of DImode reg operand\n+   'H'        high part of DImode reg operand\n+   'C'        print part of opcode for a branch condition.  */\n+void\n+score3_print_operand (FILE *file, rtx op, int c)\n+{\n+  enum rtx_code code = -1;\n+  if (!PRINT_OPERAND_PUNCT_VALID_P (c))\n+    code = GET_CODE (op);\n+\n+  if (c == '[')\n+    {\n+      fprintf (file, \".set r1\\n\");\n+    }\n+  else if (c == ']')\n+    {\n+      fprintf (file, \"\\n\\t.set nor1\");\n+    }\n+  else if (c == 'U')\n+    {\n+      gcc_assert (code == CONST_INT);\n+      fprintf (file, HOST_WIDE_INT_PRINT_HEX,\n+               (INTVAL (op) >> 16) & 0xffff);\n+    }\n+  else if (c == 'D')\n+    {\n+      if (GET_CODE (op) == CONST_DOUBLE)\n+        {\n+          rtx temp = gen_lowpart (SImode, op);\n+          gcc_assert (GET_MODE (op) == SFmode);\n+          fprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (temp) & 0xffffffff);\n+        }\n+      else\n+        output_addr_const (file, op);\n+    }\n+  else if (c == 'S')\n+    {\n+      gcc_assert (code == REG);\n+      if (G16_REG_P (REGNO (op)))\n+        fprintf (file, \"!\");\n+    }\n+  else if (c == 'V')\n+    {\n+      gcc_assert (code == REG);\n+      fprintf (file, G16_REG_P (REGNO (op)) ? \"v!\" : \"lfh!\");\n+    }\n+  else if (c == 'C')\n+    {\n+      enum machine_mode mode = GET_MODE (XEXP (op, 0));\n+\n+      switch (code)\n+        {\n+        case EQ: fputs (\"eq!\", file); break;\n+        case NE: fputs (\"ne!\", file); break;\n+        case GT: fputs (\"gt!\", file); break;\n+        case GE: fputs (mode != CCmode ? \"pl\" : \"ge\", file); break;\n+        case LT: fputs (mode != CCmode ? \"mi\" : \"lt\", file); break;\n+        case LE: fputs (\"le!\", file); break;\n+        case GTU: fputs (\"gtu!\", file); break;\n+        case GEU: fputs (\"cs\", file); break;\n+        case LTU: fputs (\"cc\", file); break;\n+        case LEU: fputs (\"leu!\", file); break;\n+        default:\n+          output_operand_lossage (\"invalid operand for code: '%c'\", code);\n+        }\n+    }\n+  else if (c == 'G')  /* Seperate from b<cond>, use for mv<cond>.  */\n+    {\n+      enum machine_mode mode = GET_MODE (XEXP (op, 0));\n+\n+      switch (code)\n+        {\n+        case EQ: fputs (\"eq\", file); break;\n+        case NE: fputs (\"ne\", file); break;\n+        case GT: fputs (\"gt\", file); break;\n+        case GE: fputs (mode != CCmode ? \"pl\" : \"ge\", file); break;\n+        case LT: fputs (mode != CCmode ? \"mi\" : \"lt\", file); break;\n+        case LE: fputs (\"le\", file); break;\n+        case GTU: fputs (\"gtu\", file); break;\n+        case GEU: fputs (\"cs\", file); break;\n+        case LTU: fputs (\"cc\", file); break;\n+        case LEU: fputs (\"leu\", file); break;\n+        default:\n+          output_operand_lossage (\"invalid operand for code: '%c'\", code);\n+        }\n+    }\n+  else if (c == 'E')\n+    {\n+      unsigned HOST_WIDE_INT i;\n+      unsigned HOST_WIDE_INT pow2mask = 1;\n+      unsigned HOST_WIDE_INT val;\n+\n+      val = INTVAL (op);\n+      for (i = 0; i < 32; i++)\n+        {\n+          if (val == pow2mask)\n+            break;\n+          pow2mask <<= 1;\n+        }\n+      gcc_assert (i < 32);\n+      fprintf (file, HOST_WIDE_INT_PRINT_HEX, i);\n+    }\n+  else if (c == 'F')\n+    {\n+      unsigned HOST_WIDE_INT i;\n+      unsigned HOST_WIDE_INT pow2mask = 1;\n+      unsigned HOST_WIDE_INT val;\n+\n+      val = ~INTVAL (op);\n+      for (i = 0; i < 32; i++)\n+        {\n+          if (val == pow2mask)\n+            break;\n+          pow2mask <<= 1;\n+        }\n+      gcc_assert (i < 32);\n+      fprintf (file, HOST_WIDE_INT_PRINT_HEX, i);\n+    }\n+  else if (code == REG)\n+    {\n+      int regnum = REGNO (op);\n+      if ((c == 'H' && !WORDS_BIG_ENDIAN)\n+          || (c == 'L' && WORDS_BIG_ENDIAN))\n+        regnum ++;\n+      fprintf (file, \"%s\", reg_names[regnum]);\n+    }\n+  else\n+    {\n+      switch (code)\n+        {\n+        case MEM:\n+          score3_print_operand_address (file, op);\n+          break;\n+        default:\n+          output_addr_const (file, op);\n+        }\n+    }\n+}\n+\n+/* Implement PRINT_OPERAND_ADDRESS macro.  */\n+void\n+score3_print_operand_address (FILE *file, rtx x)\n+{\n+  struct score3_address_info addr;\n+  enum rtx_code code = GET_CODE (x);\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  if (code == MEM)\n+    x = XEXP (x, 0);\n+\n+  if (score3_classify_address (&addr, mode, x, true))\n+    {\n+      switch (addr.type)\n+        {\n+        case SCORE3_ADD_REG:\n+          {\n+            switch (addr.code)\n+              {\n+              case PRE_DEC:\n+                fprintf (file, \"[%s,-%ld]+\", reg_names[REGNO (addr.reg)],\n+                         INTVAL (addr.offset));\n+                break;\n+              case POST_DEC:\n+                fprintf (file, \"[%s]+,-%ld\", reg_names[REGNO (addr.reg)],\n+                         INTVAL (addr.offset));\n+                break;\n+              case PRE_INC:\n+                fprintf (file, \"[%s, %ld]+\", reg_names[REGNO (addr.reg)],\n+                         INTVAL (addr.offset));\n+                break;\n+              case POST_INC:\n+                fprintf (file, \"[%s]+, %ld\", reg_names[REGNO (addr.reg)],\n+                         INTVAL (addr.offset));\n+                break;\n+              default:\n+                if (INTVAL(addr.offset) == 0)\n+                  fprintf(file, \"[%s]\", reg_names[REGNO (addr.reg)]);\n+                else\n+                  fprintf(file, \"[%s, %ld]\", reg_names[REGNO (addr.reg)],\n+                          INTVAL(addr.offset));\n+                break;\n+              }\n+          }\n+          return;\n+        case SCORE3_ADD_CONST_INT:\n+        case SCORE3_ADD_SYMBOLIC:\n+          output_addr_const (file, x);\n+          return;\n+        }\n+    }\n+  print_rtl (stderr, x);\n+  gcc_unreachable ();\n+}\n+\n+/* Implement SELECT_CC_MODE macro.  */\n+enum machine_mode\n+score3_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n+{\n+  if ((op == EQ || op == NE || op == LT || op == GE)\n+      && y == const0_rtx\n+      && GET_MODE (x) == SImode)\n+    {\n+      switch (GET_CODE (x))\n+        {\n+        case PLUS:\n+        case MINUS:\n+        case NEG:\n+        case AND:\n+        case IOR:\n+        case XOR:\n+        case NOT:\n+        case ASHIFT:\n+        case LSHIFTRT:\n+        case ASHIFTRT:\n+          return CC_NZmode;\n+\n+        case SIGN_EXTEND:\n+        case ZERO_EXTEND:\n+        case ROTATE:\n+        case ROTATERT:\n+          return (op == LT || op == GE) ? CC_Nmode : CCmode;\n+\n+        default:\n+          return CCmode;\n+        }\n+    }\n+\n+  if ((op == EQ || op == NE)\n+      && (GET_CODE (y) == NEG)\n+      && register_operand (XEXP (y, 0), SImode)\n+      && register_operand (x, SImode))\n+    {\n+      return CC_NZmode;\n+    }\n+\n+  return CCmode;\n+}\n+\n+#define EMIT_PL(_rtx)        RTX_FRAME_RELATED_P (_rtx) = 1\n+/* return 0, no more bit set in mask.  */\n+static int rpush_first (int mask, int sb, int *rd)\n+{\n+  int i, cnt = 1;\n+\n+  if ((mask & (1 << sb)) == 0)\n+    return 0;\n+\n+  *rd = sb;\n+\n+  for (i = sb-1; i >= 0; i--)\n+    {\n+      if (mask & (1 << i))\n+        {\n+          cnt ++;\n+          continue;\n+        }\n+\n+      *rd = i+1;\n+      break;;\n+    }\n+\n+  return cnt;\n+}\n+\n+static void\n+rpush (int rd, int cnt)\n+{\n+  rtx mem = gen_rtx_MEM (SImode, gen_rtx_PRE_DEC (SImode, stack_pointer_rtx));\n+  rtx reg = gen_rtx_REG (SImode, rd);\n+\n+  if (!current_function_calls_eh_return)\n+    MEM_READONLY_P (mem) = 1;\n+\n+  if (cnt == 1)\n+    EMIT_PL (emit_insn (gen_pushsi_score3 (mem, reg)));\n+  else\n+    {\n+      int i;\n+      rtx insn = gen_store_multiple (gen_rtx_MEM (SImode, stack_pointer_rtx),\n+                                     gen_rtx_REG (SImode, rd),\n+                                     GEN_INT (cnt));\n+\n+      rtx pat = PATTERN (insn);\n+\n+      for (i = 0; i < XVECLEN (pat, 0); i++)\n+        if (GET_CODE (XVECEXP (pat, 0, i)) == SET)\n+          RTX_FRAME_RELATED_P (XVECEXP (pat, 0, i)) = 1;\n+\n+      EMIT_PL (emit_insn (insn));\n+    }\n+}\n+\n+/* Generate the prologue instructions for entry into a S+core function.  */\n+void\n+score3_prologue (void)\n+{\n+  struct score3_frame_info *f = score3_compute_frame_size (get_frame_size ());\n+  HOST_WIDE_INT size;\n+  int regno;\n+\n+  size = f->total_size - f->gp_reg_size;\n+\n+  if (flag_pic)\n+    emit_insn (gen_cpload_score3 ());\n+\n+  {\n+    int cnt, rd;\n+\n+    for (regno = (int) GP_REG_LAST; regno >= (int) GP_REG_FIRST; regno--)\n+      {\n+        cnt = rpush_first (f->mask, regno, &rd);\n+        if (cnt != 0)\n+          {\n+            rpush (rd, cnt);\n+            regno = regno - cnt;\n+          }\n+      }\n+  }\n+\n+  if (size > 0)\n+    {\n+      rtx insn;\n+\n+      if (CONST_OK_FOR_LETTER_P (-size, 'L'))\n+        EMIT_PL (emit_insn (gen_add3_insn (stack_pointer_rtx,\n+                                           stack_pointer_rtx,\n+                                           GEN_INT (-size))));\n+      else\n+        {\n+          EMIT_PL (emit_move_insn (gen_rtx_REG (Pmode, SCORE3_PROLOGUE_TEMP_REGNUM),\n+                                   GEN_INT (size)));\n+          EMIT_PL (emit_insn\n+                   (gen_sub3_insn (stack_pointer_rtx,\n+                                   stack_pointer_rtx,\n+                                   gen_rtx_REG (Pmode,\n+                                                SCORE3_PROLOGUE_TEMP_REGNUM))));\n+        }\n+      insn = get_last_insn ();\n+      REG_NOTES (insn) =\n+        alloc_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+                         gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+                                      plus_constant (stack_pointer_rtx,\n+                                                     -size)),\n+                                      REG_NOTES (insn));\n+    }\n+\n+  if (frame_pointer_needed)\n+    EMIT_PL (emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx));\n+\n+  if (flag_pic && f->cprestore_size)\n+    {\n+      if (frame_pointer_needed)\n+        emit_insn (gen_cprestore_use_fp_score3 (GEN_INT (size - f->cprestore_size)));\n+      else\n+        emit_insn (gen_cprestore_use_sp_score3 (GEN_INT (size - f->cprestore_size)));\n+    }\n+}\n+\n+/* return 0, no more bit set in mask.  */\n+static int\n+rpop_first (int mask, int sb, int *rd)\n+{\n+  int i, cnt = 1;\n+\n+  if ((mask & (1 << sb)) == 0)\n+    return 0;\n+\n+  *rd = sb;\n+\n+  for (i = sb+1; i < 32; i++)\n+    if (mask & (1 << i))\n+      cnt++;\n+    else\n+      break;;\n+\n+  return cnt;\n+}\n+\n+static void\n+rpop (int rd, int cnt)\n+{\n+  rtx mem = gen_rtx_MEM (SImode, gen_rtx_POST_INC (SImode, stack_pointer_rtx));\n+  rtx reg = gen_rtx_REG (SImode, rd);\n+\n+  if (!current_function_calls_eh_return)\n+    MEM_READONLY_P (mem) = 1;\n+\n+  if (cnt == 1)\n+    emit_insn (gen_popsi_score3 (reg, mem));\n+  else\n+    emit_insn (gen_load_multiple (reg,\n+                                  gen_rtx_MEM (SImode, stack_pointer_rtx),\n+                                  GEN_INT (cnt)));\n+}\n+\n+/* Generate the epilogue instructions in a S+core function.  */\n+void\n+score3_epilogue (int sibcall_p)\n+{\n+  struct score3_frame_info *f = score3_compute_frame_size (get_frame_size ());\n+  HOST_WIDE_INT size;\n+  int regno;\n+  rtx base;\n+\n+  size = f->total_size - f->gp_reg_size;\n+\n+  if (!frame_pointer_needed)\n+    base = stack_pointer_rtx;\n+  else\n+    base = hard_frame_pointer_rtx;\n+\n+  if (size)\n+    {\n+      if (CONST_OK_FOR_LETTER_P (size, 'L'))\n+        emit_insn (gen_add3_insn (base, base, GEN_INT (size)));\n+      else\n+        {\n+          emit_move_insn (gen_rtx_REG (Pmode, SCORE3_EPILOGUE_TEMP_REGNUM),\n+                          GEN_INT (size));\n+          emit_insn (gen_add3_insn (base, base,\n+                                    gen_rtx_REG (Pmode,\n+                                                 SCORE3_EPILOGUE_TEMP_REGNUM)));\n+        }\n+    }\n+\n+  if (base != stack_pointer_rtx)\n+    emit_move_insn (stack_pointer_rtx, base);\n+\n+  if (current_function_calls_eh_return)\n+    emit_insn (gen_add3_insn (stack_pointer_rtx,\n+                              stack_pointer_rtx,\n+                              EH_RETURN_STACKADJ_RTX));\n+\n+  {\n+    int cnt, rd;\n+\n+    for (regno = (int) GP_REG_FIRST; regno <= (int) GP_REG_LAST; regno++)\n+      {\n+        cnt = rpop_first (f->mask, regno, &rd);\n+        if (cnt != 0)\n+          {\n+            rpop (rd, cnt);\n+            regno = regno + cnt;\n+          }\n+      }\n+  }\n+\n+  if (!sibcall_p)\n+    emit_jump_insn (gen_return_internal_score3 (gen_rtx_REG (Pmode, RA_REGNUM)));\n+}\n+\n+void\n+score3_gen_cmp (enum machine_mode mode)\n+{\n+  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, CC_REGNUM),\n+                          gen_rtx_COMPARE (mode, cmp_op0, cmp_op1)));\n+}\n+\n+/* Return true if X is a symbolic constant that can be calculated in\n+   the same way as a bare symbol.  If it is, store the type of the\n+   symbol in *SYMBOL_TYPE.  */\n+int\n+score3_symbolic_constant_p (rtx x, enum score_symbol_type *symbol_type)\n+{\n+  HOST_WIDE_INT offset;\n+\n+  score3_split_const (x, &x, &offset);\n+  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n+    *symbol_type = score3_classify_symbol (x);\n+  else\n+    return 0;\n+\n+  if (offset == 0)\n+    return 1;\n+\n+  /* if offset > 15bit, must reload  */\n+  if (!IMM_IN_RANGE (offset, 15, 1))\n+    return 0;\n+\n+  switch (*symbol_type)\n+    {\n+    case SYMBOL_GENERAL:\n+      return 1;\n+    case SYMBOL_SMALL_DATA:\n+      return score3_offset_within_object_p (x, offset);\n+    }\n+  gcc_unreachable ();\n+}\n+\n+void\n+score3_movsicc (rtx *ops)\n+{\n+  enum machine_mode mode;\n+\n+  mode = score3_select_cc_mode (GET_CODE (ops[1]), ops[2], ops[3]);\n+  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, CC_REGNUM),\n+                          gen_rtx_COMPARE (mode, cmp_op0, cmp_op1)));\n+}\n+\n+/* Call and sibcall pattern all need call this function.  */\n+void\n+score3_call (rtx *ops, bool sib)\n+{\n+  rtx addr = XEXP (ops[0], 0);\n+  if (!call_insn_operand (addr, VOIDmode))\n+    {\n+      rtx oaddr = addr;\n+      addr = gen_reg_rtx (Pmode);\n+      gen_move_insn (addr, oaddr);\n+    }\n+\n+  if (sib)\n+    emit_call_insn (gen_sibcall_internal_score3 (addr, ops[1]));\n+  else\n+    emit_call_insn (gen_call_internal_score3 (addr, ops[1]));\n+}\n+\n+/* Call value and sibcall value pattern all need call this function.  */\n+void\n+score3_call_value (rtx *ops, bool sib)\n+{\n+  rtx result = ops[0];\n+  rtx addr = XEXP (ops[1], 0);\n+  rtx arg = ops[2];\n+\n+  if (!call_insn_operand (addr, VOIDmode))\n+    {\n+      rtx oaddr = addr;\n+      addr = gen_reg_rtx (Pmode);\n+      gen_move_insn (addr, oaddr);\n+    }\n+\n+  if (sib)\n+    emit_call_insn (gen_sibcall_value_internal_score3 (result, addr, arg));\n+  else\n+    emit_call_insn (gen_call_value_internal_score3 (result, addr, arg));\n+}\n+\n+/* Machine Split  */\n+void\n+score3_movdi (rtx *ops)\n+{\n+  rtx dst = ops[0];\n+  rtx src = ops[1];\n+  rtx dst0 = score3_subw (dst, 0);\n+  rtx dst1 = score3_subw (dst, 1);\n+  rtx src0 = score3_subw (src, 0);\n+  rtx src1 = score3_subw (src, 1);\n+\n+  if (GET_CODE (dst0) == REG && reg_overlap_mentioned_p (dst0, src))\n+    {\n+      emit_move_insn (dst1, src1);\n+      emit_move_insn (dst0, src0);\n+    }\n+  else\n+    {\n+      emit_move_insn (dst0, src0);\n+      emit_move_insn (dst1, src1);\n+    }\n+}\n+\n+void\n+score3_zero_extract_andi (rtx *ops)\n+{\n+  if (INTVAL (ops[1]) == 1 && const_uimm5 (ops[2], SImode))\n+    emit_insn (gen_zero_extract_bittst_score3 (ops[0], ops[2]));\n+  else\n+    {\n+      unsigned HOST_WIDE_INT mask;\n+      mask = (0xffffffffU & ((1U << INTVAL (ops[1])) - 1U));\n+      mask = mask << INTVAL (ops[2]);\n+      emit_insn (gen_andsi3_cmp_score3 (ops[3], ops[0],\n+                                        gen_int_mode (mask, SImode)));\n+    }\n+}\n+\n+const char *\n+score3_rpush (rtx *ops)\n+{\n+  snprintf (score3_ins, INS_BUF_SZ, \"rpush!\\t%%1, %d\", XVECLEN (ops[0], 0));\n+  return score3_ins;\n+}\n+\n+const char *\n+score3_rpop (rtx *ops)\n+{\n+  snprintf (score3_ins, INS_BUF_SZ, \"rpop!\\t%%1, %d\", XVECLEN (ops[0], 0));\n+  return score3_ins;\n+}\n+\n+/* Output asm code for ld/sw insn.  */\n+static int\n+score3_pr_addr_post (rtx *ops, int idata, int iaddr, char *ip,\n+                     enum score_mem_unit unit ATTRIBUTE_UNUSED)\n+{\n+  struct score3_address_info ai;\n+\n+  gcc_assert (GET_CODE (ops[idata]) == REG);\n+  gcc_assert (score3_classify_address (&ai, SImode, XEXP (ops[iaddr], 0), true));\n+\n+  if (ai.type == SCORE3_ADD_REG\n+      && ai.code == REG\n+      && GET_CODE (ai.offset) == CONST_INT\n+      && G16_REG_P (REGNO (ops[idata]))\n+      && G8_REG_P (REGNO (ai.reg))\n+      && ((INTVAL (ai.offset) & 3) == 0)\n+      && (IMM_IN_RANGE (INTVAL (ai.offset), 7, 0)))\n+    {\n+      ops[iaddr] = ai.reg;\n+      return snprintf (ip, INS_BUF_SZ, \"!\\t%%%d, [%%%d, \"\n+                       HOST_WIDE_INT_PRINT_DEC \"]\",\n+                       idata, iaddr, INTVAL (ai.offset));\n+    }\n+\n+  if (ai.type == SCORE3_ADD_SYMBOLIC)\n+    return snprintf (ip, INS_BUF_SZ, \"48\\t%%%d, %%a%d\", idata, iaddr);\n+\n+  return snprintf (ip, INS_BUF_SZ, \"\\t%%%d, %%a%d\", idata, iaddr);\n+}\n+\n+/* Output asm insn for load.  */\n+const char *\n+score3_linsn (rtx *ops, enum score_mem_unit unit, bool sign)\n+{\n+  const char *pre_ins[] =\n+    {\"lbu\", \"lhu\", \"lw\", \"??\", \"lb\", \"lh\", \"lw\", \"??\"};\n+  char *ip;\n+\n+  strcpy (score3_ins, pre_ins[(sign ? 4 : 0) + unit]);\n+  ip = score3_ins + strlen (score3_ins);\n+\n+  if (unit == SCORE_WORD)\n+    score3_pr_addr_post (ops, 0, 1, ip, unit);\n+  else\n+    snprintf (ip, INS_BUF_SZ, \"\\t%%0, %%a1\");\n+\n+  return score3_ins;\n+}\n+\n+/* Output asm insn for store.  */\n+const char *\n+score3_sinsn (rtx *ops, enum score_mem_unit unit)\n+{\n+  const char *pre_ins[] = {\"sb\", \"sh\", \"sw\"};\n+  char *ip;\n+\n+  strcpy (score3_ins, pre_ins[unit]);\n+  ip = score3_ins + strlen (score3_ins);\n+\n+  if (unit == SCORE_WORD)\n+    score3_pr_addr_post (ops, 1, 0, ip, unit);\n+  else\n+    snprintf (ip, INS_BUF_SZ, \"\\t%%1, %%a0\");\n+\n+  return score3_ins;\n+}\n+\n+/* Output asm insn for load immediate.  */\n+const char *\n+score3_limm (rtx *ops)\n+{\n+  HOST_WIDE_INT v;\n+\n+  gcc_assert (GET_CODE (ops[0]) == REG);\n+  gcc_assert (GET_CODE (ops[1]) == CONST_INT);\n+\n+  v = INTVAL (ops[1]);\n+  if (G16_REG_P (REGNO (ops[0])) && IMM_IN_RANGE (v, 5, 0))\n+    return \"ldiu!\\t%0, %c1\";\n+  else if (IMM_IN_RANGE (v, 16, 1))\n+    return \"ldi\\t%0, %c1\";\n+  else if ((v & 0xffff) == 0)\n+    return \"ldis\\t%0, %U1\";\n+  else\n+    return \"li\\t%0, %c1\";\n+}\n+\n+/* Output asm insn for move.  */\n+const char *\n+score3_move (rtx *ops)\n+{\n+  gcc_assert (GET_CODE (ops[0]) == REG);\n+  gcc_assert (GET_CODE (ops[1]) == REG);\n+\n+  return \"mv!\\t%0, %1\";\n+}\n+\n+/* Generate add insn.  */\n+const char *\n+score3_select_add_imm (rtx *ops, bool set_cc)\n+{\n+  HOST_WIDE_INT v = INTVAL (ops[2]);\n+\n+  gcc_assert (GET_CODE (ops[2]) == CONST_INT);\n+  gcc_assert (REGNO (ops[0]) == REGNO (ops[1]));\n+\n+  if (set_cc)\n+    return \"addi.c\\t%0, %c2\";\n+  else\n+    if (IMM_IN_RANGE (v, 6, 1) && G16_REG_P (REGNO (ops[0])))\n+      return \"addi!\\t%0, %c2\";\n+    else\n+      return \"addi\\t%0, %c2\";\n+}\n+\n+/* Output arith insn.  */\n+const char *\n+score3_select (rtx *ops, const char *inst_pre, bool commu ATTRIBUTE_UNUSED,\n+               const char *letter, bool set_cc)\n+{\n+  gcc_assert (GET_CODE (ops[0]) == REG);\n+  gcc_assert (GET_CODE (ops[1]) == REG);\n+\n+  if (set_cc)\n+    snprintf (score3_ins, INS_BUF_SZ, \"%s.c\\t%%0, %%1, %%%s2\", inst_pre, letter);\n+  else\n+    snprintf (score3_ins, INS_BUF_SZ, \"%s\\t%%0, %%1, %%%s2\", inst_pre, letter);\n+  return score3_ins;\n+}\n+\n+/* Output a Score3 casesi instruction.  */\n+const char *\n+score3_output_casesi (rtx *operands)\n+{\n+  rtx diff_vec = PATTERN (next_real_insn (operands[2]));\n+  gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n+\n+  output_asm_insn (\"cmpi.c\\t%0, %1\", operands);\n+  output_asm_insn (\"bgtu\\t%3\", operands);\n+  switch (GET_MODE(diff_vec))\n+    {\n+    case QImode:\n+      output_asm_insn (\"ldi48\\t%4, %2\", operands);\n+      output_asm_insn (\"ltbb\\t%4, [%4, %0]\\n%2_tbb:\", operands);\n+      return \"brr!\\t%4\";\n+    case HImode:\n+      output_asm_insn (\"ldi48\\t%4, %2\", operands);\n+      output_asm_insn (\"ltbh\\t%4, [%4, %0]\\n%2_tbb:\", operands);\n+      return \"brr!\\t%4\";\n+    case SImode:\n+      output_asm_insn (\"ldi48\\t%4, %2\", operands);\n+      output_asm_insn (\"ltbw\\t%4, [%4, %0]\", operands);\n+      return \"br!\\t%4\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}"}, {"sha": "098da9500d2b8160522195af7e6846b75327fb1c", "filename": "gcc/config/score/score3.h", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore3.h?ref=254f522229578af1af093b2e4b6f1a0cc400d216", "patch": "@@ -0,0 +1,159 @@\n+/* score3.h for Sunplus S+CORE processor\n+   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+   Contributed by Sunnorth\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_SCORE3_H\n+#define GCC_SCORE3_H\n+\n+enum score3_address_type\n+{\n+  SCORE3_ADD_REG,\n+  SCORE3_ADD_CONST_INT,\n+  SCORE3_ADD_SYMBOLIC\n+};\n+\n+struct score3_frame_info\n+{\n+  HOST_WIDE_INT total_size;       /* bytes that the entire frame takes up  */\n+  HOST_WIDE_INT var_size;         /* bytes that variables take up  */\n+  HOST_WIDE_INT args_size;        /* bytes that outgoing arguments take up  */\n+  HOST_WIDE_INT gp_reg_size;      /* bytes needed to store gp regs  */\n+  HOST_WIDE_INT gp_sp_offset;     /* offset from new sp to store gp registers  */\n+  HOST_WIDE_INT cprestore_size;   /* # bytes that the .cprestore slot takes up  */\n+  unsigned int  mask;             /* mask of saved gp registers  */\n+  int num_gp;                     /* number of gp registers saved  */\n+};\n+\n+struct score3_arg_info\n+{\n+  unsigned int num_bytes;     /* The argument's size in bytes  */\n+  unsigned int reg_words;     /* The number of words passed in registers  */\n+  unsigned int reg_offset;    /* The offset of the first register from  */\n+                              /* GP_ARG_FIRST or FP_ARG_FIRST etc  */\n+  unsigned int stack_words;   /* The number of words that must be passed  */\n+                              /* on the stack  */\n+  unsigned int stack_offset;  /* The offset from the start of the stack  */\n+                              /* overflow area  */\n+};\n+\n+#ifdef RTX_CODE\n+struct score3_address_info\n+{\n+  enum score3_address_type type;\n+  rtx reg;\n+  rtx offset;\n+  enum rtx_code code;\n+  enum score_symbol_type symbol_type;\n+};\n+#endif\n+\n+#define SCORE3_SDATA_MAX                score3_sdata_max\n+#define SCORE3_STACK_ALIGN(LOC)         (((LOC) + 3) & ~3)\n+#define SCORE3_PROLOGUE_TEMP_REGNUM     (GP_REG_FIRST + 8)\n+#define SCORE3_EPILOGUE_TEMP_REGNUM     (GP_REG_FIRST + 8)\n+#define SCORE3_DEFAULT_SDATA_MAX        8\n+\n+extern int score3_symbolic_constant_p (rtx x,\n+                                       enum score_symbol_type *symbol_type);\n+extern bool score3_return_in_memory (tree type,\n+                                     tree fndecl ATTRIBUTE_UNUSED);\n+extern void score3_output_mi_thunk (FILE *file,\n+                                    tree thunk_fndecl ATTRIBUTE_UNUSED,\n+                                    HOST_WIDE_INT delta,\n+                                    HOST_WIDE_INT vcall_offset,\n+                                    tree function);\n+extern int score3_legitimize_address (rtx *xloc);\n+extern void\n+score3_function_prologue (FILE *file,\n+                          HOST_WIDE_INT size ATTRIBUTE_UNUSED);\n+extern void\n+score3_function_epilogue (FILE *file,\n+                          HOST_WIDE_INT size ATTRIBUTE_UNUSED);\n+extern section *score3_select_rtx_section (enum machine_mode mode, rtx x,\n+                                           unsigned HOST_WIDE_INT align);\n+extern bool score3_in_small_data_p (tree decl);\n+extern void score3_asm_file_start (void);\n+extern void score3_asm_file_end (void);\n+extern void score3_override_options (void);\n+extern int score3_reg_class (int regno);\n+extern enum reg_class score3_preferred_reload_class (rtx x ATTRIBUTE_UNUSED,\n+                                                     enum reg_class class);\n+extern enum reg_class\n+score3_secondary_reload_class (enum reg_class class,\n+                               enum machine_mode mode ATTRIBUTE_UNUSED,\n+                               rtx x);\n+extern int score3_const_ok_for_letter_p (HOST_WIDE_INT value, char c);\n+extern int score3_extra_constraint (rtx op, char c);\n+extern int score3_hard_regno_mode_ok (unsigned int regno,\n+                                      enum machine_mode mode);\n+extern HOST_WIDE_INT\n+score3_initial_elimination_offset (int from,\n+                                   int to ATTRIBUTE_UNUSED);\n+extern void score3_function_arg_advance (CUMULATIVE_ARGS *cum,\n+                                         enum machine_mode mode,\n+                                         tree type,\n+                                         int named);\n+extern int score3_arg_partial_bytes (CUMULATIVE_ARGS *cum,\n+                                     enum machine_mode mode,\n+                                     tree type,\n+                                     bool named);\n+extern rtx score3_function_arg (const CUMULATIVE_ARGS *cum,\n+                                enum machine_mode mode,\n+                                tree type,\n+                                int named);\n+extern rtx score3_function_value (tree valtype,\n+                                  tree func ATTRIBUTE_UNUSED,\n+                                  enum machine_mode mode);\n+extern void score3_initialize_trampoline (rtx ADDR, rtx FUNC, rtx CHAIN);\n+extern int score3_regno_mode_ok_for_base_p (int regno, int strict);\n+extern int score3_address_p (enum machine_mode mode, rtx x, int strict);\n+extern int score3_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+                                      enum reg_class from,\n+                                      enum reg_class to);\n+extern bool score3_rtx_costs (rtx x, int code, int outer_code, int *total);\n+extern int score3_address_cost (rtx addr);\n+extern int score3_output_external (FILE *file ATTRIBUTE_UNUSED,\n+                                   tree decl,\n+                                   const char *name);\n+extern rtx score3_return_addr (int count, rtx frame ATTRIBUTE_UNUSED);\n+extern void score3_print_operand (FILE *file, rtx op, int c);\n+extern void score3_print_operand_address (FILE *file, rtx x);\n+extern enum machine_mode\n+score3_select_cc_mode (enum rtx_code op, rtx x, rtx y);\n+extern void score3_prologue (void);\n+extern void score3_epilogue (int sibcall_p);\n+extern void score3_gen_cmp (enum machine_mode mode);\n+extern void score3_call (rtx *ops, bool sib);\n+extern void score3_call_value (rtx *ops, bool sib);\n+extern void score3_movsicc (rtx *ops);\n+extern void score3_movdi (rtx *ops);\n+extern void score3_zero_extract_andi (rtx *ops);\n+extern const char * score3_select_add_imm (rtx *ops, bool set_cc);\n+extern const char * score3_select (rtx *ops, const char *inst_pre, bool commu,\n+                                   const char *letter, bool set_cc);\n+extern const char * score3_move (rtx *ops);\n+extern const char * score3_limm (rtx *ops);\n+extern const char *\n+score3_linsn (rtx *ops, enum score_mem_unit unit, bool sign);\n+extern const char *\n+score3_sinsn (rtx *ops, enum score_mem_unit unit);\n+extern const char * score3_output_casesi (rtx *operands);\n+extern const char * score3_rpush (rtx *ops);\n+extern const char * score3_rpop (rtx *ops);\n+#endif"}, {"sha": "34271cc36b29a1ac7b138c49901cb7d23205a592", "filename": "gcc/config/score/score7.c", "status": "added", "additions": 1849, "deletions": 0, "changes": 1849, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.c?ref=254f522229578af1af093b2e4b6f1a0cc400d216", "patch": "@@ -0,0 +1,1849 @@\n+/* score7.c for Sunplus S+CORE processor\n+   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+   Contributed by Sunnorth\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-attr.h\"\n+#include \"recog.h\"\n+#include \"toplev.h\"\n+#include \"output.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"flags.h\"\n+#include \"reload.h\"\n+#include \"tm_p.h\"\n+#include \"ggc.h\"\n+#include \"gstab.h\"\n+#include \"hashtab.h\"\n+#include \"debug.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"integrate.h\"\n+#include \"langhooks.h\"\n+#include \"cfglayout.h\"\n+#include \"score7.h\"\n+\n+#define BITSET_P(VALUE, BIT)      (((VALUE) & (1L << (BIT))) != 0)\n+#define INS_BUF_SZ                128\n+\n+/* Define the information needed to generate branch insns.  This is\n+   stored from the compare operation.  */\n+extern rtx cmp_op0, cmp_op1;\n+extern enum reg_class score_char_to_class[256];\n+\n+static int score7_sdata_max;\n+static char score7_ins[INS_BUF_SZ + 8];\n+\n+/* Return true if SYMBOL is a SYMBOL_REF and OFFSET + SYMBOL points\n+   to the same object as SYMBOL.  */\n+static int\n+score7_offset_within_object_p (rtx symbol, HOST_WIDE_INT offset)\n+{\n+  if (GET_CODE (symbol) != SYMBOL_REF)\n+    return 0;\n+\n+  if (CONSTANT_POOL_ADDRESS_P (symbol)\n+      && offset >= 0\n+      && offset < (int)GET_MODE_SIZE (get_pool_mode (symbol)))\n+    return 1;\n+\n+  if (SYMBOL_REF_DECL (symbol) != 0\n+      && offset >= 0\n+      && offset < int_size_in_bytes (TREE_TYPE (SYMBOL_REF_DECL (symbol))))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Split X into a base and a constant offset, storing them in *BASE\n+   and *OFFSET respectively.  */\n+static void\n+score7_split_const (rtx x, rtx *base, HOST_WIDE_INT *offset)\n+{\n+  *offset = 0;\n+\n+  if (GET_CODE (x) == CONST)\n+    x = XEXP (x, 0);\n+\n+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    {\n+      *offset += INTVAL (XEXP (x, 1));\n+      x = XEXP (x, 0);\n+    }\n+\n+  *base = x;\n+}\n+\n+/* Classify symbol X, which must be a SYMBOL_REF or a LABEL_REF.  */\n+static enum score_symbol_type\n+score7_classify_symbol (rtx x)\n+{\n+  if (GET_CODE (x) == LABEL_REF)\n+    return SYMBOL_GENERAL;\n+\n+  gcc_assert (GET_CODE (x) == SYMBOL_REF);\n+\n+  if (CONSTANT_POOL_ADDRESS_P (x))\n+    {\n+      if (GET_MODE_SIZE (get_pool_mode (x)) <= SCORE7_SDATA_MAX)\n+        return SYMBOL_SMALL_DATA;\n+      return SYMBOL_GENERAL;\n+    }\n+  if (SYMBOL_REF_SMALL_P (x))\n+    return SYMBOL_SMALL_DATA;\n+  return SYMBOL_GENERAL;\n+}\n+\n+/* Return true if the current function must save REGNO.  */\n+static int\n+score7_save_reg_p (unsigned int regno)\n+{\n+  /* Check call-saved registers.  */\n+  if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n+    return 1;\n+\n+  /* We need to save the old frame pointer before setting up a new one.  */\n+  if (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\n+    return 1;\n+\n+  /* We need to save the incoming return address if it is ever clobbered\n+     within the function.  */\n+  if (regno == RA_REGNUM && df_regs_ever_live_p (regno))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return one word of double-word value OP, taking into account the fixed\n+   endianness of certain registers.  HIGH_P is true to select the high part,\n+   false to select the low part.  */\n+static rtx\n+score7_subw (rtx op, int high_p)\n+{\n+  unsigned int byte;\n+  enum machine_mode mode = GET_MODE (op);\n+\n+  if (mode == VOIDmode)\n+    mode = DImode;\n+\n+  byte = (TARGET_LITTLE_ENDIAN ? high_p : !high_p) ? UNITS_PER_WORD : 0;\n+\n+  if (GET_CODE (op) == REG && REGNO (op) == HI_REGNUM)\n+    return gen_rtx_REG (SImode, high_p ? HI_REGNUM : LO_REGNUM);\n+\n+  if (GET_CODE (op) == MEM)\n+    return adjust_address (op, SImode, byte);\n+\n+  return simplify_gen_subreg (SImode, op, mode, byte);\n+}\n+\n+static struct score7_frame_info *\n+score7_cached_frame (void)\n+{\n+  static struct score7_frame_info _frame_info;\n+  return &_frame_info;\n+}\n+\n+/* Return the bytes needed to compute the frame pointer from the current\n+   stack pointer.  SIZE is the size (in bytes) of the local variables.  */\n+static struct score7_frame_info *\n+score7_compute_frame_size (HOST_WIDE_INT size)\n+{\n+  unsigned int regno;\n+  struct score7_frame_info *f = score7_cached_frame ();\n+\n+  memset (f, 0, sizeof (struct score7_frame_info));\n+  f->gp_reg_size = 0;\n+  f->mask = 0;\n+  f->var_size = SCORE7_STACK_ALIGN (size);\n+  f->args_size = current_function_outgoing_args_size;\n+  f->cprestore_size = flag_pic ? UNITS_PER_WORD : 0;\n+  if (f->var_size == 0 && current_function_is_leaf)\n+    f->args_size = f->cprestore_size = 0;\n+\n+  if (f->args_size == 0 && current_function_calls_alloca)\n+    f->args_size = UNITS_PER_WORD;\n+\n+  f->total_size = f->var_size + f->args_size + f->cprestore_size;\n+  for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n+    {\n+      if (score7_save_reg_p (regno))\n+        {\n+          f->gp_reg_size += GET_MODE_SIZE (SImode);\n+          f->mask |= 1 << (regno - GP_REG_FIRST);\n+        }\n+    }\n+\n+  if (current_function_calls_eh_return)\n+    {\n+      unsigned int i;\n+      for (i = 0;; ++i)\n+        {\n+          regno = EH_RETURN_DATA_REGNO (i);\n+          if (regno == INVALID_REGNUM)\n+            break;\n+          f->gp_reg_size += GET_MODE_SIZE (SImode);\n+          f->mask |= 1 << (regno - GP_REG_FIRST);\n+        }\n+    }\n+\n+  f->total_size += f->gp_reg_size;\n+  f->num_gp = f->gp_reg_size / UNITS_PER_WORD;\n+\n+  if (f->mask)\n+    {\n+      HOST_WIDE_INT offset;\n+      offset = (f->args_size + f->cprestore_size + f->var_size\n+                + f->gp_reg_size - GET_MODE_SIZE (SImode));\n+      f->gp_sp_offset = offset;\n+    }\n+  else\n+    f->gp_sp_offset = 0;\n+\n+  return f;\n+}\n+\n+/* Return true if X is a valid base register for the given mode.\n+   Allow only hard registers if STRICT.  */\n+static int\n+score7_valid_base_register_p (rtx x, int strict)\n+{\n+  if (!strict && GET_CODE (x) == SUBREG)\n+    x = SUBREG_REG (x);\n+\n+  return (GET_CODE (x) == REG\n+          && score7_regno_mode_ok_for_base_p (REGNO (x), strict));\n+}\n+\n+/* Return true if X is a valid address for machine mode MODE.  If it is,\n+   fill in INFO appropriately.  STRICT is true if we should only accept\n+   hard base registers.  */\n+static int\n+score7_classify_address (struct score7_address_info *info,\n+                         enum machine_mode mode, rtx x, int strict)\n+{\n+  info->code = GET_CODE (x);\n+\n+  switch (info->code)\n+    {\n+    case REG:\n+    case SUBREG:\n+      info->type = SCORE7_ADD_REG;\n+      info->reg = x;\n+      info->offset = const0_rtx;\n+      return score7_valid_base_register_p (info->reg, strict);\n+    case PLUS:\n+      info->type = SCORE7_ADD_REG;\n+      info->reg = XEXP (x, 0);\n+      info->offset = XEXP (x, 1);\n+      return (score7_valid_base_register_p (info->reg, strict)\n+              && GET_CODE (info->offset) == CONST_INT\n+              && IMM_IN_RANGE (INTVAL (info->offset), 15, 1));\n+    case PRE_DEC:\n+    case POST_DEC:\n+    case PRE_INC:\n+    case POST_INC:\n+      if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (SImode))\n+        return false;\n+      info->type = SCORE7_ADD_REG;\n+      info->reg = XEXP (x, 0);\n+      info->offset = GEN_INT (GET_MODE_SIZE (mode));\n+      return score7_valid_base_register_p (info->reg, strict);\n+    case CONST_INT:\n+      info->type = SCORE7_ADD_CONST_INT;\n+      return IMM_IN_RANGE (INTVAL (x), 15, 1);\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      info->type = SCORE7_ADD_SYMBOLIC;\n+      return (score7_symbolic_constant_p (x, &info->symbol_type)\n+              && (info->symbol_type == SYMBOL_GENERAL\n+                  || info->symbol_type == SYMBOL_SMALL_DATA));\n+    default:\n+      return 0;\n+    }\n+}\n+\n+bool\n+score7_return_in_memory (tree type, tree fndecl ATTRIBUTE_UNUSED)\n+{\n+    return ((TYPE_MODE (type) == BLKmode)\n+            || (int_size_in_bytes (type) > 2 * UNITS_PER_WORD)\n+            || (int_size_in_bytes (type) == -1));\n+}\n+\n+/* Return a legitimate address for REG + OFFSET.  */\n+static rtx\n+score7_add_offset (rtx reg, HOST_WIDE_INT offset)\n+{\n+  if (!IMM_IN_RANGE (offset, 15, 1))\n+    {\n+      reg = expand_simple_binop (GET_MODE (reg), PLUS,\n+                                 gen_int_mode (offset & 0xffffc000,\n+                                               GET_MODE (reg)),\n+                                 reg, NULL, 0, OPTAB_WIDEN);\n+      offset &= 0x3fff;\n+    }\n+\n+  return plus_constant (reg, offset);\n+}\n+\n+/* Implement TARGET_ASM_OUTPUT_MI_THUNK.  Generate rtl rather than asm text\n+   in order to avoid duplicating too much logic from elsewhere.  */\n+void\n+score7_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n+                        HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n+                        tree function)\n+{\n+  rtx this, temp1, insn, fnaddr;\n+\n+  /* Pretend to be a post-reload pass while generating rtl.  */\n+  reload_completed = 1;\n+\n+  /* Mark the end of the (empty) prologue.  */\n+  emit_note (NOTE_INSN_PROLOGUE_END);\n+\n+  /* We need two temporary registers in some cases.  */\n+  temp1 = gen_rtx_REG (Pmode, 8);\n+\n+  /* Find out which register contains the \"this\" pointer.  */\n+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n+    this = gen_rtx_REG (Pmode, ARG_REG_FIRST + 1);\n+  else\n+    this = gen_rtx_REG (Pmode, ARG_REG_FIRST);\n+\n+  /* Add DELTA to THIS.  */\n+  if (delta != 0)\n+    {\n+      rtx offset = GEN_INT (delta);\n+      if (!CONST_OK_FOR_LETTER_P (delta, 'L'))\n+        {\n+          emit_move_insn (temp1, offset);\n+          offset = temp1;\n+        }\n+      emit_insn (gen_add3_insn (this, this, offset));\n+    }\n+\n+  /* If needed, add *(*THIS + VCALL_OFFSET) to THIS.  */\n+  if (vcall_offset != 0)\n+    {\n+      rtx addr;\n+\n+      /* Set TEMP1 to *THIS.  */\n+      emit_move_insn (temp1, gen_rtx_MEM (Pmode, this));\n+\n+      /* Set ADDR to a legitimate address for *THIS + VCALL_OFFSET.  */\n+      addr = score7_add_offset (temp1, vcall_offset);\n+\n+      /* Load the offset and add it to THIS.  */\n+      emit_move_insn (temp1, gen_rtx_MEM (Pmode, addr));\n+      emit_insn (gen_add3_insn (this, this, temp1));\n+    }\n+\n+  /* Jump to the target function.  */\n+  fnaddr = XEXP (DECL_RTL (function), 0);\n+  insn = emit_call_insn (gen_sibcall_internal_score7 (fnaddr, const0_rtx));\n+  SIBLING_CALL_P (insn) = 1;\n+\n+  /* Run just enough of rest_of_compilation.  This sequence was\n+     \"borrowed\" from alpha.c.  */\n+  insn = get_insns ();\n+  insn_locators_alloc ();\n+  split_all_insns_noflow ();\n+  shorten_branches (insn);\n+  final_start_function (insn, file, 1);\n+  final (insn, file, 1);\n+  final_end_function ();\n+\n+  /* Clean up the vars set above.  Note that final_end_function resets\n+     the global pointer for us.  */\n+  reload_completed = 0;\n+}\n+\n+/* Copy VALUE to a register and return that register.  If new psuedos\n+   are allowed, copy it into a new register, otherwise use DEST.  */\n+static rtx\n+score7_force_temporary (rtx dest, rtx value)\n+{\n+  if (can_create_pseudo_p ())\n+    return force_reg (Pmode, value);\n+  else\n+    {\n+      emit_move_insn (copy_rtx (dest), value);\n+      return dest;\n+    }\n+}\n+\n+/* Return a LO_SUM expression for ADDR.  TEMP is as for score_force_temporary\n+   and is used to load the high part into a register.  */\n+static rtx\n+score7_split_symbol (rtx temp, rtx addr)\n+{\n+  rtx high = score7_force_temporary (temp,\n+                                     gen_rtx_HIGH (Pmode, copy_rtx (addr)));\n+  return gen_rtx_LO_SUM (Pmode, high, addr);\n+}\n+\n+/* This function is used to implement LEGITIMIZE_ADDRESS.  If *XLOC can\n+   be legitimized in a way that the generic machinery might not expect,\n+   put the new address in *XLOC and return true.  */\n+int\n+score7_legitimize_address (rtx *xloc)\n+{\n+  enum score_symbol_type symbol_type;\n+\n+  if (score7_symbolic_constant_p (*xloc, &symbol_type)\n+      && symbol_type == SYMBOL_GENERAL)\n+    {\n+      *xloc = score7_split_symbol (0, *xloc);\n+      return 1;\n+    }\n+\n+  if (GET_CODE (*xloc) == PLUS\n+      && GET_CODE (XEXP (*xloc, 1)) == CONST_INT)\n+    {\n+      rtx reg = XEXP (*xloc, 0);\n+      if (!score7_valid_base_register_p (reg, 0))\n+        reg = copy_to_mode_reg (Pmode, reg);\n+      *xloc = score7_add_offset (reg, INTVAL (XEXP (*xloc, 1)));\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Fill INFO with information about a single argument.  CUM is the\n+   cumulative state for earlier arguments.  MODE is the mode of this\n+   argument and TYPE is its type (if known).  NAMED is true if this\n+   is a named (fixed) argument rather than a variable one.  */\n+static void\n+score7_classify_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+                     tree type, int named, struct score7_arg_info *info)\n+{\n+  int even_reg_p;\n+  unsigned int num_words, max_regs;\n+\n+  even_reg_p = 0;\n+  if (GET_MODE_CLASS (mode) == MODE_INT\n+      || GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    even_reg_p = (GET_MODE_SIZE (mode) > UNITS_PER_WORD);\n+  else\n+    if (type != NULL_TREE && TYPE_ALIGN (type) > BITS_PER_WORD && named)\n+      even_reg_p = 1;\n+\n+  if (TARGET_MUST_PASS_IN_STACK (mode, type))\n+    info->reg_offset = ARG_REG_NUM;\n+  else\n+    {\n+      info->reg_offset = cum->num_gprs;\n+      if (even_reg_p)\n+        info->reg_offset += info->reg_offset & 1;\n+    }\n+\n+  if (mode == BLKmode)\n+    info->num_bytes = int_size_in_bytes (type);\n+  else\n+    info->num_bytes = GET_MODE_SIZE (mode);\n+\n+  num_words = (info->num_bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  max_regs = ARG_REG_NUM - info->reg_offset;\n+\n+  /* Partition the argument between registers and stack.  */\n+  info->reg_words = MIN (num_words, max_regs);\n+  info->stack_words = num_words - info->reg_words;\n+\n+  /* The alignment applied to registers is also applied to stack arguments.  */\n+  if (info->stack_words)\n+    {\n+      info->stack_offset = cum->stack_words;\n+      if (even_reg_p)\n+        info->stack_offset += info->stack_offset & 1;\n+    }\n+}\n+\n+/* Set up the stack and frame (if desired) for the function.  */\n+void\n+score7_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n+{\n+  const char *fnname;\n+  struct score7_frame_info *f = score7_cached_frame ();\n+  HOST_WIDE_INT tsize = f->total_size;\n+\n+  fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n+  if (!flag_inhibit_size_directive)\n+    {\n+      fputs (\"\\t.ent\\t\", file);\n+      assemble_name (file, fnname);\n+      fputs (\"\\n\", file);\n+    }\n+  assemble_name (file, fnname);\n+  fputs (\":\\n\", file);\n+\n+  if (!flag_inhibit_size_directive)\n+    {\n+      fprintf (file,\n+               \"\\t.frame\\t%s,\" HOST_WIDE_INT_PRINT_DEC \",%s, %d\\t\\t\"\n+               \"# vars= \" HOST_WIDE_INT_PRINT_DEC \", regs= %d\"\n+               \", args= \" HOST_WIDE_INT_PRINT_DEC\n+               \", gp= \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+               (reg_names[(frame_pointer_needed)\n+                ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM]),\n+               tsize,\n+               reg_names[RA_REGNUM],\n+               current_function_is_leaf ? 1 : 0,\n+               f->var_size,\n+               f->num_gp,\n+               f->args_size,\n+               f->cprestore_size);\n+\n+      fprintf(file, \"\\t.mask\\t0x%08x,\" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+              f->mask,\n+              (f->gp_sp_offset - f->total_size));\n+    }\n+}\n+\n+/* Do any necessary cleanup after a function to restore stack, frame,\n+   and regs.  */\n+void\n+score7_function_epilogue (FILE *file,\n+                          HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n+{\n+  if (!flag_inhibit_size_directive)\n+    {\n+      const char *fnname;\n+      fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n+      fputs (\"\\t.end\\t\", file);\n+      assemble_name (file, fnname);\n+      fputs (\"\\n\", file);\n+    }\n+}\n+\n+/* Returns true if X contains a SYMBOL_REF.  */\n+static bool\n+score7_symbolic_expression_p (rtx x)\n+{\n+  if (GET_CODE (x) == SYMBOL_REF)\n+    return true;\n+\n+  if (GET_CODE (x) == CONST)\n+    return score7_symbolic_expression_p (XEXP (x, 0));\n+\n+  if (UNARY_P (x))\n+    return score7_symbolic_expression_p (XEXP (x, 0));\n+\n+  if (ARITHMETIC_P (x))\n+    return (score7_symbolic_expression_p (XEXP (x, 0))\n+            || score7_symbolic_expression_p (XEXP (x, 1)));\n+\n+  return false;\n+}\n+\n+/* Choose the section to use for the constant rtx expression X that has\n+   mode MODE.  */\n+section *\n+score7_select_rtx_section (enum machine_mode mode, rtx x,\n+                           unsigned HOST_WIDE_INT align)\n+{\n+  if (GET_MODE_SIZE (mode) <= SCORE7_SDATA_MAX)\n+    return get_named_section (0, \".sdata\", 0);\n+  else if (flag_pic && score7_symbolic_expression_p (x))\n+    return get_named_section (0, \".data.rel.ro\", 3);\n+  else\n+    return mergeable_constant_section (mode, align, 0);\n+}\n+\n+/* Implement TARGET_IN_SMALL_DATA_P.  */\n+bool\n+score7_in_small_data_p (tree decl)\n+{\n+  HOST_WIDE_INT size;\n+\n+  if (TREE_CODE (decl) == STRING_CST\n+      || TREE_CODE (decl) == FUNCTION_DECL)\n+    return false;\n+\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_SECTION_NAME (decl) != 0)\n+    {\n+      const char *name;\n+      name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n+      if (strcmp (name, \".sdata\") != 0\n+          && strcmp (name, \".sbss\") != 0)\n+        return true;\n+      if (!DECL_EXTERNAL (decl))\n+        return false;\n+    }\n+  size = int_size_in_bytes (TREE_TYPE (decl));\n+  return (size > 0 && size <= SCORE7_SDATA_MAX);\n+}\n+\n+/* Implement TARGET_ASM_FILE_START.  */\n+void\n+score7_asm_file_start (void)\n+{\n+  default_file_start ();\n+  fprintf (asm_out_file, ASM_COMMENT_START\n+           \"GCC for S+core %s \\n\", SCORE_GCC_VERSION);\n+\n+  if (flag_pic)\n+    fprintf (asm_out_file, \"\\t.set pic\\n\");\n+}\n+\n+/* Implement TARGET_ASM_FILE_END.  When using assembler macros, emit\n+   .externs for any small-data variables that turned out to be external.  */\n+void\n+score7_asm_file_end (void)\n+{\n+  tree name_tree;\n+  struct extern_list *p;\n+  if (extern_head)\n+    {\n+      fputs (\"\\n\", asm_out_file);\n+      for (p = extern_head; p != 0; p = p->next)\n+        {\n+          name_tree = get_identifier (p->name);\n+          if (!TREE_ASM_WRITTEN (name_tree)\n+              && TREE_SYMBOL_REFERENCED (name_tree))\n+            {\n+              TREE_ASM_WRITTEN (name_tree) = 1;\n+              fputs (\"\\t.extern\\t\", asm_out_file);\n+              assemble_name (asm_out_file, p->name);\n+              fprintf (asm_out_file, \", %d\\n\", p->size);\n+            }\n+        }\n+    }\n+}\n+\n+/* Implement OVERRIDE_OPTIONS macro.  */\n+void\n+score7_override_options (void)\n+{\n+  flag_pic = false;\n+  if (!flag_pic)\n+    score7_sdata_max = g_switch_set ? g_switch_value : SCORE7_DEFAULT_SDATA_MAX;\n+  else\n+    {\n+      score7_sdata_max = 0;\n+      if (g_switch_set && (g_switch_value != 0))\n+        warning (0, \"-fPIC and -G are incompatible\");\n+    }\n+\n+  score_char_to_class['d'] = G32_REGS;\n+  score_char_to_class['e'] = G16_REGS;\n+  score_char_to_class['t'] = T32_REGS;\n+\n+  score_char_to_class['h'] = HI_REG;\n+  score_char_to_class['l'] = LO_REG;\n+  score_char_to_class['x'] = CE_REGS;\n+\n+  score_char_to_class['q'] = CN_REG;\n+  score_char_to_class['y'] = LC_REG;\n+  score_char_to_class['z'] = SC_REG;\n+  score_char_to_class['a'] = SP_REGS;\n+\n+  score_char_to_class['c'] = CR_REGS;\n+}\n+\n+/* Implement REGNO_REG_CLASS macro.  */\n+int\n+score7_reg_class (int regno)\n+{\n+  int c;\n+  gcc_assert (regno >= 0 && regno < FIRST_PSEUDO_REGISTER);\n+\n+  if (regno == FRAME_POINTER_REGNUM\n+      || regno == ARG_POINTER_REGNUM)\n+    return ALL_REGS;\n+\n+  for (c = 0; c < N_REG_CLASSES; c++)\n+    if (TEST_HARD_REG_BIT (reg_class_contents[c], regno))\n+      return c;\n+\n+  return NO_REGS;\n+}\n+\n+/* Implement PREFERRED_RELOAD_CLASS macro.  */\n+enum reg_class\n+score7_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class class)\n+{\n+  if (reg_class_subset_p (G16_REGS, class))\n+    return G16_REGS;\n+  if (reg_class_subset_p (G32_REGS, class))\n+    return G32_REGS;\n+  return class;\n+}\n+\n+/* Implement SECONDARY_INPUT_RELOAD_CLASS\n+   and SECONDARY_OUTPUT_RELOAD_CLASS macro.  */\n+enum reg_class\n+score7_secondary_reload_class (enum reg_class class,\n+                               enum machine_mode mode ATTRIBUTE_UNUSED,\n+                               rtx x)\n+{\n+  int regno = -1;\n+  if (GET_CODE (x) == REG || GET_CODE(x) == SUBREG)\n+    regno = true_regnum (x);\n+\n+  if (!GR_REG_CLASS_P (class))\n+    return GP_REG_P (regno) ? NO_REGS : G32_REGS;\n+  return NO_REGS;\n+}\n+\n+/* Implement CONST_OK_FOR_LETTER_P macro.  */\n+/* imm constraints\n+   I        imm16 << 16\n+   J        uimm5\n+   K        uimm16\n+   L        simm16\n+   M        uimm14\n+   N        simm14  */\n+int\n+score7_const_ok_for_letter_p (HOST_WIDE_INT value, char c)\n+{\n+  switch (c)\n+    {\n+    case 'I': return ((value & 0xffff) == 0);\n+    case 'J': return IMM_IN_RANGE (value, 5, 0);\n+    case 'K': return IMM_IN_RANGE (value, 16, 0);\n+    case 'L': return IMM_IN_RANGE (value, 16, 1);\n+    case 'M': return IMM_IN_RANGE (value, 14, 0);\n+    case 'N': return IMM_IN_RANGE (value, 14, 1);\n+    default : return 0;\n+    }\n+}\n+\n+/* Implement EXTRA_CONSTRAINT macro.  */\n+/* Z        symbol_ref  */\n+int\n+score7_extra_constraint (rtx op, char c)\n+{\n+  switch (c)\n+    {\n+    case 'Z':\n+      return GET_CODE (op) == SYMBOL_REF;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Return truth value on whether or not a given hard register\n+   can support a given mode.  */\n+int\n+score7_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n+{\n+  int size = GET_MODE_SIZE (mode);\n+  enum mode_class class = GET_MODE_CLASS (mode);\n+\n+  if (class == MODE_CC)\n+    return regno == CC_REGNUM;\n+  else if (regno == FRAME_POINTER_REGNUM\n+           || regno == ARG_POINTER_REGNUM)\n+    return class == MODE_INT;\n+  else if (GP_REG_P (regno))\n+    /* ((regno <= (GP_REG_LAST- HARD_REGNO_NREGS (dummy, mode)) + 1)  */\n+    return !(regno & 1) || (size <= UNITS_PER_WORD);\n+  else if (CE_REG_P (regno))\n+    return (class == MODE_INT\n+            && ((size <= UNITS_PER_WORD)\n+                || (regno == CE_REG_FIRST && size == 2 * UNITS_PER_WORD)));\n+  else\n+    return (class == MODE_INT) && (size <= UNITS_PER_WORD);\n+}\n+\n+/* Implement INITIAL_ELIMINATION_OFFSET.  FROM is either the frame\n+   pointer or argument pointer.  TO is either the stack pointer or\n+   hard frame pointer.  */\n+HOST_WIDE_INT\n+score7_initial_elimination_offset (int from,\n+                                   int to ATTRIBUTE_UNUSED)\n+{\n+  struct score7_frame_info *f = score7_compute_frame_size (get_frame_size ());\n+  switch (from)\n+    {\n+    case ARG_POINTER_REGNUM:\n+      return f->total_size;\n+    case FRAME_POINTER_REGNUM:\n+      return 0;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Implement FUNCTION_ARG_ADVANCE macro.  */\n+void\n+score7_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+                             tree type, int named)\n+{\n+  struct score7_arg_info info;\n+  score7_classify_arg (cum, mode, type, named, &info);\n+  cum->num_gprs = info.reg_offset + info.reg_words;\n+  if (info.stack_words > 0)\n+    cum->stack_words = info.stack_offset + info.stack_words;\n+  cum->arg_number++;\n+}\n+\n+/* Implement TARGET_ARG_PARTIAL_BYTES macro.  */\n+int\n+score7_arg_partial_bytes (CUMULATIVE_ARGS *cum,\n+                          enum machine_mode mode, tree type, bool named)\n+{\n+  struct score7_arg_info info;\n+  score7_classify_arg (cum, mode, type, named, &info);\n+  return info.stack_words > 0 ? info.reg_words * UNITS_PER_WORD : 0;\n+}\n+\n+/* Implement FUNCTION_ARG macro.  */\n+rtx\n+score7_function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+                     tree type, int named)\n+{\n+  struct score7_arg_info info;\n+\n+  if (mode == VOIDmode || !named)\n+    return 0;\n+\n+  score7_classify_arg (cum, mode, type, named, &info);\n+\n+  if (info.reg_offset == ARG_REG_NUM)\n+    return 0;\n+\n+  if (!info.stack_words)\n+    return gen_rtx_REG (mode, ARG_REG_FIRST + info.reg_offset);\n+  else\n+    {\n+      rtx ret = gen_rtx_PARALLEL (mode, rtvec_alloc (info.reg_words));\n+      unsigned int i, part_offset = 0;\n+      for (i = 0; i < info.reg_words; i++)\n+        {\n+          rtx reg;\n+          reg = gen_rtx_REG (SImode, ARG_REG_FIRST + info.reg_offset + i);\n+          XVECEXP (ret, 0, i) = gen_rtx_EXPR_LIST (SImode, reg,\n+                                                   GEN_INT (part_offset));\n+          part_offset += UNITS_PER_WORD;\n+        }\n+      return ret;\n+    }\n+}\n+\n+/* Implement FUNCTION_VALUE and LIBCALL_VALUE.  For normal calls,\n+   VALTYPE is the return type and MODE is VOIDmode.  For libcalls,\n+   VALTYPE is null and MODE is the mode of the return value.  */\n+rtx\n+score7_function_value (tree valtype, tree func ATTRIBUTE_UNUSED,\n+                       enum machine_mode mode)\n+{\n+  if (valtype)\n+    {\n+      int unsignedp;\n+      mode = TYPE_MODE (valtype);\n+      unsignedp = TYPE_UNSIGNED (valtype);\n+      mode = promote_mode (valtype, mode, &unsignedp, 1);\n+    }\n+  return gen_rtx_REG (mode, RT_REGNUM);\n+}\n+\n+/* Implement INITIALIZE_TRAMPOLINE macro.  */\n+void\n+score7_initialize_trampoline (rtx ADDR, rtx FUNC, rtx CHAIN)\n+{\n+#define FFCACHE          \"_flush_cache\"\n+#define CODE_SIZE        (TRAMPOLINE_INSNS * UNITS_PER_WORD)\n+\n+  rtx pfunc, pchain;\n+\n+  pfunc = plus_constant (ADDR, CODE_SIZE);\n+  pchain = plus_constant (ADDR, CODE_SIZE + GET_MODE_SIZE (SImode));\n+\n+  emit_move_insn (gen_rtx_MEM (SImode, pfunc), FUNC);\n+  emit_move_insn (gen_rtx_MEM (SImode, pchain), CHAIN);\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, FFCACHE),\n+                     0, VOIDmode, 2,\n+                     ADDR, Pmode,\n+                     GEN_INT (TRAMPOLINE_SIZE), SImode);\n+#undef FFCACHE\n+#undef CODE_SIZE\n+}\n+\n+/* This function is used to implement REG_MODE_OK_FOR_BASE_P macro.  */\n+int\n+score7_regno_mode_ok_for_base_p (int regno, int strict)\n+{\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      if (!strict)\n+        return 1;\n+      regno = reg_renumber[regno];\n+    }\n+  if (regno == ARG_POINTER_REGNUM\n+      || regno == FRAME_POINTER_REGNUM)\n+    return 1;\n+  return GP_REG_P (regno);\n+}\n+\n+/* Implement GO_IF_LEGITIMATE_ADDRESS macro.  */\n+int\n+score7_address_p (enum machine_mode mode, rtx x, int strict)\n+{\n+  struct score7_address_info addr;\n+\n+  return score7_classify_address (&addr, mode, x, strict);\n+}\n+\n+/* Return a number assessing the cost of moving a register in class\n+   FROM to class TO. */\n+int\n+score7_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+                           enum reg_class from, enum reg_class to)\n+{\n+  if (GR_REG_CLASS_P (from))\n+    {\n+      if (GR_REG_CLASS_P (to))\n+        return 2;\n+      else if (SP_REG_CLASS_P (to))\n+        return 4;\n+      else if (CP_REG_CLASS_P (to))\n+        return 5;\n+      else if (CE_REG_CLASS_P (to))\n+        return 6;\n+    }\n+  if (GR_REG_CLASS_P (to))\n+    {\n+      if (GR_REG_CLASS_P (from))\n+        return 2;\n+      else if (SP_REG_CLASS_P (from))\n+        return 4;\n+      else if (CP_REG_CLASS_P (from))\n+        return 5;\n+      else if (CE_REG_CLASS_P (from))\n+        return 6;\n+    }\n+  return 12;\n+}\n+\n+/* Return the number of instructions needed to load a symbol of the\n+   given type into a register.  */\n+static int\n+score7_symbol_insns (enum score_symbol_type type)\n+{\n+  switch (type)\n+    {\n+    case SYMBOL_GENERAL:\n+      return 2;\n+\n+    case SYMBOL_SMALL_DATA:\n+      return 1;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Return the number of instructions needed to load or store a value\n+   of mode MODE at X.  Return 0 if X isn't valid for MODE.  */\n+static int\n+score7_address_insns (rtx x, enum machine_mode mode)\n+{\n+  struct score7_address_info addr;\n+  int factor;\n+\n+  if (mode == BLKmode)\n+    factor = 1;\n+  else\n+    factor = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  if (score7_classify_address (&addr, mode, x, false))\n+    switch (addr.type)\n+      {\n+      case SCORE7_ADD_REG:\n+      case SCORE7_ADD_CONST_INT:\n+        return factor;\n+\n+      case SCORE7_ADD_SYMBOLIC:\n+        return factor * score7_symbol_insns (addr.symbol_type);\n+      }\n+  return 0;\n+}\n+\n+/* Implement TARGET_RTX_COSTS macro.  */\n+bool\n+score7_rtx_costs (rtx x, int code, int outer_code, int *total)\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      if (outer_code == SET)\n+        {\n+          if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n+              || CONST_OK_FOR_LETTER_P (INTVAL (x), 'L'))\n+            *total = COSTS_N_INSNS (1);\n+          else\n+            *total = COSTS_N_INSNS (2);\n+        }\n+      else if (outer_code == PLUS || outer_code == MINUS)\n+        {\n+          if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'N'))\n+            *total = 0;\n+          else if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n+                   || CONST_OK_FOR_LETTER_P (INTVAL (x), 'L'))\n+            *total = 1;\n+          else\n+            *total = COSTS_N_INSNS (2);\n+        }\n+      else if (outer_code == AND || outer_code == IOR)\n+        {\n+          if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'M'))\n+            *total = 0;\n+          else if (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n+                   || CONST_OK_FOR_LETTER_P (INTVAL (x), 'K'))\n+            *total = 1;\n+          else\n+            *total = COSTS_N_INSNS (2);\n+        }\n+      else\n+        {\n+          *total = 0;\n+        }\n+      return true;\n+\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case CONST_DOUBLE:\n+      *total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case MEM:\n+      {\n+        /* If the address is legitimate, return the number of\n+           instructions it needs, otherwise use the default handling.  */\n+        int n = score7_address_insns (XEXP (x, 0), GET_MODE (x));\n+        if (n > 0)\n+          {\n+            *total = COSTS_N_INSNS (n + 1);\n+            return true;\n+          }\n+        return false;\n+      }\n+\n+    case FFS:\n+      *total = COSTS_N_INSNS (6);\n+      return true;\n+\n+    case NOT:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      if (mode == DImode)\n+        {\n+          *total = COSTS_N_INSNS (2);\n+          return true;\n+        }\n+      return false;\n+\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      if (mode == DImode)\n+        {\n+          *total = COSTS_N_INSNS ((GET_CODE (XEXP (x, 1)) == CONST_INT)\n+                                  ? 4 : 12);\n+          return true;\n+        }\n+      return false;\n+\n+    case ABS:\n+      *total = COSTS_N_INSNS (4);\n+      return true;\n+\n+    case PLUS:\n+    case MINUS:\n+      if (mode == DImode)\n+        {\n+          *total = COSTS_N_INSNS (4);\n+          return true;\n+        }\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case NEG:\n+      if (mode == DImode)\n+        {\n+          *total = COSTS_N_INSNS (4);\n+          return true;\n+        }\n+      return false;\n+\n+    case MULT:\n+      *total = optimize_size ? COSTS_N_INSNS (2) : COSTS_N_INSNS (12);\n+      return true;\n+\n+    case DIV:\n+    case MOD:\n+    case UDIV:\n+    case UMOD:\n+      *total = optimize_size ? COSTS_N_INSNS (2) : COSTS_N_INSNS (33);\n+      return true;\n+\n+    case SIGN_EXTEND:\n+    case ZERO_EXTEND:\n+      switch (GET_MODE (XEXP (x, 0)))\n+        {\n+        case QImode:\n+        case HImode:\n+          if (GET_CODE (XEXP (x, 0)) == MEM)\n+            {\n+              *total = COSTS_N_INSNS (2);\n+\n+              if (!TARGET_LITTLE_ENDIAN &&\n+                  side_effects_p (XEXP (XEXP (x, 0), 0)))\n+                *total = 100;\n+            }\n+          else\n+            *total = COSTS_N_INSNS (1);\n+          break;\n+\n+        default:\n+          *total = COSTS_N_INSNS (1);\n+          break;\n+        }\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Implement TARGET_ADDRESS_COST macro.  */\n+int\n+score7_address_cost (rtx addr)\n+{\n+  return score7_address_insns (addr, SImode);\n+}\n+\n+/* Implement ASM_OUTPUT_EXTERNAL macro.  */\n+int\n+score7_output_external (FILE *file ATTRIBUTE_UNUSED,\n+                        tree decl, const char *name)\n+{\n+  register struct extern_list *p;\n+\n+  if (score7_in_small_data_p (decl))\n+    {\n+      p = (struct extern_list *) ggc_alloc (sizeof (struct extern_list));\n+      p->next = extern_head;\n+      p->name = name;\n+      p->size = int_size_in_bytes (TREE_TYPE (decl));\n+      extern_head = p;\n+    }\n+  return 0;\n+}\n+\n+/* Implement RETURN_ADDR_RTX.  Note, we do not support moving\n+   back to a previous frame.  */\n+rtx\n+score7_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)\n+{\n+  if (count != 0)\n+    return const0_rtx;\n+  return get_hard_reg_initial_val (Pmode, RA_REGNUM);\n+}\n+\n+/* Implement PRINT_OPERAND macro.  */\n+/* Score-specific operand codes:\n+   '['        print .set nor1 directive\n+   ']'        print .set r1 directive\n+   'U'        print hi part of a CONST_INT rtx\n+   'E'        print log2(v)\n+   'F'        print log2(~v)\n+   'D'        print SFmode const double\n+   'S'        selectively print \"!\" if operand is 15bit instruction accessible\n+   'V'        print \"v!\" if operand is 15bit instruction accessible, or \"lfh!\"\n+   'L'        low  part of DImode reg operand\n+   'H'        high part of DImode reg operand\n+   'C'        print part of opcode for a branch condition.  */\n+void\n+score7_print_operand (FILE *file, rtx op, int c)\n+{\n+  enum rtx_code code = -1;\n+  if (!PRINT_OPERAND_PUNCT_VALID_P (c))\n+    code = GET_CODE (op);\n+\n+  if (c == '[')\n+    {\n+      fprintf (file, \".set r1\\n\");\n+    }\n+  else if (c == ']')\n+    {\n+      fprintf (file, \"\\n\\t.set nor1\");\n+    }\n+  else if (c == 'U')\n+    {\n+      gcc_assert (code == CONST_INT);\n+      fprintf (file, HOST_WIDE_INT_PRINT_HEX,\n+               (INTVAL (op) >> 16) & 0xffff);\n+    }\n+  else if (c == 'D')\n+    {\n+      if (GET_CODE (op) == CONST_DOUBLE)\n+        {\n+          rtx temp = gen_lowpart (SImode, op);\n+          gcc_assert (GET_MODE (op) == SFmode);\n+          fprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (temp) & 0xffffffff);\n+        }\n+      else\n+        output_addr_const (file, op);\n+    }\n+  else if (c == 'S')\n+    {\n+      gcc_assert (code == REG);\n+      if (G16_REG_P (REGNO (op)))\n+        fprintf (file, \"!\");\n+    }\n+  else if (c == 'V')\n+    {\n+      gcc_assert (code == REG);\n+      fprintf (file, G16_REG_P (REGNO (op)) ? \"v!\" : \"lfh!\");\n+    }\n+  else if (c == 'C')\n+    {\n+      enum machine_mode mode = GET_MODE (XEXP (op, 0));\n+\n+      switch (code)\n+        {\n+        case EQ: fputs (\"eq\", file); break;\n+        case NE: fputs (\"ne\", file); break;\n+        case GT: fputs (\"gt\", file); break;\n+        case GE: fputs (mode != CCmode ? \"pl\" : \"ge\", file); break;\n+        case LT: fputs (mode != CCmode ? \"mi\" : \"lt\", file); break;\n+        case LE: fputs (\"le\", file); break;\n+        case GTU: fputs (\"gtu\", file); break;\n+        case GEU: fputs (\"cs\", file); break;\n+        case LTU: fputs (\"cc\", file); break;\n+        case LEU: fputs (\"leu\", file); break;\n+        default:\n+          output_operand_lossage (\"invalid operand for code: '%c'\", code);\n+        }\n+    }\n+  else if (c == 'E')\n+    {\n+      unsigned HOST_WIDE_INT i;\n+      unsigned HOST_WIDE_INT pow2mask = 1;\n+      unsigned HOST_WIDE_INT val;\n+\n+      val = INTVAL (op);\n+      for (i = 0; i < 32; i++)\n+        {\n+          if (val == pow2mask)\n+            break;\n+          pow2mask <<= 1;\n+        }\n+      gcc_assert (i < 32);\n+      fprintf (file, HOST_WIDE_INT_PRINT_HEX, i);\n+    }\n+  else if (c == 'F')\n+    {\n+      unsigned HOST_WIDE_INT i;\n+      unsigned HOST_WIDE_INT pow2mask = 1;\n+      unsigned HOST_WIDE_INT val;\n+\n+      val = ~INTVAL (op);\n+      for (i = 0; i < 32; i++)\n+        {\n+          if (val == pow2mask)\n+            break;\n+          pow2mask <<= 1;\n+        }\n+      gcc_assert (i < 32);\n+      fprintf (file, HOST_WIDE_INT_PRINT_HEX, i);\n+    }\n+  else if (code == REG)\n+    {\n+      int regnum = REGNO (op);\n+      if ((c == 'H' && !WORDS_BIG_ENDIAN)\n+          || (c == 'L' && WORDS_BIG_ENDIAN))\n+        regnum ++;\n+      fprintf (file, \"%s\", reg_names[regnum]);\n+    }\n+  else\n+    {\n+      switch (code)\n+        {\n+        case MEM:\n+          score7_print_operand_address (file, op);\n+          break;\n+        default:\n+          output_addr_const (file, op);\n+        }\n+    }\n+}\n+\n+/* Implement PRINT_OPERAND_ADDRESS macro.  */\n+void\n+score7_print_operand_address (FILE *file, rtx x)\n+{\n+  struct score7_address_info addr;\n+  enum rtx_code code = GET_CODE (x);\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  if (code == MEM)\n+    x = XEXP (x, 0);\n+\n+  if (score7_classify_address (&addr, mode, x, true))\n+    {\n+      switch (addr.type)\n+        {\n+        case SCORE7_ADD_REG:\n+          {\n+            switch (addr.code)\n+              {\n+              case PRE_DEC:\n+                fprintf (file, \"[%s,-%ld]+\", reg_names[REGNO (addr.reg)],\n+                         INTVAL (addr.offset));\n+                break;\n+              case POST_DEC:\n+                fprintf (file, \"[%s]+,-%ld\", reg_names[REGNO (addr.reg)],\n+                         INTVAL (addr.offset));\n+                break;\n+              case PRE_INC:\n+                fprintf (file, \"[%s, %ld]+\", reg_names[REGNO (addr.reg)],\n+                         INTVAL (addr.offset));\n+                break;\n+              case POST_INC:\n+                fprintf (file, \"[%s]+, %ld\", reg_names[REGNO (addr.reg)],\n+                         INTVAL (addr.offset));\n+                break;\n+              default:\n+                if (INTVAL(addr.offset) == 0)\n+                  fprintf(file, \"[%s]\", reg_names[REGNO (addr.reg)]);\n+                else\n+                  fprintf(file, \"[%s, %ld]\", reg_names[REGNO (addr.reg)],\n+                          INTVAL(addr.offset));\n+                break;\n+              }\n+          }\n+          return;\n+        case SCORE7_ADD_CONST_INT:\n+        case SCORE7_ADD_SYMBOLIC:\n+          output_addr_const (file, x);\n+          return;\n+        }\n+    }\n+  print_rtl (stderr, x);\n+  gcc_unreachable ();\n+}\n+\n+/* Implement SELECT_CC_MODE macro.  */\n+enum machine_mode\n+score7_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n+{\n+  if ((op == EQ || op == NE || op == LT || op == GE)\n+      && y == const0_rtx\n+      && GET_MODE (x) == SImode)\n+    {\n+      switch (GET_CODE (x))\n+        {\n+        case PLUS:\n+        case MINUS:\n+        case NEG:\n+        case AND:\n+        case IOR:\n+        case XOR:\n+        case NOT:\n+        case ASHIFT:\n+        case LSHIFTRT:\n+        case ASHIFTRT:\n+          return CC_NZmode;\n+\n+        case SIGN_EXTEND:\n+        case ZERO_EXTEND:\n+        case ROTATE:\n+        case ROTATERT:\n+          return (op == LT || op == GE) ? CC_Nmode : CCmode;\n+\n+        default:\n+          return CCmode;\n+        }\n+    }\n+\n+  if ((op == EQ || op == NE)\n+      && (GET_CODE (y) == NEG)\n+      && register_operand (XEXP (y, 0), SImode)\n+      && register_operand (x, SImode))\n+    {\n+      return CC_NZmode;\n+    }\n+\n+  return CCmode;\n+}\n+\n+/* Generate the prologue instructions for entry into a S+core function.  */\n+void\n+score7_prologue (void)\n+{\n+#define EMIT_PL(_rtx)        RTX_FRAME_RELATED_P (_rtx) = 1\n+\n+  struct score7_frame_info *f = score7_compute_frame_size (get_frame_size ());\n+  HOST_WIDE_INT size;\n+  int regno;\n+\n+  size = f->total_size - f->gp_reg_size;\n+\n+  if (flag_pic)\n+    emit_insn (gen_cpload_score7 ());\n+\n+  for (regno = (int) GP_REG_LAST; regno >= (int) GP_REG_FIRST; regno--)\n+    {\n+      if (BITSET_P (f->mask, regno - GP_REG_FIRST))\n+        {\n+          rtx mem = gen_rtx_MEM (SImode,\n+                                 gen_rtx_PRE_DEC (SImode, stack_pointer_rtx));\n+          rtx reg = gen_rtx_REG (SImode, regno);\n+          if (!current_function_calls_eh_return)\n+            MEM_READONLY_P (mem) = 1;\n+          EMIT_PL (emit_insn (gen_pushsi_score7 (mem, reg)));\n+        }\n+    }\n+\n+  if (size > 0)\n+    {\n+      rtx insn;\n+\n+      if (CONST_OK_FOR_LETTER_P (-size, 'L'))\n+        EMIT_PL (emit_insn (gen_add3_insn (stack_pointer_rtx,\n+                                           stack_pointer_rtx,\n+                                           GEN_INT (-size))));\n+      else\n+        {\n+          EMIT_PL (emit_move_insn (gen_rtx_REG (Pmode, SCORE7_PROLOGUE_TEMP_REGNUM),\n+                                   GEN_INT (size)));\n+          EMIT_PL (emit_insn\n+                   (gen_sub3_insn (stack_pointer_rtx,\n+                                   stack_pointer_rtx,\n+                                   gen_rtx_REG (Pmode,\n+                                                SCORE7_PROLOGUE_TEMP_REGNUM))));\n+        }\n+      insn = get_last_insn ();\n+      REG_NOTES (insn) =\n+        alloc_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+                         gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+                                      plus_constant (stack_pointer_rtx,\n+                                                     -size)),\n+                                      REG_NOTES (insn));\n+    }\n+\n+  if (frame_pointer_needed)\n+    EMIT_PL (emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx));\n+\n+  if (flag_pic && f->cprestore_size)\n+    {\n+      if (frame_pointer_needed)\n+        emit_insn (gen_cprestore_use_fp_score7 (GEN_INT (size - f->cprestore_size)));\n+      else\n+        emit_insn (gen_cprestore_use_sp_score7 (GEN_INT (size - f->cprestore_size)));\n+    }\n+\n+#undef EMIT_PL\n+}\n+\n+/* Generate the epilogue instructions in a S+core function.  */\n+void\n+score7_epilogue (int sibcall_p)\n+{\n+  struct score7_frame_info *f = score7_compute_frame_size (get_frame_size ());\n+  HOST_WIDE_INT size;\n+  int regno;\n+  rtx base;\n+\n+  size = f->total_size - f->gp_reg_size;\n+\n+  if (!frame_pointer_needed)\n+    base = stack_pointer_rtx;\n+  else\n+    base = hard_frame_pointer_rtx;\n+\n+  if (size)\n+    {\n+      if (CONST_OK_FOR_LETTER_P (size, 'L'))\n+        emit_insn (gen_add3_insn (base, base, GEN_INT (size)));\n+      else\n+        {\n+          emit_move_insn (gen_rtx_REG (Pmode, SCORE7_EPILOGUE_TEMP_REGNUM),\n+                          GEN_INT (size));\n+          emit_insn (gen_add3_insn (base, base,\n+                                    gen_rtx_REG (Pmode,\n+                                                 SCORE7_EPILOGUE_TEMP_REGNUM)));\n+        }\n+    }\n+\n+  if (base != stack_pointer_rtx)\n+    emit_move_insn (stack_pointer_rtx, base);\n+\n+  if (current_function_calls_eh_return)\n+    emit_insn (gen_add3_insn (stack_pointer_rtx,\n+                              stack_pointer_rtx,\n+                              EH_RETURN_STACKADJ_RTX));\n+\n+  for (regno = (int) GP_REG_FIRST; regno <= (int) GP_REG_LAST; regno++)\n+    {\n+      if (BITSET_P (f->mask, regno - GP_REG_FIRST))\n+        {\n+          rtx mem = gen_rtx_MEM (SImode,\n+                                 gen_rtx_POST_INC (SImode, stack_pointer_rtx));\n+          rtx reg = gen_rtx_REG (SImode, regno);\n+\n+          if (!current_function_calls_eh_return)\n+            MEM_READONLY_P (mem) = 1;\n+\n+          emit_insn (gen_popsi_score7 (reg, mem));\n+        }\n+    }\n+\n+  if (!sibcall_p)\n+    emit_jump_insn (gen_return_internal_score7 (gen_rtx_REG (Pmode, RA_REGNUM)));\n+}\n+\n+void\n+score7_gen_cmp (enum machine_mode mode)\n+{\n+  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, CC_REGNUM),\n+                          gen_rtx_COMPARE (mode, cmp_op0, cmp_op1)));\n+}\n+\n+/* Return true if X is a symbolic constant that can be calculated in\n+   the same way as a bare symbol.  If it is, store the type of the\n+   symbol in *SYMBOL_TYPE.  */\n+int\n+score7_symbolic_constant_p (rtx x, enum score_symbol_type *symbol_type)\n+{\n+  HOST_WIDE_INT offset;\n+\n+  score7_split_const (x, &x, &offset);\n+  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n+    *symbol_type = score7_classify_symbol (x);\n+  else\n+    return 0;\n+\n+  if (offset == 0)\n+    return 1;\n+\n+  /* if offset > 15bit, must reload  */\n+  if (!IMM_IN_RANGE (offset, 15, 1))\n+    return 0;\n+\n+  switch (*symbol_type)\n+    {\n+    case SYMBOL_GENERAL:\n+      return 1;\n+    case SYMBOL_SMALL_DATA:\n+      return score7_offset_within_object_p (x, offset);\n+    }\n+  gcc_unreachable ();\n+}\n+\n+void\n+score7_movsicc (rtx *ops)\n+{\n+  enum machine_mode mode;\n+\n+  mode = score7_select_cc_mode (GET_CODE (ops[1]), ops[2], ops[3]);\n+  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, CC_REGNUM),\n+                          gen_rtx_COMPARE (mode, cmp_op0, cmp_op1)));\n+}\n+\n+/* Call and sibcall pattern all need call this function.  */\n+void\n+score7_call (rtx *ops, bool sib)\n+{\n+  rtx addr = XEXP (ops[0], 0);\n+  if (!call_insn_operand (addr, VOIDmode))\n+    {\n+      rtx oaddr = addr;\n+      addr = gen_reg_rtx (Pmode);\n+      gen_move_insn (addr, oaddr);\n+    }\n+\n+  if (sib)\n+    emit_call_insn (gen_sibcall_internal_score7 (addr, ops[1]));\n+  else\n+    emit_call_insn (gen_call_internal_score7 (addr, ops[1]));\n+}\n+\n+/* Call value and sibcall value pattern all need call this function.  */\n+void\n+score7_call_value (rtx *ops, bool sib)\n+{\n+  rtx result = ops[0];\n+  rtx addr = XEXP (ops[1], 0);\n+  rtx arg = ops[2];\n+\n+  if (!call_insn_operand (addr, VOIDmode))\n+    {\n+      rtx oaddr = addr;\n+      addr = gen_reg_rtx (Pmode);\n+      gen_move_insn (addr, oaddr);\n+    }\n+\n+  if (sib)\n+    emit_call_insn (gen_sibcall_value_internal_score7 (result, addr, arg));\n+  else\n+    emit_call_insn (gen_call_value_internal_score7 (result, addr, arg));\n+}\n+\n+/* Machine Split  */\n+void\n+score7_movdi (rtx *ops)\n+{\n+  rtx dst = ops[0];\n+  rtx src = ops[1];\n+  rtx dst0 = score7_subw (dst, 0);\n+  rtx dst1 = score7_subw (dst, 1);\n+  rtx src0 = score7_subw (src, 0);\n+  rtx src1 = score7_subw (src, 1);\n+\n+  if (GET_CODE (dst0) == REG && reg_overlap_mentioned_p (dst0, src))\n+    {\n+      emit_move_insn (dst1, src1);\n+      emit_move_insn (dst0, src0);\n+    }\n+  else\n+    {\n+      emit_move_insn (dst0, src0);\n+      emit_move_insn (dst1, src1);\n+    }\n+}\n+\n+void\n+score7_zero_extract_andi (rtx *ops)\n+{\n+  if (INTVAL (ops[1]) == 1 && const_uimm5 (ops[2], SImode))\n+    emit_insn (gen_zero_extract_bittst_score7 (ops[0], ops[2]));\n+  else\n+    {\n+      unsigned HOST_WIDE_INT mask;\n+      mask = (0xffffffffU & ((1U << INTVAL (ops[1])) - 1U));\n+      mask = mask << INTVAL (ops[2]);\n+      emit_insn (gen_andsi3_cmp_score7 (ops[3], ops[0],\n+                                 gen_int_mode (mask, SImode)));\n+    }\n+}\n+\n+/* Check addr could be present as PRE/POST mode.  */\n+static bool\n+score7_pindex_mem (rtx addr)\n+{\n+  if (GET_CODE (addr) == MEM)\n+    {\n+      switch (GET_CODE (XEXP (addr, 0)))\n+        {\n+        case PRE_DEC:\n+        case POST_DEC:\n+        case PRE_INC:\n+        case POST_INC:\n+          return true;\n+        default:\n+          break;\n+        }\n+    }\n+  return false;\n+}\n+\n+/* Output asm code for ld/sw insn.  */\n+static int\n+score7_pr_addr_post (rtx *ops, int idata, int iaddr, char *ip, enum score_mem_unit unit)\n+{\n+  struct score7_address_info ai;\n+\n+  gcc_assert (GET_CODE (ops[idata]) == REG);\n+  gcc_assert (score7_classify_address (&ai, SImode, XEXP (ops[iaddr], 0), true));\n+\n+  if (!score7_pindex_mem (ops[iaddr])\n+      && ai.type == SCORE7_ADD_REG\n+      && GET_CODE (ai.offset) == CONST_INT\n+      && G16_REG_P (REGNO (ops[idata]))\n+      && G16_REG_P (REGNO (ai.reg)))\n+    {\n+      if (INTVAL (ai.offset) == 0)\n+        {\n+          ops[iaddr] = ai.reg;\n+          return snprintf (ip, INS_BUF_SZ,\n+                           \"!\\t%%%d, [%%%d]\", idata, iaddr);\n+        }\n+      if (REGNO (ai.reg) == HARD_FRAME_POINTER_REGNUM)\n+        {\n+          HOST_WIDE_INT offset = INTVAL (ai.offset);\n+          if (SCORE_ALIGN_UNIT (offset, unit)\n+              && CONST_OK_FOR_LETTER_P (offset >> unit, 'J'))\n+            {\n+              ops[iaddr] = ai.offset;\n+              return snprintf (ip, INS_BUF_SZ,\n+                               \"p!\\t%%%d, %%c%d\", idata, iaddr);\n+            }\n+        }\n+    }\n+  return snprintf (ip, INS_BUF_SZ, \"\\t%%%d, %%a%d\", idata, iaddr);\n+}\n+\n+/* Output asm insn for load.  */\n+const char *\n+score7_linsn (rtx *ops, enum score_mem_unit unit, bool sign)\n+{\n+  const char *pre_ins[] =\n+    {\"lbu\", \"lhu\", \"lw\", \"??\", \"lb\", \"lh\", \"lw\", \"??\"};\n+  char *ip;\n+\n+  strcpy (score7_ins, pre_ins[(sign ? 4 : 0) + unit]);\n+  ip = score7_ins + strlen (score7_ins);\n+\n+  if ((!sign && unit != SCORE_HWORD)\n+      || (sign && unit != SCORE_BYTE))\n+    score7_pr_addr_post (ops, 0, 1, ip, unit);\n+  else\n+    snprintf (ip, INS_BUF_SZ, \"\\t%%0, %%a1\");\n+\n+  return score7_ins;\n+}\n+\n+/* Output asm insn for store.  */\n+const char *\n+score7_sinsn (rtx *ops, enum score_mem_unit unit)\n+{\n+  const char *pre_ins[] = {\"sb\", \"sh\", \"sw\"};\n+  char *ip;\n+\n+  strcpy (score7_ins, pre_ins[unit]);\n+  ip = score7_ins + strlen (score7_ins);\n+  score7_pr_addr_post (ops, 1, 0, ip, unit);\n+  return score7_ins;\n+}\n+\n+/* Output asm insn for load immediate.  */\n+const char *\n+score7_limm (rtx *ops)\n+{\n+  HOST_WIDE_INT v;\n+\n+  gcc_assert (GET_CODE (ops[0]) == REG);\n+  gcc_assert (GET_CODE (ops[1]) == CONST_INT);\n+\n+  v = INTVAL (ops[1]);\n+  if (G16_REG_P (REGNO (ops[0])) && IMM_IN_RANGE (v, 8, 0))\n+    return \"ldiu!\\t%0, %c1\";\n+  else if (IMM_IN_RANGE (v, 16, 1))\n+    return \"ldi\\t%0, %c1\";\n+  else if ((v & 0xffff) == 0)\n+    return \"ldis\\t%0, %U1\";\n+  else\n+    return \"li\\t%0, %c1\";\n+}\n+\n+/* Output asm insn for move.  */\n+const char *\n+score7_move (rtx *ops)\n+{\n+  gcc_assert (GET_CODE (ops[0]) == REG);\n+  gcc_assert (GET_CODE (ops[1]) == REG);\n+\n+  if (G16_REG_P (REGNO (ops[0])))\n+    {\n+      if (G16_REG_P (REGNO (ops[1])))\n+        return \"mv!\\t%0, %1\";\n+      else\n+        return \"mlfh!\\t%0, %1\";\n+    }\n+  else if (G16_REG_P (REGNO (ops[1])))\n+    return \"mhfl!\\t%0, %1\";\n+  else\n+    return \"mv\\t%0, %1\";\n+}\n+\n+/* Generate add insn.  */\n+const char *\n+score7_select_add_imm (rtx *ops, bool set_cc)\n+{\n+  HOST_WIDE_INT v = INTVAL (ops[2]);\n+\n+  gcc_assert (GET_CODE (ops[2]) == CONST_INT);\n+  gcc_assert (REGNO (ops[0]) == REGNO (ops[1]));\n+\n+  if (set_cc && G16_REG_P (REGNO (ops[0])))\n+    {\n+      if (v > 0 && IMM_IS_POW_OF_2 ((unsigned HOST_WIDE_INT) v, 0, 15))\n+        {\n+          ops[2] = GEN_INT (ffs (v) - 1);\n+          return \"addei!\\t%0, %c2\";\n+        }\n+\n+      if (v < 0 && IMM_IS_POW_OF_2 ((unsigned HOST_WIDE_INT) (-v), 0, 15))\n+        {\n+          ops[2] = GEN_INT (ffs (-v) - 1);\n+          return \"subei!\\t%0, %c2\";\n+        }\n+    }\n+\n+  if (set_cc)\n+    return \"addi.c\\t%0, %c2\";\n+  else\n+    return \"addi\\t%0, %c2\";\n+}\n+\n+/* Output arith insn.  */\n+const char *\n+score7_select (rtx *ops, const char *inst_pre,\n+               bool commu, const char *letter, bool set_cc)\n+{\n+  gcc_assert (GET_CODE (ops[0]) == REG);\n+  gcc_assert (GET_CODE (ops[1]) == REG);\n+\n+  if (set_cc && G16_REG_P (REGNO (ops[0]))\n+      && (GET_CODE (ops[2]) == REG ? G16_REG_P (REGNO (ops[2])) : 1)\n+      && REGNO (ops[0]) == REGNO (ops[1]))\n+    {\n+      snprintf (score7_ins, INS_BUF_SZ, \"%s!\\t%%0, %%%s2\", inst_pre, letter);\n+      return score7_ins;\n+    }\n+\n+  if (commu && set_cc && G16_REG_P (REGNO (ops[0]))\n+      && G16_REG_P (REGNO (ops[1]))\n+      && REGNO (ops[0]) == REGNO (ops[2]))\n+    {\n+      gcc_assert (GET_CODE (ops[2]) == REG);\n+      snprintf (score7_ins, INS_BUF_SZ, \"%s!\\t%%0, %%%s1\", inst_pre, letter);\n+      return score7_ins;\n+    }\n+\n+  if (set_cc)\n+    snprintf (score7_ins, INS_BUF_SZ, \"%s.c\\t%%0, %%1, %%%s2\", inst_pre, letter);\n+  else\n+    snprintf (score7_ins, INS_BUF_SZ, \"%s\\t%%0, %%1, %%%s2\", inst_pre, letter);\n+  return score7_ins;\n+}\n+"}, {"sha": "900aa6f492414a448c777c05cea0f8e034721e41", "filename": "gcc/config/score/score7.h", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore7.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Fscore7.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.h?ref=254f522229578af1af093b2e4b6f1a0cc400d216", "patch": "@@ -0,0 +1,157 @@\n+/* score7.h for Sunplus S+CORE processor\n+   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+   Contributed by Sunnorth\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_SCORE7_H\n+#define GCC_SCORE7_H\n+\n+enum score7_address_type\n+{\n+  SCORE7_ADD_REG,\n+  SCORE7_ADD_CONST_INT,\n+  SCORE7_ADD_SYMBOLIC\n+};\n+\n+struct score7_frame_info\n+{\n+  HOST_WIDE_INT total_size;       /* bytes that the entire frame takes up  */\n+  HOST_WIDE_INT var_size;         /* bytes that variables take up  */\n+  HOST_WIDE_INT args_size;        /* bytes that outgoing arguments take up  */\n+  HOST_WIDE_INT gp_reg_size;      /* bytes needed to store gp regs  */\n+  HOST_WIDE_INT gp_sp_offset;     /* offset from new sp to store gp registers  */\n+  HOST_WIDE_INT cprestore_size;   /* # bytes that the .cprestore slot takes up  */\n+  unsigned int  mask;             /* mask of saved gp registers  */\n+  int num_gp;                     /* number of gp registers saved  */\n+};\n+\n+struct score7_arg_info\n+{\n+  unsigned int num_bytes;     /* The argument's size in bytes  */\n+  unsigned int reg_words;     /* The number of words passed in registers  */\n+  unsigned int reg_offset;    /* The offset of the first register from  */\n+                              /* GP_ARG_FIRST or FP_ARG_FIRST etc  */\n+  unsigned int stack_words;   /* The number of words that must be passed  */\n+                              /* on the stack  */\n+  unsigned int stack_offset;  /* The offset from the start of the stack  */\n+                              /* overflow area  */\n+};\n+\n+#ifdef RTX_CODE\n+struct score7_address_info\n+{\n+  enum score7_address_type type;\n+  rtx reg;\n+  rtx offset;\n+  enum rtx_code code;\n+  enum score_symbol_type symbol_type;\n+};\n+#endif\n+\n+#define SCORE7_SDATA_MAX                score7_sdata_max\n+#define SCORE7_STACK_ALIGN(LOC)         (((LOC) + 3) & ~3)\n+#define SCORE7_PROLOGUE_TEMP_REGNUM     (GP_REG_FIRST + 8)\n+#define SCORE7_EPILOGUE_TEMP_REGNUM     (GP_REG_FIRST + 8)\n+#define SCORE7_DEFAULT_SDATA_MAX        8\n+\n+extern int score7_symbolic_constant_p (rtx x,\n+                                       enum score_symbol_type *symbol_type);\n+extern bool score7_return_in_memory (tree type,\n+                                     tree fndecl ATTRIBUTE_UNUSED);\n+extern void score7_output_mi_thunk (FILE *file,\n+                                    tree thunk_fndecl ATTRIBUTE_UNUSED,\n+                                    HOST_WIDE_INT delta,\n+                                    HOST_WIDE_INT vcall_offset,\n+                                    tree function);\n+extern int score7_legitimize_address (rtx *xloc);\n+extern void\n+score7_function_prologue (FILE *file,\n+                          HOST_WIDE_INT size ATTRIBUTE_UNUSED);\n+extern void\n+score7_function_epilogue (FILE *file,\n+                          HOST_WIDE_INT size ATTRIBUTE_UNUSED);\n+extern section *score7_select_rtx_section (enum machine_mode mode, rtx x,\n+                                           unsigned HOST_WIDE_INT align);\n+extern bool score7_in_small_data_p (tree decl);\n+extern void score7_asm_file_start (void);\n+extern void score7_asm_file_end (void);\n+extern void score7_override_options (void);\n+extern int score7_reg_class (int regno);\n+extern enum reg_class score7_preferred_reload_class (rtx x ATTRIBUTE_UNUSED,\n+                                                     enum reg_class class);\n+extern enum\n+reg_class score7_secondary_reload_class (enum reg_class class,\n+                                         enum machine_mode mode ATTRIBUTE_UNUSED,\n+                                         rtx x);\n+extern int score7_const_ok_for_letter_p (HOST_WIDE_INT value, char c);\n+extern int score7_extra_constraint (rtx op, char c);\n+extern int score7_hard_regno_mode_ok (unsigned int regno,\n+                                      enum machine_mode mode);\n+extern HOST_WIDE_INT\n+score7_initial_elimination_offset (int from,\n+                                   int to ATTRIBUTE_UNUSED);\n+extern void score7_function_arg_advance (CUMULATIVE_ARGS *cum,\n+                                         enum machine_mode mode,\n+                                         tree type,\n+                                         int named);\n+extern int score7_arg_partial_bytes (CUMULATIVE_ARGS *cum,\n+                                     enum machine_mode mode,\n+                                     tree type,\n+                                     bool named);\n+extern rtx score7_function_arg (const CUMULATIVE_ARGS *cum,\n+                                enum machine_mode mode,\n+                                tree type,\n+                                int named);\n+extern rtx score7_function_value (tree valtype,\n+                                  tree func ATTRIBUTE_UNUSED,\n+                                  enum machine_mode mode);\n+extern void score7_initialize_trampoline (rtx ADDR, rtx FUNC, rtx CHAIN);\n+extern int score7_regno_mode_ok_for_base_p (int regno, int strict);\n+extern int score7_address_p (enum machine_mode mode, rtx x, int strict);\n+extern int score7_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+                                      enum reg_class from,\n+                                      enum reg_class to);\n+extern bool score7_rtx_costs (rtx x, int code, int outer_code, int *total);\n+extern int score7_address_cost (rtx addr);\n+extern int score7_output_external (FILE *file ATTRIBUTE_UNUSED,\n+                                   tree decl,\n+                                   const char *name);\n+extern rtx score7_return_addr (int count, rtx frame ATTRIBUTE_UNUSED);\n+extern void score7_print_operand (FILE *file, rtx op, int c);\n+extern void score7_print_operand_address (FILE *file, rtx x);\n+extern enum machine_mode score7_select_cc_mode (enum rtx_code op,\n+                                                rtx x,\n+                                                rtx y);\n+extern void score7_prologue (void);\n+extern void score7_epilogue (int sibcall_p);\n+extern void score7_gen_cmp (enum machine_mode mode);\n+extern void score7_call (rtx *ops, bool sib);\n+extern void score7_call_value (rtx *ops, bool sib);\n+extern void score7_movsicc (rtx *ops);\n+extern void score7_movdi (rtx *ops);\n+extern void score7_zero_extract_andi (rtx *ops);\n+extern const char * score7_select_add_imm (rtx *ops, bool set_cc);\n+extern const char * score7_select (rtx *ops, const char *inst_pre, bool commu,\n+                                   const char *letter, bool set_cc);\n+extern const char * score7_move (rtx *ops);\n+extern const char * score7_limm (rtx *ops);\n+extern const char *\n+score7_linsn (rtx *ops, enum score_mem_unit unit, bool sign);\n+extern const char *\n+score7_sinsn (rtx *ops, enum score_mem_unit unit);\n+#endif"}, {"sha": "f27484fea4651b1014698fe10fb436dab9dc38e3", "filename": "gcc/config/score/t-score-elf", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Ft-score-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254f522229578af1af093b2e4b6f1a0cc400d216/gcc%2Fconfig%2Fscore%2Ft-score-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Ft-score-elf?ref=254f522229578af1af093b2e4b6f1a0cc400d216", "patch": "@@ -1,9 +1,16 @@\n # Additional Backend Files\n-score-mdaux.o: $(srcdir)/config/score/score-mdaux.c $(CONFIG_H) $(SYSTEM_H) \\\n+score7.o: $(srcdir)/config/score/score7.c $(CONFIG_H) $(SYSTEM_H) \\\n   coretypes.h $(TM_H) $(RTL_H) output.h flags.h $(TREE_H) \\\n   expr.h toplev.h $(TM_P_H)\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n-\t$(srcdir)/config/score/score-mdaux.c\n+\t$(srcdir)/config/score/score7.c\n+\n+score3.o: $(srcdir)/config/score/score3.c $(CONFIG_H) $(SYSTEM_H) \\\n+  coretypes.h $(TM_H) $(RTL_H) output.h flags.h $(TREE_H) \\\n+  expr.h toplev.h $(TM_P_H)\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t$(srcdir)/config/score/score3.c\n+\n \n # Assemble startup files.\n $(T)crti.o: $(srcdir)/config/score/crti.asm $(GCC_PASSES)\n@@ -35,8 +42,8 @@ dp-bit.c: $(srcdir)/config/fp-bit.c\n # without the $gp register.\n TARGET_LIBGCC2_CFLAGS = -G 0\n \n-MULTILIB_OPTIONS = mmac mel fPIC\n-MULTILIB_MATCHES = fPIC=fpic\n+MULTILIB_OPTIONS = mscore3 mel\n+MULTILIB_MATCHES = mscore3=march?score3\n \n EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crti.o crtn.o\n "}]}