{"sha": "39ff5a967693c3aa56e8abf0e9c75fabe3335d8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlmZjVhOTY3NjkzYzNhYTU2ZThhYmYwZTljNzVmYWJlMzMzNWQ4ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-05-10T15:11:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-05-10T15:11:01Z"}, "message": "cgraphbuild.c (record_reference): Use cgraph_mark_address_taken_node.\n\n\t* cgraphbuild.c (record_reference): Use cgraph_mark_address_taken_node.\n\t* cgraph.c (cgraph_mark_address_taken_node): New function.\n\t(dump_cgraph_node): Dump new flag.\n\t* cgraph.h (struct cgraph_node): Add address_taken.\n\t(cgraph_mark_address_taken_node): New function.\n\t* cp/decl2.c (cxx_callgraph_analyze_expr): Use\n\tcgraph_mark_address_taken.\n\t* ipa.c (cgraph_postorder): Prioritize functions with address taken\n\tsince new direct calls can be born.\n\nFrom-SVN: r147342", "tree": {"sha": "74ceb2f1c2ecc5f55f8c3f84dd6a925d1b0918c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74ceb2f1c2ecc5f55f8c3f84dd6a925d1b0918c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39ff5a967693c3aa56e8abf0e9c75fabe3335d8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ff5a967693c3aa56e8abf0e9c75fabe3335d8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39ff5a967693c3aa56e8abf0e9c75fabe3335d8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ff5a967693c3aa56e8abf0e9c75fabe3335d8d/comments", "author": null, "committer": null, "parents": [{"sha": "9a0c61875533558e047cb5ef140d9836ed475ab9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0c61875533558e047cb5ef140d9836ed475ab9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a0c61875533558e047cb5ef140d9836ed475ab9"}], "stats": {"total": 111, "additions": 70, "deletions": 41}, "files": [{"sha": "935aaa4214af4b0c7c4c3209c57a9a82f998801f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ff5a967693c3aa56e8abf0e9c75fabe3335d8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ff5a967693c3aa56e8abf0e9c75fabe3335d8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39ff5a967693c3aa56e8abf0e9c75fabe3335d8d", "patch": "@@ -1,3 +1,15 @@\n+2009-05-10  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphbuild.c (record_reference): Use cgraph_mark_address_taken_node.\n+\t* cgraph.c (cgraph_mark_address_taken_node): New function.\n+\t(dump_cgraph_node): Dump new flag.\n+\t* cgraph.h (struct cgraph_node): Add address_taken.\n+\t(cgraph_mark_address_taken_node): New function.\n+\t* cp/decl2.c (cxx_callgraph_analyze_expr): Use\n+\tcgraph_mark_address_taken.\n+\t* ipa.c (cgraph_postorder): Prioritize functions with address taken\n+\tsince new direct calls can be born.\n+\n 2009-05-10  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-lex.c (c_lex_with_flags): Expect cpp_hashnode in"}, {"sha": "60ff1685dc99381300e659db9dbaefe3addc514f", "filename": "gcc/cgraph.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ff5a967693c3aa56e8abf0e9c75fabe3335d8d/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ff5a967693c3aa56e8abf0e9c75fabe3335d8d/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=39ff5a967693c3aa56e8abf0e9c75fabe3335d8d", "patch": "@@ -1293,6 +1293,15 @@ cgraph_mark_needed_node (struct cgraph_node *node)\n   cgraph_mark_reachable_node (node);\n }\n \n+/* Likewise indicate that a node is having address taken.  */\n+\n+void\n+cgraph_mark_address_taken_node (struct cgraph_node *node)\n+{\n+  node->address_taken = 1;\n+  cgraph_mark_needed_node (node);\n+}\n+\n /* Return local info for the compiled function.  */\n \n struct cgraph_local_info *\n@@ -1397,6 +1406,8 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     fprintf (f, \" nested in: %s\", cgraph_node_name (node->origin));\n   if (node->needed)\n     fprintf (f, \" needed\");\n+  if (node->address_taken)\n+    fprintf (f, \" address_taken\");\n   else if (node->reachable)\n     fprintf (f, \" reachable\");\n   if (gimple_has_body_p (node->decl))"}, {"sha": "2e4201ef51d929386be7772d4cb44344f3e4986b", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ff5a967693c3aa56e8abf0e9c75fabe3335d8d/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ff5a967693c3aa56e8abf0e9c75fabe3335d8d/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=39ff5a967693c3aa56e8abf0e9c75fabe3335d8d", "patch": "@@ -189,6 +189,8 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   /* Set when function must be output - it is externally visible\n      or its address is taken.  */\n   unsigned needed : 1;\n+  /* Set when function has address taken.  */\n+  unsigned address_taken : 1;\n   /* Set when decl is an abstract function pointed to by the\n      ABSTRACT_DECL_ORIGIN of a reachable function.  */\n   unsigned abstract_and_needed : 1;\n@@ -417,6 +419,7 @@ void cgraph_mark_if_needed (tree);\n void cgraph_finalize_compilation_unit (void);\n void cgraph_optimize (void);\n void cgraph_mark_needed_node (struct cgraph_node *);\n+void cgraph_mark_address_taken_node (struct cgraph_node *);\n void cgraph_mark_reachable_node (struct cgraph_node *);\n bool cgraph_inline_p (struct cgraph_edge *, cgraph_inline_failed_t *reason);\n bool cgraph_preserve_function_body_p (tree);"}, {"sha": "a7a8bd2b314f25fdd3f0bf9a9b8ae3f3dd0dd573", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ff5a967693c3aa56e8abf0e9c75fabe3335d8d/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ff5a967693c3aa56e8abf0e9c75fabe3335d8d/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=39ff5a967693c3aa56e8abf0e9c75fabe3335d8d", "patch": "@@ -58,7 +58,7 @@ record_reference (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t functions reachable unconditionally.  */\n       decl = TREE_OPERAND (*tp, 0);\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n-\tcgraph_mark_needed_node (cgraph_node (decl));\n+\tcgraph_mark_address_taken_node (cgraph_node (decl));\n       break;\n \n     default:"}, {"sha": "1f8e848bf2ebd6692ff88734065b76554e118a99", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ff5a967693c3aa56e8abf0e9c75fabe3335d8d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ff5a967693c3aa56e8abf0e9c75fabe3335d8d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=39ff5a967693c3aa56e8abf0e9c75fabe3335d8d", "patch": "@@ -3250,11 +3250,11 @@ cxx_callgraph_analyze_expr (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED)\n     {\n     case PTRMEM_CST:\n       if (TYPE_PTRMEMFUNC_P (TREE_TYPE (t)))\n-\tcgraph_mark_needed_node (cgraph_node (PTRMEM_CST_MEMBER (t)));\n+\tcgraph_mark_address_taken_node (cgraph_node (PTRMEM_CST_MEMBER (t)));\n       break;\n     case BASELINK:\n       if (TREE_CODE (BASELINK_FUNCTIONS (t)) == FUNCTION_DECL)\n-\tcgraph_mark_needed_node (cgraph_node (BASELINK_FUNCTIONS (t)));\n+\tcgraph_mark_address_taken_node (cgraph_node (BASELINK_FUNCTIONS (t)));\n       break;\n     case VAR_DECL:\n       if (DECL_VTABLE_OR_VTT_P (t))"}, {"sha": "fb3c74992f63c7174d8a3e4c436698596c6bb4d1", "filename": "gcc/ipa.c", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ff5a967693c3aa56e8abf0e9c75fabe3335d8d/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ff5a967693c3aa56e8abf0e9c75fabe3335d8d/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=39ff5a967693c3aa56e8abf0e9c75fabe3335d8d", "patch": "@@ -38,6 +38,7 @@ cgraph_postorder (struct cgraph_node **order)\n   int stack_size = 0;\n   int order_pos = 0;\n   struct cgraph_edge *edge, last;\n+  int pass;\n \n   struct cgraph_node **stack =\n     XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n@@ -48,44 +49,46 @@ cgraph_postorder (struct cgraph_node **order)\n      right through inline functions.  */\n   for (node = cgraph_nodes; node; node = node->next)\n     node->aux = NULL;\n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (!node->aux)\n-      {\n-\tnode2 = node;\n-\tif (!node->callers)\n-\t  node->aux = &last;\n-\telse\n-\t  node->aux = node->callers;\n-\twhile (node2)\n-\t  {\n-\t    while (node2->aux != &last)\n-\t      {\n-\t\tedge = (struct cgraph_edge *) node2->aux;\n-\t\tif (edge->next_caller)\n-\t\t  node2->aux = edge->next_caller;\n-\t\telse\n-\t\t  node2->aux = &last;\n-\t\tif (!edge->caller->aux)\n-\t\t  {\n-\t\t    if (!edge->caller->callers)\n-\t\t      edge->caller->aux = &last;\n-\t\t    else\n-\t\t      edge->caller->aux = edge->caller->callers;\n-\t\t    stack[stack_size++] = node2;\n-\t\t    node2 = edge->caller;\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t    if (node2->aux == &last)\n-\t      {\n-\t\torder[order_pos++] = node2;\n-\t\tif (stack_size)\n-\t\t  node2 = stack[--stack_size];\n-\t\telse\n-\t\t  node2 = NULL;\n-\t      }\n-\t  }\n-      }\n+  for (pass = 0; pass < 2; pass++)\n+    for (node = cgraph_nodes; node; node = node->next)\n+      if (!node->aux\n+\t  && (pass || (node->needed && !node->address_taken)))\n+\t{\n+\t  node2 = node;\n+\t  if (!node->callers)\n+\t    node->aux = &last;\n+\t  else\n+\t    node->aux = node->callers;\n+\t  while (node2)\n+\t    {\n+\t      while (node2->aux != &last)\n+\t\t{\n+\t\t  edge = (struct cgraph_edge *) node2->aux;\n+\t\t  if (edge->next_caller)\n+\t\t    node2->aux = edge->next_caller;\n+\t\t  else\n+\t\t    node2->aux = &last;\n+\t\t  if (!edge->caller->aux)\n+\t\t    {\n+\t\t      if (!edge->caller->callers)\n+\t\t\tedge->caller->aux = &last;\n+\t\t      else\n+\t\t\tedge->caller->aux = edge->caller->callers;\n+\t\t      stack[stack_size++] = node2;\n+\t\t      node2 = edge->caller;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      if (node2->aux == &last)\n+\t\t{\n+\t\t  order[order_pos++] = node2;\n+\t\t  if (stack_size)\n+\t\t    node2 = stack[--stack_size];\n+\t\t  else\n+\t\t    node2 = NULL;\n+\t\t}\n+\t    }\n+\t}\n   free (stack);\n   for (node = cgraph_nodes; node; node = node->next)\n     node->aux = NULL;"}]}