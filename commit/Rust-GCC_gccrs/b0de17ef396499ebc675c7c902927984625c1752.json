{"sha": "b0de17ef396499ebc675c7c902927984625c1752", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBkZTE3ZWYzOTY0OTllYmM2NzVjN2M5MDI5Mjc5ODQ2MjVjMTc1Mg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2010-01-03T13:13:03Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2010-01-03T13:13:03Z"}, "message": "postreload-gcse.c (insert_expr_in_table): Replace BLOCK_NUM with BLOCK_FOR_INSN.\n\n\t* postreload-gcse.c (insert_expr_in_table): Replace BLOCK_NUM\n\twith BLOCK_FOR_INSN.\n\t* auto-inc-dec.c (attempt_change, get_next_ref, find_inc): Likewise.\n\t* ifcvt.c (noce_get_alt_condition, noce_try_abs,\n\tnoce_process_if_block): Likewise.\n\t* gcse.c (compute_local_properties, insert_expr_in_table,\n\tinsert_set_in_table, canon_list_insert, find_avail_set,\n\tpre_insert_copy_insn): Likewise.\n\n\t* basic-block.h (BLOCK_NUM): Move from here...\n\t* sched-int.h (BLOCK_NUM): ... to here to localize it in the scheduler.\n\nFrom-SVN: r155586", "tree": {"sha": "637750849d7de92afc2bfea49d5fe684aeb3e776", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/637750849d7de92afc2bfea49d5fe684aeb3e776"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0de17ef396499ebc675c7c902927984625c1752", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0de17ef396499ebc675c7c902927984625c1752", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0de17ef396499ebc675c7c902927984625c1752", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0de17ef396499ebc675c7c902927984625c1752/comments", "author": null, "committer": null, "parents": [{"sha": "a8685e159ea52ae6507622f2a81e73f00ace490f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8685e159ea52ae6507622f2a81e73f00ace490f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8685e159ea52ae6507622f2a81e73f00ace490f"}], "stats": {"total": 65, "additions": 44, "deletions": 21}, "files": [{"sha": "01769cc1c8a1a31cd68d939011bc71d2d524c8b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0de17ef396499ebc675c7c902927984625c1752/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0de17ef396499ebc675c7c902927984625c1752/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0de17ef396499ebc675c7c902927984625c1752", "patch": "@@ -1,3 +1,17 @@\n+2010-01-03  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* postreload-gcse.c (insert_expr_in_table): Replace BLOCK_NUM\n+\twith BLOCK_FOR_INSN.\n+\t* auto-inc-dec.c (attempt_change, get_next_ref, find_inc): Likewise.\n+\t* ifcvt.c (noce_get_alt_condition, noce_try_abs,\n+\tnoce_process_if_block): Likewise.\n+\t* gcse.c (compute_local_properties, insert_expr_in_table,\n+\tinsert_set_in_table, canon_list_insert, find_avail_set,\n+\tpre_insert_copy_insn): Likewise.\n+\n+\t* basic-block.h (BLOCK_NUM): Move from here...\n+\t* sched-int.h (BLOCK_NUM): ... to here to localize it in the scheduler.\n+\n 2010-01-03  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/42438"}, {"sha": "7d48f4227c1cadcf8fa4d9998dee3f19577b02c5", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0de17ef396499ebc675c7c902927984625c1752/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0de17ef396499ebc675c7c902927984625c1752/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=b0de17ef396499ebc675c7c902927984625c1752", "patch": "@@ -470,7 +470,7 @@ attempt_change (rtx new_addr, rtx inc_reg)\n      passes are for.  The two cases where we have an inc insn will be\n      handled mov free.  */\n \n-  basic_block bb = BASIC_BLOCK (BLOCK_NUM (mem_insn.insn));\n+  basic_block bb = BLOCK_FOR_INSN (mem_insn.insn);\n   rtx mov_insn = NULL;\n   int regno;\n   rtx mem = *mem_insn.mem_loc;\n@@ -746,7 +746,7 @@ get_next_ref (int regno, basic_block bb, rtx *next_array)\n   rtx insn = next_array[regno];\n \n   /* Lazy about cleaning out the next_arrays.  */\n-  if (insn && BASIC_BLOCK (BLOCK_NUM (insn)) != bb)\n+  if (insn && BLOCK_FOR_INSN (insn) != bb)\n     {\n       next_array[regno] = NULL;\n       insn = NULL;\n@@ -969,7 +969,7 @@ static bool\n find_inc (bool first_try)\n {\n   rtx insn;\n-  basic_block bb = BASIC_BLOCK (BLOCK_NUM (mem_insn.insn));\n+  basic_block bb = BLOCK_FOR_INSN (mem_insn.insn);\n   rtx other_insn;\n   df_ref *def_rec;\n \n@@ -986,7 +986,7 @@ find_inc (bool first_try)\n \n   /* Find the next use that is an inc.  */\n   insn = get_next_ref (REGNO (mem_insn.reg0),\n-\t\t       BASIC_BLOCK (BLOCK_NUM (mem_insn.insn)),\n+\t\t       BLOCK_FOR_INSN (mem_insn.insn),\n \t\t       reg_next_inc_use);\n   if (!insn)\n     return false;\n@@ -1042,7 +1042,7 @@ find_inc (bool first_try)\n       /* Make sure that there is no insn that assigns to inc_insn.res\n \t between the mem_insn and the inc_insn.  */\n       rtx other_insn = get_next_ref (REGNO (inc_insn.reg_res),\n-\t\t\t\t     BASIC_BLOCK (BLOCK_NUM (mem_insn.insn)),\n+\t\t\t\t     BLOCK_FOR_INSN (mem_insn.insn),\n \t\t\t\t     reg_next_def);\n       if (other_insn != inc_insn.insn)\n \t{\n@@ -1053,7 +1053,7 @@ find_inc (bool first_try)\n \t}\n \n       other_insn = get_next_ref (REGNO (inc_insn.reg_res),\n-\t\t\t\t BASIC_BLOCK (BLOCK_NUM (mem_insn.insn)),\n+\t\t\t\t BLOCK_FOR_INSN (mem_insn.insn),\n \t\t\t\t reg_next_use);\n       if (other_insn\n \t  && (other_insn != inc_insn.insn)"}, {"sha": "891561140367391be6cc40dd2cba8e4b5be4cc97", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0de17ef396499ebc675c7c902927984625c1752/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0de17ef396499ebc675c7c902927984625c1752/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=b0de17ef396499ebc675c7c902927984625c1752", "patch": "@@ -499,8 +499,6 @@ extern bitmap_obstack reg_obstack;\n /* The two blocks that are always in the cfg.  */\n #define NUM_FIXED_BLOCKS (2)\n \n-\n-#define BLOCK_NUM(INSN)\t      (BLOCK_FOR_INSN (INSN)->index + 0)\n #define set_block_for_insn(INSN, BB)  (BLOCK_FOR_INSN (INSN) = BB)\n \n extern void compute_bb_for_insn (void);"}, {"sha": "77ac28e58d1d5c995970adf83924497a85539b21", "filename": "gcc/gcse.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0de17ef396499ebc675c7c902927984625c1752/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0de17ef396499ebc675c7c902927984625c1752/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=b0de17ef396499ebc675c7c902927984625c1752", "patch": "@@ -730,7 +730,7 @@ compute_local_properties (sbitmap *transp, sbitmap *comp, sbitmap *antloc,\n \t  if (antloc)\n \t    for (occr = expr->antic_occr; occr != NULL; occr = occr->next)\n \t      {\n-\t\tSET_BIT (antloc[BLOCK_NUM (occr->insn)], indx);\n+\t\tSET_BIT (antloc[BLOCK_FOR_INSN (occr->insn)->index], indx);\n \n \t\t/* While we're scanning the table, this is a good place to\n \t\t   initialize this.  */\n@@ -742,7 +742,7 @@ compute_local_properties (sbitmap *transp, sbitmap *comp, sbitmap *antloc,\n \t  if (comp)\n \t    for (occr = expr->avail_occr; occr != NULL; occr = occr->next)\n \t      {\n-\t\tSET_BIT (comp[BLOCK_NUM (occr->insn)], indx);\n+\t\tSET_BIT (comp[BLOCK_FOR_INSN (occr->insn)->index], indx);\n \n \t\t/* While we're scanning the table, this is a good place to\n \t\t   initialize this.  */\n@@ -1162,7 +1162,8 @@ insert_expr_in_table (rtx x, enum machine_mode mode, rtx insn, int antic_p,\n     {\n       antic_occr = cur_expr->antic_occr;\n \n-      if (antic_occr && BLOCK_NUM (antic_occr->insn) != BLOCK_NUM (insn))\n+      if (antic_occr\n+\t  && BLOCK_FOR_INSN (antic_occr->insn) != BLOCK_FOR_INSN (insn))\n \tantic_occr = NULL;\n \n       if (antic_occr)\n@@ -1186,7 +1187,8 @@ insert_expr_in_table (rtx x, enum machine_mode mode, rtx insn, int antic_p,\n     {\n       avail_occr = cur_expr->avail_occr;\n \n-      if (avail_occr && BLOCK_NUM (avail_occr->insn) == BLOCK_NUM (insn))\n+      if (avail_occr\n+\t  && BLOCK_FOR_INSN (avail_occr->insn) == BLOCK_FOR_INSN (insn))\n \t{\n \t  /* Found another instance of the expression in the same basic block.\n \t     Prefer this occurrence to the currently recorded one.  We want\n@@ -1259,7 +1261,8 @@ insert_set_in_table (rtx x, rtx insn, struct hash_table_d *table)\n   /* Now record the occurrence.  */\n   cur_occr = cur_expr->avail_occr;\n \n-  if (cur_occr && BLOCK_NUM (cur_occr->insn) == BLOCK_NUM (insn))\n+  if (cur_occr\n+      && BLOCK_FOR_INSN (cur_occr->insn) == BLOCK_FOR_INSN (insn))\n     {\n       /* Found another instance of the expression in the same basic block.\n \t Prefer this occurrence to the currently recorded one.  We want\n@@ -1592,7 +1595,7 @@ canon_list_insert (rtx dest ATTRIBUTE_UNUSED, const_rtx unused1 ATTRIBUTE_UNUSED\n   dest_addr = get_addr (XEXP (dest, 0));\n   dest_addr = canon_rtx (dest_addr);\n   insn = (rtx) v_insn;\n-  bb = BLOCK_NUM (insn);\n+  bb = BLOCK_FOR_INSN (insn)->index;\n \n   canon_modify_mem_list[bb] =\n     alloc_EXPR_LIST (VOIDmode, dest_addr, canon_modify_mem_list[bb]);\n@@ -1607,7 +1610,7 @@ canon_list_insert (rtx dest ATTRIBUTE_UNUSED, const_rtx unused1 ATTRIBUTE_UNUSED\n static void\n record_last_mem_set_info (rtx insn)\n {\n-  int bb = BLOCK_NUM (insn);\n+  int bb = BLOCK_FOR_INSN (insn)->index;\n \n   /* load_killed_in_block_p will handle the case of calls clobbering\n      everything.  */\n@@ -2335,7 +2338,8 @@ find_avail_set (int regno, rtx insn)\n \t which contains INSN.  */\n       while (set)\n \t{\n-\t  if (TEST_BIT (cprop_avin[BLOCK_NUM (insn)], set->bitmap_index))\n+\t  if (TEST_BIT (cprop_avin[BLOCK_FOR_INSN (insn)->index],\n+\t\t\tset->bitmap_index))\n \t    break;\n \t  set = next_set (regno, set);\n \t}\n@@ -3728,7 +3732,7 @@ pre_insert_copy_insn (struct expr *expr, rtx insn)\n   if (dump_file)\n     fprintf (dump_file,\n \t     \"PRE: bb %d, insn %d, copy expression %d in insn %d to reg %d\\n\",\n-\t      BLOCK_NUM (insn), INSN_UID (new_insn), indx,\n+\t      BLOCK_FOR_INSN (insn)->index, INSN_UID (new_insn), indx,\n \t      INSN_UID (insn), regno);\n }\n "}, {"sha": "9efd27d999fb537638fb8012bf353a06fca0b1cf", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0de17ef396499ebc675c7c902927984625c1752/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0de17ef396499ebc675c7c902927984625c1752/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=b0de17ef396499ebc675c7c902927984625c1752", "patch": "@@ -1553,7 +1553,8 @@ noce_get_alt_condition (struct noce_if_info *if_info, rtx target,\n       /* First, look to see if we put a constant in a register.  */\n       prev_insn = prev_nonnote_insn (if_info->cond_earliest);\n       if (prev_insn\n-\t  && BLOCK_NUM (prev_insn) == BLOCK_NUM (if_info->cond_earliest)\n+\t  && BLOCK_FOR_INSN (prev_insn)\n+\t     == BLOCK_FOR_INSN (if_info->cond_earliest)\n \t  && INSN_P (prev_insn)\n \t  && GET_CODE (PATTERN (prev_insn)) == SET)\n \t{\n@@ -1810,7 +1811,7 @@ noce_try_abs (struct noce_if_info *if_info)\n     {\n       rtx set, insn = prev_nonnote_insn (earliest);\n       if (insn\n-\t  && BLOCK_NUM (insn) == BLOCK_NUM (earliest)\n+\t  && BLOCK_FOR_INSN (insn) == BLOCK_FOR_INSN (earliest)\n \t  && (set = single_set (insn))\n \t  && rtx_equal_p (SET_DEST (set), c))\n \t{\n@@ -2291,7 +2292,7 @@ noce_process_if_block (struct noce_if_info *if_info)\n \t COND_EARLIEST to JUMP.  Make sure the relevant data is still\n \t intact.  */\n       if (! insn_b\n-\t  || BLOCK_NUM (insn_b) != BLOCK_NUM (if_info->cond_earliest)\n+\t  || BLOCK_FOR_INSN (insn_b) != BLOCK_FOR_INSN (if_info->cond_earliest)\n \t  || !NONJUMP_INSN_P (insn_b)\n \t  || (set_b = single_set (insn_b)) == NULL_RTX\n \t  || ! rtx_equal_p (x, SET_DEST (set_b))"}, {"sha": "dcd95eb71f81f5186707ffff44cb0a6a5c973dd5", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0de17ef396499ebc675c7c902927984625c1752/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0de17ef396499ebc675c7c902927984625c1752/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=b0de17ef396499ebc675c7c902927984625c1752", "patch": "@@ -363,7 +363,8 @@ insert_expr_in_table (rtx x, rtx insn)\n \n   /* Search for another occurrence in the same basic block.  */\n   avail_occr = cur_expr->avail_occr;\n-  while (avail_occr && BLOCK_NUM (avail_occr->insn) != BLOCK_NUM (insn))\n+  while (avail_occr\n+\t && BLOCK_FOR_INSN (avail_occr->insn) != BLOCK_FOR_INSN (insn))\n     {\n       /* If an occurrence isn't found, save a pointer to the end of\n \t the list.  */"}, {"sha": "c3b463e76a11b64d604fd44c0432263572f78b6b", "filename": "gcc/sched-int.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0de17ef396499ebc675c7c902927984625c1752/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0de17ef396499ebc675c7c902927984625c1752/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=b0de17ef396499ebc675c7c902927984625c1752", "patch": "@@ -1296,6 +1296,11 @@ extern int *rgn_bb_table;\n extern int *block_to_bb;\n extern int *containing_rgn;\n \n+/* Often used short-hand in the scheduler.  The rest of the compiler uses\n+   BLOCK_FOR_INSN(INSN) and an indirect reference to get the basic block\n+   number (\"index\").  For historical reasons, the scheduler does not.  */\n+#define BLOCK_NUM(INSN)\t      (BLOCK_FOR_INSN (INSN)->index + 0)\n+\n #define RGN_NR_BLOCKS(rgn) (rgn_table[rgn].rgn_nr_blocks)\n #define RGN_BLOCKS(rgn) (rgn_table[rgn].rgn_blocks)\n #define RGN_DONT_CALC_DEPS(rgn) (rgn_table[rgn].dont_calc_deps)"}]}