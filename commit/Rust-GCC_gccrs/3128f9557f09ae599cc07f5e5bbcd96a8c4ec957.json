{"sha": "3128f9557f09ae599cc07f5e5bbcd96a8c4ec957", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzEyOGY5NTU3ZjA5YWU1OTljYzA3ZjVlNWJiY2Q5NmE4YzRlYzk1Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-05T10:31:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-05T10:31:58Z"}, "message": "[multiple changes]\n\n2011-12-05  Bob Duff  <duff@adacore.com>\n\n\t* sem_ch3.adb (Derive_Progenitor_Subprograms): Add Ultimate_Alias\n\tto the Comes_From_Source check, to deal properly with the case\n\tof indirect inheritance of \"=\".\n\n2011-12-05  Thomas Quinot  <quinot@adacore.com>\n\n\tPR ada/51307\n\t* s-oscons-tmplt.c: On HP-UX, CLOCK_REALTIME is an enum literal,\n\tnot a macro.\n\n2011-12-05  Thomas Quinot  <quinot@adacore.com>\n\n\t* par_sco.adb, scos.ads, put_scos.adb, get_scos.adb: Generate dominance\n\tinformation in SCOs.\n\nFrom-SVN: r182004", "tree": {"sha": "c5762214db801c9b166c1ce7591579e4351a1260", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5762214db801c9b166c1ce7591579e4351a1260"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3128f9557f09ae599cc07f5e5bbcd96a8c4ec957", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3128f9557f09ae599cc07f5e5bbcd96a8c4ec957", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3128f9557f09ae599cc07f5e5bbcd96a8c4ec957", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3128f9557f09ae599cc07f5e5bbcd96a8c4ec957/comments", "author": null, "committer": null, "parents": [{"sha": "9b554be990bcff9fa165ce0c908bff280f2c5d97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b554be990bcff9fa165ce0c908bff280f2c5d97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b554be990bcff9fa165ce0c908bff280f2c5d97"}], "stats": {"total": 331, "additions": 237, "deletions": 94}, "files": [{"sha": "d546da6d8166605115dc1f573d4f486b6f82db27", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3128f9557f09ae599cc07f5e5bbcd96a8c4ec957/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3128f9557f09ae599cc07f5e5bbcd96a8c4ec957/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3128f9557f09ae599cc07f5e5bbcd96a8c4ec957", "patch": "@@ -1,3 +1,20 @@\n+2011-12-05  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_ch3.adb (Derive_Progenitor_Subprograms): Add Ultimate_Alias\n+\tto the Comes_From_Source check, to deal properly with the case\n+\tof indirect inheritance of \"=\".\n+\n+2011-12-05  Thomas Quinot  <quinot@adacore.com>\n+\n+\tPR ada/51307\n+\t* s-oscons-tmplt.c: On HP-UX, CLOCK_REALTIME is an enum literal,\n+\tnot a macro.\n+\n+2011-12-05  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* par_sco.adb, scos.ads, put_scos.adb, get_scos.adb: Generate dominance\n+\tinformation in SCOs.\n+\n 2011-12-02  Eric Botcazou  <ebotcazou@adacore.com>\n \t    Thomas Quinot <quinot@adacore.com>\n "}, {"sha": "47af1b22b6800c950d25b2ac40bbe332636d3f42", "filename": "gcc/ada/get_scos.adb", "status": "modified", "additions": 52, "deletions": 39, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3128f9557f09ae599cc07f5e5bbcd96a8c4ec957/gcc%2Fada%2Fget_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3128f9557f09ae599cc07f5e5bbcd96a8c4ec957/gcc%2Fada%2Fget_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_scos.adb?ref=3128f9557f09ae599cc07f5e5bbcd96a8c4ec957", "patch": "@@ -266,18 +266,13 @@ begin\n                Pid : Pragma_Id;\n \n             begin\n-               --  If continuation, reset Last indication in last entry\n-               --  stored for previous CS or cs line, and start with key\n-               --  set to s for continuations.\n+               Key := 'S';\n+\n+               --  If continuation, reset Last indication in last entry stored\n+               --  for previous CS or cs line.\n \n                if C = 's' then\n                   SCO_Table.Table (SCO_Table.Last).Last := False;\n-                  Key := 's';\n-\n-               --  CS case (first line, so start with key set to S)\n-\n-               else\n-                  Key := 'S';\n                end if;\n \n                --  Initialize to scan items on one line\n@@ -287,39 +282,54 @@ begin\n                --  Loop through items on one line\n \n                loop\n+                  Pid := Unknown_Pragma;\n                   Typ := Nextc;\n \n-                  if Typ in '1' .. '9' then\n-                     Typ := ' ';\n-                  else\n-                     Skipc;\n-                     if Typ = 'P' then\n-                        Pid := Unknown_Pragma;\n-\n-                        if Nextc not in '1' .. '9' then\n-                           N := 1;\n-                           loop\n-                              Buf (N) := Getc;\n-                              exit when Nextc = ':';\n-                              N := N + 1;\n-                           end loop;\n-                           Skipc;\n-\n-                           begin\n-                              Pid :=\n-                                Pragma_Id'Value (\"pragma_\" & Buf (1 .. N));\n-                           exception\n-                              when Constraint_Error =>\n-\n-                                 --  Pid remains set to Unknown_Pragma\n-\n-                                 null;\n-                           end;\n+                  case Typ is\n+                     when '>' =>\n+                        --  A dominance marker may be present only at an entry\n+                        --  point.\n+\n+                        pragma Assert (Key = 'S');\n+\n+                        Key := '>';\n+                        Typ := Nextc;\n+\n+                     when '1' .. '9' =>\n+                        Typ := ' ';\n+\n+                     when others =>\n+                        Skipc;\n+                        if Typ = 'P' then\n+                           if Nextc not in '1' .. '9' then\n+                              N := 1;\n+                              loop\n+                                 Buf (N) := Getc;\n+                                 exit when Nextc = ':';\n+                                 N := N + 1;\n+                              end loop;\n+                              Skipc;\n+\n+                              begin\n+                                 Pid :=\n+                                   Pragma_Id'Value (\"pragma_\" & Buf (1 .. N));\n+                              exception\n+                                 when Constraint_Error =>\n+\n+                                    --  Pid remains set to Unknown_Pragma\n+\n+                                    null;\n+                              end;\n+                           end if;\n                         end if;\n-                     end if;\n-                  end if;\n+                  end case;\n \n-                  Get_Source_Location_Range (Loc1, Loc2);\n+                  if Key = '>' and then Typ /= 'E' then\n+                     Get_Source_Location (Loc1);\n+                     Loc2 := No_Source_Location;\n+                  else\n+                     Get_Source_Location_Range (Loc1, Loc2);\n+                  end if;\n \n                   SCO_Table.Append\n                     ((C1          => Key,\n@@ -330,8 +340,11 @@ begin\n                       Pragma_Sloc => No_Location,\n                       Pragma_Name => Pid));\n \n+                  if Key = '>' then\n+                     Key := 'S';\n+                  end if;\n+\n                   exit when At_EOL;\n-                  Key := 's';\n                end loop;\n             end;\n "}, {"sha": "cffb76beae86b5eb2b722ee023435e7af2a5e3d1", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 108, "deletions": 35, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3128f9557f09ae599cc07f5e5bbcd96a8c4ec957/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3128f9557f09ae599cc07f5e5bbcd96a8c4ec957/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=3128f9557f09ae599cc07f5e5bbcd96a8c4ec957", "patch": "@@ -128,10 +128,24 @@ package body Par_SCO is\n       Pragma_Name : Pragma_Id  := Unknown_Pragma);\n    --  Append an entry to SCO_Table with fields set as per arguments\n \n-   procedure Traverse_Declarations_Or_Statements  (L : List_Id);\n+   type Dominant_Info is record\n+      K : Character;\n+      --  F/T/S/E for a valid dominance marker, or ' ' for no dominant\n+\n+      N : Node_Id;\n+      --  Node providing the sloc(s) for the dominance marker\n+   end record;\n+   No_Dominant : constant Dominant_Info := (' ', Empty);\n+\n+   procedure Traverse_Declarations_Or_Statements\n+     (L : List_Id;\n+      D : Dominant_Info := No_Dominant);\n+\n    procedure Traverse_Generic_Instantiation       (N : Node_Id);\n    procedure Traverse_Generic_Package_Declaration (N : Node_Id);\n-   procedure Traverse_Handled_Statement_Sequence  (N : Node_Id);\n+   procedure Traverse_Handled_Statement_Sequence\n+     (N : Node_Id;\n+      D : Dominant_Info := No_Dominant);\n    procedure Traverse_Package_Body                (N : Node_Id);\n    procedure Traverse_Package_Declaration         (N : Node_Id);\n    procedure Traverse_Protected_Body              (N : Node_Id);\n@@ -763,7 +777,7 @@ package body Par_SCO is\n          declare\n             T : SCO_Table_Entry renames SCO_Table.Table (Index);\n          begin\n-            pragma Assert (T.C1 = 'S' or else T.C1 = 's');\n+            pragma Assert (T.C1 = 'S');\n             return T.C2 = 'p';\n          end;\n \n@@ -899,7 +913,7 @@ package body Par_SCO is\n             --  Called multiple times for the same sloc (need to allow for\n             --  C2 = 'P') ???\n \n-            pragma Assert ((T.C1 = 'S' or else T.C1 = 's')\n+            pragma Assert (T.C1 = 'S'\n                              and then\n                            (T.C2 = 'p' or else T.C2 = 'P'));\n             T.C2 := 'P';\n@@ -1018,7 +1032,16 @@ package body Par_SCO is\n    --  ensure that decisions are output after the CS line for the statements\n    --  in which the decisions occur.\n \n-   procedure Traverse_Declarations_Or_Statements (L : List_Id) is\n+   procedure Traverse_Declarations_Or_Statements\n+     (L : List_Id;\n+      D : Dominant_Info := No_Dominant)\n+   is\n+      Current_Dominant : Dominant_Info := D;\n+      --  Dominance information for the current basic block\n+\n+      Current_Condition : Node_Id;\n+      --  Last tested condition in current IF statement\n+\n       N     : Node_Id;\n       Dummy : Source_Ptr;\n \n@@ -1041,15 +1064,8 @@ package body Par_SCO is\n       --  the range from the CASE token to the last token of the expression.\n \n       procedure Set_Statement_Entry;\n-      --  If Start is No_Location, does nothing, otherwise outputs a SCO_Table\n-      --  statement entry for the range Start-Stop and then sets both Start\n-      --  and Stop to No_Location.\n-      --  What are Start and Stop??? This comment seems completely unrelated\n-      --  to the implementation!???\n-      --  Unconditionally sets Term to True. What is Term???\n-      --  This is called when we find a statement or declaration that generates\n-      --  its own table entry, so that we must end the current statement\n-      --  sequence.\n+      --  Output CS entries for all statements saved in table SC, and end the\n+      --  current CS sequence.\n \n       procedure Process_Decisions_Defer (N : Node_Id; T : Character);\n       pragma Inline (Process_Decisions_Defer);\n@@ -1067,7 +1083,6 @@ package body Par_SCO is\n       -------------------------\n \n       procedure Set_Statement_Entry is\n-         C1      : Character;\n          SC_Last : constant Int := SC.Last;\n          SD_Last : constant Int := SD.Last;\n \n@@ -1076,9 +1091,25 @@ package body Par_SCO is\n \n          for J in SC_First .. SC_Last loop\n             if J = SC_First then\n-               C1 := 'S';\n-            else\n-               C1 := 's';\n+\n+               if Current_Dominant /= No_Dominant then\n+                  declare\n+                     From, To : Source_Ptr;\n+                  begin\n+                     Sloc_Range (Current_Dominant.N, From, To);\n+                     if Current_Dominant.K /= 'E' then\n+                        To := No_Location;\n+                     end if;\n+                     Set_Table_Entry\n+                       (C1          => '>',\n+                        C2          => Current_Dominant.K,\n+                        From        => From,\n+                        To          => To,\n+                        Last        => False,\n+                        Pragma_Sloc => No_Location,\n+                        Pragma_Name => Unknown_Pragma);\n+                  end;\n+               end if;\n             end if;\n \n             declare\n@@ -1102,7 +1133,7 @@ package body Par_SCO is\n                end if;\n \n                Set_Table_Entry\n-                 (C1          => C1,\n+                 (C1          => 'S',\n                   C2          => SCE.Typ,\n                   From        => SCE.From,\n                   To          => SCE.To,\n@@ -1112,6 +1143,13 @@ package body Par_SCO is\n             end;\n          end loop;\n \n+         --  Last statement of basic block, if present, becomes new current\n+         --  dominant.\n+\n+         if SC_Last >= SC_First then\n+            Current_Dominant := ('S', SC.Table (SC_Last).N);\n+         end if;\n+\n          --  Clear out used section of SC table\n \n          SC.Set_Last (SC_First - 1);\n@@ -1261,33 +1299,41 @@ package body Par_SCO is\n                   Extend_Statement_Sequence (N, ' ');\n                   Process_Decisions_Defer (Condition (N), 'E');\n                   Set_Statement_Entry;\n+                  Current_Dominant := No_Dominant;\n \n                --  Label, which breaks the current statement sequence, but the\n                --  label itself is not included in the next statement sequence,\n                --  since it generates no code.\n \n                when N_Label =>\n                   Set_Statement_Entry;\n+                  Current_Dominant := No_Dominant;\n \n                --  Block statement, which breaks the current statement sequence\n \n                when N_Block_Statement =>\n                   Set_Statement_Entry;\n-                  Traverse_Declarations_Or_Statements (Declarations (N));\n+                  Traverse_Declarations_Or_Statements\n+                    (L => Declarations (N),\n+                     D => Current_Dominant);\n                   Traverse_Handled_Statement_Sequence\n-                    (Handled_Statement_Sequence (N));\n+                    (N => Handled_Statement_Sequence (N),\n+                     D => Current_Dominant);\n \n                --  If statement, which breaks the current statement sequence,\n                --  but we include the condition in the current sequence.\n \n                when N_If_Statement =>\n-                  Extend_Statement_Sequence (N, Condition (N), 'I');\n-                  Process_Decisions_Defer (Condition (N), 'I');\n+                  Current_Condition := Condition (N);\n+                  Extend_Statement_Sequence (N, Current_Condition, 'I');\n+                  Process_Decisions_Defer (Current_Condition, 'I');\n                   Set_Statement_Entry;\n \n                   --  Now we traverse the statements in the THEN part\n \n-                  Traverse_Declarations_Or_Statements (Then_Statements (N));\n+                  Traverse_Declarations_Or_Statements\n+                    (L => Then_Statements (N),\n+                     D => ('T', Current_Condition));\n \n                   --  Loop through ELSIF parts if present\n \n@@ -1302,23 +1348,27 @@ package body Par_SCO is\n                            --  construct \"ELSIF condition\", so that we have\n                            --  a statement for the resulting decisions.\n \n+                           Current_Condition := Condition (Elif);\n                            Extend_Statement_Sequence\n-                             (Elif, Condition (Elif), 'I');\n-                           Process_Decisions_Defer (Condition (Elif), 'I');\n+                             (Elif, Current_Condition, 'I');\n+                           Process_Decisions_Defer (Current_Condition, 'I');\n                            Set_Statement_Entry;\n \n                            --  Traverse the statements in the ELSIF\n \n                            Traverse_Declarations_Or_Statements\n-                             (Then_Statements (Elif));\n+                             (L => Then_Statements (Elif),\n+                              D => ('T', Current_Condition));\n                            Next (Elif);\n                         end loop;\n                      end;\n                   end if;\n \n                   --  Finally traverse the ELSE statements if present\n \n-                  Traverse_Declarations_Or_Statements (Else_Statements (N));\n+                  Traverse_Declarations_Or_Statements\n+                    (L => Else_Statements (N),\n+                     D => ('F', Current_Condition));\n \n                --  Case statement, which breaks the current statement sequence,\n                --  but we include the expression in the current sequence.\n@@ -1328,14 +1378,17 @@ package body Par_SCO is\n                   Process_Decisions_Defer (Expression (N), 'X');\n                   Set_Statement_Entry;\n \n-                  --  Process case branches\n+                  --  Process case branches, all of which are dominated by the\n+                  --  CASE expression.\n \n                   declare\n                      Alt : Node_Id;\n                   begin\n                      Alt := First (Alternatives (N));\n                      while Present (Alt) loop\n-                        Traverse_Declarations_Or_Statements (Statements (Alt));\n+                        Traverse_Declarations_Or_Statements\n+                          (L => Statements (Alt),\n+                           D => ('S', Expression (N)));\n                         Next (Alt);\n                      end loop;\n                   end;\n@@ -1348,6 +1401,7 @@ package body Par_SCO is\n                     N_Raise_Statement   =>\n                   Extend_Statement_Sequence (N, ' ');\n                   Set_Statement_Entry;\n+                  Current_Dominant := No_Dominant;\n \n                --  Simple return statement. which is an exit point, but we\n                --  have to process the return expression for decisions.\n@@ -1356,6 +1410,7 @@ package body Par_SCO is\n                   Extend_Statement_Sequence (N, ' ');\n                   Process_Decisions_Defer (Expression (N), 'X');\n                   Set_Statement_Entry;\n+                  Current_Dominant := No_Dominant;\n \n                --  Extended return statement\n \n@@ -1367,7 +1422,10 @@ package body Par_SCO is\n                   Set_Statement_Entry;\n \n                   Traverse_Handled_Statement_Sequence\n-                    (Handled_Statement_Sequence (N));\n+                    (N => Handled_Statement_Sequence (N),\n+                     D => Current_Dominant);\n+\n+                  Current_Dominant := No_Dominant;\n \n                --  Loop ends the current statement sequence, but we include\n                --  the iteration scheme if present in the current sequence.\n@@ -1391,6 +1449,10 @@ package body Par_SCO is\n                            Extend_Statement_Sequence (N, ISC, 'W');\n                            Process_Decisions_Defer (Condition (ISC), 'W');\n \n+                           --  Set more specific dominant for inner statements\n+\n+                           Current_Dominant := ('T', Condition (ISC));\n+\n                         --  For statement\n \n                         else\n@@ -1402,7 +1464,13 @@ package body Par_SCO is\n                   end if;\n \n                   Set_Statement_Entry;\n-                  Traverse_Declarations_Or_Statements (Statements (N));\n+                  Traverse_Declarations_Or_Statements\n+                    (L => Statements (N),\n+                     D => Current_Dominant);\n+\n+                  --  Reset current dominant\n+\n+                  Current_Dominant := ('S', N);\n \n                --  Pragma\n \n@@ -1580,7 +1648,10 @@ package body Par_SCO is\n    -- Traverse_Handled_Statement_Sequence --\n    -----------------------------------------\n \n-   procedure Traverse_Handled_Statement_Sequence (N : Node_Id) is\n+   procedure Traverse_Handled_Statement_Sequence\n+     (N : Node_Id;\n+      D : Dominant_Info := No_Dominant)\n+   is\n       Handler : Node_Id;\n \n    begin\n@@ -1589,12 +1660,14 @@ package body Par_SCO is\n       --  which does not come from source, does not get a SCO.\n \n       if Present (N) and then Comes_From_Source (N) then\n-         Traverse_Declarations_Or_Statements (Statements (N));\n+         Traverse_Declarations_Or_Statements (Statements (N), D);\n \n          if Present (Exception_Handlers (N)) then\n             Handler := First (Exception_Handlers (N));\n             while Present (Handler) loop\n-               Traverse_Declarations_Or_Statements (Statements (Handler));\n+               Traverse_Declarations_Or_Statements\n+                 (L => Statements (Handler),\n+                  D => ('E', Handler));\n                Next (Handler);\n             end loop;\n          end if;"}, {"sha": "ec259815e80378078bfc11faff9b7275239bade8", "filename": "gcc/ada/put_scos.adb", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3128f9557f09ae599cc07f5e5bbcd96a8c4ec957/gcc%2Fada%2Fput_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3128f9557f09ae599cc07f5e5bbcd96a8c4ec957/gcc%2Fada%2Fput_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_scos.adb?ref=3128f9557f09ae599cc07f5e5bbcd96a8c4ec957", "patch": "@@ -133,9 +133,9 @@ begin\n             begin\n                case T.C1 is\n \n-                  --  Statements\n+                  --  Statements (and dominance markers)\n \n-                  when 'S' =>\n+                  when 'S' | '>' =>\n                      Ctr := 0;\n                      Continuation := False;\n                      loop\n@@ -161,9 +161,15 @@ begin\n                            Sent : SCO_Table_Entry\n                                     renames SCO_Table.Table (Start);\n                         begin\n+                           if Sent.C1 = '>' then\n+                              Write_Info_Char (Sent.C1);\n+                           end if;\n+\n                            if Sent.C2 /= ' ' then\n                               Write_Info_Char (Sent.C2);\n-                              if Sent.C2 = 'P'\n+\n+                              if Sent.C1 = 'S'\n+                                   and then Sent.C2 = 'P'\n                                    and then Sent.Pragma_Name /= Unknown_Pragma\n                               then\n                                  declare\n@@ -179,7 +185,15 @@ begin\n                               end if;\n                            end if;\n \n-                           Output_Range (Sent);\n+                           --  For dependence markers (except E), output sloc.\n+                           --  For >E and all statement entries, output sloc\n+                           --  range.\n+\n+                           if Sent.C1 = '>' and then Sent.C2 /= 'E' then\n+                              Output_Source_Location (Sent.From);\n+                           else\n+                              Output_Range (Sent);\n+                           end if;\n                         end;\n \n                         --  Increment entry counter (up to 6 entries per line,\n@@ -194,19 +208,12 @@ begin\n                      <<Next_Statement>>\n                         exit when SCO_Table.Table (Start).Last;\n                         Start := Start + 1;\n-                        pragma Assert (SCO_Table.Table (Start).C1 = 's');\n                      end loop;\n \n                      if Ctr > 0 then\n                         Write_Info_Terminate;\n                      end if;\n \n-                  --  Statement continuations should not occur since they\n-                  --  are supposed to have been handled in the loop above.\n-\n-                  when 's' =>\n-                     raise Program_Error;\n-\n                   --  Decision\n \n                   when 'E' | 'G' | 'I' | 'P' | 'W' | 'X' =>"}, {"sha": "e8a3b4dde9ce9fd74dd1e0a9a61dd3842e6bcf6c", "filename": "gcc/ada/s-oscons-tmplt.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3128f9557f09ae599cc07f5e5bbcd96a8c4ec957/gcc%2Fada%2Fs-oscons-tmplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3128f9557f09ae599cc07f5e5bbcd96a8c4ec957/gcc%2Fada%2Fs-oscons-tmplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-oscons-tmplt.c?ref=3128f9557f09ae599cc07f5e5bbcd96a8c4ec957", "patch": "@@ -1343,7 +1343,13 @@ CST(Inet_Pton_Linkname, \"\")\n \n */\n \n-#ifdef CLOCK_REALTIME\n+/* Note: On HP-UX, CLOCK_REALTIME is an enum, not a macro. */\n+\n+#if defined(CLOCK_REALTIME) || defined (__hpux__)\n+# define HAVE_CLOCK_REALTIME\n+#endif\n+\n+#ifdef HAVE_CLOCK_REALTIME\n CND(CLOCK_REALTIME, \"System realtime clock\")\n #endif\n \n@@ -1377,7 +1383,7 @@ CND(CLOCK_THREAD_CPUTIME_ID, \"Thread CPU clock\")\n # define CLOCK_RT_Ada \"CLOCK_MONOTONIC\"\n # define NEED_PTHREAD_CONDATTR_SETCLOCK\n \n-#elif defined(CLOCK_REALTIME)\n+#elif defined(HAVE_CLOCK_REALTIME)\n /* By default use CLOCK_REALTIME */\n # define CLOCK_RT_Ada \"CLOCK_REALTIME\"\n #endif"}, {"sha": "1f13e62b901caeab5485270185f53d7a2cb2c8db", "filename": "gcc/ada/scos.ads", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3128f9557f09ae599cc07f5e5bbcd96a8c4ec957/gcc%2Fada%2Fscos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3128f9557f09ae599cc07f5e5bbcd96a8c4ec957/gcc%2Fada%2Fscos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.ads?ref=3128f9557f09ae599cc07f5e5bbcd96a8c4ec957", "patch": "@@ -135,14 +135,14 @@ package SCOs is\n    --      any statement with a label (the label itself is not part of the\n    --       entry point that is recorded).\n \n-   --    Each entry point must appear as the first entry on a CS line.\n-   --    The idea is that if any simple statement on a CS line is known to have\n+   --    Each entry point must appear as the first statement entry on a CS\n+   --    line. Thus, if any simple statement on a CS line is known to have\n    --    been executed, then all statements that appear before it on the same\n    --    CS line are certain to also have been executed.\n \n    --    The form of a statement line in the ALI file is:\n \n-   --      CS *sloc-range [*sloc-range...]\n+   --      CS [dominance] *sloc-range [*sloc-range...]\n \n    --    where each sloc-range corresponds to a single statement, and * is\n    --    one of:\n@@ -165,6 +165,23 @@ package SCOs is\n \n    --    and is omitted for all other cases\n \n+   --    The optional dominance marker is of the form gives additional\n+   --    information as to how the sequence of statements denoted by the CS\n+   --    line can be entered:\n+\n+   --      >F<sloc>\n+   --        sequence is entered only if the decision at <sloc> is False\n+   --      >T<sloc>\n+   --        sequence is entered only if the decision at <sloc> is True\n+\n+   --      >S<sloc>\n+   --        sequence is entered only if the statement at <sloc> has been\n+   --        executed\n+\n+   --      >E<sloc-range>\n+   --        sequence is the sequence of statements for a exception_handler\n+   --        with the given sloc range\n+\n    --    Note: up to 6 entries can appear on a single CS line. If more than 6\n    --    entries appear in one logical statement sequence, continuation lines\n    --    are marked by Cs and appear immediately after the CS line.\n@@ -381,7 +398,7 @@ package SCOs is\n    --  The SCO_Table_Entry values appear as follows:\n \n    --    Statements\n-   --      C1   = 'S' for entry point, 's' otherwise\n+   --      C1   = 'S'\n    --      C2   = statement type code to appear on CS line (or ' ' if none)\n    --      From = starting source location\n    --      To   = ending source location\n@@ -400,6 +417,15 @@ package SCOs is\n    --    Set_SCO_Pragma_Enabled changes C2 to 'P' to cause the entry to be\n    --    emitted in Put_SCOs.\n \n+   --    Dominance marker\n+   --      C1   = '>'\n+   --      C2   = 'F'/'T'/'S'/'E'\n+   --      From = Decision/statement sloc ('F'/'T'/'S'),\n+   --             handler first sloc ('E')\n+   --      To   = No_Source_Location ('F'/'T'/'S'), handler last sloc ('E')\n+\n+   --    Note: A dominance marker is always followed by a statement entry.\n+\n    --    Decision (EXIT/entry guard/IF/WHILE)\n    --      C1   = 'E'/'G'/'I'/'W' (for EXIT/entry Guard/IF/WHILE)\n    --      C2   = ' '"}, {"sha": "d94b94aaae94f2f3a7cf87a48371b5703aa4b6f1", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3128f9557f09ae599cc07f5e5bbcd96a8c4ec957/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3128f9557f09ae599cc07f5e5bbcd96a8c4ec957/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=3128f9557f09ae599cc07f5e5bbcd96a8c4ec957", "patch": "@@ -12820,14 +12820,15 @@ package body Sem_Ch3 is\n                Iface_Subp := Node (Prim_Elmt);\n \n                --  Exclude derivation of predefined primitives except those\n-               --  that come from source. Required to catch declarations of\n-               --  equality operators of interfaces. For example:\n+               --  that come from source, or are inherited from one that comes\n+               --  from source. Required to catch declarations of equality\n+               --  operators of interfaces. For example:\n \n                --     type Iface is interface;\n                --     function \"=\" (Left, Right : Iface) return Boolean;\n \n                if not Is_Predefined_Dispatching_Operation (Iface_Subp)\n-                 or else Comes_From_Source (Iface_Subp)\n+                 or else Comes_From_Source (Ultimate_Alias (Iface_Subp))\n                then\n                   E := Find_Primitive_Covering_Interface\n                          (Tagged_Type => Tagged_Type,"}]}