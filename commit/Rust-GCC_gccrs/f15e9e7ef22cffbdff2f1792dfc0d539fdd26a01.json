{"sha": "f15e9e7ef22cffbdff2f1792dfc0d539fdd26a01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE1ZTllN2VmMjJjZmZiZGZmMmYxNzkyZGZjMGQ1MzlmZGQyNmEwMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-06-25T20:23:17Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-06-25T20:23:17Z"}, "message": "Reorganize thread implementation to make a clearly defined\nfront-end/back-end interface.\n\nFrom-SVN: r14309", "tree": {"sha": "cef4395bdf1ffbd706d14d10888e5fe49e39dfe5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cef4395bdf1ffbd706d14d10888e5fe49e39dfe5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f15e9e7ef22cffbdff2f1792dfc0d539fdd26a01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f15e9e7ef22cffbdff2f1792dfc0d539fdd26a01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f15e9e7ef22cffbdff2f1792dfc0d539fdd26a01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f15e9e7ef22cffbdff2f1792dfc0d539fdd26a01/comments", "author": null, "committer": null, "parents": [{"sha": "61f77e446b6cfdae97249ed5e24396d7627dffc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f77e446b6cfdae97249ed5e24396d7627dffc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61f77e446b6cfdae97249ed5e24396d7627dffc4"}], "stats": {"total": 88, "additions": 63, "deletions": 25}, "files": [{"sha": "034cb5a6b8165cc07c47aa218185fc3622f490a8", "filename": "gcc/objc/THREADS", "status": "modified", "additions": 63, "deletions": 25, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15e9e7ef22cffbdff2f1792dfc0d539fdd26a01/gcc%2Fobjc%2FTHREADS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15e9e7ef22cffbdff2f1792dfc0d539fdd26a01/gcc%2Fobjc%2FTHREADS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FTHREADS?ref=f15e9e7ef22cffbdff2f1792dfc0d539fdd26a01", "patch": "@@ -119,7 +119,33 @@ that programs which rely upon the ObjC thread and mutex functions will\n compile and link correctly but attempting to create a thread or mutex will\n result in an error.\n \n+It is questionable whether it is really necessary to have both a\n+frontend and backend function for all available functionality.  On the\n+one hand, it provides a clear, consistent differentiation between what\n+is public and what is private with the downside of having the overhead\n+of multiple functions calls.  For example, the function to have a thread\n+yield the processor is objc_thread_yield; in the current implementation\n+this produces a function call set:\n \n+objc_thread_yield()  ->  __objc_thread_yield()  ->  system yield function\n+\n+This has two extra function calls over calling the platform specific function\n+explicitly, but the issue is whether only the overhead of a single function\n+is necessary.\n+\n+objc_thread_yield()  ->  system yield function\n+\n+This breaks the public/private dichotomy between the frontend/backend\n+for the sake of efficiency.  It is possible to just use a preprocessor\n+define so as to eliminate the extra function call:\n+\n+#define objc_thread_yield() __objc_thread_yield()\n+\n+This has the undesirable effect that if objc_thread_yield is actually\n+turned into a function based upon future need; then ObjC programs which\n+access the thread functions would need to be recompiled versus just\n+being relinked.\n+ \n ******************************************************************************\n * Threads:\n \n@@ -130,9 +156,19 @@ that the system implementation of malloc and free must be thread safe.\n If a system has multiple processors, the threads are configured for\n full parallel processing.\n \n+* Backend initialization functions\n+\n+__objc_init_thread_system(void), int\n+\tInitialize the thread subsystem.  Called once by __objc_exec_class.\n+\tReturn -1 if error otherwise return 0.\n+\n+__objc_close_thread_system(void), int\n+\tCloses the thread subsystem, not currently guaranteed to be called.\n+\tReturn -1 if error otherwise return 0.\n+\n *****\n * Frontend thread functions\n-* User programs should use these thread functions.\n+* User programs should use these functions.\n \n objc_thread_detach(SEL selector, id object, id argument), objc_thread_t\n \tCreates and detaches a new thread.  The new thread starts by\n@@ -173,15 +209,7 @@ objc_thread_get_data(void), void *\n * Backend thread functions\n * User programs should *NOT* directly call these functions.\n \n-__objc_init_thread_system(void), int\n-\tInitialize the thread subsystem.  Called once by __objc_exec_class.\n-\tReturn -1 if error otherwise return 0.\n-\n-__objc_fini_thread_system(void), int\n-\tCloses the thread subsystem, not currently guaranteed to be called.\n-\tReturn -1 if error otherwise return 0.\n-\n-__objc_thread_create(void (*func)(void *arg), void *arg), objc_thread_t\n+__objc_thread_detach(void (*func)(void *arg), void *arg), objc_thread_t\n \tSpawns a new thread executing func, called by objc_thread_detach.\n \tReturn NULL if error otherwise return thread id.\n \n@@ -222,36 +250,40 @@ last unlock on a mutex removes the system lock and allows other\n threads to access the mutex.\n \n *****\n-* Frontend thread functions\n-* User programs should use these thread functions.\n+* Frontend mutex functions\n+* User programs should use these functions.\n \n objc_mutex_allocate(void), objc_mutex_t\n \tAllocates a new mutex.  Mutex is initially unlocked.\n+\tReturn NULL if error otherwise return mutex pointer.\n \n objc_mutex_deallocate(objc_mutex_t mutex), int\n \tFree a mutex.  Before freeing the mutex, makes sure that no\n \tone else is using it.\n+\tReturn -1 if error otherwise return 0.\n \n objc_mutex_lock(objc_mutex_t mutex), int\n \tLocks a mutex.  As mentioned earlier, the same thread may call\n \tthis routine repeatedly.\n+\tReturn -1 if error otherwise return 0.\n \t\n objc_mutex_trylock(objc_mutex_t mutex), int\n-\tAttempts to lock a mutex.  Returns -1 if failed.  If lock on\n-\tmutex can be acquired then function operates exactly as\n-\tobjc_mutex_lock.\n+\tAttempts to lock a mutex.  If lock on mutex can be acquired \n+\tthen function operates exactly as objc_mutex_lock.\n+\tReturn -1 if failed to acquire lock otherwise return 0.\n \n objc_mutex_unlock(objc_mutex_t mutex), int\n \tUnlocks the mutex by one level.  Other threads may not acquire\n \tthe mutex until this thread has released all locks on it.\n+\tReturn -1 if error otherwise return 0.\n \n *****\n-* Backend thread functions\n+* Backend mutex functions\n * User programs should *NOT* directly call these functions.\n \n-__objc_mutex_allocate(void), objc_mutex_t\n+__objc_mutex_allocate(objc_mutex_t mutex), int\n \tAllocates a new mutex, called by objc_mutex_allocate.\n-\tReturn NULL if error otherwise return mutex pointer.\n+\tReturn -1 if error otherwise return 0.\n \n __objc_mutex_deallocate(objc_mutex_t mutex), int\n \tFree a mutex, called by objc_mutex_deallocate.\n@@ -277,9 +309,10 @@ its owner (by thread id) and how many times it has been locked.  The\n last unlock on a mutex removes the system lock and allows other\n threads to access the mutex.\n \n-*****\n-* Frontend thread functions\n-* User programs should use these thread functions.\n+*\n+* Frontend condition mutex functions\n+* User programs should use these functions.\n+*\n \n objc_condition_allocate(void), objc_condition_t \n \tAllocate a condition mutex.\n@@ -291,6 +324,7 @@ objc_condition_deallocate(objc_condition_t condition), int\n \topportunity to wake.  It is legal to dealloc a condition only\n \tif no other thread is/will be using it. Does NOT check for\n \tother threads waiting but just wakes them up.\n+\tReturn -1 if error otherwise return 0.\n \n objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex), int\n \tWait on the condition unlocking the mutex until objc_condition_signal()\n@@ -299,23 +333,27 @@ objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex), int\n \there, for someone else can lock it and signal/broadcast the condition.\n \tThe mutex is used to lock access to the shared data that make up the\n \t\"condition\" predicate.\n+\tReturn -1 if error otherwise return 0.\n \t\n objc_condition_broadcast(objc_condition_t condition), int\n \tWake up all threads waiting on this condition. It is recommended that \n \tthe called would lock the same mutex as the threads in\n \tobjc_condition_wait before changing the \"condition predicate\"\n \tand make this call and unlock it right away after this call.\n+\tReturn -1 if error otherwise return 0.\n \n objc_condition_signal(objc_condition_t condition), int\n \tWake up one thread waiting on this condition.\n+\tReturn -1 if error otherwise return 0.\n \n-*****\n-* Backend thread functions\n+*\n+* Backend condition mutex functions\n * User programs should *NOT* directly call these functions.\n+*\n \n-__objc_condition_allocate(void), objc_condition_t \n+__objc_condition_allocate(objc_condition_t condition), int\n \tAllocate a condition mutex, called by objc_condition_allocate.\n-\tReturn NULL if error otherwise return condition pointer.\n+\tReturn -1 if error otherwise return 0.\n \n __objc_condition_deallocate(objc_condition_t condition), int\n \tDeallocate a condition, called by objc_condition_deallocate."}]}