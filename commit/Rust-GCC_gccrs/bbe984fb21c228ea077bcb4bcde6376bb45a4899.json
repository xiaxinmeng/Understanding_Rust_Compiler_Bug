{"sha": "bbe984fb21c228ea077bcb4bcde6376bb45a4899", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJlOTg0ZmIyMWMyMjhlYTA3N2JjYjRiY2RlNjM3NmJiNDVhNDg5OQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2007-08-15T17:37:33Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2007-08-15T17:37:33Z"}, "message": "tree-ssa-alias.c (compute_memory_partitions): Use alias_bitmap_obstack to allocate bitmaps.\n\n\n\t* tree-ssa-alias.c (compute_memory_partitions): Use\n\talias_bitmap_obstack to allocate bitmaps.\n\t(reset_alias_info): Factor out of init_alias_info.\n\tMark all name tags not associated to an SSA name for renaming.\n\t(init_alias_info): Call it.\n\t(create_name_tags): Tidy.  Add comments.\n\t(dump_points_to_info_for): Do not call get_mem_sym_stats_for.\n\ntestsuite/ChangeLog\n\n\tgcc.dg/tree-ssa/20070815.c: New test.\n\nFrom-SVN: r127520", "tree": {"sha": "fd79a84b87f517fe99964e6f19729cf28e159637", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd79a84b87f517fe99964e6f19729cf28e159637"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbe984fb21c228ea077bcb4bcde6376bb45a4899", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbe984fb21c228ea077bcb4bcde6376bb45a4899", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbe984fb21c228ea077bcb4bcde6376bb45a4899", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbe984fb21c228ea077bcb4bcde6376bb45a4899/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b413c535af276684074dee54eb322168f52689a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b413c535af276684074dee54eb322168f52689a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b413c535af276684074dee54eb322168f52689a8"}], "stats": {"total": 246, "additions": 177, "deletions": 69}, "files": [{"sha": "f7e3103846022408e869cfe3eb2e2634ee2b6ab4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbe984fb21c228ea077bcb4bcde6376bb45a4899/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbe984fb21c228ea077bcb4bcde6376bb45a4899/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bbe984fb21c228ea077bcb4bcde6376bb45a4899", "patch": "@@ -1,3 +1,13 @@\n+2007-08-15  Diego Novillo  <dnovillo@google.com>\n+\n+\t* tree-ssa-alias.c (compute_memory_partitions): Use\n+\talias_bitmap_obstack to allocate bitmaps.\n+\t(reset_alias_info): Factor out of init_alias_info.\n+\tMark all name tags not associated to an SSA name for renaming.\n+\t(init_alias_info): Call it.\n+\t(create_name_tags): Tidy.  Add comments.\n+\t(dump_points_to_info_for): Do not call get_mem_sym_stats_for.\n+\n 2007-08-15  Maxim Kuvyrkov  <maxim@codesourcery.com>\n \n \t* config/mips/mips.c (vr4130_swap_insns_p): Use new interface to"}, {"sha": "5515a9c4d9ca225e3df321a094a554b2fec930b8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbe984fb21c228ea077bcb4bcde6376bb45a4899/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbe984fb21c228ea077bcb4bcde6376bb45a4899/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bbe984fb21c228ea077bcb4bcde6376bb45a4899", "patch": "@@ -1,3 +1,7 @@\n+2007-08-15  Diego Novillo  <dnovillo@google.com>\n+\n+\tgcc.dg/tree-ssa/20070815.c: New test.\n+\n 2007-08-15  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/33077"}, {"sha": "fa0e69f7cc4d19efb86a37d671b05bf9942a8296", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20070815.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbe984fb21c228ea077bcb4bcde6376bb45a4899/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20070815.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbe984fb21c228ea077bcb4bcde6376bb45a4899/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20070815.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20070815.c?ref=bbe984fb21c228ea077bcb4bcde6376bb45a4899", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -w\" } */\n+\n+/* This code snippet from glibc 2.3.5 was causing an ICE during\n+   optimization because we were failing to update the SSA form for\n+   stale name tags.  These are tags that are associated with SSA pointers\n+   that have been removed from the IL.  This was causing the SSA\n+   verifier to fail before we had a chance to run the cleanup pass that\n+   finally removes all the remaining PHI nodes for the stale name tag.  */\n+struct _IO_wide_data\n+{\n+};\n+struct _IO_FILE {\n+};\n+typedef struct _IO_FILE _IO_FILE;\n+struct _IO_jump_t\n+{\n+};\n+struct _IO_FILE_plus\n+{\n+  _IO_FILE file;\n+};\n+extern const struct _IO_jump_t _IO_file_jumps_maybe_mmap ;\n+extern const struct _IO_jump_t _IO_wfile_jumps;\n+extern const struct _IO_jump_t _IO_wfile_jumps_maybe_mmap ;\n+\n+_IO_new_fdopen (fd, mode)\n+     const char *mode;\n+{\n+  int read_write;\n+  int posix_mode = 0;\n+  struct locked_FILE\n+  {\n+    struct _IO_FILE_plus fp;\n+    struct _IO_wide_data wd;\n+  } *new_f;\n+  int fd_flags;\n+  int use_mmap = 0;\n+    {\n+  }\n+    {\n+      switch (*++mode)\n+ {\n+ case '\\0':\n+   use_mmap = 1;\n+ }\n+    }\n+  if (((fd_flags & 0003) == 00 && !(read_write & 8))\n+      || ((fd_flags & 0003) == 01 && !(read_write & 4)))\n+    {\n+    }\n+  if ((posix_mode & 02000) && !(fd_flags & 02000))\n+    return ((void *)0);\n+  _IO_no_init (&new_f->fp.file, 0, 0, &new_f->wd,\n+        (use_mmap && (read_write & 8))\n+        ? &_IO_wfile_jumps_maybe_mmap :\n+        &_IO_wfile_jumps);\n+    (use_mmap && (read_write & 8)) ? &_IO_file_jumps_maybe_mmap :\n+  _IO_file_init (&new_f->fp);\n+}"}, {"sha": "3a490fcc225ab50fc07e743a4398937ef6dde52e", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 103, "deletions": 69, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbe984fb21c228ea077bcb4bcde6376bb45a4899/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbe984fb21c228ea077bcb4bcde6376bb45a4899/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=bbe984fb21c228ea077bcb4bcde6376bb45a4899", "patch": "@@ -1497,7 +1497,7 @@ compute_memory_partitions (void)\n      virtual operands.  However, by reducing the size of the alias\n      sets to be scanned, the work needed inside the operand scanner is\n      significantly reduced.  */\n-  new_aliases = BITMAP_ALLOC (NULL);\n+  new_aliases = BITMAP_ALLOC (&alias_bitmap_obstack);\n \n   for (i = 0; VEC_iterate (tree, tags, i, tag); i++)\n     {\n@@ -1891,6 +1891,103 @@ init_mem_ref_stats (void)\n }\n \n \n+/* Helper for init_alias_info.  Reset existing aliasing information.  */\n+\n+static void\n+reset_alias_info (void)\n+{\n+  referenced_var_iterator rvi;\n+  tree var;\n+  unsigned i;\n+  bitmap active_nmts, all_nmts;\n+\n+  /* Clear the set of addressable variables.  We do not need to clear\n+     the TREE_ADDRESSABLE bit on every symbol because we are going to\n+     re-compute addressability here.  */\n+  bitmap_clear (gimple_addressable_vars (cfun));\n+\n+  active_nmts = BITMAP_ALLOC (&alias_bitmap_obstack);\n+  all_nmts = BITMAP_ALLOC (&alias_bitmap_obstack);\n+\n+  /* Clear flow-insensitive alias information from each symbol.  */\n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n+    {\n+      if (is_gimple_reg (var))\n+\tcontinue;\n+\n+      if (MTAG_P (var))\n+\tMTAG_ALIASES (var) = NULL;\n+\n+      /* Memory partition information will be computed from scratch.  */\n+      if (TREE_CODE (var) == MEMORY_PARTITION_TAG)\n+\tMPT_SYMBOLS (var) = NULL;\n+\n+      /* Collect all the name tags to determine if we have any\n+\t orphaned that need to be removed from the IL.  A name tag\n+\t will be orphaned if it is not associated with any active SSA\n+\t name.  */\n+      if (TREE_CODE (var) == NAME_MEMORY_TAG)\n+\tbitmap_set_bit (all_nmts, DECL_UID (var));\n+\n+      /* Since we are about to re-discover call-clobbered\n+\t variables, clear the call-clobbered flag.  Variables that\n+\t are intrinsically call-clobbered (globals, local statics,\n+\t etc) will not be marked by the aliasing code, so we can't\n+\t remove them from CALL_CLOBBERED_VARS.  \n+\n+\t NB: STRUCT_FIELDS are still call clobbered if they are for a\n+\t global variable, so we *don't* clear their call clobberedness\n+\t just because they are tags, though we will clear it if they\n+\t aren't for global variables.  */\n+      if (TREE_CODE (var) == NAME_MEMORY_TAG\n+\t  || TREE_CODE (var) == SYMBOL_MEMORY_TAG\n+\t  || TREE_CODE (var) == MEMORY_PARTITION_TAG\n+\t  || !is_global_var (var))\n+\tclear_call_clobbered (var);\n+    }\n+\n+  /* Clear flow-sensitive points-to information from each SSA name.  */\n+  for (i = 1; i < num_ssa_names; i++)\n+    {\n+      tree name = ssa_name (i);\n+\n+      if (!name || !POINTER_TYPE_P (TREE_TYPE (name)))\n+\tcontinue;\n+\n+      if (SSA_NAME_PTR_INFO (name))\n+\t{\n+\t  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (name);\n+\n+\t  /* Clear all the flags but keep the name tag to\n+\t     avoid creating new temporaries unnecessarily.  If\n+\t     this pointer is found to point to a subset or\n+\t     superset of its former points-to set, then a new\n+\t     tag will need to be created in create_name_tags.  */\n+\t  pi->pt_anything = 0;\n+\t  pi->pt_null = 0;\n+\t  pi->value_escapes_p = 0;\n+\t  pi->is_dereferenced = 0;\n+\t  if (pi->pt_vars)\n+\t    bitmap_clear (pi->pt_vars);\n+\n+\t  /* Add NAME's name tag to the set of active tags.  */\n+\t  if (pi->name_mem_tag)\n+\t    bitmap_set_bit (active_nmts, DECL_UID (pi->name_mem_tag));\n+\t}\n+    }\n+\n+  /* Name memory tags that are no longer associated with an SSA name\n+     are considered stale and should be removed from the IL.  All the\n+     name tags that are in the set ALL_NMTS but not in ACTIVE_NMTS are\n+     considered stale and marked for renaming.  */\n+  bitmap_and_compl_into (all_nmts, active_nmts);\n+  mark_set_for_renaming (all_nmts);\n+\n+  BITMAP_FREE (all_nmts);\n+  BITMAP_FREE (active_nmts);\n+}\n+\n+\n /* Initialize the data structures used for alias analysis.  */\n \n static struct alias_info *\n@@ -1913,70 +2010,7 @@ init_alias_info (void)\n \n   /* If aliases have been computed before, clear existing information.  */\n   if (gimple_aliases_computed_p (cfun))\n-    {\n-      unsigned i;\n-      \n-      /* Similarly, clear the set of addressable variables.  In this\n-\t case, we can just clear the set because addressability is\n-\t only computed here.  */\n-      bitmap_clear (gimple_addressable_vars (cfun));\n-\n-      /* Clear flow-insensitive alias information from each symbol.  */\n-      FOR_EACH_REFERENCED_VAR (var, rvi)\n-\t{\n-\t  if (is_gimple_reg (var))\n-\t    continue;\n-\n-\t  if (MTAG_P (var))\n-\t    MTAG_ALIASES (var) = NULL;\n-\n-\t  /* Memory partition information will be computed from scratch.  */\n-\t  if (TREE_CODE (var) == MEMORY_PARTITION_TAG)\n-\t    MPT_SYMBOLS (var) = NULL;\n-\n-\t  /* Since we are about to re-discover call-clobbered\n-\t     variables, clear the call-clobbered flag.  Variables that\n-\t     are intrinsically call-clobbered (globals, local statics,\n-\t     etc) will not be marked by the aliasing code, so we can't\n-\t     remove them from CALL_CLOBBERED_VARS.  \n-\n-\t     NB: STRUCT_FIELDS are still call clobbered if they are\n-\t     for a global variable, so we *don't* clear their call\n-\t     clobberedness just because they are tags, though we will\n-\t     clear it if they aren't for global variables.  */\n-\t  if (TREE_CODE (var) == NAME_MEMORY_TAG\n-\t      || TREE_CODE (var) == SYMBOL_MEMORY_TAG\n-\t      || TREE_CODE (var) == MEMORY_PARTITION_TAG\n-\t      || !is_global_var (var))\n-\t    clear_call_clobbered (var);\n-\t}\n-\n-      /* Clear flow-sensitive points-to information from each SSA name.  */\n-      for (i = 1; i < num_ssa_names; i++)\n-\t{\n-\t  tree name = ssa_name (i);\n-\n-\t  if (!name || !POINTER_TYPE_P (TREE_TYPE (name)))\n-\t    continue;\n-\n-\t  if (SSA_NAME_PTR_INFO (name))\n-\t    {\n-\t      struct ptr_info_def *pi = SSA_NAME_PTR_INFO (name);\n-\n-\t      /* Clear all the flags but keep the name tag to\n-\t\t avoid creating new temporaries unnecessarily.  If\n-\t\t this pointer is found to point to a subset or\n-\t\t superset of its former points-to set, then a new\n-\t\t tag will need to be created in create_name_tags.  */\n-\t      pi->pt_anything = 0;\n-\t      pi->pt_null = 0;\n-\t      pi->value_escapes_p = 0;\n-\t      pi->is_dereferenced = 0;\n-\t      if (pi->pt_vars)\n-\t\tbitmap_clear (pi->pt_vars);\n-\t    }\n-\t}\n-    }\n+    reset_alias_info ();\n   else\n     {\n       /* If this is the first time we compute aliasing information,\n@@ -2123,6 +2157,7 @@ create_name_tags (void)\n       else\n \t{\n \t  *slot = pi;\n+\n \t  /* If we didn't find a pointer with the same points-to set\n \t     as PTR, create a new name tag if needed.  */\n \t  if (pi->name_mem_tag == NULL_TREE)\n@@ -2135,7 +2170,8 @@ create_name_tags (void)\n \t renaming.  */\n       if (old_name_tag && old_name_tag != pi->name_mem_tag)\n \tmark_sym_for_renaming (old_name_tag);\n-      \n+\n+      /* Inherit volatility from the pointed-to type.  */\n       TREE_THIS_VOLATILE (pi->name_mem_tag)\n \t|= TREE_THIS_VOLATILE (TREE_TYPE (TREE_TYPE (ptr)));\n       \n@@ -3215,9 +3251,7 @@ dump_points_to_info_for (FILE *file, tree ptr)\n \t}\n \n       if (pi->is_dereferenced)\n-\tfprintf (file, \", is dereferenced (R=%ld, W=%ld)\",\n-\t\t get_mem_sym_stats_for (ptr)->num_direct_reads,\n-\t\t get_mem_sym_stats_for (ptr)->num_direct_writes);\n+\tfprintf (file, \", is dereferenced\");\n \n       if (pi->value_escapes_p)\n \tfprintf (file, \", its value escapes\");"}]}