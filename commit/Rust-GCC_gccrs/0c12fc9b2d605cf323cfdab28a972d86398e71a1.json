{"sha": "0c12fc9b2d605cf323cfdab28a972d86398e71a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMxMmZjOWIyZDYwNWNmMzIzY2ZkYWIyOGE5NzJkODYzOThlNzFhMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:51:36Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:51:36Z"}, "message": "poly_int: rtx constants\n\nThis patch adds an rtl representation of poly_int values.\nThere were three possible ways of doing this:\n\n(1) Add a new rtl code for the poly_ints themselves and store the\n    coefficients as trailing wide_ints.  This would give constants like:\n\n      (const_poly_int [c0 c1 ... cn])\n\n    The runtime value would be:\n\n      c0 + c1 * x1 + ... + cn * xn\n\n(2) Like (1), but use rtxes for the coefficients.  This would give\n    constants like:\n\n      (const_poly_int [(const_int c0)\n                       (const_int c1)\n                       ...\n                       (const_int cn)])\n\n    although the coefficients could be const_wide_ints instead\n    of const_ints where appropriate.\n\n(3) Add a new rtl code for the polynomial indeterminates,\n    then use them in const wrappers.  A constant like c0 + c1 * x1\n    would then look like:\n\n      (const:M (plus:M (mult:M (const_param:M x1)\n                               (const_int c1))\n                       (const_int c0)))\n\nThere didn't seem to be that much to choose between them.  The main\nadvantage of (1) is that it's a more efficient representation and\nthat we can refer to the cofficients directly as wide_int_storage.\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* doc/rtl.texi (const_poly_int): Document.  Also document the\n\trtl sharing behavior.\n\t* gengenrtl.c (excluded_rtx): Return true for CONST_POLY_INT.\n\t* rtl.h (const_poly_int_def): New struct.\n\t(rtx_def::u): Add a cpi field.\n\t(CASE_CONST_UNIQUE, CASE_CONST_ANY): Add CONST_POLY_INT.\n\t(CONST_POLY_INT_P, CONST_POLY_INT_COEFFS): New macros.\n\t(wi::rtx_to_poly_wide_ref): New typedef\n\t(const_poly_int_value, wi::to_poly_wide, rtx_to_poly_int64)\n\t(poly_int_rtx_p): New functions.\n\t(trunc_int_for_mode): Declare a poly_int64 version.\n\t(plus_constant): Take a poly_int64 instead of a HOST_WIDE_INT.\n\t(immed_wide_int_const): Take a poly_wide_int_ref rather than\n\ta wide_int_ref.\n\t(strip_offset): Declare.\n\t(strip_offset_and_add): New function.\n\t* rtl.def (CONST_POLY_INT): New rtx code.\n\t* rtl.c (rtx_size): Handle CONST_POLY_INT.\n\t(shared_const_p): Use poly_int_rtx_p.\n\t* emit-rtl.h (gen_int_mode): Take a poly_int64 instead of a\n\tHOST_WIDE_INT.\n\t(gen_int_shift_amount): Likewise.\n\t* emit-rtl.c (const_poly_int_hasher): New class.\n\t(const_poly_int_htab): New variable.\n\t(init_emit_once): Initialize it when NUM_POLY_INT_COEFFS > 1.\n\t(const_poly_int_hasher::hash): New function.\n\t(const_poly_int_hasher::equal): Likewise.\n\t(gen_int_mode): Take a poly_int64 instead of a HOST_WIDE_INT.\n\t(immed_wide_int_const): Rename to...\n\t(immed_wide_int_const_1): ...this and make static.\n\t(immed_wide_int_const): New function, taking a poly_wide_int_ref\n\tinstead of a wide_int_ref.\n\t(gen_int_shift_amount): Take a poly_int64 instead of a HOST_WIDE_INT.\n\t(gen_lowpart_common): Handle CONST_POLY_INT.\n\t* cse.c (hash_rtx_cb, equiv_constant): Likewise.\n\t* cselib.c (cselib_hash_rtx): Likewise.\n\t* dwarf2out.c (const_ok_for_output_1): Likewise.\n\t* expr.c (convert_modes): Likewise.\n\t* print-rtl.c (rtx_writer::print_rtx, print_value): Likewise.\n\t* rtlhash.c (add_rtx): Likewise.\n\t* explow.c (trunc_int_for_mode): Add a poly_int64 version.\n\t(plus_constant): Take a poly_int64 instead of a HOST_WIDE_INT.\n\tHandle existing CONST_POLY_INT rtxes.\n\t* expmed.h (expand_shift): Take a poly_int64 instead of a\n\tHOST_WIDE_INT.\n\t* expmed.c (expand_shift): Likewise.\n\t* rtlanal.c (strip_offset): New function.\n\t(commutative_operand_precedence): Give CONST_POLY_INT the same\n\tprecedence as CONST_DOUBLE and put CONST_WIDE_INT between that\n\tand CONST_INT.\n\t* rtl-tests.c (const_poly_int_tests): New struct.\n\t(rtl_tests_c_tests): Use it.\n\t* simplify-rtx.c (simplify_const_unary_operation): Handle\n\tCONST_POLY_INT.\n\t(simplify_const_binary_operation): Likewise.\n\t(simplify_binary_operation_1): Fold additions of symbolic constants\n\tand CONST_POLY_INTs.\n\t(simplify_subreg): Handle extensions and truncations of\n\tCONST_POLY_INTs.\n\t(simplify_const_poly_int_tests): New struct.\n\t(simplify_rtx_c_tests): Use it.\n\t* wide-int.h (storage_ref): Add default constructor.\n\t(wide_int_ref_storage): Likewise.\n\t(trailing_wide_ints): Use GTY((user)).\n\t(trailing_wide_ints::operator[]): Add a const version.\n\t(trailing_wide_ints::get_precision): New function.\n\t(trailing_wide_ints::extra_size): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255862", "tree": {"sha": "ca58581589b8fa244d77652a9a9c06f5293a8bea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca58581589b8fa244d77652a9a9c06f5293a8bea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c12fc9b2d605cf323cfdab28a972d86398e71a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c12fc9b2d605cf323cfdab28a972d86398e71a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c12fc9b2d605cf323cfdab28a972d86398e71a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c12fc9b2d605cf323cfdab28a972d86398e71a1/comments", "author": null, "committer": null, "parents": [{"sha": "abd3c800109b95f09af3b3f1a7a43d9b7631f21c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abd3c800109b95f09af3b3f1a7a43d9b7631f21c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abd3c800109b95f09af3b3f1a7a43d9b7631f21c"}], "stats": {"total": 672, "additions": 638, "deletions": 34}, "files": [{"sha": "082f098e2123b51b3046cd0143597b80fb418c7d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -1,3 +1,75 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* doc/rtl.texi (const_poly_int): Document.  Also document the\n+\trtl sharing behavior.\n+\t* gengenrtl.c (excluded_rtx): Return true for CONST_POLY_INT.\n+\t* rtl.h (const_poly_int_def): New struct.\n+\t(rtx_def::u): Add a cpi field.\n+\t(CASE_CONST_UNIQUE, CASE_CONST_ANY): Add CONST_POLY_INT.\n+\t(CONST_POLY_INT_P, CONST_POLY_INT_COEFFS): New macros.\n+\t(wi::rtx_to_poly_wide_ref): New typedef\n+\t(const_poly_int_value, wi::to_poly_wide, rtx_to_poly_int64)\n+\t(poly_int_rtx_p): New functions.\n+\t(trunc_int_for_mode): Declare a poly_int64 version.\n+\t(plus_constant): Take a poly_int64 instead of a HOST_WIDE_INT.\n+\t(immed_wide_int_const): Take a poly_wide_int_ref rather than\n+\ta wide_int_ref.\n+\t(strip_offset): Declare.\n+\t(strip_offset_and_add): New function.\n+\t* rtl.def (CONST_POLY_INT): New rtx code.\n+\t* rtl.c (rtx_size): Handle CONST_POLY_INT.\n+\t(shared_const_p): Use poly_int_rtx_p.\n+\t* emit-rtl.h (gen_int_mode): Take a poly_int64 instead of a\n+\tHOST_WIDE_INT.\n+\t(gen_int_shift_amount): Likewise.\n+\t* emit-rtl.c (const_poly_int_hasher): New class.\n+\t(const_poly_int_htab): New variable.\n+\t(init_emit_once): Initialize it when NUM_POLY_INT_COEFFS > 1.\n+\t(const_poly_int_hasher::hash): New function.\n+\t(const_poly_int_hasher::equal): Likewise.\n+\t(gen_int_mode): Take a poly_int64 instead of a HOST_WIDE_INT.\n+\t(immed_wide_int_const): Rename to...\n+\t(immed_wide_int_const_1): ...this and make static.\n+\t(immed_wide_int_const): New function, taking a poly_wide_int_ref\n+\tinstead of a wide_int_ref.\n+\t(gen_int_shift_amount): Take a poly_int64 instead of a HOST_WIDE_INT.\n+\t(gen_lowpart_common): Handle CONST_POLY_INT.\n+\t* cse.c (hash_rtx_cb, equiv_constant): Likewise.\n+\t* cselib.c (cselib_hash_rtx): Likewise.\n+\t* dwarf2out.c (const_ok_for_output_1): Likewise.\n+\t* expr.c (convert_modes): Likewise.\n+\t* print-rtl.c (rtx_writer::print_rtx, print_value): Likewise.\n+\t* rtlhash.c (add_rtx): Likewise.\n+\t* explow.c (trunc_int_for_mode): Add a poly_int64 version.\n+\t(plus_constant): Take a poly_int64 instead of a HOST_WIDE_INT.\n+\tHandle existing CONST_POLY_INT rtxes.\n+\t* expmed.h (expand_shift): Take a poly_int64 instead of a\n+\tHOST_WIDE_INT.\n+\t* expmed.c (expand_shift): Likewise.\n+\t* rtlanal.c (strip_offset): New function.\n+\t(commutative_operand_precedence): Give CONST_POLY_INT the same\n+\tprecedence as CONST_DOUBLE and put CONST_WIDE_INT between that\n+\tand CONST_INT.\n+\t* rtl-tests.c (const_poly_int_tests): New struct.\n+\t(rtl_tests_c_tests): Use it.\n+\t* simplify-rtx.c (simplify_const_unary_operation): Handle\n+\tCONST_POLY_INT.\n+\t(simplify_const_binary_operation): Likewise.\n+\t(simplify_binary_operation_1): Fold additions of symbolic constants\n+\tand CONST_POLY_INTs.\n+\t(simplify_subreg): Handle extensions and truncations of\n+\tCONST_POLY_INTs.\n+\t(simplify_const_poly_int_tests): New struct.\n+\t(simplify_rtx_c_tests): Use it.\n+\t* wide-int.h (storage_ref): Add default constructor.\n+\t(wide_int_ref_storage): Likewise.\n+\t(trailing_wide_ints): Use GTY((user)).\n+\t(trailing_wide_ints::operator[]): Add a const version.\n+\t(trailing_wide_ints::get_precision): New function.\n+\t(trailing_wide_ints::extra_size): Likewise.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "a8da7d4703125aed3210b28616db24d46be23ae8", "filename": "gcc/cse.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -2323,6 +2323,15 @@ hash_rtx_cb (const_rtx x, machine_mode mode,\n \thash += CONST_WIDE_INT_ELT (x, i);\n       return hash;\n \n+    case CONST_POLY_INT:\n+      {\n+\tinchash::hash h;\n+\th.add_int (hash);\n+\tfor (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+\t  h.add_wide_int (CONST_POLY_INT_COEFFS (x)[i]);\n+\treturn h.end ();\n+      }\n+\n     case CONST_DOUBLE:\n       /* This is like the general case, except that it only counts\n \t the integers representing the constant.  */\n@@ -3781,6 +3790,8 @@ equiv_constant (rtx x)\n       /* See if we previously assigned a constant value to this SUBREG.  */\n       if ((new_rtx = lookup_as_function (x, CONST_INT)) != 0\n \t  || (new_rtx = lookup_as_function (x, CONST_WIDE_INT)) != 0\n+\t  || (NUM_POLY_INT_COEFFS > 1\n+\t      && (new_rtx = lookup_as_function (x, CONST_POLY_INT)) != 0)\n           || (new_rtx = lookup_as_function (x, CONST_DOUBLE)) != 0\n           || (new_rtx = lookup_as_function (x, CONST_FIXED)) != 0)\n         return new_rtx;"}, {"sha": "21a690cd36160b89814986d6cd9a7191db31cf72", "filename": "gcc/cselib.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -1128,6 +1128,15 @@ cselib_hash_rtx (rtx x, int create, machine_mode memmode)\n \thash += CONST_WIDE_INT_ELT (x, i);\n       return hash;\n \n+    case CONST_POLY_INT:\n+      {\n+\tinchash::hash h;\n+\th.add_int (hash);\n+\tfor (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+\t  h.add_wide_int (CONST_POLY_INT_COEFFS (x)[i]);\n+\treturn h.end ();\n+      }\n+\n     case CONST_DOUBLE:\n       /* This is like the general case, except that it only counts\n \t the integers representing the constant.  */"}, {"sha": "888bbc964d19079e4c54feee19b8c535bbf0109d", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -1633,6 +1633,15 @@ is accessed with the macro @code{CONST_FIXED_VALUE}.  The high part of\n data is accessed with @code{CONST_FIXED_VALUE_HIGH}; the low part is\n accessed with @code{CONST_FIXED_VALUE_LOW}.\n \n+@findex const_poly_int\n+@item (const_poly_int:@var{m} [@var{c0} @var{c1} @dots{}])\n+Represents a @code{poly_int}-style polynomial integer with coefficients\n+@var{c0}, @var{c1}, @dots{}.  The coefficients are @code{wide_int}-based\n+integers rather than rtxes.  @code{CONST_POLY_INT_COEFFS} gives the\n+values of individual coefficients (which is mostly only useful in\n+low-level routines) and @code{const_poly_int_value} gives the full\n+@code{poly_int} value.\n+\n @findex const_vector\n @item (const_vector:@var{m} [@var{x0} @var{x1} @dots{}])\n Represents a vector constant.  The square brackets stand for the vector\n@@ -4236,6 +4245,11 @@ referring to it.\n @item\n All @code{const_int} expressions with equal values are shared.\n \n+@cindex @code{const_poly_int}, RTL sharing\n+@item\n+All @code{const_poly_int} expressions with equal modes and values\n+are shared.\n+\n @cindex @code{pc}, RTL sharing\n @item\n There is only one @code{pc} expression."}, {"sha": "dc1a2f0fa1798976cb8202700847ae6f31a2c9d9", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -13781,6 +13781,16 @@ const_ok_for_output_1 (rtx rtl)\n       return false;\n     }\n \n+  if (CONST_POLY_INT_P (rtl))\n+    return false;\n+\n+  if (targetm.const_not_ok_for_debug_p (rtl))\n+    {\n+      expansion_failed (NULL_TREE, rtl,\n+\t\t\t\"Expression rejected for debug by the backend.\\n\");\n+      return false;\n+    }\n+\n   /* FIXME: Refer to PR60655. It is possible for simplification\n      of rtl expressions in var tracking to produce such expressions.\n      We should really identify / validate expressions"}, {"sha": "799b94a88d555a19e97f19a64bee289b5c401b47", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 96, "deletions": 6, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -148,6 +148,16 @@ struct const_wide_int_hasher : ggc_cache_ptr_hash<rtx_def>\n \n static GTY ((cache)) hash_table<const_wide_int_hasher> *const_wide_int_htab;\n \n+struct const_poly_int_hasher : ggc_cache_ptr_hash<rtx_def>\n+{\n+  typedef std::pair<machine_mode, poly_wide_int_ref> compare_type;\n+\n+  static hashval_t hash (rtx x);\n+  static bool equal (rtx x, const compare_type &y);\n+};\n+\n+static GTY ((cache)) hash_table<const_poly_int_hasher> *const_poly_int_htab;\n+\n /* A hash table storing register attribute structures.  */\n struct reg_attr_hasher : ggc_cache_ptr_hash<reg_attrs>\n {\n@@ -248,6 +258,31 @@ const_wide_int_hasher::equal (rtx x, rtx y)\n }\n #endif\n \n+/* Returns a hash code for CONST_POLY_INT X.  */\n+\n+hashval_t\n+const_poly_int_hasher::hash (rtx x)\n+{\n+  inchash::hash h;\n+  h.add_int (GET_MODE (x));\n+  for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+    h.add_wide_int (CONST_POLY_INT_COEFFS (x)[i]);\n+  return h.end ();\n+}\n+\n+/* Returns nonzero if CONST_POLY_INT X is an rtx representation of Y.  */\n+\n+bool\n+const_poly_int_hasher::equal (rtx x, const compare_type &y)\n+{\n+  if (GET_MODE (x) != y.first)\n+    return false;\n+  for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+    if (CONST_POLY_INT_COEFFS (x)[i] != y.second.coeffs[i])\n+      return false;\n+  return true;\n+}\n+\n /* Returns a hash code for X (which is really a CONST_DOUBLE).  */\n hashval_t\n const_double_hasher::hash (rtx x)\n@@ -489,9 +524,13 @@ gen_rtx_CONST_INT (machine_mode mode ATTRIBUTE_UNUSED, HOST_WIDE_INT arg)\n }\n \n rtx\n-gen_int_mode (HOST_WIDE_INT c, machine_mode mode)\n+gen_int_mode (poly_int64 c, machine_mode mode)\n {\n-  return GEN_INT (trunc_int_for_mode (c, mode));\n+  c = trunc_int_for_mode (c, mode);\n+  if (c.is_constant ())\n+    return GEN_INT (c.coeffs[0]);\n+  unsigned int prec = GET_MODE_PRECISION (as_a <scalar_mode> (mode));\n+  return immed_wide_int_const (poly_wide_int::from (c, prec, SIGNED), mode);\n }\n \n /* CONST_DOUBLEs might be created from pairs of integers, or from\n@@ -595,8 +634,8 @@ lookup_const_wide_int (rtx wint)\n    a CONST_DOUBLE (if !TARGET_SUPPORTS_WIDE_INT) or a CONST_WIDE_INT\n    (if TARGET_SUPPORTS_WIDE_INT).  */\n \n-rtx\n-immed_wide_int_const (const wide_int_ref &v, machine_mode mode)\n+static rtx\n+immed_wide_int_const_1 (const wide_int_ref &v, machine_mode mode)\n {\n   unsigned int len = v.get_len ();\n   /* Not scalar_int_mode because we also allow pointer bound modes.  */\n@@ -683,6 +722,53 @@ immed_double_const (HOST_WIDE_INT i0, HOST_WIDE_INT i1, machine_mode mode)\n }\n #endif\n \n+/* Return an rtx representation of C in mode MODE.  */\n+\n+rtx\n+immed_wide_int_const (const poly_wide_int_ref &c, machine_mode mode)\n+{\n+  if (c.is_constant ())\n+    return immed_wide_int_const_1 (c.coeffs[0], mode);\n+\n+  /* Not scalar_int_mode because we also allow pointer bound modes.  */\n+  unsigned int prec = GET_MODE_PRECISION (as_a <scalar_mode> (mode));\n+\n+  /* Allow truncation but not extension since we do not know if the\n+     number is signed or unsigned.  */\n+  gcc_assert (prec <= c.coeffs[0].get_precision ());\n+  poly_wide_int newc = poly_wide_int::from (c, prec, SIGNED);\n+\n+  /* See whether we already have an rtx for this constant.  */\n+  inchash::hash h;\n+  h.add_int (mode);\n+  for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+    h.add_wide_int (newc.coeffs[i]);\n+  const_poly_int_hasher::compare_type typed_value (mode, newc);\n+  rtx *slot = const_poly_int_htab->find_slot_with_hash (typed_value,\n+\t\t\t\t\t\t\th.end (), INSERT);\n+  rtx x = *slot;\n+  if (x)\n+    return x;\n+\n+  /* Create a new rtx.  There's a choice to be made here between installing\n+     the actual mode of the rtx or leaving it as VOIDmode (for consistency\n+     with CONST_INT).  In practice the handling of the codes is different\n+     enough that we get no benefit from using VOIDmode, and various places\n+     assume that VOIDmode implies CONST_INT.  Using the real mode seems like\n+     the right long-term direction anyway.  */\n+  typedef trailing_wide_ints<NUM_POLY_INT_COEFFS> twi;\n+  size_t extra_size = twi::extra_size (prec);\n+  x = rtx_alloc_v (CONST_POLY_INT,\n+\t\t   sizeof (struct const_poly_int_def) + extra_size);\n+  PUT_MODE (x, mode);\n+  CONST_POLY_INT_COEFFS (x).set_precision (prec);\n+  for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+    CONST_POLY_INT_COEFFS (x)[i] = newc.coeffs[i];\n+\n+  *slot = x;\n+  return x;\n+}\n+\n rtx\n gen_rtx_REG (machine_mode mode, unsigned int regno)\n {\n@@ -1486,7 +1572,8 @@ gen_lowpart_common (machine_mode mode, rtx x)\n     }\n   else if (GET_CODE (x) == SUBREG || REG_P (x)\n \t   || GET_CODE (x) == CONCAT || const_vec_p (x)\n-\t   || CONST_DOUBLE_AS_FLOAT_P (x) || CONST_SCALAR_INT_P (x))\n+\t   || CONST_DOUBLE_AS_FLOAT_P (x) || CONST_SCALAR_INT_P (x)\n+\t   || CONST_POLY_INT_P (x))\n     return lowpart_subreg (mode, x, innermode);\n \n   /* Otherwise, we can't do this.  */\n@@ -6031,6 +6118,9 @@ init_emit_once (void)\n #endif\n   const_double_htab = hash_table<const_double_hasher>::create_ggc (37);\n \n+  if (NUM_POLY_INT_COEFFS > 1)\n+    const_poly_int_htab = hash_table<const_poly_int_hasher>::create_ggc (37);\n+\n   const_fixed_htab = hash_table<const_fixed_hasher>::create_ggc (37);\n \n   reg_attrs_htab = hash_table<reg_attr_hasher>::create_ggc (37);\n@@ -6422,7 +6512,7 @@ need_atomic_barrier_p (enum memmodel model, bool pre)\n    by VALUE bits.  */\n \n rtx\n-gen_int_shift_amount (machine_mode, HOST_WIDE_INT value)\n+gen_int_shift_amount (machine_mode, poly_int64 value)\n {\n   /* Use a 64-bit mode, to avoid any truncation.\n "}, {"sha": "9deff00d6797d8f1d294e688b9c1accff101af7c", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -362,14 +362,14 @@ extern rtvec gen_rtvec (int, ...);\n extern rtx copy_insn_1 (rtx);\n extern rtx copy_insn (rtx);\n extern rtx_insn *copy_delay_slot_insn (rtx_insn *);\n-extern rtx gen_int_mode (HOST_WIDE_INT, machine_mode);\n+extern rtx gen_int_mode (poly_int64, machine_mode);\n extern rtx_insn *emit_copy_of_insn_after (rtx_insn *, rtx_insn *);\n extern void set_reg_attrs_from_value (rtx, rtx);\n extern void set_reg_attrs_for_parm (rtx, rtx);\n extern void set_reg_attrs_for_decl_rtl (tree t, rtx x);\n extern void adjust_reg_mode (rtx, machine_mode);\n extern int mem_expr_equal_p (const_tree, const_tree);\n-extern rtx gen_int_shift_amount (machine_mode, HOST_WIDE_INT);\n+extern rtx gen_int_shift_amount (machine_mode, poly_int64);\n \n extern bool need_atomic_barrier_p (enum memmodel, bool);\n "}, {"sha": "162959518f4fa293c51b0945c015a50b010f96b2", "filename": "gcc/explow.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -77,13 +77,23 @@ trunc_int_for_mode (HOST_WIDE_INT c, machine_mode mode)\n   return c;\n }\n \n+/* Likewise for polynomial values, using the sign-extended representation\n+   for each individual coefficient.  */\n+\n+poly_int64\n+trunc_int_for_mode (poly_int64 x, machine_mode mode)\n+{\n+  for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+    x.coeffs[i] = trunc_int_for_mode (x.coeffs[i], mode);\n+  return x;\n+}\n+\n /* Return an rtx for the sum of X and the integer C, given that X has\n    mode MODE.  INPLACE is true if X can be modified inplace or false\n    if it must be treated as immutable.  */\n \n rtx\n-plus_constant (machine_mode mode, rtx x, HOST_WIDE_INT c,\n-\t       bool inplace)\n+plus_constant (machine_mode mode, rtx x, poly_int64 c, bool inplace)\n {\n   RTX_CODE code;\n   rtx y;\n@@ -92,7 +102,7 @@ plus_constant (machine_mode mode, rtx x, HOST_WIDE_INT c,\n \n   gcc_assert (GET_MODE (x) == VOIDmode || GET_MODE (x) == mode);\n \n-  if (c == 0)\n+  if (known_eq (c, 0))\n     return x;\n \n  restart:\n@@ -180,10 +190,12 @@ plus_constant (machine_mode mode, rtx x, HOST_WIDE_INT c,\n       break;\n \n     default:\n+      if (CONST_POLY_INT_P (x))\n+\treturn immed_wide_int_const (const_poly_int_value (x) + c, mode);\n       break;\n     }\n \n-  if (c != 0)\n+  if (maybe_ne (c, 0))\n     x = gen_rtx_PLUS (mode, x, gen_int_mode (c, mode));\n \n   if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)"}, {"sha": "36aabc11c254fc029bf86182d1388a2d74f3d5b5", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -2541,7 +2541,7 @@ expand_shift_1 (enum tree_code code, machine_mode mode, rtx shifted,\n \n rtx\n expand_shift (enum tree_code code, machine_mode mode, rtx shifted,\n-\t      int amount, rtx target, int unsignedp)\n+\t      poly_int64 amount, rtx target, int unsignedp)\n {\n   return expand_shift_1 (code, mode, shifted,\n \t\t\t gen_int_shift_amount (mode, amount),"}, {"sha": "69be0766f5075930f78792e191bdc4a87562b52f", "filename": "gcc/expmed.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -712,8 +712,8 @@ extern unsigned HOST_WIDE_INT choose_multiplier (unsigned HOST_WIDE_INT, int,\n #ifdef TREE_CODE\n extern rtx expand_variable_shift (enum tree_code, machine_mode,\n \t\t\t\t  rtx, tree, rtx, int);\n-extern rtx expand_shift (enum tree_code, machine_mode, rtx, int, rtx,\n-\t\t\t     int);\n+extern rtx expand_shift (enum tree_code, machine_mode, rtx, poly_int64, rtx,\n+\t\t\t int);\n extern rtx expand_divmod (int, enum tree_code, machine_mode, rtx, rtx,\n \t\t\t  rtx, int);\n #endif"}, {"sha": "63e45cfc5017cfac798d5bab4aed0f55e105d74f", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -692,6 +692,7 @@ convert_modes (machine_mode mode, machine_mode oldmode, rtx x, int unsignedp)\n       && is_int_mode (oldmode, &int_oldmode)\n       && GET_MODE_PRECISION (int_mode) <= GET_MODE_PRECISION (int_oldmode)\n       && ((MEM_P (x) && !MEM_VOLATILE_P (x) && direct_load[(int) int_mode])\n+\t  || CONST_POLY_INT_P (x)\n           || (REG_P (x)\n               && (!HARD_REGISTER_P (x)\n \t\t  || targetm.hard_regno_mode_ok (REGNO (x), int_mode))"}, {"sha": "ee90c688c9c5deb704374b888298475572674709", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -156,6 +156,7 @@ excluded_rtx (int idx)\n   return (strcmp (defs[idx].enumname, \"VAR_LOCATION\") == 0\n \t  || strcmp (defs[idx].enumname, \"CONST_DOUBLE\") == 0\n \t  || strcmp (defs[idx].enumname, \"CONST_WIDE_INT\") == 0\n+\t  || strcmp (defs[idx].enumname, \"CONST_POLY_INT\") == 0\n \t  || strcmp (defs[idx].enumname, \"CONST_FIXED\") == 0);\n }\n "}, {"sha": "66dcf9233c4a7742361ae6da7e24ad25bd6dda31", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -908,6 +908,17 @@ rtx_writer::print_rtx (const_rtx in_rtx)\n       fprintf (m_outfile, \" \");\n       cwi_output_hex (m_outfile, in_rtx);\n       break;\n+\n+    case CONST_POLY_INT:\n+      fprintf (m_outfile, \" [\");\n+      print_dec (CONST_POLY_INT_COEFFS (in_rtx)[0], m_outfile, SIGNED);\n+      for (unsigned int i = 1; i < NUM_POLY_INT_COEFFS; ++i)\n+\t{\n+\t  fprintf (m_outfile, \", \");\n+\t  print_dec (CONST_POLY_INT_COEFFS (in_rtx)[i], m_outfile, SIGNED);\n+\t}\n+      fprintf (m_outfile, \"]\");\n+      break;\n #endif\n \n     case CODE_LABEL:\n@@ -1595,6 +1606,17 @@ print_value (pretty_printer *pp, const_rtx x, int verbose)\n       }\n       break;\n \n+    case CONST_POLY_INT:\n+      pp_left_bracket (pp);\n+      pp_wide_int (pp, CONST_POLY_INT_COEFFS (x)[0], SIGNED);\n+      for (unsigned int i = 1; i < NUM_POLY_INT_COEFFS; ++i)\n+\t{\n+\t  pp_string (pp, \", \");\n+\t  pp_wide_int (pp, CONST_POLY_INT_COEFFS (x)[i], SIGNED);\n+\t}\n+      pp_right_bracket (pp);\n+      break;\n+\n     case CONST_DOUBLE:\n       if (FLOAT_MODE_P (GET_MODE (x)))\n \t{"}, {"sha": "7283a237fd0d480fe7f802d57f40f36b249d1c7c", "filename": "gcc/rtl-tests.c", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Frtl-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Frtl-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-tests.c?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -228,6 +228,62 @@ test_uncond_jump ()\n \t\t      jump_insn);\n }\n \n+template<unsigned int N>\n+struct const_poly_int_tests\n+{\n+  static void run ();\n+};\n+\n+template<>\n+struct const_poly_int_tests<1>\n+{\n+  static void run () {}\n+};\n+\n+/* Test various CONST_POLY_INT properties.  */\n+\n+template<unsigned int N>\n+void\n+const_poly_int_tests<N>::run ()\n+{\n+  rtx x1 = gen_int_mode (poly_int64 (1, 1), QImode);\n+  rtx x255 = gen_int_mode (poly_int64 (1, 255), QImode);\n+\n+  /* Test that constants are unique.  */\n+  ASSERT_EQ (x1, gen_int_mode (poly_int64 (1, 1), QImode));\n+  ASSERT_NE (x1, gen_int_mode (poly_int64 (1, 1), HImode));\n+  ASSERT_NE (x1, x255);\n+\n+  /* Test const_poly_int_value.  */\n+  ASSERT_KNOWN_EQ (const_poly_int_value (x1), poly_int64 (1, 1));\n+  ASSERT_KNOWN_EQ (const_poly_int_value (x255), poly_int64 (1, -1));\n+\n+  /* Test rtx_to_poly_int64.  */\n+  ASSERT_KNOWN_EQ (rtx_to_poly_int64 (x1), poly_int64 (1, 1));\n+  ASSERT_KNOWN_EQ (rtx_to_poly_int64 (x255), poly_int64 (1, -1));\n+  ASSERT_MAYBE_NE (rtx_to_poly_int64 (x255), poly_int64 (1, 255));\n+\n+  /* Test plus_constant of a symbol.  */\n+  rtx symbol = gen_rtx_SYMBOL_REF (Pmode, \"foo\");\n+  rtx offset1 = gen_int_mode (poly_int64 (9, 11), Pmode);\n+  rtx sum1 = gen_rtx_CONST (Pmode, gen_rtx_PLUS (Pmode, symbol, offset1));\n+  ASSERT_RTX_EQ (plus_constant (Pmode, symbol, poly_int64 (9, 11)), sum1);\n+\n+  /* Test plus_constant of a CONST.  */\n+  rtx offset2 = gen_int_mode (poly_int64 (12, 20), Pmode);\n+  rtx sum2 = gen_rtx_CONST (Pmode, gen_rtx_PLUS (Pmode, symbol, offset2));\n+  ASSERT_RTX_EQ (plus_constant (Pmode, sum1, poly_int64 (3, 9)), sum2);\n+\n+  /* Test a cancelling plus_constant.  */\n+  ASSERT_EQ (plus_constant (Pmode, sum2, poly_int64 (-12, -20)), symbol);\n+\n+  /* Test plus_constant on integer constants.  */\n+  ASSERT_EQ (plus_constant (QImode, const1_rtx, poly_int64 (4, -2)),\n+\t     gen_int_mode (poly_int64 (5, -2), QImode));\n+  ASSERT_EQ (plus_constant (QImode, x1, poly_int64 (4, -2)),\n+\t     gen_int_mode (poly_int64 (5, -1), QImode));\n+}\n+\n /* Run all of the selftests within this file.  */\n \n void\n@@ -238,6 +294,7 @@ rtl_tests_c_tests ()\n   test_dumping_rtx_reuse ();\n   test_single_set ();\n   test_uncond_jump ();\n+  const_poly_int_tests<NUM_POLY_INT_COEFFS>::run ();\n \n   /* Purge state.  */\n   set_first_insn (NULL);"}, {"sha": "c51b4feb3d4e8e8a179e16cc672b5466eea52dfe", "filename": "gcc/rtl.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -189,6 +189,10 @@ rtx_size (const_rtx x)\n \t    + sizeof (struct hwivec_def)\n \t    + ((CONST_WIDE_INT_NUNITS (x) - 1)\n \t       * sizeof (HOST_WIDE_INT)));\n+  if (CONST_POLY_INT_P (x))\n+    return (RTX_HDR_SIZE\n+\t    + sizeof (struct const_poly_int_def)\n+\t    + CONST_POLY_INT_COEFFS (x).extra_size ());\n   if (GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_HAS_BLOCK_INFO_P (x))\n     return RTX_HDR_SIZE + sizeof (struct block_symbol);\n   return RTX_CODE_SIZE (GET_CODE (x));\n@@ -254,9 +258,10 @@ shared_const_p (const_rtx orig)\n \n   /* CONST can be shared if it contains a SYMBOL_REF.  If it contains\n      a LABEL_REF, it isn't sharable.  */\n+  poly_int64 offset;\n   return (GET_CODE (XEXP (orig, 0)) == PLUS\n \t  && GET_CODE (XEXP (XEXP (orig, 0), 0)) == SYMBOL_REF\n-\t  && CONST_INT_P (XEXP (XEXP (orig, 0), 1)));\n+\t  && poly_int_rtx_p (XEXP (XEXP (orig, 0), 1), &offset));\n }\n \n "}, {"sha": "01399440b7ce2eea6d9c812f0444a4359e3d6d02", "filename": "gcc/rtl.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -348,6 +348,9 @@ DEF_RTL_EXPR(CONST_INT, \"const_int\", \"w\", RTX_CONST_OBJ)\n /* numeric integer constant */\n DEF_RTL_EXPR(CONST_WIDE_INT, \"const_wide_int\", \"\", RTX_CONST_OBJ)\n \n+/* An rtx representation of a poly_wide_int.  */\n+DEF_RTL_EXPR(CONST_POLY_INT, \"const_poly_int\", \"\", RTX_CONST_OBJ)\n+\n /* fixed-point constant */\n DEF_RTL_EXPR(CONST_FIXED, \"const_fixed\", \"www\", RTX_CONST_OBJ)\n "}, {"sha": "7b2560d151b4180f52ca8caaced318cf0793c493", "filename": "gcc/rtl.h", "status": "modified", "additions": 115, "deletions": 4, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -280,6 +280,10 @@ struct GTY((variable_size)) hwivec_def {\n #define CWI_PUT_NUM_ELEM(RTX, NUM)\t\t\t\t\t\\\n   (RTL_FLAG_CHECK1(\"CWI_PUT_NUM_ELEM\", (RTX), CONST_WIDE_INT)->u2.num_elem = (NUM))\n \n+struct GTY((variable_size)) const_poly_int_def {\n+  trailing_wide_ints<NUM_POLY_INT_COEFFS> coeffs;\n+};\n+\n /* RTL expression (\"rtx\").  */\n \n /* The GTY \"desc\" and \"tag\" options below are a kludge: we need a desc\n@@ -424,6 +428,7 @@ struct GTY((desc(\"0\"), tag(\"0\"),\n     struct real_value rv;\n     struct fixed_value fv;\n     struct hwivec_def hwiv;\n+    struct const_poly_int_def cpi;\n   } GTY ((special (\"rtx_def\"), desc (\"GET_CODE (&%0)\"))) u;\n };\n \n@@ -734,13 +739,15 @@ struct GTY(()) rtvec_def {\n #define CASE_CONST_UNIQUE \\\n    case CONST_INT: \\\n    case CONST_WIDE_INT: \\\n+   case CONST_POLY_INT: \\\n    case CONST_DOUBLE: \\\n    case CONST_FIXED\n \n /* Match all CONST_* rtxes.  */\n #define CASE_CONST_ANY \\\n    case CONST_INT: \\\n    case CONST_WIDE_INT: \\\n+   case CONST_POLY_INT: \\\n    case CONST_DOUBLE: \\\n    case CONST_FIXED: \\\n    case CONST_VECTOR\n@@ -773,6 +780,11 @@ struct GTY(()) rtvec_def {\n /* Predicate yielding nonzero iff X is an rtx for a constant integer.  */\n #define CONST_WIDE_INT_P(X) (GET_CODE (X) == CONST_WIDE_INT)\n \n+/* Predicate yielding nonzero iff X is an rtx for a polynomial constant\n+   integer.  */\n+#define CONST_POLY_INT_P(X) \\\n+  (NUM_POLY_INT_COEFFS > 1 && GET_CODE (X) == CONST_POLY_INT)\n+\n /* Predicate yielding nonzero iff X is an rtx for a constant fixed-point.  */\n #define CONST_FIXED_P(X) (GET_CODE (X) == CONST_FIXED)\n \n@@ -1914,6 +1926,12 @@ set_regno_raw (rtx x, unsigned int regno, unsigned int nregs)\n #define CONST_WIDE_INT_NUNITS(RTX) CWI_GET_NUM_ELEM (RTX)\n #define CONST_WIDE_INT_ELT(RTX, N) CWI_ELT (RTX, N)\n \n+/* For a CONST_POLY_INT, CONST_POLY_INT_COEFFS gives access to the\n+   individual coefficients, in the form of a trailing_wide_ints structure.  */\n+#define CONST_POLY_INT_COEFFS(RTX) \\\n+  (RTL_FLAG_CHECK1(\"CONST_POLY_INT_COEFFS\", (RTX), \\\n+\t\t   CONST_POLY_INT)->u.cpi.coeffs)\n+\n /* For a CONST_DOUBLE:\n #if TARGET_SUPPORTS_WIDE_INT == 0\n    For a VOIDmode, there are two integers CONST_DOUBLE_LOW is the\n@@ -2227,6 +2245,84 @@ wi::max_value (machine_mode mode, signop sgn)\n   return max_value (GET_MODE_PRECISION (as_a <scalar_mode> (mode)), sgn);\n }\n \n+namespace wi\n+{\n+  typedef poly_int<NUM_POLY_INT_COEFFS,\n+\t\t   generic_wide_int <wide_int_ref_storage <false, false> > >\n+    rtx_to_poly_wide_ref;\n+  rtx_to_poly_wide_ref to_poly_wide (const_rtx, machine_mode);\n+}\n+\n+/* Return the value of a CONST_POLY_INT in its native precision.  */\n+\n+inline wi::rtx_to_poly_wide_ref\n+const_poly_int_value (const_rtx x)\n+{\n+  poly_int<NUM_POLY_INT_COEFFS, WIDE_INT_REF_FOR (wide_int)> res;\n+  for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+    res.coeffs[i] = CONST_POLY_INT_COEFFS (x)[i];\n+  return res;\n+}\n+\n+/* Return true if X is a scalar integer or a CONST_POLY_INT.  The value\n+   can then be extracted using wi::to_poly_wide.  */\n+\n+inline bool\n+poly_int_rtx_p (const_rtx x)\n+{\n+  return CONST_SCALAR_INT_P (x) || CONST_POLY_INT_P (x);\n+}\n+\n+/* Access X (which satisfies poly_int_rtx_p) as a poly_wide_int.\n+   MODE is the mode of X.  */\n+\n+inline wi::rtx_to_poly_wide_ref\n+wi::to_poly_wide (const_rtx x, machine_mode mode)\n+{\n+  if (CONST_POLY_INT_P (x))\n+    return const_poly_int_value (x);\n+  return rtx_mode_t (const_cast<rtx> (x), mode);\n+}\n+\n+/* Return the value of X as a poly_int64.  */\n+\n+inline poly_int64\n+rtx_to_poly_int64 (const_rtx x)\n+{\n+  if (CONST_POLY_INT_P (x))\n+    {\n+      poly_int64 res;\n+      for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+\tres.coeffs[i] = CONST_POLY_INT_COEFFS (x)[i].to_shwi ();\n+      return res;\n+    }\n+  return INTVAL (x);\n+}\n+\n+/* Return true if arbitrary value X is an integer constant that can\n+   be represented as a poly_int64.  Store the value in *RES if so,\n+   otherwise leave it unmodified.  */\n+\n+inline bool\n+poly_int_rtx_p (const_rtx x, poly_int64_pod *res)\n+{\n+  if (CONST_INT_P (x))\n+    {\n+      *res = INTVAL (x);\n+      return true;\n+    }\n+  if (CONST_POLY_INT_P (x))\n+    {\n+      for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+\tif (!wi::fits_shwi_p (CONST_POLY_INT_COEFFS (x)[i]))\n+\t  return false;\n+      for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+\tres->coeffs[i] = CONST_POLY_INT_COEFFS (x)[i].to_shwi ();\n+      return true;\n+    }\n+  return false;\n+}\n+\n extern void init_rtlanal (void);\n extern int rtx_cost (rtx, machine_mode, enum rtx_code, int, bool);\n extern int address_cost (rtx, machine_mode, addr_space_t, bool);\n@@ -2764,7 +2860,8 @@ get_full_set_src_cost (rtx x, machine_mode mode, struct full_rtx_costs *c)\n \n /* In explow.c */\n extern HOST_WIDE_INT trunc_int_for_mode\t(HOST_WIDE_INT, machine_mode);\n-extern rtx plus_constant (machine_mode, rtx, HOST_WIDE_INT, bool = false);\n+extern poly_int64 trunc_int_for_mode (poly_int64, machine_mode);\n+extern rtx plus_constant (machine_mode, rtx, poly_int64, bool = false);\n extern HOST_WIDE_INT get_stack_check_protect (void);\n \n /* In rtl.c */\n@@ -3058,13 +3155,11 @@ extern void end_sequence (void);\n extern double_int rtx_to_double_int (const_rtx);\n #endif\n extern void cwi_output_hex (FILE *, const_rtx);\n-#ifndef GENERATOR_FILE\n-extern rtx immed_wide_int_const (const wide_int_ref &, machine_mode);\n-#endif\n #if TARGET_SUPPORTS_WIDE_INT == 0\n extern rtx immed_double_const (HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t       machine_mode);\n #endif\n+extern rtx immed_wide_int_const (const poly_wide_int_ref &, machine_mode);\n \n /* In varasm.c  */\n extern rtx force_const_mem (machine_mode, rtx);\n@@ -3252,6 +3347,7 @@ extern HOST_WIDE_INT get_integer_term (const_rtx);\n extern rtx get_related_value (const_rtx);\n extern bool offset_within_block_p (const_rtx, HOST_WIDE_INT);\n extern void split_const (rtx, rtx *, rtx *);\n+extern rtx strip_offset (rtx, poly_int64_pod *);\n extern bool unsigned_reg_p (rtx);\n extern int reg_mentioned_p (const_rtx, const_rtx);\n extern int count_occurrences (const_rtx, const_rtx, int);\n@@ -4185,6 +4281,21 @@ load_extend_op (machine_mode mode)\n   return UNKNOWN;\n }\n \n+/* If X is a PLUS of a base and a constant offset, add the constant to *OFFSET\n+   and return the base.  Return X otherwise.  */\n+\n+inline rtx\n+strip_offset_and_add (rtx x, poly_int64_pod *offset)\n+{\n+  if (GET_CODE (x) == PLUS)\n+    {\n+      poly_int64 suboffset;\n+      x = strip_offset (x, &suboffset);\n+      *offset += suboffset;\n+    }\n+  return x;\n+}\n+\n /* gtype-desc.c.  */\n extern void gt_ggc_mx (rtx &);\n extern void gt_pch_nx (rtx &);"}, {"sha": "abb3afae64c23e188075bbf312d7f0658c4975a7", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -915,6 +915,28 @@ split_const (rtx x, rtx *base_out, rtx *offset_out)\n   *base_out = x;\n   *offset_out = const0_rtx;\n }\n+\n+/* Express integer value X as some value Y plus a polynomial offset,\n+   where Y is either const0_rtx, X or something within X (as opposed\n+   to a new rtx).  Return the Y and store the offset in *OFFSET_OUT.  */\n+\n+rtx\n+strip_offset (rtx x, poly_int64_pod *offset_out)\n+{\n+  rtx base = const0_rtx;\n+  rtx test = x;\n+  if (GET_CODE (test) == CONST)\n+    test = XEXP (test, 0);\n+  if (GET_CODE (test) == PLUS)\n+    {\n+      base = XEXP (test, 0);\n+      test = XEXP (test, 1);\n+    }\n+  if (poly_int_rtx_p (test, offset_out))\n+    return base;\n+  *offset_out = 0;\n+  return x;\n+}\n \f\n /* Return the number of places FIND appears within X.  If COUNT_DEST is\n    zero, we do not count occurrences inside the destination of a SET.  */\n@@ -3406,27 +3428,31 @@ commutative_operand_precedence (rtx op)\n \n   /* Constants always become the second operand.  Prefer \"nice\" constants.  */\n   if (code == CONST_INT)\n-    return -8;\n+    return -10;\n   if (code == CONST_WIDE_INT)\n-    return -7;\n+    return -9;\n+  if (code == CONST_POLY_INT)\n+    return -8;\n   if (code == CONST_DOUBLE)\n-    return -7;\n+    return -8;\n   if (code == CONST_FIXED)\n-    return -7;\n+    return -8;\n   op = avoid_constant_pool_reference (op);\n   code = GET_CODE (op);\n \n   switch (GET_RTX_CLASS (code))\n     {\n     case RTX_CONST_OBJ:\n       if (code == CONST_INT)\n-        return -6;\n+\treturn -7;\n       if (code == CONST_WIDE_INT)\n-        return -6;\n+\treturn -6;\n+      if (code == CONST_POLY_INT)\n+\treturn -5;\n       if (code == CONST_DOUBLE)\n-        return -5;\n+\treturn -5;\n       if (code == CONST_FIXED)\n-        return -5;\n+\treturn -5;\n       return -4;\n \n     case RTX_EXTRA:"}, {"sha": "9a3df4c62ee8af19257b16e3ceb5cdb2feb60596", "filename": "gcc/rtlhash.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Frtlhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Frtlhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlhash.c?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -55,6 +55,10 @@ add_rtx (const_rtx x, hash &hstate)\n       for (i = 0; i < CONST_WIDE_INT_NUNITS (x); i++)\n \thstate.add_object (CONST_WIDE_INT_ELT (x, i));\n       return;\n+    case CONST_POLY_INT:\n+      for (i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+\thstate.add_wide_int (CONST_POLY_INT_COEFFS (x)[i]);\n+      break;\n     case SYMBOL_REF:\n       if (XSTR (x, 0))\n \thstate.add (XSTR (x, 0), strlen (XSTR (x, 0)) + 1);"}, {"sha": "58cf2c569182455db460640edd6861cf6fd1ba88", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 145, "deletions": 5, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -2038,6 +2038,26 @@ simplify_const_unary_operation (enum rtx_code code, machine_mode mode,\n \t}\n     }\n \n+  /* Handle polynomial integers.  */\n+  else if (CONST_POLY_INT_P (op))\n+    {\n+      poly_wide_int result;\n+      switch (code)\n+\t{\n+\tcase NEG:\n+\t  result = -const_poly_int_value (op);\n+\t  break;\n+\n+\tcase NOT:\n+\t  result = ~const_poly_int_value (op);\n+\t  break;\n+\n+\tdefault:\n+\t  return NULL_RTX;\n+\t}\n+      return immed_wide_int_const (result, mode);\n+    }\n+\n   return NULL_RTX;\n }\n \f\n@@ -2218,6 +2238,7 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n   rtx tem, reversed, opleft, opright, elt0, elt1;\n   HOST_WIDE_INT val;\n   scalar_int_mode int_mode, inner_mode;\n+  poly_int64 offset;\n \n   /* Even if we can't compute a constant result,\n      there are some cases worth simplifying.  */\n@@ -2530,6 +2551,12 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t    return simplify_gen_binary (MINUS, mode, tem, XEXP (op0, 0));\n \t}\n \n+      if ((GET_CODE (op0) == CONST\n+\t   || GET_CODE (op0) == SYMBOL_REF\n+\t   || GET_CODE (op0) == LABEL_REF)\n+\t  && poly_int_rtx_p (op1, &offset))\n+\treturn plus_constant (mode, op0, trunc_int_for_mode (-offset, mode));\n+\n       /* Don't let a relocatable value get a negative coeff.  */\n       if (CONST_INT_P (op1) && GET_MODE (op0) != VOIDmode)\n \treturn simplify_gen_binary (PLUS, mode,\n@@ -4327,6 +4354,57 @@ simplify_const_binary_operation (enum rtx_code code, machine_mode mode,\n       return immed_wide_int_const (result, int_mode);\n     }\n \n+  /* Handle polynomial integers.  */\n+  if (NUM_POLY_INT_COEFFS > 1\n+      && is_a <scalar_int_mode> (mode, &int_mode)\n+      && poly_int_rtx_p (op0)\n+      && poly_int_rtx_p (op1))\n+    {\n+      poly_wide_int result;\n+      switch (code)\n+\t{\n+\tcase PLUS:\n+\t  result = wi::to_poly_wide (op0, mode) + wi::to_poly_wide (op1, mode);\n+\t  break;\n+\n+\tcase MINUS:\n+\t  result = wi::to_poly_wide (op0, mode) - wi::to_poly_wide (op1, mode);\n+\t  break;\n+\n+\tcase MULT:\n+\t  if (CONST_SCALAR_INT_P (op1))\n+\t    result = wi::to_poly_wide (op0, mode) * rtx_mode_t (op1, mode);\n+\t  else\n+\t    return NULL_RTX;\n+\t  break;\n+\n+\tcase ASHIFT:\n+\t  if (CONST_SCALAR_INT_P (op1))\n+\t    {\n+\t      wide_int shift = rtx_mode_t (op1, mode);\n+\t      if (SHIFT_COUNT_TRUNCATED)\n+\t\tshift = wi::umod_trunc (shift, GET_MODE_PRECISION (int_mode));\n+\t      else if (wi::geu_p (shift, GET_MODE_PRECISION (int_mode)))\n+\t\treturn NULL_RTX;\n+\t      result = wi::to_poly_wide (op0, mode) << shift;\n+\t    }\n+\t  else\n+\t    return NULL_RTX;\n+\t  break;\n+\n+\tcase IOR:\n+\t  if (!CONST_SCALAR_INT_P (op1)\n+\t      || !can_ior_p (wi::to_poly_wide (op0, mode),\n+\t\t\t     rtx_mode_t (op1, mode), &result))\n+\t    return NULL_RTX;\n+\t  break;\n+\n+\tdefault:\n+\t  return NULL_RTX;\n+\t}\n+      return immed_wide_int_const (result, int_mode);\n+    }\n+\n   return NULL_RTX;\n }\n \n@@ -6370,13 +6448,27 @@ simplify_subreg (machine_mode outermode, rtx op,\n   scalar_int_mode int_outermode, int_innermode;\n   if (is_a <scalar_int_mode> (outermode, &int_outermode)\n       && is_a <scalar_int_mode> (innermode, &int_innermode)\n-      && (GET_MODE_PRECISION (int_outermode)\n-\t  < GET_MODE_PRECISION (int_innermode))\n       && byte == subreg_lowpart_offset (int_outermode, int_innermode))\n     {\n-      rtx tem = simplify_truncation (int_outermode, op, int_innermode);\n-      if (tem)\n-\treturn tem;\n+      /* Handle polynomial integers.  The upper bits of a paradoxical\n+\t subreg are undefined, so this is safe regardless of whether\n+\t we're truncating or extending.  */\n+      if (CONST_POLY_INT_P (op))\n+\t{\n+\t  poly_wide_int val\n+\t    = poly_wide_int::from (const_poly_int_value (op),\n+\t\t\t\t   GET_MODE_PRECISION (int_outermode),\n+\t\t\t\t   SIGNED);\n+\t  return immed_wide_int_const (val, int_outermode);\n+\t}\n+\n+      if (GET_MODE_PRECISION (int_outermode)\n+\t  < GET_MODE_PRECISION (int_innermode))\n+\t{\n+\t  rtx tem = simplify_truncation (int_outermode, op, int_innermode);\n+\t  if (tem)\n+\t    return tem;\n+\t}\n     }\n \n   return NULL_RTX;\n@@ -6685,12 +6777,60 @@ test_vector_ops ()\n     }\n }\n \n+template<unsigned int N>\n+struct simplify_const_poly_int_tests\n+{\n+  static void run ();\n+};\n+\n+template<>\n+struct simplify_const_poly_int_tests<1>\n+{\n+  static void run () {}\n+};\n+\n+/* Test various CONST_POLY_INT properties.  */\n+\n+template<unsigned int N>\n+void\n+simplify_const_poly_int_tests<N>::run ()\n+{\n+  rtx x1 = gen_int_mode (poly_int64 (1, 1), QImode);\n+  rtx x2 = gen_int_mode (poly_int64 (-80, 127), QImode);\n+  rtx x3 = gen_int_mode (poly_int64 (-79, -128), QImode);\n+  rtx x4 = gen_int_mode (poly_int64 (5, 4), QImode);\n+  rtx x5 = gen_int_mode (poly_int64 (30, 24), QImode);\n+  rtx x6 = gen_int_mode (poly_int64 (20, 16), QImode);\n+  rtx x7 = gen_int_mode (poly_int64 (7, 4), QImode);\n+  rtx x8 = gen_int_mode (poly_int64 (30, 24), HImode);\n+  rtx x9 = gen_int_mode (poly_int64 (-30, -24), HImode);\n+  rtx x10 = gen_int_mode (poly_int64 (-31, -24), HImode);\n+  rtx two = GEN_INT (2);\n+  rtx six = GEN_INT (6);\n+  HOST_WIDE_INT offset = subreg_lowpart_offset (QImode, HImode);\n+\n+  /* These tests only try limited operation combinations.  Fuller arithmetic\n+     testing is done directly on poly_ints.  */\n+  ASSERT_EQ (simplify_unary_operation (NEG, HImode, x8, HImode), x9);\n+  ASSERT_EQ (simplify_unary_operation (NOT, HImode, x8, HImode), x10);\n+  ASSERT_EQ (simplify_unary_operation (TRUNCATE, QImode, x8, HImode), x5);\n+  ASSERT_EQ (simplify_binary_operation (PLUS, QImode, x1, x2), x3);\n+  ASSERT_EQ (simplify_binary_operation (MINUS, QImode, x3, x1), x2);\n+  ASSERT_EQ (simplify_binary_operation (MULT, QImode, x4, six), x5);\n+  ASSERT_EQ (simplify_binary_operation (MULT, QImode, six, x4), x5);\n+  ASSERT_EQ (simplify_binary_operation (ASHIFT, QImode, x4, two), x6);\n+  ASSERT_EQ (simplify_binary_operation (IOR, QImode, x4, two), x7);\n+  ASSERT_EQ (simplify_subreg (HImode, x5, QImode, 0), x8);\n+  ASSERT_EQ (simplify_subreg (QImode, x8, HImode, offset), x5);\n+}\n+\n /* Run all of the selftests within this file.  */\n \n void\n simplify_rtx_c_tests ()\n {\n   test_vector_ops ();\n+  simplify_const_poly_int_tests<NUM_POLY_INT_COEFFS>::run ();\n }\n \n } // namespace selftest"}, {"sha": "30173a4920749b19ec31edc94fc4a10cde57a9f6", "filename": "gcc/wide-int.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c12fc9b2d605cf323cfdab28a972d86398e71a1/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=0c12fc9b2d605cf323cfdab28a972d86398e71a1", "patch": "@@ -613,6 +613,7 @@ namespace wi\n      access.  */\n   struct storage_ref\n   {\n+    storage_ref () {}\n     storage_ref (const HOST_WIDE_INT *, unsigned int, unsigned int);\n \n     const HOST_WIDE_INT *val;\n@@ -944,6 +945,8 @@ struct wide_int_ref_storage : public wi::storage_ref\n   HOST_WIDE_INT scratch[2];\n \n public:\n+  wide_int_ref_storage () {}\n+\n   wide_int_ref_storage (const wi::storage_ref &);\n \n   template <typename T>\n@@ -1323,7 +1326,7 @@ namespace wi\n    bytes beyond the sizeof need to be allocated.  Use set_precision\n    to initialize the structure.  */\n template <int N>\n-class GTY(()) trailing_wide_ints\n+class GTY((user)) trailing_wide_ints\n {\n private:\n   /* The shared precision of each number.  */\n@@ -1340,9 +1343,14 @@ class GTY(()) trailing_wide_ints\n   HOST_WIDE_INT m_val[1];\n \n public:\n+  typedef WIDE_INT_REF_FOR (trailing_wide_int_storage) const_reference;\n+\n   void set_precision (unsigned int);\n+  unsigned int get_precision () const { return m_precision; }\n   trailing_wide_int operator [] (unsigned int);\n+  const_reference operator [] (unsigned int) const;\n   static size_t extra_size (unsigned int);\n+  size_t extra_size () const { return extra_size (m_precision); }\n };\n \n inline trailing_wide_int_storage::\n@@ -1414,6 +1422,14 @@ trailing_wide_ints <N>::operator [] (unsigned int index)\n \t\t\t\t    &m_val[index * m_max_len]);\n }\n \n+template <int N>\n+inline typename trailing_wide_ints <N>::const_reference\n+trailing_wide_ints <N>::operator [] (unsigned int index) const\n+{\n+  return wi::storage_ref (&m_val[index * m_max_len],\n+\t\t\t  m_len[index], m_precision);\n+}\n+\n /* Return how many extra bytes need to be added to the end of the structure\n    in order to handle N wide_ints of precision PRECISION.  */\n template <int N>"}]}