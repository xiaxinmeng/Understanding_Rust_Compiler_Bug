{"sha": "d265b0b1c24d13c3dfdf830877fa8edf87e8c15d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI2NWIwYjFjMjRkMTNjM2RmZGY4MzA4NzdmYThlZGY4N2U4YzE1ZA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2007-03-13T20:02:59Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2007-03-13T20:02:59Z"}, "message": "tuple: Only include <utility> for std::pair, and forward declare reference_wrapper...\n\n2007-03-13  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/tr1/tuple: Only include <utility> for std::pair, and\n\tforward declare reference_wrapper; formatting fixes.\n\t* include/tr1/ref_fwd.h: Remove.\n\t* include/tr1/tuple_defs.h: Remove, unused.\n\t* include/Makefile.am: Update.\n\t* include/Makefile.in: Regenerate.\n\t* testsuite/tr1/6_containers/tuple/creation_functions/make_tuple.cc:\n\tInclude <tr1/functional> too.\n\n\t* include/tr1/tuple: Define tuple_size<tuple<_Elements...> >::value.\n\nFrom-SVN: r122883", "tree": {"sha": "3419d91399a805a52a999e12389c2457f4dbb40e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3419d91399a805a52a999e12389c2457f4dbb40e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d265b0b1c24d13c3dfdf830877fa8edf87e8c15d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d265b0b1c24d13c3dfdf830877fa8edf87e8c15d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d265b0b1c24d13c3dfdf830877fa8edf87e8c15d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d265b0b1c24d13c3dfdf830877fa8edf87e8c15d/comments", "author": null, "committer": null, "parents": [{"sha": "bde6c7a990efcfadfd832983367a8e783647aa1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bde6c7a990efcfadfd832983367a8e783647aa1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bde6c7a990efcfadfd832983367a8e783647aa1d"}], "stats": {"total": 875, "additions": 366, "deletions": 509}, "files": [{"sha": "68055f62c4a25bc912de80f510406cf2232266d3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d265b0b1c24d13c3dfdf830877fa8edf87e8c15d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d265b0b1c24d13c3dfdf830877fa8edf87e8c15d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d265b0b1c24d13c3dfdf830877fa8edf87e8c15d", "patch": "@@ -1,3 +1,16 @@\n+2007-03-13  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/tr1/tuple: Only include <utility> for std::pair, and\n+\tforward declare reference_wrapper; formatting fixes.\n+\t* include/tr1/ref_fwd.h: Remove.\n+\t* include/tr1/tuple_defs.h: Remove, unused.\n+\t* include/Makefile.am: Update.\n+\t* include/Makefile.in: Regenerate.\n+\t* testsuite/tr1/6_containers/tuple/creation_functions/make_tuple.cc:\n+\tInclude <tr1/functional> too.\n+\n+\t* include/tr1/tuple: Define tuple_size<tuple<_Elements...> >::value.\n+\n 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n \n \t* include/tr1/regex: Add \"boilerplate\" implementations."}, {"sha": "9cc39c16eba61d0f18d38dc86254b8af8f363820", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d265b0b1c24d13c3dfdf830877fa8edf87e8c15d/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d265b0b1c24d13c3dfdf830877fa8edf87e8c15d/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=d265b0b1c24d13c3dfdf830877fa8edf87e8c15d", "patch": "@@ -566,7 +566,6 @@ tr1_headers = \\\n \t${tr1_srcdir}/memory \\\n \t${tr1_srcdir}/random \\\n \t${tr1_srcdir}/random.tcc \\\n-\t${tr1_srcdir}/ref_fwd.h \\\n \t${tr1_srcdir}/regex \\\n \t${tr1_srcdir}/stdarg.h \\\n \t${tr1_srcdir}/stdbool.h \\"}, {"sha": "2f8417a0362a34d896392f26abd1419a362a22f7", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d265b0b1c24d13c3dfdf830877fa8edf87e8c15d/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d265b0b1c24d13c3dfdf830877fa8edf87e8c15d/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=d265b0b1c24d13c3dfdf830877fa8edf87e8c15d", "patch": "@@ -796,7 +796,6 @@ tr1_headers = \\\n \t${tr1_srcdir}/memory \\\n \t${tr1_srcdir}/random \\\n \t${tr1_srcdir}/random.tcc \\\n-\t${tr1_srcdir}/ref_fwd.h \\\n \t${tr1_srcdir}/regex \\\n \t${tr1_srcdir}/stdarg.h \\\n \t${tr1_srcdir}/stdbool.h \\"}, {"sha": "96e2b27cd6c6119a2ab6259326fcd0859b636c7e", "filename": "libstdc++-v3/include/tr1/ref_fwd.h", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde6c7a990efcfadfd832983367a8e783647aa1d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fref_fwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde6c7a990efcfadfd832983367a8e783647aa1d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fref_fwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fref_fwd.h?ref=bde6c7a990efcfadfd832983367a8e783647aa1d", "patch": "@@ -1,59 +0,0 @@\n-\n-\n-// class template reference_wrapper forwarding header -*- C++ -*-\n-\n-// Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file tr1/ref_fwd.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-// Douglas Gregor <doug.gregor -at- gmail.com>\n-#ifndef _TR1_REF_FWD\n-#define _TR1_REF_FWD\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-template<typename _Tp>\n-  class reference_wrapper;\n-\n-template<typename _Tp>\n-  reference_wrapper<_Tp>\n-  ref(_Tp& __t);\n-\n-  // Denotes a const reference should be taken to a variable.\n-template<typename _Tp>\n-  reference_wrapper<const _Tp>\n-  cref(const _Tp& __t);\n-\n-_GLIBCXX_END_NAMESPACE\n-}\n-#endif"}, {"sha": "4e1a2d42f58187ea8c618578ecc09fea14b69a5f", "filename": "libstdc++-v3/include/tr1/tuple", "status": "modified", "additions": 351, "deletions": 333, "changes": 684, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d265b0b1c24d13c3dfdf830877fa8edf87e8c15d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d265b0b1c24d13c3dfdf830877fa8edf87e8c15d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple?ref=d265b0b1c24d13c3dfdf830877fa8edf87e8c15d", "patch": "@@ -1,6 +1,6 @@\n // class template tuple -*- C++ -*-\n \n-// Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -39,329 +39,348 @@\n \n #pragma GCC system_header\n \n-#include <tr1/utility>\n-#include <tr1/ref_fwd.h>\n-#include <bits/cpp_type_traits.h> // for __enable_if\n+#include <utility>\n \n namespace std\n {\n _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n- // Adds a const reference to a non-reference type.\n- template<typename _Tp>\n-   struct __add_c_ref\n-   { typedef const _Tp& type; };\n-\n- template<typename _Tp>\n-   struct __add_c_ref<_Tp&>\n-   { typedef _Tp& type; };\n-\n- // Adds a reference to a non-reference type.\n- template<typename _Tp>\n-   struct __add_ref\n-   { typedef _Tp& type; };\n-\n- template<typename _Tp>\n-   struct __add_ref<_Tp&>\n-   { typedef _Tp& type; };\n-\n-/**\n- * @if maint\n- * Contains the actual implementation of the @c tuple template, stored\n- * as a recursive inheritance hierarchy from the first element (most\n- * derived class) to the last (least derived class). The @c Idx\n- * parameter gives the 0-based index of the element stored at this\n- * point in the hierarchy; we use it to implement a constant-time\n- * get() operation.\n- * @endif\n- */\n- template<int _Idx, typename... _Elements>\n-   struct _Tuple_impl; \n-\n- /**\n-  * @if maint\n-  * Zero-element tuple implementation. This is the basis case for the \n-  * inheritance recursion.\n-  * @endif maint\n-  */\n- template<int _Idx>\n-   struct _Tuple_impl<_Idx> { };\n-\n- /**\n-  * @if maint\n-  * Recursive tuple implementation. Here we store the @c Head element\n-  * and derive from a @c Tuple_impl containing the remaining elements\n-  * (which contains the @c Tail).\n-  * @endif\n-  */\n- template<int _Idx, typename _Head, typename... _Tail>\n-   struct _Tuple_impl<_Idx, _Head, _Tail...>\n-     : public _Tuple_impl<_Idx+1, _Tail...>\n-   {\n-     typedef _Tuple_impl<_Idx+1, _Tail...> _Inherited;\n-\n-     _Head _M_head;\n-\n-     _Inherited&       _M_tail()       { return *this; }\n-     const _Inherited& _M_tail() const { return *this; }\n-\n-     _Tuple_impl() : _Inherited(), _M_head() { }\n-\n-     explicit \n-     _Tuple_impl(typename __add_c_ref<_Head>::type __head,\n-                 typename __add_c_ref<_Tail>::type... __tail)\n-       : _Inherited(__tail...), _M_head(__head) { }\n-\n-     template<typename... _UElements>\n-       _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)\n-         : _Inherited(__in._M_tail()), _M_head(__in._M_head) { }\n-\n-     _Tuple_impl(const _Tuple_impl& __in)\n-       : _Inherited(__in._M_tail()), _M_head(__in._M_head) { }\n+  template<typename _Tp>\n+    class reference_wrapper;\n+\n+  // Adds a const reference to a non-reference type.\n+  template<typename _Tp>\n+    struct __add_c_ref\n+    { typedef const _Tp& type; };\n+\n+  template<typename _Tp>\n+    struct __add_c_ref<_Tp&>\n+    { typedef _Tp& type; };\n+\n+  // Adds a reference to a non-reference type.\n+  template<typename _Tp>\n+    struct __add_ref\n+    { typedef _Tp& type; };\n+\n+  template<typename _Tp>\n+    struct __add_ref<_Tp&>\n+    { typedef _Tp& type; };\n+\n+  /**\n+   * @if maint\n+   * Contains the actual implementation of the @c tuple template, stored\n+   * as a recursive inheritance hierarchy from the first element (most\n+   * derived class) to the last (least derived class). The @c Idx\n+   * parameter gives the 0-based index of the element stored at this\n+   * point in the hierarchy; we use it to implement a constant-time\n+   * get() operation.\n+   * @endif\n+   */\n+  template<int _Idx, typename... _Elements>\n+    struct _Tuple_impl; \n+\n+  /**\n+   * @if maint\n+   * Zero-element tuple implementation. This is the basis case for the \n+   * inheritance recursion.\n+   * @endif maint\n+   */\n+  template<int _Idx>\n+    struct _Tuple_impl<_Idx> { };\n+\n+  /**\n+   * @if maint\n+   * Recursive tuple implementation. Here we store the @c Head element\n+   * and derive from a @c Tuple_impl containing the remaining elements\n+   * (which contains the @c Tail).\n+   * @endif\n+   */\n+  template<int _Idx, typename _Head, typename... _Tail>\n+    struct _Tuple_impl<_Idx, _Head, _Tail...>\n+    : public _Tuple_impl<_Idx + 1, _Tail...>\n+    {\n+      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;\n+      \n+      _Head _M_head;\n+      \n+      _Inherited&       _M_tail()       { return *this; }\n+      const _Inherited& _M_tail() const { return *this; }\n+      \n+      _Tuple_impl() : _Inherited(), _M_head() { }\n+      \n+      explicit \n+      _Tuple_impl(typename __add_c_ref<_Head>::type __head,\n+\t\t  typename __add_c_ref<_Tail>::type... __tail)\n+      : _Inherited(__tail...), _M_head(__head) { }\n+\n+      template<typename... _UElements>\n+      _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)\n+      : _Inherited(__in._M_tail()), _M_head(__in._M_head) { }\n+\n+      _Tuple_impl(const _Tuple_impl& __in)\n+      : _Inherited(__in._M_tail()), _M_head(__in._M_head) { }\n      \n-     template<typename... _UElements>\n-     _Tuple_impl& operator=(const _Tuple_impl<_Idx, _UElements...>& __in)\n-     {\n-       _M_head = __in._M_head;\n-       _M_tail() = __in._M_tail();\n-       return *this;\n-     }\n-\n-     _Tuple_impl& operator=(const _Tuple_impl& __in)\n-     {\n-       _M_head = __in._M_head;\n-       _M_tail() = __in._M_tail();\n-       return *this;\n-     }\n-   };\n-\n- template<typename... _Elements> \n-   class tuple : public _Tuple_impl<0, _Elements...>\n-   {\n-     typedef _Tuple_impl<0, _Elements...> _Inherited;\n-\n-   public:\n-     tuple() : _Inherited() { }\n-\n-     explicit\n-     tuple(typename __add_c_ref<_Elements>::type... __elements)\n-       : _Inherited(__elements...) { }\n-\n-     template<typename... _UElements>\n-       tuple(const tuple<_UElements...>& __in)\n-         : _Inherited(__in) { }\n-\n-     tuple(const tuple& __in)\n-         : _Inherited(__in) { }\n-\n-     template<typename... _UElements>\n-       tuple& operator=(const tuple<_UElements...>& __in)\n-       {\n-         static_cast<_Inherited&>(*this) = __in;\n-         return *this;\n-       }\n-\n-     tuple& operator=(const tuple& __in)\n-     {\n-       static_cast<_Inherited&>(*this) = __in;\n-       return *this;\n-     }\n-   };\n-\n- template<> class tuple<> { };\n-\n- // 2-element tuple, with construction and assignment from a pair.\n- template<typename _T1, typename _T2>\n-   class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>\n-   {\n-     typedef _Tuple_impl<0, _T1, _T2> _Inherited;\n-\n-   public:\n-     tuple() : _Inherited() { }\n-\n-     explicit\n-     tuple(typename __add_c_ref<_T1>::type __a1,\n-           typename __add_c_ref<_T2>::type __a2)\n-       : _Inherited(__a1, __a2) { }\n-\n-     template<typename _U1, typename _U2>\n-       tuple(const tuple<_U1, _U2>& __in)\n-         : _Inherited(__in) { }\n-\n-     tuple(const tuple& __in)\n-         : _Inherited(__in) { }\n-\n-     template<typename _U1, typename _U2>\n-       tuple(const pair<_U1, _U2>& __in)\n-         : _Inherited(\n-             _Tuple_impl<0, \n-                         typename __add_c_ref<_U1>::type,\n-                         typename __add_c_ref<_U2>::type>(__in.first, \n-                                                          __in.second))\n-       { \n-       }\n+      template<typename... _UElements>\n+        _Tuple_impl&\n+        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)\n+        {\n+\t  _M_head = __in._M_head;\n+\t  _M_tail() = __in._M_tail();\n+\t  return *this;\n+\t}\n+\n+      _Tuple_impl&\n+      operator=(const _Tuple_impl& __in)\n+      {\n+\t_M_head = __in._M_head;\n+\t_M_tail() = __in._M_tail();\n+\treturn *this;\n+      }\n+    };\n+\n+  template<typename... _Elements> \n+    class tuple : public _Tuple_impl<0, _Elements...>\n+    {\n+      typedef _Tuple_impl<0, _Elements...> _Inherited;\n+\n+    public:\n+      tuple() : _Inherited() { }\n+\n+      explicit\n+      tuple(typename __add_c_ref<_Elements>::type... __elements)\n+      : _Inherited(__elements...) { }\n+\n+      template<typename... _UElements>\n+        tuple(const tuple<_UElements...>& __in)\n+\t: _Inherited(__in) { }\n+\n+      tuple(const tuple& __in)\n+      : _Inherited(__in) { }\n+\n+      template<typename... _UElements>\n+        tuple&\n+        operator=(const tuple<_UElements...>& __in)\n+        {\n+\t  static_cast<_Inherited&>(*this) = __in;\n+\t  return *this;\n+\t}\n+\n+      tuple&\n+      operator=(const tuple& __in)\n+      {\n+\tstatic_cast<_Inherited&>(*this) = __in;\n+\treturn *this;\n+      }\n+    };\n+\n+  template<> class tuple<> { };\n+\n+  // 2-element tuple, with construction and assignment from a pair.\n+  template<typename _T1, typename _T2>\n+    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>\n+    {\n+      typedef _Tuple_impl<0, _T1, _T2> _Inherited;\n+\n+    public:\n+      tuple() : _Inherited() { }\n+\n+      explicit\n+      tuple(typename __add_c_ref<_T1>::type __a1,\n+\t    typename __add_c_ref<_T2>::type __a2)\n+      : _Inherited(__a1, __a2) { }\n+\n+      template<typename _U1, typename _U2>\n+        tuple(const tuple<_U1, _U2>& __in)\n+\t: _Inherited(__in) { }\n+\n+      tuple(const tuple& __in)\n+      : _Inherited(__in) { }\n+\n+      template<typename _U1, typename _U2>\n+        tuple(const pair<_U1, _U2>& __in)\n+\t: _Inherited(_Tuple_impl<0, \n+\t\t     typename __add_c_ref<_U1>::type,\n+\t\t     typename __add_c_ref<_U2>::type>(__in.first, \n+\t\t\t\t\t\t      __in.second))\n+        { }\n   \n-     template<typename _U1, typename _U2>\n-       tuple& operator=(const tuple<_U1, _U2>& __in)\n-       {\n-         static_cast<_Inherited&>(*this) = __in;\n-         return *this;\n-       }\n-\n-     tuple& operator=(const tuple& __in)\n-     {\n-       static_cast<_Inherited&>(*this) = __in;\n-       return *this;\n-     }\n-\n-     template<typename _U1, typename _U2>\n-       tuple& operator=(const pair<_U1, _U2>& __in)\n-     {\n-       this->_M_head = __in.first;\n-       this->_M_tail()._M_head = __in.second;\n-       return *this;\n-     }\n-   };\n-\n-\n- /// Gives the type of the ith element of a given tuple type.\n- template<int __i, typename _Tp>\n-   struct tuple_element;\n-\n- /**\n-  * @if maint\n-  * Recursive case for tuple_element: strip off the first element in\n-  * the tuple and retrieve the (i-1)th element of the remaining tuple.\n-  * @endif\n-  */\n- template<int __i, typename _Head, typename... _Tail>\n-   struct tuple_element<__i, tuple<_Head, _Tail...> >\n-     : tuple_element<__i - 1, tuple<_Tail...> > { };\n-\n- /**\n-  * @if maint\n-  * Basis case for tuple_element: The first element is the one we're seeking.\n-  * @endif\n-  */\n- template<typename _Head, typename... _Tail>\n-   struct tuple_element<0, tuple<_Head, _Tail...> >\n-   {\n-     typedef _Head type;\n-   };\n-\n- /// Finds the size of a given tuple type.\n- template<typename _Tp>\n-   struct tuple_size;\n+      template<typename _U1, typename _U2>\n+        tuple&\n+        operator=(const tuple<_U1, _U2>& __in)\n+        {\n+\t  static_cast<_Inherited&>(*this) = __in;\n+\t  return *this;\n+\t}\n+\n+      tuple&\n+      operator=(const tuple& __in)\n+      {\n+\tstatic_cast<_Inherited&>(*this) = __in;\n+\treturn *this;\n+      }\n+\n+      template<typename _U1, typename _U2>\n+        tuple&\n+        operator=(const pair<_U1, _U2>& __in)\n+        {\n+\t  this->_M_head = __in.first;\n+\t  this->_M_tail()._M_head = __in.second;\n+\t  return *this;\n+\t}\n+    };\n+\n+  \n+  /// Gives the type of the ith element of a given tuple type.\n+  template<int __i, typename _Tp>\n+    struct tuple_element;\n+\n+  /**\n+   * @if maint\n+   * Recursive case for tuple_element: strip off the first element in\n+   * the tuple and retrieve the (i-1)th element of the remaining tuple.\n+   * @endif\n+   */\n+  template<int __i, typename _Head, typename... _Tail>\n+    struct tuple_element<__i, tuple<_Head, _Tail...> >\n+    : tuple_element<__i - 1, tuple<_Tail...> > { };\n+\n+  /**\n+   * @if maint\n+   * Basis case for tuple_element: The first element is the one we're seeking.\n+   * @endif\n+   */\n+  template<typename _Head, typename... _Tail>\n+    struct tuple_element<0, tuple<_Head, _Tail...> >\n+    {\n+      typedef _Head type;\n+    };\n+\n+  /// Finds the size of a given tuple type.\n+  template<typename _Tp>\n+    struct tuple_size;\n \n   /// @brief class tuple_size\n- template<typename... _Elements>\n-   struct tuple_size<tuple<_Elements...> >\n-   {\n-     static const int value = sizeof...(_Elements);\n-   };\n-\n- // Returns a const reference to the ith element of a tuple.\n- // Any const or non-const ref elements are returned with their original type.\n- template<int __i, typename _Head, typename... _Tail>\n-   inline typename __add_ref<_Head>::type\n-     get(_Tuple_impl<__i, _Head, _Tail...>& __t)\n-     {\n-       return __t._M_head;\n-     }\n-\n- template<int __i, typename _Head, typename... _Tail>\n-   inline typename __add_c_ref<_Head>::type\n-     get(const _Tuple_impl<__i, _Head, _Tail...>& __t)\n-     {\n-       return __t._M_head;\n-     }\n-\n- // This class helps construct the various comparison operations on tuples\n- template<int __check_equal_size, int __i, int __j, typename _Tp, typename _Up>\n-   struct __tuple_compare;\n-\n- template<int __i, int __j, typename _Tp, typename _Up>\n-   struct __tuple_compare<0, __i, __j, _Tp, _Up>\n-   {\n-     static bool __eq(const _Tp& __t, const _Up& __u)\n-     {\n-       return get<__i>(__t) == get<__i>(__u) &&\n-          __tuple_compare<0, __i+1, __j, _Tp, _Up>::__eq(__t, __u);\n-     }\n-     static bool __less(const _Tp& __t, const _Up& __u)\n-     {\n-       return (get<__i>(__t) < get<__i>(__u)) || !(get<__i>(__u) < get<__i>(__t)) &&\n-          __tuple_compare<0, __i+1, __j, _Tp, _Up>::__less(__t, __u);\n-     }\n-   };\n-\n- template<int __i, typename _Tp, typename _Up>\n-   struct __tuple_compare<0, __i, __i, _Tp, _Up>\n-   {\n-     static bool __eq(const _Tp&, const _Up&)\n-     { return true; }\n-     static bool __less(const _Tp&, const _Up&)\n-     { return false; }\n-   };\n-\n- template<typename... _TElements, typename... _UElements>\n- bool\n- operator==(const tuple<_TElements...>& __t, const tuple<_UElements...>& __u)\n- {\n-   typedef tuple<_TElements...> _Tp;\n-   typedef tuple<_UElements...> _Up;\n-   return __tuple_compare<tuple_size<_Tp>::value - tuple_size<_Tp>::value, 0,\n-                          tuple_size<_Tp>::value, _Tp, _Up>::__eq(__t, __u);\n- }\n-\n- template<typename... _TElements, typename... _UElements>\n- bool\n- operator<(const tuple<_TElements...>& __t, const tuple<_UElements...>& __u)\n- {\n-   typedef tuple<_TElements...> _Tp;\n-   typedef tuple<_UElements...> _Up;\n-   return __tuple_compare<tuple_size<_Tp>::value - tuple_size<_Tp>::value, 0,\n-                          tuple_size<_Tp>::value, _Tp, _Up>::__less(__t, __u);\n- }\n-\n- template<typename... _TElements, typename... _UElements>\n- bool\n- operator!=(const tuple<_TElements...>& __t, const tuple<_UElements...>& __u)\n- { return !(__t == __u); }\n-\n- template<typename... _TElements, typename... _UElements>\n- bool\n- operator>(const tuple<_TElements...>& __t, const tuple<_UElements...>& __u)\n- { return __u < __t; }\n-\n- template<typename... _TElements, typename... _UElements>\n- bool\n- operator<=(const tuple<_TElements...>& __t, const tuple<_UElements...>& __u)\n- { return !(__u < __t); }\n-\n- template<typename... _TElements, typename... _UElements>\n- bool\n- operator>=(const tuple<_TElements...>& __t, const tuple<_UElements...>& __u)\n- { return !(__t < __u); }\n-\n- // Helper which adds a reference to a type when given a reference_wrapper\n- template<typename _Tp>\n-   struct __strip_reference_wrapper\n-   {\n-       typedef _Tp __type;\n-   };\n-\n- template<typename _Tp>\n-   struct __strip_reference_wrapper<reference_wrapper<_Tp> >\n-   {\n-     typedef _Tp& __type;\n-   };\n-\n- template<typename _Tp>\n-   struct __strip_reference_wrapper<const reference_wrapper<_Tp> >\n-   {\n-       typedef _Tp& __type;\n-   };\n+  template<typename... _Elements>\n+    struct tuple_size<tuple<_Elements...> >\n+    {\n+      static const int value = sizeof...(_Elements);\n+    };\n+\n+  template<typename... _Elements>\n+    const int tuple_size<tuple<_Elements...> >::value;\n+\n+  // Returns a const reference to the ith element of a tuple.\n+  // Any const or non-const ref elements are returned with their original type.\n+  template<int __i, typename _Head, typename... _Tail>\n+    inline typename __add_ref<_Head>::type\n+    get(_Tuple_impl<__i, _Head, _Tail...>& __t)\n+    {\n+      return __t._M_head;\n+    }\n+\n+  template<int __i, typename _Head, typename... _Tail>\n+    inline typename __add_c_ref<_Head>::type\n+    get(const _Tuple_impl<__i, _Head, _Tail...>& __t)\n+    {\n+      return __t._M_head;\n+    }\n+\n+  // This class helps construct the various comparison operations on tuples\n+  template<int __check_equal_size, int __i, int __j,\n+\t   typename _Tp, typename _Up>\n+    struct __tuple_compare;\n+\n+  template<int __i, int __j, typename _Tp, typename _Up>\n+    struct __tuple_compare<0, __i, __j, _Tp, _Up>\n+    {\n+      static bool __eq(const _Tp& __t, const _Up& __u)\n+      {\n+\treturn (get<__i>(__t) == get<__i>(__u) &&\n+\t\t__tuple_compare<0, __i+1, __j, _Tp, _Up>::__eq(__t, __u));\n+      }\n+     \n+      static bool __less(const _Tp& __t, const _Up& __u)\n+      {\n+\treturn ((get<__i>(__t) < get<__i>(__u))\n+\t\t|| !(get<__i>(__u) < get<__i>(__t)) &&\n+\t\t__tuple_compare<0, __i+1, __j, _Tp, _Up>::__less(__t, __u));\n+      }\n+    };\n+\n+  template<int __i, typename _Tp, typename _Up>\n+    struct __tuple_compare<0, __i, __i, _Tp, _Up>\n+    {\n+      static bool __eq(const _Tp&, const _Up&)\n+      { return true; }\n+     \n+      static bool __less(const _Tp&, const _Up&)\n+      { return false; }\n+    };\n+\n+  template<typename... _TElements, typename... _UElements>\n+    bool\n+    operator==(const tuple<_TElements...>& __t,\n+\t       const tuple<_UElements...>& __u)\n+    {\n+      typedef tuple<_TElements...> _Tp;\n+      typedef tuple<_UElements...> _Up;\n+      return (__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Tp>::value,\n+\t      0, tuple_size<_Tp>::value, _Tp, _Up>::__eq(__t, __u));\n+    }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    bool\n+    operator<(const tuple<_TElements...>& __t,\n+\t      const tuple<_UElements...>& __u)\n+    {\n+      typedef tuple<_TElements...> _Tp;\n+      typedef tuple<_UElements...> _Up;\n+      return (__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Tp>::value,\n+\t      0, tuple_size<_Tp>::value, _Tp, _Up>::__less(__t, __u));\n+    }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    bool\n+    operator!=(const tuple<_TElements...>& __t,\n+\t       const tuple<_UElements...>& __u)\n+    { return !(__t == __u); }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    bool\n+    operator>(const tuple<_TElements...>& __t,\n+\t      const tuple<_UElements...>& __u)\n+    { return __u < __t; }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    bool\n+    operator<=(const tuple<_TElements...>& __t,\n+\t       const tuple<_UElements...>& __u)\n+    { return !(__u < __t); }\n+\n+  template<typename... _TElements, typename... _UElements>\n+    bool\n+    operator>=(const tuple<_TElements...>& __t,\n+\t       const tuple<_UElements...>& __u)\n+    { return !(__t < __u); }\n+\n+  // Helper which adds a reference to a type when given a reference_wrapper\n+  template<typename _Tp>\n+    struct __strip_reference_wrapper\n+    {\n+      typedef _Tp __type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __strip_reference_wrapper<reference_wrapper<_Tp> >\n+    {\n+      typedef _Tp& __type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __strip_reference_wrapper<const reference_wrapper<_Tp> >\n+    {\n+      typedef _Tp& __type;\n+    };\n \n   template<typename... _Elements>\n     inline tuple<typename __strip_reference_wrapper<_Elements>::__type...>\n@@ -373,30 +392,29 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n     }\n \n   template<typename... _Elements>\n-    inline tuple<_Elements&...> tie(_Elements&... __args)\n+    inline tuple<_Elements&...>\n+    tie(_Elements&... __args)\n     {\n       return tuple<_Elements&...>(__args...);\n     }\n \n- // A class (and instance) which can be used in 'tie' when an element\n- // of a tuple is not required\n- struct swallow_assign\n- {\n-   template<class T>\n-   swallow_assign&\n-     operator=(const T&)\n-     { return *this; }\n- };\n-\n- // TODO: Put this in some kind of shared file.\n- namespace\n- {\n-   swallow_assign ignore;\n- }; // anonymous namespace\n+  // A class (and instance) which can be used in 'tie' when an element\n+  // of a tuple is not required\n+  struct _Swallow_assign\n+  {\n+    template<class _Tp>\n+      _Swallow_assign&\n+      operator=(const _Tp&)\n+      { return *this; }\n+  };\n+\n+  // TODO: Put this in some kind of shared file.\n+  namespace\n+  {\n+    _Swallow_assign ignore;\n+  }; // anonymous namespace\n \n _GLIBCXX_END_NAMESPACE\n }\n \n-#include <tr1/functional>\n-\n #endif"}, {"sha": "dba6ccc4357810a6f5d019a861d1cb226a1eecd3", "filename": "libstdc++-v3/include/tr1/tuple_defs.h", "status": "removed", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde6c7a990efcfadfd832983367a8e783647aa1d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde6c7a990efcfadfd832983367a8e783647aa1d/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple_defs.h?ref=bde6c7a990efcfadfd832983367a8e783647aa1d", "patch": "@@ -1,114 +0,0 @@\n-// class template tuple -*- C++ -*-\n-\n-// Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file tr1/tuple_defs.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#ifndef _GLIBCXX_REPEAT_HEADER\n-#  define _GLIBCXX_REPEAT_HEADER \"tuple_defs.h\"\n-#  include \"repeat.h\"\n-#  undef _GLIBCXX_REPEAT_HEADER\n-#endif\n-\n-#ifdef _GLIBCXX_LAST_INCLUDE\n-// Chris Jefferson <chris@bubblescope.net>\n-   template<_GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS> class tuple;\n-\n-   // Returns a const reference to the ith element of a tuple.\n-   // Any const or non-const ref elements are returned with their original type.\n-   template<int __i, _GLIBCXX_TEMPLATE_PARAMS>\n-   typename __add_ref<typename tuple_element<__i, tuple<_GLIBCXX_TEMPLATE_ARGS> >::type>::type\n-   get(tuple<_GLIBCXX_TEMPLATE_ARGS>& __t)\n-   {\n-     return __get_helper<__i, tuple<_GLIBCXX_TEMPLATE_ARGS> >::get_value(__t);\n-   }\n-\n-   template<int __i, _GLIBCXX_TEMPLATE_PARAMS>\n-   typename __add_c_ref<typename tuple_element<__i, tuple<_GLIBCXX_TEMPLATE_ARGS> >::type>::type\n-   get(const tuple<_GLIBCXX_TEMPLATE_ARGS>& __t)\n-   {\n-     return __get_helper<__i, tuple<_GLIBCXX_TEMPLATE_ARGS> >::get_value(__t);\n-   }\n-\n- template<_GLIBCXX_TEMPLATE_PARAMS, _GLIBCXX_TEMPLATE_PARAMS_U>\n- bool\n- operator==(const tuple<_GLIBCXX_TEMPLATE_ARGS>& __t,\n-            const tuple<_GLIBCXX_TEMPLATE_ARGS_U>& __u)\n- {\n-   typedef tuple<_GLIBCXX_TEMPLATE_ARGS> _Tp;\n-   typedef tuple<_GLIBCXX_TEMPLATE_ARGS_U> _Up;\n-   return __tuple_compare<tuple_size<_Tp>::value - tuple_size<_Tp>::value, 0,\n-                          tuple_size<_Tp>::value, _Tp, _Up>::__eq(__t, __u);\n- }\n-\n- template<_GLIBCXX_TEMPLATE_PARAMS, _GLIBCXX_TEMPLATE_PARAMS_U>\n- bool\n- operator<(const tuple<_GLIBCXX_TEMPLATE_ARGS>& __t,\n-           const tuple<_GLIBCXX_TEMPLATE_ARGS_U>& __u)\n- {\n-   typedef tuple<_GLIBCXX_TEMPLATE_ARGS> _Tp;\n-   typedef tuple<_GLIBCXX_TEMPLATE_ARGS_U> _Up;\n-   return __tuple_compare<tuple_size<_Tp>::value - tuple_size<_Tp>::value, 0,\n-                          tuple_size<_Tp>::value, _Tp, _Up>::__less(__t, __u);\n- }\n-\n- template<_GLIBCXX_TEMPLATE_PARAMS, _GLIBCXX_TEMPLATE_PARAMS_U>\n- bool\n- operator!=(const tuple<_GLIBCXX_TEMPLATE_ARGS>& __t,\n-            const tuple<_GLIBCXX_TEMPLATE_ARGS_U>& __u)\n- { return !(__t == __u); }\n-\n- template<_GLIBCXX_TEMPLATE_PARAMS, _GLIBCXX_TEMPLATE_PARAMS_U>\n- bool\n- operator>(const tuple<_GLIBCXX_TEMPLATE_ARGS>& __t,\n-           const tuple<_GLIBCXX_TEMPLATE_ARGS_U>& __u)\n- { return __u < __t; }\n-\n- template<_GLIBCXX_TEMPLATE_PARAMS, _GLIBCXX_TEMPLATE_PARAMS_U>\n- bool\n- operator<=(const tuple<_GLIBCXX_TEMPLATE_ARGS>& __t,\n-            const tuple<_GLIBCXX_TEMPLATE_ARGS_U>& __u)\n- { return !(__u < __t); }\n-\n- template<_GLIBCXX_TEMPLATE_PARAMS, _GLIBCXX_TEMPLATE_PARAMS_U>\n- bool\n- operator>=(const tuple<_GLIBCXX_TEMPLATE_ARGS>& __t,\n-            const tuple<_GLIBCXX_TEMPLATE_ARGS_U>& __u)\n- { return !(__t < __u); }\n-\n- template<_GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS>\n-   struct __stripped_tuple_type\n-   {\n-     typedef tuple<_GLIBCXX_TEMPLATE_ARGS_STRIPPED>      __type;\n-   };\n-\n-#endif\n-"}, {"sha": "a599b7ec7b6c34920c0c7730a61e624d9a2edeb3", "filename": "libstdc++-v3/testsuite/tr1/6_containers/tuple/creation_functions/make_tuple.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d265b0b1c24d13c3dfdf830877fa8edf87e8c15d/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcreation_functions%2Fmake_tuple.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d265b0b1c24d13c3dfdf830877fa8edf87e8c15d/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcreation_functions%2Fmake_tuple.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcreation_functions%2Fmake_tuple.cc?ref=d265b0b1c24d13c3dfdf830877fa8edf87e8c15d", "patch": "@@ -1,6 +1,6 @@\n // 2004-09-23 Chris Jefferson <chris@bubblescope.net>\n \n-// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -21,6 +21,7 @@\n // Tuple\n \n #include <tr1/tuple>\n+#include <tr1/functional>\n #include <testsuite_hooks.h>\n \n using namespace std;"}]}