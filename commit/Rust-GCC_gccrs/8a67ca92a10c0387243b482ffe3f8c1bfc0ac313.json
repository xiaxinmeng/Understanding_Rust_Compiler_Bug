{"sha": "8a67ca92a10c0387243b482ffe3f8c1bfc0ac313", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE2N2NhOTJhMTBjMDM4NzI0M2I0ODJmZmUzZjhjMWJmYzBhYzMxMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2009-11-23T00:01:47Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-11-23T00:01:47Z"}, "message": "i386.c (avx_vpermilp_parallel): New function.\n\n\t* i386.c (avx_vpermilp_parallel): New function.\n\t* i386-protos.h: Declare it.\n\t* predicates.md (avx_vpermilp_v8sf_operand, avx_vpermilp_v4df_operand,\n\tavx_vpermilp_v4sf_operand, avx_vpermilp_v2df_operand): New.\n\t* sse.md (AVXMODEFDP, AVXMODEFSP): New iterators.\n\t(ssescalarnum, ssedoublesizemode): Add AVX modes.\n\t(vpermilbits): Remove.\n\t(avx_vpermil<mode>): Change insns to expanders.\n\t(*avx_vpermil<mode>): New.  Use vec_select.\n\nFrom-SVN: r154427", "tree": {"sha": "87c45b877f688ae9cf524b6f49c09a695a6c6e5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87c45b877f688ae9cf524b6f49c09a695a6c6e5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a67ca92a10c0387243b482ffe3f8c1bfc0ac313", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a67ca92a10c0387243b482ffe3f8c1bfc0ac313", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a67ca92a10c0387243b482ffe3f8c1bfc0ac313", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a67ca92a10c0387243b482ffe3f8c1bfc0ac313/comments", "author": null, "committer": null, "parents": [{"sha": "d90a2c59eb3e014cd145aed7086966790bef42f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d90a2c59eb3e014cd145aed7086966790bef42f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d90a2c59eb3e014cd145aed7086966790bef42f7"}], "stats": {"total": 195, "additions": 180, "deletions": 15}, "files": [{"sha": "9a266369b932bbc1c8ee7b0b55d82b0b508b062b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a67ca92a10c0387243b482ffe3f8c1bfc0ac313/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a67ca92a10c0387243b482ffe3f8c1bfc0ac313/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a67ca92a10c0387243b482ffe3f8c1bfc0ac313", "patch": "@@ -1,3 +1,15 @@\n+2009-11-22  Richard Henderson  <rth@redhat.com>\n+\n+\t* i386.c (avx_vpermilp_parallel): New function.\n+\t* i386-protos.h: Declare it.\n+\t* predicates.md (avx_vpermilp_v8sf_operand, avx_vpermilp_v4df_operand,\n+\tavx_vpermilp_v4sf_operand, avx_vpermilp_v2df_operand): New.\n+\t* sse.md (AVXMODEFDP, AVXMODEFSP): New iterators.\n+\t(ssescalarnum, ssedoublesizemode): Add AVX modes.\n+\t(vpermilbits): Remove.\n+\t(avx_vpermil<mode>): Change insns to expanders.\n+\t(*avx_vpermil<mode>): New.  Use vec_select.\n+\n 2009-11-22  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* opts.c (decode_options): Don't enable flag_schedule_insns "}, {"sha": "d36b269c211fa969f03d5884ec2da063598f4745", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a67ca92a10c0387243b482ffe3f8c1bfc0ac313/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a67ca92a10c0387243b482ffe3f8c1bfc0ac313/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=8a67ca92a10c0387243b482ffe3f8c1bfc0ac313", "patch": "@@ -47,6 +47,8 @@ extern bool x86_extended_QIreg_mentioned_p (rtx);\n extern bool x86_extended_reg_mentioned_p (rtx);\n extern enum machine_mode ix86_cc_mode (enum rtx_code, rtx, rtx);\n \n+extern int avx_vpermilp_parallel (rtx par, enum machine_mode mode);\n+\n extern int ix86_expand_movmem (rtx, rtx, rtx, rtx, rtx, rtx);\n extern int ix86_expand_setmem (rtx, rtx, rtx, rtx, rtx, rtx);\n extern int ix86_expand_strlen (rtx, rtx, rtx, rtx);\n@@ -275,3 +277,4 @@ extern int asm_preferred_eh_data_format (int, int);\n #ifdef HAVE_ATTR_cpu\n extern enum attr_cpu ix86_schedule;\n #endif\n+"}, {"sha": "b1499244fd6525ac5d07f4ca90953350dda42591", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a67ca92a10c0387243b482ffe3f8c1bfc0ac313/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a67ca92a10c0387243b482ffe3f8c1bfc0ac313/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=8a67ca92a10c0387243b482ffe3f8c1bfc0ac313", "patch": "@@ -24527,6 +24527,82 @@ ix86_builtin_reciprocal (unsigned int fn, bool md_fn,\n \treturn NULL_TREE;\n       }\n }\n+\f\n+/* Helper for avx_vpermilps256_operand et al.  This is also used by\n+   the expansion functions to turn the parallel back into a mask.\n+   The return value is 0 for no match and the imm8+1 for a match.  */\n+\n+int\n+avx_vpermilp_parallel (rtx par, enum machine_mode mode)\n+{\n+  unsigned i, nelt = GET_MODE_NUNITS (mode);\n+  unsigned mask = 0;\n+  unsigned char ipar[8];\n+\n+  if (XVECLEN (par, 0) != nelt)\n+    return 0;\n+\n+  /* Validate that all of the elements are constants, and not totally\n+     out of range.  Copy the data into an integral array to make the\n+     subsequent checks easier.  */\n+  for (i = 0; i < nelt; ++i)\n+    {\n+      rtx er = XVECEXP (par, 0, i);\n+      unsigned HOST_WIDE_INT ei;\n+\n+      if (!CONST_INT_P (er))\n+\treturn 0;\n+      ei = INTVAL (er);\n+      if (ei >= nelt)\n+\treturn 0;\n+      ipar[i] = ei;\n+    }\n+\n+  switch (mode)\n+    {\n+    case V4DFmode:\n+      /* In the 256-bit DFmode case, we can only move elements within\n+         a 128-bit lane.  */\n+      for (i = 0; i < 2; ++i)\n+\t{\n+\t  if (ipar[i] >= 2)\n+\t    return 0;\n+\t  mask |= ipar[i] << i;\n+\t}\n+      for (i = 2; i < 4; ++i)\n+\t{\n+\t  if (ipar[i] < 2)\n+\t    return 0;\n+\t  mask |= (ipar[i] - 2) << i;\n+\t}\n+      break;\n+\n+    case V8SFmode:\n+      /* In the 256-bit SFmode case, we have full freedom of movement\n+\t within the low 128-bit lane, but the high 128-bit lane must\n+\t mirror the exact same pattern.  */\n+      for (i = 0; i < 4; ++i)\n+\tif (ipar[i] + 4 != ipar[i + 4])\n+\t  return 0;\n+      nelt = 4;\n+      /* FALLTHRU */\n+\n+    case V2DFmode:\n+    case V4SFmode:\n+      /* In the 128-bit case, we've full freedom in the placement of\n+\t the elements from the source operand.  */\n+      for (i = 0; i < nelt; ++i)\n+\tmask |= ipar[i] << (i * (nelt / 2));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Make sure success has a non-zero value by adding one.  */\n+  return mask + 1;\n+}\n+\f\n \n /* Store OPERAND to the memory after reload is completed.  This means\n    that we can't easily use assign_stack_local.  */"}, {"sha": "1e8200aae1885e78c8891b7d0884e02f493ed333", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a67ca92a10c0387243b482ffe3f8c1bfc0ac313/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a67ca92a10c0387243b482ffe3f8c1bfc0ac313/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=8a67ca92a10c0387243b482ffe3f8c1bfc0ac313", "patch": "@@ -1148,3 +1148,24 @@\n \n   return 1;\n })\n+\n+;; Return 1 if OP is a parallel for a vpermilp[ds] permute.\n+;; ??? It would be much easier if the PARALLEL for a VEC_SELECT\n+;; had a mode, but it doesn't.  So we have 4 copies and install\n+;; the mode by hand.\n+\n+(define_predicate \"avx_vpermilp_v8sf_operand\"\n+  (and (match_code \"parallel\")\n+       (match_test \"avx_vpermilp_parallel (op, V8SFmode)\")))\n+\n+(define_predicate \"avx_vpermilp_v4df_operand\"\n+  (and (match_code \"parallel\")\n+       (match_test \"avx_vpermilp_parallel (op, V4DFmode)\")))\n+\n+(define_predicate \"avx_vpermilp_v4sf_operand\"\n+  (and (match_code \"parallel\")\n+       (match_test \"avx_vpermilp_parallel (op, V4SFmode)\")))\n+\n+(define_predicate \"avx_vpermilp_v2df_operand\"\n+  (and (match_code \"parallel\")\n+       (match_test \"avx_vpermilp_parallel (op, V2DFmode)\")))"}, {"sha": "79adc77a628661e752ca6eeb89722e3e34487c06", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 68, "deletions": 15, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a67ca92a10c0387243b482ffe3f8c1bfc0ac313/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a67ca92a10c0387243b482ffe3f8c1bfc0ac313/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=8a67ca92a10c0387243b482ffe3f8c1bfc0ac313", "patch": "@@ -58,6 +58,8 @@\n (define_mode_iterator AVX256MODE8P [V8SI V8SF])\n (define_mode_iterator AVXMODEF2P [V4SF V2DF V8SF V4DF])\n (define_mode_iterator AVXMODEF4P [V4SF V4DF])\n+(define_mode_iterator AVXMODEFDP [V2DF V4DF])\n+(define_mode_iterator AVXMODEFSP [V4SF V8SF])\n (define_mode_iterator AVXMODEDCVTDQ2PS [V4SF V8SF])\n (define_mode_iterator AVXMODEDCVTPS2DQ [V4SI V8SI])\n \n@@ -95,13 +97,16 @@\n \t\t\t\t (V4SI \"SI\") (V2DI \"DI\")])\n \n ;; Mapping of vector modes to a vector mode of double size\n-(define_mode_attr ssedoublesizemode [(V2DF \"V4DF\") (V2DI \"V4DI\")\n-\t\t\t\t     (V4SF \"V8SF\") (V4SI \"V8SI\")])\n+(define_mode_attr ssedoublesizemode\n+  [(V2DF \"V4DF\") (V2DI \"V4DI\") (V4SF \"V8SF\") (V4SI \"V8SI\")\n+   (V8HI \"V16HI\") (V16QI \"V32QI\")\n+   (V4DF \"V8DF\") (V8SF \"V16SF\")\n+   (V4DI \"V8DI\") (V8SI \"V16SI\") (V16HI \"V32HI\") (V32QI \"V64QI\")])\n \n ;; Number of scalar elements in each vector type\n-(define_mode_attr ssescalarnum [(V4SF \"4\") (V2DF \"2\")\n-\t\t\t\t(V16QI \"16\") (V8HI \"8\")\n-\t\t\t\t(V4SI \"4\") (V2DI \"2\")])\n+(define_mode_attr ssescalarnum\n+  [(V4SF \"4\") (V2DF \"2\") (V16QI \"16\") (V8HI \"8\") (V4SI \"4\") (V2DI \"2\")\n+   (V8SF \"8\") (V4DF \"4\") (V32QI \"32\") (V16HI \"16\") (V8SI \"8\") (V4DI \"4\")])\n \n ;; Mapping for AVX\n (define_mode_attr avxvecmode\n@@ -134,10 +139,6 @@\n (define_mode_attr blendbits\n   [(V8SF \"255\") (V4SF \"15\") (V4DF \"15\") (V2DF \"3\")])\n \n-;; Mapping of immediate bits for vpermil instructions\n-(define_mode_attr vpermilbits\n-  [(V8SF \"255\") (V4SF \"255\") (V4DF \"15\") (V2DF \"3\")])\n-\n ;; Mapping of immediate bits for pinsr instructions\n (define_mode_attr pinsrbits [(V16QI \"32768\") (V8HI \"128\") (V4SI \"8\")])\n \n@@ -12088,14 +12089,66 @@\n    (set_attr \"prefix\" \"vex\")\n    (set_attr \"mode\" \"OI\")])\n \n-(define_insn \"avx_vpermil<mode>\"\n+(define_expand \"avx_vpermil<mode>\"\n+  [(set (match_operand:AVXMODEFDP 0 \"register_operand\" \"\")\n+\t(vec_select:AVXMODEFDP\n+\t  (match_operand:AVXMODEFDP 1 \"nonimmediate_operand\" \"\")\n+\t  (match_operand:SI 2 \"const_0_to_255_operand\" \"\")))]\n+  \"TARGET_AVX\"\n+{\n+  int mask = INTVAL (operands[2]);\n+  rtx perm[<ssescalarnum>];\n+\n+  perm[0] = GEN_INT (mask & 1);\n+  perm[1] = GEN_INT ((mask >> 1) & 1);\n+  if (<MODE>mode == V4DFmode)\n+    {\n+      perm[2] = GEN_INT (((mask >> 2) & 1) + 2);\n+      perm[3] = GEN_INT (((mask >> 3) & 1) + 2);\n+    }\n+\n+  operands[2]\n+    = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (<ssescalarnum>, perm));\n+})\n+\n+(define_expand \"avx_vpermil<mode>\"\n+  [(set (match_operand:AVXMODEFSP 0 \"register_operand\" \"\")\n+\t(vec_select:AVXMODEFSP\n+\t  (match_operand:AVXMODEFSP 1 \"nonimmediate_operand\" \"\")\n+\t  (match_operand:SI 2 \"const_0_to_255_operand\" \"\")))]\n+  \"TARGET_AVX\"\n+{\n+  int mask = INTVAL (operands[2]);\n+  rtx perm[<ssescalarnum>];\n+\n+  perm[0] = GEN_INT (mask & 3);\n+  perm[1] = GEN_INT ((mask >> 2) & 3);\n+  perm[2] = GEN_INT ((mask >> 4) & 3);\n+  perm[3] = GEN_INT ((mask >> 6) & 3);\n+  if (<MODE>mode == V8SFmode)\n+    {\n+      perm[4] = GEN_INT ((mask & 3) + 4);\n+      perm[5] = GEN_INT (((mask >> 2) & 3) + 4);\n+      perm[6] = GEN_INT (((mask >> 4) & 3) + 4);\n+      perm[7] = GEN_INT (((mask >> 6) & 3) + 4);\n+    }\n+\n+  operands[2]\n+    = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (<ssescalarnum>, perm));\n+})\n+\n+(define_insn \"*avx_vpermilp<mode>\"\n   [(set (match_operand:AVXMODEF2P 0 \"register_operand\" \"=x\")\n-\t(unspec:AVXMODEF2P\n-\t  [(match_operand:AVXMODEF2P 1 \"register_operand\" \"xm\")\n-\t   (match_operand:SI 2 \"const_0_to_<vpermilbits>_operand\" \"n\")]\n-\t  UNSPEC_VPERMIL))]\n+\t(vec_select:AVXMODEF2P\n+\t  (match_operand:AVXMODEF2P 1 \"nonimmediate_operand\" \"xm\")\n+\t  (match_parallel 2 \"avx_vpermilp_<mode>_operand\"\n+\t    [(match_operand 3 \"const_int_operand\" \"\")])))]\n   \"TARGET_AVX\"\n-  \"vpermilp<avxmodesuffixf2c>\\t{%2, %1, %0|%0, %1, %2}\"\n+{\n+  int mask = avx_vpermilp_parallel (operands[2], <MODE>mode) - 1;\n+  operands[2] = GEN_INT (mask);\n+  return \"vpermilp<avxmodesuffixf2c>\\t{%2, %1, %0|%0, %1, %2}\";\n+}\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")"}]}