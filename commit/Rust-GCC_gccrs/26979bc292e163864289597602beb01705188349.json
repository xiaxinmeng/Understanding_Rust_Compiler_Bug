{"sha": "26979bc292e163864289597602beb01705188349", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY5NzliYzI5MmUxNjM4NjQyODk1OTc2MDJiZWIwMTcwNTE4ODM0OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-12-04T22:51:42Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-12-04T22:51:42Z"}, "message": "cp-objcp-common.c (cp_expr_size): Return NULL in the case size is undefined.\n\n\t* cp-objcp-common.c (cp_expr_size): Return NULL in the case\n\tsize is undefined.\n\n\t* builtins.c (fold_builtin_memory_op): Check that expr_size match.\n\t* explow.c (expr_size, int_expr_size): Assert that size is non_NULL.\n\nFrom-SVN: r119515", "tree": {"sha": "aec6f99c441c9265e6586e4694d0aa72c7570eaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aec6f99c441c9265e6586e4694d0aa72c7570eaa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26979bc292e163864289597602beb01705188349", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26979bc292e163864289597602beb01705188349", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26979bc292e163864289597602beb01705188349", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26979bc292e163864289597602beb01705188349/comments", "author": null, "committer": null, "parents": [{"sha": "477d851ce1a3b9fbe06c921ebd99925276792085", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/477d851ce1a3b9fbe06c921ebd99925276792085", "html_url": "https://github.com/Rust-GCC/gccrs/commit/477d851ce1a3b9fbe06c921ebd99925276792085"}], "stats": {"total": 75, "additions": 48, "deletions": 27}, "files": [{"sha": "1de07b1f9c449fb02421557142b1bc0d5788b74c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26979bc292e163864289597602beb01705188349/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26979bc292e163864289597602beb01705188349/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26979bc292e163864289597602beb01705188349", "patch": "@@ -1,3 +1,8 @@\n+2006-12-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* builtins.c (fold_builtin_memory_op): Check that expr_size match.\n+\t* explow.c (expr_size, int_expr_size): Assert that size is non_NULL.\n+\n 2006-12-04  Daniel Berlin  <dberlin@dberlin.org>\n \t\n \t* tree-ssa-alias.c (compute_may_aliases):"}, {"sha": "0cfdb9af12cad61fb7438efd5eb345d0806197e8", "filename": "gcc/builtins.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26979bc292e163864289597602beb01705188349/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26979bc292e163864289597602beb01705188349/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=26979bc292e163864289597602beb01705188349", "patch": "@@ -8202,8 +8202,8 @@ fold_builtin_memory_op (tree arglist, tree type, bool ignore, int endp)\n \t  || !TYPE_SIZE_UNIT (desttype)\n \t  || TREE_CODE (TYPE_SIZE_UNIT (srctype)) != INTEGER_CST\n \t  || TREE_CODE (TYPE_SIZE_UNIT (desttype)) != INTEGER_CST\n-\t  || !operand_equal_p (TYPE_SIZE_UNIT (srctype), len, 0)\n-\t  || !operand_equal_p (TYPE_SIZE_UNIT (desttype), len, 0))\n+\t  || !tree_int_cst_equal (TYPE_SIZE_UNIT (srctype), len)\n+\t  || !tree_int_cst_equal (TYPE_SIZE_UNIT (desttype), len))\n \treturn 0;\n \n       if (get_pointer_alignment (dest, BIGGEST_ALIGNMENT) \n@@ -8218,6 +8218,8 @@ fold_builtin_memory_op (tree arglist, tree type, bool ignore, int endp)\n       srcvar = build_fold_indirect_ref (src);\n       if (TREE_THIS_VOLATILE (srcvar))\n \treturn 0;\n+      if (!tree_int_cst_equal (lang_hooks.expr_size (srcvar), len))\n+\treturn 0;\n       /* With memcpy, it is possible to bypass aliasing rules, so without\n          this check i. e. execute/20060930-2.c would be misoptimized, because\n \t it use conflicting alias set to hold argument for the memcpy call.\n@@ -8233,6 +8235,8 @@ fold_builtin_memory_op (tree arglist, tree type, bool ignore, int endp)\n       destvar = build_fold_indirect_ref (dest);\n       if (TREE_THIS_VOLATILE (destvar))\n \treturn 0;\n+      if (!tree_int_cst_equal (lang_hooks.expr_size (destvar), len))\n+\treturn 0;\n       if (!var_decl_component_p (destvar))\n \treturn 0;\n "}, {"sha": "31c87e20af88c7cf0a15895657f62fc3bbf7cd64", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26979bc292e163864289597602beb01705188349/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26979bc292e163864289597602beb01705188349/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=26979bc292e163864289597602beb01705188349", "patch": "@@ -1,3 +1,8 @@\n+2006-12-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cp-objcp-common.c (cp_expr_size): Return NULL in the case\n+\tsize is undefined.\n+\n 2006-12-04  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/29733"}, {"sha": "a3640876c1d0bbec70850767d45debdb9e33b695", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26979bc292e163864289597602beb01705188349/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26979bc292e163864289597602beb01705188349/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=26979bc292e163864289597602beb01705188349", "patch": "@@ -82,29 +82,29 @@ cp_expr_size (tree exp)\n       /* The backend should not be interested in the size of an expression\n \t of a type with both of these set; all copies of such types must go\n \t through a constructor or assignment op.  */\n-      gcc_assert (!TYPE_HAS_COMPLEX_INIT_REF (type)\n-\t\t  || !TYPE_HAS_COMPLEX_ASSIGN_REF (type)\n-\t\t  /* But storing a CONSTRUCTOR isn't a copy.  */\n-\t\t  || TREE_CODE (exp) == CONSTRUCTOR\n-\t\t  /* And, the gimplifier will sometimes make a copy of\n-\t\t     an aggregate.  In particular, for a case like:\n-\n-\t\t\tstruct S { S(); };\n-\t\t\tstruct X { int a; S s; };\n-\t\t\tX x = { 0 };\n-\n-\t\t     the gimplifier will create a temporary with\n-\t\t     static storage duration, perform static\n-\t\t     initialization of the temporary, and then copy\n-\t\t     the result.  Since the \"s\" subobject is never\n-\t\t     constructed, this is a valid transformation.  */\n-\t\t  || CP_AGGREGATE_TYPE_P (type));\n-\n-      /* This would be wrong for a type with virtual bases, but they are\n-\t caught by the assert above.  */\n-      return (is_empty_class (type)\n-\t      ? size_zero_node\n-\t      : CLASSTYPE_SIZE_UNIT (type));\n+      if (!TYPE_HAS_COMPLEX_INIT_REF (type)\n+\t  || !TYPE_HAS_COMPLEX_ASSIGN_REF (type)\n+\t  /* But storing a CONSTRUCTOR isn't a copy.  */\n+\t  || TREE_CODE (exp) == CONSTRUCTOR\n+\t  /* And, the gimplifier will sometimes make a copy of\n+\t     an aggregate.  In particular, for a case like:\n+\n+\t\tstruct S { S(); };\n+\t\tstruct X { int a; S s; };\n+\t\tX x = { 0 };\n+\n+\t     the gimplifier will create a temporary with\n+\t     static storage duration, perform static\n+\t     initialization of the temporary, and then copy\n+\t     the result.  Since the \"s\" subobject is never\n+\t     constructed, this is a valid transformation.  */\n+\t  || CP_AGGREGATE_TYPE_P (type))\n+\t/* This would be wrong for a type with virtual bases.  */\n+\treturn (is_empty_class (type)\n+\t\t? size_zero_node\n+\t\t: CLASSTYPE_SIZE_UNIT (type));\n+      else\n+\treturn NULL_TREE;\n     }\n   else\n     /* Use the default code.  */"}, {"sha": "a71027447101c7d6d27436c95d99fad55f91a2e5", "filename": "gcc/explow.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26979bc292e163864289597602beb01705188349/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26979bc292e163864289597602beb01705188349/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=26979bc292e163864289597602beb01705188349", "patch": "@@ -245,7 +245,11 @@ expr_size (tree exp)\n   if (TREE_CODE (exp) == WITH_SIZE_EXPR)\n     size = TREE_OPERAND (exp, 1);\n   else\n-    size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (lang_hooks.expr_size (exp), exp);\n+    {\n+      size = lang_hooks.expr_size (exp);\n+      gcc_assert (size);\n+      size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (size, exp);\n+    }\n \n   return expand_expr (size, NULL_RTX, TYPE_MODE (sizetype), 0);\n }\n@@ -261,7 +265,10 @@ int_expr_size (tree exp)\n   if (TREE_CODE (exp) == WITH_SIZE_EXPR)\n     size = TREE_OPERAND (exp, 1);\n   else\n-    size = lang_hooks.expr_size (exp);\n+    {\n+      size = lang_hooks.expr_size (exp);\n+      gcc_assert (size);\n+    }\n \n   if (size == 0 || !host_integerp (size, 0))\n     return -1;"}]}