{"sha": "0566b51e1fc647d43e1a2dedc8a2d80acd70e1d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU2NmI1MWUxZmM2NDdkNDNlMWEyZGVkYzhhMmQ4MGFjZDcwZTFkNQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2004-06-15T18:51:43Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-06-15T18:51:43Z"}, "message": "tree-flow-inline.h: Document all functions.\n\n2004-06-15  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree-flow-inline.h: Document all functions.\n\nFrom-SVN: r83197", "tree": {"sha": "abe9f3da9364003c25a36fc59bf6b2925d8286b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abe9f3da9364003c25a36fc59bf6b2925d8286b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0566b51e1fc647d43e1a2dedc8a2d80acd70e1d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0566b51e1fc647d43e1a2dedc8a2d80acd70e1d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0566b51e1fc647d43e1a2dedc8a2d80acd70e1d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0566b51e1fc647d43e1a2dedc8a2d80acd70e1d5/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c8a6f15498c274ee708b862f61d8358a2d4c11ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8a6f15498c274ee708b862f61d8358a2d4c11ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8a6f15498c274ee708b862f61d8358a2d4c11ea"}], "stats": {"total": 95, "additions": 92, "deletions": 3}, "files": [{"sha": "200cdd486f3be0b7100bbf047d61a6b5ec36588a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0566b51e1fc647d43e1a2dedc8a2d80acd70e1d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0566b51e1fc647d43e1a2dedc8a2d80acd70e1d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0566b51e1fc647d43e1a2dedc8a2d80acd70e1d5", "patch": "@@ -1,3 +1,7 @@\n+2004-06-15  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree-flow-inline.h: Document all functions.\n+\t\n 2004-06-15  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-flow-inline.h (stmt_ann): Remove use of is_essa_node."}, {"sha": "17eb6db7365e01b0f0b4eab736627a1036cf00eb", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 88, "deletions": 3, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0566b51e1fc647d43e1a2dedc8a2d80acd70e1d5/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0566b51e1fc647d43e1a2dedc8a2d80acd70e1d5/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=0566b51e1fc647d43e1a2dedc8a2d80acd70e1d5", "patch": "@@ -25,6 +25,8 @@ Boston, MA 02111-1307, USA.  */\n /* Inline functions for manipulating various data structures defined in\n    tree-flow.h.  See tree-flow.h for documentation.  */\n \n+/* Return the variable annotation for T, which must be a _DECL node.\n+   Return NULL if the variable annotation doesn't already exist.  */\n static inline var_ann_t\n var_ann (tree t)\n {\n@@ -39,6 +41,8 @@ var_ann (tree t)\n   return (var_ann_t) t->common.ann;\n }\n \n+/* Return the variable annotation for T, which must be a _DECL node.\n+   Create the variable annotation if it doesn't exist.  */\n static inline var_ann_t\n get_var_ann (tree var)\n {\n@@ -47,6 +51,8 @@ get_var_ann (tree var)\n }\n \n \n+/* Return the constant annotation for T, which must be a _CST node.\n+   Return NULL if the constant annotation doesn't already exist.  */\n static inline cst_ann_t\n cst_ann (tree t)\n {\n@@ -60,13 +66,18 @@ cst_ann (tree t)\n   return (cst_ann_t) t->common.ann;\n }\n \n+/* Return the constant annotation for T, which must be a _CST node.\n+   Create the constant annotation if it doesn't exist.  */\n static inline cst_ann_t\n get_cst_ann (tree var)\n {\n   cst_ann_t ann = cst_ann (var);\n   return (ann) ? ann : create_cst_ann (var);\n }\n \n+/* Return the expression annotation for T, which must be an expression\n+   node.  Return NULL if the expression annotation doesn't already\n+   exist.  */\n static inline expr_ann_t\n expr_ann (tree t)\n {\n@@ -80,13 +91,17 @@ expr_ann (tree t)\n   return (expr_ann_t) t->common.ann;\n }\n \n+/* Return the expression annotation for T, which must be an expression\n+   node.  Create the expression annotation if it doesn't exist.  */\n static inline expr_ann_t\n-get_expr_ann (tree var)\n+get_expr_ann (tree t)\n {\n-  expr_ann_t ann = expr_ann (var);\n-  return (ann) ? ann : create_expr_ann (var);\n+  expr_ann_t ann = expr_ann (t);\n+  return (ann) ? ann : create_expr_ann (t);\n }\n \n+/* Return the statement annotation for T, which must be a statement\n+   node.  Return NULL if the statement annotation doesn't exist.  */\n static inline stmt_ann_t\n stmt_ann (tree t)\n {\n@@ -98,6 +113,8 @@ stmt_ann (tree t)\n   return (stmt_ann_t) t->common.ann;\n }\n \n+/* Return the statement annotation for T, which must be a statement\n+   node.  Create the statement annotation if it doesn't exist.  */\n static inline stmt_ann_t\n get_stmt_ann (tree stmt)\n {\n@@ -106,33 +123,39 @@ get_stmt_ann (tree stmt)\n }\n \n \n+/* Return the annotation type for annotation ANN.  */\n static inline enum tree_ann_type\n ann_type (tree_ann ann)\n {\n   return ann->common.type;\n }\n \n+/* Return the basic block for statement T.  */\n static inline basic_block\n bb_for_stmt (tree t)\n {\n   stmt_ann_t ann = stmt_ann (t);\n   return ann ? ann->bb : NULL;\n }\n \n+/* Return the may_aliases varray for variable VAR, or NULL if it has\n+   no may aliases.  */\n static inline varray_type\n may_aliases (tree var)\n {\n   var_ann_t ann = var_ann (var);\n   return ann ? ann->may_aliases : NULL;\n }\n \n+/* Return true if VAR has a hidden use, false if it does not.  */\n static inline bool\n has_hidden_use (tree var)\n {\n   var_ann_t ann = var_ann (var);\n   return ann ? ann->has_hidden_use : false;\n }\n \n+/* Set the hidden use flag on VAR.  */ \n static inline void\n set_has_hidden_use (tree var)\n {\n@@ -142,6 +165,8 @@ set_has_hidden_use (tree var)\n   ann->has_hidden_use = 1;\n }\n \n+/* Return the line number for EXPR, or return -1 if we have no line\n+   number information for it.  */\n static inline int\n get_lineno (tree expr)\n {\n@@ -157,6 +182,8 @@ get_lineno (tree expr)\n   return EXPR_LINENO (expr);\n }\n \n+/* Return the file name for EXPR, or return \"???\" if we have no\n+   filename information.  */\n static inline const char *\n get_filename (tree expr)\n {\n@@ -172,6 +199,7 @@ get_filename (tree expr)\n     return \"???\";\n }\n \n+/* Mark statement T as modified.  */\n static inline void\n modify_stmt (tree t)\n {\n@@ -181,6 +209,7 @@ modify_stmt (tree t)\n   ann->modified = 1;\n }\n \n+/* Mark statement T as unmodified.  */\n static inline void\n unmodify_stmt (tree t)\n {\n@@ -190,6 +219,7 @@ unmodify_stmt (tree t)\n   ann->modified = 0;\n }\n \n+/* Return true if T is marked as modified, false otherwise.  */\n static inline bool\n stmt_modified_p (tree t)\n {\n@@ -201,36 +231,48 @@ stmt_modified_p (tree t)\n   return ann ? ann->modified : true;\n }\n \n+/* Return the definitions present in ANN, a statement annotation.\n+   Return NULL if this annotation contains no definitions.  */\n static inline def_optype\n get_def_ops (stmt_ann_t ann)\n {\n   return ann ? ann->def_ops : NULL;\n }\n \n+/* Return the uses present in ANN, a statement annotation.\n+   Return NULL if this annotation contains no uses.  */\n static inline use_optype\n get_use_ops (stmt_ann_t ann)\n {\n   return ann ? ann->use_ops : NULL;\n }\n \n+/* Return the virtual may-defs present in ANN, a statement\n+   annotation.\n+   Return NULL if this annotation contains no virtual may-defs.  */\n static inline v_may_def_optype\n get_v_may_def_ops (stmt_ann_t ann)\n {\n   return ann ? ann->v_may_def_ops : NULL;\n }\n \n+/* Return the virtual uses present in ANN, a statement annotation.\n+   Return NULL if this annotation contains no virtual uses.  */\n static inline vuse_optype\n get_vuse_ops (stmt_ann_t ann)\n {\n   return ann ? ann->vuse_ops : NULL;\n }\n \n+/* Return the virtual must-defs present in ANN, a statement\n+   annotation.  Return NULL if this annotation contains no must-defs.*/\n static inline v_must_def_optype\n get_v_must_def_ops (stmt_ann_t ann)\n {\n   return ann ? ann->v_must_def_ops : NULL;\n }\n \n+/* Return a pointer to the tree that is at INDEX in the USES array.  */\n static inline tree *\n get_use_op_ptr (use_optype uses, unsigned int index)\n {\n@@ -241,6 +283,7 @@ get_use_op_ptr (use_optype uses, unsigned int index)\n   return uses->uses[index];\n }\n \n+/* Return a pointer to the tree that is at INDEX in the DEFS array.  */\n static inline tree *\n get_def_op_ptr (def_optype defs, unsigned int index)\n {\n@@ -251,6 +294,9 @@ get_def_op_ptr (def_optype defs, unsigned int index)\n   return defs->defs[index];\n }\n \n+\n+/* Return a pointer to the tree that is the V_MAY_DEF_RESULT for the V_MAY_DEF\n+   at INDEX in the V_MAY_DEFS array.  */\n static inline tree *\n get_v_may_def_result_ptr(v_may_def_optype v_may_defs, unsigned int index)\n {\n@@ -261,6 +307,8 @@ get_v_may_def_result_ptr(v_may_def_optype v_may_defs, unsigned int index)\n   return &(v_may_defs->v_may_defs[index * 2]);\n }\n \n+/* Return a pointer to the tree that is the V_MAY_DEF_OP for the V_MAY_DEF at\n+   INDEX in the V_MAY_DEFS array.  */\n static inline tree *\n get_v_may_def_op_ptr(v_may_def_optype v_may_defs, unsigned int index)\n {\n@@ -271,6 +319,7 @@ get_v_may_def_op_ptr(v_may_def_optype v_may_defs, unsigned int index)\n   return &(v_may_defs->v_may_defs[index * 2 + 1]);\n }\n \n+/* Return a pointer to the tree that is at INDEX in the VUSES array.  */\n static inline tree *\n get_vuse_op_ptr(vuse_optype vuses, unsigned int index)\n {\n@@ -281,6 +330,8 @@ get_vuse_op_ptr(vuse_optype vuses, unsigned int index)\n   return &(vuses->vuses[index]);\n }\n \n+/* Return a pointer to the tree that is the V_MUST_DEF_OP for the\n+   V_MUST_DEF at INDEX in the V_MUST_DEFS array.  */\n static inline tree *\n get_v_must_def_op_ptr (v_must_def_optype v_must_defs, unsigned int index)\n {\n@@ -291,6 +342,7 @@ get_v_must_def_op_ptr (v_must_def_optype v_must_defs, unsigned int index)\n   return &(v_must_defs->v_must_defs[index]);\n }\n \n+/* Mark the beginning of changes to the SSA operands for STMT.  */\n static inline void\n start_ssa_stmt_operands (tree stmt ATTRIBUTE_UNUSED)\n {\n@@ -299,20 +351,26 @@ start_ssa_stmt_operands (tree stmt ATTRIBUTE_UNUSED)\n #endif\n }\n \n+/* Return the bitmap of addresses taken by STMT, or NULL if it takes\n+   no addresses.  */\n static inline bitmap\n addresses_taken (tree stmt)\n {\n   stmt_ann_t ann = stmt_ann (stmt);\n   return ann ? ann->addresses_taken : NULL;\n }\n \n+/* Return the immediate uses of STMT, or NULL if this information is\n+   not computed.  */\n static dataflow_t\n get_immediate_uses (tree stmt)\n {\n   stmt_ann_t ann = stmt_ann (stmt);\n   return ann ? ann->df : NULL;\n }\n \n+/* Return the number of immediate uses present in the dataflow\n+   information at DF.  */\n static inline int\n num_immediate_uses (dataflow_t df)\n {\n@@ -328,6 +386,7 @@ num_immediate_uses (dataflow_t df)\n   return VARRAY_ACTIVE_SIZE (imm) + 2;\n }\n \n+/* Return the tree that is at NUM in the immediate use DF array.  */\n static inline tree\n immediate_use (dataflow_t df, int num)\n {\n@@ -343,12 +402,15 @@ immediate_use (dataflow_t df, int num)\n   return VARRAY_TREE (df->immediate_uses, num - 2);\n }\n \n+/* Return the basic_block annotation for BB.  */\n static inline bb_ann_t\n bb_ann (basic_block bb)\n {\n   return (bb_ann_t)bb->tree_annotations;\n }\n \n+/* Return the PHI nodes for basic block BB, or NULL if there are no\n+   PHI nodes.  */\n static inline tree\n phi_nodes (basic_block bb)\n {\n@@ -402,6 +464,7 @@ phi_element_for_edge (tree phi, edge e)\n \n /*  -----------------------------------------------------------------------  */\n \n+/* Return true if T is an executable statement.  */\n static inline bool\n is_exec_stmt (tree t)\n {\n@@ -427,6 +490,7 @@ is_label_stmt (tree t)\n   return false;\n }\n \n+/* Return true if we may propagate ORIG into DEST, false otherwise.  */\n static inline bool\n may_propagate_copy (tree dest, tree orig)\n {\n@@ -507,6 +571,7 @@ may_propagate_copy (tree dest, tree orig)\n \t  && !DECL_HARD_REGISTER (SSA_NAME_VAR (dest)));\n }\n \n+/* Set the default definition for VAR to DEF.  */\n static inline void\n set_default_def (tree var, tree def)\n {\n@@ -516,6 +581,8 @@ set_default_def (tree var, tree def)\n   ann->default_def = def;\n }\n \n+/* Return the default definition for variable VAR, or NULL if none\n+   exists.  */\n static inline tree\n default_def (tree var)\n {\n@@ -541,6 +608,8 @@ phi_ssa_name_p (tree t)\n \n /*  -----------------------------------------------------------------------  */\n \n+/* Return a block_stmt_iterator that points to beginning of basic\n+   block BB.  */\n static inline block_stmt_iterator\n bsi_start (basic_block bb)\n {\n@@ -560,6 +629,8 @@ bsi_start (basic_block bb)\n   return bsi;\n }\n \n+/* Return a block statement iterator that points to the end of basic\n+   block BB.  */\n static inline block_stmt_iterator\n bsi_last (basic_block bb)\n {\n@@ -579,50 +650,63 @@ bsi_last (basic_block bb)\n   return bsi;\n }\n \n+/* Return true if block statement iterator I has reached the end of\n+   the basic block.  */\n static inline bool\n bsi_end_p (block_stmt_iterator i)\n {\n   return tsi_end_p (i.tsi);\n }\n \n+/* Modify block statement iterator I so that it is at the next\n+   statement in the basic block.  */\n static inline void\n bsi_next (block_stmt_iterator *i)\n {\n   tsi_next (&i->tsi);\n }\n \n+/* Modify block statement iterator I so that it is at the previous\n+   statement in the basic block.  */\n static inline void\n bsi_prev (block_stmt_iterator *i)\n {\n   tsi_prev (&i->tsi);\n }\n \n+/* Return the statement that block statement iterator I is currently\n+   at.  */\n static inline tree\n bsi_stmt (block_stmt_iterator i)\n {\n   return tsi_stmt (i.tsi);\n }\n \n+/* Return a pointer to the statement that block statement iterator I\n+   is currently at.  */\n static inline tree *\n bsi_stmt_ptr (block_stmt_iterator i)\n {\n   return tsi_stmt_ptr (i.tsi);\n }\n \n+/* Return true if VAR may be aliased.  */\n static inline bool\n may_be_aliased (tree var)\n {\n   return (TREE_ADDRESSABLE (var)\n           || decl_function_context (var) != current_function_decl);\n }\n \n+/* Return true if VAR is a clobbered by function calls.  */\n static inline bool\n is_call_clobbered (tree var)\n {\n   return needs_to_live_in_memory (var)\n \t || bitmap_bit_p (call_clobbered_vars, var_ann (var)->uid);\n }\n \n+/* Mark variable VAR as being clobbered by function calls.  */\n static inline void\n mark_call_clobbered (tree var)\n {\n@@ -632,6 +716,7 @@ mark_call_clobbered (tree var)\n   bitmap_set_bit (call_clobbered_vars, ann->uid);\n }\n \n+/* Mark variable VAR as being non-addressable.  */\n static inline void\n mark_non_addressable (tree var)\n {"}]}