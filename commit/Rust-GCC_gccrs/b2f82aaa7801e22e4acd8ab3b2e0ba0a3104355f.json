{"sha": "b2f82aaa7801e22e4acd8ab3b2e0ba0a3104355f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJmODJhYWE3ODAxZTIyZTRhY2Q4YWIzYjJlMGJhMGEzMTA0MzU1Zg==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-03T23:48:29Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-03T23:48:29Z"}, "message": "trans-array.c (get_rank, [...]): New functions.\n\n\t* trans-array.c (get_rank, get_loop_upper_bound_for_array):\n\tNew functions.\n\t(gfc_trans_array_constructor): Handle multiple loops.\n\nFrom-SVN: r180900", "tree": {"sha": "a771365c337dc577d585a3a91345be33c9a07da6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a771365c337dc577d585a3a91345be33c9a07da6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2f82aaa7801e22e4acd8ab3b2e0ba0a3104355f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2f82aaa7801e22e4acd8ab3b2e0ba0a3104355f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2f82aaa7801e22e4acd8ab3b2e0ba0a3104355f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2f82aaa7801e22e4acd8ab3b2e0ba0a3104355f/comments", "author": null, "committer": null, "parents": [{"sha": "4616ef9b8517396fc1b4edd6d1fcdbe3705c0892", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4616ef9b8517396fc1b4edd6d1fcdbe3705c0892", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4616ef9b8517396fc1b4edd6d1fcdbe3705c0892"}], "stats": {"total": 53, "additions": 46, "deletions": 7}, "files": [{"sha": "091ae6e273e120bdd85e017930c8eb443377eaa9", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2f82aaa7801e22e4acd8ab3b2e0ba0a3104355f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2f82aaa7801e22e4acd8ab3b2e0ba0a3104355f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b2f82aaa7801e22e4acd8ab3b2e0ba0a3104355f", "patch": "@@ -1,3 +1,9 @@\n+2011-11-03  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans-array.c (get_rank, get_loop_upper_bound_for_array):\n+\tNew functions.\n+\t(gfc_trans_array_constructor): Handle multiple loops.\n+\n 2011-11-03  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans.h (struct gfc_loopinfo): New field parent."}, {"sha": "083ce5c77ee5a97219710a7274575d03bd82db37", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2f82aaa7801e22e4acd8ab3b2e0ba0a3104355f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2f82aaa7801e22e4acd8ab3b2e0ba0a3104355f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=b2f82aaa7801e22e4acd8ab3b2e0ba0a3104355f", "patch": "@@ -2034,6 +2034,19 @@ trans_constant_array_constructor (gfc_ss * ss, tree type)\n }\n \n \n+static int\n+get_rank (gfc_loopinfo *loop)\n+{\n+  int rank;\n+\n+  rank = 0;\n+  for (; loop; loop = loop->parent)\n+    rank += loop->dimen;\n+\n+  return rank;\n+}\n+\n+\n /* Helper routine of gfc_trans_array_constructor to determine if the\n    bounds of the loop specified by LOOP are constant and simple enough\n    to use with trans_constant_array_constructor.  Returns the\n@@ -2072,6 +2085,23 @@ constant_array_constructor_loop_size (gfc_loopinfo * loop)\n }\n \n \n+static tree *\n+get_loop_upper_bound_for_array (gfc_ss *array, int array_dim)\n+{\n+  gfc_ss *ss;\n+  int n;\n+\n+  gcc_assert (array->nested_ss == NULL);\n+\n+  for (ss = array; ss; ss = ss->parent)\n+    for (n = 0; n < ss->loop->dimen; n++)\n+      if (array_dim == get_array_ref_dim_for_loop_dim (ss, n))\n+\treturn &(ss->loop->to[n]);\n+\n+  gcc_unreachable ();\n+}\n+\n+\n /* Array constructors are handled by constructing a temporary, then using that\n    within the scalarization loop.  This is not optimal, but seems by far the\n    simplest method.  */\n@@ -2085,6 +2115,7 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n   tree desc;\n   tree type;\n   tree tmp;\n+  tree *loop_ubound0;\n   bool dynamic;\n   bool old_first_len, old_typespec_chararray_ctor;\n   tree old_first_len_val;\n@@ -2114,7 +2145,7 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n       first_len = true;\n     }\n \n-  gcc_assert (ss->dimen == loop->dimen);\n+  gcc_assert (ss->dimen == ss->loop->dimen);\n \n   c = expr->value.constructor;\n   if (expr->ts.type == BT_CHARACTER)\n@@ -2157,7 +2188,9 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n   /* See if the constructor determines the loop bounds.  */\n   dynamic = false;\n \n-  if (expr->shape && loop->dimen > 1 && loop->to[0] == NULL_TREE)\n+  loop_ubound0 = get_loop_upper_bound_for_array (ss, 0);\n+\n+  if (expr->shape && get_rank (loop) > 1 && *loop_ubound0 == NULL_TREE)\n     {\n       /* We have a multidimensional parameter.  */\n       for (s = ss; s; s = s->parent)\n@@ -2176,7 +2209,7 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n \t}\n     }\n \n-  if (loop->to[0] == NULL_TREE)\n+  if (*loop_ubound0 == NULL_TREE)\n     {\n       mpz_t size;\n \n@@ -2210,7 +2243,7 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n \t}\n     }\n \n-  if (TREE_CODE (loop->to[0]) == VAR_DECL)\n+  if (TREE_CODE (*loop_ubound0) == VAR_DECL)\n     dynamic = true;\n \n   gfc_trans_create_temp_array (&loop->pre, &loop->post, ss, type, NULL_TREE,\n@@ -2233,10 +2266,10 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n \t\t\t     offsetvar, gfc_index_one_node);\n       tmp = gfc_evaluate_now (tmp, &loop->pre);\n       gfc_conv_descriptor_ubound_set (&loop->pre, desc, gfc_rank_cst[0], tmp);\n-      if (loop->to[0] && TREE_CODE (loop->to[0]) == VAR_DECL)\n-\tgfc_add_modify (&loop->pre, loop->to[0], tmp);\n+      if (*loop_ubound0 && TREE_CODE (*loop_ubound0) == VAR_DECL)\n+\tgfc_add_modify (&loop->pre, *loop_ubound0, tmp);\n       else\n-\tloop->to[0] = tmp;\n+\t*loop_ubound0 = tmp;\n     }\n \n   if (TREE_USED (offsetvar))"}]}