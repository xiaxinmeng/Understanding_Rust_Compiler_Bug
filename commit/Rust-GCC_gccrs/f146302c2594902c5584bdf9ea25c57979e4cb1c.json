{"sha": "f146302c2594902c5584bdf9ea25c57979e4cb1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE0NjMwMmMyNTk0OTAyYzU1ODRiZGY5ZWEyNWM1Nzk3OWU0Y2IxYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-04-26T09:59:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-04-26T09:59:24Z"}, "message": "[multiple changes]\n\n2012-04-26  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch5.adb (Check_Unreachable_Code): Skip past pragmas.\n\n2012-04-26  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* s-finroo.ads: Remove with clause for\n\tAda.Streams. Type Root_Controlled is now abstract tagged null\n\trecord. Remove internal package Stream_Attributes. Root_Controlled\n\tdoesn't need stream attribute redeclaration and avoids the\n\tdependency on streams.\n\n2012-04-26  Tristan Gingold  <gingold@adacore.com>\n\n\t* adaint.c (to_host_path_spec): Removed (unused).\n\tMinor reformatting.\n\n2012-04-26  Steve Baird  <baird@adacore.com>\n\n\t* gnat_rm.texi Improve description of Valid_Scalars attribute.\n\n2012-04-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Can_Override_Operator): If the formal is a\n\tgeneric type the operator cannot be overriding.\n\n2012-04-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch8.adb (Spec_Reloaded_For_Body): Check whether the type\n\tis declared in a package specification, and current unit is the\n\tcorresponding package body. The use clauses themselves may be\n\twithin a nested package.\n\n2012-04-26  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch2.adb (Param_Entity): Take into account the case where\n\tthe type of the entry parameter has a representation clause.\n\nFrom-SVN: r186870", "tree": {"sha": "e1b32d8e1671c72e0a4bafe5df74c859a9f1e2b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1b32d8e1671c72e0a4bafe5df74c859a9f1e2b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f146302c2594902c5584bdf9ea25c57979e4cb1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f146302c2594902c5584bdf9ea25c57979e4cb1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f146302c2594902c5584bdf9ea25c57979e4cb1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f146302c2594902c5584bdf9ea25c57979e4cb1c/comments", "author": null, "committer": null, "parents": [{"sha": "7a6de2e28f76b03283097d1f2c36511cd7fe7dcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a6de2e28f76b03283097d1f2c36511cd7fe7dcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a6de2e28f76b03283097d1f2c36511cd7fe7dcc"}], "stats": {"total": 373, "additions": 211, "deletions": 162}, "files": [{"sha": "db2dc69e67422a6a314fd412c9cde2cd7db161be", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f146302c2594902c5584bdf9ea25c57979e4cb1c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f146302c2594902c5584bdf9ea25c57979e4cb1c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f146302c2594902c5584bdf9ea25c57979e4cb1c", "patch": "@@ -1,3 +1,41 @@\n+2012-04-26  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch5.adb (Check_Unreachable_Code): Skip past pragmas.\n+\n+2012-04-26  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* s-finroo.ads: Remove with clause for\n+\tAda.Streams. Type Root_Controlled is now abstract tagged null\n+\trecord. Remove internal package Stream_Attributes. Root_Controlled\n+\tdoesn't need stream attribute redeclaration and avoids the\n+\tdependency on streams.\n+\n+2012-04-26  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* adaint.c (to_host_path_spec): Removed (unused).\n+\tMinor reformatting.\n+\n+2012-04-26  Steve Baird  <baird@adacore.com>\n+\n+\t* gnat_rm.texi Improve description of Valid_Scalars attribute.\n+\n+2012-04-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Can_Override_Operator): If the formal is a\n+\tgeneric type the operator cannot be overriding.\n+\n+2012-04-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch8.adb (Spec_Reloaded_For_Body): Check whether the type\n+\tis declared in a package specification, and current unit is the\n+\tcorresponding package body. The use clauses themselves may be\n+\twithin a nested package.\n+\n+2012-04-26  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch2.adb (Param_Entity): Take into account the case where\n+\tthe type of the entry parameter has a representation clause.\n+\n 2012-04-26  Ed Schonberg  <schonberg@adacore.com>\n \n \t* gnat_ugn.texi: Tweak dimensionality doc."}, {"sha": "34136ff914db341209082a7002d050da689b6c47", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 112, "deletions": 129, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f146302c2594902c5584bdf9ea25c57979e4cb1c/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f146302c2594902c5584bdf9ea25c57979e4cb1c/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=f146302c2594902c5584bdf9ea25c57979e4cb1c", "patch": "@@ -3086,11 +3086,12 @@ __gnat_to_canonical_file_list_free ()\n char *\n __gnat_translate_vms (char *src)\n {\n-  static char retbuf [NAM$C_MAXRSS+1];\n+  static char retbuf [NAM$C_MAXRSS + 1];\n   char *srcendpos, *pos1, *pos2, *retpos;\n   int disp, path_present = 0;\n \n-  if (!src) return NULL;\n+  if (!src)\n+    return NULL;\n \n   srcendpos = strchr (src, '\\0');\n   retpos = retbuf;\n@@ -3099,112 +3100,132 @@ __gnat_translate_vms (char *src)\n   pos1 = src;\n   pos2 = strchr (pos1, ':');\n \n-  if (pos2 && (pos2 < srcendpos) && (*(pos2 + 1) == ':')) {\n-    /* There is a node name. \"node_name::\" becomes \"node_name!\" */\n-    disp = pos2 - pos1;\n-    strncpy (retbuf, pos1, disp);\n-    retpos [disp] = '!';\n-    retpos = retpos + disp + 1;\n-    pos1 = pos2 + 2;\n-    pos2 = strchr (pos1, ':');\n-  }\n+  if (pos2 && (pos2 < srcendpos) && (*(pos2 + 1) == ':'))\n+    {\n+      /* There is a node name. \"node_name::\" becomes \"node_name!\" */\n+      disp = pos2 - pos1;\n+      strncpy (retbuf, pos1, disp);\n+      retpos [disp] = '!';\n+      retpos = retpos + disp + 1;\n+      pos1 = pos2 + 2;\n+      pos2 = strchr (pos1, ':');\n+    }\n \n-  if (pos2) {\n-    /* There is a device name. \"dev_name:\" becomes \"/dev_name/\" */\n-    *(retpos++) = '/';\n-    disp = pos2 - pos1;\n-    strncpy (retpos, pos1, disp);\n-    retpos = retpos + disp;\n-    pos1 = pos2 + 1;\n-    *(retpos++) = '/';\n-  }\n+  if (pos2)\n+    {\n+      /* There is a device name. \"dev_name:\" becomes \"/dev_name/\" */\n+      *(retpos++) = '/';\n+      disp = pos2 - pos1;\n+      strncpy (retpos, pos1, disp);\n+      retpos = retpos + disp;\n+      pos1 = pos2 + 1;\n+      *(retpos++) = '/';\n+    }\n   else\n     /* No explicit device; we must look ahead and prepend /sys$disk/ if\n        the path is absolute */\n     if ((*pos1 == '[' || *pos1 == '<') && (pos1 < srcendpos)\n-        && !strchr (\".-]>\", *(pos1 + 1))) {\n-      strncpy (retpos, \"/sys$disk/\", 10);\n-      retpos += 10;\n-    }\n+        && !strchr (\".-]>\", *(pos1 + 1)))\n+      {\n+        strncpy (retpos, \"/sys$disk/\", 10);\n+        retpos += 10;\n+      }\n \n   /* Process the path part */\n-  while (*pos1 == '[' || *pos1 == '<') {\n-    path_present++;\n-    pos1++;\n-    if (*pos1 == ']' || *pos1 == '>') {\n-      /* Special case, [] translates to '.' */\n-      *(retpos++) = '.';\n+  while (*pos1 == '[' || *pos1 == '<')\n+    {\n+      path_present++;\n       pos1++;\n-    }\n-    else {\n-      /* '[000000' means root dir. It can be present in the middle of\n-         the path due to expansion of logical devices, in which case\n-         we skip it */\n-      if (!strncmp (pos1, \"000000\", 6) && path_present > 1 &&\n-         (*(pos1 + 6) == ']' || *(pos1 + 6) == '>' || *(pos1 + 6) == '.')) {\n-          pos1 += 6;\n-          if (*pos1 == '.') pos1++;\n+      if (*pos1 == ']' || *pos1 == '>')\n+        {\n+          /* Special case, [] translates to '.' */\n+          *(retpos++) = '.';\n+          pos1++;\n         }\n-      else if (*pos1 == '.') {\n-        /* Relative path */\n-        *(retpos++) = '.';\n-      }\n-\n-      /* There is a qualified path */\n-      while (*pos1 && *pos1 != ']' && *pos1 != '>') {\n-        switch (*pos1) {\n-          case '.':\n-            /* '.' is used to separate directories. Replace it with '/' but\n-               only if there isn't already '/' just before */\n-            if (*(retpos - 1) != '/') *(retpos++) = '/';\n-            pos1++;\n-            if (pos1 + 1 < srcendpos && *pos1 == '.' && *(pos1 + 1) == '.') {\n-              /* ellipsis refers to entire subtree; replace with '**' */\n-              *(retpos++) = '*'; *(retpos++) = '*'; *(retpos++) = '/';\n-              pos1 += 2;\n+      else\n+        {\n+          /* '[000000' means root dir. It can be present in the middle of\n+             the path due to expansion of logical devices, in which case\n+             we skip it */\n+          if (!strncmp (pos1, \"000000\", 6) && path_present > 1 &&\n+              (*(pos1 + 6) == ']' || *(pos1 + 6) == '>' || *(pos1 + 6) == '.'))\n+            {\n+              pos1 += 6;\n+              if (*pos1 == '.') pos1++;\n             }\n-            break;\n-          case '-' :\n-            /* When after '.' '[' '<' is equivalent to Unix \"..\" but there\n-            may be several in a row */\n-            if (*(pos1 - 1) == '.' || *(pos1 - 1) == '[' ||\n-                *(pos1 - 1) == '<') {\n-              while (*pos1 == '-') {\n-                pos1++;\n-                *(retpos++) = '.'; *(retpos++) = '.'; *(retpos++) = '/';\n-              }\n-              retpos--;\n-              break;\n+          else if (*pos1 == '.')\n+            {\n+              /* Relative path */\n+              *(retpos++) = '.';\n+            }\n+\n+          /* There is a qualified path */\n+          while (*pos1 && *pos1 != ']' && *pos1 != '>')\n+            {\n+              switch (*pos1)\n+                {\n+                case '.':\n+                  /* '.' is used to separate directories. Replace it with '/' but\n+                     only if there isn't already '/' just before */\n+                  if (*(retpos - 1) != '/')\n+                    *(retpos++) = '/';\n+                  pos1++;\n+                  if (pos1 + 1 < srcendpos && *pos1 == '.' && *(pos1 + 1) == '.')\n+                    {\n+                      /* ellipsis refers to entire subtree; replace with '**' */\n+                      *(retpos++) = '*';\n+                      *(retpos++) = '*';\n+                      *(retpos++) = '/';\n+                      pos1 += 2;\n+                    }\n+                  break;\n+                case '-' :\n+                  /* When after '.' '[' '<' is equivalent to Unix \"..\" but there\n+                     may be several in a row */\n+                  if (*(pos1 - 1) == '.' || *(pos1 - 1) == '[' ||\n+                      *(pos1 - 1) == '<')\n+                    {\n+                      while (*pos1 == '-')\n+                        {\n+                          pos1++;\n+                          *(retpos++) = '.';\n+                          *(retpos++) = '.';\n+                          *(retpos++) = '/';\n+                        }\n+                      retpos--;\n+                      break;\n+                    }\n+                  /* otherwise fall through to default */\n+                default:\n+                  *(retpos++) = *(pos1++);\n+                }\n             }\n-            /* otherwise fall through to default */\n-          default:\n-            *(retpos++) = *(pos1++);\n+          pos1++;\n         }\n-      }\n-      pos1++;\n     }\n-  }\n \n-  if (pos1 < srcendpos) {\n-    /* Now add the actual file name, until the version suffix if any */\n-    if (path_present) *(retpos++) = '/';\n-    pos2 = strchr (pos1, ';');\n-    disp = pos2? (pos2 - pos1) : (srcendpos - pos1);\n-    strncpy (retpos, pos1, disp);\n-    retpos += disp;\n-    if (pos2 && pos2 < srcendpos) {\n-      /* There is a non-empty version suffix. \";<ver>\" becomes \".<ver>\" */\n-      *retpos++ = '.';\n-      disp = srcendpos - pos2 - 1;\n-      strncpy (retpos, pos2 + 1, disp);\n+  if (pos1 < srcendpos)\n+    {\n+      /* Now add the actual file name, until the version suffix if any */\n+      if (path_present)\n+        *(retpos++) = '/';\n+      pos2 = strchr (pos1, ';');\n+      disp = pos2? (pos2 - pos1) : (srcendpos - pos1);\n+      strncpy (retpos, pos1, disp);\n       retpos += disp;\n+      if (pos2 && pos2 < srcendpos)\n+        {\n+          /* There is a non-empty version suffix. \";<ver>\" becomes \".<ver>\" */\n+          *retpos++ = '.';\n+          disp = srcendpos - pos2 - 1;\n+          strncpy (retpos, pos2 + 1, disp);\n+          retpos += disp;\n+        }\n     }\n-  }\n \n   *retpos = '\\0';\n \n   return retbuf;\n-\n }\n \n /* Translate a VMS syntax directory specification in to Unix syntax.  If\n@@ -3355,52 +3376,13 @@ __gnat_to_canonical_path_spec (char *pathspec)\n static char filename_buff [MAXPATH];\n \n static int\n-translate_unix (char *name, int type)\n+translate_unix (char *name, int type ATTRIBUTE_UNUSED)\n {\n   strncpy (filename_buff, name, MAXPATH);\n   filename_buff [MAXPATH - 1] = (char) 0;\n   return 0;\n }\n \n-/* Translate a Unix syntax path spec into a VMS style (comma separated list of\n-   directories.  */\n-\n-static char *\n-to_host_path_spec (char *pathspec)\n-{\n-  char *curr, *next, buff [MAXPATH];\n-\n-  if (pathspec == 0)\n-    return pathspec;\n-\n-  /* Can't very well test for colons, since that's the Unix separator!  */\n-  if (strchr (pathspec, ']') || strchr (pathspec, ','))\n-    return pathspec;\n-\n-  new_host_pathspec[0] = 0;\n-  curr = pathspec;\n-\n-  for (;;)\n-    {\n-      next = strchr (curr, ':');\n-      if (next == 0)\n-        next = strchr (curr, 0);\n-\n-      strncpy (buff, curr, next - curr);\n-      buff[next - curr] = 0;\n-\n-      strncat (new_host_pathspec, __gnat_to_host_dir_spec (buff, 0), MAXPATH);\n-      if (*next == 0)\n-        break;\n-      strncat (new_host_pathspec, \",\", MAXPATH);\n-      curr = next + 1;\n-    }\n-\n-  new_host_pathspec [MAXPATH - 1] = (char) 0;\n-\n-  return new_host_pathspec;\n-}\n-\n /* Translate a Unix syntax directory specification into VMS syntax.  The\n    PREFIXFLAG has no effect, but is kept for symmetry with\n    to_canonical_dir_spec.  If indicators of VMS syntax found, return input\n@@ -3592,7 +3574,8 @@ char __gnat_environment_char = '$';\n    Returns 0 if operation was successful and -1 in case of error. */\n \n int\n-__gnat_copy_attribs (char *from, char *to, int mode)\n+__gnat_copy_attribs (char *from ATTRIBUTE_UNUSED, char *to ATTRIBUTE_UNUSED,\n+                     int mode ATTRIBUTE_UNUSED)\n {\n #if defined (VMS) || (defined (__vxworks) && _WRS_VXWORKS_MAJOR < 6) || \\\n   defined (__nucleus__)"}, {"sha": "2f19d20996bf4ded99c9bbbefb31e6ef11a30b2c", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f146302c2594902c5584bdf9ea25c57979e4cb1c/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f146302c2594902c5584bdf9ea25c57979e4cb1c/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=f146302c2594902c5584bdf9ea25c57979e4cb1c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -723,6 +723,8 @@ package body Exp_Ch2 is\n    --    typ!(recobj).rec.all'Constrained\n \n    --  where rec is a selector whose Entry_Formal link points to the formal\n+   --  If the type of the entry parameter has a representation clause, then an\n+   --  extra temp is involved (see below).\n    --  For a formal of a task entity, the formal is rewritten as a local\n    --  renaming.\n \n@@ -760,10 +762,30 @@ package body Exp_Ch2 is\n       else\n          if Nkind (N) = N_Explicit_Dereference then\n             declare\n-               P : constant Node_Id := Prefix (N);\n-               S : Node_Id;\n+               P    : Node_Id := Prefix (N);\n+               S    : Node_Id;\n+               E    : Entity_Id;\n+               Decl : Node_Id;\n \n             begin\n+               --  If the type of an entry parameter has a representation\n+               --  clause, then the prefix is not a selected component, but\n+               --  instead a reference to a temp pointing at the selected\n+               --  component. In this case, set P to be the initial value of\n+               --  that temp.\n+\n+               if Nkind (P) = N_Identifier then\n+                  E := Entity (P);\n+\n+                  if Ekind (E) = E_Constant then\n+                     Decl := Parent (E);\n+\n+                     if Nkind (Decl) = N_Object_Declaration then\n+                        P := Expression (Decl);\n+                     end if;\n+                  end if;\n+               end if;\n+\n                if Nkind (P) = N_Selected_Component then\n                   S := Selector_Name (P);\n "}, {"sha": "88a30f9fe5d89b686f5c9c5c8e7bf5499f0ecc9c", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f146302c2594902c5584bdf9ea25c57979e4cb1c/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f146302c2594902c5584bdf9ea25c57979e4cb1c/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=f146302c2594902c5584bdf9ea25c57979e4cb1c", "patch": "@@ -6998,18 +6998,22 @@ caller.\n @findex Valid_Scalars\n @noindent\n The @code{'Valid_Scalars} attribute is intended to make it easier to\n-check the validity of scalar subcomponents of composite objects.  It\n-is defined for any prefix @code{X} that denotes a scalar or composite\n-object (after any implicit dereference), that is not of classwide type\n-or of a formal generic type with an unknown discriminant.\n-@code{X'Valid_Scalars} yields True if and only if @code{X'Valid}\n-yields True, if @code{X} is a scalar object, or @code{Y'Valid} yields\n-True for every scalar subcomponent @code{Y} of @code{X}, if @code{X}\n-is a composite object. If computing the value of\n-@code{X'Valid_Scalars} involves evaluations of subtype predicates, it\n-is unspecified in which order these evaluations take place, or if they\n-take place at all in case the result is False. The value of this\n-attribute is of the predefined type Boolean.\n+check the validity of scalar subcomponents of composite objects. It\n+is defined for any prefix @code{X} that denotes an object.\n+The value of this attribute is of the predefined type Boolean.\n+@code{X'Valid_Scalars} yields True if and only if evaluation of\n+@code{P'Valid} yields True for every scalar part P of X or if X has\n+no scalar parts. It is not specified in what order the scalar parts\n+are checked, nor whether any more are checked after any one of them\n+is determined to be invalid. If the prefix @code{X} is of a class-wide\n+type @code{T'Class} (where @code{T} is the associated specific type),\n+or if the prefix @code{X} is of a specific tagged type @code{T}, then\n+only the scalar parts of components of @code{T} are traversed; in other\n+words, components of extensions of @code{T} are not traversed even if\n+@code{T'Class (X)'Tag /= T'Tag} . The compiler will issue a warning if it can\n+be determined at compile time that the prefix of the attribute has no\n+scalar parts (e.g., if the prefix is of an access type, an interface type,\n+an undiscriminated task type, or an undiscriminated protected type).\n \n @node VADS_Size\n @unnumberedsec VADS_Size"}, {"sha": "0e1a16f933e6802672dcfe4d0b1d898da90b3e66", "filename": "gcc/ada/s-finroo.ads", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f146302c2594902c5584bdf9ea25c57979e4cb1c/gcc%2Fada%2Fs-finroo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f146302c2594902c5584bdf9ea25c57979e4cb1c/gcc%2Fada%2Fs-finroo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finroo.ads?ref=f146302c2594902c5584bdf9ea25c57979e4cb1c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,30 +31,16 @@\n \n --  This unit provides the basic support for controlled (finalizable) types\n \n-with Ada.Streams;\n-\n package System.Finalization_Root is\n    pragma Preelaborate;\n \n    --  The base for types Controlled and Limited_Controlled declared in Ada.\n    --  Finalization.\n \n-   type Root_Controlled is tagged null record;\n+   type Root_Controlled is abstract tagged null record;\n \n    procedure Adjust     (Object : in out Root_Controlled);\n    procedure Finalize   (Object : in out Root_Controlled);\n    procedure Initialize (Object : in out Root_Controlled);\n \n-   package Stream_Attributes is\n-      procedure Read\n-        (Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n-         Item   : out Root_Controlled) is null;\n-\n-      procedure Write\n-        (Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n-         Item   : Root_Controlled) is null;\n-   end Stream_Attributes;\n-\n-   for Root_Controlled'Read  use Stream_Attributes.Read;\n-   for Root_Controlled'Write use Stream_Attributes.Write;\n end System.Finalization_Root;"}, {"sha": "3d96591967aac5ffdd19e2828ef90053a3b06119", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f146302c2594902c5584bdf9ea25c57979e4cb1c/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f146302c2594902c5584bdf9ea25c57979e4cb1c/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=f146302c2594902c5584bdf9ea25c57979e4cb1c", "patch": "@@ -2767,6 +2767,12 @@ package body Sem_Ch5 is\n          begin\n             Nxt := Original_Node (Next (N));\n \n+            --  Skip past pragmas\n+\n+            while Nkind (Nxt) = N_Pragma loop\n+               Nxt := Original_Node (Next (Nxt));\n+            end loop;\n+\n             --  If a label follows us, then we never have dead code, since\n             --  someone could branch to the label, so we just ignore it, unless\n             --  we are in formal mode where goto statements are not allowed."}, {"sha": "e8aa81c307c9e30934e9bd2af7ddad428a9faf7e", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f146302c2594902c5584bdf9ea25c57979e4cb1c/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f146302c2594902c5584bdf9ea25c57979e4cb1c/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=f146302c2594902c5584bdf9ea25c57979e4cb1c", "patch": "@@ -7383,14 +7383,18 @@ package body Sem_Ch6 is\n \n    function Can_Override_Operator (Subp : Entity_Id) return Boolean is\n       Typ : Entity_Id;\n+\n    begin\n       if Nkind (Subp) /= N_Defining_Operator_Symbol then\n          return False;\n \n       else\n          Typ := Base_Type (Etype (First_Formal (Subp)));\n \n+         --  Check explicitly that the operation is a primitive of the type\n+\n          return Operator_Matches_Spec (Subp, Subp)\n+           and then not Is_Generic_Type (Typ)\n            and then Scope (Subp) = Scope (Typ)\n            and then not Is_Class_Wide_Type (Typ);\n       end if;"}, {"sha": "f31110b088a3b7e96bb1afc81c9d1d2cf20cc1a9", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f146302c2594902c5584bdf9ea25c57979e4cb1c/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f146302c2594902c5584bdf9ea25c57979e4cb1c/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=f146302c2594902c5584bdf9ea25c57979e4cb1c", "patch": "@@ -7963,10 +7963,16 @@ package body Sem_Ch8 is\n                Spec : constant Node_Id :=\n                         Parent (List_Containing (Parent (Id)));\n             begin\n+\n+               --  Check whether type is declared in a package specification,\n+               --  and current unit is the corresponding package body. The\n+               --  use clauses themselves may be within a nested package.\n+\n                return\n                  Nkind (Spec) = N_Package_Specification\n-                   and then Corresponding_Body (Parent (Spec)) =\n-                              Cunit_Entity (Current_Sem_Unit);\n+                 and then\n+                   In_Same_Source_Unit (Corresponding_Body (Parent (Spec)),\n+                              Cunit_Entity (Current_Sem_Unit));\n             end;\n          end if;\n "}]}