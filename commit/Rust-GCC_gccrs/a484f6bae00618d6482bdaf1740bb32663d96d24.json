{"sha": "a484f6bae00618d6482bdaf1740bb32663d96d24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ4NGY2YmFlMDA2MThkNjQ4MmJkYWYxNzQwYmIzMjY2M2Q5NmQyNA==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2011-08-19T14:12:32Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@gcc.gnu.org", "date": "2011-08-19T14:12:32Z"}, "message": "expr.c (expand_expr_real_2): Use widening_optab_handler.\n\n2011-08-19  Andrew Stubbs  <ams@codesourcery.com>\n\n\tgcc/\n\t* expr.c (expand_expr_real_2): Use widening_optab_handler.\n\t* genopinit.c (optabs): Use set_widening_optab_handler for $N.\n\t(gen_insn): $N now means $a must be wider than $b, not consecutive.\n\t* optabs.c (widened_mode): New function.\n\t(expand_widen_pattern_expr): Use widening_optab_handler.\n\t(expand_binop_directly): Likewise.\n\t(expand_binop): Likewise.\n\t* optabs.h (widening_optab_handlers): New struct.\n\t(optab_d): New member, 'widening'.\n\t(widening_optab_handler): New function.\n\t(set_widening_optab_handler): New function.\n\t* tree-ssa-math-opts.c (convert_mult_to_widen): Use\n\twidening_optab_handler.\n\t(convert_plusminus_to_widen): Likewise.\n\nFrom-SVN: r177901", "tree": {"sha": "79e47d7fd79f8a22d857e9e104cac40825bc24b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79e47d7fd79f8a22d857e9e104cac40825bc24b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a484f6bae00618d6482bdaf1740bb32663d96d24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a484f6bae00618d6482bdaf1740bb32663d96d24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a484f6bae00618d6482bdaf1740bb32663d96d24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a484f6bae00618d6482bdaf1740bb32663d96d24/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c4b3a0a0b9566dcd63e4a35ddcafa4b93055aa96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4b3a0a0b9566dcd63e4a35ddcafa4b93055aa96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4b3a0a0b9566dcd63e4a35ddcafa4b93055aa96"}], "stats": {"total": 185, "additions": 146, "deletions": 39}, "files": [{"sha": "435c19adcc6f89d4533fb0ca3a41971f03ca6b33", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a484f6bae00618d6482bdaf1740bb32663d96d24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a484f6bae00618d6482bdaf1740bb32663d96d24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a484f6bae00618d6482bdaf1740bb32663d96d24", "patch": "@@ -1,3 +1,20 @@\n+2011-08-19  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* expr.c (expand_expr_real_2): Use widening_optab_handler.\n+\t* genopinit.c (optabs): Use set_widening_optab_handler for $N.\n+\t(gen_insn): $N now means $a must be wider than $b, not consecutive.\n+\t* optabs.c (widened_mode): New function.\n+\t(expand_widen_pattern_expr): Use widening_optab_handler.\n+\t(expand_binop_directly): Likewise.\n+\t(expand_binop): Likewise.\n+\t* optabs.h (widening_optab_handlers): New struct.\n+\t(optab_d): New member, 'widening'.\n+\t(widening_optab_handler): New function.\n+\t(set_widening_optab_handler): New function.\n+\t* tree-ssa-math-opts.c (convert_mult_to_widen): Use\n+\twidening_optab_handler.\n+\t(convert_plusminus_to_widen): Likewise.\n+\n 2011-08-19  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-decl.c (grokdeclarator): Diagnose _Noreturn for non-C1X if"}, {"sha": "7e611bd06464ff38a41a10581e2cf0da66ab0f51", "filename": "gcc/expr.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a484f6bae00618d6482bdaf1740bb32663d96d24/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a484f6bae00618d6482bdaf1740bb32663d96d24/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a484f6bae00618d6482bdaf1740bb32663d96d24", "patch": "@@ -8005,7 +8005,8 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t  this_optab = usmul_widen_optab;\n \t  if (mode == GET_MODE_2XWIDER_MODE (innermode))\n \t    {\n-\t      if (optab_handler (this_optab, mode) != CODE_FOR_nothing)\n+\t      if (widening_optab_handler (this_optab, mode, innermode)\n+\t\t    != CODE_FOR_nothing)\n \t\t{\n \t\t  if (TYPE_UNSIGNED (TREE_TYPE (treeop0)))\n \t\t    expand_operands (treeop0, treeop1, NULL_RTX, &op0, &op1,\n@@ -8032,15 +8033,17 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t  if (mode == GET_MODE_2XWIDER_MODE (innermode)\n \t      && TREE_CODE (treeop0) != INTEGER_CST)\n \t    {\n-\t      if (optab_handler (this_optab, mode) != CODE_FOR_nothing)\n+\t      if (widening_optab_handler (this_optab, mode, innermode)\n+\t\t    != CODE_FOR_nothing)\n \t\t{\n \t\t  expand_operands (treeop0, treeop1, NULL_RTX, &op0, &op1,\n \t\t\t\t   EXPAND_NORMAL);\n \t\t  temp = expand_widening_mult (mode, op0, op1, target,\n \t\t\t\t\t       unsignedp, this_optab);\n \t\t  return REDUCE_BIT_FIELD (temp);\n \t\t}\n-\t      if (optab_handler (other_optab, mode) != CODE_FOR_nothing\n+\t      if (widening_optab_handler (other_optab, mode, innermode)\n+\t\t    != CODE_FOR_nothing\n \t\t  && innermode == word_mode)\n \t\t{\n \t\t  rtx htem, hipart;"}, {"sha": "4855e5ae3cd26ca3290155c9bda769a0cdaa315b", "filename": "gcc/genopinit.c", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a484f6bae00618d6482bdaf1740bb32663d96d24/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a484f6bae00618d6482bdaf1740bb32663d96d24/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=a484f6bae00618d6482bdaf1740bb32663d96d24", "patch": "@@ -46,10 +46,12 @@ along with GCC; see the file COPYING3.  If not see\n    used.  $A and $B are replaced with the full name of the mode; $a and $b\n    are replaced with the short form of the name, as above.\n \n-   If $N is present in the pattern, it means the two modes must be consecutive\n-   widths in the same mode class (e.g, QImode and HImode).  $I means that\n-   only full integer modes should be considered for the next mode, and $F\n-   means that only float modes should be considered.\n+   If $N is present in the pattern, it means the two modes must be in\n+   the same mode class, and $b must be greater than $a (e.g, QImode\n+   and HImode).\n+\n+   $I means that only full integer modes should be considered for the\n+   next mode, and $F means that only float modes should be considered.\n    $P means that both full and partial integer modes should be considered.\n    $Q means that only fixed-point modes should be considered.\n \n@@ -99,17 +101,17 @@ static const char * const optabs[] =\n   \"set_optab_handler (smulv_optab, $A, CODE_FOR_$(mulv$I$a3$))\",\n   \"set_optab_handler (umul_highpart_optab, $A, CODE_FOR_$(umul$a3_highpart$))\",\n   \"set_optab_handler (smul_highpart_optab, $A, CODE_FOR_$(smul$a3_highpart$))\",\n-  \"set_optab_handler (smul_widen_optab, $B, CODE_FOR_$(mul$a$b3$)$N)\",\n-  \"set_optab_handler (umul_widen_optab, $B, CODE_FOR_$(umul$a$b3$)$N)\",\n-  \"set_optab_handler (usmul_widen_optab, $B, CODE_FOR_$(usmul$a$b3$)$N)\",\n-  \"set_optab_handler (smadd_widen_optab, $B, CODE_FOR_$(madd$a$b4$)$N)\",\n-  \"set_optab_handler (umadd_widen_optab, $B, CODE_FOR_$(umadd$a$b4$)$N)\",\n-  \"set_optab_handler (ssmadd_widen_optab, $B, CODE_FOR_$(ssmadd$a$b4$)$N)\",\n-  \"set_optab_handler (usmadd_widen_optab, $B, CODE_FOR_$(usmadd$a$b4$)$N)\",\n-  \"set_optab_handler (smsub_widen_optab, $B, CODE_FOR_$(msub$a$b4$)$N)\",\n-  \"set_optab_handler (umsub_widen_optab, $B, CODE_FOR_$(umsub$a$b4$)$N)\",\n-  \"set_optab_handler (ssmsub_widen_optab, $B, CODE_FOR_$(ssmsub$a$b4$)$N)\",\n-  \"set_optab_handler (usmsub_widen_optab, $B, CODE_FOR_$(usmsub$a$b4$)$N)\",\n+  \"set_widening_optab_handler (smul_widen_optab, $B, $A, CODE_FOR_$(mul$a$b3$)$N)\",\n+  \"set_widening_optab_handler (umul_widen_optab, $B, $A, CODE_FOR_$(umul$a$b3$)$N)\",\n+  \"set_widening_optab_handler (usmul_widen_optab, $B, $A, CODE_FOR_$(usmul$a$b3$)$N)\",\n+  \"set_widening_optab_handler (smadd_widen_optab, $B, $A, CODE_FOR_$(madd$a$b4$)$N)\",\n+  \"set_widening_optab_handler (umadd_widen_optab, $B, $A, CODE_FOR_$(umadd$a$b4$)$N)\",\n+  \"set_widening_optab_handler (ssmadd_widen_optab, $B, $A, CODE_FOR_$(ssmadd$a$b4$)$N)\",\n+  \"set_widening_optab_handler (usmadd_widen_optab, $B, $A, CODE_FOR_$(usmadd$a$b4$)$N)\",\n+  \"set_widening_optab_handler (smsub_widen_optab, $B, $A, CODE_FOR_$(msub$a$b4$)$N)\",\n+  \"set_widening_optab_handler (umsub_widen_optab, $B, $A, CODE_FOR_$(umsub$a$b4$)$N)\",\n+  \"set_widening_optab_handler (ssmsub_widen_optab, $B, $A, CODE_FOR_$(ssmsub$a$b4$)$N)\",\n+  \"set_widening_optab_handler (usmsub_widen_optab, $B, $A, CODE_FOR_$(usmsub$a$b4$)$N)\",\n   \"set_optab_handler (sdiv_optab, $A, CODE_FOR_$(div$a3$))\",\n   \"set_optab_handler (ssdiv_optab, $A, CODE_FOR_$(ssdiv$Q$a3$))\",\n   \"set_optab_handler (sdivv_optab, $A, CODE_FOR_$(div$V$I$a3$))\",\n@@ -305,7 +307,7 @@ gen_insn (rtx insn)\n     {\n       int force_float = 0, force_int = 0, force_partial_int = 0;\n       int force_fixed = 0;\n-      int force_consec = 0;\n+      int force_wider = 0;\n       int matches = 1;\n \n       for (pp = optabs[pindex]; pp[0] != '$' || pp[1] != '('; pp++)\n@@ -323,7 +325,7 @@ gen_insn (rtx insn)\n \t    switch (*++pp)\n \t      {\n \t      case 'N':\n-\t\tforce_consec = 1;\n+\t\tforce_wider = 1;\n \t\tbreak;\n \t      case 'I':\n \t\tforce_int = 1;\n@@ -392,7 +394,10 @@ gen_insn (rtx insn)\n \t\t\t    || mode_class[i] == MODE_VECTOR_FRACT\n \t\t\t    || mode_class[i] == MODE_VECTOR_UFRACT\n \t\t\t    || mode_class[i] == MODE_VECTOR_ACCUM\n-\t\t\t    || mode_class[i] == MODE_VECTOR_UACCUM))\n+\t\t\t    || mode_class[i] == MODE_VECTOR_UACCUM)\n+\t\t\t&& (! force_wider\n+\t\t\t    || *pp == 'a'\n+\t\t\t    || m1 < i))\n \t\t      break;\n \t\t  }\n \n@@ -412,8 +417,7 @@ gen_insn (rtx insn)\n \t}\n \n       if (matches && pp[0] == '$' && pp[1] == ')'\n-\t  && *np == 0\n-\t  && (! force_consec || (int) GET_MODE_WIDER_MODE(m1) == m2))\n+\t  && *np == 0)\n \tbreak;\n     }\n "}, {"sha": "e8d07a08b2172d76bfa47bf299abf215d71b3ef0", "filename": "gcc/optabs.c", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a484f6bae00618d6482bdaf1740bb32663d96d24/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a484f6bae00618d6482bdaf1740bb32663d96d24/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=a484f6bae00618d6482bdaf1740bb32663d96d24", "patch": "@@ -225,6 +225,30 @@ add_equal_note (rtx insns, rtx target, enum rtx_code code, rtx op0, rtx op1)\n   return 1;\n }\n \f\n+/* Given two input operands, OP0 and OP1, determine what the correct from_mode\n+   for a widening operation would be.  In most cases this would be OP0, but if\n+   that's a constant it'll be VOIDmode, which isn't useful.  */\n+\n+static enum machine_mode\n+widened_mode (enum machine_mode to_mode, rtx op0, rtx op1)\n+{\n+  enum machine_mode m0 = GET_MODE (op0);\n+  enum machine_mode m1 = GET_MODE (op1);\n+  enum machine_mode result;\n+\n+  if (m0 == VOIDmode && m1 == VOIDmode)\n+    return to_mode;\n+  else if (m0 == VOIDmode || GET_MODE_SIZE (m0) < GET_MODE_SIZE (m1))\n+    result = m1;\n+  else\n+    result = m0;\n+\n+  if (GET_MODE_SIZE (result) > GET_MODE_SIZE (to_mode))\n+    return to_mode;\n+\n+  return result;\n+}\n+\f\n /* Widen OP to MODE and return the rtx for the widened operand.  UNSIGNEDP\n    says whether OP is signed or unsigned.  NO_EXTEND is nonzero if we need\n    not actually do a sign-extend or zero-extend, but can leave the\n@@ -515,8 +539,8 @@ expand_widen_pattern_expr (sepops ops, rtx op0, rtx op1, rtx wide_op,\n     optab_for_tree_code (ops->code, TREE_TYPE (oprnd0), optab_default);\n   if (ops->code == WIDEN_MULT_PLUS_EXPR\n       || ops->code == WIDEN_MULT_MINUS_EXPR)\n-    icode = optab_handler (widen_pattern_optab,\n-\t\t\t   TYPE_MODE (TREE_TYPE (ops->op2)));\n+    icode = widening_optab_handler (widen_pattern_optab,\n+\t\t\t\t    TYPE_MODE (TREE_TYPE (ops->op2)), tmode0);\n   else\n     icode = optab_handler (widen_pattern_optab, tmode0);\n   gcc_assert (icode != CODE_FOR_nothing);\n@@ -1242,7 +1266,8 @@ expand_binop_directly (enum machine_mode mode, optab binoptab,\n \t\t       rtx target, int unsignedp, enum optab_methods methods,\n \t\t       rtx last)\n {\n-  enum insn_code icode = optab_handler (binoptab, mode);\n+  enum machine_mode from_mode = widened_mode (mode, op0, op1);\n+  enum insn_code icode = widening_optab_handler (binoptab, mode, from_mode);\n   enum machine_mode xmode0 = insn_data[(int) icode].operand[1].mode;\n   enum machine_mode xmode1 = insn_data[(int) icode].operand[2].mode;\n   enum machine_mode mode0, mode1, tmp_mode;\n@@ -1389,7 +1414,9 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   /* If we can do it with a three-operand insn, do so.  */\n \n   if (methods != OPTAB_MUST_WIDEN\n-      && optab_handler (binoptab, mode) != CODE_FOR_nothing)\n+      && widening_optab_handler (binoptab, mode,\n+\t\t\t\t widened_mode (mode, op0, op1))\n+\t    != CODE_FOR_nothing)\n     {\n       temp = expand_binop_directly (mode, binoptab, op0, op1, target,\n \t\t\t\t    unsignedp, methods, last);\n@@ -1429,8 +1456,9 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n   if (binoptab == smul_optab\n       && GET_MODE_2XWIDER_MODE (mode) != VOIDmode\n-      && (optab_handler ((unsignedp ? umul_widen_optab : smul_widen_optab),\n-\t\t\t GET_MODE_2XWIDER_MODE (mode))\n+      && (widening_optab_handler ((unsignedp ? umul_widen_optab\n+\t\t\t\t\t     : smul_widen_optab),\n+\t\t\t\t  GET_MODE_2XWIDER_MODE (mode), mode)\n \t  != CODE_FOR_nothing))\n     {\n       temp = expand_binop (GET_MODE_2XWIDER_MODE (mode),\n@@ -1460,9 +1488,10 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \tif (optab_handler (binoptab, wider_mode) != CODE_FOR_nothing\n \t    || (binoptab == smul_optab\n \t\t&& GET_MODE_WIDER_MODE (wider_mode) != VOIDmode\n-\t\t&& (optab_handler ((unsignedp ? umul_widen_optab\n-\t\t\t\t    : smul_widen_optab),\n-\t\t\t\t   GET_MODE_WIDER_MODE (wider_mode))\n+\t\t&& (widening_optab_handler ((unsignedp ? umul_widen_optab\n+\t\t\t\t\t\t       : smul_widen_optab),\n+\t\t\t\t\t    GET_MODE_WIDER_MODE (wider_mode),\n+\t\t\t\t\t    mode)\n \t\t    != CODE_FOR_nothing)))\n \t  {\n \t    rtx xop0 = op0, xop1 = op1;\n@@ -1895,8 +1924,8 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       && optab_handler (add_optab, word_mode) != CODE_FOR_nothing)\n     {\n       rtx product = NULL_RTX;\n-\n-      if (optab_handler (umul_widen_optab, mode) != CODE_FOR_nothing)\n+      if (widening_optab_handler (umul_widen_optab, mode, word_mode)\n+\t    != CODE_FOR_nothing)\n \t{\n \t  product = expand_doubleword_mult (mode, op0, op1, target,\n \t\t\t\t\t    true, methods);\n@@ -1905,7 +1934,8 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t}\n \n       if (product == NULL_RTX\n-\t  && optab_handler (smul_widen_optab, mode) != CODE_FOR_nothing)\n+\t  && widening_optab_handler (smul_widen_optab, mode, word_mode)\n+\t\t!= CODE_FOR_nothing)\n \t{\n \t  product = expand_doubleword_mult (mode, op0, op1, target,\n \t\t\t\t\t    false, methods);\n@@ -1997,6 +2027,8 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n \t  if (optab_handler (binoptab, wider_mode) != CODE_FOR_nothing\n+\t      || widening_optab_handler (binoptab, wider_mode, mode)\n+\t\t  != CODE_FOR_nothing\n \t      || (methods == OPTAB_LIB\n \t\t  && optab_libfunc (binoptab, wider_mode)))\n \t    {"}, {"sha": "0ea620c2fda66573fa17bf4ad39d8440387a12b2", "filename": "gcc/optabs.h", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a484f6bae00618d6482bdaf1740bb32663d96d24/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a484f6bae00618d6482bdaf1740bb32663d96d24/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=a484f6bae00618d6482bdaf1740bb32663d96d24", "patch": "@@ -42,6 +42,11 @@ struct optab_handlers\n   int insn_code;\n };\n \n+struct widening_optab_handlers\n+{\n+  struct optab_handlers handlers[NUM_MACHINE_MODES][NUM_MACHINE_MODES];\n+};\n+\n struct optab_d\n {\n   enum rtx_code code;\n@@ -50,6 +55,7 @@ struct optab_d\n   void (*libcall_gen)(struct optab_d *, const char *name, char suffix,\n \t\t      enum machine_mode);\n   struct optab_handlers handlers[NUM_MACHINE_MODES];\n+  struct widening_optab_handlers *widening;\n };\n typedef struct optab_d * optab;\n \n@@ -879,6 +885,23 @@ optab_handler (optab op, enum machine_mode mode)\n \t\t\t   + (int) CODE_FOR_nothing);\n }\n \n+/* Like optab_handler, but for widening_operations that have a TO_MODE and\n+  a FROM_MODE.  */\n+\n+static inline enum insn_code\n+widening_optab_handler (optab op, enum machine_mode to_mode,\n+\t\t\tenum machine_mode from_mode)\n+{\n+  if (to_mode == from_mode || from_mode == VOIDmode)\n+    return optab_handler (op, to_mode);\n+\n+  if (op->widening)\n+    return (enum insn_code) (op->widening->handlers[(int) to_mode][(int) from_mode].insn_code\n+\t\t\t     + (int) CODE_FOR_nothing);\n+\n+  return CODE_FOR_nothing;\n+}\n+\n /* Record that insn CODE should be used to implement mode MODE of OP.  */\n \n static inline void\n@@ -887,6 +910,26 @@ set_optab_handler (optab op, enum machine_mode mode, enum insn_code code)\n   op->handlers[(int) mode].insn_code = (int) code - (int) CODE_FOR_nothing;\n }\n \n+/* Like set_optab_handler, but for widening operations that have a TO_MODE\n+   and a FROM_MODE.  */\n+\n+static inline void\n+set_widening_optab_handler (optab op, enum machine_mode to_mode,\n+\t\t\t    enum machine_mode from_mode, enum insn_code code)\n+{\n+  if (to_mode == from_mode)\n+    set_optab_handler (op, to_mode, code);\n+  else\n+    {\n+      if (op->widening == NULL)\n+\top->widening = (struct widening_optab_handlers *)\n+\t      xcalloc (1, sizeof (struct widening_optab_handlers));\n+\n+      op->widening->handlers[(int) to_mode][(int) from_mode].insn_code\n+\t  = (int) code - (int) CODE_FOR_nothing;\n+    }\n+}\n+\n /* Return the insn used to perform conversion OP from mode FROM_MODE\n    to mode TO_MODE; return CODE_FOR_nothing if the target does not have\n    such an insn.  */"}, {"sha": "e6bc2ae215b6d0f289e41225e1090eea6fbd90df", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a484f6bae00618d6482bdaf1740bb32663d96d24/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a484f6bae00618d6482bdaf1740bb32663d96d24/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=a484f6bae00618d6482bdaf1740bb32663d96d24", "patch": "@@ -2056,6 +2056,8 @@ convert_mult_to_widen (gimple stmt)\n {\n   tree lhs, rhs1, rhs2, type, type1, type2;\n   enum insn_code handler;\n+  enum machine_mode to_mode, from_mode;\n+  optab op;\n \n   lhs = gimple_assign_lhs (stmt);\n   type = TREE_TYPE (lhs);\n@@ -2065,12 +2067,17 @@ convert_mult_to_widen (gimple stmt)\n   if (!is_widening_mult_p (stmt, &type1, &rhs1, &type2, &rhs2))\n     return false;\n \n+  to_mode = TYPE_MODE (type);\n+  from_mode = TYPE_MODE (type1);\n+\n   if (TYPE_UNSIGNED (type1) && TYPE_UNSIGNED (type2))\n-    handler = optab_handler (umul_widen_optab, TYPE_MODE (type));\n+    op = umul_widen_optab;\n   else if (!TYPE_UNSIGNED (type1) && !TYPE_UNSIGNED (type2))\n-    handler = optab_handler (smul_widen_optab, TYPE_MODE (type));\n+    op = smul_widen_optab;\n   else\n-    handler = optab_handler (usmul_widen_optab, TYPE_MODE (type));\n+    op = usmul_widen_optab;\n+\n+  handler = widening_optab_handler (op, to_mode, from_mode);\n \n   if (handler == CODE_FOR_nothing)\n     return false;\n@@ -2172,7 +2179,8 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple stmt,\n      accumulate in this mode/signedness combination, otherwise\n      this transformation is likely to pessimize code.  */\n   this_optab = optab_for_tree_code (wmult_code, type1, optab_default);\n-  if (optab_handler (this_optab, TYPE_MODE (type)) == CODE_FOR_nothing)\n+  if (widening_optab_handler (this_optab, TYPE_MODE (type), TYPE_MODE (type1))\n+\t== CODE_FOR_nothing)\n     return false;\n \n   /* ??? May need some type verification here?  */"}]}