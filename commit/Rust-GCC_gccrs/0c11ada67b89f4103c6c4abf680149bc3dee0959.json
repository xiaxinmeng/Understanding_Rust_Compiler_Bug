{"sha": "0c11ada67b89f4103c6c4abf680149bc3dee0959", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMxMWFkYTY3Yjg5ZjQxMDNjNmM0YWJmNjgwMTQ5YmMzZGVlMDk1OQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@casey.cygnus.com", "date": "2000-03-10T09:25:45Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-03-10T09:25:45Z"}, "message": "decl.c (push_overloaded_decl_1, [...]): Lose.\n\n        * decl.c (push_overloaded_decl_1, auto_function,\n        define_function): Lose.\n        (build_library_fn_1): New static fn.\n        (builtin_function): Use it.\n        (get_atexit_node): Use build_library_fn_ptr.\n        (build_library_fn, build_cp_library_fn, build_library_fn_ptr,\n        build_cp_library_fn_ptr, push_library_fn, push_cp_library_fn,\n        push_void_library_fn, push_throw_library_fn): New fns.\n        * cp-tree.h: Declare them.\n        (cp_tree_index): Remove CPTI_BAD_CAST, CPTI_BAD_TYPEID.\n        (throw_bad_cast_node, throw_bad_typeid_node): Lose.\n        * except.c (init_exception_processing, call_eh_info, do_pop_exception,\n        (expand_end_eh_spec, alloc_eh_object, expand_throw): Use above fns.\n        * rtti.c (build_runtime_decl): Lose.\n        (throw_bad_cast, throw_bad_typeid, get_tinfo_decl,\n        build_dynamic_cast_1, expand_si_desc, expand_class_desc,\n        expand_ptr_desc, expand_attr_desc, expand_generic_desc): Use above fns.\n\n        * call.c (build_call): Remove result_type parm.\n        Call mark_used on unused artificial fns.\n        * init.c, method.c, typeck.c, except.c, rtti.c: Adjust.\n\nFrom-SVN: r32468", "tree": {"sha": "2abf6c15ae84cc0615afb845f3b88512998cf097", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2abf6c15ae84cc0615afb845f3b88512998cf097"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c11ada67b89f4103c6c4abf680149bc3dee0959", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c11ada67b89f4103c6c4abf680149bc3dee0959", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c11ada67b89f4103c6c4abf680149bc3dee0959", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c11ada67b89f4103c6c4abf680149bc3dee0959/comments", "author": null, "committer": null, "parents": [{"sha": "c3ab7a40d76cac8bca2e4b9592321156557c7278", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3ab7a40d76cac8bca2e4b9592321156557c7278", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3ab7a40d76cac8bca2e4b9592321156557c7278"}], "stats": {"total": 513, "additions": 235, "deletions": 278}, "files": [{"sha": "e549057d32b4e7365c3a717f22ba5bd17cf87317", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c11ada67b89f4103c6c4abf680149bc3dee0959/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c11ada67b89f4103c6c4abf680149bc3dee0959/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0c11ada67b89f4103c6c4abf680149bc3dee0959", "patch": "@@ -1,3 +1,27 @@\n+2000-03-10  Jason Merrill  <jason@casey.cygnus.com>\n+\n+\t* decl.c (push_overloaded_decl_1, auto_function, \n+\tdefine_function): Lose.\n+\t(build_library_fn_1): New static fn.\n+\t(builtin_function): Use it.\n+\t(get_atexit_node): Use build_library_fn_ptr.\n+\t(build_library_fn, build_cp_library_fn, build_library_fn_ptr,\n+\tbuild_cp_library_fn_ptr, push_library_fn, push_cp_library_fn,\n+\tpush_void_library_fn, push_throw_library_fn): New fns.\n+\t* cp-tree.h: Declare them.\n+\t(cp_tree_index): Remove CPTI_BAD_CAST, CPTI_BAD_TYPEID.\n+\t(throw_bad_cast_node, throw_bad_typeid_node): Lose.\n+\t* except.c (init_exception_processing, call_eh_info, do_pop_exception,\n+\t(expand_end_eh_spec, alloc_eh_object, expand_throw): Use above fns.\n+\t* rtti.c (build_runtime_decl): Lose.\n+\t(throw_bad_cast, throw_bad_typeid, get_tinfo_decl, \n+\tbuild_dynamic_cast_1, expand_si_desc, expand_class_desc,\n+\texpand_ptr_desc, expand_attr_desc, expand_generic_desc): Use above fns.\n+\n+\t* call.c (build_call): Remove result_type parm.\n+\tCall mark_used on unused artificial fns.\n+\t* init.c, method.c, typeck.c, except.c, rtti.c: Adjust.\n+\n 2000-03-09  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* call.c (build_call): Set TREE_NOTHROW on the CALL_EXPR as"}, {"sha": "40cd43d39b6a403416d73b5ffb280f7ca6214a93", "filename": "gcc/cp/call.c", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c11ada67b89f4103c6c4abf680149bc3dee0959/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c11ada67b89f4103c6c4abf680149bc3dee0959/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0c11ada67b89f4103c6c4abf680149bc3dee0959", "patch": "@@ -364,13 +364,14 @@ build_addr_func (function)\n    (TYPE_PTRMEMFUNC_P) must be handled by our callers.  */\n \n tree\n-build_call (function, result_type, parms)\n-     tree function, result_type, parms;\n+build_call (function, parms)\n+     tree function, parms;\n {\n   int is_constructor = 0;\n   int nothrow;\n   tree tmp;\n   tree decl;\n+  tree result_type;\n \n   function = build_addr_func (function);\n \n@@ -380,6 +381,8 @@ build_call (function, result_type, parms)\n       return error_mark_node;\n     }\n \n+  result_type = TREE_TYPE (TREE_TYPE (TREE_TYPE (function)));\n+\n   if (TREE_CODE (function) == ADDR_EXPR\n       && TREE_CODE (TREE_OPERAND (function, 0)) == FUNCTION_DECL)\n     decl = TREE_OPERAND (function, 0);\n@@ -394,8 +397,14 @@ build_call (function, result_type, parms)\n   if (decl && DECL_CONSTRUCTOR_P (decl))\n     is_constructor = 1;\n \n-  if (decl)\n-    my_friendly_assert (TREE_USED (decl), 990125);\n+  if (decl && ! TREE_USED (decl))\n+    {\n+      /* We invoke build_call directly for several library functions.  */\n+      if (DECL_ARTIFICIAL (decl))\n+\tmark_used (decl);\n+      else\n+\tmy_friendly_abort (990125);\n+    }\n \n   /* Don't pass empty class objects by value.  This is useful\n      for tags in STL, which are used to control overload resolution.\n@@ -4157,7 +4166,7 @@ build_over_call (cand, args, flags)\n \treturn exp;\n     }\n \n-  fn = build_call (fn, TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))), converted_args);\n+  fn = build_call (fn, converted_args);\n   if (TREE_CODE (TREE_TYPE (fn)) == VOID_TYPE)\n     return fn;\n   fn = require_complete_type (fn);"}, {"sha": "f7bacebe6badce4536edef65952ae707857ecbce", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c11ada67b89f4103c6c4abf680149bc3dee0959/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c11ada67b89f4103c6c4abf680149bc3dee0959/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0c11ada67b89f4103c6c4abf680149bc3dee0959", "patch": "@@ -577,8 +577,6 @@ enum cp_tree_index\n     CPTI_TERMINATE,\n     CPTI_ATEXIT,\n     CPTI_DSO_HANDLE,\n-    CPTI_BAD_CAST,\n-    CPTI_BAD_TYPEID,\n     CPTI_DCAST,\n \n     CPTI_MAX\n@@ -686,12 +684,6 @@ extern tree cp_global_trees[CPTI_MAX];\n /* A pointer to `__dso_handle'.  */\n #define dso_handle_node                 cp_global_trees[CPTI_DSO_HANDLE]\n \n-/* The declaration of __throw_bad_cast.  */\n-#define throw_bad_cast_node             cp_global_trees[CPTI_BAD_CAST]\n-\n-/* The declaration of __throw_bad_typeid.  */\n-#define throw_bad_typeid_node           cp_global_trees[CPTI_BAD_TYPEID]\n-\n /* The declaration of the dynamic_cast runtime.  */\n #define dynamic_cast_node               cp_global_trees[CPTI_DCAST]\n \n@@ -3605,7 +3597,7 @@ extern tree build_vfield_ref\t\t\tPARAMS ((tree, tree));\n extern tree resolve_scope_to_name\t\tPARAMS ((tree, tree));\n extern tree build_scoped_method_call\t\tPARAMS ((tree, tree, tree, tree));\n extern tree build_addr_func\t\t\tPARAMS ((tree));\n-extern tree build_call\t\t\t\tPARAMS ((tree, tree, tree));\n+extern tree build_call\t\t\t\tPARAMS ((tree, tree));\n extern tree build_method_call\t\t\tPARAMS ((tree, tree, tree, tree, int));\n extern int null_ptr_cst_p\t\t\tPARAMS ((tree));\n extern tree type_decays_to\t\t\tPARAMS ((tree));\n@@ -3753,12 +3745,16 @@ extern tree namespace_ancestor\t\t\tPARAMS ((tree, tree));\n extern tree unqualified_namespace_lookup\tPARAMS ((tree, int, tree *));\n extern int  lookup_using_namespace              PARAMS ((tree, tree, tree, tree, int, tree *));\n extern int  qualified_lookup_using_namespace    PARAMS ((tree, tree, tree, int));\n-extern tree auto_function\t\t\tPARAMS ((tree, tree));\n+extern tree build_library_fn\t\t\tPARAMS ((tree, tree));\n+extern tree build_cp_library_fn\t\t\tPARAMS ((tree, tree));\n+extern tree build_library_fn_ptr\t\tPARAMS ((const char *, tree));\n+extern tree build_cp_library_fn_ptr\t\tPARAMS ((const char *, tree));\n+extern tree push_library_fn\t\t\tPARAMS ((tree, tree));\n+extern tree push_cp_library_fn\t\t\tPARAMS ((tree, tree));\n+extern tree push_void_library_fn\t\tPARAMS ((tree, tree));\n+extern tree push_throw_library_fn\t\tPARAMS ((tree, tree));\n extern void init_decl_processing\t\tPARAMS ((void));\n extern int init_type_desc\t\t\tPARAMS ((void));\n-extern tree define_function\t\t\tPARAMS ((const char *, tree,\n-\t\t\t\t\t\t       void (*) (tree),\n-\t\t\t\t\t\t       const char *));\n extern tree check_tag_decl\t\t\tPARAMS ((tree));\n extern void shadow_tag\t\t\t\tPARAMS ((tree));\n extern tree groktypename\t\t\tPARAMS ((tree));"}, {"sha": "713319025a8c0d384fafaed039e1bf5882cb67eb", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 132, "deletions": 58, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c11ada67b89f4103c6c4abf680149bc3dee0959/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c11ada67b89f4103c6c4abf680149bc3dee0959/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0c11ada67b89f4103c6c4abf680149bc3dee0959", "patch": "@@ -113,7 +113,6 @@ static void declare_namespace_level PARAMS ((void));\n static void signal_catch PARAMS ((int)) ATTRIBUTE_NORETURN;\n static void storedecls PARAMS ((tree));\n static void require_complete_types_for_parms PARAMS ((tree));\n-static void push_overloaded_decl_1 PARAMS ((tree));\n static int ambi_op_p PARAMS ((tree));\n static int unary_op_p PARAMS ((tree));\n static tree store_bindings PARAMS ((tree, tree));\n@@ -133,6 +132,7 @@ static void set_identifier_type_value_with_scope\n \tPARAMS ((tree, tree, struct binding_level *));\n static void record_builtin_type PARAMS ((enum rid, const char *, tree));\n static void record_unknown_type PARAMS ((tree, const char *));\n+static tree build_library_fn_1\t\t\tPARAMS ((tree, tree));\n static int member_function_or_else PARAMS ((tree, tree, enum overload_flags));\n static void bad_specifiers PARAMS ((tree, const char *, int, int, int, int,\n \t\t\t\t  int));\n@@ -5937,26 +5937,6 @@ record_unknown_type (type, name)\n   TYPE_MODE (type) = TYPE_MODE (void_type_node);\n }\n \n-/* Push overloaded decl, in global scope, with one argument so it\n-   can be used as a callback from define_function.  */\n-\n-static void\n-push_overloaded_decl_1 (x)\n-     tree x;\n-{\n-  pushdecl (x);\n-}\n-\n-inline tree\n-auto_function (name, type)\n-     tree name, type;\n-{\n-  return define_function\n-    (IDENTIFIER_POINTER (name), type, push_overloaded_decl_1,\n-     IDENTIFIER_POINTER (build_decl_overload (name, TYPE_ARG_TYPES (type),\n-\t\t\t\t\t      0)));\n-}\n-\n /* Create the predefined scalar types of C,\n    and some nodes representing standard constants (0, 1, (void *)0).\n    Initialize the global binding level.\n@@ -6320,15 +6300,15 @@ init_decl_processing ()\n     newtype = build_exception_variant\n       (ptr_ftype_sizetype, add_exception_specifier (NULL_TREE, bad_alloc_type_node, -1));\n     deltype = build_exception_variant (void_ftype_ptr, empty_except_spec);\n-    auto_function (ansi_opname[(int) NEW_EXPR], newtype);\n-    auto_function (ansi_opname[(int) VEC_NEW_EXPR], newtype);\n-    global_delete_fndecl = auto_function (ansi_opname[(int) DELETE_EXPR],\n-\t\t\t\t\t  deltype);\n-    auto_function (ansi_opname[(int) VEC_DELETE_EXPR], deltype);\n+    push_cp_library_fn (ansi_opname[(int) NEW_EXPR], newtype);\n+    push_cp_library_fn (ansi_opname[(int) VEC_NEW_EXPR], newtype);\n+    global_delete_fndecl = push_cp_library_fn (ansi_opname[(int) DELETE_EXPR],\n+\t\t\t\t\t       deltype);\n+    push_cp_library_fn (ansi_opname[(int) VEC_DELETE_EXPR], deltype);\n   }\n \n   abort_fndecl\n-    = define_function (\"__pure_virtual\", void_ftype, 0, 0);\n+    = build_library_fn_ptr (\"__pure_virtual\", void_ftype);\n \n   /* Perform other language dependent initializations.  */\n   init_class_processing ();\n@@ -6461,60 +6441,154 @@ lang_print_error_function (file)\n   maybe_print_template_context ();\n }\n \n-/* Make a definition for a builtin function named NAME and whose data type\n+/* Entry point for the benefit of c_common_nodes_and_builtins.\n+\n+   Make a definition for a builtin function named NAME and whose data type\n    is TYPE.  TYPE should be a function type with argument types.\n \n-   If LIBRARY_NAME is nonzero, use that for DECL_ASSEMBLER_NAME,\n+   CLASS and CODE tell later passes how to compile calls to this function.\n+   See tree.h for possible values.\n+\n+   If LIBNAME is nonzero, use that for DECL_ASSEMBLER_NAME,\n    the name to be called if we can't opencode the function.  */\n \n tree\n-define_function (name, type, pfn, library_name)\n+builtin_function (name, type, code, class, libname)\n      const char *name;\n      tree type;\n-     void (*pfn) PARAMS ((tree));\n-     const char *library_name;\n+     int code;\n+     enum built_in_class class;\n+     const char *libname;\n {\n-  tree decl = build_lang_decl (FUNCTION_DECL, get_identifier (name), type);\n-  DECL_EXTERNAL (decl) = 1;\n-  TREE_PUBLIC (decl) = 1;\n-  DECL_ARTIFICIAL (decl) = 1;\n-\n-  /* If no exception specifier was given, assume it doesn't throw.  */\n-  if (TYPE_RAISES_EXCEPTIONS (type) == NULL_TREE)\n-    TREE_NOTHROW (decl) = 1;\n+  tree decl = build_library_fn_1 (get_identifier (name), type);\n+  DECL_BUILT_IN_CLASS (decl) = class;\n+  DECL_FUNCTION_CODE (decl) = code;\n \n   my_friendly_assert (DECL_CONTEXT (decl) == NULL_TREE, 392);\n-  DECL_CONTEXT (decl) = FROB_CONTEXT (current_namespace);\n \n   /* Since `pushdecl' relies on DECL_ASSEMBLER_NAME instead of DECL_NAME,\n      we cannot change DECL_ASSEMBLER_NAME until we have installed this\n      function in the namespace.  */\n-  if (pfn) (*pfn) (decl);\n-  if (library_name)\n-    DECL_ASSEMBLER_NAME (decl) = get_identifier (library_name);\n+  pushdecl (decl);\n+  if (libname)\n+    DECL_ASSEMBLER_NAME (decl) = get_identifier (libname);\n   make_function_rtl (decl);\n   return decl;\n }\n \n+/* Generate a FUNCTION_DECL with the typical flags for a runtime library\n+   function.  Not called directly.  */\n+\n+static tree\n+build_library_fn_1 (name, type)\n+     tree name;\n+     tree type;\n+{\n+  tree fn = build_lang_decl (FUNCTION_DECL, name, type);\n+  DECL_EXTERNAL (fn) = 1;\n+  TREE_PUBLIC (fn) = 1;\n+  DECL_ARTIFICIAL (fn) = 1;\n+  TREE_NOTHROW (fn) = 1;\n+  return fn;\n+}\n \n-/* Wrapper around define_function, for the benefit of\n-   c_common_nodes_and_builtins.\n-   FUNCTION_CODE tells later passes how to compile calls to this function.\n-   See tree.h for its possible values.  */\n+/* Returns the _DECL for a library function with C linkage.\n+   We assume that such functions never throw; if this is incorrect,\n+   callers should unset TREE_NOTHROW.  */\n \n tree\n-builtin_function (name, type, code, class, libname)\n+build_library_fn (name, type)\n+     tree name;\n+     tree type;\n+{\n+  tree fn = build_library_fn_1 (name, type);\n+  make_function_rtl (fn);\n+  return fn;\n+}\n+\n+/* Returns the _DECL for a library function with C++ linkage.  */\n+\n+tree\n+build_cp_library_fn (name, type)\n+     tree name;\n+     tree type;\n+{\n+  tree fn = build_library_fn_1 (name, type);\n+  TREE_NOTHROW (fn) = TYPE_NOTHROW_P (type);\n+  set_mangled_name_for_decl (fn);\n+  make_function_rtl (fn);\n+  return fn;\n+}\n+\n+/* Like build_library_fn, but takes a C string instead of an\n+   IDENTIFIER_NODE.  */\n+\n+tree\n+build_library_fn_ptr (name, type)\n      const char *name;\n      tree type;\n-     int code;\n-     enum built_in_class class;\n-     const char *libname;\n {\n-  tree decl = define_function (name, type, (void (*) PARAMS ((tree)))pushdecl,\n-\t\t\t       libname);\n-  DECL_BUILT_IN_CLASS (decl) = class;\n-  DECL_FUNCTION_CODE (decl) = code;\n-  return decl;\n+  return build_library_fn (get_identifier (name), type);\n+}\n+\n+/* Like build_cp_library_fn, but takes a C string instead of an\n+   IDENTIFIER_NODE.  */\n+\n+tree\n+build_cp_library_fn_ptr (name, type)\n+     const char *name;\n+     tree type;\n+{\n+  return build_cp_library_fn (get_identifier (name), type);\n+}\n+\n+/* Like build_library_fn, but also pushes the function so that we will\n+   be able to find it via IDENTIFIER_GLOBAL_VALUE.  */\n+\n+tree\n+push_library_fn (name, type)\n+     tree name, type;\n+{\n+  tree fn = build_library_fn (name, type);\n+  pushdecl_top_level (fn);\n+  return fn;\n+}\n+\n+/* Like build_cp_library_fn, but also pushes the function so that it\n+   will be found by normal lookup.  */\n+\n+tree\n+push_cp_library_fn (name, type)\n+     tree name;\n+     tree type;\n+{\n+  tree fn = build_cp_library_fn (name, type);\n+  pushdecl (fn);\n+  return fn;\n+}\n+\n+/* Like push_library_fn, but takes a TREE_LIST of parm types rather than\n+   a FUNCTION_TYPE.  */\n+\n+tree\n+push_void_library_fn (name, parmtypes)\n+     tree name, parmtypes;\n+{\n+  tree type = build_function_type (void_type_node, parmtypes);\n+  return push_library_fn (name, type);\n+}\n+\n+/* Like push_void_library_fn, but also note that this function throws\n+   and does not return.  Used for __throw_foo and the like.  */\n+\n+tree\n+push_throw_library_fn (name, parmtypes)\n+     tree name, parmtypes;\n+{\n+  tree fn = push_void_library_fn (name, parmtypes);\n+  TREE_THIS_VOLATILE (fn) = 1;\n+  TREE_NOTHROW (fn) = 0;\n+  return fn;\n }\n \f\n /* When we call finish_struct for an anonymous union, we create\n@@ -7984,7 +8058,7 @@ get_atexit_node ()\n \n   /* Now, build the function declaration.  */\n   push_lang_context (lang_name_c);\n-  atexit_fndecl = define_function (name, fn_type, /*pfn=*/0, NULL_PTR);\n+  atexit_fndecl = build_library_fn_ptr (name, fn_type);\n   mark_used (atexit_fndecl);\n   pop_lang_context ();\n   atexit_node = default_conversion (atexit_fndecl);"}, {"sha": "ae64e78b3d6f07b0cee36bf47cec695ec235eb8a", "filename": "gcc/cp/except.c", "status": "modified", "additions": 20, "deletions": 74, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c11ada67b89f4103c6c4abf680149bc3dee0959/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c11ada67b89f4103c6c4abf680149bc3dee0959/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=0c11ada67b89f4103c6c4abf680149bc3dee0959", "patch": "@@ -173,8 +173,9 @@ init_exception_processing ()\n   \n   if (flag_honor_std)\n     push_namespace (get_identifier (\"std\"));\n-  terminate_node = auto_function (get_identifier (\"terminate\"), vtype);\n+  terminate_node = build_cp_library_fn_ptr (\"terminate\", vtype);\n   TREE_THIS_VOLATILE (terminate_node) = 1;\n+  TREE_NOTHROW (terminate_node) = 1;\n   if (flag_honor_std)\n     pop_namespace ();\n \n@@ -253,16 +254,8 @@ call_eh_info ()\n       t = build_pointer_type (t);\n \n       /* And now the function.  */\n-      fn = build_lang_decl (FUNCTION_DECL, fn,\n-\t\t\t    build_function_type (t, void_list_node));\n-      DECL_EXTERNAL (fn) = 1;\n-      TREE_PUBLIC (fn) = 1;\n-      DECL_ARTIFICIAL (fn) = 1;\n-      TREE_NOTHROW (fn) = 1;\n-      pushdecl_top_level (fn);\n-      make_function_rtl (fn);\n+      fn = push_library_fn (fn, build_function_type (t, void_list_node));\n     }\n-  mark_used (fn);\n   return build_function_call (fn, NULL_TREE);\n }\n \n@@ -424,18 +417,12 @@ do_pop_exception ()\n     {\n       /* Declare void __cp_pop_exception (void *),\n \t as defined in exception.cc. */\n-      fn = build_lang_decl\n-\t(FUNCTION_DECL, fn,\n-\t build_function_type (void_type_node, tree_cons\n-\t\t\t      (NULL_TREE, ptr_type_node, void_list_node)));\n-      DECL_EXTERNAL (fn) = 1;\n-      TREE_PUBLIC (fn) = 1;\n-      DECL_ARTIFICIAL (fn) = 1;\n-      pushdecl_top_level (fn);\n-      make_function_rtl (fn);\n+      fn = push_void_library_fn\n+\t(fn, tree_cons (NULL_TREE, ptr_type_node, void_list_node));\n+      /* This can throw if the destructor for the exception throws.  */\n+      TREE_NOTHROW (fn) = 0;\n     }\n \n-  mark_used (fn);\n   /* Arrange to do a dynamically scoped cleanup upon exit from this region.  */\n   cleanup = lookup_name (get_identifier (\"__exception_info\"), 0);\n   cleanup = build_function_call (fn, tree_cons\n@@ -732,21 +719,13 @@ expand_end_eh_spec (raises, try_block)\n       tmp = tree_cons\n \t(NULL_TREE, integer_type_node, tree_cons\n \t (NULL_TREE, TREE_TYPE (decl), void_list_node));\n-      tmp = build_function_type\t(void_type_node, tmp);\n-  \n-      fn = build_lang_decl (FUNCTION_DECL, fn, tmp);\n-      DECL_EXTERNAL (fn) = 1;\n-      TREE_PUBLIC (fn) = 1;\n-      DECL_ARTIFICIAL (fn) = 1;\n-      TREE_THIS_VOLATILE (fn) = 1;\n-      pushdecl_top_level (fn);\n-      make_function_rtl (fn);\n+\n+      fn = push_throw_library_fn (fn, tmp);\n     }\n \n-  mark_used (fn);\n   tmp = tree_cons (NULL_TREE, build_int_2 (count, 0), \n \t\t   tree_cons (NULL_TREE, decl, NULL_TREE));\n-  tmp = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), tmp);\n+  tmp = build_call (fn, tmp);\n   finish_expr_stmt (tmp);\n \n   finish_handler (blocks, handler);\n@@ -799,19 +778,10 @@ alloc_eh_object (type)\n   else\n     {\n       /* Declare __eh_alloc (size_t), as defined in exception.cc.  */\n-      tree tmp;\n-      tmp = tree_cons (NULL_TREE, sizetype, void_list_node);\n-      fn = build_lang_decl (FUNCTION_DECL, fn,\n-\t\t\t    build_function_type (ptr_type_node, tmp));\n-      DECL_EXTERNAL (fn) = 1;\n-      TREE_PUBLIC (fn) = 1;\n-      DECL_ARTIFICIAL (fn) = 1;\n-      TREE_NOTHROW (fn) = 1;\n-      pushdecl_top_level (fn);\n-      make_function_rtl (fn);\n+      tree tmp = tree_cons (NULL_TREE, sizetype, void_list_node);\n+      fn = push_library_fn (fn, build_function_type (ptr_type_node, tmp));\n     }\n \n-  mark_used (fn);\n   exp = build_function_call (fn, tree_cons\n \t\t\t     (NULL_TREE, size_in_bytes (type), NULL_TREE));\n   exp = build1 (NOP_EXPR, build_pointer_type (type), exp);\n@@ -852,16 +822,11 @@ expand_throw (exp)\n \t{\n \t  /* Declare _Jv_Throw (void *), as defined in Java's\n \t     exception.cc.  */\n-\t  tree tmp;\n-\t  tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);\n-\t  fn = build_lang_decl (FUNCTION_DECL, fn,\n-\t\t\t\tbuild_function_type (ptr_type_node, tmp));\n-\t  DECL_EXTERNAL (fn) = 1;\n-\t  TREE_PUBLIC (fn) = 1;\n-\t  DECL_ARTIFICIAL (fn) = 1;\n+\t  tree tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);\n+\t  tmp = build_function_type (ptr_type_node, tmp);\n+\t  fn = push_library_fn (fn, tmp);\n \t  TREE_THIS_VOLATILE (fn) = 1;\n-\t  pushdecl_top_level (fn);\n-\t  make_function_rtl (fn);\n+\t  TREE_NOTHROW (fn) = 0;\n \t}\n \n       exp = build_function_call (fn, args);\n@@ -974,17 +939,9 @@ expand_throw (exp)\n \t    (NULL_TREE, ptr_type_node, tree_cons\n \t     (NULL_TREE, ptr_type_node, tree_cons\n \t      (NULL_TREE, cleanup_type, void_list_node)));\n-\t  fn = build_lang_decl (FUNCTION_DECL, fn,\n-\t\t\t\tbuild_function_type (void_type_node, tmp));\n-\t  DECL_EXTERNAL (fn) = 1;\n-\t  TREE_PUBLIC (fn) = 1;\n-\t  DECL_ARTIFICIAL (fn) = 1;\n-\t  TREE_NOTHROW (fn) = 1;\n-\t  pushdecl_top_level (fn);\n-\t  make_function_rtl (fn);\n+\t  fn = push_void_library_fn (fn, tmp);\n \t}\n \n-      mark_used (fn);\n       e = tree_cons (NULL_TREE, exp, tree_cons\n \t\t     (NULL_TREE, throw_type, tree_cons\n \t\t      (NULL_TREE, cleanup, NULL_TREE)));\n@@ -1000,21 +957,10 @@ expand_throw (exp)\n       if (IDENTIFIER_GLOBAL_VALUE (fn))\n \tfn = IDENTIFIER_GLOBAL_VALUE (fn);\n       else\n-\t{\n-\t  /* Declare void __uncatch_exception (void)\n-\t     as defined in exception.cc. */\n-\t  fn = build_lang_decl (FUNCTION_DECL, fn,\n-\t\t\t\tbuild_function_type (void_type_node,\n-\t\t\t\t\t\t     void_list_node));\n-\t  DECL_EXTERNAL (fn) = 1;\n-\t  TREE_PUBLIC (fn) = 1;\n-\t  DECL_ARTIFICIAL (fn) = 1;\n-\t  TREE_NOTHROW (fn) = 1;\n-\t  pushdecl_top_level (fn);\n-\t  make_function_rtl (fn);\n-\t}\n+\t/* Declare void __uncatch_exception (void)\n+\t   as defined in exception.cc. */\n+\tfn = push_void_library_fn (fn, void_list_node);\n \n-      mark_used (fn);\n       exp = build_function_call (fn, NULL_TREE);\n     }\n "}, {"sha": "e4482187551b5680423ee165643f4490f4b711b1", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c11ada67b89f4103c6c4abf680149bc3dee0959/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c11ada67b89f4103c6c4abf680149bc3dee0959/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=0c11ada67b89f4103c6c4abf680149bc3dee0959", "patch": "@@ -1868,8 +1868,7 @@ build_builtin_delete_call (addr)\n      tree addr;\n {\n   mark_used (global_delete_fndecl);\n-  return build_call (global_delete_fndecl, \n-\t\t     void_type_node, build_tree_list (NULL_TREE, addr));\n+  return build_call (global_delete_fndecl, build_tree_list (NULL_TREE, addr));\n }\n \f\n /* Generate a C++ \"new\" expression. DECL is either a TREE_LIST"}, {"sha": "38e9c58e6f866e895422c944bc30e21bdaa4bb7f", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c11ada67b89f4103c6c4abf680149bc3dee0959/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c11ada67b89f4103c6c4abf680149bc3dee0959/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=0c11ada67b89f4103c6c4abf680149bc3dee0959", "patch": "@@ -2156,7 +2156,7 @@ emit_thunk (thunk_fndecl)\n     for (a = TREE_CHAIN (a); a; a = TREE_CHAIN (a))\n       t = tree_cons (NULL_TREE, a, t);\n     t = nreverse (t);\n-    t = build_call (function, TREE_TYPE (TREE_TYPE (function)), t);\n+    t = build_call (function, t);\n     finish_return_stmt (t);\n \n     expand_body (finish_function (lineno, 0));"}, {"sha": "15e46174fcfcf227407af4314330fa4cb36f39c0", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 32, "deletions": 123, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c11ada67b89f4103c6c4abf680149bc3dee0959/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c11ada67b89f4103c6c4abf680149bc3dee0959/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=0c11ada67b89f4103c6c4abf680149bc3dee0959", "patch": "@@ -45,7 +45,6 @@ Boston, MA 02111-1307, USA.  */\n \n extern struct obstack permanent_obstack;\n \n-static tree build_runtime_decl PARAMS((const char *, tree));\n static tree build_headof_sub PARAMS((tree));\n static tree build_headof PARAMS((tree));\n static tree get_tinfo_var PARAMS((tree));\n@@ -165,64 +164,34 @@ build_headof (exp)\n \t\tcp_convert (ptrdiff_type_node, offset));\n }\n \n-/* Build a decl to a runtime entry point taking void and returning TYPE. \n-   Although the entry point may never return, making its return type\n-   consistent is necessary.  */\n-\n-static tree\n-build_runtime_decl (name, type)\n-     const char *name;\n-     tree type;\n-{\n-  tree d = get_identifier (name);\n-  \n-  if (IDENTIFIER_GLOBAL_VALUE (d))\n-    d = IDENTIFIER_GLOBAL_VALUE (d);\n-  else\n-    {\n-      type = build_function_type (type, void_list_node);\n-      d = build_lang_decl (FUNCTION_DECL, d, type);\n-      DECL_EXTERNAL (d) = 1;\n-      TREE_PUBLIC (d) = 1;\n-      DECL_ARTIFICIAL (d) = 1;\n-      TREE_THIS_VOLATILE (d) = 1;\n-      pushdecl_top_level (d);\n-      make_function_rtl (d);\n-    }\n-\n-  mark_used (d);\n-  return d;\n-}\n-\n /* Get a bad_cast node for the program to throw...\n \n    See libstdc++/exception.cc for __throw_bad_cast */\n \n static tree\n throw_bad_cast ()\n {\n-  if (!throw_bad_cast_node)\n-    throw_bad_cast_node = build_runtime_decl\n-        (\"__throw_bad_cast\", ptr_type_node);\n+  tree fn = get_identifier (\"__throw_bad_cast\");\n+  if (IDENTIFIER_GLOBAL_VALUE (fn))\n+    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n+  else\n+    fn = push_throw_library_fn (fn, ptr_type_node);\n   \n-  return build_call (throw_bad_cast_node,\n-                     TREE_TYPE (TREE_TYPE (throw_bad_cast_node)),\n-                     NULL_TREE);\n+  return build_call (fn, NULL_TREE);\n }\n \n static tree\n throw_bad_typeid ()\n {\n-  if (!throw_bad_typeid_node)\n-    throw_bad_typeid_node = build_runtime_decl\n-        (\"__throw_bad_typeid\",\n-         build_reference_type\n-          (build_qualified_type\n-            (type_info_type_node, TYPE_QUAL_CONST)));\n+  tree fn = get_identifier (\"__throw_bad_cast\");\n+  if (IDENTIFIER_GLOBAL_VALUE (fn))\n+    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n+  else\n+    fn = push_throw_library_fn (fn, build_reference_type\n+\t\t\t\t(build_qualified_type\n+\t\t\t\t (type_info_type_node, TYPE_QUAL_CONST)));\n \n-  return build_call (throw_bad_typeid_node,\n-                     TREE_TYPE (TREE_TYPE (throw_bad_typeid_node)),\n-                     NULL_TREE);\n+  return build_call (fn, NULL_TREE);\n }\n \f\n /* Return a pointer to type_info function associated with the expression EXP.\n@@ -420,17 +389,10 @@ get_tinfo_decl (type)\n     {\n       /* The tinfo decl is a function returning a reference to the type_info\n          object.  */\n-      d = build_lang_decl (FUNCTION_DECL, name, tinfo_decl_type);\n-      DECL_EXTERNAL (d) = 1;\n-      TREE_PUBLIC (d) = 1;\n-      DECL_ARTIFICIAL (d) = 1;\n-      TREE_NOTHROW (d) = 1;\n+      d = push_library_fn (name, tinfo_decl_type);\n       DECL_NOT_REALLY_EXTERN (d) = 1;\n       SET_DECL_TINFO_FN_P (d);\n       TREE_TYPE (name) = type;\n-\n-      pushdecl_top_level (d);\n-      make_function_rtl (d);\n       mark_inline_for_output (d);\n     }\n   else\n@@ -468,7 +430,7 @@ tinfo_from_decl (expr)\n   tree t;\n   \n   if (!new_abi_rtti_p ())\n-    t = build_call (expr, TREE_TYPE (tinfo_decl_type), NULL_TREE);\n+    t = build_call (expr, NULL_TREE);\n   else if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n     t = build_indirect_ref (expr, NULL);\n   else\n@@ -814,24 +776,15 @@ build_dynamic_cast_1 (type, expr)\n \t                  (NULL_TREE, ptrdiff_type_node, void_list_node))));\n \t        }\n \t      tmp = build_function_type (ptr_type_node, tmp);\n-\t      dcast_fn = build_lang_decl (FUNCTION_DECL,\n-\t                                  get_identifier (name),\n-\t                                  tmp);\n-\t      DECL_EXTERNAL (dcast_fn) = 1;\n-\t      TREE_PUBLIC (dcast_fn) = 1;\n-\t      DECL_ARTIFICIAL (dcast_fn) = 1;\n-\t      TREE_NOTHROW (dcast_fn) = 1;\n-\t      pushdecl (dcast_fn);\n \t      if (new_abi_rtti_p ())\n-\t        /* We want its name mangling.  */\n-\t        set_mangled_name_for_decl (dcast_fn);\n-\t      make_function_rtl (dcast_fn);\n+\t\t/* We want its name mangling.  */\n+\t\tdcast_fn = build_cp_library_fn_ptr (name, tmp);\n+\t      else\n+\t\tdcast_fn = build_library_fn_ptr (name, tmp);\n               pop_nested_namespace (ns);\n               dynamic_cast_node = dcast_fn;\n \t    }\n-\t  mark_used (dcast_fn);\n-          result = build_call\n-\t    (dcast_fn, TREE_TYPE (TREE_TYPE (dcast_fn)), elems);\n+          result = build_call (dcast_fn, elems);\n \n \t  if (tc == REFERENCE_TYPE)\n \t    {\n@@ -912,19 +865,10 @@ expand_si_desc (tdecl, type)\n \t (NULL_TREE, const_string_type_node, tree_cons\n \t  (NULL_TREE, build_pointer_type (type_info_type_node),\n \t   void_list_node)));\n-      tmp = build_function_type\t(void_type_node, tmp);\n-  \n-      fn = build_lang_decl (FUNCTION_DECL, fn, tmp);\n-      DECL_EXTERNAL (fn) = 1;\n-      TREE_PUBLIC (fn) = 1;\n-      DECL_ARTIFICIAL (fn) = 1;\n-      TREE_NOTHROW (fn) = 1;\n-      pushdecl_top_level (fn);\n-      make_function_rtl (fn);\n+      fn = push_void_library_fn (fn, tmp);\n     }\n \n-  mark_used (fn);\n-  fn = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), elems);\n+  fn = build_call (fn, elems);\n   finish_expr_stmt (fn);\n }\n \n@@ -1072,19 +1016,11 @@ expand_class_desc (tdecl, type)\n \t (NULL_TREE, const_string_type_node, tree_cons\n \t  (NULL_TREE, build_pointer_type (base_desc_type_node), tree_cons\n \t   (NULL_TREE, sizetype, void_list_node))));\n-      tmp = build_function_type\t(void_type_node, tmp);\n-  \n-      fn = build_lang_decl (FUNCTION_DECL, fn, tmp);\n-      DECL_EXTERNAL (fn) = 1;\n-      TREE_PUBLIC (fn) = 1;\n-      DECL_ARTIFICIAL (fn) = 1;\n-      TREE_NOTHROW (fn) = 1;\n-      pushdecl_top_level (fn);\n-      make_function_rtl (fn);\n+\n+      fn = push_void_library_fn (fn, tmp);\n     }\n \n-  mark_used (fn);\n-  fn = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), elems);\n+  fn = build_call (fn, elems);\n   finish_expr_stmt (fn);\n }\n \n@@ -1117,19 +1053,10 @@ expand_ptr_desc (tdecl, type)\n \t (NULL_TREE, const_string_type_node, tree_cons\n \t  (NULL_TREE, build_pointer_type (type_info_type_node),\n \t   void_list_node)));\n-      tmp = build_function_type\t(void_type_node, tmp);\n-  \n-      fn = build_lang_decl (FUNCTION_DECL, fn, tmp);\n-      DECL_EXTERNAL (fn) = 1;\n-      TREE_PUBLIC (fn) = 1;\n-      DECL_ARTIFICIAL (fn) = 1;\n-      TREE_NOTHROW (fn) = 1;\n-      pushdecl_top_level (fn);\n-      make_function_rtl (fn);\n+      fn = push_void_library_fn (fn, tmp);\n     }\n \n-  mark_used (fn);\n-  fn = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), elems);\n+  fn = build_call (fn, elems);\n   finish_expr_stmt (fn);\n }\n \n@@ -1163,19 +1090,10 @@ expand_attr_desc (tdecl, type)\n \t  (NULL_TREE, integer_type_node, tree_cons\n \t   (NULL_TREE, build_pointer_type (type_info_type_node),\n \t    void_list_node))));\n-      tmp = build_function_type\t(void_type_node, tmp);\n-  \n-      fn = build_lang_decl (FUNCTION_DECL, fn, tmp);\n-      DECL_EXTERNAL (fn) = 1;\n-      TREE_PUBLIC (fn) = 1;\n-      DECL_ARTIFICIAL (fn) = 1;\n-      TREE_NOTHROW (fn) = 1;\n-      pushdecl_top_level (fn);\n-      make_function_rtl (fn);\n+      fn = push_void_library_fn (fn, tmp);\n     }\n \n-  mark_used (fn);\n-  fn = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), elems);\n+  fn = build_call (fn, elems);\n   finish_expr_stmt (fn);\n }\n \n@@ -1201,19 +1119,10 @@ expand_generic_desc (tdecl, type, fnname)\n       tmp = tree_cons\n \t(NULL_TREE, ptr_type_node, tree_cons\n \t (NULL_TREE, const_string_type_node, void_list_node));\n-      tmp = build_function_type (void_type_node, tmp);\n-  \n-      fn = build_lang_decl (FUNCTION_DECL, fn, tmp);\n-      DECL_EXTERNAL (fn) = 1;\n-      TREE_PUBLIC (fn) = 1;\n-      DECL_ARTIFICIAL (fn) = 1;\n-      TREE_NOTHROW (fn) = 1;\n-      pushdecl_top_level (fn);\n-      make_function_rtl (fn);\n+      fn = push_void_library_fn (fn, tmp);\n     }\n \n-  mark_used (fn);\n-  fn = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), elems);\n+  fn = build_call (fn, elems);\n   finish_expr_stmt (fn);\n }\n "}, {"sha": "aed8bb308d3a893fc40c25211846cc125ef67408", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c11ada67b89f4103c6c4abf680149bc3dee0959/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c11ada67b89f4103c6c4abf680149bc3dee0959/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=0c11ada67b89f4103c6c4abf680149bc3dee0959", "patch": "@@ -3046,8 +3046,8 @@ build_function_call_real (function, params, require_complete, flags)\n     }\n \n   /* C++ */\n-  value_type = TREE_TYPE (fntype) ? TREE_TYPE (fntype) : void_type_node;\n-  result = build_call (function, value_type, coerced_params);\n+  result = build_call (function, coerced_params);\n+  value_type = TREE_TYPE (result);\n \n   if (require_complete)\n     {"}]}