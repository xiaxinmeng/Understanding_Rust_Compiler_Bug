{"sha": "e1543e694dadf1ea70eb72325219bc0cdc914a35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE1NDNlNjk0ZGFkZjFlYTcwZWI3MjMyNTIxOWJjMGNkYzkxNGEzNQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-04-28T16:46:01Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-04-28T16:56:51Z"}, "message": "libstdc++: Simplify std::pair constraints using concepts\n\nThis re-implements the constraints on the std::pair constructors and\nassignment operators in C++20 mode, to use concepts.\n\nThe non-standard constructors deprecated for PR 99957 are no longer\nsupported in C++20 mode, which requires some minor testsuite changes.\nOtherwise all tests pass in C++20 mode.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/stl_pair.h (pair) [__cplusplus > 202002]: Add\n\tnew definitions for constructors and assignment operators using\n\tconcepts for constraints.\n\t* testsuite/20_util/pair/cons/99957.cc: Disable for C++20 and\n\tlater.\n\t* testsuite/20_util/pair/cons/explicit_construct.cc: Adjust\n\texpected error messages to also match C++20 errors.", "tree": {"sha": "36e3876b1d3f5e82b548f7906df902ee1198d902", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36e3876b1d3f5e82b548f7906df902ee1198d902"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1543e694dadf1ea70eb72325219bc0cdc914a35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1543e694dadf1ea70eb72325219bc0cdc914a35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1543e694dadf1ea70eb72325219bc0cdc914a35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1543e694dadf1ea70eb72325219bc0cdc914a35/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d96db15967e78d7cecea3b1cf3169ceb924678ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d96db15967e78d7cecea3b1cf3169ceb924678ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d96db15967e78d7cecea3b1cf3169ceb924678ac"}], "stats": {"total": 231, "additions": 193, "deletions": 38}, "files": [{"sha": "c89f377fddc504736d2cf70389462aa314d974c3", "filename": "libstdc++-v3/include/bits/stl_pair.h", "status": "modified", "additions": 188, "deletions": 33, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1543e694dadf1ea70eb72325219bc0cdc914a35/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1543e694dadf1ea70eb72325219bc0cdc914a35/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h?ref=e1543e694dadf1ea70eb72325219bc0cdc914a35", "patch": "@@ -92,6 +92,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<size_t...>\n     struct _Index_tuple;\n \n+#if ! __cpp_lib_concepts\n   // Concept utility functions, reused in conditionally-explicit\n   // constructors.\n   // See PR 70437, don't look at is_constructible or\n@@ -171,11 +172,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn false;\n       }\n     };\n+#endif // lib concepts\n #endif // C++11\n \n   template<typename _U1, typename _U2> class __pair_base\n   {\n-#if __cplusplus >= 201103L\n+#if __cplusplus >= 201103L && ! __cpp_lib_concepts\n     template<typename _T1, typename _T2> friend struct pair;\n     __pair_base() = default;\n     ~__pair_base() = default;\n@@ -196,7 +198,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n   template<typename _T1, typename _T2>\n     struct pair\n-    : private __pair_base<_T1, _T2>\n+    : public __pair_base<_T1, _T2>\n     {\n       typedef _T1 first_type;    ///< The type of the `first` member\n       typedef _T2 second_type;   ///< The type of the `second` member\n@@ -205,7 +207,186 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _T2 second;                ///< The second member\n \n #if __cplusplus >= 201103L\n-      // C++11 (and later) implementation.\n+      constexpr pair(const pair&) = default;\t///< Copy constructor\n+      constexpr pair(pair&&) = default;\t\t///< Move constructor\n+\n+      template<typename... _Args1, typename... _Args2>\n+\t_GLIBCXX20_CONSTEXPR\n+\tpair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);\n+\n+      /// Swap the first members and then the second members.\n+      _GLIBCXX20_CONSTEXPR void\n+      swap(pair& __p)\n+      noexcept(__and_<__is_nothrow_swappable<_T1>,\n+\t\t      __is_nothrow_swappable<_T2>>::value)\n+      {\n+\tusing std::swap;\n+\tswap(first, __p.first);\n+\tswap(second, __p.second);\n+      }\n+\n+    private:\n+      template<typename... _Args1, size_t... _Indexes1,\n+\t       typename... _Args2, size_t... _Indexes2>\n+\t_GLIBCXX20_CONSTEXPR\n+\tpair(tuple<_Args1...>&, tuple<_Args2...>&,\n+\t     _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);\n+    public:\n+\n+#if __cpp_lib_concepts\n+      // C++20 implementation using concepts, explicit(bool), fully constexpr.\n+\n+      /// Default constructor\n+      constexpr\n+      explicit(__not_<__and_<__is_implicitly_default_constructible<_T1>,\n+\t\t\t     __is_implicitly_default_constructible<_T2>>>())\n+      pair()\n+      requires is_default_constructible_v<_T1>\n+\t       && is_default_constructible_v<_T2>\n+      : first(), second()\n+      { }\n+\n+    private:\n+\n+      /// @cond undocumented\n+      template<typename _U1, typename _U2>\n+\tstatic constexpr bool\n+\t_S_constructible()\n+\t{\n+\t  if constexpr (is_constructible_v<_T1, _U1>)\n+\t    return is_constructible_v<_T2, _U2>;\n+\t  return false;\n+\t}\n+\n+      template<typename _U1, typename _U2>\n+\tstatic constexpr bool\n+\t_S_nothrow_constructible()\n+\t{\n+\t  if constexpr (is_nothrow_constructible_v<_T1, _U1>)\n+\t    return is_nothrow_constructible_v<_T2, _U2>;\n+\t  return false;\n+\t}\n+\n+      template<typename _U1, typename _U2>\n+\tstatic constexpr bool\n+\t_S_convertible()\n+\t{\n+\t  if constexpr (is_convertible_v<_U1, _T1>)\n+\t    return is_convertible_v<_U2, _T2>;\n+\t  return false;\n+\t}\n+      /// @endcond\n+\n+    public:\n+\n+      /// Constructor accepting lvalues of `first_type` and `second_type`\n+      constexpr explicit(!_S_convertible<const _T1&, const _T2&>())\n+      pair(const _T1& __x, const _T2& __y)\n+      noexcept(_S_nothrow_constructible<const _T1&, const _T2&>())\n+      requires (_S_constructible<const _T1&, const _T2&>())\n+      : first(__x), second(__y)\n+      { }\n+\n+      /// Constructor accepting two values of arbitrary types\n+      template<typename _U1, typename _U2>\n+\trequires (_S_constructible<_U1, _U2>())\n+\tconstexpr explicit(!_S_convertible<_U1, _U2>())\n+\tpair(_U1&& __x, _U2&& __y)\n+\tnoexcept(_S_nothrow_constructible<_U1, _U2>())\n+\t: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))\n+\t{ }\n+\n+      /// Converting constructor from a `pair<U1, U2>` lvalue\n+      template<typename _U1, typename _U2>\n+\trequires (_S_constructible<const _U1&, const _U2&>())\n+\tconstexpr explicit(!_S_convertible<const _U1&, const _U2&>())\n+\tpair(const pair<_U1, _U2>& __p)\n+\tnoexcept(_S_nothrow_constructible<const _U1&, const _U2&>())\n+\t: first(__p.first), second(__p.second)\n+\t{ }\n+\n+      /// Converting constructor from a `pair<U1, U2>` rvalue\n+      template<typename _U1, typename _U2>\n+\trequires (_S_constructible<_U1, _U2>())\n+\tconstexpr explicit(!_S_convertible<_U1, _U2>())\n+\tpair(pair<_U1, _U2>&& __p)\n+\tnoexcept(_S_nothrow_constructible<_U1, _U2>())\n+\t: first(std::forward<_U1>(__p.first)),\n+\t  second(std::forward<_U2>(__p.second))\n+\t{ }\n+\n+  private:\n+      /// @cond undocumented\n+      template<typename _U1, typename _U2>\n+\tstatic constexpr bool\n+\t_S_assignable()\n+\t{\n+\t  if constexpr (is_assignable_v<_T1&, _U1>)\n+\t    return is_assignable_v<_T2&, _U2>;\n+\t  return false;\n+\t}\n+\n+      template<typename _U1, typename _U2>\n+\tstatic constexpr bool\n+\t_S_nothrow_assignable()\n+\t{\n+\t  if constexpr (is_nothrow_assignable_v<_T1&, _U1>)\n+\t    return is_nothrow_assignable_v<_T2&, _U2>;\n+\t  return false;\n+\t}\n+      /// @endcond\n+\n+  public:\n+\n+      pair& operator=(const pair&) = delete;\n+\n+      /// Copy assignment operator\n+      constexpr pair&\n+      operator=(const pair& __p)\n+      noexcept(_S_nothrow_assignable<const _T1&, const _T2&>())\n+      requires (_S_assignable<const _T1&, const _T2&>())\n+      {\n+\tfirst = __p.first;\n+\tsecond = __p.second;\n+\treturn *this;\n+      }\n+\n+      /// Move assignment operator\n+      constexpr pair&\n+      operator=(pair&& __p)\n+      noexcept(_S_nothrow_assignable<_T1, _T2>())\n+      requires (_S_assignable<_T1, _T2>())\n+      {\n+\tfirst = std::forward<first_type>(__p.first);\n+\tsecond = std::forward<second_type>(__p.second);\n+\treturn *this;\n+      }\n+\n+      /// Converting assignment from a `pair<U1, U2>` lvalue\n+      template<typename _U1, typename _U2>\n+\tconstexpr pair&\n+\toperator=(const pair<_U1, _U2>& __p)\n+\tnoexcept(_S_nothrow_assignable<const _U1&, const _U2&>())\n+\trequires (_S_assignable<const _U1&, const _U2&>())\n+\t{\n+\t  first = __p.first;\n+\t  second = __p.second;\n+\t  return *this;\n+\t}\n+\n+      /// Converting assignment from a `pair<U1, U2>` rvalue\n+      template<typename _U1, typename _U2>\n+\tconstexpr pair&\n+\toperator=(pair<_U1, _U2>&& __p)\n+\tnoexcept(_S_nothrow_assignable<_U1, _U2>())\n+\trequires (_S_assignable<_U1, _U2>())\n+\t{\n+\t  first = std::forward<_U1>(__p.first);\n+\t  second = std::forward<_U2>(__p.second);\n+\t  return *this;\n+\t}\n+#else\n+      // C++11/14/17 implementation using enable_if, partially constexpr.\n \n       /** The default constructor creates @c first and @c second using their\n        *  respective default constructors.  */\n@@ -281,9 +462,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \texplicit constexpr pair(const pair<_U1, _U2>& __p)\n \t: first(__p.first), second(__p.second) { }\n \n-      constexpr pair(const pair&) = default;\t///< Copy constructor\n-      constexpr pair(pair&&) = default;\t\t///< Move constructor\n-\n #if _GLIBCXX_USE_DEPRECATED\n     private:\n       /// @cond undocumented\n@@ -341,7 +519,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        _GLIBCXX_DEPRECATED_SUGGEST(\"nullptr\")\n        explicit pair(__null_ptr_constant, _U2&& __y)\n        : first(nullptr), second(std::forward<_U2>(__y)) { }\n-#endif // _GLIBCXX_USE_DEPRECATED\n+#endif\n \n       template<typename _U1, typename _U2, typename\n \t       enable_if<_PCCP::template\n@@ -382,11 +560,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t: first(std::forward<_U1>(__p.first)),\n \t  second(std::forward<_U2>(__p.second)) { }\n \n-      template<typename... _Args1, typename... _Args2>\n-\t_GLIBCXX20_CONSTEXPR\n-        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);\n-\n-      _GLIBCXX20_CONSTEXPR pair&\n+      pair&\n       operator=(typename conditional<\n \t\t__and_<is_copy_assignable<_T1>,\n \t\t       is_copy_assignable<_T2>>::value,\n@@ -397,7 +571,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn *this;\n       }\n \n-      _GLIBCXX20_CONSTEXPR pair&\n+      pair&\n       operator=(typename conditional<\n \t\t__and_<is_move_assignable<_T1>,\n \t\t       is_move_assignable<_T2>>::value,\n@@ -411,7 +585,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       template<typename _U1, typename _U2>\n-\t_GLIBCXX20_CONSTEXPR\n \ttypename enable_if<__and_<is_assignable<_T1&, const _U1&>,\n \t\t\t\t  is_assignable<_T2&, const _U2&>>::value,\n \t\t\t   pair&>::type\n@@ -423,7 +596,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n \n       template<typename _U1, typename _U2>\n-\t_GLIBCXX20_CONSTEXPR\n \ttypename enable_if<__and_<is_assignable<_T1&, _U1&&>,\n \t\t\t\t  is_assignable<_T2&, _U2&&>>::value,\n \t\t\t   pair&>::type\n@@ -433,24 +605,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  second = std::forward<_U2>(__p.second);\n \t  return *this;\n \t}\n-\n-      /// Swap the first members and then the second members.\n-      _GLIBCXX20_CONSTEXPR void\n-      swap(pair& __p)\n-      noexcept(__and_<__is_nothrow_swappable<_T1>,\n-                      __is_nothrow_swappable<_T2>>::value)\n-      {\n-\tusing std::swap;\n-\tswap(first, __p.first);\n-\tswap(second, __p.second);\n-      }\n-\n-    private:\n-      template<typename... _Args1, size_t... _Indexes1,\n-\t       typename... _Args2, size_t... _Indexes2>\n-\t_GLIBCXX20_CONSTEXPR\n-        pair(tuple<_Args1...>&, tuple<_Args2...>&,\n-\t     _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);\n+#endif // lib concepts\n #else\n       // C++03 implementation\n "}, {"sha": "150bcd57c9a8a8a42dcb401ed6601f5702a9b48c", "filename": "libstdc++-v3/testsuite/20_util/pair/cons/99957.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1543e694dadf1ea70eb72325219bc0cdc914a35/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2F99957.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1543e694dadf1ea70eb72325219bc0cdc914a35/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2F99957.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2F99957.cc?ref=e1543e694dadf1ea70eb72325219bc0cdc914a35", "patch": "@@ -1,5 +1,5 @@\n // { dg-options \"-Wdeprecated\" }\n-// { dg-do compile { target c++11 } }\n+// { dg-do compile { target { c++11 && { ! c++20 } } } }\n \n #include <utility>\n "}, {"sha": "ecd5acf93752637e7a7485adba01a683ccc52355", "filename": "libstdc++-v3/testsuite/20_util/pair/cons/explicit_construct.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1543e694dadf1ea70eb72325219bc0cdc914a35/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2Fexplicit_construct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1543e694dadf1ea70eb72325219bc0cdc914a35/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2Fexplicit_construct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2Fexplicit_construct.cc?ref=e1543e694dadf1ea70eb72325219bc0cdc914a35", "patch": "@@ -83,12 +83,12 @@ void f7(std::pair<long, long>) {}\n \n std::pair<ExplicitDefault, int> f8()\n {\n-  return {}; // { dg-error \"could not convert\" }\n+  return {}; // { dg-error \"convert\" }\n }\n \n std::pair<ExplicitDefaultDefault, int> f9()\n {\n-  return {}; // { dg-error \"could not convert\" }\n+  return {}; // { dg-error \"convert\" }\n }\n \n void f10(std::pair<ExplicitDefault, int>) {}\n@@ -107,8 +107,8 @@ void test_arg_passing()\n   f7({1,2});\n   f7(std::pair<int, int>{});\n   f7(std::pair<long, long>{});\n-  f10({}); // { dg-error \"could not convert\" }\n-  f11({}); // { dg-error \"could not convert\" }\n+  f10({}); // { dg-error \"convert\" }\n+  f11({}); // { dg-error \"convert\" }\n   f10(std::pair<ExplicitDefault, int>{});\n   f11(std::pair<ExplicitDefaultDefault, int>{});\n }"}]}