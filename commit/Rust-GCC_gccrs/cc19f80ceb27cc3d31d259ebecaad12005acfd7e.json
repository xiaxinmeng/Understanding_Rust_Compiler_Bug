{"sha": "cc19f80ceb27cc3d31d259ebecaad12005acfd7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MxOWY4MGNlYjI3Y2MzZDMxZDI1OWViZWNhYWQxMjAwNWFjZmQ3ZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-08-16T09:27:34Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-08-16T09:27:34Z"}, "message": "tree-ssa-forwprop.c (simplify_builtin_call): Do not remove stmt at gsi_p, instead replace it with a NOP removed later.\n\n2019-08-16  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-forwprop.c (simplify_builtin_call): Do not remove\n\tstmt at gsi_p, instead replace it with a NOP removed later.\n\t(pass_forwprop::execute): Fully propagate lattice, DCE stmts\n\tthat became dead because of that.\n\n\tfortran/\n\t* trans-intrinsic.c (gfc_conv_intrinsic_findloc): Initialize\n\tforward_branch to avoid bogus uninitialized warning.\n\n\t* gcc.dg/tree-ssa/forwprop-31.c: Adjust.\n\nFrom-SVN: r274563", "tree": {"sha": "c87e2dd89dcabb30f509577e048f53061fba1d1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c87e2dd89dcabb30f509577e048f53061fba1d1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc19f80ceb27cc3d31d259ebecaad12005acfd7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc19f80ceb27cc3d31d259ebecaad12005acfd7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc19f80ceb27cc3d31d259ebecaad12005acfd7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc19f80ceb27cc3d31d259ebecaad12005acfd7e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4f4af789f94ee71f69155770291bd94c91c4109a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f4af789f94ee71f69155770291bd94c91c4109a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f4af789f94ee71f69155770291bd94c91c4109a"}], "stats": {"total": 338, "additions": 216, "deletions": 122}, "files": [{"sha": "e447aabb367205d8aba97577b84945345cfd1b2b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc19f80ceb27cc3d31d259ebecaad12005acfd7e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc19f80ceb27cc3d31d259ebecaad12005acfd7e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc19f80ceb27cc3d31d259ebecaad12005acfd7e", "patch": "@@ -1,3 +1,10 @@\n+2019-08-16  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-forwprop.c (simplify_builtin_call): Do not remove\n+\tstmt at gsi_p, instead replace it with a NOP removed later.\n+\t(pass_forwprop::execute): Fully propagate lattice, DCE stmts\n+\tthat became dead because of that.\n+\n 2019-08-16  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* gimple-ssa-evrp-analyze.c (record_ranges_from_phis): Skip PHIs"}, {"sha": "e745f48bddda82402297cd47b5a3e08142a63574", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc19f80ceb27cc3d31d259ebecaad12005acfd7e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc19f80ceb27cc3d31d259ebecaad12005acfd7e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=cc19f80ceb27cc3d31d259ebecaad12005acfd7e", "patch": "@@ -1,3 +1,8 @@\n+2019-08-16  Richard Biener  <rguenther@suse.de>\n+\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_findloc): Initialize\n+\tforward_branch to avoid bogus uninitialized warning.\n+\n 2019-08-15  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/91443"}, {"sha": "26ea624101d08931b272b4ac40395fd47e3ab9d3", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc19f80ceb27cc3d31d259ebecaad12005acfd7e/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc19f80ceb27cc3d31d259ebecaad12005acfd7e/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=cc19f80ceb27cc3d31d259ebecaad12005acfd7e", "patch": "@@ -5428,7 +5428,7 @@ gfc_conv_intrinsic_findloc (gfc_se *se, gfc_expr *expr)\n   tree type;\n   tree tmp;\n   tree found;\n-  tree forward_branch;\n+  tree forward_branch = NULL_TREE;\n   tree back_branch;\n   gfc_loopinfo loop;\n   gfc_ss *arrayss;"}, {"sha": "cbe637eaca1d06f964654359dc21bfb0d536c057", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc19f80ceb27cc3d31d259ebecaad12005acfd7e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc19f80ceb27cc3d31d259ebecaad12005acfd7e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cc19f80ceb27cc3d31d259ebecaad12005acfd7e", "patch": "@@ -1,3 +1,7 @@\n+2019-08-16  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/forwprop-31.c: Adjust.\n+\n 2019-08-16  Martin Liska  <mliska@suse.cz>\n \n \tPR ipa/91447"}, {"sha": "edf8026488406718222298216c5cf460bd36fe72", "filename": "gcc/testsuite/gcc.dg/tree-ssa/forwprop-31.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc19f80ceb27cc3d31d259ebecaad12005acfd7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc19f80ceb27cc3d31d259ebecaad12005acfd7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-31.c?ref=cc19f80ceb27cc3d31d259ebecaad12005acfd7e", "patch": "@@ -9,7 +9,6 @@ int foo (int x)\n   return w - z; /* becomes 0 */\n }\n \n-/* The original y = 0 stmt is also retained.  */\n-/* { dg-final { scan-tree-dump-times \"= 0;\" 2 \"forwprop1\" } } */\n-/* { dg-final { scan-tree-dump-times \"-\" 0 \"forwprop1\" } } */\n-/* { dg-final { scan-tree-dump-times \"\\\\+\" 1 \"forwprop1\" } } */\n+/* Only z = x + 1 is retained.  */\n+/* { dg-final { scan-tree-dump-times \" = \" 1 \"forwprop1\" } } */\n+/* { dg-final { scan-tree-dump \"return 0;\" \"forwprop1\" } } */"}, {"sha": "c464c8995861022d6c553249751f678ebdf521df", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 196, "deletions": 117, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc19f80ceb27cc3d31d259ebecaad12005acfd7e/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc19f80ceb27cc3d31d259ebecaad12005acfd7e/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=cc19f80ceb27cc3d31d259ebecaad12005acfd7e", "patch": "@@ -1403,7 +1403,7 @@ simplify_builtin_call (gimple_stmt_iterator *gsi_p, tree callee2)\n \t\t\t\t   build_int_cst (TREE_TYPE (len1), src_len));\n \t      update_stmt (stmt1);\n \t      unlink_stmt_vdef (stmt2);\n-\t      gsi_remove (gsi_p, true);\n+\t      gsi_replace (gsi_p, gimple_build_nop (), false);\n \t      fwprop_invalidate_lattice (gimple_get_lhs (stmt2));\n \t      release_defs (stmt2);\n \t      if (lhs1 && DECL_FUNCTION_CODE (callee1) == BUILT_IN_MEMPCPY)\n@@ -2299,13 +2299,14 @@ pass_forwprop::execute (function *fun)\n   int postorder_num = pre_and_rev_post_order_compute_fn (cfun, NULL,\n \t\t\t\t\t\t\t postorder, false);\n   auto_vec<gimple *, 4> to_fixup;\n+  auto_vec<gimple *, 32> to_remove;\n   to_purge = BITMAP_ALLOC (NULL);\n   for (int i = 0; i < postorder_num; ++i)\n     {\n       gimple_stmt_iterator gsi;\n       basic_block bb = BASIC_BLOCK_FOR_FN (fun, postorder[i]);\n \n-      /* Propagate into PHIs and record degenerate ones in the lattice.  */\n+      /* Record degenerate PHIs in the lattice.  */\n       for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);\n \t   gsi_next (&si))\n \t{\n@@ -2321,17 +2322,20 @@ pass_forwprop::execute (function *fun)\n \t  FOR_EACH_PHI_ARG (use_p, phi, it, SSA_OP_USE)\n \t    {\n \t      tree use = USE_FROM_PTR (use_p);\n-\t      tree tem = fwprop_ssa_val (use);\n \t      if (! first)\n-\t\tfirst = tem;\n-\t      else if (! operand_equal_p (first, tem, 0))\n-\t\tall_same = false;\n-\t      if (tem != use\n-\t\t  && may_propagate_copy (use, tem))\n-\t\tpropagate_value (use_p, tem);\n+\t\tfirst = use;\n+\t      else if (! operand_equal_p (first, use, 0))\n+\t\t{\n+\t\t  all_same = false;\n+\t\t  break;\n+\t\t}\n \t    }\n \t  if (all_same)\n-\t    fwprop_set_lattice_val (res, first);\n+\t    {\n+\t      if (may_propagate_copy (res, first))\n+\t\tto_remove.safe_push (phi);\n+\t      fwprop_set_lattice_val (res, first);\n+\t    }\n \t}\n \n       /* Apply forward propagation to all stmts in the basic-block.\n@@ -2648,148 +2652,223 @@ pass_forwprop::execute (function *fun)\n \n       /* Combine stmts with the stmts defining their operands.\n \t Note we update GSI within the loop as necessary.  */\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n-\t  gimple *orig_stmt = stmt;\n-\t  bool changed = false;\n-\t  bool was_noreturn = (is_gimple_call (stmt)\n-\t\t\t       && gimple_call_noreturn_p (stmt));\n \n \t  /* Mark stmt as potentially needing revisiting.  */\n \t  gimple_set_plf (stmt, GF_PLF_1, false);\n \n-\t  if (fold_stmt (&gsi, fwprop_ssa_val))\n+\t  /* Substitute from our lattice.  We need to do so only once.  */\n+\t  bool substituted_p = false;\n+\t  use_operand_p usep;\n+\t  ssa_op_iter iter;\n+\t  FOR_EACH_SSA_USE_OPERAND (usep, stmt, iter, SSA_OP_USE)\n \t    {\n-\t      changed = true;\n-\t      stmt = gsi_stmt (gsi);\n-\t      if (maybe_clean_or_replace_eh_stmt (orig_stmt, stmt))\n-\t\tbitmap_set_bit (to_purge, bb->index);\n-\t      if (!was_noreturn\n-\t\t  && is_gimple_call (stmt) && gimple_call_noreturn_p (stmt))\n-\t\tto_fixup.safe_push (stmt);\n-\t      /* Cleanup the CFG if we simplified a condition to\n-\t         true or false.  */\n-\t      if (gcond *cond = dyn_cast <gcond *> (stmt))\n-\t\tif (gimple_cond_true_p (cond)\n-\t\t    || gimple_cond_false_p (cond))\n-\t\t  cfg_changed = true;\n-\t      update_stmt (stmt);\n+\t      tree use = USE_FROM_PTR (usep);\n+\t      tree val = fwprop_ssa_val (use);\n+\t      if (val && val != use && may_propagate_copy (use, val))\n+\t\t{\n+\t\t  propagate_value (usep, val);\n+\t\t  substituted_p = true;\n+\t\t}\n \t    }\n+\t  if (substituted_p\n+\t      && is_gimple_assign (stmt)\n+\t      && gimple_assign_rhs_code (stmt) == ADDR_EXPR)\n+\t    recompute_tree_invariant_for_addr_expr (gimple_assign_rhs1 (stmt));\n \n-\t  switch (gimple_code (stmt))\n+\t  bool changed;\n+\t  do\n \t    {\n-\t    case GIMPLE_ASSIGN:\n-\t      {\n-\t\ttree rhs1 = gimple_assign_rhs1 (stmt);\n-\t\tenum tree_code code = gimple_assign_rhs_code (stmt);\n+\t      gimple *orig_stmt = stmt = gsi_stmt (gsi);\n+\t      bool was_noreturn = (is_gimple_call (stmt)\n+\t\t\t\t   && gimple_call_noreturn_p (stmt));\n+\t      changed = false;\n \n-\t\tif (code == COND_EXPR\n-\t\t    || code == VEC_COND_EXPR)\n+\t      if (fold_stmt (&gsi, fwprop_ssa_val))\n+\t\t{\n+\t\t  changed = true;\n+\t\t  stmt = gsi_stmt (gsi);\n+\t\t  /* Cleanup the CFG if we simplified a condition to\n+\t\t     true or false.  */\n+\t\t  if (gcond *cond = dyn_cast <gcond *> (stmt))\n+\t\t    if (gimple_cond_true_p (cond)\n+\t\t\t|| gimple_cond_false_p (cond))\n+\t\t      cfg_changed = true;\n+\t\t}\n+\n+\t      if (changed || substituted_p)\n+\t\t{\n+\t\t  if (maybe_clean_or_replace_eh_stmt (orig_stmt, stmt))\n+\t\t    bitmap_set_bit (to_purge, bb->index);\n+\t\t  if (!was_noreturn\n+\t\t      && is_gimple_call (stmt) && gimple_call_noreturn_p (stmt))\n+\t\t    to_fixup.safe_push (stmt);\n+\t\t  update_stmt (stmt);\n+\t\t  substituted_p = false;\n+\t\t}\n+\n+\t      switch (gimple_code (stmt))\n+\t\t{\n+\t\tcase GIMPLE_ASSIGN:\n \t\t  {\n-\t\t    /* In this case the entire COND_EXPR is in rhs1. */\n-\t\t    if (forward_propagate_into_cond (&gsi))\n+\t\t    tree rhs1 = gimple_assign_rhs1 (stmt);\n+\t\t    enum tree_code code = gimple_assign_rhs_code (stmt);\n+\n+\t\t    if (code == COND_EXPR\n+\t\t\t|| code == VEC_COND_EXPR)\n \t\t      {\n-\t\t\tchanged = true;\n-\t\t\tstmt = gsi_stmt (gsi);\n+\t\t\t/* In this case the entire COND_EXPR is in rhs1. */\n+\t\t\tif (forward_propagate_into_cond (&gsi))\n+\t\t\t  {\n+\t\t\t    changed = true;\n+\t\t\t    stmt = gsi_stmt (gsi);\n+\t\t\t  }\n \t\t      }\n+\t\t    else if (TREE_CODE_CLASS (code) == tcc_comparison)\n+\t\t      {\n+\t\t\tint did_something;\n+\t\t\tdid_something = forward_propagate_into_comparison (&gsi);\n+\t\t\tif (maybe_clean_or_replace_eh_stmt (stmt, gsi_stmt (gsi)))\n+\t\t\t  bitmap_set_bit (to_purge, bb->index);\n+\t\t\tif (did_something == 2)\n+\t\t\t  cfg_changed = true;\n+\t\t\tchanged = did_something != 0;\n+\t\t      }\n+\t\t    else if ((code == PLUS_EXPR\n+\t\t\t      || code == BIT_IOR_EXPR\n+\t\t\t      || code == BIT_XOR_EXPR)\n+\t\t\t     && simplify_rotate (&gsi))\n+\t\t      changed = true;\n+\t\t    else if (code == VEC_PERM_EXPR)\n+\t\t      {\n+\t\t\tint did_something = simplify_permutation (&gsi);\n+\t\t\tif (did_something == 2)\n+\t\t\t  cfg_changed = true;\n+\t\t\tchanged = did_something != 0;\n+\t\t      }\n+\t\t    else if (code == BIT_FIELD_REF)\n+\t\t      changed = simplify_bitfield_ref (&gsi);\n+\t\t    else if (code == CONSTRUCTOR\n+\t\t\t     && TREE_CODE (TREE_TYPE (rhs1)) == VECTOR_TYPE)\n+\t\t      changed = simplify_vector_constructor (&gsi);\n+\t\t    break;\n \t\t  }\n-\t\telse if (TREE_CODE_CLASS (code) == tcc_comparison)\n+\n+\t\tcase GIMPLE_SWITCH:\n+\t\t  changed = simplify_gimple_switch (as_a <gswitch *> (stmt));\n+\t\t  break;\n+\n+\t\tcase GIMPLE_COND:\n \t\t  {\n-\t\t    int did_something;\n-\t\t    did_something = forward_propagate_into_comparison (&gsi);\n-\t\t    if (maybe_clean_or_replace_eh_stmt (stmt, gsi_stmt (gsi)))\n-\t\t      bitmap_set_bit (to_purge, bb->index);\n+\t\t    int did_something = forward_propagate_into_gimple_cond\n+\t\t\t\t\t\t\t(as_a <gcond *> (stmt));\n \t\t    if (did_something == 2)\n \t\t      cfg_changed = true;\n \t\t    changed = did_something != 0;\n+\t\t    break;\n \t\t  }\n-\t\telse if ((code == PLUS_EXPR\n-\t\t\t  || code == BIT_IOR_EXPR\n-\t\t\t  || code == BIT_XOR_EXPR)\n-\t\t\t && simplify_rotate (&gsi))\n-\t\t  changed = true;\n-\t\telse if (code == VEC_PERM_EXPR)\n+\n+\t\tcase GIMPLE_CALL:\n \t\t  {\n-\t\t    int did_something = simplify_permutation (&gsi);\n-\t\t    if (did_something == 2)\n-\t\t      cfg_changed = true;\n-\t\t    changed = did_something != 0;\n+\t\t    tree callee = gimple_call_fndecl (stmt);\n+\t\t    if (callee != NULL_TREE\n+\t\t\t&& fndecl_built_in_p (callee, BUILT_IN_NORMAL))\n+\t\t      changed = simplify_builtin_call (&gsi, callee);\n+\t\t    break;\n \t\t  }\n-\t\telse if (code == BIT_FIELD_REF)\n-\t\t  changed = simplify_bitfield_ref (&gsi);\n-                else if (code == CONSTRUCTOR\n-                         && TREE_CODE (TREE_TYPE (rhs1)) == VECTOR_TYPE)\n-                  changed = simplify_vector_constructor (&gsi);\n-\t\tbreak;\n-\t      }\n-\n-\t    case GIMPLE_SWITCH:\n-\t      changed = simplify_gimple_switch (as_a <gswitch *> (stmt));\n-\t      break;\n \n-\t    case GIMPLE_COND:\n-\t      {\n-\t\tint did_something\n-\t\t  = forward_propagate_into_gimple_cond (as_a <gcond *> (stmt));\n-\t\tif (did_something == 2)\n-\t\t  cfg_changed = true;\n-\t\tchanged = did_something != 0;\n-\t\tbreak;\n-\t      }\n-\n-\t    case GIMPLE_CALL:\n-\t      {\n-\t\ttree callee = gimple_call_fndecl (stmt);\n-\t\tif (callee != NULL_TREE\n-\t\t    && fndecl_built_in_p (callee, BUILT_IN_NORMAL))\n-\t\t  changed = simplify_builtin_call (&gsi, callee);\n-\t\tbreak;\n-\t      }\n+\t\tdefault:;\n+\t\t}\n \n-\t    default:;\n+\t      if (changed)\n+\t\t{\n+\t\t  /* If the stmt changed then re-visit it and the statements\n+\t\t     inserted before it.  */\n+\t\t  for (; !gsi_end_p (gsi); gsi_prev (&gsi))\n+\t\t    if (gimple_plf (gsi_stmt (gsi), GF_PLF_1))\n+\t\t      break;\n+\t\t  if (gsi_end_p (gsi))\n+\t\t    gsi = gsi_start_bb (bb);\n+\t\t  else\n+\t\t    gsi_next (&gsi);\n+\t\t}\n \t    }\n+\t  while (changed);\n \n-\t  if (changed)\n-\t    {\n-\t      /* If the stmt changed then re-visit it and the statements\n-\t\t inserted before it.  */\n-\t      for (; !gsi_end_p (gsi); gsi_prev (&gsi))\n-\t\tif (gimple_plf (gsi_stmt (gsi), GF_PLF_1))\n-\t\t  break;\n-\t      if (gsi_end_p (gsi))\n-\t\tgsi = gsi_start_bb (bb);\n-\t      else\n-\t\tgsi_next (&gsi);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Stmt no longer needs to be revisited.  */\n-\t      gimple_set_plf (stmt, GF_PLF_1, true);\n+\t  /* Stmt no longer needs to be revisited.  */\n+\t  stmt = gsi_stmt (gsi);\n+\t  gcc_checking_assert (!gimple_plf (stmt, GF_PLF_1));\n+\t  gimple_set_plf (stmt, GF_PLF_1, true);\n \n-\t      /* Fill up the lattice.  */\n-\t      if (gimple_assign_single_p (stmt))\n+\t  /* Fill up the lattice.  */\n+\t  if (gimple_assign_single_p (stmt))\n+\t    {\n+\t      tree lhs = gimple_assign_lhs (stmt);\n+\t      tree rhs = gimple_assign_rhs1 (stmt);\n+\t      if (TREE_CODE (lhs) == SSA_NAME)\n \t\t{\n-\t\t  tree lhs = gimple_assign_lhs (stmt);\n-\t\t  tree rhs = gimple_assign_rhs1 (stmt);\n-\t\t  if (TREE_CODE (lhs) == SSA_NAME)\n-\t\t    {\n-\t\t      tree val = lhs;\n-\t\t      if (TREE_CODE (rhs) == SSA_NAME)\n-\t\t\tval = fwprop_ssa_val (rhs);\n-\t\t      else if (is_gimple_min_invariant (rhs))\n-\t\t\tval = rhs;\n-\t\t      fwprop_set_lattice_val (lhs, val);\n-\t\t    }\n+\t\t  tree val = lhs;\n+\t\t  if (TREE_CODE (rhs) == SSA_NAME)\n+\t\t    val = fwprop_ssa_val (rhs);\n+\t\t  else if (is_gimple_min_invariant (rhs))\n+\t\t    val = rhs;\n+\t\t  /* If we can propagate the lattice-value mark the\n+\t\t     stmt for removal.  */\n+\t\t  if (val != lhs\n+\t\t      && may_propagate_copy (lhs, val))\n+\t\t    to_remove.safe_push (stmt);\n+\t\t  fwprop_set_lattice_val (lhs, val);\n \t\t}\n-\n-\t      gsi_next (&gsi);\n \t    }\n+\t  else if (gimple_nop_p (stmt))\n+\t    to_remove.safe_push (stmt);\n \t}\n+\n+      /* Substitute in destination PHI arguments.  */\n+      edge_iterator ei;\n+      edge e;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tfor (gphi_iterator gsi = gsi_start_phis (e->dest);\n+\t     !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  {\n+\t    gphi *phi = gsi.phi ();\n+\t    use_operand_p use_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);\n+\t    tree arg = USE_FROM_PTR (use_p);\n+\t    if (TREE_CODE (arg) != SSA_NAME\n+\t\t|| virtual_operand_p (arg))\n+\t      continue;\n+\t    tree val = fwprop_ssa_val (arg);\n+\t    if (val != arg\n+\t\t&& may_propagate_copy (arg, val))\n+\t      propagate_value (use_p, val);\n+\t  }\n     }\n   free (postorder);\n   lattice.release ();\n \n+  /* Remove stmts in reverse order to make debug stmt creation possible.  */\n+  while (!to_remove.is_empty())\n+    {\n+      gimple *stmt = to_remove.pop ();\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Removing dead stmt \");\n+\t  print_gimple_stmt (dump_file, stmt, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+      if (gimple_code (stmt) == GIMPLE_PHI)\n+\tremove_phi_node (&gsi, true);\n+      else\n+\t{\n+\t  unlink_stmt_vdef (stmt);\n+\t  gsi_remove (&gsi, true);\n+\t  release_defs (stmt);\n+\t}\n+    }\n+\n   /* Fixup stmts that became noreturn calls.  This may require splitting\n      blocks and thus isn't possible during the walk.  Do this\n      in reverse order so we don't inadvertedly remove a stmt we want to"}]}