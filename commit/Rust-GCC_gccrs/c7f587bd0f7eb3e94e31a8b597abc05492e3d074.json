{"sha": "c7f587bd0f7eb3e94e31a8b597abc05492e3d074", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdmNTg3YmQwZjdlYjNlOTRlMzFhOGI1OTdhYmMwNTQ5MmUzZDA3NA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-11-05T14:25:25Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-11-05T14:25:25Z"}, "message": "check.c (gfc_check_move_alloc): Introduce error to prevent aliasing between to and from arguments.\n\n2016-11-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* check.c (gfc_check_move_alloc): Introduce error to prevent\n\taliasing between to and from arguments.\n\n2016-11-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* gfortran.dg/move_alloc_17.f03: New test.\n\nFrom-SVN: r241872", "tree": {"sha": "47a574c53dd710543762343e4e69e8f68864bd06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47a574c53dd710543762343e4e69e8f68864bd06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7f587bd0f7eb3e94e31a8b597abc05492e3d074", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7f587bd0f7eb3e94e31a8b597abc05492e3d074", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7f587bd0f7eb3e94e31a8b597abc05492e3d074", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7f587bd0f7eb3e94e31a8b597abc05492e3d074/comments", "author": null, "committer": null, "parents": [{"sha": "92657eb0f617edeebbea1b43f3ca4a5c48702ba2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92657eb0f617edeebbea1b43f3ca4a5c48702ba2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92657eb0f617edeebbea1b43f3ca4a5c48702ba2"}], "stats": {"total": 118, "additions": 79, "deletions": 39}, "files": [{"sha": "41225b55650364a425f9053964f71a29f70628a3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7f587bd0f7eb3e94e31a8b597abc05492e3d074/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7f587bd0f7eb3e94e31a8b597abc05492e3d074/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c7f587bd0f7eb3e94e31a8b597abc05492e3d074", "patch": "@@ -1,3 +1,8 @@\n+2016-11-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* check.c (gfc_check_move_alloc): Introduce error to prevent\n+\taliasing between to and from arguments.\n+\n 2016-11-05  Janus Weil  <janus@gcc.gnu.org>\n \t    Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n "}, {"sha": "142cdac2e38e9dcaa0acae18a90bcde898aac1a5", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 49, "deletions": 39, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7f587bd0f7eb3e94e31a8b597abc05492e3d074/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7f587bd0f7eb3e94e31a8b597abc05492e3d074/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=c7f587bd0f7eb3e94e31a8b597abc05492e3d074", "patch": "@@ -880,7 +880,7 @@ gfc_check_a_p (gfc_expr *a, gfc_expr *p)\n \n   if (a->ts.kind != p->ts.kind)\n     {\n-      if (!gfc_notify_std (GFC_STD_GNU, \"Different type kinds at %L\", \n+      if (!gfc_notify_std (GFC_STD_GNU, \"Different type kinds at %L\",\n \t\t\t   &p->where))\n        return false;\n     }\n@@ -1797,7 +1797,7 @@ gfc_check_count (gfc_expr *mask, gfc_expr *dim, gfc_expr *kind)\n   if (!kind_check (kind, 2, BT_INTEGER))\n     return false;\n   if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n-\t\t\t       \"with KIND argument at %L\", \n+\t\t\t       \"with KIND argument at %L\",\n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n \n@@ -2127,11 +2127,11 @@ gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n \t}\n       else if (boundary->rank == array->rank - 1)\n \t{\n-\t  if (!gfc_check_conformance (shift, boundary, \n+\t  if (!gfc_check_conformance (shift, boundary,\n \t\t\t\t      \"arguments '%s' and '%s' for \"\n-\t\t\t\t      \"intrinsic %s\", \n-\t\t\t\t      gfc_current_intrinsic_arg[1]->name, \n-\t\t\t\t      gfc_current_intrinsic_arg[2]->name, \n+\t\t\t\t      \"intrinsic %s\",\n+\t\t\t\t      gfc_current_intrinsic_arg[1]->name,\n+\t\t\t\t      gfc_current_intrinsic_arg[2]->name,\n \t\t\t\t      gfc_current_intrinsic))\n \t    return false;\n \t}\n@@ -2156,7 +2156,7 @@ gfc_check_float (gfc_expr *a)\n \n   if ((a->ts.kind != gfc_default_integer_kind)\n       && !gfc_notify_std (GFC_STD_GNU, \"non-default INTEGER \"\n-\t\t\t  \"kind argument to %s intrinsic at %L\", \n+\t\t\t  \"kind argument to %s intrinsic at %L\",\n \t\t\t  gfc_current_intrinsic, &a->where))\n     return false;\n \n@@ -2283,7 +2283,7 @@ gfc_check_iand (gfc_expr *i, gfc_expr *j)\n \n   if (i->ts.kind != j->ts.kind)\n     {\n-      if (!gfc_notify_std (GFC_STD_GNU, \"Different type kinds at %L\", \n+      if (!gfc_notify_std (GFC_STD_GNU, \"Different type kinds at %L\",\n \t\t\t   &i->where))\n \treturn false;\n     }\n@@ -2329,7 +2329,7 @@ gfc_check_ichar_iachar (gfc_expr *c, gfc_expr *kind)\n     return false;\n \n   if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n-\t\t\t       \"with KIND argument at %L\", \n+\t\t\t       \"with KIND argument at %L\",\n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n \n@@ -2409,7 +2409,7 @@ gfc_check_ieor (gfc_expr *i, gfc_expr *j)\n \n   if (i->ts.kind != j->ts.kind)\n     {\n-      if (!gfc_notify_std (GFC_STD_GNU, \"Different type kinds at %L\", \n+      if (!gfc_notify_std (GFC_STD_GNU, \"Different type kinds at %L\",\n \t\t\t   &i->where))\n \treturn false;\n     }\n@@ -2432,7 +2432,7 @@ gfc_check_index (gfc_expr *string, gfc_expr *substring, gfc_expr *back,\n   if (!kind_check (kind, 3, BT_INTEGER))\n     return false;\n   if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n-\t\t\t       \"with KIND argument at %L\", \n+\t\t\t       \"with KIND argument at %L\",\n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n \n@@ -2483,7 +2483,7 @@ gfc_check_ior (gfc_expr *i, gfc_expr *j)\n \n   if (i->ts.kind != j->ts.kind)\n     {\n-      if (!gfc_notify_std (GFC_STD_GNU, \"Different type kinds at %L\", \n+      if (!gfc_notify_std (GFC_STD_GNU, \"Different type kinds at %L\",\n \t\t\t   &i->where))\n \treturn false;\n     }\n@@ -2633,7 +2633,7 @@ gfc_check_lbound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n   if (!kind_check (kind, 2, BT_INTEGER))\n     return false;\n   if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n-\t\t\t       \"with KIND argument at %L\", \n+\t\t\t       \"with KIND argument at %L\",\n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n \n@@ -2678,7 +2678,7 @@ gfc_check_len_lentrim (gfc_expr *s, gfc_expr *kind)\n   if (!kind_check (kind, 1, BT_INTEGER))\n     return false;\n   if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n-\t\t\t       \"with KIND argument at %L\", \n+\t\t\t       \"with KIND argument at %L\",\n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n \n@@ -2948,7 +2948,7 @@ gfc_check_min_max (gfc_actual_arglist *arg)\n   if (x->ts.type == BT_CHARACTER)\n     {\n       if (!gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n-\t\t\t   \"with CHARACTER argument at %L\", \n+\t\t\t   \"with CHARACTER argument at %L\",\n \t\t\t   gfc_current_intrinsic, &x->where))\n \treturn false;\n     }\n@@ -3118,10 +3118,10 @@ gfc_check_minloc_maxloc (gfc_actual_arglist *ap)\n     return false;\n \n   if (m != NULL\n-      && !gfc_check_conformance (a, m, \n-\t\t\t\t \"arguments '%s' and '%s' for intrinsic %s\", \n-\t\t\t\t gfc_current_intrinsic_arg[0]->name, \n-\t\t\t\t gfc_current_intrinsic_arg[2]->name, \n+      && !gfc_check_conformance (a, m,\n+\t\t\t\t \"arguments '%s' and '%s' for intrinsic %s\",\n+\t\t\t\t gfc_current_intrinsic_arg[0]->name,\n+\t\t\t\t gfc_current_intrinsic_arg[2]->name,\n \t\t\t\t gfc_current_intrinsic))\n     return false;\n \n@@ -3172,10 +3172,10 @@ check_reduction (gfc_actual_arglist *ap)\n     return false;\n \n   if (m != NULL\n-      && !gfc_check_conformance (a, m, \n-\t\t\t\t \"arguments '%s' and '%s' for intrinsic %s\", \n-\t\t\t\t gfc_current_intrinsic_arg[0]->name, \n-\t\t\t\t gfc_current_intrinsic_arg[2]->name, \n+      && !gfc_check_conformance (a, m,\n+\t\t\t\t \"arguments '%s' and '%s' for intrinsic %s\",\n+\t\t\t\t gfc_current_intrinsic_arg[0]->name,\n+\t\t\t\t gfc_current_intrinsic_arg[2]->name,\n \t\t\t\t gfc_current_intrinsic))\n     return false;\n \n@@ -3342,6 +3342,16 @@ gfc_check_move_alloc (gfc_expr *from, gfc_expr *to)\n       return false;\n     }\n \n+  /*  F2003 12.4.1.7  */\n+  if (to->expr_type == EXPR_VARIABLE && from->expr_type ==EXPR_VARIABLE\n+      && !strcmp (to->symtree->n.sym->name, from->symtree->n.sym->name))\n+    {\n+      gfc_error (\"The FROM and TO arguments at %L are either the same object \"\n+\t\t \"or subobjects thereof and so violate aliasing restrictions \"\n+\t\t \"(F2003 12.4.1.7)\", &to->where);\n+      return false;\n+    }\n+\n   /* CLASS arguments: Make sure the vtab of from is present.  */\n   if (to->ts.type == BT_CLASS && !UNLIMITED_POLY (from))\n     gfc_find_vtab (&from->ts);\n@@ -3447,10 +3457,10 @@ gfc_check_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)\n   if (!type_check (mask, 1, BT_LOGICAL))\n     return false;\n \n-  if (!gfc_check_conformance (array, mask, \n-\t\t\t      \"arguments '%s' and '%s' for intrinsic '%s'\", \n-\t\t\t      gfc_current_intrinsic_arg[0]->name, \n-\t\t\t      gfc_current_intrinsic_arg[1]->name, \n+  if (!gfc_check_conformance (array, mask,\n+\t\t\t      \"arguments '%s' and '%s' for intrinsic '%s'\",\n+\t\t\t      gfc_current_intrinsic_arg[0]->name,\n+\t\t\t      gfc_current_intrinsic_arg[1]->name,\n \t\t\t      gfc_current_intrinsic))\n     return false;\n \n@@ -3989,7 +3999,7 @@ gfc_check_scan (gfc_expr *x, gfc_expr *y, gfc_expr *z, gfc_expr *kind)\n   if (!kind_check (kind, 3, BT_INTEGER))\n     return false;\n   if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n-\t\t\t       \"with KIND argument at %L\", \n+\t\t\t       \"with KIND argument at %L\",\n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n \n@@ -4050,7 +4060,7 @@ gfc_check_selected_real_kind (gfc_expr *p, gfc_expr *r, gfc_expr *radix)\n {\n   if (p == NULL && r == NULL\n       && !gfc_notify_std (GFC_STD_F2008, \"SELECTED_REAL_KIND with\"\n-\t\t\t  \" neither %<P%> nor %<R%> argument at %L\", \n+\t\t\t  \" neither %<P%> nor %<R%> argument at %L\",\n \t\t\t  gfc_current_intrinsic_where))\n     return false;\n \n@@ -4081,7 +4091,7 @@ gfc_check_selected_real_kind (gfc_expr *p, gfc_expr *r, gfc_expr *radix)\n \treturn false;\n \n       if (!gfc_notify_std (GFC_STD_F2008, \"%qs intrinsic with \"\n-\t\t\t   \"RADIX argument at %L\", gfc_current_intrinsic, \n+\t\t\t   \"RADIX argument at %L\", gfc_current_intrinsic,\n \t\t\t   &radix->where))\n \treturn false;\n     }\n@@ -4123,7 +4133,7 @@ gfc_check_shape (gfc_expr *source, gfc_expr *kind)\n   if (!kind_check (kind, 1, BT_INTEGER))\n     return false;\n   if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n-\t\t\t       \"with KIND argument at %L\", \n+\t\t\t       \"with KIND argument at %L\",\n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n \n@@ -4178,7 +4188,7 @@ gfc_check_size (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n   if (!kind_check (kind, 2, BT_INTEGER))\n     return false;\n   if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n-\t\t\t       \"with KIND argument at %L\", \n+\t\t\t       \"with KIND argument at %L\",\n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n \n@@ -4621,9 +4631,9 @@ gfc_check_c_loc (gfc_expr *x)\n \t\t     &x->where);\n \t  return false;\n \t}\n-     \n+\n       if (x->rank\n-\t  && !gfc_notify_std (GFC_STD_F2008_TS, \n+\t  && !gfc_notify_std (GFC_STD_F2008_TS,\n \t\t\t      \"Noninteroperable array at %L as\"\n \t\t\t      \" argument to C_LOC: %s\", &x->where, msg))\n \t  return false;\n@@ -4634,7 +4644,7 @@ gfc_check_c_loc (gfc_expr *x)\n \n       if (ar->as->type != AS_EXPLICIT && ar->as->type != AS_ASSUMED_SIZE\n \t  && !attr.allocatable\n-\t  && !gfc_notify_std (GFC_STD_F2008, \n+\t  && !gfc_notify_std (GFC_STD_F2008,\n \t\t\t      \"Array of interoperable type at %L \"\n \t\t\t      \"to C_LOC which is nonallocatable and neither \"\n \t\t\t      \"assumed size nor explicit size\", &x->where))\n@@ -4669,7 +4679,7 @@ gfc_check_sngl (gfc_expr *a)\n \n   if ((a->ts.kind != gfc_default_double_kind)\n       && !gfc_notify_std (GFC_STD_GNU, \"non double precision \"\n-\t\t\t  \"REAL argument to %s intrinsic at %L\", \n+\t\t\t  \"REAL argument to %s intrinsic at %L\",\n \t\t\t  gfc_current_intrinsic, &a->where))\n     return false;\n \n@@ -5182,7 +5192,7 @@ gfc_check_transfer (gfc_expr *source, gfc_expr *mold, gfc_expr *size)\n   /* If we can't calculate the sizes, we cannot check any more.\n      Return true for that case.  */\n \n-  if (!gfc_calculate_transfer_sizes (source, mold, size, &source_size, \n+  if (!gfc_calculate_transfer_sizes (source, mold, size, &source_size,\n \t\t\t\t     &result_size, NULL))\n     return true;\n \n@@ -5221,7 +5231,7 @@ gfc_check_ubound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n   if (!kind_check (kind, 2, BT_INTEGER))\n     return false;\n   if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n-\t\t\t       \"with KIND argument at %L\", \n+\t\t\t       \"with KIND argument at %L\",\n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n \n@@ -5350,7 +5360,7 @@ gfc_check_verify (gfc_expr *x, gfc_expr *y, gfc_expr *z, gfc_expr *kind)\n   if (!kind_check (kind, 3, BT_INTEGER))\n     return false;\n   if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n-\t\t\t       \"with KIND argument at %L\", \n+\t\t\t       \"with KIND argument at %L\",\n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n "}, {"sha": "69af2ef70253352ccee33640ff280b4b2d25931b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7f587bd0f7eb3e94e31a8b597abc05492e3d074/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7f587bd0f7eb3e94e31a8b597abc05492e3d074/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c7f587bd0f7eb3e94e31a8b597abc05492e3d074", "patch": "@@ -1,3 +1,7 @@\n+2016-11-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* gfortran.dg/move_alloc_17.f03: New test.\n+\n 2016-11-05  Richard Biener  <rguenther@suse.de>\n \n \tPR bootstrap/78188"}, {"sha": "acede0f901bc72ace8dfc4c205e5b3313a660452", "filename": "gcc/testsuite/gfortran.dg/move_alloc_17.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7f587bd0f7eb3e94e31a8b597abc05492e3d074/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_17.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7f587bd0f7eb3e94e31a8b597abc05492e3d074/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_17.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_17.f90?ref=c7f587bd0f7eb3e94e31a8b597abc05492e3d074", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+!\n+! The call to MOVE_ALLOC below caused a seg fault in runtime.\n+! This was discussed in:\n+! https://groups.google.com/forum/#!topic/comp.lang.fortran/ZVLqXFYDZ0M\n+! Richard Maine proposed that the code violated the restrictions on\n+! actual arguments in F2003 12.4.1.7 and so the fix asserts that the\n+! TO and FROM arguments cannot be the same object or subobjects thereof.\n+!\n+!\n+program test_move_alloc\n+  type :: linked_list\n+     type(linked_list), allocatable :: link\n+     integer :: value\n+  end type linked_list\n+  type(linked_list) :: test\n+\n+  allocate(test % link)\n+  allocate(test % link % link)\n+  call move_alloc(test % link, test % link % link) ! { dg-error \"aliasing restrictions\" }\n+end program test_move_alloc"}]}