{"sha": "6b9b7b4cf82a02fd22c8f2d7d6843287577ee6ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI5YjdiNGNmODJhMDJmZDIyYzhmMmQ3ZDY4NDMyODc1NzdlZTZiYQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2004-12-18T20:14:24Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-12-18T20:14:24Z"}, "message": "re PR rtl-optimization/19001 (Loops with power of two step and variable bounds not unrolled)\n\n\tPR rtl-optimization/19001\n\t* loop-iv.c (iv_number_of_iterations): Record assumptions for loops\n\twith power of two step to 'infinite' field.\n\nFrom-SVN: r92361", "tree": {"sha": "dcbedb6e3ffaeac6b67fb1a10932ff7f543a4ca3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcbedb6e3ffaeac6b67fb1a10932ff7f543a4ca3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b9b7b4cf82a02fd22c8f2d7d6843287577ee6ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b9b7b4cf82a02fd22c8f2d7d6843287577ee6ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b9b7b4cf82a02fd22c8f2d7d6843287577ee6ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b9b7b4cf82a02fd22c8f2d7d6843287577ee6ba/comments", "author": null, "committer": null, "parents": [{"sha": "00f24ef79439d8a539dfa67694a7f3c3b9f009fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00f24ef79439d8a539dfa67694a7f3c3b9f009fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00f24ef79439d8a539dfa67694a7f3c3b9f009fc"}], "stats": {"total": 95, "additions": 79, "deletions": 16}, "files": [{"sha": "bc62c67f41a4595f4578486c544324d0f2f4df63", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9b7b4cf82a02fd22c8f2d7d6843287577ee6ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9b7b4cf82a02fd22c8f2d7d6843287577ee6ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b9b7b4cf82a02fd22c8f2d7d6843287577ee6ba", "patch": "@@ -1,3 +1,9 @@\n+2004-12-18  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\tPR rtl-optimization/19001\n+\t* loop-iv.c (iv_number_of_iterations): Record assumptions for loops\n+\twith power of two step to 'infinite' field.\n+\n 2004-12-18  Roger Sayle  <roger@eyesopen.com>\n \n \t* Makefile.in (stor-layout.o): Depend upon gt-stor-layout.h."}, {"sha": "704d51e07afe0a0183e0beaf2c5348d3fbf6ee45", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 73, "deletions": 16, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9b7b4cf82a02fd22c8f2d7d6843287577ee6ba/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9b7b4cf82a02fd22c8f2d7d6843287577ee6ba/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=6b9b7b4cf82a02fd22c8f2d7d6843287577ee6ba", "patch": "@@ -2017,9 +2017,10 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n   enum machine_mode mode, comp_mode;\n   rtx mmin, mmax, mode_mmin, mode_mmax;\n   unsigned HOST_WIDEST_INT s, size, d, inv;\n-  HOST_WIDEST_INT up, down, inc;\n+  HOST_WIDEST_INT up, down, inc, step_val;\n   int was_sharp = false;\n   rtx old_niter;\n+  bool step_is_pow2;\n \n   /* The meaning of these assumptions is this:\n      if !assumptions\n@@ -2126,10 +2127,26 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n   if (iv0.step == const0_rtx && iv1.step == const0_rtx)\n     goto fail;\n \n-  /* Ignore loops of while (i-- < 10) type.  */\n-  if (cond != NE\n-      && (INTVAL (iv0.step) < 0 || INTVAL (iv1.step) > 0))\n-    goto fail;\n+  if (cond != NE)\n+    {\n+      if (iv0.step == const0_rtx)\n+\tstep_val = -INTVAL (iv1.step);\n+      else\n+\tstep_val = INTVAL (iv1.step);\n+\n+      /* Ignore loops of while (i-- < 10) type.  */\n+      if (step_val < 0)\n+\tgoto fail;\n+\n+      step_is_pow2 = !(step_val & (step_val - 1));\n+    }\n+  else\n+    {\n+      /* We do not care about whether the step is power of two in this\n+\t case.  */\n+      step_is_pow2 = false;\n+      step_val = 0;\n+    }\n \n   /* Some more condition normalization.  We must record some assumptions\n      due to overflows.  */\n@@ -2270,8 +2287,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t      /* If the step is a power of two and the final value we have\n \t\t computed overflows, the cycle is infinite.  Otherwise it\n \t\t is nontrivial to compute the number of iterations.  */\n-\t      s = INTVAL (step);\n-\t      if ((s & (s - 1)) == 0)\n+\t      if (step_is_pow2)\n \t\tdesc->infinite = alloc_EXPR_LIST (0, may_not_xform,\n \t\t\t\t\t\t  desc->infinite);\n \t      else\n@@ -2372,11 +2388,32 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t  tmp1 = lowpart_subreg (mode, iv1.base, comp_mode);\n \n \t  bound = simplify_gen_binary (MINUS, mode, mode_mmax,\n-\t\t\t\t       lowpart_subreg (mode, step, comp_mode));\n-\t  assumption = simplify_gen_relational (cond, SImode, mode,\n-\t\t\t\t\t\ttmp1, bound);\n-\t  desc->assumptions =\n-\t\t  alloc_EXPR_LIST (0, assumption, desc->assumptions);\n+\t\t\t\t       lowpart_subreg (mode, step,\n+\t\t\t\t\t\t       comp_mode));\n+\t  if (step_is_pow2)\n+\t    {\n+\t      rtx t0, t1;\n+\n+\t      /* If s is power of 2, we know that the loop is infinite if\n+\t\t a % s <= b % s and b + s overflows.  */\n+\t      assumption = simplify_gen_relational (reverse_condition (cond),\n+\t\t\t\t\t\t    SImode, mode,\n+\t\t\t\t\t\t    tmp1, bound);\n+\n+\t      t0 = simplify_gen_binary (UMOD, mode, copy_rtx (tmp0), step);\n+\t      t1 = simplify_gen_binary (UMOD, mode, copy_rtx (tmp1), step);\n+\t      tmp = simplify_gen_relational (cond, SImode, mode, t0, t1);\n+\t      assumption = simplify_gen_binary (AND, SImode, assumption, tmp);\n+\t      desc->infinite =\n+\t\t      alloc_EXPR_LIST (0, assumption, desc->infinite);\n+\t    }\n+\t  else\n+\t    {\n+\t      assumption = simplify_gen_relational (cond, SImode, mode,\n+\t\t\t\t\t\t    tmp1, bound);\n+\t      desc->assumptions =\n+\t\t      alloc_EXPR_LIST (0, assumption, desc->assumptions);\n+\t    }\n \n \t  tmp = simplify_gen_binary (PLUS, comp_mode, iv1.base, iv0.step);\n \t  tmp = lowpart_subreg (mode, tmp, comp_mode);\n@@ -2397,10 +2434,30 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \n \t  bound = simplify_gen_binary (MINUS, mode, mode_mmin,\n \t\t\t\t       lowpart_subreg (mode, step, comp_mode));\n-\t  assumption = simplify_gen_relational (cond, SImode, mode,\n-\t\t\t\t\t\tbound, tmp0);\n-\t  desc->assumptions =\n-\t\t  alloc_EXPR_LIST (0, assumption, desc->assumptions);\n+\t  if (step_is_pow2)\n+\t    {\n+\t      rtx t0, t1;\n+\n+\t      /* If s is power of 2, we know that the loop is infinite if\n+\t\t a % s <= b % s and a - s overflows.  */\n+\t      assumption = simplify_gen_relational (reverse_condition (cond),\n+\t\t\t\t\t\t    SImode, mode,\n+\t\t\t\t\t\t    bound, tmp0);\n+\n+\t      t0 = simplify_gen_binary (UMOD, mode, copy_rtx (tmp0), step);\n+\t      t1 = simplify_gen_binary (UMOD, mode, copy_rtx (tmp1), step);\n+\t      tmp = simplify_gen_relational (cond, SImode, mode, t0, t1);\n+\t      assumption = simplify_gen_binary (AND, SImode, assumption, tmp);\n+\t      desc->infinite =\n+\t\t      alloc_EXPR_LIST (0, assumption, desc->infinite);\n+\t    }\n+\t  else\n+\t    {\n+\t      assumption = simplify_gen_relational (cond, SImode, mode,\n+\t\t\t\t\t\t    bound, tmp0);\n+\t      desc->assumptions =\n+\t\t      alloc_EXPR_LIST (0, assumption, desc->assumptions);\n+\t    }\n \n \t  tmp = simplify_gen_binary (PLUS, comp_mode, iv0.base, iv1.step);\n \t  tmp = lowpart_subreg (mode, tmp, comp_mode);"}]}