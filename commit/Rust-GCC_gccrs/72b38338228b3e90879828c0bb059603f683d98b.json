{"sha": "72b38338228b3e90879828c0bb059603f683d98b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJiMzgzMzgyMjhiM2U5MDg3OTgyOGMwYmIwNTk2MDNmNjgzZDk4Yg==", "commit": {"author": {"name": "Cl\u00e9ment Chigot", "email": "clement.chigot@atos.net", "date": "2020-10-07T13:47:45Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-10-14T00:54:37Z"}, "message": "reflect: ensure uniqueness of type descriptors on AIX.\n\nOn AIX, duplication of type descriptors can occur if one is\ndeclared in the libgo and one in the Go program being compiled.\nThe AIX linker isn't able to merge them together as Linux one does.\nOne solution is to always load libgo first but that needs a huge mechanism in\ngcc core. Thus, this patch ensures that the duplication isn't visible\nfor the end user.\n\nIn reflect and internal/reflectlite, the comparison of rtypes is made on their\nname and not only on their addresses.\n\nIn reflect, toType() function is using a canonicalization map to force rtypes\nhaving the same rtype.String() to return the same Type. This can't be made in\ninternal/reflectlite as it needs sync package. But, for now, it doesn't matter\nas internal/reflectlite is not widely used.\n\nFixes golang/go#39276\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/260158", "tree": {"sha": "153cc65f70946620a982b9c61a2971e164e599e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/153cc65f70946620a982b9c61a2971e164e599e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72b38338228b3e90879828c0bb059603f683d98b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72b38338228b3e90879828c0bb059603f683d98b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72b38338228b3e90879828c0bb059603f683d98b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72b38338228b3e90879828c0bb059603f683d98b/comments", "author": null, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdd74cc20ca22dd4aa19938d0494fcdd37cc0418", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdd74cc20ca22dd4aa19938d0494fcdd37cc0418", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdd74cc20ca22dd4aa19938d0494fcdd37cc0418"}], "stats": {"total": 198, "additions": 168, "deletions": 30}, "files": [{"sha": "8f71939862b488181e7377dc3062ea5a347c2859", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b38338228b3e90879828c0bb059603f683d98b/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b38338228b3e90879828c0bb059603f683d98b/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=72b38338228b3e90879828c0bb059603f683d98b", "patch": "@@ -1,4 +1,4 @@\n-2563706e4ead80d6906d66ae23c8915c360583ad\n+fef8afc1876f4a1d5e9a8fd54c21bf5917966e10\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "76cdc8ef217d3fd662af0faaf6af2ca4195a0ac0", "filename": "libgo/Makefile.am", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b38338228b3e90879828c0bb059603f683d98b/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b38338228b3e90879828c0bb059603f683d98b/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=72b38338228b3e90879828c0bb059603f683d98b", "patch": "@@ -973,6 +973,12 @@ endif\n # Also use -fno-inline to get better results from the memory profiler.\n runtime_pprof_check_GOCFLAGS = -static-libgo -fno-inline\n \n+if LIBGO_IS_AIX\n+# reflect tests must be done with -static-libgo. Otherwize,\n+# there will be a duplication of the canonicalization map.\n+reflect_check_GOCFLAGS = -static-libgo -Wl,-bbigtoc\n+endif\n+\n if HAVE_STATIC_LINK\n # Use -static for the syscall tests if possible, because otherwise when\n # running as root the re-execs ignore LD_LIBRARY_PATH."}, {"sha": "59a7083f6149a9a21be7eb9378575a0a662deddb", "filename": "libgo/Makefile.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b38338228b3e90879828c0bb059603f683d98b/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b38338228b3e90879828c0bb059603f683d98b/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=72b38338228b3e90879828c0bb059603f683d98b", "patch": "@@ -1114,6 +1114,10 @@ runtime_internal_sys_lo_check_GOCFLAGS = -fgo-compiling-runtime\n # Also use -fno-inline to get better results from the memory profiler.\n runtime_pprof_check_GOCFLAGS = -static-libgo -fno-inline\n \n+# reflect tests must be done with -static-libgo. Otherwize,\n+# there will be a duplication of the canonicalization map.\n+@LIBGO_IS_AIX_TRUE@reflect_check_GOCFLAGS = -static-libgo -Wl,-bbigtoc\n+\n # Use -static for the syscall tests if possible, because otherwise when\n # running as root the re-execs ignore LD_LIBRARY_PATH.\n @HAVE_STATIC_LINK_TRUE@syscall_check_GOCFLAGS = -static"}, {"sha": "a03cf1c55f90c39869b0e3d6d6941d7a01c10dac", "filename": "libgo/go/internal/reflectlite/eqtype.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b38338228b3e90879828c0bb059603f683d98b/libgo%2Fgo%2Finternal%2Freflectlite%2Feqtype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b38338228b3e90879828c0bb059603f683d98b/libgo%2Fgo%2Finternal%2Freflectlite%2Feqtype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Freflectlite%2Feqtype.go?ref=72b38338228b3e90879828c0bb059603f683d98b", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+//+build !aix !gccgo\n+\n+package reflectlite\n+\n+// rtypeEqual returns true if both types are identical.\n+func rtypeEqual(t1, t2 *rtype) bool {\n+\treturn t1 == t2\n+}"}, {"sha": "38b507fd8270b78194fc0a6fe11f9abc4c49913f", "filename": "libgo/go/internal/reflectlite/eqtype_aix_gccgo.go", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b38338228b3e90879828c0bb059603f683d98b/libgo%2Fgo%2Finternal%2Freflectlite%2Feqtype_aix_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b38338228b3e90879828c0bb059603f683d98b/libgo%2Fgo%2Finternal%2Freflectlite%2Feqtype_aix_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Freflectlite%2Feqtype_aix_gccgo.go?ref=72b38338228b3e90879828c0bb059603f683d98b", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+//+build aix,gccgo\n+\n+// AIX linker isn't able to merge identical type descriptors coming from\n+// different objects. Thus, two rtypes might have two different pointers\n+// even if they are the same. Thus, instead of pointer equality, string\n+// field is checked.\n+\n+package reflectlite\n+\n+// rtypeEqual returns true if both types are identical.\n+func rtypeEqual(t1, t2 *rtype) bool {\n+\tswitch {\n+\tcase t1 == t2:\n+\t\treturn true\n+\tcase t1 == nil || t2 == nil:\n+\t\treturn false\n+\tcase t1.kind != t2.kind || t1.hash != t2.hash:\n+\t\treturn false\n+\tdefault:\n+\t\treturn t1.String() == t2.String()\n+\t}\n+}"}, {"sha": "1609a06a53e15d26cde63d1c2252a77bcfe87df6", "filename": "libgo/go/internal/reflectlite/type.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b38338228b3e90879828c0bb059603f683d98b/libgo%2Fgo%2Finternal%2Freflectlite%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b38338228b3e90879828c0bb059603f683d98b/libgo%2Fgo%2Finternal%2Freflectlite%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Freflectlite%2Ftype.go?ref=72b38338228b3e90879828c0bb059603f683d98b", "patch": "@@ -539,7 +539,7 @@ func implements(T, V *rtype) bool {\n \t\tfor j := 0; j < len(v.methods); j++ {\n \t\t\ttm := &t.methods[i]\n \t\t\tvm := &v.methods[j]\n-\t\t\tif *vm.name == *tm.name && (vm.pkgPath == tm.pkgPath || (vm.pkgPath != nil && tm.pkgPath != nil && *vm.pkgPath == *tm.pkgPath)) && toType(vm.typ).common() == toType(tm.typ).common() {\n+\t\t\tif *vm.name == *tm.name && (vm.pkgPath == tm.pkgPath || (vm.pkgPath != nil && tm.pkgPath != nil && *vm.pkgPath == *tm.pkgPath)) && rtypeEqual(toType(vm.typ).common(), toType(tm.typ).common()) {\n \t\t\t\tif i++; i >= len(t.methods) {\n \t\t\t\t\treturn true\n \t\t\t\t}\n@@ -556,7 +556,7 @@ func implements(T, V *rtype) bool {\n \tfor j := 0; j < len(v.methods); j++ {\n \t\ttm := &t.methods[i]\n \t\tvm := &v.methods[j]\n-\t\tif *vm.name == *tm.name && (vm.pkgPath == tm.pkgPath || (vm.pkgPath != nil && tm.pkgPath != nil && *vm.pkgPath == *tm.pkgPath)) && toType(vm.mtyp).common() == toType(tm.typ).common() {\n+\t\tif *vm.name == *tm.name && (vm.pkgPath == tm.pkgPath || (vm.pkgPath != nil && tm.pkgPath != nil && *vm.pkgPath == *tm.pkgPath)) && rtypeEqual(toType(vm.mtyp).common(), toType(tm.typ).common()) {\n \t\t\tif i++; i >= len(t.methods) {\n \t\t\t\treturn true\n \t\t\t}\n@@ -572,7 +572,7 @@ func implements(T, V *rtype) bool {\n // and the ideal constant rules (no ideal constants at run time).\n func directlyAssignable(T, V *rtype) bool {\n \t// x's type V is identical to T?\n-\tif T == V {\n+\tif rtypeEqual(T, V) {\n \t\treturn true\n \t}\n \n@@ -599,7 +599,7 @@ func haveIdenticalType(T, V Type, cmpTags bool) bool {\n }\n \n func haveIdenticalUnderlyingType(T, V *rtype, cmpTags bool) bool {\n-\tif T == V {\n+\tif rtypeEqual(T, V) {\n \t\treturn true\n \t}\n "}, {"sha": "5639bc56487ec50384dc66615762d4f5fc6e19f2", "filename": "libgo/go/reflect/eqtype.go", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b38338228b3e90879828c0bb059603f683d98b/libgo%2Fgo%2Freflect%2Feqtype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b38338228b3e90879828c0bb059603f683d98b/libgo%2Fgo%2Freflect%2Feqtype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Feqtype.go?ref=72b38338228b3e90879828c0bb059603f683d98b", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !aix !gccgo\n+\n+package reflect\n+\n+// rtypeEqual returns true if both rtypes are identical.\n+func rtypeEqual(t1, t2 *rtype) bool {\n+\treturn t1 == t2\n+}\n+\n+// typeEqual returns true if both Types are identical.\n+func typeEqual(t1, t2 Type) bool {\n+\treturn t1 == t2\n+}\n+\n+func toType(p *rtype) Type {\n+\tif p == nil {\n+\t\treturn nil\n+\t}\n+\treturn p\n+}"}, {"sha": "7afbf10ad6db58dff6d876847572ffeb45a0cc0f", "filename": "libgo/go/reflect/eqtype_aix_gccgo.go", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b38338228b3e90879828c0bb059603f683d98b/libgo%2Fgo%2Freflect%2Feqtype_aix_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b38338228b3e90879828c0bb059603f683d98b/libgo%2Fgo%2Freflect%2Feqtype_aix_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Feqtype_aix_gccgo.go?ref=72b38338228b3e90879828c0bb059603f683d98b", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+//+build aix,gccgo\n+\n+// AIX linker isn't able to merge identical type descriptors coming from\n+// different objects. Thus, two rtypes might have two different pointers\n+// even if they are the same. Thus, instead of pointer equality, string\n+// field is checked.\n+\n+package reflect\n+\n+import (\n+\t\"sync\"\n+)\n+\n+// rtypeEqual returns true if both rtypes are identical.\n+func rtypeEqual(t1, t2 *rtype) bool {\n+\tswitch {\n+\tcase t1 == t2:\n+\t\treturn true\n+\tcase t1 == nil || t2 == nil:\n+\t\treturn false\n+\tcase t1.kind != t2.kind || t1.hash != t2.hash:\n+\t\treturn false\n+\tdefault:\n+\t\treturn t1.String() == t2.String()\n+\t}\n+}\n+\n+// typeEqual returns true if both Types are identical.\n+func typeEqual(t1, t2 Type) bool {\n+\treturn rtypeEqual(t1.common(), t2.common())\n+}\n+\n+// toType converts from a *rtype to a Type that can be returned\n+// to the client of package reflect. The only concern is that\n+// a nil *rtype must be replaced by a nil Type.\n+// On AIX, as type duplications can occur, it also ensure that\n+// multiple *rtype for the same  type are coalesced into a single\n+// Type.\n+\n+var canonicalType = make(map[string]Type)\n+\n+var canonicalTypeLock sync.RWMutex\n+\n+func canonicalize(t Type) Type {\n+\tif t == nil {\n+\t\treturn nil\n+\t}\n+\ts := t.rawString()\n+\tcanonicalTypeLock.RLock()\n+\tif r, ok := canonicalType[s]; ok {\n+\t\tcanonicalTypeLock.RUnlock()\n+\t\treturn r\n+\t}\n+\tcanonicalTypeLock.RUnlock()\n+\tcanonicalTypeLock.Lock()\n+\tif r, ok := canonicalType[s]; ok {\n+\t\tcanonicalTypeLock.Unlock()\n+\t\treturn r\n+\t}\n+\tcanonicalType[s] = t\n+\tcanonicalTypeLock.Unlock()\n+\treturn t\n+}\n+\n+func toType(p *rtype) Type {\n+\tif p == nil {\n+\t\treturn nil\n+\t}\n+\treturn canonicalize(p)\n+}"}, {"sha": "73c09d4bb341037f8790ef8e7163437a602ed199", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b38338228b3e90879828c0bb059603f683d98b/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b38338228b3e90879828c0bb059603f683d98b/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=72b38338228b3e90879828c0bb059603f683d98b", "patch": "@@ -1129,7 +1129,7 @@ func (t *rtype) ptrTo() *rtype {\n \t// Look in known types.\n \ts := \"*\" + *t.string\n \tif tt := lookupType(s); tt != nil {\n-\t\tp := (*ptrType)(unsafe.Pointer(tt))\n+\t\tp := (*ptrType)(unsafe.Pointer(toType(tt).(*rtype)))\n \t\tif p.elem == t {\n \t\t\tpi, _ := ptrMap.LoadOrStore(t, p)\n \t\t\treturn &pi.(*ptrType).rtype\n@@ -1158,7 +1158,9 @@ func (t *rtype) ptrTo() *rtype {\n \tpp.ptrToThis = nil\n \tpp.elem = t\n \n-\tpi, _ := ptrMap.LoadOrStore(t, &pp)\n+\tq := toType(&pp.rtype).(*rtype)\n+\tp := (*ptrType)(unsafe.Pointer(q))\n+\tpi, _ := ptrMap.LoadOrStore(t, p)\n \treturn &pi.(*ptrType).rtype\n }\n \n@@ -1273,7 +1275,7 @@ func specialChannelAssignability(T, V *rtype) bool {\n // and the ideal constant rules (no ideal constants at run time).\n func directlyAssignable(T, V *rtype) bool {\n \t// x's type V is identical to T?\n-\tif T == V {\n+\tif rtypeEqual(T, V) {\n \t\treturn true\n \t}\n \n@@ -1304,7 +1306,7 @@ func haveIdenticalType(T, V Type, cmpTags bool) bool {\n }\n \n func haveIdenticalUnderlyingType(T, V *rtype, cmpTags bool) bool {\n-\tif T == V {\n+\tif rtypeEqual(T, V) {\n \t\treturn true\n \t}\n \n@@ -1449,7 +1451,7 @@ func ChanOf(dir ChanDir, t Type) Type {\n \t\ts = \"chan \" + *typ.string\n \t}\n \tif tt := lookupType(s); tt != nil {\n-\t\tch := (*chanType)(unsafe.Pointer(tt))\n+\t\tch := (*chanType)(unsafe.Pointer(toType(tt).(*rtype)))\n \t\tif ch.elem == typ && ch.dir == uintptr(dir) {\n \t\t\tti, _ := lookupCache.LoadOrStore(ckey, tt)\n \t\t\treturn ti.(Type)\n@@ -1481,7 +1483,7 @@ func ChanOf(dir ChanDir, t Type) Type {\n \tch.uncommonType = nil\n \tch.ptrToThis = nil\n \n-\tti, _ := lookupCache.LoadOrStore(ckey, &ch.rtype)\n+\tti, _ := lookupCache.LoadOrStore(ckey, toType(&ch.rtype).(*rtype))\n \treturn ti.(Type)\n }\n \n@@ -1508,7 +1510,7 @@ func MapOf(key, elem Type) Type {\n \t// Look in known types.\n \ts := \"map[\" + *ktyp.string + \"]\" + *etyp.string\n \tif tt := lookupType(s); tt != nil {\n-\t\tmt := (*mapType)(unsafe.Pointer(tt))\n+\t\tmt := (*mapType)(unsafe.Pointer(toType(tt).(*rtype)))\n \t\tif mt.key == ktyp && mt.elem == etyp {\n \t\t\tti, _ := lookupCache.LoadOrStore(ckey, tt)\n \t\t\treturn ti.(Type)\n@@ -1559,7 +1561,7 @@ func MapOf(key, elem Type) Type {\n \t\tmt.flags |= 16\n \t}\n \n-\tti, _ := lookupCache.LoadOrStore(ckey, &mt.rtype)\n+\tti, _ := lookupCache.LoadOrStore(ckey, toType(&mt.rtype).(*rtype))\n \treturn ti.(Type)\n }\n \n@@ -1648,7 +1650,7 @@ func FuncOf(in, out []Type, variadic bool) Type {\n \tft.string = &str\n \tft.uncommonType = nil\n \tft.ptrToThis = nil\n-\treturn addToCache(&ft.rtype)\n+\treturn addToCache(toType(&ft.rtype).(*rtype))\n }\n \n // funcStr builds a string representation of a funcType.\n@@ -1909,7 +1911,7 @@ func SliceOf(t Type) Type {\n \t// Look in known types.\n \ts := \"[]\" + *typ.string\n \tif tt := lookupType(s); tt != nil {\n-\t\tslice := (*sliceType)(unsafe.Pointer(tt))\n+\t\tslice := (*sliceType)(unsafe.Pointer(toType(tt).(*rtype)))\n \t\tif slice.elem == typ {\n \t\t\tti, _ := lookupCache.LoadOrStore(ckey, tt)\n \t\t\treturn ti.(Type)\n@@ -1930,7 +1932,7 @@ func SliceOf(t Type) Type {\n \tslice.uncommonType = nil\n \tslice.ptrToThis = nil\n \n-\tti, _ := lookupCache.LoadOrStore(ckey, &slice.rtype)\n+\tti, _ := lookupCache.LoadOrStore(ckey, toType(&slice.rtype).(*rtype))\n \treturn ti.(Type)\n }\n \n@@ -2234,7 +2236,7 @@ func StructOf(fields []StructField) Type {\n \n \ttyp.uncommonType = nil\n \ttyp.ptrToThis = nil\n-\treturn addToCache(&typ.rtype)\n+\treturn addToCache(toType(&typ.rtype).(*rtype))\n }\n \n // runtimeStructField takes a StructField value passed to StructOf and\n@@ -2330,7 +2332,7 @@ func ArrayOf(count int, elem Type) Type {\n \t// Look in known types.\n \ts := \"[\" + strconv.Itoa(count) + \"]\" + *typ.string\n \tif tt := lookupType(s); tt != nil {\n-\t\tarray := (*arrayType)(unsafe.Pointer(tt))\n+\t\tarray := (*arrayType)(unsafe.Pointer(toType(tt).(*rtype)))\n \t\tif array.elem == typ {\n \t\t\tti, _ := lookupCache.LoadOrStore(ckey, tt)\n \t\t\treturn ti.(Type)\n@@ -2446,7 +2448,7 @@ func ArrayOf(count int, elem Type) Type {\n \t\tarray.kind &^= kindDirectIface\n \t}\n \n-\tti, _ := lookupCache.LoadOrStore(ckey, &array.rtype)\n+\tti, _ := lookupCache.LoadOrStore(ckey, toType(&array.rtype).(*rtype))\n \treturn ti.(Type)\n }\n \n@@ -2458,16 +2460,6 @@ func appendVarint(x []byte, v uintptr) []byte {\n \treturn x\n }\n \n-// toType converts from a *rtype to a Type that can be returned\n-// to the client of package reflect. The only concern is that\n-// a nil *rtype must be replaced by a nil Type.\n-func toType(p *rtype) Type {\n-\tif p == nil {\n-\t\treturn nil\n-\t}\n-\treturn p\n-}\n-\n // Look up a compiler-generated type descriptor.\n // Implemented in runtime.\n func lookupType(s string) *rtype"}, {"sha": "64f74323160f4a761227a4912821cbda2064e7fe", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b38338228b3e90879828c0bb059603f683d98b/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b38338228b3e90879828c0bb059603f683d98b/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=72b38338228b3e90879828c0bb059603f683d98b", "patch": "@@ -1785,7 +1785,7 @@ type SliceHeader struct {\n }\n \n func typesMustMatch(what string, t1, t2 Type) {\n-\tif t1 != t2 {\n+\tif !typeEqual(t1, t2) {\n \t\tpanic(what + \": \" + t1.String() + \" != \" + t2.String())\n \t}\n }"}]}