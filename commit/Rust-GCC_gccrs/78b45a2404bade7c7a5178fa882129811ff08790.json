{"sha": "78b45a2404bade7c7a5178fa882129811ff08790", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhiNDVhMjQwNGJhZGU3YzdhNTE3OGZhODgyMTI5ODExZmYwODc5MA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-04-10T18:06:26Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-04-10T18:06:26Z"}, "message": "class.c (find_final_overrider_data): Add `candidates'.\n\n\t* class.c (find_final_overrider_data): Add `candidates'.\n\t(dfs_find_final_overrider): Don't issue error messages\n\tprematurely.\n\t(find_final_overrider): Issue error messages here.\n\t(build_base_field): Don't warn about amgibuous direct bases here.\n\t(warn_about_ambiguous_direct_bases): New function.\n\t(layout_class_type): Use it.\n\nFrom-SVN: r41224", "tree": {"sha": "5f0d77378e5aadab31152264b12a765ca92dd6e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f0d77378e5aadab31152264b12a765ca92dd6e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78b45a2404bade7c7a5178fa882129811ff08790", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78b45a2404bade7c7a5178fa882129811ff08790", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78b45a2404bade7c7a5178fa882129811ff08790", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78b45a2404bade7c7a5178fa882129811ff08790/comments", "author": null, "committer": null, "parents": [{"sha": "0450d74d53b419f6455d9fc4f12ccf2a37ce61b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0450d74d53b419f6455d9fc4f12ccf2a37ce61b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0450d74d53b419f6455d9fc4f12ccf2a37ce61b8"}], "stats": {"total": 190, "additions": 140, "deletions": 50}, "files": [{"sha": "7b5aee39e42097f93a6de10eb6466a25989be725", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b45a2404bade7c7a5178fa882129811ff08790/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b45a2404bade7c7a5178fa882129811ff08790/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=78b45a2404bade7c7a5178fa882129811ff08790", "patch": "@@ -1,3 +1,13 @@\n+2001-04-10  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (find_final_overrider_data): Add `candidates'.\n+\t(dfs_find_final_overrider): Don't issue error messages\n+\tprematurely.\n+\t(find_final_overrider): Issue error messages here.\n+\t(build_base_field): Don't warn about amgibuous direct bases here.\n+\t(warn_about_ambiguous_direct_bases): New function.\n+\t(layout_class_type): Use it.\n+\n 2001-04-10  Richard Henderson  <rth@redhat.com>\n \n \t* typeck.c (build_array_ref): Push the array reference inside"}, {"sha": "406843e0c9ba15228223a60025210380e0c216fc", "filename": "gcc/cp/class.c", "status": "modified", "additions": 110, "deletions": 50, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b45a2404bade7c7a5178fa882129811ff08790/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b45a2404bade7c7a5178fa882129811ff08790/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=78b45a2404bade7c7a5178fa882129811ff08790", "patch": "@@ -212,7 +212,7 @@ static void record_subobject_offsets PARAMS ((tree, tree, splay_tree, int));\n static int layout_conflict_p PARAMS ((tree, tree, splay_tree, int));\n static int splay_tree_compare_integer_csts PARAMS ((splay_tree_key k1,\n \t\t\t\t\t\t    splay_tree_key k2));\n-\n+static void warn_about_ambiguous_direct_bases PARAMS ((tree));\n \n /* Macros for dfs walking during vtt construction. See\n    dfs_ctor_vtable_bases_queue_p, dfs_build_secondary_vptr_vtt_inits\n@@ -2495,6 +2495,9 @@ typedef struct find_final_overrider_data_s {\n   tree most_derived_type;\n   /* The final overriding function.  */\n   tree overriding_fn;\n+  /* The functions that we thought might be final overriders, but\n+     aren't.  */\n+  tree candidates;\n   /* The BINFO for the class in which the final overriding function\n      appears.  */\n   tree overriding_base;\n@@ -2553,49 +2556,79 @@ dfs_find_final_overrider (binfo, data)\n \t\tbreak;\n \t      }\n \n-\t  if (ffod->overriding_fn && ffod->overriding_fn != method)\n+\t  /* If we didn't already have an overrider, or any\n+\t     candidates, then this function is the best candidate so\n+\t     far.  */\n+\t  if (!ffod->overriding_fn && !ffod->candidates)\n \t    {\n-\t      /* We've found a different overrider along a different\n-\t\t path.  That can be OK if the new one overrides the\n-\t\t old one.  Consider:\n-\t      \n-\t           struct S { virtual void f(); };\n-\t           struct T : public virtual S { virtual void f(); };\n-\t           struct U : public virtual S, public virtual T {};\n-\t      \n-\t         Here `T::f' is the final overrider for `S::f'.  */\n-\t      if (strictly_overrides (method, ffod->overriding_fn))\n-\t\t{\n-\t\t  ffod->overriding_fn = method;\n-\t\t  ffod->overriding_base = TREE_VALUE (path);\n-\t\t}\n-\t      else if (!strictly_overrides (ffod->overriding_fn, method))\n-\t\t{\n-\t\t  cp_error (\"no unique final overrider for `%D' in `%T'\", \n-\t\t\t    ffod->most_derived_type,\n-\t\t\t    ffod->fn);\n-\t\t  cp_error (\"candidates are: `%#D'\", ffod->overriding_fn);\n-\t\t  cp_error (\"                `%#D'\", method);\n-\t\t  return error_mark_node;\n-\t\t}\n+\t      ffod->overriding_fn = method;\n+\t      ffod->overriding_base = TREE_VALUE (path);\n \t    }\n-\t  else if (ffod->overriding_base\n-\t\t   && (!tree_int_cst_equal \n-\t\t       (BINFO_OFFSET (TREE_VALUE (path)),\n-\t\t\tBINFO_OFFSET (ffod->overriding_base))))\n+\t  /* If we found the same overrider we already have, then\n+\t     we just need to check that we're finding it in the same\n+\t     place.  */\n+\t  else if (ffod->overriding_fn == method)\n \t    {\n-\t      /* We've found two instances of the same base that\n-\t\t provide overriders.  */\n-\t      cp_error (\"no unique final overrider for `%D' since there two instances of `%T' in `%T'\", \n-\t\t\tffod->fn,\n-\t\t\tBINFO_TYPE (ffod->overriding_base),\n-\t\t\tffod->most_derived_type);\n-\t      return error_mark_node;\n+\t      if (ffod->overriding_base\n+\t\t  && (!tree_int_cst_equal \n+\t\t      (BINFO_OFFSET (TREE_VALUE (path)),\n+\t\t       BINFO_OFFSET (ffod->overriding_base))))\n+\t\t{\n+\t\t  ffod->candidates \n+\t\t    = build_tree_list (NULL_TREE,\n+\t\t\t\t       ffod->overriding_fn);\n+\t\t  ffod->overriding_fn = NULL_TREE;\n+\t\t  ffod->overriding_base = NULL_TREE;\n+\t\t}\n \t    }\n+\t  /* If there was already an overrider, and it overrides this\n+\t     function, then the old overrider is still the best\n+\t     candidate.  */\n+\t  else if (ffod->overriding_fn\n+\t\t   && strictly_overrides (ffod->overriding_fn,\n+\t\t\t\t\t  method))\n+\t    ;\n \t  else\n \t    {\n-\t      ffod->overriding_fn = method;\n-\t      ffod->overriding_base = TREE_VALUE (path);\n+\t      tree candidates;\n+\t      bool incomparable = false;\n+\n+\t      /* If there were previous candidates, and this function\n+\t\t overrides all of them, then it is the new best\n+\t\t candidate.  */\n+\t      for (candidates = ffod->candidates;\n+\t\t   candidates;\n+\t\t   candidates = TREE_CHAIN (candidates))\n+\t\t{\n+\t\t  /* If the candidate overrides the METHOD, then we\n+\t\t     needn't worry about it any further.  */\n+\t\t  if (strictly_overrides (TREE_VALUE (candidates),\n+\t\t\t\t\t  method))\n+\t\t    {\n+\t\t      method = NULL_TREE;\n+\t\t      break;\n+\t\t    }\n+\n+\t\t  /* If the METHOD doesn't override the candidate,\n+\t\t     then it is incomporable.  */\n+\t\t  if (!strictly_overrides (method,\n+\t\t\t\t\t   TREE_VALUE (candidates)))\n+\t\t    incomparable = true;\n+\t\t}\n+\n+\t      /* If METHOD overrode all the candidates, then it is the\n+\t\t new best candidate.  */\n+\t      if (!candidates && !incomparable)\n+\t\t{\n+\t\t  ffod->overriding_fn = method;\n+\t\t  ffod->overriding_base = TREE_VALUE (path);\n+\t\t  ffod->candidates = NULL_TREE;\n+\t\t}\n+\t      /* If METHOD didn't override all the candidates, then it\n+\t\t is another candidate.  */\n+\t      else if (method && incomparable)\n+\t\tffod->candidates \n+\t\t  = tree_cons (NULL_TREE, method, ffod->candidates);\n \t    }\n \t}\n     }\n@@ -2639,12 +2672,16 @@ find_final_overrider (t, binfo, fn)\n   ffod.most_derived_type = t;\n   ffod.overriding_fn = NULL_TREE;\n   ffod.overriding_base = NULL_TREE;\n+  ffod.candidates = NULL_TREE;\n+\n+  dfs_walk (TYPE_BINFO (t),\n+\t    dfs_find_final_overrider,\n+\t    NULL,\n+\t    &ffod);\n \n-  if (dfs_walk (TYPE_BINFO (t),\n-\t\tdfs_find_final_overrider,\n-\t\tNULL,\n-\t\t&ffod))\n-    return error_mark_node;\n+  /* If there was no winner, issue an error message.  */\n+  if (!ffod.overriding_fn)\n+    cp_error (\"no unique final overrider for `%D' in `%T'\", fn, t);\n \n   return build_tree_list (ffod.overriding_fn, ffod.overriding_base);\n }\n@@ -4041,13 +4078,6 @@ build_base_field (rli, binfo, empty_p, offsets)\n       layout_empty_base (binfo, size_int (eoc), offsets);\n     }\n \n-  /* Check for inaccessible base classes.  If the same base class\n-     appears more than once in the hierarchy, but isn't virtual, then\n-     it's ambiguous.  */\n-  if (get_base_distance (basetype, rli->t, 0, NULL) == -2)\n-    cp_warning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n-\t\tbasetype, rli->t);\n-  \n   /* Record the offsets of BINFO and its base subobjects.  */\n   record_subobject_offsets (BINFO_TYPE (binfo), \n \t\t\t    BINFO_OFFSET (binfo),\n@@ -4830,6 +4860,32 @@ end_of_class (t, include_virtuals_p)\n   return result;\n }\n \n+/* Warn about direct bases of T that are inaccessible because they are\n+   ambiguous.  For example:\n+\n+     struct S {};\n+     struct T : public S {};\n+     struct U : public S, public T {};\n+\n+   Here, `(S*) new U' is not allowed because there are two `S'\n+   subobjects of U.  */\n+\n+static void\n+warn_about_ambiguous_direct_bases (t)\n+     tree t;\n+{\n+  int i;\n+\n+  for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); ++i)\n+    {\n+      tree basetype = TYPE_BINFO_BASETYPE (t, i);\n+\n+      if (get_base_distance (basetype, t, 0, NULL) == -2)\n+\tcp_warning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n+\t\t    basetype, t);\n+    }\n+}\n+\n /* Compare two INTEGER_CSTs K1 and K2.  */\n \n static int\n@@ -5035,6 +5091,10 @@ layout_class_type (t, empty_p, vfuns_p,\n      base subobject fields.  */\n   layout_virtual_bases (t, empty_base_offsets);\n \n+  /* Warn about direct bases that can't be talked about due to\n+     ambiguity.  */\n+  warn_about_ambiguous_direct_bases (t);\n+\n   /* Clean up.  */\n   splay_tree_delete (empty_base_offsets);\n }"}, {"sha": "c7f3a4c9c0abdaca903d7ee7182f9e90dcb24497", "filename": "gcc/testsuite/g++.old-deja/g++.other/override1.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b45a2404bade7c7a5178fa882129811ff08790/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverride1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b45a2404bade7c7a5178fa882129811ff08790/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverride1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverride1.C?ref=78b45a2404bade7c7a5178fa882129811ff08790", "patch": "@@ -0,0 +1,20 @@\n+// Build don't link:\n+// Origin: Frank Pilhofer <fp@fpx.de>\n+\n+struct A {\n+virtual void f ();\n+};\n+\n+struct B : virtual public A {\n+void f ();\n+};\n+\n+struct C : virtual public A {\n+void f ();\n+};\n+\n+struct D : virtual public B, virtual public C {\n+void f ();\n+};\n+\n+struct Di : virtual public B, virtual public C, virtual public D {};"}]}