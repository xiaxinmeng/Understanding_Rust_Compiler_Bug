{"sha": "f000294852af1e858096f415588b247b51802683", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAwMDI5NDg1MmFmMWU4NTgwOTZmNDE1NTg4YjI0N2I1MTgwMjY4Mw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-08-28T06:22:33Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-08-28T06:22:33Z"}, "message": "cse.c (check_for_label_ref): Move earlier in file.\n\ngcc/\n\t* cse.c (check_for_label_ref): Move earlier in file.  Turn from\n\tbeing a for_each_rtx callback to being a function that examines\n\teach subrtx itself.\n\t(cse_extended_basic_block): Update call accordingly.\n\nFrom-SVN: r214629", "tree": {"sha": "a70d8c497a32e99be9629f9722a3f0b316273d5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a70d8c497a32e99be9629f9722a3f0b316273d5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f000294852af1e858096f415588b247b51802683", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f000294852af1e858096f415588b247b51802683", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f000294852af1e858096f415588b247b51802683", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f000294852af1e858096f415588b247b51802683/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c992c06661b428aef78366d4ecd58ec06f839a64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c992c06661b428aef78366d4ecd58ec06f839a64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c992c06661b428aef78366d4ecd58ec06f839a64"}], "stats": {"total": 59, "additions": 34, "deletions": 25}, "files": [{"sha": "e096c5e8cee8535ba240b65a541b8f9a50f2fd08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f000294852af1e858096f415588b247b51802683/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f000294852af1e858096f415588b247b51802683/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f000294852af1e858096f415588b247b51802683", "patch": "@@ -1,3 +1,10 @@\n+2014-08-28  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* cse.c (check_for_label_ref): Move earlier in file.  Turn from\n+\tbeing a for_each_rtx callback to being a function that examines\n+\teach subrtx itself.\n+\t(cse_extended_basic_block): Update call accordingly.\n+\n 2014-08-28  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* cse.c (check_dependence_data): Delete."}, {"sha": "a6c9e5c5a030afb50db9e0d18b7eddf82fa0799e", "filename": "gcc/cse.c", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f000294852af1e858096f415588b247b51802683/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f000294852af1e858096f415588b247b51802683/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=f000294852af1e858096f415588b247b51802683", "patch": "@@ -596,7 +596,6 @@ static void invalidate_from_clobbers (rtx_insn *);\n static void invalidate_from_sets_and_clobbers (rtx_insn *);\n static rtx cse_process_notes (rtx, rtx, bool *);\n static void cse_extended_basic_block (struct cse_basic_block_data *);\n-static int check_for_label_ref (rtx *, void *);\n extern void dump_class (struct table_elt*);\n static void get_cse_reg_info_1 (unsigned int regno);\n static struct cse_reg_info * get_cse_reg_info (unsigned int regno);\n@@ -6366,6 +6365,32 @@ cse_prescan_path (struct cse_basic_block_data *data)\n   data->nsets = nsets;\n }\n \f\n+/* Return true if the pattern of INSN uses a LABEL_REF for which\n+   there isn't a REG_LABEL_OPERAND note.  */\n+\n+static bool\n+check_for_label_ref (rtx_insn *insn)\n+{\n+  /* If this insn uses a LABEL_REF and there isn't a REG_LABEL_OPERAND\n+     note for it, we must rerun jump since it needs to place the note.  If\n+     this is a LABEL_REF for a CODE_LABEL that isn't in the insn chain,\n+     don't do this since no REG_LABEL_OPERAND will be added.  */\n+  subrtx_iterator::array_type array;\n+  FOR_EACH_SUBRTX (iter, array, PATTERN (insn), ALL)\n+    {\n+      const_rtx x = *iter;\n+      if (GET_CODE (x) == LABEL_REF\n+\t  && !LABEL_REF_NONLOCAL_P (x)\n+\t  && (!JUMP_P (insn)\n+\t      || !label_is_jump_target_p (XEXP (x, 0), insn))\n+\t  && LABEL_P (XEXP (x, 0))\n+\t  && INSN_UID (XEXP (x, 0)) != 0\n+\t  && !find_reg_note (insn, REG_LABEL_OPERAND, XEXP (x, 0)))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Process a single extended basic block described by EBB_DATA.  */\n \n static void\n@@ -6436,8 +6461,7 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t      /* If we haven't already found an insn where we added a LABEL_REF,\n \t\t check this one.  */\n \t      if (INSN_P (insn) && !recorded_label_ref\n-\t\t  && for_each_rtx (&PATTERN (insn), check_for_label_ref,\n-\t\t\t\t   (void *) insn))\n+\t\t  && check_for_label_ref (insn))\n \t\trecorded_label_ref = true;\n \n #ifdef HAVE_cc0\n@@ -6630,28 +6654,6 @@ cse_main (rtx_insn *f ATTRIBUTE_UNUSED, int nregs)\n     return 0;\n }\n \f\n-/* Called via for_each_rtx to see if an insn is using a LABEL_REF for\n-   which there isn't a REG_LABEL_OPERAND note.\n-   Return one if so.  DATA is the insn.  */\n-\n-static int\n-check_for_label_ref (rtx *rtl, void *data)\n-{\n-  rtx_insn *insn = (rtx_insn *) data;\n-\n-  /* If this insn uses a LABEL_REF and there isn't a REG_LABEL_OPERAND\n-     note for it, we must rerun jump since it needs to place the note.  If\n-     this is a LABEL_REF for a CODE_LABEL that isn't in the insn chain,\n-     don't do this since no REG_LABEL_OPERAND will be added.  */\n-  return (GET_CODE (*rtl) == LABEL_REF\n-\t  && ! LABEL_REF_NONLOCAL_P (*rtl)\n-\t  && (!JUMP_P (insn)\n-\t      || !label_is_jump_target_p (XEXP (*rtl, 0), insn))\n-\t  && LABEL_P (XEXP (*rtl, 0))\n-\t  && INSN_UID (XEXP (*rtl, 0)) != 0\n-\t  && ! find_reg_note (insn, REG_LABEL_OPERAND, XEXP (*rtl, 0)));\n-}\n-\f\n /* Count the number of times registers are used (not set) in X.\n    COUNTS is an array in which we accumulate the count, INCR is how much\n    we count each register usage."}]}