{"sha": "8a9b4fa113286697f34dc57ffb1af08108080c9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE5YjRmYTExMzI4NjY5N2YzNGRjNTdmZmIxYWYwODEwODA4MGM5YQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-11-15T12:34:20Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-11-15T12:34:20Z"}, "message": "tree-cfg.c (replace_loop_annotate_in_block): New function extracted from...\n\n\t* tree-cfg.c (replace_loop_annotate_in_block): New function extracted\n\tfrom...\n\t(replace_loop_annotate): ...here.  Call it on the header and on the\n\tlatch block, if any.  Restore proper behavior of final cleanup.\n\nFrom-SVN: r217602", "tree": {"sha": "081ab31c4d445cce3f0630d61493e9f6ccbb4777", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/081ab31c4d445cce3f0630d61493e9f6ccbb4777"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a9b4fa113286697f34dc57ffb1af08108080c9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a9b4fa113286697f34dc57ffb1af08108080c9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a9b4fa113286697f34dc57ffb1af08108080c9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a9b4fa113286697f34dc57ffb1af08108080c9a/comments", "author": null, "committer": null, "parents": [{"sha": "d03f2c17a2152d2398ad30718d8f050fcd1304a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d03f2c17a2152d2398ad30718d8f050fcd1304a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d03f2c17a2152d2398ad30718d8f050fcd1304a0"}], "stats": {"total": 126, "additions": 92, "deletions": 34}, "files": [{"sha": "bbf3a804cc519f4678bd23876a3a40a2a6fc0462", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9b4fa113286697f34dc57ffb1af08108080c9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9b4fa113286697f34dc57ffb1af08108080c9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a9b4fa113286697f34dc57ffb1af08108080c9a", "patch": "@@ -1,3 +1,10 @@\n+2014-11-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree-cfg.c (replace_loop_annotate_in_block): New function extracted\n+\tfrom...\n+\t(replace_loop_annotate): ...here.  Call it on the header and on the\n+\tlatch block, if any.  Restore proper behavior of final cleanup.\n+\n 2014-11-15  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely): Add log message"}, {"sha": "7f105cc0611d9295644da7a94721cdc59069f6d0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9b4fa113286697f34dc57ffb1af08108080c9a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9b4fa113286697f34dc57ffb1af08108080c9a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8a9b4fa113286697f34dc57ffb1af08108080c9a", "patch": "@@ -1,3 +1,7 @@\n+2014-11-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/opt44.ad[sb]: New test.\n+\n 2014-11-15  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.dg/binding_label_tests_4.f03: Add dg-excess-errors."}, {"sha": "0bd4d6bb7274ebeb4a3f1b4fdf8d34ad420a869a", "filename": "gcc/testsuite/gnat.dg/opt44.adb", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9b4fa113286697f34dc57ffb1af08108080c9a/gcc%2Ftestsuite%2Fgnat.dg%2Fopt44.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9b4fa113286697f34dc57ffb1af08108080c9a/gcc%2Ftestsuite%2Fgnat.dg%2Fopt44.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt44.adb?ref=8a9b4fa113286697f34dc57ffb1af08108080c9a", "patch": "@@ -0,0 +1,19 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O\" }\n+\n+package body Opt44 is\n+\n+   procedure Addsub (X, Y : Sarray; R : out Sarray; N : Integer) is\n+   begin\n+      for I in Sarray'Range loop\n+         pragma Loop_Optimize (Ivdep);\n+         pragma Loop_Optimize (Vector);\n+         if N > 0 then\n+           R(I) := X(I) + Y(I);\n+         else\n+           R(I) := X(I) - Y(I);\n+         end if;\n+      end loop;\n+   end;\n+\n+end Opt44;"}, {"sha": "43822724fb0eb9dcaa47c2a0cf1c95b9a7e4eb91", "filename": "gcc/testsuite/gnat.dg/opt44.ads", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9b4fa113286697f34dc57ffb1af08108080c9a/gcc%2Ftestsuite%2Fgnat.dg%2Fopt44.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9b4fa113286697f34dc57ffb1af08108080c9a/gcc%2Ftestsuite%2Fgnat.dg%2Fopt44.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt44.ads?ref=8a9b4fa113286697f34dc57ffb1af08108080c9a", "patch": "@@ -0,0 +1,8 @@\n+package Opt44 is\n+\n+   type Sarray is array (1 .. 4) of Float;\n+   for Sarray'Alignment use 16;\n+\n+   procedure Addsub (X, Y : Sarray; R : out Sarray; N : Integer);\n+\n+end Opt44;"}, {"sha": "ae7734c5c6a55d667f5b3254de2a1357abff7dc4", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 54, "deletions": 34, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9b4fa113286697f34dc57ffb1af08108080c9a/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9b4fa113286697f34dc57ffb1af08108080c9a/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=8a9b4fa113286697f34dc57ffb1af08108080c9a", "patch": "@@ -265,13 +265,56 @@ build_gimple_cfg (gimple_seq seq)\n   discriminator_per_locus = NULL;\n }\n \n+/* Look for ANNOTATE calls with loop annotation kind in BB; if found, remove\n+   them and propagate the information to LOOP.  We assume that the annotations\n+   come immediately before the condition in BB, if any.  */\n+\n+static void\n+replace_loop_annotate_in_block (basic_block bb, struct loop *loop)\n+{\n+  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+  gimple stmt = gsi_stmt (gsi);\n+\n+  if (!(stmt && gimple_code (stmt) == GIMPLE_COND))\n+    return;\n+\n+  for (gsi_prev_nondebug (&gsi); !gsi_end_p (gsi); gsi_prev (&gsi))\n+    {\n+      stmt = gsi_stmt (gsi);\n+      if (gimple_code (stmt) != GIMPLE_CALL)\n+\tbreak;\n+      if (!gimple_call_internal_p (stmt)\n+\t  || gimple_call_internal_fn (stmt) != IFN_ANNOTATE)\n+\tbreak;\n+\n+      switch ((annot_expr_kind) tree_to_shwi (gimple_call_arg (stmt, 1)))\n+\t{\n+\tcase annot_expr_ivdep_kind:\n+\t  loop->safelen = INT_MAX;\n+\t  break;\n+\tcase annot_expr_no_vector_kind:\n+\t  loop->dont_vectorize = true;\n+\t  break;\n+\tcase annot_expr_vector_kind:\n+\t  loop->force_vectorize = true;\n+\t  cfun->has_force_vectorize_loops = true;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      stmt = gimple_build_assign (gimple_call_lhs (stmt),\n+\t\t\t\t  gimple_call_arg (stmt, 0));\n+      gsi_replace (&gsi, stmt, true);\n+    }\n+}\n \n /* Look for ANNOTATE calls with loop annotation kind; if found, remove\n    them and propagate the information to the loop.  We assume that the\n    annotations come immediately before the condition of the loop.  */\n \n static void\n-replace_loop_annotate ()\n+replace_loop_annotate (void)\n {\n   struct loop *loop;\n   basic_block bb;\n@@ -280,37 +323,12 @@ replace_loop_annotate ()\n \n   FOR_EACH_LOOP (loop, 0)\n     {\n-      gsi = gsi_last_bb (loop->header);\n-      stmt = gsi_stmt (gsi);\n-      if (!(stmt && gimple_code (stmt) == GIMPLE_COND))\n-\tcontinue;\n-      for (gsi_prev_nondebug (&gsi); !gsi_end_p (gsi); gsi_prev (&gsi))\n-\t{\n-\t  stmt = gsi_stmt (gsi);\n-\t  if (gimple_code (stmt) != GIMPLE_CALL)\n-\t    break;\n-\t  if (!gimple_call_internal_p (stmt)\n-\t      || gimple_call_internal_fn (stmt) != IFN_ANNOTATE)\n-\t    break;\n-\t  switch ((annot_expr_kind) tree_to_shwi (gimple_call_arg (stmt, 1)))\n-\t    {\n-\t    case annot_expr_ivdep_kind:\n-\t      loop->safelen = INT_MAX;\n-\t      break;\n-\t    case annot_expr_no_vector_kind:\n-\t      loop->dont_vectorize = true;\n-\t      break;\n-\t    case annot_expr_vector_kind:\n-\t      loop->force_vectorize = true;\n-\t      cfun->has_force_vectorize_loops = true;\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t  stmt = gimple_build_assign (gimple_call_lhs (stmt),\n-\t\t\t\t      gimple_call_arg (stmt, 0));\n-\t  gsi_replace (&gsi, stmt, true);\n-\t}\n+      /* First look into the header.  */\n+      replace_loop_annotate_in_block (loop->header, loop);\n+\n+      /* Then look into the latch, if any.  */\n+      if (loop->latch)\n+\treplace_loop_annotate_in_block (loop->latch, loop);\n     }\n \n   /* Remove IFN_ANNOTATE.  Safeguard for the case loop->latch == NULL.  */\n@@ -320,10 +338,11 @@ replace_loop_annotate ()\n \t{\n \t  stmt = gsi_stmt (gsi);\n \t  if (gimple_code (stmt) != GIMPLE_CALL)\n-\t    break;\n+\t    continue;\n \t  if (!gimple_call_internal_p (stmt)\n \t      || gimple_call_internal_fn (stmt) != IFN_ANNOTATE)\n-\t    break;\n+\t    continue;\n+\n \t  switch ((annot_expr_kind) tree_to_shwi (gimple_call_arg (stmt, 1)))\n \t    {\n \t    case annot_expr_ivdep_kind:\n@@ -333,6 +352,7 @@ replace_loop_annotate ()\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n+\n \t  warning_at (gimple_location (stmt), 0, \"ignoring loop annotation\");\n \t  stmt = gimple_build_assign (gimple_call_lhs (stmt),\n \t\t\t\t      gimple_call_arg (stmt, 0));"}]}