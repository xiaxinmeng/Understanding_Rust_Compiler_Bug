{"sha": "35ba173387bbe16802679a210357c800a4ee55f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzViYTE3MzM4N2JiZTE2ODAyNjc5YTIxMDM1N2M4MDBhNGVlNTVmMA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-10-05T11:36:52Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-10-05T11:36:52Z"}, "message": "include: New directory.\n\n\n2000-10-05  Benjamin Kosnik  <bkoz@cygnus.com>\n\n\t* include: New directory.\n\t* include/backward: New directory.\n\t* include/bits: New directory.\n\t* include/ext: New directory.\n\t* include/std: New directory.\n\t* include/*/*: Populate.\n\n\t* backwards: Move to include/backwards, delete.\n\t* bits: Move to include/bits, delete.\n\t* ext: Move to include/ext, delete.\n\t* std: Move to include/std, delete.\n\n\t* src/complex.cc: Adjust include of mathconf.\n\n\t* mkc++config (BASE_H): Add include.\n\n\t* src/Makefile.am: Support for topleve sources include directory.\n\t(INCLUDES): Add LIBMATH_INCLUDE.\n\t* src/Makefile.in: Regenerate.\n\t* math/Makefile.am (INCLUDES): Append /include.\n\t* math/Makefile.in: Regenerate.\n\t* libio/Makefile.am (INCLUDES): Add glibcpp_includedir.\n\t* libio/Makefile.in: Regenerate.\n\n2\n\nFrom-SVN: r36725", "tree": {"sha": "0f375662662595a9326a4448f891d1acf585cda4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f375662662595a9326a4448f891d1acf585cda4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35ba173387bbe16802679a210357c800a4ee55f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35ba173387bbe16802679a210357c800a4ee55f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35ba173387bbe16802679a210357c800a4ee55f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35ba173387bbe16802679a210357c800a4ee55f0/comments", "author": null, "committer": null, "parents": [{"sha": "9fab27938873b3a2a44e44e2050c23ee98e67e58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fab27938873b3a2a44e44e2050c23ee98e67e58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fab27938873b3a2a44e44e2050c23ee98e67e58"}], "stats": {"total": 10491, "additions": 130, "deletions": 10361}, "files": [{"sha": "5f920aff0411cc11de8cf81f87bbfb20f9e4c227", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=35ba173387bbe16802679a210357c800a4ee55f0", "patch": "@@ -1,3 +1,29 @@\n+2000-10-05  Benjamin Kosnik  <bkoz@cygnus.com>\n+\n+\t* include: New directory.\n+\t* include/backward: New directory.\n+\t* include/bits: New directory.\n+\t* include/ext: New directory.\n+\t* include/std: New directory.\n+\t* include/*/*: Populate.\n+\n+\t* backwards: Move to include/backwards, delete.\n+\t* bits: Move to include/bits, delete.\n+\t* ext: Move to include/ext, delete.\n+\t* std: Move to include/std, delete.\n+\t\n+\t* src/complex.cc: Adjust include of mathconf.\n+\n+\t* mkc++config (BASE_H): Add include.\n+\n+\t* src/Makefile.am: Support for topleve sources include directory.\n+\t(INCLUDES): Add LIBMATH_INCLUDE.\n+\t* src/Makefile.in: Regenerate.\n+\t* math/Makefile.am (INCLUDES): Append /include.\n+\t* math/Makefile.in: Regenerate.\n+\t* libio/Makefile.am (INCLUDES): Add glibcpp_includedir.\n+\t* libio/Makefile.in: Regenerate.\n+\t\n 2000-10-04  Benjamin Kosnik  <bkoz@gnu.org>\n \n \t* libio/_G_config.h : Re-guard the __mbstate_t declaration."}, {"sha": "b46d3242309fedea7e34b4fd0fc00b19272cc489", "filename": "libstdc++-v3/backward/algo.h", "status": "removed", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Falgo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Falgo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Falgo.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,114 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _CPP_BACKWARD_ALGO_H\n-#define _CPP_BACKWARD_ALGO_H 1\n-\n-#include \"algobase.h\"\n-#include \"tempbuf.h\"\n-#include <bits/stl_algo.h>\n-#include <bits/stl_numeric.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-\n-// Names from <stl_algo.h>\n-using __STD::for_each; \n-using __STD::find; \n-using __STD::find_if; \n-using __STD::adjacent_find; \n-using __STD::count; \n-using __STD::count_if; \n-using __STD::search; \n-using __STD::search_n; \n-using __STD::swap_ranges; \n-using __STD::transform; \n-using __STD::replace; \n-using __STD::replace_if; \n-using __STD::replace_copy; \n-using __STD::replace_copy_if; \n-using __STD::generate; \n-using __STD::generate_n; \n-using __STD::remove; \n-using __STD::remove_if; \n-using __STD::remove_copy; \n-using __STD::remove_copy_if; \n-using __STD::unique; \n-using __STD::unique_copy; \n-using __STD::reverse; \n-using __STD::reverse_copy; \n-using __STD::rotate; \n-using __STD::rotate_copy; \n-using __STD::random_shuffle; \n-using __STD::random_sample; \n-using __STD::random_sample_n; \n-using __STD::partition; \n-using __STD::stable_partition; \n-using __STD::sort; \n-using __STD::stable_sort; \n-using __STD::partial_sort; \n-using __STD::partial_sort_copy; \n-using __STD::nth_element; \n-using __STD::lower_bound; \n-using __STD::upper_bound; \n-using __STD::equal_range; \n-using __STD::binary_search; \n-using __STD::merge; \n-using __STD::inplace_merge; \n-using __STD::includes; \n-using __STD::set_union; \n-using __STD::set_intersection; \n-using __STD::set_difference; \n-using __STD::set_symmetric_difference; \n-using __STD::min_element; \n-using __STD::max_element; \n-using __STD::next_permutation; \n-using __STD::prev_permutation; \n-using __STD::find_first_of; \n-using __STD::find_end; \n-using __STD::is_sorted; \n-using __STD::is_heap; \n-\n-// Names from stl_heap.h\n-using __STD::push_heap;\n-using __STD::pop_heap;\n-using __STD::make_heap;\n-using __STD::sort_heap;\n-\n-// Names from stl_numeric.h\n-using __STD::accumulate; \n-using __STD::inner_product; \n-using __STD::partial_sum; \n-using __STD::adjacent_difference; \n-using __STD::power; \n-using __STD::iota; \n-\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_ALGO_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "b5c807a882fbb586af238b9320e68e6d989c7752", "filename": "libstdc++-v3/backward/algobase.h", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Falgobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Falgobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Falgobase.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,71 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _CPP_BACKWARD_ALGOBASE_H\n-#define _CPP_BACKWARD_ALGOBASE_H 1\n-\n-#ifndef _CPP_BACKWARD_PAIR_H\n-#include \"pair.h\"\n-#endif\n-#ifndef _CPP_BACKWARD_ITERATOR_H\n-#include \"iterator.h\"\n-#endif\n-#ifndef _CPP_BITS_STL__ALGOBASE_H\n-#include <bits/stl_algobase.h>\n-#endif\n-#ifndef _CPP_BITS_STL_UNINITIALIZED_H\n-#include <bits/stl_uninitialized.h>\n-#endif\n-\n-#ifdef __STL_USE_NAMESPACES\n-\n-// Names from stl_algobase.h\n-using __STD::iter_swap; \n-using __STD::swap; \n-using __STD::min; \n-using __STD::max; \n-using __STD::copy; \n-using __STD::copy_backward; \n-using __STD::copy_n; \n-using __STD::fill; \n-using __STD::fill_n; \n-using __STD::mismatch; \n-using __STD::equal; \n-using __STD::lexicographical_compare; \n-using __STD::lexicographical_compare_3way; \n-\n-// Names from stl_uninitialized.h\n-using __STD::uninitialized_copy;\n-using __STD::uninitialized_copy_n;\n-using __STD::uninitialized_fill;\n-using __STD::uninitialized_fill_n;\n-\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_ALGOBASE_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "3ec1304a8e7510306461acd9799e856175aa806b", "filename": "libstdc++-v3/backward/alloc.h", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Falloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Falloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Falloc.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,48 +0,0 @@\n-/*\n- * Copyright (c) 1996-1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _CPP_BACKWARD_ALLOC_H\n-#define _CPP_BACKWARD_ALLOC_H 1\n-\n-#ifndef _CPP_BITS_STL_CONFIG_H\n-#include <bits/stl_config.h>\n-#endif\n-#ifndef _CPP_BITS_STL_ALLOC_H\n-#include <bits/stl_alloc.h>\n-#endif\n-\n-#ifdef __STL_USE_NAMESPACES\n-\n-using __STD::__malloc_alloc_template; \n-using __STD::malloc_alloc; \n-using __STD::simple_alloc; \n-using __STD::debug_alloc; \n-#ifndef __USE_MALLOC\n-using __STD::__default_alloc_template; \n-#endif\n-using __STD::alloc; \n-using __STD::single_client_alloc; \n-#ifdef __STL_STATIC_TEMPLATE_MEMBER_BUG\n-using __STD::__malloc_alloc_oom_handler; \n-#endif /* __STL_STATIC_TEMPLATE_MEMBER_BUG */\n-#ifdef __STL_USE_STD_ALLOCATORS \n-using __STD::allocator;\n-#endif /* __STL_USE_STD_ALLOCATORS */\n-\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_ALLOC_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "ed9225404858ba8e8d210252f4532a63680c073b", "filename": "libstdc++-v3/backward/bvector.h", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fbvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fbvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fbvector.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,51 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _CPP_BACKWARD_BVECTOR_H\n-#define _CPP_BACKWARD_BVECTOR_H 1\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-#include \"vector.h\"\n-#else\n-#include \"algobase.h\"\n-#include \"alloc.h\"\n-#endif \n-\n-#include <bits/stl_bvector.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-\n-using __STD::bit_vector;\n-\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_BVECTOR_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:\n-\n-"}, {"sha": "97e0852068ba0bb092af794bd3248fe9a3420a40", "filename": "libstdc++-v3/backward/complex.h", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fcomplex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fcomplex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fcomplex.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,47 +0,0 @@\n-\n-// Copyright (C) 2000 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _CPP_BACKWARD_COMPLEX_H\n-#define _CPP_BACKWARD_COMPLEX_H 1\n-\n-#include <bits/stl_config.h>\n-#include <bits/std_complex.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::complex;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-typedef complex<float> float_complex;\n-typedef complex<double> double_complex;\n-typedef complex<long double> long_double_complex;\n-\n-#endif /* _CPP_BACKWARD_COMPLEX_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "8edee690bc6f98dad2ad0a9d81aac04fd1055cf7", "filename": "libstdc++-v3/backward/defalloc.h", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fdefalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fdefalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fdefalloc.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,87 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- */\n-\n-// Inclusion of this file is DEPRECATED.  This is the original HP\n-// default allocator.  It is provided only for backward compatibility.\n-// This file WILL BE REMOVED in a future release.\n-//\n-// DO NOT USE THIS FILE unless you have an old container implementation\n-// that requires an allocator with the HP-style interface.  \n-//\n-// Standard-conforming allocators have a very different interface.  The\n-// standard default allocator is declared in the header <memory>.\n-\n-#ifndef _CPP_BACKWARD_DEFALLOC_H\n-#define _CPP_BACKWARD_DEFALLOC_H 1\n-\n-#include \"new.h\"\n-#include <stddef.h>\n-#include <stdlib.h>\n-#include <limits.h> \n-#include \"iostream.h\" \n-#include \"algobase.h\"\n-\n-\n-template <class _Tp>\n-inline _Tp* allocate(ptrdiff_t __size, _Tp*) {\n-    set_new_handler(0);\n-    _Tp* __tmp = (_Tp*)(::operator new((size_t)(__size * sizeof(_Tp))));\n-    if (__tmp == 0) {\n-\tcerr << \"out of memory\" << endl; \n-\texit(1);\n-    }\n-    return __tmp;\n-}\n-\n-\n-template <class _Tp>\n-inline void deallocate(_Tp* __buffer) {\n-    ::operator delete(__buffer);\n-}\n-\n-template <class _Tp>\n-class allocator {\n-public:\n-    typedef _Tp value_type;\n-    typedef _Tp* pointer;\n-    typedef const _Tp* const_pointer;\n-    typedef _Tp& reference;\n-    typedef const _Tp& const_reference;\n-    typedef size_t size_type;\n-    typedef ptrdiff_t difference_type;\n-    pointer allocate(size_type __n) { \n-\treturn ::allocate((difference_type)__n, (pointer)0);\n-    }\n-    void deallocate(pointer __p) { ::deallocate(__p); }\n-    pointer address(reference __x) { return (pointer)&__x; }\n-    const_pointer const_address(const_reference __x) { \n-\treturn (const_pointer)&__x; \n-    }\n-    size_type init_page_size() { \n-\treturn max(size_type(1), size_type(4096/sizeof(_Tp))); \n-    }\n-    size_type max_size() const { \n-\treturn max(size_type(1), size_type(UINT_MAX/sizeof(_Tp))); \n-    }\n-};\n-\n-class allocator<void> {\n-public:\n-    typedef void* pointer;\n-};\n-\n-\n-\n-#endif /* _CPP_BACKWARD_DEFALLOC_H */"}, {"sha": "fc47056c5ee4a5e6aa1b7c41c6c5f34813654d1d", "filename": "libstdc++-v3/backward/deque.h", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fdeque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fdeque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fdeque.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,42 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _CPP_BACKWARD_DEQUE_H\n-#define _CPP_BACKWARD_DEQUE_H 1\n-\n-#include \"algobase.h\"\n-#include \"alloc.h\"\n-#include <bits/std_deque.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::deque;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_DEQUE_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "a346faf994c0bb01ad2088a87345dca14630e8ca", "filename": "libstdc++-v3/backward/fstream.h", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Ffstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Ffstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Ffstream.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,50 +0,0 @@\n-// Copyright (C) 2000 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _CPP_BACKWARD_FSTREAM_H\n-#define _CPP_BACKWARD_FSTREAM_H 1\n-\n-#include <bits/std_fstream.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::ifstream;\n-using __STD::ofstream;\n-using __STD::fstream;\n-\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-using __STD::wifstream;\n-using __STD::wofstream;\n-using __STD::wfstream;\n-#endif\n-\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_FSTREAM_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "7988ae99c2b2fce0a408598b2cc7a437744214bb", "filename": "libstdc++-v3/backward/function.h", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Ffunction.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,118 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _CPP_BACKWARD_FUNCTION_H\n-#define _CPP_BACKWARD_FUNCTION_H 1\n-\n-#ifndef _CPP_BITS_STL_CONFIG_H\n-#include <bits/stl_config.h>\n-#endif\n-#ifndef _CPP_BITS_STL_RELOPS\n-#include <bits/stl_relops.h>\n-#endif\n-#include <stddef.h>\n-#ifndef _CPP_BITS_STL_FUNCTION_H\n-#include <bits/stl_function.h>\n-#endif\n-\n-#ifdef __STL_USE_NAMESPACE_FOR_RELOPS\n-\n-// Names from stl_relops.h\n-using __STD_RELOPS::operator!=;\n-using __STD_RELOPS::operator>;\n-using __STD_RELOPS::operator<=;\n-using __STD_RELOPS::operator>=;\n-\n-#endif /* __STL_USE_NAMESPACE_FOR_RELOPS */\n-\n-#ifdef __STL_USE_NAMESPACES\n-\n-// Names from stl_function.h\n-using __STD::unary_function; \n-using __STD::binary_function; \n-using __STD::plus; \n-using __STD::minus; \n-using __STD::multiplies; \n-using __STD::divides; \n-using __STD::identity_element; \n-using __STD::modulus; \n-using __STD::negate; \n-using __STD::equal_to; \n-using __STD::not_equal_to; \n-using __STD::greater; \n-using __STD::less; \n-using __STD::greater_equal; \n-using __STD::less_equal; \n-using __STD::logical_and; \n-using __STD::logical_or; \n-using __STD::logical_not; \n-using __STD::unary_negate; \n-using __STD::binary_negate; \n-using __STD::not1; \n-using __STD::not2; \n-using __STD::binder1st; \n-using __STD::binder2nd; \n-using __STD::bind1st; \n-using __STD::bind2nd; \n-using __STD::unary_compose; \n-using __STD::binary_compose; \n-using __STD::compose1; \n-using __STD::compose2; \n-using __STD::pointer_to_unary_function; \n-using __STD::pointer_to_binary_function; \n-using __STD::ptr_fun; \n-using __STD::identity; \n-using __STD::select1st; \n-using __STD::select2nd; \n-using __STD::project1st; \n-using __STD::project2nd; \n-using __STD::constant_void_fun; \n-using __STD::constant_unary_fun; \n-using __STD::constant_binary_fun; \n-using __STD::constant0; \n-using __STD::constant1; \n-using __STD::constant2; \n-using __STD::subtractive_rng; \n-using __STD::mem_fun_t; \n-using __STD::const_mem_fun_t; \n-using __STD::mem_fun_ref_t; \n-using __STD::const_mem_fun_ref_t; \n-using __STD::mem_fun1_t; \n-using __STD::const_mem_fun1_t; \n-using __STD::mem_fun1_ref_t; \n-using __STD::const_mem_fun1_ref_t; \n-using __STD::mem_fun; \n-using __STD::mem_fun_ref; \n-using __STD::mem_fun1; \n-using __STD::mem_fun1_ref; \n-\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_FUNCTION_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "ebf0cb8f84be3c9c0dc9a78f98abc4b62bf16955", "filename": "libstdc++-v3/backward/hash_map.h", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fhash_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fhash_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fhash_map.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,49 +0,0 @@\n-/*\n- * Copyright (c) 1996\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- */\n-\n-#ifndef _CPP_BACKWARD_HASH_MAP_H\n-#define _CPP_BACKWARD_HASH_MAP_H 1\n-\n-#ifndef _CPP_BITS_STL_HASHTABLE_H\n-#include <bits/stl_hashtable.h>\n-#endif \n-\n-#include \"algobase.h\"\n-#include <bits/stl_hash_map.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::hash;\n-using __STD::hashtable;\n-using __STD::hash_map;\n-using __STD::hash_multimap;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-\n-#endif /* _CPP_BACKWARD_HASH_MAP_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "140ce6048c6d1a64943453ef9bb81f30af641413", "filename": "libstdc++-v3/backward/hash_set.h", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fhash_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fhash_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fhash_set.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,44 +0,0 @@\n-/*\n- * Copyright (c) 1996\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- */\n-\n-#ifndef _CPP_BACKWARD_HASH_SET_H\n-#define _CPP_BACKWARD_HASH_SET_H 1\n-\n-#ifndef _CPP_BITS_STL_HASHTABLE_H\n-#include <bits/stl_hashtable.h>\n-#endif \n-\n-#include \"algobase.h\"\n-#include <bits/stl_hash_set.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::hash;\n-using __STD::hashtable;\n-using __STD::hash_set;\n-using __STD::hash_multiset;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_HASH_SET_H */"}, {"sha": "bd0f4f47433f3c3d2f72c5b733b0f84f16c9d48e", "filename": "libstdc++-v3/backward/hashtable.h", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fhashtable.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,48 +0,0 @@\n-/*\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- */\n-\n-/* NOTE: This is an internal header file, included by other STL headers.\n- *   You should not attempt to use it directly.\n- */\n-\n-#ifndef _CPP_BACKWARD_HASHTABLE_H\n-#define _CPP_BACKWARD_HASHTABLE_H 1\n-\n-#include <bits/stl_hashtable.h>\n-#include \"algo.h\"\n-#include \"alloc.h\"\n-#include \"vector.h\"\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::hash;\n-using __STD::hashtable;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_HASHTABLE_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "0256fc62e7ed7b4fa06ef717491f88d68aa78212", "filename": "libstdc++-v3/backward/heap.h", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fheap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fheap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fheap.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,46 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- * Copyright (c) 1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _CPP_BACKWARD_HEAP_H\n-#define _CPP_BACKWARD_HEAP_H 1\n-\n-#include <bits/stl_config.h>\n-#include <bits/stl_heap.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-\n-using __STD::push_heap;\n-using __STD::pop_heap;\n-using __STD::make_heap;\n-using __STD::sort_heap;\n-\n-#endif /* __STL_USE_NAMESPACES */\n-\n-\n-#endif /* _CPP_BACKWARD_HEAP_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "206a3880b66b07f8d65970ea17e14d2e18f53581", "filename": "libstdc++-v3/backward/iomanip.h", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fiomanip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fiomanip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fiomanip.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,48 +0,0 @@\n-\n-// Copyright (C) 2000 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _CPP_BACKWARD_IOMANIP_H\n-#define _CPP_BACKWARD_IOMANIP_H 1\n-\n-#include <backward/iostream.h>\n-#include <bits/std_iomanip.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::resetiosflags;\n-using __STD::setiosflags;\n-using __STD::setbase;\n-using __STD::setfill;\n-using __STD::setprecision;\n-using __STD::setw;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_IOMANIP_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "2caee39adc4be1129aadeae84ad4a73786f55d2d", "filename": "libstdc++-v3/backward/iostream.h", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fiostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fiostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fiostream.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,60 +0,0 @@\n-\n-// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _CPP_BACKWARD_IOSTREAM_H\n-#define _CPP_BACKWARD_IOSTREAM_H 1\n-\n-#include <bits/std_iostream.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::iostream;\n-using __STD::ostream;\n-using __STD::istream;\n-using __STD::ios;\n-using __STD::streambuf;\n-\n-using __STD::cout;\n-using __STD::cin;\n-using __STD::cerr;\n-using __STD::clog;\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-using __STD::wcout;\n-using __STD::wcin;\n-using __STD::wcerr;\n-using __STD::wclog;\n-#endif\n-\n-using __STD::endl;\n-using __STD::ends;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_IOSTREAM_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "f45709267eb7d3bffdeb8e408782ccde900a1a7d", "filename": "libstdc++-v3/backward/istream.h", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fistream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fistream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fistream.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,37 +0,0 @@\n-// Copyright (C) 2000 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _CPP_BACKWARD_ISTREAM_H\n-#define _CPP_BACKWARD_ISTREAM_H 1\n-\n-#include <backward/iostream.h>\n-\n-#endif /* _CPP_BACKWARD_ISTREAM_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "40185036b3be9f1d2804c25bb0adef66db00af2b", "filename": "libstdc++-v3/backward/iterator.h", "status": "removed", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fiterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fiterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fiterator.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,104 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _CPP_BACKWARD_ITERATOR_H\n-#define _CPP_BACKWARD_ITERATOR_H 1\n-\n-#ifndef _CPP_BACKWARD_FUNCTION_H\n-#include \"function.h\"\n-#endif\n-#include <stddef.h>\n-#include \"iostream.h\"\n-#ifndef _CPP_BITS_STL_ITERATOR_H\n-#include <bits/stl_iterator.h>\n-#endif\n-#ifndef _CPP_BITS_TYPE_TRAITS_H\n-#include <bits/type_traits.h>\n-#endif\n-#ifndef _CPP_BITS_STL_CONSTRUCT_H\n-#include <bits/stl_construct.h>\n-#endif\n-#ifndef _CPP_BITS_STL_RAW_STORAGE_ITERATOR_H\n-#include <bits/stl_raw_storage_iter.h>\n-#endif\n-\n-#ifdef __STL_USE_NAMESPACES\n-\n-// Names from stl_iterator.h\n-\n-using __STD::input_iterator_tag;\n-using __STD::output_iterator_tag;\n-using __STD::forward_iterator_tag;\n-using __STD::bidirectional_iterator_tag;\n-using __STD::random_access_iterator_tag;\n-\n-#if 0\n-using __STD::iterator;\n-#endif\n-using __STD::input_iterator;\n-using __STD::output_iterator;\n-using __STD::forward_iterator;\n-using __STD::bidirectional_iterator;\n-using __STD::random_access_iterator;\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-using __STD::iterator_traits;\n-#endif\n-\n-using __STD::iterator_category;\n-using __STD::distance_type;\n-using __STD::value_type;\n-\n-using __STD::distance; \n-using __STD::advance; \n-\n-using __STD::insert_iterator;\n-using __STD::front_insert_iterator;\n-using __STD::back_insert_iterator;\n-using __STD::inserter;\n-using __STD::front_inserter;\n-using __STD::back_inserter;\n-\n-using __STD::reverse_iterator;\n-using __STD::reverse_bidirectional_iterator;\n-\n-using __STD::istream_iterator;\n-using __STD::ostream_iterator;\n-\n-// Names from stl_construct.h\n-using __STD::construct;\n-using __STD::destroy;\n-\n-// Names from stl_raw_storage_iter.h\n-using __STD::raw_storage_iterator;\n-\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_ITERATOR_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "9a719ff95941d08332a9832d1d7099ac755d24d2", "filename": "libstdc++-v3/backward/list.h", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Flist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Flist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Flist.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,42 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _CPP_BACKWARD_LIST_H\n-#define _CPP_BACKWARD_LIST_H 1\n-\n-#include <bits/stl_algobase.h>\n-#include \"alloc.h\"\n-#include <bits/std_list.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::list;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_LIST_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "cf0fe2bc638876955a44180f212e281e98111795", "filename": "libstdc++-v3/backward/map.h", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fmap.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,41 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _CPP_BACKWARD_MAP_H\n-#define _CPP_BACKWARD_MAP_H 1\n-\n-#include \"tree.h\"\n-#include <bits/stl_map.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::map;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_MAP_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "157e3331aa90d4562d3f6177fffa5eea480c4e91", "filename": "libstdc++-v3/backward/multimap.h", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fmultimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fmultimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fmultimap.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,41 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _CPP_BACKWARD_MULTIMAP_H\n-#define _CPP_BACKWARD_MULTIMAP_H 1\n-\n-#include \"tree.h\"\n-#include <bits/stl_multimap.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::multimap;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_MULTIMAP_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "270a5da8ca348f3c6aa91159041e4beb4c0bfae7", "filename": "libstdc++-v3/backward/multiset.h", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fmultiset.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,41 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _CPP_BACKWARD_MULTISET_H\n-#define _CPP_BACKWARD_MULTISET_H 1\n-\n-#include \"tree.h\"\n-#include <bits/stl_multiset.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::multiset;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_MULTISET_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "20e57dee8de66c364ff9e63479fabf9b833302d9", "filename": "libstdc++-v3/backward/new.h", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fnew.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fnew.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fnew.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,46 +0,0 @@\n-\n-// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _CPP_BACKWARD_NEW_H\n-#define _CPP_BACKWARD_NEW_H 1\n-\n-#include <bits/std_new.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::bad_alloc;\n-using __STD::nothrow_t;\n-using __STD::nothrow;\n-using __STD::new_handler;\n-using __STD::set_new_handler;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_NEW_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "740588a277b8ec89af4cbea5cd9cb2b5eeb2308e", "filename": "libstdc++-v3/backward/ostream.h", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fostream.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,37 +0,0 @@\n-// Copyright (C) 2000 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _CPP_BACKWARD_OSTREAM_H\n-#define _CPP_BACKWARD_OSTREAM_H 1\n-\n-#include <backward/iostream.h>\n-\n-#endif /* _CPP_BACKWARD_OSTREAM_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "275a205bb6ea935bcff263070e11815ce3c3bab7", "filename": "libstdc++-v3/backward/pair.h", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fpair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fpair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fpair.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,51 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _CPP_BACKWARD_PAIR_H\n-#define _CPP_BACKWARD_PAIR_H 1\n-\n-#ifndef _CPP_BITS_STL_CONFIG_H\n-#include <bits/stl_config.h>\n-#endif\n-#ifndef _CPP_BITS_STL_RELOPS_H\n-#include <bits/stl_relops.h>\n-#endif\n-#ifndef _CPP_BITS_STL_PAIR_H\n-#include <bits/stl_pair.h>\n-#endif\n-\n-#ifdef __STL_USE_NAMESPACES\n-\n-using __STD::pair;\n-using __STD::make_pair;\n-\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_PAIR_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "7d32f87497ed88f298e09a32cf8c77625cfd0896", "filename": "libstdc++-v3/backward/rope.h", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Frope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Frope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Frope.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,34 +0,0 @@\n-/*\n- * Copyright (c) 1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _CPP_BACKWARD_ROPE_H\n-#define _CPP_BACKWARD_ROPE_H 1\n-\n-#include \"hashtable.h\"   \n-#include <bits/stl_rope.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-\n-using __STD::char_producer; \n-using __STD::sequence_buffer; \n-using __STD::rope; \n-using __STD::crope; \n-using __STD::wrope; \n-\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_ROPE_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "e05890e046efda61860ff70467ae9ac277f89a82", "filename": "libstdc++-v3/backward/set.h", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fset.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,41 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _CPP_BACKWARD_SET_H\n-#define _CPP_BACKWARD_SET_H 1\n-\n-#include \"tree.h\"\n-#include <bits/stl_set.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::set;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_SET_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "8c63282d1ca06fb1306a65da2bcdab76e7d53f5a", "filename": "libstdc++-v3/backward/slist.h", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fslist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fslist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fslist.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,28 +0,0 @@\n-/*\n- * Copyright (c) 1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- */\n-\n-#ifndef _CPP_BACKWARD_SLIST_H\n-#define _CPP_BACKWARD_SLIST_H 1\n-\n-#include <ext/slist>\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::slist;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_SLIST_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "4140f409970ced8132af43be08c24cd9aaef287c", "filename": "libstdc++-v3/backward/stack.h", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fstack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fstack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fstack.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,46 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _CPP_BACKWARD_STACK_H\n-#define _CPP_BACKWARD_STACK_H 1\n-\n-#include \"vector.h\"\n-#include \"deque.h\"\n-#include \"heap.h\"\n-#include <bits/stl_stack.h>\n-#include <bits/stl_queue.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::stack;\n-using __STD::queue;\n-using __STD::priority_queue;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_STACK_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "f829b0dd577a3d47235ff336fe8ab0b17e5182a8", "filename": "libstdc++-v3/backward/stream.h", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fstream.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,37 +0,0 @@\n-// Copyright (C) 2000 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _CPP_BACKWARD_STREAM_H\n-#define _CPP_BACKWARD_STREAM_H 1\n-\n-#include <backward/iostream.h>\n-\n-#endif /* _CPP_BACKWARD_STREAM_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "f693fcd54dee5363a49fd289e372c7007b583ad3", "filename": "libstdc++-v3/backward/strstream.h", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fstrstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fstrstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fstrstream.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,44 +0,0 @@\n-// Copyright (C) 2000 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _CPP_BACKWARD_STRSTREAM_H\n-#define _CPP_BACKWARD_STRSTREAM_H 1\n-\n-#include <bits/std_strstream.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::strstreambuf;\n-using __STD::istrstream;\n-using __STD::ostrstream;\n-using __STD::strstream;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_STRSTREAM_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "82e5c8e811b17927f3551f29bc53ec159966758d", "filename": "libstdc++-v3/backward/tempbuf.h", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Ftempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Ftempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Ftempbuf.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,62 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _CPP_BACKWARD_TEMPBUF_H\n-#define _CPP_BACKWARD_TEMPBUF_H 1\n-\n-#ifndef _CPP_BACKWARD_PAIR_H\n-#include \"pair.h\"\n-#endif\n-#include <iterator.h>\n-#include <limits.h>\n-#include <stddef.h> \n-#include <stdlib.h> \n-#ifndef _CPP_BITS_TYPE_TRAITS_H\n-#include <bits/type_traits.h>  \n-#endif\n-#ifndef _CPP_BITS_STL_CONSTRUCT_H\n-#include <bits/stl_construct.h>\n-#endif\n-#ifndef _CPP_BITS_STL_UNINITIALIZED_H\n-#include <bits/stl_uninitialized.h>\n-#endif\n-#ifndef _CPP_BITS_STL_TEMPBUF_H\n-#include <bits/stl_tempbuf.h>\n-#endif\n-\n-#ifdef __STL_USE_NAMESPACES\n-\n-using __STD::get_temporary_buffer;\n-using __STD::return_temporary_buffer;\n-using __STD::_Temporary_buffer;\n-\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_TEMPBUF_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "64e89ad36fe880c71645008e08549d0e7c95cbd9", "filename": "libstdc++-v3/backward/tree.h", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Ftree.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,46 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- */\n-\n-#ifndef _CPP_BACKWARD_TREE_H\n-#define _CPP_BACKWARD_TREE_H 1\n-\n-#ifndef _CPP_BITS_STL_TREE_H\n-#include <bits/stl_tree.h>\n-#endif\n-#include \"algobase.h\" \n-#include \"alloc.h\"\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::rb_tree;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_TREE_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "8a7e8f940401a653ea03ad82747a6c29a2d2808c", "filename": "libstdc++-v3/backward/vector.h", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fbackward%2Fvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbackward%2Fvector.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,42 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _CPP_BACKWARD_VECTOR_H\n-#define _CPP_BACKWARD_VECTOR_H 1\n-\n-#include \"algobase.h\"\n-#include \"alloc.h\"  \n-#include <bits/stl_vector.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-using __STD::vector;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* _CPP_BACKWARD_VECTOR_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "2ece99c7160547eb7b079ab5d57cc5191e3da362", "filename": "libstdc++-v3/ext/bvector", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Fbvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Fbvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fbvector?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,52 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef __SGI_STL_BVECTOR_H\n-#define __SGI_STL_BVECTOR_H\n-\n-#include <bits/stl_range_errors.h>\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-#include <bits/std_vector.h>\n-#else\n-#include <bits/std_algobase.h>\n-#include <bits/atl_alloc.h>\n-#endif \n-\n-#include <ext/stl_bvector.h>\n-\n-#ifdef __STL_USE_NAMESPACES\n-\n-using __STD::bit_vector;\n-\n-#endif /* __STL_USE_NAMESPACES */\n-\n-#endif /* __SGI_STL_BVECTOR_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:\n-\n-"}, {"sha": "ae3cf2672bc484d699dbf7b182f2dbde0f4d5489", "filename": "libstdc++-v3/ext/hash_map", "status": "removed", "additions": 0, "deletions": 524, "changes": 524, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Fhash_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Fhash_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fhash_map?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,524 +0,0 @@\n-/*\n- * Copyright (c) 1996\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- */\n-\n-/* NOTE: This is an internal header file, included by other STL headers.\n- *   You should not attempt to use it directly.\n- */\n-\n-#ifndef __SGI_STL_INTERNAL_HASH_MAP_H\n-#define __SGI_STL_INTERNAL_HASH_MAP_H\n-\n-#include <ext/stl_hashtable.h>\n-\n-__STL_BEGIN_NAMESPACE\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#pragma set woff 1375\n-#endif\n-\n-// Forward declaration of equality operator; needed for friend declaration.\n-\n-template <class _Key, class _Tp,\n-          class _HashFcn  = hash<_Key>,\n-          class _EqualKey = equal_to<_Key>,\n-          class _Alloc =  allocator<_Tp> >\n-class hash_map;\n-\n-template <class _Key, class _Tp, class _HashFn, class _EqKey, class _Alloc>\n-inline bool operator==(const hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc>&,\n-                       const hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc>&);\n-\n-template <class _Key, class _Tp, class _HashFcn, class _EqualKey,\n-          class _Alloc>\n-class hash_map\n-{\n-private:\n-  typedef hashtable<pair<const _Key,_Tp>,_Key,_HashFcn,\n-                    _Select1st<pair<const _Key,_Tp> >,_EqualKey,_Alloc> _Ht;\n-  _Ht _M_ht;\n-\n-public:\n-  typedef typename _Ht::key_type key_type;\n-  typedef _Tp data_type;\n-  typedef _Tp mapped_type;\n-  typedef typename _Ht::value_type value_type;\n-  typedef typename _Ht::hasher hasher;\n-  typedef typename _Ht::key_equal key_equal;\n-  \n-  typedef typename _Ht::size_type size_type;\n-  typedef typename _Ht::difference_type difference_type;\n-  typedef typename _Ht::pointer pointer;\n-  typedef typename _Ht::const_pointer const_pointer;\n-  typedef typename _Ht::reference reference;\n-  typedef typename _Ht::const_reference const_reference;\n-\n-  typedef typename _Ht::iterator iterator;\n-  typedef typename _Ht::const_iterator const_iterator;\n-\n-  typedef typename _Ht::allocator_type allocator_type;\n-\n-  hasher hash_funct() const { return _M_ht.hash_funct(); }\n-  key_equal key_eq() const { return _M_ht.key_eq(); }\n-  allocator_type get_allocator() const { return _M_ht.get_allocator(); }\n-\n-public:\n-  hash_map() : _M_ht(100, hasher(), key_equal(), allocator_type()) {}\n-  explicit hash_map(size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}\n-  hash_map(size_type __n, const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type()) {}\n-  hash_map(size_type __n, const hasher& __hf, const key_equal& __eql,\n-           const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a) {}\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class _InputIterator>\n-  hash_map(_InputIterator __f, _InputIterator __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  template <class _InputIterator>\n-  hash_map(_InputIterator __f, _InputIterator __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  template <class _InputIterator>\n-  hash_map(_InputIterator __f, _InputIterator __l, size_type __n,\n-           const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  template <class _InputIterator>\n-  hash_map(_InputIterator __f, _InputIterator __l, size_type __n,\n-           const hasher& __hf, const key_equal& __eql,\n-           const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_unique(__f, __l); }\n-\n-#else\n-  hash_map(const value_type* __f, const value_type* __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_map(const value_type* __f, const value_type* __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_map(const value_type* __f, const value_type* __l, size_type __n,\n-           const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_map(const value_type* __f, const value_type* __l, size_type __n,\n-           const hasher& __hf, const key_equal& __eql,\n-           const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_unique(__f, __l); }\n-\n-  hash_map(const_iterator __f, const_iterator __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_map(const_iterator __f, const_iterator __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_map(const_iterator __f, const_iterator __l, size_type __n,\n-           const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_map(const_iterator __f, const_iterator __l, size_type __n,\n-           const hasher& __hf, const key_equal& __eql,\n-           const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_unique(__f, __l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-\n-public:\n-  size_type size() const { return _M_ht.size(); }\n-  size_type max_size() const { return _M_ht.max_size(); }\n-  bool empty() const { return _M_ht.empty(); }\n-  void swap(hash_map& __hs) { _M_ht.swap(__hs._M_ht); }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class _K1, class _T1, class _HF, class _EqK, class _Al>\n-  friend bool operator== (const hash_map<_K1, _T1, _HF, _EqK, _Al>&,\n-                          const hash_map<_K1, _T1, _HF, _EqK, _Al>&);\n-#else /* __STL_MEMBER_TEMPLATES */\n-  friend bool __STD_QUALIFIER\n-  operator== __STL_NULL_TMPL_ARGS (const hash_map&, const hash_map&);\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-#include <bits/concept_checks.h>\n-\n-  iterator begin() { return _M_ht.begin(); }\n-  iterator end() { return _M_ht.end(); }\n-  const_iterator begin() const { return _M_ht.begin(); }\n-  const_iterator end() const { return _M_ht.end(); }\n-\n-public:\n-  pair<iterator,bool> insert(const value_type& __obj)\n-    { return _M_ht.insert_unique(__obj); }\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class _InputIterator>\n-  void insert(_InputIterator __f, _InputIterator __l)\n-    { _M_ht.insert_unique(__f,__l); }\n-#else\n-  void insert(const value_type* __f, const value_type* __l) {\n-    _M_ht.insert_unique(__f,__l);\n-  }\n-  void insert(const_iterator __f, const_iterator __l)\n-    { _M_ht.insert_unique(__f, __l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-  pair<iterator,bool> insert_noresize(const value_type& __obj)\n-    { return _M_ht.insert_unique_noresize(__obj); }    \n-\n-  iterator find(const key_type& __key) { return _M_ht.find(__key); }\n-  const_iterator find(const key_type& __key) const \n-    { return _M_ht.find(__key); }\n-\n-  _Tp& operator[](const key_type& __key) {\n-    return _M_ht.find_or_insert(value_type(__key, _Tp())).second;\n-  }\n-\n-  size_type count(const key_type& __key) const { return _M_ht.count(__key); }\n-  \n-  pair<iterator, iterator> equal_range(const key_type& __key)\n-    { return _M_ht.equal_range(__key); }\n-  pair<const_iterator, const_iterator>\n-  equal_range(const key_type& __key) const\n-    { return _M_ht.equal_range(__key); }\n-\n-  size_type erase(const key_type& __key) {return _M_ht.erase(__key); }\n-  void erase(iterator __it) { _M_ht.erase(__it); }\n-  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }\n-  void clear() { _M_ht.clear(); }\n-\n-  void resize(size_type __hint) { _M_ht.resize(__hint); }\n-  size_type bucket_count() const { return _M_ht.bucket_count(); }\n-  size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }\n-  size_type elems_in_bucket(size_type __n) const\n-    { return _M_ht.elems_in_bucket(__n); }\n-};\n-\n-template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n-inline bool \n-operator==(const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n-           const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)\n-{\n-  return __hm1._M_ht == __hm2._M_ht;\n-}\n-\n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n-template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n-inline bool \n-operator!=(const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n-           const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2) {\n-  return !(__hm1 == __hm2);\n-}\n-\n-template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n-inline void \n-swap(hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n-     hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)\n-{\n-  __hm1.swap(__hm2);\n-}\n-\n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-// Forward declaration of equality operator; needed for friend declaration.\n-\n-template <class _Key, class _Tp,\n-          class _HashFcn  = hash<_Key>,\n-          class _EqualKey = equal_to<_Key>,\n-          class _Alloc =  allocator<_Tp> >\n-class hash_multimap;\n-\n-template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>\n-inline bool \n-operator==(const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm1,\n-           const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm2);\n-\n-template <class _Key, class _Tp, class _HashFcn, class _EqualKey, class _Alloc>\n-class hash_multimap\n-{\n-  // requirements:\n-  __STL_CLASS_REQUIRES(_Key, _Assignable);\n-  __STL_CLASS_REQUIRES(_Tp, _Assignable);\n-  __STL_CLASS_UNARY_FUNCTION_CHECK(_HashFcn, size_t, _Key);\n-  __STL_CLASS_BINARY_FUNCTION_CHECK(_EqualKey, bool, _Key, _Key);\n-\n-private:\n-  typedef hashtable<pair<const _Key, _Tp>, _Key, _HashFcn,\n-                    _Select1st<pair<const _Key, _Tp> >, _EqualKey, _Alloc> \n-          _Ht;\n-  _Ht _M_ht;\n-\n-public:\n-  typedef typename _Ht::key_type key_type;\n-  typedef _Tp data_type;\n-  typedef _Tp mapped_type;\n-  typedef typename _Ht::value_type value_type;\n-  typedef typename _Ht::hasher hasher;\n-  typedef typename _Ht::key_equal key_equal;\n-\n-  typedef typename _Ht::size_type size_type;\n-  typedef typename _Ht::difference_type difference_type;\n-  typedef typename _Ht::pointer pointer;\n-  typedef typename _Ht::const_pointer const_pointer;\n-  typedef typename _Ht::reference reference;\n-  typedef typename _Ht::const_reference const_reference;\n-\n-  typedef typename _Ht::iterator iterator;\n-  typedef typename _Ht::const_iterator const_iterator;\n-\n-  typedef typename _Ht::allocator_type allocator_type;\n-\n-  hasher hash_funct() const { return _M_ht.hash_funct(); }\n-  key_equal key_eq() const { return _M_ht.key_eq(); }\n-  allocator_type get_allocator() const { return _M_ht.get_allocator(); }\n-\n-public:\n-  hash_multimap() : _M_ht(100, hasher(), key_equal(), allocator_type()) {}\n-  explicit hash_multimap(size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}\n-  hash_multimap(size_type __n, const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type()) {}\n-  hash_multimap(size_type __n, const hasher& __hf, const key_equal& __eql,\n-                const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a) {}\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class _InputIterator>\n-  hash_multimap(_InputIterator __f, _InputIterator __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  template <class _InputIterator>\n-  hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  template <class _InputIterator>\n-  hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n,\n-                const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  template <class _InputIterator>\n-  hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n,\n-                const hasher& __hf, const key_equal& __eql,\n-                const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_equal(__f, __l); }\n-\n-#else\n-  hash_multimap(const value_type* __f, const value_type* __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multimap(const value_type* __f, const value_type* __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multimap(const value_type* __f, const value_type* __l, size_type __n,\n-                const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multimap(const value_type* __f, const value_type* __l, size_type __n,\n-                const hasher& __hf, const key_equal& __eql,\n-                const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_equal(__f, __l); }\n-\n-  hash_multimap(const_iterator __f, const_iterator __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multimap(const_iterator __f, const_iterator __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multimap(const_iterator __f, const_iterator __l, size_type __n,\n-                const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multimap(const_iterator __f, const_iterator __l, size_type __n,\n-                const hasher& __hf, const key_equal& __eql,\n-                const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_equal(__f, __l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-\n-public:\n-  size_type size() const { return _M_ht.size(); }\n-  size_type max_size() const { return _M_ht.max_size(); }\n-  bool empty() const { return _M_ht.empty(); }\n-  void swap(hash_multimap& __hs) { _M_ht.swap(__hs._M_ht); }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class _K1, class _T1, class _HF, class _EqK, class _Al>\n-  friend bool operator== (const hash_multimap<_K1, _T1, _HF, _EqK, _Al>&,\n-                          const hash_multimap<_K1, _T1, _HF, _EqK, _Al>&);\n-#else /* __STL_MEMBER_TEMPLATES */\n-  friend bool __STD_QUALIFIER\n-  operator== __STL_NULL_TMPL_ARGS (const hash_multimap&,const hash_multimap&);\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  iterator begin() { return _M_ht.begin(); }\n-  iterator end() { return _M_ht.end(); }\n-  const_iterator begin() const { return _M_ht.begin(); }\n-  const_iterator end() const { return _M_ht.end(); }\n-\n-public:\n-  iterator insert(const value_type& __obj) \n-    { return _M_ht.insert_equal(__obj); }\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class _InputIterator>\n-  void insert(_InputIterator __f, _InputIterator __l) \n-    { _M_ht.insert_equal(__f,__l); }\n-#else\n-  void insert(const value_type* __f, const value_type* __l) {\n-    _M_ht.insert_equal(__f,__l);\n-  }\n-  void insert(const_iterator __f, const_iterator __l) \n-    { _M_ht.insert_equal(__f, __l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-  iterator insert_noresize(const value_type& __obj)\n-    { return _M_ht.insert_equal_noresize(__obj); }    \n-\n-  iterator find(const key_type& __key) { return _M_ht.find(__key); }\n-  const_iterator find(const key_type& __key) const \n-    { return _M_ht.find(__key); }\n-\n-  size_type count(const key_type& __key) const { return _M_ht.count(__key); }\n-  \n-  pair<iterator, iterator> equal_range(const key_type& __key)\n-    { return _M_ht.equal_range(__key); }\n-  pair<const_iterator, const_iterator>\n-  equal_range(const key_type& __key) const\n-    { return _M_ht.equal_range(__key); }\n-\n-  size_type erase(const key_type& __key) {return _M_ht.erase(__key); }\n-  void erase(iterator __it) { _M_ht.erase(__it); }\n-  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }\n-  void clear() { _M_ht.clear(); }\n-\n-public:\n-  void resize(size_type __hint) { _M_ht.resize(__hint); }\n-  size_type bucket_count() const { return _M_ht.bucket_count(); }\n-  size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }\n-  size_type elems_in_bucket(size_type __n) const\n-    { return _M_ht.elems_in_bucket(__n); }\n-};\n-\n-template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>\n-inline bool \n-operator==(const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm1,\n-           const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm2)\n-{\n-  return __hm1._M_ht == __hm2._M_ht;\n-}\n-\n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n-template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>\n-inline bool \n-operator!=(const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm1,\n-           const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm2) {\n-  return !(__hm1 == __hm2);\n-}\n-\n-template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n-inline void \n-swap(hash_multimap<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n-     hash_multimap<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)\n-{\n-  __hm1.swap(__hm2);\n-}\n-\n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-// Specialization of insert_iterator so that it will work for hash_map\n-// and hash_multimap.\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class _Key, class _Tp, class _HashFn,  class _EqKey, class _Alloc>\n-class insert_iterator<hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc> > {\n-protected:\n-  typedef hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc> _Container;\n-  _Container* container;\n-public:\n-  typedef _Container          container_type;\n-  typedef output_iterator_tag iterator_category;\n-  typedef void                value_type;\n-  typedef void                difference_type;\n-  typedef void                pointer;\n-  typedef void                reference;\n-\n-  insert_iterator(_Container& __x) : container(&__x) {}\n-  insert_iterator(_Container& __x, typename _Container::iterator)\n-    : container(&__x) {}\n-  insert_iterator<_Container>&\n-  operator=(const typename _Container::value_type& __value) { \n-    container->insert(__value);\n-    return *this;\n-  }\n-  insert_iterator<_Container>& operator*() { return *this; }\n-  insert_iterator<_Container>& operator++() { return *this; }\n-  insert_iterator<_Container>& operator++(int) { return *this; }\n-};\n-\n-template <class _Key, class _Tp, class _HashFn,  class _EqKey, class _Alloc>\n-class insert_iterator<hash_multimap<_Key, _Tp, _HashFn, _EqKey, _Alloc> > {\n-protected:\n-  typedef hash_multimap<_Key, _Tp, _HashFn, _EqKey, _Alloc> _Container;\n-  _Container* container;\n-  typename _Container::iterator iter;\n-public:\n-  typedef _Container          container_type;\n-  typedef output_iterator_tag iterator_category;\n-  typedef void                value_type;\n-  typedef void                difference_type;\n-  typedef void                pointer;\n-  typedef void                reference;\n-\n-  insert_iterator(_Container& __x) : container(&__x) {}\n-  insert_iterator(_Container& __x, typename _Container::iterator)\n-    : container(&__x) {}\n-  insert_iterator<_Container>&\n-  operator=(const typename _Container::value_type& __value) { \n-    container->insert(__value);\n-    return *this;\n-  }\n-  insert_iterator<_Container>& operator*() { return *this; }\n-  insert_iterator<_Container>& operator++() { return *this; }\n-  insert_iterator<_Container>& operator++(int) { return *this; }\n-};\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#pragma reset woff 1375\n-#endif\n-\n-__STL_END_NAMESPACE\n-\n-#endif /* __SGI_STL_INTERNAL_HASH_MAP_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "24869cd030c8aacb397122b13fa40ec36ca110c1", "filename": "libstdc++-v3/ext/hash_set", "status": "removed", "additions": 0, "deletions": 516, "changes": 516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Fhash_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Fhash_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fhash_set?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,516 +0,0 @@\n-/*\n- * Copyright (c) 1996\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- */\n-\n-/* NOTE: This is an internal header file, included by other STL headers.\n- *   You should not attempt to use it directly.\n- */\n-\n-#ifndef __SGI_STL_INTERNAL_HASH_SET_H\n-#define __SGI_STL_INTERNAL_HASH_SET_H\n-\n-#include <ext/stl_hashtable.h>\n-\n-#include <bits/concept_checks.h>\n-\n-__STL_BEGIN_NAMESPACE\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#pragma set woff 1375\n-#endif\n-\n-// Forward declaration of equality operator; needed for friend declaration.\n-\n-template <class _Value,\n-          class _HashFcn  = hash<_Value>,\n-          class _EqualKey = equal_to<_Value>,\n-          class _Alloc =  allocator<_Value> >\n-class hash_set;\n-\n-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n-inline bool \n-operator==(const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs1,\n-           const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs2);\n-\n-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n-class hash_set\n-{\n-  // requirements:\n-\n-  __STL_CLASS_REQUIRES(_Value, _Assignable);\n-  __STL_CLASS_UNARY_FUNCTION_CHECK(_HashFcn, size_t, _Value);\n-  __STL_CLASS_BINARY_FUNCTION_CHECK(_EqualKey, bool, _Value, _Value);\n-\n-private:\n-  typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>, \n-                    _EqualKey, _Alloc> _Ht;\n-  _Ht _M_ht;\n-\n-public:\n-  typedef typename _Ht::key_type key_type;\n-  typedef typename _Ht::value_type value_type;\n-  typedef typename _Ht::hasher hasher;\n-  typedef typename _Ht::key_equal key_equal;\n-\n-  typedef typename _Ht::size_type size_type;\n-  typedef typename _Ht::difference_type difference_type;\n-  typedef typename _Ht::const_pointer pointer;\n-  typedef typename _Ht::const_pointer const_pointer;\n-  typedef typename _Ht::const_reference reference;\n-  typedef typename _Ht::const_reference const_reference;\n-\n-  typedef typename _Ht::const_iterator iterator;\n-  typedef typename _Ht::const_iterator const_iterator;\n-\n-  typedef typename _Ht::allocator_type allocator_type;\n-\n-  hasher hash_funct() const { return _M_ht.hash_funct(); }\n-  key_equal key_eq() const { return _M_ht.key_eq(); }\n-  allocator_type get_allocator() const { return _M_ht.get_allocator(); }\n-\n-public:\n-  hash_set()\n-    : _M_ht(100, hasher(), key_equal(), allocator_type()) {}\n-  explicit hash_set(size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}\n-  hash_set(size_type __n, const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type()) {}\n-  hash_set(size_type __n, const hasher& __hf, const key_equal& __eql,\n-           const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a) {}\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class _InputIterator>\n-  hash_set(_InputIterator __f, _InputIterator __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  template <class _InputIterator>\n-  hash_set(_InputIterator __f, _InputIterator __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  template <class _InputIterator>\n-  hash_set(_InputIterator __f, _InputIterator __l, size_type __n,\n-           const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  template <class _InputIterator>\n-  hash_set(_InputIterator __f, _InputIterator __l, size_type __n,\n-           const hasher& __hf, const key_equal& __eql,\n-           const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_unique(__f, __l); }\n-#else\n-\n-  hash_set(const value_type* __f, const value_type* __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_set(const value_type* __f, const value_type* __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_set(const value_type* __f, const value_type* __l, size_type __n,\n-           const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_set(const value_type* __f, const value_type* __l, size_type __n,\n-           const hasher& __hf, const key_equal& __eql,\n-           const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_unique(__f, __l); }\n-\n-  hash_set(const_iterator __f, const_iterator __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_set(const_iterator __f, const_iterator __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_set(const_iterator __f, const_iterator __l, size_type __n,\n-           const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  hash_set(const_iterator __f, const_iterator __l, size_type __n,\n-           const hasher& __hf, const key_equal& __eql,\n-           const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_unique(__f, __l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-\n-public:\n-  size_type size() const { return _M_ht.size(); }\n-  size_type max_size() const { return _M_ht.max_size(); }\n-  bool empty() const { return _M_ht.empty(); }\n-  void swap(hash_set& __hs) { _M_ht.swap(__hs._M_ht); }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class _Val, class _HF, class _EqK, class _Al>  \n-  friend bool operator== (const hash_set<_Val, _HF, _EqK, _Al>&,\n-                          const hash_set<_Val, _HF, _EqK, _Al>&);\n-#else /* __STL_MEMBER_TEMPLATES */\n-  friend bool __STD_QUALIFIER\n-  operator== __STL_NULL_TMPL_ARGS (const hash_set&, const hash_set&);\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  iterator begin() const { return _M_ht.begin(); }\n-  iterator end() const { return _M_ht.end(); }\n-\n-public:\n-  pair<iterator, bool> insert(const value_type& __obj)\n-    {\n-      pair<typename _Ht::iterator, bool> __p = _M_ht.insert_unique(__obj);\n-      return pair<iterator,bool>(__p.first, __p.second);\n-    }\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class _InputIterator>\n-  void insert(_InputIterator __f, _InputIterator __l) \n-    { _M_ht.insert_unique(__f,__l); }\n-#else\n-  void insert(const value_type* __f, const value_type* __l) {\n-    _M_ht.insert_unique(__f,__l);\n-  }\n-  void insert(const_iterator __f, const_iterator __l) \n-    {_M_ht.insert_unique(__f, __l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-  pair<iterator, bool> insert_noresize(const value_type& __obj)\n-  {\n-    pair<typename _Ht::iterator, bool> __p = \n-      _M_ht.insert_unique_noresize(__obj);\n-    return pair<iterator, bool>(__p.first, __p.second);\n-  }\n-\n-  iterator find(const key_type& __key) const { return _M_ht.find(__key); }\n-\n-  size_type count(const key_type& __key) const { return _M_ht.count(__key); }\n-  \n-  pair<iterator, iterator> equal_range(const key_type& __key) const\n-    { return _M_ht.equal_range(__key); }\n-\n-  size_type erase(const key_type& __key) {return _M_ht.erase(__key); }\n-  void erase(iterator __it) { _M_ht.erase(__it); }\n-  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }\n-  void clear() { _M_ht.clear(); }\n-\n-public:\n-  void resize(size_type __hint) { _M_ht.resize(__hint); }\n-  size_type bucket_count() const { return _M_ht.bucket_count(); }\n-  size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }\n-  size_type elems_in_bucket(size_type __n) const\n-    { return _M_ht.elems_in_bucket(__n); }\n-};\n-\n-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n-inline bool \n-operator==(const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs1,\n-           const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs2)\n-{\n-  return __hs1._M_ht == __hs2._M_ht;\n-}\n-\n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n-inline bool \n-operator!=(const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs1,\n-           const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs2) {\n-  return !(__hs1 == __hs2);\n-}\n-\n-template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n-inline void \n-swap(hash_set<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n-     hash_set<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2)\n-{\n-  __hs1.swap(__hs2);\n-}\n-\n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-\n-template <class _Value,\n-          class _HashFcn  = hash<_Value>,\n-          class _EqualKey = equal_to<_Value>,\n-          class _Alloc =  allocator<_Value> >\n-class hash_multiset;\n-\n-template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n-inline bool \n-operator==(const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n-           const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2);\n-\n-\n-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n-class hash_multiset\n-{\n-  // requirements:\n-\n-  __STL_CLASS_REQUIRES(_Value, _Assignable);\n-  __STL_CLASS_UNARY_FUNCTION_CHECK(_HashFcn, size_t, _Value);\n-  __STL_CLASS_BINARY_FUNCTION_CHECK(_EqualKey, bool, _Value, _Value);\n-\n-private:\n-  typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>, \n-                    _EqualKey, _Alloc> _Ht;\n-  _Ht _M_ht;\n-\n-public:\n-  typedef typename _Ht::key_type key_type;\n-  typedef typename _Ht::value_type value_type;\n-  typedef typename _Ht::hasher hasher;\n-  typedef typename _Ht::key_equal key_equal;\n-\n-  typedef typename _Ht::size_type size_type;\n-  typedef typename _Ht::difference_type difference_type;\n-  typedef typename _Ht::const_pointer pointer;\n-  typedef typename _Ht::const_pointer const_pointer;\n-  typedef typename _Ht::const_reference reference;\n-  typedef typename _Ht::const_reference const_reference;\n-\n-  typedef typename _Ht::const_iterator iterator;\n-  typedef typename _Ht::const_iterator const_iterator;\n-\n-  typedef typename _Ht::allocator_type allocator_type;\n-\n-  hasher hash_funct() const { return _M_ht.hash_funct(); }\n-  key_equal key_eq() const { return _M_ht.key_eq(); }\n-  allocator_type get_allocator() const { return _M_ht.get_allocator(); }\n-\n-public:\n-  hash_multiset()\n-    : _M_ht(100, hasher(), key_equal(), allocator_type()) {}\n-  explicit hash_multiset(size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}\n-  hash_multiset(size_type __n, const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type()) {}\n-  hash_multiset(size_type __n, const hasher& __hf, const key_equal& __eql,\n-                const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a) {}\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class _InputIterator>\n-  hash_multiset(_InputIterator __f, _InputIterator __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  template <class _InputIterator>\n-  hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  template <class _InputIterator>\n-  hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n,\n-                const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  template <class _InputIterator>\n-  hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n,\n-                const hasher& __hf, const key_equal& __eql,\n-                const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_equal(__f, __l); }\n-#else\n-\n-  hash_multiset(const value_type* __f, const value_type* __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multiset(const value_type* __f, const value_type* __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multiset(const value_type* __f, const value_type* __l, size_type __n,\n-                const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multiset(const value_type* __f, const value_type* __l, size_type __n,\n-                const hasher& __hf, const key_equal& __eql,\n-                const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_equal(__f, __l); }\n-\n-  hash_multiset(const_iterator __f, const_iterator __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multiset(const_iterator __f, const_iterator __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multiset(const_iterator __f, const_iterator __l, size_type __n,\n-                const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  hash_multiset(const_iterator __f, const_iterator __l, size_type __n,\n-                const hasher& __hf, const key_equal& __eql,\n-                const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_equal(__f, __l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-\n-public:\n-  size_type size() const { return _M_ht.size(); }\n-  size_type max_size() const { return _M_ht.max_size(); }\n-  bool empty() const { return _M_ht.empty(); }\n-  void swap(hash_multiset& hs) { _M_ht.swap(hs._M_ht); }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class _Val, class _HF, class _EqK, class _Al>  \n-  friend bool operator== (const hash_multiset<_Val, _HF, _EqK, _Al>&,\n-                          const hash_multiset<_Val, _HF, _EqK, _Al>&);\n-#else /* __STL_MEMBER_TEMPLATES */\n-  friend bool __STD_QUALIFIER\n-  operator== __STL_NULL_TMPL_ARGS (const hash_multiset&,const hash_multiset&);\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  iterator begin() const { return _M_ht.begin(); }\n-  iterator end() const { return _M_ht.end(); }\n-\n-public:\n-  iterator insert(const value_type& __obj)\n-    { return _M_ht.insert_equal(__obj); }\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class _InputIterator>\n-  void insert(_InputIterator __f, _InputIterator __l) \n-    { _M_ht.insert_equal(__f,__l); }\n-#else\n-  void insert(const value_type* __f, const value_type* __l) {\n-    _M_ht.insert_equal(__f,__l);\n-  }\n-  void insert(const_iterator __f, const_iterator __l) \n-    { _M_ht.insert_equal(__f, __l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-  iterator insert_noresize(const value_type& __obj)\n-    { return _M_ht.insert_equal_noresize(__obj); }    \n-\n-  iterator find(const key_type& __key) const { return _M_ht.find(__key); }\n-\n-  size_type count(const key_type& __key) const { return _M_ht.count(__key); }\n-  \n-  pair<iterator, iterator> equal_range(const key_type& __key) const\n-    { return _M_ht.equal_range(__key); }\n-\n-  size_type erase(const key_type& __key) {return _M_ht.erase(__key); }\n-  void erase(iterator __it) { _M_ht.erase(__it); }\n-  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }\n-  void clear() { _M_ht.clear(); }\n-\n-public:\n-  void resize(size_type __hint) { _M_ht.resize(__hint); }\n-  size_type bucket_count() const { return _M_ht.bucket_count(); }\n-  size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }\n-  size_type elems_in_bucket(size_type __n) const\n-    { return _M_ht.elems_in_bucket(__n); }\n-};\n-\n-template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n-inline bool \n-operator==(const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n-           const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2)\n-{\n-  return __hs1._M_ht == __hs2._M_ht;\n-}\n-\n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n-template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n-inline bool \n-operator!=(const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n-           const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2) {\n-  return !(__hs1 == __hs2);\n-}\n-\n-template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n-inline void \n-swap(hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n-     hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2) {\n-  __hs1.swap(__hs2);\n-}\n-\n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-// Specialization of insert_iterator so that it will work for hash_set\n-// and hash_multiset.\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n-class insert_iterator<hash_set<_Value, _HashFcn, _EqualKey, _Alloc> > {\n-protected:\n-  typedef hash_set<_Value, _HashFcn, _EqualKey, _Alloc> _Container;\n-  _Container* container;\n-public:\n-  typedef _Container          container_type;\n-  typedef output_iterator_tag iterator_category;\n-  typedef void                value_type;\n-  typedef void                difference_type;\n-  typedef void                pointer;\n-  typedef void                reference;\n-\n-  insert_iterator(_Container& __x) : container(&__x) {}\n-  insert_iterator(_Container& __x, typename _Container::iterator)\n-    : container(&__x) {}\n-  insert_iterator<_Container>&\n-  operator=(const typename _Container::value_type& __value) { \n-    container->insert(__value);\n-    return *this;\n-  }\n-  insert_iterator<_Container>& operator*() { return *this; }\n-  insert_iterator<_Container>& operator++() { return *this; }\n-  insert_iterator<_Container>& operator++(int) { return *this; }\n-};\n-\n-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n-class insert_iterator<hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc> > {\n-protected:\n-  typedef hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc> _Container;\n-  _Container* container;\n-  typename _Container::iterator iter;\n-public:\n-  typedef _Container          container_type;\n-  typedef output_iterator_tag iterator_category;\n-  typedef void                value_type;\n-  typedef void                difference_type;\n-  typedef void                pointer;\n-  typedef void                reference;\n-\n-  insert_iterator(_Container& __x) : container(&__x) {}\n-  insert_iterator(_Container& __x, typename _Container::iterator)\n-    : container(&__x) {}\n-  insert_iterator<_Container>&\n-  operator=(const typename _Container::value_type& __value) { \n-    container->insert(__value);\n-    return *this;\n-  }\n-  insert_iterator<_Container>& operator*() { return *this; }\n-  insert_iterator<_Container>& operator++() { return *this; }\n-  insert_iterator<_Container>& operator++(int) { return *this; }\n-};\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#pragma reset woff 1375\n-#endif\n-\n-__STL_END_NAMESPACE\n-\n-#endif /* __SGI_STL_INTERNAL_HASH_SET_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "3779defea2be4c49ed9d265be1577c5c2d16d789", "filename": "libstdc++-v3/ext/rope", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Frope", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Frope", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Frope?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,32 +0,0 @@\n-/*\n- * Copyright (c) 1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef __SGI_STL_ROPE\n-#define __SGI_STL_ROPE\n-\n-#include <bits/stl_algobase.h>\n-#include <bits/stl_tempbuf.h>\n-#include <bits/stl_algo.h>\n-#include <bits/stl_function.h>\n-#include <bits/stl_numeric.h>\n-#include <bits/stl_alloc.h>\n-#include <bits/stl_construct.h>\n-#include <bits/stl_uninitialized.h>\n-#include <ext/stl_hash_fun.h>\n-#include <ext/stl_rope.h>\n-\n-#endif /* __SGI_STL_ROPE */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "cc4d7bc679e445c99c01f42dbb05190c4f4ef0f8", "filename": "libstdc++-v3/ext/ropeimpl.h", "status": "removed", "additions": 0, "deletions": 1587, "changes": 1587, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Fropeimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Fropeimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fropeimpl.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,1587 +0,0 @@\n-/*\n- * Copyright (c) 1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-/* NOTE: This is an internal header file, included by other STL headers.\n- *   You should not attempt to use it directly.\n- */\n-\n-# include <bits/std_cstdio.h>     \n-\n-#ifdef __STL_USE_NEW_IOSTREAMS \n-# include <iostream>\n-#else /* __STL_USE_NEW_IOSTREAMS */\n-# include <bits/std_iostream.h>\n-#endif /* __STL_USE_NEW_IOSTREAMS */\n-\n-#ifdef __STL_USE_EXCEPTIONS\n-# include <bits/std_stdexcept.h>\n-#endif\n-\n-__STL_BEGIN_NAMESPACE\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#endif\n-\n-// Set buf_start, buf_end, and buf_ptr appropriately, filling tmp_buf\n-// if necessary.  Assumes _M_path_end[leaf_index] and leaf_pos are correct.\n-// Results in a valid buf_ptr if the iterator can be legitimately\n-// dereferenced.\n-template <class _CharT, class _Alloc>\n-void _Rope_iterator_base<_CharT,_Alloc>::_S_setbuf( \n-  _Rope_iterator_base<_CharT,_Alloc>& __x)\n-{\n-    const _RopeRep* __leaf = __x._M_path_end[__x._M_leaf_index];\n-    size_t __leaf_pos = __x._M_leaf_pos;\n-    size_t __pos = __x._M_current_pos;\n-\n-    switch(__leaf->_M_tag) {\n-\tcase _RopeRep::_S_leaf:\n-\t    __x._M_buf_start = \n-\t      ((_Rope_RopeLeaf<_CharT,_Alloc>*)__leaf)->_M_data;\n-\t    __x._M_buf_ptr = __x._M_buf_start + (__pos - __leaf_pos);\n-\t    __x._M_buf_end = __x._M_buf_start + __leaf->_M_size;\n-\t    break;\n-\tcase _RopeRep::_S_function:\n-\tcase _RopeRep::_S_substringfn:\n-\t    {\n-\t\tsize_t __len = _S_iterator_buf_len;\n-\t\tsize_t __buf_start_pos = __leaf_pos;\n-\t\tsize_t __leaf_end = __leaf_pos + __leaf->_M_size;\n-\t\tchar_producer<_CharT>* __fn =\n-\t\t\t((_Rope_RopeFunction<_CharT,_Alloc>*)__leaf)->_M_fn;\n-\n-\t\tif (__buf_start_pos + __len <= __pos) {\n-\t\t    __buf_start_pos = __pos - __len/4;\n-\t\t    if (__buf_start_pos + __len > __leaf_end) {\n-\t\t\t__buf_start_pos = __leaf_end - __len;\n-\t\t    }\n-\t\t}\n-\t\tif (__buf_start_pos + __len > __leaf_end) {\n-\t\t    __len = __leaf_end - __buf_start_pos;\n-\t\t}\n-\t\t(*__fn)(__buf_start_pos - __leaf_pos, __len, __x._M_tmp_buf);\n-\t\t__x._M_buf_ptr = __x._M_tmp_buf + (__pos - __buf_start_pos);\n-\t\t__x._M_buf_start = __x._M_tmp_buf;\n-\t\t__x._M_buf_end = __x._M_tmp_buf + __len;\n-\t    }\n-\t    break;\n-\tdefault:\n-\t    __stl_assert(0);\n-    }\n-}\n-\n-// Set path and buffer inside a rope iterator.  We assume that \n-// pos and root are already set.\n-template <class _CharT, class _Alloc>\n-void _Rope_iterator_base<_CharT,_Alloc>::_S_setcache\n-(_Rope_iterator_base<_CharT,_Alloc>& __x)\n-{\n-    const _RopeRep* __path[_RopeRep::_S_max_rope_depth+1];\n-    const _RopeRep* __curr_rope;\n-    int __curr_depth = -1;  /* index into path    */\n-    size_t __curr_start_pos = 0;\n-    size_t __pos = __x._M_current_pos;\n-    unsigned char __dirns = 0; // Bit vector marking right turns in the path\n-\n-    __stl_assert(__pos <= __x._M_root->_M_size);\n-    if (__pos >= __x._M_root->_M_size) {\n-\t__x._M_buf_ptr = 0;\n-\treturn;\n-    }\n-    __curr_rope = __x._M_root;\n-    if (0 != __curr_rope->_M_c_string) {\n-\t/* Treat the root as a leaf. */\n-\t__x._M_buf_start = __curr_rope->_M_c_string;\n-\t__x._M_buf_end = __curr_rope->_M_c_string + __curr_rope->_M_size;\n-\t__x._M_buf_ptr = __curr_rope->_M_c_string + __pos;\n-\t__x._M_path_end[0] = __curr_rope;\n-\t__x._M_leaf_index = 0;\n-\t__x._M_leaf_pos = 0;\n-\treturn;\n-    }\n-    for(;;) {\n-\t++__curr_depth;\n-\t__stl_assert(__curr_depth <= _RopeRep::_S_max_rope_depth);\n-\t__path[__curr_depth] = __curr_rope;\n-\tswitch(__curr_rope->_M_tag) {\n-\t  case _RopeRep::_S_leaf:\n-\t  case _RopeRep::_S_function:\n-\t  case _RopeRep::_S_substringfn:\n-\t    __x._M_leaf_pos = __curr_start_pos;\n-\t    goto done;\n-\t  case _RopeRep::_S_concat:\n-\t    {\n-\t\t_Rope_RopeConcatenation<_CharT,_Alloc>* __c =\n-\t\t\t(_Rope_RopeConcatenation<_CharT,_Alloc>*)__curr_rope;\n-\t\t_RopeRep* __left = __c->_M_left;\n-\t\tsize_t __left_len = __left->_M_size;\n-\t\t\n-\t\t__dirns <<= 1;\n-\t\tif (__pos >= __curr_start_pos + __left_len) {\n-\t\t    __dirns |= 1;\n-\t\t    __curr_rope = __c->_M_right;\n-\t\t    __curr_start_pos += __left_len;\n-\t\t} else {\n-\t\t    __curr_rope = __left;\n-\t\t}\n-\t    }\n-\t    break;\n-\t}\n-    }\n-  done:\n-    // Copy last section of path into _M_path_end.\n-      {\n-\tint __i = -1;\n-\tint __j = __curr_depth + 1 - _S_path_cache_len;\n-\n-\tif (__j < 0) __j = 0;\n-\twhile (__j <= __curr_depth) {\n-\t    __x._M_path_end[++__i] = __path[__j++];\n-\t}\n-\t__x._M_leaf_index = __i;\n-      }\n-      __x._M_path_directions = __dirns;\n-      _S_setbuf(__x);\n-}\n-\n-// Specialized version of the above.  Assumes that\n-// the path cache is valid for the previous position.\n-template <class _CharT, class _Alloc>\n-void _Rope_iterator_base<_CharT,_Alloc>::_S_setcache_for_incr\n-(_Rope_iterator_base<_CharT,_Alloc>& __x)\n-{\n-    int __current_index = __x._M_leaf_index;\n-    const _RopeRep* __current_node = __x._M_path_end[__current_index];\n-    size_t __len = __current_node->_M_size;\n-    size_t __node_start_pos = __x._M_leaf_pos;\n-    unsigned char __dirns = __x._M_path_directions;\n-    _Rope_RopeConcatenation<_CharT,_Alloc>* __c;\n-\n-    __stl_assert(__x._M_current_pos <= __x._M_root->_M_size);\n-    if (__x._M_current_pos - __node_start_pos < __len) {\n-\t/* More stuff in this leaf, we just didn't cache it. */\n-\t_S_setbuf(__x);\n-\treturn;\n-    }\n-    __stl_assert(__node_start_pos + __len == __x._M_current_pos);\n-    //  node_start_pos is starting position of last_node.\n-    while (--__current_index >= 0) {\n-\tif (!(__dirns & 1) /* Path turned left */) \n-\t  break;\n-\t__current_node = __x._M_path_end[__current_index];\n-\t__c = (_Rope_RopeConcatenation<_CharT,_Alloc>*)__current_node;\n-\t// Otherwise we were in the right child.  Thus we should pop\n-\t// the concatenation node.\n-\t__node_start_pos -= __c->_M_left->_M_size;\n-\t__dirns >>= 1;\n-    }\n-    if (__current_index < 0) {\n-\t// We underflowed the cache. Punt.\n-\t_S_setcache(__x);\n-\treturn;\n-    }\n-    __current_node = __x._M_path_end[__current_index];\n-    __c = (_Rope_RopeConcatenation<_CharT,_Alloc>*)__current_node;\n-    // current_node is a concatenation node.  We are positioned on the first\n-    // character in its right child.\n-    // node_start_pos is starting position of current_node.\n-    __node_start_pos += __c->_M_left->_M_size;\n-    __current_node = __c->_M_right;\n-    __x._M_path_end[++__current_index] = __current_node;\n-    __dirns |= 1;\n-    while (_RopeRep::_S_concat == __current_node->_M_tag) {\n-\t++__current_index;\n-\tif (_S_path_cache_len == __current_index) {\n-\t    int __i;\n-\t    for (__i = 0; __i < _S_path_cache_len-1; __i++) {\n-\t\t__x._M_path_end[__i] = __x._M_path_end[__i+1];\n-\t    }\n-\t    --__current_index;\n-\t}\n-\t__current_node =\n-\t    ((_Rope_RopeConcatenation<_CharT,_Alloc>*)__current_node)->_M_left;\n-\t__x._M_path_end[__current_index] = __current_node;\n-\t__dirns <<= 1;\n-\t// node_start_pos is unchanged.\n-    }\n-    __x._M_leaf_index = __current_index;\n-    __x._M_leaf_pos = __node_start_pos;\n-    __x._M_path_directions = __dirns;\n-    _S_setbuf(__x);\n-}\n-\n-template <class _CharT, class _Alloc>\n-void _Rope_iterator_base<_CharT,_Alloc>::_M_incr(size_t __n) {\n-    _M_current_pos += __n;\n-    if (0 != _M_buf_ptr) {\n-        size_t __chars_left = _M_buf_end - _M_buf_ptr;\n-        if (__chars_left > __n) {\n-            _M_buf_ptr += __n;\n-        } else if (__chars_left == __n) {\n-            _M_buf_ptr += __n;\n-            _S_setcache_for_incr(*this);\n-        } else {\n-            _M_buf_ptr = 0;\n-        }\n-    }\n-}\n-\n-template <class _CharT, class _Alloc>\n-void _Rope_iterator_base<_CharT,_Alloc>::_M_decr(size_t __n) {\n-    if (0 != _M_buf_ptr) {\n-        size_t __chars_left = _M_buf_ptr - _M_buf_start;\n-        if (__chars_left >= __n) {\n-            _M_buf_ptr -= __n;\n-        } else {\n-            _M_buf_ptr = 0;\n-        }\n-    }\n-    _M_current_pos -= __n;\n-}\n-\n-template <class _CharT, class _Alloc>\n-void _Rope_iterator<_CharT,_Alloc>::_M_check() {\n-    if (_M_root_rope->_M_tree_ptr != _M_root) {\n-        // _Rope was modified.  Get things fixed up.\n-        _RopeRep::_S_unref(_M_root);\n-        _M_root = _M_root_rope->_M_tree_ptr;\n-        _RopeRep::_S_ref(_M_root);\n-        _M_buf_ptr = 0;\n-    }\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline \n-_Rope_const_iterator<_CharT, _Alloc>::_Rope_const_iterator(\n-  const _Rope_iterator<_CharT,_Alloc>& __x)\n-: _Rope_iterator_base<_CharT,_Alloc>(__x) \n-{ }\n-\n-template <class _CharT, class _Alloc>\n-inline _Rope_iterator<_CharT,_Alloc>::_Rope_iterator(\n-  rope<_CharT,_Alloc>& __r, size_t __pos)\n-: _Rope_iterator_base<_CharT,_Alloc>(__r._M_tree_ptr, __pos), \n-  _M_root_rope(&__r)\n-{\n-    _RopeRep::_S_ref(_M_root);\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline size_t \n-rope<_CharT,_Alloc>::_S_char_ptr_len(const _CharT* __s)\n-{\n-    const _CharT* __p = __s;\n-\n-    while (!_S_is0(*__p)) { ++__p; }\n-    return (__p - __s);\n-}\n-\n-\n-#ifndef __GC\n-\n-template <class _CharT, class _Alloc>\n-inline void _Rope_RopeRep<_CharT,_Alloc>::_M_free_c_string()\n-{\n-    _CharT* __cstr = _M_c_string;\n-    if (0 != __cstr) {\n-\tsize_t __size = _M_size + 1;\n-\tdestroy(__cstr, __cstr + __size);\n-\t_Data_deallocate(__cstr, __size);\n-    }\n-}\n-\n-\n-template <class _CharT, class _Alloc>\n-#ifdef __STL_USE_STD_ALLOCATORS\n-  inline void _Rope_RopeRep<_CharT,_Alloc>::_S_free_string(_CharT* __s,\n-\t\t\t\t\t\t\t   size_t __n,\n-\t\t\t\t\t\t           allocator_type __a)\n-#else\n-  inline void _Rope_RopeRep<_CharT,_Alloc>::_S_free_string(_CharT* __s,\n-\t\t\t\t\t\t\t   size_t __n)\n-#endif\n-{\n-    if (!_S_is_basic_char_type((_CharT*)0)) {\n-\tdestroy(__s, __s + __n);\n-    }\n-//  This has to be a static member, so this gets a bit messy\n-#   ifdef __STL_USE_STD_ALLOCATORS\n-        __a.deallocate(\n-\t    __s, _Rope_RopeLeaf<_CharT,_Alloc>::_S_rounded_up_size(__n));\n-#   else\n-\t_Data_deallocate(\n-\t    __s, _Rope_RopeLeaf<_CharT,_Alloc>::_S_rounded_up_size(__n));\n-#   endif\n-}\n-\n-\n-//  There are several reasons for not doing this with virtual destructors\n-//  and a class specific delete operator:\n-//  - A class specific delete operator can't easily get access to\n-//    allocator instances if we need them.\n-//  - Any virtual function would need a 4 or byte vtable pointer;\n-//    this only requires a one byte tag per object.\n-template <class _CharT, class _Alloc>\n-void _Rope_RopeRep<_CharT,_Alloc>::_M_free_tree()\n-{\n-    switch(_M_tag) {\n-\tcase _S_leaf:\n-\t    {\n-\t        _Rope_RopeLeaf<_CharT,_Alloc>* __l\n-\t\t\t= (_Rope_RopeLeaf<_CharT,_Alloc>*)this;\n-\t        __l->_Rope_RopeLeaf<_CharT,_Alloc>::~_Rope_RopeLeaf();\n-\t        _L_deallocate(__l, 1);\n-\t        break;\n-\t    }\n-\tcase _S_concat:\n-\t    {\n-\t        _Rope_RopeConcatenation<_CharT,_Alloc>* __c\n-\t\t    = (_Rope_RopeConcatenation<_CharT,_Alloc>*)this;\n-\t        __c->_Rope_RopeConcatenation<_CharT,_Alloc>::\n-\t\t       ~_Rope_RopeConcatenation();\n-\t        _C_deallocate(__c, 1);\n-\t        break;\n-\t    }\n-\tcase _S_function:\n-\t    {\n-\t        _Rope_RopeFunction<_CharT,_Alloc>* __f\n-\t\t    = (_Rope_RopeFunction<_CharT,_Alloc>*)this;\n-\t        __f->_Rope_RopeFunction<_CharT,_Alloc>::~_Rope_RopeFunction();\n-\t        _F_deallocate(__f, 1);\n-\t        break;\n-\t    }\n-\tcase _S_substringfn:\n-\t    {\n-\t        _Rope_RopeSubstring<_CharT,_Alloc>* __ss =\n-\t\t\t(_Rope_RopeSubstring<_CharT,_Alloc>*)this;\n-\t\t__ss->_Rope_RopeSubstring<_CharT,_Alloc>::\n-\t\t        ~_Rope_RopeSubstring();\n-\t\t_S_deallocate(__ss, 1);\n-\t\tbreak;\n-\t    }\n-    }\n-}\n-#else\n-\n-template <class _CharT, class _Alloc>\n-#ifdef __STL_USE_STD_ALLOCATORS\n-  inline void _Rope_RopeRep<_CharT,_Alloc>::_S_free_string\n-\t\t(const _CharT*, size_t, allocator_type)\n-#else\n-  inline void _Rope_RopeRep<_CharT,_Alloc>::_S_free_string\n-\t\t(const _CharT*, size_t)\n-#endif\n-{}\n-\n-#endif\n-\n-\n-// Concatenate a C string onto a leaf rope by copying the rope data.\n-// Used for short ropes.\n-template <class _CharT, class _Alloc>\n-rope<_CharT,_Alloc>::_RopeLeaf*\n-rope<_CharT,_Alloc>::_S_leaf_concat_char_iter\n-\t\t(_RopeLeaf* __r, const _CharT* __iter, size_t __len)\n-{\n-    size_t __old_len = __r->_M_size;\n-    _CharT* __new_data = (_CharT*)\n-\t_Data_allocate(_S_rounded_up_size(__old_len + __len));\n-    _RopeLeaf* __result;\n-    \n-    uninitialized_copy_n(__r->_M_data, __old_len, __new_data);\n-    uninitialized_copy_n(__iter, __len, __new_data + __old_len);\n-    _S_cond_store_eos(__new_data[__old_len + __len]);\n-    __STL_TRY {\n-\t__result = _S_new_RopeLeaf(__new_data, __old_len + __len,\n-\t\t\t\t   __r->get_allocator());\n-    }\n-    __STL_UNWIND(_RopeRep::__STL_FREE_STRING(__new_data, __old_len + __len,\n-\t\t\t\t\t     __r->get_allocator()));\n-    return __result;\n-}\n-\n-#ifndef __GC\n-// As above, but it's OK to clobber original if refcount is 1\n-template <class _CharT, class _Alloc>\n-rope<_CharT,_Alloc>::_RopeLeaf*\n-rope<_CharT,_Alloc>::_S_destr_leaf_concat_char_iter\n-\t\t(_RopeLeaf* __r, const _CharT* __iter, size_t __len)\n-{\n-    __stl_assert(__r->_M_ref_count >= 1);\n-    if (__r->_M_ref_count > 1)\n-      return _S_leaf_concat_char_iter(__r, __iter, __len);\n-    size_t __old_len = __r->_M_size;\n-    if (_S_allocated_capacity(__old_len) >= __old_len + __len) {\n-\t// The space has been partially initialized for the standard\n-\t// character types.  But that doesn't matter for those types.\n-\tuninitialized_copy_n(__iter, __len, __r->_M_data + __old_len);\n-\tif (_S_is_basic_char_type((_CharT*)0)) {\n-\t    _S_cond_store_eos(__r->_M_data[__old_len + __len]);\n-\t    __stl_assert(__r->_M_c_string == __r->_M_data);\n-\t} else if (__r->_M_c_string != __r->_M_data && 0 != __r->_M_c_string) {\n-\t    __r->_M_free_c_string();\n-\t    __r->_M_c_string = 0;\n-\t}\n-\t__r->_M_size = __old_len + __len;\n-\t__stl_assert(__r->_M_ref_count == 1);\n-\t__r->_M_ref_count = 2;\n-\treturn __r;\n-    } else {\n-\t_RopeLeaf* __result = _S_leaf_concat_char_iter(__r, __iter, __len);\n-\t__stl_assert(__result->_M_ref_count == 1);\n-\treturn __result;\n-    }\n-}\n-#endif\n-\n-// Assumes left and right are not 0.\n-// Does not increment (nor decrement on exception) child reference counts.\n-// Result has ref count 1.\n-template <class _CharT, class _Alloc>\n-rope<_CharT,_Alloc>::_RopeRep*\n-rope<_CharT,_Alloc>::_S_tree_concat (_RopeRep* __left, _RopeRep* __right)\n-{\n-    _RopeConcatenation* __result =\n-      _S_new_RopeConcatenation(__left, __right, __left->get_allocator());\n-    size_t __depth = __result->_M_depth;\n-    \n-#   ifdef __STL_USE_STD_ALLOCATORS\n-      __stl_assert(__left->get_allocator() == __right->get_allocator());\n-#   endif\n-    if (__depth > 20 && (__result->_M_size < 1000 ||\n-\t\t\t __depth > _RopeRep::_S_max_rope_depth)) {\n-        _RopeRep* __balanced;\n-      \n-\t__STL_TRY {\n-\t   __balanced = _S_balance(__result);\n-#          ifndef __GC\n-\t     if (__result != __balanced) {\n-\t\t__stl_assert(1 == __result->_M_ref_count\n-\t\t\t     && 1 == __balanced->_M_ref_count);\n-\t     }\n-#          endif\n-\t   __result->_M_unref_nonnil();\n-        }\n-\t__STL_UNWIND((_C_deallocate(__result,1)));\n-\t\t// In case of exception, we need to deallocate\n-\t\t// otherwise dangling result node.  But caller\n-\t\t// still owns its children.  Thus unref is\n-\t\t// inappropriate.\n-\treturn __balanced;\n-    } else {\n-\treturn __result;\n-    }\n-}\n-\n-template <class _CharT, class _Alloc>\n-rope<_CharT,_Alloc>::_RopeRep* rope<_CharT,_Alloc>::_S_concat_char_iter\n-\t\t(_RopeRep* __r, const _CharT*__s, size_t __slen)\n-{\n-    _RopeRep* __result;\n-    if (0 == __slen) {\n-\t_S_ref(__r);\n-\treturn __r;\n-    }\n-    if (0 == __r)\n-      return __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen,\n-\t\t\t\t\t      __r->get_allocator());\n-    if (_RopeRep::_S_leaf == __r->_M_tag && \n-          __r->_M_size + __slen <= _S_copy_max) {\n-\t__result = _S_leaf_concat_char_iter((_RopeLeaf*)__r, __s, __slen);\n-#       ifndef __GC\n-\t  __stl_assert(1 == __result->_M_ref_count);\n-#       endif\n-\treturn __result;\n-    }\n-    if (_RopeRep::_S_concat == __r->_M_tag\n-\t&& _RopeRep::_S_leaf == ((_RopeConcatenation*)__r)->_M_right->_M_tag) {\n-\t_RopeLeaf* __right = \n-\t  (_RopeLeaf* )(((_RopeConcatenation* )__r)->_M_right);\n-\tif (__right->_M_size + __slen <= _S_copy_max) {\n-\t  _RopeRep* __left = ((_RopeConcatenation*)__r)->_M_left;\n-\t  _RopeRep* __nright = \n-\t    _S_leaf_concat_char_iter((_RopeLeaf*)__right, __s, __slen);\n-\t  __left->_M_ref_nonnil();\n-\t  __STL_TRY {\n-\t    __result = _S_tree_concat(__left, __nright);\n-          }\n-\t  __STL_UNWIND(_S_unref(__left); _S_unref(__nright));\n-#         ifndef __GC\n-\t    __stl_assert(1 == __result->_M_ref_count);\n-#         endif\n-\t  return __result;\n-\t}\n-    }\n-    _RopeRep* __nright =\n-      __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen, __r->get_allocator());\n-    __STL_TRY {\n-      __r->_M_ref_nonnil();\n-      __result = _S_tree_concat(__r, __nright);\n-    }\n-    __STL_UNWIND(_S_unref(__r); _S_unref(__nright));\n-#   ifndef __GC\n-      __stl_assert(1 == __result->_M_ref_count);\n-#   endif\n-    return __result;\n-}\n-\n-#ifndef __GC\n-template <class _CharT, class _Alloc>\n-rope<_CharT,_Alloc>::_RopeRep* \n-rope<_CharT,_Alloc>::_S_destr_concat_char_iter(\n-  _RopeRep* __r, const _CharT* __s, size_t __slen)\n-{\n-    _RopeRep* __result;\n-    if (0 == __r)\n-      return __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen,\n-\t\t\t\t\t      __r->get_allocator());\n-    size_t __count = __r->_M_ref_count;\n-    size_t __orig_size = __r->_M_size;\n-    __stl_assert(__count >= 1);\n-    if (__count > 1) return _S_concat_char_iter(__r, __s, __slen);\n-    if (0 == __slen) {\n-\t__r->_M_ref_count = 2;      // One more than before\n-\treturn __r;\n-    }\n-    if (__orig_size + __slen <= _S_copy_max && \n-          _RopeRep::_S_leaf == __r->_M_tag) {\n-\t__result = _S_destr_leaf_concat_char_iter((_RopeLeaf*)__r, __s, __slen);\n-\treturn __result;\n-    }\n-    if (_RopeRep::_S_concat == __r->_M_tag) {\n-\t_RopeLeaf* __right = (_RopeLeaf*)(((_RopeConcatenation*)__r)->_M_right);\n-\tif (_RopeRep::_S_leaf == __right->_M_tag\n-\t    && __right->_M_size + __slen <= _S_copy_max) {\n-\t  _RopeRep* __new_right = \n-\t    _S_destr_leaf_concat_char_iter(__right, __s, __slen);\n-\t  if (__right == __new_right) {\n-\t      __stl_assert(__new_right->_M_ref_count == 2);\n-\t      __new_right->_M_ref_count = 1;\n-\t  } else {\n-\t      __stl_assert(__new_right->_M_ref_count >= 1);\n-\t      __right->_M_unref_nonnil();\n-\t  }\n-\t  __stl_assert(__r->_M_ref_count == 1);\n-\t  __r->_M_ref_count = 2;    // One more than before.\n-\t  ((_RopeConcatenation*)__r)->_M_right = __new_right;\n-\t  __r->_M_size = __orig_size + __slen;\n-\t  if (0 != __r->_M_c_string) {\n-\t      __r->_M_free_c_string();\n-\t      __r->_M_c_string = 0;\n-\t  }\n-\t  return __r;\n-\t}\n-    }\n-    _RopeRep* __right =\n-      __STL_ROPE_FROM_UNOWNED_CHAR_PTR(__s, __slen, __r->get_allocator());\n-    __r->_M_ref_nonnil();\n-    __STL_TRY {\n-      __result = _S_tree_concat(__r, __right);\n-    }\n-    __STL_UNWIND(_S_unref(__r); _S_unref(__right))\n-    __stl_assert(1 == __result->_M_ref_count);\n-    return __result;\n-}\n-#endif /* !__GC */\n-\n-template <class _CharT, class _Alloc>\n-rope<_CharT,_Alloc>::_RopeRep*\n-rope<_CharT,_Alloc>::_S_concat(_RopeRep* __left, _RopeRep* __right)\n-{\n-    if (0 == __left) {\n-\t_S_ref(__right);\n-\treturn __right;\n-    }\n-    if (0 == __right) {\n-\t__left->_M_ref_nonnil();\n-\treturn __left;\n-    }\n-    if (_RopeRep::_S_leaf == __right->_M_tag) {\n-\tif (_RopeRep::_S_leaf == __left->_M_tag) {\n-\t  if (__right->_M_size + __left->_M_size <= _S_copy_max) {\n-\t    return _S_leaf_concat_char_iter((_RopeLeaf*)__left,\n-\t\t\t\t\t ((_RopeLeaf*)__right)->_M_data,\n-\t\t\t\t\t __right->_M_size);\n-\t  }\n-\t} else if (_RopeRep::_S_concat == __left->_M_tag\n-\t\t   && _RopeRep::_S_leaf ==\n-\t\t      ((_RopeConcatenation*)__left)->_M_right->_M_tag) {\n-\t  _RopeLeaf* __leftright =\n-\t\t    (_RopeLeaf*)(((_RopeConcatenation*)__left)->_M_right); \n-\t  if (__leftright->_M_size + __right->_M_size <= _S_copy_max) {\n-\t    _RopeRep* __leftleft = ((_RopeConcatenation*)__left)->_M_left;\n-\t    _RopeRep* __rest = _S_leaf_concat_char_iter(__leftright,\n-\t\t\t\t\t   ((_RopeLeaf*)__right)->_M_data,\n-\t\t\t\t\t   __right->_M_size);\n-\t    __leftleft->_M_ref_nonnil();\n-\t    __STL_TRY {\n-\t      return(_S_tree_concat(__leftleft, __rest));\n-            }\n-\t    __STL_UNWIND(_S_unref(__leftleft); _S_unref(__rest))\n-\t  }\n-\t}\n-    }\n-    __left->_M_ref_nonnil();\n-    __right->_M_ref_nonnil();\n-    __STL_TRY {\n-      return(_S_tree_concat(__left, __right));\n-    }\n-    __STL_UNWIND(_S_unref(__left); _S_unref(__right));\n-}\n-\n-template <class _CharT, class _Alloc>\n-rope<_CharT,_Alloc>::_RopeRep*\n-rope<_CharT,_Alloc>::_S_substring(_RopeRep* __base, \n-                               size_t __start, size_t __endp1)\n-{\n-    if (0 == __base) return 0;\n-    size_t __len = __base->_M_size;\n-    size_t __adj_endp1;\n-    const size_t __lazy_threshold = 128;\n-    \n-    if (__endp1 >= __len) {\n-\tif (0 == __start) {\n-\t    __base->_M_ref_nonnil();\n-\t    return __base;\n-\t} else {\n-\t    __adj_endp1 = __len;\n-\t}\n-    } else {\n-\t__adj_endp1 = __endp1;\n-    }\n-    switch(__base->_M_tag) {\n-\tcase _RopeRep::_S_concat:\n-\t    {\n-\t\t_RopeConcatenation* __c = (_RopeConcatenation*)__base;\n-\t\t_RopeRep* __left = __c->_M_left;\n-\t\t_RopeRep* __right = __c->_M_right;\n-\t\tsize_t __left_len = __left->_M_size;\n-\t\t_RopeRep* __result;\n-\n-\t\tif (__adj_endp1 <= __left_len) {\n-\t\t    return _S_substring(__left, __start, __endp1);\n-\t\t} else if (__start >= __left_len) {\n-\t\t    return _S_substring(__right, __start - __left_len,\n-\t\t\t\t  __adj_endp1 - __left_len);\n-\t\t}\n-\t\t_Self_destruct_ptr __left_result(\n-\t\t  _S_substring(__left, __start, __left_len));\n-\t\t_Self_destruct_ptr __right_result(\n-\t\t  _S_substring(__right, 0, __endp1 - __left_len));\n-\t\t__result = _S_concat(__left_result, __right_result);\n-#               ifndef __GC\n-\t\t  __stl_assert(1 == __result->_M_ref_count);\n-#               endif\n-\t\treturn __result;\n-\t    }\n-\tcase _RopeRep::_S_leaf:\n-\t    {\n-\t\t_RopeLeaf* __l = (_RopeLeaf*)__base;\n-\t\t_RopeLeaf* __result;\n-\t\tsize_t __result_len;\n-\t\tif (__start >= __adj_endp1) return 0;\n-\t\t__result_len = __adj_endp1 - __start;\n-\t\tif (__result_len > __lazy_threshold) goto lazy;\n-#               ifdef __GC\n-\t\t    const _CharT* __section = __l->_M_data + __start;\n-\t\t    __result = _S_new_RopeLeaf(__section, __result_len,\n-\t\t\t\t\t  __base->get_allocator());\n-\t\t    __result->_M_c_string = 0;  // Not eos terminated.\n-#               else\n-\t\t    // We should sometimes create substring node instead.\n-\t\t    __result = __STL_ROPE_FROM_UNOWNED_CHAR_PTR(\n-\t\t\t\t\t__l->_M_data + __start, __result_len,\n-\t\t\t\t\t__base->get_allocator());\n-#               endif\n-\t\treturn __result;\n-\t    }\n-\tcase _RopeRep::_S_substringfn:\n-\t    // Avoid introducing multiple layers of substring nodes.\n-\t    {\n-\t\t_RopeSubstring* __old = (_RopeSubstring*)__base;\n-\t\tsize_t __result_len;\n-\t\tif (__start >= __adj_endp1) return 0;\n-\t\t__result_len = __adj_endp1 - __start;\n-\t\tif (__result_len > __lazy_threshold) {\n-\t\t    _RopeSubstring* __result =\n-\t\t\t_S_new_RopeSubstring(__old->_M_base,\n-\t\t\t\t\t  __start + __old->_M_start,\n-\t\t\t\t\t  __adj_endp1 - __start,\n-\t\t\t\t\t  __base->get_allocator());\n-\t\t    return __result;\n-\n-\t\t} // *** else fall through: ***\n-\t    }\n-\tcase _RopeRep::_S_function:\n-\t    {\n-\t\t_RopeFunction* __f = (_RopeFunction*)__base;\n-\t\t_CharT* __section;\n-\t\tsize_t __result_len;\n-\t\tif (__start >= __adj_endp1) return 0;\n-\t\t__result_len = __adj_endp1 - __start;\n-\n-\t\tif (__result_len > __lazy_threshold) goto lazy;\n-\t\t__section = (_CharT*)\n-\t\t\t_Data_allocate(_S_rounded_up_size(__result_len));\n-\t\t__STL_TRY {\n-\t\t  (*(__f->_M_fn))(__start, __result_len, __section);\n-                }\n-\t\t__STL_UNWIND(_RopeRep::__STL_FREE_STRING(\n-\t               __section, __result_len, __base->get_allocator()));\n-\t\t_S_cond_store_eos(__section[__result_len]);\n-\t\treturn _S_new_RopeLeaf(__section, __result_len,\n-\t\t\t\t       __base->get_allocator());\n-\t    }\n-    }\n-    /*NOTREACHED*/\n-    __stl_assert(false);\n-  lazy:\n-    {\n-\t// Create substring node.\n-\treturn _S_new_RopeSubstring(__base, __start, __adj_endp1 - __start,\n-\t\t\t       __base->get_allocator());\n-    }\n-}\n-\n-template<class _CharT>\n-class _Rope_flatten_char_consumer : public _Rope_char_consumer<_CharT> {\n-    private:\n-\t_CharT* _M_buf_ptr;\n-    public:\n-\n-\t_Rope_flatten_char_consumer(_CharT* __buffer) {\n-\t    _M_buf_ptr = __buffer;\n-\t};\n-\t~_Rope_flatten_char_consumer() {}\n-\tbool operator() (const _CharT* __leaf, size_t __n) {\n-\t    uninitialized_copy_n(__leaf, __n, _M_buf_ptr);\n-\t    _M_buf_ptr += __n;\n-\t    return true;\n-\t}\n-};\n-\t    \n-template<class _CharT>\n-class _Rope_find_char_char_consumer : public _Rope_char_consumer<_CharT> {\n-    private:\n-\t_CharT _M_pattern;\n-    public:\n-\tsize_t _M_count;  // Number of nonmatching characters\n-\t_Rope_find_char_char_consumer(_CharT __p) \n-\t  : _M_pattern(__p), _M_count(0) {}\n-\t~_Rope_find_char_char_consumer() {}\n-\tbool operator() (const _CharT* __leaf, size_t __n) {\n-\t    size_t __i;\n-\t    for (__i = 0; __i < __n; __i++) {\n-\t\tif (__leaf[__i] == _M_pattern) {\n-\t\t    _M_count += __i; return false;\n-\t\t}\n-\t    }\n-\t    _M_count += __n; return true;\n-\t}\n-};\n-\t    \n-#ifdef __STL_USE_NEW_IOSTREAMS\n-  template<class _CharT, class _Traits>\n-  // Here _CharT is both the stream and rope character type.\n-#else\n-  template<class _CharT>\n-  // Here _CharT is the rope character type.  Unlike in the\n-  // above case, we somewhat handle the case in which it doesn't\n-  // match the stream character type, i.e. char.\n-#endif\n-class _Rope_insert_char_consumer : public _Rope_char_consumer<_CharT> {\n-    private:\n-#       ifdef __STL_USE_NEW_IOSTREAMS\n-\t  typedef basic_ostream<_CharT,_Traits> _Insert_ostream;\n-#\telse\n-\t  typedef ostream _Insert_ostream;\n-#\tendif\n-\t_Insert_ostream& _M_o;\n-    public:\n-\t_Rope_insert_char_consumer(_Insert_ostream& __writer) \n-\t  : _M_o(__writer) {};\n-\t~_Rope_insert_char_consumer() { };\n-\t\t// Caller is presumed to own the ostream\n-\tbool operator() (const _CharT* __leaf, size_t __n);\n-\t\t// Returns true to continue traversal.\n-};\n-\t    \n-#ifdef __STL_USE_NEW_IOSTREAMS\n-  template<class _CharT, class _Traits>\n-  bool _Rope_insert_char_consumer<_CharT, _Traits>::operator()\n-                                        (const _CharT* __leaf, size_t __n)\n-  {\n-    size_t __i;\n-    //  We assume that formatting is set up correctly for each element.\n-    for (__i = 0; __i < __n; __i++) _M_o.put(__leaf[__i]);\n-    return true;\n-  }\n-\n-#else\n-  template<class _CharT>\n-  bool _Rope_insert_char_consumer<_CharT>::operator()\n-\t\t\t\t\t(const _CharT* __leaf, size_t __n)\n-  {\n-    size_t __i;\n-    //  We assume that formatting is set up correctly for each element.\n-    for (__i = 0; __i < __n; __i++) _M_o << __leaf[__i];\n-    return true;\n-  }\n-\n-\n-  __STL_TEMPLATE_NULL\n-  inline bool _Rope_insert_char_consumer<char>::operator()\n-\t\t\t\t\t(const char* __leaf, size_t __n)\n-  {\n-    size_t __i;\n-    for (__i = 0; __i < __n; __i++) _M_o.put(__leaf[__i]);\n-    return true;\n-  }\n-#endif\n-\n-template <class _CharT, class _Alloc>\n-bool rope<_CharT, _Alloc>::_S_apply_to_pieces(\n-\t\t\t\t_Rope_char_consumer<_CharT>& __c,\n-\t\t\t\tconst _RopeRep* __r,\n-\t\t\t\tsize_t __begin, size_t __end)\n-{\n-    if (0 == __r) return true;\n-    switch(__r->_M_tag) {\n-\tcase _RopeRep::_S_concat:\n-\t    {\n-\t\t_RopeConcatenation* __conc = (_RopeConcatenation*)__r;\n-\t\t_RopeRep* __left =  __conc->_M_left;\n-\t\tsize_t __left_len = __left->_M_size;\n-\t\tif (__begin < __left_len) {\n-\t\t    size_t __left_end = min(__left_len, __end);\n-\t\t    if (!_S_apply_to_pieces(__c, __left, __begin, __left_end))\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (__end > __left_len) {\n-\t\t    _RopeRep* __right =  __conc->_M_right;\n-\t\t    size_t __right_start = max(__left_len, __begin);\n-\t\t    if (!_S_apply_to_pieces(__c, __right,\n-\t\t\t\t\t __right_start - __left_len,\n-\t\t\t\t\t __end - __left_len)) {\n-\t\t\treturn false;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t    return true;\n-\tcase _RopeRep::_S_leaf:\n-\t    {\n-\t\t_RopeLeaf* __l = (_RopeLeaf*)__r;\n-\t\treturn __c(__l->_M_data + __begin, __end - __begin);\n-\t    }\n-\tcase _RopeRep::_S_function:\n-\tcase _RopeRep::_S_substringfn:\n-\t    {\n-\t\t_RopeFunction* __f = (_RopeFunction*)__r;\n-\t\tsize_t __len = __end - __begin;\n-\t\tbool __result;\n-\t\t_CharT* __buffer =\n-\t\t  (_CharT*)alloc::allocate(__len * sizeof(_CharT));\n-\t\t__STL_TRY {\n-\t\t  (*(__f->_M_fn))(__begin, __len, __buffer);\n-\t\t  __result = __c(__buffer, __len);\n-                  alloc::deallocate(__buffer, __len * sizeof(_CharT));\n-                }\n-\t\t__STL_UNWIND((alloc::deallocate(__buffer,\n-\t\t\t\t\t\t__len * sizeof(_CharT))))\n-\t\treturn __result;\n-\t    }\n-\tdefault:\n-\t    __stl_assert(false);\n-\t    /*NOTREACHED*/\n-\t    return false;\n-    }\n-}\n-\n-#ifdef __STL_USE_NEW_IOSTREAMS\n-  template<class _CharT, class _Traits>\n-  inline void _Rope_fill(basic_ostream<_CharT, _Traits>& __o, size_t __n)\n-#else\n-  inline void _Rope_fill(ostream& __o, size_t __n)\n-#endif\n-{\n-    char __f = __o.fill();\n-    size_t __i;\n-\n-    for (__i = 0; __i < __n; __i++) __o.put(__f);\n-}\n-    \n-\n-template <class _CharT> inline bool _Rope_is_simple(_CharT*) { return false; }\n-inline bool _Rope_is_simple(char*) { return true; }\n-inline bool _Rope_is_simple(wchar_t*) { return true; }\n-\n-#ifdef __STL_USE_NEW_IOSTREAMS\n-  template<class _CharT, class _Traits, class _Alloc>\n-  basic_ostream<_CharT, _Traits>& operator<<\n-\t\t\t\t\t(basic_ostream<_CharT, _Traits>& __o,\n-\t\t\t\t\t const rope<_CharT, _Alloc>& __r)\n-#else\n-  template<class _CharT, class _Alloc>\n-  ostream& operator<< (ostream& __o, const rope<_CharT, _Alloc>& __r)\n-#endif\n-{\n-    size_t __w = __o.width();\n-    bool __left = bool(__o.flags() & ios::left);\n-    size_t __pad_len;\n-    size_t __rope_len = __r.size();\n-#   ifdef __STL_USE_NEW_IOSTREAMS\n-      _Rope_insert_char_consumer<_CharT, _Traits> __c(__o);\n-#   else\n-      _Rope_insert_char_consumer<_CharT> __c(__o);\n-#   endif\n-    bool __is_simple = _Rope_is_simple((_CharT*)0);\n-    \n-    if (__rope_len < __w) {\n-\t__pad_len = __w - __rope_len;\n-    } else {\n-\t__pad_len = 0;\n-    }\n-    if (!__is_simple) __o.width(__w/__rope_len);\n-    __STL_TRY {\n-      if (__is_simple && !__left && __pad_len > 0) {\n-\t_Rope_fill(__o, __pad_len);\n-      }\n-      __r.apply_to_pieces(0, __r.size(), __c);\n-      if (__is_simple && __left && __pad_len > 0) {\n-\t_Rope_fill(__o, __pad_len);\n-      }\n-      if (!__is_simple)\n-        __o.width(__w);\n-    }\n-    __STL_UNWIND(if (!__is_simple) __o.width(__w))\n-    return __o;\n-}\n-\n-template <class _CharT, class _Alloc>\n-_CharT*\n-rope<_CharT,_Alloc>::_S_flatten(_RopeRep* __r,\n-\t\t\t\t size_t __start, size_t __len,\n-\t\t\t\t _CharT* __buffer)\n-{\n-    _Rope_flatten_char_consumer<_CharT> __c(__buffer);\n-    _S_apply_to_pieces(__c, __r, __start, __start + __len);\n-    return(__buffer + __len);\n-}\n-\n-template <class _CharT, class _Alloc>\n-size_t\n-rope<_CharT,_Alloc>::find(_CharT __pattern, size_t __start) const\n-{\n-    _Rope_find_char_char_consumer<_CharT> __c(__pattern);\n-    _S_apply_to_pieces(__c, _M_tree_ptr, __start, size());\n-    size_type __result_pos = __start + __c._M_count;\n-#   ifndef __STL_OLD_ROPE_SEMANTICS\n-\tif (__result_pos == size()) __result_pos = npos;\n-#   endif\n-    return __result_pos;\n-}\n-\n-template <class _CharT, class _Alloc>\n-_CharT*\n-rope<_CharT,_Alloc>::_S_flatten(_RopeRep* __r, _CharT* __buffer)\n-{\n-    if (0 == __r) return __buffer;\n-    switch(__r->_M_tag) {\n-\tcase _RopeRep::_S_concat:\n-\t    {\n-\t\t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n-\t\t_RopeRep* __left = __c->_M_left;\n-\t\t_RopeRep* __right = __c->_M_right;\n-\t\t_CharT* __rest = _S_flatten(__left, __buffer);\n-\t\treturn _S_flatten(__right, __rest);\n-\t    }\n-\tcase _RopeRep::_S_leaf:\n-\t    {\n-\t\t_RopeLeaf* __l = (_RopeLeaf*)__r;\n-\t\treturn copy_n(__l->_M_data, __l->_M_size, __buffer).second;\n-\t    }\n-\tcase _RopeRep::_S_function:\n-\tcase _RopeRep::_S_substringfn:\n-\t    // We dont yet do anything with substring nodes.\n-\t    // This needs to be fixed before ropefiles will work well.\n-\t    {\n-\t\t_RopeFunction* __f = (_RopeFunction*)__r;\n-\t\t(*(__f->_M_fn))(0, __f->_M_size, __buffer);\n-\t\treturn __buffer + __f->_M_size;\n-\t    }\n-\tdefault:\n-\t    __stl_assert(false);\n-\t    /*NOTREACHED*/\n-\t    return 0;\n-    }\n-}\n-\n-\n-// This needs work for _CharT != char\n-template <class _CharT, class _Alloc>\n-void\n-rope<_CharT,_Alloc>::_S_dump(_RopeRep* __r, int __indent)\n-{\n-    for (int __i = 0; __i < __indent; __i++) putchar(' ');\n-    if (0 == __r) {\n-\tprintf(\"NULL\\n\"); return;\n-    }\n-    if (_RopeRep::_S_concat == __r->_M_tag) {\n-\t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n-\t_RopeRep* __left = __c->_M_left;\n-\t_RopeRep* __right = __c->_M_right;\n-\n-#       ifdef __GC\n-\t  printf(\"Concatenation %p (depth = %d, len = %ld, %s balanced)\\n\",\n-\t    __r, __r->_M_depth, __r->_M_size, __r->_M_is_balanced? \"\" : \"not\");\n-#       else\n-\t  printf(\"Concatenation %p (rc = %ld, depth = %d, \"\n-\t           \"len = %ld, %s balanced)\\n\",\n-\t\t __r, __r->_M_ref_count, __r->_M_depth, __r->_M_size,\n-\t\t __r->_M_is_balanced? \"\" : \"not\");\n-#       endif\n-\t_S_dump(__left, __indent + 2);\n-\t_S_dump(__right, __indent + 2);\n-\treturn;\n-    } else {\n-\tchar* __kind;\n-\n-\tswitch (__r->_M_tag) {\n-\t    case _RopeRep::_S_leaf:\n-\t\t__kind = \"Leaf\";\n-\t\tbreak;\n-\t    case _RopeRep::_S_function:\n-\t\t__kind = \"Function\";\n-\t\tbreak;\n-\t    case _RopeRep::_S_substringfn:\n-\t\t__kind = \"Function representing substring\";\n-\t\tbreak;\n-\t    default:\n-\t\t__kind = \"(corrupted kind field!)\";\n-\t}\n-#       ifdef __GC\n-\t  printf(\"%s %p (depth = %d, len = %ld) \",\n-\t\t __kind, __r, __r->_M_depth, __r->_M_size);\n-#       else\n-\t  printf(\"%s %p (rc = %ld, depth = %d, len = %ld) \",\n-\t\t __kind, __r, __r->_M_ref_count, __r->_M_depth, __r->_M_size);\n-#       endif\n-\tif (_S_is_one_byte_char_type((_CharT*)0)) {\n-\t    const int __max_len = 40;\n-\t    _Self_destruct_ptr __prefix(_S_substring(__r, 0, __max_len));\n-\t    _CharT __buffer[__max_len + 1];\n-\t    bool __too_big = __r->_M_size > __prefix->_M_size;\n-\n-\t    _S_flatten(__prefix, __buffer);\n-\t    __buffer[__prefix->_M_size] = _S_eos((_CharT*)0); \n-\t    printf(\"%s%s\\n\", \n-\t           (char*)__buffer, __too_big? \"...\\n\" : \"\\n\");\n-\t} else {\n-\t    printf(\"\\n\");\n-\t}\n-    }\n-}\n-\n-template <class _CharT, class _Alloc>\n-const unsigned long\n-rope<_CharT,_Alloc>::_S_min_len[\n-  _Rope_RopeRep<_CharT,_Alloc>::_S_max_rope_depth + 1] = {\n-/* 0 */1, /* 1 */2, /* 2 */3, /* 3 */5, /* 4 */8, /* 5 */13, /* 6 */21,\n-/* 7 */34, /* 8 */55, /* 9 */89, /* 10 */144, /* 11 */233, /* 12 */377,\n-/* 13 */610, /* 14 */987, /* 15 */1597, /* 16 */2584, /* 17 */4181,\n-/* 18 */6765, /* 19 */10946, /* 20 */17711, /* 21 */28657, /* 22 */46368,\n-/* 23 */75025, /* 24 */121393, /* 25 */196418, /* 26 */317811,\n-/* 27 */514229, /* 28 */832040, /* 29 */1346269, /* 30 */2178309,\n-/* 31 */3524578, /* 32 */5702887, /* 33 */9227465, /* 34 */14930352,\n-/* 35 */24157817, /* 36 */39088169, /* 37 */63245986, /* 38 */102334155,\n-/* 39 */165580141, /* 40 */267914296, /* 41 */433494437,\n-/* 42 */701408733, /* 43 */1134903170, /* 44 */1836311903,\n-/* 45 */2971215073u };\n-// These are Fibonacci numbers < 2**32.\n-\n-template <class _CharT, class _Alloc>\n-rope<_CharT,_Alloc>::_RopeRep*\n-rope<_CharT,_Alloc>::_S_balance(_RopeRep* __r)\n-{\n-    _RopeRep* __forest[_RopeRep::_S_max_rope_depth + 1];\n-    _RopeRep* __result = 0;\n-    int __i;\n-    // Invariant:\n-    // The concatenation of forest in descending order is equal to __r.\n-    // __forest[__i]._M_size >= _S_min_len[__i]\n-    // __forest[__i]._M_depth = __i\n-    // References from forest are included in refcount.\n-\n-    for (__i = 0; __i <= _RopeRep::_S_max_rope_depth; ++__i) \n-      __forest[__i] = 0;\n-    __STL_TRY {\n-      _S_add_to_forest(__r, __forest);\n-      for (__i = 0; __i <= _RopeRep::_S_max_rope_depth; ++__i) \n-        if (0 != __forest[__i]) {\n-#\tifndef __GC\n-\t  _Self_destruct_ptr __old(__result);\n-#\tendif\n-\t  __result = _S_concat(__forest[__i], __result);\n-\t__forest[__i]->_M_unref_nonnil();\n-#\tif !defined(__GC) && defined(__STL_USE_EXCEPTIONS)\n-\t  __forest[__i] = 0;\n-#\tendif\n-      }\n-    }\n-    __STL_UNWIND(for(__i = 0; __i <= _RopeRep::_S_max_rope_depth; __i++)\n-\t\t _S_unref(__forest[__i]))\n-    if (__result->_M_depth > _RopeRep::_S_max_rope_depth) {\n-#     ifdef __STL_USE_EXCEPTIONS\n-\t__STL_THROW(length_error(\"rope too long\"));\n-#     else\n-\tabort();\n-#     endif\n-    }\n-    return(__result);\n-}\n-\n-\n-template <class _CharT, class _Alloc>\n-void\n-rope<_CharT,_Alloc>::_S_add_to_forest(_RopeRep* __r, _RopeRep** __forest)\n-{\n-    if (__r->_M_is_balanced) {\n-\t_S_add_leaf_to_forest(__r, __forest);\n-\treturn;\n-    }\n-    __stl_assert(__r->_M_tag == _RopeRep::_S_concat);\n-    {\n-\t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n-\n-\t_S_add_to_forest(__c->_M_left, __forest);\n-\t_S_add_to_forest(__c->_M_right, __forest);\n-    }\n-}\n-\n-\n-template <class _CharT, class _Alloc>\n-void\n-rope<_CharT,_Alloc>::_S_add_leaf_to_forest(_RopeRep* __r, _RopeRep** __forest)\n-{\n-    _RopeRep* __insertee;   \t\t// included in refcount\n-    _RopeRep* __too_tiny = 0;    \t// included in refcount\n-    int __i;  \t\t\t\t// forest[0..__i-1] is empty\n-    size_t __s = __r->_M_size;\n-\n-    for (__i = 0; __s >= _S_min_len[__i+1]/* not this bucket */; ++__i) {\n-\tif (0 != __forest[__i]) {\n-#\t    ifndef __GC\n-\t      _Self_destruct_ptr __old(__too_tiny);\n-#\t    endif\n-\t    __too_tiny = _S_concat_and_set_balanced(__forest[__i], __too_tiny);\n-\t    __forest[__i]->_M_unref_nonnil();\n-\t    __forest[__i] = 0;\n-\t}\n-    }\n-    {\n-#\tifndef __GC\n-\t  _Self_destruct_ptr __old(__too_tiny);\n-#\tendif\n-\t__insertee = _S_concat_and_set_balanced(__too_tiny, __r);\n-    }\n-    // Too_tiny dead, and no longer included in refcount.\n-    // Insertee is live and included.\n-    __stl_assert(_S_is_almost_balanced(__insertee));\n-    __stl_assert(__insertee->_M_depth <= __r->_M_depth + 1);\n-    for (;; ++__i) {\n-\tif (0 != __forest[__i]) {\n-#\t    ifndef __GC\n-\t      _Self_destruct_ptr __old(__insertee);\n-#\t    endif\n-\t    __insertee = _S_concat_and_set_balanced(__forest[__i], __insertee);\n-\t    __forest[__i]->_M_unref_nonnil();\n-\t    __forest[__i] = 0;\n-\t    __stl_assert(_S_is_almost_balanced(__insertee));\n-\t}\n-\t__stl_assert(_S_min_len[__i] <= __insertee->_M_size);\n-\t__stl_assert(__forest[__i] == 0);\n-\tif (__i == _RopeRep::_S_max_rope_depth || \n-\t      __insertee->_M_size < _S_min_len[__i+1]) {\n-\t    __forest[__i] = __insertee;\n-\t    // refcount is OK since __insertee is now dead.\n-\t    return;\n-\t}\n-    }\n-}\n-\n-template <class _CharT, class _Alloc>\n-_CharT\n-rope<_CharT,_Alloc>::_S_fetch(_RopeRep* __r, size_type __i)\n-{\n-    __GC_CONST _CharT* __cstr = __r->_M_c_string;\n-\n-    __stl_assert(__i < __r->_M_size);\n-    if (0 != __cstr) return __cstr[__i]; \n-    for(;;) {\n-      switch(__r->_M_tag) {\n-\tcase _RopeRep::_S_concat:\n-\t    {\n-\t\t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n-\t\t_RopeRep* __left = __c->_M_left;\n-\t\tsize_t __left_len = __left->_M_size;\n-\n-\t\tif (__i >= __left_len) {\n-\t\t    __i -= __left_len;\n-\t\t    __r = __c->_M_right;\n-\t\t} else {\n-\t\t    __r = __left;\n-\t\t}\n-\t    }\n-\t    break;\n-\tcase _RopeRep::_S_leaf:\n-\t    {\n-\t\t_RopeLeaf* __l = (_RopeLeaf*)__r;\n-\t\treturn __l->_M_data[__i];\n-\t    }\n-\tcase _RopeRep::_S_function:\n-\tcase _RopeRep::_S_substringfn:\n-\t    {\n-\t\t_RopeFunction* __f = (_RopeFunction*)__r;\n-\t\t_CharT __result;\n-\n-\t\t(*(__f->_M_fn))(__i, 1, &__result);\n-\t\treturn __result;\n-\t    }\n-      }\n-    }\n-}\n-\n-# ifndef __GC\n-// Return a uniquely referenced character slot for the given\n-// position, or 0 if that's not possible.\n-template <class _CharT, class _Alloc>\n-_CharT*\n-rope<_CharT,_Alloc>::_S_fetch_ptr(_RopeRep* __r, size_type __i)\n-{\n-    _RopeRep* __clrstack[_RopeRep::_S_max_rope_depth];\n-    size_t __csptr = 0;\n-\n-    for(;;) {\n-      if (__r->_M_ref_count > 1) return 0;\n-      switch(__r->_M_tag) {\n-\tcase _RopeRep::_S_concat:\n-\t    {\n-\t\t_RopeConcatenation* __c = (_RopeConcatenation*)__r;\n-\t\t_RopeRep* __left = __c->_M_left;\n-\t\tsize_t __left_len = __left->_M_size;\n-\n-\t\tif (__c->_M_c_string != 0) __clrstack[__csptr++] = __c;\n-\t\tif (__i >= __left_len) {\n-\t\t    __i -= __left_len;\n-\t\t    __r = __c->_M_right;\n-\t\t} else {\n-\t\t    __r = __left;\n-\t\t}\n-\t    }\n-\t    break;\n-\tcase _RopeRep::_S_leaf:\n-\t    {\n-\t\t_RopeLeaf* __l = (_RopeLeaf*)__r;\n-\t\tif (__l->_M_c_string != __l->_M_data && __l->_M_c_string != 0)\n-\t\t    __clrstack[__csptr++] = __l;\n-\t\twhile (__csptr > 0) {\n-\t\t    -- __csptr;\n-\t\t    _RopeRep* __d = __clrstack[__csptr];\n-\t\t    __d->_M_free_c_string();\n-\t\t    __d->_M_c_string = 0;\n-\t\t}\n-\t\treturn __l->_M_data + __i;\n-\t    }\n-\tcase _RopeRep::_S_function:\n-\tcase _RopeRep::_S_substringfn:\n-\t    return 0;\n-      }\n-    }\n-}\n-# endif /* __GC */\n-\n-// The following could be implemented trivially using\n-// lexicographical_compare_3way.\n-// We do a little more work to avoid dealing with rope iterators for\n-// flat strings.\n-template <class _CharT, class _Alloc>\n-int\n-rope<_CharT,_Alloc>::_S_compare (const _RopeRep* __left, \n-                                 const _RopeRep* __right)\n-{\n-    size_t __left_len;\n-    size_t __right_len;\n-\n-    if (0 == __right) return 0 != __left;\n-    if (0 == __left) return -1;\n-    __left_len = __left->_M_size;\n-    __right_len = __right->_M_size;\n-    if (_RopeRep::_S_leaf == __left->_M_tag) {\n-\t_RopeLeaf* __l = (_RopeLeaf*) __left;\n-\tif (_RopeRep::_S_leaf == __right->_M_tag) {\n-\t    _RopeLeaf* __r = (_RopeLeaf*) __right;\n-\t    return lexicographical_compare_3way(\n-\t\t\t__l->_M_data, __l->_M_data + __left_len,\n-\t\t\t__r->_M_data, __r->_M_data + __right_len);\n-\t} else {\n-\t    const_iterator __rstart(__right, 0);\n-\t    const_iterator __rend(__right, __right_len);\n-\t    return lexicographical_compare_3way(\n-\t\t\t__l->_M_data, __l->_M_data + __left_len,\n-\t\t\t__rstart, __rend);\n-\t}\n-    } else {\n-\tconst_iterator __lstart(__left, 0);\n-\tconst_iterator __lend(__left, __left_len);\n-\tif (_RopeRep::_S_leaf == __right->_M_tag) {\n-\t    _RopeLeaf* __r = (_RopeLeaf*) __right;\n-\t    return lexicographical_compare_3way(\n-\t\t\t\t   __lstart, __lend,\n-\t\t\t\t   __r->_M_data, __r->_M_data + __right_len);\n-\t} else {\n-\t    const_iterator __rstart(__right, 0);\n-\t    const_iterator __rend(__right, __right_len);\n-\t    return lexicographical_compare_3way(\n-\t\t\t\t   __lstart, __lend,\n-\t\t\t\t   __rstart, __rend);\n-\t}\n-    }\n-}\n-\n-// Assignment to reference proxies.\n-template <class _CharT, class _Alloc>\n-_Rope_char_ref_proxy<_CharT, _Alloc>&\n-_Rope_char_ref_proxy<_CharT, _Alloc>::operator= (_CharT __c) {\n-    _RopeRep* __old = _M_root->_M_tree_ptr;\n-#   ifndef __GC\n-\t// First check for the case in which everything is uniquely\n-\t// referenced.  In that case we can do this destructively.\n-\t_CharT* __ptr = _My_rope::_S_fetch_ptr(__old, _M_pos);\n-\tif (0 != __ptr) {\n-\t    *__ptr = __c;\n-\t    return *this;\n-\t}\n-#   endif\n-    _Self_destruct_ptr __left(\n-      _My_rope::_S_substring(__old, 0, _M_pos));\n-    _Self_destruct_ptr __right(\n-      _My_rope::_S_substring(__old, _M_pos+1, __old->_M_size));\n-    _Self_destruct_ptr __result_left(\n-      _My_rope::_S_destr_concat_char_iter(__left, &__c, 1));\n-\n-#   ifndef __GC\n-      __stl_assert(__left == __result_left || 1 == __result_left->_M_ref_count);\n-#   endif\n-    _RopeRep* __result =\n-\t\t_My_rope::_S_concat(__result_left, __right);\n-#   ifndef __GC\n-      __stl_assert(1 <= __result->_M_ref_count);\n-      _RopeRep::_S_unref(__old);\n-#   endif\n-    _M_root->_M_tree_ptr = __result;\n-    return *this;\n-}\n-\n-template <class _CharT, class _Alloc>\n-inline _Rope_char_ref_proxy<_CharT, _Alloc>::operator _CharT () const\n-{\n-    if (_M_current_valid) {\n-\treturn _M_current;\n-    } else {\n-        return _My_rope::_S_fetch(_M_root->_M_tree_ptr, _M_pos);\n-    }\n-}\n-template <class _CharT, class _Alloc>\n-_Rope_char_ptr_proxy<_CharT, _Alloc>\n-_Rope_char_ref_proxy<_CharT, _Alloc>::operator& () const {\n-    return _Rope_char_ptr_proxy<_CharT, _Alloc>(*this);\n-}\n-\n-template <class _CharT, class _Alloc>\n-rope<_CharT, _Alloc>::rope(size_t __n, _CharT __c,\n-\t\t\t   const allocator_type& __a)\n-: _Base(__a)\n-{\n-    rope<_CharT,_Alloc> __result;\n-    const size_t __exponentiate_threshold = 32;\n-    size_t __exponent;\n-    size_t __rest;\n-    _CharT* __rest_buffer;\n-    _RopeRep* __remainder;\n-    rope<_CharT,_Alloc> __remainder_rope;\n-\n-    if (0 == __n)\n-      return;\n-    \n-    __exponent = __n / __exponentiate_threshold;\n-    __rest = __n % __exponentiate_threshold;\n-    if (0 == __rest) {\n-\t__remainder = 0;\n-    } else {\n-\t__rest_buffer = _Data_allocate(_S_rounded_up_size(__rest));\n-\tuninitialized_fill_n(__rest_buffer, __rest, __c);\n-\t_S_cond_store_eos(__rest_buffer[__rest]);\n-\t__STL_TRY {\n-\t    __remainder = _S_new_RopeLeaf(__rest_buffer, __rest, __a);\n-        }\n-\t__STL_UNWIND(_RopeRep::__STL_FREE_STRING(__rest_buffer, __rest, __a))\n-    }\n-    __remainder_rope._M_tree_ptr = __remainder;\n-    if (__exponent != 0) {\n-\t_CharT* __base_buffer =\n-\t  _Data_allocate(_S_rounded_up_size(__exponentiate_threshold));\n-\t_RopeLeaf* __base_leaf;\n-\trope __base_rope;\n-\tuninitialized_fill_n(__base_buffer, __exponentiate_threshold, __c);\n-\t_S_cond_store_eos(__base_buffer[__exponentiate_threshold]);\n-\t__STL_TRY {\n-          __base_leaf = _S_new_RopeLeaf(__base_buffer,\n-                                        __exponentiate_threshold, __a);\n-        }\n-\t__STL_UNWIND(_RopeRep::__STL_FREE_STRING(__base_buffer, \n-\t                                         __exponentiate_threshold, __a))\n-\t__base_rope._M_tree_ptr = __base_leaf;\n- \tif (1 == __exponent) {\n-\t  __result = __base_rope;\n-#         ifndef __GC\n-\t    __stl_assert(2 == __result._M_tree_ptr->_M_ref_count);\n-\t\t// One each for base_rope and __result\n-#         endif\n-\t} else {\n-\t  __result = power(__base_rope, __exponent,\n-\t\t\t   _Rope_Concat_fn<_CharT,_Alloc>());\n-\t}\n-\tif (0 != __remainder) {\n-\t  __result += __remainder_rope;\n-\t}\n-    } else {\n-\t__result = __remainder_rope;\n-    }\n-    _M_tree_ptr = __result._M_tree_ptr;\n-    _M_tree_ptr->_M_ref_nonnil();\n-}\n-\n-template<class _CharT, class _Alloc>\n-  _CharT rope<_CharT,_Alloc>::_S_empty_c_str[1];\n-\n-template<class _CharT, class _Alloc>\n-const _CharT* rope<_CharT,_Alloc>::c_str() const {\n-    if (0 == _M_tree_ptr) {\n-        _S_empty_c_str[0] = _S_eos((_CharT*)0);  // Possibly redundant,\n-\t\t\t\t\t     // but probably fast.\n-        return _S_empty_c_str;\n-    }\n-    __GC_CONST _CharT* __old_c_string = _M_tree_ptr->_M_c_string;\n-    if (0 != __old_c_string) return(__old_c_string);\n-    size_t __s = size();\n-    _CharT* __result = _Data_allocate(__s + 1);\n-    _S_flatten(_M_tree_ptr, __result);\n-    __result[__s] = _S_eos((_CharT*)0);\n-#   ifdef __GC\n-\t_M_tree_ptr->_M_c_string = __result;\n-#   else\n-      if ((__old_c_string = (__GC_CONST _CharT*)\n-             _Atomic_swap((unsigned long *)(&(_M_tree_ptr->_M_c_string)),\n-\t\t\t  (unsigned long)__result)) != 0) {\n-\t// It must have been added in the interim.  Hence it had to have been\n-\t// separately allocated.  Deallocate the old copy, since we just\n-\t// replaced it.\n-\tdestroy(__old_c_string, __old_c_string + __s + 1);\n-\t_Data_deallocate(__old_c_string, __s + 1);\n-      }\n-#   endif\n-    return(__result);\n-}\n-\n-template<class _CharT, class _Alloc>\n-const _CharT* rope<_CharT,_Alloc>::replace_with_c_str() {\n-    if (0 == _M_tree_ptr) {\n-        _S_empty_c_str[0] = _S_eos((_CharT*)0);\n-        return _S_empty_c_str;\n-    }\n-    __GC_CONST _CharT* __old_c_string = _M_tree_ptr->_M_c_string;\n-    if (_RopeRep::_S_leaf == _M_tree_ptr->_M_tag && 0 != __old_c_string) {\n-\treturn(__old_c_string);\n-    }\n-    size_t __s = size();\n-    _CharT* __result = _Data_allocate(_S_rounded_up_size(__s));\n-    _S_flatten(_M_tree_ptr, __result);\n-    __result[__s] = _S_eos((_CharT*)0);\n-    _M_tree_ptr->_M_unref_nonnil();\n-    _M_tree_ptr = _S_new_RopeLeaf(__result, __s, get_allocator());\n-    return(__result);\n-}\n-\n-// Algorithm specializations.  More should be added.\n-\n-template<class _Rope_iterator>  // was templated on CharT and Alloc\n-void\t\t\t\t// VC++ workaround\n-_Rope_rotate(_Rope_iterator __first,\n-             _Rope_iterator __middle,\n-             _Rope_iterator __last)\n-{\n-  typedef typename _Rope_iterator::value_type _CharT;\n-  typedef typename _Rope_iterator::_allocator_type _Alloc;\n-  \n-  __stl_assert(__first.container() == __middle.container()\n-                           && __middle.container() == __last.container());\n-  rope<_CharT,_Alloc>& __r(__first.container());\n-  rope<_CharT,_Alloc> __prefix = __r.substr(0, __first.index());\n-  rope<_CharT,_Alloc> __suffix = \n-    __r.substr(__last.index(), __r.size() - __last.index());\n-  rope<_CharT,_Alloc> __part1 = \n-    __r.substr(__middle.index(), __last.index() - __middle.index());\n-  rope<_CharT,_Alloc> __part2 = \n-    __r.substr(__first.index(), __middle.index() - __first.index());\n-  __r = __prefix;\n-  __r += __part1;\n-  __r += __part2;\n-  __r += __suffix;\n-}\n-\n-#if !defined(__GNUC__)\n-// Appears to confuse g++\n-inline void rotate(_Rope_iterator<char,__STL_DEFAULT_ALLOCATOR(char)> __first,\n-                   _Rope_iterator<char,__STL_DEFAULT_ALLOCATOR(char)> __middle,\n-                   _Rope_iterator<char,__STL_DEFAULT_ALLOCATOR(char)> __last) {\n-    _Rope_rotate(__first, __middle, __last);\n-}\n-#endif\n-\n-# if 0\n-// Probably not useful for several reasons:\n-// - for SGIs 7.1 compiler and probably some others,\n-//   this forces lots of rope<wchar_t, ...> instantiations, creating a\n-//   code bloat and compile time problem.  (Fixed in 7.2.)\n-// - wchar_t is 4 bytes wide on most UNIX platforms, making it unattractive\n-//   for unicode strings.  Unsigned short may be a better character\n-//   type.\n-inline void rotate(\n-\t\t_Rope_iterator<wchar_t,__STL_DEFAULT_ALLOCATOR(char)> __first,\n-                _Rope_iterator<wchar_t,__STL_DEFAULT_ALLOCATOR(char)> __middle,\n-                _Rope_iterator<wchar_t,__STL_DEFAULT_ALLOCATOR(char)> __last) {\n-    _Rope_rotate(__first, __middle, __last);\n-}\n-# endif\n-\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#endif\n-\n-__STL_END_NAMESPACE\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "ef0906279a9781f8433f9bab738c9cfff086dc1d", "filename": "libstdc++-v3/ext/slist", "status": "removed", "additions": 0, "deletions": 1048, "changes": 1048, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Fslist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Fslist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fslist?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,1048 +0,0 @@\n-/*\n- * Copyright (c) 1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- */\n-\n-/* NOTE: This is an internal header file, included by other STL headers.\n- *   You should not attempt to use it directly.\n- */\n-\n-#ifndef __SGI_STL_INTERNAL_SLIST_H\n-#define __SGI_STL_INTERNAL_SLIST_H\n-\n-#include <bits/concept_checks.h>\n-\n-__STL_BEGIN_NAMESPACE \n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#pragma set woff 1375\n-#endif\n-\n-struct _Slist_node_base\n-{\n-  _Slist_node_base* _M_next;\n-};\n-\n-inline _Slist_node_base*\n-__slist_make_link(_Slist_node_base* __prev_node,\n-                  _Slist_node_base* __new_node)\n-{\n-  __new_node->_M_next = __prev_node->_M_next;\n-  __prev_node->_M_next = __new_node;\n-  return __new_node;\n-}\n-\n-inline _Slist_node_base* \n-__slist_previous(_Slist_node_base* __head,\n-                 const _Slist_node_base* __node)\n-{\n-  while (__head && __head->_M_next != __node)\n-    __head = __head->_M_next;\n-  return __head;\n-}\n-\n-inline const _Slist_node_base* \n-__slist_previous(const _Slist_node_base* __head,\n-                 const _Slist_node_base* __node)\n-{\n-  while (__head && __head->_M_next != __node)\n-    __head = __head->_M_next;\n-  return __head;\n-}\n-\n-inline void __slist_splice_after(_Slist_node_base* __pos,\n-                                 _Slist_node_base* __before_first,\n-                                 _Slist_node_base* __before_last)\n-{\n-  if (__pos != __before_first && __pos != __before_last) {\n-    _Slist_node_base* __first = __before_first->_M_next;\n-    _Slist_node_base* __after = __pos->_M_next;\n-    __before_first->_M_next = __before_last->_M_next;\n-    __pos->_M_next = __first;\n-    __before_last->_M_next = __after;\n-  }\n-}\n-\n-inline void\n-__slist_splice_after(_Slist_node_base* __pos, _Slist_node_base* __head)\n-{\n-  _Slist_node_base* __before_last = __slist_previous(__head, 0);\n-  if (__before_last != __head) {\n-    _Slist_node_base* __after = __pos->_M_next;\n-    __pos->_M_next = __head->_M_next;\n-    __head->_M_next = 0;\n-    __before_last->_M_next = __after;\n-  }\n-}\n-\n-inline _Slist_node_base* __slist_reverse(_Slist_node_base* __node)\n-{\n-  _Slist_node_base* __result = __node;\n-  __node = __node->_M_next;\n-  __result->_M_next = 0;\n-  while(__node) {\n-    _Slist_node_base* __next = __node->_M_next;\n-    __node->_M_next = __result;\n-    __result = __node;\n-    __node = __next;\n-  }\n-  return __result;\n-}\n-\n-inline size_t __slist_size(_Slist_node_base* __node)\n-{\n-  size_t __result = 0;\n-  for ( ; __node != 0; __node = __node->_M_next)\n-    ++__result;\n-  return __result;\n-}\n-\n-template <class _Tp>\n-struct _Slist_node : public _Slist_node_base\n-{\n-  _Tp _M_data;\n-};\n-\n-struct _Slist_iterator_base\n-{\n-  typedef size_t               size_type;\n-  typedef ptrdiff_t            difference_type;\n-  typedef forward_iterator_tag iterator_category;\n-\n-  _Slist_node_base* _M_node;\n-\n-  _Slist_iterator_base(_Slist_node_base* __x) : _M_node(__x) {}\n-  void _M_incr() { _M_node = _M_node->_M_next; }\n-\n-  bool operator==(const _Slist_iterator_base& __x) const {\n-    return _M_node == __x._M_node;\n-  }\n-  bool operator!=(const _Slist_iterator_base& __x) const {\n-    return _M_node != __x._M_node;\n-  }\n-};\n-\n-template <class _Tp, class _Ref, class _Ptr>\n-struct _Slist_iterator : public _Slist_iterator_base\n-{\n-  typedef _Slist_iterator<_Tp, _Tp&, _Tp*>             iterator;\n-  typedef _Slist_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n-  typedef _Slist_iterator<_Tp, _Ref, _Ptr>             _Self;\n-\n-  typedef _Tp              value_type;\n-  typedef _Ptr             pointer;\n-  typedef _Ref             reference;\n-  typedef _Slist_node<_Tp> _Node;\n-\n-  _Slist_iterator(_Node* __x) : _Slist_iterator_base(__x) {}\n-  _Slist_iterator() : _Slist_iterator_base(0) {}\n-  _Slist_iterator(const iterator& __x) : _Slist_iterator_base(__x._M_node) {}\n-\n-  reference operator*() const { return ((_Node*) _M_node)->_M_data; }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n-  pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n-\n-  _Self& operator++()\n-  {\n-    _M_incr();\n-    return *this;\n-  }\n-  _Self operator++(int)\n-  {\n-    _Self __tmp = *this;\n-    _M_incr();\n-    return __tmp;\n-  }\n-};\n-\n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-inline ptrdiff_t* distance_type(const _Slist_iterator_base&) {\n-  return 0;\n-}\n-\n-inline forward_iterator_tag iterator_category(const _Slist_iterator_base&) {\n-  return forward_iterator_tag();\n-}\n-\n-template <class _Tp, class _Ref, class _Ptr> \n-inline _Tp* value_type(const _Slist_iterator<_Tp, _Ref, _Ptr>&) {\n-  return 0;\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-// Base class that encapsulates details of allocators.  Three cases:\n-// an ordinary standard-conforming allocator, a standard-conforming\n-// allocator with no non-static data, and an SGI-style allocator.\n-// This complexity is necessary only because we're worrying about backward\n-// compatibility and because we want to avoid wasting storage on an \n-// allocator instance if it isn't necessary.\n-\n-#ifdef __STL_USE_STD_ALLOCATORS\n-\n-// Base for general standard-conforming allocators.\n-template <class _Tp, class _Allocator, bool _IsStatic>\n-class _Slist_alloc_base {\n-public:\n-  typedef typename _Alloc_traits<_Tp,_Allocator>::allocator_type\n-          allocator_type;\n-  allocator_type get_allocator() const { return _M_node_allocator; }\n-\n-  _Slist_alloc_base(const allocator_type& __a) : _M_node_allocator(__a) {}\n-\n-protected:\n-  _Slist_node<_Tp>* _M_get_node() \n-    { return _M_node_allocator.allocate(1); }\n-  void _M_put_node(_Slist_node<_Tp>* __p) \n-    { _M_node_allocator.deallocate(__p, 1); }\n-\n-protected:\n-  typename _Alloc_traits<_Slist_node<_Tp>,_Allocator>::allocator_type\n-           _M_node_allocator;\n-  _Slist_node_base _M_head;\n-};\n-\n-// Specialization for instanceless allocators.\n-template <class _Tp, class _Allocator>\n-class _Slist_alloc_base<_Tp,_Allocator, true> {\n-public:\n-  typedef typename _Alloc_traits<_Tp,_Allocator>::allocator_type\n-          allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-\n-  _Slist_alloc_base(const allocator_type&) {}\n-\n-protected:\n-  typedef typename _Alloc_traits<_Slist_node<_Tp>, _Allocator>::_Alloc_type\n-          _Alloc_type;\n-  _Slist_node<_Tp>* _M_get_node() { return _Alloc_type::allocate(1); }\n-  void _M_put_node(_Slist_node<_Tp>* __p) { _Alloc_type::deallocate(__p, 1); }\n-\n-protected:\n-  _Slist_node_base _M_head;\n-};\n-\n-\n-template <class _Tp, class _Alloc>\n-struct _Slist_base\n-  : public _Slist_alloc_base<_Tp, _Alloc,\n-                             _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-{\n-  typedef _Slist_alloc_base<_Tp, _Alloc,\n-                            _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-          _Base;\n-  typedef typename _Base::allocator_type allocator_type;\n-\n-  _Slist_base(const allocator_type& __a)\n-    : _Base(__a) { this->_M_head._M_next = 0; }\n-  ~_Slist_base() { _M_erase_after(&this->_M_head, 0); }\n-\n-protected:\n-\n-  _Slist_node_base* _M_erase_after(_Slist_node_base* __pos)\n-  {\n-    _Slist_node<_Tp>* __next = (_Slist_node<_Tp>*) (__pos->_M_next);\n-    _Slist_node_base* __next_next = __next->_M_next;\n-    __pos->_M_next = __next_next;\n-    destroy(&__next->_M_data);\n-    _M_put_node(__next);\n-    return __next_next;\n-  }\n-  _Slist_node_base* _M_erase_after(_Slist_node_base*, _Slist_node_base*);\n-};\n-\n-#else /* __STL_USE_STD_ALLOCATORS */\n-\n-template <class _Tp, class _Alloc> \n-struct _Slist_base {\n-  typedef _Alloc allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-\n-  _Slist_base(const allocator_type&) { _M_head._M_next = 0; }\n-  ~_Slist_base() { _M_erase_after(&_M_head, 0); }\n-\n-protected:\n-  typedef simple_alloc<_Slist_node<_Tp>, _Alloc> _Alloc_type;\n-  _Slist_node<_Tp>* _M_get_node() { return _Alloc_type::allocate(1); }\n-  void _M_put_node(_Slist_node<_Tp>* __p) { _Alloc_type::deallocate(__p, 1); }\n-\n-  _Slist_node_base* _M_erase_after(_Slist_node_base* __pos)\n-  {\n-    _Slist_node<_Tp>* __next = (_Slist_node<_Tp>*) (__pos->_M_next);\n-    _Slist_node_base* __next_next = __next->_M_next;\n-    __pos->_M_next = __next_next;\n-    destroy(&__next->_M_data);\n-    _M_put_node(__next);\n-    return __next_next;\n-  }\n-  _Slist_node_base* _M_erase_after(_Slist_node_base*, _Slist_node_base*);\n-\n-protected:\n-  _Slist_node_base _M_head;\n-};  \n-\n-#endif /* __STL_USE_STD_ALLOCATORS */\n-\n-template <class _Tp, class _Alloc> \n-_Slist_node_base*\n-_Slist_base<_Tp,_Alloc>::_M_erase_after(_Slist_node_base* __before_first,\n-                                        _Slist_node_base* __last_node) {\n-  _Slist_node<_Tp>* __cur = (_Slist_node<_Tp>*) (__before_first->_M_next);\n-  while (__cur != __last_node) {\n-    _Slist_node<_Tp>* __tmp = __cur;\n-    __cur = (_Slist_node<_Tp>*) __cur->_M_next;\n-    destroy(&__tmp->_M_data);\n-    _M_put_node(__tmp);\n-  }\n-  __before_first->_M_next = __last_node;\n-  return __last_node;\n-}\n-\n-template <class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >\n-class slist : private _Slist_base<_Tp,_Alloc>\n-{\n-  // requirements:\n-\n-  __STL_CLASS_REQUIRES(_Tp, _Assignable);\n-\n-private:\n-  typedef _Slist_base<_Tp,_Alloc> _Base;\n-public:\n-  typedef _Tp                value_type;\n-  typedef value_type*       pointer;\n-  typedef const value_type* const_pointer;\n-  typedef value_type&       reference;\n-  typedef const value_type& const_reference;\n-  typedef size_t            size_type;\n-  typedef ptrdiff_t         difference_type;\n-\n-  typedef _Slist_iterator<_Tp, _Tp&, _Tp*>             iterator;\n-  typedef _Slist_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n-\n-  typedef typename _Base::allocator_type allocator_type;\n-  allocator_type get_allocator() const { return _Base::get_allocator(); }\n-\n-private:\n-  typedef _Slist_node<_Tp>      _Node;\n-  typedef _Slist_node_base      _Node_base;\n-  typedef _Slist_iterator_base  _Iterator_base;\n-\n-  _Node* _M_create_node(const value_type& __x) {\n-    _Node* __node = this->_M_get_node();\n-    __STL_TRY {\n-      construct(&__node->_M_data, __x);\n-      __node->_M_next = 0;\n-    }\n-    __STL_UNWIND(this->_M_put_node(__node));\n-    return __node;\n-  }\n-  \n-  _Node* _M_create_node() {\n-    _Node* __node = this->_M_get_node();\n-    __STL_TRY {\n-      construct(&__node->_M_data);\n-      __node->_M_next = 0;\n-    }\n-    __STL_UNWIND(this->_M_put_node(__node));\n-    return __node;\n-  }\n-\n-public:\n-  explicit slist(const allocator_type& __a = allocator_type()) : _Base(__a) {}\n-\n-  slist(size_type __n, const value_type& __x,\n-        const allocator_type& __a =  allocator_type()) : _Base(__a)\n-    { _M_insert_after_fill(&this->_M_head, __n, __x); }\n-\n-  explicit slist(size_type __n) : _Base(allocator_type())\n-    { _M_insert_after_fill(&this->_M_head, __n, value_type()); }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  // We don't need any dispatching tricks here, because _M_insert_after_range\n-  // already does them.\n-  template <class _InputIterator>\n-  slist(_InputIterator __first, _InputIterator __last,\n-        const allocator_type& __a =  allocator_type()) : _Base(__a)\n-    { _M_insert_after_range(&this->_M_head, __first, __last); }\n-\n-#else /* __STL_MEMBER_TEMPLATES */\n-  slist(const_iterator __first, const_iterator __last,\n-        const allocator_type& __a =  allocator_type()) : _Base(__a)\n-    { _M_insert_after_range(&this->_M_head, __first, __last); }\n-  slist(const value_type* __first, const value_type* __last,\n-        const allocator_type& __a =  allocator_type()) : _Base(__a)\n-    { _M_insert_after_range(&this->_M_head, __first, __last); }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  slist(const slist& __x) : _Base(__x.get_allocator())\n-    { _M_insert_after_range(&this->_M_head, __x.begin(), __x.end()); }\n-\n-  slist& operator= (const slist& __x);\n-\n-  ~slist() {}\n-\n-public:\n-  // assign(), a generalized assignment member function.  Two\n-  // versions: one that takes a count, and one that takes a range.\n-  // The range version is a member template, so we dispatch on whether\n-  // or not the type is an integer.\n-\n-  void assign(size_type __n, const _Tp& __val)\n-    { _M_fill_assign(__n, __val); }\n-\n-  void _M_fill_assign(size_type __n, const _Tp& __val);\n-\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-\n-  template <class _InputIterator>\n-  void assign(_InputIterator __first, _InputIterator __last) {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_assign_dispatch(__first, __last, _Integral());\n-  }\n-\n-  template <class _Integer>\n-  void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n-    { _M_fill_assign((size_type) __n, (_Tp) __val); }\n-\n-  template <class _InputIterator>\n-  void _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n-                          __false_type);\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-public:\n-\n-  iterator begin() { return iterator((_Node*)this->_M_head._M_next); }\n-  const_iterator begin() const \n-    { return const_iterator((_Node*)this->_M_head._M_next);}\n-\n-  iterator end() { return iterator(0); }\n-  const_iterator end() const { return const_iterator(0); }\n-\n-  // Experimental new feature: before_begin() returns a\n-  // non-dereferenceable iterator that, when incremented, yields\n-  // begin().  This iterator may be used as the argument to\n-  // insert_after, erase_after, etc.  Note that even for an empty \n-  // slist, before_begin() is not the same iterator as end().  It \n-  // is always necessary to increment before_begin() at least once to\n-  // obtain end().\n-  iterator before_begin() { return iterator((_Node*) &this->_M_head); }\n-  const_iterator before_begin() const\n-    { return const_iterator((_Node*) &this->_M_head); }\n-\n-  size_type size() const { return __slist_size(this->_M_head._M_next); }\n-  \n-  size_type max_size() const { return size_type(-1); }\n-\n-  bool empty() const { return this->_M_head._M_next == 0; }\n-\n-  void swap(slist& __x)\n-    { __STD::swap(this->_M_head._M_next, __x._M_head._M_next); }\n-\n-public:\n-\n-  reference front() { return ((_Node*) this->_M_head._M_next)->_M_data; }\n-  const_reference front() const \n-    { return ((_Node*) this->_M_head._M_next)->_M_data; }\n-  void push_front(const value_type& __x)   {\n-    __slist_make_link(&this->_M_head, _M_create_node(__x));\n-  }\n-  void push_front() { __slist_make_link(&this->_M_head, _M_create_node()); }\n-  void pop_front() {\n-    _Node* __node = (_Node*) this->_M_head._M_next;\n-    this->_M_head._M_next = __node->_M_next;\n-    destroy(&__node->_M_data);\n-    this->_M_put_node(__node);\n-  }\n-\n-  iterator previous(const_iterator __pos) {\n-    return iterator((_Node*) __slist_previous(&this->_M_head, __pos._M_node));\n-  }\n-  const_iterator previous(const_iterator __pos) const {\n-    return const_iterator((_Node*) __slist_previous(&this->_M_head,\n-                                                    __pos._M_node));\n-  }\n-\n-private:\n-  _Node* _M_insert_after(_Node_base* __pos, const value_type& __x) {\n-    return (_Node*) (__slist_make_link(__pos, _M_create_node(__x)));\n-  }\n-\n-  _Node* _M_insert_after(_Node_base* __pos) {\n-    return (_Node*) (__slist_make_link(__pos, _M_create_node()));\n-  }\n-\n-  void _M_insert_after_fill(_Node_base* __pos,\n-                            size_type __n, const value_type& __x) {\n-    for (size_type __i = 0; __i < __n; ++__i)\n-      __pos = __slist_make_link(__pos, _M_create_node(__x));\n-  }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-\n-  // Check whether it's an integral type.  If so, it's not an iterator.\n-  template <class _InIter>\n-  void _M_insert_after_range(_Node_base* __pos, \n-                             _InIter __first, _InIter __last) {\n-    typedef typename _Is_integer<_InIter>::_Integral _Integral;\n-    _M_insert_after_range(__pos, __first, __last, _Integral());\n-  }\n-\n-  template <class _Integer>\n-  void _M_insert_after_range(_Node_base* __pos, _Integer __n, _Integer __x,\n-                             __true_type) {\n-    _M_insert_after_fill(__pos, __n, __x);\n-  }\n-\n-  template <class _InIter>\n-  void _M_insert_after_range(_Node_base* __pos,\n-                             _InIter __first, _InIter __last,\n-                             __false_type) {\n-    while (__first != __last) {\n-      __pos = __slist_make_link(__pos, _M_create_node(*__first));\n-      ++__first;\n-    }\n-  }\n-\n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-  void _M_insert_after_range(_Node_base* __pos,\n-                             const_iterator __first, const_iterator __last) {\n-    while (__first != __last) {\n-      __pos = __slist_make_link(__pos, _M_create_node(*__first));\n-      ++__first;\n-    }\n-  }\n-  void _M_insert_after_range(_Node_base* __pos,\n-                             const value_type* __first,\n-                             const value_type* __last) {\n-    while (__first != __last) {\n-      __pos = __slist_make_link(__pos, _M_create_node(*__first));\n-      ++__first;\n-    }\n-  }\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-public:\n-\n-  iterator insert_after(iterator __pos, const value_type& __x) {\n-    return iterator(_M_insert_after(__pos._M_node, __x));\n-  }\n-\n-  iterator insert_after(iterator __pos) {\n-    return insert_after(__pos, value_type());\n-  }\n-\n-  void insert_after(iterator __pos, size_type __n, const value_type& __x) {\n-    _M_insert_after_fill(__pos._M_node, __n, __x);\n-  }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-\n-  // We don't need any dispatching tricks here, because _M_insert_after_range\n-  // already does them.\n-  template <class _InIter>\n-  void insert_after(iterator __pos, _InIter __first, _InIter __last) {\n-    _M_insert_after_range(__pos._M_node, __first, __last);\n-  }\n-\n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-  void insert_after(iterator __pos,\n-                    const_iterator __first, const_iterator __last) {\n-    _M_insert_after_range(__pos._M_node, __first, __last);\n-  }\n-  void insert_after(iterator __pos,\n-                    const value_type* __first, const value_type* __last) {\n-    _M_insert_after_range(__pos._M_node, __first, __last);\n-  }\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  iterator insert(iterator __pos, const value_type& __x) {\n-    return iterator(_M_insert_after(__slist_previous(&this->_M_head,\n-                                                     __pos._M_node),\n-                    __x));\n-  }\n-\n-  iterator insert(iterator __pos) {\n-    return iterator(_M_insert_after(__slist_previous(&this->_M_head,\n-                                                     __pos._M_node),\n-                                    value_type()));\n-  }\n-\n-  void insert(iterator __pos, size_type __n, const value_type& __x) {\n-    _M_insert_after_fill(__slist_previous(&this->_M_head, __pos._M_node),\n-                         __n, __x);\n-  } \n-    \n-#ifdef __STL_MEMBER_TEMPLATES\n-\n-  // We don't need any dispatching tricks here, because _M_insert_after_range\n-  // already does them.\n-  template <class _InIter>\n-  void insert(iterator __pos, _InIter __first, _InIter __last) {\n-    _M_insert_after_range(__slist_previous(&this->_M_head, __pos._M_node), \n-                          __first, __last);\n-  }\n-\n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-  void insert(iterator __pos, const_iterator __first, const_iterator __last) {\n-    _M_insert_after_range(__slist_previous(&this->_M_head, __pos._M_node), \n-                          __first, __last);\n-  }\n-  void insert(iterator __pos, const value_type* __first, \n-                              const value_type* __last) {\n-    _M_insert_after_range(__slist_previous(&this->_M_head, __pos._M_node), \n-                          __first, __last);\n-  }\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-\n-public:\n-  iterator erase_after(iterator __pos) {\n-    return iterator((_Node*) this->_M_erase_after(__pos._M_node));\n-  }\n-  iterator erase_after(iterator __before_first, iterator __last) {\n-    return iterator((_Node*) this->_M_erase_after(__before_first._M_node, \n-                                                  __last._M_node));\n-  } \n-\n-  iterator erase(iterator __pos) {\n-    return (_Node*) this->_M_erase_after(__slist_previous(&this->_M_head, \n-                                                          __pos._M_node));\n-  }\n-  iterator erase(iterator __first, iterator __last) {\n-    return (_Node*) this->_M_erase_after(\n-      __slist_previous(&this->_M_head, __first._M_node), __last._M_node);\n-  }\n-\n-  void resize(size_type new_size, const _Tp& __x);\n-  void resize(size_type new_size) { resize(new_size, _Tp()); }\n-  void clear() { this->_M_erase_after(&this->_M_head, 0); }\n-\n-public:\n-  // Moves the range [__before_first + 1, __before_last + 1) to *this,\n-  //  inserting it immediately after __pos.  This is constant time.\n-  void splice_after(iterator __pos, \n-                    iterator __before_first, iterator __before_last)\n-  {\n-    if (__before_first != __before_last) \n-      __slist_splice_after(__pos._M_node, __before_first._M_node, \n-                           __before_last._M_node);\n-  }\n-\n-  // Moves the element that follows __prev to *this, inserting it immediately\n-  //  after __pos.  This is constant time.\n-  void splice_after(iterator __pos, iterator __prev)\n-  {\n-    __slist_splice_after(__pos._M_node,\n-                         __prev._M_node, __prev._M_node->_M_next);\n-  }\n-\n-\n-  // Removes all of the elements from the list __x to *this, inserting\n-  // them immediately after __pos.  __x must not be *this.  Complexity:\n-  // linear in __x.size().\n-  void splice_after(iterator __pos, slist& __x)\n-  {\n-    __slist_splice_after(__pos._M_node, &__x._M_head);\n-  }\n-\n-  // Linear in distance(begin(), __pos), and linear in __x.size().\n-  void splice(iterator __pos, slist& __x) {\n-    if (__x._M_head._M_next)\n-      __slist_splice_after(__slist_previous(&this->_M_head, __pos._M_node),\n-                           &__x._M_head, __slist_previous(&__x._M_head, 0));\n-  }\n-\n-  // Linear in distance(begin(), __pos), and in distance(__x.begin(), __i).\n-  void splice(iterator __pos, slist& __x, iterator __i) {\n-    __slist_splice_after(__slist_previous(&this->_M_head, __pos._M_node),\n-                         __slist_previous(&__x._M_head, __i._M_node),\n-                         __i._M_node);\n-  }\n-\n-  // Linear in distance(begin(), __pos), in distance(__x.begin(), __first),\n-  // and in distance(__first, __last).\n-  void splice(iterator __pos, slist& __x, iterator __first, iterator __last)\n-  {\n-    if (__first != __last)\n-      __slist_splice_after(__slist_previous(&this->_M_head, __pos._M_node),\n-                           __slist_previous(&__x._M_head, __first._M_node),\n-                           __slist_previous(__first._M_node, __last._M_node));\n-  }\n-\n-public:\n-  void reverse() { \n-    if (this->_M_head._M_next)\n-      this->_M_head._M_next = __slist_reverse(this->_M_head._M_next);\n-  }\n-\n-  void remove(const _Tp& __val); \n-  void unique(); \n-  void merge(slist& __x);\n-  void sort();     \n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class _Predicate> \n-  void remove_if(_Predicate __pred);\n-\n-  template <class _BinaryPredicate> \n-  void unique(_BinaryPredicate __pred); \n-\n-  template <class _StrictWeakOrdering> \n-  void merge(slist&, _StrictWeakOrdering);\n-\n-  template <class _StrictWeakOrdering> \n-  void sort(_StrictWeakOrdering __comp); \n-#endif /* __STL_MEMBER_TEMPLATES */\n-};\n-\n-template <class _Tp, class _Alloc>\n-slist<_Tp,_Alloc>& slist<_Tp,_Alloc>::operator=(const slist<_Tp,_Alloc>& __x)\n-{\n-  if (&__x != this) {\n-    _Node_base* __p1 = &this->_M_head;\n-    _Node* __n1 = (_Node*) this->_M_head._M_next;\n-    const _Node* __n2 = (const _Node*) __x._M_head._M_next;\n-    while (__n1 && __n2) {\n-      __n1->_M_data = __n2->_M_data;\n-      __p1 = __n1;\n-      __n1 = (_Node*) __n1->_M_next;\n-      __n2 = (const _Node*) __n2->_M_next;\n-    }\n-    if (__n2 == 0)\n-      this->_M_erase_after(__p1, 0);\n-    else\n-      _M_insert_after_range(__p1, const_iterator((_Node*)__n2), \n-                                  const_iterator(0));\n-  }\n-  return *this;\n-}\n-\n-template <class _Tp, class _Alloc>\n-void slist<_Tp, _Alloc>::_M_fill_assign(size_type __n, const _Tp& __val) {\n-  _Node_base* __prev = &this->_M_head;\n-  _Node* __node = (_Node*) this->_M_head._M_next;\n-  for ( ; __node != 0 && __n > 0 ; --__n) {\n-    __node->_M_data = __val;\n-    __prev = __node;\n-    __node = (_Node*) __node->_M_next;\n-  }\n-  if (__n > 0)\n-    _M_insert_after_fill(__prev, __n, __val);\n-  else\n-    this->_M_erase_after(__prev, 0);\n-}\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-\n-template <class _Tp, class _Alloc> template <class _InputIter>\n-void\n-slist<_Tp, _Alloc>::_M_assign_dispatch(_InputIter __first, _InputIter __last,\n-                                       __false_type)\n-{\n-  _Node_base* __prev = &this->_M_head;\n-  _Node* __node = (_Node*) this->_M_head._M_next;\n-  while (__node != 0 && __first != __last) {\n-    __node->_M_data = *__first;\n-    __prev = __node;\n-    __node = (_Node*) __node->_M_next;\n-    ++__first;\n-  }\n-  if (__first != __last)\n-    _M_insert_after_range(__prev, __first, __last);\n-  else\n-    this->_M_erase_after(__prev, 0);\n-}\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-template <class _Tp, class _Alloc>\n-inline bool \n-operator==(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2)\n-{\n-  typedef typename slist<_Tp,_Alloc>::const_iterator const_iterator;\n-  const_iterator __end1 = _SL1.end();\n-  const_iterator __end2 = _SL2.end();\n-\n-  const_iterator __i1 = _SL1.begin();\n-  const_iterator __i2 = _SL2.begin();\n-  while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2) {\n-    ++__i1;\n-    ++__i2;\n-  }\n-  return __i1 == __end1 && __i2 == __end2;\n-}\n-\n-\n-template <class _Tp, class _Alloc>\n-inline bool\n-operator<(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2)\n-{\n-  return lexicographical_compare(_SL1.begin(), _SL1.end(), \n-                                 _SL2.begin(), _SL2.end());\n-}\n-\n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n-template <class _Tp, class _Alloc>\n-inline bool \n-operator!=(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {\n-  return !(_SL1 == _SL2);\n-}\n-\n-template <class _Tp, class _Alloc>\n-inline bool \n-operator>(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {\n-  return _SL2 < _SL1;\n-}\n-\n-template <class _Tp, class _Alloc>\n-inline bool \n-operator<=(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {\n-  return !(_SL2 < _SL1);\n-}\n-\n-template <class _Tp, class _Alloc>\n-inline bool \n-operator>=(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {\n-  return !(_SL1 < _SL2);\n-}\n-\n-template <class _Tp, class _Alloc>\n-inline void swap(slist<_Tp,_Alloc>& __x, slist<_Tp,_Alloc>& __y) {\n-  __x.swap(__y);\n-}\n-\n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-\n-template <class _Tp, class _Alloc>\n-void slist<_Tp,_Alloc>::resize(size_type __len, const _Tp& __x)\n-{\n-  _Node_base* __cur = &this->_M_head;\n-  while (__cur->_M_next != 0 && __len > 0) {\n-    --__len;\n-    __cur = __cur->_M_next;\n-  }\n-  if (__cur->_M_next) \n-    this->_M_erase_after(__cur, 0);\n-  else\n-    _M_insert_after_fill(__cur, __len, __x);\n-}\n-\n-template <class _Tp, class _Alloc>\n-void slist<_Tp,_Alloc>::remove(const _Tp& __val)\n-{\n-  _Node_base* __cur = &this->_M_head;\n-  while (__cur && __cur->_M_next) {\n-    if (((_Node*) __cur->_M_next)->_M_data == __val)\n-      this->_M_erase_after(__cur);\n-    else\n-      __cur = __cur->_M_next;\n-  }\n-}\n-\n-template <class _Tp, class _Alloc> \n-void slist<_Tp,_Alloc>::unique()\n-{\n-  _Node_base* __cur = this->_M_head._M_next;\n-  if (__cur) {\n-    while (__cur->_M_next) {\n-      if (((_Node*)__cur)->_M_data == \n-          ((_Node*)(__cur->_M_next))->_M_data)\n-        this->_M_erase_after(__cur);\n-      else\n-        __cur = __cur->_M_next;\n-    }\n-  }\n-}\n-\n-template <class _Tp, class _Alloc>\n-void slist<_Tp,_Alloc>::merge(slist<_Tp,_Alloc>& __x)\n-{\n-  _Node_base* __n1 = &this->_M_head;\n-  while (__n1->_M_next && __x._M_head._M_next) {\n-    if (((_Node*) __x._M_head._M_next)->_M_data < \n-        ((_Node*)       __n1->_M_next)->_M_data) \n-      __slist_splice_after(__n1, &__x._M_head, __x._M_head._M_next);\n-    __n1 = __n1->_M_next;\n-  }\n-  if (__x._M_head._M_next) {\n-    __n1->_M_next = __x._M_head._M_next;\n-    __x._M_head._M_next = 0;\n-  }\n-}\n-\n-template <class _Tp, class _Alloc>\n-void slist<_Tp,_Alloc>::sort()\n-{\n-  if (this->_M_head._M_next && this->_M_head._M_next->_M_next) {\n-    slist __carry;\n-    slist __counter[64];\n-    int __fill = 0;\n-    while (!empty()) {\n-      __slist_splice_after(&__carry._M_head,\n-                           &this->_M_head, this->_M_head._M_next);\n-      int __i = 0;\n-      while (__i < __fill && !__counter[__i].empty()) {\n-        __counter[__i].merge(__carry);\n-        __carry.swap(__counter[__i]);\n-        ++__i;\n-      }\n-      __carry.swap(__counter[__i]);\n-      if (__i == __fill)\n-        ++__fill;\n-    }\n-\n-    for (int __i = 1; __i < __fill; ++__i)\n-      __counter[__i].merge(__counter[__i-1]);\n-    this->swap(__counter[__fill-1]);\n-  }\n-}\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-\n-template <class _Tp, class _Alloc> \n-template <class _Predicate>\n-void slist<_Tp,_Alloc>::remove_if(_Predicate __pred)\n-{\n-  _Node_base* __cur = &this->_M_head;\n-  while (__cur->_M_next) {\n-    if (__pred(((_Node*) __cur->_M_next)->_M_data))\n-      this->_M_erase_after(__cur);\n-    else\n-      __cur = __cur->_M_next;\n-  }\n-}\n-\n-template <class _Tp, class _Alloc> template <class _BinaryPredicate> \n-void slist<_Tp,_Alloc>::unique(_BinaryPredicate __pred)\n-{\n-  _Node* __cur = (_Node*) this->_M_head._M_next;\n-  if (__cur) {\n-    while (__cur->_M_next) {\n-      if (__pred(((_Node*)__cur)->_M_data, \n-                 ((_Node*)(__cur->_M_next))->_M_data))\n-        this->_M_erase_after(__cur);\n-      else\n-        __cur = (_Node*) __cur->_M_next;\n-    }\n-  }\n-}\n-\n-template <class _Tp, class _Alloc> template <class _StrictWeakOrdering>\n-void slist<_Tp,_Alloc>::merge(slist<_Tp,_Alloc>& __x,\n-                              _StrictWeakOrdering __comp)\n-{\n-  _Node_base* __n1 = &this->_M_head;\n-  while (__n1->_M_next && __x._M_head._M_next) {\n-    if (__comp(((_Node*) __x._M_head._M_next)->_M_data,\n-               ((_Node*)       __n1->_M_next)->_M_data))\n-      __slist_splice_after(__n1, &__x._M_head, __x._M_head._M_next);\n-    __n1 = __n1->_M_next;\n-  }\n-  if (__x._M_head._M_next) {\n-    __n1->_M_next = __x._M_head._M_next;\n-    __x._M_head._M_next = 0;\n-  }\n-}\n-\n-template <class _Tp, class _Alloc> template <class _StrictWeakOrdering> \n-void slist<_Tp,_Alloc>::sort(_StrictWeakOrdering __comp)\n-{\n-  if (this->_M_head._M_next && this->_M_head._M_next->_M_next) {\n-    slist __carry;\n-    slist __counter[64];\n-    int __fill = 0;\n-    while (!empty()) {\n-      __slist_splice_after(&__carry._M_head,\n-                           &this->_M_head, this->_M_head._M_next);\n-      int __i = 0;\n-      while (__i < __fill && !__counter[__i].empty()) {\n-        __counter[__i].merge(__carry, __comp);\n-        __carry.swap(__counter[__i]);\n-        ++__i;\n-      }\n-      __carry.swap(__counter[__i]);\n-      if (__i == __fill)\n-        ++__fill;\n-    }\n-\n-    for (int __i = 1; __i < __fill; ++__i)\n-      __counter[__i].merge(__counter[__i-1], __comp);\n-    this->swap(__counter[__fill-1]);\n-  }\n-}\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-// Specialization of insert_iterator so that insertions will be constant\n-// time rather than linear time.\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class _Tp, class _Alloc>\n-class insert_iterator<slist<_Tp, _Alloc> > {\n-protected:\n-  typedef slist<_Tp, _Alloc> _Container;\n-  _Container* container;\n-  typename _Container::iterator iter;\n-public:\n-  typedef _Container          container_type;\n-  typedef output_iterator_tag iterator_category;\n-  typedef void                value_type;\n-  typedef void                difference_type;\n-  typedef void                pointer;\n-  typedef void                reference;\n-\n-  insert_iterator(_Container& __x, typename _Container::iterator __i) \n-    : container(&__x) {\n-    if (__i == __x.begin())\n-      iter = __x.before_begin();\n-    else\n-      iter = __x.previous(__i);\n-  }\n-\n-  insert_iterator<_Container>&\n-  operator=(const typename _Container::value_type& __value) { \n-    iter = container->insert_after(iter, __value);\n-    return *this;\n-  }\n-  insert_iterator<_Container>& operator*() { return *this; }\n-  insert_iterator<_Container>& operator++() { return *this; }\n-  insert_iterator<_Container>& operator++(int) { return *this; }\n-};\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#pragma reset woff 1375\n-#endif\n-\n-__STL_END_NAMESPACE \n-\n-#endif /* __SGI_STL_INTERNAL_SLIST_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "5e64f3889c85eb0ca1f0a5e875d3410bf146b35e", "filename": "libstdc++-v3/ext/stl_bvector.h", "status": "removed", "additions": 0, "deletions": 896, "changes": 896, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fstl_bvector.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,896 +0,0 @@\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996-1999\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-/* NOTE: This is an internal header file, included by other STL headers.\n- *   You should not attempt to use it directly.\n- */\n-\n-#ifndef __SGI_STL_INTERNAL_BVECTOR_H\n-#define __SGI_STL_INTERNAL_BVECTOR_H\n-\n-__STL_BEGIN_NAMESPACE \n-\n-static const int __WORD_BIT = int(CHAR_BIT*sizeof(unsigned int));\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#pragma set woff 1375\n-#endif\n-\n-struct _Bit_reference {\n-  unsigned int* _M_p;\n-  unsigned int _M_mask;\n-  _Bit_reference(unsigned int* __x, unsigned int __y) \n-    : _M_p(__x), _M_mask(__y) {}\n-\n-public:\n-  _Bit_reference() : _M_p(0), _M_mask(0) {}\n-  operator bool() const { return !(!(*_M_p & _M_mask)); }\n-  _Bit_reference& operator=(bool __x)\n-  {\n-    if (__x)  *_M_p |= _M_mask;\n-    else      *_M_p &= ~_M_mask;\n-    return *this;\n-  }\n-  _Bit_reference& operator=(const _Bit_reference& __x) \n-    { return *this = bool(__x); }\n-  bool operator==(const _Bit_reference& __x) const\n-    { return bool(*this) == bool(__x); }\n-  bool operator<(const _Bit_reference& __x) const {\n-    return !bool(*this) && bool(__x);\n-  }\n-  void flip() { *_M_p ^= _M_mask; }\n-};\n-\n-inline void swap(_Bit_reference __x, _Bit_reference __y)\n-{\n-  bool __tmp = __x;\n-  __x = __y;\n-  __y = __tmp;\n-}\n-\n-struct _Bit_iterator_base : public random_access_iterator<bool, ptrdiff_t> \n-{\n-  unsigned int* _M_p;\n-  unsigned int _M_offset;\n-\n-  _Bit_iterator_base(unsigned int* __x, unsigned int __y)\n-    : _M_p(__x), _M_offset(__y) {}\n-\n-  void _M_bump_up() {\n-    if (_M_offset++ == __WORD_BIT - 1) {\n-      _M_offset = 0;\n-      ++_M_p;\n-    }\n-  }\n-  void _M_bump_down() {\n-    if (_M_offset-- == 0) {\n-      _M_offset = __WORD_BIT - 1;\n-      --_M_p;\n-    }\n-  }\n-\n-  void _M_incr(ptrdiff_t __i) {\n-    difference_type __n = __i + _M_offset;\n-    _M_p += __n / __WORD_BIT;\n-    __n = __n % __WORD_BIT;\n-    if (__n < 0) {\n-      _M_offset = (unsigned int) __n + __WORD_BIT;\n-      --_M_p;\n-    } else\n-      _M_offset = (unsigned int) __n;\n-  }\n-\n-  bool operator==(const _Bit_iterator_base& __i) const {\n-    return _M_p == __i._M_p && _M_offset == __i._M_offset;\n-  }\n-  bool operator<(const _Bit_iterator_base& __i) const {\n-    return _M_p < __i._M_p || (_M_p == __i._M_p && _M_offset < __i._M_offset);\n-  }\n-  bool operator!=(const _Bit_iterator_base& __i) const {\n-    return !(*this == __i);\n-  }\n-  bool operator>(const _Bit_iterator_base& __i) const {\n-    return __i < *this;\n-  }\n-  bool operator<=(const _Bit_iterator_base& __i) const {\n-    return !(__i < *this); \n-  }\n-  bool operator>=(const _Bit_iterator_base& __i) const {\n-    return !(*this < __i);\n-  }\n-};\n-\n-inline ptrdiff_t\n-operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {\n-  return __WORD_BIT * (__x._M_p - __y._M_p) + __x._M_offset - __y._M_offset;\n-}\n-\n-\n-struct _Bit_iterator : public _Bit_iterator_base\n-{\n-  typedef _Bit_reference  reference;\n-  typedef _Bit_reference* pointer;\n-  typedef _Bit_iterator   iterator;\n-\n-  _Bit_iterator() : _Bit_iterator_base(0, 0) {}\n-  _Bit_iterator(unsigned int* __x, unsigned int __y) \n-    : _Bit_iterator_base(__x, __y) {}\n-\n-  reference operator*() const { return reference(_M_p, 1U << _M_offset); }\n-  iterator& operator++() {\n-    _M_bump_up();\n-    return *this;\n-  }\n-  iterator operator++(int) {\n-    iterator __tmp = *this;\n-    _M_bump_up();\n-    return __tmp;\n-  }\n-  iterator& operator--() {\n-    _M_bump_down();\n-    return *this;\n-  }\n-  iterator operator--(int) {\n-    iterator __tmp = *this;\n-    _M_bump_down();\n-    return __tmp;\n-  }\n-  iterator& operator+=(difference_type __i) {\n-    _M_incr(__i);\n-    return *this;\n-  }\n-  iterator& operator-=(difference_type __i) {\n-    *this += -__i;\n-    return *this;\n-  }\n-  iterator operator+(difference_type __i) const {\n-    iterator __tmp = *this;\n-    return __tmp += __i;\n-  }\n-  iterator operator-(difference_type __i) const {\n-    iterator __tmp = *this;\n-    return __tmp -= __i;\n-  }\n-\n-  reference operator[](difference_type __i) { return *(*this + __i); }\n-};\n-\n-inline _Bit_iterator \n-operator+(ptrdiff_t __n, const _Bit_iterator& __x) { return __x + __n; }\n-\n-\n-struct _Bit_const_iterator : public _Bit_iterator_base\n-{\n-  typedef bool                 reference;\n-  typedef bool                 const_reference;\n-  typedef const bool*          pointer;\n-  typedef _Bit_const_iterator  const_iterator;\n-\n-  _Bit_const_iterator() : _Bit_iterator_base(0, 0) {}\n-  _Bit_const_iterator(unsigned int* __x, unsigned int __y) \n-    : _Bit_iterator_base(__x, __y) {}\n-  _Bit_const_iterator(const _Bit_iterator& __x) \n-    : _Bit_iterator_base(__x._M_p, __x._M_offset) {}\n-\n-  const_reference operator*() const {\n-    return _Bit_reference(_M_p, 1U << _M_offset);\n-  }\n-  const_iterator& operator++() {\n-    _M_bump_up();\n-    return *this;\n-  }\n-  const_iterator operator++(int) {\n-    const_iterator __tmp = *this;\n-    _M_bump_up();\n-    return __tmp;\n-  }\n-  const_iterator& operator--() {\n-    _M_bump_down();\n-    return *this;\n-  }\n-  const_iterator operator--(int) {\n-    const_iterator __tmp = *this;\n-    _M_bump_down();\n-    return __tmp;\n-  }\n-  const_iterator& operator+=(difference_type __i) {\n-    _M_incr(__i);\n-    return *this;\n-  }\n-  const_iterator& operator-=(difference_type __i) {\n-    *this += -__i;\n-    return *this;\n-  }\n-  const_iterator operator+(difference_type __i) const {\n-    const_iterator __tmp = *this;\n-    return __tmp += __i;\n-  }\n-  const_iterator operator-(difference_type __i) const {\n-    const_iterator __tmp = *this;\n-    return __tmp -= __i;\n-  }\n-  const_reference operator[](difference_type __i) { \n-    return *(*this + __i); \n-  }\n-};\n-\n-inline _Bit_const_iterator \n-operator+(ptrdiff_t __n, const _Bit_const_iterator& __x) { return __x + __n; }\n-\n-\n-// Bit-vector base class, which encapsulates the difference between\n-// old SGI-style allocators and standard-conforming allocators.\n-\n-#ifdef __STL_USE_STD_ALLOCATORS\n-\n-// Base class for ordinary allocators.\n-template <class _Allocator, bool __is_static>\n-class _Bvector_alloc_base {\n-public:\n-  typedef typename _Alloc_traits<bool, _Allocator>::allocator_type\n-          allocator_type;\n-  allocator_type get_allocator() const { return _M_data_allocator; }\n-\n-  _Bvector_alloc_base(const allocator_type& __a)\n-    : _M_data_allocator(__a), _M_start(), _M_finish(), _M_end_of_storage(0) {}\n-\n-protected:\n-  unsigned int* _M_bit_alloc(size_t __n) \n-    { return _M_data_allocator.allocate((__n + __WORD_BIT - 1)/__WORD_BIT); }\n-  void _M_deallocate() {\n-    if (_M_start._M_p)\n-      _M_data_allocator.deallocate(_M_start._M_p, \n-                                   _M_end_of_storage - _M_start._M_p);\n-  }  \n-\n-  typename _Alloc_traits<unsigned int, _Allocator>::allocator_type \n-          _M_data_allocator;\n-  _Bit_iterator _M_start;\n-  _Bit_iterator _M_finish;\n-  unsigned int* _M_end_of_storage;\n-};\n-\n-// Specialization for instanceless allocators.\n-template <class _Allocator>\n-class _Bvector_alloc_base<_Allocator, true> {\n-public:\n-  typedef typename _Alloc_traits<bool, _Allocator>::allocator_type\n-          allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-\n-  _Bvector_alloc_base(const allocator_type&)\n-    : _M_start(), _M_finish(), _M_end_of_storage(0) {}\n-\n-protected:\n-  typedef typename _Alloc_traits<unsigned int, _Allocator>::_Alloc_type\n-          _Alloc_type;\n-          \n-  unsigned int* _M_bit_alloc(size_t __n) \n-    { return _Alloc_type::allocate((__n + __WORD_BIT - 1)/__WORD_BIT); }\n-  void _M_deallocate() {\n-    if (_M_start._M_p)\n-      _Alloc_type::deallocate(_M_start._M_p,\n-                              _M_end_of_storage - _M_start._M_p);\n-  }  \n-\n-  _Bit_iterator _M_start;\n-  _Bit_iterator _M_finish;\n-  unsigned int* _M_end_of_storage;\n-};  \n-\n-template <class _Alloc>\n-class _Bvector_base\n-  : public _Bvector_alloc_base<_Alloc,\n-                               _Alloc_traits<bool, _Alloc>::_S_instanceless>\n-{\n-  typedef _Bvector_alloc_base<_Alloc,\n-                              _Alloc_traits<bool, _Alloc>::_S_instanceless>\n-          _Base;\n-public:\n-  typedef typename _Base::allocator_type allocator_type;\n-\n-  _Bvector_base(const allocator_type& __a) : _Base(__a) {}\n-  ~_Bvector_base() { _Base::_M_deallocate(); }\n-};\n-\n-#else /* __STL_USE_STD_ALLOCATORS */\n-\n-template <class _Alloc>\n-class _Bvector_base\n-{\n-public:\n-  typedef _Alloc allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-\n-  _Bvector_base(const allocator_type&)\n-    : _M_start(), _M_finish(), _M_end_of_storage(0) {}\n-  ~_Bvector_base() { _M_deallocate(); }\n-\n-protected:\n-  typedef simple_alloc<unsigned int, _Alloc> _Alloc_type;\n-  \n-  unsigned int* _M_bit_alloc(size_t __n) \n-    { return _Alloc_type::allocate((__n + __WORD_BIT - 1)/__WORD_BIT); }\n-  void _M_deallocate() {\n-    if (_M_start._M_p)\n-      _Alloc_type::deallocate(_M_start._M_p,\n-                              _M_end_of_storage - _M_start._M_p);\n-  }\n-\n-  _Bit_iterator _M_start;\n-  _Bit_iterator _M_finish;\n-  unsigned int* _M_end_of_storage;  \n-};\n-\n-#endif /* __STL_USE_STD_ALLOCATORS */\n-\n-// The next few lines are confusing.  What we're doing is declaring a\n-//  partial specialization of vector<T, Alloc> if we have the necessary\n-//  compiler support.  Otherwise, we define a class bit_vector which uses\n-//  the default allocator. \n-\n-#if defined(__STL_CLASS_PARTIAL_SPECIALIZATION) && !defined(__STL_NO_BOOL)\n-#  define __SGI_STL_VECBOOL_TEMPLATE\n-#  define __BVECTOR           vector<bool, _Alloc>\n-#  define __VECTOR            vector\n-#  define __BVECTOR_BASE      _Bvector_base<_Alloc>\n-#  define __BVECTOR_TMPL_LIST template <class _Alloc>\n-   __STL_END_NAMESPACE\n-#  include <bits/stl_vector.h>\n-   __STL_BEGIN_NAMESPACE\n-#else  /* __STL_CLASS_PARTIAL_SPECIALIZATION && !__STL_NO_BOOL */\n-#  undef  __SGI_STL_VECBOOL_TEMPLATE\n-#  define __BVECTOR           bit_vector\n-#  define __VECTOR            bit_vector\n-#  define __BVECTOR_BASE      _Bvector_base<__STL_DEFAULT_ALLOCATOR(bool) >\n-#  define __BVECTOR_TMPL_LIST\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION && !__STL_NO_BOOL */\n-\n-\n-__BVECTOR_TMPL_LIST \n-class __BVECTOR : public __BVECTOR_BASE \n-{\n-public:\n-  typedef bool value_type;\n-  typedef size_t size_type;\n-  typedef ptrdiff_t difference_type; \n-  typedef _Bit_reference reference;\n-  typedef bool const_reference;\n-  typedef _Bit_reference* pointer;\n-  typedef const bool* const_pointer;\n-\n-  typedef _Bit_iterator                iterator;\n-  typedef _Bit_const_iterator          const_iterator;\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-  typedef reverse_iterator<const_iterator> const_reverse_iterator;\n-  typedef reverse_iterator<iterator> reverse_iterator;\n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-  typedef reverse_iterator<const_iterator, value_type, const_reference, \n-                           difference_type> const_reverse_iterator;\n-  typedef reverse_iterator<iterator, value_type, reference, difference_type>\n-          reverse_iterator;\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-  typedef typename __BVECTOR_BASE::allocator_type allocator_type;\n-  allocator_type get_allocator() const {\n-    return __BVECTOR_BASE::get_allocator();\n-  }\n-\n-protected:\n-#ifdef __STL_USE_NAMESPACES  \n-  using __BVECTOR_BASE::_M_bit_alloc;\n-  using __BVECTOR_BASE::_M_deallocate;\n-  using __BVECTOR_BASE::_M_start;\n-  using __BVECTOR_BASE::_M_finish;\n-  using __BVECTOR_BASE::_M_end_of_storage;\n-#endif /* __STL_USE_NAMESPACES */\n-\n-protected:\n-  void _M_initialize(size_type __n) {\n-    unsigned int* __q = _M_bit_alloc(__n);\n-    _M_end_of_storage = __q + (__n + __WORD_BIT - 1)/__WORD_BIT;\n-    _M_start = iterator(__q, 0);\n-    _M_finish = _M_start + difference_type(__n);\n-  }\n-  void _M_insert_aux(iterator __position, bool __x) {\n-    if (_M_finish._M_p != _M_end_of_storage) {\n-      copy_backward(__position, _M_finish, _M_finish + 1);\n-      *__position = __x;\n-      ++_M_finish;\n-    }\n-    else {\n-      size_type __len = size() ? 2 * size() : __WORD_BIT;\n-      unsigned int* __q = _M_bit_alloc(__len);\n-      iterator __i = copy(begin(), __position, iterator(__q, 0));\n-      *__i++ = __x;\n-      _M_finish = copy(__position, end(), __i);\n-      _M_deallocate();\n-      _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n-      _M_start = iterator(__q, 0);\n-    }\n-  }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class _InputIterator>\n-  void _M_initialize_range(_InputIterator __first, _InputIterator __last,\n-                           input_iterator_tag) {\n-    _M_start = iterator();\n-    _M_finish = iterator();\n-    _M_end_of_storage = 0;\n-    for ( ; __first != __last; ++__first) \n-      push_back(*__first);\n-  }\n-\n-  template <class _ForwardIterator>\n-  void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,\n-                           forward_iterator_tag) {\n-    size_type __n = 0;\n-    distance(__first, __last, __n);\n-    _M_initialize(__n);\n-    copy(__first, __last, _M_start);\n-  }\n-\n-  template <class _InputIterator>\n-  void _M_insert_range(iterator __pos,\n-                       _InputIterator __first, _InputIterator __last,\n-                       input_iterator_tag) {\n-    for ( ; __first != __last; ++__first) {\n-      __pos = insert(__pos, *__first);\n-      ++__pos;\n-    }\n-  }\n-\n-  template <class _ForwardIterator>\n-  void _M_insert_range(iterator __position,\n-                       _ForwardIterator __first, _ForwardIterator __last,\n-                       forward_iterator_tag) {\n-    if (__first != __last) {\n-      size_type __n = 0;\n-      distance(__first, __last, __n);\n-      if (capacity() - size() >= __n) {\n-        copy_backward(__position, end(), _M_finish + difference_type(__n));\n-        copy(__first, __last, __position);\n-        _M_finish += difference_type(__n);\n-      }\n-      else {\n-        size_type __len = size() + max(size(), __n);\n-        unsigned int* __q = _M_bit_alloc(__len);\n-        iterator __i = copy(begin(), __position, iterator(__q, 0));\n-        __i = copy(__first, __last, __i);\n-        _M_finish = copy(__position, end(), __i);\n-        _M_deallocate();\n-        _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n-        _M_start = iterator(__q, 0);\n-      }\n-    }\n-  }      \n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-public:\n-  iterator begin() { return _M_start; }\n-  const_iterator begin() const { return _M_start; }\n-  iterator end() { return _M_finish; }\n-  const_iterator end() const { return _M_finish; }\n-\n-  reverse_iterator rbegin() { return reverse_iterator(end()); }\n-  const_reverse_iterator rbegin() const { \n-    return const_reverse_iterator(end()); \n-  }\n-  reverse_iterator rend() { return reverse_iterator(begin()); }\n-  const_reverse_iterator rend() const { \n-    return const_reverse_iterator(begin()); \n-  }\n-\n-  size_type size() const { return size_type(end() - begin()); }\n-  size_type max_size() const { return size_type(-1); }\n-  size_type capacity() const {\n-    return size_type(const_iterator(_M_end_of_storage, 0) - begin());\n-  }\n-  bool empty() const { return begin() == end(); }\n-\n-  reference operator[](size_type __n)\n-    { return *(begin() + difference_type(__n)); }\n-  const_reference operator[](size_type __n) const\n-    { return *(begin() + difference_type(__n)); }\n-\n-#ifdef __STL_THROW_RANGE_ERRORS\n-  void _M_range_check(size_type __n) const {\n-    if (__n >= this->size())\n-      __stl_throw_range_error(\"vector<bool>\");\n-  }\n-\n-  reference at(size_type __n)\n-    { _M_range_check(__n); return (*this)[__n]; }\n-  const_reference at(size_type __n) const\n-    { _M_range_check(__n); return (*this)[__n]; }\n-#endif /* __STL_THROW_RANGE_ERRORS */\n-\n-  explicit __VECTOR(const allocator_type& __a = allocator_type())\n-    : __BVECTOR_BASE(__a) {}\n-\n-  __VECTOR(size_type __n, bool __value,\n-            const allocator_type& __a = allocator_type())\n-    : __BVECTOR_BASE(__a)\n-  {\n-    _M_initialize(__n);\n-    fill(_M_start._M_p, _M_end_of_storage, __value ? ~0 : 0);\n-  }\n-\n-  explicit __VECTOR(size_type __n)\n-    : __BVECTOR_BASE(allocator_type())\n-  {\n-    _M_initialize(__n);\n-    fill(_M_start._M_p, _M_end_of_storage, 0);\n-  }\n-\n-  __VECTOR(const __VECTOR& __x) : __BVECTOR_BASE(__x.get_allocator()) {\n-    _M_initialize(__x.size());\n-    copy(__x.begin(), __x.end(), _M_start);\n-  }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-\n-  // Check whether it's an integral type.  If so, it's not an iterator.\n-\n-  template <class _Integer>\n-  void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type) {\n-    _M_initialize(__n);\n-    fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);\n-  }\n-\n-  template <class _InputIterator>\n-  void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n-                              __false_type) {\n-    _M_initialize_range(__first, __last, __ITERATOR_CATEGORY(__first));\n-  }\n-\n-  template <class _InputIterator>\n-  __VECTOR(_InputIterator __first, _InputIterator __last,\n-           const allocator_type& __a = allocator_type())\n-    : __BVECTOR_BASE(__a)\n-  {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_initialize_dispatch(__first, __last, _Integral());\n-  }\n-    \n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-  __VECTOR(const_iterator __first, const_iterator __last,\n-           const allocator_type& __a = allocator_type())\n-    : __BVECTOR_BASE(__a)\n-  {\n-    size_type __n = 0;\n-    distance(__first, __last, __n);\n-    _M_initialize(__n);\n-    copy(__first, __last, _M_start);\n-  }\n-  __VECTOR(const bool* __first, const bool* __last,\n-           const allocator_type& __a = allocator_type())\n-    : __BVECTOR_BASE(__a)\n-  {\n-    size_type __n = 0;\n-    distance(__first, __last, __n);\n-    _M_initialize(__n);\n-    copy(__first, __last, _M_start);\n-  }\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  ~__VECTOR() { }\n-\n-  __VECTOR& operator=(const __VECTOR& __x) {\n-    if (&__x == this) return *this;\n-    if (__x.size() > capacity()) {\n-      _M_deallocate();\n-      _M_initialize(__x.size());\n-    }\n-    copy(__x.begin(), __x.end(), begin());\n-    _M_finish = begin() + difference_type(__x.size());\n-    return *this;\n-  }\n-\n-  // assign(), a generalized assignment member function.  Two\n-  // versions: one that takes a count, and one that takes a range.\n-  // The range version is a member template, so we dispatch on whether\n-  // or not the type is an integer.\n-\n-  void _M_fill_assign(size_t __n, bool __x) {\n-    if (__n > size()) {\n-      fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);\n-      insert(end(), __n - size(), __x);\n-    }\n-    else {\n-      erase(begin() + __n, end());\n-      fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);\n-    }\n-  }\n-\n-  void assign(size_t __n, bool __x) { _M_fill_assign(__n, __x); }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-\n-  template <class _InputIterator>\n-  void assign(_InputIterator __first, _InputIterator __last) {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_assign_dispatch(__first, __last, _Integral());\n-  }\n-\n-  template <class _Integer>\n-  void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n-    { _M_fill_assign((size_t) __n, (bool) __val); }\n-\n-  template <class _InputIter>\n-  void _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)\n-    { _M_assign_aux(__first, __last, __ITERATOR_CATEGORY(__first)); }\n-\n-  template <class _InputIterator>\n-  void _M_assign_aux(_InputIterator __first, _InputIterator __last,\n-                     input_iterator_tag) {\n-    iterator __cur = begin();\n-    for ( ; __first != __last && __cur != end(); ++__cur, ++__first)\n-      *__cur = *__first;\n-    if (__first == __last)\n-      erase(__cur, end());\n-    else\n-      insert(end(), __first, __last);\n-  }\n-\n-  template <class _ForwardIterator>\n-  void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n-                     forward_iterator_tag) {\n-    size_type __len = 0;\n-    distance(__first, __last, __len);\n-    if (__len < size())\n-      erase(copy(__first, __last, begin()), end());\n-    else {\n-      _ForwardIterator __mid = __first;\n-      advance(__mid, size());\n-      copy(__first, __mid, begin());\n-      insert(end(), __mid, __last);\n-    }\n-  }    \n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  void reserve(size_type __n) {\n-    if (capacity() < __n) {\n-      unsigned int* __q = _M_bit_alloc(__n);\n-      _M_finish = copy(begin(), end(), iterator(__q, 0));\n-      _M_deallocate();\n-      _M_start = iterator(__q, 0);\n-      _M_end_of_storage = __q + (__n + __WORD_BIT - 1)/__WORD_BIT;\n-    }\n-  }\n-\n-  reference front() { return *begin(); }\n-  const_reference front() const { return *begin(); }\n-  reference back() { return *(end() - 1); }\n-  const_reference back() const { return *(end() - 1); }\n-  void push_back(bool __x) {\n-    if (_M_finish._M_p != _M_end_of_storage)\n-      *_M_finish++ = __x;\n-    else\n-      _M_insert_aux(end(), __x);\n-  }\n-  void swap(__BVECTOR& __x) {\n-    __STD::swap(_M_start, __x._M_start);\n-    __STD::swap(_M_finish, __x._M_finish);\n-    __STD::swap(_M_end_of_storage, __x._M_end_of_storage);\n-  }\n-  iterator insert(iterator __position, bool __x = bool()) {\n-    difference_type __n = __position - begin();\n-    if (_M_finish._M_p != _M_end_of_storage && __position == end())\n-      *_M_finish++ = __x;\n-    else\n-      _M_insert_aux(__position, __x);\n-    return begin() + __n;\n-  }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  // Check whether it's an integral type.  If so, it's not an iterator.\n-\n-  template <class _Integer>\n-  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n-                          __true_type) {\n-    _M_fill_insert(__pos, __n, __x);\n-  }\n-\n-  template <class _InputIterator>\n-  void _M_insert_dispatch(iterator __pos,\n-                          _InputIterator __first, _InputIterator __last,\n-                          __false_type) {\n-    _M_insert_range(__pos, __first, __last, __ITERATOR_CATEGORY(__first));\n-  }\n-\n-  template <class _InputIterator>\n-  void insert(iterator __position,\n-              _InputIterator __first, _InputIterator __last) {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_insert_dispatch(__position, __first, __last, _Integral());\n-  }\n-\n-#else /* __STL_MEMBER_TEMPLATES */\n-  void insert(iterator __position,\n-              const_iterator __first, const_iterator __last) {\n-    if (__first == __last) return;\n-    size_type __n = 0;\n-    distance(__first, __last, __n);\n-    if (capacity() - size() >= __n) {\n-      copy_backward(__position, end(), _M_finish + __n);\n-      copy(__first, __last, __position);\n-      _M_finish += __n;\n-    }\n-    else {\n-      size_type __len = size() + max(size(), __n);\n-      unsigned int* __q = _M_bit_alloc(__len);\n-      iterator __i = copy(begin(), __position, iterator(__q, 0));\n-      __i = copy(__first, __last, __i);\n-      _M_finish = copy(__position, end(), __i);\n-      _M_deallocate();\n-      _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n-      _M_start = iterator(__q, 0);\n-    }\n-  }\n-\n-  void insert(iterator __position, const bool* __first, const bool* __last) {\n-    if (__first == __last) return;\n-    size_type __n = 0;\n-    distance(__first, __last, __n);\n-    if (capacity() - size() >= __n) {\n-      copy_backward(__position, end(), _M_finish + __n);\n-      copy(__first, __last, __position);\n-      _M_finish += __n;\n-    }\n-    else {\n-      size_type __len = size() + max(size(), __n);\n-      unsigned int* __q = _M_bit_alloc(__len);\n-      iterator __i = copy(begin(), __position, iterator(__q, 0));\n-      __i = copy(__first, __last, __i);\n-      _M_finish = copy(__position, end(), __i);\n-      _M_deallocate();\n-      _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n-      _M_start = iterator(__q, 0);\n-    }\n-  }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  void _M_fill_insert(iterator __position, size_type __n, bool __x) {\n-    if (__n == 0) return;\n-    if (capacity() - size() >= __n) {\n-      copy_backward(__position, end(), _M_finish + difference_type(__n));\n-      fill(__position, __position + difference_type(__n), __x);\n-      _M_finish += difference_type(__n);\n-    }\n-    else {\n-      size_type __len = size() + max(size(), __n);\n-      unsigned int* __q = _M_bit_alloc(__len);\n-      iterator __i = copy(begin(), __position, iterator(__q, 0));\n-      fill_n(__i, __n, __x);\n-      _M_finish = copy(__position, end(), __i + difference_type(__n));\n-      _M_deallocate();\n-      _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;\n-      _M_start = iterator(__q, 0);\n-    }\n-  }\n-\n-  void insert(iterator __position, size_type __n, bool __x) {\n-    _M_fill_insert(__position, __n, __x);\n-  }\n-\n-  void pop_back() { --_M_finish; }\n-  iterator erase(iterator __position) {\n-    if (__position + 1 != end())\n-      copy(__position + 1, end(), __position);\n-      --_M_finish;\n-    return __position;\n-  }\n-  iterator erase(iterator __first, iterator __last) {\n-    _M_finish = copy(__last, end(), __first);\n-    return __first;\n-  }\n-  void resize(size_type __new_size, bool __x = bool()) {\n-    if (__new_size < size()) \n-      erase(begin() + difference_type(__new_size), end());\n-    else\n-      insert(end(), __new_size - size(), __x);\n-  }\n-  void flip() {\n-    for (unsigned int* __p = _M_start._M_p; __p != _M_end_of_storage; ++__p)\n-      *__p = ~*__p;\n-  }\n-\n-  void clear() { erase(begin(), end()); }\n-};\n-\n-#ifdef __SGI_STL_VECBOOL_TEMPLATE\n-\n-// This typedef is non-standard.  It is provided for backward compatibility.\n-typedef vector<bool, alloc> bit_vector;\n-\n-#else /* __SGI_STL_VECBOOL_TEMPLATE */\n-\n-inline void swap(bit_vector& __x, bit_vector& __y) {\n-  __x.swap(__y);\n-}\n-\n-inline bool \n-operator==(const bit_vector& __x, const bit_vector& __y)\n-{\n-  return (__x.size() == __y.size() && \n-          equal(__x.begin(), __x.end(), __y.begin()));\n-}\n-\n-inline bool \n-operator!=(const bit_vector& __x, const bit_vector& __y)\n-{\n-  return !(__x == __y);\n-}\n-\n-inline bool \n-operator<(const bit_vector& __x, const bit_vector& __y)\n-{\n-  return lexicographical_compare(__x.begin(), __x.end(), \n-                                 __y.begin(), __y.end());\n-}\n-\n-inline bool operator>(const bit_vector& __x, const bit_vector& __y)\n-{\n-  return __y < __x;\n-}\n-\n-inline bool operator<=(const bit_vector& __x, const bit_vector& __y)\n-{\n-  return !(__y < __x);\n-}\n-\n-inline bool operator>=(const bit_vector& __x, const bit_vector& __y)\n-{\n-  return !(__x < __y);\n-}\n-\n-#endif /* __SGI_STL_VECBOOL_TEMPLATE */\n-\n-#undef __SGI_STL_VECBOOL_TEMPLATE\n-#undef __BVECTOR\n-#undef __VECTOR\n-#undef __BVECTOR_BASE\n-#undef __BVECTOR_TMPL_LIST \n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#pragma reset woff 1375\n-#endif\n-\n-__STL_END_NAMESPACE \n-\n-#endif /* __SGI_STL_INTERNAL_BVECTOR_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "3144e6a07f181912a307d7eb18d13cd86fd795dc", "filename": "libstdc++-v3/ext/stl_hash_fun.h", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Fstl_hash_fun.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Fstl_hash_fun.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fstl_hash_fun.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,93 +0,0 @@\n-/*\n- * Copyright (c) 1996-1998\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- */\n-\n-/* NOTE: This is an internal header file, included by other STL headers.\n- *   You should not attempt to use it directly.\n- */\n-\n-#ifndef _CPP_BITS_STL_HASH_FUN_H\n-#define _CPP_BITS_STL_HASH_FUN_H 1\n-\n-#include <bits/std_cstddef.h>\n-\n-__STL_BEGIN_NAMESPACE\n-\n-template <class _Key> struct hash { };\n-\n-inline size_t __stl_hash_string(const char* __s)\n-{\n-  unsigned long __h = 0; \n-  for ( ; *__s; ++__s)\n-    __h = 5*__h + *__s;\n-  \n-  return size_t(__h);\n-}\n-\n-__STL_TEMPLATE_NULL struct hash<char*>\n-{\n-  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }\n-};\n-\n-__STL_TEMPLATE_NULL struct hash<const char*>\n-{\n-  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }\n-};\n-\n-__STL_TEMPLATE_NULL struct hash<char> {\n-  size_t operator()(char __x) const { return __x; }\n-};\n-__STL_TEMPLATE_NULL struct hash<unsigned char> {\n-  size_t operator()(unsigned char __x) const { return __x; }\n-};\n-__STL_TEMPLATE_NULL struct hash<signed char> {\n-  size_t operator()(unsigned char __x) const { return __x; }\n-};\n-__STL_TEMPLATE_NULL struct hash<short> {\n-  size_t operator()(short __x) const { return __x; }\n-};\n-__STL_TEMPLATE_NULL struct hash<unsigned short> {\n-  size_t operator()(unsigned short __x) const { return __x; }\n-};\n-__STL_TEMPLATE_NULL struct hash<int> {\n-  size_t operator()(int __x) const { return __x; }\n-};\n-__STL_TEMPLATE_NULL struct hash<unsigned int> {\n-  size_t operator()(unsigned int __x) const { return __x; }\n-};\n-__STL_TEMPLATE_NULL struct hash<long> {\n-  size_t operator()(long __x) const { return __x; }\n-};\n-__STL_TEMPLATE_NULL struct hash<unsigned long> {\n-  size_t operator()(unsigned long __x) const { return __x; }\n-};\n-\n-__STL_END_NAMESPACE\n-\n-#endif /* _CPP_BITS_STL_HASH_FUN_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "ab5cf5203b1c26ad0471cdea2d1a1710f4b48899", "filename": "libstdc++-v3/ext/stl_hashtable.h", "status": "removed", "additions": 0, "deletions": 1054, "changes": 1054, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Fstl_hashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Fstl_hashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fstl_hashtable.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,1054 +0,0 @@\n-/*\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- */\n-\n-/* NOTE: This is an internal header file, included by other STL headers.\n- *   You should not attempt to use it directly.\n- */\n-\n-#ifndef __SGI_STL_INTERNAL_HASHTABLE_H\n-#define __SGI_STL_INTERNAL_HASHTABLE_H\n-\n-// Hashtable class, used to implement the hashed associative containers\n-// hash_set, hash_map, hash_multiset, and hash_multimap.\n-\n-#include <bits/stl_algobase.h>\n-#include <bits/stl_alloc.h>\n-#include <bits/stl_construct.h>\n-#include <bits/stl_tempbuf.h>\n-#include <bits/stl_algo.h>\n-#include <bits/stl_uninitialized.h>\n-#include <bits/stl_function.h>\n-#include <bits/stl_vector.h>\n-#include <ext/stl_hash_fun.h>\n-\n-__STL_BEGIN_NAMESPACE\n-\n-template <class _Val>\n-struct _Hashtable_node\n-{\n-  _Hashtable_node* _M_next;\n-  _Val _M_val;\n-};  \n-\n-template <class _Val, class _Key, class _HashFcn,\n-          class _ExtractKey, class _EqualKey, class _Alloc = alloc>\n-class hashtable;\n-\n-template <class _Val, class _Key, class _HashFcn,\n-          class _ExtractKey, class _EqualKey, class _Alloc>\n-struct _Hashtable_iterator;\n-\n-template <class _Val, class _Key, class _HashFcn,\n-          class _ExtractKey, class _EqualKey, class _Alloc>\n-struct _Hashtable_const_iterator;\n-\n-template <class _Val, class _Key, class _HashFcn,\n-          class _ExtractKey, class _EqualKey, class _Alloc>\n-struct _Hashtable_iterator {\n-  typedef hashtable<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>\n-          _Hashtable;\n-  typedef _Hashtable_iterator<_Val, _Key, _HashFcn, \n-                              _ExtractKey, _EqualKey, _Alloc>\n-          iterator;\n-  typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn, \n-                                    _ExtractKey, _EqualKey, _Alloc>\n-          const_iterator;\n-  typedef _Hashtable_node<_Val> _Node;\n-\n-  typedef forward_iterator_tag iterator_category;\n-  typedef _Val value_type;\n-  typedef ptrdiff_t difference_type;\n-  typedef size_t size_type;\n-  typedef _Val& reference;\n-  typedef _Val* pointer;\n-\n-  _Node* _M_cur;\n-  _Hashtable* _M_ht;\n-\n-  _Hashtable_iterator(_Node* __n, _Hashtable* __tab) \n-    : _M_cur(__n), _M_ht(__tab) {}\n-  _Hashtable_iterator() {}\n-  reference operator*() const { return _M_cur->_M_val; }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n-  pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n-  iterator& operator++();\n-  iterator operator++(int);\n-  bool operator==(const iterator& __it) const\n-    { return _M_cur == __it._M_cur; }\n-  bool operator!=(const iterator& __it) const\n-    { return _M_cur != __it._M_cur; }\n-};\n-\n-\n-template <class _Val, class _Key, class _HashFcn,\n-          class _ExtractKey, class _EqualKey, class _Alloc>\n-struct _Hashtable_const_iterator {\n-  typedef hashtable<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>\n-          _Hashtable;\n-  typedef _Hashtable_iterator<_Val,_Key,_HashFcn, \n-                              _ExtractKey,_EqualKey,_Alloc>\n-          iterator;\n-  typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn, \n-                                    _ExtractKey, _EqualKey, _Alloc>\n-          const_iterator;\n-  typedef _Hashtable_node<_Val> _Node;\n-\n-  typedef forward_iterator_tag iterator_category;\n-  typedef _Val value_type;\n-  typedef ptrdiff_t difference_type;\n-  typedef size_t size_type;\n-  typedef const _Val& reference;\n-  typedef const _Val* pointer;\n-\n-  const _Node* _M_cur;\n-  const _Hashtable* _M_ht;\n-\n-  _Hashtable_const_iterator(const _Node* __n, const _Hashtable* __tab)\n-    : _M_cur(__n), _M_ht(__tab) {}\n-  _Hashtable_const_iterator() {}\n-  _Hashtable_const_iterator(const iterator& __it) \n-    : _M_cur(__it._M_cur), _M_ht(__it._M_ht) {}\n-  reference operator*() const { return _M_cur->_M_val; }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n-  pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n-  const_iterator& operator++();\n-  const_iterator operator++(int);\n-  bool operator==(const const_iterator& __it) const \n-    { return _M_cur == __it._M_cur; }\n-  bool operator!=(const const_iterator& __it) const \n-    { return _M_cur != __it._M_cur; }\n-};\n-\n-// Note: assumes long is at least 32 bits.\n-enum { __stl_num_primes = 28 };\n-\n-static const unsigned long __stl_prime_list[__stl_num_primes] =\n-{\n-  53ul,         97ul,         193ul,       389ul,       769ul,\n-  1543ul,       3079ul,       6151ul,      12289ul,     24593ul,\n-  49157ul,      98317ul,      196613ul,    393241ul,    786433ul,\n-  1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,\n-  50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul, \n-  1610612741ul, 3221225473ul, 4294967291ul\n-};\n-\n-inline unsigned long __stl_next_prime(unsigned long __n)\n-{\n-  const unsigned long* __first = __stl_prime_list;\n-  const unsigned long* __last = __stl_prime_list + (int)__stl_num_primes;\n-  const unsigned long* pos = lower_bound(__first, __last, __n);\n-  return pos == __last ? *(__last - 1) : *pos;\n-}\n-\n-// Forward declaration of operator==.\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-class hashtable;\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-bool operator==(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,\n-                const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2);\n-\n-\n-// Hashtables handle allocators a bit differently than other containers\n-//  do.  If we're using standard-conforming allocators, then a hashtable\n-//  unconditionally has a member variable to hold its allocator, even if\n-//  it so happens that all instances of the allocator type are identical.\n-// This is because, for hashtables, this extra storage is negligible.  \n-//  Additionally, a base class wouldn't serve any other purposes; it \n-//  wouldn't, for example, simplify the exception-handling code.\n-\n-template <class _Val, class _Key, class _HashFcn,\n-          class _ExtractKey, class _EqualKey, class _Alloc>\n-class hashtable {\n-public:\n-  typedef _Key key_type;\n-  typedef _Val value_type;\n-  typedef _HashFcn hasher;\n-  typedef _EqualKey key_equal;\n-\n-  typedef size_t            size_type;\n-  typedef ptrdiff_t         difference_type;\n-  typedef value_type*       pointer;\n-  typedef const value_type* const_pointer;\n-  typedef value_type&       reference;\n-  typedef const value_type& const_reference;\n-\n-  hasher hash_funct() const { return _M_hash; }\n-  key_equal key_eq() const { return _M_equals; }\n-\n-private:\n-  typedef _Hashtable_node<_Val> _Node;\n-\n-#ifdef __STL_USE_STD_ALLOCATORS\n-public:\n-  typedef typename _Alloc_traits<_Val,_Alloc>::allocator_type allocator_type;\n-  allocator_type get_allocator() const { return _M_node_allocator; }\n-private:\n-  typename _Alloc_traits<_Node, _Alloc>::allocator_type _M_node_allocator;\n-  _Node* _M_get_node() { return _M_node_allocator.allocate(1); }\n-  void _M_put_node(_Node* __p) { _M_node_allocator.deallocate(__p, 1); }\n-# define __HASH_ALLOC_INIT(__a) _M_node_allocator(__a), \n-#else /* __STL_USE_STD_ALLOCATORS */\n-public:\n-  typedef _Alloc allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-private:\n-  typedef simple_alloc<_Node, _Alloc> _M_node_allocator_type;\n-  _Node* _M_get_node() { return _M_node_allocator_type::allocate(1); }\n-  void _M_put_node(_Node* __p) { _M_node_allocator_type::deallocate(__p, 1); }\n-# define __HASH_ALLOC_INIT(__a)\n-#endif /* __STL_USE_STD_ALLOCATORS */\n-\n-private:\n-  hasher                _M_hash;\n-  key_equal             _M_equals;\n-  _ExtractKey           _M_get_key;\n-  vector<_Node*,_Alloc> _M_buckets;\n-  size_type             _M_num_elements;\n-\n-public:\n-  typedef _Hashtable_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>\n-          iterator;\n-  typedef _Hashtable_const_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,\n-                                    _Alloc>\n-          const_iterator;\n-\n-  friend struct\n-  _Hashtable_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>;\n-  friend struct\n-  _Hashtable_const_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>;\n-\n-public:\n-  hashtable(size_type __n,\n-            const _HashFcn&    __hf,\n-            const _EqualKey&   __eql,\n-            const _ExtractKey& __ext,\n-            const allocator_type& __a = allocator_type())\n-    : __HASH_ALLOC_INIT(__a)\n-      _M_hash(__hf),\n-      _M_equals(__eql),\n-      _M_get_key(__ext),\n-      _M_buckets(__a),\n-      _M_num_elements(0)\n-  {\n-    _M_initialize_buckets(__n);\n-  }\n-\n-  hashtable(size_type __n,\n-            const _HashFcn&    __hf,\n-            const _EqualKey&   __eql,\n-            const allocator_type& __a = allocator_type())\n-    : __HASH_ALLOC_INIT(__a)\n-      _M_hash(__hf),\n-      _M_equals(__eql),\n-      _M_get_key(_ExtractKey()),\n-      _M_buckets(__a),\n-      _M_num_elements(0)\n-  {\n-    _M_initialize_buckets(__n);\n-  }\n-\n-  hashtable(const hashtable& __ht)\n-    : __HASH_ALLOC_INIT(__ht.get_allocator())\n-      _M_hash(__ht._M_hash),\n-      _M_equals(__ht._M_equals),\n-      _M_get_key(__ht._M_get_key),\n-      _M_buckets(__ht.get_allocator()),\n-      _M_num_elements(0)\n-  {\n-    _M_copy_from(__ht);\n-  }\n-\n-#undef __HASH_ALLOC_INIT\n-\n-  hashtable& operator= (const hashtable& __ht)\n-  {\n-    if (&__ht != this) {\n-      clear();\n-      _M_hash = __ht._M_hash;\n-      _M_equals = __ht._M_equals;\n-      _M_get_key = __ht._M_get_key;\n-      _M_copy_from(__ht);\n-    }\n-    return *this;\n-  }\n-\n-  ~hashtable() { clear(); }\n-\n-  size_type size() const { return _M_num_elements; }\n-  size_type max_size() const { return size_type(-1); }\n-  bool empty() const { return size() == 0; }\n-\n-  void swap(hashtable& __ht)\n-  {\n-    __STD::swap(_M_hash, __ht._M_hash);\n-    __STD::swap(_M_equals, __ht._M_equals);\n-    __STD::swap(_M_get_key, __ht._M_get_key);\n-    _M_buckets.swap(__ht._M_buckets);\n-    __STD::swap(_M_num_elements, __ht._M_num_elements);\n-  }\n-\n-  iterator begin()\n-  { \n-    for (size_type __n = 0; __n < _M_buckets.size(); ++__n)\n-      if (_M_buckets[__n])\n-        return iterator(_M_buckets[__n], this);\n-    return end();\n-  }\n-\n-  iterator end() { return iterator(0, this); }\n-\n-  const_iterator begin() const\n-  {\n-    for (size_type __n = 0; __n < _M_buckets.size(); ++__n)\n-      if (_M_buckets[__n])\n-        return const_iterator(_M_buckets[__n], this);\n-    return end();\n-  }\n-\n-  const_iterator end() const { return const_iterator(0, this); }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class _Vl, class _Ky, class _HF, class _Ex, class _Eq, class _Al>\n-  friend bool operator== (const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&,\n-                          const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&);\n-#else /* __STL_MEMBER_TEMPLATES */\n-  friend bool __STD_QUALIFIER\n-  operator== __STL_NULL_TMPL_ARGS (const hashtable&, const hashtable&);\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-public:\n-\n-  size_type bucket_count() const { return _M_buckets.size(); }\n-\n-  size_type max_bucket_count() const\n-    { return __stl_prime_list[(int)__stl_num_primes - 1]; } \n-\n-  size_type elems_in_bucket(size_type __bucket) const\n-  {\n-    size_type __result = 0;\n-    for (_Node* __cur = _M_buckets[__bucket]; __cur; __cur = __cur->_M_next)\n-      __result += 1;\n-    return __result;\n-  }\n-\n-  pair<iterator, bool> insert_unique(const value_type& __obj)\n-  {\n-    resize(_M_num_elements + 1);\n-    return insert_unique_noresize(__obj);\n-  }\n-\n-  iterator insert_equal(const value_type& __obj)\n-  {\n-    resize(_M_num_elements + 1);\n-    return insert_equal_noresize(__obj);\n-  }\n-\n-  pair<iterator, bool> insert_unique_noresize(const value_type& __obj);\n-  iterator insert_equal_noresize(const value_type& __obj);\n- \n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class _InputIterator>\n-  void insert_unique(_InputIterator __f, _InputIterator __l)\n-  {\n-    insert_unique(__f, __l, __ITERATOR_CATEGORY(__f));\n-  }\n-\n-  template <class _InputIterator>\n-  void insert_equal(_InputIterator __f, _InputIterator __l)\n-  {\n-    insert_equal(__f, __l, __ITERATOR_CATEGORY(__f));\n-  }\n-\n-  template <class _InputIterator>\n-  void insert_unique(_InputIterator __f, _InputIterator __l,\n-                     input_iterator_tag)\n-  {\n-    for ( ; __f != __l; ++__f)\n-      insert_unique(*__f);\n-  }\n-\n-  template <class _InputIterator>\n-  void insert_equal(_InputIterator __f, _InputIterator __l,\n-                    input_iterator_tag)\n-  {\n-    for ( ; __f != __l; ++__f)\n-      insert_equal(*__f);\n-  }\n-\n-  template <class _ForwardIterator>\n-  void insert_unique(_ForwardIterator __f, _ForwardIterator __l,\n-                     forward_iterator_tag)\n-  {\n-    size_type __n = 0;\n-    distance(__f, __l, __n);\n-    resize(_M_num_elements + __n);\n-    for ( ; __n > 0; --__n, ++__f)\n-      insert_unique_noresize(*__f);\n-  }\n-\n-  template <class _ForwardIterator>\n-  void insert_equal(_ForwardIterator __f, _ForwardIterator __l,\n-                    forward_iterator_tag)\n-  {\n-    size_type __n = 0;\n-    distance(__f, __l, __n);\n-    resize(_M_num_elements + __n);\n-    for ( ; __n > 0; --__n, ++__f)\n-      insert_equal_noresize(*__f);\n-  }\n-\n-#else /* __STL_MEMBER_TEMPLATES */\n-  void insert_unique(const value_type* __f, const value_type* __l)\n-  {\n-    size_type __n = __l - __f;\n-    resize(_M_num_elements + __n);\n-    for ( ; __n > 0; --__n, ++__f)\n-      insert_unique_noresize(*__f);\n-  }\n-\n-  void insert_equal(const value_type* __f, const value_type* __l)\n-  {\n-    size_type __n = __l - __f;\n-    resize(_M_num_elements + __n);\n-    for ( ; __n > 0; --__n, ++__f)\n-      insert_equal_noresize(*__f);\n-  }\n-\n-  void insert_unique(const_iterator __f, const_iterator __l)\n-  {\n-    size_type __n = 0;\n-    distance(__f, __l, __n);\n-    resize(_M_num_elements + __n);\n-    for ( ; __n > 0; --__n, ++__f)\n-      insert_unique_noresize(*__f);\n-  }\n-\n-  void insert_equal(const_iterator __f, const_iterator __l)\n-  {\n-    size_type __n = 0;\n-    distance(__f, __l, __n);\n-    resize(_M_num_elements + __n);\n-    for ( ; __n > 0; --__n, ++__f)\n-      insert_equal_noresize(*__f);\n-  }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-\n-  reference find_or_insert(const value_type& __obj);\n-\n-  iterator find(const key_type& __key) \n-  {\n-    size_type __n = _M_bkt_num_key(__key);\n-    _Node* __first;\n-    for ( __first = _M_buckets[__n];\n-          __first && !_M_equals(_M_get_key(__first->_M_val), __key);\n-          __first = __first->_M_next)\n-      {}\n-    return iterator(__first, this);\n-  } \n-\n-  const_iterator find(const key_type& __key) const\n-  {\n-    size_type __n = _M_bkt_num_key(__key);\n-    const _Node* __first;\n-    for ( __first = _M_buckets[__n];\n-          __first && !_M_equals(_M_get_key(__first->_M_val), __key);\n-          __first = __first->_M_next)\n-      {}\n-    return const_iterator(__first, this);\n-  } \n-\n-  size_type count(const key_type& __key) const\n-  {\n-    const size_type __n = _M_bkt_num_key(__key);\n-    size_type __result = 0;\n-\n-    for (const _Node* __cur = _M_buckets[__n]; __cur; __cur = __cur->_M_next)\n-      if (_M_equals(_M_get_key(__cur->_M_val), __key))\n-        ++__result;\n-    return __result;\n-  }\n-\n-  pair<iterator, iterator> \n-  equal_range(const key_type& __key);\n-\n-  pair<const_iterator, const_iterator> \n-  equal_range(const key_type& __key) const;\n-\n-  size_type erase(const key_type& __key);\n-  void erase(const iterator& __it);\n-  void erase(iterator __first, iterator __last);\n-\n-  void erase(const const_iterator& __it);\n-  void erase(const_iterator __first, const_iterator __last);\n-\n-  void resize(size_type __num_elements_hint);\n-  void clear();\n-\n-private:\n-  size_type _M_next_size(size_type __n) const\n-    { return __stl_next_prime(__n); }\n-\n-  void _M_initialize_buckets(size_type __n)\n-  {\n-    const size_type __n_buckets = _M_next_size(__n);\n-    _M_buckets.reserve(__n_buckets);\n-    _M_buckets.insert(_M_buckets.end(), __n_buckets, (_Node*) 0);\n-    _M_num_elements = 0;\n-  }\n-\n-  size_type _M_bkt_num_key(const key_type& __key) const\n-  {\n-    return _M_bkt_num_key(__key, _M_buckets.size());\n-  }\n-\n-  size_type _M_bkt_num(const value_type& __obj) const\n-  {\n-    return _M_bkt_num_key(_M_get_key(__obj));\n-  }\n-\n-  size_type _M_bkt_num_key(const key_type& __key, size_t __n) const\n-  {\n-    return _M_hash(__key) % __n;\n-  }\n-\n-  size_type _M_bkt_num(const value_type& __obj, size_t __n) const\n-  {\n-    return _M_bkt_num_key(_M_get_key(__obj), __n);\n-  }\n-\n-  _Node* _M_new_node(const value_type& __obj)\n-  {\n-    _Node* __n = _M_get_node();\n-    __n->_M_next = 0;\n-    __STL_TRY {\n-      construct(&__n->_M_val, __obj);\n-      return __n;\n-    }\n-    __STL_UNWIND(_M_put_node(__n));\n-  }\n-  \n-  void _M_delete_node(_Node* __n)\n-  {\n-    destroy(&__n->_M_val);\n-    _M_put_node(__n);\n-  }\n-\n-  void _M_erase_bucket(const size_type __n, _Node* __first, _Node* __last);\n-  void _M_erase_bucket(const size_type __n, _Node* __last);\n-\n-  void _M_copy_from(const hashtable& __ht);\n-\n-};\n-\n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n-          class _All>\n-_Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&\n-_Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++()\n-{\n-  const _Node* __old = _M_cur;\n-  _M_cur = _M_cur->_M_next;\n-  if (!_M_cur) {\n-    size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);\n-    while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())\n-      _M_cur = _M_ht->_M_buckets[__bucket];\n-  }\n-  return *this;\n-}\n-\n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n-          class _All>\n-inline _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>\n-_Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++(int)\n-{\n-  iterator __tmp = *this;\n-  ++*this;\n-  return __tmp;\n-}\n-\n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n-          class _All>\n-_Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&\n-_Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++()\n-{\n-  const _Node* __old = _M_cur;\n-  _M_cur = _M_cur->_M_next;\n-  if (!_M_cur) {\n-    size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);\n-    while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())\n-      _M_cur = _M_ht->_M_buckets[__bucket];\n-  }\n-  return *this;\n-}\n-\n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n-          class _All>\n-inline _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>\n-_Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++(int)\n-{\n-  const_iterator __tmp = *this;\n-  ++*this;\n-  return __tmp;\n-}\n-\n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n-          class _All>\n-inline forward_iterator_tag\n-iterator_category(const _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)\n-{\n-  return forward_iterator_tag();\n-}\n-\n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n-          class _All>\n-inline _Val* \n-value_type(const _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)\n-{\n-  return (_Val*) 0;\n-}\n-\n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n-          class _All>\n-inline hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::difference_type*\n-distance_type(const _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)\n-{\n-  return (hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::difference_type*) 0;\n-}\n-\n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n-          class _All>\n-inline forward_iterator_tag\n-iterator_category(const _Hashtable_const_iterator<_Val,_Key,_HF,\n-                                                  _ExK,_EqK,_All>&)\n-{\n-  return forward_iterator_tag();\n-}\n-\n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n-          class _All>\n-inline _Val* \n-value_type(const _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)\n-{\n-  return (_Val*) 0;\n-}\n-\n-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, \n-          class _All>\n-inline hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::difference_type*\n-distance_type(const _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)\n-{\n-  return (hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::difference_type*) 0;\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-bool operator==(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,\n-                const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2)\n-{\n-  typedef typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::_Node _Node;\n-  if (__ht1._M_buckets.size() != __ht2._M_buckets.size())\n-    return false;\n-  for (int __n = 0; __n < __ht1._M_buckets.size(); ++__n) {\n-    _Node* __cur1 = __ht1._M_buckets[__n];\n-    _Node* __cur2 = __ht2._M_buckets[__n];\n-    for ( ; __cur1 && __cur2 && __cur1->_M_val == __cur2->_M_val;\n-          __cur1 = __cur1->_M_next, __cur2 = __cur2->_M_next)\n-      {}\n-    if (__cur1 || __cur2)\n-      return false;\n-  }\n-  return true;\n-}  \n-\n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-inline bool operator!=(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,\n-                       const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2) {\n-  return !(__ht1 == __ht2);\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Extract, class _EqKey, \n-          class _All>\n-inline void swap(hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht1,\n-                 hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht2) {\n-  __ht1.swap(__ht2);\n-}\n-\n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator, bool> \n-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n-  ::insert_unique_noresize(const value_type& __obj)\n-{\n-  const size_type __n = _M_bkt_num(__obj);\n-  _Node* __first = _M_buckets[__n];\n-\n-  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next) \n-    if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n-      return pair<iterator, bool>(iterator(__cur, this), false);\n-\n-  _Node* __tmp = _M_new_node(__obj);\n-  __tmp->_M_next = __first;\n-  _M_buckets[__n] = __tmp;\n-  ++_M_num_elements;\n-  return pair<iterator, bool>(iterator(__tmp, this), true);\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator \n-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n-  ::insert_equal_noresize(const value_type& __obj)\n-{\n-  const size_type __n = _M_bkt_num(__obj);\n-  _Node* __first = _M_buckets[__n];\n-\n-  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next) \n-    if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj))) {\n-      _Node* __tmp = _M_new_node(__obj);\n-      __tmp->_M_next = __cur->_M_next;\n-      __cur->_M_next = __tmp;\n-      ++_M_num_elements;\n-      return iterator(__tmp, this);\n-    }\n-\n-  _Node* __tmp = _M_new_node(__obj);\n-  __tmp->_M_next = __first;\n-  _M_buckets[__n] = __tmp;\n-  ++_M_num_elements;\n-  return iterator(__tmp, this);\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::reference \n-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::find_or_insert(const value_type& __obj)\n-{\n-  resize(_M_num_elements + 1);\n-\n-  size_type __n = _M_bkt_num(__obj);\n-  _Node* __first = _M_buckets[__n];\n-\n-  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n-    if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n-      return __cur->_M_val;\n-\n-  _Node* __tmp = _M_new_node(__obj);\n-  __tmp->_M_next = __first;\n-  _M_buckets[__n] = __tmp;\n-  ++_M_num_elements;\n-  return __tmp->_M_val;\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator,\n-     typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator> \n-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::equal_range(const key_type& __key)\n-{\n-  typedef pair<iterator, iterator> _Pii;\n-  const size_type __n = _M_bkt_num_key(__key);\n-\n-  for (_Node* __first = _M_buckets[__n]; __first; __first = __first->_M_next)\n-    if (_M_equals(_M_get_key(__first->_M_val), __key)) {\n-      for (_Node* __cur = __first->_M_next; __cur; __cur = __cur->_M_next)\n-        if (!_M_equals(_M_get_key(__cur->_M_val), __key))\n-          return _Pii(iterator(__first, this), iterator(__cur, this));\n-      for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)\n-        if (_M_buckets[__m])\n-          return _Pii(iterator(__first, this),\n-                     iterator(_M_buckets[__m], this));\n-      return _Pii(iterator(__first, this), end());\n-    }\n-  return _Pii(end(), end());\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::const_iterator, \n-     typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::const_iterator> \n-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n-  ::equal_range(const key_type& __key) const\n-{\n-  typedef pair<const_iterator, const_iterator> _Pii;\n-  const size_type __n = _M_bkt_num_key(__key);\n-\n-  for (const _Node* __first = _M_buckets[__n] ;\n-       __first; \n-       __first = __first->_M_next) {\n-    if (_M_equals(_M_get_key(__first->_M_val), __key)) {\n-      for (const _Node* __cur = __first->_M_next;\n-           __cur;\n-           __cur = __cur->_M_next)\n-        if (!_M_equals(_M_get_key(__cur->_M_val), __key))\n-          return _Pii(const_iterator(__first, this),\n-                      const_iterator(__cur, this));\n-      for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)\n-        if (_M_buckets[__m])\n-          return _Pii(const_iterator(__first, this),\n-                      const_iterator(_M_buckets[__m], this));\n-      return _Pii(const_iterator(__first, this), end());\n-    }\n-  }\n-  return _Pii(end(), end());\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::size_type \n-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const key_type& __key)\n-{\n-  const size_type __n = _M_bkt_num_key(__key);\n-  _Node* __first = _M_buckets[__n];\n-  size_type __erased = 0;\n-\n-  if (__first) {\n-    _Node* __cur = __first;\n-    _Node* __next = __cur->_M_next;\n-    while (__next) {\n-      if (_M_equals(_M_get_key(__next->_M_val), __key)) {\n-        __cur->_M_next = __next->_M_next;\n-        _M_delete_node(__next);\n-        __next = __cur->_M_next;\n-        ++__erased;\n-        --_M_num_elements;\n-      }\n-      else {\n-        __cur = __next;\n-        __next = __cur->_M_next;\n-      }\n-    }\n-    if (_M_equals(_M_get_key(__first->_M_val), __key)) {\n-      _M_buckets[__n] = __first->_M_next;\n-      _M_delete_node(__first);\n-      ++__erased;\n-      --_M_num_elements;\n-    }\n-  }\n-  return __erased;\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const iterator& __it)\n-{\n-  _Node* __p = __it._M_cur;\n-  if (__p) {\n-    const size_type __n = _M_bkt_num(__p->_M_val);\n-    _Node* __cur = _M_buckets[__n];\n-\n-    if (__cur == __p) {\n-      _M_buckets[__n] = __cur->_M_next;\n-      _M_delete_node(__cur);\n-      --_M_num_elements;\n-    }\n-    else {\n-      _Node* __next = __cur->_M_next;\n-      while (__next) {\n-        if (__next == __p) {\n-          __cur->_M_next = __next->_M_next;\n-          _M_delete_node(__next);\n-          --_M_num_elements;\n-          break;\n-        }\n-        else {\n-          __cur = __next;\n-          __next = __cur->_M_next;\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n-  ::erase(iterator __first, iterator __last)\n-{\n-  size_type __f_bucket = __first._M_cur ? \n-    _M_bkt_num(__first._M_cur->_M_val) : _M_buckets.size();\n-  size_type __l_bucket = __last._M_cur ? \n-    _M_bkt_num(__last._M_cur->_M_val) : _M_buckets.size();\n-\n-  if (__first._M_cur == __last._M_cur)\n-    return;\n-  else if (__f_bucket == __l_bucket)\n-    _M_erase_bucket(__f_bucket, __first._M_cur, __last._M_cur);\n-  else {\n-    _M_erase_bucket(__f_bucket, __first._M_cur, 0);\n-    for (size_type __n = __f_bucket + 1; __n < __l_bucket; ++__n)\n-      _M_erase_bucket(__n, 0);\n-    if (__l_bucket != _M_buckets.size())\n-      _M_erase_bucket(__l_bucket, __last._M_cur);\n-  }\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-inline void\n-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const_iterator __first,\n-                                             const_iterator __last)\n-{\n-  erase(iterator(const_cast<_Node*>(__first._M_cur),\n-                 const_cast<hashtable*>(__first._M_ht)),\n-        iterator(const_cast<_Node*>(__last._M_cur),\n-                 const_cast<hashtable*>(__last._M_ht)));\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-inline void\n-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const const_iterator& __it)\n-{\n-  erase(iterator(const_cast<_Node*>(__it._M_cur),\n-                 const_cast<hashtable*>(__it._M_ht)));\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n-  ::resize(size_type __num_elements_hint)\n-{\n-  const size_type __old_n = _M_buckets.size();\n-  if (__num_elements_hint > __old_n) {\n-    const size_type __n = _M_next_size(__num_elements_hint);\n-    if (__n > __old_n) {\n-      vector<_Node*, _All> __tmp(__n, (_Node*)(0),\n-                                 _M_buckets.get_allocator());\n-      __STL_TRY {\n-        for (size_type __bucket = 0; __bucket < __old_n; ++__bucket) {\n-          _Node* __first = _M_buckets[__bucket];\n-          while (__first) {\n-            size_type __new_bucket = _M_bkt_num(__first->_M_val, __n);\n-            _M_buckets[__bucket] = __first->_M_next;\n-            __first->_M_next = __tmp[__new_bucket];\n-            __tmp[__new_bucket] = __first;\n-            __first = _M_buckets[__bucket];          \n-          }\n-        }\n-        _M_buckets.swap(__tmp);\n-      }\n-#         ifdef __STL_USE_EXCEPTIONS\n-      catch(...) {\n-        for (size_type __bucket = 0; __bucket < __tmp.size(); ++__bucket) {\n-          while (__tmp[__bucket]) {\n-            _Node* __next = __tmp[__bucket]->_M_next;\n-            _M_delete_node(__tmp[__bucket]);\n-            __tmp[__bucket] = __next;\n-          }\n-        }\n-        throw;\n-      }\n-#         endif /* __STL_USE_EXCEPTIONS */\n-    }\n-  }\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n-  ::_M_erase_bucket(const size_type __n, _Node* __first, _Node* __last)\n-{\n-  _Node* __cur = _M_buckets[__n];\n-  if (__cur == __first)\n-    _M_erase_bucket(__n, __last);\n-  else {\n-    _Node* __next;\n-    for (__next = __cur->_M_next; \n-         __next != __first; \n-         __cur = __next, __next = __cur->_M_next)\n-      ;\n-    while (__next != __last) {\n-      __cur->_M_next = __next->_M_next;\n-      _M_delete_node(__next);\n-      __next = __cur->_M_next;\n-      --_M_num_elements;\n-    }\n-  }\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n-  ::_M_erase_bucket(const size_type __n, _Node* __last)\n-{\n-  _Node* __cur = _M_buckets[__n];\n-  while (__cur != __last) {\n-    _Node* __next = __cur->_M_next;\n-    _M_delete_node(__cur);\n-    __cur = __next;\n-    _M_buckets[__n] = __cur;\n-    --_M_num_elements;\n-  }\n-}\n-\n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::clear()\n-{\n-  for (size_type __i = 0; __i < _M_buckets.size(); ++__i) {\n-    _Node* __cur = _M_buckets[__i];\n-    while (__cur != 0) {\n-      _Node* __next = __cur->_M_next;\n-      _M_delete_node(__cur);\n-      __cur = __next;\n-    }\n-    _M_buckets[__i] = 0;\n-  }\n-  _M_num_elements = 0;\n-}\n-\n-    \n-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n-  ::_M_copy_from(const hashtable& __ht)\n-{\n-  _M_buckets.clear();\n-  _M_buckets.reserve(__ht._M_buckets.size());\n-  _M_buckets.insert(_M_buckets.end(), __ht._M_buckets.size(), (_Node*) 0);\n-  __STL_TRY {\n-    for (size_type __i = 0; __i < __ht._M_buckets.size(); ++__i) {\n-      const _Node* __cur = __ht._M_buckets[__i];\n-      if (__cur) {\n-        _Node* __local_copy = _M_new_node(__cur->_M_val);\n-        _M_buckets[__i] = __local_copy;\n-\n-        for (_Node* __next = __cur->_M_next; \n-             __next; \n-             __cur = __next, __next = __cur->_M_next) {\n-          __local_copy->_M_next = _M_new_node(__next->_M_val);\n-          __local_copy = __local_copy->_M_next;\n-        }\n-      }\n-    }\n-    _M_num_elements = __ht._M_num_elements;\n-  }\n-  __STL_UNWIND(clear());\n-}\n-\n-__STL_END_NAMESPACE\n-\n-#endif /* __SGI_STL_INTERNAL_HASHTABLE_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "f317f3a6fbcc77f08769edfa8e25e537e48387f2", "filename": "libstdc++-v3/ext/stl_rope.h", "status": "removed", "additions": 0, "deletions": 2714, "changes": 2714, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Fstl_rope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Fstl_rope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fstl_rope.h?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58"}, {"sha": "f6faf976e34fe58d324d1d83cb86962a814722c8", "filename": "libstdc++-v3/ext/tree", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Ftree", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fab27938873b3a2a44e44e2050c23ee98e67e58/libstdc%2B%2B-v3%2Fext%2Ftree", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Ftree?ref=9fab27938873b3a2a44e44e2050c23ee98e67e58", "patch": "@@ -1,23 +0,0 @@\n-\n-/*\n- * Copyright (c) 1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- */\n-\n-#ifndef _CPP_EXT_TREE\n-#define _CPP_EXT_TREE 1\n-#include <bits/stl_tree.h>\n-#endif \n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "43d4de912253dd627f50411fc8581772a10e45a0", "filename": "libstdc++-v3/libio/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2Flibio%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2Flibio%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FChangeLog?ref=35ba173387bbe16802679a210357c800a4ee55f0", "patch": "@@ -1,3 +1,7 @@\n+2000-10-05  Benjamin Kosnik  <bkoz@gnu.org>\n+\n+\t* Makefile.am (INCLUDES): Add glibcpp_includedir.\n+\n 2000-10-04  Benjamin Kosnik  <bkoz@gnu.org>\n \n \t* _G_config.h : Re-guard the __mbstate_t declaration."}, {"sha": "c2faa09a12062c267211ba9a06cb8664fb27e214", "filename": "libstdc++-v3/libio/Makefile.am", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2Flibio%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2Flibio%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FMakefile.am?ref=35ba173387bbe16802679a210357c800a4ee55f0", "patch": "@@ -23,6 +23,9 @@\n \n AUTOMAKE_OPTIONS = 1.3 cygnus\n \n+# Root level of the include sources.\n+glibcpp_includedir = $(top_srcdir)/include\n+\n # Passed down for cross compilers, canadian crosses.\n TOPLEVEL_INCLUDES = -I$(includedir)\n \n@@ -38,9 +41,9 @@ CONFIG_INCLUDES = \\\n \t-I$(top_srcdir)/@ctype_include_dir@\n \n INCLUDES = \\\n-\t-nostdinc++ -I$(top_srcdir) \\\n-\t$(LIBIO_INCLUDES) $(CONFIG_INCLUDES) \\\n-\t$(TOPLEVEL_INCLUDES)\t\n+\t-nostdinc++ \\\n+\t-I$(top_builddir) -I$(glibcpp_includedir) \\\n+\t$(CONFIG_INCLUDES) $(LIBIO_INCLUDES) $(TOPLEVEL_INCLUDES)\t\n \n noinst_LTLIBRARIES = libio.la\n "}, {"sha": "547bd22557451e11ea1a2d149ee99ec5ee12bff2", "filename": "libstdc++-v3/libio/Makefile.in", "status": "modified", "additions": 60, "deletions": 57, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2Flibio%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2Flibio%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FMakefile.in?ref=35ba173387bbe16802679a210357c800a4ee55f0", "patch": "@@ -111,6 +111,9 @@ libinst_wstring_la = @libinst_wstring_la@\n \n AUTOMAKE_OPTIONS = 1.3 cygnus\n \n+# Root level of the include sources.\n+glibcpp_includedir = $(top_srcdir)/include\n+\n # Passed down for cross compilers, canadian crosses.\n TOPLEVEL_INCLUDES = -I$(includedir)\n @GLIBCPP_NEED_LIBIO_TRUE@LIBIO_INCLUDES = \t-I$(top_builddir)/libio -I$(top_srcdir)/libio \n@@ -119,7 +122,7 @@ TOPLEVEL_INCLUDES = -I$(includedir)\n CONFIG_INCLUDES =  \t-I$(top_srcdir)/@cpu_include_dir@ \t-I$(top_srcdir)/@ctype_include_dir@\n \n \n-INCLUDES =  \t-nostdinc++ -I$(top_srcdir) \t$(LIBIO_INCLUDES) $(CONFIG_INCLUDES) \t$(TOPLEVEL_INCLUDES)\t\n+INCLUDES =  \t-nostdinc++ \t-I$(top_builddir) -I$(glibcpp_includedir) \t$(CONFIG_INCLUDES) $(LIBIO_INCLUDES) $(TOPLEVEL_INCLUDES)\t\n \n \n noinst_LTLIBRARIES = libio.la\n@@ -170,62 +173,62 @@ CPPFLAGS = @CPPFLAGS@\n LDFLAGS = @LDFLAGS@\n LIBS = @LIBS@\n libio_la_LDFLAGS = \n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@libio_la_OBJECTS =  \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@filedoalloc.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@genops.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@fileops.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@stdfiles.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@c_codecvt.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@wfiledoalloc.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@wfileops.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@wgenops.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@iofwide.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@iofclose.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@iofopen.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@stdio.lo\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@libio_la_OBJECTS = \n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@libio_la_OBJECTS =  \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@wfiledoalloc.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@wfileops.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@wgenops.lo\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@libio_la_OBJECTS =  \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@filedoalloc.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@genops.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@fileops.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@stdfiles.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@c_codecvt.lo\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@libio_la_OBJECTS =  \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@iofwide.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@iofclose.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@iofopen.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@stdio.lo\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@libio_la_OBJECTS =  \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@filedoalloc.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@genops.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@fileops.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@stdfiles.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@c_codecvt.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@iofwide.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@iofclose.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@iofopen.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@stdio.lo\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@libio_la_OBJECTS =  \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@wfiledoalloc.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@wfileops.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@wgenops.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@iofwide.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@iofclose.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@iofopen.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@stdio.lo\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@libio_la_OBJECTS =  \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@filedoalloc.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@genops.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@fileops.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@stdfiles.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@c_codecvt.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@wfiledoalloc.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@wfileops.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@wgenops.lo\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_FALSE@libio_la_OBJECTS = \n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@libio_la_OBJECTS =  \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@iofwide.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@iofclose.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@iofopen.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@stdio.lo\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@libio_la_OBJECTS =  \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@filedoalloc.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@genops.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@fileops.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@stdfiles.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@c_codecvt.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@wfiledoalloc.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@wfileops.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@wgenops.lo\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@libio_la_OBJECTS =  \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@filedoalloc.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@genops.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@fileops.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@stdfiles.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@c_codecvt.lo\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@libio_la_OBJECTS =  \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@filedoalloc.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@genops.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@fileops.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@stdfiles.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@c_codecvt.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@iofwide.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@iofclose.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@iofopen.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@stdio.lo\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_FALSE@libio_la_OBJECTS =  \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_FALSE@wfiledoalloc.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_FALSE@wfileops.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_FALSE@@GLIBCPP_NEED_LIBIO_FALSE@wgenops.lo\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@libio_la_OBJECTS =  \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@wfiledoalloc.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@wfileops.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@wgenops.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@iofwide.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@iofclose.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@iofopen.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@stdio.lo\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@libio_la_OBJECTS =  \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@filedoalloc.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@genops.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@fileops.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@stdfiles.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@c_codecvt.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@wfiledoalloc.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@wfileops.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@wgenops.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@iofwide.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@iofclose.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@iofopen.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_XTRA_LIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@stdio.lo\n CFLAGS = @CFLAGS@\n CCLD = $(CC)\n DIST_COMMON =  ChangeLog Makefile.am Makefile.in"}, {"sha": "605f42f548a4d3a2896cd7f3783e94d263f48ebd", "filename": "libstdc++-v3/math/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2Fmath%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2Fmath%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2FMakefile.am?ref=35ba173387bbe16802679a210357c800a4ee55f0", "patch": "@@ -51,7 +51,7 @@ libmath_la_SOURCES = \\\n LINK = $(LIBTOOL) --mode=link \"$(CCLD)\" $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@\n \n TOPLEVEL_INCLUDES = -I$(includedir)\n-INCLUDES = -I..  $(TOPLEVEL_INCLUDES)\n+INCLUDES = -I../include  $(TOPLEVEL_INCLUDES)\n \n \n "}, {"sha": "4aab9ff93d582c742b5c903fffb967ea3f7db02d", "filename": "libstdc++-v3/math/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2Fmath%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2Fmath%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2FMakefile.in?ref=35ba173387bbe16802679a210357c800a4ee55f0", "patch": "@@ -130,7 +130,7 @@ libmath_la_SOURCES =  \tsignbit.c signbitf.c cabs.c cabsf.c\n LINK = $(LIBTOOL) --mode=link \"$(CCLD)\" $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@\n \n TOPLEVEL_INCLUDES = -I$(includedir)\n-INCLUDES = -I..  $(TOPLEVEL_INCLUDES)\n+INCLUDES = -I../include  $(TOPLEVEL_INCLUDES)\n mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n CONFIG_HEADER = ../config.h\n CONFIG_CLEAN_FILES = "}, {"sha": "c14736975291a1f262f4c6b87c4b15e7ad4ed6a6", "filename": "libstdc++-v3/mkc++config", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2Fmkc%2B%2Bconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2Fmkc%2B%2Bconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmkc%2B%2Bconfig?ref=35ba173387bbe16802679a210357c800a4ee55f0", "patch": "@@ -19,7 +19,7 @@ if [ ! -d \"$SRC_DIR\" ]; then\n   exit 1\n fi\n \n-BASE_H=\"$SRC_DIR/bits/c++config\"\n+BASE_H=\"$SRC_DIR/include/bits/c++config\"\n IN_H=\"$BUILD_DIR/config.h\"\n OUT_H=\"$BUILD_DIR/bits/c++config.h\"\n "}, {"sha": "2cf4a1c83d7b78f54c83b4d348b267fc7948c810", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=35ba173387bbe16802679a210357c800a4ee55f0", "patch": "@@ -21,7 +21,7 @@\n ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n ## USA.\n \n-## $Id: Makefile.am,v 1.31 2000/10/04 05:06:32 bkoz Exp $\n+## $Id: Makefile.am,v 1.32 2000/10/04 06:44:25 bkoz Exp $\n \n AUTOMAKE_OPTIONS = 1.3 gnits\n MAINT_CHARSET = latin1\n@@ -59,9 +59,14 @@ AM_CXXFLAGS = \\\n \t$(AC_CXXFLAGS) \n \n \n+# Root level of the include sources.\n+glibcpp_includedir = $(top_srcdir)/include\n+\n # Passed down for cross compilers, canadian crosses.\n TOPLEVEL_INCLUDES = -I$(includedir)\n \n+LIBMATH_INCLUDES = -I$(top_srcdir)/math\n+\n if GLIBCPP_NEED_LIBIO\n LIBIO_INCLUDES = \\\n \t-I$(top_builddir)/libio -I$(top_srcdir)/libio \n@@ -71,9 +76,9 @@ endif\n \n if GLIBCPP_USE_CSHADOW\n #CSHADOW_INCLUDES = \\\n-#\t-I$(top_srcdir)/std -I$(top_srcdir)/shadow -I$(top_builddir)/cshadow\n+#\t-I$(glibcpp_includedir)/std -I$(top_srcdir)/shadow -I$(top_builddir)/cshadow\n CSHADOW_INCLUDES = \\\n-\t-I$(top_srcdir)/std -I$(top_srcdir)/shadow \n+\t-I$(glibcpp_includedir)/std -I$(top_srcdir)/shadow \n else\n CSHADOW_INCLUDES =\n endif\n@@ -84,8 +89,9 @@ CONFIG_INCLUDES = \\\n \n INCLUDES = \\\n \t-D_GNU_SOURCE -D_ISOC99_SOURCE -nostdinc++ $(CSHADOW_INCLUDES) \\\n-\t-I$(top_builddir) -I$(top_srcdir) \\\n-\t $(CONFIG_INCLUDES) $(LIBIO_INCLUDES) $(TOPLEVEL_INCLUDES)\t\n+\t-I$(top_builddir) -I$(glibcpp_includedir) \\\n+\t $(CONFIG_INCLUDES) $(LIBIO_INCLUDES) $(LIBMATH_INCLUDES) \\\n+\t $(TOPLEVEL_INCLUDES)\t\n \n \n # Need to explicitly set this so that AM_CXXFLAGS is last. In\n@@ -219,7 +225,8 @@ sources = \\\n wstring_sources = \\\n \twstring-inst.cc\n \n-VPATH += $(top_srcdir) $(top_srcdir)/std $(top_srcdir)/src\n+VPATH += $(top_srcdir) $(top_srcdir)/src\n+VPATH += $(glibcpp_includedir) $(top_srcdir)/std\n VPATH += $(top_srcdir)/@ctype_include_dir@\n \n \n@@ -269,8 +276,8 @@ install: myinstallheaders\n myinstallheaders: $(headers:%=$(myincludep)%)\n \tif test -z \"$(MULTISUBDIR)\"; then \\\n \tfor i in $(std_headers); do \\\n-\t  echo \"$(INSTALL_DATA) $(top_srcdir)/std/$$i $(myincludep)\"; \\\n-\t        $(INSTALL_DATA) $(top_srcdir)/std/$$i $(myincludep); \\\n+\t  echo \"$(INSTALL_DATA) $(glibcpp_includedir)/std/$$i $(myincludep)\"; \\\n+\t        $(INSTALL_DATA) $(glibcpp_includedir)/std/$$i $(myincludep); \\\n \tdone; \\\n \tfor i in $(generated_headers); do \\\n \t  echo \"$(INSTALL_DATA) $$i $(myincludep)bits/\"; \\\n@@ -292,7 +299,7 @@ $(headers:%=$(myincludep)%): $(myincludep)%: %\n \t$(INSTALL_DATA) $^ $@; \\\n \tfi;\n \n-# All the machinations with string instantiations messes up the\n+# All the (now removed) machinations with string instantiations messes up the\n # automake-generated TAGS rule. Make a simple one here.\n TAGS: $(generated_headers) $(cpu_headers) \n \tetags -C $(top_srcdir)/bits/*.h $(top_srcdir)/bits/*.tcc \\\n@@ -331,3 +338,6 @@ libstdc++.INC: Makefile\n \n tmp-libstdc++.INC: Makefile\n \techo -I$(top_builddir) $(INCLUDES) > $@\n+\n+\n+"}, {"sha": "a7d0d61ca049f56e0f85c17cb792cdb5c446a946", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=35ba173387bbe16802679a210357c800a4ee55f0", "patch": "@@ -133,17 +133,22 @@ AC_CXXFLAGS =  \t$(WERROR) @WFMT_FLAGS@ @CPU_FLAGS@ @EXTRA_CXX_FLAGS@ \t@SECTION_F\n AM_CXXFLAGS =  \t-fno-implicit-templates $(OPTIMIZE_CXXFLAGS) \t-Wall -Wno-format -W -Wwrite-strings -Winline \t$(AC_CXXFLAGS) \n \n \n+# Root level of the include sources.\n+glibcpp_includedir = $(top_srcdir)/include\n+\n # Passed down for cross compilers, canadian crosses.\n TOPLEVEL_INCLUDES = -I$(includedir)\n+\n+LIBMATH_INCLUDES = -I$(top_srcdir)/math\n @GLIBCPP_NEED_LIBIO_TRUE@LIBIO_INCLUDES = \t-I$(top_builddir)/libio -I$(top_srcdir)/libio \n @GLIBCPP_NEED_LIBIO_FALSE@LIBIO_INCLUDES = -I$(top_srcdir)/libio\n-@GLIBCPP_USE_CSHADOW_TRUE@CSHADOW_INCLUDES = \t-I$(top_srcdir)/std -I$(top_srcdir)/shadow \n+@GLIBCPP_USE_CSHADOW_TRUE@CSHADOW_INCLUDES = \t-I$(glibcpp_includedir)/std -I$(top_srcdir)/shadow \n @GLIBCPP_USE_CSHADOW_FALSE@CSHADOW_INCLUDES = \n \n CONFIG_INCLUDES =  \t-I$(top_srcdir)/@cpu_include_dir@ \t-I$(top_srcdir)/@ctype_include_dir@\n \n \n-INCLUDES =  \t-D_GNU_SOURCE -D_ISOC99_SOURCE -nostdinc++ $(CSHADOW_INCLUDES) \t-I$(top_builddir) -I$(top_srcdir) \t $(CONFIG_INCLUDES) $(LIBIO_INCLUDES) $(TOPLEVEL_INCLUDES)\t\n+INCLUDES =  \t-D_GNU_SOURCE -D_ISOC99_SOURCE -nostdinc++ $(CSHADOW_INCLUDES) \t-I$(top_builddir) -I$(glibcpp_includedir) \t $(CONFIG_INCLUDES) $(LIBIO_INCLUDES) $(LIBMATH_INCLUDES) \t $(TOPLEVEL_INCLUDES)\t\n \n \n # Need to explicitly set this so that AM_CXXFLAGS is last. In\n@@ -182,7 +187,7 @@ sources =  \tlimitsMEMBERS.cc \tcmath.cc \tcomplex.cc complexf.cc complexl.cc compl\n \n wstring_sources =  \twstring-inst.cc\n \n-VPATH =  $(top_srcdir) $(top_srcdir)/std $(top_srcdir)/src $(top_srcdir)/@ctype_include_dir@\n+VPATH =  $(top_srcdir) $(top_srcdir)/src $(glibcpp_includedir) $(top_srcdir)/std $(top_srcdir)/@ctype_include_dir@\n \n # Actual sources for the distro, but don't build these.\n #EXTRA_sources = string-inst.cc \n@@ -468,8 +473,8 @@ install: myinstallheaders\n myinstallheaders: $(headers:%=$(myincludep)%)\n \tif test -z \"$(MULTISUBDIR)\"; then \\\n \tfor i in $(std_headers); do \\\n-\t  echo \"$(INSTALL_DATA) $(top_srcdir)/std/$$i $(myincludep)\"; \\\n-\t        $(INSTALL_DATA) $(top_srcdir)/std/$$i $(myincludep); \\\n+\t  echo \"$(INSTALL_DATA) $(glibcpp_includedir)/std/$$i $(myincludep)\"; \\\n+\t        $(INSTALL_DATA) $(glibcpp_includedir)/std/$$i $(myincludep); \\\n \tdone; \\\n \tfor i in $(generated_headers); do \\\n \t  echo \"$(INSTALL_DATA) $$i $(myincludep)bits/\"; \\\n@@ -491,7 +496,7 @@ $(headers:%=$(myincludep)%): $(myincludep)%: %\n \t$(INSTALL_DATA) $^ $@; \\\n \tfi;\n \n-# All the machinations with string instantiations messes up the\n+# All the (now removed) machinations with string instantiations messes up the\n # automake-generated TAGS rule. Make a simple one here.\n TAGS: $(generated_headers) $(cpu_headers) \n \tetags -C $(top_srcdir)/bits/*.h $(top_srcdir)/bits/*.tcc \\"}, {"sha": "b3b1e0fe781f084aa5ba3ae0727409843fff8943", "filename": "libstdc++-v3/src/complex.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2Fsrc%2Fcomplex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ba173387bbe16802679a210357c800a4ee55f0/libstdc%2B%2B-v3%2Fsrc%2Fcomplex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fcomplex.cc?ref=35ba173387bbe16802679a210357c800a4ee55f0", "patch": "@@ -31,7 +31,7 @@\n #include <bits/std_complex.h>\n \n // This is a ISO C 9X header.\n-#include <math/mathconf.h>\n+#include <mathconf.h>\n #undef complex\n \n #ifndef FLT"}]}