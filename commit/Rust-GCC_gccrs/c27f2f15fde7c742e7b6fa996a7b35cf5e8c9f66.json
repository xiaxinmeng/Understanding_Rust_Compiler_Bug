{"sha": "c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI3ZjJmMTVmZGU3Yzc0MmU3YjZmYTk5NmE3YjM1Y2Y1ZThjOWY2Ng==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2009-04-07T14:18:13Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-07T14:18:13Z"}, "message": "checks.adb: Remove Assume_Valid parameter from In_Subrange_Of calls\n\n2009-04-07  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb:\n\tRemove Assume_Valid parameter from In_Subrange_Of calls\n\t\n\t* sem_eval.adb:\n\t(Is_Subrange_Of): Remove Assume_Valid parameter, not needed\n\t(Is_In_Range): Remove incorrect use of Assume_Valid\n\t(Is_Out_Of_Range): Remove incorrect use of Assume_Valid\n\t\n\t* sem_eval.ads:\n\t(Is_Subrange_Of): Remove Assume_Valid parameter, not needed\n\t(Is_In_Range): Documentation cleanup\n\t(Is_Out_Of_Range): Documentation cleanup\n\n\t* gnat_rm.texi:\n\tAdd documentation for Assume_No_Invalid_Values pragma\n\n\t* sem_ch12.adb: Minor reformatting\n\n\t* sem_ch6.adb: (Check_Conformance): Avoid cascaded errors\n\n\t* sem_prag.adb: Improve error message.\n\n\t* gnatchop.adb, osint.ads, sinput.adb, sinput.ads, styleg.adb:\n\tLF/CR no longer recognized as line terminator\n\n\t* switch.ads: Minor documentation improvement\n\n\t* vms_data.ads: Minor reformatting\n\nFrom-SVN: r145675", "tree": {"sha": "d65b03473be892ceb27cc44836f2954c06de5996", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d65b03473be892ceb27cc44836f2954c06de5996"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/comments", "author": null, "committer": null, "parents": [{"sha": "afb90d93a4a9a67c2ba19d6e7e571309cf743968", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afb90d93a4a9a67c2ba19d6e7e571309cf743968", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afb90d93a4a9a67c2ba19d6e7e571309cf743968"}], "stats": {"total": 320, "additions": 195, "deletions": 125}, "files": [{"sha": "0bf73e7e8ac229cc338635e46e6c43ef985833aa", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "patch": "@@ -1,3 +1,34 @@\n+2009-04-07  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb:\n+\tRemove Assume_Valid parameter from In_Subrange_Of calls\n+\t\n+\t* sem_eval.adb:\n+\t(Is_Subrange_Of): Remove Assume_Valid parameter, not needed\n+\t(Is_In_Range): Remove incorrect use of Assume_Valid\n+\t(Is_Out_Of_Range): Remove incorrect use of Assume_Valid\n+\t\n+\t* sem_eval.ads:\n+\t(Is_Subrange_Of): Remove Assume_Valid parameter, not needed\n+\t(Is_In_Range): Documentation cleanup\n+\t(Is_Out_Of_Range): Documentation cleanup\n+\n+\t* gnat_rm.texi:\n+\tAdd documentation for Assume_No_Invalid_Values pragma\n+\n+\t* sem_ch12.adb: Minor reformatting\n+\n+\t* sem_ch6.adb: (Check_Conformance): Avoid cascaded errors\n+\n+\t* sem_prag.adb: Improve error message.\n+\n+\t* gnatchop.adb, osint.ads, sinput.adb, sinput.ads, styleg.adb:\n+\tLF/CR no longer recognized as line terminator\n+\n+\t* switch.ads: Minor documentation improvement\n+\n+\t* vms_data.ads: Minor reformatting\n+\n 2009-04-07  Robert Dewar  <dewar@adacore.com>\n \n \t* checks.adb (Determine_Range): Add Assume_Valid parameter"}, {"sha": "c46f66d392a4900c1c593a8889533f141a5af2f4", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "patch": "@@ -2044,9 +2044,7 @@ package body Checks is\n         and then\n            Is_Discrete_Type (S_Typ) = Is_Discrete_Type (Target_Typ)\n         and then\n-          (In_Subrange_Of (S_Typ, Target_Typ,\n-                           Assume_Valid => True,\n-                           Fixed_Int    => Fixed_Int)\n+          (In_Subrange_Of (S_Typ, Target_Typ, Fixed_Int)\n              or else\n                Is_In_Range (Expr, Target_Typ,\n                             Assume_Valid => True,\n@@ -2361,9 +2359,7 @@ package body Checks is\n          begin\n             if not Overflow_Checks_Suppressed (Target_Base)\n               and then not\n-                In_Subrange_Of (Expr_Type, Target_Base,\n-                                Assume_Valid => True,\n-                                Fixed_Int    => Conv_OK)\n+                In_Subrange_Of (Expr_Type, Target_Base, Fixed_Int => Conv_OK)\n               and then not Float_To_Int\n             then\n                Activate_Overflow_Check (N);\n@@ -4601,7 +4597,7 @@ package body Checks is\n       --  case the literal has already been labeled as having the subtype of\n       --  the target.\n \n-      if In_Subrange_Of (Source_Type, Target_Type, Assume_Valid => True)\n+      if In_Subrange_Of (Source_Type, Target_Type)\n         and then not\n           (Nkind (N) = N_Integer_Literal\n              or else\n@@ -4656,9 +4652,7 @@ package body Checks is\n \n       --  The conversions will always work and need no check\n \n-      elsif In_Subrange_Of\n-             (Target_Type, Source_Base_Type, Assume_Valid => True)\n-      then\n+      elsif In_Subrange_Of (Target_Type, Source_Base_Type) then\n          Insert_Action (N,\n            Make_Raise_Constraint_Error (Loc,\n              Condition =>\n@@ -4690,9 +4684,7 @@ package body Checks is\n       --  If that is the case, we can freely convert the source to the target,\n       --  and then test the target result against the bounds.\n \n-      elsif In_Subrange_Of\n-             (Source_Type, Target_Base_Type, Assume_Valid => True)\n-      then\n+      elsif In_Subrange_Of (Source_Type, Target_Base_Type) then\n \n          --  We make a temporary to hold the value of the converted value\n          --  (converted to the base type), and then we will do the test against\n@@ -6855,7 +6847,7 @@ package body Checks is\n          --  range of the target type.\n \n          else\n-            if not In_Subrange_Of (S_Typ, T_Typ, Assume_Valid => True) then\n+            if not In_Subrange_Of (S_Typ, T_Typ) then\n                Cond := Discrete_Expr_Cond (Ck_Node, T_Typ);\n             end if;\n          end if;"}, {"sha": "b2aa6620beb074b6fb01750e58f8007d13f5f93b", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "patch": "@@ -102,6 +102,7 @@ Implementation Defined Pragmas\n * Pragma Ada_2005::\n * Pragma Annotate::\n * Pragma Assert::\n+* Pragma Assume_No_Invalid_Values::\n * Pragma Ast_Entry::\n * Pragma C_Pass_By_Copy::\n * Pragma Check::\n@@ -703,6 +704,7 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Ada_2005::\n * Pragma Annotate::\n * Pragma Assert::\n+* Pragma Assume_No_Invalid_Values::\n * Pragma Ast_Entry::\n * Pragma C_Pass_By_Copy::\n * Pragma Check::\n@@ -996,6 +998,49 @@ effect on the program.  However, the expressions are analyzed for\n semantic correctness whether or not assertions are enabled, so turning\n assertions on and off cannot affect the legality of a program.\n \n+@node Pragma Assume_No_Invalid_Values\n+@unnumberedsec Pragma Assume_No_Invalid_Values\n+@findex Assume_No_Invalid_Values\n+@cindex Invalid representations\n+@cindex Invalid values\n+@noindent\n+Syntax:\n+@smallexample @c ada\n+pragma Assume_No_Invalid_Values (On | Off);\n+@end smallexample\n+\n+@noindent\n+This is a configuration pragma that controls the assumptions made by the\n+compiler about the occurrence of invalid representations (invalid values)\n+in the code.\n+\n+The default behavior (corresponding to an Off argument for this pragma), is\n+to assume that values may in general be invalid unless the compiler can\n+prove they are valid. Consider the following example:\n+\n+@smallexample @c ada\n+V1 : Integer range 1 .. 10;\n+V2 : Integer range 11 .. 20;\n+...\n+for J in V2 .. V1 loop\n+   ...\n+end loop;\n+@end smallexample\n+\n+@noindent\n+if V1 and V2 have valid values, then the loop is known at compile\n+time not to execute since the lower bound must be greater than the\n+upper bound. However in default mode, no such assumption is made,\n+and the loop may execute. If @code{Assume_No_Invalid_Values (On)}\n+is given, the compiler will assume that any occurrence of a variable\n+other than in an explicit @code{'Valid} test always has a valid\n+value, and the loop above will be optimized away.\n+\n+The use of @code{Assume_No_Invalid_Values (On)} is appropriate if\n+you know your code is free of uninitialized variables and other\n+possible sources of invalid representations, and may result in\n+more efficient code.\n+\n @node Pragma Ast_Entry\n @unnumberedsec Pragma Ast_Entry\n @cindex OpenVMS"}, {"sha": "83ccf994f288a02c2a18a345c3917bf136246bdd", "filename": "gcc/ada/gnatchop.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fgnatchop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fgnatchop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatchop.adb?ref=c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "patch": "@@ -493,11 +493,9 @@ procedure Gnatchop is\n          First := Ptr + 1;\n       end if;\n \n-      --  Recognize CR/LF or LF/CR combination\n+      --  Recognize CR/LF\n \n-      if (Source (Ptr + 1) = ASCII.CR or Source (Ptr + 1) = ASCII.LF)\n-         and then Source (Ptr) /= Source (Ptr + 1)\n-      then\n+      if Source (Ptr) = ASCII.CR and then Source (Ptr + 1) = ASCII.LF then\n          Last := First + 1;\n       end if;\n "}, {"sha": "eff00dea9b2281f3c56f12d56567ccfbb74fbdc1", "filename": "gcc/ada/osint.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fosint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fosint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.ads?ref=c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "patch": "@@ -344,7 +344,6 @@ package Osint is\n    --\n    --    CR\n    --    CR/LF\n-   --    LF/CR\n    --    LF\n \n    --  The source is terminated by an EOF (16#1A#) character, which is the last"}, {"sha": "63e810d2b759d21cd737eebf03643ab79d5115b7", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "patch": "@@ -1810,7 +1810,7 @@ package body Sem_Ch12 is\n          Find_Type (Subtype_Mark (N));\n          T := Entity (Subtype_Mark (N));\n \n-         --  Verify that there is no redundant null exclusion.\n+         --  Verify that there is no redundant null exclusion\n \n          if Null_Exclusion_Present (N) then\n             if not Is_Access_Type (T) then"}, {"sha": "764d5245a958ba0f9d4031d8418abffe63dcaabd", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "patch": "@@ -3280,12 +3280,14 @@ package body Sem_Ch6 is\n       Skip_Controlling_Formals : Boolean := False)\n    is\n       procedure Conformance_Error (Msg : String; N : Node_Id := New_Id);\n-      --  Post error message for conformance error on given node. Two messages\n-      --  are output. The first points to the previous declaration with a\n-      --  general \"no conformance\" message. The second is the detailed reason,\n-      --  supplied as Msg. The parameter N provide information for a possible\n-      --  & insertion in the message, and also provides the location for\n-      --  posting the message in the absence of a specified Err_Loc location.\n+      --  Sets Conforms to False. If Errmsg is False, then that's all it does.\n+      --  If Errmsg is True, then processing continues to post an error message\n+      --  for conformance error on given node. Two messages are output. The\n+      --  first message points to the previous declaration with a general \"no\n+      --  conformance\" message. The second is the detailed reason, supplied as\n+      --  Msg. The parameter N provide information for a possible & insertion\n+      --  in the message, and also provides the location for posting the\n+      --  message in the absence of a specified Err_Loc location.\n \n       -----------------------\n       -- Conformance_Error --\n@@ -3579,7 +3581,15 @@ package body Sem_Ch6 is\n                       Get_Inst => Get_Inst)\n            and then not Access_Types_Match\n          then\n-            Conformance_Error (\"\\type of & does not match!\", New_Formal);\n+            --  Don't give error message if old type is Any_Type. This test\n+            --  avoids some cascaded errors, e.g. in case of a bad spec.\n+\n+            if Errmsg and then Old_Formal_Base = Any_Type then\n+               Conforms := False;\n+            else\n+               Conformance_Error (\"\\type of & does not match!\", New_Formal);\n+            end if;\n+\n             return;\n          end if;\n "}, {"sha": "dece5445be4478d8232322b306702d5812aece65", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 25, "deletions": 38, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "patch": "@@ -3542,10 +3542,9 @@ package body Sem_Eval is\n    --------------------\n \n    function In_Subrange_Of\n-     (T1           : Entity_Id;\n-      T2           : Entity_Id;\n-      Assume_Valid : Boolean;\n-      Fixed_Int    : Boolean := False) return Boolean\n+     (T1        : Entity_Id;\n+      T2        : Entity_Id;\n+      Fixed_Int : Boolean := False) return Boolean\n    is\n       L1 : Node_Id;\n       H1 : Node_Id;\n@@ -3572,9 +3571,9 @@ package body Sem_Eval is\n \n          --  Check bounds to see if comparison possible at compile time\n \n-         if Compile_Time_Compare (L1, L2, Assume_Valid) in Compare_GE\n+         if Compile_Time_Compare (L1, L2, Assume_Valid => True) in Compare_GE\n               and then\n-            Compile_Time_Compare (H1, H2, Assume_Valid) in Compare_LE\n+            Compile_Time_Compare (H1, H2, Assume_Valid => True) in Compare_LE\n          then\n             return True;\n          end if;\n@@ -3653,6 +3652,12 @@ package body Sem_Eval is\n       Val  : Uint;\n       Valr : Ureal;\n \n+      pragma Warnings (Off, Assume_Valid);\n+      --  For now Assume_Valid is unreferenced since the current implementation\n+      --  always returns False if N is not a compile time known value, but we\n+      --  keep the parameter to allow for future enhancements in which we try\n+      --  to get the information in the variable case as well.\n+\n    begin\n       --  Universal types have no range limits, so always in range\n \n@@ -3678,30 +3683,19 @@ package body Sem_Eval is\n             Hi       : Node_Id;\n             LB_Known : Boolean;\n             UB_Known : Boolean;\n-            Typt     : Entity_Id;\n \n          begin\n-            if Assume_Valid\n-              or else Assume_No_Invalid_Values\n-              or else (Is_Entity_Name (N)\n-                        and then Is_Known_Valid (Entity (N)))\n-            then\n-               Typt := Typ;\n-            else\n-               Typt := Underlying_Type (Base_Type (Typ));\n-            end if;\n-\n-            Lo := Type_Low_Bound  (Typt);\n-            Hi := Type_High_Bound (Typt);\n+            Lo := Type_Low_Bound  (Typ);\n+            Hi := Type_High_Bound (Typ);\n \n             LB_Known := Compile_Time_Known_Value (Lo);\n             UB_Known := Compile_Time_Known_Value (Hi);\n \n             --  Fixed point types should be considered as such only in\n             --  flag Fixed_Int is set to False.\n \n-            if Is_Floating_Point_Type (Typt)\n-              or else (Is_Fixed_Point_Type (Typt) and then not Fixed_Int)\n+            if Is_Floating_Point_Type (Typ)\n+              or else (Is_Fixed_Point_Type (Typ) and then not Fixed_Int)\n               or else Int_Real\n             then\n                Valr := Expr_Value_R (N);\n@@ -3853,6 +3847,12 @@ package body Sem_Eval is\n       Val  : Uint;\n       Valr : Ureal;\n \n+      pragma Warnings (Off, Assume_Valid);\n+      --  For now Assume_Valid is unreferenced since the current implementation\n+      --  always returns False if N is not a compile time known value, but we\n+      --  keep the parameter to allow for future enhancements in which we try\n+      --  to get the information in the variable case as well.\n+\n    begin\n       --  Universal types have no range limits, so always in range\n \n@@ -3885,23 +3885,10 @@ package body Sem_Eval is\n             Hi       : Node_Id;\n             LB_Known : Boolean;\n             UB_Known : Boolean;\n-            Typt     : Entity_Id;\n \n          begin\n-            --  Go to base type if we could have invalid values\n-\n-            if Assume_Valid\n-              or else Assume_No_Invalid_Values\n-              or else (Is_Entity_Name (N)\n-                        and then Is_Known_Valid (Entity (N)))\n-            then\n-               Typt := Typ;\n-            else\n-               Typt := Underlying_Type (Base_Type (Typ));\n-            end if;\n-\n-            Lo := Type_Low_Bound (Typt);\n-            Hi := Type_High_Bound (Typt);\n+            Lo := Type_Low_Bound (Typ);\n+            Hi := Type_High_Bound (Typ);\n \n             LB_Known := Compile_Time_Known_Value (Lo);\n             UB_Known := Compile_Time_Known_Value (Hi);\n@@ -3910,8 +3897,8 @@ package body Sem_Eval is\n             --  as being of a real type if the flag Fixed_Int is set,\n             --  since in that case they are regarded as integer types).\n \n-            if Is_Floating_Point_Type (Typt)\n-              or else (Is_Fixed_Point_Type (Typt) and then not Fixed_Int)\n+            if Is_Floating_Point_Type (Typ)\n+              or else (Is_Fixed_Point_Type (Typ) and then not Fixed_Int)\n               or else Int_Real\n             then\n                Valr := Expr_Value_R (N);"}, {"sha": "53953d16f2a1bfc116cf30f276b4fb84a3a7ee9d", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "patch": "@@ -333,22 +333,24 @@ package Sem_Eval is\n       Fixed_Int    : Boolean := False;\n       Int_Real     : Boolean := False) return Boolean;\n    --  Returns True if it can be guaranteed at compile time that expression is\n-   --  known to be in range of the subtype Typ. If the values of N or of either\n-   --  bounds of Type are unknown at compile time, False will always be\n-   --  returned. A result of False does not mean that the expression is out of\n-   --  range, merely that it cannot be determined at compile time that it is in\n-   --  range. If Typ is a floating point type or Int_Real is set, any integer\n-   --  value is treated as though it was a real value (i.e. the underlying real\n-   --  value is used). In this case we use the corresponding real value, both\n-   --  for the bounds of Typ, and for the value of the expression N. If Typ is\n-   --  a fixed type or a discrete type and Int_Real is False but flag Fixed_Int\n-   --  is True then any fixed-point value is treated as though it was discrete\n-   --  value (i.e. the underlying integer value is used). In this case we use\n-   --  the corresponding integer value, both for the bounds of Typ, and for the\n-   --  value of the expression N. If Typ is a discrete type and Fixed_Int as\n-   --  well as Int_Real are false, integer values are used throughout. The\n-   --  Assume_Valid parameter determines whether values are to be assumed to\n-   --  be valid (True), or invalid values can occur (False).\n+   --  known to be in range of the subtype Typ. A result of False does not mean\n+   --  that the expression is out of range, merely that it cannot be determined\n+   --  at compile time that it is in range. If Typ is a floating point type or\n+   --  Int_Real is set, any integer value is treated as though it was a real\n+   --  value (i.e. the underlying real value is used). In this case we use the\n+   --  corresponding real value, both for the bounds of Typ, and for the value\n+   --  of the expression N. If Typ is a fixed type or a discrete type and\n+   --  Int_Real is False but flag Fixed_Int is True then any fixed-point value\n+   --  is treated as though it was discrete value (i.e. the underlying integer\n+   --  value is used). In this case we use the corresponding integer value,\n+   --  both for the bounds of Typ, and for the value of the expression N. If\n+   --  Typ is a discrete type and Fixed_Int as well as Int_Real are false,\n+   --  integer values are used throughout.\n+   --\n+   --  If Assume_Valid is set True, then N is always assumed to contain a valid\n+   --  value. If Assume_Valid is set False, then N may be invalid (unless there\n+   --  is some independent way of knowing that it is valid, i.e. either it is\n+   --  an entity with Is_Known_Valid set, or Assume_No_Invalid_Values is True.\n \n    function Is_Out_Of_Range\n      (N            : Node_Id;\n@@ -358,27 +360,21 @@ package Sem_Eval is\n       Int_Real     : Boolean := False) return Boolean;\n    --  Returns True if it can be guaranteed at compile time that expression is\n    --  known to be out of range of the subtype Typ. True is returned if Typ is\n-   --  a scalar type, at least one of whose bounds is known at compile time,\n-   --  and N is a compile time known expression which can be determined to be\n-   --  outside a compile_time known bound of Typ. A result of False does not\n-   --  mean that the expression is in range, but rather merely that it cannot\n-   --  be determined at compile time that it is out of range. Flags Int_Real\n-   --  and Fixed_Int are used as in routine Is_In_Range above. The Assume_Valid\n-   --  parameter determines whether values are to be assumed to be valid\n-   --  (True), or invalid values can occur (False).\n+   --  a scalar type, and the value of N can be determined to be outside the\n+   --  range of Typ. A result of False does not mean that the expression is in\n+   --  range, but rather merely that it cannot be determined at compile time\n+   --  that it is out of range. The parameters Assume_Valid, Fixed_Int, and\n+   --  Int_Real are as described for Is_In_Range above.\n \n    function In_Subrange_Of\n-     (T1           : Entity_Id;\n-      T2           : Entity_Id;\n-      Assume_Valid : Boolean;\n-      Fixed_Int    : Boolean := False) return Boolean;\n+     (T1        : Entity_Id;\n+      T2        : Entity_Id;\n+      Fixed_Int : Boolean := False) return Boolean;\n    --  Returns True if it can be guaranteed at compile time that the range of\n    --  values for scalar type T1 are always in the range of scalar type T2. A\n    --  result of False does not mean that T1 is not in T2's subrange, only that\n    --  it cannot be determined at compile time. Flag Fixed_Int is used as in\n-   --  routine Is_In_Range above. If Assume_Valid is true, the result reflects\n-   --  the result of assuming that entities involved in the comparison have\n-   --  valid representations.\n+   --  routine Is_In_Range above.\n \n    function Is_Null_Range (Lo : Node_Id; Hi : Node_Id) return Boolean;\n    --  Returns True if it can guarantee that Lo .. Hi is a null range. If it"}, {"sha": "bb62b286a81a03555266bb8942e18694535962b3", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2490,8 +2490,9 @@ package body Sem_Prag is\n             then\n                if Scope (E) /= Scope (Alias (E)) then\n                   Error_Pragma_Ref\n-                    (\"cannot apply pragma% to non-local renaming&#\", E);\n+                    (\"cannot apply pragma% to non-local entity&#\", E);\n                end if;\n+\n                E := Alias (E);\n \n             elsif Nkind_In (Parent (E), N_Full_Type_Declaration,\n@@ -2630,8 +2631,10 @@ package body Sem_Prag is\n                     and then Scope (E1) /= Scope (Alias (E1))\n                   then\n                      Error_Pragma_Ref\n-                       (\"cannot apply pragma% to non-local renaming&#\", E1);\n+                       (\"cannot apply pragma% to non-local entity& declared#\",\n+                        E1);\n                   end if;\n+\n                   Set_Convention_From_Pragma (E1);\n \n                   if Prag_Id = Pragma_Import then"}, {"sha": "3129f678e507c4f954ba6b7b3ef8cdd7bd4c54eb", "filename": "gcc/ada/sinput.adb", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fsinput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fsinput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.adb?ref=c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "patch": "@@ -657,11 +657,7 @@ package body Sinput is\n          end if;\n \n       elsif Chr = LF then\n-         if Source (P + 1) = CR then\n-            P := P + 2;\n-         else\n-            P := P + 1;\n-         end if;\n+         P := P + 1;\n \n       elsif Chr = FF or else Chr = VT then\n          P := P + 1;"}, {"sha": "a56eea7276cbc2aa98b6fa2fcf01d4cb2fcc46e7", "filename": "gcc/ada/sinput.ads", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fsinput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fsinput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.ads?ref=c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "patch": "@@ -54,15 +54,13 @@\n --    significance, but they are significant for error reporting purposes,\n --    since errors are identified by line and column location.\n \n---  In GNAT, a physical line is ended by any of the sequences LF, CR/LF, CR or\n---  LF/CR. LF is used in typical Unix systems, CR/LF in DOS systems, and CR\n---  alone in System 7. We don't know of any system using LF/CR, but it seems\n---  reasonable to include this case for consistency. In addition, we recognize\n---  any of these sequences in any of the operating systems, for better\n---  behavior in treating foreign files (e.g. a Unix file with LF terminators\n---  transferred to a DOS system). Finally, wide character codes in categories\n---  Separator, Line and Separator, Paragraph are considered to be physical\n---  line terminators.\n+--  In GNAT, a physical line is ended by any of the sequences LF, CR/LF, or\n+--  CR. LF is used in typical Unix systems, CR/LF in DOS systems, and CR\n+--  alone in System 7. In addition, we recognize any of these sequences in\n+--  any of the operating systems, for better behavior in treating foreign\n+--  files (e.g. a Unix file with LF terminators transferred to a DOS system).\n+--  Finally, wide character codes in categories Separator, Line and Separator,\n+--  Paragraph are considered to be physical line terminators.\n \n with Alloc;\n with Casing; use Casing;\n@@ -575,9 +573,17 @@ package Sinput is\n    --     CR on its own (MAC System 7)\n    --     LF on its own (Unix and unix-like systems)\n    --     CR/LF (DOS, Windows)\n-   --     LF/CR (not used, but recognized in any case)\n    --     Wide character in Separator,Line or Separator,Paragraph category\n    --\n+   --     Note: we no longer recognize LF/CR (which we did in some earlier\n+   --     versions of GNAT. The reason for this is that this sequence is not\n+   --     used and recognizing it generated confusion. For example given the\n+   --     sequence LF/CR/LF we were interpreting that as (LF/CR) ending the\n+   --     first line and a blank line ending with CR following, but it is\n+   --     clearly better to interpret this as LF, with a blank line terminated\n+   --     by CR/LF, given that LF and CR/LF are both in common use, but no\n+   --     system we know of uses LF/CR.\n+   --\n    --  A logical line ending (that is not a physical line ending) is one of:\n    --\n    --     VT on its own"}, {"sha": "2bb6b35b9b05f13f0eaa989747df35c0552bc1cf", "filename": "gcc/ada/styleg.adb", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fstyleg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fstyleg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyleg.adb?ref=c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "patch": "@@ -605,16 +605,20 @@ package body Styleg is\n          end if;\n       end if;\n \n-      --  Check DOS line terminator (ignore EOF, since we only get called\n-      --  with an EOF if it is the last character in the buffer, and was\n-      --  therefore not present in the sources\n+      --  Check DOS line terminator\n \n       if Style_Check_DOS_Line_Terminator then\n+\n+      --  Ignore EOF, since we only get called with an EOF if it is the last\n+      --  character in the buffer (and was therefore not in the source file),\n+      --  since the terminating EOF is added to stop the scan.\n+\n          if Source (Scan_Ptr) = EOF then\n             null;\n-         elsif Source (Scan_Ptr) /= LF\n-           or else Source (Scan_Ptr + 1) = CR\n-         then\n+\n+         --  Bad terminator if we don't have an LF\n+\n+         elsif Source (Scan_Ptr) /= LF then\n             Error_Msg_S (\"(style) incorrect line terminator\");\n          end if;\n       end if;"}, {"sha": "34b14bb1046406d9dbe329f3b51bbaadcbc78256", "filename": "gcc/ada/switch.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fswitch.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fswitch.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch.ads?ref=c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "patch": "@@ -89,7 +89,9 @@ private\n       Switch       : Character);\n    --  Scan natural integer parameter for switch. On entry, Ptr points just\n    --  past the switch character, on exit it points past the last digit of the\n-   --  integer value.\n+   --  integer value. Max is the maximum allowed value of Ptr, so the scan is\n+   --  restricted to Switch_Chars (Ptr .. Max). It is posssible for Ptr to be\n+   --  one greater than Max on return if the entire string is digits.\n \n    procedure Scan_Pos\n      (Switch_Chars : String;"}, {"sha": "6795a0a51101ed0ef3b7b9837d8e54083c2b82a6", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=c27f2f15fde7c742e7b6fa996a7b35cf5e8c9f66", "patch": "@@ -3715,7 +3715,7 @@ package VMS_Data is\n    --   Specifies the main project file to be used. The project files rooted\n    --   at the main project file will be parsed before looking for sources.\n    --   The source and object directories to be searched will be communicated\n-   --   to gnatfind  through logical names ADA_PRJ_INCLUDE_FILE and\n+   --   to gnatfind through logical names ADA_PRJ_INCLUDE_FILE and\n    --   ADA_PRJ_OBJECTS_FILE.\n \n    S_Find_Ref     : aliased constant S := \"/REFERENCES \"                   &\n@@ -5829,6 +5829,7 @@ package VMS_Data is\n    --\n    --   Specify the case of Ada keywords. The default is keywords in lower\n    --   case.\n+   --\n    --   keyword-option may be one of the following:\n    --\n    --      LOWER_CASE (D)\n@@ -5845,9 +5846,9 @@ package VMS_Data is\n    --        /MAX_INDENT=nnn\n    --\n    --   Do not use an additional indentation level for case alternatives\n-   --   and variants if their number is nnn or more. The default is  10.\n-   --   If nnn is zero, an additional indentation level is  used for any number\n-   --   of case alternatives and variants.\n+   --   and variants if their number is nnn or more. The default is 10.\n+   --   If nnn is zero, an additional indentation level is used for any\n+   --   number of case alternatives and variants.\n \n    S_Pretty_Mess      : aliased constant S := \"/MESSAGES_PROJECT_FILE=\"    &\n                                             \"DEFAULT \"                     &"}]}