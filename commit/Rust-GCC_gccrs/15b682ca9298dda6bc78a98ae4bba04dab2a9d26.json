{"sha": "15b682ca9298dda6bc78a98ae4bba04dab2a9d26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTViNjgyY2E5Mjk4ZGRhNmJjNzhhOThhZTRiYmEwNGRhYjJhOWQyNg==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@adacore.com", "date": "2011-08-02T12:41:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T12:41:24Z"}, "message": "cstand.adb (Register_Float_Type): Print information about type to register, if the Debug_Flag_Dot_B is set.\n\n2011-08-02  Geert Bosch  <bosch@adacore.com>\n\n\t* cstand.adb (Register_Float_Type): Print information about type to\n\tregister, if the Debug_Flag_Dot_B is set.\n\t* debug.adb (Debug_Flag_Dot_B): Document d.b debug option.\n\t* rtsfind.ads (RE_Max_Base_Digits): New run time entity.\n\t* sem_ch3.adb (Floating_Point_Type_Declaration): Allow declarations\n\twith a requested precision of more than Max_Digits digits and no more\n\tthan Max_Base_Digits digits, if a range specification is present and the\n\tPredefined_Float_Types list has a suitable type to derive from.\n\t* sem_ch3.adb (Rep_Item_Too_Early): Avoid generating error in the\n\tcase of type completion with pragma Import\n\t* sem_prag.adb\n\t(Process_Import_Predefined_Type): Processing to complete a type\n\twith pragma Import. Currently supports floating point types only.\n\t(Set_Convention_From_Pragma): Do nothing without underlying type.\n\t(Process_Convention): Guard against absence of underlying type,\n\twhich may happen when importing incomplete types.\n\t(Process_Import_Or_Interface): Handle case of importing predefined\n\ttypes. Tweak error message.\n\nFrom-SVN: r177138", "tree": {"sha": "d9fbef02af276ab9634979d335a2954d111ca12c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9fbef02af276ab9634979d335a2954d111ca12c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15b682ca9298dda6bc78a98ae4bba04dab2a9d26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15b682ca9298dda6bc78a98ae4bba04dab2a9d26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15b682ca9298dda6bc78a98ae4bba04dab2a9d26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15b682ca9298dda6bc78a98ae4bba04dab2a9d26/comments", "author": null, "committer": null, "parents": [{"sha": "f8726f2b03e034a7928323e78fbc87b705c3c388", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8726f2b03e034a7928323e78fbc87b705c3c388", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8726f2b03e034a7928323e78fbc87b705c3c388"}], "stats": {"total": 228, "additions": 205, "deletions": 23}, "files": [{"sha": "500a0a278d563065d086760c19579341ad749878", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b682ca9298dda6bc78a98ae4bba04dab2a9d26/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b682ca9298dda6bc78a98ae4bba04dab2a9d26/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=15b682ca9298dda6bc78a98ae4bba04dab2a9d26", "patch": "@@ -1,3 +1,24 @@\n+2011-08-02  Geert Bosch  <bosch@adacore.com>\n+\n+\t* cstand.adb (Register_Float_Type): Print information about type to\n+\tregister, if the Debug_Flag_Dot_B is set.\n+\t* debug.adb (Debug_Flag_Dot_B): Document d.b debug option.\n+\t* rtsfind.ads (RE_Max_Base_Digits): New run time entity.\n+\t* sem_ch3.adb (Floating_Point_Type_Declaration): Allow declarations\n+\twith a requested precision of more than Max_Digits digits and no more\n+\tthan Max_Base_Digits digits, if a range specification is present and the\n+\tPredefined_Float_Types list has a suitable type to derive from.\n+\t* sem_ch3.adb (Rep_Item_Too_Early): Avoid generating error in the\n+\tcase of type completion with pragma Import\n+\t* sem_prag.adb\n+\t(Process_Import_Predefined_Type): Processing to complete a type\n+\twith pragma Import. Currently supports floating point types only.\n+\t(Set_Convention_From_Pragma): Do nothing without underlying type.\n+\t(Process_Convention): Guard against absence of underlying type,\n+\twhich may happen when importing incomplete types.\n+\t(Process_Import_Or_Interface): Handle case of importing predefined\n+\ttypes. Tweak error message.\n+\n 2011-08-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* inline.adb (Add_Inlined_Body): Adjust check for library-level inlined"}, {"sha": "26b19afd5254f4cb48e525555feef5f50f463ced", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 67, "deletions": 5, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b682ca9298dda6bc78a98ae4bba04dab2a9d26/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b682ca9298dda6bc78a98ae4bba04dab2a9d26/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=15b682ca9298dda6bc78a98ae4bba04dab2a9d26", "patch": "@@ -467,7 +467,7 @@ package body CStand is\n             N   : Node_Id := First (Back_End_Float_Types);\n \n          begin\n-            if Digits_Value (LLF) > Max_HW_Digs then\n+            if Present (LLF) and then Digits_Value (LLF) > Max_HW_Digs then\n                LLF := Empty;\n             end if;\n \n@@ -2008,16 +2008,78 @@ package body CStand is\n       Size      : Positive;\n       Alignment : Natural)\n    is\n-      Last : Natural := Name'First - 1;\n+      T    : String (1 .. Name'Length);\n+      Last : Natural := 0;\n+\n+      procedure Dump;\n+      --  Dump information given by the back end for the type to register\n+\n+      procedure Dump is\n+      begin\n+         Write_Str (\"type \" & T (1 .. Last) & \" is \");\n+\n+         if Count > 0 then\n+            Write_Str (\"array (1 .. \");\n+            Write_Int (Int (Count));\n+\n+            if Complex then\n+               Write_Str (\", 1 .. 2\");\n+            end if;\n+\n+            Write_Str (\") of \");\n+\n+         elsif Complex then\n+            Write_Str (\"array (1 .. 2) of \");\n+         end if;\n+\n+         if Digs > 0 then\n+            Write_Str (\"digits \");\n+            Write_Int (Int (Digs));\n+            Write_Line (\";\");\n+\n+            Write_Str (\"pragma Float_Representation (\");\n+\n+            case Float_Rep is\n+               when IEEE_Binary =>  Write_Str (\"IEEE\");\n+               when VAX_Native =>\n+                  case Digs is\n+                     when  6 =>     Write_Str (\"VAXF\");\n+                     when  9 =>     Write_Str (\"VAXD\");\n+                     when 15 =>     Write_Str (\"VAXG\");\n+                     when others => Write_Str (\"VAX_\"); Write_Int (Int (Digs));\n+                  end case;\n+               when AAMP =>         Write_Str (\"AAMP\");\n+            end case;\n+            Write_Line (\", \" & T & \");\");\n+\n+         else\n+            Write_Str (\"mod 2**\");\n+            Write_Int (Int (Size / Positive'Max (1, Count)));\n+            Write_Line (\";\");\n+         end if;\n+\n+         Write_Str (\"for \" & T & \"'Size use \");\n+         Write_Int (Int (Size));\n+         Write_Line (\";\");\n+\n+         Write_Str (\"for \" & T & \"'Alignment use \");\n+         Write_Int (Int (Alignment / 8));\n+         Write_Line (\";\");\n+      end Dump;\n \n    begin\n-      for J in Name'Range loop\n-         if Name (J) = ASCII.NUL then\n+      for J in T'Range loop\n+         T (J) := Name (Name'First + J - 1);\n+         if T (J) = ASCII.NUL then\n             Last := J - 1;\n             exit;\n          end if;\n       end loop;\n \n+      if Debug_Flag_Dot_B then\n+         Dump;\n+      end if;\n+\n       if Digs > 0 and then not Complex and then Count = 0 then\n          declare\n             Ent   : constant Entity_Id := New_Standard_Entity;\n@@ -2026,7 +2088,7 @@ package body CStand is\n          begin\n             Set_Defining_Identifier\n               (New_Node (N_Full_Type_Declaration, Stloc), Ent);\n-            Make_Name (Ent, String (Name (Name'First .. Last)));\n+            Make_Name (Ent, T (1 .. Last));\n             Set_Scope (Ent, Standard_Standard);\n             Build_Float_Type (Ent, Esize, Float_Rep, Pos (Digs));\n             Set_RM_Size (Ent, UI_From_Int (Int (Size)));"}, {"sha": "27ce9b0d87b5d3ed5ac4f1280dd66de30e599293", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b682ca9298dda6bc78a98ae4bba04dab2a9d26/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b682ca9298dda6bc78a98ae4bba04dab2a9d26/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=15b682ca9298dda6bc78a98ae4bba04dab2a9d26", "patch": "@@ -92,7 +92,7 @@ package body Debug is\n    --  dZ   Generate listing showing the contents of the dispatch tables\n \n    --  d.a  Force Target_Strict_Alignment mode to True\n-   --  d.b\n+   --  d.b  Dump backend types\n    --  d.c  Generate inline concatenation, do not call procedure\n    --  d.d\n    --  d.e\n@@ -500,6 +500,9 @@ package body Debug is\n    --       would normally be false. Can be used for testing strict alignment\n    --       circuitry in the compiler.\n \n+   --  d.b  Dump back end types. During Create_Standard, the back end is\n+   --       queried for all available types. This option shows them.\n+\n    --  d.c  Generate inline concatenation, instead of calling one of the\n    --       System.Concat_n.Str_Concat_n routines in cases where the latter\n    --       routines would normally be called."}, {"sha": "1ab979fbd94004adc74cda1c790ff27f5d1478fc", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b682ca9298dda6bc78a98ae4bba04dab2a9d26/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b682ca9298dda6bc78a98ae4bba04dab2a9d26/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=15b682ca9298dda6bc78a98ae4bba04dab2a9d26", "patch": "@@ -650,6 +650,7 @@ package Rtsfind is\n      RE_Interrupt_Priority,              -- System\n      RE_Lib_Stop,                        -- System\n      RE_Low_Order_First,                 -- System\n+     RE_Max_Base_Digits,                 -- System\n      RE_Max_Priority,                    -- System\n      RE_Null_Address,                    -- System\n      RE_Priority,                        -- System\n@@ -1827,6 +1828,7 @@ package Rtsfind is\n      RE_Interrupt_Priority               => System,\n      RE_Lib_Stop                         => System,\n      RE_Low_Order_First                  => System,\n+     RE_Max_Base_Digits                  => System,\n      RE_Max_Priority                     => System,\n      RE_Null_Address                     => System,\n      RE_Priority                         => System,"}, {"sha": "60851e496b3f58e155d8e1451c53a02f14b2314e", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b682ca9298dda6bc78a98ae4bba04dab2a9d26/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b682ca9298dda6bc78a98ae4bba04dab2a9d26/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=15b682ca9298dda6bc78a98ae4bba04dab2a9d26", "patch": "@@ -6958,6 +6958,7 @@ package body Sem_Ch13 is\n \n       if Is_Incomplete_Or_Private_Type (T)\n         and then No (Underlying_Type (T))\n+        and then Get_Pragma_Id (N) /= Pragma_Import\n       then\n          Error_Msg_N\n            (\"representation item must be after full type declaration\", N);"}, {"sha": "337ff456c00f9f11f1729c8892e6e372c7b27aa2", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b682ca9298dda6bc78a98ae4bba04dab2a9d26/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b682ca9298dda6bc78a98ae4bba04dab2a9d26/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=15b682ca9298dda6bc78a98ae4bba04dab2a9d26", "patch": "@@ -15034,13 +15034,15 @@ package body Sem_Ch3 is\n \n    procedure Floating_Point_Type_Declaration (T : Entity_Id; Def : Node_Id) is\n       Digs          : constant Node_Id := Digits_Expression (Def);\n+      Max_Digs_Val  : constant Uint := Digits_Value (Standard_Long_Long_Float);\n       Digs_Val      : Uint;\n       Base_Typ      : Entity_Id;\n       Implicit_Base : Entity_Id;\n       Bound         : Node_Id;\n \n       function Can_Derive_From (E : Entity_Id) return Boolean;\n-      --  Find if given digits value allows derivation from specified type\n+      --  Find if given digits value, and possibly a specified range, allows\n+      --  derivation from specified type\n \n       ---------------------\n       -- Can_Derive_From --\n@@ -15091,24 +15093,47 @@ package body Sem_Ch3 is\n \n       Process_Real_Range_Specification (Def);\n \n-      if Can_Derive_From (Standard_Short_Float) then\n-         Base_Typ := Standard_Short_Float;\n-      elsif Can_Derive_From (Standard_Float) then\n-         Base_Typ := Standard_Float;\n-      elsif Can_Derive_From (Standard_Long_Float) then\n-         Base_Typ := Standard_Long_Float;\n-      elsif Can_Derive_From (Standard_Long_Long_Float) then\n-         Base_Typ := Standard_Long_Long_Float;\n+      --  Check that requested number of digits is not too high.\n+\n+      if Digs_Val > Max_Digs_Val then\n+         --  The check for Max_Base_Digits may be somewhat expensive, as it\n+         --  requires reading System, so only do it when necessary.\n+\n+         declare\n+            Max_Base_Digits : constant Uint :=\n+               Expr_Value (Expression (Parent (RTE (RE_Max_Base_Digits))));\n+         begin\n+            if Digs_Val > Max_Base_Digits then\n+               Error_Msg_Uint_1 := Max_Base_Digits;\n+               Error_Msg_N (\"digits value out of range, maximum is ^\", Digs);\n+\n+            elsif No (Real_Range_Specification (Def)) then\n+               Error_Msg_Uint_1 := Max_Digs_Val;\n+               Error_Msg_N (\"types with more than ^ digits need range spec \"\n+                 & \"('R'M 3.5.7(6))\", Digs);\n+            end if;\n+         end;\n+      end if;\n \n-      --  If we can't derive from any existing type, use long_long_float\n+      Base_Typ := First (Predefined_Float_Types);\n+\n+      while Present (Base_Typ) and then not Can_Derive_From (Base_Typ) loop\n+         Next (Base_Typ);\n+      end loop;\n+\n+      --  If we can't derive from any existing type, use Long_Long_Float\n       --  and give appropriate message explaining the problem.\n \n-      else\n+      if No (Base_Typ) then\n          Base_Typ := Standard_Long_Long_Float;\n \n-         if Digs_Val >= Digits_Value (Standard_Long_Long_Float) then\n-            Error_Msg_Uint_1 := Digits_Value (Standard_Long_Long_Float);\n-            Error_Msg_N (\"digits value out of range, maximum is ^\", Digs);\n+         if Digs_Val > Max_Digs_Val then\n+            --  It might be the case that there is a type with the requested\n+            --  range, just not the combination of digits and range.\n+\n+            Error_Msg_N\n+              (\"no predefined type has requested range and precision\",\n+               Real_Range_Specification (Def));\n \n          else\n             Error_Msg_N"}, {"sha": "3bb93684358096c1b3408b4857acaf84a5b66b85", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 71, "deletions": 3, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b682ca9298dda6bc78a98ae4bba04dab2a9d26/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b682ca9298dda6bc78a98ae4bba04dab2a9d26/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=15b682ca9298dda6bc78a98ae4bba04dab2a9d26", "patch": "@@ -659,6 +659,11 @@ package body Sem_Prag is\n       procedure Process_Import_Or_Interface;\n       --  Common processing for Import of Interface\n \n+      procedure Process_Import_Predefined_Type;\n+      --  Processing for completing a type with pragma Import. This is used\n+      --  to declare types that match predefined C types, especially for cases\n+      --  without corresponding Ada predefined type.\n+\n       procedure Process_Inline (Active : Boolean);\n       --  Common processing for Inline and Inline_Always. The parameter\n       --  indicates if the inline pragma is active, i.e. if it should actually\n@@ -2875,7 +2880,9 @@ package body Sem_Prag is\n             Set_Convention (E, C);\n             Set_Has_Convention_Pragma (E);\n \n-            if Is_Incomplete_Or_Private_Type (E) then\n+            if Is_Incomplete_Or_Private_Type (E)\n+              and then Present (Underlying_Type (E))\n+            then\n                Set_Convention            (Underlying_Type (E), C);\n                Set_Has_Convention_Pragma (Underlying_Type (E), True);\n             end if;\n@@ -3033,7 +3040,8 @@ package body Sem_Prag is\n            or else Rep_Item_Too_Early (E, N)\n          then\n             raise Pragma_Exit;\n-         else\n+\n+         elsif Present (Underlying_Type (E)) then\n             E := Underlying_Type (E);\n          end if;\n \n@@ -3850,6 +3858,58 @@ package body Sem_Prag is\n          end loop;\n       end Process_Generic_List;\n \n+      ------------------------------------\n+      -- Process_Import_Predefined_Type --\n+      ------------------------------------\n+\n+      procedure Process_Import_Predefined_Type is\n+         Loc  : constant Source_Ptr := Sloc (N);\n+         Ftyp : Node_Id := First (Predefined_Float_Types);\n+         Decl : Node_Id;\n+         Def  : Node_Id;\n+         Nam  : Name_Id;\n+      begin\n+         String_To_Name_Buffer (Strval (Expression (Arg3)));\n+         Nam := Name_Find;\n+\n+         while Present (Ftyp) and then Chars (Ftyp) /= Nam loop\n+            Next (Ftyp);\n+         end loop;\n+\n+         if Present (Ftyp) then\n+            --  Don't build a derived type declaration, because predefined C\n+            --  types have no declaration anywhere, so cannot really be named.\n+            --  Instead build a full type declaration, starting with an\n+            --  appropriate type definition is built\n+\n+            if Is_Floating_Point_Type (Ftyp) then\n+               Def := Make_Floating_Point_Definition (Loc,\n+                 Make_Integer_Literal (Loc, Digits_Value (Ftyp)),\n+                 Make_Real_Range_Specification (Loc,\n+                   Make_Real_Literal (Loc, Realval (Type_Low_Bound (Ftyp))),\n+                   Make_Real_Literal (Loc, Realval (Type_High_Bound (Ftyp)))));\n+\n+            else\n+               --  Should never have a predefined type we cannot handle\n+               raise Program_Error;\n+            end if;\n+\n+            --  Build and insert a Full_Type_Declaration, which will be\n+            --  analyzed as soon as this list entry has been analyzed.\n+\n+            Decl := Make_Full_Type_Declaration (Loc,\n+              Make_Defining_Identifier (Loc, Chars (Expression (Arg2))),\n+              Type_Definition => Def);\n+\n+            Insert_After (N, Decl);\n+            Mark_Rewrite_Insertion (Decl);\n+\n+         else\n+            Error_Pragma_Arg (\"no matching type found for pragma%\",\n+            Arg2);\n+         end if;\n+      end Process_Import_Predefined_Type;\n+\n       ---------------------------------\n       -- Process_Import_Or_Interface --\n       ---------------------------------\n@@ -4118,9 +4178,17 @@ package body Sem_Prag is\n                end if;\n             end;\n \n+         elsif Nkind (Parent (Def_Id)) = N_Incomplete_Type_Declaration then\n+            Check_No_Link_Name;\n+            Check_Arg_Count (3);\n+            Check_Arg_Is_Static_Expression (Arg3, Standard_String);\n+\n+            Process_Import_Predefined_Type;\n+\n          else\n             Error_Pragma_Arg\n-              (\"second argument of pragma% must be object or subprogram\",\n+              (\"second argument of pragma% must be object, subprogram\" &\n+               \" or incomplete type\",\n                Arg2);\n          end if;\n "}]}