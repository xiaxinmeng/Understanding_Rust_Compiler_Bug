{"sha": "209ca542cadd7ae7dc174bc74e066ed1de246672", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA5Y2E1NDJjYWRkN2FlN2RjMTc0YmM3NGUwNjZlZDFkZTI0NjY3Mg==", "commit": {"author": {"name": "Prathamesh Kulkarni", "email": "prathamesh.kulkarni@linaro.org", "date": "2016-08-26T08:05:39Z"}, "committer": {"name": "Prathamesh Kulkarni", "email": "prathamesh3492@gcc.gnu.org", "date": "2016-08-26T08:05:39Z"}, "message": "Patch for performing interprocedural bitwise constant propagation.\n\n2016-08-26  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n\t    Martin Jambhor  <mjambor@suse.cz>\n\n\t* common.opt: New option -fipa-bit-cp.\n\t* doc/invoke.texi: Document -fipa-bit-cp.\n\t* opts.c (default_options_table): Add entry for -fipa-bit-cp.\n\t(enable_fdo_optimizations): Check for flag_ipa_bit_cp.\n\t* tree-ssa-ccp.h: New header file.\n\t* tree-ssa-ccp.c: Include tree-ssa-ccp.h\n\t(bit_value_binop_1): Change to bit_value_binop_1 and export it.\n\tReplace all occurences of tree parameter by two new params: signop, int.\n\t(bit_value_unop_1): Change to bit_value_unop and export it.\n\tReplace all occurences of tree parameter by two new params: signop,\n\tint.\n\t(bit_value_binop): Change call from bit_value_binop_1 to\n\tbit_value_binop.\n\t(bit_value_assume_aligned): Likewise.\n\t(bit_value_unop): Change call from bit_value_unop_1 to bit_value_unop.\n\t(do_ssa_ccp): Pass nonzero_p || flag_ipa_cp_bit instead of nonzero_p\n\tto ccp_finalize.\n\t(ccp_finalize): Skip processing if val->mask == 0.\n\t* ipa-cp.c: Include tree-ssa-ccp.h\n\t(ipcp_bits_lattice): New class.\n\t(ipcp_param_lattice (bits_lattice): New member.\n\t(print_all_lattices): Call ipcp_bits_lattice::print.\n\t(set_all_contains_variable): Call ipcp_bits_lattice::set_to_bottom. \n\t(initialize_node_lattices): Likewise.\n\t(propagate_bits_accross_jump_function): New function.\n\t(propagate_constants_accross_call): Call\n\tpropagate_bits_accross_jump_function.\n\t(ipcp_propagate_stage): Store parameter types when in_lto_p is true.\n\t(ipcp_store_bits_results): New function.\n\t(ipcp_driver): Call ipcp_store_bits_results.\n\t* ipa-prop.h (ipa_bits): New struct.\n\t(ipa_jump_func): Add new member bits of type ipa_bits.\n\t(ipa_param_descriptor): Change decl to decl_or_type.\n\t(ipa_get_param): Change decl to decl_or_type and assert on\n\tPARM_DECL.\n\t(ipa_get_type): New function.\n\t(ipcp_transformation_summary): New member bits.\n\t* ipa-prop.c (ipa_get_param_decl_index_1): s/decl/decl_or_type.\n\t(ipa_populate_param_decls): Likewise.\n\t(ipa_dump_param): Likewise.\n\t(ipa_print_node_jump_functions_for_edge): Pretty-print ipa_bits jump\n\tfunction.\n\t(ipa_set_jf_unknown): Set ipa_bits::known to false.\n\t(ipa_compute_jump_functions_for_edge): Compute jump function for bits\n\tpropagation.\n\t(ipa_node_params_t::duplicate): Copy src->bits into dst->bits.\n\t(ipa_write_jump_function): Add streaming for ipa_bits.\n\t(ipa_read_jump_function): Add support for reading streamed ipa_bits.\n\t(write_ipcp_transformation_info): Add streaming for ipa_bits\n\tsummary for ltrans.\n\t(read_ipcp_transfomration_info): Add support for reading streamed ipa_bits.\n\t(ipcp_update_bits): New function.\n\t(ipcp_transform_function): Call ipcp_update_bits.\n\ntestsuite/\n\t* gcc.dg/ipa/propbits-1.c: New test-case.\n\t* gcc.dg/ipa/propbits-2.c: Likewise.\n\t* gcc.dg/ipa/propbits-3.c: Likewise.\n\nCo-Authored-By: Martin Jambor <mjambor@suse.cz>\n\nFrom-SVN: r239769", "tree": {"sha": "f2ddd305549d6c54fec0b9320813b9142aec89ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2ddd305549d6c54fec0b9320813b9142aec89ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/209ca542cadd7ae7dc174bc74e066ed1de246672", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/209ca542cadd7ae7dc174bc74e066ed1de246672", "html_url": "https://github.com/Rust-GCC/gccrs/commit/209ca542cadd7ae7dc174bc74e066ed1de246672", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/209ca542cadd7ae7dc174bc74e066ed1de246672/comments", "author": null, "committer": null, "parents": [{"sha": "f3db1aacf836e97139c70e8240480ea7cfe6b0ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3db1aacf836e97139c70e8240480ea7cfe6b0ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3db1aacf836e97139c70e8240480ea7cfe6b0ba"}], "stats": {"total": 878, "additions": 825, "deletions": 53}, "files": [{"sha": "d4360f766f5741423b983cc0621c8d4356ea412e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=209ca542cadd7ae7dc174bc74e066ed1de246672", "patch": "@@ -1,3 +1,60 @@\n+2016-08-26  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\t    Martin Jambhor  <mjambor@suse.cz>\n+\n+\t* common.opt: New option -fipa-bit-cp.\n+\t* doc/invoke.texi: Document -fipa-bit-cp.\n+\t* opts.c (default_options_table): Add entry for -fipa-bit-cp.\n+\t(enable_fdo_optimizations): Check for flag_ipa_bit_cp.\n+\t* tree-ssa-ccp.h: New header file.\n+\t* tree-ssa-ccp.c: Include tree-ssa-ccp.h\n+\t(bit_value_binop_1): Change to bit_value_binop_1 and export it.\n+\tReplace all occurences of tree parameter by two new params: signop, int.\n+\t(bit_value_unop_1): Change to bit_value_unop and export it.\n+\tReplace all occurences of tree parameter by two new params: signop,\n+\tint.\n+\t(bit_value_binop): Change call from bit_value_binop_1 to\n+\tbit_value_binop.\n+\t(bit_value_assume_aligned): Likewise.\n+\t(bit_value_unop): Change call from bit_value_unop_1 to bit_value_unop.\n+\t(do_ssa_ccp): Pass nonzero_p || flag_ipa_cp_bit instead of nonzero_p\n+\tto ccp_finalize.\n+\t(ccp_finalize): Skip processing if val->mask == 0.\n+\t* ipa-cp.c: Include tree-ssa-ccp.h\n+\t(ipcp_bits_lattice): New class.\n+\t(ipcp_param_lattice (bits_lattice): New member.\n+\t(print_all_lattices): Call ipcp_bits_lattice::print.\n+\t(set_all_contains_variable): Call ipcp_bits_lattice::set_to_bottom. \n+\t(initialize_node_lattices): Likewise.\n+\t(propagate_bits_accross_jump_function): New function.\n+\t(propagate_constants_accross_call): Call\n+\tpropagate_bits_accross_jump_function.\n+\t(ipcp_propagate_stage): Store parameter types when in_lto_p is true.\n+\t(ipcp_store_bits_results): New function.\n+\t(ipcp_driver): Call ipcp_store_bits_results.\n+\t* ipa-prop.h (ipa_bits): New struct.\n+\t(ipa_jump_func): Add new member bits of type ipa_bits.\n+\t(ipa_param_descriptor): Change decl to decl_or_type.\n+\t(ipa_get_param): Change decl to decl_or_type and assert on\n+\tPARM_DECL.\n+\t(ipa_get_type): New function.\n+\t(ipcp_transformation_summary): New member bits.\n+\t* ipa-prop.c (ipa_get_param_decl_index_1): s/decl/decl_or_type.\n+\t(ipa_populate_param_decls): Likewise.\n+\t(ipa_dump_param): Likewise.\n+\t(ipa_print_node_jump_functions_for_edge): Pretty-print ipa_bits jump\n+\tfunction.\n+\t(ipa_set_jf_unknown): Set ipa_bits::known to false.\n+\t(ipa_compute_jump_functions_for_edge): Compute jump function for bits\n+\tpropagation.\n+\t(ipa_node_params_t::duplicate): Copy src->bits into dst->bits.\n+\t(ipa_write_jump_function): Add streaming for ipa_bits.\n+\t(ipa_read_jump_function): Add support for reading streamed ipa_bits.\n+\t(write_ipcp_transformation_info): Add streaming for ipa_bits\n+\tsummary for ltrans.\n+\t(read_ipcp_transfomration_info): Add support for reading streamed ipa_bits.\n+\t(ipcp_update_bits): New function.\n+\t(ipcp_transform_function): Call ipcp_update_bits.\n+\n 2016-08-25  Szabolcs Nagy  <szabolcs.nagy@arm.com>\n \n \t* config/mips/linux.h (MUSL_DYNAMIC_LINKER32): Update."}, {"sha": "fd1ac87ddabd9fee23c053511f4c1ed48ec1c35b", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=209ca542cadd7ae7dc174bc74e066ed1de246672", "patch": "@@ -1561,6 +1561,10 @@ fipa-cp-alignment\n Common Report Var(flag_ipa_cp_alignment) Optimization\n Perform alignment discovery and propagation to make Interprocedural constant propagation stronger.\n \n+fipa-bit-cp\n+Common Report Var(flag_ipa_bit_cp) Optimization\n+Perform interprocedural bitwise constant propagation.\n+\n fipa-profile\n Common Report Var(flag_ipa_profile) Init(0) Optimization\n Perform interprocedural profile propagation."}, {"sha": "baae0bd9bfd59f0d96b37ed8d73e6ffaa5657a7b", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=209ca542cadd7ae7dc174bc74e066ed1de246672", "patch": "@@ -358,7 +358,7 @@ Objective-C and Objective-C++ Dialects}.\n -fgcse-sm -fhoist-adjacent-loads -fif-conversion @gol\n -fif-conversion2 -findirect-inlining @gol\n -finline-functions -finline-functions-called-once -finline-limit=@var{n} @gol\n--finline-small-functions -fipa-cp -fipa-cp-clone -fipa-cp-alignment @gol\n+-finline-small-functions -fipa-cp -fipa-cp-clone -fipa-cp-alignment -fipa-bit-cp @gol\n -fipa-pta -fipa-profile -fipa-pure-const -fipa-reference -fipa-icf @gol\n -fira-algorithm=@var{algorithm} @gol\n -fira-region=@var{region} -fira-hoist-pressure @gol\n@@ -6370,6 +6370,7 @@ also turns on the following optimization flags:\n -findirect-inlining @gol\n -fipa-cp @gol\n -fipa-cp-alignment @gol\n+-fipa-bit-cp @gol\n -fipa-sra @gol\n -fipa-icf @gol\n -fisolate-erroneous-paths-dereference @gol\n@@ -7378,6 +7379,12 @@ parameters to support better vectorization and string operations.\n This flag is enabled by default at @option{-O2} and @option{-Os}.  It\n requires that @option{-fipa-cp} is enabled.\n \n+@item -fipa-bit-cp\n+@opindex -fipa-bit-cp\n+When enabled, perform ipa bitwise constant propagation. This flag is\n+enabled by default at @option{-O2}. It requires that @option{-fipa-cp}\n+is enabled.\n+\n @item -fipa-icf\n @opindex fipa-icf\n Perform Identical Code Folding for functions and read-only variables."}, {"sha": "9514dd1817780d938960de8aaf0f848ad34ed4ed", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 384, "deletions": 0, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=209ca542cadd7ae7dc174bc74e066ed1de246672", "patch": "@@ -120,6 +120,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"ipa-inline.h\"\n #include \"ipa-utils.h\"\n+#include \"tree-ssa-ccp.h\"\n \n template <typename valtype> class ipcp_value;\n \n@@ -266,6 +267,60 @@ class ipcp_alignment_lattice\n   bool meet_with_1 (unsigned new_align, unsigned new_misalign);\n };\n \n+/* Lattice of known bits, only capable of holding one value.\n+   Bitwise constant propagation propagates which bits of a\n+   value are constant.\n+   For eg:\n+   int f(int x)\n+   {\n+     return some_op (x);\n+   }\n+\n+   int f1(int y)\n+   {\n+     if (cond)\n+      return f (y & 0xff);\n+     else\n+      return f (y & 0xf);\n+   }\n+\n+   In the above case, the param 'x' will always have all\n+   the bits (except the bits in lsb) set to 0.\n+   Hence the mask of 'x' would be 0xff. The mask\n+   reflects that the bits in lsb are unknown.\n+   The actual propagated value is given by m_value & ~m_mask.  */\n+\n+class ipcp_bits_lattice\n+{\n+public:\n+  bool bottom_p () { return m_lattice_val == IPA_BITS_VARYING; }\n+  bool top_p () { return m_lattice_val == IPA_BITS_UNDEFINED; }\n+  bool constant_p () { return m_lattice_val == IPA_BITS_CONSTANT; }\n+  bool set_to_bottom ();\n+  bool set_to_constant (widest_int, widest_int); \n+ \n+  widest_int get_value () { return m_value; }\n+  widest_int get_mask () { return m_mask; }\n+\n+  bool meet_with (ipcp_bits_lattice& other, unsigned, signop,\n+\t\t  enum tree_code, tree);\n+\n+  bool meet_with (widest_int, widest_int, unsigned);\n+\n+  void print (FILE *);\n+\n+private:\n+  enum { IPA_BITS_UNDEFINED, IPA_BITS_CONSTANT, IPA_BITS_VARYING } m_lattice_val;\n+\n+  /* Similar to ccp_lattice_t, mask represents which bits of value are constant.\n+     If a bit in mask is set to 0, then the corresponding bit in\n+     value is known to be constant.  */\n+  widest_int m_value, m_mask;\n+\n+  bool meet_with_1 (widest_int, widest_int, unsigned); \n+  void get_value_and_mask (tree, widest_int *, widest_int *);\n+}; \n+\n /* Structure containing lattices for a parameter itself and for pieces of\n    aggregates that are passed in the parameter or by a reference in a parameter\n    plus some other useful flags.  */\n@@ -281,6 +336,8 @@ class ipcp_param_lattices\n   ipcp_agg_lattice *aggs;\n   /* Lattice describing known alignment.  */\n   ipcp_alignment_lattice alignment;\n+  /* Lattice describing known bits.  */\n+  ipcp_bits_lattice bits_lattice;\n   /* Number of aggregate lattices */\n   int aggs_count;\n   /* True if aggregate data were passed by reference (as opposed to by\n@@ -458,6 +515,21 @@ ipcp_alignment_lattice::print (FILE * f)\n     fprintf (f, \"         Alignment %u, misalignment %u\\n\", align, misalign);\n }\n \n+void\n+ipcp_bits_lattice::print (FILE *f)\n+{\n+  if (top_p ())\n+    fprintf (f, \"         Bits unknown (TOP)\\n\");\n+  else if (bottom_p ())\n+    fprintf (f, \"         Bits unusable (BOTTOM)\\n\");\n+  else\n+    {\n+      fprintf (f, \"         Bits: value = \"); print_hex (get_value (), f);\n+      fprintf (f, \", mask = \"); print_hex (get_mask (), f);\n+      fprintf (f, \"\\n\");\n+    }\n+}\n+\n /* Print all ipcp_lattices of all functions to F.  */\n \n static void\n@@ -484,6 +556,7 @@ print_all_lattices (FILE * f, bool dump_sources, bool dump_benefits)\n \t  fprintf (f, \"         ctxs: \");\n \t  plats->ctxlat.print (f, dump_sources, dump_benefits);\n \t  plats->alignment.print (f);\n+\t  plats->bits_lattice.print (f);\n \t  if (plats->virt_call)\n \t    fprintf (f, \"        virt_call flag set\\n\");\n \n@@ -911,6 +984,151 @@ ipcp_alignment_lattice::meet_with (const ipcp_alignment_lattice &other,\n   return meet_with_1 (other.align, adjusted_misalign);\n }\n \n+/* Set lattice value to bottom, if it already isn't the case.  */\n+\n+bool\n+ipcp_bits_lattice::set_to_bottom ()\n+{\n+  if (bottom_p ())\n+    return false;\n+  m_lattice_val = IPA_BITS_VARYING;\n+  m_value = 0;\n+  m_mask = -1;\n+  return true;\n+}\n+\n+/* Set to constant if it isn't already. Only meant to be called\n+   when switching state from TOP.  */\n+\n+bool\n+ipcp_bits_lattice::set_to_constant (widest_int value, widest_int mask)\n+{\n+  gcc_assert (top_p ());\n+  m_lattice_val = IPA_BITS_CONSTANT;\n+  m_value = value;\n+  m_mask = mask;\n+  return true;\n+}\n+\n+/* Convert operand to value, mask form.  */\n+\n+void\n+ipcp_bits_lattice::get_value_and_mask (tree operand, widest_int *valuep, widest_int *maskp)\n+{\n+  wide_int get_nonzero_bits (const_tree);\n+\n+  if (TREE_CODE (operand) == INTEGER_CST)\n+    {\n+      *valuep = wi::to_widest (operand); \n+      *maskp = 0;\n+    }\n+  else\n+    {\n+      *valuep = 0;\n+      *maskp = -1;\n+    }\n+}\n+\n+/* Meet operation, similar to ccp_lattice_meet, we xor values\n+   if this->value, value have different values at same bit positions, we want\n+   to drop that bit to varying. Return true if mask is changed.\n+   This function assumes that the lattice value is in CONSTANT state  */\n+\n+bool\n+ipcp_bits_lattice::meet_with_1 (widest_int value, widest_int mask,\n+\t\t\t\tunsigned precision)\n+{\n+  gcc_assert (constant_p ());\n+  \n+  widest_int old_mask = m_mask; \n+  m_mask = (m_mask | mask) | (m_value ^ value);\n+\n+  if (wi::sext (m_mask, precision) == -1)\n+    return set_to_bottom ();\n+\n+  return m_mask != old_mask;\n+}\n+\n+/* Meet the bits lattice with operand\n+   described by <value, mask, sgn, precision.  */\n+\n+bool\n+ipcp_bits_lattice::meet_with (widest_int value, widest_int mask,\n+\t\t\t      unsigned precision)\n+{\n+  if (bottom_p ())\n+    return false;\n+\n+  if (top_p ())\n+    {\n+      if (wi::sext (mask, precision) == -1)\n+\treturn set_to_bottom ();\n+      return set_to_constant (value, mask); \n+    }\n+\n+  return meet_with_1 (value, mask, precision);\n+}\n+\n+/* Meet bits lattice with the result of bit_value_binop (other, operand)\n+   if code is binary operation or bit_value_unop (other) if code is unary op.\n+   In the case when code is nop_expr, no adjustment is required. */\n+\n+bool\n+ipcp_bits_lattice::meet_with (ipcp_bits_lattice& other, unsigned precision,\n+\t\t\t      signop sgn, enum tree_code code, tree operand)\n+{\n+  if (other.bottom_p ())\n+    return set_to_bottom ();\n+\n+  if (bottom_p () || other.top_p ())\n+    return false;\n+\n+  widest_int adjusted_value, adjusted_mask;\n+\n+  if (TREE_CODE_CLASS (code) == tcc_binary)\n+    {\n+      tree type = TREE_TYPE (operand);\n+      gcc_assert (INTEGRAL_TYPE_P (type));\n+      widest_int o_value, o_mask;\n+      get_value_and_mask (operand, &o_value, &o_mask);\n+\n+      bit_value_binop (code, sgn, precision, &adjusted_value, &adjusted_mask,\n+\t\t       sgn, precision, other.get_value (), other.get_mask (),\n+\t\t       TYPE_SIGN (type), TYPE_PRECISION (type), o_value, o_mask);\n+\n+      if (wi::sext (adjusted_mask, precision) == -1)\n+\treturn set_to_bottom ();\n+    }\n+\n+  else if (TREE_CODE_CLASS (code) == tcc_unary)\n+    {\n+      bit_value_unop (code, sgn, precision, &adjusted_value,\n+\t\t      &adjusted_mask, sgn, precision, other.get_value (),\n+\t\t      other.get_mask ());\n+\n+      if (wi::sext (adjusted_mask, precision) == -1)\n+\treturn set_to_bottom ();\n+    }\n+\n+  else if (code == NOP_EXPR)\n+    {\n+      adjusted_value = other.m_value;\n+      adjusted_mask = other.m_mask;\n+    }\n+\n+  else\n+    return set_to_bottom ();\n+\n+  if (top_p ())\n+    {\n+      if (wi::sext (adjusted_mask, precision) == -1)\n+\treturn set_to_bottom ();\n+      return set_to_constant (adjusted_value, adjusted_mask); \n+    }\n+  else\n+    return meet_with_1 (adjusted_value, adjusted_mask, precision);\n+}\n+\n /* Mark bot aggregate and scalar lattices as containing an unknown variable,\n    return true is any of them has not been marked as such so far.  */\n \n@@ -922,6 +1140,7 @@ set_all_contains_variable (struct ipcp_param_lattices *plats)\n   ret |= plats->ctxlat.set_contains_variable ();\n   ret |= set_agg_lats_contain_variable (plats);\n   ret |= plats->alignment.set_to_bottom ();\n+  ret |= plats->bits_lattice.set_to_bottom ();\n   return ret;\n }\n \n@@ -1003,6 +1222,7 @@ initialize_node_lattices (struct cgraph_node *node)\n \t      plats->ctxlat.set_to_bottom ();\n \t      set_agg_lats_to_bottom (plats);\n \t      plats->alignment.set_to_bottom ();\n+\t      plats->bits_lattice.set_to_bottom ();\n \t    }\n \t  else\n \t    set_all_contains_variable (plats);\n@@ -1621,6 +1841,78 @@ propagate_alignment_accross_jump_function (cgraph_edge *cs,\n     }\n }\n \n+/* Propagate bits across jfunc that is associated with\n+   edge cs and update dest_lattice accordingly.  */\n+\n+bool\n+propagate_bits_accross_jump_function (cgraph_edge *cs, int idx, ipa_jump_func *jfunc,\n+\t\t\t\t      ipcp_bits_lattice *dest_lattice)\n+{\n+  if (dest_lattice->bottom_p ())\n+    return false;\n+\n+  enum availability availability;\n+  cgraph_node *callee = cs->callee->function_symbol (&availability);\n+  struct ipa_node_params *callee_info = IPA_NODE_REF (callee);\n+  tree parm_type = ipa_get_type (callee_info, idx);\n+\n+  /* For K&R C programs, ipa_get_type() could return NULL_TREE.\n+     Avoid the transform for these cases.  */\n+  if (!parm_type)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Setting dest_lattice to bottom, because\"\n+\t\t\t    \"param %i type is NULL for %s\\n\", idx,\n+\t\t\t    cs->callee->name ());\n+\n+      return dest_lattice->set_to_bottom ();\n+    }\n+\n+  unsigned precision = TYPE_PRECISION (parm_type);\n+  signop sgn = TYPE_SIGN (parm_type);\n+\n+  if (jfunc->type == IPA_JF_PASS_THROUGH)\n+    {\n+      struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      enum tree_code code = ipa_get_jf_pass_through_operation (jfunc);\n+      tree operand = NULL_TREE;\n+\n+      if (code != NOP_EXPR)\n+\toperand = ipa_get_jf_pass_through_operand (jfunc);\n+\n+      int src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n+      struct ipcp_param_lattices *src_lats\n+\t= ipa_get_parm_lattices (caller_info, src_idx);\n+\n+      /* Try to propagate bits if src_lattice is bottom, but jfunc is known.\n+\t for eg consider:\n+\t int f(int x)\n+\t {\n+\t   g (x & 0xff);\n+\t }\n+\t Assume lattice for x is bottom, however we can still propagate\n+\t result of x & 0xff == 0xff, which gets computed during ccp1 pass\n+\t and we store it in jump function during analysis stage.  */\n+\n+      if (src_lats->bits_lattice.bottom_p ()\n+\t  && jfunc->bits.known)\n+\treturn dest_lattice->meet_with (jfunc->bits.value, jfunc->bits.mask,\n+\t\t\t\t\tprecision);\n+      else\n+\treturn dest_lattice->meet_with (src_lats->bits_lattice, precision, sgn,\n+\t\t\t\t\tcode, operand);\n+    }\n+\n+  else if (jfunc->type == IPA_JF_ANCESTOR)\n+    return dest_lattice->set_to_bottom ();\n+\n+  else if (jfunc->bits.known) \n+    return dest_lattice->meet_with (jfunc->bits.value, jfunc->bits.mask, precision);\n+  \n+  else\n+    return dest_lattice->set_to_bottom ();\n+}\n+\n /* If DEST_PLATS already has aggregate items, check that aggs_by_ref matches\n    NEW_AGGS_BY_REF and if not, mark all aggs as bottoms and return true (in all\n    other cases, return false).  If there are no aggregate items, set\n@@ -1968,6 +2260,8 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n \t\t\t\t\t\t\t  &dest_plats->ctxlat);\n \t  ret |= propagate_alignment_accross_jump_function (cs, jump_func,\n \t\t\t\t\t\t\t &dest_plats->alignment);\n+\t  ret |= propagate_bits_accross_jump_function (cs, i, jump_func,\n+\t\t\t\t\t\t       &dest_plats->bits_lattice);\n \t  ret |= propagate_aggs_accross_jump_function (cs, jump_func,\n \t\t\t\t\t\t       dest_plats);\n \t}\n@@ -2936,6 +3230,19 @@ ipcp_propagate_stage (struct ipa_topo_info *topo)\n   {\n     struct ipa_node_params *info = IPA_NODE_REF (node);\n \n+    /* In LTO we do not have PARM_DECLs but we would still like to be able to\n+       look at types of parameters.  */\n+    if (in_lto_p)\n+      {\n+\ttree t = TYPE_ARG_TYPES (TREE_TYPE (node->decl));\n+\tfor (int k = 0; k < ipa_get_param_count (info) && t; k++)\n+\t  {\n+\t    gcc_assert (t != void_list_node);\n+\t    info->descriptors[k].decl_or_type = TREE_VALUE (t);\n+\t    t = t ? TREE_CHAIN (t) : NULL;\n+\t  }\n+      }\n+\n     determine_versionability (node, info);\n     if (node->has_gimple_body_p ())\n       {\n@@ -4592,6 +4899,81 @@ ipcp_store_alignment_results (void)\n   }\n }\n \n+/* Look up all the bits information that we have discovered and copy it over\n+   to the transformation summary.  */\n+\n+static void\n+ipcp_store_bits_results (void)\n+{\n+  cgraph_node *node;\n+\n+  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n+    {\n+      ipa_node_params *info = IPA_NODE_REF (node);\n+      bool dumped_sth = false;\n+      bool found_useful_result = false;\n+\n+      if (!opt_for_fn (node->decl, flag_ipa_bit_cp))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Not considering %s for ipa bitwise propagation \"\n+\t\t\t\t\"; -fipa-cp-bit: disabled.\\n\",\n+\t\t\t\tnode->name ());\n+\t  continue;\n+\t}\n+\n+      if (info->ipcp_orig_node)\n+\tinfo = IPA_NODE_REF (info->ipcp_orig_node);\n+\n+      unsigned count = ipa_get_param_count (info);\n+      for (unsigned i = 0; i < count; i++)\n+\t{\n+\t  ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+\t  if (plats->bits_lattice.constant_p ())\n+\t    {\n+\t      found_useful_result = true;\n+\t      break;\n+\t    }\n+\t}\n+\n+    if (!found_useful_result)\n+      continue;\n+\n+    ipcp_grow_transformations_if_necessary ();\n+    ipcp_transformation_summary *ts = ipcp_get_transformation_summary (node);\n+    vec_safe_reserve_exact (ts->bits, count);\n+\n+    for (unsigned i = 0; i < count; i++)\n+      {\n+\tipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+\tipa_bits bits_jfunc;\t\t\t \n+\n+\tif (plats->bits_lattice.constant_p ())\n+\t  {\n+\t    bits_jfunc.known = true;\n+\t    bits_jfunc.value = plats->bits_lattice.get_value ();\n+\t    bits_jfunc.mask = plats->bits_lattice.get_mask ();\n+\t  }\n+\telse\n+\t  bits_jfunc.known = false;\n+\n+\tts->bits->quick_push (bits_jfunc);\n+\tif (!dump_file || !bits_jfunc.known)\n+\t  continue;\n+\tif (!dumped_sth)\n+\t  {\n+\t    fprintf (dump_file, \"Propagated bits info for function %s/%i:\\n\",\n+\t\t\t\tnode->name (), node->order);\n+\t    dumped_sth = true;\n+\t  }\n+\tfprintf (dump_file, \" param %i: value = \", i);\n+\tprint_hex (bits_jfunc.value, dump_file);\n+\tfprintf (dump_file, \", mask = \");\n+\tprint_hex (bits_jfunc.mask, dump_file);\n+\tfprintf (dump_file, \"\\n\");\n+      }\n+    }\n+}\n /* The IPCP driver.  */\n \n static unsigned int\n@@ -4625,6 +5007,8 @@ ipcp_driver (void)\n   ipcp_decision_stage (&topo);\n   /* Store results of alignment propagation. */\n   ipcp_store_alignment_results ();\n+  /* Store results of bits propagation.  */\n+  ipcp_store_bits_results ();\n \n   /* Free all IPCP structures.  */\n   free_toporder_info (&topo);"}, {"sha": "16297817f95423126430979158f2788605126e1e", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 159, "deletions": 4, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=209ca542cadd7ae7dc174bc74e066ed1de246672", "patch": "@@ -105,7 +105,7 @@ ipa_get_param_decl_index_1 (vec<ipa_param_descriptor> descriptors, tree ptree)\n \n   count = descriptors.length ();\n   for (i = 0; i < count; i++)\n-    if (descriptors[i].decl == ptree)\n+    if (descriptors[i].decl_or_type == ptree)\n       return i;\n \n   return -1;\n@@ -138,7 +138,7 @@ ipa_populate_param_decls (struct cgraph_node *node,\n   param_num = 0;\n   for (parm = fnargs; parm; parm = DECL_CHAIN (parm))\n     {\n-      descriptors[param_num].decl = parm;\n+      descriptors[param_num].decl_or_type = parm;\n       descriptors[param_num].move_cost = estimate_move_cost (TREE_TYPE (parm),\n \t\t\t\t\t\t\t     true);\n       param_num++;\n@@ -168,10 +168,10 @@ void\n ipa_dump_param (FILE *file, struct ipa_node_params *info, int i)\n {\n   fprintf (file, \"param #%i\", i);\n-  if (info->descriptors[i].decl)\n+  if (info->descriptors[i].decl_or_type)\n     {\n       fprintf (file, \" \");\n-      print_generic_expr (file, info->descriptors[i].decl, 0);\n+      print_generic_expr (file, info->descriptors[i].decl_or_type, 0);\n     }\n }\n \n@@ -302,6 +302,15 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \t}\n       else\n \tfprintf (f, \"         Unknown alignment\\n\");\n+\n+      if (jump_func->bits.known)\n+\t{\n+\t  fprintf (f, \"         value: \"); print_hex (jump_func->bits.value, f);\n+\t  fprintf (f, \", mask: \"); print_hex (jump_func->bits.mask, f);\n+\t  fprintf (f, \"\\n\");\n+\t}\n+      else\n+\tfprintf (f, \"         Unknown bits\\n\");\n     }\n }\n \n@@ -381,6 +390,7 @@ ipa_set_jf_unknown (struct ipa_jump_func *jfunc)\n {\n   jfunc->type = IPA_JF_UNKNOWN;\n   jfunc->alignment.known = false;\n+  jfunc->bits.known = false;\n }\n \n /* Set JFUNC to be a copy of another jmp (to be used by jump function\n@@ -1674,6 +1684,26 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n       else\n \tgcc_assert (!jfunc->alignment.known);\n \n+      if (INTEGRAL_TYPE_P (TREE_TYPE (arg))\n+\t  && (TREE_CODE (arg) == SSA_NAME || TREE_CODE (arg) == INTEGER_CST))\n+\t{\n+\t  jfunc->bits.known = true;\n+\t  \n+\t  if (TREE_CODE (arg) == SSA_NAME)\n+\t    {\n+\t      jfunc->bits.value = 0;\n+\t      jfunc->bits.mask = widest_int::from (get_nonzero_bits (arg),\n+\t\t\t\t\t\t   TYPE_SIGN (TREE_TYPE (arg)));\n+\t    }\n+\t  else\n+\t    {\n+\t      jfunc->bits.value = wi::to_widest (arg);\n+\t      jfunc->bits.mask = 0;\n+\t    }\n+\t}\n+      else\n+\tgcc_assert (!jfunc->bits.known);\n+\n       if (is_gimple_ip_invariant (arg)\n \t  || (TREE_CODE (arg) == VAR_DECL\n \t      && is_global_var (arg)\n@@ -3690,6 +3720,18 @@ ipa_node_params_t::duplicate(cgraph_node *src, cgraph_node *dst,\n       for (unsigned i = 0; i < src_alignments->length (); ++i)\n \tdst_alignments->quick_push ((*src_alignments)[i]);\n     }\n+\n+  if (src_trans && vec_safe_length (src_trans->bits) > 0)\n+    {\n+      ipcp_grow_transformations_if_necessary ();\n+      src_trans = ipcp_get_transformation_summary (src);\n+      const vec<ipa_bits, va_gc> *src_bits = src_trans->bits;\n+      vec<ipa_bits, va_gc> *&dst_bits\n+\t= ipcp_get_transformation_summary (dst)->bits;\n+      vec_safe_reserve_exact (dst_bits, src_bits->length ());\n+      for (unsigned i = 0; i < src_bits->length (); ++i)\n+\tdst_bits->quick_push ((*src_bits)[i]);\n+    }\n }\n \n /* Register our cgraph hooks if they are not already there.  */\n@@ -4609,6 +4651,15 @@ ipa_write_jump_function (struct output_block *ob,\n       streamer_write_uhwi (ob, jump_func->alignment.align);\n       streamer_write_uhwi (ob, jump_func->alignment.misalign);\n     }\n+\n+  bp = bitpack_create (ob->main_stream);\n+  bp_pack_value (&bp, jump_func->bits.known, 1);\n+  streamer_write_bitpack (&bp);\n+  if (jump_func->bits.known)\n+    {\n+      streamer_write_widest_int (ob, jump_func->bits.value);\n+      streamer_write_widest_int (ob, jump_func->bits.mask);\n+    }   \n }\n \n /* Read in jump function JUMP_FUNC from IB.  */\n@@ -4685,6 +4736,17 @@ ipa_read_jump_function (struct lto_input_block *ib,\n     }\n   else\n     jump_func->alignment.known = false;\n+\n+  bp = streamer_read_bitpack (ib);\n+  bool bits_known = bp_unpack_value (&bp, 1);\n+  if (bits_known)\n+    {\n+      jump_func->bits.known = true;\n+      jump_func->bits.value = streamer_read_widest_int (ib);\n+      jump_func->bits.mask = streamer_read_widest_int (ib);\n+    }\n+  else\n+    jump_func->bits.known = false;\n }\n \n /* Stream out parts of cgraph_indirect_call_info corresponding to CS that are\n@@ -5050,6 +5112,28 @@ write_ipcp_transformation_info (output_block *ob, cgraph_node *node)\n     }\n   else\n     streamer_write_uhwi (ob, 0);\n+\n+  ts = ipcp_get_transformation_summary (node);\n+  if (ts && vec_safe_length (ts->bits) > 0)\n+    {\n+      count = ts->bits->length ();\n+      streamer_write_uhwi (ob, count);\n+\n+      for (unsigned i = 0; i < count; ++i)\n+\t{\n+\t  const ipa_bits& bits_jfunc = (*ts->bits)[i];\n+\t  struct bitpack_d bp = bitpack_create (ob->main_stream);\n+\t  bp_pack_value (&bp, bits_jfunc.known, 1);\n+\t  streamer_write_bitpack (&bp);\n+\t  if (bits_jfunc.known)\n+\t    {\n+\t      streamer_write_widest_int (ob, bits_jfunc.value);\n+\t      streamer_write_widest_int (ob, bits_jfunc.mask);\n+\t    }\n+\t}\n+    }\n+  else\n+    streamer_write_uhwi (ob, 0);\n }\n \n /* Stream in the aggregate value replacement chain for NODE from IB.  */\n@@ -5102,6 +5186,26 @@ read_ipcp_transformation_info (lto_input_block *ib, cgraph_node *node,\n \t    }\n \t}\n     }\n+\n+  count = streamer_read_uhwi (ib);\n+  if (count > 0)\n+    {\n+      ipcp_grow_transformations_if_necessary ();\n+      ipcp_transformation_summary *ts = ipcp_get_transformation_summary (node);\n+      vec_safe_grow_cleared (ts->bits, count);\n+\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  ipa_bits& bits_jfunc = (*ts->bits)[i];\n+\t  struct bitpack_d bp = streamer_read_bitpack (ib);\n+\t  bits_jfunc.known = bp_unpack_value (&bp, 1);\n+\t  if (bits_jfunc.known)\n+\t    {\n+\t      bits_jfunc.value = streamer_read_widest_int (ib);\n+\t      bits_jfunc.mask = streamer_read_widest_int (ib);\n+\t    }\n+\t}\n+    }\n }\n \n /* Write all aggregate replacement for nodes in set.  */\n@@ -5404,6 +5508,56 @@ ipcp_update_alignments (struct cgraph_node *node)\n     }\n }\n \n+/* Update bits info of formal parameters as described in\n+   ipcp_transformation_summary.  */\n+\n+static void\n+ipcp_update_bits (struct cgraph_node *node)\n+{\n+  tree parm = DECL_ARGUMENTS (node->decl);\n+  tree next_parm = parm;\n+  ipcp_transformation_summary *ts = ipcp_get_transformation_summary (node);\n+\n+  if (!ts || vec_safe_length (ts->bits) == 0)\n+    return;\n+\n+  vec<ipa_bits, va_gc> &bits = *ts->bits;\n+  unsigned count = bits.length ();\n+\n+  for (unsigned i = 0; i < count; ++i, parm = next_parm)\n+    {\n+      if (node->clone.combined_args_to_skip\n+\t  && bitmap_bit_p (node->clone.combined_args_to_skip, i))\n+\tcontinue;\n+\n+      gcc_checking_assert (parm);\n+      next_parm = DECL_CHAIN (parm);\n+\n+      if (!bits[i].known\n+\t  || !INTEGRAL_TYPE_P (TREE_TYPE (parm))\n+\t  || !is_gimple_reg (parm))\n+\tcontinue;       \n+\n+      tree ddef = ssa_default_def (DECL_STRUCT_FUNCTION (node->decl), parm);\n+      if (!ddef)\n+\tcontinue;\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Adjusting mask for param %u to \", i); \n+\t  print_hex (bits[i].mask, dump_file);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      unsigned prec = TYPE_PRECISION (TREE_TYPE (ddef));\n+      signop sgn = TYPE_SIGN (TREE_TYPE (ddef));\n+\n+      wide_int nonzero_bits = wide_int::from (bits[i].mask, prec, UNSIGNED)\n+\t\t\t      | wide_int::from (bits[i].value, prec, sgn);\n+      set_nonzero_bits (ddef, nonzero_bits);\n+    }\n+}\n+\n /* IPCP transformation phase doing propagation of aggregate values.  */\n \n unsigned int\n@@ -5423,6 +5577,7 @@ ipcp_transform_function (struct cgraph_node *node)\n \t     node->name (), node->order);\n \n   ipcp_update_alignments (node);\n+  ipcp_update_bits (node);\n   aggval = ipa_get_agg_replacements_for_node (node);\n   if (!aggval)\n       return 0;"}, {"sha": "e5a56daeced547b55e1e3e166e2a788f7b7c1f6f", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=209ca542cadd7ae7dc174bc74e066ed1de246672", "patch": "@@ -154,6 +154,19 @@ struct GTY(()) ipa_alignment\n   unsigned misalign;\n };\n \n+/* Information about zero/non-zero bits.  */\n+struct GTY(()) ipa_bits\n+{\n+  /* The propagated value.  */\n+  widest_int value;\n+  /* Mask corresponding to the value.\n+     Similar to ccp_lattice_t, if xth bit of mask is 0,\n+     implies xth bit of value is constant.  */\n+  widest_int mask;\n+  /* True if jump function is known.  */\n+  bool known;\n+};\n+\n /* A jump function for a callsite represents the values passed as actual\n    arguments of the callsite. See enum jump_func_type for the various\n    types of jump functions supported.  */\n@@ -166,6 +179,9 @@ struct GTY (()) ipa_jump_func\n   /* Information about alignment of pointers. */\n   struct ipa_alignment alignment;\n \n+  /* Information about zero/non-zero bits.  */\n+  struct ipa_bits bits;\n+\n   enum jump_func_type type;\n   /* Represents a value of a jump function.  pass_through is used only in jump\n      function context.  constant represents the actual constant in constant jump\n@@ -283,8 +299,11 @@ ipa_get_jf_ancestor_type_preserved (struct ipa_jump_func *jfunc)\n \n struct ipa_param_descriptor\n {\n-  /* PARAM_DECL of this parameter.  */\n-  tree decl;\n+  /* In analysis and modification phase, this is the PARAM_DECL of this\n+     parameter, in IPA LTO phase, this is the type of the the described\n+     parameter or NULL if not known.  Do not read this field directly but\n+     through ipa_get_param and ipa_get_type as appropriate.  */\n+  tree decl_or_type;\n   /* If all uses of the parameter are described by ipa-prop structures, this\n      says how many there are.  If any use could not be described by means of\n      ipa-prop structures, this is IPA_UNDESCRIBED_USE.  */\n@@ -402,13 +421,31 @@ ipa_get_param_count (struct ipa_node_params *info)\n \n /* Return the declaration of Ith formal parameter of the function corresponding\n    to INFO.  Note there is no setter function as this array is built just once\n-   using ipa_initialize_node_params. */\n+   using ipa_initialize_node_params.  This function should not be called in\n+   WPA.  */\n \n static inline tree\n ipa_get_param (struct ipa_node_params *info, int i)\n {\n   gcc_checking_assert (!flag_wpa);\n-  return info->descriptors[i].decl;\n+  tree t = info->descriptors[i].decl_or_type;\n+  gcc_checking_assert (TREE_CODE (t) == PARM_DECL);\n+  return t;\n+}\n+\n+/* Return the type of Ith formal parameter of the function corresponding\n+   to INFO if it is known or NULL if not.  */\n+\n+static inline tree\n+ipa_get_type (struct ipa_node_params *info, int i)\n+{\n+  tree t = info->descriptors[i].decl_or_type;\n+  if (!t)\n+    return NULL;\n+  if (TYPE_P (t))\n+    return t;\n+  gcc_checking_assert (TREE_CODE (t) == PARM_DECL);\n+  return TREE_TYPE (t);\n }\n \n /* Return the move cost of Ith formal parameter of the function corresponding\n@@ -482,6 +519,8 @@ struct GTY(()) ipcp_transformation_summary\n   ipa_agg_replacement_value *agg_values;\n   /* Alignment information for pointers.  */\n   vec<ipa_alignment, va_gc> *alignments;\n+  /* Known bits information.  */\n+  vec<ipa_bits, va_gc> *bits;\n };\n \n void ipa_set_node_agg_value_chain (struct cgraph_node *node,"}, {"sha": "bc0570dbd5ecf803737c32455060c51a16726c59", "filename": "gcc/opts.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=209ca542cadd7ae7dc174bc74e066ed1de246672", "patch": "@@ -505,6 +505,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_2_PLUS, OPT_ftree_switch_conversion, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fipa_cp, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fipa_cp_alignment, NULL, 1 },\n+    { OPT_LEVELS_2_PLUS, OPT_fipa_bit_cp, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fdevirtualize, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fdevirtualize_speculatively, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fipa_sra, NULL, 1 },\n@@ -1422,6 +1423,9 @@ enable_fdo_optimizations (struct gcc_options *opts,\n   if (!opts_set->x_flag_ipa_cp_alignment\n       && value && opts->x_flag_ipa_cp)\n     opts->x_flag_ipa_cp_alignment = value;\n+  if (!opts_set->x_flag_ipa_bit_cp\n+      && value && opts->x_flag_ipa_cp)\n+    opts->x_flag_ipa_bit_cp = value;\n   if (!opts_set->x_flag_predictive_commoning)\n     opts->x_flag_predictive_commoning = value;\n   if (!opts_set->x_flag_unswitch_loops)"}, {"sha": "e51756d2d97a8b458f3ef9c92a5cfc33db27a2ce", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=209ca542cadd7ae7dc174bc74e066ed1de246672", "patch": "@@ -1,3 +1,10 @@\n+2016-08-26  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\t    Martin Jambhor  <mjambor@suse.cz>\n+\t\n+\t* gcc.dg/ipa/propbits-1.c: New test-case.\n+\t* gcc.dg/ipa/propbits-2.c: Likewise.\n+\t* gcc.dg/ipa/propbits-3.c: Likewise.\n+\n 2016-08-25  Steven g. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/77351"}, {"sha": "8ec372d81f075146d7510676c04d7ddbfc2b354b", "filename": "gcc/testsuite/gcc.dg/ipa/propbits-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropbits-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropbits-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropbits-1.c?ref=209ca542cadd7ae7dc174bc74e066ed1de246672", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-early-inlining -fdump-ipa-cp\" } */\n+\n+__attribute__((noinline)) \n+static int f(int x)\n+{\n+  int some_op(int);\n+  return some_op (x);\n+}\n+\n+int main(void)\n+{\n+  int a = f(1);\n+  int b = f(2);\n+  int c = f(4);\n+  return a + b + c;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Adjusting mask for param 0 to 0x7\" \"cp\" } } */"}, {"sha": "3a960f03108fbed0b5226de290c157474fd23cc8", "filename": "gcc/testsuite/gcc.dg/ipa/propbits-2.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropbits-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropbits-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropbits-2.c?ref=209ca542cadd7ae7dc174bc74e066ed1de246672", "patch": "@@ -0,0 +1,41 @@\n+/* x's mask should be meet(0xc, 0x3) == 0xf  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-early-inlining -fdump-ipa-cp\" } */\n+\n+extern int pass_test ();\n+extern int fail_test ();\n+\n+__attribute__((noinline))\n+static int f1(int x)\n+{\n+  if ((x & ~0xf) == 0)\n+    return pass_test ();\n+  else\n+    return fail_test ();\n+}\n+\n+__attribute__((noinline))\n+static int f2(int y)\n+{\n+  return f1(y & 0x03);\n+}\n+\n+__attribute__((noinline))\n+static int f3(int z)\n+{\n+  return f1(z & 0xc);\n+}\n+\n+extern int a;\n+extern int b;\n+\n+int main(void)\n+{\n+  int k = f2(a); \n+  int l = f3(b);\n+  return k + l;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Adjusting mask for param 0 to 0xf\" \"cp\" } } */\n+/* { dg-final { scan-dump-tree-not \"fail_test\" \"optimized\" } } */"}, {"sha": "44744cdde02bf50f27739415d714f8d505693c2e", "filename": "gcc/testsuite/gcc.dg/ipa/propbits-3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropbits-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropbits-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropbits-3.c?ref=209ca542cadd7ae7dc174bc74e066ed1de246672", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-early-inlining -fdump-ipa-cp\" } */\n+\n+__attribute__((noinline))\n+static int f(int x)\n+{\n+  extern int limit;\n+  extern int f2(int);\n+\n+  if (x == limit)\n+    return x;\n+  int k = f(x + 1);\n+  return f2 (k); \n+}\n+\n+int main(int argc, char **argv)\n+{\n+  int k = f(argc & 0xff); \n+  return k;\n+}\n+\n+/* { dg-final { scan-ipa-dump-not \"Adjusting mask for\" \"cp\" } } */  "}, {"sha": "987130403ce40171879a021991767a2181ffdc09", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 48, "deletions": 44, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=209ca542cadd7ae7dc174bc74e066ed1de246672", "patch": "@@ -142,7 +142,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"stor-layout.h\"\n #include \"optabs-query.h\"\n-\n+#include \"tree-ssa-ccp.h\"\n \n /* Possible lattice values.  */\n typedef enum\n@@ -536,9 +536,9 @@ set_lattice_value (tree var, ccp_prop_value_t *new_val)\n \n static ccp_prop_value_t get_value_for_expr (tree, bool);\n static ccp_prop_value_t bit_value_binop (enum tree_code, tree, tree, tree);\n-static void bit_value_binop_1 (enum tree_code, tree, widest_int *, widest_int *,\n-\t\t\t       tree, const widest_int &, const widest_int &,\n-\t\t\t       tree, const widest_int &, const widest_int &);\n+void bit_value_binop (enum tree_code, signop, int, widest_int *, widest_int *,\n+\t\t      signop, int, const widest_int &, const widest_int &,\n+\t\t      signop, int, const widest_int &, const widest_int &);\n \n /* Return a widest_int that can be used for bitwise simplifications\n    from VAL.  */\n@@ -894,7 +894,7 @@ do_dbg_cnt (void)\n    Return TRUE when something was optimized.  */\n \n static bool\n-ccp_finalize (bool nonzero_p)\n+ccp_finalize (bool nonzero_p) \n {\n   bool something_changed;\n   unsigned i;\n@@ -920,7 +920,8 @@ ccp_finalize (bool nonzero_p)\n \n       val = get_value (name);\n       if (val->lattice_val != CONSTANT\n-\t  || TREE_CODE (val->value) != INTEGER_CST)\n+\t  || TREE_CODE (val->value) != INTEGER_CST\n+\t  || val->mask == 0)\n \tcontinue;\n \n       if (POINTER_TYPE_P (TREE_TYPE (name)))\n@@ -1224,10 +1225,11 @@ ccp_fold (gimple *stmt)\n    RVAL and RMASK representing a value of type RTYPE and set\n    the value, mask pair *VAL and *MASK to the result.  */\n \n-static void\n-bit_value_unop_1 (enum tree_code code, tree type,\n-\t\t  widest_int *val, widest_int *mask,\n-\t\t  tree rtype, const widest_int &rval, const widest_int &rmask)\n+void\n+bit_value_unop (enum tree_code code, signop type_sgn, int type_precision, \n+\t\twidest_int *val, widest_int *mask,\n+\t\tsignop rtype_sgn, int rtype_precision,\n+\t\tconst widest_int &rval, const widest_int &rmask)\n {\n   switch (code)\n     {\n@@ -1240,25 +1242,23 @@ bit_value_unop_1 (enum tree_code code, tree type,\n       {\n \twidest_int temv, temm;\n \t/* Return ~rval + 1.  */\n-\tbit_value_unop_1 (BIT_NOT_EXPR, type, &temv, &temm, type, rval, rmask);\n-\tbit_value_binop_1 (PLUS_EXPR, type, val, mask,\n-\t\t\t   type, temv, temm, type, 1, 0);\n+\tbit_value_unop (BIT_NOT_EXPR, type_sgn, type_precision, &temv, &temm,\n+\t\t\ttype_sgn, type_precision, rval, rmask);\n+\tbit_value_binop (PLUS_EXPR, type_sgn, type_precision, val, mask,\n+\t\t\t type_sgn, type_precision, temv, temm,\n+\t\t\t type_sgn, type_precision, 1, 0);\n \tbreak;\n       }\n \n     CASE_CONVERT:\n       {\n-\tsignop sgn;\n-\n \t/* First extend mask and value according to the original type.  */\n-\tsgn = TYPE_SIGN (rtype);\n-\t*mask = wi::ext (rmask, TYPE_PRECISION (rtype), sgn);\n-\t*val = wi::ext (rval, TYPE_PRECISION (rtype), sgn);\n+\t*mask = wi::ext (rmask, rtype_precision, rtype_sgn);\n+\t*val = wi::ext (rval, rtype_precision, rtype_sgn);\n \n \t/* Then extend mask and value according to the target type.  */\n-\tsgn = TYPE_SIGN (type);\n-\t*mask = wi::ext (*mask, TYPE_PRECISION (type), sgn);\n-\t*val = wi::ext (*val, TYPE_PRECISION (type), sgn);\n+\t*mask = wi::ext (*mask, type_precision, type_sgn);\n+\t*val = wi::ext (*val, type_precision, type_sgn);\n \tbreak;\n       }\n \n@@ -1272,15 +1272,14 @@ bit_value_unop_1 (enum tree_code code, tree type,\n    R1VAL, R1MASK and R2VAL, R2MASK representing a values of type R1TYPE\n    and R2TYPE and set the value, mask pair *VAL and *MASK to the result.  */\n \n-static void\n-bit_value_binop_1 (enum tree_code code, tree type,\n-\t\t   widest_int *val, widest_int *mask,\n-\t\t   tree r1type, const widest_int &r1val,\n-\t\t   const widest_int &r1mask, tree r2type,\n-\t\t   const widest_int &r2val, const widest_int &r2mask)\n+void\n+bit_value_binop (enum tree_code code, signop sgn, int width, \n+\t\t widest_int *val, widest_int *mask,\n+\t\t signop r1type_sgn, int r1type_precision,\n+\t\t const widest_int &r1val, const widest_int &r1mask,\n+\t\t signop r2type_sgn, int r2type_precision,\n+\t\t const widest_int &r2val, const widest_int &r2mask)\n {\n-  signop sgn = TYPE_SIGN (type);\n-  int width = TYPE_PRECISION (type);\n   bool swap_p = false;\n \n   /* Assume we'll get a constant result.  Use an initial non varying\n@@ -1406,11 +1405,11 @@ bit_value_binop_1 (enum tree_code code, tree type,\n     case MINUS_EXPR:\n       {\n \twidest_int temv, temm;\n-\tbit_value_unop_1 (NEGATE_EXPR, r2type, &temv, &temm,\n-\t\t\t  r2type, r2val, r2mask);\n-\tbit_value_binop_1 (PLUS_EXPR, type, val, mask,\n-\t\t\t   r1type, r1val, r1mask,\n-\t\t\t   r2type, temv, temm);\n+\tbit_value_unop (NEGATE_EXPR, r2type_sgn, r2type_precision, &temv, &temm,\n+\t\t\t  r2type_sgn, r2type_precision, r2val, r2mask);\n+\tbit_value_binop (PLUS_EXPR, sgn, width, val, mask,\n+\t\t\t r1type_sgn, r1type_precision, r1val, r1mask,\n+\t\t\t r2type_sgn, r2type_precision, temv, temm);\n \tbreak;\n       }\n \n@@ -1472,7 +1471,7 @@ bit_value_binop_1 (enum tree_code code, tree type,\n \t  break;\n \n \t/* For comparisons the signedness is in the comparison operands.  */\n-\tsgn = TYPE_SIGN (r1type);\n+\tsgn = r1type_sgn;\n \n \t/* If we know the most significant bits we know the values\n \t   value ranges by means of treating varying bits as zero\n@@ -1525,8 +1524,9 @@ bit_value_unop (enum tree_code code, tree type, tree rhs)\n   gcc_assert ((rval.lattice_val == CONSTANT\n \t       && TREE_CODE (rval.value) == INTEGER_CST)\n \t      || wi::sext (rval.mask, TYPE_PRECISION (TREE_TYPE (rhs))) == -1);\n-  bit_value_unop_1 (code, type, &value, &mask,\n-\t\t    TREE_TYPE (rhs), value_to_wide_int (rval), rval.mask);\n+  bit_value_unop (code, TYPE_SIGN (type), TYPE_PRECISION (type), &value, &mask,\n+\t\t  TYPE_SIGN (TREE_TYPE (rhs)), TYPE_PRECISION (TREE_TYPE (rhs)),\n+\t\t  value_to_wide_int (rval), rval.mask);\n   if (wi::sext (mask, TYPE_PRECISION (type)) != -1)\n     {\n       val.lattice_val = CONSTANT;\n@@ -1571,9 +1571,12 @@ bit_value_binop (enum tree_code code, tree type, tree rhs1, tree rhs2)\n \t       && TREE_CODE (r2val.value) == INTEGER_CST)\n \t      || wi::sext (r2val.mask,\n \t\t\t   TYPE_PRECISION (TREE_TYPE (rhs2))) == -1);\n-  bit_value_binop_1 (code, type, &value, &mask,\n-\t\t     TREE_TYPE (rhs1), value_to_wide_int (r1val), r1val.mask,\n-\t\t     TREE_TYPE (rhs2), value_to_wide_int (r2val), r2val.mask);\n+  bit_value_binop (code, TYPE_SIGN (type), TYPE_PRECISION (type), &value, &mask,\n+\t\t   TYPE_SIGN (TREE_TYPE (rhs1)), TYPE_PRECISION (TREE_TYPE (rhs1)),\n+\t\t   value_to_wide_int (r1val), r1val.mask,\n+\t\t   TYPE_SIGN (TREE_TYPE (rhs2)), TYPE_PRECISION (TREE_TYPE (rhs2)),\n+\t\t   value_to_wide_int (r2val), r2val.mask);\n+\n   if (wi::sext (mask, TYPE_PRECISION (type)) != -1)\n     {\n       val.lattice_val = CONSTANT;\n@@ -1672,9 +1675,10 @@ bit_value_assume_aligned (gimple *stmt, tree attr, ccp_prop_value_t ptrval,\n \n   align = build_int_cst_type (type, -aligni);\n   alignval = get_value_for_expr (align, true);\n-  bit_value_binop_1 (BIT_AND_EXPR, type, &value, &mask,\n-\t\t     type, value_to_wide_int (ptrval), ptrval.mask,\n-\t\t     type, value_to_wide_int (alignval), alignval.mask);\n+  bit_value_binop (BIT_AND_EXPR, TYPE_SIGN (type), TYPE_PRECISION (type), &value, &mask,\n+\t\t   TYPE_SIGN (type), TYPE_PRECISION (type), value_to_wide_int (ptrval), ptrval.mask,\n+\t\t   TYPE_SIGN (type), TYPE_PRECISION (type), value_to_wide_int (alignval), alignval.mask);\n+\n   if (wi::sext (mask, TYPE_PRECISION (type)) != -1)\n     {\n       val.lattice_val = CONSTANT;\n@@ -2409,7 +2413,7 @@ do_ssa_ccp (bool nonzero_p)\n \n   ccp_initialize ();\n   ssa_propagate (ccp_visit_stmt, ccp_visit_phi_node);\n-  if (ccp_finalize (nonzero_p))\n+  if (ccp_finalize (nonzero_p || flag_ipa_bit_cp))\n     {\n       todo = (TODO_cleanup_cfg | TODO_update_ssa);\n "}, {"sha": "35383c5e942692200c2191585ec765836b7b9c67", "filename": "gcc/tree-ssa-ccp.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Ftree-ssa-ccp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/209ca542cadd7ae7dc174bc74e066ed1de246672/gcc%2Ftree-ssa-ccp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.h?ref=209ca542cadd7ae7dc174bc74e066ed1de246672", "patch": "@@ -0,0 +1,29 @@\n+/* Copyright (C) 2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef TREE_SSA_CCP_H\n+#define TREE_SSA_CCP_H\n+\n+void bit_value_binop (enum tree_code, signop, int, widest_int *, widest_int *,\n+\t\t      signop, int, const widest_int &, const widest_int &,\n+\t\t      signop, int, const widest_int &, const widest_int &);\n+\n+void bit_value_unop (enum tree_code, signop, int, widest_int *, widest_int *,\n+\t\t     signop, int, const widest_int &, const widest_int &);\n+\n+#endif"}]}