{"sha": "786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg2ZGU3ZWI5YWFhZjM5Zjk2MjQ4YjZkNDIzMTZiMmFhNGU5YmY2Mw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-05-09T12:02:29Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-05-09T12:02:29Z"}, "message": "sbitmap.c: Fix formatting.\n\n\t* sbitmap.c: Fix formatting.\n\t* scan.c: Likewise.\n\t* scan-decls.c: Likewise.\n\t* sched-deps.c: Likewise.\n\t* sched-ebb.c: Likewise.\n\t* sched-rgn.c: Likewise.\n\t* sched-vis.c: Likewise.\n\t* sdbout.c: Likewise.\n\t* sibcall.c: Likewise.\n\t* simplify-rtx.c: Likewise.\n\t* ssa.c: Likewise.\n\t* ssa-ccp.c: Likewise.\n\t* ssa-dce.c: Likewise.\n\t* stmt.c: Likewise.\n\t* stor-layout.c: Likewise.\n\t* stringpool.c: Likewise.\n\nFrom-SVN: r53324", "tree": {"sha": "8dfb059637bc4dfe3718b626a8be035328c2a665", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8dfb059637bc4dfe3718b626a8be035328c2a665"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/comments", "author": null, "committer": null, "parents": [{"sha": "b7764693d645c516a9b1be36fce35b12731fffb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7764693d645c516a9b1be36fce35b12731fffb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7764693d645c516a9b1be36fce35b12731fffb6"}], "stats": {"total": 525, "additions": 272, "deletions": 253}, "files": [{"sha": "bae7fb009734588fcb58cb746d78f0a00efea7d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "patch": "@@ -1,3 +1,22 @@\n+2002-05-09  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* sbitmap.c: Fix formatting.\n+\t* scan.c: Likewise.\n+\t* scan-decls.c: Likewise.\n+\t* sched-deps.c: Likewise.\n+\t* sched-ebb.c: Likewise.\n+\t* sched-rgn.c: Likewise.\n+\t* sched-vis.c: Likewise.\n+\t* sdbout.c: Likewise.\n+\t* sibcall.c: Likewise.\n+\t* simplify-rtx.c: Likewise.\n+\t* ssa.c: Likewise.\n+\t* ssa-ccp.c: Likewise.\n+\t* ssa-dce.c: Likewise.\n+\t* stmt.c: Likewise.\n+\t* stor-layout.c: Likewise.\n+\t* stringpool.c: Likewise.\n+\n 2002-05-09  David S. Miller  <davem@redhat.com>\n \n \t* config/sparc/sol2.h (ASM_CPU_SPEC): Handle -mcpu=v9."}, {"sha": "e581000e877fbbd12cf15889d5b23b446a49a69f", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "patch": "@@ -1,5 +1,5 @@\n /* Simple bitmaps.\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -222,7 +222,7 @@ sbitmap_difference (dst, a, b)\n   sbitmap_ptr dstp = dst->elms;\n   sbitmap_ptr ap = a->elms;\n   sbitmap_ptr bp = b->elms;\n-  \n+\n   for (i = 0; i < n; i++)\n     *dstp++ = *ap++ & ~*bp++;\n }\n@@ -444,7 +444,7 @@ sbitmap_intersection_of_succs (dst, src, bb)\n   for (e = b->succ; e != 0; e = e->succ_next)\n     {\n       if (e->dest == EXIT_BLOCK_PTR)\n-        continue;\n+\tcontinue;\n \n       sbitmap_copy (dst, src[e->dest->index]);\n       break;\n@@ -484,7 +484,7 @@ sbitmap_intersection_of_preds (dst, src, bb)\n   for (e = b->pred; e != 0; e = e->pred_next)\n     {\n       if (e->src == ENTRY_BLOCK_PTR)\n-        continue;\n+\tcontinue;\n \n       sbitmap_copy (dst, src[e->src->index]);\n       break;\n@@ -524,7 +524,7 @@ sbitmap_union_of_succs (dst, src, bb)\n   for (e = b->succ; e != 0; e = e->succ_next)\n     {\n       if (e->dest == EXIT_BLOCK_PTR)\n-        continue;\n+\tcontinue;\n \n       sbitmap_copy (dst, src[e->dest->index]);\n       break;\n@@ -564,7 +564,7 @@ sbitmap_union_of_preds (dst, src, bb)\n   for (e = b->pred; e != 0; e = e->pred_next)\n     {\n       if (e->src== ENTRY_BLOCK_PTR)\n-        continue;\n+\tcontinue;\n \n       sbitmap_copy (dst, src[e->src->index]);\n       break;\n@@ -580,7 +580,7 @@ sbitmap_union_of_preds (dst, src, bb)\n \n \tif (e->src == ENTRY_BLOCK_PTR)\n \t  continue;\n-\t\n+\n \tp = src[e->src->index]->elms;\n \tr = dst->elms;\n \tfor (i = 0; i < set_size; i++)"}, {"sha": "e56401d066f91095d2d5ada320df57ff2ca17da1", "filename": "gcc/scan-decls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fscan-decls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fscan-decls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan-decls.c?ref=786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "patch": "@@ -72,7 +72,7 @@ skip_to_closing_brace (pfile)\n \n /* This function scans a C source file (actually, the output of cpp),\n    reading from FP.  It looks for function declarations, and\n-   external variable declarations.  \n+   external variable declarations.\n \n    The following grammar (as well as some extra stuff) is recognized:\n \n@@ -155,7 +155,7 @@ scan_decls (pfile, argc, argv)\n \t  /* ... fall through ...  */\n \tcase CPP_OPEN_BRACE:  case CPP_CLOSE_BRACE:\n \t  goto new_statement;\n-\t  \n+\n \tcase CPP_EOF:\n \t  return 0;\n "}, {"sha": "ac6b809799f715ceb03e82df86c868e888292c87", "filename": "gcc/scan.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fscan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fscan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan.c?ref=786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "patch": "@@ -34,7 +34,7 @@ make_sstring_space (str, count)\n \n   if (new_size <= cur_size)\n     return;\n-  \n+\n   str->base = xrealloc (str->base, new_size);\n   str->ptr = str->base + cur_size;\n   str->limit = str->base + new_size;\n@@ -53,7 +53,7 @@ sstring_append (dst, src)\n   s = src->base;\n   while (--count >= 0) *d++ = *s++;\n   dst->ptr = d;\n-  *d = 0;  \n+  *d = 0;\n }\n \n int"}, {"sha": "88bf2b7f2e2b9ad1310b153b5f3cb3c30018abc9", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "patch": "@@ -280,7 +280,7 @@ add_dependence (insn, elem, dep_type)\n       else if (TEST_BIT (output_dependency_cache[INSN_LUID (insn)],\n \t\t\t INSN_LUID (elem)))\n \tpresent_dep_type = REG_DEP_OUTPUT;\n-      else \n+      else\n \tpresent_p = 0;\n       if (present_p && (int) dep_type >= (int) present_dep_type)\n \treturn;\n@@ -313,7 +313,7 @@ add_dependence (insn, elem, dep_type)\n \t     one, then change the existing dependence to this type.  */\n \t  if ((int) dep_type < (int) REG_NOTE_KIND (link))\n \t    PUT_REG_NOTE_KIND (link, dep_type);\n-\t  \n+\n #ifdef INSN_SCHEDULING\n \t  /* If we are adding a dependency to INSN's LOG_LINKs, then\n \t     note that in the bitmap caches of dependency information.  */\n@@ -1032,7 +1032,7 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n     }\n \n   /* If this instruction can throw an exception, then moving it changes\n-     where block boundaries fall.  This is mighty confusing elsewhere. \n+     where block boundaries fall.  This is mighty confusing elsewhere.\n      Therefore, prevent such an instruction from being moved.  */\n   if (can_throw_internal (insn))\n     reg_pending_barrier = true;"}, {"sha": "5f1464b9c147b510dbe3f48661be6e2462dd2e3c", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "patch": "@@ -1,6 +1,6 @@\n /* Instruction scheduling pass.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,\n    and currently maintained by, Jim Wilson (wilson@cygnus.com)\n \n@@ -297,7 +297,7 @@ schedule_ebbs (dump_file)\n \n   /* Schedule every region in the subroutine.  */\n   for (i = 0; i < n_basic_blocks; i++)\n-    { \n+    {\n       rtx head = BASIC_BLOCK (i)->head;\n       rtx tail;\n "}, {"sha": "acc8477e3ab8cdbc5e5458ddc81952f7a5eb66ed", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "patch": "@@ -577,17 +577,17 @@ too_large (block, num_bbs, num_insns)\n /* Update_loop_relations(blk, hdr): Check if the loop headed by max_hdr[blk]\n    is still an inner loop.  Put in max_hdr[blk] the header of the most inner\n    loop containing blk.  */\n-#define UPDATE_LOOP_RELATIONS(blk, hdr)                              \\\n-{                                                                    \\\n-  if (max_hdr[blk] == -1)                                            \\\n-    max_hdr[blk] = hdr;                                              \\\n-  else if (dfs_nr[max_hdr[blk]] > dfs_nr[hdr])                       \\\n-         RESET_BIT (inner, hdr);                                     \\\n-  else if (dfs_nr[max_hdr[blk]] < dfs_nr[hdr])                       \\\n-         {                                                           \\\n-            RESET_BIT (inner,max_hdr[blk]);\t\t\t     \\\n-            max_hdr[blk] = hdr;                                      \\\n-         }                                                           \\\n+#define UPDATE_LOOP_RELATIONS(blk, hdr)\t\t\\\n+{\t\t\t\t\t\t\\\n+  if (max_hdr[blk] == -1)\t\t\t\\\n+    max_hdr[blk] = hdr;\t\t\t\t\\\n+  else if (dfs_nr[max_hdr[blk]] > dfs_nr[hdr])\t\\\n+    RESET_BIT (inner, hdr);\t\t\t\\\n+  else if (dfs_nr[max_hdr[blk]] < dfs_nr[hdr])\t\\\n+    {\t\t\t\t\t\t\\\n+      RESET_BIT (inner,max_hdr[blk]);\t\t\\\n+      max_hdr[blk] = hdr;\t\t\t\\\n+    }\t\t\t\t\t\t\\\n }\n \n /* Find regions for interblock scheduling.\n@@ -1094,7 +1094,7 @@ compute_dom_prob_ps (bb)\n \t  if (CONTAINING_RGN (TO_BLOCK (nxt_out_edge)) !=\n \t      CONTAINING_RGN (BB_TO_BLOCK (bb)))\n \t    ++nr_rgn_out_edges;\n-        SET_BIT (pot_split[bb], EDGE_TO_BIT (nxt_out_edge));\n+\t  SET_BIT (pot_split[bb], EDGE_TO_BIT (nxt_out_edge));\n \t  nxt_out_edge = NEXT_OUT (nxt_out_edge);\n \n \t}\n@@ -1562,17 +1562,17 @@ enum INSN_TRAP_CLASS\n \n /* Non-zero if block bb_to is equal to, or reachable from block bb_from.  */\n #define IS_REACHABLE(bb_from, bb_to)\t\t\t\t\t\\\n-(bb_from == bb_to                                                       \\\n+  (bb_from == bb_to\t\t\t\t\t\t\t\\\n    || IS_RGN_ENTRY (bb_from)\t\t\t\t\t\t\\\n-   || (TEST_BIT (ancestor_edges[bb_to],                               \\\n-                    EDGE_TO_BIT (IN_EDGES (BB_TO_BLOCK (bb_from))))))\n+   || (TEST_BIT (ancestor_edges[bb_to],\t\t\t\t\t\\\n+\t\t EDGE_TO_BIT (IN_EDGES (BB_TO_BLOCK (bb_from))))))\n \n /* Non-zero iff the address is comprised from at most 1 register.  */\n #define CONST_BASED_ADDRESS_P(x)\t\t\t\\\n   (GET_CODE (x) == REG\t\t\t\t\t\\\n-   || ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS   \\\n-\t|| (GET_CODE (x) == LO_SUM))\t                \\\n-       && (CONSTANT_P (XEXP (x, 0))\t\t\\\n+   || ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS\t\\\n+\t|| (GET_CODE (x) == LO_SUM))\t\t\t\\\n+       && (CONSTANT_P (XEXP (x, 0))\t\t\t\\\n \t   || CONSTANT_P (XEXP (x, 1)))))\n \n /* Turns on the fed_by_spec_load flag for insns fed by load_insn.  */\n@@ -2497,7 +2497,7 @@ propagate_deps (bb, pred_deps)\n \tsucc_deps->last_pending_memory_flush\n \t  = concat_INSN_LIST (pred_deps->last_pending_memory_flush,\n \t\t\t      succ_deps->last_pending_memory_flush);\n-\t\n+\n \tsucc_deps->pending_lists_length += pred_deps->pending_lists_length;\n \tsucc_deps->pending_flush_length += pred_deps->pending_flush_length;\n \n@@ -2657,7 +2657,7 @@ debug_dependencies ()\n \t\t\t   INSN_DEP_COUNT (insn),\n \t\t\t   INSN_PRIORITY (insn),\n \t\t\t   insn_cost (insn, 0, 0));\n-\t\t  \n+\n \t\t  if (recog_memoized (insn) < 0)\n \t\t    fprintf (sched_dump, \"nothing\");\n \t\t  else\n@@ -2996,7 +2996,7 @@ schedule_insns (dump_file)\n   init_regions ();\n \n   current_sched_info = &region_sched_info;\n-  \n+\n   /* Schedule every region in the subroutine.  */\n   for (rgn = 0; rgn < nr_regions; rgn++)\n     schedule_region (rgn);"}, {"sha": "239ca0a91a107c4c07a51f11cc40c9bb0add8b35", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "patch": "@@ -677,13 +677,13 @@ print_pattern (buf, x, verbose)\n \t  && XEXP (COND_EXEC_TEST (x), 1) == const0_rtx)\n \tprint_value (t1, XEXP (COND_EXEC_TEST (x), 0), verbose);\n       else if (GET_CODE (COND_EXEC_TEST (x)) == EQ\n-               && XEXP (COND_EXEC_TEST (x), 1) == const0_rtx)\n-        {\n+\t       && XEXP (COND_EXEC_TEST (x), 1) == const0_rtx)\n+\t{\n \t  t1[0] = '!';\n \t  print_value (t1 + 1, XEXP (COND_EXEC_TEST (x), 0), verbose);\n \t}\n       else\n-        print_value (t1, COND_EXEC_TEST (x), verbose);\n+\tprint_value (t1, COND_EXEC_TEST (x), verbose);\n       print_pattern (t2, COND_EXEC_CODE (x), verbose);\n       sprintf (buf, \"(%s) %s\", t1, t2);\n       break;"}, {"sha": "08d8abe455c44e1b6e20f1c53bce3605c05e0895", "filename": "gcc/sdbout.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "patch": "@@ -782,7 +782,7 @@ sdbout_symbol (decl, local)\n       if (!DECL_RTL_SET_P (decl))\n \treturn;\n \n-      SET_DECL_RTL (decl, \n+      SET_DECL_RTL (decl,\n \t\t    eliminate_regs (DECL_RTL (decl), 0, NULL_RTX));\n #ifdef LEAF_REG_REMAP\n       if (current_function_uses_only_leaf_regs)\n@@ -858,12 +858,12 @@ sdbout_symbol (decl, local)\n \t  if (TREE_PUBLIC (decl))\n \t    {\n \t      PUT_SDB_VAL (XEXP (value, 0));\n-              PUT_SDB_SCL (C_EXT);\n+\t      PUT_SDB_SCL (C_EXT);\n \t    }\n \t  else\n \t    {\n \t      PUT_SDB_VAL (XEXP (value, 0));\n-              PUT_SDB_SCL (C_STAT);\n+\t      PUT_SDB_SCL (C_STAT);\n \t    }\n \t}\n       else if (regno >= 0)\n@@ -1759,7 +1759,7 @@ sdbout_init (input_file_name)\n     if (DECL_NAME (t) && IDENTIFIER_POINTER (DECL_NAME (t)) != 0\n \t&& !strcmp (IDENTIFIER_POINTER (DECL_NAME (t)), \"__vtbl_ptr_type\"))\n       sdbout_symbol (t, 0);\n-#endif  \n+#endif\n \n #ifdef SDB_ALLOW_FORWARD_REFERENCES\n   ggc_add_tree_root (&anonymous_types, 1);"}, {"sha": "c62941f097442ffdb95299a25e8ffeb54d9e75f7", "filename": "gcc/sibcall.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "patch": "@@ -86,7 +86,7 @@ identify_call_return_value (cp, p_hard_return, p_soft_return)\n   /* If we didn't get a single hard register (e.g. a parallel), give up.  */\n   if (GET_CODE (hard) != REG)\n     return 0;\n-    \n+\n   /* Stack adjustment done after call may appear here.  */\n   insn = skip_stack_adjustment (insn);\n   if (! insn)\n@@ -101,7 +101,7 @@ identify_call_return_value (cp, p_hard_return, p_soft_return)\n   insn = NEXT_INSN (insn);\n   if (! insn)\n     return 0;\n-  \n+\n   /* We're looking for a source of the hard return register.  */\n   set = single_set (insn);\n   if (! set || SET_SRC (set) != hard)\n@@ -168,7 +168,7 @@ skip_copy_to_return_value (orig_insn)\n \n   /* The destination must be the same as the called function's return\n      value to ensure that any return value is put in the same place by the\n-     current function and the function we're calling. \n+     current function and the function we're calling.\n \n      Further, the source must be the same as the pseudo into which the\n      called function's return value was copied.  Otherwise we're returning\n@@ -554,7 +554,7 @@ replace_call_placeholder (insn, use)\n      pass above from deleting it as unused.  */\n   if (XEXP (PATTERN (insn), 3))\n     LABEL_PRESERVE_P (XEXP (PATTERN (insn), 3)) = 0;\n-  \n+\n   /* \"Delete\" the placeholder insn.  */\n   remove_insn (insn);\n }\n@@ -586,7 +586,7 @@ optimize_sibling_and_tail_recursive_calls ()\n   if (n_basic_blocks == 0)\n     return;\n \n-  /* If we are using sjlj exceptions, we may need to add a call to \n+  /* If we are using sjlj exceptions, we may need to add a call to\n      _Unwind_SjLj_Unregister at exit of the function.  Which means\n      that we cannot do any sibcall transformations.  */\n   if (USING_SJLJ_EXCEPTIONS && current_function_has_exception_handlers ())\n@@ -676,7 +676,7 @@ optimize_sibling_and_tail_recursive_calls ()\n \t     sibling call optimizations, but not tail recursion.\n \t     Similarly if we use varargs or stdarg since they implicitly\n \t     may take the address of an argument.  */\n- \t  if (current_function_calls_alloca\n+\t  if (current_function_calls_alloca\n \t      || current_function_varargs || current_function_stdarg)\n \t    sibcall = 0;\n \n@@ -709,8 +709,8 @@ optimize_sibling_and_tail_recursive_calls ()\n \t    successful_sibling_call = 1;\n \n \t  replaced_call_placeholder = 1;\n-\t  replace_call_placeholder (insn, \n-\t\t\t\t    tailrecursion != 0 \n+\t  replace_call_placeholder (insn,\n+\t\t\t\t    tailrecursion != 0\n \t\t\t\t      ? sibcall_use_tail_recursion\n \t\t\t\t      : sibcall != 0\n \t\t\t\t\t ? sibcall_use_sibcall\n@@ -724,11 +724,11 @@ optimize_sibling_and_tail_recursive_calls ()\n       tree arg;\n \n       /* A sibling call sequence invalidates any REG_EQUIV notes made for\n-\t this function's incoming arguments. \n+\t this function's incoming arguments.\n \n \t At the start of RTL generation we know the only REG_EQUIV notes\n \t in the rtl chain are those for incoming arguments, so we can safely\n-\t flush any REG_EQUIV note. \n+\t flush any REG_EQUIV note.\n \n \t This is (slight) overkill.  We could keep track of the highest\n \t argument we clobber and be more selective in removing notes, but it\n@@ -738,7 +738,7 @@ optimize_sibling_and_tail_recursive_calls ()\n       /* A sibling call sequence also may invalidate RTX_UNCHANGING_P\n \t flag of some incoming arguments MEM RTLs, because it can write into\n \t those slots.  We clear all those bits now.\n-\t \n+\n \t This is (slight) overkill, we could keep track of which arguments\n \t we actually write into.  */\n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n@@ -749,16 +749,16 @@ optimize_sibling_and_tail_recursive_calls ()\n \n       /* Similarly, invalidate RTX_UNCHANGING_P for any incoming\n \t arguments passed in registers.  */\n-      for (arg = DECL_ARGUMENTS (current_function_decl); \n-\t   arg; \n+      for (arg = DECL_ARGUMENTS (current_function_decl);\n+\t   arg;\n \t   arg = TREE_CHAIN (arg))\n \t{\n \t  if (REG_P (DECL_RTL (arg)))\n \t    RTX_UNCHANGING_P (DECL_RTL (arg)) = false;\n \t}\n     }\n \n-  /* There may have been NOTE_INSN_BLOCK_{BEGIN,END} notes in the \n+  /* There may have been NOTE_INSN_BLOCK_{BEGIN,END} notes in the\n      CALL_PLACEHOLDER alternatives that we didn't emit.  Rebuild the\n      lexical block tree to correspond to the notes that still exist.  */\n   if (replaced_call_placeholder)"}, {"sha": "36bcc1a22dc158fd65c256a3994f5aaf38ba550f", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "patch": "@@ -43,7 +43,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    virtual regs here because the simplify_*_operation routines are called\n    by integrate.c, which is called before virtual register instantiation.\n \n-   ?!? FIXED_BASE_PLUS_P and NONZERO_BASE_PLUS_P need to move into \n+   ?!? FIXED_BASE_PLUS_P and NONZERO_BASE_PLUS_P need to move into\n    a header file so that their definitions can be shared with the\n    simplification routines in simplify-rtx.c.  Until then, do not\n    change these macros without also changing the copy in simplify-rtx.c.  */\n@@ -113,7 +113,7 @@ neg_const_int (mode, i)\n }\n \n \f\n-/* Make a binary operation by properly ordering the operands and \n+/* Make a binary operation by properly ordering the operands and\n    seeing if the expression folds.  */\n \n rtx\n@@ -300,7 +300,7 @@ simplify_replace_rtx (x, old, new)\n \trtx op0 = simplify_replace_rtx (XEXP (x, 0), old, new);\n \n \treturn\n-\t  simplify_gen_ternary (code, mode, \n+\t  simplify_gen_ternary (code, mode,\n \t\t\t\t(op_mode != VOIDmode\n \t\t\t\t ? op_mode\n \t\t\t\t : GET_MODE (op0)),\n@@ -677,7 +677,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t    return convert_memory_address (Pmode, op);\n \t  break;\n #endif\n-\t  \n+\n \tdefault:\n \t  break;\n \t}\n@@ -964,7 +964,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t    }\n \n \t  /* If one of the operands is a PLUS or a MINUS, see if we can\n-\t     simplify this by the associative law. \n+\t     simplify this by the associative law.\n \t     Don't use the associative law for floating point.\n \t     The inaccuracy makes it nonassociative,\n \t     and subtle programs can break if operations are associated.  */\n@@ -1013,7 +1013,7 @@ simplify_binary_operation (code, mode, op0, op1)\n #endif\n \t\treturn xop00;\n \t    }\n-\t  break;\t      \n+\t  break;\n \n \tcase MINUS:\n \t  /* We can't assume x-x is 0 even with non-IEEE floating point,\n@@ -1102,7 +1102,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t    return simplify_gen_binary (PLUS, mode, op0, XEXP (op1, 0));\n \n \t  /* If one of the operands is a PLUS or a MINUS, see if we can\n-\t     simplify this by the associative law. \n+\t     simplify this by the associative law.\n \t     Don't use the associative law for floating point.\n \t     The inaccuracy makes it nonassociative,\n \t     and subtle programs can break if operations are associated.  */\n@@ -1280,7 +1280,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t      if (! REAL_VALUES_EQUAL (d, dconst0))\n \t\t{\n \t\t  REAL_ARITHMETIC (d, rtx_to_tree_code (DIV), dconst1, d);\n-\t\t  return gen_rtx_MULT (mode, op0, \n+\t\t  return gen_rtx_MULT (mode, op0,\n \t\t\t\t       CONST_DOUBLE_FROM_REAL_VALUE (d, mode));\n \t\t}\n \t    }\n@@ -1320,14 +1320,14 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  break;\n \n \tcase SMIN:\n-\t  if (width <= HOST_BITS_PER_WIDE_INT && GET_CODE (trueop1) == CONST_INT \n+\t  if (width <= HOST_BITS_PER_WIDE_INT && GET_CODE (trueop1) == CONST_INT\n \t      && INTVAL (trueop1) == (HOST_WIDE_INT) 1 << (width -1)\n \t      && ! side_effects_p (op0))\n \t    return op1;\n \t  else if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n \t    return op0;\n \t  break;\n-\t   \n+\n \tcase SMAX:\n \t  if (width <= HOST_BITS_PER_WIDE_INT && GET_CODE (trueop1) == CONST_INT\n \t      && ((unsigned HOST_WIDE_INT) INTVAL (trueop1)\n@@ -1344,7 +1344,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  else if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n \t    return op0;\n \t  break;\n-\t    \n+\n \tcase UMAX:\n \t  if (trueop1 == constm1_rtx && ! side_effects_p (op0))\n \t    return op1;\n@@ -1362,7 +1362,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \tdefault:\n \t  abort ();\n \t}\n-      \n+\n       return 0;\n     }\n \n@@ -1549,9 +1549,9 @@ simplify_binary_operation (code, mode, op0, op1)\n \n    Rather than test for specific case, we do this by a brute-force method\n    and do all possible simplifications until no more changes occur.  Then\n-   we rebuild the operation. \n+   we rebuild the operation.\n \n-   If FORCE is true, then always generate the rtx.  This is used to \n+   If FORCE is true, then always generate the rtx.  This is used to\n    canonicalize stuff emitted from simplify_gen_binary.  Note that this\n    can still fail if the rtx is too complex.  It won't fail just because\n    the result is not 'simpler' than the input, however.  */\n@@ -1588,7 +1588,7 @@ simplify_plus_minus (code, mode, op0, op1, force)\n   int i, j;\n \n   memset ((char *) ops, 0, sizeof ops);\n-  \n+\n   /* Set up the two operands and then expand them until nothing has been\n      changed.  If we run out of room in our array, give up; this should\n      almost never happen.  */\n@@ -1712,7 +1712,7 @@ simplify_plus_minus (code, mode, op0, op1, force)\n \n \t\ttem = simplify_binary_operation (ncode, mode, lhs, rhs);\n \n-\t\t/* Reject \"simplifications\" that just wrap the two \n+\t\t/* Reject \"simplifications\" that just wrap the two\n \t\t   arguments in a CONST.  Failure to do so can result\n \t\t   in infinite recursion with simplify_binary_operation\n \t\t   when it calls us to simplify CONST operations.  */\n@@ -1784,7 +1784,7 @@ simplify_plus_minus (code, mode, op0, op1, force)\n      is also an improvement, so accept it.  */\n   if (!force\n       && (n_ops + n_consts > input_ops\n-          || (n_ops + n_consts == input_ops && n_consts <= input_consts)))\n+\t  || (n_ops + n_consts == input_ops && n_consts <= input_consts)))\n     return NULL_RTX;\n \n   /* Put a non-negated operand first.  If there aren't any, make all\n@@ -1955,7 +1955,7 @@ simplify_relational_operation (code, mode, op0, op1)\n \t  l0u = l0s = INTVAL (trueop0);\n \t  h0u = h0s = HWI_SIGN_EXTEND (l0s);\n \t}\n-\t  \n+\n       if (GET_CODE (trueop1) == CONST_DOUBLE)\n \t{\n \t  l1u = l1s = CONST_DOUBLE_LOW (trueop1);\n@@ -2044,7 +2044,7 @@ simplify_relational_operation (code, mode, op0, op1)\n \t      && INTEGRAL_MODE_P (mode))\n \t    return const0_rtx;\n \t  break;\n-\t  \n+\n \tdefault:\n \t  break;\n \t}\n@@ -2188,7 +2188,7 @@ simplify_ternary_operation (code, mode, op0_mode, op0, op1, op2)\n \t    {\n \t      HOST_WIDE_INT t = INTVAL (op1);\n \t      HOST_WIDE_INT f = INTVAL (op2);\n-\t      \n+\n \t      if (t == STORE_FLAG_VALUE && f == 0)\n \t        code = GET_CODE (op0);\n \t      else if (t == 0 && f == STORE_FLAG_VALUE)\n@@ -2288,7 +2288,7 @@ simplify_subreg (outermode, op, innermode, byte)\n \t  val = part ? CONST_DOUBLE_HIGH (op) : CONST_DOUBLE_LOW (op);\n \t  offset %= HOST_BITS_PER_WIDE_INT;\n \n-\t  /* We've already picked the word we want from a double, so \n+\t  /* We've already picked the word we want from a double, so\n \t     pretend this is actually an integer.  */\n \t  innermode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n \n@@ -2553,7 +2553,7 @@ simplify_gen_subreg (outermode, op, innermode, byte)\n     maintain and improve.  It's totally silly that when we add a\n     simplification that it needs to be added to 4 places (3 for RTL\n     simplification and 1 for tree simplification.  */\n-\t   \n+\n rtx\n simplify_rtx (x)\n      rtx x;\n@@ -2597,7 +2597,7 @@ simplify_rtx (x)\n     case 'x':\n       /* The only case we try to handle is a SUBREG.  */\n       if (code == SUBREG)\n-        return simplify_gen_subreg (mode, SUBREG_REG (x),\n+\treturn simplify_gen_subreg (mode, SUBREG_REG (x),\n \t\t\t\t    GET_MODE (SUBREG_REG (x)),\n \t\t\t\t    SUBREG_BYTE (x));\n       return NULL;"}, {"sha": "641727655ba0787348052a9bc559e6fe4add7341", "filename": "gcc/ssa-ccp.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-ccp.c?ref=786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "patch": "@@ -2,19 +2,19 @@\n    Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n    Original framework by Daniel Berlin <dan@cgsoftware.com>\n    Fleshed out and major cleanups by Jeff Law <law@redhat.com>\n-   \n+\n This file is part of GCC.\n-   \n+\n GCC is free software; you can redistribute it and/or modify it under\n the terms of the GNU General Public License as published by the Free\n Software Foundation; either version 2, or (at your option) any later\n version.\n-   \n+\n GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n WARRANTY; without even the implied warranty of MERCHANTABILITY or\n FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n for more details.\n-   \n+\n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n@@ -44,7 +44,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t5. Another simple SSA DCE pass to remove dead code exposed\n \t   by CCP.\n \n-   When we exit, we are still in SSA form. \n+   When we exit, we are still in SSA form.\n \n \n    Potential further enhancements:\n@@ -83,7 +83,7 @@ typedef enum\n   VARYING\n } latticevalue;\n \n-/* Main structure for CCP. \n+/* Main structure for CCP.\n \n    Contains the lattice value and, if it's a constant, the constant\n    value.  */\n@@ -185,7 +185,7 @@ visit_phi_node (phi_node, block)\n \t  /* If the current value of PHI_NODE is UNDEFINED and one\n \t     node in PHI_NODE is CONSTANT, then the new value of the\n \t     PHI is that CONSTANT.  Note this can turn into VARYING\n-\t     if we find another distinct constant later.  */ \n+\t     if we find another distinct constant later.  */\n \t  if (phi_node_lattice_val == UNDEFINED\n \t      && phi_node_expr == NULL\n \t      && current_parm_lattice_val == CONSTANT)\n@@ -288,7 +288,7 @@ visit_expression (insn, block)\n     }\n \n   /* Hard registers are not put in SSA form and thus we must consider\n-     them varying.  All the more reason to avoid hard registers in \n+     them varying.  All the more reason to avoid hard registers in\n      RTL until as late as possible in the compilation.  */\n   if (GET_CODE (dest) == REG && REGNO (dest) < FIRST_PSEUDO_REGISTER)\n     {\n@@ -451,7 +451,7 @@ visit_expression (insn, block)\n       rtx simplified = NULL;\n \n       /* We've got some kind of INSN.  If it's simple, try to evaluate\n-\t it and record the results. \n+\t it and record the results.\n \n \t We already know this insn is a single_set and that it sets\n \t a pseudo register.   So we just need to extract the source\n@@ -511,7 +511,7 @@ visit_expression (insn, block)\n \t\t  defs_to_undefined (insn);\n \t\t  break;\n \t\t}\n-\t\t\n+\n \t      /* Simplify source operands to whatever known values they\n \t\t may have.  */\n \t      if (GET_CODE (src0) == REG\n@@ -542,7 +542,7 @@ visit_expression (insn, block)\n \t\t  defs_to_undefined (insn);\n \t\t  break;\n \t\t}\n-\t\t\n+\n \t      /* Simplify source operands to whatever known values they\n \t\t may have.  */\n \t      if (GET_CODE (src0) == REG\n@@ -579,7 +579,7 @@ visit_expression (insn, block)\n \t\t  defs_to_undefined (insn);\n \t\t  break;\n \t\t}\n-\t\t\n+\n \t      /* Simplify source operands to whatever known values they\n \t\t may have.  */\n \t      if (GET_CODE (src0) == REG\n@@ -602,7 +602,7 @@ visit_expression (insn, block)\n \t\t\t\t\t\t       src0, src1, src2);\n \t      break;\n \t    }\n-\t\n+\n \t  default:\n \t    defs_to_varying (insn);\n \t}\n@@ -617,7 +617,7 @@ visit_expression (insn, block)\n \t  values[REGNO (dest)].const_value = simplified;\n \t}\n       else\n-        defs_to_varying (insn);\n+\tdefs_to_varying (insn);\n     }\n }\n \n@@ -665,11 +665,11 @@ examine_flow_edges ()\n \n \t      currinsn = NEXT_INSN (currinsn);\n \t    }\n-\t  \n+\n \t  /* Don't forget the last insn in the block.  */\n \t  if (INSN_P (currinsn))\n \t    visit_expression (currinsn, succ_block);\n-\t  \n+\n \t  /* If we haven't looked at the next block, and it has a\n \t     single successor, add it onto the worklist.  This is because\n \t     if we only have one successor, we know it gets executed,\n@@ -702,7 +702,7 @@ follow_def_use_chains ()\n \n       /* Pick an entry off the worklist (it does not matter which\n \t entry we pick).  */\n-      member = sbitmap_first_set_bit (ssa_edges); \n+      member = sbitmap_first_set_bit (ssa_edges);\n       RESET_BIT (ssa_edges, member);\n \n       /* Iterate through all the uses of this entry.  */\n@@ -716,7 +716,7 @@ follow_def_use_chains ()\n \t    {\n \t      if (TEST_BIT (executable_blocks, BLOCK_NUM (useinsn)))\n \t\tvisit_phi_node (useinsn, BLOCK_FOR_INSN (useinsn));\n-\t    }\t  \n+\t    }\n \t  else\n \t    {\n \t      if (TEST_BIT (executable_blocks, BLOCK_NUM (useinsn)))\n@@ -727,7 +727,7 @@ follow_def_use_chains ()\n }\n \n /* Examine each edge to see if we were able to prove any were\n-   not executable. \n+   not executable.\n \n    If an edge is not executable, then we can remove its alternative\n    in PHI nodes as the destination of the edge, we can simplify the\n@@ -761,7 +761,7 @@ optimize_unexecutable_edges (edges, executable_edges)\n \t\t  remove_phi_alternative (PATTERN (insn), edge->src);\n \t\t  if (rtl_dump_file)\n \t\t    fprintf (rtl_dump_file,\n-\t\t\t     \"Removing alternative for bb %d of phi %d\\n\", \n+\t\t\t     \"Removing alternative for bb %d of phi %d\\n\",\n \t\t\t     edge->src->index, SSA_NAME (PATTERN (insn)));\n \t\t  insn = NEXT_INSN (insn);\n \t\t}\n@@ -834,15 +834,15 @@ optimize_unexecutable_edges (edges, executable_edges)\n \t}\n     }\n }\n- \n+\n /* Perform substitution of known values for pseudo registers.\n \n    ??? Note we do not do simplifications or constant folding here, it\n    is unlikely that any significant simplifications can be done here\n    anyway.  Consider that if the simplification would result in an\n    expression that produces a constant value that the value would\n    have been discovered and recorded already.\n-   \n+\n    We perform two transformations.  First, we initialize pseudos to their\n    known constant values at their definition point.  Second, we try to\n    replace uses with the known constant value.  */\n@@ -901,21 +901,21 @@ ssa_ccp_substitute_constants ()\n \t\t  && (GET_CODE (useinsn) == INSN\n \t\t      || GET_CODE (useinsn) == JUMP_INSN))\n \t\t{\n-\t\t  \n+\n \t\t  if (validate_replace_src (regno_reg_rtx [i],\n \t\t\t\t\tvalues[i].const_value,\n \t\t\t\t\t    useinsn))\n \t\t    {\n \t\t      if (rtl_dump_file)\n-\t\t\tfprintf (rtl_dump_file, \n+\t\t\tfprintf (rtl_dump_file,\n \t\t\t\t \"Register %d in insn %d replaced with constant\\n\",\n \t\t\t\t i, INSN_UID (useinsn));\n \t\t      INSN_CODE (useinsn) = -1;\n \t\t      df_insn_modify (df_analyzer,\n \t\t\t\t      BLOCK_FOR_INSN (useinsn),\n \t\t\t\t      useinsn);\n \t\t    }\n-\t\t  \n+\n \t\t}\n \t    }\n \t}\n@@ -1009,7 +1009,7 @@ ssa_const_prop ()\n   for (i = 0; i < VARRAY_SIZE (ssa_definition); i++)\n     {\n       if (i < FIRST_PSEUDO_REGISTER)\n-        values[i].lattice_val = VARYING;\n+\tvalues[i].lattice_val = VARYING;\n       else\n \tvalues[i].lattice_val = UNDEFINED;\n       values[i].const_value = NULL;\n@@ -1085,7 +1085,7 @@ ssa_const_prop ()\n \n   sbitmap_free (ssa_edges);\n   ssa_edges = NULL;\n-  \n+\n   free_edge_list (edges);\n   edges = NULL;\n \n@@ -1178,7 +1178,7 @@ ssa_fast_dce (df)\n \t\t  == NOTE_INSN_DELETED))\n \t  || side_effects_p (PATTERN (VARRAY_RTX (ssa_definition, reg))))\n \tcontinue;\n-      \n+\n       /* Iterate over the uses of this register.  If we can not find\n \t any uses that have not been deleted, then the definition of\n \t this register is dead.  */\n@@ -1200,7 +1200,7 @@ ssa_fast_dce (df)\n \n       /* If we did not find a use of this register, then the definition\n \t of this register is dead.  */\n-\t     \n+\n       if (! found_use)\n \t{\n \t  rtx def = VARRAY_RTX (ssa_definition, reg);\n@@ -1221,5 +1221,5 @@ ssa_fast_dce (df)\n \n   /* Update the use-def chains in the df_analyzer as needed.  */\n   df_analyse (df_analyzer, 0,\n-              DF_RD_CHAIN | DF_RU_CHAIN | DF_REG_INFO | DF_HARD_REGS);\n+\t      DF_RD_CHAIN | DF_RU_CHAIN | DF_REG_INFO | DF_HARD_REGS);\n }"}, {"sha": "45dcd659f00ccaa0f4499bccf41dca5c51f08a9a", "filename": "gcc/ssa-dce.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-dce.c?ref=786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "patch": "@@ -370,7 +370,7 @@ find_inherently_necessary (x)\n     return !0;\n   else\n     switch (GET_CODE (x))\n-      {  \n+      {\n       case CALL_INSN:\n       case BARRIER:\n       case PREFETCH:\n@@ -691,7 +691,7 @@ ssa_eliminate_dead_code ()\n \t    remove_edge (temp);\n \t  }\n \n-\t/* Create an edge from this block to the post dominator.  \n+\t/* Create an edge from this block to the post dominator.\n \t   What about the PHI nodes at the target?  */\n \tmake_edge (bb, pdom_bb, 0);\n \n@@ -711,7 +711,7 @@ ssa_eliminate_dead_code ()\n     else if (!JUMP_P (insn))\n       delete_insn_bb (insn);\n   });\n-  \n+\n   /* Remove fake edges from the CFG.  */\n   remove_fake_edges ();\n "}, {"sha": "686339cd156cc4320d9bc38da607442e4ef8abbd", "filename": "gcc/ssa.c", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "patch": "@@ -49,7 +49,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"output.h\"\n #include \"ssa.h\"\n \n-/* TODO: \n+/* TODO:\n \n    Handle subregs better, maybe.  For now, if a reg that's set in a\n    subreg expression is duplicated going into SSA form, an extra copy\n@@ -174,15 +174,15 @@ static void insert_phi_node\n   PARAMS ((int regno, int b));\n static void insert_phi_nodes\n   PARAMS ((sbitmap *idfs, sbitmap *evals, int nregs));\n-static void create_delayed_rename \n+static void create_delayed_rename\n   PARAMS ((struct rename_context *, rtx *));\n-static void apply_delayed_renames \n+static void apply_delayed_renames\n   PARAMS ((struct rename_context *));\n-static int rename_insn_1 \n+static int rename_insn_1\n   PARAMS ((rtx *ptr, void *data));\n-static void rename_block \n+static void rename_block\n   PARAMS ((int b, int *idom));\n-static void rename_registers \n+static void rename_registers\n   PARAMS ((int nregs, int *idom));\n \n static inline int ephi_add_node\n@@ -195,20 +195,20 @@ static void ephi_create\n   PARAMS ((int t, sbitmap visited, sbitmap *pred, sbitmap *succ, rtx *nodes));\n static void eliminate_phi\n   PARAMS ((edge e, partition reg_partition));\n-static int make_regs_equivalent_over_bad_edges \n+static int make_regs_equivalent_over_bad_edges\n   PARAMS ((int bb, partition reg_partition));\n \n /* These are used only in the conservative register partitioning\n    algorithms.  */\n-static int make_equivalent_phi_alternatives_equivalent \n+static int make_equivalent_phi_alternatives_equivalent\n   PARAMS ((int bb, partition reg_partition));\n-static partition compute_conservative_reg_partition \n+static partition compute_conservative_reg_partition\n   PARAMS ((void));\n static int record_canonical_element_1\n   PARAMS ((void **srfp, void *data));\n static int check_hard_regs_in_partition\n   PARAMS ((partition reg_partition));\n-static int rename_equivalent_regs_in_insn \n+static int rename_equivalent_regs_in_insn\n   PARAMS ((rtx *ptr, void *data));\n \n /* These are used in the register coalescing algorithm.  */\n@@ -222,14 +222,14 @@ static int coalesce_regs_in_successor_phi_nodes\n   PARAMS ((basic_block bb, partition p, conflict_graph conflicts));\n static partition compute_coalesced_reg_partition\n   PARAMS ((void));\n-static int mark_reg_in_phi \n+static int mark_reg_in_phi\n   PARAMS ((rtx *ptr, void *data));\n static void mark_phi_and_copy_regs\n   PARAMS ((regset phi_set));\n \n-static int rename_equivalent_regs_in_insn \n+static int rename_equivalent_regs_in_insn\n   PARAMS ((rtx *ptr, void *data));\n-static void rename_equivalent_regs \n+static void rename_equivalent_regs\n   PARAMS ((partition reg_partition));\n \n /* Deal with hard registers.  */\n@@ -495,8 +495,8 @@ find_evaluations (evals, nregs)\n }\n \n /* Computing the Dominance Frontier:\n-  \n-   As decribed in Morgan, section 3.5, this may be done simply by \n+\n+   As decribed in Morgan, section 3.5, this may be done simply by\n    walking the dominator tree bottom-up, computing the frontier for\n    the children before the parent.  When considering a block B,\n    there are two cases:\n@@ -698,7 +698,7 @@ insert_phi_nodes (idfs, evals, nregs)\n     }\n }\n \n-/* Rename the registers to conform to SSA. \n+/* Rename the registers to conform to SSA.\n \n    This is essentially the algorithm presented in Figure 7.8 of Morgan,\n    with a few changes to reduce pattern search time in favour of a bit\n@@ -740,7 +740,7 @@ create_delayed_rename (c, reg_loc)\n {\n   struct rename_set_data *r;\n   r = (struct rename_set_data *) xmalloc (sizeof(*r));\n-  \n+\n   if (GET_CODE (*reg_loc) != REG\n       || !CONVERT_REGISTER_TO_SSA_P (REGNO (*reg_loc)))\n     abort ();\n@@ -756,7 +756,7 @@ create_delayed_rename (c, reg_loc)\n /* This is part of a rather ugly hack to allow the pre-ssa regno to be\n    reused.  If, during processing, a register has not yet been touched,\n    ssa_rename_to[regno][machno] will be NULL.  Now, in the course of pushing\n-   and popping values from ssa_rename_to, when we would ordinarily \n+   and popping values from ssa_rename_to, when we would ordinarily\n    pop NULL back in, we pop RENAME_NO_RTX.  We treat this exactly the\n    same as NULL, except that it signals that the original regno has\n    already been reused.  */\n@@ -775,7 +775,7 @@ apply_delayed_renames (c)\n   for (r = c->new_renames; r != NULL; r = r->next)\n     {\n       int new_regno;\n-      \n+\n       /* Failure here means that someone has a PARALLEL that sets\n \t a register twice (bad!).  */\n       if (ssa_rename_to_lookup (r->old_reg) != r->prev_reg)\n@@ -812,7 +812,7 @@ apply_delayed_renames (c)\n     }\n }\n \n-/* Part one of the first step of rename_block, called through for_each_rtx. \n+/* Part one of the first step of rename_block, called through for_each_rtx.\n    Mark pseudos that are set for later update.  Transform uses of pseudos.  */\n \n static int\n@@ -855,7 +855,7 @@ rename_insn_1 (ptr, data)\n \t   (set (subreg (reg foo)) ...)\n \t   into\n \t   (sequence [(set (reg foo_1) (reg foo))\n-\t              (set (subreg (reg foo_1)) ...)])  \n+\t              (set (subreg (reg foo_1)) ...)])\n \n \t   FIXME: Much of the time this is too much.  For some constructs\n \t   we know that the output register is strictly an output\n@@ -870,13 +870,13 @@ rename_insn_1 (ptr, data)\n \t  {\n \t    rtx i, reg;\n \t    reg = dest;\n-\t    \n+\n \t    while (GET_CODE (reg) == STRICT_LOW_PART\n \t\t   || GET_CODE (reg) == SUBREG\n \t\t   || GET_CODE (reg) == SIGN_EXTRACT\n \t\t   || GET_CODE (reg) == ZERO_EXTRACT)\n \t\treg = XEXP (reg, 0);\n-\t    \n+\n \t    if (GET_CODE (reg) == REG\n \t\t&& CONVERT_REGISTER_TO_SSA_P (REGNO (reg)))\n \t      {\n@@ -950,7 +950,7 @@ rename_insn_1 (ptr, data)\n \t      }\n \t    /* Stop traversing.  */\n \t    return -1;\n-\t  }\t    \n+\t  }\n \telse\n \t  /* Continue traversing.  */\n \t  return 0;\n@@ -979,7 +979,7 @@ rename_block (bb, idom)\n \n   /* Step One: Walk the basic block, adding new names for sets and\n      replacing uses.  */\n-     \n+\n   next = b->head;\n   last = b->end;\n   do\n@@ -1004,7 +1004,7 @@ rename_block (bb, idom)\n \t    {\n \t      rtx seq;\n \t      int i;\n-\t      \n+\n \t      emit (PATTERN (insn));\n \t      seq = gen_sequence ();\n \t      /* We really want a SEQUENCE of SETs, not a SEQUENCE\n@@ -1014,7 +1014,7 @@ rename_block (bb, idom)\n \t      PATTERN (insn) = seq;\n \t    }\n \t  end_sequence ();\n-\t  \n+\n \t  apply_delayed_renames (&context);\n \t  set_data = context.done_renames;\n \t}\n@@ -1099,7 +1099,7 @@ rename_block (bb, idom)\n       next = set_data->next;\n       free (set_data);\n       set_data = next;\n-    }      \n+    }\n }\n \n static void\n@@ -1112,12 +1112,12 @@ rename_registers (nregs, idom)\n \n   ssa_rename_to_pseudo = (rtx *) alloca (nregs * sizeof(rtx));\n   memset ((char *) ssa_rename_to_pseudo, 0, nregs * sizeof(rtx));\n-  memset ((char *) ssa_rename_to_hard, 0, \n+  memset ((char *) ssa_rename_to_hard, 0,\n \t FIRST_PSEUDO_REGISTER * NUM_MACHINE_MODES * sizeof (rtx));\n \n   rename_block (0, idom);\n \n-  /* ??? Update basic_block_live_at_start, and other flow info \n+  /* ??? Update basic_block_live_at_start, and other flow info\n      as needed.  */\n \n   ssa_rename_to_pseudo = NULL;\n@@ -1247,7 +1247,7 @@ ephi_forward (t, visited, succ, tstack)\n   EXECUTE_IF_SET_IN_SBITMAP (succ[t], 0, s,\n     {\n       if (! TEST_BIT (visited, s))\n-        tstack = ephi_forward (s, visited, succ, tstack);\n+\ttstack = ephi_forward (s, visited, succ, tstack);\n     });\n \n   *tstack++ = t;\n@@ -1291,7 +1291,7 @@ ephi_create (t, visited, pred, succ, nodes)\n   int p;\n \n   /* Iterate through the predecessor list looking for unvisited nodes.\n-     If there are any, we have a cycle, and must deal with that.  At \n+     If there are any, we have a cycle, and must deal with that.  At\n      the same time, look for a visited predecessor.  If there is one,\n      we won't need to create a temporary.  */\n \n@@ -1322,8 +1322,8 @@ ephi_create (t, visited, pred, succ, nodes)\n \t      emit_move_insn (nodes[p], reg_u);\n \t    }\n \t});\n-    }  \n-  else \n+    }\n+  else\n     {\n       /* No cycle.  Just copy the value from a successor.  */\n \n@@ -1366,7 +1366,7 @@ eliminate_phi (e, reg_partition)\n   if (n_nodes == 0)\n     return;\n \n-  /* Build the auxiliary graph R(B). \n+  /* Build the auxiliary graph R(B).\n \n      The nodes of the graph are the members of the register partition\n      present in Phi(B).  There is an edge from FIND(T0)->FIND(T1) for\n@@ -1399,7 +1399,7 @@ eliminate_phi (e, reg_partition)\n \n       reg = regno_reg_rtx[partition_find (reg_partition, REGNO (reg))];\n       tgt = regno_reg_rtx[partition_find (reg_partition, REGNO (tgt))];\n-      /* If the two registers are already in the same partition, \n+      /* If the two registers are already in the same partition,\n \t nothing will need to be done.  */\n       if (reg != tgt)\n \t{\n@@ -1429,10 +1429,10 @@ eliminate_phi (e, reg_partition)\n \n   sbitmap_zero (visited);\n \n-  /* As we find a solution to the tsort, collect the implementation \n+  /* As we find a solution to the tsort, collect the implementation\n      insns in a sequence.  */\n   start_sequence ();\n-  \n+\n   while (tstack != stack)\n     {\n       i = *--tstack;\n@@ -1456,14 +1456,14 @@ eliminate_phi (e, reg_partition)\n /* For basic block B, consider all phi insns which provide an\n    alternative corresponding to an incoming abnormal critical edge.\n    Place the phi alternative corresponding to that abnormal critical\n-   edge in the same register class as the destination of the set.  \n+   edge in the same register class as the destination of the set.\n \n    From Morgan, p. 178:\n \n-     For each abnormal critical edge (C, B), \n-     if T0 = phi (T1, ..., Ti, ..., Tm) is a phi node in B, \n-     and C is the ith predecessor of B, \n-     then T0 and Ti must be equivalent. \n+     For each abnormal critical edge (C, B),\n+     if T0 = phi (T1, ..., Ti, ..., Tm) is a phi node in B,\n+     and C is the ith predecessor of B,\n+     then T0 and Ti must be equivalent.\n \n    Return non-zero iff any such cases were found for which the two\n    regs were not already in the same class.  */\n@@ -1481,7 +1481,7 @@ make_regs_equivalent_over_bad_edges (bb, reg_partition)\n   phi = first_insn_after_basic_block_note (b);\n \n   /* Scan all the phi nodes.  */\n-  for (; \n+  for (;\n        PHI_NODE_P (phi);\n        phi = next_nonnote_insn (phi))\n     {\n@@ -1491,7 +1491,7 @@ make_regs_equivalent_over_bad_edges (bb, reg_partition)\n       rtx tgt = SET_DEST (set);\n \n       /* The set target is expected to be an SSA register.  */\n-      if (GET_CODE (tgt) != REG \n+      if (GET_CODE (tgt) != REG\n \t  || !CONVERT_REGISTER_TO_SSA_P (REGNO (tgt)))\n \tabort ();\n       tgt_regno = REGNO (tgt);\n@@ -1509,23 +1509,23 @@ make_regs_equivalent_over_bad_edges (bb, reg_partition)\n \t      continue;\n \n \t    /* The phi alternative is expected to be an SSA register.  */\n-\t    if (GET_CODE (*alt) != REG \n+\t    if (GET_CODE (*alt) != REG\n \t\t|| !CONVERT_REGISTER_TO_SSA_P (REGNO (*alt)))\n \t      abort ();\n \t    alt_regno = REGNO (*alt);\n \n \t    /* If the set destination and the phi alternative aren't\n \t       already in the same class...  */\n-\t    if (partition_find (reg_partition, tgt_regno) \n+\t    if (partition_find (reg_partition, tgt_regno)\n \t\t!= partition_find (reg_partition, alt_regno))\n \t      {\n \t\t/* ... make them such.  */\n \t\tif (conflicting_hard_regs_p (tgt_regno, alt_regno))\n \t\t  /* It is illegal to unify a hard register with a\n \t\t     different register.  */\n \t\t  abort ();\n-\t\t\n-\t\tpartition_union (reg_partition, \n+\n+\t\tpartition_union (reg_partition,\n \t\t\t\t tgt_regno, alt_regno);\n \t\t++changed;\n \t      }\n@@ -1554,7 +1554,7 @@ make_equivalent_phi_alternatives_equivalent (bb, reg_partition)\n   phi = first_insn_after_basic_block_note (b);\n \n   /* Scan all the phi nodes.  */\n-  for (; \n+  for (;\n        PHI_NODE_P (phi);\n        phi = next_nonnote_insn (phi))\n     {\n@@ -1572,7 +1572,7 @@ make_equivalent_phi_alternatives_equivalent (bb, reg_partition)\n \t  rtx set2 = PATTERN (phi2);\n \t  /* The regno of the destination of the set.  */\n \t  int tgt2_regno = REGNO (SET_DEST (set2));\n-\t\t  \n+\n \t  /* Are the set destinations equivalent regs?  */\n \t  if (partition_find (reg_partition, tgt_regno) ==\n \t      partition_find (reg_partition, tgt2_regno))\n@@ -1602,7 +1602,7 @@ make_equivalent_phi_alternatives_equivalent (bb, reg_partition)\n \n \t\t  /* If the alternatives aren't already in the same\n \t\t     class ...  */\n-\t\t  if (partition_find (reg_partition, REGNO (*alt)) \n+\t\t  if (partition_find (reg_partition, REGNO (*alt))\n \t\t      != partition_find (reg_partition, REGNO (*alt2)))\n \t\t    {\n \t\t      /* ... make them so.  */\n@@ -1611,7 +1611,7 @@ make_equivalent_phi_alternatives_equivalent (bb, reg_partition)\n \t\t\t   a different register.  */\n \t\t\tabort ();\n \n-\t\t      partition_union (reg_partition, \n+\t\t      partition_union (reg_partition,\n \t\t\t\t       REGNO (*alt), REGNO (*alt2));\n \t\t      ++changed;\n \t\t    }\n@@ -1635,7 +1635,7 @@ compute_conservative_reg_partition ()\n   /* We don't actually work with hard registers, but it's easier to\n      carry them around anyway rather than constantly doing register\n      number arithmetic.  */\n-  partition p = \n+  partition p =\n     partition_new (ssa_definition->num_elements);\n \n   /* The first priority is to make sure registers that might have to\n@@ -1644,7 +1644,7 @@ compute_conservative_reg_partition ()\n      edges.  */\n   for (bb = n_basic_blocks; --bb >= 0; )\n     changed += make_regs_equivalent_over_bad_edges (bb, p);\n-  \n+\n   /* Now we have to insure that corresponding arguments of phi nodes\n      assigning to corresponding regs are equivalent.  Iterate until\n      nothing changes.  */\n@@ -1667,28 +1667,28 @@ compute_conservative_reg_partition ()\n        abnormal critical edges (which isn't possible).\n \n     2. Figure out which regs are involved (in the LHS or RHS) of\n-       copies and phi nodes.  Compute conflicts among these regs.  \n+       copies and phi nodes.  Compute conflicts among these regs.\n \n     3. Walk around the instruction stream, placing two regs in the\n        same class of the partition if one appears on the LHS and the\n        other on the RHS of a copy or phi node and the two regs don't\n        conflict.  The conflict information of course needs to be\n-       updated.  \n+       updated.\n \n     4. If anything has changed, there may be new opportunities to\n        coalesce regs, so go back to 2.\n */\n \n /* If REG1 and REG2 don't conflict in CONFLICTS, place them in the\n    same class of partition P, if they aren't already.  Update\n-   CONFLICTS appropriately.  \n+   CONFLICTS appropriately.\n \n    Returns one if REG1 and REG2 were placed in the same class but were\n-   not previously; zero otherwise.  \n+   not previously; zero otherwise.\n \n    See Morgan figure 11.15.  */\n \n-static int \n+static int\n coalesce_if_unconflicting (p, conflicts, reg1, reg2)\n      partition p;\n      conflict_graph conflicts;\n@@ -1705,7 +1705,7 @@ coalesce_if_unconflicting (p, conflicts, reg1, reg2)\n      REG2.  */\n   reg1 = partition_find (p, reg1);\n   reg2 = partition_find (p, reg2);\n-  \n+\n   /* If they're already in the same class, there's nothing to do.  */\n   if (reg1 == reg2)\n     return 0;\n@@ -1720,7 +1720,7 @@ coalesce_if_unconflicting (p, conflicts, reg1, reg2)\n \n   /* Find the new canonical reg for the merged class.  */\n   reg = partition_find (p, reg1);\n-  \n+\n   /* Merge conflicts from the two previous classes.  */\n   conflict_graph_merge_regs (conflicts, reg, reg1);\n   conflict_graph_merge_regs (conflicts, reg, reg2);\n@@ -1769,7 +1769,7 @@ coalesce_regs_in_copies (bb, p, conflicts)\n \n       /* Coalesce only if the reg modes are the same.  As long as\n \t each reg's rtx is unique, it can have only one mode, so two\n-\t pseudos of different modes can't be coalesced into one.  \n+\t pseudos of different modes can't be coalesced into one.\n \n          FIXME: We can probably get around this by inserting SUBREGs\n          where appropriate, but for now we don't bother.  */\n@@ -1779,7 +1779,7 @@ coalesce_regs_in_copies (bb, p, conflicts)\n       /* Found a copy; see if we can use the same reg for both the\n \t source and destination (and thus eliminate the copy,\n \t ultimately).  */\n-      changed += coalesce_if_unconflicting (p, conflicts, \n+      changed += coalesce_if_unconflicting (p, conflicts,\n \t\t\t\t\t    REGNO (src), REGNO (dest));\n     }\n \n@@ -1805,23 +1805,23 @@ coalesce_reg_in_phi (insn, dest_regno, src_regno, data)\n      int src_regno;\n      void *data;\n {\n-  struct phi_coalesce_context *context = \n+  struct phi_coalesce_context *context =\n     (struct phi_coalesce_context *) data;\n-  \n+\n   /* Attempt to use the same reg, if they don't conflict.  */\n-  context->changed \n-    += coalesce_if_unconflicting (context->p, context->conflicts, \n+  context->changed\n+    += coalesce_if_unconflicting (context->p, context->conflicts,\n \t\t\t\t  dest_regno, src_regno);\n   return 0;\n }\n \n /* For each alternative in a phi function corresponding to basic block\n    BB (in phi nodes in successor block to BB), place the reg in the\n    phi alternative and the reg to which the phi value is set into the\n-   same class in partition P, if allowed by CONFLICTS.  \n+   same class in partition P, if allowed by CONFLICTS.\n \n    Return the number of changes that were made to P.\n-   \n+\n    See Morgan figure 11.14.  */\n \n static int\n@@ -1841,7 +1841,7 @@ coalesce_regs_in_successor_phi_nodes (bb, p, conflicts)\n }\n \n /* Compute and return a partition of pseudos.  Where possible,\n-   non-conflicting pseudos are placed in the same class.  \n+   non-conflicting pseudos are placed in the same class.\n \n    The caller is responsible for deallocating the returned partition.  */\n \n@@ -1853,7 +1853,7 @@ compute_coalesced_reg_partition ()\n   regset_head phi_set_head;\n   regset phi_set = &phi_set_head;\n \n-  partition p = \n+  partition p =\n     partition_new (ssa_definition->num_elements);\n \n   /* The first priority is to make sure registers that might have to\n@@ -1887,7 +1887,7 @@ compute_coalesced_reg_partition ()\n \t{\n \t  basic_block block = BASIC_BLOCK (bb);\n \t  changed += coalesce_regs_in_copies (block, p, conflicts);\n-\t  changed += \n+\t  changed +=\n \t    coalesce_regs_in_successor_phi_nodes (block, p, conflicts);\n \t}\n \n@@ -1995,7 +1995,7 @@ rename_equivalent_regs_in_insn (ptr, data)\n \t  unsigned int new_regno = partition_find (reg_partition, regno);\n \t  rtx canonical_element_rtx = ssa_rename_from_lookup (new_regno);\n \n-\t  if (canonical_element_rtx != NULL_RTX && \n+\t  if (canonical_element_rtx != NULL_RTX &&\n \t      HARD_REGISTER_P (canonical_element_rtx))\n \t    {\n \t      if (REGNO (canonical_element_rtx) != regno)\n@@ -2036,7 +2036,7 @@ record_canonical_element_1 (srfp, data)\n     ((struct ssa_rename_from_hash_table_data *) data)->canonical_elements;\n   partition reg_partition =\n     ((struct ssa_rename_from_hash_table_data *) data)->reg_partition;\n-  \n+\n   SET_BIT (canonical_elements, partition_find (reg_partition, reg));\n   return 1;\n }\n@@ -2108,11 +2108,11 @@ rename_equivalent_regs (reg_partition)\n \t  insn = next;\n \t  if (INSN_P (insn))\n \t    {\n-\t      for_each_rtx (&PATTERN (insn), \n-\t\t\t    rename_equivalent_regs_in_insn, \n+\t      for_each_rtx (&PATTERN (insn),\n+\t\t\t    rename_equivalent_regs_in_insn,\n \t\t\t    reg_partition);\n-\t      for_each_rtx (&REG_NOTES (insn), \n-\t\t\t    rename_equivalent_regs_in_insn, \n+\t      for_each_rtx (&REG_NOTES (insn),\n+\t\t\t    rename_equivalent_regs_in_insn,\n \t\t\t    reg_partition);\n \n \t      if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n@@ -2147,7 +2147,7 @@ convert_from_ssa ()\n \n   /* Need global_live_at_{start,end} up to date.  There should not be\n      any significant dead code at this point, except perhaps dead\n-     stores.  So do not take the time to perform dead code elimination. \n+     stores.  So do not take the time to perform dead code elimination.\n \n      Register coalescing needs death notes, so generate them.  */\n   life_analysis (insns, NULL, PROP_DEATH_NOTES);\n@@ -2201,7 +2201,7 @@ convert_from_ssa ()\n \t  /* If we've reached the end of the block, stop.  */\n \t  else if (insn == BLOCK_END (bb))\n \t    break;\n-\t  else \n+\t  else\n \t    insn = NEXT_INSN (insn);\n \t}\n     }\n@@ -2234,7 +2234,7 @@ for_each_successor_phi (bb, fn, data)\n      void *data;\n {\n   edge e;\n-  \n+\n   if (bb == EXIT_BLOCK_PTR)\n     return 0;\n \n@@ -2244,7 +2244,7 @@ for_each_successor_phi (bb, fn, data)\n       rtx insn;\n \n       basic_block successor = e->dest;\n-      if (successor == ENTRY_BLOCK_PTR \n+      if (successor == ENTRY_BLOCK_PTR\n \t  || successor == EXIT_BLOCK_PTR)\n \tcontinue;\n \n@@ -2261,7 +2261,7 @@ for_each_successor_phi (bb, fn, data)\n \t  rtx phi_set = PATTERN (insn);\n \t  rtx *alternative = phi_alternative (phi_set, bb->index);\n \t  rtx phi_src;\n-\t  \n+\n \t  /* This phi function may not have an alternative\n \t     corresponding to the incoming edge, indicating the\n \t     assigned variable is not defined along the edge.  */\n@@ -2270,7 +2270,7 @@ for_each_successor_phi (bb, fn, data)\n \t  phi_src = *alternative;\n \n \t  /* Invoke the callback.  */\n-\t  result = (*fn) (insn, REGNO (SET_DEST (phi_set)), \n+\t  result = (*fn) (insn, REGNO (SET_DEST (phi_set)),\n \t\t\t  REGNO (phi_src), data);\n \n \t  /* Terminate if requested.  */\n@@ -2301,6 +2301,6 @@ conflicting_hard_regs_p (reg1, reg2)\n     return 1;\n   if (!HARD_REGISTER_NUM_P (orig_reg1) && HARD_REGISTER_NUM_P (orig_reg2))\n     return 1;\n-  \n+\n   return 0;\n }"}, {"sha": "cbe2da0b9607793558809592dfedb79fc2c7301e", "filename": "gcc/stmt.c", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "patch": "@@ -496,7 +496,7 @@ mark_block_nesting (n)\n       ggc_mark_tree (n->data.block.cleanups);\n       ggc_mark_tree (n->data.block.outer_cleanups);\n \n-      for (l = n->data.block.label_chain; l != NULL; l = l->next) \n+      for (l = n->data.block.label_chain; l != NULL; l = l->next)\n \t{\n \t  ggc_mark (l);\n \t  ggc_mark_tree (l->label);\n@@ -848,7 +848,7 @@ expand_goto (label)\n \t  emit_indirect_jump (handler_slot);\n \t}\n \n-      /* Search backwards to the jump insn and mark it as a \n+      /* Search backwards to the jump insn and mark it as a\n \t non-local goto.  */\n       for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n \t{\n@@ -1047,8 +1047,8 @@ expand_fixup (tree_label, rtl_label, last_insn)\n \t as a placeholder.  */\n \n       {\n-        rtx original_before_jump\n-          = last_insn ? last_insn : get_last_insn ();\n+\trtx original_before_jump\n+\t  = last_insn ? last_insn : get_last_insn ();\n \trtx start;\n \trtx end;\n \ttree block;\n@@ -1066,17 +1066,17 @@ expand_fixup (tree_label, rtl_label, last_insn)\n \t      = block;\n \t  }\n \n-        start_sequence ();\n-        start = emit_note (NULL, NOTE_INSN_BLOCK_BEG);\n+\tstart_sequence ();\n+\tstart = emit_note (NULL, NOTE_INSN_BLOCK_BEG);\n \tif (cfun->x_whole_function_mode_p)\n \t  NOTE_BLOCK (start) = block;\n \tfixup->before_jump = emit_note (NULL, NOTE_INSN_DELETED);\n \tend = emit_note (NULL, NOTE_INSN_BLOCK_END);\n \tif (cfun->x_whole_function_mode_p)\n \t  NOTE_BLOCK (end) = block;\n-        fixup->context = block;\n-        end_sequence ();\n-        emit_insns_after (start, original_before_jump);\n+\tfixup->context = block;\n+\tend_sequence ();\n+\temit_insns_after (start, original_before_jump);\n       }\n \n       fixup->block_start_count = current_block_start_count;\n@@ -1382,7 +1382,7 @@ parse_output_constraint (constraint_p, operand_num, ninputs, noutputs,\n       case '=':\n \terror (\"operand constraint contains incorrectly positioned '+' or '='\");\n \treturn false;\n-\t\n+\n       case '%':\n \tif (operand_num + 1 == ninputs + noutputs)\n \t  {\n@@ -1419,7 +1419,7 @@ parse_output_constraint (constraint_p, operand_num, ninputs, noutputs,\n \t*allows_reg = true;\n \t*allows_mem = true;\n \tbreak;\n-\t\n+\n       case 'p': case 'r':\n \t*allows_reg = true;\n \tbreak;\n@@ -1575,7 +1575,7 @@ parse_input_constraint (constraint_p, input_num, ninputs, noutputs, ninout,\n    OUTPUTS is a list of output arguments (lvalues); INPUTS a list of inputs.\n    Each output or input has an expression in the TREE_VALUE and\n    and a tree list in TREE_PURPOSE which in turn contains a constraint\n-   name in TREE_VALUE (or NULL_TREE) and a constraint string \n+   name in TREE_VALUE (or NULL_TREE) and a constraint string\n    in TREE_PURPOSE.\n    CLOBBERS is a list of STRING_CST nodes each naming a hard register\n    that is clobbered by this insn.\n@@ -1752,7 +1752,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t  if ((! allows_mem && GET_CODE (output_rtx[i]) == MEM)\n \t      || GET_CODE (output_rtx[i]) == CONCAT)\n \t    {\n-    \t      real_output_rtx[i] = protect_from_queue (output_rtx[i], 1);\n+\t      real_output_rtx[i] = protect_from_queue (output_rtx[i], 1);\n \t      output_rtx[i] = gen_reg_rtx (GET_MODE (output_rtx[i]));\n \t      if (is_inout)\n \t\temit_move_insn (output_rtx[i], real_output_rtx[i]);\n@@ -1781,7 +1781,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n   body = gen_rtx_ASM_OPERANDS ((noutputs == 0 ? VOIDmode\n \t\t\t\t: GET_MODE (output_rtx[0])),\n-\t\t\t       TREE_STRING_POINTER (string), \n+\t\t\t       TREE_STRING_POINTER (string),\n \t\t\t       empty_string, 0, argvec, constraintvec,\n \t\t\t       filename, line);\n \n@@ -2127,7 +2127,7 @@ resolve_operand_names (string, outputs, inputs, pconstraints)\n \n /* A subroutine of resolve_operand_names.  P points to the '[' for a\n    potential named operand of the form [<name>].  In place, replace\n-   the name and brackets with a number.  Return a pointer to the \n+   the name and brackets with a number.  Return a pointer to the\n    balance of the string after substitution.  */\n \n static char *\n@@ -2697,7 +2697,7 @@ expand_end_loop ()\n      the end of the entry condtional.  Without this, our lexical scan\n      can't tell the difference between an entry conditional and a\n      body conditional that exits the loop.  Mistaking the two means\n-     that we can misplace the NOTE_INSN_LOOP_CONT note, which can \n+     that we can misplace the NOTE_INSN_LOOP_CONT note, which can\n      screw up loop unrolling.\n \n      Things will be oh so much better when loop optimization is done\n@@ -2738,7 +2738,7 @@ expand_end_loop ()\n \n \t/* Likewise for debug scopes.  In this case we'll either (1) move\n \t   all of the notes if they are properly nested or (2) leave the\n-\t   notes alone and only rotate the loop at high optimization \n+\t   notes alone and only rotate the loop at high optimization\n \t   levels when we expect to scrog debug info.  */\n \telse if (NOTE_LINE_NUMBER (etc_note) == NOTE_INSN_BLOCK_BEG)\n \t  debug_blocks++;\n@@ -2890,7 +2890,7 @@ expand_exit_loop_if_false (whichloop, cond)\n }\n \n /* Like expand_exit_loop_if_false except also emit a note marking\n-   the end of the conditional.  Should only be used immediately \n+   the end of the conditional.  Should only be used immediately\n    after expand_loop_start.  */\n \n int\n@@ -3114,7 +3114,7 @@ expand_return (retval)\n       /* Treat this like a return of no value from a function that\n \t returns a value.  */\n       expand_null_return ();\n-      return; \n+      return;\n     }\n   else if (TREE_CODE (retval) == RESULT_DECL)\n     retval_rhs = retval;\n@@ -5251,7 +5251,7 @@ check_for_full_enumeration_handling (type)\n \t   chain && !tree_int_cst_equal (n->low, TREE_VALUE (chain));\n \t   chain = TREE_CHAIN (chain))\n \t;\n-      \n+\n       if (!chain)\n \t{\n \t  if (TYPE_NAME (type) == 0)\n@@ -5271,7 +5271,7 @@ check_for_full_enumeration_handling (type)\n \t       chain && !tree_int_cst_equal (n->high, TREE_VALUE (chain));\n \t       chain = TREE_CHAIN (chain))\n \t    ;\n-\t  \n+\n \t  if (!chain)\n \t    {\n \t      if (TYPE_NAME (type) == 0)\n@@ -5291,11 +5291,11 @@ check_for_full_enumeration_handling (type)\n \n /* Free CN, and its children.  */\n \n-static void \n+static void\n free_case_nodes (cn)\n      case_node_ptr cn;\n {\n-  if (cn) \n+  if (cn)\n     {\n       free_case_nodes (cn->left);\n       free_case_nodes (cn->right);\n@@ -5537,21 +5537,21 @@ expand_end_case_type (orig_index, orig_type)\n \t    {\n \t      index_type = thiscase->data.case_stmt.nominal_type;\n \n-              /* Index jumptables from zero for suitable values of\n+\t      /* Index jumptables from zero for suitable values of\n                  minval to avoid a subtraction.  */\n-              if (! optimize_size\n-                  && compare_tree_int (minval, 0) > 0\n-                  && compare_tree_int (minval, 3) < 0)\n-                {\n-                  minval = integer_zero_node;\n-                  range = maxval;\n-                }\n+\t      if (! optimize_size\n+\t\t  && compare_tree_int (minval, 0) > 0\n+\t\t  && compare_tree_int (minval, 3) < 0)\n+\t\t{\n+\t\t  minval = integer_zero_node;\n+\t\t  range = maxval;\n+\t\t}\n \n \t      if (! try_tablejump (index_type, index_expr, minval, range,\n \t\t\t\t   table_label, default_label))\n \t\tabort ();\n \t    }\n-\t  \n+\n \t  /* Get table of labels to jump to, in order of case index.  */\n \n \t  ncases = tree_low_cst (range, 0) + 1;\n@@ -5564,11 +5564,11 @@ expand_end_case_type (orig_index, orig_type)\n \t\t value since that should fit in a HOST_WIDE_INT while the\n \t\t actual values may not.  */\n \t      HOST_WIDE_INT i_low\n-\t\t= tree_low_cst (fold (build (MINUS_EXPR, index_type, \n-                                             n->low, minval)), 1);\n+\t\t= tree_low_cst (fold (build (MINUS_EXPR, index_type,\n+\t\t\t\t\t     n->low, minval)), 1);\n \t      HOST_WIDE_INT i_high\n-\t\t= tree_low_cst (fold (build (MINUS_EXPR, index_type, \n-                                             n->high, minval)), 1);\n+\t\t= tree_low_cst (fold (build (MINUS_EXPR, index_type,\n+\t\t\t\t\t     n->high, minval)), 1);\n \t      HOST_WIDE_INT i;\n \n \t      for (i = i_low; i <= i_high; i ++)\n@@ -6400,7 +6400,7 @@ emit_case_nodes (index, node, default_label, index_type)\n \t      new_bound = expand_expr (fold (build (MINUS_EXPR, type,\n \t\t\t\t\t\t    high, low)),\n \t\t\t\t       NULL_RTX, mode, 0);\n-\t\t\t\t\n+\n \t      emit_cmp_and_jump_insns (new_index, new_bound, GT, NULL_RTX,\n \t\t\t\t       mode, 1, default_label);\n \t    }"}, {"sha": "8bbf4fea11f44b48726b9ed4d86407c4b2586ba6", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "patch": "@@ -180,7 +180,7 @@ variable_size (size)\n     }\n \n   if (immediate_size_expand)\n-    /* NULL_RTX is not defined; neither is the rtx type. \n+    /* NULL_RTX is not defined; neither is the rtx type.\n        Also, we would like to pass const0_rtx here, but don't have it.  */\n     expand_expr (size, expand_expr (integer_zero_node, NULL_RTX, VOIDmode, 0),\n \t\t VOIDmode, 0);\n@@ -283,7 +283,7 @@ int_mode_for_mode (mode)\n \n     case MODE_RANDOM:\n       if (mode == BLKmode)\n-        break;\n+\tbreak;\n \n       /* ... fall through ...  */\n \n@@ -381,7 +381,7 @@ layout_decl (decl, known_align)\n       && (DECL_ALIGN (decl) == 0\n \t  || (! (code == FIELD_DECL && DECL_PACKED (decl))\n \t      && TYPE_ALIGN (type) > DECL_ALIGN (decl))))\n-    {\t      \n+    {\n       DECL_ALIGN (decl) = TYPE_ALIGN (type);\n       DECL_USER_ALIGN (decl) = 0;\n     }\n@@ -407,7 +407,7 @@ layout_decl (decl, known_align)\n \t}\n     }\n \n-  /* See if we can use an ordinary integer mode for a bit-field. \n+  /* See if we can use an ordinary integer mode for a bit-field.\n      Conditions are: a fixed size that is correct for another mode\n      and occupying a complete byte or bytes on proper boundary.  */\n   if (code == FIELD_DECL && DECL_BIT_FIELD (decl)\n@@ -478,15 +478,15 @@ set_lang_adjust_rli (f)\n /* Begin laying out type T, which may be a RECORD_TYPE, UNION_TYPE, or\n    QUAL_UNION_TYPE.  Return a pointer to a struct record_layout_info which\n    is to be passed to all other layout functions for this record.  It is the\n-   responsibility of the caller to call `free' for the storage returned. \n+   responsibility of the caller to call `free' for the storage returned.\n    Note that garbage collection is not permitted until we finish laying\n    out the record.  */\n \n record_layout_info\n start_record_layout (t)\n      tree t;\n {\n-  record_layout_info rli \n+  record_layout_info rli\n     = (record_layout_info) xmalloc (sizeof (struct record_layout_info_s));\n \n   rli->t = t;\n@@ -587,7 +587,7 @@ normalize_offset (poffset, pbitpos, off_align)\n \t= size_binop (PLUS_EXPR, *poffset,\n \t\t      size_binop (MULT_EXPR, convert (sizetype, extra_aligns),\n \t\t\t\t  size_int (off_align / BITS_PER_UNIT)));\n-\t\t\t\t\n+\n       *pbitpos\n \t= size_binop (FLOOR_MOD_EXPR, *pbitpos, bitsize_int (off_align));\n     }\n@@ -654,7 +654,7 @@ place_union_field (rli, field)\n   unsigned int desired_align;\n \n   layout_decl (field, 0);\n-  \n+\n   DECL_FIELD_OFFSET (field) = size_zero_node;\n   DECL_FIELD_BIT_OFFSET (field) = bitsize_zero_node;\n   SET_DECL_OFFSET_ALIGN (field, BIGGEST_ALIGNMENT);\n@@ -685,7 +685,7 @@ place_union_field (rli, field)\n      entire union to have `int' alignment.  */\n   if (PCC_BITFIELD_TYPE_MATTERS && DECL_BIT_FIELD_TYPE (field))\n     {\n-      rli->record_align = MAX (rli->record_align, \n+      rli->record_align = MAX (rli->record_align,\n \t\t\t       TYPE_ALIGN (TREE_TYPE (field)));\n       rli->unpadded_align = MAX (rli->unpadded_align,\n \t\t\t\t TYPE_ALIGN (TREE_TYPE (field)));\n@@ -697,7 +697,7 @@ place_union_field (rli, field)\n   if (TREE_CODE (rli->t) == UNION_TYPE)\n     rli->offset = size_binop (MAX_EXPR, rli->offset, DECL_SIZE_UNIT (field));\n   else if (TREE_CODE (rli->t) == QUAL_UNION_TYPE)\n-    rli->offset = fold (build (COND_EXPR, sizetype, \n+    rli->offset = fold (build (COND_EXPR, sizetype,\n \t\t\t       DECL_QUALIFIER (field),\n \t\t\t       DECL_SIZE_UNIT (field), rli->offset));\n }\n@@ -721,7 +721,7 @@ place_field (rli, field)\n   unsigned int user_align;\n   /* The type of this field.  */\n   tree type = TREE_TYPE (field);\n- \n+\n   if (TREE_CODE (field) == ERROR_MARK || TREE_CODE (type) == ERROR_MARK)\n       return;\n \n@@ -806,7 +806,7 @@ place_field (rli, field)\n \t}\n       else\n \tdesired_align = 1;\n-    }\t\n+    }\n   else\n #ifdef PCC_BITFIELD_TYPE_MATTERS\n   if (PCC_BITFIELD_TYPE_MATTERS && type != error_mark_node\n@@ -1121,7 +1121,7 @@ finalize_record_size (rli)\n   if (warn_padded && TREE_CONSTANT (unpadded_size)\n       && simple_cst_equal (unpadded_size, TYPE_SIZE (rli->t)) == 0)\n     warning (\"padding struct size to alignment boundary\");\n-  \n+\n   if (warn_packed && TREE_CODE (rli->t) == RECORD_TYPE\n       && TYPE_PACKED (rli->t) && ! rli->packed_maybe_necessary\n       && TREE_CONSTANT (unpadded_size))\n@@ -1208,7 +1208,7 @@ compute_record_mode (type)\n \treturn;\n \n       bitpos = int_bit_position (field);\n-\t  \n+\n       /* Must be BLKmode if any field crosses a word boundary,\n \t since extract_bit_field can't handle that in registers.  */\n       if (bitpos / BITS_PER_WORD\n@@ -1680,7 +1680,7 @@ layout_type (type)\n   /* Compute the final TYPE_SIZE, TYPE_ALIGN, etc. for TYPE.  For\n      records and unions, finish_record_layout already called this\n      function.  */\n-  if (TREE_CODE (type) != RECORD_TYPE \n+  if (TREE_CODE (type) != RECORD_TYPE\n       && TREE_CODE (type) != UNION_TYPE\n       && TREE_CODE (type) != QUAL_UNION_TYPE)\n     finalize_type_size (type);"}, {"sha": "13f90ca3b0113e0acbdde5551231c37db273fbef", "filename": "gcc/stringpool.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fstringpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786de7eb9aaaf39f96248b6d42316b2aa4e9bf63/gcc%2Fstringpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstringpool.c?ref=786de7eb9aaaf39f96248b6d42316b2aa4e9bf63", "patch": "@@ -110,7 +110,7 @@ get_identifier (text)\n \n /* Identical to get_identifier, except that the length is assumed\n    known.  */\n-   \n+\n tree\n get_identifier_with_length (text, length)\n      const char *text;"}]}