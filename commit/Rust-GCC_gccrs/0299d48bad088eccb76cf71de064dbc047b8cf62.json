{"sha": "0299d48bad088eccb76cf71de064dbc047b8cf62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI5OWQ0OGJhZDA4OGVjY2I3NmNmNzFkZTA2NGRiYzA0N2I4Y2Y2Mg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-01T13:56:09Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-01T13:56:09Z"}, "message": "Turn var-tracking.c:INT_MEM_OFFSET into a function\n\nThis avoids the double evaluation mentioned in the comments and\nsimplifies the change to make MEM_OFFSET variable.\n\n2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* var-tracking.c (INT_MEM_OFFSET): Replace with...\n\t(int_mem_offset): ...this new function.\n\t(var_mem_set, var_mem_delete_and_set, var_mem_delete)\n\t(find_mem_expr_in_1pdv, dataflow_set_preserve_mem_locs)\n\t(same_variable_part_p, use_type, add_stores, vt_get_decl_and_offset):\n\tUpdate accordingly.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254309", "tree": {"sha": "9c524e7176476e0c836b872b325b60f7351d18d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c524e7176476e0c836b872b325b60f7351d18d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0299d48bad088eccb76cf71de064dbc047b8cf62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0299d48bad088eccb76cf71de064dbc047b8cf62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0299d48bad088eccb76cf71de064dbc047b8cf62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0299d48bad088eccb76cf71de064dbc047b8cf62/comments", "author": null, "committer": null, "parents": [{"sha": "8536340f4930c47a5b444da1a2d3ad21519b5676", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8536340f4930c47a5b444da1a2d3ad21519b5676", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8536340f4930c47a5b444da1a2d3ad21519b5676"}], "stats": {"total": 42, "additions": 30, "deletions": 12}, "files": [{"sha": "45388262ce67a21921a75da2bd7a0d7247e15cb6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299d48bad088eccb76cf71de064dbc047b8cf62/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299d48bad088eccb76cf71de064dbc047b8cf62/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0299d48bad088eccb76cf71de064dbc047b8cf62", "patch": "@@ -1,3 +1,14 @@\n+2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* var-tracking.c (INT_MEM_OFFSET): Replace with...\n+\t(int_mem_offset): ...this new function.\n+\t(var_mem_set, var_mem_delete_and_set, var_mem_delete)\n+\t(find_mem_expr_in_1pdv, dataflow_set_preserve_mem_locs)\n+\t(same_variable_part_p, use_type, add_stores, vt_get_decl_and_offset):\n+\tUpdate accordingly.\n+\n 2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "16327bd43f331420dcc3e14d71feffe8f0b0c48f", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299d48bad088eccb76cf71de064dbc047b8cf62/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299d48bad088eccb76cf71de064dbc047b8cf62/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=0299d48bad088eccb76cf71de064dbc047b8cf62", "patch": "@@ -390,8 +390,15 @@ struct variable\n /* Pointer to the BB's information specific to variable tracking pass.  */\n #define VTI(BB) ((variable_tracking_info *) (BB)->aux)\n \n-/* Macro to access MEM_OFFSET as an HOST_WIDE_INT.  Evaluates MEM twice.  */\n-#define INT_MEM_OFFSET(mem) (MEM_OFFSET_KNOWN_P (mem) ? MEM_OFFSET (mem) : 0)\n+/* Return MEM_OFFSET (MEM) as a HOST_WIDE_INT, or 0 if we can't.  */\n+\n+static inline HOST_WIDE_INT\n+int_mem_offset (const_rtx mem)\n+{\n+  if (MEM_OFFSET_KNOWN_P (mem))\n+    return MEM_OFFSET (mem);\n+  return 0;\n+}\n \n #if CHECKING_P && (GCC_VERSION >= 2007)\n \n@@ -2336,7 +2343,7 @@ var_mem_set (dataflow_set *set, rtx loc, enum var_init_status initialized,\n \t     rtx set_src)\n {\n   tree decl = MEM_EXPR (loc);\n-  HOST_WIDE_INT offset = INT_MEM_OFFSET (loc);\n+  HOST_WIDE_INT offset = int_mem_offset (loc);\n \n   var_mem_decl_set (set, loc, initialized,\n \t\t    dv_from_decl (decl), offset, set_src, INSERT);\n@@ -2354,7 +2361,7 @@ var_mem_delete_and_set (dataflow_set *set, rtx loc, bool modify,\n \t\t\tenum var_init_status initialized, rtx set_src)\n {\n   tree decl = MEM_EXPR (loc);\n-  HOST_WIDE_INT offset = INT_MEM_OFFSET (loc);\n+  HOST_WIDE_INT offset = int_mem_offset (loc);\n \n   clobber_overlapping_mems (set, loc);\n   decl = var_debug_decl (decl);\n@@ -2375,7 +2382,7 @@ static void\n var_mem_delete (dataflow_set *set, rtx loc, bool clobber)\n {\n   tree decl = MEM_EXPR (loc);\n-  HOST_WIDE_INT offset = INT_MEM_OFFSET (loc);\n+  HOST_WIDE_INT offset = int_mem_offset (loc);\n \n   clobber_overlapping_mems (set, loc);\n   decl = var_debug_decl (decl);\n@@ -4618,7 +4625,7 @@ find_mem_expr_in_1pdv (tree expr, rtx val, variable_table_type *vars)\n   for (node = var->var_part[0].loc_chain; node; node = node->next)\n     if (MEM_P (node->loc)\n \t&& MEM_EXPR (node->loc) == expr\n-\t&& INT_MEM_OFFSET (node->loc) == 0)\n+\t&& int_mem_offset (node->loc) == 0)\n       {\n \twhere = node;\n \tbreak;\n@@ -4683,7 +4690,7 @@ dataflow_set_preserve_mem_locs (variable **slot, dataflow_set *set)\n \t      /* We want to remove dying MEMs that don't refer to DECL.  */\n \t      if (GET_CODE (loc->loc) == MEM\n \t\t  && (MEM_EXPR (loc->loc) != decl\n-\t\t      || INT_MEM_OFFSET (loc->loc) != 0)\n+\t\t      || int_mem_offset (loc->loc) != 0)\n \t\t  && mem_dies_at_call (loc->loc))\n \t\tbreak;\n \t      /* We want to move here MEMs that do refer to DECL.  */\n@@ -4727,7 +4734,7 @@ dataflow_set_preserve_mem_locs (variable **slot, dataflow_set *set)\n \n \t  if (GET_CODE (loc->loc) != MEM\n \t      || (MEM_EXPR (loc->loc) == decl\n-\t\t  && INT_MEM_OFFSET (loc->loc) == 0)\n+\t\t  && int_mem_offset (loc->loc) == 0)\n \t      || !mem_dies_at_call (loc->loc))\n \t    {\n \t      if (old_loc != loc->loc && emit_notes)\n@@ -5254,7 +5261,7 @@ same_variable_part_p (rtx loc, tree expr, HOST_WIDE_INT offset)\n   else if (MEM_P (loc))\n     {\n       expr2 = MEM_EXPR (loc);\n-      offset2 = INT_MEM_OFFSET (loc);\n+      offset2 = int_mem_offset (loc);\n     }\n   else\n     return false;\n@@ -5522,7 +5529,7 @@ use_type (rtx loc, struct count_use_info *cui, machine_mode *modep)\n \treturn MO_CLOBBER;\n       else if (target_for_debug_bind (var_debug_decl (expr)))\n \treturn MO_CLOBBER;\n-      else if (track_loc_p (loc, expr, INT_MEM_OFFSET (loc),\n+      else if (track_loc_p (loc, expr, int_mem_offset (loc),\n \t\t\t    false, modep, NULL)\n \t       /* Multi-part variables shouldn't refer to one-part\n \t\t  variable names such as VALUEs (never happens) or\n@@ -6017,7 +6024,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \t      rtx xexpr = gen_rtx_SET (loc, src);\n \t      if (same_variable_part_p (SET_SRC (xexpr),\n \t\t\t\t\tMEM_EXPR (loc),\n-\t\t\t\t\tINT_MEM_OFFSET (loc)))\n+\t\t\t\t\tint_mem_offset (loc)))\n \t\tmo.type = MO_COPY;\n \t      else\n \t\tmo.type = MO_SET;\n@@ -9579,7 +9586,7 @@ vt_get_decl_and_offset (rtx rtl, tree *declp, HOST_WIDE_INT *offsetp)\n       if (MEM_ATTRS (rtl))\n \t{\n \t  *declp = MEM_EXPR (rtl);\n-\t  *offsetp = INT_MEM_OFFSET (rtl);\n+\t  *offsetp = int_mem_offset (rtl);\n \t  return true;\n \t}\n     }"}]}