{"sha": "cdbca1727ce8d428964efcb2f20ee82142a2c762", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RiY2ExNzI3Y2U4ZDQyODk2NGVmY2IyZjIwZWU4MjE0MmEyYzc2Mg==", "commit": {"author": {"name": "Jeffrey D. Oldham", "email": "oldham@codesourcery.com", "date": "2000-07-31T17:33:28Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-07-31T17:33:28Z"}, "message": "Makefile.in (ssa.o): Updated header files in dependences.\n\n\t* Makefile.in (ssa.o): Updated header files in dependences.\n\t* basic-block.h: Added compute_immediate_postdominators declaration.\n\t* config/i386/i386.h (CONVERT_HARD_REGISTER_TO_SSA_P): Added\n\tdefinition.\n\t* flow.c (compute_immediate_dominators): Updated comment.\n\t(compute_immediate_postdominators): Added definition.\n\t* rtl.h (HARD_REGISTER_P): Added definition.\n\t* ssa.c: Include additional header files.\n\t(assert): Added definition.\n\t(ssa_rename_to_lookup): Added to reimplement ssa_rename_to to\n\tinclude select hard registers.\n\t(ssa_rename_to_insert): Likewise.\n\t(ssa_rename_from_initialize): Likewise.\n\t(ssa_rename_from_lookup): Likewise.\n\t(original_register): Likewise.\n\t(ssa_rename_from_insert): Added to reimplement ssa_rename_from to\n\tinclude select hard reigsters.\n\t(ssa_rename_from_traverse): Likewise.\n\t(ssa_rename_from_free): Likewise.\n\t(ssa_rename_from_print): Likewise.\n\t(ssa_rename_from_print_1): Likewise.\n\t(ssa_rename_from_hash_function): Likewise.\n\t(ssa_rename_from_equal): Likewise.\n\t(ssa_rename_from_delete): Likewise.\n\t(simplify_to_immediate_dominators): Removed in favor of\n\tflow.c:compute_immediate_dominators.\n\t(find_evaluations_1): Modified to work with hard registers.\n\t(insert_phi_node): Likewise.\n\t(insert_phi_nodes): Likewise.\n\t(struct rename_set_data): Updated prev_reg comment.\n\t(create_delayed_rename): Modified to work with hard registers.\n\t(RENAME_NO_RTX): Updated comment.\n\t(apply_delayed_renames): Modified to work with hard registers.\n\t(rename_insn_1): Likewise and added handling of CLOBBER rtls.\n\t(rename_block): Updated to use revised ssa_rename_to interface.\n\t(rename_registers): Updated to use revised ssa_rename_to and\n\tssa_rename_from interface.\n\t(convert_to_ssa): Revised to use compute_immediate_dominators and\n\tdeal with hard registers.\n\t(make_regs_equivalent_over_bad_edges): Modified to work with hard\n\tregisters.  Added check for illegal unification of hard register.\n\t(make_equivalent_phi_alternatives_equivalent): Modified to work\n\twith hard registers.\n\t(compute_conservative_reg_partition): Likewise.\n\t(coalesce_if_unconflicting): Modified to work with hard registers\n\tand check for conflicting hard registers.\n\t(mark_phi_and_copy_regs): Revised loop to work only on pseudo\n\tregisters.\n\t(rename_equivalent_regs_in_insn): Modified to work with hard\n\tregisters.\n\t(record_canonical_element_1): Added definition.\n\t(check_hard_regs_in_partition): Added definition.\n\t(convert_from_ssa): Added data structure deallocation and check\n\tfor illegal hard register unification.\n\t(conflict_hard_regs_p): Added definition.\n\t* toplev.c (rest_of_compilation): Added comment.\n\nFrom-SVN: r35384", "tree": {"sha": "83e57a212d3697073b5085968a2756f1ce420f82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83e57a212d3697073b5085968a2756f1ce420f82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdbca1727ce8d428964efcb2f20ee82142a2c762", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdbca1727ce8d428964efcb2f20ee82142a2c762", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdbca1727ce8d428964efcb2f20ee82142a2c762", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdbca1727ce8d428964efcb2f20ee82142a2c762/comments", "author": null, "committer": null, "parents": [{"sha": "ca47b7399421f0f36255d95f50953444b6812e11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca47b7399421f0f36255d95f50953444b6812e11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca47b7399421f0f36255d95f50953444b6812e11"}], "stats": {"total": 773, "additions": 604, "deletions": 169}, "files": [{"sha": "44caceb1cd35e808fb342fa5bedec6daed2da41c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbca1727ce8d428964efcb2f20ee82142a2c762/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbca1727ce8d428964efcb2f20ee82142a2c762/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cdbca1727ce8d428964efcb2f20ee82142a2c762", "patch": "@@ -1,3 +1,62 @@\n+2000-07-30  Jeffrey D. Oldham  <oldham@codesourcery.com>\n+\n+\t* Makefile.in (ssa.o): Updated header files in dependences.\n+\t* basic-block.h: Added compute_immediate_postdominators declaration.\n+\t* config/i386/i386.h (CONVERT_HARD_REGISTER_TO_SSA_P): Added\n+\tdefinition.\n+\t* flow.c (compute_immediate_dominators): Updated comment.\n+\t(compute_immediate_postdominators): Added definition.\n+\t* rtl.h (HARD_REGISTER_P): Added definition.\n+\t* ssa.c: Include additional header files.\n+\t(assert): Added definition.\n+\t(ssa_rename_to_lookup): Added to reimplement ssa_rename_to to\n+\tinclude select hard registers.\n+\t(ssa_rename_to_insert): Likewise.\n+\t(ssa_rename_from_initialize): Likewise.\n+\t(ssa_rename_from_lookup): Likewise.\n+\t(original_register): Likewise.\n+\t(ssa_rename_from_insert): Added to reimplement ssa_rename_from to\n+\tinclude select hard reigsters.\n+\t(ssa_rename_from_traverse): Likewise.\n+\t(ssa_rename_from_free): Likewise.\n+\t(ssa_rename_from_print): Likewise.\n+\t(ssa_rename_from_print_1): Likewise.\n+\t(ssa_rename_from_hash_function): Likewise.\n+\t(ssa_rename_from_equal): Likewise.\n+\t(ssa_rename_from_delete): Likewise.\n+\t(simplify_to_immediate_dominators): Removed in favor of\n+\tflow.c:compute_immediate_dominators.\n+\t(find_evaluations_1): Modified to work with hard registers.\n+\t(insert_phi_node): Likewise.\n+\t(insert_phi_nodes): Likewise.\n+\t(struct rename_set_data): Updated prev_reg comment.\n+\t(create_delayed_rename): Modified to work with hard registers.\n+\t(RENAME_NO_RTX): Updated comment.\n+\t(apply_delayed_renames): Modified to work with hard registers.\n+\t(rename_insn_1): Likewise and added handling of CLOBBER rtls.\n+\t(rename_block): Updated to use revised ssa_rename_to interface.\n+\t(rename_registers): Updated to use revised ssa_rename_to and\n+\tssa_rename_from interface.\n+\t(convert_to_ssa): Revised to use compute_immediate_dominators and\n+\tdeal with hard registers.\n+\t(make_regs_equivalent_over_bad_edges): Modified to work with hard\n+\tregisters.  Added check for illegal unification of hard register.\n+\t(make_equivalent_phi_alternatives_equivalent): Modified to work\n+\twith hard registers.\n+\t(compute_conservative_reg_partition): Likewise.\n+\t(coalesce_if_unconflicting): Modified to work with hard registers\n+\tand check for conflicting hard registers.\n+\t(mark_phi_and_copy_regs): Revised loop to work only on pseudo\n+\tregisters.\n+\t(rename_equivalent_regs_in_insn): Modified to work with hard\n+\tregisters.\n+\t(record_canonical_element_1): Added definition.\n+\t(check_hard_regs_in_partition): Added definition.\n+\t(convert_from_ssa): Added data structure deallocation and check\n+\tfor illegal hard register unification.\n+\t(conflict_hard_regs_p): Added definition.\n+\t* toplev.c (rest_of_compilation): Added comment.\n+\n 2000-07-31  Anthony Green  <green@redhat.com>\n \n \t* config/ia64/crtbegin.asm (__EH_FRAME_BEGIN__): Align correctly."}, {"sha": "c755fd408368de20bdb79f5589b76ec2eb2db55c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbca1727ce8d428964efcb2f20ee82142a2c762/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbca1727ce8d428964efcb2f20ee82142a2c762/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=cdbca1727ce8d428964efcb2f20ee82142a2c762", "patch": "@@ -1328,8 +1328,10 @@ resource.o : resource.c $(CONFIG_H) $(RTL_H) hard-reg-set.h system.h \\\n    $(INSN_ATTR_H) except.h\n lcm.o : lcm.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n    real.h insn-config.h $(INSN_ATTR_H) $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H)\n-ssa.o : ssa.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) $(BASIC_BLOCK_H) \\\n-   output.h insn-config.h\n+ssa.o : ssa.c $(CONFIG_H) system.h $(RTL_H) varray.h sbitmap.h\t\t\\\n+   $(HASHTAB_H) $(REGS_H) hard-reg-set.h flags.h function.h real.h\t\\\n+   insn-config.h $(RECOG_H) $(BASIC_BLOCK_H)\t\t\t\t\\\n+   output.h\n conflict.o : conflict.c $(CONFIG_H) system.h $(OBSTACK_H) $(HASHTAB_H) \\\n    $(RTL_H) hard-reg-set.h $(BASIC_BLOCK_H)\n profile.o : profile.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\"}, {"sha": "2e540758b33d1cd82242b9ea62c5d0206f3d8b46", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbca1727ce8d428964efcb2f20ee82142a2c762/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbca1727ce8d428964efcb2f20ee82142a2c762/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=cdbca1727ce8d428964efcb2f20ee82142a2c762", "patch": "@@ -420,6 +420,7 @@ int find_edge_index\t\t\tPARAMS ((struct edge_list *,\n \n extern void compute_flow_dominators\tPARAMS ((sbitmap *, sbitmap *));\n extern void compute_immediate_dominators\tPARAMS ((int *, sbitmap *));\n+extern void compute_immediate_postdominators\tPARAMS ((int *, sbitmap *));\n \n \n enum update_life_extent"}, {"sha": "fe4a31ee72cfb2ac10c5fc808f072e7c7915c974", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbca1727ce8d428964efcb2f20ee82142a2c762/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbca1727ce8d428964efcb2f20ee82142a2c762/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=cdbca1727ce8d428964efcb2f20ee82142a2c762", "patch": "@@ -999,6 +999,11 @@ enum reg_class\n #define CC_REG_P(X) (REG_P (X) && CC_REGNO_P (REGNO (X)))\n #define CC_REGNO_P(X) ((X) == FLAGS_REG || (X) == FPSR_REG)\n \n+/* Indicate whether hard register numbered REG_NO should be converted\n+   to SSA form.  */\n+#define CONVERT_HARD_REGISTER_TO_SSA_P(REG_NO) \\\n+  (REG_NO == FLAGS_REG || REG_NO == ARG_POINTER_REGNUM)\n+\n /* The class value for index registers, and the one for base regs.  */\n \n #define INDEX_REG_CLASS INDEX_REGS"}, {"sha": "1bd7fbc7e3ef98a1552855340d61d8196c71a655", "filename": "gcc/flow.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbca1727ce8d428964efcb2f20ee82142a2c762/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbca1727ce8d428964efcb2f20ee82142a2c762/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=cdbca1727ce8d428964efcb2f20ee82142a2c762", "patch": "@@ -6202,7 +6202,8 @@ compute_flow_dominators (dominators, post_dominators)\n   free (temp_bitmap);\n }\n \n-/* Given DOMINATORS, compute the immediate dominators into IDOM.  */\n+/* Given DOMINATORS, compute the immediate dominators into IDOM.  If a\n+   block dominates only itself, its entry remains as INVALID_BLOCK.  */\n \n void\n compute_immediate_dominators (idom, dominators)\n@@ -6242,6 +6243,19 @@ compute_immediate_dominators (idom, dominators)\n   sbitmap_vector_free (tmp);\n }\n \n+/* Given POSTDOMINATORS, compute the immediate postdominators into\n+   IDOM.  If a block is only dominated by itself, its entry remains as\n+   INVALID_BLOCK.  */\n+\n+void\n+compute_immediate_postdominators (idom, postdominators)\n+     int *idom;\n+     sbitmap *postdominators;\n+{\n+  compute_immediate_dominators (idom, postdominators);\n+  return;\n+}\n+\n /* Recompute register set/reference counts immediately prior to register\n    allocation.\n "}, {"sha": "24102a9742aabe219cd359fe8fc1d55311fa5475", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbca1727ce8d428964efcb2f20ee82142a2c762/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbca1727ce8d428964efcb2f20ee82142a2c762/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=cdbca1727ce8d428964efcb2f20ee82142a2c762", "patch": "@@ -716,6 +716,12 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n /* 1 in a REG rtx if it corresponds to a variable declared by the user.  */\n #define REG_USERVAR_P(RTX) ((RTX)->volatil)\n \n+/* 1 if the given register REG corresponds to a hard register.  */\n+#define HARD_REGISTER_P(REG) (HARD_REGISTER_NUM_P (REGNO (REG)))\n+\n+/* 1 if the given register number REG_NO corresponds to a hard register.  */\n+#define HARD_REGISTER_NUM_P(REG_NO) (REG_NO < FIRST_PSEUDO_REGISTER)\n+\n /* For a CONST_INT rtx, INTVAL extracts the integer.  */\n \n #define INTVAL(RTX) XCWINT(RTX, 0, CONST_INT)"}, {"sha": "61ce4ced7e89d3448c136bf9ec88fd304e28e360", "filename": "gcc/ssa.c", "status": "modified", "additions": 509, "deletions": 166, "changes": 675, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbca1727ce8d428964efcb2f20ee82142a2c762/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbca1727ce8d428964efcb2f20ee82142a2c762/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=cdbca1727ce8d428964efcb2f20ee82142a2c762", "patch": "@@ -27,13 +27,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    Static Single Assignment Construction\n    Preston Briggs, Tim Harvey, Taylor Simpson\n    Technical Report, Rice University, 1995\n-   ftp://ftp.cs.rice.edu/public/preston/optimizer/SSA.ps.gz\n-*/\n+   ftp://ftp.cs.rice.edu/public/preston/optimizer/SSA.ps.gz.  */\n \n #include \"config.h\"\n #include \"system.h\"\n \n #include \"rtl.h\"\n+#include \"varray.h\"\n+#include \"partition.h\"\n+#include \"sbitmap.h\"\n+#include \"hashtab.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"flags.h\"\n@@ -43,8 +46,15 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"recog.h\"\n #include \"basic-block.h\"\n #include \"output.h\"\n-#include \"partition.h\"\n \n+/* We cannot use <assert.h> in GCC source, since that would include\n+   GCC's assert.h, which may not be compatible with the host compiler.  */\n+#undef assert\n+#ifdef NDEBUG\n+# define assert(e)\n+#else\n+# define assert(e) do { if (! (e)) abort (); } while (0)\n+#endif\n \n /* TODO: \n \n@@ -64,29 +74,112 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    the representation, calling back into optabs to finish any necessary\n    expansion.  */\n \n+/* All pseudo-registers and select hard registers are converted to SSA\n+   form.  When converting out of SSA, these select hard registers are\n+   guaranteed to be mapped to their original register number.  Each\n+   machine's .h file should define CONVERT_HARD_REGISTER_TO_SSA_P\n+   indicating which hard registers should be converted.\n+\n+   When converting out of SSA, temporaries for all registers are\n+   partitioned.  The partition is checked to ensure that all uses of\n+   the same hard register in the same machine mode are in the same\n+   class.  */\n \n /* If conservative_reg_partition is non-zero, use a conservative\n    register partitioning algorithm (which leaves more regs after\n    emerging from SSA) instead of the coalescing one.  This is being\n    left in for a limited time only, as a debugging tool until the\n    coalescing algorithm is validated.  */\n+\n+/* All pseudo-registers (having register number >=\n+   FIRST_PSEUDO_REGISTER) and hard registers satisfying\n+   CONVERT_HARD_REGISTER_TO_SSA_P are converted to SSA form.  */\n+\n+/* Given a hard register number REG_NO, return nonzero if and only if\n+   the register should be converted to SSA.  */\n+\n+#ifndef CONVERT_HARD_REGISTER_TO_SSA_P\n+#define CONVERT_HARD_REGISTER_TO_SSA_P(REG_NO) (0) /* default of no hard registers */\n+#endif /* CONVERT_HARD_REGISTER_TO_SSA_P  */\n+\n+/* Given a register number REG_NO, return nonzero if and only if the\n+   register should be converted to SSA.  */\n+\n+#define CONVERT_REGISTER_TO_SSA_P(REG_NO)\t\\\n+\t((!HARD_REGISTER_NUM_P (REG_NO)) || \\\n+\t (CONVERT_HARD_REGISTER_TO_SSA_P (REG_NO)))\n+\n static int conservative_reg_partition;\n \n /* This flag is set when the CFG is in SSA form.  */\n int in_ssa_form = 0;\n \n-/* Element I is the single instruction that sets register I+PSEUDO.  */\n+/* Element I is the single instruction that sets register I.  */\n varray_type ssa_definition;\n \n-/* Element I is an INSN_LIST of instructions that use register I+PSEUDO.  */\n+/* Element I is an INSN_LIST of instructions that use register I.  */\n varray_type ssa_uses;\n \n /* Element I-PSEUDO is the normal register that originated the ssa\n    register in question.  */\n varray_type ssa_rename_from;\n \n-/* The running target ssa register for a given normal register.  */\n-static rtx *ssa_rename_to;\n+/* Element I is the normal register that originated the ssa\n+   register in question.\n+\n+   A hash table stores the (register, rtl) pairs.  These are each\n+   xmalloc'ed and deleted when the hash table is destroyed.  */\n+htab_t ssa_rename_from_ht;\n+\n+/* The running target ssa register for a given pseudo register.\n+   (Pseudo registers appear in only one mode.)  */\n+static rtx *ssa_rename_to_pseudo;\n+/* Similar, but for hard registers.  A hard register can appear in\n+   many modes, so we store an equivalent pseudo for each of the\n+   modes.  */\n+static rtx ssa_rename_to_hard[FIRST_PSEUDO_REGISTER][NUM_MACHINE_MODES];\n+\n+/* ssa_rename_from maps pseudo registers to the original corresponding\n+   RTL.  It is implemented as using a hash table.  */\n+\n+typedef struct {\n+  unsigned int reg;\n+  rtx original;\n+} ssa_rename_from_pair;\n+\n+struct ssa_rename_from_hash_table_data {\n+  sbitmap canonical_elements;\n+  partition reg_partition;\n+};\n+\n+void ssa_rename_from_initialize\n+  PARAMS ((void));\n+rtx ssa_rename_from_lookup\n+  PARAMS ((int reg));\n+unsigned int original_register\n+  PARAMS ((unsigned int regno));\n+void ssa_rename_from_insert\n+  PARAMS ((unsigned int reg, rtx r));\n+void ssa_rename_from_free\n+  PARAMS ((void));\n+typedef int (*srf_trav) PARAMS ((int regno, rtx r, sbitmap canonical_elements, partition reg_partition));\n+static void ssa_rename_from_traverse\n+  PARAMS ((htab_trav callback_function, sbitmap canonical_elements, partition reg_partition));\n+static void ssa_rename_from_print\n+  PARAMS ((void));\n+static int ssa_rename_from_print_1\n+  PARAMS ((void **slot, void *data));\n+static hashval_t ssa_rename_from_hash_function\n+  PARAMS ((const void * srfp));\n+static int ssa_rename_from_equal\n+  PARAMS ((const void *srfp1, const void *srfp2));\n+static void ssa_rename_from_delete\n+  PARAMS ((void *srfp));\n+\n+static rtx ssa_rename_to_lookup\n+  PARAMS ((rtx reg));\n+static void ssa_rename_to_insert\n+  PARAMS ((rtx reg, rtx r));\n \n /* The number of registers that were live on entry to the SSA routines.  */\n static unsigned int ssa_max_reg_num;\n@@ -97,13 +190,10 @@ struct rename_context;\n \n static inline rtx * phi_alternative\n   PARAMS ((rtx, int));\n-\n-static rtx first_insn_after_basic_block_note PARAMS ((basic_block));\n-\n+static rtx first_insn_after_basic_block_note\n+  PARAMS ((basic_block));\n static int remove_phi_alternative\n   PARAMS ((rtx, int));\n-static void simplify_to_immediate_dominators \n-  PARAMS ((int *idom, sbitmap *dominators));\n static void compute_dominance_frontiers_1\n   PARAMS ((sbitmap *frontiers, int *idom, int bb, sbitmap done));\n static void compute_dominance_frontiers\n@@ -148,6 +238,10 @@ static int make_equivalent_phi_alternatives_equivalent\n   PARAMS ((int bb, partition reg_partition));\n static partition compute_conservative_reg_partition \n   PARAMS ((void));\n+static int record_canonical_element_1\n+  PARAMS ((void **srfp, void *data));\n+static int check_hard_regs_in_partition\n+  PARAMS ((partition reg_partition));\n static int rename_equivalent_regs_in_insn \n   PARAMS ((rtx *ptr, void *data));\n \n@@ -172,6 +266,171 @@ static int rename_equivalent_regs_in_insn\n static void rename_equivalent_regs \n   PARAMS ((partition reg_partition));\n \n+/* Deal with hard registers.  */\n+static int conflicting_hard_regs_p\n+  PARAMS ((int reg1, int reg2));\n+\n+/* ssa_rename_to maps registers and machine modes to SSA pseudo registers.  */\n+\n+/* Find the register associated with REG in the indicated mode.  */\n+\n+static rtx\n+ssa_rename_to_lookup (reg)\n+     rtx reg;\n+{\n+  if (!HARD_REGISTER_P (reg))\n+    return ssa_rename_to_pseudo[REGNO (reg) - FIRST_PSEUDO_REGISTER];\n+  else\n+    return ssa_rename_to_hard[REGNO (reg)][GET_MODE (reg)];\n+}\n+\n+/* Store a new value mapping REG to R in ssa_rename_to.  */\n+\n+static void\n+ssa_rename_to_insert(reg, r)\n+     rtx reg;\n+     rtx r;\n+{\n+  if (!HARD_REGISTER_P (reg))\n+    ssa_rename_to_pseudo[REGNO (reg) - FIRST_PSEUDO_REGISTER] = r;\n+  else\n+    ssa_rename_to_hard[REGNO (reg)][GET_MODE (reg)] = r;\n+}\n+\n+/* Prepare ssa_rename_from for use.  */\n+\n+void\n+ssa_rename_from_initialize ()\n+{\n+  /* We use an arbitrary initial hash table size of 64.  */\n+  ssa_rename_from_ht = htab_create (64,\n+\t\t\t\t    &ssa_rename_from_hash_function,\n+\t\t\t\t    &ssa_rename_from_equal,\n+\t\t\t\t    &ssa_rename_from_delete);\n+}\n+\n+/* Find the REG entry in ssa_rename_from.  Return NULL_RTX if no entry is\n+   found.  */\n+\n+rtx\n+ssa_rename_from_lookup (reg)\n+     int reg;\n+{\n+  ssa_rename_from_pair srfp;\n+  ssa_rename_from_pair *answer;\n+  srfp.reg = reg;\n+  srfp.original = NULL_RTX;\n+  answer = (ssa_rename_from_pair *)\n+    htab_find_with_hash (ssa_rename_from_ht, (void *) &srfp, reg);\n+  return (answer == 0 ? NULL_RTX : answer->original);\n+}\n+\n+/* Find the number of the original register specified by REGNO.  If\n+   the register is a pseudo, return the original register's number.\n+   Otherwise, return this register number REGNO.  */\n+\n+unsigned int\n+original_register (regno)\n+     unsigned int regno;\n+{\n+  rtx original_rtx = ssa_rename_from_lookup (regno);\n+  return original_rtx != NULL_RTX ? REGNO (original_rtx) : regno;\n+}\n+\n+/* Add mapping from R to REG to ssa_rename_from even if already present.  */\n+\n+void\n+ssa_rename_from_insert (reg, r)\n+     unsigned int reg;\n+     rtx r;\n+{\n+  void **slot;\n+  ssa_rename_from_pair *srfp = xmalloc (sizeof (ssa_rename_from_pair));\n+  srfp->reg = reg;\n+  srfp->original = r;\n+  slot = htab_find_slot_with_hash (ssa_rename_from_ht, (const void *) srfp,\n+\t\t\t\t   reg, INSERT);\n+  if (*slot != 0)\n+    free ((void *) *slot);\n+  *slot = srfp;\n+}\n+\n+/* Apply the CALLBACK_FUNCTION to each element in ssa_rename_from.\n+   CANONICAL_ELEMENTS and REG_PARTITION pass data needed by the only\n+   current use of this function.  */\n+\n+void\n+ssa_rename_from_traverse (callback_function,\n+\t\t\t  canonical_elements, reg_partition)\n+     htab_trav callback_function;\n+     sbitmap canonical_elements;\n+     partition reg_partition;\n+{\n+  struct ssa_rename_from_hash_table_data srfhd;\n+  srfhd.canonical_elements = canonical_elements;\n+  srfhd.reg_partition = reg_partition;\n+  htab_traverse (ssa_rename_from_ht, callback_function, (void *) &srfhd);\n+}\n+\n+/* Destroy ssa_rename_from.  */\n+\n+void\n+ssa_rename_from_free ()\n+{\n+  htab_delete (ssa_rename_from_ht);\n+}\n+\n+/* Print the contents of ssa_rename_from.  */\n+\n+static void\n+ssa_rename_from_print ()\n+{\n+  printf (\"ssa_rename_from's hash table contents:\\n\");\n+  htab_traverse (ssa_rename_from_ht, &ssa_rename_from_print_1, NULL);\n+}\n+\n+/* Print the contents of the hash table entry SLOT, passing the unused\n+   sttribute DATA.  Used as a callback function with htab_traverse ().  */\n+\n+static int\n+ssa_rename_from_print_1 (slot, data)\n+     void **slot;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  ssa_rename_from_pair * p = *slot;\n+  printf (\"ssa_rename_from maps pseudo %i to original %i.\\n\",\n+\t  p->reg, REGNO (p->original));\n+  return 1;\n+}\n+\n+/* Given a hash entry SRFP, yield a hash value.  */\n+\n+static hashval_t\n+ssa_rename_from_hash_function (srfp)\n+     const void *srfp;\n+{\n+  return ((ssa_rename_from_pair *) srfp)->reg;\n+}\n+\n+/* Test whether two hash table entries SRFP1 and SRFP2 are equal.  */\n+\n+static int\n+ssa_rename_from_equal (srfp1, srfp2)\n+     const void *srfp1;\n+     const void *srfp2;\n+{\n+  return ssa_rename_from_hash_function (srfp1) ==\n+    ssa_rename_from_hash_function (srfp2);\n+}\n+\n+/* Delete the hash table entry SRFP.  */\n+\n+static void\n+ssa_rename_from_delete (srfp)\n+     void *srfp;\n+{\n+  free (srfp);\n+}\n \n /* Given the SET of a PHI node, return the address of the alternative\n    for predecessor block C.  */\n@@ -219,51 +478,6 @@ remove_phi_alternative (set, c)\n   return 0;\n }\n \n-/* Computing the Immediate Dominators:\n-\n-   Throughout, we don't actually want the full dominators set as\n-   calculated by flow, but rather the immediate dominators.\n-*/\n-\n-static void\n-simplify_to_immediate_dominators (idom, dominators)\n-     int *idom;\n-     sbitmap *dominators;\n-{\n-  sbitmap *tmp;\n-  int b;\n-\n-  tmp = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n-\n-  /* Begin with tmp(n) = dom(n) - { n }.  */\n-  for (b = n_basic_blocks; --b >= 0; )\n-    {\n-      sbitmap_copy (tmp[b], dominators[b]);\n-      RESET_BIT (tmp[b], b);\n-    }\n-\n-  /* Subtract out all of our dominator's dominators.  */\n-  for (b = n_basic_blocks; --b >= 0; )\n-    {\n-      sbitmap tmp_b = tmp[b];\n-      int s;\n-\n-      for (s = n_basic_blocks; --s >= 0; )\n-\tif (TEST_BIT (tmp_b, s))\n-\t  sbitmap_difference (tmp_b, tmp_b, tmp[s]);\n-    }\n-\n-  /* Find the one bit set in the bitmap and put it in the output array.  */\n-  for (b = n_basic_blocks; --b >= 0; )\n-    {\n-      int t;\n-      EXECUTE_IF_SET_IN_SBITMAP (tmp[b], 0, t, { idom[b] = t; });\n-    }\n-\n-  sbitmap_vector_free (tmp);\n-}\n-\n-\n /* For all registers, find all blocks in which they are set.\n \n    This is the transform of what would be local kill information that\n@@ -279,8 +493,8 @@ find_evaluations_1 (dest, set, data)\n      void *data ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (dest) == REG\n-      && REGNO (dest) >= FIRST_PSEUDO_REGISTER)\n-    SET_BIT (fe_evals[REGNO (dest) - FIRST_PSEUDO_REGISTER], fe_current_bb);\n+      && CONVERT_REGISTER_TO_SSA_P (REGNO (dest)))\n+    SET_BIT (fe_evals[REGNO (dest)], fe_current_bb);\n }\n \n static void\n@@ -312,7 +526,6 @@ find_evaluations (evals, nregs)\n     }\n }\n \n-\n /* Computing the Dominance Frontier:\n   \n    As decribed in Morgan, section 3.5, this may be done simply by \n@@ -386,7 +599,6 @@ compute_dominance_frontiers (frontiers, idom)\n   sbitmap_free (done);\n }\n \n-\n /* Computing the Iterated Dominance Frontier:\n \n    This is the set of merge points for a given register.\n@@ -473,7 +685,6 @@ first_insn_after_basic_block_note (block)\n   return NEXT_INSN (insn);\n }\n \n-\n /* Insert the phi nodes.  */\n \n static void\n@@ -498,8 +709,8 @@ insert_phi_node (regno, bb)\n   if (npred == 0)\n     return;\n \n-  /* This is the register to which the phi function will be assinged.  */\n-  reg = regno_reg_rtx[regno + FIRST_PSEUDO_REGISTER];\n+  /* This is the register to which the phi function will be assigned.  */\n+  reg = regno_reg_rtx[regno];\n \n   /* Construct the arguments to the PHI node.  The use of pc_rtx is just\n      a placeholder; we'll insert the proper value in rename_registers.  */\n@@ -521,7 +732,6 @@ insert_phi_node (regno, bb)\n     b->end = PREV_INSN (insn);\n }\n \n-\n static void\n insert_phi_nodes (idfs, evals, nregs)\n      sbitmap *idfs;\n@@ -531,12 +741,12 @@ insert_phi_nodes (idfs, evals, nregs)\n   int reg;\n \n   for (reg = 0; reg < nregs; ++reg)\n+    if (CONVERT_REGISTER_TO_SSA_P (reg))\n     {\n       int b;\n       EXECUTE_IF_SET_IN_SBITMAP (idfs[reg], 0, b,\n \t{\n-\t  if (REGNO_REG_SET_P (BASIC_BLOCK (b)->global_live_at_start, \n-\t\t\t       reg + FIRST_PSEUDO_REGISTER))\n+\t  if (REGNO_REG_SET_P (BASIC_BLOCK (b)->global_live_at_start, reg))\n \t    insert_phi_node (reg, b);\n \t});\n     }\n@@ -548,7 +758,6 @@ insert_phi_nodes (idfs, evals, nregs)\n    with a few changes to reduce pattern search time in favour of a bit\n    more memory usage.  */\n \n-\n /* One of these is created for each set.  It will live in a list local\n    to its basic block for the duration of that block's processing.  */\n struct rename_set_data\n@@ -561,8 +770,8 @@ struct rename_set_data\n   /* This is the REG that will replace OLD_REG.  It's set only\n      when the rename data is moved onto the DONE_RENAMES queue.  */\n   rtx new_reg;\n-  /* This is what to restore ssa_rename_to[REGNO (old_reg)] to. \n-     It is usually the previous contents of ssa_rename_to[REGNO (old_reg)].  */\n+  /* This is what to restore ssa_rename_to_lookup (old_reg) to.  It is\n+     usually the previous contents of ssa_rename_to_lookup (old_reg).  */\n   rtx prev_reg;\n   /* This is the insn that contains all the SETs of the REG.  */\n   rtx set_insn;\n@@ -587,20 +796,20 @@ create_delayed_rename (c, reg_loc)\n   r = (struct rename_set_data *) xmalloc (sizeof(*r));\n   \n   if (GET_CODE (*reg_loc) != REG\n-      || REGNO (*reg_loc) < FIRST_PSEUDO_REGISTER)\n+      || !CONVERT_REGISTER_TO_SSA_P (REGNO (*reg_loc)))\n     abort();\n \n   r->reg_loc = reg_loc;\n   r->old_reg = *reg_loc;\n-  r->prev_reg = ssa_rename_to [REGNO (r->old_reg) - FIRST_PSEUDO_REGISTER];\n+  r->prev_reg = ssa_rename_to_lookup(r->old_reg);\n   r->set_insn = c->current_insn;\n   r->next = c->new_renames;\n   c->new_renames = r;\n }\n \n /* This is part of a rather ugly hack to allow the pre-ssa regno to be\n    reused.  If, during processing, a register has not yet been touched,\n-   ssa_rename_to[regno] will be NULL.  Now, in the course of pushing\n+   ssa_rename_to[regno][machno] will be NULL.  Now, in the course of pushing\n    and popping values from ssa_rename_to, when we would ordinarily \n    pop NULL back in, we pop RENAME_NO_RTX.  We treat this exactly the\n    same as NULL, except that it signals that the original regno has\n@@ -616,20 +825,19 @@ apply_delayed_renames (c)\n {\n   struct rename_set_data *r;\n   struct rename_set_data *last_r = NULL;\n-  \n+\n   for (r = c->new_renames; r != NULL; r = r->next)\n     {\n-      int regno = REGNO (r->old_reg);\n       int new_regno;\n       \n       /* Failure here means that someone has a PARALLEL that sets\n \t a register twice (bad!).  */\n-      if (ssa_rename_to [regno - FIRST_PSEUDO_REGISTER] != r->prev_reg)\n+      if (ssa_rename_to_lookup (r->old_reg) != r->prev_reg)\n \tabort();\n       /* Failure here means we have changed REG_LOC before applying\n \t the rename.  */\n       /* For the first set we come across, reuse the original regno.  */\n-      if (r->prev_reg == NULL_RTX)\n+      if (r->prev_reg == NULL_RTX && !HARD_REGISTER_P (r->old_reg))\n \t{\n \t  r->new_reg = r->old_reg;\n \t  /* We want to restore RENAME_NO_RTX rather than NULL_RTX. */\n@@ -638,19 +846,17 @@ apply_delayed_renames (c)\n       else\n \tr->new_reg = gen_reg_rtx (GET_MODE (r->old_reg));\n       new_regno = REGNO (r->new_reg);\n-      ssa_rename_to[regno - FIRST_PSEUDO_REGISTER] = r->new_reg;\n+      ssa_rename_to_insert (r->old_reg, r->new_reg);\n \n       if (new_regno >= (int) ssa_definition->num_elements)\n \t{\n \t  int new_limit = new_regno * 5 / 4;\n \t  ssa_definition = VARRAY_GROW (ssa_definition, new_limit);\n \t  ssa_uses = VARRAY_GROW (ssa_uses, new_limit);\n-\t  ssa_rename_from = VARRAY_GROW (ssa_rename_from, new_limit);\n \t}\n \n       VARRAY_RTX (ssa_definition, new_regno) = r->set_insn;\n-      VARRAY_RTX (ssa_rename_from, new_regno) = r->old_reg;\n-\n+      ssa_rename_from_insert (new_regno, r->old_reg);\n       last_r = r;\n     }\n   if (last_r != NULL)\n@@ -711,7 +917,7 @@ rename_insn_1 (ptr, data)\n \t\treg = XEXP (reg, 0);\n \t    \n \t    if (GET_CODE (reg) == REG\n-\t\t&& REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n+\t\t&& CONVERT_REGISTER_TO_SSA_P (REGNO (reg)))\n \t      {\n \t\t/* Generate (set reg reg), and do renaming on it so\n \t\t   that it becomes (set reg_1 reg_0), and we will\n@@ -726,8 +932,8 @@ rename_insn_1 (ptr, data)\n \t\tcontext->new_renames = saved_new_renames;\n \t      }\n \t  }\n-\telse if (GET_CODE (dest) == REG\n-\t\t && REGNO (dest) >= FIRST_PSEUDO_REGISTER)\n+\telse if (GET_CODE (dest) == REG &&\n+\t\t CONVERT_REGISTER_TO_SSA_P (REGNO (dest)))\n \t  {\n \t    /* We found a genuine set of an interesting register.  Tag\n \t       it so that we can create a new name for it after we finish\n@@ -749,10 +955,10 @@ rename_insn_1 (ptr, data)\n       }\n \n     case REG:\n-      if (REGNO (x) >= FIRST_PSEUDO_REGISTER\n-\t  && REGNO (x) < ssa_max_reg_num)\n+      if (CONVERT_REGISTER_TO_SSA_P (REGNO (x)) &&\n+\t  REGNO (x) < ssa_max_reg_num)\n \t{\n-\t  rtx new_reg = ssa_rename_to[REGNO(x) - FIRST_PSEUDO_REGISTER];\n+\t  rtx new_reg = ssa_rename_to_lookup (x);\n \n \t  if (new_reg != NULL_RTX && new_reg != RENAME_NO_RTX)\n \t    {\n@@ -764,6 +970,31 @@ rename_insn_1 (ptr, data)\n \t}\n       return -1;\n \n+    case CLOBBER:\n+      /* There is considerable debate on how CLOBBERs ought to be\n+\t handled in SSA.  For now, we're keeping the CLOBBERs, which\n+\t means that we don't really have SSA form.  There are a couple\n+\t of proposals for how to fix this problem, but neither is\n+\t implemented yet.  */\n+      {\n+\trtx dest = XCEXP (x, 0, CLOBBER);\n+\tif (REG_P (dest))\n+\t  {\n+\t    if (CONVERT_REGISTER_TO_SSA_P (REGNO (dest))\n+\t\t&& REGNO (dest) < ssa_max_reg_num)\n+\t      {\n+\t\trtx new_reg = ssa_rename_to_lookup (dest);\n+\t\tif (new_reg != NULL_RTX && new_reg != RENAME_NO_RTX)\n+\t\t    XCEXP (x, 0, CLOBBER) = new_reg;\n+\t      }\n+\t    /* Stop traversing.  */\n+\t    return -1;\n+\t  }\t    \n+\telse\n+\t  /* Continue traversing.  */\n+\t  return 0;\n+      }\n+\n     case PHI:\n       /* Never muck with the phi.  We do that elsewhere, special-like.  */\n       return -1;\n@@ -843,19 +1074,19 @@ rename_block (bb, idom)\n       while (PHI_NODE_P (insn))\n \t{\n \t  rtx phi = PATTERN (insn);\n-\t  unsigned int regno;\n \t  rtx reg;\n \n \t  /* Find out which of our outgoing registers this node is\n-\t     indended to replace.  Note that if this not the first PHI\n+\t     intended to replace.  Note that if this is not the first PHI\n \t     node to have been created for this register, we have to\n \t     jump through rename links to figure out which register\n \t     we're talking about.  This can easily be recognized by\n \t     noting that the regno is new to this pass.  */\n-\t  regno = REGNO (SET_DEST (phi));\n-\t  if (regno >= ssa_max_reg_num)\n-\t    regno = REGNO (VARRAY_RTX (ssa_rename_from, regno));\n-\t  reg = ssa_rename_to[regno - FIRST_PSEUDO_REGISTER];\n+\t  reg = SET_DEST (phi);\n+\t  if (REGNO (reg) >= ssa_max_reg_num)\n+\t    reg = ssa_rename_from_lookup (REGNO (reg));\n+\t  assert (reg != NULL_RTX);\n+\t  reg = ssa_rename_to_lookup (reg);\n \n \t  /* It is possible for the variable to be uninitialized on\n \t     edges in.  Reduce the arity of the PHI so that we don't\n@@ -902,8 +1133,7 @@ rename_block (bb, idom)\n \tabort();\n       *set_data->reg_loc = set_data->new_reg;\n \n-      ssa_rename_to[REGNO (old_reg)-FIRST_PSEUDO_REGISTER]\n-\t= set_data->prev_reg;\n+      ssa_rename_to_insert (old_reg, set_data->prev_reg);\n \n       next = set_data->next;\n       free (set_data);\n@@ -916,26 +1146,30 @@ rename_registers (nregs, idom)\n      int nregs;\n      int *idom;\n {\n+  int reg;\n+  int mach_mode;\n+\n   VARRAY_RTX_INIT (ssa_definition, nregs * 3, \"ssa_definition\");\n   VARRAY_RTX_INIT (ssa_uses, nregs * 3, \"ssa_uses\");\n-  VARRAY_RTX_INIT (ssa_rename_from, nregs * 3, \"ssa_rename_from\");\n+  ssa_rename_from_initialize ();\n \n-  ssa_rename_to = (rtx *) alloca (nregs * sizeof(rtx));\n-  bzero ((char *) ssa_rename_to, nregs * sizeof(rtx));\n+  ssa_rename_to_pseudo = (rtx *) alloca (nregs * sizeof(rtx));\n+  bzero ((char *) ssa_rename_to_pseudo, nregs * sizeof(rtx));\n+  bzero ((char *) ssa_rename_to_hard, \n+\t FIRST_PSEUDO_REGISTER * NUM_MACHINE_MODES * sizeof (rtx));\n \n   rename_block (0, idom);\n \n   /* ??? Update basic_block_live_at_start, and other flow info \n      as needed.  */\n \n-  ssa_rename_to = NULL;\n+  ssa_rename_to_pseudo = NULL;\n }\n \n-\n /* The main entry point for moving to SSA.  */\n \n void\n-convert_to_ssa()\n+convert_to_ssa ()\n {\n   /* Element I is the set of blocks that set register I.  */\n   sbitmap *evals;\n@@ -963,7 +1197,7 @@ convert_to_ssa()\n \n   idom = (int *) alloca (n_basic_blocks * sizeof (int));\n   memset ((void *)idom, -1, (size_t)n_basic_blocks * sizeof (int));\n-  simplify_to_immediate_dominators (idom, dominators);\n+  compute_immediate_dominators (idom, dominators);\n \n   sbitmap_vector_free (dominators);\n \n@@ -991,7 +1225,7 @@ convert_to_ssa()\n   /* Compute register evaluations.  */\n \n   ssa_max_reg_num = max_reg_num();\n-  nregs = ssa_max_reg_num - FIRST_PSEUDO_REGISTER;\n+  nregs = ssa_max_reg_num;\n   evals = sbitmap_vector_alloc (nregs, n_basic_blocks);\n   find_evaluations (evals, nregs);\n \n@@ -1003,7 +1237,7 @@ convert_to_ssa()\n   if (rtl_dump_file)\n     {\n       dump_sbitmap_vector (rtl_dump_file, \";; Iterated Dominance Frontiers:\",\n-\t\t\t   \"; Register-FIRST_PSEUDO_REGISTER\", idfs, nregs);\n+\t\t\t   \"; Register\", idfs, nregs);\n       fflush (rtl_dump_file);\n     }\n \n@@ -1025,7 +1259,6 @@ convert_to_ssa()\n   reg_scan (get_insns (), max_reg_num (), 1);\n }\n \n-\n /* REG is the representative temporary of its partition.  Add it to the\n    set of nodes to be processed, if it hasn't been already.  Return the\n    index of this register in the node set.  */\n@@ -1269,7 +1502,6 @@ eliminate_phi (e, reg_partition)\n   sbitmap_vector_free (succ);\n }\n \n-\n /* For basic block B, consider all phi insns which provide an\n    alternative corresponding to an incoming abnormal critical edge.\n    Place the phi alternative corresponding to that abnormal critical\n@@ -1307,9 +1539,9 @@ make_regs_equivalent_over_bad_edges (bb, reg_partition)\n       rtx set = PATTERN (phi);\n       rtx tgt = SET_DEST (set);\n \n-      /* The set target is expected to be a pseudo.  */\n+      /* The set target is expected to be an SSA register.  */\n       if (GET_CODE (tgt) != REG \n-\t  || REGNO (tgt) < FIRST_PSEUDO_REGISTER)\n+\t  || !CONVERT_REGISTER_TO_SSA_P (REGNO (tgt)))\n \tabort ();\n       tgt_regno = REGNO (tgt);\n \n@@ -1326,9 +1558,9 @@ make_regs_equivalent_over_bad_edges (bb, reg_partition)\n \t    if (alt == 0)\n \t      continue;\n \n-\t    /* The phi alternative is expected to be a pseudo.  */\n+\t    /* The phi alternative is expected to be an SSA register.  */\n \t    if (GET_CODE (*alt) != REG \n-\t\t|| REGNO (*alt) < FIRST_PSEUDO_REGISTER)\n+\t\t|| !CONVERT_REGISTER_TO_SSA_P (REGNO (*alt)))\n \t      abort ();\n \t    alt_regno = REGNO (*alt);\n \n@@ -1338,6 +1570,11 @@ make_regs_equivalent_over_bad_edges (bb, reg_partition)\n \t\t!= partition_find (reg_partition, alt_regno))\n \t      {\n \t\t/* ... make them such.  */\n+\t\tif (conflicting_hard_regs_p (tgt_regno, alt_regno))\n+\t\t  /* It is illegal to unify a hard register with a\n+\t\t     different register.  */\n+\t\t  abort ();\n+\t\t\n \t\tpartition_union (reg_partition, \n \t\t\t\t tgt_regno, alt_regno);\n \t\t++changed;\n@@ -1348,7 +1585,6 @@ make_regs_equivalent_over_bad_edges (bb, reg_partition)\n   return changed;\n }\n \n-\n /* Consider phi insns in basic block BB pairwise.  If the set target\n    of both isns are equivalent pseudos, make the corresponding phi\n    alternatives in each phi corresponding equivalent.\n@@ -1396,7 +1632,7 @@ make_equivalent_phi_alternatives_equivalent (bb, reg_partition)\n \t      for (e = b->pred; e; e = e->pred_next)\n \t\t{\n \t\t  int pred_block = e->src->index;\n-\t\t  /* Identify the phi altnernatives from both phi\n+\t\t  /* Identify the phi alternatives from both phi\n \t\t     nodes corresponding to this edge.  */\n \t\t  rtx *alt = phi_alternative (set, pred_block);\n \t\t  rtx *alt2 = phi_alternative (set2, pred_block);\n@@ -1406,20 +1642,25 @@ make_equivalent_phi_alternatives_equivalent (bb, reg_partition)\n \t\t  if (alt == 0 || alt2 == 0)\n \t\t    continue;\n \n-\t\t  /* Both alternatives should be pseudos.  */\n+\t\t  /* Both alternatives should be SSA registers.  */\n \t\t  if (GET_CODE (*alt) != REG\n-\t\t      || REGNO (*alt) < FIRST_PSEUDO_REGISTER)\n+\t\t      || !CONVERT_REGISTER_TO_SSA_P (REGNO (*alt)))\n \t\t    abort ();\n \t\t  if (GET_CODE (*alt2) != REG\n-\t\t      || REGNO (*alt2) < FIRST_PSEUDO_REGISTER)\n+\t\t      || !CONVERT_REGISTER_TO_SSA_P (REGNO (*alt2)))\n \t\t    abort ();\n \n-\t\t  /* If the altneratives aren't already in the same\n+\t\t  /* If the alternatives aren't already in the same\n \t\t     class ... */\n \t\t  if (partition_find (reg_partition, REGNO (*alt)) \n \t\t      != partition_find (reg_partition, REGNO (*alt2)))\n \t\t    {\n \t\t      /* ... make them so.  */\n+\t\t      if (conflicting_hard_regs_p (REGNO (*alt), REGNO (*alt2)))\n+\t\t\t/* It is illegal to unify a hard register with\n+\t\t\t   a different register. */\n+\t\t\tabort ();\n+\n \t\t      partition_union (reg_partition, \n \t\t\t\t       REGNO (*alt), REGNO (*alt2));\n \t\t      ++changed;\n@@ -1445,7 +1686,7 @@ compute_conservative_reg_partition ()\n      carry them around anyway rather than constantly doing register\n      number arithmetic.  */\n   partition p = \n-    partition_new (ssa_definition->num_elements + FIRST_PSEUDO_REGISTER);\n+    partition_new (ssa_definition->num_elements);\n \n   /* The first priority is to make sure registers that might have to\n      be copied on abnormal critical edges are placed in the same\n@@ -1506,8 +1747,8 @@ coalesce_if_unconflicting (p, conflicts, reg1, reg2)\n {\n   int reg;\n \n-  /* Don't mess with hard regs.  */\n-  if (reg1 < FIRST_PSEUDO_REGISTER || reg2 < FIRST_PSEUDO_REGISTER)\n+  /* Work only on SSA registers. */\n+  if (!CONVERT_REGISTER_TO_SSA_P (reg1) || !CONVERT_REGISTER_TO_SSA_P (reg2))\n     return 0;\n \n   /* Find the canonical regs for the classes containing REG1 and\n@@ -1520,7 +1761,8 @@ coalesce_if_unconflicting (p, conflicts, reg1, reg2)\n     return 0;\n \n   /* If the regs conflict, our hands are tied.  */\n-  if (conflict_graph_conflict_p (conflicts, reg1, reg2))\n+  if (conflicting_hard_regs_p (reg1, reg2) ||\n+      conflict_graph_conflict_p (conflicts, reg1, reg2))\n     return 0;\n \n   /* We're good to go.  Put the regs in the same partition.  */\n@@ -1594,7 +1836,6 @@ coalesce_regs_in_copies (bb, p, conflicts)\n   return changed;\n }\n \n-\n struct phi_coalesce_context\n {\n   partition p;\n@@ -1660,11 +1901,8 @@ compute_coalesced_reg_partition ()\n   int bb;\n   int changed = 0;\n \n-  /* We don't actually work with hard registers, but it's easier to\n-     carry them around anyway rather than constantly doing register\n-     number arithmetic.  */\n   partition p = \n-    partition_new (ssa_definition->num_elements + FIRST_PSEUDO_REGISTER);\n+    partition_new (ssa_definition->num_elements);\n \n   /* The first priority is to make sure registers that might have to\n      be copied on abnormal critical edges are placed in the same\n@@ -1741,41 +1979,40 @@ static void\n mark_phi_and_copy_regs (phi_set)\n      regset phi_set;\n {\n-  int reg;\n+  unsigned int reg;\n \n   /* Scan the definitions of all regs.  */\n-  for (reg = VARRAY_SIZE (ssa_definition); \n-       --reg >= FIRST_PSEUDO_REGISTER; \n-       ) \n-    {\n-      rtx insn = VARRAY_RTX (ssa_definition, reg);\n-      rtx pattern;\n-      rtx src;\n-\n-      if (insn == NULL)\n-\tcontinue;\n-      pattern = PATTERN (insn);\n-      /* Sometimes we get PARALLEL insns.  These aren't phi nodes or\n-\t copies.  */\n-      if (GET_CODE (pattern) != SET)\n-\tcontinue;\n-      src = SET_SRC (pattern);\n-\n-      if (GET_CODE (src) == REG)\n-\t{\n-\t  /* It's a reg copy.  */\n-\t  SET_REGNO_REG_SET (phi_set, reg);\n-\t  SET_REGNO_REG_SET (phi_set, REGNO (src));\n-\t}\n-      else if (GET_CODE (src) == PHI)\n-\t{\n-\t  /* It's a phi node.  Mark the reg being set.  */\n-\t  SET_REGNO_REG_SET (phi_set, reg);\n-\t  /* Mark the regs used in the phi function.  */\n-\t  for_each_rtx (&src, mark_reg_in_phi, phi_set);\n-\t}\n-      /* ... else nothing to do.  */\n-    }\n+  for (reg = 0; reg < VARRAY_SIZE (ssa_definition); ++reg)\n+    if (CONVERT_REGISTER_TO_SSA_P (reg))\n+      {\n+\trtx insn = VARRAY_RTX (ssa_definition, reg);\n+\trtx pattern;\n+\trtx src;\n+\n+\tif (insn == NULL)\n+\t  continue;\n+\tpattern = PATTERN (insn);\n+\t/* Sometimes we get PARALLEL insns.  These aren't phi nodes or\n+\t   copies.  */\n+\tif (GET_CODE (pattern) != SET)\n+\t  continue;\n+\tsrc = SET_SRC (pattern);\n+\n+\tif (GET_CODE (src) == REG)\n+\t  {\n+\t    /* It's a reg copy.  */\n+\t    SET_REGNO_REG_SET (phi_set, reg);\n+\t    SET_REGNO_REG_SET (phi_set, REGNO (src));\n+\t  }\n+\telse if (GET_CODE (src) == PHI)\n+\t  {\n+\t    /* It's a phi node.  Mark the reg being set.  */\n+\t    SET_REGNO_REG_SET (phi_set, reg);\n+\t    /* Mark the regs used in the phi function.  */\n+\t    for_each_rtx (&src, mark_reg_in_phi, phi_set);\n+\t  }\n+\t/* ... else nothing to do.  */\n+      }\n }\n \n /* Rename regs in insn PTR that are equivalent.  DATA is the register\n@@ -1795,11 +2032,19 @@ rename_equivalent_regs_in_insn (ptr, data)\n   switch (GET_CODE (x))\n     {\n     case REG:\n-      if (REGNO (x) >= FIRST_PSEUDO_REGISTER)\n+      if (CONVERT_REGISTER_TO_SSA_P (REGNO (x)))\n \t{\n-\t  int regno = REGNO (x);\n-\t  int new_regno = partition_find (reg_partition, regno);\n-\t  if (regno != new_regno)\n+\t  unsigned int regno = REGNO (x);\n+\t  unsigned int new_regno = partition_find (reg_partition, regno);\n+\t  rtx canonical_element_rtx = ssa_rename_from_lookup (new_regno);\n+\n+\t  if (canonical_element_rtx != NULL_RTX && \n+\t      HARD_REGISTER_P (canonical_element_rtx))\n+\t    {\n+\t      if (REGNO (canonical_element_rtx) != regno)\n+\t\t*ptr = canonical_element_rtx;\n+\t    }\n+\t  else if (regno != new_regno)\n \t    {\n \t      rtx new_reg = regno_reg_rtx[new_regno];\n \t      if (GET_MODE (x) != GET_MODE (new_reg))\n@@ -1820,8 +2065,73 @@ rename_equivalent_regs_in_insn (ptr, data)\n     }\n }\n \n-/* Rename regs that are equivalent in REG_PARTITION.  \n-   Also collapse any SEQUENCE insns.  */\n+/* Record the register's canonical element stored in SRFP in the\n+   canonical_elements sbitmap packaged in DATA.  This function is used\n+   as a callback function for traversing ssa_rename_from.  */\n+\n+static int\n+record_canonical_element_1 (srfp, data)\n+     void **srfp;\n+     void *data;\n+{\n+  unsigned int reg = ((ssa_rename_from_pair *) *srfp)->reg;\n+  sbitmap canonical_elements =\n+    ((struct ssa_rename_from_hash_table_data *) data)->canonical_elements;\n+  partition reg_partition =\n+    ((struct ssa_rename_from_hash_table_data *) data)->reg_partition;\n+  \n+  SET_BIT (canonical_elements, partition_find (reg_partition, reg));\n+  return 1;\n+}\n+\n+/* For each class in the REG_PARTITION corresponding to a particular\n+   hard register and machine mode, check that there are no other\n+   classes with the same hard register and machine mode.  Returns\n+   nonzero if this is the case, i.e., the partition is acceptable.  */\n+\n+static int\n+check_hard_regs_in_partition (reg_partition)\n+     partition reg_partition;\n+{\n+  /* CANONICAL_ELEMENTS has a nonzero bit if a class with the given register\n+     number and machine mode has already been seen.  This is a\n+     problem with the partition.  */\n+  sbitmap canonical_elements;\n+  int element_index;\n+  int already_seen[FIRST_PSEUDO_REGISTER][NUM_MACHINE_MODES];\n+  int reg;\n+  int mach_mode;\n+\n+  /* Collect a list of canonical elements.  */\n+  canonical_elements = sbitmap_alloc (max_reg_num ());\n+  sbitmap_zero (canonical_elements);\n+  ssa_rename_from_traverse (&record_canonical_element_1,\n+\t\t\t    canonical_elements, reg_partition);\n+\n+  /* We have not seen any hard register uses.  */\n+  for (reg = 0; reg < FIRST_PSEUDO_REGISTER; ++reg)\n+    for (mach_mode = 0; mach_mode < NUM_MACHINE_MODES; ++mach_mode)\n+      already_seen[reg][mach_mode] = 0;\n+\n+  /* Check for classes with the same hard register and machine mode.  */\n+  EXECUTE_IF_SET_IN_SBITMAP (canonical_elements, 0, element_index,\n+  {\n+    rtx hard_reg_rtx = ssa_rename_from_lookup (element_index);\n+    if (hard_reg_rtx != NULL_RTX &&\n+\tHARD_REGISTER_P (hard_reg_rtx) &&\n+\talready_seen[REGNO (hard_reg_rtx)][GET_MODE (hard_reg_rtx)] != 0)\n+\t  /* Two distinct partition classes should be mapped to the same\n+\t     hard register.  */\n+\t  return 0;\n+  });\n+\n+  sbitmap_free (canonical_elements);\n+\n+  return 1;\n+}\n+\n+/* Rename regs that are equivalent in REG_PARTITION.  Also collapse\n+   any SEQUENCE insns.  */\n \n static void\n rename_equivalent_regs (reg_partition)\n@@ -1877,10 +2187,10 @@ convert_from_ssa()\n   int bb;\n   partition reg_partition;\n   rtx insns = get_insns ();\n-    \n+\n   /* Need global_live_at_{start,end} up to date.  */\n   life_analysis (insns, NULL, \n-\t  PROP_KILL_DEAD_CODE | PROP_SCAN_DEAD_CODE | PROP_DEATH_NOTES);\n+\t\t PROP_KILL_DEAD_CODE | PROP_SCAN_DEAD_CODE | PROP_DEATH_NOTES);\n \n   /* Figure out which regs in copies and phi nodes don't conflict and\n      therefore can be coalesced.  */\n@@ -1889,6 +2199,11 @@ convert_from_ssa()\n   else\n     reg_partition = compute_coalesced_reg_partition ();\n \n+  if (!check_hard_regs_in_partition (reg_partition))\n+    /* Two separate partitions should correspond to the same hard\n+       register but do not.  */\n+    abort ();\n+\n   rename_equivalent_regs (reg_partition);\n \n   /* Eliminate the PHI nodes.  */\n@@ -1937,6 +2252,11 @@ convert_from_ssa()\n   in_ssa_form = 0;\n \n   count_or_remove_death_notes (NULL, 1);\n+\n+  /* Deallocate the data structures.  */\n+  VARRAY_FREE (ssa_definition);\n+  VARRAY_FREE (ssa_uses);\n+  ssa_rename_from_free ();\n }\n \n /* Scan phi nodes in successors to BB.  For each such phi node that\n@@ -2002,3 +2322,26 @@ for_each_successor_phi (bb, fn, data)\n \n   return 0;\n }\n+\n+/* Assuming the ssa_rename_from mapping has been established, yields\n+   nonzero if 1) only one SSA register of REG1 and REG2 comes from a\n+   hard register or 2) both SSA registers REG1 and REG2 come from\n+   different hard registers.  */\n+\n+static int\n+conflicting_hard_regs_p (reg1, reg2)\n+     int reg1;\n+     int reg2;\n+{\n+  int orig_reg1 = original_register (reg1);\n+  int orig_reg2 = original_register (reg2);\n+  if (HARD_REGISTER_NUM_P (orig_reg1) && HARD_REGISTER_NUM_P (orig_reg2)\n+      && orig_reg1 != orig_reg2)\n+    return 1;\n+  if (HARD_REGISTER_NUM_P (orig_reg1) && !HARD_REGISTER_NUM_P (orig_reg2))\n+    return 1;\n+  if (!HARD_REGISTER_NUM_P (orig_reg1) && HARD_REGISTER_NUM_P (orig_reg2))\n+    return 1;\n+  \n+  return 0;\n+}"}, {"sha": "fde14d16b5f1f8319fb3926a9bdd6de38aac833b", "filename": "gcc/toplev.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdbca1727ce8d428964efcb2f20ee82142a2c762/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdbca1727ce8d428964efcb2f20ee82142a2c762/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=cdbca1727ce8d428964efcb2f20ee82142a2c762", "patch": "@@ -2978,6 +2978,11 @@ rest_of_compilation (decl)\n \n       /* Currently, there's nothing to do in SSA form.  */\n \n+      /* The SSA implementation uses basic block numbers in its phi\n+\t nodes.  Thus, changing the control-flow graph or the basic\n+\t blocks, e.g., calling find_basic_blocks () or cleanup_cfg (),\n+\t may cause problems.  */\n+\n       /* Convert from SSA form.  */\n \n       timevar_push (TV_FROM_SSA);"}]}