{"sha": "f5470a77425a54efebfe1732488c40f05ef176d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU0NzBhNzc0MjVhNTRlZmViZmUxNzMyNDg4YzQwZjA1ZWYxNzZkMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-11T13:13:54Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-11T13:13:54Z"}, "message": "[AArch64] Rework interface to add constant/offset routines\n\nThe port had aarch64_add_offset and aarch64_add_constant routines\nthat did similar things.  This patch replaces them with an expanded\nversion of aarch64_add_offset that takes separate source and\ndestination registers.  The new routine also takes a poly_int64 offset\ninstead of a HOST_WIDE_INT offset, but it leaves the HOST_WIDE_INT\ncase to aarch64_add_offset_1, which is basically a repurposed\naarch64_add_constant_internal.  The SVE patch will put the handling\nof VL-based constants in aarch64_add_offset, while still using\naarch64_add_offset_1 for the constant part.\n\nThe vcall_offset == 0 path in aarch64_output_mi_thunk will use temp0\nas well as temp1 once SVE is added.\n\nA side-effect of the patch is that we now generate:\n\n        mov     x29, sp\n\ninstead of:\n\n        add     x29, sp, 0\n\nin the pr70044.c test.\n\n2018-01-11  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_force_temporary): Assert that\n\tx exists before using it.\n\t(aarch64_add_constant_internal): Rename to...\n\t(aarch64_add_offset_1): ...this.  Replace regnum with separate\n\tsrc and dest rtxes.  Handle the case in which they're different,\n\tincluding when the offset is zero.  Replace scratchreg with an rtx.\n\tUse 2 additions if there is no spare register into which we can\n\tmove a 16-bit constant.\n\t(aarch64_add_constant): Delete.\n\t(aarch64_add_offset): Replace reg with separate src and dest\n\trtxes.  Take a poly_int64 offset instead of a HOST_WIDE_INT.\n\tUse aarch64_add_offset_1.\n\t(aarch64_add_sp, aarch64_sub_sp): Take the scratch register as\n\tan rtx rather than an int.  Take the delta as a poly_int64\n\trather than a HOST_WIDE_INT.  Use aarch64_add_offset.\n\t(aarch64_expand_mov_immediate): Update uses of aarch64_add_offset.\n\t(aarch64_expand_prologue): Update calls to aarch64_sub_sp,\n\taarch64_allocate_and_probe_stack_space and aarch64_add_offset.\n\t(aarch64_expand_epilogue): Update calls to aarch64_add_offset\n\tand aarch64_add_sp.\n\t(aarch64_output_mi_thunk): Use aarch64_add_offset rather than\n\taarch64_add_constant.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/pr70044.c: Allow \"mov x29, sp\" too.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256532", "tree": {"sha": "7c9ad00e360700db9b5efc7ff32f9f1e50591383", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c9ad00e360700db9b5efc7ff32f9f1e50591383"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5470a77425a54efebfe1732488c40f05ef176d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5470a77425a54efebfe1732488c40f05ef176d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5470a77425a54efebfe1732488c40f05ef176d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5470a77425a54efebfe1732488c40f05ef176d0/comments", "author": null, "committer": null, "parents": [{"sha": "0d0e0188d80f337d2d997ac787b62cc7e8387612", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d0e0188d80f337d2d997ac787b62cc7e8387612", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d0e0188d80f337d2d997ac787b62cc7e8387612"}], "stats": {"total": 240, "additions": 153, "deletions": 87}, "files": [{"sha": "19a37573b24becca4552e452986d9e3722460177", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5470a77425a54efebfe1732488c40f05ef176d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5470a77425a54efebfe1732488c40f05ef176d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5470a77425a54efebfe1732488c40f05ef176d0", "patch": "@@ -1,3 +1,30 @@\n+2018-01-11  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_force_temporary): Assert that\n+\tx exists before using it.\n+\t(aarch64_add_constant_internal): Rename to...\n+\t(aarch64_add_offset_1): ...this.  Replace regnum with separate\n+\tsrc and dest rtxes.  Handle the case in which they're different,\n+\tincluding when the offset is zero.  Replace scratchreg with an rtx.\n+\tUse 2 additions if there is no spare register into which we can\n+\tmove a 16-bit constant.\n+\t(aarch64_add_constant): Delete.\n+\t(aarch64_add_offset): Replace reg with separate src and dest\n+\trtxes.  Take a poly_int64 offset instead of a HOST_WIDE_INT.\n+\tUse aarch64_add_offset_1.\n+\t(aarch64_add_sp, aarch64_sub_sp): Take the scratch register as\n+\tan rtx rather than an int.  Take the delta as a poly_int64\n+\trather than a HOST_WIDE_INT.  Use aarch64_add_offset.\n+\t(aarch64_expand_mov_immediate): Update uses of aarch64_add_offset.\n+\t(aarch64_expand_prologue): Update calls to aarch64_sub_sp,\n+\taarch64_allocate_and_probe_stack_space and aarch64_add_offset.\n+\t(aarch64_expand_epilogue): Update calls to aarch64_add_offset\n+\tand aarch64_add_sp.\n+\t(aarch64_output_mi_thunk): Use aarch64_add_offset rather than\n+\taarch64_add_constant.\n+\n 2018-01-11  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* config/aarch64/aarch64.c (aarch64_reinterpret_float_as_int):"}, {"sha": "42d97d53f169deb88e3b4a5984421e9b9b1d003b", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 119, "deletions": 86, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5470a77425a54efebfe1732488c40f05ef176d0/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5470a77425a54efebfe1732488c40f05ef176d0/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=f5470a77425a54efebfe1732488c40f05ef176d0", "patch": "@@ -1883,30 +1883,13 @@ aarch64_force_temporary (machine_mode mode, rtx x, rtx value)\n     return force_reg (mode, value);\n   else\n     {\n-      x = aarch64_emit_move (x, value);\n+      gcc_assert (x);\n+      aarch64_emit_move (x, value);\n       return x;\n     }\n }\n \n \n-static rtx\n-aarch64_add_offset (scalar_int_mode mode, rtx temp, rtx reg,\n-\t\t    HOST_WIDE_INT offset)\n-{\n-  if (!aarch64_plus_immediate (GEN_INT (offset), mode))\n-    {\n-      rtx high;\n-      /* Load the full offset into a register.  This\n-         might be improvable in the future.  */\n-      high = GEN_INT (offset);\n-      offset = 0;\n-      high = aarch64_force_temporary (mode, temp, high);\n-      reg = aarch64_force_temporary (mode, temp,\n-\t\t\t\t     gen_rtx_PLUS (mode, high, reg));\n-    }\n-  return plus_constant (mode, reg, offset);\n-}\n-\n static int\n aarch64_internal_mov_immediate (rtx dest, rtx imm, bool generate,\n \t\t\t\tscalar_int_mode mode)\n@@ -2031,86 +2014,136 @@ aarch64_internal_mov_immediate (rtx dest, rtx imm, bool generate,\n   return num_insns;\n }\n \n-/* Add DELTA to REGNUM in mode MODE.  SCRATCHREG can be used to hold a\n-   temporary value if necessary.  FRAME_RELATED_P should be true if\n-   the RTX_FRAME_RELATED flag should be set and CFA adjustments added\n-   to the generated instructions.  If SCRATCHREG is known to hold\n-   abs (delta), EMIT_MOVE_IMM can be set to false to avoid emitting the\n-   immediate again.\n+/* A subroutine of aarch64_add_offset.  Set DEST to SRC + OFFSET for\n+   a non-polynomial OFFSET.  MODE is the mode of the addition.\n+   FRAME_RELATED_P is true if the RTX_FRAME_RELATED flag should\n+   be set and CFA adjustments added to the generated instructions.\n+\n+   TEMP1, if nonnull, is a register of mode MODE that can be used as a\n+   temporary if register allocation is already complete.  This temporary\n+   register may overlap DEST but must not overlap SRC.  If TEMP1 is known\n+   to hold abs (OFFSET), EMIT_MOVE_IMM can be set to false to avoid emitting\n+   the immediate again.\n \n    Since this function may be used to adjust the stack pointer, we must\n    ensure that it cannot cause transient stack deallocation (for example\n    by first incrementing SP and then decrementing when adjusting by a\n    large immediate).  */\n \n static void\n-aarch64_add_constant_internal (scalar_int_mode mode, int regnum,\n-\t\t\t       int scratchreg, HOST_WIDE_INT delta,\n-\t\t\t       bool frame_related_p, bool emit_move_imm)\n+aarch64_add_offset_1 (scalar_int_mode mode, rtx dest,\n+\t\t      rtx src, HOST_WIDE_INT offset, rtx temp1,\n+\t\t      bool frame_related_p, bool emit_move_imm)\n {\n-  HOST_WIDE_INT mdelta = abs_hwi (delta);\n-  rtx this_rtx = gen_rtx_REG (mode, regnum);\n+  gcc_assert (emit_move_imm || temp1 != NULL_RTX);\n+  gcc_assert (temp1 == NULL_RTX || !reg_overlap_mentioned_p (temp1, src));\n+\n+  HOST_WIDE_INT moffset = abs_hwi (offset);\n   rtx_insn *insn;\n \n-  if (!mdelta)\n-    return;\n+  if (!moffset)\n+    {\n+      if (!rtx_equal_p (dest, src))\n+\t{\n+\t  insn = emit_insn (gen_rtx_SET (dest, src));\n+\t  RTX_FRAME_RELATED_P (insn) = frame_related_p;\n+\t}\n+      return;\n+    }\n \n   /* Single instruction adjustment.  */\n-  if (aarch64_uimm12_shift (mdelta))\n+  if (aarch64_uimm12_shift (moffset))\n     {\n-      insn = emit_insn (gen_add2_insn (this_rtx, GEN_INT (delta)));\n+      insn = emit_insn (gen_add3_insn (dest, src, GEN_INT (offset)));\n       RTX_FRAME_RELATED_P (insn) = frame_related_p;\n       return;\n     }\n \n-  /* Emit 2 additions/subtractions if the adjustment is less than 24 bits.\n-     Only do this if mdelta is not a 16-bit move as adjusting using a move\n-     is better.  */\n-  if (mdelta < 0x1000000 && !aarch64_move_imm (mdelta, mode))\n+  /* Emit 2 additions/subtractions if the adjustment is less than 24 bits\n+     and either:\n+\n+     a) the offset cannot be loaded by a 16-bit move or\n+     b) there is no spare register into which we can move it.  */\n+  if (moffset < 0x1000000\n+      && ((!temp1 && !can_create_pseudo_p ())\n+\t  || !aarch64_move_imm (moffset, mode)))\n     {\n-      HOST_WIDE_INT low_off = mdelta & 0xfff;\n+      HOST_WIDE_INT low_off = moffset & 0xfff;\n \n-      low_off = delta < 0 ? -low_off : low_off;\n-      insn = emit_insn (gen_add2_insn (this_rtx, GEN_INT (low_off)));\n+      low_off = offset < 0 ? -low_off : low_off;\n+      insn = emit_insn (gen_add3_insn (dest, src, GEN_INT (low_off)));\n       RTX_FRAME_RELATED_P (insn) = frame_related_p;\n-      insn = emit_insn (gen_add2_insn (this_rtx, GEN_INT (delta - low_off)));\n+      insn = emit_insn (gen_add2_insn (dest, GEN_INT (offset - low_off)));\n       RTX_FRAME_RELATED_P (insn) = frame_related_p;\n       return;\n     }\n \n   /* Emit a move immediate if required and an addition/subtraction.  */\n-  rtx scratch_rtx = gen_rtx_REG (mode, scratchreg);\n   if (emit_move_imm)\n-    aarch64_internal_mov_immediate (scratch_rtx, GEN_INT (mdelta), true, mode);\n-  insn = emit_insn (delta < 0 ? gen_sub2_insn (this_rtx, scratch_rtx)\n-\t\t\t      : gen_add2_insn (this_rtx, scratch_rtx));\n+    {\n+      gcc_assert (temp1 != NULL_RTX || can_create_pseudo_p ());\n+      temp1 = aarch64_force_temporary (mode, temp1, GEN_INT (moffset));\n+    }\n+  insn = emit_insn (offset < 0\n+\t\t    ? gen_sub3_insn (dest, src, temp1)\n+\t\t    : gen_add3_insn (dest, src, temp1));\n   if (frame_related_p)\n     {\n       RTX_FRAME_RELATED_P (insn) = frame_related_p;\n-      rtx adj = plus_constant (mode, this_rtx, delta);\n-      add_reg_note (insn , REG_CFA_ADJUST_CFA, gen_rtx_SET (this_rtx, adj));\n+      rtx adj = plus_constant (mode, src, offset);\n+      add_reg_note (insn, REG_CFA_ADJUST_CFA, gen_rtx_SET (dest, adj));\n     }\n }\n \n-static inline void\n-aarch64_add_constant (scalar_int_mode mode, int regnum, int scratchreg,\n-\t\t      HOST_WIDE_INT delta)\n+/* Set DEST to SRC + OFFSET.  MODE is the mode of the addition.\n+   FRAME_RELATED_P is true if the RTX_FRAME_RELATED flag should\n+   be set and CFA adjustments added to the generated instructions.\n+\n+   TEMP1, if nonnull, is a register of mode MODE that can be used as a\n+   temporary if register allocation is already complete.  This temporary\n+   register may overlap DEST but must not overlap SRC.  If TEMP1 is known\n+   to hold abs (OFFSET), EMIT_MOVE_IMM can be set to false to avoid emitting\n+   the immediate again.\n+\n+   Since this function may be used to adjust the stack pointer, we must\n+   ensure that it cannot cause transient stack deallocation (for example\n+   by first incrementing SP and then decrementing when adjusting by a\n+   large immediate).  */\n+\n+static void\n+aarch64_add_offset (scalar_int_mode mode, rtx dest, rtx src,\n+\t\t    poly_int64 offset, rtx temp1, bool frame_related_p,\n+\t\t    bool emit_move_imm = true)\n {\n-  aarch64_add_constant_internal (mode, regnum, scratchreg, delta, false, true);\n+  gcc_assert (emit_move_imm || temp1 != NULL_RTX);\n+  gcc_assert (temp1 == NULL_RTX || !reg_overlap_mentioned_p (temp1, src));\n+\n+  /* SVE support will go here.  */\n+  HOST_WIDE_INT constant = offset.to_constant ();\n+  aarch64_add_offset_1 (mode, dest, src, constant, temp1,\n+\t\t\tframe_related_p, emit_move_imm);\n }\n \n+/* Add DELTA to the stack pointer, marking the instructions frame-related.\n+   TEMP1 is available as a temporary if nonnull.  EMIT_MOVE_IMM is false\n+   if TEMP1 already contains abs (DELTA).  */\n+\n static inline void\n-aarch64_add_sp (int scratchreg, HOST_WIDE_INT delta, bool emit_move_imm)\n+aarch64_add_sp (rtx temp1, poly_int64 delta, bool emit_move_imm)\n {\n-  aarch64_add_constant_internal (Pmode, SP_REGNUM, scratchreg, delta,\n-\t\t\t\t true, emit_move_imm);\n+  aarch64_add_offset (Pmode, stack_pointer_rtx, stack_pointer_rtx, delta,\n+\t\t      temp1, true, emit_move_imm);\n }\n \n+/* Subtract DELTA from the stack pointer, marking the instructions\n+   frame-related if FRAME_RELATED_P.  TEMP1 is available as a temporary\n+   if nonnull.  */\n+\n static inline void\n-aarch64_sub_sp (int scratchreg, HOST_WIDE_INT delta, bool frame_related_p)\n+aarch64_sub_sp (rtx temp1, poly_int64 delta, bool frame_related_p)\n {\n-  aarch64_add_constant_internal (Pmode, SP_REGNUM, scratchreg, -delta,\n-\t\t\t\t frame_related_p, true);\n+  aarch64_add_offset (Pmode, stack_pointer_rtx, stack_pointer_rtx, -delta,\n+\t\t      temp1, frame_related_p);\n }\n \n void\n@@ -2143,9 +2176,8 @@ aarch64_expand_mov_immediate (rtx dest, rtx imm)\n \t    {\n \t      gcc_assert (can_create_pseudo_p ());\n \t      base = aarch64_force_temporary (int_mode, dest, base);\n-\t      base = aarch64_add_offset (int_mode, NULL, base,\n-\t\t\t\t\t INTVAL (offset));\n-\t      aarch64_emit_move (dest, base);\n+\t      aarch64_add_offset (int_mode, dest, base, INTVAL (offset),\n+\t\t\t\t  NULL_RTX, false);\n \t      return;\n \t    }\n \n@@ -2184,9 +2216,8 @@ aarch64_expand_mov_immediate (rtx dest, rtx imm)\n \t    {\n \t      gcc_assert(can_create_pseudo_p ());\n \t      base = aarch64_force_temporary (int_mode, dest, base);\n-\t      base = aarch64_add_offset (int_mode, NULL, base,\n-\t\t\t\t\t INTVAL (offset));\n-\t      aarch64_emit_move (dest, base);\n+\t      aarch64_add_offset (int_mode, dest, base, INTVAL (offset),\n+\t\t\t\t  NULL_RTX, false);\n \t      return;\n \t    }\n \t  /* FALLTHRU */\n@@ -3738,7 +3769,10 @@ aarch64_expand_prologue (void)\n \taarch64_emit_probe_stack_range (get_stack_check_protect (), frame_size);\n     }\n \n-  aarch64_sub_sp (IP0_REGNUM, initial_adjust, true);\n+  rtx ip0_rtx = gen_rtx_REG (Pmode, IP0_REGNUM);\n+  rtx ip1_rtx = gen_rtx_REG (Pmode, IP1_REGNUM);\n+\n+  aarch64_sub_sp (ip0_rtx, initial_adjust, true);\n \n   if (callee_adjust != 0)\n     aarch64_push_regs (reg1, reg2, callee_adjust);\n@@ -3748,18 +3782,17 @@ aarch64_expand_prologue (void)\n       if (callee_adjust == 0)\n \taarch64_save_callee_saves (DImode, callee_offset, R29_REGNUM,\n \t\t\t\t   R30_REGNUM, false);\n-      insn = emit_insn (gen_add3_insn (hard_frame_pointer_rtx,\n-\t\t\t\t       stack_pointer_rtx,\n-\t\t\t\t       GEN_INT (callee_offset)));\n-      RTX_FRAME_RELATED_P (insn) = frame_pointer_needed;\n+      aarch64_add_offset (Pmode, hard_frame_pointer_rtx,\n+\t\t\t  stack_pointer_rtx, callee_offset, ip1_rtx,\n+\t\t\t  frame_pointer_needed);\n       emit_insn (gen_stack_tie (stack_pointer_rtx, hard_frame_pointer_rtx));\n     }\n \n   aarch64_save_callee_saves (DImode, callee_offset, R0_REGNUM, R30_REGNUM,\n \t\t\t     callee_adjust != 0 || emit_frame_chain);\n   aarch64_save_callee_saves (DFmode, callee_offset, V0_REGNUM, V31_REGNUM,\n \t\t\t     callee_adjust != 0 || emit_frame_chain);\n-  aarch64_sub_sp (IP1_REGNUM, final_adjust, !frame_pointer_needed);\n+  aarch64_sub_sp (ip1_rtx, final_adjust, !frame_pointer_needed);\n }\n \n /* Return TRUE if we can use a simple_return insn.\n@@ -3815,17 +3848,16 @@ aarch64_expand_epilogue (bool for_sibcall)\n \n   /* Restore the stack pointer from the frame pointer if it may not\n      be the same as the stack pointer.  */\n+  rtx ip0_rtx = gen_rtx_REG (Pmode, IP0_REGNUM);\n+  rtx ip1_rtx = gen_rtx_REG (Pmode, IP1_REGNUM);\n   if (frame_pointer_needed && (final_adjust || cfun->calls_alloca))\n-    {\n-      insn = emit_insn (gen_add3_insn (stack_pointer_rtx,\n-\t\t\t\t       hard_frame_pointer_rtx,\n-\t\t\t\t       GEN_INT (-callee_offset)));\n-      /* If writeback is used when restoring callee-saves, the CFA\n-\t is restored on the instruction doing the writeback.  */\n-      RTX_FRAME_RELATED_P (insn) = callee_adjust == 0;\n-    }\n+    /* If writeback is used when restoring callee-saves, the CFA\n+       is restored on the instruction doing the writeback.  */\n+    aarch64_add_offset (Pmode, stack_pointer_rtx,\n+\t\t\thard_frame_pointer_rtx, -callee_offset,\n+\t\t\tip1_rtx, callee_adjust == 0);\n   else\n-    aarch64_add_sp (IP1_REGNUM, final_adjust, df_regs_ever_live_p (IP1_REGNUM));\n+    aarch64_add_sp (ip1_rtx, final_adjust, df_regs_ever_live_p (IP1_REGNUM));\n \n   aarch64_restore_callee_saves (DImode, callee_offset, R0_REGNUM, R30_REGNUM,\n \t\t\t\tcallee_adjust != 0, &cfi_ops);\n@@ -3848,7 +3880,7 @@ aarch64_expand_epilogue (bool for_sibcall)\n       cfi_ops = NULL;\n     }\n \n-  aarch64_add_sp (IP0_REGNUM, initial_adjust, df_regs_ever_live_p (IP0_REGNUM));\n+  aarch64_add_sp (ip0_rtx, initial_adjust, df_regs_ever_live_p (IP0_REGNUM));\n \n   if (cfi_ops)\n     {\n@@ -3953,24 +3985,25 @@ aarch64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n   reload_completed = 1;\n   emit_note (NOTE_INSN_PROLOGUE_END);\n \n+  this_rtx = gen_rtx_REG (Pmode, this_regno);\n+  temp0 = gen_rtx_REG (Pmode, IP0_REGNUM);\n+  temp1 = gen_rtx_REG (Pmode, IP1_REGNUM);\n+\n   if (vcall_offset == 0)\n-    aarch64_add_constant (Pmode, this_regno, IP1_REGNUM, delta);\n+    aarch64_add_offset (Pmode, this_rtx, this_rtx, delta, temp1, false);\n   else\n     {\n       gcc_assert ((vcall_offset & (POINTER_BYTES - 1)) == 0);\n \n-      this_rtx = gen_rtx_REG (Pmode, this_regno);\n-      temp0 = gen_rtx_REG (Pmode, IP0_REGNUM);\n-      temp1 = gen_rtx_REG (Pmode, IP1_REGNUM);\n-\n       addr = this_rtx;\n       if (delta != 0)\n \t{\n \t  if (delta >= -256 && delta < 256)\n \t    addr = gen_rtx_PRE_MODIFY (Pmode, this_rtx,\n \t\t\t\t       plus_constant (Pmode, this_rtx, delta));\n \t  else\n-\t    aarch64_add_constant (Pmode, this_regno, IP1_REGNUM, delta);\n+\t    aarch64_add_offset (Pmode, this_rtx, this_rtx, delta, temp1,\n+\t\t\t\tfalse);\n \t}\n \n       if (Pmode == ptr_mode)"}, {"sha": "afd7327b3d73b5e3aab26a2c3730c82a55d00f8c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5470a77425a54efebfe1732488c40f05ef176d0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5470a77425a54efebfe1732488c40f05ef176d0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f5470a77425a54efebfe1732488c40f05ef176d0", "patch": "@@ -1,3 +1,9 @@\n+2018-01-11  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc.target/aarch64/pr70044.c: Allow \"mov x29, sp\" too.\n+\n 2018-01-11  Tamar Christina  <tamar.christina@arm.com>\n \n \t* gcc.target/aarch64/advsimd-intrinsics/vdot-compile-2.c: New."}, {"sha": "6080a074f2692cd3e7085dc69e6d3b62f84bee04", "filename": "gcc/testsuite/gcc.target/aarch64/pr70044.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5470a77425a54efebfe1732488c40f05ef176d0/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr70044.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5470a77425a54efebfe1732488c40f05ef176d0/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr70044.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr70044.c?ref=f5470a77425a54efebfe1732488c40f05ef176d0", "patch": "@@ -11,4 +11,4 @@ main (int argc, char **argv)\n }\n \n /* Check that the frame pointer really is created.  */\n-/* { dg-final { scan-lto-assembler \"add\tx29, sp,\" } } */\n+/* { dg-final { scan-lto-assembler \"(mov|add)\tx29, sp\" } } */"}]}