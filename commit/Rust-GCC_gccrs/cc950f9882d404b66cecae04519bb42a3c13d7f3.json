{"sha": "cc950f9882d404b66cecae04519bb42a3c13d7f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M5NTBmOTg4MmQ0MDRiNjZjZWNhZTA0NTE5YmI0MmEzYzEzZDdmMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2016-04-16T18:54:49Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-04-16T18:54:49Z"}, "message": "re PR c++/70018 (Possible issue around IPO and C++ comdats discovered as pure/const)\n\n\n\tPR ipa/70018\n\t* cgraph.c (cgraph_set_const_flag_1): Only set as pure if\n\tfunction does not bind to current def.\n\t* ipa-pure-const.c (worse_state): Add FROM and TO parameters;\n\thandle conservatively calls to functions that does not need to bind\n\tto current def.\n\t(check_call): Update call of worse_state.\n\t(ignore_edge_for_nothrow): Update.\n\t(ignore_edge_for_pure_const): Likewise.\n\t(propagate_pure_const): Update calls to worse_state.\n\t(skip_function_for_local_pure_const): Reformat comments.\n\n\t* g++.dg/ipa/pure-const-1.C: New testcase.\n\t* g++.dg/ipa/pure-const-2.C: New testcase.\n\t* g++.dg/ipa/pure-const-3.C: New testcase.\n\nFrom-SVN: r235065", "tree": {"sha": "309f864360341cd70502972284de03b9c4215fe3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/309f864360341cd70502972284de03b9c4215fe3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc950f9882d404b66cecae04519bb42a3c13d7f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc950f9882d404b66cecae04519bb42a3c13d7f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc950f9882d404b66cecae04519bb42a3c13d7f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc950f9882d404b66cecae04519bb42a3c13d7f3/comments", "author": null, "committer": null, "parents": [{"sha": "f13fe18b5b4881a457c2176214349d322b61e187", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f13fe18b5b4881a457c2176214349d322b61e187", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f13fe18b5b4881a457c2176214349d322b61e187"}], "stats": {"total": 219, "additions": 194, "deletions": 25}, "files": [{"sha": "c738ef397523e1bbdbb594b0fa81b52215ee56c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc950f9882d404b66cecae04519bb42a3c13d7f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc950f9882d404b66cecae04519bb42a3c13d7f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc950f9882d404b66cecae04519bb42a3c13d7f3", "patch": "@@ -1,3 +1,17 @@\n+2016-04-15  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR ipa/70018\n+\t* cgraph.c (cgraph_set_const_flag_1): Only set as pure if\n+\tfunction does not bind to current def.\n+\t* ipa-pure-const.c (worse_state): Add FROM and TO parameters;\n+\thandle conservatively calls to functions that does not need to bind\n+\tto current def.\n+\t(check_call): Update call of worse_state.\n+\t(ignore_edge_for_nothrow): Update.\n+\t(ignore_edge_for_pure_const): Likewise.\n+\t(propagate_pure_const): Update calls to worse_state.\n+\t(skip_function_for_local_pure_const): Reformat comments.\n+\n 2016-04-15  Jan Hubicka  <jh@suse.cz>\n \n \tPR ipa/70018"}, {"sha": "c43adb94fa641f61dc3d5ae0595d38f8dbfa01f9", "filename": "gcc/cgraph.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc950f9882d404b66cecae04519bb42a3c13d7f3/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc950f9882d404b66cecae04519bb42a3c13d7f3/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=cc950f9882d404b66cecae04519bb42a3c13d7f3", "patch": "@@ -2393,7 +2393,35 @@ cgraph_set_const_flag_1 (cgraph_node *node, void *data)\n       if (DECL_STATIC_DESTRUCTOR (node->decl))\n \tDECL_STATIC_DESTRUCTOR (node->decl) = 0;\n     }\n-  TREE_READONLY (node->decl) = data != NULL;\n+\n+  /* Consider function:\n+\n+     bool a(int *p)\n+     {\n+       return *p==*p;\n+     }\n+\n+     During early optimization we will turn this into:\n+\n+     bool a(int *p)\n+     {\n+       return true;\n+     }\n+\n+     Now if this function will be detected as CONST however when interposed it\n+     may end up being just pure.  We always must assume the worst scenario here.\n+   */\n+  if (TREE_READONLY (node->decl))\n+    ;\n+  else if (node->binds_to_current_def_p ())\n+    TREE_READONLY (node->decl) = data != NULL;\n+  else\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Dropping state to PURE because function does \"\n+\t\t \"not bind to current def.\\n\");\n+      DECL_PURE_P (node->decl) = data != NULL;\n+    }\n   DECL_LOOPING_CONST_OR_PURE_P (node->decl) = ((size_t)data & 2) != 0;\n   return false;\n }"}, {"sha": "da8fd4d409b36d001a816544e79703c7d4400603", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 64, "deletions": 24, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc950f9882d404b66cecae04519bb42a3c13d7f3/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc950f9882d404b66cecae04519bb42a3c13d7f3/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=cc950f9882d404b66cecae04519bb42a3c13d7f3", "patch": "@@ -440,12 +440,40 @@ better_state (enum pure_const_state_e *state, bool *looping,\n }\n \n /* Merge STATE and STATE2 and LOOPING and LOOPING2 and store\n-   into STATE and LOOPING worse of the two variants.  */\n+   into STATE and LOOPING worse of the two variants.\n+   N is the actual node called.  */\n \n static inline void\n worse_state (enum pure_const_state_e *state, bool *looping,\n-\t     enum pure_const_state_e state2, bool looping2)\n+\t     enum pure_const_state_e state2, bool looping2,\n+\t     struct symtab_node *from,\n+\t     struct symtab_node *to)\n {\n+  /* Consider function:\n+\n+     bool a(int *p)\n+     {\n+       return *p==*p;\n+     }\n+\n+     During early optimization we will turn this into:\n+\n+     bool a(int *p)\n+     {\n+       return true;\n+     }\n+\n+     Now if this function will be detected as CONST however when interposed it\n+     may end up being just pure.  We always must assume the worst scenario here.\n+   */\n+  if (*state == IPA_CONST && state2 == IPA_CONST\n+      && to && !TREE_READONLY (to->decl) && !to->binds_to_current_def_p (from))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Dropping state to PURE because call to %s may not \"\n+\t\t \"bind to current def.\\n\", to->name ());\n+      state2 = IPA_PURE;\n+    }\n   *state = MAX (*state, state2);\n   *looping = MAX (*looping, looping2);\n }\n@@ -546,7 +574,8 @@ check_call (funct_state local, gcall *call, bool ipa)\n       if (special_builtin_state (&call_state, &call_looping, callee_t))\n \t{\n \t  worse_state (&local->pure_const_state, &local->looping,\n-\t\t       call_state, call_looping);\n+\t\t       call_state, call_looping,\n+\t\t       NULL, NULL);\n \t  return;\n \t}\n       /* When bad things happen to bad functions, they cannot be const\n@@ -617,7 +646,7 @@ check_call (funct_state local, gcall *call, bool ipa)\n \t\t\t == (ECF_NORETURN | ECF_NOTHROW))\n \t\t\t|| (!flag_exceptions && (flags & ECF_NORETURN)));\n       worse_state (&local->pure_const_state, &local->looping,\n-\t\t   call_state, call_looping);\n+\t\t   call_state, call_looping, NULL, NULL);\n     }\n   /* Direct functions calls are handled by IPA propagation.  */\n }\n@@ -902,8 +931,7 @@ add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n      static declarations.  We do not need to scan them more than once\n      since all we would be interested in are the addressof\n      operations.  */\n-  if (node->get_availability () > AVAIL_INTERPOSABLE\n-      && opt_for_fn (node->decl, flag_ipa_pure_const))\n+  if (opt_for_fn (node->decl, flag_ipa_pure_const))\n     set_function_state (node, analyze_function (node, true));\n }\n \n@@ -973,8 +1001,7 @@ pure_const_generate_summary (void)\n      when function got cloned and the clone is AVAILABLE.  */\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (node->get_availability () >= AVAIL_INTERPOSABLE\n-        && opt_for_fn (node->decl, flag_ipa_pure_const))\n+    if (opt_for_fn (node->decl, flag_ipa_pure_const))\n       set_function_state (node, analyze_function (node, true));\n }\n \n@@ -1105,7 +1132,7 @@ pure_const_read_summary (void)\n \t\t  fprintf (dump_file, \"\\n  pure const state: %s\\n\",\n \t\t\t   pure_const_names[fs->pure_const_state]);\n \t\t  fprintf (dump_file, \"  previously known state: %s\\n\",\n-\t\t\t   pure_const_names[fs->looping_previously_known]);\n+\t\t\t   pure_const_names[fs->state_previously_known]);\n \t\t  if (fs->looping)\n \t\t    fprintf (dump_file,\"  function is locally looping\\n\");\n \t\t  if (fs->looping_previously_known)\n@@ -1134,7 +1161,8 @@ ignore_edge_for_nothrow (struct cgraph_edge *e)\n     return true;\n \n   enum availability avail;\n-  cgraph_node *n = e->callee->function_or_virtual_thunk_symbol (&avail);\n+  cgraph_node *n = e->callee->function_or_virtual_thunk_symbol (&avail,\n+\t\t\t\t\t\t\t        e->caller);\n   return (avail <= AVAIL_INTERPOSABLE || TREE_NOTHROW (n->decl));\n }\n \n@@ -1170,7 +1198,7 @@ static bool\n ignore_edge_for_pure_const (struct cgraph_edge *e)\n {\n   enum availability avail;\n-  e->callee->function_or_virtual_thunk_symbol (&avail);\n+  e->callee->function_or_virtual_thunk_symbol (&avail, e->caller);\n   return (avail <= AVAIL_INTERPOSABLE);\n }\n \n@@ -1232,18 +1260,25 @@ propagate_pure_const (void)\n \t\t     pure_const_names[w_l->pure_const_state],\n \t\t     w_l->looping);\n \n-\t  /* First merge in function body properties.  */\n+\t  /* First merge in function body properties.\n+\t     We are safe to pass NULL as FROM and TO because we will take care\n+\t     of possible interposition when walking callees.  */\n \t  worse_state (&pure_const_state, &looping,\n-\t\t       w_l->pure_const_state, w_l->looping);\n+\t\t       w_l->pure_const_state, w_l->looping,\n+\t\t       NULL, NULL);\n \t  if (pure_const_state == IPA_NEITHER)\n \t    break;\n \n-\t  /* For interposable nodes we can not assume anything.  */\n+\t  /* For interposable nodes we can not assume anything.\n+\t     FIXME: It should be safe to remove this conditional and allow\n+\t     interposable functions with non-interposable aliases next\n+\t     stage 1.  */\n \t  if (w->get_availability () == AVAIL_INTERPOSABLE)\n \t    {\n \t      worse_state (&pure_const_state, &looping,\n \t\t\t   w_l->state_previously_known,\n-\t\t\t   w_l->looping_previously_known);\n+\t\t\t   w_l->looping_previously_known,\n+\t\t\t   NULL, NULL);\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n \t\t  fprintf (dump_file,\n@@ -1268,7 +1303,8 @@ propagate_pure_const (void)\n \t    {\n \t      enum availability avail;\n \t      struct cgraph_node *y = e->callee->\n-\t\t\t\tfunction_or_virtual_thunk_symbol (&avail);\n+\t\t\t\tfunction_or_virtual_thunk_symbol (&avail,\n+\t\t\t\t\t\t\t\t  e->caller);\n \t      enum pure_const_state_e edge_state = IPA_CONST;\n \t      bool edge_looping = false;\n \n@@ -1318,7 +1354,7 @@ propagate_pure_const (void)\n \t\t\t    w_l->state_previously_known,\n \t\t\t    w_l->looping_previously_known);\n \t      worse_state (&pure_const_state, &looping,\n-\t\t\t   edge_state, edge_looping);\n+\t\t\t   edge_state, edge_looping, e->caller, e->callee);\n \t      if (pure_const_state == IPA_NEITHER)\n \t        break;\n \t    }\n@@ -1340,7 +1376,7 @@ propagate_pure_const (void)\n \t\t\t    w_l->state_previously_known,\n \t\t\t    w_l->looping_previously_known);\n \t      worse_state (&pure_const_state, &looping,\n-\t\t\t   edge_state, edge_looping);\n+\t\t\t   edge_state, edge_looping, NULL, NULL);\n \t      if (pure_const_state == IPA_NEITHER)\n \t        break;\n \t    }\n@@ -1378,7 +1414,7 @@ propagate_pure_const (void)\n \t\t\t    w_l->state_previously_known,\n \t\t\t    w_l->looping_previously_known);\n \t      worse_state (&pure_const_state, &looping,\n-\t\t\t   ref_state, ref_looping);\n+\t\t\t   ref_state, ref_looping, NULL, NULL);\n \t      if (pure_const_state == IPA_NEITHER)\n \t\tbreak;\n \t    }\n@@ -1407,7 +1443,8 @@ propagate_pure_const (void)\n \t    {\n \t      enum availability avail;\n \t      struct cgraph_node *y = e->callee->\n-\t\t\t\tfunction_or_virtual_thunk_symbol (&avail);\n+\t\t\t\tfunction_or_virtual_thunk_symbol (&avail,\n+\t\t\t\t\t\t\t\t  e->caller);\n \n \t      if (avail > AVAIL_INTERPOSABLE)\n \t\tcan_free = get_function_state (y)->can_free;\n@@ -1552,7 +1589,8 @@ propagate_nothrow (void)\n \t\t    continue;\n \n \t\t  struct cgraph_node *y = e->callee->\n-\t\t\t\t    function_or_virtual_thunk_symbol (&avail);\n+\t\t\t\t    function_or_virtual_thunk_symbol (&avail,\n+\t\t\t\t\t\t\t\t      e->caller);\n \n \t\t  /* We can use info about the callee only if we know it can\n \t\t     not be interposed.  */\n@@ -1664,8 +1702,9 @@ make_pass_ipa_pure_const (gcc::context *ctxt)\n static bool\n skip_function_for_local_pure_const (struct cgraph_node *node)\n {\n-  /* Because we do not schedule pass_fixup_cfg over whole program after early optimizations\n-     we must not promote functions that are called by already processed functions.  */\n+  /* Because we do not schedule pass_fixup_cfg over whole program after early\n+     optimizations we must not promote functions that are called by already\n+     processed functions.  */\n \n   if (function_called_by_processed_nodes_p ())\n     {\n@@ -1676,7 +1715,8 @@ skip_function_for_local_pure_const (struct cgraph_node *node)\n   if (node->get_availability () <= AVAIL_INTERPOSABLE)\n     {\n       if (dump_file)\n-        fprintf (dump_file, \"Function is not available or interposable; not analyzing.\\n\");\n+        fprintf (dump_file,\n+\t\t \"Function is not available or interposable; not analyzing.\\n\");\n       return true;\n     }\n   return false;"}, {"sha": "efb2caa93a25722684b5496f5bd0ad2d8afa6f88", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc950f9882d404b66cecae04519bb42a3c13d7f3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc950f9882d404b66cecae04519bb42a3c13d7f3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cc950f9882d404b66cecae04519bb42a3c13d7f3", "patch": "@@ -1,3 +1,10 @@\n+2016-04-15  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR ipa/70018\n+\t* g++.dg/ipa/pure-const-1.C: New testcase.\n+\t* g++.dg/ipa/pure-const-2.C: New testcase.\n+\t* g++.dg/ipa/pure-const-3.C: New testcase.\n+\n 2016-04-15  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/70671"}, {"sha": "a219c7130771cfa2eb9ebebc463216e95f95eb13", "filename": "gcc/testsuite/g++.dg/ipa/pure-const-1.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc950f9882d404b66cecae04519bb42a3c13d7f3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpure-const-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc950f9882d404b66cecae04519bb42a3c13d7f3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpure-const-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpure-const-1.C?ref=cc950f9882d404b66cecae04519bb42a3c13d7f3", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\"  } */\n+int *ptr;\n+static int barvar;\n+\n+/* We can not detect A to be const because it may be interposed by unoptimized\n+   body.  */\n+inline\n+__attribute__ ((noinline))\n+int a(void)\n+{\n+  return *ptr == *ptr;\n+}\n+main()\n+{\n+  int aa;\n+  ptr = &barvar;\n+  aa=!a();\n+  ptr = 0;\n+  return aa;\n+}\n+/* { dg-final { scan-tree-dump \"barvar\"  \"optimized\"  } } */"}, {"sha": "9788b8acdd822abc41c9d49cd3b46693a9030861", "filename": "gcc/testsuite/g++.dg/ipa/pure-const-2.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc950f9882d404b66cecae04519bb42a3c13d7f3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpure-const-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc950f9882d404b66cecae04519bb42a3c13d7f3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpure-const-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpure-const-2.C?ref=cc950f9882d404b66cecae04519bb42a3c13d7f3", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\"  } */\n+int *ptr;\n+static int barvar;\n+/* We can not detect A to be const because it may be interposed by unoptimized\n+   body.  */\n+inline\n+__attribute__ ((noinline))\n+int a(void)\n+{\n+  return *ptr == *ptr;\n+}\n+__attribute__ ((noinline))\n+static int b(void)\n+{\n+  return a();\n+}\n+main()\n+{\n+  int aa;\n+  ptr = &barvar;\n+  aa=!b();\n+  ptr = 0;\n+  return aa;\n+}\n+/* { dg-final { scan-tree-dump \"barvar\"  \"optimized\"  } } */"}, {"sha": "3779ecb4e7d5e88f1b731f2337b664d20479ef69", "filename": "gcc/testsuite/g++.dg/ipa/pure-const-3.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc950f9882d404b66cecae04519bb42a3c13d7f3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpure-const-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc950f9882d404b66cecae04519bb42a3c13d7f3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpure-const-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpure-const-3.C?ref=cc950f9882d404b66cecae04519bb42a3c13d7f3", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\"  } */\n+int *ptr;\n+static int barvar;\n+static int b(int a);\n+/* We can not detect A to be const because it may be interposed by unoptimized\n+   body.  */\n+inline\n+__attribute__ ((noinline))\n+int a(int a)\n+{\n+  if (a>0)\n+    return b(a-1);\n+  return *ptr == *ptr;\n+}\n+inline\n+__attribute__ ((noinline))\n+static int b(int p)\n+{\n+  if (p<0)\n+    return a(p+1);\n+  return 1;\n+}\n+main()\n+{\n+  int aa;\n+  ptr = &barvar;\n+  aa=!b(3);\n+  ptr = 0;\n+  return aa;\n+}\n+/* { dg-final { scan-tree-dump \"barvar\"  \"optimized\"  } } */"}]}