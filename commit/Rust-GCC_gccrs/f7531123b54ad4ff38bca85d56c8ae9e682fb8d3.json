{"sha": "f7531123b54ad4ff38bca85d56c8ae9e682fb8d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc1MzExMjNiNTRhZDRmZjM4YmNhODVkNTZjOGFlOWU2ODJmYjhkMw==", "commit": {"author": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1993-09-29T05:42:10Z"}, "committer": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1993-09-29T05:42:10Z"}, "message": "(quote_string): New function.\n\n(special_symbol, write_output, output_line_command): Use it to quote\nspecial characters in file names on output.\n(do_line): Parse escape sequences in #line directives' file names.\n\nFrom-SVN: r5529", "tree": {"sha": "8ebb6701860eee779a5c85610a3d040e2fff17b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ebb6701860eee779a5c85610a3d040e2fff17b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7531123b54ad4ff38bca85d56c8ae9e682fb8d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7531123b54ad4ff38bca85d56c8ae9e682fb8d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7531123b54ad4ff38bca85d56c8ae9e682fb8d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7531123b54ad4ff38bca85d56c8ae9e682fb8d3/comments", "author": null, "committer": null, "parents": [{"sha": "cf1d841dcb4c84b9cf4be05fe73246be062140db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf1d841dcb4c84b9cf4be05fe73246be062140db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf1d841dcb4c84b9cf4be05fe73246be062140db"}], "stats": {"total": 103, "additions": 70, "deletions": 33}, "files": [{"sha": "ebd8416b93152ab6c51418ec079d93751201883a", "filename": "gcc/cccp.c", "status": "modified", "additions": 70, "deletions": 33, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7531123b54ad4ff38bca85d56c8ae9e682fb8d3/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7531123b54ad4ff38bca85d56c8ae9e682fb8d3/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=f7531123b54ad4ff38bca85d56c8ae9e682fb8d3", "patch": "@@ -188,6 +188,7 @@ extern char *version_string;\n extern struct tm *localtime ();\n extern int sys_nerr;\n extern char *sys_errlist[];\n+extern int parse_escape ();\n \n #ifndef errno\n extern int errno;\n@@ -308,7 +309,7 @@ static char *macarg ();\n static U_CHAR *skip_to_end_of_comment ();\n static U_CHAR *skip_quoted_string ();\n static U_CHAR *skip_paren_group ();\n-static void quote_string ();\n+static char *quote_string ();\n \n static char *check_precompiled ();\n /* static struct macrodef create_definition ();\t[moved below] */\n@@ -3664,7 +3665,7 @@ special_symbol (hp, op)\n \n       if (string)\n \t{\n-\t  buf = (char *) alloca (3 + 2 * strlen (string));\n+\t  buf = (char *) alloca (3 + 4 * strlen (string));\n \t  quote_string (buf, string);\n \t}\n       else\n@@ -4734,12 +4735,14 @@ write_output ()\n     if (next_string\n \t&& cur_buf_loc - outbuf.buf == next_string->output_mark) {\n       if (next_string->writeflag) {\n-\tlen = strlen (next_string->filename);\n-\tif (len > line_command_len)\n+\tlen = 4 * strlen (next_string->filename) + 32;\n+\twhile (len > line_command_len)\n \t  line_command = xrealloc (line_command, \n \t\t\t\t   line_command_len *= 2);\n-\tsprintf (line_command, \"\\n# %d \\\"%s\\\"\\n\",\n-\t\t next_string->lineno, next_string->filename);\n+\tsprintf (line_command, \"\\n# %d \", next_string->lineno);\n+\tstrcpy (quote_string (line_command + strlen (line_command),\n+\t\t              next_string->filename),\n+\t\t\"\\n\");\n \tif (write (fileno (stdout), line_command, strlen (line_command)) < 0)\n \t  pfatal_with_name (out_fname);\n \tif (write (fileno (stdout), next_string->contents, next_string->len) < 0)\n@@ -5888,21 +5891,39 @@ do_line (buf, limit, op, keyword)\n   if (*bp == '\\\"') {\n     static HASHNODE *fname_table[FNAME_HASHSIZE];\n     HASHNODE *hp, **hash_bucket;\n-    U_CHAR *fname;\n+    U_CHAR *fname, *p;\n     int fname_length;\n \n     fname = ++bp;\n \n-    while (*bp && *bp != '\\\"')\n-      bp++;\n-    if (*bp != '\\\"') {\n-      error (\"invalid format `#line' command\");\n-      return 0;\n-    }\n+    /* Turn the file name, which is a character string literal,\n+       into a null-terminated string.  Do this in place.  */\n+    p = bp;\n+    for (;;)\n+      switch ((*p++ = *bp++)) {\n+      case '\\0':\n+\terror (\"invalid format `#line' command\");\n+\treturn 0;\n \n-    fname_length = bp - fname;\n+      case '\\\\':\n+\t{\n+\t  char *bpc = (char *) bp;\n+\t  int c = parse_escape (&bpc);\n+\t  bp = (U_CHAR *) bpc;\n+\t  if (c < 0)\n+\t    p--;\n+\t  else\n+\t    p[-1] = c;\n+\t}\n+\tbreak;\n+\n+      case '\\\"':\n+\tp[-1] = 0;\n+\tgoto fname_done;\n+      }\n+  fname_done:\n+    fname_length = p - fname;\n \n-    bp++;\n     SKIP_WHITE_SPACE (bp);\n     if (*bp) {\n       if (pedantic)\n@@ -6908,28 +6929,38 @@ skip_quoted_string (bp, limit, start_line, count_newlines, backslash_newlines_p,\n   return bp;\n }\n \n-/* Place into DST a quoted string representing the string SRC.  */\n-static void\n+/* Place into DST a quoted string representing the string SRC.\n+   Return the address of DST's terminating null.  */\n+static char *\n quote_string (dst, src)\n      char *dst, *src;\n {\n-  char c;\n+  U_CHAR c;\n \n-  for (*dst++ = '\\\"'; ; *dst++ = c)\n+  *dst++ = '\\\"';\n+  for (;;)\n     switch ((c = *src++))\n       {\n-      case '\\n':\n-\tc = 'n';\n-\t/* fall through */\n+      default:\n+        if (isprint (c))\n+\t  *dst++ = c;\n+\telse\n+\t  {\n+\t    sprintf (dst, \"\\\\%03o\", c);\n+\t    dst += 4;\n+\t  }\n+\tbreak;\n+\n       case '\\\"':\n       case '\\\\':\n \t*dst++ = '\\\\';\n+\t*dst++ = c;\n \tbreak;\n       \n       case '\\0':\n \t*dst++ = '\\\"';\n \t*dst = '\\0';\n-\treturn;\n+\treturn dst;\n       }\n }\n \n@@ -6999,7 +7030,7 @@ output_line_command (ip, op, conditional, file_change)\n      enum file_change_code file_change;\n {\n   int len;\n-  char *line_cmd_buf;\n+  char *line_cmd_buf, *line_end;\n \n   if (no_line_commands\n       || ip->fname == NULL\n@@ -7031,19 +7062,25 @@ output_line_command (ip, op, conditional, file_change)\n     ip->bufp++;\n   }\n \n-  line_cmd_buf = (char *) alloca (strlen (ip->nominal_fname) + 100);\n+  line_cmd_buf = (char *) alloca (4 * strlen (ip->nominal_fname) + 100);\n #ifdef OUTPUT_LINE_COMMANDS\n-  sprintf (line_cmd_buf, \"#line %d \\\"%s\\\"\", ip->lineno, ip->nominal_fname);\n+  sprintf (line_cmd_buf, \"#line %d \", ip->lineno);\n #else\n-  sprintf (line_cmd_buf, \"# %d \\\"%s\\\"\", ip->lineno, ip->nominal_fname);\n+  sprintf (line_cmd_buf, \"# %d \", ip->lineno);\n #endif\n-  if (file_change != same_file)\n-    strcat (line_cmd_buf, file_change == enter_file ? \" 1\" : \" 2\");\n+  line_end = quote_string (line_cmd_buf + strlen (line_cmd_buf),\n+\t\t\t   ip->nominal_fname);\n+  if (file_change != same_file) {\n+    *line_end++ = ' ';\n+    *line_end++ = file_change == enter_file ? '1' : '2';\n+  }\n   /* Tell cc1 if following text comes from a system header file.  */\n-  if (ip->system_header_p)\n-    strcat (line_cmd_buf, \" 3\");\n-  len = strlen (line_cmd_buf);\n-  line_cmd_buf[len++] = '\\n';\n+  if (ip->system_header_p) {\n+    *line_end++ = ' ';\n+    *line_end++ = '3';\n+  }\n+  *line_end++ = '\\n';\n+  len = line_end - line_cmd_buf;\n   check_expand (op, len + 1);\n   if (op->bufp > op->buf && op->bufp[-1] != '\\n')\n     *op->bufp++ = '\\n';"}]}