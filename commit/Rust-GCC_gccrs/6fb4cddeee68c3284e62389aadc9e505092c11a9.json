{"sha": "6fb4cddeee68c3284e62389aadc9e505092c11a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZiNGNkZGVlZTY4YzMyODRlNjIzODlhYWRjOWU1MDUwOTJjMTFhOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-20T13:06:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-20T13:06:01Z"}, "message": "[multiple changes]\n\n2009-07-20  Robert Dewar  <dewar@adacore.com>\n\n\t* vms_data.ads: Minor reformatting\n\n\t* einfo.ads, einfo.adb (Parent_Subtype): Now allowed on record subtype,\n\tapplies to base type.\n\t(Parent_Subtype): Now allowed on record subtype, applies to base type\n\t* exp_ch5.adb (Expand_Assign_Record): Handle Componentwise_Assignment\n\tfor case of fully repped tagged type.\n\t(Make_Tag_Ctrl_Assignment): Set Componentwise_Assignment and avoid\n\ttag save/restore for fully repped tagged type case.\n\t* exp_util.ads, exp_util.adb (Is_Fully_Repped_Tagged_Type): New function\n\t* fe.h (Is_Fully_Repped_Tagged_Type): New function\n\t* sem_ch13.adb (Analyze_Recorrd_Representation_Clause): Check for\n\toverlap of tagged type components with parent type if parent type is\n\tfully repped.\n\t* sinfo.ads, sinfo.adb (Componentwise_Assignment): New flag\n\n\t* sem_res.adb (Check_No_Direct_Boolean_Operators): Remove handling of\n\tcomparisons.\n\t(Resolve_Comparison_Operators): Remove No_Direct_Boolean_Operators check\n\t(Resolve_Equality_Op): Remove No_Direct_Boolean_Operators check\n\n\t* gnat_rm.texi: Restriction No_Direct_Boolean_Operators includes only\n\tlogical operators (AND/OR/XOR), not comparison operators.\n\n\t* sprint.ads: Minor reformatting\n\n2009-07-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_intr.adb (Check_Intrinsic_Call): For Import_Value and related\n\tintrinsics, check that argument is a string literal, rather than\n\tchecking for staticness.\n\nFrom-SVN: r149811", "tree": {"sha": "d18d20b93c356cb855681e19f4cae6b09a57c073", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d18d20b93c356cb855681e19f4cae6b09a57c073"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fb4cddeee68c3284e62389aadc9e505092c11a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fb4cddeee68c3284e62389aadc9e505092c11a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fb4cddeee68c3284e62389aadc9e505092c11a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fb4cddeee68c3284e62389aadc9e505092c11a9/comments", "author": null, "committer": null, "parents": [{"sha": "ae65d635df87446453628c005cacf2ed3850b9c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae65d635df87446453628c005cacf2ed3850b9c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae65d635df87446453628c005cacf2ed3850b9c6"}], "stats": {"total": 465, "additions": 345, "deletions": 120}, "files": [{"sha": "6283b245d84381133b6a49e9e1f8b48aa30516be", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6fb4cddeee68c3284e62389aadc9e505092c11a9", "patch": "@@ -1,3 +1,37 @@\n+2009-07-20  Robert Dewar  <dewar@adacore.com>\n+\n+\t* vms_data.ads: Minor reformatting\n+\n+\t* einfo.ads, einfo.adb (Parent_Subtype): Now allowed on record subtype,\n+\tapplies to base type.\n+\t(Parent_Subtype): Now allowed on record subtype, applies to base type\n+\t* exp_ch5.adb (Expand_Assign_Record): Handle Componentwise_Assignment\n+\tfor case of fully repped tagged type.\n+\t(Make_Tag_Ctrl_Assignment): Set Componentwise_Assignment and avoid\n+\ttag save/restore for fully repped tagged type case.\n+\t* exp_util.ads, exp_util.adb (Is_Fully_Repped_Tagged_Type): New function\n+\t* fe.h (Is_Fully_Repped_Tagged_Type): New function\n+\t* sem_ch13.adb (Analyze_Recorrd_Representation_Clause): Check for\n+\toverlap of tagged type components with parent type if parent type is\n+\tfully repped.\n+\t* sinfo.ads, sinfo.adb (Componentwise_Assignment): New flag\n+\n+\t* sem_res.adb (Check_No_Direct_Boolean_Operators): Remove handling of\n+\tcomparisons.\n+\t(Resolve_Comparison_Operators): Remove No_Direct_Boolean_Operators check\n+\t(Resolve_Equality_Op): Remove No_Direct_Boolean_Operators check\n+\n+\t* gnat_rm.texi: Restriction No_Direct_Boolean_Operators includes only\n+\tlogical operators (AND/OR/XOR), not comparison operators.\n+\n+\t* sprint.ads: Minor reformatting\n+\n+2009-07-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_intr.adb (Check_Intrinsic_Call): For Import_Value and related\n+\tintrinsics, check that argument is a string literal, rather than\n+\tchecking for staticness.\n+\n 2009-07-20  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch13.adb: Minor reformatting"}, {"sha": "170f4f043ef90ee9a88ac1cadc6b0020c01f1362", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=6fb4cddeee68c3284e62389aadc9e505092c11a9", "patch": "@@ -2365,8 +2365,8 @@ package body Einfo is\n \n    function Parent_Subtype (Id : E) return E is\n    begin\n-      pragma Assert (Ekind (Id) = E_Record_Type);\n-      return Node19 (Id);\n+      pragma Assert (Is_Record_Type (Id));\n+      return Node19 (Base_Type (Id));\n    end Parent_Subtype;\n \n    function Postcondition_Proc (Id : E) return E is"}, {"sha": "150f18dd82b50afbcac117332f0ac5c290e9d30f", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=6fb4cddeee68c3284e62389aadc9e505092c11a9", "patch": "@@ -3106,9 +3106,10 @@ package Einfo is\n --       used when obtaining the formal kind of a formal parameter (the result\n --       is one of E_[In/Out/In_Out]_Parameter)\n \n---    Parent_Subtype (Node19)\n---       Present in E_Record_Type. Points to the subtype to use for a field\n---       that references the parent record.\n+--    Parent_Subtype (Node19) [base type only]\n+--       Present in E_Record_Type. Set only for derived tagged types, in which\n+--       case it points to the subtype of the parent type. This is the type\n+--       that is used as the Etype of the _parent field.\n \n --    Postcondition_Proc (Node8)\n --       Present only in procedure entities, saves the entity of the generated\n@@ -5264,7 +5265,7 @@ package Einfo is\n    --    Cloned_Subtype                      (Node16)   (subtype case only)\n    --    First_Entity                        (Node17)\n    --    Corresponding_Concurrent_Type       (Node18)\n-   --    Parent_Subtype                      (Node19)\n+   --    Parent_Subtype                      (Node19)   (base type only)\n    --    Last_Entity                         (Node20)\n    --    Discriminant_Constraint             (Elist21)\n    --    Corresponding_Remote_Type           (Node22)"}, {"sha": "29095c8c083b98fd61a32fe1e4ddc35f78497d9c", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 101, "deletions": 48, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=6fb4cddeee68c3284e62389aadc9e505092c11a9", "patch": "@@ -101,7 +101,9 @@ package body Exp_Ch5 is\n    --  N is an assignment of a non-tagged record value. This routine handles\n    --  the case where the assignment must be made component by component,\n    --  either because the target is not byte aligned, or there is a change\n-   --  of representation.\n+   --  of representation, or when we have a tagged type with a representation\n+   --  clause (this last case is required because holes in the tagged type\n+   --  might be filled with components from child types).\n \n    procedure Expand_Non_Function_Return (N : Node_Id);\n    --  Called by Expand_N_Simple_Return_Statement in case we're returning from\n@@ -114,11 +116,11 @@ package body Exp_Ch5 is\n    --  from a function body this is called by Expand_N_Simple_Return_Statement.\n \n    function Make_Tag_Ctrl_Assignment (N : Node_Id) return List_Id;\n-   --  Generate the necessary code for controlled and tagged assignment,\n-   --  that is to say, finalization of the target before, adjustment of\n-   --  the target after and save and restore of the tag and finalization\n-   --  pointers which are not 'part of the value' and must not be changed\n-   --  upon assignment. N is the original Assignment node.\n+   --  Generate the necessary code for controlled and tagged assignment, that\n+   --  is to say, finalization of the target before, adjustment of the target\n+   --  after and save and restore of the tag and finalization pointers which\n+   --  are not 'part of the value' and must not be changed upon assignment. N\n+   --  is the original Assignment node.\n \n    ------------------------------\n    -- Change_Of_Representation --\n@@ -1128,13 +1130,10 @@ package body Exp_Ch5 is\n    -- Expand_Assign_Record --\n    --------------------------\n \n-   --  The only processing required is in the change of representation case,\n-   --  where we must expand the assignment to a series of field by field\n-   --  assignments.\n-\n    procedure Expand_Assign_Record (N : Node_Id) is\n-      Lhs : constant Node_Id := Name (N);\n-      Rhs : Node_Id          := Expression (N);\n+      Lhs   : constant Node_Id    := Name (N);\n+      Rhs   : Node_Id             := Expression (N);\n+      L_Typ : constant Entity_Id  := Base_Type (Etype (Lhs));\n \n    begin\n       --  If change of representation, then extract the real right hand side\n@@ -1156,6 +1155,14 @@ package body Exp_Ch5 is\n       then\n          null;\n \n+      --  If we have a tagged type that has a complete record representation\n+      --  clause, we must do we must do component-wise assignments, since child\n+      --  types may have used gaps for their components, and we might be\n+      --  dealing with a view conversion.\n+\n+      elsif Is_Fully_Repped_Tagged_Type (L_Typ) then\n+         null;\n+\n       --  If neither condition met, then nothing special to do, the back end\n       --  can handle assignment of the entire component as a single entity.\n \n@@ -1168,7 +1175,6 @@ package body Exp_Ch5 is\n       declare\n          Loc   : constant Source_Ptr := Sloc (N);\n          R_Typ : constant Entity_Id  := Base_Type (Etype (Rhs));\n-         L_Typ : constant Entity_Id  := Base_Type (Etype (Lhs));\n          Decl  : constant Node_Id    := Declaration_Node (R_Typ);\n          RDef  : Node_Id;\n          F     : Entity_Id;\n@@ -1214,11 +1220,11 @@ package body Exp_Ch5 is\n \n          begin\n             C := First_Entity (Utyp);\n-\n             while Present (C) loop\n                if Chars (C) = Chars (Comp) then\n                   return C;\n                end if;\n+\n                Next_Entity (C);\n             end loop;\n \n@@ -1247,11 +1253,9 @@ package body Exp_Ch5 is\n             Result := Make_Field_Assigns (CI);\n \n             if Present (VP) then\n-\n                V := First_Non_Pragma (Variants (VP));\n                Alts := New_List;\n                while Present (V) loop\n-\n                   DCH := New_List;\n                   DC := First (Discrete_Choices (V));\n                   while Present (DC) loop\n@@ -1334,6 +1338,14 @@ package body Exp_Ch5 is\n             --  Set Assignment_OK, so discriminants can be assigned\n \n             Set_Assignment_OK (Name (A), True);\n+\n+            if Componentwise_Assignment (N)\n+              and then Nkind (Name (A)) = N_Selected_Component\n+              and then Chars (Selector_Name (Name (A))) = Name_uParent\n+            then\n+               Set_Componentwise_Assignment (A);\n+            end if;\n+\n             return A;\n          end Make_Field_Assign;\n \n@@ -1349,7 +1361,14 @@ package body Exp_Ch5 is\n             Item := First (CI);\n             Result := New_List;\n             while Present (Item) loop\n-               if Nkind (Item) = N_Component_Declaration then\n+\n+               --  Look for components, but exclude _tag field assignment if\n+               --  the special Componentwise_Assignment flag is set.\n+\n+               if Nkind (Item) = N_Component_Declaration\n+                 and then not (Is_Tag (Defining_Identifier (Item))\n+                                and then Componentwise_Assignment (N))\n+               then\n                   Append_To\n                     (Result, Make_Field_Assign (Defining_Identifier (Item)));\n                end if;\n@@ -1408,18 +1427,22 @@ package body Exp_Ch5 is\n          --  We know the underlying type is a record, but its current view\n          --  may be private. We must retrieve the usable record declaration.\n \n-         if Nkind (Decl) = N_Private_Type_Declaration\n+         if Nkind_In (Decl, N_Private_Type_Declaration,\n+                            N_Private_Extension_Declaration)\n            and then Present (Full_View (R_Typ))\n          then\n             RDef := Type_Definition (Declaration_Node (Full_View (R_Typ)));\n          else\n             RDef := Type_Definition (Decl);\n          end if;\n \n+         if Nkind (RDef) = N_Derived_Type_Definition then\n+            RDef := Record_Extension_Part (RDef);\n+         end if;\n+\n          if Nkind (RDef) = N_Record_Definition\n            and then Present (Component_List (RDef))\n          then\n-\n             if Is_Unchecked_Union (R_Typ) then\n                Insert_Actions (N,\n                  Make_Component_List_Assign (Component_List (RDef), True));\n@@ -1430,7 +1453,6 @@ package body Exp_Ch5 is\n \n             Rewrite (N, Make_Null_Statement (Loc));\n          end if;\n-\n       end;\n    end Expand_Assign_Record;\n \n@@ -1449,6 +1471,18 @@ package body Exp_Ch5 is\n       Exp  : Node_Id;\n \n    begin\n+      --  Special case to check right away, if the Componentwise_Assignment\n+      --  flag is set, this is a reanalysis from the expansion of the primitive\n+      --  assignment procedure for a tagged type, and all we need to do is to\n+      --  expand to assignment of components, because otherwise, we would get\n+      --  infinite recursion (since this looks like a tagged assignment which\n+      --  would normally try to *call* the primitive assignment procedure).\n+\n+      if Componentwise_Assignment (N) then\n+         Expand_Assign_Record (N);\n+         return;\n+      end if;\n+\n       --  Ada 2005 (AI-327): Handle assignment to priority of protected object\n \n       --  Rewrite an assignment to X'Priority into a run-time call\n@@ -1812,10 +1846,9 @@ package body Exp_Ch5 is\n             Expand_Ctrl_Actions : constant Boolean := not No_Ctrl_Actions (N);\n \n          begin\n-            --  In the controlled case, we need to make sure that function\n-            --  calls are evaluated before finalizing the target. In all cases,\n-            --  it makes the expansion easier if the side-effects are removed\n-            --  first.\n+            --  In the controlled case, we ensure that function calls are\n+            --  evaluated before finalizing the target. In all cases, it makes\n+            --  the expansion easier if the side-effects are removed first.\n \n             Remove_Side_Effects (Lhs);\n             Remove_Side_Effects (Rhs);\n@@ -1842,15 +1875,14 @@ package body Exp_Ch5 is\n                --  is set True in this case).\n \n                or else (Is_Tagged_Type (Typ)\n-                          and then not Is_Value_Type (Etype (Lhs))\n-                          and then Chars (Current_Scope) /= Name_uAssign\n-                          and then Expand_Ctrl_Actions\n-                          and then not Discriminant_Checks_Suppressed (Empty))\n+                         and then not Is_Value_Type (Etype (Lhs))\n+                         and then Chars (Current_Scope) /= Name_uAssign\n+                         and then Expand_Ctrl_Actions\n+                         and then not Discriminant_Checks_Suppressed (Empty))\n             then\n                --  Fetch the primitive op _assign and proper type to call it.\n-               --  Because of possible conflicts between private and full view\n-               --  the proper type is fetched directly from the operation\n-               --  profile.\n+               --  Because of possible conflicts between private and full view,\n+               --  fetch the proper type directly from the operation profile.\n \n                declare\n                   Op    : constant Entity_Id :=\n@@ -4304,7 +4336,11 @@ package body Exp_Ch5 is\n       Ctrl_Act : constant Boolean := Needs_Finalization (T)\n                                        and then not No_Ctrl_Actions (N);\n \n+      Component_Assign : constant Boolean :=\n+                           Is_Fully_Repped_Tagged_Type (T);\n+\n       Save_Tag : constant Boolean := Is_Tagged_Type (T)\n+                                       and then not Component_Assign\n                                        and then not No_Ctrl_Actions (N)\n                                        and then Tagged_Type_Expansion;\n       --  Tags are not saved and restored when VM_Target because VM tags are\n@@ -4320,11 +4356,12 @@ package body Exp_Ch5 is\n    begin\n       Res := New_List;\n \n-      --  Finalize the target of the assignment when controlled.\n+      --  Finalize the target of the assignment when controlled\n+\n       --  We have two exceptions here:\n \n-      --   1. If we are in an init proc since it is an initialization\n-      --      more than an assignment\n+      --   1. If we are in an init proc since it is an initialization more\n+      --      than an assignment.\n \n       --   2. If the left-hand side is a temporary that was not initialized\n       --      (or the parent part of a temporary since it is the case in\n@@ -4342,18 +4379,18 @@ package body Exp_Ch5 is\n \n       elsif Nkind (L) = N_Type_Conversion\n         and then Is_Entity_Name (Expression (L))\n-        and then Nkind (Parent (Entity (Expression (L))))\n-                   = N_Object_Declaration\n+        and then Nkind (Parent (Entity (Expression (L)))) =\n+                                              N_Object_Declaration\n         and then No_Initialization (Parent (Entity (Expression (L))))\n       then\n          null;\n \n       else\n          Append_List_To (Res,\n-           Make_Final_Call (\n-             Ref         => Duplicate_Subexpr_No_Checks (L),\n-             Typ         => Etype (L),\n-             With_Detach => New_Reference_To (Standard_False, Loc)));\n+           Make_Final_Call\n+             (Ref         => Duplicate_Subexpr_No_Checks (L),\n+              Typ         => Etype (L),\n+              With_Detach => New_Reference_To (Standard_False, Loc)));\n       end if;\n \n       --  Save the Tag in a local variable Tag_Tmp\n@@ -4628,8 +4665,7 @@ package body Exp_Ch5 is\n \n                First_After_Root := Make_Integer_Literal (Loc, 1);\n \n-               --  For the case of a controlled object, skip the\n-               --  Root_Controlled part.\n+               --  For controlled object, skip Root_Controlled part\n \n                if Is_Controlled (T) then\n                   First_After_Root :=\n@@ -4644,9 +4680,8 @@ package body Exp_Ch5 is\n                end if;\n \n                --  For the case of a record with controlled components, skip\n-               --  the Prev and Next components of the record controller.\n-               --  These components constitute a 'hole' in the middle of the\n-               --  data to be copied.\n+               --  record controller Prev/Next components. These components\n+               --  constitute a 'hole' in the middle of the data to be copied.\n \n                if Has_Controlled_Component (T) then\n                   Prev_Ref :=\n@@ -4658,8 +4693,8 @@ package body Exp_Ch5 is\n                             New_Reference_To (Controller_Component (T), Loc)),\n                       Selector_Name =>  Make_Identifier (Loc, Name_Prev));\n \n-                  --  Last index before hole: determined by position of\n-                  --  the _Controller.Prev component.\n+                  --  Last index before hole: determined by position of the\n+                  --  _Controller.Prev component.\n \n                   Last_Before_Hole :=\n                     Make_Defining_Identifier (Loc,\n@@ -4755,8 +4790,26 @@ package body Exp_Ch5 is\n             end Controlled_Actions;\n          end if;\n \n+      --  Not controlled case\n+\n       else\n-         Append_To (Res, Relocate_Node (N));\n+         declare\n+            Asn : constant Node_Id := Relocate_Node (N);\n+\n+         begin\n+            --  If this is the case of a tagged type with a full rep clause,\n+            --  we must expand it into component assignments, so we mark the\n+            --  node as unanalyzed, to get it reanalyzed, but flag it has\n+            --  requiring component-wise assignment so we don't get infinite\n+            --  recursion.\n+\n+            if Component_Assign then\n+               Set_Analyzed (Asn, False);\n+               Set_Componentwise_Assignment (Asn, True);\n+            end if;\n+\n+            Append_To (Res, Asn);\n+         end;\n       end if;\n \n       --  Restore the tag"}, {"sha": "d139a2bc3212b8e437fcf9a35588334c866dacff", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=6fb4cddeee68c3284e62389aadc9e505092c11a9", "patch": "@@ -914,6 +914,7 @@ package body Exp_Util is\n \n    function Component_May_Be_Bit_Aligned (Comp : Entity_Id) return Boolean is\n       UT : constant Entity_Id := Underlying_Type (Etype (Comp));\n+\n    begin\n       --  If no component clause, then everything is fine, since the back end\n       --  never bit-misaligns by default, even if there is a pragma Packed for\n@@ -930,9 +931,9 @@ package body Exp_Util is\n       then\n          return False;\n \n-      --  If we know that we have a small (64 bits or less) record\n-      --  or bit-packed array, then everything is fine, since the\n-      --  back end can handle these cases correctly.\n+      --  If we know that we have a small (64 bits or less) record or small\n+      --  bit-packed array, then everything is fine, since the back end can\n+      --  handle these cases correctly.\n \n       elsif Esize (Comp) <= 64\n         and then (Is_Record_Type (UT)\n@@ -2939,6 +2940,43 @@ package body Exp_Util is\n       return True;\n    end Is_All_Null_Statements;\n \n+   ---------------------------------\n+   -- Is_Fully_Repped_Tagged_Type --\n+   ---------------------------------\n+\n+   function Is_Fully_Repped_Tagged_Type (T : Entity_Id) return Boolean is\n+      U    : constant Entity_Id := Underlying_Type (T);\n+      Comp : Entity_Id;\n+\n+   begin\n+      if No (U) or else not Is_Tagged_Type (U) then\n+         return False;\n+      elsif Has_Discriminants (U) then\n+         return False;\n+      elsif not Has_Specified_Layout (U) then\n+         return False;\n+      end if;\n+\n+      --  Here we have a tagged type, see if it has any unlayed out fields\n+      --  other than a possible tag and parent fields. If so, we return False.\n+\n+      Comp := First_Component (U);\n+      while Present (Comp) loop\n+         if not Is_Tag (Comp)\n+           and then Chars (Comp) /= Name_uParent\n+           and then No (Component_Clause (Comp))\n+         then\n+            return False;\n+         else\n+            Next_Component (Comp);\n+         end if;\n+      end loop;\n+\n+      --  All components are layed out\n+\n+      return True;\n+   end Is_Fully_Repped_Tagged_Type;\n+\n    ----------------------------------\n    -- Is_Library_Level_Tagged_Type --\n    ----------------------------------\n@@ -3303,16 +3341,11 @@ package body Exp_Util is\n    function Is_Renamed_Object (N : Node_Id) return Boolean is\n       Pnod : constant Node_Id   := Parent (N);\n       Kind : constant Node_Kind := Nkind (Pnod);\n-\n    begin\n       if Kind = N_Object_Renaming_Declaration then\n          return True;\n-\n-      elsif Kind = N_Indexed_Component\n-        or else Kind = N_Selected_Component\n-      then\n+      elsif Nkind_In (Kind, N_Indexed_Component, N_Selected_Component) then\n          return Is_Renamed_Object (Pnod);\n-\n       else\n          return False;\n       end if;\n@@ -3623,8 +3656,8 @@ package body Exp_Util is\n    -- Make_CW_Equivalent_Type --\n    -----------------------------\n \n-   --  Create a record type used as an equivalent of any member\n-   --  of the class which takes its size from exp.\n+   --  Create a record type used as an equivalent of any member of the class\n+   --  which takes its size from exp.\n \n    --  Generate the following code:\n \n@@ -3671,6 +3704,7 @@ package body Exp_Util is\n       Range_Type := Make_Defining_Identifier (Loc, New_Internal_Name ('G'));\n \n       if not Is_Interface (Root_Typ) then\n+\n          --  subtype rg__xx is\n          --    Storage_Offset range 1 .. (Expr'size - typ'size) / Storage_Unit\n "}, {"sha": "1f3c9e8a2117bf75b57c9ba249a4e9e45afc3b9f", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=6fb4cddeee68c3284e62389aadc9e505092c11a9", "patch": "@@ -466,6 +466,15 @@ package Exp_Util is\n    --  False otherwise. True for an empty list. It is an error to call this\n    --  routine with No_List as the argument.\n \n+   function Is_Fully_Repped_Tagged_Type (T : Entity_Id) return Boolean;\n+   --  Tests given type T, and returns True if T is a non-discriminated tagged\n+   --  type which has a record representation clause that specifies the layout\n+   --  of all the components, including recursively components in all parent\n+   --  types. We exclude discriminated types for convenience, it is extremely\n+   --  unlikely that the special processing associated with the use of this\n+   --  routine is useful for the case of a discriminated type, and testing for\n+   --  component overlap would be a pain.\n+\n    function Is_Library_Level_Tagged_Type (Typ : Entity_Id) return Boolean;\n    --  Return True if Typ is a library level tagged type. Currently we use\n    --  this information to build statically allocated dispatch tables."}, {"sha": "79468ff538ecd46994db71155a76ce1f5cf84d03", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=6fb4cddeee68c3284e62389aadc9e505092c11a9", "patch": "@@ -142,6 +142,12 @@ extern void Get_Encoded_Name\t\t\t(Entity_Id);\n extern void Get_External_Name\t\t\t(Entity_Id, Boolean);\n extern void Get_External_Name_With_Suffix\t(Entity_Id, Fat_Pointer);\n \n+/* exp_util: */\n+\n+#define Is_Fully_Repped_Tagged_Type exp_util__is_fully_repped_tagged_type\n+\n+extern Boolean Is_Fully_Repped_Tagged_Type      (Entity_Id);\n+\n /* lib: */\n \n #define Cunit \t\t\t\tlib__cunit"}, {"sha": "a17d45471c98297bdf98bfc599b439c49c1d786e", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=6fb4cddeee68c3284e62389aadc9e505092c11a9", "patch": "@@ -8445,13 +8445,11 @@ without a specific initializer (including the case of OUT scalar parameters).\n \n @item No_Direct_Boolean_Operators\n @findex No_Direct_Boolean_Operators\n-This restriction ensures that no logical (and/or/xor) or comparison\n-operators are used on operands of type Boolean (or any type derived\n+This restriction ensures that no logical (and/or/xor) are used on\n+operands of type Boolean (or any type derived\n from Boolean). This is intended for use in safety critical programs\n where the certification protocol requires the use of short-circuit\n-(and then, or else) forms for all composite boolean operations. An\n-exception is that an explicit equality test with True or False as the\n-right operand is not considered to violate this restriction.\n+(and then, or else) forms for all composite boolean operations.\n \n @item No_Dispatching_Calls\n @findex No_Dispatching_Calls"}, {"sha": "ef778a2ced377272111e7caa12b8a9f94c8a870e", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=6fb4cddeee68c3284e62389aadc9e505092c11a9", "patch": "@@ -2191,13 +2191,27 @@ package body Sem_Ch13 is\n       Hbit    : Uint := Uint_0;\n       Comp    : Entity_Id;\n       Ocomp   : Entity_Id;\n+      Pcomp   : Entity_Id;\n       Biased  : Boolean;\n \n       Max_Bit_So_Far : Uint;\n       --  Records the maximum bit position so far. If all field positions\n       --  are monotonically increasing, then we can skip the circuit for\n       --  checking for overlap, since no overlap is possible.\n \n+      Tagged_Parent : Entity_Id := Empty;\n+      --  This is set in the case of a derived tagged type for which we have\n+      --  Is_Fully_Repped_Tagged_Type True (indicating that all components are\n+      --  positioned by record representation clauses). In this case we must\n+      --  check for overlap between components of this tagged type, and the\n+      --  components of its parent. Tagged_Parent will point to this parent\n+      --  type. For all other cases Tagged_Parent is left set to Empty.\n+\n+      Parent_Last_Bit : Uint;\n+      --  Relevant only if Tagged_Parent is set, Parent_Last_Bit indicates the\n+      --  last bit position for any field in the parent type. We only need to\n+      --  check overlap for fields starting below this point.\n+\n       Overlap_Check_Required : Boolean;\n       --  Used to keep track of whether or not an overlap check is required\n \n@@ -2319,6 +2333,39 @@ package body Sem_Ch13 is\n          end loop;\n       end if;\n \n+      --  See if we have a fully repped derived tagged type\n+\n+      declare\n+         PS : constant Entity_Id := Parent_Subtype (Rectype);\n+\n+      begin\n+         if Present (PS) and then Is_Fully_Repped_Tagged_Type (PS) then\n+            Tagged_Parent := PS;\n+\n+            --  Find maximum bit of any component of the parent type\n+\n+            Parent_Last_Bit := UI_From_Int (System_Address_Size - 1);\n+            Pcomp := First_Entity (Tagged_Parent);\n+            while Present (Pcomp) loop\n+               if Ekind (Pcomp) = E_Discriminant\n+                    or else\n+                  Ekind (Pcomp) = E_Component\n+               then\n+                  if Component_Bit_Offset (Pcomp) /= No_Uint\n+                    and then Known_Static_Esize (Pcomp)\n+                  then\n+                     Parent_Last_Bit :=\n+                       UI_Max\n+                         (Parent_Last_Bit,\n+                          Component_Bit_Offset (Pcomp) + Esize (Pcomp) - 1);\n+                  end if;\n+\n+                  Next_Entity (Pcomp);\n+               end if;\n+            end loop;\n+         end if;\n+      end;\n+\n       --  All done if no component clauses\n \n       CC := First (Component_Clauses (N));\n@@ -2483,6 +2530,9 @@ package body Sem_Ch13 is\n                         end;\n                      end if;\n \n+                  --  Normal case where this is the first component clause we\n+                  --  have seen for this entity, so set it up properly.\n+\n                   else\n                      --  Make reference for field in record rep clause and set\n                      --  appropriate entity field in the field identifier.\n@@ -2523,7 +2573,7 @@ package body Sem_Ch13 is\n                         then\n                            Error_Msg_NE\n                              (\"component overlaps tag field of&\",\n-                              CC, Rectype);\n+                              Component_Name (CC), Rectype);\n                         end if;\n \n                         --  This information is also set in the corresponding\n@@ -2568,6 +2618,27 @@ package body Sem_Ch13 is\n                            Error_Msg_N (\"component size is negative\", CC);\n                         end if;\n                      end if;\n+\n+                     --  If OK component size, check parent type overlap if\n+                     --  this component might overlap a parent field.\n+\n+                     if Present (Tagged_Parent)\n+                       and Fbit <= Parent_Last_Bit\n+                     then\n+                        Pcomp := First_Entity (Tagged_Parent);\n+                        while Present (Pcomp) loop\n+                           if (Ekind (Pcomp) = E_Discriminant\n+                                or else\n+                               Ekind (Pcomp) = E_Component)\n+                             and then not Is_Tag (Pcomp)\n+                             and then Chars (Pcomp) /= Name_uParent\n+                           then\n+                              Check_Component_Overlap (Comp, Pcomp);\n+                           end if;\n+\n+                           Next_Entity (Pcomp);\n+                        end loop;\n+                     end if;\n                   end if;\n                end if;\n             end if;"}, {"sha": "42136b13ee8f5a7132de34cd00bb0e8209adcf5b", "filename": "gcc/ada/sem_intr.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fsem_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fsem_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_intr.adb?ref=6fb4cddeee68c3284e62389aadc9e505092c11a9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -102,7 +102,9 @@ package body Sem_Intr is\n       Arg1 : constant Node_Id   := First_Actual (N);\n \n    begin\n-      --  For Import_xxx calls, argument must be static string\n+      --  For Import_xxx calls, argument must be static string. A string\n+      --  literal is legal even in Ada83 mode, where such literals are\n+      --  not static.\n \n       if Cnam = Name_Import_Address\n            or else\n@@ -115,7 +117,9 @@ package body Sem_Intr is\n          then\n             null;\n \n-         elsif not Is_Static_Expression (Arg1) then\n+         elsif Nkind (Arg1) /= N_String_Literal\n+           and then not Is_Static_Expression (Arg1)\n+         then\n             Error_Msg_FE\n               (\"call to & requires static string argument!\", N, Nam);\n             Why_Not_Static (Arg1);"}, {"sha": "372750b1b47ca5b2c33f66801f8cc9b60a08046b", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=6fb4cddeee68c3284e62389aadc9e505092c11a9", "patch": "@@ -120,9 +120,9 @@ package body Sem_Res is\n    --  Could be optimized away perhaps?\n \n    procedure Check_No_Direct_Boolean_Operators (N : Node_Id);\n-   --  N is the node for a comparison or logical operator. If the operator\n-   --  is predefined, and the root type of the operands is Standard.Boolean,\n-   --  then a check is made for restriction No_Direct_Boolean_Operators.\n+   --  N is the node for a logical operator. If the operator is predefined, and\n+   --  the root type of the operands is Standard.Boolean, then a check is made\n+   --  for restriction No_Direct_Boolean_Operators.\n \n    function Is_Definite_Access_Type (E : Entity_Id) return Boolean;\n    --  Determine whether E is an access type declared by an access\n@@ -941,24 +941,9 @@ package body Sem_Res is\n       if Scope (Entity (N)) = Standard_Standard\n         and then Root_Type (Etype (Left_Opnd (N))) = Standard_Boolean\n       then\n-         --  Restriction does not apply to generated code\n+         --  Restriction only applies to original source code\n \n-         if not Comes_From_Source (N) then\n-            null;\n-\n-         --  Restriction does not apply for A=False, A=True\n-\n-         elsif Nkind (N) = N_Op_Eq\n-           and then (Is_Entity_Name (Right_Opnd (N))\n-                      and then (Entity (Right_Opnd (N)) = Standard_True\n-                                 or else\n-                                Entity (Right_Opnd (N)) = Standard_False))\n-         then\n-            null;\n-\n-         --  Otherwise restriction applies\n-\n-         else\n+         if Comes_From_Source (N) then\n             Check_Restriction (No_Direct_Boolean_Operators, N);\n          end if;\n       end if;\n@@ -5478,8 +5463,6 @@ package body Sem_Res is\n       T : Entity_Id;\n \n    begin\n-      Check_No_Direct_Boolean_Operators (N);\n-\n       --  If this is an intrinsic operation which is not predefined, use the\n       --  types of its declared arguments to resolve the possibly overloaded\n       --  operands. Otherwise the operands are unambiguous and specify the\n@@ -6224,8 +6207,6 @@ package body Sem_Res is\n    --  Start of processing for Resolve_Equality_Op\n \n    begin\n-      Check_No_Direct_Boolean_Operators (N);\n-\n       Set_Etype (N, Base_Type (Typ));\n       Generate_Reference (T, N, ' ');\n "}, {"sha": "da6adb20072a84f943a6f6d3246c225171134c4c", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=6fb4cddeee68c3284e62389aadc9e505092c11a9", "patch": "@@ -464,6 +464,14 @@ package body Sinfo is\n       return Node1 (N);\n    end Component_Name;\n \n+   function Componentwise_Assignment\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Assignment_Statement);\n+      return Flag14 (N);\n+   end Componentwise_Assignment;\n+\n    function Condition\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -3271,6 +3279,14 @@ package body Sinfo is\n       Set_Node1_With_Parent (N, Val);\n    end Set_Component_Name;\n \n+   procedure Set_Componentwise_Assignment\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Assignment_Statement);\n+      Set_Flag14 (N, Val);\n+   end Set_Componentwise_Assignment;\n+\n    procedure Set_Condition\n       (N : Node_Id; Val : Node_Id) is\n    begin"}, {"sha": "737f7b66bb30004960ff62e01035382b25b8edf2", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=6fb4cddeee68c3284e62389aadc9e505092c11a9", "patch": "@@ -679,6 +679,16 @@ package Sinfo is\n    --    Sem_Aggr for the specific conditions under which an aggregate has this\n    --    flag set. See also the flag Static_Processing_OK.\n \n+   --  Componentwise_Assignment (Flag14-Sem)\n+   --    Present in N_Assignment_Statement nodes. Set for a record assignment\n+   --    where all that needs doing is to expand it into component-by-component\n+   --    assignments. This is used internally for the case of tagged types with\n+   --    rep clauses, where we need to avoid recursion (we don't want to try to\n+   --    generate a call to the primitive operation, because this is the case\n+   --    where we are compiling the primitive operation). Note that when we are\n+   --    expanding component assignments in this case, we never assign the _tag\n+   --    field, but we recursively assign components of the parent type.\n+\n    --  Condition_Actions (List3-Sem)\n    --    This field appears in else-if nodes and in the iteration scheme node\n    --    for while loops. This field is only used during semantic processing to\n@@ -3861,6 +3871,7 @@ package Sinfo is\n       --  Forwards_OK (Flag5-Sem)\n       --  Backwards_OK (Flag6-Sem)\n       --  No_Ctrl_Actions (Flag7-Sem)\n+      --  Componentwise_Assignment (Flag14-Sem)\n \n       --  Note: if a range check is required, then the Do_Range_Check flag\n       --  is set in the Expression (right hand side), with the check being\n@@ -7643,6 +7654,9 @@ package Sinfo is\n    function Component_Name\n      (N : Node_Id) return Node_Id;    -- Node1\n \n+   function Componentwise_Assignment\n+     (N : Node_Id) return Boolean;    -- Flag14\n+\n    function Condition\n      (N : Node_Id) return Node_Id;    -- Node1\n \n@@ -8537,6 +8551,9 @@ package Sinfo is\n    procedure Set_Component_Name\n      (N : Node_Id; Val : Node_Id);            -- Node1\n \n+   procedure Set_Componentwise_Assignment\n+     (N : Node_Id; Val : Boolean := True);    -- Flag14\n+\n    procedure Set_Condition\n      (N : Node_Id; Val : Node_Id);            -- Node1\n \n@@ -10983,6 +11000,7 @@ package Sinfo is\n    pragma Inline (Component_Items);\n    pragma Inline (Component_List);\n    pragma Inline (Component_Name);\n+   pragma Inline (Componentwise_Assignment);\n    pragma Inline (Condition);\n    pragma Inline (Condition_Actions);\n    pragma Inline (Config_Pragmas);\n@@ -11278,6 +11296,7 @@ package Sinfo is\n    pragma Inline (Set_Component_Items);\n    pragma Inline (Set_Component_List);\n    pragma Inline (Set_Component_Name);\n+   pragma Inline (Set_Componentwise_Assignment);\n    pragma Inline (Set_Condition);\n    pragma Inline (Set_Condition_Actions);\n    pragma Inline (Set_Config_Pragmas);"}, {"sha": "59c371acbc3a77db69cc006666987ac9c5603a6b", "filename": "gcc/ada/sprint.ads", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fsprint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fsprint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.ads?ref=6fb4cddeee68c3284e62389aadc9e505092c11a9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -85,9 +85,9 @@ package Sprint is\n    --    Validate_Unchecked_Conversion       validate unchecked_conversion\n    --                                                  (src-type, target-typ);\n \n-   --  Note: the storage_pool parameters for allocators and the free node\n-   --  are omitted if the Storage_Pool field is Empty, indicating use of\n-   --  the standard default pool.\n+   --  Note: the storage_pool parameters for allocators and the free node are\n+   --  omitted if the Storage_Pool field is Empty, indicating use of the\n+   --  standard default pool.\n \n    -----------------\n    -- Subprograms --\n@@ -103,18 +103,18 @@ package Sprint is\n    --    -sz  print source from tree for package Standard\n \n    procedure Sprint_Comma_List (List : List_Id);\n-   --  Prints the nodes in a list, with separating commas. If the list\n-   --  is empty then no output is generated.\n+   --  Prints the nodes in a list, with separating commas. If the list is empty\n+   --  then no output is generated.\n \n    procedure Sprint_Paren_Comma_List (List : List_Id);\n-   --  Prints the nodes in a list, surrounded by parentheses, and separated\n-   --  by comas. If the list is empty, then no output is generated. A blank\n-   --  is output before the initial left parenthesis.\n+   --  Prints the nodes in a list, surrounded by parentheses, and separated by\n+   --  commas. If the list is empty, then no output is generated. A blank is\n+   --  output before the initial left parenthesis.\n \n    procedure Sprint_Opt_Paren_Comma_List (List : List_Id);\n-   --  Same as normal Sprint_Paren_Comma_List procedure, except that\n-   --  an extra blank is output if List is non-empty, and nothing at all is\n-   --  printed it the argument is No_List.\n+   --  Same as normal Sprint_Paren_Comma_List procedure, except that an extra\n+   --  blank is output if List is non-empty, and nothing at all is printed it\n+   --  the argument is No_List.\n \n    procedure Sprint_Node_List (List : List_Id);\n    --  Prints the nodes in a list with no separating characters. This is used\n@@ -126,9 +126,9 @@ package Sprint is\n    --  Like Sprint_Node_List, but prints nothing if List = No_List\n \n    procedure Sprint_Indented_List (List : List_Id);\n-   --  Like Sprint_Line_List, except that the indentation level is\n-   --  increased before outputting the list of items, and then decremented\n-   --  (back to its original level) before returning to the caller.\n+   --  Like Sprint_Line_List, except that the indentation level is increased\n+   --  before outputting the list of items, and then decremented (back to its\n+   --  original level) before returning to the caller.\n \n    procedure Sprint_Node (Node : Node_Id);\n    --  Prints a single node. No new lines are output, except as required for\n@@ -137,8 +137,8 @@ package Sprint is\n    --  blank characters are generated.\n \n    procedure Sprint_Opt_Node (Node : Node_Id);\n-   --  Same as normal Sprint_Node procedure, except that one leading\n-   --  blank is output before the node if it is non-empty.\n+   --  Same as normal Sprint_Node procedure, except that one leading blank is\n+   --  output before the node if it is non-empty.\n \n    procedure pg (Arg : Union_Id);\n    pragma Export (Ada, pg);"}, {"sha": "37e876e983ae651c99cd92cdfffe828c9f651719", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fb4cddeee68c3284e62389aadc9e505092c11a9/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=6fb4cddeee68c3284e62389aadc9e505092c11a9", "patch": "@@ -6561,8 +6561,7 @@ package VMS_Data is\n    --        /NONO_LOCAL_HEADER (D)\n    --        /NO_LOCAL_HEADER\n    --\n-   --  Do not put local comment header before body stub for a local progran\n-   --  unit\n+   --  Do not put local comment header before body stub for local program unit.\n \n    S_Stub_Output  : aliased constant S := \"/OUTPUT=@\"                      &\n                                             \"-o@\";\n@@ -6621,9 +6620,9 @@ package VMS_Data is\n    --      OVERWRITE (D)  Overwrite the existing tree file. If the current\n    --                     directory already contains the file which, according\n    --                     to the GNAT file naming rules should be considered\n-   --                     as a tree file for the argument source file,\n-   --                     gnatstub will refuse to create the tree file needed\n-   --                     to create a sample body unless this option is chosen.\n+   --                     as a tree file for the argument source file, gnatstub\n+   --                     will refuse to create the tree file needed to create\n+   --                     a sample body unless this option is chosen.\n    --\n    --      SAVE           Do not remove the tree file (i.e., the snapshot\n    --                     of the compiler internal structures used by gnatstub)"}]}