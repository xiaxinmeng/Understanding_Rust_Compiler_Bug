{"sha": "fe67cf58ffd46926ea2cd37267fd6b88244ac7ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU2N2NmNThmZmQ0NjkyNmVhMmNkMzcyNjdmZDZiODgyNDRhYzdlZQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-04-10T00:02:10Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-04-10T00:02:10Z"}, "message": "(free_tree_list): New variable.\n\n(digest_init): Set free_tree_list.\n(process_init_constructor): Use add_double to do arithmetic with\ndouble integers instead of using fold/build to to arithmetic in\ntype of array index.  Use free_tree_list when available instead of\ngenerating a new tree_list.\n\nFrom-SVN: r4074", "tree": {"sha": "61a5ab6e6295e084d6202bffe132e2b39a0504a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61a5ab6e6295e084d6202bffe132e2b39a0504a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe67cf58ffd46926ea2cd37267fd6b88244ac7ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe67cf58ffd46926ea2cd37267fd6b88244ac7ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe67cf58ffd46926ea2cd37267fd6b88244ac7ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe67cf58ffd46926ea2cd37267fd6b88244ac7ee/comments", "author": null, "committer": null, "parents": [{"sha": "78bdb6bcdf1e7d43468e1b819bf234153b1f5b29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78bdb6bcdf1e7d43468e1b819bf234153b1f5b29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78bdb6bcdf1e7d43468e1b819bf234153b1f5b29"}], "stats": {"total": 128, "additions": 103, "deletions": 25}, "files": [{"sha": "e6d46ed7d27abcb3ba1422f2d005baa2db4a2c2f", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 103, "deletions": 25, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe67cf58ffd46926ea2cd37267fd6b88244ac7ee/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe67cf58ffd46926ea2cd37267fd6b88244ac7ee/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=fe67cf58ffd46926ea2cd37267fd6b88244ac7ee", "patch": "@@ -4711,6 +4711,20 @@ pedwarn_init (format, local, ofwhat)\n   pedwarn (format, buffer);\n }\n \f\n+/* Keep a pointer to the last free TREE_LIST node as we digest an initializer,\n+   so that we can reuse it.  This is set in digest_init, and used in\n+   process_init_constructor.\n+\n+   We will never keep more than one free TREE_LIST node here.  This is for\n+   two main reasons.  First, we take elements off the old list and add them\n+   to the new list one at a time, thus there should never be more than\n+   one free TREE_LIST at a time, and thus even if there is, we will never\n+   need more than one.  Secondly, to avoid dangling pointers to freed obstacks,\n+   we want to always ensure that we have either a pointer to a valid TREE_LIST\n+   within the current initializer, or else a pointer to null.  */\n+\n+static tree free_tree_list = NULL_TREE;\n+\n /* Digest the parser output INIT as an initializer for type TYPE.\n    Return a C expression of type TYPE to represent the initial value.\n \n@@ -4750,13 +4764,21 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n     partial_bracket_mentioned = 0;\n \n   /* By default, assume we use one element from a list.\n-     We correct this later in the sole case where it is not true.  */\n+     We correct this later in the cases where it is not true.\n+\n+     Thus, we update TAIL now to point to the next element, and save the\n+     old value in OLD_TAIL_CONTENTS.  If we didn't actually use the first\n+     element, then we will reset TAIL before proceeding.  FREE_TREE_LIST\n+     is handled similarly.  */\n \n   if (tail)\n     {\n       old_tail_contents = *tail;\n       *tail = TREE_CHAIN (*tail);\n+      free_tree_list = old_tail_contents;\n     }\n+  else\n+    free_tree_list = 0;\n \n   if (init == error_mark_node)\n     return init;\n@@ -4933,6 +4955,7 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n       else if (tail != 0)\n \t{\n \t  *tail = old_tail_contents;\n+\t  free_tree_list = NULL_TREE;\n \t  result = process_init_constructor (type, NULL_TREE, tail,\n \t\t\t\t\t     require_constant,\n \t\t\t\t\t     constructor_constant, ofwhat);\n@@ -5030,6 +5053,7 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n       else if (tail != 0)\n \t{\n \t  *tail = old_tail_contents;\n+\t  free_tree_list = NULL_TREE;\n \t  return process_init_constructor (type, NULL_TREE, tail,\n \t\t\t\t\t   constructor_constant,\n \t\t\t\t\t   constructor_constant, ofwhat);\n@@ -5120,38 +5144,47 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n-      tree min_index, max_index, current_index, members_index;\n-      tree bound_type;\n-      tree one;\n+      tree min_index, max_index;\n       /* These are non-zero only within a range initializer.  */\n       tree start_index = 0, end_index = 0;\n       /* Within a range, this is the value for the elts in the range.  */\n       tree range_val = 0;\n+      /* Do arithmetic using double integers, but don't use fold/build,\n+\t because these allocate a new tree object everytime they are called,\n+\t thus resulting in gcc using too much memory for large\n+\t initializers.  */\n+      union tree_node current_index_node, members_index_node;\n+      tree current_index = &current_index_node;\n+      tree members_index = &members_index_node;\n+      TREE_TYPE (current_index) = integer_type_node;\n+      TREE_TYPE (members_index) = integer_type_node;\n \n       /* If we have array bounds, set our bounds from that.  Otherwise,\n-\t we have a lower bound of zero and an unknown upper bound.  Also\n-\t set the type of the bounds; use \"int\" as default.  */\n+\t we have a lower bound of zero and an unknown upper bound.  */\n       if (TYPE_DOMAIN (type))\n \t{\n-\t  min_index = members_index = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n+\t  min_index = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n \t  max_index = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n-\t  bound_type = TREE_TYPE (min_index);\n \t}\n       else\n \t{\n-\t  min_index = members_index = integer_zero_node;\n+\t  min_index = integer_zero_node;\n \t  max_index = 0;\n-\t  bound_type = integer_type_node;\n \t}\n \n-      one = convert (bound_type, integer_one_node);\n+      TREE_INT_CST_LOW (members_index) = TREE_INT_CST_LOW (min_index);\n+      TREE_INT_CST_HIGH (members_index) = TREE_INT_CST_HIGH (min_index);\n \n       /* Don't leave the loop based on index if the next item has an explicit\n \t index value that will override it. */\n \n-      for (current_index = min_index; tail != 0 || end_index;\n-\t   current_index = fold (build (PLUS_EXPR, bound_type,\n-\t\t\t\t\tcurrent_index, one)))\n+      for (TREE_INT_CST_LOW (current_index) = TREE_INT_CST_LOW (min_index),\n+\t   TREE_INT_CST_HIGH (current_index) = TREE_INT_CST_HIGH (min_index);\n+\t   tail != 0 || end_index;\n+\t   add_double (TREE_INT_CST_LOW (current_index),\n+\t\t       TREE_INT_CST_HIGH (current_index), 1, 0,\n+\t\t       &TREE_INT_CST_LOW (current_index),\n+\t\t       &TREE_INT_CST_HIGH (current_index)))\n \t{\n \t  register tree next1 = 0;\n \n@@ -5304,20 +5337,38 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \t     Make the list longer if necessary.  */\n \t  while (! tree_int_cst_lt (current_index, members_index))\n \t    {\n-\t      members = tree_cons (NULL_TREE, NULL_TREE, members);\n-\t      members_index = fold (build (PLUS_EXPR, bound_type,\n-\t\t\t\t\t   members_index, one));\n+\t      if (free_tree_list)\n+\t\t{\n+\t\t  TREE_CHAIN (free_tree_list) = members;\n+\t\t  TREE_PURPOSE (free_tree_list) = NULL_TREE;\n+\t\t  TREE_VALUE (free_tree_list) = NULL_TREE;\n+\t\t  members = free_tree_list;\n+\t\t  free_tree_list = NULL_TREE;\n+\t\t}\n+\t      else\n+\t\tmembers = tree_cons (NULL_TREE, NULL_TREE, members);\n+\t      add_double (TREE_INT_CST_LOW (members_index),\n+\t\t\t  TREE_INT_CST_HIGH (members_index), 1, 0,\n+\t\t\t  &TREE_INT_CST_LOW (members_index),\n+\t\t\t  &TREE_INT_CST_HIGH (members_index));\n \t    }\n \n \t  {\n \t    tree temp;\n-\t    tree idx;\n+\t    union tree_node idx_node;\n+\t    tree idx = &idx_node;\n+\t    TREE_TYPE (idx) = integer_type_node;\n \n \t    temp = members;\n-\t    for (idx = fold (build (MINUS_EXPR, bound_type,\n-\t\t\t\t    members_index, one));\n+\t    for (add_double (TREE_INT_CST_LOW (members_index),\n+\t\t\t     TREE_INT_CST_HIGH (members_index), -1, -1,\n+\t\t\t     &TREE_INT_CST_LOW (idx),\n+\t\t\t     &TREE_INT_CST_HIGH (idx));\n \t\t tree_int_cst_lt (current_index, idx);\n-\t\t idx = fold (build (MINUS_EXPR, bound_type, idx, one)))\n+\t\t add_double (TREE_INT_CST_LOW (idx),\n+\t\t\t     TREE_INT_CST_HIGH (idx), -1, -1,\n+\t\t\t     &TREE_INT_CST_LOW (idx),\n+\t\t\t     &TREE_INT_CST_HIGH (idx)))\n \t      temp = TREE_CHAIN (temp);\n \t    TREE_VALUE (temp) = next1;\n \t  }\n@@ -5405,7 +5456,16 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \t     Make the list longer if necessary.  */\n \t  while (i >= members_length)\n \t    {\n-\t      members = tree_cons (NULL_TREE, NULL_TREE, members);\n+\t      if (free_tree_list)\n+\t\t{\n+\t\t  TREE_CHAIN (free_tree_list) = members;\n+\t\t  TREE_PURPOSE (free_tree_list) = NULL_TREE;\n+\t\t  TREE_VALUE (free_tree_list) = NULL_TREE;\n+\t\t  members = free_tree_list;\n+\t\t  free_tree_list = NULL_TREE;\n+\t\t}\n+\t      else\n+\t\tmembers = tree_cons (NULL_TREE, NULL_TREE, members);\n \t      members_length++;\n \t    }\n \t  {\n@@ -5493,8 +5553,17 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n       else if (!TREE_CONSTANT (next1))\n \tallconstant = 0;\n       else if (initializer_constant_valid_p (next1, TREE_TYPE (next1)) == 0)\n-\tallsimple = 0;\n-      members = tree_cons (field, next1, members);\n+\tallsimple = 0; \n+     if (free_tree_list)\n+\t{\n+\t  TREE_CHAIN (free_tree_list) = members;\n+\t  TREE_PURPOSE (free_tree_list) = field;\n+\t  TREE_VALUE (free_tree_list) = next1;\n+\t  members = free_tree_list;\n+\t  free_tree_list = NULL_TREE;\n+\t}\n+      else\n+\tmembers = tree_cons (field, next1, members);\n     }\n \n   /* If arguments were specified as a list, just remove the ones we used.  */\n@@ -5525,7 +5594,16 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n   if (erroneous)\n     return error_mark_node;\n \n-  result = build (CONSTRUCTOR, type, NULL_TREE, nreverse (members));\n+  if (elts)\n+    result = build (CONSTRUCTOR, type, NULL_TREE, nreverse (members));\n+  else\n+    {\n+      result = init;\n+      CONSTRUCTOR_ELTS (result) = nreverse (members);\n+      TREE_TYPE (result) = type;\n+      TREE_CONSTANT (result) = 0;\n+      TREE_STATIC (result) = 0;\n+    }\n   if (allconstant) TREE_CONSTANT (result) = 1;\n   if (allconstant && allsimple) TREE_STATIC (result) = 1;\n   return result;"}]}