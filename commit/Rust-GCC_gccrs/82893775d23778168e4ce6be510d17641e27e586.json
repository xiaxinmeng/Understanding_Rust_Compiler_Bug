{"sha": "82893775d23778168e4ce6be510d17641e27e586", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI4OTM3NzVkMjM3NzgxNjhlNGNlNmJlNTEwZDE3NjQxZTI3ZTU4Ng==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-10T12:49:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-10T12:49:30Z"}, "message": "[multiple changes]\n\n2013-10-10  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_aggr.adb (Resolve_Array_Aggregate): Redo duplicate/missing\n\tchoice circuit. Was not quite right in some cases, which showed\n\tup in ACATS test B43201C.\n\t* sem_attr.adb (Address_Checks): Make sure name is set right\n\tfor some messages issued.\n\t* mlib-prj.adb: Minor code reorganization.\n\t* gnat_ugn.texi: Remove special VMS doc for tagging of warning msgs.\n\t* exp_ch9.adb: Minor reformatting.\n\n2013-10-10  Tristan Gingold  <gingold@adacore.com>\n\n\t* lib-writ.adb (Write_Unit_Information): Adjust previous patch.\n\n2013-10-10  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch5.adb (Analyze_If_Statement): Warn on redundant if\n\tstatement.\n\t* sem_util.ads, sem_util.adb (Has_No_Obvious_Side_Effects): New\n\tfunction.\n\n2013-10-10  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch9.adb (Expand_N_Timed_Entry_Call): Simplify expansion\n\tfor the case of a dispatching trigger: there is no need to\n\tduplicate the code or create a subprogram to encapsulate the\n\ttriggering statements. This allows exit statements in the\n\ttriggering statements, that refer to enclosing loops.\n\nFrom-SVN: r203369", "tree": {"sha": "33400257804a80067604a952e1e91279577a1f2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33400257804a80067604a952e1e91279577a1f2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82893775d23778168e4ce6be510d17641e27e586", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82893775d23778168e4ce6be510d17641e27e586", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82893775d23778168e4ce6be510d17641e27e586", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82893775d23778168e4ce6be510d17641e27e586/comments", "author": null, "committer": null, "parents": [{"sha": "5a8a6763b58fe46c1a2f1710b31705565e29667c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a8a6763b58fe46c1a2f1710b31705565e29667c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a8a6763b58fe46c1a2f1710b31705565e29667c"}], "stats": {"total": 478, "additions": 301, "deletions": 177}, "files": [{"sha": "740745727defa2338c6cd6da94129e1ea4ae37ae", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=82893775d23778168e4ce6be510d17641e27e586", "patch": "@@ -1,3 +1,33 @@\n+2013-10-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Array_Aggregate): Redo duplicate/missing\n+\tchoice circuit. Was not quite right in some cases, which showed\n+\tup in ACATS test B43201C.\n+\t* sem_attr.adb (Address_Checks): Make sure name is set right\n+\tfor some messages issued.\n+\t* mlib-prj.adb: Minor code reorganization.\n+\t* gnat_ugn.texi: Remove special VMS doc for tagging of warning msgs.\n+\t* exp_ch9.adb: Minor reformatting.\n+\n+2013-10-10  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* lib-writ.adb (Write_Unit_Information): Adjust previous patch.\n+\n+2013-10-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch5.adb (Analyze_If_Statement): Warn on redundant if\n+\tstatement.\n+\t* sem_util.ads, sem_util.adb (Has_No_Obvious_Side_Effects): New\n+\tfunction.\n+\n+2013-10-10  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch9.adb (Expand_N_Timed_Entry_Call): Simplify expansion\n+\tfor the case of a dispatching trigger: there is no need to\n+\tduplicate the code or create a subprogram to encapsulate the\n+\ttriggering statements. This allows exit statements in the\n+\ttriggering statements, that refer to enclosing loops.\n+\n 2013-10-10  Robert Dewar  <dewar@adacore.com>\n \n \t* freeze.adb: Minor reformatting."}, {"sha": "8db80bde74bb485568bbb401ca843fe17e7d0887", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 38, "deletions": 90, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=82893775d23778168e4ce6be510d17641e27e586", "patch": "@@ -11948,7 +11948,10 @@ package body Exp_Ch9 is\n    --       end if;\n    --    end;\n \n-   --  3) Ada 2005 (AI-345): When T.E is a dispatching procedure call;\n+   --  3) Ada 2005 (AI-345): When T.E is a dispatching procedure call, there\n+   --     is no delay and the triggering statements are executed. We first\n+   --     determine the kind of of the triggering call and then execute a\n+   --     synchronized operation or a direct call.\n \n    --    declare\n    --       B  : Boolean := False;\n@@ -11965,7 +11968,7 @@ package body Exp_Ch9 is\n    --         or else K = Ada.Tags.TK_Tagged\n    --       then\n    --          <dispatching-call>;\n-   --          <triggering-statements>\n+   --          B := True;\n \n    --       else\n    --          S :=\n@@ -11989,20 +11992,19 @@ package body Exp_Ch9 is\n    --             then\n    --                <dispatching-call>;\n    --             end if;\n-\n-   --             <triggering-statements>\n-   --          else\n-   --             <timed-statements>\n-   --          end if;\n+   --         end if;\n    --       end if;\n+\n+   --      if B then\n+   --          <triggering-statements>\n+   --      else\n+   --          <timed-statements>\n+   --      end if;\n    --    end;\n \n    --  The triggering statement and the sequence of timed statements have not\n    --  been analyzed yet (see Analyzed_Timed_Entry_Call), but they may contain\n-   --  global references if within an instantiation. To prevent duplication\n-   --  between various uses of those statements, they are encapsulated into a\n-   --  local procedure which is invoked multiple time when the trigger is a\n-   --  dispatching call.\n+   --  global references if within an instantiation.\n \n    procedure Expand_N_Timed_Entry_Call (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n@@ -12045,63 +12047,6 @@ package body Exp_Ch9 is\n       P : Entity_Id;  --  Parameter block\n       S : Entity_Id;  --  Primitive operation slot\n \n-      procedure Rewrite_Triggering_Statements;\n-      --  If the trigger is a dispatching call, the expansion inserts multiple\n-      --  copies of the abortable part. This is both inefficient, and may lead\n-      --  to duplicate definitions that the back-end will reject, when the\n-      --  abortable part includes loops. This procedure rewrites the abortable\n-      --  part into a call to a generated procedure.\n-\n-      -----------------------------------\n-      -- Rewrite_Triggering_Statements --\n-      -----------------------------------\n-\n-      procedure Rewrite_Triggering_Statements is\n-         Proc : constant Entity_Id := Make_Defining_Identifier (Loc, Name_uA);\n-         Decl : Node_Id;\n-         Stat : Node_Id;\n-\n-      begin\n-         Decl :=\n-           Make_Subprogram_Body (Loc,\n-             Specification              =>\n-               Make_Procedure_Specification (Loc, Defining_Unit_Name => Proc),\n-             Declarations               => New_List,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc, E_Stats));\n-\n-         Append_To (Decls, Decl);\n-\n-         --  Adjust the scope of blocks in the procedure. Needed because blocks\n-         --  generate declarations that are processed before other analysis\n-         --  takes place, and their scope is already set. The backend depends\n-         --  on the scope chain to determine the legality of some anonymous\n-         --  types, and thus we must indicate that the block is within the new\n-         --  procedure.\n-\n-         Stat := First (E_Stats);\n-         while Present (Stat) loop\n-            if Nkind (Stat) = N_Block_Statement then\n-               Insert_Before (Stat,\n-                 Make_Implicit_Label_Declaration (Sloc (Stat),\n-                   Defining_Identifier =>\n-                     Make_Defining_Identifier (\n-                       Sloc (Stat), Chars (Identifier (Stat)))));\n-            end if;\n-\n-            Next (Stat);\n-         end loop;\n-\n-         --  Analyze (Decl);\n-\n-         --  Rewrite abortable part into a call to this procedure.\n-\n-         E_Stats :=\n-           New_List\n-             (Make_Procedure_Call_Statement (Loc,\n-                Name => New_Occurrence_Of (Proc, Loc)));\n-      end Rewrite_Triggering_Statements;\n-\n    --  Start of processing for Expand_N_Timed_Entry_Call\n \n    begin\n@@ -12144,7 +12089,6 @@ package body Exp_Ch9 is\n       if Is_Disp_Select then\n          Extract_Dispatching_Call (E_Call, Call_Ent, Obj, Actuals, Formals);\n          Decls := New_List;\n-         Rewrite_Triggering_Statements;\n \n          Stmts := New_List;\n \n@@ -12349,20 +12293,10 @@ package body Exp_Ch9 is\n          --       then\n          --          <dispatching-call>\n          --       end if;\n-         --       <triggering-statements>\n-         --    else\n-         --       <timed-statements>\n          --    end if;\n \n-         --  Note: we used to do Copy_Separate_List here, but this was changed\n-         --  to New_Copy_List_Tree with no explanation or RH note??? We should\n-         --  explain the need for the change ???\n-\n-         N_Stats := New_Copy_List_Tree (E_Stats);\n-\n-         Prepend_To (N_Stats,\n+         N_Stats := New_List (\n            Make_Implicit_If_Statement (N,\n-\n              Condition =>\n                Make_Or_Else (Loc,\n                  Left_Opnd =>\n@@ -12391,19 +12325,17 @@ package body Exp_Ch9 is\n          Append_To (Conc_Typ_Stmts,\n            Make_Implicit_If_Statement (N,\n              Condition       => New_Reference_To (B, Loc),\n-             Then_Statements => N_Stats,\n-             Else_Statements => D_Stats));\n+             Then_Statements => N_Stats));\n \n          --  Generate:\n          --    <dispatching-call>;\n-         --    <triggering-statements>\n-\n-         --  Note: the following was Copy_Separate_List but it was changed to\n-         --  New_Copy_List_Tree without comments or RH documentation ??? We\n-         --  should explain the need for the change ???\n+         --    B := True;\n \n-         Lim_Typ_Stmts := New_Copy_List_Tree (E_Stats);\n-         Prepend_To (Lim_Typ_Stmts, New_Copy_Tree (E_Call));\n+         Lim_Typ_Stmts :=\n+           New_List (New_Copy_Tree (E_Call),\n+             Make_Assignment_Statement (Loc,\n+               Name       => New_Occurrence_Of (B, Loc),\n+               Expression => New_Occurrence_Of (Standard_True, Loc)));\n \n          --  Generate:\n          --    if K = Ada.Tags.TK_Limited_Tagged\n@@ -12420,8 +12352,24 @@ package body Exp_Ch9 is\n              Then_Statements => Lim_Typ_Stmts,\n              Else_Statements => Conc_Typ_Stmts));\n \n+         --    Generate:\n+\n+         --    if B then\n+         --       <triggering-statements>\n+         --    else\n+         --       <timed-statements>\n+         --    end if;\n+\n+         Append_To (Stmts,\n+           Make_Implicit_If_Statement (N,\n+             Condition       => New_Occurrence_Of (B, Loc),\n+             Then_Statements => E_Stats,\n+             Else_Statements => D_Stats));\n+\n       else\n-         --  Skip assignments to temporaries created for in-out parameters.\n+         --  Simple case of a non-dispatching trigger. Skip assignments to\n+         --  temporaries created for in-out parameters.\n+\n          --  This makes unwarranted assumptions about the shape of the expanded\n          --  tree for the call, and should be cleaned up ???\n "}, {"sha": "c82dab7aa04d4ddbdb30c0836148073c1a24299f", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=82893775d23778168e4ce6be510d17641e27e586", "patch": "@@ -4931,7 +4931,6 @@ this warning option.\n This switch suppresses warnings for implicit dereferences in\n indexed components, slices, and selected components.\n \n-@ifclear vms\n @item -gnatw.d\n @emph{Activate tagging of warning messages.}\n @cindex @option{-gnatw.d} (@command{gcc})\n@@ -4947,25 +4946,6 @@ affected by the use of @code{-gnatwa}.\n If this switch is set, then warning messages return to the default\n mode in which warnings are not tagged as described above for\n @code{-gnatw.d}.\n-@end ifclear\n-\n-@ifset vms\n-@item -gnatw.d\n-@emph{Activate tagging of warning messages.}\n-@cindex @option{-gnatw.d} (@command{gcc})\n-If this switch is set, then warning messages are tagged, either with\n-the appropriate WARNINGS qualifier string (e.g. [SUSPICIOUS_MODULUS]\n-or with ``[enabled by default]'' if the warning is not under control of a\n-specific WARNING qualifier switch. This mode is off by default, and is not\n-affected by the use of @code{-gnatwa}.\n-\n-@item -gnatw.D\n-@emph{Deactivate tagging of warning messages.}\n-@cindex @option{-gnatw.d} (@command{gcc})\n-If this switch is set, then warning messages return to the default\n-mode in which warnings are not tagged as described above for\n-@code{-gnatw.d}.\n-@end ifset\n \n @item -gnatwe\n @emph{Treat warnings and style checks as errors.}"}, {"sha": "c4b5e5088fc367a5bbf7c9da8162757281017404", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=82893775d23778168e4ce6be510d17641e27e586", "patch": "@@ -628,6 +628,7 @@ package body Lib.Writ is\n             if Is_Generic_Unit (Cunit_Entity (Main_Unit))\n               and then\n                 Is_Predefined_File_Name (Unit_File_Name (Current_Sem_Unit))\n+              and then Linker_Option_Lines.Table (J).Unit = Unit_Num\n             then\n                Set_Standard_Error;\n                Write_Line"}, {"sha": "945f91372527fb492bad1aab9d231fd8a1ce1b08", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=82893775d23778168e4ce6be510d17641e27e586", "patch": "@@ -1185,9 +1185,9 @@ package body MLib.Prj is\n \n                   Delete_File (Get_Name_String (Path), Succ);\n \n-                  if not Succ then\n-                     null;\n-                  end if;\n+                  --  We ignore a failure in this Delete_File operation.\n+                  --  Is that OK??? If so, worth a comment as to why we\n+                  --  are OK with the operation failing\n                end;\n             end if;\n "}, {"sha": "5aec38a32d05f7fb65a8bdccaa5efcf48e6a37c6", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 147, "deletions": 64, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=82893775d23778168e4ce6be510d17641e27e586", "patch": "@@ -65,23 +65,35 @@ with Uintp;    use Uintp;\n package body Sem_Aggr is\n \n    type Case_Bounds is record\n-     Choice_Lo   : Node_Id;\n-     Choice_Hi   : Node_Id;\n-     Choice_Node : Node_Id;\n+      Lo : Node_Id;\n+      --  Low bound of choice. Once we sort the Case_Table, then entries\n+      --  will be in order of ascending Choice_Lo values.\n+\n+      Hi : Node_Id;\n+      --  High Bound of choice. The sort does not pay any attention to the\n+      --  high bound, so choices 1 .. 4 and 1 .. 5 could be in either order.\n+\n+      Highest : Uint;\n+      --  If there are duplicates or missing entries, then in the sorted\n+      --  table, this records the highest value among Choice_Hi values\n+      --  seen so far, including this entry.\n+\n+      Choice : Node_Id;\n+      --  The node of the choice\n    end record;\n \n    type Case_Table_Type is array (Nat range <>) of Case_Bounds;\n-   --  Table type used by Check_Case_Choices procedure\n+   --  Table type used by Check_Case_Choices procedure. Entry zero is not\n+   --  used (reserved for the sort). Real entries start at one.\n \n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n    procedure Sort_Case_Table (Case_Table : in out Case_Table_Type);\n-   --  Sort the Case Table using the Lower Bound of each Choice as the key.\n-   --  A simple insertion sort is used since the number of choices in a case\n-   --  statement of variant part will usually be small and probably in near\n-   --  sorted order.\n+   --  Sort the Case Table using the Lower Bound of each Choice as the key. A\n+   --  simple insertion sort is used since the choices in a case statement will\n+   --  usually be in near sorted order.\n \n    procedure Check_Can_Never_Be_Null (Typ : Entity_Id; Expr : Node_Id);\n    --  Ada 2005 (AI-231): Check bad usage of null for a component for which\n@@ -1905,8 +1917,9 @@ package body Sem_Aggr is\n             --  if a choice in an aggregate is a subtype indication these\n             --  denote the lowest and highest values of the subtype\n \n-            Table : Case_Table_Type (1 .. Case_Table_Size);\n-            --  Used to sort all the different choice values\n+            Table : Case_Table_Type (0 .. Case_Table_Size);\n+            --  Used to sort all the different choice values. Entry zero is\n+            --  reserved for sorting purposes.\n \n             Single_Choice : Boolean;\n             --  Set to true every time there is a single discrete choice in a\n@@ -2018,9 +2031,9 @@ package body Sem_Aggr is\n                   end if;\n \n                   Nb_Discrete_Choices := Nb_Discrete_Choices + 1;\n-                  Table (Nb_Discrete_Choices).Choice_Lo := Low;\n-                  Table (Nb_Discrete_Choices).Choice_Hi := High;\n-                  Table (Nb_Discrete_Choices).Choice_Node := Choice;\n+                  Table (Nb_Discrete_Choices).Lo := Low;\n+                  Table (Nb_Discrete_Choices).Hi := High;\n+                  Table (Nb_Discrete_Choices).Choice := Choice;\n \n                   Next (Choice);\n \n@@ -2142,6 +2155,10 @@ package body Sem_Aggr is\n                   --  High end of one range and Low end of the next. Should be\n                   --  contiguous if there is no hole in the list of values.\n \n+                  Lo_Dup : Uint;\n+                  Hi_Dup : Uint;\n+                  --  End points of duplicated range\n+\n                   Missing_Or_Duplicates : Boolean := False;\n                   --  Set True if missing or duplicate choices found\n \n@@ -2189,62 +2206,129 @@ package body Sem_Aggr is\n                begin\n                   Sort_Case_Table (Table);\n \n-                  --  Loop through entries in table to find duplicate indexes\n+                  --  First we do a quick linear loop to find out if we have\n+                  --  any duplicates or missing entries (usually we have a\n+                  --  legal aggregate, so this will get us out quickly).\n \n                   for J in 1 .. Nb_Discrete_Choices - 1 loop\n-                     Hi_Val := Expr_Value (Table (J).Choice_Hi);\n-                     Lo_Val := Expr_Value (Table (J + 1).Choice_Lo);\n-\n-                     if Hi_Val >= Lo_Val then\n-                        Choice := Table (J + 1).Choice_Lo;\n-                        Error_Msg_Sloc := Sloc (Table (J).Choice_Hi);\n-\n-                        if Hi_Val = Lo_Val then\n-                           Error_Msg_N\n-                             (\"index value in array aggregate duplicates \"\n-                              & \"the one given#\",\n-                              Choice);\n-                        else\n-                           Error_Msg_N\n-                             (\"index values in array aggregate duplicate \"\n-                              & \"those given#\", Choice);\n-                        end if;\n+                     Hi_Val := Expr_Value (Table (J).Hi);\n+                     Lo_Val := Expr_Value (Table (J + 1).Lo);\n \n+                     if Lo_Val <= Hi_Val\n+                       or else (Lo_Val > Hi_Val + 1\n+                                 and then not Others_Present)\n+                     then\n                         Missing_Or_Duplicates := True;\n-                        Output_Bad_Choices (Lo_Val, Hi_Val, Choice);\n+                        exit;\n                      end if;\n                   end loop;\n \n-                  --  Loop through entries in table to find missing indexes.\n-                  --  Not needed if others present, since missing impossible.\n+                  --  If we have missing or duplicate entries, first fill in\n+                  --  the Highest entries to make life easier in the following\n+                  --  loops to detect bad entries.\n \n-                  if not Others_Present then\n-                     for J in 1 .. Nb_Discrete_Choices - 1 loop\n-                        Hi_Val := Expr_Value (Table (J).Choice_Hi);\n-                        Lo_Val := Expr_Value (Table (J + 1).Choice_Lo);\n+                  if Missing_Or_Duplicates then\n+                     Table (1).Highest := Expr_Value (Table (1).Hi);\n \n-                        if Hi_Val < Lo_Val - 1 then\n-                           Choice := Table (J + 1).Choice_Lo;\n+                     for J in 2 .. Nb_Discrete_Choices loop\n+                        Table (J).Highest :=\n+                          UI_Max\n+                            (Table (J - 1).Highest, Expr_Value (Table (J).Hi));\n+                     end loop;\n \n-                           if Hi_Val + 1 = Lo_Val - 1 then\n-                              Error_Msg_N\n-                                (\"missing index value in array aggregate!\",\n-                                 Choice);\n-                           else\n-                              Error_Msg_N\n-                                (\"missing index values in array aggregate!\",\n-                                 Choice);\n-                           end if;\n+                     --  Loop through table entries to find duplicate indexes\n+\n+                     for J in 2 .. Nb_Discrete_Choices loop\n+                        Lo_Val := Expr_Value (Table (J).Lo);\n+                        Hi_Val := Expr_Value (Table (J).Hi);\n+\n+                        --  Case where we have duplicates (the lower bound of\n+                        --  this choice is less than or equal to the highest\n+                        --  high bound found so far).\n+\n+                        if Lo_Val <= Table (J - 1).Highest then\n+\n+                           --  We move backwards looking for duplicates. We can\n+                           --  abandon this loop as soon as we reach a choice\n+                           --  highest value that is less than Lo_Val.\n+\n+                           for K in reverse 1 .. J - 1 loop\n+                              exit when Table (K).Highest < Lo_Val;\n+\n+                              --  Here we may have duplicates between entries\n+                              --  for K and J. Get range of duplicates.\n+\n+                              Lo_Dup :=\n+                                UI_Max (Lo_Val, Expr_Value (Table (K).Lo));\n+                              Hi_Dup :=\n+                                UI_Min (Hi_Val, Expr_Value (Table (K).Hi));\n+\n+                              --  Nothing to do if duplicate range is null\n \n-                           Missing_Or_Duplicates := True;\n-                           Output_Bad_Choices (Hi_Val + 1, Lo_Val - 1, Choice);\n+                              if Lo_Dup > Hi_Dup then\n+                                 null;\n+\n+                              --  Otherwise place proper message\n+\n+                              else\n+                                 --  We place message on later choice, with a\n+                                 --  line reference to the earlier choice.\n+\n+                                 if Sloc (Table (J).Choice) <\n+                                   Sloc (Table (K).Choice)\n+                                 then\n+                                    Choice := Table (K).Choice;\n+                                    Error_Msg_Sloc := Sloc (Table (J).Choice);\n+                                 else\n+                                    Choice := Table (J).Choice;\n+                                    Error_Msg_Sloc := Sloc (Table (K).Choice);\n+                                 end if;\n+\n+                                 if Lo_Dup = Hi_Dup then\n+                                    Error_Msg_N\n+                                      (\"index value in array aggregate \"\n+                                       & \"duplicates the one given#!\", Choice);\n+                                 else\n+                                    Error_Msg_N\n+                                      (\"index values in array aggregate \"\n+                                       & \"duplicate those given#!\", Choice);\n+                                 end if;\n+\n+                                 Output_Bad_Choices (Lo_Dup, Hi_Dup, Choice);\n+                              end if;\n+                           end loop;\n                         end if;\n                      end loop;\n-                  end if;\n \n-                  --  If either missing or duplicate values, return failure\n+                     --  Loop through entries in table to find missing indexes.\n+                     --  Not needed if others, since missing impossible.\n+\n+                     if not Others_Present then\n+                        for J in 2 .. Nb_Discrete_Choices loop\n+                           Lo_Val := Expr_Value (Table (J).Lo);\n+                           Hi_Val := Table (J - 1).Highest;\n+\n+                           if Lo_Val > Hi_Val + 1 then\n+                              Choice := Table (J).Lo;\n+\n+                              if Hi_Val + 1 = Lo_Val - 1 then\n+                                 Error_Msg_N\n+                                   (\"missing index value in array aggregate!\",\n+                                    Choice);\n+                              else\n+                                 Error_Msg_N\n+                                   (\"missing index values in array aggregate!\",\n+                                    Choice);\n+                              end if;\n+\n+                              Output_Bad_Choices\n+                                (Hi_Val + 1, Lo_Val - 1, Choice);\n+                           end if;\n+                        end loop;\n+                     end if;\n+\n+                     --  If either missing or duplicate values, return failure\n \n-                  if Missing_Or_Duplicates then\n                      Set_Etype (N, Any_Composite);\n                      return Failure;\n                   end if;\n@@ -2254,8 +2338,8 @@ package body Sem_Aggr is\n             --  STEP 2 (B): Compute aggregate bounds and min/max choices values\n \n             if Nb_Discrete_Choices > 0 then\n-               Choices_Low  := Table (1).Choice_Lo;\n-               Choices_High := Table (Nb_Discrete_Choices).Choice_Hi;\n+               Choices_Low  := Table (1).Lo;\n+               Choices_High := Table (Nb_Discrete_Choices).Hi;\n             end if;\n \n             --  If Others is present, then bounds of aggregate come from the\n@@ -2566,8 +2650,9 @@ package body Sem_Aggr is\n       Check_Unset_Reference (Aggregate_Bounds (N));\n \n       if not Others_Present and then Nb_Discrete_Choices = 0 then\n-         Set_High_Bound (Aggregate_Bounds (N),\n-             Duplicate_Subexpr (High_Bound (Aggregate_Bounds (N))));\n+         Set_High_Bound\n+           (Aggregate_Bounds (N),\n+            Duplicate_Subexpr (High_Bound (Aggregate_Bounds (N))));\n       end if;\n \n       --  Check the dimensions of each component in the array aggregate\n@@ -4636,21 +4721,19 @@ package body Sem_Aggr is\n    ---------------------\n \n    procedure Sort_Case_Table (Case_Table : in out Case_Table_Type) is\n-      L : constant Int := Case_Table'First;\n       U : constant Int := Case_Table'Last;\n       K : Int;\n       J : Int;\n       T : Case_Bounds;\n \n    begin\n-      K := L;\n-      while K /= U loop\n+      K := 1;\n+      while K < U loop\n          T := Case_Table (K + 1);\n \n          J := K + 1;\n-         while J /= L\n-           and then Expr_Value (Case_Table (J - 1).Choice_Lo) >\n-                    Expr_Value (T.Choice_Lo)\n+         while J > 1\n+           and then Expr_Value (Case_Table (J - 1).Lo) > Expr_Value (T.Lo)\n          loop\n             Case_Table (J) := Case_Table (J - 1);\n             J := J - 1;"}, {"sha": "44692e0382389968be9377e964c9b751ef11f86c", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=82893775d23778168e4ce6be510d17641e27e586", "patch": "@@ -455,6 +455,7 @@ package body Sem_Attr is\n                             Reason => PE_Address_Of_Intrinsic));\n \n                      else\n+                        Error_Msg_Name_1 := Aname;\n                         Error_Msg_N\n                          (\"cannot take % of intrinsic subprogram\", N);\n                      end if;"}, {"sha": "e7f464ee1718f20f71887f56c0ee59c5d5d720ad", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=82893775d23778168e4ce6be510d17641e27e586", "patch": "@@ -1577,6 +1577,37 @@ package body Sem_Ch5 is\n             Remove_Warning_Messages (Then_Statements (N));\n          end if;\n       end if;\n+\n+      --  Warn on redundant if statement that has no effect\n+\n+      if Warn_On_Redundant_Constructs\n+\n+        --  Condition must not have obvious side effect\n+\n+        and then Has_No_Obvious_Side_Effects (Condition (N))\n+\n+        --  No elsif parts of else part\n+\n+        and then No (Elsif_Parts (N))\n+        and then No (Else_Statements (N))\n+\n+        --  Then must be a single null statement\n+\n+        and then List_Length (Then_Statements (N)) = 1\n+      then\n+         --  Go to original node, since we may have rewritten something as\n+         --  a null statement (e.g. a case we could figure the outcome of).\n+\n+         declare\n+            T : constant Node_Id := First (Then_Statements (N));\n+            S : constant Node_Id := Original_Node (T);\n+\n+         begin\n+            if Comes_From_Source (S) and then Nkind (S) = N_Null_Statement then\n+               Error_Msg_N (\"if statement has no effect?r?\", N);\n+            end if;\n+         end;\n+      end if;\n    end Analyze_If_Statement;\n \n    ----------------------------------------"}, {"sha": "935b7272e536389ba267d1d905c000b592fb6377", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=82893775d23778168e4ce6be510d17641e27e586", "patch": "@@ -6456,6 +6456,45 @@ package body Sem_Util is\n       return False;\n    end Has_Interfaces;\n \n+   ---------------------------------\n+   -- Has_No_Obvious_Side_Effects --\n+   ---------------------------------\n+\n+   function Has_No_Obvious_Side_Effects (N : Node_Id) return Boolean is\n+   begin\n+      --  For now, just handle literals, constants, and non-volatile\n+      --  variables and expressions combining these with operators or\n+      --  short circuit forms.\n+\n+      if Nkind (N) in N_Numeric_Or_String_Literal then\n+         return True;\n+\n+      elsif Nkind (N) = N_Character_Literal then\n+         return True;\n+\n+      elsif Nkind (N) in N_Unary_Op then\n+         return Has_No_Obvious_Side_Effects (Right_Opnd (N));\n+\n+      elsif Nkind (N) in N_Binary_Op or else Nkind (N) in N_Short_Circuit then\n+         return Has_No_Obvious_Side_Effects (Left_Opnd (N))\n+                   and then\n+                Has_No_Obvious_Side_Effects (Right_Opnd (N));\n+\n+      elsif Nkind (N) in N_Has_Entity then\n+         return Present (Entity (N))\n+           and then Ekind_In (Entity (N), E_Variable,\n+                                          E_Constant,\n+                                          E_Enumeration_Literal,\n+                                          E_In_Parameter,\n+                                          E_Out_Parameter,\n+                                          E_In_Out_Parameter)\n+           and then not Is_Volatile (Entity (N));\n+\n+      else\n+         return False;\n+      end if;\n+   end Has_No_Obvious_Side_Effects;\n+\n    ------------------------\n    -- Has_Null_Exclusion --\n    ------------------------"}, {"sha": "d8d7db13451ea314553c58d5283e260203d2f34e", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82893775d23778168e4ce6be510d17641e27e586/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=82893775d23778168e4ce6be510d17641e27e586", "patch": "@@ -742,6 +742,17 @@ package Sem_Util is\n    --  Use_Full_View controls if the check is done using its full view (if\n    --  available).\n \n+   function Has_No_Obvious_Side_Effects (N : Node_Id) return Boolean;\n+   --  This is a simple minded function for determining whether an expression\n+   --  has no obvious side effects. It is used only for determining whether\n+   --  warnings are needed in certain situations, and is not guaranteed to\n+   --  be accurate in either direction. Exceptions may mean an expression\n+   --  does in fact have side effects, but this may be ignored and True is\n+   --  returned, or a complex expression may in fact be side effect free\n+   --  but we don't recognize it here and return False. The Side_Effect_Free\n+   --  routine in Remove_Side_Effects is much more extensive and perhaps could\n+   --  be shared, so that this routine would be more accurate.\n+\n    function Has_Null_Exclusion (N : Node_Id) return Boolean;\n    --  Determine whether node N has a null exclusion\n "}]}