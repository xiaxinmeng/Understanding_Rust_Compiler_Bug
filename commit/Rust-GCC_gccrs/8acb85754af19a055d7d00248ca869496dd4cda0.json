{"sha": "8acb85754af19a055d7d00248ca869496dd4cda0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFjYjg1NzU0YWYxOWEwNTVkN2QwMDI0OGNhODY5NDk2ZGQ0Y2RhMA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-05-05T20:21:15Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-05-05T20:21:15Z"}, "message": "re PR target/79038 (Improve PowerPC ISA 3.0 conversion between integers and hardware _Float128)\n\n[gcc]\n2017-05-05  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/79038\n\tPR target/79202\n\tPR target/79203\n\t* config/rs6000/rs6000.md (u code attribute): Add FIX and\n\tUNSIGNED_FIX.\n\t(extendsi<mode>2): Add support for doing sign extension via\n\tVUPKHSW and XXPERMDI if the value is in Altivec registers and we\n\tdon't have ISA 3.0 instructions.\n\t(extendsi<mode>2 splitter): Likewise.\n\t(fix_trunc<mode>si2): If we are at ISA 2.07 (VSX small integer),\n\tgenerate the normal insns since SImode can now go in vector\n\tregisters.  Disallow the special UNSPECs needed for previous\n\tmachines to hide SImode being used.  Add new insns\n\tfctiw{,w}_<mode>_smallint if SImode can go in vector registers.\n\t(fix_trunc<mode>si2_stfiwx): Likewise.\n\t(fix_trunc<mode>si2_internal): Likewise.\n\t(fixuns_trunc<mode>si2): Likewise.\n\t(fixuns_trunc<mode>si2_stfiwx): Likewise.\n\t(fctiw<u>z_<mode>_smallint): Likewise.\n\t(fctiw<u>z_<mode>_mem): New combiner pattern to prevent conversion\n\tof floating point to 32-bit integer from doing a direct move to\n\tthe GPR registers to do a store.\n\t(fctiwz_<mode>): Break long line.\n\n[gcc/testsuite]\n2017-05-05  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/79038\n\tPR target/79202\n\tPR target/79203\n\t* gcc.target/powerpc/ppc-round3.c: New test.\n\t* gcc.target/powerpc/ppc-round2.c: Update expected code.\n\nFrom-SVN: r247657", "tree": {"sha": "ca1ea8fb6d98d944ff0de53f34a7c102b53d7baf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca1ea8fb6d98d944ff0de53f34a7c102b53d7baf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8acb85754af19a055d7d00248ca869496dd4cda0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8acb85754af19a055d7d00248ca869496dd4cda0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8acb85754af19a055d7d00248ca869496dd4cda0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8acb85754af19a055d7d00248ca869496dd4cda0/comments", "author": null, "committer": null, "parents": [{"sha": "4b4b2e58e318f491bfc8d939129b6d6fbfa650f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9"}], "stats": {"total": 200, "additions": 173, "deletions": 27}, "files": [{"sha": "0a8bb93f326d5270248413ddcb866e0267449101", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8acb85754af19a055d7d00248ca869496dd4cda0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8acb85754af19a055d7d00248ca869496dd4cda0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8acb85754af19a055d7d00248ca869496dd4cda0", "patch": "@@ -1,3 +1,29 @@\n+2017-05-05  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/79038\n+\tPR target/79202\n+\tPR target/79203\n+\t* config/rs6000/rs6000.md (u code attribute): Add FIX and\n+\tUNSIGNED_FIX.\n+\t(extendsi<mode>2): Add support for doing sign extension via\n+\tVUPKHSW and XXPERMDI if the value is in Altivec registers and we\n+\tdon't have ISA 3.0 instructions.\n+\t(extendsi<mode>2 splitter): Likewise.\n+\t(fix_trunc<mode>si2): If we are at ISA 2.07 (VSX small integer),\n+\tgenerate the normal insns since SImode can now go in vector\n+\tregisters.  Disallow the special UNSPECs needed for previous\n+\tmachines to hide SImode being used.  Add new insns\n+\tfctiw{,w}_<mode>_smallint if SImode can go in vector registers.\n+\t(fix_trunc<mode>si2_stfiwx): Likewise.\n+\t(fix_trunc<mode>si2_internal): Likewise.\n+\t(fixuns_trunc<mode>si2): Likewise.\n+\t(fixuns_trunc<mode>si2_stfiwx): Likewise.\n+\t(fctiw<u>z_<mode>_smallint): Likewise.\n+\t(fctiw<u>z_<mode>_mem): New combiner pattern to prevent conversion\n+\tof floating point to 32-bit integer from doing a direct move to\n+\tthe GPR registers to do a store.\n+\t(fctiwz_<mode>): Break long line.\n+\n 2017-05-05  Bin Cheng  <bin.cheng@arm.com>\n \n \t* Makefile.in (GTFILES): Add tree-ssa-loop-ivopts.c."}, {"sha": "3d21ccc34a8787622b4a5086027f23bbe59a441e", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 80, "deletions": 16, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8acb85754af19a055d7d00248ca869496dd4cda0/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8acb85754af19a055d7d00248ca869496dd4cda0/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=8acb85754af19a055d7d00248ca869496dd4cda0", "patch": "@@ -566,7 +566,9 @@\n (define_code_iterator any_float\t\t[float unsigned_float])\n \n (define_code_attr u  [(sign_extend\t\"\")\n-\t\t      (zero_extend\t\"u\")])\n+\t\t      (zero_extend\t\"u\")\n+\t\t      (fix\t\t\"\")\n+\t\t      (unsigned_fix\t\"u\")])\n \n (define_code_attr su [(sign_extend\t\"s\")\n \t\t      (zero_extend\t\"u\")\n@@ -1027,18 +1029,47 @@\n \n \n (define_insn \"extendsi<mode>2\"\n-  [(set (match_operand:EXTSI 0 \"gpc_reg_operand\" \"=r,r,wl,wu,wj,wK\")\n-\t(sign_extend:EXTSI (match_operand:SI 1 \"lwa_operand\" \"Y,r,Z,Z,r,wK\")))]\n+  [(set (match_operand:EXTSI 0 \"gpc_reg_operand\" \"=r,r,wl,wu,wj,wK,wH\")\n+\t(sign_extend:EXTSI (match_operand:SI 1 \"lwa_operand\" \"Y,r,Z,Z,r,wK,wH\")))]\n   \"\"\n   \"@\n    lwa%U1%X1 %0,%1\n    extsw %0,%1\n    lfiwax %0,%y1\n    lxsiwax %x0,%y1\n    mtvsrwa %x0,%1\n-   vextsw2d %0,%1\"\n-  [(set_attr \"type\" \"load,exts,fpload,fpload,mffgpr,vecexts\")\n-   (set_attr \"sign_extend\" \"yes\")])\n+   vextsw2d %0,%1\n+   #\"\n+  [(set_attr \"type\" \"load,exts,fpload,fpload,mffgpr,vecexts,vecperm\")\n+   (set_attr \"sign_extend\" \"yes\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,8\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"altivec_register_operand\")\n+\t(sign_extend:DI (match_operand:SI 1 \"altivec_register_operand\")))]\n+  \"TARGET_VSX_SMALL_INTEGER && TARGET_P8_VECTOR && !TARGET_P9_VECTOR\n+   && reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  int dest_regno = REGNO (dest);\n+  int src_regno = REGNO (src);\n+  rtx dest_v2di = gen_rtx_REG (V2DImode, dest_regno);\n+  rtx src_v4si = gen_rtx_REG (V4SImode, src_regno);\n+\n+  if (VECTOR_ELT_ORDER_BIG)\n+    {\n+      emit_insn (gen_altivec_vupkhsw (dest_v2di, src_v4si));\n+      emit_insn (gen_vsx_xxspltd_v2di (dest_v2di, dest_v2di, const1_rtx));\n+    }\n+  else\n+    {\n+      emit_insn (gen_altivec_vupklsw (dest_v2di, src_v4si));\n+      emit_insn (gen_vsx_xxspltd_v2di (dest_v2di, dest_v2di, const0_rtx));\n+    }\n+  DONE;\n+})\n \n (define_insn_and_split \"*extendsi<mode>2_dot\"\n   [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x,?y\")\n@@ -5570,7 +5601,7 @@\n   \"TARGET_HARD_FLOAT && ((TARGET_FPRS && <TARGET_FLOAT>) || <E500_CONVERT>)\"\n   \"\n {\n-  if (!<E500_CONVERT>)\n+  if (!<E500_CONVERT> && !TARGET_VSX_SMALL_INTEGER)\n     {\n       rtx src = force_reg (<MODE>mode, operands[1]);\n \n@@ -5596,7 +5627,8 @@\n    (clobber (match_scratch:DI 2 \"=d\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n    && (<MODE>mode != SFmode || TARGET_SINGLE_FLOAT)\n-   && TARGET_STFIWX && can_create_pseudo_p ()\"\n+   && TARGET_STFIWX && can_create_pseudo_p ()\n+   && !TARGET_VSX_SMALL_INTEGER\"\n   \"#\"\n   \"\"\n   [(pc)]\n@@ -5637,7 +5669,8 @@\n \t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d,<rreg>\")))\n    (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"=1,d\"))\n    (clobber (match_operand:DI 3 \"offsettable_mem_operand\" \"=o,o\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+   && !TARGET_VSX_SMALL_INTEGER\"\n   \"#\"\n   \"\"\n   [(pc)]\n@@ -5721,7 +5754,7 @@\n        || <E500_CONVERT>)\"\n   \"\n {\n-  if (!<E500_CONVERT>)\n+  if (!<E500_CONVERT> && !TARGET_VSX_SMALL_INTEGER)\n     {\n       emit_insn (gen_fixuns_trunc<mode>si2_stfiwx (operands[0], operands[1]));\n       DONE;\n@@ -5733,7 +5766,8 @@\n \t(unsigned_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\")))\n    (clobber (match_scratch:DI 2 \"=d\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && <TARGET_FLOAT> && TARGET_FCTIWUZ\n-   && TARGET_STFIWX && can_create_pseudo_p ()\"\n+   && TARGET_STFIWX && can_create_pseudo_p ()\n+   && !TARGET_VSX_SMALL_INTEGER\"\n   \"#\"\n   \"\"\n   [(pc)]\n@@ -5818,13 +5852,43 @@\n     }\n   DONE;\n })\n-; Here, we use (set (reg) (unspec:DI [(fix:SI ...)] UNSPEC_FCTIWZ))\n-; rather than (set (subreg:SI (reg)) (fix:SI ...))\n-; because the first makes it clear that operand 0 is not live\n-; before the instruction.\n+\n+;; If -mvsx-small-integer, we can represent the FIX operation directly.  On\n+;; older machines, we have to use an UNSPEC to produce a SImode and move it\n+;; to another location, since SImode is not allowed in vector registers.\n+(define_insn \"*fctiw<u>z_<mode>_smallint\"\n+  [(set (match_operand:SI 0 \"vsx_register_operand\" \"=d,wi\")\n+\t(any_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+   && TARGET_VSX_SMALL_INTEGER\"\n+  \"@\n+   fctiw<u>z %0,%1\n+   xscvdp<su>xws %x0,%x1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+;; Combiner pattern to prevent moving the result of converting a floating point\n+;; value to 32-bit integer to GPR in order to save it.\n+(define_insn_and_split \"*fctiw<u>z_<mode>_mem\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=Z\")\n+\t(any_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"wa\")))\n+   (clobber (match_scratch:SI 2 \"=wa\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+   && TARGET_VSX_SMALL_INTEGER\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 2)\n+\t(any_fix:SI (match_dup 1)))\n+   (set (match_dup 0)\n+\t(match_dup 2))])\n+\n+;; Here, we use (set (reg) (unspec:DI [(fix:SI ...)] UNSPEC_FCTIWZ))\n+;; rather than (set (subreg:SI (reg)) (fix:SI ...))\n+;; because the first makes it clear that operand 0 is not live\n+;; before the instruction.\n (define_insn \"fctiwz_<mode>\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wi\")\n-\t(unspec:DI [(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\"))]\n+\t(unspec:DI [(fix:SI\n+\t\t     (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\"))]\n \t\t   UNSPEC_FCTIWZ))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n   \"@"}, {"sha": "5cd12864a5b7d51bbcb4471fb6156e90db1aa706", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8acb85754af19a055d7d00248ca869496dd4cda0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8acb85754af19a055d7d00248ca869496dd4cda0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8acb85754af19a055d7d00248ca869496dd4cda0", "patch": "@@ -1,3 +1,11 @@\n+2017-05-05  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/79038\n+\tPR target/79202\n+\tPR target/79203\n+\t* gcc.target/powerpc/ppc-round3.c: New test.\n+\t* gcc.target/powerpc/ppc-round2.c: Update expected code.\n+\n 2017-05-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/80632"}, {"sha": "2b14fb402a379e0332b51f41da54f71a09e99590", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-round2.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8acb85754af19a055d7d00248ca869496dd4cda0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-round2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8acb85754af19a055d7d00248ca869496dd4cda0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-round2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-round2.c?ref=8acb85754af19a055d7d00248ca869496dd4cda0", "patch": "@@ -3,18 +3,21 @@\n /* { dg-require-effective-target powerpc_p8vector_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n /* { dg-options \"-O2 -mcpu=power8\" } */\n-/* { dg-final { scan-assembler-times \"fcfid \"      2 } } */\n-/* { dg-final { scan-assembler-times \"fcfids \"     2 } } */\n-/* { dg-final { scan-assembler-times \"fctiwuz \\|xscvdpuxws \" 2 } } */\n+/* { dg-final { scan-assembler-times \"fcfid \\|xscvsxddp \"    2 } } */\n+/* { dg-final { scan-assembler-times \"fcfids \\|xscvsxdsp \"   2 } } */\n /* { dg-final { scan-assembler-times \"fctiwz \\|xscvdpsxws \"  2 } } */\n-/* { dg-final { scan-assembler-times \"mfvsrd \"     4 } } */\n-/* { dg-final { scan-assembler-times \"mtvsrwa \"    2 } } */\n-/* { dg-final { scan-assembler-times \"mtvsrwz \"    2 } } */\n-/* { dg-final { scan-assembler-not   \"lwz\"           } } */\n-/* { dg-final { scan-assembler-not   \"lfiwax \"       } } */\n-/* { dg-final { scan-assembler-not   \"lfiwzx \"       } } */\n-/* { dg-final { scan-assembler-not   \"stw\"           } } */\n-/* { dg-final { scan-assembler-not   \"stfiwx \"       } } */\n+/* { dg-final { scan-assembler-times \"fctiwuz \\|xscvdpuxws \" 2 } } */\n+/* { dg-final { scan-assembler-times {\\mmfvsrwz\\M}           2 } } */\n+/* { dg-final { scan-assembler-times {\\mmtvsrwz\\M}           2 } } */\n+/* { dg-final { scan-assembler-times {\\mvupkhsw\\M}           2 } } */\n+/* { dg-final { scan-assembler-times {\\mxxpermdi\\M}          2 } } */\n+/* { dg-final { scan-assembler-not   {\\mmfvsrd\\M}              } } */\n+/* { dg-final { scan-assembler-not   {\\mmtvsrwa\\M}             } } */\n+/* { dg-final { scan-assembler-not   {\\mlwz\\M}                 } } */\n+/* { dg-final { scan-assembler-not   {\\mlfiwax\\M}              } } */\n+/* { dg-final { scan-assembler-not   {\\mlfiwzx\\M}              } } */\n+/* { dg-final { scan-assembler-not   {\\mstw\\M}                 } } */\n+/* { dg-final { scan-assembler-not   {\\mstfiwx\\M}              } } */\n \n /* Make sure we don't have loads/stores to the GPR unit.  */\n double"}, {"sha": "33954d7bb460df2ece496cbd57bb2459d345ff01", "filename": "gcc/testsuite/gcc.target/powerpc/ppc-round3.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8acb85754af19a055d7d00248ca869496dd4cda0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-round3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8acb85754af19a055d7d00248ca869496dd4cda0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-round3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc-round3.c?ref=8acb85754af19a055d7d00248ca869496dd4cda0", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-O2 -mcpu=power9\" } */\n+/* { dg-final { scan-assembler-times \"fcfid \\|xscvsxddp \"    2 } } */\n+/* { dg-final { scan-assembler-times \"fcfids \\|xscvsxdsp \"   2 } } */\n+/* { dg-final { scan-assembler-times \"fctiwz \\|xscvdpsxws \"  2 } } */\n+/* { dg-final { scan-assembler-times \"fctiwuz \\|xscvdpuxws \" 2 } } */\n+/* { dg-final { scan-assembler-times {\\mvextsw2d\\M}          2 } } */\n+/* { dg-final { scan-assembler-times {\\mxxextractuw\\M}       2 } } */\n+/* { dg-final { scan-assembler-not   {\\mmfvsrd\\M}              } } */\n+/* { dg-final { scan-assembler-not   {\\mmfvsrwz\\M}             } } */\n+/* { dg-final { scan-assembler-not   {\\mmtvsrwa\\M}             } } */\n+/* { dg-final { scan-assembler-not   {\\mmtvsrwz\\M}             } } */\n+/* { dg-final { scan-assembler-not   {\\mlwz\\M}                 } } */\n+/* { dg-final { scan-assembler-not   {\\mlfiwax\\M}              } } */\n+/* { dg-final { scan-assembler-not   {\\mlfiwzx\\M}              } } */\n+/* { dg-final { scan-assembler-not   {\\mstw\\M}                 } } */\n+/* { dg-final { scan-assembler-not   {\\mstfiwx\\M}              } } */\n+\n+/* Make sure we don't have loads/stores to the GPR unit.  */\n+double\n+round_double_int (double a)\n+{\n+  return (double)(int)a;\n+}\n+\n+float\n+round_float_int (float a)\n+{\n+  return (float)(int)a;\n+}\n+\n+double\n+round_double_uint (double a)\n+{\n+  return (double)(unsigned int)a;\n+}\n+\n+float\n+round_float_uint (float a)\n+{\n+  return (float)(unsigned int)a;\n+}"}]}