{"sha": "d9e0a58787285a0753791dd83a5d831bbbc92117", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDllMGE1ODc4NzI4NWEwNzUzNzkxZGQ4M2E1ZDgzMWJiYmM5MjExNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2005-07-04T13:27:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-07-04T13:27:21Z"}, "message": "decl.c (prepend_attributes): New case.\n\n2005-07-04  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* decl.c (prepend_attributes) <Pragma_Linker_Constructor>: New case.\n\t<Pragma_Linker_Destructor>: Likewise.\n\n\t* einfo.ads (Has_Gigi_Rep_Item): Document Pragma_Linker_Constructor and\n\tPragma_Linker_Destructor.\n\n\t* gigi.h (attr_type): Add ATTR_LINK_CONSTRUCTOR and\n\tATTR_LINK_DESTRUCTOR.\n\t(static_ctors, static_dtors): New variables.\n\n\t* misc.c (gnat_expand_body): Output current function as constructor\n\tand destructor if requested.\n\n\t* par-prag.adb: Add processing for pragma Linker_Constructor and\n\tLinker_Destructor.\n\n\t* sem_prag.adb (Find_Unique_Parameterless_Procedure): New function\n\textracted from Check_Interrupt_Or_Attach_Handler.\n\t(Check_Interrupt_Or_Attach_Handler): Invoke it.\n\tImplement pragma Linker_Constructor and Linker_Destructor with the\n\thelp of Find_Unique_Parameterless_Procedure.\n\tReplace Name_Alias with Name_Target for pragma Linker_Alias.\n\n\t* snames.h, snames.ads, snames.adb:\n\tAdd Name_Linker_Constructor and Name_Linker_Destructor.\n\tAdd Pragma_Linker_Constructor and Pragma_Linker_Destructor.\n\t* snames.adb: Remove Name_Alias.\n\n\t* trans.c: Include cgraph.h.\n\t(build_global_cdtor): New function.\n\t(Compilation_Unit_to_gnu): Build global constructor and destructor if\n\tneeded.\n\t(tree_transform) <N_Identifier>: Substitute renaming of view-conversions\n\tof objects too.\n\t(addressable_p) <COMPONENT_REF>: Unconditionally test\n\tDECL_NONADDRESSABLE_P on STRICT_ALIGNMENT platforms.\n\n\t* utils.c (process_attributes) <ATTR_LINK_ALIAS>: Do not assemble the\n\tvariable if it is external.\n\n\t(static_ctors, static_dtors): New global variables.\n\t(process_attributes) <ATTR_LINK_CONSTRUCTOR>: New case.\n\t<ATTR_LINK_DESTRUCTOR>: Likewise.\n\t(end_subprog_body): Chain function as constructor and destructor\n\tif requested.\n\n\t* exp_util.adb (Force_Evaluation): Unconditionally invoke\n\tRemove_Side_Effects with Variable_Ref set to true.\n\t(Remove_Side_Effects): Handle scalar types first. Use a renaming\n\tfor non-scalar types even if Variable_Ref is true and for class-wide\n\texpressions.\n\nFrom-SVN: r101576", "tree": {"sha": "617e7a72024f1df19ef1395e2e890a2461922a3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/617e7a72024f1df19ef1395e2e890a2461922a3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9e0a58787285a0753791dd83a5d831bbbc92117", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9e0a58787285a0753791dd83a5d831bbbc92117", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9e0a58787285a0753791dd83a5d831bbbc92117", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9e0a58787285a0753791dd83a5d831bbbc92117/comments", "author": null, "committer": null, "parents": [{"sha": "c73ae90f23fab6c872b09e02b0d1e34727883056", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c73ae90f23fab6c872b09e02b0d1e34727883056", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c73ae90f23fab6c872b09e02b0d1e34727883056"}], "stats": {"total": 1577, "additions": 846, "deletions": 731}, "files": [{"sha": "fb6d002da074ee102a4611ff3a6b176274523aa6", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=d9e0a58787285a0753791dd83a5d831bbbc92117", "patch": "@@ -4523,6 +4523,14 @@ prepend_attributes (Entity_Id gnat_entity, struct attrib ** attr_list)\n \t    etype = ATTR_LINK_SECTION;\n \t    break;\n \n+\t  case Pragma_Linker_Constructor:\n+\t    etype = ATTR_LINK_CONSTRUCTOR;\n+\t    break;\n+\n+\t  case Pragma_Linker_Destructor:\n+\t    etype = ATTR_LINK_DESTRUCTOR;\n+\t    break;\n+\n \t  case Pragma_Weak_External:\n \t    etype = ATTR_WEAK_EXTERNAL;\n \t    break;"}, {"sha": "4ba4ad9a180faf04cfe236fd98103363727e0562", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=d9e0a58787285a0753791dd83a5d831bbbc92117", "patch": "@@ -1358,13 +1358,15 @@ package Einfo is\n \n --    Has_Gigi_Rep_Item (Flag82)\n --       This flag is set if the rep item chain (referenced by First_Rep_Item\n---       and linked through the Next_Rep_Item chain contains a representation\n+--       and linked through the Next_Rep_Item chain) contains a representation\n --       item that needs to be specially processed by Gigi, i.e. one of the\n --       following items:\n --\n --          Machine_Attribute pragma\n --          Linker_Alias pragma\n --          Linker_Section pragma\n+--          Linker_Constructor pragma\n+--          Linker_Destructor pragma\n --          Weak_External pragma\n --\n --       If this flag is set, then Gigi should scan the rep item chain to\n@@ -2244,7 +2246,7 @@ package Einfo is\n --    Is_Private_Composite (Flag107)\n --       Present in composite types that have a private component. Used to\n --       enforce the rule that operations on the composite type that depend\n---       on the fulll view of the component, do not become visible until the\n+--       on the full view of the component, do not become visible until the\n --       immediate scope of the composite type itself (7.3.1 (5)). Both this\n --       flag and Is_Limited_Composite are needed.\n \n@@ -6017,7 +6019,7 @@ package Einfo is\n      (E  : Entity_Id;\n       Id : Attribute_Id) return Node_Id;\n    --  Searches the Rep_Item chain for a given entity E, for an instance\n-   --  of an attribute definition clause with the given attibute Id Id. If\n+   --  of an attribute definition clause with the given attribute Id. If\n    --  found, the value returned is the N_Attribute_Definition_Clause node,\n    --  otherwise Empty is returned.\n \n@@ -6035,7 +6037,7 @@ package Einfo is\n      (E  : Entity_Id;\n       Id : Attribute_Id) return Boolean;\n    --  Searches the Rep_Item chain for a given entity E, for an instance\n-   --  of an attribute definition clause with the given attibute Id Id. If\n+   --  of an attribute definition clause with the given attribute Id. If\n    --  found, True is returned, otherwise False indicates that no matching\n    --  entry was found.\n "}, {"sha": "9004213d5f2d37961799eba32deaf4a685b7cde9", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 69, "deletions": 107, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=d9e0a58787285a0753791dd83a5d831bbbc92117", "patch": "@@ -1485,43 +1485,8 @@ package body Exp_Util is\n    ----------------------\n \n    procedure Force_Evaluation (Exp : Node_Id; Name_Req : Boolean := False) is\n-      Component_In_Lhs : Boolean := False;\n-      Par              : Node_Id;\n-\n    begin\n-      --  Loop to determine whether there is a component reference in the left\n-      --  hand side if Exp appears on the left side of an assignment statement.\n-      --  Needed to determine if form of result must be a variable.\n-\n-      Par := Exp;\n-      while Present (Par)\n-        and then\n-         (Nkind (Par) = N_Selected_Component\n-            or else\n-          Nkind (Par) = N_Indexed_Component)\n-      loop\n-         if Nkind (Parent (Par)) = N_Assignment_Statement\n-           and then Par = Name (Parent (Par))\n-         then\n-            Component_In_Lhs := True;\n-            exit;\n-         else\n-            Par := Parent (Par);\n-         end if;\n-      end loop;\n-\n-      --  If the expression is a selected component, it is being evaluated as\n-      --  part of a discriminant check. If it is part of a left-hand side, this\n-      --  is the last use of its value and it is safe to create a renaming for\n-      --  it, rather than a temporary. In addition, if it is not an addressable\n-      --  field, creating a temporary may be a problem for gigi, or might drop\n-      --  the value of the assignment. Therefore, if the expression is on the\n-      --  lhs of an assignment, remove side effects without requiring a\n-      --  temporary, and create a renaming. (See remove_side_effects for\n-      --  details).\n-\n-      Remove_Side_Effects\n-        (Exp, Name_Req, Variable_Ref => not Component_In_Lhs);\n+      Remove_Side_Effects (Exp, Name_Req, Variable_Ref => True);\n    end Force_Evaluation;\n \n    ------------------------\n@@ -3828,10 +3793,37 @@ package body Exp_Util is\n \n       Scope_Suppress := (others => True);\n \n+      --  If it is a scalar type and we need to capture the value, just\n+      --  make a copy.  Likewise for a function call.  And if we have a\n+      --  volatile variable and Nam_Req is not set (see comments above\n+      --  for Side_Effect_Free).\n+\n+      if Is_Elementary_Type (Exp_Type)\n+        and then (Variable_Ref\n+                   or else Nkind (Exp) = N_Function_Call\n+                   or else (not Name_Req\n+                             and then Is_Entity_Name (Exp)\n+                             and then Treat_As_Volatile (Entity (Exp))))\n+      then\n+\n+         Def_Id := Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n+         Set_Etype (Def_Id, Exp_Type);\n+         Res := New_Reference_To (Def_Id, Loc);\n+\n+         E :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Def_Id,\n+             Object_Definition   => New_Reference_To (Exp_Type, Loc),\n+             Constant_Present    => True,\n+             Expression          => Relocate_Node (Exp));\n+\n+         Set_Assignment_OK (E);\n+         Insert_Action (Exp, E);\n+\n       --  If the expression has the form v.all then we can just capture\n       --  the pointer, and then do an explicit dereference on the result.\n \n-      if Nkind (Exp) = N_Explicit_Dereference then\n+      elsif Nkind (Exp) = N_Explicit_Dereference then\n          Def_Id :=\n            Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n          Res :=\n@@ -3873,26 +3865,51 @@ package body Exp_Util is\n          Scope_Suppress := Svg_Suppress;\n          return;\n \n+      --  If this is an unchecked conversion that Gigi can't handle, make\n+      --  a copy or a use a renaming to capture the value.\n+\n+      elsif Nkind (Exp) = N_Unchecked_Type_Conversion\n+        and then not Safe_Unchecked_Type_Conversion (Exp)\n+      then\n+         if Controlled_Type (Etype (Exp)) then\n+\n+            --  Use a renaming to capture the expression, rather than create\n+            --  a controlled temporary.\n+\n+            Def_Id := Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n+            Res := New_Reference_To (Def_Id, Loc);\n+\n+            Insert_Action (Exp,\n+              Make_Object_Renaming_Declaration (Loc,\n+                Defining_Identifier => Def_Id,\n+                Subtype_Mark        => New_Reference_To (Exp_Type, Loc),\n+                Name                => Relocate_Node (Exp)));\n+\n+         else\n+            Def_Id := Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n+            Set_Etype (Def_Id, Exp_Type);\n+            Res := New_Reference_To (Def_Id, Loc);\n+\n+            E :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Def_Id,\n+                Object_Definition   => New_Reference_To (Exp_Type, Loc),\n+                Constant_Present    => not Is_Variable (Exp),\n+                Expression          => Relocate_Node (Exp));\n+\n+            Set_Assignment_OK (E);\n+            Insert_Action (Exp, E);\n+         end if;\n+\n       --  For expressions that denote objects, we can use a renaming scheme.\n       --  We skip using this if we have a volatile variable and we do not\n       --  have Nam_Req set true (see comments above for Side_Effect_Free).\n-      --  We also skip this scheme for class-wide expressions in order to\n-      --  avoid recursive expansion (see Expand_N_Object_Renaming_Declaration)\n-      --  If the object is a function call, we need to create a temporary and\n-      --  not a renaming.\n-\n-      --  Note that we could use ordinary object declarations in the case of\n-      --  expressions not appearing as lvalues. That is left as a possible\n-      --  optimization in the future but we prefer to generate renamings\n-      --  right now, since we may indeed be transforming an lvalue.\n \n       elsif Is_Object_Reference (Exp)\n         and then Nkind (Exp) /= N_Function_Call\n-        and then not Variable_Ref\n         and then (Name_Req\n                    or else not Is_Entity_Name (Exp)\n                    or else not Treat_As_Volatile (Entity (Exp)))\n-        and then not Is_Class_Wide_Type (Exp_Type)\n       then\n          Def_Id := Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n \n@@ -3917,12 +3934,6 @@ package body Exp_Util is\n                   New_Reference_To (Base_Type (Etype (Prefix (Exp))), Loc),\n                 Name                => Relocate_Node (Prefix (Exp))));\n \n-            --  The temporary must be elaborated by gigi, and is of course\n-            --  not to be replaced in-line by the expression it renames,\n-            --  which would defeat the purpose of removing the side-effect.\n-\n-            Set_Is_Renaming_Of_Object (Def_Id, False);\n-\n          else\n             Res := New_Reference_To (Def_Id, Loc);\n \n@@ -3932,62 +3943,13 @@ package body Exp_Util is\n                 Subtype_Mark        => New_Reference_To (Exp_Type, Loc),\n                 Name                => Relocate_Node (Exp)));\n \n-            Set_Is_Renaming_Of_Object (Def_Id, False);\n          end if;\n \n-      --  If it is a scalar type, just make a copy\n-\n-      elsif Is_Elementary_Type (Exp_Type) then\n-         Def_Id := Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n-         Set_Etype (Def_Id, Exp_Type);\n-         Res := New_Reference_To (Def_Id, Loc);\n-\n-         E :=\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Def_Id,\n-             Object_Definition   => New_Reference_To (Exp_Type, Loc),\n-             Constant_Present    => True,\n-             Expression          => Relocate_Node (Exp));\n-\n-         Set_Assignment_OK (E);\n-         Insert_Action (Exp, E);\n-\n-      --  Always use a renaming for an unchecked conversion\n-      --  If this is an unchecked conversion that Gigi can't handle, make\n-      --  a copy or a use a renaming to capture the value.\n-\n-      elsif Nkind (Exp) = N_Unchecked_Type_Conversion\n-        and then not Safe_Unchecked_Type_Conversion (Exp)\n-      then\n-         if Controlled_Type (Etype (Exp)) then\n-\n-            --  Use a renaming to capture the expression, rather than create\n-            --  a controlled temporary.\n-\n-            Def_Id := Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n-            Res := New_Reference_To (Def_Id, Loc);\n-\n-            Insert_Action (Exp,\n-              Make_Object_Renaming_Declaration (Loc,\n-                Defining_Identifier => Def_Id,\n-                Subtype_Mark        => New_Reference_To (Exp_Type, Loc),\n-                Name                => Relocate_Node (Exp)));\n-\n-         else\n-            Def_Id := Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n-            Set_Etype (Def_Id, Exp_Type);\n-            Res := New_Reference_To (Def_Id, Loc);\n-\n-            E :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Def_Id,\n-                Object_Definition   => New_Reference_To (Exp_Type, Loc),\n-                Constant_Present    => not Is_Variable (Exp),\n-                Expression          => Relocate_Node (Exp));\n+         --  The temporary must be elaborated by gigi, and is of course\n+         --  not to be replaced in-line by the expression it renames,\n+         --  which would defeat the purpose of removing the side-effect.\n \n-            Set_Assignment_OK (E);\n-            Insert_Action (Exp, E);\n-         end if;\n+         Set_Is_Renaming_Of_Object (Def_Id, False);\n \n       --  Otherwise we generate a reference to the value\n "}, {"sha": "0adf64445ff02cd2d9a394685b7eefa14c6dd1c6", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=d9e0a58787285a0753791dd83a5d831bbbc92117", "patch": "@@ -301,8 +301,15 @@ extern int force_global;\n \f\n /* Data structures used to represent attributes.  */\n \n-enum attr_type {ATTR_MACHINE_ATTRIBUTE, ATTR_LINK_ALIAS,\n-\t\tATTR_LINK_SECTION, ATTR_WEAK_EXTERNAL};\n+enum attr_type\n+{\n+  ATTR_MACHINE_ATTRIBUTE,\n+  ATTR_LINK_ALIAS,\n+  ATTR_LINK_SECTION,\n+  ATTR_LINK_CONSTRUCTOR,\n+  ATTR_LINK_DESTRUCTOR,\n+  ATTR_WEAK_EXTERNAL\n+};\n \n struct attrib\n {\n@@ -359,6 +366,9 @@ enum standard_datatypes\n extern GTY(()) tree gnat_std_decls[(int) ADT_LAST];\n extern GTY(()) tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n \n+extern GTY(()) tree static_ctors;\n+extern GTY(()) tree static_dtors;\n+\n #define longest_float_type_node gnat_std_decls[(int) ADT_longest_float_type]\n #define void_type_decl_node gnat_std_decls[(int) ADT_void_type_decl]\n #define except_type_node gnat_std_decls[(int) ADT_except_type]"}, {"sha": "819e27572a9d63b15ae3038dcc43bf51ea7ddd8e", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=d9e0a58787285a0753791dd83a5d831bbbc92117", "patch": "@@ -462,9 +462,9 @@ gnat_init_gcc_eh (void)\n   using_eh_for_cleanups ();\n \n   eh_personality_libfunc = init_one_libfunc (\"__gnat_eh_personality\");\n-  default_init_unwind_resume_libfunc ();\n   lang_eh_type_covers = gnat_eh_type_covers;\n   lang_eh_runtime_type = gnat_eh_runtime_type;\n+  default_init_unwind_resume_libfunc ();\n \n   /* Turn on -fexceptions and -fnon-call-exceptions. The first one triggers\n      the generation of the necessary exception runtime tables. The second one\n@@ -634,6 +634,14 @@ gnat_expand_body (tree gnu_decl)\n     return;\n \n   tree_rest_of_compilation (gnu_decl);\n+\n+  if (DECL_STATIC_CONSTRUCTOR (gnu_decl) && targetm.have_ctors_dtors)\n+    targetm.asm_out.constructor (XEXP (DECL_RTL (gnu_decl), 0),\n+                                 DEFAULT_INIT_PRIORITY);\n+\n+  if (DECL_STATIC_DESTRUCTOR (gnu_decl) && targetm.have_ctors_dtors)\n+    targetm.asm_out.destructor (XEXP (DECL_RTL (gnu_decl), 0),\n+                                DEFAULT_INIT_PRIORITY);\n }\n \n /* Adjusts the RLI used to layout a record after all the fields have been"}, {"sha": "fa17a3faec179c39079f8144a6c78b6b18c33f36", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=d9e0a58787285a0753791dd83a5d831bbbc92117", "patch": "@@ -1054,6 +1054,8 @@ begin\n            Pragma_License                      |\n            Pragma_Link_With                    |\n            Pragma_Linker_Alias                 |\n+           Pragma_Linker_Constructor           |\n+           Pragma_Linker_Destructor            |\n            Pragma_Linker_Options               |\n            Pragma_Linker_Section               |\n            Pragma_Locking_Policy               |"}, {"sha": "797ab246ad1d15765cb21b2b4b23c01c4cf78264", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 146, "deletions": 92, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=d9e0a58787285a0753791dd83a5d831bbbc92117", "patch": "@@ -452,6 +452,13 @@ package body Sem_Prag is\n       --  unit pragma that is not a compilation unit pragma, then the\n       --  identifier must be visible.\n \n+      function Find_Unique_Parameterless_Procedure\n+        (Name : Entity_Id;\n+         Arg  : Node_Id) return Entity_Id;\n+      --  Used for a procedure pragma to find the unique parameterless\n+      --  procedure identified by Name, returns it if it exists, otherwise\n+      --  errors out and uses Arg as the pragma argument for the message.\n+\n       procedure Gather_Associations\n         (Names : Name_List;\n          Args  : out Args_List);\n@@ -1075,107 +1082,41 @@ package body Sem_Prag is\n \n       procedure Check_Interrupt_Or_Attach_Handler is\n          Arg1_X : constant Node_Id := Expression (Arg1);\n+         Handler_Proc, Proc_Scope : Entity_Id;\n \n       begin\n          Analyze (Arg1_X);\n \n-         if not Is_Entity_Name (Arg1_X) then\n-            Error_Pragma_Arg\n-              (\"argument of pragma% must be entity name\", Arg1);\n-\n-         elsif Prag_Id = Pragma_Interrupt_Handler then\n+         if Prag_Id = Pragma_Interrupt_Handler then\n             Check_Restriction (No_Dynamic_Attachment, N);\n          end if;\n \n-         declare\n-            Handler_Proc : Entity_Id := Empty;\n-            Proc_Scope   : Entity_Id;\n-            Found        : Boolean := False;\n-\n-         begin\n-            if not Is_Overloaded (Arg1_X) then\n-               Handler_Proc := Entity (Arg1_X);\n-\n-            else\n-               declare\n-                  It    : Interp;\n-                  Index : Interp_Index;\n-\n-               begin\n-                  Get_First_Interp (Arg1_X, Index, It);\n-                  while Present (It.Nam) loop\n-                     Handler_Proc := It.Nam;\n-\n-                     if Ekind (Handler_Proc) = E_Procedure\n-                       and then No (First_Formal (Handler_Proc))\n-                     then\n-                        if not Found then\n-                           Found := True;\n-                           Set_Entity (Arg1_X, Handler_Proc);\n-                           Set_Is_Overloaded (Arg1_X, False);\n-                        else\n-                           Error_Pragma_Arg\n-                             (\"ambiguous handler name for pragma% \", Arg1);\n-                        end if;\n-                     end if;\n-\n-                     Get_Next_Interp (Index, It);\n-                  end loop;\n-\n-                  if not Found then\n-                     Error_Pragma_Arg\n-                       (\"argument of pragma% must be parameterless procedure\",\n-                        Arg1);\n-                  else\n-                     Handler_Proc := Entity (Arg1_X);\n-                  end if;\n-               end;\n-            end if;\n-\n-            Proc_Scope := Scope (Handler_Proc);\n+         Handler_Proc := Find_Unique_Parameterless_Procedure (Arg1_X, Arg1);\n+         Proc_Scope := Scope (Handler_Proc);\n \n-            --  On AAMP only, a pragma Interrupt_Handler is supported for\n-            --  nonprotected parameterless procedures.\n+         --  On AAMP only, a pragma Interrupt_Handler is supported for\n+         --  nonprotected parameterless procedures.\n \n-            if AAMP_On_Target\n-              and then Prag_Id = Pragma_Interrupt_Handler\n-            then\n-               if Ekind (Handler_Proc) /= E_Procedure then\n-                  Error_Pragma_Arg\n-                    (\"argument of pragma% must be a procedure\", Arg1);\n-               end if;\n-\n-            elsif Ekind (Handler_Proc) /= E_Procedure\n-              or else Ekind (Proc_Scope) /= E_Protected_Type\n-            then\n+         if not AAMP_On_Target\n+           or else Prag_Id = Pragma_Attach_Handler\n+         then\n+            if Ekind (Proc_Scope) /= E_Protected_Type then\n                Error_Pragma_Arg\n                  (\"argument of pragma% must be protected procedure\", Arg1);\n             end if;\n \n-            if (not AAMP_On_Target or else Prag_Id = Pragma_Attach_Handler)\n-              and then Ekind (Proc_Scope) = E_Protected_Type\n-            then\n-               if Parent (N) /=\n-                    Protected_Definition (Parent (Proc_Scope))\n-               then\n-                  Error_Pragma (\"pragma% must be in protected definition\");\n-               end if;\n-            end if;\n-\n-            if not Is_Library_Level_Entity (Proc_Scope)\n-              or else (AAMP_On_Target\n-                        and then not Is_Library_Level_Entity (Handler_Proc))\n-            then\n-               Error_Pragma_Arg\n-                 (\"pragma% requires library-level entity\", Arg1);\n+            if Parent (N) /= Protected_Definition (Parent (Proc_Scope)) then\n+               Error_Pragma (\"pragma% must be in protected definition\");\n             end if;\n+         end if;\n \n-            if Present (First_Formal (Handler_Proc)) then\n-               Error_Pragma_Arg\n-                 (\"argument of pragma% must be parameterless procedure\",\n-                  Arg1);\n-            end if;\n-         end;\n+         if not Is_Library_Level_Entity (Proc_Scope)\n+           or else (AAMP_On_Target\n+                     and then not Is_Library_Level_Entity (Handler_Proc))\n+         then\n+            Error_Pragma_Arg\n+              (\"argument for pragma% must be library level entity\", Arg1);\n+         end if;\n       end Check_Interrupt_Or_Attach_Handler;\n \n       -------------------------------------------\n@@ -1614,9 +1555,74 @@ package body Sem_Prag is\n          else\n             Analyze (Id);\n          end if;\n-\n       end Find_Program_Unit_Name;\n \n+      -----------------------------------------\n+      -- Find_Unique_Parameterless_Procedure --\n+      -----------------------------------------\n+\n+      function Find_Unique_Parameterless_Procedure\n+        (Name : Entity_Id;\n+         Arg  : Node_Id) return Entity_Id\n+      is\n+         Proc : Entity_Id := Empty;\n+\n+      begin\n+         --  The body of this procedure needs some comments ???\n+\n+         if not Is_Entity_Name (Name) then\n+            Error_Pragma_Arg\n+              (\"argument of pragma% must be entity name\", Arg);\n+\n+         elsif not Is_Overloaded (Name) then\n+            Proc := Entity (Name);\n+\n+            if Ekind (Proc) /= E_Procedure\n+                 or else Present (First_Formal (Proc)) then\n+               Error_Pragma_Arg\n+                 (\"argument of pragma% must be parameterless procedure\", Arg);\n+            end if;\n+\n+         else\n+            declare\n+               Found : Boolean := False;\n+               It    : Interp;\n+               Index : Interp_Index;\n+\n+            begin\n+               Get_First_Interp (Name, Index, It);\n+               while Present (It.Nam) loop\n+                  Proc := It.Nam;\n+\n+                  if Ekind (Proc) = E_Procedure\n+                    and then No (First_Formal (Proc))\n+                  then\n+                     if not Found then\n+                        Found := True;\n+                        Set_Entity (Name, Proc);\n+                        Set_Is_Overloaded (Name, False);\n+                     else\n+                        Error_Pragma_Arg\n+                          (\"ambiguous handler name for pragma% \", Arg);\n+                     end if;\n+                  end if;\n+\n+                  Get_Next_Interp (Index, It);\n+               end loop;\n+\n+               if not Found then\n+                  Error_Pragma_Arg\n+                    (\"argument of pragma% must be parameterless procedure\",\n+                     Arg);\n+               else\n+                  Proc := Entity (Name);\n+               end if;\n+            end;\n+         end if;\n+\n+         return Proc;\n+      end Find_Unique_Parameterless_Procedure;\n+\n       -------------------------\n       -- Gather_Associations --\n       -------------------------\n@@ -2168,7 +2174,7 @@ package body Sem_Prag is\n             Comp_Unit := Get_Source_Unit (E);\n             Set_Convention_From_Pragma (E);\n \n-            --  Treat a pragma Import as an implicit body, for GPS use.\n+            --  Treat a pragma Import as an implicit body, for GPS use\n \n             if Prag_Id = Pragma_Import then\n                   Generate_Reference (E, Id, 'b');\n@@ -4403,7 +4409,7 @@ package body Sem_Prag is\n \n             Lib_Entity := Find_Lib_Unit_Name;\n \n-            --  This pragma should only apply to a RCI unit (RM E.2.3(23)).\n+            --  This pragma should only apply to a RCI unit (RM E.2.3(23))\n \n             if Present (Lib_Entity)\n               and then not Debug_Flag_U\n@@ -7659,14 +7665,14 @@ package body Sem_Prag is\n \n          --  pragma Linker_Alias (\n          --      [Entity =>]  LOCAL_NAME\n-         --      [Alias  =>]  static_string_EXPRESSION);\n+         --      [Target =>]  static_string_EXPRESSION);\n \n          when Pragma_Linker_Alias =>\n             GNAT_Pragma;\n-            Check_Arg_Order ((Name_Entity, Name_Alias));\n+            Check_Arg_Order ((Name_Entity, Name_Target));\n             Check_Arg_Count (2);\n             Check_Optional_Identifier (Arg1, Name_Entity);\n-            Check_Optional_Identifier (Arg2, Name_Alias);\n+            Check_Optional_Identifier (Arg2, Name_Target);\n             Check_Arg_Is_Library_Level_Local_Name (Arg1);\n             Check_Arg_Is_Static_Expression (Arg2, Standard_String);\n \n@@ -7681,6 +7687,52 @@ package body Sem_Prag is\n                Set_Has_Gigi_Rep_Item (Entity (Expression (Arg1)));\n             end if;\n \n+         ------------------------\n+         -- Linker_Constructor --\n+         ------------------------\n+\n+         --  pragma Linker_Constructor (procedure_LOCAL_NAME);\n+\n+         --  Code is shared with Linker_Destructor\n+\n+         -----------------------\n+         -- Linker_Destructor --\n+         -----------------------\n+\n+         --  pragma Linker_Destructor (procedure_LOCAL_NAME);\n+\n+         when Pragma_Linker_Constructor |\n+              Pragma_Linker_Destructor =>\n+         Linker_Constructor : declare\n+            Arg1_X : Node_Id;\n+            Proc   : Entity_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_Arg_Count (1);\n+            Check_No_Identifiers;\n+            Check_Arg_Is_Local_Name (Arg1);\n+            Arg1_X := Expression (Arg1);\n+            Analyze (Arg1_X);\n+            Proc := Find_Unique_Parameterless_Procedure (Arg1_X, Arg1);\n+\n+            if not Is_Library_Level_Entity (Proc) then\n+               Error_Pragma_Arg\n+                (\"argument for pragma% must be library level entity\", Arg1);\n+            end if;\n+\n+            --  The only processing required is to link this item on to the\n+            --  list of rep items for the given entity. This is accomplished\n+            --  by the call to Rep_Item_Too_Late (when no error is detected\n+            --  and False is returned).\n+\n+            if Rep_Item_Too_Late (Proc, N) then\n+               return;\n+            else\n+               Set_Has_Gigi_Rep_Item (Proc);\n+            end if;\n+         end Linker_Constructor;\n+\n          --------------------\n          -- Linker_Options --\n          --------------------\n@@ -10555,6 +10607,8 @@ package body Sem_Prag is\n       Pragma_License                      => -1,\n       Pragma_Link_With                    => -1,\n       Pragma_Linker_Alias                 => -1,\n+      Pragma_Linker_Constructor           => -1,\n+      Pragma_Linker_Destructor            => -1,\n       Pragma_Linker_Options               => -1,\n       Pragma_Linker_Section               => -1,\n       Pragma_List                         => -1,"}, {"sha": "e98f4c5b43c24e186268bd16cb77cd497ab4cc04", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=d9e0a58787285a0753791dd83a5d831bbbc92117", "patch": "@@ -262,6 +262,8 @@ package body Snames is\n      \"keep_names#\" &\n      \"link_with#\" &\n      \"linker_alias#\" &\n+     \"linker_constructor#\" &\n+     \"linker_destructor#\" &\n      \"linker_options#\" &\n      \"linker_section#\" &\n      \"list#\" &\n@@ -322,7 +324,6 @@ package body Snames is\n      \"default#\" &\n      \"dll#\" &\n      \"win32#\" &\n-     \"alias#\" &\n      \"as_is#\" &\n      \"attribute_name#\" &\n      \"body_file_name#\" &"}, {"sha": "425f707935797de84a73069527890b2f5cfe3d7f", "filename": "gcc/ada/snames.ads", "status": "modified", "additions": 471, "deletions": 468, "changes": 939, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=d9e0a58787285a0753791dd83a5d831bbbc92117", "patch": "@@ -427,32 +427,34 @@ package Snames is\n    Name_Keep_Names                     : constant Name_Id := N + 202; -- GNAT\n    Name_Link_With                      : constant Name_Id := N + 203; -- GNAT\n    Name_Linker_Alias                   : constant Name_Id := N + 204; -- GNAT\n-   Name_Linker_Options                 : constant Name_Id := N + 205;\n-   Name_Linker_Section                 : constant Name_Id := N + 206; -- GNAT\n-   Name_List                           : constant Name_Id := N + 207;\n-   Name_Machine_Attribute              : constant Name_Id := N + 208; -- GNAT\n-   Name_Main                           : constant Name_Id := N + 209; -- GNAT\n-   Name_Main_Storage                   : constant Name_Id := N + 210; -- GNAT\n-   Name_Memory_Size                    : constant Name_Id := N + 211; -- Ada 83\n-   Name_No_Return                      : constant Name_Id := N + 212; -- GNAT\n-   Name_Obsolescent                    : constant Name_Id := N + 213; -- GNAT\n-   Name_Optimize                       : constant Name_Id := N + 214;\n-   Name_Optional_Overriding            : constant Name_Id := N + 215; -- Ada 05\n-   Name_Pack                           : constant Name_Id := N + 216;\n-   Name_Page                           : constant Name_Id := N + 217;\n-   Name_Passive                        : constant Name_Id := N + 218; -- GNAT\n-   Name_Preelaborate                   : constant Name_Id := N + 219;\n-   Name_Preelaborate_05                : constant Name_Id := N + 220; -- GNAT\n-   Name_Priority                       : constant Name_Id := N + 221;\n-   Name_Psect_Object                   : constant Name_Id := N + 222; -- VMS\n-   Name_Pure                           : constant Name_Id := N + 223;\n-   Name_Pure_05                        : constant Name_Id := N + 224; -- GNAT\n-   Name_Pure_Function                  : constant Name_Id := N + 225; -- GNAT\n-   Name_Remote_Call_Interface          : constant Name_Id := N + 226;\n-   Name_Remote_Types                   : constant Name_Id := N + 227;\n-   Name_Share_Generic                  : constant Name_Id := N + 228; -- GNAT\n-   Name_Shared                         : constant Name_Id := N + 229; -- Ada 83\n-   Name_Shared_Passive                 : constant Name_Id := N + 230;\n+   Name_Linker_Constructor             : constant Name_Id := N + 205; -- GNAT\n+   Name_Linker_Destructor              : constant Name_Id := N + 206; -- GNAT\n+   Name_Linker_Options                 : constant Name_Id := N + 207;\n+   Name_Linker_Section                 : constant Name_Id := N + 208; -- GNAT\n+   Name_List                           : constant Name_Id := N + 209;\n+   Name_Machine_Attribute              : constant Name_Id := N + 210; -- GNAT\n+   Name_Main                           : constant Name_Id := N + 211; -- GNAT\n+   Name_Main_Storage                   : constant Name_Id := N + 212; -- GNAT\n+   Name_Memory_Size                    : constant Name_Id := N + 213; -- Ada 83\n+   Name_No_Return                      : constant Name_Id := N + 214; -- GNAT\n+   Name_Obsolescent                    : constant Name_Id := N + 215; -- GNAT\n+   Name_Optimize                       : constant Name_Id := N + 216;\n+   Name_Optional_Overriding            : constant Name_Id := N + 217; -- Ada 05\n+   Name_Pack                           : constant Name_Id := N + 218;\n+   Name_Page                           : constant Name_Id := N + 219;\n+   Name_Passive                        : constant Name_Id := N + 220; -- GNAT\n+   Name_Preelaborate                   : constant Name_Id := N + 221;\n+   Name_Preelaborate_05                : constant Name_Id := N + 222; -- GNAT\n+   Name_Priority                       : constant Name_Id := N + 223;\n+   Name_Psect_Object                   : constant Name_Id := N + 224; -- VMS\n+   Name_Pure                           : constant Name_Id := N + 225;\n+   Name_Pure_05                        : constant Name_Id := N + 226; -- GNAT\n+   Name_Pure_Function                  : constant Name_Id := N + 227; -- GNAT\n+   Name_Remote_Call_Interface          : constant Name_Id := N + 228;\n+   Name_Remote_Types                   : constant Name_Id := N + 229;\n+   Name_Share_Generic                  : constant Name_Id := N + 230; -- GNAT\n+   Name_Shared                         : constant Name_Id := N + 231; -- Ada 83\n+   Name_Shared_Passive                 : constant Name_Id := N + 232;\n \n    --  Note: Storage_Size is not in this list because its name matches the\n    --  name of the corresponding attribute. However, it is included in the\n@@ -462,27 +464,27 @@ package Snames is\n    --  Note: Storage_Unit is also omitted from the list because of a clash\n    --  with an attribute name, and is treated similarly.\n \n-   Name_Source_Reference               : constant Name_Id := N + 231; -- GNAT\n-   Name_Stream_Convert                 : constant Name_Id := N + 232; -- GNAT\n-   Name_Subtitle                       : constant Name_Id := N + 233; -- GNAT\n-   Name_Suppress_All                   : constant Name_Id := N + 234; -- GNAT\n-   Name_Suppress_Debug_Info            : constant Name_Id := N + 235; -- GNAT\n-   Name_Suppress_Initialization        : constant Name_Id := N + 236; -- GNAT\n-   Name_System_Name                    : constant Name_Id := N + 237; -- Ada 83\n-   Name_Task_Info                      : constant Name_Id := N + 238; -- GNAT\n-   Name_Task_Name                      : constant Name_Id := N + 239; -- GNAT\n-   Name_Task_Storage                   : constant Name_Id := N + 240; -- VMS\n-   Name_Thread_Body                    : constant Name_Id := N + 241; -- GNAT\n-   Name_Time_Slice                     : constant Name_Id := N + 242; -- GNAT\n-   Name_Title                          : constant Name_Id := N + 243; -- GNAT\n-   Name_Unchecked_Union                : constant Name_Id := N + 244; -- GNAT\n-   Name_Unimplemented_Unit             : constant Name_Id := N + 245; -- GNAT\n-   Name_Unreferenced                   : constant Name_Id := N + 246; -- GNAT\n-   Name_Unreserve_All_Interrupts       : constant Name_Id := N + 247; -- GNAT\n-   Name_Volatile                       : constant Name_Id := N + 248;\n-   Name_Volatile_Components            : constant Name_Id := N + 249;\n-   Name_Weak_External                  : constant Name_Id := N + 250; -- GNAT\n-   Last_Pragma_Name                    : constant Name_Id := N + 250;\n+   Name_Source_Reference               : constant Name_Id := N + 233; -- GNAT\n+   Name_Stream_Convert                 : constant Name_Id := N + 234; -- GNAT\n+   Name_Subtitle                       : constant Name_Id := N + 235; -- GNAT\n+   Name_Suppress_All                   : constant Name_Id := N + 236; -- GNAT\n+   Name_Suppress_Debug_Info            : constant Name_Id := N + 237; -- GNAT\n+   Name_Suppress_Initialization        : constant Name_Id := N + 238; -- GNAT\n+   Name_System_Name                    : constant Name_Id := N + 239; -- Ada 83\n+   Name_Task_Info                      : constant Name_Id := N + 240; -- GNAT\n+   Name_Task_Name                      : constant Name_Id := N + 241; -- GNAT\n+   Name_Task_Storage                   : constant Name_Id := N + 242; -- VMS\n+   Name_Thread_Body                    : constant Name_Id := N + 243; -- GNAT\n+   Name_Time_Slice                     : constant Name_Id := N + 244; -- GNAT\n+   Name_Title                          : constant Name_Id := N + 245; -- GNAT\n+   Name_Unchecked_Union                : constant Name_Id := N + 246; -- GNAT\n+   Name_Unimplemented_Unit             : constant Name_Id := N + 247; -- GNAT\n+   Name_Unreferenced                   : constant Name_Id := N + 248; -- GNAT\n+   Name_Unreserve_All_Interrupts       : constant Name_Id := N + 249; -- GNAT\n+   Name_Volatile                       : constant Name_Id := N + 250;\n+   Name_Volatile_Components            : constant Name_Id := N + 251;\n+   Name_Weak_External                  : constant Name_Id := N + 252; -- GNAT\n+   Last_Pragma_Name                    : constant Name_Id := N + 252;\n \n    --  Language convention names for pragma Convention/Export/Import/Interface\n    --  Note that Name_C is not included in this list, since it was already\n@@ -493,115 +495,114 @@ package Snames is\n    --  Entry and Protected, this is because these conventions cannot be\n    --  specified by a pragma.\n \n-   First_Convention_Name               : constant Name_Id := N + 251;\n-   Name_Ada                            : constant Name_Id := N + 251;\n-   Name_Assembler                      : constant Name_Id := N + 252;\n-   Name_COBOL                          : constant Name_Id := N + 253;\n-   Name_CPP                            : constant Name_Id := N + 254;\n-   Name_Fortran                        : constant Name_Id := N + 255;\n-   Name_Intrinsic                      : constant Name_Id := N + 256;\n-   Name_Java                           : constant Name_Id := N + 257;\n-   Name_Stdcall                        : constant Name_Id := N + 258;\n-   Name_Stubbed                        : constant Name_Id := N + 259;\n-   Last_Convention_Name                : constant Name_Id := N + 259;\n+   First_Convention_Name               : constant Name_Id := N + 253;\n+   Name_Ada                            : constant Name_Id := N + 253;\n+   Name_Assembler                      : constant Name_Id := N + 254;\n+   Name_COBOL                          : constant Name_Id := N + 255;\n+   Name_CPP                            : constant Name_Id := N + 256;\n+   Name_Fortran                        : constant Name_Id := N + 257;\n+   Name_Intrinsic                      : constant Name_Id := N + 258;\n+   Name_Java                           : constant Name_Id := N + 259;\n+   Name_Stdcall                        : constant Name_Id := N + 260;\n+   Name_Stubbed                        : constant Name_Id := N + 261;\n+   Last_Convention_Name                : constant Name_Id := N + 261;\n \n    --  The following names are preset as synonyms for Assembler\n \n-   Name_Asm                            : constant Name_Id := N + 260;\n-   Name_Assembly                       : constant Name_Id := N + 261;\n+   Name_Asm                            : constant Name_Id := N + 262;\n+   Name_Assembly                       : constant Name_Id := N + 263;\n \n    --  The following names are preset as synonyms for C\n \n-   Name_Default                        : constant Name_Id := N + 262;\n+   Name_Default                        : constant Name_Id := N + 264;\n    --  Name_Exernal (previously defined as pragma)\n \n    --  The following names are present as synonyms for Stdcall\n \n-   Name_DLL                            : constant Name_Id := N + 263;\n-   Name_Win32                          : constant Name_Id := N + 264;\n+   Name_DLL                            : constant Name_Id := N + 265;\n+   Name_Win32                          : constant Name_Id := N + 266;\n \n    --  Other special names used in processing pragmas\n \n-   Name_Alias                          : constant Name_Id := N + 265;\n-   Name_As_Is                          : constant Name_Id := N + 266;\n-   Name_Attribute_Name                 : constant Name_Id := N + 267;\n-   Name_Body_File_Name                 : constant Name_Id := N + 268;\n-   Name_Boolean_Entry_Barriers         : constant Name_Id := N + 269;\n-   Name_Check                          : constant Name_Id := N + 270;\n-   Name_Casing                         : constant Name_Id := N + 271;\n-   Name_Code                           : constant Name_Id := N + 272;\n-   Name_Component                      : constant Name_Id := N + 273;\n-   Name_Component_Size_4               : constant Name_Id := N + 274;\n-   Name_Copy                           : constant Name_Id := N + 275;\n-   Name_D_Float                        : constant Name_Id := N + 276;\n-   Name_Descriptor                     : constant Name_Id := N + 277;\n-   Name_Dot_Replacement                : constant Name_Id := N + 278;\n-   Name_Dynamic                        : constant Name_Id := N + 279;\n-   Name_Entity                         : constant Name_Id := N + 280;\n-   Name_Entry_Count                    : constant Name_Id := N + 281;\n-   Name_External_Name                  : constant Name_Id := N + 282;\n-   Name_First_Optional_Parameter       : constant Name_Id := N + 283;\n-   Name_Form                           : constant Name_Id := N + 284;\n-   Name_G_Float                        : constant Name_Id := N + 285;\n-   Name_Gcc                            : constant Name_Id := N + 286;\n-   Name_Gnat                           : constant Name_Id := N + 287;\n-   Name_GPL                            : constant Name_Id := N + 288;\n-   Name_IEEE_Float                     : constant Name_Id := N + 289;\n-   Name_Ignore                         : constant Name_Id := N + 290;\n-   Name_Info                           : constant Name_Id := N + 291;\n-   Name_Internal                       : constant Name_Id := N + 292;\n-   Name_Link_Name                      : constant Name_Id := N + 293;\n-   Name_Lowercase                      : constant Name_Id := N + 294;\n-   Name_Max_Entry_Queue_Depth          : constant Name_Id := N + 295;\n-   Name_Max_Entry_Queue_Length         : constant Name_Id := N + 296;\n-   Name_Max_Size                       : constant Name_Id := N + 297;\n-   Name_Mechanism                      : constant Name_Id := N + 298;\n-   Name_Message                        : constant Name_Id := N + 299;\n-   Name_Mixedcase                      : constant Name_Id := N + 300;\n-   Name_Modified_GPL                   : constant Name_Id := N + 301;\n-   Name_Name                           : constant Name_Id := N + 302;\n-   Name_NCA                            : constant Name_Id := N + 303;\n-   Name_No                             : constant Name_Id := N + 304;\n-   Name_No_Dependence                  : constant Name_Id := N + 305;\n-   Name_No_Dynamic_Attachment          : constant Name_Id := N + 306;\n-   Name_No_Dynamic_Interrupts          : constant Name_Id := N + 307;\n-   Name_No_Requeue                     : constant Name_Id := N + 308;\n-   Name_No_Requeue_Statements          : constant Name_Id := N + 309;\n-   Name_No_Task_Attributes             : constant Name_Id := N + 310;\n-   Name_No_Task_Attributes_Package     : constant Name_Id := N + 311;\n-   Name_On                             : constant Name_Id := N + 312;\n-   Name_Parameter_Types                : constant Name_Id := N + 313;\n-   Name_Reference                      : constant Name_Id := N + 314;\n-   Name_Restricted                     : constant Name_Id := N + 315;\n-   Name_Result_Mechanism               : constant Name_Id := N + 316;\n-   Name_Result_Type                    : constant Name_Id := N + 317;\n-   Name_Runtime                        : constant Name_Id := N + 318;\n-   Name_SB                             : constant Name_Id := N + 319;\n-   Name_Secondary_Stack_Size           : constant Name_Id := N + 320;\n-   Name_Section                        : constant Name_Id := N + 321;\n-   Name_Semaphore                      : constant Name_Id := N + 322;\n-   Name_Simple_Barriers                : constant Name_Id := N + 323;\n-   Name_Spec_File_Name                 : constant Name_Id := N + 324;\n-   Name_State                          : constant Name_Id := N + 325;\n-   Name_Static                         : constant Name_Id := N + 326;\n-   Name_Stack_Size                     : constant Name_Id := N + 327;\n-   Name_Subunit_File_Name              : constant Name_Id := N + 328;\n-   Name_Task_Stack_Size_Default        : constant Name_Id := N + 329;\n-   Name_Task_Type                      : constant Name_Id := N + 330;\n-   Name_Time_Slicing_Enabled           : constant Name_Id := N + 331;\n-   Name_Top_Guard                      : constant Name_Id := N + 332;\n-   Name_UBA                            : constant Name_Id := N + 333;\n-   Name_UBS                            : constant Name_Id := N + 334;\n-   Name_UBSB                           : constant Name_Id := N + 335;\n-   Name_Unit_Name                      : constant Name_Id := N + 336;\n-   Name_Unknown                        : constant Name_Id := N + 337;\n-   Name_Unrestricted                   : constant Name_Id := N + 338;\n-   Name_Uppercase                      : constant Name_Id := N + 339;\n-   Name_User                           : constant Name_Id := N + 340;\n-   Name_VAX_Float                      : constant Name_Id := N + 341;\n-   Name_VMS                            : constant Name_Id := N + 342;\n-   Name_Vtable_Ptr                     : constant Name_Id := N + 343;\n-   Name_Working_Storage                : constant Name_Id := N + 344;\n+   Name_As_Is                          : constant Name_Id := N + 267;\n+   Name_Attribute_Name                 : constant Name_Id := N + 268;\n+   Name_Body_File_Name                 : constant Name_Id := N + 269;\n+   Name_Boolean_Entry_Barriers         : constant Name_Id := N + 270;\n+   Name_Check                          : constant Name_Id := N + 271;\n+   Name_Casing                         : constant Name_Id := N + 272;\n+   Name_Code                           : constant Name_Id := N + 273;\n+   Name_Component                      : constant Name_Id := N + 274;\n+   Name_Component_Size_4               : constant Name_Id := N + 275;\n+   Name_Copy                           : constant Name_Id := N + 276;\n+   Name_D_Float                        : constant Name_Id := N + 277;\n+   Name_Descriptor                     : constant Name_Id := N + 278;\n+   Name_Dot_Replacement                : constant Name_Id := N + 279;\n+   Name_Dynamic                        : constant Name_Id := N + 280;\n+   Name_Entity                         : constant Name_Id := N + 281;\n+   Name_Entry_Count                    : constant Name_Id := N + 282;\n+   Name_External_Name                  : constant Name_Id := N + 283;\n+   Name_First_Optional_Parameter       : constant Name_Id := N + 284;\n+   Name_Form                           : constant Name_Id := N + 285;\n+   Name_G_Float                        : constant Name_Id := N + 286;\n+   Name_Gcc                            : constant Name_Id := N + 287;\n+   Name_Gnat                           : constant Name_Id := N + 288;\n+   Name_GPL                            : constant Name_Id := N + 289;\n+   Name_IEEE_Float                     : constant Name_Id := N + 290;\n+   Name_Ignore                         : constant Name_Id := N + 291;\n+   Name_Info                           : constant Name_Id := N + 292;\n+   Name_Internal                       : constant Name_Id := N + 293;\n+   Name_Link_Name                      : constant Name_Id := N + 294;\n+   Name_Lowercase                      : constant Name_Id := N + 295;\n+   Name_Max_Entry_Queue_Depth          : constant Name_Id := N + 296;\n+   Name_Max_Entry_Queue_Length         : constant Name_Id := N + 297;\n+   Name_Max_Size                       : constant Name_Id := N + 298;\n+   Name_Mechanism                      : constant Name_Id := N + 299;\n+   Name_Message                        : constant Name_Id := N + 300;\n+   Name_Mixedcase                      : constant Name_Id := N + 301;\n+   Name_Modified_GPL                   : constant Name_Id := N + 302;\n+   Name_Name                           : constant Name_Id := N + 303;\n+   Name_NCA                            : constant Name_Id := N + 304;\n+   Name_No                             : constant Name_Id := N + 305;\n+   Name_No_Dependence                  : constant Name_Id := N + 306;\n+   Name_No_Dynamic_Attachment          : constant Name_Id := N + 307;\n+   Name_No_Dynamic_Interrupts          : constant Name_Id := N + 308;\n+   Name_No_Requeue                     : constant Name_Id := N + 309;\n+   Name_No_Requeue_Statements          : constant Name_Id := N + 310;\n+   Name_No_Task_Attributes             : constant Name_Id := N + 311;\n+   Name_No_Task_Attributes_Package     : constant Name_Id := N + 312;\n+   Name_On                             : constant Name_Id := N + 313;\n+   Name_Parameter_Types                : constant Name_Id := N + 314;\n+   Name_Reference                      : constant Name_Id := N + 315;\n+   Name_Restricted                     : constant Name_Id := N + 316;\n+   Name_Result_Mechanism               : constant Name_Id := N + 317;\n+   Name_Result_Type                    : constant Name_Id := N + 318;\n+   Name_Runtime                        : constant Name_Id := N + 319;\n+   Name_SB                             : constant Name_Id := N + 320;\n+   Name_Secondary_Stack_Size           : constant Name_Id := N + 321;\n+   Name_Section                        : constant Name_Id := N + 322;\n+   Name_Semaphore                      : constant Name_Id := N + 323;\n+   Name_Simple_Barriers                : constant Name_Id := N + 324;\n+   Name_Spec_File_Name                 : constant Name_Id := N + 325;\n+   Name_State                          : constant Name_Id := N + 326;\n+   Name_Static                         : constant Name_Id := N + 327;\n+   Name_Stack_Size                     : constant Name_Id := N + 328;\n+   Name_Subunit_File_Name              : constant Name_Id := N + 329;\n+   Name_Task_Stack_Size_Default        : constant Name_Id := N + 330;\n+   Name_Task_Type                      : constant Name_Id := N + 331;\n+   Name_Time_Slicing_Enabled           : constant Name_Id := N + 332;\n+   Name_Top_Guard                      : constant Name_Id := N + 333;\n+   Name_UBA                            : constant Name_Id := N + 334;\n+   Name_UBS                            : constant Name_Id := N + 335;\n+   Name_UBSB                           : constant Name_Id := N + 336;\n+   Name_Unit_Name                      : constant Name_Id := N + 337;\n+   Name_Unknown                        : constant Name_Id := N + 338;\n+   Name_Unrestricted                   : constant Name_Id := N + 339;\n+   Name_Uppercase                      : constant Name_Id := N + 340;\n+   Name_User                           : constant Name_Id := N + 341;\n+   Name_VAX_Float                      : constant Name_Id := N + 342;\n+   Name_VMS                            : constant Name_Id := N + 343;\n+   Name_Vtable_Ptr                     : constant Name_Id := N + 344;\n+   Name_Working_Storage                : constant Name_Id := N + 345;\n \n    --  Names of recognized attributes. The entries with the comment \"Ada 83\"\n    --  are attributes that are defined in Ada 83, but not in Ada 95. These\n@@ -615,403 +616,403 @@ package Snames is\n    --  The entries marked VMS are recognized only in OpenVMS implementations\n    --  of GNAT, and are treated as illegal in all other contexts.\n \n-   First_Attribute_Name                : constant Name_Id := N + 345;\n-   Name_Abort_Signal                   : constant Name_Id := N + 345; -- GNAT\n-   Name_Access                         : constant Name_Id := N + 346;\n-   Name_Address                        : constant Name_Id := N + 347;\n-   Name_Address_Size                   : constant Name_Id := N + 348; -- GNAT\n-   Name_Aft                            : constant Name_Id := N + 349;\n-   Name_Alignment                      : constant Name_Id := N + 350;\n-   Name_Asm_Input                      : constant Name_Id := N + 351; -- GNAT\n-   Name_Asm_Output                     : constant Name_Id := N + 352; -- GNAT\n-   Name_AST_Entry                      : constant Name_Id := N + 353; -- VMS\n-   Name_Bit                            : constant Name_Id := N + 354; -- GNAT\n-   Name_Bit_Order                      : constant Name_Id := N + 355;\n-   Name_Bit_Position                   : constant Name_Id := N + 356; -- GNAT\n-   Name_Body_Version                   : constant Name_Id := N + 357;\n-   Name_Callable                       : constant Name_Id := N + 358;\n-   Name_Caller                         : constant Name_Id := N + 359;\n-   Name_Code_Address                   : constant Name_Id := N + 360; -- GNAT\n-   Name_Component_Size                 : constant Name_Id := N + 361;\n-   Name_Compose                        : constant Name_Id := N + 362;\n-   Name_Constrained                    : constant Name_Id := N + 363;\n-   Name_Count                          : constant Name_Id := N + 364;\n-   Name_Default_Bit_Order              : constant Name_Id := N + 365; -- GNAT\n-   Name_Definite                       : constant Name_Id := N + 366;\n-   Name_Delta                          : constant Name_Id := N + 367;\n-   Name_Denorm                         : constant Name_Id := N + 368;\n-   Name_Digits                         : constant Name_Id := N + 369;\n-   Name_Elaborated                     : constant Name_Id := N + 370; -- GNAT\n-   Name_Emax                           : constant Name_Id := N + 371; -- Ada 83\n-   Name_Enum_Rep                       : constant Name_Id := N + 372; -- GNAT\n-   Name_Epsilon                        : constant Name_Id := N + 373; -- Ada 83\n-   Name_Exponent                       : constant Name_Id := N + 374;\n-   Name_External_Tag                   : constant Name_Id := N + 375;\n-   Name_First                          : constant Name_Id := N + 376;\n-   Name_First_Bit                      : constant Name_Id := N + 377;\n-   Name_Fixed_Value                    : constant Name_Id := N + 378; -- GNAT\n-   Name_Fore                           : constant Name_Id := N + 379;\n-   Name_Has_Access_Values              : constant Name_Id := N + 380; -- GNAT\n-   Name_Has_Discriminants              : constant Name_Id := N + 381; -- GNAT\n-   Name_Identity                       : constant Name_Id := N + 382;\n-   Name_Img                            : constant Name_Id := N + 383; -- GNAT\n-   Name_Integer_Value                  : constant Name_Id := N + 384; -- GNAT\n-   Name_Large                          : constant Name_Id := N + 385; -- Ada 83\n-   Name_Last                           : constant Name_Id := N + 386;\n-   Name_Last_Bit                       : constant Name_Id := N + 387;\n-   Name_Leading_Part                   : constant Name_Id := N + 388;\n-   Name_Length                         : constant Name_Id := N + 389;\n-   Name_Machine_Emax                   : constant Name_Id := N + 390;\n-   Name_Machine_Emin                   : constant Name_Id := N + 391;\n-   Name_Machine_Mantissa               : constant Name_Id := N + 392;\n-   Name_Machine_Overflows              : constant Name_Id := N + 393;\n-   Name_Machine_Radix                  : constant Name_Id := N + 394;\n-   Name_Machine_Rounds                 : constant Name_Id := N + 395;\n-   Name_Machine_Size                   : constant Name_Id := N + 396; -- GNAT\n-   Name_Mantissa                       : constant Name_Id := N + 397; -- Ada 83\n-   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + 398;\n-   Name_Maximum_Alignment              : constant Name_Id := N + 399; -- GNAT\n-   Name_Mechanism_Code                 : constant Name_Id := N + 400; -- GNAT\n-   Name_Mod                            : constant Name_Id := N + 401;\n-   Name_Model_Emin                     : constant Name_Id := N + 402;\n-   Name_Model_Epsilon                  : constant Name_Id := N + 403;\n-   Name_Model_Mantissa                 : constant Name_Id := N + 404;\n-   Name_Model_Small                    : constant Name_Id := N + 405;\n-   Name_Modulus                        : constant Name_Id := N + 406;\n-   Name_Null_Parameter                 : constant Name_Id := N + 407; -- GNAT\n-   Name_Object_Size                    : constant Name_Id := N + 408; -- GNAT\n-   Name_Partition_ID                   : constant Name_Id := N + 409;\n-   Name_Passed_By_Reference            : constant Name_Id := N + 410; -- GNAT\n-   Name_Pool_Address                   : constant Name_Id := N + 411;\n-   Name_Pos                            : constant Name_Id := N + 412;\n-   Name_Position                       : constant Name_Id := N + 413;\n-   Name_Range                          : constant Name_Id := N + 414;\n-   Name_Range_Length                   : constant Name_Id := N + 415; -- GNAT\n-   Name_Round                          : constant Name_Id := N + 416;\n-   Name_Safe_Emax                      : constant Name_Id := N + 417; -- Ada 83\n-   Name_Safe_First                     : constant Name_Id := N + 418;\n-   Name_Safe_Large                     : constant Name_Id := N + 419; -- Ada 83\n-   Name_Safe_Last                      : constant Name_Id := N + 420;\n-   Name_Safe_Small                     : constant Name_Id := N + 421; -- Ada 83\n-   Name_Scale                          : constant Name_Id := N + 422;\n-   Name_Scaling                        : constant Name_Id := N + 423;\n-   Name_Signed_Zeros                   : constant Name_Id := N + 424;\n-   Name_Size                           : constant Name_Id := N + 425;\n-   Name_Small                          : constant Name_Id := N + 426;\n-   Name_Storage_Size                   : constant Name_Id := N + 427;\n-   Name_Storage_Unit                   : constant Name_Id := N + 428; -- GNAT\n-   Name_Stream_Size                    : constant Name_Id := N + 429; -- Ada 05\n-   Name_Tag                            : constant Name_Id := N + 430;\n-   Name_Target_Name                    : constant Name_Id := N + 431; -- GNAT\n-   Name_Terminated                     : constant Name_Id := N + 432;\n-   Name_To_Address                     : constant Name_Id := N + 433; -- GNAT\n-   Name_Type_Class                     : constant Name_Id := N + 434; -- GNAT\n-   Name_UET_Address                    : constant Name_Id := N + 435; -- GNAT\n-   Name_Unbiased_Rounding              : constant Name_Id := N + 436;\n-   Name_Unchecked_Access               : constant Name_Id := N + 437;\n-   Name_Unconstrained_Array            : constant Name_Id := N + 438;\n-   Name_Universal_Literal_String       : constant Name_Id := N + 439; -- GNAT\n-   Name_Unrestricted_Access            : constant Name_Id := N + 440; -- GNAT\n-   Name_VADS_Size                      : constant Name_Id := N + 441; -- GNAT\n-   Name_Val                            : constant Name_Id := N + 442;\n-   Name_Valid                          : constant Name_Id := N + 443;\n-   Name_Value_Size                     : constant Name_Id := N + 444; -- GNAT\n-   Name_Version                        : constant Name_Id := N + 445;\n-   Name_Wchar_T_Size                   : constant Name_Id := N + 446; -- GNAT\n-   Name_Wide_Wide_Width                : constant Name_Id := N + 447; -- Ada 05\n-   Name_Wide_Width                     : constant Name_Id := N + 448;\n-   Name_Width                          : constant Name_Id := N + 449;\n-   Name_Word_Size                      : constant Name_Id := N + 450; -- GNAT\n+   First_Attribute_Name                : constant Name_Id := N + 346;\n+   Name_Abort_Signal                   : constant Name_Id := N + 346; -- GNAT\n+   Name_Access                         : constant Name_Id := N + 347;\n+   Name_Address                        : constant Name_Id := N + 348;\n+   Name_Address_Size                   : constant Name_Id := N + 349; -- GNAT\n+   Name_Aft                            : constant Name_Id := N + 350;\n+   Name_Alignment                      : constant Name_Id := N + 351;\n+   Name_Asm_Input                      : constant Name_Id := N + 352; -- GNAT\n+   Name_Asm_Output                     : constant Name_Id := N + 353; -- GNAT\n+   Name_AST_Entry                      : constant Name_Id := N + 354; -- VMS\n+   Name_Bit                            : constant Name_Id := N + 355; -- GNAT\n+   Name_Bit_Order                      : constant Name_Id := N + 356;\n+   Name_Bit_Position                   : constant Name_Id := N + 357; -- GNAT\n+   Name_Body_Version                   : constant Name_Id := N + 358;\n+   Name_Callable                       : constant Name_Id := N + 359;\n+   Name_Caller                         : constant Name_Id := N + 360;\n+   Name_Code_Address                   : constant Name_Id := N + 361; -- GNAT\n+   Name_Component_Size                 : constant Name_Id := N + 362;\n+   Name_Compose                        : constant Name_Id := N + 363;\n+   Name_Constrained                    : constant Name_Id := N + 364;\n+   Name_Count                          : constant Name_Id := N + 365;\n+   Name_Default_Bit_Order              : constant Name_Id := N + 366; -- GNAT\n+   Name_Definite                       : constant Name_Id := N + 367;\n+   Name_Delta                          : constant Name_Id := N + 368;\n+   Name_Denorm                         : constant Name_Id := N + 369;\n+   Name_Digits                         : constant Name_Id := N + 370;\n+   Name_Elaborated                     : constant Name_Id := N + 371; -- GNAT\n+   Name_Emax                           : constant Name_Id := N + 372; -- Ada 83\n+   Name_Enum_Rep                       : constant Name_Id := N + 373; -- GNAT\n+   Name_Epsilon                        : constant Name_Id := N + 374; -- Ada 83\n+   Name_Exponent                       : constant Name_Id := N + 375;\n+   Name_External_Tag                   : constant Name_Id := N + 376;\n+   Name_First                          : constant Name_Id := N + 377;\n+   Name_First_Bit                      : constant Name_Id := N + 378;\n+   Name_Fixed_Value                    : constant Name_Id := N + 379; -- GNAT\n+   Name_Fore                           : constant Name_Id := N + 380;\n+   Name_Has_Access_Values              : constant Name_Id := N + 381; -- GNAT\n+   Name_Has_Discriminants              : constant Name_Id := N + 382; -- GNAT\n+   Name_Identity                       : constant Name_Id := N + 383;\n+   Name_Img                            : constant Name_Id := N + 384; -- GNAT\n+   Name_Integer_Value                  : constant Name_Id := N + 385; -- GNAT\n+   Name_Large                          : constant Name_Id := N + 386; -- Ada 83\n+   Name_Last                           : constant Name_Id := N + 387;\n+   Name_Last_Bit                       : constant Name_Id := N + 388;\n+   Name_Leading_Part                   : constant Name_Id := N + 389;\n+   Name_Length                         : constant Name_Id := N + 390;\n+   Name_Machine_Emax                   : constant Name_Id := N + 391;\n+   Name_Machine_Emin                   : constant Name_Id := N + 392;\n+   Name_Machine_Mantissa               : constant Name_Id := N + 393;\n+   Name_Machine_Overflows              : constant Name_Id := N + 394;\n+   Name_Machine_Radix                  : constant Name_Id := N + 395;\n+   Name_Machine_Rounds                 : constant Name_Id := N + 396;\n+   Name_Machine_Size                   : constant Name_Id := N + 397; -- GNAT\n+   Name_Mantissa                       : constant Name_Id := N + 398; -- Ada 83\n+   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + 399;\n+   Name_Maximum_Alignment              : constant Name_Id := N + 400; -- GNAT\n+   Name_Mechanism_Code                 : constant Name_Id := N + 401; -- GNAT\n+   Name_Mod                            : constant Name_Id := N + 402;\n+   Name_Model_Emin                     : constant Name_Id := N + 403;\n+   Name_Model_Epsilon                  : constant Name_Id := N + 404;\n+   Name_Model_Mantissa                 : constant Name_Id := N + 405;\n+   Name_Model_Small                    : constant Name_Id := N + 406;\n+   Name_Modulus                        : constant Name_Id := N + 407;\n+   Name_Null_Parameter                 : constant Name_Id := N + 408; -- GNAT\n+   Name_Object_Size                    : constant Name_Id := N + 409; -- GNAT\n+   Name_Partition_ID                   : constant Name_Id := N + 410;\n+   Name_Passed_By_Reference            : constant Name_Id := N + 411; -- GNAT\n+   Name_Pool_Address                   : constant Name_Id := N + 412;\n+   Name_Pos                            : constant Name_Id := N + 413;\n+   Name_Position                       : constant Name_Id := N + 414;\n+   Name_Range                          : constant Name_Id := N + 415;\n+   Name_Range_Length                   : constant Name_Id := N + 416; -- GNAT\n+   Name_Round                          : constant Name_Id := N + 417;\n+   Name_Safe_Emax                      : constant Name_Id := N + 418; -- Ada 83\n+   Name_Safe_First                     : constant Name_Id := N + 419;\n+   Name_Safe_Large                     : constant Name_Id := N + 420; -- Ada 83\n+   Name_Safe_Last                      : constant Name_Id := N + 421;\n+   Name_Safe_Small                     : constant Name_Id := N + 422; -- Ada 83\n+   Name_Scale                          : constant Name_Id := N + 423;\n+   Name_Scaling                        : constant Name_Id := N + 424;\n+   Name_Signed_Zeros                   : constant Name_Id := N + 425;\n+   Name_Size                           : constant Name_Id := N + 426;\n+   Name_Small                          : constant Name_Id := N + 427;\n+   Name_Storage_Size                   : constant Name_Id := N + 428;\n+   Name_Storage_Unit                   : constant Name_Id := N + 429; -- GNAT\n+   Name_Stream_Size                    : constant Name_Id := N + 430; -- Ada 05\n+   Name_Tag                            : constant Name_Id := N + 431;\n+   Name_Target_Name                    : constant Name_Id := N + 432; -- GNAT\n+   Name_Terminated                     : constant Name_Id := N + 433;\n+   Name_To_Address                     : constant Name_Id := N + 434; -- GNAT\n+   Name_Type_Class                     : constant Name_Id := N + 435; -- GNAT\n+   Name_UET_Address                    : constant Name_Id := N + 436; -- GNAT\n+   Name_Unbiased_Rounding              : constant Name_Id := N + 437;\n+   Name_Unchecked_Access               : constant Name_Id := N + 438;\n+   Name_Unconstrained_Array            : constant Name_Id := N + 439;\n+   Name_Universal_Literal_String       : constant Name_Id := N + 440; -- GNAT\n+   Name_Unrestricted_Access            : constant Name_Id := N + 441; -- GNAT\n+   Name_VADS_Size                      : constant Name_Id := N + 442; -- GNAT\n+   Name_Val                            : constant Name_Id := N + 443;\n+   Name_Valid                          : constant Name_Id := N + 444;\n+   Name_Value_Size                     : constant Name_Id := N + 445; -- GNAT\n+   Name_Version                        : constant Name_Id := N + 446;\n+   Name_Wchar_T_Size                   : constant Name_Id := N + 447; -- GNAT\n+   Name_Wide_Wide_Width                : constant Name_Id := N + 448; -- Ada 05\n+   Name_Wide_Width                     : constant Name_Id := N + 449;\n+   Name_Width                          : constant Name_Id := N + 450;\n+   Name_Word_Size                      : constant Name_Id := N + 451; -- GNAT\n \n    --  Attributes that designate attributes returning renamable functions,\n    --  i.e. functions that return other than a universal value and that\n    --  have non-universal arguments.\n \n-   First_Renamable_Function_Attribute  : constant Name_Id := N + 451;\n-   Name_Adjacent                       : constant Name_Id := N + 451;\n-   Name_Ceiling                        : constant Name_Id := N + 452;\n-   Name_Copy_Sign                      : constant Name_Id := N + 453;\n-   Name_Floor                          : constant Name_Id := N + 454;\n-   Name_Fraction                       : constant Name_Id := N + 455;\n-   Name_Image                          : constant Name_Id := N + 456;\n-   Name_Input                          : constant Name_Id := N + 457;\n-   Name_Machine                        : constant Name_Id := N + 458;\n-   Name_Max                            : constant Name_Id := N + 459;\n-   Name_Min                            : constant Name_Id := N + 460;\n-   Name_Model                          : constant Name_Id := N + 461;\n-   Name_Pred                           : constant Name_Id := N + 462;\n-   Name_Remainder                      : constant Name_Id := N + 463;\n-   Name_Rounding                       : constant Name_Id := N + 464;\n-   Name_Succ                           : constant Name_Id := N + 465;\n-   Name_Truncation                     : constant Name_Id := N + 466;\n-   Name_Value                          : constant Name_Id := N + 467;\n-   Name_Wide_Image                     : constant Name_Id := N + 468;\n-   Name_Wide_Wide_Image                : constant Name_Id := N + 469;\n-   Name_Wide_Value                     : constant Name_Id := N + 470;\n-   Name_Wide_Wide_Value                : constant Name_Id := N + 471;\n-   Last_Renamable_Function_Attribute   : constant Name_Id := N + 471;\n+   First_Renamable_Function_Attribute  : constant Name_Id := N + 452;\n+   Name_Adjacent                       : constant Name_Id := N + 452;\n+   Name_Ceiling                        : constant Name_Id := N + 453;\n+   Name_Copy_Sign                      : constant Name_Id := N + 454;\n+   Name_Floor                          : constant Name_Id := N + 455;\n+   Name_Fraction                       : constant Name_Id := N + 456;\n+   Name_Image                          : constant Name_Id := N + 457;\n+   Name_Input                          : constant Name_Id := N + 458;\n+   Name_Machine                        : constant Name_Id := N + 459;\n+   Name_Max                            : constant Name_Id := N + 460;\n+   Name_Min                            : constant Name_Id := N + 461;\n+   Name_Model                          : constant Name_Id := N + 462;\n+   Name_Pred                           : constant Name_Id := N + 463;\n+   Name_Remainder                      : constant Name_Id := N + 464;\n+   Name_Rounding                       : constant Name_Id := N + 465;\n+   Name_Succ                           : constant Name_Id := N + 466;\n+   Name_Truncation                     : constant Name_Id := N + 467;\n+   Name_Value                          : constant Name_Id := N + 468;\n+   Name_Wide_Image                     : constant Name_Id := N + 469;\n+   Name_Wide_Wide_Image                : constant Name_Id := N + 470;\n+   Name_Wide_Value                     : constant Name_Id := N + 471;\n+   Name_Wide_Wide_Value                : constant Name_Id := N + 472;\n+   Last_Renamable_Function_Attribute   : constant Name_Id := N + 472;\n \n    --  Attributes that designate procedures\n \n-   First_Procedure_Attribute           : constant Name_Id := N + 472;\n-   Name_Output                         : constant Name_Id := N + 472;\n-   Name_Read                           : constant Name_Id := N + 473;\n-   Name_Write                          : constant Name_Id := N + 474;\n-   Last_Procedure_Attribute            : constant Name_Id := N + 474;\n+   First_Procedure_Attribute           : constant Name_Id := N + 473;\n+   Name_Output                         : constant Name_Id := N + 473;\n+   Name_Read                           : constant Name_Id := N + 474;\n+   Name_Write                          : constant Name_Id := N + 475;\n+   Last_Procedure_Attribute            : constant Name_Id := N + 475;\n \n    --  Remaining attributes are ones that return entities\n \n-   First_Entity_Attribute_Name         : constant Name_Id := N + 475;\n-   Name_Elab_Body                      : constant Name_Id := N + 475; -- GNAT\n-   Name_Elab_Spec                      : constant Name_Id := N + 476; -- GNAT\n-   Name_Storage_Pool                   : constant Name_Id := N + 477;\n+   First_Entity_Attribute_Name         : constant Name_Id := N + 476;\n+   Name_Elab_Body                      : constant Name_Id := N + 476; -- GNAT\n+   Name_Elab_Spec                      : constant Name_Id := N + 477; -- GNAT\n+   Name_Storage_Pool                   : constant Name_Id := N + 478;\n \n    --  These attributes are the ones that return types\n \n-   First_Type_Attribute_Name           : constant Name_Id := N + 478;\n-   Name_Base                           : constant Name_Id := N + 478;\n-   Name_Class                          : constant Name_Id := N + 479;\n-   Last_Type_Attribute_Name            : constant Name_Id := N + 479;\n-   Last_Entity_Attribute_Name          : constant Name_Id := N + 479;\n-   Last_Attribute_Name                 : constant Name_Id := N + 479;\n+   First_Type_Attribute_Name           : constant Name_Id := N + 479;\n+   Name_Base                           : constant Name_Id := N + 479;\n+   Name_Class                          : constant Name_Id := N + 480;\n+   Last_Type_Attribute_Name            : constant Name_Id := N + 480;\n+   Last_Entity_Attribute_Name          : constant Name_Id := N + 480;\n+   Last_Attribute_Name                 : constant Name_Id := N + 480;\n \n    --  Names of recognized locking policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. C for Ceiling_Locking). If new policy names are added,\n    --  the first character must be distinct.\n \n-   First_Locking_Policy_Name           : constant Name_Id := N + 480;\n-   Name_Ceiling_Locking                : constant Name_Id := N + 480;\n-   Name_Inheritance_Locking            : constant Name_Id := N + 481;\n-   Last_Locking_Policy_Name            : constant Name_Id := N + 481;\n+   First_Locking_Policy_Name           : constant Name_Id := N + 481;\n+   Name_Ceiling_Locking                : constant Name_Id := N + 481;\n+   Name_Inheritance_Locking            : constant Name_Id := N + 482;\n+   Last_Locking_Policy_Name            : constant Name_Id := N + 482;\n \n    --  Names of recognized queuing policy identifiers.\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. F for FIFO_Queuing). If new policy names are added,\n    --  the first character must be distinct.\n \n-   First_Queuing_Policy_Name           : constant Name_Id := N + 482;\n-   Name_FIFO_Queuing                   : constant Name_Id := N + 482;\n-   Name_Priority_Queuing               : constant Name_Id := N + 483;\n-   Last_Queuing_Policy_Name            : constant Name_Id := N + 483;\n+   First_Queuing_Policy_Name           : constant Name_Id := N + 483;\n+   Name_FIFO_Queuing                   : constant Name_Id := N + 483;\n+   Name_Priority_Queuing               : constant Name_Id := N + 484;\n+   Last_Queuing_Policy_Name            : constant Name_Id := N + 484;\n \n    --  Names of recognized task dispatching policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. F for FIFO_WIthinn_Priorities). If new policy names\n    --  are added, the first character must be distinct.\n \n-   First_Task_Dispatching_Policy_Name  : constant Name_Id := N + 484;\n-   Name_FIFO_Within_Priorities         : constant Name_Id := N + 484;\n-   Last_Task_Dispatching_Policy_Name   : constant Name_Id := N + 484;\n+   First_Task_Dispatching_Policy_Name  : constant Name_Id := N + 485;\n+   Name_FIFO_Within_Priorities         : constant Name_Id := N + 485;\n+   Last_Task_Dispatching_Policy_Name   : constant Name_Id := N + 485;\n \n    --  Names of recognized checks for pragma Suppress\n \n-   First_Check_Name                    : constant Name_Id := N + 485;\n-   Name_Access_Check                   : constant Name_Id := N + 485;\n-   Name_Accessibility_Check            : constant Name_Id := N + 486;\n-   Name_Discriminant_Check             : constant Name_Id := N + 487;\n-   Name_Division_Check                 : constant Name_Id := N + 488;\n-   Name_Elaboration_Check              : constant Name_Id := N + 489;\n-   Name_Index_Check                    : constant Name_Id := N + 490;\n-   Name_Length_Check                   : constant Name_Id := N + 491;\n-   Name_Overflow_Check                 : constant Name_Id := N + 492;\n-   Name_Range_Check                    : constant Name_Id := N + 493;\n-   Name_Storage_Check                  : constant Name_Id := N + 494;\n-   Name_Tag_Check                      : constant Name_Id := N + 495;\n-   Name_All_Checks                     : constant Name_Id := N + 496;\n-   Last_Check_Name                     : constant Name_Id := N + 496;\n+   First_Check_Name                    : constant Name_Id := N + 486;\n+   Name_Access_Check                   : constant Name_Id := N + 486;\n+   Name_Accessibility_Check            : constant Name_Id := N + 487;\n+   Name_Discriminant_Check             : constant Name_Id := N + 488;\n+   Name_Division_Check                 : constant Name_Id := N + 489;\n+   Name_Elaboration_Check              : constant Name_Id := N + 490;\n+   Name_Index_Check                    : constant Name_Id := N + 491;\n+   Name_Length_Check                   : constant Name_Id := N + 492;\n+   Name_Overflow_Check                 : constant Name_Id := N + 493;\n+   Name_Range_Check                    : constant Name_Id := N + 494;\n+   Name_Storage_Check                  : constant Name_Id := N + 495;\n+   Name_Tag_Check                      : constant Name_Id := N + 496;\n+   Name_All_Checks                     : constant Name_Id := N + 497;\n+   Last_Check_Name                     : constant Name_Id := N + 497;\n \n    --  Names corresponding to reserved keywords, excluding those already\n    --  declared in the attribute list (Access, Delta, Digits, Mod, Range).\n \n-   Name_Abort                          : constant Name_Id := N + 497;\n-   Name_Abs                            : constant Name_Id := N + 498;\n-   Name_Accept                         : constant Name_Id := N + 499;\n-   Name_And                            : constant Name_Id := N + 500;\n-   Name_All                            : constant Name_Id := N + 501;\n-   Name_Array                          : constant Name_Id := N + 502;\n-   Name_At                             : constant Name_Id := N + 503;\n-   Name_Begin                          : constant Name_Id := N + 504;\n-   Name_Body                           : constant Name_Id := N + 505;\n-   Name_Case                           : constant Name_Id := N + 506;\n-   Name_Constant                       : constant Name_Id := N + 507;\n-   Name_Declare                        : constant Name_Id := N + 508;\n-   Name_Delay                          : constant Name_Id := N + 509;\n-   Name_Do                             : constant Name_Id := N + 510;\n-   Name_Else                           : constant Name_Id := N + 511;\n-   Name_Elsif                          : constant Name_Id := N + 512;\n-   Name_End                            : constant Name_Id := N + 513;\n-   Name_Entry                          : constant Name_Id := N + 514;\n-   Name_Exception                      : constant Name_Id := N + 515;\n-   Name_Exit                           : constant Name_Id := N + 516;\n-   Name_For                            : constant Name_Id := N + 517;\n-   Name_Function                       : constant Name_Id := N + 518;\n-   Name_Generic                        : constant Name_Id := N + 519;\n-   Name_Goto                           : constant Name_Id := N + 520;\n-   Name_If                             : constant Name_Id := N + 521;\n-   Name_In                             : constant Name_Id := N + 522;\n-   Name_Is                             : constant Name_Id := N + 523;\n-   Name_Limited                        : constant Name_Id := N + 524;\n-   Name_Loop                           : constant Name_Id := N + 525;\n-   Name_New                            : constant Name_Id := N + 526;\n-   Name_Not                            : constant Name_Id := N + 527;\n-   Name_Null                           : constant Name_Id := N + 528;\n-   Name_Of                             : constant Name_Id := N + 529;\n-   Name_Or                             : constant Name_Id := N + 530;\n-   Name_Others                         : constant Name_Id := N + 531;\n-   Name_Out                            : constant Name_Id := N + 532;\n-   Name_Package                        : constant Name_Id := N + 533;\n-   Name_Pragma                         : constant Name_Id := N + 534;\n-   Name_Private                        : constant Name_Id := N + 535;\n-   Name_Procedure                      : constant Name_Id := N + 536;\n-   Name_Raise                          : constant Name_Id := N + 537;\n-   Name_Record                         : constant Name_Id := N + 538;\n-   Name_Rem                            : constant Name_Id := N + 539;\n-   Name_Renames                        : constant Name_Id := N + 540;\n-   Name_Return                         : constant Name_Id := N + 541;\n-   Name_Reverse                        : constant Name_Id := N + 542;\n-   Name_Select                         : constant Name_Id := N + 543;\n-   Name_Separate                       : constant Name_Id := N + 544;\n-   Name_Subtype                        : constant Name_Id := N + 545;\n-   Name_Task                           : constant Name_Id := N + 546;\n-   Name_Terminate                      : constant Name_Id := N + 547;\n-   Name_Then                           : constant Name_Id := N + 548;\n-   Name_Type                           : constant Name_Id := N + 549;\n-   Name_Use                            : constant Name_Id := N + 550;\n-   Name_When                           : constant Name_Id := N + 551;\n-   Name_While                          : constant Name_Id := N + 552;\n-   Name_With                           : constant Name_Id := N + 553;\n-   Name_Xor                            : constant Name_Id := N + 554;\n+   Name_Abort                          : constant Name_Id := N + 498;\n+   Name_Abs                            : constant Name_Id := N + 499;\n+   Name_Accept                         : constant Name_Id := N + 500;\n+   Name_And                            : constant Name_Id := N + 501;\n+   Name_All                            : constant Name_Id := N + 502;\n+   Name_Array                          : constant Name_Id := N + 503;\n+   Name_At                             : constant Name_Id := N + 504;\n+   Name_Begin                          : constant Name_Id := N + 505;\n+   Name_Body                           : constant Name_Id := N + 506;\n+   Name_Case                           : constant Name_Id := N + 507;\n+   Name_Constant                       : constant Name_Id := N + 508;\n+   Name_Declare                        : constant Name_Id := N + 509;\n+   Name_Delay                          : constant Name_Id := N + 510;\n+   Name_Do                             : constant Name_Id := N + 511;\n+   Name_Else                           : constant Name_Id := N + 512;\n+   Name_Elsif                          : constant Name_Id := N + 513;\n+   Name_End                            : constant Name_Id := N + 514;\n+   Name_Entry                          : constant Name_Id := N + 515;\n+   Name_Exception                      : constant Name_Id := N + 516;\n+   Name_Exit                           : constant Name_Id := N + 517;\n+   Name_For                            : constant Name_Id := N + 518;\n+   Name_Function                       : constant Name_Id := N + 519;\n+   Name_Generic                        : constant Name_Id := N + 520;\n+   Name_Goto                           : constant Name_Id := N + 521;\n+   Name_If                             : constant Name_Id := N + 522;\n+   Name_In                             : constant Name_Id := N + 523;\n+   Name_Is                             : constant Name_Id := N + 524;\n+   Name_Limited                        : constant Name_Id := N + 525;\n+   Name_Loop                           : constant Name_Id := N + 526;\n+   Name_New                            : constant Name_Id := N + 527;\n+   Name_Not                            : constant Name_Id := N + 528;\n+   Name_Null                           : constant Name_Id := N + 529;\n+   Name_Of                             : constant Name_Id := N + 530;\n+   Name_Or                             : constant Name_Id := N + 531;\n+   Name_Others                         : constant Name_Id := N + 532;\n+   Name_Out                            : constant Name_Id := N + 533;\n+   Name_Package                        : constant Name_Id := N + 534;\n+   Name_Pragma                         : constant Name_Id := N + 535;\n+   Name_Private                        : constant Name_Id := N + 536;\n+   Name_Procedure                      : constant Name_Id := N + 537;\n+   Name_Raise                          : constant Name_Id := N + 538;\n+   Name_Record                         : constant Name_Id := N + 539;\n+   Name_Rem                            : constant Name_Id := N + 540;\n+   Name_Renames                        : constant Name_Id := N + 541;\n+   Name_Return                         : constant Name_Id := N + 542;\n+   Name_Reverse                        : constant Name_Id := N + 543;\n+   Name_Select                         : constant Name_Id := N + 544;\n+   Name_Separate                       : constant Name_Id := N + 545;\n+   Name_Subtype                        : constant Name_Id := N + 546;\n+   Name_Task                           : constant Name_Id := N + 547;\n+   Name_Terminate                      : constant Name_Id := N + 548;\n+   Name_Then                           : constant Name_Id := N + 549;\n+   Name_Type                           : constant Name_Id := N + 550;\n+   Name_Use                            : constant Name_Id := N + 551;\n+   Name_When                           : constant Name_Id := N + 552;\n+   Name_While                          : constant Name_Id := N + 553;\n+   Name_With                           : constant Name_Id := N + 554;\n+   Name_Xor                            : constant Name_Id := N + 555;\n \n    --  Names of intrinsic subprograms\n \n    --  Note: Asm is missing from this list, since Asm is a legitimate\n    --  convention name. So is To_Adress, which is a GNAT attribute.\n \n-   First_Intrinsic_Name                 : constant Name_Id := N + 555;\n-   Name_Divide                          : constant Name_Id := N + 555;\n-   Name_Enclosing_Entity                : constant Name_Id := N + 556;\n-   Name_Exception_Information           : constant Name_Id := N + 557;\n-   Name_Exception_Message               : constant Name_Id := N + 558;\n-   Name_Exception_Name                  : constant Name_Id := N + 559;\n-   Name_File                            : constant Name_Id := N + 560;\n-   Name_Generic_Dispatching_Constructor : constant Name_Id := N + 561;\n-   Name_Import_Address                  : constant Name_Id := N + 562;\n-   Name_Import_Largest_Value            : constant Name_Id := N + 563;\n-   Name_Import_Value                    : constant Name_Id := N + 564;\n-   Name_Is_Negative                     : constant Name_Id := N + 565;\n-   Name_Line                            : constant Name_Id := N + 566;\n-   Name_Rotate_Left                     : constant Name_Id := N + 567;\n-   Name_Rotate_Right                    : constant Name_Id := N + 568;\n-   Name_Shift_Left                      : constant Name_Id := N + 569;\n-   Name_Shift_Right                     : constant Name_Id := N + 570;\n-   Name_Shift_Right_Arithmetic          : constant Name_Id := N + 571;\n-   Name_Source_Location                 : constant Name_Id := N + 572;\n-   Name_Unchecked_Conversion            : constant Name_Id := N + 573;\n-   Name_Unchecked_Deallocation          : constant Name_Id := N + 574;\n-   Name_To_Pointer                      : constant Name_Id := N + 575;\n-   Last_Intrinsic_Name                  : constant Name_Id := N + 575;\n+   First_Intrinsic_Name                 : constant Name_Id := N + 556;\n+   Name_Divide                          : constant Name_Id := N + 556;\n+   Name_Enclosing_Entity                : constant Name_Id := N + 557;\n+   Name_Exception_Information           : constant Name_Id := N + 558;\n+   Name_Exception_Message               : constant Name_Id := N + 559;\n+   Name_Exception_Name                  : constant Name_Id := N + 560;\n+   Name_File                            : constant Name_Id := N + 561;\n+   Name_Generic_Dispatching_Constructor : constant Name_Id := N + 562;\n+   Name_Import_Address                  : constant Name_Id := N + 563;\n+   Name_Import_Largest_Value            : constant Name_Id := N + 564;\n+   Name_Import_Value                    : constant Name_Id := N + 565;\n+   Name_Is_Negative                     : constant Name_Id := N + 566;\n+   Name_Line                            : constant Name_Id := N + 567;\n+   Name_Rotate_Left                     : constant Name_Id := N + 568;\n+   Name_Rotate_Right                    : constant Name_Id := N + 569;\n+   Name_Shift_Left                      : constant Name_Id := N + 570;\n+   Name_Shift_Right                     : constant Name_Id := N + 571;\n+   Name_Shift_Right_Arithmetic          : constant Name_Id := N + 572;\n+   Name_Source_Location                 : constant Name_Id := N + 573;\n+   Name_Unchecked_Conversion            : constant Name_Id := N + 574;\n+   Name_Unchecked_Deallocation          : constant Name_Id := N + 575;\n+   Name_To_Pointer                      : constant Name_Id := N + 576;\n+   Last_Intrinsic_Name                  : constant Name_Id := N + 576;\n \n    --  Reserved words used only in Ada 95\n \n-   First_95_Reserved_Word              : constant Name_Id := N + 576;\n-   Name_Abstract                       : constant Name_Id := N + 576;\n-   Name_Aliased                        : constant Name_Id := N + 577;\n-   Name_Protected                      : constant Name_Id := N + 578;\n-   Name_Until                          : constant Name_Id := N + 579;\n-   Name_Requeue                        : constant Name_Id := N + 580;\n-   Name_Tagged                         : constant Name_Id := N + 581;\n-   Last_95_Reserved_Word               : constant Name_Id := N + 581;\n+   First_95_Reserved_Word              : constant Name_Id := N + 577;\n+   Name_Abstract                       : constant Name_Id := N + 577;\n+   Name_Aliased                        : constant Name_Id := N + 578;\n+   Name_Protected                      : constant Name_Id := N + 579;\n+   Name_Until                          : constant Name_Id := N + 580;\n+   Name_Requeue                        : constant Name_Id := N + 581;\n+   Name_Tagged                         : constant Name_Id := N + 582;\n+   Last_95_Reserved_Word               : constant Name_Id := N + 582;\n \n    subtype Ada_95_Reserved_Words is\n      Name_Id range First_95_Reserved_Word .. Last_95_Reserved_Word;\n \n    --  Miscellaneous names used in semantic checking\n \n-   Name_Raise_Exception                : constant Name_Id := N + 582;\n+   Name_Raise_Exception                : constant Name_Id := N + 583;\n \n    --  Additional reserved words and identifiers used in GNAT Project Files\n    --  Note that Name_External is already previously declared\n \n-   Name_Ada_Roots                      : constant Name_Id := N + 583;\n-   Name_Binder                         : constant Name_Id := N + 584;\n-   Name_Binder_Driver                  : constant Name_Id := N + 585;\n-   Name_Body_Suffix                    : constant Name_Id := N + 586;\n-   Name_Builder                        : constant Name_Id := N + 587;\n-   Name_Compiler                       : constant Name_Id := N + 588;\n-   Name_Compiler_Driver                : constant Name_Id := N + 589;\n-   Name_Compiler_Kind                  : constant Name_Id := N + 590;\n-   Name_Compute_Dependency             : constant Name_Id := N + 591;\n-   Name_Cross_Reference                : constant Name_Id := N + 592;\n-   Name_Default_Linker                 : constant Name_Id := N + 593;\n-   Name_Default_Switches               : constant Name_Id := N + 594;\n-   Name_Dependency_Option              : constant Name_Id := N + 595;\n-   Name_Exec_Dir                       : constant Name_Id := N + 596;\n-   Name_Executable                     : constant Name_Id := N + 597;\n-   Name_Executable_Suffix              : constant Name_Id := N + 598;\n-   Name_Extends                        : constant Name_Id := N + 599;\n-   Name_Externally_Built               : constant Name_Id := N + 600;\n-   Name_Finder                         : constant Name_Id := N + 601;\n-   Name_Global_Configuration_Pragmas   : constant Name_Id := N + 602;\n-   Name_Gnatls                         : constant Name_Id := N + 603;\n-   Name_Gnatstub                       : constant Name_Id := N + 604;\n-   Name_Implementation                 : constant Name_Id := N + 605;\n-   Name_Implementation_Exceptions      : constant Name_Id := N + 606;\n-   Name_Implementation_Suffix          : constant Name_Id := N + 607;\n-   Name_Include_Option                 : constant Name_Id := N + 608;\n-   Name_Language_Processing            : constant Name_Id := N + 609;\n-   Name_Languages                      : constant Name_Id := N + 610;\n-   Name_Library_Dir                    : constant Name_Id := N + 611;\n-   Name_Library_Auto_Init              : constant Name_Id := N + 612;\n-   Name_Library_GCC                    : constant Name_Id := N + 613;\n-   Name_Library_Interface              : constant Name_Id := N + 614;\n-   Name_Library_Kind                   : constant Name_Id := N + 615;\n-   Name_Library_Name                   : constant Name_Id := N + 616;\n-   Name_Library_Options                : constant Name_Id := N + 617;\n-   Name_Library_Reference_Symbol_File  : constant Name_Id := N + 618;\n-   Name_Library_Src_Dir                : constant Name_Id := N + 619;\n-   Name_Library_Symbol_File            : constant Name_Id := N + 620;\n-   Name_Library_Symbol_Policy          : constant Name_Id := N + 621;\n-   Name_Library_Version                : constant Name_Id := N + 622;\n-   Name_Linker                         : constant Name_Id := N + 623;\n-   Name_Local_Configuration_Pragmas    : constant Name_Id := N + 624;\n-   Name_Locally_Removed_Files          : constant Name_Id := N + 625;\n-   Name_Metrics                        : constant Name_Id := N + 626;\n-   Name_Naming                         : constant Name_Id := N + 627;\n-   Name_Object_Dir                     : constant Name_Id := N + 628;\n-   Name_Pretty_Printer                 : constant Name_Id := N + 629;\n-   Name_Project                        : constant Name_Id := N + 630;\n-   Name_Separate_Suffix                : constant Name_Id := N + 631;\n-   Name_Source_Dirs                    : constant Name_Id := N + 632;\n-   Name_Source_Files                   : constant Name_Id := N + 633;\n-   Name_Source_List_File               : constant Name_Id := N + 634;\n-   Name_Spec                           : constant Name_Id := N + 635;\n-   Name_Spec_Suffix                    : constant Name_Id := N + 636;\n-   Name_Specification                  : constant Name_Id := N + 637;\n-   Name_Specification_Exceptions       : constant Name_Id := N + 638;\n-   Name_Specification_Suffix           : constant Name_Id := N + 639;\n-   Name_Switches                       : constant Name_Id := N + 640;\n+   Name_Ada_Roots                      : constant Name_Id := N + 584;\n+   Name_Binder                         : constant Name_Id := N + 585;\n+   Name_Binder_Driver                  : constant Name_Id := N + 586;\n+   Name_Body_Suffix                    : constant Name_Id := N + 587;\n+   Name_Builder                        : constant Name_Id := N + 588;\n+   Name_Compiler                       : constant Name_Id := N + 589;\n+   Name_Compiler_Driver                : constant Name_Id := N + 590;\n+   Name_Compiler_Kind                  : constant Name_Id := N + 591;\n+   Name_Compute_Dependency             : constant Name_Id := N + 592;\n+   Name_Cross_Reference                : constant Name_Id := N + 593;\n+   Name_Default_Linker                 : constant Name_Id := N + 594;\n+   Name_Default_Switches               : constant Name_Id := N + 595;\n+   Name_Dependency_Option              : constant Name_Id := N + 596;\n+   Name_Exec_Dir                       : constant Name_Id := N + 597;\n+   Name_Executable                     : constant Name_Id := N + 598;\n+   Name_Executable_Suffix              : constant Name_Id := N + 599;\n+   Name_Extends                        : constant Name_Id := N + 600;\n+   Name_Externally_Built               : constant Name_Id := N + 601;\n+   Name_Finder                         : constant Name_Id := N + 602;\n+   Name_Global_Configuration_Pragmas   : constant Name_Id := N + 603;\n+   Name_Gnatls                         : constant Name_Id := N + 604;\n+   Name_Gnatstub                       : constant Name_Id := N + 605;\n+   Name_Implementation                 : constant Name_Id := N + 606;\n+   Name_Implementation_Exceptions      : constant Name_Id := N + 607;\n+   Name_Implementation_Suffix          : constant Name_Id := N + 608;\n+   Name_Include_Option                 : constant Name_Id := N + 609;\n+   Name_Language_Processing            : constant Name_Id := N + 610;\n+   Name_Languages                      : constant Name_Id := N + 611;\n+   Name_Library_Dir                    : constant Name_Id := N + 612;\n+   Name_Library_Auto_Init              : constant Name_Id := N + 613;\n+   Name_Library_GCC                    : constant Name_Id := N + 614;\n+   Name_Library_Interface              : constant Name_Id := N + 615;\n+   Name_Library_Kind                   : constant Name_Id := N + 616;\n+   Name_Library_Name                   : constant Name_Id := N + 617;\n+   Name_Library_Options                : constant Name_Id := N + 618;\n+   Name_Library_Reference_Symbol_File  : constant Name_Id := N + 619;\n+   Name_Library_Src_Dir                : constant Name_Id := N + 620;\n+   Name_Library_Symbol_File            : constant Name_Id := N + 621;\n+   Name_Library_Symbol_Policy          : constant Name_Id := N + 622;\n+   Name_Library_Version                : constant Name_Id := N + 623;\n+   Name_Linker                         : constant Name_Id := N + 624;\n+   Name_Local_Configuration_Pragmas    : constant Name_Id := N + 625;\n+   Name_Locally_Removed_Files          : constant Name_Id := N + 626;\n+   Name_Metrics                        : constant Name_Id := N + 627;\n+   Name_Naming                         : constant Name_Id := N + 628;\n+   Name_Object_Dir                     : constant Name_Id := N + 629;\n+   Name_Pretty_Printer                 : constant Name_Id := N + 630;\n+   Name_Project                        : constant Name_Id := N + 631;\n+   Name_Separate_Suffix                : constant Name_Id := N + 632;\n+   Name_Source_Dirs                    : constant Name_Id := N + 633;\n+   Name_Source_Files                   : constant Name_Id := N + 634;\n+   Name_Source_List_File               : constant Name_Id := N + 635;\n+   Name_Spec                           : constant Name_Id := N + 636;\n+   Name_Spec_Suffix                    : constant Name_Id := N + 637;\n+   Name_Specification                  : constant Name_Id := N + 638;\n+   Name_Specification_Exceptions       : constant Name_Id := N + 639;\n+   Name_Specification_Suffix           : constant Name_Id := N + 640;\n+   Name_Switches                       : constant Name_Id := N + 641;\n \n    --  Other miscellaneous names used in front end\n \n-   Name_Unaligned_Valid                : constant Name_Id := N + 641;\n+   Name_Unaligned_Valid                : constant Name_Id := N + 642;\n \n    --  ----------------------------------------------------------------\n-   First_2005_Reserved_Word            : constant Name_Id := N + 642;\n-   Name_Interface                      : constant Name_Id := N + 642;\n-   Name_Overriding                     : constant Name_Id := N + 643;\n-   Name_Synchronized                   : constant Name_Id := N + 644;\n-   Last_2005_Reserved_Word             : constant Name_Id := N + 644;\n+   First_2005_Reserved_Word            : constant Name_Id := N + 643;\n+   Name_Interface                      : constant Name_Id := N + 643;\n+   Name_Overriding                     : constant Name_Id := N + 644;\n+   Name_Synchronized                   : constant Name_Id := N + 645;\n+   Last_2005_Reserved_Word             : constant Name_Id := N + 645;\n \n    subtype Ada_2005_Reserved_Words is\n      Name_Id range First_2005_Reserved_Word .. Last_2005_Reserved_Word;\n \n    --  Mark last defined name for consistency check in Snames body\n \n-   Last_Predefined_Name                : constant Name_Id := N + 644;\n+   Last_Predefined_Name                : constant Name_Id := N + 645;\n \n    subtype Any_Operator_Name is Name_Id range\n      First_Operator_Name .. Last_Operator_Name;\n@@ -1319,6 +1320,8 @@ package Snames is\n       Pragma_Keep_Names,\n       Pragma_Link_With,\n       Pragma_Linker_Alias,\n+      Pragma_Linker_Constructor,\n+      Pragma_Linker_Destructor,\n       Pragma_Linker_Options,\n       Pragma_Linker_Section,\n       Pragma_List,"}, {"sha": "7dd1f399130158b5e11ded864769118856c5a6db", "filename": "gcc/ada/snames.h", "status": "modified", "additions": 52, "deletions": 50, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Fsnames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Fsnames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.h?ref=d9e0a58787285a0753791dd83a5d831bbbc92117", "patch": "@@ -307,55 +307,57 @@ extern unsigned char Get_Pragma_Id (int);\n #define  Pragma_Keep_Names                    93\n #define  Pragma_Link_With                     94\n #define  Pragma_Linker_Alias                  95\n-#define  Pragma_Linker_Options                96\n-#define  Pragma_Linker_Section                97\n-#define  Pragma_List                          98\n-#define  Pragma_Machine_Attribute             99\n-#define  Pragma_Main                          100\n-#define  Pragma_Main_Storage                  101\n-#define  Pragma_Memory_Size                   102\n-#define  Pragma_No_Return                     103\n-#define  Pragma_Obsolescent                   104\n-#define  Pragma_Optimize                      105\n-#define  Pragma_Optional_Overriding           106\n-#define  Pragma_Pack                          107\n-#define  Pragma_Page                          108\n-#define  Pragma_Passive                       109\n-#define  Pragma_Preelaborate                  110\n-#define  Pragma_Preelaborate_05               111\n-#define  Pragma_Priority                      112\n-#define  Pragma_Psect_Object                  113\n-#define  Pragma_Pure                          114\n-#define  Pragma_Pure_05                       115\n-#define  Pragma_Pure_Function                 116\n-#define  Pragma_Remote_Call_Interface         117\n-#define  Pragma_Remote_Types                  118\n-#define  Pragma_Share_Generic                 119\n-#define  Pragma_Shared                        120\n-#define  Pragma_Shared_Passive                121\n-#define  Pragma_Source_Reference              122\n-#define  Pragma_Stream_Convert                123\n-#define  Pragma_Subtitle                      124\n-#define  Pragma_Suppress_All                  125\n-#define  Pragma_Suppress_Debug_Info           126\n-#define  Pragma_Suppress_Initialization       127\n-#define  Pragma_System_Name                   128\n-#define  Pragma_Task_Info                     129\n-#define  Pragma_Task_Name                     130\n-#define  Pragma_Task_Storage                  131\n-#define  Pragma_Thread_Body                   132\n-#define  Pragma_Time_Slice                    133\n-#define  Pragma_Title                         134\n-#define  Pragma_Unchecked_Union               135\n-#define  Pragma_Unimplemented_Unit            136\n-#define  Pragma_Unreferenced                  137\n-#define  Pragma_Unreserve_All_Interrupts      138\n-#define  Pragma_Volatile                      139\n-#define  Pragma_Volatile_Components           140\n-#define  Pragma_Weak_External                 141\n-#define  Pragma_AST_Entry                     142\n-#define  Pragma_Interface                     143\n-#define  Pragma_Storage_Size                  144\n-#define  Pragma_Storage_Unit                  145\n+#define  Pragma_Linker_Constructor            96\n+#define  Pragma_Linker_Destructor             97\n+#define  Pragma_Linker_Options                98\n+#define  Pragma_Linker_Section                99\n+#define  Pragma_List                          100\n+#define  Pragma_Machine_Attribute             101\n+#define  Pragma_Main                          102\n+#define  Pragma_Main_Storage                  103\n+#define  Pragma_Memory_Size                   104\n+#define  Pragma_No_Return                     105\n+#define  Pragma_Obsolescent                   106\n+#define  Pragma_Optimize                      107\n+#define  Pragma_Optional_Overriding           108\n+#define  Pragma_Pack                          109\n+#define  Pragma_Page                          110\n+#define  Pragma_Passive                       111\n+#define  Pragma_Preelaborate                  112\n+#define  Pragma_Preelaborate_05               113\n+#define  Pragma_Priority                      114\n+#define  Pragma_Psect_Object                  115\n+#define  Pragma_Pure                          116\n+#define  Pragma_Pure_05                       117\n+#define  Pragma_Pure_Function                 118\n+#define  Pragma_Remote_Call_Interface         119\n+#define  Pragma_Remote_Types                  120\n+#define  Pragma_Share_Generic                 121\n+#define  Pragma_Shared                        122\n+#define  Pragma_Shared_Passive                123\n+#define  Pragma_Source_Reference              124\n+#define  Pragma_Stream_Convert                125\n+#define  Pragma_Subtitle                      126\n+#define  Pragma_Suppress_All                  127\n+#define  Pragma_Suppress_Debug_Info           128\n+#define  Pragma_Suppress_Initialization       129\n+#define  Pragma_System_Name                   130\n+#define  Pragma_Task_Info                     131\n+#define  Pragma_Task_Name                     132\n+#define  Pragma_Task_Storage                  133\n+#define  Pragma_Thread_Body                   134\n+#define  Pragma_Time_Slice                    135\n+#define  Pragma_Title                         136\n+#define  Pragma_Unchecked_Union               137\n+#define  Pragma_Unimplemented_Unit            138\n+#define  Pragma_Unreferenced                  139\n+#define  Pragma_Unreserve_All_Interrupts      140\n+#define  Pragma_Volatile                      141\n+#define  Pragma_Volatile_Components           142\n+#define  Pragma_Weak_External                 143\n+#define  Pragma_AST_Entry                     144\n+#define  Pragma_Interface                     145\n+#define  Pragma_Storage_Size                  146\n+#define  Pragma_Storage_Unit                  147\n \n /* End of snames.h (C version of Snames package spec) */"}, {"sha": "3a3327ab63f6f7c59c4d5084fd417e783c54ff99", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=d9e0a58787285a0753791dd83a5d831bbbc92117", "patch": "@@ -35,6 +35,7 @@\n #include \"rtl.h\"\n #include \"expr.h\"\n #include \"ggc.h\"\n+#include \"cgraph.h\"\n #include \"function.h\"\n #include \"except.h\"\n #include \"debug.h\"\n@@ -164,6 +165,7 @@ static tree pos_to_constructor (Node_Id, tree, Entity_Id);\n static tree maybe_implicit_deref (tree);\n static tree gnat_stabilize_reference_1 (tree, bool);\n static void annotate_with_node (tree, Node_Id);\n+static void build_global_cdtor (int, tree *);\n \n \f\n /* This is the main program of the back-end.  It sets up all the table\n@@ -410,7 +412,11 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t       && (! DECL_RENAMING_GLOBAL_P (gnu_result)\n \t\t   || global_bindings_p ())\n \t       /* Make sure it's an lvalue like INDIRECT_REF.  */\n-\t       && (DECL_P (renamed_obj) || REFERENCE_CLASS_P (renamed_obj)))\n+\t       && (DECL_P (renamed_obj)\n+\t\t   || REFERENCE_CLASS_P (renamed_obj)\n+\t\t   || (TREE_CODE (renamed_obj) == VIEW_CONVERT_EXPR\n+\t\t       && (DECL_P (TREE_OPERAND (renamed_obj, 0))\n+\t\t\t   || REFERENCE_CLASS_P (TREE_OPERAND (renamed_obj,0))))))\n \tgnu_result = renamed_obj;\n       else\n \tgnu_result = build_unary_op (INDIRECT_REF, NULL_TREE,\n@@ -2405,7 +2411,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n   Sloc_to_locus (Sloc (gnat_unit_entity), &cfun->function_end_locus);\n   cfun = 0;\n \n-      /* For a body, first process the spec if there is one. */\n+  /* For a body, first process the spec if there is one. */\n   if (Nkind (Unit (gnat_node)) == N_Package_Body\n       || (Nkind (Unit (gnat_node)) == N_Subprogram_Body\n \t      && !Acts_As_Spec (gnat_node)))\n@@ -2445,6 +2451,15 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n   /* Generate elaboration code for this unit, if necessary, and say whether\n      we did or not.  */\n   pop_stack (&gnu_elab_proc_stack);\n+\n+  /* Generate functions to call static constructors and destructors\n+     for targets that do not support .ctors/.dtors sections.  These\n+     functions have magic names which are detected by collect2.  */\n+  if (static_ctors)\n+    build_global_cdtor ('I', &static_ctors);\n+\n+  if (static_dtors)\n+    build_global_cdtor ('D', &static_dtors);\n }\n \f\n /* This function is the driver of the GNAT to GCC tree transformation\n@@ -5353,8 +5368,8 @@ addressable_p (tree gnu_expr)\n \n     case COMPONENT_REF:\n       return (!DECL_BIT_FIELD (TREE_OPERAND (gnu_expr, 1))\n-\t      && (!DECL_NONADDRESSABLE_P (TREE_OPERAND (gnu_expr, 1))\n-\t\t  || !flag_strict_aliasing)\n+\t      && !(STRICT_ALIGNMENT\n+\t\t   && DECL_NONADDRESSABLE_P (TREE_OPERAND (gnu_expr, 1)))\n \t      && addressable_p (TREE_OPERAND (gnu_expr, 0)));\n \n     case ARRAY_REF:  case ARRAY_RANGE_REF:\n@@ -5859,6 +5874,28 @@ gnat_stabilize_reference_1 (tree e, bool force)\n   TREE_SIDE_EFFECTS (result) |= TREE_SIDE_EFFECTS (e);\n   return result;\n }\n+\n+/* Build a global constructor or destructor function.  METHOD_TYPE gives\n+   the type of the function and CDTORS points to the list of constructor\n+   or destructor functions to be invoked.  FIXME: Migrate into cgraph.  */\n+\n+static void\n+build_global_cdtor (int method_type, tree *cdtors)\n+{\n+  tree body = 0;\n+\n+  for (; *cdtors; *cdtors = TREE_CHAIN (*cdtors))\n+    {\n+      tree fn = TREE_VALUE (*cdtors);\n+      tree fntype = TREE_TYPE (fn);\n+      tree fnaddr = build1 (ADDR_EXPR, build_pointer_type (fntype), fn);\n+      tree fncall = build3 (CALL_EXPR, TREE_TYPE (fntype), fnaddr, NULL_TREE,\n+\t\t\t    NULL_TREE);\n+      append_to_statement_list (fncall, &body);\n+    }\n+\n+  cgraph_build_static_cdtor (method_type, body, DEFAULT_INIT_PRIORITY);\n+}\n \f\n extern char *__gnat_to_canonical_file_spec (char *);\n "}, {"sha": "b19cb45f67f50284fd7db857107471d1595ecd2e", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e0a58787285a0753791dd83a5d831bbbc92117/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=d9e0a58787285a0753791dd83a5d831bbbc92117", "patch": "@@ -74,6 +74,11 @@ tree gnat_std_decls[(int) ADT_LAST];\n /* Functions to call for each of the possible raise reasons.  */\n tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n \n+/* List of functions called automatically at the beginning and\n+   end of execution, on targets without .ctors/.dtors sections.  */\n+tree static_ctors;\n+tree static_dtors;\n+\n /* Associates a GNAT tree node to a GCC tree node. It is used in\n    `save_gnu_tree', `get_gnu_tree' and `present_gnu_tree'. See documentation\n    of `save_gnu_tree' for more info.  */\n@@ -1509,8 +1514,11 @@ process_attributes (tree decl, struct attrib *attr_list)\n \tbreak;\n \n       case ATTR_LINK_ALIAS:\n-\tTREE_STATIC (decl) = 1;\n-\tassemble_alias (decl, attr_list->name);\n+        if (! DECL_EXTERNAL (decl))\n+\t  {\n+\t    TREE_STATIC (decl) = 1;\n+\t    assemble_alias (decl, attr_list->name);\n+\t  }\n \tbreak;\n \n       case ATTR_WEAK_EXTERNAL:\n@@ -1533,6 +1541,16 @@ process_attributes (tree decl, struct attrib *attr_list)\n \t  post_error (\"?section attributes are not supported for this target\",\n \t\t      attr_list->error_point);\n \tbreak;\n+\n+      case ATTR_LINK_CONSTRUCTOR:\n+\tDECL_STATIC_CONSTRUCTOR (decl) = 1;\n+\tTREE_USED (decl) = 1;\n+\tbreak;\n+\n+      case ATTR_LINK_DESTRUCTOR:\n+\tDECL_STATIC_DESTRUCTOR (decl) = 1;\n+\tTREE_USED (decl) = 1;\n+\tbreak;\n       }\n }\n \f\n@@ -1728,6 +1746,14 @@ end_subprog_body (tree body)\n   if (type_annotate_only)\n     return;\n \n+  /* If we don't have .ctors/.dtors sections, and this is a static\n+     constructor or destructor, it must be recorded now.  */\n+  if (DECL_STATIC_CONSTRUCTOR (fndecl) && !targetm.have_ctors_dtors)\n+    static_ctors = tree_cons (NULL_TREE, fndecl, static_ctors);\n+\n+  if (DECL_STATIC_DESTRUCTOR (fndecl) && !targetm.have_ctors_dtors)\n+    static_dtors = tree_cons (NULL_TREE, fndecl, static_dtors);\n+\n   /* We do different things for nested and non-nested functions.\n      ??? This should be in cgraph.  */\n   if (!DECL_CONTEXT (fndecl))"}]}