{"sha": "06b021af7b30d4aa8793f2f638b701462788d814", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZiMDIxYWY3YjMwZDRhYTg3OTNmMmY2MzhiNzAxNDYyNzg4ZDgxNA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-05-01T21:36:18Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-05-01T21:36:18Z"}, "message": "re PR libgcj/10582 (array assignment fails in some situations)\n\n\tPR libgcj/10582:\n\t* verify.cc (_Jv_BytecodeVerifier::is_assignable_from_slow):\n\tRemoved.\n\t(type::compatible): Use _Jv_IsAssignableFrom.\n\t* java/lang/natClass.cc (iindex_mutex_initialized): Now static.\n\t(_Jv_IsAssignableFrom): Work even when source or target class is\n\tnot prepared.\n\nFrom-SVN: r66348", "tree": {"sha": "440306528a8f43570c476adff8f6b799ce240878", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/440306528a8f43570c476adff8f6b799ce240878"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06b021af7b30d4aa8793f2f638b701462788d814", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06b021af7b30d4aa8793f2f638b701462788d814", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06b021af7b30d4aa8793f2f638b701462788d814", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06b021af7b30d4aa8793f2f638b701462788d814/comments", "author": null, "committer": null, "parents": [{"sha": "c93139b8267b5bf6debc9f697eb49b0d6dfe43d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c93139b8267b5bf6debc9f697eb49b0d6dfe43d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c93139b8267b5bf6debc9f697eb49b0d6dfe43d4"}], "stats": {"total": 112, "additions": 36, "deletions": 76}, "files": [{"sha": "0c956560c1eac56b8a11ca57c053f33e67fcd5dd", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b021af7b30d4aa8793f2f638b701462788d814/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b021af7b30d4aa8793f2f638b701462788d814/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=06b021af7b30d4aa8793f2f638b701462788d814", "patch": "@@ -1,3 +1,13 @@\n+2003-04-30  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR libgcj/10582:\n+\t* verify.cc (_Jv_BytecodeVerifier::is_assignable_from_slow):\n+\tRemoved.\n+\t(type::compatible): Use _Jv_IsAssignableFrom.\n+\t* java/lang/natClass.cc (iindex_mutex_initialized): Now static.\n+\t(_Jv_IsAssignableFrom): Work even when source or target class is\n+\tnot prepared.\n+\n 2003-04-30  Michael Koch  <konqueror@gmx.de>\n \n \t* java/text/BreakIterator.java"}, {"sha": "0db8228d63bb727ab04e8c303006dc64cb3568a6", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b021af7b30d4aa8793f2f638b701462788d814/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b021af7b30d4aa8793f2f638b701462788d814/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=06b021af7b30d4aa8793f2f638b701462788d814", "patch": "@@ -981,14 +981,14 @@ _Jv_IsAssignableFrom (jclass target, jclass source)\n {\n   if (source == target)\n     return true;\n-     \n+\n   // If target is array, so must source be.  \n-  if (target->isArray ())\n+  while (target->isArray ())\n     {\n       if (! source->isArray())\n \treturn false;\n-      return _Jv_IsAssignableFrom(target->getComponentType(), \n-                                  source->getComponentType());\n+      target = target->getComponentType();\n+      source = source->getComponentType();\n     }\n \n   if (target->isInterface())\n@@ -998,7 +998,7 @@ _Jv_IsAssignableFrom (jclass target, jclass source)\n       if (__builtin_expect \n           (source->idt == NULL || source->isInterface(), false))\n         return _Jv_InterfaceAssignableFrom (target, source);\n-\t\n+\n       _Jv_IDispatchTable *cl_idt = source->idt;\n       _Jv_IDispatchTable *if_idt = target->idt;\n \n@@ -1014,23 +1014,31 @@ _Jv_IsAssignableFrom (jclass target, jclass source)\n \t}\n       return false;\n     }\n-     \n+\n   // Primitive TYPE classes are only assignable to themselves.\n-  if (__builtin_expect (target->isPrimitive(), false))\n+  if (__builtin_expect (target->isPrimitive() || source->isPrimitive(), false))\n     return false;\n-    \n+\n   if (target == &java::lang::Object::class$)\n+    return true;\n+  else if (source->ancestors == NULL || target->ancestors == NULL)\n     {\n-      if (source->isPrimitive())\n-        return false;\n-      return true;\n+      // We need this case when either SOURCE or TARGET has not has\n+      // its constant-time tables prepared.\n+\n+      // At this point we know that TARGET can't be Object, so it is\n+      // safe to use that as the termination point.\n+      while (source && source != &java::lang::Object::class$)\n+\t{\n+\t  if (source == target)\n+\t    return true;\n+\t  source = source->getSuperclass();\n+\t}\n     }\n-  else if (source->ancestors != NULL\n-\t   && target->ancestors != NULL\n-\t   && source->depth >= target->depth\n+  else if (source->depth >= target->depth\n \t   && source->ancestors[source->depth - target->depth] == target)\n     return true;\n-      \n+\n   return false;\n }\n \n@@ -1373,7 +1381,7 @@ _Jv_AppendPartialITable (jclass klass, jclass iface, void **itable,\n }\n \n static _Jv_Mutex_t iindex_mutex;\n-bool iindex_mutex_initialized = false;\n+static bool iindex_mutex_initialized = false;\n \n // We need to find the correct offset in the Class Interface Dispatch \n // Table for a given interface. Once we have that, invoking an interface "}, {"sha": "3aacc273ae25502145c1f50350f18dde52465ac9", "filename": "libjava/verify.cc", "status": "modified", "additions": 2, "deletions": 60, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06b021af7b30d4aa8793f2f638b701462788d814/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06b021af7b30d4aa8793f2f638b701462788d814/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=06b021af7b30d4aa8793f2f638b701462788d814", "patch": "@@ -240,64 +240,6 @@ class _Jv_BytecodeVerifier\n     return get_type_val_for_signature ((jchar) k->method_count);\n   }\n \n-  // This is like _Jv_IsAssignableFrom, but it works even if SOURCE or\n-  // TARGET haven't been prepared.\n-  static bool is_assignable_from_slow (jclass target, jclass source)\n-  {\n-    // This will terminate when SOURCE==Object.\n-    while (true)\n-      {\n-\tif (source == target)\n-\t  return true;\n-\n-\tif (target->isPrimitive () || source->isPrimitive ())\n-\t  return false;\n-\n-\tif (target->isArray ())\n-\t  {\n-\t    if (! source->isArray ())\n-\t      return false;\n-\t    target = target->getComponentType ();\n-\t    source = source->getComponentType ();\n-\t  }\n-\telse if (target->isInterface ())\n-\t  {\n-\t    for (int i = 0; i < source->interface_count; ++i)\n-\t      {\n-\t\t// We use a recursive call because we also need to\n-\t\t// check superinterfaces.\n-\t\tif (is_assignable_from_slow (target, source->interfaces[i]))\n-\t\t    return true;\n-\t      }\n-\t    source = source->getSuperclass ();\n-\t    if (source == NULL)\n-\t      return false;\n-\t  }\n-\t// We must do this check before we check to see if SOURCE is\n-\t// an interface.  This way we know that any interface is\n-\t// assignable to an Object.\n-\telse if (target == &java::lang::Object::class$)\n-\t  return true;\n-\telse if (source->isInterface ())\n-\t  {\n-\t    for (int i = 0; i < target->interface_count; ++i)\n-\t      {\n-\t\t// We use a recursive call because we also need to\n-\t\t// check superinterfaces.\n-\t\tif (is_assignable_from_slow (target->interfaces[i], source))\n-\t\t  return true;\n-\t      }\n-\t    target = target->getSuperclass ();\n-\t    if (target == NULL)\n-\t      return false;\n-\t  }\n-\telse if (source == &java::lang::Object::class$)\n-\t  return false;\n-\telse\n-\t  source = source->getSuperclass ();\n-      }\n-  }\n-\n   // This is used to keep track of which `jsr's correspond to a given\n   // jsr target.\n   struct subr_info\n@@ -520,7 +462,7 @@ class _Jv_BytecodeVerifier\n       // We must resolve both types and check assignability.\n       resolve (verifier);\n       k.resolve (verifier);\n-      return is_assignable_from_slow (data.klass, k.data.klass);\n+      return _Jv_IsAssignableFrom (data.klass, k.data.klass);\n     }\n \n     bool isvoid () const\n@@ -707,7 +649,7 @@ class _Jv_BytecodeVerifier\n \t\t  // Ordinarily this terminates when we hit Object...\n \t\t  while (k != NULL)\n \t\t    {\n-\t\t      if (is_assignable_from_slow (k, oldk))\n+\t\t      if (_Jv_IsAssignableFrom (k, oldk))\n \t\t\tbreak;\n \t\t      k = k->getSuperclass ();\n \t\t      changed = true;"}]}