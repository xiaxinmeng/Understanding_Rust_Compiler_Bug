{"sha": "e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYzNjM3ZWE5MDg2M2Y5ZTA2YmRhMjFmODBjNGM0YzQ5ZDk5YzljZQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2007-10-18T15:22:58Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2007-10-18T15:22:58Z"}, "message": "re PR libstdc++/30085 (switch debug mode hash containers from ext to tr1)\n\n2007-10-18  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/ext/hash_map: To...\n\t* include/backward/hash_map: ...here. Remove debug mode.\n\t* include/ext/hash_set: To...\n\t* include/backward/hash_set: ...here. Remove debug mode.\n\t* include/ext/hash_fun.h: To...\n\t* include/backward/hash_fun.h: ...here.\n\t* include/ext/hashtable.h: To...\n\t* include/backward/hashtable.h: ...here.\n\t\n\t* include/bits/c++config: Remove __gnu_cxx namespace from debug mode.\n\t* include/debug/debug.h: Same.\n\t\t\n\t* include/debug/hash_map: Remove.\n\t* include/debug/hash_multimap.h: Remove.\n\t* include/debug/hash_set.h: Remove.\n\t* include/debug/hash_set: Remove.\n\t* include/debug/hash_multiset.h: Remove.\n\t* include/debug/hash_map.h: Remove.\n\t\n\t* include/Makefile.am (ext_headers): Move hash_set, hash_map to\n\tbackward.\n\t(debug_headers): Remove hash_map, hash_set, hash_map.h,\n\thash_map.h, hash_multiset.h, hash_multimap.h.\t\n\t* include/Makefile.in: Regenerate.\n\n\t* docs/html/debug.html: Update.\n\t* docs/html/ext/howto.html: Same.\n\t* docs/html/faq/index.html: Same.\n\t* docs/doxygen/Intro.3: Same.\n\t* docs/doxygen/user.cfg.in: Adjust includes.\n\t* testsuite/ext/hash_map: Move to...\n\t* testsuite/backward/hash_map: ...here.\n\t* testsuite/ext/hash_set: Move to...\n\t* testsuite/backward/hash_set: ...here.\n\t\n2007-10-18  Benjamin Kosnik  <bkoz@redhat.com>\n        \n\tRemoval of pre-ISO C++ items from include/backwards.\n\t* include/Makefile.am (backward_headers): Remove all but strstream,\n\tbackward_warning.h.\n\t* include/Makefile.in: Regenerate.\n\t* include/backward/new.h: Remove.\n\t* include/backward/iterator.h: Same.\n\t* include/backward/alloc.h: Same.\n\t* include/backward/set.h: Same.\n\t* include/backward/hashtable.h: Same.\n\t* include/backward/hash_set.h: Same.\n\t* include/backward/fstream.h: Same.\n\t* include/backward/tempbuf.h: Same.\n\t* include/backward/istream.h: Same.\n\t* include/backward/bvector.h: Same.\n\t* include/backward/stack.h: Same.\n\t* include/backward/rope.h: Same.\n\t* include/backward/complex.h: Same.\n\t* include/backward/ostream.h: Same.\n\t* include/backward/heap.h: Same.\n\t* include/backward/iostream.h: Same.\n\t* include/backward/function.h: Same.\n\t* include/backward/multimap.h: Same.\n\t* include/backward/pair.h: Same.\n\t* include/backward/stream.h: Same.\n\t* include/backward/iomanip.h: Same.\n\t* include/backward/slist.h: Same.\n\t* include/backward/tree.h: Same.\n\t* include/backward/vector.h: Same.\n\t* include/backward/deque.h: Same.\n\t* include/backward/multiset.h: Same.\n\t* include/backward/defalloc.h: Same.\n\t* include/backward/list.h: Same.\n\t* include/backward/map.h: Same.\n\t* include/backward/algobase.h: Same.\n\t* include/backward/hash_map.h: Same.\n\t* include/backward/algo.h: Same.\n\t* include/backward/queue.h: Same.\n\t* include/backward/streambuf.h: Same.\n\t* testsuite/backward/header_hash_set_h.cc: Same.\n\t* testsuite/backward/header_slist_h.cc: Same.\n\t* testsuite/backward/header_hash_map_h.cc: Same.\n\t* testsuite/backward/header_tempbuf_h.cc: Same.\n\t* testsuite/backward/header_deque_h.cc: Same.\n\t* testsuite/backward/header_rope_h.cc: Same.\n\t* testsuite/backward/header_iterator_h.cc: Same.\n\t* testsuite/backward/header_hashtable_h.cc: Same.\n\n2007-10-18  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tPR libstdc++/30085\n\t* include/debug/unordered_map: New.\n\t* include/debug/unordered_set: New.\n\t* include/debug/safe_association.h: New.\t\n\t* include/std/unordered_map: Include debug header if _GLIBCXX_DEBUG.\n\t* include/std/unordered_set: Same.\n\t* include/Makefile.am (debug_headers): Add unordered_map,\n\tunordered_set, safe_association.h.\n\t* include/Makefile.in: Regenerate.\n\t* testsuite/23_containers/unordered_map/requirements/debug.cc: New.\n\t* testsuite/23_containers/unordered_multimap/requirements/\n\tdebug.cc: New.\n\t* testsuite/23_containers/unordered_set/requirements/debug.cc: New.\n\t* testsuite/23_containers/unordered_multiset/requirements/\n\tdebug.cc: New.\n\n2007-10-18  Benjamin Kosnik  <bkoz@redhat.com>\n\t\n\t* testsuite/util/native_type/assoc/native_hash_multimap.hpp: Remove\n\thash_map include.\n\nFrom-SVN: r129442", "tree": {"sha": "5c6283d7c5bcdf986bf35763b76c14af3d93e82a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c6283d7c5bcdf986bf35763b76c14af3d93e82a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/comments", "author": null, "committer": null, "parents": [{"sha": "e445a2ff978362e261a74f26fe5e06d539ed893b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e445a2ff978362e261a74f26fe5e06d539ed893b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e445a2ff978362e261a74f26fe5e06d539ed893b"}], "stats": {"total": 6634, "additions": 1843, "deletions": 4791}, "files": [{"sha": "7014fbcdd42adfe4f08b10cb364048e19dab47cc", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -1,3 +1,112 @@\n+2007-10-18  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/ext/hash_map: To...\n+\t* include/backward/hash_map: ...here. Remove debug mode.\n+\t* include/ext/hash_set: To...\n+\t* include/backward/hash_set: ...here. Remove debug mode.\n+\t* include/ext/hash_fun.h: To...\n+\t* include/backward/hash_fun.h: ...here.\n+\t* include/ext/hashtable.h: To...\n+\t* include/backward/hashtable.h: ...here.\n+\t\n+\t* include/bits/c++config: Remove __gnu_cxx namespace from debug mode.\n+\t* include/debug/debug.h: Same.\n+\t\t\n+\t* include/debug/hash_map: Remove.\n+\t* include/debug/hash_multimap.h: Remove.\n+\t* include/debug/hash_set.h: Remove.\n+\t* include/debug/hash_set: Remove.\n+\t* include/debug/hash_multiset.h: Remove.\n+\t* include/debug/hash_map.h: Remove.\n+\t\n+\t* include/Makefile.am (ext_headers): Move hash_set, hash_map to\n+\tbackward.\n+\t(debug_headers): Remove hash_map, hash_set, hash_map.h,\n+\thash_map.h, hash_multiset.h, hash_multimap.h.\t\n+\t* include/Makefile.in: Regenerate.\n+\n+\t* docs/html/debug.html: Update.\n+\t* docs/html/ext/howto.html: Same.\n+\t* docs/html/faq/index.html: Same.\n+\t* docs/doxygen/Intro.3: Same.\n+\t* docs/doxygen/user.cfg.in: Adjust includes.\n+\t* testsuite/ext/hash_map: Move to...\n+\t* testsuite/backward/hash_map: ...here.\n+\t* testsuite/ext/hash_set: Move to...\n+\t* testsuite/backward/hash_set: ...here.\n+\t\n+2007-10-18  Benjamin Kosnik  <bkoz@redhat.com>\n+        \n+\tRemoval of pre-ISO C++ items from include/backwards.\n+\t* include/Makefile.am (backward_headers): Remove all but strstream,\n+\tbackward_warning.h.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/backward/new.h: Remove.\n+\t* include/backward/iterator.h: Same.\n+\t* include/backward/alloc.h: Same.\n+\t* include/backward/set.h: Same.\n+\t* include/backward/hashtable.h: Same.\n+\t* include/backward/hash_set.h: Same.\n+\t* include/backward/fstream.h: Same.\n+\t* include/backward/tempbuf.h: Same.\n+\t* include/backward/istream.h: Same.\n+\t* include/backward/bvector.h: Same.\n+\t* include/backward/stack.h: Same.\n+\t* include/backward/rope.h: Same.\n+\t* include/backward/complex.h: Same.\n+\t* include/backward/ostream.h: Same.\n+\t* include/backward/heap.h: Same.\n+\t* include/backward/iostream.h: Same.\n+\t* include/backward/function.h: Same.\n+\t* include/backward/multimap.h: Same.\n+\t* include/backward/pair.h: Same.\n+\t* include/backward/stream.h: Same.\n+\t* include/backward/iomanip.h: Same.\n+\t* include/backward/slist.h: Same.\n+\t* include/backward/tree.h: Same.\n+\t* include/backward/vector.h: Same.\n+\t* include/backward/deque.h: Same.\n+\t* include/backward/multiset.h: Same.\n+\t* include/backward/defalloc.h: Same.\n+\t* include/backward/list.h: Same.\n+\t* include/backward/map.h: Same.\n+\t* include/backward/algobase.h: Same.\n+\t* include/backward/hash_map.h: Same.\n+\t* include/backward/algo.h: Same.\n+\t* include/backward/queue.h: Same.\n+\t* include/backward/streambuf.h: Same.\n+\t* testsuite/backward/header_hash_set_h.cc: Same.\n+\t* testsuite/backward/header_slist_h.cc: Same.\n+\t* testsuite/backward/header_hash_map_h.cc: Same.\n+\t* testsuite/backward/header_tempbuf_h.cc: Same.\n+\t* testsuite/backward/header_deque_h.cc: Same.\n+\t* testsuite/backward/header_rope_h.cc: Same.\n+\t* testsuite/backward/header_iterator_h.cc: Same.\n+\t* testsuite/backward/header_hashtable_h.cc: Same.\n+\n+2007-10-18  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tPR libstdc++/30085\n+\t* include/debug/unordered_map: New.\n+\t* include/debug/unordered_set: New.\n+\t* include/debug/safe_association.h: New.\t\n+\t* include/std/unordered_map: Include debug header if _GLIBCXX_DEBUG.\n+\t* include/std/unordered_set: Same.\n+\t* include/Makefile.am (debug_headers): Add unordered_map,\n+\tunordered_set, safe_association.h.\n+\t* include/Makefile.in: Regenerate.\n+\t* testsuite/23_containers/unordered_map/requirements/debug.cc: New.\n+\t* testsuite/23_containers/unordered_multimap/requirements/\n+\tdebug.cc: New.\n+\t* testsuite/23_containers/unordered_set/requirements/debug.cc: New.\n+\t* testsuite/23_containers/unordered_multiset/requirements/\n+\tdebug.cc: New.\n+\n+2007-10-18  Benjamin Kosnik  <bkoz@redhat.com>\n+\t\n+\t* testsuite/util/native_type/assoc/native_hash_multimap.hpp: Remove\n+\thash_map include.\n+\n 2007-10-18  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/33807"}, {"sha": "1c7bcd3f9ccaa6ff2c7dba594fb40ec0f6eee190", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -84,6 +84,9 @@\n /* Define if ENOTRECOVERABLE exists. */\n #undef HAVE_ENOTRECOVERABLE\n \n+/* Define if EOVERFLOW exists. */\n+#undef HAVE_EOVERFLOW\n+\n /* Define if EOWNERDEAD exists. */\n #undef HAVE_EOWNERDEAD\n "}, {"sha": "cb3ff2e4a1eaf027a1088000863f5320c4b4f3f7", "filename": "libstdc++-v3/docs/doxygen/Intro.3", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2FIntro.3", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2FIntro.3", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2FIntro.3?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -77,15 +77,7 @@ read FAQ 5.4 and use a\n prefix.\n .TS\n lB lB lB lB.\n-<algo.h>      <hash_map.h>   <map.h>       <slist.h>\n-<algobase.h>  <hash_set.h>   <multimap.h>  <stack.h>\n-<alloc.h>     <hashtable.h>  <multiset.h>  <stream.h>\n-<bvector.h>   <heap.h>       <new.h>       <streambuf.h>\n-<complex.h>   <iomanip.h>    <ostream.h>   <strstream>\n-<defalloc.h>  <iostream.h>   <pair.h>      <strstream.h>\n-<deque.h>     <istream.h>    <queue.h>     <tempbuf.h>\n-<fstream.h>   <iterator.h>   <rope.h>      <tree.h>\n-<function.h>  <list.h>       <set.h>       <vector.h>\n+<strstream>\n .TE\n .SS Extension Headers\n These headers will only be found automatically if you include the leading\n@@ -98,7 +90,6 @@ lB lB.\n <ext/algorithm>            <ext/numeric>            \n <ext/functional>           <ext/iterator>\n <ext/slist>                <ext/rb_tree>  \n-<ext/hash_map>             <ext/hash_set>           \n <ext/rope>                 <ext/memory>               \n <ext/bitmap_allocator.h>   <ext/debug_allocator.h>    \n <ext/malloc_allocator.h>   <ext/mt_allocator.h>     "}, {"sha": "20a041e0f99bd211b6d29c124d6aeb5eeda27f0f", "filename": "libstdc++-v3/docs/doxygen/user.cfg.in", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fuser.cfg.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fuser.cfg.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fuser.cfg.in?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -542,19 +542,17 @@ INPUT                  = @srcdir@/docs/doxygen/doxygroups.cc \\\n                          include/utility \\\n                          include/valarray \\\n                          include/vector \\\n+                         include/backward/hash_map \\\n+                         include/backward/hash_set \\\n                          include/debug/bitset \\\n                          include/debug/deque \\\n-                         include/debug/hash_map \\\n-                         include/debug/hash_set \\\n                          include/debug/list \\\n                          include/debug/map \\\n                          include/debug/set \\\n                          include/debug/string \\\n                          include/debug/vector \\\n                          include/ext/algorithm \\\n                          include/ext/functional \\\n-                         include/ext/hash_map \\\n-                         include/ext/hash_set \\\n                          include/ext/iterator \\\n                          include/ext/memory \\\n                          include/ext/numeric \\"}, {"sha": "60e8418a6342f8a2a150eff0b7ee9f012b65b118", "filename": "libstdc++-v3/docs/html/debug.html", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdebug.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdebug.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdebug.html?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -231,29 +231,36 @@ <h4 class=\"left\">Using the debugging containers without debug\n     <td>__gnu_debug::vector</td>\n     <td>&lt;debug/vector&gt;</td>\n   </tr>\n+</table>\n+\n+<p>In addition, when compiling in C++0x mode, these additional\n+containers have additional debug capability.\n+</p>\n+\n+<table>\n   <tr>\n-    <td>__gnu_cxx::hash_map</td>\n-    <td>&lt;ext/hash_map&gt;</td>\n-    <td>__gnu_debug::hash_map</td>\n-    <td>&lt;debug/hash_map&gt;</td>\n+    <td>std::unordered_map</td>\n+    <td>&lt;unordered_map&gt;</td>\n+    <td>__gnu_debug::unordered_map</td>\n+    <td>&lt;debug/unordered_map&gt;</td>\n   </tr>\n   <tr>\n-    <td>__gnu_cxx::hash_multimap</td>\n-    <td>&lt;ext/hash_map&gt;</td>\n-    <td>__gnu_debug::hash_multimap</td>\n-    <td>&lt;debug/hash_map&gt;</td>\n+    <td>std::unordered_multimap</td>\n+    <td>&lt;unordered_map&gt;</td>\n+    <td>__gnu_debug::unordered_multimap</td>\n+    <td>&lt;debug/unordered_map&gt;</td>\n   </tr>\n   <tr>\n-    <td>__gnu_cxx::hash_set</td>\n-    <td>&lt;ext/hash_set&gt;</td>\n-    <td>__gnu_debug::hash_set</td>\n-    <td>&lt;debug/hash_set&gt;</td>\n+    <td>std::unordered_set</td>\n+    <td>&lt;unordered_set&gt;</td>\n+    <td>__gnu_debug::unordered_set</td>\n+    <td>&lt;debug/unordered_set&gt;</td>\n   </tr>\n   <tr>\n-    <td>__gnu_cxx::hash_multiset</td>\n-    <td>&lt;ext/hash_set&gt;</td>\n-    <td>__gnu_debug::hash_multiset</td>\n-    <td>&lt;debug/hash_set&gt;</td>\n+    <td>std::unordered_multiset</td>\n+    <td>&lt;unordered_set&gt;</td>\n+    <td>__gnu_debug::unordered_multiset</td>\n+    <td>&lt;debug/unordered_set&gt;</td>\n   </tr>\n </table>\n \n@@ -308,10 +315,10 @@ <h4 class=\"left\">Debug mode semantics</h4>\n   <li><code>std::multiset</code></li>\n   <li><code>std::set</code></li>\n   <li><code>std::vector</code></li>\n-  <li><code>__gnu_cxx::hash_map</code></li>\n-  <li><code>__gnu_cxx::hash_multimap</code></li>\n-  <li><code>__gnu_cxx::hash_multiset</code></li>\n-  <li><code>__gnu_cxx::hash_set</code></li>\n+  <li><code>std::unordered_map</code></li>\n+  <li><code>std::unordered_multimap</code></li>\n+  <li><code>std::unordered_set</code></li>\n+  <li><code>std::unordered_multiset</code></li>\n </ul>\n \n "}, {"sha": "cb544aa24c025c5064a47e1db382f2504f4c61c9", "filename": "libstdc++-v3/docs/html/ext/howto.html", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -63,27 +63,28 @@ <h1>Contents</h1>\n <h2><a name=\"1\">Ropes and trees and hashes, oh my!</a></h2>\n    <p>The SGI headers</p>\n    <pre>\n-     &lt;bvector&gt;\n      &lt;hash_map&gt;\n      &lt;hash_set&gt;\n      &lt;rope&gt;\n      &lt;slist&gt;\n-     &lt;tree&gt;\n+     &lt;rb_tree&gt;\n    </pre>\n-   <p>are all here; <code>&lt;bvector&gt;</code> exposes the old bit_vector\n-      class that was used before specialization of vector&lt;bool&gt; was\n-      available (it's actually a typedef for the specialization now).\n+   <p>are all here;\n       <code>&lt;hash_map&gt;</code> and <code>&lt;hash_set&gt;</code>\n-      are discussed further below.  <code>&lt;rope&gt;</code> is the SGI\n-      specialization for large strings (&quot;rope,&quot; &quot;large\n-      strings,&quot; get it?  love those SGI folks).\n+      are deprecated but available as backwards-compatible extensions,\n+      as discussed further below.  <code>&lt;rope&gt;</code> is the\n+      SGI specialization for large strings (&quot;rope,&quot;\n+      &quot;large strings,&quot; get it?  love those SGI folks).\n       <code>&lt;slist&gt;</code> is a singly-linked list, for when the\n-      doubly-linked <code>list&lt;&gt;</code> is too much space overhead, and\n-      <code>&lt;tree&gt;</code> exposes the red-black tree classes used in the\n-      implementation of the standard maps and sets.\n+      doubly-linked <code>list&lt;&gt;</code> is too much space\n+      overhead, and <code>&lt;rb_tree&gt;</code> exposes the red-black\n+      tree classes used in the implementation of the standard maps and\n+      sets.\n    </p>\n-   <p>Okay, about those hashing classes...  I'm going to foist most of the\n-      work off onto SGI's own site.\n+   <p>Okay, about those hashing classes... these classes have been\n+   deprecated by the unordered_set, unordered_multiset, unordered_map,\n+   unordered_multimap containers in TR1 and the upcoming C++0x, and\n+   may be removed in future releases.\n    </p>\n    <p>Each of the associative containers map, multimap, set, and multiset\n       have a counterpart which uses a"}, {"sha": "e38732e5833df4d30c11ec48bf0f607956654c62", "filename": "libstdc++-v3/docs/html/faq/index.html", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.html?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -927,7 +927,7 @@ <h2><a name=\"5_4\">5.4 Extensions and Backward Compatibility</a></h2>\n          <!-- Careful, the leading spaces in PRE show up directly. -->\n       </p>\n       <pre>\n-      #include &lt;ext/hash_map&gt; </pre>\n+      #include &lt;backward/hash_map&gt; </pre>\n       <p>rather than using <code>-I</code> or other options.  This is more\n          portable and forward-compatible.  (The situation is the same as\n          that of other headers whose directories are not searched directly,\n@@ -950,20 +950,20 @@ <h2><a name=\"5_4\">5.4 Extensions and Backward Compatibility</a></h2>\n       #ifdef __GNUC__\n       #if __GNUC__ &lt; 3\n         #include &lt;hash_map.h&gt;\n-        namespace Sgi { using ::hash_map; }; // inherit globals\n+        namespace extension { using ::hash_map; }; // inherit globals\n       #else\n-        #include &lt;ext/hash_map&gt;\n+        #include &lt;backward/hash_map&gt;\n         #if __GNUC_MINOR__ == 0\n-          namespace Sgi = std;               // GCC 3.0\n+          namespace extension = std;               // GCC 3.0\n         #else\n-          namespace Sgi = ::__gnu_cxx;       // GCC 3.1 and later\n+          namespace extension = ::__gnu_cxx;       // GCC 3.1 and later\n         #endif\n       #endif\n       #else      // ...  there are other compilers, right?\n-        namespace Sgi = std;\n+        namespace extension = std;\n       #endif\n \n-      Sgi::hash_map&lt;int,int&gt; my_map; </pre>\n+      extension::hash_map&lt;int,int&gt; my_map; </pre>\n       <p>This is a bit cleaner than defining typedefs for all the\n          instantiations you might need.\n       </p>"}, {"sha": "e1d9e0b6071a90550b25597b7404b9d8fd55065c", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 7, "deletions": 45, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -145,41 +145,11 @@ bits_headers = \\\n backward_srcdir = ${glibcxx_srcdir}/include/backward\n backward_builddir = ./backward\n backward_headers = \\\n-\t${backward_srcdir}/complex.h \\\n-\t${backward_srcdir}/iomanip.h \\\n-\t${backward_srcdir}/istream.h \\\n-\t${backward_srcdir}/ostream.h \\\n-\t${backward_srcdir}/stream.h \\\n-\t${backward_srcdir}/streambuf.h \\\n-\t${backward_srcdir}/algo.h \\\n-\t${backward_srcdir}/algobase.h \\\n-\t${backward_srcdir}/alloc.h \\\n-\t${backward_srcdir}/bvector.h \\\n-\t${backward_srcdir}/defalloc.h \\\n-\t${backward_srcdir}/deque.h \\\n-\t${backward_srcdir}/function.h \\\n-\t${backward_srcdir}/hash_map.h \\\n-\t${backward_srcdir}/hash_set.h \\\n-\t${backward_srcdir}/hashtable.h \\\n-\t${backward_srcdir}/heap.h \\\n-\t${backward_srcdir}/iostream.h \\\n-\t${backward_srcdir}/iterator.h \\\n-\t${backward_srcdir}/list.h \\\n-\t${backward_srcdir}/map.h \\\n-\t${backward_srcdir}/multimap.h \\\n-\t${backward_srcdir}/new.h \\\n-\t${backward_srcdir}/multiset.h \\\n-\t${backward_srcdir}/pair.h \\\n-\t${backward_srcdir}/queue.h \\\n-\t${backward_srcdir}/rope.h \\\n-\t${backward_srcdir}/set.h \\\n-\t${backward_srcdir}/slist.h \\\n-\t${backward_srcdir}/stack.h \\\n-\t${backward_srcdir}/tempbuf.h \\\n-\t${backward_srcdir}/tree.h \\\n-\t${backward_srcdir}/vector.h \\\n-\t${backward_srcdir}/fstream.h \\\n \t${backward_srcdir}/strstream \\\n+\t${backward_srcdir}/hash_map \\\n+\t${backward_srcdir}/hash_set \\\n+\t${backward_srcdir}/hash_fun.h \\\n+\t${backward_srcdir}/hashtable.h \\\n \t${backward_srcdir}/backward_warning.h\n \n pb_srcdir = ${glibcxx_srcdir}/include/ext/pb_ds\n@@ -496,7 +466,6 @@ pb_headers7 = \\\n \t${pb_srcdir}/detail/unordered_iterator/point_iterator.hpp \n \n \n-\n ext_srcdir = ${glibcxx_srcdir}/include/ext\n ext_builddir = ./ext \n ext_headers = \\\n@@ -511,10 +480,6 @@ ext_headers = \\\n \t${ext_srcdir}/stdio_filebuf.h \\\n \t${ext_srcdir}/stdio_sync_filebuf.h \\\n \t${ext_srcdir}/functional \\\n-\t${ext_srcdir}/hash_map \\\n-\t${ext_srcdir}/hash_set \\\n-\t${ext_srcdir}/hash_fun.h \\\n-\t${ext_srcdir}/hashtable.h \\\n \t${ext_srcdir}/iterator \\\n \t${ext_srcdir}/malloc_allocator.h \\\n \t${ext_srcdir}/memory \\\n@@ -711,25 +676,22 @@ debug_headers = \\\n \t${debug_srcdir}/deque \\\n \t${debug_srcdir}/formatter.h \\\n \t${debug_srcdir}/functions.h \\\n-\t${debug_srcdir}/hash_map \\\n-\t${debug_srcdir}/hash_map.h \\\n-\t${debug_srcdir}/hash_multimap.h \\\n-\t${debug_srcdir}/hash_multiset.h \\\n-\t${debug_srcdir}/hash_set \\\n-\t${debug_srcdir}/hash_set.h \\\n \t${debug_srcdir}/list \\\n \t${debug_srcdir}/map \\\n \t${debug_srcdir}/macros.h \\\n \t${debug_srcdir}/map.h \\\n \t${debug_srcdir}/multimap.h \\\n \t${debug_srcdir}/multiset.h \\\n+\t${debug_srcdir}/safe_association.h \\\n \t${debug_srcdir}/safe_base.h \\\n \t${debug_srcdir}/safe_iterator.h \\\n \t${debug_srcdir}/safe_iterator.tcc \\\n \t${debug_srcdir}/safe_sequence.h \\\n \t${debug_srcdir}/set \\\n \t${debug_srcdir}/set.h \\\n \t${debug_srcdir}/string \\\n+\t${debug_srcdir}/unordered_map \\\n+\t${debug_srcdir}/unordered_set \\\n \t${debug_srcdir}/vector\n \n # Parallel mode headers"}, {"sha": "c4a65c51f033b0dbc903255ed4453d5093b1938c", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 7, "deletions": 44, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -394,41 +394,11 @@ bits_headers = \\\n backward_srcdir = ${glibcxx_srcdir}/include/backward\n backward_builddir = ./backward\n backward_headers = \\\n-\t${backward_srcdir}/complex.h \\\n-\t${backward_srcdir}/iomanip.h \\\n-\t${backward_srcdir}/istream.h \\\n-\t${backward_srcdir}/ostream.h \\\n-\t${backward_srcdir}/stream.h \\\n-\t${backward_srcdir}/streambuf.h \\\n-\t${backward_srcdir}/algo.h \\\n-\t${backward_srcdir}/algobase.h \\\n-\t${backward_srcdir}/alloc.h \\\n-\t${backward_srcdir}/bvector.h \\\n-\t${backward_srcdir}/defalloc.h \\\n-\t${backward_srcdir}/deque.h \\\n-\t${backward_srcdir}/function.h \\\n-\t${backward_srcdir}/hash_map.h \\\n-\t${backward_srcdir}/hash_set.h \\\n-\t${backward_srcdir}/hashtable.h \\\n-\t${backward_srcdir}/heap.h \\\n-\t${backward_srcdir}/iostream.h \\\n-\t${backward_srcdir}/iterator.h \\\n-\t${backward_srcdir}/list.h \\\n-\t${backward_srcdir}/map.h \\\n-\t${backward_srcdir}/multimap.h \\\n-\t${backward_srcdir}/new.h \\\n-\t${backward_srcdir}/multiset.h \\\n-\t${backward_srcdir}/pair.h \\\n-\t${backward_srcdir}/queue.h \\\n-\t${backward_srcdir}/rope.h \\\n-\t${backward_srcdir}/set.h \\\n-\t${backward_srcdir}/slist.h \\\n-\t${backward_srcdir}/stack.h \\\n-\t${backward_srcdir}/tempbuf.h \\\n-\t${backward_srcdir}/tree.h \\\n-\t${backward_srcdir}/vector.h \\\n-\t${backward_srcdir}/fstream.h \\\n \t${backward_srcdir}/strstream \\\n+\t${backward_srcdir}/hash_map \\\n+\t${backward_srcdir}/hash_set \\\n+\t${backward_srcdir}/hash_fun.h \\\n+\t${backward_srcdir}/hashtable.h \\\n \t${backward_srcdir}/backward_warning.h\n \n pb_srcdir = ${glibcxx_srcdir}/include/ext/pb_ds\n@@ -757,10 +727,6 @@ ext_headers = \\\n \t${ext_srcdir}/stdio_filebuf.h \\\n \t${ext_srcdir}/stdio_sync_filebuf.h \\\n \t${ext_srcdir}/functional \\\n-\t${ext_srcdir}/hash_map \\\n-\t${ext_srcdir}/hash_set \\\n-\t${ext_srcdir}/hash_fun.h \\\n-\t${ext_srcdir}/hashtable.h \\\n \t${ext_srcdir}/iterator \\\n \t${ext_srcdir}/malloc_allocator.h \\\n \t${ext_srcdir}/memory \\\n@@ -949,25 +915,22 @@ debug_headers = \\\n \t${debug_srcdir}/deque \\\n \t${debug_srcdir}/formatter.h \\\n \t${debug_srcdir}/functions.h \\\n-\t${debug_srcdir}/hash_map \\\n-\t${debug_srcdir}/hash_map.h \\\n-\t${debug_srcdir}/hash_multimap.h \\\n-\t${debug_srcdir}/hash_multiset.h \\\n-\t${debug_srcdir}/hash_set \\\n-\t${debug_srcdir}/hash_set.h \\\n \t${debug_srcdir}/list \\\n \t${debug_srcdir}/map \\\n \t${debug_srcdir}/macros.h \\\n \t${debug_srcdir}/map.h \\\n \t${debug_srcdir}/multimap.h \\\n \t${debug_srcdir}/multiset.h \\\n+\t${debug_srcdir}/safe_association.h \\\n \t${debug_srcdir}/safe_base.h \\\n \t${debug_srcdir}/safe_iterator.h \\\n \t${debug_srcdir}/safe_iterator.tcc \\\n \t${debug_srcdir}/safe_sequence.h \\\n \t${debug_srcdir}/set \\\n \t${debug_srcdir}/set.h \\\n \t${debug_srcdir}/string \\\n+\t${debug_srcdir}/unordered_map \\\n+\t${debug_srcdir}/unordered_set \\\n \t${debug_srcdir}/vector\n \n "}, {"sha": "247460105a4e7f217205c8f06d5a1aa08374e7b7", "filename": "libstdc++-v3/include/backward/algo.h", "status": "removed", "additions": 0, "deletions": 145, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgo.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,145 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _BACKWARD_ALGO_H\n-#define _BACKWARD_ALGO_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"algobase.h\"\n-#include \"tempbuf.h\"\n-#include \"iterator.h\"\n-#include <bits/stl_algo.h>\n-#include <bits/stl_numeric.h>\n-#include <ext/algorithm>\n-#include <ext/numeric>\n-\n-// Names from <stl_algo.h>\n-using std::for_each;\n-using std::find;\n-using std::find_if;\n-using std::adjacent_find;\n-using std::count;\n-using std::count_if;\n-using std::search;\n-using std::search_n;\n-using std::swap_ranges;\n-using std::transform;\n-using std::replace;\n-using std::replace_if;\n-using std::replace_copy;\n-using std::replace_copy_if;\n-using std::generate;\n-using std::generate_n;\n-using std::remove;\n-using std::remove_if;\n-using std::remove_copy;\n-using std::remove_copy_if;\n-using std::unique;\n-using std::unique_copy;\n-using std::reverse;\n-using std::reverse_copy;\n-using std::rotate;\n-using std::rotate_copy;\n-using std::random_shuffle;\n-using std::partition;\n-using std::stable_partition;\n-using std::sort;\n-using std::stable_sort;\n-using std::partial_sort;\n-using std::partial_sort_copy;\n-using std::nth_element;\n-using std::lower_bound;\n-using std::upper_bound;\n-using std::equal_range;\n-using std::binary_search;\n-using std::merge;\n-using std::inplace_merge;\n-using std::includes;\n-using std::set_union;\n-using std::set_intersection;\n-using std::set_difference;\n-using std::set_symmetric_difference;\n-using std::min_element;\n-using std::max_element;\n-using std::next_permutation;\n-using std::prev_permutation;\n-using std::find_first_of;\n-using std::find_end;\n-\n-// Names from stl_heap.h\n-using std::push_heap;\n-using std::pop_heap;\n-using std::make_heap;\n-using std::sort_heap;\n-\n-// Names from stl_numeric.h\n-using std::accumulate;\n-using std::inner_product;\n-using std::partial_sum;\n-using std::adjacent_difference;\n-\n-// Names from ext/algorithm\n-using __gnu_cxx::random_sample;\n-using __gnu_cxx::random_sample_n;\n-using __gnu_cxx::is_sorted;\n-using __gnu_cxx::is_heap;\n-using __gnu_cxx::count;   // Extension returning void\n-using __gnu_cxx::count_if;   // Extension returning void\n-\n-// Names from ext/numeric\n-using __gnu_cxx::power;\n-using __gnu_cxx::iota;\n-\n-#endif /* _BACKWARD_ALGO_H */"}, {"sha": "289e9886d1c2ecf513cb6a423fe123a97e6aee77", "filename": "libstdc++-v3/include/backward/algobase.h", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgobase.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,91 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _BACKWARD_ALGOBASE_H\n-#define _BACKWARD_ALGOBASE_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"pair.h\"\n-#include \"iterator.h\"\n-#include <bits/stl_algobase.h>\n-#include <bits/stl_uninitialized.h>\n-#include <ext/algorithm>\n-#include <ext/memory>\n-\n-// Names from stl_algobase.h\n-using std::iter_swap;\n-using std::swap;\n-using std::min;\n-using std::max;\n-using std::copy;\n-using std::copy_backward;\n-using std::fill;\n-using std::fill_n;\n-using std::mismatch;\n-using std::equal;\n-using std::lexicographical_compare;\n-\n-// Names from stl_uninitialized.h\n-using std::uninitialized_copy;\n-using std::uninitialized_fill;\n-using std::uninitialized_fill_n;\n-\n-// Names from ext/algorithm\n-using __gnu_cxx::copy_n;\n-using __gnu_cxx::lexicographical_compare_3way;\n-\n-// Names from ext/memory\n-using __gnu_cxx::uninitialized_copy_n;\n-\n-#endif /* _BACKWARD_ALGOBASE_H */"}, {"sha": "40a0af1f9995b4624e12462ce0c05003713e48c4", "filename": "libstdc++-v3/include/backward/alloc.h", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,52 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- * Copyright (c) 1996-1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _BACKWARD_ALLOC_H\n-#define _BACKWARD_ALLOC_H 1\n-\n-#include \"backward_warning.h\"\n-#include <bits/c++config.h>\n-#include <bits/allocator.h>\n-\n-using std::allocator;\n-\n-#endif"}, {"sha": "5954bd029535621529ecfbbc7515d9412592c7a6", "filename": "libstdc++-v3/include/backward/backward_warning.h", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fbackward_warning.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fbackward_warning.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fbackward_warning.h?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -30,10 +30,16 @@\n \n #ifdef __DEPRECATED\n #warning This file includes at least one deprecated or antiquated header. \\\n-Please consider using one of the 32 headers found in section 17.4.1.2 of the \\\n-C++ standard. Examples include substituting the <X> header for the <X.h> \\\n-header for C++ includes, or <iostream> instead of the deprecated header \\\n-<iostream.h>. To disable this warning use -Wno-deprecated.\n+  Please consider the use of alternate interfaces as follows: \\\n+  <sstream> \t\tbasic_stringbuf\t   \t<strstream>\tstrstreambuf \\\n+  <sstream> \t\tbasic_istringstream\t<strstream>\tistrstream \\\n+  <sstream> \t\tbasic_ostringstream\t<strstream> \tostrstream \\\n+  <sstream> \t\tbasic_stringstream\t<strstream> \tstrstream \\\n+  <unordered_set> \tunordered_set\t\t<ext/hash_set> \thash_set \\\n+  <unordered_set> \tunordered_multiset\t<ext/hash_set> \thash_multiset \\\n+  <unordered_map> \tunordered_map\t\t<ext/hash_set> \thash_map \\\n+  <unordered_map> \tunordered_multimap\t<ext/hash_set> \thash_multimap \\\n+  To disable this warning use -Wno-deprecated.\n #endif\n \n #endif"}, {"sha": "9a2c44da144174b18b8eee8005ca5d5d4d4337fc", "filename": "libstdc++-v3/include/backward/bvector.h", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fbvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fbvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fbvector.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,64 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001, 2004 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _BACKWARD_BVECTOR_H\n-#define _BACKWARD_BVECTOR_H 1\n-\n-#include \"backward_warning.h\"\n-#include <vector>\n-\n-typedef std::vector<bool, std::allocator<bool> > bit_vector;\n-\n-#endif /* _BACKWARD_BVECTOR_H */"}, {"sha": "7972cf7303f2c5ccca788ed6be296d5b273cd5e5", "filename": "libstdc++-v3/include/backward/complex.h", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fcomplex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fcomplex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fcomplex.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,39 +0,0 @@\n-// Copyright (C) 2000 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _BACKWARD_COMPLEX_H\n-#define _BACKWARD_COMPLEX_H 1\n-\n-#include \"backward_warning.h\"\n-#include <complex>\n-\n-using std::complex;\n-typedef complex<float>\t\tfloat_complex;\n-typedef complex<double>\t\tdouble_complex;\n-typedef complex<long double>\tlong_double_complex;\n-\n-#endif"}, {"sha": "ffa9b16828b4771ab816f426805f8ff383f936af", "filename": "libstdc++-v3/include/backward/defalloc.h", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fdefalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fdefalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fdefalloc.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,117 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- */\n-\n-// Inclusion of this file is DEPRECATED.  This is the original HP\n-// default allocator.  It is provided only for backward compatibility.\n-// This file WILL BE REMOVED in a future release.\n-//\n-// DO NOT USE THIS FILE unless you have an old container implementation\n-// that requires an allocator with the HP-style interface.\n-//\n-// Standard-conforming allocators have a very different interface.  The\n-// standard default allocator is declared in the header <memory>.\n-\n-#ifndef _BACKWARD_DEFALLOC_H\n-#define _BACKWARD_DEFALLOC_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"new.h\"\n-#include <stddef.h>\n-#include <stdlib.h>\n-#include <limits.h>\n-#include \"iostream.h\"\n-#include \"algobase.h\"\n-\n-\n-template <class _Tp>\n-inline _Tp* allocate(ptrdiff_t __size, _Tp*) {\n-    set_new_handler(0);\n-    _Tp* __tmp = (_Tp*)(::operator new((size_t)(__size * sizeof(_Tp))));\n-    if (__tmp == 0) {\n-\tcerr << \"out of memory\" << endl;\n-\texit(1);\n-    }\n-    return __tmp;\n-}\n-\n-\n-template <class _Tp>\n-inline void deallocate(_Tp* __buffer) {\n-    ::operator delete(__buffer);\n-}\n-\n-template <class _Tp>\n-class allocator {\n-public:\n-    typedef _Tp value_type;\n-    typedef _Tp* pointer;\n-    typedef const _Tp* const_pointer;\n-    typedef _Tp& reference;\n-    typedef const _Tp& const_reference;\n-    typedef size_t size_type;\n-    typedef ptrdiff_t difference_type;\n-    pointer allocate(size_type __n) {\n-\treturn ::allocate((difference_type)__n, (pointer)0);\n-    }\n-    void deallocate(pointer __p) { ::deallocate(__p); }\n-    pointer address(reference __x) { return (pointer)&__x; }\n-    const_pointer const_address(const_reference __x) {\n-\treturn (const_pointer)&__x;\n-    }\n-    size_type init_page_size() {\n-\treturn max(size_type(1), size_type(4096/sizeof(_Tp)));\n-    }\n-    size_type max_size() const {\n-\treturn max(size_type(1), size_type(UINT_MAX/sizeof(_Tp)));\n-    }\n-};\n-\n-class allocator<void> {\n-public:\n-    typedef void* pointer;\n-};\n-\n-\n-\n-#endif /* _BACKWARD_DEFALLOC_H */"}, {"sha": "a4a6b41811766f9c648151841b7bad91a17edcec", "filename": "libstdc++-v3/include/backward/deque.h", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fdeque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fdeque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fdeque.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,66 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _BACKWARD_DEQUE_H\n-#define _BACKWARD_DEQUE_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"algobase.h\"\n-#include \"alloc.h\"\n-#include <deque>\n-\n-using std::deque;\n-\n-#endif /* _BACKWARD_DEQUE_H */"}, {"sha": "92835f9b84485dd91a2195deb2b82b5b26a1393a", "filename": "libstdc++-v3/include/backward/fstream.h", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ffstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ffstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ffstream.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,48 +0,0 @@\n-// Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _BACKWARD_FSTREAM_H\n-#define _BACKWARD_FSTREAM_H 1\n-\n-#include \"backward_warning.h\"\n-#include <fstream>\n-\n-using std::filebuf;\n-using std::ifstream;\n-using std::ofstream;\n-using std::fstream;\n-using std::streampos;\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-using std::wfilebuf;\n-using std::wifstream;\n-using std::wofstream;\n-using std::wfstream;\n-using std::wstreampos;\n-#endif\n-\n-#endif"}, {"sha": "b5be371d8cd97f0c1fd7c468e7e52d43bf3730d0", "filename": "libstdc++-v3/include/backward/function.h", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ffunction.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,126 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _BACKWARD_FUNCTION_H\n-#define _BACKWARD_FUNCTION_H 1\n-\n-#include \"backward_warning.h\"\n-#include <bits/c++config.h>\n-#include <stddef.h>\n-#include <bits/stl_function.h>\n-#include <ext/functional>\n-\n-// Names from stl_function.h\n-using std::unary_function;\n-using std::binary_function;\n-using std::plus;\n-using std::minus;\n-using std::multiplies;\n-using std::divides;\n-using std::modulus;\n-using std::negate;\n-using std::equal_to;\n-using std::not_equal_to;\n-using std::greater;\n-using std::less;\n-using std::greater_equal;\n-using std::less_equal;\n-using std::logical_and;\n-using std::logical_or;\n-using std::logical_not;\n-using std::unary_negate;\n-using std::binary_negate;\n-using std::not1;\n-using std::not2;\n-using std::binder1st;\n-using std::binder2nd;\n-using std::bind1st;\n-using std::bind2nd;\n-using std::pointer_to_unary_function;\n-using std::pointer_to_binary_function;\n-using std::ptr_fun;\n-using std::mem_fun_t;\n-using std::const_mem_fun_t;\n-using std::mem_fun_ref_t;\n-using std::const_mem_fun_ref_t;\n-using std::mem_fun1_t;\n-using std::const_mem_fun1_t;\n-using std::mem_fun1_ref_t;\n-using std::const_mem_fun1_ref_t;\n-using std::mem_fun;\n-using std::mem_fun_ref;\n-\n-// Names from ext/functional\n-using __gnu_cxx::identity_element;\n-using __gnu_cxx::unary_compose;\n-using __gnu_cxx::binary_compose;\n-using __gnu_cxx::compose1;\n-using __gnu_cxx::compose2;\n-using __gnu_cxx::identity;\n-using __gnu_cxx::select1st;\n-using __gnu_cxx::select2nd;\n-using __gnu_cxx::project1st;\n-using __gnu_cxx::project2nd;\n-using __gnu_cxx::constant_void_fun;\n-using __gnu_cxx::constant_unary_fun;\n-using __gnu_cxx::constant_binary_fun;\n-using __gnu_cxx::constant0;\n-using __gnu_cxx::constant1;\n-using __gnu_cxx::constant2;\n-using __gnu_cxx::subtractive_rng;\n-using __gnu_cxx::mem_fun1;\n-using __gnu_cxx::mem_fun1_ref;\n-\n-#endif /* _BACKWARD_FUNCTION_H */"}, {"sha": "e6771d77e28a2258dc5276357ed250fc322ff38f", "filename": "libstdc++-v3/include/backward/hash_fun.h", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_fun.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_fun.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_fun.h?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -53,7 +53,7 @@\n  *\n  */\n \n-/** @file ext/hash_fun.h\n+/** @file backward/hash_fun.h\n  *  This file is a GNU extension to the Standard C++ Library (possibly\n  *  containing extensions from the HP/SGI STL subset).\n  */", "previous_filename": "libstdc++-v3/include/ext/hash_fun.h"}, {"sha": "6b10cda6e3f2849ceb4ae7309026e441734caa46", "filename": "libstdc++-v3/include/backward/hash_map", "status": "renamed", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_map?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -53,19 +53,20 @@\n  *\n  */\n \n-/** @file ext/hash_map\n+/** @file backward/hash_map\n  *  This file is a GNU extension to the Standard C++ Library (possibly\n  *  containing extensions from the HP/SGI STL subset).\n  */\n \n #ifndef _HASH_MAP\n #define _HASH_MAP 1\n \n+#include \"backward_warning.h\"\n #include <bits/c++config.h>\n-#include <ext/hashtable.h>\n+#include <backward/hashtable.h>\n #include <bits/concept_check.h>\n \n-_GLIBCXX_BEGIN_NESTED_NAMESPACE(__gnu_cxx, _GLIBCXX_EXT_D)\n+_GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n   using std::equal_to;\n   using std::allocator;\n@@ -497,11 +498,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(__gnu_cxx, _GLIBCXX_EXT_D)\n \t hash_multimap<_Key, _Tp, _HashFn, _EqlKey, _Alloc>& __hm2)\n     { __hm1.swap(__hm2); }\n \n-_GLIBCXX_END_NESTED_NAMESPACE\n-\n-#ifdef _GLIBCXX_DEBUG\n-# include <debug/hash_map>\n-#endif\n+_GLIBCXX_END_NAMESPACE\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n ", "previous_filename": "libstdc++-v3/include/ext/hash_map"}, {"sha": "aa1452200a3e60fee8545ef9b723cfd8c9e5282c", "filename": "libstdc++-v3/include/backward/hash_map.h", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_map.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,68 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- * Copyright (c) 1996\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- */\n-\n-#ifndef _BACKWARD_HASH_MAP_H\n-#define _BACKWARD_HASH_MAP_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"algobase.h\"\n-#include <ext/hash_map>\n-\n-using __gnu_cxx::hash;\n-using __gnu_cxx::hashtable;\n-using __gnu_cxx::hash_map;\n-using __gnu_cxx::hash_multimap;\n-\n-#endif /* _BACKWARD_HASH_MAP_H */"}, {"sha": "59c88c9e30a04cdca9d00e2928ab673ba0828843", "filename": "libstdc++-v3/include/backward/hash_set", "status": "renamed", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_set?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -53,19 +53,20 @@\n  *\n  */\n \n-/** @file ext/hash_set\n+/** @file backward/hash_set\n  *  This file is a GNU extension to the Standard C++ Library (possibly\n  *  containing extensions from the HP/SGI STL subset).\n  */\n \n #ifndef _HASH_SET\n #define _HASH_SET 1\n \n+#include \"backward_warning.h\"\n #include <bits/c++config.h>\n-#include <ext/hashtable.h>\n+#include <backward/hashtable.h>\n #include <bits/concept_check.h>\n \n-_GLIBCXX_BEGIN_NESTED_NAMESPACE(__gnu_cxx, _GLIBCXX_EXT_D)\n+_GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n   using std::equal_to;\n   using std::allocator;\n@@ -465,11 +466,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(__gnu_cxx, _GLIBCXX_EXT_D)\n \t hash_multiset<_Val, _HashFcn, _EqualKey, _Alloc>& __hs2)\n     { __hs1.swap(__hs2); }\n \n-_GLIBCXX_END_NESTED_NAMESPACE\n-\n-#ifdef _GLIBCXX_DEBUG\n-# include <debug/hash_set>\n-#endif\n+_GLIBCXX_END_NAMESPACE\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n ", "previous_filename": "libstdc++-v3/include/ext/hash_set"}, {"sha": "c2c6e393e42b2b7b4cf2b57e3aafd51ccbd1fd21", "filename": "libstdc++-v3/include/backward/hash_set.h", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_set.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,69 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- * Copyright (c) 1996\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- */\n-\n-#ifndef _BACKWARD_HASH_SET_H\n-#define _BACKWARD_HASH_SET_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"algobase.h\"\n-#include <ext/hash_set>\n-\n-using __gnu_cxx::hash;\n-using __gnu_cxx::hashtable;\n-using __gnu_cxx::hash_set;\n-using __gnu_cxx::hash_multiset;\n-\n-#endif /* _BACKWARD_HASH_SET_H */\n-"}, {"sha": "7efb8ea5b128f42e82e69a90aa32fcb3deb8df10", "filename": "libstdc++-v3/include/backward/hashtable.h", "status": "modified", "additions": 1072, "deletions": 14, "changes": 1086, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhashtable.h?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -1,6 +1,7 @@\n-// Backward-compat support -*- C++ -*-\n+// Hashtable implementation used by containers -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -53,20 +54,1077 @@\n  *\n  */\n \n-/* NOTE: This is an internal header file, included by other STL headers.\n- *   You should not attempt to use it directly.\n+/** @file backward/hashtable.h\n+ *  This file is a GNU extension to the Standard C++ Library (possibly\n+ *  containing extensions from the HP/SGI STL subset).\n  */\n \n-#ifndef _BACKWARD_HASHTABLE_H\n-#define _BACKWARD_HASHTABLE_H 1\n+#ifndef _HASHTABLE_H\n+#define _HASHTABLE_H 1\n \n-#include \"backward_warning.h\"\n-#include <ext/hashtable.h>\n-#include \"algo.h\"\n-#include \"alloc.h\"\n-#include \"vector.h\"\n+// Hashtable class, used to implement the hashed associative containers\n+// hash_set, hash_map, hash_multiset, and hash_multimap.\n \n-using __gnu_cxx::hash;\n-using __gnu_cxx::hashtable;\n+#include <vector>\n+#include <iterator>\n+#include <algorithm>\n+#include <bits/stl_function.h>\n+#include <backward/hash_fun.h>\n \n-#endif /* _BACKWARD_HASHTABLE_H */\n+_GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n+\n+  using std::size_t;\n+  using std::ptrdiff_t;\n+  using std::forward_iterator_tag;\n+  using std::input_iterator_tag;\n+  using std::_Construct;\n+  using std::_Destroy;\n+  using std::distance;\n+  using std::vector;\n+  using std::pair;\n+  using std::__iterator_category;\n+\n+  template<class _Val>\n+    struct _Hashtable_node\n+    {\n+      _Hashtable_node* _M_next;\n+      _Val _M_val;\n+    };\n+\n+  template<class _Val, class _Key, class _HashFcn, class _ExtractKey, \n+\t   class _EqualKey, class _Alloc = std::allocator<_Val> >\n+    class hashtable;\n+\n+  template<class _Val, class _Key, class _HashFcn,\n+\t   class _ExtractKey, class _EqualKey, class _Alloc>\n+    struct _Hashtable_iterator;\n+\n+  template<class _Val, class _Key, class _HashFcn,\n+\t   class _ExtractKey, class _EqualKey, class _Alloc>\n+    struct _Hashtable_const_iterator;\n+\n+  template<class _Val, class _Key, class _HashFcn,\n+\t   class _ExtractKey, class _EqualKey, class _Alloc>\n+    struct _Hashtable_iterator\n+    {\n+      typedef hashtable<_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc>\n+        _Hashtable;\n+      typedef _Hashtable_iterator<_Val, _Key, _HashFcn,\n+\t\t\t\t  _ExtractKey, _EqualKey, _Alloc>\n+        iterator;\n+      typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn,\n+\t\t\t\t\t_ExtractKey, _EqualKey, _Alloc>\n+        const_iterator;\n+      typedef _Hashtable_node<_Val> _Node;\n+      typedef forward_iterator_tag iterator_category;\n+      typedef _Val value_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef size_t size_type;\n+      typedef _Val& reference;\n+      typedef _Val* pointer;\n+      \n+      _Node* _M_cur;\n+      _Hashtable* _M_ht;\n+\n+      _Hashtable_iterator(_Node* __n, _Hashtable* __tab)\n+      : _M_cur(__n), _M_ht(__tab) { }\n+\n+      _Hashtable_iterator() { }\n+\n+      reference\n+      operator*() const\n+      { return _M_cur->_M_val; }\n+\n+      pointer\n+      operator->() const\n+      { return &(operator*()); }\n+\n+      iterator&\n+      operator++();\n+\n+      iterator\n+      operator++(int);\n+\n+      bool\n+      operator==(const iterator& __it) const\n+      { return _M_cur == __it._M_cur; }\n+\n+      bool\n+      operator!=(const iterator& __it) const\n+      { return _M_cur != __it._M_cur; }\n+    };\n+\n+  template<class _Val, class _Key, class _HashFcn,\n+\t   class _ExtractKey, class _EqualKey, class _Alloc>\n+    struct _Hashtable_const_iterator\n+    {\n+      typedef hashtable<_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc>\n+        _Hashtable;\n+      typedef _Hashtable_iterator<_Val,_Key,_HashFcn,\n+\t\t\t\t  _ExtractKey,_EqualKey,_Alloc>\n+        iterator;\n+      typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn,\n+\t\t\t\t\t_ExtractKey, _EqualKey, _Alloc>\n+        const_iterator;\n+      typedef _Hashtable_node<_Val> _Node;\n+\n+      typedef forward_iterator_tag iterator_category;\n+      typedef _Val value_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef size_t size_type;\n+      typedef const _Val& reference;\n+      typedef const _Val* pointer;\n+      \n+      const _Node* _M_cur;\n+      const _Hashtable* _M_ht;\n+\n+      _Hashtable_const_iterator(const _Node* __n, const _Hashtable* __tab)\n+      : _M_cur(__n), _M_ht(__tab) { }\n+\n+      _Hashtable_const_iterator() { }\n+\n+      _Hashtable_const_iterator(const iterator& __it)\n+      : _M_cur(__it._M_cur), _M_ht(__it._M_ht) { }\n+\n+      reference\n+      operator*() const\n+      { return _M_cur->_M_val; }\n+\n+      pointer\n+      operator->() const\n+      { return &(operator*()); }\n+\n+      const_iterator&\n+      operator++();\n+\n+      const_iterator\n+      operator++(int);\n+\n+      bool\n+      operator==(const const_iterator& __it) const\n+      { return _M_cur == __it._M_cur; }\n+\n+      bool\n+      operator!=(const const_iterator& __it) const\n+      { return _M_cur != __it._M_cur; }\n+    };\n+\n+  // Note: assumes long is at least 32 bits.\n+  enum { _S_num_primes = 28 };\n+\n+  static const unsigned long __stl_prime_list[_S_num_primes] =\n+    {\n+      53ul,         97ul,         193ul,       389ul,       769ul,\n+      1543ul,       3079ul,       6151ul,      12289ul,     24593ul,\n+      49157ul,      98317ul,      196613ul,    393241ul,    786433ul,\n+      1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,\n+      50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul,\n+      1610612741ul, 3221225473ul, 4294967291ul\n+    };\n+\n+  inline unsigned long\n+  __stl_next_prime(unsigned long __n)\n+  {\n+    const unsigned long* __first = __stl_prime_list;\n+    const unsigned long* __last = __stl_prime_list + (int)_S_num_primes;\n+    const unsigned long* pos = std::lower_bound(__first, __last, __n);\n+    return pos == __last ? *(__last - 1) : *pos;\n+  }\n+\n+  // Forward declaration of operator==.  \n+  template<class _Val, class _Key, class _HF, class _Ex,\n+\t   class _Eq, class _All>\n+    class hashtable;\n+\n+  template<class _Val, class _Key, class _HF, class _Ex,\n+\t   class _Eq, class _All>\n+    bool\n+    operator==(const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht1,\n+\t       const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht2);\n+\n+  // Hashtables handle allocators a bit differently than other\n+  // containers do.  If we're using standard-conforming allocators, then\n+  // a hashtable unconditionally has a member variable to hold its\n+  // allocator, even if it so happens that all instances of the\n+  // allocator type are identical.  This is because, for hashtables,\n+  // this extra storage is negligible.  Additionally, a base class\n+  // wouldn't serve any other purposes; it wouldn't, for example,\n+  // simplify the exception-handling code.  \n+  template<class _Val, class _Key, class _HashFcn,\n+\t   class _ExtractKey, class _EqualKey, class _Alloc>\n+    class hashtable\n+    {\n+    public:\n+      typedef _Key key_type;\n+      typedef _Val value_type;\n+      typedef _HashFcn hasher;\n+      typedef _EqualKey key_equal;\n+\n+      typedef size_t            size_type;\n+      typedef ptrdiff_t         difference_type;\n+      typedef value_type*       pointer;\n+      typedef const value_type* const_pointer;\n+      typedef value_type&       reference;\n+      typedef const value_type& const_reference;\n+\n+      hasher\n+      hash_funct() const\n+      { return _M_hash; }\n+\n+      key_equal\n+      key_eq() const\n+      { return _M_equals; }\n+\n+    private:\n+      typedef _Hashtable_node<_Val> _Node;\n+\n+    public:\n+      typedef typename _Alloc::template rebind<value_type>::other allocator_type;\n+      allocator_type\n+      get_allocator() const\n+      { return _M_node_allocator; }\n+\n+    private:\n+      typedef typename _Alloc::template rebind<_Node>::other _Node_Alloc;\n+      typedef typename _Alloc::template rebind<_Node*>::other _Nodeptr_Alloc;\n+      typedef vector<_Node*, _Nodeptr_Alloc> _Vector_type;\n+\n+      _Node_Alloc _M_node_allocator;\n+\n+      _Node*\n+      _M_get_node()\n+      { return _M_node_allocator.allocate(1); }\n+\n+      void\n+      _M_put_node(_Node* __p)\n+      { _M_node_allocator.deallocate(__p, 1); }\n+\n+    private:\n+      hasher                _M_hash;\n+      key_equal             _M_equals;\n+      _ExtractKey           _M_get_key;\n+      _Vector_type          _M_buckets;\n+      size_type             _M_num_elements;\n+      \n+    public:\n+      typedef _Hashtable_iterator<_Val, _Key, _HashFcn, _ExtractKey,\n+\t\t\t\t  _EqualKey, _Alloc>\n+        iterator;\n+      typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn, _ExtractKey,\n+\t\t\t\t\t_EqualKey, _Alloc>\n+        const_iterator;\n+\n+      friend struct\n+      _Hashtable_iterator<_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc>;\n+\n+      friend struct\n+      _Hashtable_const_iterator<_Val, _Key, _HashFcn, _ExtractKey,\n+\t\t\t\t_EqualKey, _Alloc>;\n+\n+    public:\n+      hashtable(size_type __n, const _HashFcn& __hf,\n+\t\tconst _EqualKey& __eql, const _ExtractKey& __ext,\n+\t\tconst allocator_type& __a = allocator_type())\n+      : _M_node_allocator(__a), _M_hash(__hf), _M_equals(__eql),\n+\t_M_get_key(__ext), _M_buckets(__a), _M_num_elements(0)\n+      { _M_initialize_buckets(__n); }\n+\n+      hashtable(size_type __n, const _HashFcn& __hf,\n+\t\tconst _EqualKey& __eql,\n+\t\tconst allocator_type& __a = allocator_type())\n+      : _M_node_allocator(__a), _M_hash(__hf), _M_equals(__eql),\n+\t_M_get_key(_ExtractKey()), _M_buckets(__a), _M_num_elements(0)\n+      { _M_initialize_buckets(__n); }\n+\n+      hashtable(const hashtable& __ht)\n+      : _M_node_allocator(__ht.get_allocator()), _M_hash(__ht._M_hash),\n+      _M_equals(__ht._M_equals), _M_get_key(__ht._M_get_key),\n+      _M_buckets(__ht.get_allocator()), _M_num_elements(0)\n+      { _M_copy_from(__ht); }\n+\n+      hashtable&\n+      operator= (const hashtable& __ht)\n+      {\n+\tif (&__ht != this)\n+\t  {\n+\t    clear();\n+\t    _M_hash = __ht._M_hash;\n+\t    _M_equals = __ht._M_equals;\n+\t    _M_get_key = __ht._M_get_key;\n+\t    _M_copy_from(__ht);\n+\t  }\n+\treturn *this;\n+      }\n+\n+      ~hashtable()\n+      { clear(); }\n+\n+      size_type\n+      size() const\n+      { return _M_num_elements; }\n+\n+      size_type\n+      max_size() const\n+      { return size_type(-1); }\n+\n+      bool\n+      empty() const\n+      { return size() == 0; }\n+\n+      void\n+      swap(hashtable& __ht)\n+      {\n+\tstd::swap(_M_hash, __ht._M_hash);\n+\tstd::swap(_M_equals, __ht._M_equals);\n+\tstd::swap(_M_get_key, __ht._M_get_key);\n+\t_M_buckets.swap(__ht._M_buckets);\n+\tstd::swap(_M_num_elements, __ht._M_num_elements);\n+      }\n+\n+      iterator\n+      begin()\n+      {\n+\tfor (size_type __n = 0; __n < _M_buckets.size(); ++__n)\n+\t  if (_M_buckets[__n])\n+\t    return iterator(_M_buckets[__n], this);\n+\treturn end();\n+      }\n+\n+      iterator\n+      end()\n+      { return iterator(0, this); }\n+\n+      const_iterator\n+      begin() const\n+      {\n+\tfor (size_type __n = 0; __n < _M_buckets.size(); ++__n)\n+\t  if (_M_buckets[__n])\n+\t    return const_iterator(_M_buckets[__n], this);\n+\treturn end();\n+      }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(0, this); }\n+\n+      template<class _Vl, class _Ky, class _HF, class _Ex, class _Eq,\n+\t\tclass _Al>\n+        friend bool\n+        operator==(const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&,\n+\t\t   const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&);\n+\n+    public:\n+      size_type\n+      bucket_count() const\n+      { return _M_buckets.size(); }\n+\n+      size_type\n+      max_bucket_count() const\n+      { return __stl_prime_list[(int)_S_num_primes - 1]; }\n+\n+      size_type\n+      elems_in_bucket(size_type __bucket) const\n+      {\n+\tsize_type __result = 0;\n+\tfor (_Node* __n = _M_buckets[__bucket]; __n; __n = __n->_M_next)\n+\t  __result += 1;\n+\treturn __result;\n+      }\n+\n+      pair<iterator, bool>\n+      insert_unique(const value_type& __obj)\n+      {\n+\tresize(_M_num_elements + 1);\n+\treturn insert_unique_noresize(__obj);\n+      }\n+\n+      iterator\n+      insert_equal(const value_type& __obj)\n+      {\n+\tresize(_M_num_elements + 1);\n+\treturn insert_equal_noresize(__obj);\n+      }\n+\n+      pair<iterator, bool>\n+      insert_unique_noresize(const value_type& __obj);\n+\n+      iterator\n+      insert_equal_noresize(const value_type& __obj);\n+\n+      template<class _InputIterator>\n+        void\n+        insert_unique(_InputIterator __f, _InputIterator __l)\n+        { insert_unique(__f, __l, __iterator_category(__f)); }\n+\n+      template<class _InputIterator>\n+        void\n+        insert_equal(_InputIterator __f, _InputIterator __l)\n+        { insert_equal(__f, __l, __iterator_category(__f)); }\n+\n+      template<class _InputIterator>\n+        void\n+        insert_unique(_InputIterator __f, _InputIterator __l,\n+\t\t      input_iterator_tag)\n+        {\n+\t  for ( ; __f != __l; ++__f)\n+\t    insert_unique(*__f);\n+\t}\n+\n+      template<class _InputIterator>\n+        void\n+        insert_equal(_InputIterator __f, _InputIterator __l,\n+\t\t     input_iterator_tag)\n+        {\n+\t  for ( ; __f != __l; ++__f)\n+\t    insert_equal(*__f);\n+\t}\n+\n+      template<class _ForwardIterator>\n+        void\n+        insert_unique(_ForwardIterator __f, _ForwardIterator __l,\n+\t\t      forward_iterator_tag)\n+        {\n+\t  size_type __n = distance(__f, __l);\n+\t  resize(_M_num_elements + __n);\n+\t  for ( ; __n > 0; --__n, ++__f)\n+\t    insert_unique_noresize(*__f);\n+\t}\n+\n+      template<class _ForwardIterator>\n+        void\n+        insert_equal(_ForwardIterator __f, _ForwardIterator __l,\n+\t\t     forward_iterator_tag)\n+        {\n+\t  size_type __n = distance(__f, __l);\n+\t  resize(_M_num_elements + __n);\n+\t  for ( ; __n > 0; --__n, ++__f)\n+\t    insert_equal_noresize(*__f);\n+\t}\n+\n+      reference\n+      find_or_insert(const value_type& __obj);\n+\n+      iterator\n+      find(const key_type& __key)\n+      {\n+\tsize_type __n = _M_bkt_num_key(__key);\n+\t_Node* __first;\n+\tfor (__first = _M_buckets[__n];\n+\t     __first && !_M_equals(_M_get_key(__first->_M_val), __key);\n+\t     __first = __first->_M_next)\n+\t  { }\n+\treturn iterator(__first, this);\n+      }\n+\n+      const_iterator\n+      find(const key_type& __key) const\n+      {\n+\tsize_type __n = _M_bkt_num_key(__key);\n+\tconst _Node* __first;\n+\tfor (__first = _M_buckets[__n];\n+\t     __first && !_M_equals(_M_get_key(__first->_M_val), __key);\n+\t     __first = __first->_M_next)\n+\t  { }\n+\treturn const_iterator(__first, this);\n+      }\n+\n+      size_type\n+      count(const key_type& __key) const\n+      {\n+\tconst size_type __n = _M_bkt_num_key(__key);\n+\tsize_type __result = 0;\n+\t\n+\tfor (const _Node* __cur = _M_buckets[__n]; __cur;\n+\t     __cur = __cur->_M_next)\n+\t  if (_M_equals(_M_get_key(__cur->_M_val), __key))\n+\t    ++__result;\n+\treturn __result;\n+      }\n+\n+      pair<iterator, iterator>\n+      equal_range(const key_type& __key);\n+\n+      pair<const_iterator, const_iterator>\n+      equal_range(const key_type& __key) const;\n+\n+      size_type\n+      erase(const key_type& __key);\n+      \n+      void\n+      erase(const iterator& __it);\n+\n+      void\n+      erase(iterator __first, iterator __last);\n+\n+      void\n+      erase(const const_iterator& __it);\n+\n+      void\n+      erase(const_iterator __first, const_iterator __last);\n+\n+      void\n+      resize(size_type __num_elements_hint);\n+\n+      void\n+      clear();\n+\n+    private:\n+      size_type\n+      _M_next_size(size_type __n) const\n+      { return __stl_next_prime(__n); }\n+\n+      void\n+      _M_initialize_buckets(size_type __n)\n+      {\n+\tconst size_type __n_buckets = _M_next_size(__n);\n+\t_M_buckets.reserve(__n_buckets);\n+\t_M_buckets.insert(_M_buckets.end(), __n_buckets, (_Node*) 0);\n+\t_M_num_elements = 0;\n+      }\n+\n+      size_type\n+      _M_bkt_num_key(const key_type& __key) const\n+      { return _M_bkt_num_key(__key, _M_buckets.size()); }\n+\n+      size_type\n+      _M_bkt_num(const value_type& __obj) const\n+      { return _M_bkt_num_key(_M_get_key(__obj)); }\n+\n+      size_type\n+      _M_bkt_num_key(const key_type& __key, size_t __n) const\n+      { return _M_hash(__key) % __n; }\n+\n+      size_type\n+      _M_bkt_num(const value_type& __obj, size_t __n) const\n+      { return _M_bkt_num_key(_M_get_key(__obj), __n); }\n+\n+      _Node*\n+      _M_new_node(const value_type& __obj)\n+      {\n+\t_Node* __n = _M_get_node();\n+\t__n->_M_next = 0;\n+\ttry\n+\t  {\n+\t    this->get_allocator().construct(&__n->_M_val, __obj);\n+\t    return __n;\n+\t  }\n+\tcatch(...)\n+\t  {\n+\t    _M_put_node(__n);\n+\t    __throw_exception_again;\n+\t  }\n+      }\n+\n+      void\n+      _M_delete_node(_Node* __n)\n+      {\n+\tthis->get_allocator().destroy(&__n->_M_val);\n+\t_M_put_node(__n);\n+      }\n+      \n+      void\n+      _M_erase_bucket(const size_type __n, _Node* __first, _Node* __last);\n+\n+      void\n+      _M_erase_bucket(const size_type __n, _Node* __last);\n+\n+      void\n+      _M_copy_from(const hashtable& __ht);\n+    };\n+\n+  template<class _Val, class _Key, class _HF, class _ExK, class _EqK,\n+\t    class _All>\n+    _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>&\n+    _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n+    operator++()\n+    {\n+      const _Node* __old = _M_cur;\n+      _M_cur = _M_cur->_M_next;\n+      if (!_M_cur)\n+\t{\n+\t  size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);\n+\t  while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())\n+\t    _M_cur = _M_ht->_M_buckets[__bucket];\n+\t}\n+      return *this;\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _ExK, class _EqK,\n+\t    class _All>\n+    inline _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>\n+    _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n+    operator++(int)\n+    {\n+      iterator __tmp = *this;\n+      ++*this;\n+      return __tmp;\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _ExK, class _EqK,\n+\t    class _All>\n+    _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>&\n+    _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n+    operator++()\n+    {\n+      const _Node* __old = _M_cur;\n+      _M_cur = _M_cur->_M_next;\n+      if (!_M_cur)\n+\t{\n+\t  size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);\n+\t  while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())\n+\t    _M_cur = _M_ht->_M_buckets[__bucket];\n+\t}\n+      return *this;\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _ExK, class _EqK,\n+\t    class _All>\n+    inline _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>\n+    _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n+    operator++(int)\n+    {\n+      const_iterator __tmp = *this;\n+      ++*this;\n+      return __tmp;\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    bool\n+    operator==(const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht1,\n+\t       const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht2)\n+    {\n+      typedef typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::_Node _Node;\n+\n+      if (__ht1._M_buckets.size() != __ht2._M_buckets.size())\n+\treturn false;\n+\n+      for (size_t __n = 0; __n < __ht1._M_buckets.size(); ++__n)\n+\t{\n+\t  _Node* __cur1 = __ht1._M_buckets[__n];\n+\t  _Node* __cur2 = __ht2._M_buckets[__n];\n+\t  // Check same length of lists\n+\t  for (; __cur1 && __cur2;\n+\t       __cur1 = __cur1->_M_next, __cur2 = __cur2->_M_next)\n+\t    { } \n+\t  if (__cur1 || __cur2)\n+\t    return false;\n+\t  // Now check one's elements are in the other\n+\t  for (__cur1 = __ht1._M_buckets[__n] ; __cur1;\n+\t       __cur1 = __cur1->_M_next)\n+\t    {\n+\t      bool _found__cur1 = false;\n+\t      for (__cur2 = __ht2._M_buckets[__n];\n+\t\t   __cur2; __cur2 = __cur2->_M_next)\n+\t\t{\n+\t\t  if (__cur1->_M_val == __cur2->_M_val)\n+\t\t    {\n+\t\t      _found__cur1 = true;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      if (!_found__cur1)\n+\t\treturn false;\n+\t    }\n+\t}\n+      return true;\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    inline bool\n+    operator!=(const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht1,\n+\t       const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht2)\n+    { return !(__ht1 == __ht2); }\n+\n+  template<class _Val, class _Key, class _HF, class _Extract, class _EqKey,\n+\t    class _All>\n+    inline void\n+    swap(hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht1,\n+\t hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht2)\n+    { __ht1.swap(__ht2); }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    pair<typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator, bool>\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    insert_unique_noresize(const value_type& __obj)\n+    {\n+      const size_type __n = _M_bkt_num(__obj);\n+      _Node* __first = _M_buckets[__n];\n+      \n+      for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n+\tif (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n+\t  return pair<iterator, bool>(iterator(__cur, this), false);\n+      \n+      _Node* __tmp = _M_new_node(__obj);\n+      __tmp->_M_next = __first;\n+      _M_buckets[__n] = __tmp;\n+      ++_M_num_elements;\n+      return pair<iterator, bool>(iterator(__tmp, this), true);\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    insert_equal_noresize(const value_type& __obj)\n+    {\n+      const size_type __n = _M_bkt_num(__obj);\n+      _Node* __first = _M_buckets[__n];\n+      \n+      for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n+\tif (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n+\t  {\n+\t    _Node* __tmp = _M_new_node(__obj);\n+\t    __tmp->_M_next = __cur->_M_next;\n+\t    __cur->_M_next = __tmp;\n+\t    ++_M_num_elements;\n+\t    return iterator(__tmp, this);\n+\t  }\n+\n+      _Node* __tmp = _M_new_node(__obj);\n+      __tmp->_M_next = __first;\n+      _M_buckets[__n] = __tmp;\n+      ++_M_num_elements;\n+      return iterator(__tmp, this);\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::reference\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    find_or_insert(const value_type& __obj)\n+    {\n+      resize(_M_num_elements + 1);\n+\n+      size_type __n = _M_bkt_num(__obj);\n+      _Node* __first = _M_buckets[__n];\n+      \n+      for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n+\tif (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n+\t  return __cur->_M_val;\n+      \n+      _Node* __tmp = _M_new_node(__obj);\n+      __tmp->_M_next = __first;\n+      _M_buckets[__n] = __tmp;\n+      ++_M_num_elements;\n+      return __tmp->_M_val;\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    pair<typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator,\n+\t typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator>\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    equal_range(const key_type& __key)\n+    {\n+      typedef pair<iterator, iterator> _Pii;\n+      const size_type __n = _M_bkt_num_key(__key);\n+\n+      for (_Node* __first = _M_buckets[__n]; __first;\n+\t   __first = __first->_M_next)\n+\tif (_M_equals(_M_get_key(__first->_M_val), __key))\n+\t  {\n+\t    for (_Node* __cur = __first->_M_next; __cur;\n+\t\t __cur = __cur->_M_next)\n+\t      if (!_M_equals(_M_get_key(__cur->_M_val), __key))\n+\t\treturn _Pii(iterator(__first, this), iterator(__cur, this));\n+\t    for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)\n+\t      if (_M_buckets[__m])\n+\t\treturn _Pii(iterator(__first, this),\n+\t\t\t    iterator(_M_buckets[__m], this));\n+\t    return _Pii(iterator(__first, this), end());\n+\t  }\n+      return _Pii(end(), end());\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    pair<typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::const_iterator,\n+\t typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::const_iterator>\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    equal_range(const key_type& __key) const\n+    {\n+      typedef pair<const_iterator, const_iterator> _Pii;\n+      const size_type __n = _M_bkt_num_key(__key);\n+\n+      for (const _Node* __first = _M_buckets[__n]; __first;\n+\t   __first = __first->_M_next)\n+\t{\n+\t  if (_M_equals(_M_get_key(__first->_M_val), __key))\n+\t    {\n+\t      for (const _Node* __cur = __first->_M_next; __cur;\n+\t\t   __cur = __cur->_M_next)\n+\t\tif (!_M_equals(_M_get_key(__cur->_M_val), __key))\n+\t\t  return _Pii(const_iterator(__first, this),\n+\t\t\t      const_iterator(__cur, this));\n+\t      for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)\n+\t\tif (_M_buckets[__m])\n+\t\t  return _Pii(const_iterator(__first, this),\n+\t\t\t      const_iterator(_M_buckets[__m], this));\n+\t      return _Pii(const_iterator(__first, this), end());\n+\t    }\n+\t}\n+      return _Pii(end(), end());\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::size_type\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    erase(const key_type& __key)\n+    {\n+      const size_type __n = _M_bkt_num_key(__key);\n+      _Node* __first = _M_buckets[__n];\n+      size_type __erased = 0;\n+      \n+      if (__first)\n+\t{\n+\t  _Node* __cur = __first;\n+\t  _Node* __next = __cur->_M_next;\n+\t  while (__next)\n+\t    {\n+\t      if (_M_equals(_M_get_key(__next->_M_val), __key))\n+\t\t{\n+\t\t  __cur->_M_next = __next->_M_next;\n+\t\t  _M_delete_node(__next);\n+\t\t  __next = __cur->_M_next;\n+\t\t  ++__erased;\n+\t\t  --_M_num_elements;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  __cur = __next;\n+\t\t  __next = __cur->_M_next;\n+\t\t}\n+\t    }\n+\t  if (_M_equals(_M_get_key(__first->_M_val), __key))\n+\t    {\n+\t      _M_buckets[__n] = __first->_M_next;\n+\t      _M_delete_node(__first);\n+\t      ++__erased;\n+\t      --_M_num_elements;\n+\t    }\n+\t}\n+      return __erased;\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    erase(const iterator& __it)\n+    {\n+      _Node* __p = __it._M_cur;\n+      if (__p)\n+\t{\n+\t  const size_type __n = _M_bkt_num(__p->_M_val);\n+\t  _Node* __cur = _M_buckets[__n];\n+\t  \n+\t  if (__cur == __p)\n+\t    {\n+\t      _M_buckets[__n] = __cur->_M_next;\n+\t      _M_delete_node(__cur);\n+\t      --_M_num_elements;\n+\t    }\n+\t  else\n+\t    {\n+\t      _Node* __next = __cur->_M_next;\n+\t      while (__next)\n+\t\t{\n+\t\t  if (__next == __p)\n+\t\t    {\n+\t\t      __cur->_M_next = __next->_M_next;\n+\t\t      _M_delete_node(__next);\n+\t\t      --_M_num_elements;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      __cur = __next;\n+\t\t      __next = __cur->_M_next;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    erase(iterator __first, iterator __last)\n+    {\n+      size_type __f_bucket = __first._M_cur ? _M_bkt_num(__first._M_cur->_M_val)\n+\t                                    : _M_buckets.size();\n+\n+      size_type __l_bucket = __last._M_cur ? _M_bkt_num(__last._M_cur->_M_val)\n+\t                                   : _M_buckets.size();\n+\n+      if (__first._M_cur == __last._M_cur)\n+\treturn;\n+      else if (__f_bucket == __l_bucket)\n+\t_M_erase_bucket(__f_bucket, __first._M_cur, __last._M_cur);\n+      else\n+\t{\n+\t  _M_erase_bucket(__f_bucket, __first._M_cur, 0);\n+\t  for (size_type __n = __f_bucket + 1; __n < __l_bucket; ++__n)\n+\t    _M_erase_bucket(__n, 0);\n+\t  if (__l_bucket != _M_buckets.size())\n+\t    _M_erase_bucket(__l_bucket, __last._M_cur);\n+\t}\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    inline void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    erase(const_iterator __first, const_iterator __last)\n+    {\n+      erase(iterator(const_cast<_Node*>(__first._M_cur),\n+\t\t     const_cast<hashtable*>(__first._M_ht)),\n+\t    iterator(const_cast<_Node*>(__last._M_cur),\n+\t\t     const_cast<hashtable*>(__last._M_ht)));\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    inline void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    erase(const const_iterator& __it)\n+    { erase(iterator(const_cast<_Node*>(__it._M_cur),\n+\t\t     const_cast<hashtable*>(__it._M_ht))); }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    resize(size_type __num_elements_hint)\n+    {\n+      const size_type __old_n = _M_buckets.size();\n+      if (__num_elements_hint > __old_n)\n+\t{\n+\t  const size_type __n = _M_next_size(__num_elements_hint);\n+\t  if (__n > __old_n)\n+\t    {\n+\t      _Vector_type __tmp(__n, (_Node*)(0), _M_buckets.get_allocator());\n+\t      try\n+\t\t{\n+\t\t  for (size_type __bucket = 0; __bucket < __old_n; ++__bucket)\n+\t\t    {\n+\t\t      _Node* __first = _M_buckets[__bucket];\n+\t\t      while (__first)\n+\t\t\t{\n+\t\t\t  size_type __new_bucket = _M_bkt_num(__first->_M_val,\n+\t\t\t\t\t\t\t      __n);\n+\t\t\t  _M_buckets[__bucket] = __first->_M_next;\n+\t\t\t  __first->_M_next = __tmp[__new_bucket];\n+\t\t\t  __tmp[__new_bucket] = __first;\n+\t\t\t  __first = _M_buckets[__bucket];\n+\t\t\t}\n+\t\t    }\n+\t\t  _M_buckets.swap(__tmp);\n+\t\t}\n+\t      catch(...)\n+\t\t{\n+\t\t  for (size_type __bucket = 0; __bucket < __tmp.size();\n+\t\t       ++__bucket)\n+\t\t    {\n+\t\t      while (__tmp[__bucket])\n+\t\t\t{\n+\t\t\t  _Node* __next = __tmp[__bucket]->_M_next;\n+\t\t\t  _M_delete_node(__tmp[__bucket]);\n+\t\t\t  __tmp[__bucket] = __next;\n+\t\t\t}\n+\t\t    }\n+\t\t  __throw_exception_again;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    _M_erase_bucket(const size_type __n, _Node* __first, _Node* __last)\n+    {\n+      _Node* __cur = _M_buckets[__n];\n+      if (__cur == __first)\n+\t_M_erase_bucket(__n, __last);\n+      else\n+\t{\n+\t  _Node* __next;\n+\t  for (__next = __cur->_M_next;\n+\t       __next != __first;\n+\t       __cur = __next, __next = __cur->_M_next)\n+\t    ;\n+\t  while (__next != __last)\n+\t    {\n+\t      __cur->_M_next = __next->_M_next;\n+\t      _M_delete_node(__next);\n+\t      __next = __cur->_M_next;\n+\t      --_M_num_elements;\n+\t    }\n+\t}\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    _M_erase_bucket(const size_type __n, _Node* __last)\n+    {\n+      _Node* __cur = _M_buckets[__n];\n+      while (__cur != __last)\n+\t{\n+\t  _Node* __next = __cur->_M_next;\n+\t  _M_delete_node(__cur);\n+\t  __cur = __next;\n+\t  _M_buckets[__n] = __cur;\n+\t  --_M_num_elements;\n+\t}\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    clear()\n+    {\n+      for (size_type __i = 0; __i < _M_buckets.size(); ++__i)\n+\t{\n+\t  _Node* __cur = _M_buckets[__i];\n+\t  while (__cur != 0)\n+\t    {\n+\t      _Node* __next = __cur->_M_next;\n+\t      _M_delete_node(__cur);\n+\t      __cur = __next;\n+\t    }\n+\t  _M_buckets[__i] = 0;\n+\t}\n+      _M_num_elements = 0;\n+    }\n+\n+  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n+    void\n+    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n+    _M_copy_from(const hashtable& __ht)\n+    {\n+      _M_buckets.clear();\n+      _M_buckets.reserve(__ht._M_buckets.size());\n+      _M_buckets.insert(_M_buckets.end(), __ht._M_buckets.size(), (_Node*) 0);\n+      try\n+\t{\n+\t  for (size_type __i = 0; __i < __ht._M_buckets.size(); ++__i) {\n+\t    const _Node* __cur = __ht._M_buckets[__i];\n+\t    if (__cur)\n+\t      {\n+\t\t_Node* __local_copy = _M_new_node(__cur->_M_val);\n+\t\t_M_buckets[__i] = __local_copy;\n+\t\t\n+\t\tfor (_Node* __next = __cur->_M_next;\n+\t\t     __next;\n+\t\t     __cur = __next, __next = __cur->_M_next)\n+\t\t  {\n+\t\t    __local_copy->_M_next = _M_new_node(__next->_M_val);\n+\t\t    __local_copy = __local_copy->_M_next;\n+\t\t  }\n+\t      }\n+\t  }\n+\t  _M_num_elements = __ht._M_num_elements;\n+\t}\n+      catch(...)\n+\t{\n+\t  clear();\n+\t  __throw_exception_again;\n+\t}\n+    }\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+#endif"}, {"sha": "ef2e68475aa16f887825a7243a159d3dad3bb508", "filename": "libstdc++-v3/include/backward/heap.h", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fheap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fheap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fheap.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,67 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- * Copyright (c) 1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _BACKWARD_HEAP_H\n-#define _BACKWARD_HEAP_H 1\n-\n-#include \"backward_warning.h\"\n-#include <bits/c++config.h>\n-#include <bits/stl_heap.h>\n-\n-using std::push_heap;\n-using std::pop_heap;\n-using std::make_heap;\n-using std::sort_heap;\n-\n-#endif /* _BACKWARD_HEAP_H */"}, {"sha": "a4099a7bec429766910c355c4a35715c52e1b96e", "filename": "libstdc++-v3/include/backward/iomanip.h", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiomanip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiomanip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiomanip.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,66 +0,0 @@\n-// Copyright (C) 2000 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _BACKWARD_IOMANIP_H\n-#define _BACKWARD_IOMANIP_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"iostream.h\"\n-#include <iomanip>\n-\n-// These are from <ios> as per [27.4].\n-using std::boolalpha;\n-using std::noboolalpha;\n-using std::showbase;\n-using std::noshowbase;\n-using std::showpoint;\n-using std::noshowpoint;\n-using std::showpos;\n-using std::noshowpos;\n-using std::skipws;\n-using std::noskipws;\n-using std::uppercase;\n-using std::nouppercase;\n-using std::internal;\n-using std::left;\n-using std::right;\n-using std::dec;\n-using std::hex;\n-using std::oct;\n-using std::fixed;\n-using std::scientific;\n-\n-// These are from <iomanip> as per [27.6].  Manipulators from <istream>\n-// and <ostream> (e.g., endl) are made available via <iostream.h>.\n-using std::resetiosflags;\n-using std::setiosflags;\n-using std::setbase;\n-using std::setfill;\n-using std::setprecision;\n-using std::setw;\n-\n-#endif"}, {"sha": "ed275ffa98dd29cac4a2ee11162ab907612225f9", "filename": "libstdc++-v3/include/backward/iostream.h", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiostream.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,56 +0,0 @@\n-// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _BACKWARD_IOSTREAM_H\n-#define _BACKWARD_IOSTREAM_H 1\n-\n-#include \"backward_warning.h\"\n-#include <iostream>\n-\n-using std::iostream;\n-using std::ostream;\n-using std::istream;\n-using std::ios;\n-using std::streambuf;\n-\n-using std::cout;\n-using std::cin;\n-using std::cerr;\n-using std::clog;\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-using std::wcout;\n-using std::wcin;\n-using std::wcerr;\n-using std::wclog;\n-#endif\n-\n-using std::ws;\n-using std::endl;\n-using std::ends;\n-using std::flush;\n-\n-#endif"}, {"sha": "b1c55d189913a3464e71e036e7ad8b38dbb36a5b", "filename": "libstdc++-v3/include/backward/istream.h", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fistream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fistream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fistream.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,34 +0,0 @@\n-// Copyright (C) 2000 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _BACKWARD_ISTREAM_H\n-#define _BACKWARD_ISTREAM_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"iostream.h\"\n-\n-#endif"}, {"sha": "89496fb8fff4ea9efb44a41e7993374db518eb35", "filename": "libstdc++-v3/include/backward/iterator.h", "status": "removed", "additions": 0, "deletions": 187, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiterator.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,187 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001, 2004 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _BACKWARD_ITERATOR_H\n-#define _BACKWARD_ITERATOR_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"function.h\"\n-#include <stddef.h>\n-#include \"iostream.h\"\n-#include <iterator>\n-\n-#include <bits/stl_construct.h>\n-#include <bits/stl_raw_storage_iter.h>\n-\n-#include <ext/iterator> // For 3-parameter distance extension\n-\n-// Names from stl_iterator.h\n-using std::input_iterator_tag;\n-using std::output_iterator_tag;\n-using std::forward_iterator_tag;\n-using std::bidirectional_iterator_tag;\n-using std::random_access_iterator_tag;\n-\n-#if 0\n-using std::iterator;\n-#endif\n-\n-// The base classes input_iterator, output_iterator, forward_iterator,\n-// bidirectional_iterator, and random_access_iterator are not part of\n-// the C++ standard.  (They have been replaced by struct iterator.)\n-// They are included for backward compatibility with the HP STL.\n-template<typename _Tp, typename _Distance>\n-  struct input_iterator {\n-    typedef input_iterator_tag iterator_category;\n-    typedef _Tp                value_type;\n-    typedef _Distance          difference_type;\n-    typedef _Tp*               pointer;\n-    typedef _Tp&               reference;\n-  };\n-\n-struct output_iterator {\n-  typedef output_iterator_tag iterator_category;\n-  typedef void                value_type;\n-  typedef void                difference_type;\n-  typedef void                pointer;\n-  typedef void                reference;\n-};\n-\n-template<typename _Tp, typename _Distance>\n-  struct forward_iterator {\n-    typedef forward_iterator_tag iterator_category;\n-    typedef _Tp                  value_type;\n-    typedef _Distance            difference_type;\n-    typedef _Tp*                 pointer;\n-    typedef _Tp&                 reference;\n-  };\n-\n-template<typename _Tp, typename _Distance>\n-  struct bidirectional_iterator {\n-    typedef bidirectional_iterator_tag iterator_category;\n-    typedef _Tp                        value_type;\n-    typedef _Distance                  difference_type;\n-    typedef _Tp*                       pointer;\n-    typedef _Tp&                       reference;\n-  };\n-\n-template<typename _Tp, typename _Distance>\n-  struct random_access_iterator {\n-    typedef random_access_iterator_tag iterator_category;\n-    typedef _Tp                        value_type;\n-    typedef _Distance                  difference_type;\n-    typedef _Tp*                       pointer;\n-    typedef _Tp&                       reference;\n-  };\n-\n-using std::iterator_traits;\n-\n-template <class _Iter>\n-  inline typename iterator_traits<_Iter>::iterator_category\n-  iterator_category(const _Iter& __i)\n-  { return __iterator_category(__i); }\n-\n-template <class _Iter>\n-  inline typename iterator_traits<_Iter>::difference_type*\n-  distance_type(const _Iter&)\n-  { return static_cast<typename iterator_traits<_Iter>::difference_type*>(0); }\n-\n-template<class _Iter>\n-  inline typename iterator_traits<_Iter>::value_type*\n-  value_type(const _Iter& __i)\n-  { return static_cast<typename iterator_traits<_Iter>::value_type*>(0); }\n-\n-using std::distance;\n-using __gnu_cxx::distance; // 3-parameter extension\n-using std::advance;\n-\n-using std::insert_iterator;\n-using std::front_insert_iterator;\n-using std::back_insert_iterator;\n-using std::inserter;\n-using std::front_inserter;\n-using std::back_inserter;\n-\n-using std::reverse_iterator;\n-\n-using std::istream_iterator;\n-using std::ostream_iterator;\n-\n-// Names from stl_construct.h\n-template<class _T1, class _T2>\n-  inline void\n-  construct(_T1* __p, const _T2& __value)\n-  { std::_Construct(__p, __value); }\n-\n-template<class _T1>\n-  inline void\n-  construct(_T1* __p)\n-  { std::_Construct(__p); }\n-\n-template <class _Tp>\n-  inline void\n-  destroy(_Tp* __pointer)\n-  { std::_Destroy(__pointer); }\n-\n-template <class _ForwardIterator>\n-  inline void\n-  destroy(_ForwardIterator __first, _ForwardIterator __last)\n-  { std::_Destroy(__first, __last); }\n-\n-\n-// Names from stl_raw_storage_iter.h\n-using std::raw_storage_iterator;\n-\n-#endif /* _BACKWARD_ITERATOR_H */"}, {"sha": "d70a6e4ae7d4f1d6f4d4e67a872be11dfdbc63ac", "filename": "libstdc++-v3/include/backward/list.h", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Flist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Flist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Flist.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,66 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _BACKWARD_LIST_H\n-#define _BACKWARD_LIST_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"algobase.h\"\n-#include \"alloc.h\"\n-#include <list>\n-\n-using std::list;\n-\n-#endif /* _BACKWARD_LIST_H */"}, {"sha": "2ff3cec667e7da822aefbdb389884844abd69be7", "filename": "libstdc++-v3/include/backward/map.h", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmap.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,65 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _BACKWARD_MAP_H\n-#define _BACKWARD_MAP_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"tree.h\"\n-#include <map>\n-\n-using std::map;\n-\n-#endif /* _BACKWARD_MAP_H */"}, {"sha": "515d2995049bb0ee90aa56a0cc3efc9d127e56ef", "filename": "libstdc++-v3/include/backward/multimap.h", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmultimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmultimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmultimap.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,65 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _BACKWARD_MULTIMAP_H\n-#define _BACKWARD_MULTIMAP_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"tree.h\"\n-#include <map>\n-\n-using std::multimap;\n-\n-#endif /* _BACKWARD_MULTIMAP_H */"}, {"sha": "1f857ae6eb067f1fb8fde914f5fd70132154fe6b", "filename": "libstdc++-v3/include/backward/multiset.h", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmultiset.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,65 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _BACKWARD_MULTISET_H\n-#define _BACKWARD_MULTISET_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"tree.h\"\n-#include <set>\n-\n-using std::multiset;\n-\n-#endif /* _BACKWARD_MULTISET_H */"}, {"sha": "9cfbab27fe6b76a37f71d9a1063f82adad8312ad", "filename": "libstdc++-v3/include/backward/new.h", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fnew.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fnew.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fnew.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,42 +0,0 @@\n-// -*- C++ -*- forwarding header.\n-// Copyright (C) 2000 Free Software Foundation\n-\n-// This file is part of GCC.\n-//\n-// GCC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-//\n-// GCC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-//\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-// Boston, MA 02110-1301, USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _BACKWARD_NEW_H\n-#define _BACKWARD_NEW_H 1\n-\n-#include \"backward_warning.h\"\n-#include <new>\n-\n-using std::bad_alloc;\n-using std::nothrow_t;\n-using std::nothrow;\n-using std::new_handler;\n-using std::set_new_handler;\n-\n-#endif"}, {"sha": "07ef9b0f2b37f8a742249e471866933815785414", "filename": "libstdc++-v3/include/backward/ostream.h", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fostream.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,34 +0,0 @@\n-// Copyright (C) 2000 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _BACKWARD_OSTREAM_H\n-#define _BACKWARD_OSTREAM_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"iostream.h\"\n-\n-#endif"}, {"sha": "4985bcbfdd2af82f8993c2c853ecbd5bbe913296", "filename": "libstdc++-v3/include/backward/pair.h", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fpair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fpair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fpair.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,66 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _BACKWARD_PAIR_H\n-#define _BACKWARD_PAIR_H 1\n-\n-#include \"backward_warning.h\"\n-#include <bits/c++config.h>\n-#include <bits/stl_pair.h>\n-\n-using std::pair;\n-using std::make_pair;\n-\n-#endif /* _BACKWARD_PAIR_H */"}, {"sha": "da7505c28d1a9c33f33527967a95a438ac10ba0d", "filename": "libstdc++-v3/include/backward/queue.h", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fqueue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fqueue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fqueue.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,37 +0,0 @@\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _BACKWARD_QUEUE_H\n-#define _BACKWARD_QUEUE_H 1\n-\n-#include \"backward_warning.h\"\n-#include <queue>\n-\n-using std::queue;\n-using std::priority_queue;\n-\n-#endif"}, {"sha": "71e8815326786395c9099922c78e8864a75d7937", "filename": "libstdc++-v3/include/backward/rope.h", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Frope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Frope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Frope.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,56 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- * Copyright (c) 1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _BACKWARD_ROPE_H\n-#define _BACKWARD_ROPE_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"hashtable.h\"\n-#include <ext/rope>\n-\n-using __gnu_cxx::char_producer;\n-using __gnu_cxx::sequence_buffer;\n-using __gnu_cxx::rope;\n-using __gnu_cxx::crope;\n-using __gnu_cxx::wrope;\n-\n-#endif /* _BACKWARD_ROPE_H */"}, {"sha": "3c6a390cf49d68f1c96a0e87ca81f8c2175e3200", "filename": "libstdc++-v3/include/backward/set.h", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fset.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,65 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _BACKWARD_SET_H\n-#define _BACKWARD_SET_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"tree.h\"\n-#include <set>\n-\n-using std::set;\n-\n-#endif /* _BACKWARD_SET_H */"}, {"sha": "9b9a43d3f0d7050d5996e1f135649fe75b53352c", "filename": "libstdc++-v3/include/backward/slist.h", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fslist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fslist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fslist.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,52 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- * Copyright (c) 1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- */\n-\n-#ifndef _BACKWARD_SLIST_H\n-#define _BACKWARD_SLIST_H 1\n-\n-#include \"backward_warning.h\"\n-#include <ext/slist>\n-\n-using __gnu_cxx::slist;\n-\n-#endif /* _BACKWARD_SLIST_H */"}, {"sha": "07df41769e00f299570d54a58d481f08299caafe", "filename": "libstdc++-v3/include/backward/stack.h", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstack.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,68 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _BACKWARD_STACK_H\n-#define _BACKWARD_STACK_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"vector.h\"\n-#include \"deque.h\"\n-#include \"heap.h\"\n-#include \"queue.h\"\n-#include <stack>\n-\n-using std::stack;\n-\n-#endif /* _BACKWARD_STACK_H */"}, {"sha": "c137601e67690518ed79e08109d271b36d6f9629", "filename": "libstdc++-v3/include/backward/stream.h", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstream.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,34 +0,0 @@\n-// Copyright (C) 2000 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _BACKWARD_STREAM_H\n-#define _BACKWARD_STREAM_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"iostream.h\"\n-\n-#endif"}, {"sha": "bac24495a0567e10c1207e4775a67164c26eabba", "filename": "libstdc++-v3/include/backward/streambuf.h", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstreambuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstreambuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstreambuf.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,36 +0,0 @@\n-// Copyright (C) 2000 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#ifndef _BACKWARD_STREAMBUF_H\n-#define _BACKWARD_STREAMBUF_H 1\n-\n-#include \"backward_warning.h\"\n-#include <streambuf>\n-\n-using std::streambuf;\n-\n-#endif"}, {"sha": "af6e57daa3b032d1a47b7b4f43596275313201eb", "filename": "libstdc++-v3/include/backward/tempbuf.h", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ftempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ftempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ftempbuf.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,74 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001, 2005 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _BACKWARD_TEMPBUF_H\n-#define _BACKWARD_TEMPBUF_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"pair.h\"\n-#include \"iterator.h\"\n-#include <limits.h>\n-#include <stddef.h>\n-#include <stdlib.h>\n-#include <bits/cpp_type_traits.h>\n-#include <bits/stl_construct.h>\n-#include <bits/stl_uninitialized.h>\n-#include <ext/memory>\n-\n-using std::get_temporary_buffer;\n-using std::return_temporary_buffer;\n-using __gnu_cxx::temporary_buffer;\n-\n-#endif /* _BACKWARD_TEMPBUF_H */"}, {"sha": "88a2f1d7c824f28911bc91d22995361318456bb6", "filename": "libstdc++-v3/include/backward/tree.h", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ftree.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,52 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- * Copyright (c) 1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- */\n-\n-#ifndef _BACKWARD_TREE\n-#define _BACKWARD_TREE 1\n-\n-#include \"backward_warning.h\"\n-#include <ext/rb_tree>\n-\n-using __gnu_cxx::rb_tree;\n-\n-#endif"}, {"sha": "8cd8dd0f360818191d46048491aa4f209956ae29", "filename": "libstdc++-v3/include/backward/vector.h", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fvector.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,66 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1996\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-#ifndef _BACKWARD_VECTOR_H\n-#define _BACKWARD_VECTOR_H 1\n-\n-#include \"backward_warning.h\"\n-#include \"algobase.h\"\n-#include \"alloc.h\"\n-#include <vector>\n-\n-using std::vector;\n-\n-#endif /* _BACKWARD_VECTOR_H */"}, {"sha": "51b8f2dde99326fce1c83965a001e2302863ed3e", "filename": "libstdc++-v3/include/bits/c++config", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -65,12 +65,6 @@\n \n     namespace tr1 { }\n   }\n-\n-  namespace __gnu_cxx\n-  {\n-    namespace __debug { }\n-    namespace __norm { }\n-  }\n */\n \n // Macros for activating various namespace association modes.\n@@ -100,9 +94,6 @@\n // _GLIBCXX_STD\n // _GLIBCXX_STD_D\n // _GLIBCXX_STD_P\n-// _GLIBCXX_EXT\n-// _GLIBCXX_EXT_D\n-// _GLIBCXX_EXT_P\n \n //\n // Macros for enclosing namepaces and possibly nested namespaces.\n@@ -116,9 +107,6 @@\n # define _GLIBCXX_STD_D _GLIBCXX_STD\n # define _GLIBCXX_STD_P _GLIBCXX_STD\n # define _GLIBCXX_STD std\n-# define _GLIBCXX_EXT_D _GLIBCXX_EXT\n-# define _GLIBCXX_EXT_P _GLIBCXX_EXT\n-# define _GLIBCXX_EXT __gnu_cxx\n # define _GLIBCXX_BEGIN_NESTED_NAMESPACE(X, Y) _GLIBCXX_BEGIN_NAMESPACE(X)\n # define _GLIBCXX_END_NESTED_NAMESPACE _GLIBCXX_END_NAMESPACE\n # define _GLIBCXX_BEGIN_NAMESPACE(X) namespace X _GLIBCXX_VISIBILITY(default) {\n@@ -129,7 +117,6 @@\n #  define _GLIBCXX_STD_D _GLIBCXX_STD\n #  define _GLIBCXX_STD_P _GLIBCXX_STD\n #  define _GLIBCXX_STD _6\n-#  define _GLIBCXX_EXT _6\n #  define _GLIBCXX_BEGIN_NAMESPACE(X) _GLIBCXX_BEGIN_NESTED_NAMESPACE(X, _6)\n #  define _GLIBCXX_END_NAMESPACE _GLIBCXX_END_NESTED_NAMESPACE\n # endif\n@@ -139,9 +126,6 @@\n #  define _GLIBCXX_STD_D __norm\n #  define _GLIBCXX_STD_P _GLIBCXX_STD\n #  define _GLIBCXX_STD __cxx1998\n-#  define _GLIBCXX_EXT_D __norm\n-#  define _GLIBCXX_EXT_P _GLIBCXX_EXT\n-#  define _GLIBCXX_EXT __cxx1998\n #  define _GLIBCXX_BEGIN_NAMESPACE(X) namespace X _GLIBCXX_VISIBILITY(default) { \n #  define _GLIBCXX_END_NAMESPACE }\n #  define _GLIBCXX_EXTERN_TEMPLATE 0\n@@ -152,9 +136,6 @@\n #  define _GLIBCXX_STD_D _GLIBCXX_STD\n #  define _GLIBCXX_STD_P __norm\n #  define _GLIBCXX_STD __cxx1998\n-#  define _GLIBCXX_EXT_D _GLIBCXX_EXT\n-#  define _GLIBCXX_EXT_P __norm\n-#  define _GLIBCXX_EXT __cxx1998\n #  define _GLIBCXX_BEGIN_NAMESPACE(X) namespace X _GLIBCXX_VISIBILITY(default) { \n #  define _GLIBCXX_END_NAMESPACE }\n #  define _GLIBCXX_EXTERN_TEMPLATE 0\n@@ -165,9 +146,6 @@\n #  define _GLIBCXX_STD_D __norm\n #  define _GLIBCXX_STD_P __norm\n #  define _GLIBCXX_STD __cxx1998\n-#  define _GLIBCXX_EXT_D __norm\n-#  define _GLIBCXX_EXT_P __norm\n-#  define _GLIBCXX_EXT __gnu_cxx\n #  define _GLIBCXX_BEGIN_NAMESPACE(X) namespace X _GLIBCXX_VISIBILITY(default) { \n #  define _GLIBCXX_END_NAMESPACE }\n #  define _GLIBCXX_EXTERN_TEMPLATE 0\n@@ -193,16 +171,6 @@ namespace std\n   using namespace __debug __attribute__ ((strong)); \n   using namespace __cxx1998 __attribute__ ((strong)); \n }\n-\n-namespace __gnu_cxx\n-{\n-  namespace __norm { }\n-  namespace __debug { }\n-  namespace __cxx1998 { }\n-\n-  using namespace __debug __attribute__ ((strong)); \n-  using namespace __cxx1998 __attribute__ ((strong)); \n-}\n #endif\n \n // Namespace associations for parallel mode.\n@@ -216,16 +184,6 @@ namespace std\n   using namespace __parallel __attribute__ ((strong));\n   using namespace __cxx1998 __attribute__ ((strong)); \n }\n-\n-namespace __gnu_cxx\n-{\n-  namespace __norm { }\n-  namespace __parallel { }\n-  namespace __cxx1998 { }\n-\n-  using namespace __parallel __attribute__ ((strong)); \n-  using namespace __cxx1998 __attribute__ ((strong)); \n-}\n #endif\n \n // Namespace associations for versioning mode."}, {"sha": "32f96a37bedfcc2c94a1bc9473e53a0df416554f", "filename": "libstdc++-v3/include/debug/debug.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdebug.h?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -49,15 +49,9 @@ namespace std\n   namespace __debug { } \n }\n \n-namespace __gnu_cxx\n-{ \n-  namespace __debug { };\n-}\n-\n namespace __gnu_debug\n {\n   using namespace std::__debug;\n-  using namespace __gnu_cxx::__debug;\n }\n \n #ifndef _GLIBCXX_DEBUG"}, {"sha": "f44586b0ab6c5d02c6c24ee890f15243d815e746", "filename": "libstdc++-v3/include/debug/hash_map", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_map?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,42 +0,0 @@\n-// Debugging hash_map/hash_multimap implementation -*- C++ -*-\n-\n-// Copyright (C) 2003, 2005\n-// Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file debug/hash_map\n- *  This file is a GNU debug extension to the Standard C++ Library.\n- */\n-\n-#ifndef _GLIBCXX_DEBUG_HASH_MAP\n-#define _GLIBCXX_DEBUG_HASH_MAP 1\n-\n-#include <ext/hash_map>\n-#include <debug/hash_map.h>\n-#include <debug/hash_multimap.h>\n-\n-#endif"}, {"sha": "aeac90b8a136056c7711d46e00e9c987c1618600", "filename": "libstdc++-v3/include/debug/hash_map.h", "status": "removed", "additions": 0, "deletions": 284, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_map.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,284 +0,0 @@\n-// Debugging hash_map implementation -*- C++ -*-\n-\n-// Copyright (C) 2003, 2005, 2006, 2007\n-// Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file debug/hash_map.h\n- *  This file is a GNU debug extension to the Standard C++ Library.\n- */\n-\n-#ifndef _GLIBCXX_DEBUG_HASH_MAP_H\n-#define _GLIBCXX_DEBUG_HASH_MAP_H 1\n-\n-#include <debug/safe_sequence.h>\n-#include <debug/safe_iterator.h>\n-\n-namespace __gnu_cxx\n-{\n-namespace __debug\n-{\n-  template<typename _Value, typename _Tp,\n-\t   typename _HashFcn  = __gnu_cxx::hash<_Value>,\n-\t   typename _EqualKey = std::equal_to<_Value>,\n-\t   typename _Alloc = std::allocator<_Value> >\n-    class hash_map\n-    : public _GLIBCXX_EXT_D::hash_map<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>,\n-      public __gnu_debug::_Safe_sequence<hash_map<_Value, _Tp, _HashFcn,\n-\t\t\t\t\t\t _EqualKey, _Alloc> >\n-    {\n-      typedef _GLIBCXX_EXT_D::hash_map<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>\n-      \t\t\t\t\t\t\t_Base;\n-      typedef __gnu_debug::_Safe_sequence<hash_map> \t_Safe_base;\n-\n-    public:\n-      typedef typename _Base::key_type        key_type;\n-      typedef typename _Base::data_type       data_type;\n-      typedef typename _Base::mapped_type     mapped_type;\n-      typedef typename _Base::value_type      value_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::difference_type difference_type;\n-      typedef typename _Base::pointer         pointer;\n-      typedef typename _Base::const_pointer   const_pointer;\n-      typedef typename _Base::reference       reference;\n-      typedef typename _Base::const_reference const_reference;\n-\n-      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, hash_map>\n-\t\t\t\t\t      iterator;\n-      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n-\t\t\t\t\t  hash_map>\n-\t\t\t\t\t      const_iterator;\n-\n-      typedef typename _Base::allocator_type  allocator_type;\n-\n-      using _Base::hash_funct;\n-      using _Base::key_eq;\n-      using _Base::get_allocator;\n-\n-      hash_map() { }\n-\n-      explicit hash_map(size_type __n) : _Base(__n) { }\n-\n-      hash_map(size_type __n, const hasher& __hf) : _Base(__n, __hf) { }\n-\n-      hash_map(size_type __n, const hasher& __hf, const key_equal& __eql,\n-\t       const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __eql, __a) { }\n-\n-      template<typename _InputIterator>\n-        hash_map(_InputIterator __f, _InputIterator __l)\n-        : _Base(__gnu_debug::__check_valid_range(__f, __l), __l) { }\n-\n-      template<typename _InputIterator>\n-        hash_map(_InputIterator __f, _InputIterator __l, size_type __n)\n-\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n) { }\n-\n-      template<typename _InputIterator>\n-        hash_map(_InputIterator __f, _InputIterator __l, size_type __n,\n-\t\t const hasher& __hf)\n-        : _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n, __hf) { }\n-\n-      template<typename _InputIterator>\n-        hash_map(_InputIterator __f, _InputIterator __l, size_type __n,\n-\t\t const hasher& __hf, const key_equal& __eql,\n-\t\t const allocator_type& __a = allocator_type())\n-\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n, __hf,\n-\t\t__eql, __a) { }\n-\n-      hash_map(const _Base& __x) : _Base(__x), _Safe_base() { }\n-\n-      using _Base::size;\n-      using _Base::max_size;\n-      using _Base::empty;\n-\n-      void\n-      swap(hash_map& __x)\n-      {\n-\t_Base::swap(__x);\n-\tthis->_M_swap(__x);\n-      }\n-\n-      iterator\n-      begin() { return iterator(_Base::begin(), this); }\n-\n-      iterator\n-      end() { return iterator(_Base::end(),   this); }\n-\n-      const_iterator\n-      begin() const\n-      { return const_iterator(_Base::begin(), this); }\n-\n-      const_iterator\n-      end() const\n-      { return const_iterator(_Base::end(),   this); }\n-\n-      std::pair<iterator, bool>\n-      insert(const value_type& __obj)\n-      {\n-\tstd::pair<typename _Base::iterator, bool> __res = _Base::insert(__obj);\n-\treturn std::make_pair(iterator(__res.first, this), __res.second);\n-      }\n-\n-      void\n-      insert(const value_type* __first, const value_type* __last)\n-      {\n-\t__glibcxx_check_valid_range(__first, __last);\n-\t_Base::insert(__first, __last);\n-      }\n-\n-     template<typename _InputIterator>\n-        void\n-        insert(_InputIterator __first, _InputIterator __last)\n-        {\n-\t  __glibcxx_check_valid_range(__first, __last);\n-\t  _Base::insert(__first.base(), __last.base());\n-\t}\n-\n-\n-      std::pair<iterator, bool>\n-      insert_noresize(const value_type& __obj)\n-      {\n-\tstd::pair<typename _Base::iterator, bool> __res =\n-\t                                        _Base::insert_noresize(__obj);\n-\treturn std::make_pair(iterator(__res.first, this), __res.second);\n-      }\n-\n-      iterator\n-      find(const key_type& __key)\n-      { return iterator(_Base::find(__key), this); }\n-\n-      const_iterator\n-      find(const key_type& __key) const\n-      { return const_iterator(_Base::find(__key), this); }\n-\n-      using _Base::operator[];\n-      using _Base::count;\n-\n-      std::pair<iterator, iterator>\n-      equal_range(const key_type& __key)\n-      {\n-\ttypedef typename _Base::iterator _Base_iterator;\n-\tstd::pair<_Base_iterator, _Base_iterator> __res =\n-\t                  _Base::equal_range(__key);\n-\treturn std::make_pair(iterator(__res.first, this),\n-\t\t\t      iterator(__res.second, this));\n-      }\n-\n-      std::pair<const_iterator, const_iterator>\n-      equal_range(const key_type& __key) const\n-      {\n-\ttypedef typename _Base::const_iterator _Base_iterator;\n-\tstd::pair<_Base_iterator, _Base_iterator> __res =\n-\t_Base::equal_range(__key);\n-\treturn std::make_pair(const_iterator(__res.first, this),\n-\t\t\t      const_iterator(__res.second, this));\n-      }\n-\n-      size_type\n-      erase(const key_type& __key)\n-      {\n-\titerator __victim(_Base::find(__key), this);\n-\tif (__victim != end())\n-\t  return this->erase(__victim), 1;\n-\telse\n-\t  return 0;\n-      }\n-\n-      void\n-      erase(iterator __it)\n-      {\n-\t__glibcxx_check_erase(__it);\n-\t__it._M_invalidate();\n-\t_Base::erase(__it.base());\n-      }\n-\n-      void\n-      erase(iterator __first, iterator __last)\n-      {\n-\t__glibcxx_check_erase_range(__first, __last);\n-\tfor (iterator __tmp = __first; __tmp != __last;)\n-\t{\n-\t  iterator __victim = __tmp++;\n-\t  __victim._M_invalidate();\n-\t}\n-\t_Base::erase(__first.base(), __last.base());\n-      }\n-\n-      void\n-      clear()\n-      {\n-\t_Base::clear();\n-\tthis->_M_invalidate_all();\n-      }\n-\n-      using _Base::resize;\n-      using _Base::bucket_count;\n-      using _Base::max_bucket_count;\n-      using _Base::elems_in_bucket;\n-\n-      _Base&\n-      _M_base()       { return *this; }\n-\n-      const _Base&\n-      _M_base() const { return *this; }\n-\n-    private:\n-      void\n-      _M_invalidate_all()\n-      {\n-\ttypedef typename _Base::const_iterator _Base_const_iterator;\n-\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n-      }\n-    };\n-\n-  template<typename _Value, typename _Tp, typename _HashFcn,\n-\t   typename _EqualKey, typename _Alloc>\n-    inline bool\n-    operator==(const hash_map<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>& __x,\n-\t       const hash_map<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>& __y)\n-    { return __x._M_base() == __y._M_base(); }\n-\n-  template<typename _Value, typename _Tp, typename _HashFcn,\n-\t   typename _EqualKey, typename _Alloc>\n-    inline bool\n-    operator!=(const hash_map<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>& __x,\n-\t       const hash_map<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>& __y)\n-    { return __x._M_base() != __y._M_base(); }\n-\n-  template<typename _Value, typename _Tp, typename _HashFcn,\n-\t   typename _EqualKey, typename _Alloc>\n-    inline void\n-    swap(hash_map<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>& __x,\n-\t hash_map<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>& __y)\n-    { __x.swap(__y); }\n-} // namespace __debug\n-} // namespace __gnu_cxx\n-\n-#endif"}, {"sha": "985fbc83030f6deefb35380d79d27bc67061db74", "filename": "libstdc++-v3/include/debug/hash_multimap.h", "status": "removed", "additions": 0, "deletions": 268, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_multimap.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,268 +0,0 @@\n-// Debugging hash_multimap implementation -*- C++ -*-\n-\n-// Copyright (C) 2003, 2005, 2006\n-// Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file debug/hash_multimap.h\n- *  This file is a GNU debug extension to the Standard C++ Library.\n- */\n-\n-#ifndef _GLIBCXX_DEBUG_HASH_MULTIMAP_H\n-#define _GLIBCXX_DEBUG_HASH_MULTIMAP_H 1\n-\n-#include <debug/safe_sequence.h>\n-#include <debug/safe_iterator.h>\n-\n-namespace __gnu_cxx\n-{\n-namespace __debug\n-{\n-  template<typename _Value, typename _Tp,\n-\t   typename _HashFcn  = __gnu_cxx::hash<_Value>,\n-\t   typename _EqualKey = std::equal_to<_Value>,\n-\t   typename _Alloc =  std::allocator<_Value> >\n-    class hash_multimap\n-    : public _GLIBCXX_EXT_D::hash_multimap<_Value,_Tp,_HashFcn,_EqualKey,_Alloc>,\n-      public __gnu_debug::_Safe_sequence<hash_multimap<_Value, _Tp, _HashFcn,\n-\t\t\t\t\t\t       _EqualKey, _Alloc> >\n-    {\n-      typedef _GLIBCXX_EXT_D::hash_multimap<_Value,_Tp,_HashFcn,_EqualKey,_Alloc>\n-\t\t\t\t\t\t\t_Base;\n-      typedef __gnu_debug::_Safe_sequence<hash_multimap> _Safe_base;\n-\n-  public:\n-      typedef typename _Base::key_type\t\t\tkey_type;\n-      typedef typename _Base::data_type\t\t\tdata_type;\n-      typedef typename _Base::mapped_type\t\tmapped_type;\n-      typedef typename _Base::value_type\t\tvalue_type;\n-      typedef typename _Base::hasher\t\t\thasher;\n-      typedef typename _Base::key_equal\t\t\tkey_equal;\n-      typedef typename _Base::size_type\t\t\tsize_type;\n-      typedef typename _Base::difference_type\t\tdifference_type;\n-      typedef typename _Base::pointer\t\t\tpointer;\n-      typedef typename _Base::const_pointer\t\tconst_pointer;\n-      typedef typename _Base::reference\t\t\treference;\n-      typedef typename _Base::const_reference\t\tconst_reference;\n-\n-      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator,\n-\t\t\t\t\t  hash_multimap> iterator;\n-      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n-\t\t\t\t\t  hash_multimap> const_iterator;\n-\n-      typedef typename _Base::allocator_type              allocator_type;\n-\n-      using _Base::hash_funct;\n-      using _Base::key_eq;\n-      using _Base::get_allocator;\n-\n-      hash_multimap() { }\n-\n-      explicit hash_multimap(size_type __n) : _Base(__n) { }\n-\n-      hash_multimap(size_type __n, const hasher& __hf) : _Base(__n, __hf) { }\n-\n-      hash_multimap(size_type __n, const hasher& __hf, const key_equal& __eql,\n-\t\t    const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __eql, __a) { }\n-\n-      template<typename _InputIterator>\n-        hash_multimap(_InputIterator __f, _InputIterator __l)\n-\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l) { }\n-\n-      template<typename _InputIterator>\n-        hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n)\n-        : _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n) { }\n-\n-      template<typename _InputIterator>\n-        hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n,\n-\t\t      const hasher& __hf)\n-\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n, __hf) { }\n-\n-      template<typename _InputIterator>\n-        hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n,\n-\t\t      const hasher& __hf, const key_equal& __eql,\n-\t\t      const allocator_type& __a = allocator_type())\n-\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n, __hf,\n-\t\t__eql, __a) { }\n-\n-      using _Base::size;\n-      using _Base::max_size;\n-      using _Base::empty;\n-\n-      void\n-      swap(hash_multimap& __x)\n-      {\n-\t_Base::swap(__x);\n-\tthis->_M_swap(__x);\n-      }\n-\n-      iterator\n-      begin() { return iterator(_Base::begin(), this); }\n-\n-      iterator\n-      end()   { return iterator(_Base::end(),   this); }\n-\n-      const_iterator\n-      begin() const\n-      { return const_iterator(_Base::begin(), this); }\n-\n-      const_iterator\n-      end() const\n-      { return const_iterator(_Base::end(),   this); }\n-\n-      iterator\n-      insert(const value_type& __obj)\n-      { return iterator(_Base::insert(__obj), this); }\n-\n-      template <typename _InputIterator>\n-        void\n-        insert(_InputIterator __first, _InputIterator __last)\n-        {\n-\t  __glibcxx_check_valid_range(__first, __last);\n-\t  _Base::insert(__first.base(), __last.base());\n-\t}\n-\n-      iterator\n-      insert_noresize(const value_type& __obj)\n-      { return iterator(_Base::insert_noresize(__obj), this); }\n-\n-      iterator\n-      find(const key_type& __key)\n-      { return iterator(_Base::find(__key), this); }\n-\n-      const_iterator\n-      find(const key_type& __key) const\n-      { return const_iterator(_Base::find(__key), this); }\n-\n-      using _Base::count;\n-\n-      std::pair<iterator, iterator>\n-      equal_range(const key_type& __key)\n-      {\n-\ttypedef typename _Base::iterator _Base_iterator;\n-\tstd::pair<_Base_iterator, _Base_iterator> __res =\n-\t                                             _Base::equal_range(__key);\n-\treturn std::make_pair(iterator(__res.first, this),\n-\t\t\t      iterator(__res.second, this));\n-      }\n-\n-      std::pair<const_iterator, const_iterator>\n-      equal_range(const key_type& __key) const\n-      {\n-\ttypedef typename _Base::const_iterator _Base_iterator;\n-\tstd::pair<_Base_iterator, _Base_iterator> __res =\n-        _Base::equal_range(__key);\n-\treturn std::make_pair(const_iterator(__res.first, this),\n-\t\t\t      const_iterator(__res.second, this));\n-      }\n-\n-      size_type\n-      erase(const key_type& __key)\n-      {\n-\tstd::pair<iterator, iterator> __victims = this->equal_range(__key);\n-\tstd::size_t __num_victims = 0;\n-\twhile (__victims.first != __victims.second)\n-\t{\n-\t  this->erase(__victims.first++);\n-\t  ++__num_victims;\n-\t}\n-\treturn __num_victims;\n-      }\n-\n-      void\n-      erase(iterator __it)\n-      {\n-\t__glibcxx_check_erase(__it);\n-\t__it._M_invalidate();\n-\t_Base::erase(__it.base());\n-      }\n-\n-      void\n-      erase(iterator __first, iterator __last)\n-      {\n-\t__glibcxx_check_erase_range(__first, __last);\n-\tfor (iterator __tmp = __first; __tmp != __last;)\n-\t{\n-\t  iterator __victim = __tmp++;\n-\t  __victim._M_invalidate();\n-\t}\n-\t_Base::erase(__first.base(), __last.base());\n-      }\n-\n-      void\n-      clear()\n-      {\n-\t_Base::clear();\n-\tthis->_M_invalidate_all();\n-      }\n-\n-      using _Base::resize;\n-      using _Base::bucket_count;\n-      using _Base::max_bucket_count;\n-      using _Base::elems_in_bucket;\n-\n-      _Base&\n-      _M_base()       { return *this; }\n-\n-      const _Base&\n-      _M_base() const { return *this; }\n-\n-    private:\n-      void\n-      _M_invalidate_all()\n-      {\n-\ttypedef typename _Base::const_iterator _Base_const_iterator;\n-\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n-      }\n-    };\n-\n-  template<typename _Value, typename _Tp, typename _HashFcn,\n-\t   typename _EqualKey, typename _Alloc>\n-    inline bool\n-    operator==(const hash_multimap<_Value,_Tp,_HashFcn,_EqualKey,_Alloc>& __x,\n-\t       const hash_multimap<_Value,_Tp,_HashFcn,_EqualKey,_Alloc>& __y)\n-    { return __x._M_base() == __y._M_base(); }\n-\n-  template<typename _Value, typename _Tp, typename _HashFcn,\n-\t   typename _EqualKey, typename _Alloc>\n-    inline bool\n-    operator!=(const hash_multimap<_Value,_Tp,_HashFcn,_EqualKey,_Alloc>& __x,\n-\t       const hash_multimap<_Value,_Tp,_HashFcn,_EqualKey,_Alloc>& __y)\n-    { return __x._M_base() != __y._M_base(); }\n-\n-  template<typename _Value, typename _Tp, typename _HashFcn,\n-\t   typename _EqualKey, typename _Alloc>\n-    inline void\n-    swap(hash_multimap<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>& __x,\n-\t hash_multimap<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>& __y)\n-    { __x.swap(__y); }\n-} // namespace __debug\n-} // namespace __gnu_cxx\n-\n-#endif"}, {"sha": "11efb5b68464272cc196fd1fd9df75961a53dfde", "filename": "libstdc++-v3/include/debug/hash_multiset.h", "status": "removed", "additions": 0, "deletions": 243, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_multiset.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,243 +0,0 @@\n-// Debugging hash_multiset implementation -*- C++ -*-\n-\n-// Copyright (C) 2003, 2005, 2006\n-// Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file debug/hash_multiset.h\n- *  This file is a GNU debug extension to the Standard C++ Library.\n- */\n-\n-#ifndef _GLIBCXX_DEBUG_HASH_MULTISET_H\n-#define _GLIBCXX_DEBUG_HASH_MULTISET_H 1\n-\n-#include <debug/safe_sequence.h>\n-#include <debug/safe_iterator.h>\n-\n-namespace __gnu_cxx\n-{\n-namespace __debug\n-{\n-  template<typename _Value,\n-\t   typename _HashFcn  = __gnu_cxx::hash<_Value>,\n-\t   typename _EqualKey = std::equal_to<_Value>,\n-\t   typename _Alloc =  std::allocator<_Value> >\n-    class hash_multiset\n-    : public _GLIBCXX_EXT_D::hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc>,\n-      public __gnu_debug::_Safe_sequence<hash_multiset<_Value, _HashFcn,\n-\t\t\t\t\t\t       _EqualKey, _Alloc> >\n-    {\n-      typedef _GLIBCXX_EXT_D:: hash_multiset<_Value,_HashFcn, _EqualKey,_Alloc>\n-\t\t\t\t\t\t\t_Base;\n-      typedef __gnu_debug::_Safe_sequence<hash_multiset> _Safe_base;\n-\n-  public:\n-    typedef typename _Base::key_type\t\t\tkey_type;\n-    typedef typename _Base::value_type\t\t\tvalue_type;\n-    typedef typename _Base::hasher\t\t\thasher;\n-    typedef typename _Base::key_equal\t\t\tkey_equal;\n-    typedef typename _Base::size_type\t\t\tsize_type;\n-    typedef typename _Base::difference_type\t\tdifference_type;\n-    typedef typename _Base::pointer\t\t\tpointer;\n-    typedef typename _Base::const_pointer\t\tconst_pointer;\n-    typedef typename _Base::reference\t\t\treference;\n-    typedef typename _Base::const_reference\t\tconst_reference;\n-\n-    typedef __gnu_debug::_Safe_iterator<typename _Base::iterator,\n-\t\t\t\t\t hash_multiset> iterator;\n-    typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n-\t\t\t\t\t hash_multiset> const_iterator;\n-\n-    typedef typename _Base::allocator_type              allocator_type;\n-\n-    using _Base::hash_funct;\n-    using _Base::key_eq;\n-    using _Base::get_allocator;\n-\n-    hash_multiset() { }\n-\n-    explicit hash_multiset(size_type __n) : _Base(__n) { }\n-\n-    hash_multiset(size_type __n, const hasher& __hf) : _Base(__n, __hf) { }\n-\n-    hash_multiset(size_type __n, const hasher& __hf, const key_equal& __eql,\n-\t\t  const allocator_type& __a = allocator_type())\n-    : _Base(__n, __hf, __eql, __a)\n-    { }\n-\n-    template<typename _InputIterator>\n-      hash_multiset(_InputIterator __f, _InputIterator __l)\n-      : _Base(__gnu_debug::__check_valid_range(__f, __l), __l)\n-      { }\n-\n-    template<typename _InputIterator>\n-      hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n)\n-      : _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n)\n-      { }\n-\n-    template<typename _InputIterator>\n-      hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n,\n-\t\t    const hasher& __hf)\n-      : _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n, __hf)\n-      { }\n-\n-    template<typename _InputIterator>\n-      hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n,\n-\t\t    const hasher& __hf, const key_equal& __eql,\n-\t\t    const allocator_type& __a = allocator_type())\n-      : _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n, __hf,\n-\t      __eql, __a)\n-      { }\n-\n-    hash_multiset(const _Base& __x) : _Base(__x), _Safe_base() { }\n-\n-    using _Base::size;\n-    using _Base::max_size;\n-    using _Base::empty;\n-\n-    void\n-    swap(hash_multiset& __x)\n-    {\n-      _Base::swap(__x);\n-      this->_M_swap(__x);\n-    }\n-\n-    iterator begin() const { return iterator(_Base::begin(), this); }\n-    iterator end() const   { return iterator(_Base::end(),   this); }\n-\n-    iterator\n-    insert(const value_type& __obj)\n-    { return iterator(_Base::insert(__obj), this); }\n-\n-    template <typename _InputIterator>\n-      void\n-      insert(_InputIterator __first, _InputIterator __last)\n-      {\n-\t__glibcxx_check_valid_range(__first, __last);\n-\t_Base::insert(__first.base(), __last.base());\n-      }\n-\n-\n-    iterator\n-    insert_noresize(const value_type& __obj)\n-    { return iterator(_Base::insert_noresize(__obj), this); }\n-\n-    iterator\n-    find(const key_type& __key) const\n-    { return iterator(_Base::find(__key), this); }\n-\n-    using _Base::count;\n-\n-    std::pair<iterator, iterator>\n-    equal_range(const key_type& __key) const\n-    {\n-      typedef typename _Base::iterator _Base_iterator;\n-      std::pair<_Base_iterator, _Base_iterator> __res =\n-\t_Base::equal_range(__key);\n-      return std::make_pair(iterator(__res.first, this),\n-\t\t\t    iterator(__res.second, this));\n-    }\n-\n-    size_type\n-    erase(const key_type& __key)\n-    {\n-      size_type __count = 0;\n-      std::pair<iterator, iterator> __victims = this->equal_range(__key);\n-      while (__victims.first != __victims.second)\n-\t{\n-\t  this->erase(__victims++);\n-\t  ++__count;\n-\t}\n-      return __count;\n-    }\n-\n-    void\n-    erase(iterator __it)\n-    {\n-      __glibcxx_check_erase(__it);\n-      __it._M_invalidate();\n-      _Base::erase(__it.base());\n-    }\n-\n-    void\n-    erase(iterator __first, iterator __last)\n-    {\n-      __glibcxx_check_erase_range(__first, __last);\n-      for (iterator __tmp = __first; __tmp != __last;)\n-\t{\n-\t  iterator __victim = __tmp++;\n-\t  __victim._M_invalidate();\n-\t}\n-      _Base::erase(__first.base(), __last.base());\n-    }\n-\n-    void\n-    clear()\n-    {\n-      _Base::clear();\n-      this->_M_invalidate_all();\n-    }\n-\n-    using _Base::resize;\n-    using _Base::bucket_count;\n-    using _Base::max_bucket_count;\n-    using _Base::elems_in_bucket;\n-\n-    _Base&       _M_base()       { return *this; }\n-    const _Base& _M_base() const { return *this; }\n-\n-  private:\n-    void\n-    _M_invalidate_all()\n-    {\n-      typedef typename _Base::const_iterator _Base_const_iterator;\n-      typedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-      this->_M_invalidate_if(_Not_equal(_M_base().end()));\n-    }\n-  };\n-\n-template<typename _Value, typename _HashFcn, typename _EqualKey, typename _Alloc>\n-  inline bool\n-  operator==(const hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc>& __x,\n-\t     const hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc>& __y)\n-  { return __x._M_base() == __y._M_base(); }\n-\n-template<typename _Value, typename _HashFcn, typename _EqualKey, typename _Alloc>\n-  inline bool\n-  operator!=(const hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc>& __x,\n-\t     const hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc>& __y)\n-  { return __x._M_base() != __y._M_base(); }\n-\n-template<typename _Value, typename _HashFcn, typename _EqualKey, typename _Alloc>\n-  inline void\n-  swap(hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc>& __x,\n-       hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc>& __y)\n-  { __x.swap(__y); }\n-} // namespace __debug\n-} // namespace __gnu_cxx\n-\n-#endif"}, {"sha": "4b98fefab1f6052b32c13820ed182e2b7093d80d", "filename": "libstdc++-v3/include/debug/hash_set", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_set?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,42 +0,0 @@\n-// Debugging hash_set/hash_multiset implementation -*- C++ -*-\n-\n-// Copyright (C) 2003, 2005\n-// Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file debug/hash_set\n- *  This file is a GNU debug extension to the Standard C++ Library.\n- */\n-\n-#ifndef _GLIBCXX_DEBUG_HASH_SET\n-#define _GLIBCXX_DEBUG_HASH_SET 1\n-\n-#include <ext/hash_set>\n-#include <debug/hash_set.h>\n-#include <debug/hash_multiset.h>\n-\n-#endif"}, {"sha": "dcb9ab44dbc9f1feafbd34e29c2782331b659eb3", "filename": "libstdc++-v3/include/debug/safe_association.h", "status": "renamed", "additions": 88, "deletions": 123, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_association.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_association.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_association.h?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -1,6 +1,6 @@\n-// Debugging hash_set implementation -*- C++ -*-\n+// Safe associated container base class implementation  -*- C++ -*-\n \n-// Copyright (C) 2003, 2005, 2006, 2007\n+// Copyright (C) 2007\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -28,110 +28,110 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-/** @file debug/hash_set.h\n+/** @file debug/safe_association.h\n  *  This file is a GNU debug extension to the Standard C++ Library.\n  */\n \n-#ifndef _GLIBCXX_DEBUG_HASH_SET_H\n-#define _GLIBCXX_DEBUG_HASH_SET_H 1\n+#ifndef _GLIBCXX_DEBUG_SAFE_ASSOCIATION_H\n+#define _GLIBCXX_DEBUG_SAFE_ASSOCIATION_H 1\n \n+#include <debug/debug.h>\n+#include <debug/macros.h>\n+#include <debug/functions.h>\n+#include <debug/formatter.h>\n #include <debug/safe_sequence.h>\n-#include <debug/safe_iterator.h>\n \n-namespace __gnu_cxx\n+namespace __gnu_debug\n {\n-namespace __debug\n-{\n-  template<typename _Value,\n-\t   typename _HashFcn  = __gnu_cxx::hash<_Value>,\n-\t   typename _EqualKey = std::equal_to<_Value>,\n-\t   typename _Alloc =  std::allocator<_Value> >\n-    class hash_set\n-    : public _GLIBCXX_EXT_D::hash_set<_Value, _HashFcn, _EqualKey,_Alloc>,\n-      public __gnu_debug::_Safe_sequence<hash_set<_Value, _HashFcn, _EqualKey,\n-\t\t\t\t\t\t  _Alloc> >\n+  /**\n+   * @brief Base class for constructing a \"safe\" associated container type.\n+   *\n+   * The class template %_Safe_association simplifies the construction of\n+   * \"safe\" associated containers.\n+   */\n+  template<typename _Base>\n+    class _Safe_association \n+    : public _Base\n     {\n-      typedef _GLIBCXX_EXT_D::hash_set<_Value, _HashFcn, _EqualKey,_Alloc> _Base;\n-      typedef __gnu_debug::_Safe_sequence<hash_set> _Safe_base;\n-\n     public:\n-      typedef typename _Base::key_type        key_type;\n-      typedef typename _Base::value_type      value_type;\n+      typedef typename _Base::size_type       size_type;\n       typedef typename _Base::hasher          hasher;\n       typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::allocator_type allocator_type;\n+\n+      typedef typename _Base::key_type        key_type;\n+      typedef typename _Base::value_type      value_type;\n       typedef typename _Base::difference_type difference_type;\n-      typedef typename _Base::pointer         pointer;\n-      typedef typename _Base::const_pointer   const_pointer;\n       typedef typename _Base::reference       reference;\n       typedef typename _Base::const_reference const_reference;\n \n-      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, hash_set>\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, \n+\t\t\t\t\t  _Safe_association>\n                                               iterator;\n       typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n-\t\t\t\t\t  hash_set>\n+\t\t\t\t\t  _Safe_association>\n                                               const_iterator;\n \n-      typedef typename _Base::allocator_type allocator_type;\n+      _Safe_association() { }\n \n-      using _Base::hash_funct;\n-      using _Base::key_eq;\n-      using _Base::get_allocator;\n-\n-      hash_set() { }\n+      explicit _Safe_association(size_type __n) : _Base(__n) { }\n \n-      explicit hash_set(size_type __n) : _Base(__n) { }\n+      _Safe_association(size_type __n, const hasher& __hf) \n+      : _Base(__n, __hf) { }\n \n-      hash_set(size_type __n, const hasher& __hf) : _Base(__n, __hf) { }\n-\n-      hash_set(size_type __n, const hasher& __hf, const key_equal& __eql,\n-\t       const allocator_type& __a = allocator_type())\n+      _Safe_association(size_type __n, const hasher& __hf, \n+\t\t\tconst key_equal& __eql,\n+\t\t\tconst allocator_type& __a = allocator_type())\n       : _Base(__n, __hf, __eql, __a) { }\n \n-      template<typename _InputIterator>\n-        hash_set(_InputIterator __f, _InputIterator __l)\n-        : _Base(__gnu_debug::__check_valid_range(__f, __l), __l) { }\n+      template<typename _InputIter>\n+        _Safe_association(_InputIter __f, _InputIter __l)\n+\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l) { }\n \n-      template<typename _InputIterator>\n-        hash_set(_InputIterator __f, _InputIterator __l, size_type __n)\n+      template<typename _InputIter>\n+        _Safe_association(_InputIter __f, _InputIter __l, size_type __n)\n \t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n) { }\n \n-      template<typename _InputIterator>\n-        hash_set(_InputIterator __f, _InputIterator __l, size_type __n,\n-\t\t const hasher& __hf)\n-\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n, __hf) { }\n+      template<typename _InputIter>\n+        _Safe_association(_InputIter __f, _InputIter __l, size_type __n,\n+\t\t      const hasher& __hf)\n+\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n, __hf) \n+        { }\n \n-      template<typename _InputIterator>\n-        hash_set(_InputIterator __f, _InputIterator __l, size_type __n,\n-\t\t const hasher& __hf, const key_equal& __eql,\n-\t\t const allocator_type& __a = allocator_type())\n-\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n, __hf,\n-\t\t__eql, __a) { }\n+      template<typename _InputIter>\n+        _Safe_association(_InputIter __f, _InputIter __l, size_type __n,\n+\t\t\t  const hasher& __hf, const key_equal& __eql,\n+\t\t\t  const allocator_type& __a = allocator_type())\n+\t: _Base(__gnu_debug::__check_valid_range(__f, __l), \n+\t\t__l, __n, __hf, __eql, __a) \n+        { }\n \n-      hash_set(const _Base& __x) : _Base(__x), _Safe_base() { }\n+      _Safe_association(const _Base& __x) : _Base(__x) { }\n \n       using _Base::size;\n       using _Base::max_size;\n       using _Base::empty;\n+      using _Base::get_allocator;\n+      using _Base::key_eq;\n \n-      void\n-      swap(hash_set& __x)\n-      {\n-\t_Base::swap(__x);\n-\tthis->_M_swap(__x);\n-      }\n+      using _Base::count;\n+      using _Base::bucket_count;\n+      using _Base::max_bucket_count;\n+      using _Base::bucket;\n+      using _Base::bucket_size;\n+      using _Base::load_factor;\n \n-      iterator\n-      begin() const { return iterator(_Base::begin(), this); }\n+      const_iterator\n+      begin() const { return const_iterator(_Base::begin(), this); }\n \n-      iterator\n-      end() const   { return iterator(_Base::end(),   this); }\n+      const_iterator\n+      end() const   { return const_iterator(_Base::end(), this); }\n \n       std::pair<iterator, bool>\n       insert(const value_type& __obj)\n       {\n-\tstd::pair<typename _Base::iterator, bool> __res =\n-        _Base::insert(__obj);\n+\ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n+\t__pair_type __res = _Base::insert(__obj);\n \treturn std::make_pair(iterator(__res.first, this), __res.second);\n       }\n \n@@ -142,58 +142,50 @@ namespace __debug\n \t_Base::insert(__first, __last);\n       }\n \n-      template<typename _InputIterator>\n+      template<typename _InputIter>\n         void\n-        insert(_InputIterator __first, _InputIterator __last)\n+        insert(_InputIter __first, _InputIter __last)\n         {\n \t  __glibcxx_check_valid_range(__first, __last);\n \t  _Base::insert(__first.base(), __last.base());\n \t}\n \n-\n-      std::pair<iterator, bool>\n-      insert_noresize(const value_type& __obj)\n-      {\n-\tstd::pair<typename _Base::iterator, bool> __res =\n-        _Base::insert_noresize(__obj);\n-\treturn std::make_pair(iterator(__res.first, this), __res.second);\n-      }\n-\n-      iterator\n+      const_iterator\n       find(const key_type& __key) const\n-      { return iterator(_Base::find(__key), this); }\n+      { return const_iterator(_Base::find(__key), this); }\n \n-      using _Base::count;\n-\n-      std::pair<iterator, iterator>\n+      std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __key) const\n       {\n-\ttypedef typename _Base::iterator _Base_iterator;\n-\tstd::pair<_Base_iterator, _Base_iterator> __res =\n-\t  _Base::equal_range(__key);\n-\treturn std::make_pair(iterator(__res.first, this),\n-\t\t\t      iterator(__res.second, this));\n+\ttypedef typename _Base::const_iterator _Base_iterator;\n+\ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n+\t__pair_type __res = _Base::equal_range(__key);\n+\treturn std::make_pair(const_iterator(__res.first, this),\n+\t\t\t      const_iterator(__res.second, this));\n       }\n \n       size_type\n       erase(const key_type& __key)\n       {\n+\tsize_type __ret(0);\n \titerator __victim(_Base::find(__key), this);\n \tif (__victim != end())\n-\t  return this->erase(__victim), 1;\n-\telse\n-\t  return 0;\n+\t  {\n+\t    this->erase(__victim);\n+\t    __ret = 1;\n+\t  }\n+\treturn __ret;\n       }\n \n-      void\n+      iterator\n       erase(iterator __it)\n       {\n \t__glibcxx_check_erase(__it);\n \t__it._M_invalidate();\n-\t_Base::erase(__it.base());\n+\treturn iterator(_Base::erase(__it.base()));\n       }\n \n-      void\n+      iterator\n       erase(iterator __first, iterator __last)\n       {\n \t__glibcxx_check_erase_range(__first, __last);\n@@ -202,7 +194,7 @@ namespace __debug\n \t  iterator __victim = __tmp++;\n \t  __victim._M_invalidate();\n \t}\n-\t_Base::erase(__first.base(), __last.base());\n+\treturn iterator(_Base::erase(__first.base(), __last.base()));\n       }\n \n       void\n@@ -212,13 +204,8 @@ namespace __debug\n \tthis->_M_invalidate_all();\n       }\n \n-      using _Base::resize;\n-      using _Base::bucket_count;\n-      using _Base::max_bucket_count;\n-      using _Base::elems_in_bucket;\n-\n       _Base&\n-      _M_base()       { return *this; }\n+      _M_base() { return *this; }\n \n       const _Base&\n       _M_base() const { return *this; }\n@@ -232,28 +219,6 @@ namespace __debug\n \tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n       }\n     };\n-\n-  template<typename _Value, typename _HashFcn, typename _EqualKey,\n-\t   typename _Alloc>\n-    inline bool\n-    operator==(const hash_set<_Value, _HashFcn, _EqualKey, _Alloc>& __x,\n-\t       const hash_set<_Value, _HashFcn, _EqualKey, _Alloc>& __y)\n-    { return __x._M_base() == __y._M_base(); }\n-\n-  template<typename _Value, typename _HashFcn, typename _EqualKey,\n-\t   typename _Alloc>\n-    inline bool\n-    operator!=(const hash_set<_Value, _HashFcn, _EqualKey, _Alloc>& __x,\n-\t       const hash_set<_Value, _HashFcn, _EqualKey, _Alloc>& __y)\n-    { return __x._M_base() != __y._M_base(); }\n-\n-  template<typename _Value, typename _HashFcn, typename _EqualKey,\n-\t   typename _Alloc>\n-    inline void\n-    swap(hash_set<_Value, _HashFcn, _EqualKey, _Alloc>& __x,\n-\t hash_set<_Value, _HashFcn, _EqualKey, _Alloc>& __y)\n-    { __x.swap(__y); }\n-} // namespace __debug\n-} // namespace __gnu_cxx\n+} // namespace __gnu_debug\n \n #endif", "previous_filename": "libstdc++-v3/include/debug/hash_set.h"}, {"sha": "a88a972aa7fc9ed60babe9e5436718a58726dce7", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -0,0 +1,199 @@\n+// Debugging unordered_map/unordered_multimap implementation -*- C++ -*-\n+\n+// Copyright (C) 2003, 2005, 2007\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file debug/unordered_map\n+ *  This file is a GNU debug extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_DEBUG_UNORDERED_MAP\n+#define _GLIBCXX_DEBUG_UNORDERED_MAP 1\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+# include <unordered_map>\n+#else\n+# include <c++0x_warning.h>\n+#endif\n+#include <debug/safe_association.h>\n+#include <debug/safe_iterator.h>\n+\n+#define _GLIBCXX_BASE unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\n+#define _GLIBCXX_STD_BASE _GLIBCXX_STD_D::_GLIBCXX_BASE\n+\n+namespace std\n+{\n+namespace __debug\n+{\n+  template<typename _Key, typename _Tp,\n+\t   typename _Hash  = std::hash<_Key>,\n+\t   typename _Pred = std::equal_to<_Key>,\n+\t   typename _Alloc =  std::allocator<_Key> >\n+    class unordered_map\n+    : public __gnu_debug::_Safe_association<_GLIBCXX_STD_BASE>,\n+      public __gnu_debug::_Safe_sequence<_GLIBCXX_BASE>\n+    {\n+      typedef typename _GLIBCXX_STD_BASE _Base;\n+      typedef __gnu_debug::_Safe_association<_Base> _Safe_assoc;\n+      typedef __gnu_debug::_Safe_sequence<unordered_map> _Safe_base;\n+\n+    public:\n+      typedef typename _Safe_assoc::size_type       size_type;\n+      typedef typename _Safe_assoc::hasher          hasher;\n+      typedef typename _Safe_assoc::key_equal       key_equal;\n+      typedef typename _Safe_assoc::allocator_type allocator_type;\n+\n+      explicit\n+      unordered_map(size_type __n = 10,\n+\t\t    const hasher& __hf = hasher(),\n+\t\t    const key_equal& __eql = key_equal(),\n+\t\t    const allocator_type& __a = allocator_type())\n+      : _Safe_assoc(__n, __hf, __eql, __a)\n+      { }\n+\n+      template<typename _InputIterator>\n+        unordered_map(_InputIterator __f, _InputIterator __l, \n+\t\t      size_type __n = 10,\n+\t\t      const hasher& __hf = hasher(), \n+\t\t      const key_equal& __eql = key_equal(), \n+\t\t      const allocator_type& __a = allocator_type())\n+\t: _Safe_assoc(__f, __l, __n, __hf, __eql, __a)\n+        { }\n+\n+      unordered_map(const _Safe_assoc& __x) \n+      : _Safe_assoc(__x), _Safe_base() { }\n+\n+      void\n+      swap(unordered_map& __x)\n+      {\n+\t_Safe_assoc::swap(__x);\n+\t_Safe_base::_M_swap(__x);\n+      }\n+    };\n+\n+  template<typename _Key, typename _Tp, typename _Hash,\n+\t   typename _Pred, typename _Alloc>\n+    inline bool\n+    operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_base() == __y._M_base(); }\n+\n+  template<typename _Key, typename _Tp, typename _Hash,\n+\t   typename _Pred, typename _Alloc>\n+    inline bool\n+    operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_base() != __y._M_base(); }\n+\n+  template<typename _Key, typename _Tp, typename _Hash,\n+\t   typename _Pred, typename _Alloc>\n+    inline void\n+    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+#undef _GLIBCXX_BASE\n+#undef _GLIBCXX_STD_BASE\n+#define _GLIBCXX_STD_BASE _GLIBCXX_STD_D::_GLIBCXX_BASE\n+#define _GLIBCXX_BASE unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\n+\n+  template<typename _Key, typename _Tp,\n+\t   typename _Hash  = std::hash<_Key>,\n+\t   typename _Pred = std::equal_to<_Key>,\n+\t   typename _Alloc =  std::allocator<_Key> >\n+    class unordered_multimap\n+    : public __gnu_debug::_Safe_association<_GLIBCXX_STD_BASE>,\n+      public __gnu_debug::_Safe_sequence<_GLIBCXX_BASE>\n+    {\n+      typedef typename _GLIBCXX_STD_BASE _Base;\n+      typedef __gnu_debug::_Safe_association<_Base> _Safe_assoc;\n+      typedef __gnu_debug::_Safe_sequence<unordered_multimap> _Safe_base;\n+\n+    public:\n+      typedef typename _Safe_assoc::size_type       size_type;\n+      typedef typename _Safe_assoc::hasher          hasher;\n+      typedef typename _Safe_assoc::key_equal       key_equal;\n+      typedef typename _Safe_assoc::allocator_type allocator_type;\n+\n+      explicit\n+      unordered_multimap(size_type __n = 10,\n+\t\t    const hasher& __hf = hasher(),\n+\t\t    const key_equal& __eql = key_equal(),\n+\t\t    const allocator_type& __a = allocator_type())\n+      : _Safe_assoc(__n, __hf, __eql, __a)\n+      { }\n+\n+      template<typename _InputIterator>\n+        unordered_multimap(_InputIterator __f, _InputIterator __l, \n+\t\t      size_type __n = 10,\n+\t\t      const hasher& __hf = hasher(), \n+\t\t      const key_equal& __eql = key_equal(), \n+\t\t      const allocator_type& __a = allocator_type())\n+\t: _Safe_assoc(__f, __l, __n, __hf, __eql, __a)\n+        { }\n+\n+      unordered_multimap(const _Safe_assoc& __x) \n+      : _Safe_assoc(__x), _Safe_base() { }\n+\n+      void\n+      swap(unordered_multimap& __x)\n+      {\n+\t_Safe_assoc::swap(__x);\n+\t_Safe_base::_M_swap(__x);\n+      }\n+    };\n+\n+  template<typename _Key, typename _Tp, typename _Hash,\n+\t   typename _Pred, typename _Alloc>\n+    inline bool\n+    operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_base() == __y._M_base(); }\n+\n+  template<typename _Key, typename _Tp, typename _Hash,\n+\t   typename _Pred, typename _Alloc>\n+    inline bool\n+    operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_base() != __y._M_base(); }\n+\n+  template<typename _Key, typename _Tp, typename _Hash,\n+\t   typename _Pred, typename _Alloc>\n+    inline void\n+    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+\n+} // namespace __debug\n+} // namespace std\n+\n+#undef _GLIBCXX_BASE\n+#undef _GLIBCXX_STD_BASE\n+\n+#endif"}, {"sha": "a49b4b0601943de32c4e9e956e04cb6ec3c3f94b", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -0,0 +1,192 @@\n+// Debugging unordered_set/unordered_multiset implementation -*- C++ -*-\n+\n+// Copyright (C) 2003, 2005, 2007\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file debug/unordered_set\n+ *  This file is a GNU debug extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_DEBUG_UNORDERED_SET\n+#define _GLIBCXX_DEBUG_UNORDERED_SET 1\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+# include <unordered_set>\n+#else\n+# include <c++0x_warning.h>\n+#endif\n+\n+#include <debug/safe_association.h>\n+#include <debug/safe_iterator.h>\n+\n+#define _GLIBCXX_BASE unordered_set<_Value, _Hash, _Pred, _Alloc>\n+#define _GLIBCXX_STD_BASE _GLIBCXX_STD_D::_GLIBCXX_BASE\n+\n+namespace std\n+{\n+namespace __debug\n+{\n+  template<typename _Value,\n+\t   typename _Hash  = std::hash<_Value>,\n+\t   typename _Pred = std::equal_to<_Value>,\n+\t   typename _Alloc =  std::allocator<_Value> >\n+    class unordered_set\n+    : public __gnu_debug::_Safe_association<_GLIBCXX_STD_BASE>,\n+      public __gnu_debug::_Safe_sequence<_GLIBCXX_BASE>\n+    {\n+      typedef typename _GLIBCXX_STD_BASE _Base;\n+      typedef __gnu_debug::_Safe_association<_Base> _Safe_assoc;\n+      typedef __gnu_debug::_Safe_sequence<unordered_set> _Safe_base;\n+\n+    public:\n+      typedef typename _Safe_assoc::size_type       size_type;\n+      typedef typename _Safe_assoc::hasher          hasher;\n+      typedef typename _Safe_assoc::key_equal       key_equal;\n+      typedef typename _Safe_assoc::allocator_type allocator_type;\n+\n+      explicit\n+      unordered_set(size_type __n = 10,\n+\t\t    const hasher& __hf = hasher(),\n+\t\t    const key_equal& __eql = key_equal(),\n+\t\t    const allocator_type& __a = allocator_type())\n+      : _Safe_assoc(__n, __hf, __eql, __a)\n+      { }\n+\n+      template<typename _InputIterator>\n+        unordered_set(_InputIterator __f, _InputIterator __l, \n+\t\t      size_type __n = 10,\n+\t\t      const hasher& __hf = hasher(), \n+\t\t      const key_equal& __eql = key_equal(), \n+\t\t      const allocator_type& __a = allocator_type())\n+\t: _Safe_assoc(__f, __l, __n, __hf, __eql, __a)\n+        { }\n+\n+      unordered_set(const _Safe_assoc& __x) \n+      : _Safe_assoc(__x), _Safe_base() { }\n+\n+      void\n+      swap(unordered_set& __x)\n+      {\n+\t_Safe_assoc::swap(__x);\n+\t_Safe_base::_M_swap(__x);\n+      }\n+    };\n+\n+  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+    inline bool\n+    operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_base() == __y._M_base(); }\n+\n+  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+    inline bool\n+    operator!=(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_base() != __y._M_base(); }\n+\n+  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+    inline void\n+    swap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+#undef _GLIBCXX_BASE\n+#undef _GLIBCXX_STD_BASE\n+#define _GLIBCXX_STD_BASE _GLIBCXX_STD_D::_GLIBCXX_BASE\n+#define _GLIBCXX_BASE unordered_multiset<_Value, _Hash, _Pred, _Alloc>\n+\n+  template<typename _Value,\n+\t   typename _Hash  = std::hash<_Value>,\n+\t   typename _Pred = std::equal_to<_Value>,\n+\t   typename _Alloc =  std::allocator<_Value> >\n+    class unordered_multiset\n+    : public __gnu_debug::_Safe_association<_GLIBCXX_STD_BASE>,\n+      public __gnu_debug::_Safe_sequence<_GLIBCXX_BASE>\n+    {\n+      typedef typename _GLIBCXX_STD_BASE _Base;\n+      typedef __gnu_debug::_Safe_association<_Base> _Safe_assoc;\n+      typedef __gnu_debug::_Safe_sequence<unordered_multiset> _Safe_base;\n+\n+    public:\n+      typedef typename _Safe_assoc::size_type       size_type;\n+      typedef typename _Safe_assoc::hasher          hasher;\n+      typedef typename _Safe_assoc::key_equal       key_equal;\n+      typedef typename _Safe_assoc::allocator_type allocator_type;\n+\n+      explicit\n+      unordered_multiset(size_type __n = 10,\n+\t\t    const hasher& __hf = hasher(),\n+\t\t    const key_equal& __eql = key_equal(),\n+\t\t    const allocator_type& __a = allocator_type())\n+      : _Safe_assoc(__n, __hf, __eql, __a)\n+      { }\n+\n+      template<typename _InputIterator>\n+        unordered_multiset(_InputIterator __f, _InputIterator __l, \n+\t\t      size_type __n = 10,\n+\t\t      const hasher& __hf = hasher(), \n+\t\t      const key_equal& __eql = key_equal(), \n+\t\t      const allocator_type& __a = allocator_type())\n+\t: _Safe_assoc(__f, __l, __n, __hf, __eql, __a)\n+        { }\n+\n+      unordered_multiset(const _Safe_assoc& __x) \n+      : _Safe_assoc(__x), _Safe_base() { }\n+\n+      void\n+      swap(unordered_multiset& __x)\n+      {\n+\t_Safe_assoc::swap(__x);\n+\t_Safe_base::_M_swap(__x);\n+      }\n+    };\n+\n+  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+    inline bool\n+    operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_base() == __y._M_base(); }\n+\n+  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+    inline bool\n+    operator!=(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t       const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { return __x._M_base() != __y._M_base(); }\n+\n+  template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n+    inline void\n+    swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n+} // namespace __debug\n+} // namespace std\n+\n+#undef _GLIBCXX_BASE\n+#undef _GLIBCXX_STD_BASE\n+\n+#endif"}, {"sha": "e73b7df72c4fcdf6c4264838c5c6ab83d2c034d6", "filename": "libstdc++-v3/include/ext/hashtable.h", "status": "removed", "additions": 0, "deletions": 1130, "changes": 1130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,1130 +0,0 @@\n-// Hashtable implementation used by containers -*- C++ -*-\n-\n-// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007\n-// Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- */\n-\n-/** @file ext/hashtable.h\n- *  This file is a GNU extension to the Standard C++ Library (possibly\n- *  containing extensions from the HP/SGI STL subset).\n- */\n-\n-#ifndef _HASHTABLE_H\n-#define _HASHTABLE_H 1\n-\n-// Hashtable class, used to implement the hashed associative containers\n-// hash_set, hash_map, hash_multiset, and hash_multimap.\n-\n-#include <vector>\n-#include <iterator>\n-#include <algorithm>\n-#include <bits/stl_function.h>\n-#include <ext/hash_fun.h>\n-\n-_GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n-\n-  using std::size_t;\n-  using std::ptrdiff_t;\n-  using std::forward_iterator_tag;\n-  using std::input_iterator_tag;\n-  using std::_Construct;\n-  using std::_Destroy;\n-  using std::distance;\n-  using std::vector;\n-  using std::pair;\n-  using std::__iterator_category;\n-\n-  template<class _Val>\n-    struct _Hashtable_node\n-    {\n-      _Hashtable_node* _M_next;\n-      _Val _M_val;\n-    };\n-\n-  template<class _Val, class _Key, class _HashFcn, class _ExtractKey, \n-\t   class _EqualKey, class _Alloc = std::allocator<_Val> >\n-    class hashtable;\n-\n-  template<class _Val, class _Key, class _HashFcn,\n-\t   class _ExtractKey, class _EqualKey, class _Alloc>\n-    struct _Hashtable_iterator;\n-\n-  template<class _Val, class _Key, class _HashFcn,\n-\t   class _ExtractKey, class _EqualKey, class _Alloc>\n-    struct _Hashtable_const_iterator;\n-\n-  template<class _Val, class _Key, class _HashFcn,\n-\t   class _ExtractKey, class _EqualKey, class _Alloc>\n-    struct _Hashtable_iterator\n-    {\n-      typedef hashtable<_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc>\n-        _Hashtable;\n-      typedef _Hashtable_iterator<_Val, _Key, _HashFcn,\n-\t\t\t\t  _ExtractKey, _EqualKey, _Alloc>\n-        iterator;\n-      typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn,\n-\t\t\t\t\t_ExtractKey, _EqualKey, _Alloc>\n-        const_iterator;\n-      typedef _Hashtable_node<_Val> _Node;\n-      typedef forward_iterator_tag iterator_category;\n-      typedef _Val value_type;\n-      typedef ptrdiff_t difference_type;\n-      typedef size_t size_type;\n-      typedef _Val& reference;\n-      typedef _Val* pointer;\n-      \n-      _Node* _M_cur;\n-      _Hashtable* _M_ht;\n-\n-      _Hashtable_iterator(_Node* __n, _Hashtable* __tab)\n-      : _M_cur(__n), _M_ht(__tab) { }\n-\n-      _Hashtable_iterator() { }\n-\n-      reference\n-      operator*() const\n-      { return _M_cur->_M_val; }\n-\n-      pointer\n-      operator->() const\n-      { return &(operator*()); }\n-\n-      iterator&\n-      operator++();\n-\n-      iterator\n-      operator++(int);\n-\n-      bool\n-      operator==(const iterator& __it) const\n-      { return _M_cur == __it._M_cur; }\n-\n-      bool\n-      operator!=(const iterator& __it) const\n-      { return _M_cur != __it._M_cur; }\n-    };\n-\n-  template<class _Val, class _Key, class _HashFcn,\n-\t   class _ExtractKey, class _EqualKey, class _Alloc>\n-    struct _Hashtable_const_iterator\n-    {\n-      typedef hashtable<_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc>\n-        _Hashtable;\n-      typedef _Hashtable_iterator<_Val,_Key,_HashFcn,\n-\t\t\t\t  _ExtractKey,_EqualKey,_Alloc>\n-        iterator;\n-      typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn,\n-\t\t\t\t\t_ExtractKey, _EqualKey, _Alloc>\n-        const_iterator;\n-      typedef _Hashtable_node<_Val> _Node;\n-\n-      typedef forward_iterator_tag iterator_category;\n-      typedef _Val value_type;\n-      typedef ptrdiff_t difference_type;\n-      typedef size_t size_type;\n-      typedef const _Val& reference;\n-      typedef const _Val* pointer;\n-      \n-      const _Node* _M_cur;\n-      const _Hashtable* _M_ht;\n-\n-      _Hashtable_const_iterator(const _Node* __n, const _Hashtable* __tab)\n-      : _M_cur(__n), _M_ht(__tab) { }\n-\n-      _Hashtable_const_iterator() { }\n-\n-      _Hashtable_const_iterator(const iterator& __it)\n-      : _M_cur(__it._M_cur), _M_ht(__it._M_ht) { }\n-\n-      reference\n-      operator*() const\n-      { return _M_cur->_M_val; }\n-\n-      pointer\n-      operator->() const\n-      { return &(operator*()); }\n-\n-      const_iterator&\n-      operator++();\n-\n-      const_iterator\n-      operator++(int);\n-\n-      bool\n-      operator==(const const_iterator& __it) const\n-      { return _M_cur == __it._M_cur; }\n-\n-      bool\n-      operator!=(const const_iterator& __it) const\n-      { return _M_cur != __it._M_cur; }\n-    };\n-\n-  // Note: assumes long is at least 32 bits.\n-  enum { _S_num_primes = 28 };\n-\n-  static const unsigned long __stl_prime_list[_S_num_primes] =\n-    {\n-      53ul,         97ul,         193ul,       389ul,       769ul,\n-      1543ul,       3079ul,       6151ul,      12289ul,     24593ul,\n-      49157ul,      98317ul,      196613ul,    393241ul,    786433ul,\n-      1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,\n-      50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul,\n-      1610612741ul, 3221225473ul, 4294967291ul\n-    };\n-\n-  inline unsigned long\n-  __stl_next_prime(unsigned long __n)\n-  {\n-    const unsigned long* __first = __stl_prime_list;\n-    const unsigned long* __last = __stl_prime_list + (int)_S_num_primes;\n-    const unsigned long* pos = std::lower_bound(__first, __last, __n);\n-    return pos == __last ? *(__last - 1) : *pos;\n-  }\n-\n-  // Forward declaration of operator==.  \n-  template<class _Val, class _Key, class _HF, class _Ex,\n-\t   class _Eq, class _All>\n-    class hashtable;\n-\n-  template<class _Val, class _Key, class _HF, class _Ex,\n-\t   class _Eq, class _All>\n-    bool\n-    operator==(const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht1,\n-\t       const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht2);\n-\n-  // Hashtables handle allocators a bit differently than other\n-  // containers do.  If we're using standard-conforming allocators, then\n-  // a hashtable unconditionally has a member variable to hold its\n-  // allocator, even if it so happens that all instances of the\n-  // allocator type are identical.  This is because, for hashtables,\n-  // this extra storage is negligible.  Additionally, a base class\n-  // wouldn't serve any other purposes; it wouldn't, for example,\n-  // simplify the exception-handling code.  \n-  template<class _Val, class _Key, class _HashFcn,\n-\t   class _ExtractKey, class _EqualKey, class _Alloc>\n-    class hashtable\n-    {\n-    public:\n-      typedef _Key key_type;\n-      typedef _Val value_type;\n-      typedef _HashFcn hasher;\n-      typedef _EqualKey key_equal;\n-\n-      typedef size_t            size_type;\n-      typedef ptrdiff_t         difference_type;\n-      typedef value_type*       pointer;\n-      typedef const value_type* const_pointer;\n-      typedef value_type&       reference;\n-      typedef const value_type& const_reference;\n-\n-      hasher\n-      hash_funct() const\n-      { return _M_hash; }\n-\n-      key_equal\n-      key_eq() const\n-      { return _M_equals; }\n-\n-    private:\n-      typedef _Hashtable_node<_Val> _Node;\n-\n-    public:\n-      typedef typename _Alloc::template rebind<value_type>::other allocator_type;\n-      allocator_type\n-      get_allocator() const\n-      { return _M_node_allocator; }\n-\n-    private:\n-      typedef typename _Alloc::template rebind<_Node>::other _Node_Alloc;\n-      typedef typename _Alloc::template rebind<_Node*>::other _Nodeptr_Alloc;\n-      typedef vector<_Node*, _Nodeptr_Alloc> _Vector_type;\n-\n-      _Node_Alloc _M_node_allocator;\n-\n-      _Node*\n-      _M_get_node()\n-      { return _M_node_allocator.allocate(1); }\n-\n-      void\n-      _M_put_node(_Node* __p)\n-      { _M_node_allocator.deallocate(__p, 1); }\n-\n-    private:\n-      hasher                _M_hash;\n-      key_equal             _M_equals;\n-      _ExtractKey           _M_get_key;\n-      _Vector_type          _M_buckets;\n-      size_type             _M_num_elements;\n-      \n-    public:\n-      typedef _Hashtable_iterator<_Val, _Key, _HashFcn, _ExtractKey,\n-\t\t\t\t  _EqualKey, _Alloc>\n-        iterator;\n-      typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn, _ExtractKey,\n-\t\t\t\t\t_EqualKey, _Alloc>\n-        const_iterator;\n-\n-      friend struct\n-      _Hashtable_iterator<_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc>;\n-\n-      friend struct\n-      _Hashtable_const_iterator<_Val, _Key, _HashFcn, _ExtractKey,\n-\t\t\t\t_EqualKey, _Alloc>;\n-\n-    public:\n-      hashtable(size_type __n, const _HashFcn& __hf,\n-\t\tconst _EqualKey& __eql, const _ExtractKey& __ext,\n-\t\tconst allocator_type& __a = allocator_type())\n-      : _M_node_allocator(__a), _M_hash(__hf), _M_equals(__eql),\n-\t_M_get_key(__ext), _M_buckets(__a), _M_num_elements(0)\n-      { _M_initialize_buckets(__n); }\n-\n-      hashtable(size_type __n, const _HashFcn& __hf,\n-\t\tconst _EqualKey& __eql,\n-\t\tconst allocator_type& __a = allocator_type())\n-      : _M_node_allocator(__a), _M_hash(__hf), _M_equals(__eql),\n-\t_M_get_key(_ExtractKey()), _M_buckets(__a), _M_num_elements(0)\n-      { _M_initialize_buckets(__n); }\n-\n-      hashtable(const hashtable& __ht)\n-      : _M_node_allocator(__ht.get_allocator()), _M_hash(__ht._M_hash),\n-      _M_equals(__ht._M_equals), _M_get_key(__ht._M_get_key),\n-      _M_buckets(__ht.get_allocator()), _M_num_elements(0)\n-      { _M_copy_from(__ht); }\n-\n-      hashtable&\n-      operator= (const hashtable& __ht)\n-      {\n-\tif (&__ht != this)\n-\t  {\n-\t    clear();\n-\t    _M_hash = __ht._M_hash;\n-\t    _M_equals = __ht._M_equals;\n-\t    _M_get_key = __ht._M_get_key;\n-\t    _M_copy_from(__ht);\n-\t  }\n-\treturn *this;\n-      }\n-\n-      ~hashtable()\n-      { clear(); }\n-\n-      size_type\n-      size() const\n-      { return _M_num_elements; }\n-\n-      size_type\n-      max_size() const\n-      { return size_type(-1); }\n-\n-      bool\n-      empty() const\n-      { return size() == 0; }\n-\n-      void\n-      swap(hashtable& __ht)\n-      {\n-\tstd::swap(_M_hash, __ht._M_hash);\n-\tstd::swap(_M_equals, __ht._M_equals);\n-\tstd::swap(_M_get_key, __ht._M_get_key);\n-\t_M_buckets.swap(__ht._M_buckets);\n-\tstd::swap(_M_num_elements, __ht._M_num_elements);\n-      }\n-\n-      iterator\n-      begin()\n-      {\n-\tfor (size_type __n = 0; __n < _M_buckets.size(); ++__n)\n-\t  if (_M_buckets[__n])\n-\t    return iterator(_M_buckets[__n], this);\n-\treturn end();\n-      }\n-\n-      iterator\n-      end()\n-      { return iterator(0, this); }\n-\n-      const_iterator\n-      begin() const\n-      {\n-\tfor (size_type __n = 0; __n < _M_buckets.size(); ++__n)\n-\t  if (_M_buckets[__n])\n-\t    return const_iterator(_M_buckets[__n], this);\n-\treturn end();\n-      }\n-\n-      const_iterator\n-      end() const\n-      { return const_iterator(0, this); }\n-\n-      template<class _Vl, class _Ky, class _HF, class _Ex, class _Eq,\n-\t\tclass _Al>\n-        friend bool\n-        operator==(const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&,\n-\t\t   const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&);\n-\n-    public:\n-      size_type\n-      bucket_count() const\n-      { return _M_buckets.size(); }\n-\n-      size_type\n-      max_bucket_count() const\n-      { return __stl_prime_list[(int)_S_num_primes - 1]; }\n-\n-      size_type\n-      elems_in_bucket(size_type __bucket) const\n-      {\n-\tsize_type __result = 0;\n-\tfor (_Node* __n = _M_buckets[__bucket]; __n; __n = __n->_M_next)\n-\t  __result += 1;\n-\treturn __result;\n-      }\n-\n-      pair<iterator, bool>\n-      insert_unique(const value_type& __obj)\n-      {\n-\tresize(_M_num_elements + 1);\n-\treturn insert_unique_noresize(__obj);\n-      }\n-\n-      iterator\n-      insert_equal(const value_type& __obj)\n-      {\n-\tresize(_M_num_elements + 1);\n-\treturn insert_equal_noresize(__obj);\n-      }\n-\n-      pair<iterator, bool>\n-      insert_unique_noresize(const value_type& __obj);\n-\n-      iterator\n-      insert_equal_noresize(const value_type& __obj);\n-\n-      template<class _InputIterator>\n-        void\n-        insert_unique(_InputIterator __f, _InputIterator __l)\n-        { insert_unique(__f, __l, __iterator_category(__f)); }\n-\n-      template<class _InputIterator>\n-        void\n-        insert_equal(_InputIterator __f, _InputIterator __l)\n-        { insert_equal(__f, __l, __iterator_category(__f)); }\n-\n-      template<class _InputIterator>\n-        void\n-        insert_unique(_InputIterator __f, _InputIterator __l,\n-\t\t      input_iterator_tag)\n-        {\n-\t  for ( ; __f != __l; ++__f)\n-\t    insert_unique(*__f);\n-\t}\n-\n-      template<class _InputIterator>\n-        void\n-        insert_equal(_InputIterator __f, _InputIterator __l,\n-\t\t     input_iterator_tag)\n-        {\n-\t  for ( ; __f != __l; ++__f)\n-\t    insert_equal(*__f);\n-\t}\n-\n-      template<class _ForwardIterator>\n-        void\n-        insert_unique(_ForwardIterator __f, _ForwardIterator __l,\n-\t\t      forward_iterator_tag)\n-        {\n-\t  size_type __n = distance(__f, __l);\n-\t  resize(_M_num_elements + __n);\n-\t  for ( ; __n > 0; --__n, ++__f)\n-\t    insert_unique_noresize(*__f);\n-\t}\n-\n-      template<class _ForwardIterator>\n-        void\n-        insert_equal(_ForwardIterator __f, _ForwardIterator __l,\n-\t\t     forward_iterator_tag)\n-        {\n-\t  size_type __n = distance(__f, __l);\n-\t  resize(_M_num_elements + __n);\n-\t  for ( ; __n > 0; --__n, ++__f)\n-\t    insert_equal_noresize(*__f);\n-\t}\n-\n-      reference\n-      find_or_insert(const value_type& __obj);\n-\n-      iterator\n-      find(const key_type& __key)\n-      {\n-\tsize_type __n = _M_bkt_num_key(__key);\n-\t_Node* __first;\n-\tfor (__first = _M_buckets[__n];\n-\t     __first && !_M_equals(_M_get_key(__first->_M_val), __key);\n-\t     __first = __first->_M_next)\n-\t  { }\n-\treturn iterator(__first, this);\n-      }\n-\n-      const_iterator\n-      find(const key_type& __key) const\n-      {\n-\tsize_type __n = _M_bkt_num_key(__key);\n-\tconst _Node* __first;\n-\tfor (__first = _M_buckets[__n];\n-\t     __first && !_M_equals(_M_get_key(__first->_M_val), __key);\n-\t     __first = __first->_M_next)\n-\t  { }\n-\treturn const_iterator(__first, this);\n-      }\n-\n-      size_type\n-      count(const key_type& __key) const\n-      {\n-\tconst size_type __n = _M_bkt_num_key(__key);\n-\tsize_type __result = 0;\n-\t\n-\tfor (const _Node* __cur = _M_buckets[__n]; __cur;\n-\t     __cur = __cur->_M_next)\n-\t  if (_M_equals(_M_get_key(__cur->_M_val), __key))\n-\t    ++__result;\n-\treturn __result;\n-      }\n-\n-      pair<iterator, iterator>\n-      equal_range(const key_type& __key);\n-\n-      pair<const_iterator, const_iterator>\n-      equal_range(const key_type& __key) const;\n-\n-      size_type\n-      erase(const key_type& __key);\n-      \n-      void\n-      erase(const iterator& __it);\n-\n-      void\n-      erase(iterator __first, iterator __last);\n-\n-      void\n-      erase(const const_iterator& __it);\n-\n-      void\n-      erase(const_iterator __first, const_iterator __last);\n-\n-      void\n-      resize(size_type __num_elements_hint);\n-\n-      void\n-      clear();\n-\n-    private:\n-      size_type\n-      _M_next_size(size_type __n) const\n-      { return __stl_next_prime(__n); }\n-\n-      void\n-      _M_initialize_buckets(size_type __n)\n-      {\n-\tconst size_type __n_buckets = _M_next_size(__n);\n-\t_M_buckets.reserve(__n_buckets);\n-\t_M_buckets.insert(_M_buckets.end(), __n_buckets, (_Node*) 0);\n-\t_M_num_elements = 0;\n-      }\n-\n-      size_type\n-      _M_bkt_num_key(const key_type& __key) const\n-      { return _M_bkt_num_key(__key, _M_buckets.size()); }\n-\n-      size_type\n-      _M_bkt_num(const value_type& __obj) const\n-      { return _M_bkt_num_key(_M_get_key(__obj)); }\n-\n-      size_type\n-      _M_bkt_num_key(const key_type& __key, size_t __n) const\n-      { return _M_hash(__key) % __n; }\n-\n-      size_type\n-      _M_bkt_num(const value_type& __obj, size_t __n) const\n-      { return _M_bkt_num_key(_M_get_key(__obj), __n); }\n-\n-      _Node*\n-      _M_new_node(const value_type& __obj)\n-      {\n-\t_Node* __n = _M_get_node();\n-\t__n->_M_next = 0;\n-\ttry\n-\t  {\n-\t    this->get_allocator().construct(&__n->_M_val, __obj);\n-\t    return __n;\n-\t  }\n-\tcatch(...)\n-\t  {\n-\t    _M_put_node(__n);\n-\t    __throw_exception_again;\n-\t  }\n-      }\n-\n-      void\n-      _M_delete_node(_Node* __n)\n-      {\n-\tthis->get_allocator().destroy(&__n->_M_val);\n-\t_M_put_node(__n);\n-      }\n-      \n-      void\n-      _M_erase_bucket(const size_type __n, _Node* __first, _Node* __last);\n-\n-      void\n-      _M_erase_bucket(const size_type __n, _Node* __last);\n-\n-      void\n-      _M_copy_from(const hashtable& __ht);\n-    };\n-\n-  template<class _Val, class _Key, class _HF, class _ExK, class _EqK,\n-\t    class _All>\n-    _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>&\n-    _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n-    operator++()\n-    {\n-      const _Node* __old = _M_cur;\n-      _M_cur = _M_cur->_M_next;\n-      if (!_M_cur)\n-\t{\n-\t  size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);\n-\t  while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())\n-\t    _M_cur = _M_ht->_M_buckets[__bucket];\n-\t}\n-      return *this;\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _ExK, class _EqK,\n-\t    class _All>\n-    inline _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>\n-    _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n-    operator++(int)\n-    {\n-      iterator __tmp = *this;\n-      ++*this;\n-      return __tmp;\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _ExK, class _EqK,\n-\t    class _All>\n-    _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>&\n-    _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n-    operator++()\n-    {\n-      const _Node* __old = _M_cur;\n-      _M_cur = _M_cur->_M_next;\n-      if (!_M_cur)\n-\t{\n-\t  size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);\n-\t  while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())\n-\t    _M_cur = _M_ht->_M_buckets[__bucket];\n-\t}\n-      return *this;\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _ExK, class _EqK,\n-\t    class _All>\n-    inline _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>\n-    _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n-    operator++(int)\n-    {\n-      const_iterator __tmp = *this;\n-      ++*this;\n-      return __tmp;\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    bool\n-    operator==(const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht1,\n-\t       const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht2)\n-    {\n-      typedef typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::_Node _Node;\n-\n-      if (__ht1._M_buckets.size() != __ht2._M_buckets.size())\n-\treturn false;\n-\n-      for (size_t __n = 0; __n < __ht1._M_buckets.size(); ++__n)\n-\t{\n-\t  _Node* __cur1 = __ht1._M_buckets[__n];\n-\t  _Node* __cur2 = __ht2._M_buckets[__n];\n-\t  // Check same length of lists\n-\t  for (; __cur1 && __cur2;\n-\t       __cur1 = __cur1->_M_next, __cur2 = __cur2->_M_next)\n-\t    { } \n-\t  if (__cur1 || __cur2)\n-\t    return false;\n-\t  // Now check one's elements are in the other\n-\t  for (__cur1 = __ht1._M_buckets[__n] ; __cur1;\n-\t       __cur1 = __cur1->_M_next)\n-\t    {\n-\t      bool _found__cur1 = false;\n-\t      for (__cur2 = __ht2._M_buckets[__n];\n-\t\t   __cur2; __cur2 = __cur2->_M_next)\n-\t\t{\n-\t\t  if (__cur1->_M_val == __cur2->_M_val)\n-\t\t    {\n-\t\t      _found__cur1 = true;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t      if (!_found__cur1)\n-\t\treturn false;\n-\t    }\n-\t}\n-      return true;\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    inline bool\n-    operator!=(const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht1,\n-\t       const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht2)\n-    { return !(__ht1 == __ht2); }\n-\n-  template<class _Val, class _Key, class _HF, class _Extract, class _EqKey,\n-\t    class _All>\n-    inline void\n-    swap(hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht1,\n-\t hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht2)\n-    { __ht1.swap(__ht2); }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    pair<typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator, bool>\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    insert_unique_noresize(const value_type& __obj)\n-    {\n-      const size_type __n = _M_bkt_num(__obj);\n-      _Node* __first = _M_buckets[__n];\n-      \n-      for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n-\tif (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n-\t  return pair<iterator, bool>(iterator(__cur, this), false);\n-      \n-      _Node* __tmp = _M_new_node(__obj);\n-      __tmp->_M_next = __first;\n-      _M_buckets[__n] = __tmp;\n-      ++_M_num_elements;\n-      return pair<iterator, bool>(iterator(__tmp, this), true);\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    insert_equal_noresize(const value_type& __obj)\n-    {\n-      const size_type __n = _M_bkt_num(__obj);\n-      _Node* __first = _M_buckets[__n];\n-      \n-      for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n-\tif (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n-\t  {\n-\t    _Node* __tmp = _M_new_node(__obj);\n-\t    __tmp->_M_next = __cur->_M_next;\n-\t    __cur->_M_next = __tmp;\n-\t    ++_M_num_elements;\n-\t    return iterator(__tmp, this);\n-\t  }\n-\n-      _Node* __tmp = _M_new_node(__obj);\n-      __tmp->_M_next = __first;\n-      _M_buckets[__n] = __tmp;\n-      ++_M_num_elements;\n-      return iterator(__tmp, this);\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::reference\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    find_or_insert(const value_type& __obj)\n-    {\n-      resize(_M_num_elements + 1);\n-\n-      size_type __n = _M_bkt_num(__obj);\n-      _Node* __first = _M_buckets[__n];\n-      \n-      for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n-\tif (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n-\t  return __cur->_M_val;\n-      \n-      _Node* __tmp = _M_new_node(__obj);\n-      __tmp->_M_next = __first;\n-      _M_buckets[__n] = __tmp;\n-      ++_M_num_elements;\n-      return __tmp->_M_val;\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    pair<typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator,\n-\t typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator>\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    equal_range(const key_type& __key)\n-    {\n-      typedef pair<iterator, iterator> _Pii;\n-      const size_type __n = _M_bkt_num_key(__key);\n-\n-      for (_Node* __first = _M_buckets[__n]; __first;\n-\t   __first = __first->_M_next)\n-\tif (_M_equals(_M_get_key(__first->_M_val), __key))\n-\t  {\n-\t    for (_Node* __cur = __first->_M_next; __cur;\n-\t\t __cur = __cur->_M_next)\n-\t      if (!_M_equals(_M_get_key(__cur->_M_val), __key))\n-\t\treturn _Pii(iterator(__first, this), iterator(__cur, this));\n-\t    for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)\n-\t      if (_M_buckets[__m])\n-\t\treturn _Pii(iterator(__first, this),\n-\t\t\t    iterator(_M_buckets[__m], this));\n-\t    return _Pii(iterator(__first, this), end());\n-\t  }\n-      return _Pii(end(), end());\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    pair<typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::const_iterator,\n-\t typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::const_iterator>\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    equal_range(const key_type& __key) const\n-    {\n-      typedef pair<const_iterator, const_iterator> _Pii;\n-      const size_type __n = _M_bkt_num_key(__key);\n-\n-      for (const _Node* __first = _M_buckets[__n]; __first;\n-\t   __first = __first->_M_next)\n-\t{\n-\t  if (_M_equals(_M_get_key(__first->_M_val), __key))\n-\t    {\n-\t      for (const _Node* __cur = __first->_M_next; __cur;\n-\t\t   __cur = __cur->_M_next)\n-\t\tif (!_M_equals(_M_get_key(__cur->_M_val), __key))\n-\t\t  return _Pii(const_iterator(__first, this),\n-\t\t\t      const_iterator(__cur, this));\n-\t      for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)\n-\t\tif (_M_buckets[__m])\n-\t\t  return _Pii(const_iterator(__first, this),\n-\t\t\t      const_iterator(_M_buckets[__m], this));\n-\t      return _Pii(const_iterator(__first, this), end());\n-\t    }\n-\t}\n-      return _Pii(end(), end());\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::size_type\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    erase(const key_type& __key)\n-    {\n-      const size_type __n = _M_bkt_num_key(__key);\n-      _Node* __first = _M_buckets[__n];\n-      size_type __erased = 0;\n-      \n-      if (__first)\n-\t{\n-\t  _Node* __cur = __first;\n-\t  _Node* __next = __cur->_M_next;\n-\t  while (__next)\n-\t    {\n-\t      if (_M_equals(_M_get_key(__next->_M_val), __key))\n-\t\t{\n-\t\t  __cur->_M_next = __next->_M_next;\n-\t\t  _M_delete_node(__next);\n-\t\t  __next = __cur->_M_next;\n-\t\t  ++__erased;\n-\t\t  --_M_num_elements;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  __cur = __next;\n-\t\t  __next = __cur->_M_next;\n-\t\t}\n-\t    }\n-\t  if (_M_equals(_M_get_key(__first->_M_val), __key))\n-\t    {\n-\t      _M_buckets[__n] = __first->_M_next;\n-\t      _M_delete_node(__first);\n-\t      ++__erased;\n-\t      --_M_num_elements;\n-\t    }\n-\t}\n-      return __erased;\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    void hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    erase(const iterator& __it)\n-    {\n-      _Node* __p = __it._M_cur;\n-      if (__p)\n-\t{\n-\t  const size_type __n = _M_bkt_num(__p->_M_val);\n-\t  _Node* __cur = _M_buckets[__n];\n-\t  \n-\t  if (__cur == __p)\n-\t    {\n-\t      _M_buckets[__n] = __cur->_M_next;\n-\t      _M_delete_node(__cur);\n-\t      --_M_num_elements;\n-\t    }\n-\t  else\n-\t    {\n-\t      _Node* __next = __cur->_M_next;\n-\t      while (__next)\n-\t\t{\n-\t\t  if (__next == __p)\n-\t\t    {\n-\t\t      __cur->_M_next = __next->_M_next;\n-\t\t      _M_delete_node(__next);\n-\t\t      --_M_num_elements;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      __cur = __next;\n-\t\t      __next = __cur->_M_next;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    void\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    erase(iterator __first, iterator __last)\n-    {\n-      size_type __f_bucket = __first._M_cur ? _M_bkt_num(__first._M_cur->_M_val)\n-\t                                    : _M_buckets.size();\n-\n-      size_type __l_bucket = __last._M_cur ? _M_bkt_num(__last._M_cur->_M_val)\n-\t                                   : _M_buckets.size();\n-\n-      if (__first._M_cur == __last._M_cur)\n-\treturn;\n-      else if (__f_bucket == __l_bucket)\n-\t_M_erase_bucket(__f_bucket, __first._M_cur, __last._M_cur);\n-      else\n-\t{\n-\t  _M_erase_bucket(__f_bucket, __first._M_cur, 0);\n-\t  for (size_type __n = __f_bucket + 1; __n < __l_bucket; ++__n)\n-\t    _M_erase_bucket(__n, 0);\n-\t  if (__l_bucket != _M_buckets.size())\n-\t    _M_erase_bucket(__l_bucket, __last._M_cur);\n-\t}\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    inline void\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    erase(const_iterator __first, const_iterator __last)\n-    {\n-      erase(iterator(const_cast<_Node*>(__first._M_cur),\n-\t\t     const_cast<hashtable*>(__first._M_ht)),\n-\t    iterator(const_cast<_Node*>(__last._M_cur),\n-\t\t     const_cast<hashtable*>(__last._M_ht)));\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    inline void\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    erase(const const_iterator& __it)\n-    { erase(iterator(const_cast<_Node*>(__it._M_cur),\n-\t\t     const_cast<hashtable*>(__it._M_ht))); }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    void\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    resize(size_type __num_elements_hint)\n-    {\n-      const size_type __old_n = _M_buckets.size();\n-      if (__num_elements_hint > __old_n)\n-\t{\n-\t  const size_type __n = _M_next_size(__num_elements_hint);\n-\t  if (__n > __old_n)\n-\t    {\n-\t      _Vector_type __tmp(__n, (_Node*)(0), _M_buckets.get_allocator());\n-\t      try\n-\t\t{\n-\t\t  for (size_type __bucket = 0; __bucket < __old_n; ++__bucket)\n-\t\t    {\n-\t\t      _Node* __first = _M_buckets[__bucket];\n-\t\t      while (__first)\n-\t\t\t{\n-\t\t\t  size_type __new_bucket = _M_bkt_num(__first->_M_val,\n-\t\t\t\t\t\t\t      __n);\n-\t\t\t  _M_buckets[__bucket] = __first->_M_next;\n-\t\t\t  __first->_M_next = __tmp[__new_bucket];\n-\t\t\t  __tmp[__new_bucket] = __first;\n-\t\t\t  __first = _M_buckets[__bucket];\n-\t\t\t}\n-\t\t    }\n-\t\t  _M_buckets.swap(__tmp);\n-\t\t}\n-\t      catch(...)\n-\t\t{\n-\t\t  for (size_type __bucket = 0; __bucket < __tmp.size();\n-\t\t       ++__bucket)\n-\t\t    {\n-\t\t      while (__tmp[__bucket])\n-\t\t\t{\n-\t\t\t  _Node* __next = __tmp[__bucket]->_M_next;\n-\t\t\t  _M_delete_node(__tmp[__bucket]);\n-\t\t\t  __tmp[__bucket] = __next;\n-\t\t\t}\n-\t\t    }\n-\t\t  __throw_exception_again;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    void\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    _M_erase_bucket(const size_type __n, _Node* __first, _Node* __last)\n-    {\n-      _Node* __cur = _M_buckets[__n];\n-      if (__cur == __first)\n-\t_M_erase_bucket(__n, __last);\n-      else\n-\t{\n-\t  _Node* __next;\n-\t  for (__next = __cur->_M_next;\n-\t       __next != __first;\n-\t       __cur = __next, __next = __cur->_M_next)\n-\t    ;\n-\t  while (__next != __last)\n-\t    {\n-\t      __cur->_M_next = __next->_M_next;\n-\t      _M_delete_node(__next);\n-\t      __next = __cur->_M_next;\n-\t      --_M_num_elements;\n-\t    }\n-\t}\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    void\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    _M_erase_bucket(const size_type __n, _Node* __last)\n-    {\n-      _Node* __cur = _M_buckets[__n];\n-      while (__cur != __last)\n-\t{\n-\t  _Node* __next = __cur->_M_next;\n-\t  _M_delete_node(__cur);\n-\t  __cur = __next;\n-\t  _M_buckets[__n] = __cur;\n-\t  --_M_num_elements;\n-\t}\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    void\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    clear()\n-    {\n-      for (size_type __i = 0; __i < _M_buckets.size(); ++__i)\n-\t{\n-\t  _Node* __cur = _M_buckets[__i];\n-\t  while (__cur != 0)\n-\t    {\n-\t      _Node* __next = __cur->_M_next;\n-\t      _M_delete_node(__cur);\n-\t      __cur = __next;\n-\t    }\n-\t  _M_buckets[__i] = 0;\n-\t}\n-      _M_num_elements = 0;\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    void\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    _M_copy_from(const hashtable& __ht)\n-    {\n-      _M_buckets.clear();\n-      _M_buckets.reserve(__ht._M_buckets.size());\n-      _M_buckets.insert(_M_buckets.end(), __ht._M_buckets.size(), (_Node*) 0);\n-      try\n-\t{\n-\t  for (size_type __i = 0; __i < __ht._M_buckets.size(); ++__i) {\n-\t    const _Node* __cur = __ht._M_buckets[__i];\n-\t    if (__cur)\n-\t      {\n-\t\t_Node* __local_copy = _M_new_node(__cur->_M_val);\n-\t\t_M_buckets[__i] = __local_copy;\n-\t\t\n-\t\tfor (_Node* __next = __cur->_M_next;\n-\t\t     __next;\n-\t\t     __cur = __next, __next = __cur->_M_next)\n-\t\t  {\n-\t\t    __local_copy->_M_next = _M_new_node(__next->_M_val);\n-\t\t    __local_copy = __local_copy->_M_next;\n-\t\t  }\n-\t      }\n-\t  }\n-\t  _M_num_elements = __ht._M_num_elements;\n-\t}\n-      catch(...)\n-\t{\n-\t  clear();\n-\t  __throw_exception_again;\n-\t}\n-    }\n-\n-_GLIBCXX_END_NAMESPACE\n-\n-#endif"}, {"sha": "3e3dcf75eb3606e647000cc555c78cf5c5545ebb", "filename": "libstdc++-v3/include/std/unordered_map", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -58,9 +58,15 @@\n #  include <tr1_impl/unordered_map>\n #else\n #  define _GLIBCXX_INCLUDE_AS_CXX0X\n+#if _GLIBCXX_DEBUG\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace _GLIBCXX_STD_D {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 _GLIBCXX_STD_D\n+#else\n #  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n #  define _GLIBCXX_END_NAMESPACE_TR1\n-#  define _GLIBCXX_TR1\n+#  define _GLIBCXX_TR1 \n+#endif\n #  include <tr1_impl/unordered_map>\n #  undef _GLIBCXX_TR1\n #  undef _GLIBCXX_END_NAMESPACE_TR1"}, {"sha": "daa64cd4a8e3169323e6f03f766601c637e34a5e", "filename": "libstdc++-v3/include/std/unordered_set", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -58,14 +58,24 @@\n #  include <tr1_impl/unordered_set>\n #else\n #  define _GLIBCXX_INCLUDE_AS_CXX0X\n+#if _GLIBCXX_DEBUG\n+#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace _GLIBCXX_STD_D {\n+#  define _GLIBCXX_END_NAMESPACE_TR1 }\n+#  define _GLIBCXX_TR1 _GLIBCXX_STD_D\n+#else\n #  define _GLIBCXX_BEGIN_NAMESPACE_TR1\n #  define _GLIBCXX_END_NAMESPACE_TR1\n-#  define _GLIBCXX_TR1\n+#  define _GLIBCXX_TR1 \n+#endif\n #  include <tr1_impl/unordered_set>\n #  undef _GLIBCXX_TR1\n #  undef _GLIBCXX_END_NAMESPACE_TR1\n #  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n #  undef _GLIBCXX_INCLUDE_AS_CXX0X\n #endif\n \n+#ifdef _GLIBCXX_DEBUG\n+# include <debug/unordered_set>\n+#endif\n+\n #endif // _GLIBCXX_UNORDERED_SET"}, {"sha": "a880bdc57a8596a65b56cded90e76e810ee835a1", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/requirements/debug.cc", "status": "renamed", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Frequirements%2Fdebug.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Frequirements%2Fdebug.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Frequirements%2Fdebug.cc?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -1,6 +1,7 @@\n-// 2001-09-20 Peter Schmid  <schmid@snake.iap.physik.tu-darmstadt.de>\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -18,14 +19,21 @@\n // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n // USA.\n \n-// backward header deque.h\n+#include <string>\n+#include <debug/unordered_map>\n \n-#include <deque.h>\n-#include <testsuite_hooks.h>\n+using namespace __gnu_debug;\n \n-// { dg-options \"-Wno-deprecated\" }\n+using std::allocator;\n+using std::equal_to;\n+using std::hash;\n+using std::pair;\n+using std::string;\n \n-int main(void)\n-{\n-  return 0;\n-}\n+template class unordered_map<string, float>;\n+template class unordered_map<string, int,\n+\t\t\t     hash<string>, equal_to<string>, \n+\t\t\t     allocator<pair<const string, int> > >;\n+template class unordered_map<string, float,\n+\t\t\t     hash<string>, equal_to<string>, \n+\t\t\t     allocator<char> >;", "previous_filename": "libstdc++-v3/testsuite/backward/header_deque_h.cc"}, {"sha": "fe2b9af4e131e3408a58164166e0e27f2063a753", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/requirements/debug.cc", "status": "renamed", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Frequirements%2Fdebug.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Frequirements%2Fdebug.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Frequirements%2Fdebug.cc?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -1,6 +1,7 @@\n-//  2002-03-15  Philipp Thomas  <pthomas@suse.de>\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -18,14 +19,11 @@\n // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n // USA.\n \n-// backward header hashtable.h\n+#include <string>\n+#include <debug/unordered_map>\n \n-#include <hashtable.h>\n-#include <testsuite_hooks.h>\n+using namespace __gnu_debug;\n \n-// { dg-options \"-Wno-deprecated\" }\n+using std::string;\n \n-int main(void)\n-{\n-  return 0;\n-}\n+template class unordered_multimap<string, float>;", "previous_filename": "libstdc++-v3/testsuite/backward/header_hashtable_h.cc"}, {"sha": "3d09ef6e55143cbdcad92f348c37355990c4e695", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/requirements/debug.cc", "status": "renamed", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Frequirements%2Fdebug.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Frequirements%2Fdebug.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Frequirements%2Fdebug.cc?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -1,6 +1,7 @@\n-//  2002-03-15  Philipp Thomas  <pthomas@suse.de>\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -18,14 +19,9 @@\n // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n // USA.\n \n-// backward header rope.h\n+#include <string>\n+#include <debug/unordered_set>\n \n-#include <rope.h>\n-#include <testsuite_hooks.h>\n+using namespace __gnu_debug;\n \n-// { dg-options \"-Wno-deprecated\" }\n-\n-int main(void)\n-{\n-  return 0;\n-}\n+template class unordered_multiset<int>;", "previous_filename": "libstdc++-v3/testsuite/backward/header_rope_h.cc"}, {"sha": "2894dff0edbe8d9a682bf5032ef6bd47f9db7e5e", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/requirements/debug.cc", "status": "renamed", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Frequirements%2Fdebug.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Frequirements%2Fdebug.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Frequirements%2Fdebug.cc?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -1,31 +1,26 @@\n-//  2002-03-15  Philipp Thomas  <pthomas@suse.de>\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n // terms of the GNU General Public License as published by the\n // Free Software Foundation; either version 2, or (at your option)\n // any later version.\n-\n+//\n // This library is distributed in the hope that it will be useful,\n // but WITHOUT ANY WARRANTY; without even the implied warranty of\n // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n // GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA.\n \n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// backward header slist.h\n-\n-#include <slist.h>\n-#include <testsuite_hooks.h>\n+#include <debug/unordered_set>\n \n-// { dg-options \"-Wno-deprecated\" }\n+using namespace __gnu_debug;\n \n-int main(void)\n-{\n-  return 0;\n-}\n+template class unordered_set<int>;", "previous_filename": "libstdc++-v3/testsuite/backward/header_slist_h.cc"}, {"sha": "faa97d6f2657ea935c93689b0bb6f69d4be2803a", "filename": "libstdc++-v3/testsuite/backward/hash_map/1.cc", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_map%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_map%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_map%2F1.cc?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -1,4 +1,6 @@\n-// Copyright (C) 2002, 2005 Free Software Foundation, Inc.\n+// { dg-options \"-Wno-deprecated\" }\n+\n+// Copyright (C) 2002, 2005, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -20,7 +22,7 @@\n \n #include <cstdlib>\n #include <string>\n-#include <ext/hash_map>\n+#include <hash_map>\n #include <testsuite_hooks.h>\n \n namespace __gnu_cxx ", "previous_filename": "libstdc++-v3/testsuite/ext/hash_map/1.cc"}, {"sha": "8c73b2d790d5f9e4e700039146c566adc97bf1cc", "filename": "libstdc++-v3/testsuite/backward/hash_map/14648.cc", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_map%2F14648.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_map%2F14648.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_map%2F14648.cc?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -1,4 +1,6 @@\n-// Copyright (C) 2004, 2005 Free Software Foundation\n+// { dg-options \"-Wno-deprecated\" }\n+\n+// Copyright (C) 2004, 2005, 2007 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -17,7 +19,7 @@\n // USA.\n \n #include <iostream>\n-#include <ext/hash_map> \n+#include <hash_map> \n #include <ext/rope> \n \n // libstdc++/14648", "previous_filename": "libstdc++-v3/testsuite/ext/hash_map/14648.cc"}, {"sha": "42908eb3134ee8fc72a863cc8f3bf95e3a515666", "filename": "libstdc++-v3/testsuite/backward/hash_map/23528.cc", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_map%2F23528.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_map%2F23528.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_map%2F23528.cc?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -1,3 +1,6 @@\n+// { dg-options \"-Wno-deprecated\" }\n+// { dg-do compile }\n+\n // Copyright (C) 2005 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -16,9 +19,7 @@\n // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n // USA.\n \n-// { dg-do compile }\n-\n-#include <ext/hash_map>\n+#include <hash_map>\n \n // libstdc++/23528\n void test01()", "previous_filename": "libstdc++-v3/testsuite/ext/hash_map/23528.cc"}, {"sha": "84df423ea616f136a796a5df25bc5c3981da462d", "filename": "libstdc++-v3/testsuite/backward/hash_map/requirements/explicit_instantiation.cc", "status": "renamed", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_map%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_map%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_map%2Frequirements%2Fexplicit_instantiation.cc?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -1,4 +1,7 @@\n-// Copyright (C) 2004 Free Software Foundation, Inc.\n+// { dg-options \"-Wno-deprecated\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2004, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -27,8 +30,6 @@\n \n // This file tests explicit instantiation of library containers\n \n-#include <ext/hash_map>\n-\n-// { dg-do compile }\n+#include <hash_map>\n \n template class __gnu_cxx::hash_map<int, char>;", "previous_filename": "libstdc++-v3/testsuite/ext/hash_map/requirements/explicit_instantiation.cc"}, {"sha": "b54f022b25744633071a24c702bc8f2bc09f9000", "filename": "libstdc++-v3/testsuite/backward/hash_set/1.cc", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_set%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_set%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_set%2F1.cc?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -1,7 +1,9 @@\n+// { dg-options \"-Wno-deprecated\" }\n+\n // 2002-04-28  Paolo Carlini  <pcarlini@unitus.it>\n //             Peter Schmid  <schmid@snake.iap.physik.tu-darmstadt.de>\n \n-// Copyright (C) 2002, 2004, 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2002, 2004, 2005, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -21,7 +23,7 @@\n \n // hash_set (SGI extension)\n \n-#include <ext/hash_set>\n+#include <hash_set>\n \n void\n test01()", "previous_filename": "libstdc++-v3/testsuite/ext/hash_set/1.cc"}, {"sha": "0e9a37569937bb6ab6dd2d615459854516dff036", "filename": "libstdc++-v3/testsuite/backward/hash_set/check_construct_destroy.cc", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_set%2Fcheck_construct_destroy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_set%2Fcheck_construct_destroy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_set%2Fcheck_construct_destroy.cc?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -1,6 +1,8 @@\n+// { dg-options \"-Wno-deprecated\" }\n+\n // 2004-07-26  Matt Austern  <austern@apple.com>\n //\n-// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2003, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -27,7 +29,7 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-#include <ext/hash_set>\n+#include <hash_set>\n #include <functional>\n #include <iterator>\n #include <testsuite_allocator.h>", "previous_filename": "libstdc++-v3/testsuite/ext/hash_set/check_construct_destroy.cc"}, {"sha": "8d01bae374f8523e05ff4ba7918bf58cf9e16d5a", "filename": "libstdc++-v3/testsuite/backward/hash_set/requirements/explicit_instantiation.cc", "status": "renamed", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_set%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_set%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_set%2Frequirements%2Fexplicit_instantiation.cc?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -1,4 +1,7 @@\n-// Copyright (C) 2004 Free Software Foundation, Inc.\n+// { dg-options \"-Wno-deprecated\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2004, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -27,8 +30,6 @@\n \n // This file tests explicit instantiation of library containers\n \n-#include <ext/hash_set>\n-\n-// { dg-do compile }\n+#include <hash_set>\n \n template class __gnu_cxx::hash_set<int>;", "previous_filename": "libstdc++-v3/testsuite/ext/hash_set/requirements/explicit_instantiation.cc"}, {"sha": "cede092eeb4dd9be7be3e1ba31889cc2339ce87a", "filename": "libstdc++-v3/testsuite/backward/header_hash_map_h.cc", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fheader_hash_map_h.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fheader_hash_map_h.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fheader_hash_map_h.cc?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,31 +0,0 @@\n-//  2002-03-15  Philipp Thomas  <pthomas@suse.de>\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// backward header hash_map.h\n-\n-#include <hash_map.h>\n-#include <testsuite_hooks.h>\n-\n-// { dg-options \"-Wno-deprecated\" }\n-\n-int main(void)\n-{\n-  return 0;\n-}"}, {"sha": "7d32b03ed895546c6a7fb76439cd377931e0bede", "filename": "libstdc++-v3/testsuite/backward/header_hash_set_h.cc", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fheader_hash_set_h.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fheader_hash_set_h.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fheader_hash_set_h.cc?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,31 +0,0 @@\n-//  2002-03-15  Philipp Thomas  <pthomas@suse.de>\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// backward header hash_set.h\n-\n-#include <hash_set.h>\n-#include <testsuite_hooks.h>\n-\n-// { dg-options \"-Wno-deprecated\" }\n-\n-int main(void)\n-{\n-  return 0;\n-}"}, {"sha": "4f301bbb5ffc5f6ef6887cab3cf1ceb95fddc930", "filename": "libstdc++-v3/testsuite/backward/header_iterator_h.cc", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fheader_iterator_h.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fheader_iterator_h.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fheader_iterator_h.cc?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,31 +0,0 @@\n-// 2001-09-04 Peter Schmid  <schmid@snake.iap.physik.tu-darmstadt.de>\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// backward header iterator.h\n-\n-#include <iterator.h>\n-#include <testsuite_hooks.h>\n-\n-// { dg-options \"-Wno-deprecated\" }\n-\n-int main(void)\n-{\n-  return 0;\n-}"}, {"sha": "4b177b2ac5a4680c754dd521644fd45077f40d83", "filename": "libstdc++-v3/testsuite/backward/header_tempbuf_h.cc", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fheader_tempbuf_h.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e445a2ff978362e261a74f26fe5e06d539ed893b/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fheader_tempbuf_h.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fheader_tempbuf_h.cc?ref=e445a2ff978362e261a74f26fe5e06d539ed893b", "patch": "@@ -1,31 +0,0 @@\n-//  2002-03-15  Philipp Thomas  <pthomas@suse.de>\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// backward header tempbuf.h\n-\n-#include <tempbuf.h>\n-#include <testsuite_hooks.h>\n-\n-// { dg-options \"-Wno-deprecated\" }\n-\n-int main(void)\n-{\n-  return 0;\n-}"}, {"sha": "a3f82ba8a75b405a629ba7c25bde65a6910c915f", "filename": "libstdc++-v3/testsuite/util/native_type/assoc/native_hash_multimap.hpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fassoc%2Fnative_hash_multimap.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63637ea90863f9e06bda21f80c4c4c49d99c9ce/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fassoc%2Fnative_hash_multimap.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fnative_type%2Fassoc%2Fnative_hash_multimap.hpp?ref=e63637ea90863f9e06bda21f80c4c4c49d99c9ce", "patch": "@@ -49,7 +49,6 @@\n \n #include <string>\n #include <tr1/unordered_map>\n-#include <ext/hash_map>\n #include <ext/pb_ds/detail/type_utils.hpp>\n #include <ext/pb_ds/detail/standard_policies.hpp>\n #include <native_type/assoc/native_hash_tag.hpp>"}]}