{"sha": "e0f261f1aea2c9968a07442ca5d4eab813f86a58", "node_id": "C_kwDOANBUbNoAKGUwZjI2MWYxYWVhMmM5OTY4YTA3NDQyY2E1ZDRlYWI4MTNmODZhNTg", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-02-22T16:25:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-22T16:25:07Z"}, "message": "Merge #953\n\n953: Refactor lang item mappings r=philberty a=philberty\n\nThis refactors how we find our lang items so that during HIR lowering\r\nwe have a generic outer attributes handler on Items. The old code only\r\ndone lang item mappings during the type check pass and assumed all\r\nlang items are Traits which is not the case. To implement slices range\r\nsyntax actually map to structs within libcore/ops/range.rs which have\r\nlang items on structs. This means we can have lang items on any Item.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "54781829b4dbe2aa0371562c6eb05cdaf375e4c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54781829b4dbe2aa0371562c6eb05cdaf375e4c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0f261f1aea2c9968a07442ca5d4eab813f86a58", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiFQ5jCRBK7hj4Ov3rIwAAq9sIAF1f/y+Ql+8rhq6DvSCcvSov\nDQJx64/x8L2whMyrgHGp4fW4GRZ1BpXjlGB7Z05SDtjzZlkM9MVGN+UJq2zylU6H\n8/+QstqISBx/+YyOQNkyjbhYVJtGyOKXnwmL7CItMA7qJf5+kFgLtvthiuG+yME+\n32HTgQ+MoFmm5N9Co6/UBZAQIi3rFH3bImBYcnXNiz0EpAj7czDgw7D0ETJv0328\nP4joFIXR7w2a4l3GdaHWXS5BTIUzbDqOg6PqrjwLLloGHjpY0DgbZpV+UaEhjI/p\neythBYNSXoZFmw1KjhTl7U86SbG7fefj6nUc3LqexEDl8/P0RNU19ghCsl8mWS0=\n=GDs5\n-----END PGP SIGNATURE-----\n", "payload": "tree 54781829b4dbe2aa0371562c6eb05cdaf375e4c6\nparent 265c223766f1f4525558d086ccc46bd49f7b26e0\nparent 865aa0aeb5652f7f467f29132538ab9504dcc44d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1645547107 +0000\ncommitter GitHub <noreply@github.com> 1645547107 +0000\n\nMerge #953\n\n953: Refactor lang item mappings r=philberty a=philberty\n\nThis refactors how we find our lang items so that during HIR lowering\r\nwe have a generic outer attributes handler on Items. The old code only\r\ndone lang item mappings during the type check pass and assumed all\r\nlang items are Traits which is not the case. To implement slices range\r\nsyntax actually map to structs within libcore/ops/range.rs which have\r\nlang items on structs. This means we can have lang items on any Item.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0f261f1aea2c9968a07442ca5d4eab813f86a58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0f261f1aea2c9968a07442ca5d4eab813f86a58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0f261f1aea2c9968a07442ca5d4eab813f86a58/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "265c223766f1f4525558d086ccc46bd49f7b26e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/265c223766f1f4525558d086ccc46bd49f7b26e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/265c223766f1f4525558d086ccc46bd49f7b26e0"}, {"sha": "865aa0aeb5652f7f467f29132538ab9504dcc44d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/865aa0aeb5652f7f467f29132538ab9504dcc44d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/865aa0aeb5652f7f467f29132538ab9504dcc44d"}], "stats": {"total": 846, "additions": 551, "deletions": 295}, "files": [{"sha": "080b9dd8db3180e3b77b3663411f543250e4fc85", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f261f1aea2c9968a07442ca5d4eab813f86a58/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f261f1aea2c9968a07442ca5d4eab813f86a58/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=e0f261f1aea2c9968a07442ca5d4eab813f86a58", "patch": "@@ -77,6 +77,7 @@ GRS_OBJS = \\\n     rust/rust-macro-invoc-lexer.o \\\n     rust/rust-hir-full-test.o \\\n     rust/rust-hir-map.o \\\n+    rust/rust-attributes.o \\\n     rust/rust-abi.o \\\n     rust/rust-ast-lower.o \\\n     rust/rust-ast-lower-pattern.o \\"}, {"sha": "9eb9300cd6e956110af8efa50bdf99e5fb52393f", "filename": "gcc/rust/hir/rust-ast-lower-base.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f261f1aea2c9968a07442ca5d4eab813f86a58/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f261f1aea2c9968a07442ca5d4eab813f86a58/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h?ref=e0f261f1aea2c9968a07442ca5d4eab813f86a58", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-ast-visitor.h\"\n #include \"rust-hir-map.h\"\n #include \"rust-hir-full.h\"\n+#include \"rust-attributes.h\"\n \n namespace Rust {\n namespace HIR {\n@@ -230,9 +231,13 @@ class ASTLoweringBase : public AST::ASTVisitor\n   virtual void visit (AST::BareFunctionType &type) {}\n \n protected:\n-  ASTLoweringBase () : mappings (Analysis::Mappings::get ()) {}\n+  ASTLoweringBase ()\n+    : mappings (Analysis::Mappings::get ()),\n+      attr_mappings (Analysis::BuiltinAttributeMappings::get ())\n+  {}\n \n   Analysis::Mappings *mappings;\n+  Analysis::BuiltinAttributeMappings *attr_mappings;\n \n   HIR::Lifetime lower_lifetime (AST::Lifetime &lifetime)\n   {\n@@ -281,6 +286,16 @@ class ASTLoweringBase : public AST::ASTVisitor\n \n   HIR::FunctionQualifiers\n   lower_qualifiers (const AST::FunctionQualifiers &qualifiers);\n+\n+  void handle_outer_attributes (const HIR::Item &item);\n+\n+  void handle_lang_item_attribute (const HIR::Item &item,\n+\t\t\t\t   const AST::Attribute &attr);\n+\n+  bool is_known_attribute (const std::string &attribute_path) const;\n+\n+  bool\n+  attribute_handled_in_another_pass (const std::string &attribute_path) const;\n };\n \n } // namespace HIR"}, {"sha": "55c8e8ae7752960e33397f8349940d0c1e1bd732", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f261f1aea2c9968a07442ca5d4eab813f86a58/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f261f1aea2c9968a07442ca5d4eab813f86a58/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=e0f261f1aea2c9968a07442ca5d4eab813f86a58", "patch": "@@ -44,6 +44,10 @@ class ASTLoweringItem : public ASTLoweringBase\n   {\n     ASTLoweringItem resolver;\n     item->accept_vis (resolver);\n+\n+    if (resolver.translated != nullptr)\n+      resolver.handle_outer_attributes (*resolver.translated);\n+\n     return resolver.translated;\n   }\n "}, {"sha": "8062f2f635287be8d21d746e10f7d4d805095bda", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f261f1aea2c9968a07442ca5d4eab813f86a58/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f261f1aea2c9968a07442ca5d4eab813f86a58/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=e0f261f1aea2c9968a07442ca5d4eab813f86a58", "patch": "@@ -609,5 +609,69 @@ ASTLoweringBase::lower_qualifiers (const AST::FunctionQualifiers &qualifiers)\n \t\t\t\t  has_extern, extern_abi);\n }\n \n+void\n+ASTLoweringBase::handle_outer_attributes (const HIR::Item &item)\n+{\n+  for (const auto &attr : item.get_outer_attrs ())\n+    {\n+      const auto &str_path = attr.get_path ().as_string ();\n+      if (!is_known_attribute (str_path))\n+\t{\n+\t  rust_error_at (attr.get_locus (), \"unknown attribute\");\n+\t  continue;\n+\t}\n+\n+      bool is_lang_item = str_path.compare (\"lang\") == 0\n+\t\t\t  && attr.has_attr_input ()\n+\t\t\t  && attr.get_attr_input ().get_attr_input_type ()\n+\t\t\t       == AST::AttrInput::AttrInputType::LITERAL;\n+\n+      if (is_lang_item)\n+\thandle_lang_item_attribute (item, attr);\n+      else if (!attribute_handled_in_another_pass (str_path))\n+\t{\n+\t  rust_error_at (attr.get_locus (), \"unhandled attribute: [%s]\",\n+\t\t\t attr.get_path ().as_string ().c_str ());\n+\t}\n+    }\n+}\n+\n+void\n+ASTLoweringBase::handle_lang_item_attribute (const HIR::Item &item,\n+\t\t\t\t\t     const AST::Attribute &attr)\n+{\n+  auto &literal = static_cast<AST::AttrInputLiteral &> (attr.get_attr_input ());\n+  const auto &lang_item_type_str = literal.get_literal ().as_string ();\n+  auto lang_item_type = Analysis::RustLangItem::Parse (lang_item_type_str);\n+  if (lang_item_type == Analysis::RustLangItem::ItemType::UNKNOWN)\n+    {\n+      rust_error_at (attr.get_locus (), \"unknown lang item\");\n+      return;\n+    }\n+  mappings->insert_lang_item (lang_item_type,\n+\t\t\t      item.get_mappings ().get_defid ());\n+}\n+\n+bool\n+ASTLoweringBase::is_known_attribute (const std::string &attribute_path) const\n+{\n+  const auto &lookup = attr_mappings->lookup_builtin (attribute_path);\n+  return !lookup.is_error ();\n+}\n+\n+bool\n+ASTLoweringBase::attribute_handled_in_another_pass (\n+  const std::string &attribute_path) const\n+{\n+  const auto &lookup = attr_mappings->lookup_builtin (attribute_path);\n+  if (lookup.is_error ())\n+    return false;\n+\n+  if (lookup.handler == Analysis::CompilerPass::UNKNOWN)\n+    return false;\n+\n+  return lookup.handler != Analysis::CompilerPass::HIR_LOWERING;\n+}\n+\n } // namespace HIR\n } // namespace Rust"}, {"sha": "d8df481076c148f9d937eb3d4f97621e435e690c", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f261f1aea2c9968a07442ca5d4eab813f86a58/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f261f1aea2c9968a07442ca5d4eab813f86a58/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=e0f261f1aea2c9968a07442ca5d4eab813f86a58", "patch": "@@ -207,31 +207,6 @@ class TraitResolver : public TypeCheckBase\n     // loop of trying to resolve traits as required by the types\n     tref->on_resolved ();\n \n-    // does this have any lang-item attributes?\n-    for (auto &attr : trait_reference->get_outer_attrs ())\n-      {\n-\tbool is_lang_item = attr.get_path ().as_string ().compare (\"lang\") == 0\n-\t\t\t    && attr.has_attr_input ()\n-\t\t\t    && attr.get_attr_input ().get_attr_input_type ()\n-\t\t\t\t == AST::AttrInput::AttrInputType::LITERAL;\n-\tif (is_lang_item)\n-\t  {\n-\t    auto &literal\n-\t      = static_cast<AST::AttrInputLiteral &> (attr.get_attr_input ());\n-\t    const auto &lang_item_type_str\n-\t      = literal.get_literal ().as_string ();\n-\t    auto lang_item_type\n-\t      = Analysis::RustLangItem::Parse (lang_item_type_str);\n-\t    if (lang_item_type == Analysis::RustLangItem::ItemType::UNKNOWN)\n-\t      {\n-\t\trust_error_at (attr.get_locus (), \"unknown lang item\");\n-\t\treturn tref;\n-\t      }\n-\t    mappings->insert_lang_item (\n-\t      lang_item_type, trait_reference->get_mappings ().get_defid ());\n-\t  }\n-      }\n-\n     return tref;\n   }\n "}, {"sha": "3809ad76cd606668203808e8dc30e538d3143d39", "filename": "gcc/rust/util/rust-attributes.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f261f1aea2c9968a07442ca5d4eab813f86a58/gcc%2Frust%2Futil%2Frust-attributes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f261f1aea2c9968a07442ca5d4eab813f86a58/gcc%2Frust%2Futil%2Frust-attributes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-attributes.cc?ref=e0f261f1aea2c9968a07442ca5d4eab813f86a58", "patch": "@@ -0,0 +1,61 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-attributes.h\"\n+\n+namespace Rust {\n+namespace Analysis {\n+\n+// https://doc.rust-lang.org/stable/nightly-rustc/src/rustc_feature/builtin_attrs.rs.html#256\n+static const BuiltinAttrDefinition __definitions[] = {\n+  {\"inline\", CODE_GENERATION}, {\"cfg\", EXPANSION},     {\"cfg_attr\", EXPANSION},\n+  {\"allow\", STATIC_ANALYSIS},  {\"lang\", HIR_LOWERING},\n+};\n+\n+BuiltinAttributeMappings *\n+BuiltinAttributeMappings::get ()\n+{\n+  static BuiltinAttributeMappings *instance = nullptr;\n+  if (instance == nullptr)\n+    instance = new BuiltinAttributeMappings ();\n+\n+  return instance;\n+}\n+\n+const BuiltinAttrDefinition &\n+BuiltinAttributeMappings::lookup_builtin (const std::string &attr_name) const\n+{\n+  auto it = mappings.find (attr_name);\n+  if (it == mappings.end ())\n+    return BuiltinAttrDefinition::error_node ();\n+\n+  return it->second;\n+}\n+\n+BuiltinAttributeMappings::BuiltinAttributeMappings ()\n+{\n+  size_t ndefinitions = sizeof (__definitions) / sizeof (BuiltinAttrDefinition);\n+  for (size_t i = 0; i < ndefinitions; i++)\n+    {\n+      const BuiltinAttrDefinition &def = __definitions[i];\n+      mappings.insert ({def.name, def});\n+    }\n+}\n+\n+} // namespace Analysis\n+} // namespace Rust"}, {"sha": "6c2063c74558234c3b0e957674bdc6fabd1f8dc0", "filename": "gcc/rust/util/rust-attributes.h", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f261f1aea2c9968a07442ca5d4eab813f86a58/gcc%2Frust%2Futil%2Frust-attributes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f261f1aea2c9968a07442ca5d4eab813f86a58/gcc%2Frust%2Futil%2Frust-attributes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-attributes.h?ref=e0f261f1aea2c9968a07442ca5d4eab813f86a58", "patch": "@@ -0,0 +1,70 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-system.h\"\n+\n+namespace Rust {\n+namespace Analysis {\n+\n+enum CompilerPass\n+{\n+  UNKNOWN,\n+\n+  EXPANSION,\n+  NAME_RESOLUTION,\n+  HIR_LOWERING,\n+  TYPE_CHECK,\n+  STATIC_ANALYSIS,\n+  CODE_GENERATION\n+};\n+\n+struct BuiltinAttrDefinition\n+{\n+  std::string name;\n+  CompilerPass handler;\n+\n+  static BuiltinAttrDefinition get_error ()\n+  {\n+    return BuiltinAttrDefinition{\"\", UNKNOWN};\n+  }\n+\n+  static BuiltinAttrDefinition &error_node ()\n+  {\n+    static BuiltinAttrDefinition error_node = get_error ();\n+    return error_node;\n+  }\n+\n+  bool is_error () const { return name.empty (); }\n+};\n+\n+class BuiltinAttributeMappings\n+{\n+public:\n+  static BuiltinAttributeMappings *get ();\n+\n+  const BuiltinAttrDefinition &\n+  lookup_builtin (const std::string &attr_name) const;\n+\n+private:\n+  BuiltinAttributeMappings ();\n+\n+  std::map<std::string, const BuiltinAttrDefinition> mappings;\n+};\n+\n+} // namespace Analysis\n+} // namespace Rust"}, {"sha": "9bac328ee0fc3f7eee13823dfb694f97ff0354fa", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 1, "deletions": 269, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f261f1aea2c9968a07442ca5d4eab813f86a58/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f261f1aea2c9968a07442ca5d4eab813f86a58/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=e0f261f1aea2c9968a07442ca5d4eab813f86a58", "patch": "@@ -25,279 +25,11 @@\n #include \"rust-canonical-path.h\"\n #include \"rust-ast-full-decls.h\"\n #include \"rust-hir-full-decls.h\"\n-#include \"operator.h\"\n+#include \"rust-lang-item.h\"\n \n namespace Rust {\n namespace Analysis {\n \n-// https://github.com/rust-lang/rust/blob/master/library/core/src/ops/arith.rs\n-class RustLangItem\n-{\n-public:\n-  enum ItemType\n-  {\n-    ADD,\n-    SUBTRACT,\n-    MULTIPLY,\n-    DIVIDE,\n-    REMAINDER,\n-    BITAND,\n-    BITOR,\n-    BITXOR,\n-    SHL,\n-    SHR,\n-\n-    NEGATION,\n-    NOT,\n-\n-    ADD_ASSIGN,\n-    SUB_ASSIGN,\n-    MUL_ASSIGN,\n-    DIV_ASSIGN,\n-    REM_ASSIGN,\n-    BITAND_ASSIGN,\n-    BITOR_ASSIGN,\n-    BITXOR_ASSIGN,\n-    SHL_ASSIGN,\n-    SHR_ASSIGN,\n-\n-    DEREF,\n-    DEREF_MUT,\n-\n-    UNKNOWN,\n-  };\n-\n-  static ItemType Parse (const std::string &item)\n-  {\n-    if (item.compare (\"add\") == 0)\n-      {\n-\treturn ItemType::ADD;\n-      }\n-    else if (item.compare (\"sub\") == 0)\n-      {\n-\treturn ItemType::SUBTRACT;\n-      }\n-    else if (item.compare (\"mul\") == 0)\n-      {\n-\treturn ItemType::MULTIPLY;\n-      }\n-    else if (item.compare (\"div\") == 0)\n-      {\n-\treturn ItemType::DIVIDE;\n-      }\n-    else if (item.compare (\"rem\") == 0)\n-      {\n-\treturn ItemType::REMAINDER;\n-      }\n-    else if (item.compare (\"bitand\") == 0)\n-      {\n-\treturn ItemType::BITAND;\n-      }\n-    else if (item.compare (\"bitor\") == 0)\n-      {\n-\treturn ItemType::BITOR;\n-      }\n-    else if (item.compare (\"bitxor\") == 0)\n-      {\n-\treturn ItemType::BITXOR;\n-      }\n-    else if (item.compare (\"shl\") == 0)\n-      {\n-\treturn ItemType::SHL;\n-      }\n-    else if (item.compare (\"shr\") == 0)\n-      {\n-\treturn ItemType::SHR;\n-      }\n-    else if (item.compare (\"neg\") == 0)\n-      {\n-\treturn ItemType::NEGATION;\n-      }\n-    else if (item.compare (\"not\") == 0)\n-      {\n-\treturn ItemType::NOT;\n-      }\n-    else if (item.compare (\"add_assign\") == 0)\n-      {\n-\treturn ItemType::ADD_ASSIGN;\n-      }\n-    else if (item.compare (\"sub_assign\") == 0)\n-      {\n-\treturn ItemType::SUB_ASSIGN;\n-      }\n-    else if (item.compare (\"mul_assign\") == 0)\n-      {\n-\treturn ItemType::MUL_ASSIGN;\n-      }\n-    else if (item.compare (\"div_assign\") == 0)\n-      {\n-\treturn ItemType::DIV_ASSIGN;\n-      }\n-    else if (item.compare (\"rem_assign\") == 0)\n-      {\n-\treturn ItemType::REM_ASSIGN;\n-      }\n-    else if (item.compare (\"bitand_assign\") == 0)\n-      {\n-\treturn ItemType::BITAND_ASSIGN;\n-      }\n-    else if (item.compare (\"bitor_assign\") == 0)\n-      {\n-\treturn ItemType::BITOR_ASSIGN;\n-      }\n-    else if (item.compare (\"bitxor_assign\") == 0)\n-      {\n-\treturn ItemType::BITXOR_ASSIGN;\n-      }\n-    else if (item.compare (\"shl_assign\") == 0)\n-      {\n-\treturn ItemType::SHL_ASSIGN;\n-      }\n-    else if (item.compare (\"shr_assign\") == 0)\n-      {\n-\treturn ItemType::SHR_ASSIGN;\n-      }\n-    else if (item.compare (\"deref\") == 0)\n-      {\n-\treturn ItemType::DEREF;\n-      }\n-    else if (item.compare (\"deref_mut\") == 0)\n-      {\n-\treturn ItemType::DEREF_MUT;\n-      }\n-\n-    return ItemType::UNKNOWN;\n-  }\n-\n-  static std::string ToString (ItemType type)\n-  {\n-    switch (type)\n-      {\n-      case ADD:\n-\treturn \"add\";\n-      case SUBTRACT:\n-\treturn \"sub\";\n-      case MULTIPLY:\n-\treturn \"mul\";\n-      case DIVIDE:\n-\treturn \"div\";\n-      case REMAINDER:\n-\treturn \"rem\";\n-      case BITAND:\n-\treturn \"bitand\";\n-      case BITOR:\n-\treturn \"bitor\";\n-      case BITXOR:\n-\treturn \"bitxor\";\n-      case SHL:\n-\treturn \"shl\";\n-      case SHR:\n-\treturn \"shr\";\n-      case NEGATION:\n-\treturn \"neg\";\n-      case NOT:\n-\treturn \"not\";\n-      case ADD_ASSIGN:\n-\treturn \"add_assign\";\n-      case SUB_ASSIGN:\n-\treturn \"sub_assign\";\n-      case MUL_ASSIGN:\n-\treturn \"mul_assign\";\n-      case DIV_ASSIGN:\n-\treturn \"div_assign\";\n-      case REM_ASSIGN:\n-\treturn \"rem_assign\";\n-      case BITAND_ASSIGN:\n-\treturn \"bitand_assign\";\n-      case BITOR_ASSIGN:\n-\treturn \"bitor_assign\";\n-      case BITXOR_ASSIGN:\n-\treturn \"bitxor_assign\";\n-      case SHL_ASSIGN:\n-\treturn \"shl_assign\";\n-      case SHR_ASSIGN:\n-\treturn \"shr_assign\";\n-      case DEREF:\n-\treturn \"deref\";\n-      case DEREF_MUT:\n-\treturn \"deref_mut\";\n-\n-      case UNKNOWN:\n-\treturn \"<UNKNOWN>\";\n-      }\n-    return \"<UNKNOWN>\";\n-  }\n-\n-  static ItemType OperatorToLangItem (ArithmeticOrLogicalOperator op)\n-  {\n-    switch (op)\n-      {\n-      case ArithmeticOrLogicalOperator::ADD:\n-\treturn ItemType::ADD;\n-      case ArithmeticOrLogicalOperator::SUBTRACT:\n-\treturn ItemType::SUBTRACT;\n-      case ArithmeticOrLogicalOperator::MULTIPLY:\n-\treturn ItemType::MULTIPLY;\n-      case ArithmeticOrLogicalOperator::DIVIDE:\n-\treturn ItemType::DIVIDE;\n-      case ArithmeticOrLogicalOperator::MODULUS:\n-\treturn ItemType::REMAINDER;\n-      case ArithmeticOrLogicalOperator::BITWISE_AND:\n-\treturn ItemType::BITAND;\n-      case ArithmeticOrLogicalOperator::BITWISE_OR:\n-\treturn ItemType::BITOR;\n-      case ArithmeticOrLogicalOperator::BITWISE_XOR:\n-\treturn ItemType::BITXOR;\n-      case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n-\treturn ItemType::SHL;\n-      case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n-\treturn ItemType::SHR;\n-      }\n-    return ItemType::UNKNOWN;\n-  }\n-\n-  static ItemType\n-  CompoundAssignmentOperatorToLangItem (ArithmeticOrLogicalOperator op)\n-  {\n-    switch (op)\n-      {\n-      case ArithmeticOrLogicalOperator::ADD:\n-\treturn ItemType::ADD_ASSIGN;\n-      case ArithmeticOrLogicalOperator::SUBTRACT:\n-\treturn ItemType::SUB_ASSIGN;\n-      case ArithmeticOrLogicalOperator::MULTIPLY:\n-\treturn ItemType::MUL_ASSIGN;\n-      case ArithmeticOrLogicalOperator::DIVIDE:\n-\treturn ItemType::DIV_ASSIGN;\n-      case ArithmeticOrLogicalOperator::MODULUS:\n-\treturn ItemType::REM_ASSIGN;\n-      case ArithmeticOrLogicalOperator::BITWISE_AND:\n-\treturn ItemType::BITAND_ASSIGN;\n-      case ArithmeticOrLogicalOperator::BITWISE_OR:\n-\treturn ItemType::BITOR_ASSIGN;\n-      case ArithmeticOrLogicalOperator::BITWISE_XOR:\n-\treturn ItemType::BITXOR_ASSIGN;\n-      case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n-\treturn ItemType::SHL_ASSIGN;\n-      case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n-\treturn ItemType::SHR_ASSIGN;\n-      }\n-    return ItemType::UNKNOWN;\n-  }\n-\n-  static ItemType NegationOperatorToLangItem (NegationOperator op)\n-  {\n-    switch (op)\n-      {\n-      case NegationOperator::NEGATE:\n-\treturn ItemType::NEGATION;\n-      case NegationOperator::NOT:\n-\treturn ItemType::NOT;\n-      }\n-    return ItemType::UNKNOWN;\n-  }\n-};\n-\n class NodeMapping\n {\n public:"}, {"sha": "da200e7dabedfb68b677611d7e2ebfcb01b13865", "filename": "gcc/rust/util/rust-lang-item.h", "status": "added", "additions": 334, "deletions": 0, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f261f1aea2c9968a07442ca5d4eab813f86a58/gcc%2Frust%2Futil%2Frust-lang-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f261f1aea2c9968a07442ca5d4eab813f86a58/gcc%2Frust%2Futil%2Frust-lang-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-lang-item.h?ref=e0f261f1aea2c9968a07442ca5d4eab813f86a58", "patch": "@@ -0,0 +1,334 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-system.h\"\n+#include \"operator.h\"\n+\n+namespace Rust {\n+namespace Analysis {\n+\n+// https://github.com/rust-lang/rust/blob/master/library/core/src/ops/arith.rs\n+class RustLangItem\n+{\n+public:\n+  enum ItemType\n+  {\n+    ADD,\n+    SUBTRACT,\n+    MULTIPLY,\n+    DIVIDE,\n+    REMAINDER,\n+    BITAND,\n+    BITOR,\n+    BITXOR,\n+    SHL,\n+    SHR,\n+\n+    NEGATION,\n+    NOT,\n+\n+    ADD_ASSIGN,\n+    SUB_ASSIGN,\n+    MUL_ASSIGN,\n+    DIV_ASSIGN,\n+    REM_ASSIGN,\n+    BITAND_ASSIGN,\n+    BITOR_ASSIGN,\n+    BITXOR_ASSIGN,\n+    SHL_ASSIGN,\n+    SHR_ASSIGN,\n+\n+    DEREF,\n+    DEREF_MUT,\n+\n+    // https://github.com/rust-lang/rust/blob/master/library/core/src/ops/range.rs\n+    RANGE_FULL,\n+    RANGE,\n+    RANGE_FROM,\n+    RANGE_TO,\n+    RANGE_INCLUSIVE,\n+    RANGE_TO_INCLUSIVE,\n+\n+    UNKNOWN,\n+  };\n+\n+  static ItemType Parse (const std::string &item)\n+  {\n+    if (item.compare (\"add\") == 0)\n+      {\n+\treturn ItemType::ADD;\n+      }\n+    else if (item.compare (\"sub\") == 0)\n+      {\n+\treturn ItemType::SUBTRACT;\n+      }\n+    else if (item.compare (\"mul\") == 0)\n+      {\n+\treturn ItemType::MULTIPLY;\n+      }\n+    else if (item.compare (\"div\") == 0)\n+      {\n+\treturn ItemType::DIVIDE;\n+      }\n+    else if (item.compare (\"rem\") == 0)\n+      {\n+\treturn ItemType::REMAINDER;\n+      }\n+    else if (item.compare (\"bitand\") == 0)\n+      {\n+\treturn ItemType::BITAND;\n+      }\n+    else if (item.compare (\"bitor\") == 0)\n+      {\n+\treturn ItemType::BITOR;\n+      }\n+    else if (item.compare (\"bitxor\") == 0)\n+      {\n+\treturn ItemType::BITXOR;\n+      }\n+    else if (item.compare (\"shl\") == 0)\n+      {\n+\treturn ItemType::SHL;\n+      }\n+    else if (item.compare (\"shr\") == 0)\n+      {\n+\treturn ItemType::SHR;\n+      }\n+    else if (item.compare (\"neg\") == 0)\n+      {\n+\treturn ItemType::NEGATION;\n+      }\n+    else if (item.compare (\"not\") == 0)\n+      {\n+\treturn ItemType::NOT;\n+      }\n+    else if (item.compare (\"add_assign\") == 0)\n+      {\n+\treturn ItemType::ADD_ASSIGN;\n+      }\n+    else if (item.compare (\"sub_assign\") == 0)\n+      {\n+\treturn ItemType::SUB_ASSIGN;\n+      }\n+    else if (item.compare (\"mul_assign\") == 0)\n+      {\n+\treturn ItemType::MUL_ASSIGN;\n+      }\n+    else if (item.compare (\"div_assign\") == 0)\n+      {\n+\treturn ItemType::DIV_ASSIGN;\n+      }\n+    else if (item.compare (\"rem_assign\") == 0)\n+      {\n+\treturn ItemType::REM_ASSIGN;\n+      }\n+    else if (item.compare (\"bitand_assign\") == 0)\n+      {\n+\treturn ItemType::BITAND_ASSIGN;\n+      }\n+    else if (item.compare (\"bitor_assign\") == 0)\n+      {\n+\treturn ItemType::BITOR_ASSIGN;\n+      }\n+    else if (item.compare (\"bitxor_assign\") == 0)\n+      {\n+\treturn ItemType::BITXOR_ASSIGN;\n+      }\n+    else if (item.compare (\"shl_assign\") == 0)\n+      {\n+\treturn ItemType::SHL_ASSIGN;\n+      }\n+    else if (item.compare (\"shr_assign\") == 0)\n+      {\n+\treturn ItemType::SHR_ASSIGN;\n+      }\n+    else if (item.compare (\"deref\") == 0)\n+      {\n+\treturn ItemType::DEREF;\n+      }\n+    else if (item.compare (\"deref_mut\") == 0)\n+      {\n+\treturn ItemType::DEREF_MUT;\n+      }\n+    else if (item.compare (\"Range\") == 0)\n+      {\n+\treturn ItemType::RANGE;\n+      }\n+    else if (item.compare (\"RangeFrom\") == 0)\n+      {\n+\treturn ItemType::RANGE_FROM;\n+      }\n+    else if (item.compare (\"RangeTo\") == 0)\n+      {\n+\treturn ItemType::RANGE_TO;\n+      }\n+    else if (item.compare (\"RangeInclusive\") == 0)\n+      {\n+\treturn ItemType::RANGE_INCLUSIVE;\n+      }\n+    else if (item.compare (\"RangeToInclusive\") == 0)\n+      {\n+\treturn ItemType::RANGE_TO_INCLUSIVE;\n+      }\n+\n+    return ItemType::UNKNOWN;\n+  }\n+\n+  static std::string ToString (ItemType type)\n+  {\n+    switch (type)\n+      {\n+      case ADD:\n+\treturn \"add\";\n+      case SUBTRACT:\n+\treturn \"sub\";\n+      case MULTIPLY:\n+\treturn \"mul\";\n+      case DIVIDE:\n+\treturn \"div\";\n+      case REMAINDER:\n+\treturn \"rem\";\n+      case BITAND:\n+\treturn \"bitand\";\n+      case BITOR:\n+\treturn \"bitor\";\n+      case BITXOR:\n+\treturn \"bitxor\";\n+      case SHL:\n+\treturn \"shl\";\n+      case SHR:\n+\treturn \"shr\";\n+      case NEGATION:\n+\treturn \"neg\";\n+      case NOT:\n+\treturn \"not\";\n+      case ADD_ASSIGN:\n+\treturn \"add_assign\";\n+      case SUB_ASSIGN:\n+\treturn \"sub_assign\";\n+      case MUL_ASSIGN:\n+\treturn \"mul_assign\";\n+      case DIV_ASSIGN:\n+\treturn \"div_assign\";\n+      case REM_ASSIGN:\n+\treturn \"rem_assign\";\n+      case BITAND_ASSIGN:\n+\treturn \"bitand_assign\";\n+      case BITOR_ASSIGN:\n+\treturn \"bitor_assign\";\n+      case BITXOR_ASSIGN:\n+\treturn \"bitxor_assign\";\n+      case SHL_ASSIGN:\n+\treturn \"shl_assign\";\n+      case SHR_ASSIGN:\n+\treturn \"shr_assign\";\n+      case DEREF:\n+\treturn \"deref\";\n+      case DEREF_MUT:\n+\treturn \"deref_mut\";\n+      case RANGE_FULL:\n+\treturn \"RangeFull\";\n+      case RANGE:\n+\treturn \"Range\";\n+      case RANGE_FROM:\n+\treturn \"RangeFrom\";\n+      case RANGE_TO:\n+\treturn \"RangeTo\";\n+      case RANGE_INCLUSIVE:\n+\treturn \"RangeInclusive\";\n+      case RANGE_TO_INCLUSIVE:\n+\treturn \"RangeToInclusive\";\n+\n+      case UNKNOWN:\n+\treturn \"<UNKNOWN>\";\n+      }\n+    return \"<UNKNOWN>\";\n+  }\n+\n+  static ItemType OperatorToLangItem (ArithmeticOrLogicalOperator op)\n+  {\n+    switch (op)\n+      {\n+      case ArithmeticOrLogicalOperator::ADD:\n+\treturn ItemType::ADD;\n+      case ArithmeticOrLogicalOperator::SUBTRACT:\n+\treturn ItemType::SUBTRACT;\n+      case ArithmeticOrLogicalOperator::MULTIPLY:\n+\treturn ItemType::MULTIPLY;\n+      case ArithmeticOrLogicalOperator::DIVIDE:\n+\treturn ItemType::DIVIDE;\n+      case ArithmeticOrLogicalOperator::MODULUS:\n+\treturn ItemType::REMAINDER;\n+      case ArithmeticOrLogicalOperator::BITWISE_AND:\n+\treturn ItemType::BITAND;\n+      case ArithmeticOrLogicalOperator::BITWISE_OR:\n+\treturn ItemType::BITOR;\n+      case ArithmeticOrLogicalOperator::BITWISE_XOR:\n+\treturn ItemType::BITXOR;\n+      case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n+\treturn ItemType::SHL;\n+      case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n+\treturn ItemType::SHR;\n+      }\n+    return ItemType::UNKNOWN;\n+  }\n+\n+  static ItemType\n+  CompoundAssignmentOperatorToLangItem (ArithmeticOrLogicalOperator op)\n+  {\n+    switch (op)\n+      {\n+      case ArithmeticOrLogicalOperator::ADD:\n+\treturn ItemType::ADD_ASSIGN;\n+      case ArithmeticOrLogicalOperator::SUBTRACT:\n+\treturn ItemType::SUB_ASSIGN;\n+      case ArithmeticOrLogicalOperator::MULTIPLY:\n+\treturn ItemType::MUL_ASSIGN;\n+      case ArithmeticOrLogicalOperator::DIVIDE:\n+\treturn ItemType::DIV_ASSIGN;\n+      case ArithmeticOrLogicalOperator::MODULUS:\n+\treturn ItemType::REM_ASSIGN;\n+      case ArithmeticOrLogicalOperator::BITWISE_AND:\n+\treturn ItemType::BITAND_ASSIGN;\n+      case ArithmeticOrLogicalOperator::BITWISE_OR:\n+\treturn ItemType::BITOR_ASSIGN;\n+      case ArithmeticOrLogicalOperator::BITWISE_XOR:\n+\treturn ItemType::BITXOR_ASSIGN;\n+      case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n+\treturn ItemType::SHL_ASSIGN;\n+      case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n+\treturn ItemType::SHR_ASSIGN;\n+      }\n+    return ItemType::UNKNOWN;\n+  }\n+\n+  static ItemType NegationOperatorToLangItem (NegationOperator op)\n+  {\n+    switch (op)\n+      {\n+      case NegationOperator::NEGATE:\n+\treturn ItemType::NEGATION;\n+      case NegationOperator::NOT:\n+\treturn ItemType::NOT;\n+      }\n+    return ItemType::UNKNOWN;\n+  }\n+};\n+\n+} // namespace Analysis\n+} // namespace Rust"}]}