{"sha": "88e9690610c421a7ece2331828b9799755d7ddba", "node_id": "C_kwDOANBUbNoAKDg4ZTk2OTA2MTBjNDIxYTdlY2UyMzMxODI4Yjk3OTk3NTVkN2RkYmE", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2022-01-25T00:46:58Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-11T08:53:17Z"}, "message": "[Ada] Properly reject unsupported address specifications\n\nIn the case of an object declaration with an indefinite nominal subtype\n(roughly speaking, that's an object that takes its bounds,\ndiscriminants, and/or tag from its explicit initial value), GNAT does\nnot support address specifications unless the size of the object is\nknown at compile time.  In some cases, such unsupported address\nspecifications were not properly rejected. This could lead to either an\ninternal error during compilation or (in the class-wide case) to a\nwarning accompanied by raising Program_Error at run time.\n\ngcc/ada/\n\n\t* sem_ch13.adb (Analyze_Attribute_Definition_Clause): Replace\n\tthe existing check for an address specification for an object of\n\ta class-wide type with a more general check which rejects either\n\tthe class-wide case or the case where the FE would (if the\n\taddress specification were accepted) build a malformed\n\ttree (specifically, an object renaming declaration with a\n\tspecified address). In the case where the check fails, reject\n\tthe construct at compile time instead of generating an\n\tunconditional raise of Program_Error.\n\t* doc/gnat_rm/representation_clauses_and_pragmas.rst: Update\n\tdocumentation to reflect these changes.\n\t* gnat_rm.texi: Regenerate.", "tree": {"sha": "a459437b4cc50bb31c1f5ed96c5034cebed0a04a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a459437b4cc50bb31c1f5ed96c5034cebed0a04a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88e9690610c421a7ece2331828b9799755d7ddba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e9690610c421a7ece2331828b9799755d7ddba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88e9690610c421a7ece2331828b9799755d7ddba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e9690610c421a7ece2331828b9799755d7ddba/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c48a779f64c68f73f50c5993c818ead9faf8d013", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c48a779f64c68f73f50c5993c818ead9faf8d013", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c48a779f64c68f73f50c5993c818ead9faf8d013"}], "stats": {"total": 85, "additions": 66, "deletions": 19}, "files": [{"sha": "3bb579b4ba0481294c20b1734df1180c78e4e8c0", "filename": "gcc/ada/doc/gnat_rm/representation_clauses_and_pragmas.rst", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e9690610c421a7ece2331828b9799755d7ddba/gcc%2Fada%2Fdoc%2Fgnat_rm%2Frepresentation_clauses_and_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e9690610c421a7ece2331828b9799755d7ddba/gcc%2Fada%2Fdoc%2Fgnat_rm%2Frepresentation_clauses_and_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Frepresentation_clauses_and_pragmas.rst?ref=88e9690610c421a7ece2331828b9799755d7ddba", "patch": "@@ -1585,9 +1585,20 @@ check Alignment_Check is suppressed, or if\n ``pragma Restrictions (No_Elaboration_Code)`` is in effect. It is also\n suppressed by default on non-strict alignment machines (such as the x86).\n \n-Finally, GNAT does not permit overlaying of objects of class-wide types. In\n-most cases, the compiler can detect an attempt at such overlays and will\n-generate a warning at compile time and a Program_Error exception at run time.\n+In some cases, GNAT does not support an address specification (using either\n+form of aspect specification syntax) for the declaration of an object that has\n+an indefinite nominal subtype. An object declaration has an indefinite\n+nominal subtype if it takes its bounds (for an array type), discriminant\n+values (for a discriminated type whose discriminants lack defaults), or tag\n+(for a class-wide type) from its initial value, as in\n+\n+.. code-block:: ada\n+\n+    X : String := Some_Function_Call;\n+    -- String has no constraint, so bounds for X come from function call\n+\n+This restriction does not apply if the size of the object's initial value is\n+known at compile time and the type of the object is not class-wide.\n \n .. index:: Export\n "}, {"sha": "388528b3439bcfbfcd3bfe1be7c5f68600ced36c", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e9690610c421a7ece2331828b9799755d7ddba/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e9690610c421a7ece2331828b9799755d7ddba/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=88e9690610c421a7ece2331828b9799755d7ddba", "patch": "@@ -20176,9 +20176,20 @@ check Alignment_Check is suppressed, or if\n @code{pragma Restrictions (No_Elaboration_Code)} is in effect. It is also\n suppressed by default on non-strict alignment machines (such as the x86).\n \n-Finally, GNAT does not permit overlaying of objects of class-wide types. In\n-most cases, the compiler can detect an attempt at such overlays and will\n-generate a warning at compile time and a Program_Error exception at run time.\n+In some cases, GNAT does not support an address specification (using either\n+form of aspect specification syntax) for the declaration of an object that has\n+an indefinite nominal subtype. An object declaration has an indefinite\n+nominal subtype if it takes its bounds (for an array type), discriminant\n+values (for a discriminated type whose discriminants lack defaults), or tag\n+(for a class-wide type) from its initial value, as in\n+\n+@example\n+X : String := Some_Function_Call;\n+-- String has no constraint, so bounds for X come from function call\n+@end example\n+\n+This restriction does not apply if the size of the object\u2019s initial value is\n+known at compile time and the type of the object is not class-wide.\n \n @geindex Export\n "}, {"sha": "3cac123b134b3ef3a6704d17e49a6f4f44aa476d", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e9690610c421a7ece2331828b9799755d7ddba/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e9690610c421a7ece2331828b9799755d7ddba/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=88e9690610c421a7ece2331828b9799755d7ddba", "patch": "@@ -6550,22 +6550,47 @@ package body Sem_Ch13 is\n                     (\"\\?j?use interrupt procedure instead\", N);\n                end if;\n \n-            --  Case of an address clause for a class-wide object, which is\n-            --  considered erroneous.\n-\n-            elsif Is_Class_Wide_Type (Etype (U_Ent)) then\n-               Error_Msg_NE\n-                 (\"??class-wide object & must not be overlaid\", Nam, U_Ent);\n-               Error_Msg_N\n-                 (\"\\??Program_Error will be raised at run time\", Nam);\n-               Insert_Action (Declaration_Node (U_Ent),\n-                 Make_Raise_Program_Error (Loc,\n-                   Reason => PE_Overlaid_Controlled_Object));\n-               return;\n-\n             --  Case of address clause for an object\n \n             elsif Ekind (U_Ent) in E_Constant | E_Variable then\n+\n+               --  Disallow case of an address clause for an object of an\n+               --  indefinite subtype which takes its bounds/discriminant/tag\n+               --  from its initial value. Without this, we get a Gigi\n+               --  assertion failure for things like\n+               --    X : String := Some_Function (...) with Address => ...;\n+               --  where the result subtype of the function is unconstrained.\n+               --\n+               --  We want to reject two cases: the class-wide case, and the\n+               --  case where the FE conjures up a renaming declaration and\n+               --  would then otherwise generate an address specification for\n+               --  that renaming (which is a malformed tree, which is why Gigi\n+               --  complains).\n+\n+               if Is_Class_Wide_Type (Etype (U_Ent)) then\n+                  Error_Msg_N\n+                    (\"address specification not supported for class-wide \" &\n+                     \"object declaration\", Nam);\n+                  return;\n+               elsif Is_Constr_Subt_For_U_Nominal (Etype (U_Ent))\n+                 and then\n+                   Nkind (Parent (U_Ent)) = N_Object_Renaming_Declaration\n+               then\n+                  --  Confirm accuracy of \" and dynamic size\" message text\n+                  --  before including it. We want to include that text when\n+                  --  it is correct because it may be useful to the reader.\n+                  --  The case where we omit that part of the message text\n+                  --  might be dead code, but let's not rely on that.\n+\n+                  Error_Msg_N\n+                    (\"address specification not supported for object \" &\n+                     \"declaration with indefinite nominal subtype\" &\n+                     (if Size_Known_At_Compile_Time (Etype (U_Ent))\n+                      then \"\"\n+                      else \" and dynamic size\"), Nam);\n+                  return;\n+               end if;\n+\n                declare\n                   Expr  : constant Node_Id := Expression (N);\n                   O_Ent : Entity_Id;"}]}