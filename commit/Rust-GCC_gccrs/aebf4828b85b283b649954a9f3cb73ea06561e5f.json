{"sha": "aebf4828b85b283b649954a9f3cb73ea06561e5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWViZjQ4MjhiODViMjgzYjY0OTk1NGE5ZjNjYjczZWEwNjU2MWU1Zg==", "commit": {"author": {"name": "Kai Tietz", "email": "ktietz@redhat.com", "date": "2011-07-27T09:21:06Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2011-07-27T09:21:06Z"}, "message": "tree-vrp.c (extract_range_from_binary_expr): Remove TRUTH-binary cases and add new bitwise-cases.\n\n2011-07-27  Kai Tietz  <ktietz@redhat.com>\n\n        * tree-vrp.c (extract_range_from_binary_expr): Remove\n        TRUTH-binary cases and add new bitwise-cases.\n        (extract_range_from_assignment): Likewise.\n        (register_edge_assert_for_1): Likeiwise.\n        (register_edge_assert_for): Likewise.\n        (simplify_truth_ops_using_ranges): Likewise.\n        (simplify_stmt_using_ranges): Likewise.\n\nFrom-SVN: r176818", "tree": {"sha": "533c4e0c3160c4135908cd251c022419dc67f24d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/533c4e0c3160c4135908cd251c022419dc67f24d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aebf4828b85b283b649954a9f3cb73ea06561e5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aebf4828b85b283b649954a9f3cb73ea06561e5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aebf4828b85b283b649954a9f3cb73ea06561e5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aebf4828b85b283b649954a9f3cb73ea06561e5f/comments", "author": null, "committer": null, "parents": [{"sha": "d2a99e875608ab93e594719281514f2d09f5916a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2a99e875608ab93e594719281514f2d09f5916a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2a99e875608ab93e594719281514f2d09f5916a"}], "stats": {"total": 166, "additions": 70, "deletions": 96}, "files": [{"sha": "a64dd56d87e3205265cc90e075d885ae1fa837b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aebf4828b85b283b649954a9f3cb73ea06561e5f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aebf4828b85b283b649954a9f3cb73ea06561e5f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aebf4828b85b283b649954a9f3cb73ea06561e5f", "patch": "@@ -1,3 +1,13 @@\n+2011-07-27  Kai Tietz  <ktietz@redhat.com>\n+\n+\t* tree-vrp.c (extract_range_from_binary_expr): Remove\n+\tTRUTH-binary cases and add new bitwise-cases.\n+\t(extract_range_from_assignment): Likewise.\n+\t(register_edge_assert_for_1): Likeiwise.\n+\t(register_edge_assert_for): Likewise.\n+\t(simplify_truth_ops_using_ranges): Likewise.\n+\t(simplify_stmt_using_ranges): Likewise.\n+\n 2011-07-26  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/47372"}, {"sha": "0acbbf28eee40d82ed5e484a3d0fafc8156c6611", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 60, "deletions": 96, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aebf4828b85b283b649954a9f3cb73ea06561e5f/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aebf4828b85b283b649954a9f3cb73ea06561e5f/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=aebf4828b85b283b649954a9f3cb73ea06561e5f", "patch": "@@ -2187,9 +2187,7 @@ extract_range_from_binary_expr (value_range_t *vr,\n       && code != MIN_EXPR\n       && code != MAX_EXPR\n       && code != BIT_AND_EXPR\n-      && code != BIT_IOR_EXPR\n-      && code != TRUTH_AND_EXPR\n-      && code != TRUTH_OR_EXPR)\n+      && code != BIT_IOR_EXPR)\n     {\n       /* We can still do constant propagation here.  */\n       tree const_op0 = op_with_constant_singleton_value_range (op0);\n@@ -2244,8 +2242,7 @@ extract_range_from_binary_expr (value_range_t *vr,\n      divisions.  TODO, we may be able to derive anti-ranges in\n      some cases.  */\n   if (code != BIT_AND_EXPR\n-      && code != TRUTH_AND_EXPR\n-      && code != TRUTH_OR_EXPR\n+      && code != BIT_IOR_EXPR\n       && code != TRUNC_DIV_EXPR\n       && code != FLOOR_DIV_EXPR\n       && code != CEIL_DIV_EXPR\n@@ -2267,7 +2264,12 @@ extract_range_from_binary_expr (value_range_t *vr,\n       || POINTER_TYPE_P (TREE_TYPE (op0))\n       || POINTER_TYPE_P (TREE_TYPE (op1)))\n     {\n-      if (code == MIN_EXPR || code == MAX_EXPR)\n+      if (code == BIT_IOR_EXPR)\n+        {\n+\t  set_value_range_to_varying (vr);\n+\t  return;\n+\t}\n+      else if (code == MIN_EXPR || code == MAX_EXPR)\n \t{\n \t  /* For MIN/MAX expressions with pointers, we only care about\n \t     nullness, if both are non null, then the result is nonnull.\n@@ -2312,57 +2314,9 @@ extract_range_from_binary_expr (value_range_t *vr,\n \n   /* For integer ranges, apply the operation to each end of the\n      range and see what we end up with.  */\n-  if (code == TRUTH_AND_EXPR\n-      || code == TRUTH_OR_EXPR)\n-    {\n-      /* If one of the operands is zero, we know that the whole\n-\t expression evaluates zero.  */\n-      if (code == TRUTH_AND_EXPR\n-\t  && ((vr0.type == VR_RANGE\n-\t       && integer_zerop (vr0.min)\n-\t       && integer_zerop (vr0.max))\n-\t      || (vr1.type == VR_RANGE\n-\t\t  && integer_zerop (vr1.min)\n-\t\t  && integer_zerop (vr1.max))))\n-\t{\n-\t  type = VR_RANGE;\n-\t  min = max = build_int_cst (expr_type, 0);\n-\t}\n-      /* If one of the operands is one, we know that the whole\n-\t expression evaluates one.  */\n-      else if (code == TRUTH_OR_EXPR\n-\t       && ((vr0.type == VR_RANGE\n-\t\t    && integer_onep (vr0.min)\n-\t\t    && integer_onep (vr0.max))\n-\t\t   || (vr1.type == VR_RANGE\n-\t\t       && integer_onep (vr1.min)\n-\t\t       && integer_onep (vr1.max))))\n-\t{\n-\t  type = VR_RANGE;\n-\t  min = max = build_int_cst (expr_type, 1);\n-\t}\n-      else if (vr0.type != VR_VARYING\n-\t       && vr1.type != VR_VARYING\n-\t       && vr0.type == vr1.type\n-\t       && !symbolic_range_p (&vr0)\n-\t       && !overflow_infinity_range_p (&vr0)\n-\t       && !symbolic_range_p (&vr1)\n-\t       && !overflow_infinity_range_p (&vr1))\n-\t{\n-\t  /* Boolean expressions cannot be folded with int_const_binop.  */\n-\t  min = fold_binary (code, expr_type, vr0.min, vr1.min);\n-\t  max = fold_binary (code, expr_type, vr0.max, vr1.max);\n-\t}\n-      else\n-\t{\n-\t  /* The result of a TRUTH_*_EXPR is always true or false.  */\n-\t  set_value_range_to_truthvalue (vr, expr_type);\n-\t  return;\n-\t}\n-    }\n-  else if (code == PLUS_EXPR\n-\t   || code == MIN_EXPR\n-\t   || code == MAX_EXPR)\n+  if (code == PLUS_EXPR\n+      || code == MIN_EXPR\n+      || code == MAX_EXPR)\n     {\n       /* If we have a PLUS_EXPR with two VR_ANTI_RANGEs, drop to\n \t VR_VARYING.  It would take more effort to compute a precise\n@@ -2694,6 +2648,8 @@ extract_range_from_binary_expr (value_range_t *vr,\n       bool int_cst_range0, int_cst_range1;\n       double_int may_be_nonzero0, may_be_nonzero1;\n       double_int must_be_nonzero0, must_be_nonzero1;\n+      value_range_t *non_singleton_vr;\n+      tree singleton_val;\n \n       vr0_int_cst_singleton_p = range_int_cst_singleton_p (&vr0);\n       vr1_int_cst_singleton_p = range_int_cst_singleton_p (&vr1);\n@@ -2702,9 +2658,39 @@ extract_range_from_binary_expr (value_range_t *vr,\n       int_cst_range1 = zero_nonzero_bits_from_vr (&vr1, &may_be_nonzero1,\n \t\t\t\t\t\t  &must_be_nonzero1);\n \n+      singleton_val = (vr0_int_cst_singleton_p ? vr0.min : vr1.min);\n+      non_singleton_vr = (vr0_int_cst_singleton_p ? &vr1 : &vr0);\n+\n       type = VR_RANGE;\n       if (vr0_int_cst_singleton_p && vr1_int_cst_singleton_p)\n \tmin = max = int_const_binop (code, vr0.max, vr1.max);\n+      else if ((vr0_int_cst_singleton_p || vr1_int_cst_singleton_p)\n+      \t       && (integer_zerop (singleton_val)\n+      \t           || integer_all_onesp (singleton_val)))\n+\t{\n+\t  /* If one of the operands is zero for and-case, we know that\n+ * \t     the whole expression evaluates zero.\n+\t     If one of the operands has all bits set to one for\n+\t     or-case, we know that the whole expression evaluates\n+\t     to this one.  */\n+\t   min = max = singleton_val;\n+\t   if ((code == BIT_IOR_EXPR\n+\t\t&& integer_zerop (singleton_val))\n+\t       || (code == BIT_AND_EXPR\n+\t\t   && integer_all_onesp (singleton_val)))\n+\t  /* If one of the operands has all bits set to one, we know\n+\t     that the whole expression evaluates to the other one for\n+\t     the and-case.\n+\t     If one of the operands is zero, we know that the whole\n+\t     expression evaluates to the other one for the or-case.  */\n+\t    {\n+\t      type = non_singleton_vr->type;\n+\t      min = non_singleton_vr->min;\n+\t      max = non_singleton_vr->max;\n+\t    }\n+\t  set_value_range (vr, type, min, max, NULL);\n+\t  return;\n+\t}\n       else if (!int_cst_range0 && !int_cst_range1)\n \t{\n \t  set_value_range_to_varying (vr);\n@@ -3316,10 +3302,7 @@ extract_range_from_assignment (value_range_t *vr, gimple stmt)\n     extract_range_from_assert (vr, gimple_assign_rhs1 (stmt));\n   else if (code == SSA_NAME)\n     extract_range_from_ssa_name (vr, gimple_assign_rhs1 (stmt));\n-  else if (TREE_CODE_CLASS (code) == tcc_binary\n-\t   || code == TRUTH_AND_EXPR\n-\t   || code == TRUTH_OR_EXPR\n-\t   || code == TRUTH_XOR_EXPR)\n+  else if (TREE_CODE_CLASS (code) == tcc_binary)\n     extract_range_from_binary_expr (vr, gimple_assign_rhs_code (stmt),\n \t\t\t\t    gimple_expr_type (stmt),\n \t\t\t\t    gimple_assign_rhs1 (stmt),\n@@ -4532,11 +4515,9 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n \t\t\t\t\t      invert);\n     }\n   else if ((code == NE_EXPR\n-\t    && (gimple_assign_rhs_code (op_def) == TRUTH_AND_EXPR\n-\t\t|| gimple_assign_rhs_code (op_def) == BIT_AND_EXPR))\n+\t    && gimple_assign_rhs_code (op_def) == BIT_AND_EXPR)\n \t   || (code == EQ_EXPR\n-\t       && (gimple_assign_rhs_code (op_def) == TRUTH_OR_EXPR\n-\t\t   || gimple_assign_rhs_code (op_def) == BIT_IOR_EXPR)))\n+\t       && gimple_assign_rhs_code (op_def) == BIT_IOR_EXPR))\n     {\n       /* Recurse on each operand.  */\n       retval |= register_edge_assert_for_1 (gimple_assign_rhs1 (op_def),\n@@ -4601,17 +4582,16 @@ register_edge_assert_for (tree name, edge e, gimple_stmt_iterator si,\n      the value zero or one, then we may be able to assert values\n      for SSA_NAMEs which flow into COND.  */\n \n-  /* In the case of NAME == 1 or NAME != 0, for TRUTH_AND_EXPR defining\n-     statement of NAME we can assert both operands of the TRUTH_AND_EXPR\n+  /* In the case of NAME == 1 or NAME != 0, for BIT_AND_EXPR defining\n+     statement of NAME we can assert both operands of the BIT_AND_EXPR\n      have nonzero value.  */\n   if (((comp_code == EQ_EXPR && integer_onep (val))\n        || (comp_code == NE_EXPR && integer_zerop (val))))\n     {\n       gimple def_stmt = SSA_NAME_DEF_STMT (name);\n \n       if (is_gimple_assign (def_stmt)\n-\t  && (gimple_assign_rhs_code (def_stmt) == TRUTH_AND_EXPR\n-\t      || gimple_assign_rhs_code (def_stmt) == BIT_AND_EXPR))\n+\t  && gimple_assign_rhs_code (def_stmt) == BIT_AND_EXPR)\n \t{\n \t  tree op0 = gimple_assign_rhs1 (def_stmt);\n \t  tree op1 = gimple_assign_rhs2 (def_stmt);\n@@ -4620,20 +4600,20 @@ register_edge_assert_for (tree name, edge e, gimple_stmt_iterator si,\n \t}\n     }\n \n-  /* In the case of NAME == 0 or NAME != 1, for TRUTH_OR_EXPR defining\n-     statement of NAME we can assert both operands of the TRUTH_OR_EXPR\n+  /* In the case of NAME == 0 or NAME != 1, for BIT_IOR_EXPR defining\n+     statement of NAME we can assert both operands of the BIT_IOR_EXPR\n      have zero value.  */\n   if (((comp_code == EQ_EXPR && integer_zerop (val))\n        || (comp_code == NE_EXPR && integer_onep (val))))\n     {\n       gimple def_stmt = SSA_NAME_DEF_STMT (name);\n \n+      /* For BIT_IOR_EXPR only if NAME == 0 both operands have\n+\t necessarily zero value, or if type-precision is one.  */\n       if (is_gimple_assign (def_stmt)\n-\t  && (gimple_assign_rhs_code (def_stmt) == TRUTH_OR_EXPR\n-\t      /* For BIT_IOR_EXPR only if NAME == 0 both operands have\n-\t\t necessarily zero value.  */\n-\t      || (comp_code == EQ_EXPR\n-\t\t  && (gimple_assign_rhs_code (def_stmt) == BIT_IOR_EXPR))))\n+\t  && (gimple_assign_rhs_code (def_stmt) == BIT_IOR_EXPR\n+\t      && (TYPE_PRECISION (TREE_TYPE (name)) == 1\n+\t          || comp_code == EQ_EXPR)))\n \t{\n \t  tree op0 = gimple_assign_rhs1 (def_stmt);\n \t  tree op1 = gimple_assign_rhs2 (def_stmt);\n@@ -6804,8 +6784,7 @@ simplify_truth_ops_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n \t{\n           /* Exclude anything that should have been already folded.  */\n \t  if (rhs_code != EQ_EXPR\n-\t      && rhs_code != NE_EXPR\n-\t      && rhs_code != TRUTH_XOR_EXPR)\n+\t      && rhs_code != NE_EXPR)\n \t    return false;\n \n \t  if (!integer_zerop (op1)\n@@ -6849,14 +6828,9 @@ simplify_truth_ops_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n       else\n \tlocation = gimple_location (stmt);\n \n-      if (rhs_code == TRUTH_AND_EXPR || rhs_code == TRUTH_OR_EXPR)\n-        warning_at (location, OPT_Wstrict_overflow,\n-\t            _(\"assuming signed overflow does not occur when \"\n-\t\t      \"simplifying && or || to & or |\"));\n-      else\n-        warning_at (location, OPT_Wstrict_overflow,\n-\t            _(\"assuming signed overflow does not occur when \"\n-\t\t      \"simplifying ==, != or ! to identity or ^\"));\n+      warning_at (location, OPT_Wstrict_overflow,\n+\t\t  _(\"assuming signed overflow does not occur when \"\n+\t\t    \"simplifying ==, != or ! to identity or ^\"));\n     }\n \n   need_conversion =\n@@ -6871,13 +6845,6 @@ simplify_truth_ops_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n \n   switch (rhs_code)\n     {\n-    case TRUTH_AND_EXPR:\n-      rhs_code = BIT_AND_EXPR;\n-      break;\n-    case TRUTH_OR_EXPR:\n-      rhs_code = BIT_IOR_EXPR;\n-      break;\n-    case TRUTH_XOR_EXPR:\n     case NE_EXPR:\n       if (integer_zerop (op1))\n \t{\n@@ -7548,9 +7515,6 @@ simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n \tcase EQ_EXPR:\n \tcase NE_EXPR:\n \tcase TRUTH_NOT_EXPR:\n-\tcase TRUTH_AND_EXPR:\n-\tcase TRUTH_OR_EXPR:\n-        case TRUTH_XOR_EXPR:\n           /* Transform EQ_EXPR, NE_EXPR, TRUTH_NOT_EXPR into BIT_XOR_EXPR\n \t     or identity if the RHS is zero or one, and the LHS are known\n \t     to be boolean values.  Transform all TRUTH_*_EXPR into"}]}