{"sha": "2848ad0fd63d89a3e9989b93f6b31ad1498386b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg0OGFkMGZkNjNkODlhM2U5OTg5YjkzZjZiMzFhZDE0OTgzODZiNg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-11-12T17:11:07Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-12T17:11:07Z"}, "message": "decl.c (compute_array_index_type): New function, split out from grokdeclarator.\n\n\t* decl.c (compute_array_index_type): New function, split out from\n\tgrokdeclarator.\n\t(create_array_type_for_decl): Likewise.\n\t(grokdeclarator): Use them.\n\n\t* semantics.c (expand_stmt): Don't suspend_momentary or\n\tresume_momentary.\n\nFrom-SVN: r30504", "tree": {"sha": "1dc16b4181c12f5a35fec4e46b1d2f48415a1060", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1dc16b4181c12f5a35fec4e46b1d2f48415a1060"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2848ad0fd63d89a3e9989b93f6b31ad1498386b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2848ad0fd63d89a3e9989b93f6b31ad1498386b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2848ad0fd63d89a3e9989b93f6b31ad1498386b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2848ad0fd63d89a3e9989b93f6b31ad1498386b6/comments", "author": null, "committer": null, "parents": [{"sha": "d26f8097a31ff6a47d4b0861677ba44a8a25efec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d26f8097a31ff6a47d4b0861677ba44a8a25efec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d26f8097a31ff6a47d4b0861677ba44a8a25efec"}], "stats": {"total": 360, "additions": 205, "deletions": 155}, "files": [{"sha": "c37c04e9cbdb3083d67137c5af8a90f4ead5577b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2848ad0fd63d89a3e9989b93f6b31ad1498386b6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2848ad0fd63d89a3e9989b93f6b31ad1498386b6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2848ad0fd63d89a3e9989b93f6b31ad1498386b6", "patch": "@@ -1,3 +1,13 @@\n+1999-11-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* decl.c (compute_array_index_type): New function, split out from\n+\tgrokdeclarator.\n+\t(create_array_type_for_decl): Likewise.\n+\t(grokdeclarator): Use them.\n+\n+\t* semantics.c (expand_stmt): Don't suspend_momentary or\n+\tresume_momentary.\n+\n Thu Nov 11 12:42:11 MST 1999\tDiego Novillo <dnovillo@cygnus.com>\n \n \t* init.c (init_init_processing): Header information for"}, {"sha": "83d24c55d125a1d1cab3ef67a48d575d61f16943", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 195, "deletions": 152, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2848ad0fd63d89a3e9989b93f6b31ad1498386b6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2848ad0fd63d89a3e9989b93f6b31ad1498386b6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2848ad0fd63d89a3e9989b93f6b31ad1498386b6", "patch": "@@ -175,6 +175,8 @@ static void destroy_local_static PROTO((tree));\n static void destroy_local_var PROTO((tree));\n static void finish_constructor_body PROTO((void));\n static void finish_destructor_body PROTO((void));\n+static tree compute_array_index_type PROTO((tree, tree));\n+static tree create_array_type_for_decl PROTO((tree, tree, tree));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -8755,6 +8757,195 @@ check_static_variable_definition (decl, type)\n   return 0;\n }\n \n+/* Given the SIZE (i.e., number of elements) in an array, compute an\n+   appropriate index type for the array.  If non-NULL, NAME is the\n+   name of the thing being declared.  */\n+\n+static tree\n+compute_array_index_type (name, size)\n+     tree name;\n+     tree size;\n+{\n+  tree itype;\n+\n+  /* The size might be the result of a cast. */\n+  STRIP_TYPE_NOPS (size);\n+\n+  /* It might be a const variable or enumeration constant.  */\n+  if (TREE_READONLY_DECL_P (size))\n+    size = decl_constant_value (size);\n+\n+  /* If this involves a template parameter, it will be a constant at\n+     instantiation time, but we don't know what the value is yet.\n+     Even if no template parameters are involved, we may an expression\n+     that is not a constant; we don't even simplify `1 + 2' when\n+     processing a template.  */\n+  if (processing_template_decl)\n+    {\n+      /* Resolve a qualified reference to an enumerator or static\n+\t const data member of ours.  */\n+      if (TREE_CODE (size) == SCOPE_REF\n+\t  && TREE_OPERAND (size, 0) == current_class_type)\n+\t{\n+\t  tree t = lookup_field (current_class_type,\n+\t\t\t\t TREE_OPERAND (size, 1), 0, 0);\n+\t  if (t)\n+\t    size = t;\n+\t}\n+\n+      return build_index_type (build_min (MINUS_EXPR, sizetype,\n+\t\t\t\t\t  size, integer_one_node));\n+    }\n+\n+  /* The array bound must be an integer type.  */\n+  if (TREE_CODE (TREE_TYPE (size)) != INTEGER_TYPE\n+      && TREE_CODE (TREE_TYPE (size)) != ENUMERAL_TYPE\n+      && TREE_CODE (TREE_TYPE (size)) != BOOLEAN_TYPE)\n+    {\n+      cp_error (\"size of array `%D' has non-integer type\", name);\n+      size = integer_one_node;\n+    }\n+\n+  /* Normally, the array-bound will be a constant.  */\n+  if (TREE_CONSTANT (size))\n+    {\n+      /* Check to see if the array bound overflowed.  Make that an\n+\t error, no matter how generous we're being.  */\n+      int old_flag_pedantic_errors = flag_pedantic_errors;\n+      int old_pedantic = pedantic;\n+      pedantic = flag_pedantic_errors = 1;\n+      constant_expression_warning (size);\n+      pedantic = old_pedantic;\n+      flag_pedantic_errors = old_flag_pedantic_errors;\n+\n+      /* An array must have a positive number of elements.  */\n+      if (INT_CST_LT (size, integer_zero_node))\n+\t{\n+\t  cp_error (\"size of array `%D' is negative\", name);\n+\t  size = integer_one_node;\n+\t}\n+      /* Except that an extension we allow zero-sized arrays.  We\n+\t always allow them in system headers because glibc uses \n+\t them.  */\n+      else if (integer_zerop (size) && pedantic && !in_system_header)\n+\tcp_pedwarn (\"ANSI C++ forbids zero-size array `%D'\", name);\n+    }\n+\n+  /* Compute the index of the largest element in the array.  It is\n+     one less than the number of elements in the array.  */\n+  itype\n+    = fold (build_binary_op (MINUS_EXPR,\n+\t\t\t     cp_convert (ssizetype, size),\n+\t\t\t     cp_convert (ssizetype,\n+\t\t\t\t\t integer_one_node)));\n+  \n+  /* Check for variable-sized arrays.  We allow such things as an\n+     extension, even though they are not allowed in ANSI/ISO C++.  */\n+  if (!TREE_CONSTANT (itype))\n+    {\n+      if (pedantic)\n+\t{\n+\t  if (name)\n+\t    cp_pedwarn (\"ANSI C++ forbids variable-size array `%D'\",\n+\t\t\tname);\n+\t  else\n+\t    cp_pedwarn (\"ANSI C++ forbids variable-size array\");\n+\t}\n+\n+      /* Create a variable-sized array index type.  */\n+      itype = variable_size (itype);\n+    }\n+  /* Make sure that there was no overflow when creating to a signed\n+     index type.  (For example, on a 32-bit machine, an array with\n+     size 2^32 - 1 is too big.)  */\n+  else if (TREE_OVERFLOW (itype))\n+    {\n+      error (\"overflow in array dimension\");\n+      TREE_OVERFLOW (itype) = 0;\n+    }\n+  \n+  /* Create and return the appropriate index type.  */\n+  return build_index_type (itype);\n+}\n+\n+/* Returns an ARRAY_TYPE for an array with SIZE elements of the\n+   indicated TYPE.  If non-NULL, NAME is the NAME of the declaration\n+   with this type.  */\n+\n+static tree\n+create_array_type_for_decl (name, type, size)\n+     tree name;\n+     tree type;\n+     tree size;\n+{\n+  tree itype = NULL_TREE;\n+  const char* error_msg;\n+\n+  /* If things have already gone awry, bail now.  */\n+  if (type == error_mark_node || size == error_mark_node)\n+    return error_mark_node;\n+\n+  /* Assume that everything will go OK.  */\n+  error_msg = NULL;\n+\n+  /* There are some types which cannot be array elements.  */\n+  switch (TREE_CODE (type))\n+    {\n+    case VOID_TYPE:\n+      error_msg = \"array of void\";\n+      break;\n+\n+    case FUNCTION_TYPE:\n+      error_msg = \"array of functions\";\n+      break;\n+\n+    case REFERENCE_TYPE:\n+      error_msg = \"array of references\";\n+      break;\n+\n+    case OFFSET_TYPE:\n+      error_msg = \"array of data members\";\n+      break;\n+\n+    case METHOD_TYPE:\n+      error_msg = \"array of function members\";\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* If something went wrong, issue an error-message and return.  */\n+  if (error_msg)\n+    {\n+      if (name)\n+\tcp_error (\"declaration of `%D' as %s\", name, error_msg);\n+      else\n+\tcp_error (\"creating %s\", error_msg);\n+\n+      return error_mark_node;\n+    }\n+\n+  /* [dcl.array]\n+     \n+     The constant expressions that specify the bounds of the arrays\n+     can be omitted only for the first member of the sequence.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE && !TYPE_DOMAIN (type))\n+    {\n+      cp_error (\"declaration of `%D' as multidimensional array\",\n+\t\tname);\n+      cp_error (\"must have bounds for all dimensions except the first\");\n+\n+      return error_mark_node;\n+    }\n+\n+  /* Figure out the index type for the array.  */\n+  if (size)\n+    itype = compute_array_index_type (name, size);\n+\n+  return build_cplus_array_type (type, itype);\n+}\n+\n /* Given declspecs and a declarator,\n    determine the name and type of the object declared\n    and construct a ..._DECL node for it.\n@@ -9759,166 +9950,18 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \tcase ARRAY_REF:\n \t  {\n-\t    register tree itype = NULL_TREE;\n-\t    register tree size = TREE_OPERAND (declarator, 1);\n-\t    /* The index is a signed object `sizetype' bits wide.  */\n-\t    tree index_type = signed_type (sizetype);\n-\n-\t    declarator = TREE_OPERAND (declarator, 0);\n+\t    register tree size;\n \n-\t    /* Check for some types that there cannot be arrays of.  */\n-\n-\t    if (TREE_CODE (type) == VOID_TYPE)\n-\t      {\n-\t\tcp_error (\"declaration of `%D' as array of voids\", dname);\n-\t\ttype = error_mark_node;\n-\t      }\n-\n-\t    if (TREE_CODE (type) == FUNCTION_TYPE)\n-\t      {\n-\t\tcp_error (\"declaration of `%D' as array of functions\", dname);\n-\t\ttype = error_mark_node;\n-\t      }\n-\n-\t    /* ARM $8.4.3: Since you can't have a pointer to a reference,\n-\t       you can't have arrays of references.  If we allowed them,\n-\t       then we'd be saying x[i] is valid for an array x, but\n-\t       then you'd have to ask: what does `*(x + i)' mean?  */\n-\t    if (TREE_CODE (type) == REFERENCE_TYPE)\n-\t      {\n-\t\tif (decl_context == TYPENAME)\n-\t\t  cp_error (\"cannot make arrays of references\");\n-\t\telse\n-\t\t  cp_error (\"declaration of `%D' as array of references\",\n-\t\t\t    dname);\n-\t\ttype = error_mark_node;\n-\t      }\n-\n-\t    if (TREE_CODE (type) == OFFSET_TYPE)\n-\t      {\n-\t\t  cp_error (\"declaration of `%D' as array of data members\",\n-\t\t\t    dname);\n-\t\ttype = error_mark_node;\n-\t      }\n-\n-\t    if (TREE_CODE (type) == METHOD_TYPE)\n-\t      {\n-\t\tcp_error (\"declaration of `%D' as array of function members\",\n-\t\t\t  dname);\n-\t\ttype = error_mark_node;\n-\t      }\n-\n-\t    if (size == error_mark_node)\n-\t      type = error_mark_node;\n-\t    else if (TREE_CODE (type) == ARRAY_TYPE && !TYPE_DOMAIN (type))\n-\t      {\n-\t\t/* [dcl.array]\n-\n-\t\t   the constant expressions that specify the bounds of\n-\t\t   the arrays can be omitted only for the first member\n-\t\t   of the sequence.  */\n-\t\tcp_error (\"declaration of `%D' as multidimensional array\",\n-\t\t\t  dname);\n-\t\tcp_error (\"must have bounds for all dimensions except the first\");\n-\t\ttype = error_mark_node;\n-\t      }\n-\n-\t    if (type == error_mark_node)\n-\t      continue;\n+\t    size = TREE_OPERAND (declarator, 1);\n \n \t    /* VC++ spells a zero-sized array with [].  */\n \t    if (size == NULL_TREE && decl_context == FIELD && !\tstaticp\n \t\t&& ! RIDBIT_SETP (RID_TYPEDEF, specbits))\n \t      size = integer_zero_node;\n \n-\t    if (size)\n-\t      {\n-\t\t/* Might be a cast. */\n-\t\tif (TREE_CODE (size) == NOP_EXPR\n-\t\t    && TREE_TYPE (size) == TREE_TYPE (TREE_OPERAND (size, 0)))\n-\t\t  size = TREE_OPERAND (size, 0);\n-\t\tif (TREE_READONLY_DECL_P (size))\n-\t\t  size = decl_constant_value (size);\n-\n-\t\t/* If this involves a template parameter, it will be a\n-\t\t   constant at instantiation time, but we don't know\n-\t\t   what the value is yet.  Even if no template\n-\t\t   parameters are involved, we may an expression that\n-\t\t   is not a constant; we don't even simplify `1 + 2'\n-\t\t   when processing a template.  */\n-\t\tif (processing_template_decl)\n-\t\t  {\n-\t\t    /* Resolve a qualified reference to an enumerator or\n-\t\t       static const data member of ours.  */\n-\t\t    if (TREE_CODE (size) == SCOPE_REF\n-\t\t\t&& TREE_OPERAND (size, 0) == current_class_type)\n-\t\t      {\n-\t\t\ttree t = lookup_field (current_class_type,\n-\t\t\t\t\t       TREE_OPERAND (size, 1), 0, 0);\n-\t\t\tif (t)\n-\t\t\t  size = t;\n-\t\t      }\n-\n-\t\t    itype = build_index_type (build_min\n-\t\t      (MINUS_EXPR, sizetype, size, integer_one_node));\n-\t\t    goto dont_grok_size;\n-\t\t  }\n-\n-\t\tif (TREE_CODE (TREE_TYPE (size)) != INTEGER_TYPE\n-\t\t    && TREE_CODE (TREE_TYPE (size)) != ENUMERAL_TYPE\n-\t\t    && TREE_CODE (TREE_TYPE (size)) != BOOLEAN_TYPE)\n-\t\t  {\n-\t\t    cp_error (\"size of array `%D' has non-integer type\",\n-\t\t\t      dname);\n-\t\t    size = integer_one_node;\n-\t\t  }\n-\t\tif (pedantic && !in_system_header && integer_zerop (size))\n-\t\t  cp_pedwarn (\"ANSI C++ forbids zero-size array `%D'\", dname);\n-\t\tif (TREE_CONSTANT (size))\n-\t\t  {\n-\t\t    int old_flag_pedantic_errors = flag_pedantic_errors;\n-\t\t    int old_pedantic = pedantic;\n-\t\t    pedantic = flag_pedantic_errors = 1;\n-\t\t    /* Always give overflow errors on array subscripts.  */\n-\t\t    constant_expression_warning (size);\n-\t\t    pedantic = old_pedantic;\n-\t\t    flag_pedantic_errors = old_flag_pedantic_errors;\n-\t\t    if (INT_CST_LT (size, integer_zero_node))\n-\t\t      {\n-\t\t\tcp_error (\"size of array `%D' is negative\", dname);\n-\t\t\tsize = integer_one_node;\n-\t\t      }\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    if (pedantic)\n-\t\t      {\n-\t\t\tif (dname)\n-\t\t\t  cp_pedwarn (\"ANSI C++ forbids variable-size array `%D'\",\n-\t\t\t\t      dname);\n-\t\t\telse\n-\t\t\t  cp_pedwarn (\"ANSI C++ forbids variable-size array\");\n-\t\t      }\n-\t\t  }\n-\n-\t\titype\n-\t\t  = fold (build_binary_op (MINUS_EXPR,\n-\t\t\t\t\t   cp_convert (index_type, size),\n-\t\t\t\t\t   cp_convert (index_type,\n-\t\t\t\t\t\t       integer_one_node)));\n-\t\tif (! TREE_CONSTANT (itype))\n-\t\t  itype = variable_size (itype);\n-\t\telse if (TREE_OVERFLOW (itype))\n-\t\t  {\n-\t\t    error (\"overflow in array dimension\");\n-\t\t    TREE_OVERFLOW (itype) = 0;\n-\t\t  }\n-\n-\t\titype = build_index_type (itype);\n-\t      }\n+\t    declarator = TREE_OPERAND (declarator, 0);\n \n-\t  dont_grok_size:\n-\t    type = build_cplus_array_type (type, itype);\n+\t    type = create_array_type_for_decl (dname, type, size);\n \t    ctype = NULL_TREE;\n \t  }\n \t  break;"}, {"sha": "31bbd984a1c1ec60472cdeb00ca45bd57321cf42", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2848ad0fd63d89a3e9989b93f6b31ad1498386b6/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2848ad0fd63d89a3e9989b93f6b31ad1498386b6/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=2848ad0fd63d89a3e9989b93f6b31ad1498386b6", "patch": "@@ -2267,7 +2267,6 @@ expand_stmt (t)\n \tcase DECL_STMT:\n \t  {\n \t    tree decl;\n-\t    int i = suspend_momentary ();\n \n \t    emit_line_note (input_filename, lineno);\n \t    decl = DECL_STMT_DECL (t);\n@@ -2290,8 +2289,6 @@ expand_stmt (t)\n \t      }\n \t    else if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n \t      make_rtl_for_local_static (decl);\n-\n-\t    resume_momentary (i);\n \t  }\n \t  break;\n "}]}