{"sha": "a0c996ea7f9fa3f69670cc70642b61ca82c91f3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBjOTk2ZWE3ZjlmYTNmNjk2NzBjYzcwNjQyYjYxY2E4MmM5MWYzZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-02-29T22:43:15Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-02-29T22:43:15Z"}, "message": "compiler: Fix handling of invalid types within invalid types.\n\nFrom-SVN: r184674", "tree": {"sha": "3db4b308fcc58d4435855f40dafafe7ab8c873fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3db4b308fcc58d4435855f40dafafe7ab8c873fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0c996ea7f9fa3f69670cc70642b61ca82c91f3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0c996ea7f9fa3f69670cc70642b61ca82c91f3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0c996ea7f9fa3f69670cc70642b61ca82c91f3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0c996ea7f9fa3f69670cc70642b61ca82c91f3e/comments", "author": null, "committer": null, "parents": [{"sha": "a339c9d606640b6161b8c623041bd6c403b4bcb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a339c9d606640b6161b8c623041bd6c403b4bcb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a339c9d606640b6161b8c623041bd6c403b4bcb3"}], "stats": {"total": 27, "additions": 7, "deletions": 20}, "files": [{"sha": "6abe21d2522aa3678031eaeab9f6bc154f313b18", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0c996ea7f9fa3f69670cc70642b61ca82c91f3e/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0c996ea7f9fa3f69670cc70642b61ca82c91f3e/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=a0c996ea7f9fa3f69670cc70642b61ca82c91f3e", "patch": "@@ -4116,7 +4116,6 @@ Struct_type::do_verify()\n   Struct_field_list* fields = this->fields_;\n   if (fields == NULL)\n     return true;\n-  bool ret = true;\n   for (Struct_field_list::iterator p = fields->begin();\n        p != fields->end();\n        ++p)\n@@ -4126,27 +4125,24 @@ Struct_type::do_verify()\n \t{\n \t  error_at(p->location(), \"struct field type is incomplete\");\n \t  p->set_type(Type::make_error_type());\n-\t  ret = false;\n \t}\n       else if (p->is_anonymous())\n \t{\n \t  if (t->named_type() != NULL && t->points_to() != NULL)\n \t    {\n \t      error_at(p->location(), \"embedded type may not be a pointer\");\n \t      p->set_type(Type::make_error_type());\n-\t      return false;\n \t    }\n-\t  if (t->points_to() != NULL\n-\t      && t->points_to()->interface_type() != NULL)\n+\t  else if (t->points_to() != NULL\n+\t\t   && t->points_to()->interface_type() != NULL)\n \t    {\n \t      error_at(p->location(),\n \t\t       \"embedded type may not be pointer to interface\");\n \t      p->set_type(Type::make_error_type());\n-\t      return false;\n \t    }\n \t}\n     }\n-  return ret;\n+  return true;\n }\n \n // Whether this contains a pointer.\n@@ -5206,10 +5202,7 @@ bool\n Array_type::do_verify()\n {\n   if (!this->verify_length())\n-    {\n-      this->length_ = Expression::make_error(this->length_->location());\n-      return false;\n-    }\n+    this->length_ = Expression::make_error(this->length_->location());\n   return true;\n }\n \n@@ -5899,10 +5892,7 @@ Map_type::do_verify()\n {\n   // The runtime support uses \"map[void]void\".\n   if (!this->key_type_->is_comparable() && !this->key_type_->is_void_type())\n-    {\n-      error_at(this->location_, \"invalid map key type\");\n-      return false;\n-    }\n+    error_at(this->location_, \"invalid map key type\");\n   return true;\n }\n \n@@ -7885,7 +7875,6 @@ Named_type::do_verify()\n   if (this->local_methods_ != NULL)\n     {\n       Struct_type* st = this->type_->struct_type();\n-      bool found_dup = false;\n       if (st != NULL)\n \t{\n \t  for (Bindings::const_declarations_iterator p =\n@@ -7899,12 +7888,9 @@ Named_type::do_verify()\n \t\t  error_at(p->second->location(),\n \t\t\t   \"method %qs redeclares struct field name\",\n \t\t\t   Gogo::message_name(name).c_str());\n-\t\t  found_dup = true;\n \t\t}\n \t    }\n \t}\n-      if (found_dup)\n-\treturn false;\n     }\n \n   return true;"}, {"sha": "3fe80488a4923440db613eb48ebd0d041d9e39e3", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0c996ea7f9fa3f69670cc70642b61ca82c91f3e/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0c996ea7f9fa3f69670cc70642b61ca82c91f3e/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=a0c996ea7f9fa3f69670cc70642b61ca82c91f3e", "patch": "@@ -510,7 +510,8 @@ class Type\n \n   // Verify the type.  This is called after parsing, and verifies that\n   // types are complete and meet the language requirements.  This\n-  // returns false if the type is invalid.\n+  // returns false if the type is invalid and we should not continue\n+  // traversing it.\n   bool\n   verify()\n   { return this->do_verify(); }"}]}