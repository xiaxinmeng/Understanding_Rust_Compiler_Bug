{"sha": "baad4c48a85a354d2bf1b17e5aff71203c08adea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFhZDRjNDhhODVhMzU0ZDJiZjFiMTdlNWFmZjcxMjAzYzA4YWRlYQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-09-19T23:37:05Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-09-19T23:37:05Z"}, "message": "Extend -Wstringop-overflow to detect out-of-bounds accesses to array parameters.\n\ngcc/ChangeLog:\n\n\tPR c/50584\n\t* builtins.c (warn_for_access): Add argument.  Distinguish between\n\treads and writes.\n\t(check_access): Add argument.  Distinguish between reads and writes.\n\t(gimple_call_alloc_size): Set range even on failure.\n\t(gimple_parm_array_size): New function.\n\t(compute_objsize): Call it.\n\t(check_memop_access): Pass check_access an additional argument.\n\t(expand_builtin_memchr, expand_builtin_strcat): Same.\n\t(expand_builtin_strcpy, expand_builtin_stpcpy_1): Same.\n\t(expand_builtin_stpncpy, check_strncat_sizes): Same.\n\t(expand_builtin_strncat, expand_builtin_strncpy): Same.\n\t(expand_builtin_memcmp): Same.\n\t* builtins.h (compute_objsize): Declare a new overload.\n\t(gimple_parm_array_size): Declare.\n\t(check_access): Add argument.\n\t* calls.c (append_attrname): Simplify.\n\t(maybe_warn_rdwr_sizes): Handle internal attribute access.\n\t* tree-ssa-uninit.c (maybe_warn_pass_by_reference): Avoid adding\n\tquotes.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c/50584\n\t* c-c++-common/Wsizeof-pointer-memaccess1.c: Disable new expected\n\twarnings.\n\t* g++.dg/ext/attr-access.C: Update text of expected warnings.\n\t* gcc.dg/Wstringop-overflow-23.c: Same.\n\t* gcc.dg/Wstringop-overflow-24.c: Same.\n\t* gcc.dg/attr-access-none.c: Same.\n\t* gcc.dg/dfp/composite-type.c: Prune expected warnings.\n\t* gcc.dg/torture/pr57147-1.c: Add a member to an otherwise empty\n\tstruct to avoid a warning.\n\t* gcc.dg/torture/pr57147-3.c: Same.\n\t* gcc.dg/Warray-bounds-30.c: Adjust.\n\t* gcc.dg/attr-access-none.c: Same.\n\t* gcc.dg/Wstringop-overflow-40.c: New test.\n\t* gcc.dg/attr-access-2.c: New test.", "tree": {"sha": "b29b89090fb1eb5436ff4183d0b11ba2dc765a4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b29b89090fb1eb5436ff4183d0b11ba2dc765a4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/baad4c48a85a354d2bf1b17e5aff71203c08adea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baad4c48a85a354d2bf1b17e5aff71203c08adea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/baad4c48a85a354d2bf1b17e5aff71203c08adea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baad4c48a85a354d2bf1b17e5aff71203c08adea/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72be80e47d059f33ff11f5015b9494c42b4e0a12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72be80e47d059f33ff11f5015b9494c42b4e0a12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72be80e47d059f33ff11f5015b9494c42b4e0a12"}], "stats": {"total": 830, "additions": 624, "deletions": 206}, "files": [{"sha": "45efc1c3992a1b99b25da6be13b4073947c9bcd2", "filename": "gcc/builtins.c", "status": "modified", "additions": 233, "deletions": 81, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=baad4c48a85a354d2bf1b17e5aff71203c08adea", "patch": "@@ -183,7 +183,6 @@ static void maybe_emit_chk_warning (tree, enum built_in_function);\n static void maybe_emit_sprintf_chk_warning (tree, enum built_in_function);\n static void maybe_emit_free_warning (tree);\n static tree fold_builtin_object_size (tree, tree);\n-static tree compute_objsize (tree, int, access_ref *, const vr_values * = NULL);\n static bool get_range (tree, signop, offset_int[2], const vr_values * = NULL);\n static bool check_read_access (tree, tree, tree = NULL_TREE, int = 1);\n \n@@ -3490,93 +3489,189 @@ maybe_warn_for_bound (int opt, location_t loc, tree exp, tree func,\n }\n \n /* For an expression EXP issue an access warning controlled by option OPT\n-   with access to a region SLEN bytes in size in the RANGE of sizes.  */\n+   with access to a region SIZE bytes in size in the RANGE of sizes.\n+   WRITE is true for a write access, READ for a read access, neither for\n+   call that may or may not perform an access but for which the range\n+   is expected to valid.\n+   Returns true when a warning has been issued.  */\n \n static bool\n-warn_for_access (location_t loc, tree func, tree exp, tree range[2],\n-\t\t tree slen, bool access)\n+warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n+\t\t tree size, bool write, bool read)\n {\n   bool warned = false;\n \n-  if (access)\n+  if (write && read)\n+    {\n+      if (tree_int_cst_equal (range[0], range[1]))\n+\twarned = (func\n+\t\t  ? warning_n (loc, opt, tree_to_uhwi (range[0]),\n+\t\t\t       \"%K%qD accessing %E byte in a region \"\n+\t\t\t       \"of size %E\",\n+\t\t\t       \"%K%qD accessing %E bytes in a region \"\n+\t\t\t       \"of size %E\",\n+\t\t\t       exp, func, range[0], size)\n+\t\t  : warning_n (loc, opt, tree_to_uhwi (range[0]),\n+\t\t\t       \"%Kaccessing %E byte in a region \"\n+\t\t\t       \"of size %E\",\n+\t\t\t       \"%Kaccessing %E bytes in a region \"\n+\t\t\t       \"of size %E\",\n+\t\t\t       exp, range[0], size));\n+      else if (tree_int_cst_sign_bit (range[1]))\n+\t{\n+\t  /* Avoid printing the upper bound if it's invalid.  */\n+\t  warned = (func\n+\t\t    ? warning_at (loc, opt,\n+\t\t\t\t  \"%K%qD accessing %E or more bytes in \"\n+\t\t\t\t  \"a region of size %E\",\n+\t\t\t\t  exp, func, range[0], size)\n+\t\t    : warning_at (loc, opt,\n+\t\t\t\t  \"%Kaccessing %E or more bytes in \"\n+\t\t\t\t  \"a region of size %E\",\n+\t\t\t\t  exp, range[0], size));\n+\t}\n+      else\n+\twarned = (func\n+\t\t  ? warning_at (loc, opt,\n+\t\t\t\t\"%K%qD accessing between %E and %E bytes \"\n+\t\t\t\t\"in a region of size %E\",\n+\t\t\t\texp, func, range[0], range[1],\n+\t\t\t\tsize)\n+\t\t  : warning_at (loc, opt,\n+\t\t\t\t\"%Kaccessing between %E and %E bytes \"\n+\t\t\t\t\"in a region of size %E\",\n+\t\t\t\texp, range[0], range[1],\n+\t\t\t\tsize));\n+      return warned;\n+    }\n+\n+  if (write)\n+    {\n+      if (tree_int_cst_equal (range[0], range[1]))\n+\twarned = (func\n+\t\t  ? warning_n (loc, opt, tree_to_uhwi (range[0]),\n+\t\t\t       \"%K%qD writing %E byte into a region \"\n+\t\t\t       \"of size %E overflows the destination\",\n+\t\t\t       \"%K%qD writing %E bytes into a region \"\n+\t\t\t       \"of size %E overflows the destination\",\n+\t\t\t       exp, func, range[0], size)\n+\t\t  : warning_n (loc, opt, tree_to_uhwi (range[0]),\n+\t\t\t       \"%Kwriting %E byte into a region \"\n+\t\t\t       \"of size %E overflows the destination\",\n+\t\t\t       \"%Kwriting %E bytes into a region \"\n+\t\t\t       \"of size %E overflows the destination\",\n+\t\t\t       exp, range[0], size));\n+      else if (tree_int_cst_sign_bit (range[1]))\n+\t{\n+\t  /* Avoid printing the upper bound if it's invalid.  */\n+\t  warned = (func\n+\t\t    ? warning_at (loc, opt,\n+\t\t\t\t  \"%K%qD writing %E or more bytes into \"\n+\t\t\t\t  \"a region of size %E overflows \"\n+\t\t\t\t  \"the destination\",\n+\t\t\t\t  exp, func, range[0], size)\n+\t\t    : warning_at (loc, opt,\n+\t\t\t\t  \"%Kwriting %E or more bytes into \"\n+\t\t\t\t  \"a region of size %E overflows \"\n+\t\t\t\t  \"the destination\",\n+\t\t\t\t  exp, range[0], size));\n+\t}\n+      else\n+\twarned = (func\n+\t\t  ? warning_at (loc, opt,\n+\t\t\t\t\"%K%qD writing between %E and %E bytes \"\n+\t\t\t\t\"into a region of size %E overflows \"\n+\t\t\t\t\"the destination\",\n+\t\t\t\texp, func, range[0], range[1],\n+\t\t\t\tsize)\n+\t\t  : warning_at (loc, opt,\n+\t\t\t\t\"%Kwriting between %E and %E bytes \"\n+\t\t\t\t\"into a region of size %E overflows \"\n+\t\t\t\t\"the destination\",\n+\t\t\t\texp, range[0], range[1],\n+\t\t\t\tsize));\n+      return warned;\n+    }\n+\n+  if (read)\n     {\n       if (tree_int_cst_equal (range[0], range[1]))\n \twarned = (func\n \t\t  ? warning_n (loc, OPT_Wstringop_overread,\n \t\t\t       tree_to_uhwi (range[0]),\n \t\t\t       \"%K%qD reading %E byte from a region of size %E\",\n-\t\t\t       \"%K%qD reading %E bytes from a region of size %E\",\n-\t\t\t       exp, func, range[0], slen)\n+\t\t\t       \"%K%qD reading %E bytes from a region of size %E\",\t\t\t       exp, func, range[0], size)\n \t\t  : warning_n (loc, OPT_Wstringop_overread,\n \t\t\t       tree_to_uhwi (range[0]),\n \t\t\t       \"%Kreading %E byte from a region of size %E\",\n \t\t\t       \"%Kreading %E bytes from a region of size %E\",\n-\t\t\t       exp, range[0], slen));\n+\t\t\t       exp, range[0], size));\n       else if (tree_int_cst_sign_bit (range[1]))\n \t{\n \t  /* Avoid printing the upper bound if it's invalid.  */\n \t  warned = (func\n \t\t    ? warning_at (loc, OPT_Wstringop_overread,\n-\t\t\t\t  \"%K%qD reading %E or more bytes from a region \"\n-\t\t\t\t  \"of size %E\",\n-\t\t\t\t  exp, func, range[0], slen)\n+\t\t\t\t  \"%K%qD reading %E or more bytes from \"\n+\t\t\t\t  \"a region of size %E\",\n+\t\t\t\t  exp, func, range[0], size)\n \t\t    : warning_at (loc, OPT_Wstringop_overread,\n \t\t\t\t  \"%Kreading %E or more bytes from a region \"\n \t\t\t\t  \"of size %E\",\n-\t\t\t\t  exp, range[0], slen));\n+\t\t\t\t  exp, range[0], size));\n \t}\n       else\n \twarned = (func\n \t\t  ? warning_at (loc, OPT_Wstringop_overread,\n \t\t\t\t\"%K%qD reading between %E and %E bytes from \"\n \t\t\t\t\"a region of size %E\",\n-\t\t\t\texp, func, range[0], range[1], slen)\n-\t\t  : warning_at (loc, OPT_Wstringop_overread,\n-\t\t\t\t\"%Kreading between %E and %E bytes from \"\n+\t\t\t\texp, func, range[0], range[1], size)\n+\t\t  : warning_at (loc, opt,\n+\t\t\t\t\"%K reading between %E and %E bytes from \"\n \t\t\t\t\"a region of size %E\",\n-\t\t\t\texp, range[0], range[1], slen));\n+\t\t\t\texp, range[0], range[1], size));\n \n       if (warned)\n \tTREE_NO_WARNING (exp) = true;\n \n       return warned;\n     }\n \n-  if (tree_int_cst_equal (range[0], range[1]))\n+  if (tree_int_cst_equal (range[0], range[1])\n+      || tree_int_cst_sign_bit (range[1]))\n     warned = (func\n \t      ? warning_n (loc, OPT_Wstringop_overread,\n \t\t\t   tree_to_uhwi (range[0]),\n \t\t\t   \"%K%qD epecting %E byte in a region of size %E\",\n \t\t\t   \"%K%qD expecting %E bytes in a region of size %E\",\n-\t\t\t   exp, func, range[0], slen)\n+\t\t\t   exp, func, range[0], size)\n \t      : warning_n (loc, OPT_Wstringop_overread,\n \t\t\t   tree_to_uhwi (range[0]),\n \t\t\t   \"%Kexpecting %E byte in a region of size %E\",\n \t\t\t   \"%Kexpecting %E bytes in a region of size %E\",\n-\t\t\t   exp, range[0], slen));\n+\t\t\t   exp, range[0], size));\n   else if (tree_int_cst_sign_bit (range[1]))\n     {\n       /* Avoid printing the upper bound if it's invalid.  */\n       warned = (func\n \t\t? warning_at (loc, OPT_Wstringop_overread,\n \t\t\t      \"%K%qD expecting %E or more bytes in a region \"\n \t\t\t      \"of size %E\",\n-\t\t\t      exp, func, range[0], slen)\n+\t\t\t      exp, func, range[0], size)\n \t\t: warning_at (loc, OPT_Wstringop_overread,\n \t\t\t      \"%Kexpecting %E or more bytes in a region \"\n \t\t\t      \"of size %E\",\n-\t\t\t      exp, range[0], slen));\n+\t\t\t      exp, range[0], size));\n     }\n   else\n     warned = (func\n \t      ? warning_at (loc, OPT_Wstringop_overread,\n \t\t\t    \"%K%qD expecting between %E and %E bytes in \"\n \t\t\t    \"a region of size %E\",\n-\t\t\t    exp, func, range[0], range[1], slen)\n+\t\t\t    exp, func, range[0], range[1], size)\n \t      : warning_at (loc, OPT_Wstringop_overread,\n \t\t\t    \"%Kexpectting between %E and %E bytes in \"\n \t\t\t    \"a region of size %E\",\n-\t\t\t    exp, range[0], range[1], slen));\n+\t\t\t    exp, range[0], range[1], size));\n \n   if (warned)\n     TREE_NO_WARNING (exp) = true;\n@@ -3759,8 +3854,9 @@ get_size_range (tree bound, tree range[2], const offset_int bndrng[2])\n    When DSTWRITE is null LEN is checked to verify that it doesn't exceed\n    SIZE_MAX.\n \n-   ACCESS is true for accesses, false for simple size checks in calls\n-   to functions that neither read from nor write to the region.\n+   WRITE is true for write accesses, READ is true for reads.  Both are\n+   false for simple size checks in calls to functions that neither read\n+   from nor write to the region.\n \n    When nonnull, PAD points to a more detailed description of the access.\n \n@@ -3857,6 +3953,11 @@ check_access (tree exp, tree dstwrite,\n   get_size_range (dstwrite, range, pad ? pad->dst.bndrng : NULL);\n \n   tree func = get_callee_fndecl (exp);\n+  /* Read vs write access by built-ins can be determined from the const\n+     qualifiers on the pointer argument.  In the absence of attribute\n+     access, non-const qualified pointer arguments to user-defined\n+     functions are assumed to both read and write the objects.  */\n+  const bool builtin = func ? fndecl_built_in_p (func) : false;\n \n   /* First check the number of bytes to be written against the maximum\n      object size.  */\n@@ -3913,51 +4014,18 @@ check_access (tree exp, tree dstwrite,\n \t\t\t\t      \"the destination\",\n \t\t\t\t      exp, range[0], dstsize));\n \t    }\n-\t  else if (tree_int_cst_equal (range[0], range[1]))\n-\t    warned = (func\n-\t\t      ? warning_n (loc, OPT_Wstringop_overflow_,\n-\t\t\t\t   tree_to_uhwi (range[0]),\n-\t\t\t\t   \"%K%qD writing %E byte into a region \"\n-\t\t\t\t   \"of size %E overflows the destination\",\n-\t\t\t\t   \"%K%qD writing %E bytes into a region \"\n-\t\t\t\t   \"of size %E overflows the destination\",\n-\t\t\t\t   exp, func, range[0], dstsize)\n-\t\t      : warning_n (loc, OPT_Wstringop_overflow_,\n-\t\t\t\t   tree_to_uhwi (range[0]),\n-\t\t\t\t   \"%Kwriting %E byte into a region \"\n-\t\t\t\t   \"of size %E overflows the destination\",\n-\t\t\t\t   \"%Kwriting %E bytes into a region \"\n-\t\t\t\t   \"of size %E overflows the destination\",\n-\t\t\t\t   exp, range[0], dstsize));\n-\t  else if (tree_int_cst_sign_bit (range[1]))\n+\t  else\n \t    {\n-\t      /* Avoid printing the upper bound if it's invalid.  */\n-\t      warned = (func\n-\t\t\t? warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t\t      \"%K%qD writing %E or more bytes into \"\n-\t\t\t\t      \"a region of size %E overflows \"\n-\t\t\t\t      \"the destination\",\n-\t\t\t\t      exp, func, range[0], dstsize)\n-\t\t\t: warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t\t      \"%Kwriting %E or more bytes into \"\n-\t\t\t\t      \"a region of size %E overflows \"\n-\t\t\t\t      \"the destination\",\n-\t\t\t\t      exp, range[0], dstsize));\n+\t      const bool read\n+\t\t= mode == access_read_only || mode == access_read_write;\n+\t      const bool write\n+\t\t= mode == access_write_only || mode == access_read_write;\n+\t      warned = warn_for_access (loc, func, exp,\n+\t\t\t\t\tOPT_Wstringop_overflow_,\n+\t\t\t\t\trange, dstsize,\n+\t\t\t\t\twrite, read && !builtin);\n \t    }\n-\t  else\n-\t    warned = (func\n-\t\t      ? warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t\t    \"%K%qD writing between %E and %E bytes \"\n-\t\t\t\t    \"into a region of size %E overflows \"\n-\t\t\t\t    \"the destination\",\n-\t\t\t\t    exp, func, range[0], range[1],\n-\t\t\t\t    dstsize)\n-\t\t      : warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t\t    \"%Kwriting between %E and %E bytes \"\n-\t\t\t\t    \"into a region of size %E overflows \"\n-\t\t\t\t    \"the destination\",\n-\t\t\t\t    exp, range[0], range[1],\n-\t\t\t\t    dstsize));\n+\n \t  if (warned)\n \t    {\n \t      TREE_NO_WARNING (exp) = true;\n@@ -4037,10 +4105,15 @@ check_access (tree exp, tree dstwrite,\n       location_t loc = tree_nonartificial_location (exp);\n       loc = expansion_point_location_if_in_system_header (loc);\n \n-      if (warn_for_access (loc, func, exp, range, slen, mode)\n-\t  && pad)\n-\tinform_access (pad->src, access_read_only);\n-\n+      const bool read\n+\t= mode == access_read_only || mode == access_read_write;\n+      if (warn_for_access (loc, func, exp, OPT_Wstringop_overread, range,\n+\t\t\t   slen, false, read))\n+\t{\n+\t  TREE_NO_WARNING (exp) = true;\n+\t  if (pad)\n+\t    inform_access (pad->src, access_read_only);\n+\t}\n       return false;\n     }\n \n@@ -4065,8 +4138,11 @@ check_read_access (tree exp, tree src, tree bound /* = NULL_TREE */,\n }\n \n /* If STMT is a call to an allocation function, returns the constant\n-   size of the object allocated by the call represented as sizetype.\n-   If nonnull, sets RNG1[] to the range of the size.  */\n+   maximum size of the object allocated by the call represented as\n+   sizetype.  If nonnull, sets RNG1[] to the range of the size.\n+   When nonnull, uses RVALS for range information, otherwise calls\n+   get_range_info to get it.\n+   Returns null when STMT is not a call to a valid allocation function.  */\n \n tree\n gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n@@ -4122,8 +4198,14 @@ gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n   if (!rng1)\n     rng1 = rng1_buf;\n \n+  const int prec = ADDR_MAX_PRECISION;\n+  const tree size_max = TYPE_MAX_VALUE (sizetype);\n   if (!get_range (size, rng1, rvals))\n-    return NULL_TREE;\n+    {\n+      /* Use the full non-negative range on failure.  */\n+      rng1[0] = wi::zero (prec);\n+      rng1[1] = wi::to_wide (size_max, prec);\n+    }\n \n   if (argidx2 > nargs && TREE_CODE (size) == INTEGER_CST)\n     return fold_convert (sizetype, size);\n@@ -4133,10 +4215,13 @@ gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n   tree n = argidx2 < nargs ? gimple_call_arg (stmt, argidx2) : integer_one_node;\n   wide_int rng2[2];\n   if (!get_range (n, rng2, rvals))\n-    return NULL_TREE;\n+    {\n+      /* As above, use the full non-negative range on failure.  */\n+      rng2[0] = wi::zero (prec);\n+      rng2[1] = wi::to_wide (size_max, prec);\n+    }\n \n   /* Extend to the maximum precision to avoid overflow.  */\n-  const int prec = ADDR_MAX_PRECISION;\n   rng1[0] = wide_int::from (rng1[0], prec, UNSIGNED);\n   rng1[1] = wide_int::from (rng1[1], prec, UNSIGNED);\n   rng2[0] = wide_int::from (rng2[0], prec, UNSIGNED);\n@@ -4146,7 +4231,6 @@ gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n      of SIZE_MAX and the product of the upper bounds as a constant.  */\n   rng1[0] = rng1[0] * rng2[0];\n   rng1[1] = rng1[1] * rng2[1];\n-  tree size_max = TYPE_MAX_VALUE (sizetype);\n   if (wi::gtu_p (rng1[1], wi::to_wide (size_max, prec)))\n     {\n       rng1[1] = wi::to_wide (size_max);\n@@ -4156,6 +4240,61 @@ gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n   return wide_int_to_tree (sizetype, rng1[1]);\n }\n \n+/* For an access to an object referenced to by the function parameter PTR\n+   of pointer type, and set RNG[] to the range of sizes of the object\n+   obtainedfrom the attribute access specification for the current function.\n+   Return the function parameter on success and null otherwise.  */\n+\n+tree\n+gimple_parm_array_size (tree ptr, wide_int rng[2],\n+\t\t\tconst vr_values * /* = NULL */)\n+{\n+  /* For a function argument try to determine the byte size of the array\n+     from the current function declaratation (e.g., attribute access or\n+     related).  */\n+  tree var = SSA_NAME_VAR (ptr);\n+  if (TREE_CODE (var) != PARM_DECL)\n+    return NULL_TREE;\n+\n+  const unsigned prec = TYPE_PRECISION (sizetype);\n+\n+  rdwr_map rdwr_idx;\n+  attr_access *access = get_parm_access (rdwr_idx, var);\n+  if (!access)\n+    return NULL_TREE;\n+\n+  if (access->sizarg != UINT_MAX)\n+    {\n+      /* TODO: Try to extract the range from the argument based on\n+\t those of subsequent assertions or based on known calls to\n+\t the current function.  */\n+      return NULL_TREE;\n+    }\n+\n+  if (!access->minsize)\n+    return NULL_TREE;\n+\n+  /* Only consider ordinary array bound at level 2 (or above if it's\n+     ever added).  */\n+  if (warn_array_parameter < 2 && !access->static_p)\n+    return NULL_TREE;\n+\n+  rng[0] = wi::zero (prec);\n+  rng[1] = wi::uhwi (access->minsize, prec);\n+  /* If the PTR argument points to an array multiply MINSIZE by the size\n+     of array element type.  Otherwise, multiply it by the size of what\n+     the pointer points to.  */\n+  tree eltype = TREE_TYPE (TREE_TYPE (ptr));\n+  if (TREE_CODE (eltype) == ARRAY_TYPE)\n+    eltype = TREE_TYPE (eltype);\n+  tree size = TYPE_SIZE_UNIT (eltype);\n+  if (!size || TREE_CODE (size) != INTEGER_CST)\n+    return NULL_TREE;\n+\n+  rng[1] *= wi::to_wide (size, prec);\n+  return var;\n+}\n+\n /* Wrapper around the wide_int overload of get_range.  Returns the same\n    result but accepts offset_int instead.  */\n \n@@ -4348,6 +4487,21 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \t  return false;\n \t}\n \n+      if (gimple_nop_p (stmt))\n+\t{\n+\t  /* For a function argument try to determine the byte size\n+\t     of the array from the current function declaratation\n+\t     (e.g., attribute access or related).  */\n+\t  wide_int wr[2];\n+\t  tree ref = gimple_parm_array_size (ptr, wr, rvals);\n+\t  if (!ref)\n+\t    return NULL_TREE;\n+\t  pref->ref = ref;\n+\t  pref->sizrng[0] = offset_int::from (wr[0], UNSIGNED);\n+\t  pref->sizrng[1] = offset_int::from (wr[1], UNSIGNED);\n+\t  return true;\n+\t}\n+\n       /* TODO: Handle PHI.  */\n \n       if (!is_gimple_assign (stmt))\n@@ -4400,7 +4554,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n /* A \"public\" wrapper around the above.  Clients should use this overload\n    instead.  */\n \n-static tree\n+tree\n compute_objsize (tree ptr, int ostype, access_ref *pref,\n \t\t const vr_values *rvals /* = NULL */)\n {\n@@ -4977,7 +5131,6 @@ expand_builtin_stpncpy (tree exp, rtx)\n   /* The size of the destination object.  */\n   tree destsize = compute_objsize (dest, warn_stringop_overflow - 1, &data.dst);\n   check_access (exp, len, /*maxread=*/len, src, destsize, data.mode, &data);\n-\n   return NULL_RTX;\n }\n \n@@ -5130,7 +5283,6 @@ expand_builtin_strncat (tree exp, rtx)\n \n   check_access (exp, /*dstwrite=*/NULL_TREE, maxread, srclen,\n \t\tdestsize, data.mode, &data);\n-\n   return NULL_RTX;\n }\n "}, {"sha": "8136b768750bd60ed35ad298f2ca752b0512d453", "filename": "gcc/builtins.h", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=baad4c48a85a354d2bf1b17e5aff71203c08adea", "patch": "@@ -133,13 +133,6 @@ extern tree fold_call_stmt (gcall *, bool);\n extern void set_builtin_user_assembler_name (tree decl, const char *asmspec);\n extern bool is_simple_builtin (tree);\n extern bool is_inexpensive_builtin (tree);\n-\n-class vr_values;\n-tree gimple_call_alloc_size (gimple *, wide_int[2] = NULL,\n-\t\t\t     const vr_values * = NULL);\n-extern tree compute_objsize (tree, int, tree * = NULL, tree * = NULL,\n-\t\t\t     const vr_values * = NULL);\n-\n extern bool readonly_data_expr (tree exp);\n extern bool init_target_chars (void);\n extern unsigned HOST_WIDE_INT target_newline;\n@@ -202,7 +195,15 @@ struct access_data\n   access_mode mode;\n };\n \n-extern bool check_access (tree, tree, tree, tree, tree,\n-\t\t\t  access_mode, const access_data * = NULL);\n+class vr_values;\n+extern tree gimple_call_alloc_size (gimple *, wide_int[2] = NULL,\n+\t\t\t\t    const vr_values * = NULL);\n+extern tree gimple_parm_array_size (tree, wide_int[2], const vr_values * = NULL);\n+extern tree compute_objsize (tree, int, tree * = NULL, tree * = NULL,\n+\t\t\t     const vr_values * = NULL);\n+extern tree compute_objsize (tree, int, access_ref *, const vr_values * = NULL);\n+\n+extern bool check_access (tree, tree, tree, tree, tree, access_mode,\n+\t\t\t  const access_data * = NULL);\n \n #endif /* GCC_BUILTINS_H */"}, {"sha": "0e5c696c4638febea5a854b210ae615831eb3523", "filename": "gcc/calls.c", "status": "modified", "additions": 121, "deletions": 93, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=baad4c48a85a354d2bf1b17e5aff71203c08adea", "patch": "@@ -58,6 +58,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"gimple-fold.h\"\n \n+#include \"tree-pretty-print.h\"\n+\n /* Like PREFERRED_STACK_BOUNDARY but in units of bytes, not bits.  */\n #define STACK_BYTES (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)\n \n@@ -1898,36 +1900,20 @@ fntype_argno_type (tree fntype, unsigned argno)\n   return NULL_TREE;\n }\n \n-/* Helper to append the \"rdwr\" attribute specification described\n-   by ACCESS to the array ATTRSTR with size STRSIZE.  Used in\n+/* Helper to append the \"human readable\" attribute access specification\n+   described by ACCESS to the array ATTRSTR with size STRSIZE.  Used in\n    diagnostics.  */\n \n static inline void\n append_attrname (const std::pair<int, attr_access> &access,\n \t\t char *attrstr, size_t strsize)\n {\n-  /* Append the relevant attribute to the string.  This (deliberately)\n-     appends the attribute pointer operand even when none was specified.  */\n-  size_t len = strlen (attrstr);\n-\n-  const char* const atname\n-    = (access.second.mode == access_read_only\n-       ? \"read_only\"\n-       : (access.second.mode == access_write_only\n-\t  ? \"write_only\"\n-\t  : (access.second.mode == access_read_write\n-\t     ? \"read_write\" : \"none\")));\n-\n-  const char *sep = len ? \", \" : \"\";\n-\n-  if (access.second.sizarg == UINT_MAX)\n-    snprintf (attrstr + len, strsize - len,\n-\t      \"%s%s (%i)\", sep, atname,\n-\t      access.second.ptrarg + 1);\n-  else\n-    snprintf (attrstr + len, strsize - len,\n-\t      \"%s%s (%i, %i)\", sep, atname,\n-\t      access.second.ptrarg + 1, access.second.sizarg + 1);\n+  if (access.second.internal_p)\n+    return;\n+\n+  tree str = access.second.to_external_string ();\n+  gcc_assert (strsize >= (size_t) TREE_STRING_LENGTH (str));\n+  strcpy (attrstr, TREE_STRING_POINTER (str));\n }\n \n /* Iterate over attribute access read-only, read-write, and write-only\n@@ -1938,6 +1924,7 @@ static void\n maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n {\n   auto_diagnostic_group adg;\n+  bool warned = false;\n \n   /* A string describing the attributes that the warnings issued by this\n      function apply to.  Used to print one informational note per function\n@@ -1966,35 +1953,40 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n       if (!access.second.ptr)\n \tcontinue;\n \n-      tree argtype = fntype_argno_type (fntype, ptridx);\n-      argtype = TREE_TYPE (argtype);\n+      tree ptrtype = fntype_argno_type (fntype, ptridx);\n+      tree argtype = TREE_TYPE (ptrtype);\n \n-      tree size;\n+      /* The size of the access by the call.  */\n+      tree access_size;\n       if (sizidx == -1)\n \t{\n-\t  /* If only the pointer attribute operand was specified\n-\t     and not size, set SIZE to the size of one element of\n-\t     the pointed to type to detect smaller objects (null\n-\t     pointers are diagnosed in this case only if\n-\t     the pointer is also declared with attribute nonnull.  */\n-\t  size = size_one_node;\n+\t  /* If only the pointer attribute operand was specified and\n+\t     not size, set SIZE to the greater of MINSIZE or size of\n+\t     one element of the pointed to type to detect smaller\n+\t     objects (null pointers are diagnosed in this case only\n+\t     if the pointer is also declared with attribute nonnull.  */\n+\t  if (access.second.minsize\n+\t      && access.second.minsize != HOST_WIDE_INT_M1U)\n+\t    access_size = build_int_cstu (sizetype, access.second.minsize);\n+\t  else\n+\t    access_size = size_one_node;\n \t}\n       else\n-\tsize = rwm->get (sizidx)->size;\n+\taccess_size = rwm->get (sizidx)->size;\n \n+      bool warned = false;\n+      location_t loc = EXPR_LOCATION (exp);\n       tree ptr = access.second.ptr;\n       tree sizrng[2] = { size_zero_node, build_all_ones_cst (sizetype) };\n-      if (get_size_range (size, sizrng, true)\n+      if (get_size_range (access_size, sizrng, true)\n \t  && tree_int_cst_sgn (sizrng[0]) < 0\n \t  && tree_int_cst_sgn (sizrng[1]) < 0)\n \t{\n \t  /* Warn about negative sizes.  */\n-\t  bool warned = false;\n-\t  location_t loc = EXPR_LOCATION (exp);\n \t  if (tree_int_cst_equal (sizrng[0], sizrng[1]))\n \t    warned = warning_at (loc, OPT_Wstringop_overflow_,\n \t\t\t\t \"%Kargument %i value %E is negative\",\n-\t\t\t\t exp, sizidx + 1, size);\n+\t\t\t\t exp, sizidx + 1, access_size);\n \t  else\n \t    warned = warning_at (loc, OPT_Wstringop_overflow_,\n \t\t\t\t \"%Kargument %i range [%E, %E] is negative\",\n@@ -2011,44 +2003,56 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n \t{\n \t  if (COMPLETE_TYPE_P (argtype))\n \t    {\n-\t      /* Multiple SIZE by the size of the type the pointer\n-\t\t argument points to.  If it's incomplete the size\n-\t\t is used as is.  */\n-\t      size = NULL_TREE;\n+\t      /* Multiply ACCESS_SIZE by the size of the type the pointer\n+\t\t argument points to.  If it's incomplete the size is used\n+\t\t as is.  */\n+\t      access_size = NULL_TREE;\n \t      if (tree argsize = TYPE_SIZE_UNIT (argtype))\n \t\tif (TREE_CODE (argsize) == INTEGER_CST)\n \t\t  {\n \t\t    const int prec = TYPE_PRECISION (sizetype);\n \t\t    wide_int minsize = wi::to_wide (sizrng[0], prec);\n \t\t    minsize *= wi::to_wide (argsize, prec);\n-\t\t    size = wide_int_to_tree (sizetype, minsize);\n+\t\t    access_size = wide_int_to_tree (sizetype, minsize);\n \t\t  }\n \t    }\n \t}\n       else\n-\tsize = NULL_TREE;\n+\taccess_size = NULL_TREE;\n \n-      if (sizidx >= 0\n-\t  && integer_zerop (ptr)\n-\t  && tree_int_cst_sgn (sizrng[0]) > 0)\n+      if (integer_zerop (ptr))\n \t{\n-\t  /* Warn about null pointers with positive sizes.  This is\n-\t     different from also declaring the pointer argument with\n-\t     attribute nonnull when the function accepts null pointers\n-\t     only when the corresponding size is zero.  */\n-\t  bool warned = false;\n-\t  const location_t loc = EXPR_LOC_OR_LOC (ptr, EXPR_LOCATION (exp));\n-\t  if (tree_int_cst_equal (sizrng[0], sizrng[1]))\n-\t    warned = warning_at (loc, OPT_Wnonnull,\n-\t\t\t\t \"%Kargument %i is null but the corresponding \"\n-\t\t\t\t \"size argument %i value is %E\",\n-\t\t\t\t exp, ptridx + 1, sizidx + 1, size);\n-\t  else\n-\t    warned = warning_at (loc, OPT_Wnonnull,\n-\t\t\t\t \"%Kargument %i is null but the corresponding \"\n-\t\t\t\t \"size argument %i range is [%E, %E]\",\n-\t\t\t\t exp, ptridx + 1, sizidx + 1,\n-\t\t\t\t sizrng[0], sizrng[1]);\n+\t  if (sizidx >= 0 && tree_int_cst_sgn (sizrng[0]) > 0)\n+\t    {\n+\t      /* Warn about null pointers with positive sizes.  This is\n+\t\t different from also declaring the pointer argument with\n+\t\t attribute nonnull when the function accepts null pointers\n+\t\t only when the corresponding size is zero.  */\n+\t      if (tree_int_cst_equal (sizrng[0], sizrng[1]))\n+\t\twarned = warning_at (loc, OPT_Wnonnull,\n+\t\t\t\t     \"%Kargument %i is null but \"\n+\t\t\t\t     \"the corresponding size argument %i \"\n+\t\t\t\t     \"value is %E\",\n+\t\t\t\t     exp, ptridx + 1, sizidx + 1, access_size);\n+\t      else\n+\t\twarned = warning_at (loc, OPT_Wnonnull,\n+\t\t\t\t     \"%Kargument %i is null but \"\n+\t\t\t\t     \"the corresponding size argument %i \"\n+\t\t\t\t     \"range is [%E, %E]\",\n+\t\t\t\t     exp, ptridx + 1, sizidx + 1,\n+\t\t\t\t     sizrng[0], sizrng[1]);\n+\t    }\n+\t  else if (access_size && access.second.static_p)\n+\t    {\n+\t      /* Warn about null pointers for [static N] array arguments\n+\t\t but do not warn for ordinary (i.e., nonstatic) arrays.  */\n+\t      warned = warning_at (loc, OPT_Wnonnull,\n+\t\t\t\t   \"%Kargument %i to %<%T[static %E]%> null \"\n+\t\t\t\t   \"where non-null expected\",\n+\t\t\t\t   exp, ptridx + 1, argtype,\n+\t\t\t\t   sizrng[0]);\n+\t    }\n+\n \t  if (warned)\n \t    {\n \t      append_attrname (access, attrstr, sizeof attrstr);\n@@ -2057,18 +2061,20 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n \t    }\n \t}\n \n-      tree objsize = compute_objsize (ptr, 0);\n+      access_data data (ptr, access.second.mode, NULL_TREE, false,\n+\t\t\tNULL_TREE, false);\n+      access_ref* const pobj = (access.second.mode == access_write_only\n+\t\t\t\t? &data.dst : &data.src);\n+      tree objsize = compute_objsize (ptr, 1, pobj);\n \n-      tree srcsize;\n-      if (access.second.mode == access_write_only)\n+      /* The size of the destination or source object.  */\n+      tree dstsize = NULL_TREE, srcsize = NULL_TREE;\n+      if (access.second.mode == access_read_only\n+\t  || access.second.mode == access_none)\n \t{\n-\t  /* For a write-only argument there is no source.  */\n-\t  srcsize = NULL_TREE;\n-\t}\n-      else\n-\t{\n-\t  /* For read-only and read-write attributes also set the source\n-\t     size.  */\n+\t  /* For a read-only argument there is no destination.  For\n+\t     no access, set the source as well and differentiate via\n+\t     the access flag below.  */\n \t  srcsize = objsize;\n \t  if (access.second.mode == access_read_only\n \t      || access.second.mode == access_none)\n@@ -2080,31 +2086,53 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n \t      objsize = NULL_TREE;\n \t    }\n \t}\n+      else\n+\tdstsize = objsize;\n \n-      /* Clear the no-warning bit in case it was set in a prior\n-\t iteration so that accesses via different arguments are\n-\t diagnosed.  */\n+      /* Clear the no-warning bit in case it was set by check_access\n+\t in a prior iteration so that accesses via different arguments\n+\t are diagnosed.  */\n       TREE_NO_WARNING (exp) = false;\n-      check_access (exp, size, /*maxread=*/ NULL_TREE, srcsize, objsize,\n-\t\t    access.second.mode);\n+      access_mode mode = data.mode;\n+      if (mode == access_deferred)\n+\tmode = TYPE_READONLY (argtype) ? access_read_only : access_read_write;\n+      check_access (exp, access_size, /*maxread=*/ NULL_TREE, srcsize,\n+\t\t    dstsize, mode, &data);\n \n       if (TREE_NO_WARNING (exp))\n-\t/* If check_access issued a warning above, append the relevant\n-\t   attribute to the string.  */\n-\tappend_attrname (access, attrstr, sizeof attrstr);\n-    }\n+\t{\n+\t  warned = true;\n \n-  if (!*attrstr)\n-    return;\n+\t  if (access.second.internal_p)\n+\t    inform (loc, \"referencing argument %u of type %qT\",\n+\t\t    ptridx + 1, ptrtype);\n+\t  else\n+\t    /* If check_access issued a warning above, append the relevant\n+\t       attribute to the string.  */\n+\t    append_attrname (access, attrstr, sizeof attrstr);\n+\t}\n+    }\n \n-  if (fndecl)\n-    inform (DECL_SOURCE_LOCATION (fndecl),\n-\t    \"in a call to function %qD declared with attribute %qs\",\n-\t    fndecl, attrstr);\n-  else\n-    inform (EXPR_LOCATION (fndecl),\n-\t    \"in a call with type %qT and attribute %qs\",\n-\t    fntype, attrstr);\n+  if (*attrstr)\n+    {\n+      if (fndecl)\n+\tinform (DECL_SOURCE_LOCATION (fndecl),\n+\t\t\"in a call to function %qD declared with attribute %qs\",\n+\t\tfndecl, attrstr);\n+      else\n+\tinform (EXPR_LOCATION (fndecl),\n+\t\t\"in a call with type %qT and attribute %qs\",\n+\t\tfntype, attrstr);\n+    }\n+  else if (warned)\n+    {\n+      if (fndecl)\n+\tinform (DECL_SOURCE_LOCATION (fndecl),\n+\t\t\"in a call to function %qD\", fndecl);\n+      else\n+\tinform (EXPR_LOCATION (fndecl),\n+\t\t\"in a call with type %qT\", fntype);\n+    }\n \n   /* Set the bit in case if was cleared and not set above.  */\n   TREE_NO_WARNING (exp) = true;"}, {"sha": "38e06ba5e6295f5da0928f49a47cedaade62b37e", "filename": "gcc/testsuite/c-c++-common/Wsizeof-pointer-memaccess1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess1.c?ref=baad4c48a85a354d2bf1b17e5aff71203c08adea", "patch": "@@ -1,7 +1,7 @@\n /* Test -Wsizeof-pointer-memaccess warnings.  */\n /* { dg-do compile } */\n-/* { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument\" } */\n-/* { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-c++-compat\" { target c } } */\n+/* { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-stringop-overflow\" } */\n+/* { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-c++-compat -Wno-stringop-overflow\" { target c } } */\n /* { dg-require-effective-target alloca } */\n \n typedef __SIZE_TYPE__ size_t;"}, {"sha": "b7b2a5fc4bfc338c6be6dcc3f05a18d9a7a2f1a9", "filename": "gcc/testsuite/g++.dg/ext/attr-access.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-access.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-access.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-access.C?ref=baad4c48a85a354d2bf1b17e5aff71203c08adea", "patch": "@@ -42,8 +42,8 @@ void call_rdwrp1_rdwrr2_O0 (void)\n   int32_t x[1] = { };\n \n   rdwrp1_rdwrr2 (x, x[0]);\n-  rdwrp1_rdwrr2 (x, x[1]);        // { dg-warning \"writing 4 bytes into a region of size 0\" }\n-  rdwrp1_rdwrr2 (x + 1, x[0]);    // { dg-warning \"writing 4 bytes into a region of size 0\" }\n+  rdwrp1_rdwrr2 (x, x[1]);        // { dg-warning \"accessing 4 bytes in a region of size 0\" }\n+  rdwrp1_rdwrr2 (x + 1, x[0]);    // { dg-warning \"accessing 4 bytes in a region of size 0\" }\n }\n \n void call_wop1_wor2_O0 (void)\n@@ -84,12 +84,12 @@ void call_rdwrp1_rdwrr2_O1 (void)\n   int32_t &r2 = *(int32_t*)((char*)p1 + 1);\n \n   rdwrp1_rdwrr2 (x, x[0]);\n-  rdwrp1_rdwrr2 (x, x[1]);        // { dg-warning \"writing 4 bytes into a region of size 0\" }\n-  rdwrp1_rdwrr2 (x + 1, x[0]);    // { dg-warning \"writing 4 bytes into a region of size 0\" }\n+  rdwrp1_rdwrr2 (x, x[1]);        // { dg-warning \"accessing 4 bytes in a region of size 0\" }\n+  rdwrp1_rdwrr2 (x + 1, x[0]);    // { dg-warning \"accessing 4 bytes in a region of size 0\" }\n \n   rdwrp1_rdwrr2 (p0, r0);\n-  rdwrp1_rdwrr2 (p0, r2);         // { dg-warning \"writing 4 bytes into a region of size 2\" }\n-  rdwrp1_rdwrr2 (p1, r0);         // { dg-warning \"writing 4 bytes into a region of size 3\" }\n+  rdwrp1_rdwrr2 (p0, r2);         // { dg-warning \"accessing 4 bytes in a region of size 2\" }\n+  rdwrp1_rdwrr2 (p1, r0);         // { dg-warning \"accessing 4 bytes in a region of size 3\" }\n }\n \n void call_wop1_wor2_O1 (void)"}, {"sha": "048a95d6dcffc340f899748b6c399d380e750499", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-30.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-30.c?ref=baad4c48a85a354d2bf1b17e5aff71203c08adea", "patch": "@@ -73,8 +73,7 @@ void test_global_int_array (void)\n \n   T (&p[min]);      /* { dg-warning \"subscript -\\[0-9\\]+ is \\(below|outside\\) array bounds of .int\\\\\\[1].\" } */\n   T (&p[-1]);       /* { dg-warning \"subscript -1 is \\(below|outside\\) array bounds of .int\\\\\\[1].\" } */\n-  T (&p[0]);\n-  T (&p[1]);\n+  T (&p[0], &p[1]);\n   T (&p[2]);        /* { dg-warning \"subscript 2 is \\(above|outside\\) array bounds of .int\\\\\\[1].\" } */\n   T (&p[max]);      /* { dg-warning \"subscript \\[0-9\\]+ is \\(above|outside\\) array bounds of .int\\\\\\[1].\" } */\n "}, {"sha": "bbc12102d1406294e2a9fb0e5c304b84498cfc61", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-23.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-23.c?ref=baad4c48a85a354d2bf1b17e5aff71203c08adea", "patch": "@@ -21,7 +21,7 @@ typedef __INT32_TYPE__ int32_t;\n /* Exercise null pointer detection.  */\n \n RDONLY (2, 1) void\n-rd2_1 (int, const void*);       // { dg-message \"in a call to function 'rd2_1' declared with attribute 'read_only \\\\\\(2, 1\\\\\\)\" }\n+rd2_1 (int, const void*);       // { dg-message \"in a call to function 'rd2_1' declared with attribute 'access \\\\\\(read_only, 2, 1\\\\\\)\" \"note\" }\n \n void test_rd2_1 (void)\n {\n@@ -45,7 +45,7 @@ void test_rd2_1 (void)\n }\n \n WRONLY (3, 1) void\n-wr3_1 (int, int, void*);        // { dg-message \"in a call to function 'wr3_1' declared with attribute 'write_only \\\\\\(3, 1\\\\\\)\" }\n+wr3_1 (int, int, void*);        // { dg-message \"in a call to function 'wr3_1' declared with attribute 'access \\\\\\(write_only, 3, 1\\\\\\)\" }\n \n void test_wr3_1 (void)\n {"}, {"sha": "049d1c6981c44fead4aad805ec3547e33becaec2", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-24.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-24.c?ref=baad4c48a85a354d2bf1b17e5aff71203c08adea", "patch": "@@ -23,7 +23,7 @@ extern char d1[1], d2[2], d3[3];\n    the attribute without a size operand.  */\n \n RDONLY (1) void\n-rd1_int (const int32_t*);   // { dg-message \"in a call to function 'rd1_int' declared with attribute 'read_only \\\\\\(1\\\\\\)'\" }\n+rd1_int (const int32_t*);   // { dg-message \"in a call to function 'rd1_int' declared with attribute 'access \\\\\\(read_only, 1\\\\\\)'\" \"note\" }\n \n void test_rd1_int (void)\n {\n@@ -39,7 +39,7 @@ void test_rd1_int (void)\n    the attribute and with non-zero size.  */\n \n RDONLY (2, 1) void\n-rd2_1 (int, const void*);   // { dg-message \"in a call to function 'rd2_1' declared with attribute 'read_only \\\\\\(2, 1\\\\\\)\" }\n+rd2_1 (int, const void*);   // { dg-message \"in a call to function 'rd2_1' declared with attribute 'access \\\\\\(read_only, 2, 1\\\\\\)\" \"note\" }\n \n void test_rd2_1 (void)\n {\n@@ -49,7 +49,7 @@ void test_rd2_1 (void)\n }\n \n WRONLY (3, 1) void\n-wr3_1 (int, int, void*);    // { dg-message \"in a call to function 'wr3_1' declared with attribute 'write_only \\\\\\(3, 1\\\\\\)\" }\n+wr3_1 (int, int, void*);    // { dg-message \"in a call to function 'wr3_1' declared with attribute 'access \\\\\\(write_only, 3, 1\\\\\\)\" \"note\" }\n \n void test_wr3_1 (void)\n {\n@@ -157,7 +157,7 @@ void test_rd6_1_wr5_2_rd4_3 (void)\n {\n   rd6_1_wr5_2_rd4_3 (7, 2, 1, d1, d2, s3);   // { dg-warning \"reading 7 bytes from a region of size 3\" }\n   rd6_1_wr5_2_rd4_3 (3, 8, 1, d1, d2, s3);   // { dg-warning \"writing 8 bytes into a region of size 2\" }\n-  rd6_1_wr5_2_rd4_3 (3, 2, 9, d1, d2, s3);   // { dg-warning \"writing 9 bytes into a region of size 1\" }\n+  rd6_1_wr5_2_rd4_3 (3, 2, 9, d1, d2, s3);   // { dg-warning \"accessing 9 bytes in a region of size 1\" }\n }\n \n "}, {"sha": "386c92dc7a813db66423c7d2083e2a75798b0987", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-40.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-40.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-40.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-40.c?ref=baad4c48a85a354d2bf1b17e5aff71203c08adea", "patch": "@@ -0,0 +1,120 @@\n+/* PR c/50584 - No warning for passing small array to C99 static array\n+   declarator\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+typedef __INT16_TYPE__ int16_t;\n+\n+void fa2 (int16_t[2]);\n+void fxa2 (int16_t[2]) __attribute__ ((nonnull));\n+\n+void fas2 (int16_t[static 2]);\n+\n+void fvla (unsigned n, int16_t[n]);\n+\n+void test_array_1_dim (void)\n+{\n+  int16_t a1[1];\n+  int16_t a2[2];\n+  int16_t i;\n+\n+  fa2 (0);\n+  fa2 (a2);\n+  fa2 (a1);                   // { dg-warning \"'fa2' accessing 4 bytes in a region of size 2 \" }\n+  fa2 (&i);                   // { dg-warning \"'fa2' accessing 4 bytes in a region of size 2 \" }\n+\n+  fxa2 (0);                   // { dg-warning \"\\\\\\[-Wnonnull\" }\n+  fxa2 (a2);\n+  fxa2 (a1);                  // { dg-warning \"'fxa2' accessing 4 bytes in a region of size 2 \" }\n+  fxa2 (&i);                  // { dg-warning \"'fxa2' accessing 4 bytes in a region of size 2 \" }\n+\n+  fas2 (0);                   // { dg-warning \"\\\\\\[-Wnonnull\" }\n+  fas2 (a2);\n+  fas2 (a1);                  // { dg-warning \"'fas2' accessing 4 bytes in a region of size 2 \" }\n+  fas2 (&i);                  // { dg-warning \"'fas2' accessing 4 bytes in a region of size 2 \" }\n+\n+  fvla (1, 0);                // { dg-warning \"\\\\\\[-Wnonnull\" }\n+  fvla (1, &i);\n+  fvla (2, a2);\n+  fvla (2, a1);               // { dg-warning \"'fvla' accessing 4 bytes in a region of size 2 \" }\n+  fvla (2, &i);               // { dg-warning \"'fvla' accessing 4 bytes in a region of size 2 \" }\n+}\n+\n+\n+void fac2 (const int16_t[2]);\n+void fxac2 (const int16_t[2]) __attribute__ ((nonnull));\n+\n+void facs2 (const int16_t[static 2]);\n+\n+void fvlac (unsigned n, const int16_t[n]);\n+\n+void test_const_array_1_dim (void)\n+{\n+  int16_t a1[1];\n+  int16_t a2[2];\n+  int16_t i;\n+\n+  fac2 (0);\n+  fac2 (a2);\n+  fac2 (a1);                  // { dg-warning \"'fac2' reading 4 bytes from a region of size 2 \" }\n+  fac2 (&i);                  // { dg-warning \"'fac2' reading 4 bytes from a region of size 2 \" }\n+\n+  fxac2 (0);                  // { dg-warning \"\\\\\\[-Wnonnull\" }\n+  fxac2 (a2);\n+  fxac2 (a1);                 // { dg-warning \"'fxac2' reading 4 bytes from a region of size 2 \" }\n+  fxac2 (&i);                 // { dg-warning \"'fxac2' reading 4 bytes from a region of size 2 \" }\n+\n+  facs2 (0);                  // { dg-warning \"\\\\\\[-Wnonnull\" }\n+  facs2 (a2);\n+  facs2 (a1);                 // { dg-warning \"'facs2' reading 4 bytes from a region of size 2 \" }\n+  facs2 (&i);                 // { dg-warning \"'facs2' reading 4 bytes from a region of size 2 \" }\n+\n+  fvlac (1, 0);               // { dg-warning \"\\\\\\[-Wnonnull\" }\n+  fvlac (1, &i);\n+  fvlac (2, a2);\n+  fvlac (2, a1);              // { dg-warning \"'fvlac' reading 4 bytes from a region of size 2 \" }\n+  fvlac (2, &i);              // { dg-warning \"'fvlac' reading 4 bytes from a region of size 2 \" }\n+}\n+\n+\n+void fca3x5 (int16_t[3][5]);\n+void fcas5x7 (int16_t[static 5][7]);\n+\n+struct Snx5 { int16_t a3x5[3][5], a2x5[2][5], a1x5[1][5]; };\n+struct Snx7 { int16_t a5x7[5][7], a4x7[4][7], a1x7[1][7]; };\n+struct S0x7 { int x; int16_t a0x7[0][7]; };\n+\n+void test_array_2_dim (struct Snx5 *px5, struct Snx7 *px7, struct S0x7 *p0x7)\n+{\n+  int16_t a0x5[0][5], a1x5[1][5], a2x5[2][5], a3x5[3][5], a4x5[4][5];\n+\n+  fca3x5 (a3x5);\n+  fca3x5 (a4x5);\n+  fca3x5 (a2x5);              // { dg-warning \"'fca3x5' accessing 30 bytes in a region of size 20\" }\n+  fca3x5 (a1x5);              // { dg-warning \"'fca3x5' accessing 30 bytes in a region of size 10\" }\n+  fca3x5 (a0x5);              // { dg-warning \"'fca3x5' accessing 30 bytes in a region of size 0\" }\n+\n+  fca3x5 (px5->a3x5);\n+  fca3x5 (px5->a2x5);         // { dg-warning \"'fca3x5' accessing 30 bytes in a region of size 20\" }\n+  fca3x5 (px5->a1x5);         // { dg-warning \"'fca3x5' accessing 30 bytes in a region of size 10\" \"pr96346\" { xfail *-*-* } }\n+\n+  {\n+    int16_t (*pa2x5)[5] = &a2x5[0];\n+    fca3x5 (pa2x5);           // { dg-warning \"'fca3x5' accessing 30 bytes in a region of size 10\" }\n+    ++pa2x5;\n+    fca3x5 (pa2x5);           // { dg-warning \"'fca3x5' accessing 30 bytes \" }\n+  }\n+\n+  int16_t a0x7[0][7], a1x7[1][7], a4x7[4][7], a5x7[5][7], a99x7[99][7];\n+  fcas5x7 (a99x7);\n+  fcas5x7 (a5x7);\n+  fcas5x7 (a4x7);             // { dg-warning \"'fcas5x7' accessing 70 bytes in a region of size 56\" }\n+  fcas5x7 (a1x7);             // { dg-warning \"'fcas5x7' accessing 70 bytes in a region of size 14\" }\n+  fcas5x7 (a0x7);             // { dg-warning \"'fcas5x7' accessing 70 bytes in a region of size 0\" }\n+\n+  fcas5x7 (px7->a5x7);\n+  fcas5x7 (px7->a4x7);        // { dg-warning \"'fcas5x7' accessing 70 bytes in a region of size 56\" }\n+  fcas5x7 (px7->a1x7);        // { dg-warning \"'fcas5x7' accessing 70 bytes in a region of size 14\" \"pr96346\" { xfail *-*-* } }\n+\n+  fcas5x7 (p0x7->a0x7);       // { dg-warning \"'fcas5x7' accessing 70 bytes in a region of size 0\" \"pr96346\" { xfail *-*-* } }\n+}"}, {"sha": "74762610f98b3b857f9434e14d60315b9b9578d5", "filename": "gcc/testsuite/gcc.dg/attr-access-2.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-2.c?ref=baad4c48a85a354d2bf1b17e5aff71203c08adea", "patch": "@@ -0,0 +1,116 @@\n+/* PR 50584 - No warning for passing small array to C99 static array declarator\n+   Exercise interaction between explicit attribute access and VLA parameters.\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+#define RW(...) __attribute__ ((access (read_write, __VA_ARGS__)))\n+\n+\n+void f1 (int n, int[n], int);               // { dg-message \"designating the bound of variable length array argument 2\" \"note\" }\n+\n+// Verify that a redundant attribute access doesn't trigger a warning.\n+RW (2, 1) void f1 (int n, int[n], int);\n+\n+RW (2, 3) void f1 (int n, int[n], int);     // { dg-warning \"attribute 'access\\\\\\(read_write, 2, 3\\\\\\)' positional argument 2 conflicts with previous designation by argument 1\" }\n+\n+\n+/* Verify that applying the attribute to a VLA with an unspecified bound\n+   doesn't trigger any warnings, both with and without a size operand.  */\n+          void f2 (int, int[*], int);\n+RW (2)    void f2 (int, int[*], int);\n+RW (2, 3) void f2 (int, int[*], int);\n+\n+/* Designating a parameter that comes before the VLA is the same as\n+   using the standard VLA int[n] syntax.  It might be worth issuing\n+   a portability warning suggesting to prefer the standard syntax.  */\n+          void f3 (int, int[*], int);\n+RW (2, 1) void f3 (int, int[*], int);\n+\n+/* Designating a parameter that comes after the VLA cannot be expressed\n+   using the standard VLA int[n] syntax.  Verify it doesn't trigger\n+   a warning.  */\n+          void f4 (int, int[*], int);\n+RW (2, 3) void f4 (int, int[*], int);\n+\n+/* Also verify the same on the same declaration.  */\n+          void f5 (int[*], int) RW (1, 2);\n+RW (1, 2) void f5 (int[*], int);\n+RW (1, 2) void f5 (int[*], int) RW (1, 2);\n+\n+\n+/* Verify that designating a VLA parameter with an explicit bound without\n+   also designating the same bound parameter triggers a warning (it has\n+   a different meaning).  */\n+       void f7 (int n, int[n]);         // { dg-message \"21:note: designating the bound of variable length array argument 2\" \"note\" }\n+RW (2) void f7 (int n, int[n]);         // { dg-warning \"attribute 'access\\\\\\(read_write, 2\\\\\\)' missing positional argument 2 provided in previous designation by argument 1\" }\n+\n+          void f8 (int n, int[n]);\n+RW (2, 1) void f8 (int n, int[n]);\n+\n+\n+          void f9 (int, char[]);        // { dg-message \"25:note: previously declared as an ordinary array 'char\\\\\\[]'\" note\" }\n+RW (2)    void f9 (int n, char a[n])    // { dg-warning \"argument 2 of type 'char\\\\\\[n]' declared as a variable length array\" }\n+                                        // { dg-warning \"attribute 'access *\\\\\\(read_write, 2\\\\\\)' positional argument 2 missing in previous designation\" \"\" { target *-*-* } .-1 }\n+                                        // { dg-message \"24:note: designating the bound of variable length array argument 2\" \"note\" { target *-*-* } .-2 }\n+{ (void)&n; (void)&a; }\n+\n+\n+          void f10 (int, char[]);       // { dg-message \"26:note: previously declared as an ordinary array 'char\\\\\\[]'\" \"note\" }\n+RW (2, 1) void f10 (int n, char a[n])   // { dg-warning \"attribute 'access *\\\\\\(read_write, 2, 1\\\\\\)' positional argument 2 missing in previous designation\" \"pr????\" { xfail *-*-* } }\n+                                        // { dg-warning \"argument 2 of type 'char\\\\\\[n]' declared as a variable length array\"  \"\" { target *-*-* } .-1 }\n+{ (void)&n; (void)&a; }\n+\n+\n+/* The following is diagnosed to point out declarations with the T[*]\n+   form in headers where specifying the bound is just as important as\n+   in the definition (to detect bugs).  */\n+          void f11 (int, char[*]);      // { dg-warning \"argument 2 of type 'char\\\\\\[\\\\\\*\\\\\\]' declared with 1 unspecified variable bound\" }\n+          void f11 (int m, char a[m]);  // { dg-message \"subsequently declared as 'char\\\\\\[m]' with 0 unspecified variable bounds\" \"note\" }\n+RW (2, 1) void f11 (int n, char arr[n]) // { dg-message \"subsequently declared as 'char\\\\\\[n]' with 0 unspecified variable bounds\" \"note\" }\n+{ (void)&n; (void)&arr; }\n+\n+\n+/* Verify that redeclaring a function with attribute access applying\n+   to an array parameter of any form is not diagnosed.  */\n+          void f12__ (int, int[]) RW (2, 1);\n+RW (2, 1) void f12__ (int, int[]);\n+\n+          void f12_3 (int, int[3]) RW (2, 1);\n+RW (2, 1) void f12_3 (int, int[3]);\n+\n+          void f12_n (int n, int[n]) RW (2, 1);\n+RW (2, 1) void f12_n (int n, int[n]);\n+\n+          void f12_x (int, int[*]) RW (2, 1);\n+RW (2, 1) void f12_x (int, int[*]);\n+\n+          void f13__ (int, int[]);\n+RW (2, 1) void f13__ (int, int[]);\n+\n+          void f13_5 (int, int[5]);\n+RW (2, 1) void f13_5 (int, int[5]);\n+\n+          void f13_n (int n, int[n]);\n+RW (2, 1) void f13_n (int n, int[n]);\n+\n+          void f13_x (int, int[*]);\n+RW (2, 1) void f13_x (int, int[*]);\n+\n+RW (2, 1) void f14__ (int, int[]);\n+          void f14__ (int, int[]);\n+\n+RW (2, 1) void f14_7 (int, int[7]);\n+          void f14_7 (int, int[7]);\n+\n+RW (2, 1) void f14_n (int n, int[n]);\n+          void f14_n (int n, int[n]);\n+\n+RW (2, 1) void f14_x (int, int[*]);\n+          void f14_x (int, int[*]);\n+\n+typedef void G1 (int n, int[n], int);\n+\n+G1 g1;\n+\n+RW (2, 3) void g1 (int n, int[n], int);     // { dg-warning \"24: attribute 'access *\\\\\\(read_write, 2, 3\\\\\\)' positional argument 2 conflicts with previous designation by argument 3\" }\n+// { dg-message \"designating the bound of variable length array argument 2\" \"note\" { target *-*-* } .-1 }"}, {"sha": "dc06d057479d32a28e00c27c70eba2eafaaeca0f", "filename": "gcc/testsuite/gcc.dg/attr-access-none.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-none.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-none.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-none.c?ref=baad4c48a85a354d2bf1b17e5aff71203c08adea", "patch": "@@ -23,7 +23,7 @@ void nowarn_fnone_pcv1 (void)\n \n \n int __attribute__ ((access (none, 1, 2)))\n-fnone_pcv1_2 (const void*, int);  // { dg-message \"in a call to function 'fnone_pcv1_2' declared with attribute 'none \\\\\\(1, 2\\\\\\)'\" }\n+fnone_pcv1_2 (const void*, int);  // { dg-message \"in a call to function 'fnone_pcv1_2' declared with attribute 'access \\\\\\(none, 1, 2\\\\\\)'\" \"note\" }\n \n void nowarn_fnone_pcv1_2 (void)\n {"}, {"sha": "ce7d5c1a0a0fde78d2ee5808c12f0512ae62f3a8", "filename": "gcc/testsuite/gcc.dg/dfp/composite-type.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fcomposite-type.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fcomposite-type.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fcomposite-type.c?ref=baad4c48a85a354d2bf1b17e5aff71203c08adea", "patch": "@@ -53,3 +53,6 @@ int main()\n \n   return 0;\n }\n+\n+/* The invalid function redeclarations might also trigger:\n+   { dg-prune-output \"-Warray-parameter\" } */"}, {"sha": "5fd4ee715ee542994a34bebd13ff788ca2df7adb", "filename": "gcc/testsuite/gcc.dg/torture/pr57147-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57147-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57147-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57147-1.c?ref=baad4c48a85a354d2bf1b17e5aff71203c08adea", "patch": "@@ -2,11 +2,11 @@\n /* { dg-options \"-fdump-tree-optimized\" } */\n /* { dg-skip-if \"\" { *-*-* } { \"-fno-fat-lto-objects\" } { \"\" } } */\n \n-struct __jmp_buf_tag {};\n+struct __jmp_buf_tag { int mask; };\n typedef struct __jmp_buf_tag jmp_buf[1];\n extern int _setjmp (struct __jmp_buf_tag __env[1]);\n \n-jmp_buf g_return_jmp_buf;\n+extern jmp_buf g_return_jmp_buf;\n \n void SetNaClSwitchExpectations (void)\n {"}, {"sha": "699c7f97a54789714d13ef9f45dccf71e8bab1b5", "filename": "gcc/testsuite/gcc.dg/torture/pr57147-3.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57147-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57147-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr57147-3.c?ref=baad4c48a85a354d2bf1b17e5aff71203c08adea", "patch": "@@ -1,8 +1,7 @@\n /* { dg-do compile } */\n \n typedef char * ptr_t;\n-struct __jmp_buf_tag   {\n-};\n+struct __jmp_buf_tag { int mask; };\n typedef struct __jmp_buf_tag sigjmp_buf[1];\n sigjmp_buf GC_jmp_buf;\n int __sigsetjmp (sigjmp_buf, int);"}, {"sha": "7ed16866afa60c1b78e38af648db7f7baf4d1c36", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baad4c48a85a354d2bf1b17e5aff71203c08adea/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=baad4c48a85a354d2bf1b17e5aff71203c08adea", "patch": "@@ -562,15 +562,15 @@ maybe_warn_pass_by_reference (gimple *stmt, wlimits &wlims)\n \t  if (fndecl)\n \t    {\n \t      location_t loc (DECL_SOURCE_LOCATION (fndecl));\n-\t      inform (loc, \"by argument %u of type %<%s%> to %qD \"\n+\t      inform (loc, \"by argument %u of type %s to %qD \"\n \t\t      \"declared here\",\n \t\t      argno, argtypestr.c_str (), fndecl);\n \t    }\n \t  else\n \t    {\n \t      /* Handle calls through function pointers.  */\n \t      location_t loc (gimple_location (stmt));\n-\t      inform (loc, \"by argument %u of type %<%s%> to %qT\",\n+\t      inform (loc, \"by argument %u of type %s to %qT\",\n \t\t      argno, argtypestr.c_str (), fntype);\n \t    }\n \t}"}]}