{"sha": "9e4a4dd6518a86c94278a978412e162c4b770c7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU0YTRkZDY1MThhODZjOTQyNzhhOTc4NDEyZTE2MmM0Yjc3MGM3Yg==", "commit": {"author": {"name": "Alexander Ivchenko", "email": "alexander.ivchenko@intel.com", "date": "2014-08-14T13:18:42Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-08-14T13:18:42Z"}, "message": "i386.c (print_reg): \u0421orrectly print 64-bit mask registers.\n\ngcc/\n\t* config/i386/i386.c (print_reg): \u0421orrectly print 64-bit mask\n\tregisters.\n\t(inline_secondary_memory_needed): Allow 64 bit wide mask registers.\n\t(ix86_hard_regno_mode_ok): Allow 32/64-bit mask registers and\n\txmm/ymm16+ when availble.\n\t* config/i386/i386.h\n\t(HARD_REGNO_NREGS): Add mask regs.\n\t(VALID_AVX512F_REG_MODE): Ditto.\n\t(VALID_AVX512F_REG_MODE) : Define.\n\t(VALID_MASK_AVX512BW_MODE): Ditto.\n\t(reg_class) (MASK_REG_P(X)): Define.\n\t* config/i386/i386.md: Do not split long moves with mask register,\n\tuse kmovb if avx512bw is availible.\n\t(movdi_internal): Handle mask registers.\n\n\nCo-Authored-By: Andrey Turetskiy <andrey.turetskiy@intel.com>\nCo-Authored-By: Anna Tikhonova <anna.tikhonova@intel.com>\nCo-Authored-By: Ilya Tocar <ilya.tocar@intel.com>\nCo-Authored-By: Ilya Verbin <ilya.verbin@intel.com>\nCo-Authored-By: Kirill Yukhin <kirill.yukhin@intel.com>\nCo-Authored-By: Maxim Kuznetsov <maxim.kuznetsov@intel.com>\nCo-Authored-By: Michael Zolotukhin <michael.v.zolotukhin@intel.com>\n\nFrom-SVN: r213962", "tree": {"sha": "33cf0a1877fdbac992df7ad08b2c28b523fe991f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33cf0a1877fdbac992df7ad08b2c28b523fe991f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e4a4dd6518a86c94278a978412e162c4b770c7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e4a4dd6518a86c94278a978412e162c4b770c7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e4a4dd6518a86c94278a978412e162c4b770c7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e4a4dd6518a86c94278a978412e162c4b770c7b/comments", "author": null, "committer": null, "parents": [{"sha": "7d39012c24ded7a9d1d4eb1fa2916181dac3ada2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d39012c24ded7a9d1d4eb1fa2916181dac3ada2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d39012c24ded7a9d1d4eb1fa2916181dac3ada2"}], "stats": {"total": 96, "additions": 82, "deletions": 14}, "files": [{"sha": "a65af976c84a12ab43dee578d15101440557a840", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e4a4dd6518a86c94278a978412e162c4b770c7b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e4a4dd6518a86c94278a978412e162c4b770c7b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e4a4dd6518a86c94278a978412e162c4b770c7b", "patch": "@@ -1,3 +1,27 @@\n+2014-08-14  Alexander Ivchenko  <alexander.ivchenko@intel.com>\n+\t    Maxim Kuznetsov  <maxim.kuznetsov@intel.com>\n+\t    Anna Tikhonova  <anna.tikhonova@intel.com>\n+\t    Ilya Tocar  <ilya.tocar@intel.com>\n+\t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n+\t    Kirill Yukhin  <kirill.yukhin@intel.com>\n+\t    Michael Zolotukhin  <michael.v.zolotukhin@intel.com>\n+\n+\t* config/i386/i386.c (print_reg): \u0421orrectly print 64-bit mask\n+\tregisters.\n+\t(inline_secondary_memory_needed): Allow 64 bit wide mask registers.\n+\t(ix86_hard_regno_mode_ok): Allow 32/64-bit mask registers and\n+\txmm/ymm16+ when availble.\n+\t* config/i386/i386.h\n+\t(HARD_REGNO_NREGS): Add mask regs.\n+\t(VALID_AVX512F_REG_MODE): Ditto.\n+\t(VALID_AVX512F_REG_MODE) : Define.\n+\t(VALID_MASK_AVX512BW_MODE): Ditto.\n+\t(reg_class) (MASK_REG_P(X)): Define.\n+\t* config/i386/i386.md: Do not split long moves with mask register,\n+\tuse kmovb if avx512bw is availible.\n+\t(movdi_internal): Handle mask registers.\n+\n 2014-08-14  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/62081"}, {"sha": "5a3b67ae248ad311a39067b4e2efd5c8ea5e02a2", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e4a4dd6518a86c94278a978412e162c4b770c7b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e4a4dd6518a86c94278a978412e162c4b770c7b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9e4a4dd6518a86c94278a978412e162c4b770c7b", "patch": "@@ -14701,7 +14701,7 @@ print_reg (rtx x, int code, FILE *file)\n     case 8:\n     case 4:\n     case 12:\n-      if (! ANY_FP_REG_P (x))\n+      if (! ANY_FP_REG_P (x) && ! ANY_MASK_REG_P (x))\n \tputc (code == 8 && TARGET_64BIT ? 'r' : 'e', file);\n       /* FALLTHRU */\n     case 16:\n@@ -37393,6 +37393,11 @@ inline_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n   if (FLOAT_CLASS_P (class1) != FLOAT_CLASS_P (class2))\n     return true;\n \n+  /* Between mask and general, we have moves no larger than word size.  */\n+  if ((MAYBE_MASK_CLASS_P (class1) != MAYBE_MASK_CLASS_P (class2))\n+      && (GET_MODE_SIZE (mode) > UNITS_PER_WORD))\n+  return true;\n+\n   /* ??? This is a lie.  We do have moves between mmx/general, and for\n      mmx/sse2.  But by saying we need secondary memory we discourage the\n      register allocator from using the mmx registers unless needed.  */\n@@ -37698,7 +37703,8 @@ ix86_hard_regno_mode_ok (int regno, enum machine_mode mode)\n   if (STACK_REGNO_P (regno))\n     return VALID_FP_MODE_P (mode);\n   if (MASK_REGNO_P (regno))\n-    return VALID_MASK_REG_MODE (mode);\n+    return (VALID_MASK_REG_MODE (mode)\n+\t    || (TARGET_AVX512BW && VALID_MASK_AVX512BW_MODE (mode)));\n   if (SSE_REGNO_P (regno))\n     {\n       /* We implement the move patterns for all vector modes into and\n@@ -37715,6 +37721,15 @@ ix86_hard_regno_mode_ok (int regno, enum machine_mode mode)\n \t      || VALID_AVX512F_SCALAR_MODE (mode)))\n \treturn true;\n \n+      /* TODO check for QI/HI scalars.  */\n+      /* AVX512VL allows sse regs16+ for 128/256 bit modes.  */\n+      if (TARGET_AVX512VL\n+\t  && (mode == OImode\n+\t      || mode == TImode\n+\t      || VALID_AVX256_REG_MODE (mode)\n+\t      || VALID_AVX512VL_128_REG_MODE (mode)))\n+\treturn true;\n+\n       /* xmm16-xmm31 are only available for AVX-512.  */\n       if (EXT_REX_SSE_REGNO_P (regno))\n \treturn false;"}, {"sha": "c2f0ceed45f4ebe1cddb84737ab3e870be6c3eab", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e4a4dd6518a86c94278a978412e162c4b770c7b/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e4a4dd6518a86c94278a978412e162c4b770c7b/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=9e4a4dd6518a86c94278a978412e162c4b770c7b", "patch": "@@ -1054,7 +1054,8 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n    applied to them.  */\n \n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n-  (STACK_REGNO_P (REGNO) || SSE_REGNO_P (REGNO) || MMX_REGNO_P (REGNO)\t\\\n+  (STACK_REGNO_P (REGNO) || SSE_REGNO_P (REGNO)\t\t\t\t\\\n+   || MMX_REGNO_P (REGNO) || MASK_REGNO_P (REGNO)\t\t\t\\\n    ? (COMPLEX_MODE_P (MODE) ? 2 : 1)\t\t\t\t\t\\\n    : ((MODE) == XFmode\t\t\t\t\t\t\t\\\n       ? (TARGET_64BIT ? 2 : 3)\t\t\t\t\t\t\\\n@@ -1085,7 +1086,12 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \n #define VALID_AVX512F_REG_MODE(MODE)\t\t\t\t\t\\\n   ((MODE) == V8DImode || (MODE) == V8DFmode || (MODE) == V64QImode\t\\\n-   || (MODE) == V16SImode || (MODE) == V16SFmode || (MODE) == V32HImode)\n+   || (MODE) == V16SImode || (MODE) == V16SFmode || (MODE) == V32HImode \\\n+   || (MODE) == V4TImode)\n+\n+#define VALID_AVX512VL_128_REG_MODE(MODE)\t\t\t\t\t\\\n+  ((MODE) == V2DImode || (MODE) == V2DFmode || (MODE) == V16QImode\t\\\n+   || (MODE) == V4SImode || (MODE) == V4SFmode || (MODE) == V8HImode)\n \n #define VALID_SSE2_REG_MODE(MODE)\t\t\t\t\t\\\n   ((MODE) == V16QImode || (MODE) == V8HImode || (MODE) == V2DFmode\t\\\n@@ -1132,6 +1138,8 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \n #define VALID_MASK_REG_MODE(MODE) ((MODE) == HImode || (MODE) == QImode)\n \n+#define VALID_MASK_AVX512BW_MODE(MODE) ((MODE) == SImode || (MODE) == DImode)\n+\n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE)\t\\\n@@ -1454,6 +1462,7 @@ enum reg_class\n          : (N) <= LAST_REX_SSE_REG ? (FIRST_REX_SSE_REG + (N) - 8) \\\n                                    : (FIRST_EXT_REX_SSE_REG + (N) - 16))\n \n+#define MASK_REG_P(X) (REG_P (X) && MASK_REGNO_P (REGNO (X)))\n #define MASK_REGNO_P(N) IN_RANGE ((N), FIRST_MASK_REG, LAST_MASK_REG)\n #define ANY_MASK_REG_P(X) (REG_P (X) && MASK_REGNO_P (REGNO (X)))\n "}, {"sha": "4867e7e4ed07d83e6088dec2ab55cb6cc72aa99c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e4a4dd6518a86c94278a978412e162c4b770c7b/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e4a4dd6518a86c94278a978412e162c4b770c7b/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=9e4a4dd6518a86c94278a978412e162c4b770c7b", "patch": "@@ -952,6 +952,9 @@\n ;; Instruction suffix for integer modes.\n (define_mode_attr imodesuffix [(QI \"b\") (HI \"w\") (SI \"l\") (DI \"q\")])\n \n+;; Instruction suffix for masks.\n+(define_mode_attr mskmodesuffix [(QI \"b\") (HI \"w\") (SI \"d\") (DI \"q\")])\n+\n ;; Pointer size prefix for integer modes (Intel asm dialect)\n (define_mode_attr iptrsize [(QI \"BYTE\")\n \t\t\t    (HI \"WORD\")\n@@ -2022,13 +2025,16 @@\n \n (define_insn \"*movdi_internal\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-    \"=r  ,o  ,r,r  ,r,m ,*y,*y,?*y,?m,?r ,?*Ym,*v,*v,*v,m ,?r ,?r,?*Yi,?*Ym,?*Yi\")\n+    \"=r  ,o  ,r,r  ,r,m ,*y,*y,?*y,?m,?r ,?*Ym,*v,*v,*v,m ,?r ,?r,?*Yi,?*Ym,?*Yi,*k,*k ,*r ,*m\")\n \t(match_operand:DI 1 \"general_operand\"\n-    \"riFo,riF,Z,rem,i,re,C ,*y,m  ,*y,*Yn,r   ,C ,*v,m ,*v,*Yj,*v,r   ,*Yj ,*Yn\"))]\n+    \"riFo,riF,Z,rem,i,re,C ,*y,m  ,*y,*Yn,r   ,C ,*v,m ,*v,*Yj,*v,r   ,*Yj ,*Yn ,*r ,*km,*k,*k\"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (get_attr_type (insn))\n     {\n+    case TYPE_MSKMOV:\n+      return \"kmovq\\t{%1, %0|%0, %1}\";\n+\n     case TYPE_MULTI:\n       return \"#\";\n \n@@ -2099,7 +2105,7 @@\n   [(set (attr \"isa\")\n      (cond [(eq_attr \"alternative\" \"0,1\")\n \t      (const_string \"nox64\")\n-\t    (eq_attr \"alternative\" \"2,3,4,5,10,11,16,18\")\n+\t    (eq_attr \"alternative\" \"2,3,4,5,10,11,16,18,21,23\")\n \t      (const_string \"x64\")\n \t    (eq_attr \"alternative\" \"17\")\n \t      (const_string \"x64_sse4\")\n@@ -2118,6 +2124,8 @@\n \t      (const_string \"ssemov\")\n \t    (eq_attr \"alternative\" \"19,20\")\n \t      (const_string \"ssecvt\")\n+\t    (eq_attr \"alternative\" \"21,22,23,24\")\n+\t      (const_string \"mskmov\")\n \t    (match_operand 1 \"pic_32bit_operand\")\n \t      (const_string \"lea\")\n \t   ]\n@@ -2179,16 +2187,20 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\")\n         (match_operand:DI 1 \"general_operand\"))]\n   \"!TARGET_64BIT && reload_completed\n-   && !(MMX_REG_P (operands[0]) || SSE_REG_P (operands[0]))\n-   && !(MMX_REG_P (operands[1]) || SSE_REG_P (operands[1]))\"\n+   && !(MMX_REG_P (operands[0])\n+\t|| SSE_REG_P (operands[0])\n+\t|| MASK_REG_P (operands[0]))\n+   && !(MMX_REG_P (operands[1])\n+\t|| SSE_REG_P (operands[1])\n+\t|| MASK_REG_P (operands[1]))\"\n   [(const_int 0)]\n   \"ix86_split_long_move (operands); DONE;\")\n \n (define_insn \"*movsi_internal\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\"\n-\t\t\t\"=r,m ,*y,*y,?rm,?*y,*v,*v,*v,m ,?r ,?r,?*Yi\")\n+\t\t\t\"=r,m ,*y,*y,?rm,?*y,*v,*v,*v,m ,?r ,?r,?*Yi,*k  ,*rm\")\n \t(match_operand:SI 1 \"general_operand\"\n-\t\t\t\"g ,re,C ,*y,*y ,rm ,C ,*v,m ,*v,*Yj,*v,r\"))]\n+\t\t\t\"g ,re,C ,*y,*y ,rm ,C ,*v,m ,*v,*Yj,*v,r   ,*krm,*k\"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (get_attr_type (insn))\n@@ -2199,6 +2211,9 @@\n \n       return standard_sse_constant_opcode (insn, operands[1]);\n \n+    case TYPE_MSKMOV:\n+      return \"kmovd\\t{%1, %0|%0, %1}\";\n+\n     case TYPE_SSEMOV:\n       switch (get_attr_mode (insn))\n \t{\n@@ -2262,6 +2277,8 @@\n \t      (const_string \"sselog1\")\n \t    (eq_attr \"alternative\" \"7,8,9,10,12\")\n \t      (const_string \"ssemov\")\n+\t    (eq_attr \"alternative\" \"13,14\")\n+\t      (const_string \"mskmov\")\n  \t    (match_operand 1 \"pic_32bit_operand\")\n \t      (const_string \"lea\")\n \t   ]\n@@ -2410,9 +2427,12 @@\n     case TYPE_MSKMOV:\n       switch (which_alternative)\n         {\n-\tcase 7: return \"kmovw\\t{%k1, %0|%0, %k1}\";\n-\tcase 8: return \"kmovw\\t{%1, %0|%0, %1}\";\n-\tcase 9: return \"kmovw\\t{%1, %k0|%k0, %1}\";\n+\tcase 7: return TARGET_AVX512BW ? \"kmovb\\t{%k1, %0|%0, %k1}\"\n+\t\t\t\t       : \"kmovw\\t{%k1, %0|%0, %k1}\";\n+\tcase 8: return TARGET_AVX512BW ? \"kmovb\\t{%1, %0|%0, %1}\"\n+\t\t\t\t       : \"kmovw\\t{%1, %0|%0, %1}\";\n+\tcase 9: return TARGET_AVX512BW ? \"kmovb\\t{%1, %k0|%k0, %1}\"\n+\t\t\t\t       : \"kmovw\\t{%1, %k0|%k0, %1}\";\n \tdefault: gcc_unreachable ();\n \t}\n "}]}