{"sha": "7dcd3836a31b1642a57122f63c0828b06a190f5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RjZDM4MzZhMzFiMTY0MmE1NzEyMmY2M2MwODI4YjA2YTE5MGY1Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-28T12:27:04Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-28T12:27:04Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r611", "tree": {"sha": "fb47e904d0744e28608f985637f2f894950a3d63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb47e904d0744e28608f985637f2f894950a3d63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7dcd3836a31b1642a57122f63c0828b06a190f5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dcd3836a31b1642a57122f63c0828b06a190f5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dcd3836a31b1642a57122f63c0828b06a190f5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dcd3836a31b1642a57122f63c0828b06a190f5f/comments", "author": null, "committer": null, "parents": [{"sha": "e165f3f04d3f5bfca6c47010a745f0404109db38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e165f3f04d3f5bfca6c47010a745f0404109db38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e165f3f04d3f5bfca6c47010a745f0404109db38"}], "stats": {"total": 88, "additions": 77, "deletions": 11}, "files": [{"sha": "842ab1210cf22a53f9102dd33cd6b554876eedc4", "filename": "gcc/loop.c", "status": "modified", "additions": 77, "deletions": 11, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcd3836a31b1642a57122f63c0828b06a190f5f/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcd3836a31b1642a57122f63c0828b06a190f5f/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=7dcd3836a31b1642a57122f63c0828b06a190f5f", "patch": "@@ -1467,7 +1467,7 @@ add_label_notes (x, insns)\n      rtx insns;\n {\n   enum rtx_code code = GET_CODE (x);\n-  int i;\n+  int i, j;\n   char *fmt;\n   rtx insn;\n \n@@ -1482,8 +1482,13 @@ add_label_notes (x, insns)\n \n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    if (fmt[i] == 'e')\n-      add_label_notes (XEXP (x, i), insns);\n+    {\n+      if (fmt[i] == 'e')\n+\tadd_label_notes (XEXP (x, i), insns);\n+      else if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  add_label_notes (XVECEXP (x, i, j), insns);\n+    }\n }\n \f\n /* Scan MOVABLES, and move the insns that deserve to be moved.\n@@ -3067,6 +3072,9 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   /* This is 1 if current insn is not executed at least once for every loop\n      iteration.  */\n   int not_every_iteration = 0;\n+  /* This is 1 if current insn may be executed more than once for every\n+     loop iteration.  */\n+  int maybe_multiple = 0;\n   /* Temporary list pointers for traversing loop_iv_list.  */\n   struct iv_class *bl, **backbl;\n   /* Ratio of extra register life span we can justify\n@@ -3141,14 +3149,54 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\t    = (struct induction *) alloca (sizeof (struct induction));\n \n \t\t  record_biv (v, p, dest_reg, inc_val, mult_val,\n-\t\t\t      not_every_iteration);\n+\t\t\t      not_every_iteration, maybe_multiple);\n \t\t  reg_iv_type[REGNO (dest_reg)] = BASIC_INDUCT;\n \t\t}\n \t      else if (REGNO (dest_reg) < max_reg_before_loop)\n \t\treg_iv_type[REGNO (dest_reg)] = NOT_BASIC_INDUCT;\n \t    }\n \t}\n \n+      /* Past CODE_LABEL, we get to insns that may be executed multiple\n+\t times.  The only way we can be sure that they can't is if every\n+\t every jump insn between here and the end of the loop either\n+\t returns, exits the loop, or is a forward jump.  */\n+\n+      if (GET_CODE (p) == CODE_LABEL)\n+\t{\n+\t  rtx insn = p;\n+\n+\t  maybe_multiple = 0;\n+\n+\t  while (1)\n+\t    {\n+\t      insn = NEXT_INSN (insn);\n+\t      if (insn == scan_start)\n+\t\tbreak;\n+\t      if (insn == end)\n+\t\t{\n+\t\t  if (loop_top != 0)\n+\t\t    insn = NEXT_INSN (loop_top);\n+\t\t  else\n+\t\t    break;\n+\t\t  if (insn == scan_start)\n+\t\t    break;\n+\t\t}\n+\n+\t      if (GET_CODE (insn) == JUMP_INSN\n+\t\t  && GET_CODE (PATTERN (insn)) != RETURN\n+\t\t  && (! condjump_p (insn)\n+\t\t      || (JUMP_LABEL (insn) != 0\n+\t\t\t  && (INSN_UID (JUMP_LABEL (insn)) > max_uid_for_loop\n+\t\t\t      || (INSN_LUID (JUMP_LABEL (insn))\n+\t\t\t\t  < INSN_LUID (insn))))))\n+\t      {\n+\t\tmaybe_multiple = 1;\n+\t\tbreak;\n+\t      }\n+\t    }\n+\t}\n+\n       /* Past a label or a jump, we get to insns for which we can't count\n \t on whether or how many times they will be executed during each\n \t iteration.  */\n@@ -3415,7 +3463,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \n       /* Update the status of whether giv can derive other givs.  This can\n \t change when we pass a label or an insn that updates a biv.  */\n-      if (GET_CODE (p) == INSN || GET_CODE (p) == CODE_LABEL)\n+      if (GET_CODE (p) == INSN || GET_CODE (p) == JUMP_INSN\n+\t|| GET_CODE (p) == CODE_LABEL)\n \tupdate_giv_derive (p);\n \n       /* Past a label or a jump, we get to insns for which we can't count\n@@ -4000,16 +4049,24 @@ find_mem_givs (x, insn, not_every_iteration, loop_start, loop_end)\n \n    MULT_VAL is const1_rtx if the biv is being incremented here, in which case\n    INC_VAL is the increment.  Otherwise, MULT_VAL is const0_rtx and the biv is\n-   being set to INC_VAL.  */\n+   being set to INC_VAL.\n+\n+   NOT_EVERY_ITERATION is nonzero if this biv update is not know to be\n+   executed every iteration; MAYBE_MULTIPLE is nonzero if this biv update\n+   can be executed more than once per iteration.  If MAYBE_MULTIPLE\n+   and NOT_EVERY_ITERATION are both zero, we know that the biv update is\n+   executed exactly once per iteration.  */\n \n static void\n-record_biv (v, insn, dest_reg, inc_val, mult_val, not_every_iteration)\n+record_biv (v, insn, dest_reg, inc_val, mult_val,\n+\t    not_every_iteration, maybe_multiple)\n      struct induction *v;\n      rtx insn;\n      rtx dest_reg;\n      rtx inc_val;\n      rtx mult_val;\n      int not_every_iteration;\n+     int maybe_multiple;\n {\n   struct iv_class *bl;\n \n@@ -4020,6 +4077,7 @@ record_biv (v, insn, dest_reg, inc_val, mult_val, not_every_iteration)\n   v->add_val = inc_val;\n   v->mode = GET_MODE (dest_reg);\n   v->always_computable = ! not_every_iteration;\n+  v->maybe_multiple = maybe_multiple;\n \n   /* Add this to the reg's iv_class, creating a class\n      if this is the first incrementation of the reg.  */\n@@ -4122,6 +4180,7 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n   v->location = location;\n   v->cant_derive = 0;\n   v->combined_with = 0;\n+  v->maybe_multiple = 0;\n   v->maybe_dead = 0;\n   v->derive_adjustment = 0;\n   v->same = 0;\n@@ -4485,7 +4544,7 @@ update_giv_derive (p)\n \n   /* Search all IV classes, then all bivs, and finally all givs.\n \n-     There are two cases we are concerned with.  First we have the situation\n+     There are three cases we are concerned with.  First we have the situation\n      of a giv that is only updated conditionally.  In that case, it may not\n      derive any givs after a label is passed.\n \n@@ -4501,13 +4560,19 @@ update_giv_derive (p)\n      a branch here (actually, we need to pass both a jump and a label, but\n      this extra tracking doesn't seem worth it).\n \n-     If this is a giv update, we must adjust the giv status to show that a\n+     If this is a jump, we are concerned about any biv update that may be\n+     executed multiple times.  We are actually only concerned about\n+     backward jumps, but it is probably not worth performing the test\n+     on the jump again here.\n+\n+     If this is a biv update, we must adjust the giv status to show that a\n      subsequent biv update was performed.  If this adjustment cannot be done,\n      the giv cannot derive further givs.  */\n \n   for (bl = loop_iv_list; bl; bl = bl->next)\n     for (biv = bl->biv; biv; biv = biv->next_iv)\n-      if (GET_CODE (p) == CODE_LABEL || biv->insn == p)\n+      if (GET_CODE (p) == CODE_LABEL || GET_CODE (p) == JUMP_INSN\n+\t  || biv->insn == p)\n \t{\n \t  for (giv = bl->giv; giv; giv = giv->next_iv)\n \t    {\n@@ -4551,7 +4616,8 @@ update_giv_derive (p)\n \t\t  else\n \t\t    giv->cant_derive = 1;\n \t\t}\n-\t      else if (GET_CODE (p) == CODE_LABEL && ! biv->always_computable)\n+\t      else if ((GET_CODE (p) == CODE_LABEL && ! biv->always_computable)\n+\t\t       || (GET_CODE (p) == JUMP_INSN && biv->maybe_multiple))\n \t\tgiv->cant_derive = 1;\n \t    }\n \t}"}]}