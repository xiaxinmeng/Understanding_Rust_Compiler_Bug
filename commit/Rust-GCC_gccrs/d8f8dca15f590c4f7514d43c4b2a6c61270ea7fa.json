{"sha": "d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhmOGRjYTE1ZjU5MGM0Zjc1MTRkNDNjNGIyYTZjNjEyNzBlYTdmYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-12-14T15:35:40Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-12-14T15:35:40Z"}, "message": "class.c (pushclass): Tweak handling of class-level bindings.\n\n\t* class.c (pushclass): Tweak handling of class-level bindings.\n\t(resolve_address_of_overloaded_function): Update pointer-to-member\n\thandling.\n\t(instantiate_type): Likewise.\n\t* cvt.c (cp_convert_to_pointer): Likewise.\n\t* decl.c (pop_binding): Take the DECL to pop, not just the name.\n\tDeal with `struct stat' hack.\n\t(binding_level): Add to documentation.\n\t(push_binding): Clear BINDING_TYPE.\n\t(add_binding): New function.\n\t(push_local_binding): Use it.\n\t(push_class_binding): Likewise.\n\t(poplevel): Adjust calls to pop_binding.\n\t(poplevel_class): Likewise.\n\t(pushdecl): Adjust handling of TYPE_DECLs; add bindings for hidden\n\tdeclarations to current binding level.\n\t(push_class_level_binding): Likewise.\n\t(push_overloaded_decl): Adjust handling of OVERLOADs in local\n\tbindings.\n\t(lookup_namespace_name): Don't crash when confronted with a\n\tTEMPLATE_DECL.\n\t(lookup_name_real): Do `struct stat' hack in local binding\n\tcontexts.\n\t(build_ptrmemfunc_type): Adjust documentation.\n\t(grokdeclarator): Don't avoid building real array types when\n\tprocessing templates unless really necessary.\n\t(finish_method): Adjust calls to pop_binding.\n\t* decl2.c (reparse_absdcl_as_expr): Recursively call ourselves,\n\tnot reparse_decl_as_expr.\n\t(build_expr_from_tree): Deal with a template-id as the function to\n\tcall in a METHOD_CALL_EXPR.\n\t* pt.c (convert_nontype_argument): Tweak pointer-to-member handling.\n\t(maybe_adjust_types_For_deduction): Don't do peculiar things with\n\tMETHOD_TYPEs here.\n\t(resolve_overloaded_unification): Handle COMPONENT_REFs.  Build\n\tpointer-to-member types where necessary.\n\t* tree.c (build_cplus_array_type_1): Don't avoid building real\n\tarray types when processing templates unless really necessary.\n\t(build_exception_variant): Compare the exception lists correctly.\n\nFrom-SVN: r24314", "tree": {"sha": "d7dd59c9ebbb858ab3253584bc6ce63646ceb126", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7dd59c9ebbb858ab3253584bc6ce63646ceb126"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/comments", "author": null, "committer": null, "parents": [{"sha": "11b8962251b584202478b1d3d0d2413f6d335dd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11b8962251b584202478b1d3d0d2413f6d335dd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11b8962251b584202478b1d3d0d2413f6d335dd4"}], "stats": {"total": 525, "additions": 399, "deletions": 126}, "files": [{"sha": "78658fd0169909795d05419c86b180dc0c2066f5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "patch": "@@ -1,3 +1,45 @@\n+1998-12-14  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* class.c (pushclass): Tweak handling of class-level bindings.\n+\t(resolve_address_of_overloaded_function): Update pointer-to-member\n+\thandling. \n+\t(instantiate_type): Likewise.\n+\t* cvt.c (cp_convert_to_pointer): Likewise.\n+\t* decl.c (pop_binding): Take the DECL to pop, not just the name.\n+\tDeal with `struct stat' hack.\n+\t(binding_level): Add to documentation.\n+\t(push_binding): Clear BINDING_TYPE.\n+\t(add_binding): New function.\n+\t(push_local_binding): Use it.\n+\t(push_class_binding): Likewise.\n+\t(poplevel): Adjust calls to pop_binding.\n+\t(poplevel_class): Likewise.\n+\t(pushdecl): Adjust handling of TYPE_DECLs; add bindings for hidden\n+\tdeclarations to current binding level.\n+\t(push_class_level_binding): Likewise.\n+\t(push_overloaded_decl): Adjust handling of OVERLOADs in local\n+\tbindings. \n+\t(lookup_namespace_name): Don't crash when confronted with a\n+\tTEMPLATE_DECL. \n+\t(lookup_name_real): Do `struct stat' hack in local binding\n+\tcontexts. \n+\t(build_ptrmemfunc_type): Adjust documentation.\n+\t(grokdeclarator): Don't avoid building real array types when\n+\tprocessing templates unless really necessary.\n+\t(finish_method): Adjust calls to pop_binding.\n+\t* decl2.c (reparse_absdcl_as_expr): Recursively call ourselves,\n+\tnot reparse_decl_as_expr.\n+\t(build_expr_from_tree): Deal with a template-id as the function to\n+\tcall in a METHOD_CALL_EXPR.\n+\t* pt.c (convert_nontype_argument): Tweak pointer-to-member handling.\n+\t(maybe_adjust_types_For_deduction): Don't do peculiar things with\n+\tMETHOD_TYPEs here.\n+\t(resolve_overloaded_unification): Handle COMPONENT_REFs.  Build\n+\tpointer-to-member types where necessary.\n+\t* tree.c (build_cplus_array_type_1): Don't avoid building real\n+\tarray types when processing templates unless really necessary.\n+\t(build_exception_variant): Compare the exception lists correctly. \n+\t\n 1998-12-13  Mark Mitchell  <mark@markmitchell.com>\n \n \t* cp-tree.def (CPLUS_BINDING): Update documentation."}, {"sha": "e3f4544481b0c26505fcda2b172f32c3bc427c5e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "patch": "@@ -4789,7 +4789,7 @@ pushclass (type, modify)\n \t  for (item = previous_class_values; item; item = TREE_CHAIN (item))\n \t    {\n \t      tree id = TREE_PURPOSE (item);\n-\t      tree decl = IDENTIFIER_CLASS_VALUE (id);\n+\t      tree decl = TREE_TYPE (item);\n \n \t      push_class_binding (id, decl);\n \t      if (TREE_CODE (decl) == TYPE_DECL)\n@@ -4808,8 +4808,6 @@ pushclass (type, modify)\n \t  if (! (IS_AGGR_TYPE_CODE (TREE_CODE (tag_type))\n \t\t && CLASSTYPE_IS_TEMPLATE (tag_type)))\n \t    pushtag (TREE_PURPOSE (tags), tag_type, 0);\n-\t  else\n-\t    pushdecl_class_level (CLASSTYPE_TI_TEMPLATE (tag_type));\n \t}\n \n       current_function_decl = this_fndecl;\n@@ -5028,11 +5026,12 @@ resolve_address_of_overloaded_function (target_type,\n      interoperability with most_specialized_instantiation.  */\n   tree matches = NULL_TREE;\n \n-  /* If the TARGET_TYPE is a pointer-to-a-method, we convert it to\n-     proper pointer-to-member type here.  */\n-  if (TREE_CODE (target_type) == POINTER_TYPE\n-      && TREE_CODE (TREE_TYPE (target_type)) == METHOD_TYPE)\n-    target_type = build_ptrmemfunc_type (target_type);\n+  /* By the time we get here, we should be seeing only real\n+     pointer-to-member types, not the internal POINTER_TYPE to\n+     METHOD_TYPE representation.  */\n+  my_friendly_assert (!(TREE_CODE (target_type) == POINTER_TYPE\n+\t\t\t&& (TREE_CODE (TREE_TYPE (target_type)) \n+\t\t\t    == METHOD_TYPE)), 0);\n \n   /* Check that the TARGET_TYPE is reasonable.  */\n   if (TYPE_PTRFN_P (target_type))\n@@ -5475,15 +5474,20 @@ instantiate_type (lhstype, rhs, complain)\n \tif (fn == error_mark_node)\n \t  return error_mark_node;\n \tmark_addressable (fn);\n-\tTREE_TYPE (rhs) = lhstype;\n \tTREE_OPERAND (rhs, 0) = fn;\n \tTREE_CONSTANT (rhs) = staticp (fn);\n-\tif (TREE_CODE (lhstype) == POINTER_TYPE\n-\t    && TREE_CODE (TREE_TYPE (lhstype)) == METHOD_TYPE)\n+\tif (TYPE_PTRMEMFUNC_P (lhstype))\n \t  {\n-\t    build_ptrmemfunc_type (lhstype);\n-\t    rhs = build_ptrmemfunc (lhstype, rhs, 0);\n+\t    /* We must use the POINTER_TYPE to METHOD_TYPE on RHS here\n+\t       so that build_ptrmemfunc knows that RHS we have is not\n+\t       already a pointer-to-member constant.  Instead, it is\n+\t       just a ADDR_EXPR over a FUNCTION_DECL.  */\n+\t    TREE_TYPE (rhs) = TYPE_PTRMEMFUNC_FN_TYPE (lhstype);\n+\t    rhs = build_ptrmemfunc (TREE_TYPE (rhs), rhs, 0);\n \t  }\n+\telse\n+\t  /* Here, things our simple; we have exactly what we need.  */\n+\t  TREE_TYPE (rhs) = lhstype;\n       }\n       return rhs;\n "}, {"sha": "c8f9fcc57e9b7bc30b6e76f0d4e7ce8b7afd1966", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "patch": "@@ -95,9 +95,6 @@ cp_convert_to_pointer (type, expr)\n \t}\n     }\n \n-  if (TYPE_PTRMEMFUNC_P (type))\n-    type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n-\n   /* Handle anachronistic conversions from (::*)() to cv void* or (*)().  */\n   if (TREE_CODE (type) == POINTER_TYPE\n       && (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n@@ -128,16 +125,14 @@ cp_convert_to_pointer (type, expr)\n       intype = TREE_TYPE (expr);\n     }\n \n-  if (TYPE_PTRMEMFUNC_P (intype))\n-    intype = TYPE_PTRMEMFUNC_FN_TYPE (intype);\n-\n   form = TREE_CODE (intype);\n \n-  if (form == POINTER_TYPE || form == REFERENCE_TYPE)\n+  if (POINTER_TYPE_P (intype))\n     {\n       intype = TYPE_MAIN_VARIANT (intype);\n \n       if (TYPE_MAIN_VARIANT (type) != intype\n+\t  && TREE_CODE (type) == POINTER_TYPE\n \t  && TREE_CODE (TREE_TYPE (type)) == RECORD_TYPE\n \t  && IS_AGGR_TYPE (TREE_TYPE (type))\n \t  && IS_AGGR_TYPE (TREE_TYPE (intype))\n@@ -181,12 +176,9 @@ cp_convert_to_pointer (type, expr)\n \t\t}\n \t    }\n \t}\n-      if (TREE_CODE (TREE_TYPE (intype)) == METHOD_TYPE\n-\t  && TREE_CODE (type) == POINTER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE)\n-\treturn build_ptrmemfunc (type, expr, 1);\n \n-      if (TREE_CODE (TREE_TYPE (type)) == OFFSET_TYPE\n+      if (TREE_CODE (type) == POINTER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (type)) == OFFSET_TYPE\n \t  && TREE_CODE (TREE_TYPE (intype)) == OFFSET_TYPE)\n \t{\n \t  tree b1 = TYPE_OFFSET_BASETYPE (TREE_TYPE (type));\n@@ -205,10 +197,7 @@ cp_convert_to_pointer (type, expr)\n \t  if (binfo && ! TREE_VIA_VIRTUAL (binfo))\n \t    expr = size_binop (code, expr, BINFO_OFFSET (binfo));\n \t}\n-\n-      if (TREE_CODE (TREE_TYPE (intype)) == METHOD_TYPE\n-\t  || (TREE_CODE (type) == POINTER_TYPE\n-\t      && TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE))\n+      else if (TYPE_PTRMEMFUNC_P (type))\n \t{\n \t  cp_error (\"cannot convert `%E' from type `%T' to type `%T'\",\n \t\t    expr, intype, type);\n@@ -219,6 +208,14 @@ cp_convert_to_pointer (type, expr)\n       TREE_CONSTANT (rval) = TREE_CONSTANT (expr);\n       return rval;\n     }\n+  else if (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype))\n+    return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, 1);\n+  else if (TYPE_PTRMEMFUNC_P (intype))\n+    {\n+      cp_error (\"cannot convert `%E' from type `%T' to type `%T'\",\n+\t\texpr, intype, type);\n+      return error_mark_node;\n+    }\n \n   my_friendly_assert (form != OFFSET_TYPE, 186);\n \n@@ -228,7 +225,7 @@ cp_convert_to_pointer (type, expr)\n \n   if (integer_zerop (expr))\n     {\n-      if (TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE)\n+      if (TYPE_PTRMEMFUNC_P (type))\n \treturn build_ptrmemfunc (type, expr, 0);\n       expr = build_int_2 (0, 0);\n       TREE_TYPE (expr) = type;"}, {"sha": "8940acb3ea003cdf6bc977aa2360d7960499270c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 154, "deletions": 64, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "patch": "@@ -180,7 +180,8 @@ static void check_for_uninitialized_const_var PROTO((tree));\n static unsigned long typename_hash PROTO((hash_table_key));\n static boolean typename_compare PROTO((hash_table_key, hash_table_key));\n static void push_binding PROTO((tree, tree, struct binding_level*));\n-static void pop_binding PROTO((tree));\n+static void add_binding PROTO((tree, tree));\n+static void pop_binding PROTO((tree, tree));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -602,7 +603,10 @@ push_decl_level (stack, obstack)\n    to catch class-local declarations.  It is otherwise nonexistent.\n \n    Also there may be binding levels that catch cleanups that must be\n-   run when exceptions occur.  */\n+   run when exceptions occur.  Thus, to see whether a name is bound in\n+   the current scope, it is not enough to look in the\n+   CURRENT_BINDING_LEVEL.  You should use lookup_name_current_level\n+   instead.  */\n \n /* Note that the information in the `names' component of the global contour\n    is duplicated in the IDENTIFIER_GLOBAL_VALUEs of all identifiers.  */\n@@ -637,7 +641,8 @@ struct binding_level\n        is the name of an entity bound in the class; the TREE_VALUE is\n        the IDENTIFIER_CLASS_VALUE before we entered the class.  Thus,\n        when leaving class scope, we can restore the\n-       IDENTIFIER_CLASS_VALUE by walking this list.  */\n+       IDENTIFIER_CLASS_VALUE by walking this list.  The TREE_TYPE is\n+       the DECL bound by this name in the class.  */\n     tree class_shadowed;\n \n     /* Similar to class_shadowed, but for IDENTIFIER_TYPE_VALUE, and\n@@ -1072,6 +1077,7 @@ push_binding (id, decl, level)\n \n   /* Now, fill in the binding information.  */\n   BINDING_VALUE (binding) = decl;\n+  BINDING_TYPE (binding) = NULL_TREE;\n   BINDING_LEVEL (binding) = level;\n   LOCAL_BINDING_P (binding) = (level != class_binding_level);\n \n@@ -1080,22 +1086,58 @@ push_binding (id, decl, level)\n   IDENTIFIER_BINDING (id) = binding;\n }\n \n+/* ID is already bound in the current scope.  But, DECL is an\n+   additional binding for ID in the same scope.  This is the `struct\n+   stat' hack whereby a non-typedef class-name or enum-name can be\n+   bound at the same level as some other kind of entity.  It's the\n+   responsibility of the caller to check that inserting this name is\n+   legal here.  */\n+static void\n+add_binding (id, decl)\n+     tree id;\n+     tree decl;\n+{\n+  tree binding = IDENTIFIER_BINDING (id);\n+\n+  if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl))\n+    /* The new name is the type name.  */\n+    BINDING_TYPE (binding) = decl;\n+  else \n+    {\n+      /* The old name must be the type name.  It was placed in\n+\t IDENTIFIER_VALUE because it was thought, at the point it\n+\t was declared, to be the only entity with such a name.  */\n+      my_friendly_assert (TREE_CODE (BINDING_VALUE (binding)) == TYPE_DECL\n+\t\t\t  && DECL_ARTIFICIAL (BINDING_VALUE (binding)),\n+\t\t\t  0);\n+\n+      /* Move the type name into the type slot; it is now hidden by\n+\t the new binding.  */\n+      BINDING_TYPE (binding) = BINDING_VALUE (binding);\n+      BINDING_VALUE (binding) = decl;\n+    }\n+}\n+\n /* Bind DECL to ID in the current_binding_level.  */\n \n void\n push_local_binding (id, decl)\n      tree id;\n      tree decl;\n {\n-  tree d = decl;;\n+  tree d = decl;\n \n   if (TREE_CODE (decl) == OVERLOAD)\n     /* We must put the OVERLOAD into a TREE_LIST since the\n        TREE_CHAIN of an OVERLOAD is already used.  */\n     decl = build_tree_list (NULL_TREE, decl);\n \n-  /* Create a binding, hanging off of ID.  */\n-  push_binding (id, d, current_binding_level);\n+  if (lookup_name_current_level (id))\n+    /* Supplement the existing binding.  */\n+    add_binding (id, decl);\n+  else\n+    /* Create a new binding.  */\n+    push_binding (id, d, current_binding_level);\n \n   /* And put DECL on the list of things declared by the current\n      binding level.  */\n@@ -1110,32 +1152,63 @@ push_class_binding (id, decl)\n      tree id;\n      tree decl;\n {\n-  push_binding (id, decl, class_binding_level);\n+  if (IDENTIFIER_BINDING (id)\n+      && BINDING_LEVEL (IDENTIFIER_BINDING (id)) == class_binding_level)\n+    /* Supplement the existing binding.  */\n+    add_binding (id, decl);\n+  else\n+    /* Create a new binding.  */\n+    push_binding (id, decl, class_binding_level);\n+\n+  /* Update the IDENTIFIER_CLASS_VALUE for this ID to be the\n+     class-level declaration.  Note that we do not use DECL here\n+     because of the possibility of the `struct stat' hack; if DECL is\n+     a class-name or enum-name we might prefer a field-name, or some\n+     such.  */\n+  IDENTIFIER_CLASS_VALUE (id) = BINDING_VALUE (IDENTIFIER_BINDING (id));\n }\n \n-/* Remove the innermost binding for ID; it has gone out of scope.  */\n+/* Remove the binding for DECL which should be the innermost binding\n+   for ID.  */\n \n static void \n-pop_binding (id) \n+pop_binding (id, decl) \n      tree id;\n+     tree decl;\n {\n   tree binding;\n-\n+    \n   if (id == NULL_TREE)\n     /* It's easiest to write the loops that call this function without\n        checking whether or not the entities involved have names.  We\n        get here for such an entity.  */\n     return;\n \n-  my_friendly_assert (IDENTIFIER_BINDING (id) != NULL_TREE, 0);\n-\n-  /* Unhook the innermost binding from the list of bindings.  */\n+  /* Get the innermost binding for ID.  */\n   binding = IDENTIFIER_BINDING (id);\n-  IDENTIFIER_BINDING (id) = TREE_CHAIN (binding);\n \n-  /* And place this list node on the free list.  */\n-  TREE_CHAIN (binding) = free_binding_nodes;\n-  free_binding_nodes = binding;\n+  /* The name should be bound.  */\n+  my_friendly_assert (binding != NULL_TREE, 0);\n+\n+  /* The DECL will be either the ordinary binding or the type\n+     binding for this identifier.  Remove that binding.  */\n+  if (BINDING_VALUE (binding) == decl)\n+    BINDING_VALUE (binding) = NULL_TREE;\n+  else if (BINDING_TYPE (binding) == decl)\n+    BINDING_TYPE (binding) = NULL_TREE;\n+  else\n+    my_friendly_abort (0);\n+\n+  if (!BINDING_VALUE (binding) && !BINDING_TYPE (binding))\n+    {\n+      /* We're completely done with the innermost binding for this\n+\t identifier.  Unhook it from the list of bindings.  */\n+      IDENTIFIER_BINDING (id) = TREE_CHAIN (binding);\n+\n+      /* And place it on the free list.  */\n+      TREE_CHAIN (binding) = free_binding_nodes;\n+      free_binding_nodes = binding;\n+    }\n }\n \n /* Exit a binding level.\n@@ -1303,7 +1376,7 @@ poplevel (keep, reverse, functionbody)\n \t\t \n \t       and we are leaving the `for' scope.  There's no reason to\n \t       keep the binding of the inner `i' in this case.  */\n-\t    pop_binding (DECL_NAME (link));\n+\t    pop_binding (DECL_NAME (link), link);\n \t  else if ((outer_binding \n \t\t    && (TREE_CODE (BINDING_VALUE (outer_binding)) \n \t\t\t== TYPE_DECL))\n@@ -1319,7 +1392,7 @@ poplevel (keep, reverse, functionbody)\n \n \t       We must pop the for-scope binding so we know what's a\n \t       type and what isn't.  */\n-\t    pop_binding (DECL_NAME (link));\n+\t    pop_binding (DECL_NAME (link), link);\n \t  else\n \t    {\n \t      /* Mark this VAR_DECL as dead so that we can tell we left it\n@@ -1350,10 +1423,11 @@ poplevel (keep, reverse, functionbody)\n \t{\n \t  /* Remove the binding.  */\n \t  if (TREE_CODE_CLASS (TREE_CODE (link)) == 'd')\n-\t    pop_binding (DECL_NAME (link));\n+\t    pop_binding (DECL_NAME (link), link);\n \t  else if (TREE_CODE (link) == TREE_LIST)\n-\t    pop_binding (DECL_NAME (OVL_FUNCTION (TREE_VALUE (link))));\n-\t  else\n+\t    pop_binding (DECL_NAME (OVL_FUNCTION (TREE_VALUE (link))), \n+\t\t\t TREE_VALUE (link));\n+\t  else \n \t    my_friendly_abort (0);\n \t}\n     }\n@@ -1362,7 +1436,7 @@ poplevel (keep, reverse, functionbody)\n      that we kept around.  */\n   for (link = current_binding_level->dead_vars_from_for;\n        link; link = TREE_CHAIN (link))\n-    pop_binding (DECL_NAME (TREE_VALUE (link)));\n+    pop_binding (DECL_NAME (TREE_VALUE (link)), TREE_VALUE (link));\n \n   /* Restore the IDENTIFIER_TYPE_VALUEs.  */\n   for (link = current_binding_level->type_shadowed;\n@@ -1607,7 +1681,7 @@ poplevel_class (force)\n   for (shadowed = level->class_shadowed; \n        shadowed; \n        shadowed = TREE_CHAIN (shadowed))\n-    pop_binding (TREE_PURPOSE (shadowed));\n+    pop_binding (TREE_PURPOSE (shadowed), TREE_TYPE (shadowed));\n \n   GNU_xref_end_scope ((HOST_WIDE_INT) class_binding_level,\n \t\t      (HOST_WIDE_INT) class_binding_level->level_chain,\n@@ -3617,12 +3691,6 @@ pushdecl (x)\n             set_identifier_type_value_with_scope (DECL_NAME (x), type, \n \t\t\t\t\t\t  current_binding_level);\n \n-\t  if (TREE_CODE (x) == TYPE_DECL\n-\t      && DECL_ARTIFICIAL (x)\n-\t      && t != NULL_TREE)\n-\t    /* We don't want an artificial TYPE_DECL is we already\n-\t       have another DECL with the same name.  */\n-\t    need_new_binding = 0;\n \t}\n \n       /* Multiple external decls of the same identifier ought to match.\n@@ -3663,7 +3731,8 @@ pushdecl (x)\n \t  if (IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE && TREE_PUBLIC (x))\n \t    TREE_PUBLIC (name) = 1;\n \n-\t  if (need_new_binding)\n+\t  if (!(TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)\n+\t\t&& t != NULL_TREE))\n \t    {\n \t      if (TREE_CODE (x) == FUNCTION_DECL)\n \t\tmy_friendly_assert \n@@ -3999,23 +4068,20 @@ push_class_level_binding (name, x)\n   if (!class_binding_level)\n     return;\n \n-  if (TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)\n-      && purpose_member (name, class_binding_level->class_shadowed))\n-    return;\n-\n   /* If this declaration shadows a declaration from an enclosing\n      class, then we will need to restore IDENTIFIER_CLASS_VALUE when\n      we leave this class.  Record the shadowed declaration here.  */\n   maybe_push_cache_obstack ();\n   class_binding_level->class_shadowed\n-      = tree_cons (name, IDENTIFIER_CLASS_VALUE (name),\n-\t\t   class_binding_level->class_shadowed);\n+    = tree_cons (name, IDENTIFIER_CLASS_VALUE (name),\n+\t\t class_binding_level->class_shadowed);\n+  TREE_TYPE (class_binding_level->class_shadowed)\n+    = x;\n   pop_obstacks ();\n \n   /* Put the binding on the stack of bindings for the identifier, and\n      update IDENTIFIER_CLASS_VALUE.  */\n   push_class_binding (name, x);\n-  IDENTIFIER_CLASS_VALUE (name) = x;\n \n   obstack_ptr_grow (&decl_obstack, x);\n }\n@@ -4155,8 +4221,8 @@ push_overloaded_decl (decl, forgettable)\n       /* We only create an OVERLOAD if there was a previous binding at\n \t this level.  In that case, we need to remove the old binding\n \t and replace it with the new binding.  We must also run\n-\t through the NAMES on the current binding level to update the\n-\t chain.  */\n+\t through the NAMES on the binding level where the name was\n+\t bound to update the chain.  */\n       if (TREE_CODE (new_binding) == OVERLOAD)\n \t{\n \t  tree *d;\n@@ -4168,11 +4234,21 @@ push_overloaded_decl (decl, forgettable)\n \t\t|| (TREE_CODE (*d) == TREE_LIST\n \t\t    && TREE_VALUE (*d) == old))\n \t      {\n-\t\t*d = TREE_CHAIN (*d);\n-\t\tbreak;\n+\t\tif (TREE_CODE (*d) == TREE_LIST)\n+\t\t  /* Just replace the old binding with the new.  */\n+\t\t  TREE_VALUE (*d) = new_binding;\n+\t\telse\n+\t\t  /* Build a TREE_LIST to wrap the OVERLOAD.  */\n+\t\t  *d = build_tree_list (NULL_TREE, new_binding);\n+\n+\t\t/* And update the CPLUS_BINDING node.  */\n+\t\tBINDING_VALUE (IDENTIFIER_BINDING (name))\n+\t\t  = new_binding;\n+\t\treturn decl;\n \t      }\n \n-\t  pop_binding (name);\n+\t  /* We should always find a previous binding in this case.  */\n+\t  my_friendly_abort (0);\n \t}\n \n       /* Install the new binding.  */\n@@ -4887,9 +4963,16 @@ lookup_namespace_name (namespace, name)\n \n   my_friendly_assert (TREE_CODE (namespace) == NAMESPACE_DECL, 370);\n \n-  /* This happens for A::B<int> when B is a namespace. */\n   if (TREE_CODE (name) == NAMESPACE_DECL)\n+    /* This happens for A::B<int> when B is a namespace. */\n     return name;\n+  else if (TREE_CODE (name) == TEMPLATE_DECL)\n+    {\n+      /* This happens for A::B where B is a template, and there are no\n+\t template arguments.  */\n+      cp_error (\"invalid use of `%D'\", name);\n+      return error_mark_node;\n+    }\n \n   my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 373);\n   \n@@ -5321,15 +5404,27 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n   else\n     flags = lookup_flags (prefer_type, namespaces_only);\n \n-  /* First, look in a non-global scope, carefully avoiding any\n-     class-scope bindings if required.  */\n+  /* First, look in non-namespace scopes.  */\n   val = IDENTIFIER_BINDING (name); \n-  while (val && nonclass && !LOCAL_BINDING_P (val))\n-    val = TREE_CHAIN (val);\n-\n-  /* Get the DECL actually bound.  */\n-  if (val)\n-    val = BINDING_VALUE (val);\n+  for (val = IDENTIFIER_BINDING (name); val; val = TREE_CHAIN (val))\n+    {\n+      if (!LOCAL_BINDING_P (val) && nonclass)\n+\t/* We're not looking for class-scoped bindings, so keep going.  */\n+\tcontinue;\n+      \n+      /* If this is the kind of thing we're looking for, we're done.  */\n+      if (qualify_lookup (BINDING_VALUE (val), flags))\n+\t{\n+\t  val = BINDING_VALUE (val);\n+\t  break;\n+\t}\n+      else if ((flags & LOOKUP_PREFER_TYPES) \n+\t       && qualify_lookup (BINDING_TYPE (val), flags))\n+\t{\n+\t  val = BINDING_TYPE (val);\n+\t  break;\n+\t}\n+    }\n \n   /* If VAL is a type from a dependent base, we're not really supposed\n      to be able to see it; the fact that we can is the \"implicit\n@@ -5342,10 +5437,6 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n       && uses_template_parms (current_class_type))\n     val = lookup_field (current_class_type, name, 0, 1);\n \n-  /* Make sure that this binding is the sort of thing we're looking\n-     for.  */\n-  val = qualify_lookup (val, flags);\n-\n   /* We don't put names from baseclasses onto the IDENTIFIER_BINDING\n      list when we're defining a type.  It would probably be simpler to\n      do this, but we don't.  So, we must lookup names from base\n@@ -5361,8 +5452,8 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n     }\n   \n   /* If we found a type from a dependent base class (using the\n-     implicit typename extension), turn it into the TYPE_DECL for a\n-     TYPENAME_TYPE here.  */\n+     implicit typename extension) make sure that there's not some\n+     global name which should be chosen instead.  */\n   if (val && TREE_CODE (val) == TYPE_DECL\n       && IMPLICIT_TYPENAME_P (TREE_TYPE (val)))\n     {\n@@ -8575,7 +8666,8 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n   return decl;\n }\n \n-/* Create a canonical pointer to member function type.  */\n+/* Create and return a canonical pointer to member function type, for\n+   TYPE, which is a POINTER_TYPE to a METHOD_TYPE.  */\n \n tree\n build_ptrmemfunc_type (type)\n@@ -9790,7 +9882,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t\t/* If this involves a template parameter, it'll be\n \t\t   constant, but we don't know what the value is yet.  */\n-\t\tif (processing_template_decl)\n+\t\tif (uses_template_parms (size))\n \t\t  {\n \t\t    /* Resolve a qualified reference to an enumerator or\n \t\t       static const data member of ours.  */\n@@ -10141,9 +10233,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\ttype = build_reference_type (type);\n \t    }\n \t  else if (TREE_CODE (type) == METHOD_TYPE)\n-\t    {\n-\t      type = build_ptrmemfunc_type (build_pointer_type (type));\n-\t    }\n+\t    type = build_ptrmemfunc_type (build_pointer_type (type));\n \t  else\n \t    type = build_pointer_type (type);\n \n@@ -13976,7 +14066,7 @@ finish_method (decl)\n   for (link = current_binding_level->names; link; link = TREE_CHAIN (link))\n     {\n       if (DECL_NAME (link) != NULL_TREE)\n-\tpop_binding (DECL_NAME (link));\n+\tpop_binding (DECL_NAME (link), link);\n       my_friendly_assert (TREE_CODE (link) != FUNCTION_DECL, 163);\n       DECL_CONTEXT (link) = NULL_TREE;\n     }"}, {"sha": "fba06619cfbbfc03d84f0bab8f82c337a2ff74f5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "patch": "@@ -3547,7 +3547,7 @@ reparse_absdcl_as_expr (type, decl)\n     return build_functional_cast (type, NULL_TREE);\n \n   /* recurse */\n-  decl = reparse_decl_as_expr (type, TREE_OPERAND (decl, 0));\n+  decl = reparse_absdcl_as_expr (type, TREE_OPERAND (decl, 0));\n \n   decl = build_x_function_call (decl, NULL_TREE, current_class_ref);\n \n@@ -3770,11 +3770,28 @@ build_expr_from_tree (t)\n \t     TREE_OPERAND (ref, 1),\n \t     build_expr_from_tree (TREE_OPERAND (t, 2)));\n \t}\n-      return build_method_call\n-\t(build_expr_from_tree (TREE_OPERAND (t, 1)),\n-\t TREE_OPERAND (t, 0),\n-\t build_expr_from_tree (TREE_OPERAND (t, 2)),\n-\t NULL_TREE, LOOKUP_NORMAL);\n+      else \n+\t{\n+\t  tree fn = TREE_OPERAND (t, 0);\n+\t  \n+\t  /* We can get a TEMPLATE_ID_EXPR here on code like:\n+\n+\t       x->f<2>();\n+\t      \n+\t     so we must resolve that.  However, we can also get things\n+\t     like a BIT_NOT_EXPR here, when referring to a destructor,\n+\t     and things like that are not correctly resolved by\n+\t     build_expr_from_tree.  So, just use build_expr_from_tree\n+\t     when we really need it.  */\n+\t  if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n+\t    fn = build_expr_from_tree (fn);\n+\n+\t  return build_method_call\n+\t    (build_expr_from_tree (TREE_OPERAND (t, 1)),\n+\t     fn,\n+\t     build_expr_from_tree (TREE_OPERAND (t, 2)),\n+\t     NULL_TREE, LOOKUP_NORMAL);\n+\t}\n \n     case CALL_EXPR:\n       if (TREE_CODE (TREE_OPERAND (t, 0)) == SCOPE_REF)"}, {"sha": "ece3f29c8410d32370e2efafa447a149dce82c21", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "patch": "@@ -2710,9 +2710,6 @@ convert_nontype_argument (type, expr)\n \n     case RECORD_TYPE:\n       {\n-\ttree fns;\n-\ttree fn;\n-\n \tif (!TYPE_PTRMEMFUNC_P (type))\n \t  /* This handles templates like\n \t       template<class T, T t> void f();\n@@ -2743,16 +2740,11 @@ convert_nontype_argument (type, expr)\n \tif (TREE_CODE (expr) != ADDR_EXPR)\n \t  return error_mark_node;\n \n-\tfns = TREE_OPERAND (expr, 0);\n-\t\n-\tfn = instantiate_type (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (type)),\n-\t\t\t       fns, 0);\n+\texpr = instantiate_type (type, expr, 0);\n \t\n-\tif (fn == error_mark_node)\n+\tif (expr == error_mark_node)\n \t  return error_mark_node;\n \n-\texpr = build_unary_op (ADDR_EXPR, fn, 0);\n-\t\n \tmy_friendly_assert (same_type_p (type, TREE_TYPE (expr)),\n \t\t\t    0);\n \treturn expr;\n@@ -6972,8 +6964,7 @@ maybe_adjust_types_for_deduction (strict, parm, arg)\n \t deduction.  */\n       if (TREE_CODE (*arg) == ARRAY_TYPE)\n \t*arg = build_pointer_type (TREE_TYPE (*arg));\n-      else if (TREE_CODE (*arg) == FUNCTION_TYPE\n-\t  || TREE_CODE (*arg) == METHOD_TYPE)\n+      else if (TREE_CODE (*arg) == FUNCTION_TYPE)\n \t*arg = build_pointer_type (*arg);\n       else\n \t*arg = TYPE_MAIN_VARIANT (*arg);\n@@ -7163,6 +7154,11 @@ resolve_overloaded_unification (tparms, targs, parm, arg, strict,\n   if (TREE_CODE (arg) == ADDR_EXPR)\n     arg = TREE_OPERAND (arg, 0);\n \n+  if (TREE_CODE (arg) == COMPONENT_REF)\n+    /* Handle `&x' where `x' is some static or non-static member\n+       function name.  */\n+    arg = TREE_OPERAND (arg, 1);\n+\n   /* Strip baselink information.  */\n   while (TREE_CODE (arg) == TREE_LIST)\n     arg = TREE_VALUE (arg);\n@@ -7188,6 +7184,8 @@ resolve_overloaded_unification (tparms, targs, parm, arg, strict,\n \t  if (subargs)\n \t    {\n \t      elem = tsubst (TREE_TYPE (fn), subargs, NULL_TREE);\n+\t      if (TREE_CODE (elem) == METHOD_TYPE)\n+\t\telem = build_ptrmemfunc_type (build_pointer_type (elem));\n \t      good += try_one_overload (tparms, targs, tempargs, parm, elem,\n \t\t\t\t\tstrict, sub_strict, explicit_mask);\n \t    }\n@@ -7196,9 +7194,14 @@ resolve_overloaded_unification (tparms, targs, parm, arg, strict,\n   else if (TREE_CODE (arg) == OVERLOAD)\n     {\n       for (; arg; arg = OVL_NEXT (arg))\n-\tgood += try_one_overload (tparms, targs, tempargs, parm,\n-\t\t\t\t  TREE_TYPE (OVL_CURRENT (arg)),\n-\t\t\t\t  strict, sub_strict, explicit_mask);\n+\t{\n+\t  tree type = TREE_TYPE (OVL_CURRENT (arg));\n+\t  if (TREE_CODE (type) == METHOD_TYPE)\n+\t    type = build_ptrmemfunc_type (build_pointer_type (type));\n+\t  good += try_one_overload (tparms, targs, tempargs, parm,\n+\t\t\t\t    type,\n+\t\t\t\t    strict, sub_strict, explicit_mask);\n+\t}\n     }\n   else\n     my_friendly_abort (981006);"}, {"sha": "8bb750a66172d3d21b295f17c0185fe3833b34fc", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "patch": "@@ -416,7 +416,7 @@ build_cplus_array_type_1 (elt_type, index_type)\n       saveable_obstack = &permanent_obstack;\n     }\n \n-  if (processing_template_decl\n+  if (uses_template_parms (elt_type)\n       || uses_template_parms (index_type))\n     {\n       t = make_node (ARRAY_TYPE);\n@@ -1467,15 +1467,20 @@ build_exception_variant (type, raises)\n \n   for (; v; v = TYPE_NEXT_VARIANT (v))\n     {\n+      tree t;\n+      tree u;\n+\n       if (TYPE_QUALS (v) != type_quals)\n \tcontinue;\n \n-      /* @@ This should do set equality, not exact match.  */\n-      if (simple_cst_list_equal (TYPE_RAISES_EXCEPTIONS (v), raises))\n-\t/* List of exceptions raised matches previously found list.\n+      for (t = TYPE_RAISES_EXCEPTIONS (v), u = raises;\n+\t   t != NULL_TREE && u != NULL_TREE;\n+\t   t = TREE_CHAIN (t), u = TREE_CHAIN (v))\n+\tif (!same_type_p (TREE_VALUE (t), TREE_VALUE (u)))\n+\t  break;\n \n-\t   @@ Nice to free up storage used in consing up the\n-\t   @@ list of exceptions raised.  */\n+      if (!t && !u)\n+\t/* There's a memory leak here; RAISES is not freed.  */\n \treturn v;\n     }\n "}, {"sha": "521315e17e2ee61f6bcdd3474412a1af588b931d", "filename": "gcc/testsuite/g++.old-deja/g++.eh/tmpl3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Ftmpl3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Ftmpl3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Ftmpl3.C?ref=d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "patch": "@@ -3,9 +3,9 @@\n // Posted by Trevor Taylor <ttaylor@powerup.com.au>\n \n template<class T> struct A {\n-    void X() throw(T); // gets bogus error - previous decl - XFAIL *-*-*\n+    void X() throw(T);\n };\n \n template<class T>\n inline void A<T>::X() \n-throw(T) { } // gets bogus error - different throws - XFAIL *-*-*\n+throw(T) { } "}, {"sha": "842ed090bcc62d34317eeec69809ab968592d582", "filename": "gcc/testsuite/g++.old-deja/g++.ns/crash3.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ns%2Fcrash3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ns%2Fcrash3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ns%2Fcrash3.C?ref=d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "patch": "@@ -0,0 +1,10 @@\n+// Build don't link:\n+\n+namespace N {\n+  template <class T> struct S;\n+};\n+\n+void f()\n+{\n+  N::S(); // ERROR - invalid use of template\n+}"}, {"sha": "fece8d48c29f1b1577ad63dbb69c0d19e49a7334", "filename": "gcc/testsuite/g++.old-deja/g++.other/expr1.C", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fexpr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fexpr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fexpr1.C?ref=d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "patch": "@@ -1,11 +1,9 @@\n // Build don't link:\n \n-// crash test - XFAIL *-*-*\n-\n // Simplified from bug report by Trevor Taylor <ttaylor@powerup.com.au>\n \n struct T {\n-  int operator()(int) { }\n+  int operator()(int) { } // ERROR - candidate\n };\n \n int main() {"}, {"sha": "f81572ab2601987bb0e539da54281dc7c6384516", "filename": "gcc/testsuite/g++.old-deja/g++.other/lookup8.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup8.C?ref=d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "patch": "@@ -0,0 +1,14 @@\n+// Build don't link:\n+\n+struct S {\n+  int A;\n+  struct A {\n+    enum { a = 0 };\n+  };\n+\n+  void f();\n+};\n+\n+void S::f() {\n+  A = A::a;\n+}"}, {"sha": "6c5810ed77be195cad6744cc1910a405d1521838", "filename": "gcc/testsuite/g++.old-deja/g++.pt/array2.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Farray2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Farray2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Farray2.C?ref=d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "patch": "@@ -0,0 +1,14 @@\n+// Build don't link:\n+\n+template<int N, class C>\n+class Bar {};\n+\n+template<class C>\n+class Huh {};\n+\n+template<int N>\n+void foo(const Bar<N,Huh<float[1]> > &x) {}\n+\n+int main() {\n+  foo(Bar<3,Huh<float[1]> >());\n+}"}, {"sha": "1584f88b8020de88347c90260f44a6814a26117e", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memtemp81.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp81.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp81.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp81.C?ref=d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "patch": "@@ -0,0 +1,24 @@\n+// Build don't link:\n+\n+template <int i> class a\n+{\n+public :\n+int  k;\n+\n+template <int j> int f() const { return this->f<j-1>(); }\n+\n+int g() const { return f<i>(); };\n+};\n+\n+template <>\n+template <>\n+int a<2>::f<0>() const {\n+  return 0;\n+}\n+\n+int main()\n+{\n+a<2> x;\n+return x.g();\n+}\n+"}, {"sha": "300d91ea2b81c96d1804fe0626858ce02193619a", "filename": "gcc/testsuite/g++.old-deja/g++.pt/overload11.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Foverload11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Foverload11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Foverload11.C?ref=d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "patch": "@@ -0,0 +1,27 @@\n+// Build don't run:\n+\n+template <class T>\n+int f(int (*fn)(T))\n+{\n+  return (*fn)(3);\n+}\n+\n+struct S {\n+  static int g(int) { return 1; }\n+  static void g();\n+\n+  int h();\n+};\n+\n+int S::h()\n+{\n+  return f(&g);\n+}\n+\n+\n+int main()\n+{\n+  S s;\n+  if (s.h () != 1)\n+    return 1;\n+}"}, {"sha": "139be9235507042fbd13ea0a1292d01d5ef134e1", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ptrmem4.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem4.C?ref=d8f8dca15f590c4f7514d43c4b2a6c61270ea7fa", "patch": "@@ -0,0 +1,28 @@\n+// Build don't run:\n+\n+template<class T,class T1>\n+int connect_to_method(T* receiver,\n+                      int (T1::*method)()) \n+{ \n+  return (receiver->*method)();\n+}\n+\n+class Gtk_Container\n+{\n+public:\n+  int remove_callback() { return 1; }\n+  void remove_callback(int);\n+  int f();\n+};\n+\n+int Gtk_Container::f() \n+{\n+  return connect_to_method(this, &Gtk_Container::remove_callback);\n+}\n+\n+int main()\n+{\n+  Gtk_Container gc;\n+  if (gc.f () != 1)\n+    return 1;\n+}"}]}