{"sha": "477008025c8ae99fdaa6acd66e57b5a0616b3347", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc3MDA4MDI1YzhhZTk5ZmRhYTZhY2Q2NmU1N2I1YTA2MTZiMzM0Nw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-15T02:15:41Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-15T02:15:41Z"}, "message": "(dbxout_symbol_location): Subroutine broken out from dbxout_symbol.\n\n(dbxout_symbol_location): Subroutine broken out from\ndbxout_symbol.  Handle CONCAT here.\n(dbxout_symbol_name): New subroutine.  Handle anonymous decls too.\n(dbxout_reg_parms): Simplify using dbxout_symbol_location.\nHandle CONCAT.\n\nFrom-SVN: r4921", "tree": {"sha": "3c9c822d3d3c839fc56ce4e6c6ff22a65f1f3f26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c9c822d3d3c839fc56ce4e6c6ff22a65f1f3f26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/477008025c8ae99fdaa6acd66e57b5a0616b3347", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/477008025c8ae99fdaa6acd66e57b5a0616b3347", "html_url": "https://github.com/Rust-GCC/gccrs/commit/477008025c8ae99fdaa6acd66e57b5a0616b3347", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/477008025c8ae99fdaa6acd66e57b5a0616b3347/comments", "author": null, "committer": null, "parents": [{"sha": "ec4738c0ca6712bc322b0d2dcfdfe440ba7cdbb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec4738c0ca6712bc322b0d2dcfdfe440ba7cdbb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec4738c0ca6712bc322b0d2dcfdfe440ba7cdbb9"}], "stats": {"total": 403, "additions": 215, "deletions": 188}, "files": [{"sha": "c2afd68921c7593b00ded71252a9f1eff0a433e9", "filename": "gcc/dbxout.c", "status": "modified", "additions": 215, "deletions": 188, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477008025c8ae99fdaa6acd66e57b5a0616b3347/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477008025c8ae99fdaa6acd66e57b5a0616b3347/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=477008025c8ae99fdaa6acd66e57b5a0616b3347", "patch": "@@ -263,6 +263,8 @@ void dbxout_symbol ();\n static void dbxout_type_name ();\n static void dbxout_type ();\n static void dbxout_typedefs ();\n+static void dbxout_symbol_name ();\n+static void dbxout_symbol_location ();\n static void dbxout_prepare_symbol ();\n static void dbxout_finish_symbol ();\n static void dbxout_continue ();\n@@ -1667,188 +1669,242 @@ dbxout_symbol (decl, local)\n \tleaf_renumber_regs_insn (DECL_RTL (decl));\n #endif\n \n-      /* Don't mention a variable at all\n-\t if it was completely optimized into nothingness.\n+      dbxout_symbol_location (decl, type, 0, DECL_RTL (decl));\n+    }\n+}\n+\f\n+/* Output the stab for DECL, a VAR_DECL, RESULT_DECL or PARM_DECL.\n+   Add SUFFIX to its name, if SUFFIX is not 0.\n+   Describe the variable as residing in HOME\n+   (usually HOME is DECL_RTL (DECL), but not always).  */\n+\n+static void\n+dbxout_symbol_location (decl, type, suffix, home)\n+     tree decl, type;\n+     char *suffix;\n+     rtx home;\n+{\n+  int letter = 0;\n+  int regno = -1;\n \n-\t If DECL was from an inline function, then it's rtl\n-\t is not identically the rtl that was used in this\n-\t particular compilation.  */\n-      if (GET_CODE (DECL_RTL (decl)) == REG)\n+  /* Don't mention a variable at all\n+     if it was completely optimized into nothingness.\n+     \n+     If the decl was from an inline function, then it's rtl\n+     is not identically the rtl that was used in this\n+     particular compilation.  */\n+  if (GET_CODE (home) == REG)\n+    {\n+      regno = REGNO (home);\n+      if (regno >= FIRST_PSEUDO_REGISTER)\n+\treturn;\n+    }\n+  else if (GET_CODE (home) == SUBREG)\n+    {\n+      rtx value = home;\n+      int offset = 0;\n+      while (GET_CODE (value) == SUBREG)\n \t{\n-\t  regno = REGNO (DECL_RTL (decl));\n+\t  offset += SUBREG_WORD (value);\n+\t  value = SUBREG_REG (value);\n+\t}\n+      if (GET_CODE (value) == REG)\n+\t{\n+\t  regno = REGNO (value);\n \t  if (regno >= FIRST_PSEUDO_REGISTER)\n \t    return;\n+\t  regno += offset;\n \t}\n-      else if (GET_CODE (DECL_RTL (decl)) == SUBREG)\n+      alter_subreg (home);\n+    }\n+\n+  /* The kind-of-variable letter depends on where\n+     the variable is and on the scope of its name:\n+     G and N_GSYM for static storage and global scope,\n+     S for static storage and file scope,\n+     V for static storage and local scope,\n+     for those two, use N_LCSYM if data is in bss segment,\n+     N_STSYM if in data segment, N_FUN otherwise.\n+     (We used N_FUN originally, then changed to N_STSYM\n+     to please GDB.  However, it seems that confused ld.\n+     Now GDB has been fixed to like N_FUN, says Kingdon.)\n+     no letter at all, and N_LSYM, for auto variable,\n+     r and N_RSYM for register variable.  */\n+\n+  if (GET_CODE (home) == MEM\n+      && GET_CODE (XEXP (home, 0)) == SYMBOL_REF)\n+    {\n+      if (TREE_PUBLIC (decl))\n \t{\n-\t  rtx value = DECL_RTL (decl);\n-\t  int offset = 0;\n-\t  while (GET_CODE (value) == SUBREG)\n-\t    {\n-\t      offset += SUBREG_WORD (value);\n-\t      value = SUBREG_REG (value);\n-\t    }\n-\t  if (GET_CODE (value) == REG)\n-\t    {\n-\t      regno = REGNO (value);\n-\t      if (regno >= FIRST_PSEUDO_REGISTER)\n-\t\treturn;\n-\t      regno += offset;\n-\t    }\n-\t  alter_subreg (DECL_RTL (decl));\n+\t  letter = 'G';\n+\t  current_sym_code = N_GSYM;\n \t}\n-\n-      /* The kind-of-variable letter depends on where\n-\t the variable is and on the scope of its name:\n-\t G and N_GSYM for static storage and global scope,\n-\t S for static storage and file scope,\n-\t V for static storage and local scope,\n-\t    for those two, use N_LCSYM if data is in bss segment,\n-\t    N_STSYM if in data segment, N_FUN otherwise.\n-\t    (We used N_FUN originally, then changed to N_STSYM\n-\t    to please GDB.  However, it seems that confused ld.\n-\t    Now GDB has been fixed to like N_FUN, says Kingdon.)\n-\t no letter at all, and N_LSYM, for auto variable,\n-\t r and N_RSYM for register variable.  */\n-\n-      if (GET_CODE (DECL_RTL (decl)) == MEM\n-\t  && GET_CODE (XEXP (DECL_RTL (decl), 0)) == SYMBOL_REF)\n+      else\n \t{\n-\t  if (TREE_PUBLIC (decl))\n-\t    {\n-\t      letter = 'G';\n-\t      current_sym_code = N_GSYM;\n-\t    }\n-\t  else\n-\t    {\n-\t      current_sym_addr = XEXP (DECL_RTL (decl), 0);\n+\t  current_sym_addr = XEXP (home, 0);\n \n-\t      letter = decl_function_context (decl) ? 'V' : 'S';\n+\t  letter = decl_function_context (decl) ? 'V' : 'S';\n \n-\t      if (!DECL_INITIAL (decl))\n-\t\tcurrent_sym_code = N_LCSYM;\n-\t      else if (TREE_READONLY (decl) && ! TREE_THIS_VOLATILE (decl))\n-\t\t/* This is not quite right, but it's the closest\n-\t\t   of all the codes that Unix defines.  */\n-\t\tcurrent_sym_code = DBX_STATIC_CONST_VAR_CODE;\n-\t      else\n-\t\t{\n-/* Ultrix `as' seems to need this.  */\n+\t  if (!DECL_INITIAL (decl))\n+\t    current_sym_code = N_LCSYM;\n+\t  else if (TREE_READONLY (decl) && ! TREE_THIS_VOLATILE (decl))\n+\t    /* This is not quite right, but it's the closest\n+\t       of all the codes that Unix defines.  */\n+\t    current_sym_code = DBX_STATIC_CONST_VAR_CODE;\n+\t  else\n+\t    {\n+\t      /* Ultrix `as' seems to need this.  */\n #ifdef DBX_STATIC_STAB_DATA_SECTION\n-\t\t  data_section ();\n+\t      data_section ();\n #endif\n-\t\t  current_sym_code = N_STSYM;\n-\t\t}\n+\t      current_sym_code = N_STSYM;\n \t    }\n \t}\n-      else if (regno >= 0)\n+    }\n+  else if (regno >= 0)\n+    {\n+      letter = 'r';\n+      current_sym_code = N_RSYM;\n+      current_sym_value = DBX_REGISTER_NUMBER (regno);\n+    }\n+  else if (GET_CODE (home) == MEM\n+\t   && (GET_CODE (XEXP (home, 0)) == MEM\n+\t       || (GET_CODE (XEXP (home, 0)) == REG\n+\t\t   && REGNO (XEXP (home, 0)) != FRAME_POINTER_REGNUM)))\n+    /* If the value is indirect by memory or by a register\n+       that isn't the frame pointer\n+       then it means the object is variable-sized and address through\n+       that register or stack slot.  DBX has no way to represent this\n+       so all we can do is output the variable as a pointer.\n+       If it's not a parameter, ignore it.\n+       (VAR_DECLs like this can be made by integrate.c.)  */\n+    {\n+      if (GET_CODE (XEXP (home, 0)) == REG)\n \t{\n \t  letter = 'r';\n \t  current_sym_code = N_RSYM;\n-\t  current_sym_value = DBX_REGISTER_NUMBER (regno);\n-\t}\n-      else if (GET_CODE (DECL_RTL (decl)) == MEM\n-\t       && (GET_CODE (XEXP (DECL_RTL (decl), 0)) == MEM\n-\t\t   || (GET_CODE (XEXP (DECL_RTL (decl), 0)) == REG\n-\t\t       && REGNO (XEXP (DECL_RTL (decl), 0)) != FRAME_POINTER_REGNUM)))\n-\t/* If the value is indirect by memory or by a register\n-\t   that isn't the frame pointer\n-\t   then it means the object is variable-sized and address through\n-\t   that register or stack slot.  DBX has no way to represent this\n-\t   so all we can do is output the variable as a pointer.\n-\t   If it's not a parameter, ignore it.\n-\t   (VAR_DECLs like this can be made by integrate.c.)  */\n-\t{\n-\t  if (GET_CODE (XEXP (DECL_RTL (decl), 0)) == REG)\n-\t    {\n-\t      letter = 'r';\n-\t      current_sym_code = N_RSYM;\n-\t      current_sym_value = DBX_REGISTER_NUMBER (REGNO (XEXP (DECL_RTL (decl), 0)));\n-\t    }\n-\t  else\n-\t    {\n-\t      current_sym_code = N_LSYM;\n-\t      /* DECL_RTL looks like (MEM (MEM (PLUS (REG...) (CONST_INT...)))).\n-\t\t We want the value of that CONST_INT.  */\n-\t      current_sym_value\n-\t\t= DEBUGGER_AUTO_OFFSET (XEXP (XEXP (DECL_RTL (decl), 0), 0));\n-\t    }\n-\n-\t  /* Effectively do build_pointer_type, but don't cache this type,\n-\t     since it might be temporary whereas the type it points to\n-\t     might have been saved for inlining.  */\n-\t  /* Don't use REFERENCE_TYPE because dbx can't handle that.  */\n-\t  type = make_node (POINTER_TYPE);\n-\t  TREE_TYPE (type) = TREE_TYPE (decl);\n-\t}\n-      else if (GET_CODE (DECL_RTL (decl)) == MEM\n-\t       && GET_CODE (XEXP (DECL_RTL (decl), 0)) == REG)\n-\t{\n-\t  current_sym_code = N_LSYM;\n-\t  current_sym_value = DEBUGGER_AUTO_OFFSET (XEXP (DECL_RTL (decl), 0));\n+\t  current_sym_value = DBX_REGISTER_NUMBER (REGNO (XEXP (home, 0)));\n \t}\n-      else if (GET_CODE (DECL_RTL (decl)) == MEM\n-\t       && GET_CODE (XEXP (DECL_RTL (decl), 0)) == PLUS\n-\t       && GET_CODE (XEXP (XEXP (DECL_RTL (decl), 0), 1)) == CONST_INT)\n+      else\n \t{\n \t  current_sym_code = N_LSYM;\n-\t  /* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...)))\n+\t  /* RTL looks like (MEM (MEM (PLUS (REG...) (CONST_INT...)))).\n \t     We want the value of that CONST_INT.  */\n-\t  current_sym_value = DEBUGGER_AUTO_OFFSET (XEXP (DECL_RTL (decl), 0));\n-\t}\n-      else if (GET_CODE (DECL_RTL (decl)) == MEM\n-\t       && GET_CODE (XEXP (DECL_RTL (decl), 0)) == CONST)\n-\t{\n-\t  /* Handle an obscure case which can arise when optimizing and\n-\t     when there are few available registers.  (This is *always*\n-\t     the case for i386/i486 targets).  The DECL_RTL looks like\n-\t     (MEM (CONST ...)) even though this variable is a local `auto'\n-\t     or a local `register' variable.  In effect, what has happened\n-\t     is that the reload pass has seen that all assignments and\n-\t     references for one such a local variable can be replaced by\n-\t     equivalent assignments and references to some static storage\n-\t     variable, thereby avoiding the need for a register.  In such\n-\t     cases we're forced to lie to debuggers and tell them that\n-\t     this variable was itself `static'.  */\n-\t  current_sym_code = N_LCSYM;\n-\t  letter = 'V';\n-\t  current_sym_addr = XEXP (XEXP (DECL_RTL (decl), 0), 0);\n+\t  current_sym_value\n+\t    = DEBUGGER_AUTO_OFFSET (XEXP (XEXP (home, 0), 0));\n \t}\n+\n+      /* Effectively do build_pointer_type, but don't cache this type,\n+\t since it might be temporary whereas the type it points to\n+\t might have been saved for inlining.  */\n+      /* Don't use REFERENCE_TYPE because dbx can't handle that.  */\n+      type = make_node (POINTER_TYPE);\n+      TREE_TYPE (type) = TREE_TYPE (decl);\n+    }\n+  else if (GET_CODE (home) == MEM\n+\t   && GET_CODE (XEXP (home, 0)) == REG)\n+    {\n+      current_sym_code = N_LSYM;\n+      current_sym_value = DEBUGGER_AUTO_OFFSET (XEXP (home, 0));\n+    }\n+  else if (GET_CODE (home) == MEM\n+\t   && GET_CODE (XEXP (home, 0)) == PLUS\n+\t   && GET_CODE (XEXP (XEXP (home, 0), 1)) == CONST_INT)\n+    {\n+      current_sym_code = N_LSYM;\n+      /* RTL looks like (MEM (PLUS (REG...) (CONST_INT...)))\n+\t We want the value of that CONST_INT.  */\n+      current_sym_value = DEBUGGER_AUTO_OFFSET (XEXP (home, 0));\n+    }\n+  else if (GET_CODE (home) == MEM\n+\t   && GET_CODE (XEXP (home, 0)) == CONST)\n+    {\n+      /* Handle an obscure case which can arise when optimizing and\n+\t when there are few available registers.  (This is *always*\n+\t the case for i386/i486 targets).  The RTL looks like\n+\t (MEM (CONST ...)) even though this variable is a local `auto'\n+\t or a local `register' variable.  In effect, what has happened\n+\t is that the reload pass has seen that all assignments and\n+\t references for one such a local variable can be replaced by\n+\t equivalent assignments and references to some static storage\n+\t variable, thereby avoiding the need for a register.  In such\n+\t cases we're forced to lie to debuggers and tell them that\n+\t this variable was itself `static'.  */\n+      current_sym_code = N_LCSYM;\n+      letter = 'V';\n+      current_sym_addr = XEXP (XEXP (home, 0), 0);\n+    }\n+  else if (GET_CODE (home) == CONCAT)\n+    {\n+      tree subtype = TREE_TYPE (type);\n+\n+      /* If the variable's storage is in two parts,\n+\t output each as a separate stab with a modified name.  */\n+      if (WORDS_BIG_ENDIAN)\n+\tdbxout_symbol_location (decl, subtype, \"$imag\", XEXP (home, 0));\n       else\n-\t/* Address might be a MEM, when DECL is a variable-sized object.\n-\t   Or it might be const0_rtx, meaning previous passes\n-\t   want us to ignore this variable.  */\n-\tbreak;\n+\tdbxout_symbol_location (decl, subtype, \"$real\", XEXP (home, 0));\n \n-      /* Ok, start a symtab entry and output the variable name.  */\n-      FORCE_TEXT;\n+      /* Cast avoids warning in old compilers.  */\n+      current_sym_code = (STAB_CODE_TYPE) 0;\n+      current_sym_value = 0;\n+      current_sym_addr = 0;\n+      dbxout_prepare_symbol (decl);\n+\n+      if (WORDS_BIG_ENDIAN)\n+\tdbxout_symbol_location (decl, subtype, \"$real\", XEXP (home, 1));\n+      else\n+\tdbxout_symbol_location (decl, subtype, \"$imag\", XEXP (home, 1));\n+      return;\n+    }\n+  else\n+    /* Address might be a MEM, when DECL is a variable-sized object.\n+       Or it might be const0_rtx, meaning previous passes\n+       want us to ignore this variable.  */\n+    return;\n+\n+  /* Ok, start a symtab entry and output the variable name.  */\n+  FORCE_TEXT;\n \n #ifdef DBX_STATIC_BLOCK_START\n-      DBX_STATIC_BLOCK_START (asmfile, current_sym_code);\n+  DBX_STATIC_BLOCK_START (asmfile, current_sym_code);\n #endif\n \n-      /* One slight hitch: if this is a VAR_DECL which is a static\n-\t class member, we must put out the mangled name instead of the\n-\t DECL_NAME.  */\n-      {\n-\tchar *name;\n-\t/* Note also that static member (variable) names DO NOT begin\n-\t   with underscores in .stabs directives.  */\n-\tif (DECL_LANG_SPECIFIC (decl))\n-\t  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-\telse\n-\t  name = IDENTIFIER_POINTER (DECL_NAME (decl));\n-\tfprintf (asmfile, \"%s \\\"%s:\", ASM_STABS_OP, name);\n-      }\n-      if (letter) putc (letter, asmfile);\n-      dbxout_type (type, 0, 0);\n-      dbxout_finish_symbol (decl);\n+  dbxout_symbol_name (decl, suffix, letter);\n+  dbxout_type (type, 0, 0);\n+  dbxout_finish_symbol (decl);\n \n #ifdef DBX_STATIC_BLOCK_END\n-      DBX_STATIC_BLOCK_END (asmfile, current_sym_code);\n+  DBX_STATIC_BLOCK_END (asmfile, current_sym_code);\n #endif\n-      break;\n-    }\n+}\n+\f\n+/* Output the symbol name of DECL for a stabs, with suffix SUFFIX.\n+   Then output LETTER to indicate the kind of location the symbol has.  */\n+\n+static void\n+dbxout_symbol_name (decl, suffix, letter)\n+     tree decl;\n+     char *suffix;\n+     int letter;\n+{\n+  /* One slight hitch: if this is a VAR_DECL which is a static\n+     class member, we must put out the mangled name instead of the\n+     DECL_NAME.  */\n+\n+  char *name;\n+  /* Note also that static member (variable) names DO NOT begin\n+     with underscores in .stabs directives.  */\n+  if (DECL_LANG_SPECIFIC (decl))\n+    name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+  else\n+    name = IDENTIFIER_POINTER (DECL_NAME (decl));\n+  if (name == 0)\n+    name = \"(anon)\";\n+  fprintf (asmfile, \"%s \\\"%s%s:\", ASM_STABS_OP, name,\n+\t   (suffix ? suffix : \"\"));\n+\n+  if (letter) putc (letter, asmfile);\n }\n \n static void\n@@ -2149,26 +2205,12 @@ dbxout_reg_parms (parms)\n \t    && REGNO (DECL_RTL (parms)) >= 0\n \t    && REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER\n \t    && PARM_PASSED_IN_MEMORY (parms))\n-\t  {\n-\t    current_sym_code = N_RSYM;\n-\t    current_sym_value = DBX_REGISTER_NUMBER (REGNO (DECL_RTL (parms)));\n-\t    current_sym_addr = 0;\n-\n-\t    FORCE_TEXT;\n-\t    if (DECL_NAME (parms))\n-\t      {\n-\t\tcurrent_sym_nchars = 2 + IDENTIFIER_LENGTH (DECL_NAME (parms));\n-\t\tfprintf (asmfile, \"%s \\\"%s:r\", ASM_STABS_OP,\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)));\n-\t      }\n-\t    else\n-\t      {\n-\t\tcurrent_sym_nchars = 8;\n-\t\tfprintf (asmfile, \"%s \\\"(anon):r\", ASM_STABS_OP);\n-\t      }\n-\t    dbxout_type (TREE_TYPE (parms), 0, 0);\n-\t    dbxout_finish_symbol (parms);\n-\t  }\n+\t  dbxout_symbol_location (parms, TREE_TYPE (parms),\n+\t\t\t\t  0, DECL_RTL (parms));\n+\telse if (GET_CODE (DECL_RTL (parms)) == CONCAT\n+\t\t && PARM_PASSED_IN_MEMORY (parms))\n+\t  dbxout_symbol_location (parms, TREE_TYPE (parms),\n+\t\t\t\t  0, DECL_RTL (parms));\n \t/* Report parms that live in memory but not where they were passed.  */\n \telse if (GET_CODE (DECL_RTL (parms)) == MEM\n \t\t && GET_CODE (XEXP (DECL_RTL (parms), 0)) == PLUS\n@@ -2188,23 +2230,8 @@ dbxout_reg_parms (parms)\n #endif\n \t    if (INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1)) != offset) {...}\n #endif\n-\t    current_sym_code = N_LSYM;\n-\t    current_sym_value = DEBUGGER_AUTO_OFFSET (XEXP (DECL_RTL (parms), 0));\n-\t    current_sym_addr = 0;\n-\t    FORCE_TEXT;\n-\t    if (DECL_NAME (parms))\n-\t      {\n-\t\tcurrent_sym_nchars = 2 + IDENTIFIER_LENGTH (DECL_NAME (parms));\n-\t\tfprintf (asmfile, \"%s \\\"%s:\", ASM_STABS_OP,\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)));\n-\t      }\n-\t    else\n-\t      {\n-\t\tcurrent_sym_nchars = 8;\n-\t\tfprintf (asmfile, \"%s \\\"(anon):\", ASM_STABS_OP);\n-\t      }\n-\t    dbxout_type (TREE_TYPE (parms), 0, 0);\n-\t    dbxout_finish_symbol (parms);\n+\t    dbxout_symbol_location (parms, TREE_TYPE (parms),\n+\t\t\t\t    0, DECL_RTL (parms));\n \t  }\n #if 0\n \telse if (GET_CODE (DECL_RTL (parms)) == MEM"}]}