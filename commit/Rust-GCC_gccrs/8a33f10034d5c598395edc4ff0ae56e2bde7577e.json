{"sha": "8a33f10034d5c598395edc4ff0ae56e2bde7577e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGEzM2YxMDAzNGQ1YzU5ODM5NWVkYzRmZjBhZTU2ZTJiZGU3NTc3ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-09-04T14:03:31Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-09-04T14:03:31Z"}, "message": "optabs.c (debug_optab_libfunc): Update; make available to gdb.\n\n\t* optabs.c (debug_optab_libfunc): Update; make available to gdb.\n\t(libfunc_entry): New structure.\n\t(libfunc_hash): New hashtable.\n\t(hash_libfunc): New function.\n\t(eq_libfunc): New function.\n\t(convert_optab_libfunc): New function.\n\t(optab_libfunc): New function.\n\t(expand_binop, sign_expand_binop, expand_twoval_binop_libfunc,\n\texpand_unop, prepare_cmp_insn, prepare_float_insn, gen_add2_insn,\n\texpand_float, expand_fix, new_optab, new_convert_optab):\n\t Update for new libfunc API.\n\t(init_libfunc, init_integral_libfuncs,\n\tinit_floating_libfuncs, init_interclass_conv_libfuncs\n\tinit_intraclass_conv_libfuncs): Remove; reorganize all logic to:\n\t(gen_libfunc, gen_int_libfunc, gen_fp_libfunc, gen_int_fp_libfunc,\n\tgen_intv_fp_libfunc, gen_interclass_conv_libfunc,\n\tgen_int_to_fp_conv_libfunc, gen_ufloat_conv_libfunc,\n\tgen_int_to_fp_nondecimal_conv_libfunc, gen_fp_to_int_conv_libfunc,\n\tgen_intraclass_conv_libfunc, gen_trunc_conv_libfunc,\n\tgen_extend_conv_libfunc): New.\n\t(init_one_libfunc): Revamp for hashtables.\n\t(set_conv_libfunc): Likewise.\n\t(init_optabs): Initialize hashtable; use lazy initialization where possible.\n\t* optabs.h (optab_handlers): Move out of GGC.\n\t(optab, convert_optab): Move out of GGC; add lazy gen info.\n\t(code_to_optab, convert_optab_table, optab_table): Move out of GGC.\n\t(optab_libfunc, convert_optab_libfunc): New.\n\t* builtins.c (expand_builtin_powi): Update for new API.\n\t* expr.c (convert_move): Likewise.\n\t* expmed.c (expand_divmod): Likewise.\n\nFrom-SVN: r128083", "tree": {"sha": "bc1e8971e3309ecdbd9ef277a0279ed5b1e1ce55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc1e8971e3309ecdbd9ef277a0279ed5b1e1ce55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a33f10034d5c598395edc4ff0ae56e2bde7577e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a33f10034d5c598395edc4ff0ae56e2bde7577e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a33f10034d5c598395edc4ff0ae56e2bde7577e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a33f10034d5c598395edc4ff0ae56e2bde7577e/comments", "author": null, "committer": null, "parents": [{"sha": "6977374226b230fe6e6d9b5ce2615bea094cb0f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6977374226b230fe6e6d9b5ce2615bea094cb0f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6977374226b230fe6e6d9b5ce2615bea094cb0f1"}], "stats": {"total": 956, "additions": 653, "deletions": 303}, "files": [{"sha": "e37aa54cae3b1d471eadbfd278488a991df59a21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a33f10034d5c598395edc4ff0ae56e2bde7577e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a33f10034d5c598395edc4ff0ae56e2bde7577e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a33f10034d5c598395edc4ff0ae56e2bde7577e", "patch": "@@ -1,3 +1,36 @@\n+2007-09-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* optabs.c (debug_optab_libfunc): Update; make available to gdb.\n+\t(libfunc_entry): New structure.\n+\t(libfunc_hash): New hashtable.\n+\t(hash_libfunc): New function.\n+\t(eq_libfunc): New function.\n+\t(convert_optab_libfunc): New function.\n+\t(optab_libfunc): New function.\n+\t(expand_binop, sign_expand_binop, expand_twoval_binop_libfunc,\n+\texpand_unop, prepare_cmp_insn, prepare_float_insn, gen_add2_insn,\n+\texpand_float, expand_fix, new_optab, new_convert_optab):\n+\t Update for new libfunc API.\n+\t(init_libfunc, init_integral_libfuncs,\n+\tinit_floating_libfuncs, init_interclass_conv_libfuncs\n+\tinit_intraclass_conv_libfuncs): Remove; reorganize all logic to:\n+\t(gen_libfunc, gen_int_libfunc, gen_fp_libfunc, gen_int_fp_libfunc,\n+\tgen_intv_fp_libfunc, gen_interclass_conv_libfunc,\n+\tgen_int_to_fp_conv_libfunc, gen_ufloat_conv_libfunc,\n+\tgen_int_to_fp_nondecimal_conv_libfunc, gen_fp_to_int_conv_libfunc,\n+\tgen_intraclass_conv_libfunc, gen_trunc_conv_libfunc,\n+\tgen_extend_conv_libfunc): New.\n+\t(init_one_libfunc): Revamp for hashtables.\n+\t(set_conv_libfunc): Likewise.\n+\t(init_optabs): Initialize hashtable; use lazy initialization where possible.\n+\t* optabs.h (optab_handlers): Move out of GGC.\n+\t(optab, convert_optab): Move out of GGC; add lazy gen info.\n+\t(code_to_optab, convert_optab_table, optab_table): Move out of GGC.\n+\t(optab_libfunc, convert_optab_libfunc): New.\n+\t* builtins.c (expand_builtin_powi): Update for new API.\n+\t* expr.c (convert_move): Likewise.\n+\t* expmed.c (expand_divmod): Likewise.\n+\n 2007-09-04  Daniel Jacobowitz  <dan@codesourcery.com>\n \n \t* config/rs6000/rs6000.c (rs6000_stack_info): Allocate space for the"}, {"sha": "fc16948bb37f3723519b0cc6f519e3966dabee3c", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a33f10034d5c598395edc4ff0ae56e2bde7577e/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a33f10034d5c598395edc4ff0ae56e2bde7577e/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=8a33f10034d5c598395edc4ff0ae56e2bde7577e", "patch": "@@ -3060,7 +3060,7 @@ expand_builtin_powi (tree exp, rtx target, rtx subtarget)\n   if (GET_MODE (op1) != mode2)\n     op1 = convert_to_mode (mode2, op1, 0);\n \n-  target = emit_library_call_value (optab_handler (powi_optab, mode)->libfunc,\n+  target = emit_library_call_value (optab_libfunc (powi_optab, mode),\n \t\t\t\t    target, LCT_CONST_MAKE_BLOCK, mode, 2,\n \t\t\t\t    op0, mode, op1, mode2);\n "}, {"sha": "09a58dedba20a8625c16051ab49e3f177bc2a197", "filename": "gcc/expmed.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a33f10034d5c598395edc4ff0ae56e2bde7577e/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a33f10034d5c598395edc4ff0ae56e2bde7577e/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=8a33f10034d5c598395edc4ff0ae56e2bde7577e", "patch": "@@ -3886,8 +3886,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n   if (compute_mode == VOIDmode)\n     for (compute_mode = mode; compute_mode != VOIDmode;\n \t compute_mode = GET_MODE_WIDER_MODE (compute_mode))\n-      if (optab_handler (optab1, compute_mode)->libfunc\n-\t  || optab_handler (optab2, compute_mode)->libfunc)\n+      if (optab_libfunc (optab1, compute_mode)\n+\t  || optab_libfunc (optab2, compute_mode))\n \tbreak;\n \n   /* If we still couldn't find a mode, use MODE, but expand_binop will"}, {"sha": "13f447cc8b6aaa27901d29714cef8c304aa0944c", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a33f10034d5c598395edc4ff0ae56e2bde7577e/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a33f10034d5c598395edc4ff0ae56e2bde7577e/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8a33f10034d5c598395edc4ff0ae56e2bde7577e", "patch": "@@ -443,7 +443,7 @@ convert_move (rtx to, rtx from, int unsignedp)\n \t}\n \n       /* Otherwise use a libcall.  */\n-      libcall = convert_optab_handler (tab, to_mode, from_mode)->libfunc;\n+      libcall = convert_optab_libfunc (tab, to_mode, from_mode);\n \n       /* Is this conversion implemented yet?  */\n       gcc_assert (libcall);"}, {"sha": "2501ce6cff7c6809007ccd870fa7796c6b97a642", "filename": "gcc/optabs.c", "status": "modified", "additions": 599, "deletions": 292, "changes": 891, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a33f10034d5c598395edc4ff0ae56e2bde7577e/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a33f10034d5c598395edc4ff0ae56e2bde7577e/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=8a33f10034d5c598395edc4ff0ae56e2bde7577e", "patch": "@@ -103,6 +103,9 @@ static rtx expand_unop_direct (enum machine_mode, optab, rtx, rtx, int);\n    as they are unique to each libcall that is emitted.  */\n static HOST_WIDE_INT libcall_id = 0;\n \n+/* Debug facility for use in GDB.  */\n+void debug_optab_libfuncs (void);\n+\n #ifndef HAVE_conditional_trap\n #define HAVE_conditional_trap 0\n #define gen_conditional_trap(a,b) (gcc_unreachable (), NULL_RTX)\n@@ -114,6 +117,104 @@ static HOST_WIDE_INT libcall_id = 0;\n #else\n #define DECIMAL_PREFIX \"dpd_\"\n #endif\n+\f\n+\n+/* Info about libfunc.  We use same hashtable for normal optabs and conversion\n+   optab.  In the first case mode2 is unused.  */\n+struct libfunc_entry GTY(())\n+{\n+  void * GTY((skip)) optab;\n+  enum machine_mode mode1, mode2;\n+  rtx libfunc;\n+};\n+\n+/* Hash table used to convert declarations into nodes.  */\n+static GTY((param_is (struct libfunc_entry))) htab_t libfunc_hash;\n+\n+/* Used for attribute_hash.  */\n+\n+static hashval_t\n+hash_libfunc (const void *p)\n+{\n+  const struct libfunc_entry *const e = (const struct libfunc_entry *) p;\n+\n+  return (((int) e->mode1 + (int) e->mode2 * NUM_MACHINE_MODES)\n+\t  ^ htab_hash_pointer (e->optab));\n+}\n+\n+/* Used for optab_hash.  */\n+\n+static int\n+eq_libfunc (const void *p, const void *q)\n+{\n+  const struct libfunc_entry *const e1 = (const struct libfunc_entry *) p;\n+  const struct libfunc_entry *const e2 = (const struct libfunc_entry *) q;\n+\n+  return (e1->optab == e2->optab\n+\t  && e1->mode1 == e2->mode1\n+\t  && e1->mode2 == e2->mode2);\n+}\n+\n+/* Return libfunc corresponding operation defined by OPTAB converting\n+   from MODE2 to MODE1.  Trigger lazy initialization if needed, return NULL\n+   if no libfunc is available.  */\n+rtx\n+convert_optab_libfunc (convert_optab optab, enum machine_mode mode1,\n+\t\t       enum machine_mode mode2)\n+{\n+  struct libfunc_entry e;\n+  struct libfunc_entry **slot;\n+\n+  e.optab = optab;\n+  e.mode1 = mode1;\n+  e.mode2 = mode2;\n+  slot = (struct libfunc_entry **) htab_find_slot (libfunc_hash, &e, NO_INSERT);\n+  if (!slot)\n+    {\n+      if (optab->libcall_gen)\n+\t{\n+\t  optab->libcall_gen (optab, optab->libcall_basename, mode1, mode2);\n+          slot = (struct libfunc_entry **) htab_find_slot (libfunc_hash, &e, NO_INSERT);\n+\t  if (slot)\n+\t    return (*slot)->libfunc;\n+\t  else\n+\t    return NULL;\n+\t}\n+      return NULL;\n+    }\n+  return (*slot)->libfunc;\n+}\n+\n+/* Return libfunc corresponding operation defined by OPTAB in MODE.\n+   Trigger lazy initialization if needed, return NULL if no libfunc is\n+   available.  */\n+rtx\n+optab_libfunc (optab optab, enum machine_mode mode)\n+{\n+  struct libfunc_entry e;\n+  struct libfunc_entry **slot;\n+\n+  e.optab = optab;\n+  e.mode1 = mode;\n+  e.mode2 = VOIDmode;\n+  slot = (struct libfunc_entry **) htab_find_slot (libfunc_hash, &e, NO_INSERT);\n+  if (!slot)\n+    {\n+      if (optab->libcall_gen)\n+\t{\n+\t  optab->libcall_gen (optab, optab->libcall_basename,\n+\t\t\t      optab->libcall_suffix, mode);\n+          slot = (struct libfunc_entry **) htab_find_slot (libfunc_hash,\n+\t\t\t\t\t\t\t   &e, NO_INSERT);\n+\t  if (slot)\n+\t    return (*slot)->libfunc;\n+\t  else\n+\t    return NULL;\n+\t}\n+      return NULL;\n+    }\n+  return (*slot)->libfunc;\n+}\n \n \f\n /* Add a REG_EQUAL note to the last insn in INSNS.  TARGET is being set to\n@@ -1419,6 +1520,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n        ? OPTAB_WIDEN : methods);\n   enum mode_class class;\n   enum machine_mode wider_mode;\n+  rtx libfunc;\n   rtx temp;\n   rtx entry_last = get_last_insn ();\n   rtx last;\n@@ -1989,7 +2091,8 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   /* It can't be open-coded in this mode.\n      Use a library call if one is available and caller says that's ok.  */\n \n-  if (optab_handler (binoptab, mode)->libfunc\n+  libfunc = optab_libfunc (binoptab, mode);\n+  if (libfunc\n       && (methods == OPTAB_LIB || methods == OPTAB_LIB_WIDEN))\n     {\n       rtx insns;\n@@ -2013,7 +2116,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n       /* Pass 1 for NO_QUEUE so we don't lose any increments\n \t if the libcall is cse'd or moved.  */\n-      value = emit_library_call_value (optab_handler (binoptab, mode)->libfunc,\n+      value = emit_library_call_value (libfunc,\n \t\t\t\t       NULL_RTX, LCT_CONST, mode, 2,\n \t\t\t\t       op0, mode, op1x, op1_mode);\n \n@@ -2056,7 +2159,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t  if ((optab_handler (binoptab, wider_mode)->insn_code\n \t       != CODE_FOR_nothing)\n \t      || (methods == OPTAB_LIB\n-\t\t  && optab_handler (binoptab, wider_mode)->libfunc))\n+\t\t  && optab_libfunc (binoptab, wider_mode)))\n \t    {\n \t      rtx xop0 = op0, xop1 = op1;\n \t      int no_extend = 0;\n@@ -2131,7 +2234,6 @@ sign_expand_binop (enum machine_mode mode, optab uoptab, optab soptab,\n      hides any signed insn for direct use.  */\n   wide_soptab = *soptab;\n   optab_handler (&wide_soptab, mode)->insn_code = CODE_FOR_nothing;\n-  optab_handler (&wide_soptab, mode)->libfunc = 0;\n \n   temp = expand_binop (mode, &wide_soptab, op0, op1, target,\n \t\t       unsignedp, OPTAB_WIDEN);\n@@ -2387,21 +2489,22 @@ expand_twoval_binop_libfunc (optab binoptab, rtx op0, rtx op1,\n   enum machine_mode libval_mode;\n   rtx libval;\n   rtx insns;\n+  rtx libfunc;\n \n   /* Exactly one of TARG0 or TARG1 should be non-NULL.  */\n   gcc_assert (!targ0 != !targ1);\n \n   mode = GET_MODE (op0);\n-  if (!optab_handler (binoptab, mode)->libfunc)\n+  libfunc = optab_libfunc (binoptab, mode);\n+  if (!libfunc)\n     return false;\n \n   /* The value returned by the library function will have twice as\n      many bits as the nominal MODE.  */\n   libval_mode = smallest_mode_for_size (2 * GET_MODE_BITSIZE (mode),\n \t\t\t\t\tMODE_INT);\n   start_sequence ();\n-  libval = emit_library_call_value (optab_handler (binoptab, mode)->libfunc,\n-\t\t\t\t    NULL_RTX, LCT_CONST,\n+  libval = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n \t\t\t\t    libval_mode, 2,\n \t\t\t\t    op0, mode,\n \t\t\t\t    op1, mode);\n@@ -2967,6 +3070,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n   enum mode_class class = GET_MODE_CLASS (mode);\n   enum machine_mode wider_mode;\n   rtx temp;\n+  rtx libfunc;\n \n   temp = expand_unop_direct (mode, unoptab, op0, target, unsignedp);\n   if (temp)\n@@ -3135,7 +3239,8 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \n  try_libcall:\n   /* Now try a library call in this mode.  */\n-  if (optab_handler (unoptab, mode)->libfunc)\n+  libfunc = optab_libfunc (unoptab, mode);\n+  if (libfunc)\n     {\n       rtx insns;\n       rtx value;\n@@ -3152,8 +3257,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \n       /* Pass 1 for NO_QUEUE so we don't lose any increments\n \t if the libcall is cse'd or moved.  */\n-      value = emit_library_call_value (optab_handler (unoptab, mode)->libfunc,\n-\t\t\t\t       NULL_RTX, LCT_CONST, outmode,\n+      value = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST, outmode,\n \t\t\t\t       1, op0, mode);\n       insns = get_insns ();\n       end_sequence ();\n@@ -3175,7 +3279,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t{\n \t  if ((optab_handler (unoptab, wider_mode)->insn_code\n \t       != CODE_FOR_nothing)\n-\t      || optab_handler (unoptab, wider_mode)->libfunc)\n+\t      || optab_libfunc (unoptab, wider_mode))\n \t    {\n \t      rtx xop0 = op0;\n \t      rtx last = get_last_insn ();\n@@ -4058,6 +4162,7 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n   enum machine_mode mode = *pmode;\n   rtx x = *px, y = *py;\n   int unsignedp = *punsignedp;\n+  rtx libfunc;\n \n   /* If we are inside an appropriately-short loop and we are optimizing,\n      force expensive constants into a register.  */\n@@ -4162,15 +4267,20 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n \n   /* Handle a lib call just for the mode we are using.  */\n \n-  if (optab_handler (cmp_optab, mode)->libfunc && !SCALAR_FLOAT_MODE_P (mode))\n+  libfunc = optab_libfunc (cmp_optab, mode);\n+  if (libfunc && !SCALAR_FLOAT_MODE_P (mode))\n     {\n-      rtx libfunc = optab_handler (cmp_optab, mode)->libfunc;\n       rtx result;\n+      rtx ulibfunc;\n \n       /* If we want unsigned, and this mode has a distinct unsigned\n \t comparison routine, use that.  */\n-      if (unsignedp && optab_handler (ucmp_optab, mode)->libfunc)\n-\tlibfunc = optab_handler (ucmp_optab, mode)->libfunc;\n+      if (unsignedp)\n+\t{\n+\t  ulibfunc = optab_libfunc (ucmp_optab, mode);\n+\t}\n+      if (unsignedp && ulibfunc)\n+\tlibfunc = ulibfunc;\n \n       result = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST_MAKE_BLOCK,\n \t\t\t\t\ttargetm.libgcc_cmp_return_mode (),\n@@ -4375,18 +4485,18 @@ prepare_float_lib_cmp (rtx *px, rtx *py, enum rtx_code *pcomparison,\n        mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     {\n-      if ((libfunc = optab_handler (code_to_optab[comparison], mode)->libfunc))\n+      if ((libfunc = optab_libfunc (code_to_optab[comparison], mode)))\n \tbreak;\n \n-      if ((libfunc = optab_handler (code_to_optab[swapped], mode)->libfunc))\n+      if ((libfunc = optab_libfunc (code_to_optab[swapped] , mode)))\n \t{\n \t  rtx tmp;\n \t  tmp = x; x = y; y = tmp;\n \t  comparison = swapped;\n \t  break;\n \t}\n \n-      if ((libfunc = optab_handler (code_to_optab[reversed], mode)->libfunc)\n+      if ((libfunc = optab_libfunc (code_to_optab[reversed], mode))\n \t  && FLOAT_LIB_COMPARE_RETURNS_BOOL (mode, reversed))\n \t{\n \t  comparison = reversed;\n@@ -4755,6 +4865,7 @@ gen_add2_insn (rtx x, rtx y)\n \n /* Generate and return an insn body to add r1 and c,\n    storing the result in r0.  */\n+\n rtx\n gen_add3_insn (rtx r0, rtx r1, rtx c)\n {\n@@ -4814,6 +4925,7 @@ gen_sub2_insn (rtx x, rtx y)\n \n /* Generate and return an insn body to subtract r1 and c,\n    storing the result in r0.  */\n+\n rtx\n gen_sub3_insn (rtx r0, rtx r1, rtx c)\n {\n@@ -5124,8 +5236,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n       if (GET_MODE_SIZE (GET_MODE (from)) < GET_MODE_SIZE (SImode))\n \tfrom = convert_to_mode (SImode, from, unsignedp);\n \n-      libfunc = convert_optab_handler (tab, GET_MODE (to),\n-\t\t\t\t       GET_MODE (from))->libfunc;\n+      libfunc = convert_optab_libfunc (tab, GET_MODE (to), GET_MODE (from));\n       gcc_assert (libfunc);\n \n       start_sequence ();\n@@ -5305,8 +5416,7 @@ expand_fix (rtx to, rtx from, int unsignedp)\n       rtx libfunc;\n \n       convert_optab tab = unsignedp ? ufix_optab : sfix_optab;\n-      libfunc = convert_optab_handler (tab, GET_MODE (to),\n-\t\t\t\t       GET_MODE (from))->libfunc;\n+      libfunc = convert_optab_libfunc (tab, GET_MODE (to), GET_MODE (from));\n       gcc_assert (libfunc);\n \n       start_sequence ();\n@@ -5386,12 +5496,10 @@ static optab\n new_optab (void)\n {\n   int i;\n-  optab op = ggc_alloc (sizeof (struct optab));\n+  optab op = xcalloc (sizeof (struct optab), 1);\n+\n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n-    {\n-      optab_handler (op, i)->insn_code = CODE_FOR_nothing;\n-      optab_handler (op, i)->libfunc = 0;\n-    }\n+    optab_handler (op, i)->insn_code = CODE_FOR_nothing;\n \n   return op;\n }\n@@ -5400,13 +5508,12 @@ static convert_optab\n new_convert_optab (void)\n {\n   int i, j;\n-  convert_optab op = ggc_alloc (sizeof (struct convert_optab));\n+  convert_optab op = xcalloc (sizeof (struct convert_optab), 1);\n+\n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n     for (j = 0; j < NUM_MACHINE_MODES; j++)\n-      {\n-\tconvert_optab_handler (op, i, j)->insn_code = CODE_FOR_nothing;\n-\tconvert_optab_handler (op, i, j)->libfunc = 0;\n-      }\n+      convert_optab_handler (op, i, j)->insn_code = CODE_FOR_nothing;\n+\n   return op;\n }\n \n@@ -5448,98 +5555,122 @@ init_convert_optab (enum rtx_code code)\n    usually one of the characters '2', '3', or '4').\n \n    OPTABLE is the table in which libfunc fields are to be initialized.\n-   FIRST_MODE is the first machine mode index in the given optab to\n-     initialize.\n-   LAST_MODE is the last machine mode index in the given optab to\n-     initialize.\n    OPNAME is the generic (string) name of the operation.\n    SUFFIX is the character which specifies the number of operands for\n      the given generic operation.\n+   MODE is the mode to generate for.\n */\n \n static void\n-init_libfuncs (optab optable, int first_mode, int last_mode,\n-\t       const char *opname, int suffix)\n+gen_libfunc (optab optable, const char *opname, int suffix, enum machine_mode mode)\n {\n-  int mode;\n   unsigned opname_len = strlen (opname);\n+  const char *mname = GET_MODE_NAME (mode);\n+  unsigned mname_len = strlen (mname);\n+  char *libfunc_name = alloca (2 + opname_len + mname_len + 1 + 1);\n+  char *p;\n+  const char *q;\n \n-  for (mode = first_mode; (int) mode <= (int) last_mode;\n-       mode = (enum machine_mode) ((int) mode + 1))\n-    {\n-      const char *mname = GET_MODE_NAME (mode);\n-      unsigned mname_len = strlen (mname);\n-      char *libfunc_name = alloca (2 + opname_len + mname_len + 1 + 1);\n-      char *p;\n-      const char *q;\n-\n-      p = libfunc_name;\n-      *p++ = '_';\n-      *p++ = '_';\n-      for (q = opname; *q; )\n-\t*p++ = *q++;\n-      for (q = mname; *q; q++)\n-\t*p++ = TOLOWER (*q);\n-      *p++ = suffix;\n-      *p = '\\0';\n-\n-      optab_handler (optable, mode)->libfunc\n-\t= init_one_libfunc (ggc_alloc_string (libfunc_name, p - libfunc_name));\n-    }\n+  p = libfunc_name;\n+  *p++ = '_';\n+  *p++ = '_';\n+  for (q = opname; *q; )\n+    *p++ = *q++;\n+  for (q = mname; *q; q++)\n+    *p++ = TOLOWER (*q);\n+  *p++ = suffix;\n+  *p = '\\0';\n+\n+  set_optab_libfunc (optable, mode,\n+\t\t     ggc_alloc_string (libfunc_name, p - libfunc_name));\n }\n \n-/* Initialize the libfunc fields of an entire group of entries in some\n-   optab which correspond to all integer mode operations.  The parameters\n-   have the same meaning as similarly named ones for the `init_libfuncs'\n-   routine.  (See above).  */\n+/* Like gen_libfunc, but verify that integer operation is involved.  */\n \n static void\n-init_integral_libfuncs (optab optable, const char *opname, int suffix)\n+gen_int_libfunc (optab optable, const char *opname, char suffix,\n+\t\t enum machine_mode mode)\n {\n-  int maxsize = 2*BITS_PER_WORD;\n+  int maxsize = 2 * BITS_PER_WORD;\n+\n+  if (GET_MODE_CLASS (mode) != MODE_INT)\n+    return;\n   if (maxsize < LONG_LONG_TYPE_SIZE)\n     maxsize = LONG_LONG_TYPE_SIZE;\n-  init_libfuncs (optable, word_mode,\n-\t\t mode_for_size (maxsize, MODE_INT, 0),\n-\t\t opname, suffix);\n+  if (GET_MODE_CLASS (mode) != MODE_INT\n+      || mode < word_mode || GET_MODE_BITSIZE (mode) > maxsize)\n+    return;\n+  gen_libfunc (optable, opname, suffix, mode);\n }\n \n-/* Initialize the libfunc fields of an entire group of entries in some\n-   optab which correspond to all real mode operations.  The parameters\n-   have the same meaning as similarly named ones for the `init_libfuncs'\n-   routine.  (See above).  */\n+/* Like gen_libfunc, but verify that FP and set decimal prefix if needed.  */\n+\n+static void\n+gen_fp_libfunc (optab optable, const char *opname, char suffix,\n+\t\tenum machine_mode mode)\n+{\n+  char *dec_opname;\n+\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    gen_libfunc (optable, opname, suffix, mode);\n+  if (DECIMAL_FLOAT_MODE_P (mode))\n+    {\n+      dec_opname = alloca (sizeof (DECIMAL_PREFIX) + strlen (opname));\n+      /* For BID support, change the name to have either a bid_ or dpd_ prefix\n+\t depending on the low level floating format used.  */\n+      memcpy (dec_opname, DECIMAL_PREFIX, sizeof (DECIMAL_PREFIX) - 1);\n+      strcpy (dec_opname + sizeof (DECIMAL_PREFIX) - 1, opname);\n+      gen_libfunc (optable, dec_opname, suffix, mode);\n+    }\n+}\n+\n+/* Like gen_libfunc, but verify that FP or INT operation is involved.  */\n \n static void\n-init_floating_libfuncs (optab optable, const char *opname, int suffix)\n+gen_int_fp_libfunc (optab optable, const char *name, char suffix,\n+\t\t    enum machine_mode mode)\n {\n-  char *dec_opname = alloca (sizeof (DECIMAL_PREFIX) + strlen (opname));\n+  if (DECIMAL_FLOAT_MODE_P (mode) || GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    gen_fp_libfunc (optable, name, suffix, mode);\n+  if (INTEGRAL_MODE_P (mode))\n+    gen_int_libfunc (optable, name, suffix, mode);\n+}\n \n-  /* For BID support, change the name to have either a bid_ or dpd_ prefix\n-     depending on the low level floating format used.  */\n-  memcpy (dec_opname, DECIMAL_PREFIX, sizeof (DECIMAL_PREFIX) - 1);\n-  strcpy (dec_opname + sizeof (DECIMAL_PREFIX) - 1, opname);\n+/* Like gen_libfunc, but verify that FP or INT operation is involved\n+   and add 'v' suffix for integer operation.  */\n \n-  init_libfuncs (optable, MIN_MODE_FLOAT, MAX_MODE_FLOAT, opname, suffix);\n-  init_libfuncs (optable, MIN_MODE_DECIMAL_FLOAT, MAX_MODE_DECIMAL_FLOAT,\n-\t\t dec_opname, suffix);\n+static void\n+gen_intv_fp_libfunc (optab optable, const char *name, char suffix,\n+\t\t     enum machine_mode mode)\n+{\n+  if (DECIMAL_FLOAT_MODE_P (mode) || GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    gen_fp_libfunc (optable, name, suffix, mode);\n+  if (GET_MODE_CLASS (mode) == MODE_INT)\n+    {\n+      int len = strlen (name);\n+      char *v_name = alloca (len + 2);\n+      strcpy (v_name, name);\n+      v_name[len] = 'v';\n+      v_name[len + 1] = 0;\n+      gen_int_libfunc (optable, v_name, suffix, mode);\n+    }\n }\n \n /* Initialize the libfunc fields of an entire group of entries of an\n    inter-mode-class conversion optab.  The string formation rules are\n    similar to the ones for init_libfuncs, above, but instead of having\n    a mode name and an operand count these functions have two mode names\n    and no operand count.  */\n+\n static void\n-init_interclass_conv_libfuncs (convert_optab tab, const char *opname,\n-\t\t\t       enum mode_class from_class,\n-\t\t\t       enum mode_class to_class)\n+gen_interclass_conv_libfunc (convert_optab tab,\n+\t\t\t     const char *opname,\n+\t\t\t     enum machine_mode tmode,\n+\t\t\t     enum machine_mode fmode)\n {\n-  enum machine_mode first_from_mode = GET_CLASS_NARROWEST_MODE (from_class);\n-  enum machine_mode first_to_mode = GET_CLASS_NARROWEST_MODE (to_class);\n   size_t opname_len = strlen (opname);\n-  size_t max_mname_len = 0;\n+  size_t mname_len = 0;\n \n-  enum machine_mode fmode, tmode;\n   const char *fname, *tname;\n   const char *q;\n   char *libfunc_name, *suffix;\n@@ -5550,77 +5681,122 @@ init_interclass_conv_libfuncs (convert_optab tab, const char *opname,\n      depends on which underlying decimal floating point format is used.  */\n   const size_t dec_len = sizeof (DECIMAL_PREFIX) - 1;\n \n-  for (fmode = first_from_mode;\n-       fmode != VOIDmode;\n-       fmode = GET_MODE_WIDER_MODE (fmode))\n-    max_mname_len = MAX (max_mname_len, strlen (GET_MODE_NAME (fmode)));\n-\n-  for (tmode = first_to_mode;\n-       tmode != VOIDmode;\n-       tmode = GET_MODE_WIDER_MODE (tmode))\n-    max_mname_len = MAX (max_mname_len, strlen (GET_MODE_NAME (tmode)));\n+  mname_len = strlen (GET_MODE_NAME (tmode)) + strlen (GET_MODE_NAME (fmode));\n \n-  nondec_name = alloca (2 + opname_len + 2*max_mname_len + 1 + 1);\n+  nondec_name = alloca (2 + opname_len + mname_len + 1 + 1);\n   nondec_name[0] = '_';\n   nondec_name[1] = '_';\n   memcpy (&nondec_name[2], opname, opname_len);\n   nondec_suffix = nondec_name + opname_len + 2;\n \n-  dec_name = alloca (2 + dec_len + opname_len + 2*max_mname_len + 1 + 1);\n+  dec_name = alloca (2 + dec_len + opname_len + mname_len + 1 + 1);\n   dec_name[0] = '_';\n   dec_name[1] = '_';\n   memcpy (&dec_name[2], DECIMAL_PREFIX, dec_len);\n   memcpy (&dec_name[2+dec_len], opname, opname_len);\n   dec_suffix = dec_name + dec_len + opname_len + 2;\n \n-  for (fmode = first_from_mode; fmode != VOIDmode;\n-       fmode = GET_MODE_WIDER_MODE (fmode))\n-    for (tmode = first_to_mode; tmode != VOIDmode;\n-\t tmode = GET_MODE_WIDER_MODE (tmode))\n-      {\n-\tfname = GET_MODE_NAME (fmode);\n-\ttname = GET_MODE_NAME (tmode);\n+  fname = GET_MODE_NAME (fmode);\n+  tname = GET_MODE_NAME (tmode);\n \n-\tif (DECIMAL_FLOAT_MODE_P(fmode) || DECIMAL_FLOAT_MODE_P(tmode))\n-\t  {\n-\t    libfunc_name = dec_name;\n-\t    suffix = dec_suffix;\n-\t  }\n-\telse\n-\t  {\n-\t    libfunc_name = nondec_name;\n-\t    suffix = nondec_suffix;\n-\t  }\n+  if (DECIMAL_FLOAT_MODE_P(fmode) || DECIMAL_FLOAT_MODE_P(tmode))\n+    {\n+      libfunc_name = dec_name;\n+      suffix = dec_suffix;\n+    }\n+  else\n+    {\n+      libfunc_name = nondec_name;\n+      suffix = nondec_suffix;\n+    }\n \n-\tp = suffix;\n-\tfor (q = fname; *q; p++, q++)\n-\t  *p = TOLOWER (*q);\n-\tfor (q = tname; *q; p++, q++)\n-\t  *p = TOLOWER (*q);\n+  p = suffix;\n+  for (q = fname; *q; p++, q++)\n+    *p = TOLOWER (*q);\n+  for (q = tname; *q; p++, q++)\n+    *p = TOLOWER (*q);\n \n-\t*p = '\\0';\n+  *p = '\\0';\n \n-\tconvert_optab_handler (tab, tmode, fmode)->libfunc\n-\t  = init_one_libfunc (ggc_alloc_string (libfunc_name,\n-\t\t\t\t\t\tp - libfunc_name));\n-      }\n+  set_conv_libfunc (tab, tmode, fmode,\n+\t\t    ggc_alloc_string (libfunc_name, p - libfunc_name));\n }\n \n-/* Initialize the libfunc fields of an entire group of entries of an\n-   intra-mode-class conversion optab.  The string formation rules are\n-   similar to the ones for init_libfunc, above.  WIDENING says whether\n-   the optab goes from narrow to wide modes or vice versa.  These functions\n-   have two mode names _and_ an operand count.  */\n+/* Same as gen_interclass_conv_libfunc but verify that we are producing\n+   int->fp conversion.  */\n+\n+static void\n+gen_int_to_fp_conv_libfunc (convert_optab tab,\n+\t\t\t    const char *opname,\n+\t\t\t    enum machine_mode tmode,\n+\t\t\t    enum machine_mode fmode)\n+{\n+  if (GET_MODE_CLASS (fmode) != MODE_INT)\n+    return;\n+  if (GET_MODE_CLASS (tmode) != MODE_FLOAT && !DECIMAL_FLOAT_MODE_P (tmode))\n+    return;\n+  gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n+}\n+\n+/* ufloat_optab is special by using floatun for FP and floatuns decimal fp\n+   naming scheme.  */\n+\n+static void\n+gen_ufloat_conv_libfunc (convert_optab tab,\n+\t\t\t const char *opname ATTRIBUTE_UNUSED,\n+\t\t\t enum machine_mode tmode,\n+\t\t\t enum machine_mode fmode)\n+{\n+  if (DECIMAL_FLOAT_MODE_P (tmode))\n+    gen_int_to_fp_conv_libfunc (tab, \"floatuns\", tmode, fmode);\n+  else\n+    gen_int_to_fp_conv_libfunc (tab, \"floatun\", tmode, fmode);\n+}\n+\n+/* Same as gen_interclass_conv_libfunc but verify that we are producing\n+   fp->int conversion.  */\n+\n+static void\n+gen_int_to_fp_nondecimal_conv_libfunc (convert_optab tab,\n+\t\t\t               const char *opname,\n+\t\t\t               enum machine_mode tmode,\n+\t\t\t               enum machine_mode fmode)\n+{\n+  if (GET_MODE_CLASS (fmode) != MODE_INT)\n+    return;\n+  if (GET_MODE_CLASS (tmode) != MODE_FLOAT)\n+    return;\n+  gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n+}\n+\n+/* Same as gen_interclass_conv_libfunc but verify that we are producing\n+   fp->int conversion with no decimal floating point involved.  */\n+\n static void\n-init_intraclass_conv_libfuncs (convert_optab tab, const char *opname,\n-\t\t\t       enum mode_class class, bool widening)\n+gen_fp_to_int_conv_libfunc (convert_optab tab,\n+\t\t\t    const char *opname,\n+\t\t\t    enum machine_mode tmode,\n+\t\t\t    enum machine_mode fmode)\n+{\n+  if (GET_MODE_CLASS (fmode) != MODE_FLOAT && !DECIMAL_FLOAT_MODE_P (fmode))\n+    return;\n+  if (GET_MODE_CLASS (tmode) != MODE_INT)\n+    return;\n+  gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n+}\n+\n+/* Initialize the libfunc fiels of an of an intra-mode-class conversion optab.\n+   The string formation rules are\n+   similar to the ones for init_libfunc, above.  */\n+\n+static void\n+gen_intraclass_conv_libfunc (convert_optab tab, const char *opname,\n+\t\t\t     enum machine_mode tmode, enum machine_mode fmode)\n {\n-  enum machine_mode first_mode = GET_CLASS_NARROWEST_MODE (class);\n   size_t opname_len = strlen (opname);\n-  size_t max_mname_len = 0;\n+  size_t mname_len = 0;\n \n-  enum machine_mode nmode, wmode;\n-  const char *nname, *wname;\n+  const char *fname, *tname;\n   const char *q;\n   char *nondec_name, *dec_name, *nondec_suffix, *dec_suffix;\n   char *libfunc_name, *suffix;\n@@ -5630,58 +5806,105 @@ init_intraclass_conv_libfuncs (convert_optab tab, const char *opname,\n      depends on which underlying decimal floating point format is used.  */\n   const size_t dec_len = sizeof (DECIMAL_PREFIX) - 1;\n \n-  for (nmode = first_mode; nmode != VOIDmode;\n-       nmode = GET_MODE_WIDER_MODE (nmode))\n-    max_mname_len = MAX (max_mname_len, strlen (GET_MODE_NAME (nmode)));\n+  mname_len = strlen (GET_MODE_NAME (tmode)) + strlen (GET_MODE_NAME (fmode));\n \n-  nondec_name = alloca (2 + opname_len + 2*max_mname_len + 1 + 1);\n+  nondec_name = alloca (2 + opname_len + mname_len + 1 + 1);\n   nondec_name[0] = '_';\n   nondec_name[1] = '_';\n   memcpy (&nondec_name[2], opname, opname_len);\n   nondec_suffix = nondec_name + opname_len + 2;\n \n-  dec_name = alloca (2 + dec_len + opname_len + 2*max_mname_len + 1 + 1);\n+  dec_name = alloca (2 + dec_len + opname_len + mname_len + 1 + 1);\n   dec_name[0] = '_';\n   dec_name[1] = '_';\n   memcpy (&dec_name[2], DECIMAL_PREFIX, dec_len);\n   memcpy (&dec_name[2 + dec_len], opname, opname_len);\n   dec_suffix = dec_name + dec_len + opname_len + 2;\n \n-  for (nmode = first_mode; nmode != VOIDmode;\n-       nmode = GET_MODE_WIDER_MODE (nmode))\n-    for (wmode = GET_MODE_WIDER_MODE (nmode); wmode != VOIDmode;\n-\t wmode = GET_MODE_WIDER_MODE (wmode))\n-      {\n-\tnname = GET_MODE_NAME (nmode);\n-\twname = GET_MODE_NAME (wmode);\n+  fname = GET_MODE_NAME (fmode);\n+  tname = GET_MODE_NAME (tmode);\n \n-\tif (DECIMAL_FLOAT_MODE_P(nmode) || DECIMAL_FLOAT_MODE_P(wmode))\n-\t  {\n-\t    libfunc_name = dec_name;\n-\t    suffix = dec_suffix;\n-\t  }\n-\telse\n-\t  {\n-\t    libfunc_name = nondec_name;\n-\t    suffix = nondec_suffix;\n-\t  }\n+  if (DECIMAL_FLOAT_MODE_P(fmode) || DECIMAL_FLOAT_MODE_P(tmode))\n+    {\n+      libfunc_name = dec_name;\n+      suffix = dec_suffix;\n+    }\n+  else\n+    {\n+      libfunc_name = nondec_name;\n+      suffix = nondec_suffix;\n+    }\n \n-\tp = suffix;\n-\tfor (q = widening ? nname : wname; *q; p++, q++)\n-\t  *p = TOLOWER (*q);\n-\tfor (q = widening ? wname : nname; *q; p++, q++)\n-\t  *p = TOLOWER (*q);\n+  p = suffix;\n+  for (q = fname; *q; p++, q++)\n+    *p = TOLOWER (*q);\n+  for (q = tname; *q; p++, q++)\n+    *p = TOLOWER (*q);\n \n-\t*p++ = '2';\n-\t*p = '\\0';\n+  *p++ = '2';\n+  *p = '\\0';\n \n-\tconvert_optab_handler(tab, widening ? wmode : nmode,\n-\t             \t      widening ? nmode : wmode)->libfunc\n-\t  = init_one_libfunc (ggc_alloc_string (libfunc_name,\n-\t\t\t\t\t\tp - libfunc_name));\n-      }\n+  set_conv_libfunc (tab, tmode, fmode,\n+\t\t    ggc_alloc_string (libfunc_name, p - libfunc_name));\n }\n \n+/* Pick proper libcall for trunc_optab.  We need to chose if we do\n+   truncation or extension and interclass or intraclass.  */\n+\n+static void\n+gen_trunc_conv_libfunc (convert_optab tab,\n+\t\t\t const char *opname,\n+\t\t\t enum machine_mode tmode,\n+\t\t\t enum machine_mode fmode)\n+{\n+  if (GET_MODE_CLASS (tmode) != MODE_FLOAT && !DECIMAL_FLOAT_MODE_P (tmode))\n+    return;\n+  if (GET_MODE_CLASS (fmode) != MODE_FLOAT && !DECIMAL_FLOAT_MODE_P (fmode))\n+    return;\n+  if (tmode == fmode)\n+    return;\n+\n+  if ((GET_MODE_CLASS (tmode) == MODE_FLOAT && DECIMAL_FLOAT_MODE_P (fmode))\n+      || (GET_MODE_CLASS (fmode) == MODE_FLOAT && DECIMAL_FLOAT_MODE_P (tmode)))\n+     gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n+  \n+  if (GET_MODE_PRECISION (fmode) <= GET_MODE_PRECISION (tmode))\n+    return;\n+\n+  if ((GET_MODE_CLASS (tmode) == MODE_FLOAT\n+       && GET_MODE_CLASS (fmode) == MODE_FLOAT)\n+      || (DECIMAL_FLOAT_MODE_P (fmode) && DECIMAL_FLOAT_MODE_P (tmode)))\n+    gen_intraclass_conv_libfunc (tab, opname, tmode, fmode);\n+}\n+\n+/* Pick proper libcall for extend_optab.  We need to chose if we do\n+   truncation or extension and interclass or intraclass.  */\n+\n+static void\n+gen_extend_conv_libfunc (convert_optab tab,\n+\t\t\t const char *opname ATTRIBUTE_UNUSED,\n+\t\t\t enum machine_mode tmode,\n+\t\t\t enum machine_mode fmode)\n+{\n+  if (GET_MODE_CLASS (tmode) != MODE_FLOAT && !DECIMAL_FLOAT_MODE_P (tmode))\n+    return;\n+  if (GET_MODE_CLASS (fmode) != MODE_FLOAT && !DECIMAL_FLOAT_MODE_P (fmode))\n+    return;\n+  if (tmode == fmode)\n+    return;\n+\n+  if ((GET_MODE_CLASS (tmode) == MODE_FLOAT && DECIMAL_FLOAT_MODE_P (fmode))\n+      || (GET_MODE_CLASS (fmode) == MODE_FLOAT && DECIMAL_FLOAT_MODE_P (tmode)))\n+     gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n+  \n+  if (GET_MODE_PRECISION (fmode) > GET_MODE_PRECISION (tmode))\n+    return;\n+\n+  if ((GET_MODE_CLASS (tmode) == MODE_FLOAT\n+       && GET_MODE_CLASS (fmode) == MODE_FLOAT)\n+      || (DECIMAL_FLOAT_MODE_P (fmode) && DECIMAL_FLOAT_MODE_P (tmode)))\n+    gen_intraclass_conv_libfunc (tab, opname, tmode, fmode);\n+}\n \n rtx\n init_one_libfunc (const char *name)\n@@ -5712,10 +5935,24 @@ init_one_libfunc (const char *name)\n void\n set_optab_libfunc (optab optable, enum machine_mode mode, const char *name)\n {\n+  rtx val;\n+  struct libfunc_entry e;\n+  struct libfunc_entry **slot;\n+  e.optab = optable;\n+  e.mode1 = mode;\n+  e.mode2 = VOIDmode;\n+\n   if (name)\n-    optab_handler (optable, mode)->libfunc = init_one_libfunc (name);\n+    val = init_one_libfunc (name);\n   else\n-    optab_handler (optable, mode)->libfunc = 0;\n+    val = 0;\n+  slot = (struct libfunc_entry **) htab_find_slot (libfunc_hash, &e, INSERT);\n+  if (*slot == NULL)\n+    *slot = ggc_alloc (sizeof (struct libfunc_entry));\n+  (*slot)->optab = optable;\n+  (*slot)->mode1 = mode;\n+  (*slot)->mode2 = VOIDmode;\n+  (*slot)->libfunc = val;\n }\n \n /* Call this to reset the function entry for one conversion optab\n@@ -5725,11 +5962,24 @@ void\n set_conv_libfunc (convert_optab optable, enum machine_mode tmode,\n \t\t  enum machine_mode fmode, const char *name)\n {\n+  rtx val;\n+  struct libfunc_entry e;\n+  struct libfunc_entry **slot;\n+  e.optab = optable;\n+  e.mode1 = tmode;\n+  e.mode2 = fmode;\n+\n   if (name)\n-    convert_optab_handler (optable, tmode, fmode)->libfunc\n-      = init_one_libfunc (name);\n+    val = init_one_libfunc (name);\n   else\n-    convert_optab_handler (optable, tmode, fmode)->libfunc = 0;\n+    val = 0;\n+  slot = (struct libfunc_entry **) htab_find_slot (libfunc_hash, &e, INSERT);\n+  if (*slot == NULL)\n+    *slot = ggc_alloc (sizeof (struct libfunc_entry));\n+  (*slot)->optab = optable;\n+  (*slot)->mode1 = tmode;\n+  (*slot)->mode2 = fmode;\n+  (*slot)->libfunc = val;\n }\n \n /* Call this to initialize the contents of the optabs\n@@ -5741,6 +5991,7 @@ init_optabs (void)\n   unsigned int i;\n   enum machine_mode int_mode;\n \n+  libfunc_hash = htab_create_ggc (10, hash_libfunc, eq_libfunc, NULL);\n   /* Start by initializing all tables to contain CODE_FOR_nothing.  */\n \n   for (i = 0; i < NUM_RTX_CODE; i++)\n@@ -5960,110 +6211,171 @@ init_optabs (void)\n   /* Fill in the optabs with the insns we support.  */\n   init_all_optabs ();\n \n-  /* The ffs function operates on `int'.  Fall back on it if we do not\n-     have a libgcc2 function for that width.  */\n-  int_mode = mode_for_size (INT_TYPE_SIZE, MODE_INT, 0);\n-  optab_handler (ffs_optab, int_mode)->libfunc = init_one_libfunc (\"ffs\");\n-\n   /* Initialize the optabs with the names of the library functions.  */\n-  init_integral_libfuncs (add_optab, \"add\", '3');\n-  init_floating_libfuncs (add_optab, \"add\", '3');\n-  init_integral_libfuncs (addv_optab, \"addv\", '3');\n-  init_floating_libfuncs (addv_optab, \"add\", '3');\n-  init_integral_libfuncs (sub_optab, \"sub\", '3');\n-  init_floating_libfuncs (sub_optab, \"sub\", '3');\n-  init_integral_libfuncs (subv_optab, \"subv\", '3');\n-  init_floating_libfuncs (subv_optab, \"sub\", '3');\n-  init_integral_libfuncs (smul_optab, \"mul\", '3');\n-  init_floating_libfuncs (smul_optab, \"mul\", '3');\n-  init_integral_libfuncs (smulv_optab, \"mulv\", '3');\n-  init_floating_libfuncs (smulv_optab, \"mul\", '3');\n-  init_integral_libfuncs (sdiv_optab, \"div\", '3');\n-  init_floating_libfuncs (sdiv_optab, \"div\", '3');\n-  init_integral_libfuncs (sdivv_optab, \"divv\", '3');\n-  init_integral_libfuncs (udiv_optab, \"udiv\", '3');\n-  init_integral_libfuncs (sdivmod_optab, \"divmod\", '4');\n-  init_integral_libfuncs (udivmod_optab, \"udivmod\", '4');\n-  init_integral_libfuncs (smod_optab, \"mod\", '3');\n-  init_integral_libfuncs (umod_optab, \"umod\", '3');\n-  init_floating_libfuncs (ftrunc_optab, \"ftrunc\", '2');\n-  init_integral_libfuncs (and_optab, \"and\", '3');\n-  init_integral_libfuncs (ior_optab, \"ior\", '3');\n-  init_integral_libfuncs (xor_optab, \"xor\", '3');\n-  init_integral_libfuncs (ashl_optab, \"ashl\", '3');\n-  init_integral_libfuncs (ashr_optab, \"ashr\", '3');\n-  init_integral_libfuncs (lshr_optab, \"lshr\", '3');\n-  init_integral_libfuncs (smin_optab, \"min\", '3');\n-  init_floating_libfuncs (smin_optab, \"min\", '3');\n-  init_integral_libfuncs (smax_optab, \"max\", '3');\n-  init_floating_libfuncs (smax_optab, \"max\", '3');\n-  init_integral_libfuncs (umin_optab, \"umin\", '3');\n-  init_integral_libfuncs (umax_optab, \"umax\", '3');\n-  init_integral_libfuncs (neg_optab, \"neg\", '2');\n-  init_floating_libfuncs (neg_optab, \"neg\", '2');\n-  init_integral_libfuncs (negv_optab, \"negv\", '2');\n-  init_floating_libfuncs (negv_optab, \"neg\", '2');\n-  init_integral_libfuncs (one_cmpl_optab, \"one_cmpl\", '2');\n-  init_integral_libfuncs (ffs_optab, \"ffs\", '2');\n-  init_integral_libfuncs (clz_optab, \"clz\", '2');\n-  init_integral_libfuncs (ctz_optab, \"ctz\", '2');\n-  init_integral_libfuncs (popcount_optab, \"popcount\", '2');\n-  init_integral_libfuncs (parity_optab, \"parity\", '2');\n+  add_optab->libcall_basename = \"add\";\n+  add_optab->libcall_suffix = '3';\n+  add_optab->libcall_gen = gen_int_fp_libfunc;\n+  addv_optab->libcall_basename = \"add\";\n+  addv_optab->libcall_suffix = '3';\n+  addv_optab->libcall_gen = gen_intv_fp_libfunc;\n+  sub_optab->libcall_basename = \"sub\";\n+  sub_optab->libcall_suffix = '3';\n+  sub_optab->libcall_gen = gen_int_fp_libfunc;\n+  subv_optab->libcall_basename = \"sub\";\n+  subv_optab->libcall_suffix = '3';\n+  subv_optab->libcall_gen = gen_intv_fp_libfunc;\n+  smul_optab->libcall_basename = \"mul\";\n+  smul_optab->libcall_suffix = '3';\n+  smul_optab->libcall_gen = gen_int_fp_libfunc;\n+  smulv_optab->libcall_basename = \"mul\";\n+  smulv_optab->libcall_suffix = '3';\n+  smulv_optab->libcall_gen = gen_intv_fp_libfunc;\n+  sdiv_optab->libcall_basename = \"div\";\n+  sdiv_optab->libcall_suffix = '3';\n+  sdiv_optab->libcall_gen = gen_int_fp_libfunc;\n+  sdivv_optab->libcall_basename = \"divv\";\n+  sdivv_optab->libcall_suffix = '3';\n+  sdivv_optab->libcall_gen = gen_int_libfunc;\n+  udiv_optab->libcall_basename = \"udiv\";\n+  udiv_optab->libcall_suffix = '3';\n+  udiv_optab->libcall_gen = gen_int_libfunc;\n+  sdivmod_optab->libcall_basename = \"divmod\";\n+  sdivmod_optab->libcall_suffix = '4';\n+  sdivmod_optab->libcall_gen = gen_int_libfunc;\n+  udivmod_optab->libcall_basename = \"udivmod\";\n+  udivmod_optab->libcall_suffix = '4';\n+  udivmod_optab->libcall_gen = gen_int_libfunc;\n+  smod_optab->libcall_basename = \"mod\";\n+  smod_optab->libcall_suffix = '3';\n+  smod_optab->libcall_gen = gen_int_libfunc;\n+  umod_optab->libcall_basename = \"umod\";\n+  umod_optab->libcall_suffix = '3';\n+  umod_optab->libcall_gen = gen_int_libfunc;\n+  ftrunc_optab->libcall_basename = \"ftrunc\";\n+  ftrunc_optab->libcall_suffix = '2';\n+  ftrunc_optab->libcall_gen = gen_fp_libfunc;\n+  and_optab->libcall_basename = \"and\";\n+  and_optab->libcall_suffix = '3';\n+  and_optab->libcall_gen = gen_int_libfunc;\n+  ior_optab->libcall_basename = \"ior\";\n+  ior_optab->libcall_suffix = '3';\n+  ior_optab->libcall_gen = gen_int_libfunc;\n+  xor_optab->libcall_basename = \"xor\";\n+  xor_optab->libcall_suffix = '3';\n+  xor_optab->libcall_gen = gen_int_libfunc;\n+  ashl_optab->libcall_basename = \"ashl\";\n+  ashl_optab->libcall_suffix = '3';\n+  ashl_optab->libcall_gen = gen_int_libfunc;\n+  ashr_optab->libcall_basename = \"ashr\";\n+  ashr_optab->libcall_suffix = '3';\n+  ashr_optab->libcall_gen = gen_int_libfunc;\n+  lshr_optab->libcall_basename = \"lshr\";\n+  lshr_optab->libcall_suffix = '3';\n+  lshr_optab->libcall_gen = gen_int_libfunc;\n+  smin_optab->libcall_basename = \"min\";\n+  smin_optab->libcall_suffix = '3';\n+  smin_optab->libcall_gen = gen_int_fp_libfunc;\n+  smax_optab->libcall_basename = \"max\";\n+  smax_optab->libcall_suffix = '3';\n+  smax_optab->libcall_gen = gen_int_fp_libfunc;\n+  umin_optab->libcall_basename = \"umin\";\n+  umin_optab->libcall_suffix = '3';\n+  umin_optab->libcall_gen = gen_int_libfunc;\n+  umax_optab->libcall_basename = \"umax\";\n+  umax_optab->libcall_suffix = '3';\n+  umax_optab->libcall_gen = gen_int_libfunc;\n+  neg_optab->libcall_basename = \"neg\";\n+  neg_optab->libcall_suffix = '2';\n+  neg_optab->libcall_gen = gen_int_fp_libfunc;\n+  negv_optab->libcall_basename = \"neg\";\n+  negv_optab->libcall_suffix = '2';\n+  negv_optab->libcall_gen = gen_intv_fp_libfunc;\n+  one_cmpl_optab->libcall_basename = \"one_cmpl\";\n+  one_cmpl_optab->libcall_suffix = '2';\n+  one_cmpl_optab->libcall_gen = gen_int_libfunc;\n+  ffs_optab->libcall_basename = \"ffs\";\n+  ffs_optab->libcall_suffix = '2';\n+  ffs_optab->libcall_gen = gen_int_libfunc;\n+  clz_optab->libcall_basename = \"clz\";\n+  clz_optab->libcall_suffix = '2';\n+  clz_optab->libcall_gen = gen_int_libfunc;\n+  ctz_optab->libcall_basename = \"ctz\";\n+  ctz_optab->libcall_suffix = '2';\n+  ctz_optab->libcall_gen = gen_int_libfunc;\n+  popcount_optab->libcall_basename = \"popcount\";\n+  popcount_optab->libcall_suffix = '2';\n+  popcount_optab->libcall_gen = gen_int_libfunc;\n+  parity_optab->libcall_basename = \"parity\";\n+  parity_optab->libcall_suffix = '2';\n+  parity_optab->libcall_gen = gen_int_libfunc;\n \n   /* Comparison libcalls for integers MUST come in pairs,\n      signed/unsigned.  */\n-  init_integral_libfuncs (cmp_optab, \"cmp\", '2');\n-  init_integral_libfuncs (ucmp_optab, \"ucmp\", '2');\n-  init_floating_libfuncs (cmp_optab, \"cmp\", '2');\n+  cmp_optab->libcall_basename = \"cmp\";\n+  cmp_optab->libcall_suffix = '2';\n+  cmp_optab->libcall_gen = gen_int_fp_libfunc;\n+  ucmp_optab->libcall_basename = \"ucmp\";\n+  ucmp_optab->libcall_suffix = '2';\n+  ucmp_optab->libcall_gen = gen_int_libfunc;\n \n   /* EQ etc are floating point only.  */\n-  init_floating_libfuncs (eq_optab, \"eq\", '2');\n-  init_floating_libfuncs (ne_optab, \"ne\", '2');\n-  init_floating_libfuncs (gt_optab, \"gt\", '2');\n-  init_floating_libfuncs (ge_optab, \"ge\", '2');\n-  init_floating_libfuncs (lt_optab, \"lt\", '2');\n-  init_floating_libfuncs (le_optab, \"le\", '2');\n-  init_floating_libfuncs (unord_optab, \"unord\", '2');\n-\n-  init_floating_libfuncs (powi_optab, \"powi\", '2');\n+  eq_optab->libcall_basename = \"eq\";\n+  eq_optab->libcall_suffix = '2';\n+  eq_optab->libcall_gen = gen_fp_libfunc;\n+  ne_optab->libcall_basename = \"ne\";\n+  ne_optab->libcall_suffix = '2';\n+  ne_optab->libcall_gen = gen_fp_libfunc;\n+  gt_optab->libcall_basename = \"gt\";\n+  gt_optab->libcall_suffix = '2';\n+  gt_optab->libcall_gen = gen_fp_libfunc;\n+  ge_optab->libcall_basename = \"ge\";\n+  ge_optab->libcall_suffix = '2';\n+  ge_optab->libcall_gen = gen_fp_libfunc;\n+  lt_optab->libcall_basename = \"lt\";\n+  lt_optab->libcall_suffix = '2';\n+  lt_optab->libcall_gen = gen_fp_libfunc;\n+  le_optab->libcall_basename = \"le\";\n+  le_optab->libcall_suffix = '2';\n+  le_optab->libcall_gen = gen_fp_libfunc;\n+  unord_optab->libcall_basename = \"unord\";\n+  unord_optab->libcall_suffix = '2';\n+  unord_optab->libcall_gen = gen_fp_libfunc;\n+\n+  powi_optab->libcall_basename = \"powi\";\n+  powi_optab->libcall_suffix = '2';\n+  powi_optab->libcall_gen = gen_fp_libfunc;\n \n   /* Conversions.  */\n-  init_interclass_conv_libfuncs (sfloat_optab, \"float\",\n-\t\t\t\t MODE_INT, MODE_FLOAT);\n-  init_interclass_conv_libfuncs (sfloat_optab, \"float\",\n-\t\t\t\t MODE_INT, MODE_DECIMAL_FLOAT);\n-  init_interclass_conv_libfuncs (ufloat_optab, \"floatun\",\n-\t\t\t\t MODE_INT, MODE_FLOAT);\n-  init_interclass_conv_libfuncs (ufloat_optab, \"floatun\",\n-\t\t\t\t MODE_INT, MODE_DECIMAL_FLOAT);\n-  init_interclass_conv_libfuncs (sfix_optab, \"fix\",\n-\t\t\t\t MODE_FLOAT, MODE_INT);\n-  init_interclass_conv_libfuncs (sfix_optab, \"fix\",\n-\t\t\t\t MODE_DECIMAL_FLOAT, MODE_INT);\n-  init_interclass_conv_libfuncs (ufix_optab, \"fixuns\",\n-\t\t\t\t MODE_FLOAT, MODE_INT);\n-  init_interclass_conv_libfuncs (ufix_optab, \"fixuns\",\n-\t\t\t\t MODE_DECIMAL_FLOAT, MODE_INT);\n-  init_interclass_conv_libfuncs (ufloat_optab, \"floatuns\",\n-\t\t\t\t MODE_INT, MODE_DECIMAL_FLOAT);\n-  init_interclass_conv_libfuncs (lrint_optab, \"lrint\",\n-\t\t\t\t MODE_INT, MODE_FLOAT);\n-  init_interclass_conv_libfuncs (lround_optab, \"lround\",\n-\t\t\t\t MODE_INT, MODE_FLOAT);\n-  init_interclass_conv_libfuncs (lfloor_optab, \"lfloor\",\n-\t\t\t\t MODE_INT, MODE_FLOAT);\n-  init_interclass_conv_libfuncs (lceil_optab, \"lceil\",\n-\t\t\t\t MODE_INT, MODE_FLOAT);\n-\n-  /* sext_optab is also used for FLOAT_EXTEND.  */\n-  init_intraclass_conv_libfuncs (sext_optab, \"extend\", MODE_FLOAT, true);\n-  init_intraclass_conv_libfuncs (sext_optab, \"extend\", MODE_DECIMAL_FLOAT, true);\n-  init_interclass_conv_libfuncs (sext_optab, \"extend\", MODE_FLOAT, MODE_DECIMAL_FLOAT);\n-  init_interclass_conv_libfuncs (sext_optab, \"extend\", MODE_DECIMAL_FLOAT, MODE_FLOAT);\n-  init_intraclass_conv_libfuncs (trunc_optab, \"trunc\", MODE_FLOAT, false);\n-  init_intraclass_conv_libfuncs (trunc_optab, \"trunc\", MODE_DECIMAL_FLOAT, false);\n-  init_interclass_conv_libfuncs (trunc_optab, \"trunc\", MODE_FLOAT, MODE_DECIMAL_FLOAT);\n-  init_interclass_conv_libfuncs (trunc_optab, \"trunc\", MODE_DECIMAL_FLOAT, MODE_FLOAT);\n+  sfloat_optab->libcall_basename = \"float\";\n+  sfloat_optab->libcall_gen = gen_int_to_fp_conv_libfunc;\n+  ufloat_optab->libcall_gen = gen_ufloat_conv_libfunc;\n+  sfix_optab->libcall_basename = \"fix\";\n+  sfix_optab->libcall_gen = gen_fp_to_int_conv_libfunc;\n+  ufix_optab->libcall_basename = \"fixuns\";\n+  ufix_optab->libcall_gen = gen_fp_to_int_conv_libfunc;\n+  lrint_optab->libcall_basename = \"lrint\";\n+  lrint_optab->libcall_gen = gen_int_to_fp_nondecimal_conv_libfunc;\n+  lround_optab->libcall_basename = \"lround\";\n+  lround_optab->libcall_gen = gen_int_to_fp_nondecimal_conv_libfunc;\n+  lfloor_optab->libcall_basename = \"lfloor\";\n+  lfloor_optab->libcall_gen = gen_int_to_fp_nondecimal_conv_libfunc;\n+  lceil_optab->libcall_basename = \"lceil\";\n+  lceil_optab->libcall_gen = gen_int_to_fp_nondecimal_conv_libfunc;\n+\n+  /* trunc_optab is also used for FLOAT_EXTEND.  */\n+  sext_optab->libcall_basename = \"extend\";\n+  sext_optab->libcall_gen = gen_extend_conv_libfunc;\n+  trunc_optab->libcall_basename = \"trunc\";\n+  trunc_optab->libcall_gen = gen_trunc_conv_libfunc;\n+\n+  /* The ffs function operates on `int'.  Fall back on it if we do not\n+     have a libgcc2 function for that width.  */\n+  if (INT_TYPE_SIZE < BITS_PER_WORD)\n+    {\n+      int_mode = mode_for_size (INT_TYPE_SIZE, MODE_INT, 0);\n+      set_optab_libfunc (ffs_optab, mode_for_size (INT_TYPE_SIZE, MODE_INT, 0),\n+\t\t\t \"ffs\");\n+    }\n \n   /* Explicitly initialize the bswap libfuncs since we need them to be\n      valid for things other than word_mode.  */\n@@ -6073,8 +6385,7 @@ init_optabs (void)\n   /* Use cabs for double complex abs, since systems generally have cabs.\n      Don't define any libcall for float complex, so that cabs will be used.  */\n   if (complex_double_type_node)\n-    optab_handler (abs_optab, TYPE_MODE (complex_double_type_node))->libfunc\n-      = init_one_libfunc (\"cabs\");\n+    set_optab_libfunc (abs_optab, TYPE_MODE (complex_double_type_node), \"cabs\");\n \n   abort_libfunc = init_one_libfunc (\"abort\");\n   memcpy_libfunc = init_one_libfunc (\"memcpy\");\n@@ -6109,12 +6420,10 @@ init_optabs (void)\n   targetm.init_libfuncs ();\n }\n \n-#ifdef DEBUG\n-\n /* Print information about the current contents of the optabs on\n    STDERR.  */\n \n-static void\n+void\n debug_optab_libfuncs (void)\n {\n   int i;\n@@ -6126,17 +6435,17 @@ debug_optab_libfuncs (void)\n     for (j = 0; j < NUM_MACHINE_MODES; ++j)\n       {\n \toptab o;\n-\tstruct optab_handlers *h;\n+\trtx l;\n \n \to = optab_table[i];\n-\th = optab_handler (o, j);\n-\tif (h->libfunc)\n+\tl = optab_libfunc (optab_table[i], j);\n+\tif (l)\n \t  {\n-\t    gcc_assert (GET_CODE (h->libfunc) == SYMBOL_REF);\n+\t    gcc_assert (GET_CODE (l) == SYMBOL_REF);\n \t    fprintf (stderr, \"%s\\t%s:\\t%s\\n\",\n \t\t     GET_RTX_NAME (o->code),\n \t\t     GET_MODE_NAME (j),\n-\t\t     XSTR (h->libfunc, 0));\n+\t\t     XSTR (l, 0));\n \t  }\n       }\n \n@@ -6146,24 +6455,22 @@ debug_optab_libfuncs (void)\n       for (k = 0; k < NUM_MACHINE_MODES; ++k)\n \t{\n \t  convert_optab o;\n-\t  struct optab_handlers *h;\n+\t  rtx l;\n \n-\t  o = &convert_optab_table[i];\n-\t  h = convert_optab_handler(o, j, k);\n-\t  if (h->libfunc)\n+\t  o = convert_optab_table[i];\n+\t  l = convert_optab_libfunc (o, j, k);\n+\t  if (l)\n \t    {\n-\t      gcc_assert (GET_CODE (h->libfunc) == SYMBOL_REF);\n+\t      gcc_assert (GET_CODE (l) == SYMBOL_REF);\n \t      fprintf (stderr, \"%s\\t%s\\t%s:\\t%s\\n\",\n \t\t       GET_RTX_NAME (o->code),\n \t\t       GET_MODE_NAME (j),\n \t\t       GET_MODE_NAME (k),\n-\t\t       XSTR (h->libfunc, 0));\n+\t\t       XSTR (l, 0));\n \t    }\n \t}\n }\n \n-#endif /* DEBUG */\n-\n \f\n /* Generate insns to trap with code TCODE if OP1 and OP2 satisfy condition\n    CODE.  Return 0 on failure.  */"}, {"sha": "a85b3f365e7de1c46c6a47f68ecf1beb8c407e4d", "filename": "gcc/optabs.h", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a33f10034d5c598395edc4ff0ae56e2bde7577e/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a33f10034d5c598395edc4ff0ae56e2bde7577e/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=8a33f10034d5c598395edc4ff0ae56e2bde7577e", "patch": "@@ -39,25 +39,31 @@ along with GCC; see the file COPYING3.  If not see\n    A few optabs, such as move_optab and cmp_optab, are used\n    by special code.  */\n \n-struct optab_handlers GTY(())\n+struct optab_handlers\n {\n   enum insn_code insn_code;\n-  rtx libfunc;\n };\n \n-struct optab GTY(())\n+struct optab\n {\n   enum rtx_code code;\n+  const char *libcall_basename;\n+  char libcall_suffix;\n+  void (*libcall_gen)(struct optab *, const char *name, char suffix, enum machine_mode);\n   struct optab_handlers handlers[NUM_MACHINE_MODES];\n };\n typedef struct optab * optab;\n \n /* A convert_optab is for some sort of conversion operation between\n    modes.  The first array index is the destination mode, the second\n    is the source mode.  */\n-struct convert_optab GTY(())\n+struct convert_optab\n {\n   enum rtx_code code;\n+  const char *libcall_basename;\n+  void (*libcall_gen)(struct convert_optab *, const char *name,\n+\t\t      enum machine_mode,\n+\t\t      enum machine_mode);\n   struct optab_handlers handlers[NUM_MACHINE_MODES][NUM_MACHINE_MODES];\n };\n typedef struct convert_optab *convert_optab;\n@@ -324,7 +330,7 @@ enum optab_index\n   OTI_MAX\n };\n \n-extern GTY(()) optab optab_table[OTI_MAX];\n+extern optab optab_table[OTI_MAX];\n \n #define add_optab (optab_table[OTI_add])\n #define sub_optab (optab_table[OTI_sub])\n@@ -498,7 +504,7 @@ enum convert_optab_index\n   COI_MAX\n };\n \n-extern GTY(()) convert_optab convert_optab_table[COI_MAX];\n+extern convert_optab convert_optab_table[COI_MAX];\n \n #define sext_optab (convert_optab_table[COI_sext])\n #define zext_optab (convert_optab_table[COI_zext])\n@@ -521,7 +527,7 @@ extern enum insn_code reload_in_optab[NUM_MACHINE_MODES];\n extern enum insn_code reload_out_optab[NUM_MACHINE_MODES];\n \n /* Contains the optab used for each rtx code.  */\n-extern GTY(()) optab code_to_optab[NUM_RTX_CODE + 1];\n+extern optab code_to_optab[NUM_RTX_CODE + 1];\n \n \f\n typedef rtx (*rtxfun) (rtx);\n@@ -709,4 +715,8 @@ extern rtx expand_vec_shift_expr (tree, rtx);\n #define convert_optab_handler(optab,mode,mode2) \\\n \t(&(optab)->handlers[(int) (mode)][(int) (mode2)])\n \n+extern rtx optab_libfunc (optab optab, enum machine_mode mode);\n+extern rtx optab_libfunc (optab optab, enum machine_mode mode);\n+extern rtx convert_optab_libfunc (convert_optab optab, enum machine_mode mode1,\n+\t\t\t          enum machine_mode mode2);\n #endif /* GCC_OPTABS_H */"}]}