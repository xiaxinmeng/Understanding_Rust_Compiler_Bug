{"sha": "ac77b88e5267498679463fb578fe89ba973977e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM3N2I4OGU1MjY3NDk4Njc5NDYzZmI1NzhmZTg5YmE5NzM5NzdlMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-08-14T20:49:40Z"}, "committer": {"name": "Douglas Rupp", "email": "rupp@gcc.gnu.org", "date": "2009-08-14T20:49:40Z"}, "message": "unwind-ia64.c (struct _Unwind_Context): Add new field 'signal_pfs_loc'.\n\n\n\t* config/ia64/unwind-ia64.c (struct _Unwind_Context): Add new\n\tfield 'signal_pfs_loc'.\n\t(uw_frame_state_for): Remove duplicate code dealing with leaf\n\tprocedures without unwind info.\n\tIf in the frame after unwinding through a signal handler, restore\n\tthe AR.PFS register instead of the CFM if AR.PFS has not been saved.\n\t* config/ia64/linux-unwind.h (ia64_fallback_frame_state): Do not set\n\t'pfs_loc' to the AR.PFS location in the signal context; instead\n\tset 'signal_pfs_loc'.\n\tManually generate the unwind info for the AR.PFS register.\n\t(ABI_MARKER_OLD_LINUX_SIGTRAMP, ABI_MARKER_OLD_LINUX_INTERRUPT,\n\tABI_MARKER_LINUX_SIGTRAMP, ABI_MARKER_LINUX_INTERRUPT): Define.\n\t(ia64_handle_unwabi): Test 'fs->unwabi' against them.\n\tDo not set 'pfs_loc' to the AR.PFS location in the signal context;\n\tinstead set 'signal_pfs_loc'.\n\tRemove code preventing the AR.PFS register from being restored\n\tfrom the signal context.\n\nFrom-SVN: r150777", "tree": {"sha": "f84e66234a111d9d52810e971f1c6349093821d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f84e66234a111d9d52810e971f1c6349093821d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac77b88e5267498679463fb578fe89ba973977e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac77b88e5267498679463fb578fe89ba973977e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac77b88e5267498679463fb578fe89ba973977e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac77b88e5267498679463fb578fe89ba973977e2/comments", "author": null, "committer": null, "parents": [{"sha": "c24db30451c80100f6431dec406702fefa549ec6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c24db30451c80100f6431dec406702fefa549ec6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c24db30451c80100f6431dec406702fefa549ec6"}], "stats": {"total": 86, "additions": 69, "deletions": 17}, "files": [{"sha": "d2f328e3499cfe72ee3ed52747de35a3c63415a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac77b88e5267498679463fb578fe89ba973977e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac77b88e5267498679463fb578fe89ba973977e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac77b88e5267498679463fb578fe89ba973977e2", "patch": "@@ -1,3 +1,23 @@\n+2009-08-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/ia64/unwind-ia64.c (struct _Unwind_Context): Add new\n+\tfield 'signal_pfs_loc'.\n+\t(uw_frame_state_for): Remove duplicate code dealing with leaf\n+\tprocedures without unwind info.\n+\tIf in the frame after unwinding through a signal handler, restore\n+\tthe AR.PFS register instead of the CFM if AR.PFS has not been saved.\n+\t* config/ia64/linux-unwind.h (ia64_fallback_frame_state): Do not set\n+\t'pfs_loc' to the AR.PFS location in the signal context; instead\n+\tset 'signal_pfs_loc'.\n+\tManually generate the unwind info for the AR.PFS register.\n+\t(ABI_MARKER_OLD_LINUX_SIGTRAMP, ABI_MARKER_OLD_LINUX_INTERRUPT,\n+\tABI_MARKER_LINUX_SIGTRAMP, ABI_MARKER_LINUX_INTERRUPT): Define.\n+\t(ia64_handle_unwabi): Test 'fs->unwabi' against them.\n+\tDo not set 'pfs_loc' to the AR.PFS location in the signal context;\n+\tinstead set 'signal_pfs_loc'.\n+\tRemove code preventing the AR.PFS register from being restored\n+\tfrom the signal context.\n+\n 2009-08-14  Douglas B Rupp  <rupp@gnat.com>\n \t    Tristan Gingold  <gingold@adacore.com>\n "}, {"sha": "93f762de5736aef3379bd9583706c983436603a6", "filename": "gcc/config/ia64/linux-unwind.h", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac77b88e5267498679463fb578fe89ba973977e2/gcc%2Fconfig%2Fia64%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac77b88e5267498679463fb578fe89ba973977e2/gcc%2Fconfig%2Fia64%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Flinux-unwind.h?ref=ac77b88e5267498679463fb578fe89ba973977e2", "patch": "@@ -23,7 +23,7 @@\n    <http://www.gnu.org/licenses/>.  */\n \n /* Do code reading to identify a signal frame, and set the frame\n-   state data appropriately.  See unwind-dw2.c for the structs.  */\n+   state data appropriately.  See unwind-ia64.c for the structs.  */\n \n /* This works only for glibc-2.3 and later, because sigcontext is different\n    in glibc-2.2.4.  */\n@@ -66,7 +66,7 @@ ia64_fallback_frame_state (struct _Unwind_Context *context,\n       }\n \n       context->fpsr_loc = &(sc->sc_ar_fpsr);\n-      context->pfs_loc = &(sc->sc_ar_pfs);\n+      context->signal_pfs_loc = &(sc->sc_ar_pfs);\n       context->lc_loc = &(sc->sc_ar_lc);\n       context->unat_loc = &(sc->sc_ar_unat);\n       context->br_loc[0] = &(sc->sc_br[0]);\n@@ -105,23 +105,34 @@ ia64_fallback_frame_state (struct _Unwind_Context *context,\n \t  ia64_rse_skip_regs ((unsigned long *)(sc->sc_ar_bsp), -sof);\n       }\n \n+      /* Account for use of br.ret to resume execution of user code.  */\n       fs->curr.reg[UNW_REG_RP].where = UNW_WHERE_SPREL;\n       fs->curr.reg[UNW_REG_RP].val\n \t= (unsigned long)&(sc->sc_ip) - context->psp;\n       fs->curr.reg[UNW_REG_RP].when = -1;\n \n+      fs->curr.reg[UNW_REG_PFS].where = UNW_WHERE_SPREL;\n+      fs->curr.reg[UNW_REG_PFS].val\n+\t= (unsigned long)&(sc->sc_cfm) - context->psp;\n+      fs ->curr.reg[UNW_REG_PFS].when = -1;\n+\n       return _URC_NO_REASON;\n     }\n   return _URC_END_OF_STACK;\n }\n \n #define MD_HANDLE_UNWABI ia64_handle_unwabi\n \n+#define ABI_MARKER_OLD_LINUX_SIGTRAMP\t((0 << 8) | 's')\n+#define ABI_MARKER_OLD_LINUX_INTERRUPT\t((0 << 8) | 'i')\n+#define ABI_MARKER_LINUX_SIGTRAMP\t((3 << 8) | 's')\n+#define ABI_MARKER_LINUX_INTERRUPT\t((3 << 8) | 'i')\n+\n static void\n ia64_handle_unwabi (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n {\n-  if (fs->unwabi == ((3 << 8) | 's')\n-      || fs->unwabi == ((0 << 8) | 's'))\n+  if (fs->unwabi == ABI_MARKER_LINUX_SIGTRAMP\n+      || fs->unwabi == ABI_MARKER_OLD_LINUX_SIGTRAMP)\n     {\n       struct sigframe {\n \tchar scratch[16];\n@@ -144,7 +155,7 @@ ia64_handle_unwabi (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n \t  context->ireg[i - 2].loc = &sc->sc_gr[i];\n       }\n \n-      context->pfs_loc = &(sc->sc_ar_pfs);\n+      context->signal_pfs_loc = &(sc->sc_ar_pfs);\n       context->lc_loc = &(sc->sc_ar_lc);\n       context->unat_loc = &(sc->sc_ar_unat);\n       context->br_loc[0] = &(sc->sc_br[0]);\n@@ -181,9 +192,8 @@ ia64_handle_unwabi (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n \t  ia64_rse_skip_regs ((unsigned long *)(sc->sc_ar_bsp), -sof);\n       }\n \n-      /* pfs_loc already set above.  Without this pfs_loc would point\n-\t incorrectly to sc_cfm instead of sc_ar_pfs.  */\n-      fs->curr.reg[UNW_REG_PFS].where = UNW_WHERE_NONE;\n+      /* The use of br.ret to resume execution of user code is already\n+\t accounted for in the unwind ABI.  */\n     }\n }\n #endif /* glibc-2.3 or better */"}, {"sha": "8e62f328a23900c22be8d4e19bb5c089128e2df6", "filename": "gcc/config/ia64/unwind-ia64.c", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac77b88e5267498679463fb578fe89ba973977e2/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac77b88e5267498679463fb578fe89ba973977e2/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Funwind-ia64.c?ref=ac77b88e5267498679463fb578fe89ba973977e2", "patch": "@@ -204,6 +204,9 @@ struct _Unwind_Context\n   unsigned long *pfs_loc;\t/* Save location for pfs in current\n   \t\t\t\t   (corr. to sp) frame.  Target\n   \t\t\t\t   contains cfm for caller.\t*/\n+  unsigned long *signal_pfs_loc;/* Save location for pfs in current\n+\t\t\t\t   signal frame.  Target contains\n+\t\t\t\t   pfs for caller.  */\n   unsigned long *pri_unat_loc;\n   unsigned long *unat_loc;\n   unsigned long *lc_loc;\n@@ -1786,6 +1789,7 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n #ifdef MD_FALLBACK_FRAME_STATE_FOR\n       if (MD_FALLBACK_FRAME_STATE_FOR (context, fs) == _URC_NO_REASON)\n \treturn _URC_NO_REASON;\n+#endif\n \n       /* [SCRA 11.4.1] A leaf function with no memory stack, no exception\n \t handlers, and which keeps the return value in B0 does not need\n@@ -1794,15 +1798,11 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n \t This can only happen in the frame after unwinding through a signal\n \t handler.  Avoid infinite looping by requiring that B0 != RP.\n \t RP == 0 terminates the chain.  */\n-      if (context->br_loc[0] && *context->br_loc[0] != context->rp\n+      if (context->br_loc[0]\n+\t  && *context->br_loc[0] != context->rp\n \t  && context->rp != 0)\n-\t{\n-\t  fs->curr.reg[UNW_REG_RP].where = UNW_WHERE_BR;\n-\t  fs->curr.reg[UNW_REG_RP].when = -1;\n-\t  fs->curr.reg[UNW_REG_RP].val = 0;\n-\t  return _URC_NO_REASON;\n-\t}\n-#endif\n+\tgoto skip_unwind_info;\n+\n       return _URC_END_OF_STACK;\n     }\n \n@@ -1850,14 +1850,36 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n \t  r->where = UNW_WHERE_NONE;\n     }\n \n-  /* If RP did't get saved, generate entry for the return link register.  */\n+skip_unwind_info:\n+  /* If RP didn't get saved, generate entry for the return link register.  */\n   if (fs->curr.reg[UNW_REG_RP].when >= fs->when_target)\n     {\n       fs->curr.reg[UNW_REG_RP].where = UNW_WHERE_BR;\n       fs->curr.reg[UNW_REG_RP].when = -1;\n       fs->curr.reg[UNW_REG_RP].val = fs->return_link_reg;\n     }\n \n+  /* There is a subtlety for the frame after unwinding through a signal\n+     handler: should we restore the cfm as usual or the pfs?  We can't\n+     restore both because we use br.ret to resume execution of user code.\n+     For other frames the procedure is by definition non-leaf so the pfs\n+     is saved and restored and thus effectively dead in the body; only\n+     the cfm need therefore be restored.\n+     \n+     Here we have 2 cases:\n+       - either the pfs is saved and restored and thus effectively dead\n+\t like in regular frames; then we do nothing special and restore\n+\t the cfm.\n+       - or the pfs is not saved and thus live; but in that case the\n+\t procedure is necessarily leaf so the cfm is effectively dead\n+\t and we restore the pfs.  */\n+  if (context->signal_pfs_loc)\n+    {\n+      if (fs->curr.reg[UNW_REG_PFS].when >= fs->when_target)\n+\tcontext->pfs_loc = context->signal_pfs_loc;\n+      context->signal_pfs_loc = NULL;\n+    }\n+\n   return _URC_NO_REASON;\n }\n "}]}