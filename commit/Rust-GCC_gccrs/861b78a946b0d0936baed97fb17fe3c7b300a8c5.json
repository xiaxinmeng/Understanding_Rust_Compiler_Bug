{"sha": "861b78a946b0d0936baed97fb17fe3c7b300a8c5", "node_id": "C_kwDOANBUbNoAKDg2MWI3OGE5NDZiMGQwOTM2YmFlZDk3ZmIxN2ZlM2M3YjMwMGE4YzU", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-03-09T19:47:00Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-16T08:42:03Z"}, "message": "[Ada] Fix internal error on predicate aspect with iterator\n\nThe semantic analysis of predicates involves a fair amount of tree\ncopying because of both semantic and implementation considerations, and\nthere is a difficulty with quantified expressions since they declare a\nnew entity that cannot be shared between the various copies of the tree.\n\nThis change implements a specific processing for it in New_Copy_Tree\nthat subsumes a couple of fixes made earlier for variants of the issue.\n\ngcc/ada/\n\n\t* sem_util.ads (Is_Entity_Of_Quantified_Expression): Declare.\n\t* sem_util.adb (Is_Entity_Of_Quantified_Expression): New\n\tpredicate.\n\t(New_Copy_Tree): Deal with all entities of quantified\n\texpressions.\n\t* sem_ch13.adb (Build_Predicate_Functions): Get rid of\n\tsuperfluous tree copying and remove obsolete code.\n\t* sem_ch6.adb (Fully_Conformant_Expressions): Deal with all\n\tentities of quantified expressions.", "tree": {"sha": "f8625731ca2c2ba3d78c4a9c1a8cc5dfbc73e07e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8625731ca2c2ba3d78c4a9c1a8cc5dfbc73e07e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/861b78a946b0d0936baed97fb17fe3c7b300a8c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/861b78a946b0d0936baed97fb17fe3c7b300a8c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/861b78a946b0d0936baed97fb17fe3c7b300a8c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/861b78a946b0d0936baed97fb17fe3c7b300a8c5/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c88e46a270212180767fc585dd190b7713702db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c88e46a270212180767fc585dd190b7713702db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c88e46a270212180767fc585dd190b7713702db"}], "stats": {"total": 94, "additions": 38, "deletions": 56}, "files": [{"sha": "f597024a54a27979136cbe7415ecb15e43900b4c", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 2, "deletions": 38, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861b78a946b0d0936baed97fb17fe3c7b300a8c5/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861b78a946b0d0936baed97fb17fe3c7b300a8c5/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=861b78a946b0d0936baed97fb17fe3c7b300a8c5", "patch": "@@ -10231,16 +10231,13 @@ package body Sem_Ch13 is\n \n             Set_SCO_Pragma_Enabled (Sloc (Prag));\n \n-            --  Extract the arguments of the pragma. The expression itself\n-            --  is copied for use in the predicate function, to preserve the\n-            --  original version for ASIS use.\n-            --  Is this still needed???\n+            --  Extract the arguments of the pragma\n \n             Arg1 := First (Pragma_Argument_Associations (Prag));\n             Arg2 := Next (Arg1);\n \n             Arg1 := Get_Pragma_Arg (Arg1);\n-            Arg2 := New_Copy_Tree (Get_Pragma_Arg (Arg2));\n+            Arg2 := Get_Pragma_Arg (Arg2);\n \n             --  When the predicate pragma applies to the current type or its\n             --  full view, replace all occurrences of the subtype name with\n@@ -10455,45 +10452,12 @@ package body Sem_Ch13 is\n \n          if Raise_Expression_Present then\n             declare\n-               function Reset_Loop_Variable\n-                 (N : Node_Id) return Traverse_Result;\n-\n-               procedure Reset_Loop_Variables is\n-                 new Traverse_Proc (Reset_Loop_Variable);\n-\n-               ------------------------\n-               -- Reset_Loop_Variable --\n-               ------------------------\n-\n-               function Reset_Loop_Variable\n-                 (N : Node_Id) return Traverse_Result\n-               is\n-               begin\n-                  if Nkind (N) = N_Iterator_Specification then\n-                     Set_Defining_Identifier (N,\n-                       Make_Defining_Identifier\n-                         (Sloc (N), Chars (Defining_Identifier (N))));\n-                  end if;\n-\n-                  return OK;\n-               end Reset_Loop_Variable;\n-\n-               --  Local variables\n-\n                Map : constant Elist_Id := New_Elmt_List;\n \n             begin\n                Append_Elmt (Object_Entity, Map);\n                Append_Elmt (Object_Entity_M, Map);\n                Expr_M := New_Copy_Tree (Expr, Map => Map);\n-\n-               --  The unanalyzed expression will be copied and appear in\n-               --  both functions. Normally expressions do not declare new\n-               --  entities, but quantified expressions do, so we need to\n-               --  create new entities for their bound variables, to prevent\n-               --  multiple definitions in gigi.\n-\n-               Reset_Loop_Variables (Expr_M);\n             end;\n          end if;\n "}, {"sha": "38ed14f27b387715b932ef5d9702ca49e973d407", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861b78a946b0d0936baed97fb17fe3c7b300a8c5/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861b78a946b0d0936baed97fb17fe3c7b300a8c5/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=861b78a946b0d0936baed97fb17fe3c7b300a8c5", "patch": "@@ -10106,14 +10106,13 @@ package body Sem_Ch6 is\n                  and then Discriminal_Link (Entity (E1)) =\n                           Discriminal_Link (Entity (E2)))\n \n-             --  AI12-050: The loop variables of quantified expressions match\n-             --  if they have the same identifier, even though they may have\n-             --  different entities.\n+             --  AI12-050: The entities of quantified expressions match if they\n+             --  have the same identifier, even if they may be distinct nodes.\n \n               or else\n                 (Chars (Entity (E1)) = Chars (Entity (E2))\n-                  and then Ekind (Entity (E1)) = E_Loop_Parameter\n-                  and then Ekind (Entity (E2)) = E_Loop_Parameter)\n+                  and then Is_Entity_Of_Quantified_Expression (Entity (E1))\n+                  and then Is_Entity_Of_Quantified_Expression (Entity (E2)))\n \n               --  A call to an instantiation of Unchecked_Conversion is\n               --  rewritten with the name of the generated function created for"}, {"sha": "225d76105f512da0495d0611c4bf386b99bd8240", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861b78a946b0d0936baed97fb17fe3c7b300a8c5/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861b78a946b0d0936baed97fb17fe3c7b300a8c5/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=861b78a946b0d0936baed97fb17fe3c7b300a8c5", "patch": "@@ -17624,6 +17624,21 @@ package body Sem_Util is\n       end if;\n    end Is_Effectively_Volatile_Object_Shared;\n \n+   ----------------------------------------\n+   -- Is_Entity_Of_Quantified_Expression --\n+   ----------------------------------------\n+\n+   function Is_Entity_Of_Quantified_Expression (Id : Entity_Id) return Boolean\n+   is\n+      Par : constant Node_Id := Parent (Id);\n+\n+   begin\n+      return (Nkind (Par) = N_Loop_Parameter_Specification\n+               or else Nkind (Par) = N_Iterator_Specification)\n+        and then Defining_Identifier (Par) = Id\n+        and then Nkind (Parent (Par)) = N_Quantified_Expression;\n+   end Is_Entity_Of_Quantified_Expression;\n+\n    -------------------\n    -- Is_Entry_Body --\n    -------------------\n@@ -24622,22 +24637,20 @@ package body Sem_Util is\n          --  ??? this list is flaky, and may hide dormant bugs\n          --  Should functions be included???\n \n-         --  Loop parameters appear within quantified expressions and contain\n-         --  an entity declaration that must be replaced when the expander is\n-         --  active if the expression has been preanalyzed or analyzed.\n+         --  Quantified expressions contain an entity declaration that must\n+         --  always be replaced when the expander is active, even if it has\n+         --  not been analyzed yet like e.g. in predicates.\n \n-         elsif Ekind (Id) not in\n-                 E_Block     | E_Constant | E_Label | E_Loop_Parameter |\n-                 E_Procedure | E_Variable\n+         elsif Ekind (Id) not in E_Block\n+                               | E_Constant\n+                               | E_Label\n+                               | E_Procedure\n+                               | E_Variable\n+           and then not Is_Entity_Of_Quantified_Expression (Id)\n            and then not Is_Type (Id)\n          then\n             return;\n \n-         elsif Ekind (Id) = E_Loop_Parameter\n-           and then No (Etype (Condition (Parent (Parent (Id)))))\n-         then\n-            return;\n-\n          --  Nothing to do when the entity was already visited\n \n          elsif NCT_Tables_In_Use\n@@ -24661,9 +24674,12 @@ package body Sem_Util is\n          New_Id := New_Copy (Id);\n \n          --  Create a new name for the new entity because the back end needs\n-         --  distinct names for debugging purposes.\n+         --  distinct names for debugging purposes, provided that the entity\n+         --  has already been analyzed.\n \n-         Set_Chars (New_Id, New_Internal_Name ('T'));\n+         if Ekind (Id) /= E_Void then\n+            Set_Chars (New_Id, New_Internal_Name ('T'));\n+         end if;\n \n          --  Update the Comes_From_Source and Sloc attributes of the entity in\n          --  case the caller has supplied new values."}, {"sha": "3ce2233645ec0d832ee55c36ec03aaf88381f9bb", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861b78a946b0d0936baed97fb17fe3c7b300a8c5/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861b78a946b0d0936baed97fb17fe3c7b300a8c5/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=861b78a946b0d0936baed97fb17fe3c7b300a8c5", "patch": "@@ -2055,6 +2055,9 @@ package Sem_Util is\n    --  Determine whether an arbitrary node denotes an effectively volatile\n    --  object for reading (SPARK RM 7.1.2).\n \n+   function Is_Entity_Of_Quantified_Expression (Id : Entity_Id) return Boolean;\n+   --  Determine whether entity Id is the entity of a quantified expression\n+\n    function Is_Entry_Body (Id : Entity_Id) return Boolean;\n    --  Determine whether entity Id is the body entity of an entry [family]\n "}]}