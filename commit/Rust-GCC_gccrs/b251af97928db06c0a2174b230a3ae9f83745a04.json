{"sha": "b251af97928db06c0a2174b230a3ae9f83745a04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI1MWFmOTc5MjhkYjA2YzBhMjE3NGIyMzBhM2FlOWY4Mzc0NWEwNA==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2007-01-08T19:02:08Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2007-01-08T19:02:08Z"}, "message": "interface.c, [...]: Update Copyright years.\n\n2007-01-08  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n    * interface.c, intrinsic.c, gfortranspec.c, io.c, f95-lang.c,\n    iresolve.c, match.c:  Update Copyright years.  Whitespace.\n\nFrom-SVN: r120587", "tree": {"sha": "b598244cdfb89f7db1065f41dbcd45e7cabf4461", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b598244cdfb89f7db1065f41dbcd45e7cabf4461"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b251af97928db06c0a2174b230a3ae9f83745a04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b251af97928db06c0a2174b230a3ae9f83745a04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b251af97928db06c0a2174b230a3ae9f83745a04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b251af97928db06c0a2174b230a3ae9f83745a04/comments", "author": null, "committer": null, "parents": [{"sha": "7fb41a42a9490e41b03fe1bcfe0d3903fd8c0372", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fb41a42a9490e41b03fe1bcfe0d3903fd8c0372", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fb41a42a9490e41b03fe1bcfe0d3903fd8c0372"}], "stats": {"total": 2596, "additions": 1243, "deletions": 1353}, "files": [{"sha": "e692343c269d9f755d943d3078d5fc510da75ecc", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b251af97928db06c0a2174b230a3ae9f83745a04/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b251af97928db06c0a2174b230a3ae9f83745a04/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b251af97928db06c0a2174b230a3ae9f83745a04", "patch": "@@ -1,3 +1,9 @@\n+2007-01-08  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\t* interface.c, intrinsic.c, gfortranspec.c, io.c, f95-lang.c,\n+\tiresolve.c, match.c:  Update Copyright years.  Whitespace.\n+\n+\n 2007-01-08  Richard Guenther  <rguenther@suse.de>\n \n \t* trans-io.c (transfer_array_desc): Use build_int_cst instead"}, {"sha": "4532981e9dd071d4ea465aca9f6ca517d880e164", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b251af97928db06c0a2174b230a3ae9f83745a04/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b251af97928db06c0a2174b230a3ae9f83745a04/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=b251af97928db06c0a2174b230a3ae9f83745a04", "patch": "@@ -1,5 +1,5 @@\n /* gfortran backend interface\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook.\n \n@@ -238,7 +238,7 @@ gfc_expand_function (tree fndecl)\n \n   tree_rest_of_compilation (fndecl);\n }\n-\f\n+\n \n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR,\n    or validate its data type for an `if' or `while' statement or ?..: exp.\n@@ -267,8 +267,7 @@ gfc_truthvalue_conversion (tree expr)\n \t  return expr;\n \t}\n       else if (TREE_CODE (expr) == NOP_EXPR)\n-        return build1 (NOP_EXPR, boolean_type_node,\n-\t               TREE_OPERAND (expr, 0));\n+        return build1 (NOP_EXPR, boolean_type_node, TREE_OPERAND (expr, 0));\n       else\n         return build1 (NOP_EXPR, boolean_type_node, expr);\n \n@@ -284,6 +283,7 @@ gfc_truthvalue_conversion (tree expr)\n     }\n }\n \n+\n static void\n gfc_create_decls (void)\n {\n@@ -296,6 +296,7 @@ gfc_create_decls (void)\n   gfc_init_constants ();\n }\n \n+\n static void\n gfc_be_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n {\n@@ -314,7 +315,8 @@ gfc_be_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n   errorcount += errors;\n   warningcount += warnings;\n }\n-\f\n+\n+\n /* Initialize everything.  */\n \n static bool\n@@ -353,15 +355,16 @@ gfc_print_identifier (FILE * file ATTRIBUTE_UNUSED,\n {\n   return;\n }\n-\f\n+\n \n /* These functions and variables deal with binding contours.  We only\n    need these functions for the list of PARM_DECLs, but we leave the\n    functions more general; these are a simplified version of the\n    functions from GNAT.  */\n \n-/* For each binding contour we allocate a binding_level structure which records\n-   the entities defined or declared in that contour. Contours include:\n+/* For each binding contour we allocate a binding_level structure which\n+   records the entities defined or declared in that contour.  Contours\n+   include:\n \n         the global one\n         one for each subprogram definition\n@@ -394,7 +397,8 @@ static GTY(()) struct binding_level *global_binding_level;\n \n /* Binding level structures are initialized by copying this one.  */\n static struct binding_level clear_binding_level = { NULL, NULL, NULL };\n-\f\n+\n+\n /* Return nonzero if we are currently in the global binding level.  */\n \n int\n@@ -457,7 +461,7 @@ poplevel (int keep, int reverse, int functionbody)\n      reverse order except for PARM_DECL node, which are explicitly stored in\n      the right order.  */\n   decl_chain = (reverse) ? nreverse (current_binding_level->names)\n-    : current_binding_level->names;\n+\t\t\t : current_binding_level->names;\n \n   /* If there were any declarations in the current binding level, or if this\n      binding level is a function body, or if there are any nested blocks then\n@@ -515,7 +519,8 @@ poplevel (int keep, int reverse, int functionbody)\n \n   return block_node;\n }\n-\f\n+\n+\n /* Insert BLOCK at the end of the list of subblocks of the\n    current binding level.  This is used when a BIND_EXPR is expanded,\n    to handle the BLOCK node inside the BIND_EXPR.  */\n@@ -528,6 +533,7 @@ insert_block (tree block)\n     = chainon (current_binding_level->blocks, block);\n }\n \n+\n /* Records a ..._DECL node DECL as belonging to the current lexical scope.\n    Returns the ..._DECL node.  */\n \n@@ -625,13 +631,15 @@ gfc_init_decl_processing (void)\n   gfc_init_types ();\n }\n \n+\n /* Mark EXP saying that we need to be able to take the\n    address of it; it should not be allocated in a register.\n    In Fortran 95 this is only the case for variables with\n    the TARGET attribute, but we implement it here for a\n    likely future Cray pointer extension.\n    Value is 1 if successful.  */\n /* TODO: Check/fix mark_addressable.  */\n+\n bool\n gfc_mark_addressable (tree exp)\n {\n@@ -659,9 +667,8 @@ gfc_mark_addressable (tree exp)\n \t  {\n \t    if (TREE_PUBLIC (x))\n \t      {\n-\t\terror\n-\t\t  (\"global register variable %qs used in nested function\",\n-\t\t   IDENTIFIER_POINTER (DECL_NAME (x)));\n+\t\terror (\"global register variable %qs used in nested function\",\n+\t\t       IDENTIFIER_POINTER (DECL_NAME (x)));\n \t\treturn false;\n \t      }\n \t    pedwarn (\"register variable %qs used in nested function\",\n@@ -702,6 +709,7 @@ gfc_mark_addressable (tree exp)\n       }\n }\n \n+\n /* Return the typed-based alias set for T, which may be an expression\n    or a type.  Return -1 if we don't do anything special.  */\n \n@@ -720,6 +728,7 @@ gfc_get_alias_set (tree t)\n   return -1;\n }\n \n+\n /* press the big red button - garbage (ggc) collection is on */\n \n int ggc_p = 1;\n@@ -736,10 +745,10 @@ gfc_builtin_function (tree decl)\n \n \n static void\n-gfc_define_builtin (const char * name,\n+gfc_define_builtin (const char *name,\n \t\t    tree type,\n \t\t    int code,\n-\t\t    const char * library_name,\n+\t\t    const char *library_name,\n \t\t    bool const_p)\n {\n   tree decl;\n@@ -773,7 +782,7 @@ gfc_define_builtin (const char * name,\n /* Create function types for builtin functions.  */\n \n static void\n-build_builtin_fntypes (tree * fntype, tree type)\n+build_builtin_fntypes (tree *fntype, tree type)\n {\n   tree tmp;\n \n@@ -789,6 +798,7 @@ build_builtin_fntypes (tree * fntype, tree type)\n   fntype[2] = build_function_type (type, tmp);\n }\n \n+\n static tree\n builtin_type_for_size (int size, bool unsignedp)\n {"}, {"sha": "645e3b2d404a25c956d39b926738d74e0d28f9a5", "filename": "gcc/fortran/gfortranspec.c", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b251af97928db06c0a2174b230a3ae9f83745a04/gcc%2Ffortran%2Fgfortranspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b251af97928db06c0a2174b230a3ae9f83745a04/gcc%2Ffortran%2Fgfortranspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortranspec.c?ref=b251af97928db06c0a2174b230a3ae9f83745a04", "patch": "@@ -1,5 +1,5 @@\n /* Specific flags and argument handling of the Fortran front-end.\n-   Copyright (C) 1997, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Copyright (C) 1997, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -18,6 +18,7 @@ You should have received a copy of the GNU General Public License\n along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n Boston, MA 02110-1301, USA.  */\n+\n /* This file is copied more or less verbatim from g77.  */\n /* This file contains a filter for the main `gcc' driver, which is\n    replicated for the `gfortran' driver by adding this filter.  The purpose\n@@ -160,7 +161,7 @@ lookup_option (Option *xopt, int *xskip, const char **xarg, const char *text)\n     opt = OPTION_x, arg = text + 2;\n   else\n     {\n-      if ((skip = WORD_SWITCH_TAKES_ARG (text + 1)) != 0)\t/* See gcc.c.  */\n+      if ((skip = WORD_SWITCH_TAKES_ARG (text + 1)) != 0)  /* See gcc.c.  */\n \t;\n       else if (!strcmp (text, \"-fhelp\"))\t/* Really --help!! */\n \topt = OPTION_help;\n@@ -346,7 +347,7 @@ lang_specific_driver (int *in_argc, const char *const **in_argv,\n \tcase OPTION_version:\n \t  printf (\"GNU Fortran 95 (GCC) %s\\n\", version_string);\n \t  printf (\"Copyright %s 2006 Free Software Foundation, Inc.\\n\\n\",\n-\t          _(\"(C)\"));\n+\t\t  _(\"(C)\"));\n \t  printf (_(\"GNU Fortran comes with NO WARRANTY, to the extent permitted by law.\\n\\\n You may redistribute copies of GNU Fortran\\n\\\n under the terms of the GNU General Public License.\\n\\\n@@ -364,7 +365,7 @@ For more information about these matters, see the file named COPYING\\n\\n\"));\n \t}\n \n       /* This is the one place we check for missing arguments in the\n-         program.  */\n+\t program.  */\n \n       if (i + skip < argc)\n \ti += skip;\n@@ -392,25 +393,25 @@ For more information about these matters, see the file named COPYING\\n\\n\"));\n \t}\n \n       if ((argv[i][0] == '-') && (argv[i][1] == 'M'))\n-        {\n-          char *p;\n-\n-          if (argv[i][2] == '\\0')\n-            {\n-              p = XNEWVEC (char, strlen (argv[i + 1]) + 2);\n-              p[0] = '-';\n-              p[1] = 'J';\n-              strcpy (&p[2], argv[i + 1]);\n-              i++;\n-            }\n-          else\n-            {\n-              p = XNEWVEC (char, strlen (argv[i]) + 1);\n-              strcpy (p, argv[i]);\n-            }\n-          append_arg (p);\n-          continue;\n-        }\n+\t{\n+\t  char *p;\n+\n+\t  if (argv[i][2] == '\\0')\n+\t    {\n+\t      p = XNEWVEC (char, strlen (argv[i + 1]) + 2);\n+\t      p[0] = '-';\n+\t      p[1] = 'J';\n+\t      strcpy (&p[2], argv[i + 1]);\n+\t      i++;\n+\t    }\n+\t  else\n+\t    {\n+\t      p = XNEWVEC (char, strlen (argv[i]) + 1);\n+\t      strcpy (p, argv[i]);\n+\t    }\n+\t  append_arg (p);\n+\t  continue;\n+\t}\n \n       if ((argv[i][0] == '-') && (argv[i][1] != 'l'))\n \t{\n@@ -535,6 +536,7 @@ For more information about these matters, see the file named COPYING\\n\\n\"));\n   *in_argv = g77_newargv;\n }\n \n+\n /* Called before linking.  Returns 0 on success and -1 on failure.  */\n int\n lang_specific_pre_link (void)\t/* Not used for F77.  */"}, {"sha": "91674bffbb2b6cc914d909c6d0b0a54883db2ec0", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 114, "deletions": 144, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b251af97928db06c0a2174b230a3ae9f83745a04/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b251af97928db06c0a2174b230a3ae9f83745a04/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=b251af97928db06c0a2174b230a3ae9f83745a04", "patch": "@@ -1,6 +1,6 @@\n /* Deal with interfaces.\n-   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006 Free Software\n-   Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of GCC.\n@@ -70,7 +70,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"gfortran.h\"\n #include \"match.h\"\n \n-\n /* The current_interface structure holds information about the\n    interface currently being parsed.  This structure is saved and\n    restored during recursive interfaces.  */\n@@ -81,7 +80,7 @@ gfc_interface_info current_interface;\n /* Free a singly linked list of gfc_interface structures.  */\n \n void\n-gfc_free_interface (gfc_interface * intr)\n+gfc_free_interface (gfc_interface *intr)\n {\n   gfc_interface *next;\n \n@@ -99,7 +98,6 @@ gfc_free_interface (gfc_interface * intr)\n static gfc_intrinsic_op\n fold_unary (gfc_intrinsic_op operator)\n {\n-\n   switch (operator)\n     {\n     case INTRINSIC_UPLUS:\n@@ -121,7 +119,7 @@ fold_unary (gfc_intrinsic_op operator)\n    This subroutine doesn't return MATCH_NO.  */\n \n match\n-gfc_match_generic_spec (interface_type * type,\n+gfc_match_generic_spec (interface_type *type,\n \t\t\tchar *name,\n \t\t\tgfc_intrinsic_op *operator)\n {\n@@ -194,15 +192,13 @@ gfc_match_interface (void)\n   if (gfc_match_generic_spec (&type, name, &operator) == MATCH_ERROR)\n     return MATCH_ERROR;\n \n-\n   /* If we're not looking at the end of the statement now, or if this\n      is not a nameless interface but we did not see a space, punt.  */\n   if (gfc_match_eos () != MATCH_YES\n-      || (type != INTERFACE_NAMELESS\n-\t  && m != MATCH_YES))\n+      || (type != INTERFACE_NAMELESS && m != MATCH_YES))\n     {\n-      gfc_error\n-\t(\"Syntax error: Trailing garbage in INTERFACE statement at %C\");\n+      gfc_error (\"Syntax error: Trailing garbage in INTERFACE statement \"\n+\t\t \"at %C\");\n       return MATCH_ERROR;\n     }\n \n@@ -263,11 +259,10 @@ gfc_match_end_interface (void)\n   /* If we're not looking at the end of the statement now, or if this\n      is not a nameless interface but we did not see a space, punt.  */\n   if (gfc_match_eos () != MATCH_YES\n-      || (type != INTERFACE_NAMELESS\n-\t  && m != MATCH_YES))\n+      || (type != INTERFACE_NAMELESS && m != MATCH_YES))\n     {\n-      gfc_error\n-\t(\"Syntax error: Trailing garbage in END INTERFACE statement at %C\");\n+      gfc_error (\"Syntax error: Trailing garbage in END INTERFACE \"\n+\t\t \"statement at %C\");\n       return MATCH_ERROR;\n     }\n \n@@ -301,7 +296,7 @@ gfc_match_end_interface (void)\n \n     case INTERFACE_USER_OP:\n       /* Comparing the symbol node names is OK because only use-associated\n-         symbols can be renamed.  */\n+\t symbols can be renamed.  */\n       if (type != current_interface.type\n \t  || strcmp (current_interface.uop->name, name) != 0)\n \t{\n@@ -332,17 +327,17 @@ gfc_match_end_interface (void)\n    recursing through gfc_compare_types for the components.  */\n \n int\n-gfc_compare_derived_types (gfc_symbol * derived1, gfc_symbol * derived2)\n+gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)\n {\n   gfc_component *dt1, *dt2;\n \n   /* Special case for comparing derived types across namespaces.  If the\n      true names and module names are the same and the module name is\n      nonnull, then they are equal.  */\n   if (strcmp (derived1->name, derived2->name) == 0\n-\t&& derived1 != NULL && derived2 != NULL\n-\t&& derived1->module != NULL && derived2->module != NULL\n-\t&& strcmp (derived1->module, derived2->module) == 0)\n+      && derived1 != NULL && derived2 != NULL\n+      && derived1->module != NULL && derived2->module != NULL\n+      && strcmp (derived1->module, derived2->module) == 0)\n     return 1;\n \n   /* Compare type via the rules of the standard.  Both types must have\n@@ -352,7 +347,7 @@ gfc_compare_derived_types (gfc_symbol * derived1, gfc_symbol * derived2)\n     return 0;\n \n   if (derived1->component_access == ACCESS_PRIVATE\n-\t|| derived2->component_access == ACCESS_PRIVATE)\n+      || derived2->component_access == ACCESS_PRIVATE)\n     return 0;\n \n   if (derived1->attr.sequence == 0 || derived2->attr.sequence == 0)\n@@ -396,12 +391,12 @@ gfc_compare_derived_types (gfc_symbol * derived1, gfc_symbol * derived2)\n   return 1;\n }\n \n+\n /* Compare two typespecs, recursively if necessary.  */\n \n int\n-gfc_compare_types (gfc_typespec * ts1, gfc_typespec * ts2)\n+gfc_compare_types (gfc_typespec *ts1, gfc_typespec *ts2)\n {\n-\n   if (ts1->type != ts2->type)\n     return 0;\n   if (ts1->type != BT_DERIVED)\n@@ -420,7 +415,7 @@ gfc_compare_types (gfc_typespec * ts1, gfc_typespec * ts2)\n    zero otherwise.  */\n \n static int\n-compare_type_rank (gfc_symbol * s1, gfc_symbol * s2)\n+compare_type_rank (gfc_symbol *s1, gfc_symbol *s2)\n {\n   int r1, r2;\n \n@@ -441,7 +436,7 @@ static int compare_interfaces (gfc_symbol *, gfc_symbol *, int);\n    procedures.  Returns nonzero if the same, zero if different.  */\n \n static int\n-compare_type_rank_if (gfc_symbol * s1, gfc_symbol * s2)\n+compare_type_rank_if (gfc_symbol *s1, gfc_symbol *s2)\n {\n   if (s1 == NULL || s2 == NULL)\n     return s1 == s2 ? 1 : 0;\n@@ -475,9 +470,8 @@ compare_type_rank_if (gfc_symbol * s1, gfc_symbol * s2)\n    if not found.  */\n \n static gfc_symbol *\n-find_keyword_arg (const char *name, gfc_formal_arglist * f)\n+find_keyword_arg (const char *name, gfc_formal_arglist *f)\n {\n-\n   for (; f; f = f->next)\n     if (strcmp (f->sym->name, name) == 0)\n       return f->sym;\n@@ -493,7 +487,7 @@ find_keyword_arg (const char *name, gfc_formal_arglist * f)\n    interfaces for that operator are legal.  */\n \n static void\n-check_operator_interface (gfc_interface * intr, gfc_intrinsic_op operator)\n+check_operator_interface (gfc_interface *intr, gfc_intrinsic_op operator)\n {\n   gfc_formal_arglist *formal;\n   sym_intent i1, i2;\n@@ -539,27 +533,24 @@ check_operator_interface (gfc_interface * intr, gfc_intrinsic_op operator)\n     {\n       if (!sym->attr.subroutine)\n \t{\n-\t  gfc_error\n-\t    (\"Assignment operator interface at %L must be a SUBROUTINE\",\n-\t     &intr->where);\n+\t  gfc_error (\"Assignment operator interface at %L must be \"\n+\t\t     \"a SUBROUTINE\", &intr->where);\n \t  return;\n \t}\n       if (args != 2)\n \t{\n-\t  gfc_error\n-\t    (\"Assignment operator interface at %L must have two arguments\",\n-\t     &intr->where);\n+\t  gfc_error (\"Assignment operator interface at %L must have \"\n+\t\t     \"two arguments\", &intr->where);\n \t  return;\n \t}\n       if (sym->formal->sym->ts.type != BT_DERIVED\n-\t    && sym->formal->next->sym->ts.type != BT_DERIVED\n-\t    && (sym->formal->sym->ts.type == sym->formal->next->sym->ts.type\n-\t\t  || (gfc_numeric_ts (&sym->formal->sym->ts)\n-\t\t\t&& gfc_numeric_ts (&sym->formal->next->sym->ts))))\n+\t  && sym->formal->next->sym->ts.type != BT_DERIVED\n+\t  && (sym->formal->sym->ts.type == sym->formal->next->sym->ts.type\n+\t      || (gfc_numeric_ts (&sym->formal->sym->ts)\n+\t\t  && gfc_numeric_ts (&sym->formal->next->sym->ts))))\n \t{\n-\t  gfc_error\n-\t    (\"Assignment operator interface at %L must not redefine \"\n-\t     \"an INTRINSIC type assignment\", &intr->where);\n+\t  gfc_error (\"Assignment operator interface at %L must not redefine \"\n+\t\t     \"an INTRINSIC type assignment\", &intr->where);\n \t  return;\n \t}\n     }\n@@ -578,9 +569,7 @@ check_operator_interface (gfc_interface * intr, gfc_intrinsic_op operator)\n     case INTRINSIC_PLUS:\t/* Numeric unary or binary */\n     case INTRINSIC_MINUS:\n       if ((args == 1)\n-\t  && (t1 == BT_INTEGER\n-\t      || t1 == BT_REAL\n-\t      || t1 == BT_COMPLEX))\n+\t  && (t1 == BT_INTEGER || t1 == BT_REAL || t1 == BT_COMPLEX))\n \tgoto bad_repl;\n \n       if ((args == 2)\n@@ -696,7 +685,7 @@ check_operator_interface (gfc_interface * intr, gfc_intrinsic_op operator)\n    14.1.2.3.  */\n \n static int\n-count_types_test (gfc_formal_arglist * f1, gfc_formal_arglist * f2)\n+count_types_test (gfc_formal_arglist *f1, gfc_formal_arglist *f2)\n {\n   int rc, ac1, ac2, i, j, k, n1;\n   gfc_formal_arglist *f;\n@@ -762,7 +751,7 @@ count_types_test (gfc_formal_arglist * f1, gfc_formal_arglist * f2)\n \t  ac1++;\n \n       /* Count the number of arguments in f2 with that type, including\n-         those that are optional.  */\n+\t those that are optional.  */\n       ac2 = 0;\n \n       for (f = f2; f; f = f->next)\n@@ -794,7 +783,7 @@ count_types_test (gfc_formal_arglist * f1, gfc_formal_arglist * f2)\n    which is what happens here.  */\n \n static int\n-operator_correspondence (gfc_formal_arglist * f1, gfc_formal_arglist * f2)\n+operator_correspondence (gfc_formal_arglist *f1, gfc_formal_arglist *f2)\n {\n   for (;;)\n     {\n@@ -824,20 +813,19 @@ operator_correspondence (gfc_formal_arglist * f1, gfc_formal_arglist * f2)\n \n    INTERFACE FOO\n        SUBROUTINE F1(A, B)\n-           INTEGER :: A ; REAL :: B\n+\t   INTEGER :: A ; REAL :: B\n        END SUBROUTINE F1\n \n        SUBROUTINE F2(B, A)\n-           INTEGER :: A ; REAL :: B\n+\t   INTEGER :: A ; REAL :: B\n        END SUBROUTINE F1\n    END INTERFACE FOO\n \n    At this point, 'CALL FOO(A=1, B=1.0)' is ambiguous.  */\n \n static int\n-generic_correspondence (gfc_formal_arglist * f1, gfc_formal_arglist * f2)\n+generic_correspondence (gfc_formal_arglist *f1, gfc_formal_arglist *f2)\n {\n-\n   gfc_formal_arglist *f2_save, *g;\n   gfc_symbol *sym;\n \n@@ -852,7 +840,7 @@ generic_correspondence (gfc_formal_arglist * f1, gfc_formal_arglist * f2)\n \tgoto next;\n \n       /* Now search for a disambiguating keyword argument starting at\n-         the current non-match.  */\n+\t the current non-match.  */\n       for (g = f1; g; g = g->next)\n \t{\n \t  if (g->sym->attr.optional)\n@@ -878,7 +866,7 @@ generic_correspondence (gfc_formal_arglist * f1, gfc_formal_arglist * f2)\n    would be ambiguous between the two interfaces, zero otherwise.  */\n \n static int\n-compare_interfaces (gfc_symbol * s1, gfc_symbol * s2, int generic_flag)\n+compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, int generic_flag)\n {\n   gfc_formal_arglist *f1, *f2;\n \n@@ -919,7 +907,7 @@ compare_interfaces (gfc_symbol * s1, gfc_symbol * s2, int generic_flag)\n    subroutines.  Returns nonzero if something goes wrong.  */\n \n static int\n-check_interface0 (gfc_interface * p, const char *interface_name)\n+check_interface0 (gfc_interface *p, const char *interface_name)\n {\n   gfc_interface *psave, *q, *qlast;\n \n@@ -947,7 +935,6 @@ check_interface0 (gfc_interface * p, const char *interface_name)\n \t    {\n \t      qlast = q;\n \t      q = q->next;\n-\n \t    }\n \t  else\n \t    {\n@@ -968,11 +955,11 @@ check_interface0 (gfc_interface * p, const char *interface_name)\n    here.  */\n \n static int\n-check_interface1 (gfc_interface * p, gfc_interface * q0,\n+check_interface1 (gfc_interface *p, gfc_interface *q0,\n \t\t  int generic_flag, const char *interface_name,\n \t\t  bool referenced)\n {\n-  gfc_interface * q;\n+  gfc_interface *q;\n   for (; p; p = p->next)\n     for (q = q0; q; q = q->next)\n       {\n@@ -1007,7 +994,7 @@ check_interface1 (gfc_interface * p, gfc_interface * q0,\n    after all of the symbols are actually loaded.  */\n \n static void\n-check_sym_interfaces (gfc_symbol * sym)\n+check_sym_interfaces (gfc_symbol *sym)\n {\n   char interface_name[100];\n   bool k;\n@@ -1024,9 +1011,8 @@ check_sym_interfaces (gfc_symbol * sym)\n \n       for (p = sym->generic; p; p = p->next)\n \t{\n-\t  if (!p->sym->attr.use_assoc\n-\t\t&& p->sym->attr.mod_proc\n-\t\t&& p->sym->attr.if_source != IFSRC_DECL)\n+\t  if (!p->sym->attr.use_assoc && p->sym->attr.mod_proc\n+\t      && p->sym->attr.if_source != IFSRC_DECL)\n \t    {\n \t      gfc_error (\"MODULE PROCEDURE '%s' at %L does not come \"\n \t\t\t \"from a module\", p->sym->name, &p->where);\n@@ -1038,15 +1024,14 @@ check_sym_interfaces (gfc_symbol * sym)\n \t this is incorrect since host associated symbols, from any\n \t source, cannot be ambiguous with local symbols.  */\n       k = sym->attr.referenced || !sym->attr.use_assoc;\n-      if (check_interface1 (sym->generic, sym->generic, 1,\n-\t\t\t    interface_name, k))\n+      if (check_interface1 (sym->generic, sym->generic, 1, interface_name, k))\n \tsym->attr.ambiguous_interfaces = 1;\n     }\n }\n \n \n static void\n-check_uop_interfaces (gfc_user_op * uop)\n+check_uop_interfaces (gfc_user_op *uop)\n {\n   char interface_name[100];\n   gfc_user_op *uop2;\n@@ -1074,7 +1059,7 @@ check_uop_interfaces (gfc_user_op * uop)\n    that most symbols will not have generic or operator interfaces.  */\n \n void\n-gfc_check_interfaces (gfc_namespace * ns)\n+gfc_check_interfaces (gfc_namespace *ns)\n {\n   gfc_namespace *old_ns, *ns2;\n   char interface_name[100];\n@@ -1114,9 +1099,8 @@ gfc_check_interfaces (gfc_namespace * ns)\n \n \n static int\n-symbol_rank (gfc_symbol * sym)\n+symbol_rank (gfc_symbol *sym)\n {\n-\n   return (sym->as == NULL) ? 0 : sym->as->rank;\n }\n \n@@ -1126,7 +1110,7 @@ symbol_rank (gfc_symbol * sym)\n    allocatable. Returns nonzero if compatible, zero if not compatible.  */\n \n static int\n-compare_allocatable (gfc_symbol * formal, gfc_expr * actual)\n+compare_allocatable (gfc_symbol *formal, gfc_expr *actual)\n {\n   symbol_attribute attr;\n \n@@ -1146,7 +1130,7 @@ compare_allocatable (gfc_symbol * formal, gfc_expr * actual)\n    pointer. Returns nonzero if compatible, zero if not compatible.  */\n \n static int\n-compare_pointer (gfc_symbol * formal, gfc_expr * actual)\n+compare_pointer (gfc_symbol *formal, gfc_expr *actual)\n {\n   symbol_attribute attr;\n \n@@ -1166,7 +1150,7 @@ compare_pointer (gfc_symbol * formal, gfc_expr * actual)\n    compatible, zero if not compatible.  */\n \n static int\n-compare_parameter (gfc_symbol * formal, gfc_expr * actual,\n+compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t\t   int ranks_must_agree, int is_elemental)\n {\n   gfc_ref *ref;\n@@ -1181,7 +1165,7 @@ compare_parameter (gfc_symbol * formal, gfc_expr * actual,\n \treturn 0;\n \n       if (formal->attr.if_source == IFSRC_UNKNOWN\n-\t    || actual->symtree->n.sym->attr.external)\n+\t  || actual->symtree->n.sym->attr.external)\n \treturn 1;\t\t/* Assume match */\n \n       return compare_interfaces (formal, actual->symtree->n.sym, 0);\n@@ -1226,7 +1210,7 @@ compare_parameter (gfc_symbol * formal, gfc_expr * actual,\n    compatible, zero if not compatible.  */\n \n static int\n-compare_parameter_protected (gfc_symbol * formal, gfc_expr * actual)\n+compare_parameter_protected (gfc_symbol *formal, gfc_expr *actual)\n {\n   if (actual->expr_type != EXPR_VARIABLE)\n     return 1;\n@@ -1259,9 +1243,8 @@ compare_parameter_protected (gfc_symbol * formal, gfc_expr * actual)\n    code.  */\n \n static int\n-compare_actual_formal (gfc_actual_arglist ** ap,\n-\t\t       gfc_formal_arglist * formal,\n-\t\t       int ranks_must_agree, int is_elemental, locus * where)\n+compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n+\t\t       int ranks_must_agree, int is_elemental, locus *where)\n {\n   gfc_actual_arglist **new, *a, *actual, temp;\n   gfc_formal_arglist *f;\n@@ -1303,28 +1286,26 @@ compare_actual_formal (gfc_actual_arglist ** ap,\n \t  if (f == NULL)\n \t    {\n \t      if (where)\n-\t\tgfc_error\n-\t\t  (\"Keyword argument '%s' at %L is not in the procedure\",\n-\t\t   a->name, &a->expr->where);\n+\t\tgfc_error (\"Keyword argument '%s' at %L is not in \"\n+\t\t\t   \"the procedure\", a->name, &a->expr->where);\n \t      return 0;\n \t    }\n \n \t  if (new[i] != NULL)\n \t    {\n \t      if (where)\n-\t\tgfc_error\n-\t\t  (\"Keyword argument '%s' at %L is already associated \"\n-\t\t   \"with another actual argument\", a->name, &a->expr->where);\n+\t\tgfc_error (\"Keyword argument '%s' at %L is already associated \"\n+\t\t\t   \"with another actual argument\", a->name,\n+\t\t\t   &a->expr->where);\n \t      return 0;\n \t    }\n \t}\n \n       if (f == NULL)\n \t{\n \t  if (where)\n-\t    gfc_error\n-\t      (\"More actual than formal arguments in procedure call at %L\",\n-\t       where);\n+\t    gfc_error (\"More actual than formal arguments in procedure \"\n+\t\t       \"call at %L\", where);\n \n \t  return 0;\n \t}\n@@ -1335,29 +1316,25 @@ compare_actual_formal (gfc_actual_arglist ** ap,\n       if (f->sym == NULL)\n \t{\n \t  if (where)\n-\t    gfc_error\n-\t      (\"Missing alternate return spec in subroutine call at %L\",\n-\t       where);\n+\t    gfc_error (\"Missing alternate return spec in subroutine call \"\n+\t\t       \"at %L\", where);\n \t  return 0;\n \t}\n \n       if (a->expr == NULL)\n \t{\n \t  if (where)\n-\t    gfc_error\n-\t      (\"Unexpected alternate return spec in subroutine call at %L\",\n-\t       where);\n+\t    gfc_error (\"Unexpected alternate return spec in subroutine \"\n+\t\t       \"call at %L\", where);\n \t  return 0;\n \t}\n \n-      rank_check = where != NULL\n-\t\t     && !is_elemental\n-\t\t     && f->sym->as\n-\t\t     && (f->sym->as->type == AS_ASSUMED_SHAPE\n-\t\t\t   || f->sym->as->type == AS_DEFERRED);\n+      rank_check = where != NULL && !is_elemental && f->sym->as\n+\t\t   && (f->sym->as->type == AS_ASSUMED_SHAPE\n+\t\t       || f->sym->as->type == AS_DEFERRED);\n \n-      if (!compare_parameter\n-\t  (f->sym, a->expr, ranks_must_agree || rank_check, is_elemental))\n+      if (!compare_parameter (f->sym, a->expr,\n+\t\t\t      ranks_must_agree || rank_check, is_elemental))\n \t{\n \t  if (where)\n \t    gfc_error (\"Type/rank mismatch in argument '%s' at %L\",\n@@ -1377,19 +1354,17 @@ compare_actual_formal (gfc_actual_arglist ** ap,\n \t  return 0;\n \t}\n \n-      if (f->sym->attr.flavor == FL_PROCEDURE\n-\t    && f->sym->attr.pure\n-\t    && a->expr->ts.type == BT_PROCEDURE\n-\t    && !a->expr->symtree->n.sym->attr.pure)\n+      if (f->sym->attr.flavor == FL_PROCEDURE && f->sym->attr.pure\n+\t  && a->expr->ts.type == BT_PROCEDURE\n+\t  && !a->expr->symtree->n.sym->attr.pure)\n \t{\n \t  if (where)\n \t    gfc_error (\"Expected a PURE procedure for argument '%s' at %L\",\n \t\t       f->sym->name, &a->expr->where);\n \t  return 0;\n \t}\n \n-      if (f->sym->as\n-\t  && f->sym->as->type == AS_ASSUMED_SHAPE\n+      if (f->sym->as && f->sym->as->type == AS_ASSUMED_SHAPE\n \t  && a->expr->expr_type == EXPR_VARIABLE\n \t  && a->expr->symtree->n.sym->as\n \t  && a->expr->symtree->n.sym->as->type == AS_ASSUMED_SIZE\n@@ -1423,14 +1398,14 @@ compare_actual_formal (gfc_actual_arglist ** ap,\n \n       /* Check intent = OUT/INOUT for definable actual argument.  */\n       if (a->expr->expr_type != EXPR_VARIABLE\n-\t     && (f->sym->attr.intent == INTENT_OUT\n-\t\t   || f->sym->attr.intent == INTENT_INOUT))\n+\t  && (f->sym->attr.intent == INTENT_OUT\n+\t      || f->sym->attr.intent == INTENT_INOUT))\n \t{\n \t  if (where)\n \t    gfc_error (\"Actual argument at %L must be definable to \"\n \t\t       \"match dummy INTENT = OUT/INOUT\", &a->expr->where);\n-          return 0;\n-        }\n+\t  return 0;\n+\t}\n \n       if (!compare_parameter_protected(f->sym, a->expr))\n \t{\n@@ -1439,7 +1414,7 @@ compare_actual_formal (gfc_actual_arglist ** ap,\n \t\t       \"PROTECTED attribute and dummy argument '%s' is \"\n \t\t       \"INTENT = OUT/INOUT\",\n \t\t       &a->expr->where,f->sym->name);\n-          return 0;\n+\t  return 0;\n \t}\n \n     match:\n@@ -1458,8 +1433,8 @@ compare_actual_formal (gfc_actual_arglist ** ap,\n       if (f->sym == NULL)\n \t{\n \t  if (where)\n-\t    gfc_error (\"Missing alternate return spec in subroutine call at %L\",\n-\t\t       where);\n+\t    gfc_error (\"Missing alternate return spec in subroutine call \"\n+\t\t       \"at %L\", where);\n \t  return 0;\n \t}\n       if (!f->sym->attr.optional)\n@@ -1552,7 +1527,7 @@ pair_cmp (const void *p1, const void *p2)\n    Returning FAILURE will produce no warning.  */\n \n static try\n-compare_actual_expr (gfc_expr * e1, gfc_expr * e2)\n+compare_actual_expr (gfc_expr *e1, gfc_expr *e2)\n {\n   const gfc_ref *r1, *r2;\n \n@@ -1595,12 +1570,13 @@ compare_actual_expr (gfc_expr * e1, gfc_expr * e2)\n   return FAILURE;\n }\n \n+\n /* Given formal and actual argument lists that correspond to one\n    another, check that identical actual arguments aren't not\n    associated with some incompatible INTENTs.  */\n \n static try\n-check_some_aliasing (gfc_formal_arglist * f, gfc_actual_arglist * a)\n+check_some_aliasing (gfc_formal_arglist *f, gfc_actual_arglist *a)\n {\n   sym_intent f1_intent, f2_intent;\n   gfc_formal_arglist *f1;\n@@ -1668,17 +1644,15 @@ check_some_aliasing (gfc_formal_arglist * f, gfc_actual_arglist * a)\n    return non-zero if their intents are compatible, zero otherwise.  */\n \n static int\n-compare_parameter_intent (gfc_symbol * formal, gfc_expr * actual)\n+compare_parameter_intent (gfc_symbol *formal, gfc_expr *actual)\n {\n-  if (actual->symtree->n.sym->attr.pointer\n-      && !formal->attr.pointer)\n+  if (actual->symtree->n.sym->attr.pointer && !formal->attr.pointer)\n     return 1;\n \n   if (actual->symtree->n.sym->attr.intent != INTENT_IN)\n     return 1;\n \n-  if (formal->attr.intent == INTENT_INOUT\n-      || formal->attr.intent == INTENT_OUT)\n+  if (formal->attr.intent == INTENT_INOUT || formal->attr.intent == INTENT_OUT)\n     return 0;\n \n   return 1;\n@@ -1690,7 +1664,7 @@ compare_parameter_intent (gfc_symbol * formal, gfc_expr * actual)\n    are not mismatched.  */\n \n static try\n-check_intents (gfc_formal_arglist * f, gfc_actual_arglist * a)\n+check_intents (gfc_formal_arglist *f, gfc_actual_arglist *a)\n {\n   sym_intent f_intent;\n \n@@ -1708,7 +1682,6 @@ check_intents (gfc_formal_arglist * f, gfc_actual_arglist * a)\n \n       if (!compare_parameter_intent(f->sym, a->expr))\n \t{\n-\n \t  gfc_error (\"Procedure argument at %L is INTENT(IN) while interface \"\n \t\t     \"specifies INTENT(%s)\", &a->expr->where,\n \t\t     gfc_intent_string (f_intent));\n@@ -1719,18 +1692,17 @@ check_intents (gfc_formal_arglist * f, gfc_actual_arglist * a)\n \t{\n \t  if (f_intent == INTENT_INOUT || f_intent == INTENT_OUT)\n \t    {\n-\t      gfc_error\n-\t\t(\"Procedure argument at %L is local to a PURE procedure and \"\n-\t\t \"is passed to an INTENT(%s) argument\", &a->expr->where,\n-\t\t gfc_intent_string (f_intent));\n+\t      gfc_error (\"Procedure argument at %L is local to a PURE \"\n+\t\t\t \"procedure and is passed to an INTENT(%s) argument\",\n+\t\t\t &a->expr->where, gfc_intent_string (f_intent));\n \t      return FAILURE;\n \t    }\n \n \t  if (a->expr->symtree->n.sym->attr.pointer)\n \t    {\n-\t      gfc_error\n-\t\t(\"Procedure argument at %L is local to a PURE procedure and \"\n-\t\t \"has the POINTER attribute\", &a->expr->where);\n+\t      gfc_error (\"Procedure argument at %L is local to a PURE \"\n+\t\t\t \"procedure and has the POINTER attribute\",\n+\t\t\t &a->expr->where);\n \t      return FAILURE;\n \t    }\n \t}\n@@ -1745,14 +1717,14 @@ check_intents (gfc_formal_arglist * f, gfc_actual_arglist * a)\n    sorted.  */\n \n void\n-gfc_procedure_use (gfc_symbol * sym, gfc_actual_arglist ** ap, locus * where)\n+gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n {\n \n   /* Warn about calls with an implicit interface.  */\n   if (gfc_option.warn_implicit_interface\n       && sym->attr.if_source == IFSRC_UNKNOWN)\n     gfc_warning (\"Procedure '%s' called with an implicit interface at %L\",\n-                 sym->name, where);\n+\t\t sym->name, where);\n \n   if (sym->attr.if_source == IFSRC_UNKNOWN\n       || !compare_actual_formal (ap, sym->formal, 0,\n@@ -1771,8 +1743,8 @@ gfc_procedure_use (gfc_symbol * sym, gfc_actual_arglist ** ap, locus * where)\n    not found.  */\n \n gfc_symbol *\n-gfc_search_interface (gfc_interface * intr, int sub_flag,\n-\t\t      gfc_actual_arglist ** ap)\n+gfc_search_interface (gfc_interface *intr, int sub_flag,\n+\t\t      gfc_actual_arglist **ap)\n {\n   int r;\n \n@@ -1801,7 +1773,7 @@ gfc_search_interface (gfc_interface * intr, int sub_flag,\n /* Do a brute force recursive search for a symbol.  */\n \n static gfc_symtree *\n-find_symtree0 (gfc_symtree * root, gfc_symbol * sym)\n+find_symtree0 (gfc_symtree *root, gfc_symbol *sym)\n {\n   gfc_symtree * st;\n \n@@ -1820,7 +1792,7 @@ find_symtree0 (gfc_symtree * root, gfc_symbol * sym)\n /* Find a symtree for a symbol.  */\n \n static gfc_symtree *\n-find_sym_in_symtree (gfc_symbol * sym)\n+find_sym_in_symtree (gfc_symbol *sym)\n {\n   gfc_symtree *st;\n   gfc_namespace *ns;\n@@ -1837,7 +1809,7 @@ find_sym_in_symtree (gfc_symbol * sym)\n     {\n       st = find_symtree0 (ns->sym_root, sym);\n       if (st)\n-        return st;\n+\treturn st;\n     }\n   gfc_internal_error (\"Unable to find symbol %s\", sym->name);\n   /* Not reached */\n@@ -1853,7 +1825,7 @@ find_sym_in_symtree (gfc_symbol * sym)\n    the appropriate function call.  */\n \n try\n-gfc_extend_expr (gfc_expr * e)\n+gfc_extend_expr (gfc_expr *e)\n {\n   gfc_actual_arglist *actual;\n   gfc_symbol *sym;\n@@ -1917,9 +1889,8 @@ gfc_extend_expr (gfc_expr * e)\n \n   if (gfc_pure (NULL) && !gfc_pure (sym))\n     {\n-      gfc_error\n-\t(\"Function '%s' called in lieu of an operator at %L must be PURE\",\n-\t sym->name, &e->where);\n+      gfc_error (\"Function '%s' called in lieu of an operator at %L must \"\n+\t\t \"be PURE\", sym->name, &e->where);\n       return FAILURE;\n     }\n \n@@ -1936,7 +1907,7 @@ gfc_extend_expr (gfc_expr * e)\n    generated.  */\n \n try\n-gfc_extend_assign (gfc_code * c, gfc_namespace * ns)\n+gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n {\n   gfc_actual_arglist *actual;\n   gfc_expr *lhs, *rhs;\n@@ -1948,8 +1919,7 @@ gfc_extend_assign (gfc_code * c, gfc_namespace * ns)\n   /* Don't allow an intrinsic assignment to be replaced.  */\n   if (lhs->ts.type != BT_DERIVED && rhs->ts.type != BT_DERIVED\n       && (lhs->ts.type == rhs->ts.type\n-          || (gfc_numeric_ts (&lhs->ts)\n-\t      && gfc_numeric_ts (&rhs->ts))))\n+\t  || (gfc_numeric_ts (&lhs->ts) && gfc_numeric_ts (&rhs->ts))))\n     return FAILURE;\n \n   actual = gfc_get_actual_arglist ();\n@@ -2011,7 +1981,7 @@ check_new_interface (gfc_interface * base, gfc_symbol * new)\n /* Add a symbol to the current interface.  */\n \n try\n-gfc_add_interface (gfc_symbol * new)\n+gfc_add_interface (gfc_symbol *new)\n {\n   gfc_interface **head, *intr;\n   gfc_namespace *ns;\n@@ -2046,8 +2016,8 @@ gfc_add_interface (gfc_symbol * new)\n       break;\n \n     case INTERFACE_USER_OP:\n-      if (check_new_interface (current_interface.uop->operator, new) ==\n-\t  FAILURE)\n+      if (check_new_interface (current_interface.uop->operator, new)\n+\t  == FAILURE)\n \treturn FAILURE;\n \n       head = &current_interface.uop->operator;\n@@ -2072,7 +2042,7 @@ gfc_add_interface (gfc_symbol * new)\n    Symbols are freed when a namespace is freed.  */\n \n void\n-gfc_free_formal_arglist (gfc_formal_arglist * p)\n+gfc_free_formal_arglist (gfc_formal_arglist *p)\n {\n   gfc_formal_arglist *q;\n "}, {"sha": "d3692c9d19e335a3b5ff9eb656504e7e9924847c", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 204, "deletions": 215, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b251af97928db06c0a2174b230a3ae9f83745a04/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b251af97928db06c0a2174b230a3ae9f83745a04/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=b251af97928db06c0a2174b230a3ae9f83745a04", "patch": "@@ -1,6 +1,6 @@\n /* Build up a list of intrinsic subroutines and functions for the\n    name-resolution stage.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught & Katherine Holcomb\n \n@@ -21,14 +21,12 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"flags.h\"\n #include \"gfortran.h\"\n #include \"intrinsic.h\"\n \n-\n /* Namespace to hold the resolved symbols for intrinsic subroutines.  */\n static gfc_namespace *gfc_intrinsic_namespace;\n \n@@ -59,6 +57,7 @@ sizing;\n #define REQUIRED\t0\n #define OPTIONAL\t1\n \n+\n /* Return a letter based on the passed type.  Used to construct the\n    name of a type-dependent subroutine.  */\n \n@@ -101,7 +100,7 @@ gfc_type_letter (bt type)\n /* Get a symbol for a resolved name.  */\n \n gfc_symbol *\n-gfc_get_intrinsic_sub_symbol (const char * name)\n+gfc_get_intrinsic_sub_symbol (const char *name)\n {\n   gfc_symbol *sym;\n \n@@ -119,7 +118,7 @@ gfc_get_intrinsic_sub_symbol (const char * name)\n    typespecs.  */\n \n static const char *\n-conv_name (gfc_typespec * from, gfc_typespec * to)\n+conv_name (gfc_typespec *from, gfc_typespec *to)\n {\n   static char name[30];\n \n@@ -135,7 +134,7 @@ conv_name (gfc_typespec * from, gfc_typespec * to)\n    isn't found.  */\n \n static gfc_intrinsic_sym *\n-find_conv (gfc_typespec * from, gfc_typespec * to)\n+find_conv (gfc_typespec *from, gfc_typespec *to)\n {\n   gfc_intrinsic_sym *sym;\n   const char *target;\n@@ -157,7 +156,7 @@ find_conv (gfc_typespec * from, gfc_typespec * to)\n    function to manipulate the argument list.  */\n \n static try\n-do_check (gfc_intrinsic_sym * specific, gfc_actual_arglist * arg)\n+do_check (gfc_intrinsic_sym *specific, gfc_actual_arglist *arg)\n {\n   gfc_expr *a1, *a2, *a3, *a4, *a5;\n \n@@ -199,18 +198,18 @@ do_check (gfc_intrinsic_sym * specific, gfc_actual_arglist * arg)\n \n    Argument list:\n       char *     name of function\n-      int        whether function is elemental\n-      int        If the function can be used as an actual argument [1]\n-      bt         return type of function\n-      int        kind of return type of function\n-      int        Fortran standard version\n+      int\twhether function is elemental\n+      int\tIf the function can be used as an actual argument [1]\n+      bt\t return type of function\n+      int\tkind of return type of function\n+      int\tFortran standard version\n       check      pointer to check function\n       simplify   pointer to simplification function\n       resolve    pointer to resolution function\n \n    Optional arguments come in multiples of four:\n       char *    name of argument\n-      bt        type of argument\n+      bt\ttype of argument\n       int       kind of argument\n       int       arg optional flag (1=optional, 0=required)\n \n@@ -316,10 +315,10 @@ add_sym (const char *name, int elemental, int actual_ok, bt type, int kind,\n \n static void\n add_sym_0 (const char *name, int elemental, int actual_ok, bt type,\n-\t\t       int kind, int standard,\n-\t\t       try (*check)(void),\n-\t\t       gfc_expr *(*simplify)(void),\n-\t   void (*resolve)(gfc_expr *))\n+\t   int kind, int standard,\n+\t   try (*check) (void),\n+\t   gfc_expr *(*simplify) (void),\n+\t   void (*resolve) (gfc_expr *))\n {\n   gfc_simplify_f sf;\n   gfc_check_f cf;\n@@ -330,16 +329,15 @@ add_sym_0 (const char *name, int elemental, int actual_ok, bt type,\n   rf.f0 = resolve;\n \n   add_sym (name, elemental, actual_ok, type, kind, standard, cf, sf, rf,\n-\t   (void*)0);\n+\t   (void *) 0);\n }\n \n \n /* Add a symbol to the subroutine list where the subroutine takes\n    0 arguments.  */\n \n static void\n-add_sym_0s (const char * name, int standard,\n-\t    void (*resolve)(gfc_code *))\n+add_sym_0s (const char *name, int standard, void (*resolve) (gfc_code *))\n {\n   gfc_check_f cf;\n   gfc_simplify_f sf;\n@@ -350,7 +348,7 @@ add_sym_0s (const char * name, int standard,\n   rf.s1 = resolve;\n \n   add_sym (name, ELEMENTAL, ACTUAL_NO, BT_UNKNOWN, 0, standard, cf, sf, rf,\n-\t   (void*)0);\n+\t   (void *) 0);\n }\n \n \n@@ -360,10 +358,10 @@ add_sym_0s (const char * name, int standard,\n static void\n add_sym_1 (const char *name, int elemental, int actual_ok, bt type,\n \t   int kind, int standard,\n-\t   try (*check)(gfc_expr *),\n-\t   gfc_expr *(*simplify)(gfc_expr *),\n-\t   void (*resolve)(gfc_expr *,gfc_expr *),\n-\t   const char* a1, bt type1, int kind1, int optional1)\n+\t   try (*check) (gfc_expr *),\n+\t   gfc_expr *(*simplify) (gfc_expr *),\n+\t   void (*resolve) (gfc_expr *, gfc_expr *),\n+\t   const char *a1, bt type1, int kind1, int optional1)\n {\n   gfc_check_f cf;\n   gfc_simplify_f sf;\n@@ -375,20 +373,19 @@ add_sym_1 (const char *name, int elemental, int actual_ok, bt type,\n \n   add_sym (name, elemental, actual_ok, type, kind, standard, cf, sf, rf,\n \t   a1, type1, kind1, optional1,\n-\t   (void*)0);\n+\t   (void *) 0);\n }\n \n \n /* Add a symbol to the subroutine list where the subroutine takes\n    1 arguments.  */\n \n static void\n-add_sym_1s (const char *name, int elemental, bt type,\n-\t\t\tint kind, int standard,\n-\t\t\ttry (*check)(gfc_expr *),\n-\t\t\tgfc_expr *(*simplify)(gfc_expr *),\n-\t\t\tvoid (*resolve)(gfc_code *),\n-\t    const char* a1, bt type1, int kind1, int optional1)\n+add_sym_1s (const char *name, int elemental, bt type, int kind, int standard,\n+\t    try (*check) (gfc_expr *),\n+\t    gfc_expr *(*simplify) (gfc_expr *),\n+\t    void (*resolve) (gfc_code *),\n+\t    const char *a1, bt type1, int kind1, int optional1)\n {\n   gfc_check_f cf;\n   gfc_simplify_f sf;\n@@ -400,7 +397,7 @@ add_sym_1s (const char *name, int elemental, bt type,\n \n   add_sym (name, elemental, ACTUAL_NO, type, kind, standard, cf, sf, rf,\n \t   a1, type1, kind1, optional1,\n-\t   (void*)0);\n+\t   (void *) 0);\n }\n \n \n@@ -409,12 +406,12 @@ add_sym_1s (const char *name, int elemental, bt type,\n \n static void\n add_sym_1m (const char *name, int elemental, int actual_ok, bt type,\n-\t\t\tint kind, int standard,\n-\t\t\ttry (*check)(gfc_actual_arglist *),\n-\t\t\tgfc_expr *(*simplify)(gfc_expr *),\n-\t\t\tvoid (*resolve)(gfc_expr *,gfc_actual_arglist *),\n-\t\t\tconst char* a1, bt type1, int kind1, int optional1,\n-\t    const char* a2, bt type2, int kind2, int optional2)\n+\t    int kind, int standard,\n+\t    try (*check) (gfc_actual_arglist *),\n+\t    gfc_expr *(*simplify) (gfc_expr *),\n+\t    void (*resolve) (gfc_expr *, gfc_actual_arglist *),\n+\t    const char *a1, bt type1, int kind1, int optional1,\n+\t    const char *a2, bt type2, int kind2, int optional2)\n {\n   gfc_check_f cf;\n   gfc_simplify_f sf;\n@@ -427,7 +424,7 @@ add_sym_1m (const char *name, int elemental, int actual_ok, bt type,\n   add_sym (name, elemental, actual_ok, type, kind, standard, cf, sf, rf,\n \t   a1, type1, kind1, optional1,\n \t   a2, type2, kind2, optional2,\n-\t   (void*)0);\n+\t   (void *) 0);\n }\n \n \n@@ -436,12 +433,12 @@ add_sym_1m (const char *name, int elemental, int actual_ok, bt type,\n \n static void\n add_sym_2 (const char *name, int elemental, int actual_ok, bt type,\n-\t\t       int kind, int standard,\n-\t\t       try (*check)(gfc_expr *,gfc_expr *),\n-\t\t       gfc_expr *(*simplify)(gfc_expr *,gfc_expr *),\n-\t\t       void (*resolve)(gfc_expr *,gfc_expr *,gfc_expr *),\n-\t\t       const char* a1, bt type1, int kind1, int optional1,\n-\t   const char* a2, bt type2, int kind2, int optional2)\n+\t   int kind, int standard,\n+\t   try (*check) (gfc_expr *, gfc_expr *),\n+\t   gfc_expr *(*simplify) (gfc_expr *, gfc_expr *),\n+\t   void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *),\n+\t   const char *a1, bt type1, int kind1, int optional1,\n+\t   const char *a2, bt type2, int kind2, int optional2)\n {\n   gfc_check_f cf;\n   gfc_simplify_f sf;\n@@ -454,21 +451,20 @@ add_sym_2 (const char *name, int elemental, int actual_ok, bt type,\n   add_sym (name, elemental, actual_ok, type, kind, standard, cf, sf, rf,\n \t   a1, type1, kind1, optional1,\n \t   a2, type2, kind2, optional2,\n-\t   (void*)0);\n+\t   (void *) 0);\n }\n \n \n /* Add a symbol to the subroutine list where the subroutine takes\n    2 arguments.  */\n \n static void\n-add_sym_2s (const char *name, int elemental, bt type,\n-\t\t\tint kind, int standard,\n-\t\t       try (*check)(gfc_expr *,gfc_expr *),\n-\t\t       gfc_expr *(*simplify)(gfc_expr *,gfc_expr *),\n-\t\t       void (*resolve)(gfc_code *),\n-\t\t       const char* a1, bt type1, int kind1, int optional1,\n-\t    const char* a2, bt type2, int kind2, int optional2)\n+add_sym_2s (const char *name, int elemental, bt type, int kind, int standard,\n+\t    try (*check) (gfc_expr *, gfc_expr *),\n+\t    gfc_expr *(*simplify) (gfc_expr *, gfc_expr *),\n+\t    void (*resolve) (gfc_code *),\n+\t    const char *a1, bt type1, int kind1, int optional1,\n+\t    const char *a2, bt type2, int kind2, int optional2)\n {\n   gfc_check_f cf;\n   gfc_simplify_f sf;\n@@ -481,7 +477,7 @@ add_sym_2s (const char *name, int elemental, bt type,\n   add_sym (name, elemental, ACTUAL_NO, type, kind, standard, cf, sf, rf,\n \t   a1, type1, kind1, optional1,\n \t   a2, type2, kind2, optional2,\n-\t   (void*)0);\n+\t   (void *) 0);\n }\n \n \n@@ -490,13 +486,13 @@ add_sym_2s (const char *name, int elemental, bt type,\n \n static void\n add_sym_3 (const char *name, int elemental, int actual_ok, bt type,\n-\t\t       int kind, int standard,\n-\t\t       try (*check)(gfc_expr *,gfc_expr *,gfc_expr *),\n-\t\t       gfc_expr *(*simplify)(gfc_expr *,gfc_expr *,gfc_expr *),\n-\t\t       void (*resolve)(gfc_expr *,gfc_expr *,gfc_expr *,gfc_expr *),\n-\t\t       const char* a1, bt type1, int kind1, int optional1,\n-\t\t       const char* a2, bt type2, int kind2, int optional2,\n-\t   const char* a3, bt type3, int kind3, int optional3)\n+\t   int kind, int standard,\n+\t   try (*check) (gfc_expr *, gfc_expr *, gfc_expr *),\n+\t   gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *),\n+\t   void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n+\t   const char *a1, bt type1, int kind1, int optional1,\n+\t   const char *a2, bt type2, int kind2, int optional2,\n+\t   const char *a3, bt type3, int kind3, int optional3)\n {\n   gfc_check_f cf;\n   gfc_simplify_f sf;\n@@ -510,22 +506,22 @@ add_sym_3 (const char *name, int elemental, int actual_ok, bt type,\n \t   a1, type1, kind1, optional1,\n \t   a2, type2, kind2, optional2,\n \t   a3, type3, kind3, optional3,\n-\t   (void*)0);\n+\t   (void *) 0);\n }\n \n \n /* MINLOC and MAXLOC get special treatment because their argument\n    might have to be reordered.  */\n \n static void\n-add_sym_3ml (const char *name, int elemental, \n-\t\t\t int actual_ok, bt type, int kind, int standard,\n-\t\t\t try (*check)(gfc_actual_arglist *),\n-\t\t\t gfc_expr*(*simplify)(gfc_expr *,gfc_expr *,gfc_expr *),\n-\t\t\t void (*resolve)(gfc_expr *,gfc_expr *,gfc_expr *,gfc_expr *),\n-\t\t\t const char* a1, bt type1, int kind1, int optional1,\n-\t\t\t const char* a2, bt type2, int kind2, int optional2,\n-\t     const char* a3, bt type3, int kind3, int optional3)\n+add_sym_3ml (const char *name, int elemental, int actual_ok, bt type,\n+\t     int kind, int standard,\n+\t     try (*check) (gfc_actual_arglist *),\n+\t     gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *),\n+\t     void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n+\t     const char *a1, bt type1, int kind1, int optional1,\n+\t     const char *a2, bt type2, int kind2, int optional2,\n+\t     const char *a3, bt type3, int kind3, int optional3)\n {\n   gfc_check_f cf;\n   gfc_simplify_f sf;\n@@ -539,22 +535,22 @@ add_sym_3ml (const char *name, int elemental,\n \t   a1, type1, kind1, optional1,\n \t   a2, type2, kind2, optional2,\n \t   a3, type3, kind3, optional3,\n-\t   (void*)0);\n+\t   (void *) 0);\n }\n \n \n /* MINVAL, MAXVAL, PRODUCT, and SUM also get special treatment because\n    their argument also might have to be reordered.  */\n \n static void\n-add_sym_3red (const char *name, int elemental, \n-                          int actual_ok, bt type, int kind, int standard,\n-                          try (*check)(gfc_actual_arglist *),\n-                          gfc_expr*(*simplify)(gfc_expr *,gfc_expr *,gfc_expr *),\n-                          void (*resolve)(gfc_expr *,gfc_expr *,gfc_expr *,gfc_expr *),\n-                          const char* a1, bt type1, int kind1, int optional1,\n-                          const char* a2, bt type2, int kind2, int optional2,\n-\t      const char* a3, bt type3, int kind3, int optional3)\n+add_sym_3red (const char *name, int elemental, int actual_ok, bt type,\n+\t      int kind, int standard,\n+\t      try (*check) (gfc_actual_arglist *),\n+\t      gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *),\n+\t      void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n+\t      const char *a1, bt type1, int kind1, int optional1,\n+\t      const char *a2, bt type2, int kind2, int optional2,\n+\t      const char *a3, bt type3, int kind3, int optional3)\n {\n   gfc_check_f cf;\n   gfc_simplify_f sf;\n@@ -568,22 +564,21 @@ add_sym_3red (const char *name, int elemental,\n \t   a1, type1, kind1, optional1,\n \t   a2, type2, kind2, optional2,\n \t   a3, type3, kind3, optional3,\n-\t   (void*)0);\n+\t   (void *) 0);\n }\n \n \n /* Add a symbol to the subroutine list where the subroutine takes\n    3 arguments.  */\n \n static void\n-add_sym_3s (const char *name, int elemental, bt type,\n-\t\t\tint kind, int standard,\n-\t\t       try (*check)(gfc_expr *,gfc_expr *,gfc_expr *),\n-\t\t       gfc_expr *(*simplify)(gfc_expr *,gfc_expr *,gfc_expr *),\n-\t\t       void (*resolve)(gfc_code *),\n-\t\t       const char* a1, bt type1, int kind1, int optional1,\n-\t\t       const char* a2, bt type2, int kind2, int optional2,\n-\t    const char* a3, bt type3, int kind3, int optional3)\n+add_sym_3s (const char *name, int elemental, bt type, int kind, int standard,\n+\t    try (*check) (gfc_expr *, gfc_expr *, gfc_expr *),\n+\t    gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *),\n+\t    void (*resolve) (gfc_code *),\n+\t    const char *a1, bt type1, int kind1, int optional1,\n+\t    const char *a2, bt type2, int kind2, int optional2,\n+\t    const char *a3, bt type3, int kind3, int optional3)\n {\n   gfc_check_f cf;\n   gfc_simplify_f sf;\n@@ -597,7 +592,7 @@ add_sym_3s (const char *name, int elemental, bt type,\n \t   a1, type1, kind1, optional1,\n \t   a2, type2, kind2, optional2,\n \t   a3, type3, kind3, optional3,\n-\t   (void*)0);\n+\t   (void *) 0);\n }\n \n \n@@ -606,14 +601,16 @@ add_sym_3s (const char *name, int elemental, bt type,\n \n static void\n add_sym_4 (const char *name, int elemental, int actual_ok, bt type,\n-\t\t       int kind, int standard,\n-\t\t       try (*check)(gfc_expr *,gfc_expr *,gfc_expr *,gfc_expr *),\n-\t\t       gfc_expr *(*simplify)(gfc_expr *,gfc_expr *,gfc_expr *,gfc_expr *),\n-\t\t       void (*resolve)(gfc_expr *,gfc_expr *,gfc_expr *,gfc_expr *,gfc_expr *),\n-\t\t       const char* a1, bt type1, int kind1, int optional1,\n-\t\t       const char* a2, bt type2, int kind2, int optional2,\n-\t\t       const char* a3, bt type3, int kind3, int optional3,\n-\t   const char* a4, bt type4, int kind4, int optional4 )\n+\t   int kind, int standard,\n+\t   try (*check) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n+\t   gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t\t\t  gfc_expr *),\n+\t   void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t\t    gfc_expr *),\n+\t   const char *a1, bt type1, int kind1, int optional1,\n+\t   const char *a2, bt type2, int kind2, int optional2,\n+\t   const char *a3, bt type3, int kind3, int optional3,\n+\t   const char *a4, bt type4, int kind4, int optional4 )\n {\n   gfc_check_f cf;\n   gfc_simplify_f sf;\n@@ -628,23 +625,23 @@ add_sym_4 (const char *name, int elemental, int actual_ok, bt type,\n \t   a2, type2, kind2, optional2,\n \t   a3, type3, kind3, optional3,\n \t   a4, type4, kind4, optional4,\n-\t   (void*)0);\n+\t   (void *) 0);\n }\n \n \n /* Add a symbol to the subroutine list where the subroutine takes\n    4 arguments.  */\n \n static void\n-add_sym_4s (const char *name, int elemental,\n-\t\t\tbt type, int kind, int standard,\n-    try (*check)(gfc_expr *,gfc_expr *,gfc_expr *,gfc_expr *),\n-    gfc_expr *(*simplify)(gfc_expr *,gfc_expr *,gfc_expr *,gfc_expr *),\n-    void (*resolve)(gfc_code *),\n-    const char* a1, bt type1, int kind1, int optional1,\n-    const char* a2, bt type2, int kind2, int optional2,\n-    const char* a3, bt type3, int kind3, int optional3,\n-    const char* a4, bt type4, int kind4, int optional4)\n+add_sym_4s (const char *name, int elemental, bt type, int kind, int standard,\n+\t    try (*check) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n+\t    gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t\t\t   gfc_expr *),\n+\t    void (*resolve) (gfc_code *),\n+\t    const char *a1, bt type1, int kind1, int optional1,\n+\t    const char *a2, bt type2, int kind2, int optional2,\n+\t    const char *a3, bt type3, int kind3, int optional3,\n+\t    const char *a4, bt type4, int kind4, int optional4)\n {\n   gfc_check_f cf;\n   gfc_simplify_f sf;\n@@ -659,24 +656,25 @@ add_sym_4s (const char *name, int elemental,\n \t   a2, type2, kind2, optional2,\n \t   a3, type3, kind3, optional3,\n \t   a4, type4, kind4, optional4,\n-\t   (void*)0);\n+\t   (void *) 0);\n }\n \n \n /* Add a symbol to the subroutine list where the subroutine takes\n    5 arguments.  */\n \n static void\n-add_sym_5s (const char *name, int elemental,\n- bt type, int kind, int standard,\n- try (*check)(gfc_expr *,gfc_expr *,gfc_expr *,gfc_expr *,gfc_expr *),\n- gfc_expr *(*simplify)(gfc_expr *,gfc_expr *,gfc_expr *,gfc_expr *,gfc_expr *),\n- void (*resolve)(gfc_code *),\n- const char* a1, bt type1, int kind1, int optional1,\n- const char* a2, bt type2, int kind2, int optional2,\n- const char* a3, bt type3, int kind3, int optional3,\n- const char* a4, bt type4, int kind4, int optional4,\n- const char* a5, bt type5, int kind5, int optional5) \n+add_sym_5s (const char *name, int elemental, bt type, int kind, int standard,\n+\t    try (*check) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t\t  gfc_expr *),\n+\t    gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t\t\t   gfc_expr *, gfc_expr *),\n+\t    void (*resolve) (gfc_code *),\n+\t    const char *a1, bt type1, int kind1, int optional1,\n+\t    const char *a2, bt type2, int kind2, int optional2,\n+\t    const char *a3, bt type3, int kind3, int optional3,\n+\t    const char *a4, bt type4, int kind4, int optional4,\n+\t    const char *a5, bt type5, int kind5, int optional5) \n {\n   gfc_check_f cf;\n   gfc_simplify_f sf;\n@@ -692,7 +690,7 @@ add_sym_5s (const char *name, int elemental,\n \t   a3, type3, kind3, optional3,\n \t   a4, type4, kind4, optional4,\n \t   a5, type5, kind5, optional5,\n-\t   (void*)0);\n+\t   (void *) 0);\n }\n \n \n@@ -701,9 +699,8 @@ add_sym_5s (const char *name, int elemental,\n    a name is not found.  */\n \n static gfc_intrinsic_sym *\n-find_sym (gfc_intrinsic_sym * start, int n, const char *name)\n+find_sym (gfc_intrinsic_sym *start, int n, const char *name)\n {\n-\n   while (n > 0)\n     {\n       if (strcmp (name, start->name) == 0)\n@@ -739,7 +736,6 @@ gfc_find_function (const char *name)\n static gfc_intrinsic_sym *\n find_subroutine (const char *name)\n {\n-\n   return find_sym (subroutines, nsub, name);\n }\n \n@@ -795,9 +791,8 @@ gfc_intrinsic_actual_ok (const char *name, const bool subroutine_flag)\n int\n gfc_intrinsic_name (const char *name, int subroutine_flag)\n {\n-\n-  return subroutine_flag ?\n-    find_subroutine (name) != NULL : gfc_find_function (name) != NULL;\n+  return subroutine_flag ? find_subroutine (name) != NULL\n+\t\t\t : gfc_find_function (name) != NULL;\n }\n \n \n@@ -852,7 +847,6 @@ make_generic (const char *name, gfc_generic_isym_id generic_id, int standard)\n static void\n make_alias (const char *name, int standard)\n {\n-\n   /* First check that the intrinsic belongs to the selected standard.\n      If not, don't add it to the symbol list.  */\n   if (!(gfc_option.allow_std & standard)\n@@ -880,21 +874,22 @@ make_alias (const char *name, int standard)\n     }\n }\n \n+\n /* Make the current subroutine noreturn.  */\n \n static void\n-make_noreturn(void)\n+make_noreturn (void)\n {\n   if (sizing == SZ_NOTHING)\n-      next_sym[-1].noreturn = 1;\n+    next_sym[-1].noreturn = 1;\n }\n \n+\n /* Add intrinsic functions.  */\n \n static void\n add_functions (void)\n {\n-\n   /* Argument names as in the standard (to be used as argument keywords).  */\n   const char\n     *a = \"a\", *f = \"field\", *pt = \"pointer\", *tg = \"target\",\n@@ -1206,7 +1201,7 @@ add_functions (void)\n \t     GFC_STD_F2003, NULL, NULL, NULL);\n \n   make_generic (\"command_argument_count\", GFC_ISYM_COMMAND_ARGUMENT_COUNT,\n-\t        GFC_STD_F2003);\n+\t\tGFC_STD_F2003);\n \n   add_sym_2 (\"complex\", ELEMENTAL, ACTUAL_NO, BT_COMPLEX, dz, GFC_STD_GNU,\n \t     gfc_check_complex, gfc_simplify_complex, gfc_resolve_complex,\n@@ -1277,7 +1272,7 @@ add_functions (void)\n   make_generic (\"cshift\", GFC_ISYM_CSHIFT, GFC_STD_F95);\n \n   add_sym_1 (\"ctime\", NOT_ELEMENTAL, ACTUAL_NO, BT_CHARACTER, 0, GFC_STD_GNU,\n-              gfc_check_ctime, NULL, gfc_resolve_ctime,\n+\t      gfc_check_ctime, NULL, gfc_resolve_ctime,\n \t      tm, BT_INTEGER, di, REQUIRED);\n \n   make_generic (\"ctime\", GFC_ISYM_CTIME, GFC_STD_GNU);\n@@ -1613,7 +1608,7 @@ add_functions (void)\n \n   /* The following function is for G77 compatibility.  */\n   add_sym_1 (\"irand\", NOT_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 4, GFC_STD_GNU,\n-             gfc_check_irand, NULL, NULL,\n+\t     gfc_check_irand, NULL, NULL,\n \t     i, BT_INTEGER, 4, OPTIONAL);\n \n   make_generic (\"irand\", GFC_ISYM_IRAND, GFC_STD_GNU);\n@@ -1816,7 +1811,7 @@ add_functions (void)\n   make_generic (\"maxloc\", GFC_ISYM_MAXLOC, GFC_STD_F95);\n \n   add_sym_3red (\"maxval\", NOT_ELEMENTAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n-                gfc_check_minval_maxval, NULL, gfc_resolve_maxval,\n+\t\tgfc_check_minval_maxval, NULL, gfc_resolve_maxval,\n \t\tar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n \t\tmsk, BT_LOGICAL, dl, OPTIONAL);\n \n@@ -1844,27 +1839,27 @@ add_functions (void)\n \n   add_sym_1m (\"min\", ELEMENTAL, ACTUAL_NO, BT_UNKNOWN, 0, GFC_STD_F77,\n \t      gfc_check_min_max, gfc_simplify_min, gfc_resolve_min,\n-\t     a1, BT_REAL, dr, REQUIRED, a2, BT_REAL, dr, REQUIRED);\n+\t      a1, BT_REAL, dr, REQUIRED, a2, BT_REAL, dr, REQUIRED);\n \n   add_sym_1m (\"min0\", ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F77,\n \t      gfc_check_min_max_integer, gfc_simplify_min, NULL,\n-\t     a1, BT_INTEGER, di, REQUIRED, a2, BT_INTEGER, di, REQUIRED);\n+\t      a1, BT_INTEGER, di, REQUIRED, a2, BT_INTEGER, di, REQUIRED);\n \n   add_sym_1m (\"amin0\", ELEMENTAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F77,\n \t      gfc_check_min_max_integer, gfc_simplify_min, NULL,\n-\t     a1, BT_INTEGER, di, REQUIRED, a2, BT_INTEGER, di, REQUIRED);\n+\t      a1, BT_INTEGER, di, REQUIRED, a2, BT_INTEGER, di, REQUIRED);\n \n   add_sym_1m (\"amin1\", ELEMENTAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F77,\n \t      gfc_check_min_max_real, gfc_simplify_min, NULL,\n-\t     a1, BT_REAL, dr, REQUIRED, a2, BT_REAL, dr, REQUIRED);\n+\t      a1, BT_REAL, dr, REQUIRED, a2, BT_REAL, dr, REQUIRED);\n \n   add_sym_1m (\"min1\", ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F77,\n \t      gfc_check_min_max_real, gfc_simplify_min, NULL,\n-\t     a1, BT_REAL, dr, REQUIRED, a2, BT_REAL, dr, REQUIRED);\n+\t      a1, BT_REAL, dr, REQUIRED, a2, BT_REAL, dr, REQUIRED);\n \n   add_sym_1m (\"dmin1\", ELEMENTAL, ACTUAL_NO, BT_REAL, dd, GFC_STD_F77,\n \t      gfc_check_min_max_double, gfc_simplify_min, NULL,\n-\t     a1, BT_REAL, dd, REQUIRED, a2, BT_REAL, dd, REQUIRED);\n+\t      a1, BT_REAL, dd, REQUIRED, a2, BT_REAL, dd, REQUIRED);\n \n   make_generic (\"min\", GFC_ISYM_MIN, GFC_STD_F77);\n \n@@ -1882,7 +1877,7 @@ add_functions (void)\n   make_generic (\"minloc\", GFC_ISYM_MINLOC, GFC_STD_F95);\n \n   add_sym_3red (\"minval\", NOT_ELEMENTAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n-                gfc_check_minval_maxval, NULL, gfc_resolve_minval,\n+\t\tgfc_check_minval_maxval, NULL, gfc_resolve_minval,\n \t\tar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n \t\tmsk, BT_LOGICAL, dl, OPTIONAL);\n \n@@ -1916,7 +1911,7 @@ add_functions (void)\n \n   add_sym_1 (\"new_line\", NOT_ELEMENTAL, ACTUAL_NO, BT_CHARACTER, dc,\n \t     GFC_STD_F2003, gfc_check_new_line, gfc_simplify_new_line, NULL,\n-             i, BT_CHARACTER, dc, REQUIRED);\n+\t     i, BT_CHARACTER, dc, REQUIRED);\n \n   add_sym_2 (\"nint\", ELEMENTAL, ACTUAL_YES, BT_INTEGER, di, GFC_STD_F77,\n \t     gfc_check_a_ikind, gfc_simplify_nint, gfc_resolve_nint,\n@@ -1960,7 +1955,7 @@ add_functions (void)\n   make_generic (\"present\", GFC_ISYM_PRESENT, GFC_STD_F95);\n \n   add_sym_3red (\"product\", NOT_ELEMENTAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n-                gfc_check_product_sum, NULL, gfc_resolve_product,\n+\t\tgfc_check_product_sum, NULL, gfc_resolve_product,\n \t\tar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n \t\tmsk, BT_LOGICAL, dl, OPTIONAL);\n \n@@ -1974,8 +1969,8 @@ add_functions (void)\n \n   /* The following function is for G77 compatibility.  */\n   add_sym_1 (\"rand\", NOT_ELEMENTAL, ACTUAL_NO, BT_REAL, 4, GFC_STD_GNU,\n-             gfc_check_rand, NULL, NULL,\n-             i, BT_INTEGER, 4, OPTIONAL);\n+\t     gfc_check_rand, NULL, NULL,\n+\t     i, BT_INTEGER, 4, OPTIONAL);\n \n   /* Compatibility with HP FORTRAN 77/iX Reference.  Note, rand() and ran()\n      use slightly different shoddy multiplicative congruential PRNG.  */\n@@ -2181,7 +2176,7 @@ add_functions (void)\n   make_generic (\"stat\", GFC_ISYM_STAT, GFC_STD_GNU);\n \n   add_sym_3red (\"sum\", NOT_ELEMENTAL, ACTUAL_NO, BT_UNKNOWN, 0, GFC_STD_F95,\n-                gfc_check_product_sum, NULL, gfc_resolve_sum,\n+\t\tgfc_check_product_sum, NULL, gfc_resolve_sum,\n \t\tar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n \t\tmsk, BT_LOGICAL, dl, OPTIONAL);\n \n@@ -2255,8 +2250,8 @@ add_functions (void)\n   make_generic (\"trim\", GFC_ISYM_TRIM, GFC_STD_F95);\n \n   add_sym_1 (\"ttynam\", NOT_ELEMENTAL, ACTUAL_NO, BT_CHARACTER, 0, GFC_STD_GNU,\n-              gfc_check_ttynam, NULL, gfc_resolve_ttynam,\n-\t      ut, BT_INTEGER, di, REQUIRED);\n+\t     gfc_check_ttynam, NULL, gfc_resolve_ttynam,\n+\t     ut, BT_INTEGER, di, REQUIRED);\n \n   make_generic (\"ttynam\", GFC_ISYM_TTYNAM, GFC_STD_GNU);\n \n@@ -2295,11 +2290,10 @@ add_functions (void)\n   make_generic (\"verify\", GFC_ISYM_VERIFY, GFC_STD_F95);\n     \n   add_sym_1 (\"loc\", NOT_ELEMENTAL, ACTUAL_NO, BT_INTEGER, ii, GFC_STD_GNU,\n-\t    gfc_check_loc, NULL, gfc_resolve_loc,\n-\t    ar, BT_UNKNOWN, 0, REQUIRED);\n+\t     gfc_check_loc, NULL, gfc_resolve_loc,\n+\t     ar, BT_UNKNOWN, 0, REQUIRED);\n \t\t\n   make_generic (\"loc\", GFC_ISYM_LOC, GFC_STD_GNU);\n-\n }\n \n \n@@ -2362,11 +2356,11 @@ add_subroutines (void)\n \t      tm, BT_REAL, dr, REQUIRED);\n \n   add_sym_2s (\"chdir\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n-              gfc_check_chdir_sub, NULL, gfc_resolve_chdir_sub,\n+\t      gfc_check_chdir_sub, NULL, gfc_resolve_chdir_sub,\n \t      name, BT_CHARACTER, dc, REQUIRED, st, BT_INTEGER, di, OPTIONAL);\n \n   add_sym_3s (\"chmod\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n-              gfc_check_chmod_sub, NULL, gfc_resolve_chmod_sub,\n+\t      gfc_check_chmod_sub, NULL, gfc_resolve_chmod_sub,\n \t      name, BT_CHARACTER, dc, REQUIRED, md, BT_CHARACTER, dc, REQUIRED,\n \t      st, BT_INTEGER, di, OPTIONAL);\n \n@@ -2377,42 +2371,44 @@ add_subroutines (void)\n \n   /* More G77 compatibility garbage.  */\n   add_sym_2s (\"etime\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n-\t     gfc_check_etime_sub, NULL, gfc_resolve_etime_sub,\n+\t      gfc_check_etime_sub, NULL, gfc_resolve_etime_sub,\n \t      vl, BT_REAL, 4, REQUIRED, tm, BT_REAL, 4, REQUIRED);\n \n   add_sym_2s (\"dtime\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n-\t     gfc_check_etime_sub, NULL, gfc_resolve_etime_sub,\n+\t      gfc_check_etime_sub, NULL, gfc_resolve_etime_sub,\n \t      vl, BT_REAL, 4, REQUIRED, tm, BT_REAL, 4, REQUIRED);\n \n   add_sym_1s (\"fdate\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n-\t     gfc_check_fdate_sub, NULL, gfc_resolve_fdate_sub,\n-\t     dt, BT_CHARACTER, dc, REQUIRED);\n+\t      gfc_check_fdate_sub, NULL, gfc_resolve_fdate_sub,\n+\t      dt, BT_CHARACTER, dc, REQUIRED);\n \n   add_sym_1s (\"gerror\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n-              gfc_check_gerror, NULL, gfc_resolve_gerror, c, BT_CHARACTER,\n+\t      gfc_check_gerror, NULL, gfc_resolve_gerror, c, BT_CHARACTER,\n \t      dc, REQUIRED);\n \n   add_sym_2s (\"getcwd\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n-          gfc_check_getcwd_sub, NULL, gfc_resolve_getcwd_sub,\n+\t      gfc_check_getcwd_sub, NULL, gfc_resolve_getcwd_sub,\n \t      c, BT_CHARACTER, dc, REQUIRED, st, BT_INTEGER, di, OPTIONAL);\n \n   add_sym_2s (\"getenv\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n \t      NULL, NULL, NULL,\n-\t      name, BT_CHARACTER, dc, REQUIRED, val, BT_CHARACTER, dc, REQUIRED);\n+\t      name, BT_CHARACTER, dc, REQUIRED, val, BT_CHARACTER, dc,\n+\t      REQUIRED);\n \n   add_sym_2s (\"getarg\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n \t      NULL, NULL, gfc_resolve_getarg,\n \t      c, BT_INTEGER, di, REQUIRED, vl, BT_CHARACTER, dc, REQUIRED);\n \n   add_sym_1s (\"getlog\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n-              gfc_check_getlog, NULL, gfc_resolve_getlog, c, BT_CHARACTER,\n+\t      gfc_check_getlog, NULL, gfc_resolve_getlog, c, BT_CHARACTER,\n \t      dc, REQUIRED);\n \n   /* F2003 commandline routines.  */\n \n   add_sym_3s (\"get_command\", 0, BT_UNKNOWN, 0, GFC_STD_F2003,\n \t      NULL, NULL, gfc_resolve_get_command,\n-\t      com, BT_CHARACTER, dc, OPTIONAL, length, BT_INTEGER, di, OPTIONAL,\n+\t      com, BT_CHARACTER, dc, OPTIONAL,\n+\t      length, BT_INTEGER, di, OPTIONAL,\n \t      st, BT_INTEGER, di, OPTIONAL);\n \n   add_sym_4s (\"get_command_argument\", 0, BT_UNKNOWN, 0, GFC_STD_F2003,\n@@ -2423,8 +2419,9 @@ add_subroutines (void)\n   /* F2003 subroutine to get environment variables.  */\n \n   add_sym_5s (\"get_environment_variable\", 0, BT_UNKNOWN, 0, GFC_STD_F2003,\n-\t     NULL, NULL, gfc_resolve_get_environment_variable,\n-\t      name, BT_CHARACTER, dc, REQUIRED, val, BT_CHARACTER, dc, OPTIONAL,\n+\t      NULL, NULL, gfc_resolve_get_environment_variable,\n+\t      name, BT_CHARACTER, dc, REQUIRED,\n+\t      val, BT_CHARACTER, dc, OPTIONAL,\n \t      length, BT_INTEGER, di, OPTIONAL, st, BT_INTEGER, di, OPTIONAL,\n \t      trim_name, BT_LOGICAL, dl, OPTIONAL);\n \n@@ -2444,7 +2441,7 @@ add_subroutines (void)\n \t      h, BT_REAL, dr, REQUIRED);\n \n   add_sym_3s (\"random_seed\", 0, BT_UNKNOWN, 0, GFC_STD_F95,\n-\t     gfc_check_random_seed, NULL, NULL,\n+\t      gfc_check_random_seed, NULL, NULL,\n \t      sz, BT_INTEGER, di, OPTIONAL, pt, BT_INTEGER, di, OPTIONAL,\n \t      gt, BT_INTEGER, di, OPTIONAL);\n \n@@ -2455,11 +2452,11 @@ add_subroutines (void)\n \t      st, BT_INTEGER, di, OPTIONAL);\n \n   add_sym_1s (\"srand\", 0, BT_UNKNOWN, di, GFC_STD_GNU,\n-             gfc_check_srand, NULL, gfc_resolve_srand,\n+\t      gfc_check_srand, NULL, gfc_resolve_srand,\n \t      c, BT_INTEGER, 4, REQUIRED);\n \n   add_sym_1s (\"exit\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n-             gfc_check_exit, NULL, gfc_resolve_exit,\n+\t      gfc_check_exit, NULL, gfc_resolve_exit,\n \t      c, BT_INTEGER, di, OPTIONAL);\n \n   if ((gfc_option.allow_std & GFC_STD_GNU) || gfc_option.flag_all_intrinsics)\n@@ -2495,29 +2492,29 @@ add_subroutines (void)\n \t      ut, BT_INTEGER, di, REQUIRED, of, BT_INTEGER, ii, REQUIRED);\n \n   add_sym_2s (\"hostnm\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n-          gfc_check_hostnm_sub, NULL, gfc_resolve_hostnm_sub,\n+\t      gfc_check_hostnm_sub, NULL, gfc_resolve_hostnm_sub,\n \t      c, BT_CHARACTER, dc, REQUIRED, st, BT_INTEGER, di, OPTIONAL);\n \n   add_sym_3s (\"kill\", 0, BT_UNKNOWN, 0, GFC_STD_GNU, gfc_check_kill_sub,\n \t      NULL, gfc_resolve_kill_sub, c, BT_INTEGER, di, REQUIRED,\n \t      val, BT_INTEGER, di, REQUIRED, st, BT_INTEGER, di, OPTIONAL);\n \n   add_sym_3s (\"link\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n-              gfc_check_link_sub, NULL, gfc_resolve_link_sub,\n+\t      gfc_check_link_sub, NULL, gfc_resolve_link_sub,\n \t      name, BT_CHARACTER, dc, REQUIRED, val, BT_CHARACTER,\n \t      dc, REQUIRED, st, BT_INTEGER, di, OPTIONAL);\n \n   add_sym_1s (\"perror\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n-          gfc_check_perror, NULL, gfc_resolve_perror,\n+\t      gfc_check_perror, NULL, gfc_resolve_perror,\n \t      c, BT_CHARACTER, dc, REQUIRED);\n \n   add_sym_3s (\"rename\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n-              gfc_check_rename_sub, NULL, gfc_resolve_rename_sub,\n+\t      gfc_check_rename_sub, NULL, gfc_resolve_rename_sub,\n \t      name, BT_CHARACTER, dc, REQUIRED, val, BT_CHARACTER,\n \t      dc, REQUIRED, st, BT_INTEGER, di, OPTIONAL);\n \n   add_sym_1s (\"sleep\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n-              gfc_check_sleep_sub, NULL, gfc_resolve_sleep_sub,\n+\t      gfc_check_sleep_sub, NULL, gfc_resolve_sleep_sub,\n \t      val, BT_CHARACTER, dc, REQUIRED);\n \n   add_sym_3s (\"fstat\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n@@ -2541,7 +2538,7 @@ add_subroutines (void)\n \t      st, BT_INTEGER, di, OPTIONAL);\n \n   add_sym_3s (\"symlnk\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n-              gfc_check_symlnk_sub, NULL, gfc_resolve_symlnk_sub,\n+\t      gfc_check_symlnk_sub, NULL, gfc_resolve_symlnk_sub,\n \t      name, BT_CHARACTER, dc, REQUIRED, val, BT_CHARACTER,\n \t      dc, REQUIRED, st, BT_INTEGER, di, OPTIONAL);\n \n@@ -2550,22 +2547,21 @@ add_subroutines (void)\n \t      c, BT_CHARACTER, dc, REQUIRED, st, BT_INTEGER, di, OPTIONAL);\n \n   add_sym_3s (\"system_clock\", 0, BT_UNKNOWN, 0, GFC_STD_F95,\n-\t     gfc_check_system_clock, NULL, gfc_resolve_system_clock,\n+\t      gfc_check_system_clock, NULL, gfc_resolve_system_clock,\n \t      c, BT_INTEGER, di, OPTIONAL, cr, BT_INTEGER, di, OPTIONAL,\n \t      cm, BT_INTEGER, di, OPTIONAL);\n \n   add_sym_2s (\"ttynam\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n-              gfc_check_ttynam_sub, NULL, gfc_resolve_ttynam_sub,\n+\t      gfc_check_ttynam_sub, NULL, gfc_resolve_ttynam_sub,\n \t      ut, BT_INTEGER, di, REQUIRED, c, BT_CHARACTER, dc, REQUIRED);\n \n   add_sym_2s (\"umask\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n-          gfc_check_umask_sub, NULL, gfc_resolve_umask_sub,\n+\t      gfc_check_umask_sub, NULL, gfc_resolve_umask_sub,\n \t      val, BT_INTEGER, di, REQUIRED, num, BT_INTEGER, di, OPTIONAL);\n \n   add_sym_2s (\"unlink\", 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n-          gfc_check_unlink_sub, NULL, gfc_resolve_unlink_sub,\n+\t      gfc_check_unlink_sub, NULL, gfc_resolve_unlink_sub,\n \t      c, BT_CHARACTER, dc, REQUIRED, st, BT_INTEGER, di, OPTIONAL);\n-\n }\n \n \n@@ -2574,7 +2570,6 @@ add_subroutines (void)\n static void\n add_conv (bt from_type, int from_kind, bt to_type, int to_kind, int standard)\n {\n-\n   gfc_typespec from, to;\n   gfc_intrinsic_sym *sym;\n \n@@ -2772,7 +2767,7 @@ gfc_intrinsic_done_1 (void)\n    have been left behind by a sort against some formal argument list.  */\n \n static void\n-remove_nullargs (gfc_actual_arglist ** ap)\n+remove_nullargs (gfc_actual_arglist **ap)\n {\n   gfc_actual_arglist *head, *tail, *next;\n \n@@ -2812,10 +2807,9 @@ remove_nullargs (gfc_actual_arglist ** ap)\n    return FAILURE.  */\n \n static try\n-sort_actual (const char *name, gfc_actual_arglist ** ap,\n-\t     gfc_intrinsic_arg * formal, locus * where)\n+sort_actual (const char *name, gfc_actual_arglist **ap,\n+\t     gfc_intrinsic_arg *formal, locus *where)\n {\n-\n   gfc_actual_arglist *actual, *a;\n   gfc_intrinsic_arg *f;\n \n@@ -2832,7 +2826,7 @@ sort_actual (const char *name, gfc_actual_arglist ** ap,\n     return SUCCESS;\n \n   for (;;)\n-    {\t\t\t\t/* Put the nonkeyword arguments in a 1:1 correspondence */\n+    {\t\t/* Put the nonkeyword arguments in a 1:1 correspondence */\n       if (f == NULL)\n \tbreak;\n       if (a == NULL)\n@@ -2869,7 +2863,7 @@ sort_actual (const char *name, gfc_actual_arglist ** ap,\n \t\t       \"context\", where);\n \t  else\n \t    gfc_error (\"Can't find keyword named '%s' in call to '%s' at %L\",\n-\t\t     a->name, name, where);\n+\t\t       a->name, name, where);\n \t  return FAILURE;\n \t}\n \n@@ -2934,7 +2928,7 @@ sort_actual (const char *name, gfc_actual_arglist ** ap,\n    for arrayness here.  */\n \n static try\n-check_arglist (gfc_actual_arglist ** ap, gfc_intrinsic_sym * sym,\n+check_arglist (gfc_actual_arglist **ap, gfc_intrinsic_sym *sym,\n \t       int error_flag)\n {\n   gfc_actual_arglist *actual;\n@@ -2953,11 +2947,11 @@ check_arglist (gfc_actual_arglist ** ap, gfc_intrinsic_sym * sym,\n       if (!gfc_compare_types (&formal->ts, &actual->expr->ts))\n \t{\n \t  if (error_flag)\n-\t    gfc_error\n-\t      (\"Type of argument '%s' in call to '%s' at %L should be \"\n-\t       \"%s, not %s\", gfc_current_intrinsic_arg[i],\n-\t       gfc_current_intrinsic, &actual->expr->where,\n-\t       gfc_typename (&formal->ts), gfc_typename (&actual->expr->ts));\n+\t    gfc_error (\"Type of argument '%s' in call to '%s' at %L should \"\n+\t\t       \"be %s, not %s\", gfc_current_intrinsic_arg[i],\n+\t\t       gfc_current_intrinsic, &actual->expr->where,\n+\t\t       gfc_typename (&formal->ts),\n+\t\t       gfc_typename (&actual->expr->ts));\n \t  return FAILURE;\n \t}\n     }\n@@ -2971,7 +2965,7 @@ check_arglist (gfc_actual_arglist ** ap, gfc_intrinsic_sym * sym,\n    of the result.  This may involve calling a resolution subroutine.  */\n \n static void\n-resolve_intrinsic (gfc_intrinsic_sym * specific, gfc_expr * e)\n+resolve_intrinsic (gfc_intrinsic_sym *specific, gfc_expr *e)\n {\n   gfc_expr *a1, *a2, *a3, *a4, *a5;\n   gfc_actual_arglist *arg;\n@@ -3058,7 +3052,7 @@ resolve_intrinsic (gfc_intrinsic_sym * specific, gfc_expr * e)\n    if nothing has changed in the expression itself.  */\n \n static try\n-do_simplify (gfc_intrinsic_sym * specific, gfc_expr * e)\n+do_simplify (gfc_intrinsic_sym *specific, gfc_expr *e)\n {\n   gfc_expr *result, *a1, *a2, *a3, *a4, *a5;\n   gfc_actual_arglist *arg;\n@@ -3173,7 +3167,7 @@ do_simplify (gfc_intrinsic_sym * specific, gfc_expr * e)\n    list cannot match any intrinsic.  */\n \n static void\n-init_arglist (gfc_intrinsic_sym * isym)\n+init_arglist (gfc_intrinsic_sym *isym)\n {\n   gfc_intrinsic_arg *formal;\n   int i;\n@@ -3196,7 +3190,7 @@ init_arglist (gfc_intrinsic_sym * isym)\n    and intrinsic match, FAILURE otherwise.  */\n \n static try\n-check_specific (gfc_intrinsic_sym * specific, gfc_expr * expr, int error_flag)\n+check_specific (gfc_intrinsic_sym *specific, gfc_expr *expr, int error_flag)\n {\n   gfc_actual_arglist *arg, **ap;\n   int r;\n@@ -3218,8 +3212,7 @@ check_specific (gfc_intrinsic_sym * specific, gfc_expr * expr, int error_flag)\n     return FAILURE;\n \n   if (specific->check.f3ml == gfc_check_minloc_maxloc)\n-    /* This is special because we might have to reorder the argument\n-       list.  */\n+    /* This is special because we might have to reorder the argument list.  */\n     t = gfc_check_minloc_maxloc (*ap);\n   else if (specific->check.f3red == gfc_check_minval_maxval)\n     /* This is also special because we also might have to reorder the\n@@ -3257,9 +3250,8 @@ check_specific (gfc_intrinsic_sym * specific, gfc_expr * expr, int error_flag)\n \n \t  if (arg->expr->rank != r)\n \t    {\n-\t      gfc_error\n-\t\t(\"Ranks of arguments to elemental intrinsic '%s' differ \"\n-\t\t \"at %L\", specific->name, &arg->expr->where);\n+\t      gfc_error (\"Ranks of arguments to elemental intrinsic '%s' \"\n+\t\t\t \"differ at %L\", specific->name, &arg->expr->where);\n \t      return FAILURE;\n \t    }\n \t}\n@@ -3299,7 +3291,7 @@ gfc_init_expr_extensions (gfc_intrinsic_sym *isym)\n    has chosen.  */\n \n static void\n-check_intrinsic_standard (const char *name, int standard, locus * where)\n+check_intrinsic_standard (const char *name, int standard, locus *where)\n {\n   if (!gfc_option.warn_nonstd_intrinsics)\n     return;\n@@ -3313,17 +3305,17 @@ check_intrinsic_standard (const char *name, int standard, locus * where)\n    We return:\n \n     MATCH_YES    if the call corresponds to an intrinsic, simplification\n-                 is done if possible.\n+\t\t is done if possible.\n \n     MATCH_NO     if the call does not correspond to an intrinsic\n \n     MATCH_ERROR  if the call corresponds to an intrinsic but there was an\n-                 error during the simplification process.\n+\t\t error during the simplification process.\n \n    The error_flag parameter enables an error reporting.  */\n \n match\n-gfc_intrinsic_func_interface (gfc_expr * expr, int error_flag)\n+gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n {\n   gfc_intrinsic_sym *isym, *specific;\n   gfc_actual_arglist *actual;\n@@ -3332,7 +3324,7 @@ gfc_intrinsic_func_interface (gfc_expr * expr, int error_flag)\n \n   if (expr->value.function.isym != NULL)\n     return (do_simplify (expr->value.function.isym, expr) == FAILURE)\n-      ? MATCH_ERROR : MATCH_YES;\n+\t   ? MATCH_ERROR : MATCH_YES;\n \n   gfc_suppress_error = !error_flag;\n   flag = 0;\n@@ -3407,8 +3399,8 @@ gfc_intrinsic_func_interface (gfc_expr * expr, int error_flag)\n   if (gfc_init_expr && flag && gfc_init_expr_extensions (specific))\n     {\n       if (gfc_notify_std (GFC_STD_GNU, \"Extension: Evaluation of \"\n-\t    \"nonstandard initialization expression at %L\", &expr->where)\n-\t  == FAILURE)\n+\t\t\t  \"nonstandard initialization expression at %L\",\n+\t\t\t  &expr->where) == FAILURE)\n \t{\n \t  return MATCH_ERROR;\n \t}\n@@ -3426,7 +3418,7 @@ gfc_intrinsic_func_interface (gfc_expr * expr, int error_flag)\n    correspond).  */\n \n match\n-gfc_intrinsic_sub_interface (gfc_code * c, int error_flag)\n+gfc_intrinsic_sub_interface (gfc_code *c, int error_flag)\n {\n   gfc_intrinsic_sym *isym;\n   const char *name;\n@@ -3485,7 +3477,7 @@ gfc_intrinsic_sub_interface (gfc_code * c, int error_flag)\n /* Call gfc_convert_type() with warning enabled.  */\n \n try\n-gfc_convert_type (gfc_expr * expr, gfc_typespec * ts, int eflag)\n+gfc_convert_type (gfc_expr *expr, gfc_typespec *ts, int eflag)\n {\n   return gfc_convert_type_warn (expr, ts, eflag, 1);\n }\n@@ -3502,8 +3494,7 @@ gfc_convert_type (gfc_expr * expr, gfc_typespec * ts, int eflag)\n    'wflag' controls the warning related to conversion.  */\n \n try\n-gfc_convert_type_warn (gfc_expr * expr, gfc_typespec * ts, int eflag,\n-\t\t       int wflag)\n+gfc_convert_type_warn (gfc_expr *expr, gfc_typespec *ts, int eflag, int wflag)\n {\n   gfc_intrinsic_sym *sym;\n   gfc_typespec from_ts;\n@@ -3519,8 +3510,7 @@ gfc_convert_type_warn (gfc_expr * expr, gfc_typespec * ts, int eflag,\n \n   /* NULL and zero size arrays get their type here.  */\n   if (expr->expr_type == EXPR_NULL\n-      || (expr->expr_type == EXPR_ARRAY\n-\t  && expr->value.constructor == NULL))\n+      || (expr->expr_type == EXPR_ARRAY && expr->value.constructor == NULL))\n     {\n       /* Sometimes the RHS acquire the type.  */\n       expr->ts = *ts;\n@@ -3530,8 +3520,7 @@ gfc_convert_type_warn (gfc_expr * expr, gfc_typespec * ts, int eflag,\n   if (expr->ts.type == BT_UNKNOWN)\n     goto bad;\n \n-  if (expr->ts.type == BT_DERIVED\n-      && ts->type == BT_DERIVED\n+  if (expr->ts.type == BT_DERIVED && ts->type == BT_DERIVED\n       && gfc_compare_types (&expr->ts, ts))\n     return SUCCESS;\n "}, {"sha": "312bb39b3d93d0d39bcfdffc414aebabae0a4a8a", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 157, "deletions": 173, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b251af97928db06c0a2174b230a3ae9f83745a04/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b251af97928db06c0a2174b230a3ae9f83745a04/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=b251af97928db06c0a2174b230a3ae9f83745a04", "patch": "@@ -1,6 +1,6 @@\n /* Deal with I/O statements & related stuff.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software\n-   Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of GCC.\n@@ -27,9 +27,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"match.h\"\n #include \"parse.h\"\n \n-gfc_st_label format_asterisk =\n-  {0, NULL, NULL, -1, ST_LABEL_FORMAT, ST_LABEL_FORMAT, NULL,\n-   0, {NULL, NULL}};\n+gfc_st_label\n+format_asterisk = {0, NULL, NULL, -1, ST_LABEL_FORMAT, ST_LABEL_FORMAT, NULL,\n+\t\t   0, {NULL, NULL}};\n \n typedef struct\n {\n@@ -52,7 +52,7 @@ static const io_tag\n \ttag_unit\t= {\"UNIT\", \" unit = %e\", BT_INTEGER},\n \ttag_advance\t= {\"ADVANCE\", \" advance = %e\", BT_CHARACTER},\n \ttag_rec\t\t= {\"REC\", \" rec = %e\", BT_INTEGER},\n-\ttag_spos        = {\"POSITION\", \" pos = %e\", BT_INTEGER},\n+\ttag_spos\t= {\"POSITION\", \" pos = %e\", BT_INTEGER},\n \ttag_format\t= {\"FORMAT\", NULL, BT_CHARACTER},\n \ttag_iomsg\t= {\"IOMSG\", \" iomsg = %e\", BT_CHARACTER},\n \ttag_iostat\t= {\"IOSTAT\", \" iostat = %v\", BT_INTEGER},\n@@ -152,14 +152,13 @@ next_char (int in_string)\n static void\n unget_char (void)\n {\n-\n   use_last_char = 1;\n }\n \n /* Eat up the spaces and return a character. */\n \n static char\n-next_char_not_space(void)\n+next_char_not_space (void)\n {\n   char c;\n   do\n@@ -210,15 +209,15 @@ format_lex (void)\n       do\n \t{\n \t  c = next_char_not_space ();\n-          if(ISDIGIT (c))\n-            value = 10 * value + c - '0';\n+\t  if (ISDIGIT (c))\n+\t    value = 10 * value + c - '0';\n \t}\n       while (ISDIGIT (c));\n \n       unget_char ();\n \n       if (negative_flag)\n-        value = -value;\n+\tvalue = -value;\n \n       token = FMT_SIGNED_INT;\n       break;\n@@ -242,8 +241,8 @@ format_lex (void)\n \t  c = next_char_not_space ();\n \t  if (c != '0')\n \t    zflag = 0;\n-          if (ISDIGIT (c))\n-            value = 10 * value + c - '0';\n+\t  if (ISDIGIT (c))\n+\t    value = 10 * value + c - '0';\n \t}\n       while (ISDIGIT (c));\n \n@@ -343,7 +342,7 @@ format_lex (void)\n \t\t  break;\n \t\t}\n \t    }\n-          value++;\n+\t  value++;\n \t}\n       break;\n \n@@ -506,8 +505,8 @@ check_format (void)\n       t = format_lex ();\n \n       if (gfc_notify_std (GFC_STD_GNU, \"Extension: $ descriptor at %C\")\n-          == FAILURE)\n-        return FAILURE;\n+\t  == FAILURE)\n+\treturn FAILURE;\n       if (t != FMT_RPAREN || level > 0)\n \t{\n \t  gfc_warning (\"$ should be the last specifier in format at %C\");\n@@ -573,8 +572,8 @@ check_format (void)\n       switch (gfc_notification_std (GFC_STD_GNU))\n \t{\n \t  case WARNING:\n-\t    gfc_warning\n-\t      (\"Extension: Missing positive width after L descriptor at %C\");\n+\t    gfc_warning (\"Extension: Missing positive width after L \"\n+\t\t\t \"descriptor at %C\");\n \t    saved_token = t;\n \t    break;\n \n@@ -660,7 +659,7 @@ check_format (void)\n       if (t != FMT_PERIOD)\n \t{\n \t  /* Warn if -std=legacy, otherwise error.  */\n-          if (gfc_option.warn_std != 0)\n+\t  if (gfc_option.warn_std != 0)\n \t    gfc_error_now (\"Period required in format specifier at %C\");\n \t  else\n \t    gfc_warning (\"Period required in format specifier at %C\");\n@@ -680,16 +679,16 @@ check_format (void)\n     case FMT_H:\n       if(mode == MODE_STRING)\n       {\n-        format_string += value;\n-        format_length -= value;\n+\tformat_string += value;\n+\tformat_length -= value;\n       }\n       else\n       {\n-        while(repeat >0)\n-         {\n-          next_char(1);\n-          repeat -- ;\n-         }\n+\twhile (repeat >0)\n+\t {\n+\t  next_char (1);\n+\t  repeat -- ;\n+\t }\n       }\n      break;\n \n@@ -821,7 +820,7 @@ check_format (void)\n       gfc_warning (\"%s in format string at %C\", error);\n \n       /* TODO: More elaborate measures are needed to show where a problem\n-         is within a format string that has been calculated.  */\n+\t is within a format string that has been calculated.  */\n     }\n \n   rv = FAILURE;\n@@ -835,9 +834,8 @@ check_format (void)\n    like a format string.  */\n \n static void\n-check_format_string (gfc_expr * e)\n+check_format_string (gfc_expr *e)\n {\n-\n   mode = MODE_STRING;\n   format_string = e->value.character.string;\n   check_format ();\n@@ -857,7 +855,7 @@ gfc_match_format (void)\n   locus start;\n \n   if (gfc_current_ns->proc_name\n-\t&& gfc_current_ns->proc_name->attr.flavor == FL_MODULE)\n+      && gfc_current_ns->proc_name->attr.flavor == FL_MODULE)\n     {\n       gfc_error (\"Format statement in module main block at %C\");\n       return MATCH_ERROR;\n@@ -897,7 +895,7 @@ gfc_match_format (void)\n   e->ts.type = BT_CHARACTER;\n   e->ts.kind = gfc_default_character_kind;\n   e->where = start;\n-  e->value.character.string = format_string = gfc_getmem(format_length+1);\n+  e->value.character.string = format_string = gfc_getmem (format_length + 1);\n   e->value.character.length = format_length;\n   gfc_statement_label->format = e;\n \n@@ -912,7 +910,7 @@ gfc_match_format (void)\n /* Match an expression I/O tag of some sort.  */\n \n static match\n-match_etag (const io_tag * tag, gfc_expr ** v)\n+match_etag (const io_tag *tag, gfc_expr **v)\n {\n   gfc_expr *result;\n   match m;\n@@ -936,7 +934,7 @@ match_etag (const io_tag * tag, gfc_expr ** v)\n /* Match a variable I/O tag of some sort.  */\n \n static match\n-match_vtag (const io_tag * tag, gfc_expr ** v)\n+match_vtag (const io_tag *tag, gfc_expr **v)\n {\n   gfc_expr *result;\n   match m;\n@@ -989,7 +987,7 @@ match_out_tag(const io_tag *tag, gfc_expr **result)\n /* Match a label I/O tag.  */\n \n static match\n-match_ltag (const io_tag * tag, gfc_st_label ** label)\n+match_ltag (const io_tag *tag, gfc_st_label ** label)\n {\n   match m;\n   gfc_st_label *old;\n@@ -1013,9 +1011,8 @@ match_ltag (const io_tag * tag, gfc_st_label ** label)\n /* Do expression resolution and type-checking on an expression tag.  */\n \n static try\n-resolve_tag (const io_tag * tag, gfc_expr * e)\n+resolve_tag (const io_tag *tag, gfc_expr *e)\n {\n-\n   if (e == NULL)\n     return SUCCESS;\n \n@@ -1025,7 +1022,7 @@ resolve_tag (const io_tag * tag, gfc_expr * e)\n   if (e->ts.type != tag->type && tag != &tag_format)\n     {\n       gfc_error (\"%s tag at %L must be of type %s\", tag->name,\n-\t\t&e->where, gfc_basic_typename (tag->type));\n+\t\t &e->where, gfc_basic_typename (tag->type));\n       return FAILURE;\n     }\n \n@@ -1044,32 +1041,34 @@ resolve_tag (const io_tag * tag, gfc_expr * e)\n \t of integer or character type.  The integer variable should be\n \t ASSIGNED.  */\n       if (e->symtree == NULL || e->symtree->n.sym->as == NULL\n-\t\t|| e->symtree->n.sym->as->rank == 0)\n+\t  || e->symtree->n.sym->as->rank == 0)\n \t{\n \t  if (e->ts.type != BT_CHARACTER && e->ts.type != BT_INTEGER)\n \t    {\n \t      gfc_error (\"%s tag at %L must be of type %s or %s\", tag->name,\n-\t\t\t&e->where, gfc_basic_typename (BT_CHARACTER),\n-\t\t\tgfc_basic_typename (BT_INTEGER));\n+\t\t\t &e->where, gfc_basic_typename (BT_CHARACTER),\n+\t\t\t gfc_basic_typename (BT_INTEGER));\n \t      return FAILURE;\n \t    }\n \t  else if (e->ts.type == BT_INTEGER && e->expr_type == EXPR_VARIABLE)\n \t    {\n-\t      if (gfc_notify_std (GFC_STD_F95_DEL,\n-\t\t\t\"Obsolete: ASSIGNED variable in FORMAT tag at %L\",\n-\t\t\t&e->where) == FAILURE)\n+\t      if (gfc_notify_std (GFC_STD_F95_DEL, \"Obsolete: ASSIGNED \"\n+\t\t\t\t  \"variable in FORMAT tag at %L\", &e->where)\n+\t\t  == FAILURE)\n \t\treturn FAILURE;\n \t      if (e->symtree->n.sym->attr.assign != 1)\n \t\t{\n \t\t  gfc_error (\"Variable '%s' at %L has not been assigned a \"\n-\t\t\t\"format label\", e->symtree->n.sym->name, &e->where);\n+\t\t\t     \"format label\", e->symtree->n.sym->name,\n+\t\t\t     &e->where);\n \t\t  return FAILURE;\n \t\t}\n \t    }\n \t  else if (e->ts.type == BT_INTEGER)\n \t    {\n \t      gfc_error (\"scalar '%s' FORMAT tag at %L is not an ASSIGNED \"\n-\t\t\t \"variable\", gfc_basic_typename (e->ts.type), &e->where);\n+\t\t\t \"variable\", gfc_basic_typename (e->ts.type),\n+\t\t\t &e->where);\n \t      return FAILURE;\n \t    }\n \n@@ -1082,16 +1081,16 @@ resolve_tag (const io_tag * tag, gfc_expr * e)\n \t     assigned an Hollerith constant.  */\n \t  if (e->ts.type == BT_CHARACTER)\n \t    {\n-\t      if (gfc_notify_std (GFC_STD_GNU,\n-\t\t\t\"Extension: Character array in FORMAT tag at %L\",\n-\t\t\t&e->where) == FAILURE)\n+\t      if (gfc_notify_std (GFC_STD_GNU, \"Extension: Character array \"\n+\t\t\t\t  \"in FORMAT tag at %L\", &e->where)\n+\t\t  == FAILURE)\n \t\treturn FAILURE;\n \t    }\n \t  else\n \t    {\n-\t      if (gfc_notify_std (GFC_STD_LEGACY,\n-\t\t\t\"Extension: Non-character in FORMAT tag at %L\",\n-\t\t\t&e->where) == FAILURE)\n+\t      if (gfc_notify_std (GFC_STD_LEGACY, \"Extension: Non-character \"\n+\t\t\t\t  \"in FORMAT tag at %L\", &e->where)\n+\t\t  == FAILURE)\n \t\treturn FAILURE;\n \t    }\n \t  return SUCCESS;\n@@ -1115,16 +1114,16 @@ resolve_tag (const io_tag * tag, gfc_expr * e)\n       if (tag == &tag_iostat && e->ts.kind != gfc_default_integer_kind)\n \t{\n \t  if (gfc_notify_std (GFC_STD_GNU, \"Fortran 95 requires default \"\n-\t\t\t      \"INTEGER in IOSTAT tag at %L\",\n-\t\t\t      &e->where) == FAILURE)\n+\t\t\t      \"INTEGER in IOSTAT tag at %L\", &e->where)\n+\t      == FAILURE)\n \t    return FAILURE;\n \t}\n \n       if (tag == &tag_size && e->ts.kind != gfc_default_integer_kind)\n \t{\n \t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 95 requires default \"\n-\t\t\t      \"INTEGER in SIZE tag at %L\",\n-\t\t\t      &e->where) == FAILURE)\n+\t\t\t      \"INTEGER in SIZE tag at %L\", &e->where)\n+\t      == FAILURE)\n \t    return FAILURE;\n \t}\n \n@@ -1138,8 +1137,8 @@ resolve_tag (const io_tag * tag, gfc_expr * e)\n       if (tag == &tag_iolength && e->ts.kind != gfc_default_integer_kind)\n \t{\n \t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 95 requires default \"\n-\t\t\t      \"INTEGER in IOLENGTH tag at %L\",\n-\t\t\t      &e->where) == FAILURE)\n+\t\t\t      \"INTEGER in IOLENGTH tag at %L\", &e->where)\n+\t      == FAILURE)\n \t    return FAILURE;\n \t}\n     }\n@@ -1151,7 +1150,7 @@ resolve_tag (const io_tag * tag, gfc_expr * e)\n /* Match a single tag of an OPEN statement.  */\n \n static match\n-match_open_element (gfc_open * open)\n+match_open_element (gfc_open *open)\n {\n   match m;\n \n@@ -1208,9 +1207,8 @@ match_open_element (gfc_open * open)\n /* Free the gfc_open structure and all the expressions it contains.  */\n \n void\n-gfc_free_open (gfc_open * open)\n+gfc_free_open (gfc_open *open)\n {\n-\n   if (open == NULL)\n     return;\n \n@@ -1228,15 +1226,14 @@ gfc_free_open (gfc_open * open)\n   gfc_free_expr (open->delim);\n   gfc_free_expr (open->pad);\n   gfc_free_expr (open->convert);\n-\n   gfc_free (open);\n }\n \n \n /* Resolve everything in a gfc_open structure.  */\n \n try\n-gfc_resolve_open (gfc_open * open)\n+gfc_resolve_open (gfc_open *open)\n {\n \n   RESOLVE_TAG (&tag_unit, open->unit);\n@@ -1247,7 +1244,6 @@ gfc_resolve_open (gfc_open * open)\n   RESOLVE_TAG (&tag_e_access, open->access);\n   RESOLVE_TAG (&tag_e_form, open->form);\n   RESOLVE_TAG (&tag_e_recl, open->recl);\n-\n   RESOLVE_TAG (&tag_e_blank, open->blank);\n   RESOLVE_TAG (&tag_e_position, open->position);\n   RESOLVE_TAG (&tag_e_action, open->action);\n@@ -1262,20 +1258,20 @@ gfc_resolve_open (gfc_open * open)\n }\n \n \n-\n /* Check if a given value for a SPECIFIER is either in the list of values\n    allowed in F95 or F2003, issuing an error message and returning a zero\n    value if it is not allowed.  */\n+\n static int\n-compare_to_allowed_values (const char * specifier, const char * allowed[],\n-\t\t\t   const char * allowed_f2003[], \n-\t\t\t   const char * allowed_gnu[], char * value,\n-\t\t\t   const char * statement, bool warn)\n+compare_to_allowed_values (const char *specifier, const char *allowed[],\n+\t\t\t   const char *allowed_f2003[], \n+\t\t\t   const char *allowed_gnu[], char *value,\n+\t\t\t   const char *statement, bool warn)\n {\n   int i;\n   unsigned int len;\n \n-  len = strlen(value);\n+  len = strlen (value);\n   if (len > 0)\n   {\n     for (len--; len > 0; len--)\n@@ -1285,13 +1281,14 @@ compare_to_allowed_values (const char * specifier, const char * allowed[],\n   }\n \n   for (i = 0; allowed[i]; i++)\n-    if (len == strlen(allowed[i])\n-\t&& strncasecmp (value, allowed[i], strlen(allowed[i])) == 0)\n+    if (len == strlen (allowed[i])\n+\t&& strncasecmp (value, allowed[i], strlen (allowed[i])) == 0)\n       return 1;\n \n   for (i = 0; allowed_f2003 && allowed_f2003[i]; i++)\n-    if (len == strlen(allowed_f2003[i])\n-\t&& strncasecmp (value, allowed_f2003[i], strlen(allowed_f2003[i])) == 0)\n+    if (len == strlen (allowed_f2003[i])\n+\t&& strncasecmp (value, allowed_f2003[i], strlen (allowed_f2003[i]))\n+\t   == 0)\n       {\n \tnotification n = gfc_notification_std (GFC_STD_F2003);\n \n@@ -1316,8 +1313,8 @@ compare_to_allowed_values (const char * specifier, const char * allowed[],\n       }\n \n   for (i = 0; allowed_gnu && allowed_gnu[i]; i++)\n-    if (len == strlen(allowed_gnu[i])\n-\t&& strncasecmp (value, allowed_gnu[i], strlen(allowed_gnu[i])) == 0)\n+    if (len == strlen (allowed_gnu[i])\n+\t&& strncasecmp (value, allowed_gnu[i], strlen (allowed_gnu[i])) == 0)\n       {\n \tnotification n = gfc_notification_std (GFC_STD_GNU);\n \n@@ -1355,6 +1352,7 @@ compare_to_allowed_values (const char * specifier, const char * allowed[],\n     }\n }\n \n+\n /* Match an OPEN statement.  */\n \n match\n@@ -1410,9 +1408,9 @@ gfc_match_open (void)\n   /* Checks on the ACCESS specifier.  */\n   if (open->access && open->access->expr_type == EXPR_CONSTANT)\n     {\n-      static const char * access_f95[] = { \"SEQUENTIAL\", \"DIRECT\", NULL };\n-      static const char * access_f2003[] = { \"STREAM\", NULL };\n-      static const char * access_gnu[] = { \"APPEND\", NULL };\n+      static const char *access_f95[] = { \"SEQUENTIAL\", \"DIRECT\", NULL };\n+      static const char *access_f2003[] = { \"STREAM\", NULL };\n+      static const char *access_gnu[] = { \"APPEND\", NULL };\n \n       if (!compare_to_allowed_values (\"ACCESS\", access_f95, access_f2003,\n \t\t\t\t      access_gnu,\n@@ -1424,7 +1422,7 @@ gfc_match_open (void)\n   /* Checks on the ACTION specifier.  */\n   if (open->action && open->action->expr_type == EXPR_CONSTANT)\n     {\n-      static const char * action[] = { \"READ\", \"WRITE\", \"READWRITE\", NULL };\n+      static const char *action[] = { \"READ\", \"WRITE\", \"READWRITE\", NULL };\n \n       if (!compare_to_allowed_values (\"ACTION\", action, NULL, NULL,\n \t\t\t\t      open->action->value.character.string,\n@@ -1448,7 +1446,7 @@ gfc_match_open (void)\n   /* Checks on the BLANK specifier.  */\n   if (open->blank && open->blank->expr_type == EXPR_CONSTANT)\n     {\n-      static const char * blank[] = { \"ZERO\", \"NULL\", NULL };\n+      static const char *blank[] = { \"ZERO\", \"NULL\", NULL };\n \n       if (!compare_to_allowed_values (\"BLANK\", blank, NULL, NULL,\n \t\t\t\t      open->blank->value.character.string,\n@@ -1471,7 +1469,7 @@ gfc_match_open (void)\n   /* Checks on the DELIM specifier.  */\n   if (open->delim && open->delim->expr_type == EXPR_CONSTANT)\n     {\n-      static const char * delim[] = { \"APOSTROPHE\", \"QUOTE\", \"NONE\", NULL };\n+      static const char *delim[] = { \"APOSTROPHE\", \"QUOTE\", \"NONE\", NULL };\n \n       if (!compare_to_allowed_values (\"DELIM\", delim, NULL, NULL,\n \t\t\t\t      open->delim->value.character.string,\n@@ -1494,7 +1492,7 @@ gfc_match_open (void)\n   /* Checks on the FORM specifier.  */\n   if (open->form && open->form->expr_type == EXPR_CONSTANT)\n     {\n-      static const char * form[] = { \"FORMATTED\", \"UNFORMATTED\", NULL };\n+      static const char *form[] = { \"FORMATTED\", \"UNFORMATTED\", NULL };\n \n       if (!compare_to_allowed_values (\"FORM\", form, NULL, NULL,\n \t\t\t\t      open->form->value.character.string,\n@@ -1505,7 +1503,7 @@ gfc_match_open (void)\n   /* Checks on the PAD specifier.  */\n   if (open->pad && open->pad->expr_type == EXPR_CONSTANT)\n     {\n-      static const char * pad[] = { \"YES\", \"NO\", NULL };\n+      static const char *pad[] = { \"YES\", \"NO\", NULL };\n \n       if (!compare_to_allowed_values (\"PAD\", pad, NULL, NULL,\n \t\t\t\t      open->pad->value.character.string,\n@@ -1516,7 +1514,7 @@ gfc_match_open (void)\n   /* Checks on the POSITION specifier.  */\n   if (open->position && open->position->expr_type == EXPR_CONSTANT)\n     {\n-      static const char * position[] = { \"ASIS\", \"REWIND\", \"APPEND\", NULL };\n+      static const char *position[] = { \"ASIS\", \"REWIND\", \"APPEND\", NULL };\n \n       if (!compare_to_allowed_values (\"POSITION\", position, NULL, NULL,\n \t\t\t\t      open->position->value.character.string,\n@@ -1572,7 +1570,7 @@ gfc_match_open (void)\n   /* Checks on the STATUS specifier.  */\n   if (open->status && open->status->expr_type == EXPR_CONSTANT)\n     {\n-      static const char * status[] = { \"OLD\", \"NEW\", \"SCRATCH\",\n+      static const char *status[] = { \"OLD\", \"NEW\", \"SCRATCH\",\n \t\"REPLACE\", \"UNKNOWN\", NULL };\n \n       if (!compare_to_allowed_values (\"STATUS\", status, NULL, NULL,\n@@ -1581,23 +1579,25 @@ gfc_match_open (void)\n \tgoto cleanup;\n \n       /* F2003, 9.4.5: If the STATUS= specifier has the value NEW or REPLACE,\n-         the FILE= specifier shall appear.  */\n-      if (open->file == NULL &&\n-\t  (strncasecmp (open->status->value.character.string, \"replace\", 7) == 0\n-\t  || strncasecmp (open->status->value.character.string, \"new\", 3) == 0))\n+\t the FILE= specifier shall appear.  */\n+      if (open->file == NULL\n+\t  && (strncasecmp (open->status->value.character.string, \"replace\", 7)\n+\t      == 0\n+\t     || strncasecmp (open->status->value.character.string, \"new\", 3)\n+\t\t== 0))\n \t{\n-\t  warn_or_error (\"The STATUS specified in OPEN statement at %C is '%s' \"\n-\t\t\t \"and no FILE specifier is present\",\n+\t  warn_or_error (\"The STATUS specified in OPEN statement at %C is \"\n+\t\t\t \"'%s' and no FILE specifier is present\",\n \t\t\t open->status->value.character.string);\n \t}\n \n       /* F2003, 9.4.5: If the STATUS= specifier has the value SCRATCH,\n \t the FILE= specifier shall not appear.  */\n-      if (strncasecmp (open->status->value.character.string, \"scratch\", 7) == 0\n-\t  && open->file)\n+      if (strncasecmp (open->status->value.character.string, \"scratch\", 7)\n+\t  == 0 && open->file)\n \t{\n-\t  warn_or_error (\"The STATUS specified in OPEN statement at %C cannot \"\n-\t\t\t \"have the value SCRATCH if a FILE specifier \"\n+\t  warn_or_error (\"The STATUS specified in OPEN statement at %C \"\n+\t\t\t \"cannot have the value SCRATCH if a FILE specifier \"\n \t\t\t \"is present\");\n \t}\n     }\n@@ -1612,10 +1612,11 @@ gfc_match_open (void)\n       && strncasecmp (open->form->value.character.string,\n \t\t      \"unformatted\", 11) == 0)\n     {\n-      const char * spec = (open->delim ? \"DELIM \" : (open->pad ? \"PAD \" :\n-\t    open->blank ? \"BLANK \" : \"\"));\n+      const char *spec = (open->delim ? \"DELIM \"\n+\t\t\t\t      : (open->pad ? \"PAD \" : open->blank\n+\t\t\t\t\t\t\t    ? \"BLANK \" : \"\"));\n \n-      warn_or_error (\"%sspecifier at %C not allowed in OPEN statement for \"\n+      warn_or_error (\"%s specifier at %C not allowed in OPEN statement for \"\n \t\t     \"unformatted I/O\", spec);\n     }\n \n@@ -1626,7 +1627,8 @@ gfc_match_open (void)\n \t\t     \"stream I/O\");\n     }\n \n-  if (open->position && open->access && open->access->expr_type == EXPR_CONSTANT\n+  if (open->position\n+      && open->access && open->access->expr_type == EXPR_CONSTANT\n       && !(strncasecmp (open->access->value.character.string,\n \t\t\t\"sequential\", 10) == 0\n \t   || strncasecmp (open->access->value.character.string,\n@@ -1656,25 +1658,23 @@ gfc_match_open (void)\n /* Free a gfc_close structure an all its expressions.  */\n \n void\n-gfc_free_close (gfc_close * close)\n+gfc_free_close (gfc_close *close)\n {\n-\n   if (close == NULL)\n     return;\n \n   gfc_free_expr (close->unit);\n   gfc_free_expr (close->iomsg);\n   gfc_free_expr (close->iostat);\n   gfc_free_expr (close->status);\n-\n   gfc_free (close);\n }\n \n \n /* Match elements of a CLOSE statement.  */\n \n static match\n-match_close_element (gfc_close * close)\n+match_close_element (gfc_close *close)\n {\n   match m;\n \n@@ -1754,7 +1754,7 @@ gfc_match_close (void)\n   /* Checks on the STATUS specifier.  */\n   if (close->status && close->status->expr_type == EXPR_CONSTANT)\n     {\n-      static const char * status[] = { \"KEEP\", \"DELETE\", NULL };\n+      static const char *status[] = { \"KEEP\", \"DELETE\", NULL };\n \n       if (!compare_to_allowed_values (\"STATUS\", status, NULL, NULL,\n \t\t\t\t      close->status->value.character.string,\n@@ -1778,9 +1778,8 @@ gfc_match_close (void)\n /* Resolve everything in a gfc_close structure.  */\n \n try\n-gfc_resolve_close (gfc_close * close)\n+gfc_resolve_close (gfc_close *close)\n {\n-\n   RESOLVE_TAG (&tag_unit, close->unit);\n   RESOLVE_TAG (&tag_iomsg, close->iomsg);\n   RESOLVE_TAG (&tag_iostat, close->iostat);\n@@ -1796,9 +1795,8 @@ gfc_resolve_close (gfc_close * close)\n /* Free a gfc_filepos structure.  */\n \n void\n-gfc_free_filepos (gfc_filepos * fp)\n+gfc_free_filepos (gfc_filepos *fp)\n {\n-\n   gfc_free_expr (fp->unit);\n   gfc_free_expr (fp->iomsg);\n   gfc_free_expr (fp->iostat);\n@@ -1809,7 +1807,7 @@ gfc_free_filepos (gfc_filepos * fp)\n /* Match elements of a REWIND, BACKSPACE, ENDFILE, or FLUSH statement.  */\n \n static match\n-match_file_element (gfc_filepos * fp)\n+match_file_element (gfc_filepos *fp)\n {\n   match m;\n \n@@ -1904,9 +1902,8 @@ match_filepos (gfc_statement st, gfc_exec_op op)\n \n \n try\n-gfc_resolve_filepos (gfc_filepos * fp)\n+gfc_resolve_filepos (gfc_filepos *fp)\n {\n-\n   RESOLVE_TAG (&tag_unit, fp->unit);\n   RESOLVE_TAG (&tag_iostat, fp->iostat);\n   RESOLVE_TAG (&tag_iomsg, fp->iomsg);\n@@ -1923,28 +1920,26 @@ gfc_resolve_filepos (gfc_filepos * fp)\n match\n gfc_match_endfile (void)\n {\n-\n   return match_filepos (ST_END_FILE, EXEC_ENDFILE);\n }\n \n match\n gfc_match_backspace (void)\n {\n-\n   return match_filepos (ST_BACKSPACE, EXEC_BACKSPACE);\n }\n \n match\n gfc_match_rewind (void)\n {\n-\n   return match_filepos (ST_REWIND, EXEC_REWIND);\n }\n \n match\n gfc_match_flush (void)\n {\n-  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: FLUSH statement at %C\") == FAILURE)\n+  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: FLUSH statement at %C\")\n+      == FAILURE)\n     return MATCH_ERROR;\n \n   return match_filepos (ST_FLUSH, EXEC_FLUSH);\n@@ -1976,7 +1971,7 @@ default_unit (io_kind k)\n /* Match a unit specification for a data transfer statement.  */\n \n static match\n-match_dt_unit (io_kind k, gfc_dt * dt)\n+match_dt_unit (io_kind k, gfc_dt *dt)\n {\n   gfc_expr *e;\n \n@@ -2012,7 +2007,7 @@ match_dt_unit (io_kind k, gfc_dt * dt)\n /* Match a format specification.  */\n \n static match\n-match_dt_format (gfc_dt * dt)\n+match_dt_format (gfc_dt *dt)\n {\n   locus where;\n   gfc_expr *e;\n@@ -2070,7 +2065,7 @@ match_dt_format (gfc_dt * dt)\n    nonzero if we find such a variable.  */\n \n static int\n-check_namelist (gfc_symbol * sym)\n+check_namelist (gfc_symbol *sym)\n {\n   gfc_namelist *p;\n \n@@ -2089,7 +2084,7 @@ check_namelist (gfc_symbol * sym)\n /* Match a single data transfer element.  */\n \n static match\n-match_dt_element (io_kind k, gfc_dt * dt)\n+match_dt_element (io_kind k, gfc_dt *dt)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symbol *sym;\n@@ -2163,8 +2158,8 @@ match_dt_element (io_kind k, gfc_dt * dt)\n     {\n       if (k == M_WRITE)\n        {\n-         gfc_error (\"END tag at %C not allowed in output statement\");\n-         return MATCH_ERROR;\n+\t gfc_error (\"END tag at %C not allowed in output statement\");\n+\t return MATCH_ERROR;\n        }\n       dt->end_where = gfc_current_locus;\n     }\n@@ -2184,9 +2179,8 @@ match_dt_element (io_kind k, gfc_dt * dt)\n /* Free a data transfer structure and everything below it.  */\n \n void\n-gfc_free_dt (gfc_dt * dt)\n+gfc_free_dt (gfc_dt *dt)\n {\n-\n   if (dt == NULL)\n     return;\n \n@@ -2197,15 +2191,14 @@ gfc_free_dt (gfc_dt * dt)\n   gfc_free_expr (dt->iomsg);\n   gfc_free_expr (dt->iostat);\n   gfc_free_expr (dt->size);\n-\n   gfc_free (dt);\n }\n \n \n /* Resolve everything in a gfc_dt structure.  */\n \n try\n-gfc_resolve_dt (gfc_dt * dt)\n+gfc_resolve_dt (gfc_dt *dt)\n {\n   gfc_expr *e;\n \n@@ -2220,21 +2213,18 @@ gfc_resolve_dt (gfc_dt * dt)\n   e = dt->io_unit;\n   if (gfc_resolve_expr (e) == SUCCESS\n       && (e->ts.type != BT_INTEGER\n-\t  && (e->ts.type != BT_CHARACTER\n-\t      || e->expr_type != EXPR_VARIABLE)))\n+\t  && (e->ts.type != BT_CHARACTER || e->expr_type != EXPR_VARIABLE)))\n     {\n-      gfc_error\n-\t(\"UNIT specification at %L must be an INTEGER expression or a \"\n-\t \"CHARACTER variable\", &e->where);\n+      gfc_error (\"UNIT specification at %L must be an INTEGER expression \"\n+\t\t \"or a CHARACTER variable\", &e->where);\n       return FAILURE;\n     }\n \n   if (e->ts.type == BT_CHARACTER)\n     {\n       if (gfc_has_vector_index (e))\n \t{\n-\t  gfc_error (\"Internal unit with vector subscript at %L\",\n-\t\t     &e->where);\n+\t  gfc_error (\"Internal unit with vector subscript at %L\", &e->where);\n \t  return FAILURE;\n \t}\n     }\n@@ -2286,7 +2276,7 @@ gfc_resolve_dt (gfc_dt * dt)\n       && dt->format_label->defined == ST_LABEL_UNKNOWN)\n     {\n       gfc_error (\"FORMAT label %d at %L not defined\", dt->format_label->value,\n-\t         &dt->format_label->where);\n+\t\t &dt->format_label->where);\n       return FAILURE;\n     }\n   return SUCCESS;\n@@ -2329,10 +2319,10 @@ io_kind_name (io_kind k)\n    which is equivalent to a single IO element.  This function is\n    mutually recursive with match_io_element().  */\n \n-static match match_io_element (io_kind k, gfc_code **);\n+static match match_io_element (io_kind, gfc_code **);\n \n static match\n-match_io_iterator (io_kind k, gfc_code ** result)\n+match_io_iterator (io_kind k, gfc_code **result)\n {\n   gfc_code *head, *tail, *new;\n   gfc_iterator *iter;\n@@ -2421,7 +2411,7 @@ match_io_iterator (io_kind k, gfc_code ** result)\n    expression or an IO Iterator.  */\n \n static match\n-match_io_element (io_kind k, gfc_code ** cpp)\n+match_io_element (io_kind k, gfc_code **cpp)\n {\n   gfc_expr *expr;\n   gfc_code *cp;\n@@ -2453,9 +2443,8 @@ match_io_element (io_kind k, gfc_code ** cpp)\n       case M_READ:\n \tif (expr->symtree->n.sym->attr.intent == INTENT_IN)\n \t  {\n-\t    gfc_error\n-\t      (\"Variable '%s' in input list at %C cannot be INTENT(IN)\",\n-\t       expr->symtree->n.sym->name);\n+\t    gfc_error (\"Variable '%s' in input list at %C cannot be \"\n+\t\t       \"INTENT(IN)\", expr->symtree->n.sym->name);\n \t    m = MATCH_ERROR;\n \t  }\n \n@@ -2479,9 +2468,9 @@ match_io_element (io_kind k, gfc_code ** cpp)\n \t    && current_dt->io_unit->expr_type == EXPR_VARIABLE\n \t    && gfc_impure_variable (current_dt->io_unit->symtree->n.sym))\n \t  {\n-\t    gfc_error\n-\t      (\"Cannot write to internal file unit '%s' at %C inside a \"\n-\t       \"PURE procedure\", current_dt->io_unit->symtree->n.sym->name);\n+\t    gfc_error (\"Cannot write to internal file unit '%s' at %C \"\n+\t\t       \"inside a PURE procedure\",\n+\t\t       current_dt->io_unit->symtree->n.sym->name);\n \t    m = MATCH_ERROR;\n \t  }\n \n@@ -2509,7 +2498,7 @@ match_io_element (io_kind k, gfc_code ** cpp)\n /* Match an I/O list, building gfc_code structures as we go.  */\n \n static match\n-match_io_list (io_kind k, gfc_code ** head_p)\n+match_io_list (io_kind k, gfc_code **head_p)\n {\n   gfc_code *head, *tail, *new;\n   match m;\n@@ -2551,7 +2540,7 @@ match_io_list (io_kind k, gfc_code ** head_p)\n /* Attach the data transfer end node.  */\n \n static void\n-terminate_io (gfc_code * io_code)\n+terminate_io (gfc_code *io_code)\n {\n   gfc_code *c;\n \n@@ -2572,7 +2561,8 @@ terminate_io (gfc_code * io_code)\n    in resolve_tag and others in gfc_resolve_dt.  */\n \n static match\n-check_io_constraints (io_kind k, gfc_dt *dt, gfc_code * io_code, locus * spec_end)\n+check_io_constraints (io_kind k, gfc_dt *dt, gfc_code *io_code,\n+\t\t      locus *spec_end)\n {\n #define io_constraint(condition,msg,arg)\\\n if (condition) \\\n@@ -2582,14 +2572,14 @@ if (condition) \\\n   }\n \n   match m;\n-  gfc_expr * expr;\n-  gfc_symbol * sym = NULL;\n+  gfc_expr *expr;\n+  gfc_symbol *sym = NULL;\n \n   m = MATCH_YES;\n \n   expr = dt->io_unit;\n   if (expr && expr->expr_type == EXPR_VARIABLE\n-\t&& expr->ts.type == BT_CHARACTER)\n+      && expr->ts.type == BT_CHARACTER)\n     {\n       sym = expr->symtree->n.sym;\n \n@@ -2606,12 +2596,12 @@ if (condition) \\\n \t\t     &dt->rec->where);\n \n       if (dt->namelist != NULL)\n-        {\n-          if (gfc_notify_std(GFC_STD_F2003,\n-                         \"Fortran 2003: Internal file at %L with namelist\",\n-                         &expr->where) == FAILURE)\n-            m = MATCH_ERROR;\n-        }\n+\t{\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Internal file \"\n+\t\t\t      \"at %L with namelist\", &expr->where)\n+\t      == FAILURE)\n+\t    m = MATCH_ERROR;\n+\t}\n \n       io_constraint (dt->advance != NULL,\n \t\t     \"ADVANCE tag at %L is incompatible with internal file\",\n@@ -2621,8 +2611,7 @@ if (condition) \\\n   if (expr && expr->ts.type != BT_CHARACTER)\n     {\n \n-      io_constraint (gfc_pure (NULL)\n-\t\t       && (k == M_READ || k == M_WRITE),\n+      io_constraint (gfc_pure (NULL) && (k == M_READ || k == M_WRITE),\n \t\t     \"IO UNIT in %s statement at %C must be \"\n \t\t     \"an internal file in a PURE procedure\",\n \t\t     io_kind_name (k));\n@@ -2631,12 +2620,10 @@ if (condition) \\\n \n   if (k != M_READ)\n     {\n-      io_constraint (dt->end,\n-\t\t     \"END tag not allowed with output at %L\",\n+      io_constraint (dt->end, \"END tag not allowed with output at %L\",\n \t\t     &dt->end_where);\n \n-      io_constraint (dt->eor,\n-\t\t     \"EOR tag not allowed with output at %L\",\n+      io_constraint (dt->eor, \"EOR tag not allowed with output at %L\",\n \t\t     &dt->eor_where);\n \n       io_constraint (k != M_READ && dt->size,\n@@ -2701,9 +2688,8 @@ if (condition) \\\n \t\t     \"List directed format(*) is not allowed with a \"\n \t\t     \"ADVANCE=specifier at %L.\", &expr->where);\n \n-      io_constraint (dt->format_expr == NULL\n-\t\t       && dt->format_label == NULL\n-\t\t       && dt->namelist == NULL,\n+      io_constraint (dt->format_expr == NULL && dt->format_label == NULL\n+\t\t     && dt->namelist == NULL,\n \t\t     \"the ADVANCE=specifier at %L must appear with an \"\n \t\t     \"explicit format expression\", &expr->where);\n \n@@ -2740,6 +2726,7 @@ if (condition) \\\n }\n #undef io_constraint\n \n+\n /* Match a READ, WRITE or PRINT statement.  */\n \n static match\n@@ -2812,7 +2799,6 @@ match_io (io_kind k)\n     {\n       /* Before issuing an error for a malformed 'print (1,*)' type of\n \t error, check for a default-char-expr of the form ('(I0)').  */\n-\n       if (k == M_PRINT && m == MATCH_YES)\n \t{\n \t  /* Reset current locus to get the initial '(' in an expression.  */\n@@ -2988,7 +2974,7 @@ gfc_match_print (void)\n /* Free a gfc_inquire structure.  */\n \n void\n-gfc_free_inquire (gfc_inquire * inquire)\n+gfc_free_inquire (gfc_inquire *inquire)\n {\n \n   if (inquire == NULL)\n@@ -3022,7 +3008,6 @@ gfc_free_inquire (gfc_inquire * inquire)\n   gfc_free_expr (inquire->iolength);\n   gfc_free_expr (inquire->convert);\n   gfc_free_expr (inquire->strm_pos);\n-\n   gfc_free (inquire);\n }\n \n@@ -3032,7 +3017,7 @@ gfc_free_inquire (gfc_inquire * inquire)\n #define RETM   if (m != MATCH_NO) return m;\n \n static match\n-match_inquire_element (gfc_inquire * inquire)\n+match_inquire_element (gfc_inquire *inquire)\n {\n   match m;\n \n@@ -3155,15 +3140,15 @@ gfc_match_inquire (void)\n \n   if (inquire->unit != NULL && inquire->file != NULL)\n     {\n-      gfc_error (\"INQUIRE statement at %L cannot contain both FILE and\"\n-\t\t \" UNIT specifiers\", &loc);\n+      gfc_error (\"INQUIRE statement at %L cannot contain both FILE and \"\n+\t\t \"UNIT specifiers\", &loc);\n       goto cleanup;\n     }\n \n   if (inquire->unit == NULL && inquire->file == NULL)\n     {\n-      gfc_error (\"INQUIRE statement at %L requires either FILE or\"\n-\t\t     \" UNIT specifier\", &loc);\n+      gfc_error (\"INQUIRE statement at %L requires either FILE or \"\n+\t\t \"UNIT specifier\", &loc);\n       goto cleanup;\n     }\n \n@@ -3189,9 +3174,8 @@ gfc_match_inquire (void)\n /* Resolve everything in a gfc_inquire structure.  */\n \n try\n-gfc_resolve_inquire (gfc_inquire * inquire)\n+gfc_resolve_inquire (gfc_inquire *inquire)\n {\n-\n   RESOLVE_TAG (&tag_unit, inquire->unit);\n   RESOLVE_TAG (&tag_file, inquire->file);\n   RESOLVE_TAG (&tag_iomsg, inquire->iomsg);"}, {"sha": "63741f2ba6f8397fe9e03c5cfb92a9c351b013c5", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 582, "deletions": 617, "changes": 1199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b251af97928db06c0a2174b230a3ae9f83745a04/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b251af97928db06c0a2174b230a3ae9f83745a04/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=b251af97928db06c0a2174b230a3ae9f83745a04", "patch": "@@ -1,5 +1,5 @@\n /* Intrinsic function resolution.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught & Katherine Holcomb\n \n@@ -35,7 +35,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"gfortran.h\"\n #include \"intrinsic.h\"\n \n-\n /* Given printf-like arguments, return a stable version of the result string. \n \n    We already have a working, optimized string hashing table in the form of\n@@ -51,9 +50,9 @@ gfc_get_string (const char *format, ...)\n   tree ident;\n \n   va_start (ap, format);\n-  vsnprintf (temp_name, sizeof(temp_name), format, ap);\n+  vsnprintf (temp_name, sizeof (temp_name), format, ap);\n   va_end (ap);\n-  temp_name[sizeof(temp_name)-1] = 0;\n+  temp_name[sizeof (temp_name) - 1] = 0;\n \n   ident = get_identifier (temp_name);\n   return IDENTIFIER_POINTER (ident);\n@@ -78,77 +77,78 @@ check_charlen_present (gfc_expr *source)\n \n \n void\n-gfc_resolve_abs (gfc_expr * f, gfc_expr * a)\n+gfc_resolve_abs (gfc_expr *f, gfc_expr *a)\n {\n   f->ts = a->ts;\n   if (f->ts.type == BT_COMPLEX)\n     f->ts.type = BT_REAL;\n \n-  f->value.function.name =\n-    gfc_get_string (\"__abs_%c%d\", gfc_type_letter (a->ts.type), a->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__abs_%c%d\", gfc_type_letter (a->ts.type), a->ts.kind);\n }\n \n \n void\n-gfc_resolve_access (gfc_expr * f, gfc_expr * name ATTRIBUTE_UNUSED,\n-\t            gfc_expr * mode ATTRIBUTE_UNUSED)\n+gfc_resolve_access (gfc_expr *f, gfc_expr *name ATTRIBUTE_UNUSED,\n+\t\t    gfc_expr *mode ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_c_int_kind;\n-  f->value.function.name = PREFIX(\"access_func\");\n+  f->value.function.name = PREFIX (\"access_func\");\n }\n \n \n void\n-gfc_resolve_acos (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_acos (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__acos_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__acos_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n }\n \n \n void\n-gfc_resolve_acosh (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_acosh (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__acosh_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__acosh_%c%d\", gfc_type_letter (x->ts.type),\n+\t\t      x->ts.kind);\n }\n \n \n void\n-gfc_resolve_aimag (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_aimag (gfc_expr *f, gfc_expr *x)\n {\n   f->ts.type = BT_REAL;\n   f->ts.kind = x->ts.kind;\n-  f->value.function.name =\n-    gfc_get_string (\"__aimag_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__aimag_%c%d\", gfc_type_letter (x->ts.type),\n+\t\t      x->ts.kind);\n }\n \n \n void\n-gfc_resolve_and (gfc_expr * f, gfc_expr * i, gfc_expr * j)\n+gfc_resolve_and (gfc_expr *f, gfc_expr *i, gfc_expr *j)\n {\n   f->ts.type = i->ts.type;\n-  f->ts.kind = gfc_kind_max (i,j);\n+  f->ts.kind = gfc_kind_max (i, j);\n \n   if (i->ts.kind != j->ts.kind)\n     {\n-      if (i->ts.kind == gfc_kind_max (i,j))\n-\tgfc_convert_type(j, &i->ts, 2);\n+      if (i->ts.kind == gfc_kind_max (i, j))\n+\tgfc_convert_type (j, &i->ts, 2);\n       else\n-\tgfc_convert_type(i, &j->ts, 2);\n+\tgfc_convert_type (i, &j->ts, 2);\n     }\n \n-  f->value.function.name = gfc_get_string (\"__and_%c%d\",\n-\t\t\t\t\t   gfc_type_letter (i->ts.type),\n-\t\t\t\t\t   f->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__and_%c%d\", gfc_type_letter (i->ts.type), f->ts.kind);\n }\n \n \n void\n-gfc_resolve_aint (gfc_expr * f, gfc_expr * a, gfc_expr * kind)\n+gfc_resolve_aint (gfc_expr *f, gfc_expr *a, gfc_expr *kind)\n {\n   gfc_typespec ts;\n   \n@@ -163,20 +163,20 @@ gfc_resolve_aint (gfc_expr * f, gfc_expr * a, gfc_expr * kind)\n     }\n   /* The resolved name is only used for specific intrinsics where\n      the return kind is the same as the arg kind.  */\n-  f->value.function.name =\n-    gfc_get_string (\"__aint_%c%d\", gfc_type_letter (a->ts.type), a->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__aint_%c%d\", gfc_type_letter (a->ts.type), a->ts.kind);\n }\n \n \n void\n-gfc_resolve_dint (gfc_expr * f, gfc_expr * a)\n+gfc_resolve_dint (gfc_expr *f, gfc_expr *a)\n {\n   gfc_resolve_aint (f, a, NULL);\n }\n \n \n void\n-gfc_resolve_all (gfc_expr * f, gfc_expr * mask, gfc_expr * dim)\n+gfc_resolve_all (gfc_expr *f, gfc_expr *mask, gfc_expr *dim)\n {\n   f->ts = mask->ts;\n \n@@ -187,14 +187,14 @@ gfc_resolve_all (gfc_expr * f, gfc_expr * mask, gfc_expr * dim)\n       f->shape = gfc_copy_shape_excluding (mask->shape, mask->rank, dim);\n     }\n \n-  f->value.function.name =\n-    gfc_get_string (PREFIX(\"all_%c%d\"), gfc_type_letter (mask->ts.type),\n-\t\t    mask->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (PREFIX (\"all_%c%d\"), gfc_type_letter (mask->ts.type),\n+\t\t      mask->ts.kind);\n }\n \n \n void\n-gfc_resolve_anint (gfc_expr * f, gfc_expr * a, gfc_expr * kind)\n+gfc_resolve_anint (gfc_expr *f, gfc_expr *a, gfc_expr *kind)\n {\n   gfc_typespec ts;\n   \n@@ -210,20 +210,21 @@ gfc_resolve_anint (gfc_expr * f, gfc_expr * a, gfc_expr * kind)\n \n   /* The resolved name is only used for specific intrinsics where\n      the return kind is the same as the arg kind.  */\n-  f->value.function.name =\n-    gfc_get_string (\"__anint_%c%d\", gfc_type_letter (a->ts.type), a->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__anint_%c%d\", gfc_type_letter (a->ts.type),\n+\t\t      a->ts.kind);\n }\n \n \n void\n-gfc_resolve_dnint (gfc_expr * f, gfc_expr * a)\n+gfc_resolve_dnint (gfc_expr *f, gfc_expr *a)\n {\n   gfc_resolve_anint (f, a, NULL);\n }\n \n \n void\n-gfc_resolve_any (gfc_expr * f, gfc_expr * mask, gfc_expr * dim)\n+gfc_resolve_any (gfc_expr *f, gfc_expr *mask, gfc_expr *dim)\n {\n   f->ts = mask->ts;\n \n@@ -234,58 +235,60 @@ gfc_resolve_any (gfc_expr * f, gfc_expr * mask, gfc_expr * dim)\n       f->shape = gfc_copy_shape_excluding (mask->shape, mask->rank, dim);\n     }\n \n-  f->value.function.name =\n-    gfc_get_string (PREFIX(\"any_%c%d\"), gfc_type_letter (mask->ts.type),\n-\t\t    mask->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (PREFIX (\"any_%c%d\"), gfc_type_letter (mask->ts.type),\n+\t\t      mask->ts.kind);\n }\n \n \n void\n-gfc_resolve_asin (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_asin (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__asin_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__asin_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n }\n \n void\n-gfc_resolve_asinh (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_asinh (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__asinh_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__asinh_%c%d\", gfc_type_letter (x->ts.type),\n+\t\t      x->ts.kind);\n }\n \n void\n-gfc_resolve_atan (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_atan (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__atan_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__atan_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n }\n \n void\n-gfc_resolve_atanh (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_atanh (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__atanh_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__atanh_%c%d\", gfc_type_letter (x->ts.type),\n+\t\t      x->ts.kind);\n }\n \n void\n-gfc_resolve_atan2 (gfc_expr * f, gfc_expr * x,\n-\t\t   gfc_expr * y ATTRIBUTE_UNUSED)\n+gfc_resolve_atan2 (gfc_expr *f, gfc_expr *x, gfc_expr *y ATTRIBUTE_UNUSED)\n {\n   f->ts = x->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__atan2_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__atan2_%c%d\", gfc_type_letter (x->ts.type),\n+\t\t      x->ts.kind);\n }\n \n \n /* Resolve the BESYN and BESJN intrinsics.  */\n \n void\n-gfc_resolve_besn (gfc_expr * f, gfc_expr * n, gfc_expr * x)\n+gfc_resolve_besn (gfc_expr *f, gfc_expr *n, gfc_expr *x)\n {\n   gfc_typespec ts;\n   \n@@ -301,53 +304,50 @@ gfc_resolve_besn (gfc_expr * f, gfc_expr * n, gfc_expr * x)\n \n \n void\n-gfc_resolve_btest (gfc_expr * f, gfc_expr * i, gfc_expr * pos)\n+gfc_resolve_btest (gfc_expr *f, gfc_expr *i, gfc_expr *pos)\n {\n   f->ts.type = BT_LOGICAL;\n   f->ts.kind = gfc_default_logical_kind;\n-\n-  f->value.function.name = gfc_get_string (\"__btest_%d_%d\", i->ts.kind,\n-\t\t\t\t\t   pos->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__btest_%d_%d\", i->ts.kind, pos->ts.kind);\n }\n \n \n void\n-gfc_resolve_ceiling (gfc_expr * f, gfc_expr * a, gfc_expr * kind)\n+gfc_resolve_ceiling (gfc_expr *f, gfc_expr *a, gfc_expr *kind)\n {\n   f->ts.type = BT_INTEGER;\n-  f->ts.kind = (kind == NULL) ? gfc_default_integer_kind\n-    : mpz_get_si (kind->value.integer);\n-\n-  f->value.function.name =\n-    gfc_get_string (\"__ceiling_%d_%c%d\", f->ts.kind,\n-\t\t    gfc_type_letter (a->ts.type), a->ts.kind);\n+  f->ts.kind = (kind == NULL)\n+\t     ? gfc_default_integer_kind : mpz_get_si (kind->value.integer);\n+  f->value.function.name\n+    = gfc_get_string (\"__ceiling_%d_%c%d\", f->ts.kind,\n+\t\t      gfc_type_letter (a->ts.type), a->ts.kind);\n }\n \n \n void\n-gfc_resolve_char (gfc_expr * f, gfc_expr * a, gfc_expr * kind)\n+gfc_resolve_char (gfc_expr *f, gfc_expr *a, gfc_expr *kind)\n {\n   f->ts.type = BT_CHARACTER;\n-  f->ts.kind = (kind == NULL) ? gfc_default_character_kind\n-    : mpz_get_si (kind->value.integer);\n-\n-  f->value.function.name =\n-    gfc_get_string (\"__char_%d_%c%d\", f->ts.kind,\n-\t\t    gfc_type_letter (a->ts.type), a->ts.kind);\n+  f->ts.kind = (kind == NULL)\n+\t     ? gfc_default_character_kind : mpz_get_si (kind->value.integer);\n+  f->value.function.name\n+    = gfc_get_string (\"__char_%d_%c%d\", f->ts.kind,\n+\t\t      gfc_type_letter (a->ts.type), a->ts.kind);\n }\n \n \n void\n-gfc_resolve_chdir (gfc_expr * f, gfc_expr * d ATTRIBUTE_UNUSED)\n+gfc_resolve_chdir (gfc_expr *f, gfc_expr *d ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n-  f->value.function.name = gfc_get_string (PREFIX(\"chdir_i%d\"), f->ts.kind);\n+  f->value.function.name = gfc_get_string (PREFIX (\"chdir_i%d\"), f->ts.kind);\n }\n \n \n void\n-gfc_resolve_chdir_sub (gfc_code * c)\n+gfc_resolve_chdir_sub (gfc_code *c)\n {\n   const char *name;\n   int kind;\n@@ -357,23 +357,23 @@ gfc_resolve_chdir_sub (gfc_code * c)\n   else\n     kind = gfc_default_integer_kind;\n \n-  name = gfc_get_string (PREFIX(\"chdir_i%d_sub\"), kind);\n+  name = gfc_get_string (PREFIX (\"chdir_i%d_sub\"), kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n void\n-gfc_resolve_chmod (gfc_expr * f, gfc_expr * name ATTRIBUTE_UNUSED,\n-\t\t   gfc_expr * mode ATTRIBUTE_UNUSED)\n+gfc_resolve_chmod (gfc_expr *f, gfc_expr *name ATTRIBUTE_UNUSED,\n+\t\t   gfc_expr *mode ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_c_int_kind;\n-  f->value.function.name = PREFIX(\"chmod_func\");\n+  f->value.function.name = PREFIX (\"chmod_func\");\n }\n \n \n void\n-gfc_resolve_chmod_sub (gfc_code * c)\n+gfc_resolve_chmod_sub (gfc_code *c)\n {\n   const char *name;\n   int kind;\n@@ -383,37 +383,39 @@ gfc_resolve_chmod_sub (gfc_code * c)\n   else\n     kind = gfc_default_integer_kind;\n \n-  name = gfc_get_string (PREFIX(\"chmod_i%d_sub\"), kind);\n+  name = gfc_get_string (PREFIX (\"chmod_i%d_sub\"), kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n void\n-gfc_resolve_cmplx (gfc_expr * f, gfc_expr * x, gfc_expr * y, gfc_expr * kind)\n+gfc_resolve_cmplx (gfc_expr *f, gfc_expr *x, gfc_expr *y, gfc_expr *kind)\n {\n   f->ts.type = BT_COMPLEX;\n-  f->ts.kind = (kind == NULL) ? gfc_default_real_kind\n-    : mpz_get_si (kind->value.integer);\n+  f->ts.kind = (kind == NULL)\n+\t     ? gfc_default_real_kind : mpz_get_si (kind->value.integer);\n \n   if (y == NULL)\n-    f->value.function.name =\n-      gfc_get_string (\"__cmplx0_%d_%c%d\", f->ts.kind,\n-\t\t      gfc_type_letter (x->ts.type), x->ts.kind);\n+    f->value.function.name\n+      = gfc_get_string (\"__cmplx0_%d_%c%d\", f->ts.kind,\n+\t\t\tgfc_type_letter (x->ts.type), x->ts.kind);\n   else\n-    f->value.function.name =\n-      gfc_get_string (\"__cmplx1_%d_%c%d_%c%d\", f->ts.kind,\n-\t\t      gfc_type_letter (x->ts.type), x->ts.kind,\n-\t\t      gfc_type_letter (y->ts.type), y->ts.kind);\n+    f->value.function.name\n+      = gfc_get_string (\"__cmplx1_%d_%c%d_%c%d\", f->ts.kind,\n+\t\t\tgfc_type_letter (x->ts.type), x->ts.kind,\n+\t\t\tgfc_type_letter (y->ts.type), y->ts.kind);\n }\n \n+\n void\n-gfc_resolve_dcmplx (gfc_expr * f, gfc_expr * x, gfc_expr * y)\n+gfc_resolve_dcmplx (gfc_expr *f, gfc_expr *x, gfc_expr *y)\n {\n   gfc_resolve_cmplx (f, x, y, gfc_int_expr (gfc_default_double_kind));\n }\n \n+\n void\n-gfc_resolve_complex (gfc_expr * f, gfc_expr * x, gfc_expr * y)\n+gfc_resolve_complex (gfc_expr *f, gfc_expr *x, gfc_expr *y)\n {\n   int kind;\n \n@@ -434,42 +436,41 @@ gfc_resolve_complex (gfc_expr * f, gfc_expr * x, gfc_expr * y)\n \n   f->ts.type = BT_COMPLEX;\n   f->ts.kind = kind;\n-\n-  f->value.function.name =\n-    gfc_get_string (\"__cmplx1_%d_%c%d_%c%d\", f->ts.kind,\n-\t\t    gfc_type_letter (x->ts.type), x->ts.kind,\n-\t\t    gfc_type_letter (y->ts.type), y->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__cmplx1_%d_%c%d_%c%d\", f->ts.kind,\n+\t\t      gfc_type_letter (x->ts.type), x->ts.kind,\n+\t\t      gfc_type_letter (y->ts.type), y->ts.kind);\n }\n \n \n void\n-gfc_resolve_conjg (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_conjg (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n   f->value.function.name = gfc_get_string (\"__conjg_%d\", x->ts.kind);\n }\n \n \n void\n-gfc_resolve_cos (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_cos (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__cos_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__cos_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n }\n \n \n void\n-gfc_resolve_cosh (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_cosh (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__cosh_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__cosh_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n }\n \n \n void\n-gfc_resolve_count (gfc_expr * f, gfc_expr * mask, gfc_expr * dim)\n+gfc_resolve_count (gfc_expr *f, gfc_expr *mask, gfc_expr *dim)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n@@ -481,16 +482,15 @@ gfc_resolve_count (gfc_expr * f, gfc_expr * mask, gfc_expr * dim)\n       f->shape = gfc_copy_shape_excluding (mask->shape, mask->rank, dim);\n     }\n \n-  f->value.function.name =\n-    gfc_get_string (PREFIX(\"count_%d_%c%d\"), f->ts.kind,\n-\t\t    gfc_type_letter (mask->ts.type), mask->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (PREFIX (\"count_%d_%c%d\"), f->ts.kind,\n+\t\t      gfc_type_letter (mask->ts.type), mask->ts.kind);\n }\n \n \n void\n-gfc_resolve_cshift (gfc_expr * f, gfc_expr * array,\n-\t\t    gfc_expr * shift,\n-\t\t    gfc_expr * dim)\n+gfc_resolve_cshift (gfc_expr *f, gfc_expr *array, gfc_expr *shift,\n+\t\t    gfc_expr *dim)\n {\n   int n;\n \n@@ -520,14 +520,14 @@ gfc_resolve_cshift (gfc_expr * f, gfc_expr * array,\n       if (dim->ts.kind != shift->ts.kind)\n \tgfc_convert_type_warn (dim, &shift->ts, 2, 0);\n     }\n-  f->value.function.name =\n-    gfc_get_string (PREFIX(\"cshift%d_%d%s\"), n, shift->ts.kind,\n-\t\t    array->ts.type == BT_CHARACTER ? \"_char\" : \"\");\n+  f->value.function.name\n+    = gfc_get_string (PREFIX (\"cshift%d_%d%s\"), n, shift->ts.kind,\n+\t\t      array->ts.type == BT_CHARACTER ? \"_char\" : \"\");\n }\n \n \n void\n-gfc_resolve_ctime (gfc_expr * f, gfc_expr * time)\n+gfc_resolve_ctime (gfc_expr *f, gfc_expr *time)\n {\n   gfc_typespec ts;\n   \n@@ -544,22 +544,22 @@ gfc_resolve_ctime (gfc_expr * f, gfc_expr * time)\n       gfc_convert_type (time, &ts, 2);\n     }\n \n-  f->value.function.name = gfc_get_string (PREFIX(\"ctime\"));\n+  f->value.function.name = gfc_get_string (PREFIX (\"ctime\"));\n }\n \n \n void\n-gfc_resolve_dble (gfc_expr * f, gfc_expr * a)\n+gfc_resolve_dble (gfc_expr *f, gfc_expr *a)\n {\n   f->ts.type = BT_REAL;\n   f->ts.kind = gfc_default_double_kind;\n-  f->value.function.name =\n-    gfc_get_string (\"__dble_%c%d\", gfc_type_letter (a->ts.type), a->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__dble_%c%d\", gfc_type_letter (a->ts.type), a->ts.kind);\n }\n \n \n void\n-gfc_resolve_dim (gfc_expr * f, gfc_expr * a, gfc_expr * p)\n+gfc_resolve_dim (gfc_expr *f, gfc_expr *a, gfc_expr *p)\n {\n   f->ts.type = a->ts.type;\n   if (p != NULL)\n@@ -570,18 +570,18 @@ gfc_resolve_dim (gfc_expr * f, gfc_expr * a, gfc_expr * p)\n   if (p != NULL && a->ts.kind != p->ts.kind)\n     {\n       if (a->ts.kind == gfc_kind_max (a,p))\n-\tgfc_convert_type(p, &a->ts, 2);\n+\tgfc_convert_type (p, &a->ts, 2);\n       else\n-\tgfc_convert_type(a, &p->ts, 2);\n+\tgfc_convert_type (a, &p->ts, 2);\n     }\n \n-  f->value.function.name =\n-    gfc_get_string (\"__dim_%c%d\", gfc_type_letter (f->ts.type), f->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__dim_%c%d\", gfc_type_letter (f->ts.type), f->ts.kind);\n }\n \n \n void\n-gfc_resolve_dot_product (gfc_expr * f, gfc_expr * a, gfc_expr * b)\n+gfc_resolve_dot_product (gfc_expr *f, gfc_expr *a, gfc_expr *b)\n {\n   gfc_expr temp;\n \n@@ -592,30 +592,25 @@ gfc_resolve_dot_product (gfc_expr * f, gfc_expr * a, gfc_expr * b)\n   temp.value.op.op2 = b;\n   gfc_type_convert_binary (&temp);\n   f->ts = temp.ts;\n-\n-  f->value.function.name =\n-    gfc_get_string (PREFIX(\"dot_product_%c%d\"), gfc_type_letter (f->ts.type),\n-\t\t    f->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (PREFIX (\"dot_product_%c%d\"),\n+\t\t      gfc_type_letter (f->ts.type), f->ts.kind);\n }\n \n \n void\n-gfc_resolve_dprod (gfc_expr * f,\n-\t\t   gfc_expr * a ATTRIBUTE_UNUSED,\n-\t\t   gfc_expr * b ATTRIBUTE_UNUSED)\n+gfc_resolve_dprod (gfc_expr *f, gfc_expr *a ATTRIBUTE_UNUSED,\n+\t\t   gfc_expr *b ATTRIBUTE_UNUSED)\n {\n   f->ts.kind = gfc_default_double_kind;\n   f->ts.type = BT_REAL;\n-\n   f->value.function.name = gfc_get_string (\"__dprod_r%d\", f->ts.kind);\n }\n \n \n void\n-gfc_resolve_eoshift (gfc_expr * f, gfc_expr * array,\n-\t\t     gfc_expr * shift,\n-\t\t     gfc_expr * boundary,\n-\t\t     gfc_expr * dim)\n+gfc_resolve_eoshift (gfc_expr *f, gfc_expr *array, gfc_expr *shift,\n+\t\t     gfc_expr *boundary, gfc_expr *dim)\n {\n   int n;\n \n@@ -647,66 +642,64 @@ gfc_resolve_eoshift (gfc_expr * f, gfc_expr * array,\n \tgfc_convert_type_warn (dim, &shift->ts, 2, 0);\n     }\n \n-  f->value.function.name =\n-    gfc_get_string (PREFIX(\"eoshift%d_%d%s\"), n, shift->ts.kind,\n-\t\t    array->ts.type == BT_CHARACTER ? \"_char\" : \"\");\n+  f->value.function.name\n+    = gfc_get_string (PREFIX (\"eoshift%d_%d%s\"), n, shift->ts.kind,\n+\t\t      array->ts.type == BT_CHARACTER ? \"_char\" : \"\");\n }\n \n \n void\n-gfc_resolve_exp (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_exp (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__exp_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__exp_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n }\n \n \n void\n-gfc_resolve_exponent (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_exponent (gfc_expr *f, gfc_expr *x)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n-\n   f->value.function.name = gfc_get_string (\"__exponent_%d\", x->ts.kind);\n }\n \n \n void\n-gfc_resolve_fdate (gfc_expr * f)\n+gfc_resolve_fdate (gfc_expr *f)\n {\n   f->ts.type = BT_CHARACTER;\n   f->ts.kind = gfc_default_character_kind;\n-  f->value.function.name = gfc_get_string (PREFIX(\"fdate\"));\n+  f->value.function.name = gfc_get_string (PREFIX (\"fdate\"));\n }\n \n \n void\n-gfc_resolve_floor (gfc_expr * f, gfc_expr * a, gfc_expr * kind)\n+gfc_resolve_floor (gfc_expr *f, gfc_expr *a, gfc_expr *kind)\n {\n   f->ts.type = BT_INTEGER;\n-  f->ts.kind = (kind == NULL) ? gfc_default_integer_kind\n-    : mpz_get_si (kind->value.integer);\n-\n-  f->value.function.name =\n-    gfc_get_string (\"__floor%d_%c%d\", f->ts.kind,\n-\t\t    gfc_type_letter (a->ts.type), a->ts.kind);\n+  f->ts.kind = (kind == NULL)\n+\t     ? gfc_default_integer_kind : mpz_get_si (kind->value.integer);\n+  f->value.function.name\n+    = gfc_get_string (\"__floor%d_%c%d\", f->ts.kind,\n+\t\t      gfc_type_letter (a->ts.type), a->ts.kind);\n }\n \n \n void\n-gfc_resolve_fnum (gfc_expr * f, gfc_expr * n)\n+gfc_resolve_fnum (gfc_expr *f, gfc_expr *n)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n   if (n->ts.kind != f->ts.kind)\n     gfc_convert_type (n, &f->ts, 2);\n-  f->value.function.name = gfc_get_string (PREFIX(\"fnum_i%d\"), f->ts.kind);\n+  f->value.function.name = gfc_get_string (PREFIX (\"fnum_i%d\"), f->ts.kind);\n }\n \n \n void\n-gfc_resolve_fraction (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_fraction (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n   f->value.function.name = gfc_get_string (\"__fraction_%d\", x->ts.kind);\n@@ -716,68 +709,70 @@ gfc_resolve_fraction (gfc_expr * f, gfc_expr * x)\n /* Resolve single-argument g77 math intrinsics, eg BESY0, ERF.  */\n \n void\n-gfc_resolve_g77_math1 (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_g77_math1 (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n   f->value.function.name = gfc_get_string (\"<intrinsic>\");\n }\n \n \n void\n-gfc_resolve_getcwd (gfc_expr * f, gfc_expr * n ATTRIBUTE_UNUSED)\n+gfc_resolve_getcwd (gfc_expr *f, gfc_expr *n ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = 4;\n-  f->value.function.name = gfc_get_string (PREFIX(\"getcwd\"));\n+  f->value.function.name = gfc_get_string (PREFIX (\"getcwd\"));\n }\n \n \n void\n-gfc_resolve_getgid (gfc_expr * f)\n+gfc_resolve_getgid (gfc_expr *f)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = 4;\n-  f->value.function.name = gfc_get_string (PREFIX(\"getgid\"));\n+  f->value.function.name = gfc_get_string (PREFIX (\"getgid\"));\n }\n \n \n void\n-gfc_resolve_getpid (gfc_expr * f)\n+gfc_resolve_getpid (gfc_expr *f)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = 4;\n-  f->value.function.name = gfc_get_string (PREFIX(\"getpid\"));\n+  f->value.function.name = gfc_get_string (PREFIX (\"getpid\"));\n }\n \n \n void\n-gfc_resolve_getuid (gfc_expr * f)\n+gfc_resolve_getuid (gfc_expr *f)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = 4;\n-  f->value.function.name = gfc_get_string (PREFIX(\"getuid\"));\n+  f->value.function.name = gfc_get_string (PREFIX (\"getuid\"));\n }\n \n+\n void\n-gfc_resolve_hostnm (gfc_expr * f, gfc_expr * n ATTRIBUTE_UNUSED)\n+gfc_resolve_hostnm (gfc_expr *f, gfc_expr *n ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = 4;\n   f->value.function.name = gfc_get_string (PREFIX (\"hostnm\"));\n }\n \n+\n void\n-gfc_resolve_iand (gfc_expr * f, gfc_expr * i, gfc_expr * j)\n+gfc_resolve_iand (gfc_expr *f, gfc_expr *i, gfc_expr *j)\n {\n   /* If the kind of i and j are different, then g77 cross-promoted the\n      kinds to the largest value.  The Fortran 95 standard requires the \n      kinds to match.  */\n   if (i->ts.kind != j->ts.kind)\n     {\n-      if (i->ts.kind == gfc_kind_max (i,j))\n-\tgfc_convert_type(j, &i->ts, 2);\n+      if (i->ts.kind == gfc_kind_max (i, j))\n+\tgfc_convert_type (j, &i->ts, 2);\n       else\n-\tgfc_convert_type(i, &j->ts, 2);\n+\tgfc_convert_type (i, &j->ts, 2);\n     }\n \n   f->ts = i->ts;\n@@ -786,70 +781,67 @@ gfc_resolve_iand (gfc_expr * f, gfc_expr * i, gfc_expr * j)\n \n \n void\n-gfc_resolve_ibclr (gfc_expr * f, gfc_expr * i, gfc_expr * pos ATTRIBUTE_UNUSED)\n+gfc_resolve_ibclr (gfc_expr *f, gfc_expr *i, gfc_expr *pos ATTRIBUTE_UNUSED)\n {\n   f->ts = i->ts;\n   f->value.function.name = gfc_get_string (\"__ibclr_%d\", i->ts.kind);\n }\n \n \n void\n-gfc_resolve_ibits (gfc_expr * f, gfc_expr * i,\n-\t\t   gfc_expr * pos ATTRIBUTE_UNUSED,\n-\t\t   gfc_expr * len ATTRIBUTE_UNUSED)\n+gfc_resolve_ibits (gfc_expr *f, gfc_expr *i, gfc_expr *pos ATTRIBUTE_UNUSED,\n+\t\t   gfc_expr *len ATTRIBUTE_UNUSED)\n {\n   f->ts = i->ts;\n   f->value.function.name = gfc_get_string (\"__ibits_%d\", i->ts.kind);\n }\n \n \n void\n-gfc_resolve_ibset (gfc_expr * f, gfc_expr * i,\n-\t\t   gfc_expr * pos ATTRIBUTE_UNUSED)\n+gfc_resolve_ibset (gfc_expr *f, gfc_expr *i, gfc_expr *pos ATTRIBUTE_UNUSED)\n {\n   f->ts = i->ts;\n   f->value.function.name = gfc_get_string (\"__ibset_%d\", i->ts.kind);\n }\n \n \n void\n-gfc_resolve_ichar (gfc_expr * f, gfc_expr * c)\n+gfc_resolve_ichar (gfc_expr *f, gfc_expr *c)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n-\n   f->value.function.name = gfc_get_string (\"__ichar_%d\", c->ts.kind);\n }\n \n \n void\n-gfc_resolve_idnint (gfc_expr * f, gfc_expr * a)\n+gfc_resolve_idnint (gfc_expr *f, gfc_expr *a)\n {\n   gfc_resolve_nint (f, a, NULL);\n }\n \n \n void\n-gfc_resolve_ierrno (gfc_expr * f)\n+gfc_resolve_ierrno (gfc_expr *f)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n-  f->value.function.name = gfc_get_string (PREFIX(\"ierrno_i%d\"), f->ts.kind);\n+  f->value.function.name = gfc_get_string (PREFIX (\"ierrno_i%d\"), f->ts.kind);\n }\n \n \n void\n-gfc_resolve_ieor (gfc_expr * f, gfc_expr * i, gfc_expr * j)\n+gfc_resolve_ieor (gfc_expr *f, gfc_expr *i, gfc_expr *j)\n {\n   /* If the kind of i and j are different, then g77 cross-promoted the\n      kinds to the largest value.  The Fortran 95 standard requires the \n      kinds to match.  */\n   if (i->ts.kind != j->ts.kind)\n     {\n-      if (i->ts.kind == gfc_kind_max (i,j))\n-\tgfc_convert_type(j, &i->ts, 2);\n+      if (i->ts.kind == gfc_kind_max (i, j))\n+\tgfc_convert_type (j, &i->ts, 2);\n       else\n-\tgfc_convert_type(i, &j->ts, 2);\n+\tgfc_convert_type (i, &j->ts, 2);\n     }\n \n   f->ts = i->ts;\n@@ -858,17 +850,17 @@ gfc_resolve_ieor (gfc_expr * f, gfc_expr * i, gfc_expr * j)\n \n \n void\n-gfc_resolve_ior (gfc_expr * f, gfc_expr * i, gfc_expr * j)\n+gfc_resolve_ior (gfc_expr *f, gfc_expr *i, gfc_expr *j)\n {\n   /* If the kind of i and j are different, then g77 cross-promoted the\n      kinds to the largest value.  The Fortran 95 standard requires the \n      kinds to match.  */\n   if (i->ts.kind != j->ts.kind)\n     {\n-      if (i->ts.kind == gfc_kind_max (i,j))\n-\tgfc_convert_type(j, &i->ts, 2);\n+      if (i->ts.kind == gfc_kind_max (i, j))\n+\tgfc_convert_type (j, &i->ts, 2);\n       else\n-\tgfc_convert_type(i, &j->ts, 2);\n+\tgfc_convert_type (i, &j->ts, 2);\n     }\n \n   f->ts = i->ts;\n@@ -877,8 +869,8 @@ gfc_resolve_ior (gfc_expr * f, gfc_expr * i, gfc_expr * j)\n \n \n void\n-gfc_resolve_index_func (gfc_expr * f, gfc_expr * str,\n-\t\t\tATTRIBUTE_UNUSED gfc_expr * sub_str, gfc_expr * back)\n+gfc_resolve_index_func (gfc_expr *f, gfc_expr *str,\n+\t\t\tgfc_expr *sub_str ATTRIBUTE_UNUSED, gfc_expr *back)\n {\n   gfc_typespec ts;\n \n@@ -894,62 +886,58 @@ gfc_resolve_index_func (gfc_expr * f, gfc_expr * str,\n       gfc_convert_type (back, &ts, 2);\n     }\n \n-  f->value.function.name =\n-    gfc_get_string (\"__index_%d_i%d\", str->ts.kind, f->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__index_%d_i%d\", str->ts.kind, f->ts.kind);\n }\n \n \n void\n-gfc_resolve_int (gfc_expr * f, gfc_expr * a, gfc_expr * kind)\n+gfc_resolve_int (gfc_expr *f, gfc_expr *a, gfc_expr *kind)\n {\n   f->ts.type = BT_INTEGER;\n-  f->ts.kind = (kind == NULL) ? gfc_default_integer_kind\n-    : mpz_get_si (kind->value.integer);\n-\n-  f->value.function.name =\n-    gfc_get_string (\"__int_%d_%c%d\", f->ts.kind, gfc_type_letter (a->ts.type),\n-\t\t    a->ts.kind);\n+  f->ts.kind = (kind == NULL)\n+\t     ? gfc_default_integer_kind : mpz_get_si (kind->value.integer);\n+  f->value.function.name\n+    = gfc_get_string (\"__int_%d_%c%d\", f->ts.kind,\n+\t\t      gfc_type_letter (a->ts.type), a->ts.kind);\n }\n \n \n void\n-gfc_resolve_int2 (gfc_expr * f, gfc_expr * a)\n+gfc_resolve_int2 (gfc_expr *f, gfc_expr *a)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = 2;\n-\n-  f->value.function.name =\n-    gfc_get_string (\"__int_%d_%c%d\", f->ts.kind, gfc_type_letter (a->ts.type),\n-\t\t    a->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__int_%d_%c%d\", f->ts.kind,\n+\t\t      gfc_type_letter (a->ts.type), a->ts.kind);\n }\n \n \n void\n-gfc_resolve_int8 (gfc_expr * f, gfc_expr * a)\n+gfc_resolve_int8 (gfc_expr *f, gfc_expr *a)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = 8;\n-\n-  f->value.function.name =\n-    gfc_get_string (\"__int_%d_%c%d\", f->ts.kind, gfc_type_letter (a->ts.type),\n-\t\t    a->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__int_%d_%c%d\", f->ts.kind,\n+\t\t      gfc_type_letter (a->ts.type), a->ts.kind);\n }\n \n \n void\n-gfc_resolve_long (gfc_expr * f, gfc_expr * a)\n+gfc_resolve_long (gfc_expr *f, gfc_expr *a)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = 4;\n-\n-  f->value.function.name =\n-    gfc_get_string (\"__int_%d_%c%d\", f->ts.kind, gfc_type_letter (a->ts.type),\n-\t\t    a->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__int_%d_%c%d\", f->ts.kind,\n+\t\t      gfc_type_letter (a->ts.type), a->ts.kind);\n }\n \n \n void\n-gfc_resolve_isatty (gfc_expr * f, gfc_expr * u)\n+gfc_resolve_isatty (gfc_expr *f, gfc_expr *u)\n {\n   gfc_typespec ts;\n   \n@@ -964,65 +952,62 @@ gfc_resolve_isatty (gfc_expr * f, gfc_expr * u)\n       gfc_convert_type (u, &ts, 2);\n     }\n \n-  f->value.function.name = gfc_get_string (PREFIX(\"isatty_l%d\"), f->ts.kind);\n+  f->value.function.name = gfc_get_string (PREFIX (\"isatty_l%d\"), f->ts.kind);\n }\n \n \n void\n-gfc_resolve_ishft (gfc_expr * f, gfc_expr * i, gfc_expr * shift)\n+gfc_resolve_ishft (gfc_expr *f, gfc_expr *i, gfc_expr *shift)\n {\n   f->ts = i->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__ishft_%d_%d\", i->ts.kind, shift->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__ishft_%d_%d\", i->ts.kind, shift->ts.kind);\n }\n \n \n void\n-gfc_resolve_rshift (gfc_expr * f, gfc_expr * i, gfc_expr * shift)\n+gfc_resolve_rshift (gfc_expr *f, gfc_expr *i, gfc_expr *shift)\n {\n   f->ts = i->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__rshift_%d_%d\", i->ts.kind, shift->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__rshift_%d_%d\", i->ts.kind, shift->ts.kind);\n }\n \n \n void\n-gfc_resolve_lshift (gfc_expr * f, gfc_expr * i, gfc_expr * shift)\n+gfc_resolve_lshift (gfc_expr *f, gfc_expr *i, gfc_expr *shift)\n {\n   f->ts = i->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__lshift_%d_%d\", i->ts.kind, shift->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__lshift_%d_%d\", i->ts.kind, shift->ts.kind);\n }\n \n \n void\n-gfc_resolve_ishftc (gfc_expr * f, gfc_expr * i, gfc_expr * shift,\n-\t\t    gfc_expr * size)\n+gfc_resolve_ishftc (gfc_expr *f, gfc_expr *i, gfc_expr *shift, gfc_expr *size)\n {\n   int s_kind;\n \n   s_kind = (size == NULL) ? gfc_default_integer_kind : shift->ts.kind;\n \n   f->ts = i->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__ishftc_%d_%d_%d\", i->ts.kind, shift->ts.kind, s_kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__ishftc_%d_%d_%d\", i->ts.kind, shift->ts.kind, s_kind);\n }\n \n \n void\n-gfc_resolve_kill (gfc_expr * f, ATTRIBUTE_UNUSED gfc_expr * p,\n-                  ATTRIBUTE_UNUSED gfc_expr * s)\n+gfc_resolve_kill (gfc_expr *f, gfc_expr *p ATTRIBUTE_UNUSED,\n+\t\t  gfc_expr *s ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n-\n-  f->value.function.name = gfc_get_string (PREFIX(\"kill_i%d\"), f->ts.kind);\n+  f->value.function.name = gfc_get_string (PREFIX (\"kill_i%d\"), f->ts.kind);\n }\n \n \n void\n-gfc_resolve_lbound (gfc_expr * f, gfc_expr * array,\n-\t\t    gfc_expr * dim)\n+gfc_resolve_lbound (gfc_expr *f, gfc_expr *array, gfc_expr *dim)\n {\n   static char lbound[] = \"__lbound\";\n \n@@ -1041,17 +1026,18 @@ gfc_resolve_lbound (gfc_expr * f, gfc_expr * array,\n \n \n void\n-gfc_resolve_len (gfc_expr * f, gfc_expr * string)\n+gfc_resolve_len (gfc_expr *f, gfc_expr *string)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n-  f->value.function.name = gfc_get_string (\"__len_%d_i%d\", string->ts.kind,\n-\t\t\t\t\t   gfc_default_integer_kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__len_%d_i%d\", string->ts.kind,\n+\t\t      gfc_default_integer_kind);\n }\n \n \n void\n-gfc_resolve_len_trim (gfc_expr * f, gfc_expr * string)\n+gfc_resolve_len_trim (gfc_expr *f, gfc_expr *string)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n@@ -1060,12 +1046,12 @@ gfc_resolve_len_trim (gfc_expr * f, gfc_expr * string)\n \n \n void\n-gfc_resolve_link (gfc_expr * f, gfc_expr * p1 ATTRIBUTE_UNUSED,\n-\t          gfc_expr * p2 ATTRIBUTE_UNUSED)\n+gfc_resolve_link (gfc_expr *f, gfc_expr *p1 ATTRIBUTE_UNUSED,\n+\t\t  gfc_expr *p2 ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n-  f->value.function.name = gfc_get_string (PREFIX(\"link_i%d\"), f->ts.kind);\n+  f->value.function.name = gfc_get_string (PREFIX (\"link_i%d\"), f->ts.kind);\n }\n \n \n@@ -1079,39 +1065,40 @@ gfc_resolve_loc (gfc_expr *f, gfc_expr *x)\n \n \n void\n-gfc_resolve_log (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_log (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__log_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__log_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n }\n \n \n void\n-gfc_resolve_log10 (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_log10 (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__log10_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__log10_%c%d\", gfc_type_letter (x->ts.type),\n+\t\t      x->ts.kind);\n }\n \n \n void\n-gfc_resolve_logical (gfc_expr * f, gfc_expr * a, gfc_expr * kind)\n+gfc_resolve_logical (gfc_expr *f, gfc_expr *a, gfc_expr *kind)\n {\n   f->ts.type = BT_LOGICAL;\n-  f->ts.kind = (kind == NULL) ? gfc_default_logical_kind\n-    : mpz_get_si (kind->value.integer);\n+  f->ts.kind = (kind == NULL)\n+\t     ? gfc_default_logical_kind : mpz_get_si (kind->value.integer);\n   f->rank = a->rank;\n \n-  f->value.function.name =\n-    gfc_get_string (\"__logical_%d_%c%d\", f->ts.kind,\n-\t\t    gfc_type_letter (a->ts.type), a->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__logical_%d_%c%d\", f->ts.kind,\n+\t\t      gfc_type_letter (a->ts.type), a->ts.kind);\n }\n \n \n void\n-gfc_resolve_malloc (gfc_expr * f, gfc_expr * size)\n+gfc_resolve_malloc (gfc_expr *f, gfc_expr *size)\n {\n   if (size->ts.kind < gfc_index_integer_kind)\n     {\n@@ -1124,12 +1111,12 @@ gfc_resolve_malloc (gfc_expr * f, gfc_expr * size)\n \n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_index_integer_kind;\n-  f->value.function.name = gfc_get_string (PREFIX(\"malloc\"));\n+  f->value.function.name = gfc_get_string (PREFIX (\"malloc\"));\n }\n \n \n void\n-gfc_resolve_matmul (gfc_expr * f, gfc_expr * a, gfc_expr * b)\n+gfc_resolve_matmul (gfc_expr *f, gfc_expr *a, gfc_expr *b)\n {\n   gfc_expr temp;\n \n@@ -1151,14 +1138,14 @@ gfc_resolve_matmul (gfc_expr * f, gfc_expr * a, gfc_expr * b)\n \n   f->rank = (a->rank == 2 && b->rank == 2) ? 2 : 1;\n \n-  f->value.function.name =\n-    gfc_get_string (PREFIX(\"matmul_%c%d\"), gfc_type_letter (f->ts.type),\n-\t\t    f->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (PREFIX (\"matmul_%c%d\"), gfc_type_letter (f->ts.type),\n+\t\t      f->ts.kind);\n }\n \n \n static void\n-gfc_resolve_minmax (const char * name, gfc_expr * f, gfc_actual_arglist * args)\n+gfc_resolve_minmax (const char *name, gfc_expr *f, gfc_actual_arglist *args)\n {\n   gfc_actual_arglist *a;\n \n@@ -1168,31 +1155,31 @@ gfc_resolve_minmax (const char * name, gfc_expr * f, gfc_actual_arglist * args)\n   for (a = args->next; a; a = a->next)\n     {\n       if (a->expr->ts.kind > f->ts.kind)\n-        f->ts.kind = a->expr->ts.kind;\n+\tf->ts.kind = a->expr->ts.kind;\n     }\n \n   /* Convert all parameters to the required kind.  */\n   for (a = args; a; a = a->next)\n     {\n       if (a->expr->ts.kind != f->ts.kind)\n-        gfc_convert_type (a->expr, &f->ts, 2);\n+\tgfc_convert_type (a->expr, &f->ts, 2);\n     }\n \n-  f->value.function.name =\n-    gfc_get_string (name, gfc_type_letter (f->ts.type), f->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (name, gfc_type_letter (f->ts.type), f->ts.kind);\n }\n \n \n void\n-gfc_resolve_max (gfc_expr * f, gfc_actual_arglist * args)\n+gfc_resolve_max (gfc_expr *f, gfc_actual_arglist *args)\n {\n   gfc_resolve_minmax (\"__max_%c%d\", f, args);\n }\n \n \n void\n-gfc_resolve_maxloc (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n-\t\t    gfc_expr * mask)\n+gfc_resolve_maxloc (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n+\t\t    gfc_expr *mask)\n {\n   const char *name;\n   int i, j, idim;\n@@ -1217,7 +1204,7 @@ gfc_resolve_maxloc (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n \t  for (i = 0, j = 0; i < f->rank; i++, j++)\n \t    {\n \t      if (i == (idim - 1))\n-\t        j++;\n+\t\tj++;\n \t      mpz_init_set (f->shape[i], array->shape[j]);\n \t    }\n \t}\n@@ -1244,15 +1231,15 @@ gfc_resolve_maxloc (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n   else\n     name = \"maxloc\";\n \n-  f->value.function.name =\n-    gfc_get_string (PREFIX(\"%s%d_%d_%c%d\"), name, dim != NULL, f->ts.kind,\n-                    gfc_type_letter (array->ts.type), array->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (PREFIX (\"%s%d_%d_%c%d\"), name, dim != NULL, f->ts.kind,\n+\t\t      gfc_type_letter (array->ts.type), array->ts.kind);\n }\n \n \n void\n-gfc_resolve_maxval (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n-\t\t    gfc_expr * mask)\n+gfc_resolve_maxval (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n+\t\t    gfc_expr *mask)\n {\n   const char *name;\n   int i, j, idim;\n@@ -1271,7 +1258,7 @@ gfc_resolve_maxval (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n \t  for (i = 0, j = 0; i < f->rank; i++, j++)\n \t    {\n \t      if (i == (idim - 1))\n-\t        j++;\n+\t\tj++;\n \t      mpz_init_set (f->shape[i], array->shape[j]);\n \t    }\n \t}\n@@ -1298,55 +1285,55 @@ gfc_resolve_maxval (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n   else\n     name = \"maxval\";\n \n-  f->value.function.name =\n-    gfc_get_string (PREFIX(\"%s_%c%d\"), name,\n-\t\t    gfc_type_letter (array->ts.type), array->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (PREFIX (\"%s_%c%d\"), name,\n+\t\t      gfc_type_letter (array->ts.type), array->ts.kind);\n }\n \n \n void\n-gfc_resolve_mclock (gfc_expr * f)\n+gfc_resolve_mclock (gfc_expr *f)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = 4;\n-  f->value.function.name = PREFIX(\"mclock\");\n+  f->value.function.name = PREFIX (\"mclock\");\n }\n \n \n void\n-gfc_resolve_mclock8 (gfc_expr * f)\n+gfc_resolve_mclock8 (gfc_expr *f)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = 8;\n-  f->value.function.name = PREFIX(\"mclock8\");\n+  f->value.function.name = PREFIX (\"mclock8\");\n }\n \n \n void\n-gfc_resolve_merge (gfc_expr * f, gfc_expr * tsource,\n-\t\t   gfc_expr * fsource ATTRIBUTE_UNUSED,\n-\t\t   gfc_expr * mask ATTRIBUTE_UNUSED)\n+gfc_resolve_merge (gfc_expr *f, gfc_expr *tsource,\n+\t\t   gfc_expr *fsource ATTRIBUTE_UNUSED,\n+\t\t   gfc_expr *mask ATTRIBUTE_UNUSED)\n {\n   if (tsource->ts.type == BT_CHARACTER)\n     check_charlen_present (tsource);\n \n   f->ts = tsource->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__merge_%c%d\", gfc_type_letter (tsource->ts.type),\n-\t\t    tsource->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__merge_%c%d\", gfc_type_letter (tsource->ts.type),\n+\t\t      tsource->ts.kind);\n }\n \n \n void\n-gfc_resolve_min (gfc_expr * f, gfc_actual_arglist * args)\n+gfc_resolve_min (gfc_expr *f, gfc_actual_arglist *args)\n {\n   gfc_resolve_minmax (\"__min_%c%d\", f, args);\n }\n \n \n void\n-gfc_resolve_minloc (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n-\t\t    gfc_expr * mask)\n+gfc_resolve_minloc (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n+\t\t    gfc_expr *mask)\n {\n   const char *name;\n   int i, j, idim;\n@@ -1371,7 +1358,7 @@ gfc_resolve_minloc (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n \t  for (i = 0, j = 0; i < f->rank; i++, j++)\n \t    {\n \t      if (i == (idim - 1))\n-\t        j++;\n+\t\tj++;\n \t      mpz_init_set (f->shape[i], array->shape[j]);\n \t    }\n \t}\n@@ -1398,15 +1385,15 @@ gfc_resolve_minloc (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n   else\n     name = \"minloc\";\n \n-  f->value.function.name =\n-    gfc_get_string (PREFIX(\"%s%d_%d_%c%d\"), name, dim != NULL, f->ts.kind,\n-                    gfc_type_letter (array->ts.type), array->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (PREFIX (\"%s%d_%d_%c%d\"), name, dim != NULL, f->ts.kind,\n+\t\t      gfc_type_letter (array->ts.type), array->ts.kind);\n }\n \n \n void\n-gfc_resolve_minval (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n-\t\t    gfc_expr * mask)\n+gfc_resolve_minval (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n+\t\t    gfc_expr *mask)\n {\n   const char *name;\n   int i, j, idim;\n@@ -1425,7 +1412,7 @@ gfc_resolve_minval (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n \t  for (i = 0, j = 0; i < f->rank; i++, j++)\n \t    {\n \t      if (i == (idim - 1))\n-\t        j++;\n+\t\tj++;\n \t      mpz_init_set (f->shape[i], array->shape[j]);\n \t    }\n \t}\n@@ -1452,14 +1439,14 @@ gfc_resolve_minval (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n   else\n     name = \"minval\";\n \n-  f->value.function.name =\n-    gfc_get_string (PREFIX(\"%s_%c%d\"), name,\n-\t\t    gfc_type_letter (array->ts.type), array->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (PREFIX (\"%s_%c%d\"), name,\n+\t\t      gfc_type_letter (array->ts.type), array->ts.kind);\n }\n \n \n void\n-gfc_resolve_mod (gfc_expr * f, gfc_expr * a, gfc_expr * p)\n+gfc_resolve_mod (gfc_expr *f, gfc_expr *a, gfc_expr *p)\n {\n   f->ts.type = a->ts.type;\n   if (p != NULL)\n@@ -1470,18 +1457,18 @@ gfc_resolve_mod (gfc_expr * f, gfc_expr * a, gfc_expr * p)\n   if (p != NULL && a->ts.kind != p->ts.kind)\n     {\n       if (a->ts.kind == gfc_kind_max (a,p))\n-\tgfc_convert_type(p, &a->ts, 2);\n+\tgfc_convert_type (p, &a->ts, 2);\n       else\n-\tgfc_convert_type(a, &p->ts, 2);\n+\tgfc_convert_type (a, &p->ts, 2);\n     }\n \n-  f->value.function.name =\n-    gfc_get_string (\"__mod_%c%d\", gfc_type_letter (f->ts.type), f->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__mod_%c%d\", gfc_type_letter (f->ts.type), f->ts.kind);\n }\n \n \n void\n-gfc_resolve_modulo (gfc_expr * f, gfc_expr * a, gfc_expr * p)\n+gfc_resolve_modulo (gfc_expr *f, gfc_expr *a, gfc_expr *p)\n {\n   f->ts.type = a->ts.type;\n   if (p != NULL)\n@@ -1492,76 +1479,73 @@ gfc_resolve_modulo (gfc_expr * f, gfc_expr * a, gfc_expr * p)\n   if (p != NULL && a->ts.kind != p->ts.kind)\n     {\n       if (a->ts.kind == gfc_kind_max (a,p))\n-\tgfc_convert_type(p, &a->ts, 2);\n+\tgfc_convert_type (p, &a->ts, 2);\n       else\n-\tgfc_convert_type(a, &p->ts, 2);\n+\tgfc_convert_type (a, &p->ts, 2);\n     }\n \n-  f->value.function.name =\n-    gfc_get_string (\"__modulo_%c%d\", gfc_type_letter (f->ts.type),\n-\t\t    f->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__modulo_%c%d\", gfc_type_letter (f->ts.type),\n+\t\t      f->ts.kind);\n }\n \n void\n-gfc_resolve_nearest (gfc_expr * f, gfc_expr * a, gfc_expr *p ATTRIBUTE_UNUSED)\n+gfc_resolve_nearest (gfc_expr *f, gfc_expr *a, gfc_expr *p ATTRIBUTE_UNUSED)\n {\n   f->ts = a->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__nearest_%c%d\", gfc_type_letter (a->ts.type),\n-            a->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__nearest_%c%d\", gfc_type_letter (a->ts.type),\n+\t\t      a->ts.kind);\n }\n \n void\n-gfc_resolve_nint (gfc_expr * f, gfc_expr * a, gfc_expr * kind)\n+gfc_resolve_nint (gfc_expr *f, gfc_expr *a, gfc_expr *kind)\n {\n   f->ts.type = BT_INTEGER;\n-  f->ts.kind = (kind == NULL) ? gfc_default_integer_kind\n-    : mpz_get_si (kind->value.integer);\n-\n-  f->value.function.name =\n-    gfc_get_string (\"__nint_%d_%d\", f->ts.kind, a->ts.kind);\n+  f->ts.kind = (kind == NULL)\n+\t     ? gfc_default_integer_kind : mpz_get_si (kind->value.integer);\n+  f->value.function.name\n+    = gfc_get_string (\"__nint_%d_%d\", f->ts.kind, a->ts.kind);\n }\n \n \n void\n-gfc_resolve_not (gfc_expr * f, gfc_expr * i)\n+gfc_resolve_not (gfc_expr *f, gfc_expr *i)\n {\n   f->ts = i->ts;\n   f->value.function.name = gfc_get_string (\"__not_%d\", i->ts.kind);\n }\n \n \n void\n-gfc_resolve_or (gfc_expr * f, gfc_expr * i, gfc_expr * j)\n+gfc_resolve_or (gfc_expr *f, gfc_expr *i, gfc_expr *j)\n {\n   f->ts.type = i->ts.type;\n-  f->ts.kind = gfc_kind_max (i,j);\n+  f->ts.kind = gfc_kind_max (i, j);\n \n   if (i->ts.kind != j->ts.kind)\n     {\n-      if (i->ts.kind == gfc_kind_max (i,j))\n-\tgfc_convert_type(j, &i->ts, 2);\n+      if (i->ts.kind == gfc_kind_max (i, j))\n+\tgfc_convert_type (j, &i->ts, 2);\n       else\n-\tgfc_convert_type(i, &j->ts, 2);\n+\tgfc_convert_type (i, &j->ts, 2);\n     }\n \n-  f->value.function.name = gfc_get_string (\"__or_%c%d\",\n-\t\t\t\t\t   gfc_type_letter (i->ts.type),\n-\t\t\t\t\t   f->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__or_%c%d\", gfc_type_letter (i->ts.type), f->ts.kind);\n }\n \n \n void\n-gfc_resolve_pack (gfc_expr * f, gfc_expr * array, gfc_expr * mask,\n-\t\t  gfc_expr * vector ATTRIBUTE_UNUSED)\n+gfc_resolve_pack (gfc_expr *f, gfc_expr *array, gfc_expr *mask,\n+\t\t  gfc_expr *vector ATTRIBUTE_UNUSED)\n {\n   f->ts = array->ts;\n   f->rank = 1;\n \n   if (mask->rank != 0)\n     f->value.function.name = (array->ts.type == BT_CHARACTER\n-\t\t\t      ? PREFIX(\"pack_char\")\n-\t\t\t      : PREFIX(\"pack\"));\n+\t\t\t   ? PREFIX (\"pack_char\") : PREFIX (\"pack\"));\n   else\n     {\n       /* We convert mask to default logical only in the scalar case.\n@@ -1577,15 +1561,14 @@ gfc_resolve_pack (gfc_expr * f, gfc_expr * array, gfc_expr * mask,\n \t}\n \n       f->value.function.name = (array->ts.type == BT_CHARACTER\n-\t\t\t\t? PREFIX(\"pack_s_char\")\n-\t\t\t\t: PREFIX(\"pack_s\"));\n+\t\t\t     ? PREFIX (\"pack_s_char\") : PREFIX (\"pack_s\"));\n     }\n }\n \n \n void\n-gfc_resolve_product (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n-\t\t     gfc_expr * mask)\n+gfc_resolve_product (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n+\t\t     gfc_expr *mask)\n {\n   const char *name;\n \n@@ -1618,53 +1601,53 @@ gfc_resolve_product (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n   else\n     name = \"product\";\n \n-  f->value.function.name =\n-    gfc_get_string (PREFIX(\"%s_%c%d\"), name,\n-\t\t    gfc_type_letter (array->ts.type), array->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (PREFIX (\"%s_%c%d\"), name,\n+\t\t      gfc_type_letter (array->ts.type), array->ts.kind);\n }\n \n \n void\n-gfc_resolve_real (gfc_expr * f, gfc_expr * a, gfc_expr * kind)\n+gfc_resolve_real (gfc_expr *f, gfc_expr *a, gfc_expr *kind)\n {\n   f->ts.type = BT_REAL;\n \n   if (kind != NULL)\n     f->ts.kind = mpz_get_si (kind->value.integer);\n   else\n-    f->ts.kind = (a->ts.type == BT_COMPLEX) ?\n-      a->ts.kind : gfc_default_real_kind;\n+    f->ts.kind = (a->ts.type == BT_COMPLEX)\n+\t       ? a->ts.kind : gfc_default_real_kind;\n \n-  f->value.function.name =\n-    gfc_get_string (\"__real_%d_%c%d\", f->ts.kind,\n-\t\t    gfc_type_letter (a->ts.type), a->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__real_%d_%c%d\", f->ts.kind,\n+\t\t      gfc_type_letter (a->ts.type), a->ts.kind);\n }\n \n \n void\n-gfc_resolve_realpart (gfc_expr * f, gfc_expr * a)\n+gfc_resolve_realpart (gfc_expr *f, gfc_expr *a)\n {\n   f->ts.type = BT_REAL;\n   f->ts.kind = a->ts.kind;\n-  f->value.function.name =\n-    gfc_get_string (\"__real_%d_%c%d\", f->ts.kind,\n-\t\t    gfc_type_letter (a->ts.type), a->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__real_%d_%c%d\", f->ts.kind,\n+\t\t      gfc_type_letter (a->ts.type), a->ts.kind);\n }\n \n \n void\n-gfc_resolve_rename (gfc_expr * f, gfc_expr * p1 ATTRIBUTE_UNUSED,\n-\t            gfc_expr * p2 ATTRIBUTE_UNUSED)\n+gfc_resolve_rename (gfc_expr *f, gfc_expr *p1 ATTRIBUTE_UNUSED,\n+\t\t    gfc_expr *p2 ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n-  f->value.function.name = gfc_get_string (PREFIX(\"rename_i%d\"), f->ts.kind);\n+  f->value.function.name = gfc_get_string (PREFIX (\"rename_i%d\"), f->ts.kind);\n }\n \n \n void\n-gfc_resolve_repeat (gfc_expr * f, gfc_expr * string,\n-\t\t    gfc_expr * ncopies ATTRIBUTE_UNUSED)\n+gfc_resolve_repeat (gfc_expr *f, gfc_expr *string,\n+\t\t    gfc_expr *ncopies ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_CHARACTER;\n   f->ts.kind = string->ts.kind;\n@@ -1673,9 +1656,9 @@ gfc_resolve_repeat (gfc_expr * f, gfc_expr * string,\n \n \n void\n-gfc_resolve_reshape (gfc_expr * f, gfc_expr * source, gfc_expr * shape,\n-\t\t     gfc_expr * pad ATTRIBUTE_UNUSED,\n-\t\t     gfc_expr * order ATTRIBUTE_UNUSED)\n+gfc_resolve_reshape (gfc_expr *f, gfc_expr *source, gfc_expr *shape,\n+\t\t     gfc_expr *pad ATTRIBUTE_UNUSED,\n+\t\t     gfc_expr *order ATTRIBUTE_UNUSED)\n {\n   mpz_t rank;\n   int kind;\n@@ -1707,19 +1690,19 @@ gfc_resolve_reshape (gfc_expr * f, gfc_expr * source, gfc_expr * shape,\n     case 10:\n     case 16:\n       if (source->ts.type == BT_COMPLEX || source->ts.type == BT_REAL)\n-\tf->value.function.name =\n-\t  gfc_get_string (PREFIX(\"reshape_%c%d\"),\n-\t\t\t  gfc_type_letter (source->ts.type), source->ts.kind);\n+\tf->value.function.name\n+\t  = gfc_get_string (PREFIX (\"reshape_%c%d\"),\n+\t\t\t    gfc_type_letter (source->ts.type),\n+\t\t\t    source->ts.kind);\n       else\n-\tf->value.function.name =\n-\t  gfc_get_string (PREFIX(\"reshape_%d\"), source->ts.kind);\n+\tf->value.function.name\n+\t  = gfc_get_string (PREFIX (\"reshape_%d\"), source->ts.kind);\n \n       break;\n \n     default:\n       f->value.function.name = (source->ts.type == BT_CHARACTER\n-\t\t\t\t? PREFIX(\"reshape_char\")\n-\t\t\t\t: PREFIX(\"reshape\"));\n+\t\t\t     ? PREFIX (\"reshape_char\") : PREFIX (\"reshape\"));\n       break;\n     }\n \n@@ -1752,7 +1735,7 @@ gfc_resolve_reshape (gfc_expr * f, gfc_expr * source, gfc_expr * shape,\n \n \n void\n-gfc_resolve_rrspacing (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_rrspacing (gfc_expr *f, gfc_expr *x)\n {\n   int k;\n   gfc_actual_arglist *prec;\n@@ -1771,7 +1754,7 @@ gfc_resolve_rrspacing (gfc_expr * f, gfc_expr * x)\n \n \n void\n-gfc_resolve_scale (gfc_expr * f, gfc_expr * x, gfc_expr * i)\n+gfc_resolve_scale (gfc_expr *f, gfc_expr *x, gfc_expr *i)\n {\n   f->ts = x->ts;\n \n@@ -1780,10 +1763,8 @@ gfc_resolve_scale (gfc_expr * f, gfc_expr * x, gfc_expr * i)\n   if (i->ts.kind != gfc_c_int_kind)\n     {\n       gfc_typespec ts;\n-\n       ts.type = BT_INTEGER;\n       ts.kind = gfc_default_integer_kind;\n-\n       gfc_convert_type_warn (i, &ts, 2, 0);\n     }\n \n@@ -1792,9 +1773,9 @@ gfc_resolve_scale (gfc_expr * f, gfc_expr * x, gfc_expr * i)\n \n \n void\n-gfc_resolve_scan (gfc_expr * f, gfc_expr * string,\n-\t\t  gfc_expr * set ATTRIBUTE_UNUSED,\n-\t\t  gfc_expr * back ATTRIBUTE_UNUSED)\n+gfc_resolve_scan (gfc_expr *f, gfc_expr *string,\n+\t\t  gfc_expr *set ATTRIBUTE_UNUSED,\n+\t\t  gfc_expr *back ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n@@ -1803,16 +1784,15 @@ gfc_resolve_scan (gfc_expr * f, gfc_expr * string,\n \n \n void\n-gfc_resolve_secnds (gfc_expr * t1, gfc_expr * t0)\n+gfc_resolve_secnds (gfc_expr *t1, gfc_expr *t0)\n {\n   t1->ts = t0->ts;\n-  t1->value.function.name =\n-    gfc_get_string (PREFIX(\"secnds\"));\n+  t1->value.function.name = gfc_get_string (PREFIX (\"secnds\"));\n }\n \n \n void\n-gfc_resolve_set_exponent (gfc_expr * f, gfc_expr * x, gfc_expr * i)\n+gfc_resolve_set_exponent (gfc_expr *f, gfc_expr *x, gfc_expr *i)\n {\n   f->ts = x->ts;\n \n@@ -1822,10 +1802,8 @@ gfc_resolve_set_exponent (gfc_expr * f, gfc_expr * x, gfc_expr * i)\n   if (i->ts.kind != 4)\n     {\n       gfc_typespec ts;\n-\n       ts.type = BT_INTEGER;\n       ts.kind = gfc_default_integer_kind;\n-\n       gfc_convert_type_warn (i, &ts, 2, 0);\n     }\n \n@@ -1834,28 +1812,28 @@ gfc_resolve_set_exponent (gfc_expr * f, gfc_expr * x, gfc_expr * i)\n \n \n void\n-gfc_resolve_shape (gfc_expr * f, gfc_expr * array)\n+gfc_resolve_shape (gfc_expr *f, gfc_expr *array)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n   f->rank = 1;\n-  f->value.function.name = gfc_get_string (PREFIX(\"shape_%d\"), f->ts.kind);\n   f->shape = gfc_get_shape (1);\n   mpz_init_set_ui (f->shape[0], array->rank);\n+  f->value.function.name = gfc_get_string (PREFIX (\"shape_%d\"), f->ts.kind);\n }\n \n \n void\n-gfc_resolve_sign (gfc_expr * f, gfc_expr * a, gfc_expr * b ATTRIBUTE_UNUSED)\n+gfc_resolve_sign (gfc_expr *f, gfc_expr *a, gfc_expr *b ATTRIBUTE_UNUSED)\n {\n   f->ts = a->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__sign_%c%d\", gfc_type_letter (a->ts.type), a->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__sign_%c%d\", gfc_type_letter (a->ts.type), a->ts.kind);\n }\n \n \n void\n-gfc_resolve_signal (gfc_expr * f, gfc_expr *number, gfc_expr *handler)\n+gfc_resolve_signal (gfc_expr *f, gfc_expr *number, gfc_expr *handler)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_c_int_kind;\n@@ -1865,36 +1843,36 @@ gfc_resolve_signal (gfc_expr * f, gfc_expr *number, gfc_expr *handler)\n     {\n       if (handler->ts.kind != gfc_c_int_kind)\n \tgfc_convert_type (handler, &f->ts, 2);\n-      f->value.function.name = gfc_get_string (PREFIX(\"signal_func_int\"));\n+      f->value.function.name = gfc_get_string (PREFIX (\"signal_func_int\"));\n     }\n   else\n-    f->value.function.name = gfc_get_string (PREFIX(\"signal_func\"));\n+    f->value.function.name = gfc_get_string (PREFIX (\"signal_func\"));\n \n   if (number->ts.kind != gfc_c_int_kind)\n     gfc_convert_type (number, &f->ts, 2);\n }\n \n \n void\n-gfc_resolve_sin (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_sin (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__sin_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__sin_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n }\n \n \n void\n-gfc_resolve_sinh (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_sinh (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__sinh_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__sinh_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n }\n \n \n void\n-gfc_resolve_spacing (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_spacing (gfc_expr *f, gfc_expr *x)\n {\n   int k; \n   gfc_actual_arglist *prec, *tiny, *emin_1;\n@@ -1929,14 +1907,12 @@ gfc_resolve_spacing (gfc_expr * f, gfc_expr * x)\n   prec->next = emin_1;\n \n   f->value.function.actual->next = prec;\n-\n }\n \n \n void\n-gfc_resolve_spread (gfc_expr * f, gfc_expr * source,\n-\t\t    gfc_expr * dim,\n-\t\t    gfc_expr * ncopies)\n+gfc_resolve_spread (gfc_expr *f, gfc_expr *source, gfc_expr *dim,\n+\t\t    gfc_expr *ncopies)\n {\n   if (source->ts.type == BT_CHARACTER)\n     check_charlen_present (source);\n@@ -1945,16 +1921,15 @@ gfc_resolve_spread (gfc_expr * f, gfc_expr * source,\n   f->rank = source->rank + 1;\n   if (source->rank == 0)\n     f->value.function.name = (source->ts.type == BT_CHARACTER\n-\t\t\t      ? PREFIX(\"spread_char_scalar\")\n-\t\t\t      : PREFIX(\"spread_scalar\"));\n+\t\t\t      ? PREFIX (\"spread_char_scalar\")\n+\t\t\t      : PREFIX (\"spread_scalar\"));\n   else\n     f->value.function.name = (source->ts.type == BT_CHARACTER\n-\t\t\t      ? PREFIX(\"spread_char\")\n-\t\t\t      : PREFIX(\"spread\"));\n+\t\t\t      ? PREFIX (\"spread_char\")\n+\t\t\t      : PREFIX (\"spread\"));\n \n   if (dim && gfc_is_constant_expr (dim)\n-\t&& ncopies && gfc_is_constant_expr (ncopies)\n-\t&& source->shape[0])\n+      && ncopies && gfc_is_constant_expr (ncopies) && source->shape[0])\n     {\n       int i, idim;\n       idim = mpz_get_ui (dim->value.integer);\n@@ -1975,50 +1950,50 @@ gfc_resolve_spread (gfc_expr * f, gfc_expr * source,\n \n \n void\n-gfc_resolve_sqrt (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_sqrt (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__sqrt_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__sqrt_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n }\n \n \n /* Resolve the g77 compatibility function STAT AND FSTAT.  */\n \n void\n-gfc_resolve_stat (gfc_expr * f, gfc_expr * n ATTRIBUTE_UNUSED,\n-\t\t  gfc_expr * a ATTRIBUTE_UNUSED)\n+gfc_resolve_stat (gfc_expr *f, gfc_expr *n ATTRIBUTE_UNUSED,\n+\t\t  gfc_expr *a ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n-  f->value.function.name = gfc_get_string (PREFIX(\"stat_i%d\"), f->ts.kind);\n+  f->value.function.name = gfc_get_string (PREFIX (\"stat_i%d\"), f->ts.kind);\n }\n \n \n void\n-gfc_resolve_lstat (gfc_expr * f, gfc_expr * n ATTRIBUTE_UNUSED,\n-\t\t   gfc_expr * a ATTRIBUTE_UNUSED)\n+gfc_resolve_lstat (gfc_expr *f, gfc_expr *n ATTRIBUTE_UNUSED,\n+\t\t   gfc_expr *a ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n-  f->value.function.name = gfc_get_string (PREFIX(\"lstat_i%d\"), f->ts.kind);\n+  f->value.function.name = gfc_get_string (PREFIX (\"lstat_i%d\"), f->ts.kind);\n }\n \n \n void\n-gfc_resolve_fstat (gfc_expr * f, gfc_expr * n, gfc_expr * a ATTRIBUTE_UNUSED)\n+gfc_resolve_fstat (gfc_expr *f, gfc_expr *n, gfc_expr *a ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n   if (n->ts.kind != f->ts.kind)\n     gfc_convert_type (n, &f->ts, 2);\n \n-  f->value.function.name = gfc_get_string (PREFIX(\"fstat_i%d\"), f->ts.kind);\n+  f->value.function.name = gfc_get_string (PREFIX (\"fstat_i%d\"), f->ts.kind);\n }\n \n \n void\n-gfc_resolve_fgetc (gfc_expr * f, gfc_expr * u, gfc_expr * c ATTRIBUTE_UNUSED)\n+gfc_resolve_fgetc (gfc_expr *f, gfc_expr *u, gfc_expr *c ATTRIBUTE_UNUSED)\n {\n   gfc_typespec ts;\n \n@@ -2033,21 +2008,21 @@ gfc_resolve_fgetc (gfc_expr * f, gfc_expr * u, gfc_expr * c ATTRIBUTE_UNUSED)\n       gfc_convert_type (u, &ts, 2);\n     }\n \n-  f->value.function.name = gfc_get_string (PREFIX(\"fgetc\"));\n+  f->value.function.name = gfc_get_string (PREFIX (\"fgetc\"));\n }\n \n \n void\n-gfc_resolve_fget (gfc_expr * f, gfc_expr * c ATTRIBUTE_UNUSED)\n+gfc_resolve_fget (gfc_expr *f, gfc_expr *c ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_c_int_kind;\n-  f->value.function.name = gfc_get_string (PREFIX(\"fget\"));\n+  f->value.function.name = gfc_get_string (PREFIX (\"fget\"));\n }\n \n \n void\n-gfc_resolve_fputc (gfc_expr * f, gfc_expr * u, gfc_expr * c ATTRIBUTE_UNUSED)\n+gfc_resolve_fputc (gfc_expr *f, gfc_expr *u, gfc_expr *c ATTRIBUTE_UNUSED)\n {\n   gfc_typespec ts;\n \n@@ -2062,21 +2037,21 @@ gfc_resolve_fputc (gfc_expr * f, gfc_expr * u, gfc_expr * c ATTRIBUTE_UNUSED)\n       gfc_convert_type (u, &ts, 2);\n     }\n \n-  f->value.function.name = gfc_get_string (PREFIX(\"fputc\"));\n+  f->value.function.name = gfc_get_string (PREFIX (\"fputc\"));\n }\n \n \n void\n-gfc_resolve_fput (gfc_expr * f, gfc_expr * c ATTRIBUTE_UNUSED)\n+gfc_resolve_fput (gfc_expr *f, gfc_expr *c ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_c_int_kind;\n-  f->value.function.name = gfc_get_string (PREFIX(\"fput\"));\n+  f->value.function.name = gfc_get_string (PREFIX (\"fput\"));\n }\n \n \n void\n-gfc_resolve_ftell (gfc_expr * f, gfc_expr * u)\n+gfc_resolve_ftell (gfc_expr *f, gfc_expr *u)\n {\n   gfc_typespec ts;\n \n@@ -2091,13 +2066,12 @@ gfc_resolve_ftell (gfc_expr * f, gfc_expr * u)\n       gfc_convert_type (u, &ts, 2);\n     }\n \n-  f->value.function.name = gfc_get_string (PREFIX(\"ftell\"));\n+  f->value.function.name = gfc_get_string (PREFIX (\"ftell\"));\n }\n \n \n void\n-gfc_resolve_sum (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n-\t\t gfc_expr * mask)\n+gfc_resolve_sum (gfc_expr *f, gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n {\n   const char *name;\n \n@@ -2130,72 +2104,72 @@ gfc_resolve_sum (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n       gfc_resolve_dim_arg (dim);\n     }\n \n-  f->value.function.name =\n-    gfc_get_string (PREFIX(\"%s_%c%d\"), name,\n+  f->value.function.name\n+    = gfc_get_string (PREFIX (\"%s_%c%d\"), name,\n \t\t    gfc_type_letter (array->ts.type), array->ts.kind);\n }\n \n \n void\n-gfc_resolve_symlnk (gfc_expr * f, gfc_expr * p1 ATTRIBUTE_UNUSED,\n-\t            gfc_expr * p2 ATTRIBUTE_UNUSED)\n+gfc_resolve_symlnk (gfc_expr *f, gfc_expr *p1 ATTRIBUTE_UNUSED,\n+\t\t    gfc_expr *p2 ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n-  f->value.function.name = gfc_get_string (PREFIX(\"symlnk_i%d\"), f->ts.kind);\n+  f->value.function.name = gfc_get_string (PREFIX (\"symlnk_i%d\"), f->ts.kind);\n }\n \n \n /* Resolve the g77 compatibility function SYSTEM.  */\n \n void\n-gfc_resolve_system (gfc_expr * f, gfc_expr * n ATTRIBUTE_UNUSED)\n+gfc_resolve_system (gfc_expr *f, gfc_expr *n ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = 4;\n-  f->value.function.name = gfc_get_string (PREFIX(\"system\"));\n+  f->value.function.name = gfc_get_string (PREFIX (\"system\"));\n }\n \n \n void\n-gfc_resolve_tan (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_tan (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__tan_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__tan_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n }\n \n \n void\n-gfc_resolve_tanh (gfc_expr * f, gfc_expr * x)\n+gfc_resolve_tanh (gfc_expr *f, gfc_expr *x)\n {\n   f->ts = x->ts;\n-  f->value.function.name =\n-    gfc_get_string (\"__tanh_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__tanh_%c%d\", gfc_type_letter (x->ts.type), x->ts.kind);\n }\n \n \n void\n-gfc_resolve_time (gfc_expr * f)\n+gfc_resolve_time (gfc_expr *f)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = 4;\n-  f->value.function.name = gfc_get_string (PREFIX(\"time_func\"));\n+  f->value.function.name = gfc_get_string (PREFIX (\"time_func\"));\n }\n \n \n void\n-gfc_resolve_time8 (gfc_expr * f)\n+gfc_resolve_time8 (gfc_expr *f)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = 8;\n-  f->value.function.name = gfc_get_string (PREFIX(\"time8_func\"));\n+  f->value.function.name = gfc_get_string (PREFIX (\"time8_func\"));\n }\n \n \n void\n-gfc_resolve_transfer (gfc_expr * f, gfc_expr * source ATTRIBUTE_UNUSED,\n-\t\t      gfc_expr * mold, gfc_expr * size)\n+gfc_resolve_transfer (gfc_expr *f, gfc_expr *source ATTRIBUTE_UNUSED,\n+\t\t      gfc_expr *mold, gfc_expr *size)\n {\n   /* TODO: Make this do something meaningful.  */\n   static char transfer0[] = \"__transfer0\", transfer1[] = \"__transfer1\";\n@@ -2221,7 +2195,7 @@ gfc_resolve_transfer (gfc_expr * f, gfc_expr * source ATTRIBUTE_UNUSED,\n \n \n void\n-gfc_resolve_transpose (gfc_expr * f, gfc_expr * matrix)\n+gfc_resolve_transpose (gfc_expr *f, gfc_expr *matrix)\n {\n   f->ts = matrix->ts;\n   f->rank = 2;\n@@ -2239,40 +2213,40 @@ gfc_resolve_transpose (gfc_expr * f, gfc_expr * matrix)\n     case 10:\n     case 16:\n       switch (matrix->ts.type)\n-        {\n-        case BT_REAL:\n-        case BT_COMPLEX:\n-          f->value.function.name =\n-            gfc_get_string (PREFIX(\"transpose_%c%d\"),\n-\t\t\t    gfc_type_letter (matrix->ts.type),\n-\t\t\t    matrix->ts.kind);\n-          break;\n-\n-        case BT_INTEGER:\n-        case BT_LOGICAL:\n+\t{\n+\tcase BT_REAL:\n+\tcase BT_COMPLEX:\n+\t  f->value.function.name\n+\t    = gfc_get_string (PREFIX (\"transpose_%c%d\"),\n+\t\t\t      gfc_type_letter (matrix->ts.type),\n+\t\t\t      matrix->ts.kind);\n+\t  break;\n+\n+\tcase BT_INTEGER:\n+\tcase BT_LOGICAL:\n \t  /* Use the integer routines for real and logical cases.  This\n \t     assumes they all have the same alignment requirements.  */\n-          f->value.function.name =\n-            gfc_get_string (PREFIX(\"transpose_i%d\"), matrix->ts.kind);\n-          break;\n-\n-        default:\n-          f->value.function.name = PREFIX(\"transpose\");\n-          break;\n-        }\n+\t  f->value.function.name\n+\t    = gfc_get_string (PREFIX (\"transpose_i%d\"), matrix->ts.kind);\n+\t  break;\n+\n+\tdefault:\n+\t  f->value.function.name = PREFIX (\"transpose\");\n+\t  break;\n+\t}\n       break;\n \n     default:\n       f->value.function.name = (matrix->ts.type == BT_CHARACTER\n-\t\t\t\t? PREFIX(\"transpose_char\")\n-\t\t\t\t: PREFIX(\"transpose\"));\n+\t\t\t\t? PREFIX (\"transpose_char\")\n+\t\t\t\t: PREFIX (\"transpose\"));\n       break;\n     }\n }\n \n \n void\n-gfc_resolve_trim (gfc_expr * f, gfc_expr * string)\n+gfc_resolve_trim (gfc_expr *f, gfc_expr *string)\n {\n   f->ts.type = BT_CHARACTER;\n   f->ts.kind = string->ts.kind;\n@@ -2281,8 +2255,7 @@ gfc_resolve_trim (gfc_expr * f, gfc_expr * string)\n \n \n void\n-gfc_resolve_ubound (gfc_expr * f, gfc_expr * array,\n-\t\t    gfc_expr * dim)\n+gfc_resolve_ubound (gfc_expr *f, gfc_expr *array, gfc_expr *dim)\n {\n   static char ubound[] = \"__ubound\";\n \n@@ -2303,27 +2276,27 @@ gfc_resolve_ubound (gfc_expr * f, gfc_expr * array,\n /* Resolve the g77 compatibility function UMASK.  */\n \n void\n-gfc_resolve_umask (gfc_expr * f, gfc_expr * n)\n+gfc_resolve_umask (gfc_expr *f, gfc_expr *n)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = n->ts.kind;\n-  f->value.function.name = gfc_get_string (PREFIX(\"umask_i%d\"), n->ts.kind);\n+  f->value.function.name = gfc_get_string (PREFIX (\"umask_i%d\"), n->ts.kind);\n }\n \n \n /* Resolve the g77 compatibility function UNLINK.  */\n \n void\n-gfc_resolve_unlink (gfc_expr * f, gfc_expr * n ATTRIBUTE_UNUSED)\n+gfc_resolve_unlink (gfc_expr *f, gfc_expr *n ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = 4;\n-  f->value.function.name = gfc_get_string (PREFIX(\"unlink\"));\n+  f->value.function.name = gfc_get_string (PREFIX (\"unlink\"));\n }\n \n \n void\n-gfc_resolve_ttynam (gfc_expr * f, gfc_expr * unit)\n+gfc_resolve_ttynam (gfc_expr *f, gfc_expr *unit)\n {\n   gfc_typespec ts;\n   \n@@ -2339,27 +2312,27 @@ gfc_resolve_ttynam (gfc_expr * f, gfc_expr * unit)\n       gfc_convert_type (unit, &ts, 2);\n     }\n \n-  f->value.function.name = gfc_get_string (PREFIX(\"ttynam\"));\n+  f->value.function.name = gfc_get_string (PREFIX (\"ttynam\"));\n }\n \n \n void\n-gfc_resolve_unpack (gfc_expr * f, gfc_expr * vector, gfc_expr * mask,\n-\t\t    gfc_expr * field ATTRIBUTE_UNUSED)\n+gfc_resolve_unpack (gfc_expr *f, gfc_expr *vector, gfc_expr *mask,\n+\t\t    gfc_expr *field ATTRIBUTE_UNUSED)\n {\n   f->ts = vector->ts;\n   f->rank = mask->rank;\n \n-  f->value.function.name =\n-    gfc_get_string (PREFIX(\"unpack%d%s\"), field->rank > 0 ? 1 : 0,\n-\t\t    vector->ts.type == BT_CHARACTER ? \"_char\" : \"\");\n+  f->value.function.name\n+    = gfc_get_string (PREFIX (\"unpack%d%s\"), field->rank > 0 ? 1 : 0,\n+\t\t      vector->ts.type == BT_CHARACTER ? \"_char\" : \"\");\n }\n \n \n void\n-gfc_resolve_verify (gfc_expr * f, gfc_expr * string,\n-\t\t    gfc_expr * set ATTRIBUTE_UNUSED,\n-\t\t    gfc_expr * back ATTRIBUTE_UNUSED)\n+gfc_resolve_verify (gfc_expr *f, gfc_expr *string,\n+\t\t    gfc_expr *set ATTRIBUTE_UNUSED,\n+\t\t    gfc_expr *back ATTRIBUTE_UNUSED)\n {\n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n@@ -2368,29 +2341,28 @@ gfc_resolve_verify (gfc_expr * f, gfc_expr * string,\n \n \n void\n-gfc_resolve_xor (gfc_expr * f, gfc_expr * i, gfc_expr * j)\n+gfc_resolve_xor (gfc_expr *f, gfc_expr *i, gfc_expr *j)\n {\n   f->ts.type = i->ts.type;\n-  f->ts.kind = gfc_kind_max (i,j);\n+  f->ts.kind = gfc_kind_max (i, j);\n \n   if (i->ts.kind != j->ts.kind)\n     {\n-      if (i->ts.kind == gfc_kind_max (i,j))\n-\tgfc_convert_type(j, &i->ts, 2);\n+      if (i->ts.kind == gfc_kind_max (i, j))\n+\tgfc_convert_type (j, &i->ts, 2);\n       else\n-\tgfc_convert_type(i, &j->ts, 2);\n+\tgfc_convert_type (i, &j->ts, 2);\n     }\n \n-  f->value.function.name = gfc_get_string (\"__xor_%c%d\",\n-\t\t\t\t\t   gfc_type_letter (i->ts.type),\n-\t\t\t\t\t   f->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__xor_%c%d\", gfc_type_letter (i->ts.type), f->ts.kind);\n }\n \n \n /* Intrinsic subroutine resolution.  */\n \n void\n-gfc_resolve_alarm_sub (gfc_code * c)\n+gfc_resolve_alarm_sub (gfc_code *c)\n {\n   const char *name;\n   gfc_expr *seconds, *handler, *status;\n@@ -2407,10 +2379,10 @@ gfc_resolve_alarm_sub (gfc_code * c)\n     {\n       if (handler->ts.kind != gfc_c_int_kind)\n \tgfc_convert_type (handler, &ts, 2);\n-      name = gfc_get_string (PREFIX(\"alarm_sub_int\"));\n+      name = gfc_get_string (PREFIX (\"alarm_sub_int\"));\n     }\n   else\n-    name = gfc_get_string (PREFIX(\"alarm_sub\"));\n+    name = gfc_get_string (PREFIX (\"alarm_sub\"));\n \n   if (seconds->ts.kind != gfc_c_int_kind)\n     gfc_convert_type (seconds, &ts, 2);\n@@ -2421,47 +2393,43 @@ gfc_resolve_alarm_sub (gfc_code * c)\n }\n \n void\n-gfc_resolve_cpu_time (gfc_code * c)\n+gfc_resolve_cpu_time (gfc_code *c)\n {\n   const char *name;\n-\n-  name = gfc_get_string (PREFIX(\"cpu_time_%d\"),\n-\t\t\t c->ext.actual->expr->ts.kind);\n+  name = gfc_get_string (PREFIX (\"cpu_time_%d\"), c->ext.actual->expr->ts.kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n void\n-gfc_resolve_mvbits (gfc_code * c)\n+gfc_resolve_mvbits (gfc_code *c)\n {\n   const char *name;\n   int kind;\n-\n   kind = c->ext.actual->expr->ts.kind;\n-  name = gfc_get_string (PREFIX(\"mvbits_i%d\"), kind);\n-\n+  name = gfc_get_string (PREFIX (\"mvbits_i%d\"), kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n void\n-gfc_resolve_random_number (gfc_code * c)\n+gfc_resolve_random_number (gfc_code *c)\n {\n   const char *name;\n   int kind;\n \n   kind = c->ext.actual->expr->ts.kind;\n   if (c->ext.actual->expr->rank == 0)\n-    name = gfc_get_string (PREFIX(\"random_r%d\"), kind);\n+    name = gfc_get_string (PREFIX (\"random_r%d\"), kind);\n   else\n-    name = gfc_get_string (PREFIX(\"arandom_r%d\"), kind);\n+    name = gfc_get_string (PREFIX (\"arandom_r%d\"), kind);\n   \n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n void\n-gfc_resolve_rename_sub (gfc_code * c)\n+gfc_resolve_rename_sub (gfc_code *c)\n {\n   const char *name;\n   int kind;\n@@ -2471,13 +2439,13 @@ gfc_resolve_rename_sub (gfc_code * c)\n   else\n     kind = gfc_default_integer_kind;\n \n-  name = gfc_get_string (PREFIX(\"rename_i%d_sub\"), kind);\n+  name = gfc_get_string (PREFIX (\"rename_i%d_sub\"), kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n void\n-gfc_resolve_kill_sub (gfc_code * c)\n+gfc_resolve_kill_sub (gfc_code *c)\n {\n   const char *name;\n   int kind;\n@@ -2487,13 +2455,13 @@ gfc_resolve_kill_sub (gfc_code * c)\n   else\n     kind = gfc_default_integer_kind;\n \n-  name = gfc_get_string (PREFIX(\"kill_i%d_sub\"), kind);\n+  name = gfc_get_string (PREFIX (\"kill_i%d_sub\"), kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n     \n \n void\n-gfc_resolve_link_sub (gfc_code * c)\n+gfc_resolve_link_sub (gfc_code *c)\n {\n   const char *name;\n   int kind;\n@@ -2503,13 +2471,13 @@ gfc_resolve_link_sub (gfc_code * c)\n   else\n     kind = gfc_default_integer_kind;\n \n-  name = gfc_get_string (PREFIX(\"link_i%d_sub\"), kind);\n+  name = gfc_get_string (PREFIX (\"link_i%d_sub\"), kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n void\n-gfc_resolve_symlnk_sub (gfc_code * c)\n+gfc_resolve_symlnk_sub (gfc_code *c)\n {\n   const char *name;\n   int kind;\n@@ -2519,72 +2487,70 @@ gfc_resolve_symlnk_sub (gfc_code * c)\n   else\n     kind = gfc_default_integer_kind;\n \n-  name = gfc_get_string (PREFIX(\"symlnk_i%d_sub\"), kind);\n+  name = gfc_get_string (PREFIX (\"symlnk_i%d_sub\"), kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n /* G77 compatibility subroutines etime() and dtime().  */\n \n void\n-gfc_resolve_etime_sub (gfc_code * c)\n+gfc_resolve_etime_sub (gfc_code *c)\n {\n   const char *name;\n-\n-  name = gfc_get_string (PREFIX(\"etime_sub\"));\n+  name = gfc_get_string (PREFIX (\"etime_sub\"));\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n /* G77 compatibility subroutines itime(), idate(), ltime() and gmtime().  */\n \n void\n-gfc_resolve_itime (gfc_code * c)\n+gfc_resolve_itime (gfc_code *c)\n {\n-  c->resolved_sym = gfc_get_intrinsic_sub_symbol\n-\t\t      (gfc_get_string (PREFIX(\"itime_i%d\"),\n-\t\t\t\t       gfc_default_integer_kind));\n+  c->resolved_sym\n+    = gfc_get_intrinsic_sub_symbol (gfc_get_string (PREFIX (\"itime_i%d\"),\n+\t\t\t\t\t\t    gfc_default_integer_kind));\n }\n \n void\n-gfc_resolve_idate (gfc_code * c)\n+gfc_resolve_idate (gfc_code *c)\n {\n-  c->resolved_sym = gfc_get_intrinsic_sub_symbol\n-\t\t      (gfc_get_string (PREFIX(\"idate_i%d\"),\n-\t\t\t\t       gfc_default_integer_kind));\n+  c->resolved_sym\n+    = gfc_get_intrinsic_sub_symbol (gfc_get_string (PREFIX (\"idate_i%d\"),\n+\t\t\t\t\t\t    gfc_default_integer_kind));\n }\n \n void\n-gfc_resolve_ltime (gfc_code * c)\n+gfc_resolve_ltime (gfc_code *c)\n {\n-  c->resolved_sym = gfc_get_intrinsic_sub_symbol\n-\t\t      (gfc_get_string (PREFIX(\"ltime_i%d\"),\n-\t\t\t\t       gfc_default_integer_kind));\n+  c->resolved_sym\n+    = gfc_get_intrinsic_sub_symbol (gfc_get_string (PREFIX (\"ltime_i%d\"),\n+\t\t\t\t\t\t    gfc_default_integer_kind));\n }\n \n void\n-gfc_resolve_gmtime (gfc_code * c)\n+gfc_resolve_gmtime (gfc_code *c)\n {\n-  c->resolved_sym = gfc_get_intrinsic_sub_symbol\n-\t\t      (gfc_get_string (PREFIX(\"gmtime_i%d\"),\n-\t\t\t\t       gfc_default_integer_kind));\n+  c->resolved_sym\n+    = gfc_get_intrinsic_sub_symbol (gfc_get_string (PREFIX (\"gmtime_i%d\"),\n+\t\t\t\t\t\t    gfc_default_integer_kind));\n }\n \n \n /* G77 compatibility subroutine second().  */\n \n void\n-gfc_resolve_second_sub (gfc_code * c)\n+gfc_resolve_second_sub (gfc_code *c)\n {\n   const char *name;\n-\n-  name = gfc_get_string (PREFIX(\"second_sub\"));\n+  name = gfc_get_string (PREFIX (\"second_sub\"));\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n void\n-gfc_resolve_sleep_sub (gfc_code * c)\n+gfc_resolve_sleep_sub (gfc_code *c)\n {\n   const char *name;\n   int kind;\n@@ -2594,39 +2560,39 @@ gfc_resolve_sleep_sub (gfc_code * c)\n   else\n     kind = gfc_default_integer_kind;\n \n-  name = gfc_get_string (PREFIX(\"sleep_i%d_sub\"), kind);\n+  name = gfc_get_string (PREFIX (\"sleep_i%d_sub\"), kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n /* G77 compatibility function srand().  */\n \n void\n-gfc_resolve_srand (gfc_code * c)\n+gfc_resolve_srand (gfc_code *c)\n {\n   const char *name;\n-  name = gfc_get_string (PREFIX(\"srand\"));\n+  name = gfc_get_string (PREFIX (\"srand\"));\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n /* Resolve the getarg intrinsic subroutine.  */\n \n void\n-gfc_resolve_getarg (gfc_code * c)\n+gfc_resolve_getarg (gfc_code *c)\n {\n   const char *name;\n   int kind;\n-\n   kind = gfc_default_integer_kind;\n-  name = gfc_get_string (PREFIX(\"getarg_i%d\"), kind);\n+  name = gfc_get_string (PREFIX (\"getarg_i%d\"), kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n+\n /* Resolve the getcwd intrinsic subroutine.  */\n \n void\n-gfc_resolve_getcwd_sub (gfc_code * c)\n+gfc_resolve_getcwd_sub (gfc_code *c)\n {\n   const char *name;\n   int kind;\n@@ -2636,53 +2602,52 @@ gfc_resolve_getcwd_sub (gfc_code * c)\n   else\n     kind = gfc_default_integer_kind;\n \n-  name = gfc_get_string (PREFIX(\"getcwd_i%d_sub\"), kind);\n+  name = gfc_get_string (PREFIX (\"getcwd_i%d_sub\"), kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n /* Resolve the get_command intrinsic subroutine.  */\n \n void\n-gfc_resolve_get_command (gfc_code * c)\n+gfc_resolve_get_command (gfc_code *c)\n {\n   const char *name;\n   int kind;\n-\n   kind = gfc_default_integer_kind;\n-  name = gfc_get_string (PREFIX(\"get_command_i%d\"), kind);\n+  name = gfc_get_string (PREFIX (\"get_command_i%d\"), kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n /* Resolve the get_command_argument intrinsic subroutine.  */\n \n void\n-gfc_resolve_get_command_argument (gfc_code * c)\n+gfc_resolve_get_command_argument (gfc_code *c)\n {\n   const char *name;\n   int kind;\n-\n   kind = gfc_default_integer_kind;\n-  name = gfc_get_string (PREFIX(\"get_command_argument_i%d\"), kind);\n+  name = gfc_get_string (PREFIX (\"get_command_argument_i%d\"), kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n+\n /* Resolve the get_environment_variable intrinsic subroutine.  */\n \n void\n-gfc_resolve_get_environment_variable (gfc_code * code)\n+gfc_resolve_get_environment_variable (gfc_code *code)\n {\n   const char *name;\n   int kind;\n-\n   kind = gfc_default_integer_kind;\n-  name = gfc_get_string (PREFIX(\"get_environment_variable_i%d\"), kind);\n+  name = gfc_get_string (PREFIX (\"get_environment_variable_i%d\"), kind);\n   code->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n+\n void\n-gfc_resolve_signal_sub (gfc_code * c)\n+gfc_resolve_signal_sub (gfc_code *c)\n {\n   const char *name;\n   gfc_expr *number, *handler, *status;\n@@ -2699,10 +2664,10 @@ gfc_resolve_signal_sub (gfc_code * c)\n     {\n       if (handler->ts.kind != gfc_c_int_kind)\n \tgfc_convert_type (handler, &ts, 2);\n-      name = gfc_get_string (PREFIX(\"signal_sub_int\"));\n+      name = gfc_get_string (PREFIX (\"signal_sub_int\"));\n     }\n   else\n-    name = gfc_get_string (PREFIX(\"signal_sub\"));\n+    name = gfc_get_string (PREFIX (\"signal_sub\"));\n \n   if (number->ts.kind != gfc_c_int_kind)\n     gfc_convert_type (number, &ts, 2);\n@@ -2712,21 +2677,22 @@ gfc_resolve_signal_sub (gfc_code * c)\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n+\n /* Resolve the SYSTEM intrinsic subroutine.  */\n \n void\n-gfc_resolve_system_sub (gfc_code * c)\n+gfc_resolve_system_sub (gfc_code *c)\n {\n   const char *name;\n-\n-  name = gfc_get_string (PREFIX(\"system_sub\"));\n+  name = gfc_get_string (PREFIX (\"system_sub\"));\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n+\n /* Determine if the arguments to SYSTEM_CLOCK are INTEGER(4) or INTEGER(8) */\n \n void\n-gfc_resolve_system_clock (gfc_code * c)\n+gfc_resolve_system_clock (gfc_code *c)\n {\n   const char *name;\n   int kind;\n@@ -2740,14 +2706,15 @@ gfc_resolve_system_clock (gfc_code * c)\n   else\n     kind = gfc_default_integer_kind;\n \n-  name = gfc_get_string (PREFIX(\"system_clock_%d\"), kind);\n+  name = gfc_get_string (PREFIX (\"system_clock_%d\"), kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n+\n /* Resolve the EXIT intrinsic subroutine.  */\n \n void\n-gfc_resolve_exit (gfc_code * c)\n+gfc_resolve_exit (gfc_code *c)\n {\n   const char *name;\n   int kind;\n@@ -2757,14 +2724,15 @@ gfc_resolve_exit (gfc_code * c)\n   else\n     kind = gfc_default_integer_kind;\n \n-  name = gfc_get_string (PREFIX(\"exit_i%d\"), kind);\n+  name = gfc_get_string (PREFIX (\"exit_i%d\"), kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n+\n /* Resolve the FLUSH intrinsic subroutine.  */\n \n void\n-gfc_resolve_flush (gfc_code * c)\n+gfc_resolve_flush (gfc_code *c)\n {\n   const char *name;\n   gfc_typespec ts;\n@@ -2773,17 +2741,16 @@ gfc_resolve_flush (gfc_code * c)\n   ts.type = BT_INTEGER;\n   ts.kind = gfc_default_integer_kind;\n   n = c->ext.actual->expr;\n-  if (n != NULL\n-      && n->ts.kind != ts.kind)\n+  if (n != NULL && n->ts.kind != ts.kind)\n     gfc_convert_type (n, &ts, 2);\n \n-  name = gfc_get_string (PREFIX(\"flush_i%d\"), ts.kind);\n+  name = gfc_get_string (PREFIX (\"flush_i%d\"), ts.kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n void\n-gfc_resolve_free (gfc_code * c)\n+gfc_resolve_free (gfc_code *c)\n {\n   gfc_typespec ts;\n   gfc_expr *n;\n@@ -2794,12 +2761,12 @@ gfc_resolve_free (gfc_code * c)\n   if (n->ts.kind != ts.kind)\n     gfc_convert_type (n, &ts, 2);\n \n-  c->resolved_sym = gfc_get_intrinsic_sub_symbol (PREFIX(\"free\"));\n+  c->resolved_sym = gfc_get_intrinsic_sub_symbol (PREFIX (\"free\"));\n }\n \n \n void\n-gfc_resolve_ctime_sub (gfc_code * c)\n+gfc_resolve_ctime_sub (gfc_code *c)\n {\n   gfc_typespec ts;\n   \n@@ -2813,33 +2780,33 @@ gfc_resolve_ctime_sub (gfc_code * c)\n       gfc_convert_type (c->ext.actual->expr, &ts, 2);\n     }\n \n-  c->resolved_sym = gfc_get_intrinsic_sub_symbol (PREFIX(\"ctime_sub\"));\n+  c->resolved_sym = gfc_get_intrinsic_sub_symbol (PREFIX (\"ctime_sub\"));\n }\n \n \n void\n-gfc_resolve_fdate_sub (gfc_code * c)\n+gfc_resolve_fdate_sub (gfc_code *c)\n {\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (PREFIX (\"fdate_sub\"));\n }\n \n \n void\n-gfc_resolve_gerror (gfc_code * c)\n+gfc_resolve_gerror (gfc_code *c)\n {\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (PREFIX (\"gerror\"));\n }\n \n \n void\n-gfc_resolve_getlog (gfc_code * c)\n+gfc_resolve_getlog (gfc_code *c)\n {\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (PREFIX (\"getlog\"));\n }\n \n \n void\n-gfc_resolve_hostnm_sub (gfc_code * c)\n+gfc_resolve_hostnm_sub (gfc_code *c)\n {\n   const char *name;\n   int kind;\n@@ -2849,41 +2816,39 @@ gfc_resolve_hostnm_sub (gfc_code * c)\n   else\n     kind = gfc_default_integer_kind;\n \n-  name = gfc_get_string (PREFIX(\"hostnm_i%d_sub\"), kind);\n+  name = gfc_get_string (PREFIX (\"hostnm_i%d_sub\"), kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n void\n-gfc_resolve_perror (gfc_code * c)\n+gfc_resolve_perror (gfc_code *c)\n {\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (PREFIX (\"perror_sub\"));\n }\n \n /* Resolve the STAT and FSTAT intrinsic subroutines.  */\n \n void\n-gfc_resolve_stat_sub (gfc_code * c)\n+gfc_resolve_stat_sub (gfc_code *c)\n {\n   const char *name;\n-\n-  name = gfc_get_string (PREFIX(\"stat_i%d_sub\"), gfc_default_integer_kind);\n+  name = gfc_get_string (PREFIX (\"stat_i%d_sub\"), gfc_default_integer_kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n void\n-gfc_resolve_lstat_sub (gfc_code * c)\n+gfc_resolve_lstat_sub (gfc_code *c)\n {\n   const char *name;\n-\n-  name = gfc_get_string (PREFIX(\"lstat_i%d_sub\"), gfc_default_integer_kind);\n+  name = gfc_get_string (PREFIX (\"lstat_i%d_sub\"), gfc_default_integer_kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n void\n-gfc_resolve_fstat_sub (gfc_code * c)\n+gfc_resolve_fstat_sub (gfc_code *c)\n {\n   const char *name;\n   gfc_expr *u;\n@@ -2893,13 +2858,13 @@ gfc_resolve_fstat_sub (gfc_code * c)\n   ts = &c->ext.actual->next->expr->ts;\n   if (u->ts.kind != ts->kind)\n     gfc_convert_type (u, ts, 2);\n-  name = gfc_get_string (PREFIX(\"fstat_i%d_sub\"), ts->kind);\n+  name = gfc_get_string (PREFIX (\"fstat_i%d_sub\"), ts->kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n void\n-gfc_resolve_fgetc_sub (gfc_code * c)\n+gfc_resolve_fgetc_sub (gfc_code *c)\n {\n   const char *name;\n   gfc_typespec ts;\n@@ -2918,32 +2883,32 @@ gfc_resolve_fgetc_sub (gfc_code * c)\n     }\n \n   if (st != NULL)\n-    name = gfc_get_string (PREFIX(\"fgetc_i%d_sub\"), st->ts.kind);\n+    name = gfc_get_string (PREFIX (\"fgetc_i%d_sub\"), st->ts.kind);\n   else\n-    name = gfc_get_string (PREFIX(\"fgetc_i%d_sub\"), gfc_default_integer_kind);\n+    name = gfc_get_string (PREFIX (\"fgetc_i%d_sub\"), gfc_default_integer_kind);\n \n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n void\n-gfc_resolve_fget_sub (gfc_code * c)\n+gfc_resolve_fget_sub (gfc_code *c)\n {\n   const char *name;\n   gfc_expr *st;\n \n   st = c->ext.actual->next->expr;\n   if (st != NULL)\n-    name = gfc_get_string (PREFIX(\"fget_i%d_sub\"), st->ts.kind);\n+    name = gfc_get_string (PREFIX (\"fget_i%d_sub\"), st->ts.kind);\n   else\n-    name = gfc_get_string (PREFIX(\"fget_i%d_sub\"), gfc_default_integer_kind);\n+    name = gfc_get_string (PREFIX (\"fget_i%d_sub\"), gfc_default_integer_kind);\n \n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n void\n-gfc_resolve_fputc_sub (gfc_code * c)\n+gfc_resolve_fputc_sub (gfc_code *c)\n {\n   const char *name;\n   gfc_typespec ts;\n@@ -2962,32 +2927,32 @@ gfc_resolve_fputc_sub (gfc_code * c)\n     }\n \n   if (st != NULL)\n-    name = gfc_get_string (PREFIX(\"fputc_i%d_sub\"), st->ts.kind);\n+    name = gfc_get_string (PREFIX (\"fputc_i%d_sub\"), st->ts.kind);\n   else\n-    name = gfc_get_string (PREFIX(\"fputc_i%d_sub\"), gfc_default_integer_kind);\n+    name = gfc_get_string (PREFIX (\"fputc_i%d_sub\"), gfc_default_integer_kind);\n \n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n void\n-gfc_resolve_fput_sub (gfc_code * c)\n+gfc_resolve_fput_sub (gfc_code *c)\n {\n   const char *name;\n   gfc_expr *st;\n \n   st = c->ext.actual->next->expr;\n   if (st != NULL)\n-    name = gfc_get_string (PREFIX(\"fput_i%d_sub\"), st->ts.kind);\n+    name = gfc_get_string (PREFIX (\"fput_i%d_sub\"), st->ts.kind);\n   else\n-    name = gfc_get_string (PREFIX(\"fput_i%d_sub\"), gfc_default_integer_kind);\n+    name = gfc_get_string (PREFIX (\"fput_i%d_sub\"), gfc_default_integer_kind);\n \n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n void\n-gfc_resolve_ftell_sub (gfc_code * c)\n+gfc_resolve_ftell_sub (gfc_code *c)\n {\n   const char *name;\n   gfc_expr *unit;\n@@ -3006,13 +2971,13 @@ gfc_resolve_ftell_sub (gfc_code * c)\n       gfc_convert_type (unit, &ts, 2);\n     }\n \n-  name = gfc_get_string (PREFIX(\"ftell_i%d_sub\"), offset->ts.kind);\n+  name = gfc_get_string (PREFIX (\"ftell_i%d_sub\"), offset->ts.kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n \n void\n-gfc_resolve_ttynam_sub (gfc_code * c)\n+gfc_resolve_ttynam_sub (gfc_code *c)\n {\n   gfc_typespec ts;\n   \n@@ -3025,14 +2990,14 @@ gfc_resolve_ttynam_sub (gfc_code * c)\n       gfc_convert_type (c->ext.actual->expr, &ts, 2);\n     }\n \n-  c->resolved_sym = gfc_get_intrinsic_sub_symbol (PREFIX(\"ttynam_sub\"));\n+  c->resolved_sym = gfc_get_intrinsic_sub_symbol (PREFIX (\"ttynam_sub\"));\n }\n \n \n /* Resolve the UMASK intrinsic subroutine.  */\n \n void\n-gfc_resolve_umask_sub (gfc_code * c)\n+gfc_resolve_umask_sub (gfc_code *c)\n {\n   const char *name;\n   int kind;\n@@ -3042,14 +3007,14 @@ gfc_resolve_umask_sub (gfc_code * c)\n   else\n     kind = gfc_default_integer_kind;\n \n-  name = gfc_get_string (PREFIX(\"umask_i%d_sub\"), kind);\n+  name = gfc_get_string (PREFIX (\"umask_i%d_sub\"), kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n /* Resolve the UNLINK intrinsic subroutine.  */\n \n void\n-gfc_resolve_unlink_sub (gfc_code * c)\n+gfc_resolve_unlink_sub (gfc_code *c)\n {\n   const char *name;\n   int kind;\n@@ -3059,6 +3024,6 @@ gfc_resolve_unlink_sub (gfc_code * c)\n   else\n     kind = gfc_default_integer_kind;\n \n-  name = gfc_get_string (PREFIX(\"unlink_i%d_sub\"), kind);\n+  name = gfc_get_string (PREFIX (\"unlink_i%d_sub\"), kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }"}, {"sha": "e3d37d25c7e7db6297501fe0727cfc90f9f345fe", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 128, "deletions": 164, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b251af97928db06c0a2174b230a3ae9f83745a04/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b251af97928db06c0a2174b230a3ae9f83745a04/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=b251af97928db06c0a2174b230a3ae9f83745a04", "patch": "@@ -1,5 +1,5 @@\n /* Matching subroutines in all sizes, shapes and colors.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -20,7 +20,6 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"flags.h\"\n@@ -225,7 +224,7 @@ gfc_match_small_int (int *value)\n    do most of the work.  */\n \n match\n-gfc_match_st_label (gfc_st_label ** label)\n+gfc_match_st_label (gfc_st_label **label)\n {\n   locus old_loc;\n   match m;\n@@ -314,7 +313,7 @@ gfc_match_label (void)\n    A '%' character is a mandatory space.  */\n \n int\n-gfc_match_strings (mstring * a)\n+gfc_match_strings (mstring *a)\n {\n   mstring *p, *best_match;\n   int no_match, c, possibles;\n@@ -348,8 +347,7 @@ gfc_match_strings (mstring * a)\n \t  if (*p->mp == ' ')\n \t    {\n \t      /* Space matches 1+ whitespace(s).  */\n-\t      if ((gfc_current_form == FORM_FREE)\n-\t\t  && gfc_is_whitespace (c))\n+\t      if ((gfc_current_form == FORM_FREE) && gfc_is_whitespace (c))\n \t\tcontinue;\n \n \t      p->mp++;\n@@ -397,7 +395,7 @@ gfc_match_name (char *buffer)\n   if (!ISALPHA (c))\n     {\n       if (gfc_error_flag_test() == 0)\n-        gfc_error (\"Invalid character in name at %C\");\n+\tgfc_error (\"Invalid character in name at %C\");\n       gfc_current_locus = old_loc;\n       return MATCH_NO;\n     }\n@@ -417,9 +415,7 @@ gfc_match_name (char *buffer)\n       old_loc = gfc_current_locus;\n       c = gfc_next_char ();\n     }\n-  while (ISALNUM (c)\n-\t || c == '_'\n-\t || (gfc_option.flag_dollar_ok && c == '$'));\n+  while (ISALNUM (c) || c == '_' || (gfc_option.flag_dollar_ok && c == '$'));\n \n   buffer[i] = '\\0';\n   gfc_current_locus = old_loc;\n@@ -432,7 +428,7 @@ gfc_match_name (char *buffer)\n    pointer if successful.  */\n \n match\n-gfc_match_sym_tree (gfc_symtree ** matched_symbol, int host_assoc)\n+gfc_match_sym_tree (gfc_symtree **matched_symbol, int host_assoc)\n {\n   char buffer[GFC_MAX_SYMBOL_LEN + 1];\n   match m;\n@@ -443,7 +439,7 @@ gfc_match_sym_tree (gfc_symtree ** matched_symbol, int host_assoc)\n \n   if (host_assoc)\n     return (gfc_get_ha_sym_tree (buffer, matched_symbol))\n-      ? MATCH_ERROR : MATCH_YES;\n+\t   ? MATCH_ERROR : MATCH_YES;\n \n   if (gfc_get_sym_tree (buffer, NULL, matched_symbol))\n     return MATCH_ERROR;\n@@ -453,7 +449,7 @@ gfc_match_sym_tree (gfc_symtree ** matched_symbol, int host_assoc)\n \n \n match\n-gfc_match_symbol (gfc_symbol ** matched_symbol, int host_assoc)\n+gfc_match_symbol (gfc_symbol **matched_symbol, int host_assoc)\n {\n   gfc_symtree *st;\n   match m;\n@@ -463,21 +459,22 @@ gfc_match_symbol (gfc_symbol ** matched_symbol, int host_assoc)\n   if (m == MATCH_YES)\n     {\n       if (st)\n-        *matched_symbol = st->n.sym;\n+\t*matched_symbol = st->n.sym;\n       else\n-        *matched_symbol = NULL;\n+\t*matched_symbol = NULL;\n     }\n   else\n     *matched_symbol = NULL;\n   return m;\n }\n \n+\n /* Match an intrinsic operator.  Returns an INTRINSIC enum. While matching, \n    we always find INTRINSIC_PLUS before INTRINSIC_UPLUS. We work around this \n    in matchexp.c.  */\n \n match\n-gfc_match_intrinsic_op (gfc_intrinsic_op * result)\n+gfc_match_intrinsic_op (gfc_intrinsic_op *result)\n {\n   gfc_intrinsic_op op;\n \n@@ -500,15 +497,14 @@ gfc_match_intrinsic_op (gfc_intrinsic_op * result)\n    the equals sign is seen.  */\n \n match\n-gfc_match_iterator (gfc_iterator * iter, int init_flag)\n+gfc_match_iterator (gfc_iterator *iter, int init_flag)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_expr *var, *e1, *e2, *e3;\n   locus start;\n   match m;\n \n-  /* Match the start of an iterator without affecting the symbol\n-     table.  */\n+  /* Match the start of an iterator without affecting the symbol table.  */\n \n   start = gfc_current_locus;\n   m = gfc_match (\" %n =\", name);\n@@ -784,7 +780,7 @@ gfc_match (const char *target, ...)\n \t    case 'l':\n \t    case 'n':\n \t    case 's':\n-\t      (void)va_arg (argp, void **);\n+\t      (void) va_arg (argp, void **);\n \t      break;\n \n \t    case 'e':\n@@ -936,6 +932,7 @@ gfc_match_pointer_assignment (void)\n    when just after having encountered a simple IF statement. This code\n    is really duplicate with parts of the gfc_match_if code, but this is\n    *much* easier.  */\n+\n static match\n match_arithmetic_if (void)\n {\n@@ -955,8 +952,8 @@ match_arithmetic_if (void)\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_notify_std (GFC_STD_F95_DEL,\n-\t\t      \"Obsolete: arithmetic IF statement at %C\") == FAILURE)\n+  if (gfc_notify_std (GFC_STD_F95_DEL, \"Obsolete: arithmetic IF statement \"\n+\t\t      \"at %C\") == FAILURE)\n     return MATCH_ERROR;\n \n   new_st.op = EXEC_ARITHMETIC_IF;\n@@ -983,7 +980,7 @@ static match match_simple_forall (void);\n static match match_simple_where (void);\n \n match\n-gfc_match_if (gfc_statement * if_type)\n+gfc_match_if (gfc_statement *if_type)\n {\n   gfc_expr *expr;\n   gfc_st_label *l1, *l2, *l3;\n@@ -1014,10 +1011,8 @@ gfc_match_if (gfc_statement * if_type)\n     {\n       if (n == MATCH_YES)\n \t{\n-\t  gfc_error\n-\t    (\"Block label not appropriate for arithmetic IF statement \"\n-\t     \"at %C\");\n-\n+\t  gfc_error (\"Block label not appropriate for arithmetic IF \"\n+\t\t     \"statement at %C\");\n \t  gfc_free_expr (expr);\n \t  return MATCH_ERROR;\n \t}\n@@ -1026,15 +1021,13 @@ gfc_match_if (gfc_statement * if_type)\n \t  || gfc_reference_st_label (l2, ST_LABEL_TARGET) == FAILURE\n \t  || gfc_reference_st_label (l3, ST_LABEL_TARGET) == FAILURE)\n \t{\n-\n \t  gfc_free_expr (expr);\n \t  return MATCH_ERROR;\n \t}\n       \n-      if (gfc_notify_std (GFC_STD_F95_DEL,\n-  \t\t          \"Obsolete: arithmetic IF statement at %C\")\n-\t  == FAILURE)\n-        return MATCH_ERROR;\n+      if (gfc_notify_std (GFC_STD_F95_DEL, \"Obsolete: arithmetic IF \"\n+\t\t\t  \"statement at %C\") == FAILURE)\n+\treturn MATCH_ERROR;\n \n       new_st.op = EXEC_ARITHMETIC_IF;\n       new_st.expr = expr;\n@@ -1050,15 +1043,13 @@ gfc_match_if (gfc_statement * if_type)\n     {\n       new_st.op = EXEC_IF;\n       new_st.expr = expr;\n-\n       *if_type = ST_IF_BLOCK;\n       return MATCH_YES;\n     }\n \n   if (n == MATCH_YES)\n     {\n       gfc_error (\"Block label is not appropriate IF statement at %C\");\n-\n       gfc_free_expr (expr);\n       return MATCH_ERROR;\n     }\n@@ -1146,7 +1137,7 @@ gfc_match_if (gfc_statement * if_type)\n \n   /* All else has failed, so give up.  See if any of the matchers has\n      stored an error message of some sort.  */\n-    if (gfc_error_check () == 0)\n+  if (gfc_error_check () == 0)\n     gfc_error (\"Unclassifiable statement in IF-clause at %C\");\n \n   gfc_free_expr (expr);\n@@ -1258,9 +1249,8 @@ gfc_match_elseif (void)\n /* Free a gfc_iterator structure.  */\n \n void\n-gfc_free_iterator (gfc_iterator * iter, int flag)\n+gfc_free_iterator (gfc_iterator *iter, int flag)\n {\n-\n   if (iter == NULL)\n     return;\n \n@@ -1310,8 +1300,7 @@ gfc_match_do (void)\n     }\n \n   /* match an optional comma, if no comma is found a space is obligatory.  */\n-  if (gfc_match_char(',') != MATCH_YES\n-      && gfc_match (\"% \") != MATCH_YES)\n+  if (gfc_match_char(',') != MATCH_YES && gfc_match (\"% \") != MATCH_YES)\n     return MATCH_NO;\n \n   /* See if we have a DO WHILE.  */\n@@ -1456,7 +1445,6 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n match\n gfc_match_exit (void)\n {\n-\n   return match_exit_cycle (ST_EXIT, EXEC_EXIT);\n }\n \n@@ -1466,7 +1454,6 @@ gfc_match_exit (void)\n match\n gfc_match_cycle (void)\n {\n-\n   return match_exit_cycle (ST_CYCLE, EXEC_CYCLE);\n }\n \n@@ -1488,7 +1475,7 @@ gfc_match_stopcode (gfc_statement st)\n     {\n       m = gfc_match_small_literal_int (&stop_code, &cnt);\n       if (m == MATCH_ERROR)\n-        goto cleanup;\n+\tgoto cleanup;\n \n       if (m == MATCH_YES && cnt > 5)\n \t{\n@@ -1497,25 +1484,25 @@ gfc_match_stopcode (gfc_statement st)\n \t}\n \n       if (m == MATCH_NO)\n-        {\n-          /* Try a character constant.  */\n-          m = gfc_match_expr (&e);\n-          if (m == MATCH_ERROR)\n-            goto cleanup;\n-          if (m == MATCH_NO)\n-            goto syntax;\n-          if (e->ts.type != BT_CHARACTER || e->expr_type != EXPR_CONSTANT)\n-            goto syntax;\n-        }\n+\t{\n+\t  /* Try a character constant.  */\n+\t  m = gfc_match_expr (&e);\n+\t  if (m == MATCH_ERROR)\n+\t    goto cleanup;\n+\t  if (m == MATCH_NO)\n+\t    goto syntax;\n+\t  if (e->ts.type != BT_CHARACTER || e->expr_type != EXPR_CONSTANT)\n+\t    goto syntax;\n+\t}\n \n       if (gfc_match_eos () != MATCH_YES)\n-        goto syntax;\n+\tgoto syntax;\n     }\n \n   if (gfc_pure (NULL))\n     {\n       gfc_error (\"%s statement not allowed in PURE procedure at %C\",\n-\t         gfc_ascii_statement (st));\n+\t\t gfc_ascii_statement (st));\n       goto cleanup;\n     }\n \n@@ -1544,8 +1531,7 @@ gfc_match_pause (void)\n   m = gfc_match_stopcode (ST_PAUSE);\n   if (m == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_F95_DEL,\n-\t    \"Obsolete: PAUSE statement at %C\")\n+      if (gfc_notify_std (GFC_STD_F95_DEL, \"Obsolete: PAUSE statement at %C\")\n \t  == FAILURE)\n \tm = MATCH_ERROR;\n     }\n@@ -1567,7 +1553,6 @@ gfc_match_stop (void)\n match\n gfc_match_continue (void)\n {\n-\n   if (gfc_match_eos () != MATCH_YES)\n     {\n       gfc_syntax_error (ST_CONTINUE);\n@@ -1590,21 +1575,21 @@ gfc_match_assign (void)\n   if (gfc_match (\" %l\", &label) == MATCH_YES)\n     {\n       if (gfc_reference_st_label (label, ST_LABEL_UNKNOWN) == FAILURE)\n-        return MATCH_ERROR;\n+\treturn MATCH_ERROR;\n       if (gfc_match (\" to %v%t\", &expr) == MATCH_YES)\n-        {\n-\t  if (gfc_notify_std (GFC_STD_F95_DEL,\n-\t\t\"Obsolete: ASSIGN statement at %C\")\n+\t{\n+\t  if (gfc_notify_std (GFC_STD_F95_DEL, \"Obsolete: ASSIGN \"\n+\t\t\t      \"statement at %C\")\n \t      == FAILURE)\n \t    return MATCH_ERROR;\n \n-          expr->symtree->n.sym->attr.assign = 1;\n+\t  expr->symtree->n.sym->attr.assign = 1;\n \n-          new_st.op = EXEC_LABEL_ASSIGN;\n-          new_st.label = label;\n-          new_st.expr = expr;\n-          return MATCH_YES;\n-        }\n+\t  new_st.op = EXEC_LABEL_ASSIGN;\n+\t  new_st.label = label;\n+\t  new_st.expr = expr;\n+\t  return MATCH_YES;\n+\t}\n     }\n   return MATCH_NO;\n }\n@@ -1639,8 +1624,8 @@ gfc_match_goto (void)\n \n   if (gfc_match_variable (&expr, 0) == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_F95_DEL,\n-\t\t\t  \"Obsolete: Assigned GOTO statement at %C\")\n+      if (gfc_notify_std (GFC_STD_F95_DEL, \"Obsolete: Assigned GOTO \"\n+\t\t\t  \"statement at %C\")\n \t  == FAILURE)\n \treturn MATCH_ERROR;\n \n@@ -1686,8 +1671,7 @@ gfc_match_goto (void)\n \n       if (head == NULL)\n \t{\n-\t   gfc_error (\n-\t       \"Statement label list in GOTO at %C cannot be empty\");\n+\t   gfc_error (\"Statement label list in GOTO at %C cannot be empty\");\n \t   goto syntax;\n \t}\n       new_st.block = head;\n@@ -1773,7 +1757,7 @@ gfc_match_goto (void)\n /* Frees a list of gfc_alloc structures.  */\n \n void\n-gfc_free_alloc_list (gfc_alloc * p)\n+gfc_free_alloc_list (gfc_alloc *p)\n {\n   gfc_alloc *q;\n \n@@ -1821,7 +1805,7 @@ gfc_match_allocate (void)\n \tgoto cleanup;\n \n       if (gfc_pure (NULL)\n-          && gfc_impure_variable (tail->expr->symtree->n.sym))\n+\t  && gfc_impure_variable (tail->expr->symtree->n.sym))\n \t{\n \t  gfc_error (\"Bad allocate-object in ALLOCATE statement at %C for a \"\n \t\t     \"PURE procedure\");\n@@ -1845,23 +1829,21 @@ gfc_match_allocate (void)\n     {\n       if (stat->symtree->n.sym->attr.intent == INTENT_IN)\n \t{\n-\t  gfc_error\n-\t    (\"STAT variable '%s' of ALLOCATE statement at %C cannot be \"\n-\t     \"INTENT(IN)\", stat->symtree->n.sym->name);\n+\t  gfc_error (\"STAT variable '%s' of ALLOCATE statement at %C cannot \"\n+\t\t     \"be INTENT(IN)\", stat->symtree->n.sym->name);\n \t  goto cleanup;\n \t}\n \n       if (gfc_pure (NULL) && gfc_impure_variable (stat->symtree->n.sym))\n \t{\n-\t  gfc_error\n-\t    (\"Illegal STAT variable in ALLOCATE statement at %C for a PURE \"\n-\t     \"procedure\");\n+\t  gfc_error (\"Illegal STAT variable in ALLOCATE statement at %C \"\n+\t\t     \"for a PURE procedure\");\n \t  goto cleanup;\n \t}\n \n       if (stat->symtree->n.sym->attr.flavor != FL_VARIABLE)\n \t{\n-\t  gfc_error(\"STAT expression at %C must be a variable\");\n+\t  gfc_error (\"STAT expression at %C must be a variable\");\n \t  goto cleanup;\n \t}\n \n@@ -1915,8 +1897,7 @@ gfc_match_nullify (void)\n \n       if (gfc_pure (NULL) && gfc_impure_variable (p->symtree->n.sym))\n \t{\n-\t  gfc_error\n-\t    (\"Illegal variable in NULLIFY at %C for a PURE procedure\");\n+\t  gfc_error (\"Illegal variable in NULLIFY at %C for a PURE procedure\");\n \t  goto cleanup;\n \t}\n \n@@ -1991,11 +1972,10 @@ gfc_match_deallocate (void)\n \tgoto cleanup;\n \n       if (gfc_pure (NULL)\n-          && gfc_impure_variable (tail->expr->symtree->n.sym))\n+\t  && gfc_impure_variable (tail->expr->symtree->n.sym))\n \t{\n-\t  gfc_error\n-\t    (\"Illegal deallocate-expression in DEALLOCATE at %C for a PURE \"\n-\t     \"procedure\");\n+\t  gfc_error (\"Illegal deallocate-expression in DEALLOCATE at %C \"\n+\t\t     \"for a PURE procedure\");\n \t  goto cleanup;\n \t}\n \n@@ -2027,7 +2007,7 @@ gfc_match_deallocate (void)\n \n       if (stat->symtree->n.sym->attr.flavor != FL_VARIABLE)\n \t{\n-\t  gfc_error(\"STAT expression at %C must be a variable\");\n+\t  gfc_error (\"STAT expression at %C must be a variable\");\n \t  goto cleanup;\n \t}\n \n@@ -2077,12 +2057,12 @@ gfc_match_return (void)\n   if (gfc_current_form == FORM_FREE)\n     {\n       /* The following are valid, so we can't require a blank after the\n-        RETURN keyword:\n-          return+1\n-          return(1)  */\n+\tRETURN keyword:\n+\t  return+1\n+\t  return(1)  */\n       c = gfc_peek_char ();\n       if (ISALPHA (c) || ISDIGIT (c))\n-       return MATCH_NO;\n+\treturn MATCH_NO;\n     }\n \n   m = gfc_match (\" %e%t\", &e);\n@@ -2101,7 +2081,7 @@ gfc_match_return (void)\n   gfc_enclosing_unit (&s);\n   if (s == COMP_PROGRAM\n       && gfc_notify_std (GFC_STD_GNU, \"Extension: RETURN statement in \"\n-                        \"main program at %C\") == FAILURE)\n+\t\t\t\"main program at %C\") == FAILURE)\n       return MATCH_ERROR;\n \n   new_st.op = EXEC_RETURN;\n@@ -2177,7 +2157,7 @@ gfc_match_call (void)\n \n       new_st.next = c = gfc_get_code ();\n       c->op = EXEC_SELECT;\n-      sprintf (name, \"_result_%s\",sym->name);\n+      sprintf (name, \"_result_%s\", sym->name);\n       gfc_get_ha_sym_tree (name, &select_st);  /* Can't fail */\n \n       select_sym = select_st->n.sym;\n@@ -2241,13 +2221,13 @@ gfc_get_common (const char *name, int from_module)\n {\n   gfc_symtree *st;\n   static int serial = 0;\n-  char mangled_name[GFC_MAX_SYMBOL_LEN+1];\n+  char mangled_name[GFC_MAX_SYMBOL_LEN + 1];\n \n   if (from_module)\n     {\n       /* A use associated common block is only needed to correctly layout\n \t the variables it contains.  */\n-      snprintf(mangled_name, GFC_MAX_SYMBOL_LEN, \"_%d_%s\", serial++, name);\n+      snprintf (mangled_name, GFC_MAX_SYMBOL_LEN, \"_%d_%s\", serial++, name);\n       st = gfc_new_symtree (&gfc_current_ns->common_root, mangled_name);\n     }\n   else\n@@ -2306,10 +2286,10 @@ match\n gfc_match_common (void)\n {\n   gfc_symbol *sym, **head, *tail, *other, *old_blank_common;\n-  char name[GFC_MAX_SYMBOL_LEN+1];\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_common_head *t;\n   gfc_array_spec *as;\n-  gfc_equiv * e1, * e2;\n+  gfc_equiv *e1, *e2;\n   match m;\n   gfc_gsymbol *gsym;\n \n@@ -2331,8 +2311,8 @@ gfc_match_common (void)\n       gsym = gfc_get_gsymbol (name);\n       if (gsym->type != GSYM_UNKNOWN && gsym->type != GSYM_COMMON)\n \t{\n-\t  gfc_error (\"Symbol '%s' at %C is already an external symbol that is not COMMON\",\n-\t\t     name);\n+\t  gfc_error (\"Symbol '%s' at %C is already an external symbol that \"\n+\t\t     \"is not COMMON\", name);\n \t  goto cleanup;\n \t}\n \n@@ -2349,7 +2329,8 @@ gfc_match_common (void)\n \t{\n \t  if (gfc_current_ns->is_block_data)\n \t    {\n-\t      gfc_warning (\"BLOCK DATA unit cannot contain blank COMMON at %C\");\n+\t      gfc_warning (\"BLOCK DATA unit cannot contain blank COMMON \"\n+\t\t\t   \"at %C\");\n \t    }\n \t  t = &gfc_current_ns->blank_common;\n \t  if (t->head == NULL)\n@@ -2407,9 +2388,8 @@ gfc_match_common (void)\n \t  /* Derived type names must have the SEQUENCE attribute.  */\n \t  if (sym->ts.type == BT_DERIVED && !sym->ts.derived->attr.sequence)\n \t    {\n-\t      gfc_error\n-\t\t(\"Derived type variable in COMMON at %C does not have the \"\n-\t\t \"SEQUENCE attribute\");\n+\t      gfc_error (\"Derived type variable in COMMON at %C does not \"\n+\t\t\t \"have the SEQUENCE attribute\");\n \t      goto cleanup;\n \t    }\n \n@@ -2421,7 +2401,7 @@ gfc_match_common (void)\n \t  tail = sym;\n \n \t  /* Deal with an optional array specification after the\n-             symbol name.  */\n+\t     symbol name.  */\n \t  m = gfc_match_array_spec (&as);\n \t  if (m == MATCH_ERROR)\n \t    goto cleanup;\n@@ -2430,9 +2410,8 @@ gfc_match_common (void)\n \t    {\n \t      if (as->type != AS_EXPLICIT)\n \t\t{\n-\t\t  gfc_error\n-\t\t    (\"Array specification for symbol '%s' in COMMON at %C \"\n-\t\t     \"must be explicit\", sym->name);\n+\t\t  gfc_error (\"Array specification for symbol '%s' in COMMON \"\n+\t\t\t     \"at %C must be explicit\", sym->name);\n \t\t  goto cleanup;\n \t\t}\n \n@@ -2441,9 +2420,8 @@ gfc_match_common (void)\n \n \t      if (sym->attr.pointer)\n \t\t{\n-\t\t  gfc_error\n-\t\t    (\"Symbol '%s' in COMMON at %C cannot be a POINTER array\",\n-\t\t     sym->name);\n+\t\t  gfc_error (\"Symbol '%s' in COMMON at %C cannot be a \"\n+\t\t\t     \"POINTER array\", sym->name);\n \t\t  goto cleanup;\n \t\t}\n \n@@ -2459,9 +2437,9 @@ gfc_match_common (void)\n \t  if (sym->attr.in_equivalence)\n \t    {\n \t      for (e1 = gfc_current_ns->equiv; e1; e1 = e1->next)\n-\t        {\n-\t          for (e2 = e1; e2; e2 = e2->eq)\n-\t            if (e2->expr->symtree->n.sym == sym)\n+\t\t{\n+\t\t  for (e2 = e1; e2; e2 = e2->eq)\n+\t\t    if (e2->expr->symtree->n.sym == sym)\n \t\t      goto equiv_found;\n \n \t\t  continue;\n@@ -2472,13 +2450,12 @@ gfc_match_common (void)\n \t\t    {\n \t\t      other = e2->expr->symtree->n.sym;\n \t\t      if (other->common_head\n-\t\t            && other->common_head != sym->common_head)\n+\t\t\t  && other->common_head != sym->common_head)\n \t\t\t{\n \t\t\t  gfc_error (\"Symbol '%s', in COMMON block '%s' at \"\n \t\t\t\t     \"%C is being indirectly equivalenced to \"\n \t\t\t\t     \"another COMMON block '%s'\",\n-\t\t\t\t     sym->name,\n-\t\t\t\t     sym->common_head->name,\n+\t\t\t\t     sym->name, sym->common_head->name,\n \t\t\t\t     other->common_head->name);\n \t\t\t    goto cleanup;\n \t\t\t}\n@@ -2552,7 +2529,7 @@ gfc_match_block_data (void)\n /* Free a namelist structure.  */\n \n void\n-gfc_free_namelist (gfc_namelist * name)\n+gfc_free_namelist (gfc_namelist *name)\n {\n   gfc_namelist *n;\n \n@@ -2583,9 +2560,9 @@ gfc_match_namelist (void)\n     {\n       if (group_name->ts.type != BT_UNKNOWN)\n \t{\n-\t  gfc_error\n-\t    (\"Namelist group name '%s' at %C already has a basic type \"\n-\t     \"of %s\", group_name->name, gfc_typename (&group_name->ts));\n+\t  gfc_error (\"Namelist group name '%s' at %C already has a basic \"\n+\t\t     \"type of %s\", group_name->name,\n+\t\t     gfc_typename (&group_name->ts));\n \t  return MATCH_ERROR;\n \t}\n \n@@ -2594,7 +2571,7 @@ gfc_match_namelist (void)\n \t    && gfc_notify_std (GFC_STD_GNU, \"Namelist group name '%s' \"\n \t\t\t       \"at %C already is USE associated and can\"\n \t\t\t       \"not be respecified.\", group_name->name)\n-\t\t == FAILURE)\n+\t       == FAILURE)\n \treturn MATCH_ERROR;\n \n       if (group_name->attr.flavor != FL_NAMELIST\n@@ -2619,14 +2596,14 @@ gfc_match_namelist (void)\n \t  if (sym->as && sym->as->type == AS_ASSUMED_SIZE)\n \t    {\n \t      gfc_error (\"Assumed size array '%s' in namelist '%s' at \"\n-\t\t         \"%C is not allowed\", sym->name, group_name->name);\n+\t\t\t \"%C is not allowed\", sym->name, group_name->name);\n \t      gfc_error_check ();\n \t    }\n \n \t  if (sym->as && sym->as->type == AS_ASSUMED_SHAPE\n-\t\t&& gfc_notify_std (GFC_STD_GNU, \"Assumed shape array '%s' in \"\n-\t\t\t\t   \"namelist '%s' at %C is an extension.\",\n-\t\t\t\t   sym->name, group_name->name) == FAILURE)\n+\t      && gfc_notify_std (GFC_STD_GNU, \"Assumed shape array '%s' in \"\n+\t\t\t\t \"namelist '%s' at %C is an extension.\",\n+\t\t\t\t sym->name, group_name->name) == FAILURE)\n \t    gfc_error_check ();\n \n \t  nl = gfc_get_namelist ();\n@@ -2695,15 +2672,13 @@ gfc_match_module (void)\n    do this.  */\n \n void\n-gfc_free_equiv (gfc_equiv * eq)\n+gfc_free_equiv (gfc_equiv *eq)\n {\n-\n   if (eq == NULL)\n     return;\n \n   gfc_free_equiv (eq->eq);\n   gfc_free_equiv (eq->next);\n-\n   gfc_free_expr (eq->expr);\n   gfc_free (eq);\n }\n@@ -2761,16 +2736,14 @@ gfc_match_equivalence (void)\n \t  for (ref = set->expr->ref; ref; ref = ref->next)\n \t    if (ref->type == REF_ARRAY && ref->u.ar.type == AR_SECTION)\n \t      {\n-\t\tgfc_error\n-\t\t  (\"Array reference in EQUIVALENCE at %C cannot be an \"\n-\t\t   \"array section\");\n+\t\tgfc_error (\"Array reference in EQUIVALENCE at %C cannot \"\n+\t\t\t   \"be an array section\");\n \t\tgoto cleanup;\n \t      }\n \n \t  sym = set->expr->symtree->n.sym;\n \n-\t  if (gfc_add_in_equivalence (&sym->attr, sym->name, NULL)\n-\t\t== FAILURE)\n+\t  if (gfc_add_in_equivalence (&sym->attr, sym->name, NULL) == FAILURE)\n \t    goto cleanup;\n \n \t  if (sym->attr.in_common)\n@@ -2807,8 +2780,7 @@ gfc_match_equivalence (void)\n \t      {\n \t\tgfc_error (\"Attempt to indirectly overlap COMMON \"\n \t\t\t   \"blocks %s and %s by EQUIVALENCE at %C\",\n-\t\t\t   sym->common_head->name,\n-\t\t\t   common_head->name);\n+\t\t\t   sym->common_head->name, common_head->name);\n \t\tgoto cleanup;\n \t      }\n \t    sym->attr.in_common = 1;\n@@ -2836,6 +2808,7 @@ gfc_match_equivalence (void)\n   return MATCH_ERROR;\n }\n \n+\n /* Check that a statement function is not recursive. This is done by looking\n    for the statement function symbol(sym) by looking recursively through its\n    expression(e).  If a reference to sym is found, true is returned.  \n@@ -2858,8 +2831,7 @@ recursive_stmt_fcn (gfc_expr *e, gfc_symbol *sym)\n     case EXPR_FUNCTION:\n       for (arg = e->value.function.actual; arg; arg = arg->next)\n \t{\n-\t  if (sym->name == arg->name\n-\t\t|| recursive_stmt_fcn (arg->expr, sym))\n+\t  if (sym->name == arg->name || recursive_stmt_fcn (arg->expr, sym))\n \t    return true;\n \t}\n \n@@ -2872,8 +2844,8 @@ recursive_stmt_fcn (gfc_expr *e, gfc_symbol *sym)\n \n       /* Catch recursion via other statement functions.  */\n       if (e->symtree->n.sym->attr.proc == PROC_ST_FUNCTION\n-\t    && e->symtree->n.sym->value\n-\t    && recursive_stmt_fcn (e->symtree->n.sym->value, sym))\n+\t  && e->symtree->n.sym->value\n+\t  && recursive_stmt_fcn (e->symtree->n.sym->value, sym))\n \treturn true;\n \n       if (e->symtree->n.sym->ts.type == BT_UNKNOWN)\n@@ -2891,7 +2863,7 @@ recursive_stmt_fcn (gfc_expr *e, gfc_symbol *sym)\n \n     case EXPR_OP:\n       if (recursive_stmt_fcn (e->value.op.op1, sym)\n-\t    || recursive_stmt_fcn (e->value.op.op2, sym))\n+\t  || recursive_stmt_fcn (e->value.op.op2, sym))\n \treturn true;\n       break;\n \n@@ -2910,15 +2882,15 @@ recursive_stmt_fcn (gfc_expr *e, gfc_symbol *sym)\n \t      for (i = 0; i < ref->u.ar.dimen; i++)\n \t\t{\n \t\t  if (recursive_stmt_fcn (ref->u.ar.start[i], sym)\n-\t\t\t|| recursive_stmt_fcn (ref->u.ar.end[i], sym)\n-\t\t\t|| recursive_stmt_fcn (ref->u.ar.stride[i], sym))\n+\t\t      || recursive_stmt_fcn (ref->u.ar.end[i], sym)\n+\t\t      || recursive_stmt_fcn (ref->u.ar.stride[i], sym))\n \t\t    return true;\n \t\t}\n \t      break;\n \n \t    case REF_SUBSTRING:\n \t      if (recursive_stmt_fcn (ref->u.ss.start, sym)\n-\t\t    || recursive_stmt_fcn (ref->u.ss.end, sym))\n+\t\t  || recursive_stmt_fcn (ref->u.ss.end, sym))\n \t\treturn true;\n \n \t      break;\n@@ -2967,8 +2939,7 @@ gfc_match_st_function (void)\n \n   if (recursive_stmt_fcn (expr, sym))\n     {\n-      gfc_error (\"Statement function at %L is recursive\",\n-\t\t &expr->where);\n+      gfc_error (\"Statement function at %L is recursive\", &expr->where);\n       return MATCH_ERROR;\n     }\n \n@@ -2987,7 +2958,7 @@ gfc_match_st_function (void)\n /* Free a single case structure.  */\n \n static void\n-free_case (gfc_case * p)\n+free_case (gfc_case *p)\n {\n   if (p->low == p->high)\n     p->high = NULL;\n@@ -3000,7 +2971,7 @@ free_case (gfc_case * p)\n /* Free a list of case structures.  */\n \n void\n-gfc_free_case_list (gfc_case * p)\n+gfc_free_case_list (gfc_case *p)\n {\n   gfc_case *q;\n \n@@ -3015,7 +2986,7 @@ gfc_free_case_list (gfc_case * p)\n /* Match a single case selector.  */\n \n static match\n-match_case_selector (gfc_case ** cp)\n+match_case_selector (gfc_case **cp)\n {\n   gfc_case *c;\n   match m;\n@@ -3031,7 +3002,6 @@ match_case_selector (gfc_case ** cp)\n       if (m == MATCH_ERROR)\n \tgoto cleanup;\n     }\n-\n   else\n     {\n       m = gfc_match_init_expr (&c->low);\n@@ -3245,7 +3215,7 @@ match_simple_where (void)\n /* Match a WHERE statement.  */\n \n match\n-gfc_match_where (gfc_statement * st)\n+gfc_match_where (gfc_statement *st)\n {\n   gfc_expr *expr;\n   match m0, m;\n@@ -3262,7 +3232,6 @@ gfc_match_where (gfc_statement * st)\n   if (gfc_match_eos () == MATCH_YES)\n     {\n       *st = ST_WHERE_BLOCK;\n-\n       new_st.op = EXEC_WHERE;\n       new_st.expr = expr;\n       return MATCH_YES;\n@@ -3363,19 +3332,17 @@ gfc_match_elsewhere (void)\n /* Free a list of FORALL iterators.  */\n \n void\n-gfc_free_forall_iterator (gfc_forall_iterator * iter)\n+gfc_free_forall_iterator (gfc_forall_iterator *iter)\n {\n   gfc_forall_iterator *next;\n \n   while (iter)\n     {\n       next = iter->next;\n-\n       gfc_free_expr (iter->var);\n       gfc_free_expr (iter->start);\n       gfc_free_expr (iter->end);\n       gfc_free_expr (iter->stride);\n-\n       gfc_free (iter);\n       iter = next;\n     }\n@@ -3387,7 +3354,7 @@ gfc_free_forall_iterator (gfc_forall_iterator * iter)\n      <var> = <start>:<end>[:<stride>][, <scalar mask>]  */\n \n static match\n-match_forall_iterator (gfc_forall_iterator ** result)\n+match_forall_iterator (gfc_forall_iterator **result)\n {\n   gfc_forall_iterator *iter;\n   locus where;\n@@ -3444,8 +3411,8 @@ match_forall_iterator (gfc_forall_iterator ** result)\n   /* Make sure that potential internal function references in the\n      mask do not get messed up.  */\n   if (iter->var\n-\t&& iter->var->expr_type == EXPR_VARIABLE\n-\t&& iter->var->symtree->n.sym->refs == 1)\n+      && iter->var->expr_type == EXPR_VARIABLE\n+      && iter->var->symtree->n.sym->refs == 1)\n     iter->var->symtree->n.sym->attr.flavor = FL_UNKNOWN;\n \n   gfc_current_locus = where;\n@@ -3457,7 +3424,7 @@ match_forall_iterator (gfc_forall_iterator ** result)\n /* Match the header of a FORALL statement.  */\n \n static match\n-match_forall_header (gfc_forall_iterator ** phead, gfc_expr ** mask)\n+match_forall_header (gfc_forall_iterator **phead, gfc_expr **mask)\n {\n   gfc_forall_iterator *head, *tail, *new;\n   gfc_expr *msk;\n@@ -3523,8 +3490,8 @@ match_forall_header (gfc_forall_iterator ** phead, gfc_expr ** mask)\n   return MATCH_ERROR;\n }\n \n-/* Match the rest of a simple FORALL statement that follows an IF statement. \n- */\n+/* Match the rest of a simple FORALL statement that follows an \n+   IF statement.  */\n \n static match\n match_simple_forall (void)\n@@ -3590,7 +3557,7 @@ match_simple_forall (void)\n /* Match a FORALL statement.  */\n \n match\n-gfc_match_forall (gfc_statement * st)\n+gfc_match_forall (gfc_statement *st)\n {\n   gfc_forall_iterator *head;\n   gfc_expr *mask;\n@@ -3618,11 +3585,9 @@ gfc_match_forall (gfc_statement * st)\n   if (gfc_match_eos () == MATCH_YES)\n     {\n       *st = ST_FORALL_BLOCK;\n-\n       new_st.op = EXEC_FORALL;\n       new_st.expr = mask;\n       new_st.ext.forall_iterator = head;\n-\n       return MATCH_YES;\n     }\n \n@@ -3647,7 +3612,6 @@ gfc_match_forall (gfc_statement * st)\n   new_st.expr = mask;\n   new_st.ext.forall_iterator = head;\n   new_st.block = gfc_get_code ();\n-\n   new_st.block->op = EXEC_FORALL;\n   new_st.block->next = c;\n "}]}