{"sha": "44080af98edf7d8a59a94dd803f60cf0505fba34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQwODBhZjk4ZWRmN2Q4YTU5YTk0ZGQ4MDNmNjBjZjA1MDVmYmEzNA==", "commit": {"author": {"name": "Stafford Horne", "email": "shorne@gmail.com", "date": "2019-07-21T21:01:59Z"}, "committer": {"name": "Stafford Horne", "email": "shorne@gcc.gnu.org", "date": "2019-07-21T21:01:59Z"}, "message": "or1k: Initial support for FPU\n\nThis adds support for OpenRISC hardware floating point instructions.\nThis is enabled with the -mhard-float option.\n\nDouble-prevision floating point operations work using register pairing as\nspecified in: https://openrisc.io/proposals/orfpx64a32.  This has just been\nadded in the OpenRISC architecture specification 1.3.\nThis is enabled with the -mdouble-float option.\n\nNot all architectures support unordered comparisons so an option,\n-munordered-float is added.\n\nCurrently OpenRISC does not support sf/df or df/sf conversions, but this has\nalso just been added in architecture specification 1.3.\n\ngcc/ChangeLog:\n\n\t* config.gcc (or1k*-*-*): Add mhard-float, mdouble-float, msoft-float\n\tand munordered-float validations.\n\t* config/or1k/constraints.md (d): New register constraint.\n\t* config/or1k/predicates.md (fp_comparison_operator): New.\n\t* config/or1k/or1k.c (or1k_print_operand): Add support for printing 'd'\n\toperands.\n\t(or1k_expand_compare): Normalize unordered comparisons.\n\t* config/or1k/or1k.h (reg_class): Define DOUBLE_REGS.\n\t(REG_CLASS_NAMES): Add \"DOUBLE_REGS\".\n\t(REG_CLASS_CONTENTS): Add contents for DOUBLE_REGS.\n\t* config/or1k/or1k.md (type): Add fpu.\n\t(fpu): New instruction reservation.\n\t(F, f, fr, fi, FI, FOP, fop): New.\n\t(<fop><F:mode>3): New ALU instruction definition.\n\t(float<fi><F:mode>2): New conversion instruction definition.\n\t(fix_trunc<F:mode><fi>2): New conversion instruction definition.\n\t(fpcmpcc): New code iterator.\n\t(*sf_fp_insn): New instruction definition.\n\t(cstore<F:mode>4): New expand definition.\n\t(cbranch<F:mode>4): New expand definition.\n\t* config/or1k/or1k.opt (msoft-float, mhard-float, mdouble-float,\n\tmunordered-float): New options.\n\t* doc/invoke.texi: Document msoft-float, mhard-float, mdouble-float and\n\tmunordered-float.\n\nFrom-SVN: r273650", "tree": {"sha": "4ad7a9f769f0596da8bb827b2b3e4b2e11c71002", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ad7a9f769f0596da8bb827b2b3e4b2e11c71002"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44080af98edf7d8a59a94dd803f60cf0505fba34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44080af98edf7d8a59a94dd803f60cf0505fba34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44080af98edf7d8a59a94dd803f60cf0505fba34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44080af98edf7d8a59a94dd803f60cf0505fba34/comments", "author": {"login": "stffrdhrn", "id": 2404255, "node_id": "MDQ6VXNlcjI0MDQyNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/2404255?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stffrdhrn", "html_url": "https://github.com/stffrdhrn", "followers_url": "https://api.github.com/users/stffrdhrn/followers", "following_url": "https://api.github.com/users/stffrdhrn/following{/other_user}", "gists_url": "https://api.github.com/users/stffrdhrn/gists{/gist_id}", "starred_url": "https://api.github.com/users/stffrdhrn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stffrdhrn/subscriptions", "organizations_url": "https://api.github.com/users/stffrdhrn/orgs", "repos_url": "https://api.github.com/users/stffrdhrn/repos", "events_url": "https://api.github.com/users/stffrdhrn/events{/privacy}", "received_events_url": "https://api.github.com/users/stffrdhrn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1e2e81c1a36a51f4660d30a0278366a8a0727a9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e2e81c1a36a51f4660d30a0278366a8a0727a9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e2e81c1a36a51f4660d30a0278366a8a0727a9d"}], "stats": {"total": 232, "additions": 228, "deletions": 4}, "files": [{"sha": "224b785b8f11313509d1d8aa078c62042267c33c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44080af98edf7d8a59a94dd803f60cf0505fba34/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44080af98edf7d8a59a94dd803f60cf0505fba34/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44080af98edf7d8a59a94dd803f60cf0505fba34", "patch": "@@ -1,3 +1,30 @@\n+2019-07-22  Stafford Horne  <shorne@gmail.com>\n+\n+\t* config.gcc (or1k*-*-*): Add mhard-float, mdouble-float, msoft-float\n+\tand munordered-float validations.\n+\t* config/or1k/constraints.md (d): New register constraint.\n+\t* config/or1k/predicates.md (fp_comparison_operator): New.\n+\t* config/or1k/or1k.c (or1k_print_operand): Add support for printing 'd'\n+\toperands.\n+\t(or1k_expand_compare): Normalize unordered comparisons.\n+\t* config/or1k/or1k.h (reg_class): Define DOUBLE_REGS.\n+\t(REG_CLASS_NAMES): Add \"DOUBLE_REGS\".\n+\t(REG_CLASS_CONTENTS): Add contents for DOUBLE_REGS.\n+\t* config/or1k/or1k.md (type): Add fpu.\n+\t(fpu): New instruction reservation.\n+\t(F, f, fr, fi, FI, FOP, fop): New.\n+\t(<fop><F:mode>3): New ALU instruction definition.\n+\t(float<fi><F:mode>2): New conversion instruction definition.\n+\t(fix_trunc<F:mode><fi>2): New conversion instruction definition.\n+\t(fpcmpcc): New code iterator.\n+\t(*sf_fp_insn): New instruction definition.\n+\t(cstore<F:mode>4): New expand definition.\n+\t(cbranch<F:mode>4): New expand definition.\n+\t* config/or1k/or1k.opt (msoft-float, mhard-float, mdouble-float,\n+\tmunordered-float): New options.\n+\t* doc/invoke.texi: Document msoft-float, mhard-float, mdouble-float and\n+\tmunordered-float.\n+\n 2019-07-22  Stafford Horne  <shorne@gmail.com>\n \n \t* config.gcc (or1k*-*-*): Add mrori and mror to validation."}, {"sha": "58262e5b861719644675d552f8ff5adb0f10ee6c", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44080af98edf7d8a59a94dd803f60cf0505fba34/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44080af98edf7d8a59a94dd803f60cf0505fba34/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=44080af98edf7d8a59a94dd803f60cf0505fba34", "patch": "@@ -2579,6 +2579,7 @@ or1k*-*-*)\n \t\tcase ${or1k_multilib} in\n \t\tmcmov | msext | msfimm | \\\n \t\tmror | mrori | \\\n+\t\tmhard-float | mdouble-float | munordered-float | msoft-float | \\\n \t\tmhard-div | mhard-mul | \\\n \t\tmsoft-div | msoft-mul )\n \t\t\tTM_MULTILIB_CONFIG=\"${TM_MULTILIB_CONFIG},${or1k_multilib}\""}, {"sha": "8cac7eb5329b748cf956d7b15fde115bf15739a6", "filename": "gcc/config/or1k/constraints.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44080af98edf7d8a59a94dd803f60cf0505fba34/gcc%2Fconfig%2For1k%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44080af98edf7d8a59a94dd803f60cf0505fba34/gcc%2Fconfig%2For1k%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2Fconstraints.md?ref=44080af98edf7d8a59a94dd803f60cf0505fba34", "patch": "@@ -24,6 +24,7 @@\n \n ; We use:\n ;  c - sibcall registers\n+;  d - double pair base registers (excludes r0, r30 and r31 which overflow)\n ;  I - constant signed 16-bit\n ;  K - constant unsigned 16-bit\n ;  M - constant signed 16-bit shifted left 16-bits (l.movhi)\n@@ -32,6 +33,9 @@\n (define_register_constraint \"c\" \"SIBCALL_REGS\"\n   \"Registers which can hold a sibling call address\")\n \n+(define_register_constraint \"d\" \"DOUBLE_REGS\"\n+  \"Registers which can be used for double reg pairs.\")\n+\n ;; Immediates\n (define_constraint \"I\"\n   \"A signed 16-bit immediate in the range -32768 to 32767.\""}, {"sha": "1eea84f47e07428e77d76c000342f4cf80de4fc9", "filename": "gcc/config/or1k/or1k.c", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44080af98edf7d8a59a94dd803f60cf0505fba34/gcc%2Fconfig%2For1k%2For1k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44080af98edf7d8a59a94dd803f60cf0505fba34/gcc%2Fconfig%2For1k%2For1k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2For1k.c?ref=44080af98edf7d8a59a94dd803f60cf0505fba34", "patch": "@@ -1226,6 +1226,19 @@ or1k_print_operand (FILE *file, rtx x, int code)\n \toutput_operand_lossage (\"invalid %%H value\");\n       break;\n \n+    case 'd':\n+      if (REG_P (x))\n+\t{\n+\t  if (GET_MODE (x) == DFmode || GET_MODE (x) == DImode)\n+\t    fprintf (file, \"%s,%s\", reg_names[REGNO (operand)],\n+\t\t\t\t    reg_names[REGNO (operand) + 1]);\n+\t  else\n+\t    fprintf (file, \"%s\", reg_names[REGNO (operand)]);\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid %%d value\");\n+      break;\n+\n     case 'h':\n       print_reloc (file, x, 0, RKIND_HI);\n       break;\n@@ -1435,21 +1448,42 @@ void\n or1k_expand_compare (rtx *operands)\n {\n   rtx sr_f = gen_rtx_REG (BImode, SR_F_REGNUM);\n+  rtx_code cmp_code = GET_CODE (operands[0]);\n+  bool flag_check_ne = true;\n \n   /* The RTL may receive an immediate in argument 1 of the compare, this is not\n      supported unless we have l.sf*i instructions, force them into registers.  */\n   if (!TARGET_SFIMM)\n     XEXP (operands[0], 1) = force_reg (SImode, XEXP (operands[0], 1));\n \n+  /* Normalize comparison operators to ones OpenRISC support.  */\n+  switch (cmp_code)\n+    {\n+      case LTGT:\n+\tcmp_code = UNEQ;\n+\tflag_check_ne = false;\n+\tbreak;\n+\n+      case ORDERED:\n+\tcmp_code = UNORDERED;\n+\tflag_check_ne = false;\n+\tbreak;\n+\n+      default:\n+\tbreak;\n+    }\n+\n   /* Emit the given comparison into the Flag bit.  */\n   PUT_MODE (operands[0], BImode);\n+  PUT_CODE (operands[0], cmp_code);\n   emit_insn (gen_rtx_SET (sr_f, operands[0]));\n \n   /* Adjust the operands for use in the caller.  */\n-  operands[0] = gen_rtx_NE (VOIDmode, sr_f, const0_rtx);\n+  operands[0] = flag_check_ne ? gen_rtx_NE (VOIDmode, sr_f, const0_rtx)\n+\t\t\t      : gen_rtx_EQ (VOIDmode, sr_f, const0_rtx);\n   operands[1] = sr_f;\n   operands[2] = const0_rtx;\n-}\n+ }\n \n /* Expand the patterns \"call\", \"sibcall\", \"call_value\" and \"sibcall_value\".\n    Expands a function call where argument RETVAL is an optional RTX providing"}, {"sha": "2b29e62fdd30dc0a1e4f5d8c2ec089cdd28958b5", "filename": "gcc/config/or1k/or1k.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44080af98edf7d8a59a94dd803f60cf0505fba34/gcc%2Fconfig%2For1k%2For1k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44080af98edf7d8a59a94dd803f60cf0505fba34/gcc%2Fconfig%2For1k%2For1k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2For1k.h?ref=44080af98edf7d8a59a94dd803f60cf0505fba34", "patch": "@@ -189,6 +189,7 @@ enum reg_class\n {\n   NO_REGS,\n   SIBCALL_REGS,\n+  DOUBLE_REGS,\n   GENERAL_REGS,\n   FLAG_REGS,\n   ALL_REGS,\n@@ -200,6 +201,7 @@ enum reg_class\n #define REG_CLASS_NAMES {\t\\\n   \"NO_REGS\", \t\t\t\\\n   \"SIBCALL_REGS\",\t\t\\\n+  \"DOUBLE_REGS\",\t\t\\\n   \"GENERAL_REGS\",\t\t\\\n   \"FLAG_REGS\",\t\t\t\\\n   \"ALL_REGS\" }\n@@ -212,6 +214,7 @@ enum reg_class\n #define REG_CLASS_CONTENTS      \\\n { { 0x00000000, 0x00000000 },\t\\\n   { SIBCALL_REGS_MASK,   0 },\t\\\n+  { 0x7f7ffffe, 0x00000000 },\t\\\n   { 0xffffffff, 0x00000003 },\t\\\n   { 0x00000000, 0x00000004 },\t\\\n   { 0xffffffff, 0x00000007 }\t\\"}, {"sha": "cee11d078cce0c3593c0e06d6e7747f993b41a56", "filename": "gcc/config/or1k/or1k.md", "status": "modified", "additions": 109, "deletions": 2, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44080af98edf7d8a59a94dd803f60cf0505fba34/gcc%2Fconfig%2For1k%2For1k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44080af98edf7d8a59a94dd803f60cf0505fba34/gcc%2Fconfig%2For1k%2For1k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2For1k.md?ref=44080af98edf7d8a59a94dd803f60cf0505fba34", "patch": "@@ -60,7 +60,7 @@\n (define_attr \"length\" \"\" (const_int 4))\n \n (define_attr \"type\"\n-  \"alu,st,ld,control,multi\"\n+  \"alu,st,ld,control,multi,fpu\"\n   (const_string \"alu\"))\n \n (define_attr \"insn_support\" \"class1,sext,sfimm,shftimm,ror,rori\" (const_string \"class1\"))\n@@ -97,6 +97,10 @@\n (define_insn_reservation \"control\" 1\n   (eq_attr \"type\" \"control\")\n   \"cpu\")\n+(define_insn_reservation \"fpu\" 2\n+  (eq_attr \"type\" \"fpu\")\n+  \"cpu\")\n+\n \n ; Define delay slots for any branch\n (define_delay (eq_attr \"type\" \"control\")\n@@ -159,6 +163,47 @@\n   \"\"\n   \"l.sub\\t%0, %r1, %2\")\n \n+;; -------------------------------------------------------------------------\n+;; Floating Point Arithmetic instructions\n+;; -------------------------------------------------------------------------\n+\n+;; Mode iterator for single/double float\n+(define_mode_iterator F [(SF \"TARGET_HARD_FLOAT\")\n+\t\t\t (DF \"TARGET_DOUBLE_FLOAT\")])\n+(define_mode_attr f [(SF \"s\") (DF \"d\")])\n+(define_mode_attr fr [(SF \"r\") (DF \"d\")])\n+(define_mode_attr fi [(SF \"si\") (DF \"di\")])\n+(define_mode_attr FI [(SF \"SI\") (DF \"DI\")])\n+\n+;; Basic arithmetic instructions\n+(define_code_iterator FOP [plus minus mult div])\n+(define_code_attr fop [(plus \"add\") (minus \"sub\") (mult \"mul\") (div \"div\")])\n+\n+(define_insn \"<fop><F:mode>3\"\n+  [(set (match_operand:F 0 \"register_operand\" \"=<fr>\")\n+\t(FOP:F (match_operand:F 1 \"register_operand\" \"<fr>\")\n+\t       (match_operand:F 2 \"register_operand\" \"<fr>\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"lf.<fop>.<f>\\t%d0, %d1, %d2\"\n+  [(set_attr \"type\" \"fpu\")])\n+\n+;; Basic float<->int conversion\n+(define_insn \"float<fi><F:mode>2\"\n+  [(set (match_operand:F 0 \"register_operand\" \"=<fr>\")\n+\t(float:F\n+\t    (match_operand:<FI> 1 \"register_operand\" \"<fr>\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"lf.itof.<f>\\t%d0, %d1\"\n+  [(set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"fix_trunc<F:mode><fi>2\"\n+  [(set (match_operand:<FI> 0 \"register_operand\" \"=<fr>\")\n+\t(fix:<FI>\n+\t    (match_operand:F 1 \"register_operand\" \"<fr>\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"lf.ftoi.<f>\\t%d0, %d1\"\n+  [(set_attr \"type\" \"fpu\")])\n+\n ;; -------------------------------------------------------------------------\n ;; Logical operators\n ;; -------------------------------------------------------------------------\n@@ -380,7 +425,7 @@\n (define_code_iterator intcmpcc [ne eq lt ltu gt gtu ge le geu leu])\n (define_code_attr insn [(ne \"ne\") (eq \"eq\") (lt \"lts\") (ltu \"ltu\")\n \t\t\t(gt \"gts\") (gtu \"gtu\") (ge \"ges\") (le \"les\")\n-\t\t\t(geu \"geu\") (leu \"leu\") ])\n+\t\t\t(geu \"geu\") (leu \"leu\")])\n \n (define_insn \"*sf_insn\"\n   [(set (reg:BI SR_F_REGNUM)\n@@ -392,6 +437,36 @@\n    l.sf<insn>i\\t%r0, %1\"\n   [(set_attr \"insn_support\" \"*,sfimm\")])\n \n+;; Support FP comparisons too\n+\n+;; The OpenRISC FPU supports these comparisons:\n+;;\n+;;    lf.sfeq.{d,s} - equality, r r, double or single precision\n+;;    lf.sfge.{d,s} - greater than or equal, r r, double or single precision\n+;;    lf.sfgt.{d,s} - greater than, r r, double or single precision\n+;;    lf.sfle.{d,s} - less than or equal, r r, double or single precision\n+;;    lf.sflt.{d,s} - less than, r r, double or single precision\n+;;    lf.sfne.{d,s} - not equal, r r, double or single precision\n+;;\n+;; Double precision is only supported on some hardware.  Only register/register\n+;; comparisons are supported.  All comparisons are signed.\n+\n+(define_code_iterator fpcmpcc [ne eq lt gt ge le uneq unle unlt ungt unge\n+\t\t\t       unordered])\n+(define_code_attr fpcmpinsn [(ne \"ne\") (eq \"eq\") (lt \"lt\") (gt \"gt\") (ge \"ge\")\n+\t\t\t     (le \"le\") (uneq \"ueq\") (unle \"ule\") (unlt \"ult\")\n+\t\t\t     (ungt \"ugt\") (unge \"uge\") (unordered \"un\")])\n+\n+\n+(define_insn \"*sf_fp_insn\"\n+  [(set (reg:BI SR_F_REGNUM)\n+\t(fpcmpcc:BI (match_operand:F 0 \"register_operand\" \"<fr>\")\n+\t\t    (match_operand:F 1 \"register_operand\" \"<fr>\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"lf.sf<fpcmpinsn>.<f>\\t%d0, %d1\"\n+  [(set_attr \"type\" \"fpu\")])\n+\n+\n ;; -------------------------------------------------------------------------\n ;; Conditional Store instructions\n ;; -------------------------------------------------------------------------\n@@ -412,6 +487,23 @@\n   DONE;\n })\n \n+;; Support FP cstores too\n+(define_expand \"cstore<F:mode>4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(if_then_else:F\n+\t  (match_operator 1 \"fp_comparison_operator\"\n+\t    [(match_operand:F 2 \"register_operand\" \"\")\n+\t     (match_operand:F 3 \"register_operand\" \"\")])\n+\t  (match_dup 0)\n+\t  (const_int 0)))]\n+  \"TARGET_HARD_FLOAT\"\n+{\n+  or1k_expand_compare (operands + 1);\n+  PUT_MODE (operands[1], SImode);\n+  emit_insn (gen_rtx_SET (operands[0], operands[1]));\n+  DONE;\n+})\n+\n ;; Being able to \"copy\" SR_F to a general register is helpful for\n ;; the atomic insns, wherein the usual usage is to test the success\n ;; of the compare-and-swap.  Representing the operation in this way,\n@@ -505,6 +597,21 @@\n   or1k_expand_compare (operands);\n })\n \n+;; Support FP branching\n+\n+(define_expand \"cbranch<F:mode>4\"\n+  [(set (pc)\n+\t(if_then_else\n+\t  (match_operator 0 \"fp_comparison_operator\"\n+\t    [(match_operand:F 1 \"register_operand\" \"\")\n+\t     (match_operand:F 2 \"register_operand\" \"\")])\n+\t  (label_ref (match_operand 3 \"\" \"\"))\n+\t  (pc)))]\n+  \"TARGET_HARD_FLOAT\"\n+{\n+  or1k_expand_compare (operands);\n+})\n+\n (define_insn \"*cbranch\"\n   [(set (pc)\n \t(if_then_else"}, {"sha": "15085fafa3f37d3f0dacc9ecf090f635593b9eb9", "filename": "gcc/config/or1k/or1k.opt", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44080af98edf7d8a59a94dd803f60cf0505fba34/gcc%2Fconfig%2For1k%2For1k.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44080af98edf7d8a59a94dd803f60cf0505fba34/gcc%2Fconfig%2For1k%2For1k.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2For1k.opt?ref=44080af98edf7d8a59a94dd803f60cf0505fba34", "patch": "@@ -41,6 +41,28 @@ Target RejectNegative Mask(SOFT_MUL).\n Enable generation of binaries which use functions from libgcc to perform\n multiply operations. The default is -mhard-mul.\n \n+msoft-float\n+Target RejectNegative InverseMask(HARD_FLOAT)\n+Enable generation of binaries which use functions from libgcc to perform\n+floating point operations.  This is the default; use -mhard-float to override.\n+\n+mhard-float\n+Target RejectNegative Mask(HARD_FLOAT)\n+Enable generation of hardware floating point instructions. The default is\n+-msoft-float.\n+\n+mdouble-float\n+Target Mask(DOUBLE_FLOAT)\n+When -mhard-float is selected, enables generation of double-precision floating\n+point instructions.  By default functions from libgcc are used to perform\n+double-precision floating point operations.\n+\n+munordered-float\n+Target RejectNegative Mask(FP_UNORDERED)\n+When -mhard-float is selected, enables generation of unordered floating point\n+compare and set flag (lf.sfun*) instructions.  By default functions from libgcc\n+are used to perform unordered floating point compare and set flag operations.\n+\n mcmov\n Target RejectNegative Mask(CMOV)\n Enable generation of conditional move (l.cmov) instructions.  By default the"}, {"sha": "3aa6ca3eeccaa9b7ca1dbae0a0b4b0093b0319a7", "filename": "gcc/config/or1k/predicates.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44080af98edf7d8a59a94dd803f60cf0505fba34/gcc%2Fconfig%2For1k%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44080af98edf7d8a59a94dd803f60cf0505fba34/gcc%2Fconfig%2For1k%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2Fpredicates.md?ref=44080af98edf7d8a59a94dd803f60cf0505fba34", "patch": "@@ -90,6 +90,11 @@\n (define_predicate \"equality_comparison_operator\"\n   (match_code \"ne,eq\"))\n \n+(define_predicate \"fp_comparison_operator\"\n+  (if_then_else (match_test \"TARGET_FP_UNORDERED\")\n+    (match_operand 0 \"comparison_operator\")\n+    (match_operand 0 \"ordered_comparison_operator\")))\n+\n ;; Borrowed from rs6000\n ;; Return true if the operand is in volatile memory.  Note that during the\n ;; RTL generation phase, memory_operand does not return TRUE for volatile"}, {"sha": "7bac080dca131e6db092776a882031cb81f3eeae", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44080af98edf7d8a59a94dd803f60cf0505fba34/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44080af98edf7d8a59a94dd803f60cf0505fba34/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=44080af98edf7d8a59a94dd803f60cf0505fba34", "patch": "@@ -1034,6 +1034,7 @@ Objective-C and Objective-C++ Dialects}.\n @emph{OpenRISC Options}\n @gccoptlist{-mboard=@var{name}  -mnewlib  -mhard-mul  -mhard-div @gol\n -msoft-mul  -msoft-div @gol\n+-msoft-float  -mhard-float  -mdouble-float -munordered-float @gol\n -mcmov  -mror  -mrori  -msext  -msfimm  -mshftimm}\n \n @emph{PDP-11 Options}\n@@ -23666,6 +23667,26 @@ This default is hardware divide.\n Select software or hardware multiply (@code{l.mul}, @code{l.muli}) instructions.\n This default is hardware multiply.\n \n+@item -msoft-float\n+@itemx -mhard-float\n+@opindex msoft-float\n+@opindex mhard-float\n+Select software or hardware for floating point operations.\n+The default is software.\n+\n+@item -mdouble-float\n+@opindex mdouble-float\n+When @option{-mhard-float} is selected, enables generation of double-precision\n+floating point instructions.  By default functions from @file{libgcc} are used\n+to perform double-precision floating point operations.\n+\n+@item -munordered-float\n+@opindex munordered-float\n+When @option{-mhard-float} is selected, enables generation of unordered\n+floating point compare and set flag (@code{lf.sfun*}) instructions.  By default\n+functions from @file{libgcc} are used to perform unordered floating point\n+compare and set flag operations.\n+\n @item -mcmov\n @opindex mcmov\n Enable generation of conditional move (@code{l.cmov}) instructions.  By"}]}