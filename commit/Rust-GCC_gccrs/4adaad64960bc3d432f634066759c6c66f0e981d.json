{"sha": "4adaad64960bc3d432f634066759c6c66f0e981d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFkYWFkNjQ5NjBiYzNkNDMyZjYzNDA2Njc1OWM2YzY2ZjBlOTgxZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-04-30T15:02:11Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-04-30T15:02:11Z"}, "message": "re PR tree-optimization/79224 (Large C-Ray slowdown)\n\n\n\tPR ipa/79224\n\t* ipa-inline-analysis.c (dump_predicate): Add optional parameter NL.\n\t(account_size_time): Use two predicates - exec_pred and\n\tnonconst_pred_ptr.\n\t(evaluate_conditions_for_known_args): Compute both clause and\n\tnonspec_clause.\n\t(evaluate_properties_for_edge): Evaulate both clause and nonspec_clause.\n\t(inline_summary_t::duplicate): Update.\n\t(estimate_function_body_sizes): Caluculate exec and nonconst predicates\n\tseparately.\n\t(compute_inline_parameters): Likewise.\n\t(estimate_edge_size_and_time): Update caluclation of time.\n\t(estimate_node_size_and_time): Compute both time and nonspecialized\n\ttime.\n\t(estimate_ipcp_clone_size_and_time): Update.\n\t(inline_merge_summary): Update.\n\t(do_estimate_edge_time): Update.\n\t(do_estimate_edge_size): Update.\n\t(do_estimate_edge_hints): Update.\n\t(inline_read_section, inline_write_summary): Stream both new predicates.\n\t* ipa-inline.c (compute_uninlined_call_time): Take uninlined_call_time\n\tas argument.\n\t(compute_inlined_call_time): Cleanup.\n\t(big_speedup_p): Update.\n\t(edge_badness): Update.\n\t* ipa-inline.h (INLINE_TIME_SCALE): Remove.\n\t(size_time_entry): Replace predicate by exec_predicate and\n\tnonconst_predicate.\n\t(edge_growth_cache_entry): Cache both time nad nonspecialized time.\n\t(estimate_edge_time): Return also nonspec_time.\n\t(reset_edge_growth_cache): Update.\n\nFrom-SVN: r247417", "tree": {"sha": "310c3e9e870254ce22cb78bf8cb4da0a8378e317", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/310c3e9e870254ce22cb78bf8cb4da0a8378e317"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4adaad64960bc3d432f634066759c6c66f0e981d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4adaad64960bc3d432f634066759c6c66f0e981d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4adaad64960bc3d432f634066759c6c66f0e981d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4adaad64960bc3d432f634066759c6c66f0e981d/comments", "author": null, "committer": null, "parents": [{"sha": "8cbe7981c6d98096ecacd81fc83563fe4acd1e2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cbe7981c6d98096ecacd81fc83563fe4acd1e2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cbe7981c6d98096ecacd81fc83563fe4acd1e2a"}], "stats": {"total": 447, "additions": 304, "deletions": 143}, "files": [{"sha": "f8bde7a91e47c942a2b5fa995e93118fb87d624c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4adaad64960bc3d432f634066759c6c66f0e981d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4adaad64960bc3d432f634066759c6c66f0e981d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4adaad64960bc3d432f634066759c6c66f0e981d", "patch": "@@ -1,3 +1,37 @@\n+2017-04-29  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/79224\n+\t* ipa-inline-analysis.c (dump_predicate): Add optional parameter NL.\n+\t(account_size_time): Use two predicates - exec_pred and\n+\tnonconst_pred_ptr.\n+\t(evaluate_conditions_for_known_args): Compute both clause and\n+\tnonspec_clause.\n+\t(evaluate_properties_for_edge): Evaulate both clause and nonspec_clause.\n+\t(inline_summary_t::duplicate): Update.\n+\t(estimate_function_body_sizes): Caluculate exec and nonconst predicates\n+\tseparately.\n+\t(compute_inline_parameters): Likewise.\n+\t(estimate_edge_size_and_time): Update caluclation of time.\n+\t(estimate_node_size_and_time): Compute both time and nonspecialized\n+\ttime.\n+\t(estimate_ipcp_clone_size_and_time): Update.\n+\t(inline_merge_summary): Update.\n+\t(do_estimate_edge_time): Update.\n+\t(do_estimate_edge_size): Update.\n+\t(do_estimate_edge_hints): Update.\n+\t(inline_read_section, inline_write_summary): Stream both new predicates.\n+\t* ipa-inline.c (compute_uninlined_call_time): Take uninlined_call_time\n+\tas argument.\n+\t(compute_inlined_call_time): Cleanup.\n+\t(big_speedup_p): Update.\n+\t(edge_badness): Update.\n+\t* ipa-inline.h (INLINE_TIME_SCALE): Remove.\n+\t(size_time_entry): Replace predicate by exec_predicate and\n+\tnonconst_predicate.\n+\t(edge_growth_cache_entry): Cache both time nad nonspecialized time.\n+\t(estimate_edge_time): Return also nonspec_time.\n+\t(reset_edge_growth_cache): Update.\n+\n 2017-04-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/80491"}, {"sha": "81183cffdfa6f5e1fa0d030ad4caddf949df161b", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 232, "deletions": 112, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4adaad64960bc3d432f634066759c6c66f0e981d/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4adaad64960bc3d432f634066759c6c66f0e981d/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=4adaad64960bc3d432f634066759c6c66f0e981d", "patch": "@@ -585,10 +585,12 @@ dump_clause (FILE *f, conditions conds, clause_t clause)\n }\n \n \n-/* Dump predicate PREDICATE.  */\n+/* Dump PREDICATE to F. CONDS a vector of conditions used when evauating\n+   predicats. When NL is true new line is output at the end of dump.  */\n \n static void\n-dump_predicate (FILE *f, conditions conds, struct predicate *pred)\n+dump_predicate (FILE *f, conditions conds, struct predicate *pred,\n+\t\tbool nl = true)\n {\n   int i;\n   if (true_predicate_p (pred))\n@@ -600,7 +602,8 @@ dump_predicate (FILE *f, conditions conds, struct predicate *pred)\n \t  fprintf (f, \" && \");\n \tdump_clause (f, conds, pred->clause[i]);\n       }\n-  fprintf (f, \"\\n\");\n+  if (nl)\n+    fprintf (f, \"\\n\");\n }\n \n \n@@ -660,17 +663,27 @@ dump_inline_hints (FILE *f, inline_hints hints)\n }\n \n \n-/* Record SIZE and TIME under condition PRED into the inline summary.  */\n+/* Record SIZE and TIME to SUMMARY.\n+   The accounted code will be executed when EXEC_PRED is true.\n+   When NONCONST_PRED is false the code will evaulate to constant and\n+   will get optimized out in specialized clones of the function.   */\n \n static void\n account_size_time (struct inline_summary *summary, int size, sreal time,\n-\t\t   struct predicate *pred)\n+\t\t   struct predicate *exec_pred,\n+\t\t   struct predicate *nonconst_pred_ptr)\n {\n   size_time_entry *e;\n   bool found = false;\n   int i;\n+  struct predicate nonconst_pred;\n \n-  if (false_predicate_p (pred))\n+  if (false_predicate_p (exec_pred))\n+    return;\n+\n+  nonconst_pred = and_predicates (summary->conds, nonconst_pred_ptr, exec_pred);\n+\n+  if (false_predicate_p (&nonconst_pred))\n     return;\n \n   /* We need to create initial empty unconitional clause, but otherwie\n@@ -681,7 +694,8 @@ account_size_time (struct inline_summary *summary, int size, sreal time,\n   gcc_assert (time >= 0);\n \n   for (i = 0; vec_safe_iterate (summary->entry, i, &e); i++)\n-    if (predicates_equal_p (&e->predicate, pred))\n+    if (predicates_equal_p (&e->exec_predicate, exec_pred)\n+\t&& predicates_equal_p (&e->nonconst_predicate, &nonconst_pred))\n       {\n \tfound = true;\n \tbreak;\n@@ -691,7 +705,7 @@ account_size_time (struct inline_summary *summary, int size, sreal time,\n       i = 0;\n       found = true;\n       e = &(*summary->entry)[0];\n-      gcc_assert (!e->predicate.clause[0]);\n+      gcc_assert (!e->exec_predicate.clause[0]);\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n \t\t \"\\t\\tReached limit on number of entries, \"\n@@ -700,17 +714,25 @@ account_size_time (struct inline_summary *summary, int size, sreal time,\n   if (dump_file && (dump_flags & TDF_DETAILS) && (time != 0 || size))\n     {\n       fprintf (dump_file,\n-\t       \"\\t\\tAccounting size:%3.2f, time:%3.2f on %spredicate:\",\n+\t       \"\\t\\tAccounting size:%3.2f, time:%3.2f on %spredicate exec:\",\n \t       ((double) size) / INLINE_SIZE_SCALE,\n-\t       (time.to_double ()) / INLINE_TIME_SCALE, found ? \"\" : \"new \");\n-      dump_predicate (dump_file, summary->conds, pred);\n+\t       (time.to_double ()), found ? \"\" : \"new \");\n+      dump_predicate (dump_file, summary->conds, exec_pred, 0);\n+      if (!predicates_equal_p (exec_pred, &nonconst_pred))\n+\t{\n+          fprintf (dump_file, \" nonconst:\");\n+          dump_predicate (dump_file, summary->conds, &nonconst_pred);\n+\t}\n+      else\n+        fprintf (dump_file, \"\\n\");\n     }\n   if (!found)\n     {\n       struct size_time_entry new_entry;\n       new_entry.size = size;\n       new_entry.time = time;\n-      new_entry.predicate = *pred;\n+      new_entry.exec_predicate = *exec_pred;\n+      new_entry.nonconst_predicate = nonconst_pred;\n       vec_safe_push (summary->entry, new_entry);\n     }\n   else\n@@ -795,21 +817,33 @@ set_hint_predicate (struct predicate **p, struct predicate new_predicate)\n }\n \n \n-/* KNOWN_VALS is partial mapping of parameters of NODE to constant values.\n+/* Compute what conditions may or may not hold given invormation about\n+   parameters.  RET_CLAUSE returns truths that may hold in a specialized copy,\n+   whie RET_NONSPEC_CLAUSE returns truths that may hold in an nonspecialized\n+   copy when called in a given context.  It is a bitmask of conditions. Bit\n+   0 means that condition is known to be false, while bit 1 means that condition\n+   may or may not be true.  These differs - for example NOT_INLINED condition\n+   is always false in the second and also builtin_constant_p tests can not use\n+   the fact that parameter is indeed a constant.\n+\n+   KNOWN_VALS is partial mapping of parameters of NODE to constant values.\n    KNOWN_AGGS is a vector of aggreggate jump functions for each parameter.\n    Return clause of possible truths. When INLINE_P is true, assume that we are\n    inlining.\n \n    ERROR_MARK means compile time invariant.  */\n \n-static clause_t\n+static void\n evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t\t\t\t    bool inline_p,\n \t\t\t\t    vec<tree> known_vals,\n \t\t\t\t    vec<ipa_agg_jump_function_p>\n-\t\t\t\t    known_aggs)\n+\t\t\t\t    known_aggs,\n+\t\t\t\t    clause_t *ret_clause,\n+\t\t\t\t    clause_t *ret_nonspec_clause)\n {\n   clause_t clause = inline_p ? 0 : 1 << predicate_not_inlined_condition;\n+  clause_t nonspec_clause = 1 << predicate_not_inlined_condition;\n   struct inline_summary *info = inline_summaries->get (node);\n   int i;\n   struct condition *c;\n@@ -828,6 +862,7 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n       if (c->operand_num >= (int) known_vals.length ())\n \t{\n \t  clause |= 1 << (i + predicate_first_dynamic_condition);\n+\t  nonspec_clause |= 1 << (i + predicate_first_dynamic_condition);\n \t  continue;\n \t}\n \n@@ -859,18 +894,26 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n       if (!val)\n \t{\n \t  clause |= 1 << (i + predicate_first_dynamic_condition);\n+\t  nonspec_clause |= 1 << (i + predicate_first_dynamic_condition);\n \t  continue;\n \t}\n       if (c->code == CHANGED)\n-\tcontinue;\n+\t{\n+\t  nonspec_clause |= 1 << (i + predicate_first_dynamic_condition);\n+\t  continue;\n+\t}\n \n       if (tree_to_shwi (TYPE_SIZE (TREE_TYPE (val))) != c->size)\n \t{\n \t  clause |= 1 << (i + predicate_first_dynamic_condition);\n+\t  nonspec_clause |= 1 << (i + predicate_first_dynamic_condition);\n \t  continue;\n \t}\n       if (c->code == IS_NOT_CONSTANT)\n-\tcontinue;\n+\t{\n+\t  nonspec_clause |= 1 << (i + predicate_first_dynamic_condition);\n+\t  continue;\n+\t}\n \n       val = fold_unary (VIEW_CONVERT_EXPR, TREE_TYPE (c->val), val);\n       res = val\n@@ -881,16 +924,19 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \tcontinue;\n \n       clause |= 1 << (i + predicate_first_dynamic_condition);\n+      nonspec_clause |= 1 << (i + predicate_first_dynamic_condition);\n     }\n-  return clause;\n+  *ret_clause = clause;\n+  if (ret_nonspec_clause)\n+    *ret_nonspec_clause = nonspec_clause;\n }\n \n \n /* Work out what conditions might be true at invocation of E.  */\n \n static void\n evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n-\t\t\t      clause_t *clause_ptr,\n+\t\t\t      clause_t *clause_ptr, clause_t *nonspec_clause_ptr,\n \t\t\t      vec<tree> *known_vals_ptr,\n \t\t\t      vec<ipa_polymorphic_call_context>\n \t\t\t      *known_contexts_ptr,\n@@ -976,9 +1022,9 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t}\n     }\n \n-  if (clause_ptr)\n-    *clause_ptr = evaluate_conditions_for_known_args (callee, inline_p,\n-\t\t\t\t\t\t      known_vals, known_aggs);\n+  evaluate_conditions_for_known_args (callee, inline_p,\n+\t\t\t\t      known_vals, known_aggs, clause_ptr,\n+\t\t\t\t      nonspec_clause_ptr);\n \n   if (known_vals_ptr)\n     *known_vals_ptr = known_vals;\n@@ -1172,12 +1218,16 @@ inline_summary_t::duplicate (cgraph_node *src,\n \t\t}\n \t    }\n \t}\n-      possible_truths = evaluate_conditions_for_known_args (dst, false,\n-\t\t\t\t\t\t\t    known_vals,\n-\t\t\t\t\t\t\t    vNULL);\n+      evaluate_conditions_for_known_args (dst, false,\n+\t\t\t\t\t  known_vals,\n+\t\t\t\t\t  vNULL,\n+\t\t\t\t\t  &possible_truths,\n+\t\t\t\t\t  /* We are going to specialize,\n+\t\t\t\t\t     so ignore nonspec truths.  */\n+\t\t\t\t\t  NULL);\n       known_vals.release ();\n \n-      account_size_time (info, 0, 0, &true_pred);\n+      account_size_time (info, 0, 0, &true_pred, &true_pred);\n \n       /* Remap size_time vectors.\n          Simplify the predicate by prunning out alternatives that are known\n@@ -1186,14 +1236,21 @@ inline_summary_t::duplicate (cgraph_node *src,\n          to be true.  */\n       for (i = 0; vec_safe_iterate (entry, i, &e); i++)\n \t{\n-\t  struct predicate new_predicate;\n-\t  new_predicate = remap_predicate_after_duplication (&e->predicate,\n+\t  struct predicate new_exec_pred;\n+\t  struct predicate new_nonconst_pred;\n+\t  new_exec_pred = remap_predicate_after_duplication (&e->exec_predicate,\n \t\t\t\t\t\t\t     possible_truths,\n \t\t\t\t\t\t\t     info);\n-\t  if (false_predicate_p (&new_predicate))\n+\t  new_nonconst_pred\n+\t\t = remap_predicate_after_duplication (&e->nonconst_predicate,\n+\t\t\t\t\t\t     possible_truths,\n+\t\t\t\t\t\t     info);\n+\t  if (false_predicate_p (&new_exec_pred)\n+\t      || false_predicate_p (&new_nonconst_pred))\n \t    optimized_out_size += e->size;\n \t  else\n-\t    account_size_time (info, e->size, e->time, &new_predicate);\n+\t    account_size_time (info, e->size, e->time, &new_exec_pred,\n+\t\t\t       &new_nonconst_pred);\n \t}\n \n       /* Remap edge predicates with the same simplification as above.\n@@ -1439,10 +1496,21 @@ dump_inline_summary (FILE *f, struct cgraph_node *node)\n \tfprintf (f, \"  In SCC:          %i\\n\", (int) s->scc_no);\n       for (i = 0; vec_safe_iterate (s->entry, i, &e); i++)\n \t{\n-\t  fprintf (f, \"    size:%f, time:%f, predicate:\",\n+\t  fprintf (f, \"    size:%f, time:%f\",\n \t\t   (double) e->size / INLINE_SIZE_SCALE,\n-\t\t   e->time.to_double () / INLINE_TIME_SCALE);\n-\t  dump_predicate (f, s->conds, &e->predicate);\n+\t\t   e->time.to_double ());\n+\t  if (!true_predicate_p (&e->exec_predicate))\n+\t    {\n+\t      fprintf (f, \",  executed if:\");\n+\t      dump_predicate (f, s->conds, &e->exec_predicate, 0);\n+\t    }\n+\t  if (!predicates_equal_p (&e->exec_predicate,\n+\t\t\t\t   &e->nonconst_predicate))\n+\t    {\n+\t      fprintf (f, \",  nonconst if:\");\n+\t      dump_predicate (f, s->conds, &e->nonconst_predicate, 0);\n+\t    }\n+\t  fprintf (f, \"\\n\");\n \t}\n       if (s->loop_iterations)\n \t{\n@@ -2585,10 +2653,11 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   /* When we run into maximal number of entries, we assign everything to the\n      constant truth case.  Be sure to have it in list. */\n   bb_predicate = true_predicate ();\n-  account_size_time (info, 0, 0, &bb_predicate);\n+  account_size_time (info, 0, 0, &bb_predicate, &bb_predicate);\n \n   bb_predicate = not_inlined_predicate ();\n-  account_size_time (info, 2 * INLINE_SIZE_SCALE, 0, &bb_predicate);\n+  account_size_time (info, 2 * INLINE_SIZE_SCALE, 0, &bb_predicate,\n+\t\t     &bb_predicate);\n \n   if (fbi.info)\n     compute_bb_predicates (&fbi, node, info);\n@@ -2746,10 +2815,10 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t    will_be_nonconstant\n \t      = will_be_nonconstant_predicate (&fbi, info,\n \t\t\t\t\t       stmt, nonconstant_names);\n+\t  else\n+\t    will_be_nonconstant = true_predicate ();\n \t  if (this_time || this_size)\n \t    {\n-\t      struct predicate p;\n-\n \t      this_time *= freq;\n \n \t      prob = eliminated_by_inlining_prob (stmt);\n@@ -2759,15 +2828,15 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t      if (prob == 2 && dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"\\t\\tWill be eliminated by inlining\\n\");\n \n-\t      if (fbi.info)\n-\t\tp = and_predicates (info->conds, &bb_predicate,\n-\t\t\t\t    &will_be_nonconstant);\n-\t      else\n-\t\tp = true_predicate ();\n+\t      struct predicate p = and_predicates (info->conds, &bb_predicate,\n+\t\t\t\t\t\t   &will_be_nonconstant);\n+\n+\t      /* We can ignore statement when we proved it is never going\n+\t\t to happen, but we can not do that for call statements\n+\t\t because edges are accounted specially.  */\n \n-\t      if (!false_predicate_p (&p)\n-\t\t  || (is_gimple_call (stmt)\n-\t\t      && !false_predicate_p (&bb_predicate)))\n+\t      if (!false_predicate_p (is_gimple_call (stmt)\n+\t\t\t\t      ? &bb_predicate : &p))\n \t\t{\n \t\t  time += this_time;\n \t\t  size += this_size;\n@@ -2781,13 +2850,18 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t  if (prob)\n \t\t    {\n \t\t      struct predicate ip = not_inlined_predicate ();\n-\t\t      ip = and_predicates (info->conds, &ip, &p);\n+\t\t      ip = and_predicates (info->conds, &ip, &bb_predicate);\n \t\t      account_size_time (info, this_size * prob,\n-\t\t\t\t\t this_time * prob, &ip);\n+\t\t\t\t\t (sreal)(this_time * prob)\n+\t\t\t\t\t / (CGRAPH_FREQ_BASE * 2), &ip,\n+\t\t\t\t\t &p);\n \t\t    }\n \t\t  if (prob != 2)\n \t\t    account_size_time (info, this_size * (2 - prob),\n-\t\t\t\t       this_time * (2 - prob), &p);\n+\t\t\t\t       (sreal)(this_time * (2 - prob))\n+\t\t\t\t\t/ (CGRAPH_FREQ_BASE * 2),\n+\t\t\t\t       &bb_predicate,\n+\t\t\t\t       &p);\n \t\t}\n \n \t      if (!info->fp_expressions && fp_expression_p (stmt))\n@@ -2969,9 +3043,9 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n       es->call_stmt_size = eni_size_weights.call_cost;\n       es->call_stmt_time = eni_time_weights.call_cost;\n       account_size_time (info, INLINE_SIZE_SCALE * 2,\n-\t\t\t INLINE_TIME_SCALE * 2, &t);\n+\t\t\t 2, &t, &t);\n       t = not_inlined_predicate ();\n-      account_size_time (info, 2 * INLINE_SIZE_SCALE, 0, &t);\n+      account_size_time (info, 2 * INLINE_SIZE_SCALE, 0, &t, &t);\n       inline_update_overall_summary (node);\n       info->self_size = info->size;\n       info->self_time = info->time;\n@@ -3048,7 +3122,7 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n   if (flag_checking)\n     {\n       inline_update_overall_summary (node);\n-      gcc_assert (info->time == info->self_time\n+      gcc_assert (!(info->time - info->self_time).to_int ()\n \t\t  && info->size == info->self_size);\n     }\n }\n@@ -3174,8 +3248,11 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n   *size += cur_size;\n   if (min_size)\n     *min_size += cur_size;\n-  *time += call_time * prob / REG_BR_PROB_BASE\n-    * e->frequency * (INLINE_TIME_SCALE / CGRAPH_FREQ_BASE);\n+  if (prob == REG_BR_PROB_BASE)\n+    *time += ((sreal)(call_time * e->frequency)) / CGRAPH_FREQ_BASE;\n+  else\n+    *time += ((sreal)call_time) * (prob * e->frequency)\n+\t      / (CGRAPH_FREQ_BASE * REG_BR_PROB_BASE);\n }\n \n \n@@ -3257,10 +3334,13 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n static void\n estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t     clause_t possible_truths,\n+\t\t\t     clause_t nonspec_possible_truths,\n \t\t\t     vec<tree> known_vals,\n \t\t\t     vec<ipa_polymorphic_call_context> known_contexts,\n \t\t\t     vec<ipa_agg_jump_function_p> known_aggs,\n-\t\t\t     int *ret_size, int *ret_min_size, sreal *ret_time,\n+\t\t\t     int *ret_size, int *ret_min_size,\n+\t\t\t     sreal *ret_time,\n+\t\t\t     sreal *ret_nonspecialized_time,\n \t\t\t     inline_hints *ret_hints,\n \t\t\t     vec<inline_param_summary>\n \t\t\t     inline_param_summary)\n@@ -3292,31 +3372,57 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t  }\n     }\n \n-  for (i = 0; vec_safe_iterate (info->entry, i, &e); i++)\n-    if (evaluate_predicate (&e->predicate, possible_truths))\n-      {\n-\tsize += e->size;\n-\tgcc_checking_assert (e->time >= 0);\n-\tgcc_checking_assert (time >= 0);\n-\tif (!inline_param_summary.exists ())\n-\t  time += e->time;\n-\telse\n-\t  {\n-\t    int prob = predicate_probability (info->conds,\n-\t\t\t\t\t      &e->predicate,\n-\t\t\t\t\t      possible_truths,\n-\t\t\t\t\t      inline_param_summary);\n-\t    gcc_checking_assert (prob >= 0);\n-\t    gcc_checking_assert (prob <= REG_BR_PROB_BASE);\n-\t    time += e->time * prob / REG_BR_PROB_BASE;\n-\t  }\n-\tgcc_checking_assert (time >= 0);\n+  estimate_calls_size_and_time (node, &size, &min_size, &time, &hints, possible_truths,\n+\t\t\t\tknown_vals, known_contexts, known_aggs);\n+  sreal nonspecialized_time = time;\n \n-      }\n-  gcc_checking_assert (true_predicate_p (&(*info->entry)[0].predicate));\n+  for (i = 0; vec_safe_iterate (info->entry, i, &e); i++)\n+    {\n+      bool nonconst = evaluate_predicate (&e->nonconst_predicate,\n+\t\t\t\t\t  possible_truths);\n+      bool exec = evaluate_predicate (&e->exec_predicate,\n+\t\t\t\t      nonspec_possible_truths);\n+      gcc_assert (!nonconst || exec);\n+      if (exec)\n+        {\n+\t  gcc_checking_assert (e->time >= 0);\n+\t  gcc_checking_assert (time >= 0);\n+\n+\t  /* We compute specialized size only because size of nonspecialized\n+\t     copy is context independent.\n+\n+\t     The difference between nonspecialized execution and specialized is\n+\t     that nonspecialized is not going to have optimized out computations\n+\t     known to be constant in a specialized setting.  */\n+\t  if (nonconst)\n+\t    size += e->size;\n+\t  nonspecialized_time += e->time;\n+\t  if (!nonconst)\n+\t    ;\n+\t  else if (!inline_param_summary.exists ())\n+\t    {\n+\t      if (nonconst)\n+\t        time += e->time;\n+\t    }\n+\t  else\n+\t    {\n+\t      int prob = predicate_probability (info->conds,\n+\t\t\t\t\t        &e->nonconst_predicate,\n+\t\t\t\t\t        possible_truths,\n+\t\t\t\t\t        inline_param_summary);\n+\t      gcc_checking_assert (prob >= 0);\n+\t      gcc_checking_assert (prob <= REG_BR_PROB_BASE);\n+\t      time += e->time * prob / REG_BR_PROB_BASE;\n+\t    }\n+\t  gcc_checking_assert (time >= 0);\n+        }\n+     }\n+  gcc_checking_assert (true_predicate_p (&(*info->entry)[0].exec_predicate));\n+  gcc_checking_assert (true_predicate_p (&(*info->entry)[0].nonconst_predicate));\n   min_size = (*info->entry)[0].size;\n   gcc_checking_assert (size >= 0);\n   gcc_checking_assert (time >= 0);\n+  gcc_checking_assert (nonspecialized_time >= time);\n \n   if (info->loop_iterations\n       && !evaluate_predicate (info->loop_iterations, possible_truths))\n@@ -3332,18 +3438,16 @@ estimate_node_size_and_time (struct cgraph_node *node,\n   if (DECL_DECLARED_INLINE_P (node->decl))\n     hints |= INLINE_HINT_declared_inline;\n \n-  estimate_calls_size_and_time (node, &size, &min_size, &time, &hints, possible_truths,\n-\t\t\t\tknown_vals, known_contexts, known_aggs);\n-  gcc_checking_assert (size >= 0);\n-  gcc_checking_assert (time >= 0);\n-  time = time / INLINE_TIME_SCALE;\n   size = RDIV (size, INLINE_SIZE_SCALE);\n   min_size = RDIV (min_size, INLINE_SIZE_SCALE);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\n   size:%i time:%f\\n\", (int) size, time.to_double ());\n+    fprintf (dump_file, \"\\n   size:%i time:%f nonspec time:%f\\n\", (int) size,\n+\t     time.to_double (), nonspecialized_time.to_double ());\n   if (ret_time)\n     *ret_time = time;\n+  if (ret_nonspecialized_time)\n+    *ret_nonspecialized_time = nonspecialized_time;\n   if (ret_size)\n     *ret_size = size;\n   if (ret_min_size)\n@@ -3368,12 +3472,15 @@ estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n \t\t\t\t   int *ret_size, sreal *ret_time,\n \t\t\t\t   inline_hints *hints)\n {\n-  clause_t clause;\n-\n-  clause = evaluate_conditions_for_known_args (node, false, known_vals,\n-\t\t\t\t\t       known_aggs);\n-  estimate_node_size_and_time (node, clause, known_vals, known_contexts,\n-\t\t\t       known_aggs, ret_size, NULL, ret_time, hints, vNULL);\n+  clause_t clause, nonspec_clause;\n+  sreal nonspec_time;\n+\n+  evaluate_conditions_for_known_args (node, false, known_vals, known_aggs,\n+\t\t\t\t      &clause, &nonspec_clause);\n+  estimate_node_size_and_time (node, clause, nonspec_clause,\n+\t\t\t       known_vals, known_contexts,\n+\t\t\t       known_aggs, ret_size, NULL, ret_time,\n+\t\t\t       &nonspec_time, hints, vNULL);\n }\n \n /* Translate all conditions from callee representation into caller\n@@ -3645,7 +3752,7 @@ inline_merge_summary (struct cgraph_edge *edge)\n   struct cgraph_node *to = (edge->caller->global.inlined_to\n \t\t\t    ? edge->caller->global.inlined_to : edge->caller);\n   struct inline_summary *info = inline_summaries->get (to);\n-  clause_t clause = 0;\t\t/* not_inline is known to be false.  */\n+  clause_t clause = 0;\t/* not_inline is known to be false.  */\n   size_time_entry *e;\n   vec<int> operand_map = vNULL;\n   vec<int> offset_map = vNULL;\n@@ -3662,7 +3769,7 @@ inline_merge_summary (struct cgraph_edge *edge)\n   info->fp_expressions |= callee_info->fp_expressions;\n \n   if (callee_info->conds)\n-    evaluate_properties_for_edge (edge, true, &clause, NULL, NULL, NULL);\n+    evaluate_properties_for_edge (edge, true, &clause, NULL, NULL, NULL, NULL);\n   if (ipa_node_params_sum && callee_info->conds)\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (edge);\n@@ -3705,14 +3812,19 @@ inline_merge_summary (struct cgraph_edge *edge)\n   for (i = 0; vec_safe_iterate (callee_info->entry, i, &e); i++)\n     {\n       struct predicate p = remap_predicate (info, callee_info,\n-\t\t\t\t\t    &e->predicate, operand_map,\n+\t\t\t\t\t    &e->exec_predicate, operand_map,\n \t\t\t\t\t    offset_map, clause,\n \t\t\t\t\t    &toplev_predicate);\n-      if (!false_predicate_p (&p))\n+      struct predicate nonconstp\n+\t\t\t = remap_predicate (info, callee_info,\n+\t\t\t\t\t    &e->nonconst_predicate, operand_map,\n+\t\t\t\t\t    offset_map, clause,\n+\t\t\t\t\t    &toplev_predicate);\n+      if (!false_predicate_p (&p) && !false_predicate_p (&nonconstp))\n \t{\n-\t  sreal add_time = e->time * edge->frequency / CGRAPH_FREQ_BASE;\n+\t  sreal add_time = ((sreal)e->time * edge->frequency) / CGRAPH_FREQ_BASE;\n \t  int prob = predicate_probability (callee_info->conds,\n-\t\t\t\t\t    &e->predicate,\n+\t\t\t\t\t    &e->nonconst_predicate,\n \t\t\t\t\t    clause, es->param);\n \t  add_time = add_time * prob / REG_BR_PROB_BASE;\n \t  if (prob != REG_BR_PROB_BASE\n@@ -3721,7 +3833,7 @@ inline_merge_summary (struct cgraph_edge *edge)\n \t      fprintf (dump_file, \"\\t\\tScaling time by probability:%f\\n\",\n \t\t       (double) prob / REG_BR_PROB_BASE);\n \t    }\n-\t  account_size_time (info, e->size, add_time, &p);\n+\t  account_size_time (info, e->size, add_time, &p, &nonconstp);\n \t}\n     }\n   remap_edge_summaries (edge, edge->callee, info, callee_info, operand_map,\n@@ -3761,13 +3873,13 @@ inline_update_overall_summary (struct cgraph_node *node)\n   info->time = 0;\n   for (i = 0; vec_safe_iterate (info->entry, i, &e); i++)\n     {\n-      info->size += e->size, info->time += e->time;\n+      info->size += e->size;\n+      info->time += e->time;\n     }\n   estimate_calls_size_and_time (node, &info->size, &info->min_size,\n \t\t\t\t&info->time, NULL,\n \t\t\t\t~(clause_t) (1 << predicate_false_condition),\n \t\t\t\tvNULL, vNULL, vNULL);\n-  info->time = info->time / INLINE_TIME_SCALE;\n   info->size = (info->size + INLINE_SIZE_SCALE / 2) / INLINE_SIZE_SCALE;\n }\n \n@@ -3803,11 +3915,11 @@ simple_edge_hints (struct cgraph_edge *edge)\n sreal\n do_estimate_edge_time (struct cgraph_edge *edge)\n {\n-  sreal time;\n+  sreal time, nonspec_time;\n   int size;\n   inline_hints hints;\n   struct cgraph_node *callee;\n-  clause_t clause;\n+  clause_t clause, nonspec_clause;\n   vec<tree> known_vals;\n   vec<ipa_polymorphic_call_context> known_contexts;\n   vec<ipa_agg_jump_function_p> known_aggs;\n@@ -3818,10 +3930,11 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n \n   gcc_checking_assert (edge->inline_failed);\n   evaluate_properties_for_edge (edge, true,\n-\t\t\t\t&clause, &known_vals, &known_contexts,\n-\t\t\t\t&known_aggs);\n-  estimate_node_size_and_time (callee, clause, known_vals, known_contexts,\n-\t\t\t       known_aggs, &size, &min_size, &time, &hints, es->param);\n+\t\t\t\t&clause, &nonspec_clause, &known_vals,\n+\t\t\t\t&known_contexts, &known_aggs);\n+  estimate_node_size_and_time (callee, clause, nonspec_clause, known_vals,\n+\t\t\t       known_contexts, known_aggs, &size, &min_size,\n+\t\t\t       &time, &nonspec_time, &hints, es->param);\n \n   /* When we have profile feedback, we can quite safely identify hot\n      edges and for those we disable size limits.  Don't do that when\n@@ -3846,6 +3959,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n       if ((int) edge_growth_cache.length () <= edge->uid)\n \tedge_growth_cache.safe_grow_cleared (symtab->edges_max_uid);\n       edge_growth_cache[edge->uid].time = time;\n+      edge_growth_cache[edge->uid].nonspec_time = nonspec_time;\n \n       edge_growth_cache[edge->uid].size = size + (size >= 0);\n       hints |= simple_edge_hints (edge);\n@@ -3863,7 +3977,7 @@ do_estimate_edge_size (struct cgraph_edge *edge)\n {\n   int size;\n   struct cgraph_node *callee;\n-  clause_t clause;\n+  clause_t clause, nonspec_clause;\n   vec<tree> known_vals;\n   vec<ipa_polymorphic_call_context> known_contexts;\n   vec<ipa_agg_jump_function_p> known_aggs;\n@@ -3883,10 +3997,12 @@ do_estimate_edge_size (struct cgraph_edge *edge)\n   /* Early inliner runs without caching, go ahead and do the dirty work.  */\n   gcc_checking_assert (edge->inline_failed);\n   evaluate_properties_for_edge (edge, true,\n-\t\t\t\t&clause, &known_vals, &known_contexts,\n+\t\t\t\t&clause, &nonspec_clause,\n+\t\t\t\t&known_vals, &known_contexts,\n \t\t\t\t&known_aggs);\n-  estimate_node_size_and_time (callee, clause, known_vals, known_contexts,\n-\t\t\t       known_aggs, &size, NULL, NULL, NULL, vNULL);\n+  estimate_node_size_and_time (callee, clause, nonspec_clause, known_vals,\n+\t\t\t       known_contexts, known_aggs, &size, NULL, NULL,\n+\t\t\t       NULL, NULL, vNULL);\n   known_vals.release ();\n   known_contexts.release ();\n   known_aggs.release ();\n@@ -3902,7 +4018,7 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n {\n   inline_hints hints;\n   struct cgraph_node *callee;\n-  clause_t clause;\n+  clause_t clause, nonspec_clause;\n   vec<tree> known_vals;\n   vec<ipa_polymorphic_call_context> known_contexts;\n   vec<ipa_agg_jump_function_p> known_aggs;\n@@ -3922,10 +4038,12 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n   /* Early inliner runs without caching, go ahead and do the dirty work.  */\n   gcc_checking_assert (edge->inline_failed);\n   evaluate_properties_for_edge (edge, true,\n-\t\t\t\t&clause, &known_vals, &known_contexts,\n+\t\t\t\t&clause, &nonspec_clause,\n+\t\t\t\t&known_vals, &known_contexts,\n \t\t\t\t&known_aggs);\n-  estimate_node_size_and_time (callee, clause, known_vals, known_contexts,\n-\t\t\t       known_aggs, NULL, NULL, NULL, &hints, vNULL);\n+  estimate_node_size_and_time (callee, clause, nonspec_clause, known_vals,\n+\t\t\t       known_contexts, known_aggs, NULL, NULL,\n+\t\t\t       NULL, NULL, &hints, vNULL);\n   known_vals.release ();\n   known_contexts.release ();\n   known_aggs.release ();\n@@ -4304,7 +4422,8 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \n \t  e.size = streamer_read_uhwi (&ib);\n \t  e.time = sreal::stream_in (&ib);\n-\t  e.predicate = read_predicate (&ib);\n+\t  e.exec_predicate = read_predicate (&ib);\n+\t  e.nonconst_predicate = read_predicate (&ib);\n \n \t  vec_safe_push (info->entry, e);\n \t}\n@@ -4463,7 +4582,8 @@ inline_write_summary (void)\n \t    {\n \t      streamer_write_uhwi (ob, e->size);\n \t      e->time.stream_out (ob);\n-\t      write_predicate (ob, &e->predicate);\n+\t      write_predicate (ob, &e->exec_predicate);\n+\t      write_predicate (ob, &e->nonconst_predicate);\n \t    }\n \t  write_predicate (ob, info->loop_iterations);\n \t  write_predicate (ob, info->loop_stride);"}, {"sha": "dedacc9df684fea42e7dd67cf58c94ab0a3c4b44", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4adaad64960bc3d432f634066759c6c66f0e981d/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4adaad64960bc3d432f634066759c6c66f0e981d/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=4adaad64960bc3d432f634066759c6c66f0e981d", "patch": "@@ -639,10 +639,9 @@ want_early_inline_function_p (struct cgraph_edge *e)\n    does not happen.  */\n \n inline sreal\n-compute_uninlined_call_time (struct inline_summary *callee_info,\n-\t\t\t     struct cgraph_edge *edge)\n+compute_uninlined_call_time (struct cgraph_edge *edge,\n+\t\t\t     sreal uninlined_call_time)\n {\n-  sreal uninlined_call_time = (sreal)callee_info->time;\n   cgraph_node *caller = (edge->caller->global.inlined_to \n \t\t\t ? edge->caller->global.inlined_to\n \t\t\t : edge->caller);\n@@ -677,12 +676,10 @@ compute_inlined_call_time (struct cgraph_edge *edge,\n   else\n     time = time >> 11;\n \n-  /* This calculation should match one in ipa-inline-analysis.\n-     FIXME: Once ipa-inline-analysis is converted to sreal this can be\n-     simplified.  */\n-  time -= (sreal) ((gcov_type) edge->frequency\n-\t\t   * inline_edge_summary (edge)->call_stmt_time\n-\t           * (INLINE_TIME_SCALE / CGRAPH_FREQ_BASE)) / INLINE_TIME_SCALE;\n+  /* This calculation should match one in ipa-inline-analysis.c\n+     (estimate_edge_size_and_time).  */\n+  time -= (sreal) edge->frequency\n+\t   * inline_edge_summary (edge)->call_stmt_time / CGRAPH_FREQ_BASE;\n   time += caller_time;\n   if (time <= 0)\n     time = ((sreal) 1) >> 8;\n@@ -696,12 +693,13 @@ compute_inlined_call_time (struct cgraph_edge *edge,\n static bool\n big_speedup_p (struct cgraph_edge *e)\n {\n-  sreal time = compute_uninlined_call_time (inline_summaries->get (e->callee),\n-\t\t\t\t\t    e);\n-  sreal inlined_time = compute_inlined_call_time (e, estimate_edge_time (e));\n+  sreal unspec_time;\n+  sreal spec_time = estimate_edge_time (e, &unspec_time);\n+  sreal time = compute_uninlined_call_time (e, unspec_time);\n+  sreal inlined_time = compute_inlined_call_time (e, spec_time);\n \n   if (time - inlined_time\n-      > (sreal) time * PARAM_VALUE (PARAM_INLINE_MIN_SPEEDUP)\n+      > (sreal) (time * PARAM_VALUE (PARAM_INLINE_MIN_SPEEDUP))\n \t * percent_rec)\n     return true;\n   return false;\n@@ -1011,7 +1009,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n {\n   sreal badness;\n   int growth;\n-  sreal edge_time;\n+  sreal edge_time, unspec_edge_time;\n   struct cgraph_node *callee = edge->callee->ultimate_alias_target ();\n   struct inline_summary *callee_info = inline_summaries->get (callee);\n   inline_hints hints;\n@@ -1020,12 +1018,11 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t\t\t : edge->caller);\n \n   growth = estimate_edge_growth (edge);\n-  edge_time = estimate_edge_time (edge);\n+  edge_time = estimate_edge_time (edge, &unspec_edge_time);\n   hints = estimate_edge_hints (edge);\n   gcc_checking_assert (edge_time >= 0);\n-  /* FIXME: -1 to care of rounding issues should go away once cache is migrated.\n-     to sreals.  */\n-  gcc_checking_assert (edge_time <= callee_info->time);\n+  /* Check that inlined time is better, but tolerate some roundoff issues.  */\n+  gcc_checking_assert ((edge_time - callee_info->time).to_int () <= 0);\n   gcc_checking_assert (growth <= callee_info->size);\n \n   if (dump)\n@@ -1035,9 +1032,10 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t       edge->caller->order,\n \t       xstrdup_for_dump (callee->name ()),\n \t       edge->callee->order);\n-      fprintf (dump_file, \"      size growth %i, time %f \",\n+      fprintf (dump_file, \"      size growth %i, time %f unspec %f \",\n \t       growth,\n-\t       edge_time.to_double ());\n+\t       edge_time.to_double (),\n+\t       unspec_edge_time.to_double ());\n       dump_inline_hints (dump_file, hints);\n       if (big_speedup_p (edge))\n \tfprintf (dump_file, \" big_speedup\");\n@@ -1076,7 +1074,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n       sreal numerator, denominator;\n       int overall_growth;\n \n-      numerator = (compute_uninlined_call_time (callee_info, edge)\n+      numerator = (compute_uninlined_call_time (edge, unspec_edge_time)\n \t\t   - compute_inlined_call_time (edge, edge_time));\n       if (numerator == 0)\n \tnumerator = ((sreal) 1 >> 8);\n@@ -1162,13 +1160,14 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t  fprintf (dump_file,\n \t\t   \"      %f: guessed profile. frequency %f, count %\" PRId64\n \t\t   \" caller count %\" PRId64\n-\t\t   \" time w/o inlining %f, time w/ inlining %f\"\n+\t\t   \" time w/o inlining %f, time with inlining %f\"\n \t\t   \" overall growth %i (current) %i (original)\"\n \t\t   \" %i (compensated)\\n\",\n \t\t   badness.to_double (),\n \t\t  (double)edge->frequency / CGRAPH_FREQ_BASE,\n \t\t   edge->count, caller->count,\n-\t\t   compute_uninlined_call_time (callee_info, edge).to_double (),\n+\t\t   compute_uninlined_call_time (edge,\n+\t\t\t\t\t\tunspec_edge_time).to_double (),\n \t\t   compute_inlined_call_time (edge, edge_time).to_double (),\n \t\t   estimate_growth (callee),\n \t\t   callee_info->growth, overall_growth);\n@@ -2056,8 +2055,9 @@ inline_small_functions (void)\n       if (dump_file)\n \t{\n \t  fprintf (dump_file,\n-\t\t   \" Inlined into %s which now has time %f and size %i, \"\n+\t\t   \" Inlined %s into %s which now has time %f and size %i, \"\n \t\t   \"net change of %+i.\\n\",\n+\t\t   edge->callee->name (),\n \t\t   edge->caller->name (),\n \t\t   inline_summaries->get (edge->caller)->time.to_double (),\n \t\t   inline_summaries->get (edge->caller)->size,"}, {"sha": "c9720dc7f81bf10a55abe5c32ad21a720aa0f5d4", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4adaad64960bc3d432f634066759c6c66f0e981d/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4adaad64960bc3d432f634066759c6c66f0e981d/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=4adaad64960bc3d432f634066759c6c66f0e981d", "patch": "@@ -103,13 +103,16 @@ struct GTY(()) predicate\n    context.  We keep simple array of record, every containing of predicate\n    and time/size to account.\n \n-   We keep values scaled up, so fractional sizes and times can be\n-   accounted.  */\n+   We keep values scaled up, so fractional sizes can be accounted.  */\n #define INLINE_SIZE_SCALE 2\n-#define INLINE_TIME_SCALE (CGRAPH_FREQ_BASE * 2)\n struct GTY(()) size_time_entry\n {\n-  struct predicate predicate;\n+  /* Predicate for code to be executed.  */\n+  struct predicate exec_predicate;\n+  /* Predicate for value to be constant and optimized out in a specialized copy.\n+     When deciding on specialization this makes it possible to see how much\n+     the executed code paths will simplify.  */\n+  struct predicate nonconst_predicate;\n   int size;\n   sreal GTY((skip)) time;\n };\n@@ -230,9 +233,11 @@ struct inline_edge_summary\n typedef struct inline_edge_summary inline_edge_summary_t;\n extern vec<inline_edge_summary_t> inline_edge_summary_vec;\n \n+/* Data we cache about callgraph edges during inlining to avoid expensive\n+   re-computations during the greedy algorithm.  */\n struct edge_growth_cache_entry\n {\n-  sreal time;\n+  sreal time, nonspec_time;\n   int size;\n   inline_hints hints;\n };\n@@ -315,12 +320,14 @@ estimate_edge_growth (struct cgraph_edge *edge)\n    EDGE.  */\n \n static inline sreal\n-estimate_edge_time (struct cgraph_edge *edge)\n+estimate_edge_time (struct cgraph_edge *edge, sreal *nonspec_time = NULL)\n {\n   sreal ret;\n   if ((int)edge_growth_cache.length () <= edge->uid\n       || !edge_growth_cache[edge->uid].size)\n     return do_estimate_edge_time (edge);\n+  if (nonspec_time)\n+    *nonspec_time = edge_growth_cache[edge->uid].nonspec_time;\n   return edge_growth_cache[edge->uid].time;\n }\n \n@@ -345,7 +352,7 @@ reset_edge_growth_cache (struct cgraph_edge *edge)\n {\n   if ((int)edge_growth_cache.length () > edge->uid)\n     {\n-      struct edge_growth_cache_entry zero = {0, 0, 0};\n+      struct edge_growth_cache_entry zero = {0, 0, 0, 0};\n       edge_growth_cache[edge->uid] = zero;\n     }\n }"}]}