{"sha": "80c29cc43702b54cdd5de86bee8b8e24ecce2b4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBjMjljYzQzNzAyYjU0Y2RkNWRlODZiZWU4YjhlMjRlY2NlMmI0ZQ==", "commit": {"author": {"name": "Roman Zippel", "email": "zippel@linux-m68k.org", "date": "2001-08-27T22:01:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-08-27T22:01:07Z"}, "message": "gcse.c (reg_first_set, [...]): Replace with ...\n\n        * gcse.c (reg_first_set, reg_last_set): Replace with ...\n        (reg_avail_info, current_bb): ... these.\n        (oprs_unchanged_p, record_last_reg_set_info): Use them.\n        (compute_hash_table): Likewise.\n\nCo-Authored-By: Richard Henderson <rth@redhat.com>\n\nFrom-SVN: r45213", "tree": {"sha": "5e50dc625fd4e5264f1f3e1762c254601277e677", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e50dc625fd4e5264f1f3e1762c254601277e677"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80c29cc43702b54cdd5de86bee8b8e24ecce2b4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80c29cc43702b54cdd5de86bee8b8e24ecce2b4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80c29cc43702b54cdd5de86bee8b8e24ecce2b4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80c29cc43702b54cdd5de86bee8b8e24ecce2b4e/comments", "author": null, "committer": null, "parents": [{"sha": "bce7bfe83537e9e14bbe92e3424694745d7121a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bce7bfe83537e9e14bbe92e3424694745d7121a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bce7bfe83537e9e14bbe92e3424694745d7121a6"}], "stats": {"total": 95, "additions": 58, "deletions": 37}, "files": [{"sha": "a517aae60d420b266fad1ac2b8f59e946899b60f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c29cc43702b54cdd5de86bee8b8e24ecce2b4e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c29cc43702b54cdd5de86bee8b8e24ecce2b4e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=80c29cc43702b54cdd5de86bee8b8e24ecce2b4e", "patch": "@@ -1,3 +1,11 @@\n+2001-08-27  Roman Zippel <zippel@linux-m68k.org>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\t* gcse.c (reg_first_set, reg_last_set): Replace with ...\n+\t(reg_avail_info, current_bb): ... these.\n+\t(oprs_unchanged_p, record_last_reg_set_info): Use them.\n+\t(compute_hash_table): Likewise.\n+\n 2001-08-27  Roman Zippel <zippel@linux-m68k.org>\n \n \t* flow.c (verify_flow_info): Use checksums to verify edges."}, {"sha": "2a33a1555ec6a19567c1a995d10dae2c7c9b92e7", "filename": "gcc/gcse.c", "status": "modified", "additions": 50, "deletions": 37, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c29cc43702b54cdd5de86bee8b8e24ecce2b4e/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c29cc43702b54cdd5de86bee8b8e24ecce2b4e/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=80c29cc43702b54cdd5de86bee8b8e24ecce2b4e", "patch": "@@ -1298,11 +1298,19 @@ compute_sets (f)\n \f\n /* Hash table support.  */\n \n-/* For each register, the cuid of the first/last insn in the block to set it,\n-   or -1 if not set.  */\n+/* For each register, the cuid of the first/last insn in the block\n+   that set it, or -1 if not set.  */\n #define NEVER_SET -1\n-static int *reg_first_set;\n-static int *reg_last_set;\n+\n+struct reg_avail_info\n+{\n+  int last_bb;\n+  int first_set;\n+  int last_set;\n+};\n+\n+static struct reg_avail_info *reg_avail_info;\n+static int current_bb;\n \n \n /* See whether X, the source of a set, is something we want to consider for\n@@ -1376,15 +1384,19 @@ oprs_unchanged_p (x, insn, avail_p)\n   switch (code)\n     {\n     case REG:\n-      if (avail_p)\n-\treturn (reg_last_set[REGNO (x)] == NEVER_SET\n-\t\t|| reg_last_set[REGNO (x)] < INSN_CUID (insn));\n-      else\n-\treturn (reg_first_set[REGNO (x)] == NEVER_SET\n-\t\t|| reg_first_set[REGNO (x)] >= INSN_CUID (insn));\n+      {\n+\tstruct reg_avail_info *info = &reg_avail_info[REGNO (x)];\n+\n+\tif (info->last_bb != current_bb)\n+\t  return 1;\n+        if (avail_p)\n+\t  return info->last_set < INSN_CUID (insn);\n+\telse\n+\t  return info->first_set >= INSN_CUID (insn);\n+      }\n \n     case MEM:\n-      if (load_killed_in_block_p (BLOCK_FOR_INSN (insn), INSN_CUID (insn),\n+      if (load_killed_in_block_p (BASIC_BLOCK (current_bb), INSN_CUID (insn),\n \t\t\t\t  x, avail_p))\n \treturn 0;\n       else\n@@ -2328,12 +2340,15 @@ dump_hash_table (file, name, table, table_size, total_size)\n \n /* Record register first/last/block set information for REGNO in INSN.\n \n-   reg_first_set records the first place in the block where the register\n+   first_set records the first place in the block where the register\n    is set and is used to compute \"anticipatability\".\n \n-   reg_last_set records the last place in the block where the register\n+   last_set records the last place in the block where the register\n    is set and is used to compute \"availability\".\n \n+   last_bb records the block for which first_set and last_set are\n+   valid, as a quick test to invalidate them.\n+\n    reg_set_in_block records whether the register is set in the block\n    and is used to compute \"transparency\".  */\n \n@@ -2342,11 +2357,16 @@ record_last_reg_set_info (insn, regno)\n      rtx insn;\n      int regno;\n {\n-  if (reg_first_set[regno] == NEVER_SET)\n-    reg_first_set[regno] = INSN_CUID (insn);\n+  struct reg_avail_info *info = &reg_avail_info[regno];\n+  int cuid = INSN_CUID (insn);\n \n-  reg_last_set[regno] = INSN_CUID (insn);\n-  SET_BIT (reg_set_in_block[BLOCK_NUM (insn)], regno);\n+  info->last_set = cuid;\n+  if (info->last_bb != current_bb)\n+    {\n+      info->last_bb = current_bb;\n+      info->first_set = cuid;\n+      SET_BIT (reg_set_in_block[current_bb], regno);\n+    }\n }\n \n \n@@ -2453,7 +2473,7 @@ static void\n compute_hash_table (set_p)\n      int set_p;\n {\n-  int bb;\n+  unsigned int i;\n \n   /* While we compute the hash table we also compute a bit array of which\n      registers are set in which blocks.\n@@ -2473,29 +2493,25 @@ compute_hash_table (set_p)\n       }\n   }\n   /* Some working arrays used to track first and last set in each block.  */\n-  /* ??? One could use alloca here, but at some size a threshold is crossed\n-     beyond which one should use malloc.  Are we at that threshold here?  */\n-  reg_first_set = (int *) gmalloc (max_gcse_regno * sizeof (int));\n-  reg_last_set = (int *) gmalloc (max_gcse_regno * sizeof (int));\n+  reg_avail_info = (struct reg_avail_info*)\n+    gmalloc (max_gcse_regno * sizeof (struct reg_avail_info));\n \n-  for (bb = 0; bb < n_basic_blocks; bb++)\n+  for (i = 0; i < max_gcse_regno; ++i)\n+    reg_avail_info[i].last_bb = NEVER_SET;\n+\n+  for (current_bb = 0; current_bb < n_basic_blocks; current_bb++)\n     {\n       rtx insn;\n       unsigned int regno;\n       int in_libcall_block;\n-      unsigned int i;\n \n       /* First pass over the instructions records information used to\n \t determine when registers and memory are first and last set.\n \t ??? hard-reg reg_set_in_block computation\n \t could be moved to compute_sets since they currently don't change.  */\n \n-      for (i = 0; i < max_gcse_regno; i++)\n-\treg_first_set[i] = reg_last_set[i] = NEVER_SET;\n-\n-\n-      for (insn = BLOCK_HEAD (bb);\n-\t   insn && insn != NEXT_INSN (BLOCK_END (bb));\n+      for (insn = BLOCK_HEAD (current_bb);\n+\t   insn && insn != NEXT_INSN (BLOCK_END (current_bb));\n \t   insn = NEXT_INSN (insn))\n \t{\n \t  if (! INSN_P (insn))\n@@ -2523,8 +2539,8 @@ compute_hash_table (set_p)\n \n       /* The next pass builds the hash table.  */\n \n-      for (insn = BLOCK_HEAD (bb), in_libcall_block = 0;\n-\t   insn && insn != NEXT_INSN (BLOCK_END (bb));\n+      for (insn = BLOCK_HEAD (current_bb), in_libcall_block = 0;\n+\t   insn && insn != NEXT_INSN (BLOCK_END (current_bb));\n \t   insn = NEXT_INSN (insn))\n \tif (INSN_P (insn))\n \t  {\n@@ -2536,11 +2552,8 @@ compute_hash_table (set_p)\n \t}\n     }\n \n-  free (reg_first_set);\n-  free (reg_last_set);\n-\n-  /* Catch bugs early.  */\n-  reg_first_set = reg_last_set = 0;\n+  free (reg_avail_info);\n+  reg_avail_info = NULL;\n }\n \n /* Allocate space for the set hash table."}]}