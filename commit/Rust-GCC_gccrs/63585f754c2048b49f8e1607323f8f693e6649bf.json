{"sha": "63585f754c2048b49f8e1607323f8f693e6649bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM1ODVmNzU0YzIwNDhiNDlmOGUxNjA3MzIzZjhmNjkzZTY2NDliZg==", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2011-09-06T07:46:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-06T07:46:28Z"}, "message": "einfo.ads (Extra_Accessibility_Of_Result): New function...\n\n2011-09-06  Steve Baird  <baird@adacore.com>\n\n\t* einfo.ads (Extra_Accessibility_Of_Result): New function; in the\n\t(Ada2012) cases described in AI05-0234 where the accessibility\n\tlevel of a function result is \"determined by the point of\n\tcall\", an implicit parameter representing that accessibility\n\tlevel is passed in. Extra_Accessibilty_Of_Result yields this\n\tadditional formal parameter. Extra_Accessibility_Of_Result\n\tis analogous to the existing Extra_Accessibility\n\tfunction used in the implementation of access parameters.\n\t(Set_Extra_Accessibility_Of_Result): New procedure; sets\n\tExtra_Accessibility_Of_Result attribute.\n\t* einfo.adb (Extra_Accessibility_Of_Result): New function.\n\t(Set_Extra_Accessibility_Of_Result): New procedure.\n\t(Write_Field19_Name): Display Extra_Accessibilty_Of_Result attribute.\n\t* sem_util.adb (Dynamic_Accessibility_Level): Set Etype of\n\tan accessibility level literal to Natural; introduce a nested\n\tfunction, Make_Level_Literal, to do this.\n\t* exp_ch6.ads (Needs_Result_Accessibility_Level): New function;\n\tdetermines whether a given function (or access-to-function\n\ttype) needs to have an implicitly-declared accessibility-level\n\tparameter added to its profile.\n\t(Add_Extra_Actual_To_Call): Export an existing procedure which was\n\tpreviously declared in the body of Exp_Ch6.\n\t* exp_ch6.adb (Add_Extra_Actual_To_Call): Export declaration by moving\n\tit to exp_ch6.ads.\n\t(Has_Unconstrained_Access_Discriminants): New Function; a\n\tpredicate on subtype entities which returns True if the given\n\tsubtype is unconstrained and has one or more access discriminants.\n\t(Expand_Call): When expanding a call to a function which takes an\n\tExtra_Accessibility_Of_Result parameter, pass in the appropriate\n\tactual parameter value. In the case of a function call which is\n\tused to initialize an allocator, this may not be possible because\n\tthe Etype of the allocator may not have been set yet. In this\n\tcase, we defer passing in the parameter and handle it later in\n\tExpand_Allocator_Expression.\n\t(Expand_Simple_Function_Return): When returning from a function which\n\treturns an unconstrained subtype having at least one access\n\tdiscriminant, generate the accessibility check needed to ensure that\n\tthe function result will not outlive any objects designated by its\n\tdiscriminants.\n\t(Needs_Result_Accessibility_Level): New function; see exp_ch6.ads\n\tdescription.\n\t* exp_ch4.adb (Expand_Allocator_Expression): When a function call\n\tis used to initialize an allocator, we may need to pass in \"the\n\taccessibility level determined by the point of call\" (AI05-0234)\n\tto the function. Expand_Call, where such actual parameters are\n\tusually generated, is too early in this case because the Etype of\n\tthe allocator (which is used in determining the level to be passed\n\tin) may not have been set yet when Expand_Call executes. Instead,\n\twe generate code to pass in the appropriate actual parameter\n\tin Expand_Allocator_Expression.\n\t* sem_ch6.adb (Create_Extra_Formals): Create\n\tthe new Extra_Accessibility_Of_Result formal if\n\tNeeds_Result_Accessibility_Level returns True. This includes the\n\tintroduction of a nested procedure, Check_Against_Result_Level.\n\nFrom-SVN: r178567", "tree": {"sha": "e5fea66ce59258196742bafadb9532e9434b0957", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5fea66ce59258196742bafadb9532e9434b0957"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63585f754c2048b49f8e1607323f8f693e6649bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63585f754c2048b49f8e1607323f8f693e6649bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63585f754c2048b49f8e1607323f8f693e6649bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63585f754c2048b49f8e1607323f8f693e6649bf/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1a982c6e28da20f07b2cf52607936c2f2efee5b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a982c6e28da20f07b2cf52607936c2f2efee5b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a982c6e28da20f07b2cf52607936c2f2efee5b7"}], "stats": {"total": 639, "additions": 618, "deletions": 21}, "files": [{"sha": "f488cd7a39e12cb6433976be3363ecdaec82294e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63585f754c2048b49f8e1607323f8f693e6649bf/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63585f754c2048b49f8e1607323f8f693e6649bf/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=63585f754c2048b49f8e1607323f8f693e6649bf", "patch": "@@ -1,3 +1,60 @@\n+2011-09-06  Steve Baird  <baird@adacore.com>\n+\n+\t* einfo.ads (Extra_Accessibility_Of_Result): New function; in the\n+\t(Ada2012) cases described in AI05-0234 where the accessibility\n+\tlevel of a function result is \"determined by the point of\n+\tcall\", an implicit parameter representing that accessibility\n+\tlevel is passed in. Extra_Accessibilty_Of_Result yields this\n+\tadditional formal parameter. Extra_Accessibility_Of_Result\n+\tis analogous to the existing Extra_Accessibility\n+\tfunction used in the implementation of access parameters.\n+\t(Set_Extra_Accessibility_Of_Result): New procedure; sets\n+\tExtra_Accessibility_Of_Result attribute.\n+\t* einfo.adb (Extra_Accessibility_Of_Result): New function.\n+\t(Set_Extra_Accessibility_Of_Result): New procedure.\n+\t(Write_Field19_Name): Display Extra_Accessibilty_Of_Result attribute.\n+\t* sem_util.adb (Dynamic_Accessibility_Level): Set Etype of\n+\tan accessibility level literal to Natural; introduce a nested\n+\tfunction, Make_Level_Literal, to do this.\n+\t* exp_ch6.ads (Needs_Result_Accessibility_Level): New function;\n+\tdetermines whether a given function (or access-to-function\n+\ttype) needs to have an implicitly-declared accessibility-level\n+\tparameter added to its profile.\n+\t(Add_Extra_Actual_To_Call): Export an existing procedure which was\n+\tpreviously declared in the body of Exp_Ch6.\n+\t* exp_ch6.adb (Add_Extra_Actual_To_Call): Export declaration by moving\n+\tit to exp_ch6.ads.\n+\t(Has_Unconstrained_Access_Discriminants): New Function; a\n+\tpredicate on subtype entities which returns True if the given\n+\tsubtype is unconstrained and has one or more access discriminants.\n+\t(Expand_Call): When expanding a call to a function which takes an\n+\tExtra_Accessibility_Of_Result parameter, pass in the appropriate\n+\tactual parameter value. In the case of a function call which is\n+\tused to initialize an allocator, this may not be possible because\n+\tthe Etype of the allocator may not have been set yet. In this\n+\tcase, we defer passing in the parameter and handle it later in\n+\tExpand_Allocator_Expression.\n+\t(Expand_Simple_Function_Return): When returning from a function which\n+\treturns an unconstrained subtype having at least one access\n+\tdiscriminant, generate the accessibility check needed to ensure that\n+\tthe function result will not outlive any objects designated by its\n+\tdiscriminants.\n+\t(Needs_Result_Accessibility_Level): New function; see exp_ch6.ads\n+\tdescription.\n+\t* exp_ch4.adb (Expand_Allocator_Expression): When a function call\n+\tis used to initialize an allocator, we may need to pass in \"the\n+\taccessibility level determined by the point of call\" (AI05-0234)\n+\tto the function. Expand_Call, where such actual parameters are\n+\tusually generated, is too early in this case because the Etype of\n+\tthe allocator (which is used in determining the level to be passed\n+\tin) may not have been set yet when Expand_Call executes. Instead,\n+\twe generate code to pass in the appropriate actual parameter\n+\tin Expand_Allocator_Expression.\n+\t* sem_ch6.adb (Create_Extra_Formals): Create\n+\tthe new Extra_Accessibility_Of_Result formal if\n+\tNeeds_Result_Accessibility_Level returns True. This includes the\n+\tintroduction of a nested procedure, Check_Against_Result_Level.\n+\n 2011-09-06  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gcc-interface/Makefile.in (X86_TARGET_PAIRS): Remove duplicate"}, {"sha": "8777786082019ae5a9398140ef6c0be2bd47c5e2", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63585f754c2048b49f8e1607323f8f693e6649bf/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63585f754c2048b49f8e1607323f8f693e6649bf/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=63585f754c2048b49f8e1607323f8f693e6649bf", "patch": "@@ -161,6 +161,7 @@ package body Einfo is\n \n    --    Body_Entity                     Node19\n    --    Corresponding_Discriminant      Node19\n+   --    Extra_Accessibility_Of_Result   Node19\n    --    Parent_Subtype                  Node19\n    --    Related_Array_Object            Node19\n    --    Size_Check_Code                 Node19\n@@ -1043,6 +1044,12 @@ package body Einfo is\n       return Node13 (Id);\n    end Extra_Accessibility;\n \n+   function Extra_Accessibility_Of_Result (Id : E) return E is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Function, E_Operator, E_Subprogram_Type));\n+      return Node19 (Id);\n+   end Extra_Accessibility_Of_Result;\n+\n    function Extra_Constrained (Id : E) return E is\n    begin\n       pragma Assert (Is_Formal (Id) or else Ekind (Id) = E_Variable);\n@@ -3519,6 +3526,12 @@ package body Einfo is\n       Set_Node13 (Id, V);\n    end Set_Extra_Accessibility;\n \n+   procedure Set_Extra_Accessibility_Of_Result (Id : E; V : E) is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Function, E_Operator, E_Subprogram_Type));\n+      Set_Node19 (Id, V);\n+   end Set_Extra_Accessibility_Of_Result;\n+\n    procedure Set_Extra_Constrained (Id : E; V : E) is\n    begin\n       pragma Assert (Is_Formal (Id) or else Ekind (Id) = E_Variable);\n@@ -8312,6 +8325,9 @@ package body Einfo is\n          when Private_Kind                                 =>\n             Write_Str (\"Underlying_Full_View\");\n \n+         when E_Function | E_Operator | E_Subprogram_Type =>\n+            Write_Str (\"Extra_Accessibility_Of_Result\");\n+\n          when others                                       =>\n             Write_Str (\"Field19??\");\n       end case;"}, {"sha": "7e8d8196098ac216970ffbf6ce4373a0e22e810a", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63585f754c2048b49f8e1607323f8f693e6649bf/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63585f754c2048b49f8e1607323f8f693e6649bf/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=63585f754c2048b49f8e1607323f8f693e6649bf", "patch": "@@ -1131,6 +1131,15 @@ package Einfo is\n --       must be retrieved through the entity designed by this field instead of\n --       being computed.\n \n+--    Extra_Accessibility_Of_Result (Node19)\n+--       Present in (non-generic) Function, Operator, and Subprogram_Type\n+--       entities if expansion is active. Normally Empty, but if a function is\n+--       one for which \"the accessibility level of the result ... determined\n+--       by the point of call\" (AI05-0234) is needed, then an extra formal of\n+--       subtype Natural is created (see description of field Extra_Formal),\n+--       and the Extra_Accessibility_Of_Result field of the function points to\n+--       the entity for this extra formal.\n+\n --    Extra_Constrained (Node23)\n --       Present in formal parameters in the non-generic case if expansion is\n --       active. Normally Empty, but if a parameter is one for which a dynamic\n@@ -5235,6 +5244,7 @@ package Einfo is\n    --    First_Entity                        (Node17)\n    --    Alias                               (Node18)   (non-generic case only)\n    --    Renamed_Entity                      (Node18)   (generic case only)\n+   --    Extra_Accessibility_Of_Result       (Node19)   (non-generic case only)\n    --    Last_Entity                         (Node20)\n    --    Interface_Name                      (Node21)\n    --    Scope_Depth_Value                   (Uint22)\n@@ -5389,6 +5399,7 @@ package Einfo is\n    --  E_Operator\n    --    First_Entity                        (Node17)\n    --    Alias                               (Node18)\n+   --    Extra_Accessibility_Of_Result       (Node19)\n    --    Last_Entity                         (Node20)\n    --    Overridden_Operation                (Node26)\n    --    Subprograms_For_Type                (Node29)\n@@ -5680,6 +5691,7 @@ package Einfo is\n    --    Scope_Depth                         (synth)\n \n    --  E_Subprogram_Type\n+   --    Extra_Accessibility_Of_Result       (Node19)\n    --    Directly_Designated_Type            (Node20)\n    --    Extra_Formals                       (Node28)\n    --    First_Formal                        (synth)\n@@ -6068,6 +6080,7 @@ package Einfo is\n    function Esize                               (Id : E) return U;\n    function Exception_Code                      (Id : E) return U;\n    function Extra_Accessibility                 (Id : E) return E;\n+   function Extra_Accessibility_Of_Result       (Id : E) return E;\n    function Extra_Constrained                   (Id : E) return E;\n    function Extra_Formal                        (Id : E) return E;\n    function Extra_Formals                       (Id : E) return E;\n@@ -6656,6 +6669,7 @@ package Einfo is\n    procedure Set_Esize                           (Id : E; V : U);\n    procedure Set_Exception_Code                  (Id : E; V : U);\n    procedure Set_Extra_Accessibility             (Id : E; V : E);\n+   procedure Set_Extra_Accessibility_Of_Result   (Id : E; V : E);\n    procedure Set_Extra_Constrained               (Id : E; V : E);\n    procedure Set_Extra_Formal                    (Id : E; V : E);\n    procedure Set_Extra_Formals                   (Id : E; V : E);"}, {"sha": "d018d4c426cd56c2b9181d8b9b308886408fad35", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63585f754c2048b49f8e1607323f8f693e6649bf/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63585f754c2048b49f8e1607323f8f693e6649bf/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=63585f754c2048b49f8e1607323f8f693e6649bf", "patch": "@@ -765,11 +765,38 @@ package body Exp_Ch4 is\n    --  Start of processing for Expand_Allocator_Expression\n \n    begin\n-      --  WOuld be nice to comment the branches of this very long if ???\n+      --  Messy???\n \n-      if Is_Tagged_Type (T)\n-        or else Needs_Finalization (T)\n-      then\n+      --  In the case of an Ada2012 allocator whose initial value comes from a\n+      --  function call, pass \"the accessibility level determined by the point\n+      --  of call\" (AI05-0234) to the function. Conceptually, this belongs in\n+      --  Expand_Call but it couldn't be done there (because the Etype of the\n+      --  allocator wasn't set then) so we generate the parameter here. See\n+      --  the Boolean variable Defer in (a block within) Expand_Call.\n+\n+      if Ada_Version >= Ada_2012 and then Nkind (Exp) = N_Function_Call then\n+         declare\n+            Subp : Entity_Id;\n+\n+         begin\n+            if Nkind (Name (Exp)) = N_Explicit_Dereference then\n+               Subp := Designated_Type (Etype (Prefix (Name (Exp))));\n+            else\n+               Subp := Entity (Name (Exp));\n+            end if;\n+\n+            if Present (Extra_Accessibility_Of_Result (Subp)) then\n+               Add_Extra_Actual_To_Call\n+                 (Subprogram_Call => Exp,\n+                  Extra_Formal    => Extra_Accessibility_Of_Result (Subp),\n+                  Extra_Actual    => Dynamic_Accessibility_Level (PtrT));\n+            end if;\n+         end;\n+      end if;\n+\n+      --  Would be nice to comment the branches of this very long if ???\n+\n+      if Is_Tagged_Type (T) or else Needs_Finalization (T) then\n          if Is_CPP_Constructor_Call (Exp) then\n \n             --  Generate:\n@@ -811,10 +838,10 @@ package body Exp_Ch4 is\n \n                Insert_List_After_And_Analyze (P,\n                  Build_Initialization_Call (Loc,\n-                   Id_Ref =>\n+                   Id_Ref          =>\n                      Make_Explicit_Dereference (Loc,\n                        Prefix => New_Reference_To (Temp, Loc)),\n-                   Typ => Etype (Exp),\n+                   Typ             => Etype (Exp),\n                    Constructor_Ref => Exp));\n             end;\n "}, {"sha": "4e986f70893a0d26ce51b523f77aea1a0f9994ee", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 454, "deletions": 7, "changes": 461, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63585f754c2048b49f8e1607323f8f693e6649bf/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63585f754c2048b49f8e1607323f8f693e6649bf/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=63585f754c2048b49f8e1607323f8f693e6649bf", "patch": "@@ -104,13 +104,6 @@ package body Exp_Ch6 is\n    --  present, then use it, otherwise pass a literal corresponding to the\n    --  Alloc_Form parameter (which must not be Unspecified in that case).\n \n-   procedure Add_Extra_Actual_To_Call\n-     (Subprogram_Call : Node_Id;\n-      Extra_Formal    : Entity_Id;\n-      Extra_Actual    : Node_Id);\n-   --  Adds Extra_Actual as a named parameter association for the formal\n-   --  Extra_Formal in Subprogram_Call.\n-\n    procedure Add_Finalization_Master_Actual_To_Build_In_Place_Call\n      (Func_Call  : Node_Id;\n       Func_Id    : Entity_Id;\n@@ -196,6 +189,11 @@ package body Exp_Ch6 is\n    --  reference to the object itself, and the call becomes a call to the\n    --  corresponding protected subprogram.\n \n+   function Has_Unconstrained_Access_Discriminants\n+     (Subtyp : Entity_Id) return Boolean;\n+   --  Returns True if the given subtype is unconstrained and has one\n+   --  or more access discriminants.\n+\n    procedure Expand_Simple_Function_Return (N : Node_Id);\n    --  Expand simple return from function. In the case where we are returning\n    --  from a function body this is called by Expand_N_Simple_Return_Statement.\n@@ -2751,6 +2749,108 @@ package body Exp_Ch6 is\n          Next_Formal (Formal);\n       end loop;\n \n+      --  If we are calling an Ada2012 function which needs to have the\n+      --  \"accessibility level determined by the point of call\" (AI05-0234)\n+      --  passed in to it, then pass it in.\n+\n+      if Ada_Version >= Ada_2012\n+         and then Ekind_In (Subp, E_Function, E_Operator, E_Subprogram_Type)\n+         and then Present (Extra_Accessibility_Of_Result (Subp))\n+      then\n+         declare\n+            Ancestor : Node_Id := Parent (Call_Node);\n+            Level    : Node_Id := Empty;\n+            Defer    : Boolean := False;\n+\n+         begin\n+            --  Unimplemented: if Subp returns an anonymous access type, then\n+            --    a) if the call is the operand of an explict conversion, then\n+            --       the target type of the conversion (a named access type)\n+            --       determines the accessibility level pass in;\n+            --    b) if the call defines an access discriminant of an object\n+            --       (e.g., the discriminant of an object being created by an\n+            --       allocator, or the discriminant of a function result),\n+            --       then the accessibility level to pass in is that of the\n+            --       discriminated object being initialized).\n+\n+            while Nkind (Ancestor) = N_Qualified_Expression\n+            loop\n+               Ancestor := Parent (Ancestor);\n+            end loop;\n+\n+            case Nkind (Ancestor) is\n+               when N_Allocator =>\n+                  --  Messy.\n+                  --\n+                  --  At this point, we'd like to assign\n+                  --    Level := Dynamic_Accessibility_Level (Ancestor);\n+                  --  but Etype of Ancestor may not have been set yet,\n+                  --  so that doesn't work.\n+                  --  Handle this later in Expand_Allocator_Expression.\n+\n+                  Defer := True;\n+\n+               when N_Object_Declaration | N_Object_Renaming_Declaration =>\n+                  declare\n+                     Def_Id : constant Entity_Id :=\n+                                Defining_Identifier (Ancestor);\n+                  begin\n+                     if Is_Return_Object (Def_Id) then\n+                        if Present (Extra_Accessibility_Of_Result\n+                                     (Return_Applies_To (Scope (Def_Id))))\n+                        then\n+                           --  Pass along value that was passed in if the\n+                           --  routine we are returning from also has an\n+                           --  Accessibility_Of_Result formal.\n+\n+                           Level :=\n+                             New_Occurrence_Of\n+                              (Extra_Accessibility_Of_Result\n+                                 (Return_Applies_To (Scope (Def_Id))), Loc);\n+                        end if;\n+                     else\n+                        Level := Make_Integer_Literal (Loc,\n+                                   Object_Access_Level (Def_Id));\n+                     end if;\n+                  end;\n+\n+               when N_Simple_Return_Statement =>\n+                  if Present (Extra_Accessibility_Of_Result\n+                    (Return_Applies_To (Return_Statement_Entity (Ancestor))))\n+                  then\n+                     --  Pass along value that was passed in if the routine\n+                     --  we are returning from also has an\n+                     --  Accessibility_Of_Result formal.\n+\n+                     Level :=\n+                       New_Occurrence_Of\n+                         (Extra_Accessibility_Of_Result\n+                            (Return_Applies_To\n+                               (Return_Statement_Entity (Ancestor))), Loc);\n+                  end if;\n+\n+               when others =>\n+                  null;\n+            end case;\n+\n+            if not Defer then\n+               if not Present (Level) then\n+                  --  The \"innermost master that evaluates the function call\".\n+                  --\n+                  --  ??? -  Shuld we use Integer'Last here instead\n+                  --  in order to deal with (some of) the problems\n+                  --  associated with calls to subps whose enclosing\n+                  --  scope is unknown (e.g., Anon_Access_To_Subp_Param.all)?\n+\n+                  Level := Make_Integer_Literal (Loc,\n+                             Scope_Depth (Current_Scope) + 1);\n+               end if;\n+\n+               Add_Extra_Actual (Level, Extra_Accessibility_Of_Result (Subp));\n+            end if;\n+         end;\n+      end if;\n+\n       --  If we are expanding a rhs of an assignment we need to check if tag\n       --  propagation is needed. You might expect this processing to be in\n       --  Analyze_Assignment but has to be done earlier (bottom-up) because the\n@@ -6146,6 +6246,31 @@ package body Exp_Ch6 is\n       end if;\n    end Expand_Protected_Subprogram_Call;\n \n+   --------------------------------------------\n+   -- Has_Unconstrained_Access_Discriminants --\n+   --------------------------------------------\n+\n+   function Has_Unconstrained_Access_Discriminants\n+     (Subtyp : Entity_Id) return Boolean\n+   is\n+      Discr : Entity_Id;\n+\n+   begin\n+      if Has_Discriminants (Subtyp)\n+        and then not Is_Constrained (Subtyp)\n+      then\n+         Discr := First_Discriminant (Subtyp);\n+         while Present (Discr) loop\n+            if Ekind (Etype (Discr)) = E_Anonymous_Access_Type then\n+               return True;\n+            end if;\n+\n+            Next_Discriminant (Discr);\n+         end loop;\n+      end if;\n+      return False;\n+   end Has_Unconstrained_Access_Discriminants;\n+\n    -----------------------------------\n    -- Expand_Simple_Function_Return --\n    -----------------------------------\n@@ -6604,6 +6729,216 @@ package body Exp_Ch6 is\n              Suppress  => All_Checks);\n       end if;\n \n+      --  AI05-0234: RM 6.5(21/3). Check access discriminants to\n+      --  ensure that the function result does not outlive an\n+      --  object designated by one of it discriminants.\n+\n+      if Ada_Version >= Ada_2012\n+        and then Has_Unconstrained_Access_Discriminants (R_Type)\n+      then\n+         declare\n+            Discrim_Source : Node_Id := Exp;\n+\n+            procedure Check_Against_Result_Level (Level : Node_Id);\n+            --  Check the given accessibility level against the\n+            --  level determined by the point of call\" (AI05-0234).\n+\n+            --------------------------------\n+            -- Check_Against_Result_Level --\n+            --------------------------------\n+\n+            procedure Check_Against_Result_Level (Level : Node_Id) is\n+            begin\n+               Insert_Action (N,\n+                 Make_Raise_Program_Error (Loc,\n+                   Condition =>\n+                     Make_Op_Gt (Loc,\n+                       Left_Opnd  => Level,\n+                       Right_Opnd =>\n+                         New_Occurrence_Of\n+                           (Extra_Accessibility_Of_Result (Scope_Id), Loc)),\n+                       Reason => PE_Accessibility_Check_Failed));\n+            end Check_Against_Result_Level;\n+         begin\n+            while Nkind (Discrim_Source) = N_Qualified_Expression loop\n+               Discrim_Source := Expression (Discrim_Source);\n+            end loop;\n+\n+            if Nkind (Discrim_Source) = N_Identifier\n+              and then Is_Return_Object (Entity (Discrim_Source))\n+            then\n+\n+               Discrim_Source := Entity (Discrim_Source);\n+\n+               if Is_Constrained (Etype (Discrim_Source)) then\n+                  Discrim_Source := Etype (Discrim_Source);\n+               else\n+                  Discrim_Source := Expression (Parent (Discrim_Source));\n+               end if;\n+\n+            elsif Nkind (Discrim_Source) = N_Identifier\n+              and then Nkind_In (Original_Node (Discrim_Source),\n+                                 N_Aggregate, N_Extension_Aggregate)\n+            then\n+\n+               Discrim_Source := Original_Node (Discrim_Source);\n+\n+            elsif Nkind (Discrim_Source) = N_Explicit_Dereference and then\n+              Nkind (Original_Node (Discrim_Source)) = N_Function_Call\n+            then\n+\n+               Discrim_Source := Original_Node (Discrim_Source);\n+\n+            end if;\n+\n+            while Nkind_In (Discrim_Source, N_Qualified_Expression,\n+                                            N_Type_Conversion,\n+                                            N_Unchecked_Type_Conversion)\n+            loop\n+\n+               Discrim_Source := Expression (Discrim_Source);\n+            end loop;\n+\n+            case Nkind (Discrim_Source) is\n+               when N_Defining_Identifier =>\n+\n+                  pragma Assert (Is_Composite_Type (Discrim_Source) and then\n+                                 Has_Discriminants (Discrim_Source) and then\n+                                 Is_Constrained (Discrim_Source));\n+\n+                  declare\n+                     Discrim   : Entity_Id :=\n+                                   First_Discriminant (Base_Type (R_Type));\n+                     Disc_Elmt : Elmt_Id   :=\n+                                   First_Elmt (Discriminant_Constraint\n+                                                 (Discrim_Source));\n+                  begin\n+                     loop\n+                        if Ekind (Etype (Discrim)) =\n+                          E_Anonymous_Access_Type then\n+\n+                           Check_Against_Result_Level\n+                             (Dynamic_Accessibility_Level (Node (Disc_Elmt)));\n+                        end if;\n+\n+                        Next_Elmt (Disc_Elmt);\n+                        Next_Discriminant (Discrim);\n+                        exit when not Present (Discrim);\n+                     end loop;\n+                  end;\n+\n+               when N_Aggregate | N_Extension_Aggregate =>\n+\n+                  --  Unimplemented: extension aggregate case where\n+                  --  discrims come from ancestor part, not extension part.\n+\n+                  declare\n+                     Discrim  : Entity_Id :=\n+                                  First_Discriminant (Base_Type (R_Type));\n+\n+                     Disc_Exp : Node_Id   := Empty;\n+\n+                     Positionals_Exhausted\n+                              : Boolean   := not Present (Expressions\n+                                                            (Discrim_Source));\n+\n+                     function Associated_Expr\n+                       (Comp_Id : Entity_Id;\n+                        Associations : List_Id) return Node_Id;\n+\n+                     --  Given a component and a component associations list,\n+                     --  locate the expression for that component; returns\n+                     --  Empty if no such expression is found.\n+\n+                     ---------------------\n+                     -- Associated_Expr --\n+                     ---------------------\n+\n+                     function Associated_Expr\n+                       (Comp_Id : Entity_Id;\n+                        Associations : List_Id) return Node_Id\n+                     is\n+                        Assoc  : Node_Id := First (Associations);\n+                        Choice : Node_Id;\n+                     begin\n+                        --  Simple linear search seems ok here\n+\n+                        while Present (Assoc) loop\n+                           Choice := First (Choices (Assoc));\n+\n+                           while Present (Choice) loop\n+                              if (Nkind (Choice) = N_Identifier\n+                                  and then Chars (Choice) = Chars (Comp_Id))\n+                                 or else (Nkind (Choice) = N_Others_Choice)\n+                              then\n+                                 return Expression (Assoc);\n+                              end if;\n+\n+                              Next (Choice);\n+                           end loop;\n+\n+                           Next (Assoc);\n+                        end loop;\n+\n+                        return Empty;\n+                     end Associated_Expr;\n+\n+                  --  Start of processing for Expand_Simple_Function_Return\n+\n+                  begin\n+                     if not Positionals_Exhausted then\n+                        Disc_Exp := First (Expressions (Discrim_Source));\n+                     end if;\n+\n+                     loop\n+                        if Positionals_Exhausted then\n+                           Disc_Exp := Associated_Expr (Discrim,\n+                             Component_Associations (Discrim_Source));\n+                        end if;\n+\n+                        if Ekind (Etype (Discrim)) =\n+                          E_Anonymous_Access_Type then\n+\n+                           Check_Against_Result_Level\n+                             (Dynamic_Accessibility_Level (Disc_Exp));\n+                        end if;\n+\n+                        Next_Discriminant (Discrim);\n+                        exit when not Present (Discrim);\n+\n+                        if not Positionals_Exhausted then\n+                           Next (Disc_Exp);\n+                           Positionals_Exhausted := not Present (Disc_Exp);\n+                        end if;\n+                     end loop;\n+                  end;\n+\n+               when N_Function_Call =>\n+                  --  No check needed; check performed by callee.\n+                  null;\n+\n+               when others =>\n+\n+                  declare\n+                     Level : constant Node_Id :=\n+                        Make_Integer_Literal (Loc,\n+                          Object_Access_Level (Discrim_Source));\n+                  begin\n+                     --  Unimplemented: check for name prefix that includes\n+                     --  a dereference of an access value with a dynamic\n+                     --  accessibility level (e.g., an access param or a\n+                     --  saooaaat) and use dynamic level in that case. For\n+                     --  example:\n+                     --    return Access_Param.all(Some_Index).Some_Component;\n+\n+                     Set_Etype (Level, Standard_Natural);\n+                     Check_Against_Result_Level (Level);\n+                  end;\n+\n+            end case;\n+         end;\n+      end if;\n+\n       --  If we are returning an object that may not be bit-aligned, then copy\n       --  the value into a temporary first. This copy may need to expand to a\n       --  loop of component operations.\n@@ -7923,4 +8258,116 @@ package body Exp_Ch6 is\n       return not Is_Constrained (Func_Typ) or else Is_Tagged_Type (Func_Typ);\n    end Needs_BIP_Alloc_Form;\n \n+   --------------------------------------\n+   -- Needs_Result_Accessibility_Level --\n+   --------------------------------------\n+\n+   function Needs_Result_Accessibility_Level\n+     (Func_Id : Entity_Id) return Boolean\n+   is\n+      Func_Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n+\n+      function Has_Unconstrained_Access_Discriminant_Component\n+        (Comp_Typ :  Entity_Id) return Boolean;\n+      --  Returns True if any component of the type has\n+      --  an unconstrained access discriminant.\n+\n+      -----------------------------------------------------\n+      -- Has_Unconstrained_Access_Discriminant_Component --\n+      -----------------------------------------------------\n+\n+      function Has_Unconstrained_Access_Discriminant_Component\n+        (Comp_Typ :  Entity_Id) return Boolean\n+      is\n+      begin\n+         if not Is_Limited_Type (Comp_Typ) then\n+            return False;\n+            --  Only limited types can have access discriminants with\n+            --  defaults.\n+\n+         elsif Has_Unconstrained_Access_Discriminants (Comp_Typ) then\n+            return True;\n+\n+         elsif Is_Array_Type (Comp_Typ) then\n+            return Has_Unconstrained_Access_Discriminant_Component\n+                     (Underlying_Type (Component_Type (Comp_Typ)));\n+\n+         elsif Is_Record_Type (Comp_Typ) then\n+            declare\n+               Comp : Entity_Id := First_Component (Comp_Typ);\n+            begin\n+               while Present (Comp) loop\n+                  if Has_Unconstrained_Access_Discriminant_Component\n+                       (Underlying_Type (Etype (Comp)))\n+                  then\n+                     return True;\n+                  end if;\n+\n+                  Next_Component (Comp);\n+               end loop;\n+            end;\n+         end if;\n+\n+         return False;\n+      end Has_Unconstrained_Access_Discriminant_Component;\n+\n+   --  Start of processing for Needs_Result_Accessibility_Level\n+\n+   begin\n+      if not Present (Func_Typ) --  ??? completion unavailable\n+\n+        or else Func_Typ = Standard_Void_Type --  not a function\n+\n+        or else Is_Scalar_Type (Func_Typ) --  handle enum-lit renames\n+      then\n+         return False;\n+      end if;\n+\n+      if Present (Alias (Func_Id)) then\n+         --  Handle a corner case, a cross-dialect subp renaming. For example,\n+         --  an Ada2012 renaming of an Ada05 subprogram. This can occur when\n+         --  a non-Ada2012 unit references predefined runtime units.\n+         --\n+         --  Unimplemented: a cross-dialect subp renaming which does not set\n+         --  the Alias attribute (e.g., a rename of a dereference of an access\n+         --  to subprogram value).\n+\n+         return Present (Extra_Accessibility_Of_Result (Alias (Func_Id)));\n+      end if;\n+\n+      if Ada_Version < Ada_2012 then\n+         return False;\n+      end if;\n+\n+      if Ekind (Func_Typ) = E_Anonymous_Access_Type\n+        or else Is_Tagged_Type (Func_Typ)\n+      then\n+         --  In the case of, say, a null tagged record result type, the need\n+         --  for this extra parameter might not be obvious. This function\n+         --  returns True for all tagged types for compatibility reasons.\n+         --  A function with, say, a tagged null controlling result type might\n+         --  be overridden by a primitive of an extension having an access\n+         --  discriminant and the overrider and overridden must have compatible\n+         --  calling conventions (including implicitly declared parameters).\n+         --  Similarly, values of one access-to-subprogram type might designate\n+         --  both a primitive subprogram of a given type and a function\n+         --  which is, for example, not a primitive subprogram of any type.\n+         --  Again, this requires calling convention compatibility.\n+         --  It might be possible to solve these issues by introducing\n+         --  wrappers, but that is not the approach that was chosen.\n+\n+         return True;\n+      end if;\n+\n+      if Has_Unconstrained_Access_Discriminants (Func_Typ) then\n+         return True;\n+      end if;\n+\n+      if Has_Unconstrained_Access_Discriminant_Component (Func_Typ) then\n+         return True;\n+      end if;\n+\n+      return False;\n+   end Needs_Result_Accessibility_Level;\n+\n end Exp_Ch6;"}, {"sha": "06145f525e0336b6b5cbacad2f18599e4de371c3", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63585f754c2048b49f8e1607323f8f693e6649bf/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63585f754c2048b49f8e1607323f8f693e6649bf/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=63585f754c2048b49f8e1607323f8f693e6649bf", "patch": "@@ -205,4 +205,17 @@ package Exp_Ch6 is\n    --  Ada 2005 (AI-318-02): Return True if the function needs an implicit\n    --  BIP_Alloc_Form parameter (see type BIP_Formal_Kind).\n \n+   function Needs_Result_Accessibility_Level\n+     (Func_Id : Entity_Id) return Boolean;\n+   --  Ada 2012 (AI05-0234): Return True if the function needs an implicit\n+   --  parameter to identify the accessibility level of the function result\n+   --  \"determined by the point of call\".\n+\n+   procedure Add_Extra_Actual_To_Call\n+     (Subprogram_Call : Node_Id;\n+      Extra_Formal    : Entity_Id;\n+      Extra_Actual    : Node_Id);\n+   --  Adds Extra_Actual as a named parameter association for the formal\n+   --  Extra_Formal in Subprogram_Call.\n+\n end Exp_Ch6;"}, {"sha": "d82cd72d4887dc3dea11d9e79e0adf9e3638e6b5", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63585f754c2048b49f8e1607323f8f693e6649bf/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63585f754c2048b49f8e1607323f8f693e6649bf/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=63585f754c2048b49f8e1607323f8f693e6649bf", "patch": "@@ -6296,7 +6296,7 @@ package body Sem_Ch6 is\n       --  build-in-place formals are needed in some cases (limited 'Input).\n \n       if Is_Predefined_Internal_Operation (E) then\n-         goto Test_For_BIP_Extras;\n+         goto Test_For_Func_Result_Extras;\n       end if;\n \n       Formal := First_Formal (E);\n@@ -6395,7 +6395,15 @@ package body Sem_Ch6 is\n          Next_Formal (Formal);\n       end loop;\n \n-      <<Test_For_BIP_Extras>>\n+      <<Test_For_Func_Result_Extras>>\n+\n+      --  Ada 2012 (AI05-234): \"the accessibility level of the result of a\n+      --  function call is ... determined by the point of call ...\".\n+\n+      if Needs_Result_Accessibility_Level (E) then\n+         Set_Extra_Accessibility_Of_Result\n+           (E, Add_Extra_Formal (E, Standard_Natural, E, \"L\"));\n+      end if;\n \n       --  Ada 2005 (AI-318-02): In the case of build-in-place functions, add\n       --  appropriate extra formals. See type Exp_Ch6.BIP_Formal_Kind."}, {"sha": "b573ba8ee000f35de7f5a5e660a906c90ccffceb", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63585f754c2048b49f8e1607323f8f693e6649bf/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63585f754c2048b49f8e1607323f8f693e6649bf/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=63585f754c2048b49f8e1607323f8f693e6649bf", "patch": "@@ -2878,6 +2878,22 @@ package body Sem_Util is\n    function Dynamic_Accessibility_Level (Expr : Node_Id) return Node_Id is\n       E : Entity_Id;\n       Loc : constant Source_Ptr := Sloc (Expr);\n+\n+      function Make_Level_Literal (Level : Uint) return Node_Id;\n+      --  Construct an integer literal representing an accessibility level.\n+\n+      ---------------------------------\n+      -- function Make_Level_Literal --\n+      ---------------------------------\n+\n+      function Make_Level_Literal (Level : Uint) return Node_Id is\n+         Result : constant Node_Id :=\n+                    Make_Integer_Literal (Loc, Level);\n+      begin\n+         Set_Etype (Result, Standard_Natural);\n+         return Result;\n+      end Make_Level_Literal;\n+\n    begin\n       if Is_Entity_Name (Expr) then\n          E := Entity (Expr);\n@@ -2903,7 +2919,7 @@ package body Sem_Util is\n               and then Ekind (Etype (Entity (Selector_Name (Expr)))) =\n               E_Anonymous_Access_Type then\n \n-               return Make_Integer_Literal (Loc, Object_Access_Level (Expr));\n+               return Make_Level_Literal (Object_Access_Level (Expr));\n             end if;\n \n          when N_Attribute_Reference =>\n@@ -2912,15 +2928,14 @@ package body Sem_Util is\n                --  For X'Access, the level of the prefix X\n \n                when Attribute_Access =>\n-                  return Make_Integer_Literal (Loc,\n-                    Object_Access_Level (Prefix (Expr)));\n+                  return Make_Level_Literal\n+                           (Object_Access_Level (Prefix (Expr)));\n \n                --  Treat the unchecked attributes as library-level\n \n                when Attribute_Unchecked_Access |\n                  Attribute_Unrestricted_Access =>\n-                  return Make_Integer_Literal (Loc,\n-                    Scope_Depth (Standard_Standard));\n+                  return Make_Level_Literal (Scope_Depth (Standard_Standard));\n \n                --  No other access-valued attributes\n \n@@ -2947,7 +2962,7 @@ package body Sem_Util is\n             null;\n       end case;\n \n-      return Make_Integer_Literal (Loc, Type_Access_Level (Etype (Expr)));\n+      return Make_Level_Literal (Type_Access_Level (Etype (Expr)));\n    end Dynamic_Accessibility_Level;\n \n    -----------------------------------"}]}