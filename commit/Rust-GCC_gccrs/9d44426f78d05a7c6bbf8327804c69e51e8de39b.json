{"sha": "9d44426f78d05a7c6bbf8327804c69e51e8de39b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ0NDQyNmY3OGQwNWE3YzZiYmY4MzI3ODA0YzY5ZTUxZThkZTM5Yg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-10-09T07:46:48Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-10-09T07:46:48Z"}, "message": "re PR fortran/87151 (allocating array of character)\n\n2018-10-09  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/87151\n\t* trans-array.c (gfc_get_array_span): Deal with deferred char\n\tarray components having a TYPE_MAX_VALUE of zero.\n\t(gfc_array_init_size): Use the hidden string length component\n\tto build the descriptor dtype.\n\t(gfc_array_allocate): Remove the erroneous replacement of the\n\tcharlen backend decl with a temporary.\n\t(gfc_conv_expr_descriptor): Use the ss_info string length in\n\tthe case of deferred character components.\n\t(gfc_alloc_allocatable_for_assignment): Actually compare the\n\tstring lengths for deferred characters. Make sure that kind > 1\n\tis handled correctly. Set the span field of the descriptor.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_len): Remove the stupid\n\tcomment.\n\n\tPR fortran/80931\n\t* trans-array.c (gfc_array_allocate): Set the span field for\n\tvariable length character arrays.\n\n\n2018-10-09  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/87151\n\t* gfortran.dg/deferred_type_component_3.f90: New test.\n\n\tPR fortran/80931\n\t* gfortran.dg/deferred_character_28.f90: New test.\n\t* gfortran.dg/deferred_character_29.f90: New test (note that\n\tthis test appears in PR83196 comment #4 by mistake).\n\nFrom-SVN: r264949", "tree": {"sha": "428ac1315816d7c064ff22610d05ceebfdb49bf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/428ac1315816d7c064ff22610d05ceebfdb49bf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d44426f78d05a7c6bbf8327804c69e51e8de39b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d44426f78d05a7c6bbf8327804c69e51e8de39b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d44426f78d05a7c6bbf8327804c69e51e8de39b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d44426f78d05a7c6bbf8327804c69e51e8de39b/comments", "author": null, "committer": null, "parents": [{"sha": "6d5209631367ad74cc31c09a5eae6ac715d2d250", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d5209631367ad74cc31c09a5eae6ac715d2d250", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d5209631367ad74cc31c09a5eae6ac715d2d250"}], "stats": {"total": 450, "additions": 429, "deletions": 21}, "files": [{"sha": "d945e206d5002b30b66756014f9dc0160e0f16a0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d44426f78d05a7c6bbf8327804c69e51e8de39b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d44426f78d05a7c6bbf8327804c69e51e8de39b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9d44426f78d05a7c6bbf8327804c69e51e8de39b", "patch": "@@ -1,3 +1,24 @@\n+2018-10-09  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/87151\n+\t* trans-array.c (gfc_get_array_span): Deal with deferred char\n+\tarray components having a TYPE_MAX_VALUE of zero.\n+\t(gfc_array_init_size): Use the hidden string length component\n+\tto build the descriptor dtype.\n+\t(gfc_array_allocate): Remove the erroneous replacement of the\n+\tcharlen backend decl with a temporary.\n+\t(gfc_conv_expr_descriptor): Use the ss_info string length in\n+\tthe case of deferred character components.\n+\t(gfc_alloc_allocatable_for_assignment): Actually compare the\n+\tstring lengths for deferred characters. Make sure that kind > 1\n+\tis handled correctly. Set the span field of the descriptor.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_len): Remove the stupid\n+\tcomment.\n+\n+\tPR fortran/80931\n+\t* trans-array.c (gfc_array_allocate): Set the span field for\n+\tvariable length character arrays.\n+\n 2018-10-08  Cesar Philippidis  <cesar@codesourcery.com>\n \n \t* expr.c (gfc_check_pointer_assign): Demote \"Assignment to"}, {"sha": "c4df4ebbc408ace58d9d9012a441a5d00fab6c83", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 70, "deletions": 20, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d44426f78d05a7c6bbf8327804c69e51e8de39b/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d44426f78d05a7c6bbf8327804c69e51e8de39b/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=9d44426f78d05a7c6bbf8327804c69e51e8de39b", "patch": "@@ -853,7 +853,8 @@ gfc_get_array_span (tree desc, gfc_expr *expr)\n \t types if possible. Otherwise, return NULL_TREE.  */\n       tmp = gfc_get_element_type (TREE_TYPE (desc));\n       if (tmp && TREE_CODE (tmp) == ARRAY_TYPE\n-\t  && TYPE_MAX_VALUE (TYPE_DOMAIN (tmp)) == NULL_TREE)\n+\t  && (TYPE_MAX_VALUE (TYPE_DOMAIN (tmp)) == NULL_TREE\n+\t      || integer_zerop (TYPE_MAX_VALUE (TYPE_DOMAIN (tmp)))))\n \t{\n \t  if (expr->expr_type == EXPR_VARIABLE\n \t      && expr->ts.type == BT_CHARACTER)\n@@ -5366,6 +5367,28 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n       tmp = gfc_conv_descriptor_dtype (descriptor);\n       gfc_add_modify (pblock, tmp, gfc_get_dtype_rank_type (rank, type));\n     }\n+  else if (expr->ts.type == BT_CHARACTER\n+\t   && expr->ts.deferred\n+\t   && TREE_CODE (descriptor) == COMPONENT_REF)\n+    {\n+      /* Deferred character components have their string length tucked away\n+\t in a hidden field of the derived type. Obtain that and use it to\n+\t set the dtype. The charlen backend decl is zero because the field\n+\t type is zero length.  */\n+      gfc_ref *ref;\n+      tmp = NULL_TREE;\n+      for (ref = expr->ref; ref; ref = ref->next)\n+\tif (ref->type == REF_COMPONENT\n+\t    && gfc_deferred_strlen (ref->u.c.component, &tmp))\n+\t  break;\n+      gcc_assert (tmp != NULL_TREE);\n+      tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (tmp),\n+\t\t\t     TREE_OPERAND (descriptor, 0), tmp, NULL_TREE);\n+      tmp = fold_convert (gfc_charlen_type_node, tmp);\n+      type = gfc_get_character_type_len (expr->ts.kind, tmp);\n+      tmp = gfc_conv_descriptor_dtype (descriptor);\n+      gfc_add_modify (pblock, tmp, gfc_get_dtype_rank_type (rank, type));\n+    }\n   else\n     {\n       tmp = gfc_conv_descriptor_dtype (descriptor);\n@@ -5774,16 +5797,11 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n \n   if (expr->ts.type == BT_CHARACTER\n       && TREE_CODE (se->string_length) == COMPONENT_REF\n-      && expr->ts.u.cl->backend_decl != se->string_length)\n-    {\n-      if (VAR_P (expr->ts.u.cl->backend_decl))\n-\tgfc_add_modify (&se->pre, expr->ts.u.cl->backend_decl,\n-\t\t\tfold_convert (TREE_TYPE (expr->ts.u.cl->backend_decl),\n-\t\t\t\t      se->string_length));\n-      else\n-\texpr->ts.u.cl->backend_decl = gfc_evaluate_now (se->string_length,\n-\t\t\t\t\t\t\t&se->pre);\n-    }\n+      && expr->ts.u.cl->backend_decl != se->string_length\n+      && VAR_P (expr->ts.u.cl->backend_decl))\n+    gfc_add_modify (&se->pre, expr->ts.u.cl->backend_decl,\n+\t\t    fold_convert (TREE_TYPE (expr->ts.u.cl->backend_decl),\n+\t\t\t\t  se->string_length));\n \n   gfc_init_block (&set_descriptor_block);\n   /* Take the corank only from the actual ref and not from the coref.  The\n@@ -5871,17 +5889,19 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   if (dimension)\n     gfc_conv_descriptor_offset_set (&set_descriptor_block, se->expr, offset);\n \n-  /* Pointer arrays need the span field to be set.  */\n-  if (is_pointer_array (se->expr)\n-      || (expr->ts.type == BT_CLASS\n-\t  && CLASS_DATA (expr)->attr.class_pointer)\n+  /* Set the span field for pointer and deferred length character arrays.  */\n+  if ((is_pointer_array (se->expr)\n+       || (expr->ts.type == BT_CLASS && CLASS_DATA (expr)->attr.class_pointer)\n+       || (expr->ts.type == BT_CHARACTER && TREE_CODE (se->string_length)\n+\t\t\t\t\t\t\t== COMPONENT_REF))\n       || (expr->ts.type == BT_CHARACTER\n-\t  && TREE_CODE (se->string_length) == COMPONENT_REF))\n+\t  && (expr->ts.deferred || VAR_P (expr->ts.u.cl->backend_decl))))\n     {\n       if (expr3 && expr3_elem_size != NULL_TREE)\n \ttmp = expr3_elem_size;\n       else if (se->string_length\n-\t       && TREE_CODE (se->string_length) == COMPONENT_REF)\n+\t       && (TREE_CODE (se->string_length) == COMPONENT_REF\n+\t\t   || (expr->ts.type == BT_CHARACTER && expr->ts.deferred)))\n \t{\n \t  if (expr->ts.kind != 1)\n \t    {\n@@ -7053,6 +7073,7 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n   tree offset;\n   int full;\n   bool subref_array_target = false;\n+  bool deferred_array_component = false;\n   gfc_expr *arg, *ss_expr;\n \n   if (se->want_coarray)\n@@ -7092,6 +7113,14 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n       gfc_conv_ss_descriptor (&se->pre, ss, 0);\n       desc = info->descriptor;\n \n+      /* The charlen backend decl for deferred character components cannot\n+\t be used because it is fixed at zero.  Instead, the hidden string\n+\t length component is used.  */\n+      if (expr->ts.type == BT_CHARACTER\n+\t  && expr->ts.deferred\n+\t  && TREE_CODE (desc) == COMPONENT_REF)\n+\tdeferred_array_component = true;\n+\n       subref_array_target = se->direct_byref && is_subref_array (expr);\n       need_tmp = gfc_ref_needs_temporary_p (expr->ref)\n \t\t\t&& !subref_array_target;\n@@ -7140,8 +7169,12 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t      se->expr = desc;\n \t    }\n \n-\t  if (expr->ts.type == BT_CHARACTER)\n+\t  if (expr->ts.type == BT_CHARACTER && !deferred_array_component)\n \t    se->string_length = gfc_get_expr_charlen (expr);\n+\t  /* The ss_info string length is returned set to the value of the\n+\t     hidden string length component.  */\n+\t  else if (deferred_array_component)\n+\t    se->string_length = ss_info->string_length;\n \n \t  gfc_free_ss_chain (ss);\n \t  return;\n@@ -9797,8 +9830,15 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   cond_null = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t array1, build_int_cst (TREE_TYPE (array1), 0));\n \n-  if (expr1->ts.deferred)\n-    cond_null = gfc_evaluate_now (logical_true_node, &fblock);\n+  if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n+    {\n+      tmp = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t     logical_type_node,\n+\t\t\t     lss->info->string_length,\n+\t\t\t     rss->info->string_length);\n+      cond_null = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t\t   logical_type_node, tmp, cond_null);\n+    }\n   else\n     cond_null= gfc_evaluate_now (cond_null, &fblock);\n \n@@ -10024,6 +10064,12 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n \tgfc_add_modify (&fblock, expr1->ts.u.cl->backend_decl, tmp);\n       else\n \tgfc_add_modify (&fblock, lss->info->string_length, tmp);\n+\n+      if (expr1->ts.kind > 1)\n+\ttmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t       TREE_TYPE (tmp),\n+\t\t\t       tmp, build_int_cst (TREE_TYPE (tmp),\n+\t\t\t\t\t\t   expr1->ts.kind));\n     }\n   else if (expr1->ts.type == BT_CHARACTER && expr1->ts.u.cl->backend_decl)\n     {\n@@ -10037,6 +10083,10 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   else\n     tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr1->ts));\n   tmp = fold_convert (gfc_array_index_type, tmp);\n+\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))\n+    gfc_conv_descriptor_span_set (&fblock, desc, tmp);\n+\n   size2 = fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t   gfc_array_index_type,\n \t\t\t   tmp, size2);"}, {"sha": "3bb32b564bc354a24e619b88579392f639b9f3a5", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d44426f78d05a7c6bbf8327804c69e51e8de39b/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d44426f78d05a7c6bbf8327804c69e51e8de39b/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=9d44426f78d05a7c6bbf8327804c69e51e8de39b", "patch": "@@ -6404,7 +6404,6 @@ gfc_conv_intrinsic_len (gfc_se * se, gfc_expr * expr)\n       /* Fall through.  */\n \n     default:\n-      /* Anybody stupid enough to do this deserves inefficient code.  */\n       gfc_init_se (&argse, se);\n       if (arg->rank == 0)\n \tgfc_conv_expr (&argse, arg);"}, {"sha": "6a8605b2c7a94d32c48fda6f60e9ba7f3e73ecc6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d44426f78d05a7c6bbf8327804c69e51e8de39b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d44426f78d05a7c6bbf8327804c69e51e8de39b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9d44426f78d05a7c6bbf8327804c69e51e8de39b", "patch": "@@ -1,3 +1,13 @@\n+2018-10-09  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/87151\n+\t* gfortran.dg/deferred_type_component_3.f90: New test.\n+\n+\tPR fortran/80931\n+\t* gfortran.dg/deferred_character_28.f90: New test.\n+\t* gfortran.dg/deferred_character_29.f90: New test (note that\n+\tthis test appears in PR83196 comment #4 by mistake).\n+\n 2018-10-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.target/i386/vararg-loc.c: Accept a column number."}, {"sha": "6cdf2afd693ed25fb5571cef1d86dab5b8357d19", "filename": "gcc/testsuite/gfortran.dg/deferred_character_28.f90", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d44426f78d05a7c6bbf8327804c69e51e8de39b/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_28.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d44426f78d05a7c6bbf8327804c69e51e8de39b/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_28.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_28.f90?ref=9d44426f78d05a7c6bbf8327804c69e51e8de39b", "patch": "@@ -0,0 +1,60 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR80931, which was nearly fix by the patch for PR87151.\n+! However, the 'span' for 'temp' was not being set and so a segfault\n+! occurred in the assignment at line 39.\n+!\n+! Contributed by Tiziano Mueller  <dev-zero@gentoo.org>\n+!\n+module input_section_types\n+   type :: section\n+      character(len=:), allocatable :: keywords_(:)\n+\n+      contains\n+         procedure, pass :: add_keyword\n+   end type\n+\n+   interface section\n+      procedure constructor\n+   end interface\n+\n+contains\n+\n+   type(section) function constructor ()\n+      allocate (character(len=255) :: constructor%keywords_(0))\n+   end function\n+\n+   subroutine add_keyword (this, name)\n+      class(section), intent(inout) :: this\n+      character(*), intent(in)      :: name\n+      character(len=:), allocatable :: temp(:)\n+\n+      integer :: n_elements\n+\n+      n_elements = size (this%keywords_)\n+      allocate (character(len=255) :: temp(n_elements+1))\n+      temp(:n_elements) = this%keywords_\n+      call move_alloc (temp, this%keywords_)\n+\n+      this%keywords_(n_elements+1) = name\n+   end subroutine\n+end module\n+\n+   use input_section_types\n+   type(section) :: s\n+   character(*), parameter :: hello = \"Hello World\"\n+   character(*), parameter :: bye = \"Goodbye World\"\n+\n+   s = constructor ()\n+\n+   call s%add_keyword (hello)\n+   if (len (s%keywords_) .ne. 255) stop 1\n+   if (size (s%keywords_, 1) .ne. 1) stop 2\n+   if (trim (s%keywords_(1)) .ne. hello) stop 3\n+\n+   call s%add_keyword (bye)\n+   if (len (s%keywords_) .ne. 255) stop 4\n+   if (size (s%keywords_, 1) .ne. 2) stop 5\n+   if (trim (s%keywords_(1)) .ne. hello) stop 6\n+   if (trim (s%keywords_(2)) .ne. bye) stop 7\n+end"}, {"sha": "2d8a4c2d01808005f1b4ab9fa7e61b0fe25d6c45", "filename": "gcc/testsuite/gfortran.dg/deferred_character_29.f90", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d44426f78d05a7c6bbf8327804c69e51e8de39b/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_29.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d44426f78d05a7c6bbf8327804c69e51e8de39b/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_29.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_29.f90?ref=9d44426f78d05a7c6bbf8327804c69e51e8de39b", "patch": "@@ -0,0 +1,197 @@\n+! { dg-do compile }\n+!\n+! Test the fix for PR83196 comment #4 (there by mistake)\n+!\n+! Contributed by Arjen Markus  <arjen.markus895@gmail.com>\n+!____________________________________________________________\n+! keyindex.f90 --\n+!     Class implementing a straightforward keyword/index list\n+!     The idea is to have a very simple implementation to\n+!     store keywords (strings) and return the position in the\n+!     list or vice versa.\n+!____________________________________________________________\n+module keyindices\n+    implicit none\n+\n+    private\n+\n+    integer, parameter                              :: default_keylength = 40\n+\n+    type keyindex\n+        integer                                     :: keylength\n+        integer                                     :: lastindex = 0\n+        character(len=:), dimension(:), allocatable :: keyword\n+    contains\n+        procedure                                   :: init      => init_keyindex\n+        procedure                                   :: get_index => get_index_from_list\n+        procedure                                   :: get_key   => get_keyword_from_list\n+        procedure                                   :: has_key   => has_keyword_in_list\n+    end type keyindex\n+\n+    public :: keyindex\n+contains\n+\n+! init_keyindex --\n+!     Initialise the object\n+!\n+! Arguments:\n+!     this                     Keyindex object\n+!     initial_size             Initial size of the list (optimisation)\n+!     keylength                Maximum length of a keyword (optional)\n+!\n+subroutine init_keyindex( this, initial_size, keylength )\n+    class(keyindex), intent(inout) :: this\n+    integer, intent(in)           :: initial_size\n+    integer, intent(in), optional :: keylength\n+\n+    integer                       :: keylength_\n+\n+    if ( present(keylength) ) then\n+        keylength_ = keylength\n+    else\n+        keylength_ = default_keylength\n+    endif\n+\n+    !\n+    ! Allocate the list of keywords\n+    !\n+    if ( allocated(this%keyword) ) then\n+        deallocate( this%keyword )\n+    endif\n+\n+\n+    allocate( character(len=keylength_):: this%keyword(initial_size) )\n+\n+    this%lastindex = 0\n+    this%keylength = keylength_\n+end subroutine init_keyindex\n+\n+! get_index_from_list --\n+!     Look up the keyword in the list and return its index\n+!\n+! Arguments:\n+!     this                     Keyindex object\n+!     keyword                  Keyword to be looked up\n+!\n+! Returns:\n+!     Index in the list\n+!\n+! Note:\n+!     If the keyword does not yet exist, add it to the list\n+!\n+integer function get_index_from_list( this, keyword )\n+    class(keyindex), intent(inout) :: this\n+    character(len=*), intent(in)  :: keyword\n+\n+    integer                       :: i\n+    character(len=this%keylength), dimension(:), allocatable :: newlist\n+\n+    if ( .not. allocated(this%keyword) ) then\n+        call this%init( 50 )\n+    endif\n+\n+    get_index_from_list = 0\n+\n+    do i = 1,this%lastindex\n+        if ( this%keyword(i) == keyword ) then\n+            get_index_from_list = i\n+            exit\n+        endif\n+    enddo\n+\n+    !\n+    ! Do we need to add it?\n+    !\n+    if ( get_index_from_list == 0 ) then\n+        if ( size(this%keyword) <= this%lastindex ) then\n+            !\n+            ! Allocate a larger list\n+            !\n+            allocate( character(len=this%keylength):: newlist(2*size(this%keyword)) )\n+\n+            newlist(1:size(this%keyword)) = this%keyword\n+            call move_alloc( newlist, this%keyword )\n+        endif\n+\n+        get_index_from_list = this%lastindex + 1\n+        this%lastindex      = get_index_from_list\n+        this%keyword(get_index_from_list) = keyword\n+    endif\n+end function get_index_from_list\n+\n+! get_keyword_from_list --\n+!     Look up the keyword in the list by the given index\n+!\n+! Arguments:\n+!     this                     Keyindex object\n+!     idx                      Index of the keyword\n+!\n+! Returns:\n+!     Keyword as stored in the list\n+!\n+! Note:\n+!     If the index does not exist, an empty string is returned\n+!\n+function get_keyword_from_list( this, idx )\n+    class(keyindex), intent(inout) :: this\n+    integer, intent(in)            :: idx\n+\n+    character(len=this%keylength)  :: get_keyword_from_list\n+\n+    get_keyword_from_list = ' '\n+\n+    if ( idx >= 1 .and. idx <= this%lastindex ) then\n+        get_keyword_from_list = this%keyword(idx)\n+    endif\n+end function get_keyword_from_list\n+\n+! has_keyword_in_list --\n+!     Look up whether the keyword is stored in the list or not\n+!\n+! Arguments:\n+!     this                     Keyindex object\n+!     keyword                  Keyword to be looked up\n+!\n+! Returns:\n+!     True if the keyword is in the list or false if not\n+!\n+logical function has_keyword_in_list( this, keyword )\n+    class(keyindex), intent(inout) :: this\n+    character(len=*), intent(in)  :: keyword\n+\n+    integer                       :: i\n+\n+    has_keyword_in_list = .false.\n+\n+    do i = 1,this%lastindex\n+        if ( this%keyword(i) == keyword ) then\n+            has_keyword_in_list = .true.\n+            exit\n+        endif\n+    enddo\n+end function has_keyword_in_list\n+\n+end module keyindices\n+\n+    use keyindices\n+    type(keyindex) :: idx\n+\n+    call idx%init (3, 8)\n+\n+    if (idx%get_index (\"one\") .ne. 1) stop 1\n+    if (idx%get_index (\"two\") .ne. 2) stop 2\n+    if (idx%get_index (\"three\") .ne. 3) stop 3\n+\n+! Check that new span is generated as list is extended.\n+    if (idx%get_index (\"four\") .ne. 4) stop 4\n+    if (idx%get_index (\"five\") .ne. 5) stop 5\n+    if (idx%get_index (\"six\") .ne. 6) stop 6\n+\n+! Search by keyword\n+    if (.not.idx%has_key (\"four\")) stop 7\n+    if (idx%has_key (\"seven\")) stop 8\n+\n+! Search by index\n+    if (idx%get_key (4) .ne. \"four\") stop 9\n+    if (idx%get_key (10) .ne. \"\") stop 10\n+end\n\\ No newline at end of file"}, {"sha": "ecbb38238063fe9af6d0c7b2ca7da160aa480875", "filename": "gcc/testsuite/gfortran.dg/deferred_type_component_3.f90", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d44426f78d05a7c6bbf8327804c69e51e8de39b/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_type_component_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d44426f78d05a7c6bbf8327804c69e51e8de39b/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_type_component_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_type_component_3.f90?ref=9d44426f78d05a7c6bbf8327804c69e51e8de39b", "patch": "@@ -0,0 +1,71 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR87151 by exercising deferred length character\n+! array components.\n+!\n+! Based on the contribution by Valery Weber <valeryweber@hotmail.com>\n+!\n+module bvec\n+    type, public :: bvec_t\n+     private\n+     character(:), dimension(:), allocatable :: vc\n+   contains\n+     PROCEDURE, PASS :: create\n+     PROCEDURE, PASS :: test_bvec\n+     PROCEDURE, PASS :: delete\n+  end type bvec_t\n+contains\n+  subroutine create (this, switch)\n+    class(bvec_t), intent(inout) :: this\n+    logical :: switch\n+    if (switch) then\n+      allocate (character(2)::this%vc(3))\n+      if (len (this%vc) .ne. 2) stop 1     ! The orignal problem. Gave 0.\n+\n+! Check that reallocation on assign does what it should do as required by\n+! F2003 7.4.1.3. ie. reallocation occurs because LEN has changed.\n+      this%vc = ['abcd','efgh','ijkl']\n+    else\n+      allocate (this%vc, source = ['abcd','efgh','ijkl'])\n+    endif\n+  end subroutine create\n+\n+  subroutine test_bvec (this)\n+    class(bvec_t), intent(inout) :: this\n+    character(20) :: buffer\n+    if (allocated (this%vc)) then\n+      if (len (this%vc) .ne. 4) stop 2\n+      if (size (this%vc) .ne. 3) stop 3\n+! Check array referencing and scalarized array referencing\n+      if (this%vc(2) .ne. 'efgh') stop 4\n+      if (any (this%vc .ne. ['abcd','efgh','ijkl'])) stop 5\n+! Check full array io\n+      write (buffer, *) this%vc\n+      if (trim (buffer(2:)) .ne. 'abcdefghijkl') stop 6\n+! Make sure that substrings work correctly\n+      write (buffer, *) this%vc(:)(2:3)\n+      if (trim (buffer(2:)) .ne. 'bcfgjk') stop 7\n+      write (buffer, *) this%vc(2:)(2:3)\n+      if (trim (buffer(2:)) .ne. 'fgjk') stop 8\n+    endif\n+  end subroutine test_bvec\n+\n+  subroutine delete (this)\n+    class(bvec_t), intent(inout) :: this\n+    if (allocated (this%vc)) then\n+      deallocate (this%vc)\n+    endif\n+  end subroutine delete\n+end module bvec\n+\n+program test\n+  use bvec\n+  type(bvec_t) :: a\n+  call a%create (.false.)\n+  call a%test_bvec\n+  call a%delete\n+\n+  call a%create (.true.)\n+  call a%test_bvec\n+  call a%delete\n+end program test"}]}