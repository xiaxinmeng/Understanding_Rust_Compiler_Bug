{"sha": "2f23fcc9f1b46317c0bb0ad24e60a987f01b3cd5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYyM2ZjYzlmMWI0NjMxN2MwYmIwYWQyNGU2MGE5ODdmMDFiM2NkNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-11-12T19:10:55Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-11-12T19:10:55Z"}, "message": "(qty_compare_1, qty_sugg_compare_1): Use `const void *' arguments.\n\n(QTY_CMP_PRI, QTY_CMP_SUGG): New macros.\n(qty_compare_1, qty_sugg_compare_1): Use them.\n\nFrom-SVN: r13134", "tree": {"sha": "c4b1c71eab9e1991b63fcf57307f203b83aed630", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4b1c71eab9e1991b63fcf57307f203b83aed630"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f23fcc9f1b46317c0bb0ad24e60a987f01b3cd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f23fcc9f1b46317c0bb0ad24e60a987f01b3cd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f23fcc9f1b46317c0bb0ad24e60a987f01b3cd5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f23fcc9f1b46317c0bb0ad24e60a987f01b3cd5/comments", "author": null, "committer": null, "parents": [{"sha": "99edfd16f331979d815ae9de8162a923a6ce58b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99edfd16f331979d815ae9de8162a923a6ce58b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99edfd16f331979d815ae9de8162a923a6ce58b8"}], "stats": {"total": 138, "additions": 49, "deletions": 89}, "files": [{"sha": "ab8f47a2d9c8df604e37186aa114c513b72d0544", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 49, "deletions": 89, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f23fcc9f1b46317c0bb0ad24e60a987f01b3cd5/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f23fcc9f1b46317c0bb0ad24e60a987f01b3cd5/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=2f23fcc9f1b46317c0bb0ad24e60a987f01b3cd5", "patch": "@@ -253,9 +253,9 @@ static void optimize_reg_copy_2\tPROTO((rtx, rtx, rtx));\n static void update_equiv_regs\tPROTO((void));\n static void block_alloc\t\tPROTO((int));\n static int qty_sugg_compare    \tPROTO((int, int));\n-static int qty_sugg_compare_1\tPROTO((int *, int *));\n+static int qty_sugg_compare_1\tPROTO((const GENERIC_PTR, const GENERIC_PTR));\n static int qty_compare    \tPROTO((int, int));\n-static int qty_compare_1\tPROTO((int *, int *));\n+static int qty_compare_1\tPROTO((const GENERIC_PTR, const GENERIC_PTR));\n static int combine_regs\t\tPROTO((rtx, rtx, int, int, rtx, int));\n static int reg_meets_class_p\tPROTO((int, enum reg_class));\n static int reg_classes_overlap_p PROTO((enum reg_class, enum reg_class,\n@@ -1604,51 +1604,37 @@ block_alloc (b)\n    the same algorithm in both local- and global-alloc can speed up execution\n    of some programs by as much as a factor of three!  */\n \n+/* Note that the quotient will never be bigger than\n+   the value of floor_log2 times the maximum number of\n+   times a register can occur in one insn (surely less than 100).\n+   Multiplying this by 10000 can't overflow.\n+   QTY_CMP_PRI is also used by qty_sugg_compare.  */\n+\n+#define QTY_CMP_PRI(q)\t\t\\\n+  ((int) (((double) (floor_log2 (qty_n_refs[q]) * qty_n_refs[q] * qty_size[q]) \\\n+\t  / (qty_death[q] - qty_birth[q])) * 10000))\n+\n static int\n qty_compare (q1, q2)\n      int q1, q2;\n {\n-  /* Note that the quotient will never be bigger than\n-     the value of floor_log2 times the maximum number of\n-     times a register can occur in one insn (surely less than 100).\n-     Multiplying this by 10000 can't overflow.  */\n-  register int pri1\n-    = (((double) (floor_log2 (qty_n_refs[q1]) * qty_n_refs[q1] * qty_size[q1])\n-\t/ (qty_death[q1] - qty_birth[q1]))\n-       * 10000);\n-  register int pri2\n-    = (((double) (floor_log2 (qty_n_refs[q2]) * qty_n_refs[q2] * qty_size[q2])\n-\t/ (qty_death[q2] - qty_birth[q2]))\n-       * 10000);\n-  return pri2 - pri1;\n+  return QTY_CMP_PRI (q2) - QTY_CMP_PRI (q1);\n }\n \n static int\n-qty_compare_1 (q1, q2)\n-     int *q1, *q2;\n+qty_compare_1 (q1p, q2p)\n+     const GENERIC_PTR q1p;\n+     const GENERIC_PTR q2p;\n {\n-  register int tem;\n-\n-  /* Note that the quotient will never be bigger than\n-     the value of floor_log2 times the maximum number of\n-     times a register can occur in one insn (surely less than 100).\n-     Multiplying this by 10000 can't overflow.  */\n-  register int pri1\n-    = (((double) (floor_log2 (qty_n_refs[*q1]) * qty_n_refs[*q1]\n-\t\t  * qty_size[*q1])\n-\t/ (qty_death[*q1] - qty_birth[*q1]))\n-       * 10000);\n-  register int pri2\n-    = (((double) (floor_log2 (qty_n_refs[*q2]) * qty_n_refs[*q2]\n-\t\t  * qty_size[*q2])\n-\t/ (qty_death[*q2] - qty_birth[*q2]))\n-       * 10000);\n-\n-  tem = pri2 - pri1;\n-  if (tem != 0) return tem;\n+  register int q1 = *(int *)q1p, q2 = *(int *)q2p;\n+  register int tem = QTY_CMP_PRI (q2) - QTY_CMP_PRI (q1);\n+\n+  if (tem != 0)\n+    return tem;\n+\n   /* If qtys are equally good, sort by qty number,\n      so that the results of qsort leave nothing to chance.  */\n-  return *q1 - *q2;\n+  return q1 - q2;\n }\n \f\n /* Compare two quantities' priority for getting real registers.  This version\n@@ -1658,71 +1644,45 @@ qty_compare_1 (q1, q2)\n    number of preferences have the highest priority.  Of those, we use the same\n    algorithm as above.  */\n \n+#define QTY_CMP_SUGG(q)\t\t\\\n+  (qty_phys_num_copy_sugg[q]\t\t\\\n+    ? qty_phys_num_copy_sugg[q]\t\\\n+    : qty_phys_num_sugg[q] * FIRST_PSEUDO_REGISTER)\n+\n static int\n qty_sugg_compare (q1, q2)\n      int q1, q2;\n {\n-  register int sugg1 = (qty_phys_num_copy_sugg[q1]\n-\t\t\t? qty_phys_num_copy_sugg[q1]\n-\t\t\t: qty_phys_num_sugg[q1] * FIRST_PSEUDO_REGISTER);\n-  register int sugg2 = (qty_phys_num_copy_sugg[q2]\n-\t\t\t? qty_phys_num_copy_sugg[q2]\n-\t\t\t: qty_phys_num_sugg[q2] * FIRST_PSEUDO_REGISTER);\n-  /* Note that the quotient will never be bigger than\n-     the value of floor_log2 times the maximum number of\n-     times a register can occur in one insn (surely less than 100).\n-     Multiplying this by 10000 can't overflow.  */\n-  register int pri1\n-    = (((double) (floor_log2 (qty_n_refs[q1]) * qty_n_refs[q1] * qty_size[q1])\n-\t/ (qty_death[q1] - qty_birth[q1]))\n-       * 10000);\n-  register int pri2\n-    = (((double) (floor_log2 (qty_n_refs[q2]) * qty_n_refs[q2] * qty_size[q2])\n-\t/ (qty_death[q2] - qty_birth[q2]))\n-       * 10000);\n-\n-  if (sugg1 != sugg2)\n-    return sugg1 - sugg2;\n+  register int tem = QTY_CMP_SUGG (q1) - QTY_CMP_SUGG (q2);\n+\n+  if (tem != 0)\n+    return tem;\n   \n-  return pri2 - pri1;\n+  return QTY_CMP_PRI (q2) - QTY_CMP_PRI (q1);\n }\n \n static int\n-qty_sugg_compare_1 (q1, q2)\n-     int *q1, *q2;\n+qty_sugg_compare_1 (q1p, q2p)\n+     const GENERIC_PTR q1p;\n+     const GENERIC_PTR q2p;\n {\n-  register int sugg1 = (qty_phys_num_copy_sugg[*q1]\n-\t\t\t? qty_phys_num_copy_sugg[*q1]\n-\t\t\t: qty_phys_num_sugg[*q1] * FIRST_PSEUDO_REGISTER);\n-  register int sugg2 = (qty_phys_num_copy_sugg[*q2]\n-\t\t\t? qty_phys_num_copy_sugg[*q2]\n-\t\t\t: qty_phys_num_sugg[*q2] * FIRST_PSEUDO_REGISTER);\n-\n-  /* Note that the quotient will never be bigger than\n-     the value of floor_log2 times the maximum number of\n-     times a register can occur in one insn (surely less than 100).\n-     Multiplying this by 10000 can't overflow.  */\n-  register int pri1\n-    = (((double) (floor_log2 (qty_n_refs[*q1]) * qty_n_refs[*q1]\n-\t\t  * qty_size[*q1])\n-\t/ (qty_death[*q1] - qty_birth[*q1]))\n-       * 10000);\n-  register int pri2\n-    = (((double) (floor_log2 (qty_n_refs[*q2]) * qty_n_refs[*q2]\n-\t\t  * qty_size[*q2])\n-\t/ (qty_death[*q2] - qty_birth[*q2]))\n-       * 10000);\n-\n-  if (sugg1 != sugg2)\n-    return sugg1 - sugg2;\n-  \n-  if (pri1 != pri2)\n-    return pri2 - pri1;\n+  register int q1 = *(int *)q1p, q2 = *(int *)q2p;\n+  register int tem = QTY_CMP_SUGG (q1) - QTY_CMP_SUGG (q2);\n+\n+  if (tem != 0)\n+    return tem;\n+\n+  tem = QTY_CMP_PRI (q2) - QTY_CMP_PRI (q1);\n+  if (tem != 0)\n+    return tem;\n \n   /* If qtys are equally good, sort by qty number,\n      so that the results of qsort leave nothing to chance.  */\n-  return *q1 - *q2;\n+  return q1 - q2;\n }\n+\n+#undef QTY_CMP_SUGG\n+#undef QTY_CMP_PRI\n \f\n /* Attempt to combine the two registers (rtx's) USEDREG and SETREG.\n    Returns 1 if have done so, or 0 if cannot."}]}