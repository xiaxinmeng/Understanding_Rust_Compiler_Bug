{"sha": "e0403e95689af7d562c7d04f706e9e25115747ff", "node_id": "C_kwDOANBUbNoAKGUwNDAzZTk1Njg5YWY3ZDU2MmM3ZDA0ZjcwNmU5ZTI1MTE1NzQ3ZmY", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-10-18T12:14:26Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-10-18T12:14:26Z"}, "message": "ipa-cp: Better representation of aggregate values we clone for\n\nThis patch replaces linked lists of ipa_agg_replacement_value with\nvectors of similar structures called ipa_argagg_value and simplifies\nhow we compute them in the first place.  Having a vector should also\nresult in less overhead when allocating and because we keep it sorted,\nit leads to logarithmic searches.\n\nThe slightly obnoxious \"argagg\" bit in the name can be changed into\n\"agg\" after the next patch removes our current ipa_agg_value type.\n\nThe patch also introduces type ipa_argagg_value_list which serves as a\ncommon view into a vector of ipa_argagg_value structures regardless\nwhether they are stored in GC memory (required for IPA-CP\ntransformation summary because we store trees) or in an auto_vec which\nis hopefully usually only allocated on stack.\n\nThe calculation of aggreagete costant values for a given subsert of\ncallers is then rewritten to compute known constants for each\nedge (some pruning to skip obviously not needed is still employed and\nshould not be really worse than what I am replacing) and these vectors\nare there intersected, which can be done linearly since they are\nsorted.  The patch also removes a lot of heap allocations of small\nlists of aggregate values and replaces them with stack based\nauto_vecs.\n\nAs Richard Sandiford suggested, I use std::lower_bound from\n<algorithm> rather than re-implementing bsearch for array_slice.  The\npatch depends on the patch which adds the ability to construct\narray_slices from gc-allocated vectors.\n\ngcc/ChangeLog:\n\n2022-10-17  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (IPA_PROP_ARG_INDEX_LIMIT_BITS): New.\n\t(ipcp_transformation): Added forward declaration.\n\t(ipa_argagg_value): New type.\n\t(ipa_argagg_value_list): New type.\n\t(ipa_agg_replacement_value): Removed type.\n\t(ipcp_transformation): Switch from using ipa_agg_replacement_value\n\tto ipa_argagg_value_list.\n\t(ipa_get_agg_replacements_for_node): Removed.\n\t(ipa_dump_agg_replacement_values): Removed declaration.\n\t* ipa-cp.cc: Define INCLUDE_ALGORITHM.\n\t(values_equal_for_ipcp_p): Moved up in the file.\n\t(ipa_argagg_value_list::dump): New function.\n\t(ipa_argagg_value_list::debug): Likewise.\n\t(ipa_argagg_value_list::get_elt): Likewise.\n\t(ipa_argagg_value_list::get_elt_for_index): Likewise.\n\t(ipa_argagg_value_list::get_value): New overloaded functions.\n\t(ipa_argagg_value_list::superset_of_p): New function.\n\t(new ipa_argagg_value_list::push_adjusted_values): Likewise.\n\t(push_agg_values_from_plats): Likewise.\n\t(intersect_argaggs_with): Likewise.\n\t(get_clone_agg_value): Removed.\n\t(ipa_agg_value_from_node): Make last parameter const, use\n\tipa_argagg_value_list to search values coming from clones.\n\t(ipa_get_indirect_edge_target_1): Use ipa_argagg_value_list to search\n\tvalues coming from clones.\n\t(ipcp_discover_new_direct_edges): Pass around a vector of\n\tipa_argagg_values rather than a link list of replacement values.\n\t(cgraph_edge_brings_value_p): Use ipa_argagg_value_list to search\n\tvalues coming from clones.\n\t(create_specialized_node): Work with a vector of ipa_argagg_values\n\trather than a link list of replacement values.\n\t(self_recursive_agg_pass_through_p): Make the pointer parameters\n\tconst.\n\t(copy_plats_to_inter): Removed.\n\t(intersect_with_plats): Likewise.\n\t(agg_replacements_to_vector): Likewise.\n\t(intersect_with_agg_replacements): Likewise.\n\t(intersect_aggregates_with_edge): Likewise.\n\t(push_agg_values_for_index_from_edge): Likewise.\n\t(push_agg_values_from_edge): Likewise.\n\t(find_aggregate_values_for_callers_subset): Rewrite.\n\t(cgraph_edge_brings_all_agg_vals_for_node): Likewise.\n\t(ipcp_val_agg_replacement_ok_p): Use ipa_argagg_value_list to search\n\taggregate values.\n\t(decide_about_value): Work with a vector of ipa_argagg_values rather\n\tthan a link list of replacement values.\n\t(decide_whether_version_node): Likewise.\n\t(ipa_analyze_node): Check number of parameters, assert that there\n\tare no descriptors when bailing out.\n\t* ipa-prop.cc (ipa_set_node_agg_value_chain): Switch to a vector of\n\tipa_argagg_value.\n\t(ipa_node_params_t::duplicate): Removed superfluous handling of\n\tipa_agg_replacement_values.  Name of src parameter removed because\n\tit is no longer used.\n\t(ipcp_transformation_t::duplicate): Replaced duplication of\n\tipa_agg_replacement_values with copying vector m_agg_values.\n\t(ipa_dump_agg_replacement_values): Removed.\n\t(write_ipcp_transformation_info): Stream the new data-structure\n\tinstead of the old.\n\t(read_ipcp_transformation_info): Likewise.\n\t(adjust_agg_replacement_values): Work with ipa_argagg_values instead\n\tof linked lists of ipa_agg_replacement_values, copy the items and\n\ttruncate the vector as necessary to keep it sorted instead of marking\n\titems as invalid.  Return one bool if CFG should be updated.\n\t(ipcp_modif_dom_walker): Store ipcp_transformation instead of\n\tlinked list of ipa_agg_replacement_values.\n\t(ipcp_modif_dom_walker::before_dom_children): Use\n\tipa_argagg_value_list instead of walking a list of\n\tipa_agg_replacement_values.\n\t(ipcp_transform_function): Switch to the new data structure, adjust\n\tdumping.\n\ngcc/testsuite/ChangeLog:\n\n2022-08-15  Martin Jambor  <mjambor@suse.cz>\n\n\t* gcc.dg/ipa/ipcp-agg-11.c: Adjust dumps.\n\t* gcc.dg/ipa/ipcp-agg-8.c: Likewise.", "tree": {"sha": "fad49359c1b7158e875a3113b06ac9f1ba8f02e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fad49359c1b7158e875a3113b06ac9f1ba8f02e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0403e95689af7d562c7d04f706e9e25115747ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0403e95689af7d562c7d04f706e9e25115747ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0403e95689af7d562c7d04f706e9e25115747ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0403e95689af7d562c7d04f706e9e25115747ff/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e73fe9e162af7b875a54cd78ddbb6bf26d8b06c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e73fe9e162af7b875a54cd78ddbb6bf26d8b06c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e73fe9e162af7b875a54cd78ddbb6bf26d8b06c2"}], "stats": {"total": 1399, "additions": 733, "deletions": 666}, "files": [{"sha": "530733515e6df8336a1d6371993018522811a01d", "filename": "gcc/ipa-cp.cc", "status": "modified", "additions": 510, "deletions": 482, "changes": 992, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0403e95689af7d562c7d04f706e9e25115747ff/gcc%2Fipa-cp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0403e95689af7d562c7d04f706e9e25115747ff/gcc%2Fipa-cp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.cc?ref=e0403e95689af7d562c7d04f706e9e25115747ff", "patch": "@@ -100,6 +100,7 @@ along with GCC; see the file COPYING3.  If not see\n    and tree-inline.cc) according to instructions inserted to the call graph by\n    the second stage.  */\n \n+#define INCLUDE_ALGORITHM\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -455,6 +456,26 @@ ipcp_lattice<valtype>::is_single_const ()\n     return true;\n }\n \n+/* Return true iff X and Y should be considered equal values by IPA-CP.  */\n+\n+static bool\n+values_equal_for_ipcp_p (tree x, tree y)\n+{\n+  gcc_checking_assert (x != NULL_TREE && y != NULL_TREE);\n+\n+  if (x == y)\n+    return true;\n+\n+  if (TREE_CODE (x) == ADDR_EXPR\n+      && TREE_CODE (y) == ADDR_EXPR\n+      && TREE_CODE (TREE_OPERAND (x, 0)) == CONST_DECL\n+      && TREE_CODE (TREE_OPERAND (y, 0)) == CONST_DECL)\n+    return operand_equal_p (DECL_INITIAL (TREE_OPERAND (x, 0)),\n+\t\t\t    DECL_INITIAL (TREE_OPERAND (y, 0)), 0);\n+  else\n+    return operand_equal_p (x, y, 0);\n+}\n+\n /* Print V which is extracted from a value in a lattice to F.  */\n \n static void\n@@ -1217,6 +1238,274 @@ ipcp_bits_lattice::meet_with (ipcp_bits_lattice& other, unsigned precision,\n \t\t\tdrop_all_ones);\n }\n \n+/* Dump the contents of the list to FILE.  */\n+\n+void\n+ipa_argagg_value_list::dump (FILE *f)\n+{\n+  bool comma = false;\n+  for (const ipa_argagg_value &av : m_elts)\n+    {\n+      fprintf (f, \"%s %i[%u]=\", comma ? \",\" : \"\",\n+\t       av.index, av.unit_offset);\n+      print_generic_expr (f, av.value);\n+      if (av.by_ref)\n+\tfprintf (f, \"(by_ref)\");\n+      comma = true;\n+    }\n+  fprintf (f, \"\\n\");\n+}\n+\n+/* Dump the contents of the list to stderr.  */\n+\n+void\n+ipa_argagg_value_list::debug ()\n+{\n+  dump (stderr);\n+}\n+\n+/* Return the item describing a constant stored for INDEX at UNIT_OFFSET or\n+   NULL if there is no such constant.  */\n+\n+const ipa_argagg_value *\n+ipa_argagg_value_list::get_elt (int index, unsigned unit_offset) const\n+{\n+  ipa_argagg_value key;\n+  key.index = index;\n+  key.unit_offset = unit_offset;\n+  const ipa_argagg_value *res\n+    = std::lower_bound (m_elts.begin (), m_elts.end (), key,\n+\t\t\t[] (const ipa_argagg_value &elt,\n+\t\t\t    const ipa_argagg_value &val)\n+\t\t\t{\n+\t\t\t  if (elt.index < val.index)\n+\t\t\t    return true;\n+\t\t\t  if (elt.index > val.index)\n+\t\t\t    return false;\n+\t\t\t  if (elt.unit_offset < val.unit_offset)\n+\t\t\t    return true;\n+\t\t\t  return false;\n+\t\t\t});\n+\n+  if (res == m_elts.end ()\n+      || res->index != index\n+      || res->unit_offset != unit_offset)\n+    res = nullptr;\n+\n+  /* TODO: perhaps remove the check (that the underlying array is indeed\n+     sorted) if it turns out it can be too slow? */\n+  if (!flag_checking)\n+    return res;\n+\n+  const ipa_argagg_value *slow_res = NULL;\n+  int prev_index = -1;\n+  unsigned prev_unit_offset = 0;\n+  for (const ipa_argagg_value &av : m_elts)\n+    {\n+      gcc_assert (prev_index < 0\n+\t\t  || prev_index < av.index\n+\t\t  || prev_unit_offset < av.unit_offset);\n+      prev_index = av.index;\n+      prev_unit_offset = av.unit_offset;\n+      if (av.index == index\n+\t  && av.unit_offset == unit_offset)\n+\tslow_res = &av;\n+    }\n+  gcc_assert (res == slow_res);\n+\n+  return res;\n+}\n+\n+/* Return the first item describing a constant stored for parameter with INDEX,\n+   regardless of offset or reference, or NULL if there is no such constant.  */\n+\n+const ipa_argagg_value *\n+ipa_argagg_value_list::get_elt_for_index (int index) const\n+{\n+  const ipa_argagg_value *res\n+    = std::lower_bound (m_elts.begin (), m_elts.end (), index,\n+\t\t\t[] (const ipa_argagg_value &elt, unsigned idx)\n+\t\t\t{\n+\t\t\t  return elt.index < idx;\n+\t\t\t});\n+  if (res == m_elts.end ()\n+      || res->index != index)\n+    res = nullptr;\n+  return res;\n+}\n+\n+/* Return the aggregate constant stored for INDEX at UNIT_OFFSET, not\n+   performing any check of whether value is passed by reference, or NULL_TREE\n+   if there is no such constant.  */\n+\n+tree\n+ipa_argagg_value_list::get_value (int index, unsigned unit_offset) const\n+{\n+  const ipa_argagg_value *av = get_elt (index, unit_offset);\n+  return av ? av->value : NULL_TREE;\n+}\n+\n+/* Return the aggregate constant stored for INDEX at UNIT_OFFSET, if it is\n+   passed by reference or not according to BY_REF, or NULL_TREE if there is\n+   no such constant.  */\n+\n+tree\n+ipa_argagg_value_list::get_value (int index, unsigned unit_offset,\n+\t\t\t\t    bool by_ref) const\n+{\n+  const ipa_argagg_value *av = get_elt (index, unit_offset);\n+  if (av && av->by_ref == by_ref)\n+    return av->value;\n+  return NULL_TREE;\n+}\n+\n+/* Return true if all elements present in OTHER are also present in this\n+   list.  */\n+\n+bool\n+ipa_argagg_value_list::superset_of_p (const ipa_argagg_value_list &other) const\n+{\n+  unsigned j = 0;\n+  for (unsigned i = 0; i < other.m_elts.size (); i++)\n+    {\n+      unsigned other_index = other.m_elts[i].index;\n+      unsigned other_offset = other.m_elts[i].unit_offset;\n+\n+      while (j < m_elts.size ()\n+\t     && (m_elts[j].index < other_index\n+\t\t || (m_elts[j].index == other_index\n+\t\t     && m_elts[j].unit_offset < other_offset)))\n+       j++;\n+\n+      if (j >= m_elts.size ()\n+\t  || m_elts[j].index != other_index\n+\t  || m_elts[j].unit_offset != other_offset\n+\t  || m_elts[j].by_ref != other.m_elts[i].by_ref\n+\t  || !m_elts[j].value\n+\t  || !values_equal_for_ipcp_p (m_elts[j].value, other.m_elts[i].value))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Push all items in this list that describe parameter SRC_INDEX into RES as\n+   ones describing DST_INDEX while subtracting UNIT_DELTA from their unit\n+   offsets but skip those which would end up with a negative offset.  */\n+\n+void\n+ipa_argagg_value_list::push_adjusted_values (unsigned src_index,\n+\t\t\t\t\t     unsigned dest_index,\n+\t\t\t\t\t     unsigned unit_delta,\n+\t\t\t\t\t     vec<ipa_argagg_value> *res) const\n+{\n+  const ipa_argagg_value *av = get_elt_for_index (src_index);\n+  if (!av)\n+    return;\n+  unsigned prev_unit_offset = 0;\n+  bool first = true;\n+  for (; av < m_elts.end (); ++av)\n+    {\n+      if (av->index > src_index)\n+\treturn;\n+      if (av->index == src_index\n+\t  && (av->unit_offset >= unit_delta)\n+\t  && av->value)\n+\t{\n+\t  ipa_argagg_value new_av;\n+\t  gcc_checking_assert (av->value);\n+\t  new_av.value = av->value;\n+\t  new_av.unit_offset = av->unit_offset - unit_delta;\n+\t  new_av.index = dest_index;\n+\t  new_av.by_ref = av->by_ref;\n+\n+\t  /* Quick check that the offsets we push are indeed increasing.  */\n+\t  gcc_assert (first\n+\t\t      || new_av.unit_offset > prev_unit_offset);\n+\t  prev_unit_offset = new_av.unit_offset;\n+\t  first = false;\n+\n+\t  res->safe_push (new_av);\n+\t}\n+    }\n+}\n+\n+/* Push to RES information about single lattices describing aggregate values in\n+   PLATS as those describing parameter DEST_INDEX and the original offset minus\n+   UNIT_DELTA.  Return true if any item has been pushed to RES.  */\n+\n+static bool\n+push_agg_values_from_plats (ipcp_param_lattices *plats, int dest_index,\n+\t\t\t    unsigned unit_delta,\n+\t\t\t    vec<ipa_argagg_value> *res)\n+{\n+  if (plats->aggs_contain_variable)\n+    return false;\n+\n+  bool pushed_sth = false;\n+  bool first = true;\n+  unsigned prev_unit_offset = 0;\n+  for (struct ipcp_agg_lattice *aglat = plats->aggs; aglat; aglat = aglat->next)\n+    if (aglat->is_single_const ()\n+\t&& (aglat->offset / BITS_PER_UNIT - unit_delta) >= 0)\n+      {\n+\tipa_argagg_value iav;\n+\tiav.value = aglat->values->value;\n+\tiav.unit_offset = aglat->offset / BITS_PER_UNIT - unit_delta;\n+\tiav.index = dest_index;\n+\tiav.by_ref = plats->aggs_by_ref;\n+\n+\tgcc_assert (first\n+\t\t    || iav.unit_offset > prev_unit_offset);\n+\tprev_unit_offset = iav.unit_offset;\n+\tfirst = false;\n+\n+\tpushed_sth = true;\n+\tres->safe_push (iav);\n+      }\n+  return pushed_sth;\n+}\n+\n+/* Turn all values in LIST that are not present in OTHER into NULL_TREEs.\n+   Return the number of remaining valid entries.  */\n+\n+static unsigned\n+intersect_argaggs_with (vec<ipa_argagg_value> &elts,\n+\t\t\tconst vec<ipa_argagg_value> &other)\n+{\n+  unsigned valid_entries = 0;\n+  unsigned j = 0;\n+  for (unsigned i = 0; i < elts.length (); i++)\n+    {\n+      if (!elts[i].value)\n+\tcontinue;\n+\n+      unsigned this_index = elts[i].index;\n+      unsigned this_offset = elts[i].unit_offset;\n+\n+      while (j < other.length ()\n+\t     && (other[j].index < this_index\n+\t\t || (other[j].index == this_index\n+\t\t     && other[j].unit_offset < this_offset)))\n+\tj++;\n+\n+      if (j >= other.length ())\n+\t{\n+\t  elts[i].value = NULL_TREE;\n+\t  continue;\n+\t}\n+\n+      if (other[j].index == this_index\n+\t  && other[j].unit_offset == this_offset\n+\t  && other[j].by_ref == elts[i].by_ref\n+\t  && other[j].value\n+\t  && values_equal_for_ipcp_p (other[j].value, elts[i].value))\n+\tvalid_entries++;\n+      else\n+\telts[i].value = NULL_TREE;\n+    }\n+  return valid_entries;\n+}\n+\n /* Mark bot aggregate and scalar lattices as containing an unknown variable,\n    return true is any of them has not been marked as such so far.  */\n \n@@ -1401,26 +1690,6 @@ ipacp_value_safe_for_type (tree param_type, tree value)\n     return false;\n }\n \n-/* Return true iff X and Y should be considered equal values by IPA-CP.  */\n-\n-static bool\n-values_equal_for_ipcp_p (tree x, tree y)\n-{\n-  gcc_checking_assert (x != NULL_TREE && y != NULL_TREE);\n-\n-  if (x == y)\n-    return true;\n-\n-  if (TREE_CODE (x) == ADDR_EXPR\n-      && TREE_CODE (y) == ADDR_EXPR\n-      && TREE_CODE (TREE_OPERAND (x, 0)) == CONST_DECL\n-      && TREE_CODE (TREE_OPERAND (y, 0)) == CONST_DECL)\n-    return operand_equal_p (DECL_INITIAL (TREE_OPERAND (x, 0)),\n-\t\t\t    DECL_INITIAL (TREE_OPERAND (y, 0)), 0);\n-  else\n-    return operand_equal_p (x, y, 0);\n-}\n-\n /* Return the result of a (possibly arithmetic) operation on the constant\n    value INPUT.  OPERAND is 2nd operand for binary operation.  RES_TYPE is\n    the type of the parameter to which the result is passed.  Return\n@@ -1701,26 +1970,6 @@ ipa_value_range_from_jfunc (ipa_node_params *info, cgraph_edge *cs,\n   return vr;\n }\n \n-/* See if NODE is a clone with a known aggregate value at a given OFFSET of a\n-   parameter with the given INDEX.  */\n-\n-static tree\n-get_clone_agg_value (struct cgraph_node *node, HOST_WIDE_INT offset,\n-\t\t     int index)\n-{\n-  struct ipa_agg_replacement_value *aggval;\n-\n-  aggval = ipa_get_agg_replacements_for_node (node);\n-  while (aggval)\n-    {\n-      if (aggval->offset == offset\n-\t  && aggval->index == index)\n-\treturn aggval->value;\n-      aggval = aggval->next;\n-    }\n-  return NULL_TREE;\n-}\n-\n /* Determine whether ITEM, jump function for an aggregate part, evaluates to a\n    single known constant value and if so, return it.  Otherwise return NULL.\n    NODE and INFO describes the caller node or the one it is inlined to, and\n@@ -1729,7 +1978,7 @@ get_clone_agg_value (struct cgraph_node *node, HOST_WIDE_INT offset,\n static tree\n ipa_agg_value_from_node (class ipa_node_params *info,\n \t\t\t struct cgraph_node *node,\n-\t\t\t struct ipa_agg_jf_item *item)\n+\t\t\t const ipa_agg_jf_item *item)\n {\n   tree value = NULL_TREE;\n   int src_idx;\n@@ -1749,9 +1998,13 @@ ipa_agg_value_from_node (class ipa_node_params *info,\n     {\n       if (item->jftype == IPA_JF_PASS_THROUGH)\n \tvalue = info->known_csts[src_idx];\n-      else\n-\tvalue = get_clone_agg_value (node, item->value.load_agg.offset,\n-\t\t\t\t     src_idx);\n+      else if (ipcp_transformation *ts = ipcp_get_transformation_summary (node))\n+\t{\n+\t  ipa_argagg_value_list avl (ts);\n+\t  value = avl.get_value (src_idx,\n+\t\t\t\t item->value.load_agg.offset / BITS_PER_UNIT,\n+\t\t\t\t item->value.load_agg.by_ref);\n+\t}\n     }\n   else if (info->lattices)\n     {\n@@ -2979,15 +3232,16 @@ propagate_constants_across_call (struct cgraph_edge *cs)\n }\n \n /* If an indirect edge IE can be turned into a direct one based on KNOWN_VALS\n-   KNOWN_CONTEXTS, KNOWN_AGGS or AGG_REPS return the destination.  The latter\n-   three can be NULL.  If AGG_REPS is not NULL, KNOWN_AGGS is ignored.  */\n+   KNOWN_CONTEXTS, and known aggregates either in AVS or KNOWN_AGGS return\n+   the destination.  The latter three can be NULL.  If AGG_REPS is not NULL,\n+   KNOWN_AGGS is ignored.  */\n \n static tree\n ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n \t\t\t\tconst vec<tree> &known_csts,\n \t\t\t\tconst vec<ipa_polymorphic_call_context> &known_contexts,\n \t\t\t\tconst vec<ipa_agg_value_set> &known_aggs,\n-\t\t\t\tstruct ipa_agg_replacement_value *agg_reps,\n+\t\t\t\tconst ipa_argagg_value_list *avs,\n \t\t\t\tbool *speculative)\n {\n   int param_index = ie->indirect_info->param_index;\n@@ -3007,20 +3261,10 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n       if (ie->indirect_info->agg_contents)\n \t{\n \t  t = NULL;\n-\t  if (agg_reps && ie->indirect_info->guaranteed_unmodified)\n-\t    {\n-\t      while (agg_reps)\n-\t\t{\n-\t\t  if (agg_reps->index == param_index\n-\t\t      && agg_reps->offset == ie->indirect_info->offset\n-\t\t      && agg_reps->by_ref == ie->indirect_info->by_ref)\n-\t\t    {\n-\t\t      t = agg_reps->value;\n-\t\t      break;\n-\t\t    }\n-\t\t  agg_reps = agg_reps->next;\n-\t\t}\n-\t    }\n+\t  if (avs && ie->indirect_info->guaranteed_unmodified)\n+\t    t = avs->get_value (param_index,\n+\t\t\t\tie->indirect_info->offset / BITS_PER_UNIT,\n+\t\t\t\tie->indirect_info->by_ref);\n \t  if (!t)\n \t    {\n \t      const ipa_agg_value_set *agg;\n@@ -3063,20 +3307,10 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n   t = NULL;\n \n   /* Try to work out value of virtual table pointer value in replacements.  */\n-  if (!t && agg_reps && !ie->indirect_info->by_ref)\n-    {\n-      while (agg_reps)\n-\t{\n-\t  if (agg_reps->index == param_index\n-\t      && agg_reps->offset == ie->indirect_info->offset\n-\t      && agg_reps->by_ref)\n-\t    {\n-\t      t = agg_reps->value;\n-\t      break;\n-\t    }\n-\t  agg_reps = agg_reps->next;\n-\t}\n-    }\n+  if (!t && avs && !ie->indirect_info->by_ref)\n+    t = avs->get_value (param_index,\n+\t\t\tie->indirect_info->offset / BITS_PER_UNIT,\n+\t\t\ttrue);\n \n   /* Try to work out value of virtual table pointer value in known\n      aggregate values.  */\n@@ -4103,7 +4337,7 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n \t\t\t\tvec<tree> known_csts,\n \t\t\t\tvec<ipa_polymorphic_call_context>\n \t\t\t\tknown_contexts,\n-\t\t\t\tstruct ipa_agg_replacement_value *aggvals)\n+\t\t\t\tvec<ipa_argagg_value, va_gc> *aggvals)\n {\n   struct cgraph_edge *ie, *next_ie;\n   bool found = false;\n@@ -4114,8 +4348,9 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n       bool speculative;\n \n       next_ie = ie->next_callee;\n+      ipa_argagg_value_list avs (aggvals);\n       target = ipa_get_indirect_edge_target_1 (ie, known_csts, known_contexts,\n-\t\t\t\t\t       vNULL, aggvals, &speculative);\n+\t\t\t\t\t       vNULL, &avs, &speculative);\n       if (target)\n \t{\n \t  bool agg_contents = ie->indirect_info->agg_contents;\n@@ -4249,11 +4484,15 @@ cgraph_edge_brings_value_p (cgraph_edge *cs, ipcp_value_source<tree> *src,\n \n   if (caller_info->ipcp_orig_node)\n     {\n-      tree t;\n+      tree t = NULL_TREE;\n       if (src->offset == -1)\n \tt = caller_info->known_csts[src->index];\n-      else\n-\tt = get_clone_agg_value (cs->caller, src->offset, src->index);\n+      else if (ipcp_transformation *ts\n+\t       = ipcp_get_transformation_summary (cs->caller))\n+\t{\n+\t  ipa_argagg_value_list avl (ts);\n+\t  t = avl.get_value (src->index, src->offset / BITS_PER_UNIT);\n+\t}\n       return (t != NULL_TREE\n \t      && values_equal_for_ipcp_p (src->val->value, t));\n     }\n@@ -5060,13 +5299,12 @@ static struct cgraph_node *\n create_specialized_node (struct cgraph_node *node,\n \t\t\t vec<tree> known_csts,\n \t\t\t vec<ipa_polymorphic_call_context> known_contexts,\n-\t\t\t struct ipa_agg_replacement_value *aggvals,\n+\t\t\t vec<ipa_argagg_value, va_gc> *aggvals,\n \t\t\t vec<cgraph_edge *> &callers)\n {\n   ipa_node_params *new_info, *info = ipa_node_params_sum->get (node);\n   vec<ipa_replace_map *, va_gc> *replace_trees = NULL;\n   vec<ipa_adjusted_param, va_gc> *new_params = NULL;\n-  struct ipa_agg_replacement_value *av;\n   struct cgraph_node *new_node;\n   int i, count = ipa_get_param_count (info);\n   clone_info *cinfo = clone_info::get (node);\n@@ -5194,8 +5432,8 @@ create_specialized_node (struct cgraph_node *node,\n     new_node->expand_all_artificial_thunks ();\n \n   ipa_set_node_agg_value_chain (new_node, aggvals);\n-  for (av = aggvals; av; av = av->next)\n-    new_node->maybe_create_reference (av->value, NULL);\n+  for (const ipa_argagg_value &av : aggvals)\n+    new_node->maybe_create_reference (av.value, NULL);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -5210,7 +5448,11 @@ create_specialized_node (struct cgraph_node *node,\n \t      }\n \t}\n       if (aggvals)\n-\tipa_dump_agg_replacement_values (dump_file, aggvals);\n+\t{\n+\t  fprintf (dump_file, \"     Aggregate replacements:\");\n+\t  ipa_argagg_value_list avs (aggvals);\n+\t  avs.dump (dump_file);\n+\t}\n     }\n \n   new_info = ipa_node_params_sum->get (new_node);\n@@ -5219,7 +5461,8 @@ create_specialized_node (struct cgraph_node *node,\n   new_info->known_csts = known_csts;\n   new_info->known_contexts = known_contexts;\n \n-  ipcp_discover_new_direct_edges (new_node, known_csts, known_contexts, aggvals);\n+  ipcp_discover_new_direct_edges (new_node, known_csts, known_contexts,\n+\t\t\t\t  aggvals);\n \n   return new_node;\n }\n@@ -5252,7 +5495,8 @@ self_recursive_pass_through_p (cgraph_edge *cs, ipa_jump_func *jfunc, int i,\n    pass-through.  */\n \n static bool\n-self_recursive_agg_pass_through_p (cgraph_edge *cs, ipa_agg_jf_item *jfunc,\n+self_recursive_agg_pass_through_p (const cgraph_edge *cs,\n+\t\t\t\t   const ipa_agg_jf_item *jfunc,\n \t\t\t\t   int i, bool simple = true)\n {\n   enum availability availability;\n@@ -5427,376 +5671,215 @@ find_more_contexts_for_caller_subset (cgraph_node *node,\n     }\n }\n \n-/* Go through PLATS and create a vector of values consisting of values and\n-   offsets (minus OFFSET) of lattices that contain only a single value.  */\n-\n-static vec<ipa_agg_value>\n-copy_plats_to_inter (class ipcp_param_lattices *plats, HOST_WIDE_INT offset)\n-{\n-  vec<ipa_agg_value> res = vNULL;\n-\n-  if (!plats->aggs || plats->aggs_contain_variable || plats->aggs_bottom)\n-    return vNULL;\n-\n-  for (struct ipcp_agg_lattice *aglat = plats->aggs; aglat; aglat = aglat->next)\n-    if (aglat->is_single_const ())\n-      {\n-\tstruct ipa_agg_value ti;\n-\tti.offset = aglat->offset - offset;\n-\tti.value = aglat->values->value;\n-\tres.safe_push (ti);\n-      }\n-  return res;\n-}\n-\n-/* Intersect all values in INTER with single value lattices in PLATS (while\n-   subtracting OFFSET).  */\n-\n-static void\n-intersect_with_plats (class ipcp_param_lattices *plats,\n-\t\t      vec<ipa_agg_value> *inter,\n-\t\t      HOST_WIDE_INT offset)\n-{\n-  struct ipcp_agg_lattice *aglat;\n-  struct ipa_agg_value *item;\n-  int k;\n-\n-  if (!plats->aggs || plats->aggs_contain_variable || plats->aggs_bottom)\n-    {\n-      inter->release ();\n-      return;\n-    }\n-\n-  aglat = plats->aggs;\n-  FOR_EACH_VEC_ELT (*inter, k, item)\n-    {\n-      bool found = false;\n-      if (!item->value)\n-\tcontinue;\n-      while (aglat)\n-\t{\n-\t  if (aglat->offset - offset > item->offset)\n-\t    break;\n-\t  if (aglat->offset - offset == item->offset)\n-\t    {\n-\t      if (aglat->is_single_const ())\n-\t\t{\n-\t\t  tree value = aglat->values->value;\n-\n-\t\t  if (values_equal_for_ipcp_p (item->value, value))\n-\t\t    found = true;\n-\t\t}\n-\t      break;\n-\t    }\n-\t  aglat = aglat->next;\n-\t}\n-      if (!found)\n-\titem->value = NULL_TREE;\n-    }\n-}\n-\n-/* Copy aggregate replacement values of NODE (which is an IPA-CP clone) to the\n-   vector result while subtracting OFFSET from the individual value offsets.  */\n-\n-static vec<ipa_agg_value>\n-agg_replacements_to_vector (struct cgraph_node *node, int index,\n-\t\t\t    HOST_WIDE_INT offset)\n-{\n-  struct ipa_agg_replacement_value *av;\n-  vec<ipa_agg_value> res = vNULL;\n-\n-  for (av = ipa_get_agg_replacements_for_node (node); av; av = av->next)\n-    if (av->index == index\n-\t&& (av->offset - offset) >= 0)\n-    {\n-      struct ipa_agg_value item;\n-      gcc_checking_assert (av->value);\n-      item.offset = av->offset - offset;\n-      item.value = av->value;\n-      res.safe_push (item);\n-    }\n-\n-  return res;\n-}\n+/* Push all aggregate values coming along edge CS for parameter number INDEX to\n+   RES.  If INTERIM is non-NULL, it contains the current interim state of\n+   collected aggregate values which can be used to compute values passed over\n+   self-recursive edges.\n \n-/* Intersect all values in INTER with those that we have already scheduled to\n-   be replaced in parameter number INDEX of NODE, which is an IPA-CP clone\n-   (while subtracting OFFSET).  */\n+   This basically one iteration of push_agg_values_from_edge over one\n+   parameter, which allows for simpler early returns.  */\n \n static void\n-intersect_with_agg_replacements (struct cgraph_node *node, int index,\n-\t\t\t\t vec<ipa_agg_value> *inter,\n-\t\t\t\t HOST_WIDE_INT offset)\n+push_agg_values_for_index_from_edge (struct cgraph_edge *cs, int index,\n+\t\t\t\t     vec<ipa_argagg_value> *res,\n+\t\t\t\t     const ipa_argagg_value_list *interim)\n {\n-  struct ipa_agg_replacement_value *srcvals;\n-  struct ipa_agg_value *item;\n-  int i;\n+  bool agg_values_from_caller = false;\n+  bool agg_jf_preserved = false;\n+  unsigned unit_delta = UINT_MAX;\n+  int src_idx = -1;\n+  ipa_jump_func *jfunc = ipa_get_ith_jump_func (ipa_edge_args_sum->get (cs),\n+\t\t\t\t\t\tindex);\n \n-  srcvals = ipa_get_agg_replacements_for_node (node);\n-  if (!srcvals)\n+  if (jfunc->type == IPA_JF_PASS_THROUGH\n+      && ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n     {\n-      inter->release ();\n-      return;\n+      agg_values_from_caller = true;\n+      agg_jf_preserved = ipa_get_jf_pass_through_agg_preserved (jfunc);\n+      src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n+      unit_delta = 0;\n     }\n-\n-  FOR_EACH_VEC_ELT (*inter, i, item)\n+  else if (jfunc->type == IPA_JF_ANCESTOR\n+\t   && ipa_get_jf_ancestor_agg_preserved (jfunc))\n     {\n-      struct ipa_agg_replacement_value *av;\n-      bool found = false;\n-      if (!item->value)\n-\tcontinue;\n-      for (av = srcvals; av; av = av->next)\n-\t{\n-\t  gcc_checking_assert (av->value);\n-\t  if (av->index == index\n-\t      && av->offset - offset == item->offset)\n-\t    {\n-\t      if (values_equal_for_ipcp_p (item->value, av->value))\n-\t\tfound = true;\n-\t      break;\n-\t    }\n-\t}\n-      if (!found)\n-\titem->value = NULL_TREE;\n+      agg_values_from_caller = true;\n+      agg_jf_preserved = true;\n+      src_idx = ipa_get_jf_ancestor_formal_id (jfunc);\n+      unit_delta = ipa_get_jf_ancestor_offset (jfunc) / BITS_PER_UNIT;\n     }\n-}\n \n-/* Intersect values in INTER with aggregate values that come along edge CS to\n-   parameter number INDEX and return it.  If INTER does not actually exist yet,\n-   copy all incoming values to it.  If we determine we ended up with no values\n-   whatsoever, return a released vector.  */\n-\n-static vec<ipa_agg_value>\n-intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n-\t\t\t\tvec<ipa_agg_value> inter)\n-{\n-  struct ipa_jump_func *jfunc;\n-  jfunc = ipa_get_ith_jump_func (ipa_edge_args_sum->get (cs), index);\n-  if (jfunc->type == IPA_JF_PASS_THROUGH\n-      && ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n+  ipa_node_params *caller_info = ipa_node_params_sum->get (cs->caller);\n+  if (agg_values_from_caller)\n     {\n-      ipa_node_params *caller_info = ipa_node_params_sum->get (cs->caller);\n-      int src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n-\n       if (caller_info->ipcp_orig_node)\n \t{\n \t  struct cgraph_node *orig_node = caller_info->ipcp_orig_node;\n-\t  class ipcp_param_lattices *orig_plats;\n+\t  ipcp_transformation *ts\n+\t    = ipcp_get_transformation_summary (cs->caller);\n \t  ipa_node_params *orig_info = ipa_node_params_sum->get (orig_node);\n-\t  orig_plats = ipa_get_parm_lattices (orig_info, src_idx);\n-\t  if (agg_pass_through_permissible_p (orig_plats, jfunc))\n+\t  ipcp_param_lattices *orig_plats\n+\t    = ipa_get_parm_lattices (orig_info, src_idx);\n+\t  if (ts\n+\t      && orig_plats->aggs\n+\t      && (agg_jf_preserved || !orig_plats->aggs_by_ref))\n \t    {\n-\t      if (!inter.exists ())\n-\t\tinter = agg_replacements_to_vector (cs->caller, src_idx, 0);\n-\t      else\n-\t\tintersect_with_agg_replacements (cs->caller, src_idx,\n-\t\t\t\t\t\t &inter, 0);\n-\t      return inter;\n+\t      ipa_argagg_value_list src (ts);\n+\t      src.push_adjusted_values (src_idx, index, unit_delta, res);\n+\t      return;\n \t    }\n \t}\n       else\n \t{\n-\t  class ipcp_param_lattices *src_plats;\n-\t  src_plats = ipa_get_parm_lattices (caller_info, src_idx);\n-\t  if (agg_pass_through_permissible_p (src_plats, jfunc))\n+\t  ipcp_param_lattices *src_plats\n+\t    = ipa_get_parm_lattices (caller_info, src_idx);\n+\t  if (src_plats->aggs\n+\t      && !src_plats->aggs_bottom\n+\t      && (agg_jf_preserved || !src_plats->aggs_by_ref))\n \t    {\n-\t      /* Currently we do not produce clobber aggregate jump\n-\t\t functions, adjust when we do.  */\n-\t      gcc_checking_assert (!jfunc->agg.items);\n-\t      if (!inter.exists ())\n-\t\tinter = copy_plats_to_inter (src_plats, 0);\n-\t      else\n-\t\tintersect_with_plats (src_plats, &inter, 0);\n-\t      return inter;\n+\t      if (interim && self_recursive_pass_through_p (cs, jfunc, index))\n+\t\t{\n+\t\t  interim->push_adjusted_values (src_idx, index, unit_delta,\n+\t\t\t\t\t\t res);\n+\t\t  return;\n+\t\t}\n+\t      if (!src_plats->aggs_contain_variable)\n+\t\t{\n+\t\t  push_agg_values_from_plats (src_plats, index, unit_delta,\n+\t\t\t\t\t      res);\n+\t\t  return;\n+\t\t}\n \t    }\n \t}\n     }\n-  else if (jfunc->type == IPA_JF_ANCESTOR\n-\t   && ipa_get_jf_ancestor_agg_preserved (jfunc))\n-    {\n-      ipa_node_params *caller_info = ipa_node_params_sum->get (cs->caller);\n-      int src_idx = ipa_get_jf_ancestor_formal_id (jfunc);\n-      class ipcp_param_lattices *src_plats;\n-      HOST_WIDE_INT delta = ipa_get_jf_ancestor_offset (jfunc);\n \n-      if (caller_info->ipcp_orig_node)\n-\t{\n-\t  if (!inter.exists ())\n-\t    inter = agg_replacements_to_vector (cs->caller, src_idx, delta);\n-\t  else\n-\t    intersect_with_agg_replacements (cs->caller, src_idx, &inter,\n-\t\t\t\t\t     delta);\n-\t}\n-      else\n-\t{\n-\t  src_plats = ipa_get_parm_lattices (caller_info, src_idx);\n-\t  /* Currently we do not produce clobber aggregate jump\n-\t     functions, adjust when we do.  */\n-\t  gcc_checking_assert (!src_plats->aggs || !jfunc->agg.items);\n-\t  if (!inter.exists ())\n-\t    inter = copy_plats_to_inter (src_plats, delta);\n-\t  else\n-\t    intersect_with_plats (src_plats, &inter, delta);\n-\t}\n-      return inter;\n-    }\n-\n-  if (jfunc->agg.items)\n+  if (!jfunc->agg.items)\n+    return;\n+  bool first = true;\n+  unsigned prev_unit_offset = 0;\n+  for (const ipa_agg_jf_item &agg_jf : *jfunc->agg.items)\n     {\n-      ipa_node_params *caller_info = ipa_node_params_sum->get (cs->caller);\n-      struct ipa_agg_value *item;\n-      int k;\n+      tree value, srcvalue;\n+      /* Besides simple pass-through aggregate jump function, arithmetic\n+\t aggregate jump function could also bring same aggregate value as\n+\t parameter passed-in for self-feeding recursive call.  For example,\n \n-      if (!inter.exists ())\n-\tfor (unsigned i = 0; i < jfunc->agg.items->length (); i++)\n-\t  {\n-\t    struct ipa_agg_jf_item *agg_item = &(*jfunc->agg.items)[i];\n-\t    tree value = ipa_agg_value_from_node (caller_info, cs->caller,\n-\t\t\t\t\t\t  agg_item);\n-\t    if (value)\n-\t      {\n-\t\tstruct ipa_agg_value agg_value;\n+\t fn (int *i)\n+\t {\n+\t   int j = *i & 1;\n+\t   fn (&j);\n+\t }\n \n-\t\tagg_value.value = value;\n-\t\tagg_value.offset = agg_item->offset;\n-\t\tinter.safe_push (agg_value);\n-\t      }\n-\t  }\n+\t Given that *i is 0, recursive propagation via (*i & 1) also gets 0.  */\n+      if (interim\n+\t  && self_recursive_agg_pass_through_p (cs, &agg_jf, index, false)\n+\t  && (srcvalue = interim->get_value(index,\n+\t\t\t\t\t    agg_jf.offset / BITS_PER_UNIT)))\n+\tvalue = ipa_get_jf_arith_result (agg_jf.value.pass_through.operation,\n+\t\t\t\t\t srcvalue,\n+\t\t\t\t\t agg_jf.value.pass_through.operand,\n+\t\t\t\t\t agg_jf.type);\n       else\n-\tFOR_EACH_VEC_ELT (inter, k, item)\n-\t  {\n-\t    int l = 0;\n-\t    bool found = false;\n-\n-\t    if (!item->value)\n-\t      continue;\n-\n-\t    while ((unsigned) l < jfunc->agg.items->length ())\n-\t      {\n-\t\tstruct ipa_agg_jf_item *ti;\n-\t\tti = &(*jfunc->agg.items)[l];\n-\t\tif (ti->offset > item->offset)\n-\t\t  break;\n-\t\tif (ti->offset == item->offset)\n-\t\t  {\n-\t\t    tree value;\n-\n-\t\t    /* Besides simple pass-through aggregate jump function,\n-\t\t       arithmetic aggregate jump function could also bring\n-\t\t       same aggregate value as parameter passed-in for\n-\t\t       self-feeding recursive call.  For example,\n-\n-\t\t         fn (int *i)\n-\t\t           {\n-\t\t             int j = *i & 1;\n-\t\t             fn (&j);\n-\t\t           }\n-\n-\t\t       Given that *i is 0, recursive propagation via (*i & 1)\n-\t\t       also gets 0.  */\n-\t\t    if (self_recursive_agg_pass_through_p (cs, ti, index,\n-\t\t\t\t\t\t\t   false))\n-\t\t      value = ipa_get_jf_arith_result (\n-\t\t\t\t\tti->value.pass_through.operation,\n-\t\t\t\t\titem->value,\n-\t\t\t\t\tti->value.pass_through.operand,\n-\t\t\t\t\tti->type);\n-\t\t    else\n-\t\t      value = ipa_agg_value_from_node (caller_info,\n-\t\t\t\t\t\t       cs->caller, ti);\n+\tvalue = ipa_agg_value_from_node (caller_info, cs->caller,\n+\t\t\t\t\t &agg_jf);\n+      if (value)\n+\t{\n+\t  struct ipa_argagg_value iav;\n+\t  iav.value = value;\n+\t  iav.unit_offset = agg_jf.offset / BITS_PER_UNIT;\n+\t  iav.index = index;\n+\t  iav.by_ref = jfunc->agg.by_ref;\n+\n+\t  gcc_assert (first\n+\t\t      || iav.unit_offset > prev_unit_offset);\n+\t  prev_unit_offset = iav.unit_offset;\n+\t  first = false;\n \n-\t\t    if (value && values_equal_for_ipcp_p (item->value, value))\n-\t\t      found = true;\n-\t\t    break;\n-\t\t  }\n-\t\tl++;\n-\t      }\n-\t    if (!found)\n-\t      item->value = NULL;\n-\t  }\n-    }\n-  else\n-    {\n-      inter.release ();\n-      return vNULL;\n+\t  res->safe_push (iav);\n+\t}\n     }\n-  return inter;\n+  return;\n }\n \n-/* Look at edges in CALLERS and collect all known aggregate values that arrive\n-   from all of them.  */\n+/* Push all aggregate values coming along edge CS to RES.  DEST_INFO is the\n+   description of ultimate callee of CS or the one it was cloned from (the\n+   summary where lattices are).  If INTERIM is non-NULL, it contains the\n+   current interim state of collected aggregate values which can be used to\n+   compute values passed over self-recursive edges and to skip values which\n+   clearly will not be part of intersection with INTERIM.  */\n \n-static struct ipa_agg_replacement_value *\n-find_aggregate_values_for_callers_subset (struct cgraph_node *node,\n-\t\t\t\t\t  const vec<cgraph_edge *> &callers)\n+static void\n+push_agg_values_from_edge (struct cgraph_edge *cs,\n+\t\t\t   ipa_node_params *dest_info,\n+\t\t\t   vec<ipa_argagg_value> *res,\n+\t\t\t   const ipa_argagg_value_list *interim)\n {\n-  ipa_node_params *dest_info = ipa_node_params_sum->get (node);\n-  struct ipa_agg_replacement_value *res;\n-  struct ipa_agg_replacement_value **tail = &res;\n-  struct cgraph_edge *cs;\n-  int i, j, count = ipa_get_param_count (dest_info);\n+  ipa_edge_args *args = ipa_edge_args_sum->get (cs);\n+  if (!args)\n+    return;\n+\n+  int count = MIN (ipa_get_param_count (dest_info),\n+\t\t   ipa_get_cs_argument_count (args));\n \n-  FOR_EACH_VEC_ELT (callers, j, cs)\n+  unsigned interim_index = 0;\n+  for (int index = 0; index < count; index++)\n     {\n-      ipa_edge_args *args = ipa_edge_args_sum->get (cs);\n-      if (!args)\n+      if (interim)\n \t{\n-\t  count = 0;\n-\t  break;\n+\t  while (interim_index < interim->m_elts.size ()\n+\t\t && interim->m_elts[interim_index].value\n+\t\t && interim->m_elts[interim_index].index < index)\n+\t    interim_index++;\n+\t  if (interim_index >= interim->m_elts.size ()\n+\t      || interim->m_elts[interim_index].index > index)\n+\t    continue;\n \t}\n-      int c = ipa_get_cs_argument_count (args);\n-      if (c < count)\n-\tcount = c;\n-    }\n \n-  for (i = 0; i < count; i++)\n-    {\n-      struct cgraph_edge *cs;\n-      vec<ipa_agg_value> inter = vNULL;\n-      struct ipa_agg_value *item;\n-      class ipcp_param_lattices *plats = ipa_get_parm_lattices (dest_info, i);\n-      int j;\n-\n-      /* Among other things, the following check should deal with all by_ref\n-\t mismatches.  */\n+      ipcp_param_lattices *plats = ipa_get_parm_lattices (dest_info, index);\n       if (plats->aggs_bottom)\n \tcontinue;\n+      push_agg_values_for_index_from_edge (cs, index, res, interim);\n+    }\n+}\n \n-      FOR_EACH_VEC_ELT (callers, j, cs)\n-\t{\n-\t  struct ipa_jump_func *jfunc\n-\t    = ipa_get_ith_jump_func (ipa_edge_args_sum->get (cs), i);\n-\t  if (self_recursive_pass_through_p (cs, jfunc, i)\n-\t      && (!plats->aggs_by_ref\n-\t\t  || ipa_get_jf_pass_through_agg_preserved (jfunc)))\n-\t    continue;\n-\t  inter = intersect_aggregates_with_edge (cs, i, inter);\n \n-\t  if (!inter.exists ())\n-\t    goto next_param;\n-\t}\n+/* Look at edges in CALLERS and collect all known aggregate values that arrive\n+   from all of them.  Return nullptr if there are none.  */\n \n-      FOR_EACH_VEC_ELT (inter, j, item)\n-\t{\n-\t  struct ipa_agg_replacement_value *v;\n+static struct vec<ipa_argagg_value, va_gc> *\n+find_aggregate_values_for_callers_subset (struct cgraph_node *node,\n+\t\t\t\t\t  const vec<cgraph_edge *> &callers)\n+{\n+  ipa_node_params *dest_info = ipa_node_params_sum->get (node);\n+  if (dest_info->ipcp_orig_node)\n+    dest_info = ipa_node_params_sum->get (dest_info->ipcp_orig_node);\n \n-\t  if (!item->value)\n-\t    continue;\n+  /* gather_edges_for_value puts a non-recursive call into the first element of\n+     callers if it can.  */\n+  auto_vec<ipa_argagg_value, 32> interim;\n+  push_agg_values_from_edge (callers[0], dest_info, &interim, NULL);\n \n-\t  v = ggc_alloc<ipa_agg_replacement_value> ();\n-\t  v->index = i;\n-\t  v->offset = item->offset;\n-\t  v->value = item->value;\n-\t  v->by_ref = plats->aggs_by_ref;\n-\t  *tail = v;\n-\t  tail = &v->next;\n-\t}\n+  unsigned valid_entries = interim.length ();\n+  if (!valid_entries)\n+    return nullptr;\n+\n+  unsigned caller_count = callers.length();\n+  for (unsigned i = 1; i < caller_count; i++)\n+    {\n+      auto_vec<ipa_argagg_value, 32> last;\n+      ipa_argagg_value_list avs (&interim);\n+      push_agg_values_from_edge (callers[i], dest_info, &last, &avs);\n \n-    next_param:\n-      if (inter.exists ())\n-\tinter.release ();\n+      valid_entries = intersect_argaggs_with (interim, last);\n+      if (!valid_entries)\n+\treturn nullptr;\n     }\n-  *tail = NULL;\n+\n+  vec<ipa_argagg_value, va_gc> *res = NULL;\n+  vec_safe_reserve_exact (res, valid_entries);\n+  for (const ipa_argagg_value &av : interim)\n+    if (av.value)\n+      res->quick_push(av);\n+  gcc_checking_assert (res->length () == valid_entries);\n   return res;\n }\n \n@@ -5837,72 +5920,23 @@ cgraph_edge_brings_all_scalars_for_node (struct cgraph_edge *cs,\n \n /* Determine whether CS also brings all aggregate values that NODE is\n    specialized for.  */\n+\n static bool\n cgraph_edge_brings_all_agg_vals_for_node (struct cgraph_edge *cs,\n \t\t\t\t\t  struct cgraph_node *node)\n {\n-  struct ipa_agg_replacement_value *aggval;\n-  int i, ec, count;\n-\n-  aggval = ipa_get_agg_replacements_for_node (node);\n-  if (!aggval)\n+  ipcp_transformation *ts = ipcp_get_transformation_summary (node);\n+  if (!ts || vec_safe_is_empty (ts->m_agg_values))\n     return true;\n \n-  ipa_node_params *clone_node_info = ipa_node_params_sum->get (node);\n-  count = ipa_get_param_count (clone_node_info);\n-  ec = ipa_get_cs_argument_count (ipa_edge_args_sum->get (cs));\n-  if (ec < count)\n-    for (struct ipa_agg_replacement_value *av = aggval; av; av = av->next)\n-      if (aggval->index >= ec)\n-\treturn false;\n-\n-  ipa_node_params *orig_node_info\n-    = ipa_node_params_sum->get (clone_node_info->ipcp_orig_node);\n-\n-  for (i = 0; i < count; i++)\n-    {\n-      class ipcp_param_lattices *plats;\n-      bool interesting = false;\n-      for (struct ipa_agg_replacement_value *av = aggval; av; av = av->next)\n-\tif (aggval->index == i)\n-\t  {\n-\t    interesting = true;\n-\t    break;\n-\t  }\n-      if (!interesting)\n-\tcontinue;\n-\n-      plats = ipa_get_parm_lattices (orig_node_info, aggval->index);\n-      if (plats->aggs_bottom)\n-\treturn false;\n-\n-      vec<ipa_agg_value> values = intersect_aggregates_with_edge (cs, i, vNULL);\n-      if (!values.exists ())\n-\treturn false;\n-\n-      for (struct ipa_agg_replacement_value *av = aggval; av; av = av->next)\n-\tif (aggval->index == i)\n-\t  {\n-\t    struct ipa_agg_value *item;\n-\t    int j;\n-\t    bool found = false;\n-\t    FOR_EACH_VEC_ELT (values, j, item)\n-\t      if (item->value\n-\t\t  && item->offset == av->offset\n-\t\t  && values_equal_for_ipcp_p (item->value, av->value))\n-\t\t{\n-\t\t  found = true;\n-\t\t  break;\n-\t\t}\n-\t    if (!found)\n-\t      {\n-\t\tvalues.release ();\n-\t\treturn false;\n-\t      }\n-\t  }\n-      values.release ();\n-    }\n-  return true;\n+  const ipa_argagg_value_list existing (ts->m_agg_values);\n+  auto_vec<ipa_argagg_value, 32> edge_values;\n+  ipa_node_params *dest_info = ipa_node_params_sum->get (node);\n+  gcc_checking_assert (dest_info->ipcp_orig_node);\n+  dest_info = ipa_node_params_sum->get (dest_info->ipcp_orig_node);\n+  push_agg_values_from_edge (cs, dest_info, &edge_values, &existing);\n+  const ipa_argagg_value_list avl (&edge_values);\n+  return avl.superset_of_p (existing);\n }\n \n /* Given an original NODE and a VAL for which we have already created a\n@@ -6006,28 +6040,22 @@ copy_known_vectors_add_val (ipa_auto_call_arg_values *avals,\n    AGGVALS list.  */\n \n DEBUG_FUNCTION bool\n-ipcp_val_agg_replacement_ok_p (ipa_agg_replacement_value *aggvals,\n+ipcp_val_agg_replacement_ok_p (vec<ipa_argagg_value, va_gc> *aggvals,\n \t\t\t       int index, HOST_WIDE_INT offset, tree value)\n {\n   if (offset == -1)\n     return true;\n \n-  while (aggvals)\n-    {\n-      if (aggvals->index == index\n-\t  && aggvals->offset == offset\n-\t  && values_equal_for_ipcp_p (aggvals->value, value))\n-\treturn true;\n-      aggvals = aggvals->next;\n-    }\n-  return false;\n+  const ipa_argagg_value_list avl (aggvals);\n+  tree v = avl.get_value (index, offset / BITS_PER_UNIT);\n+  return v && values_equal_for_ipcp_p (v, value);\n }\n \n /* Return true if offset is minus one because source of a polymorphic context\n    cannot be an aggregate value.  */\n \n DEBUG_FUNCTION bool\n-ipcp_val_agg_replacement_ok_p (ipa_agg_replacement_value *,\n+ipcp_val_agg_replacement_ok_p (vec<ipa_argagg_value, va_gc> *,\n \t\t\t       int , HOST_WIDE_INT offset,\n \t\t\t       ipa_polymorphic_call_context)\n {\n@@ -6047,7 +6075,6 @@ decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n \t\t    ipcp_value<valtype> *val, ipa_auto_call_arg_values *avals,\n \t\t    vec<cgraph_node *> *self_gen_clones)\n {\n-  struct ipa_agg_replacement_value *aggvals;\n   int caller_count;\n   sreal freq_sum;\n   profile_count count_sum, rec_count_sum;\n@@ -6126,7 +6153,8 @@ decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n     }\n   find_more_scalar_values_for_callers_subset (node, known_csts, callers);\n   find_more_contexts_for_caller_subset (node, &known_contexts, callers);\n-  aggvals = find_aggregate_values_for_callers_subset (node, callers);\n+  vec<ipa_argagg_value, va_gc> *aggvals\n+    = find_aggregate_values_for_callers_subset (node, callers);\n   gcc_checking_assert (ipcp_val_agg_replacement_ok_p (aggvals, index,\n \t\t\t\t\t\t      offset, val->value));\n   val->spec_node = create_specialized_node (node, known_csts, known_contexts,\n@@ -6277,7 +6305,7 @@ decide_whether_version_node (struct cgraph_node *node)\n \t= copy_useful_known_contexts (avals.m_known_contexts);\n       find_more_scalar_values_for_callers_subset (node, known_csts, callers);\n       find_more_contexts_for_caller_subset (node, &known_contexts, callers);\n-      ipa_agg_replacement_value *aggvals\n+      vec<ipa_argagg_value, va_gc> *aggvals\n \t= find_aggregate_values_for_callers_subset (node, callers);\n \n       if (!known_contexts_useful_p (known_contexts))"}, {"sha": "24148a3bbba9492f078285af5480da9df760fec9", "filename": "gcc/ipa-prop.cc", "status": "modified", "additions": 118, "deletions": 142, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0403e95689af7d562c7d04f706e9e25115747ff/gcc%2Fipa-prop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0403e95689af7d562c7d04f706e9e25115747ff/gcc%2Fipa-prop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.cc?ref=e0403e95689af7d562c7d04f706e9e25115747ff", "patch": "@@ -1095,7 +1095,10 @@ parm_ref_data_pass_through_p (struct ipa_func_body_info *fbi, int index,\n    latter can be NULL), STMT is the load statement.  If function returns true,\n    *INDEX_P, *OFFSET_P and *BY_REF is filled with the parameter index, offset\n    within the aggregate and whether it is a load from a value passed by\n-   reference respectively.  */\n+   reference respectively.\n+\n+   Return false if the offset divided by BITS_PER_UNIT would not fit into an\n+   unsigned int.  */\n \n bool\n ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,\n@@ -1109,7 +1112,8 @@ ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,\n   bool reverse;\n   tree base = get_ref_base_and_extent_hwi (op, offset_p, &size, &reverse);\n \n-  if (!base)\n+  if (!base\n+      || (*offset_p / BITS_PER_UNIT) > UINT_MAX)\n     return false;\n \n   /* We can not propagate across volatile loads.  */\n@@ -3057,13 +3061,11 @@ ipa_analyze_node (struct cgraph_node *node)\n     return;\n   info->analysis_done = 1;\n \n-  if (ipa_func_spec_opts_forbid_analysis_p (node))\n+  if (ipa_func_spec_opts_forbid_analysis_p (node)\n+      || (count_formal_params (node->decl)\n+\t  >= (1 << IPA_PROP_ARG_INDEX_LIMIT_BITS)))\n     {\n-      for (int i = 0; i < ipa_get_param_count (info); i++)\n-\t{\n-\t  ipa_set_param_used (info, i, true);\n-\t  ipa_set_controlled_uses (info, i, IPA_UNDESCRIBED_USE);\n-\t}\n+      gcc_assert (!ipa_get_param_count (info));\n       return;\n     }\n \n@@ -4383,11 +4385,11 @@ ipcp_free_transformation_sum (void)\n \n void\n ipa_set_node_agg_value_chain (struct cgraph_node *node,\n-\t\t\t      struct ipa_agg_replacement_value *aggvals)\n+\t\t\t      vec<ipa_argagg_value, va_gc> *aggs)\n {\n   ipcp_transformation_initialize ();\n   ipcp_transformation *s = ipcp_transformation_sum->get_create (node);\n-  s->agg_values = aggvals;\n+  s->m_agg_values = aggs;\n }\n \n /* Hook that is called by cgraph.cc when an edge is removed.  Adjust reference\n@@ -4532,12 +4534,10 @@ ipa_add_new_function (cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n /* Hook that is called by summary when a node is duplicated.  */\n \n void\n-ipa_node_params_t::duplicate(cgraph_node *src, cgraph_node *dst,\n+ipa_node_params_t::duplicate(cgraph_node *, cgraph_node *,\n \t\t\t     ipa_node_params *old_info,\n \t\t\t     ipa_node_params *new_info)\n {\n-  ipa_agg_replacement_value *old_av, *new_av;\n-\n   new_info->descriptors = vec_safe_copy (old_info->descriptors);\n   new_info->lattices = NULL;\n   new_info->ipcp_orig_node = old_info->ipcp_orig_node;\n@@ -4547,23 +4547,6 @@ ipa_node_params_t::duplicate(cgraph_node *src, cgraph_node *dst,\n   new_info->analysis_done = old_info->analysis_done;\n   new_info->node_enqueued = old_info->node_enqueued;\n   new_info->versionable = old_info->versionable;\n-\n-  old_av = ipa_get_agg_replacements_for_node (src);\n-  if (old_av)\n-    {\n-      new_av = NULL;\n-      while (old_av)\n-\t{\n-\t  struct ipa_agg_replacement_value *v;\n-\n-\t  v = ggc_alloc<ipa_agg_replacement_value> ();\n-\t  memcpy (v, old_av, sizeof (*v));\n-\t  v->next = new_av;\n-\t  new_av = v;\n-\t  old_av = old_av->next;\n-\t}\n-      ipa_set_node_agg_value_chain (dst, new_av);\n-    }\n }\n \n /* Duplication of ipcp transformation summaries.  */\n@@ -4576,17 +4559,9 @@ ipcp_transformation_t::duplicate(cgraph_node *, cgraph_node *dst,\n   /* Avoid redundant work of duplicating vectors we will never use.  */\n   if (dst->inlined_to)\n     return;\n+  dst_trans->m_agg_values = vec_safe_copy (src_trans->m_agg_values);\n   dst_trans->bits = vec_safe_copy (src_trans->bits);\n   dst_trans->m_vr = vec_safe_copy (src_trans->m_vr);\n-  ipa_agg_replacement_value *agg = src_trans->agg_values,\n-\t\t\t    **aggptr = &dst_trans->agg_values;\n-  while (agg)\n-    {\n-      *aggptr = ggc_alloc<ipa_agg_replacement_value> ();\n-      **aggptr = *agg;\n-      agg = agg->next;\n-      aggptr = &(*aggptr)->next;\n-    }\n }\n \n /* Register our cgraph hooks if they are not already there.  */\n@@ -4703,23 +4678,6 @@ ipa_print_all_params (FILE * f)\n     ipa_print_node_params (f, node);\n }\n \n-/* Dump the AV linked list.  */\n-\n-void\n-ipa_dump_agg_replacement_values (FILE *f, struct ipa_agg_replacement_value *av)\n-{\n-  bool comma = false;\n-  fprintf (f, \"     Aggregate replacements:\");\n-  for (; av; av = av->next)\n-    {\n-      fprintf (f, \"%s %i[\" HOST_WIDE_INT_PRINT_DEC \"]=\", comma ? \",\" : \"\",\n-\t       av->index, av->offset);\n-      print_generic_expr (f, av->value);\n-      comma = true;\n-    }\n-  fprintf (f, \"\\n\");\n-}\n-\n /* Stream out jump function JUMP_FUNC to OB.  */\n \n static void\n@@ -5356,31 +5314,31 @@ write_ipcp_transformation_info (output_block *ob, cgraph_node *node)\n   int node_ref;\n   unsigned int count = 0;\n   lto_symtab_encoder_t encoder;\n-  struct ipa_agg_replacement_value *aggvals, *av;\n \n-  aggvals = ipa_get_agg_replacements_for_node (node);\n   encoder = ob->decl_state->symtab_node_encoder;\n   node_ref = lto_symtab_encoder_encode (encoder, node);\n   streamer_write_uhwi (ob, node_ref);\n \n-  for (av = aggvals; av; av = av->next)\n-    count++;\n-  streamer_write_uhwi (ob, count);\n-\n-  for (av = aggvals; av; av = av->next)\n+  ipcp_transformation *ts = ipcp_get_transformation_summary (node);\n+  if (ts && !vec_safe_is_empty (ts->m_agg_values))\n     {\n-      struct bitpack_d bp;\n+      streamer_write_uhwi (ob, ts->m_agg_values->length ());\n+      for (const ipa_argagg_value &av : ts->m_agg_values)\n+\t{\n+\t  struct bitpack_d bp;\n \n-      streamer_write_uhwi (ob, av->offset);\n-      streamer_write_uhwi (ob, av->index);\n-      stream_write_tree (ob, av->value, true);\n+\t  stream_write_tree (ob, av.value, true);\n+\t  streamer_write_uhwi (ob, av.unit_offset);\n+\t  streamer_write_uhwi (ob, av.index);\n \n-      bp = bitpack_create (ob->main_stream);\n-      bp_pack_value (&bp, av->by_ref, 1);\n-      streamer_write_bitpack (&bp);\n+\t  bp = bitpack_create (ob->main_stream);\n+\t  bp_pack_value (&bp, av.by_ref, 1);\n+\t  streamer_write_bitpack (&bp);\n+\t}\n     }\n+  else\n+    streamer_write_uhwi (ob, 0);\n \n-  ipcp_transformation *ts = ipcp_get_transformation_summary (node);\n   if (ts && vec_safe_length (ts->m_vr) > 0)\n     {\n       count = ts->m_vr->length ();\n@@ -5432,26 +5390,27 @@ static void\n read_ipcp_transformation_info (lto_input_block *ib, cgraph_node *node,\n \t\t\t       data_in *data_in)\n {\n-  struct ipa_agg_replacement_value *aggvals = NULL;\n   unsigned int count, i;\n \n   count = streamer_read_uhwi (ib);\n-  for (i = 0; i <count; i++)\n-    {\n-      struct ipa_agg_replacement_value *av;\n-      struct bitpack_d bp;\n-\n-      av = ggc_alloc<ipa_agg_replacement_value> ();\n-      av->offset = streamer_read_uhwi (ib);\n-      av->index = streamer_read_uhwi (ib);\n-      av->value = stream_read_tree (ib, data_in);\n-      bp = streamer_read_bitpack (ib);\n-      av->by_ref = bp_unpack_value (&bp, 1);\n-      av->next = aggvals;\n-      aggvals = av;\n-    }\n-  ipa_set_node_agg_value_chain (node, aggvals);\n-  \n+  if (count > 0)\n+    {\n+      ipcp_transformation_initialize ();\n+      ipcp_transformation *ts = ipcp_transformation_sum->get_create (node);\n+      vec_safe_grow_cleared (ts->m_agg_values, count, true);\n+      for (i = 0; i <count; i++)\n+\t{\n+\t  ipa_argagg_value *av = &(*ts->m_agg_values)[i];;\n+\n+\t  av->value = stream_read_tree (ib, data_in);\n+\t  av->unit_offset = streamer_read_uhwi (ib);\n+\t  av->index = streamer_read_uhwi (ib);\n+\n+\t  bitpack_d bp = streamer_read_bitpack (ib);\n+\t  av->by_ref = bp_unpack_value (&bp, 1);\n+\t}\n+    }\n+\n   count = streamer_read_uhwi (ib);\n   if (count > 0)\n     {\n@@ -5595,56 +5554,75 @@ ipcp_read_transformation_summaries (void)\n     }\n }\n \n-/* Adjust the aggregate replacements in AGGVAL to reflect parameters skipped in\n+/* Adjust the aggregate replacements in TS to reflect parameters skipped in\n    NODE but also if any parameter was IPA-SRAed into a scalar go ahead with\n    substitution of the default_definitions of that new param with the\n    appropriate constant.\n \n-   Return two bools.  the first it true if at least one item in AGGVAL still\n-   exists and function body walk should go ahead.  The second is true if any\n-   values were already substituted for scalarized parameters and update_cfg\n-   shuld be run after replace_uses_by.  */\n+   If after adjustments there are no aggregate replacements left, the\n+   m_agg_values will be set to NULL.  In other cases, it may be shrunk.\n+\n+   Return true if any values were already substituted for scalarized parameters\n+   and update_cfg shuld be run after replace_uses_by.  */\n \n-static std::pair<bool, bool>\n+static bool\n adjust_agg_replacement_values (cgraph_node *node,\n-\t\t\t       ipa_agg_replacement_value *aggval,\n+\t\t\t       ipcp_transformation *ts,\n \t\t\t       const vec<ipa_param_descriptor, va_gc>\n \t\t\t         &descriptors)\n {\n-  struct ipa_agg_replacement_value *v;\n   clone_info *cinfo = clone_info::get (node);\n   if (!cinfo || !cinfo->param_adjustments)\n-    return std::pair<bool, bool> (true, false);\n+    return false;\n \n-  bool anything_left = false;\n+  bool removed_item = false;\n   bool done_replacement = false;\n-  for (v = aggval; v; v = v->next)\n+  unsigned dst_index = 0;\n+  unsigned count = ts->m_agg_values->length ();\n+  for (unsigned i = 0; i < count; i++)\n     {\n+      ipa_argagg_value *v = &(*ts->m_agg_values)[i];\n       gcc_checking_assert (v->index >= 0);\n \n-      unsigned unit_offset = v->offset / BITS_PER_UNIT;\n       tree cst_type = TREE_TYPE (v->value);\n       int split_idx;\n       int new_idx\n \t= cinfo->param_adjustments->get_updated_index_or_split (v->index,\n-\t\t\t\t\t\t\t\tunit_offset,\n+\t\t\t\t\t\t\t\tv->unit_offset,\n \t\t\t\t\t\t\t\tcst_type,\n \t\t\t\t\t\t\t\t&split_idx);\n-      v->index = new_idx;\n       if (new_idx >= 0)\n-\tanything_left = true;\n-      else if (split_idx >= 0)\n \t{\n-\t  tree parm = ipa_get_param (descriptors, split_idx);\n-\t  tree ddef = ssa_default_def (cfun, parm);\n-\t  if (ddef)\n+\t  v->index = new_idx;\n+\t  if (removed_item)\n+\t    (*ts->m_agg_values)[dst_index] = *v;\n+\t  dst_index++;\n+\t}\n+      else\n+\t{\n+\t  removed_item = true;\n+\t  if (split_idx >= 0)\n \t    {\n-\t      replace_uses_by (ddef, v->value);\n-\t      done_replacement = true;\n+\t      tree parm = ipa_get_param (descriptors, split_idx);\n+\t      tree ddef = ssa_default_def (cfun, parm);\n+\t      if (ddef)\n+\t\t{\n+\t\t  replace_uses_by (ddef, v->value);\n+\t\t  done_replacement = true;\n+\t\t}\n \t    }\n \t}\n     }\n-   return std::pair<bool, bool> (anything_left, done_replacement);\n+\n+  if (dst_index == 0)\n+    {\n+      ggc_free (ts->m_agg_values);\n+      ts->m_agg_values = NULL;\n+    }\n+  else if (removed_item)\n+    ts->m_agg_values->truncate (dst_index);\n+\n+  return done_replacement;\n }\n \n /* Dominator walker driving the ipcp modification phase.  */\n@@ -5654,10 +5632,9 @@ class ipcp_modif_dom_walker : public dom_walker\n public:\n   ipcp_modif_dom_walker (struct ipa_func_body_info *fbi,\n \t\t\t vec<ipa_param_descriptor, va_gc> *descs,\n-\t\t\t struct ipa_agg_replacement_value *av,\n-\t\t\t bool *sc)\n+\t\t\t ipcp_transformation *ts, bool *sc)\n     : dom_walker (CDI_DOMINATORS), m_fbi (fbi), m_descriptors (descs),\n-      m_aggval (av), m_something_changed (sc) {}\n+      m_ts (ts), m_something_changed (sc) {}\n \n   edge before_dom_children (basic_block) final override;\n   bool cleanup_eh ()\n@@ -5666,7 +5643,7 @@ class ipcp_modif_dom_walker : public dom_walker\n private:\n   struct ipa_func_body_info *m_fbi;\n   vec<ipa_param_descriptor, va_gc> *m_descriptors;\n-  struct ipa_agg_replacement_value *m_aggval;\n+  ipcp_transformation *m_ts;\n   bool *m_something_changed;\n   auto_bitmap m_need_eh_cleanup;\n };\n@@ -5677,10 +5654,9 @@ ipcp_modif_dom_walker::before_dom_children (basic_block bb)\n   gimple_stmt_iterator gsi;\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      struct ipa_agg_replacement_value *v;\n       gimple *stmt = gsi_stmt (gsi);\n       tree rhs, val, t;\n-      HOST_WIDE_INT offset;\n+      HOST_WIDE_INT bit_offset;\n       poly_int64 size;\n       int index;\n       bool by_ref, vce;\n@@ -5708,32 +5684,30 @@ ipcp_modif_dom_walker::before_dom_children (basic_block bb)\n \tcontinue;\n \n       if (!ipa_load_from_parm_agg (m_fbi, m_descriptors, stmt, rhs, &index,\n-\t\t\t\t   &offset, &size, &by_ref))\n+\t\t\t\t   &bit_offset, &size, &by_ref))\n \tcontinue;\n-      for (v = m_aggval; v; v = v->next)\n-\tif (v->index == index\n-\t    && v->offset == offset)\n-\t  break;\n+      unsigned unit_offset = bit_offset / BITS_PER_UNIT;\n+      ipa_argagg_value_list avl (m_ts);\n+      tree v = avl.get_value (index, unit_offset, by_ref);\n+\n       if (!v\n-\t  || v->by_ref != by_ref\n-\t  || maybe_ne (tree_to_poly_int64 (TYPE_SIZE (TREE_TYPE (v->value))),\n-\t\t       size))\n+\t  || maybe_ne (tree_to_poly_int64 (TYPE_SIZE (TREE_TYPE (v))), size))\n \tcontinue;\n \n-      gcc_checking_assert (is_gimple_ip_invariant (v->value));\n-      if (!useless_type_conversion_p (TREE_TYPE (rhs), TREE_TYPE (v->value)))\n+      gcc_checking_assert (is_gimple_ip_invariant (v));\n+      if (!useless_type_conversion_p (TREE_TYPE (rhs), TREE_TYPE (v)))\n \t{\n-\t  if (fold_convertible_p (TREE_TYPE (rhs), v->value))\n-\t    val = fold_build1 (NOP_EXPR, TREE_TYPE (rhs), v->value);\n+\t  if (fold_convertible_p (TREE_TYPE (rhs), v))\n+\t    val = fold_build1 (NOP_EXPR, TREE_TYPE (rhs), v);\n \t  else if (TYPE_SIZE (TREE_TYPE (rhs))\n-\t\t   == TYPE_SIZE (TREE_TYPE (v->value)))\n-\t    val = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (rhs), v->value);\n+\t\t   == TYPE_SIZE (TREE_TYPE (v)))\n+\t    val = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (rhs), v);\n \t  else\n \t    {\n \t      if (dump_file)\n \t\t{\n \t\t  fprintf (dump_file, \"    const \");\n-\t\t  print_generic_expr (dump_file, v->value);\n+\t\t  print_generic_expr (dump_file, v);\n \t\t  fprintf (dump_file, \"  can't be converted to type of \");\n \t\t  print_generic_expr (dump_file, rhs);\n \t\t  fprintf (dump_file, \"\\n\");\n@@ -5742,7 +5716,7 @@ ipcp_modif_dom_walker::before_dom_children (basic_block bb)\n \t    }\n \t}\n       else\n-\tval = v->value;\n+\tval = v;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -6019,7 +5993,6 @@ ipcp_transform_function (struct cgraph_node *node)\n {\n   vec<ipa_param_descriptor, va_gc> *descriptors = NULL;\n   struct ipa_func_body_info fbi;\n-  struct ipa_agg_replacement_value *aggval;\n   int param_count;\n \n   gcc_checking_assert (cfun);\n@@ -6031,18 +6004,17 @@ ipcp_transform_function (struct cgraph_node *node)\n \n   ipcp_update_bits (node);\n   ipcp_update_vr (node);\n-  aggval = ipa_get_agg_replacements_for_node (node);\n-  if (!aggval)\n+  ipcp_transformation *ts = ipcp_get_transformation_summary (node);\n+  if (!ts || vec_safe_is_empty (ts->m_agg_values))\n       return 0;\n   param_count = count_formal_params (node->decl);\n   if (param_count == 0)\n     return 0;\n   vec_safe_grow_cleared (descriptors, param_count, true);\n   ipa_populate_param_decls (node, *descriptors);\n-  std::pair<bool, bool> rr\n-    = adjust_agg_replacement_values (node, aggval, *descriptors);\n-  bool cfg_changed = rr.second;\n-  if (!rr.first)\n+\n+  bool cfg_changed = adjust_agg_replacement_values (node, ts, *descriptors);\n+  if (vec_safe_is_empty (ts->m_agg_values))\n     {\n       vec_free (descriptors);\n       if (dump_file)\n@@ -6053,7 +6025,11 @@ ipcp_transform_function (struct cgraph_node *node)\n       return 0;\n     }\n   if (dump_file)\n-    ipa_dump_agg_replacement_values (dump_file, aggval);\n+    {\n+      fprintf (dump_file, \"     Aggregate replacements:\");\n+      ipa_argagg_value_list avs (ts);\n+      avs.dump (dump_file);\n+    }\n \n   fbi.node = node;\n   fbi.info = NULL;\n@@ -6064,7 +6040,7 @@ ipcp_transform_function (struct cgraph_node *node)\n \n   bool modified_mem_access = false;\n   calculate_dominance_info (CDI_DOMINATORS);\n-  ipcp_modif_dom_walker walker (&fbi, descriptors, aggval, &modified_mem_access);\n+  ipcp_modif_dom_walker walker (&fbi, descriptors, ts, &modified_mem_access);\n   walker.walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   free_dominance_info (CDI_DOMINATORS);\n   cfg_changed |= walker.cleanup_eh ();\n@@ -6076,7 +6052,7 @@ ipcp_transform_function (struct cgraph_node *node)\n   fbi.bb_infos.release ();\n \n   ipcp_transformation *s = ipcp_transformation_sum->get (node);\n-  s->agg_values = NULL;\n+  s->m_agg_values = NULL;\n   s->bits = NULL;\n   s->m_vr = NULL;\n "}, {"sha": "008d34d0bc6e8026ff5b4a2901f92573631cc9ef", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 101, "deletions": 38, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0403e95689af7d562c7d04f706e9e25115747ff/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0403e95689af7d562c7d04f706e9e25115747ff/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=e0403e95689af7d562c7d04f706e9e25115747ff", "patch": "@@ -25,6 +25,11 @@ along with GCC; see the file COPYING3.  If not see\n \n #define IPA_UNDESCRIBED_USE -1\n \n+/* Index identifying an actualargument or a formal parameter may have only this\n+   many bits.  */\n+\n+#define IPA_PROP_ARG_INDEX_LIMIT_BITS 16\n+\n /* ipa-prop.cc stuff (ipa-cp, indirect inlining):  */\n \n /* A jump function for a callsite represents the values passed as actual\n@@ -184,6 +189,92 @@ struct GTY(()) ipa_agg_jump_function\n   bool by_ref;\n };\n \n+class ipcp_transformation;\n+\n+/* Element of a vector describing aggregate values for a number of arguments in\n+   a particular context, be it a call or the aggregate constants that a node is\n+   specialized for.  */\n+\n+struct GTY(()) ipa_argagg_value\n+{\n+  /* The constant value.  In the contexts where the list of known values is\n+     being pruned, NULL means a variable value.  */\n+  tree value;\n+  /* Unit offset within the aggregate.  */\n+  unsigned unit_offset;\n+  /* Index of the parameter, as it was in the original function (i.e. needs\n+     remapping after parameter modification is carried out as part of clone\n+     materialization).  */\n+  unsigned index : IPA_PROP_ARG_INDEX_LIMIT_BITS;\n+  /* Whether the value was passed by reference.  */\n+  unsigned by_ref : 1;\n+};\n+\n+/* A view into a sorted list of aggregate values in a particular context, be it\n+   a call or the aggregate constants that a node is specialized for.  The\n+   actual data is stored in the vector this has been constructed from.  */\n+\n+class ipa_argagg_value_list\n+{\n+public:\n+  ipa_argagg_value_list () = delete;\n+  ipa_argagg_value_list (const vec<ipa_argagg_value, va_gc> *values)\n+    : m_elts (values)\n+  {}\n+  ipa_argagg_value_list (const vec<ipa_argagg_value> *values)\n+    : m_elts (*values)\n+  {}\n+  ipa_argagg_value_list (const ipcp_transformation *tinfo);\n+\n+  /* Return the aggregate constant stored for INDEX at UNIT_OFFSET, if it is\n+     passed by reference or not according to BY_REF, or NULL_TREE\n+     otherwise.  */\n+\n+  tree get_value (int index, unsigned unit_offset, bool by_ref) const;\n+\n+  /* Return the aggregate constant stored for INDEX at UNIT_OFFSET, not\n+     performing any check of whether value is passed by reference.  Return\n+     NULL_TREE if there is no such constant.  */\n+\n+  tree get_value (int index, unsigned unit_offset) const;\n+\n+  /* Return the item describing a constant stored for INDEX at UNIT_OFFSET or\n+     NULL if there is no such constant.  */\n+\n+  const ipa_argagg_value *get_elt (int index, unsigned unit_offset) const;\n+\n+  /* Return the first item describing a constant stored for parameter with\n+     INDEX, regardless of offset or reference, or NULL if there is no such\n+     constant.  */\n+\n+  const ipa_argagg_value *get_elt_for_index (int index) const;\n+\n+  /* Return true if all elements present in OTHER are also present in this\n+     list.  */\n+\n+  bool superset_of_p (const ipa_argagg_value_list &other) const;\n+\n+  /* Push all items in this list that describe parameter SRC_INDEX into RES as\n+     ones describing DST_INDEX while subtracting UNIT_DELTA from their unit\n+     offsets but skip those which would end up with a negative offset.  */\n+\n+  void push_adjusted_values (unsigned src_index, unsigned dest_index,\n+\t\t\t     unsigned unit_delta,\n+\t\t\t     vec<ipa_argagg_value> *res) const;\n+\n+  /* Dump aggregate constants to FILE.  */\n+\n+  void dump (FILE *f);\n+\n+  /* Dump aggregate constants to stderr.  */\n+\n+  void DEBUG_FUNCTION debug ();\n+\n+  /* Array slice pointing to the actual storage.  */\n+\n+  array_slice<const ipa_argagg_value> m_elts;\n+};\n+\n /* An element in an aggregate part describing a known value at a given offset.\n    All unlisted positions are assumed to be unknown and all listed values must\n    fulfill is_gimple_ip_invariant.  */\n@@ -882,55 +973,38 @@ ipa_is_param_used_by_polymorphic_call (class ipa_node_params *info, int i)\n   return (*info->descriptors)[i].used_by_polymorphic_call;\n }\n \n-/* Information about replacements done in aggregates for a given node (each\n-   node has its linked list).  */\n-struct GTY(()) ipa_agg_replacement_value\n-{\n-  /* Next item in the linked list.  */\n-  struct ipa_agg_replacement_value *next;\n-  /* Offset within the aggregate.  */\n-  HOST_WIDE_INT offset;\n-  /* The constant value.  */\n-  tree value;\n-  /* The parameter index.  */\n-  int index;\n-  /* Whether the value was passed by reference.  */\n-  bool by_ref;\n-};\n-\n /* Structure holding information for the transformation phase of IPA-CP.  */\n \n struct GTY(()) ipcp_transformation\n {\n-  /* Linked list of known aggregate values.  */\n-  ipa_agg_replacement_value *agg_values;\n+  /* Known aggregate values.  */\n+  vec<ipa_argagg_value, va_gc>  *m_agg_values;\n   /* Known bits information.  */\n   vec<ipa_bits *, va_gc> *bits;\n   /* Value range information.  */\n   vec<ipa_vr, va_gc> *m_vr;\n \n   /* Default constructor.  */\n   ipcp_transformation ()\n-  : agg_values (NULL), bits (NULL), m_vr (NULL)\n+  : m_agg_values (NULL), bits (NULL), m_vr (NULL)\n   { }\n \n   /* Default destructor.  */\n   ~ipcp_transformation ()\n   {\n-    ipa_agg_replacement_value *agg = agg_values;\n-    while (agg)\n-      {\n-\tipa_agg_replacement_value *next = agg->next;\n-\tggc_free (agg);\n-\tagg = next;\n-      }\n+    vec_free (m_agg_values);\n     vec_free (bits);\n     vec_free (m_vr);\n   }\n };\n \n+inline\n+ipa_argagg_value_list::ipa_argagg_value_list (const ipcp_transformation *tinfo)\n+  : m_elts (tinfo->m_agg_values)\n+{}\n+\n void ipa_set_node_agg_value_chain (struct cgraph_node *node,\n-\t\t\t\t   struct ipa_agg_replacement_value *aggvals);\n+\t\t\t\t   vec<ipa_argagg_value, va_gc> *aggs);\n void ipcp_transformation_initialize (void);\n void ipcp_free_transformation_sum (void);\n \n@@ -1107,15 +1181,6 @@ ipcp_get_transformation_summary (cgraph_node *node)\n   return ipcp_transformation_sum->get (node);\n }\n \n-/* Return the aggregate replacements for NODE, if there are any.  */\n-\n-static inline struct ipa_agg_replacement_value *\n-ipa_get_agg_replacements_for_node (cgraph_node *node)\n-{\n-  ipcp_transformation *ts = ipcp_get_transformation_summary (node);\n-  return ts ? ts->agg_values : NULL;\n-}\n-\n /* Function formal parameters related computations.  */\n void ipa_initialize_node_params (struct cgraph_node *node);\n bool ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n@@ -1171,8 +1236,6 @@ struct ipcp_agg_lattice;\n \n extern object_allocator<ipcp_agg_lattice> ipcp_agg_lattice_pool;\n \n-void ipa_dump_agg_replacement_values (FILE *f,\n-\t\t\t\t      struct ipa_agg_replacement_value *av);\n void ipa_prop_write_jump_functions (void);\n void ipa_prop_read_jump_functions (void);\n void ipcp_write_transformation_summaries (void);"}, {"sha": "48bf77222b27253c247919397f2ec3a27e0bbc71", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-agg-11.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0403e95689af7d562c7d04f706e9e25115747ff/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0403e95689af7d562c7d04f706e9e25115747ff/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-11.c?ref=e0403e95689af7d562c7d04f706e9e25115747ff", "patch": "@@ -73,5 +73,5 @@ entry ()\n /* { dg-final { scan-ipa-dump \"offset: 0, type: int, CONST: 101\" \"cp\" } } */\n /* { dg-final { scan-ipa-dump \"offset: 32, type: int, PASS THROUGH: 0, op trunc_mod_expr 7\" \"cp\" } } */\n /* { dg-final { scan-ipa-dump \"offset: 64, type: int, LOAD AGG: 1 \\\\\\[offset: 0, by reference], op plus_expr 6\" \"cp\" } } */\n-/* { dg-final { scan-ipa-dump \"Aggregate replacements: 0\\\\\\[0]=1, 0\\\\\\[32]=105, 0\\\\\\[64]=-18\" \"cp\" } } */\n-/* { dg-final { scan-ipa-dump \"Aggregate replacements: 0\\\\\\[0]=101, 0\\\\\\[32]=2, 0\\\\\\[64]=9\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"Aggregate replacements: 0\\\\\\[0]=1\\\\(by_ref\\\\), 0\\\\\\[4]=105\\\\(by_ref\\\\), 0\\\\\\[8]=-18\\\\(by_ref\\\\)\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"Aggregate replacements: 0\\\\\\[0]=101, 0\\\\\\[4]=2, 0\\\\\\[8]=9\" \"cp\" } } */"}, {"sha": "8234702dd6e1bdfb9bf0b3d84a713b65eee31aa8", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-agg-8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0403e95689af7d562c7d04f706e9e25115747ff/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0403e95689af7d562c7d04f706e9e25115747ff/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-8.c?ref=e0403e95689af7d562c7d04f706e9e25115747ff", "patch": "@@ -48,5 +48,5 @@ entry (int c)\n       foo (4, i, &s);\n     }\n }\n-/* { dg-final { scan-ipa-dump \"Aggregate replacements: 1\\\\\\[32]=64, 1\\\\\\[64]=32\" \"cp\" } } */\n-/* { dg-final { scan-ipa-dump \"Aggregate replacements: 1\\\\\\[32]=0\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"Aggregate replacements: 1\\\\\\[4]=64\\\\(by_ref\\\\), 1\\\\\\[8]=32\\\\(by_ref\\\\)\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"Aggregate replacements: 1\\\\\\[4]=0\\\\(by_ref\\\\)\" \"cp\" } } */"}]}