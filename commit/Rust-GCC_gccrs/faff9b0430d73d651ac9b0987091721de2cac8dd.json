{"sha": "faff9b0430d73d651ac9b0987091721de2cac8dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFmZjliMDQzMGQ3M2Q2NTFhYzliMDk4NzA5MTcyMWRlMmNhYzhkZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-16T00:44:14Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-16T00:44:14Z"}, "message": "Check for errors from Gogo::call_builtin.\n\nFrom-SVN: r167891", "tree": {"sha": "1b059b5dfe7d55e61faf98f37d4e5c75160dde03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b059b5dfe7d55e61faf98f37d4e5c75160dde03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/faff9b0430d73d651ac9b0987091721de2cac8dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faff9b0430d73d651ac9b0987091721de2cac8dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faff9b0430d73d651ac9b0987091721de2cac8dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faff9b0430d73d651ac9b0987091721de2cac8dd/comments", "author": null, "committer": null, "parents": [{"sha": "0c5be64e9a453f80374662e9c54dc5d8df01ff2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c5be64e9a453f80374662e9c54dc5d8df01ff2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c5be64e9a453f80374662e9c54dc5d8df01ff2d"}], "stats": {"total": 64, "additions": 59, "deletions": 5}, "files": [{"sha": "6a7ba456e9cdbe4f656f8afd56ec477ef0573626", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faff9b0430d73d651ac9b0987091721de2cac8dd/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faff9b0430d73d651ac9b0987091721de2cac8dd/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=faff9b0430d73d651ac9b0987091721de2cac8dd", "patch": "@@ -505,6 +505,8 @@ Expression::convert_interface_to_interface(Translate_context* context,\n \t\t\t\t     lhs_type_descriptor,\n \t\t\t\t     TREE_TYPE(rhs_type_descriptor),\n \t\t\t\t     rhs_type_descriptor);\n+      if (call == error_mark_node)\n+\treturn error_mark_node;\n       // This will panic if the interface conversion fails.\n       TREE_NOTHROW(assert_interface_decl) = 0;\n       elt->value = fold_convert_loc(location, TREE_TYPE(field), call);\n@@ -535,6 +537,8 @@ Expression::convert_interface_to_interface(Translate_context* context,\n \t\t\t\t     lhs_type_descriptor,\n \t\t\t\t     TREE_TYPE(rhs_type_descriptor),\n \t\t\t\t     rhs_type_descriptor);\n+      if (call == error_mark_node)\n+\treturn error_mark_node;\n       // This will panic if the interface conversion fails.\n       TREE_NOTHROW(convert_interface_decl) = 0;\n       elt->value = fold_convert_loc(location, TREE_TYPE(field), call);\n@@ -599,6 +603,8 @@ Expression::convert_interface_to_type(Translate_context* context,\n \t\t\t\t rhs_type_descriptor,\n \t\t\t\t TREE_TYPE(rhs_inter_descriptor),\n \t\t\t\t rhs_inter_descriptor);\n+  if (call == error_mark_node)\n+    return error_mark_node;\n   // This call will panic if the conversion is invalid.\n   TREE_NOTHROW(check_interface_type_decl) = 0;\n \n@@ -6012,6 +6018,8 @@ Expression::comparison_tree(Translate_context* context, Operator op,\n \t\t\t\t\t descriptor,\n \t\t\t\t\t ptr_type_node,\n \t\t\t\t\t arg);\n+\t  if (left_tree == error_mark_node)\n+\t    return error_mark_node;\n \t  // This can panic if the type is not comparable.\n \t  TREE_NOTHROW(empty_interface_value_compare_decl) = 0;\n \t}\n@@ -6029,6 +6037,8 @@ Expression::comparison_tree(Translate_context* context, Operator op,\n \t\t\t\t\t descriptor,\n \t\t\t\t\t ptr_type_node,\n \t\t\t\t\t arg);\n+\t  if (left_tree == error_mark_node)\n+\t    return error_mark_node;\n \t  // This can panic if the type is not comparable.\n \t  TREE_NOTHROW(interface_value_compare_decl) = 0;\n \t}\n@@ -6054,6 +6064,8 @@ Expression::comparison_tree(Translate_context* context, Operator op,\n \t\t\t\t\t left_tree,\n \t\t\t\t\t TREE_TYPE(right_tree),\n \t\t\t\t\t right_tree);\n+\t  if (left_tree == error_mark_node)\n+\t    return error_mark_node;\n \t  // This can panic if the type is uncomparable.\n \t  TREE_NOTHROW(empty_interface_compare_decl) = 0;\n \t}\n@@ -6070,6 +6082,8 @@ Expression::comparison_tree(Translate_context* context, Operator op,\n \t\t\t\t\t left_tree,\n \t\t\t\t\t TREE_TYPE(right_tree),\n \t\t\t\t\t right_tree);\n+\t  if (left_tree == error_mark_node)\n+\t    return error_mark_node;\n \t  // This can panic if the type is uncomparable.\n \t  TREE_NOTHROW(interface_compare_decl) = 0;\n \t}\n@@ -7415,6 +7429,8 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\t\t\t\t\t   \"__go_print_space\",\n \t\t\t\t\t\t   0,\n \t\t\t\t\t\t   void_type_node);\n+\t\t    if (call == error_mark_node)\n+\t\t      return error_mark_node;\n \t\t    append_to_statement_list(call, &stmt_list);\n \t\t  }\n \n@@ -7513,8 +7529,9 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\t\t\t\t       void_type_node,\n \t\t\t\t\t       TREE_TYPE(arg),\n \t\t\t\t\t       arg);\n-\t\tif (call != error_mark_node)\n-\t\t  append_to_statement_list(call, &stmt_list);\n+\t\tif (call == error_mark_node)\n+\t\t  return error_mark_node;\n+\t\tappend_to_statement_list(call, &stmt_list);\n \t      }\n \t  }\n \n@@ -7526,6 +7543,8 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\t\t\t\t   \"__go_print_nl\",\n \t\t\t\t\t   0,\n \t\t\t\t\t   void_type_node);\n+\t    if (call == error_mark_node)\n+\t      return error_mark_node;\n \t    append_to_statement_list(call, &stmt_list);\n \t  }\n \n@@ -7552,6 +7571,8 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\t\t\t       void_type_node,\n \t\t\t\t       TREE_TYPE(arg_tree),\n \t\t\t\t       arg_tree);\n+\tif (call == error_mark_node)\n+\t  return error_mark_node;\n \t// This function will throw an exception.\n \tTREE_NOTHROW(panic_fndecl) = 0;\n \t// This function will not return.\n@@ -7604,6 +7625,8 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\t\t\t      0,\n \t\t\t\t      empty_tree);\n \t  }\n+\tif (call == error_mark_node)\n+\t  return error_mark_node;\n \treturn fold_build3_loc(location, COND_EXPR, empty_tree, arg_tree,\n \t\t\t       call, empty_nil_tree);\n       }\n@@ -9404,6 +9427,8 @@ String_index_expression::do_get_tree(Translate_context* context)\n \t\t\t\t    start_tree,\n \t\t\t\t    length_type,\n \t\t\t\t    end_tree);\n+      if (ret == error_mark_node)\n+\treturn error_mark_node;\n       // This will panic if the bounds are out of range for the\n       // string.\n       TREE_NOTHROW(strslice_fndecl) = 0;\n@@ -9573,6 +9598,8 @@ Map_index_expression::get_value_pointer(Translate_context* context,\n \t\t\t\t (insert\n \t\t\t\t  ? boolean_true_node\n \t\t\t\t  : boolean_false_node));\n+  if (call == error_mark_node)\n+    return error_mark_node;\n   // This can panic on a map of interface type if the interface holds\n   // an uncomparable or unhashable type.\n   TREE_NOTHROW(map_index_fndecl) = 0;\n@@ -11129,6 +11156,8 @@ Map_construction_expression::do_get_tree(Translate_context* context)\n \t\t\t\t TYPE_SIZE_UNIT(TREE_TYPE(val_field)),\n \t\t\t\t const_ptr_type_node,\n \t\t\t\t fold_convert(const_ptr_type_node, valaddr));\n+  if (call == error_mark_node)\n+    return error_mark_node;\n \n   tree ret;\n   if (make_tmp == NULL)"}, {"sha": "e43f64d7e1ae66d1547dddd8ae085a4006e4e2ab", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faff9b0430d73d651ac9b0987091721de2cac8dd/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faff9b0430d73d651ac9b0987091721de2cac8dd/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=faff9b0430d73d651ac9b0987091721de2cac8dd", "patch": "@@ -341,7 +341,8 @@ Gogo::register_gc_vars(const std::vector<Named_object*>& var_gc,\n \t\t\t\t void_type_node,\n \t\t\t\t build_pointer_type(root_list_type),\n \t\t\t\t build_fold_addr_expr(decl));\n-  append_to_statement_list(call, init_stmt_list);\n+  if (call != error_mark_node)\n+    append_to_statement_list(call, init_stmt_list);\n }\n \n // Build the decl for the initialization function.\n@@ -1684,7 +1685,8 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n \t\t\t\t void_type_node,\n \t\t\t\t ptr_type_node,\n \t\t\t\t this->defer_stack(end_loc));\n-  append_to_statement_list(call, &stmt_list);\n+  if (call != error_mark_node)\n+    append_to_statement_list(call, &stmt_list);\n \n   tree retval = this->return_value(gogo, named_function, end_loc, &stmt_list);\n   tree set;\n@@ -1723,7 +1725,8 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n \t\t\t\t    void_type_node,\n \t\t\t\t    ptr_type_node,\n \t\t\t\t    this->defer_stack(end_loc));\n-  TREE_NOTHROW(undefer_fndecl) = 0;\n+  if (undefer_fndecl != NULL_TREE)\n+    TREE_NOTHROW(undefer_fndecl) = 0;\n \n   tree defer = Gogo::call_builtin(&check_fndecl,\n \t\t\t\t  end_loc,\n@@ -2867,6 +2870,8 @@ Gogo::runtime_error(int code, source_location location)\n \t\t\t\tvoid_type_node,\n \t\t\t\tinteger_type_node,\n \t\t\t\tbuild_int_cst(integer_type_node, code));\n+  if (ret == error_mark_node)\n+    return error_mark_node;\n   // The runtime error function panics and does not return.\n   TREE_NOTHROW(runtime_error_fndecl) = 0;\n   TREE_THIS_VOLATILE(runtime_error_fndecl) = 1;\n@@ -2904,6 +2909,8 @@ Gogo::send_on_channel(tree channel, tree val, bool blocking, bool for_select,\n \t\t\t\t\t(for_select\n \t\t\t\t\t ? boolean_true_node\n \t\t\t\t\t : boolean_false_node));\n+\t  if (ret == error_mark_node)\n+\t    return error_mark_node;\n \t  // This can panic if there are too many operations on a\n \t  // closed channel.\n \t  TREE_NOTHROW(send_small_fndecl) = 0;\n@@ -2922,6 +2929,8 @@ Gogo::send_on_channel(tree channel, tree val, bool blocking, bool for_select,\n \t\t\t\t\tchannel,\n \t\t\t\t\tuint64_type_node,\n \t\t\t\t\tval);\n+\t  if (ret == error_mark_node)\n+\t    return error_mark_node;\n \t  // This can panic if there are too many operations on a\n \t  // closed channel.\n \t  TREE_NOTHROW(send_nonblocking_small_fndecl) = 0;\n@@ -2967,6 +2976,8 @@ Gogo::send_on_channel(tree channel, tree val, bool blocking, bool for_select,\n \t\t\t\t    (for_select\n \t\t\t\t     ? boolean_true_node\n \t\t\t\t     : boolean_false_node));\n+\t  if (call == error_mark_node)\n+\t    return error_mark_node;\n \t  // This can panic if there are too many operations on a\n \t  // closed channel.\n \t  TREE_NOTHROW(send_big_fndecl) = 0;\n@@ -2984,6 +2995,8 @@ Gogo::send_on_channel(tree channel, tree val, bool blocking, bool for_select,\n \t\t\t\t    channel,\n \t\t\t\t    ptr_type_node,\n \t\t\t\t    val);\n+\t  if (call == error_mark_node)\n+\t    return error_mark_node;\n \t  // This can panic if there are too many operations on a\n \t  // closed channel.\n \t  TREE_NOTHROW(send_nonblocking_big_fndecl) = 0;\n@@ -3025,6 +3038,8 @@ Gogo::receive_from_channel(tree type_tree, tree channel, bool for_select,\n \t\t\t\t     (for_select\n \t\t\t\t      ? boolean_true_node\n \t\t\t\t      : boolean_false_node));\n+      if (call == error_mark_node)\n+\treturn error_mark_node;\n       // This can panic if there are too many operations on a closed\n       // channel.\n       TREE_NOTHROW(receive_small_fndecl) = 0;\n@@ -3057,6 +3072,8 @@ Gogo::receive_from_channel(tree type_tree, tree channel, bool for_select,\n \t\t\t\t     (for_select\n \t\t\t\t      ? boolean_true_node\n \t\t\t\t      : boolean_false_node));\n+      if (call == error_mark_node)\n+\treturn error_mark_node;\n       // This can panic if there are too many operations on a closed\n       // channel.\n       TREE_NOTHROW(receive_big_fndecl) = 0;\n@@ -3114,6 +3131,8 @@ Gogo::make_trampoline(tree fnaddr, tree closure, source_location location)\n \t\t\t      ptr_type_node,\n \t\t\t      fold_convert_loc(location, ptr_type_node,\n \t\t\t\t\t       closure));\n+  if (x == error_mark_node)\n+    return error_mark_node;\n \n   x = save_expr(x);\n "}, {"sha": "ce389abdd7a0d28db75ec28a27069a4b581b9cd3", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faff9b0430d73d651ac9b0987091721de2cac8dd/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faff9b0430d73d651ac9b0987091721de2cac8dd/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=faff9b0430d73d651ac9b0987091721de2cac8dd", "patch": "@@ -4216,6 +4216,8 @@ Select_clauses::get_tree(Translate_context* context,\n \t\t\t\t chans_arg,\n \t\t\t\t pointer_boolean_type_tree,\n \t\t\t\t is_sends_arg);\n+  if (call == error_mark_node)\n+    return error_mark_node;\n \n   tree stmt_list = NULL_TREE;\n "}, {"sha": "bd0c7e5a58cdb0a8bb313b8c703c796252463b6f", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faff9b0430d73d651ac9b0987091721de2cac8dd/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faff9b0430d73d651ac9b0987091721de2cac8dd/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=faff9b0430d73d651ac9b0987091721de2cac8dd", "patch": "@@ -5094,6 +5094,8 @@ Map_type::do_make_expression_tree(Translate_context* context,\n \t\t\t\tcontext->gogo()->map_descriptor(this),\n \t\t\t\tsizetype,\n \t\t\t\texpr_tree);\n+  if (ret == error_mark_node)\n+    return error_mark_node;\n   // This can panic if the capacity is out of range.\n   TREE_NOTHROW(new_map_fndecl) = 0;\n \n@@ -5344,6 +5346,8 @@ Channel_type::do_make_expression_tree(Translate_context* context,\n \t\t\t\telement_size_tree,\n \t\t\t\tsizetype,\n \t\t\t\texpr_tree);\n+  if (ret == error_mark_node)\n+    return error_mark_node;\n   // This can panic if the capacity is out of range.\n   TREE_NOTHROW(new_channel_fndecl) = 0;\n "}]}