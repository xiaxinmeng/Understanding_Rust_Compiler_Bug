{"sha": "535808fd722db576f0f14424bc083fbef183fd4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM1ODA4ZmQ3MjJkYjU3NmYwZjE0NDI0YmMwODNmYmVmMTgzZmQ0Yg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-03-21T20:52:15Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-03-21T20:52:15Z"}, "message": "poly_span_traits fixes (PR 84811)\n\nThis patch fixes incorrect results for HOST_WIDE_INT positions\nat opposite extremes when used with HOST_WIDE_INT sizes.  It also\nfixes UB when comparing such positions with unsigned HOST_WIDE_INT\nsizes (although the results in that case were wrapv-correct).\n\n2018-03-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\tPR tree-optimization/84811\n\t* poly-int.h (poly_span_traits): Remove the T3 parameter and\n\tpromote HOST_WIDE_INT T2 - T1 results to unsigned HOST_WIDE_INT.\n\t(maybe_in_range_p, known_in_range_p, ranges_known_overlap_p):\n\t(known_subrange_p): Update accordingly.  Cast each value involved\n\tin the size comparison, rather than casting the result of the\n\tsubtraction.\n\ngcc/testsuite/\n\tPR tree-optimization/84811\n\t* gcc.dg/torture/pr84811.c: New test.\n\nFrom-SVN: r258743", "tree": {"sha": "46261783cb3e754715a50c28c60d025fc28af544", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46261783cb3e754715a50c28c60d025fc28af544"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/535808fd722db576f0f14424bc083fbef183fd4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/535808fd722db576f0f14424bc083fbef183fd4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/535808fd722db576f0f14424bc083fbef183fd4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/535808fd722db576f0f14424bc083fbef183fd4b/comments", "author": null, "committer": null, "parents": [{"sha": "e215422f1d6c69ae23b09de85a97bb3925cc5bfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e215422f1d6c69ae23b09de85a97bb3925cc5bfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e215422f1d6c69ae23b09de85a97bb3925cc5bfe"}], "stats": {"total": 107, "additions": 78, "deletions": 29}, "files": [{"sha": "2c5ed01e3f44b1cc0f1b03518325b91801383008", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535808fd722db576f0f14424bc083fbef183fd4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535808fd722db576f0f14424bc083fbef183fd4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=535808fd722db576f0f14424bc083fbef183fd4b", "patch": "@@ -1,3 +1,13 @@\n+2018-03-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/84811\n+\t* poly-int.h (poly_span_traits): Remove the T3 parameter and\n+\tpromote HOST_WIDE_INT T2 - T1 results to unsigned HOST_WIDE_INT.\n+\t(maybe_in_range_p, known_in_range_p, ranges_known_overlap_p):\n+\t(known_subrange_p): Update accordingly.  Cast each value involved\n+\tin the size comparison, rather than casting the result of the\n+\tsubtraction.\n+\n 2018-03-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/84982"}, {"sha": "62c39507952fd9e9350c67d22d4370c8e7ee1190", "filename": "gcc/poly-int.h", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535808fd722db576f0f14424bc083fbef183fd4b/gcc%2Fpoly-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535808fd722db576f0f14424bc083fbef183fd4b/gcc%2Fpoly-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpoly-int.h?ref=535808fd722db576f0f14424bc083fbef183fd4b", "patch": "@@ -2399,30 +2399,34 @@ print_dec (const poly_int_pod<N, C> &value, FILE *file)\n \t     poly_coeff_traits<C>::signedness ? SIGNED : UNSIGNED);\n }\n \n-/* Helper for correctly comparing Pos - Start with Size in cases where\n-   known_ge (Pos, Start), Pos and Start are potentially signed, and Size is\n-   potentially unsigned.  Applying the cast function to the result of\n-   Pos - Start gives the value that should be compared with the size.\n-\n-   Try to avoid doing any unnecessary arithmetic or copying.  */\n-template<typename Pos, typename Start, typename Size,\n-\t typename Diff = POLY_BINARY_COEFF (Start, Pos),\n-\t typename Res = POLY_BINARY_COEFF (Size, Diff)>\n+/* Helper for calculating the distance between two points P1 and P2,\n+   in cases where known_le (P1, P2).  T1 and T2 are the types of the\n+   two positions, in either order.  The coefficients of P2 - P1 have\n+   type unsigned HOST_WIDE_INT if the coefficients of both T1 and T2\n+   have C++ primitive type, otherwise P2 - P1 has its usual\n+   wide-int-based type.\n+\n+   The actual subtraction should look something like this:\n+\n+     typedef poly_span_traits<T1, T2> span_traits;\n+     span_traits::cast (P2) - span_traits::cast (P1)\n+\n+   Applying the cast before the subtraction avoids undefined overflow\n+   for signed T1 and T2.\n+\n+   The implementation of the cast tries to avoid unnecessary arithmetic\n+   or copying.  */\n+template<typename T1, typename T2,\n+\t typename Res = POLY_BINARY_COEFF (POLY_BINARY_COEFF (T1, T2),\n+\t\t\t\t\t   unsigned HOST_WIDE_INT)>\n struct poly_span_traits\n {\n-  /* Assume no cast is needed.  We'll get a warning about signed vs.\n-     unsigned comparisons if the assumption is wrong.  */\n   template<typename T>\n   static const T &cast (const T &x) { return x; }\n };\n \n-/* The only case a change in type is needed is this one, in which the\n-   subtraction would give a HOST_WIDE_INT-based result if done on poly_ints\n-   and adding a zero size would give an unsigned HOST_WIDE_INT-based\n-   result.  Since we know known_ge (Pos, Start), it is safe to treat\n-   Pos - Start as an unsigned HOST_WIDE_INT.  */\n-template<typename T1, typename T2, typename T3>\n-struct poly_span_traits<T1, T2, T3, HOST_WIDE_INT, unsigned HOST_WIDE_INT>\n+template<typename T1, typename T2>\n+struct poly_span_traits<T1, T2, unsigned HOST_WIDE_INT>\n {\n   template<typename T>\n   static typename if_nonpoly<T, unsigned HOST_WIDE_INT>::type\n@@ -2451,7 +2455,8 @@ template<typename T1, typename T2, typename T3>\n inline bool\n maybe_in_range_p (const T1 &val, const T2 &pos, const T3 &size)\n {\n-  typedef poly_span_traits<T1, T2, T3> span;\n+  typedef poly_span_traits<T1, T2> start_span;\n+  typedef poly_span_traits<T3, T3> size_span;\n   if (known_lt (val, pos))\n     return false;\n   if (!known_size_p (size))\n@@ -2462,7 +2467,8 @@ maybe_in_range_p (const T1 &val, const T2 &pos, const T3 &size)\n     /* In this case we don't know whether VAL >= POS is true at compile\n        time, so we can't prove that VAL >= POS + SIZE.  */\n     return true;\n-  return maybe_lt (span::cast (val - pos), size);\n+  return maybe_lt (start_span::cast (val) - start_span::cast (pos),\n+\t\t   size_span::cast (size));\n }\n \n /* Return true if range [POS, POS + SIZE) is known to include VAL.\n@@ -2473,10 +2479,12 @@ template<typename T1, typename T2, typename T3>\n inline bool\n known_in_range_p (const T1 &val, const T2 &pos, const T3 &size)\n {\n-  typedef poly_span_traits<T1, T2, T3> span;\n+  typedef poly_span_traits<T1, T2> start_span;\n+  typedef poly_span_traits<T3, T3> size_span;\n   return (known_size_p (size)\n \t  && known_ge (val, pos)\n-\t  && known_lt (span::cast (val - pos), size));\n+\t  && known_lt (start_span::cast (val) - start_span::cast (pos),\n+\t\t       size_span::cast (size)));\n }\n \n /* Return true if the two ranges [POS1, POS1 + SIZE1) and [POS2, POS2 + SIZE2)\n@@ -2504,8 +2512,9 @@ inline bool\n ranges_known_overlap_p (const T1 &pos1, const T2 &size1,\n \t\t\tconst T3 &pos2, const T4 &size2)\n {\n-  typedef poly_span_traits<T1, T3, T2> span1;\n-  typedef poly_span_traits<T1, T3, T4> span2;\n+  typedef poly_span_traits<T1, T3> start_span;\n+  typedef poly_span_traits<T2, T2> size1_span;\n+  typedef poly_span_traits<T4, T4> size2_span;\n   /* known_gt (POS1 + SIZE1, POS2)                         [infinite precision]\n      --> known_gt (SIZE1, POS2 - POS1)                     [infinite precision]\n      --> known_gt (SIZE1, POS2 - lower_bound (POS1, POS2)) [infinite precision]\n@@ -2520,8 +2529,12 @@ ranges_known_overlap_p (const T1 &pos1, const T2 &size1,\n      which the indeterminate is zero (the minimum value).  */\n   return (known_size_p (size1)\n \t  && known_size_p (size2)\n-\t  && known_lt (span1::cast (pos2 - lower_bound (pos1, pos2)), size1)\n-\t  && known_lt (span2::cast (pos1 - lower_bound (pos1, pos2)), size2));\n+\t  && known_lt (start_span::cast (pos2)\n+\t\t       - start_span::cast (lower_bound (pos1, pos2)),\n+\t\t       size1_span::cast (size1))\n+\t  && known_lt (start_span::cast (pos1)\n+\t\t       - start_span::cast (lower_bound (pos1, pos2)),\n+\t\t       size2_span::cast (size2)));\n }\n \n /* Return true if range [POS1, POS1 + SIZE1) is known to be a subrange of\n@@ -2534,15 +2547,16 @@ known_subrange_p (const T1 &pos1, const T2 &size1,\n \t\t  const T3 &pos2, const T4 &size2)\n {\n   typedef typename poly_int_traits<T2>::coeff_type C2;\n-  typedef POLY_BINARY_COEFF (T2, T4) size_diff_type;\n-  typedef poly_span_traits<T1, T3, size_diff_type> span;\n+  typedef poly_span_traits<T1, T3> start_span;\n+  typedef poly_span_traits<T2, T4> size_span;\n   return (known_gt (size1, POLY_INT_TYPE (T2) (0))\n \t  && (poly_coeff_traits<C2>::signedness > 0\n \t      || known_size_p (size1))\n \t  && known_size_p (size2)\n \t  && known_ge (pos1, pos2)\n \t  && known_le (size1, size2)\n-\t  && known_le (span::cast (pos1 - pos2), size2 - size1));\n+\t  && known_le (start_span::cast (pos1) - start_span::cast (pos2),\n+\t\t       size_span::cast (size2) - size_span::cast (size1)));\n }\n \n /* Return true if the endpoint of the range [POS, POS + SIZE) can be"}, {"sha": "36e16266c005e65ab70a53494cc2330c4436dcfc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535808fd722db576f0f14424bc083fbef183fd4b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535808fd722db576f0f14424bc083fbef183fd4b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=535808fd722db576f0f14424bc083fbef183fd4b", "patch": "@@ -1,3 +1,8 @@\n+2018-03-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/84811\n+\t* gcc.dg/torture/pr84811.c: New test.\n+\n 2018-03-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/84982"}, {"sha": "7cf7cf2cbcd67ca7b1790e53c41ac394ac3f3bcc", "filename": "gcc/testsuite/gcc.dg/torture/pr84811.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535808fd722db576f0f14424bc083fbef183fd4b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr84811.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535808fd722db576f0f14424bc083fbef183fd4b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr84811.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr84811.c?ref=535808fd722db576f0f14424bc083fbef183fd4b", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target lp64 } } */\n+\n+int a;\n+long b[1][9];\n+typedef long V __attribute__((vector_size (16), may_alias));\n+\n+void\n+foo ()\n+{\n+  V *c = (V *) ((char *) b + -9060696663385964544);\n+  *c = (V) { 1, 1 };\n+  c++;\n+  *c = (V) { 1, 1 };\n+  c++;\n+  *c = (V) { 1, 1 };\n+  c++;\n+  *c = (V) { 1, 1 };\n+  long __attribute__((may_alias)) *d = (long *) ((char *) b + 162675373468811328);\n+  *d = 1;\n+}"}]}