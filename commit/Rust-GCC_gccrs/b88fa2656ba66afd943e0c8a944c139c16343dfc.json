{"sha": "b88fa2656ba66afd943e0c8a944c139c16343dfc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg4ZmEyNjU2YmE2NmFmZDk0M2UwYzhhOTQ0YzEzOWMxNjM0M2RmYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2015-04-23T15:55:21Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-04-23T15:55:21Z"}, "message": "re PR c++/50800 (Internal compiler error in finish_member_declarations, possibly related to may_alias attribute)\n\n\tPR c++/50800\n\t* tree.c (strip_typedefs): Add remove_attributes parm.\n\t(strip_typedefs_expr): Likewise.\n\t(apply_identity_attributes): New subroutine of strip_typedefs.\n\t* pt.c (canonicalize_type_argument): Let strip_typedefs handle attrs.\n\t(convert_nontype_argument, unify): Likewise.\n\t* cp-tree.h: Adjust.\n\nFrom-SVN: r222377", "tree": {"sha": "d05c2d5aab8de47b924156998dfccc05465c5d69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d05c2d5aab8de47b924156998dfccc05465c5d69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b88fa2656ba66afd943e0c8a944c139c16343dfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b88fa2656ba66afd943e0c8a944c139c16343dfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b88fa2656ba66afd943e0c8a944c139c16343dfc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b88fa2656ba66afd943e0c8a944c139c16343dfc/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6c28362134af5aa01326e4fc3d38753b7fd42eba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c28362134af5aa01326e4fc3d38753b7fd42eba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c28362134af5aa01326e4fc3d38753b7fd42eba"}], "stats": {"total": 189, "additions": 136, "deletions": 53}, "files": [{"sha": "717aaa681782b6de28dbf18cf5bdb775f058a9c2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b88fa2656ba66afd943e0c8a944c139c16343dfc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b88fa2656ba66afd943e0c8a944c139c16343dfc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b88fa2656ba66afd943e0c8a944c139c16343dfc", "patch": "@@ -1,5 +1,13 @@\n 2015-04-23  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/50800\n+\t* tree.c (strip_typedefs): Add remove_attributes parm.\n+\t(strip_typedefs_expr): Likewise.\n+\t(apply_identity_attributes): New subroutine of strip_typedefs.\n+\t* pt.c (canonicalize_type_argument): Let strip_typedefs handle attrs.\n+\t(convert_nontype_argument, unify): Likewise.\n+\t* cp-tree.h: Adjust.\n+\n \tPR c++/65646\n \t* pt.c (check_explicit_specialization): Don't\n \tSET_DECL_TEMPLATE_SPECIALIZATION for a variable with no template"}, {"sha": "df03d1a146533b58623e1d8f3771f1cd9ce1ec77", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b88fa2656ba66afd943e0c8a944c139c16343dfc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b88fa2656ba66afd943e0c8a944c139c16343dfc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b88fa2656ba66afd943e0c8a944c139c16343dfc", "patch": "@@ -6066,8 +6066,8 @@ extern bool class_tmpl_impl_spec_p\t\t(const_tree);\n extern int zero_init_p\t\t\t\t(const_tree);\n extern bool check_abi_tag_redeclaration\t\t(const_tree, const_tree, const_tree);\n extern bool check_abi_tag_args\t\t\t(tree, tree);\n-extern tree strip_typedefs\t\t\t(tree);\n-extern tree strip_typedefs_expr\t\t\t(tree);\n+extern tree strip_typedefs\t\t\t(tree, bool * = NULL);\n+extern tree strip_typedefs_expr\t\t\t(tree, bool * = NULL);\n extern tree copy_binfo\t\t\t\t(tree, tree, tree,\n \t\t\t\t\t\t tree *, int);\n extern int member_p\t\t\t\t(const_tree);"}, {"sha": "ea0d3bc61b46c875b53be3b7b91fd1ce3e86bbb5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b88fa2656ba66afd943e0c8a944c139c16343dfc/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b88fa2656ba66afd943e0c8a944c139c16343dfc/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b88fa2656ba66afd943e0c8a944c139c16343dfc", "patch": "@@ -6493,20 +6493,14 @@ template_template_parm_bindings_ok_p (tree tparms, tree targs)\n static tree\n canonicalize_type_argument (tree arg, tsubst_flags_t complain)\n {\n-  tree mv;\n   if (!arg || arg == error_mark_node || arg == TYPE_CANONICAL (arg))\n     return arg;\n-  mv = TYPE_MAIN_VARIANT (arg);\n-  arg = strip_typedefs (arg);\n-  if (TYPE_ALIGN (arg) != TYPE_ALIGN (mv)\n-      || TYPE_ATTRIBUTES (arg) != TYPE_ATTRIBUTES (mv))\n-    {\n-      if (complain & tf_warning)\n-\twarning (0, \"ignoring attributes on template argument %qT\", arg);\n-      arg = build_aligned_type (arg, TYPE_ALIGN (mv));\n-      arg = cp_build_type_attribute_variant (arg, TYPE_ATTRIBUTES (mv));\n-    }\n-  return arg;\n+  bool removed_attributes = false;\n+  tree canon = strip_typedefs (arg, &removed_attributes);\n+  if (removed_attributes\n+      && (complain & tf_warning))\n+    warning (0, \"ignoring attributes on template argument %qT\", arg);\n+  return canon;\n }\n \n /* Convert the indicated template ARG as necessary to match the\n@@ -6743,7 +6737,10 @@ convert_template_argument (tree parm,\n \t   argument specification is valid.  */\n \tval = convert_nontype_argument (t, orig_arg, complain);\n       else\n-\tval = strip_typedefs_expr (orig_arg);\n+\t{\n+\t  bool removed_attr = false;\n+\t  val = strip_typedefs_expr (orig_arg, &removed_attr);\n+\t}\n \n       if (val == NULL_TREE)\n \tval = error_mark_node;\n@@ -18202,7 +18199,10 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \t  && !TEMPLATE_PARM_PARAMETER_PACK (parm))\n \treturn unify_parameter_pack_mismatch (explain_p, parm, arg);\n \n-      arg = strip_typedefs_expr (arg);\n+      {\n+\tbool removed_attr = false;\n+\targ = strip_typedefs_expr (arg, &removed_attr);\n+      }\n       TREE_VEC_ELT (INNERMOST_TEMPLATE_ARGS (targs), idx) = arg;\n       return unify_success (explain_p);\n "}, {"sha": "1c4cc57f1ad5bcaa26971aa9a4fba0f25ebce3f8", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 99, "deletions": 32, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b88fa2656ba66afd943e0c8a944c139c16343dfc/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b88fa2656ba66afd943e0c8a944c139c16343dfc/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=b88fa2656ba66afd943e0c8a944c139c16343dfc", "patch": "@@ -55,6 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-expr.h\"\n #include \"gimplify.h\"\n #include \"wide-int.h\"\n+#include \"attribs.h\"\n \n static tree bot_manip (tree *, int *, void *);\n static tree bot_replace (tree *, int *, void *);\n@@ -1175,6 +1176,52 @@ cv_unqualified (tree type)\n   return cp_build_qualified_type (type, quals);\n }\n \n+/* Subroutine of strip_typedefs.  We want to apply to RESULT the attributes\n+   from ATTRIBS that affect type identity, and no others.  If any are not\n+   applied, set *remove_attributes to true.  */\n+\n+static tree\n+apply_identity_attributes (tree result, tree attribs, bool *remove_attributes)\n+{\n+  tree first_ident = NULL_TREE;\n+  tree new_attribs = NULL_TREE;\n+  tree *p = &new_attribs;\n+\n+  for (tree a = TYPE_ATTRIBUTES (result); a; a = TREE_CHAIN (a))\n+    {\n+      const attribute_spec *as\n+\t= lookup_attribute_spec (get_attribute_name (a));\n+      if (as && as->affects_type_identity)\n+\t{\n+\t  if (!first_ident)\n+\t    first_ident = a;\n+\t  else if (first_ident == error_mark_node)\n+\t    {\n+\t      *p = tree_cons (TREE_PURPOSE (a), TREE_VALUE (a), NULL_TREE);\n+\t      p = &TREE_CHAIN (*p);\n+\t    }\n+\t}\n+      else if (first_ident)\n+\t{\n+\t  for (tree a2 = first_ident; a2; a2 = TREE_CHAIN (a2))\n+\t    {\n+\t      *p = tree_cons (TREE_PURPOSE (a2), TREE_VALUE (a2), NULL_TREE);\n+\t      p = &TREE_CHAIN (*p);\n+\t    }\n+\t  first_ident = error_mark_node;\n+\t}\n+    }\n+  if (first_ident != error_mark_node)\n+    new_attribs = first_ident;\n+\n+  if (first_ident == attribs)\n+    /* All attributes affected type identity.  */;\n+  else\n+    *remove_attributes = true;\n+\n+  return cp_build_type_attribute_variant (result, new_attribs);\n+}\n+\n /* Builds a qualified variant of T that is not a typedef variant.\n    E.g. consider the following declarations:\n      typedef const int ConstInt;\n@@ -1193,10 +1240,14 @@ cv_unqualified (tree type)\n     * If T is a type that needs structural equality\n       its TYPE_CANONICAL (T) will be NULL.\n     * TYPE_CANONICAL (T) desn't carry type attributes\n-      and loses template parameter names.   */\n+      and loses template parameter names.\n+\n+   If REMOVE_ATTRIBUTES is non-null, also strip attributes that don't\n+   affect type identity, and set the referent to true if any were\n+   stripped.  */\n \n tree\n-strip_typedefs (tree t)\n+strip_typedefs (tree t, bool *remove_attributes)\n {\n   tree result = NULL, type = NULL, t0 = NULL;\n \n@@ -1210,7 +1261,7 @@ strip_typedefs (tree t)\n       for (; t; t = TREE_CHAIN (t))\n \t{\n \t  gcc_assert (!TREE_PURPOSE (t));\n-\t  tree elt = strip_typedefs (TREE_VALUE (t));\n+\t  tree elt = strip_typedefs (TREE_VALUE (t), remove_attributes);\n \t  if (elt != TREE_VALUE (t))\n \t    changed = true;\n \t  vec_safe_push (vec, elt);\n@@ -1235,28 +1286,28 @@ strip_typedefs (tree t)\n   switch (TREE_CODE (t))\n     {\n     case POINTER_TYPE:\n-      type = strip_typedefs (TREE_TYPE (t));\n+      type = strip_typedefs (TREE_TYPE (t), remove_attributes);\n       result = build_pointer_type (type);\n       break;\n     case REFERENCE_TYPE:\n-      type = strip_typedefs (TREE_TYPE (t));\n+      type = strip_typedefs (TREE_TYPE (t), remove_attributes);\n       result = cp_build_reference_type (type, TYPE_REF_IS_RVALUE (t));\n       break;\n     case OFFSET_TYPE:\n-      t0 = strip_typedefs (TYPE_OFFSET_BASETYPE (t));\n-      type = strip_typedefs (TREE_TYPE (t));\n+      t0 = strip_typedefs (TYPE_OFFSET_BASETYPE (t), remove_attributes);\n+      type = strip_typedefs (TREE_TYPE (t), remove_attributes);\n       result = build_offset_type (t0, type);\n       break;\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (t))\n \t{\n-\t  t0 = strip_typedefs (TYPE_PTRMEMFUNC_FN_TYPE (t));\n+\t  t0 = strip_typedefs (TYPE_PTRMEMFUNC_FN_TYPE (t), remove_attributes);\n \t  result = build_ptrmemfunc_type (t0);\n \t}\n       break;\n     case ARRAY_TYPE:\n-      type = strip_typedefs (TREE_TYPE (t));\n-      t0  = strip_typedefs (TYPE_DOMAIN (t));;\n+      type = strip_typedefs (TREE_TYPE (t), remove_attributes);\n+      t0  = strip_typedefs (TYPE_DOMAIN (t), remove_attributes);\n       result = build_cplus_array_type (type, t0);\n       break;\n     case FUNCTION_TYPE:\n@@ -1269,7 +1320,8 @@ strip_typedefs (tree t)\n \t  {\n \t    if (arg_node == void_list_node)\n \t      break;\n-\t    arg_type = strip_typedefs (TREE_VALUE (arg_node));\n+\t    arg_type = strip_typedefs (TREE_VALUE (arg_node),\n+\t\t\t\t       remove_attributes);\n \t    gcc_assert (arg_type);\n \n \t    arg_types =\n@@ -1284,7 +1336,7 @@ strip_typedefs (tree t)\n \tif (arg_node)\n \t  arg_types = chainon (arg_types, void_list_node);\n \n-\ttype = strip_typedefs (TREE_TYPE (t));\n+\ttype = strip_typedefs (TREE_TYPE (t), remove_attributes);\n \tif (TREE_CODE (t) == METHOD_TYPE)\n \t  {\n \t    tree class_type = TREE_TYPE (TREE_VALUE (arg_types));\n@@ -1325,9 +1377,9 @@ strip_typedefs (tree t)\n \t\ttree arg = TREE_VEC_ELT (args, i);\n \t\ttree strip_arg;\n \t\tif (TYPE_P (arg))\n-\t\t  strip_arg = strip_typedefs (arg);\n+\t\t  strip_arg = strip_typedefs (arg, remove_attributes);\n \t\telse\n-\t\t  strip_arg = strip_typedefs_expr (arg);\n+\t\t  strip_arg = strip_typedefs_expr (arg, remove_attributes);\n \t\tTREE_VEC_ELT (new_args, i) = strip_arg;\n \t\tif (strip_arg != arg)\n \t\t  changed = true;\n@@ -1343,12 +1395,14 @@ strip_typedefs (tree t)\n \t    else\n \t      ggc_free (new_args);\n \t  }\n-\tresult = make_typename_type (strip_typedefs (TYPE_CONTEXT (t)),\n+\tresult = make_typename_type (strip_typedefs (TYPE_CONTEXT (t),\n+\t\t\t\t\t\t     remove_attributes),\n \t\t\t\t     fullname, typename_type, tf_none);\n       }\n       break;\n     case DECLTYPE_TYPE:\n-      result = strip_typedefs_expr (DECLTYPE_TYPE_EXPR (t));\n+      result = strip_typedefs_expr (DECLTYPE_TYPE_EXPR (t),\n+\t\t\t\t    remove_attributes);\n       if (result == DECLTYPE_TYPE_EXPR (t))\n \treturn t;\n       else\n@@ -1367,14 +1421,25 @@ strip_typedefs (tree t)\n       || TYPE_ALIGN (t) != TYPE_ALIGN (result))\n     {\n       gcc_assert (TYPE_USER_ALIGN (t));\n-      if (TYPE_ALIGN (t) == TYPE_ALIGN (result))\n-\tresult = build_variant_type_copy (result);\n+      if (remove_attributes)\n+\t*remove_attributes = true;\n       else\n-\tresult = build_aligned_type (result, TYPE_ALIGN (t));\n-      TYPE_USER_ALIGN (result) = true;\n+\t{\n+\t  if (TYPE_ALIGN (t) == TYPE_ALIGN (result))\n+\t    result = build_variant_type_copy (result);\n+\t  else\n+\t    result = build_aligned_type (result, TYPE_ALIGN (t));\n+\t  TYPE_USER_ALIGN (result) = true;\n+\t}\n     }\n   if (TYPE_ATTRIBUTES (t))\n-    result = cp_build_type_attribute_variant (result, TYPE_ATTRIBUTES (t));\n+    {\n+      if (remove_attributes)\n+\tresult = apply_identity_attributes (result, TYPE_ATTRIBUTES (t),\n+\t\t\t\t\t    remove_attributes);\n+      else\n+\tresult = cp_build_type_attribute_variant (result, TYPE_ATTRIBUTES (t));\n+    }\n   return cp_build_qualified_type (result, cp_type_quals (t));\n }\n \n@@ -1389,7 +1454,7 @@ strip_typedefs (tree t)\n    sizeof(TT) is replaced by sizeof(T).  */\n \n tree\n-strip_typedefs_expr (tree t)\n+strip_typedefs_expr (tree t, bool *remove_attributes)\n {\n   unsigned i,n;\n   tree r, type, *ops;\n@@ -1404,7 +1469,7 @@ strip_typedefs_expr (tree t)\n   /* Some expressions have type operands, so let's handle types here rather\n      than check TYPE_P in multiple places below.  */\n   if (TYPE_P (t))\n-    return strip_typedefs (t);\n+    return strip_typedefs (t, remove_attributes);\n \n   code = TREE_CODE (t);\n   switch (code)\n@@ -1418,8 +1483,8 @@ strip_typedefs_expr (tree t)\n \n     case TRAIT_EXPR:\n       {\n-\ttree type1 = strip_typedefs (TRAIT_EXPR_TYPE1 (t));\n-\ttree type2 = strip_typedefs (TRAIT_EXPR_TYPE2 (t));\n+\ttree type1 = strip_typedefs (TRAIT_EXPR_TYPE1 (t), remove_attributes);\n+\ttree type2 = strip_typedefs (TRAIT_EXPR_TYPE2 (t), remove_attributes);\n \tif (type1 == TRAIT_EXPR_TYPE1 (t)\n \t    && type2 == TRAIT_EXPR_TYPE2 (t))\n \t  return t;\n@@ -1436,7 +1501,7 @@ strip_typedefs_expr (tree t)\n \ttree it;\n \tfor (it = t; it; it = TREE_CHAIN (it))\n \t  {\n-\t    tree val = strip_typedefs_expr (TREE_VALUE (t));\n+\t    tree val = strip_typedefs_expr (TREE_VALUE (t), remove_attributes);\n \t    vec_safe_push (vec, val);\n \t    if (val != TREE_VALUE (t))\n \t      changed = true;\n@@ -1462,7 +1527,8 @@ strip_typedefs_expr (tree t)\n \tvec_safe_reserve (vec, n);\n \tfor (i = 0; i < n; ++i)\n \t  {\n-\t    tree op = strip_typedefs_expr (TREE_VEC_ELT (t, i));\n+\t    tree op = strip_typedefs_expr (TREE_VEC_ELT (t, i),\n+\t\t\t\t\t   remove_attributes);\n \t    vec->quick_push (op);\n \t    if (op != TREE_VEC_ELT (t, i))\n \t      changed = true;\n@@ -1487,17 +1553,18 @@ strip_typedefs_expr (tree t)\n \tvec<constructor_elt, va_gc> *vec\n \t  = vec_safe_copy (CONSTRUCTOR_ELTS (t));\n \tn = CONSTRUCTOR_NELTS (t);\n-\ttype = strip_typedefs (TREE_TYPE (t));\n+\ttype = strip_typedefs (TREE_TYPE (t), remove_attributes);\n \tfor (i = 0; i < n; ++i)\n \t  {\n \t    constructor_elt *e = &(*vec)[i];\n-\t    tree op = strip_typedefs_expr (e->value);\n+\t    tree op = strip_typedefs_expr (e->value, remove_attributes);\n \t    if (op != e->value)\n \t      {\n \t\tchanged = true;\n \t\te->value = op;\n \t      }\n-\t    gcc_checking_assert (e->index == strip_typedefs_expr (e->index));\n+\t    gcc_checking_assert\n+\t      (e->index == strip_typedefs_expr (e->index, remove_attributes));\n \t  }\n \n \tif (!changed && type == TREE_TYPE (t))\n@@ -1538,12 +1605,12 @@ strip_typedefs_expr (tree t)\n     case REINTERPRET_CAST_EXPR:\n     case CAST_EXPR:\n     case NEW_EXPR:\n-      type = strip_typedefs (type);\n+      type = strip_typedefs (type, remove_attributes);\n       /* fallthrough */\n \n     default:\n       for (i = 0; i < n; ++i)\n-\tops[i] = strip_typedefs_expr (TREE_OPERAND (t, i));\n+\tops[i] = strip_typedefs_expr (TREE_OPERAND (t, i), remove_attributes);\n       break;\n     }\n "}, {"sha": "a7032a0b24cb32f32ffc545e7f3733bf1f2ef205", "filename": "gcc/testsuite/g++.dg/abi/mangle40.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b88fa2656ba66afd943e0c8a944c139c16343dfc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle40.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b88fa2656ba66afd943e0c8a944c139c16343dfc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle40.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle40.C?ref=b88fa2656ba66afd943e0c8a944c139c16343dfc", "patch": "@@ -24,5 +24,5 @@ void f (T t) { }\t\t// { dg-warning \"mangled name\" }\n \n int main()\n {\n-  f (A<__m128>::t);\n+  f (A<__v4sf>::t);\n }"}, {"sha": "3806cb4539971b862e0932f60352c90fbcf84bd4", "filename": "gcc/testsuite/g++.dg/ext/alias-canon2.C", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b88fa2656ba66afd943e0c8a944c139c16343dfc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-canon2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b88fa2656ba66afd943e0c8a944c139c16343dfc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-canon2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-canon2.C?ref=b88fa2656ba66afd943e0c8a944c139c16343dfc", "patch": "@@ -31,6 +31,3 @@ out_long (ui64 longVal)\n         }\n     }\n }\n-\n-void f(ui32 *) { }\n-void f(ui32a *) { }"}, {"sha": "d804c1a8805bda294fcbc5c29b1eafbe995f1bb3", "filename": "gcc/testsuite/g++.dg/ext/alias-mangle.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b88fa2656ba66afd943e0c8a944c139c16343dfc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-mangle.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b88fa2656ba66afd943e0c8a944c139c16343dfc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-mangle.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Falias-mangle.C?ref=b88fa2656ba66afd943e0c8a944c139c16343dfc", "patch": "@@ -8,4 +8,4 @@ template<typename> struct A\n   A();\n };\n \n-A<X> a;\n+A<X> a;\t       // { dg-warning \"ignoring attributes on template argument\" }"}, {"sha": "9ff9918fb8039609e203e33043b9119bd98ad4ee", "filename": "gcc/testsuite/g++.dg/ext/attrib50.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b88fa2656ba66afd943e0c8a944c139c16343dfc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib50.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b88fa2656ba66afd943e0c8a944c139c16343dfc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib50.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib50.C?ref=b88fa2656ba66afd943e0c8a944c139c16343dfc", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/50800\n+\n+template <typename T> struct B;\n+template <typename T> struct B<T &> {\n+  typedef T type;\n+};\n+struct A {\n+  typedef int TA __attribute__((__may_alias__));\n+};\n+void d() { B<int &> b; }\n+int main() { B<A::TA &> b; }\t// { dg-warning \"attributes\" }"}]}