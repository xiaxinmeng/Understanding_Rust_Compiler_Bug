{"sha": "2b1fb720818a85d5c893ce65d140add40debf2ff", "node_id": "C_kwDOANBUbNoAKDJiMWZiNzIwODE4YTg1ZDVjODkzY2U2NWQxNDBhZGQ0MGRlYmYyZmY", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-10-25T20:44:51Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-10-27T09:40:16Z"}, "message": "[PR tree-optimization/107394] Canonicalize global franges as they are read back.\n\nThe problem here is that we're inlining a global range with NANs into\na function that has been tagged with __attribute__((optimize\n(\"-ffinite-math-only\"))).  As the global range is copied from\nSSA_NAME_RANGE_INFO, its NAN bits are copied, which then cause\nfrange::verify_range() to fail a sanity check making sure no NANs\ncreep in when !HONOR_NANS.\n\nI think what we should do is nuke the NAN bits as we're restoring the\nglobal range.  For that matter, if we use the frange constructor,\neverything except that NAN sign will be done automatically, including\ndropping INFs to the min/max representable range when appropriate.\n\n\tPR tree-optimization/107394\n\ngcc/ChangeLog:\n\n\t* value-range-storage.cc (frange_storage_slot::get_frange): Use\n\tfrange constructor.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/pr107394.c: New test.", "tree": {"sha": "e89fbf13fcc8de28fa6e8d83c6bec7489ca9c972", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e89fbf13fcc8de28fa6e8d83c6bec7489ca9c972"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b1fb720818a85d5c893ce65d140add40debf2ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b1fb720818a85d5c893ce65d140add40debf2ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b1fb720818a85d5c893ce65d140add40debf2ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b1fb720818a85d5c893ce65d140add40debf2ff/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9119431bc1563217c7c770035b0456d1e2bc596d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9119431bc1563217c7c770035b0456d1e2bc596d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9119431bc1563217c7c770035b0456d1e2bc596d"}], "stats": {"total": 55, "additions": 44, "deletions": 11}, "files": [{"sha": "0e1e5ac40cea42b5d6d9c52ee90c974088c181d3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr107394.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1fb720818a85d5c893ce65d140add40debf2ff/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr107394.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1fb720818a85d5c893ce65d140add40debf2ff/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr107394.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr107394.c?ref=2b1fb720818a85d5c893ce65d140add40debf2ff", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile }\n+// { dg-options \"-O2\" }\n+\n+static double\n+quux (double x)\n+{\n+  return __builtin_fabs (x);\n+}\n+\n+__attribute__ ((flatten, optimize (\"-ffinite-math-only\"))) static int\n+bar (int *p)\n+{\n+  *p = quux (0.0);\n+\n+  return 0;\n+}\n+\n+void\n+foo (int *p)\n+{\n+  (void) bar (p);\n+}"}, {"sha": "462447ba250a4d140c0f068000cbfb090bd7b08b", "filename": "gcc/value-range-storage.cc", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1fb720818a85d5c893ce65d140add40debf2ff/gcc%2Fvalue-range-storage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1fb720818a85d5c893ce65d140add40debf2ff/gcc%2Fvalue-range-storage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-storage.cc?ref=2b1fb720818a85d5c893ce65d140add40debf2ff", "patch": "@@ -261,17 +261,28 @@ frange_storage_slot::get_frange (frange &r, tree type) const\n {\n   gcc_checking_assert (r.supports_type_p (type));\n \n-  r.set_undefined ();\n-  r.m_kind = m_kind;\n-  r.m_type = type;\n-  r.m_min = m_min;\n-  r.m_max = m_max;\n-  r.m_pos_nan = m_pos_nan;\n-  r.m_neg_nan = m_neg_nan;\n-  r.normalize_kind ();\n-\n-  if (flag_checking)\n-    r.verify_range ();\n+  // Handle explicit NANs.\n+  if (m_kind == VR_NAN)\n+    {\n+      if (HONOR_NANS (type))\n+\t{\n+\t  if (m_pos_nan && m_neg_nan)\n+\t    r.set_nan (type);\n+\t  else\n+\t    r.set_nan (type, m_neg_nan);\n+\t}\n+      else\n+\tr.set_undefined ();\n+      return;\n+    }\n+\n+  // Use the constructor because it will canonicalize the range.\n+  r = frange (type, m_min, m_max, m_kind);\n+\n+  // The constructor will set the NAN bits for HONOR_NANS, but we must\n+  // make sure to set the NAN sign if known.\n+  if (HONOR_NANS (type) && (m_pos_nan ^ m_neg_nan) == 1)\n+    r.update_nan (m_neg_nan);\n }\n \n bool"}]}