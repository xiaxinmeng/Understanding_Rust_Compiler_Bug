{"sha": "3db72de3129796a961e3d495ee559cc5abb23c18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RiNzJkZTMxMjk3OTZhOTYxZTNkNDk1ZWU1NTljYzVhYmIyM2MxOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-10T21:12:57Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-10T21:12:57Z"}, "message": "i386.c (x86_output_mi_thunk): Generate rtl and run final, instead of emitting text directly.\n\n        * config/i386/i386.c (x86_output_mi_thunk): Generate rtl and\n        run final, instead of emitting text directly.\n\nFrom-SVN: r176128", "tree": {"sha": "2032883092cdb823d882ab1ce412c924c1556fdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2032883092cdb823d882ab1ce412c924c1556fdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3db72de3129796a961e3d495ee559cc5abb23c18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3db72de3129796a961e3d495ee559cc5abb23c18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3db72de3129796a961e3d495ee559cc5abb23c18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3db72de3129796a961e3d495ee559cc5abb23c18/comments", "author": null, "committer": null, "parents": [{"sha": "a1f91bca13c252376afb41e1fd14fe684beac5f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1f91bca13c252376afb41e1fd14fe684beac5f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1f91bca13c252376afb41e1fd14fe684beac5f1"}], "stats": {"total": 147, "additions": 77, "deletions": 70}, "files": [{"sha": "6f015ee2d5f4743c3ab6dc77d5872130c52a0dd1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db72de3129796a961e3d495ee559cc5abb23c18/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db72de3129796a961e3d495ee559cc5abb23c18/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3db72de3129796a961e3d495ee559cc5abb23c18", "patch": "@@ -1,3 +1,8 @@\n+2011-07-10  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.c (x86_output_mi_thunk): Generate rtl and\n+\trun final, instead of emitting text directly.\n+\n 2011-07-10  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/i386.c (ix86_option_override_internal): Turn on"}, {"sha": "f948a3282a16ecf3fead5f590eb6e1e6f76b7887", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 72, "deletions": 70, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db72de3129796a961e3d495ee559cc5abb23c18/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db72de3129796a961e3d495ee559cc5abb23c18/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3db72de3129796a961e3d495ee559cc5abb23c18", "patch": "@@ -29296,12 +29296,10 @@ x86_output_mi_thunk (FILE *file,\n \t\t     tree thunk ATTRIBUTE_UNUSED, HOST_WIDE_INT delta,\n \t\t     HOST_WIDE_INT vcall_offset, tree function)\n {\n-  rtx xops[3];\n   rtx this_param = x86_this_parameter (function);\n-  rtx this_reg, tmp;\n+  rtx this_reg, tmp, fnaddr;\n \n-  /* Make sure unwind info is emitted for the thunk if needed.  */\n-  final_start_function (emit_barrier (), file, 1);\n+  emit_note (NOTE_INSN_PROLOGUE_END);\n \n   /* If VCALL_OFFSET, we'll need THIS in a register.  Might as well\n      pull it in now and let DELTA benefit.  */\n@@ -29310,126 +29308,130 @@ x86_output_mi_thunk (FILE *file,\n   else if (vcall_offset)\n     {\n       /* Put the this parameter into %eax.  */\n-      xops[0] = this_param;\n-      xops[1] = this_reg = gen_rtx_REG (Pmode, AX_REG);\n-      output_asm_insn (\"mov%z1\\t{%0, %1|%1, %0}\", xops);\n+      this_reg = gen_rtx_REG (Pmode, AX_REG);\n+      emit_move_insn (this_reg, this_param);\n     }\n   else\n     this_reg = NULL_RTX;\n \n   /* Adjust the this parameter by a fixed constant.  */\n   if (delta)\n     {\n-      xops[0] = GEN_INT (delta);\n-      xops[1] = this_reg ? this_reg : this_param;\n+      rtx delta_rtx = GEN_INT (delta);\n+      rtx delta_dst = this_reg ? this_reg : this_param;\n+\n       if (TARGET_64BIT)\n \t{\n-\t  if (!x86_64_general_operand (xops[0], DImode))\n+\t  if (!x86_64_general_operand (delta_rtx, Pmode))\n \t    {\n-\t      tmp = gen_rtx_REG (DImode, R10_REG);\n-\t      xops[1] = tmp;\n-\t      output_asm_insn (\"mov{q}\\t{%1, %0|%0, %1}\", xops);\n-\t      xops[0] = tmp;\n-\t      xops[1] = this_param;\n+\t      tmp = gen_rtx_REG (Pmode, R10_REG);\n+\t      emit_move_insn (tmp, delta_rtx);\n+\t      delta_rtx = tmp;\n \t    }\n-\t  if (x86_maybe_negate_const_int (&xops[0], DImode))\n-\t    output_asm_insn (\"sub{q}\\t{%0, %1|%1, %0}\", xops);\n-\t  else\n-\t    output_asm_insn (\"add{q}\\t{%0, %1|%1, %0}\", xops);\n \t}\n-      else if (x86_maybe_negate_const_int (&xops[0], SImode))\n-\toutput_asm_insn (\"sub{l}\\t{%0, %1|%1, %0}\", xops);\n-      else\n-\toutput_asm_insn (\"add{l}\\t{%0, %1|%1, %0}\", xops);\n+\n+      emit_insn (ix86_gen_add3 (delta_dst, delta_dst, delta_rtx));\n     }\n \n   /* Adjust the this parameter by a value stored in the vtable.  */\n   if (vcall_offset)\n     {\n+      rtx vcall_addr, vcall_mem;\n+      unsigned int tmp_regno;\n+\n       if (TARGET_64BIT)\n-\ttmp = gen_rtx_REG (DImode, R10_REG);\n+\ttmp_regno = R10_REG;\n       else\n \t{\n-\t  int tmp_regno = CX_REG;\n \t  unsigned int ccvt = ix86_get_callcvt (TREE_TYPE (function));\n \t  if ((ccvt & (IX86_CALLCVT_FASTCALL | IX86_CALLCVT_THISCALL)) != 0)\n \t    tmp_regno = AX_REG;\n-\t  tmp = gen_rtx_REG (SImode, tmp_regno);\n+\t  else\n+\t    tmp_regno = CX_REG;\n \t}\n+      tmp = gen_rtx_REG (Pmode, tmp_regno);\n \n-      xops[0] = gen_rtx_MEM (Pmode, this_reg);\n-      xops[1] = tmp;\n-      output_asm_insn (\"mov%z1\\t{%0, %1|%1, %0}\", xops);\n+      emit_move_insn (tmp, gen_rtx_MEM (ptr_mode, this_reg));\n \n       /* Adjust the this parameter.  */\n-      xops[0] = gen_rtx_MEM (Pmode, plus_constant (tmp, vcall_offset));\n-      if (TARGET_64BIT && !memory_operand (xops[0], Pmode))\n+      vcall_addr = plus_constant (tmp, vcall_offset);\n+      if (TARGET_64BIT\n+\t  && !ix86_legitimate_address_p (ptr_mode, vcall_addr, true))\n \t{\n-\t  rtx tmp2 = gen_rtx_REG (DImode, R11_REG);\n-\t  xops[0] = GEN_INT (vcall_offset);\n-\t  xops[1] = tmp2;\n-\t  output_asm_insn (\"mov{q}\\t{%0, %1|%1, %0}\", xops);\n-\t  xops[0] = gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, tmp, tmp2));\n+\t  rtx tmp2 = gen_rtx_REG (Pmode, R11_REG);\n+\t  emit_move_insn (tmp2, GEN_INT (vcall_offset));\n+\t  vcall_addr = gen_rtx_PLUS (Pmode, tmp, tmp2);\n \t}\n-      xops[1] = this_reg;\n-      output_asm_insn (\"add%z1\\t{%0, %1|%1, %0}\", xops);\n+\n+      vcall_mem = gen_rtx_MEM (Pmode, vcall_addr);\n+      emit_insn (ix86_gen_add3 (this_reg, this_reg, vcall_mem));\n     }\n \n   /* If necessary, drop THIS back to its stack slot.  */\n   if (this_reg && this_reg != this_param)\n-    {\n-      xops[0] = this_reg;\n-      xops[1] = this_param;\n-      output_asm_insn (\"mov%z1\\t{%0, %1|%1, %0}\", xops);\n-    }\n+    emit_move_insn (this_param, this_reg);\n \n-  xops[0] = XEXP (DECL_RTL (function), 0);\n+  fnaddr = XEXP (DECL_RTL (function), 0);\n   if (TARGET_64BIT)\n     {\n       if (!flag_pic || targetm.binds_local_p (function)\n-\t  || DEFAULT_ABI == MS_ABI)\n-\toutput_asm_insn (\"jmp\\t%P0\", xops);\n-      /* All thunks should be in the same object as their target,\n-\t and thus binds_local_p should be true.  */\n-      else if (TARGET_64BIT && cfun->machine->call_abi == MS_ABI)\n-\tgcc_unreachable ();\n+\t  || cfun->machine->call_abi == MS_ABI)\n+\t;\n       else\n \t{\n-\t  tmp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, xops[0]), UNSPEC_GOTPCREL);\n+\t  tmp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, fnaddr), UNSPEC_GOTPCREL);\n \t  tmp = gen_rtx_CONST (Pmode, tmp);\n-\t  tmp = gen_rtx_MEM (QImode, tmp);\n-\t  xops[0] = tmp;\n-\t  output_asm_insn (\"jmp\\t%A0\", xops);\n+\t  fnaddr = gen_rtx_MEM (QImode, tmp);\n \t}\n     }\n   else\n     {\n       if (!flag_pic || targetm.binds_local_p (function))\n-\toutput_asm_insn (\"jmp\\t%P0\", xops);\n-      else\n+\t;\n #if TARGET_MACHO\n-\tif (TARGET_MACHO)\n-\t  {\n-\t    rtx sym_ref = XEXP (DECL_RTL (function), 0);\n-\t    if (TARGET_MACHO_BRANCH_ISLANDS)\n-\t      sym_ref = (gen_rtx_SYMBOL_REF\n+      else if (TARGET_MACHO)\n+\t{\n+\t  rtx sym_ref = XEXP (DECL_RTL (function), 0);\n+\t  if (TARGET_MACHO_BRANCH_ISLANDS)\n+\t    sym_ref = (gen_rtx_SYMBOL_REF\n \t\t   (Pmode,\n \t\t    machopic_indirection_name (sym_ref, /*stub_p=*/true)));\n-\t    tmp = gen_rtx_MEM (QImode, sym_ref);\n-\t    xops[0] = tmp;\n-\t    output_asm_insn (\"jmp\\t%0\", xops);\n-\t  }\n-\telse\n+\t  fnaddr = gen_rtx_MEM (QImode, sym_ref);\n+\t}\n #endif /* TARGET_MACHO */\n+      else\n \t{\n-\t  tmp = gen_rtx_REG (SImode, CX_REG);\n+\t  tmp = gen_rtx_REG (Pmode, CX_REG);\n \t  output_set_got (tmp, NULL_RTX);\n \n-\t  xops[1] = tmp;\n-\t  output_asm_insn (\"mov{l}\\t{%0@GOT(%1), %1|%1, %0@GOT[%1]}\", xops);\n-\t  output_asm_insn (\"jmp\\t{*}%1\", xops);\n+\t  fnaddr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, fnaddr), UNSPEC_GOT);\n+\t  fnaddr = gen_rtx_PLUS (Pmode, fnaddr, tmp);\n+\t  fnaddr = gen_rtx_MEM (Pmode, fnaddr);\n \t}\n     }\n+\n+  /* Our sibling call patterns do not allow memories, because we have no\n+     predicate that can distinguish between frame and non-frame memory.\n+     For our purposes here, we can get away with (ab)using a jump pattern,\n+     because we're going to do no optimization.  */\n+  if (MEM_P (fnaddr))\n+    emit_jump_insn (gen_indirect_jump (fnaddr));\n+  else\n+    {\n+      tmp = gen_rtx_MEM (QImode, fnaddr);\n+      tmp = gen_rtx_CALL (VOIDmode, tmp, const0_rtx);\n+      tmp = emit_call_insn (tmp);\n+      SIBLING_CALL_P (tmp) = 1;\n+    }\n+  emit_barrier ();\n+\n+  /* Emit just enough of rest_of_compilation to get the insns emitted.\n+     Note that use_thunk calls assemble_start_function et al.  */\n+  tmp = get_insns ();\n+  insn_locators_alloc ();\n+  shorten_branches (tmp);\n+  final_start_function (tmp, file, 1);\n+  final (tmp, file, 1);\n   final_end_function ();\n }\n "}]}