{"sha": "f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFiYTg4YjFiMjBjYjU3OWIzYjdjZTZjZTY1NDcwMjA1NzQyYmU3ZQ==", "commit": {"author": {"name": "Xiong Hu Luo", "email": "luoxhu@linux.ibm.com", "date": "2019-04-24T05:10:44Z"}, "committer": {"name": "Xiong Hu Luo", "email": "luoxhu@linux.vnet.ibm.com", "date": "2020-01-14T01:10:46Z"}, "message": "Missed function specialization + partial devirtualization\n\nv8:\n 1. Rebase to master with Martin's static function (r280043) comments merge.\n    Boostrap/testsuite/SPEC2017 tested pass on Power8-LE.\n 2. TODO:\n    2.1. C++ devirt for multiple speculative call targets.\n    2.2. ipa-icf ipa_merge_profiles refine with COMDAT inline testcase.\n\nThis patch aims to fix PR69678 caused by PGO indirect call profiling\nperformance issues.\nThe bug that profiling data is never working was fixed by Martin's pull\nback of topN patches, performance got GEOMEAN ~1% improvement(+24% for\n511.povray_r specifically).\nStill, currently the default profile only generates SINGLE indirect target\nthat called more than 75%.  This patch leverages MULTIPLE indirect\ntargets use in LTO-WPA and LTO-LTRANS stage, as a result, function\nspecialization, profiling, partial devirtualization, inlining and\ncloning could be done successfully based on it.\nPerformance can get improved from 0.70 sec to 0.38 sec on simple tests.\nDetails are:\n  1.  PGO with topn is enabled by default now, but only one indirect\n  target edge will be generated in ipa-profile pass, so add variables to enable\n  multiple speculative edges through passes, speculative_id will record the\n  direct edge index bind to the indirect edge, indirect_call_targets length\n  records how many direct edges owned by the indirect edge, postpone gimple_ic\n  to ipa-profile like default as inline pass will decide whether it is benefit\n  to transform indirect call.\n  2.  Use speculative_id to track and search the reference node matched\n  with the direct edge's callee for multiple targets.  Actually, it is the\n  caller's responsibility to handle the direct edges mapped to same indirect\n  edge.  speculative_call_info will return one of the direct edge specified,\n  this will leverage current IPA edge process framework mostly.\n  3.  Enable LTO WPA/LTRANS stage multiple indirect call targets analysis for\n  profile full support in ipa passes and cgraph_edge functions.  speculative_id\n  can be set by make_speculative id when multiple targets are binded to\n  one indirect edge, and cloned if new edge is cloned.  speculative_id\n  is streamed out and stream int by lto like lto_stmt_uid.\n  4.  Create and duplicate all speculative direct edge's call summary\n  in ipa-fnsummary.c with auto_vec.\n  5.  Add 1 in module testcase and 2 cross module testcases.\n  6.  Bootstrap and regression test passed on Power8-LE.  No function\n  and performance regression for SPEC2017.\n\ngcc/ChangeLog\n\n\t2020-01-14  Xiong Hu Luo  <luoxhu@linux.ibm.com>\n\n\tPR ipa/69678\n\t* cgraph.c (symbol_table::create_edge): Init speculative_id and\n\ttarget_prob.\n\t(cgraph_edge::make_speculative): Add param for setting speculative_id\n\tand target_prob.\n\t(cgraph_edge::speculative_call_info): Update comments and find reference\n\tby speculative_id for multiple indirect targets.\n\t(cgraph_edge::resolve_speculation): Decrease the speculations\n\tfor indirect edge, drop it's speculative if not direct target\n\tleft. Update comments.\n\t(cgraph_edge::redirect_call_stmt_to_callee): Likewise.\n\t(cgraph_node::dump): Print num_speculative_call_targets.\n\t(cgraph_node::verify_node): Don't report error if speculative\n\tedge not include statement.\n\t(cgraph_edge::num_speculative_call_targets_p): New function.\n\t* cgraph.h (int common_target_id): Remove.\n\t(int common_target_probability): Remove.\n\t(num_speculative_call_targets): New variable.\n\t(make_speculative): Add param for setting speculative_id.\n\t(cgraph_edge::num_speculative_call_targets_p): New declare.\n\t(target_prob): New variable.\n\t(speculative_id): New variable.\n\t* ipa-fnsummary.c (analyze_function_body): Create and duplicate\n\t  call summaries for multiple speculative call targets.\n\t* cgraphclones.c (cgraph_node::create_clone): Clone speculative_id.\n\t* ipa-profile.c (struct speculative_call_target): New struct.\n\t(class speculative_call_summary): New class.\n\t(class speculative_call_summaries): New class.\n\t(call_sums): New variable.\n\t(ipa_profile_generate_summary): Generate indirect multiple targets summaries.\n\t(ipa_profile_write_edge_summary): New function.\n\t(ipa_profile_write_summary): Stream out indirect multiple targets summaries.\n\t(ipa_profile_dump_all_summaries): New function.\n\t(ipa_profile_read_edge_summary): New function.\n\t(ipa_profile_read_summary_section): New function.\n\t(ipa_profile_read_summary): Stream in indirect multiple targets summaries.\n\t(ipa_profile): Generate num_speculative_call_targets from\n\tprofile summaries.\n\t* ipa-ref.h (speculative_id): New variable.\n\t* ipa-utils.c (ipa_merge_profiles): Update with target_prob.\n\t* lto-cgraph.c (lto_output_edge): Remove indirect common_target_id and\n\tcommon_target_probability.   Stream out speculative_id and\n\tnum_speculative_call_targets.\n\t(input_edge): Likewise.\n\t* predict.c (dump_prediction): Remove edges count assert to be\n\tprecise.\n\t* symtab.c (symtab_node::create_reference): Init speculative_id.\n\t(symtab_node::clone_references): Clone speculative_id.\n\t(symtab_node::clone_referring): Clone speculative_id.\n\t(symtab_node::clone_reference): Clone speculative_id.\n\t(symtab_node::clear_stmts_in_references): Clear speculative_id.\n\t* tree-inline.c (copy_bb): Duplicate all the speculative edges\n\tif indirect call contains multiple speculative targets.\n\t* value-prof.h  (check_ic_target): Remove.\n\t* value-prof.c  (gimple_value_profile_transformations):\n\tUse void function gimple_ic_transform.\n\t* value-prof.c  (gimple_ic_transform): Handle topn case.\n\tFix comment typos.  Change it to a void function.\n\ngcc/testsuite/ChangeLog\n\n\t2020-01-14  Xiong Hu Luo  <luoxhu@linux.ibm.com>\n\n\tPR ipa/69678\n\t* gcc.dg/tree-prof/indir-call-prof-topn.c: New testcase.\n\t* gcc.dg/tree-prof/crossmodule-indir-call-topn-1.c: New testcase.\n\t* gcc.dg/tree-prof/crossmodule-indir-call-topn-1a.c: New testcase.\n\t* gcc.dg/tree-prof/crossmodule-indir-call-topn-2.c: New testcase.\n\t* lib/scandump.exp: Dump executable file name.\n\t* lib/scanwpaipa.exp: New scan-pgo-wap-ipa-dump.", "tree": {"sha": "98070d8a50651dab76f87ca3470e7b1fad571a44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98070d8a50651dab76f87ca3470e7b1fad571a44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/comments", "author": {"login": "xionghul", "id": 4607154, "node_id": "MDQ6VXNlcjQ2MDcxNTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4607154?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xionghul", "html_url": "https://github.com/xionghul", "followers_url": "https://api.github.com/users/xionghul/followers", "following_url": "https://api.github.com/users/xionghul/following{/other_user}", "gists_url": "https://api.github.com/users/xionghul/gists{/gist_id}", "starred_url": "https://api.github.com/users/xionghul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xionghul/subscriptions", "organizations_url": "https://api.github.com/users/xionghul/orgs", "repos_url": "https://api.github.com/users/xionghul/repos", "events_url": "https://api.github.com/users/xionghul/events{/privacy}", "received_events_url": "https://api.github.com/users/xionghul/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "64378144aabf65bf3df2313191250accc042170e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64378144aabf65bf3df2313191250accc042170e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64378144aabf65bf3df2313191250accc042170e"}], "stats": {"total": 1103, "additions": 934, "deletions": 169}, "files": [{"sha": "07e5bebe909eabd884ff62fe371d9d95a8a63d31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -1,3 +1,64 @@\n+2020-01-14  Xiong Hu Luo  <luoxhu@linux.ibm.com>\n+\n+\tPR ipa/69678\n+\t* cgraph.c (symbol_table::create_edge): Init speculative_id and\n+\ttarget_prob.\n+\t(cgraph_edge::make_speculative): Add param for setting speculative_id\n+\tand target_prob.\n+\t(cgraph_edge::speculative_call_info): Update comments and find reference\n+\tby speculative_id for multiple indirect targets.\n+\t(cgraph_edge::resolve_speculation): Decrease the speculations\n+\tfor indirect edge, drop it's speculative if not direct target\n+\tleft. Update comments.\n+\t(cgraph_edge::redirect_call_stmt_to_callee): Likewise.\n+\t(cgraph_node::dump): Print num_speculative_call_targets.\n+\t(cgraph_node::verify_node): Don't report error if speculative\n+\tedge not include statement.\n+\t(cgraph_edge::num_speculative_call_targets_p): New function.\n+\t* cgraph.h (int common_target_id): Remove.\n+\t(int common_target_probability): Remove.\n+\t(num_speculative_call_targets): New variable.\n+\t(make_speculative): Add param for setting speculative_id.\n+\t(cgraph_edge::num_speculative_call_targets_p): New declare.\n+\t(target_prob): New variable.\n+\t(speculative_id): New variable.\n+\t* ipa-fnsummary.c (analyze_function_body): Create and duplicate\n+\t  call summaries for multiple speculative call targets.\n+\t* cgraphclones.c (cgraph_node::create_clone): Clone speculative_id.\n+\t* ipa-profile.c (struct speculative_call_target): New struct.\n+\t(class speculative_call_summary): New class.\n+\t(class speculative_call_summaries): New class.\n+\t(call_sums): New variable.\n+\t(ipa_profile_generate_summary): Generate indirect multiple targets summaries.\n+\t(ipa_profile_write_edge_summary): New function.\n+\t(ipa_profile_write_summary): Stream out indirect multiple targets summaries.\n+\t(ipa_profile_dump_all_summaries): New function.\n+\t(ipa_profile_read_edge_summary): New function.\n+\t(ipa_profile_read_summary_section): New function.\n+\t(ipa_profile_read_summary): Stream in indirect multiple targets summaries.\n+\t(ipa_profile): Generate num_speculative_call_targets from\n+\tprofile summaries.\n+\t* ipa-ref.h (speculative_id): New variable.\n+\t* ipa-utils.c (ipa_merge_profiles): Update with target_prob.\n+\t* lto-cgraph.c (lto_output_edge): Remove indirect common_target_id and\n+\tcommon_target_probability.   Stream out speculative_id and\n+\tnum_speculative_call_targets.\n+\t(input_edge): Likewise.\n+\t* predict.c (dump_prediction): Remove edges count assert to be\n+\tprecise.\n+\t* symtab.c (symtab_node::create_reference): Init speculative_id.\n+\t(symtab_node::clone_references): Clone speculative_id.\n+\t(symtab_node::clone_referring): Clone speculative_id.\n+\t(symtab_node::clone_reference): Clone speculative_id.\n+\t(symtab_node::clear_stmts_in_references): Clear speculative_id.\n+\t* tree-inline.c (copy_bb): Duplicate all the speculative edges\n+\tif indirect call contains multiple speculative targets.\n+\t* value-prof.h  (check_ic_target): Remove.\n+\t* value-prof.c  (gimple_value_profile_transformations):\n+\tUse void function gimple_ic_transform.\n+\t* value-prof.c  (gimple_ic_transform): Handle topn case.\n+\tFix comment typos.  Change it to a void function.\n+\n 2020-01-13  Andrew Pinski  <apinski@marvell.com>\n \n \t* config/aarch64/aarch64-cores.def (octeontx2): New define."}, {"sha": "95b523d6be552a3cc618e3bfbfcc346f041adb8e", "filename": "gcc/cgraph.c", "status": "modified", "additions": 101, "deletions": 16, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -858,6 +858,8 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n   edge->prev_callee = NULL;\n   edge->next_callee = NULL;\n   edge->lto_stmt_uid = 0;\n+  edge->target_prob = 0;\n+  edge->speculative_id = 0;\n \n   edge->count = count;\n   edge->call_stmt = call_stmt;\n@@ -1044,10 +1046,16 @@ cgraph_edge::remove (cgraph_edge *edge)\n    the reference representing the if conditional and attaches\n    them all to the original indirect call statement.  \n \n+   speculative_id is used to link direct calls with their corresponding\n+   IPA_REF_ADDR references when representing speculative calls.\n+\n+   target_prob is the probability of the speculative call.\n+\n    Return direct edge created.  */\n \n cgraph_edge *\n-cgraph_edge::make_speculative (cgraph_node *n2, profile_count direct_count)\n+cgraph_edge::make_speculative (cgraph_node *n2, profile_count direct_count,\n+\t\t\t       unsigned int speculative_id, int target_prob)\n {\n   cgraph_node *n = caller;\n   ipa_ref *ref = NULL;\n@@ -1065,24 +1073,53 @@ cgraph_edge::make_speculative (cgraph_node *n2, profile_count direct_count)\n   else\n     e2->can_throw_external = can_throw_external;\n   e2->lto_stmt_uid = lto_stmt_uid;\n+  e2->speculative_id = speculative_id;\n+  e2->target_prob = target_prob;\n   e2->in_polymorphic_cdtor = in_polymorphic_cdtor;\n   count -= e2->count;\n   symtab->call_edge_duplication_hooks (this, e2);\n   ref = n->create_reference (n2, IPA_REF_ADDR, call_stmt);\n   ref->lto_stmt_uid = lto_stmt_uid;\n+  ref->speculative_id = speculative_id;\n   ref->speculative = speculative;\n   n2->mark_address_taken ();\n   return e2;\n }\n \n-/* Speculative call consist of three components:\n-   1) an indirect edge representing the original call\n-   2) an direct edge representing the new call\n-   3) ADDR_EXPR reference representing the speculative check.\n-   All three components are attached to single statement (the indirect\n-   call) and if one of them exists, all of them must exist.\n+/* Speculative calls represent a transformation of indirect calls\n+   which may be later inserted into gimple in the following form:\n+\n+   if (call_dest == target1)\n+   target1 ();\n+   else if (call_dest == target2)\n+   target2 ();\n+   else\n+   call_dest ();\n+\n+   This is a win in the case when target1 and target2 are common values for\n+   call_dest as determined by ipa-devirt or indirect call profiling.\n+   In particular this may enable inlining and other optimizations.\n+\n+   Speculative call consists of the following main components:\n+\n+   1) One or more \"speculative\" direct call (num_speculative_call_targets is\n+   speculative direct call count belongs to the speculative indirect call)\n+   2) One or more IPA_REF_ADDR references (representing the fact that code above\n+   takes address of target1 and target2)\n+   3) The fallback \"speculative\" indirect call\n \n-   Given speculative call edge, return all three components.\n+   Direct calls and corresponding references are linked by\n+   speculative_id.\n+\n+   speculative_call_info returns triple\n+   (direct_call, indirect call, IPA_REF_ADDR reference)\n+   when called on one edge participating in the speculative call:\n+\n+   1) If called on direct call, its corresponding IPA_REF_ADDR and related\n+   indirect call are returned.\n+\n+   2) If called on indirect call, it will return one of direct edges and its\n+   matching IPA_REF_ADDR.\n  */\n \n void\n@@ -1122,7 +1159,7 @@ cgraph_edge::speculative_call_info (cgraph_edge *&direct,\n \n   reference = NULL;\n   for (i = 0; e->caller->iterate_reference (i, ref); i++)\n-    if (ref->speculative\n+    if (ref->speculative && ref->speculative_id == e->speculative_id\n \t&& ((ref->stmt && ref->stmt == e->call_stmt)\n \t    || (!ref->stmt && ref->lto_stmt_uid == e->lto_stmt_uid)))\n       {\n@@ -1138,9 +1175,18 @@ cgraph_edge::speculative_call_info (cgraph_edge *&direct,\n \n /* Speculative call EDGE turned out to be direct call to CALLEE_DECL.  Remove\n    the speculative call sequence and return edge representing the call, the\n-   original EDGE can be removed and deallocated.  It is up to caller to\n-   redirect the call as appropriate.  Return the edge that now represents the\n-   call.  */\n+   original EDGE can be removed and deallocated.  Return the edge that now\n+   represents the call.\n+\n+   For \"speculative\" indirect call that contains multiple \"speculative\"\n+   targets (i.e. edge->indirect_info->num_speculative_call_targets > 1),\n+   decrease the count and only remove current direct edge.\n+\n+   If no speculative direct call left to the speculative indirect call, remove\n+   the speculative of both the indirect call and corresponding direct edge.\n+\n+   It is up to caller to iteratively resolve each \"speculative\" direct call and\n+   redirect the call as appropriate.  */\n \n cgraph_edge *\n cgraph_edge::resolve_speculation (cgraph_edge *edge, tree callee_decl)\n@@ -1184,7 +1230,16 @@ cgraph_edge::resolve_speculation (cgraph_edge *edge, tree callee_decl)\n          in the functions inlined through it.  */\n     }\n   edge->count += e2->count;\n-  edge->speculative = false;\n+  if (edge->num_speculative_call_targets_p ())\n+    {\n+      /* The indirect edge has multiple speculative targets, don't remove\n+\t speculative until all related direct edges are resolved.  */\n+      edge->indirect_info->num_speculative_call_targets--;\n+      if (!edge->indirect_info->num_speculative_call_targets)\n+\tedge->speculative = false;\n+    }\n+  else\n+    edge->speculative = false;\n   e2->speculative = false;\n   ref->remove_reference ();\n   if (e2->indirect_unknown_callee || e2->inline_failed)\n@@ -1244,7 +1299,17 @@ cgraph_edge::make_direct (cgraph_edge *edge, cgraph_node *callee)\n \n /* If necessary, change the function declaration in the call statement\n    associated with E so that it corresponds to the edge callee.  Speculations\n-   can be resolved in the process and EDGE can be removed and deallocated.  */\n+   can be resolved in the process and EDGE can be removed and deallocated.\n+\n+   The edge could be one of speculative direct call generated from speculative\n+   indirect call.  In this circumstance, decrease the speculative targets\n+   count (i.e. num_speculative_call_targets) and redirect call stmt to the\n+   corresponding i-th target.  If no speculative direct call left to the\n+   speculative indirect call, remove \"speculative\" of the indirect call and\n+   also redirect stmt to it's final direct target.\n+\n+   It is up to caller to iteratively transform each \"speculative\"\n+   direct call as appropriate.  */\n \n gimple *\n cgraph_edge::redirect_call_stmt_to_callee (cgraph_edge *e)\n@@ -1290,7 +1355,17 @@ cgraph_edge::redirect_call_stmt_to_callee (cgraph_edge *e)\n \t  e->caller->set_call_stmt_including_clones (e->call_stmt, new_stmt,\n \t\t\t\t\t\t     false);\n \t  e->count = gimple_bb (e->call_stmt)->count;\n-\t  e2->speculative = false;\n+\t  if (e2->num_speculative_call_targets_p ())\n+\t    {\n+\t      /* The indirect edge has multiple speculative targets, don't\n+\t\t remove speculative until all related direct edges are\n+\t\t redirected.  */\n+\t      e2->indirect_info->num_speculative_call_targets--;\n+\t      if (!e2->indirect_info->num_speculative_call_targets)\n+\t\te2->speculative = false;\n+\t    }\n+\t  else\n+\t    e2->speculative = false;\n \t  e2->count = gimple_bb (e2->call_stmt)->count;\n \t  ref->speculative = false;\n \t  ref->stmt = NULL;\n@@ -2103,6 +2178,8 @@ cgraph_node::dump (FILE *f)\n \t  if (edge->indirect_info->vptr_changed)\n \t    fprintf (f, \" (vptr maybe changed)\");\n \t}\n+      fprintf (f, \" Num speculative call targets: %i\",\n+\t       edge->indirect_info->num_speculative_call_targets);\n       fprintf (f, \"\\n\");\n       if (edge->indirect_info->polymorphic)\n \tedge->indirect_info->context.dump (f);\n@@ -3393,7 +3470,7 @@ cgraph_node::verify_node (void)\n \n       for (e = callees; e; e = e->next_callee)\n \t{\n-\t  if (!e->aux)\n+\t  if (!e->aux && !e->speculative)\n \t    {\n \t      error (\"edge %s->%s has no corresponding call_stmt\",\n \t\t     identifier_to_locale (e->caller->name ()),\n@@ -3732,6 +3809,14 @@ cgraph_edge::possibly_call_in_translation_unit_p (void)\n   return node->get_availability () >= AVAIL_INTERPOSABLE;\n }\n \n+/* Return num_speculative_targets of this edge.  */\n+\n+int\n+cgraph_edge::num_speculative_call_targets_p (void)\n+{\n+  return indirect_info ? indirect_info->num_speculative_call_targets : 0;\n+}\n+\n /* A stashed copy of \"symtab\" for use by selftest::symbol_table_test.\n    This needs to be a global so that it can be a GC root, and thus\n    prevent the stashed copy from being garbage-collected if the GC runs"}, {"sha": "0ace13df1f96dcab5c55b58651b339d16980a336", "filename": "gcc/cgraph.h", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -1703,10 +1703,9 @@ class GTY(()) cgraph_indirect_call_info\n   int param_index;\n   /* ECF flags determined from the caller.  */\n   int ecf_flags;\n-  /* Profile_id of common target obtained from profile.  */\n-  int common_target_id;\n-  /* Probability that call will land in function with COMMON_TARGET_ID.  */\n-  int common_target_probability;\n+\n+  /* Number of speculative call targets, it's less than GCOV_TOPN_VALUES.  */\n+  unsigned num_speculative_call_targets : 16;\n \n   /* Set when the call is a virtual call with the parameter being the\n      associated object pointer rather than a simple direct call.  */\n@@ -1764,25 +1763,49 @@ class GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n \n   /* Turn edge into speculative call calling N2. Update\n      the profile so the direct call is taken COUNT times\n-     with FREQUENCY.  */\n-  cgraph_edge *make_speculative (cgraph_node *n2, profile_count direct_count);\n-\n-   /* Given speculative call edge, return all three components.  */\n+     with FREQUENCY.  speculative_id is used to link direct calls with their\n+     corresponding IPA_REF_ADDR references when representing speculative calls.\n+     target_prob is the probability of the speculative call.  */\n+  cgraph_edge *make_speculative (cgraph_node *n2, profile_count direct_count,\n+\t\t\t\t unsigned int speculative_id = 0,\n+\t\t\t\t int target_prob = 0);\n+\n+  /* Given speculative call edge, return all three components.  */\n   void speculative_call_info (cgraph_edge *&direct, cgraph_edge *&indirect,\n \t\t\t      ipa_ref *&reference);\n \n   /* Speculative call edge turned out to be direct call to CALLEE_DECL.  Remove\n      the speculative call sequence and return edge representing the call, the\n      original EDGE can be removed and deallocated.  It is up to caller to\n      redirect the call as appropriate.  Return the edge that now represents the\n-     call.  */\n+     call.\n+\n+     For \"speculative\" indirect call that contains multiple \"speculative\"\n+     targets (i.e. edge->indirect_info->num_speculative_call_targets > 1),\n+     decrease the count and only remove current direct edge.\n+\n+     If no speculative direct call left to the speculative indirect call, remove\n+     the speculative of both the indirect call and corresponding direct edge.\n+\n+     It is up to caller to iteratively resolve each \"speculative\" direct call\n+     and redirect the call as appropriate.  */\n   static cgraph_edge *resolve_speculation (cgraph_edge *edge,\n \t\t\t\t\t   tree callee_decl = NULL);\n \n   /* If necessary, change the function declaration in the call statement\n      associated with edge E so that it corresponds to the edge callee.\n      Speculations can be resolved in the process and EDGE can be removed and\n-     deallocated.  */\n+     deallocated.\n+\n+     The edge could be one of speculative direct call generated from speculative\n+     indirect call.  In this circumstance, decrease the speculative targets\n+     count (i.e. num_speculative_call_targets) and redirect call stmt to the\n+     corresponding i-th target.  If no speculative direct call left to the\n+     speculative indirect call, remove \"speculative\" of the indirect call and\n+     also redirect stmt to it's final direct target.\n+\n+     It is up to caller to iteratively transform each \"speculative\"\n+     direct call as appropriate.  */\n   static gimple *redirect_call_stmt_to_callee (cgraph_edge *e);\n \n   /* Create clone of edge in the node N represented\n@@ -1829,6 +1852,9 @@ class GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n      be internal to the current translation unit.  */\n   bool possibly_call_in_translation_unit_p (void);\n \n+  /* Return num_speculative_targets of this edge.  */\n+  int num_speculative_call_targets_p (void);\n+\n   /* Expected number of executions: calculated in profile.c.  */\n   profile_count count;\n   cgraph_node *caller;\n@@ -1848,6 +1874,11 @@ class GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   /* The stmt_uid of call_stmt.  This is used by LTO to recover the call_stmt\n      when the function is serialized in.  */\n   unsigned int lto_stmt_uid;\n+  /*  target_prob is the probability of the speculative call.  */\n+  unsigned int target_prob;\n+  /* speculative id is used to link direct calls with their corresponding\n+     IPA_REF_ADDR references when representing speculative calls.  */\n+  unsigned int speculative_id : 16;\n   /* Whether this edge was made direct by indirect inlining.  */\n   unsigned int indirect_inlining_edge : 1;\n   /* Whether this edge describes an indirect call with an undetermined"}, {"sha": "e73e0696b9169132b59ab3e06082ddff92fe9c71", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -133,6 +133,7 @@ cgraph_edge::clone (cgraph_node *n, gcall *call_stmt, unsigned stmt_uid,\n   new_edge->inline_failed = inline_failed;\n   new_edge->indirect_inlining_edge = indirect_inlining_edge;\n   new_edge->lto_stmt_uid = stmt_uid;\n+  new_edge->speculative_id = speculative_id;\n   /* Clone flags that depend on call_stmt availability manually.  */\n   new_edge->can_throw_external = can_throw_external;\n   new_edge->call_stmt_cannot_inline_p = call_stmt_cannot_inline_p;"}, {"sha": "4e1c587b10178b363a957593deeb3eafb2c20ecc", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -2604,14 +2604,34 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t      edge_set_predicate (edge, &bb_predicate);\n \t      if (edge->speculative)\n \t\t{\n-\t\t  cgraph_edge *direct, *indirect;\n+\t\t  cgraph_edge *direct, *indirect, *next_direct;\n \t\t  ipa_ref *ref;\n \t\t  edge->speculative_call_info (direct, indirect, ref);\n \t\t  gcc_assert (direct == edge);\n \t          ipa_call_summary *es2\n \t\t\t = ipa_call_summaries->get_create (indirect);\n \t\t  ipa_call_summaries->duplicate (edge, indirect,\n \t\t\t\t\t\t es, es2);\n+\n+\t\t  /* Create and duplicate call summaries for multiple\n+\t\t     speculative call targets.  */\n+\t\t  int num_specs = indirect->num_speculative_call_targets_p ();\n+\t\t  if (num_specs > 1)\n+\t\t    for (next_direct = edge->next_callee;\n+\t\t\t next_direct && --num_specs;\n+\t\t\t next_direct = next_direct->next_callee)\n+\t\t      {\n+\t\t\tnext_direct->speculative_call_info (direct, indirect,\n+\t\t\t\t\t\t\t    ref);\n+\t\t\tif (direct == next_direct && next_direct->speculative\n+\t\t\t    && edge->call_stmt == stmt)\n+\t\t\t  {\n+\t\t\t    ipa_call_summary *es3\n+\t\t\t      = ipa_call_summaries->get_create (next_direct);\n+\t\t\t    ipa_call_summaries->duplicate (edge, next_direct,\n+\t\t\t\t\t\t\t   es, es3);\n+\t\t\t  }\n+\t\t      }\n \t\t}\n \t    }\n "}, {"sha": "fc231c916b78e2455cbdc1bbccb01f3cc3c3c2ac", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 323, "deletions": 30, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -159,7 +159,99 @@ dump_histogram (FILE *file, vec<histogram_entry *> histogram)\n    }\n }\n \n-/* Collect histogram from CFG profiles.  */\n+/* Structure containing speculative target information from profile.  */\n+\n+struct speculative_call_target\n+{\n+  speculative_call_target (unsigned int id = 0, int prob = 0)\n+    : target_id (id), target_probability (prob)\n+  {\n+  }\n+\n+  /* Profile_id of target obtained from profile.  */\n+  unsigned int target_id;\n+  /* Probability that call will land in function with target_id.  */\n+  unsigned int target_probability;\n+};\n+\n+class speculative_call_summary\n+{\n+public:\n+  speculative_call_summary () : speculative_call_targets ()\n+  {}\n+\n+  auto_vec<speculative_call_target> speculative_call_targets;\n+\n+  void dump (FILE *f);\n+\n+};\n+\n+  /* Class to manage call summaries.  */\n+\n+class ipa_profile_call_summaries\n+  : public call_summary<speculative_call_summary *>\n+{\n+public:\n+  ipa_profile_call_summaries (symbol_table *table)\n+    : call_summary<speculative_call_summary *> (table)\n+  {}\n+\n+  /* Duplicate info when an edge is cloned.  */\n+  virtual void duplicate (cgraph_edge *, cgraph_edge *,\n+\t\t\t  speculative_call_summary *old_sum,\n+\t\t\t  speculative_call_summary *new_sum);\n+};\n+\n+static ipa_profile_call_summaries *call_sums = NULL;\n+\n+/* Dump all information in speculative call summary to F.  */\n+\n+void\n+speculative_call_summary::dump (FILE *f)\n+{\n+  cgraph_node *n2;\n+\n+  unsigned spec_count = speculative_call_targets.length ();\n+  for (unsigned i = 0; i < spec_count; i++)\n+    {\n+      speculative_call_target item = speculative_call_targets[i];\n+      n2 = find_func_by_profile_id (item.target_id);\n+      if (n2)\n+\tfprintf (f, \"    The %i speculative target is %s with prob %3.2f\\n\", i,\n+\t\t n2->dump_name (),\n+\t\t item.target_probability / (float) REG_BR_PROB_BASE);\n+      else\n+\tfprintf (f, \"    The %i speculative target is %u with prob %3.2f\\n\", i,\n+\t\t item.target_id,\n+\t\t item.target_probability / (float) REG_BR_PROB_BASE);\n+    }\n+}\n+\n+/* Duplicate info when an edge is cloned.  */\n+\n+void\n+ipa_profile_call_summaries::duplicate (cgraph_edge *, cgraph_edge *,\n+\t\t\t\t       speculative_call_summary *old_sum,\n+\t\t\t\t       speculative_call_summary *new_sum)\n+{\n+  if (!old_sum)\n+    return;\n+\n+  unsigned old_count = old_sum->speculative_call_targets.length ();\n+  if (!old_count)\n+    return;\n+\n+  new_sum->speculative_call_targets.reserve_exact (old_count);\n+  new_sum->speculative_call_targets.quick_grow_cleared (old_count);\n+\n+  for (unsigned i = 0; i < old_count; i++)\n+    {\n+      new_sum->speculative_call_targets[i]\n+\t= old_sum->speculative_call_targets[i];\n+    }\n+}\n+\n+/* Collect histogram and speculative target summaries from CFG profiles.  */\n \n static void\n ipa_profile_generate_summary (void)\n@@ -169,7 +261,10 @@ ipa_profile_generate_summary (void)\n   basic_block bb;\n \n   hash_table<histogram_hash> hashtable (10);\n-  \n+\n+  gcc_checking_assert (!call_sums);\n+  call_sums = new ipa_profile_call_summaries (symtab);\n+\n   FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n     if (ENTRY_BLOCK_PTR_FOR_FN (DECL_STRUCT_FUNCTION (node->decl))->count.ipa_p ())\n       FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (node->decl))\n@@ -191,23 +286,35 @@ ipa_profile_generate_summary (void)\n \t\t  if (h)\n \t\t    {\n \t\t      gcov_type val, count, all;\n-\t\t      if (get_nth_most_common_value (NULL, \"indirect call\", h,\n-\t\t\t\t\t\t     &val, &count, &all))\n+\t\t      struct cgraph_edge *e = node->get_edge (stmt);\n+\t\t      if (e && !e->indirect_unknown_callee)\n+\t\t\tcontinue;\n+\n+\t\t      speculative_call_summary *csum\n+\t\t\t= call_sums->get_create (e);\n+\n+\t\t      for (unsigned j = 0; j < GCOV_TOPN_VALUES; j++)\n \t\t\t{\n-\t\t\t  struct cgraph_edge * e = node->get_edge (stmt);\n-\t\t\t  if (e && !e->indirect_unknown_callee)\n+\t\t\t  if (!get_nth_most_common_value (NULL, \"indirect call\",\n+\t\t\t\t\t\t\t  h, &val, &count, &all,\n+\t\t\t\t\t\t\t  j))\n+\t\t\t    continue;\n+\n+\t\t\t  if (val == 0)\n \t\t\t    continue;\n \n-\t\t\t  e->indirect_info->common_target_id = val;\n-\t\t\t  e->indirect_info->common_target_probability\n-\t\t\t    = GCOV_COMPUTE_SCALE (count, all);\n-\t\t\t  if (e->indirect_info->common_target_probability > REG_BR_PROB_BASE)\n+\t\t\t  speculative_call_target item (\n+\t\t\t    val, GCOV_COMPUTE_SCALE (count, all));\n+\t\t\t  if (item.target_probability > REG_BR_PROB_BASE)\n \t\t\t    {\n \t\t\t      if (dump_file)\n-\t\t\t\tfprintf (dump_file, \"Probability capped to 1\\n\");\n-\t\t\t      e->indirect_info->common_target_probability = REG_BR_PROB_BASE;\n+\t\t\t\tfprintf (dump_file,\n+\t\t\t\t\t \"Probability capped to 1\\n\");\n+\t\t\t      item.target_probability = REG_BR_PROB_BASE;\n \t\t\t    }\n+\t\t\t  csum->speculative_call_targets.safe_push (item);\n \t\t\t}\n+\n \t\t      gimple_remove_histogram_value (DECL_STRUCT_FUNCTION (node->decl),\n \t\t\t\t\t\t      stmt, h);\n \t\t    }\n@@ -222,6 +329,33 @@ ipa_profile_generate_summary (void)\n   histogram.qsort (cmp_counts);\n }\n \n+/* Serialize the speculative summary info for LTO.  */\n+\n+static void\n+ipa_profile_write_edge_summary (lto_simple_output_block *ob,\n+\t\t\t\tspeculative_call_summary *csum)\n+{\n+  unsigned len = 0;\n+\n+  len = csum->speculative_call_targets.length ();\n+\n+  gcc_assert (len <= GCOV_TOPN_VALUES);\n+\n+  streamer_write_hwi_stream (ob->main_stream, len);\n+\n+  if (len)\n+    {\n+      unsigned spec_count = csum->speculative_call_targets.length ();\n+      for (unsigned i = 0; i < spec_count; i++)\n+\t{\n+\t  speculative_call_target item = csum->speculative_call_targets[i];\n+\t  gcc_assert (item.target_id);\n+\t  streamer_write_hwi_stream (ob->main_stream, item.target_id);\n+\t  streamer_write_hwi_stream (ob->main_stream, item.target_probability);\n+\t}\n+    }\n+}\n+\n /* Serialize the ipa info for lto.  */\n \n static void\n@@ -238,10 +372,122 @@ ipa_profile_write_summary (void)\n       streamer_write_uhwi_stream (ob->main_stream, histogram[i]->time);\n       streamer_write_uhwi_stream (ob->main_stream, histogram[i]->size);\n     }\n+\n+  if (!call_sums)\n+    return;\n+\n+  /* Serialize speculative targets information.  */\n+  unsigned int count = 0;\n+  lto_symtab_encoder_t encoder = ob->decl_state->symtab_node_encoder;\n+  lto_symtab_encoder_iterator lsei;\n+  cgraph_node *node;\n+\n+  for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n+       lsei_next_function_in_partition (&lsei))\n+    {\n+      node = lsei_cgraph_node (lsei);\n+      if (node->definition && node->has_gimple_body_p ()\n+\t  && node->indirect_calls)\n+\tcount++;\n+    }\n+\n+  streamer_write_uhwi_stream (ob->main_stream, count);\n+\n+  /* Process all of the functions.  */\n+  for (lsei = lsei_start_function_in_partition (encoder);\n+       !lsei_end_p (lsei) && count; lsei_next_function_in_partition (&lsei))\n+    {\n+      cgraph_node *node = lsei_cgraph_node (lsei);\n+      if (node->definition && node->has_gimple_body_p ()\n+\t  && node->indirect_calls)\n+\t{\n+\t  int node_ref = lto_symtab_encoder_encode (encoder, node);\n+\t  streamer_write_uhwi_stream (ob->main_stream, node_ref);\n+\n+\t  for (cgraph_edge *e = node->indirect_calls; e; e = e->next_callee)\n+\t    {\n+\t      speculative_call_summary *csum = call_sums->get_create (e);\n+\t      ipa_profile_write_edge_summary (ob, csum);\n+\t    }\n+      }\n+    }\n+\n   lto_destroy_simple_output_block (ob);\n }\n \n-/* Deserialize the ipa info for lto.  */\n+/* Dump all profile summary data for all cgraph nodes and edges to file F.  */\n+\n+static void\n+ipa_profile_dump_all_summaries (FILE *f)\n+{\n+  fprintf (dump_file,\n+\t   \"\\n========== IPA-profile speculative targets: ==========\\n\");\n+  cgraph_node *node;\n+  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n+    {\n+      fprintf (f, \"\\nSummary for node %s:\\n\", node->dump_name ());\n+      for (cgraph_edge *e = node->indirect_calls; e; e = e->next_callee)\n+\t{\n+\t  fprintf (f, \"  Summary for %s of indirect edge %d:\\n\",\n+\t\t   e->caller->dump_name (), e->lto_stmt_uid);\n+\t  speculative_call_summary *csum = call_sums->get_create (e);\n+\t  csum->dump (f);\n+\t}\n+    }\n+  fprintf (f, \"\\n\\n\");\n+}\n+\n+/* Read speculative targets information about edge for LTO WPA.  */\n+\n+static void\n+ipa_profile_read_edge_summary (class lto_input_block *ib, cgraph_edge *edge)\n+{\n+  unsigned i, len;\n+\n+  len = streamer_read_hwi (ib);\n+  gcc_assert (len <= GCOV_TOPN_VALUES);\n+\n+  speculative_call_summary *csum = call_sums->get_create (edge);\n+\n+  for (i = 0; i < len; i++)\n+  {\n+    speculative_call_target item (streamer_read_hwi (ib),\n+\tstreamer_read_hwi (ib));\n+    csum->speculative_call_targets.safe_push (item);\n+  }\n+}\n+\n+/* Read profile speculative targets section information for LTO WPA.  */\n+\n+static void\n+ipa_profile_read_summary_section (struct lto_file_decl_data *file_data,\n+\t\t\t\t  class lto_input_block *ib)\n+{\n+  if (!ib)\n+    return;\n+\n+  lto_symtab_encoder_t encoder = file_data->symtab_node_encoder;\n+\n+  unsigned int count = streamer_read_uhwi (ib);\n+\n+  unsigned int i;\n+  unsigned int index;\n+  cgraph_node * node;\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      index = streamer_read_uhwi (ib);\n+      encoder = file_data->symtab_node_encoder;\n+      node\n+\t= dyn_cast<cgraph_node *> (lto_symtab_encoder_deref (encoder, index));\n+\n+      for (cgraph_edge *e = node->indirect_calls; e; e = e->next_callee)\n+\tipa_profile_read_edge_summary (ib, e);\n+    }\n+}\n+\n+/* Deserialize the IPA histogram and speculative targets summary info for LTO.\n+   */\n \n static void\n ipa_profile_read_summary (void)\n@@ -253,6 +499,9 @@ ipa_profile_read_summary (void)\n \n   hash_table<histogram_hash> hashtable (10);\n \n+  gcc_checking_assert (!call_sums);\n+  call_sums = new ipa_profile_call_summaries (symtab);\n+\n   while ((file_data = file_data_vec[j++]))\n     {\n       const char *data;\n@@ -273,6 +522,9 @@ ipa_profile_read_summary (void)\n \t      account_time_size (&hashtable, histogram,\n \t\t\t\t count, time, size);\n \t    }\n+\n+\t  ipa_profile_read_summary_section (file_data, ib);\n+\n \t  lto_destroy_simple_input_block (file_data,\n \t\t\t\t\t  LTO_section_ipa_profile,\n \t\t\t\t\t  ib, data, len);\n@@ -512,6 +764,7 @@ ipa_profile (void)\n   int nindirect = 0, ncommon = 0, nunknown = 0, nuseless = 0, nconverted = 0;\n   int nmismatch = 0, nimpossible = 0;\n   bool node_map_initialized = false;\n+  gcov_type threshold;\n \n   if (dump_file)\n     dump_histogram (dump_file, histogram);\n@@ -520,14 +773,12 @@ ipa_profile (void)\n       overall_time += histogram[i]->count * histogram[i]->time;\n       overall_size += histogram[i]->size;\n     }\n+  threshold = 0;\n   if (overall_time)\n     {\n-      gcov_type threshold;\n-\n       gcc_assert (overall_size);\n \n       cutoff = (overall_time * param_hot_bb_count_ws_permille + 500) / 1000;\n-      threshold = 0;\n       for (i = 0; cumulated < cutoff; i++)\n \t{\n \t  cumulated += histogram[i]->count * histogram[i]->time;\n@@ -563,10 +814,21 @@ ipa_profile (void)\n   histogram.release ();\n   histogram_pool.release ();\n \n-  /* Produce speculative calls: we saved common target from porfiling into\n-     e->common_target_id.  Now, at link time, we can look up corresponding\n+  /* Produce speculative calls: we saved common target from profiling into\n+     e->target_id.  Now, at link time, we can look up corresponding\n      function node and produce speculative call.  */\n \n+  gcc_checking_assert (call_sums);\n+\n+  if (dump_file)\n+    {\n+      if (!node_map_initialized)\n+\tinit_node_map (false);\n+      node_map_initialized = true;\n+\n+      ipa_profile_dump_all_summaries (dump_file);\n+    }\n+\n   FOR_EACH_DEFINED_FUNCTION (n)\n     {\n       bool update = false;\n@@ -578,13 +840,35 @@ ipa_profile (void)\n \t{\n \t  if (n->count.initialized_p ())\n \t    nindirect++;\n-\t  if (e->indirect_info->common_target_id)\n+\n+\t  speculative_call_summary *csum = call_sums->get_create (e);\n+\t  unsigned spec_count = csum->speculative_call_targets.length ();\n+\t  if (spec_count)\n \t    {\n \t      if (!node_map_initialized)\n-\t        init_node_map (false);\n+\t\tinit_node_map (false);\n \t      node_map_initialized = true;\n \t      ncommon++;\n-\t      n2 = find_func_by_profile_id (e->indirect_info->common_target_id);\n+\n+\t      if (in_lto_p)\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    {\n+\t\t      fprintf (dump_file,\n+\t\t\t       \"Updating hotness threshold in LTO mode.\\n\");\n+\t\t      fprintf (dump_file, \"Updated min count: %\" PRId64 \"\\n\",\n+\t\t\t       (int64_t) threshold / spec_count);\n+\t\t    }\n+\t\t  set_hot_bb_threshold (threshold / spec_count);\n+\t\t}\n+\n+\t      unsigned speculative_id = 0;\n+\t      bool speculative_found = false;\n+\t      for (unsigned i = 0; i < spec_count; i++)\n+\t      {\n+\t      speculative_call_target item\n+\t\t= csum->speculative_call_targets[i];\n+\t      n2 = find_func_by_profile_id (item.target_id);\n \t      if (n2)\n \t\t{\n \t\t  if (dump_file)\n@@ -593,11 +877,10 @@ ipa_profile (void)\n \t\t\t       \" other module %s => %s, prob %3.2f\\n\",\n \t\t\t       n->dump_name (),\n \t\t\t       n2->dump_name (),\n-\t\t\t       e->indirect_info->common_target_probability\n-\t\t\t       / (float)REG_BR_PROB_BASE);\n+\t\t\t       item.target_probability\n+\t\t\t\t / (float) REG_BR_PROB_BASE);\n \t\t    }\n-\t\t  if (e->indirect_info->common_target_probability\n-\t\t      < REG_BR_PROB_BASE / 2)\n+\t\t  if (item.target_probability < REG_BR_PROB_BASE / 2)\n \t\t    {\n \t\t      nuseless++;\n \t\t      if (dump_file)\n@@ -653,20 +936,26 @@ ipa_profile (void)\n \t\t\t    n2 = alias;\n \t\t\t}\n \t\t      nconverted++;\n-\t\t      e->make_speculative\n-\t\t\t(n2,\n-\t\t\t e->count.apply_probability\n-\t\t\t\t     (e->indirect_info->common_target_probability));\n+\t\t      e->make_speculative (n2,\n+\t\t\t\t\t   e->count.apply_probability (\n+\t\t\t\t\t     item.target_probability),\n+\t\t\t\t\t   speculative_id,\n+\t\t\t\t\t   item.target_probability);\n \t\t      update = true;\n+\t\t      speculative_id++;\n+\t\t      speculative_found = true;\n \t\t    }\n \t\t}\n \t      else\n \t\t{\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"Function with profile-id %i not found.\\n\",\n-\t\t\t     e->indirect_info->common_target_id);\n+\t\t\t     item.target_id);\n \t\t  nunknown++;\n \t\t}\n+\t       }\n+\t     if (speculative_found)\n+\t       e->indirect_info->num_speculative_call_targets = speculative_id;\n \t    }\n \t }\n        if (update)\n@@ -729,6 +1018,10 @@ ipa_profile (void)\n \t}\n     }\n   free (order);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    symtab->dump (dump_file);\n+\n   return 0;\n }\n "}, {"sha": "1de5bd34b82cd3d732d74546eca428491efc8f8a", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -59,6 +59,9 @@ struct GTY(()) ipa_ref\n   symtab_node *referred;\n   gimple *stmt;\n   unsigned int lto_stmt_uid;\n+  /* speculative id is used to link direct calls with their corresponding\n+     IPA_REF_ADDR references when representing speculative calls.  */\n+  unsigned int speculative_id : 16;\n   unsigned int referred_index;\n   ENUM_BITFIELD (ipa_ref_use) use:3;\n   unsigned int speculative:1;"}, {"sha": "587ad5c6360f91519fe9914284428c5dc70a3c49", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 119, "deletions": 54, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -675,68 +675,133 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t   e2 = (e2 ? e2->next_callee : NULL), e = e->next_callee)\n \t{\n \t  profile_count count = gimple_bb (e->call_stmt)->count;\n+\t  /* Below code are introduced by r279373 of \"Fix merging of common\n+\t     traget info.\".\n+\n+\t     ipa-icf runs after ipa-profile, common_target_id with\n+\t     common_target_probablity are useless in ipa-icf since they are\n+\t     moved from cgraph.h to ipa-profile.c and processed already.\n+\t     Need double circulation to find out each mapped direct speculative\n+\t     edge and do prob merge.  Not easy to construct a case to cover all\n+\t     circumstances here.  For src and dst both have multiple speculative\n+\t     targets, only N:N maps are implemented, 2:0, 2:1, 0:2, 1:2 are not\n+\t     implemented yet as too complicated and no test cases to cover.  */\n \t  if (copy_counts)\n \t    {\n-\t      e->indirect_info->common_target_id\n-\t\t      = e2->indirect_info->common_target_id;\n-\t      e->indirect_info->common_target_probability\n-\t\t      = e2->indirect_info->common_target_probability;\n+\t      /* copy if both e and e2 have same num_speculative_call_targets.\n+\t       */\n+\t      if (e->num_speculative_call_targets_p ()\n+\t\t  == e2->num_speculative_call_targets_p ())\n+\t\t{\n+\t\t  int num_specs = e->num_speculative_call_targets_p ();\n+\t\t  cgraph_edge *direct, *indirect, *next_direct;\n+\t\t  cgraph_edge *direct2, *indirect2, *next_direct2;\n+\t\t  ipa_ref *ref;\n+\t\t  for (next_direct = e; next_direct && num_specs--;\n+\t\t       next_direct = direct->next_callee)\n+\t\t    {\n+\t\t      next_direct->speculative_call_info (direct, indirect,\n+\t\t\t\t\t\t\t  ref);\n+\n+\t\t      int num_specs2 = e2->num_speculative_call_targets_p ();\n+\t\t      for (next_direct2 = e2; next_direct2 && num_specs2--;\n+\t\t\t   next_direct2 = direct2->next_callee)\n+\t\t\t{\n+\t\t\t  if (e2 && e2->speculative)\n+\t\t\t    next_direct2->speculative_call_info (direct2,\n+\t\t\t\t\t\t\t\t indirect2,\n+\t\t\t\t\t\t\t\t ref);\n+\t\t\t  if (direct->speculative_id == direct2->speculative_id\n+\t\t\t      && direct->lto_stmt_uid == direct2->lto_stmt_uid)\n+\t\t\t    {\n+\t\t\t      direct->target_prob = direct2->target_prob;\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tgcc_assert (e->num_speculative_call_targets_p ()\n+\t\t\t    && e->num_speculative_call_targets_p ());\n \t    }\n-\t  else if (e->indirect_info->common_target_id\n-\t\t   || e2->indirect_info->common_target_id)\n+\t  else if (e->num_speculative_call_targets_p ()\n+\t\t   || e2->num_speculative_call_targets_p ())\n \t    {\n-\t      sreal scale1\n-\t\t = e->count.ipa().to_sreal_scale (count);\n-\t      sreal scale2\n-\t\t = e2->count.ipa().to_sreal_scale (count);\n-\n-\t      if (scale1 == 0 && scale2 == 0)\n-\t\tscale1 = scale2 = 1;\n-\t      sreal sum = scale1 + scale2;\n-\t      int scaled_probability1\n-\t\t      = ((sreal)e->indirect_info->common_target_probability\n-\t\t\t* scale1 / sum).to_int ();\n-\t      int scaled_probability2\n-\t\t      = ((sreal)e2->indirect_info->common_target_probability\n-\t\t\t * scale2 / sum).to_int ();\n-\t      if (symtab->dump_file)\n+\t      if (e->num_speculative_call_targets_p ()\n+\t\t  == e2->num_speculative_call_targets_p ())\n \t\t{\n-\t\t  fprintf (symtab->dump_file,\n-\t\t\t   \"Merging common targets %i prob %i\"\n-\t\t\t   \" and %i prob %i with scales %f %f\\n\",\n-\t\t\t   e->indirect_info->common_target_id,\n-\t\t\t   e->indirect_info->common_target_probability,\n-\t\t\t   e2->indirect_info->common_target_id,\n-\t\t\t   e2->indirect_info->common_target_probability,\n-\t\t\t   scale1.to_double (),\n-\t\t\t   scale2.to_double ());\n-\t\t  fprintf (symtab->dump_file, \"Combined BB count \");\n-\t\t  count.dump (symtab->dump_file);\n-\t\t  fprintf (symtab->dump_file, \" dst edge count \");\n-\t\t  e->count.dump (symtab->dump_file);\n-\t\t  fprintf (symtab->dump_file, \" src edge count \");\n-\t\t  e2->count.dump (symtab->dump_file);\n-\t\t  fprintf (symtab->dump_file, \"\\n\");\n+\t\t  int num_specs = e->num_speculative_call_targets_p ();\n+\t\t  cgraph_edge *direct, *indirect, *next_direct;\n+\t\t  cgraph_edge *direct2, *indirect2, *next_direct2;\n+\t\t  ipa_ref *ref;\n+\t\t  for (next_direct = e; next_direct && num_specs--;\n+\t\t       next_direct = direct->next_callee)\n+\t\t    {\n+\t\t      next_direct->speculative_call_info (direct, indirect,\n+\t\t\t\t\t\t\t  ref);\n+\n+\t\t      int num_specs2 = e2->num_speculative_call_targets_p ();\n+\t\t      for (next_direct2 = e2; next_direct2 && num_specs2--;\n+\t\t\t   next_direct2 = direct2->next_callee)\n+\t\t\t{\n+\t\t\t  if (e2 && e2->speculative)\n+\t\t\t    next_direct2->speculative_call_info (direct2,\n+\t\t\t\t\t\t\t\t indirect2,\n+\t\t\t\t\t\t\t\t ref);\n+\t\t\t  if (direct->speculative_id == direct2->speculative_id\n+\t\t\t      && direct->lto_stmt_uid == direct2->lto_stmt_uid)\n+\t\t\t    {\n+\t\t\t      sreal scale1\n+\t\t\t\t= e->count.ipa ().to_sreal_scale (count);\n+\t\t\t      sreal scale2\n+\t\t\t\t= e2->count.ipa ().to_sreal_scale (count);\n+\n+\t\t\t      if (scale1 == 0 && scale2 == 0)\n+\t\t\t\tscale1 = scale2 = 1;\n+\t\t\t      sreal sum = scale1 + scale2;\n+\t\t\t      int scaled_prob1\n+\t\t\t\t= (((sreal)direct->target_prob)\n+\t\t\t\t   * scale1 / sum).to_int ();\n+\t\t\t      int scaled_prob2\n+\t\t\t\t= (((sreal)direct2->target_prob)\n+\t\t\t\t   * scale2 / sum).to_int ();\n+\t\t\t      if (symtab->dump_file)\n+\t\t\t\t{\n+\t\t\t\t  fprintf (\n+\t\t\t\t    symtab->dump_file,\n+\t\t\t\t    \"Merging speculative id %i prob %i\"\n+\t\t\t\t    \" and %i prob %i with scales %f %f\\n\",\n+\t\t\t\t    direct->speculative_id, direct->target_prob,\n+\t\t\t\t    direct2->speculative_id,\n+\t\t\t\t    direct2->target_prob, scale1.to_double (),\n+\t\t\t\t    scale2.to_double ());\n+\t\t\t\t  fprintf (symtab->dump_file,\n+\t\t\t\t\t   \"Combined BB count \");\n+\t\t\t\t  count.dump (symtab->dump_file);\n+\t\t\t\t  fprintf (symtab->dump_file,\n+\t\t\t\t\t   \" dst edge count \");\n+\t\t\t\t  e->count.dump (symtab->dump_file);\n+\t\t\t\t  fprintf (symtab->dump_file,\n+\t\t\t\t\t   \" src edge count \");\n+\t\t\t\t  e2->count.dump (symtab->dump_file);\n+\t\t\t\t  fprintf (symtab->dump_file, \"\\n\");\n+\t\t\t\t}\n+\t\t\t      direct->target_prob = scaled_prob1 + scaled_prob2;\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n \t\t}\n-\t      if (e->indirect_info->common_target_id\n-\t\t  == e2->indirect_info->common_target_id)\n-\t\te->indirect_info->common_target_probability\n-\t\t       \t= scaled_probability1 + scaled_probability2;\n-\t      else if (!e2->indirect_info->common_target_id\n-\t\t       || scaled_probability1 > scaled_probability2)\n-\t\te->indirect_info->common_target_probability\n-\t\t       \t= scaled_probability1;\n-\t      else \n+\t      else if (e->num_speculative_call_targets_p ())\n \t\t{\n-\t\t  e->indirect_info->common_target_id\n-\t\t\t  = e2->indirect_info->common_target_id;\n-\t\t  e->indirect_info->common_target_probability\n-\t\t\t  = scaled_probability2;\n+\t\t  /* Process if only dst is speculative.  */\n+\t\t  gcc_assert (!e->num_speculative_call_targets_p ());\n+\t\t}\n+\t      else if (e2->num_speculative_call_targets_p ())\n+\t\t{\n+\t\t  /* Process if only src is speculative.  */\n+\t\t  gcc_assert (!e2->num_speculative_call_targets_p ());\n \t\t}\n-\t      if (symtab->dump_file)\n-\t\tfprintf (symtab->dump_file, \"Merged as %i prob %i\\n\",\n-\t\t\t e->indirect_info->common_target_id,\n-\t\t\t e->indirect_info->common_target_probability);\n \t    }\n \n \t  /* When call is speculative, we need to re-distribute probabilities"}, {"sha": "621607499e1fd47e68f74e665061db4782b919d0", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -262,6 +262,7 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n   bp_pack_enum (&bp, cgraph_inline_failed_t,\n \t        CIF_N_REASONS, edge->inline_failed);\n   bp_pack_var_len_unsigned (&bp, uid);\n+  bp_pack_value (&bp, edge->speculative_id, 16);\n   bp_pack_value (&bp, edge->indirect_inlining_edge, 1);\n   bp_pack_value (&bp, edge->speculative, 1);\n   bp_pack_value (&bp, edge->call_stmt_cannot_inline_p, 1);\n@@ -284,16 +285,11 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n \t\t\t     | ECF_SIBCALL\n \t\t\t     | ECF_LEAF\n \t\t\t     | ECF_NOVOPS)));\n+\n+      bp_pack_value (&bp, edge->indirect_info->num_speculative_call_targets,\n+\t\t     16);\n     }\n   streamer_write_bitpack (&bp);\n-  if (edge->indirect_unknown_callee)\n-    {\n-      streamer_write_hwi_stream (ob->main_stream,\n-\t\t\t         edge->indirect_info->common_target_id);\n-      if (edge->indirect_info->common_target_id)\n-\tstreamer_write_hwi_stream\n-\t   (ob->main_stream, edge->indirect_info->common_target_probability);\n-    }\n }\n \n /* Return if NODE contain references from other partitions.  */\n@@ -690,6 +686,8 @@ lto_output_ref (struct lto_simple_output_block *ob, struct ipa_ref *ref,\n       if (ref->stmt)\n \tuid = gimple_uid (ref->stmt) + 1;\n       streamer_write_hwi_stream (ob->main_stream, uid);\n+      bp_pack_value (&bp, ref->speculative_id, 16);\n+      streamer_write_bitpack (&bp);\n     }\n }\n \n@@ -1428,7 +1426,11 @@ input_ref (class lto_input_block *ib,\n   ref = referring_node->create_reference (node, use);\n   ref->speculative = speculative;\n   if (is_a <cgraph_node *> (referring_node))\n-    ref->lto_stmt_uid = streamer_read_hwi (ib);\n+    {\n+      ref->lto_stmt_uid = streamer_read_hwi (ib);\n+      bp = streamer_read_bitpack (ib);\n+      ref->speculative_id = bp_unpack_value (&bp, 16);\n+    }\n }\n \n /* Read an edge from IB.  NODES points to a vector of previously read nodes for\n@@ -1442,7 +1444,7 @@ input_edge (class lto_input_block *ib, vec<symtab_node *> nodes,\n {\n   struct cgraph_node *caller, *callee;\n   struct cgraph_edge *edge;\n-  unsigned int stmt_id;\n+  unsigned int stmt_id, speculative_id;\n   profile_count count;\n   cgraph_inline_failed_t inline_failed;\n   struct bitpack_d bp;\n@@ -1466,6 +1468,7 @@ input_edge (class lto_input_block *ib, vec<symtab_node *> nodes,\n   bp = streamer_read_bitpack (ib);\n   inline_failed = bp_unpack_enum (&bp, cgraph_inline_failed_t, CIF_N_REASONS);\n   stmt_id = bp_unpack_var_len_unsigned (&bp);\n+  speculative_id = bp_unpack_value (&bp, 16);\n \n   if (indirect)\n     edge = caller->create_indirect_edge (NULL, 0, count);\n@@ -1475,6 +1478,7 @@ input_edge (class lto_input_block *ib, vec<symtab_node *> nodes,\n   edge->indirect_inlining_edge = bp_unpack_value (&bp, 1);\n   edge->speculative = bp_unpack_value (&bp, 1);\n   edge->lto_stmt_uid = stmt_id;\n+  edge->speculative_id = speculative_id;\n   edge->inline_failed = inline_failed;\n   edge->call_stmt_cannot_inline_p = bp_unpack_value (&bp, 1);\n   edge->can_throw_external = bp_unpack_value (&bp, 1);\n@@ -1494,9 +1498,9 @@ input_edge (class lto_input_block *ib, vec<symtab_node *> nodes,\n       if (bp_unpack_value (&bp, 1))\n \tecf_flags |= ECF_RETURNS_TWICE;\n       edge->indirect_info->ecf_flags = ecf_flags;\n-      edge->indirect_info->common_target_id = streamer_read_hwi (ib);\n-      if (edge->indirect_info->common_target_id)\n-        edge->indirect_info->common_target_probability = streamer_read_hwi (ib);\n+\n+      edge->indirect_info->num_speculative_call_targets\n+\t= bp_unpack_value (&bp, 16);\n     }\n }\n "}, {"sha": "02c5fe0667dd24d2c9cbec9ac7cb37be5125eb4b", "filename": "gcc/predict.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -761,7 +761,6 @@ dump_prediction (FILE *file, enum br_predictor predictor, int probability,\n       && bb->count.precise_p ()\n       && reason == REASON_NONE)\n     {\n-      gcc_assert (e->count ().precise_p ());\n       fprintf (file, \";;heuristics;%s;%\" PRId64 \";%\" PRId64 \";%.1f;\\n\",\n \t       predictor_info[predictor].name,\n \t       bb->count.to_gcov_type (), e->count ().to_gcov_type (),"}, {"sha": "f141200a452159269cc35ce5af087e5a70f60280", "filename": "gcc/symtab.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -605,6 +605,7 @@ symtab_node::create_reference (symtab_node *referred_node,\n   ref->referred = referred_node;\n   ref->stmt = stmt;\n   ref->lto_stmt_uid = 0;\n+  ref->speculative_id = 0;\n   ref->use = use_type;\n   ref->speculative = 0;\n \n@@ -662,6 +663,7 @@ symtab_node::clone_references (symtab_node *node)\n       ref2 = create_reference (ref->referred, ref->use, ref->stmt);\n       ref2->speculative = speculative;\n       ref2->lto_stmt_uid = stmt_uid;\n+      ref2->speculative_id = ref->speculative_id;\n     }\n }\n \n@@ -680,6 +682,7 @@ symtab_node::clone_referring (symtab_node *node)\n       ref2 = ref->referring->create_reference (this, ref->use, ref->stmt);\n       ref2->speculative = speculative;\n       ref2->lto_stmt_uid = stmt_uid;\n+      ref2->speculative_id = ref->speculative_id;\n     }\n }\n \n@@ -695,6 +698,7 @@ symtab_node::clone_reference (ipa_ref *ref, gimple *stmt)\n   ref2 = create_reference (ref->referred, ref->use, stmt);\n   ref2->speculative = speculative;\n   ref2->lto_stmt_uid = stmt_uid;\n+  ref2->speculative_id = ref->speculative_id;\n   return ref2;\n }\n \n@@ -749,6 +753,7 @@ symtab_node::clear_stmts_in_references (void)\n       {\n \tr->stmt = NULL;\n \tr->lto_stmt_uid = 0;\n+\tr->speculative_id = 0;\n       }\n }\n "}, {"sha": "86e954fb84d0f461fbfebf505c543657657150e0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -1,3 +1,13 @@\n+2020-01-14  Xiong Hu Luo  <luoxhu@linux.ibm.com>\n+\n+\tPR ipa/69678\n+\t* gcc.dg/tree-prof/indir-call-prof-topn.c: New testcase.\n+\t* gcc.dg/tree-prof/crossmodule-indir-call-topn-1.c: New testcase.\n+\t* gcc.dg/tree-prof/crossmodule-indir-call-topn-1a.c: New testcase.\n+\t* gcc.dg/tree-prof/crossmodule-indir-call-topn-2.c: New testcase.\n+\t* lib/scandump.exp: Dump executable file name.\n+\t* lib/scanwpaipa.exp: New scan-pgo-wap-ipa-dump.\n+\n 2020-01-13  David Malcolm  <dmalcolm@redhat.com>\n \n \t* gcc.dg/plugin/diagnostic-test-paths-2.c: Remove unused dg-line"}, {"sha": "a13b08cd60e060ede04dcc4a9570ceb60b299942", "filename": "gcc/testsuite/gcc.dg/tree-prof/crossmodule-indir-call-topn-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indir-call-topn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indir-call-topn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indir-call-topn-1.c?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-require-effective-target lto } */\n+/* { dg-additional-sources \"crossmodule-indir-call-topn-1a.c\" } */\n+/* { dg-require-profiling \"-fprofile-generate\" } */\n+/* { dg-options \"-O2 -flto -DDOJOB=1 -fdump-ipa-profile_estimate\" } */\n+\n+#include <stdio.h>\n+\n+typedef int (*fptr) (int);\n+int\n+one (int a);\n+\n+int\n+two (int a);\n+\n+fptr table[] = {&one, &two};\n+\n+int\n+main()\n+{\n+  int i, x;\n+  fptr p = &one;\n+\n+  x = one (3);\n+\n+  for (i = 0; i < 350000000; i++)\n+    {\n+      x = (*p) (3);\n+      p = table[x];\n+    }\n+  printf (\"done:%d\\n\", x);\n+}\n+\n+/* { dg-final-use-not-autofdo { scan-pgo-wpa-ipa-dump \"2 \\\\(200.00%\\\\) speculations produced.\" \"profile_estimate\" } } */"}, {"sha": "a8c6e365fb9035543c026848a47ca4050d47a94b", "filename": "gcc/testsuite/gcc.dg/tree-prof/crossmodule-indir-call-topn-1a.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indir-call-topn-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indir-call-topn-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indir-call-topn-1a.c?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -0,0 +1,22 @@\n+/* It seems there is no way to avoid the other source of mulitple\n+   source testcase from being compiled independently.  Just avoid\n+   error.  */\n+#ifdef DOJOB\n+int\n+one (int a)\n+{\n+  return 1;\n+}\n+\n+int\n+two (int a)\n+{\n+  return 0;\n+}\n+#else\n+int\n+main()\n+{\n+  return 0;\n+}\n+#endif"}, {"sha": "9b996fcf0ede47758b56ed0aaed0ad170b346c49", "filename": "gcc/testsuite/gcc.dg/tree-prof/crossmodule-indir-call-topn-2.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indir-call-topn-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indir-call-topn-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indir-call-topn-2.c?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-require-effective-target lto } */\n+/* { dg-additional-sources \"crossmodule-indir-call-topn-1a.c\" } */\n+/* { dg-require-profiling \"-fprofile-generate\" } */\n+/* { dg-options \"-O2 -flto -DDOJOB=1 -fdump-ipa-profile_estimate\" } */\n+\n+#include <stdio.h>\n+\n+typedef int (*fptr) (int);\n+int\n+one (int a);\n+\n+int\n+two (int a);\n+\n+fptr table[] = {&one, &two};\n+\n+int foo ()\n+{\n+  int i, x;\n+  fptr p = &one;\n+\n+  x = one (3);\n+\n+  for (i = 0; i < 350000000; i++)\n+    {\n+      x = (*p) (3);\n+      p = table[x];\n+    }\n+  return x;\n+}\n+\n+int\n+main()\n+{\n+  int x = foo ();\n+  printf (\"done:%d\\n\", x);\n+}\n+\n+/* { dg-final-use-not-autofdo { scan-pgo-wpa-ipa-dump \"2 \\\\(200.00%\\\\) speculations produced.\" \"profile_estimate\" } } */\n+"}, {"sha": "063996c71df30f82127af883649cefb36c57f0ef", "filename": "gcc/testsuite/gcc.dg/tree-prof/indir-call-prof-topn.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Findir-call-prof-topn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Findir-call-prof-topn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Findir-call-prof-topn.c?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-require-profiling \"-fprofile-generate\" } */\n+/* { dg-options \"-O2 -fdump-ipa-profile_estimate\" } */\n+\n+#include <stdio.h>\n+\n+typedef int (*fptr) (int);\n+int\n+one (int a)\n+{\n+  return 1;\n+}\n+\n+int\n+two (int a)\n+{\n+  return 0;\n+}\n+\n+fptr table[] = {&one, &two};\n+\n+int\n+main()\n+{\n+  int i, x;\n+  fptr p = &one;\n+\n+  one (3);\n+\n+  for (i = 0; i < 350000000; i++)\n+    {\n+      x = (*p) (3);\n+      p = table[x];\n+    }\n+  printf (\"done:%d\\n\", x);\n+}\n+\n+/* { dg-final-use-not-autofdo { scan-ipa-dump \"2 \\\\(200.00%\\\\) speculations produced.\" \"profile_estimate\" } } */"}, {"sha": "d6ba350acc89c92150ad5f358a22abf895784352", "filename": "gcc/testsuite/lib/scandump.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Ftestsuite%2Flib%2Fscandump.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Ftestsuite%2Flib%2Fscandump.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fscandump.exp?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -70,6 +70,7 @@ proc scan-dump { args } {\n     set output_file \"[glob -nocomplain $dumpbase.[lindex $args 2]]\"\n     if { $output_file == \"\" } {\n \tverbose -log \"$testcase: dump file does not exist\"\n+\tverbose -log \"dump file: $dumpbase.$suf\"\n \tunresolved \"$testname\"\n \treturn\n     }"}, {"sha": "2f58823a4f3c03ff29279a0cb30446782f3dad29", "filename": "gcc/testsuite/lib/scanwpaipa.exp", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Ftestsuite%2Flib%2Fscanwpaipa.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Ftestsuite%2Flib%2Fscanwpaipa.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fscanwpaipa.exp?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -45,6 +45,29 @@ proc scan-wpa-ipa-dump { args } {\n     }\n }\n \n+# Argument 0 is the regexp to match\n+# Argument 1 is the name of the dumped ipa pass\n+# Argument 2 handles expected failures and the like\n+proc scan-pgo-wpa-ipa-dump { args } {\n+\n+    if { [llength $args] < 2 } {\n+\terror \"scan-pgo-wpa-ipa-dump: too few arguments\"\n+\treturn\n+    }\n+    if { [llength $args] > 3 } {\n+\terror \"scan-pgo-wpa-ipa-dump: too many arguments\"\n+\treturn\n+    }\n+    if { [llength $args] >= 3 } {\n+\tscan-dump \"pgo-wpa-ipa\" [lindex $args 0] \\\n+\t\t  \"\\[0-9\\]\\[0-9\\]\\[0-9\\]i.[lindex $args 1]\" \".x02.wpa\" \\\n+\t\t  [lindex $args 2]\n+    } else {\n+\tscan-dump \"pgo-wpa-ipa\" [lindex $args 0] \\\n+\t\t  \"\\[0-9\\]\\[0-9\\]\\[0-9\\]i.[lindex $args 1]\" \".x02.wpa\"\n+    }\n+}\n+\n # Call pass if pattern is present given number of times, otherwise fail.\n # Argument 0 is the regexp to match\n # Argument 1 is number of times the regexp must be found"}, {"sha": "2197769bf1742fee4f7bcc91826db73125999cd0", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -2187,18 +2187,44 @@ copy_bb (copy_body_data *id, basic_block bb,\n \t\t\t\t\t  num, den,\n \t\t\t\t\t  true);\n \n-\t\t      /* Speculative calls consist of two edges - direct and\n-\t\t\t indirect.  Duplicate the whole thing and distribute\n-\t\t\t frequencies accordingly.  */\n+\t\t      /* A speculative call is consist of edges - indirect edge\n+\t\t\t and direct edges (one indirect edeg may has multiple\n+\t\t\t direct edges).  Duplicate the whole thing and\n+\t\t\t distribute frequencies accordingly.  */\n \t\t      if (edge->speculative)\n \t\t\t{\n \t\t\t  struct cgraph_edge *direct, *indirect;\n \t\t\t  struct ipa_ref *ref;\n \n \t\t\t  gcc_assert (!edge->indirect_unknown_callee);\n \t\t\t  old_edge->speculative_call_info (direct, indirect, ref);\n+\t\t\t  while (old_edge->next_callee\n+\t\t\t\t && old_edge->next_callee->speculative\n+\t\t\t\t && indirect->num_speculative_call_targets_p ()\n+\t\t\t\t      > 1)\n+\t\t\t    {\n+\t\t\t      id->dst_node->clone_reference (ref, stmt);\n+\n+\t\t\t      edge = old_edge->next_callee;\n+\t\t\t      edge = edge->clone (id->dst_node, call_stmt,\n+\t\t\t\t\t\t  gimple_uid (stmt), num, den,\n+\t\t\t\t\t\t  true);\n+\t\t\t      old_edge = old_edge->next_callee;\n+\t\t\t      gcc_assert (!edge->indirect_unknown_callee);\n+\n+\t\t\t      /* If the indirect edge has multiple speculative\n+\t\t\t\t calls, iterate through all direct calls\n+\t\t\t\t associated to the speculative call and clone\n+\t\t\t\t all related direct edges before cloning the\n+\t\t\t\t related indirect edge.  */\n+\t\t\t      old_edge->speculative_call_info (direct, indirect,\n+\t\t\t\t\t\t\t       ref);\n+\t\t\t    }\n \n \t\t\t  profile_count indir_cnt = indirect->count;\n+\n+\t\t\t  /* Duplicate the indirect edge after all direct edges\n+\t\t\t     cloned.  */\n \t\t\t  indirect = indirect->clone (id->dst_node, call_stmt,\n \t\t\t\t\t\t      gimple_uid (stmt),\n \t\t\t\t\t\t      num, den,"}, {"sha": "9a2c46252c6b1c048b26be4c3b6988efa0530f7a", "filename": "gcc/value-prof.c", "status": "modified", "additions": 47, "deletions": 40, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -106,7 +106,7 @@ static bool gimple_divmod_fixed_value_transform (gimple_stmt_iterator *);\n static bool gimple_mod_pow2_value_transform (gimple_stmt_iterator *);\n static bool gimple_mod_subtract_transform (gimple_stmt_iterator *);\n static bool gimple_stringops_transform (gimple_stmt_iterator *);\n-static bool gimple_ic_transform (gimple_stmt_iterator *);\n+static void gimple_ic_transform (gimple_stmt_iterator *);\n \n /* Allocate histogram value.  */\n \n@@ -616,8 +616,7 @@ gimple_value_profile_transformations (void)\n \t  if (gimple_mod_subtract_transform (&gsi)\n \t      || gimple_divmod_fixed_value_transform (&gsi)\n \t      || gimple_mod_pow2_value_transform (&gsi)\n-\t      || gimple_stringops_transform (&gsi)\n-\t      || gimple_ic_transform (&gsi))\n+\t      || gimple_stringops_transform (&gsi))\n \t    {\n \t      stmt = gsi_stmt (gsi);\n \t      changed = true;\n@@ -628,6 +627,9 @@ gimple_value_profile_transformations (void)\n \t\t  gsi = gsi_for_stmt (stmt);\n \t\t}\n \t    }\n+\n+\t  /* The function never thansforms a GIMPLE statement.  */\n+\t  gimple_ic_transform (&gsi);\n         }\n     }\n \n@@ -1386,13 +1388,12 @@ gimple_ic (gcall *icall_stmt, struct cgraph_node *direct_call,\n   return dcall_stmt;\n }\n \n-/*\n-  For every checked indirect/virtual call determine if most common pid of\n-  function/class method has probability more than 50%. If yes modify code of\n-  this call to:\n- */\n+/* There maybe multiple indirect targets in histogram.  Check every\n+   indirect/virtual call if callee function exists, if not exist, leave it to\n+   LTO stage for later process.  Modify code of this indirect call to an if-else\n+   structure in ipa-profile finally.  */\n \n-static bool\n+static void\n gimple_ic_transform (gimple_stmt_iterator *gsi)\n {\n   gcall *stmt;\n@@ -1402,52 +1403,58 @@ gimple_ic_transform (gimple_stmt_iterator *gsi)\n \n   stmt = dyn_cast <gcall *> (gsi_stmt (*gsi));\n   if (!stmt)\n-    return false;\n+    return;\n \n   if (gimple_call_fndecl (stmt) != NULL_TREE)\n-    return false;\n+    return;\n \n   if (gimple_call_internal_p (stmt))\n-    return false;\n+    return;\n \n   histogram = gimple_histogram_value_of_type (cfun, stmt, HIST_TYPE_INDIR_CALL);\n   if (!histogram)\n-    return false;\n+    return;\n \n-  if (!get_nth_most_common_value (NULL, \"indirect call\", histogram, &val,\n-\t\t\t\t  &count, &all))\n-    return false;\n+  count = 0;\n+  all = histogram->hvalue.counters[0];\n \n-  if (4 * count <= 3 * all)\n-    return false;\n+  for (unsigned j = 0; j < GCOV_TOPN_VALUES; j++)\n+    {\n+      if (!get_nth_most_common_value (NULL, \"indirect call\", histogram, &val,\n+\t\t\t\t      &count, &all, j))\n+\treturn;\n \n-  direct_call = find_func_by_profile_id ((int)val);\n+      /* Minimum probability.  should be higher than 25%.  */\n+      if (4 * count <= all)\n+\treturn;\n \n-  if (direct_call == NULL)\n-    {\n-      if (val)\n+      direct_call = find_func_by_profile_id ((int) val);\n+\n+      if (direct_call == NULL)\n \t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, stmt,\n-\t\t\t     \"Indirect call -> direct call from other \"\n-\t\t\t     \"module %T=> %i (will resolve only with LTO)\\n\",\n-\t\t\t     gimple_call_fn (stmt), (int)val);\n+\t  if (val)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (\n+\t\t  MSG_MISSED_OPTIMIZATION, stmt,\n+\t\t  \"Indirect call -> direct call from other \"\n+\t\t  \"module %T=> %i (will resolve only with LTO)\\n\",\n+\t\t  gimple_call_fn (stmt), (int) val);\n+\t    }\n+\t  return;\n \t}\n-      return false;\n-    }\n \n-  if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, stmt,\n-\t\t       \"Indirect call -> direct call \"\n-\t\t       \"%T => %T transformation on insn postponed\\n\",\n-\t\t       gimple_call_fn (stmt), direct_call->decl);\n-      dump_printf_loc (MSG_NOTE, stmt,\n-\t\t       \"hist->count %\" PRId64\n-\t\t       \" hist->all %\" PRId64\"\\n\", count, all);\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, stmt,\n+\t\t\t   \"Indirect call -> direct call \"\n+\t\t\t   \"%T => %T transformation on insn postponed\\n\",\n+\t\t\t   gimple_call_fn (stmt), direct_call->decl);\n+\t  dump_printf_loc (MSG_NOTE, stmt,\n+\t\t\t   \"hist->count %\" PRId64 \" hist->all %\" PRId64 \"\\n\",\n+\t\t\t   count, all);\n+\t}\n     }\n-\n-  return true;\n }\n \n /* Return true if the stringop CALL shall be profiled.  SIZE_ARG be"}, {"sha": "81c615dadec815dd91cc3107b77aedfce49fda05", "filename": "gcc/value-prof.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ba88b1b20cb579b3b7ce6ce65470205742be7e/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "patch": "@@ -89,7 +89,6 @@ void verify_histograms (void);\n void free_histograms (function *);\n void stringop_block_profile (gimple *, unsigned int *, HOST_WIDE_INT *);\n gcall *gimple_ic (gcall *, struct cgraph_node *, profile_probability);\n-bool check_ic_target (gcall *, struct cgraph_node *);\n bool get_nth_most_common_value (gimple *stmt, const char *counter_type,\n \t\t\t\thistogram_value hist, gcov_type *value,\n \t\t\t\tgcov_type *count, gcov_type *all,"}]}