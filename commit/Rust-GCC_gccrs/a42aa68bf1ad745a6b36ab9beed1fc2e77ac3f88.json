{"sha": "a42aa68bf1ad745a6b36ab9beed1fc2e77ac3f88", "node_id": "C_kwDOANBUbNoAKGE0MmFhNjhiZjFhZDc0NWE2YjM2YWI5YmVlZDFmYzJlNzdhYzNmODg", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-04-11T08:44:28Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-04-11T08:44:28Z"}, "message": "phiopt: Optimize (x != cst1 ? x : cst2) != cst3 [PR104639]\n\nHere is an attempt to resolve a P1 regression, where due to threading\nchanges we no longer optimize\nbool foo(int i) {\n    while (i == 4)\n        i += 2;\n    return i;\n}\nto just return i != 0; by enhancing the phiopt value_replacement\noptimization.  Normally it will optimize x != cst1 ? x : cst1 to x.\nHere we extend it to also optimize x != cst1 ? x : cst2 to x if\nit (phi result) has a single immediate use which is a comparison\nwith some INTEGER_CST cst3 and we can prove that we don't care\nwhether x is cst1 or cst2 because both compare the same against cst3.\n\n2022-04-11  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/104639\n\t* tree-ssa-phiopt.cc: Include tree-ssa-propagate.h.\n\t(value_replacement): Optimize (x != cst1 ? x : cst2) != cst3\n\tinto x != cst3.\n\n\t* gcc.dg/tree-ssa/pr104639-1.c: New test.\n\t* gcc.dg/tree-ssa/pr104639-2.c: New test.", "tree": {"sha": "188792bf816e9f0a2238c2773fd4d36425a958c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/188792bf816e9f0a2238c2773fd4d36425a958c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a42aa68bf1ad745a6b36ab9beed1fc2e77ac3f88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a42aa68bf1ad745a6b36ab9beed1fc2e77ac3f88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a42aa68bf1ad745a6b36ab9beed1fc2e77ac3f88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a42aa68bf1ad745a6b36ab9beed1fc2e77ac3f88/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "083e8e66d2e90992fa83a53bfc3553dfa91abda1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/083e8e66d2e90992fa83a53bfc3553dfa91abda1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/083e8e66d2e90992fa83a53bfc3553dfa91abda1"}], "stats": {"total": 200, "additions": 195, "deletions": 5}, "files": [{"sha": "183fa374afc2f94ccce7cd8622ea1c558d1ff144", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr104639-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42aa68bf1ad745a6b36ab9beed1fc2e77ac3f88/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr104639-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42aa68bf1ad745a6b36ab9beed1fc2e77ac3f88/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr104639-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr104639-1.c?ref=a42aa68bf1ad745a6b36ab9beed1fc2e77ac3f88", "patch": "@@ -0,0 +1,13 @@\n+/* PR tree-optimization/104639 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -g -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-not \"PHI <\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"i_\\[0-9]*\\\\\\(D\\\\\\) != 0;\" 1 \"optimized\" } } */\n+\n+_Bool\n+foo (int i)\n+{\n+  while (i == 4)\n+    i += 2;\n+  return i;\n+}"}, {"sha": "e251147067598d9d175c931bd4540f9de72f9bed", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr104639-2.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42aa68bf1ad745a6b36ab9beed1fc2e77ac3f88/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr104639-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42aa68bf1ad745a6b36ab9beed1fc2e77ac3f88/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr104639-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr104639-2.c?ref=a42aa68bf1ad745a6b36ab9beed1fc2e77ac3f88", "patch": "@@ -0,0 +1,54 @@\n+/* PR tree-optimization/104639 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-tree-pre -g -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-not \"PHI <\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"x_\\[0-9]*\\\\\\(D\\\\\\) != 42;\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"y_\\[0-9]*\\\\\\(D\\\\\\) > 6;\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"z_\\[0-9]*\\\\\\(D\\\\\\) > 9;\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"u_\\[0-9]*\\\\\\(D\\\\\\) <= 7;\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"v_\\[0-9]*\\\\\\(D\\\\\\) <= 42;\" 1 \"optimized\" } } */\n+\n+int\n+f1 (int x)\n+{\n+  if (x == 4)\n+    x = 6;\n+  int xd = x;\n+  return x != 42;\n+}\n+\n+int\n+f2 (int y)\n+{\n+  if (y == 4)\n+    y = 6;\n+  int yd = y;\n+  return y > 6;\n+}\n+\n+int\n+f3 (int z)\n+{\n+  if (z == 4)\n+    z = 6;\n+  int zd = z;\n+  return z >= 10;\n+}\n+\n+int\n+f4 (int u)\n+{\n+  if (u == 4)\n+    u = 6;\n+  int ud = u;\n+  return u < 8;\n+}\n+\n+int\n+f5 (int v)\n+{\n+  if (v == 4)\n+    v = 6;\n+  int vd = v;\n+  return v <= 42;\n+}"}, {"sha": "00c8f399e4c254922e35731b213e1e740f996b0e", "filename": "gcc/tree-ssa-phiopt.cc", "status": "modified", "additions": 128, "deletions": 5, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42aa68bf1ad745a6b36ab9beed1fc2e77ac3f88/gcc%2Ftree-ssa-phiopt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42aa68bf1ad745a6b36ab9beed1fc2e77ac3f88/gcc%2Ftree-ssa-phiopt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.cc?ref=a42aa68bf1ad745a6b36ab9beed1fc2e77ac3f88", "patch": "@@ -52,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-range.h\"\n #include \"gimple-match.h\"\n #include \"dbgcnt.h\"\n+#include \"tree-ssa-propagate.h\"\n \n static unsigned int tree_ssa_phiopt_worker (bool, bool, bool);\n static bool two_value_replacement (basic_block, basic_block, edge, gphi *,\n@@ -1327,7 +1328,17 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n      We now need to verify that the two arguments in the PHI node match\n      the two arguments to the equality comparison.  */\n \n-  if (operand_equal_for_value_replacement (arg0, arg1, &code, cond))\n+  bool equal_p = operand_equal_for_value_replacement (arg0, arg1, &code, cond);\n+  bool maybe_equal_p = false;\n+  if (!equal_p\n+      && empty_or_with_defined_p\n+      && TREE_CODE (gimple_cond_rhs (cond)) == INTEGER_CST\n+      && (operand_equal_for_phi_arg_p (gimple_cond_lhs (cond), arg0)\n+\t  ? TREE_CODE (arg1) == INTEGER_CST\n+\t  : (operand_equal_for_phi_arg_p (gimple_cond_lhs (cond), arg1)\n+\t     && TREE_CODE (arg0) == INTEGER_CST)))\n+    maybe_equal_p = true;\n+  if (equal_p || maybe_equal_p)\n     {\n       edge e;\n       tree arg;\n@@ -1358,11 +1369,123 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n \t  && single_non_singleton_phi_for_edges (phi_nodes (gimple_bb (phi)),\n \t\t\t\t\t\t e0, e1) == phi)\n \t{\n-          replace_phi_edge_with_variable (cond_bb, e1, phi, arg);\n-\t  /* Note that we optimized this PHI.  */\n-\t  return 2;\n+\t  use_operand_p use_p;\n+\t  gimple *use_stmt;\n+\n+\t  /* Even if arg0/arg1 isn't equal to second operand of cond, we\n+\t     can optimize away the bb if we can prove it doesn't care whether\n+\t     phi result is arg0/arg1 or second operand of cond.  Consider:\n+\t     <bb 2> [local count: 118111600]:\n+\t     if (i_2(D) == 4)\n+\t       goto <bb 4>; [97.00%]\n+\t     else\n+\t       goto <bb 3>; [3.00%]\n+\n+\t     <bb 3> [local count: 3540129]:\n+\n+\t     <bb 4> [local count: 118111600]:\n+\t     # i_6 = PHI <i_2(D)(3), 6(2)>\n+\t     _3 = i_6 != 0;\n+\t     Here, carg is 4, oarg is 6, crhs is 0, and because\n+\t     (4 != 0) == (6 != 0), we don't care if i_6 is 4 or 6, both\n+\t     have the same outcome.  So, can can optimize this to:\n+\t     _3 = i_2(D) != 0;\n+\t     If the single imm use of phi result >, >=, < or <=, similarly\n+\t     we can check if both carg and oarg compare the same against\n+\t     crhs using ccode.  */\n+\t  if (maybe_equal_p\n+\t      && TREE_CODE (arg) != INTEGER_CST\n+\t      && single_imm_use (gimple_phi_result (phi), &use_p, &use_stmt))\n+\t    {\n+\t      enum tree_code ccode = ERROR_MARK;\n+\t      tree clhs = NULL_TREE, crhs = NULL_TREE;\n+\t      tree carg = gimple_cond_rhs (cond);\n+\t      tree oarg = e0 == e ? arg1 : arg0;\n+\t      if (is_gimple_assign (use_stmt)\n+\t\t  && (TREE_CODE_CLASS (gimple_assign_rhs_code (use_stmt))\n+\t\t      == tcc_comparison))\n+\t\t{\n+\t\t  ccode = gimple_assign_rhs_code (use_stmt);\n+\t\t  clhs = gimple_assign_rhs1 (use_stmt);\n+\t\t  crhs = gimple_assign_rhs2 (use_stmt);\n+\t\t}\n+\t      else if (gimple_code (use_stmt) == GIMPLE_COND)\n+\t\t{\n+\t\t  ccode = gimple_cond_code (use_stmt);\n+\t\t  clhs = gimple_cond_lhs (use_stmt);\n+\t\t  crhs = gimple_cond_rhs (use_stmt);\n+\t\t}\n+\t      if (ccode != ERROR_MARK\n+\t\t  && clhs == gimple_phi_result (phi)\n+\t\t  && TREE_CODE (crhs) == INTEGER_CST)\n+\t\tswitch (ccode)\n+\t\t  {\n+\t\t  case EQ_EXPR:\n+\t\t  case NE_EXPR:\n+\t\t    if (!tree_int_cst_equal (crhs, carg)\n+\t\t\t&& !tree_int_cst_equal (crhs, oarg))\n+\t\t      equal_p = true;\n+\t\t    break;\n+\t\t  case GT_EXPR:\n+\t\t    if (tree_int_cst_lt (crhs, carg)\n+\t\t\t== tree_int_cst_lt (crhs, oarg))\n+\t\t      equal_p = true;\n+\t\t    break;\n+\t\t  case GE_EXPR:\n+\t\t    if (tree_int_cst_le (crhs, carg)\n+\t\t\t== tree_int_cst_le (crhs, oarg))\n+\t\t      equal_p = true;\n+\t\t    break;\n+\t\t  case LT_EXPR:\n+\t\t    if (tree_int_cst_lt (carg, crhs)\n+\t\t\t== tree_int_cst_lt (oarg, crhs))\n+\t\t      equal_p = true;\n+\t\t    break;\n+\t\t  case LE_EXPR:\n+\t\t    if (tree_int_cst_le (carg, crhs)\n+\t\t\t== tree_int_cst_le (oarg, crhs))\n+\t\t      equal_p = true;\n+\t\t    break;\n+\t\t  default:\n+\t\t    break;\n+\t\t  }\n+\t      if (equal_p && MAY_HAVE_DEBUG_BIND_STMTS)\n+\t\t{\n+\t\t  imm_use_iterator imm_iter;\n+\t\t  tree phires = gimple_phi_result (phi);\n+\t\t  tree temp = NULL_TREE;\n+\n+\t\t  /* Add # DEBUG D#1 => arg != carg ? arg : oarg.  */\n+\t\t  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, phires)\n+\t\t    {\n+\t\t      if (!is_gimple_debug (use_stmt))\n+\t\t\tcontinue;\n+\t\t      if (temp == NULL_TREE)\n+\t\t\t{\n+\t\t\t  gimple_stmt_iterator gsi\n+\t\t\t    = gsi_after_labels (gimple_bb (phi));\n+\t\t\t  tree type = TREE_TYPE (phires);\n+\t\t\t  temp = build_debug_expr_decl (type);\n+\t\t\t  tree t = build2 (NE_EXPR, boolean_type_node,\n+\t\t\t\t\t   arg, carg);\n+\t\t\t  t = build3 (COND_EXPR, type, t, arg, oarg);\n+\t\t\t  gimple *g = gimple_build_debug_bind (temp, t, phi);\n+\t\t\t  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t\t\t}\n+\t\t      FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+\t\t\treplace_exp (use_p, temp);\n+\t\t      update_stmt (use_stmt);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  if (equal_p)\n+\t    {\n+\t      replace_phi_edge_with_variable (cond_bb, e1, phi, arg);\n+\t      /* Note that we optimized this PHI.  */\n+\t      return 2;\n+\t    }\n \t}\n-      else\n+      else if (equal_p)\n \t{\n \t  if (!single_pred_p (middle_bb))\n \t    return 0;"}]}