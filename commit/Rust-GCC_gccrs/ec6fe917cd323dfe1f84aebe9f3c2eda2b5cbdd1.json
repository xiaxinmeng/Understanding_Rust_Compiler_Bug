{"sha": "ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM2ZmU5MTdjZDMyM2RmZTFmODRhZWJlOWYzYzJlZGEyYjVjYmRkMQ==", "commit": {"author": {"name": "Ilya Verbin", "email": "ilya.verbin@intel.com", "date": "2014-11-13T13:44:04Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-11-13T13:44:04Z"}, "message": "[PATCH 3/7] OpenMP 4.0 offloading infrastructure: Offload tables.\n\ngcc/\n\t* Makefile.in (GTFILES): Add omp-low.h to list of GC files.\n\t* cgraphunit.c: Include omp-low.h.\n\t* doc/tm.texi: Regenerate.\n\t* doc/tm.texi.in (TARGET_RECORD_OFFLOAD_SYMBOL): Document.\n\t* gengtype.c (open_base_files): Add omp-low.h to ifiles.\n\t* lto-cgraph.c (output_offload_tables): New function.\n\t(input_offload_tables): Likewise.\n\t* lto-section-in.c (lto_section_name): Add \"offload_table\".\n\t* lto-section-names.h (OFFLOAD_VAR_TABLE_SECTION_NAME): Define.\n\t(OFFLOAD_FUNC_TABLE_SECTION_NAME): Likewise.\n\t* lto-streamer-out.c (lto_output): Call output_offload_tables.\n\t* lto-streamer.h (lto_section_type): Add LTO_section_offload_table.\n\t(output_offload_tables, input_offload_tables): Declare.\n\t* omp-low.c: Include common/common-target.h and lto-section-names.h.\n\t(offload_funcs, offload_vars): New global <tree, va_gc> vectors.\n\t(expand_omp_target): Add child_fn into offload_funcs vector.\n\t(add_decls_addresses_to_decl_constructor): New function.\n\t(omp_finish_file): Likewise.\n\t* omp-low.h (omp_finish_file, offload_funcs, offload_vars): Declare.\n\t* target.def (record_offload_symbol): New DEFHOOK.\n\t* toplev.c: Include omp-low.h.\n\t(compile_file): Call omp_finish_file.\n\t* varpool.c: Include omp-low.h.\n\t(varpool_node::get_create): Add decl into offload_vars vector.\n\ngcc/lto/\n\t* lto/lto.c (read_cgraph_and_symbols): Call input_offload_tables.\n\nCo-Authored-By: Andrey Turetskiy <andrey.turetskiy@intel.com>\nCo-Authored-By: Bernd Schmidt <bernds@codesourcery.com>\nCo-Authored-By: Ilya Tocar <ilya.tocar@intel.com>\nCo-Authored-By: Michael Zolotukhin <michael.v.zolotukhin@intel.com>\n\nFrom-SVN: r217489", "tree": {"sha": "e5c2e1b47f7ea61d81e7314f0dab30406c0efc09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5c2e1b47f7ea61d81e7314f0dab30406c0efc09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/comments", "author": null, "committer": null, "parents": [{"sha": "3f341ee716b3e32238c5b57e3282a125e273d6f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f341ee716b3e32238c5b57e3282a125e273d6f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f341ee716b3e32238c5b57e3282a125e273d6f7"}], "stats": {"total": 269, "additions": 267, "deletions": 2}, "files": [{"sha": "b70b758c1aa2f29553cfd599a975743822d44dff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "patch": "@@ -7,6 +7,36 @@\n \t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n \t    Michael Zolotukhin  <michael.v.zolotukhin@intel.com>\n \n+\t* Makefile.in (GTFILES): Add omp-low.h to list of GC files.\n+\t* cgraphunit.c: Include omp-low.h.\n+\t* doc/tm.texi: Regenerate.\n+\t* doc/tm.texi.in (TARGET_RECORD_OFFLOAD_SYMBOL): Document.\n+\t* gengtype.c (open_base_files): Add omp-low.h to ifiles.\n+\t* lto-cgraph.c (output_offload_tables): New function.\n+\t(input_offload_tables): Likewise.\n+\t* lto-section-in.c (lto_section_name): Add \"offload_table\".\n+\t* lto-section-names.h (OFFLOAD_VAR_TABLE_SECTION_NAME): Define.\n+\t(OFFLOAD_FUNC_TABLE_SECTION_NAME): Likewise.\n+\t* lto-streamer-out.c (lto_output): Call output_offload_tables.\n+\t* lto-streamer.h (lto_section_type): Add LTO_section_offload_table.\n+\t(output_offload_tables, input_offload_tables): Declare.\n+\t* omp-low.c: Include common/common-target.h and lto-section-names.h.\n+\t(offload_funcs, offload_vars): New global <tree, va_gc> vectors.\n+\t(expand_omp_target): Add child_fn into offload_funcs vector.\n+\t(add_decls_addresses_to_decl_constructor): New function.\n+\t(omp_finish_file): Likewise.\n+\t* omp-low.h (omp_finish_file, offload_funcs, offload_vars): Declare.\n+\t* target.def (record_offload_symbol): New DEFHOOK.\n+\t* toplev.c: Include omp-low.h.\n+\t(compile_file): Call omp_finish_file.\n+\t* varpool.c: Include omp-low.h.\n+\t(varpool_node::get_create): Add decl into offload_vars vector.\n+\n+2014-11-13  Ilya Verbin  <ilya.verbin@intel.com>\n+\t    Ilya Tocar  <ilya.tocar@intel.com>\n+\t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n+\t    Bernd Schmidt  <bernds@codesourcery.com>\n+\n \t* cgraph.c: Include context.h.\n \t(cgraph_node::create): Set node->offloadable and g->have_offload if\n \tdecl have \"omp declare target\" attribute."}, {"sha": "32f307282c237eadf4acacd3270c4bce90f19692", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "patch": "@@ -2320,6 +2320,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/tree-profile.c $(srcdir)/tree-nested.c \\\n   $(srcdir)/tree-parloops.c \\\n   $(srcdir)/omp-low.c \\\n+  $(srcdir)/omp-low.h \\\n   $(srcdir)/targhooks.c $(out_file) $(srcdir)/passes.c $(srcdir)/cgraphunit.c \\\n   $(srcdir)/cgraphclones.c \\\n   $(srcdir)/tree-phinodes.c \\"}, {"sha": "534c61301d02ccb46f233fa5add78c191774a334", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "patch": "@@ -225,6 +225,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"tree-chkp.h\"\n #include \"lto-section-names.h\"\n+#include \"omp-low.h\"\n \n /* Queue of cgraph nodes scheduled to be added into cgraph.  This is a\n    secondary queue used during optimization to accommodate passes that"}, {"sha": "778e90d989d4244d9714f4fb2e47d482c7470765", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "patch": "@@ -11396,6 +11396,12 @@ If defined, this function returns an appropriate alignment in bits for an atomic\n ISO C11 requires atomic compound assignments that may raise floating-point exceptions to raise exceptions corresponding to the arithmetic operation whose result was successfully stored in a compare-and-exchange sequence.  This requires code equivalent to calls to @code{feholdexcept}, @code{feclearexcept} and @code{feupdateenv} to be generated at appropriate points in the compare-and-exchange sequence.  This hook should set @code{*@var{hold}} to an expression equivalent to the call to @code{feholdexcept}, @code{*@var{clear}} to an expression equivalent to the call to @code{feclearexcept} and @code{*@var{update}} to an expression equivalent to the call to @code{feupdateenv}.  The three expressions are @code{NULL_TREE} on entry to the hook and may be left as @code{NULL_TREE} if no code is required in a particular place.  The default implementation leaves all three expressions as @code{NULL_TREE}.  The @code{__atomic_feraiseexcept} function from @code{libatomic} may be of use as part of the code generated in @code{*@var{update}}.\n @end deftypefn\n \n+@deftypefn {Target Hook} void TARGET_RECORD_OFFLOAD_SYMBOL (tree)\n+Used when offloaded functions are seen in the compilation unit and no named\n+sections are available.  It is called once for each symbol that must be\n+recorded in the offload function and variable table.\n+@end deftypefn\n+\n @defmac TARGET_SUPPORTS_WIDE_INT\n \n On older ports, large integers are stored in @code{CONST_DOUBLE} rtl"}, {"sha": "6c82448c5a8fb31a118bc98f081139472b461f2a", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "patch": "@@ -8169,6 +8169,8 @@ and the associated definitions of those functions.\n \n @hook TARGET_ATOMIC_ASSIGN_EXPAND_FENV\n \n+@hook TARGET_RECORD_OFFLOAD_SYMBOL\n+\n @defmac TARGET_SUPPORTS_WIDE_INT\n \n On older ports, large integers are stored in @code{CONST_DOUBLE} rtl"}, {"sha": "71159b05fa7feff9303748ee3ca95c6702d02576", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "patch": "@@ -1843,7 +1843,7 @@ open_base_files (void)\n       \"tree-ssa.h\", \"reload.h\", \"cpp-id-data.h\", \"tree-chrec.h\",\n       \"except.h\", \"output.h\",  \"cfgloop.h\", \"target.h\", \"lto-streamer.h\",\n       \"target-globals.h\", \"ipa-ref.h\", \"cgraph.h\", \"ipa-prop.h\", \n-      \"ipa-inline.h\", \"dwarf2out.h\", NULL\n+      \"ipa-inline.h\", \"dwarf2out.h\", \"omp-low.h\", NULL\n     };\n     const char *const *ifp;\n     outf_p gtype_desc_c;"}, {"sha": "b29d1b51a3891afe10507dadc87f4ba4dcbe97b8", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "patch": "@@ -61,6 +61,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"context.h\"\n #include \"pass_manager.h\"\n #include \"ipa-utils.h\"\n+#include \"omp-low.h\"\n \n /* True when asm nodes has been output.  */\n bool asm_nodes_output = false;\n@@ -1068,6 +1069,50 @@ read_string (struct lto_input_block *ib)\n   return str;\n }\n \n+/* Output function/variable tables that will allow libgomp to look up offload\n+   target code.\n+   OFFLOAD_FUNCS is filled in expand_omp_target, OFFLOAD_VARS is filled in\n+   varpool_node::get_create.  In WHOPR (partitioned) mode during the WPA stage\n+   both OFFLOAD_FUNCS and OFFLOAD_VARS are filled by input_offload_tables.  */\n+\n+void\n+output_offload_tables (void)\n+{\n+  if (vec_safe_is_empty (offload_funcs) && vec_safe_is_empty (offload_vars))\n+    return;\n+\n+  struct lto_simple_output_block *ob\n+    = lto_create_simple_output_block (LTO_section_offload_table);\n+\n+  for (unsigned i = 0; i < vec_safe_length (offload_funcs); i++)\n+    {\n+      streamer_write_enum (ob->main_stream, LTO_symtab_tags,\n+\t\t\t   LTO_symtab_last_tag, LTO_symtab_unavail_node);\n+      lto_output_fn_decl_index (ob->decl_state, ob->main_stream,\n+\t\t\t\t(*offload_funcs)[i]);\n+    }\n+\n+  for (unsigned i = 0; i < vec_safe_length (offload_vars); i++)\n+    {\n+      streamer_write_enum (ob->main_stream, LTO_symtab_tags,\n+\t\t\t   LTO_symtab_last_tag, LTO_symtab_variable);\n+      lto_output_var_decl_index (ob->decl_state, ob->main_stream,\n+\t\t\t\t (*offload_vars)[i]);\n+    }\n+\n+  streamer_write_uhwi_stream (ob->main_stream, 0);\n+  lto_destroy_simple_output_block (ob);\n+\n+  /* In WHOPR mode during the WPA stage the joint offload tables need to be\n+     streamed to one partition only.  That's why we free offload_funcs and\n+     offload_vars after the first call of output_offload_tables.  */\n+  if (flag_wpa)\n+    {\n+      vec_free (offload_funcs);\n+      vec_free (offload_vars);\n+    }\n+}\n+\n /* Overwrite the information in NODE based on FILE_DATA, TAG, FLAGS,\n    STACK_SIZE, SELF_TIME and SELF_SIZE.  This is called either to initialize\n    NODE or to replace the values in it, for instance because the first\n@@ -1794,6 +1839,55 @@ input_symtab (void)\n     }\n }\n \n+/* Input function/variable tables that will allow libgomp to look up offload\n+   target code, and store them into OFFLOAD_FUNCS and OFFLOAD_VARS.  */\n+\n+void\n+input_offload_tables (void)\n+{\n+  struct lto_file_decl_data **file_data_vec = lto_get_file_decl_data ();\n+  struct lto_file_decl_data *file_data;\n+  unsigned int j = 0;\n+\n+  while ((file_data = file_data_vec[j++]))\n+    {\n+      const char *data;\n+      size_t len;\n+      struct lto_input_block *ib\n+\t= lto_create_simple_input_block (file_data, LTO_section_offload_table,\n+\t\t\t\t\t &data, &len);\n+      if (!ib)\n+\tcontinue;\n+\n+      enum LTO_symtab_tags tag\n+\t= streamer_read_enum (ib, LTO_symtab_tags, LTO_symtab_last_tag);\n+      while (tag)\n+\t{\n+\t  if (tag == LTO_symtab_unavail_node)\n+\t    {\n+\t      int decl_index = streamer_read_uhwi (ib);\n+\t      tree fn_decl\n+\t\t= lto_file_decl_data_get_fn_decl (file_data, decl_index);\n+\t      vec_safe_push (offload_funcs, fn_decl);\n+\t    }\n+\t  else if (tag == LTO_symtab_variable)\n+\t    {\n+\t      int decl_index = streamer_read_uhwi (ib);\n+\t      tree var_decl\n+\t\t= lto_file_decl_data_get_var_decl (file_data, decl_index);\n+\t      vec_safe_push (offload_vars, var_decl);\n+\t    }\n+\t  else\n+\t    fatal_error (\"invalid offload table in %s\", file_data->file_name);\n+\n+\t  tag = streamer_read_enum (ib, LTO_symtab_tags, LTO_symtab_last_tag);\n+\t}\n+\n+      lto_destroy_simple_input_block (file_data, LTO_section_offload_table,\n+\t\t\t\t      ib, data, len);\n+    }\n+}\n+\n /* True when we need optimization summary for NODE.  */\n \n static int"}, {"sha": "d54ca0f8b06be898678ae0c7ce4918e9b45fbb12", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "patch": "@@ -70,7 +70,8 @@ const char *lto_section_name[LTO_N_SECTION_TYPES] =\n   \"cgraphopt\",\n   \"inline\",\n   \"ipcp_trans\",\n-  \"icf\"\n+  \"icf\",\n+  \"offload_table\"\n };\n \n "}, {"sha": "d84deac84d0026eb4cb764581f2dc78cb1ff2dc5", "filename": "gcc/lto-section-names.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Flto-section-names.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Flto-section-names.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-names.h?ref=ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "patch": "@@ -35,4 +35,7 @@ extern const char *section_name_prefix;\n \n #define LTO_SEGMENT_NAME \"__GNU_LTO\"\n \n+#define OFFLOAD_VAR_TABLE_SECTION_NAME \".gnu.offload_vars\"\n+#define OFFLOAD_FUNC_TABLE_SECTION_NAME \".gnu.offload_funcs\"\n+\n #endif /* GCC_LTO_SECTION_NAMES_H */"}, {"sha": "98ee44d91cc9111ef53b01899f6a0231c5e34698", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "patch": "@@ -2308,6 +2308,8 @@ lto_output (void)\n      statements using the statement UIDs.  */\n   output_symtab ();\n \n+  output_offload_tables ();\n+\n #ifdef ENABLE_CHECKING\n   lto_bitmap_free (output);\n #endif"}, {"sha": "f5b67abd468efd68b13e2ddc3d651721a0ae2cf5", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "patch": "@@ -247,6 +247,7 @@ enum lto_section_type\n   LTO_section_inline_summary,\n   LTO_section_ipcp_transform,\n   LTO_section_ipa_icf,\n+  LTO_section_offload_table,\n   LTO_N_SECTION_TYPES\t\t/* Must be last.  */\n };\n \n@@ -822,6 +823,8 @@ bool lto_symtab_encoder_encode_initializer_p (lto_symtab_encoder_t,\n \t\t\t\t\t      varpool_node *);\n void output_symtab (void);\n void input_symtab (void);\n+void output_offload_tables (void);\n+void input_offload_tables (void);\n bool referenced_from_other_partition_p (struct ipa_ref_list *,\n \t\t\t\t        lto_symtab_encoder_t);\n bool reachable_from_other_partition_p (struct cgraph_node *,"}, {"sha": "96362e1336912651682ce8a0112eb5045b35d78b", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "patch": "@@ -3,6 +3,13 @@\n \t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n \t    Michael Zolotukhin  <michael.v.zolotukhin@intel.com>\n \n+\t* lto/lto.c (read_cgraph_and_symbols): Call input_offload_tables.\n+\n+2014-11-13  Ilya Verbin  <ilya.verbin@intel.com>\n+\t    Ilya Tocar  <ilya.tocar@intel.com>\n+\t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n+\t    Bernd Schmidt  <bernds@codesourcery.com>\n+\n \t* lto-object.c (lto_obj_add_section): Use section_name_prefix instead of\n \tLTO_SECTION_NAME_PREFIX.\n \t* lto-partition.c (lto_promote_cross_file_statics): Call"}, {"sha": "98d48fb7aa9c72da6fbf5398f3d5a8702fbd62cc", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "patch": "@@ -3034,6 +3034,8 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   /* Read the symtab.  */\n   input_symtab ();\n \n+  input_offload_tables ();\n+\n   /* Store resolutions into the symbol table.  */\n \n   ld_plugin_symbol_resolution_t *res;"}, {"sha": "915d55f7f93843f57cc95bbe2a2404e925e76666", "filename": "gcc/omp-low.c", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "patch": "@@ -77,6 +77,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"optabs.h\"\n #include \"cfgloop.h\"\n #include \"target.h\"\n+#include \"common/common-target.h\"\n #include \"omp-low.h\"\n #include \"gimple-low.h\"\n #include \"tree-cfgcleanup.h\"\n@@ -87,6 +88,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-eh.h\"\n #include \"cilk.h\"\n #include \"context.h\"\n+#include \"lto-section-names.h\"\n \n \n /* Lowering of OpenMP parallel and workshare constructs proceeds in two\n@@ -235,6 +237,9 @@ static tree scan_omp_1_op (tree *, int *, void *);\n       *handled_ops_p = false; \\\n       break;\n \n+/* Holds offload tables with decls.  */\n+vec<tree, va_gc> *offload_funcs, *offload_vars;\n+\n /* Convenience function for calling scan_omp_1_op on tree operands.  */\n \n static inline tree\n@@ -8409,6 +8414,9 @@ expand_omp_target (struct omp_region *region)\n       DECL_STRUCT_FUNCTION (child_fn)->curr_properties = cfun->curr_properties;\n       cgraph_node::add_new_function (child_fn, true);\n \n+      /* Add the new function to the offload table.  */\n+      vec_safe_push (offload_funcs, child_fn);\n+\n       /* Fix the callgraph edges for child_cfun.  Those for cfun will be\n \t fixed in a following pass.  */\n       push_cfun (child_cfun);\n@@ -12423,4 +12431,91 @@ make_pass_omp_simd_clone (gcc::context *ctxt)\n   return new pass_omp_simd_clone (ctxt);\n }\n \n+/* Helper function for omp_finish_file routine.  Takes decls from V_DECLS and\n+   adds their addresses and sizes to constructor-vector V_CTOR.  */\n+static void\n+add_decls_addresses_to_decl_constructor (vec<tree, va_gc> *v_decls,\n+\t\t\t\t\t vec<constructor_elt, va_gc> *v_ctor)\n+{\n+  unsigned len = vec_safe_length (v_decls);\n+  for (unsigned i = 0; i < len; i++)\n+    {\n+      tree it = (*v_decls)[i];\n+      bool is_function = TREE_CODE (it) != VAR_DECL;\n+\n+      CONSTRUCTOR_APPEND_ELT (v_ctor, NULL_TREE, build_fold_addr_expr (it));\n+      if (!is_function)\n+\tCONSTRUCTOR_APPEND_ELT (v_ctor, NULL_TREE,\n+\t\t\t\tfold_convert (const_ptr_type_node,\n+\t\t\t\t\t      DECL_SIZE_UNIT (it)));\n+    }\n+}\n+\n+/* Create new symbols containing (address, size) pairs for global variables,\n+   marked with \"omp declare target\" attribute, as well as addresses for the\n+   functions, which are outlined target regions.  */\n+void\n+omp_finish_file (void)\n+{\n+  unsigned num_funcs = vec_safe_length (offload_funcs);\n+  unsigned num_vars = vec_safe_length (offload_vars);\n+\n+  if (num_funcs == 0 && num_vars == 0)\n+    return;\n+\n+  if (targetm_common.have_named_sections)\n+    {\n+      vec<constructor_elt, va_gc> *v_f, *v_v;\n+      vec_alloc (v_f, num_funcs);\n+      vec_alloc (v_v, num_vars * 2);\n+\n+      add_decls_addresses_to_decl_constructor (offload_funcs, v_f);\n+      add_decls_addresses_to_decl_constructor (offload_vars, v_v);\n+\n+      tree vars_decl_type = build_array_type_nelts (pointer_sized_int_node,\n+\t\t\t\t\t\t    num_vars * 2);\n+      tree funcs_decl_type = build_array_type_nelts (pointer_sized_int_node,\n+\t\t\t\t\t\t     num_funcs);\n+      TYPE_ALIGN (vars_decl_type) = TYPE_ALIGN (pointer_sized_int_node);\n+      TYPE_ALIGN (funcs_decl_type) = TYPE_ALIGN (pointer_sized_int_node);\n+      tree ctor_v = build_constructor (vars_decl_type, v_v);\n+      tree ctor_f = build_constructor (funcs_decl_type, v_f);\n+      TREE_CONSTANT (ctor_v) = TREE_CONSTANT (ctor_f) = 1;\n+      TREE_STATIC (ctor_v) = TREE_STATIC (ctor_f) = 1;\n+      tree funcs_decl = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+\t\t\t\t    get_identifier (\".offload_func_table\"),\n+\t\t\t\t    funcs_decl_type);\n+      tree vars_decl = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+\t\t\t\t   get_identifier (\".offload_var_table\"),\n+\t\t\t\t   vars_decl_type);\n+      TREE_STATIC (funcs_decl) = TREE_STATIC (vars_decl) = 1;\n+      /* Do not align tables more than TYPE_ALIGN (pointer_sized_int_node),\n+\t otherwise a joint table in a binary will contain padding between\n+\t tables from multiple object files.  */\n+      DECL_USER_ALIGN (funcs_decl) = DECL_USER_ALIGN (vars_decl) = 1;\n+      DECL_ALIGN (funcs_decl) = TYPE_ALIGN (funcs_decl_type);\n+      DECL_ALIGN (vars_decl) = TYPE_ALIGN (vars_decl_type);\n+      DECL_INITIAL (funcs_decl) = ctor_f;\n+      DECL_INITIAL (vars_decl) = ctor_v;\n+      set_decl_section_name (funcs_decl, OFFLOAD_FUNC_TABLE_SECTION_NAME);\n+      set_decl_section_name (vars_decl, OFFLOAD_VAR_TABLE_SECTION_NAME);\n+\n+      varpool_node::finalize_decl (vars_decl);\n+      varpool_node::finalize_decl (funcs_decl);\n+   }\n+  else\n+    {\n+      for (unsigned i = 0; i < num_funcs; i++)\n+\t{\n+\t  tree it = (*offload_funcs)[i];\n+\t  targetm.record_offload_symbol (it);\n+\t}\n+      for (unsigned i = 0; i < num_vars; i++)\n+\t{\n+\t  tree it = (*offload_vars)[i];\n+\t  targetm.record_offload_symbol (it);\n+\t}\n+    }\n+}\n+\n #include \"gt-omp-low.h\""}, {"sha": "ac587d04d3a5b30185f772443f288ffc5c587b84", "filename": "gcc/omp-low.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Fomp-low.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Fomp-low.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.h?ref=ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "patch": "@@ -27,5 +27,9 @@ extern void omp_expand_local (basic_block);\n extern void free_omp_regions (void);\n extern tree omp_reduction_init (tree, tree);\n extern bool make_gimple_omp_edges (basic_block, struct omp_region **, int *);\n+extern void omp_finish_file (void);\n+\n+extern GTY(()) vec<tree, va_gc> *offload_funcs;\n+extern GTY(()) vec<tree, va_gc> *offload_vars;\n \n #endif /* GCC_OMP_LOW_H */"}, {"sha": "682d22ead004e8b8d3e9610792ac2e3becc0f678", "filename": "gcc/target.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "patch": "@@ -1779,6 +1779,14 @@ HOOK_VECTOR_END (vectorize)\n #undef HOOK_PREFIX\n #define HOOK_PREFIX \"TARGET_\"\n \n+DEFHOOK\n+(record_offload_symbol,\n+ \"Used when offloaded functions are seen in the compilation unit and no named\\n\\\n+sections are available.  It is called once for each symbol that must be\\n\\\n+recorded in the offload function and variable table.\",\n+ void, (tree),\n+ hook_void_tree)\n+\n /* Allow target specific overriding of option settings after options have\n   been changed by an attribute or pragma or when it is reset at the\n   end of the code affected by an attribute or pragma.  */"}, {"sha": "80fb4ceb4c6c8a60ad5f5262a36903039834c47d", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "patch": "@@ -98,6 +98,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"insn-codes.h\"\n #include \"optabs.h\"\n #include \"tree-chkp.h\"\n+#include \"omp-low.h\"\n \n #if defined(DBX_DEBUGGING_INFO) || defined(XCOFF_DEBUGGING_INFO)\n #include \"dbxout.h\"\n@@ -601,6 +602,8 @@ compile_file (void)\n       if (flag_check_pointer_bounds)\n \tchkp_finish_file ();\n \n+      omp_finish_file ();\n+\n       output_shared_constant_pool ();\n       output_object_blocks ();\n       finish_tm_clone_pairs ();"}, {"sha": "80dd496a49a23766141519615dfc1a266ca4c7de", "filename": "gcc/varpool.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "patch": "@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\"\n #include \"lto-streamer.h\"\n #include \"context.h\"\n+#include \"omp-low.h\"\n \n const char * const tls_model_names[]={\"none\", \"tls-emulated\", \"tls-real\",\n \t\t\t\t      \"tls-global-dynamic\", \"tls-local-dynamic\",\n@@ -171,6 +172,8 @@ varpool_node::get_create (tree decl)\n     {\n       node->offloadable = 1;\n       g->have_offload = true;\n+      if (!in_lto_p)\n+\tvec_safe_push (offload_vars, decl);\n     }\n \n   node->register_symbol ();"}]}