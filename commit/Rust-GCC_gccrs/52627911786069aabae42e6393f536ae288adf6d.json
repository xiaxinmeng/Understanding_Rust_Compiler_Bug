{"sha": "52627911786069aabae42e6393f536ae288adf6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI2Mjc5MTE3ODYwNjlhYWJhZTQyZTYzOTNmNTM2YWUyODhhZGY2ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T07:53:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T07:53:47Z"}, "message": "Removed.\n\nFrom-SVN: r213531", "tree": {"sha": "6f962430a9a927eb9a9d00eaf95c20794e95b54a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f962430a9a927eb9a9d00eaf95c20794e95b54a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52627911786069aabae42e6393f536ae288adf6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52627911786069aabae42e6393f536ae288adf6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52627911786069aabae42e6393f536ae288adf6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52627911786069aabae42e6393f536ae288adf6d/comments", "author": null, "committer": null, "parents": [{"sha": "fb4fb123accb94141f0bb7ffdd9c62b4b71db15f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb4fb123accb94141f0bb7ffdd9c62b4b71db15f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb4fb123accb94141f0bb7ffdd9c62b4b71db15f"}], "stats": {"total": 652, "additions": 0, "deletions": 652}, "files": [{"sha": "6af947f725d151fb63c3f17260931589e4aef6db", "filename": "gcc/ada/g-trasym-vms-alpha.adb", "status": "removed", "additions": 0, "deletions": 305, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4fb123accb94141f0bb7ffdd9c62b4b71db15f/gcc%2Fada%2Fg-trasym-vms-alpha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4fb123accb94141f0bb7ffdd9c62b4b71db15f/gcc%2Fada%2Fg-trasym-vms-alpha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-trasym-vms-alpha.adb?ref=fb4fb123accb94141f0bb7ffdd9c62b4b71db15f", "patch": "@@ -1,305 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---             G N A T . T R A C E B A C K . S Y M B O L I C                --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---           Copyright (C) 1999-2014, Free Software Foundation, Inc.        --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Run-time symbolic traceback support for Alpha/VMS\n-\n-with Ada.Exceptions.Traceback; use Ada.Exceptions.Traceback;\n-with Interfaces.C;\n-with System;\n-with System.Aux_DEC;\n-with System.Soft_Links;\n-with System.Traceback_Entries;\n-\n-package body GNAT.Traceback.Symbolic is\n-\n-   pragma Warnings (Off); --  Needs comment ???\n-   pragma Linker_Options (\"--for-linker=sys$library:trace.exe\");\n-\n-   use Interfaces.C;\n-   use System;\n-   use System.Aux_DEC;\n-   use System.Traceback_Entries;\n-\n-   subtype User_Arg_Type is Unsigned_Longword;\n-   subtype Cond_Value_Type is Unsigned_Longword;\n-\n-   type ASCIC is record\n-      Count : unsigned_char;\n-      Data  : char_array (1 .. 255);\n-   end record;\n-   pragma Convention (C, ASCIC);\n-\n-   for ASCIC use record\n-      Count at 0 range 0 .. 7;\n-      Data  at 1 range 0 .. 8 * 255 - 1;\n-   end record;\n-   for ASCIC'Size use 8 * 256;\n-\n-   function Fetch_ASCIC is new Fetch_From_Address (ASCIC);\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   function Dummy_User_Act_Proc\n-     (Msgvec : Address       := Null_Address;\n-      Actrtn : Address       := Null_Address;\n-      Facnam : Address       := Null_Address;\n-      Actprm : User_Arg_Type := 0) return Cond_Value_Type;\n-   --  Dummy routine with SYS$PUTMSG signature\n-\n-   procedure Symbolize\n-     (Status         : out Cond_Value_Type;\n-      Current_PC     : Address;\n-      Adjusted_PC    : Address;\n-      Current_FP     : Address;\n-      Current_R26    : Address;\n-      Image_Name     : out Address;\n-      Module_Name    : out Address;\n-      Routine_Name   : out Address;\n-      Line_Number    : out Integer;\n-      Relative_PC    : out Address;\n-      Absolute_PC    : out Address;\n-      PC_Is_Valid    : out Long_Integer;\n-      User_Act_Proc  : Address           := Dummy_User_Act_Proc'Address;\n-      User_Arg_Value : User_Arg_Type     := 0);\n-   --  Comment on above procedure required ???\n-\n-   pragma Import (External, Symbolize);\n-\n-   pragma Import_Valued_Procedure\n-     (Symbolize, \"TBK$SYMBOLIZE\",\n-      (Cond_Value_Type, Address, Address, Address, Address,\n-       Address, Address, Address, Integer,\n-       Address, Address, Long_Integer,\n-       Address, User_Arg_Type),\n-      (Value, Value, Value, Value, Value,\n-       Reference, Reference, Reference, Reference,\n-       Reference, Reference, Reference,\n-       Value, Value));\n-\n-   function Decode_Ada_Name (Encoded_Name : String) return String;\n-   --  Decodes an Ada identifier name. Removes leading \"_ada_\" and trailing\n-   --  __{DIGIT}+ or ${DIGIT}+, converts other \"__\" to '.'\n-\n-   ---------------------\n-   -- Decode_Ada_Name --\n-   ---------------------\n-\n-   function Decode_Ada_Name (Encoded_Name : String) return String is\n-      Decoded_Name : String (1 .. Encoded_Name'Length);\n-      Pos          : Integer := Encoded_Name'First;\n-      Last         : Integer := Encoded_Name'Last;\n-      DPos         : Integer := 1;\n-\n-   begin\n-      if Pos > Last then\n-         return \"\";\n-      end if;\n-\n-      --  Skip leading _ada_\n-\n-      if Encoded_Name'Length > 4\n-        and then Encoded_Name (Pos .. Pos + 4) = \"_ada_\"\n-      then\n-         Pos := Pos + 5;\n-      end if;\n-\n-      --  Skip trailing __{DIGIT}+ or ${DIGIT}+\n-\n-      if Encoded_Name (Last) in '0' .. '9' then\n-         for J in reverse Pos + 2 .. Last - 1 loop\n-            case Encoded_Name (J) is\n-               when '0' .. '9' =>\n-                  null;\n-               when '$' =>\n-                  Last := J - 1;\n-                  exit;\n-               when '_' =>\n-                  if Encoded_Name (J - 1) = '_' then\n-                     Last := J - 2;\n-                  end if;\n-                  exit;\n-               when others =>\n-                  exit;\n-            end case;\n-         end loop;\n-      end if;\n-\n-      --  Now just copy encoded name to decoded name, converting \"__\" to '.'\n-\n-      while Pos <= Last loop\n-         if Encoded_Name (Pos) = '_' and then Encoded_Name (Pos + 1) = '_'\n-           and then Pos /= Encoded_Name'First\n-         then\n-            Decoded_Name (DPos) := '.';\n-            Pos := Pos + 2;\n-\n-         else\n-            Decoded_Name (DPos) := Encoded_Name (Pos);\n-            Pos := Pos + 1;\n-         end if;\n-\n-         DPos := DPos + 1;\n-      end loop;\n-\n-      return Decoded_Name (1 .. DPos - 1);\n-   end Decode_Ada_Name;\n-\n-   -------------------------\n-   -- Dummy_User_Act_Proc --\n-   -------------------------\n-\n-   function Dummy_User_Act_Proc\n-     (Msgvec : Address       := Null_Address;\n-      Actrtn : Address       := Null_Address;\n-      Facnam : Address       := Null_Address;\n-      Actprm : User_Arg_Type := 0) return Cond_Value_Type\n-   is\n-   begin\n-      return 0;\n-   end Dummy_User_Act_Proc;\n-\n-   ------------------------\n-   -- Symbolic_Traceback --\n-   ------------------------\n-\n-   function Symbolic_Traceback (Traceback : Tracebacks_Array) return String is\n-      Status            : Cond_Value_Type;\n-      Image_Name        : ASCIC;\n-      Image_Name_Addr   : Address;\n-      Module_Name       : ASCIC;\n-      Module_Name_Addr  : Address;\n-      Routine_Name      : ASCIC;\n-      Routine_Name_Addr : Address;\n-      Line_Number       : Integer;\n-      Relative_PC       : Address;\n-      Absolute_PC       : Address;\n-      PC_Is_Valid       : Long_Integer;\n-      Return_Address    : Address;\n-      Res               : String (1 .. 256 * Traceback'Length);\n-      Len               : Integer;\n-\n-   begin\n-      if Traceback'Length > 0 then\n-         Len := 0;\n-\n-         --  Since image computation is not thread-safe we need task lockout\n-\n-         System.Soft_Links.Lock_Task.all;\n-\n-         for J in Traceback'Range loop\n-            Return_Address :=\n-              (if J = Traceback'Last then Address_Zero\n-                                     else PC_For (Traceback (J + 1)));\n-\n-            Symbolize\n-              (Status,\n-               PC_For (Traceback (J)),\n-               PC_For (Traceback (J)),\n-               PV_For (Traceback (J)),\n-               Return_Address,\n-               Image_Name_Addr,\n-               Module_Name_Addr,\n-               Routine_Name_Addr,\n-               Line_Number,\n-               Relative_PC,\n-               Absolute_PC,\n-               PC_Is_Valid);\n-\n-            Image_Name   := Fetch_ASCIC (Image_Name_Addr);\n-            Module_Name  := Fetch_ASCIC (Module_Name_Addr);\n-            Routine_Name := Fetch_ASCIC (Routine_Name_Addr);\n-\n-            declare\n-               First : Integer := Len + 1;\n-               Last  : Integer := First + 80 - 1;\n-               Pos   : Integer;\n-               Routine_Name_D : String := Decode_Ada_Name\n-                 (To_Ada\n-                    (Routine_Name.Data (1 .. size_t (Routine_Name.Count)),\n-                     False));\n-\n-            begin\n-               Res (First .. Last) := (others => ' ');\n-\n-               Res (First .. First + Integer (Image_Name.Count) - 1) :=\n-                 To_Ada\n-                  (Image_Name.Data (1 .. size_t (Image_Name.Count)),\n-                   False);\n-\n-               Res (First + 10 ..\n-                    First + 10 + Integer (Module_Name.Count) - 1) :=\n-                 To_Ada\n-                  (Module_Name.Data (1 .. size_t (Module_Name.Count)),\n-                   False);\n-\n-               Res (First + 30 ..\n-                    First + 30 + Routine_Name_D'Length - 1) :=\n-                 Routine_Name_D;\n-\n-               --  If routine name doesn't fit 20 characters, output\n-               --  the line number on next line at 50th position\n-\n-               if Routine_Name_D'Length > 20 then\n-                  Pos := First + 30 + Routine_Name_D'Length;\n-                  Res (Pos) := ASCII.LF;\n-                  Last := Pos + 80;\n-                  Res (Pos + 1 .. Last) := (others => ' ');\n-                  Pos := Pos + 51;\n-               else\n-                  Pos := First + 50;\n-               end if;\n-\n-               Res (Pos .. Pos + Integer'Image (Line_Number)'Length - 1) :=\n-                 Integer'Image (Line_Number);\n-\n-               Res (Last) := ASCII.LF;\n-               Len := Last;\n-            end;\n-         end loop;\n-\n-         System.Soft_Links.Unlock_Task.all;\n-         return Res (1 .. Len);\n-\n-      else\n-         return \"\";\n-      end if;\n-   end Symbolic_Traceback;\n-\n-   function Symbolic_Traceback\n-     (E : Ada.Exceptions.Exception_Occurrence) return String\n-   is\n-   begin\n-      return Symbolic_Traceback (Tracebacks (E));\n-   end Symbolic_Traceback;\n-\n-end GNAT.Traceback.Symbolic;"}, {"sha": "6ffb7f715bcdbb4e0cbff06598cf6193129911e4", "filename": "gcc/ada/g-trasym-vms-ia64.adb", "status": "removed", "additions": 0, "deletions": 347, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4fb123accb94141f0bb7ffdd9c62b4b71db15f/gcc%2Fada%2Fg-trasym-vms-ia64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4fb123accb94141f0bb7ffdd9c62b4b71db15f/gcc%2Fada%2Fg-trasym-vms-ia64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-trasym-vms-ia64.adb?ref=fb4fb123accb94141f0bb7ffdd9c62b4b71db15f", "patch": "@@ -1,347 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---             G N A T . T R A C E B A C K . S Y M B O L I C                --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---         Copyright (C) 2005-2014, Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Run-time symbolic traceback support for IA64/VMS\n-\n-with Ada.Exceptions.Traceback; use Ada.Exceptions.Traceback;\n-with System;\n-with System.Aux_DEC;\n-with System.Soft_Links;\n-with System.Traceback_Entries;\n-\n-package body GNAT.Traceback.Symbolic is\n-\n-   use System;\n-   use System.Aux_DEC;\n-   use System.Traceback_Entries;\n-\n-   subtype Var_String_Buf is String (1 .. 254);\n-\n-   type Var_String is record\n-      Curlen : Unsigned_Word := 0;\n-      Buf    : Var_String_Buf;\n-   end record;\n-   pragma Convention (C, Var_String);\n-   for Var_String'Size use 8 * 256;\n-\n-   type Descriptor64 is record\n-      Mbo       : Unsigned_Word;\n-      Dtype     : Unsigned_Byte;\n-      Class     : Unsigned_Byte;\n-      Mbmo      : Unsigned_Longword;\n-      Maxstrlen : Integer_64;\n-      Pointer   : Address;\n-   end record;\n-   pragma Convention (C, Descriptor64);\n-\n-   subtype Cond_Value_Type is Unsigned_Longword;\n-\n-   --  TBK_API_PARAM as defined in TBKDEF\n-\n-   type Tbk_Api_Param is record\n-      Length              : Unsigned_Word;\n-      T_Type              : Unsigned_Byte;\n-      Version             : Unsigned_Byte;\n-      Reserveda           : Unsigned_Longword;\n-      Faulting_Pc         : Address;\n-      Faulting_Fp         : Address;\n-      Filename_Desc       : Address;\n-      Library_Module_Desc : Address;\n-      Record_Number       : Address;\n-      Image_Desc          : Address;\n-      Module_Desc         : Address;\n-      Routine_Desc        : Address;\n-      Listing_Lineno      : Address;\n-      Rel_Pc              : Address;\n-      Image_Base_Addr     : Address;\n-      Module_Base_Addr    : Address;\n-      Malloc_Rtn          : Address;\n-      Free_Rtn            : Address;\n-      Symbolize_Flags     : Address;\n-      Reserved0           : Unsigned_Quadword;\n-      Reserved1           : Unsigned_Quadword;\n-      Reserved2           : Unsigned_Quadword;\n-   end record;\n-   pragma Convention (C, Tbk_Api_Param);\n-\n-   K_Version : constant Unsigned_Byte := 1;\n-   --  Current API version\n-\n-   K_Length : constant Unsigned_Word := 152;\n-   --  Length of the parameter\n-\n-   pragma Compile_Time_Error (Tbk_Api_Param'Size = K_Length * 8,\n-                              \"Bad length for tbk_api_param\");\n-   --  Sanity check\n-\n-   function Symbolize (Param : Address) return Cond_Value_Type;\n-   pragma Import (C, Symbolize, \"TBK$I64_SYMBOLIZE\");\n-\n-   function Decode_Ada_Name (Encoded_Name : String) return String;\n-   --  Decodes an Ada identifier name. Removes leading \"_ada_\" and trailing\n-   --  __{DIGIT}+ or ${DIGIT}+, converts other \"__\" to '.'\n-\n-   procedure Setup_Descriptor64_Vs (Desc : out Descriptor64; Var : Address);\n-   --  Setup descriptor Desc for address Var\n-\n-   ---------------------\n-   -- Decode_Ada_Name --\n-   ---------------------\n-\n-   function Decode_Ada_Name (Encoded_Name : String) return String is\n-      Decoded_Name : String (1 .. Encoded_Name'Length);\n-      Pos          : Integer := Encoded_Name'First;\n-      Last         : Integer := Encoded_Name'Last;\n-      DPos         : Integer := 1;\n-\n-   begin\n-      if Pos > Last then\n-         return \"\";\n-      end if;\n-\n-      --  Skip leading _ada_\n-\n-      if Encoded_Name'Length > 4\n-        and then Encoded_Name (Pos .. Pos + 4) = \"_ada_\"\n-      then\n-         Pos := Pos + 5;\n-      end if;\n-\n-      --  Skip trailing __{DIGIT}+ or ${DIGIT}+\n-\n-      if Encoded_Name (Last) in '0' .. '9' then\n-         for J in reverse Pos + 2 .. Last - 1 loop\n-            case Encoded_Name (J) is\n-               when '0' .. '9' =>\n-                  null;\n-\n-               when '$' =>\n-                  Last := J - 1;\n-                  exit;\n-\n-               when '_' =>\n-                  if Encoded_Name (J - 1) = '_' then\n-                     Last := J - 2;\n-                  end if;\n-                  exit;\n-\n-               when others =>\n-                  exit;\n-            end case;\n-         end loop;\n-      end if;\n-\n-      --  Now just copy encoded name to decoded name, converting \"__\" to '.'\n-\n-      while Pos <= Last loop\n-         if Encoded_Name (Pos) = '_' and then Encoded_Name (Pos + 1) = '_'\n-           and then Pos /= Encoded_Name'First\n-         then\n-            Decoded_Name (DPos) := '.';\n-            Pos := Pos + 2;\n-         else\n-            Decoded_Name (DPos) := Encoded_Name (Pos);\n-            Pos := Pos + 1;\n-         end if;\n-\n-         DPos := DPos + 1;\n-      end loop;\n-\n-      return Decoded_Name (1 .. DPos - 1);\n-   end Decode_Ada_Name;\n-\n-   ---------------------------\n-   -- Setup_Descriptor64_Vs --\n-   ---------------------------\n-\n-   procedure Setup_Descriptor64_Vs (Desc : out Descriptor64; Var : Address) is\n-      K_Dtype_Vt : constant Unsigned_Byte := 37;\n-      K_Class_Vs : constant Unsigned_Byte := 11;\n-   begin\n-      Desc.Mbo := 1;\n-      Desc.Dtype := K_Dtype_Vt;\n-      Desc.Class := K_Class_Vs;\n-      Desc.Mbmo := -1;\n-      Desc.Maxstrlen := Integer_64 (Var_String_Buf'Length);\n-      Desc.Pointer := Var;\n-   end Setup_Descriptor64_Vs;\n-\n-   ------------------------\n-   -- Symbolic_Traceback --\n-   ------------------------\n-\n-   function Symbolic_Traceback (Traceback : Tracebacks_Array) return String is\n-      Param         : Tbk_Api_Param;\n-      Status        : Cond_Value_Type;\n-      Record_Number : Unsigned_Longword;\n-      Image_Name    : Var_String;\n-      Image_Dsc     : Descriptor64;\n-      Module_Name   : Var_String;\n-      Module_Dsc    : Descriptor64;\n-      Routine_Name  : Var_String;\n-      Routine_Dsc   : Descriptor64;\n-      Line_Number   : Unsigned_Longword;\n-      Res           : String (1 .. 256 * Traceback'Length);\n-      Len           : Integer;\n-\n-   begin\n-      if Traceback'Length = 0 then\n-         return \"\";\n-      end if;\n-\n-      Len := 0;\n-\n-      --  Since image computation is not thread-safe we need task lockout\n-\n-      System.Soft_Links.Lock_Task.all;\n-\n-      --  Initialize descriptors\n-\n-      Setup_Descriptor64_Vs (Image_Dsc, Image_Name'Address);\n-      Setup_Descriptor64_Vs (Module_Dsc, Module_Name'Address);\n-      Setup_Descriptor64_Vs (Routine_Dsc, Routine_Name'Address);\n-\n-      for J in Traceback'Range loop\n-         --  Initialize fields in case they are not written\n-\n-         Record_Number := 0;\n-         Line_Number := 0;\n-         Image_Name.Curlen := 0;\n-         Module_Name.Curlen := 0;\n-         Routine_Name.Curlen := 0;\n-\n-         --  Symbolize\n-\n-         Param := (Length              => K_Length,\n-                   T_Type              => 0,\n-                   Version             => K_Version,\n-                   Reserveda           => 0,\n-                   Faulting_Pc         => PC_For (Traceback (J)),\n-                   Faulting_Fp         => 0,\n-                   Filename_Desc       => Null_Address,\n-                   Library_Module_Desc => Null_Address,\n-                   Record_Number       => Record_Number'Address,\n-                   Image_Desc          => Image_Dsc'Address,\n-                   Module_Desc         => Module_Dsc'Address,\n-                   Routine_Desc        => Routine_Dsc'Address,\n-                   Listing_Lineno      => Line_Number'Address,\n-                   Rel_Pc              => Null_Address,\n-                   Image_Base_Addr     => Null_Address,\n-                   Module_Base_Addr    => Null_Address,\n-                   Malloc_Rtn          => Null_Address,\n-                   Free_Rtn            => Null_Address,\n-                   Symbolize_Flags     => Null_Address,\n-                   Reserved0           => (0, 0),\n-                   Reserved1           => (0, 0),\n-                   Reserved2           => (0, 0));\n-\n-         Status := Symbolize (Param'Address);\n-\n-         --  Check for success (marked by bit 0)\n-\n-         if (Status rem 2) = 1 then\n-\n-            --  Success\n-\n-            if Line_Number = 0 then\n-\n-               --  As GCC doesn't emit source file correlation, use record\n-               --  number of line number is not set\n-\n-               Line_Number := Record_Number;\n-            end if;\n-\n-            declare\n-               First : constant Integer := Len + 1;\n-               Last  : Integer := First + 80 - 1;\n-               Pos   : Integer;\n-\n-               Routine_Name_D : constant String :=\n-                                  Decode_Ada_Name\n-                                    (Routine_Name.Buf\n-                                      (1 .. Natural (Routine_Name.Curlen)));\n-\n-               Lineno : constant String :=\n-                          Unsigned_Longword'Image (Line_Number);\n-\n-            begin\n-               Res (First .. Last) := (others => ' ');\n-\n-               Res (First .. First + Natural (Image_Name.Curlen) - 1) :=\n-                 Image_Name.Buf (1 .. Natural (Image_Name.Curlen));\n-\n-               Res (First + 10 ..\n-                      First + 10 + Natural (Module_Name.Curlen) - 1) :=\n-                 Module_Name.Buf (1 .. Natural (Module_Name.Curlen));\n-\n-               Res (First + 30 ..\n-                      First + 30 + Routine_Name_D'Length - 1) :=\n-                 Routine_Name_D;\n-\n-               --  If routine name doesn't fit 20 characters, output the line\n-               --  number on next line at 50th position.\n-\n-               if Routine_Name_D'Length > 20 then\n-                  Pos := First + 30 + Routine_Name_D'Length;\n-                  Res (Pos) := ASCII.LF;\n-                  Last := Pos + 80;\n-                  Res (Pos + 1 .. Last) := (others => ' ');\n-                  Pos := Pos + 51;\n-               else\n-                  Pos := First + 50;\n-               end if;\n-\n-               Res (Pos .. Pos + Lineno'Length - 1) := Lineno;\n-\n-               Res (Last) := ASCII.LF;\n-               Len := Last;\n-            end;\n-\n-         --  Failure (bit 0 clear)\n-\n-         else\n-            Res (Len + 1 .. Len + 6) := \"ERROR\" & ASCII.LF;\n-            Len := Len + 6;\n-         end if;\n-      end loop;\n-\n-      System.Soft_Links.Unlock_Task.all;\n-      return Res (1 .. Len);\n-   end Symbolic_Traceback;\n-\n-   function Symbolic_Traceback\n-     (E : Ada.Exceptions.Exception_Occurrence) return String\n-   is\n-   begin\n-      return Symbolic_Traceback (Tracebacks (E));\n-   end Symbolic_Traceback;\n-\n-end GNAT.Traceback.Symbolic;"}]}