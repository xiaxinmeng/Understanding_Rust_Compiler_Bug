{"sha": "9f6abd2db90151c8966d2d2718ab8c299abf1105", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY2YWJkMmRiOTAxNTFjODk2NmQyZDI3MThhYjhjMjk5YWJmMTEwNQ==", "commit": {"author": {"name": "Joe Ramsay", "email": "joe.ramsay@arm.com", "date": "2020-07-29T13:04:28Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2020-07-29T13:04:28Z"}, "message": "arm: Enable no-writeback vldr.16/vstr.16.\n\nThere was previously no way to specify that a register operand cannot\nhave any writeback modifiers, and as a result the argument to vldr.16\nand vstr.16 could be erroneously output with post-increment. This\nchange adds a constraint which forbids all writeback, and\nselects it in the relevant case for vldr.16 and vstr.16\n\nBootstrapped on arm-linux, gcc and CMSIS-DSP testsuites are clean.\nIs this patch OK for trunk? If yes, please commit on my behalf as I\ndon't\nhave commit rights.\n\ngcc/ChangeLog:\n\n\t* config/arm/arm-protos.h (arm_coproc_mem_operand_no_writeback):\n\tDeclare prototype.\n\t(arm_mve_mode_and_operands_type_check): Declare prototype.\n\t* config/arm/arm.c (arm_coproc_mem_operand): Refactor to use\n\t_arm_coproc_mem_operand.\n\t(arm_coproc_mem_operand_wb): New function to cover full, limited\n\tand no writeback.\n\t(arm_coproc_mem_operand_no_writeback): New constraint for memory\n\toperand with no writeback.\n\t(arm_print_operand): Extend 'E' specifier for memory operand\n\tthat does not support writeback.\n\t(arm_mve_mode_and_operands_type_check): New constraint check for\n\tMVE memory operands.\n\t* config/arm/constraints.md: Add Uj constraint for VFP vldr.16\n\tand vstr.16.\n\t* config/arm/vfp.md (*mov_load_vfp_hf16): New pattern for\n\tvldr.16.\n\t(*mov_store_vfp_hf16): New pattern for vstr.16.\n\t(*mov<mode>_vfp_<mode>16): Remove MVE moves.", "tree": {"sha": "186c05e4721e7f04f79eac893978fbccc449e168", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/186c05e4721e7f04f79eac893978fbccc449e168"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f6abd2db90151c8966d2d2718ab8c299abf1105", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f6abd2db90151c8966d2d2718ab8c299abf1105", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f6abd2db90151c8966d2d2718ab8c299abf1105", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f6abd2db90151c8966d2d2718ab8c299abf1105/comments", "author": {"login": "joeramsay", "id": 78039542, "node_id": "MDQ6VXNlcjc4MDM5NTQy", "avatar_url": "https://avatars.githubusercontent.com/u/78039542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joeramsay", "html_url": "https://github.com/joeramsay", "followers_url": "https://api.github.com/users/joeramsay/followers", "following_url": "https://api.github.com/users/joeramsay/following{/other_user}", "gists_url": "https://api.github.com/users/joeramsay/gists{/gist_id}", "starred_url": "https://api.github.com/users/joeramsay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joeramsay/subscriptions", "organizations_url": "https://api.github.com/users/joeramsay/orgs", "repos_url": "https://api.github.com/users/joeramsay/repos", "events_url": "https://api.github.com/users/joeramsay/events{/privacy}", "received_events_url": "https://api.github.com/users/joeramsay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5175857714cc37b01c4349f37253aea39c6a59b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5175857714cc37b01c4349f37253aea39c6a59b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5175857714cc37b01c4349f37253aea39c6a59b4"}], "stats": {"total": 127, "additions": 105, "deletions": 22}, "files": [{"sha": "0cc0ae78400e43406119f3c379a3f460f9ace283", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f6abd2db90151c8966d2d2718ab8c299abf1105/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f6abd2db90151c8966d2d2718ab8c299abf1105/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=9f6abd2db90151c8966d2d2718ab8c299abf1105", "patch": "@@ -116,8 +116,11 @@ extern enum reg_class coproc_secondary_reload_class (machine_mode, rtx,\n extern bool arm_tls_referenced_p (rtx);\n \n extern int arm_coproc_mem_operand (rtx, bool);\n+extern int arm_coproc_mem_operand_no_writeback (rtx);\n+extern int arm_coproc_mem_operand_wb (rtx, int);\n extern int neon_vector_mem_operand (rtx, int, bool);\n extern int mve_vector_mem_operand (machine_mode, rtx, bool);\n+bool arm_mve_mode_and_operands_type_check (machine_mode, rtx, rtx);\n extern int neon_struct_mem_operand (rtx);\n \n extern rtx *neon_vcmla_lane_prepare_operands (rtx *);"}, {"sha": "dd78141519e4a12a707aa2b3d2d1dba997d0e103", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 60, "deletions": 14, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f6abd2db90151c8966d2d2718ab8c299abf1105/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f6abd2db90151c8966d2d2718ab8c299abf1105/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=9f6abd2db90151c8966d2d2718ab8c299abf1105", "patch": "@@ -13235,13 +13235,14 @@ neon_element_bits (machine_mode mode)\n /* Predicates for `match_operand' and `match_operator'.  */\n \n /* Return TRUE if OP is a valid coprocessor memory address pattern.\n-   WB is true if full writeback address modes are allowed and is false\n+   WB level is 2 if full writeback address modes are allowed, 1\n    if limited writeback address modes (POST_INC and PRE_DEC) are\n-   allowed.  */\n+   allowed and 0 if no writeback at all is supported.  */\n \n int\n-arm_coproc_mem_operand (rtx op, bool wb)\n+arm_coproc_mem_operand_wb (rtx op, int wb_level)\n {\n+  gcc_assert (wb_level == 0 || wb_level == 1 || wb_level == 2);\n   rtx ind;\n \n   /* Reject eliminable registers.  */\n@@ -13274,16 +13275,18 @@ arm_coproc_mem_operand (rtx op, bool wb)\n \n   /* Autoincremment addressing modes.  POST_INC and PRE_DEC are\n      acceptable in any case (subject to verification by\n-     arm_address_register_rtx_p).  We need WB to be true to accept\n+     arm_address_register_rtx_p).  We need full writeback to accept\n+     PRE_INC and POST_DEC, and at least restricted writeback for\n      PRE_INC and POST_DEC.  */\n-  if (GET_CODE (ind) == POST_INC\n-      || GET_CODE (ind) == PRE_DEC\n-      || (wb\n-\t  && (GET_CODE (ind) == PRE_INC\n-\t      || GET_CODE (ind) == POST_DEC)))\n+  if (wb_level > 0\n+      && (GET_CODE (ind) == POST_INC\n+\t  || GET_CODE (ind) == PRE_DEC\n+\t  || (wb_level > 1\n+\t      && (GET_CODE (ind) == PRE_INC\n+\t\t  || GET_CODE (ind) == POST_DEC))))\n     return arm_address_register_rtx_p (XEXP (ind, 0), 0);\n \n-  if (wb\n+  if (wb_level > 1\n       && (GET_CODE (ind) == POST_MODIFY || GET_CODE (ind) == PRE_MODIFY)\n       && arm_address_register_rtx_p (XEXP (ind, 0), 0)\n       && GET_CODE (XEXP (ind, 1)) == PLUS\n@@ -13305,6 +13308,25 @@ arm_coproc_mem_operand (rtx op, bool wb)\n   return FALSE;\n }\n \n+/* Return TRUE if OP is a valid coprocessor memory address pattern.\n+   WB is true if full writeback address modes are allowed and is false\n+   if limited writeback address modes (POST_INC and PRE_DEC) are\n+   allowed.  */\n+\n+int arm_coproc_mem_operand (rtx op, bool wb)\n+{\n+  return arm_coproc_mem_operand_wb (op, wb ? 2 : 1);\n+}\n+\n+/* Return TRUE if OP is a valid coprocessor memory address pattern in a\n+   context in which no writeback address modes are allowed.  */\n+\n+int\n+arm_coproc_mem_operand_no_writeback (rtx op)\n+{\n+  return arm_coproc_mem_operand_wb (op, 0);\n+}\n+\n /* This function returns TRUE on matching mode and op.\n 1. For given modes, check for [Rn], return TRUE for Rn <= LO_REGS.\n 2. For other modes, check for [Rn], return TRUE for Rn < R15 (expect R13).  */\n@@ -23568,7 +23590,7 @@ arm_print_condition (FILE *stream)\n /* Globally reserved letters: acln\n    Puncutation letters currently used: @_|?().!#\n    Lower case letters currently used: bcdefhimpqtvwxyz\n-   Upper case letters currently used: ABCDFGHJKLMNOPQRSTU\n+   Upper case letters currently used: ABCDEFGHIJKLMNOPQRSTU\n    Letters previously used, but now deprecated/obsolete: sVWXYZ.\n \n    Note that the global reservation for 'c' is only for CONSTANT_ADDRESS_P.\n@@ -24134,11 +24156,12 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       }\n       return;\n \n-    /* To print the memory operand with \"Ux\" constraint.  Based on the rtx_code\n-       the memory operands output looks like following.\n+    /* To print the memory operand with \"Ux\" or \"Uj\" constraint.  Based on the\n+       rtx_code the memory operands output looks like following.\n        1. [Rn], #+/-<imm>\n        2. [Rn, #+/-<imm>]!\n-       3. [Rn].  */\n+       3. [Rn, #+/-<imm>]\n+       4. [Rn].  */\n     case 'E':\n       {\n \trtx addr;\n@@ -24173,6 +24196,16 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \t\t  asm_fprintf (stream, \", #%wd]!\",INTVAL (postinc_reg));\n \t      }\n \t  }\n+\telse if (code == PLUS)\n+\t  {\n+\t    rtx base = XEXP (addr, 0);\n+\t    rtx index = XEXP (addr, 1);\n+\n+\t    gcc_assert (REG_P (base) && CONST_INT_P (index));\n+\n+\t    HOST_WIDE_INT offset = INTVAL (index);\n+\t    asm_fprintf (stream, \"[%r, #%wd]\", REGNO (base), offset);\n+\t  }\n \telse\n \t  {\n \t    gcc_assert (REG_P (addr));\n@@ -33548,4 +33581,17 @@ arm_mode_base_reg_class (machine_mode mode)\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \n+bool\n+arm_mve_mode_and_operands_type_check (machine_mode mode, rtx op0, rtx op1)\n+{\n+  if (!(TARGET_HAVE_MVE || TARGET_HAVE_MVE_FLOAT))\n+    return true;\n+  else if (mode == E_BFmode)\n+    return false;\n+  else if ((s_register_operand (op0, mode) && MEM_P (op1))\n+\t   || (s_register_operand (op1, mode) && MEM_P (op0)))\n+    return false;\n+  return true;\n+}\n+\n #include \"gt-arm.h\""}, {"sha": "ff229aa98455e05470801d7110b1aaf5ab3e0d25", "filename": "gcc/config/arm/constraints.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f6abd2db90151c8966d2d2718ab8c299abf1105/gcc%2Fconfig%2Farm%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f6abd2db90151c8966d2d2718ab8c299abf1105/gcc%2Fconfig%2Farm%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fconstraints.md?ref=9f6abd2db90151c8966d2d2718ab8c299abf1105", "patch": "@@ -452,6 +452,13 @@\n  (and (match_code \"mem\")\n       (match_test \"TARGET_32BIT && arm_coproc_mem_operand (op, FALSE)\")))\n \n+(define_memory_constraint \"Uj\"\n+ \"@internal\n+  In ARM/Thumb-2 state an VFP load/store address which does not support\n+  writeback at all (eg vldr.16).\"\n+ (and (match_code \"mem\")\n+      (match_test \"TARGET_32BIT && arm_coproc_mem_operand_no_writeback (op)\")))\n+\n (define_memory_constraint \"Uy\"\n  \"@internal\n   In ARM/Thumb-2 state a valid iWMMX load/store address.\""}, {"sha": "6a2bc5a789f097a9c6af04bec68fbef8622d6a98", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f6abd2db90151c8966d2d2718ab8c299abf1105/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f6abd2db90151c8966d2d2718ab8c299abf1105/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=9f6abd2db90151c8966d2d2718ab8c299abf1105", "patch": "@@ -387,6 +387,20 @@\n    (set_attr \"arch\"           \"t2,any,any,any,a,t2,any,any,any,any,any,any\")]\n )\n \n+(define_insn \"*mov_load_vfp_hf16\"\n+  [(set (match_operand:HF 0 \"s_register_operand\" \"=t\")\n+\t(match_operand:HF 1 \"memory_operand\" \"Uj\"))]\n+  \"TARGET_HAVE_MVE_FLOAT\"\n+  \"vldr.16\\\\t%0, %E1\"\n+)\n+\n+(define_insn \"*mov_store_vfp_hf16\"\n+  [(set (match_operand:HF 0 \"memory_operand\" \"=Uj\")\n+\t(match_operand:HF 1 \"s_register_operand\"   \"t\"))]\n+  \"TARGET_HAVE_MVE_FLOAT\"\n+  \"vstr.16\\\\t%1, %E0\"\n+)\n+\n ;; HFmode and BFmode moves\n \n (define_insn \"*mov<mode>_vfp_<mode>16\"\n@@ -396,6 +410,8 @@\n \t\t\t  \"  m,r,t,r,r,t,Dv,Um,t, F\"))]\n   \"TARGET_32BIT\n    && TARGET_VFP_FP16INST\n+   && arm_mve_mode_and_operands_type_check (<MODE>mode, operands[0],\n+\t\t\t\t\t    operands[1])\n    && (s_register_operand (operands[0], <MODE>mode)\n        || s_register_operand (operands[1], <MODE>mode))\"\n  {\n@@ -414,15 +430,9 @@\n     case 6: /* S register from immediate.  */\n       return \\\"vmov.f16\\\\t%0, %1\\t%@ __<fporbf>\\\";\n     case 7: /* S register from memory.  */\n-      if (TARGET_HAVE_MVE)\n-\treturn \\\"vldr.16\\\\t%0, %A1\\\";\n-      else\n-\treturn \\\"vld1.16\\\\t{%z0}, %A1\\\";\n+      return \\\"vld1.16\\\\t{%z0}, %A1\\\";\n     case 8: /* Memory from S register.  */\n-      if (TARGET_HAVE_MVE)\n-\treturn \\\"vstr.16\\\\t%1, %A0\\\";\n-      else\n-\treturn \\\"vst1.16\\\\t{%z1}, %A0\\\";\n+      return \\\"vst1.16\\\\t{%z1}, %A0\\\";\n     case 9: /* ARM register from constant.  */\n       {\n \tlong bits;"}, {"sha": "0a69aced8b48434e14b41935ebc349bdf8e815b9", "filename": "gcc/testsuite/gcc.target/arm/mve/intrinsics/mve-vldstr16-no-writeback.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f6abd2db90151c8966d2d2718ab8c299abf1105/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve-vldstr16-no-writeback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f6abd2db90151c8966d2d2718ab8c299abf1105/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve-vldstr16-no-writeback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve-vldstr16-no-writeback.c?ref=9f6abd2db90151c8966d2d2718ab8c299abf1105", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+/* { dg-additional-options \"-O2\" } */\n+\n+void\n+fn1 (__fp16 *pSrc)\n+{\n+  __fp16 high;\n+  __fp16 *pDst = 0;\n+  unsigned i;\n+  for (i = 0;; i++)\n+    if (pSrc[i])\n+      pDst[i] = high;\n+}\n+\n+/* { dg-final { scan-assembler {vldr\\.16\\ts[0-9]+, \\[r[0-9]+\\]\\n} } } */\n+/* { dg-final { scan-assembler {vstr\\.16\\ts[0-9]+, \\[r[0-9]+\\]\\n} } } */"}]}