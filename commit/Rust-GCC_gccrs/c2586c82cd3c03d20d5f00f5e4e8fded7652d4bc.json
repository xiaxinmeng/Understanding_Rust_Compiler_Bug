{"sha": "c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI1ODZjODJjZDNjMDNkMjBkNWYwMGY1ZTRlOGZkZWQ3NjUyZDRiYw==", "commit": {"author": {"name": "Dominik Vogt", "email": "vogt@linux.vnet.ibm.com", "date": "2016-09-23T09:49:58Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2016-09-23T09:49:58Z"}, "message": "S/390: Enable wraparound in s390_contiguous_bitmask_p.\n\ngcc/ChangeLog:\n\n2016-09-23  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n\n\t* config/s390/predicates.md (\"contiguous_bitmask_operand\"): Adapt to new\n\tinterface of s390_contiguous_bitmask_p.\n\t(\"contiguous_bitmask_nowrap_operand\"): New predicate.\n\t* (\"*anddi3_cc\", \"*anddi3_cconly\", \"*anddi3\"): Replace NxxDq with NxxDw.\n\t* config/s390/constraints.md (\"NxxDw\", \"NxxSq\"): Adapt to new interface\n\tof s390_contiguous_bitmask_p.\n\t* (\"NxxDw\"): Rename NxxDq constraint to NxxDw.\n\t(\"NxxSw\"): New constraint.\n\t* config/s390/s390.md (\"*andsi3_zarch\"): Enable bitmask wraparound.\n\t* config/s390/s390-protos.h (s390_contiguous_bitmask_p): Updated\n\tinterface.\n\t(s390_contiguous_bitmask_nowrap_p): Export.\n\t* config/s390/s390.c (s390_contiguous_bitmask_nowrap_p): New name of\n\tformer s390_contiguous_bitmask_p.\n\t(s390_contiguous_bitmask_p): Use s390_contiguous_bitmask_nowrap_p to\n\tdetect contiguous bit ranges with wraparound.  Change signature to\n\treturn START and END position instead of POS and LENGTH.\n\t(s390_contiguous_bitmask_vector_p): Remove extra code for continous bit\n\tranges with wraparound.\n\t(s390_extzv_shift_ok): Use s390_contiguous_bitmask_nowrap_p.\n\t(s390_contiguous_bitmask_vector_p,s390_extzv_shift_ok,print_operand):\n\tAdapt to new signature of s390_contiguous_bitmask_p.\n\nFrom-SVN: r240413", "tree": {"sha": "577296687eeb1bfcaa7acb595af6db7eb1729a43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/577296687eeb1bfcaa7acb595af6db7eb1729a43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc/comments", "author": {"login": "vogtd", "id": 9690100, "node_id": "MDQ6VXNlcjk2OTAxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/9690100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vogtd", "html_url": "https://github.com/vogtd", "followers_url": "https://api.github.com/users/vogtd/followers", "following_url": "https://api.github.com/users/vogtd/following{/other_user}", "gists_url": "https://api.github.com/users/vogtd/gists{/gist_id}", "starred_url": "https://api.github.com/users/vogtd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vogtd/subscriptions", "organizations_url": "https://api.github.com/users/vogtd/orgs", "repos_url": "https://api.github.com/users/vogtd/repos", "events_url": "https://api.github.com/users/vogtd/events{/privacy}", "received_events_url": "https://api.github.com/users/vogtd/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "822f18cd922fba668a3068a6226ee120f7448d81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/822f18cd922fba668a3068a6226ee120f7448d81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/822f18cd922fba668a3068a6226ee120f7448d81"}], "stats": {"total": 265, "additions": 176, "deletions": 89}, "files": [{"sha": "f048efcdc0884d17e73b55dac3a432ec84b290e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc", "patch": "@@ -1,3 +1,28 @@\n+2016-09-23  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n+\n+\t* config/s390/predicates.md (\"contiguous_bitmask_operand\"): Adapt to new\n+\tinterface of s390_contiguous_bitmask_p.\n+\t(\"contiguous_bitmask_nowrap_operand\"): New predicate.\n+\t* (\"*anddi3_cc\", \"*anddi3_cconly\", \"*anddi3\"): Replace NxxDq with NxxDw.\n+\t* config/s390/constraints.md (\"NxxDw\", \"NxxSq\"): Adapt to new interface\n+\tof s390_contiguous_bitmask_p.\n+\t* (\"NxxDw\"): Rename NxxDq constraint to NxxDw.\n+\t(\"NxxSw\"): New constraint.\n+\t* config/s390/s390.md (\"*andsi3_zarch\"): Enable bitmask wraparound.\n+\t* config/s390/s390-protos.h (s390_contiguous_bitmask_p): Updated\n+\tinterface.\n+\t(s390_contiguous_bitmask_nowrap_p): Export.\n+\t* config/s390/s390.c (s390_contiguous_bitmask_nowrap_p): New name of\n+\tformer s390_contiguous_bitmask_p.\n+\t(s390_contiguous_bitmask_p): Use s390_contiguous_bitmask_nowrap_p to\n+\tdetect contiguous bit ranges with wraparound.  Change signature to\n+\treturn START and END position instead of POS and LENGTH.\n+\t(s390_contiguous_bitmask_vector_p): Remove extra code for continous bit\n+\tranges with wraparound.\n+\t(s390_extzv_shift_ok): Use s390_contiguous_bitmask_nowrap_p.\n+\t(s390_contiguous_bitmask_vector_p,s390_extzv_shift_ok,print_operand):\n+\tAdapt to new signature of s390_contiguous_bitmask_p.\n+\n 2016-09-23  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-vect-loop-manip.c (create_intersect_range_checks_index): New."}, {"sha": "ee505d04f6455ace452a9f73efb11c87435d3f66", "filename": "gcc/config/s390/constraints.md", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc/gcc%2Fconfig%2Fs390%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc/gcc%2Fconfig%2Fs390%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fconstraints.md?ref=c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc", "patch": "@@ -55,7 +55,12 @@\n ;;         D,S,H:   mode of the containing operand\n ;;         0,F:     value of the other parts (F - all bits set)\n ;;         --\n-;;         xx[DS]q  satisfies s390_contiguous_bitmask_p for DImode or SImode\n+;;         xxDq     satisfies s390_contiguous_bitmask_p for DImode\n+;;                  (with possible wraparound of the one-bit range)\n+;;         xxSw     satisfies s390_contiguous_bitmask_p for SImode\n+;;                  (with possible wraparound of the one-bit range)\n+;;         xxSq     satisfies s390_contiguous_bitmask_nowrap_p for SImode\n+;;                  (without wraparound of the one-bit range)\n ;;\n ;;         The constraint matches if the specified part of a constant\n ;;         has a value different from its other parts.  If the letter x\n@@ -346,15 +351,20 @@\n   (and (match_code \"const_int\")\n        (match_test \"s390_N_constraint_str (\\\"xQH0\\\", ival)\")))\n \n-(define_constraint \"NxxDq\"\n+(define_constraint \"NxxDw\"\n   \"@internal\"\n   (and (match_code \"const_int\")\n-       (match_test \"s390_contiguous_bitmask_p (ival, 64, NULL, NULL)\")))\n+       (match_test \"s390_contiguous_bitmask_p (ival, true, 64, NULL, NULL)\")))\n \n (define_constraint \"NxxSq\"\n   \"@internal\"\n   (and (match_code \"const_int\")\n-       (match_test \"s390_contiguous_bitmask_p (ival, 32, NULL, NULL)\")))\n+       (match_test \"s390_contiguous_bitmask_p (ival, false, 32, NULL, NULL)\")))\n+\n+(define_constraint \"NxxSw\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"s390_contiguous_bitmask_p (ival, true, 32, NULL, NULL)\")))\n \n ;;\n ;; Double-letter constraints starting with O follow."}, {"sha": "5b57344010f55ae996b98ae7035f41793df154e0", "filename": "gcc/config/s390/predicates.md", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc/gcc%2Fconfig%2Fs390%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc/gcc%2Fconfig%2Fs390%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fpredicates.md?ref=c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc", "patch": "@@ -176,10 +176,20 @@\n   return false;\n })\n \n+; Predicate that always allows wraparound of the one-bit range.\n (define_predicate \"contiguous_bitmask_operand\"\n   (match_code \"const_int\")\n {\n-  return s390_contiguous_bitmask_p (INTVAL (op), GET_MODE_BITSIZE (mode), NULL, NULL);\n+  return s390_contiguous_bitmask_p (INTVAL (op), true,\n+                                    GET_MODE_BITSIZE (mode), NULL, NULL);\n+})\n+\n+; Same without wraparound.\n+(define_predicate \"contiguous_bitmask_nowrap_operand\"\n+  (match_code \"const_int\")\n+{\n+  return s390_contiguous_bitmask_p\n+    (INTVAL (op), false, GET_MODE_BITSIZE (mode), NULL, NULL);\n })\n \n ;; Return true if OP is ligitimate for any LOC instruction."}, {"sha": "7ae98d49cd59facdf1026a938496b3196dfb19f9", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc", "patch": "@@ -73,7 +73,7 @@ extern int s390_const_ok_for_constraint_p (HOST_WIDE_INT, int, const char *);\n extern int s390_const_double_ok_for_constraint_p (rtx, int, const char *);\n extern int s390_single_part (rtx, machine_mode, machine_mode, int);\n extern unsigned HOST_WIDE_INT s390_extract_part (rtx, machine_mode, int);\n-extern bool s390_contiguous_bitmask_p (unsigned HOST_WIDE_INT, int, int *, int *);\n+extern bool s390_contiguous_bitmask_p (unsigned HOST_WIDE_INT, bool, int, int *, int *);\n extern bool s390_contiguous_bitmask_vector_p (rtx, int *, int *);\n extern bool s390_bytemask_vector_p (rtx, unsigned *);\n extern bool s390_split_ok_p (rtx, rtx, machine_mode, int);"}, {"sha": "0b0e3600c66c255492de6ebcc5a738c8cd673c23", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 121, "deletions": 79, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc", "patch": "@@ -2260,67 +2260,107 @@ s390_single_part (rtx op,\n }\n \n /* Return true if IN contains a contiguous bitfield in the lower SIZE\n-   bits and no other bits are set in IN.  POS and LENGTH can be used\n-   to obtain the start position and the length of the bitfield.\n+   bits and no other bits are set in (the lower SIZE bits of) IN.\n \n-   POS gives the position of the first bit of the bitfield counting\n-   from the lowest order bit starting with zero.  In order to use this\n-   value for S/390 instructions this has to be converted to \"bits big\n-   endian\" style.  */\n+   PSTART and PEND can be used to obtain the start and end\n+   position (inclusive) of the bitfield relative to 64\n+   bits. *PSTART / *PEND gives the position of the first/last bit\n+   of the bitfield counting from the highest order bit starting\n+   with zero.  */\n \n bool\n-s390_contiguous_bitmask_p (unsigned HOST_WIDE_INT in, int size,\n-\t\t\t   int *pos, int *length)\n-{\n-  int tmp_pos = 0;\n-  int tmp_length = 0;\n-  int i;\n-  unsigned HOST_WIDE_INT mask = 1ULL;\n-  bool contiguous = false;\n+s390_contiguous_bitmask_nowrap_p (unsigned HOST_WIDE_INT in, int size,\n+\t\t\t\t  int *pstart, int *pend)\n+{\n+  int start;\n+  int end = -1;\n+  int lowbit = sizeof (HOST_WIDE_INT) * BITS_PER_UNIT - 1;\n+  int highbit = sizeof (HOST_WIDE_INT) * BITS_PER_UNIT - size;\n+  unsigned HOST_WIDE_INT bitmask = 1ULL;\n+\n+  gcc_assert (!!pstart == !!pend);\n+  for (start = lowbit; start >= highbit; bitmask <<= 1, start--)\n+    if (end == -1)\n+      {\n+\t/* Look for the rightmost bit of a contiguous range of ones.  */\n+\tif (bitmask & in)\n+\t  /* Found it.  */\n+\t  end = start;\n+      }\n+    else\n+      {\n+\t/* Look for the firt zero bit after the range of ones.  */\n+\tif (! (bitmask & in))\n+\t  /* Found it.  */\n+\t  break;\n+      }\n+  /* We're one past the last one-bit.  */\n+  start++;\n \n-  for (i = 0; i < size; mask <<= 1, i++)\n+  if (end == -1)\n+    /* No one bits found.  */\n+    return false;\n+\n+  if (start > highbit)\n     {\n-      if (contiguous)\n-\t{\n-\t  if (mask & in)\n-\t    tmp_length++;\n-\t  else\n-\t    break;\n-\t}\n-      else\n-\t{\n-\t  if (mask & in)\n-\t    {\n-\t      contiguous = true;\n-\t      tmp_length++;\n-\t    }\n-\t  else\n-\t    tmp_pos++;\n-\t}\n+      unsigned HOST_WIDE_INT mask;\n+\n+      /* Calculate a mask for all bits beyond the contiguous bits.  */\n+      mask = ((~(0ULL) >> highbit) & (~(0ULL) << (lowbit - start + 1)));\n+      if (mask & in)\n+\t/* There are more bits set beyond the first range of one bits.  */\n+\treturn false;\n     }\n \n-  if (!tmp_length)\n-    return false;\n+  if (pstart)\n+    {\n+      *pstart = start;\n+      *pend = end;\n+    }\n+\n+  return true;\n+}\n \n-  /* Calculate a mask for all bits beyond the contiguous bits.  */\n-  mask = (-1LL & ~(((1ULL << (tmp_length + tmp_pos - 1)) << 1) - 1));\n+/* Same as s390_contiguous_bitmask_nowrap_p but also returns true\n+   if ~IN contains a contiguous bitfield.  In that case, *END is <\n+   *START.\n \n-  if ((unsigned)size < sizeof (HOST_WIDE_INT) * BITS_PER_UNIT)\n-    mask &= (HOST_WIDE_INT_1U << size) - 1;\n+   If WRAP_P is true, a bitmask that wraps around is also tested.\n+   When a wraparoud occurs *START is greater than *END (in\n+   non-null pointers), and the uppermost (64 - SIZE) bits are thus\n+   part of the range.  If WRAP_P is false, no wraparound is\n+   tested.  */\n \n-  if (mask & in)\n-    return false;\n+bool\n+s390_contiguous_bitmask_p (unsigned HOST_WIDE_INT in, bool wrap_p,\n+\t\t\t   int size, int *start, int *end)\n+{\n+  int bs = sizeof (HOST_WIDE_INT) * BITS_PER_UNIT;\n+  bool b;\n \n-  if (tmp_length + tmp_pos - 1 > size)\n+  gcc_assert (!!start == !!end);\n+  if ((in & ((~(0ULL)) >> (bs - size))) == 0)\n+    /* This cannot be expressed as a contiguous bitmask.  Exit early because\n+       the second call of s390_contiguous_bitmask_nowrap_p would accept this as\n+       a valid bitmask.  */\n     return false;\n+  b = s390_contiguous_bitmask_nowrap_p (in, size, start, end);\n+  if (b)\n+    return true;\n+  if (! wrap_p)\n+    return false;\n+  b = s390_contiguous_bitmask_nowrap_p (~in, size, start, end);\n+  if (b && start)\n+    {\n+      int s = *start;\n+      int e = *end;\n \n-  if (length)\n-    *length = tmp_length;\n-\n-  if (pos)\n-    *pos = tmp_pos;\n+      gcc_assert (s >= 1);\n+      *start = ((e + 1) & (bs - 1));\n+      *end = ((s - 1 + bs) & (bs - 1));\n+    }\n \n-  return true;\n+  return b;\n }\n \n /* Return true if OP contains the same contiguous bitfield in *all*\n@@ -2336,9 +2376,11 @@ bool\n s390_contiguous_bitmask_vector_p (rtx op, int *start, int *end)\n {\n   unsigned HOST_WIDE_INT mask;\n-  int length, size;\n+  int size;\n   rtx elt;\n+  bool b;\n \n+  gcc_assert (!!start == !!end);\n   if (!const_vec_duplicate_p (op, &elt)\n       || !CONST_INT_P (elt))\n     return false;\n@@ -2350,25 +2392,21 @@ s390_contiguous_bitmask_vector_p (rtx op, int *start, int *end)\n     return false;\n \n   mask = UINTVAL (elt);\n-  if (s390_contiguous_bitmask_p (mask, size, start,\n-\t\t\t\t end != NULL ? &length : NULL))\n-    {\n-      if (end != NULL)\n-\t*end = *start + length - 1;\n-      return true;\n-    }\n-  /* 0xff00000f style immediates can be covered by swapping start and\n-     end indices in vgm.  */\n-  if (s390_contiguous_bitmask_p (~mask, size, start,\n-\t\t\t\t end != NULL ? &length : NULL))\n+\n+  b = s390_contiguous_bitmask_p (mask, true, size, start, end);\n+  if (b)\n     {\n-      if (end != NULL)\n-\t*end = *start - 1;\n-      if (start != NULL)\n-\t*start = *start + length;\n+      if (start)\n+\t{\n+\t  int bs = sizeof (HOST_WIDE_INT) * BITS_PER_UNIT;\n+\n+\t  *start -= (bs - size);\n+\t  *end -= (bs - size);\n+\t}\n       return true;\n     }\n-  return false;\n+  else\n+    return false;\n }\n \n /* Return true if C consists only of byte chunks being either 0 or\n@@ -2422,14 +2460,21 @@ s390_bytemask_vector_p (rtx op, unsigned *mask)\n bool\n s390_extzv_shift_ok (int bitsize, int rotl, unsigned HOST_WIDE_INT contig)\n {\n-  int pos, len;\n+  int start, end;\n   bool ok;\n \n-  ok = s390_contiguous_bitmask_p (contig, bitsize, &pos, &len);\n+  ok = s390_contiguous_bitmask_nowrap_p (contig, bitsize, &start, &end);\n   gcc_assert (ok);\n \n-  return ((rotl >= 0 && rotl <= pos)\n-\t  || (rotl < 0 && -rotl <= bitsize - len - pos));\n+  if (rotl >= 0)\n+    return (64 - end >= rotl);\n+  else\n+    {\n+      /* Translate \"- rotate right\" in BITSIZE mode to \"rotate left\" in\n+\t DIMode.  */\n+      rotl = -rotl + (64 - bitsize);\n+      return (start >= rotl);\n+    }\n }\n \n /* Check whether we can (and want to) split a double-word\n@@ -7441,16 +7486,17 @@ print_operand (FILE *file, rtx x, int code)\n \tcase 'e': case 'f':\n \tcase 's': case 't':\n \t  {\n-\t    int pos, len;\n+\t    int start, end;\n+\t    int len;\n \t    bool ok;\n \n \t    len = (code == 's' || code == 'e' ? 64 : 32);\n-\t    ok = s390_contiguous_bitmask_p (ival, len, &pos, &len);\n+\t    ok = s390_contiguous_bitmask_p (ival, true, len, &start, &end);\n \t    gcc_assert (ok);\n \t    if (code == 's' || code == 't')\n-\t      ival = 64 - pos - len;\n+\t      ival = start;\n \t    else\n-\t      ival = 64 - 1 - pos;\n+\t      ival = end;\n \t  }\n \t  break;\n \tdefault:\n@@ -7490,16 +7536,12 @@ print_operand (FILE *file, rtx x, int code)\n \tcase 'e':\n \tcase 's':\n \t  {\n-\t    int start, stop, inner_len;\n+\t    int start, end;\n \t    bool ok;\n \n-\t    inner_len = GET_MODE_UNIT_BITSIZE (GET_MODE (x));\n-\t    ok = s390_contiguous_bitmask_vector_p (x, &start, &stop);\n+\t    ok = s390_contiguous_bitmask_vector_p (x, &start, &end);\n \t    gcc_assert (ok);\n-\t    if (code == 's' || code == 't')\n-\t      ival = inner_len - stop - 1;\n-\t    else\n-\t      ival = inner_len - start - 1;\n+\t    ival = (code == 's') ? start : end;\n \t    fprintf (file, HOST_WIDE_INT_PRINT_DEC, ival);\n \t  }\n \t  break;"}, {"sha": "2848b41656634cecbf135271ebb673fb0b6f609d", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=c2586c82cd3c03d20d5f00f5e4e8fded7652d4bc", "patch": "@@ -6962,7 +6962,7 @@\n   [(set (reg CC_REGNUM)\n         (compare\n \t  (and:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,d,0,    d\")\n-                  (match_operand:DI 2 \"general_operand\"      \" d,d,T,NxxDq\"))\n+                  (match_operand:DI 2 \"general_operand\"      \" d,d,T,NxxDw\"))\n           (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\"               \"=d,d,d,    d\")\n         (and:DI (match_dup 1) (match_dup 2)))]\n@@ -6980,7 +6980,7 @@\n   [(set (reg CC_REGNUM)\n         (compare\n \t  (and:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,d,0,    d\")\n-                  (match_operand:DI 2 \"general_operand\"      \" d,d,T,NxxDq\"))\n+                  (match_operand:DI 2 \"general_operand\"      \" d,d,T,NxxDw\"))\n                  (const_int 0)))\n    (clobber (match_scratch:DI 0                              \"=d,d,d,    d\"))]\n   \"TARGET_ZARCH\n@@ -7003,7 +7003,7 @@\n \t  (match_operand:DI 1 \"nonimmediate_operand\"\n             \"%d,o,    0,    0,    0,    0,    0,    0,0,d,0,    d,    0,0\")\n           (match_operand:DI 2 \"general_operand\"\n-            \"M, M,N0HDF,N1HDF,N2HDF,N3HDF,N0SDF,N1SDF,d,d,T,NxxDq,NxQDF,Q\")))\n+            \"M, M,N0HDF,N1HDF,N2HDF,N3HDF,N0SDF,N1SDF,d,d,T,NxxDw,NxQDF,Q\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_ZARCH && s390_logical_operator_ok_p (operands)\"\n   \"@\n@@ -7134,7 +7134,7 @@\n         (and:SI (match_operand:SI 1 \"nonimmediate_operand\"\n \t\t\t    \"%d,o,    0,    0, 0,0,d,0,0,    d,    0,0\")\n                 (match_operand:SI 2 \"general_operand\"\n-\t\t\t    \" M,M,N0HSF,N1HSF,Os,d,d,R,T,NxxSq,NxQSF,Q\")))\n+\t\t\t    \" M,M,N0HSF,N1HSF,Os,d,d,R,T,NxxSw,NxQSF,Q\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_ZARCH && s390_logical_operator_ok_p (operands)\"\n   \"@"}]}