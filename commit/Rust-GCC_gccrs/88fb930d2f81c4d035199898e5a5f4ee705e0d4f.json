{"sha": "88fb930d2f81c4d035199898e5a5f4ee705e0d4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhmYjkzMGQyZjgxYzRkMDM1MTk5ODk4ZTVhNWY0ZWU3MDVlMGQ0Zg==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2005-02-15T18:52:15Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2005-02-15T18:52:15Z"}, "message": "overflow-warn-1.c, [...]: New tests.\n\n\t* gcc.dg/overflow-warn-1.c, gcc.dg/overflow-warn-2.c,\n\tgcc.dg/overflow-warn-3.c, gcc.dg/overflow-warn-4.c: New tests.\n\nFrom-SVN: r95068", "tree": {"sha": "6d023bd7e792a38782f102298b963c0baa4acb37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d023bd7e792a38782f102298b963c0baa4acb37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88fb930d2f81c4d035199898e5a5f4ee705e0d4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88fb930d2f81c4d035199898e5a5f4ee705e0d4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88fb930d2f81c4d035199898e5a5f4ee705e0d4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88fb930d2f81c4d035199898e5a5f4ee705e0d4f/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a6cf91138c6dd450e7afc0ff088e2b64c7ef99e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a6cf91138c6dd450e7afc0ff088e2b64c7ef99e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a6cf91138c6dd450e7afc0ff088e2b64c7ef99e"}], "stats": {"total": 514, "additions": 514, "deletions": 0}, "files": [{"sha": "4de8e11cef1a32a355ff4ddde590bf9509d2416e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fb930d2f81c4d035199898e5a5f4ee705e0d4f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fb930d2f81c4d035199898e5a5f4ee705e0d4f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=88fb930d2f81c4d035199898e5a5f4ee705e0d4f", "patch": "@@ -1,3 +1,8 @@\n+2005-02-15  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.dg/overflow-warn-1.c, gcc.dg/overflow-warn-2.c,\n+\tgcc.dg/overflow-warn-3.c, gcc.dg/overflow-warn-4.c: New tests.\n+\n 2005-02-15  Andreas Schwab  <schwab@suse.de>\n \n \t* ada/acats/tests/cxb/cxb30131.c: Include <stdlib.h> to properly"}, {"sha": "fc02ce3e51a87cd7840cbf385667596a37b0a0da", "filename": "gcc/testsuite/gcc.dg/overflow-warn-1.c", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fb930d2f81c4d035199898e5a5f4ee705e0d4f/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fb930d2f81c4d035199898e5a5f4ee705e0d4f/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-1.c?ref=88fb930d2f81c4d035199898e5a5f4ee705e0d4f", "patch": "@@ -0,0 +1,121 @@\n+/* Test for diagnostics for constant overflow.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <limits.h>\n+\n+enum e {\n+  E0 = INT_MAX,\n+  /* Unsigned overflow wraps around.  */\n+  E1 = UINT_MAX + 1,\n+  /* Overflow in an unevaluated part of an expression is OK (example\n+     in the standard).  */\n+  E2 = 2 || 1 / 0,\n+  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n+  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n+     whole expression violates the constraints.  */\n+  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* Again, overflow in evaluated subexpression.  */\n+  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* A cast does not constitute overflow in conversion.  */\n+  E7 = (char) INT_MAX\n+};\n+\n+struct s {\n+  int a;\n+  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+};\n+\n+void\n+f (void)\n+{\n+  /* This expression is not required to be a constant expression, so\n+     it should just involve undefined behavior at runtime.  */\n+  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+/* But this expression does need to be constant.  */\n+static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+\n+/* The first two of these involve overflow, so are not null pointer\n+   constants.  The third has the overflow in an unevaluated\n+   subexpression, so is a null pointer constant.  */\n+void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+/* { dg-warning \"warning: initialization makes pointer from integer without a cast\" \"null\" { target *-*-* } 48 } */\n+void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+/* { dg-warning \"warning: initialization makes pointer from integer without a cast\" \"null\" { xfail *-*-* } 50 } */\n+void *r = (1 ? 0 : INT_MAX+1);\n+\n+void\n+g (int i)\n+{\n+  switch (i)\n+    {\n+    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n+      ;\n+    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n+      ;\n+    }\n+}\n+\n+int\n+h (void)\n+{\n+  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+int\n+h1 (void)\n+{\n+  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+void fuc (unsigned char);\n+void fsc (signed char);\n+\n+void\n+h2 (void)\n+{\n+  fsc (SCHAR_MAX + 1);\n+  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX);\n+  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fuc (-1);\n+  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (SCHAR_MIN);\n+  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+}\n+\n+void fui (unsigned int);\n+void fsi (signed int);\n+\n+int si;\n+unsigned ui;\n+\n+void\n+h2i (int x)\n+{\n+  /* For some reason, we only give certain warnings for implicit\n+     conversions among values of the same precision with -Wconversion,\n+     while we don't give others at all.  */\n+  fsi ((unsigned)INT_MAX + 1);\n+  si = (unsigned)INT_MAX + 1;\n+  si = x ? (unsigned)INT_MAX + 1 : 1;\n+  fsi ((unsigned)INT_MAX + 2);\n+  si = (unsigned)INT_MAX + 2;\n+  si = x ? (unsigned)INT_MAX + 2 : 1;\n+  fsi (UINT_MAX);\n+  si = UINT_MAX;\n+  fui (-1);\n+  ui = -1;\n+  ui = x ? -1 : 1U;\n+  fui (INT_MIN);\n+  ui = INT_MIN;\n+  ui = x ? INT_MIN : 1U;\n+}"}, {"sha": "189f727036314610545c94716bf1c3fe459c31f0", "filename": "gcc/testsuite/gcc.dg/overflow-warn-2.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fb930d2f81c4d035199898e5a5f4ee705e0d4f/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fb930d2f81c4d035199898e5a5f4ee705e0d4f/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-2.c?ref=88fb930d2f81c4d035199898e5a5f4ee705e0d4f", "patch": "@@ -0,0 +1,132 @@\n+/* Test for diagnostics for constant overflow.  Test with -Wconversion.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -Wconversion\" } */\n+\n+#include <limits.h>\n+\n+enum e {\n+  E0 = INT_MAX,\n+  /* Unsigned overflow wraps around.  */\n+  E1 = UINT_MAX + 1,\n+  /* Overflow in an unevaluated part of an expression is OK (example\n+     in the standard).  */\n+  E2 = 2 || 1 / 0,\n+  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n+  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n+     whole expression violates the constraints.  */\n+  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* Again, overflow in evaluated subexpression.  */\n+  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* A cast does not constitute overflow in conversion.  */\n+  E7 = (char) INT_MAX\n+};\n+\n+struct s {\n+  int a;\n+  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+};\n+\n+void\n+f (void)\n+{\n+  /* This expression is not required to be a constant expression, so\n+     it should just involve undefined behavior at runtime.  */\n+  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+/* But this expression does need to be constant.  */\n+static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+\n+/* The first two of these involve overflow, so are not null pointer\n+   constants.  The third has the overflow in an unevaluated\n+   subexpression, so is a null pointer constant.  */\n+void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+/* { dg-warning \"warning: initialization makes pointer from integer without a cast\" \"null\" { target *-*-* } 48 } */\n+void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+/* { dg-warning \"warning: initialization makes pointer from integer without a cast\" \"null\" { xfail *-*-* } 50 } */\n+void *r = (1 ? 0 : INT_MAX+1);\n+\n+void\n+g (int i)\n+{\n+  switch (i)\n+    {\n+    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n+      ;\n+    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n+      ;\n+    }\n+}\n+\n+int\n+h (void)\n+{\n+  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+int\n+h1 (void)\n+{\n+  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+void fuc (unsigned char);\n+void fsc (signed char);\n+\n+void\n+h2 (void)\n+{\n+  fsc (SCHAR_MAX + 1);\n+  /* { dg-warning \"warning: passing argument 1 of 'fsc' with different width due to prototype\" \"-Wconversion\" { target *-*-* } 84 } */\n+  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  /* { dg-warning \"warning: passing argument 1 of 'fsc' with different width due to prototype\" \"-Wconversion\" { target *-*-* } 86 } */\n+  fsc (UCHAR_MAX);\n+  /* { dg-warning \"warning: passing argument 1 of 'fsc' with different width due to prototype\" \"-Wconversion\" { target *-*-* } 88 } */\n+  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  /* { dg-warning \"warning: passing argument 1 of 'fsc' with different width due to prototype\" \"-Wconversion\" { target *-*-* } 90 } */\n+  fuc (-1); /* { dg-warning \"warning: negative integer implicitly converted to unsigned type\" } */\n+  /* { dg-warning \"warning: passing argument 1 of 'fuc' with different width due to prototype\" \"-Wconversion\" { target *-*-* } 92 } */\n+  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  /* { dg-warning \"warning: passing argument 1 of 'fuc' with different width due to prototype\" \"-Wconversion\" { target *-*-* } 94 } */\n+  fuc (SCHAR_MIN); /* { dg-warning \"warning: negative integer implicitly converted to unsigned type\" } */\n+  /* { dg-warning \"warning: passing argument 1 of 'fuc' with different width due to prototype\" \"-Wconversion\" { target *-*-* } 96 } */\n+  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  /* { dg-warning \"warning: passing argument 1 of 'fuc' with different width due to prototype\" \"-Wconversion\" { target *-*-* } 98 } */\n+  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  /* { dg-warning \"warning: passing argument 1 of 'fuc' with different width due to prototype\" \"-Wconversion\" { target *-*-* } 100 } */\n+}\n+\n+void fui (unsigned int);\n+void fsi (signed int);\n+\n+int si;\n+unsigned ui;\n+\n+void\n+h2i (int x)\n+{\n+  /* For some reason, we only give certain warnings for implicit\n+     conversions among values of the same precision with -Wconversion,\n+     while we don't give others at all.  */\n+  fsi ((unsigned)INT_MAX + 1); /* { dg-warning \"warning: passing argument 1 of 'fsi' as signed due to prototype\" } */\n+  si = (unsigned)INT_MAX + 1;\n+  si = x ? (unsigned)INT_MAX + 1 : 1;\n+  fsi ((unsigned)INT_MAX + 2); /* { dg-warning \"warning: passing argument 1 of 'fsi' as signed due to prototype\" } */\n+  si = (unsigned)INT_MAX + 2;\n+  si = x ? (unsigned)INT_MAX + 2 : 1;\n+  fsi (UINT_MAX); /* { dg-warning \"warning: passing argument 1 of 'fsi' as signed due to prototype\" } */\n+  si = UINT_MAX;\n+  fui (-1); /* { dg-warning \"warning: negative integer implicitly converted to unsigned type\" } */\n+  /* { dg-warning \"warning: passing argument 1 of 'fui' as unsigned due to prototype\" \"-Wconversion\" { target *-*-* } 124 } */\n+  ui = -1; /* { dg-warning \"warning: negative integer implicitly converted to unsigned type\" } */\n+  ui = x ? -1 : 1U; /* { dg-warning \"warning: negative integer implicitly converted to unsigned type\" } */\n+  fui (INT_MIN); /* { dg-warning \"warning: negative integer implicitly converted to unsigned type\" } */\n+  /* { dg-warning \"warning: passing argument 1 of 'fui' as unsigned due to prototype\" \"-Wconversion\" { target *-*-* } 128 } */\n+  ui = INT_MIN; /* { dg-warning \"warning: negative integer implicitly converted to unsigned type\" } */\n+  ui = x ? INT_MIN : 1U; /* { dg-warning \"warning: negative integer implicitly converted to unsigned type\" } */\n+}"}, {"sha": "f20940efdcd11a1fa0fe88244ad29268bcc3d0ff", "filename": "gcc/testsuite/gcc.dg/overflow-warn-3.c", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fb930d2f81c4d035199898e5a5f4ee705e0d4f/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fb930d2f81c4d035199898e5a5f4ee705e0d4f/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-3.c?ref=88fb930d2f81c4d035199898e5a5f4ee705e0d4f", "patch": "@@ -0,0 +1,128 @@\n+/* Test for diagnostics for constant overflow.  Test with -pedantic.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -pedantic\" } */\n+\n+#include <limits.h>\n+\n+enum e {\n+  E0 = INT_MAX,\n+  /* Unsigned overflow wraps around.  */\n+  E1 = UINT_MAX + 1,\n+  /* Overflow in an unevaluated part of an expression is OK (example\n+     in the standard).  */\n+  E2 = 2 || 1 / 0,\n+  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n+  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n+     whole expression violates the constraints.  */\n+  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n+  /* Again, overflow in evaluated subexpression.  */\n+  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 24 } */\n+  /* A cast does not constitute overflow in conversion.  */\n+  E7 = (char) INT_MAX\n+};\n+\n+struct s {\n+  int a;\n+  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 33 } */\n+};\n+\n+void\n+f (void)\n+{\n+  /* This expression is not required to be a constant expression, so\n+     it should just involve undefined behavior at runtime.  */\n+  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-bogus \"warning: overflow in constant expression\" \"constant\" { xfail *-*-* } 42 } */\n+}\n+\n+/* But this expression does need to be constant.  */\n+static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+/* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 47 } */\n+\n+/* The first two of these involve overflow, so are not null pointer\n+   constants.  The third has the overflow in an unevaluated\n+   subexpression, so is a null pointer constant.  */\n+void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+/* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 53 } */\n+/* { dg-warning \"warning: initialization makes pointer from integer without a cast\" \"null\" { target *-*-* } 53 } */\n+void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+/* { dg-warning \"warning: initialization makes pointer from integer without a cast\" \"null\" { xfail *-*-* } 56 } */\n+void *r = (1 ? 0 : INT_MAX+1);\n+\n+void\n+g (int i)\n+{\n+  switch (i)\n+    {\n+    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n+      ;\n+    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n+      /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 67 } */\n+      ;\n+    }\n+}\n+\n+int\n+h (void)\n+{\n+  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+int\n+h1 (void)\n+{\n+  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+void fuc (unsigned char);\n+void fsc (signed char);\n+\n+void\n+h2 (void)\n+{\n+  fsc (SCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fuc (-1);\n+  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (SCHAR_MIN);\n+  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+}\n+\n+void fui (unsigned int);\n+void fsi (signed int);\n+\n+int si;\n+unsigned ui;\n+\n+void\n+h2i (int x)\n+{\n+  /* For some reason, we only give certain warnings for implicit\n+     conversions among values of the same precision with -Wconversion,\n+     while we don't give others at all.  */\n+  fsi ((unsigned)INT_MAX + 1);\n+  si = (unsigned)INT_MAX + 1;\n+  si = x ? (unsigned)INT_MAX + 1 : 1;\n+  fsi ((unsigned)INT_MAX + 2);\n+  si = (unsigned)INT_MAX + 2;\n+  si = x ? (unsigned)INT_MAX + 2 : 1;\n+  fsi (UINT_MAX);\n+  si = UINT_MAX;\n+  fui (-1);\n+  ui = -1;\n+  ui = x ? -1 : 1U;\n+  fui (INT_MIN);\n+  ui = INT_MIN;\n+  ui = x ? INT_MIN : 1U;\n+}"}, {"sha": "acf2c876bf21be27ccedc15b6198824285f2097e", "filename": "gcc/testsuite/gcc.dg/overflow-warn-4.c", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fb930d2f81c4d035199898e5a5f4ee705e0d4f/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fb930d2f81c4d035199898e5a5f4ee705e0d4f/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-4.c?ref=88fb930d2f81c4d035199898e5a5f4ee705e0d4f", "patch": "@@ -0,0 +1,128 @@\n+/* Test for diagnostics for constant overflow.  Test with -pedantic-errors.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -pedantic-errors\" } */\n+\n+#include <limits.h>\n+\n+enum e {\n+  E0 = INT_MAX,\n+  /* Unsigned overflow wraps around.  */\n+  E1 = UINT_MAX + 1,\n+  /* Overflow in an unevaluated part of an expression is OK (example\n+     in the standard).  */\n+  E2 = 2 || 1 / 0,\n+  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n+  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n+     whole expression violates the constraints.  */\n+  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n+  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n+  /* Again, overflow in evaluated subexpression.  */\n+  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 24 } */\n+  /* A cast does not constitute overflow in conversion.  */\n+  E7 = (char) INT_MAX\n+};\n+\n+struct s {\n+  int a;\n+  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 33 } */\n+};\n+\n+void\n+f (void)\n+{\n+  /* This expression is not required to be a constant expression, so\n+     it should just involve undefined behavior at runtime.  */\n+  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+  /* { dg-bogus \"error: overflow in constant expression\" \"constant\" { xfail *-*-* } 42 } */\n+}\n+\n+/* But this expression does need to be constant.  */\n+static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+/* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 47 } */\n+\n+/* The first two of these involve overflow, so are not null pointer\n+   constants.  The third has the overflow in an unevaluated\n+   subexpression, so is a null pointer constant.  */\n+void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n+/* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 53 } */\n+/* { dg-error \"error: initialization makes pointer from integer without a cast\" \"null\" { target *-*-* } 53 } */\n+void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n+/* { dg-error \"error: initialization makes pointer from integer without a cast\" \"null\" { xfail *-*-* } 56 } */\n+void *r = (1 ? 0 : INT_MAX+1);\n+\n+void\n+g (int i)\n+{\n+  switch (i)\n+    {\n+    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n+      ;\n+    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n+      /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 67 } */\n+      ;\n+    }\n+}\n+\n+int\n+h (void)\n+{\n+  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+int\n+h1 (void)\n+{\n+  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n+}\n+\n+void fuc (unsigned char);\n+void fsc (signed char);\n+\n+void\n+h2 (void)\n+{\n+  fsc (SCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n+  fuc (-1);\n+  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (SCHAR_MIN);\n+  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n+}\n+\n+void fui (unsigned int);\n+void fsi (signed int);\n+\n+int si;\n+unsigned ui;\n+\n+void\n+h2i (int x)\n+{\n+  /* For some reason, we only give certain warnings for implicit\n+     conversions among values of the same precision with -Wconversion,\n+     while we don't give others at all.  */\n+  fsi ((unsigned)INT_MAX + 1);\n+  si = (unsigned)INT_MAX + 1;\n+  si = x ? (unsigned)INT_MAX + 1 : 1;\n+  fsi ((unsigned)INT_MAX + 2);\n+  si = (unsigned)INT_MAX + 2;\n+  si = x ? (unsigned)INT_MAX + 2 : 1;\n+  fsi (UINT_MAX);\n+  si = UINT_MAX;\n+  fui (-1);\n+  ui = -1;\n+  ui = x ? -1 : 1U;\n+  fui (INT_MIN);\n+  ui = INT_MIN;\n+  ui = x ? INT_MIN : 1U;\n+}"}]}