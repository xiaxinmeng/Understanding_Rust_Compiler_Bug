{"sha": "8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZmZjRmYzEzNmEzZTZhYjJmNGJjM2EyOTI0MWE2MThiMDY5ODhiZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-04T08:07:15Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-04T08:07:15Z"}, "message": "rtl.def (ADDRESSOF): Remove.\n\n\t* rtl.def (ADDRESSOF): Remove.\n\t* alias.c (rtx_equal_for_memref_p): Don't handle addressof.\n\t(find_base_term, memrefs_conflict_p): Likewise.\n\t* cse.c (fixed_base_plus_p, find_best_addr: Likewise.\n\t(fold_rtx, cse_insn, set_live_p): Likewise.\n\t* dwarf2out.c (mem_loc_descriptor): Likewise.\n\t(add_location_or_const_value_attribute): Likewise.\n\t* emit-rtl.c (copy_insn_1): Likewise.\n\t* explow.c (memory_address): Likewise.\n\t* expmed.c (store_split_bit_field): Likewise.\n\t* expr.c (expand_expr_real_1): Likewise.\n\t* function.c (instantiate_decl\n\t(instantiate_virtual_regs_1, fix_lexical_addr): Likewise.\n\t* genrecog.c (preds, validate_pattern): Likewise.\n\t* integrate.c (copy_rtx_and_substitute): Likewise.\n\t* recog.c (general_operand, register_operand): Likewise.\n\t(memory_address_p): Likwise.\n\t* reload1.c (eliminate_regs, elimination_effects): Likewise.\n\t* rtl.c (copy_rtx): Likewise.\n\t* rtlanal.c (rtx_unstable_p, rtx_varies_p): Likewise.\n\t(rtx_addr_can_trap_p, nonzero_address_p, address_cost): Likewise.\n\t* rtlhooks.c (gen_lowpart_general): Likewise.\n\t* stmt.c (expand_asm_operands): Likewise.\n\t* web.c (entry_register, replace_ref, web_main): Likewise.\n\t* config/alpha/alpha.c (input_operand, alpha_legitimate_address_p,\n\talpha_expand_block_move, alpha_expand_block_clear): Likewise.\n\t* config/arm/arm.c (thumb_rtx_costs): Likewise.\n\t* config/c4x/c4x.c (c4x_valid_operands): Likewise.\n\t* config/frv/frv.c (move_destination_operand, move_source_operand,\n\tcondexec_dest_operand, condexec_source_operand,\n\tcondexec_memory_operand): Likewise.\n\t* config/h8300/h8300.h (PREDICATE_CODES): Likewise.\n\t* config/ia64/ia64.c (general_xfmode_operand): Likewise.\n\t(destination_xfmode_operand): Likewise.\n\t* config/mips/mips.h (PREDICATE_CODES): Likewise.\n\t* config/mn10300/mn10300.c (mn10300_address_cost_1): Likewise.\n\t* config/s390/s390.c (general_s_operand): Likewise.\n\t* config/s390/s390.md (mov*): Likewise.\n\t* config/sparc/sparc.h (PREDICATE_CODES): Likewise.\n\n\t* c-typeck.c (c_mark_addressable): Don't put_var_into_stack.\n\t* expr.c (expand_expr_real_1): Likewise.\n\t* stmt.c (expand_decl): Likewise.\n\t* config/c4x/c4x.c (c4x_expand_builtin): Likewise.\n\n\t* function.c (struct fixup_replacement, struct insns_for_mem_entry,\n\tpostponed_insns, put_var_into_stack, put_reg_into_stack,\n\tschedule_fixup_var_refs, fixup_var_refs, find_fixup_replacement,\n\tfixup_var_refs_insns, fixup_var_refs_insns_with_hash,\n\tfixup_var_refs_insn, fixup_var_refs_1, fixup_memory_subreg,\n\twalk_fixup_memory_subreg, fixup_stack_1, optimize_bit_field,\n\tgen_mem_addressof, flush_addressof, put_addressof_into_stack,\n\tpurge_bitfield_addressof_replacements, purge_addressof_replacements,\n\tpurge_addressof_1, insns_for_mem_hash, insns_for_mem_comp,\n\tstruct insns_for_mem_walk_info, insns_for_mem_walk,\n\tcompute_insns_for_mem, is_addressof, purge_addressof, setjmp_protect,\n\tsetjmp_protect_args): Remove.\n\t(push_function_context_to): Don't handle var_refs_queue.\n\t(pop_function_context_from, free_after_compilation): Likewise.\n\t(instantiate_virtual_regs): Don't handle parm_reg_stack_loc.\n\t(assign_parms, allocate_struct_function): Likewise.\n\t(use_register_for_decl): New.\n\t(expand_function_end): Don't setjmp_protect.\n\t* function.h (struct emit_status): Update commentary.\n\t(struct function): Remove x_max_parm_reg, x_parm_reg_stack_loc.\n\t(max_parm_reg, parm_reg_stack_loc): Remove.\n\t* passes.c (DFI_addressof): Remove.\n\t(dump_file_info): Remove addressof.\n\t(rest_of_handle_addressof): Remove.\n\t(rest_of_compilation): Don't call it.\n\t* rtl.h (ADDRESSOF_REGNO, ADDRESSOF_DECL): Remove.\n\t* stmt.c (expand_decl): Use use_register_for_decl.\n\t* tree.h: Update decls.\n\t* web.c (mark_addressof): Remove.\n\t* doc/invoke.texi (-dF): Remove.\n\nada/\n        * utils2.c (gnat_mark_addressable): Don't put_var_into_stack.\ncp/\n        * typeck.c (cxx_mark_addressable): Don't put_var_into_stack.\nfortran/\n        * f95-lang.c (gfc_mark_addressable): Don't put_var_into_stack.\ntreelang/\n        * treetree.c (tree_mark_addressable):  Don't put_var_into_stack.\n\nFrom-SVN: r84072", "tree": {"sha": "d8e587b078a6e56d763f14d68c29fef196cd5322", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8e587b078a6e56d763f14d68c29fef196cd5322"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/comments", "author": null, "committer": null, "parents": [{"sha": "68d22aa55a9a4f491851f37a6a377ed50ea8e292", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68d22aa55a9a4f491851f37a6a377ed50ea8e292", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68d22aa55a9a4f491851f37a6a377ed50ea8e292"}], "stats": {"total": 3321, "additions": 329, "deletions": 2992}, "files": [{"sha": "e9f7ce28e170497b7df35229e09300a10ff1044e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -1,3 +1,81 @@\n+2004-07-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* rtl.def (ADDRESSOF): Remove.\n+\t* alias.c (rtx_equal_for_memref_p): Don't handle addressof.\n+\t(find_base_term, memrefs_conflict_p): Likewise.\n+\t* cse.c (fixed_base_plus_p, find_best_addr: Likewise.\n+\t(fold_rtx, cse_insn, set_live_p): Likewise.\n+\t* dwarf2out.c (mem_loc_descriptor): Likewise.\n+\t(add_location_or_const_value_attribute): Likewise.\n+\t* emit-rtl.c (copy_insn_1): Likewise.\n+\t* explow.c (memory_address): Likewise.\n+\t* expmed.c (store_split_bit_field): Likewise.\n+\t* expr.c (expand_expr_real_1): Likewise.\n+\t* function.c (instantiate_decl\n+\t(instantiate_virtual_regs_1, fix_lexical_addr): Likewise.\n+\t* genrecog.c (preds, validate_pattern): Likewise.\n+\t* integrate.c (copy_rtx_and_substitute): Likewise.\n+\t* recog.c (general_operand, register_operand): Likewise.\n+\t(memory_address_p): Likwise.\n+\t* reload1.c (eliminate_regs, elimination_effects): Likewise.\n+\t* rtl.c (copy_rtx): Likewise.\n+\t* rtlanal.c (rtx_unstable_p, rtx_varies_p): Likewise.\n+\t(rtx_addr_can_trap_p, nonzero_address_p, address_cost): Likewise.\n+\t* rtlhooks.c (gen_lowpart_general): Likewise.\n+\t* stmt.c (expand_asm_operands): Likewise.\n+\t* web.c (entry_register, replace_ref, web_main): Likewise.\n+\t* config/alpha/alpha.c (input_operand, alpha_legitimate_address_p,\n+\talpha_expand_block_move, alpha_expand_block_clear): Likewise.\n+\t* config/arm/arm.c (thumb_rtx_costs): Likewise.\n+\t* config/c4x/c4x.c (c4x_valid_operands): Likewise.\n+\t* config/frv/frv.c (move_destination_operand, move_source_operand,\n+\tcondexec_dest_operand, condexec_source_operand,\n+\tcondexec_memory_operand): Likewise.\n+\t* config/h8300/h8300.h (PREDICATE_CODES): Likewise.\n+\t* config/ia64/ia64.c (general_xfmode_operand): Likewise.\n+\t(destination_xfmode_operand): Likewise.\n+\t* config/mips/mips.h (PREDICATE_CODES): Likewise.\n+\t* config/mn10300/mn10300.c (mn10300_address_cost_1): Likewise.\n+\t* config/s390/s390.c (general_s_operand): Likewise.\n+\t* config/s390/s390.md (mov*): Likewise.\n+\t* config/sparc/sparc.h (PREDICATE_CODES): Likewise.\n+\n+\t* c-typeck.c (c_mark_addressable): Don't put_var_into_stack.\n+\t* expr.c (expand_expr_real_1): Likewise.\n+\t* stmt.c (expand_decl): Likewise.\n+\t* config/c4x/c4x.c (c4x_expand_builtin): Likewise.\n+\n+\t* function.c (struct fixup_replacement, struct insns_for_mem_entry,\n+\tpostponed_insns, put_var_into_stack, put_reg_into_stack,\n+\tschedule_fixup_var_refs, fixup_var_refs, find_fixup_replacement,\n+\tfixup_var_refs_insns, fixup_var_refs_insns_with_hash,\n+\tfixup_var_refs_insn, fixup_var_refs_1, fixup_memory_subreg,\n+\twalk_fixup_memory_subreg, fixup_stack_1, optimize_bit_field,\n+\tgen_mem_addressof, flush_addressof, put_addressof_into_stack,\n+\tpurge_bitfield_addressof_replacements, purge_addressof_replacements,\n+\tpurge_addressof_1, insns_for_mem_hash, insns_for_mem_comp,\n+\tstruct insns_for_mem_walk_info, insns_for_mem_walk, \n+\tcompute_insns_for_mem, is_addressof, purge_addressof, setjmp_protect,\n+\tsetjmp_protect_args): Remove.\n+\t(push_function_context_to): Don't handle var_refs_queue.\n+\t(pop_function_context_from, free_after_compilation): Likewise.\n+\t(instantiate_virtual_regs): Don't handle parm_reg_stack_loc.\n+\t(assign_parms, allocate_struct_function): Likewise.\n+\t(use_register_for_decl): New.\n+\t(expand_function_end): Don't setjmp_protect.\n+\t* function.h (struct emit_status): Update commentary.\n+\t(struct function): Remove x_max_parm_reg, x_parm_reg_stack_loc.\n+\t(max_parm_reg, parm_reg_stack_loc): Remove.\n+\t* passes.c (DFI_addressof): Remove.\n+\t(dump_file_info): Remove addressof.\n+\t(rest_of_handle_addressof): Remove.\n+\t(rest_of_compilation): Don't call it.\n+\t* rtl.h (ADDRESSOF_REGNO, ADDRESSOF_DECL): Remove.\n+\t* stmt.c (expand_decl): Use use_register_for_decl.\n+\t* tree.h: Update decls.\n+\t* web.c (mark_addressof): Remove.\n+\t* doc/invoke.texi (-dF): Remove.\n+\n 2004-07-03  Richard Henderson  <rth@redhat.com>\n \n \t* config/ia64/ia64.c (spill_xfmode_operand): Use assign_stack_temp"}, {"sha": "12669bec53227d60122347986f89f0b5164c701e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -1,3 +1,7 @@\n+2004-07-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* utils2.c (gnat_mark_addressable): Don't put_var_into_stack.\n+\n 2004-07-01  Richard Henderson  <rth@redhat.com>\n \n \t* trans.c (gnat_stabilize_reference): Don't handle RTL_EXPR."}, {"sha": "85b0a7452fff4117bb29d197d96fabff4955e530", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -1987,7 +1987,6 @@ gnat_mark_addressable (tree expr_node)\n       case VAR_DECL:\n       case PARM_DECL:\n       case RESULT_DECL:\n-\tput_var_into_stack (expr_node, 1);\n \tTREE_ADDRESSABLE (expr_node) = 1;\n \treturn true;\n "}, {"sha": "9e53d9bb07f4d4b52b1df7d3050981b5a2b74894", "filename": "gcc/alias.c", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -1256,11 +1256,6 @@ rtx_equal_for_memref_p (rtx x, rtx y)\n \t comparison for these nodes.  */\n       return 0;\n \n-    case ADDRESSOF:\n-      return (XINT (x, 1) == XINT (y, 1)\n-\t      && rtx_equal_for_memref_p (XEXP (x, 0),\n-\t\t\t\t\t XEXP (y, 0)));\n-\n     default:\n       break;\n     }\n@@ -1502,9 +1497,6 @@ find_base_term (rtx x)\n     case LABEL_REF:\n       return x;\n \n-    case ADDRESSOF:\n-      return REG_BASE_VALUE (frame_pointer_rtx);\n-\n     default:\n       return 0;\n     }\n@@ -1826,18 +1818,6 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n       return memrefs_conflict_p (xsize, x, ysize, canon_rtx (XEXP (y, 0)), c);\n     }\n \n-  if (GET_CODE (x) == ADDRESSOF)\n-    {\n-      if (y == frame_pointer_rtx\n-\t  || GET_CODE (y) == ADDRESSOF)\n-\treturn xsize <= 0 || ysize <= 0;\n-    }\n-  if (GET_CODE (y) == ADDRESSOF)\n-    {\n-      if (x == frame_pointer_rtx)\n-\treturn xsize <= 0 || ysize <= 0;\n-    }\n-\n   if (CONSTANT_P (x))\n     {\n       if (GET_CODE (x) == CONST_INT && GET_CODE (y) == CONST_INT)"}, {"sha": "e5f94915cf2327295e5d375a912d2151e79d6b91", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -2714,7 +2714,6 @@ c_mark_addressable (tree exp)\n \t    pedwarn (\"address of register variable `%s' requested\",\n \t\t     IDENTIFIER_POINTER (DECL_NAME (x)));\n \t  }\n-\tput_var_into_stack (x, /*rescan=*/true);\n \n \t/* drops in */\n       case FUNCTION_DECL:"}, {"sha": "0fe8b000514744a832957d7606b650709c659db3", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -806,7 +806,6 @@ input_operand (rtx op, enum machine_mode mode)\n \t      && local_symbolic_operand (XEXP (op, 0), mode));\n \n     case REG:\n-    case ADDRESSOF:\n       return 1;\n \n     case SUBREG:\n@@ -1725,9 +1724,6 @@ alpha_legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n \t      && CONSTANT_ADDRESS_P (ofs))\n \t    return true;\n \t}\n-      else if (GET_CODE (x) == ADDRESSOF\n-\t       && GET_CODE (ofs) == CONST_INT)\n-\treturn true;\n     }\n \n   /* If we're managing explicit relocations, LO_SUM is valid, as\n@@ -4486,39 +4482,6 @@ alpha_expand_block_move (rtx operands[])\n \t}\n     }\n \n-  /* Load the entire block into registers.  */\n-  if (GET_CODE (XEXP (orig_src, 0)) == ADDRESSOF)\n-    {\n-      enum machine_mode mode;\n-\n-      tmp = XEXP (XEXP (orig_src, 0), 0);\n-\n-      /* Don't use the existing register if we're reading more than\n-\t is held in the register.  Nor if there is not a mode that\n-\t handles the exact size.  */\n-      mode = mode_for_size (bytes * BITS_PER_UNIT, MODE_INT, 1);\n-      if (GET_CODE (tmp) == REG\n-\t  && mode != BLKmode\n-\t  && GET_MODE_SIZE (GET_MODE (tmp)) >= bytes)\n-\t{\n-\t  if (mode == TImode)\n-\t    {\n-\t      data_regs[nregs] = gen_lowpart (DImode, tmp);\n-\t      data_regs[nregs + 1] = gen_highpart (DImode, tmp);\n-\t      nregs += 2;\n-\t    }\n-\t  else\n-\t    data_regs[nregs++] = gen_lowpart (mode, tmp);\n-\n-\t  goto src_done;\n-\t}\n-\n-      /* No appropriate mode; fall back on memory.  */\n-      orig_src = replace_equiv_address (orig_src,\n-\t\t\t\t\tcopy_addr_to_reg (XEXP (orig_src, 0)));\n-      src_align = GET_MODE_BITSIZE (GET_MODE (tmp));\n-    }\n-\n   ofs = 0;\n   if (src_align >= 64 && bytes >= 8)\n     {\n@@ -4603,66 +4566,13 @@ alpha_expand_block_move (rtx operands[])\n       ofs += 1;\n     }\n \n- src_done:\n-\n   if (nregs > ARRAY_SIZE (data_regs))\n     abort ();\n \n   /* Now save it back out again.  */\n \n   i = 0, ofs = 0;\n \n-  if (GET_CODE (XEXP (orig_dst, 0)) == ADDRESSOF)\n-    {\n-      enum machine_mode mode;\n-      tmp = XEXP (XEXP (orig_dst, 0), 0);\n-\n-      mode = mode_for_size (orig_bytes * BITS_PER_UNIT, MODE_INT, 1);\n-      if (GET_CODE (tmp) == REG && GET_MODE (tmp) == mode)\n-\t{\n-\t  if (nregs == 1)\n-\t    {\n-\t      emit_move_insn (tmp, data_regs[0]);\n-\t      i = 1;\n-\t      goto dst_done;\n-\t    }\n-\n-\t  else if (nregs == 2 && mode == TImode)\n-\t    {\n-\t      /* Undo the subregging done above when copying between\n-\t\t two TImode registers.  */\n-\t      if (GET_CODE (data_regs[0]) == SUBREG\n-\t\t  && GET_MODE (SUBREG_REG (data_regs[0])) == TImode)\n-\t\temit_move_insn (tmp, SUBREG_REG (data_regs[0]));\n-\t      else\n-\t\t{\n-\t\t  rtx seq;\n-\n-\t\t  start_sequence ();\n-\t\t  emit_move_insn (gen_lowpart (DImode, tmp), data_regs[0]);\n-\t\t  emit_move_insn (gen_highpart (DImode, tmp), data_regs[1]);\n-\t\t  seq = get_insns ();\n-\t\t  end_sequence ();\n-\n-\t\t  emit_no_conflict_block (seq, tmp, data_regs[0],\n-\t\t\t\t\t  data_regs[1], NULL_RTX);\n-\t\t}\n-\n-\t      i = 2;\n-\t      goto dst_done;\n-\t    }\n-\t}\n-\n-      /* ??? If nregs > 1, consider reconstructing the word in regs.  */\n-      /* ??? Optimize mode < dst_mode with strict_low_part.  */\n-\n-      /* No appropriate mode; fall back on memory.  We can speed things\n-\t up by recognizing extra alignment information.  */\n-      orig_dst = replace_equiv_address (orig_dst,\n-\t\t\t\t\tcopy_addr_to_reg (XEXP (orig_dst, 0)));\n-      dst_align = GET_MODE_BITSIZE (GET_MODE (tmp));\n-    }\n-\n   /* Write out the data in whatever chunks reading the source allowed.  */\n   if (dst_align >= 64)\n     {\n@@ -4751,8 +4661,6 @@ alpha_expand_block_move (rtx operands[])\n       ofs += 1;\n     }\n \n- dst_done:\n-\n   if (i != nregs)\n     abort ();\n \n@@ -4798,21 +4706,6 @@ alpha_expand_block_clear (rtx operands[])\n \t    align = a, alignofs = 2 - c % 2;\n \t}\n     }\n-  else if (GET_CODE (tmp) == ADDRESSOF)\n-    {\n-      enum machine_mode mode;\n-\n-      mode = mode_for_size (bytes * BITS_PER_UNIT, MODE_INT, 1);\n-      if (GET_MODE (XEXP (tmp, 0)) == mode)\n-\t{\n-\t  emit_move_insn (XEXP (tmp, 0), const0_rtx);\n-\t  return 1;\n-\t}\n-\n-      /* No appropriate mode; fall back on memory.  */\n-      orig_dst = replace_equiv_address (orig_dst, copy_addr_to_reg (tmp));\n-      align = GET_MODE_BITSIZE (GET_MODE (XEXP (tmp, 0)));\n-    }\n \n   /* Handle an unaligned prefix first.  */\n "}, {"sha": "37b13fe4c363f7fd40fa5dbbf0ac8b6bb9e980e8", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -3550,7 +3550,6 @@ thumb_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n       /* XXX guess.  */\n       return 8;\n \n-    case ADDRESSOF:\n     case MEM:\n       /* XXX another guess.  */\n       /* Memory costs quite a lot for the first word, but subsequent words"}, {"sha": "62f8679997c5e92160eb77cdd576c70e3bc193bf", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -3812,12 +3812,6 @@ c4x_valid_operands (enum rtx_code code, rtx *operands,\n   \tcase MEM:\n \t  break;\n \t  \n-\t  /* After CSE, any remaining (ADDRESSOF:P reg) gets converted\n-\t     into a stack slot memory address comprising a PLUS and a\n-\t     constant.  */\n-\tcase ADDRESSOF:\n-\t  break;\n-\t  \n \tdefault:\n \t  fatal_insn (\"c4x_valid_operands: Internal error\", op2);\n \t  break;\n@@ -3862,12 +3856,6 @@ c4x_valid_operands (enum rtx_code code, rtx *operands,\n \tcase MEM:\n \t  break;\n \t  \n-\t  /* After CSE, any remaining (ADDRESSOF:P reg) gets converted\n-\t     into a stack slot memory address comprising a PLUS and a\n-\t     constant.  */\n-\tcase ADDRESSOF:\n-\t  break;\n-\t  \n \tdefault:\n \t  abort ();\n \t  break;\n@@ -4863,8 +4851,6 @@ c4x_expand_builtin (tree exp, rtx target,\n       if (TARGET_C3X)\n \tbreak;\n       arg0 = TREE_VALUE (arglist);\n-      if (TREE_CODE (arg0) == VAR_DECL || TREE_CODE (arg0) == PARM_DECL)\n-\tput_var_into_stack (arg0, /*rescan=*/true);\n       r0 = expand_expr (arg0, NULL_RTX, QFmode, 0);\n       r0 = protect_from_queue (r0, 0);\n       if (register_operand (r0, QFmode))"}, {"sha": "99e8cb9c7e24bb2e86aa48b1c8ea73b927f644ed", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -4370,9 +4370,6 @@ move_destination_operand (rtx op, enum machine_mode mode)\n       return TRUE;\n \n     case MEM:\n-      if (GET_CODE (XEXP (op, 0)) == ADDRESSOF)\n-        return TRUE;\n-\n       return frv_legitimate_memory_operand (op, mode, FALSE);\n     }\n \n@@ -4463,9 +4460,6 @@ move_source_operand (rtx op, enum machine_mode mode)\n       return TRUE;\n \n     case MEM:\n-      if (GET_CODE (XEXP (op, 0)) == ADDRESSOF)\n-        return TRUE;\n-\n       return frv_legitimate_memory_operand (op, mode, FALSE);\n     }\n \n@@ -4505,9 +4499,6 @@ condexec_dest_operand (rtx op, enum machine_mode mode)\n       return TRUE;\n \n     case MEM:\n-      if (GET_CODE (XEXP (op, 0)) == ADDRESSOF)\n-        return TRUE;\n-\n       return frv_legitimate_memory_operand (op, mode, TRUE);\n     }\n \n@@ -4551,9 +4542,6 @@ condexec_source_operand (rtx op, enum machine_mode mode)\n       return TRUE;\n \n     case MEM:\n-      if (GET_CODE (XEXP (op, 0)) == ADDRESSOF)\n-        return TRUE;\n-\n       return frv_legitimate_memory_operand (op, mode, TRUE);\n     }\n \n@@ -5237,9 +5225,6 @@ condexec_memory_operand (rtx op, enum machine_mode mode)\n     return FALSE;\n \n   addr = XEXP (op, 0);\n-  if (GET_CODE (addr) == ADDRESSOF)\n-    return TRUE;\n-\n   return frv_legitimate_address_p (mode, addr, reload_completed, TRUE, FALSE);\n }\n "}, {"sha": "eeafd84a24e50e84925f71c5ad5c0f494e8433c9", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -1150,9 +1150,9 @@ struct cum_arg\n \n #define PREDICATE_CODES\t\t\t\t\t\t\t\\\n   {\"general_operand_src\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\\\n-\t\t\t   LABEL_REF, SUBREG, REG, MEM, ADDRESSOF}},\t\\\n+\t\t\t   LABEL_REF, SUBREG, REG, MEM}},\t\t\\\n   {\"general_operand_dst\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\\\n-\t\t\t   LABEL_REF, SUBREG, REG, MEM, ADDRESSOF}},\t\\\n+\t\t\t   LABEL_REF, SUBREG, REG, MEM}},\t\t\\\n   {\"single_one_operand\", {CONST_INT}},\t\t\t\t\t\\\n   {\"single_zero_operand\", {CONST_INT}},\t\t\t\t\t\\\n   {\"call_insn_operand\", {MEM}},\t\t\t\t\t\t\\"}, {"sha": "2c7e36d511e7e0882ba6ef47f7999e22bd6bc6a1", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -958,8 +958,6 @@ general_xfmode_operand (rtx op, enum machine_mode mode)\n {\n   if (! general_operand (op, mode))\n     return 0;\n-  if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == ADDRESSOF)\n-    return 0;\n   return 1;\n }\n \n@@ -970,8 +968,6 @@ destination_xfmode_operand (rtx op, enum machine_mode mode)\n {\n   if (! destination_operand (op, mode))\n     return 0;\n-  if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == ADDRESSOF)\n-    return 0;\n   return 1;\n }\n "}, {"sha": "ab008e494c7b56a492f5471f67b6058bd58b2432", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -2743,16 +2743,16 @@ typedef struct mips_args {\n    macro are thoses used in the most insn patterns.  */\n \n #define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-  {\"uns_arith_operand\",\t\t{ REG, CONST_INT, SUBREG, ADDRESSOF }},\t\\\n+  {\"uns_arith_operand\",\t\t{ REG, CONST_INT, SUBREG }},\t\t\\\n   {\"symbolic_operand\",\t\t{ CONST, SYMBOL_REF, LABEL_REF }},\t\\\n   {\"general_symbolic_operand\",\t{ CONST, SYMBOL_REF, LABEL_REF }},\t\\\n   {\"global_got_operand\",\t{ CONST, SYMBOL_REF, LABEL_REF }},\t\\\n   {\"local_got_operand\",\t\t{ CONST, SYMBOL_REF, LABEL_REF }},\t\\\n   {\"const_arith_operand\",\t{ CONST_INT }},\t\t\t\t\\\n   {\"small_data_pattern\",\t{ SET, PARALLEL, UNSPEC,\t\t\\\n \t\t\t\t  UNSPEC_VOLATILE }},\t\t\t\\\n-  {\"arith_operand\",\t\t{ REG, CONST_INT, CONST, SUBREG, ADDRESSOF }},\t\\\n-  {\"reg_or_0_operand\",\t\t{ REG, CONST_INT, CONST_DOUBLE, SUBREG, ADDRESSOF }}, \\\n+  {\"arith_operand\",\t\t{ REG, CONST_INT, CONST, SUBREG }},\t\\\n+  {\"reg_or_0_operand\",\t\t{ REG, CONST_INT, CONST_DOUBLE, SUBREG }}, \\\n   {\"small_int\",\t\t\t{ CONST_INT }},\t\t\t\t\\\n   {\"const_float_1_operand\",\t{ CONST_DOUBLE }},\t\t\t\\\n   {\"reg_or_const_float_1_operand\", { CONST_DOUBLE, REG}},               \\"}, {"sha": "da235e39a29400953295f9cae0f2c6278ec36877", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -1974,19 +1974,6 @@ mn10300_address_cost_1 (rtx x, int *unsig)\n     case LABEL_REF:\n       return 8;\n \n-    case ADDRESSOF:\n-      switch (GET_CODE (XEXP (x, 0)))\n-\t{\n-\tcase MEM:\n-\t  return mn10300_address_cost (XEXP (x, 0));\n-\n-\tcase REG:\n-\t  return 1;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-\n     default:\n       abort ();\n "}, {"sha": "470425bc72e90cd0022ed632eb6ab95f4d2f13ae", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -1181,8 +1181,6 @@ general_s_operand (register rtx op, enum machine_mode mode,\n       /* Memory operands are OK unless they already use an\n \t index register.  */\n       case MEM:\n-\tif (GET_CODE (XEXP (op, 0)) == ADDRESSOF)\n-\t  return 1;\n \tif (!s390_decompose_address (XEXP (op, 0), &addr))\n \t  return 0;\n \tif (addr.indx)"}, {"sha": "8e2c458e5df8304885f61528455ae2c1c06e0b79", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -1338,8 +1338,7 @@\n      always sign-extends (at least) to SImode.  */\n   if (optimize && !no_new_pseudos\n       && register_operand (operands[0], VOIDmode)\n-      && GET_CODE (operands[1]) == MEM\n-      && GET_CODE (XEXP (operands[1], 0)) != ADDRESSOF)\n+      && GET_CODE (operands[1]) == MEM)\n     {\n       rtx tmp = gen_reg_rtx (SImode);\n       rtx ext = gen_rtx_SIGN_EXTEND (SImode, operands[1]);\n@@ -1386,8 +1385,7 @@\n      is just as fast as a QImode load.  */\n   if (TARGET_ZARCH && optimize && !no_new_pseudos\n       && register_operand (operands[0], VOIDmode)\n-      && GET_CODE (operands[1]) == MEM\n-      && GET_CODE (XEXP (operands[1], 0)) != ADDRESSOF)\n+      && GET_CODE (operands[1]) == MEM)\n     {\n       rtx tmp = gen_reg_rtx (word_mode);\n       rtx ext = gen_rtx_ZERO_EXTEND (word_mode, operands[1]);"}, {"sha": "595a0f5fa88b1a44d3f568ca7471b667f8bb567e", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -2578,7 +2578,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n {\"icc_or_fcc_reg_operand\", {REG}},\t\t\t\t\t\\\n {\"call_operand\", {MEM}},\t\t\t\t\t\t\\\n {\"call_operand_address\", {SYMBOL_REF, LABEL_REF, CONST, CONST_DOUBLE,\t\\\n-\tADDRESSOF, SUBREG, REG, PLUS, LO_SUM, CONST_INT}},\t\t\\\n+\tSUBREG, REG, PLUS, LO_SUM, CONST_INT}},\t\t\t\t\\\n {\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST}},\t\t\t\\\n {\"symbolic_memory_operand\", {SUBREG, MEM}},\t\t\t\t\\\n {\"label_ref_operand\", {LABEL_REF}},\t\t\t\t\t\\"}, {"sha": "4703ed85be26e641c7a0226bdcea53cb2db1a37b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -1,10 +1,14 @@\n-2004-07-03  Scott Brumbaugh  <scottb.lists@verizon.net>\r\n-\r\n-\tPR c++/3761\r\n-\t* name-lookup.c (push_class_level_binding): Don't pass a\r\n-\tTREE_LIST of ambiguous names to check_template_shadow as it\r\n-\tonly handles declarations. Instead, pull the declaration \r\n-\tout and pass that.\r\n+2004-07-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* typeck.c (cxx_mark_addressable): Don't put_var_into_stack.\n+\n+2004-07-03  Scott Brumbaugh  <scottb.lists@verizon.net>\n+\n+\tPR c++/3761\n+\t* name-lookup.c (push_class_level_binding): Don't pass a\n+\tTREE_LIST of ambiguous names to check_template_shadow as it\n+\tonly handles declarations. Instead, pull the declaration\n+\tout and pass that.\n \n 2004-07-03  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n "}, {"sha": "4f473508c389b6497122f749265517dca9754201", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -4295,7 +4295,6 @@ cxx_mark_addressable (tree exp)\n \t  warning (\"address requested for `%D', which is declared `register'\",\n \t\t      x);\n \tTREE_ADDRESSABLE (x) = 1;\n-\tput_var_into_stack (x, /*rescan=*/true);\n \treturn true;\n \n       case FUNCTION_DECL:"}, {"sha": "ef99bc6cb78254de682d65a1e283782c9dd6886a", "filename": "gcc/cse.c", "status": "modified", "additions": 3, "deletions": 28, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -695,9 +695,6 @@ fixed_base_plus_p (rtx x)\n \treturn false;\n       return fixed_base_plus_p (XEXP (x, 0));\n \n-    case ADDRESSOF:\n-      return true;\n-\n     default:\n       return false;\n     }\n@@ -2769,7 +2766,6 @@ find_best_addr (rtx insn, rtx *loc, enum machine_mode mode)\n \t  && (regno = REGNO (addr), regno == FRAME_POINTER_REGNUM\n \t      || regno == HARD_FRAME_POINTER_REGNUM\n \t      || regno == ARG_POINTER_REGNUM))\n-      || GET_CODE (addr) == ADDRESSOF\n       || CONSTANT_ADDRESS_P (addr))\n     return;\n \n@@ -3188,10 +3184,6 @@ fold_rtx (rtx x, rtx insn)\n \t since they are used only for lists of args\n \t in a function call's REG_EQUAL note.  */\n     case EXPR_LIST:\n-      /* Changing anything inside an ADDRESSOF is incorrect; we don't\n-\t want to (e.g.,) make (addressof (const_int 0)) just because\n-\t the location is known to be zero.  */\n-    case ADDRESSOF:\n       return x;\n \n #ifdef HAVE_cc0\n@@ -3444,8 +3436,6 @@ fold_rtx (rtx x, rtx insn)\n \telse if (GET_CODE (addr) == LO_SUM\n \t\t && GET_CODE (XEXP (addr, 1)) == SYMBOL_REF)\n \t  base = XEXP (addr, 1);\n-\telse if (GET_CODE (addr) == ADDRESSOF)\n-\t  return change_address (x, VOIDmode, addr);\n \n \t/* If this is a constant pool reference, we can fold it into its\n \t   constant to allow better value tracking.  */\n@@ -5924,7 +5914,6 @@ cse_insn (rtx insn, rtx libcall_insn)\n     if (sets[i].rtl)\n       {\n \trtx dest = SET_DEST (sets[i].rtl);\n-\trtx inner_dest = sets[i].inner_dest;\n \tstruct table_elt *elt;\n \n \t/* Don't record value if we are not supposed to risk allocating\n@@ -5973,17 +5962,8 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t      sets[i].dest_hash = HASH (dest, GET_MODE (dest));\n \t    }\n \n-\tif (MEM_P (inner_dest)\n-\t    && GET_CODE (XEXP (inner_dest, 0)) == ADDRESSOF)\n-\t  /* Given (SET (MEM (ADDRESSOF (X))) Y) we don't want to say\n-\t     that (MEM (ADDRESSOF (X))) is equivalent to Y.\n-\t     Consider the case in which the address of the MEM is\n-\t     passed to a function, which alters the MEM.  Then, if we\n-\t     later use Y instead of the MEM we'll miss the update.  */\n-\t  elt = insert (dest, 0, sets[i].dest_hash, GET_MODE (dest));\n-\telse\n-\t  elt = insert (dest, sets[i].src_elt,\n-\t\t\tsets[i].dest_hash, GET_MODE (dest));\n+\telt = insert (dest, sets[i].src_elt,\n+\t\t      sets[i].dest_hash, GET_MODE (dest));\n \n \telt->in_memory = (MEM_P (sets[i].inner_dest)\n \t\t\t  && (! RTX_UNCHANGING_P (sets[i].inner_dest)\n@@ -7402,12 +7382,7 @@ set_live_p (rtx set, rtx insn ATTRIBUTE_UNUSED, /* Only used with HAVE_cc0.  */\n   else if (!REG_P (SET_DEST (set))\n \t   || REGNO (SET_DEST (set)) < FIRST_PSEUDO_REGISTER\n \t   || counts[REGNO (SET_DEST (set))] != 0\n-\t   || side_effects_p (SET_SRC (set))\n-\t   /* An ADDRESSOF expression can turn into a use of the\n-\t      internal arg pointer, so always consider the\n-\t      internal arg pointer live.  If it is truly dead,\n-\t      flow will delete the initializing insn.  */\n-\t   || (SET_DEST (set) == current_function_internal_arg_pointer))\n+\t   || side_effects_p (SET_SRC (set)))\n     return true;\n   return false;\n }"}, {"sha": "625a6789672e25d8dd7b69dcff4aa959f818a655", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -3315,9 +3315,6 @@ Dump after the third if conversion, to @file{@var{file}.31.ce3}.\n @opindex df\n Dump after control and data flow analysis, to @file{@var{file}.11.cfg}.\n Also dump after life analysis, to @file{@var{file}.19.life}.\n-@item F\n-@opindex dF\n-Dump after purging @code{ADDRESSOF} codes, to @file{@var{file}.07.addressof}.\n @item g\n @opindex dg\n Dump after global register allocation, to @file{@var{file}.26.greg}."}, {"sha": "282ccab41d1b4be826169561c43c166237c94818", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -8736,15 +8736,6 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode, bool can_use_fbreg)\n       mem_loc_result = int_loc_descriptor (INTVAL (rtl));\n       break;\n \n-    case ADDRESSOF:\n-      /* If this is a MEM, return its address.  Otherwise, we can't\n-\t represent this.  */\n-      if (MEM_P (XEXP (rtl, 0)))\n-\treturn mem_loc_descriptor (XEXP (XEXP (rtl, 0), 0), mode,\n-\t\t\t\t   can_use_fbreg);\n-      else\n-\treturn 0;\n-\n     default:\n       abort ();\n     }\n@@ -10093,11 +10084,6 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \n   switch (GET_CODE (rtl))\n     {\n-    case ADDRESSOF:\n-      /* The address of a variable that was optimized away;\n-\t don't emit anything.  */\n-      break;\n-\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case CONST_VECTOR:"}, {"sha": "45abfe320bee1923ddb85ff966882c600f66806c", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -5013,7 +5013,6 @@ copy_insn_1 (rtx orig)\n     case CODE_LABEL:\n     case PC:\n     case CC0:\n-    case ADDRESSOF:\n       return orig;\n     case CLOBBER:\n       if (REG_P (XEXP (orig, 0)) && REGNO (XEXP (orig, 0)) < FIRST_PSEUDO_REGISTER)"}, {"sha": "2223ca6e2bc2b4a9de1bbee4fbdbbf3a8ded43f5", "filename": "gcc/explow.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -436,9 +436,6 @@ memory_address (enum machine_mode mode, rtx x)\n {\n   rtx oldx = x;\n \n-  if (GET_CODE (x) == ADDRESSOF)\n-    return x;\n-\n   x = convert_memory_address (Pmode, x);\n \n   /* By passing constant addresses through registers"}, {"sha": "6ee291370d0b81dd88094a1e281a7cdae0e43479", "filename": "gcc/expmed.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -945,8 +945,6 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t\t\t\t       ? GET_MODE (value)\n \t\t\t\t\t       : word_mode, value));\n     }\n-  else if (GET_CODE (value) == ADDRESSOF)\n-    value = copy_to_reg (value);\n \n   while (bitsdone < bitsize)\n     {"}, {"sha": "b44309ded60acb267f6d0b6fdb2216be3571ef41", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -8740,8 +8740,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      {\n \t\ttarget = assign_temp (type, 2, 0, 1);\n \t\tSET_DECL_RTL (slot, target);\n-\t\tif (TREE_ADDRESSABLE (slot))\n-\t\t  put_var_into_stack (slot, /*rescan=*/false);\n \n \t\t/* Since SLOT is not known to the called function\n \t\t   to belong to its stack frame, we must build an explicit\n@@ -8775,13 +8773,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t  return target;\n \t      }\n \t    else\n-\t      {\n-\t\tSET_DECL_RTL (slot, target);\n-\t\t/* If we must have an addressable slot, then make sure that\n-\t\t   the RTL that we just stored in slot is OK.  */\n-\t\tif (TREE_ADDRESSABLE (slot))\n-\t\t  put_var_into_stack (slot, /*rescan=*/true);\n-\t      }\n+\t      SET_DECL_RTL (slot, target);\n \t  }\n \n \texp1 = TREE_OPERAND (exp, 3) = TREE_OPERAND (exp, 1);\n@@ -8919,8 +8911,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    op0 = force_const_mem (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))),\n \t\t\t\t   op0);\n \t  else if (REG_P (op0) || GET_CODE (op0) == SUBREG\n-\t\t   || GET_CODE (op0) == CONCAT || GET_CODE (op0) == ADDRESSOF\n-\t\t   || GET_CODE (op0) == PARALLEL || GET_CODE (op0) == LO_SUM)\n+\t\t   || GET_CODE (op0) == CONCAT || GET_CODE (op0) == PARALLEL\n+\t\t   || GET_CODE (op0) == LO_SUM)\n \t    {\n \t      /* If this object is in a register, it can't be BLKmode.  */\n \t      tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));"}, {"sha": "0b4026aa4ecf8ea017172d8bb8bd7c3a8dc7e848", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -1,3 +1,7 @@\n+2004-07-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* f95-lang.c (gfc_mark_addressable): Don't put_var_into_stack.\n+\n 2004-07-04  Paul Brook  <paul@codesourcery.com>\n \n \t* decl.c (gfc_match_implicit_range): Don't use typespec."}, {"sha": "43eb87d1be323f05e591af7aa61f76eaf0d806ef", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -668,7 +668,6 @@ gfc_mark_addressable (tree exp)\n \t    pedwarn (\"address of register variable `%s' requested\",\n \t\t     IDENTIFIER_POINTER (DECL_NAME (x)));\n \t  }\n-\tput_var_into_stack (x, /*rescan=*/true);\n \n \t/* drops in */\n       case FUNCTION_DECL:"}, {"sha": "0bab2b6c44d74b893ba0ed338af103d75d6625f1", "filename": "gcc/function.c", "status": "modified", "additions": 200, "deletions": 2518, "changes": 2718, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -31,12 +31,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    Call `assign_stack_local' to allocate a stack slot for a local variable.\n    This is usually done during the RTL generation for the function body,\n    but it can also be done in the reload pass when a pseudo-register does\n-   not get a hard register.\n-\n-   Call `put_var_into_stack' when you learn, belatedly, that a variable\n-   previously given a pseudo-register must in fact go in the stack.\n-   This function changes the DECL_RTL to be a stack slot instead of a reg\n-   then scans all the RTL instructions so far generated to correct them.  */\n+   not get a hard register.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -202,47 +197,11 @@ struct temp_slot GTY(())\n   HOST_WIDE_INT full_size;\n };\n \f\n-/* This structure is used to record MEMs or pseudos used to replace VAR, any\n-   SUBREGs of VAR, and any MEMs containing VAR as an address.  We need to\n-   maintain this list in case two operands of an insn were required to match;\n-   in that case we must ensure we use the same replacement.  */\n-\n-struct fixup_replacement GTY(())\n-{\n-  rtx old;\n-  rtx new;\n-  struct fixup_replacement *next;\n-};\n-\n-struct insns_for_mem_entry\n-{\n-  /* A MEM.  */\n-  rtx key;\n-  /* These are the INSNs which reference the MEM.  */\n-  rtx insns;\n-};\n-\n /* Forward declarations.  */\n \n static rtx assign_stack_local_1 (enum machine_mode, HOST_WIDE_INT, int,\n \t\t\t\t struct function *);\n static struct temp_slot *find_temp_slot_from_address (rtx);\n-static void put_reg_into_stack (struct function *, rtx, tree, enum machine_mode,\n-\t\t\t\tunsigned int, bool, bool, bool, htab_t);\n-static void schedule_fixup_var_refs (struct function *, rtx, tree, enum machine_mode,\n-\t\t\t\t     htab_t);\n-static void fixup_var_refs (rtx, enum machine_mode, int, rtx, htab_t);\n-static struct fixup_replacement\n-  *find_fixup_replacement (struct fixup_replacement **, rtx);\n-static void fixup_var_refs_insns (rtx, rtx, enum machine_mode, int, int, rtx);\n-static void fixup_var_refs_insns_with_hash (htab_t, rtx, enum machine_mode, int, rtx);\n-static void fixup_var_refs_insn (rtx, rtx, enum machine_mode, int, int, rtx);\n-static void fixup_var_refs_1 (rtx, enum machine_mode, rtx *, rtx,\n-\t\t\t      struct fixup_replacement **, rtx);\n-static rtx fixup_memory_subreg (rtx, rtx, enum machine_mode, int);\n-static rtx walk_fixup_memory_subreg (rtx, rtx, rtx, enum machine_mode, int);\n-static rtx fixup_stack_1 (rtx, rtx);\n-static void optimize_bit_field (rtx, rtx, rtx *);\n static void instantiate_decls (tree, int);\n static void instantiate_decls_1 (tree, int);\n static void instantiate_decl (rtx, HOST_WIDE_INT, int);\n@@ -262,17 +221,10 @@ static int contains (rtx, varray_type);\n #ifdef HAVE_return\n static void emit_return_into_block (basic_block, rtx);\n #endif\n-static void put_addressof_into_stack (rtx, htab_t);\n-static bool purge_addressof_1 (rtx *, rtx, int, int, int, htab_t);\n static void purge_single_hard_subreg_set (rtx);\n #if defined(HAVE_epilogue) && defined(INCOMING_RETURN_ADDR_RTX)\n static rtx keep_stack_depressed (rtx);\n #endif\n-static int is_addressof (rtx *, void *);\n-static hashval_t insns_for_mem_hash (const void *);\n-static int insns_for_mem_comp (const void *, const void *);\n-static int insns_for_mem_walk (rtx *, void *);\n-static void compute_insns_for_mem (rtx, rtx, htab_t);\n static void prepare_function_start (tree);\n static void do_clobber_return_reg (rtx, void *);\n static void do_use_return_reg (rtx, void *);\n@@ -283,9 +235,6 @@ static void set_insn_locators (rtx, int) ATTRIBUTE_UNUSED;\n /* Pointer to chain of `struct function' for containing functions.  */\n struct function *outer_function_chain;\n \n-/* List of insns that were postponed by purge_addressof_1.  */\n-static rtx postponed_insns;\n-\n /* Given a function decl for a containing function,\n    return the `struct function' for it.  */\n \n@@ -329,7 +278,6 @@ push_function_context_to (tree context)\n \n   p->outer = outer_function_chain;\n   outer_function_chain = p;\n-  p->fixup_var_refs_queue = 0;\n \n   lang_hooks.function.enter_nested (p);\n \n@@ -349,7 +297,6 @@ void\n pop_function_context_from (tree context ATTRIBUTE_UNUSED)\n {\n   struct function *p = outer_function_chain;\n-  struct var_refs_queue *queue;\n \n   cfun = p;\n   outer_function_chain = p->outer;\n@@ -361,32 +308,6 @@ pop_function_context_from (tree context ATTRIBUTE_UNUSED)\n \n   lang_hooks.function.leave_nested (p);\n \n-  /* Finish doing put_var_into_stack for any of our variables which became\n-     addressable during the nested function.  If only one entry has to be\n-     fixed up, just do that one.  Otherwise, first make a list of MEMs that\n-     are not to be unshared.  */\n-  if (p->fixup_var_refs_queue == 0)\n-    ;\n-  else if (p->fixup_var_refs_queue->next == 0)\n-    fixup_var_refs (p->fixup_var_refs_queue->modified,\n-\t\t    p->fixup_var_refs_queue->promoted_mode,\n-\t\t    p->fixup_var_refs_queue->unsignedp,\n-\t\t    p->fixup_var_refs_queue->modified, 0);\n-  else\n-    {\n-      rtx list = 0;\n-\n-      for (queue = p->fixup_var_refs_queue; queue; queue = queue->next)\n-\tlist = gen_rtx_EXPR_LIST (VOIDmode, queue->modified, list);\n-\n-      for (queue = p->fixup_var_refs_queue; queue; queue = queue->next)\n-\tfixup_var_refs (queue->modified, queue->promoted_mode,\n-\t\t\tqueue->unsignedp, list, 0);\n-\n-    }\n-\n-  p->fixup_var_refs_queue = 0;\n-\n   /* Reset variables that have known state during rtx generation.  */\n   rtx_equal_function_value_matters = 1;\n   virtuals_instantiated = 0;\n@@ -440,8 +361,6 @@ free_after_compilation (struct function *f)\n   f->x_tail_recursion_reentry = NULL;\n   f->x_arg_pointer_save_area = NULL;\n   f->x_parm_birth_insn = NULL;\n-  f->x_parm_reg_stack_loc = NULL;\n-  f->fixup_var_refs_queue = NULL;\n   f->original_arg_vector = NULL;\n   f->original_decl_initial = NULL;\n   f->epilogue_delay_list = NULL;\n@@ -1170,2269 +1089,180 @@ preserve_temp_slots (rtx x)\n \t    move_slot_to_level (p, temp_slot_level - 1);\n \t}\n \n-      return;\n-    }\n-\n-  /* If X is a register that is being used as a pointer, see if we have\n-     a temporary slot we know it points to.  To be consistent with\n-     the code below, we really should preserve all non-kept slots\n-     if we can't find a match, but that seems to be much too costly.  */\n-  if (REG_P (x) && REG_POINTER (x))\n-    p = find_temp_slot_from_address (x);\n-\n-  /* If X is not in memory or is at a constant address, it cannot be in\n-     a temporary slot, but it can contain something whose address was\n-     taken.  */\n-  if (p == 0 && (!MEM_P (x) || CONSTANT_P (XEXP (x, 0))))\n-    {\n-      for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n-\t{\n-\t  next = p->next;\n-\n-\t  if (p->addr_taken)\n-\t    move_slot_to_level (p, temp_slot_level - 1);\n-\t}\n-\n-      return;\n-    }\n-\n-  /* First see if we can find a match.  */\n-  if (p == 0)\n-    p = find_temp_slot_from_address (XEXP (x, 0));\n-\n-  if (p != 0)\n-    {\n-      /* Move everything at our level whose address was taken to our new\n-\t level in case we used its address.  */\n-      struct temp_slot *q;\n-\n-      if (p->level == temp_slot_level)\n-\t{\n-\t  for (q = *temp_slots_at_level (temp_slot_level); q; q = next)\n-\t    {\n-\t      next = q->next;\n-\n-\t      if (p != q && q->addr_taken)\n-\t\tmove_slot_to_level (q, temp_slot_level - 1);\n-\t    }\n-\n-\t  move_slot_to_level (p, temp_slot_level - 1);\n-\t  p->addr_taken = 0;\n-\t}\n-      return;\n-    }\n-\n-  /* Otherwise, preserve all non-kept slots at this level.  */\n-  for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n-    {\n-      next = p->next;\n-\n-      if (!p->keep)\n-\tmove_slot_to_level (p, temp_slot_level - 1);\n-    }\n-}\n-\n-/* Free all temporaries used so far.  This is normally called at the\n-   end of generating code for a statement.  */\n-\n-void\n-free_temp_slots (void)\n-{\n-  struct temp_slot *p, *next;\n-\n-  for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n-    {\n-      next = p->next;\n-\n-      if (!p->keep)\n-\tmake_slot_available (p);\n-    }\n-\n-  combine_temp_slots ();\n-}\n-\n-/* Push deeper into the nesting level for stack temporaries.  */\n-\n-void\n-push_temp_slots (void)\n-{\n-  temp_slot_level++;\n-}\n-\n-/* Pop a temporary nesting level.  All slots in use in the current level\n-   are freed.  */\n-\n-void\n-pop_temp_slots (void)\n-{\n-  struct temp_slot *p, *next;\n-\n-  for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n-    {\n-      next = p->next;\n-      make_slot_available (p);\n-    }\n-\n-  combine_temp_slots ();\n-\n-  temp_slot_level--;\n-}\n-\n-/* Initialize temporary slots.  */\n-\n-void\n-init_temp_slots (void)\n-{\n-  /* We have not allocated any temporaries yet.  */\n-  avail_temp_slots = 0;\n-  used_temp_slots = 0;\n-  temp_slot_level = 0;\n-  var_temp_slot_level = 0;\n-  target_temp_slot_level = 0;\n-}\n-\f\n-/* Retroactively move an auto variable from a register to a stack\n-   slot.  This is done when an address-reference to the variable is\n-   seen.  If RESCAN is true, all previously emitted instructions are\n-   examined and modified to handle the fact that DECL is now\n-   addressable.  */\n-\n-void\n-put_var_into_stack (tree decl, int rescan)\n-{\n-  rtx orig_reg, reg;\n-  enum machine_mode promoted_mode, decl_mode;\n-  struct function *function = 0;\n-  tree context;\n-  bool can_use_addressof_p;\n-  bool volatile_p = TREE_CODE (decl) != SAVE_EXPR && TREE_THIS_VOLATILE (decl);\n-  bool used_p = (TREE_USED (decl)\n-\t       || (TREE_CODE (decl) != SAVE_EXPR && DECL_INITIAL (decl) != 0));\n-\n-  context = decl_function_context (decl);\n-\n-  /* Get the current rtl used for this object and its original mode.  */\n-  orig_reg = reg = DECL_RTL_IF_SET (decl);\n-\n-  /* No need to do anything if decl has no rtx yet\n-     since in that case caller is setting TREE_ADDRESSABLE\n-     and a stack slot will be assigned when the rtl is made.  */\n-  if (reg == 0)\n-    return;\n-\n-  /* Get the declared mode for this object.  */\n-  decl_mode = (TREE_CODE (decl) == SAVE_EXPR ? TYPE_MODE (TREE_TYPE (decl))\n-\t       : DECL_MODE (decl));\n-  /* Get the mode it's actually stored in.  */\n-  promoted_mode = GET_MODE (reg);\n-\n-  /* If this variable comes from an outer function, find that\n-     function's saved context.  Don't use find_function_data here,\n-     because it might not be in any active function.\n-     FIXME: Is that really supposed to happen?\n-     It does in ObjC at least.  */\n-  if (context != current_function_decl)\n-    for (function = outer_function_chain; function; function = function->outer)\n-      if (function->decl == context)\n-\tbreak;\n-\n-  /* If this is a variable-sized object or a structure passed by invisible\n-     reference, with a pseudo to address it, put that pseudo into the stack\n-     if the var is non-local.  */\n-  if (TREE_CODE (decl) != SAVE_EXPR && DECL_NONLOCAL (decl)\n-      && MEM_P (reg)\n-      && REG_P (XEXP (reg, 0))\n-      && REGNO (XEXP (reg, 0)) > LAST_VIRTUAL_REGISTER)\n-    {\n-      orig_reg = reg = XEXP (reg, 0);\n-      decl_mode = promoted_mode = GET_MODE (reg);\n-    }\n-\n-  /* If this variable lives in the current function and we don't need to put it\n-     in the stack for the sake of setjmp or the non-locality, try to keep it in\n-     a register until we know we actually need the address.  */\n-  can_use_addressof_p\n-    = (function == 0\n-       && ! (TREE_CODE (decl) != SAVE_EXPR && DECL_NONLOCAL (decl))\n-       && optimize > 0\n-       /* FIXME make it work for promoted modes too */\n-       && decl_mode == promoted_mode\n-#ifdef NON_SAVING_SETJMP\n-       && ! (NON_SAVING_SETJMP && current_function_calls_setjmp)\n-#endif\n-       );\n-\n-  /* If we can't use ADDRESSOF, make sure we see through one we already\n-     generated.  */\n-  if (! can_use_addressof_p\n-      && MEM_P (reg)\n-      && GET_CODE (XEXP (reg, 0)) == ADDRESSOF)\n-    reg = XEXP (XEXP (reg, 0), 0);\n-\n-  /* Now we should have a value that resides in one or more pseudo regs.  */\n-\n-  if (REG_P (reg))\n-    {\n-      if (can_use_addressof_p)\n-\tgen_mem_addressof (reg, decl, rescan);\n-      else\n-\tput_reg_into_stack (function, reg, TREE_TYPE (decl), decl_mode,\n-\t\t\t    0, volatile_p, used_p, false, 0);\n-\n-\t  /* If this was previously a MEM but we've removed the ADDRESSOF,\n-\t     set this address into that MEM so we always use the same\n-\t     rtx for this variable.  */\n-\t  if (orig_reg != reg && MEM_P (orig_reg))\n-\t    XEXP (orig_reg, 0) = XEXP (reg, 0);\n-    }\n-  else if (GET_CODE (reg) == CONCAT)\n-    {\n-      /* A CONCAT contains two pseudos; put them both in the stack.\n-\t We do it so they end up consecutive.\n-\t We fixup references to the parts only after we fixup references\n-\t to the whole CONCAT, lest we do double fixups for the latter\n-\t references.  */\n-      enum machine_mode part_mode = GET_MODE (XEXP (reg, 0));\n-      tree part_type = lang_hooks.types.type_for_mode (part_mode, 0);\n-      rtx lopart = XEXP (reg, 0);\n-      rtx hipart = XEXP (reg, 1);\n-#ifdef FRAME_GROWS_DOWNWARD\n-      /* Since part 0 should have a lower address, do it second.  */\n-      put_reg_into_stack (function, hipart, part_type, part_mode,\n-\t\t\t  0, volatile_p, false, false, 0);\n-      put_reg_into_stack (function, lopart, part_type, part_mode,\n-\t\t\t  0, volatile_p, false, true, 0);\n-#else\n-      put_reg_into_stack (function, lopart, part_type, part_mode,\n-\t\t\t  0, volatile_p, false, false, 0);\n-      put_reg_into_stack (function, hipart, part_type, part_mode,\n-\t\t\t  0, volatile_p, false, true, 0);\n-#endif\n-\n-      /* Change the CONCAT into a combined MEM for both parts.  */\n-      PUT_CODE (reg, MEM);\n-      MEM_ATTRS (reg) = 0;\n-\n-      /* set_mem_attributes uses DECL_RTL to avoid re-generating of\n-         already computed alias sets.  Here we want to re-generate.  */\n-      if (DECL_P (decl))\n-\tSET_DECL_RTL (decl, NULL);\n-      set_mem_attributes (reg, decl, 1);\n-      if (DECL_P (decl))\n-\tSET_DECL_RTL (decl, reg);\n-\n-      /* The two parts are in memory order already.\n-\t Use the lower parts address as ours.  */\n-      XEXP (reg, 0) = XEXP (XEXP (reg, 0), 0);\n-      /* Prevent sharing of rtl that might lose.  */\n-      if (GET_CODE (XEXP (reg, 0)) == PLUS)\n-\tXEXP (reg, 0) = copy_rtx (XEXP (reg, 0));\n-      if (used_p && rescan)\n-\t{\n-\t  schedule_fixup_var_refs (function, reg, TREE_TYPE (decl),\n-\t\t\t\t   promoted_mode, 0);\n-\t  schedule_fixup_var_refs (function, lopart, part_type, part_mode, 0);\n-\t  schedule_fixup_var_refs (function, hipart, part_type, part_mode, 0);\n-\t}\n-    }\n-  else\n-    return;\n-}\n-\n-/* Subroutine of put_var_into_stack.  This puts a single pseudo reg REG\n-   into the stack frame of FUNCTION (0 means the current function).\n-   TYPE is the user-level data type of the value hold in the register.\n-   DECL_MODE is the machine mode of the user-level data type.\n-   ORIGINAL_REGNO must be set if the real regno is not visible in REG.\n-   VOLATILE_P is true if this is for a \"volatile\" decl.\n-   USED_P is true if this reg might have already been used in an insn.\n-   CONSECUTIVE_P is true if the stack slot assigned to reg must be\n-   consecutive with the previous stack slot.  */\n-\n-static void\n-put_reg_into_stack (struct function *function, rtx reg, tree type,\n-\t\t    enum machine_mode decl_mode, unsigned int original_regno,\n-\t\t    bool volatile_p, bool used_p, bool consecutive_p,\n-\t\t    htab_t ht)\n-{\n-  struct function *func = function ? function : cfun;\n-  enum machine_mode mode = GET_MODE (reg);\n-  unsigned int regno = original_regno;\n-  rtx new = 0;\n-\n-  if (regno == 0)\n-    regno = REGNO (reg);\n-\n-  if (regno < func->x_max_parm_reg)\n-    {\n-      if (!func->x_parm_reg_stack_loc)\n-\tabort ();\n-      new = func->x_parm_reg_stack_loc[regno];\n-    }\n-\n-  if (new == 0)\n-    new = assign_stack_local_1 (decl_mode, GET_MODE_SIZE (decl_mode),\n-\t\t\t\tconsecutive_p ? -2 : 0, func);\n-\n-  PUT_CODE (reg, MEM);\n-  PUT_MODE (reg, decl_mode);\n-  XEXP (reg, 0) = XEXP (new, 0);\n-  MEM_ATTRS (reg) = 0;\n-  /* `volatil' bit means one thing for MEMs, another entirely for REGs.  */\n-  MEM_VOLATILE_P (reg) = volatile_p;\n-\n-  /* If this is a memory ref that contains aggregate components,\n-     mark it as such for cse and loop optimize.  If we are reusing a\n-     previously generated stack slot, then we need to copy the bit in\n-     case it was set for other reasons.  For instance, it is set for\n-     __builtin_va_alist.  */\n-  if (type)\n-    {\n-      MEM_SET_IN_STRUCT_P (reg,\n-\t\t\t   AGGREGATE_TYPE_P (type) || MEM_IN_STRUCT_P (new));\n-      set_mem_alias_set (reg, get_alias_set (type));\n-    }\n-\n-  if (used_p)\n-    schedule_fixup_var_refs (function, reg, type, mode, ht);\n-}\n-\n-/* Make sure that all refs to the variable, previously made\n-   when it was a register, are fixed up to be valid again.\n-   See function above for meaning of arguments.  */\n-\n-static void\n-schedule_fixup_var_refs (struct function *function, rtx reg, tree type,\n-\t\t\t enum machine_mode promoted_mode, htab_t ht)\n-{\n-  int unsigned_p = type ? TYPE_UNSIGNED (type) : 0;\n-\n-  if (function != 0)\n-    {\n-      struct var_refs_queue *temp;\n-\n-      temp = ggc_alloc (sizeof (struct var_refs_queue));\n-      temp->modified = reg;\n-      temp->promoted_mode = promoted_mode;\n-      temp->unsignedp = unsigned_p;\n-      temp->next = function->fixup_var_refs_queue;\n-      function->fixup_var_refs_queue = temp;\n-    }\n-  else\n-    /* Variable is local; fix it up now.  */\n-    fixup_var_refs (reg, promoted_mode, unsigned_p, reg, ht);\n-}\n-\f\n-static void\n-fixup_var_refs (rtx var, enum machine_mode promoted_mode, int unsignedp,\n-\t\trtx may_share, htab_t ht)\n-{\n-  rtx first_insn = get_insns ();\n-  struct sequence_stack *stack = seq_stack;\n-  int save_volatile_ok = volatile_ok;\n-\n-  /* If there's a hash table, it must record all uses of VAR.  */\n-  if (ht)\n-    {\n-      if (stack != 0)\n-\tabort ();\n-      fixup_var_refs_insns_with_hash (ht, var, promoted_mode, unsignedp,\n-\t\t\t\t      may_share);\n-      return;\n-    }\n-\n-  /* Volatile is valid in MEMs because all we're doing in changing the\n-     address inside.  */\n-  volatile_ok = 1;\n-  fixup_var_refs_insns (first_insn, var, promoted_mode, unsignedp,\n-\t\t\tstack == 0, may_share);\n-\n-  /* Scan all pending sequences too.  */\n-  for (; stack; stack = stack->next)\n-    {\n-      push_to_full_sequence (stack->first, stack->last);\n-      fixup_var_refs_insns (stack->first, var, promoted_mode, unsignedp,\n-\t\t\t    stack->next != 0, may_share);\n-      /* Update bounds of sequence in case we added insns.  */\n-      stack->first = get_insns ();\n-      stack->last = get_last_insn ();\n-      end_sequence ();\n-    }\n-\n-  volatile_ok = save_volatile_ok;\n-}\n-\f\n-/* REPLACEMENTS is a pointer to a list of the struct fixup_replacement and X is\n-   some part of an insn.  Return a struct fixup_replacement whose OLD\n-   value is equal to X.  Allocate a new structure if no such entry exists.  */\n-\n-static struct fixup_replacement *\n-find_fixup_replacement (struct fixup_replacement **replacements, rtx x)\n-{\n-  struct fixup_replacement *p;\n-\n-  /* See if we have already replaced this.  */\n-  for (p = *replacements; p != 0 && ! rtx_equal_p (p->old, x); p = p->next)\n-    ;\n-\n-  if (p == 0)\n-    {\n-      p = xmalloc (sizeof (struct fixup_replacement));\n-      p->old = x;\n-      p->new = 0;\n-      p->next = *replacements;\n-      *replacements = p;\n-    }\n-\n-  return p;\n-}\n-\n-/* Scan the insn-chain starting with INSN for refs to VAR and fix them\n-   up.  TOPLEVEL is nonzero if this chain is the main chain of insns\n-   for the current function.  MAY_SHARE is either a MEM that is not\n-   to be unshared or a list of them.  */\n-\n-static void\n-fixup_var_refs_insns (rtx insn, rtx var, enum machine_mode promoted_mode,\n-\t\t      int unsignedp, int toplevel, rtx may_share)\n-{\n-  while (insn)\n-    {\n-      /* fixup_var_refs_insn might modify insn, so save its next\n-         pointer now.  */\n-      rtx next = NEXT_INSN (insn);\n-\n-      if (INSN_P (insn))\n-\tfixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel,\n-\t\t\t     may_share);\n-\n-      insn = next;\n-    }\n-}\n-\n-/* Look up the insns which reference VAR in HT and fix them up.  Other\n-   arguments are the same as fixup_var_refs_insns.  */\n-\n-static void\n-fixup_var_refs_insns_with_hash (htab_t ht, rtx var, enum machine_mode promoted_mode,\n-\t\t\t\tint unsignedp, rtx may_share)\n-{\n-  struct insns_for_mem_entry tmp;\n-  struct insns_for_mem_entry *ime;\n-  rtx insn_list;\n-\n-  tmp.key = var;\n-  ime = htab_find (ht, &tmp);\n-  for (insn_list = ime->insns; insn_list != 0; insn_list = XEXP (insn_list, 1))\n-    if (INSN_P (XEXP (insn_list, 0)))\n-      fixup_var_refs_insn (XEXP (insn_list, 0), var, promoted_mode,\n-\t\t\t   unsignedp, 1, may_share);\n-}\n-\n-\n-/* Per-insn processing by fixup_var_refs_insns(_with_hash).  INSN is\n-   the insn under examination, VAR is the variable to fix up\n-   references to, PROMOTED_MODE and UNSIGNEDP describe VAR, and\n-   TOPLEVEL is nonzero if this is the main insn chain for this\n-   function.  */\n-\n-static void\n-fixup_var_refs_insn (rtx insn, rtx var, enum machine_mode promoted_mode,\n-\t\t     int unsignedp, int toplevel, rtx no_share)\n-{\n-  rtx call_dest = 0;\n-  rtx set, prev, prev_set;\n-  rtx note;\n-\n-  /* Remember the notes in case we delete the insn.  */\n-  note = REG_NOTES (insn);\n-\n-  /* If this is a CLOBBER of VAR, delete it.\n-\n-     If it has a REG_LIBCALL note, delete the REG_LIBCALL\n-     and REG_RETVAL notes too.  */\n-  if (GET_CODE (PATTERN (insn)) == CLOBBER\n-      && (XEXP (PATTERN (insn), 0) == var\n-\t  || (GET_CODE (XEXP (PATTERN (insn), 0)) == CONCAT\n-\t      && (XEXP (XEXP (PATTERN (insn), 0), 0) == var\n-\t\t  || XEXP (XEXP (PATTERN (insn), 0), 1) == var))))\n-    {\n-      if ((note = find_reg_note (insn, REG_LIBCALL, NULL_RTX)) != 0)\n-\t/* The REG_LIBCALL note will go away since we are going to\n-\t   turn INSN into a NOTE, so just delete the\n-\t   corresponding REG_RETVAL note.  */\n-\tremove_note (XEXP (note, 0),\n-\t\t     find_reg_note (XEXP (note, 0), REG_RETVAL,\n-\t\t\t\t    NULL_RTX));\n-\n-      delete_insn (insn);\n-    }\n-\n-  /* The insn to load VAR from a home in the arglist\n-     is now a no-op.  When we see it, just delete it.\n-     Similarly if this is storing VAR from a register from which\n-     it was loaded in the previous insn.  This will occur\n-     when an ADDRESSOF was made for an arglist slot.  */\n-  else if (toplevel\n-\t   && (set = single_set (insn)) != 0\n-\t   && SET_DEST (set) == var\n-\t   /* If this represents the result of an insn group,\n-\t      don't delete the insn.  */\n-\t   && find_reg_note (insn, REG_RETVAL, NULL_RTX) == 0\n-\t   && (rtx_equal_p (SET_SRC (set), var)\n-\t       || (REG_P (SET_SRC (set))\n-\t\t   && (prev = prev_nonnote_insn (insn)) != 0\n-\t\t   && (prev_set = single_set (prev)) != 0\n-\t\t   && SET_DEST (prev_set) == SET_SRC (set)\n-\t\t   && rtx_equal_p (SET_SRC (prev_set), var))))\n-    {\n-      delete_insn (insn);\n-    }\n-  else\n-    {\n-      struct fixup_replacement *replacements = 0;\n-\n-      if (SMALL_REGISTER_CLASSES)\n-\t{\n-\t  /* If the insn that copies the results of a CALL_INSN\n-\t     into a pseudo now references VAR, we have to use an\n-\t     intermediate pseudo since we want the life of the\n-\t     return value register to be only a single insn.\n-\n-\t     If we don't use an intermediate pseudo, such things as\n-\t     address computations to make the address of VAR valid\n-\t     if it is not can be placed between the CALL_INSN and INSN.\n-\n-\t     To make sure this doesn't happen, we record the destination\n-\t     of the CALL_INSN and see if the next insn uses both that\n-\t     and VAR.  */\n-\n-\t  if (call_dest != 0 && GET_CODE (insn) == INSN\n-\t      && reg_mentioned_p (var, PATTERN (insn))\n-\t      && reg_mentioned_p (call_dest, PATTERN (insn)))\n-\t    {\n-\t      rtx temp = gen_reg_rtx (GET_MODE (call_dest));\n-\n-\t      emit_insn_before (gen_move_insn (temp, call_dest), insn);\n-\n-\t      PATTERN (insn) = replace_rtx (PATTERN (insn),\n-\t\t\t\t\t    call_dest, temp);\n-\t    }\n-\n-\t  if (GET_CODE (insn) == CALL_INSN\n-\t      && GET_CODE (PATTERN (insn)) == SET)\n-\t    call_dest = SET_DEST (PATTERN (insn));\n-\t  else if (GET_CODE (insn) == CALL_INSN\n-\t\t   && GET_CODE (PATTERN (insn)) == PARALLEL\n-\t\t   && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == SET)\n-\t    call_dest = SET_DEST (XVECEXP (PATTERN (insn), 0, 0));\n-\t  else\n-\t    call_dest = 0;\n-\t}\n-\n-      /* See if we have to do anything to INSN now that VAR is in\n-\t memory.  If it needs to be loaded into a pseudo, use a single\n-\t pseudo for the entire insn in case there is a MATCH_DUP\n-\t between two operands.  We pass a pointer to the head of\n-\t a list of struct fixup_replacements.  If fixup_var_refs_1\n-\t needs to allocate pseudos or replacement MEMs (for SUBREGs),\n-\t it will record them in this list.\n-\n-\t If it allocated a pseudo for any replacement, we copy into\n-\t it here.  */\n-\n-      fixup_var_refs_1 (var, promoted_mode, &PATTERN (insn), insn,\n-\t\t\t&replacements, no_share);\n-\n-      while (replacements)\n-\t{\n-\t  struct fixup_replacement *next;\n-\n-\t  if (REG_P (replacements->new))\n-\t    {\n-\t      rtx insert_before;\n-\t      rtx seq;\n-\n-\t      /* OLD might be a (subreg (mem)).  */\n-\t      if (GET_CODE (replacements->old) == SUBREG)\n-\t\treplacements->old\n-\t\t  = fixup_memory_subreg (replacements->old, insn,\n-\t\t\t\t\t promoted_mode, 0);\n-\t      else\n-\t\treplacements->old\n-\t\t  = fixup_stack_1 (replacements->old, insn);\n-\n-\t      insert_before = insn;\n-\n-\t      /* If we are changing the mode, do a conversion.\n-\t\t This might be wasteful, but combine.c will\n-\t\t eliminate much of the waste.  */\n-\n-\t      if (GET_MODE (replacements->new)\n-\t\t  != GET_MODE (replacements->old))\n-\t\t{\n-\t\t  start_sequence ();\n-\t\t  convert_move (replacements->new,\n-\t\t\t\treplacements->old, unsignedp);\n-\t\t  seq = get_insns ();\n-\t\t  end_sequence ();\n-\t\t}\n-\t      else\n-\t\tseq = gen_move_insn (replacements->new,\n-\t\t\t\t     replacements->old);\n-\n-\t      emit_insn_before (seq, insert_before);\n-\t    }\n-\n-\t  next = replacements->next;\n-\t  free (replacements);\n-\t  replacements = next;\n-\t}\n-    }\n-\n-  /* Also fix up any invalid exprs in the REG_NOTES of this insn.\n-     But don't touch other insns referred to by reg-notes;\n-     we will get them elsewhere.  */\n-  while (note)\n-    {\n-      if (GET_CODE (note) != INSN_LIST)\n-\tXEXP (note, 0)\n-\t  = walk_fixup_memory_subreg (XEXP (note, 0), insn, var,\n-\t\t\t\t      promoted_mode, 1);\n-      note = XEXP (note, 1);\n-    }\n-}\n-\f\n-/* VAR is a MEM that used to be a pseudo register with mode PROMOTED_MODE.\n-   See if the rtx expression at *LOC in INSN needs to be changed.\n-\n-   REPLACEMENTS is a pointer to a list head that starts out zero, but may\n-   contain a list of original rtx's and replacements. If we find that we need\n-   to modify this insn by replacing a memory reference with a pseudo or by\n-   making a new MEM to implement a SUBREG, we consult that list to see if\n-   we have already chosen a replacement. If none has already been allocated,\n-   we allocate it and update the list.  fixup_var_refs_insn will copy VAR\n-   or the SUBREG, as appropriate, to the pseudo.  */\n-\n-static void\n-fixup_var_refs_1 (rtx var, enum machine_mode promoted_mode, rtx *loc, rtx insn,\n-\t\t  struct fixup_replacement **replacements, rtx no_share)\n-{\n-  int i;\n-  rtx x = *loc;\n-  RTX_CODE code = GET_CODE (x);\n-  const char *fmt;\n-  rtx tem, tem1;\n-  struct fixup_replacement *replacement;\n-\n-  switch (code)\n-    {\n-    case ADDRESSOF:\n-      if (XEXP (x, 0) == var)\n-\t{\n-\t  /* Prevent sharing of rtl that might lose.  */\n-\t  rtx sub = copy_rtx (XEXP (var, 0));\n-\n-\t  if (! validate_change (insn, loc, sub, 0))\n-\t    {\n-\t      rtx y = gen_reg_rtx (GET_MODE (sub));\n-\t      rtx seq, new_insn;\n-\n-\t      /* We should be able to replace with a register or all is lost.\n-\t\t Note that we can't use validate_change to verify this, since\n-\t\t we're not caring for replacing all dups simultaneously.  */\n-\t      if (! validate_replace_rtx (*loc, y, insn))\n-\t\tabort ();\n-\n-\t      /* Careful!  First try to recognize a direct move of the\n-\t\t value, mimicking how things are done in gen_reload wrt\n-\t\t PLUS.  Consider what happens when insn is a conditional\n-\t\t move instruction and addsi3 clobbers flags.  */\n-\n-\t      start_sequence ();\n-\t      new_insn = emit_insn (gen_rtx_SET (VOIDmode, y, sub));\n-\t      seq = get_insns ();\n-\t      end_sequence ();\n-\n-\t      if (recog_memoized (new_insn) < 0)\n-\t\t{\n-\t\t  /* That failed.  Fall back on force_operand and hope.  */\n-\n-\t\t  start_sequence ();\n-\t\t  sub = force_operand (sub, y);\n-\t\t  if (sub != y)\n-\t\t    emit_insn (gen_move_insn (y, sub));\n-\t\t  seq = get_insns ();\n-\t\t  end_sequence ();\n-\t\t}\n-\n-#ifdef HAVE_cc0\n-\t      /* Don't separate setter from user.  */\n-\t      if (PREV_INSN (insn) && sets_cc0_p (PREV_INSN (insn)))\n-\t\tinsn = PREV_INSN (insn);\n-#endif\n-\n-\t      emit_insn_before (seq, insn);\n-\t    }\n-\t}\n-      return;\n-\n-    case MEM:\n-      if (var == x)\n-\t{\n-\t  /* If we already have a replacement, use it.  Otherwise,\n-\t     try to fix up this address in case it is invalid.  */\n-\n-\t  replacement = find_fixup_replacement (replacements, var);\n-\t  if (replacement->new)\n-\t    {\n-\t      *loc = replacement->new;\n-\t      return;\n-\t    }\n-\n-\t  *loc = replacement->new = x = fixup_stack_1 (x, insn);\n-\n-\t  /* Unless we are forcing memory to register or we changed the mode,\n-\t     we can leave things the way they are if the insn is valid.  */\n-\n-\t  INSN_CODE (insn) = -1;\n-\t  if (! flag_force_mem && GET_MODE (x) == promoted_mode\n-\t      && recog_memoized (insn) >= 0)\n-\t    return;\n-\n-\t  *loc = replacement->new = gen_reg_rtx (promoted_mode);\n-\t  return;\n-\t}\n-\n-      /* If X contains VAR, we need to unshare it here so that we update\n-\t each occurrence separately.  But all identical MEMs in one insn\n-\t must be replaced with the same rtx because of the possibility of\n-\t MATCH_DUPs.  */\n-\n-      if (reg_mentioned_p (var, x))\n-\t{\n-\t  replacement = find_fixup_replacement (replacements, x);\n-\t  if (replacement->new == 0)\n-\t    replacement->new = copy_most_rtx (x, no_share);\n-\n-\t  *loc = x = replacement->new;\n-\t  code = GET_CODE (x);\n-\t}\n-      break;\n-\n-    case REG:\n-    case CC0:\n-    case PC:\n-    case CONST_INT:\n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-    case CONST_DOUBLE:\n-    case CONST_VECTOR:\n-      return;\n-\n-    case SIGN_EXTRACT:\n-    case ZERO_EXTRACT:\n-      /* Note that in some cases those types of expressions are altered\n-\t by optimize_bit_field, and do not survive to get here.  */\n-      if (XEXP (x, 0) == var\n-\t  || (GET_CODE (XEXP (x, 0)) == SUBREG\n-\t      && SUBREG_REG (XEXP (x, 0)) == var))\n-\t{\n-\t  /* Get TEM as a valid MEM in the mode presently in the insn.\n-\n-\t     We don't worry about the possibility of MATCH_DUP here; it\n-\t     is highly unlikely and would be tricky to handle.  */\n-\n-\t  tem = XEXP (x, 0);\n-\t  if (GET_CODE (tem) == SUBREG)\n-\t    {\n-\t      if (GET_MODE_BITSIZE (GET_MODE (tem))\n-\t\t  > GET_MODE_BITSIZE (GET_MODE (var)))\n-\t\t{\n-\t\t  replacement = find_fixup_replacement (replacements, var);\n-\t\t  if (replacement->new == 0)\n-\t\t    replacement->new = gen_reg_rtx (GET_MODE (var));\n-\t\t  SUBREG_REG (tem) = replacement->new;\n-\n-\t\t  /* The following code works only if we have a MEM, so we\n-\t\t     need to handle the subreg here.  We directly substitute\n-\t\t     it assuming that a subreg must be OK here.  We already\n-\t\t     scheduled a replacement to copy the mem into the\n-\t\t     subreg.  */\n-\t\t  XEXP (x, 0) = tem;\n-\t\t  return;\n-\t\t}\n-\t      else\n-\t\ttem = fixup_memory_subreg (tem, insn, promoted_mode, 0);\n-\t    }\n-\t  else\n-\t    tem = fixup_stack_1 (tem, insn);\n-\n-\t  /* Unless we want to load from memory, get TEM into the proper mode\n-\t     for an extract from memory.  This can only be done if the\n-\t     extract is at a constant position and length.  */\n-\n-\t  if (! flag_force_mem && GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t      && GET_CODE (XEXP (x, 2)) == CONST_INT\n-\t      && ! mode_dependent_address_p (XEXP (tem, 0))\n-\t      && ! MEM_VOLATILE_P (tem))\n-\t    {\n-\t      enum machine_mode wanted_mode = VOIDmode;\n-\t      enum machine_mode is_mode = GET_MODE (tem);\n-\t      HOST_WIDE_INT pos = INTVAL (XEXP (x, 2));\n-\n-\t      if (GET_CODE (x) == ZERO_EXTRACT)\n-\t\t{\n-\t\t  enum machine_mode new_mode\n-\t\t    = mode_for_extraction (EP_extzv, 1);\n-\t\t  if (new_mode != MAX_MACHINE_MODE)\n-\t\t    wanted_mode = new_mode;\n-\t\t}\n-\t      else if (GET_CODE (x) == SIGN_EXTRACT)\n-\t\t{\n-\t\t  enum machine_mode new_mode\n-\t\t    = mode_for_extraction (EP_extv, 1);\n-\t\t  if (new_mode != MAX_MACHINE_MODE)\n-\t\t    wanted_mode = new_mode;\n-\t\t}\n-\n-\t      /* If we have a narrower mode, we can do something.  */\n-\t      if (wanted_mode != VOIDmode\n-\t\t  && GET_MODE_SIZE (wanted_mode) < GET_MODE_SIZE (is_mode))\n-\t\t{\n-\t\t  HOST_WIDE_INT offset = pos / BITS_PER_UNIT;\n-\t\t  rtx old_pos = XEXP (x, 2);\n-\t\t  rtx newmem;\n-\n-\t\t  /* If the bytes and bits are counted differently, we\n-\t\t     must adjust the offset.  */\n-\t\t  if (BYTES_BIG_ENDIAN != BITS_BIG_ENDIAN)\n-\t\t    offset = (GET_MODE_SIZE (is_mode)\n-\t\t\t      - GET_MODE_SIZE (wanted_mode) - offset);\n-\n-\t\t  pos %= GET_MODE_BITSIZE (wanted_mode);\n-\n-\t\t  newmem = adjust_address_nv (tem, wanted_mode, offset);\n-\n-\t\t  /* Make the change and see if the insn remains valid.  */\n-\t\t  INSN_CODE (insn) = -1;\n-\t\t  XEXP (x, 0) = newmem;\n-\t\t  XEXP (x, 2) = GEN_INT (pos);\n-\n-\t\t  if (recog_memoized (insn) >= 0)\n-\t\t    return;\n-\n-\t\t  /* Otherwise, restore old position.  XEXP (x, 0) will be\n-\t\t     restored later.  */\n-\t\t  XEXP (x, 2) = old_pos;\n-\t\t}\n-\t    }\n-\n-\t  /* If we get here, the bitfield extract insn can't accept a memory\n-\t     reference.  Copy the input into a register.  */\n-\n-\t  tem1 = gen_reg_rtx (GET_MODE (tem));\n-\t  emit_insn_before (gen_move_insn (tem1, tem), insn);\n-\t  XEXP (x, 0) = tem1;\n-\t  return;\n-\t}\n-      break;\n-\n-    case SUBREG:\n-      if (SUBREG_REG (x) == var)\n-\t{\n-\t  /* If this is a special SUBREG made because VAR was promoted\n-\t     from a wider mode, replace it with VAR and call ourself\n-\t     recursively, this time saying that the object previously\n-\t     had its current mode (by virtue of the SUBREG).  */\n-\n-\t  if (SUBREG_PROMOTED_VAR_P (x))\n-\t    {\n-\t      *loc = var;\n-\t      fixup_var_refs_1 (var, GET_MODE (var), loc, insn, replacements,\n-\t\t\t\tno_share);\n-\t      return;\n-\t    }\n-\n-\t  /* If this SUBREG makes VAR wider, it has become a paradoxical\n-\t     SUBREG with VAR in memory, but these aren't allowed at this\n-\t     stage of the compilation.  So load VAR into a pseudo and take\n-\t     a SUBREG of that pseudo.  */\n-\t  if (GET_MODE_SIZE (GET_MODE (x)) > GET_MODE_SIZE (GET_MODE (var)))\n-\t    {\n-\t      replacement = find_fixup_replacement (replacements, var);\n-\t      if (replacement->new == 0)\n-\t\treplacement->new = gen_reg_rtx (promoted_mode);\n-\t      SUBREG_REG (x) = replacement->new;\n-\t      return;\n-\t    }\n-\n-\t  /* See if we have already found a replacement for this SUBREG.\n-\t     If so, use it.  Otherwise, make a MEM and see if the insn\n-\t     is recognized.  If not, or if we should force MEM into a register,\n-\t     make a pseudo for this SUBREG.  */\n-\t  replacement = find_fixup_replacement (replacements, x);\n-\t  if (replacement->new)\n-\t    {\n-\t      enum machine_mode mode = GET_MODE (x);\n-\t      *loc = replacement->new;\n-\n-\t      /* Careful!  We may have just replaced a SUBREG by a MEM, which\n-\t\t means that the insn may have become invalid again.  We can't\n-\t\t in this case make a new replacement since we already have one\n-\t\t and we must deal with MATCH_DUPs.  */\n-\t      if (MEM_P (replacement->new))\n-\t\t{\n-\t\t  INSN_CODE (insn) = -1;\n-\t\t  if (recog_memoized (insn) >= 0)\n-\t\t    return;\n-\n-\t\t  fixup_var_refs_1 (replacement->new, mode, &PATTERN (insn),\n-\t\t\t\t    insn, replacements, no_share);\n-\t\t}\n-\n-\t      return;\n-\t    }\n-\n-\t  replacement->new = *loc = fixup_memory_subreg (x, insn,\n-\t\t\t\t\t\t\t promoted_mode, 0);\n-\n-\t  INSN_CODE (insn) = -1;\n-\t  if (! flag_force_mem && recog_memoized (insn) >= 0)\n-\t    return;\n-\n-\t  *loc = replacement->new = gen_reg_rtx (GET_MODE (x));\n-\t  return;\n-\t}\n-      break;\n-\n-    case SET:\n-      /* First do special simplification of bit-field references.  */\n-      if (GET_CODE (SET_DEST (x)) == SIGN_EXTRACT\n-\t  || GET_CODE (SET_DEST (x)) == ZERO_EXTRACT)\n-\toptimize_bit_field (x, insn, 0);\n-      if (GET_CODE (SET_SRC (x)) == SIGN_EXTRACT\n-\t  || GET_CODE (SET_SRC (x)) == ZERO_EXTRACT)\n-\toptimize_bit_field (x, insn, 0);\n-\n-      /* For a paradoxical SUBREG inside a ZERO_EXTRACT, load the object\n-\t into a register and then store it back out.  */\n-      if (GET_CODE (SET_DEST (x)) == ZERO_EXTRACT\n-\t  && GET_CODE (XEXP (SET_DEST (x), 0)) == SUBREG\n-\t  && SUBREG_REG (XEXP (SET_DEST (x), 0)) == var\n-\t  && (GET_MODE_SIZE (GET_MODE (XEXP (SET_DEST (x), 0)))\n-\t      > GET_MODE_SIZE (GET_MODE (var))))\n-\t{\n-\t  replacement = find_fixup_replacement (replacements, var);\n-\t  if (replacement->new == 0)\n-\t    replacement->new = gen_reg_rtx (GET_MODE (var));\n-\n-\t  SUBREG_REG (XEXP (SET_DEST (x), 0)) = replacement->new;\n-\t  emit_insn_after (gen_move_insn (var, replacement->new), insn);\n-\t}\n-\n-      /* If SET_DEST is now a paradoxical SUBREG, put the result of this\n-\t insn into a pseudo and store the low part of the pseudo into VAR.  */\n-      if (GET_CODE (SET_DEST (x)) == SUBREG\n-\t  && SUBREG_REG (SET_DEST (x)) == var\n-\t  && (GET_MODE_SIZE (GET_MODE (SET_DEST (x)))\n-\t      > GET_MODE_SIZE (GET_MODE (var))))\n-\t{\n-\t  SET_DEST (x) = tem = gen_reg_rtx (GET_MODE (SET_DEST (x)));\n-\t  emit_insn_after (gen_move_insn (var, gen_lowpart (GET_MODE (var),\n-\t\t\t\t\t\t\t    tem)),\n-\t\t\t   insn);\n-\t  break;\n-\t}\n-\n-      {\n-\trtx dest = SET_DEST (x);\n-\trtx src = SET_SRC (x);\n-\trtx outerdest = dest;\n-\n-\twhile (GET_CODE (dest) == SUBREG || GET_CODE (dest) == STRICT_LOW_PART\n-\t       || GET_CODE (dest) == SIGN_EXTRACT\n-\t       || GET_CODE (dest) == ZERO_EXTRACT)\n-\t  dest = XEXP (dest, 0);\n-\n-\tif (GET_CODE (src) == SUBREG)\n-\t  src = SUBREG_REG (src);\n-\n-\t/* If VAR does not appear at the top level of the SET\n-\t   just scan the lower levels of the tree.  */\n-\n-\tif (src != var && dest != var)\n-\t  break;\n-\n-\t/* We will need to rerecognize this insn.  */\n-\tINSN_CODE (insn) = -1;\n-\n-\tif (GET_CODE (outerdest) == ZERO_EXTRACT && dest == var\n-\t    && mode_for_extraction (EP_insv, -1) != MAX_MACHINE_MODE)\n-\t  {\n-\t    /* Since this case will return, ensure we fixup all the\n-\t       operands here.  */\n-\t    fixup_var_refs_1 (var, promoted_mode, &XEXP (outerdest, 1),\n-\t\t\t      insn, replacements, no_share);\n-\t    fixup_var_refs_1 (var, promoted_mode, &XEXP (outerdest, 2),\n-\t\t\t      insn, replacements, no_share);\n-\t    fixup_var_refs_1 (var, promoted_mode, &SET_SRC (x),\n-\t\t\t      insn, replacements, no_share);\n-\n-\t    tem = XEXP (outerdest, 0);\n-\n-\t    /* Clean up (SUBREG:SI (MEM:mode ...) 0)\n-\t       that may appear inside a ZERO_EXTRACT.\n-\t       This was legitimate when the MEM was a REG.  */\n-\t    if (GET_CODE (tem) == SUBREG\n-\t\t&& SUBREG_REG (tem) == var)\n-\t      tem = fixup_memory_subreg (tem, insn, promoted_mode, 0);\n-\t    else\n-\t      tem = fixup_stack_1 (tem, insn);\n-\n-\t    if (GET_CODE (XEXP (outerdest, 1)) == CONST_INT\n-\t\t&& GET_CODE (XEXP (outerdest, 2)) == CONST_INT\n-\t\t&& ! mode_dependent_address_p (XEXP (tem, 0))\n-\t\t&& ! MEM_VOLATILE_P (tem))\n-\t      {\n-\t\tenum machine_mode wanted_mode;\n-\t\tenum machine_mode is_mode = GET_MODE (tem);\n-\t\tHOST_WIDE_INT pos = INTVAL (XEXP (outerdest, 2));\n-\n-\t\twanted_mode = mode_for_extraction (EP_insv, 0);\n-\n-\t\t/* If we have a narrower mode, we can do something.  */\n-\t\tif (GET_MODE_SIZE (wanted_mode) < GET_MODE_SIZE (is_mode))\n-\t\t  {\n-\t\t    HOST_WIDE_INT offset = pos / BITS_PER_UNIT;\n-\t\t    rtx old_pos = XEXP (outerdest, 2);\n-\t\t    rtx newmem;\n-\n-\t\t    if (BYTES_BIG_ENDIAN != BITS_BIG_ENDIAN)\n-\t\t      offset = (GET_MODE_SIZE (is_mode)\n-\t\t\t\t- GET_MODE_SIZE (wanted_mode) - offset);\n-\n-\t\t    pos %= GET_MODE_BITSIZE (wanted_mode);\n-\n-\t\t    newmem = adjust_address_nv (tem, wanted_mode, offset);\n-\n-\t\t    /* Make the change and see if the insn remains valid.  */\n-\t\t    INSN_CODE (insn) = -1;\n-\t\t    XEXP (outerdest, 0) = newmem;\n-\t\t    XEXP (outerdest, 2) = GEN_INT (pos);\n-\n-\t\t    if (recog_memoized (insn) >= 0)\n-\t\t      return;\n-\n-\t\t    /* Otherwise, restore old position.  XEXP (x, 0) will be\n-\t\t       restored later.  */\n-\t\t    XEXP (outerdest, 2) = old_pos;\n-\t\t  }\n-\t      }\n-\n-\t    /* If we get here, the bit-field store doesn't allow memory\n-\t       or isn't located at a constant position.  Load the value into\n-\t       a register, do the store, and put it back into memory.  */\n-\n-\t    tem1 = gen_reg_rtx (GET_MODE (tem));\n-\t    emit_insn_before (gen_move_insn (tem1, tem), insn);\n-\t    emit_insn_after (gen_move_insn (tem, tem1), insn);\n-\t    XEXP (outerdest, 0) = tem1;\n-\t    return;\n-\t  }\n-\n-\t/* STRICT_LOW_PART is a no-op on memory references\n-\t   and it can cause combinations to be unrecognizable,\n-\t   so eliminate it.  */\n-\n-\tif (dest == var && GET_CODE (SET_DEST (x)) == STRICT_LOW_PART)\n-\t  SET_DEST (x) = XEXP (SET_DEST (x), 0);\n-\n-\t/* A valid insn to copy VAR into or out of a register\n-\t   must be left alone, to avoid an infinite loop here.\n-\t   If the reference to VAR is by a subreg, fix that up,\n-\t   since SUBREG is not valid for a memref.\n-\t   Also fix up the address of the stack slot.\n-\n-\t   Note that we must not try to recognize the insn until\n-\t   after we know that we have valid addresses and no\n-\t   (subreg (mem ...) ...) constructs, since these interfere\n-\t   with determining the validity of the insn.  */\n-\n-\tif ((SET_SRC (x) == var\n-\t     || (GET_CODE (SET_SRC (x)) == SUBREG\n-\t\t && SUBREG_REG (SET_SRC (x)) == var))\n-\t    && (REG_P (SET_DEST (x))\n-\t\t|| (GET_CODE (SET_DEST (x)) == SUBREG\n-\t\t    && REG_P (SUBREG_REG (SET_DEST (x)))))\n-\t    && GET_MODE (var) == promoted_mode\n-\t    && x == single_set (insn))\n-\t  {\n-\t    rtx pat, last;\n-\n-\t    if (GET_CODE (SET_SRC (x)) == SUBREG\n-\t\t&& (GET_MODE_SIZE (GET_MODE (SET_SRC (x)))\n-\t\t    > GET_MODE_SIZE (GET_MODE (var))))\n-\t      {\n-\t\t/* This (subreg VAR) is now a paradoxical subreg.  We need\n-\t\t   to replace VAR instead of the subreg.  */\n-\t\treplacement = find_fixup_replacement (replacements, var);\n-\t\tif (replacement->new == NULL_RTX)\n-\t\t  replacement->new = gen_reg_rtx (GET_MODE (var));\n-\t\tSUBREG_REG (SET_SRC (x)) = replacement->new;\n-\t      }\n-\t    else\n-\t      {\n-\t\treplacement = find_fixup_replacement (replacements, SET_SRC (x));\n-\t\tif (replacement->new)\n-\t\t  SET_SRC (x) = replacement->new;\n-\t\telse if (GET_CODE (SET_SRC (x)) == SUBREG)\n-\t\t  SET_SRC (x) = replacement->new\n-\t\t    = fixup_memory_subreg (SET_SRC (x), insn, promoted_mode,\n-\t\t\t\t\t   0);\n-\t\telse\n-\t\t  SET_SRC (x) = replacement->new\n-\t\t    = fixup_stack_1 (SET_SRC (x), insn);\n-\t      }\n-\n-\t    if (recog_memoized (insn) >= 0)\n-\t      return;\n-\n-\t    /* INSN is not valid, but we know that we want to\n-\t       copy SET_SRC (x) to SET_DEST (x) in some way.  So\n-\t       we generate the move and see whether it requires more\n-\t       than one insn.  If it does, we emit those insns and\n-\t       delete INSN.  Otherwise, we can just replace the pattern\n-\t       of INSN; we have already verified above that INSN has\n-\t       no other function that to do X.  */\n-\n-\t    pat = gen_move_insn (SET_DEST (x), SET_SRC (x));\n-\t    if (NEXT_INSN (pat) != NULL_RTX)\n-\t      {\n-\t\tlast = emit_insn_before (pat, insn);\n-\n-\t\t/* INSN might have REG_RETVAL or other important notes, so\n-\t\t   we need to store the pattern of the last insn in the\n-\t\t   sequence into INSN similarly to the normal case.  LAST\n-\t\t   should not have REG_NOTES, but we allow them if INSN has\n-\t\t   no REG_NOTES.  */\n-\t\tif (REG_NOTES (last) && REG_NOTES (insn))\n-\t\t  abort ();\n-\t\tif (REG_NOTES (last))\n-\t\t  REG_NOTES (insn) = REG_NOTES (last);\n-\t\tPATTERN (insn) = PATTERN (last);\n-\n-\t\tdelete_insn (last);\n-\t      }\n-\t    else\n-\t      PATTERN (insn) = PATTERN (pat);\n-\n-\t    return;\n-\t  }\n-\n-\tif ((SET_DEST (x) == var\n-\t     || (GET_CODE (SET_DEST (x)) == SUBREG\n-\t\t && SUBREG_REG (SET_DEST (x)) == var))\n-\t    && (REG_P (SET_SRC (x))\n-\t\t|| (GET_CODE (SET_SRC (x)) == SUBREG\n-\t\t    && REG_P (SUBREG_REG (SET_SRC (x)))))\n-\t    && GET_MODE (var) == promoted_mode\n-\t    && x == single_set (insn))\n-\t  {\n-\t    rtx pat, last;\n-\n-\t    if (GET_CODE (SET_DEST (x)) == SUBREG)\n-\t      SET_DEST (x) = fixup_memory_subreg (SET_DEST (x), insn,\n-\t\t\t\t\t\t  promoted_mode, 0);\n-\t    else\n-\t      SET_DEST (x) = fixup_stack_1 (SET_DEST (x), insn);\n-\n-\t    if (recog_memoized (insn) >= 0)\n-\t      return;\n-\n-\t    pat = gen_move_insn (SET_DEST (x), SET_SRC (x));\n-\t    if (NEXT_INSN (pat) != NULL_RTX)\n-\t      {\n-\t\tlast = emit_insn_before (pat, insn);\n-\n-\t\t/* INSN might have REG_RETVAL or other important notes, so\n-\t\t   we need to store the pattern of the last insn in the\n-\t\t   sequence into INSN similarly to the normal case.  LAST\n-\t\t   should not have REG_NOTES, but we allow them if INSN has\n-\t\t   no REG_NOTES.  */\n-\t\tif (REG_NOTES (last) && REG_NOTES (insn))\n-\t\t  abort ();\n-\t\tif (REG_NOTES (last))\n-\t\t  REG_NOTES (insn) = REG_NOTES (last);\n-\t\tPATTERN (insn) = PATTERN (last);\n-\n-\t\tdelete_insn (last);\n-\t      }\n-\t    else\n-\t      PATTERN (insn) = PATTERN (pat);\n-\n-\t    return;\n-\t  }\n-\n-\t/* Otherwise, storing into VAR must be handled specially\n-\t   by storing into a temporary and copying that into VAR\n-\t   with a new insn after this one.  Note that this case\n-\t   will be used when storing into a promoted scalar since\n-\t   the insn will now have different modes on the input\n-\t   and output and hence will be invalid (except for the case\n-\t   of setting it to a constant, which does not need any\n-\t   change if it is valid).  We generate extra code in that case,\n-\t   but combine.c will eliminate it.  */\n-\n-\tif (dest == var)\n-\t  {\n-\t    rtx temp;\n-\t    rtx fixeddest = SET_DEST (x);\n-\t    enum machine_mode temp_mode;\n-\n-\t    /* STRICT_LOW_PART can be discarded, around a MEM.  */\n-\t    if (GET_CODE (fixeddest) == STRICT_LOW_PART)\n-\t      fixeddest = XEXP (fixeddest, 0);\n-\t    /* Convert (SUBREG (MEM)) to a MEM in a changed mode.  */\n-\t    if (GET_CODE (fixeddest) == SUBREG)\n-\t      {\n-\t\tfixeddest = fixup_memory_subreg (fixeddest, insn,\n-\t\t\t\t\t\t promoted_mode, 0);\n-\t\ttemp_mode = GET_MODE (fixeddest);\n-\t      }\n-\t    else\n-\t      {\n-\t\tfixeddest = fixup_stack_1 (fixeddest, insn);\n-\t\ttemp_mode = promoted_mode;\n-\t      }\n-\n-\t    temp = gen_reg_rtx (temp_mode);\n-\n-\t    emit_insn_after (gen_move_insn (fixeddest,\n-\t\t\t\t\t    gen_lowpart (GET_MODE (fixeddest),\n-\t\t\t\t\t\t\t temp)),\n-\t\t\t     insn);\n-\n-\t    SET_DEST (x) = temp;\n-\t  }\n-      }\n-\n-    default:\n-      break;\n-    }\n-\n-  /* Nothing special about this RTX; fix its operands.  */\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\tfixup_var_refs_1 (var, promoted_mode, &XEXP (x, i), insn, replacements,\n-\t\t\t  no_share);\n-      else if (fmt[i] == 'E')\n-\t{\n-\t  int j;\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    fixup_var_refs_1 (var, promoted_mode, &XVECEXP (x, i, j),\n-\t\t\t      insn, replacements, no_share);\n-\t}\n-    }\n-}\n-\f\n-/* Previously, X had the form (SUBREG:m1 (REG:PROMOTED_MODE ...)).\n-   The REG  was placed on the stack, so X now has the form (SUBREG:m1\n-   (MEM:m2 ...)).\n-\n-   Return an rtx (MEM:m1 newaddr) which is equivalent.  If any insns\n-   must be emitted to compute NEWADDR, put them before INSN.\n-\n-   UNCRITICAL nonzero means accept paradoxical subregs.\n-   This is used for subregs found inside REG_NOTES.  */\n-\n-static rtx\n-fixup_memory_subreg (rtx x, rtx insn, enum machine_mode promoted_mode, int uncritical)\n-{\n-  int offset;\n-  rtx mem = SUBREG_REG (x);\n-  rtx addr = XEXP (mem, 0);\n-  enum machine_mode mode = GET_MODE (x);\n-  rtx result, seq;\n-\n-  /* Paradoxical SUBREGs are usually invalid during RTL generation.  */\n-  if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (mem)) && ! uncritical)\n-    abort ();\n-\n-  offset = SUBREG_BYTE (x);\n-  if (BYTES_BIG_ENDIAN)\n-    /* If the PROMOTED_MODE is wider than the mode of the MEM, adjust\n-       the offset so that it points to the right location within the\n-       MEM.  */\n-    offset -= (GET_MODE_SIZE (promoted_mode) - GET_MODE_SIZE (GET_MODE (mem)));\n-\n-  if (!flag_force_addr\n-      && memory_address_p (mode, plus_constant (addr, offset)))\n-    /* Shortcut if no insns need be emitted.  */\n-    return adjust_address (mem, mode, offset);\n-\n-  start_sequence ();\n-  result = adjust_address (mem, mode, offset);\n-  seq = get_insns ();\n-  end_sequence ();\n-\n-  emit_insn_before (seq, insn);\n-  return result;\n-}\n-\n-/* Do fixup_memory_subreg on all (SUBREG (VAR) ...) contained in X.\n-   VAR is a MEM that used to be a pseudo register with mode PROMOTED_MODE.\n-   Replace subexpressions of X in place.\n-   If X itself is a (SUBREG (VAR) ...), return the replacement expression.\n-   Otherwise return X, with its contents possibly altered.\n-\n-   INSN and UNCRITICAL are as for fixup_memory_subreg.  */\n-\n-static rtx\n-walk_fixup_memory_subreg (rtx x, rtx insn, rtx var,\n-\t\t\t  enum machine_mode promoted_mode, int uncritical)\n-{\n-  enum rtx_code code;\n-  const char *fmt;\n-  int i;\n-\n-  if (x == 0)\n-    return 0;\n-\n-  code = GET_CODE (x);\n-\n-  if (code == SUBREG && SUBREG_REG (x) == var)\n-    return fixup_memory_subreg (x, insn, promoted_mode, uncritical);\n-\n-  /* Nothing special about this RTX; fix its operands.  */\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\tXEXP (x, i) = walk_fixup_memory_subreg (XEXP (x, i), insn, var,\n-\t\t\t\t\t\tpromoted_mode, uncritical);\n-      else if (fmt[i] == 'E')\n-\t{\n-\t  int j;\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    XVECEXP (x, i, j)\n-\t      = walk_fixup_memory_subreg (XVECEXP (x, i, j), insn, var,\n-\t\t\t\t\t  promoted_mode, uncritical);\n-\t}\n-    }\n-  return x;\n-}\n-\f\n-/* For each memory ref within X, if it refers to a stack slot\n-   with an out of range displacement, put the address in a temp register\n-   (emitting new insns before INSN to load these registers)\n-   and alter the memory ref to use that register.\n-   Replace each such MEM rtx with a copy, to avoid clobberage.  */\n-\n-static rtx\n-fixup_stack_1 (rtx x, rtx insn)\n-{\n-  int i;\n-  RTX_CODE code = GET_CODE (x);\n-  const char *fmt;\n-\n-  if (code == MEM)\n-    {\n-      rtx ad = XEXP (x, 0);\n-      /* If we have address of a stack slot but it's not valid\n-\t (displacement is too large), compute the sum in a register.  */\n-      if (GET_CODE (ad) == PLUS\n-\t  && REG_P (XEXP (ad, 0))\n-\t  && ((REGNO (XEXP (ad, 0)) >= FIRST_VIRTUAL_REGISTER\n-\t       && REGNO (XEXP (ad, 0)) <= LAST_VIRTUAL_REGISTER)\n-\t      || REGNO (XEXP (ad, 0)) == FRAME_POINTER_REGNUM\n-#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-\t      || REGNO (XEXP (ad, 0)) == HARD_FRAME_POINTER_REGNUM\n-#endif\n-\t      || REGNO (XEXP (ad, 0)) == STACK_POINTER_REGNUM\n-\t      || REGNO (XEXP (ad, 0)) == ARG_POINTER_REGNUM\n-\t      || XEXP (ad, 0) == current_function_internal_arg_pointer)\n-\t  && GET_CODE (XEXP (ad, 1)) == CONST_INT)\n-\t{\n-\t  rtx temp, seq;\n-\t  if (memory_address_p (GET_MODE (x), ad))\n-\t    return x;\n-\n-\t  start_sequence ();\n-\t  temp = copy_to_reg (ad);\n-\t  seq = get_insns ();\n-\t  end_sequence ();\n-\t  emit_insn_before (seq, insn);\n-\t  return replace_equiv_address (x, temp);\n-\t}\n-      return x;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\tXEXP (x, i) = fixup_stack_1 (XEXP (x, i), insn);\n-      else if (fmt[i] == 'E')\n-\t{\n-\t  int j;\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    XVECEXP (x, i, j) = fixup_stack_1 (XVECEXP (x, i, j), insn);\n-\t}\n-    }\n-  return x;\n-}\n-\f\n-/* Optimization: a bit-field instruction whose field\n-   happens to be a byte or halfword in memory\n-   can be changed to a move instruction.\n-\n-   We call here when INSN is an insn to examine or store into a bit-field.\n-   BODY is the SET-rtx to be altered.\n-\n-   EQUIV_MEM is the table `reg_equiv_mem' if that is available; else 0.\n-   (Currently this is called only from function.c, and EQUIV_MEM\n-   is always 0.)  */\n-\n-static void\n-optimize_bit_field (rtx body, rtx insn, rtx *equiv_mem)\n-{\n-  rtx bitfield;\n-  int destflag;\n-  rtx seq = 0;\n-  enum machine_mode mode;\n-\n-  if (GET_CODE (SET_DEST (body)) == SIGN_EXTRACT\n-      || GET_CODE (SET_DEST (body)) == ZERO_EXTRACT)\n-    bitfield = SET_DEST (body), destflag = 1;\n-  else\n-    bitfield = SET_SRC (body), destflag = 0;\n-\n-  /* First check that the field being stored has constant size and position\n-     and is in fact a byte or halfword suitably aligned.  */\n-\n-  if (GET_CODE (XEXP (bitfield, 1)) == CONST_INT\n-      && GET_CODE (XEXP (bitfield, 2)) == CONST_INT\n-      && ((mode = mode_for_size (INTVAL (XEXP (bitfield, 1)), MODE_INT, 1))\n-\t  != BLKmode)\n-      && INTVAL (XEXP (bitfield, 2)) % INTVAL (XEXP (bitfield, 1)) == 0)\n-    {\n-      rtx memref = 0;\n-\n-      /* Now check that the containing word is memory, not a register,\n-\t and that it is safe to change the machine mode.  */\n-\n-      if (MEM_P (XEXP (bitfield, 0)))\n-\tmemref = XEXP (bitfield, 0);\n-      else if (REG_P (XEXP (bitfield, 0))\n-\t       && equiv_mem != 0)\n-\tmemref = equiv_mem[REGNO (XEXP (bitfield, 0))];\n-      else if (GET_CODE (XEXP (bitfield, 0)) == SUBREG\n-\t       && MEM_P (SUBREG_REG (XEXP (bitfield, 0))))\n-\tmemref = SUBREG_REG (XEXP (bitfield, 0));\n-      else if (GET_CODE (XEXP (bitfield, 0)) == SUBREG\n-\t       && equiv_mem != 0\n-\t       && REG_P (SUBREG_REG (XEXP (bitfield, 0))))\n-\tmemref = equiv_mem[REGNO (SUBREG_REG (XEXP (bitfield, 0)))];\n-\n-      if (memref\n-\t  && ! mode_dependent_address_p (XEXP (memref, 0))\n-\t  && ! MEM_VOLATILE_P (memref))\n-\t{\n-\t  /* Now adjust the address, first for any subreg'ing\n-\t     that we are now getting rid of,\n-\t     and then for which byte of the word is wanted.  */\n-\n-\t  HOST_WIDE_INT offset = INTVAL (XEXP (bitfield, 2));\n-\t  rtx insns;\n-\n-\t  /* Adjust OFFSET to count bits from low-address byte.  */\n-\t  if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n-\t    offset = (GET_MODE_BITSIZE (GET_MODE (XEXP (bitfield, 0)))\n-\t\t      - offset - INTVAL (XEXP (bitfield, 1)));\n-\n-\t  /* Adjust OFFSET to count bytes from low-address byte.  */\n-\t  offset /= BITS_PER_UNIT;\n-\t  if (GET_CODE (XEXP (bitfield, 0)) == SUBREG)\n-\t    {\n-\t      offset += (SUBREG_BYTE (XEXP (bitfield, 0))\n-\t\t\t / UNITS_PER_WORD) * UNITS_PER_WORD;\n-\t      if (BYTES_BIG_ENDIAN)\n-\t\toffset -= (MIN (UNITS_PER_WORD,\n-\t\t\t\tGET_MODE_SIZE (GET_MODE (XEXP (bitfield, 0))))\n-\t\t\t   - MIN (UNITS_PER_WORD,\n-\t\t\t\t  GET_MODE_SIZE (GET_MODE (memref))));\n-\t    }\n-\n-\t  start_sequence ();\n-\t  memref = adjust_address (memref, mode, offset);\n-\t  insns = get_insns ();\n-\t  end_sequence ();\n-\t  emit_insn_before (insns, insn);\n-\n-\t  /* Store this memory reference where\n-\t     we found the bit field reference.  */\n-\n-\t  if (destflag)\n-\t    {\n-\t      validate_change (insn, &SET_DEST (body), memref, 1);\n-\t      if (! CONSTANT_ADDRESS_P (SET_SRC (body)))\n-\t\t{\n-\t\t  rtx src = SET_SRC (body);\n-\t\t  while (GET_CODE (src) == SUBREG\n-\t\t\t && SUBREG_BYTE (src) == 0)\n-\t\t    src = SUBREG_REG (src);\n-\t\t  if (GET_MODE (src) != GET_MODE (memref))\n-\t\t    src = gen_lowpart (GET_MODE (memref), SET_SRC (body));\n-\t\t  validate_change (insn, &SET_SRC (body), src, 1);\n-\t\t}\n-\t      else if (GET_MODE (SET_SRC (body)) != VOIDmode\n-\t\t       && GET_MODE (SET_SRC (body)) != GET_MODE (memref))\n-\t\t/* This shouldn't happen because anything that didn't have\n-\t\t   one of these modes should have got converted explicitly\n-\t\t   and then referenced through a subreg.\n-\t\t   This is so because the original bit-field was\n-\t\t   handled by agg_mode and so its tree structure had\n-\t\t   the same mode that memref now has.  */\n-\t\tabort ();\n-\t    }\n-\t  else\n-\t    {\n-\t      rtx dest = SET_DEST (body);\n-\n-\t      while (GET_CODE (dest) == SUBREG\n-\t\t     && SUBREG_BYTE (dest) == 0\n-\t\t     && (GET_MODE_CLASS (GET_MODE (dest))\n-\t\t\t == GET_MODE_CLASS (GET_MODE (SUBREG_REG (dest))))\n-\t\t     && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))\n-\t\t\t <= UNITS_PER_WORD))\n-\t\tdest = SUBREG_REG (dest);\n-\n-\t      validate_change (insn, &SET_DEST (body), dest, 1);\n-\n-\t      if (GET_MODE (dest) == GET_MODE (memref))\n-\t\tvalidate_change (insn, &SET_SRC (body), memref, 1);\n-\t      else\n-\t\t{\n-\t\t  /* Convert the mem ref to the destination mode.  */\n-\t\t  rtx newreg = gen_reg_rtx (GET_MODE (dest));\n-\n-\t\t  start_sequence ();\n-\t\t  convert_move (newreg, memref,\n-\t\t\t\tGET_CODE (SET_SRC (body)) == ZERO_EXTRACT);\n-\t\t  seq = get_insns ();\n-\t\t  end_sequence ();\n-\n-\t\t  validate_change (insn, &SET_SRC (body), newreg, 1);\n-\t\t}\n-\t    }\n-\n-\t  /* See if we can convert this extraction or insertion into\n-\t     a simple move insn.  We might not be able to do so if this\n-\t     was, for example, part of a PARALLEL.\n-\n-\t     If we succeed, write out any needed conversions.  If we fail,\n-\t     it is hard to guess why we failed, so don't do anything\n-\t     special; just let the optimization be suppressed.  */\n-\n-\t  if (apply_change_group () && seq)\n-\t    emit_insn_before (seq, insn);\n-\t}\n-    }\n-}\n-\f\n-/* These routines are responsible for converting virtual register references\n-   to the actual hard register references once RTL generation is complete.\n-\n-   The following four variables are used for communication between the\n-   routines.  They contain the offsets of the virtual registers from their\n-   respective hard registers.  */\n-\n-static int in_arg_offset;\n-static int var_offset;\n-static int dynamic_offset;\n-static int out_arg_offset;\n-static int cfa_offset;\n-\n-/* In most machines, the stack pointer register is equivalent to the bottom\n-   of the stack.  */\n-\n-#ifndef STACK_POINTER_OFFSET\n-#define STACK_POINTER_OFFSET\t0\n-#endif\n-\n-/* If not defined, pick an appropriate default for the offset of dynamically\n-   allocated memory depending on the value of ACCUMULATE_OUTGOING_ARGS,\n-   REG_PARM_STACK_SPACE, and OUTGOING_REG_PARM_STACK_SPACE.  */\n-\n-#ifndef STACK_DYNAMIC_OFFSET\n-\n-/* The bottom of the stack points to the actual arguments.  If\n-   REG_PARM_STACK_SPACE is defined, this includes the space for the register\n-   parameters.  However, if OUTGOING_REG_PARM_STACK space is not defined,\n-   stack space for register parameters is not pushed by the caller, but\n-   rather part of the fixed stack areas and hence not included in\n-   `current_function_outgoing_args_size'.  Nevertheless, we must allow\n-   for it when allocating stack dynamic objects.  */\n-\n-#if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n-#define STACK_DYNAMIC_OFFSET(FNDECL)\t\\\n-((ACCUMULATE_OUTGOING_ARGS\t\t\t\t\t\t      \\\n-  ? (current_function_outgoing_args_size + REG_PARM_STACK_SPACE (FNDECL)) : 0)\\\n- + (STACK_POINTER_OFFSET))\t\t\t\t\t\t      \\\n-\n-#else\n-#define STACK_DYNAMIC_OFFSET(FNDECL)\t\\\n-((ACCUMULATE_OUTGOING_ARGS ? current_function_outgoing_args_size : 0)\t      \\\n- + (STACK_POINTER_OFFSET))\n-#endif\n-#endif\n-\n-/* On most machines, the CFA coincides with the first incoming parm.  */\n-\n-#ifndef ARG_POINTER_CFA_OFFSET\n-#define ARG_POINTER_CFA_OFFSET(FNDECL) FIRST_PARM_OFFSET (FNDECL)\n-#endif\n-\n-/* Build up a (MEM (ADDRESSOF (REG))) rtx for a register REG that just\n-   had its address taken.  DECL is the decl or SAVE_EXPR for the\n-   object stored in the register, for later use if we do need to force\n-   REG into the stack.  REG is overwritten by the MEM like in\n-   put_reg_into_stack.  RESCAN is true if previously emitted\n-   instructions must be rescanned and modified now that the REG has\n-   been transformed.  */\n-\n-rtx\n-gen_mem_addressof (rtx reg, tree decl, int rescan)\n-{\n-  rtx r = gen_rtx_ADDRESSOF (Pmode, gen_reg_rtx (GET_MODE (reg)),\n-\t\t\t     REGNO (reg), decl);\n-\n-  /* Calculate this before we start messing with decl's RTL.  */\n-  HOST_WIDE_INT set = decl ? get_alias_set (decl) : 0;\n-\n-  /* If the original REG was a user-variable, then so is the REG whose\n-     address is being taken.  Likewise for unchanging.  */\n-  REG_USERVAR_P (XEXP (r, 0)) = REG_USERVAR_P (reg);\n-  RTX_UNCHANGING_P (XEXP (r, 0)) = RTX_UNCHANGING_P (reg);\n-\n-  PUT_CODE (reg, MEM);\n-  MEM_VOLATILE_P (reg) = 0;\n-  MEM_ATTRS (reg) = 0;\n-  XEXP (reg, 0) = r;\n-\n-  if (decl)\n-    {\n-      tree type = TREE_TYPE (decl);\n-      enum machine_mode decl_mode = DECL_MODE (decl);\n-      rtx decl_rtl = DECL_RTL_IF_SET (decl);\n-\n-      PUT_MODE (reg, decl_mode);\n-\n-      /* Clear DECL_RTL momentarily so functions below will work\n-\t properly, then set it again.  */\n-      if (DECL_P (decl) && decl_rtl == reg)\n-\tSET_DECL_RTL (decl, 0);\n-\n-      set_mem_attributes (reg, decl, 1);\n-      set_mem_alias_set (reg, set);\n-\n-      if (DECL_P (decl) && decl_rtl == reg)\n-\tSET_DECL_RTL (decl, reg);\n-\n-      if (rescan\n-\t  && (TREE_USED (decl) || (DECL_P (decl) && DECL_INITIAL (decl) != 0)))\n-\tfixup_var_refs (reg, GET_MODE (reg), TYPE_UNSIGNED (type), reg, 0);\n-    }\n-  else if (rescan)\n-    {\n-      /* This can only happen during reload.  Clear the same flag bits as\n-\t reload.  */\n-      RTX_UNCHANGING_P (reg) = 0;\n-      MEM_IN_STRUCT_P (reg) = 0;\n-      MEM_SCALAR_P (reg) = 0;\n-\n-      fixup_var_refs (reg, GET_MODE (reg), 0, reg, 0);\n-    }\n-\n-  return reg;\n-}\n-\n-/* If DECL has an RTL that is an ADDRESSOF rtx, put it into the stack.  */\n-\n-void\n-flush_addressof (tree decl)\n-{\n-  if ((TREE_CODE (decl) == PARM_DECL || TREE_CODE (decl) == VAR_DECL)\n-      && DECL_RTL (decl) != 0\n-      && MEM_P (DECL_RTL (decl))\n-      && GET_CODE (XEXP (DECL_RTL (decl), 0)) == ADDRESSOF\n-      && REG_P (XEXP (XEXP (DECL_RTL (decl), 0), 0)))\n-    put_addressof_into_stack (XEXP (DECL_RTL (decl), 0), 0);\n-}\n-\n-/* Force the register pointed to by R, an ADDRESSOF rtx, into the stack.  */\n-\n-static void\n-put_addressof_into_stack (rtx r, htab_t ht)\n-{\n-  tree decl, type;\n-  bool volatile_p, used_p;\n-\n-  rtx reg = XEXP (r, 0);\n-\n-  if (!REG_P (reg))\n-    abort ();\n-\n-  decl = ADDRESSOF_DECL (r);\n-  if (decl)\n-    {\n-      type = TREE_TYPE (decl);\n-      volatile_p = (TREE_CODE (decl) != SAVE_EXPR\n-\t\t    && TREE_THIS_VOLATILE (decl));\n-      used_p = (TREE_USED (decl)\n-\t\t|| (DECL_P (decl) && DECL_INITIAL (decl) != 0));\n-    }\n-  else\n-    {\n-      type = NULL_TREE;\n-      volatile_p = false;\n-      used_p = true;\n-    }\n-\n-  put_reg_into_stack (0, reg, type, GET_MODE (reg), ADDRESSOF_REGNO (r),\n-\t\t      volatile_p, used_p, false, ht);\n-}\n-\n-/* List of replacements made below in purge_addressof_1 when creating\n-   bitfield insertions.  */\n-static rtx purge_bitfield_addressof_replacements;\n-\n-/* List of replacements made below in purge_addressof_1 for patterns\n-   (MEM (ADDRESSOF (REG ...))).  The key of the list entry is the\n-   corresponding (ADDRESSOF (REG ...)) and value is a substitution for\n-   the all pattern.  List PURGE_BITFIELD_ADDRESSOF_REPLACEMENTS is not\n-   enough in complex cases, e.g. when some field values can be\n-   extracted by usage MEM with narrower mode.  */\n-static rtx purge_addressof_replacements;\n-\n-/* Helper function for purge_addressof.  See if the rtx expression at *LOC\n-   in INSN needs to be changed.  If FORCE, always put any ADDRESSOFs into\n-   the stack.  If the function returns FALSE then the replacement could not\n-   be made.  If MAY_POSTPONE is true and we would not put the addressof\n-   to stack, postpone processing of the insn.  */\n-\n-static bool\n-purge_addressof_1 (rtx *loc, rtx insn, int force, int store, int may_postpone,\n-\t\t   htab_t ht)\n-{\n-  rtx x;\n-  RTX_CODE code;\n-  int i, j;\n-  const char *fmt;\n-  bool result = true;\n-  bool libcall = false;\n-\n-  /* Re-start here to avoid recursion in common cases.  */\n- restart:\n-\n-  x = *loc;\n-  if (x == 0)\n-    return true;\n-\n-  /* Is this a libcall?  */\n-  if (!insn)\n-    libcall = REG_NOTE_KIND (*loc) == REG_RETVAL;\n-\n-  code = GET_CODE (x);\n-\n-  /* If we don't return in any of the cases below, we will recurse inside\n-     the RTX, which will normally result in any ADDRESSOF being forced into\n-     memory.  */\n-  if (code == SET)\n-    {\n-      result = purge_addressof_1 (&SET_DEST (x), insn, force, 1,\n-\t\t\t\t  may_postpone, ht);\n-      result &= purge_addressof_1 (&SET_SRC (x), insn, force, 0,\n-\t\t\t\t   may_postpone, ht);\n-      return result;\n-    }\n-  else if (code == ADDRESSOF)\n-    {\n-      rtx sub, insns;\n-\n-      if (!MEM_P (XEXP (x, 0)))\n-\tput_addressof_into_stack (x, ht);\n-\n-      /* We must create a copy of the rtx because it was created by\n-\t overwriting a REG rtx which is always shared.  */\n-      sub = copy_rtx (XEXP (XEXP (x, 0), 0));\n-      if (validate_change (insn, loc, sub, 0)\n-\t  || validate_replace_rtx (x, sub, insn))\n-\treturn true;\n-\n-      start_sequence ();\n-\n-      /* If SUB is a hard or virtual register, try it as a pseudo-register.\n-\t Otherwise, perhaps SUB is an expression, so generate code to compute\n-\t it.  */\n-      if (REG_P (sub) && REGNO (sub) <= LAST_VIRTUAL_REGISTER)\n-\tsub = copy_to_reg (sub);\n-      else\n-\tsub = force_operand (sub, NULL_RTX);\n-\n-      if (! validate_change (insn, loc, sub, 0)\n-\t  && ! validate_replace_rtx (x, sub, insn))\n-\tabort ();\n-\n-      insns = get_insns ();\n-      end_sequence ();\n-      emit_insn_before (insns, insn);\n-      return true;\n-    }\n-\n-  else if (code == MEM && GET_CODE (XEXP (x, 0)) == ADDRESSOF && ! force)\n-    {\n-      rtx sub = XEXP (XEXP (x, 0), 0);\n-\n-      if (MEM_P (sub))\n-\tsub = adjust_address_nv (sub, GET_MODE (x), 0);\n-      else if (REG_P (sub)\n-\t       && (MEM_VOLATILE_P (x) || GET_MODE (x) == BLKmode))\n-\t;\n-      else if (REG_P (sub) && GET_MODE (x) != GET_MODE (sub))\n-\t{\n-\t  int size_x, size_sub;\n-\n-\t  if (may_postpone)\n-\t    {\n-\t      /* Postpone for now, so that we do not emit bitfield arithmetics\n-\t\t unless there is some benefit from it.  */\n-\t      if (!postponed_insns || XEXP (postponed_insns, 0) != insn)\n-\t\tpostponed_insns = alloc_INSN_LIST (insn, postponed_insns);\n-\t      return true;\n-\t    }\n-\n-\t  if (!insn)\n-\t    {\n-\t      /* When processing REG_NOTES look at the list of\n-\t\t replacements done on the insn to find the register that X\n-\t\t was replaced by.  */\n-\t      rtx tem;\n-\n-\t      for (tem = purge_bitfield_addressof_replacements;\n-\t\t   tem != NULL_RTX;\n-\t\t   tem = XEXP (XEXP (tem, 1), 1))\n-\t\tif (rtx_equal_p (x, XEXP (tem, 0)))\n-\t\t  {\n-\t\t    *loc = XEXP (XEXP (tem, 1), 0);\n-\t\t    return true;\n-\t\t  }\n-\n-\t      /* See comment for purge_addressof_replacements.  */\n-\t      for (tem = purge_addressof_replacements;\n-\t\t   tem != NULL_RTX;\n-\t\t   tem = XEXP (XEXP (tem, 1), 1))\n-\t\tif (rtx_equal_p (XEXP (x, 0), XEXP (tem, 0)))\n-\t\t  {\n-\t\t    rtx z = XEXP (XEXP (tem, 1), 0);\n-\n-\t\t    if (GET_MODE (x) == GET_MODE (z)\n-\t\t\t|| (!REG_P (XEXP (XEXP (tem, 1), 0))\n-\t\t\t    && GET_CODE (XEXP (XEXP (tem, 1), 0)) != SUBREG))\n-\t\t      abort ();\n-\n-\t\t    /* It can happen that the note may speak of things\n-\t\t       in a wider (or just different) mode than the\n-\t\t       code did.  This is especially true of\n-\t\t       REG_RETVAL.  */\n-\n-\t\t    if (GET_CODE (z) == SUBREG && SUBREG_BYTE (z) == 0)\n-\t\t      z = SUBREG_REG (z);\n-\n-\t\t    if (GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD\n-\t\t\t&& (GET_MODE_SIZE (GET_MODE (x))\n-\t\t\t    > GET_MODE_SIZE (GET_MODE (z))))\n-\t\t      {\n-\t\t\t/* This can occur as a result in invalid\n-\t\t\t   pointer casts, e.g. float f; ...\n-\t\t\t   *(long long int *)&f.\n-\t\t\t   ??? We could emit a warning here, but\n-\t\t\t   without a line number that wouldn't be\n-\t\t\t   very helpful.  */\n-\t\t\tz = gen_rtx_SUBREG (GET_MODE (x), z, 0);\n-\t\t      }\n-\t\t    else\n-\t\t      z = gen_lowpart (GET_MODE (x), z);\n-\n-\t\t    *loc = z;\n-\t\t    return true;\n-\t\t  }\n-\n-\t      /* When we are processing the REG_NOTES of the last instruction\n-\t\t of a libcall, there will be typically no replacements\n-\t\t for that insn; the replacements happened before, piecemeal\n-\t\t fashion.  OTOH we are not interested in the details of\n-\t\t this for the REG_EQUAL note, we want to know the big picture,\n-\t\t which can be succinctly described with a simple SUBREG.\n-\t\t Note that removing the REG_EQUAL note is not an option\n-\t\t on the last insn of a libcall, so we must do a replacement.  */\n-\n-\t      /* In compile/990107-1.c:7 compiled at -O1 -m1 for sh-elf,\n-\t\t we got\n-\t\t (mem:DI (addressof:SI (reg/v:DF 160) 159 0x401c8510)\n-\t\t [0 S8 A32]), which can be expressed with a simple\n-\t\t same-size subreg  */\n-\t      if ((GET_MODE_SIZE (GET_MODE (x))\n-\t\t   <= GET_MODE_SIZE (GET_MODE (sub)))\n-\t\t  /* Again, invalid pointer casts (as in\n-\t\t     compile/990203-1.c) can require paradoxical\n-\t\t     subregs.  */\n-\t\t  || (GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD\n-\t\t      && (GET_MODE_SIZE (GET_MODE (x))\n-\t\t\t  > GET_MODE_SIZE (GET_MODE (sub)))\n-\t\t      && libcall))\n-\t\t{\n-\t\t  *loc = gen_rtx_SUBREG (GET_MODE (x), sub, 0);\n-\t\t  return true;\n-\t\t}\n-\t      /* ??? Are there other cases we should handle?  */\n-\n-\t      /* Sometimes we may not be able to find the replacement.  For\n-\t\t example when the original insn was a MEM in a wider mode,\n-\t\t and the note is part of a sign extension of a narrowed\n-\t\t version of that MEM.  Gcc testcase compile/990829-1.c can\n-\t\t generate an example of this situation.  Rather than complain\n-\t\t we return false, which will prompt our caller to remove the\n-\t\t offending note.  */\n-\t      return false;\n-\t    }\n-\n-\t  size_x = GET_MODE_BITSIZE (GET_MODE (x));\n-\t  size_sub = GET_MODE_BITSIZE (GET_MODE (sub));\n-\n-\t  /* Do not frob unchanging MEMs.  If a later reference forces the\n-\t     pseudo to the stack, we can wind up with multiple writes to\n-\t     an unchanging memory, which is invalid.  */\n-\t  if (RTX_UNCHANGING_P (x) && size_x != size_sub)\n-\t    ;\n-\n-\t  /* Don't even consider working with paradoxical subregs,\n-\t     or the moral equivalent seen here.  */\n-\t  else if (size_x <= size_sub\n-\t           && int_mode_for_mode (GET_MODE (sub)) != BLKmode)\n-\t    {\n-\t      /* Do a bitfield insertion to mirror what would happen\n-\t\t in memory.  */\n-\n-\t      rtx val, seq;\n-\n-\t      if (store)\n-\t\t{\n-\t\t  rtx p = PREV_INSN (insn);\n-\n-\t\t  start_sequence ();\n-\t\t  val = gen_reg_rtx (GET_MODE (x));\n-\t\t  if (! validate_change (insn, loc, val, 0))\n-\t\t    {\n-\t\t      /* Discard the current sequence and put the\n-\t\t\t ADDRESSOF on stack.  */\n-\t\t      end_sequence ();\n-\t\t      goto give_up;\n-\t\t    }\n-\t\t  seq = get_insns ();\n-\t\t  end_sequence ();\n-\t\t  emit_insn_before (seq, insn);\n-\t\t  compute_insns_for_mem (p ? NEXT_INSN (p) : get_insns (),\n-\t\t\t\t\t insn, ht);\n-\n-\t\t  start_sequence ();\n-\t\t  store_bit_field (sub, size_x, 0, GET_MODE (x),\n-\t\t\t\t   val, GET_MODE_SIZE (GET_MODE (sub)));\n-\n-\t\t  /* Make sure to unshare any shared rtl that store_bit_field\n-\t\t     might have created.  */\n-\t\t  unshare_all_rtl_again (get_insns ());\n-\n-\t\t  seq = get_insns ();\n-\t\t  end_sequence ();\n-\t\t  p = emit_insn_after (seq, insn);\n-\t\t  if (NEXT_INSN (insn))\n-\t\t    compute_insns_for_mem (NEXT_INSN (insn),\n-\t\t\t\t\t   p ? NEXT_INSN (p) : NULL_RTX,\n-\t\t\t\t\t   ht);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  rtx p = PREV_INSN (insn);\n-\n-\t\t  start_sequence ();\n-\t\t  val = extract_bit_field (sub, size_x, 0, 1, NULL_RTX,\n-\t\t\t\t\t   GET_MODE (x), GET_MODE (x),\n-\t\t\t\t\t   GET_MODE_SIZE (GET_MODE (sub)));\n-\n-\t\t  if (! validate_change (insn, loc, val, 0))\n-\t\t    {\n-\t\t      /* Discard the current sequence and put the\n-\t\t\t ADDRESSOF on stack.  */\n-\t\t      end_sequence ();\n-\t\t      goto give_up;\n-\t\t    }\n+      return;\n+    }\n \n-\t\t  seq = get_insns ();\n-\t\t  end_sequence ();\n-\t\t  emit_insn_before (seq, insn);\n-\t\t  compute_insns_for_mem (p ? NEXT_INSN (p) : get_insns (),\n-\t\t\t\t\t insn, ht);\n-\t\t}\n+  /* If X is a register that is being used as a pointer, see if we have\n+     a temporary slot we know it points to.  To be consistent with\n+     the code below, we really should preserve all non-kept slots\n+     if we can't find a match, but that seems to be much too costly.  */\n+  if (REG_P (x) && REG_POINTER (x))\n+    p = find_temp_slot_from_address (x);\n \n-\t      /* Remember the replacement so that the same one can be done\n-\t\t on the REG_NOTES.  */\n-\t      purge_bitfield_addressof_replacements\n-\t\t= gen_rtx_EXPR_LIST (VOIDmode, x,\n-\t\t\t\t     gen_rtx_EXPR_LIST\n-\t\t\t\t     (VOIDmode, val,\n-\t\t\t\t      purge_bitfield_addressof_replacements));\n+  /* If X is not in memory or is at a constant address, it cannot be in\n+     a temporary slot, but it can contain something whose address was\n+     taken.  */\n+  if (p == 0 && (!MEM_P (x) || CONSTANT_P (XEXP (x, 0))))\n+    {\n+      for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n+\t{\n+\t  next = p->next;\n \n-\t      /* We replaced with a reg -- all done.  */\n-\t      return true;\n-\t    }\n+\t  if (p->addr_taken)\n+\t    move_slot_to_level (p, temp_slot_level - 1);\n \t}\n \n-      else if (validate_change (insn, loc, sub, 0))\n+      return;\n+    }\n+\n+  /* First see if we can find a match.  */\n+  if (p == 0)\n+    p = find_temp_slot_from_address (XEXP (x, 0));\n+\n+  if (p != 0)\n+    {\n+      /* Move everything at our level whose address was taken to our new\n+\t level in case we used its address.  */\n+      struct temp_slot *q;\n+\n+      if (p->level == temp_slot_level)\n \t{\n-\t  /* Remember the replacement so that the same one can be done\n-\t     on the REG_NOTES.  */\n-\t  if (REG_P (sub) || GET_CODE (sub) == SUBREG)\n+\t  for (q = *temp_slots_at_level (temp_slot_level); q; q = next)\n \t    {\n-\t      rtx tem;\n+\t      next = q->next;\n \n-\t      for (tem = purge_addressof_replacements;\n-\t\t   tem != NULL_RTX;\n-\t\t   tem = XEXP (XEXP (tem, 1), 1))\n-\t\tif (rtx_equal_p (XEXP (x, 0), XEXP (tem, 0)))\n-\t\t  {\n-\t\t    XEXP (XEXP (tem, 1), 0) = sub;\n-\t\t    return true;\n-\t\t  }\n-\t      purge_addressof_replacements\n-\t\t= gen_rtx_EXPR_LIST (VOIDmode, XEXP (x, 0),\n-\t\t\t\t     gen_rtx_EXPR_LIST (VOIDmode, sub,\n-\t\t\t\t\t\t\tpurge_addressof_replacements));\n-\t      return true;\n+\t      if (p != q && q->addr_taken)\n+\t\tmove_slot_to_level (q, temp_slot_level - 1);\n \t    }\n-\t  goto restart;\n+\n+\t  move_slot_to_level (p, temp_slot_level - 1);\n+\t  p->addr_taken = 0;\n \t}\n+      return;\n     }\n \n- give_up:\n-  /* Scan all subexpressions.  */\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n+  /* Otherwise, preserve all non-kept slots at this level.  */\n+  for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n     {\n-      if (*fmt == 'e')\n-\tresult &= purge_addressof_1 (&XEXP (x, i), insn, force, 0,\n-\t\t\t\t     may_postpone, ht);\n-      else if (*fmt == 'E')\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  result &= purge_addressof_1 (&XVECEXP (x, i, j), insn, force, 0,\n-\t\t\t\t       may_postpone, ht);\n-    }\n-\n-  return result;\n-}\n-\n-/* Return a hash value for K, a REG.  */\n+      next = p->next;\n \n-static hashval_t\n-insns_for_mem_hash (const void *k)\n-{\n-  /* Use the address of the key for the hash value.  */\n-  struct insns_for_mem_entry *m = (struct insns_for_mem_entry *) k;\n-  return htab_hash_pointer (m->key);\n+      if (!p->keep)\n+\tmove_slot_to_level (p, temp_slot_level - 1);\n+    }\n }\n \n-/* Return nonzero if K1 and K2 (two REGs) are the same.  */\n+/* Free all temporaries used so far.  This is normally called at the\n+   end of generating code for a statement.  */\n \n-static int\n-insns_for_mem_comp (const void *k1, const void *k2)\n+void\n+free_temp_slots (void)\n {\n-  struct insns_for_mem_entry *m1 = (struct insns_for_mem_entry *) k1;\n-  struct insns_for_mem_entry *m2 = (struct insns_for_mem_entry *) k2;\n-  return m1->key == m2->key;\n-}\n+  struct temp_slot *p, *next;\n \n-struct insns_for_mem_walk_info\n-{\n-  /* The hash table that we are using to record which INSNs use which\n-     MEMs.  */\n-  htab_t ht;\n+  for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n+    {\n+      next = p->next;\n \n-  /* The INSN we are currently processing.  */\n-  rtx insn;\n+      if (!p->keep)\n+\tmake_slot_available (p);\n+    }\n \n-  /* Zero if we are walking to find ADDRESSOFs, one if we are walking\n-     to find the insns that use the REGs in the ADDRESSOFs.  */\n-  int pass;\n-};\n+  combine_temp_slots ();\n+}\n \n-/* Called from compute_insns_for_mem via for_each_rtx.  If R is a REG\n-   that might be used in an ADDRESSOF expression, record this INSN in\n-   the hash table given by DATA (which is really a pointer to an\n-   insns_for_mem_walk_info structure).  */\n+/* Push deeper into the nesting level for stack temporaries.  */\n \n-static int\n-insns_for_mem_walk (rtx *r, void *data)\n+void\n+push_temp_slots (void)\n {\n-  struct insns_for_mem_walk_info *ifmwi\n-    = (struct insns_for_mem_walk_info *) data;\n-  struct insns_for_mem_entry tmp;\n-  tmp.insns = NULL_RTX;\n-\n-  if (ifmwi->pass == 0 && *r && GET_CODE (*r) == ADDRESSOF\n-      && REG_P (XEXP (*r, 0)))\n-    {\n-      void **e;\n-      tmp.key = XEXP (*r, 0);\n-      e = htab_find_slot (ifmwi->ht, &tmp, INSERT);\n-      if (*e == NULL)\n-\t{\n-\t  *e = ggc_alloc (sizeof (tmp));\n-\t  memcpy (*e, &tmp, sizeof (tmp));\n-\t}\n-    }\n-  else if (ifmwi->pass == 1 && *r && REG_P (*r))\n-    {\n-      struct insns_for_mem_entry *ifme;\n-      tmp.key = *r;\n-      ifme = htab_find (ifmwi->ht, &tmp);\n-\n-      /* If we have not already recorded this INSN, do so now.  Since\n-\t we process the INSNs in order, we know that if we have\n-\t recorded it it must be at the front of the list.  */\n-      if (ifme && (!ifme->insns || XEXP (ifme->insns, 0) != ifmwi->insn))\n-\tifme->insns = gen_rtx_EXPR_LIST (VOIDmode, ifmwi->insn,\n-\t\t\t\t\t ifme->insns);\n-    }\n-\n-  return 0;\n+  temp_slot_level++;\n }\n \n-/* Walk the INSNS, until we reach LAST_INSN, recording which INSNs use\n-   which REGs in HT.  */\n+/* Pop a temporary nesting level.  All slots in use in the current level\n+   are freed.  */\n \n-static void\n-compute_insns_for_mem (rtx insns, rtx last_insn, htab_t ht)\n+void\n+pop_temp_slots (void)\n {\n-  rtx insn;\n-  struct insns_for_mem_walk_info ifmwi;\n-  ifmwi.ht = ht;\n+  struct temp_slot *p, *next;\n \n-  for (ifmwi.pass = 0; ifmwi.pass < 2; ++ifmwi.pass)\n-    for (insn = insns; insn != last_insn; insn = NEXT_INSN (insn))\n-      if (INSN_P (insn))\n-\t{\n-\t  ifmwi.insn = insn;\n-\t  for_each_rtx (&insn, insns_for_mem_walk, &ifmwi);\n-\t}\n-}\n+  for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n+    {\n+      next = p->next;\n+      make_slot_available (p);\n+    }\n \n-/* Helper function for purge_addressof called through for_each_rtx.\n-   Returns true iff the rtl is an ADDRESSOF.  */\n+  combine_temp_slots ();\n \n-static int\n-is_addressof (rtx *rtl, void *data ATTRIBUTE_UNUSED)\n-{\n-  return GET_CODE (*rtl) == ADDRESSOF;\n+  temp_slot_level--;\n }\n \n-/* Eliminate all occurrences of ADDRESSOF from INSNS.  Elide any remaining\n-   (MEM (ADDRESSOF)) patterns, and force any needed registers into the\n-   stack.  */\n+/* Initialize temporary slots.  */\n \n void\n-purge_addressof (rtx insns)\n+init_temp_slots (void)\n {\n-  rtx insn, tmp;\n-  htab_t ht;\n+  /* We have not allocated any temporaries yet.  */\n+  avail_temp_slots = 0;\n+  used_temp_slots = 0;\n+  temp_slot_level = 0;\n+  var_temp_slot_level = 0;\n+  target_temp_slot_level = 0;\n+}\n+\f\n+/* These routines are responsible for converting virtual register references\n+   to the actual hard register references once RTL generation is complete.\n \n-  /* When we actually purge ADDRESSOFs, we turn REGs into MEMs.  That\n-     requires a fixup pass over the instruction stream to correct\n-     INSNs that depended on the REG being a REG, and not a MEM.  But,\n-     these fixup passes are slow.  Furthermore, most MEMs are not\n-     mentioned in very many instructions.  So, we speed up the process\n-     by pre-calculating which REGs occur in which INSNs; that allows\n-     us to perform the fixup passes much more quickly.  */\n-  ht = htab_create_ggc (1000, insns_for_mem_hash, insns_for_mem_comp, NULL);\n-  compute_insns_for_mem (insns, NULL_RTX, ht);\n+   The following four variables are used for communication between the\n+   routines.  They contain the offsets of the virtual registers from their\n+   respective hard registers.  */\n \n-  postponed_insns = NULL;\n+static int in_arg_offset;\n+static int var_offset;\n+static int dynamic_offset;\n+static int out_arg_offset;\n+static int cfa_offset;\n \n-  for (insn = insns; insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn))\n-      {\n-\tif (! purge_addressof_1 (&PATTERN (insn), insn,\n-\t\t\t\t asm_noperands (PATTERN (insn)) > 0, 0, 1, ht))\n-\t  /* If we could not replace the ADDRESSOFs in the insn,\n-\t     something is wrong.  */\n-\t  abort ();\n+/* In most machines, the stack pointer register is equivalent to the bottom\n+   of the stack.  */\n \n-\tif (! purge_addressof_1 (&REG_NOTES (insn), NULL_RTX, 0, 0, 0, ht))\n-\t  {\n-\t    /* If we could not replace the ADDRESSOFs in the insn's notes,\n-\t       we can just remove the offending notes instead.  */\n-\t    rtx note;\n+#ifndef STACK_POINTER_OFFSET\n+#define STACK_POINTER_OFFSET\t0\n+#endif\n \n-\t    for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-\t      {\n-\t\t/* If we find a REG_RETVAL note then the insn is a libcall.\n-\t\t   Such insns must have REG_EQUAL notes as well, in order\n-\t\t   for later passes of the compiler to work.  So it is not\n-\t\t   safe to delete the notes here, and instead we abort.  */\n-\t\tif (REG_NOTE_KIND (note) == REG_RETVAL)\n-\t\t  abort ();\n-\t\tif (for_each_rtx (&note, is_addressof, NULL))\n-\t\t  remove_note (insn, note);\n-\t      }\n-\t  }\n-      }\n+/* If not defined, pick an appropriate default for the offset of dynamically\n+   allocated memory depending on the value of ACCUMULATE_OUTGOING_ARGS,\n+   REG_PARM_STACK_SPACE, and OUTGOING_REG_PARM_STACK_SPACE.  */\n \n-  /* Process the postponed insns.  */\n-  while (postponed_insns)\n-    {\n-      insn = XEXP (postponed_insns, 0);\n-      tmp = postponed_insns;\n-      postponed_insns = XEXP (postponed_insns, 1);\n-      free_INSN_LIST_node (tmp);\n+#ifndef STACK_DYNAMIC_OFFSET\n \n-      if (! purge_addressof_1 (&PATTERN (insn), insn,\n-\t\t\t       asm_noperands (PATTERN (insn)) > 0, 0, 0, ht))\n-\tabort ();\n-    }\n+/* The bottom of the stack points to the actual arguments.  If\n+   REG_PARM_STACK_SPACE is defined, this includes the space for the register\n+   parameters.  However, if OUTGOING_REG_PARM_STACK space is not defined,\n+   stack space for register parameters is not pushed by the caller, but\n+   rather part of the fixed stack areas and hence not included in\n+   `current_function_outgoing_args_size'.  Nevertheless, we must allow\n+   for it when allocating stack dynamic objects.  */\n \n-  /* Clean up.  */\n-  purge_bitfield_addressof_replacements = 0;\n-  purge_addressof_replacements = 0;\n+#if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n+#define STACK_DYNAMIC_OFFSET(FNDECL)\t\\\n+((ACCUMULATE_OUTGOING_ARGS\t\t\t\t\t\t      \\\n+  ? (current_function_outgoing_args_size + REG_PARM_STACK_SPACE (FNDECL)) : 0)\\\n+ + (STACK_POINTER_OFFSET))\t\t\t\t\t\t      \\\n \n-  /* REGs are shared.  purge_addressof will destructively replace a REG\n-     with a MEM, which creates shared MEMs.\n+#else\n+#define STACK_DYNAMIC_OFFSET(FNDECL)\t\\\n+((ACCUMULATE_OUTGOING_ARGS ? current_function_outgoing_args_size : 0)\t      \\\n+ + (STACK_POINTER_OFFSET))\n+#endif\n+#endif\n \n-     Unfortunately, the children of put_reg_into_stack assume that MEMs\n-     referring to the same stack slot are shared (fixup_var_refs and\n-     the associated hash table code).\n+/* On most machines, the CFA coincides with the first incoming parm.  */\n \n-     So, we have to do another unsharing pass after we have flushed any\n-     REGs that had their address taken into the stack.\n+#ifndef ARG_POINTER_CFA_OFFSET\n+#define ARG_POINTER_CFA_OFFSET(FNDECL) FIRST_PARM_OFFSET (FNDECL)\n+#endif\n \n-     It may be worth tracking whether or not we converted any REGs into\n-     MEMs to avoid this overhead when it is not needed.  */\n-  unshare_all_rtl_again (get_insns ());\n-}\n \f\n /* Convert a SET of a hard subreg to a set of the appropriate hard\n    register.  A subroutine of purge_hard_subreg_sets.  */\n@@ -3509,7 +1339,6 @@ void\n instantiate_virtual_regs (void)\n {\n   rtx insn;\n-  unsigned int i;\n \n   /* Compute the offsets to use for this function.  */\n   in_arg_offset = FIRST_PARM_OFFSET (current_function_decl);\n@@ -3549,12 +1378,6 @@ instantiate_virtual_regs (void)\n           instantiate_virtual_regs_lossage (insn);\n       }\n \n-  /* Instantiate the stack slots for the parm registers, for later use in\n-     addressof elimination.  */\n-  for (i = 0; i < max_parm_reg; ++i)\n-    if (parm_reg_stack_loc[i])\n-      instantiate_virtual_regs_1 (&parm_reg_stack_loc[i], NULL_RTX, 0);\n-\n   /* Now instantiate the remaining register equivalences for debugging info.\n      These will not be valid addresses.  */\n   instantiate_decls (current_function_decl, 0);\n@@ -3634,7 +1457,6 @@ instantiate_decl (rtx x, HOST_WIDE_INT size, int valid_only)\n \n   addr = XEXP (x, 0);\n   if (CONSTANT_P (addr)\n-      || (GET_CODE (addr) == ADDRESSOF && REG_P (XEXP (addr, 0)))\n       || (REG_P (addr)\n \t  && (REGNO (addr) < FIRST_VIRTUAL_REGISTER\n \t      || REGNO (addr) > LAST_VIRTUAL_REGISTER)))\n@@ -4088,20 +1910,6 @@ instantiate_virtual_regs_1 (rtx *loc, rtx object, int extra_insns)\n \n       return 1;\n \n-    case ADDRESSOF:\n-      if (REG_P (XEXP (x, 0)))\n-\treturn 1;\n-\n-      else if (MEM_P (XEXP (x, 0)))\n-\t{\n-\t  /* If we have a (addressof (mem ..)), do any instantiation inside\n-\t     since we know we'll be making the inside valid when we finally\n-\t     remove the ADDRESSOF.  */\n-\t  instantiate_virtual_regs_1 (&XEXP (XEXP (x, 0), 0), NULL_RTX, 0);\n-\t  return 1;\n-\t}\n-      break;\n-\n     default:\n       break;\n     }\n@@ -4184,6 +1992,46 @@ aggregate_value_p (tree exp, tree fntype)\n   return 0;\n }\n \f\n+/* Return true if we should assign DECL a pseudo register; false if it\n+   should live on the local stack.  */\n+\n+bool\n+use_register_for_decl (tree decl)\n+{\n+  /* Honor volatile.  */\n+  if (TREE_SIDE_EFFECTS (decl))\n+    return false;\n+\n+  /* Honor addressability.  */\n+  if (TREE_ADDRESSABLE (decl))\n+    return false;\n+\n+  /* Only register-like things go in registers.  */\n+  if (DECL_MODE (decl) == BLKmode)\n+    return false;\n+\n+  /* If -ffloat-store specified, don't put explicit float variables\n+     into registers.  */\n+  /* ??? This should be checked after DECL_ARTIFICIAL, but tree-ssa\n+     propagates values across these stores, and it probably shouldn't.  */\n+  if (flag_float_store && FLOAT_TYPE_P (TREE_TYPE (decl)))\n+    return false;\n+\n+  /* Compiler-generated temporaries can always go in registers.  */\n+  if (DECL_ARTIFICIAL (decl))\n+    return true;\n+\n+#ifdef NON_SAVING_SETJMP\n+  /* Protect variables not declared \"register\" from setjmp.  */\n+  if (NON_SAVING_SETJMP\n+      && current_function_calls_setjmp\n+      && !DECL_REGISTER (decl))\n+    return false;\n+#endif\n+\n+  return (optimize || DECL_REGISTER (decl));\n+}\n+\n /* Assign RTL expressions to the function's parameters.\n    This may involve copying them into registers and using\n    those registers as the RTL for them.  */\n@@ -4247,9 +2095,6 @@ assign_parms (tree fndecl)\n \n   orig_fnargs = fnargs;\n \n-  max_parm_reg = LAST_VIRTUAL_REGISTER + 1;\n-  parm_reg_stack_loc = ggc_alloc_cleared (max_parm_reg * sizeof (rtx));\n-\n   /* If the target wants to split complex arguments into scalars, do so.  */\n   if (targetm.calls.split_complex_arg)\n     fnargs = split_complex_args (fnargs);\n@@ -4653,7 +2498,8 @@ assign_parms (tree fndecl)\n \n \t Set DECL_RTL to that place.  */\n \n-      if (GET_CODE (entry_parm) == PARALLEL && nominal_mode != BLKmode\n+      if (GET_CODE (entry_parm) == PARALLEL\n+\t  && nominal_mode != BLKmode\n \t  && XVECLEN (entry_parm, 0) > 1)\n \t{\n \t  /* Reconstitute objects the size of a register or larger using\n@@ -4662,29 +2508,10 @@ assign_parms (tree fndecl)\n \n \t  if (REG_P (parmreg))\n \t    {\n-\t      unsigned int regno = REGNO (parmreg);\n-\n \t      emit_group_store (parmreg, entry_parm, TREE_TYPE (parm),\n \t\t\t\tint_size_in_bytes (TREE_TYPE (parm)));\n \t      SET_DECL_RTL (parm, parmreg);\n \t      loaded_in_reg = 1;\n-\n-\t      if (regno >= max_parm_reg)\n-\t\t{\n-\t\t  rtx *new;\n-\t\t  int old_max_parm_reg = max_parm_reg;\n-\n-\t\t  /* It's slow to expand this one register at a time,\n-\t\t     but it's also rare and we need max_parm_reg to be\n-\t\t     precisely correct.  */\n-\t\t  max_parm_reg = regno + 1;\n-\t\t  new = ggc_realloc (parm_reg_stack_loc,\n-\t\t\t\t     max_parm_reg * sizeof (rtx));\n-\t\t  memset (new + old_max_parm_reg, 0,\n-\t\t\t  (max_parm_reg - old_max_parm_reg) * sizeof (rtx));\n-\t\t  parm_reg_stack_loc = new;\n-\t\t  parm_reg_stack_loc[regno] = stack_parm;\n-\t\t}\n \t    }\n \t}\n \n@@ -4790,13 +2617,7 @@ assign_parms (tree fndecl)\n \t  if (! DECL_RTL_SET_P (parm))\n \t    SET_DECL_RTL (parm, stack_parm);\n \t}\n-      else if (! ((! optimize\n-\t\t   && ! DECL_REGISTER (parm))\n-\t\t  || TREE_SIDE_EFFECTS (parm)\n-\t\t  /* If -ffloat-store specified, don't put explicit\n-\t\t     float variables into registers.  */\n-\t\t  || (flag_float_store\n-\t\t      && TREE_CODE (TREE_TYPE (parm)) == REAL_TYPE))\n+      else if (use_register_for_decl (parm)\n \t       /* Always assign pseudo to structure return or item passed\n \t\t  by invisible reference.  */\n \t       || passed_pointer || parm == function_result_decl)\n@@ -4805,7 +2626,6 @@ assign_parms (tree fndecl)\n \t     may need to do it in a wider mode.  */\n \n \t  rtx parmreg;\n-\t  unsigned int regno, regnoi = 0, regnor = 0;\n \n \t  unsignedp = TYPE_UNSIGNED (TREE_TYPE (parm));\n \n@@ -4889,16 +2709,10 @@ assign_parms (tree fndecl)\n \n \t  /* If we were passed a pointer but the actual value\n \t     can safely live in a register, put it in one.  */\n-\t  if (passed_pointer && TYPE_MODE (TREE_TYPE (parm)) != BLKmode\n+\t  if (passed_pointer\n+\t      && use_register_for_decl (parm)\n \t      /* If by-reference argument was promoted, demote it.  */\n-\t      && (TYPE_MODE (TREE_TYPE (parm)) != GET_MODE (DECL_RTL (parm))\n-\t\t  || ! ((! optimize\n-\t\t\t && ! DECL_REGISTER (parm))\n-\t\t\t|| TREE_SIDE_EFFECTS (parm)\n-\t\t\t/* If -ffloat-store specified, don't put explicit\n-\t\t\t   float variables into registers.  */\n-\t\t\t|| (flag_float_store\n-\t\t\t    && TREE_CODE (TREE_TYPE (parm)) == REAL_TYPE))))\n+\t      && TYPE_MODE (TREE_TYPE (parm)) != GET_MODE (DECL_RTL (parm)))\n \t    {\n \t      /* We can't use nominal_mode, because it will have been set to\n \t\t Pmode above.  We must use the actual mode of the parm.  */\n@@ -4970,56 +2784,6 @@ assign_parms (tree fndecl)\n \t    }\n #endif /* FUNCTION_ARG_CALLEE_COPIES */\n \n-\t  /* In any case, record the parm's desired stack location\n-\t     in case we later discover it must live in the stack.\n-\n-\t     If it is a COMPLEX value, store the stack location for both\n-\t     halves.  */\n-\n-\t  if (GET_CODE (parmreg) == CONCAT)\n-\t    regno = MAX (REGNO (XEXP (parmreg, 0)), REGNO (XEXP (parmreg, 1)));\n-\t  else\n-\t    regno = REGNO (parmreg);\n-\n-\t  if (regno >= max_parm_reg)\n-\t    {\n-\t      rtx *new;\n-\t      int old_max_parm_reg = max_parm_reg;\n-\n-\t      /* It's slow to expand this one register at a time,\n-\t\t but it's also rare and we need max_parm_reg to be\n-\t\t precisely correct.  */\n-\t      max_parm_reg = regno + 1;\n-\t      new = ggc_realloc (parm_reg_stack_loc,\n-\t\t\t\t max_parm_reg * sizeof (rtx));\n-\t      memset (new + old_max_parm_reg, 0,\n-\t\t      (max_parm_reg - old_max_parm_reg) * sizeof (rtx));\n-\t      parm_reg_stack_loc = new;\n-\t    }\n-\n-\t  if (GET_CODE (parmreg) == CONCAT)\n-\t    {\n-\t      enum machine_mode submode = GET_MODE (XEXP (parmreg, 0));\n-\n-\t      regnor = REGNO (gen_realpart (submode, parmreg));\n-\t      regnoi = REGNO (gen_imagpart (submode, parmreg));\n-\n-\t      if (stack_parm != 0)\n-\t\t{\n-\t\t  parm_reg_stack_loc[regnor]\n-\t\t    = gen_realpart (submode, stack_parm);\n-\t\t  parm_reg_stack_loc[regnoi]\n-\t\t    = gen_imagpart (submode, stack_parm);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  parm_reg_stack_loc[regnor] = 0;\n-\t\t  parm_reg_stack_loc[regnoi] = 0;\n-\t\t}\n-\t    }\n-\t  else\n-\t    parm_reg_stack_loc[REGNO (parmreg)] = stack_parm;\n-\n \t  /* Mark the register as eliminable if we did no conversion\n \t     and it was copied from memory at a fixed offset,\n \t     and the arg pointer was not copied to a pseudo-reg.\n@@ -5039,25 +2803,33 @@ assign_parms (tree fndecl)\n \n \t      /* Mark complex types separately.  */\n \t      if (GET_CODE (parmreg) == CONCAT)\n-\t\t/* Scan backwards for the set of the real and\n-\t\t   imaginary parts.  */\n-\t\tfor (sinsn = linsn; sinsn != 0;\n-\t\t     sinsn = prev_nonnote_insn (sinsn))\n-\t\t  {\n-\t\t    set = single_set (sinsn);\n-\t\t    if (set != 0\n-\t\t\t&& SET_DEST (set) == regno_reg_rtx [regnoi])\n-\t\t      REG_NOTES (sinsn)\n-\t\t\t= gen_rtx_EXPR_LIST (REG_EQUIV,\n-\t\t\t\t\t     parm_reg_stack_loc[regnoi],\n-\t\t\t\t\t     REG_NOTES (sinsn));\n-\t\t    else if (set != 0\n-\t\t\t     && SET_DEST (set) == regno_reg_rtx [regnor])\n-\t\t      REG_NOTES (sinsn)\n-\t\t\t= gen_rtx_EXPR_LIST (REG_EQUIV,\n-\t\t\t\t\t     parm_reg_stack_loc[regnor],\n-\t\t\t\t\t     REG_NOTES (sinsn));\n-\t\t  }\n+\t\t{\n+\t\t  enum machine_mode submode\n+\t\t    = GET_MODE_INNER (GET_MODE (parmreg));\n+\t          int regnor = REGNO (gen_realpart (submode, parmreg));\n+\t          int regnoi = REGNO (gen_imagpart (submode, parmreg));\n+\t\t  rtx stackr = gen_realpart (submode, stack_parm);\n+\t\t  rtx stacki = gen_imagpart (submode, stack_parm);\n+\n+\t\t  /* Scan backwards for the set of the real and\n+\t\t     imaginary parts.  */\n+\t\t  for (sinsn = linsn; sinsn != 0;\n+\t\t       sinsn = prev_nonnote_insn (sinsn))\n+\t\t    {\n+\t\t      set = single_set (sinsn);\n+\t\t      if (set == 0)\n+\t\t\tcontinue;\n+\n+\t\t      if (SET_DEST (set) == regno_reg_rtx [regnoi])\n+\t\t        REG_NOTES (sinsn)\n+\t\t\t  = gen_rtx_EXPR_LIST (REG_EQUIV, stacki,\n+\t\t\t\t\t       REG_NOTES (sinsn));\n+\t\t      else if (SET_DEST (set) == regno_reg_rtx [regnor])\n+\t\t        REG_NOTES (sinsn)\n+\t\t\t  = gen_rtx_EXPR_LIST (REG_EQUIV, stackr,\n+\t\t\t\t\t       REG_NOTES (sinsn));\n+\t\t    }\n+\t\t}\n \t      else if ((set = single_set (linsn)) != 0\n \t\t       && SET_DEST (set) == parmreg)\n \t\tREG_NOTES (linsn)\n@@ -5069,22 +2841,6 @@ assign_parms (tree fndecl)\n \t  if (POINTER_TYPE_P (TREE_TYPE (parm)))\n \t    mark_reg_pointer (parmreg,\n \t\t\t      TYPE_ALIGN (TREE_TYPE (TREE_TYPE (parm))));\n-\n-\t  /* If something wants our address, try to use ADDRESSOF.  */\n-\t  if (TREE_ADDRESSABLE (parm))\n-\t    {\n-\t      /* If we end up putting something into the stack,\n-\t\t fixup_var_refs_insns will need to make a pass over\n-\t\t all the instructions.  It looks through the pending\n-\t\t sequences -- but it can't see the ones in the\n-\t\t CONVERSION_INSNS, if they're not on the sequence\n-\t\t stack.  So, we go back to that sequence, just so that\n-\t\t the fixups will happen.  */\n-\t      push_to_sequence (conversion_insns);\n-\t      put_var_into_stack (parm, /*rescan=*/true);\n-\t      conversion_insns = get_insns ();\n-\t      end_sequence ();\n-\t    }\n \t}\n       else\n \t{\n@@ -5648,63 +3404,6 @@ setjmp_args_warning (void)\n \t       decl, decl);\n }\n \n-/* If this function call setjmp, put all vars into the stack\n-   unless they were declared `register'.  */\n-\n-void\n-setjmp_protect (tree block)\n-{\n-  tree decl, sub;\n-  for (decl = BLOCK_VARS (block); decl; decl = TREE_CHAIN (decl))\n-    if ((TREE_CODE (decl) == VAR_DECL\n-\t || TREE_CODE (decl) == PARM_DECL)\n-\t&& DECL_RTL (decl) != 0\n-\t&& (REG_P (DECL_RTL (decl))\n-\t    || (MEM_P (DECL_RTL (decl))\n-\t\t&& GET_CODE (XEXP (DECL_RTL (decl), 0)) == ADDRESSOF))\n-\t/* If this variable came from an inline function, it must be\n-\t   that its life doesn't overlap the setjmp.  If there was a\n-\t   setjmp in the function, it would already be in memory.  We\n-\t   must exclude such variable because their DECL_RTL might be\n-\t   set to strange things such as virtual_stack_vars_rtx.  */\n-\t&& ! DECL_FROM_INLINE (decl)\n-\t&& (\n-#ifdef NON_SAVING_SETJMP\n-\t    /* If longjmp doesn't restore the registers,\n-\t       don't put anything in them.  */\n-\t    NON_SAVING_SETJMP\n-\t    ||\n-#endif\n-\t    ! DECL_REGISTER (decl)))\n-      put_var_into_stack (decl, /*rescan=*/true);\n-  for (sub = BLOCK_SUBBLOCKS (block); sub; sub = TREE_CHAIN (sub))\n-    setjmp_protect (sub);\n-}\n-\f\n-/* Like the previous function, but for args instead of local variables.  */\n-\n-void\n-setjmp_protect_args (void)\n-{\n-  tree decl;\n-  for (decl = DECL_ARGUMENTS (current_function_decl);\n-       decl; decl = TREE_CHAIN (decl))\n-    if ((TREE_CODE (decl) == VAR_DECL\n-\t || TREE_CODE (decl) == PARM_DECL)\n-\t&& DECL_RTL (decl) != 0\n-\t&& (REG_P (DECL_RTL (decl))\n-\t    || (MEM_P (DECL_RTL (decl))\n-\t\t&& GET_CODE (XEXP (DECL_RTL (decl), 0)) == ADDRESSOF))\n-\t&& (\n-\t    /* If longjmp doesn't restore the registers,\n-\t       don't put anything in them.  */\n-#ifdef NON_SAVING_SETJMP\n-\t    NON_SAVING_SETJMP\n-\t    ||\n-#endif\n-\t    ! DECL_REGISTER (decl)))\n-      put_var_into_stack (decl, /*rescan=*/true);\n-}\n \f\n /* Convert a stack slot address ADDR for variable VAR\n    (from a containing function)\n@@ -5725,9 +3424,6 @@ fix_lexical_addr (rtx addr, tree var)\n \n   fp = find_function_data (context);\n \n-  if (GET_CODE (addr) == ADDRESSOF && MEM_P (XEXP (addr, 0)))\n-    addr = XEXP (XEXP (addr, 0), 0);\n-\n   /* Decode given address as base reg plus displacement.  */\n   if (REG_P (addr))\n     basereg = addr, displacement = 0;\n@@ -6027,8 +3723,6 @@ allocate_struct_function (tree fndecl)\n \n   cfun = ggc_alloc_cleared (sizeof (struct function));\n \n-  max_parm_reg = LAST_VIRTUAL_REGISTER + 1;\n-\n   cfun->stack_alignment_needed = STACK_BOUNDARY;\n   cfun->preferred_stack_boundary = STACK_BOUNDARY;\n \n@@ -6488,18 +4182,6 @@ expand_function_end (void)\n   if (arg_pointer_save_area && ! cfun->arg_pointer_save_area_init)\n     get_arg_pointer_save_area (cfun);\n \n-#ifdef NON_SAVING_SETJMP\n-  /* Don't put any variables in registers if we call setjmp\n-     on a machine that fails to restore the registers.  */\n-  if (NON_SAVING_SETJMP && current_function_calls_setjmp)\n-    {\n-      if (DECL_INITIAL (current_function_decl) != error_mark_node)\n-\tsetjmp_protect (DECL_INITIAL (current_function_decl));\n-\n-      setjmp_protect_args ();\n-    }\n-#endif\n-\n   /* If we are doing stack checking and this function makes calls,\n      do a stack probe at the start of the function to ensure we have enough\n      space for another stack frame.  */"}, {"sha": "a90a5009325bc3067dfc22e0c5922b62f10f5ac9", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -97,10 +97,7 @@ struct emit_status GTY(())\n     regno_pointer_align;\n \n   /* Indexed by pseudo register number, gives the rtx for that pseudo.\n-     Allocated in parallel with regno_pointer_align.\n-\n-     Note MEM expressions can appear in this array due to the actions\n-     of put_var_into_stack.  */\n+     Allocated in parallel with regno_pointer_align.  */\n   rtx * GTY ((length (\"%h.x_reg_rtx_no\"))) x_regno_reg_rtx;\n };\n \n@@ -273,16 +270,6 @@ struct function GTY(())\n   /* Insn after which register parms and SAVE_EXPRs are born, if nonopt.  */\n   rtx x_parm_birth_insn;\n \n-  /* 1 + last pseudo register number possibly used for loading a copy\n-     of a parameter of this function.  */\n-  unsigned int x_max_parm_reg;\n-\n-  /* Vector indexed by REGNO, containing location on stack in which\n-     to put the parm which is nominally in pseudo register REGNO,\n-     if we discover that that parm must go in the stack.  The highest\n-     element in this vector is one less than MAX_PARM_REG, above.  */\n-  rtx * GTY ((length (\"%h.x_max_parm_reg\"))) x_parm_reg_stack_loc;\n-\n   /* List of all used temporaries allocated, by level.  */\n   struct varray_head_tag * GTY((param_is (struct temp_slot))) x_used_temp_slots;\n \n@@ -498,8 +485,6 @@ extern int trampolines_created;\n #define current_function_has_nonlocal_label (cfun->has_nonlocal_label)\n #define current_function_has_nonlocal_goto (cfun->has_nonlocal_goto)\n \n-#define max_parm_reg (cfun->x_max_parm_reg)\n-#define parm_reg_stack_loc (cfun->x_parm_reg_stack_loc)\n #define return_label (cfun->x_return_label)\n #define naked_return_label (cfun->x_naked_return_label)\n #define stack_slot_list (cfun->x_stack_slot_list)"}, {"sha": "2694e839383d5c3f6de2a588d8088c6b89e7e14a", "filename": "gcc/genrecog.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -190,23 +190,23 @@ static const struct pred_table\n   const RTX_CODE codes[NUM_RTX_CODE];\n } preds[] = {\n   {\"general_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n-\t\t       LABEL_REF, SUBREG, REG, MEM, ADDRESSOF}},\n+\t\t       LABEL_REF, SUBREG, REG, MEM }},\n #ifdef PREDICATE_CODES\n   PREDICATE_CODES\n #endif\n   {\"address_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n-\t\t       LABEL_REF, SUBREG, REG, MEM, ADDRESSOF,\n+\t\t       LABEL_REF, SUBREG, REG, MEM,\n \t\t       PLUS, MINUS, MULT}},\n-  {\"register_operand\", {SUBREG, REG, ADDRESSOF}},\n-  {\"pmode_register_operand\", {SUBREG, REG, ADDRESSOF}},\n+  {\"register_operand\", {SUBREG, REG}},\n+  {\"pmode_register_operand\", {SUBREG, REG}},\n   {\"scratch_operand\", {SCRATCH, REG}},\n   {\"immediate_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n \t\t\t LABEL_REF}},\n   {\"const_int_operand\", {CONST_INT}},\n   {\"const_double_operand\", {CONST_INT, CONST_DOUBLE}},\n-  {\"nonimmediate_operand\", {SUBREG, REG, MEM, ADDRESSOF}},\n+  {\"nonimmediate_operand\", {SUBREG, REG, MEM}},\n   {\"nonmemory_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n-\t\t\t LABEL_REF, SUBREG, REG, ADDRESSOF}},\n+\t\t\t LABEL_REF, SUBREG, REG}},\n   {\"push_operand\", {MEM}},\n   {\"pop_operand\", {MEM}},\n   {\"memory_operand\", {SUBREG, MEM}},\n@@ -519,7 +519,6 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n \t\t    if (c != REG\n \t\t\t&& c != SUBREG\n \t\t\t&& c != MEM\n-\t\t\t&& c != ADDRESSOF\n \t\t\t&& c != CONCAT\n \t\t\t&& c != PARALLEL\n \t\t\t&& c != STRICT_LOW_PART)"}, {"sha": "03711d9baf09301ffe7f8442ea80ac201463c301", "filename": "gcc/integrate.c", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -364,41 +364,6 @@ copy_rtx_and_substitute (rtx orig, struct inline_remap *map, int for_lhs)\n \t\t\t\t  GET_MODE (SUBREG_REG (orig)),\n \t\t\t\t  SUBREG_BYTE (orig));\n \n-    case ADDRESSOF:\n-      copy = gen_rtx_ADDRESSOF (mode,\n-\t\t\t\tcopy_rtx_and_substitute (XEXP (orig, 0),\n-\t\t\t\t\t\t\t map, for_lhs),\n-\t\t\t\t0, ADDRESSOF_DECL (orig));\n-      regno = ADDRESSOF_REGNO (orig);\n-      if (map->reg_map[regno])\n-\tregno = REGNO (map->reg_map[regno]);\n-      else if (regno > LAST_VIRTUAL_REGISTER)\n-\t{\n-\t  temp = XEXP (orig, 0);\n-\t  map->reg_map[regno] = gen_reg_rtx (GET_MODE (temp));\n-\t  REG_USERVAR_P (map->reg_map[regno]) = REG_USERVAR_P (temp);\n-\t  REG_LOOP_TEST_P (map->reg_map[regno]) = REG_LOOP_TEST_P (temp);\n-\t  RTX_UNCHANGING_P (map->reg_map[regno]) = RTX_UNCHANGING_P (temp);\n-\t  /* A reg with REG_FUNCTION_VALUE_P true will never reach here.  */\n-\n-\t  /* Objects may initially be represented as registers, but\n-\t     but turned into a MEM if their address is taken by\n-\t     put_var_into_stack.  Therefore, the register table may have\n-\t     entries which are MEMs.\n-\n-\t     We briefly tried to clear such entries, but that ended up\n-\t     cascading into many changes due to the optimizers not being\n-\t     prepared for empty entries in the register table.  So we've\n-\t     decided to allow the MEMs in the register table for now.  */\n-\t  if (REG_P (map->x_regno_reg_rtx[regno])\n-\t      && REG_POINTER (map->x_regno_reg_rtx[regno]))\n-\t    mark_reg_pointer (map->reg_map[regno],\n-\t\t\t      map->regno_pointer_align[regno]);\n-\t  regno = REGNO (map->reg_map[regno]);\n-\t}\n-      ADDRESSOF_REGNO (copy) = regno;\n-      return copy;\n-\n     case USE:\n     case CLOBBER:\n       /* USE and CLOBBER are ordinary, but we convert (use (subreg foo))"}, {"sha": "822e4db8f8ddfd1b57c971ad25000625da3d0086", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -139,7 +139,6 @@ enum dump_file_index\n   DFI_jump,\n   DFI_null,\n   DFI_cse,\n-  DFI_addressof,\n   DFI_gcse,\n   DFI_loop,\n   DFI_bypass,\n@@ -181,7 +180,7 @@ enum dump_file_index\n    Remaining -d letters:\n \n \t\"   e            q         \"\n-\t\"          K   O Q     WXY \"\n+\t\"    F     K   O Q     WXY \"\n */\n \n static struct dump_file_info dump_file_tbl[DFI_MAX] =\n@@ -193,7 +192,6 @@ static struct dump_file_info dump_file_tbl[DFI_MAX] =\n   { \"jump\",\t'j', 0, 0, 0 },\n   { \"null\",\t'u', 0, 0, 0 },\n   { \"cse\",\t's', 0, 0, 0 },\n-  { \"addressof\", 'F', 0, 0, 0 },\n   { \"gcse\",\t'G', 1, 0, 0 },\n   { \"loop\",\t'L', 1, 0, 0 },\n   { \"bypass\",   'G', 1, 0, 0 }, /* Yes, duplicate enable switch.  */\n@@ -989,20 +987,6 @@ rest_of_handle_cfg (void)\n   close_dump_file (DFI_cfg, print_rtl_with_bb, get_insns ());\n }\n \n-/* Purge addressofs.  */\n-static void\n-rest_of_handle_addressof (void)\n-{\n-  open_dump_file (DFI_addressof, current_function_decl);\n-\n-  purge_addressof (get_insns ());\n-  if (optimize && purge_all_dead_edges (0))\n-    delete_unreachable_blocks ();\n-  reg_scan (get_insns (), max_reg_num (), 1);\n-\n-  close_dump_file (DFI_addressof, print_rtl, get_insns ());\n-}\n-\n /* Perform jump bypassing and control flow optimizations.  */\n static void\n rest_of_handle_jump_bypass (void)\n@@ -1543,8 +1527,6 @@ rest_of_compilation (void)\n   if (optimize > 0)\n     rest_of_handle_cse ();\n \n-  rest_of_handle_addressof ();\n-\n   ggc_collect ();\n \n   if (optimize > 0)"}, {"sha": "9220f4dc6b31c15c5b6b0426f3b8c5d66a216f02", "filename": "gcc/recog.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -978,19 +978,11 @@ general_operand (rtx op, enum machine_mode mode)\n       if (! volatile_ok && MEM_VOLATILE_P (op))\n \treturn 0;\n \n-      if (GET_CODE (y) == ADDRESSOF)\n-\treturn 1;\n-\n       /* Use the mem's mode, since it will be reloaded thus.  */\n       mode = GET_MODE (op);\n       GO_IF_LEGITIMATE_ADDRESS (mode, y, win);\n     }\n \n-  /* Pretend this is an operand for now; we'll run force_operand\n-     on its replacement in fixup_var_refs_1.  */\n-  if (code == ADDRESSOF)\n-    return 1;\n-\n   return 0;\n \n  win:\n@@ -1060,11 +1052,6 @@ register_operand (rtx op, enum machine_mode mode)\n       op = sub;\n     }\n \n-  /* If we have an ADDRESSOF, consider it valid since it will be\n-     converted into something that will not be a MEM.  */\n-  if (GET_CODE (op) == ADDRESSOF)\n-    return 1;\n-\n   /* We don't consider registers whose class is NO_REGS\n      to be a register operand.  */\n   return (REG_P (op)\n@@ -1288,9 +1275,6 @@ pop_operand (rtx op, enum machine_mode mode)\n int\n memory_address_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx addr)\n {\n-  if (GET_CODE (addr) == ADDRESSOF)\n-    return 1;\n-\n   GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n   return 0;\n "}, {"sha": "35fe9ca009f7c1fe3e77d212a712ee78e802f3b7", "filename": "gcc/reload1.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -2282,15 +2282,6 @@ eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n     case RETURN:\n       return x;\n \n-    case ADDRESSOF:\n-      /* This is only for the benefit of the debugging backends, which call\n-\t eliminate_regs on DECL_RTL; any ADDRESSOFs in the actual insns are\n-\t removed after CSE.  */\n-      new = eliminate_regs (XEXP (x, 0), 0, insn);\n-      if (MEM_P (new))\n-\treturn XEXP (new, 0);\n-      return x;\n-\n     case REG:\n       regno = REGNO (x);\n \n@@ -2553,12 +2544,6 @@ eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n       return x;\n \n     case MEM:\n-      /* This is only for the benefit of the debugging backends, which call\n-\t eliminate_regs on DECL_RTL; any ADDRESSOFs in the actual insns are\n-\t removed after CSE.  */\n-      if (GET_CODE (XEXP (x, 0)) == ADDRESSOF)\n-\treturn eliminate_regs (XEXP (XEXP (x, 0), 0), 0, insn);\n-\n       /* Our only special processing is to pass the mode of the MEM to our\n \t recursive call and copy the flags.  While we are here, handle this\n \t case more efficiently.  */\n@@ -2657,9 +2642,6 @@ elimination_effects (rtx x, enum machine_mode mem_mode)\n     case RETURN:\n       return;\n \n-    case ADDRESSOF:\n-      abort ();\n-\n     case REG:\n       regno = REGNO (x);\n \n@@ -2802,9 +2784,6 @@ elimination_effects (rtx x, enum machine_mode mem_mode)\n       return;\n \n     case MEM:\n-      if (GET_CODE (XEXP (x, 0)) == ADDRESSOF)\n-\tabort ();\n-\n       /* Our only special processing is to pass the mode of the MEM to our\n \t recursive call.  */\n       elimination_effects (XEXP (x, 0), GET_MODE (x));"}, {"sha": "f1aa85b64dcd9de8883bc3f25e8bd4ae5a9d75e3", "filename": "gcc/rtl.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -224,7 +224,6 @@ copy_rtx (rtx orig)\n     case CC0:\n     case SCRATCH:\n       /* SCRATCH must be shared because they represent distinct values.  */\n-    case ADDRESSOF:\n       return orig;\n     case CLOBBER:\n       if (REG_P (XEXP (orig, 0)) && REGNO (XEXP (orig, 0)) < FIRST_PSEUDO_REGISTER)"}, {"sha": "25b5ee90610ba0e79eab6e10df1271c77e105804", "filename": "gcc/rtl.def", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -906,15 +906,6 @@ DEF_RTL_EXPR(SYMBOL_REF, \"symbol_ref\", \"s00\", RTX_CONST_OBJ)\n    pretend to be looking at the entire value and comparing it.  */\n DEF_RTL_EXPR(CC0, \"cc0\", \"\", RTX_OBJ)\n \n-/* Reference to the address of a register.  Removed by purge_addressof after\n-   CSE has elided as many as possible.\n-   1st operand: the register we may need the address of.\n-   2nd operand: the original pseudo regno we were generated for.\n-   3rd operand: the decl for the object in the register, for\n-     put_reg_in_stack.  */\n-\n-DEF_RTL_EXPR(ADDRESSOF, \"addressof\", \"eit\", RTX_OBJ)\n-\n /* =====================================================================\n    A QUEUED expression really points to a member of the queue of instructions\n    to be output later for postincrement/postdecrement."}, {"sha": "4de6b82391c3c79b83721b54a837a46b78df1e67", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -1115,12 +1115,6 @@ enum label_kind\n \n #define LABEL_ALT_ENTRY_P(LABEL) (LABEL_KIND (LABEL) != LABEL_NORMAL)\n \n-/* The original regno this ADDRESSOF was built for.  */\n-#define ADDRESSOF_REGNO(RTX) XCUINT (RTX, 1, ADDRESSOF)\n-\n-/* The variable in the register we took the address of.  */\n-#define ADDRESSOF_DECL(RTX) XCTREE (RTX, 2, ADDRESSOF)\n-\n /* In jump.c, each JUMP_INSN can point to a label that it can jump to,\n    so that if the JUMP_INSN is deleted, the label's LABEL_NUSES can\n    be decremented and possibly the label can be deleted.  */\n@@ -1801,9 +1795,6 @@ extern rtx simplify_replace_rtx (rtx, rtx, rtx);\n extern rtx simplify_rtx (rtx);\n extern rtx avoid_constant_pool_reference (rtx);\n \n-/* In function.c  */\n-extern rtx gen_mem_addressof (rtx, tree, int);\n-\n /* In regclass.c  */\n extern enum machine_mode choose_hard_reg_mode (unsigned int, unsigned int,\n \t\t\t\t\t       bool);\n@@ -2280,7 +2271,6 @@ extern int prologue_epilogue_contains (rtx);\n extern int sibcall_epilogue_contains (rtx);\n extern void mark_temp_addr_taken (rtx);\n extern void update_temp_slot_address (rtx, rtx);\n-extern void purge_addressof (rtx);\n extern void purge_hard_subreg_sets (rtx);\n \n /* In stmt.c */"}, {"sha": "0eaf1c0df2e775d48c660ac465c0c4a8aba78099", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -86,7 +86,6 @@ rtx_unstable_p (rtx x)\n     case QUEUED:\n       return 1;\n \n-    case ADDRESSOF:\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:\n@@ -173,10 +172,6 @@ rtx_varies_p (rtx x, int for_alias)\n     case LABEL_REF:\n       return 0;\n \n-    case ADDRESSOF:\n-      /* This will resolve to some offset from the frame pointer.  */\n-      return 0;\n-\n     case REG:\n       /* Note that we have to test for the actual rtx used for the frame\n \t and arg pointers and not just the register number in case we have\n@@ -248,10 +243,6 @@ rtx_addr_can_trap_p (rtx x)\n     case LABEL_REF:\n       return 0;\n \n-    case ADDRESSOF:\n-      /* This will resolve to some offset from the frame pointer.  */\n-      return 0;\n-\n     case REG:\n       /* As in rtx_varies_p, we have to use the actual rtx, not reg number.  */\n       if (x == frame_pointer_rtx || x == hard_frame_pointer_rtx\n@@ -311,10 +302,6 @@ nonzero_address_p (rtx x)\n     case LABEL_REF:\n       return true;\n \n-    case ADDRESSOF:\n-      /* This will resolve to some offset from the frame pointer.  */\n-      return true;\n-\n     case REG:\n       /* As in rtx_varies_p, we have to use the actual rtx, not reg number.  */\n       if (x == frame_pointer_rtx || x == hard_frame_pointer_rtx\n@@ -3838,14 +3825,6 @@ rtx_cost (rtx x, enum rtx_code outer_code ATTRIBUTE_UNUSED)\n int\n address_cost (rtx x, enum machine_mode mode)\n {\n-  /* The address_cost target hook does not deal with ADDRESSOF nodes.  But,\n-     during CSE, such nodes are present.  Using an ADDRESSOF node which\n-     refers to the address of a REG is a good thing because we can then\n-     turn (MEM (ADDRESSOF (REG))) into just plain REG.  */\n-\n-  if (GET_CODE (x) == ADDRESSOF && REG_P (XEXP ((x), 0)))\n-    return -1;\n-\n   /* We may be asked for cost of various unusual addresses, such as operands\n      of push instruction.  It is not worthwhile to complicate writing\n      of the target hook by such cases.  */"}, {"sha": "5cb14efd14008b2f04b7ee209e0a922d9e5659a4", "filename": "gcc/rtlhooks.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Frtlhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Frtlhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlhooks.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -76,8 +76,6 @@ gen_lowpart_general (enum machine_mode mode, rtx x)\n \n       return adjust_address (x, mode, offset);\n     }\n-  else if (GET_CODE (x) == ADDRESSOF)\n-    return gen_lowpart_general (mode, force_reg (GET_MODE (x), x));\n   else\n     abort ();\n }"}, {"sha": "77bc32ae734e1539d1dac07c8ba46b51471b8d23", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -1600,7 +1600,6 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \t\t}\n \t      if (REG_P (op)\n \t\t  || GET_CODE (op) == SUBREG\n-\t\t  || GET_CODE (op) == ADDRESSOF\n \t\t  || GET_CODE (op) == CONCAT)\n \t\t{\n \t\t  tree qual_type = build_qualified_type (type,\n@@ -3070,14 +3069,7 @@ expand_decl (tree decl)\n       set_mem_attributes (x, decl, 1);\n       SET_DECL_RTL (decl, x);\n     }\n-  else if (DECL_MODE (decl) != BLKmode\n-\t   /* If -ffloat-store, don't put explicit float vars\n-\t      into regs.  */\n-\t   && !(flag_float_store\n-\t\t&& TREE_CODE (type) == REAL_TYPE)\n-\t   && ! TREE_THIS_VOLATILE (decl)\n-\t   && ! DECL_NONLOCAL (decl)\n-\t   && (DECL_REGISTER (decl) || DECL_ARTIFICIAL (decl) || optimize))\n+  else if (use_register_for_decl (decl))\n     {\n       /* Automatic variable that can go in a register.  */\n       int unsignedp = TYPE_UNSIGNED (type);\n@@ -3103,10 +3095,6 @@ expand_decl (tree decl)\n \t}\n \n       maybe_set_unchanging (DECL_RTL (decl), decl);\n-\n-      /* If something wants our address, try to use ADDRESSOF.  */\n-      if (TREE_ADDRESSABLE (decl))\n-\tput_var_into_stack (decl, /*rescan=*/false);\n     }\n \n   else if (TREE_CODE (DECL_SIZE_UNIT (decl)) == INTEGER_CST"}, {"sha": "3d2f1880b97c0dae5abe715fb9f4d16c95dfc3bd", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -3465,17 +3465,14 @@ extern void build_common_tree_nodes_2 (int);\n extern tree build_range_type (tree, tree, tree);\n \n /* In function.c */\n-extern void setjmp_protect_args (void);\n-extern void setjmp_protect (tree);\n extern void expand_main_function (void);\n extern void init_dummy_function_start (void);\n extern void expand_dummy_function_end (void);\n extern void init_function_for_compilation (void);\n extern void allocate_struct_function (tree);\n extern void init_function_start (tree);\n+extern bool use_register_for_decl (tree);\n extern void assign_parms (tree);\n-extern void put_var_into_stack (tree, int);\n-extern void flush_addressof (tree);\n extern void setjmp_vars_warning (tree);\n extern void setjmp_args_warning (void);\n extern void init_temp_slots (void);"}, {"sha": "fb70e8aeb2b1d6309c48a29d05265d64df2bd023", "filename": "gcc/treelang/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FChangeLog?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -1,3 +1,7 @@\n+2004-04-07  Richard Henderson  <rth@redhat.com>\n+\n+\t* treetree.c (tree_mark_addressable):  Don't put_var_into_stack.\n+\n 2004-03-31  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* treetree.c (tree_lang_signed_or_unsigned_type): Use TYPE_UNSIGNED,"}, {"sha": "1819ad91e53d684cc6d5b01b048b87a6d72134ee", "filename": "gcc/treelang/treetree.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Ftreelang%2Ftreetree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Ftreelang%2Ftreetree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -962,7 +962,6 @@ tree_mark_addressable (tree exp)\n \t    pedwarn (\"address of register variable `%s' requested\",\n \t\t     IDENTIFIER_POINTER (DECL_NAME (x)));\n \t  }\n-\tput_var_into_stack (x, /*rescan=*/ true);\n \n \t/* drops in */\n       case FUNCTION_DECL:"}, {"sha": "01b54254450d5a8716b6cfcf3158335ea80ca67e", "filename": "gcc/web.c", "status": "modified", "additions": 4, "deletions": 40, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fff4fc136a3e6ab2f4bc3a29241a618b06988be/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=8fff4fc136a3e6ab2f4bc3a29241a618b06988be", "patch": "@@ -70,9 +70,8 @@ static struct web_entry *unionfind_root (struct web_entry *);\n static void unionfind_union (struct web_entry *, struct web_entry *);\n static void union_defs (struct df *, struct ref *, struct web_entry *, \n                         struct web_entry *);\n-static rtx entry_register (struct web_entry *, struct ref *, char *, char *);\n+static rtx entry_register (struct web_entry *, struct ref *, char *);\n static void replace_ref (struct ref *, rtx);\n-static int mark_addressof (rtx *, void *);\n \n /* Find the root of unionfind tree (the representative of set).  */\n \n@@ -173,8 +172,7 @@ union_defs (struct df *df, struct ref *use, struct web_entry *def_entry,\n /* Find the corresponding register for the given entry.  */\n \n static rtx\n-entry_register (struct web_entry *entry, struct ref *ref, char *used, \n-                char *use_addressof)\n+entry_register (struct web_entry *entry, struct ref *ref, char *used)\n {\n   struct web_entry *root;\n   rtx reg, newreg;\n@@ -198,14 +196,6 @@ entry_register (struct web_entry *entry, struct ref *ref, char *used,\n \t\t \"New web forced to keep reg=%i (user variable)\\n\",\n \t\t REGNO (reg));\n     }\n-  else if (use_addressof [REGNO (reg)])\n-    {\n-      newreg = reg;\n-      if (dump_file)\n-\tfprintf (dump_file,\n-\t\t \"New web forced to keep reg=%i (address taken)\\n\",\n-\t\t REGNO (reg));\n-    }\n   else\n     {\n       newreg = gen_reg_rtx (GET_MODE (reg));\n@@ -239,19 +229,6 @@ replace_ref (struct ref *ref, rtx reg)\n   *loc = reg;\n }\n \n-/* Mark each pseudo whose address is taken.  */\n-\n-static int\n-mark_addressof (rtx *rtl, void *data)\n-{\n-  if (!*rtl)\n-    return 0;\n-  if (GET_CODE (*rtl) == ADDRESSOF\n-      && REG_P (XEXP (*rtl, 0)))\n-    ((char *)data)[REGNO (XEXP (*rtl, 0))] = 1;\n-  return 0;\n-}\n-\n /* Main entry point.  */\n \n void\n@@ -263,17 +240,13 @@ web_main (void)\n   unsigned int i;\n   int max = max_reg_num ();\n   char *used;\n-  char *use_addressof;\n-  basic_block bb;\n-  rtx insn;\n \n   df = df_init ();\n   df_analyze (df, 0, DF_UD_CHAIN | DF_EQUIV_NOTES);\n \n   def_entry = xcalloc (df->n_defs, sizeof (struct web_entry));\n   use_entry = xcalloc (df->n_uses, sizeof (struct web_entry));\n   used = xcalloc (max, sizeof (char));\n-  use_addressof = xcalloc (max, sizeof (char));\n \n   if (dump_file)\n     df_dump (df, DF_UD_CHAIN | DF_DU_CHAIN, dump_file);\n@@ -282,29 +255,20 @@ web_main (void)\n   for (i = 0; i < df->n_uses; i++)\n     union_defs (df, df->uses[i], def_entry, use_entry);\n \n-  /* We can not safely rename registers whose address is taken.  */\n-  FOR_EACH_BB (bb)\n-    FOR_BB_INSNS (bb, insn)\n-      {\n-\tif (INSN_P (insn))\n-\t  for_each_rtx (&PATTERN (insn), mark_addressof, use_addressof);\n-      }\n-\n   /* Update the instruction stream, allocating new registers for split pseudos\n      in progress.  */\n   for (i = 0; i < df->n_uses; i++)\n     replace_ref (df->uses[i], entry_register (use_entry + i, df->uses[i],\n-\t\t\t\t\t      used, use_addressof));\n+\t\t\t\t\t      used));\n   for (i = 0; i < df->n_defs; i++)\n     replace_ref (df->defs[i], entry_register (def_entry + i, df->defs[i],\n-\t\t\t\t\t      used, use_addressof));\n+\t\t\t\t\t      used));\n \n   /* Dataflow information is corrupt here, but it can be easily updated\n      by creating new entries for new registers and updates or calling\n      df_insns_modify.  */\n   free (def_entry);\n   free (use_entry);\n   free (used);\n-  free (use_addressof);\n   df_finish (df);\n }"}]}