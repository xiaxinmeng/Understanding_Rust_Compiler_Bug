{"sha": "f502d50e30db90506c0c3c4845694cd2e8e0cb25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjUwMmQ1MGUzMGRiOTA1MDZjMGMzYzQ4NDU2OTRjZDJlOGUwY2IyNQ==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2015-06-18T13:31:17Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2015-06-18T13:31:17Z"}, "message": "re PR middle-end/66253 (459.GemsFDTD in SPEC CPU 2006 is miscompiled)\n\n\tPR middle-end/66253\n\t* tree-vect-stmts.c (vectorizable_store): Implement non-SLP\n\tgrouped strided stores.\n\t(vectorizable_load): Don't use the DR from first_stmt in\n\tthe non-SLP grouped strided case.\n\ntestsuite/\n\t* gcc.dg/vect/pr66253.c: New testcase.\n\nFrom-SVN: r224605", "tree": {"sha": "e23e0f732120c2dd7af35f2386b298e409be08a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e23e0f732120c2dd7af35f2386b298e409be08a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f502d50e30db90506c0c3c4845694cd2e8e0cb25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f502d50e30db90506c0c3c4845694cd2e8e0cb25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f502d50e30db90506c0c3c4845694cd2e8e0cb25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f502d50e30db90506c0c3c4845694cd2e8e0cb25/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "55429190dd99a471a22b88a9576920b6cf17d803", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55429190dd99a471a22b88a9576920b6cf17d803", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55429190dd99a471a22b88a9576920b6cf17d803"}], "stats": {"total": 202, "additions": 146, "deletions": 56}, "files": [{"sha": "fef6cb94002fb9421a4678176208f8c7ff6be5dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f502d50e30db90506c0c3c4845694cd2e8e0cb25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f502d50e30db90506c0c3c4845694cd2e8e0cb25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f502d50e30db90506c0c3c4845694cd2e8e0cb25", "patch": "@@ -1,3 +1,11 @@\n+2015-06-18  Michael Matz  <matz@suse.de>\n+\n+\tPR middle-end/66253\n+\t* tree-vect-stmts.c (vectorizable_store): Implement non-SLP\n+\tgrouped strided stores.\n+\t(vectorizable_load): Don't use the DR from first_stmt in\n+\tthe non-SLP grouped strided case.\n+\n 2015-06-18  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \tPR target/66569"}, {"sha": "b6d91e141bd0984cfa868a0a88b104e2a358746e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f502d50e30db90506c0c3c4845694cd2e8e0cb25/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f502d50e30db90506c0c3c4845694cd2e8e0cb25/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f502d50e30db90506c0c3c4845694cd2e8e0cb25", "patch": "@@ -1,3 +1,8 @@\n+2015-06-18  Michael Matz  <matz@suse.de>\n+\n+\tPR middle-end/66253\n+\t* gcc.dg/vect/pr66253.c: New testcase.\n+\n 2015-06-18  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \tPR target/66569"}, {"sha": "bdf3ff9ca51f7f656fad687fd8c77c6ee053794f", "filename": "gcc/testsuite/gcc.dg/vect/pr66253.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f502d50e30db90506c0c3c4845694cd2e8e0cb25/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr66253.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f502d50e30db90506c0c3c4845694cd2e8e0cb25/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr66253.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr66253.c?ref=f502d50e30db90506c0c3c4845694cd2e8e0cb25", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_double } */\n+/* { dg-require-effective-target vect_hw_misalign } */\n+\n+#include \"tree-vect.h\"\n+\n+void __attribute__((noinline,noclone))\n+test1(_Complex double * __restrict__ a, _Complex double * __restrict__ b,\n+      double * __restrict__ c, int stride, int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    {\n+      a[i*stride] = 0.5 * b[i*stride] * c[i*stride];\n+    }\n+}\n+\n+double ca[256];\n+_Complex double ia[256];\n+_Complex double da[256];\n+\n+extern void abort (void);\n+\n+int main ()\n+{\n+  int i;\n+  int stride;\n+\n+  check_vect ();\n+\n+  for (stride = 1; stride < 15; stride++)\n+    {\n+      for (i = 0; i < 256; i++)\n+\t{\n+\t  __real__ ia[i] = (i + stride) % 19;\n+\t  __imag__ ia[i] = (i + stride) % 23;\n+\t  ca[i] = (i + stride) % 29;\n+\t  __asm__ volatile (\"\");\n+\t}\n+\n+      test1(da, ia, ca, stride, 256/stride);\n+\n+      for (i = 0; i < 256/stride; i++)\n+\t{\n+\t  if (da[i*stride] != 0.5 * ia[i*stride] * ca[i*stride])\n+\t    abort ();\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "9760d9a471f72a01137896d5d197dfffe27132c0", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 82, "deletions": 56, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f502d50e30db90506c0c3c4845694cd2e8e0cb25/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f502d50e30db90506c0c3c4845694cd2e8e0cb25/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=f502d50e30db90506c0c3c4845694cd2e8e0cb25", "patch": "@@ -5262,16 +5262,17 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       gimple_seq stmts = NULL;\n       tree stride_base, stride_step, alias_off;\n       tree vec_oprnd;\n+      unsigned int g;\n \n       gcc_assert (!nested_in_vect_loop_p (loop, stmt));\n \n       stride_base\n \t= fold_build_pointer_plus\n-\t    (unshare_expr (DR_BASE_ADDRESS (dr)),\n+\t    (unshare_expr (DR_BASE_ADDRESS (first_dr)),\n \t     size_binop (PLUS_EXPR,\n-\t\t\t convert_to_ptrofftype (unshare_expr (DR_OFFSET (dr))),\n-\t\t\t convert_to_ptrofftype (DR_INIT(dr))));\n-      stride_step = fold_convert (sizetype, unshare_expr (DR_STEP (dr)));\n+\t\t\t convert_to_ptrofftype (unshare_expr (DR_OFFSET (first_dr))),\n+\t\t\t convert_to_ptrofftype (DR_INIT(first_dr))));\n+      stride_step = fold_convert (sizetype, unshare_expr (DR_STEP (first_dr)));\n \n       /* For a store with loop-invariant (but other than power-of-2)\n          stride (i.e. not a grouped access) like so:\n@@ -5302,6 +5303,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t    ltype = vectype;\n \t  ltype = build_aligned_type (ltype, TYPE_ALIGN (elem_type));\n \t  ncopies = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+\t  group_size = 1;\n \t}\n \n       ivstep = stride_step;\n@@ -5322,65 +5324,89 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \tgsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n \n       prev_stmt_info = NULL;\n-      running_off = offvar;\n-      alias_off = build_int_cst (reference_alias_ptr_type (DR_REF (dr)), 0);\n-      for (j = 0; j < ncopies; j++)\n+      alias_off = build_int_cst (reference_alias_ptr_type (DR_REF (first_dr)), 0);\n+      next_stmt = first_stmt;\n+      for (g = 0; g < group_size; g++)\n \t{\n-\t  /* We've set op and dt above, from gimple_assign_rhs1(stmt),\n-\t     and first_stmt == stmt.  */\n-\t  if (j == 0)\n-\t    {\n-\t      if (slp)\n-\t\t{\n-\t\t  vect_get_vec_defs (op, NULL_TREE, stmt, &vec_oprnds, NULL,\n-\t\t\t\t     slp_node, -1);\n-\t\t  vec_oprnd = vec_oprnds[0];\n-\t\t}\n-\t      else\n-\t\tvec_oprnd = vect_get_vec_def_for_operand (op, first_stmt, NULL);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (slp)\n-\t\tvec_oprnd = vec_oprnds[j];\n-\t      else\n-\t\tvec_oprnd = vect_get_vec_def_for_stmt_copy (dt, vec_oprnd);\n-\t    }\n-\n-\t  for (i = 0; i < nstores; i++)\n+\t  running_off = offvar;\n+\t  if (g)\n \t    {\n-\t      tree newref, newoff;\n-\t      gimple incr, assign;\n-\t      tree size = TYPE_SIZE (ltype);\n-\t      /* Extract the i'th component.  */\n-\t      tree pos = fold_build2 (MULT_EXPR, bitsizetype, bitsize_int (i),\n+\t      tree size = TYPE_SIZE_UNIT (ltype);\n+\t      tree pos = fold_build2 (MULT_EXPR, sizetype, size_int (g),\n \t\t\t\t      size);\n-\t      tree elem = fold_build3 (BIT_FIELD_REF, ltype, vec_oprnd,\n-\t\t\t\t       size, pos);\n-\n-\t      elem = force_gimple_operand_gsi (gsi, elem, true,\n-\t\t\t\t\t       NULL_TREE, true,\n-\t\t\t\t\t       GSI_SAME_STMT);\n-\n-\t      newref = build2 (MEM_REF, ltype,\n-\t\t\t       running_off, alias_off);\n-\n-\t      /* And store it to *running_off.  */\n-\t      assign = gimple_build_assign (newref, elem);\n-\t      vect_finish_stmt_generation (stmt, assign, gsi);\n-\n-\t      newoff = copy_ssa_name (running_off, NULL);\n+\t      tree newoff = copy_ssa_name (running_off, NULL);\n \t      incr = gimple_build_assign (newoff, POINTER_PLUS_EXPR,\n-\t\t\t\t\t  running_off, stride_step);\n+\t\t\t\t\t  running_off, pos);\n \t      vect_finish_stmt_generation (stmt, incr, gsi);\n-\n \t      running_off = newoff;\n-\t      if (j == 0 && i == 0)\n-\t\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = assign;\n+\t    }\n+\t  for (j = 0; j < ncopies; j++)\n+\t    {\n+\t      /* We've set op and dt above, from gimple_assign_rhs1(stmt),\n+\t\t and first_stmt == stmt.  */\n+\t      if (j == 0)\n+\t\t{\n+\t\t  if (slp)\n+\t\t    {\n+\t\t      vect_get_vec_defs (op, NULL_TREE, stmt, &vec_oprnds, NULL,\n+\t\t\t\t\t slp_node, -1);\n+\t\t      vec_oprnd = vec_oprnds[0];\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      gcc_assert (gimple_assign_single_p (next_stmt));\n+\t\t      op = gimple_assign_rhs1 (next_stmt);\n+\t\t      vec_oprnd = vect_get_vec_def_for_operand (op, next_stmt,\n+\t\t\t\t\t\t\t\tNULL);\n+\t\t    }\n+\t\t}\n \t      else\n-\t\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = assign;\n-\t      prev_stmt_info = vinfo_for_stmt (assign);\n+\t\t{\n+\t\t  if (slp)\n+\t\t    vec_oprnd = vec_oprnds[j];\n+\t\t  else\n+\t\t    vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, vec_oprnd);\n+\t\t}\n+\n+\t      for (i = 0; i < nstores; i++)\n+\t\t{\n+\t\t  tree newref, newoff;\n+\t\t  gimple incr, assign;\n+\t\t  tree size = TYPE_SIZE (ltype);\n+\t\t  /* Extract the i'th component.  */\n+\t\t  tree pos = fold_build2 (MULT_EXPR, bitsizetype,\n+\t\t\t\t\t  bitsize_int (i), size);\n+\t\t  tree elem = fold_build3 (BIT_FIELD_REF, ltype, vec_oprnd,\n+\t\t\t\t\t   size, pos);\n+\n+\t\t  elem = force_gimple_operand_gsi (gsi, elem, true,\n+\t\t\t\t\t\t   NULL_TREE, true,\n+\t\t\t\t\t\t   GSI_SAME_STMT);\n+\n+\t\t  newref = build2 (MEM_REF, ltype,\n+\t\t\t\t   running_off, alias_off);\n+\n+\t\t  /* And store it to *running_off.  */\n+\t\t  assign = gimple_build_assign (newref, elem);\n+\t\t  vect_finish_stmt_generation (stmt, assign, gsi);\n+\n+\t\t  newoff = copy_ssa_name (running_off, NULL);\n+\t\t  incr = gimple_build_assign (newoff, POINTER_PLUS_EXPR,\n+\t\t\t\t\t      running_off, stride_step);\n+\t\t  vect_finish_stmt_generation (stmt, incr, gsi);\n+\n+\t\t  running_off = newoff;\n+\t\t  if (g == group_size - 1)\n+\t\t    {\n+\t\t      if (j == 0 && i == 0)\n+\t\t\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = assign;\n+\t\t      else\n+\t\t\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = assign;\n+\t\t      prev_stmt_info = vinfo_for_stmt (assign);\n+\t\t    }\n+\t\t}\n \t    }\n+\t  next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n \t}\n       return true;\n     }\n@@ -6265,7 +6291,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n       gcc_assert (!nested_in_vect_loop);\n \n-      if (grouped_load)\n+      if (slp && grouped_load)\n \tfirst_dr = STMT_VINFO_DATA_REF\n \t    (vinfo_for_stmt (GROUP_FIRST_ELEMENT (stmt_info)));\n       else"}]}