{"sha": "65d630d474e1beedfc6a06a4857c08f2cf781d5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVkNjMwZDQ3NGUxYmVlZGZjNmEwNmE0ODU3YzA4ZjJjZjc4MWQ1ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-04-30T17:55:29Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-04-30T17:55:29Z"}, "message": "cgraph.c (ld_plugin_symbol_resolution_names): Move to symtab.c\n\n\t* cgraph.c (ld_plugin_symbol_resolution_names): Move to symtab.c\n\t(cgraph_asm_nodes, cgraph_asm_last_node): Move to cgraphunit.c\n\t(cgraph_add_to_same_comdat_group): Remove.\n\t(cgraph_add_asm_node): Move to cgraphunit.c.\n\t(cgraph_make_decl_local): Move to symtab.c\n\t(cgraph_make_node_local_1): Update.\n\t(cgraph_can_remove_if_no_direct_calls_and): Update.\n\t(used_from_object_file_p): Update.\n\t(resolution_used_from_other_file_p): Move to symtab.c\n\t(cgraph_used_from_object_file_p): move to symtab.c\n\t(verify_cgraph_node): Verify same comdat groups.\n\t* cgraph.h (cgraph_asm_node): Rename to ...\n\t(asm_node): ... this one.\n\t(cgraph_asm_nodes): Rename to ...\n\t(asm_nodes): ... this one.\n\t(symtab_add_to_same_comdat_group): New function.\n\t(symtab_dissolve_same_comdat_group_list): New function.\n\t(symtab_used_from_object_file_p): Declare.\n\t(symtab_make_decl_local): Declare.\n\t(cgraph_add_to_same_comdat_group): Remove.\n\t(cgraph_add_asm_node): Remove.\n\t(cgraph_used_from_object_file_p, varpool_used_from_object_file_p):\n\tRemove.\n\t(cgraph_finalize_compilation_unit): Rename to ...\n\t(finalize_compilation_unit): ... this one.\n\t(cgraph_optimize): Rename to ....\n\t(compile): ... this one.\n\t(add_asm_node): Declare.\n\t(fixup_same_cpp_alias_visibility): Declare.\n\t(cgraph_make_decl_local): Remove.\n\t(varpool_assemble_pending_decls): Rename to ...\n\t(varpool_output_variables): ... this one.\n\t(varpool_remove_unreferenced_decls): Remove.\n\t* ipa-inline-transform.c (clone_inlined_nodes): Dissolve comdat groups.\n\t(preserve_function_body_p): Make static.\n\t* toplev.c (compile_file): Update comments;\n\tupdate.\n\t* cgraphunit.c: Update comments.\n\t(cgraph_expand_all_functions): Rename to ...\n\t(expand_all_functions): ... this one; update.\n\t(cgraph_mark_functions_to_output): Rename to ...\n\t(mark_functions_to_output): ... this one; cleanup.\n\t(cgraph_output_pending_asms): Remove prototype.\n\t(asm_nodes, asm_last_node): New static vars.\n\t(cgraph_process_new_functions): Update.\n\t(cgraph_reset_node): Cleanup; add comment.\n\t(cgraph_add_new_function): Update.\n\t(cgraph_output_pending_asms): Rename to ...\n\t(output_asm_statements): ... this one.\n\t(add_asm_node): New function.\n\t(fixup_same_cpp_alias_visibility): New function based on code\n\tin cgraph_analyze_function.\n\t(cgraph_analyze_function): Use it.\n\t(cgraph_order_sort): Update.\n\t(cgraph_output_in_order): Update.\n\t(cgraph_function_versioning): Update.\n\t(cgraph_optimize): Rename to ...\n\t(compile): ... this one; initialize streamer hooks here.\n\t(cgraph_finalize_compilation_unit): Rename to ...\n\t(finalize_compilation_unit): ... this one; do not initialize streamer\n\thook here.\n\t* lto-streamer-out.c (lto_output_toplevel_asms): Update.\n\t* dwarf2out.c: Update ocmment.\n\t* optimize.c (maybe_clone_body): Use symtab_add_to_same_comdat_group.\n\t* method.c (use_thunk): Likewise.\n\t* semantics.c (maybe_add_lambda_conv_op): Likewise.\n\t* decl2.c (maybe_emit_vtables): Likewise.\t\n\t(cp_write_global_declarations): Use finalize_compilation_unit.\n\t* parser.c (cp_parser_asm_definition): Use add_asm_node.\n\t* lto-streamer-in.c (lto_input_toplevel_asms): Use add_asm_node\n\t* c-decl.c (c_write_global_declarations): Use finalize_compilation_unit.\n\t* langhooks.c (write_global_declarations): Update.\n\t* ipa.c (cgraph_externally_visible_p): Update.\n\t(dissolve_same_comdat_group_list): Remove.\n\t(function_and_variable_visibility): Update.\n\t* symtab.c: Inlcude lto-streamer.h and rtl.h\n\t(ld_plugin_symbol_resolution_names): New.\n\t(symtab_add_to_same_comdat_group): New.\n\t(symtab_dissolve_same_comdat_group_list): New.\n\t(resolution_used_from_other_file_p): Move here from cgraph.c\n\t(symtab_used_from_object_file_p): New.\n\t(symtab_make_decl_local): New.\n\t* passes.c (register_pass): Update comments.\n\t* c-parser.c (c_parser_asm_definition): Update.\n\t* varpool.c (varpool_analyze_node): Use fixup_same_cpp_alias_visibility.\n\t(varpool_remove_unreferenced_decls): Make static.\n\t(varpool_assemble_pending_decls): Rename to ...\n\t(varpool_output_variables): ... this one; call\n\tvarpool_remove_unreferenced_decls.\n\t(varpool_used_from_object_file_p): Remove.\n\n\t* gogo-tree.cc (Gogo::write_globals): Use finalize_compilation_unit.\n\n\t* gcc-interface/utils.c (rest_of_subprog_body_compilation): Update\n\tcomment.\n\t(gnat_write_global_declarations): Use finalize_compilation_unit.\n\n\t* f95-lang.c (gfc_finish): Update comments.\n\n\t* lto.c (lto_main): Use compile ().\n\t* lto-partition.c (partition_cgraph_node_p): Use symtab_used_from_object_file_p.\n\t(partition_varpool_node_p): Likewise.\n\nFrom-SVN: r186998", "tree": {"sha": "a3bcb26607a9acedb2c93c538095fba522a39176", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3bcb26607a9acedb2c93c538095fba522a39176"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65d630d474e1beedfc6a06a4857c08f2cf781d5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d630d474e1beedfc6a06a4857c08f2cf781d5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65d630d474e1beedfc6a06a4857c08f2cf781d5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d630d474e1beedfc6a06a4857c08f2cf781d5e/comments", "author": null, "committer": null, "parents": [{"sha": "7edaa4d2a502c6c8e01a5c1a213834607538a30b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7edaa4d2a502c6c8e01a5c1a213834607538a30b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7edaa4d2a502c6c8e01a5c1a213834607538a30b"}], "stats": {"total": 792, "additions": 432, "deletions": 360}, "files": [{"sha": "60053595c652d8e7286f0a5880ee393655c14ae3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -1,3 +1,96 @@\n+012-04-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (ld_plugin_symbol_resolution_names): Move to symtab.c\n+\t(cgraph_asm_nodes, cgraph_asm_last_node): Move to cgraphunit.c\n+\t(cgraph_add_to_same_comdat_group): Remove.\n+\t(cgraph_add_asm_node): Move to cgraphunit.c.\n+\t(cgraph_make_decl_local): Move to symtab.c\n+\t(cgraph_make_node_local_1): Update.\n+\t(cgraph_can_remove_if_no_direct_calls_and): Update.\n+\t(used_from_object_file_p): Update.\n+\t(resolution_used_from_other_file_p): Move to symtab.c\n+\t(cgraph_used_from_object_file_p): move to symtab.c\n+\t(verify_cgraph_node): Verify same comdat groups.\n+\t* cgraph.h (cgraph_asm_node): Rename to ...\n+\t(asm_node): ... this one.\n+\t(cgraph_asm_nodes): Rename to ...\n+\t(asm_nodes): ... this one.\n+\t(symtab_add_to_same_comdat_group): New function.\n+\t(symtab_dissolve_same_comdat_group_list): New function.\n+\t(symtab_used_from_object_file_p): Declare.\n+\t(symtab_make_decl_local): Declare.\n+\t(cgraph_add_to_same_comdat_group): Remove.\n+\t(cgraph_add_asm_node): Remove.\n+\t(cgraph_used_from_object_file_p, varpool_used_from_object_file_p):\n+\tRemove.\n+\t(cgraph_finalize_compilation_unit): Rename to ...\n+\t(finalize_compilation_unit): ... this one.\n+\t(cgraph_optimize): Rename to ....\n+\t(compile): ... this one.\n+\t(add_asm_node): Declare.\n+\t(fixup_same_cpp_alias_visibility): Declare.\n+\t(cgraph_make_decl_local): Remove.\n+\t(varpool_assemble_pending_decls): Rename to ...\n+\t(varpool_output_variables): ... this one.\n+\t(varpool_remove_unreferenced_decls): Remove.\n+\t* ipa-inline-transform.c (clone_inlined_nodes): Dissolve comdat groups.\n+\t(preserve_function_body_p): Make static.\n+\t* toplev.c (compile_file): Update comments;\n+\tupdate.\n+\t* cgraphunit.c: Update comments.\n+\t(cgraph_expand_all_functions): Rename to ...\n+\t(expand_all_functions): ... this one; update.\n+\t(cgraph_mark_functions_to_output): Rename to ...\n+\t(mark_functions_to_output): ... this one; cleanup.\n+\t(cgraph_output_pending_asms): Remove prototype.\n+\t(asm_nodes, asm_last_node): New static vars.\n+\t(cgraph_process_new_functions): Update.\n+\t(cgraph_reset_node): Cleanup; add comment.\n+\t(cgraph_add_new_function): Update.\n+\t(cgraph_output_pending_asms): Rename to ...\n+\t(output_asm_statements): ... this one.\n+\t(add_asm_node): New function.\n+\t(fixup_same_cpp_alias_visibility): New function based on code\n+\tin cgraph_analyze_function.\n+\t(cgraph_analyze_function): Use it.\n+\t(cgraph_order_sort): Update.\n+\t(cgraph_output_in_order): Update.\n+\t(cgraph_function_versioning): Update.\n+\t(cgraph_optimize): Rename to ...\n+\t(compile): ... this one; initialize streamer hooks here.\n+\t(cgraph_finalize_compilation_unit): Rename to ...\n+\t(finalize_compilation_unit): ... this one; do not initialize streamer\n+\thook here.\n+\t* lto-streamer-out.c (lto_output_toplevel_asms): Update.\n+\t* dwarf2out.c: Update ocmment.\n+\t* optimize.c (maybe_clone_body): Use symtab_add_to_same_comdat_group.\n+\t* method.c (use_thunk): Likewise.\n+\t* semantics.c (maybe_add_lambda_conv_op): Likewise.\n+\t* decl2.c (maybe_emit_vtables): Likewise.\t\n+\t(cp_write_global_declarations): Use finalize_compilation_unit.\n+\t* parser.c (cp_parser_asm_definition): Use add_asm_node.\n+\t* lto-streamer-in.c (lto_input_toplevel_asms): Use add_asm_node\n+\t* c-decl.c (c_write_global_declarations): Use finalize_compilation_unit.\n+\t* langhooks.c (write_global_declarations): Update.\n+\t* ipa.c (cgraph_externally_visible_p): Update.\n+\t(dissolve_same_comdat_group_list): Remove.\n+\t(function_and_variable_visibility): Update.\n+\t* symtab.c: Inlcude lto-streamer.h and rtl.h\n+\t(ld_plugin_symbol_resolution_names): New.\n+\t(symtab_add_to_same_comdat_group): New.\n+\t(symtab_dissolve_same_comdat_group_list): New.\n+\t(resolution_used_from_other_file_p): Move here from cgraph.c\n+\t(symtab_used_from_object_file_p): New.\n+\t(symtab_make_decl_local): New.\n+\t* passes.c (register_pass): Update comments.\n+\t* c-parser.c (c_parser_asm_definition): Update.\n+\t* varpool.c (varpool_analyze_node): Use fixup_same_cpp_alias_visibility.\n+\t(varpool_remove_unreferenced_decls): Make static.\n+\t(varpool_assemble_pending_decls): Rename to ...\n+\t(varpool_output_variables): ... this one; call\n+\tvarpool_remove_unreferenced_decls.\n+\t(varpool_used_from_object_file_p): Remove.\n+\n 2012-04-30  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR c++/51033"}, {"sha": "e733b68f68da751a59400a4c07b5a98109be29a0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -1,3 +1,9 @@\n+2012-04-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc-interface/utils.c (rest_of_subprog_body_compilation): Update\n+\tcomment.\n+\t(gnat_write_global_declarations): Use finalize_compilation_unit.\n+\n 2012-04-30  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity): In type annotation mode,"}, {"sha": "6d267e0ef4ee5be92a27d8ad8277b66a076cd2bc", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -2036,7 +2036,6 @@ rest_of_subprog_body_compilation (tree subprog_decl)\n   /* Dump functions before gimplification.  */\n   dump_function (TDI_original, subprog_decl);\n \n-  /* ??? This special handling of nested functions is probably obsolete.  */\n   if (!decl_function_context (subprog_decl))\n     cgraph_finalize_function (subprog_decl, false);\n   else\n@@ -4907,9 +4906,8 @@ gnat_write_global_declarations (void)\n     if (TREE_CODE (iter) == TYPE_DECL)\n       debug_hooks->global_decl (iter);\n \n-  /* Proceed to optimize and emit assembly.\n-     FIXME: shouldn't be the front end's responsibility to call this.  */\n-  cgraph_finalize_compilation_unit ();\n+  /* Proceed to optimize and emit assembly. */\n+  finalize_compilation_unit ();\n \n   /* After cgraph has had a chance to emit everything that's going to\n      be emitted, output debug information for the rest of globals.  */"}, {"sha": "72fad86f9d12238f8f533002393eea1910572214", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -10040,7 +10040,7 @@ c_write_global_declarations (void)\n \n   /* We're done parsing; proceed to optimize and emit assembly.\n      FIXME: shouldn't be the front end's responsibility to call this.  */\n-  cgraph_finalize_compilation_unit ();\n+  finalize_compilation_unit ();\n \n   timevar_stop (TV_PHASE_CGRAPH);\n   timevar_start (TV_PHASE_DBGINFO);"}, {"sha": "3308ca8d063720ca9d55e8c0199c8a4affe97777", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic.h\"\n #include \"opts.h\"\n #include \"plugin.h\"\n+#include \"cgraph.h\"\n \n #define GCC_BAD(gmsgid) \\\n   do { warning (OPT_Wpragmas, gmsgid); return; } while (0)\n@@ -311,6 +312,7 @@ maybe_apply_pending_pragma_weaks (void)\n   tree alias_id, id, decl;\n   int i;\n   pending_weak *pe;\n+  symtab_node target;\n \n   FOR_EACH_VEC_ELT (pending_weak, pending_weaks, i, pe)\n     {\n@@ -320,13 +322,22 @@ maybe_apply_pending_pragma_weaks (void)\n       if (id == NULL)\n \tcontinue;\n \n+      target = symtab_node_for_asm (id);\n       decl = build_decl (UNKNOWN_LOCATION,\n-\t\t\t FUNCTION_DECL, alias_id, default_function_type);\n+\t\t\t target ? TREE_CODE (target->symbol.decl) : FUNCTION_DECL,\n+\t\t\t alias_id, default_function_type);\n \n       DECL_ARTIFICIAL (decl) = 1;\n       TREE_PUBLIC (decl) = 1;\n-      DECL_EXTERNAL (decl) = 1;\n       DECL_WEAK (decl) = 1;\n+      if (TREE_CODE (decl) == VAR_DECL)\n+\tTREE_STATIC (decl) = 1;\n+      if (!target)\n+\t{\n+\t  error (\"%q+D aliased to undefined symbol %qE\",\n+\t\t decl, id);\n+\t  continue;\n+\t}\n \n       assemble_alias (decl, id);\n     }"}, {"sha": "47908f140549fde700dd950ef25efe0293c82b7e", "filename": "gcc/c-parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -1792,7 +1792,7 @@ c_parser_asm_definition (c_parser *parser)\n {\n   tree asm_str = c_parser_simple_asm_expr (parser);\n   if (asm_str)\n-    cgraph_add_asm_node (asm_str);\n+    add_asm_node (asm_str);\n   c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n }\n "}, {"sha": "ebba1b767c7d6868e25ef591c0f9cb1d92475806", "filename": "gcc/cgraph.c", "status": "modified", "additions": 8, "deletions": 164, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -54,20 +54,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"gimple-pretty-print.h\"\n \n-const char * const ld_plugin_symbol_resolution_names[]=\n-{\n-  \"\",\n-  \"undef\",\n-  \"prevailing_def\",\n-  \"prevailing_def_ironly\",\n-  \"preempted_reg\",\n-  \"preempted_ir\",\n-  \"resolved_ir\",\n-  \"resolved_exec\",\n-  \"resolved_dyn\",\n-  \"prevailing_def_ironly_exp\"\n-};\n-\n static void cgraph_node_remove_callers (struct cgraph_node *node);\n static inline void cgraph_edge_remove_caller (struct cgraph_edge *e);\n static inline void cgraph_edge_remove_callee (struct cgraph_edge *e);\n@@ -94,12 +80,6 @@ enum cgraph_state cgraph_state = CGRAPH_STATE_PARSING;\n /* Set when the cgraph is fully build and the basic flags are computed.  */\n bool cgraph_function_flags_ready = false;\n \n-/* Linked list of cgraph asm nodes.  */\n-struct cgraph_asm_node *cgraph_asm_nodes;\n-\n-/* Last node in cgraph_asm_nodes.  */\n-static GTY(()) struct cgraph_asm_node *cgraph_asm_last_node;\n-\n /* List of hooks triggered on cgraph_edge events.  */\n struct cgraph_edge_hook_list {\n   cgraph_edge_hook hook;\n@@ -1377,31 +1357,6 @@ cgraph_remove_node (struct cgraph_node *node)\n   free_nodes = node;\n }\n \n-/* Add NEW_ to the same comdat group that OLD is in.  */\n-\n-void\n-cgraph_add_to_same_comdat_group (struct cgraph_node *new_node,\n-\t\t\t\t struct cgraph_node *old_node)\n-{\n-  gcc_assert (DECL_ONE_ONLY (old_node->symbol.decl));\n-  gcc_assert (!new_node->symbol.same_comdat_group);\n-  gcc_assert (new_node != old_node);\n-\n-  DECL_COMDAT_GROUP (new_node->symbol.decl) = DECL_COMDAT_GROUP (old_node->symbol.decl);\n-  new_node->symbol.same_comdat_group = (symtab_node)old_node;\n-  if (!old_node->symbol.same_comdat_group)\n-    old_node->symbol.same_comdat_group = (symtab_node)new_node;\n-  else\n-    {\n-      symtab_node n;\n-      for (n = old_node->symbol.same_comdat_group;\n-\t   n->symbol.same_comdat_group != (symtab_node)old_node;\n-\t   n = n->symbol.same_comdat_group)\n-\t;\n-      n->symbol.same_comdat_group = (symtab_node)new_node;\n-    }\n-}\n-\n /* Remove the node from cgraph and all inline clones inlined into it.\n    Skip however removal of FORBIDDEN_NODE and return true if it needs to be\n    removed.  This allows to call the function from outer loop walking clone\n@@ -1660,25 +1615,6 @@ debug_cgraph (void)\n   dump_cgraph (stderr);\n }\n \n-/* Add a top-level asm statement to the list.  */\n-\n-struct cgraph_asm_node *\n-cgraph_add_asm_node (tree asm_str)\n-{\n-  struct cgraph_asm_node *node;\n-\n-  node = ggc_alloc_cleared_cgraph_asm_node ();\n-  node->asm_str = asm_str;\n-  node->order = symtab_order++;\n-  node->next = NULL;\n-  if (cgraph_asm_nodes == NULL)\n-    cgraph_asm_nodes = node;\n-  else\n-    cgraph_asm_last_node->next = node;\n-  cgraph_asm_last_node = node;\n-  return node;\n-}\n-\n /* Return true when the DECL can possibly be inlined.  */\n bool\n cgraph_function_possibly_inlined_p (tree decl)\n@@ -2047,77 +1983,6 @@ cgraph_node_can_be_local_p (struct cgraph_node *node)\n \t\t\t\t\t   NULL, true));\n }\n \n-/* Make DECL local.  FIXME: We shouldn't need to mess with rtl this early,\n-   but other code such as notice_global_symbol generates rtl.  */\n-void\n-cgraph_make_decl_local (tree decl)\n-{\n-  rtx rtl, symbol;\n-\n-  if (TREE_CODE (decl) == VAR_DECL)\n-    DECL_COMMON (decl) = 0;\n-  else gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n-\n-  if (DECL_ONE_ONLY (decl) || DECL_COMDAT (decl))\n-    {\n-      /* It is possible that we are linking against library defining same COMDAT\n-\t function.  To avoid conflict we need to rename our local name of the\n-\t function just in the case WHOPR partitioning decide to make it hidden\n-\t to avoid cross partition references.  */\n-      if (flag_wpa)\n-\t{\n-\t  const char *old_name;\n-\n-\t  old_name  = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t    {\n-\t      struct cgraph_node *node = cgraph_get_node (decl);\n-\t      change_decl_assembler_name (decl,\n-\t\t\t\t\t  clone_function_name (decl, \"local\"));\n-\t      if (node->symbol.lto_file_data)\n-\t\tlto_record_renamed_decl (node->symbol.lto_file_data,\n-\t\t\t\t\t old_name,\n-\t\t\t\t\t IDENTIFIER_POINTER\n-\t\t\t\t\t   (DECL_ASSEMBLER_NAME (decl)));\n-\t    }\n-\t  else if (TREE_CODE (decl) == VAR_DECL)\n-\t    {\n-\t      struct varpool_node *vnode = varpool_get_node (decl);\n-\t      /* change_decl_assembler_name will warn here on vtables because\n-\t\t C++ frontend still sets TREE_SYMBOL_REFERENCED on them.  */\n-\t      SET_DECL_ASSEMBLER_NAME (decl,\n-\t\t\t\t       clone_function_name (decl, \"local\"));\n-\t      if (vnode->symbol.lto_file_data)\n-\t\tlto_record_renamed_decl (vnode->symbol.lto_file_data,\n-\t\t\t\t\t old_name,\n-\t\t\t\t\t IDENTIFIER_POINTER\n-\t\t\t\t\t   (DECL_ASSEMBLER_NAME (decl)));\n-\t    }\n-\t}\n-      DECL_SECTION_NAME (decl) = 0;\n-      DECL_COMDAT (decl) = 0;\n-    }\n-  DECL_COMDAT_GROUP (decl) = 0;\n-  DECL_WEAK (decl) = 0;\n-  DECL_EXTERNAL (decl) = 0;\n-  TREE_PUBLIC (decl) = 0;\n-  if (!DECL_RTL_SET_P (decl))\n-    return;\n-\n-  /* Update rtl flags.  */\n-  make_decl_rtl (decl);\n-\n-  rtl = DECL_RTL (decl);\n-  if (!MEM_P (rtl))\n-    return;\n-\n-  symbol = XEXP (rtl, 0);\n-  if (GET_CODE (symbol) != SYMBOL_REF)\n-    return;\n-\n-  SYMBOL_REF_WEAK (symbol) = DECL_WEAK (decl);\n-}\n-\n /* Call calback on NODE, thunks and aliases asociated to NODE. \n    When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n    skipped. */\n@@ -2190,7 +2055,7 @@ cgraph_make_node_local_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n   gcc_checking_assert (cgraph_node_can_be_local_p (node));\n   if (DECL_COMDAT (node->symbol.decl) || DECL_EXTERNAL (node->symbol.decl))\n     {\n-      cgraph_make_decl_local (node->symbol.decl);\n+      symtab_make_decl_local (node->symbol.decl);\n \n       node->symbol.externally_visible = false;\n       node->local.local = true;\n@@ -2472,7 +2337,7 @@ cgraph_can_remove_if_no_direct_calls_and_refs_p (struct cgraph_node *node)\n   /* Only COMDAT functions can be removed if externally visible.  */\n   if (node->symbol.externally_visible\n       && (!DECL_COMDAT (node->symbol.decl)\n-\t  || cgraph_used_from_object_file_p (node)))\n+\t  || symtab_used_from_object_file_p ((symtab_node) node)))\n     return false;\n   return true;\n }\n@@ -2504,7 +2369,7 @@ cgraph_can_remove_if_no_direct_calls_p (struct cgraph_node *node)\n static bool\n used_from_object_file_p (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n {\n-  return cgraph_used_from_object_file_p (node);\n+  return symtab_used_from_object_file_p ((symtab_node) node);\n }\n \n /* Return true when function NODE can be expected to be removed\n@@ -2537,32 +2402,6 @@ cgraph_will_be_removed_from_program_if_no_direct_calls (struct cgraph_node *node\n     }\n }\n \n-/* Return true when RESOLUTION indicate that linker will use\n-   the symbol from non-LTO object files.  */\n-\n-bool\n-resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution resolution)\n-{\n-  return (resolution == LDPR_PREVAILING_DEF\n-          || resolution == LDPR_PREEMPTED_REG\n-          || resolution == LDPR_RESOLVED_EXEC\n-          || resolution == LDPR_RESOLVED_DYN);\n-}\n-\n-\n-/* Return true when NODE is known to be used from other (non-LTO) object file.\n-   Known only when doing LTO via linker plugin.  */\n-\n-bool\n-cgraph_used_from_object_file_p (struct cgraph_node *node)\n-{\n-  gcc_assert (!node->global.inlined_to);\n-  if (!TREE_PUBLIC (node->symbol.decl) || DECL_EXTERNAL (node->symbol.decl))\n-    return false;\n-  if (resolution_used_from_other_file_p (node->symbol.resolution))\n-    return true;\n-  return false;\n-}\n \n /* Worker for cgraph_only_called_directly_p.  */\n \n@@ -2741,6 +2580,11 @@ verify_cgraph_node (struct cgraph_node *node)\n       error (\"execution count is negative\");\n       error_found = true;\n     }\n+  if (node->global.inlined_to && node->symbol.same_comdat_group)\n+    {\n+      error (\"inline clone in same comdat group list\");\n+      error_found = true;\n+    }\n   if (node->global.inlined_to && node->symbol.externally_visible)\n     {\n       error (\"externally visible inline clone\");"}, {"sha": "eefb2f4e2e8968d4fb040f886434df479d73a795", "filename": "gcc/cgraph.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -422,11 +422,11 @@ struct GTY(()) varpool_node {\n   unsigned extra_name_alias : 1;\n };\n \n-/* Every top level asm statement is put into a cgraph_asm_node.  */\n+/* Every top level asm statement is put into a asm_node.  */\n \n-struct GTY(()) cgraph_asm_node {\n+struct GTY(()) asm_node {\n   /* Next asm node.  */\n-  struct cgraph_asm_node *next;\n+  struct asm_node *next;\n   /* String for this asm node.  */\n   tree asm_str;\n   /* Ordering of all cgraph nodes.  */\n@@ -467,7 +467,7 @@ extern enum cgraph_state cgraph_state;\n extern bool cgraph_function_flags_ready;\n extern cgraph_node_set cgraph_new_nodes;\n \n-extern GTY(()) struct cgraph_asm_node *cgraph_asm_nodes;\n+extern GTY(()) struct asm_node *asm_nodes;\n extern GTY(()) int symtab_order;\n extern bool same_body_aliases_done;\n \n@@ -480,6 +480,8 @@ symtab_node symtab_node_for_asm (const_tree asmname);\n const char * symtab_node_asm_name (symtab_node);\n const char * symtab_node_name (symtab_node);\n void symtab_insert_node_to_hashtable (symtab_node);\n+void symtab_add_to_same_comdat_group (symtab_node, symtab_node);\n+void symtab_dissolve_same_comdat_group_list (symtab_node node);\n void dump_symtab (FILE *);\n void debug_symtab (void);\n void dump_symtab_node (FILE *, symtab_node);\n@@ -488,6 +490,8 @@ void dump_symtab_base (FILE *, symtab_node);\n void verify_symtab (void);\n void verify_symtab_node (symtab_node);\n bool verify_symtab_base (symtab_node);\n+bool symtab_used_from_object_file_p (symtab_node);\n+void symtab_make_decl_local (tree);\n \n /* In cgraph.c  */\n void dump_cgraph (FILE *);\n@@ -497,7 +501,6 @@ void debug_cgraph_node (struct cgraph_node *);\n void cgraph_remove_edge (struct cgraph_edge *);\n void cgraph_remove_node (struct cgraph_node *);\n struct cgraph_node *cgraph_find_replacement_node (struct cgraph_node *);\n-void cgraph_add_to_same_comdat_group (struct cgraph_node *, struct cgraph_node *);\n bool cgraph_remove_node_and_inline_clones (struct cgraph_node *, struct cgraph_node *);\n void cgraph_release_function_body (struct cgraph_node *);\n void cgraph_node_remove_callees (struct cgraph_node *node);\n@@ -538,8 +541,6 @@ void cgraph_redirect_edge_callee (struct cgraph_edge *, struct cgraph_node *);\n void cgraph_make_edge_direct (struct cgraph_edge *, struct cgraph_node *);\n bool cgraph_only_called_directly_p (struct cgraph_node *);\n \n-struct cgraph_asm_node *cgraph_add_asm_node (tree);\n-\n bool cgraph_function_possibly_inlined_p (tree);\n void cgraph_unnest_node (struct cgraph_node *);\n \n@@ -564,8 +565,6 @@ bool cgraph_can_remove_if_no_direct_calls_and_refs_p\n   (struct cgraph_node *node);\n bool cgraph_can_remove_if_no_direct_calls_p (struct cgraph_node *node);\n bool resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution);\n-bool cgraph_used_from_object_file_p (struct cgraph_node *);\n-bool varpool_used_from_object_file_p (struct varpool_node *);\n bool cgraph_for_node_thunks_and_aliases (struct cgraph_node *,\n \t\t\t                 bool (*) (struct cgraph_node *, void *),\n \t\t\t                 void *,\n@@ -605,10 +604,11 @@ gimple cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *);\n bool cgraph_propagate_frequency (struct cgraph_node *node);\n \n /* In cgraphunit.c  */\n+struct asm_node *add_asm_node (tree);\n extern FILE *cgraph_dump_file;\n void cgraph_finalize_function (tree, bool);\n-void cgraph_finalize_compilation_unit (void);\n-void cgraph_optimize (void);\n+void finalize_compilation_unit (void);\n+void compile (void);\n void init_cgraph (void);\n struct cgraph_node * cgraph_copy_node_for_versioning (struct cgraph_node *,\n \t\ttree, VEC(cgraph_edge_p,heap)*, bitmap);\n@@ -621,6 +621,7 @@ void tree_function_versioning (tree, tree, VEC (ipa_replace_map_p,gc)*,\n \t\t\t       bool, bitmap, bool, bitmap, basic_block);\n bool cgraph_process_new_functions (void);\n void cgraph_process_same_body_aliases (void);\n+void fixup_same_cpp_alias_visibility (symtab_node node, symtab_node target, tree alias);\n \n \n /* In cgraphbuild.c  */\n@@ -668,17 +669,15 @@ void dump_varpool_node (FILE *, struct varpool_node *);\n void varpool_finalize_decl (tree);\n bool decide_is_variable_needed (struct varpool_node *, tree);\n enum availability cgraph_variable_initializer_availability (struct varpool_node *);\n-void cgraph_make_decl_local (tree);\n void cgraph_make_node_local (struct cgraph_node *);\n bool cgraph_node_can_be_local_p (struct cgraph_node *);\n \n \n void varpool_remove_node (struct varpool_node *node);\n void varpool_finalize_named_section_flags (struct varpool_node *node);\n-bool varpool_assemble_pending_decls (void);\n+bool varpool_output_variables (void);\n bool varpool_assemble_decl (struct varpool_node *node);\n void varpool_analyze_node (struct varpool_node *);\n-void varpool_remove_unreferenced_decls (void);\n struct varpool_node * varpool_extra_name_alias (tree, tree);\n struct varpool_node * varpool_create_variable_alias (tree, tree);\n void varpool_reset_queue (void);\n@@ -1288,4 +1287,5 @@ cgraph_mark_force_output_node (struct cgraph_node *node)\n   node->symbol.force_output = 1;\n   gcc_checking_assert (!node->global.inlined_to);\n }\n+\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "f922a5e0bfd9251c908cb4d0ad31f882416a5554", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 86, "deletions": 75, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -39,7 +39,11 @@ along with GCC; see the file COPYING3.  If not see\n       This function has same behavior as the above but is used for static\n       variables.\n \n-    - cgraph_finalize_compilation_unit\n+    - add_asm_node\n+\n+      Insert new toplevel ASM statement\n+\n+    - finalize_compilation_unit\n \n       This function is called once (source level) compilation unit is finalized\n       and it will no longer change.\n@@ -54,7 +58,7 @@ along with GCC; see the file COPYING3.  If not see\n       The function can be called multiple times when multiple source level\n       compilation units are combined.\n \n-    - cgraph_optimize\n+    - compile\n \n       This passes control to the back-end.  Optimizations are performed and\n       final assembler is generated.  This is done in the following way. Note\n@@ -130,7 +134,7 @@ along with GCC; see the file COPYING3.  If not see\n \t    Simple IP passes working within single program partition.\n \n \t 5) Expansion\n-\t    (cgraph_expand_all_functions)\n+\t    (expand_all_functions)\n \n \t    At this stage functions that needs to be output into\n \t    assembler are identified and compiled in topological order\n@@ -197,14 +201,19 @@ along with GCC; see the file COPYING3.  If not see\n    may generate new functions that need to be optimized and expanded.  */\n cgraph_node_set cgraph_new_nodes;\n \n-static void cgraph_expand_all_functions (void);\n-static void cgraph_mark_functions_to_output (void);\n-static void cgraph_expand_function (struct cgraph_node *);\n-static void cgraph_output_pending_asms (void);\n+static void expand_all_functions (void);\n+static void mark_functions_to_output (void);\n+static void expand_function (struct cgraph_node *);\n static void cgraph_analyze_function (struct cgraph_node *);\n \n FILE *cgraph_dump_file;\n \n+/* Linked list of cgraph asm nodes.  */\n+struct asm_node *asm_nodes;\n+\n+/* Last node in cgraph_asm_nodes.  */\n+static GTY(()) struct asm_node *asm_last_node;\n+\n /* Used for vtable lookup in thunk adjusting.  */\n static GTY (()) tree vtable_entry_type;\n \n@@ -324,7 +333,7 @@ cgraph_process_new_functions (void)\n \t     directly.  */\n \t  node->process = 0;\n           cgraph_call_function_insertion_hooks (node);\n-\t  cgraph_expand_function (node);\n+\t  expand_function (node);\n \t  break;\n \n \tdefault:\n@@ -372,12 +381,12 @@ cgraph_reset_node (struct cgraph_node *node)\n static bool\n referred_to_p (symtab_node node)\n {\n-  int i;\n   struct ipa_ref *ref;\n \n-  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list, i, ref);\n-       i++)\n+  /* See if there are any refrences at all.  */\n+  if (ipa_ref_list_referring_iterate (&node->symbol.ref_list, 0, ref))\n     return true;\n+  /* For functions check also calls.  */\n   if (symtab_function_p (node) && cgraph (node)->callers)\n     return true;\n   return false;\n@@ -518,7 +527,7 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n \t  execute_pass_list (pass_early_local_passes.pass.sub);\n \tbitmap_obstack_release (NULL);\n \tpop_cfun ();\n-\tcgraph_expand_function (node);\n+\texpand_function (node);\n \tcurrent_function_decl = NULL;\n \tbreak;\n \n@@ -533,19 +542,54 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n     DECL_FUNCTION_PERSONALITY (fndecl) = lang_hooks.eh_personality ();\n }\n \n+/* Add a top-level asm statement to the list.  */\n+\n+struct asm_node *\n+add_asm_node (tree asm_str)\n+{\n+  struct asm_node *node;\n+\n+  node = ggc_alloc_cleared_asm_node ();\n+  node->asm_str = asm_str;\n+  node->order = symtab_order++;\n+  node->next = NULL;\n+  if (asm_nodes == NULL)\n+    asm_nodes = node;\n+  else\n+    asm_last_node->next = node;\n+  asm_last_node = node;\n+  return node;\n+}\n+\n /* Output all asm statements we have stored up to be output.  */\n \n static void\n-cgraph_output_pending_asms (void)\n+output_asm_statements (void)\n {\n-  struct cgraph_asm_node *can;\n+  struct asm_node *can;\n \n   if (seen_error ())\n     return;\n \n-  for (can = cgraph_asm_nodes; can; can = can->next)\n+  for (can = asm_nodes; can; can = can->next)\n     assemble_asm (can->asm_str);\n-  cgraph_asm_nodes = NULL;\n+  asm_nodes = NULL;\n+}\n+\n+/* C++ FE sometimes change linkage flags after producing same body aliases.  */\n+void\n+fixup_same_cpp_alias_visibility (symtab_node node, symtab_node target, tree alias)\n+{\n+  DECL_VIRTUAL_P (node->symbol.decl) = DECL_VIRTUAL_P (alias);\n+  if (TREE_PUBLIC (node->symbol.decl))\n+    {\n+      DECL_EXTERNAL (node->symbol.decl) = DECL_EXTERNAL (alias);\n+      DECL_COMDAT (node->symbol.decl) = DECL_COMDAT (alias);\n+      DECL_COMDAT_GROUP (node->symbol.decl) = DECL_COMDAT_GROUP (alias);\n+      if (DECL_ONE_ONLY (alias)\n+\t  && !node->symbol.same_comdat_group)\n+\tsymtab_add_to_same_comdat_group ((symtab_node)node, (symtab_node)target);\n+    }\n }\n \n /* Analyze the function scheduled to be output.  */\n@@ -576,39 +620,13 @@ cgraph_analyze_function (struct cgraph_node *node)\n \t\t\t      IPA_REF_ALIAS, NULL);\n       if (node->same_body_alias)\n \t{ \n-\t  DECL_VIRTUAL_P (node->symbol.decl) = DECL_VIRTUAL_P (node->thunk.alias);\n \t  DECL_DECLARED_INLINE_P (node->symbol.decl)\n \t     = DECL_DECLARED_INLINE_P (node->thunk.alias);\n \t  DECL_DISREGARD_INLINE_LIMITS (node->symbol.decl)\n \t     = DECL_DISREGARD_INLINE_LIMITS (node->thunk.alias);\n+\t  fixup_same_cpp_alias_visibility ((symtab_node) node, (symtab_node) tgt, node->thunk.alias);\n \t}\n \n-      /* Fixup visibility nonsences C++ frontend produce on same body aliases.  */\n-      if (TREE_PUBLIC (node->symbol.decl) && node->same_body_alias)\n-\t{\n-          DECL_EXTERNAL (node->symbol.decl) = DECL_EXTERNAL (node->thunk.alias);\n-\t  if (DECL_ONE_ONLY (node->thunk.alias))\n-\t    {\n-\t      DECL_COMDAT (node->symbol.decl) = DECL_COMDAT (node->thunk.alias);\n-\t      DECL_COMDAT_GROUP (node->symbol.decl) = DECL_COMDAT_GROUP (node->thunk.alias);\n-\t      if (DECL_ONE_ONLY (node->thunk.alias) && !node->symbol.same_comdat_group)\n-\t\t{\n-\t\t  struct cgraph_node *tgt = cgraph_get_node (node->thunk.alias);\n-\t\t  node->symbol.same_comdat_group = (symtab_node)tgt;\n-\t\t  if (!tgt->symbol.same_comdat_group)\n-\t\t    tgt->symbol.same_comdat_group = (symtab_node)node;\n-\t\t  else\n-\t\t    {\n-\t\t      symtab_node n;\n-\t\t      for (n = tgt->symbol.same_comdat_group;\n-\t\t\t   n->symbol.same_comdat_group != (symtab_node)tgt;\n-\t\t\t   n = n->symbol.same_comdat_group)\n-\t\t\t;\n-\t\t      n->symbol.same_comdat_group = (symtab_node)node;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n       if (node->symbol.address_taken)\n \tcgraph_mark_address_taken_node (cgraph_alias_aliased_node (node));\n     }\n@@ -1074,7 +1092,7 @@ handle_alias_pairs (void)\n /* Figure out what functions we want to assemble.  */\n \n static void\n-cgraph_mark_functions_to_output (void)\n+mark_functions_to_output (void)\n {\n   struct cgraph_node *node;\n #ifdef ENABLE_CHECKING\n@@ -1087,16 +1105,11 @@ cgraph_mark_functions_to_output (void)\n   FOR_EACH_FUNCTION (node)\n     {\n       tree decl = node->symbol.decl;\n-      struct cgraph_edge *e;\n \n       gcc_assert (!node->process || node->symbol.same_comdat_group);\n       if (node->process)\n \tcontinue;\n \n-      for (e = node->callers; e; e = e->next_caller)\n-\tif (e->inline_failed)\n-\t  break;\n-\n       /* We need to output all local functions that are used and not\n \t always inlined, as well as those that are reachable from\n \t outside the current compilation unit.  */\n@@ -1544,7 +1557,7 @@ assemble_thunks_and_aliases (struct cgraph_node *node)\n /* Expand function specified by NODE.  */\n \n static void\n-cgraph_expand_function (struct cgraph_node *node)\n+expand_function (struct cgraph_node *node)\n {\n   tree decl = node->symbol.decl;\n   location_t saved_loc;\n@@ -1641,9 +1654,9 @@ cgraph_expand_function (struct cgraph_node *node)\n   current_function_decl = NULL;\n \n   /* It would make a lot more sense to output thunks before function body to get more\n-     forward and lest backwarding jumps.  This is however would need solving problem\n+     forward and lest backwarding jumps.  This however would need solving problem\n      with comdats. See PR48668.  Also aliases must come after function itself to\n-     make one pass assemblers, like one on AIX happy.  See PR 50689.\n+     make one pass assemblers, like one on AIX, happy.  See PR 50689.\n      FIXME: Perhaps thunks should be move before function IFF they are not in comdat\n      groups.  */\n   assemble_thunks_and_aliases (node);\n@@ -1665,7 +1678,7 @@ cgraph_expand_function (struct cgraph_node *node)\n    order).  */\n \n static void\n-cgraph_expand_all_functions (void)\n+expand_all_functions (void)\n {\n   struct cgraph_node *node;\n   struct cgraph_node **order = XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n@@ -1687,7 +1700,7 @@ cgraph_expand_all_functions (void)\n       if (node->process)\n \t{\n \t  node->process = 0;\n-\t  cgraph_expand_function (node);\n+\t  expand_function (node);\n \t}\n     }\n   cgraph_process_new_functions ();\n@@ -1713,7 +1726,7 @@ struct cgraph_order_sort\n   {\n     struct cgraph_node *f;\n     struct varpool_node *v;\n-    struct cgraph_asm_node *a;\n+    struct asm_node *a;\n   } u;\n };\n \n@@ -1724,14 +1737,14 @@ struct cgraph_order_sort\n    need to be output.  */\n \n static void\n-cgraph_output_in_order (void)\n+output_in_order (void)\n {\n   int max;\n   struct cgraph_order_sort *nodes;\n   int i;\n   struct cgraph_node *pf;\n   struct varpool_node *pv;\n-  struct cgraph_asm_node *pa;\n+  struct asm_node *pa;\n \n   max = symtab_order;\n   nodes = XCNEWVEC (struct cgraph_order_sort, max);\n@@ -1755,7 +1768,7 @@ cgraph_output_in_order (void)\n       nodes[i].u.v = pv;\n     }\n \n-  for (pa = cgraph_asm_nodes; pa; pa = pa->next)\n+  for (pa = asm_nodes; pa; pa = pa->next)\n     {\n       i = pa->order;\n       gcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n@@ -1775,7 +1788,7 @@ cgraph_output_in_order (void)\n \t{\n \tcase ORDER_FUNCTION:\n \t  nodes[i].u.f->process = 0;\n-\t  cgraph_expand_function (nodes[i].u.f);\n+\t  expand_function (nodes[i].u.f);\n \t  break;\n \n \tcase ORDER_VAR:\n@@ -1794,7 +1807,7 @@ cgraph_output_in_order (void)\n \t}\n     }\n \n-  cgraph_asm_nodes = NULL;\n+  asm_nodes = NULL;\n   free (nodes);\n }\n \n@@ -2054,7 +2067,7 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n      that is not weak also.\n      ??? We cannot use COMDAT linkage because there is no\n      ABI support for this.  */\n-  cgraph_make_decl_local (new_version_node->symbol.decl);\n+  symtab_make_decl_local (new_version_node->symbol.decl);\n   DECL_VIRTUAL_P (new_version_node->symbol.decl) = 0;\n   new_version_node->symbol.externally_visible = 0;\n   new_version_node->local.local = 1;\n@@ -2275,7 +2288,7 @@ cgraph_materialize_all_clones (void)\n /* Perform simple optimizations based on callgraph.  */\n \n void\n-cgraph_optimize (void)\n+compile (void)\n {\n   if (seen_error ())\n     return;\n@@ -2294,6 +2307,10 @@ cgraph_optimize (void)\n     fprintf (stderr, \"Performing interprocedural optimizations\\n\");\n   cgraph_state = CGRAPH_STATE_IPA;\n \n+  /* If LTO is enabled, initialize the streamer hooks needed by GIMPLE.  */\n+  if (flag_lto)\n+    lto_streamer_hooks_init ();\n+\n   /* Don't run the IPA passes if there was any error or sorry messages.  */\n   if (!seen_error ())\n     ipa_passes ();\n@@ -2338,20 +2355,18 @@ cgraph_optimize (void)\n   verify_symtab ();\n #endif\n   bitmap_obstack_release (NULL);\n-  cgraph_mark_functions_to_output ();\n+  mark_functions_to_output ();\n   output_weakrefs ();\n \n   cgraph_state = CGRAPH_STATE_EXPANSION;\n   if (!flag_toplevel_reorder)\n-    cgraph_output_in_order ();\n+    output_in_order ();\n   else\n     {\n-      cgraph_output_pending_asms ();\n-\n-      cgraph_expand_all_functions ();\n-      varpool_remove_unreferenced_decls ();\n+      output_asm_statements ();\n \n-      varpool_assemble_pending_decls ();\n+      expand_all_functions ();\n+      varpool_output_variables ();\n     }\n \n   cgraph_process_new_functions ();\n@@ -2388,14 +2403,10 @@ cgraph_optimize (void)\n /* Analyze the whole compilation unit once it is parsed completely.  */\n \n void\n-cgraph_finalize_compilation_unit (void)\n+finalize_compilation_unit (void)\n {\n   timevar_push (TV_CGRAPH);\n \n-  /* If LTO is enabled, initialize the streamer hooks needed by GIMPLE.  */\n-  if (flag_lto)\n-    lto_streamer_hooks_init ();\n-\n   /* If we're here there's no current function anymore.  Some frontends\n      are lazy in clearing these.  */\n   current_function_decl = NULL;\n@@ -2432,7 +2443,7 @@ cgraph_finalize_compilation_unit (void)\n   cgraph_analyze_functions ();\n \n   /* Finally drive the pass manager.  */\n-  cgraph_optimize ();\n+  compile ();\n \n   timevar_pop (TV_CGRAPH);\n }"}, {"sha": "5d1f8de4ed98521774c6603d9b8bd56b0dc0080e", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -1830,7 +1830,7 @@ maybe_emit_vtables (tree ctype)\n   tree vtbl;\n   tree primary_vtbl;\n   int needed = 0;\n-  struct varpool_node *current = NULL, *last = NULL, *first = NULL;\n+  struct varpool_node *current = NULL, *last = NULL;\n \n   /* If the vtables for this class have already been emitted there is\n      nothing more to do.  */\n@@ -1894,16 +1894,11 @@ maybe_emit_vtables (tree ctype)\n \t{\n \t  current = varpool_node (vtbl);\n \t  if (last)\n-\t    last->symbol.same_comdat_group = (symtab_node) current;\n+\t    symtab_add_to_same_comdat_group ((symtab_node) current, (symtab_node) last);\n \t  last = current;\n-\t  if (!first)\n-\t    first = current;\n \t}\n     }\n \n-  if (first != last)\n-    last->symbol.same_comdat_group = (symtab_node)first;\n-\n   /* Since we're writing out the vtable here, also write the debug\n      info.  */\n   note_debug_info_needed (ctype);\n@@ -4027,7 +4022,7 @@ cp_write_global_declarations (void)\n   timevar_stop (TV_PHASE_DEFERRED);\n   timevar_start (TV_PHASE_CGRAPH);\n \n-  cgraph_finalize_compilation_unit ();\n+  finalize_compilation_unit ();\n \n   timevar_stop (TV_PHASE_CGRAPH);\n   timevar_start (TV_PHASE_CHECK_DBGINFO);"}, {"sha": "77f8839828aa30cb8303957697ea14deb728b822", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -389,7 +389,8 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \t\t\t\t this_adjusting, fixed_offset, virtual_value,\n \t\t\t\t virtual_offset, alias);\n   if (DECL_ONE_ONLY (function))\n-    cgraph_add_to_same_comdat_group (thunk_node, funcn);\n+    symtab_add_to_same_comdat_group ((symtab_node) thunk_node,\n+\t\t\t\t     (symtab_node) funcn);\n \n   if (!this_adjusting\n       || !targetm.asm_out.can_output_mi_thunk (thunk_fndecl, fixed_offset,"}, {"sha": "5698c975a48505405370df014dc7c0c8c1cb2e34", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -324,8 +324,8 @@ maybe_clone_body (tree fn)\n \t\t *[CD][12]*.  */\n \t      comdat_group = cdtor_comdat_group (fns[1], fns[0]);\n \t      DECL_COMDAT_GROUP (fns[0]) = comdat_group;\n-\t      cgraph_add_to_same_comdat_group (cgraph_get_node (clone),\n-\t\t\t\t\t       cgraph_get_node (fns[0]));\n+\t      symtab_add_to_same_comdat_group (symtab_get_node (clone),\n+\t\t\t\t\t       symtab_get_node (fns[0]));\n \t    }\n \t}\n \n@@ -337,8 +337,9 @@ maybe_clone_body (tree fn)\n \t  /* If *[CD][12]* dtors go into the *[CD]5* comdat group and dtor is\n \t     virtual, it goes into the same comdat group as well.  */\n \t  if (comdat_group)\n-\t    cgraph_add_to_same_comdat_group (cgraph_get_create_node (clone),\n-\t\t\t\t\t     cgraph_get_node (fns[0]));\n+\t    symtab_add_to_same_comdat_group\n+\t       ((symtab_node) cgraph_get_create_node (clone),\n+\t        symtab_get_node (fns[0]));\n \t}\n       else if (alias)\n \t/* No need to populate body.  */ ;"}, {"sha": "0c423536dd7447c200ed701aaf2496d0e018b806", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -15377,7 +15377,7 @@ cp_parser_asm_definition (cp_parser* parser)\n \t    }\n \t}\n       else\n-\tcgraph_add_asm_node (string);\n+\tadd_asm_node (string);\n     }\n }\n "}, {"sha": "90378dc4122ee3702a4cf30db8f8db0e320797c2", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -9330,8 +9330,9 @@ maybe_add_lambda_conv_op (tree type)\n   if (DECL_ONE_ONLY (statfn))\n     {\n       /* Put the thunk in the same comdat group as the call op.  */\n-      cgraph_add_to_same_comdat_group (cgraph_get_create_node (statfn),\n-\t\t\t\t       cgraph_get_create_node (callop));\n+      symtab_add_to_same_comdat_group\n+\t ((symtab_node) cgraph_get_create_node (statfn),\n+          (symtab_node) cgraph_get_create_node (callop));\n     }\n   body = begin_function_body ();\n   compound_stmt = begin_compound_stmt (0);"}, {"sha": "8bbf95477a7d1851fc2bef714d76d373537a0adc", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -20378,7 +20378,7 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n   text_section_line_info->end_label = text_end_label;\n }\n \n-/* Called before cgraph_optimize starts outputtting functions, variables\n+/* Called before compile () starts outputtting functions, variables\n    and toplevel asms into assembly.  */\n \n static void"}, {"sha": "ee13c2f94f5979cf896497dd8104f7fbc93ddb46", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -1,3 +1,7 @@\n+2012-04-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* f95-lang.c (gfc_finish): Update comments.\n+\n 2012-04-29  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/53148"}, {"sha": "3f0c3033673afb47995b2fa273128750c4f12689", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -242,11 +242,11 @@ gfc_finish (void)\n /* ??? This is something of a hack.\n \n    Emulated tls lowering needs to see all TLS variables before we call\n-   cgraph_finalize_compilation_unit.  The C/C++ front ends manage this\n+   finalize_compilation_unit.  The C/C++ front ends manage this\n    by calling decl_rest_of_compilation on each global and static variable\n    as they are seen.  The Fortran front end waits until this hook.\n \n-   A Correct solution is for cgraph_finalize_compilation_unit not to be\n+   A Correct solution is for finalize_compilation_unit not to be\n    called during the WRITE_GLOBALS langhook, and have that hook only do what\n    its name suggests and write out globals.  But the C++ and Java front ends\n    have (unspecified) problems with aliases that gets in the way.  It has"}, {"sha": "951d3f9a137e253b2916f47ca03b6aa460f3f329", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -1,3 +1,7 @@\n+2012-04-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gogo-tree.cc (Gogo::write_globals): Use finalize_compilation_unit.\n+\n 2012-04-23  Ian Lance Taylor  <iant@google.com>\n \n \t* go-lang.c (go_langhook_init): Set MPFR precision to 256."}, {"sha": "7f7323869599a8094d1a3db46d80fdeaf4e72114", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -930,7 +930,7 @@ Gogo::write_globals()\n \n   wrapup_global_declarations(vec, count);\n \n-  cgraph_finalize_compilation_unit();\n+  finalize_compilation_unit();\n \n   check_global_declarations(vec, count);\n   emit_debug_global_declarations(vec, count);"}, {"sha": "1c77e86723a27980f4a97c8a64618dc072de9b04", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -157,6 +157,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t     For now we keep the ohter functions in the group in program until\n \t     cgraph_remove_unreachable_functions gets rid of them.  */\n \t  gcc_assert (!e->callee->global.inlined_to);\n+          symtab_dissolve_same_comdat_group_list ((symtab_node) e->callee);\n \t  if (e->callee->analyzed && !DECL_EXTERNAL (e->callee->symbol.decl))\n \t    {\n \t      if (overall_size)\n@@ -176,6 +177,8 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t  cgraph_redirect_edge_callee (e, n);\n \t}\n     }\n+  else\n+    symtab_dissolve_same_comdat_group_list ((symtab_node) e->callee);\n \n   if (e->caller->global.inlined_to)\n     e->callee->global.inlined_to = e->caller->global.inlined_to;\n@@ -355,7 +358,7 @@ save_inline_function_body (struct cgraph_node *node)\n \n /* Return true when function body of DECL still needs to be kept around\n    for later re-use.  */\n-bool\n+static bool\n preserve_function_body_p (struct cgraph_node *node)\n {\n   gcc_assert (cgraph_global_info_ready);"}, {"sha": "a722386934b3df1c0794ffe0c876c759c737d413", "filename": "gcc/ipa.c", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -598,7 +598,7 @@ cgraph_externally_visible_p (struct cgraph_node *node,\n     return true;\n \n   /* If linker counts on us, we must preserve the function.  */\n-  if (cgraph_used_from_object_file_p (node))\n+  if (symtab_used_from_object_file_p ((symtab_node) node))\n     return true;\n   if (DECL_PRESERVE_P (node->symbol.decl))\n     return true;\n@@ -657,7 +657,7 @@ varpool_externally_visible_p (struct varpool_node *vnode, bool aliased)\n     return true;\n \n   /* If linker counts on us, we must preserve the function.  */\n-  if (varpool_used_from_object_file_p (vnode))\n+  if (symtab_used_from_object_file_p ((symtab_node) vnode))\n     return true;\n \n   if (DECL_HARD_REGISTER (vnode->symbol.decl))\n@@ -678,7 +678,7 @@ varpool_externally_visible_p (struct varpool_node *vnode, bool aliased)\n      Even if the linker clams the symbol is unused, never bring internal\n      symbols that are declared by user as used or externally visible.\n      This is needed for i.e. references from asm statements.   */\n-  if (varpool_used_from_object_file_p (vnode))\n+  if (symtab_used_from_object_file_p ((symtab_node) vnode))\n     return true;\n   if (vnode->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY)\n     return false;\n@@ -716,21 +716,6 @@ varpool_externally_visible_p (struct varpool_node *vnode, bool aliased)\n   return false;\n }\n \n-/* Dissolve the same_comdat_group list in which NODE resides.  */\n-\n-static void\n-dissolve_same_comdat_group_list (symtab_node node)\n-{\n-  symtab_node n = node, next;\n-  do\n-    {\n-      next = n->symbol.same_comdat_group;\n-      n->symbol.same_comdat_group = NULL;\n-      n = next;\n-    }\n-  while (n != node);\n-}\n-\n /* Mark visibility of all functions.\n \n    A local function is one whose calls can occur only in the current\n@@ -825,7 +810,7 @@ function_and_variable_visibility (bool whole_program)\n \t\t all of them have to be, otherwise it is a front-end bug.  */\n \t      gcc_assert (DECL_EXTERNAL (n->symbol.decl));\n #endif\n-\t  dissolve_same_comdat_group_list ((symtab_node) node);\n+\t  symtab_dissolve_same_comdat_group_list ((symtab_node) node);\n \t}\n       gcc_assert ((!DECL_WEAK (node->symbol.decl)\n \t\t  && !DECL_COMDAT (node->symbol.decl))\n@@ -845,14 +830,14 @@ function_and_variable_visibility (bool whole_program)\n \t{\n \t  gcc_assert (whole_program || in_lto_p\n \t\t      || !TREE_PUBLIC (node->symbol.decl));\n-\t  cgraph_make_decl_local (node->symbol.decl);\n+\t  symtab_make_decl_local (node->symbol.decl);\n \t  node->symbol.resolution = LDPR_PREVAILING_DEF_IRONLY;\n \t  if (node->symbol.same_comdat_group)\n \t    /* cgraph_externally_visible_p has already checked all other nodes\n \t       in the group and they will all be made local.  We need to\n \t       dissolve the group at once so that the predicate does not\n \t       segfault though. */\n-\t    dissolve_same_comdat_group_list ((symtab_node) node);\n+\t    symtab_dissolve_same_comdat_group_list ((symtab_node) node);\n \t}\n \n       if (node->thunk.thunk_p\n@@ -921,9 +906,9 @@ function_and_variable_visibility (bool whole_program)\n       if (!vnode->symbol.externally_visible)\n \t{\n \t  gcc_assert (in_lto_p || whole_program || !TREE_PUBLIC (vnode->symbol.decl));\n-\t  cgraph_make_decl_local (vnode->symbol.decl);\n+\t  symtab_make_decl_local (vnode->symbol.decl);\n \t  if (vnode->symbol.same_comdat_group)\n-\t    dissolve_same_comdat_group_list ((symtab_node) vnode);\n+\t    symtab_dissolve_same_comdat_group_list ((symtab_node) vnode);\n \t  vnode->symbol.resolution = LDPR_PREVAILING_DEF_IRONLY;\n \t}\n      gcc_assert (TREE_STATIC (vnode->symbol.decl));"}, {"sha": "cb5da8c36feb44ac3ec9bce5d1f8f58b0c838aaa", "filename": "gcc/langhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -300,7 +300,7 @@ write_global_declarations (void)\n \n   /* This lang hook is dual-purposed, and also finalizes the\n      compilation unit.  */\n-  cgraph_finalize_compilation_unit ();\n+  finalize_compilation_unit ();\n \n   /* Really define vars that have had only a tentative definition.\n      Really output inline functions that must actually be callable"}, {"sha": "24d8d4f6025d17b1a2f8ac8e4493b815647fae05", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -1223,7 +1223,7 @@ lto_input_toplevel_asms (struct lto_file_decl_data *file_data, int order_base)\n \n   while ((str = streamer_read_string_cst (data_in, &ib)))\n     {\n-      struct cgraph_asm_node *node = cgraph_add_asm_node (str);\n+      struct asm_node *node = add_asm_node (str);\n       node->order = streamer_read_hwi (&ib) + order_base;\n       if (node->order >= symtab_order)\n \tsymtab_order = node->order + 1;"}, {"sha": "9a54f1900ffaf930cffa48c6d68c045a9d917704", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -968,20 +968,20 @@ void\n lto_output_toplevel_asms (void)\n {\n   struct output_block *ob;\n-  struct cgraph_asm_node *can;\n+  struct asm_node *can;\n   char *section_name;\n   struct lto_output_stream *header_stream;\n   struct lto_asm_header header;\n \n-  if (! cgraph_asm_nodes)\n+  if (! asm_nodes)\n     return;\n \n   ob = create_output_block (LTO_section_asm);\n \n   /* Make string 0 be a NULL string.  */\n   streamer_write_char_stream (ob->string_stream, 0);\n \n-  for (can = cgraph_asm_nodes; can; can = can->next)\n+  for (can = asm_nodes; can; can = can->next)\n     {\n       streamer_write_string_cst (ob, ob->main_stream, can->asm_str);\n       streamer_write_hwi (ob, can->order);"}, {"sha": "f9c5d3028bbe9e154c8c6fcc4ea8960036bc4f6b", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -1,3 +1,9 @@\n+2012-04-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (lto_main): Use compile ().\n+\t* lto-partition.c (partition_cgraph_node_p): Use symtab_used_from_object_file_p.\n+\t(partition_varpool_node_p): Likewise.\n+\n 2012-04-20  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-partition.c (partition_cgraph_node_p): Use force_output."}, {"sha": "5c931e682af65ae4490e3fcb3fbc44095d4974c2", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -270,7 +270,7 @@ partition_cgraph_node_p (struct cgraph_node *node)\n   if (DECL_EXTERNAL (node->symbol.decl)\n       || (DECL_COMDAT (node->symbol.decl)\n \t  && !node->symbol.force_output\n-\t  && !cgraph_used_from_object_file_p (node)))\n+\t  && !symtab_used_from_object_file_p ((symtab_node) node)))\n     return false;\n   if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n     return false;\n@@ -289,7 +289,7 @@ partition_varpool_node_p (struct varpool_node *vnode)\n   if (DECL_IN_CONSTANT_POOL (vnode->symbol.decl)\n       || (DECL_COMDAT (vnode->symbol.decl)\n \t  && !vnode->symbol.force_output\n-\t  && !varpool_used_from_object_file_p (vnode)))\n+\t  && !symtab_used_from_object_file_p ((symtab_node) vnode)))\n     return false;\n   if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (vnode->symbol.decl)))\n     return false;"}, {"sha": "32fc869e9835aa1a73423cfadf0699de6ab185c8", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -2116,7 +2116,7 @@ lto_main (void)\n \n \t  /* Let the middle end know that we have read and merged all of\n \t     the input files.  */ \n-\t  cgraph_optimize ();\n+\t  compile ();\n \n \t  /* FIXME lto, if the processes spawned by WPA fail, we miss\n \t     the chance to print WPA's report, so WPA will call"}, {"sha": "d6b9b9bc84f23a01632d1911028537c877e8db5e", "filename": "gcc/passes.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -1248,19 +1248,24 @@ register_pass (struct register_pass_info *pass_info)\n /* Construct the pass tree.  The sequencing of passes is driven by\n    the cgraph routines:\n \n-   cgraph_finalize_compilation_unit ()\n+   finalize_compilation_unit ()\n        for each node N in the cgraph\n \t   cgraph_analyze_function (N)\n \t       cgraph_lower_function (N) -> all_lowering_passes\n \n-   If we are optimizing, cgraph_optimize is then invoked:\n+   If we are optimizing, compile is then invoked:\n \n-   cgraph_optimize ()\n+   compile ()\n        ipa_passes () \t\t\t-> all_small_ipa_passes\n-       cgraph_expand_all_functions ()\n+\t\t\t\t\t-> Analysis of all_regular_ipa_passes\n+\t* possible LTO streaming at copmilation time *\n+\t\t\t\t\t-> Execution of all_regular_ipa_passes\n+\t* possible LTO streaming at link time *\n+\t\t\t\t\t-> all_late_ipa_passes\n+       expand_all_functions ()\n            for each node N in the cgraph\n-\t       cgraph_expand_function (N)\n-\t\t  tree_rest_of_compilation (DECL (N))  -> all_passes\n+\t       expand_function (N)      -> Transformation of all_regular_ipa_passes\n+\t\t\t\t        -> all_passes\n */\n \n void"}, {"sha": "1d9fdd881085755152e97bdf63e0d97486b30676", "filename": "gcc/symtab.c", "status": "modified", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -30,6 +30,22 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"diagnostic.h\"\n #include \"timevar.h\"\n+#include \"lto-streamer.h\"\n+#include \"rtl.h\"\n+\n+const char * const ld_plugin_symbol_resolution_names[]=\n+{\n+  \"\",\n+  \"undef\",\n+  \"prevailing_def\",\n+  \"prevailing_def_ironly\",\n+  \"preempted_reg\",\n+  \"preempted_ir\",\n+  \"resolved_ir\",\n+  \"resolved_exec\",\n+  \"resolved_dyn\",\n+  \"prevailing_def_ironly_exp\"\n+};\n \n /* Hash table used to convert declarations into nodes.  */\n static GTY((param_is (union symtab_node_def))) htab_t symtab_hash;\n@@ -335,6 +351,49 @@ change_decl_assembler_name (tree decl, tree name)\n     }\n }\n \n+/* Add NEW_ to the same comdat group that OLD is in.  */\n+\n+void\n+symtab_add_to_same_comdat_group (symtab_node new_node,\n+\t\t\t\t symtab_node old_node)\n+{\n+  gcc_assert (DECL_ONE_ONLY (old_node->symbol.decl));\n+  gcc_assert (!new_node->symbol.same_comdat_group);\n+  gcc_assert (new_node != old_node);\n+\n+  DECL_COMDAT_GROUP (new_node->symbol.decl) = DECL_COMDAT_GROUP (old_node->symbol.decl);\n+  new_node->symbol.same_comdat_group = old_node;\n+  if (!old_node->symbol.same_comdat_group)\n+    old_node->symbol.same_comdat_group = new_node;\n+  else\n+    {\n+      symtab_node n;\n+      for (n = old_node->symbol.same_comdat_group;\n+\t   n->symbol.same_comdat_group != old_node;\n+\t   n = n->symbol.same_comdat_group)\n+\t;\n+      n->symbol.same_comdat_group = new_node;\n+    }\n+}\n+\n+/* Dissolve the same_comdat_group list in which NODE resides.  */\n+\n+void\n+symtab_dissolve_same_comdat_group_list (symtab_node node)\n+{\n+  symtab_node n = node, next;\n+\n+  if (!node->symbol.same_comdat_group)\n+    return;\n+  do\n+    {\n+      next = n->symbol.same_comdat_group;\n+      n->symbol.same_comdat_group = NULL;\n+      n = next;\n+    }\n+  while (n != node);\n+}\n+\n /* Return printable assembler name of NODE.\n    This function is used only for debugging.  When assembler name\n    is unknown go with identifier name.  */\n@@ -611,4 +670,82 @@ verify_symtab (void)\n    verify_symtab_node (node);\n }\n \n+/* Return true when RESOLUTION indicate that linker will use\n+   the symbol from non-LTO object files.  */\n+\n+bool\n+resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution resolution)\n+{\n+  return (resolution == LDPR_PREVAILING_DEF\n+          || resolution == LDPR_PREEMPTED_REG\n+          || resolution == LDPR_RESOLVED_EXEC\n+          || resolution == LDPR_RESOLVED_DYN);\n+}\n+\n+/* Return true when NODE is known to be used from other (non-LTO) object file.\n+   Known only when doing LTO via linker plugin.  */\n+\n+bool\n+symtab_used_from_object_file_p (symtab_node node)\n+{\n+  if (!TREE_PUBLIC (node->symbol.decl) || DECL_EXTERNAL (node->symbol.decl))\n+    return false;\n+  if (resolution_used_from_other_file_p (node->symbol.resolution))\n+    return true;\n+  return false;\n+}\n+\n+/* Make DECL local.  FIXME: We shouldn't need to mess with rtl this early,\n+   but other code such as notice_global_symbol generates rtl.  */\n+void\n+symtab_make_decl_local (tree decl)\n+{\n+  rtx rtl, symbol;\n+\n+  if (TREE_CODE (decl) == VAR_DECL)\n+    DECL_COMMON (decl) = 0;\n+  else gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n+\n+  if (DECL_ONE_ONLY (decl) || DECL_COMDAT (decl))\n+    {\n+      /* It is possible that we are linking against library defining same COMDAT\n+\t function.  To avoid conflict we need to rename our local name of the\n+\t function just in the case WHOPR partitioning decide to make it hidden\n+\t to avoid cross partition references.  */\n+      if (flag_wpa)\n+\t{\n+\t  const char *old_name;\n+          symtab_node node = symtab_get_node (decl);\n+\t  old_name  = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+\t  change_decl_assembler_name (decl,\n+\t\t\t\t      clone_function_name (decl, \"local\"));\n+\t  if (node->symbol.lto_file_data)\n+\t    lto_record_renamed_decl (node->symbol.lto_file_data,\n+\t\t\t\t     old_name,\n+\t\t\t\t     IDENTIFIER_POINTER\n+\t\t\t\t       (DECL_ASSEMBLER_NAME (decl)));\n+\t}\n+      DECL_SECTION_NAME (decl) = 0;\n+      DECL_COMDAT (decl) = 0;\n+    }\n+  DECL_COMDAT_GROUP (decl) = 0;\n+  DECL_WEAK (decl) = 0;\n+  DECL_EXTERNAL (decl) = 0;\n+  TREE_PUBLIC (decl) = 0;\n+  if (!DECL_RTL_SET_P (decl))\n+    return;\n+\n+  /* Update rtl flags.  */\n+  make_decl_rtl (decl);\n+\n+  rtl = DECL_RTL (decl);\n+  if (!MEM_P (rtl))\n+    return;\n+\n+  symbol = XEXP (rtl, 0);\n+  if (GET_CODE (symbol) != SYMBOL_REF)\n+    return;\n+\n+  SYMBOL_REF_WEAK (symbol) = DECL_WEAK (decl);\n+}\n #include \"gt-symtab.h\""}, {"sha": "7d7be83e28ea30fc00fa149fbce0552fa96e1fb9", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -567,7 +567,7 @@ compile_file (void)\n \n   ggc_protect_identifiers = false;\n \n-  /* This must also call cgraph_finalize_compilation_unit.  */\n+  /* This must also call finalize_compilation_unit.  */\n   lang_hooks.decls.final_write_globals ();\n \n   if (seen_error ())\n@@ -580,8 +580,7 @@ compile_file (void)\n      basically finished.  */\n   if (in_lto_p || !flag_lto || flag_fat_lto_objects)\n     {\n-      varpool_remove_unreferenced_decls ();\n-      varpool_assemble_pending_decls ();\n+      varpool_output_variables ();\n       finish_aliases_2 ();\n \n       /* Likewise for mudflap static object registrations.  */"}, {"sha": "103b5b5f810b8e4587b82697ea2ee2df7e4b4e2c", "filename": "gcc/varpool.c", "status": "modified", "additions": 6, "deletions": 38, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d630d474e1beedfc6a06a4857c08f2cf781d5e/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=65d630d474e1beedfc6a06a4857c08f2cf781d5e", "patch": "@@ -237,34 +237,13 @@ varpool_analyze_node (struct varpool_node *node)\n \t  }\n       if (!VEC_length (ipa_ref_t, node->symbol.ref_list.references))\n \tipa_record_reference ((symtab_node)node, (symtab_node)tgt, IPA_REF_ALIAS, NULL);\n-      /* C++ FE sometimes change linkage flags after producing same body aliases.  */\n       if (node->extra_name_alias)\n \t{\n \t  DECL_WEAK (node->symbol.decl) = DECL_WEAK (node->alias_of);\n-\t  TREE_PUBLIC (node->symbol.decl) = TREE_PUBLIC (node->alias_of);\n \t  DECL_EXTERNAL (node->symbol.decl) = DECL_EXTERNAL (node->alias_of);\n \t  DECL_VISIBILITY (node->symbol.decl) = DECL_VISIBILITY (node->alias_of);\n-\t  if (TREE_PUBLIC (node->symbol.decl))\n-\t    {\n-\t      DECL_COMDAT (node->symbol.decl) = DECL_COMDAT (node->alias_of);\n-\t      DECL_COMDAT_GROUP (node->symbol.decl) = DECL_COMDAT_GROUP (node->alias_of);\n-\t      if (DECL_ONE_ONLY (node->alias_of)\n-\t\t  && !node->symbol.same_comdat_group)\n-\t\t{\n-\t\t  node->symbol.same_comdat_group = (symtab_node)tgt;\n-\t\t  if (!tgt->symbol.same_comdat_group)\n-\t\t    tgt->symbol.same_comdat_group = (symtab_node)node;\n-\t\t  else\n-\t\t    {\n-\t\t      symtab_node n;\n-\t\t      for (n = tgt->symbol.same_comdat_group;\n-\t\t\t   n->symbol.same_comdat_group != (symtab_node)tgt;\n-\t\t\t   n = n->symbol.same_comdat_group)\n-\t\t\t;\n-\t\t      n->symbol.same_comdat_group = (symtab_node)node;\n-\t\t    }\n-\t\t}\n-\t    }\n+\t  fixup_same_cpp_alias_visibility ((symtab_node) node,\n+\t\t\t\t\t   (symtab_node) tgt, node->alias_of);\n \t}\n     }\n   else if (DECL_INITIAL (decl))\n@@ -331,7 +310,7 @@ enqueue_node (struct varpool_node *node, struct varpool_node **first)\n    reachability starting from variables that are either externally visible\n    or was referred from the asm output routines.  */\n \n-void\n+static void\n varpool_remove_unreferenced_decls (void)\n {\n   struct varpool_node *next, *node;\n@@ -413,14 +392,16 @@ varpool_finalize_named_section_flags (struct varpool_node *node)\n \n /* Output all variables enqueued to be assembled.  */\n bool\n-varpool_assemble_pending_decls (void)\n+varpool_output_variables (void)\n {\n   bool changed = false;\n   struct varpool_node *node;\n \n   if (seen_error ())\n     return false;\n \n+  varpool_remove_unreferenced_decls ();\n+\n   timevar_push (TV_VAROUT);\n \n   FOR_EACH_DEFINED_VARIABLE (node)\n@@ -501,19 +482,6 @@ varpool_extra_name_alias (tree alias, tree decl)\n   return alias_node;\n }\n \n-/* Return true when NODE is known to be used from other (non-LTO) object file.\n-   Known only when doing LTO via linker plugin.  */\n-\n-bool\n-varpool_used_from_object_file_p (struct varpool_node *node)\n-{\n-  if (!TREE_PUBLIC (node->symbol.decl))\n-    return false;\n-  if (resolution_used_from_other_file_p (node->symbol.resolution))\n-    return true;\n-  return false;\n-}\n-\n /* Call calback on NODE and aliases asociated to NODE. \n    When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n    skipped. */"}]}