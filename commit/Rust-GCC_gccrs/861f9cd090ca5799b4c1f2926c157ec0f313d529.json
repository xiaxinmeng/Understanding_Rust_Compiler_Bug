{"sha": "861f9cd090ca5799b4c1f2926c157ec0f313d529", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYxZjljZDA5MGNhNTc5OWI0YzFmMjkyNmMxNTdlYzBmMzEzZDUyOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-06-20T17:10:11Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-06-20T17:10:11Z"}, "message": "predict.c (estimate_loops_at_level, [...]): New functions.\n\n\t* predict.c (estimate_loops_at_level, propagate_freq\n\testimate_bb_frequencies, count_to_freqs): New functions.\n\t(estimate_probability): Call estimate_bb_frequencies.\n\t* basic-block.h (basic_block_def): Add field \"freq\".\n\t(BB_FREQ_MAX): New constant.\n\nFrom-SVN: r43476", "tree": {"sha": "fcf4a6ca198466362d0368d4f30253d39e28915f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcf4a6ca198466362d0368d4f30253d39e28915f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/861f9cd090ca5799b4c1f2926c157ec0f313d529", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/861f9cd090ca5799b4c1f2926c157ec0f313d529", "html_url": "https://github.com/Rust-GCC/gccrs/commit/861f9cd090ca5799b4c1f2926c157ec0f313d529", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/861f9cd090ca5799b4c1f2926c157ec0f313d529/comments", "author": null, "committer": null, "parents": [{"sha": "c01b7cdf97e69255dd4a5dddda782ba29a32b3d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01b7cdf97e69255dd4a5dddda782ba29a32b3d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c01b7cdf97e69255dd4a5dddda782ba29a32b3d1"}], "stats": {"total": 291, "additions": 291, "deletions": 0}, "files": [{"sha": "d258e10a6c3d0c70f9def6d5b4ed2bec89fe7770", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861f9cd090ca5799b4c1f2926c157ec0f313d529/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861f9cd090ca5799b4c1f2926c157ec0f313d529/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=861f9cd090ca5799b4c1f2926c157ec0f313d529", "patch": "@@ -1,3 +1,11 @@\n+Wed Jun 20 19:08:18 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* predict.c (estimate_loops_at_level, propagate_freq\n+\testimate_bb_frequencies, count_to_freqs): New functions.\n+\t(estimate_probability): Call estimate_bb_frequencies.\n+\t* basic-block.h (basic_block_def): Add field \"freq\".\n+\t(BB_FREQ_MAX): New constant.\n+\n Wed Jun 20 17:02:50 2001  J\"orn Rennecke <amylaar@redhat.com>\n \n \t* sh.c (barrier_align): Don't ask for alignment when seeing a"}, {"sha": "95f7e48bcfad91709f2b3178e612806c19d4c265", "filename": "gcc/basic-block.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861f9cd090ca5799b4c1f2926c157ec0f313d529/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861f9cd090ca5799b4c1f2926c157ec0f313d529/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=861f9cd090ca5799b4c1f2926c157ec0f313d529", "patch": "@@ -202,7 +202,12 @@ typedef struct basic_block_def {\n \n   /* Expected number of executions: calculated in profile.c.  */\n   int count;\n+ \n+  /* Expected frequency.  Normalized to be in range 0 to BB_FREQ_MAX.  */\n+  int frequency;\n } *basic_block;\n+ \n+#define BB_FREQ_MAX 10000\n \n /* Number of basic blocks in the current function.  */\n "}, {"sha": "b3409a47ccfb5835b8e982797f3bd33e41f0704c", "filename": "gcc/predict.c", "status": "modified", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861f9cd090ca5799b4c1f2926c157ec0f313d529/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861f9cd090ca5799b4c1f2926c157ec0f313d529/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=861f9cd090ca5799b4c1f2926c157ec0f313d529", "patch": "@@ -60,6 +60,10 @@\n static void combine_predictions_for_insn PARAMS ((rtx, basic_block));\n static void dump_prediction\t\t PARAMS ((enum br_predictor, int,\n \t\t\t\t\t\t  basic_block));\n+static void estimate_loops_at_level\t PARAMS ((struct loop *loop));\n+static void propagate_freq\t\t PARAMS ((basic_block));\n+static void estimate_bb_frequencies\t PARAMS ((struct loops *));\n+static void counts_to_freqs\t\t PARAMS ((void));\n \n /* Information we hold about each branch predictor.\n    Filled using information from predict.def.  */\n@@ -436,6 +440,8 @@ estimate_probability (loops_info)\n     }\n   sbitmap_vector_free (post_dominators);\n   sbitmap_vector_free (dominators);\n+\n+  estimate_bb_frequencies (loops_info);\n }\n \f\n /* __builtin_expect dropped tokens into the insn stream describing\n@@ -511,3 +517,275 @@ expected_value_to_br_prob ()\n \t\t        cond == const1_rtx ? TAKEN : NOT_TAKEN);\n     }\n }\n+\f\n+/* This is used to carry information about basic blocks.  It is \n+   attached to the AUX field of the standard CFG block.  */\n+\n+typedef struct block_info_def\n+{\n+  /* Estimated frequency of execution of basic_block.  */\n+  double frequency;\n+\n+  /* To keep queue of basic blocks to process.  */\n+  basic_block next;\n+\n+  /* True if block already converted.  */\n+  int visited:1;\n+} *block_info;\n+\n+/* Similar information for edges.  */\n+typedef struct edge_info_def\n+{\n+  /* In case edge is an loopback edge, the probability edge will be reached\n+     in case header is.  Estimated number of iterations of the loop can be\n+     then computed as 1 / (1 - back_edge_prob).  */\n+  double back_edge_prob;\n+  /* True if the edge is an loopback edge in the natural loop.  */\n+  int back_edge:1;\n+} *edge_info;\n+\n+#define BLOCK_INFO(B)\t((block_info) (B)->aux)\n+#define EDGE_INFO(E)\t((edge_info) (E)->aux)\n+\n+/* Helper function for estimate_bb_frequencies.\n+   Propagate the frequencies for loops headed by HEAD.  */\n+static void\n+propagate_freq (head)\n+     basic_block head;\n+{\n+  basic_block bb = head;\n+  basic_block last = bb;\n+  edge e;\n+  basic_block nextbb;\n+\n+  BLOCK_INFO (head)->frequency = 1;\n+  for (; bb; bb = nextbb)\n+    {\n+      double cyclic_probability = 0, frequency = 0;\n+\n+      nextbb = BLOCK_INFO (bb)->next;\n+      BLOCK_INFO (bb)->next = NULL;\n+\n+      /* Compute frequency of basic block.  */\n+      if (bb != head)\n+\t{\n+\t  for (e = bb->pred; e; e = e->pred_next)\n+\t    if (!BLOCK_INFO (e->src)->visited && !EDGE_INFO (e)->back_edge)\n+\t      continue;\n+\n+\t  for (e = bb->pred; e; e = e->pred_next)\n+\t    if (EDGE_INFO (e)->back_edge)\n+\t      cyclic_probability += EDGE_INFO (e)->back_edge_prob;\n+\t    else\n+\t      frequency += (e->probability\n+\t\t\t    * BLOCK_INFO (e->src)->frequency /\n+\t\t\t    REG_BR_PROB_BASE);\n+\n+\t  if (cyclic_probability > 1.0 - 1.0 / REG_BR_PROB_BASE)\n+\t    cyclic_probability = 1.0 - 1.0 / REG_BR_PROB_BASE;\n+\n+\t  BLOCK_INFO (bb)->frequency = frequency / (1 - cyclic_probability);\n+\t}\n+\n+      BLOCK_INFO (bb)->visited = 1;\n+\n+      /* Compute back edge frequencies.  */\n+      for (e = bb->succ; e; e = e->succ_next)\n+\tif (e->dest == head)\n+\t  EDGE_INFO (e)->back_edge_prob = (e->probability\n+\t\t\t\t\t   * BLOCK_INFO (bb)->frequency\n+\t\t\t\t\t   / REG_BR_PROB_BASE);\n+\n+      /* Propagate to succesor blocks.  */\n+      for (e = bb->succ; e; e = e->succ_next)\n+\tif (!EDGE_INFO (e)->back_edge\n+\t    && !BLOCK_INFO (e->dest)->visited\n+\t    && !BLOCK_INFO (e->dest)->next && e->dest != last)\n+\t  {\n+\t    if (!nextbb)\n+\t      nextbb = e->dest;\n+\t    else\n+\t      BLOCK_INFO (last)->next = e->dest;\n+\t    last = e->dest;\n+\t  }\n+    }\n+}\n+\n+/* Estimate probabilities of the loopback edges in loops at same nest level.  */\n+static void\n+estimate_loops_at_level (first_loop)\n+     struct loop *first_loop;\n+{\n+  struct loop *l, *loop = first_loop;\n+\n+  for (loop = first_loop; loop; loop = loop->next)\n+    {\n+      int n;\n+      edge e;\n+\n+      estimate_loops_at_level (loop->inner);\n+\n+      /* find current loop back edge and mark it.  */\n+      for (e = loop->latch->succ; e->dest != loop->header; e = e->succ_next);\n+\n+      EDGE_INFO (e)->back_edge = 1;\n+\n+      /* In case loop header is shared, ensure that it is the last one sharing\n+         same header, so we avoid redundant work.  */\n+      if (loop->shared)\n+\t{\n+\t  for (l = loop->next; l; l = l->next)\n+\t    if (l->header == loop->header)\n+\t      break;\n+\t  if (l)\n+\t    continue;\n+\t}\n+\n+      /* Now merge all nodes of all loops with given header as not visited.  */\n+      for (l = loop->shared ? first_loop : loop; l != loop->next; l = l->next)\n+\tif (loop->header == l->header)\n+\t  EXECUTE_IF_SET_IN_SBITMAP (l->nodes, 0, n,\n+\t\t\t\t     BLOCK_INFO (BASIC_BLOCK (n))->visited =\n+\t\t\t\t     0);\n+      propagate_freq (loop->header);\n+    }\n+}\n+\n+/* Convert counts measured by profile driven feedback to frequencies.  */\n+static void\n+counts_to_freqs ()\n+{\n+  HOST_WIDEST_INT count_max = 1;\n+  int i;\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    if (BASIC_BLOCK (i)->count > count_max)\n+      count_max = BASIC_BLOCK (i)->count;\n+\n+  for (i = -2; i < n_basic_blocks; i++)\n+    {\n+      basic_block bb;\n+      if (i == -2)\n+\tbb = ENTRY_BLOCK_PTR;\n+      else if (i == -1)\n+\tbb = EXIT_BLOCK_PTR;\n+      else\n+\tbb = BASIC_BLOCK (i);\n+      bb->frequency = ((bb->count * BB_FREQ_MAX + count_max / 2)\n+\t\t       / count_max);\n+    }\n+}\n+\n+/* Estimate basic blocks frequency by given branch probabilities.  */\n+static void\n+estimate_bb_frequencies (loops)\n+     struct loops *loops;\n+{\n+  block_info bi;\n+  edge_info ei;\n+  int edgenum = 0;\n+  int i;\n+  double freq_max = 0;\n+\n+  if (flag_branch_probabilities)\n+    {\n+      counts_to_freqs ();\n+      return;\n+    }\n+\n+  /* Fill in the probability values in flowgraph based on the REG_BR_PROB\n+     notes.  */\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      rtx last_insn = BLOCK_END (i);\n+      int probability;\n+      edge fallthru, branch;\n+\n+      if (GET_CODE (last_insn) != JUMP_INSN || !any_condjump_p (last_insn))\n+\t{\n+\t  /* We can predict only conditional jumps at the moment.\n+\t     Expect each edge to be equall probable.\n+\t     ?? In future we want to make abnormal edges improbable.  */\n+\t  int nedges = 0;\n+\t  edge e;\n+\n+\t  for (e = BASIC_BLOCK (i)->succ; e; e = e->succ_next)\n+\t    {\n+\t      nedges++;\n+\t      if (e->probability != 0)\n+\t\tbreak;\n+\t    }\n+\t  if (!e)\n+\t    for (e = BASIC_BLOCK (i)->succ; e; e = e->succ_next)\n+\t      e->probability = (REG_BR_PROB_BASE + nedges / 2) / nedges;\n+\t}\n+      else\n+\t{\n+\t  probability = INTVAL (XEXP (find_reg_note (last_insn,\n+\t\t\t\t\t\t     REG_BR_PROB, 0), 0));\n+\t  fallthru = BASIC_BLOCK (i)->succ;\n+\t  if (!fallthru->flags & EDGE_FALLTHRU)\n+\t    fallthru = fallthru->succ_next;\n+\t  branch = BASIC_BLOCK (i)->succ;\n+\t  if (branch->flags & EDGE_FALLTHRU)\n+\t    branch = branch->succ_next;\n+\n+\t  branch->probability = probability;\n+\t  fallthru->probability = REG_BR_PROB_BASE - probability;\n+\t}\n+    }\n+  ENTRY_BLOCK_PTR->succ->probability = REG_BR_PROB_BASE;\n+\n+  /* Set up block info for each basic block.  */\n+  bi = (block_info) xcalloc ((n_basic_blocks + 2), sizeof (*bi));\n+  ei = (edge_info) xcalloc ((n_edges), sizeof (*ei));\n+  for (i = -2; i < n_basic_blocks; i++)\n+    {\n+      edge e;\n+      basic_block bb;\n+\n+      if (i == -2)\n+\tbb = ENTRY_BLOCK_PTR;\n+      else if (i == -1)\n+\tbb = EXIT_BLOCK_PTR;\n+      else\n+\tbb = BASIC_BLOCK (i);\n+      bb->aux = bi + i + 2;\n+      BLOCK_INFO (bb)->visited = 1;\n+      for (e = bb->succ; e; e = e->succ_next)\n+\t{\n+\t  e->aux = ei + edgenum, edgenum++;\n+\t  EDGE_INFO (e)->back_edge_prob = ((double) e->probability\n+\t\t\t\t\t   / REG_BR_PROB_BASE);\n+\t}\n+    }\n+  /* First compute probabilities locally for each loop from innermost\n+     to outermost to examine probabilities for back edges.  */\n+  estimate_loops_at_level (loops->tree);\n+\n+  /* Now fake loop around whole function to finalize probabilities.  */\n+  for (i = 0; i < n_basic_blocks; i++)\n+    BLOCK_INFO (BASIC_BLOCK (i))->visited = 0;\n+  BLOCK_INFO (ENTRY_BLOCK_PTR)->visited = 0;\n+  BLOCK_INFO (EXIT_BLOCK_PTR)->visited = 0;\n+  propagate_freq (ENTRY_BLOCK_PTR);\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    if (BLOCK_INFO (BASIC_BLOCK (i))->frequency > freq_max)\n+      freq_max = BLOCK_INFO (BASIC_BLOCK (i))->frequency;\n+  for (i = -2; i < n_basic_blocks; i++)\n+    {\n+      basic_block bb;\n+      if (i == -2)\n+\tbb = ENTRY_BLOCK_PTR;\n+      else if (i == -1)\n+\tbb = EXIT_BLOCK_PTR;\n+      else\n+\tbb = BASIC_BLOCK (i);\n+      bb->frequency = (BLOCK_INFO (bb)->frequency * BB_FREQ_MAX / freq_max\n+\t\t       + 0.5);\n+    }\n+\n+  free (ei);\n+  free (bi);\n+}"}]}