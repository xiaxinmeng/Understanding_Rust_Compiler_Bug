{"sha": "9a18e785b8c1ad490a3bb00a88735f57c0c60e4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWExOGU3ODViOGMxYWQ0OTBhM2JiMDBhODg3MzVmNTdjMGM2MGU0Yg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2008-03-26T07:42:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-03-26T07:42:47Z"}, "message": "sem_warn.ads, [...] (Warnings_Off_Pragmas): New table\n\n2008-03-26  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_warn.ads, sem_warn.adb (Warnings_Off_Pragmas): New table\n\t(Initialize): New procedure\n\t(Output_Warnings_Off_Warnings): New procedure\n\t(Check_References): Suppress certain msgs if Is_Trivial_Subprogram\n\t(Output_Non_Modifed_In_Out_Warnings): Ditto\n\t(Warn_On_Unreferenced_Entity): Ditto\n\nFrom-SVN: r133580", "tree": {"sha": "e208a215de2d37cf1eaf06ed6e41fe03c3628f7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e208a215de2d37cf1eaf06ed6e41fe03c3628f7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a18e785b8c1ad490a3bb00a88735f57c0c60e4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a18e785b8c1ad490a3bb00a88735f57c0c60e4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a18e785b8c1ad490a3bb00a88735f57c0c60e4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a18e785b8c1ad490a3bb00a88735f57c0c60e4b/comments", "author": null, "committer": null, "parents": [{"sha": "26570b21745ef73ffb6df68712cd3fb6932fe602", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26570b21745ef73ffb6df68712cd3fb6932fe602", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26570b21745ef73ffb6df68712cd3fb6932fe602"}], "stats": {"total": 603, "additions": 424, "deletions": 179}, "files": [{"sha": "81d866f5645cb8ce45251ae616543cf88a54c6fa", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 387, "deletions": 178, "changes": 565, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18e785b8c1ad490a3bb00a88735f57c0c60e4b/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18e785b8c1ad490a3bb00a88735f57c0c60e4b/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=9a18e785b8c1ad490a3bb00a88735f57c0c60e4b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1999-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -23,7 +23,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Alloc;\n with Atree;    use Atree;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n@@ -44,7 +43,6 @@ with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n-with Table;\n with Uintp;    use Uintp;\n \n package body Sem_Warn is\n@@ -67,9 +65,9 @@ package body Sem_Warn is\n    --  The reason that we defer output of these messages is that we want to\n    --  detect the case where the relevant procedure is used as a generic actual\n    --  in an instantation, since we suppress the warnings in this case. The\n-   --  flag Used_As_Generic_Actual will be set in this case, but will not be\n-   --  set till later. Similarly, we suppress the message if the address of\n-   --  the procedure is taken, where the flag Address_Taken may be set later.\n+   --  flag Used_As_Generic_Actual will be set in this case, but only at the\n+   --  point of usage. Similarly, we suppress the message if the address of the\n+   --  procedure is taken, where the flag Address_Taken may be set later.\n \n    package In_Out_Warnings is new Table.Table (\n      Table_Component_Type => Entity_Id,\n@@ -79,6 +77,39 @@ package body Sem_Warn is\n      Table_Increment      => Alloc.In_Out_Warnings_Increment,\n      Table_Name           => \"In_Out_Warnings\");\n \n+   --------------------------------------------------------\n+   -- Handling of Warnings Off, Unmodified, Unreferenced --\n+   --------------------------------------------------------\n+\n+   --  The functions Has_Warnings_Off, Has_Unmodified, Has_Unreferenced must\n+   --  generally be used instead of Warnings_Off, Has_Pragma_Unmodified and\n+   --  Has_Pragma_Unreferenced, as noted in the specs in Einfo.\n+\n+   --  In order to avoid losing warnings in -gnatw.w (warn on unnecessary\n+   --  warnings off pragma) mode, i.e. to avoid false negatives, the code\n+   --  must follow some important rules.\n+\n+   --  Call these functions as late as possible, after completing all other\n+   --  tests, just before the warnings is given. For example, don't write:\n+\n+   --     if not Has_Warnings_Off (E)\n+   --       and then some-other-predicate-on-E then ..\n+\n+   --  Instead the following is preferred\n+\n+   --     if somme-other-predicate-on-E\n+   --       and then Has_Warnings_Off (E)\n+\n+   --  This way if some-other-predicate is false, we avoid a false indication\n+   --  that a Warnings (Off,E) pragma was useful in preventing a warning.\n+\n+   --  The second rule is that if both Has_Unmodified and Has_Warnings_Off, or\n+   --  Has_Unreferenced and Has_Warnings_Off are called, make sure that the\n+   --  call to Has_Unmodified/Has_Unreferenced comes first, this way we record\n+   --  that the Warnings (Off) could have been Unreferenced or Unmodified. In\n+   --  fact Has_Unmodified/Has_Unreferenced includes a test for Warnings Off,\n+   --  and so a subsequent test is not needed anyway (though it is harmless).\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -145,6 +176,10 @@ package body Sem_Warn is\n    --  accept statement, and the message is posted on Body_E. In all other\n    --  cases, Body_E is ignored and must be Empty.\n \n+   function Warnings_Off_Check_Spec (E : Entity_Id) return Boolean;\n+   --  Returns True if Warnings_Off is set for the entity E or (in the case\n+   --  where there is a Spec_Entity), Warnings_Off is set for the Spec_Entity.\n+\n    --------------------------\n    -- Check_Code_Statement --\n    --------------------------\n@@ -275,15 +310,15 @@ package body Sem_Warn is\n             if not Is_Entity_Name (Name (N)) then\n                return;\n \n-            --  Forget it if warnings are suppressed on function entity\n+            --  Forget it if function name is suspicious. A strange test\n+            --  but warning generation is in the heuristics business!\n \n-            elsif Warnings_Off (Entity (Name (N))) then\n+            elsif Is_Suspicious_Function_Name (Entity (Name (N))) then\n                return;\n \n-               --  Forget it if function name is suspicious. A strange test\n-               --  but warning generation is in the heuristics business!\n+            --  Forget it if warnings are suppressed on function entity\n \n-            elsif Is_Suspicious_Function_Name (Entity (Name (N))) then\n+            elsif Has_Warnings_Off (Entity (Name (N))) then\n                return;\n             end if;\n \n@@ -592,6 +627,40 @@ package body Sem_Warn is\n       --  from another unit. This is true for entities in packages that are at\n       --  the library level.\n \n+      function Warnings_Off_E1 return Boolean;\n+      --  Return True if Warnings_Off is set for E1, or for its Etype (E1T),\n+      --  or for the base type of E1T.\n+\n+      -----------------\n+      -- Body_Formal --\n+      -----------------\n+\n+      function Body_Formal\n+        (E                : Entity_Id;\n+         Accept_Statement : Node_Id) return Entity_Id\n+      is\n+         Body_Param : Node_Id;\n+         Body_E     : Entity_Id;\n+\n+      begin\n+         --  Loop to find matching parameter in accept statement\n+\n+         Body_Param := First (Parameter_Specifications (Accept_Statement));\n+         while Present (Body_Param) loop\n+            Body_E := Defining_Identifier (Body_Param);\n+\n+            if Chars (Body_E) = Chars (E) then\n+               return Body_E;\n+            end if;\n+\n+            Next (Body_Param);\n+         end loop;\n+\n+         --  Should never fall through, should always find a match\n+\n+         raise Program_Error;\n+      end Body_Formal;\n+\n       ----------------------\n       -- Missing_Subunits --\n       ----------------------\n@@ -634,36 +703,6 @@ package body Sem_Warn is\n          end if;\n       end Missing_Subunits;\n \n-      -----------------\n-      -- Body_Formal --\n-      -----------------\n-\n-      function Body_Formal\n-        (E                : Entity_Id;\n-         Accept_Statement : Node_Id) return Entity_Id\n-      is\n-         Body_Param : Node_Id;\n-         Body_E     : Entity_Id;\n-\n-      begin\n-         --  Loop to find matching parameter in accept statement\n-\n-         Body_Param := First (Parameter_Specifications (Accept_Statement));\n-         while Present (Body_Param) loop\n-            Body_E := Defining_Identifier (Body_Param);\n-\n-            if Chars (Body_E) = Chars (E) then\n-               return Body_E;\n-            end if;\n-\n-            Next (Body_Param);\n-         end loop;\n-\n-         --  Should never fall through, should always find a match\n-\n-         raise Program_Error;\n-      end Body_Formal;\n-\n       ----------------------------\n       -- Output_Reference_Error --\n       ----------------------------\n@@ -790,6 +829,17 @@ package body Sem_Warn is\n          end loop;\n       end Publicly_Referenceable;\n \n+      ---------------------\n+      -- Warnings_Off_E1 --\n+      ---------------------\n+\n+      function Warnings_Off_E1 return Boolean is\n+      begin\n+         return Has_Warnings_Off (E1T)\n+           or else Has_Warnings_Off (Base_Type (E1T))\n+           or else Warnings_Off_Check_Spec (E1);\n+      end Warnings_Off_E1;\n+\n    --  Start of processing for Check_References\n \n    begin\n@@ -817,15 +867,11 @@ package body Sem_Warn is\n       while Present (E1) loop\n          E1T := Etype (E1);\n \n-         --  We only look at source entities with warning flag on. We also\n-         --  ignore objects whose type or base type has warnings suppressed.\n-         --  We also don't issue warnings within instances, since the proper\n-         --  place for such warnings is on the template when it is compiled.\n+         --  We are only interested in source entities. We also don't issue\n+         --  warnings within instances, since the proper place for such\n+         --  warnings is on the template when it is compiled.\n \n          if Comes_From_Source (E1)\n-           and then not Warnings_Off (E1)\n-           and then not Warnings_Off (E1T)\n-           and then not Warnings_Off (Base_Type (E1T))\n            and then Instantiation_Location (Sloc (E1)) = No_Location\n          then\n             --  We are interested in variables and out/in-out parameters, but\n@@ -850,18 +896,9 @@ package body Sem_Warn is\n                   UR := Unset_Reference (E1);\n                end if;\n \n-               --  If the entity is an out parameter of the current subprogram\n-               --  body, check the warning status of the parameter in the spec.\n-\n-               if Is_Formal (E1)\n-                 and then Present (Spec_Entity (E1))\n-                 and then Warnings_Off (Spec_Entity (E1))\n-               then\n-                  null;\n-\n                --  Special processing for access types\n \n-               elsif Present (UR)\n+               if Present (UR)\n                  and then Is_Access_Type (E1T)\n                then\n                   --  For access types, the only time we made a UR entry was\n@@ -872,7 +909,10 @@ package body Sem_Warn is\n                   --  assignment of a pointer involving discriminant check\n                   --  on the designated object).\n \n-                  Error_Msg_NE (\"?& may be null!\", UR, E1);\n+                  if not Warnings_Off_E1 then\n+                     Error_Msg_NE (\"?& may be null!\", UR, E1);\n+                  end if;\n+\n                   goto Continue;\n \n                --  Case of variable that could be a constant. Note that we\n@@ -916,10 +956,12 @@ package body Sem_Warn is\n                           and then not Has_Pragma_Unreferenced_Check_Spec (E1)\n                           and then not Has_Pragma_Unmodified_Check_Spec (E1)\n                         then\n-                           Error_Msg_N\n-                             (\"?& is not modified, \"\n-                              & \"could be declared constant!\",\n-                              E1);\n+                           if not Warnings_Off_E1 then\n+                              Error_Msg_N\n+                                (\"?& is not modified, \"\n+                                 & \"could be declared constant!\",\n+                                 E1);\n+                           end if;\n                         end if;\n                      end if;\n                   end if;\n@@ -959,12 +1001,15 @@ package body Sem_Warn is\n                             or else not Is_Fully_Initialized_Type (E1T))\n                then\n                   --  Do not output complaint about never being assigned a\n-                  --  value if a pragma Unreferenced applies to the variable\n+                  --  value if a pragma Unmodified applies to the variable\n                   --  we are examining, or if it is a parameter, if there is\n-                  --  a pragma Unreferenced for the corresponding spec.\n+                  --  a pragma Unreferenced for the corresponding spec, of\n+                  --  if the type is marked as having unreferenced objects.\n+                  --  The last is a little peculiar, but better too few than\n+                  --  too many warnings in this situation.\n \n-                  if Has_Pragma_Unreferenced_Check_Spec (E1)\n-                    or else Has_Pragma_Unreferenced_Objects (E1T)\n+                  if Has_Pragma_Unreferenced_Objects (E1T)\n+                    or else Has_Pragma_Unmodified_Check_Spec (E1)\n                   then\n                      null;\n \n@@ -985,7 +1030,7 @@ package body Sem_Warn is\n                      --  other method to achieve the local effect of a\n                      --  modification. On the other hand if the spec and body\n                      --  are in the same unit, we are in the package body and\n-                     --  there we less  excuse for a junk IN OUT parameter.\n+                     --  there we have less excuse for a junk IN OUT parameter.\n \n                      if Has_Private_Declaration (E1T)\n                        and then Present (Spec_Entity (E1))\n@@ -996,8 +1041,8 @@ package body Sem_Warn is\n                      --  Suppress warning for any parameter of a dispatching\n                      --  operation, since it is quite reasonable to have an\n                      --  operation that is overridden, and for some subclasses\n-                     --  needs to be IN OUT and for others the parameter does\n-                     --  not happen to be assigned.\n+                     --  needs the formal to be IN OUT and for others happens\n+                     --  not to assign it.\n \n                      elsif Is_Dispatching_Operation\n                              (Scope (Goto_Spec_Entity (E1)))\n@@ -1030,25 +1075,38 @@ package body Sem_Warn is\n                   --  Other cases of formals\n \n                   elsif Is_Formal (E1) then\n-                     if Referenced_Check_Spec (E1) then\n-                        if not Has_Pragma_Unmodified_Check_Spec (E1) then\n+                     if not Is_Trivial_Subprogram (Scope (E1)) then\n+                        if Referenced_Check_Spec (E1) then\n+                           if not Has_Pragma_Unmodified_Check_Spec (E1)\n+                             and then not Warnings_Off_E1\n+                           then\n+                              Output_Reference_Error\n+                                (\"?formal parameter& is read but \"\n+                                 & \"never assigned!\");\n+                           end if;\n+\n+                        elsif not Has_Pragma_Unreferenced_Check_Spec (E1)\n+                          and then not Warnings_Off_E1\n+                        then\n                            Output_Reference_Error\n-                             (\"?formal parameter& is read but \"\n-                              & \"never assigned!\");\n+                             (\"?formal parameter& is not referenced!\");\n                         end if;\n-\n-                     else\n-                        Output_Reference_Error\n-                          (\"?formal parameter& is not referenced!\");\n                      end if;\n \n                   --  Case of variable\n \n                   else\n                      if Referenced (E1) then\n-                        Output_Reference_Error\n-                          (\"?variable& is read but never assigned!\");\n-                     else\n+                        if not Has_Unmodified (E1)\n+                          and then not Warnings_Off_E1\n+                        then\n+                           Output_Reference_Error\n+                             (\"?variable& is read but never assigned!\");\n+                        end if;\n+\n+                     elsif not Has_Unreferenced (E1)\n+                       and then not Warnings_Off_E1\n+                     then\n                         Output_Reference_Error\n                           (\"?variable& is never read and never assigned!\");\n                      end if;\n@@ -1058,6 +1116,7 @@ package body Sem_Warn is\n \n                      if Ekind (E1) = E_Variable\n                        and then Present (Hiding_Loop_Variable (E1))\n+                       and then not Warnings_Off_E1\n                      then\n                         Error_Msg_N\n                           (\"?for loop implicitly declares loop variable!\",\n@@ -1100,75 +1159,88 @@ package body Sem_Warn is\n                   --  are only for functions, and functions do not allow OUT\n                   --  parameters.)\n \n-                  if Nkind (UR) = N_Simple_Return_Statement\n-                    and then not Has_Pragma_Unmodified_Check_Spec (E1)\n-                  then\n-                     Error_Msg_NE\n-                       (\"?OUT parameter& not set before return\", UR, E1);\n+                  if not Is_Trivial_Subprogram (Scope (E1)) then\n+                     if Nkind (UR) = N_Simple_Return_Statement\n+                       and then not Has_Pragma_Unmodified_Check_Spec (E1)\n+                     then\n+                        if not Warnings_Off_E1 then\n+                           Error_Msg_NE\n+                             (\"?OUT parameter& not set before return\", UR, E1);\n+                        end if;\n \n-                  --  If the unset reference is prefix of a selected component\n-                  --  that comes from source, mention the component as well. If\n-                  --  the selected component comes from expansion, all we know\n-                  --  is that the entity is not fully initialized at the point\n-                  --  of the reference. Locate an unintialized component to get\n-                  --  a better error message.\n+                        --  If the unset reference is a selected component\n+                        --  prefix from source, mention the component as well.\n+                        --  If the selected component comes from expansion, all\n+                        --  we know is that the entity is not fully initialized\n+                        --  at the point of the reference. Locate a random\n+                        --  unintialized component to get a better message.\n \n-                  elsif Nkind (Parent (UR)) = N_Selected_Component then\n-                     Error_Msg_Node_2 := Selector_Name (Parent (UR));\n+                     elsif Nkind (Parent (UR)) = N_Selected_Component then\n+                        Error_Msg_Node_2 := Selector_Name (Parent (UR));\n \n-                     if not Comes_From_Source (Parent (UR)) then\n-                        declare\n-                           Comp : Entity_Id;\n+                        if not Comes_From_Source (Parent (UR)) then\n+                           declare\n+                              Comp : Entity_Id;\n \n-                        begin\n-                           Comp := First_Entity (E1T);\n-                           while Present (Comp) loop\n-                              if Ekind (Comp) = E_Component\n-                                and then Nkind (Parent (Comp)) =\n-                                                      N_Component_Declaration\n-                                and then No (Expression (Parent (Comp)))\n-                              then\n-                                 Error_Msg_Node_2 := Comp;\n-                                 exit;\n-                              end if;\n+                           begin\n+                              Comp := First_Entity (E1T);\n+                              while Present (Comp) loop\n+                                 if Ekind (Comp) = E_Component\n+                                   and then Nkind (Parent (Comp)) =\n+                                   N_Component_Declaration\n+                                   and then No (Expression (Parent (Comp)))\n+                                 then\n+                                    Error_Msg_Node_2 := Comp;\n+                                    exit;\n+                                 end if;\n+\n+                                 Next_Entity (Comp);\n+                              end loop;\n+                           end;\n+                        end if;\n \n-                              Next_Entity (Comp);\n-                           end loop;\n-                        end;\n-                     end if;\n+                        --  Issue proper warning. This is a case of referencing\n+                        --  a variable before it has been explicitly assigned.\n+                        --  For access types, UR was only set for dereferences,\n+                        --  so the issue is that the value may be null.\n+\n+                        if not Is_Trivial_Subprogram (Scope (E1)) then\n+                           if not Warnings_Off_E1 then\n+                              if Is_Access_Type (Etype (Parent (UR))) then\n+                                 Error_Msg_N (\"?`&.&` may be null!\", UR);\n+                              else\n+                                 Error_Msg_N\n+                                   (\"?`&.&` may be referenced before \"\n+                                    & \"it has a value!\", UR);\n+                              end if;\n+                           end if;\n+                        end if;\n \n-                     --  Issue proper warning. This is a case of referencing\n-                     --  a variable before it has been explicitly assigned.\n-                     --  For access types, UR was only set for dereferences,\n-                     --  so the issue is that the value may be null.\n+                        --  All other cases of unset reference active\n \n-                     if Is_Access_Type (Etype (Parent (UR))) then\n-                        Error_Msg_N (\"?`&.&` may be null!\", UR);\n-                     else\n+                     elsif not Warnings_Off_E1 then\n                         Error_Msg_N\n-                          (\"?`&.&` may be referenced before it has a value!\",\n+                          (\"?& may be referenced before it has a value!\",\n                            UR);\n                      end if;\n-\n-                  --  All other cases of unset reference active\n-\n-                  else\n-                     Error_Msg_N\n-                       (\"?& may be referenced before it has a value!\",\n-                        UR);\n                   end if;\n \n                   goto Continue;\n                end if;\n             end if;\n \n             --  Then check for unreferenced entities. Note that we are only\n-            --  interested in entities which do not have the Referenced flag\n-            --  set. The Referenced_As_LHS flag is interesting only if the\n-            --  Referenced flag is not set.\n+            --  interested in entities whose Referenced flag is not set.\n \n             if not Referenced_Check_Spec (E1)\n \n+               --  If Referenced_As_LHS is set, then that's still interesting\n+               --  (potential \"assigned but never read\" case), but not if we\n+               --  have pragma Unreferenced, which cancels this error.\n+\n+              and then (not Referenced_As_LHS_Check_Spec (E1)\n+                          or else not Has_Unreferenced (E1))\n+\n                --  Check that warnings on unreferenced entities are enabled\n \n               and then\n@@ -1324,10 +1396,12 @@ package body Sem_Warn is\n                      --  The unreferenced entity is E1, but post the warning\n                      --  on the body entity for this accept statement.\n \n-                     Warn_On_Unreferenced_Entity\n-                       (E1, Body_Formal (E1, Accept_Statement => Anod));\n+                     if not Warnings_Off_E1 then\n+                        Warn_On_Unreferenced_Entity\n+                          (E1, Body_Formal (E1, Accept_Statement => Anod));\n+                     end if;\n \n-                  else\n+                  elsif not Warnings_Off_E1 then\n                      Unreferenced_Entities.Append (E1);\n                   end if;\n                end if;\n@@ -1343,11 +1417,13 @@ package body Sem_Warn is\n               and then Instantiation_Depth (Sloc (E1)) = 0\n               and then Warn_On_Redundant_Constructs\n             then\n-               Unreferenced_Entities.Append (E1);\n+               if not Warnings_Off_E1 then\n+                  Unreferenced_Entities.Append (E1);\n \n                --  Force warning on entity\n \n-               Set_Referenced (E1, False);\n+                  Set_Referenced (E1, False);\n+               end if;\n             end if;\n          end if;\n \n@@ -1478,7 +1554,8 @@ package body Sem_Warn is\n                             or else\n                               Earlier_In_Extended_Unit\n                                 (Sloc (N),  Sloc (Unset_Reference (E))))\n-                 and then not Warnings_Off (E)\n+                 and then not Has_Pragma_Unmodified_Check_Spec (E)\n+                 and then not Warnings_Off_Check_Spec (E)\n                then\n                   --  We may have an unset reference. The first test is whether\n                   --  this is an access to a discriminant of a record or a\n@@ -1967,7 +2044,7 @@ package body Sem_Warn is\n                --  is explicitly marked by a pragma Unreferenced).\n \n                if not Referenced (Lunit)\n-                 and then not Has_Pragma_Unreferenced (Lunit)\n+                 and then not Has_Unreferenced (Lunit)\n                then\n                   --  Suppress warnings in internal units if not in -gnatg mode\n                   --  (these would be junk warnings for an application program,\n@@ -2060,8 +2137,8 @@ package body Sem_Warn is\n                            --  Else give the warning\n \n                            else\n-                              if not Has_Pragma_Unreferenced\n-                                       (Entity (Name (Item)))\n+                              if not\n+                                Has_Unreferenced (Entity (Name (Item)))\n                               then\n                                  Error_Msg_N\n                                    (\"?no entities of & are referenced!\",\n@@ -2076,8 +2153,8 @@ package body Sem_Warn is\n                               Pack := Find_Package_Renaming (Munite, Lunit);\n \n                               if Present (Pack)\n-                                and then not Warnings_Off (Lunit)\n-                                and then not Has_Pragma_Unreferenced (Pack)\n+                                and then not Has_Warnings_Off (Lunit)\n+                                and then not Has_Unreferenced (Pack)\n                               then\n                                  Error_Msg_NE\n                                    (\"?no entities of & are referenced!\",\n@@ -2276,11 +2353,16 @@ package body Sem_Warn is\n    is\n    begin\n       if Is_Formal (E) and then Present (Spec_Entity (E)) then\n-         return Has_Pragma_Unmodified (E)\n-                  or else\n-                Has_Pragma_Unmodified (Spec_Entity (E));\n+\n+         --  Note: use of OR instead of OR ELSE here is deliberate, we want\n+         --  to mess with Unmodified flags on both body and spec entities.\n+\n+         return Has_Unmodified (E)\n+                  or\n+                Has_Unmodified (Spec_Entity (E));\n+\n       else\n-         return Has_Pragma_Unmodified (E);\n+         return Has_Unmodified (E);\n       end if;\n    end Has_Pragma_Unmodified_Check_Spec;\n \n@@ -2293,14 +2375,30 @@ package body Sem_Warn is\n    is\n    begin\n       if Is_Formal (E) and then Present (Spec_Entity (E)) then\n-         return Has_Pragma_Unreferenced (E)\n-                  or else\n-                Has_Pragma_Unreferenced (Spec_Entity (E));\n+\n+         --  Note: use of OR here instead of OR ELSE is deliberate, we want\n+         --  to mess with flags on both entities.\n+\n+         return Has_Unreferenced (E)\n+                  or\n+                Has_Unreferenced (Spec_Entity (E));\n+\n       else\n-         return Has_Pragma_Unreferenced (E);\n+         return Has_Unreferenced (E);\n       end if;\n    end Has_Pragma_Unreferenced_Check_Spec;\n \n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+   begin\n+      Warnings_Off_Pragmas.Init;\n+      Unreferenced_Entities.Init;\n+      In_Out_Warnings.Init;\n+   end Initialize;\n+\n    ------------------------------------\n    -- Never_Set_In_Source_Check_Spec --\n    ------------------------------------\n@@ -2341,7 +2439,7 @@ package body Sem_Warn is\n       begin\n          if Nkind (R) in N_Has_Entity\n            and then Present (Entity (R))\n-           and then Warnings_Off (Entity (R))\n+           and then Has_Warnings_Off (Entity (R))\n          then\n             return Abandon;\n          else\n@@ -2383,16 +2481,33 @@ package body Sem_Warn is\n       -----------------------\n \n       function No_Warn_On_In_Out (E : Entity_Id) return Boolean is\n-         S : constant Entity_Id := Scope (E);\n+         S  : constant Entity_Id := Scope (E);\n+         SE : constant Entity_Id := Spec_Entity (E);\n+\n       begin\n-         if Warnings_Off (S) then\n+         --  Do not warn if address is taken, since funny business may be going\n+         --  on in treating the parameter indirectly as IN OUT.\n+\n+         if Address_Taken (S)\n+           or else (Present (SE) and then Address_Taken (Scope (SE)))\n+         then\n             return True;\n-         elsif Address_Taken (S) then\n+\n+         --  Do not warn if used as a generic actual, since the generic may be\n+         --  what is forcing the use of an \"unnecessary\" IN OUT.\n+\n+         elsif Used_As_Generic_Actual (S)\n+           or else (Present (SE) and then Used_As_Generic_Actual (Scope (SE)))\n+         then\n             return True;\n-         elsif Used_As_Generic_Actual (S) then\n+\n+         --  Else test warnings off\n+\n+         elsif Warnings_Off_Check_Spec (S) then\n             return True;\n-         elsif Present (Spec_Entity (E)) then\n-            return No_Warn_On_In_Out (Spec_Entity (E));\n+\n+         --  All tests for suppressing warning failed\n+\n          else\n             return False;\n          end if;\n@@ -2411,8 +2526,8 @@ package body Sem_Warn is\n             --  Suppress warning in specific cases (see details in comments for\n             --  No_Warn_On_In_Out), or if there is a pragma Unmodified.\n \n-            if No_Warn_On_In_Out (E1)\n-              or else Has_Pragma_Unmodified_Check_Spec (E1)\n+            if Has_Pragma_Unmodified_Check_Spec (E1)\n+              or else No_Warn_On_In_Out (E1)\n             then\n                null;\n \n@@ -2421,18 +2536,23 @@ package body Sem_Warn is\n             else\n                --  If -gnatwc is set then output message that we could be IN\n \n-               if Warn_On_Constant then\n-                  Error_Msg_N (\"?formal parameter & is not modified!\", E1);\n-                  Error_Msg_N (\"\\?mode could be IN instead of `IN OUT`!\", E1);\n+               if not Is_Trivial_Subprogram (Scope (E1)) then\n+                  if Warn_On_Constant then\n+                     Error_Msg_N\n+                       (\"?formal parameter & is not modified!\", E1);\n+                     Error_Msg_N\n+                       (\"\\?mode could be IN instead of `IN OUT`!\", E1);\n \n-               --  We do not generate warnings for IN OUT parameters unless we\n-               --  have at least -gnatwu. This is deliberately inconsistent\n-               --  with the treatment of variables, but otherwise we get too\n-               --  many unexpected warnings in default mode.\n+                     --  We do not generate warnings for IN OUT parameters\n+                     --  unless we have at least -gnatwu. This is deliberately\n+                     --  inconsistent with the treatment of variables, but\n+                     --  otherwise we get too many unexpected warnings in\n+                     --  default mode.\n \n-               elsif Check_Unreferenced then\n-                  Error_Msg_N (\"?formal parameter& is read but \"\n-                               & \"never assigned!\", E1);\n+                  elsif Check_Unreferenced then\n+                     Error_Msg_N (\"?formal parameter& is read but \"\n+                                  & \"never assigned!\", E1);\n+                  end if;\n                end if;\n \n                --  Kill any other warnings on this entity, since this is the\n@@ -2600,6 +2720,62 @@ package body Sem_Warn is\n       end loop;\n    end Output_Unreferenced_Messages;\n \n+   -----------------------------------------\n+   -- Output_Unused_Warnings_Off_Warnings --\n+   -----------------------------------------\n+\n+   procedure Output_Unused_Warnings_Off_Warnings is\n+   begin\n+      for J in Warnings_Off_Pragmas.First .. Warnings_Off_Pragmas.Last loop\n+         declare\n+            Wentry : Warnings_Off_Entry renames Warnings_Off_Pragmas.Table (J);\n+            N      : Node_Id renames Wentry.N;\n+            E      : Node_Id renames Wentry.E;\n+\n+         begin\n+            --  Turn off Warnings_Off, or we won't get the warning!\n+\n+            Set_Warnings_Off (E, False);\n+\n+            --  Nothing to do if pragma was used to suppress a general warning\n+\n+            if Warnings_Off_Used (E) then\n+               null;\n+\n+            --  If pragma was used both in unmodified and unreferenced contexts\n+            --  then that's as good as the general case, no warning.\n+\n+            elsif Warnings_Off_Used_Unmodified (E)\n+                    and\n+                  Warnings_Off_Used_Unreferenced (E)\n+            then\n+               null;\n+\n+            --  Used only in context where Unmodified would have worked\n+\n+            elsif Warnings_Off_Used_Unmodified (E) then\n+               Error_Msg_NE\n+                 (\"?could use Unmodified instead of \"\n+                  & \"Warnings Off for &\", Pragma_Identifier (N), E);\n+\n+            --  Used only in context where Unreferenced would have worked\n+\n+            elsif Warnings_Off_Used_Unreferenced (E) then\n+               Error_Msg_NE\n+                 (\"?could use Unreferenced instead of \"\n+                  & \"Warnings Off for &\", Pragma_Identifier (N), E);\n+\n+            --  Not used at all\n+\n+            else\n+               Error_Msg_NE\n+                 (\"?pragma Warnings Off for & unused, \"\n+                  & \"could be omitted\", N, E);\n+            end if;\n+         end;\n+      end loop;\n+   end Output_Unused_Warnings_Off_Warnings;\n+\n    ---------------------------\n    -- Referenced_Check_Spec --\n    ---------------------------\n@@ -2674,6 +2850,12 @@ package body Sem_Warn is\n          when 'R' =>\n             Warn_On_Object_Renames_Function     := False;\n \n+         when 'w' =>\n+            Warn_On_Warnings_Off                := True;\n+\n+         when 'W' =>\n+            Warn_On_Warnings_Off                := False;\n+\n          when 'x' =>\n             Warn_On_Non_Local_Exception         := True;\n \n@@ -2746,6 +2928,7 @@ package body Sem_Warn is\n             Warn_On_Unchecked_Conversion        := False;\n             Warn_On_Unrecognized_Pragma         := False;\n             Warn_On_Unrepped_Components         := False;\n+            Warn_On_Warnings_Off                := False;\n \n          when 'b' =>\n             Warn_On_Bad_Fixed_Value             := True;\n@@ -2997,7 +3180,7 @@ package body Sem_Warn is\n             --  node, since assert pragmas get rewritten at analysis time.\n \n             elsif Nkind (Original_Node (P)) = N_Pragma\n-              and then Chars (Original_Node (P)) = Name_Assert\n+              and then Pragma_Name (Original_Node (P)) = Name_Assert\n             then\n                return;\n             end if;\n@@ -3100,12 +3283,12 @@ package body Sem_Warn is\n          if Is_Array_Type (Typ)\n            and then not Is_Constrained (Typ)\n            and then Number_Dimensions (Typ) = 1\n-           and then not Warnings_Off (Typ)\n            and then (Root_Type (Typ) = Standard_String\n                        or else\n                      Root_Type (Typ) = Standard_Wide_String\n                        or else\n                      Root_Type (Typ) = Standard_Wide_Wide_String)\n+           and then not Has_Warnings_Off (Typ)\n          then\n             LB := Type_Low_Bound (Etype (First_Index (Typ)));\n \n@@ -3412,7 +3595,10 @@ package body Sem_Warn is\n       E : Entity_Id := Spec_E;\n \n    begin\n-      if not Referenced_Check_Spec (E) and then not Warnings_Off (E) then\n+      if not Referenced_Check_Spec (E)\n+        and then not Has_Pragma_Unreferenced_Check_Spec (E)\n+        and then not Warnings_Off_Check_Spec (E)\n+      then\n          case Ekind (E) is\n             when E_Variable =>\n \n@@ -3494,8 +3680,12 @@ package body Sem_Warn is\n                      if Present (Body_E) then\n                         E := Body_E;\n                      end if;\n-                     Error_Msg_NE\n-                       (\"?formal parameter & is not referenced!\", E, Spec_E);\n+\n+                     if not Is_Trivial_Subprogram (Scope (E)) then\n+                        Error_Msg_NE\n+                          (\"?formal parameter & is not referenced!\",\n+                           E, Spec_E);\n+                     end if;\n                   end if;\n                end if;\n \n@@ -3585,20 +3775,19 @@ package body Sem_Warn is\n       if Is_Assignable (Ent)\n         and then not Is_Return_Object (Ent)\n         and then Present (Last_Assignment (Ent))\n-        and then not Warnings_Off (Ent)\n-        and then not Has_Pragma_Unreferenced_Check_Spec (Ent)\n         and then not Is_Imported (Ent)\n         and then not Is_Exported (Ent)\n         and then Safe_To_Capture_Value (N, Ent)\n+        and then not Has_Pragma_Unreferenced_Check_Spec (Ent)\n       then\n          --  Before we issue the message, check covering exception handlers.\n-         --  Search up tree for enclosing statement sequences and handlers\n+         --  Search up tree for enclosing statement sequences and handlers.\n \n          P := Parent (Last_Assignment (Ent));\n          while Present (P) loop\n \n-            --  Something is really wrong if we don't find a handled\n-            --  statement sequence, so just suppress the warning.\n+            --  Something is really wrong if we don't find a handled statement\n+            --  sequence, so just suppress the warning.\n \n             if No (P) then\n                Set_Last_Assignment (Ent, Empty);\n@@ -3712,4 +3901,24 @@ package body Sem_Warn is\n       end if;\n    end Warn_On_Useless_Assignments;\n \n+   -----------------------------\n+   -- Warnings_Off_Check_Spec --\n+   -----------------------------\n+\n+   function Warnings_Off_Check_Spec (E : Entity_Id) return Boolean is\n+   begin\n+      if Is_Formal (E) and then Present (Spec_Entity (E)) then\n+\n+         --  Note: use of OR here instead of OR ELSE is deliberate, we want\n+         --  to mess with flags on both entities.\n+\n+         return Has_Warnings_Off (E)\n+                  or\n+                Has_Warnings_Off (Spec_Entity (E));\n+\n+      else\n+         return Has_Warnings_Off (E);\n+      end if;\n+   end Warnings_Off_Check_Spec;\n+\n end Sem_Warn;"}, {"sha": "d78bba96ecaf17b9808d583594dd573c04bded04", "filename": "gcc/ada/sem_warn.ads", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18e785b8c1ad490a3bb00a88735f57c0c60e4b/gcc%2Fada%2Fsem_warn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18e785b8c1ad490a3bb00a88735f57c0c60e4b/gcc%2Fada%2Fsem_warn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.ads?ref=9a18e785b8c1ad490a3bb00a88735f57c0c60e4b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1999-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,14 +27,44 @@\n --  about uses of uninitialized variables and unused with's. It also has\n --  some unrelated routines related to the generation of warnings.\n \n+with Alloc; use Alloc;\n+with Table;\n with Types; use Types;\n \n package Sem_Warn is\n \n+   ------------------------\n+   -- Warnings Off Table --\n+   ------------------------\n+\n+   type Warnings_Off_Entry is record\n+      N : Node_Id;\n+      --  A pragma Warnings (Off, ent) node\n+\n+      E : Entity_Id;\n+      --  The entity involved\n+   end record;\n+\n+   --  An entry is made in the following table for any valid Pragma Warnings\n+   --  (Off, entity) encountered while Opt.Warn_On_Warnings_Off is True. It\n+   --  is used to generate warnings on any of these pragmas that turn out not\n+   --  to be needed, or that could be replaced by Unmodified/Unreferenced.\n+\n+   package Warnings_Off_Pragmas is new Table.Table (\n+     Table_Component_Type => Warnings_Off_Entry,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 0,\n+     Table_Initial        => Alloc.Warnings_Off_Pragmas_Initial,\n+     Table_Increment      => Alloc.Warnings_Off_Pragmas_Increment,\n+     Table_Name           => \"Name_Warnings_Off_Pragmas\");\n+\n    --------------------\n    -- Initialization --\n    --------------------\n \n+   procedure Initialize;\n+   --  Initialize this package for new compilation\n+\n    function Set_Warning_Switch (C : Character) return Boolean;\n    --  This function sets the warning switch or switches corresponding to the\n    --  given character. It is used to process a -gnatw switch on the command\n@@ -121,6 +151,12 @@ package Sem_Warn is\n    --  the compilation process (see Check_Unset_Reference for further\n    --  details). This procedure outputs waiting warnings, if any.\n \n+   procedure Output_Unused_Warnings_Off_Warnings;\n+   --  Warnings about pragma Warnings (Off, ent) statements that are unused,\n+   --  or could be replaced by Unmodified/Unreferenced pragmas, are collected\n+   --  till the end of the compilation process. This procedure outputs waiting\n+   --  warnings if any.\n+\n    ----------------------------\n    -- Other Warning Routines --\n    ----------------------------"}]}