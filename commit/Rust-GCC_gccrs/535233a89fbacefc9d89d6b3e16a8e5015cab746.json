{"sha": "535233a89fbacefc9d89d6b3e16a8e5015cab746", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM1MjMzYTg5ZmJhY2VmYzlkODlkNmIzZTE2YThlNTAxNWNhYjc0Ng==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "1999-11-19T13:03:00Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "1999-11-19T13:03:00Z"}, "message": "extend.texi: Document C++ restricted pointers and references.\n\n\t* extend.texi: Document C++ restricted pointers and references.\n\n\t* cp-tree.h (grok_method_quals): Return this pointer qualifiers.\n\t* decl.c (grokdeclarator): Adjust calls to grok_method_quals.\n\t* decl2.c (grok_method_quals): Accept `restrict' as applying to\n\tthe object pointer. Return such qualifiers.\n\t(grokclassfn): Apply this pointer qualifiers. Cleanup unused\n\tvariables.\n\nFrom-SVN: r30587", "tree": {"sha": "039515215e280d5d71d98f879993cbb32909d22c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/039515215e280d5d71d98f879993cbb32909d22c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/535233a89fbacefc9d89d6b3e16a8e5015cab746", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/535233a89fbacefc9d89d6b3e16a8e5015cab746", "html_url": "https://github.com/Rust-GCC/gccrs/commit/535233a89fbacefc9d89d6b3e16a8e5015cab746", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/535233a89fbacefc9d89d6b3e16a8e5015cab746/comments", "author": null, "committer": null, "parents": [{"sha": "73d65336b7ea7591387c04c3a42c4e75641cc86c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73d65336b7ea7591387c04c3a42c4e75641cc86c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73d65336b7ea7591387c04c3a42c4e75641cc86c"}], "stats": {"total": 111, "additions": 87, "deletions": 24}, "files": [{"sha": "6a72c033a7f469cd7e46a6b51cbd33e71d202073", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535233a89fbacefc9d89d6b3e16a8e5015cab746/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535233a89fbacefc9d89d6b3e16a8e5015cab746/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=535233a89fbacefc9d89d6b3e16a8e5015cab746", "patch": "@@ -1,12 +1,17 @@\n+Fri Nov 19 10:41:15 GMT 1999  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* extend.texi: Document C++ restricted pointers and references.\t\n+\n 1999-11-19  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* cse.c (addr_affects_sp): No longer conditional on AUTO_INC_DEC.\n \t(invalidate_skipped_set): Call it unconditionally.\n \t(cse_set_around_loop): Likewise.\n \n-Fri Nov 18 13:39:22 CET 1999  Jam Hubicka  <hubicka@freesoft.cz>\n-\t* i386.h (struct_processor_costs): New fileds int_load, int_store, fp_move,\n-\tfp_load and fp_store\n+Fri Nov 18 13:39:22 CET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n+\n+\t* i386.h (struct_processor_costs): New fileds int_load, int_store,\n+\tfp_move, fp_load and fp_store\n \t(REGISTER_MOVE_COST): Fix comment, calculate exactly the cost of\n \tfp->int moves\n \t(MEMORY_MOVE_COST): New macro."}, {"sha": "284227dcf1d63757b8793871e891680652cee27f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535233a89fbacefc9d89d6b3e16a8e5015cab746/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535233a89fbacefc9d89d6b3e16a8e5015cab746/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=535233a89fbacefc9d89d6b3e16a8e5015cab746", "patch": "@@ -1,3 +1,12 @@\n+1999-11-19  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* cp-tree.h (grok_method_quals): Return this pointer qualifiers.\n+\t* decl.c (grokdeclarator): Adjust calls to grok_method_quals.\n+\t* decl2.c (grok_method_quals): Accept `restrict' as applying to\n+\tthe object pointer. Return such qualifiers.\n+\t(grokclassfn): Apply this pointer qualifiers. Cleanup unused\n+\tvariables.\n+\n 1999-11-18  Mark Mitchell  <mark@codesourcery.com>\n \n \t* except.c (expand_end_catch_block): Fix typo."}, {"sha": "2e764c1658916226be1db8ae269203edbb7eab8a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535233a89fbacefc9d89d6b3e16a8e5015cab746/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535233a89fbacefc9d89d6b3e16a8e5015cab746/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=535233a89fbacefc9d89d6b3e16a8e5015cab746", "patch": "@@ -3529,7 +3529,7 @@ extern void make_rtl_for_local_static           PROTO((tree));\n extern void init_decl2\t\t\t\tPROTO((void));\n extern int check_java_method\t\t\tPROTO((tree));\n extern int lang_decode_option\t\t\tPROTO((int, char **));\n-extern tree grok_method_quals\t\t\tPROTO((tree, tree, tree));\n+extern int grok_method_quals\t\t\tPROTO((tree, tree, tree));\n extern void warn_if_unknown_interface\t\tPROTO((tree));\n extern void grok_x_components\t\t\tPROTO((tree));\n extern void maybe_retrofit_in_chrg\t\tPROTO((tree));"}, {"sha": "91b8552d54bd8154172c885dd7309453f69c86a1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535233a89fbacefc9d89d6b3e16a8e5015cab746/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535233a89fbacefc9d89d6b3e16a8e5015cab746/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=535233a89fbacefc9d89d6b3e16a8e5015cab746", "patch": "@@ -8919,7 +8919,8 @@ create_array_type_for_decl (name, type, size)\n    is erroneous, NULL_TREE is returned.\n \n    QUALS is used only for FUNCDEF and MEMFUNCDEF cases.  For a member\n-   function, these are the qualifiers to give to the `this' pointer.\n+   function, these are the qualifiers to give to the `this' pointer. We\n+   apply TYPE_QUAL_RESTRICT to the this ptr, not the object.\n \n    May return void_type_node if the declarator turned out to be a friend.\n    See grokfield for details.  */\n@@ -9836,8 +9837,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  if (ctype != NULL_TREE)\n \t    {\n \t      tree dummy = build_decl (TYPE_DECL, NULL_TREE, type);\n-\t      ctype = grok_method_quals (ctype, dummy, quals);\n+\t      grok_method_quals (ctype, dummy, quals);\n \t      type = TREE_TYPE (dummy);\n+\t      ctype = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (type)));\n \t      quals = NULL_TREE;\n \t    }\n \t}"}, {"sha": "f4630b2f86a6b5f61568bfa96ce673de3cecbc20", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535233a89fbacefc9d89d6b3e16a8e5015cab746/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535233a89fbacefc9d89d6b3e16a8e5015cab746/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=535233a89fbacefc9d89d6b3e16a8e5015cab746", "patch": "@@ -780,23 +780,28 @@ lang_decode_option (argc, argv)\n \f\n /* Incorporate `const' and `volatile' qualifiers for member functions.\n    FUNCTION is a TYPE_DECL or a FUNCTION_DECL.\n-   QUALS is a list of qualifiers.  */\n+   QUALS is a list of qualifiers.  Returns any explicit\n+   top-level qualifiers of the method's this pointer, anything other than\n+   TYPE_UNQUALIFIED will be an extension.  */\n \n-tree\n+int\n grok_method_quals (ctype, function, quals)\n      tree ctype, function, quals;\n {\n   tree fntype = TREE_TYPE (function);\n   tree raises = TYPE_RAISES_EXCEPTIONS (fntype);\n   int type_quals = TYPE_UNQUALIFIED;\n   int dup_quals = TYPE_UNQUALIFIED;\n+  int this_quals = TYPE_UNQUALIFIED;\n \n   do\n     {\n       int tq = cp_type_qual_from_rid (TREE_VALUE (quals));\n       \n-      if (type_quals & tq)\n+      if ((type_quals | this_quals) & tq)\n \tdup_quals |= tq;\n+      else if (tq & TYPE_QUAL_RESTRICT)\n+        this_quals |= tq;\n       else\n \ttype_quals |= tq;\n       quals = TREE_CHAIN (quals);\n@@ -817,7 +822,7 @@ grok_method_quals (ctype, function, quals)\n     fntype = build_exception_variant (fntype, raises);\n \n   TREE_TYPE (function) = fntype;\n-  return ctype;\n+  return this_quals;\n }\n \n /* Warn when -fexternal-templates is used and #pragma\n@@ -961,9 +966,7 @@ grokclassfn (ctype, function, flags, quals)\n      tree quals;\n {\n   tree fn_name = DECL_NAME (function);\n-  tree arg_types;\n-  tree parm;\n-  tree qualtype;\n+  int this_quals = TYPE_UNQUALIFIED;\n \n   if (fn_name == NULL_TREE)\n     {\n@@ -973,26 +976,23 @@ grokclassfn (ctype, function, flags, quals)\n     }\n \n   if (quals)\n-    qualtype = grok_method_quals (ctype, function, quals);\n-  else\n-    qualtype = ctype;\n+    this_quals = grok_method_quals (ctype, function, quals);\n \n-  arg_types = TYPE_ARG_TYPES (TREE_TYPE (function));\n   if (TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE)\n     {\n       /* Must add the class instance variable up front.  */\n       /* Right now we just make this a pointer.  But later\n \t we may wish to make it special.  */\n-      tree type = TREE_VALUE (arg_types);\n+      tree type = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (function)));\n \n-      parm = build_decl (PARM_DECL, this_identifier, type);\n+      tree parm = build_decl (PARM_DECL, this_identifier,\n+                         cp_build_qualified_type (type, this_quals | TYPE_QUAL_CONST));\n       /* Mark the artificial `this' parameter as \"artificial\".  */\n       SET_DECL_ARTIFICIAL (parm);\n       DECL_ARG_TYPE (parm) = type;\n       /* We can make this a register, so long as we don't\n \t accidentally complain if someone tries to take its address.  */\n       DECL_REGISTER (parm) = 1;\n-      TREE_READONLY (parm) = 1;\n       TREE_CHAIN (parm) = last_function_parms;\n       last_function_parms = parm;\n     }\n@@ -1003,10 +1003,7 @@ grokclassfn (ctype, function, flags, quals)\n   DECL_CLASS_CONTEXT (function) = ctype;\n \n   if (flags == DTOR_FLAG || DECL_CONSTRUCTOR_P (function))\n-    {\n-      maybe_retrofit_in_chrg (function);\n-      arg_types = TYPE_ARG_TYPES (TREE_TYPE (function));\n-    }\n+    maybe_retrofit_in_chrg (function);\n \n   if (flags == DTOR_FLAG)\n     {"}, {"sha": "17f12c95d92b04b862a13a74696fabb9293798a8", "filename": "gcc/extend.texi", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535233a89fbacefc9d89d6b3e16a8e5015cab746/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535233a89fbacefc9d89d6b3e16a8e5015cab746/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=535233a89fbacefc9d89d6b3e16a8e5015cab746", "patch": "@@ -3219,6 +3219,7 @@ Predefined Macros,cpp.info,The C Preprocessor}).\n * Naming Results::      Giving a name to C++ function return values.\n * Min and Max::\t\tC++ Minimum and maximum operators.\n * Volatiles::\t\tWhat constitutes an access to a volatile object.\n+* Restricted Pointers:: C9X restricted pointers and references.\n * C++ Interface::       You can use a single C++ header file for both\n                          declarations and definitions.\n * Template Instantiation:: Methods for ensuring that exactly one copy of\n@@ -3466,6 +3467,55 @@ possible to ignore the return value from functions returning volatile\n references. Again, if you wish to force a read, cast the reference to\n an rvalue.\n \n+@node Restricted Pointers\n+@section Restricting Pointer Aliasing\n+@cindex restricted pointers\n+@cindex restricted references\n+@cindex restricted this pointer\n+\n+As with gcc, g++ understands the C9X proposal of restricted pointers,\n+specified with the @code{__restrict__}, or @code{__restrict} type\n+qualifier. Because you cannot compile C++ by specifying the -flang-isoc9x\n+language flag, @code{restrict} is not a keyword in C++.\n+\n+In addition to allowing restricted pointers, you can specify restricted\n+references, which indicate that the reference is not aliased in the local\n+context.\n+\n+@example\n+void fn (int *__restrict__ rptr, int &__restrict__ rref)\n+@{\n+  @dots{}\n+@}\n+@end example\n+\n+@noindent\n+In the body of @code{fn}, @var{rptr} points to an unaliased integer and\n+@var{rref} refers to a (different) unaliased integer.\n+\n+You may also specify whether a member function's @var{this} pointer is\n+unaliased by using @code{__restrict__} as a member function qualifier.\n+\n+@example\n+void T::fn () __restrict__\n+@{\n+  @dots{}\n+@}\n+@end example\n+\n+@noindent\n+Within the body of @code{T::fn}, @var{this} will have the effective\n+definition @code{T *__restrict__ const this}. Notice that the\n+interpretation of a @code{__restrict__} member function qualifier is\n+different to that of @code{const} or @code{volatile} qualifier, in that it\n+is applied to the pointer rather than the object. This is consistent with\n+other compilers which implement restricted pointers.\n+\n+As with all outermost parameter qualifiers, @code{__restrict__} is\n+ignored in function definition matching. This means you only need to\n+specify @code{__restrict__} in a function definition, rather than\n+in a function prototype as well.\n+\n @node C++ Interface\n @section Declarations and Definitions in One Header\n "}]}