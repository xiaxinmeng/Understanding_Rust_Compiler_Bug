{"sha": "229fa5dbde6e8a58c8409712a9e09d76793677c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI5ZmE1ZGJkZTZlOGE1OGM4NDA5NzEyYTllMDlkNzY3OTM2NzdjMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-06T11:15:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-06T11:15:32Z"}, "message": "[multiple changes]\n\n2017-01-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* checks.adb (Ensure_Valid): Do not generate a validity check\n\twithin a generated predicate function, validity checks will have\n\tbeen applied earlier when required.\n\n2017-01-06  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-tpoben.ads (Protection_Entries): Add comment and reorder\n\tcomponents for performances.\n\t* s-tpobop.adb (PO_Do_Or_Queue): Implement Max_Queue_Length runtime\n\tsemantic.\n\nFrom-SVN: r244136", "tree": {"sha": "c10c62f1ebe2c54e1c08fd4a75865af8efa675cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c10c62f1ebe2c54e1c08fd4a75865af8efa675cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/229fa5dbde6e8a58c8409712a9e09d76793677c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/229fa5dbde6e8a58c8409712a9e09d76793677c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/229fa5dbde6e8a58c8409712a9e09d76793677c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/229fa5dbde6e8a58c8409712a9e09d76793677c0/comments", "author": null, "committer": null, "parents": [{"sha": "d9c59db4554b9fe827e2f262eafdd789b686a944", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9c59db4554b9fe827e2f262eafdd789b686a944", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9c59db4554b9fe827e2f262eafdd789b686a944"}], "stats": {"total": 88, "additions": 64, "deletions": 24}, "files": [{"sha": "ce482e34e0ed8a44d5f1ac987a9fd6cfaf425093", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229fa5dbde6e8a58c8409712a9e09d76793677c0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229fa5dbde6e8a58c8409712a9e09d76793677c0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=229fa5dbde6e8a58c8409712a9e09d76793677c0", "patch": "@@ -1,3 +1,16 @@\n+2017-01-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* checks.adb (Ensure_Valid): Do not generate a validity check\n+\twithin a generated predicate function, validity checks will have\n+\tbeen applied earlier when required.\n+\n+2017-01-06  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* s-tpoben.ads (Protection_Entries): Add comment and reorder\n+\tcomponents for performances.\n+\t* s-tpobop.adb (PO_Do_Or_Queue): Implement Max_Queue_Length runtime\n+\tsemantic.\n+\n 2017-01-06  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_eval.adb (Check_Expression_Against_Static_Predicate):"}, {"sha": "61e1ad4fed977be58d1c22f8832b832c07baf30b", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229fa5dbde6e8a58c8409712a9e09d76793677c0/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229fa5dbde6e8a58c8409712a9e09d76793677c0/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=229fa5dbde6e8a58c8409712a9e09d76793677c0", "patch": "@@ -5709,6 +5709,14 @@ package body Checks is\n       elsif Expr_Known_Valid (Expr) then\n          return;\n \n+      --  No check needed within a generated predicate function. Validity\n+      --  of input value will have been checked earlier.\n+\n+      elsif Ekind (Current_Scope) = E_Function\n+        and then Is_Predicate_Function (Current_Scope)\n+      then\n+         return;\n+\n       --  Ignore case of enumeration with holes where the flag is set not to\n       --  worry about holes, since no special validity check is needed\n "}, {"sha": "90bfa89f3983d4fe5a2519f6471865a0da7a62d3", "filename": "gcc/ada/s-tpoben.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229fa5dbde6e8a58c8409712a9e09d76793677c0/gcc%2Fada%2Fs-tpoben.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229fa5dbde6e8a58c8409712a9e09d76793677c0/gcc%2Fada%2Fs-tpoben.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpoben.ads?ref=229fa5dbde6e8a58c8409712a9e09d76793677c0", "patch": "@@ -148,8 +148,6 @@ package System.Tasking.Protected_Objects.Entries is\n       --  A function which maps the entry index in a call (which denotes the\n       --  queue of the proper entry) into the body of the entry.\n \n-      Entry_Queues : Protected_Entry_Queue_Array (1 .. Num_Entries);\n-\n       Entry_Queue_Maxes : Protected_Entry_Queue_Max_Access;\n       --  Access to an array of naturals representing the max value for each\n       --  entry's queue length. A value of 0 signifies no max.\n@@ -158,6 +156,9 @@ package System.Tasking.Protected_Objects.Entries is\n       --  An array of string names which denotes entry [family member] names.\n       --  The structure is indexed by protected entry index and contains Num_\n       --  Entries components.\n+\n+      Entry_Queues : Protected_Entry_Queue_Array (1 .. Num_Entries);\n+      --  Action and barrier subprograms for the protected type.\n    end record;\n \n    --  No default initial values for this type, since call records will need to"}, {"sha": "a6f6c993d4e927ac135d5476b7e2f88c5f598d80", "filename": "gcc/ada/s-tpobop.adb", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229fa5dbde6e8a58c8409712a9e09d76793677c0/gcc%2Fada%2Fs-tpobop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229fa5dbde6e8a58c8409712a9e09d76793677c0/gcc%2Fada%2Fs-tpobop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpobop.adb?ref=229fa5dbde6e8a58c8409712a9e09d76793677c0", "patch": "@@ -292,17 +292,17 @@ package body System.Tasking.Protected_Objects.Operations is\n    is\n       E             : constant Protected_Entry_Index :=\n                         Protected_Entry_Index (Entry_Call.E);\n+      Index         : constant Protected_Entry_Index :=\n+                        Object.Find_Body_Index (Object.Compiler_Info, E);\n       Barrier_Value : Boolean;\n-\n+      Queue_Length  : Natural;\n    begin\n       --  When the Action procedure for an entry body returns, it is either\n       --  completed (having called [Exceptional_]Complete_Entry_Body) or it\n       --  is queued, having executed a requeue statement.\n \n       Barrier_Value :=\n-        Object.Entry_Bodies (\n-          Object.Find_Body_Index (Object.Compiler_Info, E)).\n-            Barrier (Object.Compiler_Info, E);\n+        Object.Entry_Bodies (Index).Barrier (Object.Compiler_Info, E);\n \n       if Barrier_Value then\n \n@@ -316,8 +316,7 @@ package body System.Tasking.Protected_Objects.Operations is\n \n          pragma Debug\n           (Debug.Trace (Self_ID, \"PODOQ: start entry body\", 'P'));\n-         Object.Entry_Bodies (\n-           Object.Find_Body_Index (Object.Compiler_Info, E)).Action (\n+         Object.Entry_Bodies (Index).Action (\n              Object.Compiler_Info, Entry_Call.Uninterpreted_Data, E);\n \n          if Object.Call_In_Progress /= null then\n@@ -346,29 +345,48 @@ package body System.Tasking.Protected_Objects.Operations is\n         or else not Entry_Call.With_Abort\n       then\n          if Run_Time_Restrictions.Set (Max_Entry_Queue_Length)\n-           and then Run_Time_Restrictions.Value (Max_Entry_Queue_Length) <=\n-                      Queuing.Count_Waiting (Object.Entry_Queues (E))\n+           or else Object.Entry_Queue_Maxes /= null\n          then\n-            --  This violates the Max_Entry_Queue_Length restriction, raise\n-            --  Program_Error.\n+            --  Need to check the queue length. Computing the length is an\n+            --  unusual case and is slow (need to walk the queue)\n+\n+            Queue_Length := Queuing.Count_Waiting (Object.Entry_Queues (E));\n+\n+            if (Run_Time_Restrictions.Set (Max_Entry_Queue_Length)\n+                and then Queue_Length >=\n+                   Run_Time_Restrictions.Value (Max_Entry_Queue_Length))\n+              or else\n+              (Object.Entry_Queue_Maxes /= null\n+                 and then Object.Entry_Queue_Maxes (Index) /= 0\n+                 and then Queue_Length >= Object.Entry_Queue_Maxes (Index))\n+            then\n+               --  This violates the Max_Entry_Queue_Length restriction or the\n+               --  Max_Queue_Length bound, raise Program_Error.\n \n-            Entry_Call.Exception_To_Raise := Program_Error'Identity;\n+               Entry_Call.Exception_To_Raise := Program_Error'Identity;\n \n-            if Single_Lock then\n-               STPO.Lock_RTS;\n-            end if;\n+               if Single_Lock then\n+                  STPO.Lock_RTS;\n+               end if;\n \n-            STPO.Write_Lock (Entry_Call.Self);\n-            Initialization.Wakeup_Entry_Caller (Self_ID, Entry_Call, Done);\n-            STPO.Unlock (Entry_Call.Self);\n+               STPO.Write_Lock (Entry_Call.Self);\n+               Initialization.Wakeup_Entry_Caller (Self_ID, Entry_Call, Done);\n+               STPO.Unlock (Entry_Call.Self);\n \n-            if Single_Lock then\n-               STPO.Unlock_RTS;\n+               if Single_Lock then\n+                  STPO.Unlock_RTS;\n+               end if;\n+\n+               return;\n             end if;\n-         else\n-            Queuing.Enqueue (Object.Entry_Queues (E), Entry_Call);\n-            Update_For_Queue_To_PO (Entry_Call, Entry_Call.With_Abort);\n          end if;\n+\n+         --  Do the work: queue the call\n+\n+         Queuing.Enqueue (Object.Entry_Queues (E), Entry_Call);\n+         Update_For_Queue_To_PO (Entry_Call, Entry_Call.With_Abort);\n+\n+         return;\n       else\n          --  Conditional_Call and With_Abort\n "}]}