{"sha": "e1fd038a0c859f7f669370f06f0516e4bd5307b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFmZDAzOGEwYzg1OWY3ZjY2OTM3MGYwNmYwNTE2ZTRiZDUzMDdiOQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-08-24T23:35:56Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-08-24T23:35:56Z"}, "message": "Do not check whether memory references accessed in every iteration trap.\n\nThis patch relaxes the checks from gimple_could_trap_p in order to\nallow the flag_loop_if_convert_stores to if-convert more loops\nin which it is possible to prove that:\n\n- the accesses to an array in a loop do not trap (more than the\n  original non-if-converted loop).  This is true when the memory\n  accesses are executed at every iteration of the if-converted loop.\n\n- the writes to memory occur on arrays that are not const qualified.\n  This is true when there exists at least one unconditional write to\n  the array in the analyzed program.  In this patch this analysis is\n  limited to the loop to be if-converted.\n\n\t* gimple.c (gimple_could_trap_p_1): Not static anymore.\n\tPass an extra bool parameter include_mem.\n\t(gimple_could_trap_p): Adjust call to gimple_could_trap_p_1.\n\t(gimple_assign_rhs_could_trap_p): Same.\n\t* gimple.h (gimple_could_trap_p_1): Declared.\n\t* tree-data-ref.h (same_data_refs_base_objects): New.\n\t(same_data_refs): New.\n\t* tree-if-conv.c (memrefs_read_or_written_unconditionally): New.\n\t(write_memrefs_written_at_least_once): New.\n\t(ifcvt_memrefs_wont_trap): New.\n\t(operations_could_trap): New.\n\t(ifcvt_could_trap_p): New.\n\t(if_convertible_gimple_assign_stmt_p): Call ifcvt_could_trap_p.\n\tGets a vector of data refs.\n\t(if_convertible_stmt_p): Same.\n\t(if_convertible_loop_p_1): New.\n\t(if_convertible_loop_p): Call if_convertible_loop_p_1.\n\n\t* gcc.dg/tree-ssa/ifc-5.c: New.\n\nFrom-SVN: r163531", "tree": {"sha": "82b29bdf050426fdf9c44df1c3fd18a14cf5b09d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82b29bdf050426fdf9c44df1c3fd18a14cf5b09d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1fd038a0c859f7f669370f06f0516e4bd5307b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1fd038a0c859f7f669370f06f0516e4bd5307b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1fd038a0c859f7f669370f06f0516e4bd5307b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1fd038a0c859f7f669370f06f0516e4bd5307b9/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd544141e09187ded0b02cac4ee5ce56ca38622c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd544141e09187ded0b02cac4ee5ce56ca38622c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd544141e09187ded0b02cac4ee5ce56ca38622c"}], "stats": {"total": 383, "additions": 300, "deletions": 83}, "files": [{"sha": "57749fefc7d494c22c081bee384a684d9f038ff8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fd038a0c859f7f669370f06f0516e4bd5307b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fd038a0c859f7f669370f06f0516e4bd5307b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1fd038a0c859f7f669370f06f0516e4bd5307b9", "patch": "@@ -1,3 +1,23 @@\n+2010-08-24  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* gimple.c (gimple_could_trap_p_1): Not static anymore.\n+\tPass an extra bool parameter include_mem.\n+\t(gimple_could_trap_p): Adjust call to gimple_could_trap_p_1.\n+\t(gimple_assign_rhs_could_trap_p): Same.\n+\t* gimple.h (gimple_could_trap_p_1): Declared.\n+\t* tree-data-ref.h (same_data_refs_base_objects): New.\n+\t(same_data_refs): New.\n+\t* tree-if-conv.c (memrefs_read_or_written_unconditionally): New.\n+\t(write_memrefs_written_at_least_once): New.\n+\t(ifcvt_memrefs_wont_trap): New.\n+\t(operations_could_trap): New.\n+\t(ifcvt_could_trap_p): New.\n+\t(if_convertible_gimple_assign_stmt_p): Call ifcvt_could_trap_p.\n+\tGets a vector of data refs.\n+\t(if_convertible_stmt_p): Same.\n+\t(if_convertible_loop_p_1): New.\n+\t(if_convertible_loop_p): Call if_convertible_loop_p_1.\n+\n 2010-08-24  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* common.opt (ftree-loop-if-convert-stores): New flag."}, {"sha": "9d5c61bcecffee1f0151eed402ab55321a133237", "filename": "gcc/gimple.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fd038a0c859f7f669370f06f0516e4bd5307b9/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fd038a0c859f7f669370f06f0516e4bd5307b9/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=e1fd038a0c859f7f669370f06f0516e4bd5307b9", "patch": "@@ -2399,24 +2399,25 @@ gimple_rhs_has_side_effects (const_gimple s)\n   return false;\n }\n \n-\n /* Helper for gimple_could_trap_p and gimple_assign_rhs_could_trap_p.\n-   Return true if S can trap.  If INCLUDE_LHS is true and S is a\n-   GIMPLE_ASSIGN, the LHS of the assignment is also checked.\n-   Otherwise, only the RHS of the assignment is checked.  */\n+   Return true if S can trap.  When INCLUDE_MEM is true, check whether\n+   the memory operations could trap.  When INCLUDE_STORES is true and\n+   S is a GIMPLE_ASSIGN, the LHS of the assignment is also checked.  */\n \n-static bool\n-gimple_could_trap_p_1 (gimple s, bool include_lhs)\n+bool\n+gimple_could_trap_p_1 (gimple s, bool include_mem, bool include_stores)\n {\n-  unsigned i, start;\n   tree t, div = NULL_TREE;\n   enum tree_code op;\n \n-  start = (is_gimple_assign (s) && !include_lhs) ? 1 : 0;\n+  if (include_mem)\n+    {\n+      unsigned i, start = (is_gimple_assign (s) && !include_stores) ? 1 : 0;\n \n-  for (i = start; i < gimple_num_ops (s); i++)\n-    if (tree_could_trap_p (gimple_op (s, i)))\n-      return true;\n+      for (i = start; i < gimple_num_ops (s); i++)\n+\tif (tree_could_trap_p (gimple_op (s, i)))\n+\t  return true;\n+    }\n \n   switch (gimple_code (s))\n     {\n@@ -2445,26 +2446,23 @@ gimple_could_trap_p_1 (gimple s, bool include_lhs)\n     }\n \n   return false;\n-\n }\n \n-\n /* Return true if statement S can trap.  */\n \n bool\n gimple_could_trap_p (gimple s)\n {\n-  return gimple_could_trap_p_1 (s, true);\n+  return gimple_could_trap_p_1 (s, true, true);\n }\n \n-\n /* Return true if RHS of a GIMPLE_ASSIGN S can trap.  */\n \n bool\n gimple_assign_rhs_could_trap_p (gimple s)\n {\n   gcc_assert (is_gimple_assign (s));\n-  return gimple_could_trap_p_1 (s, false);\n+  return gimple_could_trap_p_1 (s, true, false);\n }\n \n "}, {"sha": "545b271d83a78879146e24efc078e0c233f0db32", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fd038a0c859f7f669370f06f0516e4bd5307b9/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fd038a0c859f7f669370f06f0516e4bd5307b9/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=e1fd038a0c859f7f669370f06f0516e4bd5307b9", "patch": "@@ -886,6 +886,7 @@ void gimple_cond_set_condition_from_tree (gimple, tree);\n bool gimple_has_side_effects (const_gimple);\n bool gimple_rhs_has_side_effects (const_gimple);\n bool gimple_could_trap_p (gimple);\n+bool gimple_could_trap_p_1 (gimple, bool, bool);\n bool gimple_assign_rhs_could_trap_p (gimple);\n void gimple_regimplify_operands (gimple, gimple_stmt_iterator *);\n bool empty_body_p (gimple_seq);"}, {"sha": "26e6df7c426ab39b58a8247f00f8165868107aaf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fd038a0c859f7f669370f06f0516e4bd5307b9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fd038a0c859f7f669370f06f0516e4bd5307b9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e1fd038a0c859f7f669370f06f0516e4bd5307b9", "patch": "@@ -1,3 +1,7 @@\n+2010-08-24  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* gcc.dg/tree-ssa/ifc-5.c: New.\n+\n 2010-08-24  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* gcc.dg/tree-ssa/ifc-4.c: New."}, {"sha": "a9cc8168ebfd9e699290f77bb7ea42c40d7da6eb", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-5.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fd038a0c859f7f669370f06f0516e4bd5307b9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fd038a0c859f7f669370f06f0516e4bd5307b9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-5.c?ref=e1fd038a0c859f7f669370f06f0516e4bd5307b9", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-c -O2 -ftree-vectorize -fdump-tree-ifcvt-stats\" { target *-*-* } } */\n+\n+void\n+dct_unquantize_h263_inter_c (short *block, int n, int qscale, int nCoeffs)\n+{\n+  int i, level, qmul, qadd;\n+\n+  qadd = (qscale - 1) | 1;\n+  qmul = qscale << 1;\n+\n+  for (i = 0; i <= nCoeffs; i++)\n+    {\n+      level = block[i];\n+      if (level < 0)\n+\tlevel = level * qmul - qadd;\n+      else\n+\tlevel = level * qmul + qadd;\n+      block[i] = level;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Applying if-conversion\" 1 \"ifcvt\" } } */\n+/* { dg-final { cleanup-tree-dump \"ifcvt\" } } */"}, {"sha": "757c3c1fbecc4c00aba9ccf963fe5a7d4430415f", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fd038a0c859f7f669370f06f0516e4bd5307b9/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fd038a0c859f7f669370f06f0516e4bd5307b9/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=e1fd038a0c859f7f669370f06f0516e4bd5307b9", "patch": "@@ -417,6 +417,39 @@ extern void create_rdg_vertices (struct graph *, VEC (gimple, heap) *);\n extern bool dr_may_alias_p (const struct data_reference *,\n \t\t\t    const struct data_reference *);\n \n+\n+/* Return true when the base objects of data references A and B are\n+   the same memory object.  */\n+\n+static inline bool\n+same_data_refs_base_objects (data_reference_p a, data_reference_p b)\n+{\n+  return DR_NUM_DIMENSIONS (a) == DR_NUM_DIMENSIONS (b)\n+    && operand_equal_p (DR_BASE_OBJECT (a), DR_BASE_OBJECT (b), 0);\n+}\n+\n+/* Return true when the data references A and B are accessing the same\n+   memory object with the same access functions.  */\n+\n+static inline bool\n+same_data_refs (data_reference_p a, data_reference_p b)\n+{\n+  unsigned int i;\n+\n+  /* The references are exactly the same.  */\n+  if (operand_equal_p (DR_REF (a), DR_REF (b), 0))\n+    return true;\n+\n+  if (!same_data_refs_base_objects (a, b))\n+    return false;\n+\n+  for (i = 0; i < DR_NUM_DIMENSIONS (a); i++)\n+    if (!eq_evolutions_p (DR_ACCESS_FN (a, i), DR_ACCESS_FN (b, i)))\n+      return false;\n+\n+  return true;\n+}\n+\n /* Return true when the DDR contains two data references that have the\n    same access functions.  */\n "}, {"sha": "55e2a11a2b1665bb1fe8b028b2ca50d58cb0d2aa", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 204, "deletions": 67, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fd038a0c859f7f669370f06f0516e4bd5307b9/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fd038a0c859f7f669370f06f0516e4bd5307b9/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=e1fd038a0c859f7f669370f06f0516e4bd5307b9", "patch": "@@ -446,6 +446,132 @@ if_convertible_phi_p (struct loop *loop, basic_block bb, gimple phi)\n   return true;\n }\n \n+/* Returns true when the memory references of STMT are read or written\n+   unconditionally.  In other words, this function returns true when\n+   for every data reference A in STMT there exist other accesses to\n+   the same data reference with predicates that add up (OR-up) to the\n+   true predicate: this ensures that the data reference A is touched\n+   (read or written) on every iteration of the if-converted loop.  */\n+\n+static bool\n+memrefs_read_or_written_unconditionally (gimple stmt,\n+\t\t\t\t\t VEC (data_reference_p, heap) *drs)\n+{\n+  int i, j;\n+  data_reference_p a, b;\n+  tree ca = bb_predicate (gimple_bb (stmt));\n+\n+  for (i = 0; VEC_iterate (data_reference_p, drs, i, a); i++)\n+    if (DR_STMT (a) == stmt)\n+      {\n+\tbool found = false;\n+\n+\tfor (j = 0; VEC_iterate (data_reference_p, drs, j, b); j++)\n+\t  if (DR_STMT (b) != stmt\n+\t      && same_data_refs (a, b))\n+\t    {\n+\t      tree cb = bb_predicate (gimple_bb (DR_STMT (b)));\n+\n+\t      if (is_true_predicate (cb)\n+\t\t  || is_true_predicate (ca = fold_or_predicates (EXPR_LOCATION (cb),\n+\t\t\t\t\t\t\t\t ca, cb)))\n+\t\t{\n+\t\t  found = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\tif (!found)\n+\t  return false;\n+      }\n+\n+  return true;\n+}\n+\n+/* Returns true when the memory references of STMT are unconditionally\n+   written.  In other words, this function returns true when for every\n+   data reference A written in STMT, there exist other writes to the\n+   same data reference with predicates that add up (OR-up) to the true\n+   predicate: this ensures that the data reference A is written on\n+   every iteration of the if-converted loop.  */\n+\n+static bool\n+write_memrefs_written_at_least_once (gimple stmt,\n+\t\t\t\t     VEC (data_reference_p, heap) *drs)\n+{\n+  int i, j;\n+  data_reference_p a, b;\n+  tree ca = bb_predicate (gimple_bb (stmt));\n+\n+  for (i = 0; VEC_iterate (data_reference_p, drs, i, a); i++)\n+    if (DR_STMT (a) == stmt\n+\t&& !DR_IS_READ (a))\n+      {\n+\tbool found = false;\n+\n+\tfor (j = 0; VEC_iterate (data_reference_p, drs, j, b); j++)\n+\t  if (DR_STMT (b) != stmt\n+\t      && !DR_IS_READ (b)\n+\t      && same_data_refs_base_objects (a, b))\n+\t    {\n+\t      tree cb = bb_predicate (gimple_bb (DR_STMT (b)));\n+\n+\t      if (is_true_predicate (cb)\n+\t\t  || is_true_predicate (ca = fold_or_predicates (EXPR_LOCATION (cb),\n+\t\t\t\t\t\t\t\t ca, cb)))\n+\t\t{\n+\t\t  found = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\tif (!found)\n+\t  return false;\n+      }\n+\n+  return true;\n+}\n+\n+/* Return true when the memory references of STMT won't trap in the\n+   if-converted code.  There are two things that we have to check for:\n+\n+   - writes to memory occur to writable memory: if-conversion of\n+   memory writes transforms the conditional memory writes into\n+   unconditional writes, i.e. \"if (cond) A[i] = foo\" is transformed\n+   into \"A[i] = cond ? foo : A[i]\", and as the write to memory may not\n+   be executed at all in the original code, it may be a readonly\n+   memory.  To check that A is not const-qualified, we check that\n+   there exists at least an unconditional write to A in the current\n+   function.\n+\n+   - reads or writes to memory are valid memory accesses for every\n+   iteration.  To check that the memory accesses are correctly formed\n+   and that we are allowed to read and write in these locations, we\n+   check that the memory accesses to be if-converted occur at every\n+   iteration unconditionally.  */\n+\n+static bool\n+ifcvt_memrefs_wont_trap (gimple stmt, VEC (data_reference_p, heap) *refs)\n+{\n+  return write_memrefs_written_at_least_once (stmt, refs)\n+    && memrefs_read_or_written_unconditionally (stmt, refs);\n+}\n+\n+/* Wrapper around gimple_could_trap_p refined for the needs of the\n+   if-conversion.  Try to prove that the memory accesses of STMT could\n+   not trap in the innermost loop containing STMT.  */\n+\n+static bool\n+ifcvt_could_trap_p (gimple stmt, VEC (data_reference_p, heap) *refs)\n+{\n+  if (gimple_vuse (stmt)\n+      && !gimple_could_trap_p_1 (stmt, false, false)\n+      && ifcvt_memrefs_wont_trap (stmt, refs))\n+    return false;\n+\n+  return gimple_could_trap_p (stmt);\n+}\n+\n /* Return true when STMT is if-convertible.\n \n    GIMPLE_ASSIGN statement is not if-convertible if,\n@@ -454,7 +580,8 @@ if_convertible_phi_p (struct loop *loop, basic_block bb, gimple phi)\n    - LHS is not var decl.  */\n \n static bool\n-if_convertible_gimple_assign_stmt_p (gimple stmt)\n+if_convertible_gimple_assign_stmt_p (gimple stmt,\n+\t\t\t\t     VEC (data_reference_p, heap) *refs)\n {\n   tree lhs = gimple_assign_lhs (stmt);\n   basic_block bb;\n@@ -482,7 +609,7 @@ if_convertible_gimple_assign_stmt_p (gimple stmt)\n \n   if (flag_tree_loop_if_convert_stores)\n     {\n-      if (gimple_could_trap_p (stmt))\n+      if (ifcvt_could_trap_p (stmt, refs))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"tree could trap...\\n\");\n@@ -522,7 +649,7 @@ if_convertible_gimple_assign_stmt_p (gimple stmt)\n    - it is a GIMPLE_LABEL or a GIMPLE_COND.  */\n \n static bool\n-if_convertible_stmt_p (gimple stmt)\n+if_convertible_stmt_p (gimple stmt, VEC (data_reference_p, heap) *refs)\n {\n   switch (gimple_code (stmt))\n     {\n@@ -532,7 +659,7 @@ if_convertible_stmt_p (gimple stmt)\n       return true;\n \n     case GIMPLE_ASSIGN:\n-      return if_convertible_gimple_assign_stmt_p (stmt);\n+      return if_convertible_gimple_assign_stmt_p (stmt, refs);\n \n     default:\n       /* Don't know what to do with 'em so don't do anything.  */\n@@ -800,69 +927,24 @@ predicate_bbs (loop_p loop)\n   return true;\n }\n \n-/* Return true when LOOP is if-convertible.\n-   LOOP is if-convertible if:\n-   - it is innermost,\n-   - it has two or more basic blocks,\n-   - it has only one exit,\n-   - loop header is not the exit edge,\n-   - if its basic blocks and phi nodes are if convertible.  */\n+/* Return true when LOOP is if-convertible.  This is a helper function\n+   for if_convertible_loop_p.  REFS and DDRS are initialized and freed\n+   in if_convertible_loop_p.  */\n \n static bool\n-if_convertible_loop_p (struct loop *loop)\n+if_convertible_loop_p_1 (struct loop *loop,\n+\t\t\t VEC (data_reference_p, heap) **refs,\n+\t\t\t VEC (ddr_p, heap) **ddrs)\n {\n+  bool res;\n   unsigned int i;\n-  edge e;\n-  edge_iterator ei;\n   basic_block exit_bb = NULL;\n \n-  /* Handle only innermost loop.  */\n-  if (!loop || loop->inner)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"not innermost loop\\n\");\n-      return false;\n-    }\n-\n-  /* If only one block, no need for if-conversion.  */\n-  if (loop->num_nodes <= 2)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"less than 2 basic blocks\\n\");\n-      return false;\n-    }\n-\n-  /* More than one loop exit is too much to handle.  */\n-  if (!single_exit (loop))\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"multiple exits\\n\");\n-      return false;\n-    }\n-\n-  /* ??? Check target's vector conditional operation support for vectorizer.  */\n-\n-  /* If one of the loop header's edge is exit edge then do not apply\n-     if-conversion.  */\n-  FOR_EACH_EDGE (e, ei, loop->header->succs)\n-    {\n-      if (loop_exit_edge_p (loop, e))\n-\treturn false;\n-    }\n-\n   /* Don't if-convert the loop when the data dependences cannot be\n      computed: the loop won't be vectorized in that case.  */\n-  {\n-    VEC (data_reference_p, heap) *refs = VEC_alloc (data_reference_p, heap, 5);\n-    VEC (ddr_p, heap) *ddrs = VEC_alloc (ddr_p, heap, 25);\n-    bool res = compute_data_dependences_for_loop (loop, true, &refs, &ddrs);\n-\n-    free_data_refs (refs);\n-    free_dependence_relations (ddrs);\n-\n-    if (!res)\n-      return false;\n-  }\n+  res = compute_data_dependences_for_loop (loop, true, refs, ddrs);\n+  if (!res)\n+    return false;\n \n   calculate_dominance_info (CDI_DOMINATORS);\n \n@@ -886,7 +968,8 @@ if_convertible_loop_p (struct loop *loop)\n \texit_bb = bb;\n     }\n \n-  if (!predicate_bbs (loop))\n+  res = predicate_bbs (loop);\n+  if (!res)\n     return false;\n \n   for (i = 0; i < loop->num_nodes; i++)\n@@ -898,13 +981,11 @@ if_convertible_loop_p (struct loop *loop)\n \tif (!if_convertible_phi_p (loop, bb, gsi_stmt (itr)))\n \t  return false;\n \n-      /* For non predicated BBs, don't check their statements.  */\n-      if (!is_predicated (bb))\n-\tcontinue;\n-\n-      for (itr = gsi_start_bb (bb); !gsi_end_p (itr); gsi_next (&itr))\n-\tif (!if_convertible_stmt_p (gsi_stmt (itr)))\n-\t  return false;\n+      /* Check the if-convertibility of statements in predicated BBs.  */\n+      if (is_predicated (bb))\n+\tfor (itr = gsi_start_bb (bb); !gsi_end_p (itr); gsi_next (&itr))\n+\t  if (!if_convertible_stmt_p (gsi_stmt (itr), *refs))\n+\t    return false;\n     }\n \n   if (dump_file)\n@@ -913,6 +994,62 @@ if_convertible_loop_p (struct loop *loop)\n   return true;\n }\n \n+/* Return true when LOOP is if-convertible.\n+   LOOP is if-convertible if:\n+   - it is innermost,\n+   - it has two or more basic blocks,\n+   - it has only one exit,\n+   - loop header is not the exit edge,\n+   - if its basic blocks and phi nodes are if convertible.  */\n+\n+static bool\n+if_convertible_loop_p (struct loop *loop)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  bool res = false;\n+  VEC (data_reference_p, heap) *refs;\n+  VEC (ddr_p, heap) *ddrs;\n+\n+  /* Handle only innermost loop.  */\n+  if (!loop || loop->inner)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"not innermost loop\\n\");\n+      return false;\n+    }\n+\n+  /* If only one block, no need for if-conversion.  */\n+  if (loop->num_nodes <= 2)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"less than 2 basic blocks\\n\");\n+      return false;\n+    }\n+\n+  /* More than one loop exit is too much to handle.  */\n+  if (!single_exit (loop))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"multiple exits\\n\");\n+      return false;\n+    }\n+\n+  /* If one of the loop header's edge is an exit edge then do not\n+     apply if-conversion.  */\n+  FOR_EACH_EDGE (e, ei, loop->header->succs)\n+    if (loop_exit_edge_p (loop, e))\n+      return false;\n+\n+  refs = VEC_alloc (data_reference_p, heap, 5);\n+  ddrs = VEC_alloc (ddr_p, heap, 25);\n+  res = if_convertible_loop_p_1 (loop, &refs, &ddrs);\n+\n+  free_data_refs (refs);\n+  free_dependence_relations (ddrs);\n+  return res;\n+}\n+\n /* Basic block BB has two predecessors.  Using predecessor's bb\n    predicate, set an appropriate condition COND for the PHI node\n    replacement.  Return the true block whose phi arguments are"}]}