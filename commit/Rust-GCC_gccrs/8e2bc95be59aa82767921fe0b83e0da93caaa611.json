{"sha": "8e2bc95be59aa82767921fe0b83e0da93caaa611", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUyYmM5NWJlNTlhYTgyNzY3OTIxZmUwYjgzZTBkYTkzY2FhYTYxMQ==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2011-02-02T19:51:03Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-02-02T19:51:03Z"}, "message": "re PR fortran/47082 ([OOP] ICE in gfc_conv_component_ref)\n\n2011-02-02  Janus Weil  <janus@gcc.gnu.org>\n\t    Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/47082\n\t* trans-expr.c (gfc_trans_class_init_assign): Add call to\n\tgfc_get_derived_type.\n\t* module.c (read_cleanup): Do not use unique_symtrees for vtabs\n\tor vtypes.\n\n2011-02-02  Janus Weil  <janus@gcc.gnu.org>\n\t    Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/47082\n\t* gfortran.dg/class_37.f03 : New test.\n\n\nCo-Authored-By: Paul Thomas <pault@gcc.gnu.org>\n\nFrom-SVN: r169767", "tree": {"sha": "ffaee50911754a7de580e03aa7a2d82de33596ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffaee50911754a7de580e03aa7a2d82de33596ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e2bc95be59aa82767921fe0b83e0da93caaa611", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e2bc95be59aa82767921fe0b83e0da93caaa611", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e2bc95be59aa82767921fe0b83e0da93caaa611", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e2bc95be59aa82767921fe0b83e0da93caaa611/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "932e32375ae90a7ca6d146efccf7e87b820f032a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/932e32375ae90a7ca6d146efccf7e87b820f032a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/932e32375ae90a7ca6d146efccf7e87b820f032a"}], "stats": {"total": 299, "additions": 298, "deletions": 1}, "files": [{"sha": "09606e1800f65e0c91a544bae2108bdc18aad46f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2bc95be59aa82767921fe0b83e0da93caaa611/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2bc95be59aa82767921fe0b83e0da93caaa611/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8e2bc95be59aa82767921fe0b83e0da93caaa611", "patch": "@@ -1,3 +1,12 @@\n+2011-02-02  Janus Weil  <janus@gcc.gnu.org>\n+\t    Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/47082\n+\t* trans-expr.c (gfc_trans_class_init_assign): Add call to\n+\tgfc_get_derived_type.\n+\t* module.c (read_cleanup): Do not use unique_symtrees for vtabs\n+\tor vtypes.\n+\n 2011-02-02  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/47572"}, {"sha": "267809c4d77c09f982393608feb3f21353f0763b", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2bc95be59aa82767921fe0b83e0da93caaa611/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2bc95be59aa82767921fe0b83e0da93caaa611/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=8e2bc95be59aa82767921fe0b83e0da93caaa611", "patch": "@@ -4219,9 +4219,23 @@ read_cleanup (pointer_info *p)\n \n   if (p->type == P_SYMBOL && p->u.rsym.state == USED && !p->u.rsym.referenced)\n     {\n+      gfc_namespace *ns;\n       /* Add hidden symbols to the symtree.  */\n       q = get_integer (p->u.rsym.ns);\n-      st = gfc_get_unique_symtree ((gfc_namespace *) q->u.pointer);\n+      ns = (gfc_namespace *) q->u.pointer;\n+\n+      if (!p->u.rsym.sym->attr.vtype\n+\t    && !p->u.rsym.sym->attr.vtab)\n+\tst = gfc_get_unique_symtree (ns);\n+      else\n+\t{\n+\t  /* There is no reason to use 'unique_symtrees' for vtabs or\n+\t     vtypes - their name is fine for a symtree and reduces the\n+\t     namespace pollution.  */\n+\t  st = gfc_find_symtree (ns->sym_root, p->u.rsym.sym->name);\n+\t  if (!st)\n+\t    st = gfc_new_symtree (&ns->sym_root, p->u.rsym.sym->name);\n+\t}\n \n       st->n.sym = p->u.rsym.sym;\n       st->n.sym->refs++;"}, {"sha": "f19c015259844e564adbc3423a1d2c5762c3d01e", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2bc95be59aa82767921fe0b83e0da93caaa611/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2bc95be59aa82767921fe0b83e0da93caaa611/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=8e2bc95be59aa82767921fe0b83e0da93caaa611", "patch": "@@ -6300,6 +6300,11 @@ gfc_trans_class_init_assign (gfc_code *code)\n \n   rhs = gfc_copy_expr (code->expr1);\n   gfc_add_vptr_component (rhs);\n+\n+  /* Make sure that the component backend_decls have been built, which\n+     will not have happened if the derived types concerned have not\n+     been referenced.  */\n+  gfc_get_derived_type (rhs->ts.u.derived);\n   gfc_add_def_init_component (rhs);\n \n   sz = gfc_copy_expr (code->expr1);"}, {"sha": "440750d1c4be3f4d782f80b128f5da8c19f8e285", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2bc95be59aa82767921fe0b83e0da93caaa611/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2bc95be59aa82767921fe0b83e0da93caaa611/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e2bc95be59aa82767921fe0b83e0da93caaa611", "patch": "@@ -1,3 +1,9 @@\n+2011-02-02  Janus Weil  <janus@gcc.gnu.org>\n+\t    Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/47082\n+\t* gfortran.dg/class_37.f03 : New test.\n+\n 2011-02-02  Sebastian Pop  <sebastian.pop@amd.com>\n \t    Richard Guenther  <rguenther@suse.de>\n "}, {"sha": "f951ea1f8e01833ef9b958e8a52fdba20c74325a", "filename": "gcc/testsuite/gfortran.dg/class_37.f03", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2bc95be59aa82767921fe0b83e0da93caaa611/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_37.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2bc95be59aa82767921fe0b83e0da93caaa611/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_37.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_37.f03?ref=8e2bc95be59aa82767921fe0b83e0da93caaa611", "patch": "@@ -0,0 +1,263 @@\n+! { dg-do compile }\n+! Test fix for PR47082, in which an ICE in the ALLOCATE at line 248.\n+!\n+! Contributed by Salvatore Filippone  <salvatore.filippone@uniroma2.it>\n+!\n+module psb_penv_mod\n+\n+  interface psb_init\n+    module procedure  psb_init\n+  end interface\n+\n+  interface psb_exit\n+    module procedure  psb_exit\n+  end interface\n+\n+  interface psb_info\n+    module procedure psb_info\n+  end interface\n+\n+  integer, private, save :: nctxt=0\n+\n+\n+\n+contains\n+\n+\n+  subroutine psb_init(ictxt,np,basectxt,ids)\n+    implicit none \n+    integer, intent(out) :: ictxt\n+    integer, intent(in), optional :: np, basectxt, ids(:)\n+\n+\n+    ictxt = nctxt\n+    nctxt = nctxt + 1\n+\n+  end subroutine psb_init\n+\n+  subroutine psb_exit(ictxt,close)\n+    implicit none \n+    integer, intent(inout) :: ictxt\n+    logical, intent(in), optional :: close\n+\n+    nctxt = max(0, nctxt - 1)    \n+\n+  end subroutine psb_exit\n+\n+\n+  subroutine psb_info(ictxt,iam,np)\n+\n+    implicit none \n+\n+    integer, intent(in)  :: ictxt\n+    integer, intent(out) :: iam, np\n+\n+    iam = 0\n+    np  = 1\n+\n+  end subroutine psb_info\n+\n+\n+end module psb_penv_mod\n+\n+\n+module psb_indx_map_mod\n+\n+  type      :: psb_indx_map\n+\n+    integer :: state          = -1\n+    integer :: ictxt          = -1\n+    integer :: mpic           = -1\n+    integer :: global_rows    = -1\n+    integer :: global_cols    = -1\n+    integer :: local_rows     = -1\n+    integer :: local_cols     = -1\n+\n+\n+  end type psb_indx_map\n+\n+end module psb_indx_map_mod\n+\n+\n+\n+module psb_gen_block_map_mod\n+  use psb_indx_map_mod\n+  \n+  type, extends(psb_indx_map) :: psb_gen_block_map\n+    integer :: min_glob_row   = -1\n+    integer :: max_glob_row   = -1\n+    integer, allocatable :: loc_to_glob(:), srt_l2g(:,:), vnl(:)\n+  contains\n+\n+    procedure, pass(idxmap)  :: gen_block_map_init => block_init\n+\n+  end type psb_gen_block_map\n+\n+  private ::  block_init\n+\n+contains\n+\n+  subroutine block_init(idxmap,ictxt,nl,info)\n+    use psb_penv_mod\n+    implicit none \n+    class(psb_gen_block_map), intent(inout) :: idxmap\n+    integer, intent(in)  :: ictxt, nl\n+    integer, intent(out) :: info\n+    !  To be implemented\n+    integer :: iam, np, i, j, ntot\n+    integer, allocatable :: vnl(:)\n+\n+    info = 0\n+    call psb_info(ictxt,iam,np) \n+    if (np < 0) then \n+      info = -1\n+      return\n+    end if\n+    \n+    allocate(vnl(0:np),stat=info)\n+    if (info /= 0)  then\n+      info = -2\n+      return\n+    end if\n+    \n+    vnl(:)   = 0\n+    vnl(iam) = nl\n+    ntot = sum(vnl)\n+    vnl(1:np) = vnl(0:np-1)\n+    vnl(0) = 0\n+    do i=1,np\n+      vnl(i) = vnl(i) + vnl(i-1)\n+    end do\n+    if (ntot /= vnl(np)) then \n+! !$      write(0,*) ' Mismatch in block_init ',ntot,vnl(np)\n+    end if\n+    \n+    idxmap%global_rows  = ntot\n+    idxmap%global_cols  = ntot\n+    idxmap%local_rows   = nl\n+    idxmap%local_cols   = nl\n+    idxmap%ictxt        = ictxt\n+    idxmap%state        = 1\n+\n+    idxmap%min_glob_row = vnl(iam)+1\n+    idxmap%max_glob_row = vnl(iam+1) \n+    call move_alloc(vnl,idxmap%vnl)\n+    allocate(idxmap%loc_to_glob(nl),stat=info) \n+    if (info /= 0)  then\n+      info = -2\n+      return\n+    end if\n+    \n+  end subroutine block_init\n+\n+end module psb_gen_block_map_mod\n+\n+\n+module psb_descriptor_type\n+  use psb_indx_map_mod\n+\n+  implicit none\n+\n+\n+  type psb_desc_type\n+    integer, allocatable  :: matrix_data(:)\n+    integer, allocatable  :: halo_index(:)\n+    integer, allocatable  :: ext_index(:)\n+    integer, allocatable  :: ovrlap_index(:)\n+    integer, allocatable  :: ovrlap_elem(:,:)\n+    integer, allocatable  :: ovr_mst_idx(:)\n+    integer, allocatable  :: bnd_elem(:)\n+    class(psb_indx_map), allocatable :: indxmap\n+    integer, allocatable  :: lprm(:)\n+    type(psb_desc_type), pointer     :: base_desc => null()\n+    integer, allocatable  :: idx_space(:)\n+  end type psb_desc_type\n+\n+\n+end module psb_descriptor_type\n+\n+module psb_cd_if_tools_mod\n+\n+  use psb_descriptor_type\n+  use psb_gen_block_map_mod\n+\n+  interface psb_cdcpy\n+    subroutine psb_cdcpy(desc_in, desc_out, info)\n+      use psb_descriptor_type\n+\n+      implicit none\n+      !....parameters...\n+\n+      type(psb_desc_type), intent(in)  :: desc_in\n+      type(psb_desc_type), intent(out) :: desc_out\n+      integer, intent(out)             :: info\n+    end subroutine psb_cdcpy\n+  end interface\n+\n+\n+end module psb_cd_if_tools_mod\n+\n+module psb_cd_tools_mod\n+\n+  use psb_cd_if_tools_mod\n+\n+  interface psb_cdall\n+\n+    subroutine psb_cdall(ictxt, desc, info,mg,ng,vg,vl,flag,nl,repl, globalcheck)\n+      use psb_descriptor_type\n+      implicit None\n+      Integer, intent(in)               :: mg,ng,ictxt, vg(:), vl(:),nl\n+      integer, intent(in)               :: flag\n+      logical, intent(in)               :: repl, globalcheck\n+      integer, intent(out)              :: info\n+      type(psb_desc_type), intent(out)  :: desc\n+      \n+      optional :: mg,ng,vg,vl,flag,nl,repl, globalcheck\n+    end subroutine psb_cdall\n+   \n+  end interface\n+\n+end module psb_cd_tools_mod\n+module psb_base_tools_mod\n+  use psb_cd_tools_mod\n+end module psb_base_tools_mod\n+\n+subroutine psb_cdall(ictxt, desc, info,mg,ng,vg,vl,flag,nl,repl, globalcheck)\n+  use psb_descriptor_type\n+  use psb_gen_block_map_mod\n+  use psb_base_tools_mod, psb_protect_name => psb_cdall\n+  implicit None\n+  Integer, intent(in)               :: mg,ng,ictxt, vg(:), vl(:),nl\n+  integer, intent(in)               :: flag\n+  logical, intent(in)               :: repl, globalcheck\n+  integer, intent(out)              :: info\n+  type(psb_desc_type), intent(out)  :: desc\n+\n+  optional :: mg,ng,vg,vl,flag,nl,repl, globalcheck\n+  integer :: err_act, n_, flag_, i, me, np, nlp, nnv, lr\n+  integer, allocatable :: itmpsz(:) \n+\n+\n+\n+  info = 0\n+  desc%base_desc => null() \n+  if (allocated(desc%indxmap)) then \n+    write(0,*) 'Allocated on an intent(OUT) var?'\n+  end if\n+\n+  allocate(psb_gen_block_map :: desc%indxmap, stat=info)\n+  if (info == 0) then \n+    select type(aa => desc%indxmap) \n+    type is (psb_gen_block_map) \n+      call aa%gen_block_map_init(ictxt,nl,info)\n+    class default \n+        ! This cannot happen \n+      info = -1\n+    end select\n+  end if\n+\n+  return\n+\n+end subroutine psb_cdall\n+\n+ "}]}