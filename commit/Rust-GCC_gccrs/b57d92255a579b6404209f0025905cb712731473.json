{"sha": "b57d92255a579b6404209f0025905cb712731473", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU3ZDkyMjU1YTU3OWI2NDA0MjA5ZjAwMjU5MDVjYjcxMjczMTQ3Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-02-06T01:18:06Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-02-06T01:18:06Z"}, "message": "dwarf2out.c: Add old_args_size.\n\n\t* dwarf2out.c: Add old_args_size.\n\t(dwarf2out_args_size): Use it.\n\t(dwarf2out_begin_prologue): Initialize it.\n\t(dwarf2out_stack_adjust): If !asynchronous_exceptions, save up\n\tpushed args until we see a call.\n\t* final.c (final_scan_insn): Hand CALL_INSNs off to the dwarf2 code\n\tbefore outputting them.\n\t* cplus-dem.c (demangle_template_template_parm): New function.\n\t(demangle_template): Handle template template parameters.\n\nFrom-SVN: r17685", "tree": {"sha": "5d24951e6f65a794707a6a64e1c7b521375dd809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d24951e6f65a794707a6a64e1c7b521375dd809"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b57d92255a579b6404209f0025905cb712731473", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b57d92255a579b6404209f0025905cb712731473", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b57d92255a579b6404209f0025905cb712731473", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b57d92255a579b6404209f0025905cb712731473/comments", "author": null, "committer": null, "parents": [{"sha": "259620a822f977a298dfa1a1e24f1d082b949038", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/259620a822f977a298dfa1a1e24f1d082b949038", "html_url": "https://github.com/Rust-GCC/gccrs/commit/259620a822f977a298dfa1a1e24f1d082b949038"}], "stats": {"total": 200, "additions": 188, "deletions": 12}, "files": [{"sha": "ed83329115a9072e29d38e25be1612fbf1f9250f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b57d92255a579b6404209f0025905cb712731473/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b57d92255a579b6404209f0025905cb712731473/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b57d92255a579b6404209f0025905cb712731473", "patch": "@@ -1,3 +1,18 @@\n+1998-02-06  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* dwarf2out.c: Add old_args_size.\n+\t(dwarf2out_args_size): Use it.\n+\t(dwarf2out_begin_prologue): Initialize it.\n+\t(dwarf2out_stack_adjust): If !asynchronous_exceptions, save up\n+\tpushed args until we see a call.\n+\t* final.c (final_scan_insn): Hand CALL_INSNs off to the dwarf2 code\n+\tbefore outputting them.\n+\n+1998-02-06  Kriang Lerdsuwanakij  <lerdsuwa@scf.usc.edu>\n+\n+\t* cplus-dem.c (demangle_template_template_parm): New function.\n+\t(demangle_template): Handle template template parameters.\n+\n 1998-02-02  Mark Mitchell  <mmitchell@usa.net>\n \n \t* calls.c (expand_call): Don't confuse member functions named"}, {"sha": "b915fe1498f011171c4d3fb5f5494afa4a645d04", "filename": "gcc/cplus-dem.c", "status": "modified", "additions": 135, "deletions": 9, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b57d92255a579b6404209f0025905cb712731473/gcc%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b57d92255a579b6404209f0025905cb712731473/gcc%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcplus-dem.c?ref=b57d92255a579b6404209f0025905cb712731473", "patch": "@@ -225,6 +225,10 @@ static int\n demangle_method_args PARAMS ((struct work_stuff *work, const char **, string *));\n #endif\n \n+static int\n+demangle_template_template_parm PARAMS ((struct work_stuff *work, \n+\t\t\t\t\t const char **, string *));\n+\n static int\n demangle_template PARAMS ((struct work_stuff *work, const char **, string *,\n \t\t\t   string *, int));\n@@ -925,6 +929,70 @@ demangle_method_args (work, mangled, declp)\n \n #endif\n \n+static int\n+demangle_template_template_parm (work, mangled, tname)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *tname;\n+{\n+  int i;\n+  int r;\n+  int need_comma = 0;\n+  int success = 1;\n+  string temp;\n+\n+  string_append (tname, \"template <\");\n+  /* get size of template parameter list */\n+  if (get_count (mangled, &r))\n+    {\n+      for (i = 0; i < r; i++)\n+\t{\n+\t  if (need_comma)\n+\t    {\n+\t      string_append (tname, \", \");\n+\t    }\n+\n+\t    /* Z for type parameters */\n+\t    if (**mangled == 'Z')\n+\t      {\n+\t\t(*mangled)++;\n+\t\tstring_append (tname, \"class\");\n+\t      }\n+\t      /* z for template parameters */\n+\t    else if (**mangled == 'z')\n+\t      {\n+\t\t(*mangled)++;\n+\t\tsuccess = \n+\t\t  demangle_template_template_parm (work, mangled, tname);\n+\t\tif (!success)\n+\t\t  {\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* temp is initialized in do_type */\n+\t\tsuccess = do_type (work, mangled, &temp);\n+\t\tif (success)\n+\t\t  {\n+\t\t    string_appends (tname, &temp);\n+\t\t  }\n+\t\tstring_delete(&temp);\n+\t\tif (!success)\n+\t\t  {\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t  need_comma = 1;\n+\t}\n+\n+    }\n+  if (tname->p[-1] == '>')\n+    string_append (tname, \" \");\n+  string_append (tname, \"> class\");\n+  return (success);\n+}\n+\n static int\n demangle_template (work, mangled, tname, trawname, is_type)\n      struct work_stuff *work;\n@@ -954,19 +1022,50 @@ demangle_template (work, mangled, tname, trawname, is_type)\n     {\n       start = *mangled;\n       /* get template name */\n-      if ((r = consume_count (mangled)) == 0 || strlen (*mangled) < r)\n+      if (**mangled == 'z')\n \t{\n-\t  return (0);\n+\t  int idx;\n+\t  (*mangled)++;\n+\t  (*mangled)++;\n+\n+\t  idx = consume_count_with_underscores (mangled);\n+\t  if (idx == -1 \n+\t      || (work->tmpl_argvec && idx >= work->ntmpl_args)\n+\t      || consume_count_with_underscores (mangled) == -1)\n+\t    {\n+\t      return (0);\n+\t    }\n+\t  if (work->tmpl_argvec)\n+\t    {\n+\t      string_append (tname, work->tmpl_argvec[idx]);\n+\t      if (trawname)\n+\t\tstring_append (trawname, work->tmpl_argvec[idx]);\n+\t    }\n+\t  else\n+\t    {\n+\t      char buf[10];\n+\t      sprintf(buf, \"T%d\", idx);\n+\t      string_append (tname, buf);\n+\t      if (trawname)\n+\t\tstring_append (trawname, work->tmpl_argvec[idx]);\n+\t    }\n \t}\n-      if (trawname)\n-\tstring_appendn (trawname, *mangled, r);\n-      is_java_array = (work -> options & DMGL_JAVA)\n-\t&& strncmp (*mangled, \"JArray1Z\", 8) == 0;\n-      if (! is_java_array)\n+      else\n \t{\n-\t  string_appendn (tname, *mangled, r);\n+\t  if ((r = consume_count (mangled)) == 0 || strlen (*mangled) < r)\n+\t    {\n+\t      return (0);\n+\t    }\n+\t  if (trawname)\n+\t    string_appendn (trawname, *mangled, r);\n+\t  is_java_array = (work -> options & DMGL_JAVA)\n+\t    && strncmp (*mangled, \"JArray1Z\", 8) == 0;\n+\t  if (! is_java_array)\n+\t    {\n+\t      string_appendn (tname, *mangled, r);\n+\t    }\n+\t  *mangled += r;\n \t}\n-      *mangled += r;\n     }\n   if (!is_java_array)\n     string_append (tname, \"<\");\n@@ -1014,6 +1113,33 @@ demangle_template (work, mangled, tname, trawname, is_type)\n \t      break;\n \t    }\n \t}\n+      /* z for template parameters */\n+      else if (**mangled == 'z')\n+\t{\n+\t  int r2;\n+\t  (*mangled)++;\n+\t  success = demangle_template_template_parm (work, mangled, tname);\n+\t  \n+\t  if (success\n+\t      && (r2 = consume_count (mangled)) > 0 && strlen (*mangled) >= r2)\n+\t    {\n+\t      string_append (tname, \" \");\n+\t      string_appendn (tname, *mangled, r2);\n+\t      if (!is_type)\n+\t\t{\n+\t\t  /* Save the template argument. */\n+\t\t  int len = r2;\n+\t\t  work->tmpl_argvec[i] = xmalloc (len + 1);\n+\t\t  memcpy (work->tmpl_argvec[i], *mangled, len);\n+\t\t  work->tmpl_argvec[i][len] = '\\0';\n+\t\t}\n+\t      *mangled += r2;\n+\t    }\n+\t  if (!success)\n+\t    {\n+\t      break;\n+\t    }\n+\t}\n       else\n \t{\n \t  string  param;"}, {"sha": "fe2231f11986cfdf8ff7fa2cc9feed3167a58168", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b57d92255a579b6404209f0025905cb712731473/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b57d92255a579b6404209f0025905cb712731473/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b57d92255a579b6404209f0025905cb712731473", "patch": "@@ -847,6 +847,9 @@ static long cfa_store_offset;\n /* The running total of the size of arguments pushed onto the stack.  */\n static long args_size;\n \n+/* The last args_size we actually output.  */\n+static long old_args_size;\n+\n /* Entry point to update the canonical frame address (CFA).\n    LABEL is passed to add_fde_cfi.  The value of CFA is now to be\n    calculated from REG+OFFSET.  */\n@@ -961,7 +964,13 @@ dwarf2out_args_size (label, size)\n      char *label;\n      long size;\n {\n-  register dw_cfi_ref cfi = new_cfi ();\n+  register dw_cfi_ref cfi;\n+\n+  if (size == old_args_size)\n+    return;\n+  old_args_size = size;\n+\n+  cfi = new_cfi ();\n   cfi->dw_cfi_opc = DW_CFA_GNU_args_size;\n   cfi->dw_cfi_oprnd1.dw_cfi_offset = size;\n   add_fde_cfi (label, cfi);\n@@ -1067,6 +1076,26 @@ dwarf2out_stack_adjust (insn)\n   long offset;\n   char *label;\n \n+  if (! asynchronous_exceptions && GET_CODE (insn) == CALL_INSN)\n+    {\n+      /* Extract the size of the args from the CALL rtx itself.  */\n+\n+      insn = PATTERN (insn);\n+      if (GET_CODE (insn) == PARALLEL)\n+\tinsn = XVECEXP (insn, 0, 0);\n+      if (GET_CODE (insn) == SET)\n+\tinsn = SET_SRC (insn);\n+      assert (GET_CODE (insn) == CALL);\n+      dwarf2out_args_size (\"\", INTVAL (XEXP (insn, 1)));\n+      return;\n+    }\n+\n+  /* If only calls can throw, and we have a frame pointer,\n+     save up adjustments until we see the CALL_INSN.  */\n+  else if (! asynchronous_exceptions\n+\t   && cfa_reg != STACK_POINTER_REGNUM)\n+    return;\n+\n   if (GET_CODE (insn) == BARRIER)\n     {\n       /* When we see a BARRIER, we know to reset args_size to 0.  Usually\n@@ -1850,7 +1879,7 @@ dwarf2out_begin_prologue ()\n   fde->dw_fde_end = NULL;\n   fde->dw_fde_cfi = NULL;\n \n-  args_size = 0;\n+  args_size = old_args_size = 0;\n }\n \n /* Output a marker (i.e. a label) for the absolute end of the generated code"}, {"sha": "cf131c52a28c6dc6a8b1dbc96fbda7ff7e604466", "filename": "gcc/final.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b57d92255a579b6404209f0025905cb712731473/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b57d92255a579b6404209f0025905cb712731473/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=b57d92255a579b6404209f0025905cb712731473", "patch": "@@ -2174,6 +2174,12 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \n \tdebug_insn = insn;\n \n+#if defined (DWARF2_UNWIND_INFO) && !defined (ACCUMULATE_OUTGOING_ARGS)\n+\t/* If we push arguments, we want to know where the calls are.  */\n+\tif (GET_CODE (insn) == CALL_INSN && dwarf2out_do_frame ())\n+\t  dwarf2out_frame_debug (insn);\n+#endif\n+\n \t/* If the proper template needs to be chosen by some C code,\n \t   run that code and get the real template.  */\n \n@@ -2226,7 +2232,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n #if !defined (ACCUMULATE_OUTGOING_ARGS)\n \t/* If we push arguments, we need to check all insns for stack\n \t   adjustments.  */\n-\tif (dwarf2out_do_frame ())\n+\tif (GET_CODE (insn) == INSN && dwarf2out_do_frame ())\n \t  dwarf2out_frame_debug (insn);\n #else\n #if defined (HAVE_prologue)"}]}