{"sha": "1312bb902382cb4891673284f43ac095e80374cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTMxMmJiOTAyMzgyY2I0ODkxNjczMjg0ZjQzYWMwOTVlODAzNzRjZg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-08-28T11:35:52Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-08-28T11:35:52Z"}, "message": "re PR fortran/80477 ([OOP] Polymorphic function result generates memory leak)\n\n2017-08-28  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/80477\n\t* trans-expr.c (gfc_conv_procedure_call): Allocatable class\n\tscalar results being passed to a derived type formal argument\n\tare finalized if possible. Otherwise, rely on existing code for\n\tdeallocation. Make the deallocation of allocatable result\n\tcomponents conditional on finalization not taking place. Make\n\tthe freeing of data components after finalization conditional\n\ton the data being NULL.\n\t(gfc_trans_arrayfunc_assign): Change the gcc_assert to a\n\tcondition to return NULL_TREE.\n\t(gfc_trans_assignment_1): If the assignment is class to class\n\tand the rhs expression must be finalized but the assignment\n\tis not marked as a polymorphic assignment, use the vptr copy\n\tfunction instead of gfc_trans_scalar_assign.\n\n\tPR fortran/86481\n\t* trans-expr.c (gfc_conv_expr_reference): Do not add the post\n\tblock to the pre block if the expression is to be finalized.\n\t* trans-stmt.c (gfc_trans_allocate): If the expr3 must be\n\tfinalized, load the post block into a finalization block and\n\tadd it right at the end of the allocation block.\n\n2017-08-28  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/80477\n\t* gfortran.dg/class_result_7.f90: New test.\n\t* gfortran.dg/class_result_8.f90: New test.\n\t* gfortran.dg/class_result_9.f90: New test.\n\n\tPR fortran/86481\n\t* gfortran.dg/allocate_with_source_25.f90: New test.\n\nFrom-SVN: r263916", "tree": {"sha": "8ce6e0709fe7da9193539e9a2c66bf15130cb155", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ce6e0709fe7da9193539e9a2c66bf15130cb155"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1312bb902382cb4891673284f43ac095e80374cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1312bb902382cb4891673284f43ac095e80374cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1312bb902382cb4891673284f43ac095e80374cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1312bb902382cb4891673284f43ac095e80374cf/comments", "author": null, "committer": null, "parents": [{"sha": "2c8861b7505cdc04377cd125565bb5ccadb29529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c8861b7505cdc04377cd125565bb5ccadb29529", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c8861b7505cdc04377cd125565bb5ccadb29529"}], "stats": {"total": 366, "additions": 347, "deletions": 19}, "files": [{"sha": "04598438aaededec6651157606153ad4e5823f1b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1312bb902382cb4891673284f43ac095e80374cf/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1312bb902382cb4891673284f43ac095e80374cf/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1312bb902382cb4891673284f43ac095e80374cf", "patch": "@@ -1,3 +1,27 @@\n+2017-08-28  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/80477\n+\t* trans-expr.c (gfc_conv_procedure_call): Allocatable class\n+\tscalar results being passed to a derived type formal argument\n+\tare finalized if possible. Otherwise, rely on existing code for\n+\tdeallocation. Make the deallocation of allocatable result\n+\tcomponents conditional on finalization not taking place. Make\n+\tthe freeing of data components after finalization conditional\n+\ton the data being NULL.\n+\t(gfc_trans_arrayfunc_assign): Change the gcc_assert to a\n+\tcondition to return NULL_TREE.\n+\t(gfc_trans_assignment_1): If the assignment is class to class\n+\tand the rhs expression must be finalized but the assignment\n+\tis not marked as a polymorphic assignment, use the vptr copy\n+\tfunction instead of gfc_trans_scalar_assign.\n+\n+\tPR fortran/86481\n+\t* trans-expr.c (gfc_conv_expr_reference): Do not add the post\n+\tblock to the pre block if the expression is to be finalized.\n+\t* trans-stmt.c (gfc_trans_allocate): If the expr3 must be\n+\tfinalized, load the post block into a finalization block and\n+\tadd it right at the end of the allocation block.\n+\n 2018-08-27  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR 87091"}, {"sha": "56ce98c78c69283947fbde861510c639360ad200", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 107, "deletions": 18, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1312bb902382cb4891673284f43ac095e80374cf/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1312bb902382cb4891673284f43ac095e80374cf/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=1312bb902382cb4891673284f43ac095e80374cf", "patch": "@@ -4886,6 +4886,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   for (arg = args, argc = 0; arg != NULL;\n        arg = arg->next, formal = formal ? formal->next : NULL, ++argc)\n     {\n+      bool finalized = false;\n+\n       e = arg->expr;\n       fsym = formal ? formal->sym : NULL;\n       parm_kind = MISSING;\n@@ -5360,7 +5362,42 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t      && e->ts.type == BT_CLASS\n \t\t      && !CLASS_DATA (e)->attr.dimension\n \t\t      && !CLASS_DATA (e)->attr.codimension)\n-\t\t    parmse.expr = gfc_class_data_get (parmse.expr);\n+\t\t    {\n+\t\t      parmse.expr = gfc_class_data_get (parmse.expr);\n+\t\t      /* The result is a class temporary, whose _data component\n+\t\t\t must be freed to avoid a memory leak.  */\n+\t\t      if (e->expr_type == EXPR_FUNCTION\n+\t\t\t  && CLASS_DATA (e)->attr.allocatable)\n+\t\t\t{\n+\t\t\t  tree zero;\n+\n+\t\t\t  gfc_expr *var;\n+\n+\t\t\t  /* Borrow the function symbol to make a call to\n+\t\t\t     gfc_add_finalizer_call and then restore it.  */\n+\t\t\t  tmp = e->symtree->n.sym->backend_decl;\n+\t\t\t  e->symtree->n.sym->backend_decl\n+\t\t\t\t\t= TREE_OPERAND (parmse.expr, 0);\n+\t\t\t  e->symtree->n.sym->attr.flavor = FL_VARIABLE;\n+\t\t\t  var = gfc_lval_expr_from_sym (e->symtree->n.sym);\n+\t\t\t  finalized = gfc_add_finalizer_call (&parmse.post,\n+\t\t\t\t\t\t\t      var);\n+\t\t\t  gfc_free_expr (var);\n+\t\t\t  e->symtree->n.sym->backend_decl = tmp;\n+\t\t\t  e->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n+\n+\t\t\t  /* Then free the class _data.  */\n+\t\t\t  zero = build_int_cst (TREE_TYPE (parmse.expr), 0);\n+\t\t\t  tmp = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t\t\t logical_type_node,\n+\t\t\t\t\t\t parmse.expr, zero);\n+\t\t\t  tmp = build3_v (COND_EXPR, tmp,\n+\t\t\t\t\t  gfc_call_free (parmse.expr),\n+\t\t\t\t\t  build_empty_stmt (input_location));\n+\t\t\t  gfc_add_expr_to_block (&parmse.post, tmp);\n+\t\t\t  gfc_add_modify (&parmse.post, parmse.expr, zero);\n+\t\t\t}\n+\t\t    }\n \n \t\t  /* Wrap scalar variable in a descriptor. We need to convert\n \t\t     the address of a pointer back to the pointer itself before,\n@@ -5687,9 +5724,18 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\ttmp = build_fold_indirect_ref_loc (input_location, tmp);\n \t    }\n \n-\t  tmp = gfc_deallocate_alloc_comp (e->ts.u.derived, tmp, parm_rank);\n-\n-\t  gfc_prepend_expr_to_block (&post, tmp);\n+\t  if (!finalized && !e->must_finalize)\n+\t    {\n+\t      if ((e->ts.type == BT_CLASS\n+\t\t   && GFC_CLASS_TYPE_P (TREE_TYPE (tmp)))\n+\t\t  || e->ts.type == BT_DERIVED)\n+\t\ttmp = gfc_deallocate_alloc_comp (e->ts.u.derived, tmp,\n+\t\t\t\t\t\t parm_rank);\n+\t      else if (e->ts.type == BT_CLASS)\n+\t\ttmp = gfc_deallocate_alloc_comp (CLASS_DATA (e)->ts.u.derived,\n+\t\t\t\t\t\t tmp, parm_rank);\n+\t      gfc_prepend_expr_to_block (&post, tmp);\n+\t    }\n         }\n \n       /* Add argument checking of passing an unallocated/NULL actual to\n@@ -6410,7 +6456,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  final_fndecl = gfc_class_vtab_final_get (se->expr);\n \t  is_final = fold_build2_loc (input_location, NE_EXPR,\n \t\t\t\t      logical_type_node,\n- \t\t\t    \t      final_fndecl,\n+\t\t\t\t      final_fndecl,\n \t\t\t\t      fold_convert (TREE_TYPE (final_fndecl),\n \t\t\t\t\t   \t    null_pointer_node));\n \t  final_fndecl = build_fold_indirect_ref_loc (input_location,\n@@ -6420,28 +6466,43 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t     gfc_build_addr_expr (NULL, tmp),\n \t\t\t\t     gfc_class_vtab_size_get (se->expr),\n \t\t\t\t     boolean_false_node);\n- \t  tmp = fold_build3_loc (input_location, COND_EXPR,\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t void_type_node, is_final, tmp,\n \t\t\t\t build_empty_stmt (input_location));\n \n \t  if (se->ss && se->ss->loop)\n \t    {\n-\t      gfc_add_expr_to_block (&se->ss->loop->post, tmp);\n-\t      tmp = gfc_call_free (info->data);\n+\t      gfc_prepend_expr_to_block (&se->ss->loop->post, tmp);\n+\t      tmp = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t     logical_type_node,\n+\t\t\t\t     info->data,\n+\t\t\t\t     fold_convert (TREE_TYPE (info->data),\n+\t\t\t\t\t   \t    null_pointer_node));\n+\t      tmp = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t     void_type_node, tmp,\n+\t\t\t\t     gfc_call_free (info->data),\n+\t\t\t\t     build_empty_stmt (input_location));\n \t      gfc_add_expr_to_block (&se->ss->loop->post, tmp);\n \t    }\n \t  else\n \t    {\n-\t      gfc_add_expr_to_block (&se->post, tmp);\n-\t      tmp = gfc_class_data_get (se->expr);\n-\t      tmp = gfc_call_free (tmp);\n+\t      tree classdata;\n+\t      gfc_prepend_expr_to_block (&se->post, tmp);\n+\t      classdata = gfc_class_data_get (se->expr);\n+\t      tmp = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t     logical_type_node,\n+\t\t\t\t     classdata,\n+\t\t\t\t     fold_convert (TREE_TYPE (classdata),\n+\t\t\t\t\t   \t    null_pointer_node));\n+\t      tmp = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t     void_type_node, tmp,\n+\t\t\t\t     gfc_call_free (classdata),\n+\t\t\t\t     build_empty_stmt (input_location));\n \t      gfc_add_expr_to_block (&se->post, tmp);\n \t    }\n-\n-no_finalization:\n-\t  expr->must_finalize = 0;\n \t}\n \n+no_finalization:\n       gfc_add_block_to_block (&se->post, &post);\n     }\n \n@@ -8072,7 +8133,9 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)\n       var = gfc_create_var (TREE_TYPE (se->expr), NULL);\n       gfc_add_modify (&se->pre, var, se->expr);\n     }\n-  gfc_add_block_to_block (&se->pre, &se->post);\n+\n+  if (!expr->must_finalize)\n+    gfc_add_block_to_block (&se->pre, &se->post);\n \n   /* Take the address of that value.  */\n   se->expr = gfc_build_addr_expr (NULL_TREE, var);\n@@ -9262,10 +9325,12 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n   /* The frontend doesn't seem to bother filling in expr->symtree for intrinsic\n      functions.  */\n   comp = gfc_get_proc_ptr_comp (expr2);\n-  gcc_assert (expr2->value.function.isym\n+\n+  if (!(expr2->value.function.isym\n \t      || (comp && comp->attr.dimension)\n \t      || (!comp && gfc_return_by_reference (expr2->value.function.esym)\n-\t\t  && expr2->value.function.esym->result->attr.dimension));\n+\t\t  && expr2->value.function.esym->result->attr.dimension)))\n+    return NULL;\n \n   gfc_init_se (&se, NULL);\n   gfc_start_block (&se.pre);\n@@ -10238,6 +10303,8 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \tgfc_add_block_to_block (&loop.post, &rse.post);\n     }\n \n+  tmp = NULL_TREE;\n+\n   if (is_poly_assign)\n     tmp = trans_class_assignment (&body, expr1, expr2, &lse, &rse,\n \t\t\t\t  use_vptr_copy || (lhs_attr.allocatable\n@@ -10266,13 +10333,35 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n       code.resolved_isym = gfc_intrinsic_subroutine_by_id (GFC_ISYM_CAF_SEND);\n       tmp = gfc_conv_intrinsic_subroutine (&code);\n     }\n-  else\n+  else if (!is_poly_assign && expr2->must_finalize\n+\t   && expr1->ts.type == BT_CLASS\n+\t   && expr2->ts.type == BT_CLASS)\n+    {\n+      /* This case comes about when the scalarizer provides array element\n+\t references. Use the vptr copy function, since this does a deep\n+\t copy of allocatable components, without which the finalizer call */\n+      tmp = gfc_get_vptr_from_expr (rse.expr);\n+      if (tmp != NULL_TREE)\n+\t{\n+\t  tree fcn = gfc_vptr_copy_get (tmp);\n+\t  if (POINTER_TYPE_P (TREE_TYPE (fcn)))\n+\t    fcn = build_fold_indirect_ref_loc (input_location, fcn);\n+\t  tmp = build_call_expr_loc (input_location,\n+\t\t\t\t     fcn, 2,\n+\t\t\t\t     gfc_build_addr_expr (NULL, rse.expr),\n+\t\t\t\t     gfc_build_addr_expr (NULL, lse.expr));\n+\t}\n+    }\n+\n+  /* If nothing else works, do it the old fashioned way!  */\n+  if (tmp == NULL_TREE)\n     tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts,\n \t\t\t\t   gfc_expr_is_variable (expr2)\n \t\t\t\t   || scalar_to_array\n \t\t\t\t   || expr2->expr_type == EXPR_ARRAY,\n \t\t\t\t   !(l_is_temp || init_flag) && dealloc,\n \t\t\t\t   expr1->symtree->n.sym->attr.codimension);\n+\n   /* Add the pre blocks to the body.  */\n   gfc_add_block_to_block (&body, &rse.pre);\n   gfc_add_block_to_block (&body, &lse.pre);"}, {"sha": "795d3cc0a13c2033a3ca2e2a5e5eb971179d568d", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1312bb902382cb4891673284f43ac095e80374cf/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1312bb902382cb4891673284f43ac095e80374cf/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=1312bb902382cb4891673284f43ac095e80374cf", "patch": "@@ -5783,6 +5783,7 @@ gfc_trans_allocate (gfc_code * code)\n   enum { E3_UNSET = 0, E3_SOURCE, E3_MOLD, E3_DESC } e3_is;\n   stmtblock_t block;\n   stmtblock_t post;\n+  stmtblock_t final_block;\n   tree nelems;\n   bool upoly_expr, tmp_expr3_len_flag = false, al_len_needs_set, is_coarray;\n   bool needs_caf_sync, caf_refs_comp;\n@@ -5801,6 +5802,7 @@ gfc_trans_allocate (gfc_code * code)\n \n   gfc_init_block (&block);\n   gfc_init_block (&post);\n+  gfc_init_block (&final_block);\n \n   /* STAT= (and maybe ERRMSG=) is present.  */\n   if (code->expr1)\n@@ -5842,6 +5844,11 @@ gfc_trans_allocate (gfc_code * code)\n \n       is_coarray = gfc_is_coarray (code->expr3);\n \n+      if (code->expr3->expr_type == EXPR_FUNCTION && !code->expr3->mold\n+\t  && (gfc_is_class_array_function (code->expr3)\n+\t      || gfc_is_alloc_class_scalar_function (code->expr3)))\n+\tcode->expr3->must_finalize = 1;\n+\n       /* Figure whether we need the vtab from expr3.  */\n       for (al = code->ext.alloc.list; !vtab_needed && al != NULL;\n \t   al = al->next)\n@@ -5914,7 +5921,10 @@ gfc_trans_allocate (gfc_code * code)\n \t  temp_obj_created = temp_var_needed = !VAR_P (se.expr);\n \t}\n       gfc_add_block_to_block (&block, &se.pre);\n-      gfc_add_block_to_block (&post, &se.post);\n+      if (code->expr3->must_finalize)\n+\tgfc_add_block_to_block (&final_block, &se.post);\n+      else\n+\tgfc_add_block_to_block (&post, &se.post);\n \n       /* Special case when string in expr3 is zero.  */\n       if (code->expr3->ts.type == BT_CHARACTER\n@@ -6743,6 +6753,8 @@ gfc_trans_allocate (gfc_code * code)\n \n   gfc_add_block_to_block (&block, &se.post);\n   gfc_add_block_to_block (&block, &post);\n+  if (code->expr3 && code->expr3->must_finalize)\n+    gfc_add_block_to_block (&block, &final_block);\n \n   return gfc_finish_block (&block);\n }"}, {"sha": "64638c544f125a28a7921f42b00e9ca91dbcc624", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1312bb902382cb4891673284f43ac095e80374cf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1312bb902382cb4891673284f43ac095e80374cf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1312bb902382cb4891673284f43ac095e80374cf", "patch": "@@ -1,3 +1,13 @@\n+2017-08-28  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/80477\n+\t* gfortran.dg/class_result_7.f90: New test.\n+\t* gfortran.dg/class_result_8.f90: New test.\n+\t* gfortran.dg/class_result_9.f90: New test.\n+\n+\tPR fortran/86481\n+\t* gfortran.dg/allocate_with_source_25.f90: New test.\n+\n 2018-08-28  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/87099"}, {"sha": "92dc50756d4946554c0b0b9f964a32e5a3339278", "filename": "gcc/testsuite/gfortran.dg/allocate_with_source_25.f90", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1312bb902382cb4891673284f43ac095e80374cf/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_25.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1312bb902382cb4891673284f43ac095e80374cf/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_25.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_25.f90?ref=1312bb902382cb4891673284f43ac095e80374cf", "patch": "@@ -0,0 +1,71 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+!  Test the fix for PR86481\n+!\n+! Contributed by Rich Townsend  <townsend@astro.wisc.edu>\n+!\n+program simple_leak\n+\n+  implicit none\n+\n+  type, abstract :: foo_t\n+  end type foo_t\n+\n+  type, extends(foo_t) :: foo_a_t\n+     real(8), allocatable :: a(:)\n+  end type foo_a_t\n+\n+  type, extends(foo_t) ::  bar_t\n+     class(foo_t), allocatable :: f\n+  end type bar_t\n+\n+  integer, parameter :: N = 2\n+  integer, parameter :: D = 3\n+\n+  type(bar_t) :: b(N)\n+  integer     :: i\n+\n+  do i = 1, N\n+     b(i) = func_bar(D)\n+  end do\n+\n+  do i = 1, N\n+     deallocate (b(i)%f)\n+  end do\n+\n+contains\n+\n+  function func_bar (D) result (b)\n+\n+    integer, intent(in) :: D\n+    type(bar_t)         :: b\n+\n+    allocate(b%f, SOURCE=func_foo(D))\n+\n+  end function func_bar\n+\n+  !****\n+\n+  function func_foo (D) result (f)\n+\n+    integer, intent(in)       :: D\n+    class(foo_t), allocatable :: f\n+\n+    allocate(f, SOURCE=func_foo_a(D)) ! Lose one of these for each allocation\n+\n+  end function func_foo\n+\n+  !****\n+\n+  function func_foo_a (D) result (f)\n+\n+    integer, intent(in) :: D\n+    type(foo_a_t)       :: f\n+\n+    allocate(f%a(D))  ! Lose one of these for each allocation => N*D*elem_size(f%a)\n+\n+  end function func_foo_a\n+\n+end program simple_leak\n+! { dg-final { scan-tree-dump-times \"\\>_final\" 6 \"original\" } }"}, {"sha": "066da549d6d78d8a2be56477e6fd61164ad523ad", "filename": "gcc/testsuite/gfortran.dg/class_result_7.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1312bb902382cb4891673284f43ac095e80374cf/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_result_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1312bb902382cb4891673284f43ac095e80374cf/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_result_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_result_7.f90?ref=1312bb902382cb4891673284f43ac095e80374cf", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+!  Test the fix for PR80477\n+!\n+! Contributed by Stefano Zaghi  <stefano.zaghi@cnr.it>\n+!\n+module a_type_m\n+   implicit none\n+   type :: a_type_t\n+      real :: x\n+   endtype\n+contains\n+   subroutine assign_a_type(lhs, rhs)\n+      type(a_type_t), intent(inout) :: lhs\n+      type(a_type_t), intent(in)    :: rhs\n+      lhs%x = rhs%x\n+   end subroutine\n+\n+   function add_a_type(lhs, rhs) result( res )\n+      type(a_type_t), intent(in)  :: lhs\n+      type(a_type_t), intent(in)  :: rhs\n+      class(a_type_t), allocatable :: res\n+      allocate (a_type_t :: res)\n+      res%x = lhs%x + rhs%x\n+   end function\n+end module\n+\n+program polymorphic_operators_memory_leaks\n+   use a_type_m\n+   implicit none\n+   type(a_type_t) :: a = a_type_t(1) , b = a_type_t(2)\n+   call assign_a_type (a, add_a_type(a,b))              ! generated a memory leak\n+end\n+! { dg-final { scan-tree-dump-times \"builtin_free\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"builtin_malloc\" 1 \"original\" } }"}, {"sha": "573dd44daad6321a9a16c40a51ac75ae0532de9e", "filename": "gcc/testsuite/gfortran.dg/class_result_8.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1312bb902382cb4891673284f43ac095e80374cf/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_result_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1312bb902382cb4891673284f43ac095e80374cf/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_result_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_result_8.f90?ref=1312bb902382cb4891673284f43ac095e80374cf", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+!  Test the fix for the array version of PR80477\n+!\n+! Contributed by Stefano Zaghi  <stefano.zaghi@cnr.it>\n+!\n+module a_type_m\n+   implicit none\n+   type :: a_type_t\n+      real :: x\n+      real, allocatable :: y(:)\n+   endtype\n+contains\n+   subroutine assign_a_type(lhs, rhs)\n+      type(a_type_t), intent(inout) :: lhs\n+      type(a_type_t), intent(in)    :: rhs(:)\n+      lhs%x = rhs(1)%x + rhs(2)%x\n+   end subroutine\n+\n+   function add_a_type(lhs, rhs) result( res )\n+      type(a_type_t), intent(in)  :: lhs\n+      type(a_type_t), intent(in)  :: rhs\n+      class(a_type_t), allocatable :: res(:)\n+      allocate (a_type_t :: res(2))\n+      allocate (res(1)%y(1))\n+      allocate (res(2)%y(1))\n+      res(1)%x = lhs%x\n+      res(2)%x = rhs%x\n+   end function\n+end module\n+\n+program polymorphic_operators_memory_leaks\n+   use a_type_m\n+   implicit none\n+   type(a_type_t) :: a = a_type_t(1) , b = a_type_t(2)\n+   call assign_a_type (a, add_a_type(a,b))\n+   print *, a%x\n+end\n+! { dg-final { scan-tree-dump-times \"builtin_free\" 6 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"builtin_malloc\" 7 \"original\" } }"}, {"sha": "10bc139aabf2e6fdc52e73a5386647d6d5462b58", "filename": "gcc/testsuite/gfortran.dg/class_result_9.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1312bb902382cb4891673284f43ac095e80374cf/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_result_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1312bb902382cb4891673284f43ac095e80374cf/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_result_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_result_9.f90?ref=1312bb902382cb4891673284f43ac095e80374cf", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+!\n+!  Test the fix for an additional bug found while fixing PR80477\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module a_type_m\n+   implicit none\n+   type :: a_type_t\n+      real :: x\n+      real, allocatable :: y(:)\n+   endtype\n+contains\n+   subroutine assign_a_type(lhs, rhs)\n+      type(a_type_t), intent(inout) :: lhs\n+      type(a_type_t), intent(in)    :: rhs(:)\n+      lhs%x = rhs(1)%x + rhs(2)%x\n+      lhs%y = rhs(1)%y + rhs(2)%y\n+   end subroutine\n+\n+   function add_a_type(lhs, rhs) result( res )\n+      type(a_type_t), intent(in)  :: lhs\n+      type(a_type_t), intent(in)  :: rhs\n+      class(a_type_t), allocatable :: res(:)\n+      allocate (a_type_t :: res(2))\n+      allocate (res(1)%y(1), source = [10.0])\n+      allocate (res(2)%y(1), source = [20.0])\n+      res(1)%x = lhs%x + rhs%x\n+      res(2)%x = rhs%x + rhs%x\n+   end function\n+end module\n+\n+program polymorphic_operators_memory_leaks\n+    use a_type_m\n+    implicit none\n+    type(a_type_t) :: a = a_type_t(1) , b = a_type_t(2)\n+    class(a_type_t), allocatable :: res(:)\n+\n+    res = add_a_type(a,b)        ! Remarkably, this ICEd - found while debugging the PR.\n+    call assign_a_type (a, res)\n+    if (int (res(1)%x + res(2)%x) .ne. int (a%x)) stop 1\n+    if (int (sum (res(1)%y + res(2)%y)) .ne. int (sum (a%y))) stop 1\n+    deallocate (a%y)\n+    deallocate (res)\n+end"}]}