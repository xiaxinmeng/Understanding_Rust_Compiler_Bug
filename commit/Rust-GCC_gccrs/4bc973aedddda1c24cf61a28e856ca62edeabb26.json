{"sha": "4bc973aedddda1c24cf61a28e856ca62edeabb26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJjOTczYWVkZGRkYTFjMjRjZjYxYTI4ZTg1NmNhNjJlZGVhYmIyNg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-06-29T00:42:41Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-06-29T00:42:41Z"}, "message": "expr.c (emit_block_move): Properly handle case where one of the block move arguments has a queued...\n\n\ufffd\n        * expr.c (emit_block_move): Properly handle case where one of the\n        block move arguments has a queued increment or decrement.\n        (clear_storage): Similarly.  Fix formatting goof.\n\nFrom-SVN: r27822", "tree": {"sha": "d09f5cb6dae23d23c6ce3172ed2a7dff355656f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d09f5cb6dae23d23c6ce3172ed2a7dff355656f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bc973aedddda1c24cf61a28e856ca62edeabb26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bc973aedddda1c24cf61a28e856ca62edeabb26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bc973aedddda1c24cf61a28e856ca62edeabb26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bc973aedddda1c24cf61a28e856ca62edeabb26/comments", "author": null, "committer": null, "parents": [{"sha": "5dd2921918e6d0190b75f0ee8df2fd5499463315", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dd2921918e6d0190b75f0ee8df2fd5499463315", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dd2921918e6d0190b75f0ee8df2fd5499463315"}], "stats": {"total": 172, "additions": 114, "deletions": 58}, "files": [{"sha": "075ddd3728bd14bdbe5a6db4fc2b1ba002a569e5", "filename": "gcc/expr.c", "status": "modified", "additions": 114, "deletions": 58, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc973aedddda1c24cf61a28e856ca62edeabb26/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc973aedddda1c24cf61a28e856ca62edeabb26/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4bc973aedddda1c24cf61a28e856ca62edeabb26", "patch": "@@ -1710,6 +1710,37 @@ emit_block_move (x, y, size, align)\n \t    }\n \t}\n \n+      /* X, Y, or SIZE may have been passed through protect_from_queue.\n+\n+\t It is unsafe to save the value generated by protect_from_queue\n+\t and reuse it later.  Consider what happens if emit_queue is\n+\t called before the return value from protect_from_queue is used.\n+\n+\t Expansion of the CALL_EXPR below will call emit_queue before\n+\t we are finished emitting RTL for argument setup.  So if we are\n+\t not careful we could get the wrong value for an argument.\n+\n+\t To avoid this problem we go ahead and emit code to copy X, Y &\n+\t SIZE into new pseudos.  We can then place those new pseudos\n+\t into an RTL_EXPR and use them later, even after a call to\n+\t emit_queue. \n+\n+\t Note this is not strictly needed for library calls since they\n+\t do not call emit_queue before loading their arguments.  However,\n+\t we may need to have library calls call emit_queue in the future\n+\t since failing to do so could cause problems for targets which\n+\t define SMALL_REGISTER_CLASSES and pass arguments in registers.  */\n+      x = copy_to_mode_reg (Pmode, XEXP (x, 0));\n+      y = copy_to_mode_reg (Pmode, XEXP (y, 0));\n+\n+#ifdef TARGET_MEM_FUNCTIONS\n+      size = copy_to_mode_reg (TYPE_MODE (sizetype), size);\n+#else\n+      size = convert_to_mode (TYPE_MODE (integer_type_node), size,\n+\t\t\t      TREE_UNSIGNED (integer_type_node));\n+      size = copy_to_reg (size);\n+#endif\n+\n #ifdef TARGET_MEM_FUNCTIONS\n       /* It is incorrect to use the libcall calling conventions to call\n \t memcpy in this context.\n@@ -1748,12 +1779,10 @@ emit_block_move (x, y, size, align)\n \t the last is a size_t byte count for the copy.  */\n       arg_list\n \t= build_tree_list (NULL_TREE,\n-\t\t\t    make_tree (build_pointer_type (void_type_node),\n-\t\t\t\t       XEXP (x, 0)));\n+\t\t\t   make_tree (build_pointer_type (void_type_node), x));\n       TREE_CHAIN (arg_list)\n \t= build_tree_list (NULL_TREE,\n-\t\t\t   make_tree (build_pointer_type (void_type_node),\n-\t\t\t\t      XEXP (y, 0)));\n+\t\t\t   make_tree (build_pointer_type (void_type_node), y));\n       TREE_CHAIN (TREE_CHAIN (arg_list))\n \t = build_tree_list (NULL_TREE, make_tree (sizetype, size));\n       TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arg_list))) = NULL_TREE;\n@@ -1767,8 +1796,7 @@ emit_block_move (x, y, size, align)\n       retval = expand_expr (call_expr, NULL_RTX, VOIDmode, 0);\n #else\n       emit_library_call (bcopy_libfunc, 0,\n-\t\t\t VOIDmode, 3, XEXP (y, 0), Pmode,\n-\t\t\t XEXP (x, 0), Pmode,\n+\t\t\t VOIDmode, 3, y, Pmode, x, Pmode\n \t\t\t convert_to_mode (TYPE_MODE (integer_type_node), size,\n \t\t\t\t\t  TREE_UNSIGNED (integer_type_node)),\n \t\t\t TYPE_MODE (integer_type_node));\n@@ -2444,69 +2472,97 @@ clear_storage (object, size, align)\n \t\t}\n \t    }\n \n+\t  /* OBJECT or SIZE may have been passed through protect_from_queue.\n \n-#ifdef TARGET_MEM_FUNCTIONS\n-      /* It is incorrect to use the libcall calling conventions to call\n-\t memset in this context.\n+\t     It is unsafe to save the value generated by protect_from_queue\n+\t     and reuse it later.  Consider what happens if emit_queue is\n+\t     called before the return value from protect_from_queue is used.\n \n-\t This could be a user call to memset and the user may wish to\n-\t examine the return value from memset.\n+\t     Expansion of the CALL_EXPR below will call emit_queue before\n+\t     we are finished emitting RTL for argument setup.  So if we are\n+\t     not careful we could get the wrong value for an argument.\n \n-\t For targets where libcalls and normal calls have different conventions\n-\t for returning pointers, we could end up generating incorrect code. \n+\t     To avoid this problem we go ahead and emit code to copy OBJECT\n+\t     and SIZE into new pseudos.  We can then place those new pseudos\n+\t     into an RTL_EXPR and use them later, even after a call to\n+\t     emit_queue.\n \n-\t So instead of using a libcall sequence we build up a suitable\n-\t CALL_EXPR and expand the call in the normal fashion.  */\n-      if (fn == NULL_TREE)\n-\t{\n-\t  tree fntype;\n+\t     Note this is not strictly needed for library calls since they\n+\t     do not call emit_queue before loading their arguments.  However,\n+\t     we may need to have library calls call emit_queue in the future\n+\t     since failing to do so could cause problems for targets which\n+\t     define SMALL_REGISTER_CLASSES and pass arguments in registers.  */\n+\t  object = copy_to_mode_reg (Pmode, XEXP (object, 0));\n \n-\t  /* This was copied from except.c, I don't know if all this is\n-\t     necessary in this context or not.  */\n-\t  fn = get_identifier (\"memset\");\n-\t  push_obstacks_nochange ();\n-\t  end_temporary_allocation ();\n-\t  fntype = build_pointer_type (void_type_node);\n-\t  fntype = build_function_type (fntype, NULL_TREE);\n-\t  fn = build_decl (FUNCTION_DECL, fn, fntype);\n-\t  DECL_EXTERNAL (fn) = 1;\n-\t  TREE_PUBLIC (fn) = 1;\n-\t  DECL_ARTIFICIAL (fn) = 1;\n-\t  make_decl_rtl (fn, NULL_PTR, 1);\n-\t  assemble_external (fn);\n-\t  pop_obstacks ();\n-\t}\n+#ifdef TARGET_MEM_FUNCTIONS\n+\t  size = copy_to_mode_reg (TYPE_MODE (sizetype), size);\n+#else\n+\t  size = convert_to_mode (TYPE_MODE (integer_type_node), size,\n+\t\t\t\t  TREE_UNSIGNED (integer_type_node));\n+\t  size = copy_to_reg (size);\n+#endif\n \n-      /* We need to make an argument list for the function call. \n \n-\t memset has three arguments, the first is a void * addresses, the\n-\t second a integer with the initialization value, the last is a size_t\n-\t byte count for the copy.  */\n-      arg_list\n-\t= build_tree_list (NULL_TREE,\n-\t\t\t    make_tree (build_pointer_type (void_type_node),\n-\t\t\t\t       XEXP (object, 0)));\n-      TREE_CHAIN (arg_list)\n-\t= build_tree_list (NULL_TREE,\n-\t\t\t   make_tree (integer_type_node, const0_rtx));\n-      TREE_CHAIN (TREE_CHAIN (arg_list))\n-\t = build_tree_list (NULL_TREE, make_tree (sizetype, size));\n-      TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arg_list))) = NULL_TREE;\n+#ifdef TARGET_MEM_FUNCTIONS\n+\t  /* It is incorrect to use the libcall calling conventions to call\n+\t     memset in this context.\n \n-      /* Now we have to build up the CALL_EXPR itself.  */\n-      call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n-      call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t\t\t call_expr, arg_list, NULL_TREE);\n-      TREE_SIDE_EFFECTS (call_expr) = 1;\n+\t     This could be a user call to memset and the user may wish to\n+\t     examine the return value from memset.\n \n-      retval = expand_expr (call_expr, NULL_RTX, VOIDmode, 0);\n+\t     For targets where libcalls and normal calls have different\n+\t     conventions for returning pointers, we could end up generating\n+\t      incorrect code. \n+\n+\t     So instead of using a libcall sequence we build up a suitable\n+\t     CALL_EXPR and expand the call in the normal fashion.  */\n+\t  if (fn == NULL_TREE)\n+\t    {\n+\t      tree fntype;\n+\n+\t      /* This was copied from except.c, I don't know if all this is\n+\t\t necessary in this context or not.  */\n+\t      fn = get_identifier (\"memset\");\n+\t      push_obstacks_nochange ();\n+\t      end_temporary_allocation ();\n+\t      fntype = build_pointer_type (void_type_node);\n+\t      fntype = build_function_type (fntype, NULL_TREE);\n+\t      fn = build_decl (FUNCTION_DECL, fn, fntype);\n+\t      DECL_EXTERNAL (fn) = 1;\n+\t      TREE_PUBLIC (fn) = 1;\n+\t      DECL_ARTIFICIAL (fn) = 1;\n+\t      make_decl_rtl (fn, NULL_PTR, 1);\n+\t      assemble_external (fn);\n+\t      pop_obstacks ();\n+\t    }\n+\n+\t  /* We need to make an argument list for the function call. \n+\n+\t     memset has three arguments, the first is a void * addresses, the\n+\t     second a integer with the initialization value, the last is a\n+\t     size_t byte count for the copy.  */\n+\t  arg_list\n+\t    = build_tree_list (NULL_TREE,\n+\t\t\t       make_tree (build_pointer_type (void_type_node),\n+\t\t\t\t\t  object));\n+\t  TREE_CHAIN (arg_list)\n+\t    = build_tree_list (NULL_TREE,\n+\t\t\t        make_tree (integer_type_node, const0_rtx));\n+\t  TREE_CHAIN (TREE_CHAIN (arg_list))\n+\t    = build_tree_list (NULL_TREE, make_tree (sizetype, size));\n+\t  TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arg_list))) = NULL_TREE;\n+\n+\t  /* Now we have to build up the CALL_EXPR itself.  */\n+\t  call_expr = build1 (ADDR_EXPR,\n+\t\t\t      build_pointer_type (TREE_TYPE (fn)), fn);\n+\t  call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+\t\t\t     call_expr, arg_list, NULL_TREE);\n+\t  TREE_SIDE_EFFECTS (call_expr) = 1;\n+\n+\t  retval = expand_expr (call_expr, NULL_RTX, VOIDmode, 0);\n #else\n \t  emit_library_call (bzero_libfunc, 0,\n-\t\t\t     VOIDmode, 2,\n-\t\t\t     XEXP (object, 0), Pmode,\t\n-\t\t\t     convert_to_mode\n-\t\t\t     (TYPE_MODE (integer_type_node), size,\n-\t\t\t      TREE_UNSIGNED (integer_type_node)),\n+\t\t\t     VOIDmode, 2, object, Pmode, size\n \t\t\t     TYPE_MODE (integer_type_node));\n #endif\n \t}"}]}