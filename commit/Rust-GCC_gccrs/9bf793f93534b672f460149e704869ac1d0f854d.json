{"sha": "9bf793f93534b672f460149e704869ac1d0f854d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJmNzkzZjkzNTM0YjY3MmY0NjAxNDllNzA0ODY5YWMxZDBmODU0ZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-03-01T19:18:01Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-03-01T19:18:01Z"}, "message": "fold-const.c (fold): An equality comparison of a non-weak object against zero has a known result.\n\n\n\t* fold-const.c (fold): An equality comparison of a non-weak object\n\tagainst zero has a known result.  Similarly an equality comparison\n\tof the address of two non-weak, unaliased symbols has a known result.\n\n\t* ggc-page.c (struct page_entry): New field PREV.\n\t(ggc_alloc): Update PREV field appropriately.\n\t(sweep_pages): Likewise.\n\t(ggc_free): Likewise.  Use PREV field rather than loop to\n\timprove ggc_free performance.\n\ncp/\n\t* init.c (build_vec_delete_1): Convert 2nd argument to NE_EXPR to\n\tthe proper type.\n\nFrom-SVN: r78713", "tree": {"sha": "be50a4b46ffe2e6609446e59e988c1df925aa7d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be50a4b46ffe2e6609446e59e988c1df925aa7d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bf793f93534b672f460149e704869ac1d0f854d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bf793f93534b672f460149e704869ac1d0f854d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bf793f93534b672f460149e704869ac1d0f854d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bf793f93534b672f460149e704869ac1d0f854d/comments", "author": null, "committer": null, "parents": [{"sha": "c9e0ce371610049698e7af2a065ddea2ede63709", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9e0ce371610049698e7af2a065ddea2ede63709", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9e0ce371610049698e7af2a065ddea2ede63709"}], "stats": {"total": 129, "additions": 121, "deletions": 8}, "files": [{"sha": "e03c4b0458b2755e862540e451d2d0f6ce59a823", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf793f93534b672f460149e704869ac1d0f854d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf793f93534b672f460149e704869ac1d0f854d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9bf793f93534b672f460149e704869ac1d0f854d", "patch": "@@ -1,3 +1,15 @@\n+2004-03-01  Jeff Law  <law@redhat.com>\n+\n+\t* fold-const.c (fold): An equality comparison of a non-weak object\n+\tagainst zero has a known result.  Similarly an equality comparison\n+\tof the address of two non-weak, unaliased symbols has a known result.\n+ \n+\t* ggc-page.c (struct page_entry): New field PREV.\n+\t(ggc_alloc): Update PREV field appropriately.\n+\t(sweep_pages): Likewise.\n+\t(ggc_free): Likewise.  Use PREV field rather than loop to\n+\timprove ggc_free performance.\n+ \n 2004-03-01  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.c (mips_output_division): Use the division"}, {"sha": "b9ef5933976b6c8a14e2b9f41485843e60186cf3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf793f93534b672f460149e704869ac1d0f854d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf793f93534b672f460149e704869ac1d0f854d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9bf793f93534b672f460149e704869ac1d0f854d", "patch": "@@ -1,3 +1,8 @@\n+2004-03-01  Jeff Law  <law@redhat.com>\n+\n+\t* init.c (build_vec_delete_1): Convert 2nd argument to NE_EXPR to\n+\tthe proper type.\n+\n 2004-02-29  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/14138"}, {"sha": "4a31bd5f017ad337225b9aa39bcb02f969f3b113", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf793f93534b672f460149e704869ac1d0f854d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf793f93534b672f460149e704869ac1d0f854d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=9bf793f93534b672f460149e704869ac1d0f854d", "patch": "@@ -2436,7 +2436,8 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n   /* Outermost wrapper: If pointer is null, punt.  */\n   body = fold (build (COND_EXPR, void_type_node,\n \t\t      fold (build (NE_EXPR, boolean_type_node, base,\n-\t\t\t\t   integer_zero_node)),\n+\t\t\t\t   convert (TREE_TYPE (base),\n+\t\t\t\t\t    integer_zero_node))),\n \t\t      body, integer_zero_node));\n   body = build1 (NOP_EXPR, void_type_node, body);\n "}, {"sha": "cffa2ec94144ad421d05f8e40fc3a6f3a9374fd5", "filename": "gcc/fold-const.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf793f93534b672f460149e704869ac1d0f854d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf793f93534b672f460149e704869ac1d0f854d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=9bf793f93534b672f460149e704869ac1d0f854d", "patch": "@@ -7183,6 +7183,45 @@ fold (tree expr)\n       if (tree_swap_operands_p (arg0, arg1, true))\n \treturn fold (build (swap_tree_comparison (code), type, arg1, arg0));\n \n+      /* If this is an equality comparison of the address of a non-weak\n+\t object against zero, then we know the result.  */\n+      if ((code == EQ_EXPR || code == NE_EXPR)\n+\t  && TREE_CODE (arg0) == ADDR_EXPR\n+\t  && DECL_P (TREE_OPERAND (arg0, 0))\n+\t  && ! DECL_WEAK (TREE_OPERAND (arg0, 0))\n+\t  && integer_zerop (arg1))\n+\t{\n+\t  if (code == EQ_EXPR)\n+\t    return integer_zero_node;\n+\t  else\n+\t    return integer_one_node;\n+\t}\n+\n+      /* If this is an equality comparison of the address of two non-weak,\n+\t unaliased symbols neither of which are extern (since we do not\n+\t have access to attributes for externs), then we know the result.  */\n+      if ((code == EQ_EXPR || code == NE_EXPR)\n+\t  && TREE_CODE (arg0) == ADDR_EXPR\n+\t  && DECL_P (TREE_OPERAND (arg0, 0))\n+\t  && ! DECL_WEAK (TREE_OPERAND (arg0, 0))\n+\t  && ! lookup_attribute (\"alias\",\n+\t\t\t\t DECL_ATTRIBUTES (TREE_OPERAND (arg0, 0)))\n+\t  && ! DECL_EXTERNAL (TREE_OPERAND (arg0, 0))\n+\t  && TREE_CODE (arg1) == ADDR_EXPR\n+\t  && DECL_P (TREE_OPERAND (arg1, 0))\n+\t  && ! DECL_WEAK (TREE_OPERAND (arg1, 0))\n+\t  && ! lookup_attribute (\"alias\",\n+\t\t\t\t DECL_ATTRIBUTES (TREE_OPERAND (arg1, 0)))\n+\t  && ! DECL_EXTERNAL (TREE_OPERAND (arg1, 0)))\n+\t{\n+\t  if (code == EQ_EXPR)\n+\t    return (operand_equal_p (arg0, arg1, 0)\n+\t\t    ? integer_one_node : integer_zero_node);\n+\t  else\n+\t    return (operand_equal_p (arg0, arg1, 0)\n+\t\t    ? integer_zero_node : integer_one_node);\n+\t}\n+\n       if (FLOAT_TYPE_P (TREE_TYPE (arg0)))\n \t{\n \t  tree targ0 = strip_float_extensions (arg0);"}, {"sha": "c499dd79e9dd6de384c305257359ffb442cb2c14", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 63, "deletions": 7, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf793f93534b672f460149e704869ac1d0f854d/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf793f93534b672f460149e704869ac1d0f854d/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=9bf793f93534b672f460149e704869ac1d0f854d", "patch": "@@ -247,6 +247,11 @@ typedef struct page_entry\n      this is the last page-entry.  */\n   struct page_entry *next;\n \n+  /* The previous page-entry with objects of the same size, or NULL if\n+     this is the first page-entry.   The PREV pointer exists solely to\n+     keep the cost of ggc_free managable.  */\n+  struct page_entry *prev;\n+\n   /* The number of bytes allocated.  (This will always be a multiple\n      of the host system page size.)  */\n   size_t bytes;\n@@ -1092,12 +1097,18 @@ ggc_alloc (size_t size)\n       while (new_entry->context_depth >= G.depth_in_use)\n \tpush_depth (G.by_depth_in_use-1);\n \n-      /* If this is the only entry, it's also the tail.  */\n+      /* If this is the only entry, it's also the tail.  If it is not\n+\t the only entry, then we must update the PREV pointer of the\n+\t ENTRY (G.pages[order]) to point to our new page entry.  */\n       if (entry == NULL)\n \tG.page_tails[order] = new_entry;\n+      else\n+\tentry->prev = new_entry;\n \n-      /* Put new pages at the head of the page list.  */\n+      /* Put new pages at the head of the page list.  By definition the\n+\t entry at the head of the list always has a NULL pointer.  */\n       new_entry->next = entry;\n+      new_entry->prev = NULL;\n       entry = new_entry;\n       G.pages[order] = new_entry;\n \n@@ -1146,8 +1157,17 @@ ggc_alloc (size_t size)\n       && entry->next != NULL\n       && entry->next->num_free_objects > 0)\n     {\n+      /* We have a new head for the list.  */\n       G.pages[order] = entry->next;\n+\n+      /* We are moving ENTRY to the end of the page table list.\n+\t The new page at the head of the list will have NULL in\n+\t its PREV field and ENTRY will have NULL in its NEXT field.  */\n+      entry->next->prev = NULL;\n       entry->next = NULL;\n+\n+      /* Append ENTRY to the tail of the list.  */\n+      entry->prev = G.page_tails[order];\n       G.page_tails[order]->next = entry;\n       G.page_tails[order] = entry;\n     }\n@@ -1339,22 +1359,34 @@ ggc_free (void *p)\n \n     if (pe->num_free_objects++ == 0)\n       {\n+\tpage_entry *p, *q;\n+\n \t/* If the page is completely full, then it's supposed to\n \t   be after all pages that aren't.  Since we've freed one\n \t   object from a page that was full, we need to move the\n-\t   page to the head of the list.  */\n+\t   page to the head of the list. \n \n-\tpage_entry *p, *q;\n-\tfor (q = NULL, p = G.pages[order]; ; q = p, p = p->next)\n-\t  if (p == pe)\n-\t    break;\n+\t   PE is the node we want to move.  Q is the previous node\n+\t   and P is the next node in the list.  */\n+\tq = pe->prev;\n \tif (q && q->num_free_objects == 0)\n \t  {\n \t    p = pe->next;\n+\n \t    q->next = p;\n+\n+\t    /* If PE was at the end of the list, then Q becomes the\n+\t       new end of the list.  If PE was not the end of the\n+\t       list, then we need to update the PREV field for P.  */\n \t    if (!p)\n \t      G.page_tails[order] = q;\n+\t    else\n+\t      p->prev = q;\n+\n+\t    /* Move PE to the head of the list.  */\n \t    pe->next = G.pages[order];\n+\t    pe->prev = NULL;\n+\t    G.pages[order]->prev = pe;\n \t    G.pages[order] = pe;\n \t  }\n \n@@ -1741,10 +1773,17 @@ sweep_pages (void)\n \t  /* Remove the page if it's empty.  */\n \t  else if (live_objects == 0)\n \t    {\n+\t      /* If P was the first page in the list, then NEXT\n+\t\t becomes the new first page in the list, otherwise\n+\t\t splice P out of the forward pointers.  */\n \t      if (! previous)\n \t\tG.pages[order] = next;\n \t      else\n \t\tprevious->next = next;\n+\t    \n+\t      /* Splice P out of the back pointers too.  */\n+\t      if (next)\n+\t\tnext->prev = previous;\n \n \t      /* Are we removing the last element?  */\n \t      if (p == G.page_tails[order])\n@@ -1761,6 +1800,7 @@ sweep_pages (void)\n \t\t{\n \t\t  /* Move p to the end of the list.  */\n \t\t  p->next = NULL;\n+\t\t  p->prev = G.page_tails[order];\n \t\t  G.page_tails[order]->next = p;\n \n \t\t  /* Update the tail pointer...  */\n@@ -1771,6 +1811,11 @@ sweep_pages (void)\n \t\t    G.pages[order] = next;\n \t\t  else\n \t\t    previous->next = next;\n+\n+\t\t  /* And update the backpointer in NEXT if necessary.  */\n+\t\t  if (next)\n+\t\t    next->prev = previous;\n+\n \t\t  p = previous;\n \t\t}\n \t    }\n@@ -1782,8 +1827,19 @@ sweep_pages (void)\n \t  else if (p != G.pages[order])\n \t    {\n \t      previous->next = p->next;\n+\n+\t      /* Update the backchain in the next node if it exists.  */\n+\t      if (p->next)\n+\t\tp->next->prev = previous;\n+\n+\t      /* Move P to the head of the list.  */\n \t      p->next = G.pages[order];\n+\t      p->prev = NULL;\n+\t      G.pages[order]->prev = p;\n+\n+\t      /* Update the head pointer.  */\n \t      G.pages[order] = p;\n+\n \t      /* Are we moving the last element?  */\n \t      if (G.page_tails[order] == p)\n \t        G.page_tails[order] = previous;"}]}