{"sha": "6ee874f1353933b1427b5e2953358eb3424090d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVlODc0ZjEzNTM5MzNiMTQyN2I1ZTI5NTMzNThlYjM0MjQwOTBkNQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-07-14T16:45:42Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-07-30T10:03:58Z"}, "message": "d: Refactor matching and lowering of intrinsic functions.\n\nIntrinsics are now matched explicitly, rather than through a common\nalias where there are multiple overrides for a common intrinsic.\nWhere there is a corresponding DECL_FUNCTION_CODE, that is now stored in\nthe D intrinsic array.  All run-time std.math intrinsics have been\nremoved, as the library implementation already forwards to core.math.\n\ngcc/d/ChangeLog:\n\n\t* d-tree.h (DEF_D_INTRINSIC): Rename second argument from A to B.\n\t* intrinsics.cc (intrinsic_decl): Add built_in field.\n\t(DEF_D_INTRINSIC): Rename second argument from ALIAS to BUILTIN.\n\t(maybe_set_intrinsic): Handle new intrinsic codes.\n\t(expand_intrinsic_bt): Likewise.\n\t(expand_intrinsic_checkedint): Likewise.\n\t(expand_intrinsic_bswap): Remove.\n\t(expand_intrinsic_sqrt): Remove.\n\t(maybe_expand_intrinsic): Group together intrinsic cases that map\n\tdirectly to gcc built-ins.\n\t* intrinsics.def (DEF_D_BUILTIN): Rename second argument from A to B.\n\tUpdate all callers to pass equivalent DECL_FUNCTION_CODE.\n\t(DEF_CTFE_BUILTIN): Likewise.\n\t(STD_COS): Remove intrinsic.\n\t(STD_FABS): Remove intrinsic.\n\t(STD_LDEXP): Remove intrinsic.\n\t(STD_RINT): Remove intrinsic.\n\t(STD_RNDTOL): Remove intrinsic.\n\t(STD_SIN): Remove intrinsic.\n\t(STD_SQRTF): Remove intrinsic.\n\t(STD_SQRT): Remove intrinsic.\n\t(STD_SQRTL): Remove intrinsic.\n\ngcc/testsuite/ChangeLog:\n\n\t* gdc.dg/intrinsics.d: New test.", "tree": {"sha": "d84425d9f58597e1450b5fe7ad27c5090577da23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d84425d9f58597e1450b5fe7ad27c5090577da23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ee874f1353933b1427b5e2953358eb3424090d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ee874f1353933b1427b5e2953358eb3424090d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ee874f1353933b1427b5e2953358eb3424090d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ee874f1353933b1427b5e2953358eb3424090d5/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c558d2655cb22f472c83e8296b5cd2a92365cd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c558d2655cb22f472c83e8296b5cd2a92365cd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c558d2655cb22f472c83e8296b5cd2a92365cd3"}], "stats": {"total": 631, "additions": 358, "deletions": 273}, "files": [{"sha": "d92418a55c9cea3558046585302c154d6c41df1a", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee874f1353933b1427b5e2953358eb3424090d5/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee874f1353933b1427b5e2953358eb3424090d5/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=6ee874f1353933b1427b5e2953358eb3424090d5", "patch": "@@ -80,7 +80,7 @@ enum level_kind\n \n enum intrinsic_code\n {\n-#define DEF_D_INTRINSIC(CODE, A, N, M, D, C) INTRINSIC_ ## CODE,\n+#define DEF_D_INTRINSIC(CODE, B, N, M, D, C) INTRINSIC_ ## CODE,\n \n #include \"intrinsics.def\"\n "}, {"sha": "7ef1ec5ea209efc47dcac47a6dc7ec393d151f8c", "filename": "gcc/d/intrinsics.cc", "status": "modified", "additions": 159, "deletions": 183, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee874f1353933b1427b5e2953358eb3424090d5/gcc%2Fd%2Fintrinsics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee874f1353933b1427b5e2953358eb3424090d5/gcc%2Fd%2Fintrinsics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fintrinsics.cc?ref=6ee874f1353933b1427b5e2953358eb3424090d5", "patch": "@@ -40,9 +40,12 @@ along with GCC; see the file COPYING3.  If not see\n \n struct intrinsic_decl\n {\n-  /* The DECL_FUNCTION_CODE of this decl.  */\n+  /* The DECL_INTRINSIC_CODE of this decl.  */\n   intrinsic_code code;\n \n+  /* The DECL_FUNCTION_CODE of this decl, if it directly maps to any.  */\n+  built_in_function built_in;\n+\n   /* The name of the intrinsic.  */\n   const char *name;\n \n@@ -58,8 +61,8 @@ struct intrinsic_decl\n \n static const intrinsic_decl intrinsic_decls[] =\n {\n-#define DEF_D_INTRINSIC(CODE, ALIAS, NAME, MODULE, DECO, CTFE) \\\n-    { INTRINSIC_ ## ALIAS, NAME, MODULE, DECO, CTFE },\n+#define DEF_D_INTRINSIC(CODE, BUILTIN, NAME, MODULE, DECO, CTFE) \\\n+    { INTRINSIC_ ## CODE, BUILT_IN_ ## BUILTIN, NAME, MODULE, DECO, CTFE },\n \n #include \"intrinsics.def\"\n \n@@ -144,11 +147,28 @@ maybe_set_intrinsic (FuncDeclaration *decl)\n \t    case INTRINSIC_C_VA_ARG:\n \t    case INTRINSIC_VASTART:\n \t    case INTRINSIC_ADDS:\n+\t    case INTRINSIC_ADDSL:\n+\t    case INTRINSIC_ADDU:\n+\t    case INTRINSIC_ADDUL:\n \t    case INTRINSIC_SUBS:\n+\t    case INTRINSIC_SUBSL:\n+\t    case INTRINSIC_SUBU:\n+\t    case INTRINSIC_SUBUL:\n \t    case INTRINSIC_MULS:\n+\t    case INTRINSIC_MULSL:\n+\t    case INTRINSIC_MULU:\n+\t    case INTRINSIC_MULUI:\n+\t    case INTRINSIC_MULUL:\n \t    case INTRINSIC_NEGS:\n-\t    case INTRINSIC_VLOAD:\n-\t    case INTRINSIC_VSTORE:\n+\t    case INTRINSIC_NEGSL:\n+\t    case INTRINSIC_VLOAD8:\n+\t    case INTRINSIC_VLOAD16:\n+\t    case INTRINSIC_VLOAD32:\n+\t    case INTRINSIC_VLOAD64:\n+\t    case INTRINSIC_VSTORE8:\n+\t    case INTRINSIC_VSTORE16:\n+\t    case INTRINSIC_VSTORE32:\n+\t    case INTRINSIC_VSTORE64:\n \t      break;\n \n \t    case INTRINSIC_POW:\n@@ -302,14 +322,33 @@ expand_intrinsic_bt (intrinsic_code intrinsic, tree callexp)\n \t\t\t integer_minus_one_node, integer_zero_node);\n \n   /* Update the bit as needed, only testing the bit for bt().  */\n-  if (intrinsic == INTRINSIC_BT)\n-    return cond;\n+  tree_code code;\n+\n+  switch (intrinsic)\n+    {\n+    case INTRINSIC_BT:\n+    case INTRINSIC_BT64:\n+      return cond;\n+\n+    case INTRINSIC_BTC:\n+    case INTRINSIC_BTC64:\n+      code = BIT_XOR_EXPR;\n+      break;\n+\n+    case INTRINSIC_BTR:\n+    case INTRINSIC_BTR64:\n+      bitnum = fold_build1 (BIT_NOT_EXPR, TREE_TYPE (bitnum), bitnum);\n+      code = BIT_AND_EXPR;\n+      break;\n+\n+    case INTRINSIC_BTS:\n+    case INTRINSIC_BTS64:\n+      code = BIT_IOR_EXPR;\n+      break;\n \n-  tree_code code = (intrinsic == INTRINSIC_BTC) ? BIT_XOR_EXPR\n-    : (intrinsic == INTRINSIC_BTR) ? BIT_AND_EXPR\n-    : (intrinsic == INTRINSIC_BTS) ? BIT_IOR_EXPR\n-    : ERROR_MARK;\n-  gcc_assert (code != ERROR_MARK);\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   /* ptr[bitnum / size] op= mask;  */\n   if (intrinsic == INTRINSIC_BTR)\n@@ -325,31 +364,6 @@ expand_intrinsic_bt (intrinsic_code intrinsic, tree callexp)\n   return compound_expr (cond, compound_expr (ptr, tmp));\n }\n \n-/* Expand a front-end intrinsic call to bswap().  This takes one argument, the\n-   signature to which can be either:\n-\n-\tint bswap (uint arg);\n-\tint bswap (ulong arg);\n-\n-   This swaps all bytes in an N byte type end-to-end.  The original call\n-   expression is held in CALLEXP.  */\n-\n-static tree\n-expand_intrinsic_bswap (tree callexp)\n-{\n-  tree arg = CALL_EXPR_ARG (callexp, 0);\n-  int argsize = TYPE_PRECISION (TREE_TYPE (arg));\n-\n-  /* Which variant of __builtin_bswap* should we call?  */\n-  built_in_function code = (argsize == 32) ? BUILT_IN_BSWAP32\n-    : (argsize == 64) ? BUILT_IN_BSWAP64\n-    : END_BUILTINS;\n-\n-  gcc_assert (code != END_BUILTINS);\n-\n-  return call_builtin_fn (callexp, code, 1, arg);\n-}\n-\n /* Expand a front-end intrinsic call to popcnt().  This takes one argument, the\n    signature to which can be either:\n \n@@ -376,32 +390,6 @@ expand_intrinsic_popcnt (tree callexp)\n   return call_builtin_fn (callexp, code, 1, arg);\n }\n \n-/* Expand a front-end intrinsic call to INTRINSIC, which is either a call to\n-   sqrt(), sqrtf(), sqrtl().  These intrinsics expect to take one argument,\n-   the signature to which can be either:\n-\n-\tfloat sqrt (float arg);\n-\tdouble sqrt (double arg);\n-\treal sqrt (real arg);\n-\n-   This computes the square root of the given argument.  The original call\n-   expression is held in CALLEXP.  */\n-\n-static tree\n-expand_intrinsic_sqrt (intrinsic_code intrinsic, tree callexp)\n-{\n-  tree arg = CALL_EXPR_ARG (callexp, 0);\n-\n-  /* Which variant of __builtin_sqrt* should we call?  */\n-  built_in_function code = (intrinsic == INTRINSIC_SQRT) ? BUILT_IN_SQRT\n-    : (intrinsic == INTRINSIC_SQRTF) ? BUILT_IN_SQRTF\n-    : (intrinsic == INTRINSIC_SQRTL) ? BUILT_IN_SQRTL\n-    : END_BUILTINS;\n-\n-  gcc_assert (code != END_BUILTINS);\n-  return call_builtin_fn (callexp, code, 1, arg);\n-}\n-\n /* Expand a front-end intrinsic call to copysign().  This takes two arguments,\n    the signature to which can be either:\n \n@@ -575,28 +563,54 @@ expand_intrinsic_checkedint (intrinsic_code intrinsic, tree callexp)\n   tree x;\n   tree y;\n   tree overflow;\n+  internal_fn icode;\n \n-  /* The negs() intrinsic gets turned into SUB_OVERFLOW (0, y).  */\n-  if (intrinsic == INTRINSIC_NEGS)\n-    {\n-      x = fold_convert (type, integer_zero_node);\n-      y = CALL_EXPR_ARG (callexp, 0);\n-      overflow = CALL_EXPR_ARG (callexp, 1);\n-    }\n-  else\n+  /* Which variant of *_OVERFLOW should we generate?  */\n+  switch (intrinsic)\n     {\n+    case INTRINSIC_ADDS:\n+    case INTRINSIC_ADDSL:\n+    case INTRINSIC_ADDU:\n+    case INTRINSIC_ADDUL:\n       x = CALL_EXPR_ARG (callexp, 0);\n       y = CALL_EXPR_ARG (callexp, 1);\n       overflow = CALL_EXPR_ARG (callexp, 2);\n-    }\n+      icode = IFN_ADD_OVERFLOW;\n+      break;\n \n-  /* Which variant of *_OVERFLOW should we generate?  */\n-  internal_fn icode = (intrinsic == INTRINSIC_ADDS) ? IFN_ADD_OVERFLOW\n-    : (intrinsic == INTRINSIC_SUBS) ? IFN_SUB_OVERFLOW\n-    : (intrinsic == INTRINSIC_MULS) ? IFN_MUL_OVERFLOW\n-    : (intrinsic == INTRINSIC_NEGS) ? IFN_SUB_OVERFLOW\n-    : IFN_LAST;\n-  gcc_assert (icode != IFN_LAST);\n+    case INTRINSIC_SUBS:\n+    case INTRINSIC_SUBSL:\n+    case INTRINSIC_SUBU:\n+    case INTRINSIC_SUBUL:\n+      x = CALL_EXPR_ARG (callexp, 0);\n+      y = CALL_EXPR_ARG (callexp, 1);\n+      overflow = CALL_EXPR_ARG (callexp, 2);\n+      icode = IFN_SUB_OVERFLOW;\n+      break;\n+\n+    case INTRINSIC_MULS:\n+    case INTRINSIC_MULSL:\n+    case INTRINSIC_MULU:\n+    case INTRINSIC_MULUI:\n+    case INTRINSIC_MULUL:\n+      x = CALL_EXPR_ARG (callexp, 0);\n+      y = CALL_EXPR_ARG (callexp, 1);\n+      overflow = CALL_EXPR_ARG (callexp, 2);\n+      icode = IFN_MUL_OVERFLOW;\n+      break;\n+\n+    case INTRINSIC_NEGS:\n+    case INTRINSIC_NEGSL:\n+      /* The negs() intrinsic gets turned into SUB_OVERFLOW (0, y).  */\n+      x = fold_convert (type, integer_zero_node);\n+      y = CALL_EXPR_ARG (callexp, 0);\n+      overflow = CALL_EXPR_ARG (callexp, 1);\n+      icode = IFN_SUB_OVERFLOW;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   tree result\n     = build_call_expr_internal_loc (EXPR_LOCATION (callexp), icode,\n@@ -702,142 +716,87 @@ maybe_expand_intrinsic (tree callexp)\n       return callexp;\n \n     case INTRINSIC_BSF:\n+    case INTRINSIC_BSF64:\n       return expand_intrinsic_bsf (callexp);\n \n     case INTRINSIC_BSR:\n+    case INTRINSIC_BSR64:\n       return expand_intrinsic_bsr (callexp);\n \n     case INTRINSIC_BT:\n+    case INTRINSIC_BT64:\n     case INTRINSIC_BTC:\n+    case INTRINSIC_BTC64:\n     case INTRINSIC_BTR:\n+    case INTRINSIC_BTR64:\n     case INTRINSIC_BTS:\n+    case INTRINSIC_BTS64:\n       return expand_intrinsic_bt (intrinsic, callexp);\n \n-    case INTRINSIC_BSWAP:\n-      return expand_intrinsic_bswap (callexp);\n-\n-    case INTRINSIC_POPCNT:\n+    case INTRINSIC_POPCNT32:\n+    case INTRINSIC_POPCNT64:\n       return expand_intrinsic_popcnt (callexp);\n \n-    case INTRINSIC_COS:\n-      return call_builtin_fn (callexp, BUILT_IN_COSL, 1,\n-\t\t\t      CALL_EXPR_ARG (callexp, 0));\n-\n-    case INTRINSIC_SIN:\n-      return call_builtin_fn (callexp, BUILT_IN_SINL, 1,\n-\t\t\t      CALL_EXPR_ARG (callexp, 0));\n-\n-    case INTRINSIC_RNDTOL:\n-      /* Not sure if llroundl stands as a good replacement for the\n-\t expected behavior of rndtol.  */\n-      return call_builtin_fn (callexp, BUILT_IN_LLROUNDL, 1,\n-\t\t\t      CALL_EXPR_ARG (callexp, 0));\n-\n-    case INTRINSIC_SQRT:\n-    case INTRINSIC_SQRTF:\n-    case INTRINSIC_SQRTL:\n-      return expand_intrinsic_sqrt (intrinsic, callexp);\n-\n-    case INTRINSIC_LDEXP:\n-      return call_builtin_fn (callexp, BUILT_IN_LDEXPL, 2,\n-\t\t\t      CALL_EXPR_ARG (callexp, 0),\n-\t\t\t      CALL_EXPR_ARG (callexp, 1));\n-\n-    case INTRINSIC_FABS:\n-      return call_builtin_fn (callexp, BUILT_IN_FABSL, 1,\n-\t\t\t      CALL_EXPR_ARG (callexp, 0));\n-\n-    case INTRINSIC_RINT:\n-      return call_builtin_fn (callexp, BUILT_IN_RINTL, 1,\n-\t\t\t      CALL_EXPR_ARG (callexp, 0));\n-\n-    case INTRINSIC_TAN:\n-      return call_builtin_fn (callexp, BUILT_IN_TANL, 1,\n-\t\t\t      CALL_EXPR_ARG (callexp, 0));\n-\n-    case INTRINSIC_ISNAN:\n-      return call_builtin_fn (callexp, BUILT_IN_ISNAN, 1,\n-\t\t\t      CALL_EXPR_ARG (callexp, 0));\n-\n-    case INTRINSIC_ISINFINITY:\n-      return call_builtin_fn (callexp, BUILT_IN_ISINF, 1,\n-\t\t\t      CALL_EXPR_ARG (callexp, 0));\n-\n-    case INTRINSIC_ISFINITE:\n-      return call_builtin_fn (callexp, BUILT_IN_ISFINITE, 1,\n-\t\t\t      CALL_EXPR_ARG (callexp, 0));\n-\n+    case INTRINSIC_BSWAP32:\n+    case INTRINSIC_BSWAP64:\n+    case INTRINSIC_CEIL:\n+    case INTRINSIC_CEILF:\n+    case INTRINSIC_CEILL:\n+    case INTRINSIC_COSL:\n     case INTRINSIC_EXP:\n-      return call_builtin_fn (callexp, BUILT_IN_EXPL, 1,\n-\t\t\t      CALL_EXPR_ARG (callexp, 0));\n-\n-    case INTRINSIC_EXPM1:\n-      return call_builtin_fn (callexp, BUILT_IN_EXPM1L, 1,\n-\t\t\t      CALL_EXPR_ARG (callexp, 0));\n-\n     case INTRINSIC_EXP2:\n-      return call_builtin_fn (callexp, BUILT_IN_EXP2L, 1,\n-\t\t\t      CALL_EXPR_ARG (callexp, 0));\n-\n+    case INTRINSIC_EXPM1:\n+    case INTRINSIC_FABSL:\n+    case INTRINSIC_FLOOR:\n+    case INTRINSIC_FLOORF:\n+    case INTRINSIC_FLOORL:\n+    case INTRINSIC_ISFINITE:\n+    case INTRINSIC_ISINFINITY:\n+    case INTRINSIC_ISNAN:\n     case INTRINSIC_LOG:\n-      return call_builtin_fn (callexp, BUILT_IN_LOGL, 1,\n-\t\t\t      CALL_EXPR_ARG (callexp, 0));\n-\n-    case INTRINSIC_LOG2:\n-      return call_builtin_fn (callexp, BUILT_IN_LOG2L, 1,\n-\t\t\t      CALL_EXPR_ARG (callexp, 0));\n-\n     case INTRINSIC_LOG10:\n-      return call_builtin_fn (callexp, BUILT_IN_LOG10L, 1,\n-\t\t\t      CALL_EXPR_ARG (callexp, 0));\n-\n+    case INTRINSIC_LOG2:\n+    case INTRINSIC_RINTL:\n+    case INTRINSIC_RNDTOLL:\n     case INTRINSIC_ROUND:\n-      return call_builtin_fn (callexp, BUILT_IN_ROUNDL, 1,\n-\t\t\t      CALL_EXPR_ARG (callexp, 0));\n-\n-    case INTRINSIC_FLOORF:\n-    case INTRINSIC_FLOOR:\n-    case INTRINSIC_FLOORL:\n-      code = (intrinsic == INTRINSIC_FLOOR) ? BUILT_IN_FLOOR\n-\t: (intrinsic == INTRINSIC_FLOORF) ? BUILT_IN_FLOORF\n-\t: BUILT_IN_FLOORL;\n-      return call_builtin_fn (callexp, code, 1, CALL_EXPR_ARG (callexp, 0));\n-\n-    case INTRINSIC_CEILF:\n-    case INTRINSIC_CEIL:\n-    case INTRINSIC_CEILL:\n-      code = (intrinsic == INTRINSIC_CEIL) ? BUILT_IN_CEIL\n-\t: (intrinsic == INTRINSIC_CEILF) ? BUILT_IN_CEILF\n-\t: BUILT_IN_CEILL;\n-      return call_builtin_fn (callexp, code, 1, CALL_EXPR_ARG (callexp, 0));\n-\n+    case INTRINSIC_SINL:\n+    case INTRINSIC_SQRT:\n+    case INTRINSIC_SQRTF:\n+    case INTRINSIC_SQRTL:\n+    case INTRINSIC_TAN:\n     case INTRINSIC_TRUNC:\n-      return call_builtin_fn (callexp, BUILT_IN_TRUNCL, 1,\n+      code = intrinsic_decls[intrinsic].built_in;\n+      gcc_assert (code != BUILT_IN_NONE);\n+      return call_builtin_fn (callexp, code, 1,\n \t\t\t      CALL_EXPR_ARG (callexp, 0));\n \n+    case INTRINSIC_FMAX:\n     case INTRINSIC_FMIN:\n-      return call_builtin_fn (callexp, BUILT_IN_FMINL, 2,\n+    case INTRINSIC_LDEXPL:\n+      code = intrinsic_decls[intrinsic].built_in;\n+      gcc_assert (code != BUILT_IN_NONE);\n+      return call_builtin_fn (callexp, code, 2,\n \t\t\t      CALL_EXPR_ARG (callexp, 0),\n \t\t\t      CALL_EXPR_ARG (callexp, 1));\n \n-    case INTRINSIC_FMAX:\n-      return call_builtin_fn (callexp, BUILT_IN_FMAXL, 2,\n+    case INTRINSIC_FMA:\n+      code = intrinsic_decls[intrinsic].built_in;\n+      gcc_assert (code != BUILT_IN_NONE);\n+      return call_builtin_fn (callexp, code, 3,\n \t\t\t      CALL_EXPR_ARG (callexp, 0),\n-\t\t\t      CALL_EXPR_ARG (callexp, 1));\n+\t\t\t      CALL_EXPR_ARG (callexp, 1),\n+\t\t\t      CALL_EXPR_ARG (callexp, 2));\n \n     case INTRINSIC_COPYSIGN:\n+    case INTRINSIC_COPYSIGNI:\n       return expand_intrinsic_copysign (callexp);\n \n     case INTRINSIC_POW:\n       return expand_intrinsic_pow (callexp);\n \n-    case INTRINSIC_FMA:\n-      return call_builtin_fn (callexp, BUILT_IN_FMAL, 3,\n-\t\t\t      CALL_EXPR_ARG (callexp, 0),\n-\t\t\t      CALL_EXPR_ARG (callexp, 1),\n-\t\t\t      CALL_EXPR_ARG (callexp, 2));\n-\n     case INTRINSIC_TOPREC:\n+    case INTRINSIC_TOPRECF:\n+    case INTRINSIC_TOPRECL:\n       return expand_intrinsic_toprec (callexp);\n \n     case INTRINSIC_VA_ARG:\n@@ -848,15 +807,32 @@ maybe_expand_intrinsic (tree callexp)\n       return expand_intrinsic_vastart (callexp);\n \n     case INTRINSIC_ADDS:\n+    case INTRINSIC_ADDSL:\n+    case INTRINSIC_ADDU:\n+    case INTRINSIC_ADDUL:\n     case INTRINSIC_SUBS:\n+    case INTRINSIC_SUBSL:\n+    case INTRINSIC_SUBU:\n+    case INTRINSIC_SUBUL:\n     case INTRINSIC_MULS:\n+    case INTRINSIC_MULSL:\n+    case INTRINSIC_MULU:\n+    case INTRINSIC_MULUI:\n+    case INTRINSIC_MULUL:\n     case INTRINSIC_NEGS:\n+    case INTRINSIC_NEGSL:\n       return expand_intrinsic_checkedint (intrinsic, callexp);\n \n-    case INTRINSIC_VLOAD:\n+    case INTRINSIC_VLOAD8:\n+    case INTRINSIC_VLOAD16:\n+    case INTRINSIC_VLOAD32:\n+    case INTRINSIC_VLOAD64:\n       return expand_volatile_load (callexp);\n \n-    case INTRINSIC_VSTORE:\n+    case INTRINSIC_VSTORE8:\n+    case INTRINSIC_VSTORE16:\n+    case INTRINSIC_VSTORE32:\n+    case INTRINSIC_VSTORE64:\n       return expand_volatile_store (callexp);\n \n     default:"}, {"sha": "0c32126b1fa7265375c6c0f5a4c2ecfb12cd806e", "filename": "gcc/d/intrinsics.def", "status": "modified", "additions": 81, "deletions": 89, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee874f1353933b1427b5e2953358eb3424090d5/gcc%2Fd%2Fintrinsics.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee874f1353933b1427b5e2953358eb3424090d5/gcc%2Fd%2Fintrinsics.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fintrinsics.def?ref=6ee874f1353933b1427b5e2953358eb3424090d5", "patch": "@@ -15,11 +15,10 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* DEF_D_INTRINSIC (CODE, ALIAS, NAME, MODULE, DECO, CTFE)\n+/* DEF_D_INTRINSIC (CODE, BUILTIN, NAME, MODULE, DECO, CTFE)\n    CODE\t    The enum code used to refer to this intrinsic.\n-   ALIAS    The enum code used to reference the function DECL_FUNCTION_CODE,\n-\t    if there are multiple modules or decos for a single intrinsic,\n-\t    they would all refer to this code.\n+   BUILTIN  The enum code used to reference the function DECL_FUNCTION_CODE,\n+\t    if the intrinsic can be mapped 1:1 to a GCC built-in.\n    NAME\t    The name of this intrinsic as a string.\n    MODULE   The name of the module which the intrinsic belongs to as a string.\n    DECO\t    The function signature decoration of the intrinsic.\n@@ -30,127 +29,120 @@ along with GCC; see the file COPYING3.  If not see\n    GCC builtin, or are specially handled by the compiler.  */\n \n /* A D built-in that has no runtime implementation.  */\n-#define DEF_D_BUILTIN(C, A, N, M, D) \\\n-  DEF_D_INTRINSIC (C, A, N, M, D, false)\n+#define DEF_D_BUILTIN(C, B, N, M, D) \\\n+  DEF_D_INTRINSIC (C, B, N, M, D, false)\n \n /* A D built-in that is specially recognized only during CTFE.  */\n-#define DEF_CTFE_BUILTIN(C, A, N, M, D) \\\n-  DEF_D_INTRINSIC (C, A, N, M, D, true)\n+#define DEF_CTFE_BUILTIN(C, B, N, M, D) \\\n+  DEF_D_INTRINSIC (C, B, N, M, D, true)\n \n DEF_D_BUILTIN (NONE, NONE, 0, 0, 0)\n \n /* core.bitop intrinsics.  */\n \n-DEF_D_BUILTIN (BSF, BSF, \"bsf\", \"core.bitop\", \"FNaNbNiNfkZi\")\n-DEF_D_BUILTIN (BSR, BSR, \"bsr\", \"core.bitop\", \"FNaNbNiNfkZi\")\n-DEF_D_BUILTIN (BT, BT, \"bt\", \"core.bitop\", \"FNaNbNixPkkZi\")\n-DEF_D_BUILTIN (BTC, BTC, \"btc\", \"core.bitop\", \"FNaNbNiPkkZi\")\n-DEF_D_BUILTIN (BTR, BTR, \"btr\", \"core.bitop\", \"FNaNbNiPkkZi\")\n-DEF_D_BUILTIN (BTS, BTS, \"bts\", \"core.bitop\", \"FNaNbNiPkkZi\")\n-DEF_D_BUILTIN (BSF64, BSF, \"bsf\", \"core.bitop\", \"FNaNbNiNfmZi\")\n-DEF_D_BUILTIN (BSR64, BSR, \"bsr\", \"core.bitop\", \"FNaNbNiNfmZi\")\n-DEF_D_BUILTIN (BT64, BT, \"bt\", \"core.bitop\", \"FNaNbNixPmmZi\")\n-DEF_D_BUILTIN (BTC64, BTC, \"btc\", \"core.bitop\", \"FNaNbNiPmmZi\")\n-DEF_D_BUILTIN (BTR64, BTR, \"btr\", \"core.bitop\", \"FNaNbNiPmmZi\")\n-DEF_D_BUILTIN (BTS64, BTS, \"bts\", \"core.bitop\", \"FNaNbNiPmmZi\")\n-DEF_D_BUILTIN (BSWAP, BSWAP, \"bswap\", \"core.bitop\", \"FNaNbNiNfkZk\")\n-DEF_D_BUILTIN (BSWAP64, BSWAP, \"bswap\", \"core.bitop\", \"FNaNbNiNfmZm\")\n-DEF_D_BUILTIN (POPCNT, POPCNT, \"popcnt\", \"core.bitop\", \"FNaNbNiNfkZi\")\n-DEF_D_BUILTIN (POPCNT64, POPCNT, \"popcnt\", \"core.bitop\", \"FNaNbNiNfmZi\")\n-DEF_D_BUILTIN (VLOAD, VLOAD, \"volatileLoad\", \"core.bitop\", \"FNbNiNfPhZh\")\n-DEF_D_BUILTIN (VLOAD16, VLOAD, \"volatileLoad\", \"core.bitop\", \"FNbNiNfPtZt\")\n-DEF_D_BUILTIN (VLOAD32, VLOAD, \"volatileLoad\", \"core.bitop\", \"FNbNiNfPkZk\")\n-DEF_D_BUILTIN (VLOAD64, VLOAD, \"volatileLoad\", \"core.bitop\", \"FNbNiNfPmZm\")\n-DEF_D_BUILTIN (VSTORE, VSTORE, \"volatileStore\", \"core.bitop\", \"FNbNiNfPhhZv\")\n-DEF_D_BUILTIN (VSTORE16, VSTORE, \"volatileStore\", \"core.bitop\", \"FNbNiNfPttZv\")\n-DEF_D_BUILTIN (VSTORE32, VSTORE, \"volatileStore\", \"core.bitop\", \"FNbNiNfPkkZv\")\n-DEF_D_BUILTIN (VSTORE64, VSTORE, \"volatileStore\", \"core.bitop\", \"FNbNiNfPmmZv\")\n+DEF_D_BUILTIN (BSF, NONE, \"bsf\", \"core.bitop\", \"FNaNbNiNfkZi\")\n+DEF_D_BUILTIN (BSR, NONE, \"bsr\", \"core.bitop\", \"FNaNbNiNfkZi\")\n+DEF_D_BUILTIN (BT, NONE, \"bt\", \"core.bitop\", \"FNaNbNixPkkZi\")\n+DEF_D_BUILTIN (BTC, NONE, \"btc\", \"core.bitop\", \"FNaNbNiPkkZi\")\n+DEF_D_BUILTIN (BTR, NONE, \"btr\", \"core.bitop\", \"FNaNbNiPkkZi\")\n+DEF_D_BUILTIN (BTS, NONE, \"bts\", \"core.bitop\", \"FNaNbNiPkkZi\")\n+DEF_D_BUILTIN (BSF64, NONE, \"bsf\", \"core.bitop\", \"FNaNbNiNfmZi\")\n+DEF_D_BUILTIN (BSR64, NONE, \"bsr\", \"core.bitop\", \"FNaNbNiNfmZi\")\n+DEF_D_BUILTIN (BT64, NONE, \"bt\", \"core.bitop\", \"FNaNbNixPmmZi\")\n+DEF_D_BUILTIN (BTC64, NONE, \"btc\", \"core.bitop\", \"FNaNbNiPmmZi\")\n+DEF_D_BUILTIN (BTR64, NONE, \"btr\", \"core.bitop\", \"FNaNbNiPmmZi\")\n+DEF_D_BUILTIN (BTS64, NONE, \"bts\", \"core.bitop\", \"FNaNbNiPmmZi\")\n+\n+DEF_D_BUILTIN (BSWAP32, BSWAP32, \"bswap\", \"core.bitop\", \"FNaNbNiNfkZk\")\n+DEF_D_BUILTIN (BSWAP64, BSWAP64, \"bswap\", \"core.bitop\", \"FNaNbNiNfmZm\")\n+\n+DEF_D_BUILTIN (POPCNT32, NONE, \"popcnt\", \"core.bitop\", \"FNaNbNiNfkZi\")\n+DEF_D_BUILTIN (POPCNT64, NONE, \"popcnt\", \"core.bitop\", \"FNaNbNiNfmZi\")\n+\n+DEF_D_BUILTIN (VLOAD8, NONE, \"volatileLoad\", \"core.bitop\", \"FNbNiNfPhZh\")\n+DEF_D_BUILTIN (VLOAD16, NONE, \"volatileLoad\", \"core.bitop\", \"FNbNiNfPtZt\")\n+DEF_D_BUILTIN (VLOAD32, NONE, \"volatileLoad\", \"core.bitop\", \"FNbNiNfPkZk\")\n+DEF_D_BUILTIN (VLOAD64, NONE, \"volatileLoad\", \"core.bitop\", \"FNbNiNfPmZm\")\n+DEF_D_BUILTIN (VSTORE8, NONE, \"volatileStore\", \"core.bitop\", \"FNbNiNfPhhZv\")\n+DEF_D_BUILTIN (VSTORE16, NONE, \"volatileStore\", \"core.bitop\", \"FNbNiNfPttZv\")\n+DEF_D_BUILTIN (VSTORE32, NONE, \"volatileStore\", \"core.bitop\", \"FNbNiNfPkkZv\")\n+DEF_D_BUILTIN (VSTORE64, NONE, \"volatileStore\", \"core.bitop\", \"FNbNiNfPmmZv\")\n \n /* core.checkedint intrinsics.  */\n \n-DEF_D_BUILTIN (ADDS, ADDS, \"adds\", \"core.checkedint\", \"FNaNbNiNfiiKbZi\")\n-DEF_D_BUILTIN (ADDSL, ADDS, \"adds\", \"core.checkedint\", \"FNaNbNiNfllKbZl\")\n-DEF_D_BUILTIN (ADDU, ADDS, \"addu\", \"core.checkedint\", \"FNaNbNiNfkkKbZk\")\n-DEF_D_BUILTIN (ADDUL, ADDS, \"addu\", \"core.checkedint\", \"FNaNbNiNfmmKbZm\")\n-DEF_D_BUILTIN (SUBS, SUBS, \"subs\", \"core.checkedint\", \"FNaNbNiNfiiKbZi\")\n-DEF_D_BUILTIN (SUBSL, SUBS, \"subs\", \"core.checkedint\", \"FNaNbNiNfllKbZl\")\n-DEF_D_BUILTIN (SUBU, SUBS, \"subu\", \"core.checkedint\", \"FNaNbNiNfkkKbZk\")\n-DEF_D_BUILTIN (SUBUL, SUBS, \"subu\", \"core.checkedint\", \"FNaNbNiNfmmKbZm\")\n-DEF_D_BUILTIN (MULS, MULS, \"muls\", \"core.checkedint\", \"FNaNbNiNfiiKbZi\")\n-DEF_D_BUILTIN (MULSL, MULS, \"muls\", \"core.checkedint\", \"FNaNbNiNfllKbZl\")\n-DEF_D_BUILTIN (MULU, MULS, \"mulu\", \"core.checkedint\", \"FNaNbNiNfkkKbZk\")\n-DEF_D_BUILTIN (MULUI, MULS, \"mulu\", \"core.checkedint\", \"FNaNbNiNfmkKbZm\")\n-DEF_D_BUILTIN (MULUL, MULS, \"mulu\", \"core.checkedint\", \"FNaNbNiNfmmKbZm\")\n-DEF_D_BUILTIN (NEGS, NEGS, \"negs\", \"core.checkedint\", \"FNaNbNiNfiKbZi\")\n-DEF_D_BUILTIN (NEGSL, NEGS, \"negs\", \"core.checkedint\", \"FNaNbNiNflKbZl\")\n+DEF_D_BUILTIN (ADDS, NONE, \"adds\", \"core.checkedint\", \"FNaNbNiNfiiKbZi\")\n+DEF_D_BUILTIN (ADDSL, NONE, \"adds\", \"core.checkedint\", \"FNaNbNiNfllKbZl\")\n+DEF_D_BUILTIN (ADDU, NONE, \"addu\", \"core.checkedint\", \"FNaNbNiNfkkKbZk\")\n+DEF_D_BUILTIN (ADDUL, NONE, \"addu\", \"core.checkedint\", \"FNaNbNiNfmmKbZm\")\n+DEF_D_BUILTIN (SUBS, NONE, \"subs\", \"core.checkedint\", \"FNaNbNiNfiiKbZi\")\n+DEF_D_BUILTIN (SUBSL, NONE, \"subs\", \"core.checkedint\", \"FNaNbNiNfllKbZl\")\n+DEF_D_BUILTIN (SUBU, NONE, \"subu\", \"core.checkedint\", \"FNaNbNiNfkkKbZk\")\n+DEF_D_BUILTIN (SUBUL, NONE, \"subu\", \"core.checkedint\", \"FNaNbNiNfmmKbZm\")\n+DEF_D_BUILTIN (MULS, NONE, \"muls\", \"core.checkedint\", \"FNaNbNiNfiiKbZi\")\n+DEF_D_BUILTIN (MULSL, NONE, \"muls\", \"core.checkedint\", \"FNaNbNiNfllKbZl\")\n+DEF_D_BUILTIN (MULU, NONE, \"mulu\", \"core.checkedint\", \"FNaNbNiNfkkKbZk\")\n+DEF_D_BUILTIN (MULUI, NONE, \"mulu\", \"core.checkedint\", \"FNaNbNiNfmkKbZm\")\n+DEF_D_BUILTIN (MULUL, NONE, \"mulu\", \"core.checkedint\", \"FNaNbNiNfmmKbZm\")\n+DEF_D_BUILTIN (NEGS, NONE, \"negs\", \"core.checkedint\", \"FNaNbNiNfiKbZi\")\n+DEF_D_BUILTIN (NEGSL, NONE, \"negs\", \"core.checkedint\", \"FNaNbNiNflKbZl\")\n \n /* core.math intrinsics.  */\n \n-DEF_D_BUILTIN (COS, COS, \"cos\", \"core.math\", \"FNaNbNiNfeZe\")\n-DEF_D_BUILTIN (FABS, FABS, \"fabs\", \"core.math\", \"FNaNbNiNfeZe\")\n-DEF_D_BUILTIN (LDEXP, LDEXP, \"ldexp\", \"core.math\", \"FNaNbNiNfeiZe\")\n-DEF_D_BUILTIN (RINT, RINT, \"rint\", \"core.math\", \"FNaNbNiNfeZe\")\n-DEF_D_BUILTIN (RNDTOL, RNDTOL, \"rndtol\", \"core.math\", \"FNaNbNiNfeZl\")\n-DEF_D_BUILTIN (SIN, SIN, \"sin\", \"core.math\", \"FNaNbNiNfeZe\")\n+DEF_D_BUILTIN (COSL, COSL, \"cos\", \"core.math\", \"FNaNbNiNfeZe\")\n+DEF_D_BUILTIN (FABSL, FABSL, \"fabs\", \"core.math\", \"FNaNbNiNfeZe\")\n+DEF_D_BUILTIN (LDEXPL, LDEXPL, \"ldexp\", \"core.math\", \"FNaNbNiNfeiZe\")\n+DEF_D_BUILTIN (RINTL, RINTL, \"rint\", \"core.math\", \"FNaNbNiNfeZe\")\n+\n+/* Not sure if `llroundl' stands as a good replacement for the expected\n+   behavior of `rndtol()'.  */\n+DEF_D_BUILTIN (RNDTOLL, LLROUNDL, \"rndtol\", \"core.math\", \"FNaNbNiNfeZl\")\n+\n+DEF_D_BUILTIN (SINL, SINL, \"sin\", \"core.math\", \"FNaNbNiNfeZe\")\n DEF_D_BUILTIN (SQRTF, SQRTF, \"sqrt\", \"core.math\", \"FNaNbNiNffZf\")\n DEF_D_BUILTIN (SQRT, SQRT, \"sqrt\", \"core.math\", \"FNaNbNiNfdZd\")\n DEF_D_BUILTIN (SQRTL, SQRTL, \"sqrt\", \"core.math\", \"FNaNbNiNfeZe\")\n-DEF_D_BUILTIN (TOPRECF, TOPREC, \"toPrec\", \"core.math\", \"FNaNbNffZI1T\")\n-DEF_D_BUILTIN (TOPREC, TOPREC, \"toPrec\", \"core.math\", \"FNaNbNfdZI1T\")\n-DEF_D_BUILTIN (TOPRECL, TOPREC, \"toPrec\", \"core.math\", \"FNaNbNfeZI1T\")\n+DEF_D_BUILTIN (TOPRECF, NONE, \"toPrec\", \"core.math\", \"FNaNbNffZI1T\")\n+DEF_D_BUILTIN (TOPREC, NONE, \"toPrec\", \"core.math\", \"FNaNbNfdZI1T\")\n+DEF_D_BUILTIN (TOPRECL, NONE, \"toPrec\", \"core.math\", \"FNaNbNfeZI1T\")\n \n /* std.math intrinsics.  */\n \n-DEF_D_BUILTIN (STD_COS, COS, \"cos\", \"std.math\", \"FNaNbNiNfeZe\")\n-DEF_D_BUILTIN (STD_FABS, FABS, \"fabs\", \"std.math\", \"FNaNbNiNfeZe\")\n-DEF_D_BUILTIN (STD_LDEXP, LDEXP, \"ldexp\", \"std.math\", \"FNaNbNiNfeiZe\")\n-DEF_D_BUILTIN (STD_RINT, RINT, \"rint\", \"std.math\", \"FNaNbNiNfeZe\")\n-DEF_D_BUILTIN (STD_RNDTOL, RNDTOL, \"rndtol\", \"std.math\", \"FNaNbNiNfeZl\")\n-DEF_D_BUILTIN (STD_SIN, SIN, \"sin\", \"std.math\", \"FNaNbNiNfeZe\")\n-DEF_D_BUILTIN (STD_SQRTF, SQRTF, \"sqrt\", \"std.math\", \"FNaNbNiNffZf\")\n-DEF_D_BUILTIN (STD_SQRT, SQRT, \"sqrt\", \"std.math\", \"FNaNbNiNfdZd\")\n-DEF_D_BUILTIN (STD_SQRTL, SQRTL, \"sqrt\", \"std.math\", \"FNaNbNiNfeZe\")\n-\n-DEF_CTFE_BUILTIN (TAN, TAN, \"tan\", \"std.math\", \"FNaNbNiNeeZe\")\n+DEF_CTFE_BUILTIN (TAN, TANL, \"tan\", \"std.math\", \"FNaNbNiNeeZe\")\n DEF_CTFE_BUILTIN (ISNAN, ISNAN, \"isNaN\", \"std.math\", \"FNaNbNiNeI1XZb\")\n-DEF_CTFE_BUILTIN (ISINFINITY, ISINFINITY, \"isInfinity\", \"std.math\",\n-\t\t  \"FNaNbNiNeI1XZb\")\n+DEF_CTFE_BUILTIN (ISINFINITY, ISINF, \"isInfinity\", \"std.math\", \"FNaNbNiNeI1XZb\")\n DEF_CTFE_BUILTIN (ISFINITE, ISFINITE, \"isFinite\", \"std.math\", \"FNaNbNiNeI1XZb\")\n \n-DEF_CTFE_BUILTIN (EXP, EXP, \"exp\", \"std.math\", \"FNaNbNiNeeZe\")\n-DEF_CTFE_BUILTIN (EXPM1, EXPM1, \"expm1\", \"std.math\", \"FNaNbNiNeeZe\")\n-DEF_CTFE_BUILTIN (EXP2, EXP2, \"exp2\", \"std.math\", \"FNaNbNiNeeZe\")\n+DEF_CTFE_BUILTIN (EXP, EXPL, \"exp\", \"std.math\", \"FNaNbNiNeeZe\")\n+DEF_CTFE_BUILTIN (EXPM1, EXPM1L, \"expm1\", \"std.math\", \"FNaNbNiNeeZe\")\n+DEF_CTFE_BUILTIN (EXP2, EXP2L, \"exp2\", \"std.math\", \"FNaNbNiNeeZe\")\n \n-DEF_CTFE_BUILTIN (LOG, LOG, \"log\", \"std.math\", \"FNaNbNiNfeZe\")\n-DEF_CTFE_BUILTIN (LOG2, LOG2, \"log2\", \"std.math\", \"FNaNbNiNfeZe\")\n-DEF_CTFE_BUILTIN (LOG10, LOG10, \"log10\", \"std.math\", \"FNaNbNiNfeZe\")\n+DEF_CTFE_BUILTIN (LOG, LOGL, \"log\", \"std.math\", \"FNaNbNiNfeZe\")\n+DEF_CTFE_BUILTIN (LOG2, LOG2L, \"log2\", \"std.math\", \"FNaNbNiNfeZe\")\n+DEF_CTFE_BUILTIN (LOG10, LOG10L, \"log10\", \"std.math\", \"FNaNbNiNfeZe\")\n \n-DEF_CTFE_BUILTIN (ROUND, ROUND, \"round\", \"std.math\", \"FNbNiNeeZe\")\n+DEF_CTFE_BUILTIN (ROUND, ROUNDL, \"round\", \"std.math\", \"FNbNiNeeZe\")\n DEF_CTFE_BUILTIN (FLOORF, FLOORF, \"floor\", \"std.math\", \"FNaNbNiNefZf\")\n DEF_CTFE_BUILTIN (FLOOR, FLOOR, \"floor\", \"std.math\", \"FNaNbNiNedZd\")\n DEF_CTFE_BUILTIN (FLOORL, FLOORL, \"floor\", \"std.math\", \"FNaNbNiNeeZe\")\n DEF_CTFE_BUILTIN (CEILF, CEILF, \"ceil\", \"std.math\", \"FNaNbNiNefZf\")\n DEF_CTFE_BUILTIN (CEIL, CEIL, \"ceil\", \"std.math\", \"FNaNbNiNedZd\")\n DEF_CTFE_BUILTIN (CEILL, CEILL, \"ceil\", \"std.math\", \"FNaNbNiNeeZe\")\n \n-DEF_CTFE_BUILTIN (TRUNC, TRUNC, \"trunc\", \"std.math\", \"FNbNiNeeZe\")\n-DEF_CTFE_BUILTIN (FMIN, FMIN, \"fmin\", \"std.math\", \"FNaNbNiNfeeZe\")\n-DEF_CTFE_BUILTIN (FMAX, FMAX, \"fmax\", \"std.math\", \"FNaNbNiNfeeZe\")\n-DEF_CTFE_BUILTIN (COPYSIGN, COPYSIGN, \"copysign\", \"std.math\",\n-\t\t  \"FNaNbNiNeI1RI1XZI1R\")\n-DEF_CTFE_BUILTIN (COPYSIGNI, COPYSIGN, \"copysign\", \"std.math\",\n+DEF_CTFE_BUILTIN (TRUNC, TRUNCL, \"trunc\", \"std.math\", \"FNbNiNeeZe\")\n+DEF_CTFE_BUILTIN (FMIN, FMINL, \"fmin\", \"std.math\", \"FNaNbNiNfeeZe\")\n+DEF_CTFE_BUILTIN (FMAX, FMAXL, \"fmax\", \"std.math\", \"FNaNbNiNfeeZe\")\n+DEF_CTFE_BUILTIN (COPYSIGN, NONE, \"copysign\", \"std.math\", \"FNaNbNiNeI1RI1XZI1R\")\n+DEF_CTFE_BUILTIN (COPYSIGNI, NONE, \"copysign\", \"std.math\",\n \t\t  \"FNaNbNiNeI1XI1RZI1R\")\n \n-DEF_CTFE_BUILTIN (POW, POW, \"pow\", \"std.math\", \"FNaNbNiNeI1FI1GZ@\")\n-DEF_CTFE_BUILTIN (FMA, FMA, \"fma\", \"std.math\", \"FNaNbNiNfeeeZe\")\n+DEF_CTFE_BUILTIN (POW, NONE, \"pow\", \"std.math\", \"FNaNbNiNeI1FI1GZ@\")\n+DEF_CTFE_BUILTIN (FMA, FMAL, \"fma\", \"std.math\", \"FNaNbNiNfeeeZe\")\n \n /* core.stdc.stdarg intrinsics.  */\n \n-DEF_D_BUILTIN (VA_ARG, VA_ARG, \"va_arg\", \"core.stdc.stdarg\",\n-\t       \"FKI7va_listKI1TZv\")\n-DEF_D_BUILTIN (C_VA_ARG, C_VA_ARG, \"va_arg\", \"core.stdc.stdarg\",\n-\t       \"FKI7va_listZI1T\")\n-DEF_D_BUILTIN (VASTART, VASTART, \"va_start\", \"core.stdc.stdarg\",\n+DEF_D_BUILTIN (VA_ARG, NONE, \"va_arg\", \"core.stdc.stdarg\", \"FKI7va_listKI1TZv\")\n+DEF_D_BUILTIN (C_VA_ARG, NONE, \"va_arg\", \"core.stdc.stdarg\", \"FKI7va_listZI1T\")\n+DEF_D_BUILTIN (VASTART, NONE, \"va_start\", \"core.stdc.stdarg\",\n \t       \"FJI7va_listKI1TZv\")\n \n #undef DEF_D_BUILTIN"}, {"sha": "e10c06dd41af3ac183c59d779a12cc3450f96e92", "filename": "gcc/testsuite/gdc.dg/intrinsics.d", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee874f1353933b1427b5e2953358eb3424090d5/gcc%2Ftestsuite%2Fgdc.dg%2Fintrinsics.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee874f1353933b1427b5e2953358eb3424090d5/gcc%2Ftestsuite%2Fgdc.dg%2Fintrinsics.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fintrinsics.d?ref=6ee874f1353933b1427b5e2953358eb3424090d5", "patch": "@@ -0,0 +1,117 @@\n+// { dg-do compile }\n+// { dg-options \"-fdump-tree-original\" }\n+import core.bitop;\n+import core.checkedint;\n+import core.math;\n+import core.stdc.stdarg;\n+\n+//////////////////////////////////////////////////////\n+// core.bitop\n+\n+// { dg-final { scan-tree-dump-not \" bsf \" \"original\" } }\n+int test_bsf(uint a) { return bsf(a); }\n+int test_bsf(ulong a) { return bsf(a); }\n+// { dg-final { scan-tree-dump-not \" bsr \" \"original\" } }\n+int test_bsr(uint a) { return bsr(a); }\n+int test_bsr(ulong a) { return bsr(a); }\n+// { dg-final { scan-tree-dump-not \" bt \" \"original\" } }\n+int test_bt(size_t *a, size_t b) { return bt(a, b); }\n+// { dg-final { scan-tree-dump-not \" btc \" \"original\" } }\n+int test_btc(size_t *a, size_t b) { return btc(a, b); }\n+// { dg-final { scan-tree-dump-not \" btr \" \"original\" } }\n+int test_btr(size_t *a, size_t b) { return btr(a, b); }\n+// { dg-final { scan-tree-dump-not \" bts \" \"original\" } }\n+int test_bts(size_t *a, size_t b) { return bts(a, b); }\n+// { dg-final { scan-tree-dump-not \" bswap \" \"original\" } }\n+uint test_bswap(uint a) { return bswap(a); }\n+ulong test_bswap(ulong a) { return bswap(a); }\n+// { dg-final { scan-tree-dump-not \" popcnt \" \"original\" } }\n+int test_popcnt(uint a) { return popcnt(a); }\n+int test_popcnt(ulong a) { return popcnt(a); }\n+// { dg-final { scan-tree-dump-not \" volatileLoad \" \"original\" } }\n+ubyte test_volatileLoad(ubyte *a) { return volatileLoad(a); }\n+ushort test_volatileLoad(ushort *a) { return volatileLoad(a); }\n+uint test_volatileLoad(uint *a) { return volatileLoad(a); }\n+ulong test_volatileLoad(ulong *a) { return volatileLoad(a); }\n+// { dg-final { scan-tree-dump-not \" volatileStore \" \"original\" } }\n+void test_volatileStore(ubyte *a, ubyte b) { return volatileStore(a, b); }\n+void test_volatileStore(ushort *a, ushort b) { return volatileStore(a, b); }\n+void test_volatileStore(uint *a, uint b) { return volatileStore(a, b); }\n+void test_volatileStore(ulong *a, ulong b) { return volatileStore(a, b); }\n+\n+//////////////////////////////////////////////////////\n+// core.checkedint\n+\n+// { dg-final { scan-tree-dump-not \" adds \" \"original\" } }\n+int test_adds(int a, int b, ref bool c) { return adds(a, b, c); }\n+long test_adds(long a, long b, ref bool c) { return adds(a, b, c); }\n+// { dg-final { scan-tree-dump-not \" addu \" \"original\" } }\n+uint test_addu(uint a, uint b, ref bool c) { return addu(a, b, c); }\n+ulong test_addu(ulong a, ulong b, ref bool c) { return addu(a, b, c); }\n+// { dg-final { scan-tree-dump-not \" subs \" \"original\" } }\n+int test_subs(int a, int b, ref bool c) { return subs(a, b, c); }\n+long test_subs(long a, long b, ref bool c) { return subs(a, b, c); }\n+// { dg-final { scan-tree-dump-not \" subu \" \"original\" } }\n+uint test_subu(uint a, uint b, ref bool c) { return subu(a, b, c); }\n+ulong test_subu(ulong a, ulong b, ref bool c) { return subu(a, b, c); }\n+// { dg-final { scan-tree-dump-not \" negs \" \"original\" } }\n+int test_negs(int a, ref bool b) { return negs(a, b); }\n+long test_negs(long a, ref bool b) { return negs(a, b); }\n+// { dg-final { scan-tree-dump-not \" muls \" \"original\" } }\n+int test_muls(int a, int b, ref bool c) { return muls(a, b, c); }\n+long test_muls(long a, long b, ref bool c) { return muls(a, b, c); }\n+// { dg-final { scan-tree-dump-not \" mulu \" \"original\" } }\n+uint test_mulu(uint a, uint b, ref bool c) { return mulu(a, b, c); }\n+ulong test_mulu(ulong a, uint b, ref bool c) { return mulu(a, b, c); }\n+ulong test_mulu(ulong a, ulong b, ref bool c) { return mulu(a, b, c); }\n+\n+//////////////////////////////////////////////////////\n+// core.math\n+\n+// { dg-final { scan-tree-dump-not \" cos \" \"original\" } }\n+float test_cos(float a) { return cos(a); }\n+double test_cos(double a) { return cos(a); }\n+real test_cos(real a) { return cos(a); }\n+// { dg-final { scan-tree-dump-not \" sin \" \"original\" } }\n+float test_sin(float a) { return sin(a); }\n+double test_sin(double a) { return sin(a); }\n+real test_sin(real a) { return sin(a); }\n+// { dg-final { scan-tree-dump-not \" rndtol \" \"original\" } }\n+long test_rndtol(float a) { return rndtol(a); }\n+long test_rndtol(double a) { return rndtol(a); }\n+long test_rndtol(real a) { return rndtol(a); }\n+// { dg-final { scan-tree-dump-not \" sqrt \" \"original\" } }\n+float test_sqrt(float a) { return sqrt(a); }\n+double test_sqrt(double a) { return sqrt(a); }\n+real test_sqrt(real a) { return sqrt(a); }\n+// { dg-final { scan-tree-dump-not \" ldexp \" \"original\" } }\n+float test_ldexp(float a, int b) { return ldexp(a, b); }\n+double test_ldexp(double a, int b) { return ldexp(a, b); }\n+real test_ldexp(real a, int b) { return ldexp(a, b); }\n+// { dg-final { scan-tree-dump-not \" fabs \" \"original\" } }\n+float test_fabs(float a) { return fabs(a); }\n+double test_fabs(double a) { return fabs(a); }\n+real test_fabs(real a) { return fabs(a); }\n+// { dg-final { scan-tree-dump-not \" rint \" \"original\" } }\n+float test_rint(float a) { return rint(a); }\n+double test_rint(double a) { return rint(a); }\n+real test_rint(real a) { return rint(a); }\n+// { dg-final { scan-tree-dump-not \" toPrec \" \"original\" } }\n+float test_toPrec(float a) { return toPrec!float(a); }\n+float test_toPrec(double a) { return toPrec!float(a); }\n+float test_toPrec(real a) { return toPrec!float(a); }\n+double test_toPrec(float a) { return toPrec!double(a); }\n+double test_toPrec(double a) { return toPrec!double(a); }\n+double test_toPrec(real a) { return toPrec!double(a); }\n+real test_toPrec(float a) { return toPrec!real(a); }\n+real test_toPrec(double a) { return toPrec!real(a); }\n+real test_toPrec(real a) { return toPrec!real(a); }\n+\n+//////////////////////////////////////////////////////\n+// core.stdc.stdarg\n+\n+// { dg-final { scan-tree-dump-not \" va_arg \" \"original\" } }\n+void test_va_arg(...) { int a; return va_arg!int(_argptr, a); }\n+int test_va_arg(...) { return va_arg!int(_argptr); }\n+// { dg-final { scan-tree-dump-not \" va_start \" \"original\" } }\n+void test_va_start(int a, ...) { return va_start(_argptr, a); }"}]}