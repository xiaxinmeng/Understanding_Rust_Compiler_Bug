{"sha": "7921a90e334117206c6bb78bad57e07fb242214c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkyMWE5MGUzMzQxMTcyMDZjNmJiNzhiYWQ1N2UwN2ZiMjQyMjE0Yw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-07-17T10:26:25Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-07-17T10:26:25Z"}, "message": "re PR tree-optimization/91178 (Infinite recursion in split_constant_offset in slp after r260289)\n\n2019-07-17  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/91178\n\t* tree-vect-stmts.c (get_group_load_store_type): For SLP\n\tloads with a gap larger than the vector size always use\n\tVMAT_STRIDED_SLP.\n\t(vectorizable_load): For VMAT_STRIDED_SLP with a permutation\n\tavoid loading vectors that are only contained in the gap\n\tand thus are not needed.\n\n\t* gcc.dg/torture/pr91178.c: New testcase.\n\nFrom-SVN: r273549", "tree": {"sha": "0f25c2455ffa74ab7f422e94f69d0c33157fbed8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f25c2455ffa74ab7f422e94f69d0c33157fbed8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7921a90e334117206c6bb78bad57e07fb242214c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7921a90e334117206c6bb78bad57e07fb242214c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7921a90e334117206c6bb78bad57e07fb242214c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7921a90e334117206c6bb78bad57e07fb242214c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9505acd8501e6c79bc4fa9ed9f1ee174462601d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9505acd8501e6c79bc4fa9ed9f1ee174462601d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9505acd8501e6c79bc4fa9ed9f1ee174462601d1"}], "stats": {"total": 48, "additions": 46, "deletions": 2}, "files": [{"sha": "b15db2d089e83a89dcb1d2f3fdb2366a1305fdd3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7921a90e334117206c6bb78bad57e07fb242214c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7921a90e334117206c6bb78bad57e07fb242214c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7921a90e334117206c6bb78bad57e07fb242214c", "patch": "@@ -1,3 +1,13 @@\n+2019-07-17  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/91178\n+\t* tree-vect-stmts.c (get_group_load_store_type): For SLP\n+\tloads with a gap larger than the vector size always use\n+\tVMAT_STRIDED_SLP.\n+\t(vectorizable_load): For VMAT_STRIDED_SLP with a permutation\n+\tavoid loading vectors that are only contained in the gap\n+\tand thus are not needed.\n+\n 2019-07-17  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/91180"}, {"sha": "2d7a6bfc6541f1848085e5e3a1af5668ccf5cdd9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7921a90e334117206c6bb78bad57e07fb242214c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7921a90e334117206c6bb78bad57e07fb242214c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7921a90e334117206c6bb78bad57e07fb242214c", "patch": "@@ -1,3 +1,8 @@\n+2019-07-17  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/91178\n+\t* gcc.dg/torture/pr91178.c: New testcase.\n+\n 2019-07-17  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/91180"}, {"sha": "b7a2dbe9e7f095fd92e847c90ba6975596d1f081", "filename": "gcc/testsuite/gcc.dg/torture/pr91178.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7921a90e334117206c6bb78bad57e07fb242214c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr91178.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7921a90e334117206c6bb78bad57e07fb242214c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr91178.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr91178.c?ref=7921a90e334117206c6bb78bad57e07fb242214c", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+\n+int a;\n+extern int f[10][91125];\n+int b[50];\n+void c()\n+{\n+  for (int d = 6; d <= a; d++)\n+    for (int e = 16; e <= 24; e++)\n+      b[e] -= f[d][d];\n+}"}, {"sha": "5d05e108ede61fc3558f94ec92beabc3858ee328", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7921a90e334117206c6bb78bad57e07fb242214c/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7921a90e334117206c6bb78bad57e07fb242214c/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=7921a90e334117206c6bb78bad57e07fb242214c", "patch": "@@ -2267,14 +2267,23 @@ get_group_load_store_type (stmt_vec_info stmt_info, tree vectype, bool slp,\n \t\t\t/ vect_get_scalar_dr_size (first_dr_info)))\n \t    overrun_p = false;\n \n+\t  /* If the gap at the end of the group exceeds a whole vector\n+\t     in size use the strided SLP code which can skip code-generation\n+\t     for the gap.  */\n+\t  if (vls_type == VLS_LOAD && known_gt (gap, nunits))\n+\t    *memory_access_type = VMAT_STRIDED_SLP;\n+\t  else\n+\t    *memory_access_type = VMAT_CONTIGUOUS;\n+\n \t  /* If the gap splits the vector in half and the target\n \t     can do half-vector operations avoid the epilogue peeling\n \t     by simply loading half of the vector only.  Usually\n \t     the construction with an upper zero half will be elided.  */\n \t  dr_alignment_support alignment_support_scheme;\n \t  scalar_mode elmode = SCALAR_TYPE_MODE (TREE_TYPE (vectype));\n \t  machine_mode vmode;\n-\t  if (overrun_p\n+\t  if (*memory_access_type == VMAT_CONTIGUOUS\n+\t      && overrun_p\n \t      && !masked_p\n \t      && (((alignment_support_scheme\n \t\t      = vect_supportable_dr_alignment (first_dr_info, false)))\n@@ -2297,7 +2306,6 @@ get_group_load_store_type (stmt_vec_info stmt_info, tree vectype, bool slp,\n \t\t\t\t \"Peeling for outer loop is not supported\\n\");\n \t      return false;\n \t    }\n-\t  *memory_access_type = VMAT_CONTIGUOUS;\n \t}\n     }\n   else\n@@ -8732,6 +8740,7 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       /* Checked by get_load_store_type.  */\n       unsigned int const_nunits = nunits.to_constant ();\n       unsigned HOST_WIDE_INT cst_offset = 0;\n+      unsigned int group_gap = 0;\n \n       gcc_assert (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo));\n       gcc_assert (!nested_in_vect_loop);\n@@ -8749,6 +8758,7 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       if (slp && grouped_load)\n \t{\n \t  group_size = DR_GROUP_SIZE (first_stmt_info);\n+\t  group_gap = DR_GROUP_GAP (first_stmt_info);\n \t  ref_type = get_group_alias_ptr_type (first_stmt_info);\n \t}\n       else\n@@ -8892,6 +8902,14 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  if (nloads > 1)\n \t    vec_alloc (v, nloads);\n \t  stmt_vec_info new_stmt_info = NULL;\n+\t  if (slp && slp_perm\n+\t      && (group_el % group_size) > group_size - group_gap\n+\t      && (group_el % group_size) + nloads * lnel < group_size)\n+\t    {\n+\t      dr_chain.quick_push (NULL_TREE);\n+\t      group_el += nloads * lnel;\n+\t      continue;\n+\t    }\n \t  for (i = 0; i < nloads; i++)\n \t    {\n \t      tree this_off = build_int_cst (TREE_TYPE (alias_off),"}]}