{"sha": "39e4731c78f5d5b1def6c81a2a7bc1417c523480", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzllNDczMWM3OGY1ZDViMWRlZjZjODFhMmE3YmMxNDE3YzUyMzQ4MA==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@linaro.org", "date": "2018-08-02T09:07:17Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2018-08-02T09:07:17Z"}, "message": "[ARM] Fix PR85434: spilling of stack protector guard's address on ARM\n\nIn case of high register pressure in PIC mode, address of the stack\nprotector's guard can be spilled on ARM targets as shown in PR85434,\nthus allowing an attacker to control what the canary would be compared\nagainst. This is also known as CVE-2018-12886. ARM does lack\nstack_protect_set and stack_protect_test insn patterns, defining them\ndoes not help as the address is expanded regularly and the patterns\nonly deal with the copy and test of the guard with the canary.\n\nThis problem does not occur for x86 targets because the PIC access and\nthe test can be done in the same instruction. Aarch64 is exempt too\nbecause PIC access insn pattern are mov of UNSPEC which prevents it from\nthe second access in the epilogue being CSEd in cse_local pass with the\nfirst access in the prologue.\n\nThe approach followed here is to create new \"combined\" set and test\nstandard pattern names that take the unexpanded guard and do the set or\ntest. This allows the target to use an opaque pattern (eg. using UNSPEC)\nto hide the individual instructions being generated to the compiler and\nsplit the pattern into generic load, compare and branch instruction\nafter register allocator, therefore avoiding any spilling. This is here\nimplemented for the ARM targets. For targets not implementing these new\nstandard pattern names, the existing stack_protect_set and\nstack_protect_test pattern names are used.\n\nTo be able to split PIC access after register allocation, the functions\nhad to be augmented to force a new PIC register load and to control\nwhich register it loads into. This is because sharing the PIC register\nbetween prologue and epilogue could lead to spilling due to CSE again\nwhich an attacker could use to control what the canary gets compared\nagainst.\n\n2018-08-02  Thomas Preud'homme  <thomas.preudhomme@linaro.org>\n\n    gcc/\n    PR target/85434\n    * target-insns.def (stack_protect_combined_set): Define new standard\n    pattern name.\n    (stack_protect_combined_test): Likewise.\n    * cfgexpand.c (stack_protect_prologue): Try new\n    stack_protect_combined_set pattern first.\n    * function.c (stack_protect_epilogue): Try new\n    stack_protect_combined_test pattern first.\n    * config/arm/arm.c (require_pic_register): Add pic_reg and compute_now\n    parameters to control which register to use as PIC register and force\n    reloading PIC register respectively.  Insert in the stream of insns if\n    possible.\n    (legitimize_pic_address): Expose above new parameters in prototype and\n    adapt recursive calls accordingly.\n    (arm_legitimize_address): Adapt to new legitimize_pic_address\n    prototype.\n    (thumb_legitimize_address): Likewise.\n    (arm_emit_call_insn): Adapt to new require_pic_register prototype.\n    * config/arm/arm-protos.h (legitimize_pic_address): Adapt to prototype\n    change.\n    * config/arm/arm.md (movsi expander): Adapt to legitimize_pic_address\n    prototype change.\n    (stack_protect_combined_set): New insn_and_split pattern.\n    (stack_protect_set): New insn pattern.\n    (stack_protect_combined_test): New insn_and_split pattern.\n    (stack_protect_test): New insn pattern.\n    * config/arm/unspecs.md (UNSPEC_SP_SET): New unspec.\n    (UNSPEC_SP_TEST): Likewise.\n    * doc/md.texi (stack_protect_combined_set): Document new standard\n    pattern name.\n    (stack_protect_set): Clarify that the operand for guard's address is\n    legal.\n    (stack_protect_combined_test): Document new standard pattern name.\n    (stack_protect_test): Clarify that the operand for guard's address is\n    legal.\n\n    gcc/testsuite/\n    PR target/85434\n    * gcc.target/arm/pr85434.c: New test.\n\nFrom-SVN: r263245", "tree": {"sha": "57309b5ab05b79b454c374bb9d6177fbbf8b143b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57309b5ab05b79b454c374bb9d6177fbbf8b143b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39e4731c78f5d5b1def6c81a2a7bc1417c523480", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39e4731c78f5d5b1def6c81a2a7bc1417c523480", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39e4731c78f5d5b1def6c81a2a7bc1417c523480", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39e4731c78f5d5b1def6c81a2a7bc1417c523480/comments", "author": {"login": "tpreudhomme-linaro", "id": 43454833, "node_id": "MDQ6VXNlcjQzNDU0ODMz", "avatar_url": "https://avatars.githubusercontent.com/u/43454833?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tpreudhomme-linaro", "html_url": "https://github.com/tpreudhomme-linaro", "followers_url": "https://api.github.com/users/tpreudhomme-linaro/followers", "following_url": "https://api.github.com/users/tpreudhomme-linaro/following{/other_user}", "gists_url": "https://api.github.com/users/tpreudhomme-linaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/tpreudhomme-linaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tpreudhomme-linaro/subscriptions", "organizations_url": "https://api.github.com/users/tpreudhomme-linaro/orgs", "repos_url": "https://api.github.com/users/tpreudhomme-linaro/repos", "events_url": "https://api.github.com/users/tpreudhomme-linaro/events{/privacy}", "received_events_url": "https://api.github.com/users/tpreudhomme-linaro/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "12c27c758ce62ff43836c5bee1538f9dfccf3d85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12c27c758ce62ff43836c5bee1538f9dfccf3d85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12c27c758ce62ff43836c5bee1538f9dfccf3d85"}], "stats": {"total": 500, "additions": 463, "deletions": 37}, "files": [{"sha": "35e4d99751d78f9624589b8f0c7f7a20fa4d5d58", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39e4731c78f5d5b1def6c81a2a7bc1417c523480", "patch": "@@ -1,3 +1,41 @@\n+2018-08-02  Thomas Preud'homme  <thomas.preudhomme@linaro.org>\n+\n+\tPR target/85434\n+\t* target-insns.def (stack_protect_combined_set): Define new standard\n+\tpattern name.\n+\t(stack_protect_combined_test): Likewise.\n+\t* cfgexpand.c (stack_protect_prologue): Try new\n+\tstack_protect_combined_set pattern first.\n+\t* function.c (stack_protect_epilogue): Try new\n+\tstack_protect_combined_test pattern first.\n+\t* config/arm/arm.c (require_pic_register): Add pic_reg and compute_now\n+\tparameters to control which register to use as PIC register and force\n+\treloading PIC register respectively.  Insert in the stream of insns if\n+\tpossible.\n+\t(legitimize_pic_address): Expose above new parameters in prototype and\n+\tadapt recursive calls accordingly.\n+\t(arm_legitimize_address): Adapt to new legitimize_pic_address\n+\tprototype.\n+\t(thumb_legitimize_address): Likewise.\n+\t(arm_emit_call_insn): Adapt to new require_pic_register prototype.\n+\t* config/arm/arm-protos.h (legitimize_pic_address): Adapt to prototype\n+\tchange.\n+\t* config/arm/arm.md (movsi expander): Adapt to legitimize_pic_address\n+\tprototype change.\n+\t(stack_protect_combined_set): New insn_and_split pattern.\n+\t(stack_protect_set): New insn pattern.\n+\t(stack_protect_combined_test): New insn_and_split pattern.\n+\t(stack_protect_test): New insn pattern.\n+\t* config/arm/unspecs.md (UNSPEC_SP_SET): New unspec.\n+\t(UNSPEC_SP_TEST): Likewise.\n+\t* doc/md.texi (stack_protect_combined_set): Document new standard\n+\tpattern name.\n+\t(stack_protect_set): Clarify that the operand for guard's address is\n+\tlegal.\n+\t(stack_protect_combined_test): Document new standard pattern name.\n+\t(stack_protect_test): Clarify that the operand for guard's address is\n+\tlegal.\n+\n 2018-08-02  David Malcolm  <dmalcolm@redhat.com>\n \n \t* dumpfile.c (dump_user_location_t::dump_user_location_t): Add"}, {"sha": "0a73ac754cfaaf3896df19404f8baa18f8554f2d", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=39e4731c78f5d5b1def6c81a2a7bc1417c523480", "patch": "@@ -6105,8 +6105,18 @@ stack_protect_prologue (void)\n {\n   tree guard_decl = targetm.stack_protect_guard ();\n   rtx x, y;\n+  struct expand_operand ops[2];\n \n   x = expand_normal (crtl->stack_protect_guard);\n+  create_fixed_operand (&ops[0], x);\n+  create_fixed_operand (&ops[1], DECL_RTL (guard_decl));\n+  /* Allow the target to compute address of Y and copy it to X without\n+     leaking Y into a register.  This combined address + copy pattern allows\n+     the target to prevent spilling of any intermediate results by splitting\n+     it after register allocator.  */\n+  if (maybe_expand_insn (targetm.code_for_stack_protect_combined_set, 2, ops))\n+    return;\n+\n   if (guard_decl)\n     y = expand_normal (guard_decl);\n   else"}, {"sha": "100844e659cdc7b1e4979f11a64d5bea827a7324", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=39e4731c78f5d5b1def6c81a2a7bc1417c523480", "patch": "@@ -67,7 +67,7 @@ extern int const_ok_for_dimode_op (HOST_WIDE_INT, enum rtx_code);\n extern int arm_split_constant (RTX_CODE, machine_mode, rtx,\n \t\t\t       HOST_WIDE_INT, rtx, rtx, int);\n extern int legitimate_pic_operand_p (rtx);\n-extern rtx legitimize_pic_address (rtx, machine_mode, rtx);\n+extern rtx legitimize_pic_address (rtx, machine_mode, rtx, rtx, bool);\n extern rtx legitimize_tls_address (rtx, rtx);\n extern bool arm_legitimate_address_p (machine_mode, rtx, bool);\n extern int arm_legitimate_address_outer_p (machine_mode, rtx, RTX_CODE, int);"}, {"sha": "87c728e0eeacb1cb394e5dc276458d4d9efd1856", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 41, "deletions": 15, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=39e4731c78f5d5b1def6c81a2a7bc1417c523480", "patch": "@@ -7369,20 +7369,26 @@ legitimate_pic_operand_p (rtx x)\n }\n \n /* Record that the current function needs a PIC register.  Initialize\n-   cfun->machine->pic_reg if we have not already done so.  */\n+   cfun->machine->pic_reg if we have not already done so.\n+\n+   A new pseudo register is used for the PIC register if possible, otherwise\n+   PIC_REG must be non NULL and is used instead.  COMPUTE_NOW forces the PIC\n+   register to be loaded, irregardless of whether it was loaded previously.  */\n \n static void\n-require_pic_register (void)\n+require_pic_register (rtx pic_reg, bool compute_now)\n {\n   /* A lot of the logic here is made obscure by the fact that this\n      routine gets called as part of the rtx cost estimation process.\n      We don't want those calls to affect any assumptions about the real\n      function; and further, we can't call entry_of_function() until we\n      start the real expansion process.  */\n-  if (!crtl->uses_pic_offset_table)\n+  if (!crtl->uses_pic_offset_table || compute_now)\n     {\n-      gcc_assert (can_create_pseudo_p ());\n+      gcc_assert (can_create_pseudo_p ()\n+\t\t  || (pic_reg != NULL_RTX && GET_MODE (pic_reg) == Pmode));\n       if (arm_pic_register != INVALID_REGNUM\n+\t  && can_create_pseudo_p ()\n \t  && !(TARGET_THUMB1 && arm_pic_register > LAST_LO_REGNUM))\n \t{\n \t  if (!cfun->machine->pic_reg)\n@@ -7399,7 +7405,8 @@ require_pic_register (void)\n \t  rtx_insn *seq, *insn;\n \n \t  if (!cfun->machine->pic_reg)\n-\t    cfun->machine->pic_reg = gen_reg_rtx (Pmode);\n+\t    cfun->machine->pic_reg =\n+\t      can_create_pseudo_p () ? gen_reg_rtx (Pmode) : pic_reg;\n \n \t  /* Play games to avoid marking the function as needing pic\n \t     if we are being called as part of the cost-estimation\n@@ -7410,7 +7417,8 @@ require_pic_register (void)\n \t      start_sequence ();\n \n \t      if (TARGET_THUMB1 && arm_pic_register != INVALID_REGNUM\n-\t\t  && arm_pic_register > LAST_LO_REGNUM)\n+\t\t  && arm_pic_register > LAST_LO_REGNUM\n+\t\t  && can_create_pseudo_p ())\n \t\temit_move_insn (cfun->machine->pic_reg,\n \t\t\t\tgen_rtx_REG (Pmode, arm_pic_register));\n \t      else\n@@ -7427,15 +7435,29 @@ require_pic_register (void)\n \t         we can't yet emit instructions directly in the final\n \t\t insn stream.  Queue the insns on the entry edge, they will\n \t\t be committed after everything else is expanded.  */\n-\t      insert_insn_on_edge (seq,\n-\t\t\t\t   single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n+\t      if (currently_expanding_to_rtl)\n+\t\tinsert_insn_on_edge (seq,\n+\t\t\t\t     single_succ_edge\n+\t\t\t\t     (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n+\t      else\n+\t\temit_insn (seq);\n \t    }\n \t}\n     }\n }\n \n+/* Legitimize PIC load to ORIG into REG.  If REG is NULL, a new pseudo is\n+   created to hold the result of the load.  If not NULL, PIC_REG indicates\n+   which register to use as PIC register, otherwise it is decided by register\n+   allocator.  COMPUTE_NOW forces the PIC register to be loaded at the current\n+   location in the instruction stream, irregardless of whether it was loaded\n+   previously.\n+\n+   Returns the register REG into which the PIC load is performed.  */\n+\n rtx\n-legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)\n+legitimize_pic_address (rtx orig, machine_mode mode, rtx reg, rtx pic_reg,\n+\t\t\tbool compute_now)\n {\n   if (GET_CODE (orig) == SYMBOL_REF\n       || GET_CODE (orig) == LABEL_REF)\n@@ -7469,7 +7491,7 @@ legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)\n \t  rtx mem;\n \n \t  /* If this function doesn't have a pic register, create one now.  */\n-\t  require_pic_register ();\n+\t  require_pic_register (pic_reg, compute_now);\n \n \t  pat = gen_calculate_pic_address (reg, cfun->machine->pic_reg, orig);\n \n@@ -7520,9 +7542,11 @@ legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)\n \n       gcc_assert (GET_CODE (XEXP (orig, 0)) == PLUS);\n \n-      base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n+      base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg,\n+\t\t\t\t     pic_reg, compute_now);\n       offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n-\t\t\t\t       base == reg ? 0 : reg);\n+\t\t\t\t       base == reg ? 0 : reg, pic_reg,\n+\t\t\t\t       compute_now);\n \n       if (CONST_INT_P (offset))\n \t{\n@@ -8707,7 +8731,8 @@ arm_legitimize_address (rtx x, rtx orig_x, machine_mode mode)\n     {\n       /* We need to find and carefully transform any SYMBOL and LABEL\n \t references; so go back to the original address expression.  */\n-      rtx new_x = legitimize_pic_address (orig_x, mode, NULL_RTX);\n+      rtx new_x = legitimize_pic_address (orig_x, mode, NULL_RTX, NULL_RTX,\n+\t\t\t\t\t  false /*compute_now*/);\n \n       if (new_x != orig_x)\n \tx = new_x;\n@@ -8775,7 +8800,8 @@ thumb_legitimize_address (rtx x, rtx orig_x, machine_mode mode)\n     {\n       /* We need to find and carefully transform any SYMBOL and LABEL\n \t references; so go back to the original address expression.  */\n-      rtx new_x = legitimize_pic_address (orig_x, mode, NULL_RTX);\n+      rtx new_x = legitimize_pic_address (orig_x, mode, NULL_RTX, NULL_RTX,\n+\t\t\t\t\t  false /*compute_now*/);\n \n       if (new_x != orig_x)\n \tx = new_x;\n@@ -18059,7 +18085,7 @@ arm_emit_call_insn (rtx pat, rtx addr, bool sibcall)\n \t  ? !targetm.binds_local_p (SYMBOL_REF_DECL (addr))\n \t  : !SYMBOL_REF_LOCAL_P (addr)))\n     {\n-      require_pic_register ();\n+      require_pic_register (NULL_RTX, false /*compute_now*/);\n       use_reg (&CALL_INSN_FUNCTION_USAGE (insn), cfun->machine->pic_reg);\n     }\n "}, {"sha": "130531d4eb6aa44ddbafc044b752ddbbe11df388", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 91, "deletions": 1, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=39e4731c78f5d5b1def6c81a2a7bc1417c523480", "patch": "@@ -6021,7 +6021,8 @@\n       operands[1] = legitimize_pic_address (operands[1], SImode,\n \t\t\t\t\t    (!can_create_pseudo_p ()\n \t\t\t\t\t     ? operands[0]\n-\t\t\t\t\t     : 0));\n+\t\t\t\t\t     : NULL_RTX), NULL_RTX,\n+\t\t\t\t\t    false /*compute_now*/);\n   }\n   \"\n )\n@@ -8634,6 +8635,95 @@\n    (set_attr \"conds\" \"clob\")]\n )\n \n+;; Named patterns for stack smashing protection.\n+(define_insn_and_split \"stack_protect_combined_set\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+\t(unspec:SI [(match_operand:SI 1 \"memory_operand\" \"X\")]\n+\t\t   UNSPEC_SP_SET))\n+   (match_scratch:SI 2 \"=r\")\n+   (match_scratch:SI 3 \"=r\")]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (unspec:SI [(mem:SI (match_dup 2))]\n+\t\t\t\t\t    UNSPEC_SP_SET))\n+\t      (clobber (match_dup 2))])]\n+  \"\n+{\n+  rtx addr = XEXP (operands[1], 0);\n+  if (flag_pic)\n+    {\n+      /* Forces recomputing of GOT base now.  */\n+      operands[1] = legitimize_pic_address (addr, SImode, operands[2],\n+\t\t\t\t\t    operands[3], true /*compute_now*/);\n+    }\n+  else\n+    {\n+      if (!address_operand (addr, SImode))\n+\toperands[1] = force_const_mem (SImode, addr);\n+      emit_move_insn (operands[2], operands[1]);\n+    }\n+}\"\n+)\n+\n+(define_insn \"stack_protect_set\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+\t(unspec:SI [(mem:SI (match_operand:SI 1 \"register_operand\" \"r\"))]\n+\t UNSPEC_SP_SET))\n+   (clobber (match_dup 1))]\n+  \"\"\n+  \"ldr\\\\t%1, [%1]\\;str\\\\t%1, %0\\;mov\\t%1,0\"\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"type\" \"multiple\")])\n+\n+(define_insn_and_split \"stack_protect_combined_test\"\n+  [(set (pc)\n+\t(if_then_else\n+\t\t(eq (match_operand:SI 0 \"memory_operand\" \"m\")\n+\t\t    (unspec:SI [(match_operand:SI 1 \"memory_operand\" \"X\")]\n+\t\t\t       UNSPEC_SP_TEST))\n+\t\t(label_ref (match_operand 2))\n+\t\t(pc)))\n+   (match_scratch:SI 3 \"=r\")\n+   (match_scratch:SI 4 \"=r\")]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx eq, addr;\n+\n+  addr = XEXP (operands[1], 0);\n+  if (flag_pic)\n+    {\n+      /* Forces recomputing of GOT base now.  */\n+      operands[1] = legitimize_pic_address (addr, SImode, operands[3],\n+\t\t\t\t\t    operands[4],\n+\t\t\t\t\t    true /*compute_now*/);\n+    }\n+  else\n+    {\n+      if (!address_operand (addr, SImode))\n+\toperands[1] = force_const_mem (SImode, addr);\n+      emit_move_insn (operands[3], operands[1]);\n+    }\n+  emit_insn (gen_stack_protect_test (operands[4], operands[0], operands[3]));\n+  eq = gen_rtx_EQ (VOIDmode, operands[4], const0_rtx);\n+  emit_jump_insn (gen_cbranchsi4 (eq, operands[4], const0_rtx, operands[2]));\n+  DONE;\n+})\n+\n+(define_insn \"stack_protect_test\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"memory_operand\" \"m\")\n+\t\t    (mem:SI (match_operand:SI 2 \"register_operand\" \"r\"))]\n+\t UNSPEC_SP_TEST))\n+   (clobber (match_dup 2))]\n+  \"\"\n+  \"ldr\\t%0, [%2]\\;ldr\\t%2, %1\\;eor\\t%0, %2, %0\"\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"type\" \"multiple\")])\n+\n (define_expand \"casesi\"\n   [(match_operand:SI 0 \"s_register_operand\" \"\")\t; index to jump on\n    (match_operand:SI 1 \"const_int_operand\" \"\")\t; lower bound"}, {"sha": "8f9dbcb08dc2547375e2d5195fe5dbb4098aa29a", "filename": "gcc/config/arm/unspecs.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Fconfig%2Farm%2Funspecs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Fconfig%2Farm%2Funspecs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funspecs.md?ref=39e4731c78f5d5b1def6c81a2a7bc1417c523480", "patch": "@@ -86,6 +86,9 @@\n   UNSPEC_PROBE_STACK    ; Probe stack memory reference\n   UNSPEC_NONSECURE_MEM\t; Represent non-secure memory in ARMv8-M with\n \t\t\t; security extension\n+  UNSPEC_SP_SET\t\t; Represent the setting of stack protector's canary\n+  UNSPEC_SP_TEST\t; Represent the testing of stack protector's canary\n+\t\t\t; against the guard.\n ])\n \n (define_c_enum \"unspec\" ["}, {"sha": "e7935257783d39b638e9acbe42ee7ba3bfee16cb", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 47, "deletions": 8, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=39e4731c78f5d5b1def6c81a2a7bc1417c523480", "patch": "@@ -7377,22 +7377,61 @@ builtins.\n The get/set patterns have a single output/input operand respectively,\n with @var{mode} intended to be @code{Pmode}.\n \n+@cindex @code{stack_protect_combined_set} instruction pattern\n+@item @samp{stack_protect_combined_set}\n+This pattern, if defined, moves a @code{ptr_mode} value from an address\n+whose declaration RTX is given in operand 1 to the memory in operand 0\n+without leaving the value in a register afterward.  If several\n+instructions are needed by the target to perform the operation (eg. to\n+load the address from a GOT entry then load the @code{ptr_mode} value\n+and finally store it), it is the backend's responsibility to ensure no\n+intermediate result gets spilled.  This is to avoid leaking the value\n+some place that an attacker might use to rewrite the stack guard slot\n+after having clobbered it.\n+\n+If this pattern is not defined, then the address declaration is\n+expanded first in the standard way and a @code{stack_protect_set}\n+pattern is then generated to move the value from that address to the\n+address in operand 0.\n+\n @cindex @code{stack_protect_set} instruction pattern\n @item @samp{stack_protect_set}\n-This pattern, if defined, moves a @code{ptr_mode} value from the memory\n-in operand 1 to the memory in operand 0 without leaving the value in\n-a register afterward.  This is to avoid leaking the value some place\n-that an attacker might use to rewrite the stack guard slot after\n-having clobbered it.\n+This pattern, if defined, moves a @code{ptr_mode} value from the valid\n+memory location in operand 1 to the memory in operand 0 without leaving\n+the value in a register afterward.  This is to avoid leaking the value\n+some place that an attacker might use to rewrite the stack guard slot\n+after having clobbered it.\n+\n+Note: on targets where the addressing modes do not allow to load\n+directly from stack guard address, the address is expanded in a standard\n+way first which could cause some spills.\n \n If this pattern is not defined, then a plain move pattern is generated.\n \n+@cindex @code{stack_protect_combined_test} instruction pattern\n+@item @samp{stack_protect_combined_test}\n+This pattern, if defined, compares a @code{ptr_mode} value from an\n+address whose declaration RTX is given in operand 1 with the memory in\n+operand 0 without leaving the value in a register afterward and\n+branches to operand 2 if the values were equal.  If several\n+instructions are needed by the target to perform the operation (eg. to\n+load the address from a GOT entry then load the @code{ptr_mode} value\n+and finally store it), it is the backend's responsibility to ensure no\n+intermediate result gets spilled.  This is to avoid leaking the value\n+some place that an attacker might use to rewrite the stack guard slot\n+after having clobbered it.\n+\n+If this pattern is not defined, then the address declaration is\n+expanded first in the standard way and a @code{stack_protect_test}\n+pattern is then generated to compare the value from that address to the\n+value at the memory in operand 0.\n+\n @cindex @code{stack_protect_test} instruction pattern\n @item @samp{stack_protect_test}\n This pattern, if defined, compares a @code{ptr_mode} value from the\n-memory in operand 1 with the memory in operand 0 without leaving the\n-value in a register afterward and branches to operand 2 if the values\n-were equal.\n+valid memory location in operand 1 with the memory in operand 0 without\n+leaving the value in a register afterward and branches to operand 2 if\n+the values were equal.\n \n If this pattern is not defined, then a plain compare pattern and\n conditional branch pattern is used."}, {"sha": "a95d2f890cdee8f8b30dd7c6f80db47776c22394", "filename": "gcc/function.c", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=39e4731c78f5d5b1def6c81a2a7bc1417c523480", "patch": "@@ -4893,20 +4893,33 @@ stack_protect_epilogue (void)\n   rtx_code_label *label = gen_label_rtx ();\n   rtx x, y;\n   rtx_insn *seq;\n+  struct expand_operand ops[3];\n \n   x = expand_normal (crtl->stack_protect_guard);\n-  if (guard_decl)\n-    y = expand_normal (guard_decl);\n-  else\n-    y = const0_rtx;\n-\n-  /* Allow the target to compare Y with X without leaking either into\n-     a register.  */\n-  if (targetm.have_stack_protect_test ()\n-      && ((seq = targetm.gen_stack_protect_test (x, y, label)) != NULL_RTX))\n-    emit_insn (seq);\n-  else\n-    emit_cmp_and_jump_insns (x, y, EQ, NULL_RTX, ptr_mode, 1, label);\n+  create_fixed_operand (&ops[0], x);\n+  create_fixed_operand (&ops[1], DECL_RTL (guard_decl));\n+  create_fixed_operand (&ops[2], label);\n+  /* Allow the target to compute address of Y and compare it with X without\n+     leaking Y into a register.  This combined address + compare pattern allows\n+     the target to prevent spilling of any intermediate results by splitting\n+     it after register allocator.  */\n+  if (!maybe_expand_jump_insn (targetm.code_for_stack_protect_combined_test,\n+\t\t\t       3, ops))\n+    {\n+      if (guard_decl)\n+\ty = expand_normal (guard_decl);\n+      else\n+\ty = const0_rtx;\n+\n+      /* Allow the target to compare Y with X without leaking either into\n+\t a register.  */\n+      if (targetm.have_stack_protect_test ()\n+\t  && ((seq = targetm.gen_stack_protect_test (x, y, label))\n+\t      != NULL_RTX))\n+\temit_insn (seq);\n+      else\n+\temit_cmp_and_jump_insns (x, y, EQ, NULL_RTX, ptr_mode, 1, label);\n+    }\n \n   /* The noreturn predictor has been moved to the tree level.  The rtl-level\n      predictors estimate this branch about 20%, which isn't enough to get"}, {"sha": "d39889b35229f6dba6bc2f6161abecba9c0448cb", "filename": "gcc/target-insns.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Ftarget-insns.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Ftarget-insns.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-insns.def?ref=39e4731c78f5d5b1def6c81a2a7bc1417c523480", "patch": "@@ -96,7 +96,9 @@ DEF_TARGET_INSN (sibcall_value, (rtx x0, rtx x1, rtx opt2, rtx opt3,\n DEF_TARGET_INSN (simple_return, (void))\n DEF_TARGET_INSN (split_stack_prologue, (void))\n DEF_TARGET_INSN (split_stack_space_check, (rtx x0, rtx x1))\n+DEF_TARGET_INSN (stack_protect_combined_set, (rtx x0, rtx x1))\n DEF_TARGET_INSN (stack_protect_set, (rtx x0, rtx x1))\n+DEF_TARGET_INSN (stack_protect_combined_test, (rtx x0, rtx x1, rtx x2))\n DEF_TARGET_INSN (stack_protect_test, (rtx x0, rtx x1, rtx x2))\n DEF_TARGET_INSN (store_multiple, (rtx x0, rtx x1, rtx x2))\n DEF_TARGET_INSN (tablejump, (rtx x0, rtx x1))"}, {"sha": "a8da2ab8b246f7edaf2449be4341fbd23928216b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=39e4731c78f5d5b1def6c81a2a7bc1417c523480", "patch": "@@ -1,3 +1,8 @@\n+2018-08-02  Thomas Preud'homme  <thomas.preudhomme@linaro.org>\n+\n+\tPR target/85434\n+\t* gcc.target/arm/pr85434.c: New test.\n+\n 2018-08-01  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/86650"}, {"sha": "4143a861f7caffc2af5a57518674297dd4e9e1b6", "filename": "gcc/testsuite/gcc.target/arm/pr85434.c", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr85434.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39e4731c78f5d5b1def6c81a2a7bc1417c523480/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr85434.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr85434.c?ref=39e4731c78f5d5b1def6c81a2a7bc1417c523480", "patch": "@@ -0,0 +1,200 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target fstack_protector }*/\n+/* { dg-require-effective-target fpic }*/\n+/* { dg-additional-options \"-Os -fpic -fstack-protector-strong\" } */\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+\n+static const unsigned char base64_enc_map[64] =\n+{\n+    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\n+    'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n+    'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\n+    'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n+    'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\n+    'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7',\n+    '8', '9', '+', '/'\n+};\n+\n+#define BASE64_SIZE_T_MAX   ( (size_t) -1 ) /* SIZE_T_MAX is not standard */\n+\n+\n+void doSmth(void *x);\n+\n+#include <string.h>\n+\n+\n+void check(int n) {\n+  \n+    if (!(n % 2 && n % 3 && n % 5)) {\n+ __asm__  (   \"add    r8, r8, #1;\" );\n+    }\n+}\n+\n+uint32_t test(\n+  uint32_t a1,\n+  uint32_t a2,\n+  size_t a3,\n+  size_t a4,\n+  size_t a5,\n+  size_t a6)\n+{\n+  uint32_t nResult = 0;\n+  uint8_t* h = 0L;\n+  uint8_t X[128];\n+  uint8_t mac[64];\n+  size_t len;\n+\n+  doSmth(&a1);\n+  doSmth(&a2);\n+  doSmth(&a3);\n+  doSmth(&a4);\n+  doSmth(&a5);\n+  doSmth(&a6);\n+\n+  if (a1 && a2 && a3 && a4 && a5 && a6) {\n+    nResult = 1;\n+    h = (void*)X;\n+    len = sizeof(X);\n+    memset(X, a2, len);\n+    len -= 64;\n+    memcpy(mac ,X, len);\n+    *(h + len) = a6;\n+\n+    {\n+\n+\n+        unsigned char *dst = X;\n+        size_t dlen = a3;\n+        size_t *olen = &a6;\n+        const unsigned char *src = mac;\n+        size_t slen = a4;\n+    size_t i, n;\n+    int C1, C2, C3;\n+    unsigned char *p;\n+\n+    if( slen == 0 )\n+    {\n+        *olen = 0;\n+        return( 0 );\n+    }\n+\n+    n = slen / 3 + ( slen % 3 != 0 );\n+\n+    if( n > ( BASE64_SIZE_T_MAX - 1 ) / 4 )\n+    {\n+        *olen = BASE64_SIZE_T_MAX;\n+        return( 0 );\n+    }\n+\n+    n *= 4;\n+\n+    if( ( dlen < n + 1 ) || ( NULL == dst ) )\n+    {\n+        *olen = n + 1;\n+        return( 0 );\n+    }\n+\n+    n = ( slen / 3 ) * 3;\n+\n+    for( i = 0, p = dst; i < n; i += 3 )\n+    {\n+        C1 = *src++;\n+        C2 = *src++;\n+        C3 = *src++;\n+\n+        check(i);\n+\n+        *p++ = base64_enc_map[(C1 >> 2) & 0x3F];\n+        *p++ = base64_enc_map[(((C1 &  3) << 4) + (C2 >> 4)) & 0x3F];\n+        *p++ = base64_enc_map[(((C2 & 15) << 2) + (C3 >> 6)) & 0x3F];\n+        *p++ = base64_enc_map[C3 & 0x3F];\n+    }\n+\n+    if( i < slen )\n+    {\n+        C1 = *src++;\n+        C2 = ( ( i + 1 ) < slen ) ? *src++ : 0;\n+\n+        *p++ = base64_enc_map[(C1 >> 2) & 0x3F];\n+        *p++ = base64_enc_map[(((C1 & 3) << 4) + (C2 >> 4)) & 0x3F];\n+\n+        if( ( i + 1 ) < slen )\n+             *p++ = base64_enc_map[((C2 & 15) << 2) & 0x3F];\n+        else *p++ = '=';\n+\n+        *p++ = '=';\n+    }\n+\n+    *olen = p - dst;\n+    *p = 0;\n+\n+}\n+\n+  __asm__ (\"mov r8, %0;\" : \"=r\" ( nResult ));\n+  }\n+  else\n+  {\n+    nResult = 2;\n+  }\n+\n+  doSmth(X);\n+  doSmth(mac);\n+\n+\n+  return nResult;\n+}\n+\n+/* The pattern below catches sequences of instructions that were generated\n+   for ARM and Thumb-2 before the fix for this PR. They are of the form:\n+\n+   ldr     rX, <offset from sp or fp>\n+   <optional non ldr instructions>\n+   ldr     rY, <offset from sp or fp>\n+   ldr     rZ, [rX]\n+   <optional non ldr instructions>\n+   cmp     rY, rZ\n+   <optional non cmp instructions>\n+   bl      __stack_chk_fail\n+\n+   Ideally the optional block would check for the various rX, rY and rZ\n+   registers not being set but this is not possible due to back references\n+   being illegal in lookahead expression in Tcl, thus preventing to use the\n+   only construct that allow to negate a regexp from using the backreferences\n+   to those registers.  Instead we go for the heuristic of allowing non ldr/cmp\n+   instructions with the assumptions that (i) those are not part of the stack\n+   protector sequences and (ii) they would only be scheduled here if they don't\n+   conflict with registers used by stack protector.\n+\n+   Note on the regexp logic:\n+   Allowing non X instructions (where X is ldr or cmp) is done by looking for\n+   some non newline spaces, followed by something which is not X, followed by\n+   an alphanumeric character followed by anything but a newline and ended by a\n+   newline the whole thing an undetermined number of times. The alphanumeric\n+   character is there to force the match of the negative lookahead for X to\n+   only happen after all the initial spaces and thus to check the mnemonic.\n+   This prevents it to match one of the initial space.  */\n+/* { dg-final { scan-assembler-not {ldr[ \\t]+([^,]+), \\[(?:sp|fp)[^]]*\\](?:\\n[ \\t]+(?!ldr)\\w[^\\n]*)*\\n[ \\t]+ldr[ \\t]+([^,]+), \\[(?:sp|fp)[^]]*\\]\\n[ \\t]+ldr[ \\t]+([^,]+), \\[\\1\\](?:\\n[ \\t]+(?!ldr)\\w[^\\n]*)*\\n[ \\t]+cmp[ \\t]+\\2, \\3(?:\\n[ \\t]+(?!cmp)\\w[^\\n]*)*\\n[ \\t]+bl[ \\t]+__stack_chk_fail} } } */\n+\n+/* Likewise for Thumb-1 sequences of instructions prior to the fix for this PR\n+   which had the form:\n+\n+   ldr     rS, <offset from sp or fp>\n+   <optional non ldr instructions>\n+   ldr     rT, <PC relative offset>\n+   <optional non ldr instructions>\n+   ldr     rX, [rS, rT]\n+   <optional non ldr instructions>\n+   ldr     rY, <offset from sp or fp>\n+   ldr     rZ, [rX]\n+   <optional non ldr instructions>\n+   cmp     rY, rZ\n+   <optional non cmp instructions>\n+   bl      __stack_chk_fail\n+\n+  Note on the regexp logic:\n+  PC relative offset is checked by looking for a source operand that does not\n+  contain [ or ].  */\n+/* { dg-final { scan-assembler-not {ldr[ \\t]+([^,]+), \\[(?:sp|fp)[^]]*\\](?:\\n[ \\t]+(?!ldr)\\w[^\\n]*)*\\n[ \\t]+ldr[ \\t]+([^,]+), [^][\\n]*(?:\\n[ \\t]+(?!ldr)\\w[^\\n]*)*\\n[ \\t]+ldr[ \\t]+([^,]+), \\[\\1, \\2\\](?:\\n[ \\t]+(?!ldr)\\w[^\\n]*)*\\n[ \\t]+ldr[ \\t]+([^,]+), \\[(?:sp|fp)[^]]*\\]\\n[ \\t]+ldr[ \\t]+([^,]+), \\[\\3\\](?:\\n[ \\t]+(?!ldr)\\w[^\\n]*)*\\n[ \\t]+cmp[ \\t]+\\4, \\5(?:\\n[ \\t]+(?!cmp)\\w[^\\n]*)*\\n[ \\t]+bl[ \\t]+__stack_chk_fail} } } */"}]}