{"sha": "783f0cfc8d973c147a5243d7312b85e7ea892e1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgzZjBjZmM4ZDk3M2MxNDdhNTI0M2Q3MzEyYjg1ZTdlYTg5MmUxYw==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2013-09-17T17:46:03Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2013-09-17T17:46:03Z"}, "message": "re PR c++/58435 (Applying a type transformation to a list: const ignored)\n\n/cp\n2013-09-17  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/58435\n\t* pt.c (tsubst, [BOUND_TEMPLATE_TEMPLATE_PARM]): Take into account\n\tthe cp_type_quals (r) too.\n\n/testsuite\n2013-09-17  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/58435\n\t* g++.dg/cpp0x/alias-decl-38.C: New.\n\nFrom-SVN: r202662", "tree": {"sha": "63f2d508f3488858a5aded0da200a3c24d31513a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63f2d508f3488858a5aded0da200a3c24d31513a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/783f0cfc8d973c147a5243d7312b85e7ea892e1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/783f0cfc8d973c147a5243d7312b85e7ea892e1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/783f0cfc8d973c147a5243d7312b85e7ea892e1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/783f0cfc8d973c147a5243d7312b85e7ea892e1c/comments", "author": null, "committer": null, "parents": [{"sha": "b631d45ac3d9d53a648885ac6b88210da192ab37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b631d45ac3d9d53a648885ac6b88210da192ab37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b631d45ac3d9d53a648885ac6b88210da192ab37"}], "stats": {"total": 58, "additions": 56, "deletions": 2}, "files": [{"sha": "7e2c13beb5e6273738a2fa1bd05e53d91e3ac5e7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/783f0cfc8d973c147a5243d7312b85e7ea892e1c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/783f0cfc8d973c147a5243d7312b85e7ea892e1c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=783f0cfc8d973c147a5243d7312b85e7ea892e1c", "patch": "@@ -1,3 +1,9 @@\n+2013-09-17  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/58435\n+\t* pt.c (tsubst, [BOUND_TEMPLATE_TEMPLATE_PARM]): Take into account\n+\tthe cp_type_quals (r) too.\n+\n 2013-09-16  Adam Butcher  <adam@jessamine.co.uk>\n \n \t* cp-tree.h (type_uses_auto_or_concept): Declare.\n@@ -11,7 +17,8 @@\n \t(is_auto_or_concept): New function.\n \t(type_uses_auto_or_concept): New function.\n \t* parser.h (struct cp_parser): Add fully_implicit_function_template_p.\n-\t* parser.c (cp_parser_new): Initialize fully_implicit_function_template_p.\n+\t* parser.c (cp_parser_new): Initialize\n+\tfully_implicit_function_template_p.\n \t(cp_parser_new): Initialize fully_implicit_function_template_p.\n \t(cp_parser_lambda_expression): Copy and restore value of\n \tfully_implicit_function_template_p as per other parser fields."}, {"sha": "e0b71108fcf04fb5553d268c741cb1d2e1b73d95", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/783f0cfc8d973c147a5243d7312b85e7ea892e1c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/783f0cfc8d973c147a5243d7312b85e7ea892e1c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=783f0cfc8d973c147a5243d7312b85e7ea892e1c", "patch": "@@ -11540,7 +11540,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t\t\t\t    /*entering_scope=*/0,\n \t\t\t\t\t   complain);\n \t\treturn cp_build_qualified_type_real\n-\t\t  (r, cp_type_quals (t), complain);\n+\t\t  (r, cp_type_quals (t) | cp_type_quals (r), complain);\n \t      }\n \t    else\n \t      /* TEMPLATE_TEMPLATE_PARM or TEMPLATE_PARM_INDEX.  */"}, {"sha": "205dee8b01f5db204a4e84a88cb3abb584876551", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/783f0cfc8d973c147a5243d7312b85e7ea892e1c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/783f0cfc8d973c147a5243d7312b85e7ea892e1c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=783f0cfc8d973c147a5243d7312b85e7ea892e1c", "patch": "@@ -1,3 +1,9 @@\n+2013-09-17  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/58435\n+\t* pt.c (tsubst, [BOUND_TEMPLATE_TEMPLATE_PARM]): Take into account\n+\tthe cp_type_quals (r) too.\n+\n 2013-09-17  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/58332"}, {"sha": "bc98737b849f0b961c8c7f19308838c1f83635fb", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-38.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/783f0cfc8d973c147a5243d7312b85e7ea892e1c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-38.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/783f0cfc8d973c147a5243d7312b85e7ea892e1c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-38.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-38.C?ref=783f0cfc8d973c147a5243d7312b85e7ea892e1c", "patch": "@@ -0,0 +1,41 @@\n+// PR c++/58435\n+// { dg-do compile { target c++11 } }\n+\n+template<typename T, typename U>\n+struct same { static const bool value = false; };\n+template<typename T>\n+struct same<T, T> { static const bool value = true; };\n+\n+template <template <typename> class F, typename T> struct apply\n+{ typedef F<T> type; };\n+template <template <typename> class F, typename T> struct applyc\n+{ typedef const F<T> type; };\n+template <template <typename> class F, typename T> struct applyv\n+{ typedef volatile F<T> type; };\n+template <template <typename> class F, typename T> struct applycv\n+{ typedef const volatile F<T> type; };\n+\n+template <typename T> using map = T;\n+template <typename T> using mapc = const T;\n+template <typename T> using mapv = volatile T;\n+template <typename T> using mapcv = const volatile T;\n+\n+static_assert(same<apply<map, int>::type, int>::value, \"\");\n+static_assert(same<apply<mapc, int>::type, const int>::value, \"\");\n+static_assert(same<apply<mapv, int>::type, volatile int>::value, \"\");\n+static_assert(same<apply<mapcv, int>::type, const volatile int>::value, \"\");\n+\n+static_assert(same<applyc<map, int>::type, const int>::value, \"\");\n+static_assert(same<applyc<mapc, int>::type, const int>::value, \"\");\n+static_assert(same<applyc<mapv, int>::type, const volatile int>::value, \"\");\n+static_assert(same<applyc<mapcv, int>::type, const volatile int>::value, \"\");\n+\n+static_assert(same<applyv<map, int>::type, volatile int>::value, \"\");\n+static_assert(same<applyv<mapc, int>::type, const volatile int>::value, \"\");\n+static_assert(same<applyv<mapv, int>::type, volatile int>::value, \"\");\n+static_assert(same<applyv<mapcv, int>::type, const volatile int>::value, \"\");\n+\n+static_assert(same<applycv<map, int>::type, const volatile int>::value, \"\");\n+static_assert(same<applycv<mapc, int>::type, const volatile int>::value, \"\");\n+static_assert(same<applycv<mapv, int>::type, const volatile int>::value, \"\");\n+static_assert(same<applycv<mapcv, int>::type, const volatile int>::value, \"\");"}]}