{"sha": "d0b00e74bf59c73b79471bbe9de19373b8661e20", "node_id": "C_kwDOANBUbNoAKGQwYjAwZTc0YmY1OWM3M2I3OTQ3MWJiZTlkZTE5MzczYjg2NjFlMjA", "commit": {"author": {"name": "Indu Bhagat", "email": "indu.bhagat@oracle.com", "date": "2022-04-14T17:01:22Z"}, "committer": {"name": "Indu Bhagat", "email": "indu.bhagat@oracle.com", "date": "2022-04-14T17:03:52Z"}, "message": "CTF for extern variable fix [PR105089]\n\nThe CTF format cannot differentiate between a non-defining extern\nvariable declaration vs. a defining variable declaration (unlike DWARF).\nSo, the correct behaviour wrt the compiler generating CTF for such\nextern variables (i.e., when both the defining and non-defining decl\nare present in the same CU) is to simply emit the CTF variable\ncorrespoding to the defining declaration.\n\nTo carry out the above, following changes are introduced via the patch:\n\n1. The CTF container (ctfc.h) now keeps track of the non-defining declarations\n(by noting the DWARF attribute DW_AT_specification) in a new ctfc_ignore_vars\nhashtable.  Such book-keeping is necessary because the CTF container should\nnot rely on the order of DWARF DIEs presented to it at generation time.\n\n2. At the time of ctf_add_variable (), the DW_AT_specification DIE if present\nis added in the ctfc_ignore_vars hashtable.  The CTF variable generation for\nthe defining declaration continues as normal.\n\n3. If the ctf_add_variable () is asked to generate CTF variable for a DIE\npresent in the ctfc_ignore_vars, it skips generating CTF for it.\n\n4. Recall that CTF variables are pre-processed before emission.  Till now, the\nonly pre-processing that was being done was to sort them in order of their\nnames.  Now an additional step is added:  If the CTF variable which\ncorresponds to the non-defining declaration is indeed present in the ctfc_vars\nhashtable (because the corresponding DWARF DIE was encountered first by the\nCTF generation engine), skip that CTF variable from output.\n\nAn important side effect of such a workflow above is that CTF for the C type\nof the non-defining decl will remain in the CTF dictionary (and will be\nemitted in the output section as well).  This type can be pruned by the\nlink-time de-duplicator as usual, if deemed unused.\n\n2022-04-14  Indu Bhagat  <indu.bhagat@oracle.com>\n\ngcc/ChangeLog:\n\n\tPR debug/105089\n\t* ctfc.cc (ctf_dvd_ignore_insert): New function.\n\t(ctf_dvd_ignore_lookup): Likewise.\n\t(ctf_add_variable): Keep track of non-defining decl DIEs.\n\t(new_ctf_container): Initialize the new hash-table.\n\t(ctfc_delete_container): Empty hash-table.\n\t* ctfc.h (struct ctf_container): Add new hash-table.\n\t(ctf_dvd_ignore_lookup): New declaration.\n\t(ctf_add_variable): Add additional argument.\n\t* ctfout.cc (ctf_dvd_preprocess_cb): Skip adding CTF variable\n\trecord for non-defining decl for which a defining decl exists\n\tin the same TU.\n\t(ctf_preprocess): Defer updating the number of global objts\n\tuntil here.\n\t(output_ctf_header): Use ctfc_vars_list_count as some CTF\n\tvariables may not make it to the final output.\n\t(output_ctf_vars): Likewise.\n\t* dwarf2ctf.cc (gen_ctf_variable): Skip generating CTF variable\n\tif this is known to be a non-defining decl DIE.", "tree": {"sha": "44897017cd9f804e3d804144c0526bfcc5a24e28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44897017cd9f804e3d804144c0526bfcc5a24e28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0b00e74bf59c73b79471bbe9de19373b8661e20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0b00e74bf59c73b79471bbe9de19373b8661e20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0b00e74bf59c73b79471bbe9de19373b8661e20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0b00e74bf59c73b79471bbe9de19373b8661e20/comments", "author": {"login": "ibhagatgnu", "id": 51812649, "node_id": "MDQ6VXNlcjUxODEyNjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/51812649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibhagatgnu", "html_url": "https://github.com/ibhagatgnu", "followers_url": "https://api.github.com/users/ibhagatgnu/followers", "following_url": "https://api.github.com/users/ibhagatgnu/following{/other_user}", "gists_url": "https://api.github.com/users/ibhagatgnu/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibhagatgnu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibhagatgnu/subscriptions", "organizations_url": "https://api.github.com/users/ibhagatgnu/orgs", "repos_url": "https://api.github.com/users/ibhagatgnu/repos", "events_url": "https://api.github.com/users/ibhagatgnu/events{/privacy}", "received_events_url": "https://api.github.com/users/ibhagatgnu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibhagatgnu", "id": 51812649, "node_id": "MDQ6VXNlcjUxODEyNjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/51812649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibhagatgnu", "html_url": "https://github.com/ibhagatgnu", "followers_url": "https://api.github.com/users/ibhagatgnu/followers", "following_url": "https://api.github.com/users/ibhagatgnu/following{/other_user}", "gists_url": "https://api.github.com/users/ibhagatgnu/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibhagatgnu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibhagatgnu/subscriptions", "organizations_url": "https://api.github.com/users/ibhagatgnu/orgs", "repos_url": "https://api.github.com/users/ibhagatgnu/repos", "events_url": "https://api.github.com/users/ibhagatgnu/events{/privacy}", "received_events_url": "https://api.github.com/users/ibhagatgnu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "613a6fca75156aadc2e79d78a23e547d39762c1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/613a6fca75156aadc2e79d78a23e547d39762c1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/613a6fca75156aadc2e79d78a23e547d39762c1e"}], "stats": {"total": 110, "additions": 98, "deletions": 12}, "files": [{"sha": "f24e7bff94874c0643756019c9fb4a75fd3397f9", "filename": "gcc/ctfc.cc", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b00e74bf59c73b79471bbe9de19373b8661e20/gcc%2Fctfc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b00e74bf59c73b79471bbe9de19373b8661e20/gcc%2Fctfc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fctfc.cc?ref=d0b00e74bf59c73b79471bbe9de19373b8661e20", "patch": "@@ -179,6 +179,40 @@ ctf_dvd_lookup (const ctf_container_ref ctfc, dw_die_ref die)\n   return NULL;\n }\n \n+/* Insert a dummy CTF variable into the list of variables to be ignored.  */\n+\n+static void\n+ctf_dvd_ignore_insert (ctf_container_ref ctfc, ctf_dvdef_ref dvd)\n+{\n+  bool existed = false;\n+  ctf_dvdef_ref entry = dvd;\n+\n+  ctf_dvdef_ref * item = ctfc->ctfc_ignore_vars->find_slot (entry, INSERT);\n+  if (*item == NULL)\n+     *item = dvd;\n+  else\n+    existed = true;\n+  /* Duplicate variable records not expected to be inserted.  */\n+  gcc_assert (!existed);\n+}\n+\n+/* Lookup the dummy CTF variable given the DWARF die for the non-defining\n+   decl to be ignored.  */\n+\n+bool\n+ctf_dvd_ignore_lookup (const ctf_container_ref ctfc, dw_die_ref die)\n+{\n+  ctf_dvdef_t entry;\n+  entry.dvd_key = die;\n+\n+  ctf_dvdef_ref * slot = ctfc->ctfc_ignore_vars->find_slot (&entry, NO_INSERT);\n+\n+  if (slot)\n+    return true;\n+\n+  return false;\n+}\n+\n /* Append member definition to the list.  Member list is a singly-linked list\n    with list start pointing to the head.  */\n \n@@ -666,9 +700,10 @@ ctf_add_member_offset (ctf_container_ref ctfc, dw_die_ref sou,\n \n int\n ctf_add_variable (ctf_container_ref ctfc, const char * name, ctf_id_t ref,\n-\t\t  dw_die_ref die, unsigned int external_vis)\n+\t\t  dw_die_ref die, unsigned int external_vis,\n+\t\t  dw_die_ref die_var_decl)\n {\n-  ctf_dvdef_ref dvd;\n+  ctf_dvdef_ref dvd, dvd_ignore;\n \n   gcc_assert (name);\n \n@@ -680,6 +715,24 @@ ctf_add_variable (ctf_container_ref ctfc, const char * name, ctf_id_t ref,\n       dvd->dvd_name = ctf_add_string (ctfc, name, &(dvd->dvd_name_offset));\n       dvd->dvd_visibility = external_vis;\n       dvd->dvd_type = ref;\n+\n+      /* If DW_AT_specification attribute exists, keep track of it as this is\n+\t the non-defining declaration corresponding to the variable.  We will\n+\t skip emitting CTF variable for such incomplete, non-defining\n+\t declarations.\n+\t There could be some non-defining declarations, however, for which a\n+\t defining declaration does not show up in the same CU.  For such\n+\t cases, the compiler continues to emit CTF variable record as\n+\t usual.  */\n+      if (die_var_decl)\n+\t{\n+\t  dvd_ignore = ggc_cleared_alloc<ctf_dvdef_t> ();\n+\t  dvd_ignore->dvd_key = die_var_decl;\n+\t  /* It's alright to leave other fields as zero.  No valid CTF\n+\t     variable will be added for these DW_TAG_variable DIEs.  */\n+\t  ctf_dvd_ignore_insert (ctfc, dvd_ignore);\n+\t}\n+\n       ctf_dvd_insert (ctfc, dvd);\n \n       if (strcmp (name, \"\"))\n@@ -900,6 +953,8 @@ new_ctf_container (void)\n     = hash_table<ctfc_dtd_hasher>::create_ggc (100);\n   tu_ctfc->ctfc_vars\n     = hash_table<ctfc_dvd_hasher>::create_ggc (100);\n+  tu_ctfc->ctfc_ignore_vars\n+    = hash_table<ctfc_dvd_hasher>::create_ggc (10);\n \n   return tu_ctfc;\n }\n@@ -952,6 +1007,9 @@ ctfc_delete_container (ctf_container_ref ctfc)\n       ctfc->ctfc_vars->empty ();\n       ctfc->ctfc_types = NULL;\n \n+      ctfc->ctfc_ignore_vars->empty ();\n+      ctfc->ctfc_ignore_vars = NULL;\n+\n       ctfc_delete_strtab (&ctfc->ctfc_strtable);\n       ctfc_delete_strtab (&ctfc->ctfc_aux_strtable);\n       if (ctfc->ctfc_vars_list)"}, {"sha": "001e544ef083a318ab92c3657437abde95f1e0b5", "filename": "gcc/ctfc.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b00e74bf59c73b79471bbe9de19373b8661e20/gcc%2Fctfc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b00e74bf59c73b79471bbe9de19373b8661e20/gcc%2Fctfc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fctfc.h?ref=d0b00e74bf59c73b79471bbe9de19373b8661e20", "patch": "@@ -274,6 +274,8 @@ typedef struct GTY (()) ctf_container\n   hash_table <ctfc_dtd_hasher> * GTY (()) ctfc_types;\n   /* CTF variables.  */\n   hash_table <ctfc_dvd_hasher> * GTY (()) ctfc_vars;\n+  /* CTF variables to be ignored.  */\n+  hash_table <ctfc_dvd_hasher> * GTY (()) ctfc_ignore_vars;\n \n   /* CTF string table.  */\n   ctf_strtable_t ctfc_strtable;\n@@ -394,6 +396,8 @@ extern ctf_dtdef_ref ctf_dtd_lookup (const ctf_container_ref ctfc,\n \t\t\t\t     dw_die_ref die);\n extern ctf_dvdef_ref ctf_dvd_lookup (const ctf_container_ref ctfc,\n \t\t\t\t     dw_die_ref die);\n+extern bool ctf_dvd_ignore_lookup (const ctf_container_ref ctfc,\n+\t\t\t\t   dw_die_ref die);\n \n extern const char * ctf_add_string (ctf_container_ref, const char *,\n \t\t\t\t    uint32_t *, int);\n@@ -430,7 +434,7 @@ extern int ctf_add_member_offset (ctf_container_ref, dw_die_ref, const char *,\n extern int ctf_add_function_arg (ctf_container_ref, dw_die_ref,\n \t\t\t\t const char *, ctf_id_t);\n extern int ctf_add_variable (ctf_container_ref, const char *, ctf_id_t,\n-\t\t\t     dw_die_ref, unsigned int);\n+\t\t\t     dw_die_ref, unsigned int, dw_die_ref);\n \n extern ctf_id_t ctf_lookup_tree_type (ctf_container_ref, const tree);\n extern ctf_id_t get_btf_id (ctf_id_t);"}, {"sha": "3cf89b94f993b08c053b6a2df5141e02ac75ec7c", "filename": "gcc/ctfout.cc", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b00e74bf59c73b79471bbe9de19373b8661e20/gcc%2Fctfout.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b00e74bf59c73b79471bbe9de19373b8661e20/gcc%2Fctfout.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fctfout.cc?ref=d0b00e74bf59c73b79471bbe9de19373b8661e20", "patch": "@@ -212,6 +212,13 @@ ctf_dvd_preprocess_cb (ctf_dvdef_ref * slot, void * arg)\n   ctf_dvdef_ref var = (ctf_dvdef_ref) *slot;\n   ctf_container_ref arg_ctfc = dvd_arg->dvd_arg_ctfc;\n \n+  /* If the CTF variable corresponds to an extern variable declaration with\n+     a defining declaration later on, skip it.  Only CTF variable\n+     corresponding to the defining declaration for the extern variable is\n+     desirable.  */\n+  if (ctf_dvd_ignore_lookup (arg_ctfc, var->dvd_key))\n+    return 1;\n+\n   ctf_preprocess_var (arg_ctfc, var);\n \n   /* Keep track of global objts.  */\n@@ -276,16 +283,16 @@ static void\n ctf_preprocess (ctf_container_ref ctfc)\n {\n   size_t num_ctf_types = ctfc->ctfc_types->elements ();\n+  size_t num_ctf_vars = ctfc_get_num_ctf_vars (ctfc);\n \n   /* Initialize an array to keep track of the CTF variables at global\n-     scope.  */\n-  size_t num_global_objts = ctfc->ctfc_num_global_objts;\n+     scope.  At this time, size it conservatively.  */\n+  size_t num_global_objts = num_ctf_vars;\n   if (num_global_objts)\n     {\n       ctfc->ctfc_gobjts_list = ggc_vec_alloc<ctf_dvdef_t*>(num_global_objts);\n     }\n \n-  size_t num_ctf_vars = ctfc_get_num_ctf_vars (ctfc);\n   if (num_ctf_vars)\n     {\n       ctf_dvd_preprocess_arg_t dvd_arg;\n@@ -299,8 +306,11 @@ ctf_preprocess (ctf_container_ref ctfc)\n \t list for sorting.  */\n       ctfc->ctfc_vars->traverse<void *, ctf_dvd_preprocess_cb> (&dvd_arg);\n       /* Sort the list.  */\n-      qsort (ctfc->ctfc_vars_list, num_ctf_vars, sizeof (ctf_dvdef_ref),\n-\t     ctf_varent_compare);\n+      qsort (ctfc->ctfc_vars_list, ctfc->ctfc_vars_list_count,\n+\t     sizeof (ctf_dvdef_ref), ctf_varent_compare);\n+      /* Update the actual number of the generated CTF variables at global\n+\t scope.  */\n+      ctfc->ctfc_num_global_objts = dvd_arg.dvd_global_obj_idx;\n     }\n \n   /* Initialize an array to keep track of the CTF functions types for global\n@@ -476,7 +486,7 @@ output_ctf_header (ctf_container_ref ctfc)\n       /* Vars appear after function index.  */\n       varoff = funcidxoff + ctfc->ctfc_num_global_funcs * sizeof (uint32_t);\n       /* CTF types appear after vars.  */\n-      typeoff = varoff + ctfc_get_num_ctf_vars (ctfc) * sizeof (ctf_varent_t);\n+      typeoff = varoff + (ctfc->ctfc_vars_list_count) * sizeof (ctf_varent_t);\n       /* The total number of bytes for CTF types is the sum of the number of\n \t times struct ctf_type_t, struct ctf_stype_t are written, plus the\n \t amount of variable length data after each one of these.  */\n@@ -595,7 +605,7 @@ static void\n output_ctf_vars (ctf_container_ref ctfc)\n {\n   size_t i;\n-  size_t num_ctf_vars = ctfc_get_num_ctf_vars (ctfc);\n+  unsigned int num_ctf_vars = ctfc->ctfc_vars_list_count;\n   if (num_ctf_vars)\n     {\n       /* Iterate over the list of sorted vars and output the asm.  */"}, {"sha": "a6329ab6ee48ad9bb149b394d67aa2701500958c", "filename": "gcc/dwarf2ctf.cc", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b00e74bf59c73b79471bbe9de19373b8661e20/gcc%2Fdwarf2ctf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b00e74bf59c73b79471bbe9de19373b8661e20/gcc%2Fdwarf2ctf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2ctf.cc?ref=d0b00e74bf59c73b79471bbe9de19373b8661e20", "patch": "@@ -808,12 +808,26 @@ gen_ctf_variable (ctf_container_ref ctfc, dw_die_ref die)\n   if (ctf_dvd_lookup (ctfc, die))\n     return;\n \n+  /* Do not generate CTF variable records for non-defining incomplete\n+     declarations.  Such declarations can be known via the DWARF\n+     DW_AT_specification attribute.  */\n+  if (ctf_dvd_ignore_lookup (ctfc, die))\n+    return;\n+\n+  /* The value of the DW_AT_specification attribute, if present, is a\n+     reference to the debugging information entry representing the\n+     non-defining declaration.  */\n+  dw_die_ref decl = get_AT_ref (die, DW_AT_specification);\n+\n   /* Add the type of the variable.  */\n   var_type_id = gen_ctf_type (ctfc, var_type);\n \n   /* Generate the new CTF variable and update global counter.  */\n-  (void) ctf_add_variable (ctfc, var_name, var_type_id, die, external_vis);\n-  ctfc->ctfc_num_global_objts += 1;\n+  (void) ctf_add_variable (ctfc, var_name, var_type_id, die, external_vis,\n+\t\t\t   decl);\n+  /* Skip updating the number of global objects at this time.  This is updated\n+     later after pre-processing as some CTF variable records although\n+     generated now, will not be emitted later.  [PR105089].  */\n }\n \n /* Add a CTF function record for the given input DWARF DIE.  */"}]}