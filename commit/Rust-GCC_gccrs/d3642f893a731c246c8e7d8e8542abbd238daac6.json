{"sha": "d3642f893a731c246c8e7d8e8542abbd238daac6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM2NDJmODkzYTczMWMyNDZjOGU3ZDhlODU0MmFiYmQyMzhkYWFjNg==", "commit": {"author": {"name": "Feng Wang", "email": "fengwang@nudt.edu.cn", "date": "2005-07-07T07:54:58Z"}, "committer": {"name": "Feng Wang", "email": "fengwang@gcc.gnu.org", "date": "2005-07-07T07:54:58Z"}, "message": "For the 60th anniversary of Chinese people\ufffd\ufffds Anti-Japan war victory.\n\n2005-07-07  Feng Wang  <fengwang@nudt.edu.cn>\n\n\tPR fortran/16531\n\tPR fortran/15966\n\tPR fortran/18781\n\t* arith.c (gfc_hollerith2int, gfc_hollerith2real,\n\tgfc_hollerith2complex, gfc_hollerith2character, gfc_hollerith2logical):\n\tNew functions.\n\t(eval_intrinsic): Don't evaluate if Hollerith constant arguments exist.\n\t* arith.h (gfc_hollerith2int, gfc_hollerith2real,\n\tgfc_hollerith2complex, gfc_hollerith2character, gfc_hollerith2logical):\n\tAdd prototypes.\n\t* expr.c (free_expr0): Free memery allocated for Hollerith constant.\n\t(gfc_copy_expr): Allocate and copy string if Expr is from Hollerith.\n\t(gfc_check_assign): Enable conversion from Hollerith to other.\n\t* gfortran.h (bt): Add BT_HOLLERITH.\n\t(gfc_expr): Add from_H flag.\n\t* intrinsic.c (gfc_type_letter): Return 'h' for BT_HOLLERITH.\n\t(add_conversions): Add conversions from Hollerith constant to other.\n\t(do_simplify): Don't simplify if  Hollerith constant arguments exist.\n\t* io.c (resolve_tag): Enable array in FORMAT tag under GFC_STD_GNU.\n\t* misc.c (gfc_basetype_name): Return \"HOLLERITH\" for BT_HOLLERITH.\n\t(gfc_type_name): Print \"HOLLERITH\" for BT_HOLLERITH.\n\t* primary.c (match_hollerith_constant): New function.\n\t(gfc_match_literal_constant): Add match Hollerith before Integer.\n\t* simplify.c (gfc_convert_constant): Add conversion from Hollerith\n\tto other.\n\t* trans-const.c (gfc_conv_constant_to_tree): Use VIEW_CONVERT_EXPR to\n\tconvert Hollerith constant to tree.\n\t* trans-io.c (gfc_convert_array_to_string): Get array's address and\n\tlength to set string expr.\n\t(set_string): Deal with array assigned Hollerith constant and character\n\tarray.\n\t* gfortran.texi: Document Hollerith constants as extention support.\n\n2005-07-07  Feng Wang  <fengwang@nudt.edu.cn>\n\n\tPR fortran/16531\n\tPR fortran/15966\n\tPR fortran/18781\n\t* gfortran.dg/hollerith.f90: New.\n\t* gfortran.dg/hollerith2.f90: New.\n\t* gfortran.dg/hollerith3.f90: New.\n\t* gfortran.dg/hollerith4.f90: New.\n\t* gfortran.dg/hollerith_f95.f90: New.\n\t* gfortran.dg/hollerith_legacy.f90: New.\n\t* gfortran.dg/g77/cpp4.F: New. Port from g77.\n\n2005-07-07  Feng Wang  <fengwang@nudt.edu.cn>\n\n\tPR fortran/16531\n\t* io/transfer.c (formatted_transfer): Enable FMT_A on other types to\n\tsupport Hollerith constants.\n\nFrom-SVN: r101688", "tree": {"sha": "7bfda0a20b79d65d1ac562cb286d5799c84e43db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bfda0a20b79d65d1ac562cb286d5799c84e43db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3642f893a731c246c8e7d8e8542abbd238daac6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3642f893a731c246c8e7d8e8542abbd238daac6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3642f893a731c246c8e7d8e8542abbd238daac6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3642f893a731c246c8e7d8e8542abbd238daac6/comments", "author": null, "committer": null, "parents": [{"sha": "378f73afe05d3dbce185f9ab74f0c24e53f4b218", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/378f73afe05d3dbce185f9ab74f0c24e53f4b218", "html_url": "https://github.com/Rust-GCC/gccrs/commit/378f73afe05d3dbce185f9ab74f0c24e53f4b218"}], "stats": {"total": 905, "additions": 863, "deletions": 42}, "files": [{"sha": "4443f336446bad9ad1d7557e02843dda2a30d719", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 166, "deletions": 8, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -1582,17 +1582,19 @@ eval_intrinsic (gfc_intrinsic_op operator,\n   if (operator == INTRINSIC_POWER && op2->ts.type != BT_INTEGER)\n     goto runtime;\n \n-  if (op1->expr_type != EXPR_CONSTANT\n-      && (op1->expr_type != EXPR_ARRAY\n-\t  || !gfc_is_constant_expr (op1)\n-\t  || !gfc_expanded_ac (op1)))\n+  if (op1->from_H\n+      || (op1->expr_type != EXPR_CONSTANT\n+\t  && (op1->expr_type != EXPR_ARRAY\n+\t    || !gfc_is_constant_expr (op1)\n+\t    || !gfc_expanded_ac (op1))))\n     goto runtime;\n \n   if (op2 != NULL\n-      && op2->expr_type != EXPR_CONSTANT\n-      && (op2->expr_type != EXPR_ARRAY\n-\t  || !gfc_is_constant_expr (op2)\n-\t  || !gfc_expanded_ac (op2)))\n+      && (op2->from_H\n+\t|| (op2->expr_type != EXPR_CONSTANT\n+\t  && (op2->expr_type != EXPR_ARRAY\n+\t    || !gfc_is_constant_expr (op2)\n+\t    || !gfc_expanded_ac (op2)))))\n     goto runtime;\n \n   if (unary)\n@@ -2214,3 +2216,159 @@ gfc_int2log (gfc_expr *src, int kind)\n   return result;\n }\n \n+/* Convert Hollerith to integer. The constant will be padded or truncated.  */\n+\n+gfc_expr *\n+gfc_hollerith2int (gfc_expr * src, int kind)\n+{\n+  gfc_expr *result;\n+  int len;\n+\n+  len = src->value.character.length;\n+\n+  result = gfc_get_expr ();\n+  result->expr_type = EXPR_CONSTANT;\n+  result->ts.type = BT_INTEGER;\n+  result->ts.kind = kind;\n+  result->where = src->where;\n+  result->from_H = 1;\n+\n+  if (len > kind)\n+    {\n+      gfc_warning (\"The Hollerith constant at %L is too long to convert to %s\",\n+\t\t&src->where, gfc_typename(&result->ts));\n+    }\n+  result->value.character.string = gfc_getmem (kind + 1);\n+  memcpy (result->value.character.string, src->value.character.string,\n+\tMIN (kind, len));\n+\n+  if (len < kind)\n+    memset (&result->value.character.string[len], ' ', kind - len);\n+\n+  result->value.character.string[kind] = '\\0'; /* For debugger */\n+  result->value.character.length = kind;\n+\n+  return result;\n+}\n+\n+/* Convert Hollerith to real. The constant will be padded or truncated.  */\n+\n+gfc_expr *\n+gfc_hollerith2real (gfc_expr * src, int kind)\n+{\n+  gfc_expr *result;\n+  int len;\n+\n+  len = src->value.character.length;\n+\n+  result = gfc_get_expr ();\n+  result->expr_type = EXPR_CONSTANT;\n+  result->ts.type = BT_REAL;\n+  result->ts.kind = kind;\n+  result->where = src->where;\n+  result->from_H = 1;\n+\n+  if (len > kind)\n+    {\n+      gfc_warning (\"The Hollerith constant at %L is too long to convert to %s\",\n+\t\t&src->where, gfc_typename(&result->ts));\n+    }\n+  result->value.character.string = gfc_getmem (kind + 1);\n+  memcpy (result->value.character.string, src->value.character.string,\n+\tMIN (kind, len));\n+\n+  if (len < kind)\n+    memset (&result->value.character.string[len], ' ', kind - len);\n+\n+  result->value.character.string[kind] = '\\0'; /* For debugger */\n+  result->value.character.length = kind;\n+\n+  return result;\n+}\n+\n+/* Convert Hollerith to complex. The constant will be padded or truncated.  */\n+\n+gfc_expr *\n+gfc_hollerith2complex (gfc_expr * src, int kind)\n+{\n+  gfc_expr *result;\n+  int len;\n+\n+  len = src->value.character.length;\n+\n+  result = gfc_get_expr ();\n+  result->expr_type = EXPR_CONSTANT;\n+  result->ts.type = BT_COMPLEX;\n+  result->ts.kind = kind;\n+  result->where = src->where;\n+  result->from_H = 1;\n+\n+  kind = kind * 2;\n+\n+  if (len > kind)\n+    {\n+      gfc_warning (\"The Hollerith constant at %L is too long to convert to %s\",\n+\t\t&src->where, gfc_typename(&result->ts));\n+    }\n+  result->value.character.string = gfc_getmem (kind + 1);\n+  memcpy (result->value.character.string, src->value.character.string,\n+\tMIN (kind, len));\n+\n+  if (len < kind)\n+    memset (&result->value.character.string[len], ' ', kind - len);\n+\n+  result->value.character.string[kind] = '\\0'; /* For debugger */\n+  result->value.character.length = kind;\n+\n+  return result;\n+}\n+\n+/* Convert Hollerith to character. */\n+\n+gfc_expr *\n+gfc_hollerith2character (gfc_expr * src, int kind)\n+{\n+  gfc_expr *result;\n+\n+  result = gfc_copy_expr (src);\n+  result->ts.type = BT_CHARACTER;\n+  result->ts.kind = kind;\n+  result->from_H = 1;\n+\n+  return result;\n+}\n+\n+/* Convert Hollerith to logical. The constant will be padded or truncated.  */\n+\n+gfc_expr *\n+gfc_hollerith2logical (gfc_expr * src, int kind)\n+{\n+  gfc_expr *result;\n+  int len;\n+\n+  len = src->value.character.length;\n+\n+  result = gfc_get_expr ();\n+  result->expr_type = EXPR_CONSTANT;\n+  result->ts.type = BT_LOGICAL;\n+  result->ts.kind = kind;\n+  result->where = src->where;\n+  result->from_H = 1;\n+\n+  if (len > kind)\n+    {\n+      gfc_warning (\"The Hollerith constant at %L is too long to convert to %s\",\n+\t\t&src->where, gfc_typename(&result->ts));\n+    }\n+  result->value.character.string = gfc_getmem (kind + 1);\n+  memcpy (result->value.character.string, src->value.character.string,\n+\tMIN (kind, len));\n+\n+  if (len < kind)\n+    memset (&result->value.character.string[len], ' ', kind - len);\n+\n+  result->value.character.string[kind] = '\\0'; /* For debugger */\n+  result->value.character.length = kind;\n+\n+  return result;\n+}"}, {"sha": "385fbff2a8642bed01bd19cd63059ce811660e0c", "filename": "gcc/fortran/arith.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Farith.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Farith.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.h?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -82,6 +82,11 @@ gfc_expr *gfc_complex2complex (gfc_expr *, int);\n gfc_expr *gfc_log2log (gfc_expr *, int);\n gfc_expr *gfc_log2int (gfc_expr *, int);\n gfc_expr *gfc_int2log (gfc_expr *, int);\n+gfc_expr *gfc_hollerith2int (gfc_expr *, int);\n+gfc_expr *gfc_hollerith2real (gfc_expr *, int);\n+gfc_expr *gfc_hollerith2complex (gfc_expr *, int);\n+gfc_expr *gfc_hollerith2character (gfc_expr *, int);\n+gfc_expr *gfc_hollerith2logical (gfc_expr *, int);\n \n #endif /* GFC_ARITH_H  */\n "}, {"sha": "a3a24b59f408273d0a98465773c1629eeb9a00aa", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -141,6 +141,12 @@ free_expr0 (gfc_expr * e)\n   switch (e->expr_type)\n     {\n     case EXPR_CONSTANT:\n+      if (e->from_H)\n+\t{\n+\t  gfc_free (e->value.character.string);\n+\t  break;\n+\t}\n+\n       switch (e->ts.type)\n \t{\n \tcase BT_INTEGER:\n@@ -152,6 +158,7 @@ free_expr0 (gfc_expr * e)\n \t  break;\n \n \tcase BT_CHARACTER:\n+\tcase BT_HOLLERITH:\n \t  gfc_free (e->value.character.string);\n \t  break;\n \n@@ -393,6 +400,15 @@ gfc_copy_expr (gfc_expr * p)\n       break;\n \n     case EXPR_CONSTANT:\n+      if (p->from_H)\n+\t{\n+\t  s = gfc_getmem (p->value.character.length + 1);\n+\t  q->value.character.string = s;\n+\n+\t  memcpy (s, p->value.character.string,\n+\t\t  p->value.character.length + 1);\n+\t  break;\n+\t}\n       switch (q->ts.type)\n \t{\n \tcase BT_INTEGER:\n@@ -414,6 +430,7 @@ gfc_copy_expr (gfc_expr * p)\n \t  break;\n \n \tcase BT_CHARACTER:\n+\tcase BT_HOLLERITH:\n \t  s = gfc_getmem (p->value.character.length + 1);\n \t  q->value.character.string = s;\n \n@@ -1813,7 +1830,10 @@ gfc_check_assign (gfc_expr * lvalue, gfc_expr * rvalue, int conform)\n \n   if (!conform)\n     {\n-      if (gfc_numeric_ts (&lvalue->ts) && gfc_numeric_ts (&rvalue->ts))\n+      /* Numeric can be converted to any other numeric. And Hollerith can be\n+\t converted to any other type.  */\n+      if ((gfc_numeric_ts (&lvalue->ts) && gfc_numeric_ts (&rvalue->ts))\n+\t  || rvalue->ts.type == BT_HOLLERITH)\n \treturn SUCCESS;\n \n       if (lvalue->ts.type == BT_LOGICAL && rvalue->ts.type == BT_LOGICAL)"}, {"sha": "71b6c19b9325416980340e6784dbac16a0344094", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -127,7 +127,7 @@ gfc_source_form;\n \n typedef enum\n { BT_UNKNOWN = 1, BT_INTEGER, BT_REAL, BT_COMPLEX,\n-  BT_LOGICAL, BT_CHARACTER, BT_DERIVED, BT_PROCEDURE\n+  BT_LOGICAL, BT_CHARACTER, BT_DERIVED, BT_PROCEDURE, BT_HOLLERITH\n }\n bt;\n \n@@ -1077,6 +1077,9 @@ typedef struct gfc_expr\n \n   locus where;\n \n+  /* True if it is converted from Hollerith constant.  */\n+  unsigned int from_H : 1;\n+\n   union\n   {\n     int logical;"}, {"sha": "67d95df2f3a1a773ad896887c6ce106b80ece5a7", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -79,6 +79,10 @@ gfc_type_letter (bt type)\n       c = 'c';\n       break;\n \n+    case BT_HOLLERITH:\n+      c = 'h';\n+      break;\n+\n     default:\n       c = 'u';\n       break;\n@@ -2327,6 +2331,31 @@ add_conversions (void)\n \t\t  BT_INTEGER, gfc_integer_kinds[i].kind, GFC_STD_F77);\n       }\n \n+  if ((gfc_option.allow_std & GFC_STD_LEGACY) != 0)\n+    {\n+      /* Hollerith-Integer conversions.  */\n+      for (i = 0; gfc_integer_kinds[i].kind != 0; i++)\n+\tadd_conv (BT_HOLLERITH, gfc_default_character_kind,\n+\t\t  BT_INTEGER, gfc_integer_kinds[i].kind, GFC_STD_LEGACY);\n+      /* Hollerith-Real conversions.  */\n+      for (i = 0; gfc_real_kinds[i].kind != 0; i++)\n+\tadd_conv (BT_HOLLERITH, gfc_default_character_kind,\n+\t\t  BT_REAL, gfc_real_kinds[i].kind, GFC_STD_LEGACY);\n+      /* Hollerith-Complex conversions.  */\n+      for (i = 0; gfc_real_kinds[i].kind != 0; i++)\n+\tadd_conv (BT_HOLLERITH, gfc_default_character_kind,\n+\t\t  BT_COMPLEX, gfc_real_kinds[i].kind, GFC_STD_LEGACY);\n+\n+      /* Hollerith-Character conversions.  */\n+      add_conv (BT_HOLLERITH, gfc_default_character_kind, BT_CHARACTER,\n+\t\t  gfc_default_character_kind, GFC_STD_LEGACY);\n+\n+      /* Hollerith-Logical conversions.  */\n+      for (i = 0; gfc_logical_kinds[i].kind != 0; i++)\n+\tadd_conv (BT_HOLLERITH, gfc_default_character_kind,\n+\t\t  BT_LOGICAL, gfc_logical_kinds[i].kind, GFC_STD_LEGACY);\n+    }\n+\n   /* Real/Complex - Real/Complex conversions.  */\n   for (i = 0; gfc_real_kinds[i].kind != 0; i++)\n     for (j = 0; gfc_real_kinds[j].kind != 0; j++)\n@@ -2713,6 +2742,16 @@ do_simplify (gfc_intrinsic_sym * specific, gfc_expr * e)\n   gfc_expr *result, *a1, *a2, *a3, *a4, *a5;\n   gfc_actual_arglist *arg;\n \n+  /* Check the arguments if there are Hollerith constants. We deal with\n+     them at run-time.  */\n+  for (arg = e->value.function.actual; arg != NULL; arg = arg->next)\n+    {\n+      if (arg->expr && arg->expr->from_H)\n+\t{\n+\t  result = NULL;\n+\t  goto finish;\n+\t}\n+    }\n   /* Max and min require special handling due to the variable number\n      of args.  */\n   if (specific->simplify.f1 == gfc_simplify_min)"}, {"sha": "abfeead2f50a840d37b54372c374f160db1e5797", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 49, "deletions": 19, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -969,33 +969,63 @@ resolve_tag (const io_tag * tag, gfc_expr * e)\n   if (gfc_resolve_expr (e) == FAILURE)\n     return FAILURE;\n \n-  if (e->ts.type != tag->type)\n+  if (e->ts.type != tag->type && tag != &tag_format)\n     {\n-      /* Format label can be integer varibale.  */\n-      if (tag != &tag_format || e->ts.type != BT_INTEGER)\n-        {\n-          gfc_error (\"%s tag at %L must be of type %s or %s\", tag->name,\n-\t\t&e->where, gfc_basic_typename (tag->type),\n-\t\tgfc_basic_typename (BT_INTEGER));\n-          return FAILURE;\n-        }\n+      gfc_error (\"%s tag at %L must be of type %s\", tag->name,\n+\t\t&e->where, gfc_basic_typename (tag->type));\n+      return FAILURE;\n     }\n \n   if (tag == &tag_format)\n     {\n-      if (e->rank != 1 && e->rank != 0)\n+      /* If e's rank is zero and e is not an element of an array, it should be\n+\t of integer or character type.  The integer variable should be\n+\t ASSIGNED.  */\n+      if (e->symtree == NULL || e->symtree->n.sym->as == NULL\n+\t\t|| e->symtree->n.sym->as->rank == 0)\n \t{\n-\t  gfc_error (\"FORMAT tag at %L cannot be array of strings\",\n-\t\t     &e->where);\n-\t  return FAILURE;\n+\t  if (e->ts.type != BT_CHARACTER && e->ts.type != BT_INTEGER)\n+\t    {\n+\t      gfc_error (\"%s tag at %L must be of type %s or %s\", tag->name,\n+\t\t\t&e->where, gfc_basic_typename (BT_CHARACTER),\n+\t\t\tgfc_basic_typename (BT_INTEGER));\n+\t      return FAILURE;\n+\t    }\n+\t  else if (e->ts.type == BT_INTEGER && e->expr_type == EXPR_VARIABLE)\n+\t    {\n+\t      if (gfc_notify_std (GFC_STD_F95_DEL,\n+\t\t\t\"Obsolete: ASSIGNED variable in FORMAT tag at %L\",\n+\t\t\t&e->where) == FAILURE)\n+\t\treturn FAILURE;\n+\t      if (e->symtree->n.sym->attr.assign != 1)\n+\t\t{\n+\t\t  gfc_error (\"Variable '%s' at %L has not been assigned a \"\n+\t\t\t\"format label\", e->symtree->n.sym->name, &e->where);\n+\t\t  return FAILURE;\n+\t\t}\n+\t    }\n+\t  return SUCCESS;\n \t}\n-      /* Check assigned label.  */\n-      if (e->expr_type == EXPR_VARIABLE && e->ts.type == BT_INTEGER\n-\t\t&& e->symtree->n.sym->attr.assign != 1)\n+      else\n \t{\n-\t  gfc_error (\"Variable '%s' has not been assigned a format label at %L\",\n-\t\t\te->symtree->n.sym->name, &e->where);\n-\t  return FAILURE;\n+\t  /* if rank is nonzero, we allow the type to be character under\n+\t     GFC_STD_GNU and other type under GFC_STD_LEGACY. It may be\n+\t     assigned an Hollerith constant.  */\n+\t  if (e->ts.type == BT_CHARACTER)\n+\t    {\n+\t      if (gfc_notify_std (GFC_STD_GNU,\n+\t\t\t\"Extension: Character array in FORMAT tag at %L\",\n+\t\t\t&e->where) == FAILURE)\n+\t\treturn FAILURE;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (gfc_notify_std (GFC_STD_LEGACY,\n+\t\t\t\"Extension: Non-character in FORMAT tag at %L\",\n+\t\t\t&e->where) == FAILURE)\n+\t\treturn FAILURE;\n+\t    }\n+\t  return SUCCESS;\n \t}\n     }\n   else"}, {"sha": "dc6a34b86bc7c04d1ac4066e050974020dae0611", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -159,6 +159,9 @@ gfc_basic_typename (bt type)\n     case BT_CHARACTER:\n       p = \"CHARACTER\";\n       break;\n+    case BT_HOLLERITH:\n+      p = \"HOLLERITH\";\n+      break;\n     case BT_DERIVED:\n       p = \"DERIVED\";\n       break;\n@@ -207,6 +210,9 @@ gfc_typename (gfc_typespec * ts)\n     case BT_CHARACTER:\n       sprintf (buffer, \"CHARACTER(%d)\", ts->kind);\n       break;\n+    case BT_HOLLERITH:\n+      sprintf (buffer, \"HOLLERITH\");\n+      break;\n     case BT_DERIVED:\n       sprintf (buffer, \"TYPE(%s)\", ts->derived->name);\n       break;"}, {"sha": "1f8305bf7b4346d27633cf8bfbab4552c9f1757c", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -228,6 +228,75 @@ match_integer_constant (gfc_expr ** result, int signflag)\n }\n \n \n+/* Match a Hollerith constant.  */\n+\n+static match\n+match_hollerith_constant (gfc_expr ** result)\n+{\n+  locus old_loc;\n+  gfc_expr * e = NULL;\n+  const char * msg;\n+  char * buffer;\n+  unsigned int num;\n+  unsigned int i;  \n+\n+  old_loc = gfc_current_locus;\n+  gfc_gobble_whitespace ();\n+\n+  if (match_integer_constant (&e, 0) == MATCH_YES\n+\t&& gfc_match_char ('h') == MATCH_YES)\n+    {\n+      if (gfc_notify_std (GFC_STD_LEGACY,\n+\t\t\"Extention: Hollerith constant at %C\")\n+\t\t== FAILURE)\n+\tgoto cleanup;\n+\n+      msg = gfc_extract_int (e, &num);\n+      if (msg != NULL)\n+\t{\n+\t  gfc_error (msg);\n+\t  goto cleanup;\n+\t}\n+      if (num == 0)\n+\t{\n+\t  gfc_error (\"Invalid Hollerith constant: %L must contain at least one \"\n+\t\t\t\"character\", &old_loc);\n+\t  goto cleanup;\n+\t}\n+      if (e->ts.kind != gfc_default_integer_kind)\n+\t{\n+\t  gfc_error (\"Invalid Hollerith constant: Interger kind at %L \"\n+\t\t\"should be default\", &old_loc);\n+\t  goto cleanup;\n+\t}\n+      else\n+\t{\n+\t  buffer = (char *)gfc_getmem (sizeof(char)*num+1);\n+\t  for (i = 0; i < num; i++)\n+\t    {\n+\t      buffer[i] = gfc_next_char_literal (1);\n+\t    }\n+\t  gfc_free_expr (e);\n+\t  e = gfc_constant_result (BT_HOLLERITH,\n+\t\tgfc_default_character_kind, &gfc_current_locus);\n+\t  e->value.character.string = gfc_getmem (num+1);\n+\t  memcpy (e->value.character.string, buffer, num);\n+\t  e->value.character.length = num;\n+\t  *result = e;\n+\t  return MATCH_YES;\n+\t}\n+    }\n+\n+  gfc_free_expr (e);\n+  gfc_current_locus = old_loc;\n+  return MATCH_NO;\n+\n+cleanup:\n+  gfc_free_expr (e);\n+  return MATCH_ERROR;\n+}\n+\n+\n /* Match a binary, octal or hexadecimal constant that can be found in\n    a DATA statement.  */\n \n@@ -1159,6 +1228,10 @@ gfc_match_literal_constant (gfc_expr ** result, int signflag)\n   if (m != MATCH_NO)\n     return m;\n \n+  m = match_hollerith_constant (result);\n+  if (m != MATCH_NO)\n+    return m;\n+\n   m = match_integer_constant (result, signflag);\n   if (m != MATCH_NO)\n     return m;"}, {"sha": "72d03eab672cad1b451864cfd7ff21a2aceaad3e", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -3774,6 +3774,34 @@ gfc_convert_constant (gfc_expr * e, bt type, int kind)\n \t}\n       break;\n \n+    case BT_HOLLERITH:\n+      switch (type)\n+\t{\n+\tcase BT_INTEGER:\n+\t  f = gfc_hollerith2int;\n+\t  break;\n+\n+\tcase BT_REAL:\n+\t  f = gfc_hollerith2real;\n+\t  break;\n+\n+\tcase BT_COMPLEX:\n+\t  f = gfc_hollerith2complex;\n+\t  break;\n+\n+\tcase BT_CHARACTER:\n+\t  f = gfc_hollerith2character;\n+\t  break;\n+\n+\tcase BT_LOGICAL:\n+\t  f = gfc_hollerith2logical;\n+\t  break;\n+\n+\tdefault:\n+\t  goto oops;\n+\t}\n+      break;\n+\n     default:\n     oops:\n       gfc_internal_error (\"gfc_convert_constant(): Unexpected type\");"}, {"sha": "ae7c271d7e059c4a5059ab9ad6c7bf6dc6fb1255", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 37, "deletions": 9, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -274,30 +274,58 @@ gfc_conv_constant_to_tree (gfc_expr * expr)\n {\n   gcc_assert (expr->expr_type == EXPR_CONSTANT);\n \n+  /* If it is converted from Hollerith constant, we build string constant\n+     and VIEW_CONVERT to its type.  */\n+ \n   switch (expr->ts.type)\n     {\n     case BT_INTEGER:\n-      return gfc_conv_mpz_to_tree (expr->value.integer, expr->ts.kind);\n+      if (expr->from_H)\n+\treturn build1 (VIEW_CONVERT_EXPR,\n+\t\t\tgfc_get_int_type (expr->ts.kind),\n+\t\t\tgfc_build_string_const (expr->value.character.length,\n+\t\t\t\texpr->value.character.string));\n+      else\n+\treturn gfc_conv_mpz_to_tree (expr->value.integer, expr->ts.kind);\n \n     case BT_REAL:\n-      return gfc_conv_mpfr_to_tree (expr->value.real, expr->ts.kind);\n+      if (expr->from_H)\n+\treturn build1 (VIEW_CONVERT_EXPR,\n+\t\t\tgfc_get_real_type (expr->ts.kind),\n+\t\t\tgfc_build_string_const (expr->value.character.length,\n+\t\t\t\texpr->value.character.string));\n+      else\n+\treturn gfc_conv_mpfr_to_tree (expr->value.real, expr->ts.kind);\n \n     case BT_LOGICAL:\n-      return build_int_cst (gfc_get_logical_type (expr->ts.kind),\n+      if (expr->from_H)\n+\treturn build1 (VIEW_CONVERT_EXPR,\n+\t\t\tgfc_get_logical_type (expr->ts.kind),\n+\t\t\tgfc_build_string_const (expr->value.character.length,\n+\t\t\t\texpr->value.character.string));\n+      else\n+\treturn build_int_cst (gfc_get_logical_type (expr->ts.kind),\n \t\t\t    expr->value.logical);\n \n     case BT_COMPLEX:\n-      {\n-\ttree real = gfc_conv_mpfr_to_tree (expr->value.complex.r,\n+      if (expr->from_H)\n+\treturn build1 (VIEW_CONVERT_EXPR,\n+\t\t\tgfc_get_complex_type (expr->ts.kind),\n+\t\t\tgfc_build_string_const (expr->value.character.length,\n+\t\t\t\texpr->value.character.string));\n+      else\n+\t{\n+\t  tree real = gfc_conv_mpfr_to_tree (expr->value.complex.r,\n \t\t\t\t\t  expr->ts.kind);\n-\ttree imag = gfc_conv_mpfr_to_tree (expr->value.complex.i,\n+\t  tree imag = gfc_conv_mpfr_to_tree (expr->value.complex.i,\n \t\t\t\t\t  expr->ts.kind);\n \n-\treturn build_complex (gfc_typenode_for_spec (&expr->ts),\n-\t\t\t      real, imag);\n-      }\n+\t  return build_complex (gfc_typenode_for_spec (&expr->ts),\n+\t\t\t\treal, imag);\n+\t}\n \n     case BT_CHARACTER:\n+    case BT_HOLLERITH:\n       return gfc_build_string_const (expr->value.character.length,\n \t\t\t\t     expr->value.character.string);\n "}, {"sha": "4b6caa6f9c8f55a83247844a2c3a9e245fa29910", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 71, "deletions": 2, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -364,6 +364,68 @@ set_parameter_ref (stmtblock_t * block, tree var, gfc_expr * e)\n   gfc_add_modify_expr (block, tmp, se.expr);\n }\n \n+/* Given an array expr, find its address and length to get a string. If the\n+   array is full, the string's address is the address of array's first element\n+   and the length is the size of the whole array. If it is an element, the\n+   string's address is the element's address and the length is the rest size of\n+   the array.\n+*/\n+\n+static void\n+gfc_convert_array_to_string (gfc_se * se, gfc_expr * e)\n+{\n+  tree tmp;\n+  tree array;\n+  tree type;\n+  tree size;\n+  int rank;\n+  gfc_symbol *sym;\n+\n+  sym = e->symtree->n.sym;\n+  rank = sym->as->rank - 1;\n+\n+  if (e->ref->u.ar.type == AR_FULL)\n+    {\n+      se->expr = gfc_get_symbol_decl (sym);\n+      se->expr = gfc_conv_array_data (se->expr);\n+    }\n+  else\n+    {\n+      gfc_conv_expr (se, e);\n+    }\n+\n+  array = sym->backend_decl;\n+  type = TREE_TYPE (array);\n+\n+  if (GFC_ARRAY_TYPE_P (type))\n+    size = GFC_TYPE_ARRAY_SIZE (type);\n+  else\n+    {\n+      gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n+      size = gfc_conv_array_stride (array, rank);\n+      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\tgfc_conv_array_ubound (array, rank),\n+\t\tgfc_conv_array_lbound (array, rank));\n+      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type, tmp,\n+\t\tgfc_index_one_node);\n+      size = fold_build2 (MULT_EXPR, gfc_array_index_type, tmp, size);      \n+    }\n+\n+  gcc_assert (size);\n+\n+  /* If it is an element, we need the its address and size of the rest.  */\n+  if (e->ref->u.ar.type == AR_ELEMENT)\n+    {\n+      size = fold_build2 (MINUS_EXPR, gfc_array_index_type, size,\n+\t\tTREE_OPERAND (se->expr, 1));\n+      se->expr = gfc_build_addr_expr (NULL, se->expr);\n+    }\n+\n+  tmp = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n+  size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, tmp);\n+\n+  se->string_length = fold_convert (gfc_charlen_type_node, size);\n+}\n \n /* Generate code to store a string and its length into the\n    ioparm structure.  */\n@@ -400,15 +462,22 @@ set_string (stmtblock_t * block, stmtblock_t * postblock, tree var,\n     }\n   else\n     {\n-      gfc_conv_expr (&se, e);\n+      /* General character.  */\n+      if (e->ts.type == BT_CHARACTER && e->rank == 0)\n+\tgfc_conv_expr (&se, e);\n+      /* Array assigned Hollerith constant or character array.  */\n+      else if (e->symtree && (e->symtree->n.sym->as->rank > 0))\n+\tgfc_convert_array_to_string (&se, e);\n+      else\n+\tgcc_unreachable ();\n+\n       gfc_conv_string_parameter (&se);\n       gfc_add_modify_expr (&se.pre, io, fold_convert (TREE_TYPE (io), se.expr));\n       gfc_add_modify_expr (&se.pre, len, se.string_length);\n     }\n \n   gfc_add_block_to_block (block, &se.pre);\n   gfc_add_block_to_block (postblock, &se.post);\n-\n }\n \n "}, {"sha": "57e7e08f945d2b481ac43c12c7be9752a2fb1ee5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -1,3 +1,16 @@\n+2005-07-07  Feng Wang  <fengwang@nudt.edu.cn>\n+\n+\tPR fortran/16531\n+\tPR fortran/15966\n+\tPR fortran/18781\n+\t* gfortran.dg/hollerith.f90: New.\n+\t* gfortran.dg/hollerith2.f90: New.\n+\t* gfortran.dg/hollerith3.f90: New.\n+\t* gfortran.dg/hollerith4.f90: New.\n+\t* gfortran.dg/hollerith_f95.f90: New.\n+\t* gfortran.dg/hollerith_legacy.f90: New.\n+\t* gfortran.dg/g77/cpp4.F: New. Port from g77.\n+\n 2005-07-07  Ziemowit Laski  <zlaski@apple.com>\n \n \tPR objc/22274"}, {"sha": "0dd5c99edc2c920a0b6a3512e73dff0605a18986", "filename": "gcc/testsuite/gfortran.dg/g77/cpp4.F", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Fcpp4.F", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Fcpp4.F", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Fcpp4.F?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -0,0 +1,12 @@\n+      ! { dg-do run }\n+C The preprocessor must not mangle Hollerith constants\n+C which contain apostrophes.\n+      integer i\n+      character*4 j\n+      data i /4hbla'/\n+      write (j, '(4a)') i\n+      if (j .ne. \"bla'\") call abort\n+      end\n+\n+      ! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 6 }\n+      ! { dg-warning \"Conversion\" \"conversion\" { target *-*-* } 6 }"}, {"sha": "e273ceedc686a8a15b291a5b2094bf301fa21cec", "filename": "gcc/testsuite/gfortran.dg/hollerith.f90", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ftestsuite%2Fgfortran.dg%2Fhollerith.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ftestsuite%2Fgfortran.dg%2Fhollerith.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fhollerith.f90?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -0,0 +1,108 @@\n+! { dg-do run }\n+! PR15966, PR18781 & PR16531\n+implicit none\n+complex*16 x(2) \n+complex*8 a(2,2)\n+character*4 z\n+character z1(4)\n+character*4 z2(2,2)\n+character*80 line\n+integer*4 i\n+logical*4 l\n+real*4 r\n+character*8 c\n+\n+data x /16Habcdefghijklmnop, 16Hqrstuvwxyz012345/\n+data a /8H(i3),abc, 0, 4H(i4), 8H    (i9)/\n+data z/4h(i5)/\n+data z1/1h(,1hi,1h6,1h)/\n+data z2/4h(i7),'xxxx','xxxx','xxxx'/\n+\n+z2 (1,2) = 4h(i8)\n+i = 4hHell\n+l = 4Ho wo\n+r = 4Hrld! \n+write (line, '(3A4)') i, l, r\n+if (line .ne. 'Hello world!') call abort\n+i = 2Hab\n+r = 2Hab\n+l = 2Hab\n+c = 2Hab\n+write (line, '(3A4, 8A)') i, l, r, c\n+if (line .ne. 'ab  ab  ab  ab      ') call abort\n+\n+write(line, '(4A8, \"!\")' ) x\n+if (line .ne. 'abcdefghijklmnopqrstuvwxyz012345!') call abort\n+\n+write (line, a) 3\n+if (line .ne. '  3') call abort\n+write (line, a (1,2)) 4\n+if (line .ne. '   4') call abort\n+write (line, z) 5\n+if (line .ne. '    5') call abort\n+write (line, z1) 6\n+if (line .ne. '     6') call abort\n+write (line, z2) 7\n+if (line .ne. '      7') call abort\n+write (line, z2 (1,2)) 8\n+if (line .ne. '       8') call abort\n+write (line, '(16A)') z2\n+if (line .ne. '(i7)xxxx(i8)xxxx') call abort\n+call test (8h   hello)\n+end\n+\n+subroutine test (h)\n+integer*8 h\n+character*80 line\n+\n+write (line, '(8a)') h\n+if (line .ne. '   hello') call abort\n+end subroutine\n+\n+! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 15 }\n+! { dg-warning \"Conversion\" \"conversion\" { target *-*-* } 15 }\n+\n+! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 16 }\n+! { dg-warning \"Conversion\" \"conversion\" { target *-*-* } 16 }\n+\n+! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 17 }\n+\n+! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 18 }\n+\n+! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 19 }\n+\n+! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 21 }\n+! { dg-warning \"Conversion\" \"conversion\" { target *-*-* } 21 }\n+\n+! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 22 }\n+! { dg-warning \"Conversion\" \"conversion\" { target *-*-* } 22 }\n+\n+! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 23 }\n+! { dg-warning \"Conversion\" \"conversion\" { target *-*-* } 23 }\n+\n+! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 24 }\n+! { dg-warning \"Conversion\" \"conversion\" { target *-*-* } 24 }\n+\n+! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 27 }\n+! { dg-warning \"Conversion\" \"conversion\" { target *-*-* } 27 }\n+\n+! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 28 }\n+! { dg-warning \"Conversion\" \"conversion\" { target *-*-* } 28 }\n+\n+! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 29 }\n+! { dg-warning \"Conversion\" \"conversion\" { target *-*-* } 29 }\n+\n+! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 30 }\n+! { dg-warning \"Conversion\" \"conversion\" { target *-*-* } 30 }\n+\n+! { dg-warning \"Non-character in FORMAT tag\" \"\" { target *-*-* } 37 }\n+\n+! { dg-warning \"Non-character in FORMAT tag\" \"\" { target *-*-* } 39 }\n+\n+! { dg-warning \"Character array in FORMAT tag\" \"\" { target *-*-* } 43 }\n+\n+! { dg-warning \"Character array in FORMAT tag\" \"\" { target *-*-* } 45 }\n+\n+! { dg-warning \"Character array in FORMAT tag\" \"\" { target *-*-* } 47 }\n+\n+! { dg-warning \"Hollerith constant\" \"\" { target *-*-* } 51 }"}, {"sha": "773b79b1b96b175cb9595e8f4c769f767e130f60", "filename": "gcc/testsuite/gfortran.dg/hollerith2.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ftestsuite%2Fgfortran.dg%2Fhollerith2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ftestsuite%2Fgfortran.dg%2Fhollerith2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fhollerith2.f90?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -0,0 +1,26 @@\n+       ! { dg-do run }\n+       ! Program to test Hollerith constant.\n+       Program test\n+       implicit none\n+       integer* 4 i,j\n+       real r, x, y\n+       parameter (i = 4h1234)\n+       parameter (r = 4hdead)\n+       parameter (y = 4*r)\n+       parameter (j = selected_real_kind (i))\n+       x = 4H1234 \n+       x = sin(r)\n+       x = x * r\n+       x = x / r\n+       x = x + r\n+       x = x - r\n+       end\n+! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 7 }\n+! { dg-warning \"Conversion\" \"conversion\" { target *-*-* } 7 }\n+\n+! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 8 }\n+! { dg-warning \"Conversion\" \"conversion\" { target *-*-* } 8 }\n+\n+! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 11 }\n+! { dg-warning \"Conversion\" \"conversion\" { target *-*-* } 11 }\n+"}, {"sha": "b283f5f7c0bcd188bad61921c061b3454c96b859", "filename": "gcc/testsuite/gfortran.dg/hollerith3.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ftestsuite%2Fgfortran.dg%2Fhollerith3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ftestsuite%2Fgfortran.dg%2Fhollerith3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fhollerith3.f90?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -0,0 +1,9 @@\n+       ! { dg-do compile }\n+       ! { dg-options \"-w\" }\n+       ! Program to test invalid Hollerith constant.\n+       Program test\n+       implicit none\n+       integer i\n+       i = 0H ! { dg-error \"at least one character\" }\n+       i = 4_8H1234 ! { dg-error \"should be default\" }\n+       end"}, {"sha": "b89018509ee9f7ec1ab7be5525c15ceaced81874", "filename": "gcc/testsuite/gfortran.dg/hollerith4.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ftestsuite%2Fgfortran.dg%2Fhollerith4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ftestsuite%2Fgfortran.dg%2Fhollerith4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fhollerith4.f90?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+! Test Hollerith constant assigned to allocatable array\n+\n+integer, allocatable :: c (:,:)\n+character (len = 20) ch\n+allocate (c(1,2))\n+\n+c(1,1) = 4H(A4)\n+c(1,2) = 4H(A5)\n+\n+write (ch, \"(2A4)\") c\n+if (ch .ne. \"(A4)(A5)\") call abort()\n+write (ch, c) 'Hello'\n+if (ch .ne. \"Hell\") call abort()\n+write (ch, c (1,2)) 'Hello'\n+if (ch .ne. \"Hello\") call abort()\n+end\n+\n+! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 8 }\n+! { dg-warning \"Conversion\" \"conversion\" { target *-*-* } 8 }\n+\n+! { dg-warning \"Hollerith constant\" \"const\" { target *-*-* } 9 }\n+! { dg-warning \"Conversion\" \"conversion\" { target *-*-* } 9 }\n+\n+! { dg-warning \"Non-character in FORMAT tag\" \"\" { target *-*-* } 13 }\n+\n+! { dg-warning \"Non-character in FORMAT tag\" \"\" { target *-*-* } 15 }\n+\n+"}, {"sha": "c7e4d588f8945568c82b49d928df278568db7ed1", "filename": "gcc/testsuite/gfortran.dg/hollerith_f95.f90", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ftestsuite%2Fgfortran.dg%2Fhollerith_f95.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ftestsuite%2Fgfortran.dg%2Fhollerith_f95.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fhollerith_f95.f90?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -0,0 +1,100 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+! PR15966, PR18781 & PR16531\n+implicit none\n+complex*16 x(2) \n+complex*8 a(2,2)\n+character*4 z\n+character z1(4)\n+character*4 z2(2,2)\n+character*80 line\n+integer*4 i\n+logical*4 l\n+real*4 r\n+character*8 c\n+\n+data x /16Habcdefghijklmnop, 16Hqrstuvwxyz012345/\n+data a /8H(i3),abc, 0, 4H(i4), 8H    (i9)/\n+data z/4h(i5)/\n+data z1/1h(,1hi,1h6,1h)/\n+data z2/4h(i7),'xxxx','xxxx','xxxx'/\n+\n+z2 (1,2) = 4h(i8)\n+i = 4hHell\n+l = 4Ho wo\n+r = 4Hrld! \n+write (line, '(3A4)') i, l, r\n+if (line .ne. 'Hello world!') call abort\n+i = 2Hab\n+r = 2Hab\n+l = 2Hab\n+c = 2Hab\n+write (line, '(3A4, 8A)') i, l, r, c\n+if (line .ne. 'ab  ab  ab  ab      ') call abort\n+\n+write(line, '(4A8, \"!\")' ) x\n+if (line .ne. 'abcdefghijklmnopqrstuvwxyz012345!') call abort\n+\n+write (line, a) 3\n+if (line .ne. '  3') call abort\n+write (line, a (1,2)) 4\n+if (line .ne. '   4') call abort\n+write (line, z) 5\n+if (line .ne. '    5') call abort\n+write (line, z1) 6\n+if (line .ne. '     6') call abort\n+write (line, z2) 7\n+if (line .ne. '      7') call abort\n+write (line, z2 (1,2)) 8\n+if (line .ne. '       8') call abort\n+write (line, '(16A)') z2\n+if (line .ne. '(i7)xxxx(i8)xxxx') call abort\n+call test (8h   hello)\n+end\n+\n+subroutine test (h)\n+integer*8 h\n+character*80 line\n+\n+write (line, '(8a)') h\n+if (line .ne. '   hello') call abort\n+end subroutine\n+\n+! { dg-error \"Hollerith constant\" \"const\" { target *-*-* } 16 }\n+\n+! { dg-error \"Hollerith constant\" \"const\" { target *-*-* } 17 }\n+\n+! { dg-error \"Hollerith constant\" \"const\" { target *-*-* } 18 }\n+\n+! { dg-error \"Hollerith constant\" \"const\" { target *-*-* } 19 }\n+\n+! { dg-error \"Hollerith constant\" \"const\" { target *-*-* } 20 }\n+\n+! { dg-error \"Hollerith constant\" \"const\" { target *-*-* } 22 }\n+\n+! { dg-error \"Hollerith constant\" \"const\" { target *-*-* } 23 }\n+\n+! { dg-error \"Hollerith constant\" \"const\" { target *-*-* } 24 }\n+\n+! { dg-error \"Hollerith constant\" \"const\" { target *-*-* } 25 }\n+\n+! { dg-error \"Hollerith constant\" \"const\" { target *-*-* } 28 }\n+\n+! { dg-error \"Hollerith constant\" \"const\" { target *-*-* } 29 }\n+\n+! { dg-error \"Hollerith constant\" \"const\" { target *-*-* } 30 }\n+\n+! { dg-error \"Hollerith constant\" \"const\" { target *-*-* } 31 }\n+\n+! { dg-error \"Hollerith constant\" \"const\" { target *-*-* } 52 }\n+\n+! { dg-error \"Non-character in FORMAT tag\" \"\" { target *-*-* } 38 }\n+\n+! { dg-error \"Non-character in FORMAT tag\" \"\" { target *-*-* } 40 }\n+\n+! { dg-error \"Character array in FORMAT tag\" \"\" { target *-*-* } 44 }\n+\n+! { dg-error \"Character array in FORMAT tag\" \"\" { target *-*-* } 46 }\n+\n+! { dg-error \"Character array in FORMAT tag\" \"\" { target *-*-* } 48 }\n+"}, {"sha": "561430cf7c7f49e5490934f764f9be61e04e3fd3", "filename": "gcc/testsuite/gfortran.dg/hollerith_legacy.f90", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ftestsuite%2Fgfortran.dg%2Fhollerith_legacy.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/gcc%2Ftestsuite%2Fgfortran.dg%2Fhollerith_legacy.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fhollerith_legacy.f90?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -0,0 +1,61 @@\n+! { dg-do compile }\n+! { dg-options \"-std=legacy\" }\n+! PR15966, PR18781 & PR16531\n+implicit none\n+complex*16 x(2) \n+complex*8 a(2,2)\n+character*4 z\n+character z1(4)\n+character*4 z2(2,2)\n+character*80 line\n+integer*4 i\n+logical*4 l\n+real*4 r\n+character*8 c\n+\n+data x /16Habcdefghijklmnop, 16Hqrstuvwxyz012345/\n+data a /8H(i3),abc, 0, 4H(i4), 8H    (i9)/\n+data z/4h(i5)/\n+data z1/1h(,1hi,1h6,1h)/\n+data z2/4h(i7),'xxxx','xxxx','xxxx'/\n+\n+z2 (1,2) = 4h(i8)\n+i = 4hHell\n+l = 4Ho wo\n+r = 4Hrld! \n+write (line, '(3A4)') i, l, r\n+if (line .ne. 'Hello world!') call abort\n+i = 2Hab\n+r = 2Hab\n+l = 2Hab\n+c = 2Hab\n+write (line, '(3A4, 8A)') i, l, r, c\n+if (line .ne. 'ab  ab  ab  ab      ') call abort\n+\n+write(line, '(4A8, \"!\")' ) x\n+if (line .ne. 'abcdefghijklmnopqrstuvwxyz012345!') call abort\n+\n+write (line, a) 3\n+if (line .ne. '  3') call abort\n+write (line, a (1,2)) 4\n+if (line .ne. '   4') call abort\n+write (line, z) 5\n+if (line .ne. '    5') call abort\n+write (line, z1) 6\n+if (line .ne. '     6') call abort\n+write (line, z2) 7\n+if (line .ne. '      7') call abort\n+write (line, z2 (1,2)) 8\n+if (line .ne. '       8') call abort\n+write (line, '(16A)') z2\n+if (line .ne. '(i7)xxxx(i8)xxxx') call abort\n+call test (8h   hello)\n+end\n+\n+subroutine test (h)\n+integer*8 h\n+character*80 line\n+\n+write (line, '(8a)') h\n+if (line .ne. '   hello') call abort\n+end subroutine"}, {"sha": "242bd3c8910afa1e378bfaf7560ffad5ee3b58ec", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -1,3 +1,9 @@\n+2005-07-07  Feng Wang  <fengwang@nudt.edu.cn>\n+\n+\tPR fortran/16531\n+\t* io/transfer.c (formatted_transfer): Enable FMT_A on other types to\n+\tsupport Hollerith constants.\n+\n 2005-07-01  Andreas Jaeger  <aj@suse.de>\n \n \t* intrinsics/unpack_generic.c: Remove const from parameter."}, {"sha": "bcba218c50adef2b17025603756333792b9825f9", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3642f893a731c246c8e7d8e8542abbd238daac6/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3642f893a731c246c8e7d8e8542abbd238daac6/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=d3642f893a731c246c8e7d8e8542abbd238daac6", "patch": "@@ -524,8 +524,6 @@ formatted_transfer (bt type, void *p, int len)\n \tcase FMT_A:\n \t  if (n == 0)\n \t    goto need_data;\n-\t  if (require_type (BT_CHARACTER, type, f))\n-\t    return;\n \n \t  if (g.mode == READING)\n \t    read_a (f, p, len);"}]}