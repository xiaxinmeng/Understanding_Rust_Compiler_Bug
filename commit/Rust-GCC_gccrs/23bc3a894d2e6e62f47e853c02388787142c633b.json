{"sha": "23bc3a894d2e6e62f47e853c02388787142c633b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNiYzNhODk0ZDJlNmU2MmY0N2U4NTNjMDIzODg3ODcxNDJjNjMzYg==", "commit": {"author": {"name": "Bryce McKinlay", "email": "mckinlay@redhat.com", "date": "2006-04-29T01:35:50Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2006-04-29T01:35:50Z"}, "message": "link.cc (_Jv_Linker::resolve_pool_entry): Don't pass vtable_index to resolve_method.\n\n2006-04-28  Bryce McKinlay  <mckinlay@redhat.com>\n\n\t* link.cc (_Jv_Linker::resolve_pool_entry): Don't pass vtable_index\n\tto resolve_method.\n\t* interpret.cc (insn_invokevirtual): Use method->index, not\n\tvtable_index. Check accflag FINAL to determine finals. Only do\n\texplicit null check if calling a final method. Use\n\tthrow_null_pointer_exception.\n\t(invokevirtual_resolved): Likewise.\n\t(null_pointer_exc): Remove static field.\n\t(throw_null_pointer_exception): Always define. Throw a new\n\tNullPointerException every time.\n\t* include/java-interp.h (_Jv_ResolvedMethod): Remove vtable_index\n\tfield.\n\t* include/execution.h (resolve_method): Remove vtable_index argument.\n\nFrom-SVN: r113370", "tree": {"sha": "190c70f4d67cff0f7db66783ec89f4f81229bbdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/190c70f4d67cff0f7db66783ec89f4f81229bbdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23bc3a894d2e6e62f47e853c02388787142c633b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23bc3a894d2e6e62f47e853c02388787142c633b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23bc3a894d2e6e62f47e853c02388787142c633b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23bc3a894d2e6e62f47e853c02388787142c633b/comments", "author": null, "committer": null, "parents": [{"sha": "f6326de601ea98a438f0f053ecc5b8cb78364254", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6326de601ea98a438f0f053ecc5b8cb78364254", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6326de601ea98a438f0f053ecc5b8cb78364254"}], "stats": {"total": 87, "additions": 40, "deletions": 47}, "files": [{"sha": "ce5d6a4e8d7744d80882524b6e7961ebd7507ab8", "filename": "libjava/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23bc3a894d2e6e62f47e853c02388787142c633b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23bc3a894d2e6e62f47e853c02388787142c633b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=23bc3a894d2e6e62f47e853c02388787142c633b", "patch": "@@ -1,3 +1,19 @@\n+2006-04-28  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* link.cc (_Jv_Linker::resolve_pool_entry): Don't pass vtable_index\n+\tto resolve_method.\n+\t* interpret.cc (insn_invokevirtual): Use method->index, not\n+\tvtable_index. Check accflag FINAL to determine finals. Only do\n+\texplicit null check if calling a final method. Use\n+\tthrow_null_pointer_exception.\n+\t(invokevirtual_resolved): Likewise.\n+\t(null_pointer_exc): Remove static field.\n+\t(throw_null_pointer_exception): Always define. Throw a new\n+\tNullPointerException every time.\n+\t* include/java-interp.h (_Jv_ResolvedMethod): Remove vtable_index\n+\tfield.\n+\t* include/execution.h (resolve_method): Remove vtable_index argument.\t\n+\n 2006-04-28  Andreas Tobler  <a.tobler@schweiz.ch>\n \n \t* configure.ac: Add an additional checks for dladdr and dlopen on dld."}, {"sha": "f0c309c85cca27a36fdd6e8d7e4c9001976f9658", "filename": "libjava/include/execution.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23bc3a894d2e6e62f47e853c02388787142c633b/libjava%2Finclude%2Fexecution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23bc3a894d2e6e62f47e853c02388787142c633b/libjava%2Finclude%2Fexecution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fexecution.h?ref=23bc3a894d2e6e62f47e853c02388787142c633b", "patch": "@@ -26,7 +26,7 @@ struct _Jv_ExecutionEngine\n   void (*allocate_static_fields) (jclass, int, int);\n   void (*create_ncode) (jclass);\n   _Jv_ResolvedMethod *(*resolve_method) (_Jv_Method *, jclass,\n-\t\t\t\t\t jboolean, jint);\n+\t\t\t\t\t jboolean);\n   void (*post_miranda_hook) (jclass);\n };\n \n@@ -50,7 +50,7 @@ struct _Jv_CompiledEngine : public _Jv_ExecutionEngine\n   }\n \n   static _Jv_ResolvedMethod *do_resolve_method (_Jv_Method *, jclass,\n-\t\t\t\t\t\tjboolean, jint)\n+\t\t\t\t\t\tjboolean)\n   {\n     return NULL;\n   }\n@@ -118,7 +118,7 @@ class _Jv_InterpreterEngine : public _Jv_ExecutionEngine\n   static void do_allocate_static_fields (jclass, int, int);\n   static void do_create_ncode (jclass);\n   static _Jv_ResolvedMethod *do_resolve_method (_Jv_Method *, jclass,\n-\t\t\t\t\t\tjboolean, jint);\n+\t\t\t\t\t\tjboolean);\n \n   static bool do_need_resolve_string_fields ()\n   {"}, {"sha": "eb7c99d14db3a573b6a29a48c253e571943558c5", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23bc3a894d2e6e62f47e853c02388787142c633b/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23bc3a894d2e6e62f47e853c02388787142c633b/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=23bc3a894d2e6e62f47e853c02388787142c633b", "patch": "@@ -243,7 +243,6 @@ _Jv_GetFirstMethod (_Jv_InterpClass *klass)\n struct _Jv_ResolvedMethod\n {\n   jint            stack_item_count;\t\n-  jint            vtable_index;\t\n   jclass          klass;\n   _Jv_Method*     method;\n "}, {"sha": "9a2059dadfc4c869e6d4f43182420b6364974c8b", "filename": "libjava/interpret.cc", "status": "modified", "additions": 20, "deletions": 37, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23bc3a894d2e6e62f47e853c02388787142c633b/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23bc3a894d2e6e62f47e853c02388787142c633b/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=23bc3a894d2e6e62f47e853c02388787142c633b", "patch": "@@ -51,10 +51,8 @@ static void throw_internal_error (const char *msg)\n   __attribute__ ((__noreturn__));\n static void throw_incompatible_class_change_error (jstring msg)\n   __attribute__ ((__noreturn__));\n-#ifndef HANDLE_SEGV\n static void throw_null_pointer_exception ()\n   __attribute__ ((__noreturn__));\n-#endif\n \n static void throw_class_format_error (jstring msg)\n \t__attribute__ ((__noreturn__));\n@@ -1142,31 +1140,27 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \t * the corresponding bit JV_CONSTANT_ResolvedFlag in the tag\n \t * directly.  For now, I don't think it is worth it.  */\n \n-\tSAVE_PC();\n \trmeth = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n \t\t\t\t\t\t   index)).rmethod;\n \n \tsp -= rmeth->stack_item_count;\n-\t// We don't use NULLCHECK here because we can't rely on that\n-\t// working if the method is final.  So instead we do an\n-\t// explicit test.\n-\tif (! sp[0].o)\n-\t  {\n-\t    //printf(\"invokevirtual pc = %p/%i\\n\", pc, meth->get_pc_val(pc));\n-\t    throw new java::lang::NullPointerException;\n-\t  }\n \n-\tif (rmeth->vtable_index == -1)\n+\tif (rmeth->method->accflags & Modifier::FINAL)\n \t  {\n-\t    // final methods do not appear in the vtable,\n-\t    // if it does not appear in the superclass.\n+\t    // We can't rely on NULLCHECK working if the method is final.\n+\t    SAVE_PC();\n+\t    if (! sp[0].o)\n+\t      throw_null_pointer_exception ();\n+\n+\t    // Final methods might not appear in the vtable.\n \t    fun = (void (*)()) rmeth->method->ncode;\n \t  }\n \telse\n \t  {\n+\t    NULLCHECK (sp[0].o);\n \t    jobject rcv = sp[0].o;\n \t    _Jv_VTable *table = *(_Jv_VTable**) rcv;\n-\t    fun = (void (*)()) table->get_method (rmeth->vtable_index);\n+\t    fun = (void (*)()) table->get_method (rmeth->method->index);\n \t  }\n \n #ifdef DIRECT_THREADED\n@@ -1183,26 +1177,22 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n       {\n \trmeth = (_Jv_ResolvedMethod *) AVAL ();\n \tsp -= rmeth->stack_item_count;\n-\t// We don't use NULLCHECK here because we can't rely on that\n-\t// working if the method is final.  So instead we do an\n-\t// explicit test.\n-\tif (! sp[0].o)\n+\n+\tif (rmeth->method->accflags & Modifier::FINAL)\n \t  {\n+\t    // We can't rely on NULLCHECK working if the method is final.\n \t    SAVE_PC();\n-\t    throw new java::lang::NullPointerException;\n-\t  }\n+\t    if (! sp[0].o)\n+\t      throw_null_pointer_exception ();\n \n-\tif (rmeth->vtable_index == -1)\n-\t  {\n-\t    // final methods do not appear in the vtable,\n-\t    // if it does not appear in the superclass.\n+\t    // Final methods might not appear in the vtable.\n \t    fun = (void (*)()) rmeth->method->ncode;\n \t  }\n \telse\n \t  {\n \t    jobject rcv = sp[0].o;\n \t    _Jv_VTable *table = *(_Jv_VTable**) rcv;\n-\t    fun = (void (*)()) table->get_method (rmeth->vtable_index);\n+\t    fun = (void (*)()) table->get_method (rmeth->method->index);\n \t  }\n       }\n       goto perform_invoke;\n@@ -2882,7 +2872,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \tif (! sp[0].o)\n \t  {\n \t    SAVE_PC();\n-\t    throw new java::lang::NullPointerException;\n+\t    throw_null_pointer_exception ();\n \t  }\n \n \tfun = (void (*)()) rmeth->method->ncode;\n@@ -2906,7 +2896,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \tif (! sp[0].o)\n \t  {\n \t    SAVE_PC();\n-\t    throw new java::lang::NullPointerException;\n+\t    throw_null_pointer_exception ();\n \t  }\n \tfun = (void (*)()) rmeth->method->ncode;\n       }\n@@ -3304,17 +3294,11 @@ throw_incompatible_class_change_error (jstring msg)\n   throw new java::lang::IncompatibleClassChangeError (msg);\n }\n \n-#ifndef HANDLE_SEGV\n-static java::lang::NullPointerException *null_pointer_exc;\n static void \n throw_null_pointer_exception ()\n {\n-  if (null_pointer_exc == NULL)\n-    null_pointer_exc = new java::lang::NullPointerException;\n-\n-  throw null_pointer_exc;\n+  throw new java::lang::NullPointerException;\n }\n-#endif\n \n /* Look up source code line number for given bytecode (or direct threaded\n    interpreter) PC. */\n@@ -3920,7 +3904,7 @@ _Jv_InterpreterEngine::do_allocate_static_fields (jclass klass,\n \n _Jv_ResolvedMethod *\n _Jv_InterpreterEngine::do_resolve_method (_Jv_Method *method, jclass klass,\n-\t\t\t\t\t  jboolean staticp, jint vtable_index)\n+\t\t\t\t\t  jboolean staticp)\n {\n   int arg_count = _Jv_count_arguments (method->signature, staticp);\n \n@@ -3936,7 +3920,6 @@ _Jv_InterpreterEngine::do_resolve_method (_Jv_Method *method, jclass klass,\n \t\t&result->arg_types[0],\n \t\tNULL);\n \n-  result->vtable_index        = vtable_index;\n   result->method              = method;\n   result->klass               = klass;\n "}, {"sha": "c65b0c97ff19aa9e331090b0361358695926a8a4", "filename": "libjava/link.cc", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23bc3a894d2e6e62f47e853c02388787142c633b/libjava%2Flink.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23bc3a894d2e6e62f47e853c02388787142c633b/libjava%2Flink.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flink.cc?ref=23bc3a894d2e6e62f47e853c02388787142c633b", "patch": "@@ -496,16 +496,11 @@ _Jv_Linker::resolve_pool_entry (jclass klass, int index, bool lazy)\n \t    throw new java::lang::NoSuchMethodError (sb->toString());\n \t  }\n       \n-\tint vtable_index = -1;\n-\tif (pool->tags[index] != JV_CONSTANT_InterfaceMethodref)\n-\t  vtable_index = (jshort)the_method->index;\n-\n \tpool->data[index].rmethod\n \t  = klass->engine->resolve_method(the_method,\n \t\t\t\t\t  found_class,\n \t\t\t\t\t  ((the_method->accflags\n-\t\t\t\t\t    & Modifier::STATIC) != 0),\n-\t\t\t\t\t  vtable_index);\n+\t\t\t\t\t    & Modifier::STATIC) != 0));\n \tpool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n       }\n       break;"}]}