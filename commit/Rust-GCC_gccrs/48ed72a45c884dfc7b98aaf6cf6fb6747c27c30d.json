{"sha": "48ed72a45c884dfc7b98aaf6cf6fb6747c27c30d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhlZDcyYTQ1Yzg4NGRmYzdiOThhYWY2Y2Y2ZmI2NzQ3YzI3YzMwZA==", "commit": {"author": {"name": "Peter Barada", "email": "peter@baradas.org", "date": "2003-10-11T04:53:13Z"}, "committer": {"name": "Bernardo Innocenti", "email": "bernie@gcc.gnu.org", "date": "2003-10-11T04:53:13Z"}, "message": "m68k.c (m68k_frame): Move before protos referencing it.\n\n\t* config/m68k/m68k.c (m68k_frame): Move before protos referencing it.\n\t(m68k_save_reg): Add boolean parameter `interrupt_handler'.\n\t(m68k_interrupt_function_p): New function.\n\t(m68k_handle_fndecl_attribute): Ditto.\n\t(m68k_compute_frame_layout): Ditto.\n\t(m68k_attribute_table): Define back-end specific attributes.\n\t(m68k_output_function_epilogue): Emit RTE instruction for interrupt\n\tfunctions.\n\nCo-Authored-By: Bernardo Innocenti <bernie@develer.com>\n\nFrom-SVN: r72329", "tree": {"sha": "c3a10c386f6d9a85ab9f29d4c4107790cd4360d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3a10c386f6d9a85ab9f29d4c4107790cd4360d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48ed72a45c884dfc7b98aaf6cf6fb6747c27c30d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48ed72a45c884dfc7b98aaf6cf6fb6747c27c30d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48ed72a45c884dfc7b98aaf6cf6fb6747c27c30d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48ed72a45c884dfc7b98aaf6cf6fb6747c27c30d/comments", "author": null, "committer": null, "parents": [{"sha": "ba591f5a882f10537db190126830fee42af14448", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba591f5a882f10537db190126830fee42af14448", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba591f5a882f10537db190126830fee42af14448"}], "stats": {"total": 170, "additions": 122, "deletions": 48}, "files": [{"sha": "846c74d7e5eecd0eab77ab4be724bc066eeb9ab6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48ed72a45c884dfc7b98aaf6cf6fb6747c27c30d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48ed72a45c884dfc7b98aaf6cf6fb6747c27c30d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48ed72a45c884dfc7b98aaf6cf6fb6747c27c30d", "patch": "@@ -1,3 +1,15 @@\n+2003-10-11  Peter Barada <peter@baradas.org>\n+\t    Bernardo Innocenti  <bernie@develer.com>\n+\n+\t* config/m68k/m68k.c (m68k_frame): Move before protos referencing it.\n+\t(m68k_save_reg): Add boolean parameter `interrupt_handler'.\n+\t(m68k_interrupt_function_p): New function.\n+\t(m68k_handle_fndecl_attribute): Ditto.\n+\t(m68k_compute_frame_layout): Ditto.\n+\t(m68k_attribute_table): Define back-end specific attributes.\n+\t(m68k_output_function_epilogue): Emit RTE instruction for interrupt\n+\tfunctions.\n+\n 2003-10-11  Bernardo Innocenti  <bernie@develer.com>\n \n \t* config/m68k/t-uclinux: New target Makefile fragment.\n@@ -46,18 +58,6 @@\n \t* gcc/config/m68k/m68k.md (call): Call m68k_output_pic_call().\n \t(call_value): Likewise.\n \n-2003-10-11  Peter Barada <peter@baradas.org>\n-\t    Bernardo Innocenti  <bernie@develer.com>\n-\n-\t* config/m68k/m68k.c (m68k_frame): Move before protos referencing it.\n-\t(m68k_save_reg): Add boolean parameter `interrupt_handler'.\n-\t(m68k_interrupt_function_p): New function.\n-\t(m68k_handle_fndecl_attribute): Ditto.\n-\t(m68k_compute_frame_layout): Ditto.\n-\t(m68k_attribute_table): Define back-end specific attributes.\n-\t(m68k_output_function_epilogue): Emit RTE instruction for interrupt\n-\tfunctions.\n-\n 2003-10-10  Zack Weinberg  <zack@codesourcery.com>\n \n \t* gengenrtl.c (find_formats, genheader): Make i an unsigned"}, {"sha": "dfa79ba7d3a4b2f9c9f826c5a615bab6dea79505", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 110, "deletions": 36, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48ed72a45c884dfc7b98aaf6cf6fb6747c27c30d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48ed72a45c884dfc7b98aaf6cf6fb6747c27c30d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=48ed72a45c884dfc7b98aaf6cf6fb6747c27c30d", "patch": "@@ -45,6 +45,23 @@ Boston, MA 02111-1307, USA.  */\n /* Needed for use_return_insn.  */\n #include \"flags.h\"\n \n+/* Structure describing stack frame layout. */\n+struct m68k_frame {\n+  HOST_WIDE_INT offset;\n+  HOST_WIDE_INT size;\n+  /* data and address register */\n+  int reg_no;\n+  unsigned int reg_mask;\n+  unsigned int reg_rev_mask;\n+  /* fpu registers */\n+  int fpu_no;\n+  unsigned int fpu_mask;\n+  unsigned int fpu_rev_mask;\n+  /* offsets relative to ARG_POINTER.  */\n+  HOST_WIDE_INT frame_pointer_offset;\n+  HOST_WIDE_INT stack_pointer_offset;\n+};\n+\n /* This flag is used to communicate between movhi and ASM_OUTPUT_CASE_END,\n    if SGS_SWITCH_TABLE.  */\n int switch_table_difference_label_flag;\n@@ -62,7 +79,12 @@ static void m68k_hp320_file_start (void);\n #endif\n static void m68k_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t\t  HOST_WIDE_INT, tree);\n-static int m68k_save_reg (unsigned int);\n+static bool m68k_interrupt_function_p (tree func);\n+static tree m68k_handle_fndecl_attribute (tree *node, tree name,\n+\t\t\t\t\t  tree args, int flags,\n+\t\t\t\t\t  bool *no_add_attrs);\n+static void m68k_compute_frame_layout (struct m68k_frame *frame);\n+static bool m68k_save_reg (unsigned int regno, bool interrupt_handler);\n static int const_int_cost (rtx);\n static bool m68k_rtx_costs (rtx, int, int, int *);\n \f\n@@ -139,6 +161,16 @@ int m68k_last_compare_had_fp_operands;\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS m68k_rtx_costs\n \n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE m68k_attribute_table\n+\n+static const struct attribute_spec m68k_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"interrupt_handler\", 0, 0, true,  false, false, m68k_handle_fndecl_attribute },\n+  { NULL,                0, 0, false, false, false, NULL }\n+};\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Sometimes certain combinations of command options do not make\n@@ -249,36 +281,50 @@ override_options (void)\n   REAL_MODE_FORMAT (XFmode) = &ieee_extended_motorola_format;\n }\n \f\n-/* Structure describing stack frame layout. */\n-struct m68k_frame {\n-  HOST_WIDE_INT offset;\n-  HOST_WIDE_INT size;\n-  /* data and address register */\n-  int reg_no;\n-  unsigned int reg_mask;\n-  unsigned int reg_rev_mask;\n-  /* fpu registers */\n-  int fpu_no;\n-  unsigned int fpu_mask;\n-  unsigned int fpu_rev_mask;\n-  /* fpa registers */\n-  int fpa_no;\n-  /* offsets relative to ARG_POINTER.  */\n-  HOST_WIDE_INT frame_pointer_offset;\n-  HOST_WIDE_INT stack_pointer_offset;\n-};\n+/* Return nonzero if FUNC is an interrupt function as specified by the\n+   \"interrupt_handler\" attribute.  */\n+static bool\n+m68k_interrupt_function_p(tree func)\n+{\n+  tree a;\n+\n+  if (TREE_CODE (func) != FUNCTION_DECL)\n+    return false;\n+\n+  a = lookup_attribute (\"interrupt_handler\", DECL_ATTRIBUTES (func));\n+  return (a != NULL_TREE);\n+}\n+\n+/* Handle an attribute requiring a FUNCTION_DECL; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+m68k_handle_fndecl_attribute (tree *node, tree name,\n+\t\t\t      tree args ATTRIBUTE_UNUSED,\n+\t\t\t      int flags ATTRIBUTE_UNUSED,\n+\t\t\t      bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (\"`%s' attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n \n static void\n m68k_compute_frame_layout (struct m68k_frame *frame)\n {\n   int regno, saved;\n   unsigned int mask, rmask;\n+  bool interrupt_handler = m68k_interrupt_function_p (current_function_decl);\n \n   frame->size = (get_frame_size () + 3) & -4;\n \n   mask = rmask = saved = 0;\n   for (regno = 0; regno < 16; regno++)\n-    if (m68k_save_reg (regno))\n+    if (m68k_save_reg (regno, interrupt_handler))\n       {\n \tmask |= 1 << regno;\n \trmask |= 1 << (15 - regno);\n@@ -327,13 +373,13 @@ m68k_initial_elimination_offset (int from, int to)\n   abort();\n }\n \n-/* Return 1 if we need to save REGNO.  */\n-static int\n-m68k_save_reg (unsigned int regno)\n+/* Return true if we need to save REGNO. */\n+static bool\n+m68k_save_reg (unsigned int regno, bool interrupt_handler)\n {\n   if (flag_pic && current_function_uses_pic_offset_table\n       && regno == PIC_OFFSET_TABLE_REGNUM)\n-    return 1;\n+    return true;\n \n   if (current_function_calls_eh_return)\n     {\n@@ -344,14 +390,35 @@ m68k_save_reg (unsigned int regno)\n \t  if (test == INVALID_REGNUM)\n \t    break;\n \t  if (test == regno)\n-\t    return 1;\n+\t    return true;\n \t}\n     }\n \n-  return (regs_ever_live[regno]\n-\t  && !call_used_regs[regno]\n-\t  && !fixed_regs[regno]\n-\t  && !(regno == FRAME_POINTER_REGNUM && frame_pointer_needed));\n+  /* Fixed regs we never touch.  */\n+  if (fixed_regs[regno])\n+    return false;\n+\n+  /* The frame pointer (if it is such) is handled specially.  */\n+  if (regno == FRAME_POINTER_REGNUM && frame_pointer_needed)\n+    return false;\n+\n+  /* Interrupt handlers must also save call_used_regs\n+     if they are live or when calling nested functions.  */\n+  if (interrupt_handler)\n+  {\n+     if (regs_ever_live[regno])\n+       return true;\n+\n+     if (!current_function_is_leaf && call_used_regs[regno])\n+       return true;\n+  }\n+\n+  /* Never need to save registers that aren't touched.  */\n+  if (!regs_ever_live[regno])\n+    return false;\n+\n+  /* Otherwise save everthing that isn't call-clobbered.  */\n+  return !call_used_regs[regno];\n }\n \n /* This function generates the assembly code for function entry.\n@@ -375,6 +442,7 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n   HOST_WIDE_INT fsize = (size + 3) & -4;\n   HOST_WIDE_INT fsize_with_regs;\n   HOST_WIDE_INT cfa_offset = INCOMING_FRAME_SP_OFFSET;\n+  bool interrupt_handler = m68k_interrupt_function_p (current_function_decl);\n   \n   /* If the stack limit is a symbol, we can check it here,\n      before actually allocating the space.  */\n@@ -394,7 +462,7 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n     {\n       /* on Coldfire add register save into initial stack frame setup, if possible */\n       for (regno = 0; regno < 16; regno++)\n-        if (m68k_save_reg (regno))\n+        if (m68k_save_reg (regno, interrupt_handler))\n           num_saved_regs++;\n \n       if (num_saved_regs <= 2)\n@@ -541,7 +609,7 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n   if (TARGET_68881)\n     {\n       for (regno = 16; regno < 24; regno++)\n-\tif (m68k_save_reg (regno))\n+\tif (m68k_save_reg (regno, interrupt_handler))\n \t  {\n \t    mask |= 1 << (regno - 16);\n \t    num_saved_regs++;\n@@ -571,7 +639,7 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size)\n       num_saved_regs = 0;\n     }\n   for (regno = 0; regno < 16; regno++)\n-    if (m68k_save_reg (regno))\n+    if (m68k_save_reg (regno, interrupt_handler))\n       {\n         mask |= 1 << (15 - regno);\n         num_saved_regs++;\n@@ -706,12 +774,15 @@ int\n use_return_insn ()\n {\n   int regno;\n+  bool interrupt_handler;\n \n   if (!reload_completed || frame_pointer_needed || get_frame_size () != 0)\n     return 0;\n   \n+  interrupt_handler = m68k_interrupt_function_p (current_function_decl);\n+\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (m68k_save_reg (regno))\n+    if (m68k_save_reg (regno, interrupt_handler))\n       return 0;\n \n   return 1;\n@@ -737,6 +808,7 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n   int big = 0;\n   rtx insn = get_last_insn ();\n   int restore_from_sp = 0;\n+  bool interrupt_handler = m68k_interrupt_function_p (current_function_decl);\n   \n   /* If the last insn was a BARRIER, we don't have to write any code.  */\n   if (GET_CODE (insn) == NOTE)\n@@ -756,7 +828,7 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n   if (TARGET_68881)\n     {\n       for (regno = 16; regno < 24; regno++)\n-\tif (m68k_save_reg (regno))\n+\tif (m68k_save_reg (regno, interrupt_handler))\n \t  {\n \t    nregs++;\n \t    fmask |= 1 << (23 - regno);\n@@ -765,7 +837,7 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n   foffset = nregs * 12;\n   nregs = 0;  mask = 0;\n   for (regno = 0; regno < 16; regno++)\n-    if (m68k_save_reg (regno))\n+    if (m68k_save_reg (regno, interrupt_handler))\n       {\n         nregs++;\n \tmask |= 1 << regno;\n@@ -1053,7 +1125,9 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n       asm_fprintf (stream, \"\\taddl %Ra0,%Rsp\\n\");\n #endif\n     }\n-  if (current_function_pops_args)\n+  if (interrupt_handler)\n+    fprintf (stream, \"\\trte\\n\");\n+  else if (current_function_pops_args)\n     asm_fprintf (stream, \"\\trtd %I%d\\n\", current_function_pops_args);\n   else\n     fprintf (stream, \"\\trts\\n\");"}]}