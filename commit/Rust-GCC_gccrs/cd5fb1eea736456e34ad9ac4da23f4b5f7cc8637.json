{"sha": "cd5fb1eea736456e34ad9ac4da23f4b5f7cc8637", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q1ZmIxZWVhNzM2NDU2ZTM0YWQ5YWM0ZGEyM2Y0YjVmN2NjODYzNw==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1995-02-08T20:07:24Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1995-02-08T20:07:24Z"}, "message": "sparc.c (v9_regcmp_p): New function.\n\n\t* sparc/sparc.c (v9_regcmp_p): New function.\n\t(v9_regcmp_op): Call it.\n\t* sparc/sparc.md (movsicc): New pattern.\n\t(movdicc, movsfcc, movdfcc, movtfcc): Likewise.\n\nFrom-SVN: r8895", "tree": {"sha": "e9f55d434d9e5fd066bc47b7745a00e87ecb4fd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9f55d434d9e5fd066bc47b7745a00e87ecb4fd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd5fb1eea736456e34ad9ac4da23f4b5f7cc8637", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd5fb1eea736456e34ad9ac4da23f4b5f7cc8637", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd5fb1eea736456e34ad9ac4da23f4b5f7cc8637", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd5fb1eea736456e34ad9ac4da23f4b5f7cc8637/comments", "author": null, "committer": null, "parents": [{"sha": "5b26b12e46b07208e81d3d1e5ed063b202b75798", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b26b12e46b07208e81d3d1e5ed063b202b75798", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b26b12e46b07208e81d3d1e5ed063b202b75798"}], "stats": {"total": 151, "additions": 149, "deletions": 2}, "files": [{"sha": "f93f7940474c11e55d003f87fc200da570997d98", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5fb1eea736456e34ad9ac4da23f4b5f7cc8637/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5fb1eea736456e34ad9ac4da23f4b5f7cc8637/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=cd5fb1eea736456e34ad9ac4da23f4b5f7cc8637", "patch": "@@ -187,6 +187,21 @@ sparc64_fpconv_stack_temp ()\n     return fpconv_stack_temp;\n }\n \f\n+/* Miscellaneous utilities.  */\n+\n+/* Nonzero if CODE, a comparison, is suitable for use in v9 conditional move\n+   or branch on register contents instructions.  */\n+\n+int\n+v9_regcmp_p (code)\n+     enum rtx_code code;\n+{\n+  return (code == EQ || code == NE || code == GE || code == LT\n+\t  || code == LE || code == GT);\n+}\n+\f\n+/* Operand constraints.  */\n+\n /* Return non-zero only if OP is a register of mode MODE,\n    or const0_rtx.  */\n int\n@@ -524,8 +539,7 @@ v9_regcmp_op (op, mode)\n   if (GET_RTX_CLASS (code) != '<')\n     return 0;\n \n-  return (code == EQ || code == NE || code == GE || code == LT\n-\t  || code == LE || code == GT);\n+  return v9_regcmp_p (code);\n }\n \n /* Return 1 if this is a SIGN_EXTEND or ZERO_EXTEND operation.  */"}, {"sha": "31f034f253245f3351b79bf0c77289bfcf76e984", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5fb1eea736456e34ad9ac4da23f4b5f7cc8637/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5fb1eea736456e34ad9ac4da23f4b5f7cc8637/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=cd5fb1eea736456e34ad9ac4da23f4b5f7cc8637", "patch": "@@ -2184,6 +2184,139 @@\n \f\n ;; Sparc V9 conditional move instructions.\n \n+;; We can handle larger constants here for some flavors, but for now we play\n+;; it safe and only allow those constants supported by all flavours.\n+\n+(define_expand \"movsicc\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(if_then_else (match_operand 1 \"comparison_operator\" \"\")\n+\t\t      (match_operand:SI 2 \"arith10_operand\" \"\")\n+\t\t      (match_operand:SI 3 \"arith10_operand\" \"\")))]\n+  \"TARGET_V9\"\n+  \"\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n+\n+  if (sparc_compare_op1 == const0_rtx\n+      && GET_CODE (sparc_compare_op0) == REG\n+      && GET_MODE (sparc_compare_op0) == DImode\n+      && v9_regcmp_p (code))\n+    {\n+      operands[1] = gen_rtx (code, DImode,\n+\t\t\t     sparc_compare_op0, sparc_compare_op1);\n+    }\n+  else\n+    {\n+      rtx cc_reg = gen_compare_reg (code,\n+\t\t\t\t    sparc_compare_op0, sparc_compare_op1);\n+      operands[1] = gen_rtx (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n+    }\n+}\")\n+\n+(define_expand \"movdicc\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(if_then_else (match_operand 1 \"comparison_operator\" \"\")\n+\t\t      (match_operand:DI 2 \"arith10_operand\" \"\")\n+\t\t      (match_operand:DI 3 \"arith10_operand\" \"\")))]\n+  \"TARGET_V9\"\n+  \"\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n+\n+  if (sparc_compare_op1 == const0_rtx\n+      && GET_CODE (sparc_compare_op0) == REG\n+      && GET_MODE (sparc_compare_op0) == DImode\n+      && v9_regcmp_p (code))\n+    {\n+      operands[1] = gen_rtx (code, DImode,\n+\t\t\t     sparc_compare_op0, sparc_compare_op1);\n+    }\n+  else\n+    {\n+      rtx cc_reg = gen_compare_reg (code,\n+\t\t\t\t    sparc_compare_op0, sparc_compare_op1);\n+      operands[1] = gen_rtx (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n+    }\n+}\")\n+\n+(define_expand \"movsfcc\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(if_then_else (match_operand 1 \"comparison_operator\" \"\")\n+\t\t      (match_operand:SF 2 \"register_operand\" \"\")\n+\t\t      (match_operand:SF 3 \"register_operand\" \"\")))]\n+  \"TARGET_V9\"\n+  \"\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n+\n+  if (sparc_compare_op1 == const0_rtx\n+      && GET_CODE (sparc_compare_op0) == REG\n+      && GET_MODE (sparc_compare_op0) == DImode\n+      && v9_regcmp_p (code))\n+    {\n+      operands[1] = gen_rtx (code, DImode,\n+\t\t\t     sparc_compare_op0, sparc_compare_op1);\n+    }\n+  else\n+    {\n+      rtx cc_reg = gen_compare_reg (code,\n+\t\t\t\t    sparc_compare_op0, sparc_compare_op1);\n+      operands[1] = gen_rtx (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n+    }\n+}\")\n+\n+(define_expand \"movdfcc\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(if_then_else (match_operand 1 \"comparison_operator\" \"\")\n+\t\t      (match_operand:DF 2 \"register_operand\" \"\")\n+\t\t      (match_operand:DF 3 \"register_operand\" \"\")))]\n+  \"TARGET_V9\"\n+  \"\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n+\n+  if (sparc_compare_op1 == const0_rtx\n+      && GET_CODE (sparc_compare_op0) == REG\n+      && GET_MODE (sparc_compare_op0) == DImode\n+      && v9_regcmp_p (code))\n+    {\n+      operands[1] = gen_rtx (code, DImode,\n+\t\t\t     sparc_compare_op0, sparc_compare_op1);\n+    }\n+  else\n+    {\n+      rtx cc_reg = gen_compare_reg (code,\n+\t\t\t\t    sparc_compare_op0, sparc_compare_op1);\n+      operands[1] = gen_rtx (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n+    }\n+}\")\n+\n+(define_expand \"movtfcc\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+\t(if_then_else (match_operand 1 \"comparison_operator\" \"\")\n+\t\t      (match_operand:TF 2 \"register_operand\" \"\")\n+\t\t      (match_operand:TF 3 \"register_operand\" \"\")))]\n+  \"TARGET_V9\"\n+  \"\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n+\n+  if (sparc_compare_op1 == const0_rtx\n+      && GET_CODE (sparc_compare_op0) == REG\n+      && GET_MODE (sparc_compare_op0) == DImode\n+      && v9_regcmp_p (code))\n+    {\n+      operands[1] = gen_rtx (code, DImode,\n+\t\t\t     sparc_compare_op0, sparc_compare_op1);\n+    }\n+  else\n+    {\n+      rtx cc_reg = gen_compare_reg (code,\n+\t\t\t\t    sparc_compare_op0, sparc_compare_op1);\n+      operands[1] = gen_rtx (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n+    }\n+}\")\n+\n ; ??? There is not actually a 32 bit version of this instruction.\n (define_insn \"*movsi_cc_sp64\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")"}]}