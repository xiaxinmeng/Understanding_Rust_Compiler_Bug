{"sha": "898d374de9cf27f34508f835a6ec18d9686d6d6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk4ZDM3NGRlOWNmMjdmMzQ1MDhmODM1YTZlYzE4ZDk2ODZkNmQ2ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-04-03T17:44:45Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-04-03T17:44:45Z"}, "message": "i386.c (ix86_force_to_memory, [...]): Update for 64bit.\n\n\t* i386.c (ix86_force_to_memory, ix86_free_from_memory):\n\tUpdate for 64bit.\n\nFrom-SVN: r41062", "tree": {"sha": "cef9c68ea563e32464f51c7c75ba8f84a0da11e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cef9c68ea563e32464f51c7c75ba8f84a0da11e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/898d374de9cf27f34508f835a6ec18d9686d6d6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/898d374de9cf27f34508f835a6ec18d9686d6d6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/898d374de9cf27f34508f835a6ec18d9686d6d6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/898d374de9cf27f34508f835a6ec18d9686d6d6d/comments", "author": null, "committer": null, "parents": [{"sha": "547a559d0173843b660dcb152b53728deb25f2d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/547a559d0173843b660dcb152b53728deb25f2d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/547a559d0173843b660dcb152b53728deb25f2d8"}], "stats": {"total": 126, "additions": 86, "deletions": 40}, "files": [{"sha": "51099bee09e6e77e99755f7c8f8c87e0c93debe6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/898d374de9cf27f34508f835a6ec18d9686d6d6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/898d374de9cf27f34508f835a6ec18d9686d6d6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=898d374de9cf27f34508f835a6ec18d9686d6d6d", "patch": "@@ -1,3 +1,8 @@\n+Tue Apr  3 19:41:21 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (ix86_force_to_memory, ix86_free_from_memory):\n+\tUpdate for 64bit.\n+\n 2001-04-03  Zack Weinberg  <zackw@stanford.edu>\n \n \t* config/i386/xm-beos.h, config/i386/xm-isc.h,"}, {"sha": "c50761cafc70f2ea7a5a15316200955343d3195e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 81, "deletions": 40, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/898d374de9cf27f34508f835a6ec18d9686d6d6d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/898d374de9cf27f34508f835a6ec18d9686d6d6d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=898d374de9cf27f34508f835a6ec18d9686d6d6d", "patch": "@@ -10147,61 +10147,102 @@ ix86_force_to_memory (mode, operand)\n      enum machine_mode mode;\n      rtx operand;\n {\n+  rtx result;\n   if (!reload_completed)\n     abort ();\n-  switch (mode)\n+  if (TARGET_64BIT && TARGET_RED_ZONE)\n+    {\n+      result = gen_rtx_MEM (mode,\n+\t\t\t    gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t  GEN_INT (-RED_ZONE_SIZE)));\n+      emit_move_insn (result, operand);\n+    }\n+  else if (TARGET_64BIT && !TARGET_RED_ZONE)\n     {\n-      case DImode:\n+      switch (mode)\n \t{\n-\t  rtx operands[2];\n-\t  split_di (&operand, 1, operands, operands+1);\n+\tcase HImode:\n+\tcase SImode:\n+\t  operand = gen_lowpart (DImode, operand);\n+\t  /* FALLTHRU */\n+\tcase DImode:\n \t  emit_insn (\n-\t    gen_rtx_SET (VOIDmode,\n-\t\t\t gen_rtx_MEM (SImode,\n-\t\t\t\t      gen_rtx_PRE_DEC (Pmode,\n-\t\t\t\t\t\t       stack_pointer_rtx)),\n-\t\t\t operands[1]));\n+\t\t      gen_rtx_SET (VOIDmode,\n+\t\t\t\t   gen_rtx_MEM (DImode,\n+\t\t\t\t\t\tgen_rtx_PRE_DEC (DImode,\n+\t\t\t\t\t\t\tstack_pointer_rtx)),\n+\t\t\t\t   operand));\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      result = gen_rtx_MEM (mode, stack_pointer_rtx);\n+    }\n+  else\n+    {\n+      switch (mode)\n+\t{\n+\tcase DImode:\n+\t  {\n+\t    rtx operands[2];\n+\t    split_di (&operand, 1, operands, operands + 1);\n+\t    emit_insn (\n+\t\t\tgen_rtx_SET (VOIDmode,\n+\t\t\t\t     gen_rtx_MEM (SImode,\n+\t\t\t\t\t\t  gen_rtx_PRE_DEC (Pmode,\n+\t\t\t\t\t\t\tstack_pointer_rtx)),\n+\t\t\t\t     operands[1]));\n+\t    emit_insn (\n+\t\t\tgen_rtx_SET (VOIDmode,\n+\t\t\t\t     gen_rtx_MEM (SImode,\n+\t\t\t\t\t\t  gen_rtx_PRE_DEC (Pmode,\n+\t\t\t\t\t\t\tstack_pointer_rtx)),\n+\t\t\t\t     operands[0]));\n+\t  }\n+\t  break;\n+\tcase HImode:\n+\t  /* It is better to store HImodes as SImodes.  */\n+\t  if (!TARGET_PARTIAL_REG_STALL)\n+\t    operand = gen_lowpart (SImode, operand);\n+\t  /* FALLTHRU */\n+\tcase SImode:\n \t  emit_insn (\n-\t    gen_rtx_SET (VOIDmode,\n-\t\t\t gen_rtx_MEM (SImode,\n-\t\t\t\t      gen_rtx_PRE_DEC (Pmode,\n-\t\t\t\t\t\t       stack_pointer_rtx)),\n-\t\t\t operands[0]));\n+\t\t      gen_rtx_SET (VOIDmode,\n+\t\t\t\t   gen_rtx_MEM (GET_MODE (operand),\n+\t\t\t\t\t\tgen_rtx_PRE_DEC (SImode,\n+\t\t\t\t\t\t\tstack_pointer_rtx)),\n+\t\t\t\t   operand));\n+\t  break;\n+\tdefault:\n+\t  abort ();\n \t}\n-\tbreak;\n-      case HImode:\n-\t/* It is better to store HImodes as SImodes.  */\n-\tif (!TARGET_PARTIAL_REG_STALL)\n-\t  operand = gen_lowpart (SImode, operand);\n-\t/* FALLTHRU */\n-      case SImode:\n-\temit_insn (\n-\t  gen_rtx_SET (VOIDmode,\n-\t\t       gen_rtx_MEM (GET_MODE (operand),\n-\t\t\t\t    gen_rtx_PRE_DEC (SImode,\n-\t\t\t\t\t\t     stack_pointer_rtx)),\n-\t\t       operand));\n-\tbreak;\n-      default:\n-\tabort();\n+      result = gen_rtx_MEM (mode, stack_pointer_rtx);\n     }\n-  return gen_rtx_MEM (mode, stack_pointer_rtx);\n+  return result;\n }\n \n /* Free operand from the memory.  */\n void\n ix86_free_from_memory (mode)\n      enum machine_mode mode;\n {\n-  /* Use LEA to deallocate stack space.  In peephole2 it will be converted\n-     to pop or add instruction if registers are available.  */\n-  emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t  gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t\t\tGEN_INT (mode == DImode\n-\t\t\t\t\t\t ? 8\n-\t\t\t\t\t\t : mode == HImode && TARGET_PARTIAL_REG_STALL\n-\t\t\t\t\t\t ? 2\n-\t\t\t\t\t\t : 4))));\n+  if (!TARGET_64BIT || !TARGET_RED_ZONE)\n+    {\n+      int size;\n+\n+      if (mode == DImode || TARGET_64BIT)\n+\tsize = 8;\n+      else if (mode == HImode && TARGET_PARTIAL_REG_STALL)\n+\tsize = 2;\n+      else\n+\tsize = 4;\n+      /* Use LEA to deallocate stack space.  In peephole2 it will be converted\n+         to pop or add instruction if registers are available.  */\n+      emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t      gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t    GEN_INT (size))));\n+    }\n }\n \n /* Put float CONST_DOUBLE in the constant pool instead of fp regs."}]}