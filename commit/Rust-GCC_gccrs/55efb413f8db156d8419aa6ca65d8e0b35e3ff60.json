{"sha": "55efb413f8db156d8419aa6ca65d8e0b35e3ff60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVlZmI0MTNmOGRiMTU2ZDg0MTlhYTZjYTY1ZDhlMGIzNWUzZmY2MA==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "2000-08-23T03:54:23Z"}, "committer": {"name": "John Wehle", "email": "wehle@gcc.gnu.org", "date": "2000-08-23T03:54:23Z"}, "message": "rtlanal.c (rtx_unstable_p): The pic register is stable (within one function) and the actual rtx should be...\n\n\t* rtlanal.c (rtx_unstable_p): The pic register is stable\n\t(within one function) and the actual rtx should be used\n\twhen checking the registers.\n\t(rtx_addr_can_trap_p): Pic memory addresses can't trap.\n\n\t* alias.c (true_dependence, write_dependence_p): Fix\n\tbug in previous patch.\n\n\t* i386.c (ix86_GOT_alias_set): New.\n\t(legitimize_pic_address): Use it.\n\n\t* rtlanal.c (rtx_unstable_p): An unchanging MEM is\n\tonly stable if its address is stable.\n\t(rtx_varies_p): An unchanging MEM can't vary if\n\tits address doesn't vary.\n\nFrom-SVN: r35900", "tree": {"sha": "b033d3e0a235bd6b290d0387a72344825b7163b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b033d3e0a235bd6b290d0387a72344825b7163b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55efb413f8db156d8419aa6ca65d8e0b35e3ff60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55efb413f8db156d8419aa6ca65d8e0b35e3ff60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55efb413f8db156d8419aa6ca65d8e0b35e3ff60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55efb413f8db156d8419aa6ca65d8e0b35e3ff60/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aac625acc6303ce268562ee24ca2cb6d220ea9a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aac625acc6303ce268562ee24ca2cb6d220ea9a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aac625acc6303ce268562ee24ca2cb6d220ea9a4"}], "stats": {"total": 77, "additions": 56, "deletions": 21}, "files": [{"sha": "cef575916e19c97a94c76ad3acd3b370397974ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55efb413f8db156d8419aa6ca65d8e0b35e3ff60/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55efb413f8db156d8419aa6ca65d8e0b35e3ff60/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55efb413f8db156d8419aa6ca65d8e0b35e3ff60", "patch": "@@ -1,3 +1,21 @@\n+Tue Aug 22 23:53:27 EDT 2000  John Wehle  (john@feith.com)\n+\n+\t* rtlanal.c (rtx_unstable_p): The pic register is stable\n+\t(within one function) and the actual rtx should be used\n+\twhen checking the registers.\n+\t(rtx_addr_can_trap_p): Pic memory addresses can't trap.\n+\n+\t* alias.c (true_dependence, write_dependence_p): Fix\n+\tbug in previous patch.\n+\n+\t* i386.c (ix86_GOT_alias_set): New.\n+\t(legitimize_pic_address): Use it.\n+\n+\t* rtlanal.c (rtx_unstable_p): An unchanging MEM is\n+\tonly stable if its address is stable.\n+\t(rtx_varies_p): An unchanging MEM can't vary if\n+\tits address doesn't vary.\n+\n 2000-08-22  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* c-parse.in (unop +): Restrict -Wtraditional warnings to user code."}, {"sha": "5d96dad2df23f1951431a8cafed193316473e6cc", "filename": "gcc/alias.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55efb413f8db156d8419aa6ca65d8e0b35e3ff60/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55efb413f8db156d8419aa6ca65d8e0b35e3ff60/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=55efb413f8db156d8419aa6ca65d8e0b35e3ff60", "patch": "@@ -1584,18 +1584,18 @@ true_dependence (mem, mem_mode, x, varies)\n   if (RTX_UNCHANGING_P (x) && ! RTX_UNCHANGING_P (mem))\n     return 0;\n \n-  base = find_base_term (x);\n-  if (base && (GET_CODE (base) == LABEL_REF\n-\t       || (GET_CODE (base) == SYMBOL_REF\n-\t\t   && CONSTANT_POOL_ADDRESS_P (base))))\n-    return 0;\n-\n   if (mem_mode == VOIDmode)\n     mem_mode = GET_MODE (mem);\n \n   x_addr = get_addr (XEXP (x, 0));\n   mem_addr = get_addr (XEXP (mem, 0));\n \n+  base = find_base_term (x_addr);\n+  if (base && (GET_CODE (base) == LABEL_REF\n+\t       || (GET_CODE (base) == SYMBOL_REF\n+\t\t   && CONSTANT_POOL_ADDRESS_P (base))))\n+    return 0;\n+\n   if (! base_alias_check (x_addr, mem_addr, GET_MODE (x), mem_mode))\n     return 0;\n \n@@ -1645,22 +1645,21 @@ write_dependence_p (mem, x, writep)\n   /* If MEM is an unchanging read, then it can't possibly conflict with\n      the store to X, because there is at most one store to MEM, and it must\n      have occurred somewhere before MEM.  */\n+  if (! writep && RTX_UNCHANGING_P (mem))\n+    return 0;\n+\n+  x_addr = get_addr (XEXP (x, 0));\n+  mem_addr = get_addr (XEXP (mem, 0));\n+\n   if (! writep)\n     {\n-      if (RTX_UNCHANGING_P (mem))\n-\treturn 0;\n-\n-      base = find_base_term (mem);\n+      base = find_base_term (mem_addr);\n       if (base && (GET_CODE (base) == LABEL_REF\n \t\t   || (GET_CODE (base) == SYMBOL_REF\n \t\t       && CONSTANT_POOL_ADDRESS_P (base))))\n \treturn 0;\n     }\n \n-\n-  x_addr = get_addr (XEXP (x, 0));\n-  mem_addr = get_addr (XEXP (mem, 0));\n-\n   if (! base_alias_check (x_addr, mem_addr, GET_MODE (x),\n \t\t\t  GET_MODE (mem)))\n     return 0;"}, {"sha": "4c21a88a4d9194d618547b9ace293b859ea33717", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55efb413f8db156d8419aa6ca65d8e0b35e3ff60/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55efb413f8db156d8419aa6ca65d8e0b35e3ff60/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=55efb413f8db156d8419aa6ca65d8e0b35e3ff60", "patch": "@@ -427,6 +427,7 @@ static void ix86_emit_restore_regs_using_mov PARAMS ((rtx, int));\n static void ix86_emit_epilogue_esp_adjustment PARAMS((int));\n static void ix86_sched_reorder_pentium PARAMS((rtx *, rtx *));\n static void ix86_sched_reorder_ppro PARAMS((rtx *, rtx *));\n+static HOST_WIDE_INT ix86_GOT_alias_set PARAMS ((void));\n \n struct ix86_address\n {\n@@ -2553,6 +2554,17 @@ legitimate_address_p (mode, addr, strict)\n   return FALSE;\n }\n \f\n+/* Return an unique alias set for the GOT.  */\n+\n+static HOST_WIDE_INT   \n+ix86_GOT_alias_set ()\n+{\n+    static HOST_WIDE_INT set = -1;\n+    if (set == -1)\n+      set = new_alias_set ();\n+    return set;\n+}   \n+\n /* Return a legitimate reference for ORIG (an address) using the\n    register REG.  If REG is 0, a new pseudo is generated.\n \n@@ -2610,6 +2622,7 @@ legitimize_pic_address (orig, reg)\n       new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n       new = gen_rtx_MEM (Pmode, new);\n       RTX_UNCHANGING_P (new) = 1;\n+      MEM_ALIAS_SET (new) = ix86_GOT_alias_set ();\t\n \n       if (reg == 0)\n \treg = gen_reg_rtx (Pmode);"}, {"sha": "8424b8e2cde624dd1fefc79d8f4814cbba8f3444", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55efb413f8db156d8419aa6ca65d8e0b35e3ff60/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55efb413f8db156d8419aa6ca65d8e0b35e3ff60/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=55efb413f8db156d8419aa6ca65d8e0b35e3ff60", "patch": "@@ -53,7 +53,7 @@ rtx_unstable_p (x)\n   register const char *fmt;\n \n   if (code == MEM)\n-    return ! RTX_UNCHANGING_P (x);\n+    return ! RTX_UNCHANGING_P (x) || rtx_unstable_p (XEXP (x, 0));\n \n   if (code == QUEUED)\n     return 1;\n@@ -62,9 +62,9 @@ rtx_unstable_p (x)\n     return 0;\n \n   if (code == REG)\n-    return ! (REGNO (x) == FRAME_POINTER_REGNUM\n-\t      || REGNO (x) == HARD_FRAME_POINTER_REGNUM\n-\t      || REGNO (x) == ARG_POINTER_REGNUM\n+    /* As in rtx_varies_p, we have to use the actual rtx, not reg number.  */\n+    return ! (x == frame_pointer_rtx || x == hard_frame_pointer_rtx\n+\t      || x == arg_pointer_rtx || x == pic_offset_table_rtx\n \t      || RTX_UNCHANGING_P (x));\n \n   fmt = GET_RTX_FORMAT (code);\n@@ -101,6 +101,8 @@ rtx_varies_p (x)\n   switch (code)\n     {\n     case MEM:\n+      return ! RTX_UNCHANGING_P (x) || rtx_varies_p (XEXP (x, 0));\n+\n     case QUEUED:\n       return 1;\n \n@@ -174,9 +176,12 @@ rtx_addr_can_trap_p (x)\n \n     case PLUS:\n       /* An address is assumed not to trap if it is an address that can't\n-\t trap plus a constant integer.  */\n-      return (rtx_addr_can_trap_p (XEXP (x, 0))\n-\t      || GET_CODE (XEXP (x, 1)) != CONST_INT);\n+\t trap plus a constant integer or it is the pic register plus a\n+\t constant.  */\n+      return ! ((! rtx_addr_can_trap_p (XEXP (x, 0))\n+\t\t && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t\t|| (XEXP (x, 0) == pic_offset_table_rtx\n+\t\t    && CONSTANT_P (XEXP (x, 1))));\n \n     case LO_SUM:\n       return rtx_addr_can_trap_p (XEXP (x, 1));"}]}