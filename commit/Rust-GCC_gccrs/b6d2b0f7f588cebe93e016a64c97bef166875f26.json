{"sha": "b6d2b0f7f588cebe93e016a64c97bef166875f26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZkMmIwZjdmNTg4Y2ViZTkzZTAxNmE2NGM5N2JlZjE2Njg3NWYyNg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-07-24T17:18:00Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-07-24T17:18:00Z"}, "message": "For PR libgcj/7482:\n\n\t* verify.cc (ref_intersection): New class.\n\t(type_val): Removed unresolved_reference_type,\n\tuninitialized_unresolved_reference_type.\n\t(is_assignable_from_slow): Rewrote.\n\t(type::data): Removed.\n\t(type::klass): New field.\n\t(type::type): Added verifier argument.\n\t(type::resolve): Removed.\n\t(type::set_uninitialized): Updated for change to type_val.\n\t(type::set_initialized): Likewise.\n\t(type::isinitialized): Likewise.\n\t(type::print): Likewise.\n\t(construct_primitive_array_type): Likewise.\n\t(type::compatible): Updated for change to type_val and to use\n\tref_intersection.\n\t(type::isarray): Updated to use ref_intersection.\n\t(type::isinterface): Likewise.\n\t(type::element_type): Likewise.\n\t(type::to_array): Likewise.\n\t(type::verify_dimensions): Rewrote.\n\t(type::merge): Likewise.\n\t(check_class_constant): Updated for type constructor change.\n\t(check_constant): Likewise.\n\t(check_field_constant): Likewise.\n\t(get_one_type): Likewise.\n\t(initialize_stack): Likewise.\n\t(verify_instructions_0): Likewise.\n\t(verify_instructions_0) [op_invokeinterface]: Removed special\n\tcase.\n\t(isect_list): New field.\n\t(_Jv_BytecodeVerifier): Initialize it.\n\t(~_Jv_BytecodeVerifier): Destroy ref_intersection objects.\n\nFrom-SVN: r69751", "tree": {"sha": "60c45c4edc5ba1d4f54aabecbcdc5958638cb22d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60c45c4edc5ba1d4f54aabecbcdc5958638cb22d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6d2b0f7f588cebe93e016a64c97bef166875f26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6d2b0f7f588cebe93e016a64c97bef166875f26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6d2b0f7f588cebe93e016a64c97bef166875f26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6d2b0f7f588cebe93e016a64c97bef166875f26/comments", "author": null, "committer": null, "parents": [{"sha": "1c41b3d6cf500cf8fca39dba7b92367a8496ca32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c41b3d6cf500cf8fca39dba7b92367a8496ca32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c41b3d6cf500cf8fca39dba7b92367a8496ca32"}], "stats": {"total": 578, "additions": 346, "deletions": 232}, "files": [{"sha": "29f1cbf9f79b4727bfdc650f3af837501a89ec1a", "filename": "libjava/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d2b0f7f588cebe93e016a64c97bef166875f26/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d2b0f7f588cebe93e016a64c97bef166875f26/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b6d2b0f7f588cebe93e016a64c97bef166875f26", "patch": "@@ -1,3 +1,39 @@\n+2003-07-24  Tom Tromey  <tromey@redhat.com>\n+\n+\tFor PR libgcj/7482:\n+\t* verify.cc (ref_intersection): New class.\n+\t(type_val): Removed unresolved_reference_type,\n+\tuninitialized_unresolved_reference_type.\n+\t(is_assignable_from_slow): Rewrote.\n+\t(type::data): Removed.\n+\t(type::klass): New field.\n+\t(type::type): Added verifier argument.\n+\t(type::resolve): Removed.\n+\t(type::set_uninitialized): Updated for change to type_val.\n+\t(type::set_initialized): Likewise.\n+\t(type::isinitialized): Likewise.\n+\t(type::print): Likewise.\n+\t(construct_primitive_array_type): Likewise.\n+\t(type::compatible): Updated for change to type_val and to use\n+\tref_intersection.\n+\t(type::isarray): Updated to use ref_intersection.\n+\t(type::isinterface): Likewise.\n+\t(type::element_type): Likewise.\n+\t(type::to_array): Likewise.\n+\t(type::verify_dimensions): Rewrote.\n+\t(type::merge): Likewise.\n+\t(check_class_constant): Updated for type constructor change.\n+\t(check_constant): Likewise.\n+\t(check_field_constant): Likewise.\n+\t(get_one_type): Likewise.\n+\t(initialize_stack): Likewise.\n+\t(verify_instructions_0): Likewise.\n+\t(verify_instructions_0) [op_invokeinterface]: Removed special\n+\tcase.\n+\t(isect_list): New field.\n+\t(_Jv_BytecodeVerifier): Initialize it.\n+\t(~_Jv_BytecodeVerifier): Destroy ref_intersection objects. \n+\n 2003-07-24  H. V\ufffdis\ufffdnen  <hvaisane@joyx.joensuu.fi>\n \n \t* java/text/SimpleDateFormat.java (format) [YEAR_FIELD]: Zero pad"}, {"sha": "ba408aa98bee90f669c9580c662b1bafb23726b0", "filename": "libjava/verify.cc", "status": "modified", "additions": 310, "deletions": 232, "changes": 542, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d2b0f7f588cebe93e016a64c97bef166875f26/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d2b0f7f588cebe93e016a64c97bef166875f26/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=b6d2b0f7f588cebe93e016a64c97bef166875f26", "patch": "@@ -1,4 +1,4 @@\n-// defineclass.cc - defining a class from .class format.\n+// verify.cc - verify bytecode\n \n /* Copyright (C) 2001, 2002, 2003  Free Software Foundation\n \n@@ -58,6 +58,7 @@ class _Jv_BytecodeVerifier\n   struct subr_info;\n   struct subr_entry_info;\n   struct linked_utf8;\n+  struct ref_intersection;\n \n   // The current PC.\n   int PC;\n@@ -104,6 +105,9 @@ class _Jv_BytecodeVerifier\n   // but without this our utf8 objects would be collected.\n   linked_utf8 *utf8_list;\n \n+  // A linked list of all ref_intersection objects we allocate.\n+  ref_intersection *isect_list;\n+\n   struct linked_utf8\n   {\n     _Jv_Utf8Const *val;\n@@ -189,9 +193,219 @@ class _Jv_BytecodeVerifier\n     // Everything after `reference_type' must be a reference type.\n     reference_type,\n     null_type,\n-    unresolved_reference_type,\n-    uninitialized_reference_type,\n-    uninitialized_unresolved_reference_type\n+    uninitialized_reference_type\n+  };\n+\n+  // This represents a merged class type.  Some verifiers (including\n+  // earlier versions of this one) will compute the intersection of\n+  // two class types when merging states.  However, this loses\n+  // critical information about interfaces implemented by the various\n+  // classes.  So instead we keep track of all the actual classes that\n+  // have been merged.\n+  struct ref_intersection\n+  {\n+    // Whether or not this type has been resolved.\n+    bool is_resolved;\n+\n+    // Actual type data.\n+    union\n+    {\n+      // For a resolved reference type, this is a pointer to the class.\n+      jclass klass;\n+      // For other reference types, this it the name of the class.\n+      _Jv_Utf8Const *name;\n+    } data;\n+\n+    // Link to the next reference in the intersection.\n+    ref_intersection *ref_next;\n+\n+    // This is used to keep track of all the allocated\n+    // ref_intersection objects, so we can free them.\n+    // FIXME: we should allocate these in chunks.\n+    ref_intersection *alloc_next;\n+\n+    ref_intersection (jclass klass, _Jv_BytecodeVerifier *verifier)\n+      : ref_next (NULL)\n+    {\n+      is_resolved = true;\n+      data.klass = klass;\n+      alloc_next = verifier->isect_list;\n+      verifier->isect_list = this;\n+    }\n+\n+    ref_intersection (_Jv_Utf8Const *name, _Jv_BytecodeVerifier *verifier)\n+      : ref_next (NULL)\n+    {\n+      is_resolved = false;\n+      data.name = name;\n+      alloc_next = verifier->isect_list;\n+      verifier->isect_list = this;\n+    }\n+\n+    ref_intersection (ref_intersection *dup, ref_intersection *tail,\n+\t\t      _Jv_BytecodeVerifier *verifier)\n+      : ref_next (tail)\n+    {\n+      is_resolved = dup->is_resolved;\n+      data = dup->data;\n+      alloc_next = verifier->isect_list;\n+      verifier->isect_list = this;\n+    }\n+\n+    bool equals (ref_intersection *other, _Jv_BytecodeVerifier *verifier)\n+    {\n+      if (! is_resolved && ! other->is_resolved\n+\t  && _Jv_equalUtf8Consts (data.name, other->data.name))\n+\treturn true;\n+      if (! is_resolved)\n+\tresolve (verifier);\n+      if (! other->is_resolved)\n+\tother->resolve (verifier);\n+      return data.klass == other->data.klass;\n+    }\n+\n+    // Merge THIS type into OTHER, returning the result.  This will\n+    // return OTHER if all the classes in THIS already appear in\n+    // OTHER.\n+    ref_intersection *merge (ref_intersection *other,\n+\t\t\t     _Jv_BytecodeVerifier *verifier)\n+    {\n+      ref_intersection *tail = other;\n+      for (ref_intersection *self = this; self != NULL; self = self->ref_next)\n+\t{\n+\t  bool add = true;\n+\t  for (ref_intersection *iter = other; iter != NULL;\n+\t       iter = iter->ref_next)\n+\t    {\n+\t      if (iter->equals (self, verifier))\n+\t\t{\n+\t\t  add = false;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  if (add)\n+\t    tail = new ref_intersection (self, tail, verifier);\n+\t}\n+      return tail;\n+    }\n+\n+    void resolve (_Jv_BytecodeVerifier *verifier)\n+    {\n+      if (is_resolved)\n+\treturn;\n+\n+      using namespace java::lang;\n+      java::lang::ClassLoader *loader\n+\t= verifier->current_class->getClassLoaderInternal();\n+      // We might see either kind of name.  Sigh.\n+      if (data.name->data[0] == 'L'\n+\t  && data.name->data[data.name->length - 1] == ';')\n+\tdata.klass = _Jv_FindClassFromSignature (data.name->data, loader);\n+      else\n+\tdata.klass = Class::forName (_Jv_NewStringUtf8Const (data.name),\n+\t\t\t\t     false, loader);\n+      is_resolved = true;\n+    }\n+\n+    // See if an object of type OTHER can be assigned to an object of\n+    // type *THIS.  This might resolve classes in one chain or the\n+    // other.\n+    bool compatible (ref_intersection *other,\n+\t\t     _Jv_BytecodeVerifier *verifier)\n+    {\n+      ref_intersection *self = this;\n+\n+      for (; self != NULL; self = self->ref_next)\n+\t{\n+\t  ref_intersection *other_iter = other;\n+\n+\t  for (; other_iter != NULL; other_iter = other_iter->ref_next)\n+\t    {\n+\t      // Avoid resolving if possible.\n+\t      if (! self->is_resolved\n+\t\t  && ! other_iter->is_resolved\n+\t\t  && _Jv_equalUtf8Consts (self->data.name,\n+\t\t\t\t\t  other_iter->data.name))\n+\t\tcontinue;\n+\n+\t      if (! self->is_resolved)\n+\t\tself->resolve(verifier);\n+\t      if (! other_iter->is_resolved)\n+\t\tother_iter->resolve(verifier);\n+\n+\t      if (! is_assignable_from_slow (self->data.klass,\n+\t\t\t\t\t     other_iter->data.klass))\n+\t\treturn false;\n+\t    }\n+\t}\n+\n+      return true;\n+    }\n+\n+    bool isarray ()\n+    {\n+      // assert (ref_next == NULL);\n+      if (is_resolved)\n+\treturn data.klass->isArray ();\n+      else\n+\treturn data.name->data[0] == '[';\n+    }\n+\n+    bool isinterface (_Jv_BytecodeVerifier *verifier)\n+    {\n+      // assert (ref_next == NULL);\n+      if (! is_resolved)\n+\tresolve (verifier);\n+      return data.klass->isInterface ();\n+    }\n+\n+    bool isabstract (_Jv_BytecodeVerifier *verifier)\n+    {\n+      // assert (ref_next == NULL);\n+      if (! is_resolved)\n+\tresolve (verifier);\n+      using namespace java::lang::reflect;\n+      return Modifier::isAbstract (data.klass->getModifiers ());\n+    }\n+\n+    jclass getclass (_Jv_BytecodeVerifier *verifier)\n+    {\n+      if (! is_resolved)\n+\tresolve (verifier);\n+      return data.klass;\n+    }\n+\n+    int count_dimensions ()\n+    {\n+      int ndims = 0;\n+      if (is_resolved)\n+\t{\n+\t  jclass k = data.klass;\n+\t  while (k->isArray ())\n+\t    {\n+\t      k = k->getComponentType ();\n+\t      ++ndims;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  char *p = data.name->data;\n+\t  while (*p++ == '[')\n+\t    ++ndims;\n+\t}\n+      return ndims;\n+    }\n+\n+    void *operator new (size_t bytes)\n+    {\n+      return _Jv_Malloc (bytes);\n+    }\n+\n+    void operator delete (void *mem)\n+    {\n+      _Jv_Free (mem);\n+    }\n   };\n \n   // Return the type_val corresponding to a primitive signature\n@@ -244,58 +458,43 @@ class _Jv_BytecodeVerifier\n   // TARGET haven't been prepared.\n   static bool is_assignable_from_slow (jclass target, jclass source)\n   {\n-    // This will terminate when SOURCE==Object.\n-    while (true)\n+    // First, strip arrays.\n+    while (target->isArray ())\n+      {\n+\t// If target is array, source must be as well.\n+\tif (! source->isArray ())\n+\t  return false;\n+\ttarget = target->getComponentType ();\n+\tsource = source->getComponentType ();\n+      }\n+\n+    // Quick success.\n+    if (target == &java::lang::Object::class$)\n+      return true;\n+\n+    do\n       {\n \tif (source == target)\n \t  return true;\n \n \tif (target->isPrimitive () || source->isPrimitive ())\n \t  return false;\n \n-\tif (target->isArray ())\n-\t  {\n-\t    if (! source->isArray ())\n-\t      return false;\n-\t    target = target->getComponentType ();\n-\t    source = source->getComponentType ();\n-\t  }\n-\telse if (target->isInterface ())\n+\tif (target->isInterface ())\n \t  {\n \t    for (int i = 0; i < source->interface_count; ++i)\n \t      {\n \t\t// We use a recursive call because we also need to\n \t\t// check superinterfaces.\n \t\tif (is_assignable_from_slow (target, source->interfaces[i]))\n-\t\t    return true;\n-\t      }\n-\t    source = source->getSuperclass ();\n-\t    if (source == NULL)\n-\t      return false;\n-\t  }\n-\t// We must do this check before we check to see if SOURCE is\n-\t// an interface.  This way we know that any interface is\n-\t// assignable to an Object.\n-\telse if (target == &java::lang::Object::class$)\n-\t  return true;\n-\telse if (source->isInterface ())\n-\t  {\n-\t    for (int i = 0; i < target->interface_count; ++i)\n-\t      {\n-\t\t// We use a recursive call because we also need to\n-\t\t// check superinterfaces.\n-\t\tif (is_assignable_from_slow (target->interfaces[i], source))\n \t\t  return true;\n \t      }\n-\t    target = target->getSuperclass ();\n-\t    if (target == NULL)\n-\t      return false;\n \t  }\n-\telse if (source == &java::lang::Object::class$)\n-\t  return false;\n-\telse\n-\t  source = source->getSuperclass ();\n+\tsource = source->getSuperclass ();\n       }\n+    while (source != NULL);\n+\n+    return false;\n   }\n \n   // This is used to keep track of which `jsr's correspond to a given\n@@ -324,16 +523,12 @@ class _Jv_BytecodeVerifier\n   // verifier.\n   struct type\n   {\n-    // The type.\n+    // The type key.\n     type_val key;\n-    // Some associated data.\n-    union\n-    {\n-      // For a resolved reference type, this is a pointer to the class.\n-      jclass klass;\n-      // For other reference types, this it the name of the class.\n-      _Jv_Utf8Const *name;\n-    } data;\n+\n+    // For reference types, the representation of the type.\n+    ref_intersection *klass;\n+\n     // This is used when constructing a new object.  It is the PC of the\n     // `new' instruction which created the object.  We use the special\n     // value -2 to mean that this is uninitialized, and the special\n@@ -348,7 +543,7 @@ class _Jv_BytecodeVerifier\n     type ()\n     {\n       key = unsuitable_type;\n-      data.klass = NULL;\n+      klass = NULL;\n       pc = UNINIT;\n     }\n \n@@ -357,33 +552,34 @@ class _Jv_BytecodeVerifier\n     type (type_val k)\n     {\n       key = k;\n-      data.klass = NULL;\n-      if (key == reference_type)\n-\tdata.klass = &java::lang::Object::class$;\n+      // For reference_type, if KLASS==NULL then that means we are\n+      // looking for a generic object of any kind, including an\n+      // uninitialized reference.\n+      klass = NULL;\n       pc = UNINIT;\n     }\n \n     // Make a new instance given a class.\n-    type (jclass klass)\n+    type (jclass k, _Jv_BytecodeVerifier *verifier)\n     {\n       key = reference_type;\n-      data.klass = klass;\n+      klass = new ref_intersection (k, verifier);\n       pc = UNINIT;\n     }\n \n     // Make a new instance given the name of a class.\n-    type (_Jv_Utf8Const *n)\n+    type (_Jv_Utf8Const *n, _Jv_BytecodeVerifier *verifier)\n     {\n-      key = unresolved_reference_type;\n-      data.name = n;\n+      key = reference_type;\n+      klass = new ref_intersection (n, verifier);\n       pc = UNINIT;\n     }\n \n     // Copy constructor.\n     type (const type &t)\n     {\n       key = t.key;\n-      data = t.data;\n+      klass = t.klass;\n       pc = t.pc;\n     }\n \n@@ -402,15 +598,15 @@ class _Jv_BytecodeVerifier\n     type& operator= (type_val k)\n     {\n       key = k;\n-      data.klass = NULL;\n+      klass = NULL;\n       pc = UNINIT;\n       return *this;\n     }\n \n     type& operator= (const type& t)\n     {\n       key = t.key;\n-      data = t.data;\n+      klass = t.klass;\n       pc = t.pc;\n       return *this;\n     }\n@@ -424,35 +620,11 @@ class _Jv_BytecodeVerifier\n       return *this;\n     }\n \n-    // If *THIS is an unresolved reference type, resolve it.\n-    void resolve (_Jv_BytecodeVerifier *verifier)\n-    {\n-      if (key != unresolved_reference_type\n-\t  && key != uninitialized_unresolved_reference_type)\n-\treturn;\n-\n-      using namespace java::lang;\n-      java::lang::ClassLoader *loader\n-\t= verifier->current_class->getClassLoaderInternal();\n-      // We might see either kind of name.  Sigh.\n-      if (data.name->data[0] == 'L'\n-\t  && data.name->data[data.name->length - 1] == ';')\n-\tdata.klass = _Jv_FindClassFromSignature (data.name->data, loader);\n-      else\n-\tdata.klass = Class::forName (_Jv_NewStringUtf8Const (data.name),\n-\t\t\t\t     false, loader);\n-      key = (key == unresolved_reference_type\n-\t     ? reference_type\n-\t     : uninitialized_reference_type);\n-    }\n-\n     // Mark this type as the uninitialized result of `new'.\n     void set_uninitialized (int npc, _Jv_BytecodeVerifier *verifier)\n     {\n       if (key == reference_type)\n \tkey = uninitialized_reference_type;\n-      else if (key == unresolved_reference_type)\n-\tkey = uninitialized_unresolved_reference_type;\n       else\n \tverifier->verify_fail (\"internal error in type::uninitialized\");\n       pc = npc;\n@@ -461,13 +633,9 @@ class _Jv_BytecodeVerifier\n     // Mark this type as now initialized.\n     void set_initialized (int npc)\n     {\n-      if (npc != UNINIT && pc == npc\n-\t  && (key == uninitialized_reference_type\n-\t      || key == uninitialized_unresolved_reference_type))\n+      if (npc != UNINIT && pc == npc && key == uninitialized_reference_type)\n \t{\n-\t  key = (key == uninitialized_reference_type\n-\t\t ? reference_type\n-\t\t : unresolved_reference_type);\n+\t  key = reference_type;\n \t  pc = UNINIT;\n \t}\n     }\n@@ -488,14 +656,16 @@ class _Jv_BytecodeVerifier\n \n       // The `null' type is convertible to any initialized reference\n       // type.\n-      if (key == null_type || k.key == null_type)\n-\treturn true;\n+      if (key == null_type)\n+\treturn k.key != uninitialized_reference_type;\n+      if (k.key == null_type)\n+\treturn key != uninitialized_reference_type;\n \n-      // Any reference type is convertible to Object.  This is a special\n-      // case so we don't need to unnecessarily resolve a class.\n-      if (key == reference_type\n-\t  && data.klass == &java::lang::Object::class$)\n+      // A special case for a generic reference.\n+      if (klass == NULL)\n \treturn true;\n+      if (k.klass == NULL)\n+\tverifier->verify_fail (\"programmer error in type::compatible\");\n \n       // An initialized type and an uninitialized type are not\n       // compatible.\n@@ -511,16 +681,7 @@ class _Jv_BytecodeVerifier\n \t    return false;\n \t}\n \n-      // Two unresolved types are equal if their names are the same.\n-      if (! isresolved ()\n-\t  && ! k.isresolved ()\n-\t  && _Jv_equalUtf8Consts (data.name, k.data.name))\n-\treturn true;\n-\n-      // We must resolve both types and check assignability.\n-      resolve (verifier);\n-      k.resolve (verifier);\n-      return is_assignable_from_slow (data.klass, k.data.klass);\n+      return klass->compatible(k.klass, verifier);\n     }\n \n     bool isvoid () const\n@@ -545,9 +706,7 @@ class _Jv_BytecodeVerifier\n       // We treat null_type as not an array.  This is ok based on the\n       // current uses of this method.\n       if (key == reference_type)\n-\treturn data.klass->isArray ();\n-      else if (key == unresolved_reference_type)\n-\treturn data.name->data[0] == '[';\n+\treturn klass->isarray ();\n       return false;\n     }\n \n@@ -558,50 +717,41 @@ class _Jv_BytecodeVerifier\n \n     bool isinterface (_Jv_BytecodeVerifier *verifier)\n     {\n-      resolve (verifier);\n       if (key != reference_type)\n \treturn false;\n-      return data.klass->isInterface ();\n+      return klass->isinterface (verifier);\n     }\n \n     bool isabstract (_Jv_BytecodeVerifier *verifier)\n     {\n-      resolve (verifier);\n       if (key != reference_type)\n \treturn false;\n-      using namespace java::lang::reflect;\n-      return Modifier::isAbstract (data.klass->getModifiers ());\n+      return klass->isabstract (verifier);\n     }\n \n     // Return the element type of an array.\n     type element_type (_Jv_BytecodeVerifier *verifier)\n     {\n-      // FIXME: maybe should do string manipulation here.\n-      resolve (verifier);\n       if (key != reference_type)\n \tverifier->verify_fail (\"programmer error in type::element_type()\", -1);\n \n-      jclass k = data.klass->getComponentType ();\n+      jclass k = klass->getclass (verifier)->getComponentType ();\n       if (k->isPrimitive ())\n \treturn type (verifier->get_type_val_for_signature (k));\n-      return type (k);\n+      return type (k, verifier);\n     }\n \n     // Return the array type corresponding to an initialized\n     // reference.  We could expand this to work for other kinds of\n     // types, but currently we don't need to.\n     type to_array (_Jv_BytecodeVerifier *verifier)\n     {\n-      // Resolving isn't ideal, because it might force us to load\n-      // another class, but it's easy.  FIXME?\n-      if (key == unresolved_reference_type)\n-\tresolve (verifier);\n-\n-      if (key == reference_type)\n-\treturn type (_Jv_GetArrayClass (data.klass,\n-\t\t\t\t\tdata.klass->getClassLoaderInternal()));\n-      else\n+      if (key != reference_type)\n \tverifier->verify_fail (\"internal error in type::to_array()\");\n+\n+      jclass k = klass->getclass (verifier);\n+      return type (_Jv_GetArrayClass (k, k->getClassLoaderInternal()),\n+\t\t   verifier);\n     }\n \n     bool isreference () const\n@@ -616,9 +766,7 @@ class _Jv_BytecodeVerifier\n \n     bool isinitialized () const\n     {\n-      return (key == reference_type\n-\t      || key == null_type\n-\t      || key == unresolved_reference_type);\n+      return key == reference_type || key == null_type;\n     }\n \n     bool isresolved () const\n@@ -631,24 +779,10 @@ class _Jv_BytecodeVerifier\n     void verify_dimensions (int ndims, _Jv_BytecodeVerifier *verifier)\n     {\n       // The way this is written, we don't need to check isarray().\n-      if (key == reference_type)\n-\t{\n-\t  jclass k = data.klass;\n-\t  while (k->isArray () && ndims > 0)\n-\t    {\n-\t      k = k->getComponentType ();\n-\t      --ndims;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  // We know KEY == unresolved_reference_type.\n-\t  char *p = data.name->data;\n-\t  while (*p++ == '[' && ndims-- > 0)\n-\t    ;\n-\t}\n+      if (key != reference_type)\n+\tverifier->verify_fail (\"internal error in verify_dimensions: not a reference type\");\n \n-      if (ndims > 0)\n+      if (klass->count_dimensions () < ndims)\n \tverifier->verify_fail (\"array type has fewer dimensions than required\");\n     }\n \n@@ -682,53 +816,12 @@ class _Jv_BytecodeVerifier\n \t\t    verifier->verify_fail (\"merging different uninitialized types\");\n \t\t}\n \n-\t      if (! isresolved ()\n-\t\t  && ! old_type.isresolved ()\n-\t\t  && _Jv_equalUtf8Consts (data.name, old_type.data.name))\n+\t      ref_intersection *merged = old_type.klass->merge (klass,\n+\t\t\t\t\t\t\t\tverifier);\n+\t      if (merged != klass)\n \t\t{\n-\t\t  // Types are identical.\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  resolve (verifier);\n-\t\t  old_type.resolve (verifier);\n-\n-\t\t  jclass k = data.klass;\n-\t\t  jclass oldk = old_type.data.klass;\n-\n-\t\t  int arraycount = 0;\n-\t\t  while (k->isArray () && oldk->isArray ())\n-\t\t    {\n-\t\t      ++arraycount;\n-\t\t      k = k->getComponentType ();\n-\t\t      oldk = oldk->getComponentType ();\n-\t\t    }\n-\n-\t\t  // Ordinarily this terminates when we hit Object...\n-\t\t  while (k != NULL)\n-\t\t    {\n-\t\t      if (is_assignable_from_slow (k, oldk))\n-\t\t\tbreak;\n-\t\t      k = k->getSuperclass ();\n-\t\t      changed = true;\n-\t\t    }\n-\t\t  // ... but K could have been an interface, in which\n-\t\t  // case we'll end up here.  We just convert this\n-\t\t  // into Object.\n-\t\t  if (k == NULL)\n-\t\t    k = &java::lang::Object::class$;\n-\n-\t\t  if (changed)\n-\t\t    {\n-\t\t      while (arraycount > 0)\n-\t\t\t{\n-\t\t\t  java::lang::ClassLoader *loader\n-\t\t\t    = verifier->current_class->getClassLoaderInternal();\n-\t\t\t  k = _Jv_GetArrayClass (k, loader);\n-\t\t\t  --arraycount;\n-\t\t\t}\n-\t\t      data.klass = k;\n-\t\t    }\n+\t\t  klass = merged;\n+\t\t  changed = true;\n \t\t}\n \t    }\n \t}\n@@ -782,9 +875,7 @@ class _Jv_BytecodeVerifier\n \tcase unused_by_subroutine_type: c = '_'; break;\n \tcase reference_type: c = 'L'; break;\n \tcase null_type: c = '@'; break;\n-\tcase unresolved_reference_type: c = 'l'; break;\n \tcase uninitialized_reference_type: c = 'U'; break;\n-\tcase uninitialized_unresolved_reference_type: c = 'u'; break;\n \t}\n       debug_print (\"%c\", c);\n     }\n@@ -1624,9 +1715,7 @@ class _Jv_BytecodeVerifier\n       case unused_by_subroutine_type:\n       case reference_type:\n       case null_type:\n-      case unresolved_reference_type:\n       case uninitialized_reference_type:\n-      case uninitialized_unresolved_reference_type:\n       default:\n \tverify_fail (\"unknown type in construct_primitive_array_type\");\n       }\n@@ -1997,9 +2086,9 @@ class _Jv_BytecodeVerifier\n     check_pool_index (index);\n     _Jv_Constants *pool = &current_class->constants;\n     if (pool->tags[index] == JV_CONSTANT_ResolvedClass)\n-      return type (pool->data[index].clazz);\n+      return type (pool->data[index].clazz, this);\n     else if (pool->tags[index] == JV_CONSTANT_Class)\n-      return type (pool->data[index].utf8);\n+      return type (pool->data[index].utf8, this);\n     verify_fail (\"expected class constant\", start_PC);\n   }\n \n@@ -2009,7 +2098,7 @@ class _Jv_BytecodeVerifier\n     _Jv_Constants *pool = &current_class->constants;\n     if (pool->tags[index] == JV_CONSTANT_ResolvedString\n \t|| pool->tags[index] == JV_CONSTANT_String)\n-      return type (&java::lang::String::class$);\n+      return type (&java::lang::String::class$, this);\n     else if (pool->tags[index] == JV_CONSTANT_Integer)\n       return type (int_type);\n     else if (pool->tags[index] == JV_CONSTANT_Float)\n@@ -2065,7 +2154,7 @@ class _Jv_BytecodeVerifier\n     if (class_type)\n       *class_type = ct;\n     if (field_type->data[0] == '[' || field_type->data[0] == 'L')\n-      return type (field_type);\n+      return type (field_type, this);\n     return get_type_val_for_signature (field_type->data[0]);\n   }\n \n@@ -2099,7 +2188,7 @@ class _Jv_BytecodeVerifier\n \t  ++p;\n \t++p;\n \t_Jv_Utf8Const *name = make_utf8_const (start, p - start);\n-\treturn type (name);\n+\treturn type (name, this);\n       }\n \n     // Casting to jchar here is ok since we are looking at an ASCII\n@@ -2116,7 +2205,7 @@ class _Jv_BytecodeVerifier\n     jclass k = construct_primitive_array_type (rt);\n     while (--arraycount > 0)\n       k = _Jv_GetArrayClass (k, NULL);\n-    return type (k);\n+    return type (k, this);\n   }\n \n   void compute_argument_types (_Jv_Utf8Const *signature,\n@@ -2160,7 +2249,7 @@ class _Jv_BytecodeVerifier\n     using namespace java::lang::reflect;\n     if (! Modifier::isStatic (current_method->self->accflags))\n       {\n-\ttype kurr (current_class);\n+\ttype kurr (current_class, this);\n \tif (is_init)\n \t  {\n \t    kurr.set_uninitialized (type::SELF, this);\n@@ -2287,7 +2376,7 @@ class _Jv_BytecodeVerifier\n \t  {\n \t    if (PC >= exception[i].start_pc.i && PC < exception[i].end_pc.i)\n \t      {\n-\t\ttype handler (&java::lang::Throwable::class$);\n+\t\ttype handler (&java::lang::Throwable::class$, this);\n \t\tif (exception[i].handler_type.i != 0)\n \t\t  handler = check_class_constant (exception[i].handler_type.i);\n \t\tpush_exception_jump (handler, exception[i].handler_pc.i);\n@@ -2959,33 +3048,13 @@ class _Jv_BytecodeVerifier\n \t\t    {\n \t\t      // In this case the PC doesn't matter.\n \t\t      t.set_uninitialized (type::UNINIT, this);\n+\t\t      // FIXME: check to make sure that the <init>\n+\t\t      // call is to the right class.\n+\t\t      // It must either be super or an exact class\n+\t\t      // match.\n \t\t    }\n \t\t  type raw = pop_raw ();\n-\t\t  bool ok = false;\n-\t\t  if (! is_init && ! raw.isinitialized ())\n-\t\t    {\n-\t\t      // This is a failure.\n-\t\t    }\n-\t\t  else if (is_init && raw.isnull ())\n-\t\t    {\n-\t\t      // Another failure.\n-\t\t    }\n-\t\t  else if (t.compatible (raw, this))\n-\t\t    {\n-\t\t      ok = true;\n-\t\t    }\n-\t\t  else if (opcode == op_invokeinterface)\n-\t\t    {\n-\t\t      // This is a hack.  We might have merged two\n-\t\t      // items and gotten `Object'.  This can happen\n-\t\t      // because we don't keep track of where merges\n-\t\t      // come from.  This is safe as long as the\n-\t\t      // interpreter checks interfaces at runtime.\n-\t\t      type obj (&java::lang::Object::class$);\n-\t\t      ok = raw.compatible (obj, this);\n-\t\t    }\n-\n-\t\t  if (! ok)\n+\t\t  if (! t.compatible (raw, this))\n \t\t    verify_fail (\"incompatible type on stack\");\n \n \t\t  if (is_init)\n@@ -3017,7 +3086,8 @@ class _Jv_BytecodeVerifier\n \t      if (atype < boolean_type || atype > long_type)\n \t\tverify_fail (\"type not primitive\", start_PC);\n \t      pop_type (int_type);\n-\t      push_type (construct_primitive_array_type (type_val (atype)));\n+\t      type t (construct_primitive_array_type (type_val (atype)), this);\n+\t      push_type (t);\n \t    }\n \t    break;\n \t  case op_anewarray:\n@@ -3033,7 +3103,7 @@ class _Jv_BytecodeVerifier\n \t    }\n \t    break;\n \t  case op_athrow:\n-\t    pop_type (type (&java::lang::Throwable::class$));\n+\t    pop_type (type (&java::lang::Throwable::class$, this));\n \t    invalidate_pc ();\n \t    break;\n \t  case op_checkcast:\n@@ -3178,6 +3248,7 @@ class _Jv_BytecodeVerifier\n     flags = NULL;\n     jsr_ptrs = NULL;\n     utf8_list = NULL;\n+    isect_list = NULL;\n     entry_points = NULL;\n   }\n \n@@ -3220,6 +3291,13 @@ class _Jv_BytecodeVerifier\n \t_Jv_Free (entry_points);\n \tentry_points = next;\n       }\n+\n+    while (isect_list != NULL)\n+      {\n+\tref_intersection *next = isect_list->alloc_next;\n+\tdelete isect_list;\n+\tisect_list = next;\n+      }\n   }\n };\n "}]}