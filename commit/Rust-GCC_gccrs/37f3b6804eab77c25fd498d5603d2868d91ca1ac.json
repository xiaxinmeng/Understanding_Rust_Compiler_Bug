{"sha": "37f3b6804eab77c25fd498d5603d2868d91ca1ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdmM2I2ODA0ZWFiNzdjMjVmZDQ5OGQ1NjAzZDI4NjhkOTFjYTFhYw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2011-12-28T18:02:49Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2011-12-28T18:02:49Z"}, "message": "Fix PR 51623\n\nFrom-SVN: r182710", "tree": {"sha": "f5d83b77aefa093bda1f184fdaa3a6829e82917c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5d83b77aefa093bda1f184fdaa3a6829e82917c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37f3b6804eab77c25fd498d5603d2868d91ca1ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37f3b6804eab77c25fd498d5603d2868d91ca1ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37f3b6804eab77c25fd498d5603d2868d91ca1ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37f3b6804eab77c25fd498d5603d2868d91ca1ac/comments", "author": null, "committer": null, "parents": [{"sha": "0fe0620df5f91f4979dc7b9347e86a1acec4b156", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fe0620df5f91f4979dc7b9347e86a1acec4b156", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fe0620df5f91f4979dc7b9347e86a1acec4b156"}], "stats": {"total": 137, "additions": 136, "deletions": 1}, "files": [{"sha": "9648baa2055bec309e08432250d72e3bd67fac7c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37f3b6804eab77c25fd498d5603d2868d91ca1ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37f3b6804eab77c25fd498d5603d2868d91ca1ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=37f3b6804eab77c25fd498d5603d2868d91ca1ac", "patch": "@@ -1,3 +1,10 @@\n+2011-12-28  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/51623\n+\t* config/rs6000/rs6000.c (rs6000_assemble_integer): Don't call\n+\tunlikely_text_section_p.  Instead check for being in a code\n+\tsection.\n+\n 2011-12-28  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/51684"}, {"sha": "d61f14cc071be70873019fe7ecaf35a8021f0e9f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37f3b6804eab77c25fd498d5603d2868d91ca1ac/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37f3b6804eab77c25fd498d5603d2868d91ca1ac/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=37f3b6804eab77c25fd498d5603d2868d91ca1ac", "patch": "@@ -15461,7 +15461,7 @@ rs6000_assemble_integer (rtx x, unsigned int size, int aligned_p)\n       if (TARGET_RELOCATABLE\n \t  && in_section != toc_section\n \t  && in_section != text_section\n-\t  && !unlikely_text_section_p (in_section)\n+\t  && (in_section && (in_section->common.flags & SECTION_CODE)) == 0\n \t  && !recurse\n \t  && GET_CODE (x) != CONST_INT\n \t  && GET_CODE (x) != CONST_DOUBLE"}, {"sha": "aba19e9a5ae5e5fb0101271677ef7fd4e38bba1a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37f3b6804eab77c25fd498d5603d2868d91ca1ac/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37f3b6804eab77c25fd498d5603d2868d91ca1ac/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=37f3b6804eab77c25fd498d5603d2868d91ca1ac", "patch": "@@ -1,3 +1,8 @@\n+2011-12-28  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/51623\n+\t* gcc.target/powerpc/pr51623.c: New file.\n+\n 2011-12-28  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.dg/torture/pr50396.c: Use dg-add-options ieee."}, {"sha": "37b7d6557a40e00708c3f8e2911cf39545393a3f", "filename": "gcc/testsuite/gcc.target/powerpc/pr51623.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37f3b6804eab77c25fd498d5603d2868d91ca1ac/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr51623.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37f3b6804eab77c25fd498d5603d2868d91ca1ac/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr51623.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr51623.c?ref=37f3b6804eab77c25fd498d5603d2868d91ca1ac", "patch": "@@ -0,0 +1,123 @@\n+/* PR target/51623 */\n+/* { dg-do compile { target { { powerpc*-*-linux* && ilp32 } || { powerpc-*-eabi* } } } } */\n+/* { dg-options \"-mrelocatable -ffreestanding\" } */\n+\n+/* This generated an error, since the compiler was calling\n+   unlikely_text_section_p in a context where it wasn't valid.  */\n+\n+typedef long long loff_t;\n+typedef unsigned size_t;\n+\n+\n+struct mtd_info {\n+  unsigned writesize;\n+  unsigned oobsize;\n+  const char *name;\n+};\n+\n+extern int strcmp(const char *,const char *);\n+extern char * strchr(const char *,int);\n+\n+struct cmd_tbl_s {\n+  char *name;\n+};\n+\n+\n+int printf(const char *fmt, ...) __attribute__ ((format (__printf__, 1, 2)));\n+void* malloc(size_t);\n+void free(void*);\n+\n+\n+extern int nand_curr_device;\n+extern struct mtd_info nand_info[];\n+\n+static int nand_dump(struct mtd_info *nand, unsigned long off, int only_oob)\n+{\n+  int i;\n+  unsigned char *datbuf, *oobbuf, *p;\n+\n+  datbuf = malloc(nand->writesize + nand->oobsize);\n+  oobbuf = malloc(nand->oobsize);\n+  off &= ~(nand->writesize - 1);\n+\n+  printf(\"Page %08lx dump:\\n\", off);\n+  i = nand->writesize >> 4;\n+  p = datbuf;\n+\n+  while (i--) {\n+    if (!only_oob)\n+      printf(\"\\t%02x %02x %02x %02x %02x %02x %02x %02x\"\n+\t     \"  %02x %02x %02x %02x %02x %02x %02x %02x\\n\",\n+\t     p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],\n+\t     p[8], p[9], p[10], p[11], p[12], p[13], p[14],\n+\t     p[15]);\n+    p += 16;\n+  }\n+\n+  i = nand->oobsize >> 3;\n+  free(datbuf);\n+  free(oobbuf);\n+\n+  return 0;\n+}\n+\n+int do_nand(struct cmd_tbl_s * cmdtp, int flag, int argc, char *argv[])\n+{\n+  int dev;\n+  unsigned long  off;\n+  char *cmd, *s;\n+  struct mtd_info *nand;\n+\n+  if (argc < 2)\n+    goto usage;\n+\n+  cmd = argv[1];\n+\n+  if (strcmp(cmd, \"info\") == 0) {\n+    putc('\\n');\n+    return 0;\n+  }\n+\n+  if (strcmp(cmd, \"device\") == 0) {\n+    if (argc < 3) {\n+      putc('\\n');\n+    }\n+    dev = (int)simple_strtoul(argv[2], ((void *)0), 10);\n+    nand_curr_device = dev;\n+    return 0;\n+  }\n+\n+  if (strcmp(cmd, \"bad\") != 0 && strcmp(cmd, \"erase\") != 0  )\n+    goto usage;\n+  \n+  if (nand_curr_device < 0 ) {\n+    return 1;\n+  }\n+  nand = &nand_info[nand_curr_device];\n+\n+  if (strcmp(cmd, \"erase\") == 0 || strcmp(cmd, \"scrub\") == 0) {\n+    int clean = argc > 2 && !strcmp(\"clean\", argv[2]);\n+    int scrub = !strcmp(cmd, \"scrub\");\n+    return 0;\n+  }\n+\n+  if (strncmp(cmd, \"dump\", 4) == 0) {\n+    if (argc < 3)\n+      goto usage;\n+\n+    s = strchr(cmd, '.');\n+    off = (int)simple_strtoul(argv[2], ((void *)0), 16);\n+    \n+    if (s != ((void *)0) && strcmp(s, \".oob\") == 0)\n+      nand_dump(nand, off, 1);\n+    else\n+      nand_dump(nand, off, 0);\n+    \n+    return 0;\n+  }\n+usage:\n+  cmd_usage(cmdtp);\n+  return 1;\n+}\n+\n+void *ptr = do_nand;"}]}