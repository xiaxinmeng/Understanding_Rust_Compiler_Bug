{"sha": "7a7688141da7ee692469abe43c9066557653c269", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E3Njg4MTQxZGE3ZWU2OTI0NjlhYmU0M2M5MDY2NTU3NjUzYzI2OQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-06T02:36:40Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-06T02:36:40Z"}, "message": "Initial revision\n\nFrom-SVN: r282", "tree": {"sha": "e3971bf7b39b86df4cae9c265322a2bfa00664db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3971bf7b39b86df4cae9c265322a2bfa00664db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a7688141da7ee692469abe43c9066557653c269", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a7688141da7ee692469abe43c9066557653c269", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a7688141da7ee692469abe43c9066557653c269", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a7688141da7ee692469abe43c9066557653c269/comments", "author": null, "committer": null, "parents": [{"sha": "79e68feb317b00bda42db706667eccc7619c0a30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79e68feb317b00bda42db706667eccc7619c0a30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79e68feb317b00bda42db706667eccc7619c0a30"}], "stats": {"total": 2645, "additions": 2645, "deletions": 0}, "files": [{"sha": "02776abbe2767f1be9de3f50ff83db18fd5fd52a", "filename": "gcc/config/sparc/sparc.md", "status": "added", "additions": 2645, "deletions": 0, "changes": 2645, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a7688141da7ee692469abe43c9066557653c269/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a7688141da7ee692469abe43c9066557653c269/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=7a7688141da7ee692469abe43c9066557653c269", "patch": "@@ -0,0 +1,2645 @@\n+;;- Machine description for SPARC chip for GNU C compiler\n+;;   Copyright (C) 1987, 1988, 1989, 1992 Free Software Foundation, Inc.\n+;;   Contributed by Michael Tiemann (tiemann@cygnus.com)\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;; Insn type.  Used to default other attribute values.\n+\n+;; type \"unary\" insns have one input operand (1) and one output operand (0)\n+;; type \"binary\" insns have two input operands (1,2) and one output (0)\n+;; type \"compare\" insns have one or two input operands (0,1) and no output\n+;; type \"call_no_delay_slot\" is a call followed by an unimp instruction.\n+\n+(define_attr \"type\"\n+  \"move,unary,binary,compare,load,store,branch,call,call_no_delay_slot,address,fpload,fpstore,fp,fpcmp,fpmul,fpdiv,fpsqrt,multi,misc\"\n+  (const_string \"binary\"))\n+\n+;; Set true if insn uses call-clobbered intermediate register.\n+(define_attr \"use_clobbered\" \"false,true\"\n+  (if_then_else (and (eq_attr \"type\" \"address\")\n+\t\t     (match_operand 0 \"clobbered_register\" \"\"))\n+\t \t(const_string \"true\")\n+\t\t(const_string \"false\")))\n+\n+;; Length (in # of insns).\n+(define_attr \"length\" \"\"\n+  (cond [(eq_attr \"type\" \"load,fpload\")\n+\t (if_then_else (match_operand 1 \"symbolic_memory_operand\" \"\")\n+\t\t       (const_int 2) (const_int 1))\n+\n+\t (eq_attr \"type\" \"store,fpstore\")\n+\t (if_then_else (match_operand 0 \"symbolic_memory_operand\" \"\")\n+\t\t       (const_int 2) (const_int 1))\n+\n+\t (eq_attr \"type\" \"address\") (const_int 2)\n+\n+\t (eq_attr \"type\" \"binary\")\n+\t (if_then_else (ior (match_operand 2 \"arith_operand\" \"\")\n+\t\t\t    (match_operand 2 \"arith_double_operand\" \"\"))\n+\t\t       (const_int 1) (const_int 3))\n+\n+\t (eq_attr \"type\" \"move,unary\")\n+\t (if_then_else (ior (match_operand 1 \"arith_operand\" \"\")\n+\t\t\t    (match_operand 1 \"arith_double_operand\" \"\"))\n+\t\t       (const_int 1) (const_int 2))]\n+\n+\t(const_int 1)))\n+\n+(define_asm_attributes\n+  [(set_attr \"length\" \"1\")\n+   (set_attr \"type\" \"multi\")])\n+\n+;; Attributes for instruction and branch scheduling\n+\n+(define_attr \"in_call_delay\" \"false,true\"\n+  (cond [(eq_attr \"type\" \"branch,call,call_no_delay_slot,multi\")\n+\t \t(const_string \"false\")\n+\t (eq_attr \"type\" \"load,fpload,store,fpstore\")\n+\t \t(if_then_else (eq_attr \"length\" \"1\")\n+\t\t\t      (const_string \"true\")\n+\t\t\t      (const_string \"false\"))\n+\t (eq_attr \"type\" \"address\")\n+\t \t(if_then_else (eq_attr \"use_clobbered\" \"false\")\n+\t\t\t      (const_string \"true\")\n+\t\t\t      (const_string \"false\"))]\n+\t(if_then_else (eq_attr \"length\" \"1\")\n+\t\t      (const_string \"true\")\n+\t\t      (const_string \"false\"))))\n+\n+(define_delay (eq_attr \"type\" \"call\")\n+  [(eq_attr \"in_call_delay\" \"true\") (nil) (nil)])\n+\n+;; ??? Should implement the notion of predelay slots for floating point\n+;; branches.  This would allow us to remove the nop always inserted before\n+;; a floating point branch.\n+\n+(define_attr \"in_branch_delay\" \"false,true\"\n+  (if_then_else (and (eq_attr \"type\" \"!branch,call,call_no_delay_slot,multi\")\n+\t\t     (eq_attr \"length\" \"1\"))\n+\t\t(const_string \"true\")\n+\t\t(const_string \"false\")))\n+\n+(define_delay (eq_attr \"type\" \"branch\")\n+  [(eq_attr \"in_branch_delay\" \"true\")\n+   (nil) (eq_attr \"in_branch_delay\" \"true\")])\n+\n+;; Function units of the SPARC\n+\n+;; (define_function_unit {name} {num-units} {n-users} {test}\n+;;                       {ready-delay} {busy-delay} [{conflict-list}])\n+\n+;; The integer ALU.\n+;; (Noted only for documentation; units that take one cycle do not need to\n+;; be specified.)\n+\n+;; (define_function_unit \"alu\" 1 0\n+;;  (eq_attr \"type\" \"unary,binary,move,address\") 1 0)\n+\n+;; Memory with load-delay of 1 (i.e., 2 cycle load).\n+(define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"load,fpload\") 2 0)\n+\n+;; SPARC has two floating-point units: the FP ALU,\n+;; and the FP MUL/DIV/SQRT unit.\n+;; Instruction timings on the CY7C602 are as follows\n+;; FABSs\t4\n+;; FADDs/d\t5/5\n+;; FCMPs/d\t4/4\n+;; FDIVs/d\t23/37\n+;; FMOVs\t4\n+;; FMULs/d\t5/7\n+;; FNEGs\t4\n+;; FSQRTs/d\t34/63\n+;; FSUBs/d\t5/5\n+;; FdTOi/s\t5/5\n+;; FsTOi/d\t5/5\n+;; FiTOs/d\t9/5\n+\n+;; The CY7C602 can only support 2 fp isnsn simultaneously.\n+;; More insns cause the chip to stall.  Until we handle this\n+;; better in the scheduler, we use excess cycle times to\n+;; more evenly spread out fp insns.\n+\n+(define_function_unit \"fp_alu\" 1 2 (eq_attr \"type\" \"fp\") 8 0)\n+(define_function_unit \"fp_mul\" 1 2 (eq_attr \"type\" \"fpmul\") 10 0)\n+(define_function_unit \"fp_div\" 1 2 (eq_attr \"type\" \"fpdiv\") 23 0)\n+(define_function_unit \"fp_sqrt\" 1 2 (eq_attr \"type\" \"fpsqrt\") 34 0)\n+\f\n+;; Compare instructions.\n+;; This controls RTL generation and register allocation.\n+\n+;; We generate RTL for comparisons and branches by having the cmpxx \n+;; patterns store away the operands.  Then, the scc and bcc patterns\n+;; emit RTL for both the compare and the branch.\n+;;\n+;; We do this because we want to generate different code for an sne and\n+;; seq insn.  In those cases, if the second operand of the compare is not\n+;; const0_rtx, we want to compute the xor of the two operands and test\n+;; it against zero.\n+;;\n+;; We start with the DEFINE_EXPANDs, then then DEFINE_INSNs to match\n+;; the patterns.  Finally, we have the DEFINE_SPLITs for some of the scc\n+;; insns that actually require more than one machine instruction.\n+\n+;; Put cmpsi first among compare insns so it matches two CONST_INT operands.\n+\n+(define_expand \"cmpsi\"\n+  [(set (reg:CC 0)\n+\t(compare:CC (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t    (match_operand:SI 1 \"arith_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  sparc_compare_op0 = operands[0];\n+  sparc_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+(define_expand \"cmpsf\"\n+  [(set (reg:CCFP 0)\n+\t(compare:CCFP (match_operand:SF 0 \"register_operand\" \"\")\n+\t\t      (match_operand:SF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  sparc_compare_op0 = operands[0];\n+  sparc_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+(define_expand \"cmpdf\"\n+  [(set (reg:CCFP 0)\n+\t(compare:CCFP (match_operand:DF 0 \"register_operand\" \"\")\n+\t\t      (match_operand:DF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  sparc_compare_op0 = operands[0];\n+  sparc_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+;; Next come the scc insns.  For seq, sne, sgeu, and sltu, we can do this\n+;; without jumps using the addx/subx instructions.  For the rest, we do\n+;; branches.  Seq_special and sne_special clobber the CC reg, because they\n+;; generate addcc/subcc instructions.\n+\n+(define_expand \"seq_special\"\n+  [(set (match_dup 3) (xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t      (match_operand:SI 2 \"register_operand\" \"\")))\n+   (parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (eq:SI (match_dup 3) (const_int 0)))\n+\t      (clobber (reg:CC 0))])]\n+\t     \n+  \"\"\n+  \"{ operands[3] = gen_reg_rtx (SImode); }\")\n+\n+(define_expand \"sne_special\"\n+  [(set (match_dup 3) (xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t      (match_operand:SI 2 \"register_operand\" \"\")))\n+   (parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (ne:SI (match_dup 3) (const_int 0)))\n+\t      (clobber (reg:CC 0))])]\n+  \"\"\n+  \"{ operands[3] = gen_reg_rtx (SImode); }\")\n+\n+(define_expand \"seq\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(eq:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{ if (GET_MODE (sparc_compare_op0) == SImode)\n+    {\n+      emit_insn (gen_seq_special (operands[0], sparc_compare_op0,\n+\t\t\t\t  sparc_compare_op1));\n+      DONE;\n+    }\n+  else\n+    operands[1] = gen_compare_reg (EQ, sparc_compare_op0, sparc_compare_op1);\n+}\")\n+\n+(define_expand \"sne\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ne:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{ if (GET_MODE (sparc_compare_op0) == SImode)\n+    {\n+      emit_insn (gen_sne_special (operands[0], sparc_compare_op0,\n+\t\t\t\t  sparc_compare_op1));\n+      DONE;\n+    }\n+  else\n+    operands[1] = gen_compare_reg (NE, sparc_compare_op0, sparc_compare_op1);\n+}\")\n+\n+(define_expand \"sgt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(gt:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (GT, sparc_compare_op0, sparc_compare_op1); }\")\n+\n+(define_expand \"slt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(lt:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (LT, sparc_compare_op0, sparc_compare_op1); }\")\n+\n+(define_expand \"sge\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ge:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (GE, sparc_compare_op0, sparc_compare_op1); }\")\n+\n+(define_expand \"sle\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(le:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (LE, sparc_compare_op0, sparc_compare_op1); }\")\n+\n+(define_expand \"sgtu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(gtu:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  rtx tem;\n+\n+  /* We can do ltu easily, so if both operands are registers, swap them and\n+     do a LTU.  */\n+  if ((GET_CODE (sparc_compare_op0) == REG\n+       || GET_CODE (sparc_compare_op0) == SUBREG)\n+      && (GET_CODE (sparc_compare_op1) == REG\n+\t  || GET_CODE (sparc_compare_op1) == SUBREG))\n+    {\n+      tem = sparc_compare_op0;\n+      sparc_compare_op0 = sparc_compare_op1;\n+      sparc_compare_op1 = tem;\n+      emit_insn (gen_sltu (operands[0]));\n+      DONE;\n+    }\n+\n+  operands[1] = gen_compare_reg (LEU, sparc_compare_op0, sparc_compare_op1);\n+}\")\n+\n+(define_expand \"sltu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ltu:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (LTU, sparc_compare_op0, sparc_compare_op1);\n+}\")\n+\n+(define_expand \"sgeu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(geu:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (GEU, sparc_compare_op0, sparc_compare_op1);\n+}\")\n+\n+(define_expand \"sleu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(leu:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  rtx tem;\n+\n+  /* We can do geu easily, so if both operands are registers, swap them and\n+     do a GEU.  */\n+  if ((GET_CODE (sparc_compare_op0) == REG\n+       || GET_CODE (sparc_compare_op0) == SUBREG)\n+      && (GET_CODE (sparc_compare_op1) == REG\n+\t  || GET_CODE (sparc_compare_op1) == SUBREG))\n+    {\n+      tem = sparc_compare_op0;\n+      sparc_compare_op0 = sparc_compare_op1;\n+      sparc_compare_op1 = tem;\n+      emit_insn (gen_sgeu (operands[0]));\n+      DONE;\n+    }\n+\n+  operands[1] = gen_compare_reg (LEU, sparc_compare_op0, sparc_compare_op1);\n+}\")\n+\n+;; Now the DEFINE_INSNs for the compare and scc cases.  First the compares.\n+\n+(define_insn \"\"\n+  [(set (reg:CC 0)\n+\t(compare:CC (match_operand:SI 0 \"register_operand\" \"rJ\")\n+\t\t    (match_operand:SI 1 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"cmp %r0,%1\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CCFP 0)\n+\t(compare:CCFP (match_operand:DF 0 \"register_operand\" \"f\")\n+\t\t      (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fcmped %0,%1\"\n+  [(set_attr \"type\" \"fpcmp\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CCFP 0)\n+\t(compare:CCFP (match_operand:SF 0 \"register_operand\" \"f\")\n+\t\t      (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fcmpes %0,%1\"\n+  [(set_attr \"type\" \"fpcmp\")])\n+\n+;; The SEQ and SNE patterns are special because they can be done\n+;; without any branching and do not involve a COMPARE.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ne:SI (match_operand:SI 1 \"register_operand\" \"r\") (const_int 0)))\n+   (clobber (reg:CC 0))]\n+  \"\"\n+  \"subcc %%g0,%1,%%g0\\;addx %%g0,0,%0\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (ne:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t       (const_int 0))))\n+   (clobber (reg:CC 0))]\n+  \"\"\n+  \"subcc %%g0,%1,%%g0\\;subx %%g0,0,%0\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(eq:SI (match_operand:SI 1 \"register_operand\" \"r\") (const_int 0)))\n+   (clobber (reg:CC 0))]\n+  \"\"\n+  \"subcc %%g0,%1,%%g0\\;subx %%g0,-1,%0\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (eq:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t       (const_int 0))))\n+   (clobber (reg:CC 0))]\n+  \"\"\n+  \"subcc %%g0,%1,%%g0\\;addx %%g0,-1,%0\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"2\")])\n+\n+;; We can also do (x + (i == 0)) and related, so put them in.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (ne:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t(const_int 0))\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CC 0))]\n+  \"\"\n+  \"subcc %%g0,%1,%%g0\\;addx %2,0,%0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t  (ne:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 0))))\n+   (clobber (reg:CC 0))]\n+  \"\"\n+  \"subcc %%g0,%1,%%g0\\;subx %2,0,%0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (eq:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t(const_int 0))\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CC 0))]\n+  \"\"\n+  \"subcc %%g0,%1,%%g0\\;subx %2,-1,%0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t  (eq:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 0))))\n+   (clobber (reg:CC 0))]\n+  \"\"\n+  \"subcc %%g0,%1,%%g0\\;addx %2,-1,%0\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"2\")])\n+\n+;; We can also do GEU and LTU directly, but these operate after a\n+;; compare.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ltu:SI (reg:CC 0) (const_int 0)))]\n+  \"\"\n+  \"addx %%g0,0,%0\"\n+  [(set_attr \"type\" \"misc\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (ltu:SI (reg:CC 0) (const_int 0))))]\n+  \"\"\n+  \"subx %%g0,0,%0\"\n+  [(set_attr \"type\" \"misc\")])\n+\n+;; ??? Combine should canonicalize these next two to the same pattern.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (neg:SI (ltu:SI (reg:CC 0) (const_int 0)))\n+\t\t  (match_operand:SI 1 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"subx %%g0,%1,%0\"\n+  [(set_attr \"type\" \"unary\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (plus:SI (ltu:SI (reg:CC 0) (const_int 0))\n+\t\t\t (match_operand:SI 1 \"arith_operand\" \"rI\"))))]\n+  \"\"\n+  \"subx %%g0,%1,%0\"\n+  [(set_attr \"type\" \"unary\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(geu:SI (reg:CC 0) (const_int 0)))]\n+  \"\"\n+  \"subx %%g0,-1,%0\"\n+  [(set_attr \"type\" \"misc\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (geu:SI (reg:CC 0) (const_int 0))))]\n+  \"\"\n+  \"addx %%g0,-1,%0\"\n+  [(set_attr \"type\" \"misc\")])\n+\n+;; We can also do (x + ((unsigned) i >= 0)) and related, so put them in.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (ltu:SI (reg:CC 0) (const_int 0))\n+\t\t (match_operand:SI 1 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"addx %%g0,%1,%0\"\n+  [(set_attr \"type\" \"unary\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (ltu:SI (reg:CC 0) (const_int 0))\n+\t\t (plus:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n+\t\t\t  (match_operand:SI 2 \"arith_operand\" \"rI\"))))]\n+  \"\"\n+  \"addx %1,%2,%0\"\n+  [(set_attr \"type\" \"binary\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (ltu:SI (reg:CC 0) (const_int 0))))]\n+  \"\"\n+  \"subx %1,0,%0\"\n+  [(set_attr \"type\" \"unary\")])\n+\n+;; ??? Combine should canonicalize these next two to the same pattern.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t    (match_operand:SI 2 \"arith_operand\" \"rI\"))\n+\t\t  (ltu:SI (reg:CC 0) (const_int 0))))]\n+  \"\"\n+  \"subx %1,%2,%0\"\n+  [(set_attr \"type\" \"binary\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (plus:SI (ltu:SI (reg:CC 0) (const_int 0))\n+\t\t\t   (match_operand:SI 2 \"arith_operand\" \"rI\"))))]\n+  \"\"\n+  \"subx %1,%2,%0\"\n+  [(set_attr \"type\" \"binary\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (geu:SI (reg:CC 0) (const_int 0))\n+\t\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"subx %1,-1,%0\"\n+  [(set_attr \"type\" \"unary\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (geu:SI (reg:CC 0) (const_int 0))))]\n+  \"\"\n+  \"addx %1,-1,%0\"\n+  [(set_attr \"type\" \"unary\")])\n+\n+;; Now we have the generic scc insns.  These will be done using a jump.\n+;; We have to exclude the cases above, since we will not want combine to\n+;; turn something that does not require a jump into something that does.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 1 \"normal_comp_operator\" [(reg 0) (const_int 0)]))]\n+  \"\"\n+  \"* return output_scc_insn (operands, insn); \"\n+  [(set_attr \"type\" \"multi\")])\n+\f\n+;; These control RTL generation for conditional jump insns\n+\n+(define_expand \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (EQ, sparc_compare_op0, sparc_compare_op1); }\")\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (NE, sparc_compare_op0, sparc_compare_op1); }\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (GT, sparc_compare_op0, sparc_compare_op1); }\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (GTU, sparc_compare_op0, sparc_compare_op1);\n+}\")\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (LT, sparc_compare_op0, sparc_compare_op1); }\")\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (LTU, sparc_compare_op0, sparc_compare_op1);\n+}\")\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (GE, sparc_compare_op0, sparc_compare_op1); }\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (GEU, sparc_compare_op0, sparc_compare_op1);\n+}\")\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (LE, sparc_compare_op0, sparc_compare_op1); }\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (LEU, sparc_compare_op0, sparc_compare_op1);\n+}\")\n+\f\n+;; Now match both normal and inverted jump.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"noov_compare_op\"\n+\t\t\t\t      [(reg 0) (const_int 0)])\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{\n+  return output_cbranch (operands[0], 1, 0,\n+\t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n+\t\t\t ! final_sequence);\n+}\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"noov_compare_op\"\n+\t\t\t\t      [(reg 0) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  return output_cbranch (operands[0], 1, 1,\n+\t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n+\t\t\t ! final_sequence);\n+}\"\n+  [(set_attr \"type\" \"branch\")])\n+\f\n+;; Move instructions\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, SImode, 0))\n+    DONE;\n+}\")\n+\n+(define_expand \"reload_insi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&r\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, SImode, operands[2]))\n+    DONE;\n+\n+  /* We don't want the clobber emitted, so handle this ourselves.  */\n+  emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n+;; We must support both 'r' and 'f' registers here, because combine may\n+;; convert SFmode hard registers to SImode hard registers when simplifying\n+;; subreg sets.\n+\n+;; We cannot combine the similar 'r' and 'f' constraints, because it causes\n+;; problems with register allocation.  Reload might try to put an interger\n+;; in an fp register, or an fp number is an integer register.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,f,Q,Q,rf\")\n+\t(match_operand:SI 1 \"move_operand\" \"rI,K,Q,!Q,rJ,!f,!fr\"))]\n+  \"register_operand (operands[0], SImode)\n+   || register_operand (operands[1], SImode)\n+   || operands[1] == const0_rtx\"\n+  \"@\n+   mov %1,%0\n+   sethi %%hi(%a1),%0\n+   ld %1,%0\n+   ld %1,%0\n+   st %r1,%0\n+   st %r1,%0\n+   st %r1,[%%fp-4]\\;ld [%%fp-4],%0\"\n+  [(set_attr \"type\" \"move,move,load,load,store,store,misc\")\n+   (set_attr \"length\" \"*,1,*,*,*,*,2\")])\n+\n+;; Special pic pattern, for loading the address of a label into a register.\n+;; It clobbers o7 because the call puts the return address (i.e. pc value)\n+;; there.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"move_pic_label\" \"i\"))\n+   (set (reg:SI 15) (pc))]\n+  \"\"\n+  \"\\\\n1:\\;call 2f\\;sethi %%hi(%l1-1b),%0\\\\n2:\\\\tor %0,%%lo(%l1-1b),%0\\;add %0,%%o7,%0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(high:DI (match_operand 1 \"\" \"\")))]\n+  \"check_pic (1)\"\n+  \"*\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+\n+  if (GET_CODE (op1) == CONST_INT)\n+    {\n+      operands[0] = operand_subword (op0, 1, 0, DImode);\n+      output_asm_insn (\\\"sethi %%hi(%a1),%0\\\", operands);\n+\n+      operands[0] = operand_subword (op0, 0, 0, DImode);\n+      if (INTVAL (op1) < 0)\n+\toutput_asm_insn (\\\"mov -1,%0\\\", operands);\n+      else\n+\toutput_asm_insn (\\\"mov 0,%0\\\", operands);\n+    }\n+  else if (GET_CODE (op1) == CONST_DOUBLE)\n+    {\n+      operands[0] = operand_subword (op0, 1, 0, DImode);\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_HIGH (op1));\n+      output_asm_insn (\\\"sethi %%hi(%a1),%0\\\", operands);\n+\n+      operands[0] = operand_subword (op0, 0, 0, DImode);\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_LOW (op1));\n+      output_asm_insn (singlemove_string (operands), operands);\n+    }\n+  else\n+    abort ();\n+}\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(high:SI (match_operand 1 \"\" \"\")))]\n+  \"check_pic (1)\"\n+  \"sethi %%hi(%a1),%0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(high:HI (match_operand 1 \"\" \"\")))]\n+  \"check_pic (1)\"\n+  \"sethi %%hi(%a1),%0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:DI 2 \"immediate_operand\" \"in\")))]\n+  \"\"\n+  \"or %R1,%%lo(%a2),%R0\"\n+  ;; Need to set length for this arith insn because operand2\n+  ;; is not an \"arith_operand\".\n+  [(set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"in\")))]\n+  \"\"\n+  \"or %1,%%lo(%a2),%0\"\n+  ;; Need to set length for this arith insn because operand2\n+  ;; is not an \"arith_operand\".\n+  [(set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (mem:SI (match_operand:SI 0 \"symbolic_operand\" \"\"))\n+\t(match_operand:SI 1 \"reg_or_0_operand\" \"rJ\"))\n+   (clobber (match_scratch:SI 2 \"=&r\"))]\n+  \"\"\n+  \"sethi %%hi(%a0),%2\\;st %r1,[%2+%%lo(%a0)]\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, HImode, 0))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,Q\")\n+\t(match_operand:HI 1 \"move_operand\" \"rI,K,Q,rJ\"))]\n+  \"register_operand (operands[0], HImode)\n+   || register_operand (operands[1], HImode)\n+   || operands[1] == const0_rtx\"\n+  \"@\n+   mov %1,%0\n+   sethi %%hi(%a1),%0\n+   lduh %1,%0\n+   sth %r1,%0\"\n+  [(set_attr \"type\" \"move,move,load,store\")\n+   (set_attr \"length\" \"*,1,*,1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand 2 \"immediate_operand\" \"in\")))]\n+  \"\"\n+  \"or %1,%%lo(%a2),%0\"\n+  [(set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (mem:HI (match_operand:SI 0 \"symbolic_operand\" \"\"))\n+\t(match_operand:HI 1 \"reg_or_0_operand\" \"rJ\"))\n+   (clobber (match_scratch:SI 2 \"=&r\"))]\n+  \"\"\n+  \"sethi %%hi(%a0),%2\\;sth %r1,[%2+%%lo(%a0)]\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, QImode, 0))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,Q\")\n+\t(match_operand:QI 1 \"move_operand\" \"rI,K,Q,rJ\"))]\n+  \"register_operand (operands[0], QImode)\n+   || register_operand (operands[1], QImode)\n+   || operands[1] == const0_rtx\"\n+  \"@\n+   mov %1,%0\n+   sethi %%hi(%a1),%0\n+   ldub %1,%0\n+   stb %r1,%0\"\n+  [(set_attr \"type\" \"move,move,load,store\")\n+   (set_attr \"length\" \"*,1,*,1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(subreg:QI (lo_sum:SI (match_operand:QI 1 \"register_operand\" \"r\")\n+\t\t\t      (match_operand 2 \"immediate_operand\" \"in\")) 0))]\n+  \"\"\n+  \"or %1,%%lo(%a2),%0\"\n+  [(set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (mem:QI (match_operand:SI 0 \"symbolic_operand\" \"\"))\n+\t(match_operand:QI 1 \"reg_or_0_operand\" \"rJ\"))\n+   (clobber (match_scratch:SI 2 \"=&r\"))]\n+  \"\"\n+  \"sethi %%hi(%a0),%2\\;stb %r1,[%2+%%lo(%a0)]\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"2\")])\n+\n+;; The definition of this insn does not really explain what it does,\n+;; but it should suffice\n+;; that anything generated as this insn will be recognized as one\n+;; and that it will not successfully combine with anything.\n+(define_expand \"movstrsi\"\n+  [(parallel [(set (mem:BLK (match_operand:BLK 0 \"general_operand\" \"\"))\n+\t\t   (mem:BLK (match_operand:BLK 1 \"general_operand\" \"\")))\n+\t      (use (match_operand:SI 2 \"arith32_operand\" \"\"))\n+\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n+\t      (clobber (match_dup 0))\n+\t      (clobber (match_dup 1))\n+\t      (clobber (match_scratch:SI 4 \"\"))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 1))])]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && GET_CODE (operands[3]) == CONST_INT\n+      && INTVAL (operands[2]) / INTVAL (operands[3]) > 32)\n+    FAIL;\n+\n+  operands[0] = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n+  operands[1] = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n+  operands[2] = force_not_mem (operands[2]);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (use (match_operand:SI 2 \"arith32_operand\" \"rn\"))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n+   (clobber (match_dup 0))\n+   (clobber (match_dup 1))\n+   (clobber (match_scratch:SI 4 \"=&r\"))\n+   (clobber (reg:SI 0))\n+   (clobber (reg:SI 1))]\n+  \"\"\n+  \"* return output_block_move (operands);\"\n+  [(set_attr \"type\" \"multi\")])\n+\f\n+;; Floating point move insns\n+\n+;; This pattern forces (set (reg:DF ...) (const_double ...))\n+;; to be reloaded by putting the constant into memory.\n+;; It must come before the more general movdf pattern.\n+;; ??? A similar pattern for SF mode values would also be useful, but it\n+;; is not as easy to write.\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=?r,r,f,o\")\n+\t(match_operand:DF 1 \"\" \"?E,G,m,G\"))]\n+  \"GET_CODE (operands[1]) == CONST_DOUBLE\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return output_move_double (operands);\n+    case 1:\n+      return \\\"mov %%g0,%0\\;mov %%g0,%R0\\\";\n+    case 2:\n+      return output_fp_move_double (operands);\n+    case 3:\n+      operands[1] = adj_offsettable_operand (operands[0], 4);\n+      return \\\"st %%g0,%0\\;st %%g0,%1\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"load,move,fpload,store\")\n+   (set_attr \"length\" \"3,2,3,3\")])\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, DFmode, 0))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"reg_or_nonsymb_mem_operand\" \"=f,r,Q,Q,f,&r,?f,?r\")\n+\t(match_operand:DF 1 \"reg_or_nonsymb_mem_operand\" \"f,r,f,r,Q,Q,r,f\"))]\n+  \"register_operand (operands[0], DFmode)\n+   || register_operand (operands[1], DFmode)\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+    return output_fp_move_double (operands);\n+  return output_move_double (operands);\n+}\"\n+  [(set_attr \"type\" \"fp,move,fpstore,store,fpload,load,multi,multi\")\n+   (set_attr \"length\" \"2,2,3,3,3,3,3,3\")])\n+\n+(define_insn \"\"\n+  [(set (mem:DF (match_operand:SI 0 \"symbolic_operand\" \"i,i\"))\n+\t(match_operand:DF 1 \"reg_or_0_operand\" \"rf,G\"))\n+   (clobber (match_scratch:SI 2 \"=&r,&r\"))]\n+  \"\"\n+  \"*\n+{\n+  output_asm_insn (\\\"sethi %%hi(%a0),%2\\\", operands);\n+  if (which_alternative == 0)\n+    return \\\"std %1,[%2+%%lo(%a0)]\\\";\n+  else\n+    return \\\"st %%g0,[%2+%%lo(%a0)]\\;st %%g0,[%2+%%lo(%a0+4)]\\\";\n+}\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"3\")])\n+\f\n+;; Double-word move insns.\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, DImode, 0))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"=r,Q,&r,&r,?f,?f,?f,?r,?Q\")\n+\t(match_operand:DI 1 \"general_operand\" \"r,r,Q,i,r,f,Q,f,f\"))]\n+  \"register_operand (operands[0], DImode)\n+   || register_operand (operands[1], DImode)\n+   || operands[1] == const0_rtx\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+    return output_fp_move_double (operands);\n+  return output_move_double (operands);\n+}\"\n+  [(set_attr \"type\" \"move,store,load,misc,multi,fp,fpload,multi,fpstore\")\n+   (set_attr \"length\" \"2,3,3,3,3,2,3,3,3\")])\n+\n+;; Floating-point move insns.\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, SFmode, 0))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"reg_or_nonsymb_mem_operand\" \"=f,r,rf,f,r,Q,Q\")\n+\t(match_operand:SF 1 \"reg_or_nonsymb_mem_operand\" \"f,r,!rf,Q,Q,f,r\"))]\n+  \"register_operand (operands[0], SFmode)\n+   || register_operand (operands[1], SFmode)\"\n+  \"@\n+   fmovs %1,%0\n+   mov %1,%0\n+   st %r1,[%%fp-4]\\;ld [%%fp-4],%0\n+   ld %1,%0\n+   ld %1,%0\n+   st %r1,%0\n+   st %r1,%0\"\n+  [(set_attr \"type\" \"fp,move,multi,fpload,load,fpstore,store\")\n+   (set_attr \"length\" \"*,*,2,*,*,*,*\")])\n+\n+(define_insn \"\"\n+  [(set (mem:SF (match_operand:SI 0 \"symbolic_operand\" \"i\"))\n+\t(match_operand:SF 1 \"reg_or_0_operand\" \"rfG\"))\n+   (clobber (match_scratch:SI 2 \"=&r\"))]\n+  \"\"\n+  \"sethi %%hi(%a0),%2\\;st %r1,[%2+%%lo(%a0)]\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"2\")])\n+\f\n+;;- zero extension instructions\n+\n+;; These patterns originally accepted general_operands, however, slightly\n+;; better code is generated by only accepting register_operands, and then\n+;; letting combine generate the ldu[hb] insns.\n+\n+(define_expand \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx temp = gen_reg_rtx (SImode);\n+  rtx shift_16 = gen_rtx (CONST_INT, VOIDmode, 16);\n+\n+  if (GET_CODE (operand1) == SUBREG)\n+    operand1 = XEXP (operand1, 0);\n+\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx (SUBREG, SImode, operand1, 0),\n+\t\t\t  shift_16));\n+  emit_insn (gen_lshrsi3 (operand0, temp, shift_16));\n+  DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"lduh %1,%0\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_expand \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(zero_extend:HI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n+\t(zero_extend:HI (match_operand:QI 1 \"sparc_operand\" \"r,I,Q\")))]\n+  \"GET_CODE (operands[1]) != CONST_INT\"\n+  \"@\n+   and %1,0xff,%0;\n+   mov (%1 & 0xff),%0\n+   ldub %1,%0\"\n+  [(set_attr \"type\" \"unary,move,load\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_expand \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"sparc_operand\" \"r,I,Q\")))]\n+  \"GET_CODE (operands[1]) != CONST_INT\"\n+  \"@\n+   and %1,0xff,%0\n+   mov (%1 & 0xff),%0\n+   ldub %1,%0\"\n+  [(set_attr \"type\" \"unary,move,load\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CC 0)\n+\t(compare:CC (zero_extend:SI (match_operand:QI 0 \"register_operand\" \"r\"))\n+\t\t    (const_int 0)))]\n+  \"\"\n+  \"andcc %0,0xff,%%g0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CC 0)\n+\t(compare:CC (zero_extend:SI (match_operand:QI 1 \"register_operand\" \"r\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (match_dup 1)))]\n+  \"\"\n+  \"andcc %1,0xff,%0\"\n+  [(set_attr \"type\" \"unary\")])\n+\f\n+;;- sign extension instructions\n+\n+;; These patterns originally accepted general_operands, however, slightly\n+;; better code is generated by only accepting register_operands, and then\n+;; letting combine generate the lds[hb] insns.\n+\n+(define_expand \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx temp = gen_reg_rtx (SImode);\n+  rtx shift_16 = gen_rtx (CONST_INT, VOIDmode, 16);\n+\n+  if (GET_CODE (operand1) == SUBREG)\n+    operand1 = XEXP (operand1, 0);\n+\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx (SUBREG, SImode, operand1, 0),\n+\t\t\t  shift_16));\n+  emit_insn (gen_ashrsi3 (operand0, temp, shift_16));\n+  DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"ldsh %1,%0\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_expand \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(sign_extend:HI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx temp = gen_reg_rtx (SImode);\n+  rtx shift_24 = gen_rtx (CONST_INT, VOIDmode, 24);\n+\n+  if (GET_CODE (operand1) == SUBREG)\n+    operand1 = XEXP (operand1, 0);\n+  if (GET_CODE (operand0) == SUBREG)\n+    operand0 = XEXP (operand0, 0);\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx (SUBREG, SImode, operand1, 0),\n+\t\t\t  shift_24));\n+  if (GET_MODE (operand0) != SImode)\n+    operand0 = gen_rtx (SUBREG, SImode, operand0, 0);\n+  emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n+  DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"ldsb %1,%0\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_expand \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx temp = gen_reg_rtx (SImode);\n+  rtx shift_24 = gen_rtx (CONST_INT, VOIDmode, 24);\n+\n+  if (GET_CODE (operand1) == SUBREG)\n+    operand1 = XEXP (operand1, 0);\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx (SUBREG, SImode, operand1, 0),\n+\t\t\t  shift_24));\n+  emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n+  DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"ldsb %1,%0\"\n+  [(set_attr \"type\" \"load\")])\n+\f\n+;; Conversions between float and double.\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(float_extend:DF\n+\t (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fstod %1,%0\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(float_truncate:SF\n+\t (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fdtos %1,%0\"\n+  [(set_attr \"type\" \"fp\")])\n+\f\n+;; Conversion between fixed point and floating point.\n+\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n+\t(float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"rfm\")))]\n+  \"\"\n+  \"* return output_floatsisf2 (operands);\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"3\")])\n+\n+(define_insn \"floatsidf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n+\t(float:DF (match_operand:SI 1 \"nonimmediate_operand\" \"rfm\")))]\n+  \"\"\n+  \"* return output_floatsidf2 (operands);\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"3\")])\n+\n+;; Convert a float to an actual integer.\n+;; Truncation is performed as part of the conversion.\n+\n+(define_insn \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(fix:SI (fix:SF (match_operand:SF 1 \"general_operand\" \"fm\"))))\n+   (clobber (match_scratch:SF 2 \"=&f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[1]))\n+    output_asm_insn (\\\"fstoi %1,%2\\\", operands);\n+  else\n+    output_asm_insn (\\\"ld %1,%2\\;fstoi %2,%2\\\", operands);\n+  if (GET_CODE (operands[0]) == MEM)\n+    return \\\"st %2,%0\\\";\n+  else\n+    return \\\"st %2,[%%fp-4]\\;ld [%%fp-4],%0\\\";\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"3\")])\n+\n+(define_insn \"fix_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(fix:SI (fix:DF (match_operand:DF 1 \"general_operand\" \"fm\"))))\n+   (clobber (match_scratch:DF 2 \"=&f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[1]))\n+    output_asm_insn (\\\"fdtoi %1,%2\\\", operands);\n+  else\n+    {\n+      rtx xoperands[3];\n+      xoperands[0] = operands[2];\n+      xoperands[1] = operands[1];\n+      output_asm_insn (output_fp_move_double (xoperands), xoperands);\n+      output_asm_insn (\\\"fdtoi %2,%2\\\", operands);\n+    }\n+  if (GET_CODE (operands[0]) == MEM)\n+    return \\\"st %2,%0\\\";\n+  else\n+    return \\\"st %2,[%%fp-4]\\;ld [%%fp-4],%0\\\";\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"3\")])\n+\f\n+;;- arithmetic instructions\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n+\t\t (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n+   (clobber (reg:SI 0))]\n+  \"\"\n+  \"*\n+{\n+  rtx op2 = operands[2];\n+\n+  /* If constant is postive, upper bits zeroed, otherwise unchanged\n+   * give the assembler a chance to pick the move instruction. */\n+  if (GET_CODE (op2) == CONST_INT)\n+    {\n+      int sign = INTVAL (op2);\n+      if (sign < 0)\n+\treturn \\\"addcc %R1,%2,%R0\\;addx %1,-1,%0\\\";\n+      return \\\"addcc %R1,%2,%R0\\;addx %1,0,%0\\\";\n+    }\n+  else if (GET_CODE (op2) == CONST_DOUBLE)\n+    {\n+      int sign = CONST_DOUBLE_HIGH (op2);\n+      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t     CONST_DOUBLE_LOW (operands[1]));\n+      if (sign < 0)\n+        return \\\"addcc %R1,%2,%R0\\;addx %1,-1,%0\\\";\n+      return \\\"addcc %R1,%2,%R0\\;addx %1,0,%0\\\";\n+    }\n+  return \\\"addcc %R1,%R2,%R0\\;addx %1,%2,%0\\\";\n+}\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"add %1,%2,%0\")\n+\n+(define_insn \"\"\n+  [(set (reg:CC_NOOV 0)\n+\t(compare:CC_NOOV (plus:SI (match_operand:SI 0 \"arith_operand\" \"%r\")\n+\t\t\t\t  (match_operand:SI 1 \"arith_operand\" \"rI\"))\n+\t\t\t (const_int 0)))]\n+  \"\"\n+  \"addcc %0,%1,%%g0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CC_NOOV 0)\n+\t(compare:CC_NOOV (plus:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n+\t\t\t\t  (match_operand:SI 2 \"arith_operand\" \"rI\"))\n+\t\t\t (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"addcc %1,%2,%0\")\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n+   (clobber (reg:SI 0))]\n+  \"\"\n+  \"*\n+{\n+  rtx op2 = operands[2];\n+\n+  /* If constant is postive, upper bits zeroed, otherwise unchanged\n+   * give the assembler a chance to pick the move instruction. */\n+  if (GET_CODE (op2) == CONST_INT)\n+    {\n+      int sign = INTVAL (op2);\n+      if (sign < 0)\n+\treturn \\\"subcc %R1,%2,%R0\\;subx %1,-1,%0\\\";\n+      return \\\"subcc %R1,%2,%R0\\;subx %1,0,%0\\\";\n+    }\n+  else if (GET_CODE (op2) == CONST_DOUBLE)\n+    {\n+      int sign = CONST_DOUBLE_HIGH (op2);\n+      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t     CONST_DOUBLE_LOW (operands[1]));\n+      if (sign < 0)\n+        return \\\"subcc %R1,%2,%R0\\;subx %1,-1,%0\\\";\n+      return \\\"subcc %R1,%2,%R0\\;subx %1,0,%0\\\";\n+    }\n+  return \\\"subcc %R1,%R2,%R0\\;subx %1,%2,%0\\\";\n+}\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"sub %1,%2,%0\")\n+\n+(define_insn \"\"\n+  [(set (reg:CC_NOOV 0)\n+\t(compare:CC_NOOV (minus:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t   (match_operand:SI 1 \"arith_operand\" \"rI\"))\n+\t\t\t (const_int 0)))]\n+  \"\"\n+  \"subcc %0,%1,%%g0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CC_NOOV 0)\n+\t(compare:CC_NOOV (minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t   (match_operand:SI 2 \"arith_operand\" \"rI\"))\n+\t\t\t (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"subcc %1,%2,%0\")\n+\n+;;- and instructions\n+;; We define DImode `and` so with DImode `not` we can get\n+;; DImode `andn`.  Other combinations are possible.\n+\n+(define_expand \"anddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(and:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n+\t\t(match_operand:DI 2 \"arith_double_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx op2 = operands[2];\n+\n+  /* If constant is postive, upper bits zeroed, otherwise unchanged\n+   * give the assembler a chance to pick the move instruction. */\n+  if (GET_CODE (op2) == CONST_INT)\n+    {\n+      int sign = INTVAL (op2);\n+      if (sign < 0)\n+\treturn \\\"mov %1,%0\\;and %R1,%2,%R0\\\";\n+      return \\\"mov 0,%0\\;and %R1,%2,%R0\\\";\n+    }\n+  else if (GET_CODE (op2) == CONST_DOUBLE)\n+    {\n+      int sign = CONST_DOUBLE_HIGH (op2);\n+      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t     CONST_DOUBLE_LOW (operands[1]));\n+      if (sign < 0)\n+\treturn \\\"mov %1,%0\\;and %R1,%2,%R0\\\";\n+      return \\\"mov 0,%0\\;and %R1,%2,%R0\\\";\n+    }\n+  return \\\"and %1,%2,%0\\;and %R1,%R2,%R0\\\";\n+}\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"and %1,%2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r\"))\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"andn %2,%1,%0\\;andn %R2,%R1,%R0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"andn %2,%1,%0\")\n+\n+(define_expand \"iordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ior:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n+\t\t(match_operand:DI 2 \"arith_double_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ior:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx op2 = operands[2];\n+\n+  /* If constant is postive, upper bits zeroed, otherwise unchanged\n+   * give the assembler a chance to pick the move instruction. */\n+  if (GET_CODE (op2) == CONST_INT)\n+    {\n+      int sign = INTVAL (op2);\n+      if (sign < 0)\n+\treturn \\\"mov -1,%0\\;or %R1,%2,%R0\\\";\n+      return \\\"mov %1,%0\\;or %R1,%2,%R0\\\";\n+    }\n+  else if (GET_CODE (op2) == CONST_DOUBLE)\n+    {\n+      int sign = CONST_DOUBLE_HIGH (op2);\n+      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t     CONST_DOUBLE_LOW (operands[1]));\n+      if (sign < 0)\n+\treturn \\\"mov -1,%0\\;or %R1,%2,%R0\\\";\n+      return \\\"mov %1,%0\\;or %R1,%2,%R0\\\";\n+    }\n+  return \\\"or %1,%2,%0\\;or %R1,%R2,%R0\\\";\n+}\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"or %1,%2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ior:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r\"))\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"orn %2,%1,%0\\;orn %R2,%R1,%R0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (not:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"orn %2,%1,%0\")\n+\n+(define_expand \"xordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(xor:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n+\t\t(match_operand:DI 2 \"arith_double_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(xor:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx op2 = operands[2];\n+\n+  /* If constant is postive, upper bits zeroed, otherwise unchanged\n+   * give the assembler a chance to pick the move instruction. */\n+  if (GET_CODE (op2) == CONST_INT)\n+    {\n+      int sign = INTVAL (op2);\n+      if (sign < 0)\n+\treturn \\\"xor %1,-1,%0\\;xor %R1,%2,%R0\\\";\n+      return \\\"mov %1,%0\\;xor %R1,%2,%R0\\\";\n+    }\n+  else if (GET_CODE (op2) == CONST_DOUBLE)\n+    {\n+      int sign = CONST_DOUBLE_HIGH (op2);\n+      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t     CONST_DOUBLE_LOW (operands[1]));\n+      if (sign < 0)\n+\treturn \\\"xor %1,-1,%0\\;xor %R1,%2,%R0\\\";\n+      return \\\"mov %1,%0\\;xor %R1,%2,%R0\\\";\n+    }\n+  return \\\"xor %1,%2,%0\\;xor %R1,%R2,%R0\\\";\n+}\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(xor:SI (match_operand:SI 1 \"arith_operand\" \"%rJ\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"xor %r1,%2,%0\")\n+\n+;; xnor patterns.  Note that (a ^ ~b) == (~a ^ b) == ~(a ^ b).\n+;; Combine now canonicalizes to the rightmost expression.\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(not:DI (xor:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t(match_operand:DI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"xnor %1,%2,%0\\;xnor %R1,%R2,%R0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (xor:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t(match_operand:SI 2 \"arith_operand\" \"rI\"))))]\n+  \"\"\n+  \"xnor %r1,%2,%0\")\n+\n+;; These correspond to the above in the case where we also (or only)\n+;; want to set the condition code.  \n+\n+(define_insn \"\"\n+  [(set (reg:CC 0)\n+\t(compare:CC\n+\t (match_operator:SI 2 \"cc_arithop\"\n+\t\t\t    [(match_operand:SI 0 \"arith_operand\" \"%r\")\n+\t\t\t     (match_operand:SI 1 \"arith_operand\" \"rI\")])\n+\t (const_int 0)))]\n+  \"\"\n+  \"%A2cc %0,%1,%%g0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CC 0)\n+\t(compare:CC\n+\t (match_operator:SI 3 \"cc_arithop\"\n+\t\t\t    [(match_operand:SI 1 \"arith_operand\" \"%r\")\n+\t\t\t     (match_operand:SI 2 \"arith_operand\" \"rI\")])\n+\t (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_dup 3))]\n+  \"\"\n+  \"%A3cc %1,%2,%0\")\n+\n+(define_insn \"\"\n+  [(set (reg:CC 0)\n+\t(compare:CC\n+\t (not:SI (xor:SI (match_operand:SI 0 \"reg_or_0_operand\" \"%rJ\")\n+\t\t\t (match_operand:SI 1 \"arith_operand\" \"rI\")))\n+\t (const_int 0)))]\n+  \"\"\n+  \"xnorcc %r0,%1,%%g0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CC 0)\n+\t(compare:CC\n+\t (not:SI (xor:SI (match_operand:SI 1 \"reg_or_0_operand\" \"%rJ\")\n+\t\t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))\n+\t (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (xor:SI (match_dup 1) (match_dup 2))))]\n+  \"\"\n+  \"xnorcc %r1,%2,%0\")\n+\n+(define_insn \"\"\n+  [(set (reg:CC 0)\n+\t(compare:CC\n+\t (match_operator:SI 2 \"cc_arithopn\"\n+\t\t\t    [(not:SI (match_operand:SI 0 \"arith_operand\" \"rI\"))\n+\t\t\t     (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\")])\n+\t (const_int 0)))]\n+  \"\"\n+  \"%B2cc %r1,%0,%%g0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CC 0)\n+\t(compare:CC\n+\t (match_operator:SI 3 \"cc_arithopn\"\n+\t\t\t    [(not:SI (match_operand:SI 1 \"arith_operand\" \"rI\"))\n+\t\t\t     (match_operand:SI 2 \"reg_or_0_operand\" \"rJ\")])\n+\t (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_dup 3))]\n+  \"\"\n+  \"%B3cc %r2,%1,%0\")\n+\n+;; We cannot use the \"neg\" pseudo insn because the Sun assembler\n+;; does not know how to make it work for constants.\n+\n+(define_insn \"negdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(neg:DI (match_operand:DI 1 \"register_operand\" \"r\")))\n+   (clobber (reg:SI 0))]\n+  \"\"\n+  \"subcc %%g0,%R1,%R0\\;subx %%g0,%1,%0\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n+\t(neg:SI (match_operand:SI 1 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"sub %%g0,%1,%0\"\n+  [(set_attr \"type\" \"unary\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CC_NOOV 0)\n+\t(compare:CC_NOOV (neg:SI (match_operand:SI 0 \"arith_operand\" \"rI\"))\n+\t\t\t (const_int 0)))]\n+  \"\"\n+  \"subcc %%g0,%0,%%g0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CC_NOOV 0)\n+\t(compare:CC_NOOV (neg:SI (match_operand:SI 1 \"arith_operand\" \"rI\"))\n+\t\t\t (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (match_dup 1)))]\n+  \"\"\n+  \"subcc %%g0,%1,%0\"\n+  [(set_attr \"type\" \"unary\")])\n+\n+;; We cannot use the \"not\" pseudo insn because the Sun assembler\n+;; does not know how to make it work for constants.\n+(define_expand \"one_cmpldi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(not:DI (match_operand:DI 1 \"arith_double_operand\" \"rHI\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(not:DI (match_operand:DI 1 \"arith_double_operand\" \"rHI\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx op1 = operands[1];\n+\n+  if (GET_CODE (op1) == CONST_INT)\n+    {\n+      int sign = INTVAL (op1);\n+      if (sign < 0)\n+\treturn \\\"xnor %%g0,%1,%R0\\;xnor %%g0,-1,%0\\\";\n+      return \\\"xnor %%g0,%1,%R0\\;xnor %%g0,0,%0\\\";\n+    }\n+  else if (GET_CODE (op1) == CONST_DOUBLE)\n+    {\n+      int sign = CONST_DOUBLE_HIGH (op1);\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t     CONST_DOUBLE_LOW (operands[1]));\n+      if (sign < 0)\n+\treturn \\\"xnor %%g0,%1,%R0\\;xnor %%g0,-1,%0\\\";\n+      return \\\"xnor %%g0,%1,%R0\\;xnor %%g0,0,%0\\\";\n+    }\n+  return \\\"xnor %%g0,%1,%0\\;xnor %%g0,%R1,%R0\\\";\n+}\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"xnor %%g0,%1,%0\"\n+  [(set_attr \"type\" \"unary\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CC 0)\n+\t(compare:CC (not:SI (match_operand:SI 0 \"arith_operand\" \"rI\"))\n+\t\t    (const_int 0)))]\n+  \"\"\n+  \"xnorcc %%g0,%0,%%g0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CC 0)\n+\t(compare:CC (not:SI (match_operand:SI 1 \"arith_operand\" \"rI\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_dup 1)))]\n+  \"\"\n+  \"xnorcc %%g0,%1,%0\"\n+  [(set_attr \"type\" \"unary\")])\n+\f\n+;; Floating point arithmetic instructions.\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(plus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"faddd %1,%2,%0\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(plus:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fadds %1,%2,%0\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:DF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fsubd %1,%2,%0\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fsubs %1,%2,%0\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(mult:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fmuld %1,%2,%0\"\n+  [(set_attr \"type\" \"fpmul\")])\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(mult:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fmuls %1,%2,%0\"\n+  [(set_attr \"type\" \"fpmul\")])\n+\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(div:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t(match_operand:DF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fdivd %1,%2,%0\"\n+  [(set_attr \"type\" \"fpdiv\")])\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(div:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t(match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fdivs %1,%2,%0\"\n+  [(set_attr \"type\" \"fpdiv\")])\n+\n+(define_insn \"negdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n+\t(neg:DF (match_operand:DF 1 \"register_operand\" \"0,f\")))]\n+  \"\"\n+  \"@\n+   fnegs %0,%0\n+   fnegs %1,%0\\;fmovs %R1,%R0\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"1,2\")])\n+\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(neg:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fnegs %1,%0\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"absdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n+\t(abs:DF (match_operand:DF 1 \"register_operand\" \"0,f\")))]\n+  \"\"\n+  \"@\n+   fabss %0,%0\n+   fabss %1,%0\\;fmovs %R1,%R0\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"1,2\")])\n+\n+(define_insn \"abssf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(abs:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fabss %1,%0\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"sqrtdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(sqrt:DF (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fsqrtd %1,%0\"\n+  [(set_attr \"type\" \"fpsqrt\")])\n+\n+(define_insn \"sqrtsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fsqrts %1,%0\"\n+  [(set_attr \"type\" \"fpsqrt\")])\n+\f\n+;;- arithmetic shift instructions\n+\n+;; We can trivially handle shifting the constant 1 by 64 bits.\n+;; For other shifts we use the library routine.\n+;; ??? Questionable, we can do better than this can't we?\n+(define_expand \"ashldi3\"\n+  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t\t   (ashift:DI (match_operand:DI 1 \"const_double_operand\" \"\")\n+\t\t\t      (match_operand:SI 2 \"register_operand\" \"\")))\n+\t      (clobber (reg:SI 0))])]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE\n+      && CONST_DOUBLE_HIGH (operands[1]) == 0\n+      && CONST_DOUBLE_LOW (operands[1]) == 1)\n+    operands[1] = const1_rtx;\n+  else if (operands[1] != const1_rtx)\n+    FAIL;\n+}\")\n+\n+;; ??? Questionable, we can do better than this can't we?\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n+\t(ashift:DI (const_int 1)\n+\t\t   (match_operand:SI 2 \"register_operand\" \"r\")))\n+   (clobber (reg:SI 0))]\n+  \"\"\n+  \"subcc %2,32,%%g0\\;addx %%g0,0,%R0\\;xor %R0,1,%0\\;sll %R0,%2,%R0\\;sll %0,%2,%0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"5\")])\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"sll %1,%2,%0\")\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t     (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"sra %1,%2,%0\")\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t     (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"srl %1,%2,%0\")\n+\f\n+;; Unconditional and other jump instructions\n+;; Note that for the Sparc, by setting the annul bit on an unconditional\n+;; branch, the following insn is never executed.  This saves us a nop,\n+;; but requires a debugger which can handle annuled branches.\n+(define_insn \"jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"b%* %l0\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_expand \"tablejump\"\n+  [(parallel [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t      (use (label_ref (match_operand 1 \"\" \"\")))])]\n+  \"\"\n+  \"\n+{\n+  /* We need to use the PC value in %o7 that was set up when the address\n+     of the label was loaded into a register, so we need different RTL.  */\n+  if (flag_pic)\n+    {\n+      emit_insn (gen_pic_tablejump (operands[0], operands[1]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"pic_tablejump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))\n+   (use (reg:SI 15))]\n+  \"\"\n+  \"jmp %%o7+%0%#\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"jmp %a0%#\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))\n+   (set (reg:SI 15) (label_ref (match_dup 0)))]\n+  \"\"\n+  \"call %l0%#\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+;; This pattern recognizes the \"instruction\" that appears in \n+;; a function call that wants a structure value, \n+;; to inform the called function if compiled with Sun CC.\n+;(define_insn \"\"\n+;  [(match_operand:SI 0 \"immediate_operand\" \"\")]\n+;  \"GET_CODE (operands[0]) == CONST_INT && INTVAL (operands[0]) > 0\"\n+;  \"unimp %0\"\n+;  [(set_attr \"type\" \"marker\")])\n+\n+;;- jump to subroutine\n+(define_expand \"call\"\n+  ;; Note that this expression is not used for generating RTL.\n+  ;; All the RTL is generated explicitly below.\n+  [(call (match_operand:SI 0 \"call_operand\" \"\")\n+\t (match_operand 3 \"\" \"i\"))]\n+  ;; operands[2] is next_arg_register\n+  ;; operands[3] is struct_value_size_rtx.\n+  \"\"\n+  \"\n+{\n+  rtx fn_rtx, nregs_rtx;\n+\n+  if (GET_CODE (XEXP (operands[0], 0)) == LABEL_REF)\n+    {\n+      /* This is really a PIC sequence.  We want to represent\n+\t it as a funny jump so it's delay slots can be filled. \n+\n+\t ??? But if this really *is* a CALL, will not it clobber the\n+\t call-clobbered registers?  We lose this if it is a JUMP_INSN.\n+\t Why cannot we have delay slots filled if it were a CALL?  */\n+\n+      if (INTVAL (operands[3]) > 0)\n+\temit_jump_insn (gen_rtx (PARALLEL, VOIDmode, gen_rtvec (3,\n+\t\t\t\t gen_rtx (SET, VOIDmode, pc_rtx,\n+\t\t\t\t\t  XEXP (operands[0], 0)),\n+\t\t\t\t operands[3],\n+\t\t\t\t gen_rtx (CLOBBER, VOIDmode,\n+\t\t\t\t\t  gen_rtx (REG, SImode, 15)))));\n+      else\n+\temit_jump_insn (gen_rtx (PARALLEL, VOIDmode, gen_rtvec (2,\n+\t\t\t\t gen_rtx (SET, VOIDmode, pc_rtx,\n+\t\t\t\t\t  XEXP (operands[0], 0)),\n+\t\t\t\t gen_rtx (CLOBBER, VOIDmode,\n+\t\t\t\t\t  gen_rtx (REG, SImode, 15)))));\n+      goto finish_call;\n+    }\n+\n+  fn_rtx = operands[0];\n+\n+  /* Count the number of parameter registers being used by this call.\n+     if that argument is NULL, it means we are using them all, which\n+     means 6 on the sparc.  */\n+#if 0\n+  if (operands[2])\n+    nregs_rtx = gen_rtx (CONST_INT, VOIDmode, REGNO (operands[2]) - 8);\n+  else\n+    nregs_rtx = gen_rtx (CONST_INT, VOIDmode, 6);\n+#else\n+  nregs_rtx = const0_rtx;\n+#endif\n+\n+  if (INTVAL (operands[3]) > 0)\n+    emit_call_insn (gen_rtx (PARALLEL, VOIDmode, gen_rtvec (3,\n+\t\t\t     gen_rtx (CALL, VOIDmode, fn_rtx, nregs_rtx),\n+\t\t\t     operands[3],\n+\t\t\t     gen_rtx (CLOBBER, VOIDmode,\n+\t\t\t\t\t       gen_rtx (REG, SImode, 15)))));\n+  else\n+    emit_call_insn (gen_rtx (PARALLEL, VOIDmode, gen_rtvec (2,\n+\t\t\t     gen_rtx (CALL, VOIDmode, fn_rtx, nregs_rtx),\n+\t\t\t     gen_rtx (CLOBBER, VOIDmode,\n+\t\t\t\t\t       gen_rtx (REG, SImode, 15)))));\n+\n+ finish_call:\n+#if 0\n+  /* If this call wants a structure value,\n+     emit an unimp insn to let the called function know about this.  */\n+  if (INTVAL (operands[3]) > 0)\n+    {\n+      rtx insn = emit_insn (operands[3]);\n+      SCHED_GROUP_P (insn) = 1;\n+    }\n+#endif\n+\n+  DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(call (mem:SI (match_operand:SI 0 \"call_operand_address\" \"S,r\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (reg:SI 15))]\n+  ;;- Do not use operand 1 for most machines.\n+  \"\"\n+  \"*\n+{\n+  return \\\"call %a0,%1%#\\\";\n+}\"\n+  [(set_attr \"type\" \"call\")])\n+\n+;; This is a call that wants a structure value.\n+(define_insn \"\"\n+  [(call (mem:SI (match_operand:SI 0 \"call_operand_address\" \"S,r\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (match_operand 2 \"immediate_operand\" \"\")\n+   (clobber (reg:SI 15))]\n+  ;;- Do not use operand 1 for most machines.\n+  \"GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) > 0\"\n+  \"*\n+{\n+  return \\\"call %a0,%1\\;nop\\;unimp %2\\\";\n+}\"\n+  [(set_attr \"type\" \"call_no_delay_slot\")])\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"register_operand\" \"=rf\")\n+\t(call (match_operand:SI 1 \"\" \"\")\n+\t      (match_operand 4 \"\" \"\")))]\n+  ;; operand 3 is next_arg_register\n+  \"\"\n+  \"\n+{\n+  rtx fn_rtx, nregs_rtx;\n+  rtvec vec;\n+\n+  fn_rtx = operands[1];\n+\n+#if 0\n+  if (operands[3])\n+    nregs_rtx = gen_rtx (CONST_INT, VOIDmode, REGNO (operands[3]) - 8);\n+  else\n+    nregs_rtx = gen_rtx (CONST_INT, VOIDmode, 6);\n+#else\n+  nregs_rtx = const0_rtx;\n+#endif\n+\n+  vec = gen_rtvec (2,\n+\t\t   gen_rtx (SET, VOIDmode, operands[0],\n+\t\t\t    gen_rtx (CALL, VOIDmode, fn_rtx, nregs_rtx)),\n+\t\t   gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 15)));\n+\n+  emit_call_insn (gen_rtx (PARALLEL, VOIDmode, vec));\n+\n+  DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (mem:SI (match_operand:SI 1 \"call_operand_address\" \"rS\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (reg:SI 15))]\n+  ;;- Do not use operand 2 for most machines.\n+  \"\"\n+  \"*\n+{\n+  return \\\"call %a1,%2%#\\\";\n+}\"\n+  [(set_attr \"type\" \"call\")])\n+\f\n+(define_insn \"return\"\n+  [(return)]\n+  \"! TARGET_EPILOGUE\"\n+  \"* return output_return (operands);\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\")\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))]\n+  \"\"\n+ \"jmp %a0%#\"\n+ [(set_attr \"type\" \"branch\")])\n+ \n+(define_expand \"nonlocal_goto\"\n+  [(match_operand:SI 0 \"general_operand\" \"\")\n+   (match_operand:SI 1 \"general_operand\" \"\")\n+   (match_operand:SI 2 \"general_operand\" \"\")\n+   (match_operand:SI 3 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx temp;\n+  /* Trap instruction to flush all the registers window.  */\n+  emit_insn (gen_rtx (UNSPEC_VOLATILE, VOIDmode,\n+\t\t      gen_rtvec (1, const0_rtx), 0));\n+  /* Load the fp value for the containing fn into %fp.\n+     This is needed because operands[2] refers to %fp.  */\n+  emit_move_insn (virtual_stack_vars_rtx, operands[0]);\n+  /* Find the containing function's current nonlocal goto handler,\n+     which will do any cleanups and then jump to the label.  */\n+  emit_move_insn (gen_rtx (REG, SImode, 8), operands[1]);\n+  /* Restore %fp from stack pointer value for containing function.\n+     The restore insn that follows will move this to %sp,\n+     and reload the appropriate value into %fp.  */\n+  emit_move_insn (frame_pointer_rtx, operands[2]);\n+  /* Put in the static chain register the nonlocal label address.  */\n+  emit_move_insn (static_chain_rtx, operands[3]);\n+  /* USE of frame_pointer_rtx added for consistency; not clear if\n+     really needed.  */\n+  emit_insn (gen_rtx (USE, VOIDmode, frame_pointer_rtx));\n+  emit_insn (gen_rtx (USE, VOIDmode, stack_pointer_rtx));\n+  emit_insn (gen_rtx (USE, VOIDmode, static_chain_rtx));\n+  emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, SImode, 8)));\n+  /* Return, restoring reg window and jumping to goto handler.  */\n+  emit_insn (gen_rtx (UNSPEC_VOLATILE, VOIDmode,\n+\t\t      gen_rtvec (1, const0_rtx), 1));\n+  DONE;\n+}\")\n+\n+;; Special trap insn to flush register windows.\n+(define_insn \"\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"ta 3\")\n+\n+(define_insn \"\"\n+  [(unspec_volatile [(const_int 0)] 1)]\n+  \"\"\n+  \"jmp %%o0+0\\;restore\")\n+\n+;(define_insn \"tail_call\" ;; tail call\n+;  [(set (pc) (match_operand 0 \"memory_operand\" \"m\"))]\n+;  \"tail_call_valid_p ()\"\n+;  \"* return output_tail_call (operands, insn);\"\n+;  [(set_attr \"type\" \"branch\")])\n+\f\n+;; Split up troublesome insns for better scheduling.  */\n+\n+;; The following patterns are straightforward.  They can be applied\n+;; either before or after register allocation.\n+\n+(define_split\n+  [(set (match_operator 0 \"memop\" [(match_operand:SI 1 \"symbolic_operand\" \"\")])\n+\t(match_operand 2 \"reg_or_0_operand\" \"\"))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"! flag_pic\"\n+  [(set (match_dup 3) (high:SI (match_dup 1)))\n+   (set (match_op_dup 0 [(lo_sum:SI (match_dup 3) (match_dup 1))])\n+\t(match_dup 2))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operator 0 \"memop\"\n+\t\t\t[(match_operand:SI 1 \"immediate_operand\" \"\")])\n+\t(match_operand 2 \"general_operand\" \"\"))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"flag_pic\"\n+  [(set (match_op_dup 0 [(match_dup 1)])\n+\t(match_dup 2))]\n+  \"\n+{\n+  operands[1] = legitimize_pic_address (operands[1], GET_MODE (operands[0]),\n+\t\t\t\t\toperands[3], 0);\n+}\")\n+\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operator 1 \"memop\"\n+\t\t\t[(match_operand:SI 2 \"immediate_operand\" \"\")]))]\n+  \"flag_pic\"\n+  [(set (match_dup 0)\n+\t(match_op_dup 1 [(match_dup 2)]))]\n+  \"\n+{\n+  operands[2] = legitimize_pic_address (operands[2], GET_MODE (operands[1]),\n+\t\t\t\t\toperands[0], 0);\n+}\")\n+\n+;; Sign- and Zero-extend operations can have symbolic memory operands.\n+\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operator 1 \"extend_op\"\n+\t\t\t[(match_operator 2 \"memop\"\n+\t\t\t\t\t [(match_operand:SI 3 \"immediate_operand\" \"\")])]))]\n+  \"flag_pic\"\n+  [(set (match_dup 0)\n+\t(match_op_dup 1 [(match_op_dup 2 [(match_dup 3)])]))]\n+  \"\n+{\n+  operands[3] = legitimize_pic_address (operands[3], GET_MODE (operands[2]),\n+\t\t\t\t\toperands[0], 0);\n+}\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"immediate_operand\" \"\"))]\n+  \"! flag_pic && (GET_CODE (operands[1]) == SYMBOL_REF\n+\t\t  || GET_CODE (operands[1]) == CONST\n+\t\t  || GET_CODE (operands[1]) == LABEL_REF)\"\n+  [(set (match_dup 0) (high:SI (match_dup 1)))\n+   (set (match_dup 0)\n+\t(lo_sum:SI (match_dup 0) (match_dup 1)))]\n+  \"\")\n+\n+;; LABEL_REFs are not modified by `legitimize_pic_address`\n+;; so do not recurse infinitely in the PIC case.\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"immediate_operand\" \"\"))]\n+  \"flag_pic && (GET_CODE (operands[1]) == SYMBOL_REF\n+\t\t|| GET_CODE (operands[1]) == CONST)\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"\n+{\n+  operands[1] = legitimize_pic_address (operands[1], Pmode, operands[0], 0);\n+}\")\n+\f\n+;; These split sne/seq insns.  The forms of the resulting insns are \n+;; somewhat bogus, but they avoid extra patterns and show data dependency.\n+;; Nothing will look at these in detail after splitting has occurred.\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ne:SI (match_operand:SI 1 \"register_operand\" \"\") (const_int 0)))\n+   (clobber (reg:CC 0))]\n+  \"\"\n+  [(set (reg:CC_NOOV 0) (compare:CC_NOOV (neg:SI (match_dup 1))\n+\t\t\t\t\t (const_int 0)))\n+   (set (match_dup 0) (ltu:SI (reg:CC 0) (const_int 0)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(neg:SI (ne:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t       (const_int 0))))\n+   (clobber (reg:CC 0))]\n+  \"\"\n+  [(set (reg:CC_NOOV 0) (compare:CC_NOOV (neg:SI (match_dup 1))\n+\t\t\t\t\t (const_int 0)))\n+   (set (match_dup 0) (neg:SI (ltu:SI (reg:CC 0) (const_int 0))))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(eq:SI (match_operand:SI 1 \"register_operand\" \"\") (const_int 0)))\n+   (clobber (reg:CC 0))]\n+  \"\"\n+  [(set (reg:CC_NOOV 0) (compare:CC_NOOV (neg:SI (match_dup 1))\n+\t\t\t\t\t (const_int 0)))\n+   (set (match_dup 0) (geu:SI (reg:CC 0) (const_int 0)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(neg:SI (eq:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t       (const_int 0))))\n+   (clobber (reg:CC 0))]\n+  \"\"\n+  [(set (reg:CC_NOOV 0) (compare:CC_NOOV (neg:SI (match_dup 1))\n+\t\t\t\t\t (const_int 0)))\n+   (set (match_dup 0) (neg:SI (geu:SI (reg:CC 0) (const_int 0))))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (ne:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t(const_int 0))\n+\t\t (match_operand:SI 2 \"register_operand\" \"\")))\n+   (clobber (reg:CC 0))]\n+  \"\"\n+  [(set (reg:CC_NOOV 0) (compare:CC_NOOV (neg:SI (match_dup 1))\n+\t\t\t\t\t (const_int 0)))\n+   (set (match_dup 0) (plus:SI (ltu:SI (reg:CC 0) (const_int 0))\n+\t\t\t       (match_dup 2)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(minus:SI (match_operand:SI 2 \"register_operand\" \"\")\n+\t\t  (ne:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t (const_int 0))))\n+   (clobber (reg:CC 0))]\n+  \"\"\n+  [(set (reg:CC_NOOV 0) (compare:CC_NOOV (neg:SI (match_dup 1))\n+\t\t\t\t\t (const_int 0)))\n+   (set (match_dup 0) (minus:SI (match_dup 2)\n+\t\t\t\t(ltu:SI (reg:CC 0) (const_int 0))))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (eq:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t(const_int 0))\n+\t\t (match_operand:SI 2 \"register_operand\" \"\")))\n+   (clobber (reg:CC 0))]\n+  \"\"\n+  [(set (reg:CC_NOOV 0) (compare:CC_NOOV (neg:SI (match_dup 1))\n+\t\t\t\t\t (const_int 0)))\n+   (set (match_dup 0) (plus:SI (geu:SI (reg:CC 0) (const_int 0))\n+\t\t\t       (match_dup 2)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(minus:SI (match_operand:SI 2 \"register_operand\" \"\")\n+\t\t  (eq:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t (const_int 0))))\n+   (clobber (reg:CC 0))]\n+  \"\"\n+  [(set (reg:CC_NOOV 0) (compare:CC_NOOV (neg:SI (match_dup 1))\n+\t\t\t\t\t (const_int 0)))\n+   (set (match_dup 0) (minus:SI (match_dup 2)\n+\t\t\t\t(geu:SI (reg:CC 0) (const_int 0))))]\n+  \"\")\n+\f\n+;; Peepholes go at the end.\n+\n+;; Optimize the case of following a reg-reg move with a test\n+;; of reg just moved.\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"register_operand\" \"r\"))\n+   (set (reg:CC 0)\n+\t(compare:CC (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t    (const_int 0)))]\n+  \"rtx_equal_p (operands[2], operands[0])\n+   || rtx_equal_p (operands[2], operands[1])\"\n+  \"orcc %1,%%g0,%0\"\n+  [(set_attr \"type\" \"move\")])\n+\n+;; Do {sign,zero}-extended compares somewhat more efficiently.\n+;; ??? Is this now the Right Way to do this?  Or will SCRATCH\n+;;     eventually have some impact here?\n+\n+(define_peephole\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(match_operand:HI 1 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_dup 0)))\n+   (set (reg:CC 0)\n+\t(compare:CC (match_dup 2)\n+\t\t    (const_int 0)))]\n+  \"\"\n+  \"ldsh %1,%0\\;orcc %0,%%g0,%2\")\n+\n+(define_peephole\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(match_operand:QI 1 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_dup 0)))\n+   (set (reg:CC 0)\n+\t(compare:CC (match_dup 2)\n+\t\t    (const_int 0)))]\n+  \"\"\n+  \"ldsb %1,%0\\;orcc %0,%%g0,%2\")\n+\n+(define_peephole\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(match_operand:HI 1 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_dup 0)))]\n+  \"dead_or_set_p (insn, operands[0])\"\n+  \"*\n+{\n+  warning (\\\"bad peephole\\\");\n+  if (! MEM_VOLATILE_P (operands[1]))\n+    abort ();\n+  return \\\"ldsh %1,%2\\\";\n+}\")\n+\n+(define_peephole\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(match_operand:QI 1 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_dup 0)))]\n+  \"dead_or_set_p (insn, operands[0])\"\n+  \"*\n+{\n+  warning (\\\"bad peephole\\\");\n+  if (! MEM_VOLATILE_P (operands[1]))\n+    abort ();\n+  return \\\"ldsb %1,%2\\\";\n+}\")\n+\n+;; Floating-point move peepholes\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_dup 0)\n+\t\t   (match_operand:SI 1 \"immediate_operand\" \"i\")))\n+   (set (match_operand:DF 2 \"register_operand\" \"=fr\")\n+\t(mem:DF (match_dup 0)))]\n+  \"RTX_UNCHANGING_P (operands[1]) && reg_unused_after (operands[0], insn)\"\n+  \"*\n+{\n+  /* Go by way of output_move_double in case the register in operand 2\n+     is not properly aligned for ldd.  */\n+  operands[1] = gen_rtx (MEM, DFmode,\n+\t\t\t gen_rtx (LO_SUM, SImode, operands[0], operands[1]));\n+  operands[0] = operands[2];\n+  return output_move_double (operands);\n+}\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_dup 0)\n+\t\t   (match_operand:SI 1 \"immediate_operand\" \"i\")))\n+   (set (match_operand:SF 2 \"register_operand\" \"=fr\")\n+\t(mem:SF (match_dup 0)))]\n+  \"RTX_UNCHANGING_P (operands[1]) && reg_unused_after (operands[0], insn)\"\n+  \"ld [%0+%%lo(%a1)],%2\")\n+\n+;; Return peepholes.  First the \"normal\" ones\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"restore_operand\" \"\")\n+\t(match_operand:SI 1 \"arith_operand\" \"rI\"))\n+   (return)]\n+  \"! TARGET_EPILOGUE\"\n+  \"*\n+{\n+  if (current_function_returns_struct)\n+    return \\\"jmp %%i7+12\\;restore %%g0,%1,%Y0\\\";\n+  else\n+    return \\\"ret\\;restore %%g0,%1,%Y0\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"restore_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))\n+   (return)]\n+  \"! TARGET_EPILOGUE\"\n+  \"*\n+{\n+  if (current_function_returns_struct)\n+    return \\\"jmp %%i7+12\\;restore %r1,%2,%Y0\\\";\n+  else\n+    return \\\"ret\\;restore %r1,%2,%Y0\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+;; Turned off because it should never match (subtracting a constant\n+;; is turned into addition) and because it would do the wrong thing\n+;; when operand 2 is -4096 (--4096 == 4096 is not a valid immediate).\n+;;(define_insn \"\"\n+;;  [(set (match_operand:SI 0 \"restore_operand\" \"\")\n+;;\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+;;\t\t  (match_operand:SI 2 \"small_int\" \"I\")))\n+;;   (return)]\n+;;  \"! TARGET_EPILOGUE\"\n+;;  \"ret\\;restore %1,-(%2),%Y0\"\n+;;  [(set_attr \"type\" \"multi\")])\n+\n+;; The following pattern is only generated by delayed-branch scheduling,\n+;; when the insn winds up in the epilogue.\n+(define_insn \"\"\n+  [(set (reg:SF 32)\n+\t(match_operand:SF 0 \"register_operand\" \"f\"))\n+   (return)]\n+  \"! TARGET_EPILOGUE\"\n+  \"ret\\;fmovs %0,%%f0\")\n+\n+;; Now peepholes to go a call followed by a jump.\n+\n+(define_peephole\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (mem:SI (match_operand:SI 1 \"call_operand_address\" \"S,r\"))\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (clobber (reg:SI 15))])\n+   (set (pc) (label_ref (match_operand 3 \"\" \"\")))]\n+  \"short_branch (INSN_UID (insn), INSN_UID (operands[3]))\"\n+  \"*\n+{\n+  return \\\"call %a1,%2\\;add %%o7,(%l3-.-4),%%o7\\\";\n+}\")\n+\n+(define_peephole\n+  [(parallel [(call (mem:SI (match_operand:SI 0 \"call_operand_address\" \"S,r\"))\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (clobber (reg:SI 15))])\n+   (set (pc) (label_ref (match_operand 2 \"\" \"\")))]\n+  \"short_branch (INSN_UID (insn), INSN_UID (operands[2]))\"\n+  \"*\n+{\n+  return \\\"call %a0,%1\\;add %%o7,(%l2-.-4),%%o7\\\";\n+}\")\n+\n+(define_peephole\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t\t   (minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t     (reg:SI 0)))\n+\t      (clobber (reg:CC 0))])\n+   (set (reg:CC 0) (compare (match_dup 0) (const_int 0)))]\n+  \"\"\n+  \"subxcc %r1,0,%0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+;;- Local variables:\n+;;- mode:emacs-lisp\n+;;- comment-start: \";;- \"\n+;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\n+;;- eval: (modify-syntax-entry ?[ \"(]\")\n+;;- eval: (modify-syntax-entry ?] \")[\")\n+;;- eval: (modify-syntax-entry ?{ \"(}\")\n+;;- eval: (modify-syntax-entry ?} \"){\")\n+;;- End:"}]}