{"sha": "ae3459cd5956fcd29e8aa5408efb707cb7d9b14f", "node_id": "C_kwDOANBUbNoAKGFlMzQ1OWNkNTk1NmZjZDI5ZThhYTU0MDhlZmI3MDdjYjdkOWIxNGY", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-07-22T22:10:30Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-08-15T13:51:04Z"}, "message": "c++: Extend -Wpessimizing-move for class prvalues [PR106276]\n\nWe already have a warning that warns about pessimizing std::move\nin a return statement, when it prevents the NRVO:\n\n  T fn()\n  {\n    T t;\n    return std::move (t); // warning \\o/\n  }\n\nHowever, the warning doesn't warn when what we are returning is a class\nprvalue, that is, when std::move prevents the RVO:\n\n  T fn()\n  {\n    T t;\n    return std::move (T{}); // no warning :-(\n  }\n\nThis came up recently in GCC:\n<https://gcc.gnu.org/pipermail/gcc-patches/2022-July/598177.html>.\n\nThis patch fixes that.  I would like to extend the warning further, so\nthat it warns in more contexts, e.g.:\n\n  T t = std::move(T());\n\nor\n\n  void foo (T);\n  foo (std::move(T()));\n\n\tPR c++/106276\n\ngcc/cp/ChangeLog:\n\n\t* typeck.cc (can_do_rvo_p): New.\n\t(maybe_warn_pessimizing_move): Warn when moving a temporary object\n\tin a return statement prevents copy elision.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/Wpessimizing-move7.C: New test.", "tree": {"sha": "5167eb50e7881a8d5792969aaa91aedc9e4ec3d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5167eb50e7881a8d5792969aaa91aedc9e4ec3d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae3459cd5956fcd29e8aa5408efb707cb7d9b14f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae3459cd5956fcd29e8aa5408efb707cb7d9b14f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae3459cd5956fcd29e8aa5408efb707cb7d9b14f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae3459cd5956fcd29e8aa5408efb707cb7d9b14f/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e236d671d460dd47262accdea2e9d1d80820ae88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e236d671d460dd47262accdea2e9d1d80820ae88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e236d671d460dd47262accdea2e9d1d80820ae88"}], "stats": {"total": 94, "additions": 91, "deletions": 3}, "files": [{"sha": "15548e5091f785f7e372eac672408e74efb64d98", "filename": "gcc/cp/typeck.cc", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae3459cd5956fcd29e8aa5408efb707cb7d9b14f/gcc%2Fcp%2Ftypeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae3459cd5956fcd29e8aa5408efb707cb7d9b14f/gcc%2Fcp%2Ftypeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.cc?ref=ae3459cd5956fcd29e8aa5408efb707cb7d9b14f", "patch": "@@ -10287,12 +10287,29 @@ can_do_nrvo_p (tree retval, tree functype)\n \t  /* The cv-unqualified type of the returned value must be the\n \t     same as the cv-unqualified return type of the\n \t     function.  */\n-\t  && same_type_p ((TYPE_MAIN_VARIANT (TREE_TYPE (retval))),\n-\t\t\t  (TYPE_MAIN_VARIANT (functype)))\n+\t  && same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (retval)),\n+\t\t\t  TYPE_MAIN_VARIANT (functype))\n \t  /* And the returned value must be non-volatile.  */\n \t  && !TYPE_VOLATILE (TREE_TYPE (retval)));\n }\n \n+/* Like can_do_nrvo_p, but we check if we're trying to move a class\n+   prvalue.  */\n+\n+static bool\n+can_do_rvo_p (tree retval, tree functype)\n+{\n+  if (functype == error_mark_node)\n+    return false;\n+  if (retval)\n+    STRIP_ANY_LOCATION_WRAPPER (retval);\n+  return (retval != NULL_TREE\n+\t  && !glvalue_p (retval)\n+\t  && same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (retval)),\n+\t\t\t  TYPE_MAIN_VARIANT (functype))\n+\t  && !TYPE_VOLATILE (TREE_TYPE (retval)));\n+}\n+\n /* If we should treat RETVAL, an expression being returned, as if it were\n    designated by an rvalue, returns it adjusted accordingly; otherwise, returns\n    NULL_TREE.  See [class.copy.elision].  RETURN_P is true if this is a return\n@@ -10401,12 +10418,20 @@ maybe_warn_pessimizing_move (tree retval, tree functype)\n \t\t\t      \"prevents copy elision\"))\n \t\tinform (loc, \"remove %<std::move%> call\");\n \t    }\n+\t  else if (can_do_rvo_p (arg, functype))\n+\t    {\n+\t      auto_diagnostic_group d;\n+\t      if (warning_at (loc, OPT_Wpessimizing_move,\n+\t\t\t      \"moving a temporary object in a return statement \"\n+\t\t\t      \"prevents copy elision\"))\n+\t\tinform (loc, \"remove %<std::move%> call\");\n+\t    }\n \t  /* Warn if the move is redundant.  It is redundant when we would\n \t     do maybe-rvalue overload resolution even without std::move.  */\n \t  else if (warn_redundant_move\n \t\t   && (moved = treat_lvalue_as_rvalue_p (arg, /*return*/true)))\n \t    {\n-\t      /* Make sure that the overload resolution would actually succeed\n+\t      /* Make sure that overload resolution would actually succeed\n \t\t if we removed the std::move call.  */\n \t      tree t = convert_for_initialization (NULL_TREE, functype,\n \t\t\t\t\t\t   moved,"}, {"sha": "cd4eaa09aae56bfdb38f1d67d69841eb3d158484", "filename": "gcc/testsuite/g++.dg/cpp0x/Wpessimizing-move7.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae3459cd5956fcd29e8aa5408efb707cb7d9b14f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWpessimizing-move7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae3459cd5956fcd29e8aa5408efb707cb7d9b14f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWpessimizing-move7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWpessimizing-move7.C?ref=ae3459cd5956fcd29e8aa5408efb707cb7d9b14f", "patch": "@@ -0,0 +1,63 @@\n+// PR c++/106276\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-Wpessimizing-move\" }\n+\n+// Define std::move.\n+namespace std {\n+  template<typename _Tp>\n+    struct remove_reference\n+    { typedef _Tp   type; };\n+\n+  template<typename _Tp>\n+    struct remove_reference<_Tp&>\n+    { typedef _Tp   type; };\n+\n+  template<typename _Tp>\n+    struct remove_reference<_Tp&&>\n+    { typedef _Tp   type; };\n+\n+  template<typename _Tp>\n+    constexpr typename std::remove_reference<_Tp>::type&&\n+    move(_Tp&& __t) noexcept\n+    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }\n+}\n+\n+struct A { A(); A(const A&) = delete; A(A&&); };\n+struct B { B(A); };\n+\n+static A foo ();\n+\n+A\n+fn1 ()\n+{\n+  return std::move (A{}); // { dg-warning \"moving a temporary object in a return statement prevents copy elision\" }\n+  return std::move (A()); // { dg-warning \"moving a temporary object in a return statement prevents copy elision\" }\n+  return std::move (foo ()); // { dg-warning \"moving a temporary object in a return statement prevents copy elision\" }\n+}\n+\n+B fn2 ()\n+{\n+  return std::move (A());\n+  return std::move (A{});\n+  return std::move (foo ());\n+}\n+\n+template <typename T1, typename T2>\n+T1\n+fn3 ()\n+{\n+  return std::move (T2{}); // { dg-warning \"moving a temporary object in a return statement prevents copy elision\" }\n+}\n+\n+void\n+do_fn3 ()\n+{\n+  fn3<A, A>();\n+  fn3<B, A>();\n+}\n+\n+char take_buffer;\n+struct label_text {\n+  label_text take() { return std::move(label_text(&take_buffer)); } // { dg-warning \"moving a temporary object in a return statement prevents copy elision\" }\n+  label_text(char *);\n+};"}]}