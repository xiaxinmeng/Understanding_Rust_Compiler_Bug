{"sha": "671a283636de75f7ed638ee6b01ed2d44361b8b6", "node_id": "C_kwDOANBUbNoAKDY3MWEyODM2MzZkZTc1ZjdlZDYzOGVlNmIwMWVkMmQ0NDM2MWI4YjY", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2022-01-15T23:37:54Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2022-01-15T23:45:24Z"}, "message": "Add -Wuse-after-free [PR80532].\n\ngcc/c-family/ChangeLog\n\n\tPR tree-optimization/80532\n\t* c.opt (-Wuse-after-free): New options.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/80532\n\t* common.opt (-Wuse-after-free): New options.\n\t* diagnostic-spec.c (nowarn_spec_t::nowarn_spec_t): Handle\n\tOPT_Wreturn_local_addr and OPT_Wuse_after_free_.\n\t* diagnostic-spec.h (NW_DANGLING): New enumerator.\n\t* doc/invoke.texi (-Wuse-after-free): Document new option.\n\t* gimple-ssa-warn-access.cc (pass_waccess::check_call): Rename...\n\t(pass_waccess::check_call_access): ...to this.\n\t(pass_waccess::check): Rename...\n\t(pass_waccess::check_block): ...to this.\n\t(pass_waccess::check_pointer_uses): New function.\n\t(pass_waccess::gimple_call_return_arg): New function.\n\t(pass_waccess::warn_invalid_pointer): New function.\n\t(pass_waccess::check_builtin): Handle free and realloc.\n\t(gimple_use_after_inval_p): New function.\n\t(get_realloc_lhs): New function.\n\t(maybe_warn_mismatched_realloc): New function.\n\t(pointers_related_p): New function.\n\t(pass_waccess::check_call): Call check_pointer_uses.\n\t(pass_waccess::execute): Compute and free dominance info.\n\nlibcpp/ChangeLog:\n\n\t* files.c (_cpp_find_file): Substitute a valid pointer for\n\tan invalid one to avoid -Wuse-after-free.\n\nlibiberty/ChangeLog:\n\n\t* regex.c: Suppress -Wuse-after-free.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/80532\n\t* gcc.dg/Wmismatched-dealloc-2.c: Avoid -Wuse-after-free.\n\t* gcc.dg/Wmismatched-dealloc-3.c: Same.\n\t* gcc.dg/analyzer/file-1.c: Prune expected warning.\n\t* gcc.dg/analyzer/file-2.c: Same.\n\t* gcc.dg/attr-alloc_size-6.c: Disable -Wuse-after-free.\n\t* gcc.dg/attr-alloc_size-7.c: Same.\n\t* c-c++-common/Wuse-after-free-2.c: New test.\n\t* c-c++-common/Wuse-after-free-3.c: New test.\n\t* c-c++-common/Wuse-after-free-4.c: New test.\n\t* c-c++-common/Wuse-after-free-5.c: New test.\n\t* c-c++-common/Wuse-after-free-6.c: New test.\n\t* c-c++-common/Wuse-after-free-7.c: New test.\n\t* c-c++-common/Wuse-after-free.c: New test.\n\t* g++.dg/warn/Wmismatched-dealloc-3.C: New test.\n\t* g++.dg/warn/Wuse-after-free.C: New test.", "tree": {"sha": "fc2477d20340a1f678cb650cd8485127dddb1615", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc2477d20340a1f678cb650cd8485127dddb1615"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/671a283636de75f7ed638ee6b01ed2d44361b8b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/671a283636de75f7ed638ee6b01ed2d44361b8b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/671a283636de75f7ed638ee6b01ed2d44361b8b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/671a283636de75f7ed638ee6b01ed2d44361b8b6/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29401b7b4581e9131e7057e263dcea8b40a6b5ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29401b7b4581e9131e7057e263dcea8b40a6b5ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29401b7b4581e9131e7057e263dcea8b40a6b5ab"}], "stats": {"total": 1657, "additions": 1625, "deletions": 32}, "files": [{"sha": "28363643664653a10a7c3de870e2b5d2a62010ba", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -1366,6 +1366,18 @@ Wunused-const-variable=\n C ObjC C++ ObjC++ Joined RejectNegative UInteger Var(warn_unused_const_variable) Warning LangEnabledBy(C ObjC,Wunused-variable, 1, 0) IntegerRange(0, 2)\n Warn when a const variable is unused.\n \n+# Defining these options here in addition to common.opt is necessary\n+# in order for the default -Wall setting of -Wuse-after-free=2 to take\n+# effect.\n+\n+Wuse-after-free\n+LangEnabledBy(C ObjC C++ LTO ObjC++)\n+; in common.opt\n+\n+Wuse-after-free=\n+LangEnabledBy(C ObjC C++ LTO ObjC++, Wall,2,0)\n+; in common.opt\n+\n Wvariadic-macros\n C ObjC C++ ObjC++ CPP(warn_variadic_macros) CppReason(CPP_W_VARIADIC_MACROS) Var(cpp_warn_variadic_macros) Init(0) Warning LangEnabledBy(C ObjC C++ ObjC++,Wpedantic || Wtraditional)\n Warn about using variadic macros."}, {"sha": "c3f6472be049f467d5cccd03db4301ce04ac9fc7", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -552,6 +552,14 @@ Warray-bounds=\n Common Joined RejectNegative UInteger Var(warn_array_bounds) Warning IntegerRange(0, 2)\n Warn if an array is accessed out of bounds.\n \n+Wuse-after-free\n+Common Var(warn_use_after_free) Warning\n+Warn for uses of pointers to deallocated strorage.\n+\n+Wuse-after-free=\n+Common Joined RejectNegative UInteger Var(warn_use_after_free) Warning IntegerRange(0, 3)\n+Warn for uses of pointers to deallocated strorage.\n+\n Wattributes\n Common Var(warn_attributes) Init(1) Warning\n Warn about inappropriate attribute usage."}, {"sha": "c9e1c1be91d8ac9cfd5c15c9cf4ccdf597edb3b5", "filename": "gcc/diagnostic-spec.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Fdiagnostic-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Fdiagnostic-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-spec.c?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -99,6 +99,11 @@ nowarn_spec_t::nowarn_spec_t (opt_code opt)\n \tm_bits = NW_UNINIT;\n       break;\n \n+    case OPT_Wreturn_local_addr:\n+    case OPT_Wuse_after_free_:\n+      m_bits = NW_DANGLING;\n+      break;\n+\n     default:\n       /* A catchall group for everything else.  */\n       m_bits = NW_OTHER;"}, {"sha": "28e5e5ccc751cc1df340274f7d0e54ba1b6d8164", "filename": "gcc/diagnostic-spec.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Fdiagnostic-spec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Fdiagnostic-spec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-spec.h?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -41,11 +41,13 @@ class nowarn_spec_t\n      NW_UNINIT = 1 << 3,\n      /* Warnings about arithmetic overflow.  */\n      NW_VFLOW = 1 << 4,\n+     /* Warnings about dangling pointers.  */\n+     NW_DANGLING = 1 << 5,\n      /* All other unclassified warnings.  */\n-     NW_OTHER = 1 << 5,\n+     NW_OTHER = 1 << 6,\n      /* All groups of warnings.  */\n      NW_ALL = (NW_ACCESS | NW_LEXICAL | NW_NONNULL\n-\t       | NW_UNINIT | NW_VFLOW | NW_OTHER)\n+\t       | NW_UNINIT | NW_VFLOW | NW_DANGLING | NW_OTHER)\n    };\n \n   nowarn_spec_t (): m_bits () { }"}, {"sha": "121c8ea827f3cf97167535213e2e6d2faa6a284e", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -4383,6 +4383,65 @@ annotations.\n Warn about overriding virtual functions that are not marked with the\n @code{override} keyword.\n \n+@item -Wuse-after-free\n+@itemx -Wuse-after-free=@var{n}\n+@opindex Wuse-after-free\n+@opindex Wno-use-after-free\n+Warn about uses of pointers to dynamically allocated objects that have\n+been rendered indeterminate by a call to a deallocation function.\n+\n+@table @gcctabopt\n+@item -Wuse-after-free=1\n+At level 1 the warning attempts to diagnose only unconditional uses\n+of pointers made indeterminate by a deallocation call or a successful\n+call to @code{realloc}, regardless of whether or not the call resulted\n+in an actual reallocatio of memory.  This includes double-@code{free}\n+calls as well as uses in arithmetic and relational expressions.  Although\n+undefined, uses of indeterminate pointers in equality (or inequality)\n+expressions are not diagnosed at this level.\n+@item -Wuse-after-free=2\n+At level 2, in addition to unconditional uses, the warning also diagnoses\n+conditional uses of pointers made indeterminate by a deallocation call.\n+As at level 2, uses in equality (or inequality) expressions are not\n+diagnosed.  For example, the second call to @code{free} in the following\n+function is diagnosed at this level:\n+@smallexample\n+struct A @{ int refcount; void *data; @};\n+\n+void release (struct A *p)\n+@{\n+  int refcount = --p->refcount;\n+  free (p);\n+  if (refcount == 0)\n+    free (p->data);   // warning: p may be used after free\n+@}\n+@end smallexample\n+@item -Wuse-after-free=3\n+At level 3, the warning also diagnoses uses of indeterminate pointers in\n+equality expressions.  All uses of indeterminate pointers are undefined\n+but equality tests sometimes appear after calls to @code{realloc} as\n+an attempt to determine whether the call resulted in relocating the object\n+to a different address.  They are diagnosed at a separate level to aid\n+legacy code gradually transition to safe alternatives.  For example,\n+the equality test in the function below is diagnosed at this level:\n+@smallexample\n+void adjust_pointers (int**, int);\n+\n+void grow (int **p, int n)\n+@{\n+  int **q = (int**)realloc (p, n *= 2);\n+  if (q == p)\n+    return;\n+  adjust_pointers ((int**)q, n);\n+@}\n+@end smallexample\n+To avoid the warning at this level, store offsets into allocated memory\n+instead of pointers.  This approach obviates needing to adjust the stored\n+pointers after reallocation.\n+@end table\n+\n+@option{-Wuse-after-free=2} is included in @option{-Wall}.\n+\n @item -Wuseless-cast @r{(C++ and Objective-C++ only)}\n @opindex Wuseless-cast\n @opindex Wno-useless-cast\n@@ -5703,6 +5762,7 @@ Options} and @ref{Objective-C and Objective-C++ Dialect Options}.\n -Wunused-label     @gol\n -Wunused-value     @gol\n -Wunused-variable  @gol\n+-Wuse-after-free=3  @gol\n -Wvla-parameter @r{(C and Objective-C only)} @gol\n -Wvolatile-register-var  @gol\n -Wzero-length-bounds}"}, {"sha": "882129143a19b89ec5815d82e68e588e3c9cc2ea", "filename": "gcc/gimple-ssa-warn-access.cc", "status": "modified", "additions": 446, "deletions": 15, "changes": 461, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Fgimple-ssa-warn-access.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Fgimple-ssa-warn-access.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.cc?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -53,6 +53,7 @@\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"demangle.h\"\n+#include \"attr-fnspec.h\"\n #include \"pointer-query.h\"\n \n /* Return true if tree node X has an associated location.  */\n@@ -2071,6 +2072,7 @@ class pass_waccess : public gimple_opt_pass\n   opt_pass *clone () { return new pass_waccess (m_ctxt); }\n \n   virtual bool gate (function *);\n+\n   virtual unsigned int execute (function *);\n \n private:\n@@ -2084,14 +2086,14 @@ class pass_waccess : public gimple_opt_pass\n   /* Check a call to a built-in function.  */\n   bool check_builtin (gcall *);\n \n-  /* Check a call to an ordinary function.  */\n-  bool check_call (gcall *);\n+  /* Check a call to an ordinary function for invalid accesses.  */\n+  bool check_call_access (gcall *);\n \n   /* Check statements in a basic block.  */\n-  void check (basic_block);\n+  void check_block (basic_block);\n \n   /* Check a call to a function.  */\n-  void check (gcall *);\n+  void check_call (gcall *);\n \n   /* Check a call to the named built-in function.  */\n   void check_alloca (gcall *);\n@@ -2109,18 +2111,37 @@ class pass_waccess : public gimple_opt_pass\n   bool maybe_warn_memmodel (gimple *, tree, tree, const unsigned char *);\n   void check_atomic_memmodel (gimple *, tree, tree, const unsigned char *);\n \n+  /* Check for uses of indeterminate pointers.  */\n+  void check_pointer_uses (gimple *, tree);\n+\n+  /* Return the argument that a call returns.  */\n+  tree gimple_call_return_arg (gcall *);\n+\n+  void warn_invalid_pointer (tree, gimple *, gimple *, bool, bool = false);\n+\n+  /* Return true if use follows an invalidating statement.  */\n+  bool use_after_inval_p (gimple *, gimple *);\n+\n   /* A pointer_query object and its cache to store information about\n      pointers and their targets in.  */\n   pointer_query m_ptr_qry;\n   pointer_query::cache_type m_var_cache;\n+\n+  /* A bit is set for each basic block whose statements have been assigned\n+     valid UIDs.  */\n+  bitmap m_bb_uids_set;\n+  /* The current function.  */\n+  function *m_func;\n };\n \n /* Construct the pass.  */\n \n pass_waccess::pass_waccess (gcc::context *ctxt)\n   : gimple_opt_pass (pass_data_waccess, ctxt),\n     m_ptr_qry (NULL, &m_var_cache),\n-    m_var_cache ()\n+    m_var_cache (),\n+    m_bb_uids_set (),\n+    m_func ()\n {\n }\n \n@@ -3071,6 +3092,15 @@ pass_waccess::check_builtin (gcall *stmt)\n       check_read_access (stmt, call_arg (stmt, 0));\n       return true;\n \n+    case BUILT_IN_FREE:\n+    case BUILT_IN_REALLOC:\n+      {\n+\ttree arg = call_arg (stmt, 0);\n+\tif (TREE_CODE (arg) == SSA_NAME)\n+\t  check_pointer_uses (stmt, arg);\n+      }\n+      return true;\n+\n     case BUILT_IN_GETTEXT:\n     case BUILT_IN_PUTS:\n     case BUILT_IN_PUTS_UNLOCKED:\n@@ -3175,6 +3205,7 @@ pass_waccess::check_builtin (gcall *stmt)\n \treturn true;\n       break;\n     }\n+\n   return false;\n }\n \n@@ -3504,7 +3535,7 @@ pass_waccess::maybe_check_access_sizes (rdwr_map *rwm, tree fndecl, tree fntype,\n    accesses.  Return true if a call has been handled.  */\n \n bool\n-pass_waccess::check_call (gcall *stmt)\n+pass_waccess::check_call_access (gcall *stmt)\n {\n   tree fntype = gimple_call_fntype (stmt);\n   if (!fntype)\n@@ -3692,46 +3723,442 @@ pass_waccess::maybe_check_dealloc_call (gcall *call)\n     }\n }\n \n+/* Return true if either USE_STMT's basic block (that of a pointer's use)\n+   is dominated by INVAL_STMT's (that of a pointer's invalidating statement,\n+   or if they're in the same block, USE_STMT follows INVAL_STMT.  */\n+\n+bool\n+pass_waccess::use_after_inval_p (gimple *inval_stmt, gimple *use_stmt)\n+{\n+  basic_block inval_bb = gimple_bb (inval_stmt);\n+  basic_block use_bb = gimple_bb (use_stmt);\n+\n+  if (inval_bb != use_bb)\n+    return dominated_by_p (CDI_DOMINATORS, use_bb, inval_bb);\n+\n+  if (bitmap_set_bit (m_bb_uids_set, inval_bb->index))\n+    /* The first time this basic block is visited assign increasing ids\n+       to consecutive statements in it.  Use the ids to determine which\n+       precedes which.  This avoids the linear traversal on subsequent\n+       visits to the same block.  */\n+    for (auto si = gsi_start_bb (inval_bb); !gsi_end_p (si);\n+\t gsi_next_nondebug (&si))\n+      {\n+\tgimple *stmt = gsi_stmt (si);\n+\tunsigned uid = inc_gimple_stmt_max_uid (m_func);\n+\tgimple_set_uid (stmt, uid);\n+      }\n+\n+  return gimple_uid (inval_stmt) < gimple_uid (use_stmt);\n+}\n+\n+/* Issue a warning for the USE_STMT of pointer PTR rendered invalid\n+   by INVAL_STMT.  PTR may be null when it's been optimized away.\n+   MAYBE is true to issue the \"maybe\" kind of warning.  EQUALITY is\n+   true when the pointer is used in an equality expression.  */\n+\n+void\n+pass_waccess::warn_invalid_pointer (tree ptr, gimple *use_stmt,\n+\t\t\t\t    gimple *inval_stmt,\n+\t\t\t\t    bool maybe,\n+\t\t\t\t    bool equality /* = false */)\n+{\n+  /* Avoid printing the unhelpful \"<unknown>\" in the diagnostics.  */\n+  if (ptr && TREE_CODE (ptr) == SSA_NAME\n+      && (!SSA_NAME_VAR (ptr) || DECL_ARTIFICIAL (SSA_NAME_VAR (ptr))))\n+    ptr = NULL_TREE;\n+\n+  location_t use_loc = gimple_location (use_stmt);\n+  if (use_loc == UNKNOWN_LOCATION)\n+    {\n+      use_loc = cfun->function_end_locus;\n+      if (!ptr)\n+\t/* Avoid issuing a warning with no context other than\n+\t   the function.  That would make it difficult to debug\n+\t   in any but very simple cases.  */\n+\treturn;\n+    }\n+\n+  if (is_gimple_call (inval_stmt))\n+    {\n+      if ((equality && warn_use_after_free < 3)\n+\t  || (maybe && warn_use_after_free < 2)\n+\t  || warning_suppressed_p (use_stmt, OPT_Wuse_after_free))\n+\treturn;\n+\n+      const tree inval_decl = gimple_call_fndecl (inval_stmt);\n+\n+      if ((ptr && warning_at (use_loc, OPT_Wuse_after_free,\n+\t\t\t      (maybe\n+\t\t\t       ? G_(\"pointer %qE may be used after %qD\")\n+\t\t\t       : G_(\"pointer %qE used after %qD\")),\n+\t\t\t      ptr, inval_decl))\n+\t  || (!ptr && warning_at (use_loc, OPT_Wuse_after_free,\n+\t\t\t      (maybe\n+\t\t\t       ? G_(\"pointer may be used after %qD\")\n+\t\t\t       : G_(\"pointer used after %qD\")),\n+\t\t\t\t  inval_decl)))\n+\t{\n+\t  location_t loc = gimple_location (inval_stmt);\n+\t  inform (loc, \"call to %qD here\", inval_decl);\n+\t  suppress_warning (use_stmt, OPT_Wuse_after_free);\n+\t}\n+      return;\n+    }\n+}\n+\n+/* If STMT is a call to either the standard realloc or to a user-defined\n+   reallocation function returns its LHS and set *PTR to the reallocated\n+   pointer.  Otherwise return null.  */\n+\n+static tree\n+get_realloc_lhs (gimple *stmt, tree *ptr)\n+{\n+  if (gimple_call_builtin_p (stmt, BUILT_IN_REALLOC))\n+    {\n+      *ptr = gimple_call_arg (stmt, 0);\n+      return gimple_call_lhs (stmt);\n+    }\n+\n+  gcall *call = dyn_cast<gcall *>(stmt);\n+  if (!call)\n+    return NULL_TREE;\n+\n+  tree fnattr = NULL_TREE;\n+  tree fndecl = gimple_call_fndecl (call);\n+  if (fndecl)\n+    fnattr = DECL_ATTRIBUTES (fndecl);\n+  else\n+    {\n+      tree fntype = gimple_call_fntype (stmt);\n+      if (!fntype)\n+\treturn NULL_TREE;\n+      fnattr = TYPE_ATTRIBUTES (fntype);\n+    }\n+\n+  if (!fnattr)\n+    return NULL_TREE;\n+\n+  for (tree ats = fnattr;  (ats = lookup_attribute (\"*dealloc\", ats));\n+       ats = TREE_CHAIN (ats))\n+    {\n+      tree args = TREE_VALUE (ats);\n+      if (!args)\n+\tcontinue;\n+\n+      tree alloc = TREE_VALUE (args);\n+      if (!alloc)\n+\tcontinue;\n+\n+      if (alloc == DECL_NAME (fndecl))\n+\t{\n+\t  unsigned argno = 0;\n+\t  if (tree index = TREE_CHAIN (args))\n+\t    argno = TREE_INT_CST_LOW (TREE_VALUE (index)) - 1;\n+\t  *ptr = gimple_call_arg (stmt, argno);\n+\t  return gimple_call_lhs (stmt);\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Warn if STMT is a call to a deallocation function that's not a match\n+   for the REALLOC_STMT call.  Return true if warned.  */\n+\n+static bool\n+maybe_warn_mismatched_realloc (tree ptr, gimple *realloc_stmt, gimple *stmt)\n+{\n+  if (!is_gimple_call (stmt))\n+    return false;\n+\n+  tree fndecl = gimple_call_fndecl (stmt);\n+  if (!fndecl)\n+    return false;\n+\n+  unsigned argno = fndecl_dealloc_argno (fndecl);\n+  if (call_nargs (stmt) <= argno)\n+    return false;\n+\n+  if (matching_alloc_calls_p (realloc_stmt, fndecl))\n+    return false;\n+\n+  /* Avoid printing the unhelpful \"<unknown>\" in the diagnostics.  */\n+  if (ptr && TREE_CODE (ptr) == SSA_NAME\n+      && (!SSA_NAME_VAR (ptr) || DECL_ARTIFICIAL (SSA_NAME_VAR (ptr))))\n+    ptr = NULL_TREE;\n+\n+  location_t loc = gimple_location (stmt);\n+  tree realloc_decl = gimple_call_fndecl (realloc_stmt);\n+  tree dealloc_decl = gimple_call_fndecl (stmt);\n+  if (ptr && !warning_at (loc, OPT_Wmismatched_dealloc,\n+\t\t\t  \"%qD called on pointer %qE passed to mismatched \"\n+\t\t\t  \"allocation function %qD\",\n+\t\t\t  dealloc_decl, ptr, realloc_decl))\n+    return false;\n+  if (!ptr && !warning_at (loc, OPT_Wmismatched_dealloc,\n+\t\t\t   \"%qD called on a pointer passed to mismatched \"\n+\t\t\t   \"reallocation function %qD\",\n+\t\t\t   dealloc_decl, realloc_decl))\n+    return false;\n+\n+  inform (gimple_location (realloc_stmt),\n+\t  \"call to %qD\", realloc_decl);\n+  return true;\n+}\n+\n+/* Return true if P and Q point to the same object, and false if they\n+   either don't or their relationship cannot be determined.  */\n+\n+static bool\n+pointers_related_p (gimple *stmt, tree p, tree q, pointer_query &qry)\n+{\n+  if (!ptr_derefs_may_alias_p (p, q))\n+    return false;\n+\n+  /* TODO: Work harder to rule out relatedness.  */\n+  access_ref pref, qref;\n+  if (!qry.get_ref (p, stmt, &pref, 0)\n+      || !qry.get_ref (q, stmt, &qref, 0))\n+    return true;\n+\n+  return pref.ref == qref.ref;\n+}\n+\n+/* For a STMT either a call to a deallocation function or a clobber, warn\n+   for uses of the pointer PTR it was called with (including its copies\n+   or others derived from it by pointer arithmetic).  */\n+\n+void\n+pass_waccess::check_pointer_uses (gimple *stmt, tree ptr)\n+{\n+  gcc_assert (TREE_CODE (ptr) == SSA_NAME);\n+\n+  const bool check_dangling = !is_gimple_call (stmt);\n+  basic_block stmt_bb = gimple_bb (stmt);\n+\n+  /* If STMT is a reallocation function set to the reallocated pointer\n+     and the LHS of the call, respectively.  */\n+  tree realloc_ptr = NULL_TREE;\n+  tree realloc_lhs = get_realloc_lhs (stmt, &realloc_ptr);\n+\n+  auto_bitmap visited;\n+\n+  auto_vec<tree> pointers;\n+  pointers.safe_push (ptr);\n+\n+  /* Starting with PTR, iterate over POINTERS added by the loop, and\n+     either warn for their uses in basic blocks dominated by the STMT\n+     or in statements that follow it in the same basic block, or add\n+     them to POINTERS if they point into the same object as PTR (i.e.,\n+     are obtained by pointer arithmetic on PTR).  */\n+  for (unsigned i = 0; i != pointers.length (); ++i)\n+    {\n+      tree ptr = pointers[i];\n+      if (TREE_CODE (ptr) == SSA_NAME\n+\t  && !bitmap_set_bit (visited, SSA_NAME_VERSION (ptr)))\n+\t/* Avoid revisiting the same pointer.  */\n+\tcontinue;\n+\n+      use_operand_p use_p;\n+      imm_use_iterator iter;\n+      FOR_EACH_IMM_USE_FAST (use_p, iter, ptr)\n+\t{\n+\t  gimple *use_stmt = USE_STMT (use_p);\n+\t  if (use_stmt == stmt || is_gimple_debug (use_stmt))\n+\t    continue;\n+\n+\t  if (realloc_lhs)\n+\t    {\n+\t      /* Check to see if USE_STMT is a mismatched deallocation\n+\t\t call for the pointer passed to realloc.  That's a bug\n+\t\t regardless of the pointer's value and so warn.  */\n+\t      if (maybe_warn_mismatched_realloc (*use_p->use, stmt, use_stmt))\n+\t\tcontinue;\n+\n+\t      /* Pointers passed to realloc that are used in basic blocks\n+\t\t where the realloc call is known to have failed are valid.\n+\t\t Ignore pointers that nothing is known about.  Those could\n+\t\t have escaped along with their nullness.  */\n+\t      value_range vr;\n+\t      if (m_ptr_qry.rvals->range_of_expr (vr, realloc_lhs, use_stmt))\n+\t\t{\n+\t\t  if (vr.zero_p ())\n+\t\t    continue;\n+\n+\t\t  if (!pointers_related_p (stmt, ptr, realloc_ptr, m_ptr_qry))\n+\t\t    continue;\n+\t\t}\n+\t    }\n+\n+\t  if (check_dangling\n+\t      && gimple_code (use_stmt) == GIMPLE_RETURN)\n+\t    /* Avoid interfering with -Wreturn-local-addr (which runs only\n+\t       with optimization enabled so it won't diagnose cases that\n+\t       would be caught here when optimization is disabled).  */\n+\t    continue;\n+\n+\t  bool equality = false;\n+\t  if (is_gimple_assign (use_stmt))\n+\t    {\n+\t      tree_code code = gimple_assign_rhs_code (use_stmt);\n+\t      equality = code == EQ_EXPR || code == NE_EXPR;\n+\t    }\n+\t  else if (gcond *cond = dyn_cast<gcond *>(use_stmt))\n+\t    {\n+\t      tree_code code = gimple_cond_code (cond);\n+\t      equality = code == EQ_EXPR || code == NE_EXPR;\n+\t    }\n+\n+\t  /* Warn if USE_STMT is dominated by the deallocation STMT.\n+\t     Otherwise, add the pointer to POINTERS so that the uses\n+\t     of any other pointers derived from it can be checked.  */\n+\t  if (use_after_inval_p (stmt, use_stmt))\n+\t    {\n+\t      /* TODO: Handle PHIs but careful of false positives.  */\n+\t      if (gimple_code (use_stmt) != GIMPLE_PHI)\n+\t\t{\n+\t\t  basic_block use_bb = gimple_bb (use_stmt);\n+\t\t  bool this_maybe\n+\t\t    = !dominated_by_p (CDI_POST_DOMINATORS, use_bb, stmt_bb);\n+\t\t  warn_invalid_pointer (*use_p->use, use_stmt, stmt,\n+\t\t\t\t\tthis_maybe, equality);\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\n+\t  if (is_gimple_assign (use_stmt))\n+\t    {\n+\t      tree lhs = gimple_assign_lhs (use_stmt);\n+\t      if (TREE_CODE (lhs) == SSA_NAME)\n+\t\t{\n+\t\t  tree_code rhs_code = gimple_assign_rhs_code (use_stmt);\n+\t\t  if (rhs_code == POINTER_PLUS_EXPR || rhs_code == SSA_NAME)\n+\t\t    pointers.safe_push (lhs);\n+\t\t}\n+\t      continue;\n+\t    }\n+\n+\t  if (gcall *call = dyn_cast <gcall *>(use_stmt))\n+\t    {\n+\t      if (gimple_call_return_arg (call))\n+\t\tif (tree lhs = gimple_call_lhs (call))\n+\t\t  if (TREE_CODE (lhs) == SSA_NAME)\n+\t\t    pointers.safe_push (lhs);\n+\t      continue;\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Check call STMT for invalid accesses.  */\n \n void\n-pass_waccess::check (gcall *stmt)\n+pass_waccess::check_call (gcall *stmt)\n {\n   if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n     check_builtin (stmt);\n \n-  if (is_gimple_call (stmt))\n-    check_call (stmt);\n+  if (tree callee = gimple_call_fndecl (stmt))\n+    {\n+      /* Check for uses of the pointer passed to either a standard\n+\t or a user-defined deallocation function.  */\n+      unsigned argno = fndecl_dealloc_argno (callee);\n+      if (argno < (unsigned) call_nargs (stmt))\n+\t{\n+\t  tree arg = call_arg (stmt, argno);\n+\t  if (TREE_CODE (arg) == SSA_NAME)\n+\t    check_pointer_uses (stmt, arg);\n+\t}\n+    }\n \n-  maybe_check_dealloc_call (stmt);\n+  check_call_access (stmt);\n \n+  maybe_check_dealloc_call (stmt);\n   check_nonstring_args (stmt);\n }\n \n+\n /* Check basic block BB for invalid accesses.  */\n \n void\n-pass_waccess::check (basic_block bb)\n+pass_waccess::check_block (basic_block bb)\n {\n   /* Iterate over statements, looking for function calls.  */\n-  for (auto si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+  for (auto si = gsi_start_bb (bb); !gsi_end_p (si);\n+       gsi_next_nondebug (&si))\n     {\n-      if (gcall *call = dyn_cast <gcall *> (gsi_stmt (si)))\n-\tcheck (call);\n+      gimple *stmt = gsi_stmt (si);\n+      if (gcall *call = dyn_cast <gcall *> (stmt))\n+\tcheck_call (call);\n     }\n }\n \n+/* Return the argument that the call STMT to a built-in function returns\n+   (including with an offset) or null if it doesn't.  */\n+\n+tree\n+pass_waccess::gimple_call_return_arg (gcall *call)\n+{\n+  /* Check for attribute fn spec to see if the function returns one\n+     of its arguments.  */\n+  attr_fnspec fnspec = gimple_call_fnspec (call);\n+  unsigned int argno;\n+  if (!fnspec.returns_arg (&argno))\n+    {\n+      if (gimple_call_num_args (call) < 1)\n+\treturn NULL_TREE;\n+\n+      if (!gimple_call_builtin_p (call, BUILT_IN_NORMAL))\n+\treturn NULL_TREE;\n+\n+      tree fndecl = gimple_call_fndecl (call);\n+      switch (DECL_FUNCTION_CODE (fndecl))\n+\t{\n+\tcase BUILT_IN_MEMPCPY:\n+\tcase BUILT_IN_MEMPCPY_CHK:\n+\tcase BUILT_IN_MEMCHR:\n+\tcase BUILT_IN_STRCHR:\n+\tcase BUILT_IN_STRRCHR:\n+\tcase BUILT_IN_STRSTR:\n+\tcase BUILT_IN_STPCPY:\n+\tcase BUILT_IN_STPCPY_CHK:\n+\tcase BUILT_IN_STPNCPY:\n+\tcase BUILT_IN_STPNCPY_CHK:\n+\t  argno = 0;\n+\t  break;\n+\n+\tdefault:\n+\t  return NULL_TREE;\n+\t}\n+    }\n+\n+  if (gimple_call_num_args (call) <= argno)\n+    return NULL_TREE;\n+\n+  return gimple_call_arg (call, argno);\n+}\n+\n /* Check function FUN for invalid accesses.  */\n \n unsigned\n pass_waccess::execute (function *fun)\n {\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+\n   /* Create a new ranger instance and associate it with FUN.  */\n   m_ptr_qry.rvals = enable_ranger (fun);\n+  m_func = fun;\n+\n+  auto_bitmap bb_uids_set (&bitmap_default_obstack);\n+  m_bb_uids_set = bb_uids_set;\n+\n+  set_gimple_stmt_max_uid (m_func, 0);\n \n   basic_block bb;\n   FOR_EACH_BB_FN (bb, fun)\n-    check (bb);\n+    check_block (bb);\n \n   if (dump_file)\n     m_ptr_qry.dump (dump_file, (dump_flags & TDF_DETAILS) != 0);\n@@ -3743,6 +4170,10 @@ pass_waccess::execute (function *fun)\n   disable_ranger (fun);\n   m_ptr_qry.rvals = NULL;\n \n+  m_bb_uids_set = NULL;\n+\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+  free_dominance_info (CDI_DOMINATORS);\n   return 0;\n }\n "}, {"sha": "e309bdf041a029e2f2a98fc66aa82a3704db1465", "filename": "gcc/testsuite/c-c++-common/Wuse-after-free-2.c", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free-2.c?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -0,0 +1,169 @@\n+/* Verify that accessing freed objects by built-in functions is diagnosed.\n+   { dg-do compile }\n+   { dg-options \"-Wall\" }  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#if __cplusplus\n+#  define EXTERN_C extern \"C\"\n+#else\n+#  define EXTERN_C extern\n+#endif\n+\n+EXTERN_C void free (void*);\n+EXTERN_C void* realloc (void*, size_t);\n+\n+EXTERN_C void* memcpy (void*, const void*, size_t);\n+EXTERN_C char* strcpy (char*, const char*);\n+EXTERN_C size_t strlen (const char*);\n+\n+\n+void sink (void*, ...);\n+\n+struct Member { char *p; char a[4]; };\n+\n+int nowarn_strcpy_memptr (struct Member *p)\n+{\n+  char *q = strcpy (p->p, p->a);\n+  free (p);\n+  return *q;\n+}\n+\n+int nowarn_strlen_memptr (struct Member *p)\n+{\n+  const char *q = p->p;\n+\n+  free (p);\n+\n+  return strlen (q);\n+}\n+\n+int warn_strlen_memptr (struct Member *p)\n+{\n+  free (p);                   // { dg-message \"call to '\\(void \\)?free\\(\\\\(void\\\\*\\\\)\\)?'\" \"note\" }\n+  return strlen (p->p);       // { dg-warning \"-Wuse-after-free\" }\n+}\n+\n+int warn_strlen_memarray (struct Member *p)\n+{\n+  {\n+    free (p);\n+    return strlen (p->a);     // { dg-warning \"-Wuse-after-free\" }\n+  }\n+\n+  {\n+    char *q = p->a;\n+\n+    free (p);\n+    return strlen (q);        // { dg-warning \"-Wuse-after-free\" \"pr??????\" { xfail *-*-* } }\n+  }\n+}\n+\n+void* nowarn_realloc_success (void *p)\n+{\n+  void *q = realloc (p, 7);\n+  if (!q)\n+    /* When realloc fails the original pointer remains valid.  */\n+    return p;\n+\n+  return q;\n+}\n+\n+void* nowarn_realloc_equal (void *p, int *moved)\n+{\n+  void *q = realloc (p, 7);\n+  /* Verify that equality is not diagnosed at the default level\n+     (it is diagnosed at level 3).  */\n+  *moved = !(p == q);\n+  return q;\n+}\n+\n+void* nowarn_realloc_unequal (void *p, int *moved)\n+{\n+  void *q = realloc (p, 7);\n+  /* Verify that inequality is not diagnosed at the default level\n+     (it is diagnosed at level 3).  */\n+  *moved = p != q;\n+  return q;\n+}\n+\n+void* warn_realloc_relational (void *p, int *rel)\n+{\n+  void *q = realloc (p, 7);       // { dg-message \"call to '\\(void\\\\* \\)?realloc\\(\\\\(void\\\\*, size_t\\\\)\\)?'\" \"note\" }\n+  /* Verify that all relational expressions are diagnosed at the default\n+     level.  */\n+  rel[0] = (char*)p < (char*)q;  // { dg-warning \"-Wuse-after-free\" }\n+  rel[1] = (char*)p <= (char*)q; // { dg-warning \"-Wuse-after-free\" }\n+  rel[2] = (char*)p >= (char*)q; // { dg-warning \"-Wuse-after-free\" }\n+  rel[3] = (char*)p > (char*)q;  // { dg-warning \"-Wuse-after-free\" }\n+  return q;\n+}\n+\n+void* warn_realloc_unchecked (void *p, int *moved)\n+{\n+  void *q = realloc (p, 7);       // { dg-message \"call to '\\(void\\\\* \\)?realloc\\(\\\\(void\\\\*, size_t\\\\)\\)?'\" \"note\" }\n+  /* Use subtraction rather than inequality to trigger the warning\n+     at the default level (equality is diagnosed only at level 3).  */\n+  *moved = (char*)p - (char*)q;   // { dg-warning \"-Wuse-after-free\" }\n+  return q;\n+}\n+\n+void* nowarn_realloc_unchecked_copy (void *p1, void *p2, const void *s,\n+\t\t\t\t     int n, int *x)\n+{\n+  void *p3 = memcpy (p1, s, n);\n+  void *p4 = realloc (p2, 7);\n+  *x = p3 != p4;\n+  return p4;\n+}\n+\n+void* warn_realloc_unchecked_copy (void *p, const void *s, int n, int *moved)\n+{\n+  void *p2 = memcpy (p, s, n);\n+  void *q = realloc (p, 7);       // { dg-message \"call to '\\(void\\\\* \\)?realloc\\(\\\\(void\\\\*, size_t\\\\)\\)?'\" \"note\" }\n+  *moved = (char*)p2 - (char*)q;  // { dg-warning \"-Wuse-after-free\" }\n+  return q;\n+}\n+\n+void* warn_realloc_failed (void *p, int *moved)\n+{\n+  void *q = realloc (p, 7);           // { dg-message \"call to '\\(void\\\\* \\)?realloc\\(\\\\(void\\\\*, size_t\\\\)\\)?'\" \"note\" }\n+  if (q)\n+    {\n+      /* When realloc succeeds the original pointer is invalid.  */\n+      *moved = (char*)p - (char*)q;   // { dg-warning \"-Wuse-after-free\" }\n+      return q;\n+    }\n+\n+  return p;\n+}\n+\n+extern void *evp;\n+\n+void* warn_realloc_extern (void *p, int *moved)\n+{\n+  evp = realloc (p, 7);\n+  if (evp)\n+    {\n+      /* When realloc succeeds the original pointer is invalid.  */\n+      *moved = (char*)p - (char*)evp;   // { dg-warning \"-Wuse-after-free\" \"escaped\" }\n+      return evp;\n+    }\n+\n+  return p;                   // { dg-bogus \"-Wuse-after-free\" \"safe use after realloc failure\" { xfail *-*-* } }\n+}\n+\n+struct A { void *p, *q; int moved; };\n+\n+void* warn_realloc_arg (struct A *p)\n+{\n+  p->q = realloc (p->p, 7);\n+  if (p->q)\n+    {\n+      /* When realloc succeeds the original pointer is invalid.  */\n+      p->moved = p->p != p->q;  // { dg-warning \"-Wuse-after-free\" \"escaped\" { xfail *-*-* } }\n+      return p->q;\n+    }\n+\n+  return p->p;\n+}"}, {"sha": "0a2db1a16c87517c0112eec59f5b0429c633ca1f", "filename": "gcc/testsuite/c-c++-common/Wuse-after-free-3.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free-3.c?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -0,0 +1,83 @@\n+/* Exercise -Wuse-after-free with user-defined deallocators.\n+   { dg-do compile }\n+   { dg-options \"-O0 -Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#if __cplusplus\n+#  define EXTERN_C extern \"C\"\n+#else\n+#  define EXTERN_C extern\n+#endif\n+\n+#define A(...) __attribute__ ((malloc (__VA_ARGS__)))\n+\n+EXTERN_C void free (void *);\n+EXTERN_C void* realloc (void *, size_t);\n+\n+typedef struct List { struct List *next; } List;\n+\n+// User-defined allocator/deallocator just like like realloc and free.\n+extern                     void  list_free (List *);\n+extern                     List* list_realloc (size_t, List *);\n+extern A (list_realloc, 2) List* list_realloc (size_t, List *);\n+extern A (list_free, 1)    List* list_realloc (size_t, List *);\n+\n+\n+void sink (void *);\n+\n+extern int ei;\n+extern List *elp, *elpa[];\n+\n+void nowarn_list_free (struct List *lp)\n+{\n+  {\n+    list_free (lp);\n+    lp = 0;\n+    sink (lp);\n+  }\n+  {\n+    list_free (elp);\n+    elp = 0;\n+    sink (elp);\n+  }\n+  {\n+    list_free (elpa[0]);\n+    elpa[0] = 0;\n+    sink (elpa[0]);\n+  }\n+  {\n+    void *vp = elpa[0];\n+    list_free (elpa[0]);\n+    sink (vp);\n+  }\n+  {\n+    List *p = elpa[1];\n+    if (ei & 1)\n+      list_free (p);\n+    if (ei & 2)\n+      sink (p);\n+  }\n+  {\n+    struct List *next = lp->next;\n+    list_free (lp);\n+    list_free (next);\n+  }\n+}\n+\n+\n+void nowarn_list_free_list (List *head)\n+{\n+  for (List *p = head, *q; p; p = q)\n+    {\n+      q = p->next;\n+      list_free (p);\n+    }\n+}\n+\n+void warn_list_free_list (List *head)\n+{\n+  List *p = head;\n+  for (; p; p = p->next)      // { dg-warning \"\\\\\\[-Wuse-after-free\" }\n+    list_free (p);            // { dg-message \"call to '\\(void \\)?list_free\\(\\\\(List\\\\*\\\\)\\)?'\" \"note\" }\n+}"}, {"sha": "686ba7e256ce9e3effcd64d6943e0c37ed2edd84", "filename": "gcc/testsuite/c-c++-common/Wuse-after-free-4.c", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free-4.c?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -0,0 +1,102 @@\n+/* Verify -Wuse-after-free=1 triggers only for unconditional uses and\n+   not for equality expressions.\n+   { dg-do compile }\n+   { dg-options \"-O0 -Wall -Wuse-after-free=1\" } */\n+\n+#if __cplusplus\n+#  define EXTERN_C extern \"C\"\n+#else\n+#  define EXTERN_C extern\n+#endif\n+\n+EXTERN_C void free (void*);\n+\n+void sink (void*);\n+\n+\n+void warn_double_free (void *p)\n+{\n+  free (p);\n+  free (p);         // { dg-warning \"pointer 'p' used\" }\n+}\n+\n+void nowarn_cond_double_free (void *p, int c)\n+{\n+  free (p);\n+  if (c)\n+    free (p);\n+}\n+\n+void warn_call_after_free (void *p)\n+{\n+  free (p);\n+  sink (p);         // { dg-warning \"pointer 'p' used\" }\n+}\n+\n+void nowarn_cond_call_after_free (void *p, int c)\n+{\n+  free (p);\n+  if (c)\n+    sink (p);\n+}\n+\n+void* warn_return_after_free (void *p)\n+{\n+  free (p);\n+  return p;         // { dg-warning \"pointer 'p' used\" }\n+}\n+\n+void* nowarn_cond_return_after_free (void *p, int c)\n+{\n+  free (p);\n+  if (c)\n+    return p;\n+  return 0;\n+}\n+\n+void warn_relational_after_free (char *p, char *q[])\n+{\n+  free (p);\n+\n+  int a[] =\n+    {\n+     p < q[0],      // { dg-warning \"pointer 'p' used\" }\n+     p <= q[1],     // { dg-warning \"pointer 'p' used\" }\n+     p > q[2],      // { dg-warning \"pointer 'p' used\" }\n+     p >= q[3],     // { dg-warning \"pointer 'p' used\" }\n+     p == q[4],\n+     p != q[5]\n+    };\n+\n+  sink (a);\n+}\n+\n+void nowarn_cond_relational_after_free (char *p, char *q[], int c)\n+{\n+  free (p);\n+\n+  int a[] =\n+    {\n+     c ? p < q[0] : q[0][0],\n+     c ? p <= q[1] : q[1][1],\n+     c ? p > q[2] : q[2][2],\n+     c ? p >= q[3] : q[3][3],\n+     c ? p == q[4] : q[4][4],\n+     c ? p != q[5] : q[5][5],\n+    };\n+\n+  sink (a);\n+}\n+\n+\n+// Verify no warning for the example in the manual.\n+\n+struct A { int refcount; void *data; };\n+\n+void release (struct A *p)\n+{\n+  int refcount = --p->refcount;\n+  free (p);\n+  if (refcount == 0)\n+    free (p->data);   // no warning at level 1\n+}"}, {"sha": "c6ff1f3fad2c27eba6479f6a70b2565a45bec687", "filename": "gcc/testsuite/c-c++-common/Wuse-after-free-5.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free-5.c?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -0,0 +1,103 @@\n+/* Verify -Wuse-after-free=2 triggers for conditional as well as\n+   unconditional uses but not for equality expressions.\n+   { dg-do compile }\n+   { dg-options \"-O0 -Wall -Wuse-after-free=2\" } */\n+\n+\n+#if __cplusplus\n+#  define EXTERN_C extern \"C\"\n+#else\n+#  define EXTERN_C extern\n+#endif\n+\n+EXTERN_C void free (void*);\n+\n+void sink (void*);\n+\n+\n+void warn_double_free (void *p)\n+{\n+  free (p);\n+  free (p);         // { dg-warning \"pointer 'p' used\" }\n+}\n+\n+void warn_cond_double_free (void *p, int c)\n+{\n+  free (p);\n+  if (c)\n+    free (p);       // { dg-warning \"pointer 'p' may be used\" }\n+}\n+\n+void warn_call_after_free (void *p)\n+{\n+  free (p);\n+  sink (p);         // { dg-warning \"pointer 'p' used\" }\n+}\n+\n+void warn_cond_call_after_free (void *p, int c)\n+{\n+  free (p);\n+  if (c)\n+    sink (p);       // { dg-warning \"pointer 'p' may be used\" }\n+}\n+\n+void* warn_return_after_free (void *p)\n+{\n+  free (p);\n+  return p;         // { dg-warning \"pointer 'p' used\" }\n+}\n+\n+void* warn_cond_return_after_free (void *p, int c)\n+{\n+  free (p);\n+  if (c)\n+    return p;       // { dg-warning \"pointer 'p' may be used\" }\n+  return 0;\n+}\n+\n+void warn_relational_after_free (char *p, char *q[])\n+{\n+  free (p);\n+\n+  int a[] =\n+    {\n+     p < q[0],      // { dg-warning \"pointer 'p' used\" }\n+     p <= q[1],     // { dg-warning \"pointer 'p' used\" }\n+     p > q[2],      // { dg-warning \"pointer 'p' used\" }\n+     p >= q[3],     // { dg-warning \"pointer 'p' used\" }\n+     p == q[4],\n+     p != q[5]\n+    };\n+\n+  sink (a);\n+}\n+\n+void warn_cond_relational_after_free (char *p, char *q[], int c)\n+{\n+  free (p);\n+\n+  int a[] =\n+    {\n+     c ? p < q[0] : q[0][0],  // { dg-warning \"pointer 'p' may be used\" }\n+     c ? p <= q[1] : q[1][1], // { dg-warning \"pointer 'p' may be used\" }\n+     c ? p > q[2] : q[2][2],  // { dg-warning \"pointer 'p' may be used\" }\n+     c ? p >= q[3] : q[3][3], // { dg-warning \"pointer 'p' may be used\" }\n+     c ? p == q[4] : q[4][4],\n+     c ? p != q[5] : q[5][5],\n+    };\n+\n+  sink (a);\n+}\n+\n+\n+// Verify warning for the example in the manual.\n+\n+struct A { int refcount; void *data; };\n+\n+void release (struct A *p)\n+{\n+  int refcount = --p->refcount;\n+  free (p);\n+  if (refcount == 0)\n+    free (p->data); // { dg-warning \"pointer 'p' may be used\" }\n+}"}, {"sha": "581b1a0a024df5947010b46936d37e46c9d48c07", "filename": "gcc/testsuite/c-c++-common/Wuse-after-free-6.c", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free-6.c?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -0,0 +1,105 @@\n+/* Verify -Wuse-after-free=2 triggers for conditional as well as\n+   unconditional uses but not for equality expressions.  Same as\n+   -Wuse-after-free-5.c but with optimization.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wuse-after-free=2\" } */\n+\n+\n+#if __cplusplus\n+#  define EXTERN_C extern \"C\"\n+#else\n+#  define EXTERN_C extern\n+#endif\n+\n+EXTERN_C void free (void*);\n+\n+void sink (void*);\n+\n+\n+void warn_double_free (void *p)\n+{\n+  free (p);\n+  free (p);         // { dg-warning \"pointer 'p' used\" }\n+}\n+\n+void warn_cond_double_free (void *p, int c)\n+{\n+  free (p);\n+  if (c)\n+    free (p);       // { dg-warning \"pointer 'p' may be used\" }\n+}\n+\n+void warn_call_after_free (void *p)\n+{\n+  free (p);\n+  sink (p);         // { dg-warning \"pointer 'p' used\" }\n+}\n+\n+void warn_cond_call_after_free (void *p, int c)\n+{\n+  free (p);\n+  if (c)\n+    sink (p);       // { dg-warning \"pointer 'p' may be used\" }\n+}\n+\n+void* warn_return_after_free (void *p)\n+{\n+  free (p);\n+  return p;         // { dg-warning \"pointer 'p' used\" }\n+}\n+\n+void* warn_cond_return_after_free (void *p, int c)\n+{\n+  free (p);\n+  // PHI handling not fully implemented.\n+  if (c)\n+    return p;       // { dg-warning \"pointer 'p' may be used\" \"pr??????\" { xfail *-*-* } }\n+  return 0;\n+}\n+\n+void warn_relational_after_free (char *p, char *q[])\n+{\n+  free (p);\n+\n+  int a[] =\n+    {\n+     p < q[0],      // { dg-warning \"pointer 'p' used\" }\n+     p <= q[1],     // { dg-warning \"pointer 'p' used\" }\n+     p > q[2],      // { dg-warning \"pointer 'p' used\" }\n+     p >= q[3],     // { dg-warning \"pointer 'p' used\" }\n+     p == q[4],\n+     p != q[5]\n+    };\n+\n+  sink (a);\n+}\n+\n+void warn_cond_relational_after_free (char *p, char *q[], int c)\n+{\n+  free (p);\n+\n+  int a[] =\n+    {\n+     c ? p < q[0] : q[0][0],  // { dg-warning \"pointer 'p' may be used\" }\n+     c ? p <= q[1] : q[1][1], // { dg-warning \"pointer 'p' may be used\" }\n+     c ? p > q[2] : q[2][2],  // { dg-warning \"pointer 'p' may be used\" }\n+     c ? p >= q[3] : q[3][3], // { dg-warning \"pointer 'p' may be used\" }\n+     c ? p == q[4] : q[4][4],\n+     c ? p != q[5] : q[5][5],\n+    };\n+\n+  sink (a);\n+}\n+\n+\n+// Verify warning for the example in the manual.\n+\n+struct A { int refcount; void *data; };\n+\n+void release (struct A *p)\n+{\n+  int refcount = --p->refcount;\n+  free (p);\n+  if (refcount == 0)\n+    free (p->data); // { dg-warning \"pointer 'p' may be used\" }\n+}"}, {"sha": "12bb6f24ea5be817eb77a65dd5ea8a36291d55d1", "filename": "gcc/testsuite/c-c++-common/Wuse-after-free-7.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free-7.c?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -0,0 +1,103 @@\n+/* Verify -Wuse-after-free=3 triggers for conditional and unconditional\n+   uses in all expressions including equality.\n+   { dg-do compile }\n+   { dg-options \"-O0 -Wall -Wuse-after-free=3\" } */\n+\n+\n+#if __cplusplus\n+#  define EXTERN_C extern \"C\"\n+#else\n+#  define EXTERN_C extern\n+#endif\n+\n+EXTERN_C void free (void*);\n+\n+void sink (void*);\n+\n+\n+void warn_double_free (void *p)\n+{\n+  free (p);\n+  free (p);         // { dg-warning \"pointer 'p' used\" }\n+}\n+\n+void warn_cond_double_free (void *p, int c)\n+{\n+  free (p);\n+  if (c)\n+    free (p);       // { dg-warning \"pointer 'p' may be used\" }\n+}\n+\n+void warn_call_after_free (void *p)\n+{\n+  free (p);\n+  sink (p);         // { dg-warning \"pointer 'p' used\" }\n+}\n+\n+void warn_cond_call_after_free (void *p, int c)\n+{\n+  free (p);\n+  if (c)\n+    sink (p);       // { dg-warning \"pointer 'p' may be used\" }\n+}\n+\n+void* warn_return_after_free (void *p)\n+{\n+  free (p);\n+  return p;         // { dg-warning \"pointer 'p' used\" }\n+}\n+\n+void* warn_cond_return_after_free (void *p, int c)\n+{\n+  free (p);\n+  if (c)\n+    return p;       // { dg-warning \"pointer 'p' may be used\" }\n+  return 0;\n+}\n+\n+void warn_relational_after_free (char *p, char *q[])\n+{\n+  free (p);\n+\n+  int a[] =\n+    {\n+     p < q[0],      // { dg-warning \"pointer 'p' used\" }\n+     p <= q[1],     // { dg-warning \"pointer 'p' used\" }\n+     p > q[2],      // { dg-warning \"pointer 'p' used\" }\n+     p >= q[3],     // { dg-warning \"pointer 'p' used\" }\n+     p == q[4],     // { dg-warning \"pointer 'p' used\" }\n+     p != q[5]      // { dg-warning \"pointer 'p' used\" }\n+    };\n+\n+  sink (a);\n+}\n+\n+void warn_cond_relational_after_free (char *p, char *q[], int c)\n+{\n+  free (p);\n+\n+  int a[] =\n+    {\n+     c ? p < q[0] : q[0][0],  // { dg-warning \"pointer 'p' may be used\" }\n+     c ? p <= q[1] : q[1][1], // { dg-warning \"pointer 'p' may be used\" }\n+     c ? p > q[2] : q[2][2],  // { dg-warning \"pointer 'p' may be used\" }\n+     c ? p >= q[3] : q[3][3], // { dg-warning \"pointer 'p' may be used\" }\n+     c ? p == q[4] : q[4][4], // { dg-warning \"pointer 'p' may be used\" }\n+     c ? p != q[5] : q[5][5], // { dg-warning \"pointer 'p' may be used\" }\n+    };\n+\n+  sink (a);\n+}\n+\n+\n+// Verify warning for the example in the manual.\n+\n+struct A { int refcount; void *data; };\n+\n+void release (struct A *p)\n+{\n+  int refcount = --p->refcount;\n+  free (p);\n+  if (refcount == 0)\n+    free (p->data); // { dg-warning \"pointer 'p' may be used\" }\n+}"}, {"sha": "634d3142f435493fb320639098d0cccb26430d9f", "filename": "gcc/testsuite/c-c++-common/Wuse-after-free.c", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWuse-after-free.c?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -0,0 +1,167 @@\n+/* Exercise basic cases of -Wuse-after-free without optimization.\n+   { dg-do compile }\n+   { dg-options \"-O0 -Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#if __cplusplus\n+#  define EXTERN_C extern \"C\"\n+#else\n+#  define EXTERN_C extern\n+#endif\n+\n+EXTERN_C void* alloca (size_t);\n+\n+EXTERN_C void* calloc (size_t, size_t);\n+EXTERN_C void* malloc (size_t);\n+\n+EXTERN_C void free (void*);\n+\n+\n+void sink (void *);\n+\n+extern void* evp;\n+extern void* evpa[];\n+\n+extern int ei;\n+\n+struct List { struct List *next; };\n+\n+void nowarn_free (void *vp, struct List *lp)\n+{\n+  {\n+    free (vp);\n+    vp = 0;\n+    sink (vp);\n+  }\n+  {\n+    free (evp);\n+    evp = 0;\n+    sink (evp);\n+  }\n+  {\n+    free (evpa[0]);\n+    evpa[0] = 0;\n+    sink (evpa[0]);\n+  }\n+  {\n+    void *vp = evpa[0];\n+    free (evpa[1]);\n+    sink (vp);\n+  }\n+  {\n+    void *p = evpa[1];\n+    if (ei & 1)\n+      free (p);\n+    if (ei & 2)\n+      sink (p);\n+  }\n+  {\n+    struct List *next = lp->next;\n+    free (lp);\n+    free (next);\n+  }\n+}\n+\n+void nowarn_free_arg (void *p, void *q)\n+{\n+  free (p);\n+  if (q)\n+    free (q);\n+}\n+\n+void nowarn_free_extern (void)\n+{\n+  extern void *ep, *eq;\n+  free (ep);\n+  ep = eq;\n+  free (ep);\n+}\n+\n+void nowarn_free_assign (void)\n+{\n+  extern void *ep;\n+  free (ep);\n+  ep = 0;\n+  free (ep);\n+}\n+\n+#pragma GCC diagnostic push\n+/* Verify that -Wuse-after-free works with #pragma diagnostic.  Note\n+   that the option name should not need to include a trailing =, even\n+   though it's a multi-level option.  (specifying the level after\n+   the option, as in \"-Wuse-after-free=2\", doesn't work.  */\n+#pragma GCC diagnostic ignored \"-Wuse-after-free\"\n+\n+void nowarn_double_free_suppressed (void *p)\n+{\n+  free (p);\n+  free (p);\n+}\n+\n+#pragma GCC diagnostic pop\n+\n+void warn_double_free_arg (void *p)\n+{\n+  free (p);                   // { dg-message \"call to '\\(void \\)?free\\(\\\\(void\\\\*\\\\)\\)?'\" \"note\" }\n+  // Verify exactly one warning is issued.\n+  free (p);                   // { dg-warning \"\\\\\\-Wuse-after-free\" }\n+                              // { dg-bogus \"\\\\\\-Wuse-after-free\" \"duplicate warning\" { target *-*-* } .-1 }\n+\n+}\n+\n+void warn_double_free_extern (void)\n+{\n+  /* GCC assumes free() clobbers global memory and the warning is\n+     too simplistic to see through that assumption.  */\n+  extern void *ep, *eq;\n+  {\n+    eq = ep;\n+    free (ep);                // { dg-message \"call to 'free'\" \"pr??????\" { xfail *-*-* } }\n+    free (eq);                // { dg-warning \"\\\\\\-Wuse-after-free\" \"pr??????\" { xfail *-*-* } }\n+  }\n+}\n+\n+void warn_deref_after_free (int *p, int i)\n+{\n+  int *q0 = p, *q1 = p + 1, *qi = p + i;\n+  free (p);                   // { dg-message \"call to '\\(void \\)?free\\(\\\\(void\\\\*\\\\)\\)?'\" \"note\" }\n+  *p = 0;                     // { dg-warning \"\\\\\\-Wuse-after-free\" }\n+\n+  *q0 = 0;                    // { dg-warning \"\\\\\\-Wuse-after-free\" }\n+  *q1 = 0;                    // { dg-warning \"\\\\\\-Wuse-after-free\" }\n+  *qi = 0;                    // { dg-warning \"\\\\\\-Wuse-after-free\" }\n+}\n+\n+void warn_array_ref_after_free (int *p, int i)\n+{\n+  free (p);                   // { dg-message \"call to '\\(void \\)?free\\(\\\\(void\\\\*\\\\)\\)?'\" \"note\" }\n+  p[i] = 0;                   // { dg-warning \"\\\\\\-Wuse-after-free\" }\n+}\n+\n+void nowarn_free_list (struct List *head)\n+{\n+  for (struct List *p = head, *q; p; p = q)\n+    {\n+      q = p->next;\n+      free (p);\n+    }\n+}\n+\n+void warn_free_list (struct List *head)\n+{\n+  struct List *p = head;\n+  for (; p; p = p->next)      // { dg-warning \"\\\\\\[-Wuse-after-free\" }\n+    free (p);                 // { dg-message \"call to '\\(void \\)?free\\(\\\\(void\\\\*\\\\)\\)?'\" \"note\" }\n+}\n+\n+\n+void warn_free (void *vp)\n+{\n+  {\n+    free (vp);                // { dg-message \"call to '\\(void \\)?free\\(\\\\(void\\\\*\\\\)\\)?'\" \"note\" }\n+    evp = vp;                 // { dg-warning \"-Wuse-after-free\" }\n+    evpa[0] = vp;             // { dg-warning \"-Wuse-after-free\" }\n+    evpa[1] = evp;\n+  }\n+}"}, {"sha": "05c7feef5c0f46e521973486961845d8f951f1df", "filename": "gcc/testsuite/g++.dg/warn/Wmismatched-dealloc-3.C", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-dealloc-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-dealloc-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-dealloc-3.C?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -0,0 +1,70 @@\n+/* Verify that passing a pointer to a deallocation function that was\n+   previously passed to a mismatched reallocation function is diagnosed\n+   by -Wmismatched-dealloc (and not by some other warning).\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+#define A(...) __attribute__ ((malloc (__VA_ARGS__)))\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern \"C\"\n+{\n+  void free (void *);\n+  void* realloc (void *, size_t);\n+}\n+\n+// User-defined allocator/deallocator just like like realloc.\n+                   int* int_realloc (size_t, int *);\n+A (int_realloc, 2) int* int_realloc (size_t, int *);\n+\n+\n+void sink (void *);\n+\n+\n+void* warn_realloc_op_delete (void *p)\n+{\n+  void *q = realloc (p, 5);   // { dg-message \"call to 'void\\\\* realloc\\\\(void\\\\*, size_t\\\\)'\" \"note\" }\n+\n+  operator delete (p);        // { dg-warning \"'void operator delete\\\\(void\\\\*\\\\)' called on pointer 'p' passed to mismatched allocation function 'void\\\\* realloc\\\\(void\\\\*, size_t\\\\)' \\\\\\[-Wmismatched-dealloc\" }\n+  return q;\n+}\n+\n+void* warn_realloc_op_delete_cond (void *p)\n+{\n+  void *q = realloc (p, 5);      // { dg-message \"call to 'void\\\\* realloc\\\\(void\\\\*, size_t\\\\)'\" \"note\" }\n+\n+  if (!q)\n+    operator delete (p);         // { dg-warning \"'void operator delete\\\\(void\\\\*\\\\)' called on pointer 'p' passed to mismatched allocation function 'void\\\\* realloc\\\\(void\\\\*, size_t\\\\)'\" }\n+  return q;\n+}\n+\n+void* warn_realloc_array_delete_char (char *p)\n+{\n+  char *q;\n+  q = (char*)realloc (p, 7);  // { dg-message \"call to 'void\\\\* realloc\\\\(void\\\\*, size_t\\\\)'\" \"note\" }\n+\n+  if (!q)\n+    delete[] (p);             // { dg-warning \"'void operator delete \\\\\\[]\\\\(void\\\\*\\\\)' called on pointer 'p' passed to mismatched allocation function 'void\\\\* realloc\\\\(void\\\\*, size_t\\\\)'\" }\n+  return q;\n+}\n+\n+\n+int* warn_int_realloc_op_delete (int *p)\n+{\n+  int *q;\n+  q = int_realloc (5, p);     // { dg-message \"call to 'int\\\\* int_realloc\\\\(size_t, int\\\\*\\\\)'\" \"note\" }\n+\n+  operator delete (p);        // { dg-warning \"'void operator delete\\\\(void\\\\*\\\\)' called on pointer 'p' passed to mismatched allocation function 'int\\\\* int_realloc\\\\(size_t, int\\\\*\\\\)' \\\\\\[-Wmismatched-dealloc\" }\n+  return q;\n+}\n+\n+\n+int* warn_int_realloc_free (int *p)\n+{\n+  int *q;\n+  q = int_realloc (5, p);    // { dg-message \"call to 'int\\\\* int_realloc\\\\(size_t, int\\\\*\\\\)'\" \"note\" }\n+\n+  free (p);                   // { dg-warning \"'void free\\\\(void\\\\*\\\\)' called on pointer 'p' passed to mismatched allocation function 'int\\\\* int_realloc\\\\(size_t, int\\\\*\\\\)' \\\\\\[-Wmismatched-dealloc\" }\n+  return q;\n+}"}, {"sha": "022bd8d39f95682ce7ada9499d44b239a7371a28", "filename": "gcc/testsuite/g++.dg/warn/Wuse-after-free.C", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWuse-after-free.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWuse-after-free.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWuse-after-free.C?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -0,0 +1,158 @@\n+/* Exercise basic C++ only cases of -Wuse-after-free without optimization.\n+   { dg-do compile }\n+   { dg-options \"-O0 -Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern \"C\" void free (void *);\n+extern \"C\" void* realloc (void *, size_t);\n+\n+void sink (void *);\n+\n+extern void* evp;\n+extern void* evpa[];\n+\n+extern int ei;\n+\n+struct List { struct List *next; };\n+\n+void nowarn_delete (void *vp, struct List *lp)\n+{\n+  {\n+    operator delete (vp);\n+    vp = 0;\n+    sink (vp);\n+  }\n+  {\n+    operator delete (evp);\n+    evp = 0;\n+    sink (evp);\n+  }\n+  {\n+    operator delete (evpa[0]);\n+    evpa[0] = 0;\n+    sink (evpa[0]);\n+  }\n+  {\n+    void *vp = evpa[0];\n+    operator delete (evpa[0]);\n+    sink (vp);\n+  }\n+  {\n+    void *p = evpa[1];\n+    if (ei & 1)\n+      operator delete (p);\n+    if (ei & 2)\n+      sink (p);\n+  }\n+  {\n+    struct List *next = lp->next;\n+    operator delete (lp);\n+    operator delete (next);\n+  }\n+}\n+\n+void nowarn_delete_arg (void *p, void *q)\n+{\n+  operator delete (p);\n+  if (q)\n+    operator delete (q);\n+}\n+\n+void nowarn_delete_extern (void)\n+{\n+  extern void *ep, *eq;\n+  operator delete (ep);\n+  ep = eq;\n+  operator delete (ep);\n+}\n+\n+void nowarn_delete_assign (void)\n+{\n+  extern void *ep;\n+  operator delete (ep);\n+  ep = 0;\n+  operator delete (ep);\n+}\n+\n+void warn_double_delete_arg (void *p)\n+{\n+  operator delete (p);        // { dg-message \"call to 'void operator delete\\\\(void\\\\*\\\\)'\" \"note\" }\n+  operator delete (p);        // { dg-warning \"\\\\\\-Wuse-after-free\" }\n+}\n+\n+void warn_delete_free_arg (void *p)\n+{\n+  operator delete (p);        // { dg-message \"call to 'void operator delete\\\\(void\\\\*\\\\)'\" \"note\" }\n+  free (p);                   // { dg-warning \"\\\\\\-Wuse-after-free\" }\n+}\n+\n+void warn_free_delete_arg (void *p)\n+{\n+  free (p);                   // { dg-message \"call to 'void free\\\\(void\\\\*\\\\)'\" \"note\" }\n+  operator delete (p);        // { dg-warning \"\\\\\\-Wuse-after-free\" }\n+}\n+\n+void warn_mismatched_double_delete_arg (void *p, void *q)\n+{\n+  operator delete (p);        // { dg-message \"call to 'void operator delete\\\\(void\\\\*\\\\)'\" \"note\" }\n+  operator delete[] (p);      // { dg-warning \"\\\\\\-Wuse-after-free\" }\n+\n+  operator delete[] (q);      // { dg-message \"call to 'void operator delete \\\\\\[]\\\\(void\\\\*\\\\)'\" \"note\" }\n+  operator delete (q);        // { dg-warning \"\\\\\\-Wuse-after-free\" }\n+}\n+\n+void warn_double_delete_extern (void)\n+{\n+  /* GCC assumes operator delete() clobbers global memory and the warning is\n+     too simplistic to see through that assumption.  */\n+  extern void *ep, *eq;\n+  {\n+    eq = ep;\n+    operator delete (ep);     // { dg-message \"call to 'operator delete'\" \"pr??????\" { xfail *-*-* } }\n+    operator delete (eq);     // { dg-warning \"\\\\\\-Wuse-after-free\" \"pr??????\" { xfail *-*-* } }\n+  }\n+}\n+\n+void warn_deref_after_delete (int *p, int i)\n+{\n+  int *q0 = p, *q1 = p + 1, *qi = p + i;\n+  operator delete (p);        // { dg-message \"call to 'void operator delete\\\\(void\\\\*\\\\)'\" \"note\" }\n+  *p = 0;                     // { dg-warning \"\\\\\\-Wuse-after-free\" }\n+\n+  *q0 = 0;                    // { dg-warning \"\\\\\\-Wuse-after-free\" }\n+  *q1 = 0;                    // { dg-warning \"\\\\\\-Wuse-after-free\" }\n+  *qi = 0;                    // { dg-warning \"\\\\\\-Wuse-after-free\" }\n+}\n+\n+void warn_array_ref_after_delete (int *p, int i)\n+{\n+  operator delete (p);        // { dg-message \"call to 'void operator delete\\\\(void\\\\*\\\\)'\" \"note\" }\n+  p[i] = 0;                   // { dg-warning \"\\\\\\-Wuse-after-free\" }\n+}\n+\n+void nowarn_delete_list (struct List *head)\n+{\n+  for (struct List *p = head, *q; p; p = q)\n+    {\n+      q = p->next;\n+      operator delete (p);\n+    }\n+}\n+\n+void warn_delete_list (struct List *head)\n+{\n+  struct List *p = head;\n+  for (; p; p = p->next)      // { dg-warning \"\\\\\\[-Wuse-after-free\" }\n+    operator delete (p);      // { dg-message \"call to 'void operator delete\\\\(void\\\\*\\\\)'\" \"note\" }\n+}\n+\n+void warn_delete (void *vp)\n+{\n+  {\n+    operator delete (vp);     // { dg-message \"call to 'void operator delete\\\\(void\\\\*\\\\)'\" \"note\" }\n+    evp = vp;                 // { dg-warning \"-Wuse-after-free\" }\n+    evpa[0] = vp;             // { dg-warning \"-Wuse-after-free\" }\n+    evpa[1] = evp;\n+  }\n+}"}, {"sha": "c303d2f1775f6d2c8a04fd9fe432e3a379db6699", "filename": "gcc/testsuite/gcc.dg/Wmismatched-dealloc-2.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fgcc.dg%2FWmismatched-dealloc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fgcc.dg%2FWmismatched-dealloc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWmismatched-dealloc-2.c?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -26,6 +26,7 @@ void dealloc (void*);\n A (dealloc) void* alloc (int);\n \n void sink (void*);\n+void* source (void);\n \n void test_alloc_A (void)\n {\n@@ -107,35 +108,35 @@ void test_realloc_A (void *ptr)\n }\n \n \n-void test_realloc (void *ptr)\n+void test_realloc (void)\n {\n   extern void free (void*);\n   extern void* realloc (void*, size_t);\n \n   {\n-    void *p = realloc (ptr, 1);\n+    void *p = realloc (source (), 1);\n     p = realloc_A (p, 2);\n     __builtin_free (p);\n   }\n \n   {\n-    void *p = realloc (ptr, 2);\n+    void *p = realloc (source (), 2);\n     p = realloc_A (p, 2);\n     free (p);\n   }\n \n   {\n-    void *p = realloc (ptr, 3);\n+    void *p = realloc (source (), 3);\n     free (p);\n   }\n \n   {\n-    void *p = realloc (ptr, 4);\n+    void *p = realloc (source (), 4);\n     __builtin_free (p);\n   }\n \n   {\n-    void *p = realloc (ptr, 5);         // { dg-message \"returned from 'realloc'\" }\n+    void *p = realloc (source (), 5);   // { dg-message \"returned from 'realloc'\" }\n     dealloc (p);                        // { dg-warning \"'dealloc' called on pointer returned from a mismatched allocation function\" }\n   }\n }"}, {"sha": "302900662cecf2a590905a22975363219b01c699", "filename": "gcc/testsuite/gcc.dg/Wmismatched-dealloc-3.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fgcc.dg%2FWmismatched-dealloc-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fgcc.dg%2FWmismatched-dealloc-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWmismatched-dealloc-3.c?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -157,6 +157,7 @@ void test_reallocarray (void *p)\n   }\n \n   {\n+    p = source ();\n     void *q = realloc (p, 1);\n     q = reallocarray (q, 2, 3);\n     sink (q);\n@@ -192,27 +193,31 @@ void test_reallocarray (void *p)\n   }\n \n   {\n+    p = source ();\n     void *q = reallocarray (p, 7, 8);\n     q = __builtin_realloc (q, 9);\n     sink (q);\n     free (q);\n   }\n \n   {\n+    p = source ();\n     void *q = reallocarray (p, 7, 8);\n     q = realloc (q, 9);\n     sink (q);\n     free (q);\n   }\n \n   {\n+    p = source ();\n     void *q = reallocarray (p, 8, 9);\n     q = reallocarray (q, 3, 4);\n     sink (q);\n     free (q);\n   }\n \n   {\n+    p = source ();\n     void *q = reallocarray (p, 9, 10);\n     q = reallocarray (q, 3, 4);\n     sink (q);"}, {"sha": "0f4bc5aa7af16440b6a2beb38eb9a3d9a82d9fc7", "filename": "gcc/testsuite/gcc.dg/analyzer/file-1.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffile-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffile-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffile-1.c?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -13,6 +13,9 @@ test_1 (const char *path)\n   /* { dg-message \"second 'fclose' here; first 'fclose' was at \\\\(5\\\\)\" \"second fclose\" { target *-*-* } .-1 } */\n }\n \n+/* Swallow -Wuse-after-free issued for the same problem\n+   { dg-prune-output \"-Wuse-after-free\" } */\n+\n void\n test_2 (const char *src, const char *dst)\n {"}, {"sha": "8d34c7390841c865d492e0a7aeda2170139e8ac2", "filename": "gcc/testsuite/gcc.dg/analyzer/file-2.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffile-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffile-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffile-2.c?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -16,3 +16,6 @@ void test (const char *path)\n   fclose (f.m_f);\n   fclose (f.m_f); /* { dg-warning \"double 'fclose' of FILE 'f.m_f'\" } */\n }\n+\n+/* Swallow -Wuse-after-free issued for the same problem\n+   { dg-prune-output \"-Wuse-after-free\" } */"}, {"sha": "e28057f900731d1d242c88aefb274e5a6ebee85a", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-6.c?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -5,7 +5,7 @@\n    -Walloc-larger-than=maximum.  */\n /* { dg-do compile } */\n /* { dg-require-effective-target alloca } */\n-/* { dg-options \"-O0 -Wall -Walloc-size-larger-than=12345\" } */\n+/* { dg-options \"-O0 -Wall -Walloc-size-larger-than=12345 -Wno-use-after-free\" } */\n \n #define MAXOBJSZ  12345\n "}, {"sha": "6c26935211ab8386e782e2c1be1f6684926cc2fb", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-7.c?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -4,7 +4,7 @@\n    of the maximum specified by -Walloc-size-larger-than=maximum.  */\n /* { dg-do compile } */\n /* { dg-require-effective-target alloca } */\n-/* { dg-options \"-O1 -Wall -Walloc-size-larger-than=12345\" } */\n+/* { dg-options \"-O1 -Wall -Walloc-size-larger-than=12345 -Wno-use-after-free\" } */\n \n #define SIZE_MAX   __SIZE_MAX__\n #define MAXOBJSZ   12345"}, {"sha": "24208f7b0f82145e9646d7932b55f8ac19909344", "filename": "libcpp/files.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/libcpp%2Ffiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/libcpp%2Ffiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ffiles.c?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -553,12 +553,11 @@ _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir,\n \t\t  {\n \t\t    /* If *hash_slot is NULL, the above\n \t\t       htab_find_slot_with_hash call just created the\n-\t\t       slot, but we aren't going to store there\n-\t\t       anything, so need to remove the newly created\n-\t\t       entry.  htab_clear_slot requires that it is\n-\t\t       non-NULL, so store there some non-NULL pointer,\n-\t\t       htab_clear_slot will overwrite it\n-\t\t       immediately.  */\n+\t\t       slot, but we aren't going to store there anything\n+\t\t       of use, so need to remove the newly created entry.\n+\t\t       htab_clear_slot requires that it is non-NULL, so\n+\t\t       store some non-NULL but valid pointer there,\n+\t\t       htab_clear_slot will immediately overwrite it.  */\n \t\t    *hash_slot = file;\n \t\t    htab_clear_slot (pfile->file_hash, hash_slot);\n \t\t  }\n@@ -582,7 +581,7 @@ _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir,\n \t\tif (*hash_slot == NULL)\n \t\t  {\n \t\t    /* See comment on the above htab_clear_slot call.  */\n-\t\t    *hash_slot = file;\n+\t\t    *hash_slot = &hash_slot;\n \t\t    htab_clear_slot (pfile->file_hash, hash_slot);\n \t\t  }\n \t\treturn NULL;"}, {"sha": "84af5276ae817bea902d1009df025daa49d32a1e", "filename": "libiberty/regex.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a283636de75f7ed638ee6b01ed2d44361b8b6/libiberty%2Fregex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a283636de75f7ed638ee6b01ed2d44361b8b6/libiberty%2Fregex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fregex.c?ref=671a283636de75f7ed638ee6b01ed2d44361b8b6", "patch": "@@ -30,6 +30,10 @@\n   #pragma alloca\n #endif\n \n+#if __GNUC__ >= 12\n+#  pragma GCC diagnostic ignored \"-Wuse-after-free\"\n+#endif\n+\n #undef\t_GNU_SOURCE\n #define _GNU_SOURCE\n "}]}