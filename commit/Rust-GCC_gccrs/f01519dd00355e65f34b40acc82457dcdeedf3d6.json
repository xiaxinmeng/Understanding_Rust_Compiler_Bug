{"sha": "f01519dd00355e65f34b40acc82457dcdeedf3d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAxNTE5ZGQwMDM1NWU2NWYzNGI0MGFjYzgyNDU3ZGNkZWVkZjNkNg==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2004-01-10T05:47:14Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2004-01-10T05:47:14Z"}, "message": "darwin-ldouble.c: Add big comment explaining exactly what is expected as a 'long double'.\n\n\t* config/rs6000/darwin-ldouble.c: Add big comment explaining\n\texactly what is expected as a 'long double'.\n\t(_xlqadd): When a value to be returned is representable as a\n\t'double', just return it directly, do not construct it using a union.\n\tAlso, correct final fixup.\n\t(_xlqmul): Likewise.\n\t(_xlqdiv): Likewise.\n\t* real.c (encode_ibm_extended): Make consistent with darwin-ldouble.c.\n\nFrom-SVN: r75629", "tree": {"sha": "d30bf7e4c2a8d092733cec701722dc75f1fb8112", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d30bf7e4c2a8d092733cec701722dc75f1fb8112"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f01519dd00355e65f34b40acc82457dcdeedf3d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f01519dd00355e65f34b40acc82457dcdeedf3d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f01519dd00355e65f34b40acc82457dcdeedf3d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f01519dd00355e65f34b40acc82457dcdeedf3d6/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "975421be9e4f094f3958c264cc7f793221d90d39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/975421be9e4f094f3958c264cc7f793221d90d39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/975421be9e4f094f3958c264cc7f793221d90d39"}], "stats": {"total": 135, "additions": 47, "deletions": 88}, "files": [{"sha": "367a26a3309b5fcfff20f044049956d126e9eb62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f01519dd00355e65f34b40acc82457dcdeedf3d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f01519dd00355e65f34b40acc82457dcdeedf3d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f01519dd00355e65f34b40acc82457dcdeedf3d6", "patch": "@@ -6,6 +6,15 @@\n \n 2004-01-09  Geoffrey Keating  <geoffk@apple.com>\n \n+\t* config/rs6000/darwin-ldouble.c: Add big comment explaining\n+\texactly what is expected as a 'long double'.\n+\t(_xlqadd): When a value to be returned is representable as a\n+\t'double', just return it directly, do not construct it using a union.\n+\tAlso, correct final fixup.\n+\t(_xlqmul): Likewise.\n+\t(_xlqdiv): Likewise.\n+\t* real.c (encode_ibm_extended): Make consistent with darwin-ldouble.c.\n+\n \t* config/rs6000/rs6000.md (fix_trunctfdi2): Delete.\n \n 2004-01-09  Richard Henderson  <rth@redhat.com>"}, {"sha": "c73b24f5270ff15fab7ac47272bc164660f17fa9", "filename": "gcc/config/rs6000/darwin-ldouble.c", "status": "modified", "additions": 23, "deletions": 43, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f01519dd00355e65f34b40acc82457dcdeedf3d6/gcc%2Fconfig%2Frs6000%2Fdarwin-ldouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f01519dd00355e65f34b40acc82457dcdeedf3d6/gcc%2Fconfig%2Frs6000%2Fdarwin-ldouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin-ldouble.c?ref=f01519dd00355e65f34b40acc82457dcdeedf3d6", "patch": "@@ -37,6 +37,17 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    Floating-Point Computations\", by Seppo Linnainmaa, ACM TOMS vol 7\n    no 3, September 1961, pages 272-283.  */\n \n+/* Each long double is made up of two IEEE doubles.  The value of the\n+   long double is the sum of the values of the two parts.  The most\n+   significant part is required to be the value of the long double\n+   rounded to the nearest double, as specified by IEEE.  For Inf\n+   values, the least significant part is required to be one of +0.0 or\n+   -0.0.  No other requirements are made; so, for example, 1.0 may be\n+   represented as (1.0, +0.0) or (1.0, -0.0), and the low part of a\n+   NaN is don't-care.\n+\n+   This code currently assumes big-endian.  */\n+\n #define fabs(x) __builtin_fabs(x)\n \n #define unlikely(x) __builtin_expect ((x), 0)\n@@ -68,11 +79,8 @@ _xlqadd (double a, double b, double c, double d)\n   FPR_zero = 0.0;\n   FPR_PosInf = FPKINF;\n \n-  if (unlikely (a != a) || unlikely (c != c)) {\n-    z.dval[0] = a + c;\t\t/* NaN result.\t*/\n-    z.dval[1] = a + c;\t\t/* NaN result.\t*/\n-    return z.ldval;\n-  }\n+  if (unlikely (a != a) || unlikely (c != c)) \n+    return a + c;  /* NaN result.  */\n \n   /* Ordered operands are arranged in order of their magnitudes.  */\n \n@@ -110,18 +118,14 @@ _xlqadd (double a, double b, double c, double d)\n   t = (tau + b) + a;\t     /* Sum values in ascending magnitude order.  */\n \n   /* Infinite or zero result.  */\n-  if (unlikely (fabs (t) == FPR_PosInf) || unlikely (t == FPR_zero))\n-    {\n-      z.dval[0] = t;\n-      z.dval[1] = t >= 0.0 ? (fabs (t) >= 0.0 ? t : 0.0) : -0.0;\n-      return z.ldval;\n-    }\n+  if (unlikely (t == FPR_zero) || unlikely (fabs (t) == FPR_PosInf))\n+    return t;\n \n   /* Usual case.  */\n   tau = (((a-t) + b) + c) + d;\n   u = t + tau;\n   z.dval[0] = u;\t       /* Final fixup for long double result.  */\n-  z.dval[1] = (u - t) + tau;\n+  z.dval[1] = (t - u) + tau;\n   return z.ldval;\n }\n \n@@ -142,22 +146,10 @@ _xlqmul (double a, double b, double c, double d)\n \n   t = a * c;\t\t\t/* Highest order double term.  */\n \n-  if (unlikely (t != t) || unlikely (t == FPR_zero)) \n-    {\n-      /* NaN or zero result.  */\n-      z.dval[0] = t;\n-      z.dval[1] = t;\n-      return z.ldval;\n-    }\n+  if (unlikely (t != t) || unlikely (t == FPR_zero) \n+      || unlikely (fabs (t) == FPR_PosInf))\n+    return t;\n \n-  if (unlikely (fabs(t) == FPR_PosInf))\n-    {\n-      /* Infinite result.  */\n-      z.dval[0] = t;\n-      z.dval[1] = t >= 0 ? 0.0 : -0.0;\n-      return z.ldval;\n-    }\n-  \n   /* Finite nonzero result requires summing of terms of two highest\n      orders.\t*/\n   \n@@ -170,7 +162,7 @@ _xlqmul (double a, double b, double c, double d)\n \n   /* Construct long double result.  */\n   z.dval[0] = u;\n-  z.dval[1] = (u - t) + tau;\n+  z.dval[1] = (t - u) + tau;\n   return z.ldval;\n }\n \n@@ -185,21 +177,9 @@ _xlqdiv (double a, double b, double c, double d)\n   \n   t = a / c;                    /* highest order double term */\n   \n-  if (unlikely (t != t) || unlikely (t == FPR_zero))\n-    {\n-      /* NaN or zero result.  */\n-      z.dval[0] = t;\n-      z.dval[1] = t;\n-      return z.ldval;\n-    }\n-\n-  if (unlikely (fabs (t) == FPR_PosInf))\n-    {\n-      /* Infinite result.  */\n-      z.dval[0] = t;\n-      z.dval[1] = t >= 0.0 ? 0.0 : -0.0;\n-      return z.ldval;\n-    }\n+  if (unlikely (t != t) || unlikely (t == FPR_zero) \n+      || unlikely (fabs (t) == FPR_PosInf))\n+    return t;\n \n   /* Finite nonzero result requires corrections to the highest order term.  */\n "}, {"sha": "ecee90bf40c1063d60d9372d7424dc5c756500a4", "filename": "gcc/real.c", "status": "modified", "additions": 15, "deletions": 45, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f01519dd00355e65f34b40acc82457dcdeedf3d6/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f01519dd00355e65f34b40acc82457dcdeedf3d6/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=f01519dd00355e65f34b40acc82457dcdeedf3d6", "patch": "@@ -3235,53 +3235,23 @@ encode_ibm_extended (const struct real_format *fmt, long *buf,\n \n   base_fmt = fmt->qnan_msb_set ? &ieee_double_format : &mips_double_format;\n \n-  switch (r->class)\n-    {\n-    case rvc_zero:\n-      /* Both doubles have sign bit set.  */\n-      buf[0] = FLOAT_WORDS_BIG_ENDIAN ? r->sign << 31 : 0;\n-      buf[1] = FLOAT_WORDS_BIG_ENDIAN ? 0 : r->sign << 31;\n-      buf[2] = buf[0];\n-      buf[3] = buf[1];\n-      break;\n-\n-    case rvc_inf:\n-    case rvc_nan:\n-      /* Both doubles set to Inf / NaN.  */\n-      encode_ieee_double (base_fmt, &buf[0], r);\n-      buf[2] = buf[0];\n-      buf[3] = buf[1];\n-      return;\n+  /* u = IEEE double precision portion of significand.  */\n+  u = *r;\n+  round_for_format (base_fmt, &u);\n+  encode_ieee_double (base_fmt, &buf[0], &u);\n \n-    case rvc_normal:\n-      /* u = IEEE double precision portion of significand.  */\n-      u = *r;\n-      clear_significand_below (&u, SIGNIFICAND_BITS - 53);\n-\n-      normalize (&u);\n-      /* If the upper double is zero, we have a denormal double, so\n-\t move it to the first double and leave the second as zero.  */\n-      if (u.class == rvc_zero)\n-\t{\n-\t  v = u;\n-\t  u = *r;\n-\t  normalize (&u);\n-\t}\n-      else\n-\t{\n-\t  /* v = remainder containing additional 53 bits of significand.  */\n-\t  do_add (&v, r, &u, 1);\n-\t  round_for_format (base_fmt, &v);\n-\t}\n-\n-      round_for_format (base_fmt, &u);\n-\n-      encode_ieee_double (base_fmt, &buf[0], &u);\n+  if (r->class == rvc_normal)\n+    {\n+      do_add (&v, r, &u, 1);\n+      round_for_format (base_fmt, &v);\n       encode_ieee_double (base_fmt, &buf[2], &v);\n-      break;\n-\n-    default:\n-      abort ();\n+    }\n+  else\n+    {\n+      /* Inf, NaN, 0 are all representable as doubles, so the\n+\t least-significant part can be 0.0.  */\n+      buf[2] = 0;\n+      buf[3] = 0;\n     }\n }\n "}]}