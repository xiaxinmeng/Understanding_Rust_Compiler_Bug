{"sha": "e0324e2629e25a90c13c68b4eef1e47b091970c3", "node_id": "C_kwDOANBUbNoAKGUwMzI0ZTI2MjllMjVhOTBjMTNjNjhiNGVlZjFlNDdiMDkxOTcwYzM", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2023-03-07T03:57:57Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2023-03-09T21:26:43Z"}, "message": "c++: allocator temps in list of arrays [PR108773]\n\nThe optimization to reuse the same allocator temporary for all string\nconstructor calls was breaking on this testcase, because the temps were\nalready in the argument to build_vec_init, and replacing them with\nreferences to one slot got confused with calls at multiple levels (for the\ninitializer_list backing array, and then again for the array member of the\nstd::array).  Fixed by reusing the whole TARGET_EXPR instead of pulling out\nthe slot; gimplification ensures that it's only initialized once.\n\nI also moved the check for initializing a std:: class down into the tree\nwalk, and handle multiple temps within a single array element\ninitialization.\n\n\tPR c++/108773\n\ngcc/cp/ChangeLog:\n\n\t* init.cc (find_allocator_temps_r): New.\n\t(combine_allocator_temps): Replace find_allocator_temp.\n\t(build_vec_init): Adjust.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/initlist-array18.C: New test.\n\t* g++.dg/cpp0x/initlist-array19.C: New test.", "tree": {"sha": "54d7347b1474a45b8c8a2278981c64b21feb9bec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54d7347b1474a45b8c8a2278981c64b21feb9bec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0324e2629e25a90c13c68b4eef1e47b091970c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0324e2629e25a90c13c68b4eef1e47b091970c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0324e2629e25a90c13c68b4eef1e47b091970c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0324e2629e25a90c13c68b4eef1e47b091970c3/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4214bdb1d77ebee04d12f66c831730ed67fedf55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4214bdb1d77ebee04d12f66c831730ed67fedf55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4214bdb1d77ebee04d12f66c831730ed67fedf55"}], "stats": {"total": 131, "additions": 110, "deletions": 21}, "files": [{"sha": "1b7d3d8fe3e01a7b705c7d185b8b8ea707bf69b7", "filename": "gcc/cp/init.cc", "status": "modified", "additions": 57, "deletions": 21, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0324e2629e25a90c13c68b4eef1e47b091970c3/gcc%2Fcp%2Finit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0324e2629e25a90c13c68b4eef1e47b091970c3/gcc%2Fcp%2Finit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.cc?ref=e0324e2629e25a90c13c68b4eef1e47b091970c3", "patch": "@@ -4330,8 +4330,54 @@ find_temps_r (tree *tp, int *walk_subtrees, void *data)\n   return NULL_TREE;\n }\n \n+/* walk_tree callback to collect temporaries in an expression that\n+   are allocator arguments to standard library classes.  */\n+\n+static tree\n+find_allocator_temps_r (tree *tp, int *walk_subtrees, void *data)\n+{\n+  vec<tree*> &temps = *static_cast<auto_vec<tree*> *>(data);\n+  tree t = *tp;\n+  if (TYPE_P (t))\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+\n+  /* If this is a call to a constructor for a std:: class, look for\n+     a reference-to-allocator argument.  */\n+  tree fn = cp_get_callee_fndecl_nofold (t);\n+  if (fn && DECL_CONSTRUCTOR_P (fn)\n+      && decl_in_std_namespace_p (TYPE_NAME (DECL_CONTEXT (fn))))\n+    {\n+      int nargs = call_expr_nargs (t);\n+      for (int i = 1; i < nargs; ++i)\n+\t{\n+\t  tree arg = get_nth_callarg (t, i);\n+\t  tree atype = TREE_TYPE (arg);\n+\t  if (TREE_CODE (atype) == REFERENCE_TYPE\n+\t      && is_std_allocator (TREE_TYPE (atype)))\n+\t    {\n+\t      STRIP_NOPS (arg);\n+\t      if (TREE_CODE (arg) == ADDR_EXPR)\n+\t\t{\n+\t\t  tree *ap = &TREE_OPERAND (arg, 0);\n+\t\t  if (TREE_CODE (*ap) == TARGET_EXPR)\n+\t\t    temps.safe_push (ap);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* If INIT initializes a standard library class, and involves a temporary\n-   std::allocator<T>, return a pointer to the temp.\n+   std::allocator<T>, use ALLOC_OBJ for all such temporaries.\n+\n+   Note that this can clobber the input to build_vec_init; no unsharing is\n+   done.  To make this safe we use the TARGET_EXPR in all places rather than\n+   pulling out the TARGET_EXPR_SLOT.\n \n    Used by build_vec_init when initializing an array of e.g. strings to reuse\n    the same temporary allocator for all of the strings.  We can do this because\n@@ -4341,22 +4387,18 @@ find_temps_r (tree *tp, int *walk_subtrees, void *data)\n    ??? Add an attribute to allow users to assert the same property for other\n    classes, i.e. one object of the type is interchangeable with any other?  */\n \n-static tree*\n-find_allocator_temp (tree init)\n+static void\n+combine_allocator_temps (tree &init, tree &alloc_obj)\n {\n-  if (TREE_CODE (init) == EXPR_STMT)\n-    init = EXPR_STMT_EXPR (init);\n-  if (TREE_CODE (init) == CONVERT_EXPR)\n-    init = TREE_OPERAND (init, 0);\n-  tree type = TREE_TYPE (init);\n-  if (!CLASS_TYPE_P (type) || !decl_in_std_namespace_p (TYPE_NAME (type)))\n-    return NULL;\n   auto_vec<tree*> temps;\n-  cp_walk_tree_without_duplicates (&init, find_temps_r, &temps);\n+  cp_walk_tree_without_duplicates (&init, find_allocator_temps_r, &temps);\n   for (tree *p : temps)\n-    if (is_std_allocator (TREE_TYPE (*p)))\n-      return p;\n-  return NULL;\n+    {\n+      if (!alloc_obj)\n+\talloc_obj = *p;\n+      else\n+\t*p = alloc_obj;\n+    }\n }\n \n /* `build_vec_init' returns tree structure that performs\n@@ -4694,13 +4736,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t  if (one_init)\n \t    {\n \t      /* Only create one std::allocator temporary.  */\n-\t      if (tree *this_alloc = find_allocator_temp (one_init))\n-\t\t{\n-\t\t  if (alloc_obj)\n-\t\t    *this_alloc = alloc_obj;\n-\t\t  else\n-\t\t    alloc_obj = TARGET_EXPR_SLOT (*this_alloc);\n-\t\t}\n+\t      combine_allocator_temps (one_init, alloc_obj);\n \t      finish_expr_stmt (one_init);\n \t    }\n "}, {"sha": "8c0f316789df69f5daa110234375edc53719ae2b", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist-array18.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0324e2629e25a90c13c68b4eef1e47b091970c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-array18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0324e2629e25a90c13c68b4eef1e47b091970c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-array18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-array18.C?ref=e0324e2629e25a90c13c68b4eef1e47b091970c3", "patch": "@@ -0,0 +1,30 @@\n+// PR c++/108773\n+// { dg-do compile { target c++11 } }\n+\n+#include <initializer_list>\n+\n+namespace std {\n+struct __new_allocator {};\n+struct allocator : __new_allocator {};\n+template <typename T>\n+struct basic_string {\n+  basic_string(const T *, allocator = allocator());\n+  ~basic_string();\n+};\n+using string = basic_string<char>;\n+template <typename T>\n+struct array {\n+  T _M_elems;\n+};\n+template <typename T>\n+struct list {\n+  list &operator=(initializer_list<T>);\n+};\n+}\n+struct RGWSyncTraceManager {\n+  std::list<std::array<std::string>> admin_commands;\n+  void hook_to_admin_command();\n+};\n+void RGWSyncTraceManager::hook_to_admin_command() {\n+  admin_commands = {{\"\"}, {\"\"}};\n+}"}, {"sha": "1ede5d77339513a2fa83501647cac63469c2d4b6", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist-array19.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0324e2629e25a90c13c68b4eef1e47b091970c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-array19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0324e2629e25a90c13c68b4eef1e47b091970c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-array19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-array19.C?ref=e0324e2629e25a90c13c68b4eef1e47b091970c3", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/108773\n+// { dg-do compile { target c++20 } }\n+\n+#include <initializer_list>\n+\n+namespace std {\n+template <typename _Tp, int _Nm> struct array {\n+  _Tp _M_elems[_Nm];\n+};\n+template <typename _Tp> struct list { void operator=(initializer_list<_Tp>); };\n+struct allocator {};\n+struct basic_string {\n+  int _M_p;\n+  constexpr basic_string() {}\n+  basic_string(const char *, const allocator & = allocator());\n+  ~basic_string();\n+};\n+} // namespace std\n+\n+std::list<std::array<std::basic_string, 3>> stuff;\n+void foo() {\n+  stuff = {{\"\", \"\"}, {\"\", \"\"}};\n+}"}]}